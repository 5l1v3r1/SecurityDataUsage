 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| SMV is a third generation privilege separation technique that of- fers explicit access control of memory and allows concurrent threads within the same process to partially share or fully isolate their memory space in a controlled and parallel man- ner following application requirements An evaluation of our prototype in the Linux kernel (TCB < 1,800 LOC) shows negligible runtime performance overhead in real-world ap- plications including Cherokee web server (< 069%), Apache httpd web server (< 093%), and Mozilla Firefox web browser (< 1|,Non-data,35
|89%) with at most 12 LOC changes 1 INTRODUCTION Ideally, software components are separated logically into small fault compartments, so that a defect in one compo- nent cannot compromise the others This concept of privi- lege separation [35, 36] protects confidentiality and integrity of data (and code) that should only be accessible from small trusted components|,Non-data,35
| However, most applications use a sin- gle address space, shared among all components and threads Redesigning all legacy multithreaded applications to use pro- cesses for isolation is impractical Today’s software, such as web servers and browsers, enhances its functionality through Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page Copyrights for components of this work owned by others than ACM must be honored|,Non-data,35
| Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acmorg|,Non-data,35
| CCS’16, October 24-28, 2016, Vienna, Austria c(cid:13) 2016 ACM ISBN 978-1-4503-4139-4/16/10  |,Non-data,35
 $1500 DOI: http://dxdoiorg/10,Non-data,35
|1145/29767492978327 libraries, modules, and plugins that are developed indepen- dently by various third-parties Failing to properly separate privileges in applications and confine software components in terms of their memory spaces leaves a system vulnerable to attacks such as privilege escalation, denial-of-service, buffer overflows, and control-flow hijacking, jeopardizing both the stability and the security of the system Many proposals exist for privilege separation in a mono- lithic application|,Non-data,35
 The first generation privilege separation techniques focus on splitting a process into different single- process compartments Provos et al [33] presented an intra- process privilege separation case study by manually parti- tioning OpenSSH components into privileged master pro- cesses and unprivileged slave processes Privtrans [9] au- tomated the partitioning procedure,Non-data,35
| Wedge [8] then intro- duced capabilities to privilege separation and Salus [40] en- abled a dynamic security policy Unfortunately, all these techniques cannot support multithreaded compartments Second generation privilege separation techniques like Ar- biter [47] aimed to support multithreaded applications by allowing concurrent thread execution However, Arbiter’s implementation for separating memory space and its serial- ized user-level memory management impose prohibitive run- time overhead (200% – 400% for memory operations)|,Non-data,35
| As a result, the thread execution is not fully concurrent since all threads must wait on a global barrier to tag memory pages for capabilities In addition, the required retrofitting efforts for legacy software are non-trivial, as the case stud- ies showed that at least hundreds of lines of code (LOC) changes are required to separate software components even for applications that have small code base sizes (8K LOC) We postulate that a third generation privilege separation technique for achieving intra-process isolation in monolithic multithreaded applications such as the Cherokee web server, Apache httpd, and the Mozilla Firefox web browser, needs to fulfill the following requirements (which are only partially addressed by existing solutions) for wide adoption: - Genericity and flexibility (GF): Implementing privilege separation in different types of applications requires pro- grammers to employ completely different abstractions and concepts A general model with a universal interface and isolation concept that supports both client- and server- side multithreaded applications is needed (e|,Non-data,35
|g, compart- ments in the Firefox browser, worker buffers in Cherokee web server, worker pools in Apache httpd web server) 393Problem tackled Non-parallel privilege separation 1st gen technique Issue vs solution OpenSSH [33] Privtrans [9] Wedge [8] Security principal Parallel execution Process Not handled Not handled Single thread Not handled Not handled Static Compiler, OS Annotations OpenSSH etc Static OS Tool assisted OpenSSH etc|,Non-data,35
| Parallel tagging Security policy TCB Process Not handled Not handled Static OS Refactoring efforts Fully manual Use cases OpenSSH 2nd gen technique 3rd gen technique Concurrent execution and Concurrent memory operations dynamic security policy and high performance Arbiter [47] Multiple threads Partially handled Not handled Dynamic Library, OS SMV (This paper) Multiple threads Yes Yes Dynamic OS (<1800 LOC) Fully manual(>100 ∆ LOC) Library assisted(<20 ∆ LOC) FUSE (8K LOC) etc Firefox (13M LOC) etc Salus [40] Single thread Not handled Not handled Dynamic Library, OS Tool assisted PolarSSL Table 1: Issues and solutions for intra-process privilege separation techniques - Ease of use (EU): Programmers prefer to realize their de- sired security policy in a model with a high-level API rather than through low-level error-prone memory man- agement tools without intra-process capabilities (e|,Non-data,35
|g, mmap, shmem) In particular, porting legacy software to a new model has to be easy despite the complexity of component interweaving and the underlying assumption of shared memory (e|,Non-data,35
|g, Firefox, which contains 13M LOC), and should be possible with minimal code refactoring efforts - No hardware modifications (NH): Over-privileged multi- threaded applications are pervasive A model that is ready to run on today’s commodity hardware (even re- gardless of the CPU brands/models) is necessary for wide deployment|,Non-data,35
| - Low runtime overhead (LO): Monitoring application mem- ory accesses at high frequency is unrealistic for practical systems A practical model must be implemented in a way that incurs only negligible runtime overheads In particu- lar, enhanced security should not sacrifice the parallelism in multithreaded applications A model has to support se- lective memory isolation for multiple computing entities (i|,Non-data,35
|e, multiple threads can exercise the same privilege to parallelize a given workload and perform highly parallel memory operations) To address the above challenges, we propose a third gen- eration privilege separation solution for monolithic applica- tions: secure memory views (SMVs) – a model and archi- tecture that efficiently enforces differential security and fault isolation policies in monolithic multithreaded applications at negligible overheads SMV protects applications from neg- ligent or malicious memory accesses between software com- ponents|,Non-data,35
| In short, the intrinsically shared process address space is divided into a dynamic set of memory protection domains A thread container SMV maintains a collection of memory protection domains that define the memory view for its associated threads Access privileges to the memory protection domains are explicitly defined in the SMVs and the associated SMVthreads must strictly follow the defined security policies The SMV model provides a well-defined interface for programmers to exercise the least privilege prin- ciple for arbitrary software objects “inside” a multithreaded process|,Non-data,35
| For example, a server’s worker thread can be con- figured to allow access to its thread stack and part of the global server configuration but not to the private key that resides within the same process address space With the SMV model, the programmer can enforce dif- ferent access permissions for different components in a sin- gle address space (GF) New software can leverage the full API and can be designed to only share data along a well- defined API, and existing software can be retrofitted (with minimal code changes) by instrumenting calls across com- ponent boundaries to change the underlying memory view (EU) Moreover, the privilege enforcement relies on OS ker- nel level page table manipulation and standard hardware virtual memory protection mechanisms (NH)|,Non-data,35
| Therefore, the SMV model does not suffer from the performance overheads (LO) imposed by IPC (vs in-memory communication), user level memory management (vs kernel level), or per-instruction reference monitors (vs hardware trap) The SMV model’s programmability and efficient privilege enforcement mecha- nism allow it to protect both client- and server-side multi- threaded applications with low overhead We implemented a prototype of the SMV model in the Linux kernel Our evaluation demonstrates (a) its negligi- ble runtime overhead in the presence of high concurrency using multithreaded benchmarks that employ the general producer-consumer pattern, and (b) the immediate benefit of efficient software component isolation by compartmen- talizing client connections for the popular Cherokee and Apache httpd web servers and the compartments in the Fire- fox web browser|,Non-data,35
| SMVs incur only around 2% runtime overhead overall with 2 LOC changes for the multithreaded benchmark PARSEC, 069% throughput overhead with 2 LOC changes for Cherokee, 093% throughput overhead with 2 LOC changes for Apache httpd, and 189% runtime over- head with only 12 LOC changes for the Firefox web browser|,Non-data,35
| Note that SMV focuses on restricting memory views for in- dividual threads, access permissions for kernel APIs is an orthogonal problem that is well covered by, eg, AppAr- mor [4], SELinux [39], or the seccomp framework [38] In summary, this paper makes the following contribu- tions: Design of the SMV model which provides threads with fine- grained control over privileges for a shared address space|,Non-data,35
| Specification of an SMV API for programmers that facili- tates porting existing pthread applications Implementation of the SMV model that consists of a trusted Linux kernel component (implementing enforcement) and the corresponding untrusted user-space library that im- plement the SMV API, which is publicly available along with our benchmarks and test suite1 Evaluation of our prototype implementation showing that SMVs achieve all four desired requirements as a practical and efficient model for enforcing least privilege memory views for multithreaded applications in practice 1https://github|,Non-data,35
|com/terry-hsu/smv 3942 THREAT MODEL AND OBJECTIVES Threat model We assume that the attacker, an unpriv- ileged user without root permissions, can control a thread in a vulnerable multithreaded program, allocate memory, and fork more threads up to resource limits on a trusted kernel with sound hardware The adversary will try to es- calate privileges through the attacker-controlled threads or gain control of another thread, e|,Non-data,35
|g, by reading or writing data of another module or executing code of another mod- ule In this model, the adversary may read or write any data that the controlled thread has access to The adver- sary may also attempt to bypass protection domains by ex- ploiting race conditions between threads or by leveraging confused deputy attacks, e|,Non-data,35
|g, through the API exported by other threads We assume that the OS kernel is not com- promised (OS kernel security is an orthogonal topic [24]) and user-space libraries installed by root users are trusted We assume that the access permissions both of the memory views (enforced through SMV) and for the kernel (enforced through AppArmor, SELinux, or seccomp) are set correctly|,Non-data,35
|ABSTRACT Contemporary vehicles are getting equipped with an increasing number of Electronic Control Units (ECUs) and wireless connec- tivities Although these have enhanced vehicle safety and effi- ciency, they are accompanied with new vulnerabilities In this pa- per, we unveil a new important vulnerability applicable to several in-vehicle networks including Control Area Network (CAN), the de facto standard in-vehicle network protocol Specifically, we propose a new type of Denial-of-Service (DoS), called the bus- off attack, which exploits the error-handling scheme of in-vehicle networks to disconnect or shut down good/uncompromised ECUs|,Non-data,37
| This is an important attack that must be thwarted, since the attack, once an ECU is compromised, is easy to be mounted on safety- critical ECUs while its prevention is very difficult In addition to the discovery of this new vulnerability, we analyze its feasibility using actual in-vehicle network traffic, and demonstrate the attack on a CAN bus prototype as well as on two real vehicles Based on our analysis and experimental results, we also propose and evaluate a mechanism to detect and prevent the bus-off attack 1|,Non-data,37
| INTRODUCTION New security breaches in vehicles are emerging due to software- driven Electronic Control Units (ECUs) and wireless connectivi- ties of modern vehicles These trends have introduced more remote surfaces/endpoints that an adversary can exploit and, in the worst case, control the vehicle remotely Researchers have demonstrated how vulnerabilities in remote endpoints can be exploited to com- promise an ECU, access the in-vehicle network, and then control vehicle maneuvers [5, 10, 12] In 2015, researchers were able to compromise and remotely kill a Jeep Cherokee running on a high- way [13], which triggered a recall of 1|,Non-data,37
|4 million vehicles Such a reality of vehicle cyber attacks has made vehicle security one of the most critical issues to be addressed To detect and prevent vehicle cyber attacks, various types of se- curity solutions, such as Message Authentication Code (MAC) and Intrusion Detection Systems (IDSs) for in-vehicle networks — akin to those in the Internet security — have been proposed [8, 14, 17, 21] These solutions provide a certain level of security, but there Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page|,Non-data,37
| Copyrights for components of this work owned by others than ACM must be honored Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acm|,Non-data,37
|org CCS’16, October 24-28, 2016, Vienna, Austria c(cid:2) 2016 ACM ISBN 978-1-4503-4139-4/16/10 |,Non-data,37
  $1500 DOI: http://dxdoi,Non-data,37
|org/101145/29767492978302 still remain critical, uncovered vulnerabilities specific to the auto- motive domain We propose a new type of Denial-of-Service (DoS) attack called the bus-off attack which, ironically, exploits the error-handling scheme of in-vehicle networks|,Non-data,37
| That is, their fault-confinement mechanism — which has been considered as one of their major advantages in providing fault-tolerance and robustness — is used as an attack vector The attacker periodically injects attack mes- sages to the in-vehicle network, deceives an uncompromised ECU into thinking it is defective, and eventually forces itself or even the whole network to shut down In addition to its severe conse- quences, the following unique characteristics of the proposed bus- off attack differentiate itself from previously known attacks and make it a critical threat which must be countered 1|,Non-data,37
| The bus-off attack is easy to mount since the attacker is not required to reverse-engineer messages (ie, figure out the meaning/purpose of messages) or their checksum algorithms for launching it Thus, the attacker can easily mount the at- tack on various vehicles regardless of their manufacturer or model|,Non-data,37
| This is in sharp contrast to previously demonstrated attacks, which required painstaking reverse-engineering pro- cedures in order to take control of a vehicle [10, 12, 13] 2 As the symptoms of the bus-off attack resemble those of sys- tem errors such as improper termination [4], bit flip [22], and bit drop [15], it deceives state-of-the-art IDSs to think the network is erroneous, while it is actually under attack 3|,Non-data,37
| Although MACs for in-vehicle network messages may thwart most of the previously known attacks, they cannot prevent the proposed bus-off attack since it nullifies their functionalities That is, not only contemporary insecure in-vehicle networks but also prospective security-enhanced ones will still be vulnerable to the bus-off attack 4 Since the attack relies solely on low-level safety features of in-vehicle networks, it is independent of actual implementa- tion subtleties of different ECUs|,Non-data,37
| Among the various in-vehicle network protocols, we focus on the vulnerability of the Control Area Network (CAN) protocol, which is the de facto standard for in-vehicle networks The feasibility of the bus-off attack is, however, not limited to CAN but applicable to other in-vehicle network protocols, which are discussed further in Section 8 In this paper, we will primarily focus on what an adversary can do with a compromised ECU, rather than how the ECU was compromised in the first place, which has been covered well elsewhere [5, 7, 10, 12, 13] This paper makes the following main contributions: • Discovery of a new Denial-of-Service threat — bus-off at- tack — on in-vehicle networks which exploits their error- handling mechanism as an attack vector; 1044the proof of the practicability of the bus-off attack; • Analysis and characterization of real CAN bus traffic, and • Implementation and demonstration of the bus-off attack on a • Development and evaluation of a countermeasure that can CAN bus prototype and on two real vehicles; and detect and prevent the bus-off attack|,Non-data,37
| The rest of the paper is organized as follows Section 2 provides the required background on CAN, and Section 3 details the pro- posed bus-off attack Section 4 discusses the feasibility of the at- tack and Section 5 evaluates the attack on a CAN bus prototype and real vehicles Section 6 discusses the limitations of state-of-the-art solutions in preventing the bus-off attack, and Section 7 details a new defense mechanism against it|,Non-data,37
| Section 8 discusses further the severity of the bus-off attack as well as its applicability to other in-vehicle networks Finally, we conclude the paper in Section 9 2 PRIMER ON CAN For completeness, we first review the main features of CAN re- lated to the proposed attack|,Non-data,37
 21 CAN Frames CAN interconnects ECUs/nodes through a message broadcast bus Each node broadcasts periodic (and occasionally sporadic) data frames on the CAN bus to provide retrieved data The trans- mitted data is received by one or more nodes on the bus and then utilized for maintaining data consistency and for vehicle control decisions,Non-data,37
| Frame format Each CAN frame is basically a sequence of dominant (0) and recessive (1) bits, and belongs to one of four dif- ferent types: data frame which is used for sending retrieved data; remote frame for requesting transmission of a specified message; error frame used to indicate detected errors via error flags; and overload frame to inject delay between frames Fig 1 shows the base format of a CAN data frame|,Non-data,37
| A data frame can carry up to 8 bytes of data, the length of which is specified in the 4-bit Data Length Code (DLC) For most passenger cars, a 1-byte checksum of each message is contained in the last byte of its data field [13] Although the checksum is not part of the CAN specification, car manufacturers implement it using their own algorithms to provide an additional layer of protection to the CAN Cyclic Redundancy Check (CRC) Consecutive transmissions of CAN frames are sep- arated by a 3-bit Inter-frame Space (IFS)|,Non-data,37
| Message ID Instead of containing the transmitter/receiver ad- dress, a CAN frame contains a unique ID, which represents its pri- ority and meaning For example, a frame containing wheel speed values might have ID=0x01 and frame containing battery temper- ature values might have ID=0x20 Only one ECU is assigned to transmit a given ID at a time, and the ID values are defined to be distinct from each other by the manufacturer|,Non-data,37
| The base frame for- mat has an 11-bit ID, whereas an extended format has a 29-bit ID Since the use of base format is much more prevalent, we focus on the base format in this paper Note, however, that the attack model proposed in this paper is not dependent on the type of format 2|,Non-data,37
|2 Arbitration Once the CAN bus is detected idle, a node with data to trans- mit, starts its frame transmission (Tx) by issuing a Start-of-Frame (SOF) SOF provides hard synchronization between ECUs to make bitwise transmission and reception feasible At that time, one or more other nodes may also have buffered data to transmit, and may thus concurrently access the bus In such a case, the CAN protocol resolves the access contention via arbitration|,Non-data,37
| (cid:18)(cid:20)(cid:21)(cid:22)(cid:14)(cid:20)(cid:13)(cid:14)(cid:22)(cid:23)(cid:24) (cid:1) (cid:2) (cid:3) (cid:4)(cid:5) (cid:12)(cid:23)(cid:24)(cid:14)(cid:20)(cid:23)(cid:17) (cid:6) (cid:9) (cid:10) (cid:5)(cid:11)(cid:12) (cid:6) (cid:7) (cid:6) (cid:4) (cid:5) (cid:8) (cid:5)(cid:13)(cid:14)(cid:13) (cid:5)(cid:13)(cid:14)(cid:13) (cid:12)(cid:6)(cid:12) (cid:18)(cid:12)(cid:19) (cid:12)(cid:6)(cid:12) (cid:12)(cid:6)(cid:12)(cid:15) (cid:5)(cid:16)(cid:17) (cid:18) (cid:12) (cid:19) (cid:18)(cid:12)(cid:19)(cid:15) (cid:5)(cid:16)(cid:17) (cid:8)(cid:2)(cid:3) (cid:27)(cid:3)(cid:24)(cid:8)(cid:12)(cid:6)(cid:28)(cid:28)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24) (cid:29)(cid:30)(cid:2)(cid:8)(cid:19)(cid:11)(cid:8)(cid:11)(cid:6)(cid:12)(cid:6)(cid:31)(cid:32)(cid:33)(cid:31)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24) (cid:34)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24) (cid:35)(cid:36)(cid:37)(cid:34)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24) (cid:28)(cid:38)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24) (cid:39)(cid:6)(cid:16)(cid:14)(cid:2)(cid:24)(cid:6)(cid:22)(cid:1)(cid:21)(cid:21)(cid:6)(cid:28)(cid:24)(cid:26) Figure 1: Format of a CAN data frame (cid:32)(cid:33)(cid:34) (cid:35)(cid:36) (cid:29)(cid:37)(cid:29) (cid:27) (cid:27) (cid:27) (cid:27) (cid:28) (cid:28) (cid:27) (cid:27) (cid:28) (cid:27) (cid:28) (cid:27) (cid:27) (cid:27) (cid:28) (cid:27) (cid:27) (cid:27) (cid:28) (cid:28) (cid:22)(cid:29)(cid:30)(cid:6)(cid:31)(cid:10)(cid:11)(cid:8)(cid:26) (cid:7)(cid:12)(cid:13)(cid:14)(cid:15)(cid:12)(cid:16)(cid:15)(cid:14)(cid:3)(cid:17)(cid:6)(cid:18)(cid:3)(cid:11)(cid:15) (cid:27) (cid:27) (cid:28) (cid:27) (cid:27) (cid:28) (cid:27) (cid:28) (cid:27) (cid:27) (cid:27) (cid:28) (cid:27) (cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7) (cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:8) (cid:9)(cid:7)(cid:2)(cid:6) (cid:8)(cid:10)(cid:11) Figure 2: Example of CAN arbitration phase During transmission, each node sends its frame one bit at a time and monitors the actual output on the CAN bus In the arbitra- tion phase, since frame IDs are unique and the CAN bus logically behaves as a wired-AND gate (e|,Non-data,37
|g, 0 & 1 = 0), some contending nodes would see a dominant (0) bit even though it has transmit- ted a recessive (1) bit In such a case, they lose arbitration, with- draw from bus contention, and switch to receiver mode In the end, only one arbitration-winner node is allowed to continuously access the bus for data transmission|,Non-data,37
| This process enables higher- priority frames (ie, lower IDs) to be transmitted before lower- priority ones Once the arbitration winner has completed trans- mission of its frame ending with an End-of-Frame (EOF), after a 3-bit time of IFS, the bus becomes free again for access, i|,Non-data,37
|e, idle At that time, nodes that have buffered data or had previously lost arbitration, start another round of arbitration for access For com- pleteness, we illustrate in Fig|,Non-data,37
| 2 how arbitration is done in CAN 23 Error Handling Error handling is built in the CAN protocol and is important for its fault-tolerance It aims to detect errors in CAN frames and en- ables ECUs to take appropriate actions, such as discarding a frame, retransmitting a frame, and raising error flags|,Non-data,37
| The CAN protocol defines no less than 5 different ways of detecting errors [3] • Bit Error: Every transmitter compares its transmitted bit with the output bit on the CAN bus If the two are different, a bit error has occurred, except during arbitration • Stuff Error: After every five consecutive bits of the same po- larity, an opposite polarity bit is stuffed for maintaining soft synchronization|,Non-data,37
| Violation of this incurs a stuff error • CRC Error: If the calculated CRC is different from the re- • Form Error: If the fixed-form bit fields (eg, CRC delimiter, ACK delimiter, EOF, IFS) contain at least one illegal bit, a form error has incurred|,Non-data,37
| • ACK Error: When a node transmits a message, any node that has received it issues a dominant bit in the ACK slot If none replies, an ACK error is raised ceived CRC, a CRC error is raised Error counters|,Non-data,37
| For any detected errors, the perceived node transmits an error frame on the bus and increases one of the two error counters it maintains: Transmit Error Counter (TEC) and Re- ceive Error Counter (REC) There are several rules governing the 1045(cid:26)(cid:12)(cid:1)(cid:4)(cid:27)(cid:4)(cid:28)(cid:29)(cid:30)(cid:4)(cid:31)(cid:7)(cid:6)(cid:32)(cid:4)(cid:33)(cid:12)(cid:1)(cid:4)(cid:27)(cid:4)(cid:28)(cid:29)(cid:30) (cid:12)(cid:6)(cid:6)(cid:7)(cid:6)(cid:4) (cid:2)(cid:9)(cid:8)(cid:17)(cid:19)(cid:20) (cid:12)(cid:6)(cid:6)(cid:7)(cid:6)(cid:4) (cid:5)(cid:14)(cid:21)(cid:21)(cid:17)(cid:19)(cid:20) (cid:26)(cid:12)(cid:1)(cid:4)(cid:37)(cid:4)(cid:28)(cid:29)(cid:30)(cid:4)(cid:31)(cid:14)(cid:15)(cid:16)(cid:32)(cid:4)(cid:33)(cid:12)(cid:1)(cid:4)(cid:37)(cid:4)(cid:28)(cid:29)(cid:30) (cid:33)(cid:20)(cid:21)(cid:20)(cid:8) (cid:31)(cid:2)(cid:23)(cid:8)(cid:7)(cid:35)(cid:36)(cid:14)(cid:15)(cid:23)(cid:14)(cid:10)(cid:32) (cid:26)(cid:12)(cid:1)(cid:4)(cid:27)(cid:4)(cid:29)(cid:34)(cid:34) (cid:22)(cid:23)(cid:21)(cid:4)(cid:24)(cid:25)(cid:25) (cid:7)(cid:11)(cid:20)(cid:3)(cid:5)(cid:11)(cid:13)(cid:5)(cid:3)(cid:21)(cid:22) (cid:15)(cid:21)(cid:22)(cid:5)(cid:11)(cid:21)(cid:23) (cid:26)(cid:13)(cid:5)(cid:13) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:2) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:1) (cid:2) (cid:3)(cid:4)(cid:4)(cid:5)(cid:4)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:6) (cid:4)(cid:9)(cid:11)(cid:12)(cid:13)(cid:14)(cid:6)(cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:18)(cid:19)(cid:11)(cid:20) (cid:24)(cid:34)(cid:15)(cid:17)(cid:1)(cid:35) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:2) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:1) (cid:24)(cid:25)(cid:21)(cid:17)(cid:13)(cid:11)(cid:20)(cid:3)(cid:5)(cid:11)(cid:13)(cid:5)(cid:3)(cid:21)(cid:22)(cid:17)(cid:25)(cid:3)(cid:22)(cid:22)(cid:10)(cid:11)(cid:12) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:2) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) (cid:1) (cid:1) (cid:1) (cid:1) (cid:1) (cid:3)(cid:4)(cid:4)(cid:5)(cid:4)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:6) (cid:4)(cid:9)(cid:11)(cid:12)(cid:13)(cid:14) (cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:18)(cid:19)(cid:11)(cid:20) (cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:6) (cid:1)(cid:2)(cid:3) (cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:11)(cid:14) (cid:1)(cid:4)(cid:3) (cid:15)(cid:7)(cid:16)(cid:17) (cid:18)(cid:19)(cid:12) (cid:18)(cid:19)(cid:12)(cid:17)(cid:20)(cid:10)(cid:4)(cid:21)(cid:6)(cid:10)(cid:12)(cid:17)(cid:36)(cid:8)(cid:23)(cid:10) (cid:18)(cid:3)(cid:5)(cid:17)(cid:10)(cid:11)(cid:11)(cid:21)(cid:11)(cid:17)(cid:13)(cid:5)(cid:17)(cid:27)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:6)(cid:28) (cid:29)(cid:30)(cid:31)(cid:32)(cid:33) Figure 3: State diagram of fault confinement in CAN Figure 4: Example of a bus-off attack increase/decrease of these counters, but in essence, a node that de- tects an error during transmission increases TEC by 8, whereas if perceived during reception, REC is increased by 1 [3]|,Non-data,37
| Moreover, for any error-free transmission and reception, TEC and REC are decreased by 1, respectively Fault confinement To confine serious errors disrupting bus communications, each ECU’s error mode is managed as in Fig 3|,Non-data,37
| All ECUs start in an Error-active mode and switch between differ- ent modes depending on their TEC and REC values When TEC or REC exceeds 127 due to consecutive errors, the node becomes Error-passive, and only returns to its initial state when both go be- low 128 When TEC exceeds the limit of 255, the corresponding ECU — which must have triggered many transmit errors — enters the Bus-off mode Upon entering this mode, to protect the CAN bus from continuously being distracted, the error-causing ECU is forced to shut down and not participate in sending/receiving data on the CAN bus at all|,Non-data,37
| It can be restored back to its original error- active mode, either automatically or manually However, since bus- off is usually an indication of serious network errors and may not be fixed by mere automatic re-initialization of the CAN controller, a user-intervened recovery or even a controlled shut-down of the entire system is recommended [18] Bus-off recovery The reasons for such different options are 1) the bus-off recovery mechanism depends on the software stack be- ing used, i|,Non-data,37
|e, how the system is designed by the manufacturer, and 2) ECUs have different ASILs (Automotive Safety Integrity Lev- els) Since the bus-off is a serious problem, in most cases, vehi- cle systems are designed to first enter a “limp home” mode (when it occurs) with all their parameters set to pre-set values, and thus run with reduced functionality (eg|,Non-data,37
|, limited engine RPM) In this mode, warning lamps are lit up on the dashboard to alert the driver, and the vehicle runs only for some time before it is properly ser- viced by an OEM-authorized service center Depending on the severity of the underlying issue, ie|,Non-data,37
|, which ECU was shut down, a vehicle in the limp home mode will later be totally disabled Error flags When an error is detected, the perceived node in- dicates to others on the bus via an error flag, which comes in two forms: active and passive For any perceived errors, nodes that are in error-active mode issue an active error flag which consists of 6 dominant bits|,Non-data,37
| So, the transmitted frame causes other nodes to vi- olate the bit-stuffing rule, transmit their own error frame caused by the stuff error, and terminate any on-going transmissions or recep- tions For nodes that are in error-passive mode, they operate in the same way as error-active ones, except that they issue a passive error flag which consists of 6 recessive bits and have an 11 (not 3) bit-time of IFS if they were the transmitter of the previous message [3] An error-passive node tries to signal its passive error flag until it actu- ally observes 6 recessive bits on the bus, ie|,Non-data,37
|, an indication of the error flag being properly sent Since recessive bits are overwrit- ten on the CAN bus by dominant bits, the thus-issued passive error flags may persist until the end of a frame 3 ATTACK MODEL We first discuss the adversary model under consideration, and then uncover a new vulnerability of in-vehicle networks|,Non-data,37
 31 Adversary Model We consider an adversary whose objective is to shut down un- compromised (healthy) in-vehicle ECUs with a minimal number of message injections Such an objective precludes other types of at- tacks (eg,Non-data,37
|, flooding) which, albeit their greater impact, require a large number of message injections and are thus easier to be de- tected In Section 8, we will discuss more on such attacks, high- lighting the severity of the bus-off attack As in previously dis- cussed attacks [5, 10, 12, 13], we assume that the adversary can physically/remotely compromise an in-vehicle ECU through nu- merous attack surfaces and means, and thus gain its control In contrast, we do not require the adversary under consideration to reverse-engineer messages or checksums in order to achieve its goal of shutting down an ECU|,Non-data,37
| Since the messages and the im- plemented checksum algorithms are different for different vehicle manufacturers and models, such reverse-engineering can be very painstaking, when the adversary wants to mount attacks on differ- ent vehicles Once an ECU is compromised, we consider the adversary to be capable of performing at least the following malicious actions The adversary can inject any message with forged ID, DLC, and data on the bus as they are managed at user level Also, since CAN is a broadcast bus, the adversary can sniff messages on CAN|,Non-data,37
| Restric- tions of message filters are detailed in Section 42 These are the basic capabilities of an adversary who has the control of a compro- mised ECU Practicability of such an adversary model has already been proved and demonstrated in [5, 10, 12]|,Non-data,37
| 32 Bus-off Attack We now introduce the bus-off attack which exploits the follow- ing feature of CAN: CAN’s error handling automatically isolates defective or “misbehaving” ECUs — whose TEC>255 — into bus- off mode Specifically, by iteratively injecting attack messages, the adversary coerces the TEC of an uncompromised/healthy victim ECU to continuously increase — deceiving it to think it is defec- tive — and in the end, triggers the CAN fault confinement to force the victim or even the entire network to shut down Increasing the victim’s TEC|,Non-data,37
| Suppose message M is periodi- cally sent by some victim ECU V Then, an adversary A can suc- ceed in a bus-off attack by injecting an attack message, which sat- isfies the following conditions 1046(cid:1)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5) (cid:15)(cid:2)(cid:4)(cid:14)(cid:16)(cid:10)(cid:10)(cid:17)(cid:10) (cid:27)(cid:26) (cid:22)(cid:16)(cid:23)(cid:24)(cid:14)(cid:25)(cid:1)(cid:26) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:15) (cid:7)(cid:8)(cid:8)(cid:9)(cid:8)(cid:10)(cid:11)(cid:12)(cid:13)(cid:14) (cid:5)(cid:18)(cid:23)(cid:20)(cid:21)(cid:17)(cid:10)(cid:11)(cid:12)(cid:13)(cid:14) (cid:24)(cid:30)(cid:30)(cid:30)(cid:30)(cid:30)(cid:30)(cid:27) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:5) (cid:2)(cid:5)(cid:6)(cid:5)(cid:5) (cid:27)(cid:26) (cid:22)(cid:16)(cid:23)(cid:24)(cid:14)(cid:25)(cid:1)(cid:26) (cid:7)(cid:8)(cid:8)(cid:9)(cid:8)(cid:10)(cid:11)(cid:12)(cid:13)(cid:14) (cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:10)(cid:13)(cid:14) (cid:18)(cid:4)(cid:19)(cid:20)(cid:20)(cid:21)(cid:15)(cid:2)(cid:4)(cid:14)(cid:16)(cid:10)(cid:10)(cid:17)(cid:10) (cid:16)(cid:16)(cid:10)(cid:8)(cid:17)(cid:18)(cid:17)(cid:19)(cid:19)(cid:20)(cid:21)(cid:17)(cid:10)(cid:22)(cid:20)(cid:23)(cid:19) (cid:24)(cid:7)(cid:8)(cid:8)(cid:9)(cid:8)(cid:10)(cid:2)(cid:17)(cid:12)(cid:10)(cid:25)(cid:10)(cid:1)(cid:11)(cid:26)(cid:27)(cid:10) (cid:27)(cid:26) (cid:22)(cid:16)(cid:23)(cid:24)(cid:14)(cid:26)(cid:1)(cid:28)(cid:29) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:15) (cid:7)(cid:8)(cid:8)(cid:9)(cid:8)(cid:10)(cid:11)(cid:12)(cid:13)(cid:14) (cid:24)(cid:28)(cid:17)(cid:6)(cid:29)(cid:27) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:5) (cid:24)(cid:28)(cid:17)(cid:6)(cid:29)(cid:27) (cid:2)(cid:5)(cid:6)(cid:5)(cid:5) (cid:1) (cid:27)(cid:26) (cid:22)(cid:16)(cid:23)(cid:24)(cid:14)(cid:26)(cid:1)(cid:28)(cid:29) (cid:7)(cid:8)(cid:8)(cid:9)(cid:8)(cid:10)(cid:11)(cid:12)(cid:13)(cid:14) (cid:1) (a) Phase 1 – Victim in error-active mode (cid:29)(cid:29)(cid:19)(cid:22)(cid:12)(cid:17)(cid:12)(cid:28)(cid:28)(cid:23)(cid:24)(cid:12)(cid:19)(cid:30)(cid:23)(cid:20)(cid:28) (cid:10)(cid:1)(cid:9)(cid:25)(cid:19)(cid:31)(cid:21)(cid:22)(cid:19)(cid:7)(cid:22)(cid:22)(cid:21)(cid:22)(cid:32)(cid:33)(cid:16)(cid:28)(cid:28)(cid:23)(cid:24)(cid:12)(cid:19)(cid:34)(cid:21)(cid:35)(cid:12)(cid:28)(cid:19) (cid:36)(cid:37)(cid:23)(cid:17)(cid:37)(cid:19)(cid:36)(cid:12)(cid:22)(cid:12)(cid:19)(cid:20)(cid:37)(cid:12)(cid:19)(cid:33)(cid:22)(cid:12)(cid:24)(cid:23)(cid:21)(cid:38)(cid:28)(cid:19)(cid:6)(cid:13)(cid:12)(cid:22)(cid:14) (cid:29)(cid:26) (cid:1)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5) (cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:10)(cid:13)(cid:14) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:15) (cid:10)(cid:11)(cid:12)(cid:6)(cid:13)(cid:14) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:5) (cid:10)(cid:11)(cid:12)(cid:6)(cid:13)(cid:14) (cid:19)(cid:21)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:1)(cid:24)(cid:27)(cid:28) (cid:10)(cid:36)(cid:16)(cid:23)(cid:20)(cid:14) (cid:7)(cid:22)(cid:22)(cid:21)(cid:22)(cid:19)(cid:9)(cid:26)(cid:16)(cid:40) (cid:27)(cid:16)(cid:28)(cid:28)(cid:23)(cid:24)(cid:12)(cid:19)(cid:9)(cid:26)(cid:16)(cid:40) (cid:31)(cid:24) (cid:19)(cid:21)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:1)(cid:24)(cid:25)(cid:30) (cid:1) (cid:7)(cid:8)(cid:9) (cid:2)(cid:5)(cid:6)(cid:5)(cid:5) (cid:15)(cid:16)(cid:3)(cid:3)(cid:9)(cid:11)(cid:11)(cid:17)(cid:16)(cid:18)(cid:14)(cid:19)(cid:20) (cid:10)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:20)(cid:21)(cid:19)(cid:7)(cid:22)(cid:22)(cid:21)(cid:22)(cid:19)(cid:5)(cid:17)(cid:20)(cid:23)(cid:24)(cid:12)(cid:14) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:15) (cid:10)(cid:11)(cid:12)(cid:6)(cid:13)(cid:14) (cid:31)(cid:24) (cid:19)(cid:21)(cid:22)(cid:23)(cid:14)(cid:24)(cid:27)(cid:28)(cid:1)(cid:24)(cid:27)(cid:32) (cid:2)(cid:5)(cid:6)(cid:5)(cid:15) (cid:1) (cid:7)(cid:8)(cid:9) (cid:15)(cid:16)(cid:3)(cid:3)(cid:9)(cid:11)(cid:11)(cid:17)(cid:16)(cid:18)(cid:14)(cid:19)(cid:20) (cid:10)(cid:25)(cid:20)(cid:23)(cid:26)(cid:26)(cid:19)(cid:7)(cid:22)(cid:22)(cid:21)(cid:22)(cid:19)(cid:27)(cid:16)(cid:28)(cid:28)(cid:23)(cid:24)(cid:12)(cid:14) (cid:39) (cid:22)(cid:12)(cid:17)(cid:12)(cid:28)(cid:28)(cid:23)(cid:24)(cid:12)(cid:19)(cid:30)(cid:23)(cid:20)(cid:28) (cid:10)(cid:1)(cid:9)(cid:25)(cid:19)(cid:31)(cid:21)(cid:22)(cid:19)(cid:7)(cid:22)(cid:22)(cid:21)(cid:22)(cid:32)(cid:16)(cid:17)(cid:20)(cid:23)(cid:24)(cid:12)(cid:19)(cid:34)(cid:21)(cid:35)(cid:12)(cid:28)(cid:14) (b) Transition from Phase 1 to 2|,Non-data,37
 (cid:34)(cid:34)(cid:19)(cid:20)(cid:12)(cid:28)(cid:12)(cid:24)(cid:24)(cid:17)(cid:25)(cid:12)(cid:19)(cid:29)(cid:17)(cid:16)(cid:24) (cid:10)(cid:1)(cid:9)(cid:15)(cid:19)(cid:30)(cid:21)(cid:20)(cid:19)(cid:7)(cid:20)(cid:20)(cid:21)(cid:20)(cid:31)(cid:35)(cid:23)(cid:24)(cid:24)(cid:17)(cid:25)(cid:12)(cid:19)(cid:32)(cid:21)(cid:33)(cid:12)(cid:24)(cid:19) (cid:36)(cid:37)(cid:17)(cid:28)(cid:37)(cid:19)(cid:36)(cid:12)(cid:20)(cid:12)(cid:19)(cid:16)(cid:37)(cid:12)(cid:19)(cid:35)(cid:20)(cid:12)(cid:25)(cid:17)(cid:21)(cid:38)(cid:24)(cid:19)(cid:6)(cid:13)(cid:12)(cid:20)(cid:14) (cid:26)(cid:27) (cid:29)(cid:3)(cid:34)(cid:9)(cid:7)(cid:30)(cid:32)(cid:9)(cid:7)(cid:14) (cid:15)(cid:10)(cid:12)(cid:35)(cid:11)(cid:5)(cid:2)(cid:11)(cid:11)(cid:2)(cid:36)(cid:35) (cid:1)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:26) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:5) (cid:15)(cid:16)(cid:17)(cid:18)(cid:14)(cid:19)(cid:20)(cid:21)(cid:1)(cid:19)(cid:22)(cid:20) (cid:10)(cid:36)(cid:23)(cid:17)(cid:16)(cid:14) (cid:7)(cid:20)(cid:20)(cid:21)(cid:20)(cid:19)(cid:9)(cid:18)(cid:23)(cid:39) (cid:22)(cid:23)(cid:24)(cid:24)(cid:17)(cid:25)(cid:12)(cid:19)(cid:9)(cid:18)(cid:23)(cid:39) (cid:28)(cid:19) (cid:15)(cid:16)(cid:17)(cid:18)(cid:14)(cid:19)(cid:23)(cid:24)(cid:1)(cid:19)(cid:23)(cid:25) (cid:1) (cid:7)(cid:8)(cid:9) (cid:2)(cid:5)(cid:6)(cid:5)(cid:5) (cid:1)(cid:2) (cid:2)(cid:3)(cid:4)(cid:26) (cid:10)(cid:11)(cid:12)(cid:6)(cid:13)(cid:14) (cid:28)(cid:19) (cid:15)(cid:16)(cid:17)(cid:18)(cid:14)(cid:19)(cid:22)(cid:20)(cid:1)(cid:19)(cid:22)(cid:23) (cid:1) (cid:7)(cid:8)(cid:9) (cid:2)(cid:5)(cid:6)(cid:5)(cid:26) (cid:29)(cid:30)(cid:3)(cid:3)(cid:9)(cid:11)(cid:11)(cid:31)(cid:30)(cid:32)(cid:14)(cid:15)(cid:33) (cid:10)(cid:15)(cid:16)(cid:17)(cid:18)(cid:18)(cid:19)(cid:7)(cid:20)(cid:20)(cid:21)(cid:20)(cid:19)(cid:22)(cid:23)(cid:24)(cid:24)(cid:17)(cid:25)(cid:12)(cid:14) (cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:10)(cid:13)(cid:14) (cid:29)(cid:30)(cid:3)(cid:3)(cid:9)(cid:11)(cid:11)(cid:31)(cid:30)(cid:32)(cid:14)(cid:15)(cid:33) (cid:27) (cid:20)(cid:12)(cid:28)(cid:12)(cid:24)(cid:24)(cid:17)(cid:25)(cid:12)(cid:19)(cid:29)(cid:17)(cid:16)(cid:24) (cid:10)(cid:1)(cid:9)(cid:15)(cid:19)(cid:30)(cid:21)(cid:20)(cid:19)(cid:7)(cid:20)(cid:20)(cid:21)(cid:20)(cid:31)(cid:23)(cid:28)(cid:16)(cid:17)(cid:25)(cid:12)(cid:19)(cid:32)(cid:21)(cid:33)(cid:12)(cid:24)(cid:14) (c) Phase 2 – Victim in error-passive mode Figure 5: Two phases of bus-off attack C1 ID – Same ID as message M; C2,Non-data,37
| Timing – Transmitted at the same time as M; and C3 Contents – Having at least one bit position in which it is dominant (0), whereas it is recessive (1) in M All preceding bits should be the same as M To describe the general attack model, for now we assume that the adversary can transmit a message that satisfies C1–C3|,Non-data,37
| Details of how and why C1–C3 can be met will be discussed in Section 4 As shown in Fig 4, when the bus becomes idle, not only the vic- tim transmits message M but also the adversary transmits an attack message satisfying C1–C3 So, not one but two transmitters — A and V sending messages with identical IDs — win arbitration, and thus concurrently send their bit values of control, data, etc|,Non-data,37
|, on the bus The two nodes’ bitwise transmissions are synchronized in virtue of hard and soft synchronizations Since the attack message meets C3, V sees an opposite polarity on the bus to the one it trans- mitted (this happens after an arbitration) As a result, the victim V experiences a bit error forced by A, thus increasing its TEC by 8|,Non-data,37
| By repeating this bus-off attack on the victim’s messages, the adversary can make the victim’s TEC to continuously increase, and force the victim to enter bus-off mode and disconnect from the bus Although the victim is error-free in transmitting messages other than the targeted one, since TEC increases by 8 upon detection of each error but decreases only by 1 for each error-free transmission, an iterative bus-off attack rapidly increases the victim’s TEC The entire process of an iterative bus-off attack consists of the following two phases Phase 1 – Victim in error-active|,Non-data,37
| Both adversary and victim nodes start in their default mode, error-active After observing mes- sages on the CAN bus, the adversary targets one of them for a bus- off attack We refer to such a message as the target message and its transmitter as the victim As mentioned earlier, the adversary then injects its attack message at the same time as the target message to increase the victim’s TEC|,Non-data,37
| Thus, as shown in Fig 5(a), the victim experiences bit error, transmits an active error flag, and increases its TEC by 8 Since an active error flag consists of 6 consecutive dominant bits (ie|,Non-data,37
|, 000000), either a stuff or bit error is triggered at the adversary node, and its TEC also increases by 8 After the er- ror delimiter and IFS, the CAN controllers of the adversary and the victim automatically retransmit the Tx-failed messages again at the same time So, the exact same bit error recurs until they both enter error-passive mode What is significant about the attack in Phase 1 is that the adversary can coerce the victim to become error-passive with just one message injection|,Non-data,37
| Phase 1 to 2 After 16 (re)transmissions, as shown in Fig 5(b), both the adversary and the victim become error-passive when their TEC=128 Again, for the retransmitted message, bit error occurs at the victim node|,Non-data,37
| However, since the victim is now in error-passive mode, it attempts to deliver a passive error flag which consists of 6 recessive bits At that time, since the adversary transmits its frame, the attempt to deliver the error flag will persist until the adversary’s EOF In contrast to Phase 1, the adversary node experiences no er- ror and thus succeeds in transmitting its frame, whereas the victim will succeed later during its retransmission In total, due to a bit error (+8) and a successful retransmission (−1), the victim’s TEC changes 128 → 136 → 135, whereas the adversary’s changes 128 → 127|,Non-data,37
| Accordingly, the adversary returns to error-active, while the victim remains error-passive Up to this point, all but the first change in TEC are achieved via automatic retransmissions by the CAN controller, ie, the controller does it all for the attacker! Phase 2 – Victim in error-passive|,Non-data,37
| Fig 5(c) illustrates Phase 2 of the bus-off attack in which only the victim is error-passive Once the scheduled interval of the target message has elapsed, the victim again transmits that message, and thus at the same time, the adver- sary re-injects its attack message Since the victim is still in error- passive mode, as it was the case when transitioning from Phase 1 to 2, the adversary can decrease its TEC further by 1|,Non-data,37
| On the other hand, the victim’s TEC is again increased by 7 (= +8 − 1), thus keeping the victim in error-passive mode In Phase 2, the adversary iterates this process for every periodically transmitted target mes- sage until the victim is eventually forced to bus off, ie, TEC>255|,Non-data,37
| This implies that the periodicities of the attack and the target mes- sages are the same As a result, the victim ECU becomes discon- nected, and in the worst case, the entire network shuts down [18] Although CAN messages’ ID values do not contain information on their actual transmitters, their values and intervals together im- ply the messages’ priority and safety-criticality That is, if the at- tacker targets a message sent with high priority (i|,Non-data,37
|e, a low ID value) and small message intervals, then the attacker would most likely disconnect a safety-critical ECU that sends important messages re- lated to, for example, vehicle acceleration or braking Alternative bus-off attacks The adversary may attempt to it- erate this process for not only every periodic transmission but also every retransmission (as in Phase 1)|,Non-data,37
| However, as shown in Fig 5(c), since error-passive nodes, which were the transmitter of the previous message, have a longer IFS than error-active nodes, the adversary cannot synchronize its injection timing with the victim’s retransmission, thus failing to mount the attack Yang [23] reported that an uncovered fatal error can sometimes occur due to a misspecification of CAN; if a new frame is trans- mitted on the bus during the error delimiter subsequent to a passive error flag issued by an error-passive node, a form error incurs to that node, thus increasing its TEC If the adversary were to exploit such an inherent specification error in CAN to mount a bus-off at- 1047(cid:22)(cid:23) (cid:3)(cid:20)(cid:20)(cid:14)(cid:27)(cid:8)(cid:28) (cid:22)(cid:24) (cid:3)(cid:20)(cid:20)(cid:14)(cid:27)(cid:8)(cid:28) (cid:22)(cid:23) (cid:13)(cid:3)(cid:14)(cid:2)(cid:6)(cid:25) (cid:22)(cid:24) (cid:13)(cid:3)(cid:14)(cid:2)(cid:6)(cid:25) (cid:22)(cid:26) (cid:3)(cid:20)(cid:20)(cid:14)(cid:27)(cid:8)(cid:28) (cid:32)(cid:10)(cid:28)(cid:8)(cid:28)(cid:6)(cid:3)(cid:20)(cid:16)(cid:14)(cid:2)(cid:20)(cid:3)(cid:2)(cid:14)(cid:10)(cid:19)(cid:6) (cid:2)(cid:10)(cid:6)(cid:22)(cid:24) (cid:22)(cid:23) (cid:22)(cid:24) (cid:29)(cid:30)(cid:31) (cid:29)(cid:30)(cid:31) (cid:3)(cid:8)(cid:9)(cid:10)(cid:4)(cid:2) (cid:3)(cid:8)(cid:9)(cid:10)(cid:4)(cid:5) (cid:1)(cid:2)(cid:3)(cid:4) (cid:5)(cid:6)(cid:7) (cid:1)(cid:6) (cid:3)(cid:17)(cid:17)(cid:4)(cid:18)(cid:10)(cid:19) (cid:1) (cid:22)(cid:26) (cid:22)(cid:26) (cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:6) (cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:11)(cid:14) (cid:1)(cid:6) (cid:3)(cid:17)(cid:17)(cid:4)(cid:18)(cid:10)(cid:19) (cid:1) (cid:23) (cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7) (cid:8)(cid:9)(cid:10)(cid:11)(cid:3)(cid:12)(cid:10)(cid:13)(cid:6)(cid:14)(cid:12)(cid:6)(cid:15)(cid:16) (cid:15) (cid:20)(cid:21)(cid:22) (cid:21)(cid:3)(cid:14)(cid:17)(cid:4)(cid:24)(cid:3)(cid:5)(cid:10)(cid:13)(cid:6) (cid:25)(cid:15)(cid:17)(cid:10)(cid:24)(cid:10)(cid:13)(cid:10)(cid:13)(cid:6)(cid:20)(cid:9)(cid:26) (cid:23)(cid:5)(cid:5)(cid:3)(cid:24)(cid:27)(cid:6)(cid:28)(cid:19)(cid:29) s D I  d e d e c e r P  t c n i t s d i  f o  r e b m u N 12 10 8 6 4 2 0 20 23 B2 223 224 3B7 4C3 B4 CAN ID (Hex) Figure 6: Example of preceded IDs|,Non-data,37
| Figure 7: Fabricated preceded ID Figure 8: Distinct preceded IDs tack, it may be simpler to coerce the victim to bus off However, the occurrence of that fatal error depends on what type of new frame is transmitted at that time as well as how high the bus load is|,Non-data,37
| Note that it would be very difficult for an adversary to control such fac- tors That is, it is too restrictive for the attacker to achieve the bus- off attack in that way By contrast, we propose and discuss a more general method for mounting the bus-off attack, ie|,Non-data,37
|, succeeding the attack under any bus condition 4 FEASIBILITY OF BUS-OFF ATTACK To mount the bus-off attack, the adversary has to inject an at- tack message that satisfies conditions on ID, timing, and contents We now discuss how and why each condition can be met, in the ascending order of difficulty|,Non-data,37
| 41 Different Contents To trigger a bit error at the victim and increase its TEC, the at- tack message must first satisfy C3: having at least one bit position in which its signal is dominant (0), whereas the victim’s is recessive (1), and all preceding bits are identical Since the bus-off attack also requires the attack and target messages to have the same ID (ie|,Non-data,37
|, C1 – identical arbitration fields), the mismatch in C3 must occur in ei- ther the control or the data field Note that this is infeasible in other fields such as CRC and ACK, because they are determined by the CAN controller, not by the user/adversary Since CAN messages normally have DLC set to at least 1 and non-zero data values, one simple but most definite way for the adversary to cause a mismatch is to set the attack message’s DLC or data values to all 0s Also, given that DLC for each CAN ID is usually constant over time, the attacker can learn the value and set its attack message’s DLC accordingly|,Non-data,37
| This way, the adversary can satisfy C3 42 Same ID The next difficult task is to meet C1, which requires the attack message to have the same ID as the target That is, the adversary must know in advance the ID used by the target message|,Non-data,37
| The fact that favors the adversary is that CAN is a broadcast bus sys- tem However, each ECU cannot acquire the IDs of all received messages except those passed through its message filter We dis- tinguish a received message from an accepted message, depending on whether it passed through the filter and then arrived at a user- level application Since an adversary can read contents only from accepted messages, meeting C1 depends on how the filter is set at the compromised ECU|,Non-data,37
| Empty message filter Some ECUs in vehicles have almost, if not completely, empty message filters so that they can receive, ac- cept, and process almost all messages on the bus, thus making it trivial to satisfy C1 A typical example of these ECUs is the telem- atic unit, which has to operate in that way to provide a broad range of features, eg|,Non-data,37
|, remote diagnostics, anti-theft Another interest- ing aspect of this ECU is that, from a security viewpoint, it is re- garded as one of the most vulnerable ECUs due to its wide range of external/remote attack surfaces Note that several researchers have already shown the practicability of compromising the telem- atic unit [5, 7, 10, 12] So, this implies that an adversary can com- promise some empty filter ECUs more easily than those with non- empty filters, thus satisfying C1|,Non-data,37
| Non-empty message filter Although the message filter of a compromised ECU is preset to accept messages with only a few different IDs, it does not restrict the adversary in attacking them Furthermore, by directly modifying the message filter, the adver- sary can also mount the attack on messages that would usually have been filtered out The two most common CAN controllers — Microchip MCP2515 and NXP SJA1000 — both allow modifica- tion and disabling of message filters through software commands, when the ECU is in configuration mode [1, 2]|,Non-data,37
| For ECUs with the Microchip MCP2515 CAN controller, the configuration mode can be entered not only upon power-up or reset but also via user in- structions through the Serial Peripheral Interface (SPI) Through the SPI, it is also possible for the user to read/write the CAN con- troller registers, including the filter register [1] Thus, such user- level features for configuring the CAN controller allow attackers to easily enter configuration mode via software commands, and mod- ify/disable the message filters, thus satisfying C1 4|,Non-data,37
|3 Tx Synchronization Even though the adversary knows the ID and contents to use for his attack message, he should also know exactly when to send it Unless the adversary is capable of sending the attack message at the same time as the target message, not only once but iteratively, he would fail to cause a bit error, or increase the victim’s TEC Difficulties in synchronizing the Tx timing C2 requires the transmission of the attack and the target messages to be synchro- nized with less than a bit resolution|,Non-data,37
| If the attack timing is wrong by even one bit, there won’t be two arbitration winners and the attack would thus fail For synchronizing the timing of its transmission, the adversary may utilize the fact that CAN messages are usually sent at fixed intervals For example, once the adversary learns that the target message is sent every T ms, it can attempt to transmit its attack message when T ms has elapsed since the target’s last trans- mission However, such an approach would be inaccurate due to jitters|,Non-data,37
| Since jitters make the actual message periodicities deviate from their preset values [9], albeit leveraging message periodicity to fulfill C2, the attacker would have difficulties in synchronizing the transmission of its attack message with the target’s Preceded ID In order to overcome these difficulties, the adver- sary can exploit another fact of CAN: nodes, which have either lost arbitration or had new messages buffered while the bus was busy, attempt to transmit their messages as soon as the bus becomes idle We define a preceded ID of M as the ID of the message that has 1048completed its transmission right before the start of M’s|,Non-data,37
| Consider an example where node A transmits messages with ID=M1, M2, and node B transmits a message with ID=M3 which has the lowest priority among them As shown in Fig 6, if these messages are arriving and being queued at the depicted times, M1 and M2 would be the preceded IDs of M2 and M3, respectively, with only a 3-bit IFS separating the corresponding message pairs In other words, the transmissions of M2 and M3 are forced to be buffered until their preceded ID messages have been transmitted on the bus|,Non-data,37
| Since message priorities and periodicities do not change, such a feature implies that one particular CAN message may always be followed by another specific message, ie, there is a unique preceded ID for that specified one As an example, if the periodicities of their transmissions are either same or integer multiples (e|,Non-data,37
|g, 5ms for M1, M2, and 10ms for M3), then M2 would always be the preceded ID of M3, ie, be the unique preceded ID|,Non-data,37
| Hence, regardless of jitter, the exact timing of message transmissions becomes rather predictable and even determinative: 3 bit-time after the preceded ID’s completion Bus-off attack by exploiting preceded IDs In the above exam- ple, to attack M3, the adversary can monitor the CAN bus, learn its preceded ID of M2 or even M2’s preceded ID of M1, and buffer an attack message with ID=M3 when receiving one of them Then, its CAN controller would always transmit the attack message af- ter M2’s transmission (i|,Non-data,37
|e, concurrently with the target message), and the adversary will thus succeed in the bus-off attack Likewise, the adversary can target M2 by buffering its attack message with ID=M2, as soon as it receives its preceded ID of M1 If the pre- ceded ID is unique, then the bus-off attack can be iterated for its every reception and thus consecutively increase the victim’s TEC|,Non-data,37
| Even though the target message does not have such a preceded ID, an adversary can fabricate it in order to synchronize the tim- ing and thus succeed in mounting the attack Consider an example shown in Fig 7 where a victim node periodically transmits mes- sage V, which has no preceded IDs In such a case, just before the transmission of V, the adversary can inject some message P and an attack message A, sequentially|,Non-data,37
| Hence, V’s transmission gets delayed until the completion of P, ie, the adversary fabricates P as the preceded ID of V, and thus the attack message is synchro- nized with its target Our evaluation results will later demonstrate the efficiency of bus-off attacks based on the above approaches|,Non-data,37
| 44 Preceded IDs in Actual CAN Traffic The key point in meeting C2 and succeeding in the bus-off at- tack is leveraging the preceded IDs of the target message Depend- ing on the configuration and scheduling of messages, some target messages may (or may not) have a preceded ID We first consider the case in which the adversary is targeting messages with genuine (unfabricated) preceded IDs|,Non-data,37
| Hence, it is essential to verify their existence in actual CAN traffic as well as usefulness in satisfying C2 That is, the following questions should be answered: • Existence – Are there such preceded IDs in real in-vehicle • Uniqueness – If yes, how many distinct preceded IDs are • Pattern – If more than one, are there any patterns in the pre- there for a specified message? network traffic? ceded IDs which can be utilized? We answer these questions via an analysis of actual CAN traffic data We use CAN data that was recorded from a 2010 Toyota Camry by Ruth et al [20]|,Non-data,37
| During a 30-minute drive, the data was logged by a Gryphon S3 and Hercules software [20] According to the logged data, there were 42 distinct messages transmitted on the ĀȀ !" #$Ȁ%" #$Ȁ%" &(cid:1) ĀȀ !" (cid:1) Ā (cid:1)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5) (cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:10)(cid:13)(cid:14) (cid:1) !' ( (cid:1) )*Ā !" (cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:7)(cid:10)(cid:11)(cid:7)(cid:6)(cid:12)(cid:6)(cid:13)(cid:5)(cid:6)(cid:8)(cid:11)(cid:1)(cid:14) (cid:1) ( Ā!' (cid:1) (cid:1) )*Ā !" (cid:1) Ā (cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:7)(cid:10)(cid:11)(cid:7)(cid:6)(cid:12)(cid:6)(cid:13)(cid:5)(cid:6)(cid:8)(cid:11)(cid:1)(cid:14) Figure 9: Timing of preceded ID message injection CAN bus: 39 of them sent periodically at intervals ranging from 10ms to 5 secs, and 3 of them sent sporadically Existence and uniqueness|,Non-data,37
| Of these, we first identify the ones of interest to us: messages that are always sent right after another’s completion, ie, have preceded IDs (eg|,Non-data,37
|, M2 or M3 in Fig 6) Of the 39 periodic messages seen on the bus, we were able to find 8 of such type Fig|,Non-data,37
| 8 shows the number of distinct preceded IDs of the ones labeled in the x-axis For example, message 0xB2 had a unique preceded ID 0xB0, ie, 0xB2 always followed 0xB0, where both were sent every 10ms|,Non-data,37
| On the other hand, message 0x3B7 had 11 different kinds of those IDs The result showing that 10% of the periodic messages have a unique preceded ID answers the question of their existence as well as uniqueness in actual CAN traffic, and thus implies that the bus-off attack exploiting genuine preceded IDs is indeed feasible in actual vehicles Since in-vehicle messages have fixed priorities, are sent periodically, and some have to be sent consecutively by an ECU (eg|,Non-data,37
|, two messages containing front and rear wheel speed values), we believe preceded IDs are prevalent in all other types of passenger cars as well Patterns in preceded IDs Another interesting aspect of the CAN bus traffic, which caught our attention was that there were notable patterns in the preceded IDs As shown in Fig|,Non-data,37
| 8, message 0x223 with periodicity 30ms had 3 distinct preceded IDs, meaning that observing those IDs may not help determine the transmission timing of 0x223 However, we were able to extract an interest- ing pattern in their transmission: the 6n-th transmission of 0x20 was the unique preceded ID of the 2n-th transmission of 0x223, where n is an integer That is, even though a unique preceded ID was not observable for every transmission, it was for every n-fold transmission, ie|,Non-data,37
|, there exists a pattern in preceded IDs Therefore, by observing the CAN bus traffic, acquiring knowledge of genuine preceded IDs, and thus meeting not only C1, C3 but also C2, the adversary can succeed in mounting bus-off attack 45 Fabrication of Preceded IDs Even though the targeted messages do not have a preceded ID, as shown in Fig|,Non-data,37
| 7, the adversary can fabricate it to meet C2 There- fore, we will henceforth refer preceded ID messages to ones which are fabricated by the adversary The injection timing, quantity, and the contents of the preceded ID message are important for the ad- versary to mount a bus-off attack with preceded IDs Injection timing|,Non-data,37
| To succeed in the bus-off attack via fabri- cation of preceded IDs, it is essential for the adversary to inject that fabricated message right before the target message In other words, the adversary is required to estimate when the target mes- sage would be transmitted on the bus Although most in-vehicle messages have fixed periodicity, randomness incurred from jitters makes such estimation rather difficult As shown in Fig|,Non-data,37
| 9, con- sider a target message V with periodicity of T , which is expected to be transmitted at times torig, torig + T , and thereafter Note that T is a predefined and constant value for periodic messages How- ever, due to the jitters of Jn and Jn+1 — caused by variations in 1049Before stuffing Stuffed bits After stuffing 000001111000011110000|,Non-data,37
 00000111110000011111000001,Non-data,37
| Figure 10: Maximizing Tx duration via bit-stuffing n the transmitter node’s clock drift, task scheduling, execution time, etc [9] — the victim’s messages are transmitted on the bus at times tv ic n and tv ic n+1, where n is the sequence index From the adversary’s perspective, due to an incurred delay of D from transmission and reception, it receives message V at times tadv n+1|,Non-data,37
| Note that D includes delays for message transmission, propagation, and pro- cessing Since the number of bits in a certain message is almost a constant and the bit timing of CAN already takes into account of the signal propagation on the bus, without loss of generality, we assume D to be constant for a given message V [3, 16] and tadv Thus, the only remaining randomness in the timing of message transmission is jitter (eg|,Non-data,37
|, Jn) Jitter is known to follow a Gaus- sian distribution due to randomness in thermal noise, which also follows a Gaussian, and the Central Limit Theorem, ie, compos- ite effects of many uncorrelated noise sources approach a Gaussian distribution [9]|,Non-data,37
| So, we can consider Jn and Jn+1 as outcomes of a Gaussian random variable J ∼ N(0, σ2 v) Thus, the times when the adversary receives V can be expressed as: n + D = torig + Jn + D n+1 + D = torig + T + Jn+1 + D, tadv n = tv ic tadv n+1 = tv ic (1) where Jn < 0 and Jn+1 > 0 in Fig 9 Then n + T − D + J∗, (2) n + T − D + Jn+1 − Jn = tadv tv ic n+1 = tadv v) since its outcomes are Jn+1 − Jn|,Non-data,37
| Note where J∗ ∼ N(0, 2σ2 that in Eq (2), J∗ is the only random variable whereas others are either constant or measurable by the adversary Such an equation shows that the adversary can indeed obtain an approximate estima- tion of when the victim would transmit its message, ie|,Non-data,37
|, the target message, at the next sequence As shown in Fig 7, for the fabri- cation of preceded IDs to be effective, the adversary has to 1) start transmission of its preceded ID message(s) before the target and 2,3) hold the CAN bus, ie|,Non-data,37
|, make the bus busy, until it becomes sure that the attack and target messages would synchronize That is, the adversary must meet the following three conditions: n+1) = tadv 1) tf ab < min(tv ic 2) tf ab + H > max(tv ic 3) H = κF > max(J∗) − min(J∗), n+1) = tadv n + T − D + min(J∗) n + T − D + max(J∗) (3) Figure 11: CAN bus prototype (cid:2) max(J injections, κ should be kept to minimum by maximizing F To maximize F, i|,Non-data,37
|e, the duration of its preceded ID message occupy- ing the bus, the adversary can exploit the bit-stuffing rule of CAN: after every 5 consecutive bits of the same polarity (eg, 00000), an opposite polarity bit is stuffed|,Non-data,37
| By fabricating its preceded ID message with DLC=8 and the data field as shown in Fig 10, the adversary can maximize the number of stuffed bits and thus F to ∗ = (8L + 44 + (cid:7)8L/4(cid:8)) /Sbus = 124/Sbus, where at least F 44 denotes the number of bits exterior to the data field, L the DLC=8, and Sbus the bus speed Note that at least 2L bits are added to the fabricated message according to the CAN’s bit-stuffing rule Hence, if we consider a CAN bus with Sbus = 500Kbps, using a single injected preceded ID message, the adversary can take control of the bus for at least 0|,Non-data,37
|248ms Such analyses sug- gest that for targeting a message with a jitter deviation of σv, the adequate number of preceded ID messages can be expressed as κ =  For example, if σv = 0025ms and Sbus = 500Kbps, the adversary is only re- quired to inject κ = (cid:9)0|,Non-data,37
|8554(cid:10) = 1 preceded ID message with I = 3, ie, 9973% confidence|,Non-data,37
| To ensure the effectiveness of the fabricated preceded IDs with a near-perfect confidence, the adver- sary can set I = 4 and thus inject κ = (cid:9)11405(cid:10) = 2 messages at time tf ab Our evaluation will later show that one injection of fab- ricated ID messages (κ = 1) can be sufficient for a bus-off attack Contents of the preceded ID message|,Non-data,37
| Other than the control and data fields, the adversary also has to carefully decide which ID to use for fabricating the preceded ID messages If only one preceded ID message is to be used for the attack, the adversary can exploit the next seemingly free ID To be as elusive as possible, the ID value can be changed for each attempt of attack and be chosen from those least frequently sent on the bus If two preceded ID messages are to be used, the adversary can similarly inject the first one with any free ID but should inject the second one with an ID having higher priority (smaller value) than the target|,Non-data,37
| ∗)−min(J F∗ 2Iσv Sbus ∗) (cid:2) √ 2 (cid:3) = (cid:3) 124 where tf ab denotes when the adversary starts to inject its fabricated preceded ID message(s) Moreover, H denotes the duration of the adversary holding the bus, which is equivalent to κ preceded ID messages each sent for a duration of F Since J∗ is a bounded √ Gaussian random variable, the boundaries can be approximated as ||max(J∗)|| = ||min(J∗)|| (cid:4)I 2σv, where σv is measurable, and I an attack parameter Since J∗ is Gaussian, setting I = 3 would provide a 99|,Non-data,37
|73% confidence and I = 4 a 9999% confidence In √ total, to fully exploit the fabricated preceded IDs, the adversary has to start injecting them prior to tadv 2σv Note that n+1)− H, which the adversary should not lower tf ab beyond max(tv ic can be set once H is determined|,Non-data,37
| Number of messages Once satisfying 1) in Eq (3), the ad- versary has to satisfy 3) — occupy the bus at least for the dura- tion of max(J∗) − min(J∗) = 2 2Iσv, which can be met via κ (≥ 1) injections of preceded ID messages Since the adversary’s objective is to mount the bus-off attack with a minimal number of n + T − D − I √ 5|,Non-data,37
| EVALUATION We now evaluate the feasibility of the proposed bus-off attack on a CAN bus prototype and two real vehicles For in-depth analyses of the bus-off attack, we first evaluate the attack on the CAN bus prototype, and then extend the evaluation to real vehicles 51 Bus-off Attack As shown in Fig|,Non-data,37
| 11, we configured a CAN prototype in which all 3 nodes were connected to each other via a 2-wire bus Each node consists of an Arduino UNO board and a SeeedStudio CAN bus shield, which is composed of a Microchip MCP2515 CAN con- troller with SPI interface, MCP2551 CAN transceiver, and a 120Ω terminal resistor to provide CAN bus communication capabilities Evaluation setup The CAN bus prototype was set up to oper- ate at 500Kbps as in typical in-vehicle CAN buses|,Non-data,37
 Three inter- connected nodes were each programmed to replicate the scenario 1050Victim's TEC Adversary's TEC 250 200 150 100 50 ) C E T (  t n u o C  r o r r E  t i m s n a r T 0 0 20 40 80 60 120 Elapsed Time [ms] 100 120 100 80 60 40 20 ) C E T (  t n u o C  r o r r E  t i m s n a r T 0 0 140 160 180 Phase 1 Phase 2 255 250 245 240 235 230 225 220 05 15 Elapsed Time [ms] 1 160 150 140 180 Elapsed Time [ms] 170 Figure 12: TECs during a bus-off attack Figure 13: Victim’s TEC during Phase 1 and 2,Non-data,37
 Error-passive 250 Kbps 500 Kbps CAN bus speed 1000 Kbps Bus-off ] s m [  y a e D l 25 2 15 1 ] s m [  y a e D l 189 188 187 186 ] s m [  k c a t t a  f f i   o - s u b g n d e e c c u s  f o  y a e D l 193 192 191 190 189 188 250 Kbps 500 Kbps CAN bus speed 1000 Kbps 100 200 300 400 #messages per second on the bus 500 250 200 150 100 50 ) C E T (  t n u o C  r o r r E  t i m s n a r T 0 0 Victim's TEC Adversary's TEC 50 100 150 Elapsed Time [ms] 200 Figure 14: Delays of bus-off attack under different bus speeds Figure 15: Delays of bus-off attack under different bus loads,Non-data,37
| Figure 16: Changes in TECs when the preceded ID is fabricated shown in Fig 6, which is also commonly seen in actual CAN bus traffic: every 10ms, node A was programmed to send two consecu- tive messages with ID=0x07 and 0x09, and B to send one message with a lower priority of ID=0x11 Node B buffered its message when a message with ID=0x07 was received|,Non-data,37
| Note that 0x07 and 0x09 become the genuine preceded IDs of 0x09 and 0x11, respec- tively We will later extend this evaluation of the bus-off attack to the case without assuming the availability of genuine preceded IDs Last, but not least, the third node was programmed as an attacker which learns any preceded IDs on the bus and repetitively launches the bus-off attack In our evaluation, message 0x11 from B was set as the attacker’s target message|,Non-data,37
| Hence, the attack message was set up to have the same ID=0x11 but with a different DLC (=0) Since the targeted message had a period of 10ms, the bus-off attack was repeated at the same time interval For every message trans- mission/reception, the Transmit Error Count (TEC) of each node was read from its CAN controller register The entire procedure of an iterative bus-off attack was re-initiated once a node entered the bus-off mode, and was examined 1,000 times|,Non-data,37
| Changes in TEC during a bus-off attack Fig 12 shows how the TECs of the victim and the adversary change during an itera- tive bus-off attack All 1,000 examinations showed near identical changes as shown in Fig|,Non-data,37
| 12 In the initial stage of the attack, there was a steep rise in the TEC of both nodes This is because in Phase 1, with just one attack message, bit errors incurred for not only the initial transmission but also all subsequent retransmissions as depicted in Fig 5(a)|,Non-data,37
| Once the victim became error-passive, ie, TEC>127, the attack entered its second phase Here, with success- ful message transmissions, the adversary was able to recover back to, and remain as error-active|,Non-data,37
| On the other hand, the victim expe- rienced iterative bit errors during its transmissions, and eventually entered the bus-off mode when its TEC exceeded 255 Properties of attack Phase 2 Fig 13 shows a magnified plot of the changes in the victim’s TEC during the attack|,Non-data,37
| In Phase 1, TEC monotonically increased due to the errors in all (re)transmissions On the other hand, once the attack entered Phase 2, the difference in error mode lets the victim succeed in its transmission only after experiencing a bit error Thus, whenever an attack message was injected into the bus by the attacker, the victim’s TEC was first in- creased by 8 and then immediately decreased by 1 The net TEC increase of 7 each time eventually forced the victim to be discon- nected from the bus|,Non-data,37
| These results confirm the properties of Phase 2 discussed in Section 32 52 Attack Under Different Bus Conditions The bit-rate of the CAN bus can vary from 125Kbps to 1Mbps, depending on its purpose, and its bus load can also vary with time|,Non-data,37
| Thus, in order to examine the practicability of a bus-off attack un- der different bus conditions, we conducted the same experiment in Section 51 1,000 times, while varying the speed and load of the bus Each time we measured the average delays of the bus-off at- tack that forces a victim to enter error-passive and bus-off modes, as they represent the following metrics: (1) the required number of attack messages, and (2) the probability of the attack’s success If there was at least one attempt in which the attack failed, then the maximum deviation in delays would be at least the inter-attack interval|,Non-data,37
 Different bus speeds Fig 14 shows box plots of the average delays of the bus-off attack in coercing the victim to become error- passive and bus-off The bus speed was varied from 250Kbps to its maximum of 1Mbps,Non-data,37
| As shown in Fig 14 (top), for all bus speeds, it took much less than 10ms for the adversary to coerce the victim to become error-passive Since the attack message was injected every 10ms, this implies that only a single injection of the attack mes- sage was required Also, observing that the maximum deviation was less than 10ms, all attempted bus-off attacks succeeded, irre- 1051(cid:75)(cid:17)(cid:24)(cid:882)(cid:47)(cid:47) (cid:62)(cid:258)(cid:393)(cid:410)(cid:381)(cid:393) (cid:87)(cid:396)(cid:381)(cid:410)(cid:381)(cid:410)(cid:455)(cid:393)(cid:286) (cid:10)(cid:11)(cid:12)(cid:13)(cid:14)(cid:14) (cid:6)(cid:7)(cid:5)(cid:4)(cid:5)(cid:4)(cid:8)(cid:3)(cid:9) (cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3) (a) Communication with ECUs in a 2013 Honda Accord|,Non-data,37
 (b) Communication with ECUs in a 2016 Hyundai Sonata Figure 17: Bus-off attack experiments on (a) Honda Accord 2013 and (b) Hyundai Sonata 2016 ) C E T (  t n u o C  r o r r E  t i m s n a r T  s ’ r e k c a t t A 250 200 150 100 50 0 0 2013 Honda Accord Failed Failed 1 2 3 4 6 Elapsed Time [ms] 5 7 8 9 10 x 104 (a) 2013 Honda Accord ) C E T (  t n u o C  r o r r E  t i m s n a r T  s ’ r e k c a t t A 250 200 150 100 50 0 0 2016 Hyundai Sonata Failed 1 2 3 4 5 Elapsed Time [ms] 6 7 8 9 x 104 (b) 2016 Hyundai Sonata,Non-data,37
| Figure 18: Transmit error counts of ECUs in the two real vehicles are increased via bus-off attack spective of the bus speed The attacker was able to make the victim enter error-passive mode faster with the increase of bus speed, be- cause a higher bus speed enabled frame (re)transmissions to com- plete more quickly Fig|,Non-data,37
| 14 (bottom) shows the total delay of the victim eventually becoming bus-off at different bus speeds For all settings, the maximum deviation was less than 10ms, again imply- ing a 100% success probability of the attack Different bus loads Not only the speed but also the load of the bus was varied in evaluating the attack|,Non-data,37
| To generate different bus loads, the node that was neither the adversary nor the victim injected 100∼500 messages per second Their IDs were randomly chosen among the set of unused ID values, and their DLCs were set randomly between 1 and 8 Fig 15 shows the average total delay of coercing the victim node to eventually bus off under the given bus loads|,Non-data,37
| As the bus load increases, the overall delay is shown to rise, because some of the randomly injected messages won arbitration over the target and attack messages and thus delayed their trans- mission Note, however, that since they both had the same IDs, they both won/lost the arbitration Therefore, in all 1000 examina- tions with different bus loads, all trials of bus-off attack succeeded regardless of the bus load 5|,Non-data,37
|3 Periodicity vs Preceded ID To mount a bus-off attack, the attack message has to satisfy con- ditions C1–C3 Of these, C2 is the most difficult to meet, but can be satisfied by exploiting either of the following three scenarios: • Periodicity – measure the Tx interval of the target message • Genuine ID – assuming genuine preceded IDs are available, • Fabricated ID – fabricating and thus exploiting the preceded and exploit it for synchronizing the transmission timing exploit them for the bus-off attack|,Non-data,37
| ID of a target message We evaluated all of these in order to verify their accuracies and efficiencies For the first scenario, the adversary and the victim were programmed to send messages every 10ms with the same ID but different DLC values The first transmissions from both nodes were initiated by a reference message sent by the non-victim node|,Non-data,37
| For the second scenario of exploiting genuine preceded IDs, the nodes were programmed equivalently as discussed in Section 51 Finally, for the third scenario, we programmed the adversary to fabricate one preceded ID message per attack as shown in Fig 7 For each attack scenario, we examined 50,000 bus-off attack trials|,Non-data,37
| When periodicity was exploited to synchronize the Tx timing for a bus-off attack, due to jitters, only 58 out of 50,000 trials (012%) were able to trigger a bit error at the victim, thus eventually not triggering a bus-off On the other hand, when genuine preceded IDs were assumed to be present and thus were exploited, all 50,000 tri- als succeeded in increasing the victim’s TEC Even without assum- ing that there is a genuine preceded ID for the target message, the adversary increased the victim’s TEC 45,127 times (out of 50,000 trials) by fabricating it, i|,Non-data,37
|e, a 09025 success probability Note that in achieving such a high probability, one fabricated preceded ID was sufficient since the jitter deviation σv = 0|,Non-data,37
|023ms Although some attempts failed, due to the high success rate and the nature of change in TEC (ie, +8 in TEC in case of error and −1 in the absence of error), iterative bus-off attacks eventually forced the vic- tim to bus off as shown in Fig|,Non-data,37
| 16 One can see that the change in TEC is slightly different from the one in Fig 12 due to some failed attempts These results show that a preceded ID — regardless of whether genuine or fabricated — is a good indicator for determin- ing the exact timing of a specific message, and is indeed useful for mounting a bus-off attack|,Non-data,37
| 54 Bus-off Attack on Real Vehicles To evaluate the feasibility of bus-off attack further, we also con- ducted experiments on two real vehicles, 2013 Honda Accord and 2016 Hyundai Sonata shown in Figs 17(a) and 17(b) During our experiments, the vehicles were immobilized for safety in an iso- lated and controlled environment|,Non-data,37
| As shown in Fig 17, through the On-Board Diagnostic (OBD-II) port, we were able to connect our CAN bus prototype to their in-vehicle CAN buses, both of which run at 500Kbps Thus, the 3 prototype nodes were able to read all 40 distinct broadcast messages from the Honda Accord’s CAN bus and 58 distinct messages from the Hyundai Sonata’s CAN bus Moreover, the nodes were capable of injecting and delivering arbi- trary messages to the in-vehicle ECUs|,Non-data,37
| Increasing the TEC of a real in-vehicle ECU We first experi- mentally show that an attacker can synchronize its Tx timing with a real ECU, increase its TEC, and thus succeed in launching a bus- 1052250 200 150 100 50 ) C E T (  t n u o C  r o r r E  t i m s n a r T  s m ’ i t c V i 0 0 200 DLC=2 DLC=4 DLC=6 DLC=8 x 10−3 12 r o r r e   e v i t u c e s n o c  f o  y t i l i b a b o r P 1 08 0|,Non-data,37
6 04 02 Without Countermeasure With Countermeasure 250 200 150 100 50 ) C E T (  t n u o C  r o r r E  t i m s n a r T  s m ’ i t c V i 2013 Honda Accord 2016 Hyundai Sonata 400 600 800 Elapsed Time [ms] 1000 1200 0 10−8 10−7 10−6 10−5 Bit Error Rate (BER) 10−4 10−3 0 0 20 40 60 80 100 Elapsed Time [ms] 120 140 160 180 Figure 19: Iterative bus-off attack in a Honda Accord and a Hyundai Sonata Figure 20: Probability of two consecutive errors,Non-data,37
| Figure 21: Efficiency of the proposed countermeasure off attack For the evaluation on the Honda Accord, one prototype node was programmed as the attacker mounting a bus-off attack on one of its ECUs, which sent message 0x295 every 40ms The attacker node made 15 attempts of the bus-off attack on that ECU by fabricating the preceded ID of 0x295|,Non-data,37
| For the evaluation on the Hyundai Sonata, the node was programmed to mount the attack on an ECU which sent message 0x164 every 10ms Similarly, 15 attempts of the bus-off attack via fabrication of preceded ID were made Due to restrictions in accessing the error counters of real in- vehicle ECUs, we validate the attack on real ECUs by exploiting the fact that in Phase 1 of the bus-off attack, the attacker’s and the victim’s TECs increase equivalently and both eventually exceed 127 within a very short period So, Fig|,Non-data,37
| 18 shows (i) how the at- tacker’s TEC changed during Phase 1 of 15 bus-off attack attempts under both settings, and (ii) how the TEC of the in-vehicle victim ECU changed In contrast, during Phase 2, the attacker’s TEC does not reflect the victim’s TEC Since the results from only Phase 1 are valid, once the attacker’s TEC exceeds 127, the node is reset to ini- tialize its error counters For the real ECU’s TEC to be re-initialized so as to iterate Phase 1, the adversary mounted the attack every 5 secs, thus allowing the real ECU to decrease its TEC back to 0 as a result of its error-free transmissions during this period|,Non-data,37
| One can see from Fig 18(a) that in 13 out of 15 attempts, the attacker’s and hence the Honda Accord ECU’s (victim’s) TEC rose steeply, thus making both ECUs enter error-passive mode As the attack was mounted via one fabricated preceded ID, 2 out of 15 at- tempts failed The steep rises of TEC were again due to automatic retransmissions by the attacker node’s and the in-vehicle ECU’s CAN controllers|,Non-data,37
| Similarly, Fig 18(b) shows that, except for one attempt, the Hyundai Sonata ECU’s TEC always increased when the bus-off attack was mounted Although we could only show the result from Phase 1, it implies that the attacker can synchronize the Tx timing with a real ECU, and iterate such a process to continu- ously increase its TEC, eventually forcing it to disconnect from the in-vehicle network Moreover, it shows that the attack can succeed regardless of the vehicle model/year, and corroborates an important fact of the bus-off attack: there is no need to reverse-engineer mes- sages or checksums for mounting the bus-off attack, thus making it easier for the adversary to launch the bus-off attack|,Non-data,37
| Forcing an in-vehicle ECU to bus off To further demonstrate the feasibility of the bus-off attack on real vehicles, we also evalu- ated a scenario in which one of the CAN prototype nodes was made to be the victim The period of the target message sent by the vic- tim was set to 50ms Since the three CAN prototype nodes were capable of exchanging messages with real ECUs in both vehicles, they were successfully added to their in-vehicle CAN networks, and hence operate/act as if they were real ECUs|,Non-data,37
| As a result, an at- tack on one of them would be equivalent to an attack on a real ECU Unlike the prototype setting, however, their bus loads were signifi- cantly higher — due to traffic generated by real in-vehicle ECUs — during the attack, ie, the attack was evaluated in highly complex CAN bus traffic|,Non-data,37
| Fig 19 shows the changes in TECs of the vic- tim node being attacked on the 2013 Honda Accord and the 2016 Hyundai Sonata Under both settings, through iterative bus-off at- tacks, the victim became error-passive within 24ms and eventually entered bus-off mode|,Non-data,37
| Compared to the prototype setting, since the target message was set to have a larger interval and the bus loads were much higher, the overall delays of the victim entering error- passive and bus-off were larger These results on the two real vehicles confirm that the bus-off attack is indeed a severe, real problem 6 RELATED WORK As a countermeasure against attacks on in-vehicle networks, message authentication and intrusion detection systems (IDSs) have been the two main lines of defense|,Non-data,37
| Providing message authentication for CAN is difficult due to the limited space available for appending a Message Authentication Code (MAC) in its data field Moreover, the requirement of real- time communication and processing makes the provision of authen- tication a non-trivial problem Several schemes have been proposed to overcome these difficulties The authors of [21] proposed to trun- cate MAC across multiple frames|,Non-data,37
| Similarly, the authors of [17] proposed to use multiple CRC fields for including a 64-bit MAC To achieve such authentications, the entire message has to be re- ceived by the transceiver and delivered to the upper layer However, for the proposed bus-off attack, the adversary causes a bit error at the victim during message reception Thus, even though a MAC is appended to the message, its functionalities will be nullified|,Non-data,37
| Sim- ilarly, the functionalities of message checksums are also nullified Other than authentication methods, IDSs have also been pro- posed as countermeasures The essence of state-of-the-art IDSs is to monitor the periodicity and contents of messages, and ver- ify whether there are any significant changes to them The au- thors of [14] proposed a method of measuring the entropy of an in-vehicle network and used the result as a specification of the be- havior for an IDS|,Non-data,37
| Similarly, a method of modeling the distribution of message intervals was proposed in [12] to define a norm behav- ior Not only message frequency but also obvious misuse of mes- sage IDs (eg, ID=0x00) were monitored in [8]|,Non-data,37
| Although such IDSs are capable of detecting attacks to some extent, they over- looked the fact that message periodicity can change even in a nor- mal or uncompromised environment For example, if an error had occurred due to hardware/software fault, then that message would 1053automatically be retransmitted by the CAN controller, thus chang- ing its transmission interval [19] As a result, since an abnormal periodicity may be due to a system error as well as an attack, it is unreasonable to directly map such a symptom to an attack For example, 16 consecutive error frames can occur due to not only a bus-off attack but also improper CAN termination [4]|,Non-data,37
| This implies that for the proposed bus-off attack, the IDS may not tell if the error was due to an attack or a system error 7 COUNTERMEASURES The proposed bus-off attack is an important vulnerability, espe- cially in view of its capability of nullifying MACs and checksums, and also deceiving IDSs to think there is a system error although the network is actually under attack We propose a new defense mechanism which leverages the following features of the bus-off attack for its prevention|,Non-data,37
| In Phase 1, due to CAN’s automatic retransmission, F1 at least two consecutive errors occur during the transmission of frames Thus, we watch for consecutive error frames with an active error flag In Phase 2, due to the difference in error modes, F2|,Non-data,37
| at the time when the (error-passive) victim’s TEC increases, a message with the same ID will be successfully transmitted by some ECU on the bus F1 indicates a bus-off attack We first simulated the probability of F1 under an uncompromised condition We leveraged the same error model in [19] where bit error occurrences follow a Bernoulli distribution|,Non-data,37
| In our simulation, for a given DLC and Bit Error Rate (BER), we randomly generated 100,000 different CAN messages and measured how many of them satisfy F1 The simulation result, plotted in Fig 20, shows that even under an unusually high BER of 10−3 (usually 10−5 ∼ 10−7 [19]), the maximum probability of F1 was only 011%|,Non-data,37
| So, under a normal condition, the probability of F1 occurring 16 times in a bursty manner can be considered 0, whereas it was 10 during a bus-off attack Considering this large discrepancy, we can consider F1 to indicate a bus-off attack How- ever, since F1 can also occur due to severe system errors such as im- proper bus termination [4], bit flip [22], and bit drop/insertion [15], F1 alone cannot be a definitive evidence of a bus-off attack|,Non-data,37
| F2 is the evidence After occurrence of F1, once an error-passive ECU experiences a bit error again when transmitting a message with ID=M, it can further monitor the CAN bus and check if there was any successful transmission of another message with the same ID=M, ie, occurrence of F2|,Non-data,37
| This can only occur when two or more ECUs are sending the same message at the same time, which is not allowed on CAN and thus infeasible even in a severely er- roneous network, while it is possible under a bus-off attack From both F1 and F2, we can thus verify the occurrence of a bus-off attack, ie, the observed symptoms are not caused by a system er- ror|,Non-data,37
| Following this reasoning, we propose the following defense mechanism: an ECU or its error counters are reset whenever F2 is observed after N consecutive error frames We use N = 16 to reset the victim ECU upon occurrence of both F1 and F2 Efficiency of the proposed countermeasure We evaluated the bus-off attack on our CAN bus prototype with the proposed coun- termeasure|,Non-data,37
| According to the proposed defense, the nodes were programmed to reset when F2 was observed after 16 consecutive and bursty error frames During an iterative bus-off attack, Fig 21 shows how the victim’s TEC changed with and without the pro- posed defense By observing the presence of bursty error frames on the CAN bus, the victim’s error mode mostly stayed as error- active, which is in sharp contrast to the case without any counter- measure, and also successfully transmitted its messages, efficiently preventing the bus-off attack|,Non-data,37
| Alternative countermeasures In our proposed countermea- sure, we looked for consecutive error frames (ie, F1) to prevent the bus-off attack|,Non-data,37
| We may also consider a countermeasure which verifies if consecutive errors incur at the same bit position, instead of frames As this is, in fact, the strongest evidence of the bus-off attack, we may use it as the condition of triggering an ECU reset It may also be considered as a new rule in CAN for not increasing the error counters Then, as the detection of a bus-off attack can be made much faster with the stronger evidence, unwanted retrans- missions, which were at least 16 in our proposed countermeasure, can be reduced further|,Non-data,37
| Note that these retransmissions may affect other messages in meeting their hard/soft deadlines Albeit effec- tive, such a countermeasure accompanies numerous challenges and limitations: 1) detecting individual bit errors would require changes in hardware, thus incurring expensive development cost and 2) de- tecting which bit has currently changed and comparing it with the previously changed one would require additional memory in the CAN transceiver chip The proposed bus-off attack exploits the periodic feature of in- vehicle network messages for synchronizing its transmission time with the victim’s It is thus limited to only periodic messages but it is very effective since most in-vehicle messages are periodic|,Non-data,37
| Therefore, an alternative countermeasure can be to transmit peri- odic messages with some random factors added to their Tx times (eg, adding random jitters), making them somewhat aperiodic However, adding random factors to Tx times can create serious un- expected problems such as priority inversion, message sequence inversion, and deadline violation [6]|,Non-data,37
| As this incurs detrimental ef- fects on the message scheduling mechanism, we did not consider it as a possible countermeasure against the bus-off attack 8 DISCUSSION Severity of the bus-off attack Since contemporary in-vehicle networks are not equipped with security mechanisms, an adversary can mount not only the bus-off attack but also other types of (previ- ously covered) attacks on in-vehicle networks|,Non-data,37
| For example, the at- tacker can simply inject arbitrary messages on the CAN bus or mo- nopolize the network by continuously sending the highest-priority frames However, the following facts make the bus-off attack a more severe problem and an attack that an adversary might favor over other attacks Previously demonstrated/covered attacks either show obvious misuse of message IDs or significantly increase the message frequency, which can easily be detected and then removed by existing IDSs [8, 12, 14] In contrast, the proposed bus-off at- tack can be mounted without misusing IDs and requires only a small increase in message frequency — up to a frequency that ren- ders the bus-off attack feasible even during a system error (e|,Non-data,37
|g, bit drop/insertion) This may cause the existing IDSs to be confused whether the symptom is due to an attack or a system error More importantly, unlike previously demonstrated attacks, the adversary can mount a bus-off attack without any knowledge on the meanings or purposes of messages, making their reverse-engineering unnec- essary|,Non-data,37
| Also, the attacker succeeds before the victim verifies a mes- sage’s checksum, and hence can use an arbitrary checksum in the attack message, ie, no need to reverse-engineer the implemented checksum algorithm Even if MACs were used for in-vehicle net- work messages, their functionalities could likewise be nullified|,Non-data,37
| Requiring far less painstaking (than reverse engineering) efforts — especially when the adversary wants to mount attacks on various types of vehicles — differentiates the bus-off attack from previ- 1054ously known vehicle attacks and can also be a strong motivation for the adversary to prefer the bus-off attack to others Limitations of the bus-off attack In order to succeed in the bus-off attack, the attacker must synchronize its transmission tim- ing with the victim’s To achieve this, the proposed bus-off at- tack leverages the CAN protocol’s buffering strategy via a gen- uine/fabricated preceded ID message|,Non-data,37
| As mentioned before, how- ever, its exploitation is only feasible when the target message (from the victim) is sent periodically In other words, the attacker cannot force a victim to bus off when he is sending messages aperiodically Meanwhile, since most messages in CAN are sent periodically, the attacker can succeed in mounting the bus-off attack on most ECUs in the in-vehicle network Vulnerability of other in-vehicle networks|,Non-data,37
| Although most modern vehicles are equipped with CAN, some may deploy other protocols, such as CAN-FD, TTCAN, and FlexRay for more com- plex operations Note that CAN-FD is an enhanced version of CAN, providing flexible and higher data rates as well as a larger data field [15] Since CAN-FD’s basic components, arbitration, and error handling all conform to those in CAN, it is also vulnerable to the proposed bus-off attack What makes CAN-FD more interest- ing is that an attacker can monitor the newly introduced Extended Data Length (EDL) and Bit Rate Switch (BRS) fields, recognize which messages are sent with high bit rates or large payloads — safety-critical messages — and target them for a bus-off attack|,Non-data,37
| TTCAN is a session-layer protocol in which its message trans- missions are based on a static schedule, time-triggered paradigm to provide Tx determinism [11] As a result, all ECUs transmit their messages only at their assigned time slots and are periodically syn- chronized through a broadcast reference message Since the allo- cated time slots are predefined in a schedule matrix and are stored in each node, the attacker — having control of a vehicle running TTCAN — is provided with the knowledge of what messages are sent and when, thus making the bus-off attack easier In FlexRay, which is designed to be more reliable than CAN as in CAN-FD, the error modes are divided into 3 different modes: normal-active, normal-passive, and halt|,Non-data,37
| Normal-active mode is essentially equivalent to the error-active mode of CAN, whereas normal-passive mode differs from the CAN’s error-passive mode, as it does not allow the nodes to transmit in that mode Accordingly, FlexRay becomes invulnerable to the proposed bus-off attack 9 CONCLUSION In this paper, we discovered a new vulnerability, called the bus- off attack, of in-vehicle networks|,Non-data,37
| The attack exploits their error- handling scheme to disconnect an uncompromised ECU and/or even shut down the entire in-vehicle network We analyzed its prac- ticability and demonstrated the attack on a CAN bus prototype and two real vehicles Based on our analysis and experimental results, we proposed a defense mechanism to prevent the bus-off attack Even though the proposed attack has not yet been seen in the wild, it is easy to mount and also directly related to drivers/passengers’ safety, and should thus be countered with high priority|,Non-data,37
| Moreover, the facts that the proposed attack can nullify state-of-the-art solu- tions and is easy to launch, make it even more important to design and deploy its countermeasures Thus, we recommend concerted efforts from both academia and industry to account for this vulner- ability in the design of in-vehicle networks Acknowledgments The work reported in this paper was supported in part by the NSF under Grants 1505785 and 1646130 10|,Non-data,37
|ABSTRACT Lattice-based cryptography offers some of the most attrac- tive primitives believed to be resistant to quantum com- puters Following increasing interest from both companies and government agencies in building quantum computers, a number of works have proposed instantiations of practical post-quantum key exchange protocols based on hard prob- lems in ideal lattices, mainly based on the Ring Learning With Errors (R-LWE) problem While ideal lattices facil- itate major efficiency and storage benefits over their non- ideal counterparts, the additional ring structure that en- ables these advantages also raises concerns about the as- sumed difficulty of the underlying problems Thus, a ques- tion of significant interest to cryptographers, and especially to those currently placing bets on primitives that will with- stand quantum adversaries, is how much of an advantage the additional ring structure actually gives in practice|,Non-data,40
| Despite conventional wisdom that generic lattices might be too slow and unwieldy, we demonstrate that LWE-based key exchange is quite practical: our constant time imple- mentation requires around 13ms computation time for each party; compared to the recent NewHope R-LWE scheme, communication sizes increase by a factor of 47×, but remain under 12 KiB in each direction Our protocol is competitive when used for serving web pages over TLS; when partnered with ECDSA signatures, latencies increase by less than a fac- tor of 1|,Non-data,40
|6×, and (even under heavy load) server throughput only decreases by factors of 15× and 12× when serving typ- ical 1 KiB and 100 KiB pages, respectively To achieve these practical results, our protocol takes advantage of several in- ∗ Large parts of this work were done when Valeria Nikolaenko was an intern at Google|,Non-data,40
 Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for third-party components of this work must be honored Request permissions from Permissions@acmorg,Non-data,40
| CCS’16 October 24–28, 2016, Vienna, Austria Copyright is held by the owner/author(s) Publication rights licensed to ACM ACM ISBN 978-1-4503-4139-4/16/10|,Non-data,40
1500 DOI: http://dxdoi,Non-data,40
|org/101145/29767492978425 novations These include techniques to optimize communi- cation bandwidth, dynamic generation of public parameters (which also offers additional security against backdoors), carefully chosen error distributions, and tight security pa- rameters|,Non-data,40
| Keywords Post-quantum cryptography; learning with errors; key ex- change; OpenSSL; TLS 1 INTRODUCTION Recent advances in quantum computing (cf [26, 39]) have triggered widespread interest in developing practical post- quantum cryptographic schemes [48] Subsequently, stan- dards bodies and government agencies have announced their intentions to transition to cryptographic standards that of- fer quantum-resistance; this includes the National Institute of Standards and Technology (NIST) [50], the National Se- curity Agency (NSA) [51], and the PQCRYPTO project [9] funded by the European Union|,Non-data,40
|ABSTRACT This work describes the design, implementation, and eval- uation of Λ◦ λ, a general-purpose software framework for lattice-based cryptography The Λ◦λ framework has several novel properties that distinguish it from prior implementa- tions of lattice cryptosystems, including the following Generality, modularity, concision: Λ◦λ defines a collection of general, highly composable interfaces for mathematical operations used across lattice cryptography, allowing for a wide variety of schemes to be expressed very naturally and at a high level of abstraction For example, we implement an advanced fully homomorphic encryption (FHE) scheme in as few as 2–5 lines of code per feature, via code that very closely matches the scheme’s mathematical definition|,Non-data,41
| Theory affinity: Λ◦ λ is designed from the ground-up around the specialized ring representations, fast algorithms, and worst-case hardness proofs that have been developed for the Ring-LWE problem and its cryptographic applications In particular, it implements fast algorithms for sampling from theory-recommended error distributions over arbitrary cyclotomic rings, and provides tools for maintaining tight control of error growth in cryptographic schemes Safety: Λ◦λ has several facilities for reducing code com- plexity and programming errors, thereby aiding the correct implementation of lattice cryptosystems In particular, it uses strong typing to statically enforce—i|,Non-data,41
|e, at compile time— a wide variety of constraints among the various parameters Advanced features: Λ◦ λ exposes the rich hierarchy of cyclotomic rings to cryptographic applications We use this to give the first-ever implementation of a collection of FHE operations known as “ring switching,” and also define and analyze a more efficient variant that we call “ring tunneling|,Non-data,41
|” Lastly, this work defines and analyzes a variety of mathe- matical objects and algorithms for the recommended usage of Ring-LWE in cyclotomic rings, which we believe will serve as a useful knowledge base for future implementations ∗Supported by NSF CAREER Award CCF-1054495, DARPA FA8750-11-C-0096, the Sloan Foundation, and Google Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for components of this work owned by others than the author(s) must be honored|,Non-data,41
| Abstracting with credit is permitted To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acmorg|,Non-data,41
| CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s) Publication rights licensed to ACM ISBN 978-1-4503-4139-4/16/10 |,Non-data,41
  $1500 DOI: http://dxdoi,Non-data,41
|org/101145/29767492978402 1 INTRODUCTION Lattice-based cryptography has seen enormous growth over the past decade, and has attractive features like appar- ent resistance to quantum attacks; security under worst-case hardness assumptions (e|,Non-data,41
|g, [1, 51]); efficiency and parallelism, especially via the use of algebraically structured lattices over polynomial rings (eg, [36, 47, 42]); and powerful crypto- graphic constructions like identity/attribute-based and fully homomorphic encryption (e|,Non-data,41
|g, [30, 27, 11, 31, 32]) The past few years have seen a broad movement toward the practical implementation of lattice/ring-based schemes, with an impressive array of results To date, each such implementation has been specialized to a particular cryp- tographic primitive (and sometimes even to a specific com- putational platform), e|,Non-data,41
|g, collision-resistant hashing (using SIMD instruction sets) [41], digital signatures [33, 20], key- establishment protocols [10, 2, 9], and fully homomorphic encryption (FHE) [49, 34] (using GPUs and FPGAs [56, 18]), to name a few However, the state of lattice cryptography implementations is also highly fragmented : they are usually focused on a single cryptosystem for fixed parameter sets, and have few reusable interfaces, making them hard to implement other primitives upon Those interfaces that do exist are quite low-level ; e|,Non-data,41
|g, they require the programmer to explicitly convert between various representations of ring elements, which calls for specialized expertise and can be error prone Finally, prior implementations either do not support, or use suboptimal algorithms for, the important class of arbitrary cyclotomic rings, and thereby lack related classes of FHE functionality (See Section 1|,Non-data,41
|4 for a more detailed review of related work) With all this in mind, we contend that there is a need for a general-purpose, high-level, and feature-rich framework that will allow researchers to more easily implement and exper- iment with the wide variety of lattice-based cryptographic schemes, particularly more complex ones like FHE 11 Contributions This work describes the design, implementation, and eval- uation of Λ◦λ, a general-purpose framework for lattice-based cryptography in the compiled, functional, strongly typed programming language Haskell|,Non-data,41
|1,2 Our primary goals for 1The name Λ◦λ refers to the combination of lattices and functional programming, which are often signified by Λ and λ, respectively The recommended pronunciation is “L O L” 2Λ◦λ is available under the free and open-source GNU GPL2 license It can be installed from Hackage, the Haskell com- 993Λ◦λ include: (1) the ability to implement both basic and advanced lattice cryptosystems correctly, concisely, and at a high level of abstraction; (2) alignment with the current best theory concerning security and algorithmic efficiency; and (3) acceptable performance on commodity CPUs, along with the capacity to integrate specialized backends (e|,Non-data,41
|g, GPUs) without affecting application code 11|,Non-data,41
|1 Novel Attributes of Λ◦λ The Λ◦ λ framework has several novel properties that distinguish it from prior lattice-crypto implementations Generality, modularity, and concision: Λ◦λ defines a collection of simple, modular interfaces and implementations for the lattice cryptography “toolbox,” ie, the collection of operations that are used across a wide variety of modern cryp- tographic constructions|,Non-data,41
| This generality allows cryptographic schemes to be expressed very naturally and concisely, via code that closely mirrors their mathematical definitions For example, we implement a full-featured FHE scheme (which includes never-before-implemented functionality) in as few as 2–5 lines of code per feature (See Sections 12 and 4 for details|,Non-data,41
|) While Λ◦ λ’s interfaces are general enough to support most modern lattice-based cryptosystems, our main focus (as with most prior implementations) is on systems defined over cyclotomic rings, because they lie at the heart of practically efficient lattice-based cryptography (see, eg, [36, 47, 42, 43]) However, while almost all prior implementations are limited to the narrow subclass of power-of-two cyclotomics (which are the algorithmically simplest case), Λ◦λ supports arbitrary cyclotomic rings|,Non-data,41
| Such support is essential in a general framework, because many advanced techniques in ring-based cryptography, such as “plaintext packing” and homomorphic SIMD operations [53, 54], inherently require non-power-of-two cyclotomics when using characteristic-two plaintext spaces (eg, F Theory affinity: Λ◦λ is designed from the ground-up around the specialized ring representations, fast algorithms, and worst-case hardness proofs developed in [42, 43] for the design and analysis of ring-based cryptosystems (over arbitrary cyclotomic rings), particularly those relying on Ring-LWE To our knowledge, Λ◦λ is the first-ever imple- mentation of these techniques, which include: 2k )|,Non-data,41
| • fast and modular algorithms for converting among the three most useful representations of ring elements, cor- responding to the powerful, decoding, and Chinese Re- mainder Theorem (CRT) bases; • fast algorithms for sampling from “theory-recommended” error distributions—ie, those for which the Ring-LWE problem has provable worst-case hardness—for use in encryption and related operations; • proper use of the powerful- and decoding-basis repre- sentations to maintain tight control of error growth under cryptographic operations, and for the best error tolerance in decryption We especially emphasize the importance of using appropriate error distributions for Ring-LWE, because ad-hoc instantia- tions with narrow error can be completely broken by certain munity’s central repository, via stack install lol|,Non-data,41
| The source repository is also available at https://githubcom/ cpeikert/Lol attacks [26, 16, 14], whereas theory-recommended distribu- tions are provably immune to the same class of attacks [50] In addition, Λ◦λ is the first lattice cryptography imple- mentation to expose the rich hierarchy of cyclotomic rings, making subring and extension-ring relationships accessible to applications|,Non-data,41
| In particular, Λ◦λ supports a set of homomor- phic operations known as ring-switching [11, 28, 3], which en- ables efficient homomorphic evaluation of certain structured linear transforms Ring-switching has multiple applications, such as ciphertext compression [11, 28] and asymptotically efficient “bootstrapping” algorithms for FHE [3] Safety: Building on its host language Haskell, Λ◦λ has several facilities for reducing programming errors and code complexity, thereby aiding the correct implementation of lattice cryptosystems This is particularly important for advanced constructions like FHE, which involve a host of parameters, mathematical objects, and algebraic operations that must satisfy a variety of constraints for the scheme to work as intended|,Non-data,41
| More specifically, Λ◦λ uses advanced features of Haskell’s type system to statically enforce (ie, at compile time) a variety of mathematical constraints This catches many com- mon programming errors early on, and guarantees that any execution will perform only legal operations|,Non-data,41
|3 For example, Λ◦ λ represents integer moduli and cyclotomic indices as specialized types, which allows it to statically enforce that all inputs to modular arithmetic operations have the same modulus, and that to embed from one cyclotomic ring to another, the former must be a subring of the latter We emphasize that representing moduli and indices as types does not require fixing their values at compile time; instead, one can (and we often do) reify runtime values into types, checking any necessary constraints just once at reification Additionally, Λ◦ λ aids safety by defining high-level ab- stractions and narrow interfaces for algebraic objects and cryptographic operations For example, it provides an ab- stract data type for cyclotomic rings, which hides its choice of internal representation (powerful or CRT basis, subring element, etc|,Non-data,41
|), and automatically performs any necessary con- versions Moreover, it exposes only high-level operations like ring addition and multiplication, bit decomposition, sampling uniform or Gaussian ring elements, etc Finally, Haskell itself also greatly aids safety because com- putations are by default pure: they cannot mutate state or otherwise modify their environment This makes code easier to reason about, test, or even formally verify, and is a natural fit for algebra-intensive applications like lattice cryptography|,Non-data,41
| We stress that “effectful” computations like input/output or random number generation are still possible, but must be embedded in a structure that precisely delineates what effects are allowed Multiple backends: Λ◦λ’s architecture sharply separates its interface of cyclotomic ring operations from the implemen- tations of their corresponding linear transforms This allows for multiple “backends,” eg|,Non-data,41
|, based on specialized hardware like GPUs or FPGAs via tools like [15], without requiring any changes to cryptographic application code (By contrast, prior implementations exhibit rather tight coupling between their application and backend code) We have implemented 3A popular joke about Haskell code is “if you can get it to compile, it must be correct” 994two interchangeable backends, one in the pure-Haskell Repa array library [37, 40], and one in C++|,Non-data,41
 112 Other Technical Contributions Our work on Λ◦λ has also led to several technical novelties of broader interest and applicability Abstractions for lattice cryptography,Non-data,41
| As already mentioned, Λ◦λ defines composable abstractions and algo- rithms for widely used lattice operations, such as rounding (or rescaling) Zq to another modulus, (bit) decomposition, and other operations associated with “gadgets” (including in “Chinese remainder” representations) Prior works have docu- mented and/or implemented subsets of these operations, but at lower levels of generality and composability For example, we derive generic algorithms for all the above operations on product rings, using any corresponding algorithms for the component rings And we show how to generically “promote” these operations on Z or Zq to arbitrary cyclotomic rings|,Non-data,41
