 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| The equal error rates drop to 2%-3% with 11 to 12 strokes Similar techniques based on behavioral biometrics are also presented in [8, 26] We note that continuous authentication can only detect the attacker after he has used the device for a while As a result, the attacker still has a good chance to obtain the victim’s sensitive data before being logged out|,Non-data,51
| In addition, if the attacker just watches content (eg photos and messages) on the screen and does not use the device, he would not be detected by continuous authentication methods at all Our method falls into the last category that the device locks itself immediately when the user leaves|,Non-data,51
| If our method is combined with one-time and continuous authentication mechanisms, the attacker can hardly get any opportunity to access the user’s sensitive data even if he possesses the missing mobile device Our work is the first in this category to the best of our knowledge iLock is also related to recent work on object tracking and ranging In particular, FMCW is used in WiTrack [6] for RF-based indoor localization and achieves the position- ing accuracy of centimeter|,Non-data,51
| WiTrack 20 [5] uses more an- tennas to support multi-user localization based on FMCW Their methods are based on WiFi signals and customized transceivers that are not available on COTS mobile devices In addition, the techniques in [21,22] use FMCW with audio signals to track the chest motion and finger movement, re- spectively|,Non-data,51
| Finally, the work in [15, 20, 23] work on acoustic ranging between devices iLock differs from these work in the research problem and also system implementation 7 CONCLUSION In this paper, we presented the design and evaluation of iLock, a secure and usable defense against data theft on a lost/stolen mobile device|,Non-data,51
| iLock automatically, quickly, and accurately detects the user’s physical separation from his/her device Once significant physical separation is de- 943tected, iLock immediately locks the device to thwart data theft Relying on acoustic signals, iLock can be deployed on most COTS mobile devices with standard built-in micro- phones and speakers Extensive experiments on Samsung Galaxy S5 confirmed the high efficacy of iLock with negligi- ble false positives and negatives|,Non-data,51
| Acknowledgement The authors would like to thank the anonymous reviewers for their constructive comments and helpful advice This work was partially supported by the US National Science Foundation under grants CNS-1320906, CNS-1421999, and CNS-1514381 8 |,Non-data,51
|ABSTRACT Motivated by the impossibility of achieving fairness in secure com- putation [Cleve, STOC 1986], recent works study a model of fair- ness in which an adversarial party that aborts on receiving output is forced to pay a mutually predefined monetary penalty to every other party that did not receive the output These works show how to design protocols for secure computation with penalties that tol- erate an arbitrary number of corruptions In this work, we improve the efficiency of protocols for secure computation with penalties in a hybrid model where parties have access to the “claim-or-refund” transaction functionality Our first improvement is for the ladder protocol of Bentov and Kumaresan (Crypto 2014) where we improve the dependence of the script com- plexity of the protocol (which corresponds to miner verification load and also space on the blockchain) on the number of parties from quadratic to linear (and in particular, is completely indepen- dent of the underlying function)|,Non-data,52
| Our second improvement is for the see-saw protocol of Kumaresan et al (CCS 2015) where we re- duce the total number of claim-or-refund transactions and also the script complexity from quadratic to linear in the number of parties We also present a ‘dual-mode’ protocol that offers different guar- antees depending on the number of corrupt parties: (1) when s < n/2 parties are corrupt, this protocol guarantees fairness (ie|,Non-data,52
|, ei- ther all parties get the output or none do), and (2) when t > n/2 parties are corrupt, this protocol guarantees fairness with penalties (ie, if the adversary gets the output, then either the honest parties get output as well or they get compensation via penalizing the ad- versary) The above protocol works as long as t + s < n, matching the bound obtained for secure computation protocols in the stan- dard model (i|,Non-data,52
|e, replacing “fairness with penalties” with “security- with-abort” (full security except fairness)) by Ishai et al (SICOMP 2011) Keywords: Bitcoin, secure computation, fairness|,Non-data,52
| 1 INTRODUCTION Protocols for secure multiparty computation [29, 15, 8, 11] allow a set of mutually distrusting parties to carry out a distributed com- putation without compromising on privacy of inputs or correctness Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted|,Non-data,52
| To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acmorg CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s)|,Non-data,52
 Publication rights licensed to ACM ISBN 978-1-4503-4139-4/16/10  ,Non-data,52
 $1500 DOI: http://dxdoiorg/10,Non-data,52
|1145/29767492978421 of the end result Despite being a powerful tool, it is known that se- cure computation protocols do not provide fairness or guaranteed output delivery when a majority of the parties are dishonest [12]1 Addressing this deficiency is critical if secure computation is to be widely adopted in practice, especially given the current interest in practical secure computation|,Non-data,52
| Several workarounds have been pro- posed in the literature to counter adversaries that may decide to abort, possibly depending on the outcome of the protocol (see [28, 4, 23, 17]) In this work, we are interested in the workaround pro- posed in [24, 23, 7] where an adversarial party that aborts on receiv- ing output is forced to pay a mutually predefined monetary penalty to every other part that did not receive the output In practice, such mechanisms would be effective if the compensation amount is rightly defined While the original works [24, 23, 7] depended on e-cash systems, recent works [5, 2, 9, 21, 1, 22, 19] have shown how to use a decentralized digital currency (like Bitcoin) to design protocols for secure computation in the penalty model|,Non-data,52
 Our contributions in a nutshell We present two efficiency im- provements to secure computation with penalties • We improve the total size of the transactions (more concretely “script complexity” defined below) used in secure computa- tion with penalties for single stage computations Let f de- note the function being computed,Non-data,52
| Prior work by Bentov and Kumaresan [9] required transactions of total size O(n2||z||) where n is the number of parties and ||z|| is the size of the output of f We present a protocol that requires transactions of total size O(nλ) where λ is the security parameter, and is independent of f This protocol works in the programmable random oracle model • We improve the number of transactions and the total size of the transactions used in secure computation with penalties for multiple stage computations|,Non-data,52
| Prior scheme by Kumare- san et al [22] had the number of transactions grow quadrati- cally in the number of parties n We present a protocol whose number of transactions grows linearly in n In particular, this implies that the n-party poker protocol (among other appli- cations) as described in [22] can be implemented using only linear number of transactions|,Non-data,52
| Additionally, we present the following qualitative improvement to secure computation with penalties • We present a “dual mode” protocol (alternatively, “best-of- both-worlds” protocol) that offers different guarantees de- pending on the number of corrupt parties: (1) when s < n/2 1Fairness guarantees that if one party receives output then all par- ties receive output Guaranteed output delivery ensures that an ad- versary cannot prevent the honest parties from computing the func- tion 406parties are corrupt, this protocol guarantees fairness (i|,Non-data,52
|e, ei- ther all parties get the output or none do), and (2) when t > n/2 parties are corrupt, this protocol guarantees fair- ness with penalties (ie, if the adversary gets the output, then either the honest parties get output as well or they get com- pensation via penalizing the adversary)|,Non-data,52
| The above protocol works as long as t + s < n, matching the bound obtained for secure computation protocols in the standard model (ie, re- placing “fairness with penalties” with “security-with-abort” (full security except fairness)) by [18] Next, we discuss the model and efficiency metrics for secure computation with penalties|,Non-data,52
| We follow the model used in [9, 21, 22] where parties are assumed to have access to the “claim-or- refund” transaction functionality (discussed below) This func- tionality can be implemented in Bitcoin (subject to limitations dis- cussed below) or in Ethereum Claim-or-refund transaction functionality In [9, 22], protocols for secure computation with penalties are designed in a hybrid model where parties have access to an ideal transaction functionality called the claim-or-refund transaction functionality [9, 6, 26]|,Non-data,52
| This func- tionality, denoted as F∗ CR, takes care of handling “money/coins” and allows protocols to be designed independently of the Bitcoin ecosystem F∗ CR implements the following functionality: (1) it ac- cepts a deposit of coins(q), a Boolean circuit φ, and a time-limit τ from a designated sender S; and (2) waits until time τ to get a witness w from a designated receiver R such that φ(w) = 1; and (3) if such a witness was received within time τ transfers coins(q) to R; (4) else returns coins(q) back to S Three features of F∗ CR explain its importance: (1) F∗ CR can be very efficiently implemented in Bitcoin [9, 6, 26] or in Ethereum, (2) F∗ CR provides an abstraction which makes protocols designed in the F∗ CR-hybrid model robust to changes in the Bitcoin archi- tecture, and (3) F∗ CR is “complete” for secure computation with penalties [9, 22] Protocols for secure computation with penalties CR-hybrid model work as long as F∗ designed in the F∗ CR is imple- mented|,Non-data,52
| Such an implementation need not be tied to Bitcoin, ie, Bank of America, Paypal, etc could, in principle, support F∗ CR transactions|,Non-data,52
| Each of the latter provides services by relying on its own network for providing consistency of its “ledger” and at this level, the underlying mechanics is not very different from Bitcoin Practical relevance of our contributions Next, we discuss the cost of secure computation with penalties in the F∗ CR-hybrid model so that our contributions can be better understood A protocol for secure computation with penalties in the F∗ CR-hybrid model typ- ically involves an sequence of F∗ CR transactions|,Non-data,52
 The following metrics capture the costs of such a protocol: • The total number of calls to F∗ CR This captures the number of Bitcoin transactions that need to be broadcasted Recall that each transaction stays in the blockchain forever • The maximum/total size of the Boolean circuits φ employed in the sequence,Non-data,52
 We refer to this as the “script complexity” of the protocol since this goes inside the script of the F∗ CR Bitcoin transaction Script complexity captures the load on the Bitcoin network and the verification time for the miners and SPV nodes Larger φ also translates to larger scripts and consequently larger transactions and transmitting them across the network would also become a bottleneck2 • The maximum/total amount of deposits (i,Non-data,52
|e, money) made to F∗ CR This captures the amount of collateral that each party 2We denote scripts as circuits (not as RAM programs) and their size is proportional to their running time needs to input during the protocol (and will remain unusable till the protocol completes)|,Non-data,52
 Recall that each honest party would regain its deposit at the end of the protocol • The maximum time-limit τ used in the sequence This cap- tures the total time to completion for the protocol Recall that each transaction takes roughly 1 hour to be confirmed on the Bitcoin blockchain,Non-data,52
 Our goal is to minimize these costs as much as possible We refer to the first and second costs as “on-chain” costs since these costs are shared by the Bitcoin miners and affect the Bitcoin system as a whole See also the discussion in [25] We refer to the third and the fourth costs as “off-chain” costs since these are costs borne by the parties running the secure computation protocol,Non-data,52
| Note that the above arguments are valid for any other alt-coin as well Anyway, in this work, we focus on improving the “on-chain” costs since we believe these to be the major bottleneck Our protocols make heavy use of secure computation protocols but these are done off- chain (except in our construction for the reactive setting), so their costs are only shared between the participants and not by the Bit- coin system Finally, we note that in the non-reactive case our re- sults provide a improvement in the script complexity over [9] while keeping all other parameters equal|,Non-data,52
| On the other hand, in the reac- tive case, our results improve the script complexity relative to [22] but perform worse in the total/max deposit expected While [22]’s deposits grow linearly in the number of stages of the reactive proto- col, ours grows quadratically (Note that the remaining parameters are equal in both constructions) Note that this is consistent with our motivation of relieving the burden on the Bitcoin system and off-loading more burden on the specific participants of the secure computation with penalties protocol|,Non-data,52
| Important notes and caveats about the model Our model is es- sentially the standard model used in secure computation literature except that we allow working in the F∗ (More formal description of the model can be found in the next sec- tion and also in [9]) While this model is Bitcoin-inspired, it is Bitcoin-independent Currently, there are several important limita- tions about implementing F∗ CR in Bitcoin|,Non-data,52
| For instance, the scripts that can go inside a Bitcoin transaction (specifically, the value φ in an F∗ CR transaction) are very limited—not all scripts are cur- rently supported There are also ongoing issues about malleability of transactions and how it affects F∗ CR implementation (see discus- sion in [3]) Newer and simpler implementations of F∗ CR namely via OP_CHECKLOCKTIMEVERIFY have been suggested and ac- cepted The bottomline is that the Bitcoin code is highly volatile|,Non-data,52
| This is main reason why we follow the model in [9, 21, 22] and work in an idealized model (ie, by abstracting the F∗ CR trans- action as an ideal functionality) with the hope of providing tech- niques and results that are resistant to the frequent changes to the Bitcoin code Furthermore, since the limitations in the Bitcoin re- alization are by no means fundamental (as evidenced by Ethereum that proposes to realize all types of transaction functionalities), our constructions also have practical value both in the Bitcoin system and also elsewhere|,Non-data,52
| To summarize, our results on secure com- putation with penalties work on Bitcoin (or an alt-coin or using a bank/trusted party) as long as the underlying F∗ CR transactions are implementable in Bitcoin (or the corresponding alt-coin or a bank/trusted party) At least one alt-coin, namely Ethereum, sup- ports programmable contracts with no limitations on scripts and thus can be used to implement our protocols Related work We discussed the relation between our work and the works of [9, 22]|,Non-data,52
| The works of [5, 6] construct 2-party lottery protocols using Bitcoin scripts which essentially implement F∗ CR CR-hybrid model 407Other notable works which are not in the F∗ CR model include the works of [2, 1, 20, 19, 21] The works of [20, 19] use a more power- ful transaction functionality which implements a ledger/blockchain to implement “smart contracts” and fair secure computation (un- der the penalties notion)|,Non-data,52
| Hawk [20] also provides financial pri- vacy which our protocols do not provide Ethereum supports pro- grammable transactions and smart contracts from scratch We wish to emphasize that protocols constructed in the F∗ CR-hybrid model can be easily cast into protocols in any of the above models Also, we make an explicit distinction between the off-chain costs and the on-chain costs which is not always captured in other works|,Non-data,52
| For instance, in Ethereum, the entire smart contract (or the func- tion) is put on the blockchain, and in a naïve construction, every miner is involved in the computation of the function as well as the state changes associated with executing the contract These are ex- actly the type of burdens on the miners that we are trying to relieve via use of (possibly expensive) off-chain mechanisms (eg, secure computation)|,Non-data,52
| 2 PRELIMINARIES A function μ(·) is negligible in λ if for every positive polynomial p(·) and all sufficiently large λ’s it holds that μ(λ) < 1/p(λ) A probability ensemble X = {X(a, λ)}a∈{0,1}∗,n∈N is an infinite sequence of random variables indexed by a and λ ∈ N Two dis- tribution ensembles X = {X(a, λ)}λ∈N and Y = {Y (a, λ)}λ∈N c≡ Y are said to be computationally indistinguishable, denoted X if for every non-uniform polynomial-time algorithm D there exists a negligible function μ(·) such that for every a ∈ {0, 1}∗, ||Pr[D(X(a, λ)) = 1] − Pr[D(Y (a, λ)) = 1]|| ≤ μ(λ)|,Non-data,52
| All parties are assumed to run in time polynomial in the security parameter λ We prove security in the “secure computation with coins” (SCC) model proposed in [9] Note that the main difference from standard definitions of secure computation [14] is that (1) the model treats coins as atomic entities that are fungible and cannot be duplicated, (2) the adversary cannot produce/destroy coins; only the environment Z has such powers, and (3) the view of Z contains the distribution of coins3 Let IDEALf,S,Z (λ, z) denote the output of environment Z initialized with input z after interacting in the ideal process with ideal process adversary S and ideal functional- ity Gf on security parameter λ|,Non-data,52
| Recall that our protocols will be run in a hybrid model where parties will have access to a (stan- dard or special) ideal functionality Gg We denote the output of Z after interacting in an execution of π in such a model with A by π,A,Z (λ, z), where z denotes Z’s input We are now ready HYBRIDg to define what it means for a protocol to SCC realize a functionality DEFINITION 1|,Non-data,52
| Let n ∈ N Let π be a probabilistic polynomial-time n-party protocol and let Gf be a probabilistic polynomial-time n-party ideal functionality We say that π SCC realizes Gf with abort in the Gg-hybrid model (where Gg is a standard or a special ideal functionality) if for every non-uniform probabilistic polynomial-time adversary A attacking π there ex- ists a non-uniform probabilistic polynomial-time adversary S for the ideal model such that for every non-uniform probabilistic 3Note that typically in the simulation, coins are being exchanged between the ideal functionality, the simulator, and the adversary that the simulator is simulating By (1) and (2) above, it follows that the simulator cannot send coins to the ideal functionality that it had already sent to the adversary (and vice versa)|,Non-data,52
| • Output phase: F (cid:63) f with session identifier sid, security parameter 1λ, penalty amount q, running with parties P1,    , Pn, and adversary S that corrupts parties {Ps}s∈C proceeds as follows: Let H = [n]\ C, and h = ||H|||,Non-data,52
| Let d be a parameter representing the safety deposit • Input phase: Wait to receive a message (input, sid, ssid, r, yr, coins(d)) from Pr for all r ∈ H Then wait to receive a message (input, sid, ssid, {ys}s∈C , coins(hq)) from S – Send (return, sid, ssid, coins(d)) to Pr for all r ∈ H|,Non-data,52
| – Compute (z1,    , zn) ← f (y1, |,Non-data,52
|   , yn) – Send message (output, sid, ssid, {zs}s∈C ) to S|,Non-data,52
| – If S returns send (output, sid, ssid, zr) to Pr for all r ∈ H, and send (payback, sid, ssid, coins((h − ||Hout||)q)) to S, and send (extrapay, sid, ssid, coins(q)) to Pr for each r ∈ Hout – Else if S returns (abort, sid, ssid), send (penalty, sid, ssid, coins(q)) to Pr for all r ∈ H (continue, sid, ssid, Hout), then Figure 1: Secure (non-reactive) computation with penalties F (cid:63) f  polynomial-time adversary Z, {IDEALf,S,Z (λ, z)}λ∈N,z∈{0,1}∗ c≡ {HYBRIDg π,A,Z (λ, z)}λ∈N,z∈{0,1}∗ |,Non-data,52
| ♦ f according to Definition 1 DEFINITION 2 Let π be a protocol and f be a multiparty func- tion We say that π securely computes f with penalties if π SCC- realizes the functionality F (cid:63) Throughout this paper, we deal only with static adversaries|,Non-data,52
| Also, unless otherwise stated, we deal with the case where a majority of parties are dishonest 21 Ideal Functionalities Secure computation with penalties—non-reactive case Loosely speaking, our notion of fair secure computation guarantees: An honest party never has to pay any penalty|,Non-data,52
| If a party aborts after learning the output and does not deliver output to honest parties, then every honest party is compen- sated f Ideal functionality F (cid:63) f for the non-reactive case [9, 22, 21, 1] See Figure 1 for a formal description In the first phase, the func- f receives inputs for f from all parties|,Non-data,52
| In addition, F (cid:63) tionality F (cid:63) allows the ideal world adverary S to deposit some coins which may be used to compensate honest parties if S aborts after receiving the outputs Note that an honest party makes a fixed deposit coins(d) in the input phase Then, in the output phase, F (cid:63) f returns the de- posit made by honest parties back to them If insufficient number of coins are deposited, then S does not obtain the output, yet may potentially pay penalty to some subset of the honest parties|,Non-data,52
| If S deposited sufficient number of coins, then it gets a chance to look at the output and then decide to continue delivering output to all par- ties, or just abort, in which case all honest parties are compensated using the penalty deposited by S Secure computation with penalties—reactive case Loosely speaking, our notion of fair reactive secure computation guaran- tees: An honest party never has to pay any penalty If a party aborts after the computation has started (even though it may not learn outputs of all stages of the reactive computa- tion) and does not deliver output to honest parties, then every honest party is compensated|,Non-data,52
| 408F (cid:63) f with session identifier sid, security parameter 1λ, penalty amount q, running with parties P1,    , Pn, and adversary S that corrupts parties {Ps}s∈C proceeds as follows: Let H = [n] \ C, and h = ||H|||,Non-data,52
| Let d be a parameter representing the safety deposit Initialize state0 := NULL and flag := 1 Note that f = (f1,  |,Non-data,52
|  , fρ) is a reactive function composed of ρ stages • Deposit phase: Wait to receive a message (deposit, sid, ssid, r, coins(d) from Pr for all r ∈ H to receive (deposit, sid, ssid, coins(hq)) from S|,Non-data,52
| Then wait • Computation phase: For each (cid:96) = 1,    , ρ, do: (x(cid:96),1, |,Non-data,52
|   , x(cid:96),n) – Wait to receive a message (input, sid, ssid, r, x(cid:96),r) from Pr for all r ∈ H|,Non-data,52
| – If S sends (abort, sid, ssid, {coins(qr)}r∈H ), send (penalty, sid, ssid, coins(q + qr)) to Pr for all r ∈ H, set flag := 0, and terminate phase – Else if S sends (input, sid, ssid, {x(cid:96),s}s∈C ), set x(cid:96) = – Compute (z(cid:96), state(cid:96)) ← f(cid:96)(x(cid:96); state(cid:96)−1), and parse z(cid:96) to ob- – Send (output, sid, ssid, {zs,(cid:96)}s∈C ) to S – If S returns (continue, sid, ssid), then send (output, sid, ssid, z(cid:96),r) to Pr for all r ∈ H – Else if S sends (abort, sid, ssid, {coins(qr)}r∈H ), send (penalty, sid, ssid, coins(q + qr)) to Pr for all r ∈ H, set flag = 0, and terminate phase|,Non-data,52
| tain (z(cid:96),1,    , z(cid:96),n)|,Non-data,52
| Figure 2: Secure (reactive) computation with penalties F∗ f  Ideal functionality F (cid:63) f for the reactive case [9, 22, 21, 1] It is very similar to the description in Figure 1 except the simulator is required to produce coins(hq) up front in a deposit stage Also, now the computation proceeds in stages, with each stage delivering output, and aborts after every stage are penalized|,Non-data,52
| See Figure 2 for a formal description Note that f = (f1,   |,Non-data,52
| , fρ) is a reactive func- tion composed of ρ stages The variable statei captures the state of the reactive computation and the variable flag indicates whether there has been an abort Ideal functionality F (cid:63) CR [9, 6, 26] This special ideal functionality has found tremendous application in the design of multiparty fair secure computation and lottery protocols [9]|,Non-data,52
| We elaborate more on the definition of the ideal functionality F∗ CR below See Figure 3 for a formal description At a high level, F (cid:63) CR allows a sender Ps to conditionally send coins(x) to a receiver Pr The condition is formalized as the revelation of a satisfying assignment (i|,Non-data,52
|e, wit- ness) for a sender-specified circuit φs,r( · ; z) (ie, relation) that may depend on some public input z|,Non-data,52
| Further, there is a “time” bound, formalized as a round number τ, within which Pr has to act in order to claim the coins Note that the satisfying witness is made public by F (cid:63) CR Bitcoin, or alternatively a cryptocurrency that supports time-locks and scripts, can be used to realize F∗ CR [9, 6, 26] In the Bitcoin realization of F∗ CR, sending a message with coins(x) corresponds to broadcasting a transaction to the Bitcoin network, and waiting according to some time parameter until there is enough confidence that the transaction will not be reversed|,Non-data,52
| We denote an F (cid:63) CR transaction where sender Ps asks receiver Pr for a witness for a predicate φ in exchange for coins(q) with deadline round τ by: Ps −−−−−−−−−−−−−→ φ q,τ Pr F (cid:63) CR with session identifier sid, running with parties Ps and Pr, a parameter 1λ, and adversary S proceeds as follows: • Deposit phase Upon receiving the tuple (deposit, sid, ssid, s, r, φs,r, τ, coins(x)) from Ps, record the message (deposit, sid, ssid, s, r, φs,r, τ, x) and send it to all par- ties Ignore any future deposit messages with the same ssid from Ps to Pr • Claim phase|,Non-data,52
| In round τ, upon receiving (claim, sid, ssid, s, r, φs,r, τ, x, w) from Pr, check if (1) a tuple (deposit, sid, ssid, s, r, φs,r, τ, x) was recorded, and (2) if φs,r(w) = 1 If both checks pass, send (claim, sid, ssid, s, r, φs,r, τ, x, w) to all parties, send (claim, sid, ssid, s, r, φs,r, τ, coins(x)) to Pr, and delete the record (deposit, sid, ssid, s, r, φs,r, τ, x) • Refund phase: In round τ + 1, if the record (deposit, sid, ssid, s, r, φs,r, τ, x) was not deleted, then send (refund, sid, ssid, s, r, φs,r, τ, coins(x)) to Ps, and delete the record (deposit, sid, ssid, s, r, φs,r, τ, x) Figure 3: The special ideal functionality F (cid:63) CR|,Non-data,52
| We formally define script complexity of a protocol consisting of a sequence of F∗ CR deposits DEFINITION 3 (SCRIPT COMPLEXITY [21]) Let Π be a protocol among n parties P1,  |,Non-data,52
|  , Pn in the F∗ CR-hybrid model For circuit φ, let ||φ|| denote its circuit complexity For a given ex- ecution of Π starting from a particular initialization Ω of parties’ inputs and random tapes and distribution of coins, let VΠ,Ω denote the sum of all ||φ|| such that some honest party claimed an F∗ CR transaction by producing a witness for φ during an execution of Π|,Non-data,52
| Then the script complexity of Π, denoted VΠ, equals maxΩ (VΠ,Ω) ♦ Note: Often while denoting the script complexity of a scheme, we ignore poly(λ) factors and focus on the dependence on the number of parties n, the function f, and the round complexity r of an arbi- trary n-party protocol This is purely for the sake of clarity and to better present our improvements Also, we extensively use the ran- dom oracle model|,Non-data,52
| We chose to do this (even when standard model alternatives exist in some cases) for the sake of clarity, consistency, and to better present our main ideas Throughout this paper, we denote the random oracles as Hash and Hash(cid:48) The latter is a pro- grammable random oracle while the former is non-programmable If security under standard assumptions is desired, then Hash can be replaced by an honest-binding commitment [13, 9, 22]|,Non-data,52
| However, this substitution might affect some of our theorems (notably, the one related to compact ladder) Also, we focus on the SCC model and while our protocols do not require rewinding in the proofs wrt coins or cryptographic primitivies, there are subtle issues while try- ing to guarantee universal composability in the programmable ran- dom oracle model See [10] for more extensive discussion Remark on cash distribution|,Non-data,52
| The works of [2, 1, 22] gave pro- tocols for secure cash distribution with penalties (SCD) in the two- party and multiparty settings Although we do not discuss this in the paper due to space limitations, we note that the mechanism to add cash distribution to our reactive protocols is straightforward and thus, our protocols can be directly upgraded (using a generic compiler) to handle secure cash distribution with penalties Since SCD models stateful reactive functionalities it provides a way to securely implement smart contracts (as discussed in [22, 20]) in a 409Roof deposits For each j ∈ [n − 1] simultaneously: −−−−−−−−−−−−−−−−→ φn Pj Pn (Txn,j) q,τn Ladder deposits|,Non-data,52
| For i = n − 1 down to 1 (one-by-one): Pi+1 −−−−−−−−−−−−−−−−→ φi i·q,τi Pi (Txi) The ladder mechanism is parameterized by a protocol Init, predicates φ1,    , φn, and procedures Extend and Recon|,Non-data,52
| Initialization Parties P1,   |,Non-data,52
| , Pn run Init with their respec- tive inputs x1,    , xn to obtain respective outputs y1, |,Non-data,52
|   , yn If there is an abort in this step such that some parties did not obtain their outputs, then all parties terminate and output ⊥|,Non-data,52
| Roof deposits For each j ∈ [n − 1] simultaneously: Figure 4: Deposits in the ladder mechanism [9] Pj decentralized setting, and consequently captures a wide variety of applications such as games, auctions, markets, etc Remark|,Non-data,52
| We give the strongest possible theorem statements cor- responding to our results That is, we may present constructions in the random oracle model (for the sake of clarity and to avoid cumbersome notation) even when there a construction that is based on one-way functions However our theorems will be stated as assuming the existence of one-way functions if that’s indeed the case Also, we present the planted ladder mechanism as one that takes an r-round protocol as a parameter and discuss efficiency in the text as a function of r|,Non-data,52
| Since in order to implement reactive MPC with penalties it suffices to use a constant-round protocol, ie, r = O(1), our theorem statement ignores r when describing the efficiency Likewise, sometimes we state our theorems as oper- ating in the FOT-hybrid model (i|,Non-data,52
|e, with ideal oblivious transfer) Recall that OT implies MPC unconditionally 3|,Non-data,52
| THE LADDER MECHANISM Since our efficiency improvements come from modifying the ladder mechanism of [9], we briefly describe this mechanism Fig- ure 5 contains a description of the ladder mechanism Each party Pi enters the ladder mechanism holding some private input yi For the ladder mechanism to be useful to construct a protocol for se- cure computation with penalties, the predicates {φi}i∈[n] (which are parameters to the ladder mechanism) need to satisfy the follow- ing two informal properties: • Extensibility|,Non-data,52
 It is possible to satisfy φi+1 (and claim Txi+1) using yi+1 and a witness that satisfies φi • Unforgeability It is computationally infeasible to satisfy φi+1 given only {yj}j(cid:54)=i and witnesses to {φj}j<i (in par- ticular without a witness to φi) We now proceed to describe the ladder mechanism,Non-data,52
| The mech- anism is a sequence of F∗ CR deposits split into two phases In the first phase, known as the roof deposits, all parties except Pn make an F∗ CR deposit to Pn for an amount of coins(q) and with predi- cate φn If all roof deposits are made, then parties enter the second phase, known as the ladder deposits Here first Pn makes an F∗ deposit to Pn−1 for an amount of coins((n − 1)q) and with predi- CR cate φn−1|,Non-data,52
| Likewise, Pn−1 makes an F∗ CR deposit to Pn−2 for an amount of coins((n − 2)q) and with predicate φn−2 This contin- ues all the way down to P2 who makes an F∗ CR deposit to P1 for an amount of coins(q) and with predicate φ1 The sequence of F∗ CR deposits in the ladder mechanism are claimed in reverse First, P1 claims Tx1|,Non-data,52
| Then P2 claims Tx2, and so on until finally Pn claims all Txn,j for j (cid:54)= n This sequence of claims is enabled by the extensibility property described above Next, we briefly describe how aborts are typically handled in the ladder mechanism If some party aborts during the roof deposit phase, then parties terminate immediately (and wait for F∗ CR deposits to be refunded—this is −−−−−−−−−−−−−−−−→ φn Pn (Txn,j) q,τn Handling aborts|,Non-data,52
| If a party Pj does not make an F∗ CR deposit to Pn as above, then each party Pi terminates the protocol and wait to collect refund from Txn,i (for i (cid:54)= n) Ladder deposits For i = n − 1 down to 1 (one-by-one): −−−−−−−−−−−−−−−−→ Pi+1 φi i·q,τi Pi (Txi) Handling aborts If a party Pi+1 does not make an F∗ CR de- posit to Pi as above, then (1) each party Pj for j ≤ i does not make its ladder deposit (i|,Non-data,52
|e, Txj−1) and waits to collect refund from Txn,j (for j (cid:54)= n), and (2) each party Pj for j > i continues on to the ladder claim phase Claims P1 claims Tx1 using witness α1 = Extend(1,⊥; y1)|,Non-data,52
| For i = 1 to n − 1 (one-by-one), at time τi: • If Pi claimed Txi, then let αi be the witness satisfying φi Pi+1 computes αi+1 ← Extend(i + 1, αi; yi+1) If i + 1 (cid:54)= n, then Pi+1 claims Txi+1 using witness αi+1 If i + 1 = n, then Pn claims Txn,j for all j using witness αn|,Non-data,52
| • If Pi did not claim Txi, then Pi+1 terminates the proto- col and waits to collect refund from Txn,i+1 if i + 1 (cid:54)= n Output If Txn,j was claimed by Pn for some j, then let αn be the witness satisfying φn Each party Pi outputs zi = Recon(αn; yi) and terminates the protocol|,Non-data,52
| If no Txn,j was claimed, then each party outputs ⊥ Figure 5: Protocol framework for the ladder mechanism guaranteed by the unforgeability property above), and in particular do not make any ladder deposits If some party Pi+1 did not make its F∗ CR deposit to Pi in the ladder deposit phase, then (1) each Pj for j ≤ i does not make its ladder deposit, and (2) each Pj (for j (cid:54)= n) claims Txj iff Pj−1 claimed Txj−1, and (3) Pn claims Txn,j for all j (cid:54)= n iff Pn−1 claimed Txn−1|,Non-data,52
| We formally present the framework for the ladder mechanism that we described above in Figure 5 This framework takes as parameters a protocol Init, a set of predicates {φi}i∈[rn], and procedures Extend and Recon Usefulness for secure computation with penalties Given the above, we briefly provide some intuition on why the ladder mecha- nism is useful for secure computation with penalties|,Non-data,52
| Let i+1 < n First, note that Txn,i+1 locks up coins(q) belonging to Pi+1 Now, if Txi is claimed, then Pi+1 would have lost coins(i · q) to Pi However, by the extensibility property, Pi+1 will be able to claim Txi+1 and obtain coins((i+1)·q) from Pi+2|,Non-data,52
| Claiming Txi+1 will release the witness for the predicate φi+1 to all other parties The main assertion is thus the following: when a party Pi+1 releases a witness for the predicate φi+1, then at this point it has neither gained nor lost coins Now suppose, Pn (either corrupt or honest) 410Protocol Init Parties P1, |,Non-data,52
|   , Pn with their MPC inputs x1,  |,Non-data,52
|  , xn run an MPC protocol that • computes z ← f (x1,   |,Non-data,52
| , xn); • n-out-of-n secret shares z into z1,    , zn; • samples ω1, |,Non-data,52
|   , ωn at random from {0, 1}λ; • for j ∈ [n]: computes hj = Hash(zj(cid:107)ωj); • for i ∈ [n]: outputs yi = zi(cid:107)ωi and {hj}j∈[n] to party Pi Predicates|,Non-data,52
| Note that the predicates have {hj}j∈[n] hard- coded in them Define φi as follows: φi (β1(cid:107)···(cid:107)βi;{hj}j≤i) = (Hash(β1) ?= h1) (cid:94)···(cid:94) (Hash(βi) ?= hi) Procedure Extend(i + 1, αi; yi+1): Output αi+1 = αi(cid:107)yi+1 Procedure Recon(αn; yi): Parse αn as β1(cid:107)···(cid:107)βn Parse each βi as z(cid:48) i|,Non-data,52
| Output(cid:76) i(cid:107)ω(cid:48) j∈[n]z(cid:48) j Figure 6: Parameters to the ladder mechanism from [9] does not reveal a witness to φn, then all the roof deposits Txn,j get refunded Thus, the following is true: If 1|,Non-data,52
| Pi+1 released a witness for the predicate φi+1, and 2 Pn did not release a witness for the predicate φn by time τn, then party Pi+1 would ultimately stand to gain coins(q) at the end of the protocol Bentov-Kumaresan parameters for the ladder mechanism to get MPC with penalties for a non-reactive function f Refer to Figure 6 for a description of the parameters for the ladder mech- anism used in [9]|,Non-data,52
| The protocol Init is an MPC among the parties that computes the function output and secret shares among the par- ties Then it commits to the shares using additional randomness (In the figure, we used a hash function Hash modeled as a random oracle It can safely be replaced by honest-binding commitments as in [9]|,Non-data,52
|) The parties get commitments to all shares and the de- commitment corresponding to their index The predicates φii∈[n] are defined in the following way: φi has {hj}j≤i hard-coded in it, and requires the hash preimages of these values Extensibility is readily guaranteed (as shown in Figure 6), and unforgeability is guaranteed via the random oracle (alternatively, binding property of the commitment) Finally, the procedure Recon takes the wit- ness to φn, i|,Non-data,52
|e, all the shares, and XORs them to obtain the final output This completes the description of the parameters for the ladder mechanism of [9] that yields MPC with penalties for a non- reactive function f It is easy to see that the script complexity of the above protocol grows quadratic in n|,Non-data,52
| 4 COMPACT LADDER In this section, we improve the efficiency of secure computation with penalties in the non-reactive setting Recall that the ladder protocol of [9] required script complexity Ω(n2||z||) where ||z|| is the size of the output of the non-reactive function We are going to improve this to O(nλ), and in particular make it completely inde- pendent of the function|,Non-data,52
| Protocol Init Parties P1,   |,Non-data,52
| , Pn with their MPC inputs x1,    , xn run an MPC protocol that • samples random k1, |,Non-data,52
|   , kn from {0, 1}λ; • for j ∈ [n]: computes hj = Hash(k1⊕···⊕kj); • computes e ← f (x1,  |,Non-data,52
|  , xn)⊕Hash(cid:48)(k1⊕···⊕kn); • for i ∈ [n]: outputs yi = ki, {hj}j∈[n], and e to party Pi Predicates Note that the predicate φi has hi hard-coded in it|,Non-data,52
| Define φi as follows: φi (αi; hi) = (Hash(αi) ?= hi) Procedure Extend(i+1, αi; yi+1): Output αi+1 = αi⊕yi+1 Procedure Recon(αn; yi): Output e⊕Hash(cid:48)(αn) Figure 7: Compact ladder parameters First ideas—using hybrid encryption|,Non-data,52
| A standard technique (also appearing in [16]) is to use an MPC to encrypt the actual output of the computation and then to secret share the keys among parties and allow to reconstruct the encryption key in a fair manner (in our case with the ladder mechanism) This has the immediate impact of reducing the script complexity to O(n2λ) In particular, the i-th predicate φi will have size O(iλ) (ignoring poly(λ) factors) One caveat is that for our strong security notion, we will need to use a programmable random oracle in order to achieve equivocation properties in the simulation proof|,Non-data,52
|4 (In contrast, [16] only consid- ered standalone security and could do away with semantic security of the encryption scheme) Compact ladder To further reduce the script complexity to O(nλ), we have a simple tweak to the parameters of the ladder mechanism The main idea to have the size of the i-th predicate φi be O(λ)|,Non-data,52
| To to do this, we run an MPC protocol in Init that gen- erates secret shares k1,    , kn of a key k that is used to encrypt the output of the computation|,Non-data,52
| The MPC protocol also generates hash images of the following form: hj = Hash(k1⊕···⊕kj) We then define the predicates as φi(αi; hi) = (Hash(αi) ?= hi) That is, the predicate φ has the value hi hard-coded in it and only takes a λ-bit input This is the main idea|,Non-data,52
| A formal description of the parameters appears in Figure 7 is O(nλ) Clearly, the script complexity of the resulting protocol, ie|,Non-data,52
|, the sum of the sizes of all predicates, It remains to be shown that the predicates satisfy the extensibility as well as the unforgeability property Extensibility follows from the fact that given a witness αi to the predicate φi and the secret value ki+1, the witness to the predicate φi+1 can be obtained as αi⊕ki+1 Unforgeabiility follows from the use of the random ora- cle More concretely, given the values k1, |,Non-data,52
|   , ki−1, ki+1,  |,Non-data,52
|  , kn and the hash values Hash(k1),   |,Non-data,52
| , Hash(k1⊕···⊕kn), is computationally infeasible to find a hash preimage of any of Hash(k1⊕···⊕ki),    , Hash(k1⊕···⊕kn) or even distinguish them from random|,Non-data,52
| In the formal simulation proof we also need to argue about the timing of various events (eg, interaction with the ideal functionality, the adversary, etc), distribution of coins, and it 4Alternatives in the standard model include use of non-committing encryption but here we would not be able to get the desirable effi- ciency [27]|,Non-data,52
 411equivocation of the final output We state our theorem and provide a proof sketch below and defer the full proof to the full version THEOREM 1 Assuming the existence of a programmable ran- CR)-hybrid f for any non-reactive function f,Non-data,52
| Fur- CR and has dom oracle, there exists a protocol in the (FOT,F∗ model that SCC-realizes F∗ thermore, the protocol makes only O(n) calls to F∗ script complexity O(nλ) Proof sketch The simulator S invokes the simulator of the MPC protocol in the initialization phase and generates a random string e as the encryption, random k1,  |,Non-data,52
|  , kn and distributes hash images on these values to the adversary A and also gives the value ki to each corrupt Pi S also extracts inputs of the corrupt parties in the previous step However, it does not directly send these inputs to the ideal functionality F∗ f since it may also needs to extract and submit coins(hq) to the ideal functionality (especially in the case when Pn is corrupt)|,Non-data,52
| Acting as F∗ CR, S simulates the deposit phases of the protocol Note that some of the deposits might not be made by A S emulates the honest parties to A exactly as described in the protocol (including how they react to deposits that were not made) When the claim phase starts and it’s the turn of an honest party Pj to claim Txj, S will use the value k1⊕···⊕kj|,Non-data,52
| It also receives corrupt parties’ claim witnesses via A Additionally, during the claim phase, S will need to produce coins whenever A claims them Suppose Pi is corrupt and it produces a valid witness α to claim Txi (For the time being, assume i (cid:54)= n; we’ll take care of this case later|,Non-data,52
|) To simulate this, S needs to produce coins(i · q) Ideally, we would ask S to get these coins via Txi−1, ie, coins((i − 1)q) and coins(q) from Pi’s roof deposit Txn,i|,Non-data,52
| How- ever, it is not clear that Txi−1 was even made by Pi Importantly, we are able to make the following claim: if Txi−1 was not made by Pi but Pi can produce valid witnesses to claim Txi, then for every j < i, party Pj is corrupt To prove the claim, we appeal to the unforgeability property of the predicates in the following way Note that according to the protocol description, if Txi−1 was not made, then for j < i an honest party Pj would not make Txj−1|,Non-data,52
| Since it never made a deposit Txj−1, this in turn means that it would never reveal a valid witness for Txj (note: honest Pj claims Txj iff Txj−1 is claimed) Then it follows from the unforgeability property that without a valid witness for Txj it is computationally infeasible to provide a valid witness to Txi Now we are ready to describe the simulation of the claims Tx1,  |,Non-data,52
|  , Txi (whichever were made) For transactions Txj with j < i that were claimed, we simply use corrupt Pj+1’s deposit of coins(jq) to give to cor- rupt Pj who’s claiming it For transaction Txi, we use coins(q) from the roof deposit of each of P1, |,Non-data,52
|   , Pi Recall Pi+1 is honest, and if Pi+1 made deposit Txi it must necessarily hold that all par- ties (in particular, P1, |,Non-data,52
|   , Pi) made roof deposits of coins(q) each The above strategy takes care of parties that try to claim a deposit Txi without make the deposit Txi−1|,Non-data,52
| In the rest of the proof, we assume that every Pi that tries to claim deposit Txi has made the deposit Txi−1 This case is handled easily: we ask S to get these coins via Txi−1, ie, coins((i − 1)q) and coins(q) from Pi’s roof deposit Txn,i (out of a total of coins(q))|,Non-data,52
 The above strategy works only for i (cid:54)= n We first complete the discussion assuming Pn is honest and then discuss the other case later Suppose Pn is honest We have already addressed how to handle coins during the claims,Non-data,52
| The only remaining thing to address is when to ask S to contact F∗ f  Let ic be the largest index such that Pic is corrupt S will contact the ideal functionality when Txic is claimed by Pic since it is clear that A will no longer abort the protocol S would then get the actual output z from the ideal functionality, and program Hash(cid:48) to return z⊕e (where e is the random string S distributed to the parties initially)|,Non-data,52
| Note that this is indistinguishable from the real execution as long as A did not query on the string k1⊕···⊕kn— an event that happens with negligible probability This completes the simulation when Pn is honest When Pn is corrupt, we need to show how to handle claims made by Pn and also how to handle the interaction with the ideal func- tionality Actually, when Txn−1 is deposited by Pn, S will take coins(hq) out of these coins((n − 1)q) (note: (n − 1) ≥ h) to deposit to the ideal functionality along with the inputs to the com- putation (extracted in the very first step)|,Non-data,52
 S would then get the ac- tual output from the ideal functionality Let ih be the largest index such that Pih is honest S will actually do the above steps of giving coins(hq) to F∗ f right before time τih so that it can obtain the ac- tual output z and program Hash(cid:48) such that Hash(cid:48)(k1⊕···⊕kn) = e⊕z This ensures that remaining honest messages are such that the view of the adversary is indistinguishable from the real execution,Non-data,52
| Also, S would ask F∗ f to deliver the output to all honest parties (because the corrupt parties did not abort the computation at all) and would get coins(hq) back from the ideal functionality which it can then use to handle Pn’s claim of Txn,j for all j since it now has exactly coins((n − 1)q) This completes the simulation when Pn is honest 5 PLANTED LADDER MECHANISM In this section, we improve the efficiency of secure computation with penalties in the reactive setting|,Non-data,52
| In the reactive setting, we have to deal with a multi-round protocol and guarantee its com- pletion or guarantee compensation to all honest parties Previous work by Kumaresan et al [22] showed the “see-saw protocol” for the reactive setting which is essentially an adaptation of the lad- der mechanism of [9] but that guarantees that all honest parties are compensated no matter where the abort happens However, to do this, they required Ω(n2) F∗ CR transactions and a script complexity of Ω(n2T ) where T is the size of the transcript of an n-party se- cure computation protocol that implements the reactive function f with security-with-abort|,Non-data,52
| We are going to improve both the script complexity to O(nT ) and the number of F∗ First ideas—tweaking the ladder mechanism The main idea be- hind the improvement is a simple set of tweaks to the ladder mecha- nism that preserves the structure of the mechanism and yet suffices for the reactive setting We first provide a rough sketch of the idea, then discuss the problem with the approach, and then proceed to give the fix CR calls to O(n)|,Non-data,52
| Note that since we have to handle multi-round protocols we let parties take turns to send messages until the entire protocol is com- pleted More concretely, suppose we have an r-round protocol π, then we essentially have r copies of the original ladder mechanism of [9] The k-th such copy (from the bottom) corresponds to the k-th round messages (there are n of them, one from each party) of π It is important to note that in the k-th copy of the ladder mecha- nism, party Pi+1 makes a deposit of coins((n(k− 1) + i)q)|,Non-data,52
| (Note how when k = 1, this is the same as the ladder mechanism in [9]) That is, the amount deposited keeps growing across the r copies of the ladder eventually ending in the last deposit of coins((nr−1)q) The best way to understand the planted ladder mechanism is to view the whole deposit sequence as a single ladder mechanism i ≡ Pi mod n The among rn virtual parties P (cid:48) main observation is that the ladder mechanism already guarantees compensation to parties who have made their move (i|,Non-data,52
|e, revealed their share or the next message of the protocol) in case the protocol is aborted Thus, if the protocol is aborted after the first copy of the ladder deposits have been claimed (ie|,Non-data,52
|, the first round of the pro- rn, where P (cid:48) 1,    , P (cid:48) 412Roof deposits|,Non-data,52
| For each j ∈ [n − 1] simultaneously: Pj −−−−−−−−−−−−−−−−−−−−→ n φrn∧φ(cid:48) (r+1)·q,τ(r+1)n Pn (Txn,j) Ladder deposits For i = rn − 1 down to 1 (one-by-one): Pi+1 mod n −−−−−−−−−−−−−−−−−→ n φi∧φ(cid:48) (n+i)·q,τn+i Pi mod n (Txn+i) Underground deposits For i = n down to 1 (one-by-one): Pi+1 mod n −−−−−−−−−−−−−−−−→ i φ(cid:48) i·q,τi Pi (Txi) Figure 8: Deposits in the planted ladder mechanism tocol has been completed), it follows that each honest party would be compensated! In fact, by the time the k-th copy of the lad- der deposits are claimed, each honest party would have coins(kq) as compensation in the case the protocol is aborted in this phase|,Non-data,52
| (Note that each party Pj for j (cid:54)= n would have deposited coins(rq) as the roof deposit That is, if the protocol is completed, then no party gains or loses money) The problem with the idea above is that aborts within the first copy of the ladder mechanism will not guarantee compensation to all honest parties (ie|,Non-data,52
|, not all parties would have gotten coins(q) as compensation) Dummy witnesses and underground deposits To fix this prob- lem, we use a simple idea: have the first copy of the ladder mech- anism reveal dummy witnesses which are independent of the actual computation That is, now there are (r + 1) copies of the ladder mechanism: the first copy is a special set of transactions that we call “underground” deposits, while the remaining r of them corre- spond to the actual r-round protocol|,Non-data,52
| The deposits are shown in Figure 8 The underground deposits essentially serve to bootstrap the com- putation Aborts during the underground claim phase may not com- pensate all honest parties, but this is not a problem since the mes- sages corresponding to the actual protocol have not been sent by anyone This amounts to aborting the protocol even before it started and is still a fair protocol since neither the honest parties nor the adversary obtain any information about the actual protocol|,Non-data,52
 Addi- tional ideas ensure that the underground deposits will be claimed before any of the deposits in the r copies of the ladder are claimed This ensures that aborts in any of the r copies will result in each honest party being compensated by the adversary A framework for the planted ladder mechanism We present a simple framework for the planted ladder mechanism in Figure 9,Non-data,52
| Just like the framework for the ladder protocol, this framework takes as parameters a protocol Init, a set of predicates {φi}i∈[rn], and procedures Extend and Recon As before we will crucially rely on the extensibility and unforgeabilty property of the predicates {φi}i∈[rn] (and also of the underground predicates {φ(cid:48) i}i∈[n]) In the initialization phase, parties run an MPC protocol that sets up the dummy witnesses k1,  |,Non-data,52
|  , kn and computes the Hash on XORs of the prefixes of the sequence of dummy witnesses This part is similar to our compact ladder mechanism (Again, one can re- place Hash with an honest-binding commitment as in [22]|,Non-data,52
|) Each party Pi receives the value ki and the images of k1,    , kn un- der Hash|,Non-data,52
| In addition parties run Init which is a parameter of the planted ladder mechanism The dummy witnesses define the un- n as: φ(cid:48) 1,   |,Non-data,52
| , φ(cid:48) n for j ∈ [rn] The extra predicate φ(cid:48) derground predicates φ(cid:48) i (αi; hi) = (Hash(αi) ?= hi) Af- ter this, parties enter the three deposit phases: Roof, Ladder, and Underground We already mentioned that the predicates for the underground deposits are φ(cid:48) n|,Non-data,52
| The predicates for the Roof and Ladder deposits are φj ∧ φ(cid:48) n is to ensure that the underground deposits are claimed before any of the ladder/roof deposits are claimed Other than these, there are essen- tially no differences between the ladder mechanism and the planted ladder mechanism One thing to note is that we sometimes interpret Recon as a protocol (instead of a procedure) This will be relevant to the dual mode protocol that we describe in the next section|,Non-data,52
| Intuition The best way to understand the planted ladder mech- anism is to view the whole deposit sequence as a single ladder mechanism among (r +1)n virtual parties P (cid:48) (r+1)n, where i ≡ Pi mod n P (cid:48) PROPOSITION 2 Honest parties do not lose money|,Non-data,52
| 1,    , P (cid:48) Proof sketch|,Non-data,52
| This actually follows from the extensibility property of the predicates {φ(cid:48) i} and {φi} More concretely, every time an honest party’s ladder/underground deposit, say Txj is claimed, the honest party Pj+1 mod n will always be able to claim Txj+1 Since claiming Txj+1 gives coins((j + 1)q) to Pj+1 mod n and since it would have lost only coins(jq) when Pj mod n claimed Txj, it follows that Pj+1 mod n never loses money during the ladder claim phase ie|,Non-data,52
|, before time τ(r+1)n−1 Now suppose there is some Txj+1 which Pj+1 mod n is unable to claim Then by the unforgeability property of the predicates it holds that transactions Txk for k > j + 1 cannot be claimed by Pk mod n In particular, the roof deposit Txn,j+1 cannot be claimed|,Non-data,52
| On the other hand, if Pj+1 mod n was able to claim all deposits made to it, then it follows that it would have gained coins((r + 1)q) during the course of the claims (ie, coins(q) for each of the r + 1 stages) This is also the maximum amount that it can lose during the roof claim by Pn|,Non-data,52
| This therefore means that honest parties will never lose money PROPOSITION 3 Suppose for some i, party Pi mod n is honest and revealed a witness to the predicate φi during the execution of the protocol Then either the protocol is completed (i|,Non-data,52
|e, Pn reveals a witness to the predicate φrn) or all honest parties get compensated Proof sketch By the unforgeability property of {φ(cid:48) i}i∈[n], it fol- lows that an honest party Pi reveals a witness to φi only if each honest party Pj revealed kj in the underground claim phase|,Non-data,52
| This is because for a party to claim the ladder deposit it needs to produce a witness that satisfies φ(cid:48) n which is possible only if each honest Pj revealed kj For the rest of the argument, we assume that all honest parties revealed the underground dummy witnesses Now suppose there is an abort Let Pi+1 mod n be an honest party such that (1) all honest parties Pj with j mod n ≤ i mod n could claim Txj for j < i, but (2) Pi+1 could not claim Txi+1|,Non-data,52
| From the above it follows that party Pi must be corrupt Also by the unforgeability property, we have that Txj for j > i cannot be claimed by Pj mod n since honest Pi+1 mod n did not reveal its witness αi+1 In particular, this means that the roof deposits will be refunded back to all honest parties Also all deposits Txj made by honest Pj mod n such that j > i will also be refunded back to Pj+1|,Non-data,52
| Finally, recall that all honest parties were able to reveal their dummy witnesses, therefore it must hold that i + 1 > n Now let us analyze how much money each honest party pos- If Pj+1 mod n is honest and sesses at the end of the protocol 413The planted ladder mechanism is parameterized by a proto- col Init, predicates {φi}i∈[rn], procedures Extend and Recon Note: In the following: Pi ≡ Pi mod n|,Non-data,52
| Also: n mod n (cid:44) n Initialization Parties P1,  |,Non-data,52
|  , Pn run an MPC protocol that • samples random k1,   |,Non-data,52
| , kn from {0, 1}λ; • for j ∈ [n]: computes hj = Hash(k1⊕···⊕kj); • for i ∈ [n]: outputs {hj}j∈[n] and ki to Pi In addition, parties P1,   |,Non-data,52
| , Pn run Init with their respective inputs x1,    , xn to obtain respective outputs y1, |,Non-data,52
|   , yn If there is an abort (either in Init or the protocol above) and some parties did not obtain their outputs, then all parties terminate and output ⊥|,Non-data,52
| The predicates φ(cid:48) i have hi hard-coded in them: (cid:48) i (αi; hi) = (Hash(αi) ?= hi) φ Roof deposits For each j ∈ [n − 1] simultaneously: Pj −−−−−−−−−−−−−−−−−−−−→ n φrn∧φ(cid:48) (r+1)·q,τ(r+1)n Pn (Txn,j) Handling aborts If Pj does not make deposit Txn,j, then each Pi terminates the protocol and waits to collect refund Ladder deposits|,Non-data,52
| For i = rn − 1 down to 1 (one-by-one): Pi+1 −−−−−−−−−−−−−−−−−→ n φi∧φ(cid:48) (n+i)·q,τn+i Pi (Txn+i) Handling aborts If Pi+1 does not make deposit Txn+i, then each Pj terminates the protocol and waits to collect refunds Underground deposits For i = n to 1 (one-by-one): Pi+1 −−−−−−−−−−−−−−−−→ i φ(cid:48) i·q,τi Pi (Txi) Handling aborts|,Non-data,52
| If Pi+1 does not make deposit Txi, then (1) each Pj+1 for j < i does not make deposit Txj and waits to collect refunds, while (2) each Pj+1 for j ≥ i continues on to the claim phase Underground claims P1 claims Tx1 using witness α(cid:48) For i = 1 to n − 1 (one-by-one), at time τi: 1 = k1 • If Pi claimed Txi, then let α(cid:48) φ(cid:48) i|,Non-data,52
| Then Pi+1 claims Txi+1 using witness α(cid:48) i be the witness satisfying i⊕ki+1 • If Pi did not claim Txi, then each Pj+1 terminates the protocol and waits to collect refunds Ladder/roof claims Let Xi = (xi, ωi, yi) where xi, yi re- spectively are inputs, outputs of Pi from Init and ωi is Pi’s private randomness|,Non-data,52
| For i > n, let Xi ≡ Xi mod n P1 claims Txn+1 using witness α1 ← Extend(1,⊥, X1) at time τn+i: • If Pi claimed Txi say using witness αi, then Pi+1 com- putes αi+1 = Extend(i + 1, αi, Xi+1) If i + 1 (cid:54)= rn, then Pi+1 claims Txi+1 using witness (αi+1, α(cid:48) n), else Pi+1 claims Txn,j for all j using witness (αrn, α(cid:48) • If Pi did not claim Txi, then Pi+1 terminates the proto- n) col and waits to collect refunds Output|,Non-data,52
| Parties run protocol Recon to generate output Figure 9: Framework for the planted ladder mechanism its ladder deposit Txj is claimed, then by the extensibility prop- erty Pj+1 mod n can claim Txj+1 The amounts in the mecha- nism are such that at time τj+1, Pj+1 would have an additional coins((j + 1)q) − coins(jq) = coins(q) for every Txj it claimed, i|,Non-data,52
|e, an additional coins(q) for every completed round Since (1) at least one round was completed (note: i + 1 > n), and (2) all deposits Txj for j > i were refunded, it follows from above that each honest party gets at least coins(q) as compensation Parameterizing the planted ladder mechanism to get MPC with penalties for a reactive function f|,Non-data,52
| Let π(cid:48) be an n-party r-round publicly verifiable MPC protocol realizing f with security-with- abort Let π(cid:48) be described by next message functions {nmf(cid:48) j}j∈[rn] and transcript validation functions {tv(cid:48) j}j∈[rn] We would want to derive the parameters Extend, Recon and the predicates φii∈[n] from the protocol π(cid:48) The predicates φii∈[n] could be defined in terms of the transcript validation functions|,Non-data,52
| While extensibility is readily guaranteed via the next message function, the unforge- ability property is not always clear (especially with respect to first round messages) However, adding the unforgeability property to π(cid:48) is possible via a simple transformation The idea is to ask parties to sign every message sent as part of π(cid:48) under their public key That is, the transcript TTj of the trans- formed protocol consisting of the first j messages would be of the form (μ1(cid:107)σ1)(cid:107)···(cid:107)(μj(cid:107)σj), where for each i, the value μi is the message that would have been sent in π(cid:48) and the value σi is a sig- nature under party Pi mod n’s public key on the message μi|,Non-data,52
| We denote the transformed protocol as π It is easy to see that Extend can be defined in terms of the next message function of π Like- wise, Recon may be defined as the procedure by which parties gen- erate the output in the protocol π Also, we define Init as the pro- tocol in which parties generate fresh public-key/signing-key pairs and distribute them via a local broadcast channel (i|,Non-data,52
|e, among the n parties) See Figure 10 for a formal description of the parameters Note that we have abstracted away several features of f and fo- cus on it as one single function for which we need to guarantee pro- tocol termination|,Non-data,52
| We already gave intuition as to why the planted ladder mechanism ensures protocol completion as long as the predi- cates {φi}i∈[n] satisfy both the extensibility and the unforgeability properties In the formal simulation proof we also need to argue about the timing of various events (eg, interaction with the ideal functionality, the adversary, etc|,Non-data,52
|), distribution of coins, and equivo- cation of the final output We state our theorem and provide a proof sketch below and defer the full proof to the full version THEOREM 4 Assume the existence of enhanced trapdoor per- mutations|,Non-data,52
| Let f be a reactive function that has a constant-round protocol UC-realizing it with security-with-abort, the size of whose transcript is T  Then there exists a protocol in the F∗ CR-hybrid model that SCC-realizes F∗ f which requires only O(n) calls to F∗ CR and whose script complexity is O(nT ) Proof sketch The simulator S acts as F∗ CR and also uses the simulator Sπ of the constant-round protocol π (after undergoing the transformation described above)|,Non-data,52
| S invokes the simulator of the MPC protocol in the initialization phase and generates random k1,    , kn and distributes commitments (or hash images) to the adversary A and also gives the value ki to each corrupt Pi|,Non-data,52
| S then invokes the simulator of Init and distributes fresh public-keys be- longing to honest parties and receives the public-keys of the corrupt parties from A Then acting as F∗ CR, S emulates the three deposit phases of the protocol Note that some of the deposits might not be made by A S emulates the honest parties to A exactly as described 414Protocol Init|,Non-data,52
| Parties P1,    , Pn each locally run KeyGen of a digital signature scheme (KeyGen, Sign, Verify) to generate fresh verification-key signing-key pairs|,Non-data,52
| Let (vkj, skj) be the key pair corresponding to Pj Each Pj then broadcasts vkj to all other parties At the end, each Pj outputs the set of all public keys {vki}i∈[n] and its private signing key skj The parameters Extend, Recon, and {φi}i∈[rn] are defined via the outputs of Init and a protocol π described below|,Non-data,52
| Protocol π Let π(cid:48) be an n-party r-round publicly veri- fiable MPC protocol realizing f (possibly a reactive func- tion) with security-with-abort Let π(cid:48) be described by next message functions {nmf(cid:48) j}j∈[rn] and transcript validation functions {tv(cid:48) := (xi, ωi, ({vkj}j∈[n], ski)) where xi, ωi respectively are pri- vate inputs, randomness of Pi For i > n, let X(cid:48) and Xi ≡ Xi mod n|,Non-data,52
| Let π, described by next message functions {nmf j}j∈[rn] and transcript validation functions {tvj}j∈[rn], be obtained from π(cid:48) in the following way: 1 nmf j(TTj−1, Xj) parses TTj−1 = (μ1(cid:107)σ1)(cid:107)···(cid:107)(μj−1(cid:107) j), and := (xi, ωi) and Xi i ≡ X(cid:48) j(μ1(cid:107)···(cid:107)μj−1, X(cid:48) σj−1) and computes μj ← nmf(cid:48) outputs TTj−1(cid:107)μj(cid:107)Sign(μj, skj) j}j∈[rn] Let X(cid:48) i i mod n 2|,Non-data,52
| tvj(TTj,{vki}i) parses TTj = (μ1(cid:107)σ1)(cid:107)···(cid:107)(μj(cid:107)σj), j(μ1(cid:107)···(cid:107)μj) ∧(cid:86) outputs tv(cid:48) j(cid:48) Verify(vkj(cid:48) mod n, σj(cid:48) ) Predicates φi(α) ≡ tvi(α;{vkj}j) Procedure Extend(i, α; Xi) ≡ nmf i(α, Xi)|,Non-data,52
| Procedure Recon output the output of π(cid:48), else output ⊥ If Txn,j was claimed for some j, then Figure 10: Parameterizing the planted ladder mechanism to get MPC with penalties for a reactive function f in the protocol (including how they react to deposits that were not made)|,Non-data,52
| When the claim phase starts and it’s the turn of an honest party to send out a message in π, S invokes Sπ to generate this message It also receives corrupt parties’ messages in π (via A) and feeds them to Sπ S essentially uses Sπ to extract inputs of the corrupt parties However, it does not directly send these inputs to the ideal functionality F∗ f since it also needs to extract and submit coins(hq) to the ideal functionality|,Non-data,52
| Also, S will use Sπ to generate messages according to the protocol to claim deposits as done by the honest parties in the real execution (Note: this is where we use the exten- sibility property indirectly via Sπ) Note that Sπ does not need the actual output of the execution until the last honest party message (ie, it can simulate honest messages until then)|,Non-data,52
| Additionally, during the claim phase, S will need to produce coins whenever A claims them Suppose Pi mod n is corrupt and it produces a valid witness (α, α(cid:48) (For the time n) to claim Txi being, assume i (cid:54)= (r + 1)n; we’ll take care of this case later) To simulate this, S needs to produce coins(i · q)|,Non-data,52
| Ideally, we would ask S to get these coins via Txi−1, ie, coins((i − 1)q) and coins(q) from Pi mod n’s roof deposit Txn,i mod n (out of a total of coins((r + 1)q)) However, it is not clear that Txi−1 was even made by Pi mod n|,Non-data,52
| Importantly, we are able to make the fol- lowing claim: if Txi−1 was not made by Pi mod n but Pi mod n can produce valid witnesses to claim Txi, then for every j < i, party Pj mod n is corrupt Note that the above claim implies that i < n, since we assume that there is at least one honest party To prove the claim, we appeal to the unforgeability property of the transcript validation function of π in the following way Note that according to the protocol description, if Txi−1 was not made, then for j < i an honest party Pj mod n would not make Txj−1|,Non-data,52
| Since it never made a deposit Txj−1, this in turn means that it would never reveal a valid witness for Txj (Note: honest Pj mod n claims Txj iff Txj−1 is claimed) Then it follows from the un- forgeability property that without a valid witness for Txj it is com- putationally infeasible to provide a valid witness to Txi Now we are ready to describe the simulation of the claims Tx1,  |,Non-data,52
|  , Txi (whichever were made) For transactions Txj with j < i that were claimed, we simply use corrupt Pj+1’s deposit of coins(jq) to give to corrupt Pj who’s claiming it For transaction Txi, we use coins(q) from the roof deposit of each of P1, |,Non-data,52
|   , Pi Recall Pi+1 is honest, and if Pi+1 made deposit Txi it must necessarily hold that all parties (in particular, P1, |,Non-data,52
|   , Pi) made roof deposits of coins((r + 1)q) each The above strategy takes care of parties that try to claim a deposit Txi without making the deposit Txi−1|,Non-data,52
| In the rest of the proof, we assume that every Pi that tries to claim deposit Txi has made the deposit Txi−1 This case is handled eas- ily: we ask S to get these coins via Txi−1, ie, coins((i− 1)q) and coins(q) from Pi mod n’s roof deposit Txn,i mod n (out of a total of coins((r + 1)q))|,Non-data,52
 The above strategy works only for i mod n (cid:54)= n We first complete the discussion assuming Pn is honest and then discuss the other case later Suppose Pn is honest We have al- ready addressed how to handle coins during the claims,Non-data,52
| The only remaining thing to address is when to ask S to contact F∗ f  Let ic be the largest index such that Pic mod n is corrupt S will contact the ideal functionality when Txic is claimed by Pic In fact, when Txic−1 is deposited by Pic, S will take coins(hq) out of these coins((ic−1)q) (note: ic > n > h) to deposit to the ideal function- ality along with the inputs to the computation (extracted via Sπ)|,Non-data,52
| S would then get the actual output from the ideal functionality, feed this to Sπ and get the remaining honest messages such that the view of the adversary is indistinguishable from the real execution Also, S would ask F∗ f to deliver the output to all honest parties (because the corrupt parties did not abort the computation at all) and would get coins(hq) back from the ideal functionality which it can then use to handle Pic’s claim of Txic This completes the simulation when Pn is honest When Pn is corrupt, we need to show how to handle claims made by Pn and also how to handle the interaction with the ideal func- tionality|,Non-data,52
| The claims made by Pn are handled easily: if Txi for i mod n = n is claimed by Pn, then we supply coins(iq) to Pn by taking it out of coins((i − 1)q) deposited by Pn in Txi−1 and coins(q) taken out of coins(((r + 1)n − 1)q) deposited by Pn in Tx(r+1)n−1 Note that while handling ladder claims, a total of coins(rq) have been removed from coins(((r + 1)n − 1)q) de- posited by Pn in Tx(r+1)n−1 This leaves coins(((r+1)n−1)q)− coins(rq) = coins(rnq + nq − q − rq) = coins((r + 1)(n − 1)q) Actually, when Tx(r+1)n−1 is deposited by Pn, S will take coins(hq) out of these remaining unused coins((r + 1)(n − 1)q) (note: (r + 1)(n− 1) > h since r > 0) to deposit to the ideal func- tionality along with the inputs to the computation (extracted via Sπ)|,Non-data,52
| S would then get the actual output from the ideal function- ality, feed this to Sπ and get the remaining honest messages such that the view of the adversary is indistinguishable from the real ex- ecution Also, S would ask F∗ f to deliver the output to all honest parties (because the corrupt parties did not abort the computation at all) and would get coins(hq) back from the ideal functionality which it can then use to handle Pn’s claim of Txn,j for all j since it now has exactly coins((r + 1)(n − 1)q)! The one additional point to note is the equivocation of honest party’s messages so that the view of the adversary is indistinguish- 415able from the real execution Let ih be the largest index such that Pih mod n is honest S will actually do the above steps of giving coins(hq) to F∗ f right before time τih so that it can obtain the out- put and feed this to Sπ to produce the correct view|,Non-data,52
| This completes the simulation when Pn is honest 6 DUAL MODE PROTOCOL We now show an application of our planted ladder mechanism This application is motivated by the fact that if s < n/2 parties are corrupt, then standard secure computation protocols [8, 15] ob- tain guaranteed output delivery (and, in particular, fairness) and one does not have to resort to the notion of secure computation with penalties|,Non-data,52
| Additionally, note that a single corrupt party Pn in the ladder mechanism can deny the output to all honest parties Ide- ally, one would want a “dual mode” protocol (alternatively, “best- of-both-worlds” protocol) where 1 if s < n/2 parties are corrupt, then the protocol guarantees fairness; and 2 if t > n/2 parties are corrupt, then the protocol guarantees fairness under the penalties notion|,Non-data,52
| Ishai et al [18] considered a weaker version of the above where they relaxed the second requirement to obtain a protocol that guar- antees “security-with-abort” which is the standard security no- tion for secure computation in the presence of a dishonest major- ity [14] They showed (1) a negative result that precludes such “best-of-both-worlds” protocol when the parameters s, t are such that s + t ≥ n, and (2) a positive result with an explicit construc- tion of such a protocol when s + t < n (in fact, their protocol achieves guaranteed output delivery when at most s parties are cor- rupt) Clearly, “security-with-abort” is weaker than “security-with- penalties” since the latter implies the former|,Non-data,52
| Thus, we cannot hope for positive results in the regime where s + t ≥ n In this section, we show that the regime where s + t < n indeed supports a “best- of-both-worlds” protocol as described above Our protocol Our first observation is that restarts are required in [18] in order to guarantee output delivery, and can be avoided in our case since we only require fairness|,Non-data,52
| Then to make the script complexity independent of the complexity of evaluating f, a natural idea is to follow the template of [9] and to use an off-chain secure computation protocol and make the on-chain complexity depend only on the size of the output of f Our off-chain MPC protocol actually computes the output and performs a (t + 1)-out-of-n se- cret sharing of the output This ensures that at the end of the MPC protocol, the adversary corrupting t > n/2 parties does not ob- tain any information about the output Parties then proceed to run the planted ladder mechanism using essentially the parameters of the original ladder mechanism of [9]|,Non-data,52
| (That is, they reveal the se- cret shares one-by-one in the ladder claim phase after revealing the dummy witnesses in the underground claim phase) We note that it is important to use the planted ladder mechanism as the ladder mechanism does not guarantee compensation to hon- est parties that did not reveal their secret share (say, in the event that the protocol was aborted in the middle) This is especially im- portant as the adversary requires only one additional secret share in order to compute the output On the other hand, the planted ladder mechanism guarantees that either the protocol is completed or all honest parties obtain a compensation|,Non-data,52
| That is, either all parties get the output or all honest parties get compensated This takes care of the case when t ≥ n/2 are corrupt as in this case we get fairness with penalties Protocol Init Parties P1, |,Non-data,52
|   , Pn with their MPC inputs x1,  |,Non-data,52
|  , xn run an MPC protocol that • computes z ← f (x1,   |,Non-data,52
| , xn); • (t + 1)-out-of-n secret shares z into z1,    , zn; • samples ω1, |,Non-data,52
|   , ωn at random from {0, 1}λ; • for j ∈ [n]: computes hj = Hash(zj(cid:107)ωj); • for i ∈ [n]: outputs yi = zi(cid:107)ωi and {hj}j∈[n] to party Pi Predicates For i ∈ [n], predicate φi has {hj}j≤i hard-coded: φi (β1(cid:107)···(cid:107)βi;{hj}j≤i) = (Hash(β1) ?= h1) (cid:94)···(cid:94) (Hash(βi) ?= hi) Procedure Extend(i, α; yi) ≡ α(cid:107)yi|,Non-data,52
| Protocol Recon If each party has already obtained at least t + 1 shares via the ladder mechanism, then they all recon- struct the final output and terminate the protocol On the other hand, suppose less than t + 1 shares were disclosed during the execution of the ladder mechanism, then each honest party Pi broadcasts yi If at least t + 1 shares were broadcasted, then parties now use these shares to reconstruct the output z, else they output ⊥|,Non-data,52
| Figure 11: Parameterizing the planted ladder mechanism to get the dual mode protocol For the case when s < n − t parties are corrupted, we need to obtain complete fairness Since there are n − s ≥ t + 1 honest parties, we simply ask the honest parties to broadcast their shares at the end of the protocol Recall that t + 1 shares are sufficient to reconstruct the secret|,Non-data,52
| Note that an honest party would broadcast its share only after obtaining a compensation Therefore, when t > n/2 parties are corrupt, we obtain fairness with penalties, and when less than n − t parties are corrupt we obtain complete fairness The script complexity of the above protocol would be O(n2||z||) since we use the mechanism of [9] Alternatively we could use the compact ladder mechanism assuming a programmable random oracle to get a protocol whose script complexity is O(nλ)|,Non-data,52
| The formal protocol is described in Figure 11 (Note that Hash can be safely replaced by honest-binding commitments as in [9]) Due to space limitations, the proof of the following theorem is deferred to the full version THEOREM 5|,Non-data,52
| Assume the existence of one-way functions Let s, t be such that s < n/2, t ≥ n/2, and s + t < n Then there exists a protocol in the (FOT,F∗ CR)-hybrid model that simultane- ously (1) SCC-realizes F∗ f when t parties are corrupted, and (2) realizes Ff with complete fairness when s parties are corrupted Additionally, the protocol makes only O(n) calls to F∗ CR and the script complexity of the protocol is O(n2||z||) where ||z|| denotes the size of the output of f|,Non-data,52
| (This can be reduced to O(nλ) assuming a programmable random oracle) 7 CONCLUSIONS The results in this paper are motivated by the distinction be- tween on-chain and off-chain complexity of secure computation with penalties Specifically, we design protocols for secure com- 416putation with penalties which have lower script complexity (i|,Non-data,52
|e, on-chain complexity) relative to prior works [9, 22] Our two main efficiency improvements are: (1) an improvement to the script com- plexity of secure computaion with penalties in the non-reactive set- ting from O(n2||z||) to O(nλ) (in particular, making the complexity independent of the function), and (2) an improvement to the script complexity (and also number of F∗ CR calls) of secure computation with penalties in the reactive setting from O(n2T ) to O(nT ) Both these results provide a quadratic to linear reduction in the depen- dence on the number of parties n and thus are likely to be useful in practice|,Non-data,52
| One major open question in this area is to remove/lessen the dependence of the script complexity in the reactive setting on T , ie, the size of the transcript of the MPC protocol realizing the reactive function Another contribution of this work is providing a general frame- work for the ladder mechanism which in fact makes the protocols easier to describe|,Non-data,52
| Additionally, we use this framework to design a protocol that offers “best-of-both-worlds” security in the sense that it offers (1) complete fairness when up to s (< n/2) parties are cor- rupted, and (2) fairness with penalties when up to t (> n/2) parties are corrupted Our protocol works in the regime where s + t < n which is essentially the only regime where positive results are pos- sible [18] Open questions in this area include a lower bound on the script complexity and the number of F∗ CR transactions required to implement secure computation with penalties tolerating t < n corruptions 8|,Non-data,52
|ABSTRACT Device-to-device communication is important to emerging mobile applications such as Internet of Things and mobile social networks Authentication and key agreement among multiple legitimate devices is the important first step to build a secure communication channel Existing solutions put the devices into physical proximity and use the common radio environment as a proof of identities and the common secret to agree on a same key However they experience very slow secret bit generation rate and high errors, requiring sev- eral minutes to build a 256-bit key|,Non-data,53
| In this work, we design and implement an authentication and key agreement proto- col for mobile devices, called The Dancing Signals (TDS), being extremely fast and error-free TDS uses channel state information (CSI) as the common secret among legitimate devices It guarantees that only devices in a close physical proximity can agree on a key and any device outside a cer- tain distance gets nothing about the key Compared with existing solutions, TDS is very fast and robust, support- s group key agreement, and can effectively defend against predictable channel attacks|,Non-data,53
 We implement TDS using com- modity off-the-shelf 80211n devices and evaluate its perfor- mance via extensive experiments Results show that TDS only takes a couple of seconds to make devices agree on a 256-bit secret key with high entropy Keywords Group authentication; Key agreement; WiFi; CSI 1,Non-data,53
| INTRODUCTION With the rapid technology growth of mobile devices, wire- less device-to-device communication has been playing im- Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page Copyrights for components of this work owned by others than ACM must be honored Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee|,Non-data,53
| Request permissions from permissions@acmorg CCS’16, October 24-28, 2016, Vienna, Austria c(cid:2) 2016 ACM ISBN 978-1-4503-4139-4/16/10|,Non-data,53
   $1500 DOI: http://dx,Non-data,53
doiorg/101145/29767492978298 portant roles for many emerging applications including In- ternet of Things (IoT) and mobile social networks,Non-data,53
| For ex- ample, IoT appliances may communicate with each other to collaboratively sense the physical world and make proper reactions [19] Mobile social applications fuel the need for mobile devices such as smartphones to interact directly in an ad-hoc mode to share various information such as texts, pictures, and videos A fundamental problem of wireless device-to-device com- munication is the vulnerability to various attacks such as identity spoofing, eavesdropping, and man-in-the-middle at- tacks [24] [15] [4] Sensitive information such as health con- ditions and personal data shared among IoT and Mobile so- cial devices has become the targets of these attacks|,Non-data,53
| Hence authentication and key agreement among mobile devices is the critical first step to secure such interactions It requires a number of mobile devices to agree on a symmetric key with- out prior shared secret, through an untrusted and unauthen- ticated wireless channel The key then helps to establish a secure channel for these devices Hence authentication and key agreement are both required in building the secure chan- nel|,Non-data,53
 This process is also called as device pairing or grouping in the literature Traditional public key encryption and Diffie-Hellman key exchange [6] do not work for device-to-device communica- tion in mobile networks due to the open nature of the wire- less medium and lack of centralized trust management [16] [8] Recent efforts have been made to device authentica- tion and key agreement while reducing the amount of user interactions such as manual key assignment and input [24] [15] [23] [19] The main idea of these methods is to put two devices into physical proximity and use the common radio environment as a proof of identities and the common secret to generate a same key on different devices,Non-data,53
| The main limi- tations of these methods is slow speed of key generation and high error rate For example, Radiotelepathy [16] extracts secret keys using the channel impulse response (CIR) in the wireless channel and its key generation rate is only around 1 bit per second ProxiMate can generate less than five bit- s per second in most scenarios [15], costing more than one minute for two devices to agree on a 256-bit key Holding two devices in a physical proximity (5cm in the ProxiMate 616experiments [15]) for minutes before communication is in- convenience in most applications|,Non-data,53
| A recent work can pair two IoT devices co-present in a long period of time [19] This solution is good for wearable devices that are attached to the same object or human being, but impractical for de- vices that may move away from each other Pinpoint [27] can pair two devices and estimate secure channel leverag- ing semi-symmetrical CIR to dispel reversed jamming noise However, this method can hardly expand to more than two devices yet|,Non-data,53
| Moreover, many existing key agreement meth- ods assumes that two devices communicate through an au- thenticated channel [2] [16] [15] [14] [28] Without extra de- vice authentication solutions, these methods are vulnerable to various attacks such as a man-in-the-middle attack In this work, we design and implement an authentication and key agreement protocol for mobile devices with instan- t and robust key agreement Our experiments using com- modity off-the-shelf (COTS) wireless devices show secret bit generation rates faster than existing methods by more than an order of magnitude in various practical scenarios|,Non-data,53
| The key idea behind the speed improvement is a new key distri- bution protocol Different from many existing methods that use received signal strength (RSS) to extract secret bits [15], we use channel state information (CSI) available from Or- thogonal Frequency Division Multiplexing (OFDM) of the current WiFi standard Different from RSS, CSI measure- ment contains much richer information in a same period of time On the other hand, previous methods that use recip- rocal quantization (directly converting each signal sample to a bit) may introduce many mismatched bits for the two keys generated on different devices [2] [16] [15] [14] [28], requiring additional information reconciliation process [3] to fix the errors|,Non-data,53
