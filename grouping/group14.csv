 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| Such modularity makes our code easier to understand and verify, and is also pedagogically helpful to newcomers to the area DSL for sparse decompositions As shown in [43] and further in this work, most cryptographically relevant operations on cyclotomic rings correspond to linear trans- forms having sparse decompositions, ie|,Non-data,41
|, factorizations into relatively sparse matrices, or tensor products thereof Such factorizations directly yield fast and highly parallel algo- rithms; eg, the Cooley-Tukey FFT algorithm arises from a sparse decomposition of the Discrete Fourier Transform|,Non-data,41
| To concisely and systematically implement the wide vari- ety of linear transforms associated with general cyclotomics, Λ◦λ includes an embedded domain-specific language (DSL) for expressing sparse decompositions using natural matrix notation, and a “compiler” that produces corresponding fast and parallel implementations This compiler includes generic combinators that “lift” any class of transform from the prim- itive case of prime cyclotomics, to the prime-power case, and then to arbitrary cyclotomics (See the full version for details) Algorithms for the cyclotomic hierarchy|,Non-data,41
| Recall that Λ◦λ is the first lattice cryptography implementation to ex- pose the rich hierarchy of cyclotomic rings, ie, their subring and extension-ring relationships As the foundation for this functionality, in the full version we derive sparse decomposi- tions for a variety of objects and linear transforms related to the cyclotomic hierarchy|,Non-data,41
| In particular, we obtain simple linear-time algorithms for the embed and “tweaked” trace operations in the three main bases of interest (powerful, de- coding, and CRT), and for computing the relative analogues of these bases for cyclotomic extension rings To our knowl- edge, almost all of this material is new (For comparison, the Ring-LWE “toolkit” [43] deals almost entirely with transforms and algorithms for a single cyclotomic ring, not inter-ring operations) FHE with ring tunneling|,Non-data,41
| In Section 4, we define and implement an FHE scheme which refines a variety of tech- niques and features from a long series of works on Ring-LWE and FHE [42, 12, 13, 11, 28, 43, 3] For example, it allows the plaintext and ciphertext spaces to be defined over different cyclotomic rings, which permits certain optimizations Using Λ◦ λ’s support for the cyclotomic hierarchy, we also devise and implement a more efficient variant of ring- switching for FHE, which we call ring tunneling While a prior technique [3] homomorphically evaluates a linear function by “hopping” from one ring to another through a common extension ring, our new approach “tunnels” through a common subring, which makes it more efficient|,Non-data,41
| Moreover, we show that the linear function can be integrated into the accompanying key-switching step, thus unifying two operations into a simpler and even more efficient one (See Section 42 for details) 1|,Non-data,41
|2 Example: FHE in Λ◦λ For illustration, here we briefly give a flavor of our FHE im- plementation in Λ◦λ; see Figure 1 for representative code, and Section 4 for many more details of the scheme’s mathematical definition and implementation While we do not expect the reader (especially one who is not conversant with Haskell) to understand all the details of the code, it should be clear that even complex operations like modulus-switching and key-switching/relinearization have very concise and natural implementations in terms of Λ◦λ’s interfaces (which include the functions errorCoset, reduce, embed, twace, liftDec, etc) Indeed, the implementations of the FHE functions are often shorter than their type declarations! (For the reader who is new to Haskell, the full version gives a brief tutorial that provides sufficient background to understand the code fragments appearing in this paper|,Non-data,41
|) As a reader’s guide to the code from Figure 1, by convention the type variables z, zp, zq always represent (respectively) the integer ring Z and quotient rings Zp = Z/pZ, Zq = Z/qZ, where p (cid:28) q are respectively the plaintext and ciphertext moduli The types m, m’ respectively represent the indices m, m(cid:48) of the cyclotomic rings R, R(cid:48), where we need m||m(cid:48) so that R can be seen as a subring of R(cid:48) Combining all this, the types Cyc m’ z, Cyc m zp, and Cyc m’ zq respec- tively represent R(cid:48), the plaintext ring Rp = R/pR, and the ciphertext ring R(cid:48) q = R(cid:48)/qR(cid:48) The declaration encrypt :: (m ‘Divides‘ m’, |,Non-data,41
) => ,Non-data,41
| defines the type of the function encrypt (and similarly for decrypt, rescaleCT, etc) Preceding the arrow =>, the text (m ‘Divides‘ m’, |,Non-data,41
|) lists the constraints that the types must satisfy at compile time; here the first constraint en- forces that m||m(cid:48) The text following the arrow => defines the types of the inputs and output|,Non-data,41
| For encrypt, the inputs are a secret key in R(cid:48) and a plaintext in R(cid:48) p, and the output is a random ciphertext over R(cid:48) q Notice that the full ciphertext type also includes the types m and zp, which indicate that the plaintext is from Rp This aids safety: thanks to the type of decrypt, the type system prevents the programmer from incorrectly attempting to decrypt the ciphertext into a ring other than Rp Finally, each function declaration is followed by an imple- mentation, which describes how the output is computed from the input(s)|,Non-data,41
| Because the implementations rely on the math- ematical definition of the scheme, we defer further discussion to Section 4 13 Limitations and Future Work Security While Λ◦λ has many attractive functionality and safety features, we stress that it is still an early-stage research prototype, and is not yet recommended for produc- tion purposes—especially in scenarios requiring high security assurances|,Non-data,41
| Potential issues include, but may not be limited to: 995encrypt :: (m ‘Divides‘ m’, MonadRandom rnd, ) -- secret key ∈ R(cid:48) -- plaintext ∈ Rp -- ciphertext over R(cid:48) => SK (Cyc m’ z) -> PT (Cyc m zp) -> rnd (CT m zp (Cyc m’ zq)) q encrypt (SK s) mu = do -- in randomness monad -- error ← μ + pR(cid:48) e <- errorCoset (embed mu) -- uniform from R(cid:48) c1 <- getRandom q return $ CT LSD 0 1 [reduce e - c1 * reduce s, c1] decrypt :: (Lift zq z, Reduce z zp, |,Non-data,41
|) => SK (Cyc m’ z) -> CT m zp (Cyc m’ zq) -> PT (Cyc m zp) -- secret key ∈ R(cid:48) -- ciphertext over R(cid:48) -- plaintext in Rp q decrypt (SK s) (CT LSD k l c) = let e = liftDec $ evaluate c (reduce s) in l *> twace (iterate divG (reduce e) !! k) -- homomorphic multiplication (CT LSD k1 l1 c1) * (CT _ k2 l2 c2) = CT d2 (k1+k2+1) (l1*l2) (mulG <$> c1 * c2) -- ciphertext modulus switching rescaleCT :: (Rescale zq zq’, |,Non-data,41
|) => CT m zp (Cyc m’ zq ) -> CT m zp (Cyc m’ zq’) -- ciphertext over R(cid:48) -- to R(cid:48) q(cid:48) q rescaleCT (CT MSD k l [c0,c1]) = CT MSD k l [rescaleDec c0, rescalePow c1] -- key switching/linearization keySwitchQuad :: (MonadRandom rnd, |,Non-data,41
|) => SK r’ -> SK r’ -> rnd (CT m zp r’q -> CT m zp r’q) -- recrypt function -- target, source keys keySwitchQuad sout sin = do -- in randomness monad hint <- ksHint sout sin return $ \(CT MSD k l [c0,c1,c2]) -> CT MSD k l $ [c0,c1] + switch hint c2 switch hint c = sum $ zipWith (*>) (reduce <$> decompose c) hint Figure 1: Representative (and approximate) code from our implementation of an FHE scheme in Λ◦λ • Most functions in Λ◦ λ are not constant time, and may therefore leak secret information via timing or other side channels (Systematically protecting lattice cryptography from side-channel attacks is an important area of research) • While Λ◦λ implements a fast algorithm for sampling from theory-recommended error distributions, the cur- rent implementation is somewhat na ̈ıve in terms of precision|,Non-data,41
| By default, some Λ◦λ functions use double- precision floating-point arithmetic to approximate a sample from a continuous Gaussian, before rounding (But one can specify an alternative data type having more precision) We have not yet analyzed the associ- ated security implications, if any We do note, however, that Ring-LWE is robust to small variations in the error distribution (see, e|,Non-data,41
|g, [42, Section 5]) Discrete Gaussian sampling Many lattice-based cryp- tosytems, such as digital signatures and identity-based or attribute-based encryption schemes following [30], require sampling from a discrete Gaussian probability distribution over a given lattice coset, using an appropriate kind of “trap- door|,Non-data,41
|” Supporting this operation in Λ◦ λ is left to future work, for the following reasons While it is straightforward to give a clean interface for discrete Gaussian sampling (similar to the Decompose class), providing a secure and practical implementation is very subtle, especially for arbitrary cyclo- tomic rings: one needs to account for the non-orthogonality of the standard bases, use practically efficient algorithms, and ensure high statistical fidelity to the desired distribu- tion using finite precision Although there has been good progress in addressing these issues at the theoretical level (see, eg|,Non-data,41
|, [21, 43, 23, 22]), a complete practical solution still requires further research Applications As our focus here is mainly on the Λ◦λ framework itself, we leave the implementation of additional lattice-based cryptosystems to future work While digital signatures and identity/attribute-based encryption use dis- crete Gaussian sampling, many other primitives should be straightforward to implement using Λ◦λ’s existing function- ality|,Non-data,41
| These include standard Ring-LWE-based [42, 43] and NTRU-style encryption [36, 55], public-key encryption with security under chosen-ciphertext attacks [48], and pseudo- random functions (PRFs) [5, 8, 4] It should also be possible to implement the homomorphic evaluation of a lattice-based PRF under our FHE scheme, in the same spirit as homomor- phic evaluations of the AES block cipher [29, 17]; we have promising preliminary work in this direction Language layer Rich lattice-based cryptosystems, es- pecially homomorphic encryption, involve a large number of tunable parameters and different routes to the user’s end goal|,Non-data,41
| In current implementations, merely expressing a homo- morphic computation requires expertise in the intricacies of the homomorphic encryption scheme and its particular im- plementation For future work, we envision domain-specific languages (DSLs) that allow the programmer to express a plaintext computation at a level above the “native instruction set” of the homomorphic encryption scheme A specialized compiler would then translate the user’s description into a homomorphic computation (on ciphertexts) using the cryp- tosystem’s instruction set, and possibly even instantiate secure parameters for it Because Haskell is an excellent host language for embedded DSLs, we believe that Λ◦λ will serve as a strong foundation for such tools|,Non-data,41
| 14 Comparison to Related Work As mentioned above, there are many implementations of various lattice- and ring-based cryptographic schemes, such as NTRU (Prime) encryption [36, 6], the SWIFFT hash function [41], digital signature schemes like [33] and BLISS [20], key-exchange protocols [10, 2, 9], and FHE li- braries like HElib [34] In addition, there are some high- performance backends for power-of-two cyclotomics, like NFLlib [46] and [56], which can potentially be plugged into these other systems Also, in a Masters thesis developed concurrently with this work, Mayer [44] implemented the “toolkit” algorithms from [43] for arbitrary cyclotomic rings (though not the inter-ring operations that Λ◦λ supports)|,Non-data,41
| On the whole, the prior works each implement just one cryptographic primitive (sometimes even on a specific com- putational platform), and typically opt for performance over generality and modularity In particular, none of them pro- vide any abstract data types for cyclotomic rings, but instead require the programmer to explicitly manage the represen- tations of ring elements (eg, as polynomials) and ensure that operations on them are mathematically meaningful|,Non-data,41
| 996Moreover, with the exception of [44], they do not support general cyclotomic rings using the current best theory for cryptographic purposes HElib Our work compares most closely to HElib [34], which is an “assembly language” for BGV-style FHE over cyclotomic rings [11] It holds speed records for a variety of FHE benchmarks (e|,Non-data,41
|g, homomorphic AES computation [29]), and appears to be the sole public implementation of many advanced FHE features, like bootstrapping for “packed” ci- phertexts [35] On the downside, HElib does not use the best known algo- rithms for cryptographic operations in general (non-power- of-two) cyclotomics Most significantly, it uses the univariate representation modulo cyclotomic polynomials, rather than the multivariate/tensored representations from [43], which results in more complex and less efficient algorithms, and suboptimal noise growth in cryptographic schemes|,Non-data,41
| The prac- tical effects of this can be seen in our performance evaluation (Section 52), which shows that Λ◦λ’s C++ backend is about nine times slower than HElib for power-of-two cyclotomics, but is significantly faster (by factors of two or more) for indices involving two or more small primes Finally, HELib is targeted toward just one class of cryptographic construction (FHE), so it lacks functionality necessary to implement a broader selection of lattice schemes (eg|,Non-data,41
|, CCA-secure en- cryption) Computational algebra systems Algebra packages like Sage and Magma provide very general-purpose support for computational number theory While these systems do offer higher-level abstractions and operations for cyclotomic rings, they are not a suitable platform for attaining our goals|,Non-data,41
| First, their existing implementations of cyclotomic rings do not use the “tensored” representations (ie, powerful and decoding bases, and CRT bases over Zq) and associated fast algorithms that are preferred for cryptographic purposes Nor do they include support for special lattice operations like bit decomposition and other “gadget” operations, so to use such systems we would have to reimplement essentially all the mathematical algorithms from scratch|,Non-data,41
| Perhaps more significantly, the programming languages of these systems are relatively weakly and dynamically (not statically) typed, so all type-checking is deferred to runtime, where errors can be much harder to debug 15 Architecture and Paper Organization The components of Λ◦λ are arranged in a few main layers, and the remainder of the paper is organized correspondingly From the bottom up, the layers are: Integer layer (Section 2): This layer contains abstract interfaces and implementations for domains like the inte- gers Z and its quotient rings Zq = Z/qZ, including special- ized operations like rescaling and “(bit) decomposition|,Non-data,41
|” It also contains tools for working with moduli and cyclotomic indices at the type level, which enables static enforcement of mathematical constraints Tensor layer (full version): This layer’s main abstract interface, called Tensor, defines all the linear transformations and special values needed for working efficiently in cyclotomic rings (building on the framework developed in [43]), and per- mits multiple implementations Because the tensor layer is completely hidden from typical cryptographic applications, we defer to the full versionthe details of its design and our implementations This material includes the definitions and analysis of several linear transforms and algorithms that, to our knowledge, have not previously appeared in the literature|,Non-data,41
| Additionally, the full version describes the “sparse decom- position” DSL and compiler that underlie our pure-Haskell Tensor implementation Cyclotomic layer (Section 3): This layer defines data types and high-level interfaces for cyclotomic rings and their cryptographically relevant operations Our implementations are relatively thin wrappers which modularly combine the integer and tensor layers, and automatically manage the internal representations of ring elements for more efficient operations Cryptography layer (Section 4): This layer consists of implementations of cryptographic schemes|,Non-data,41
| As a detailed example, we define an advanced FHE scheme that incorpo- rates and refines a wide collection of features from a long series of works [42, 12, 13, 11, 29, 28, 43, 3] We also show how its implementation in Λ◦λ very closely and concisely matches its mathematical definition Finally, in Section 5 we evaluate Λ◦ λ in terms of code quality and runtime performance, and give a comparison to HElib [34] Due to space constraints, many technical details are omitted from this extended abstract|,Non-data,41
| The full, most recent version of this work is [19] 2 INTEGER & MODULAR ARITHMETIC Lattice-based cryptography is built around arithmetic in the ring of integers Z and quotient rings Zq = Z/qZ of integers modulo q, ie|,Non-data,41
|, the cosets x + qZ with the usual addition and multiplication operations In addition, a variety of specialized operations are also widely used, eg, lifting a coset in Zq to its smallest representative in Z, rescaling (or rounding) one quotient ring Zq to another, and decomposing a Zq-element as a vector of small Z-elements with respect to a “gadget” vector|,Non-data,41
| In this section we summarize how we represent and imple- ment these domains and operations in Λ◦λ This provides a foundation for the next section, where we show in par- ticular how all these operations are generically “promoted” from Z and Zq to cyclotomic rings, to support ring-based cryptosystems 21 Representing Z and Zq We exclusively use fixed-precision primitive types like Int and Int64 to represent the integers Z, and define our own specialized type ZqBasic q z to represent Zq|,Non-data,41
| Here q is a “phantom” type that represents the value of the modu- lus q, while z is an integer type (like Int64) specifying the underlying representation of the integer residues modulo q This approach has many advantages: by making ZqBasic q z an instance of Ring, we can use the (+) and (*) operators without any explicit modular reductions More importantly, at compile time the type system disallows operations on incompatible types—eg|,Non-data,41
|, attempting to add a ZqBasic q1 z to a ZqBasic q2 z for distinct q1, q2—with no runtime over- head Finally, we implement ZqBasic q z as a newtype for z, which means that that have identical runtime representations, with no memory overhead 997reduce lift rescale gadget encode decompose :: Decompose zq z :: Reduce :: Lift :: Rescale :: Gadget :: Gadget z zq => z -> zq zq z zq zq’ => zq -> zq’ => zq [zq] zq => zq -> [zq] => zq -> [z] => zq -> z Figure 2: Methods defined by the classes (interfaces) Reduce, Lift, etc, with slightly simplified types|,Non-data,41
| CRT/RNS representation Applications like homo- morphic encryption can require moduli q that are too large for standard fixed-precision integer types Using Haskell’s unbounded Integer is rather slow, and the values have vary- ing sizes, which means they cannot be stored efficiently in “unboxed” form in arrays A standard solution is to use a Chinese Remainder Theorem (CRT), or Residue Number System (RNS), representation: choose q to be the product of several pairwise coprime and sufficiently small q1, |,Non-data,41
|   , qt, and use the natural ring isomorphism from Zq to the product ring Zq1 × ··· × Zqt , where addition and multiplication are both component-wise In Haskell, using the CRT/RNS representation is very natural via the generic pair type (,): whenever types a and b respectively represent rings A and B, the pair type (a,b) represents the product ring A × B|,Non-data,41
| This just requires defin- ing the obvious instances of Additive and Ring for (a,b) Products of more than two rings are immediately supported by nesting pairs, like ((a,b),c), or by using higher-arity tuples like (a,b,c) A final nice feature is that a pair (or tuple) has fixed representation size if all its components do, so arrays of pairs can be stored directly in “unboxed” form 2|,Non-data,41
|2 Specialized Operations For the specialized operations used across lattice cryptogra- phy, Λ◦λ defines the interfaces (called classes) Reduce, Lift, Rescale, Gadget, Decompose, and Correct, along with ap- propriate implementations (called instances) The methods defined by these classes are shown in Figure 2 For the present discussion, one can read the type argu- ments z and zq in Figure 2 as respectively representing Z and Zq for some modulus q The reduce method represents modular reduction from Z to Zq, while the lift method represents lifting from Zq to the set of distinguished repre- sentatives Z ∩ [− q 2 )|,Non-data,41
| The rescale method represents the modular “rounding” function (cid:98)·(cid:101)q(cid:48) : Zq → Zq(cid:48) , defined as (cid:48)Z ∈ Zq(cid:48) , (cid:106) q(cid:48) (cid:109) q · (x + qZ) (cid:106) q(cid:48) (cid:109) q · x (cid:98)x + qZ(cid:101)q(cid:48) := 2 , q = + q where (cid:98)·(cid:101) denotes rounding to the nearest integer The gadget, encode, and decompose methods respectively represent some “gadget” vector over Zq (eg, the powers-of- two vector g = (1, 2, 4, 8, |,Non-data,41
|   , 2(cid:96)−1)) and efficient algorithms for the following standard tasks: 1 Decomposition: given u ∈ Zq, output a short vector x over Z such that (cid:104)g, x(cid:105) = gt · x = u (mod q)|,Non-data,41
| 2 Error correction: given a “noisy encoding” of the gadget bt = s·gt+et mod q, where s ∈ Zq and e is a sufficiently short error vector over Z, output s and e 23 Type-Level Cyclotomic Indices As discussed in Section 3 below, there is one cyclotomic ring for every positive integer m, which we call the index|,Non-data,41
| Its factorization plays a major role in the definitions of the ring operations For example, the index-m “Chinese remain- der transform” is similar to a mixed-radix FFT, where the radices are the prime divisors of m In addition, cyclotomic rings can sometimes be related to each other based on their indices For example, the mth cyclotomic can be seen as a subring of the m(cid:48)th cyclotomic if and only if m||m(cid:48); the largest common subring of the m1th and m2th cyclotomics is the gcd(m1, m2)th cyclotomic, etc|,Non-data,41
| In Λ◦λ, a cyclotomic index m is specified by an appropriate type m, and the data types representing cyclotomic rings (and their underlying coefficient tensors) are parameterized by such an m Based on this parameter, Λ◦λ generically derives algorithms for all the relevant operations in the corresponding cyclotomic In addition, for operations that involve more than one cyclotomic, Λ◦λ expresses and statically enforces (at compile time) the laws governing when these operations are well defined We achieve the above properties using Haskell’s type sys- tem, with the help of the powerful data kinds extension [57] and the singletons library [25, 24]|,Non-data,41
| These tools enable the “promotion” of ordinary values and functions from the data level to the type level More specifically, they promote every value to a corresponding type, and promote every function to a corresponding type family, ie, a function on the promoted types|,Non-data,41
| We stress that all type-level computations are per- formed at compile time, yielding the dual benefits of static safety guarantees and no runtime overhead 3 CYCLOTOMIC RINGS In this section we summarize Λ◦λ’s interfaces and imple- mentations for cyclotomic rings In Section 3|,Non-data,41
|1 we review the relevant mathematical background In Section 32 we describe the interfaces of the two data types, Cyc and UCyc, that represent cyclotomic rings Then in Section 3|,Non-data,41
|3 we describe some key aspects of the implementations 31 Mathematical Background To appreciate the material in this section, one only needs the following high-level background; see the full version and [42, 43] for many more mathematical and computational details 3|,Non-data,41
|11 Cyclotomic Rings For a positive integer m, the mth cyclotomic ring is R = Z[ζm], the ring extension of the integers Z obtained by adjoin- ing an element ζm having multiplicative order m The ring R is contained in the mth cyclotomic number field K = Q(ζm), which both have degree deg(K/Q) = deg(R/Z) = n We endow K, and thereby R, with a geometry via a function σ : K → Cn called the canonical embedding|,Non-data,41
| Eg, we define the (cid:96)2 norm on K as (cid:107)x(cid:107)2 = (cid:107)σ(x)(cid:107)2, and define Gaussian- like distributions over R and K The complex coordinates of σ come in conjugate pairs, and addition and multiplication are coordinate-wise under σ|,Non-data,41
| For cryptographic purposes, there are two particularly important Z-bases of R: the powerful basis pm ∈ Rn and the decoding basis dm ∈ Rn That is, every r ∈ R can be uniquely represented as r = (cid:104)pm, r(cid:105) for some integral vector r ∈ Zn, and similarly for dm In particular, there are Z- linear transformations that switch from one representation to the other For geometric reasons, certain cryptographic operations are best defined in terms of a particular one of 998m(cid:48) these bases, e|,Non-data,41
|g, decryption uses the decoding basis, whereas decomposition uses the powerful basis There are special ring elements gm, tm ∈ R whose product is gm · tm = ˆm, which is defined as ˆm := m/2 when m is even, and ˆm := m otherwise The elements gm, tm are used in the generation and management of error terms in cryptographic applications, as described below|,Non-data,41
| The mth cyclotomic ring R = Z[ζm] can be seen as a subring of the m(cid:48)th cyclotomic ring R(cid:48) = Z[ζm(cid:48) ] if and only if m||m(cid:48), and in such a case we can embed R into R(cid:48) by identifying ζm with ζm(cid:48)/m  In the reverse direction, we can twace from R(cid:48) to R, which is a certain R-linear function that fixes R pointwise (The name is short for “tweaked trace,” because the function is a variant of the true trace function to our “tweaked” setting, described next) 3|,Non-data,41
|12 (Tweaked) Ring-LWE and Error Distributions Ring-LWE is a family of computational problems that was defined and analyzed in [42, 43] Those works deal with a form of Ring-LWE that involves a special (fractional) ideal R∨, which is “dual” to R, and an error distribution ψ that corresponds to a spherical Gaussian Dr of some param- eter r (eg|,Non-data,41
|, r = 2 or r ≈ n1/4) in the canonical embedding Such spherical distributions play an important role in the worst-case hardness proofs for Ring-LWE, and also behave very well in cryptographic applications In cryptosystems, it can be convenient to use a form of Ring-LWE that does not involve R∨ As first suggested in [3], this can be done by working with an equivalent “tweaked” form of the problem, which is obtained by multiplying Ring- LWE samples by a “tweak” factor t = tm = ˆm/gm ∈ R, which satisfies t · R∨ = R|,Non-data,41
| This yields “noisy products” (ai ∈ Rq , bi = ai · s + ei mod qR), i = t·ei where both ai and s reside in Rq, and the error terms e(cid:48) come from the “tweaked” distribution t · ψ Note that the tweaked form t · ψ of a spherical Gaussian may be highly non-spherical (in the canonical embedding), but this is not a problem: the tweaked form of Ring-LWE is equivalent to the original one involving R∨, because the tweak is reversible 31|,Non-data,41
|3 Error Invariant In cryptographic applications, error terms are combined in various ways, and thereby grow in size To obtain the best concrete parameters and security levels, the accumulated error should be kept “small” More precisely, its coefficients with respect to some choice of Z-basis should have magnitudes that are as small as possible As shown in [43, Section 6], errors e whose coordinates σi(e) in the canonical embedding are small and (nearly) indepen- dent have correspondingly small coefficients with respect to the decoding basis of R∨|,Non-data,41
| In the tweaked setting, where both errors and the decoding basis carry an extra tm = ˆm/gm factor, an equivalent hypothesis is the following: Invariant 1 For an error e(cid:48) ∈ R, every coordinate (cid:48) σi(e /tm) = ˆm −1 · σi(e (cid:48) · gm) ∈ C should be nearly independent (up to conjugate symmetry) and have relatively “light” tails This invariant is satisfied for fresh errors drawn from tweaked Gaussians, as well as for small linear combinations of such terms In general, the invariant is not preserved under multiplication, because the product of two tweaked error terms e(cid:48) m factor|,Non-data,41
| Fortunately, this is easily fixed by introducing an extra gm factor: i = tm · ei carries a t2 gm · e 1 · e (cid:48) 2 = tm · ( ˆm · e1 · e2) (cid:48) satisfies the invariant, because multiplication is coordinate- wise under σ We use this technique in our FHE scheme of Section 4 32 Cyclotomic Types: Cyc and UCyc In this subsection we summarize the interfaces of the two data types, Cyc and UCyc, that represent cyclotomic rings|,Non-data,41
| Cyc t m r represents the mth cyclotomic ring over a base ring r—typically, one of Q, Z, or Zq—backed by an underly- ing Tensor type t The interface for Cyc completely hides the internal representations of ring elements (eg, the choice of basis) from the client, and automatically manages the choice of representation so that the various ring operations are usu- ally as efficient as possible|,Non-data,41
| Therefore, most cryptographic applications can and should use Cyc UCyc t m rep r represents the same cyclotomic ring as Cyc t m r, but as a coefficient vector relative to the basis indicated by rep This argument is one of the four valueless types P, D, C, E, which respectively denote the powerful basis, decoding basis, CRT r-basis (if it exists), and CRT basis over an appropriate extension ring of r Exposing the representation at the type level in this way allows—indeed, requires—the client to manage the choice of representation|,Non-data,41
| (Cyc is one such client) This can lead to more efficient computations in certain cases where Cyc’s management may be suboptimal More importantly, it safely enables a wide class of operations on the underlying coefficient vector, via category-theoretic classes like Functor; see Sections 32|,Non-data,41
1 and 333 for further details Clients can easily switch between Cyc and UCyc as needed,Non-data,41
| Indeed, Cyc is just a relatively thin wrapper around UCyc, which mainly just manages the choice of representation, and provides some other optimizations related to subrings (see Section 33 for details) Instances 32|,Non-data,41
|1 Cyc and UCyc are instances of many classes, which comprise a large portion of their interfaces Algebraic classes As one might expect, Cyc t m r and UCyc t m rep r are instances of Eq, Additive, Ring, and various other algebraic classes for any appropriate choices of t, m, rep, and r Therefore, the standard operators (==), (+), (*), etc|,Non-data,41
| are well-defined for Cyc and UCyc values, with semantics matching the mathematical definitions Category-theoretic classes Because UCyc t m rep r for rep = P, D, C (but not rep = E) is represented as a vector of r-coefficients with respect to the basis indicated by rep, we define the partially applied types UCyc t m rep (note the missing base type r) to be instances of the classes Functor, Applicative, Foldable, and Traversable For example, the Functor instance for f = UCyc t m rep defines fmap :: (r -> r’) -> f r -> f r’ to apply the r -> r’ function independently on each of the r-coefficients|,Non-data,41
| By contrast, Cyc t m is not an instance of any category- theoretic classes This is because by design, Cyc hides the 999choice of representation from the client, so it is unclear how (say) fmap could be properly defined Lattice cryptography classes Lastly, we “promote” in- stances of our specialized lattice cryptography classes like Reduce, Lift, Rescale, Gadget, etc|,Non-data,41
| from base types to UCyc and/or Cyc, as appropriate For example, the instance Reduce z zq, which represents modular reduction from Z to Zq, induces the instance Reduce (Cyc t m z) (Cyc t m zq), which represents reduction from R to Rq All these instances have very concise and generic implementations using the just-described category-theoretic instances for UCyc; see Sec- tion 33|,Non-data,41
3 for further details 322 Functions scalarCyc mulG divG liftPow/Dec :: Lift b a => Cyc t m b -> Cyc t m a r -> Cyc t m r Cyc t m r -> Cyc t m r Cyc t m r -> Maybe (Cyc t m r) :: :: :: -- error sampling tGaussian :: MonadRandom rnd => errorRounded :: MonadRandom rnd => errorCoset v -> rnd (Cyc t m q) v -> rnd (Cyc t m z) :: ,Non-data,41
| => v -> Cyc t m zp -> rnd (Cyc t m z) -- inter-ring operations embed twace coeffsPow, coeffsDec :: Cyc t m’ r -> [Cyc t m r] powBasis Tagged m [Cyc t m’ r] Tagged m [Cyc t m’ r] crtSet :: Cyc t m r -> Cyc t m’ r :: Cyc t m’ r -> Cyc t m r :: :: Figure 3: Representative functions for the Cyc data type For brevity, we omit most constraints, includ- ing Tensor t, Ring r, Fact m, and m ‘Divides‘ m’|,Non-data,41
| We briefly mention a few of the remaining functions that define the interface for Cyc; see Figure 3 for their type sig- natures (UCyc admits a very similar collection of functions, which we omit from the discussion) mulG, divG respectively multiply and divide by the special element gm These are commonly used in applications, and have especially fast algorithms in all our repre- sentations, which is why we define them as special functions|,Non-data,41
| Note that because the input may not always be divisible by gm, the output type of divG is a Maybe tGaussian samples an element of the number field K from the “tweaked” continuous Gaussian distribution t · Dr, given v = r2 Because the output is a random variable, its type must be monadic (The functions errorRounded and errorCoset work similarly|,Non-data,41
|) The following functions involve Cyc data for two indices m||m’ (so the mth cyclotomic is a subring of the m’th one) The type signatures express the divisibility constraint as m ‘Divides‘ m’, which is statically checked at compile time embed, twace are respectively the embedding and “tweaked trace” functions crtSet is the relative CRT set cm(cid:48),m of the m’th cyclotomic ring over the mth one, modulo a prime power|,Non-data,41
| (See the full version for its formal definition and a novel algorithm for computing it) 33 Implementation We now describe some notable aspects of the Cyc and UCyc implementations As previously mentioned, Cyc is mainly a thin wrapper around UCyc that automatically manages the choice of representation rep, and also includes some important optimizations for ring elements that are known to reside in cyclotomic subrings|,Non-data,41
| In turn, UCyc is a thin wrapper around an instance of the Tensor class 331 Representations Cyc t m r can represent an element of the mth cyclotomic ring over base ring r in a few possible ways: • as a UCyc t m rep r for some rep = P, D, C, E; • when applicable, as a scalar from the base ring r, or more generally, as an element of the kth cyclotomic subring for some k||m, i|,Non-data,41
|e, as a Cyc t k r The latter subring representations enable some very useful optimizations: while cryptosystems often need to treat scalars and subring elements as residing in some larger cyclotomic ring, Cyc can exploit knowledge of their “true” domains to operate more efficiently, as described in Section 33|,Non-data,41
|2 below UCyc represents a cyclotomic ring element by its coefficient tensor with respect to the basis indicated by rep That is, for rep = P, D, C, a value of type UCyc t m rep r is simply a value of type (t m r) However, a CRT basis over r does not always exist, e|,Non-data,41
|g, if r represents the integers Z, or Zq for a modulus q that does not meet certain criteria To handle such cases we use rep = E, which indicates that the representation is relative to a CRT basis over a certain extension ring CRTExt r that always admits such a basis, eg|,Non-data,41
|, the complex numbers C 332 Operations Most of the Cyc functions shown in Figure 3 simply call their UCyc counterparts for an appropriate representation rep, after converting any subring inputs to the full ring|,Non-data,41
| Similarly, most of the UCyc operations for a given representation just call the appropriate Tensor method In what follows we describe some operations that depart from these patterns The algebraic instances for Cyc implement operations like (==), (+), and (*) in the following way: first they convert the inputs to “compatible” representations in the most efficient way possible, then they compute the output in an associated representation A few rules for how this is done are as follows: • For two scalars from the base ring r, the result is just computed and stored as a scalar, thus making the operation very fast|,Non-data,41
| • Inputs from subrings of indices k1, k2||m are converted to the compositum of the two subrings, ie, the cyclo- tomic of index k = lcm(k1, k2) (which divides m), then the result is computed there and stored as a subring element • For (+), the inputs are converted to a common repre- sentation and added entry-wise|,Non-data,41
| • For (*), if one of the inputs is a scalar from the base ring r, it is simply multiplied by the coefficients of the other input (this works for any r-basis representation) Otherwise, the two inputs are converted to the same CRT representation and multiplied entry-wise 1000The implementation of embed for Cyc is “lazy,” merely storing its input as a subring element and returning instantly For twace from index m’ to m, there are two cases: if the input is represented as a UCyc value (i|,Non-data,41
|e, not as a subring element), then we just invoke the appropriate representation- specific twace function on that value Otherwise, the input is in the k’th cyclotomic for some k’||m’, in which case we apply twace from index k’ to index k = gcd(m, k’), which is the smallest index where the result is guaranteed to reside, and store the result as a subring element 3|,Non-data,41
|33 Promoting Base-Ring Operations Many cryptographic operations on cyclotomic rings are defined as working entry-wise on the ring element’s coefficient tensor with respect to some basis For example, reducing from R to Rq is equivalent to reducing the coefficients from Z to Zq in any basis, while “decoding” Rq to R (as used in decryption) is defined as lifting the Zq-coefficients, relative to the decoding basis, to their smallest representatives in Z To implement these and many other operations, we generically “promote” operations on the base ring to corresponding oper- ations on cyclotomic rings, using the fact that UCyc t m rep is an instance of the category-theoretic classes Functor etc|,Non-data,41
| As a brief example, consider the Functor class, which in- troduces fmap :: Functor f => (a -> b) -> f a -> f b Our Functor instance for UCyc t m rep defines fmap g c to apply g to each of c’s coefficients (in the basis indicated by rep) This lets us easily promote our specialized lattice operations from Section 2 For example, Reduce z zq can be promoted to Reduce (UCyc t m P z) (UCyc t m P zq) simply by defining reduce = fmap reduce|,Non-data,41
| We similarly promote other base-ring operations, including lifting from Zq to Z, rescaling from Zq to Zq(cid:48) , discretization of Q to either Z or to a desired coset of Zp, and more The full version of the paper additionally describes how we promote the “gadget” operations decompose and correct, which requires the richer category-theoretic class Traversable It also describes how we implement a specialized, more effi- cient algorithm for rescaling a product ring Rq = Rq1 × Rq2 to Rq1 (where the moduli qi may themselves be products) 4|,Non-data,41
| FHE IN Λ◦λ In this section we describe a full-featured fully homomor- phic encryption and its implementation in Λ◦λ, using the interfaces described in the previous sections At the mathe- matical level, the system refines a variety of techniques and features from a long series of works [42, 12, 13, 11, 28, 43, 3] In addition, we describe some novel generalizations and op- erations, such as “ring-tunneling” Due to space restrictions, most of the mathematical operations and their implementa- tions are deferred to the full version (but see Figure 1 for representative code)|,Non-data,41
| 41 Keys, Plaintexts, and Ciphertexts The cryptosystem is parameterized by two cyclotomic rings: R = Om and R(cid:48) = Om(cid:48) where m||m(cid:48), making R a subring of R(cid:48) A secret key is an element s ∈ R(cid:48) Some operations require s to be “small;” more precisely, we need s · gm(cid:48) to have small coordinates in the canonical embedding of R(cid:48) (see Invariant 1)|,Non-data,41
| Recall that this is the case for “tweaked” spherical Gaussian distributions The plaintext ring is Rp = R/pR, where p is a (typically small) positive integer, eg, p = 2|,Non-data,41
| For technical reasons, The ciphertext ring is R(cid:48) p must be coprime with every odd prime dividing m(cid:48) A plaintext is simply an element μ ∈ Rp q = R(cid:48)/qR(cid:48) for some integer mod- ulus q ≥ p that is coprime with p A ciphertext is essentially just a polynomial c(S) ∈ R(cid:48) q[S], i|,Non-data,41
|e, one with coefficients from R(cid:48) q in an indeterminant S, which represents the (un- known) secret key We often identify c(S) with its vector of coefficients (c0, c1,  |,Non-data,41
|  , cd) ∈ (R(cid:48) q)d+1, where d is the degree of c(S) In addition, a ciphertext carries a nonnegative integer k ≥ 0 and a factor l ∈ Zp as auxiliary information These values are affected by certain operations on ciphertexts, as described below|,Non-data,41
| A ciphertext c(S) (with auxiliary values k ∈ Z, l ∈ Zp) encrypting a plaintext μ ∈ Rp under secret key s ∈ R(cid:48) satisfies the “most significant digit” (MSD) relation c(s) ≈ q p · (l −1 · gk m(cid:48) · μ) (mod qR (cid:48) ), where the approximation hides a small fractional error term p R(cid:48)) that satisfies Invariant 1 (The full version also de- (in 1 scribes an alternative “least significant digit” (LSD) relation; it is possible to losslessly convert between the two forms) Due to space restrictions, we describe the algorithms and implementations for encryption, decryption, homomorphic addition and multiplication, modulus switching, and key- switching/linearization in the full version 4|,Non-data,41
|2 Ring Tunneling The term “ring switching” encompasses a collection of techniques, introduced in [11, 28, 3], that allow one to change the ciphertext ring for various purposes These techniques can also induce a corresponding change in the plaintext ring, at the same time applying a desired linear function to the underlying plaintext Here we describe a novel method of ring switching, which we call ring tunneling, that is more efficient than the function- ally equivalent method of [3], which for comparison we call ring hopping The difference between the two methods is that hopping goes “up and then down” through the compositum of the source and target rings, while tunneling goes “down and then up” through their intersection (the largest common subring)|,Non-data,41
| Essentially, tunneling is more efficient because it uses an intermediate ring that is smaller than, instead of larger than, the source and target rings In addition, we show how the linear function that is homomorphically applied to the plaintext can be integrated into the key-switching hint, thus combining two separate steps into a simpler and more efficient operation overall We provide a simple implementa- tion of ring tunneling in Λ◦λ, which to our knowledge is the first realization of ring-switching of any kind Linear functions|,Non-data,41
| We will need some basic theory of linear functions on rings Let E be a common subring of some rings R, S A function L : R → S is E-linear if for all r, r(cid:48) ∈ R and e ∈ E, (cid:48) L(r + r ) = L(r) + L(r (cid:48) ) and L(e · r) = e · L(r) From this it follows that for any E-basis b of R, an E-linear function L is uniquely determined by its values yj = L(bj) ∈ S|,Non-data,41
| Specifically, if r = bt · e ∈ R for some e over E, then L(r) = L(b)t · e = yt · e Now let E(cid:48), R(cid:48), S(cid:48) respectively be cyclotomic extension rings of E, R, S satisfying certain conditions described below 1001As part of ring switching we will need to extend an E-linear function L : R → S to an E(cid:48)-linear function L(cid:48) : R(cid:48) → S(cid:48) that agrees with L on R, ie|,Non-data,41
|, L(cid:48)(r) = L(r) for every r ∈ R The following lemma gives a sufficient condition for when and how this is possible (See the full version for a proof) Lemma 1|,Non-data,41
| Let e, r, s, e(cid:48), r(cid:48), s(cid:48) respectively be the indices of cyclotomic rings E, R, S, E(cid:48), R(cid:48), S(cid:48), and suppose e = gcd(r, e(cid:48)), r(cid:48) = lcm(r, e(cid:48)), and lcm(s, e(cid:48))||s(cid:48) Then: 1 The relative decoding bases dr,e of R/E and dr(cid:48),e(cid:48) of R(cid:48)/E(cid:48) are identical 2|,Non-data,41
| For any E-linear function L : R → S, the function L(cid:48) : R(cid:48) → S(cid:48) defined by L(cid:48)(dr(cid:48),e(cid:48) ) = L(dr,e) is E(cid:48)-linear and agrees with L on R Ring tunneling as key switching Abstractly, ring tunneling homomorphically evaluates a desired Ep-linear function Lp : Rp → Sp on a plaintext, by converting its ciphertext over R(cid:48) q We now show that it can be implemented as a form of key switching|,Non-data,41
| q to one over S(cid:48) Ring tunneling involves two phases: a preprocessing phase where we use the desired linear function Lp and the secret keys to produce appropriate hints, and an online phase where we apply the tunneling operation to a given ciphertext using the hint The preprocessing phase is as follows: p : R(cid:48) agrees with Lp on Rp, as described above 1 Extend Lp to an E(cid:48) p-linear function L(cid:48) p → S(cid:48) p that 2|,Non-data,41
| Lift L(cid:48) p to a “small” E(cid:48)-linear function L(cid:48) : R(cid:48) → S(cid:48) that p Specifically, define L(cid:48) by L(cid:48)(dr(cid:48),e(cid:48) ) = y, p(dr(cid:48),e(cid:48) ) induces L(cid:48) where y (over S(cid:48)) is obtained by lifting yp = L(cid:48) using the powerful basis The above lifting procedure is justified by the following considerations We want L(cid:48) to map ciphertext errors in R(cid:48) to errors in S(cid:48), maintaining Invariant 1 in the respective rings|,Non-data,41
| In the relative decoding basis dr(cid:48),e(cid:48) , r(cid:48),e(cid:48) · e ∈ R(cid:48) has E(cid:48)-coefficients e ciphertext error e = dt that satisfy the invariant for E(cid:48), and hence for S(cid:48) as well Because we want (cid:48) L (e) = L (cid:48) r(cid:48),e(cid:48) · e) = yt · e ∈ S (dt (cid:48) to satisfy the invariant for S(cid:48), it is therefore best to lift yp from S(cid:48) p to S(cid:48) using the powerful basis 3 Prepare an appropriate key-switching hint using keys sin ∈ R(cid:48) and sout ∈ S(cid:48)|,Non-data,41
| Let b be an arbitrary E(cid:48)-basis of R(cid:48) (which we also use in the online phase below) Using a gadget vector g over S(cid:48) q, generate key-switching hints Hj for the components of L(cid:48)(sin · bt), such that (41) (1, sout) · Hj ≈ L (sin · bj) · gt (mod qS ) (cid:48) (cid:48) (As usual, the approximation hides appropriate Ring- LWE errors that satisfy Invariant 1|,Non-data,41
|) Note that we can interpret the columns of Hj as linear polynomials The online phase proceeds as follows As input we are given an MSD-form, linear ciphertext c(S) = c0 + c1S (over R(cid:48) q) with associated integer k = 0 and arbitrary l ∈ Zp, encrypting a message μ ∈ Rp under secret key sin 1|,Non-data,41
| Express c1 uniquely as c1 = bt · e for some e over E(cid:48) (where b is the same E(cid:48)-basis of R(cid:48) used in Step 3 above) q 2 Compute L(cid:48)(c0) ∈ S(cid:48) q, apply the core key-switching operation to each ej with hint Hj, and sum the results Formally, output a ciphertext having k = 0, the same l ∈ Zp as the input, and the linear polynomial (cid:48) (cid:88) (cid:48) (cid:48) Hj · g −1(ej) (mod qS )|,Non-data,41
| (42) c (S) = L (c0) + j For correctness, notice that we have =⇒ L (cid:48) c0 + sin · c1 ≈ q (c0 + sin · c1) ≈ q p · l p · l −1 · μ (mod qR −1 · L(μ) (cid:48) ) ), (43) where the error in the second approximation is L(cid:48) applied to the error in the first approximation, and therefore satisfies Invariant 1 by design of L(cid:48) Then by Equations (4|,Non-data,41
|2), (41), E(cid:48)-linearity of L(cid:48), the definition of e, and Equation (43), (mod qS (cid:48) (cid:48) (sout) ≈ L (cid:48) c (c0) + (cid:48) (sin · bj) · gt · g −1(ej) L (cid:88) j (c0 + sin · bt · e) (cid:48) (c0 + sin · c1) (cid:48) p · l −1 · L(μ) = L = L ≈ q (mod qS (cid:48) ) as desired, where the error in the first approximation comes from the hints Hj Comparison to ring hopping|,Non-data,41
| We now describe the efficiency advantages of ring tunneling versus ring hopping We analyze the most natural setting where both the input and output ciphertexts are in CRT representation; in particular, this allows the process to be iterated as in [3] Both ring tunneling and ring hopping convert a ciphertext over R(cid:48) q, either via the greatest common subring E(cid:48) q (in hopping) In both cases, the bottleneck is key-switching, where we compute one or more values H · g−1(c) for some hint H and ring element c (which may be over different rings)|,Non-data,41
| This proceeds in two main steps: q (in tunneling) or the compositum T (cid:48) q to one over S(cid:48) 1 We convert c from CRT to powerful representation for g−1-decomposition, and then convert each entry of g−1(c) to CRT representation Each such conversion takes Θ(n log n) = ̃Θ(n) time in the dimension n of the ring that c resides in 2|,Non-data,41
| We multiply each column of H by the appropriate entry of g−1(c), and sum Because both terms are in CRT representation, this takes linear Θ(n) time in the dimension n of the ring that H is over The total number of components of g−1(c) is the same in both tunneling and hopping, so we do not consider it further in this comparison In ring tunneling, we switch dim(R(cid:48)/E(cid:48)) elements ej ∈ E(cid:48) q (see Equation (4|,Non-data,41
|2)) using the same number of hints over S(cid:48) q Thus the total cost is )·( ̃Θ(dim(E ))) = ̃Θ(dim(R ))+Θ(dim(S dim(R /E (cid:48) (cid:48) (cid:48) (cid:48) (cid:48) ))+Θ(dim(T (cid:48) )) By contrast, in ring hopping we first embed the ciphertext into the compositum T (cid:48) q and key-switch there Because the 1002compositum has dimension dim(T (cid:48)) = dim(R(cid:48)/E(cid:48)) · dim(S(cid:48)), the total cost is ̃Θ(dim(T (cid:48))) + Θ(dim(T (cid:48)))|,Non-data,41
| The second (linear) terms of the above expressions, corresponding to Step 2, are essentially identical For the first (superlin- ear) terms, we see that Step 1 for tunneling is at least a dim(T (cid:48)/R(cid:48)) = dim(S(cid:48)/E(cid:48)) factor faster than for hopping In typical instantiations, this factor is a small prime between, say, 3 and 11, so the savings can be quite significant in practice 5|,Non-data,41
| EVALUATION Recall that Λ◦ λ primarily aims to be a general, modu- lar, and safe framework for lattice cryptography, while also achieving acceptable performance While Λ◦λ’s modularity and static safety properties are described in the other sec- tions of the paper, here we evaluate two of its lower-level characteristics: code quality and runtime performance For comparison, we also give a similar analysis for HE- lib [34], which is Λ◦λ’s closest analogue in terms of scope and features (Recall that HElib is a leading implementa- tion of fully homomorphic encryption|,Non-data,41
|) We emphasize two main caveats regarding such a comparison: first, while Λ◦λ and HElib support many common operations and features, they are not functionally equivalent—eg, Λ◦ λ supports ring-switching, error sampling, and certain gadget operations that HElib lacks, while HElib supports ring automorphisms and sophisticated plaintext “shuffling” operations that Λ◦λ lacks Second, Λ◦λ’s host language (Haskell) is somewhat higher-level than HElib’s (C++), so any comparisons of code quality or performance will necessarily be “apples to oranges|,Non-data,41
|” Nevertheless, we believe that such a comparison is still mean- ingful and informative, as it quantifies the relative trade-offs of the two approaches in terms of software engineering values like simplicity, maintainability, and performance Our analysis shows that Λ◦λ offers high code quality, with respect to both the size and complexity In particular, Λ◦λ’s code base is about 7–8 times smaller than HElib’s Also, Λ◦λ currently offers good performance, always within an order of magnitude of HElib’s, and we expect that it can substantially improve with focused optimization|,Non-data,41
| Notably, Λ◦ λ’s C++ backend is already faster than HElib in Chinese Remainder Transforms for non-power-of-two cyclotomic indices with small prime divisors, due to the use of better algorithms associated with the “tensored” representations For example, a CRT for index m = 2633 (of dimension n = 576) takes about 99 μs in Λ◦λ, and 153 μs in HElib on our benchmark machine (and the performance gap grows when more primes are included) Due to space restrictions, in this section we present sum- mary statistics; detailed results can be found in the full version 5|,Non-data,41
|1 Source Code Analysis We analyzed the source code of all “core” functions from Λ◦λ and HElib, and calculated a few metrics that are in- dicative of code quality and complexity: actual lines of code, number of functions, and cyclomatic complexity [45] “Core” functions are any that are called (directly or indirectly) by the libraries’ public interfaces, such as algebraic, number- theoretic, and cryptographic operations, but not unit tests, benchmarks, etc Note that HElib relies on NTL [52] for the bulk of its algebraic operations (eg|,Non-data,41
|, cyclotomic and finite- field arithmetic), so to give a fair comparison we include only the relevant portions of NTL with HElib, referring to their combination as HElib+NTL Similarly, Λ◦λ includes a Tensor backend written in C++ (along with a pure Haskell one), which we identify separately in our analysis Source lines of code A basic metric of code complex- ity is program size as measured by source lines of code (SLOC)|,Non-data,41
| We measured SLOC for Λ◦ λ and HElib+NTL using Ohcount [7] for Haskell code and metriculator [38] for C/C++ code Metriculator measures logical source lines of code, which approximates the number of “executable state- ments” By contrast, Ohcount counts “physical ” (or actual) lines of code Both metrics exclude comments and empty lines, so they do not penalize for documentation or extra whitespace|,Non-data,41
| While the two metrics are not equivalent, they provide a rough comparison between the two code bases Codebase SLOC Total Λ◦λ Haskell C++ 4,257 734 4,991 HElib NTL HElib+NTL 14,709 20,073 34,782 Figure 4: Source lines of code for Λ ◦ λ and HE- lib+NTL Function count and cyclomatic complexity Mc- Cabe’s cyclomatic complexity (CC) [45] counts the number of “linearly independent” execution paths through a piece of code (usually, a single function), using the control-flow graph|,Non-data,41
| The theory behind this metric is that smaller cy- clomatic complexity typically corresponds to simpler code that is easier to understand and test thoroughly McCabe suggests limiting the CC of functions to ten or less Figure 5 gives a summary of cyclomatic complexities in Λ◦λ and HElib+NTL, as measured by argon [39] for Haskell code and metriculator [38] for C/C++ code A more detailed histogram is provided in the full version|,Non-data,41
| In both codebases, more than 80 % of the functions have a cyclomatic complexity of 1 (corresponding to straight-line code having no control- flow statements), but at higher complexities, Λ◦λ has many fewer functions in both an absolute and relative sense Codebase A B C Total Λ◦λ 1,234 HElib+NTL 6,850 14 159 5 69 1,253 7,078 Figure 5: Number of functions per argon grade: cy- clomatic complexities of 1–5 earn an ‘A,’ 6–10 a ‘B,’ and 11 or more a ‘C’ Only three Haskell functions and two C++ functions in Λ◦λ received a grade of ‘C;’ in each of these, the complexity is simply due to the many combinations of cases for the representations of the inputs (see Section 33|,Non-data,41
|2) The two C++ functions are the inner loops of the CRT and DFT transforms, due to a case statement that chooses the appro- priate unrolled code for a particular dimension, which we do for performance reasons 100352 Performance As a general-purpose library, we do not expect Λ◦ λ’s performance to be competitive with highly optimized (but in- flexible) C implementations like SWIFFT [41] and BLISS [20], but we aim for performance in the same league as higher-level libraries like HElib|,Non-data,41
| In the full version we give microbench- mark data for various common operations and parameter sets, to show that performance is reasonable and to establish a baseline for future work In summary, the benchmarks show that our pure-Haskell Tensor implementation (RT) based on Repa [37] tends to be about 2–40 times slower than our C++ backend (CT) However, CT itself is within a factor of 4–10 of HElib on bot- tleneck operations like CRTs and pointwise multiplications, and is actually faster for CRTs on non-power-of-two indices, because it uses a more efficient algorithm stemming from the “tensored” representations (See Figure 6|,Non-data,41
|) Most of our optimization efforts have been devoted to the CT backend, which partially explains the poor perfor- mance of the Repa backend; we believe that similarly tuning RT could speed up benchmarks considerably However, RT performance is currently limited by the architecture of our tensor DSL, which is blocking many compiler optimizations Specifically, the higher-rank types that make the DSL work for arbitrary cyclotomic indices also make specialization, in- lining, and fusion opportunities much more difficult for the compiler to discover Addressing this issue to obtain a fast and general pure-Haskell implementation is an important problem for future work|,Non-data,41
| Index m φ(m) HElib CT RT 210 = 1,024 211 = 2,048 2633 = 1,728 2634 = 5,184 263252 = 14,400 512 1,024 576 1,728 3,840 16 32 153 638 2,756 139 307 99 364 1,011 2,344 5,211 3,088 10,400 24,330 Figure 6: Runtimes (in microseconds) for the Chi- nese Remainder Transform from the powerful (P) to CRT (C) basis, for a single modulus For comparison, we include HElib’s analogous transformation from its “polynomial” to “Double CRT” representation, also with one modulus All benchmarks were per- formed on a mid-2012 laptop with a Core i7-3610QM processor and 6 GB RAM 6|,Non-data,41
|ABSTRACT We present simple, practical, and powerful new techniques for garbled circuits These techniques result in significant concrete and asymptotic improvements over the state of the art, for several natural kinds of computations For arithmetic circuits over the integers, our construction results in garbled circuits with free addition, weighted threshold gates with cost independent of fan-in, and ex- ponentiation by a fixed exponent with cost independent of the exponent For boolean circuits, our construction gives an exponential improvement over the state of the art for threshold gates (including AND/OR gates) of high fan-in|,Non-data,42
| Our construction can be efficiently instantiated with prac- tical symmetric-key primitives (eg, AES), and is proven secure under similar assumptions to that of the Free-XOR garbling scheme (Kolesnikov & Schneider, ICALP 2008) We give an extensive comparison between our scheme and state- of-the-art garbling schemes applied to boolean circuits|,Non-data,42
| 1 INTRODUCTION Garbled circuits were famously introduced by Yao in the 1980s [20] Since that time they have become an invaluable technique for both practical and theoretical cryptographic constructions Most notably, garbled circuits form the conceptual core for the most practical approaches to secure two-party computation|,Non-data,42
| In these protocols, the garbled circuits are the major performance bottleneck both in computation and communication A considerable amount of work [5, 16, 14, 18, 6, 13, 21, 11] has been dedicated to reducing the cost of garbled circuits since Yao’s seminal construction The current state of the art provides highly efficient garbling for boolean circuits ex- pressed using XOR, NOT, & AND gates Concretely, using the most recent half gates construction of Zahur, Rosulek and Evans [21], XOR & NOT involve no computation or communication, while fan-in-2 AND gates require 4 AES calls to garble, 2 AES calls to evaluate, and 256 bits to communicate|,Non-data,42
| Implementations like JustGarble [6], which take advantage of hardware-accelerated AES, can garble Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee|,Non-data,42
| Request permissions from permissions@acmorg CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s) Publication rights licensed to ACM|,Non-data,42
 ISBN 978-1-4503-4139-4/16/10   $15,Non-data,42
00 DOI: http://dxdoiorg/101145/2976749,Non-data,42
|2978410 circuits at a rate of 100s of millions AND gates per second on consumer hardware Despite this success story, garbled circuits remain tied deeply to boolean circuits Many computations of interest are cumbersome and expensive to express as boolean cir- cuits As two specific examples (which our contributions address directly): • Threshold computations with very high fan-in (for ex- ample, the kinds of computations that might be found in a neural-network-based classifier) do not have small boolean circuits|,Non-data,42
| • Arithmetic computations (over the integers or in a ring mod m) are poorly suited to boolean circuits, especially when compared to other techniques for secure compu- tation that are based on secret sharing In particular, secret-sharing-based secure computation protocols allow additions for free, whereas addition in a boolean circuit requires non-free AND gates (even ignoring a possible modular reduction step) Our work aims to address these shortcomings of boolean circuits and directly construct garbled circuit techniques supporting these advanced kinds of computations 1|,Non-data,42
|1 Our Contributions We show a practical garbling scheme that can be used to natively garble both boolean circuits and arithmetic circuits (with arithmetic over a large modulus), applying insights and techniques from one domain to the other Our approach gives significant concrete & asymptotic improvements over the state of the art In particular, our most extreme improvements are for the following kinds of computations (below λ is a security parameter, eg|,Non-data,42
|, 128 bits): Linear operations in arithmetic circuits Our scheme supports addition and multiplication by a public con- stant for free, over the integers Other costs in the scheme (ie|,Non-data,42
|, size of wire labels & cost of other gates) depend only polylogarithmically on the maximum size of integers in the computation In this way, our construction combines the best as- pects of the two main paradigms for secure com- putation: free addition (beyond addition mod 2) as in secret-sharing-based MPC, and constant-round protocols from garbled circuits Current garbled circuit techniques would represent integers in binary and incur O(λ (cid:96)) cost to add two (cid:96)-bit numbers 565Other arithmetic operations|,Non-data,42
| Our scheme supports ex- ponentiation (by a fixed/public power) with cost in- dependent of the choice of exponent, and weighted threshold gates with cost that is independent of the fan-in High fan-in boolean threshold gates For gates of fan- in b, our construction requires O(λ log3 b) bits, or only O(λ log2 b) bits in the special case of AND/OR gates Current techniques are exponentially worse, requiring Θ(λb) bits even for AND/OR gates|,Non-data,42
| On the other hand, our scheme does least well on comparison gates, where we are polynomially slower We give more in-depth comparisons between our scheme and existing techniques in Sections 7 and 8 We also explore the case of natural linear algebraic operations over the integers (eg|,Non-data,42
|, matrix multiplication) and show that our techniques give close to an order of magnitude improvement Finally, we use our construction to circumvent the lower bound of [21] They proved that any garbling scheme using “known techniques” requires 2λ bits to garble a single AND- gate, while we show an instantiation of our construction that garbles a single AND-gate using only λ bits This instantiation is of theoretical interest, but does not lead to improvements for general larger circuits|,Non-data,42
| 12 Techniques Our results build on a simple and powerful combination of techniques that were introduced in previous works in several contexts In particular, our garbling scheme is based on a natural generalization of the Free-XOR technique of Kolesnikov & Schneider [14], allowing for free addition mod larger m, rather than just mod 2 This generalization was shown before, e|,Non-data,42
|g by Malkin, Pastro and shelat [15], who used it to obtain free addition in arithmetic (mod m) circuits We observe that this technique is in fact useful not only for mod-m addition, but for any operation that depends only on the Hamming weight of its inputs (namely, symmetric operation): such operations can be garbled by first applying free addition to get the Hamming weight, then applying a projection gadget which garbles a unary mapping of each sum to the correct output This projection gadget can be viewed as the trivial extension of Yao’s garbled gate, applied to unary gates over mod m inputs (similar gadgets have been used before, at least implicitly, e|,Non-data,42
|g in [14, 13]) In Section 4 we formally describe these simple components as a garbling scheme for what we call “mixed moduli simple circuits”, which are circuits that allow only modular addition (under many moduli) and projections As we show in Section 5, these simple components already provide savings over the state of the art, even for boolean circuits, through simple ways to represent boolean gadgets as mixed moduli circuits|,Non-data,42
| One example is a boolean fan-in-b AND gate, which has output equal 1 if and only if the sum of its inputs equals b, and thus can be represented as a projection of sum This representation can be viewed as an extension of the one by Nielsen and Orlandi [17], who (in a different context) represent a fan-in-2 NAND gate by adding the two inputs over the integers and then giving a gadget that checks whether or not the result equals 2 While the above ideas directly handle symmetric oper- ations like boolean AND and threshold gates, as well as arithmetic addition, the cost grows prohibitively high as the modulus (or the fan-in) grows, and other operations such as comparison or modular multiplication are also highly inefficient We address this in Section 6 by showing how to express those more complex operations with high moduli more efficiently as mixed moduli circuits|,Non-data,42
| In particular, we represent large-modulus values using the Chinese Remainder Theorem (CRT), as well as another primorial mixed-radix representation, together with several other optimizations (as we will explain) We note that CRT-based representations have also been used in many other contexts, with the most relevant one being by Applebaum, Ishai, and Kushilevitz [2] who (in addition to their more efficient main result) outline a garbling scheme for arithmetic circuits, relying on first encoding the inputs via CRT encoding, and then applying standard boolean garbled circuit techniques In Section 7 we discuss how to use our gadgets for better garbling of boolean and arithmetic circuits, provide asymptotic and concrete comparison with standard garbled circuit techniques, and discuss a linear algebraic application scenario Finally in Section 8 we give a more in-depth comparison to the related work discussed above, and to other 2PC techniques|,Non-data,42
| 2 PRELIMINARIES Logarithms are taken to be base 2, unless otherwise noted We take pi to denote the i-th prime Let Z denote the integers, and N the natural numbers|,Non-data,42
| Additionally, Zm denotes the ring of integers modulo m ∈ N We use [x]m to denote the residue of x mod m In some cases it is convenient to define < on Zm For concreteness, if m = 2k + 1 for some k, then consider Zm as {−k, |,Non-data,42
|   ,−1, 0, 1,  |,Non-data,42
|  , k} and let x < y if y − x > 0 over Z Otherwise if m = 2k, then consider Zm as {−k + 1,  |,Non-data,42
|  ,−1, 0, 1,   |,Non-data,42
| , k}, defining order identically 21 Garbled Circuits We use the garbling schemes abstraction and security definitions of Bellare, Hoang and Rogaway [7] Roughly speaking, a garbling scheme consists of the following algo- rithms: Gb: given input a circuit f , generates garbled circuit F , encoding information e, and decoding information d En: given a circuit-input x, encoding information e, gener- ates garbled input X Ev: given garbled circuit F and garbled input X, generates garbled output Y De: given garbled output Y and decoding information d, generates plaintext circuit-output y Bellare et al|,Non-data,42
| identify 3 natural security properties for a garbling scheme, which we summarize below For more details, we refer the reader to [7]: • Privacy (prvsim security): intuitively, the distribution of values (F, X, d) — generated as above — leaks no more than f (x) More specifically, there exists a simulator that can simulate the joint distribution of (F, X, d) given just f and f (x)|,Non-data,42
| • Obliviousness (obvsim security): the values (F, X) alone (ie, without d) leak nothing about x|,Non-data,42
| That is, there exists a simulator that can simulate (F, X) given just f  566• Authenticity (aut security): Given (F, X), it is infeasible for an adversary to generate ̃Y (cid:54)= Ev(F, X) such that De(d, Y ) (cid:54)= ⊥ 3 BACKGROUND ON GARBLED CIRCUITS We give a brief and self-contained overview of standard garbled circuit constructions and optimizations|,Non-data,42
| Readers familiar with garbled circuits may safely skip this section 31 Yao’s Classical Construction In (the modern interpretation of) Yao’s scheme [20], the garbler chooses two random wire labels W 0 and W 1 for each wire, where W x is a bit-string encoding the truth value x Then for each (boolean, fan-in 2) gate, the garbler generates a garbled gate consisting of 4 ciphertexts|,Non-data,42
| If a gate has input wires indexed i and j, output wire index k, and functionality g : {0, 1}2 → {0, 1}, then the 4 ciphertexts are: (W g(0,1) ), (W g(1,1) (W g(0,0) (W g(1,0) ), EW 0 ), EW 1 EW 0 EW 1 i ,W 1 j i ,W 0 j ) k k i ,W 1 j k k i ,W 0 j where Ek(m) is a suitable encryption scheme Intuitively, the wire labels encoding (a, b) on the input wires are used as keys to encrypt the wire label encoding g(a, b) on the output wire An evaluator evaluates the garbled circuit by holding one wire label per wire Hence, she can decrypt only one ciphertext per gate, and learn one label for the output wire|,Non-data,42
| We point out that Yao’s classical scheme can be trivially extended to support garbling of non-boolean circuits of any fan-in In particular, for m-ary wires we choose m different wire labels on each wire Then to garble a fan-in-k gate, we include mk ciphertexts (one for each entry in the gate’s truth table) While this trivial extension is obviously not efficient, we will rely on this observation for unary gates (fan-in 1) as a component in some of our gadgets|,Non-data,42
| 32 Standard Elementary Optimizations Arranging the 4 ciphertexts in order of truth values leaks information, so in the classical scheme these ciphertexts are given in random order The evaluator performs trial de- cryption on each one, and we use an encryption scheme that makes it obvious when decrypting the “correct” ciphertext A better approach is to use the point-and-permute optimization of Beaver, Micali and Rogaway [5]|,Non-data,42
| A random “color bit” is appended to each wire label, so that W 0 i and W 1 i have opposite color bits Because the association between colors and truth values is random, it is safe to arrange the 4 ciphertexts according to color bits of the input wire labels (ie, the first ciphertext should be the one that uses two keys having both 0 color bits, regardless of what truth value they represent)|,Non-data,42
| Using point-and-permute, the evaluator need only decrypt one ciphertext — the one indicated by the color bits of the input wire labels Hence, it is possible to use a simple one- time encryption scheme Ek1,k2 (m) = H(g; k1(cid:107)k2)⊕m, where g is the index of the gate and H is a key derivation function or random oracle The number of ciphertexts can also be reduced from 4 to 3 by the following row reduction trick of Naor, Pinkas and Sumner [16] Instead of choosing the output wire labels W 0 k at random, we choose one of them so that the first of the 4 ciphertexts is always the all-zeroes string|,Non-data,42
| For k and W 1 (W 1 i ,W 0 j k , then we choose W 1 j )⊕ W 1 i (cid:107)W 0 example, if the first ciphertext for a gate is EW 0 k ) = i (cid:107)W 0 H(g; W 0 k not uniformly, but as H(g; W 0 j ) Since the first ciphertext is all zeroes, it need not be sent, and only 3 ciphertexts are required Note that this method constrains the selection of one of W 0 k , W 1 k  A more sophisticated approach, constraining the selection of both labels, can further reduce the garbled gate to 2 ciphertexts, as shown by Pinkas et al|,Non-data,42
| [18] (see also a simpler construction in [11]) 33 Free-XOR i ⊕ W 1 Arguably the optimization to garbled circuits with the highest practical impact is the Free-XOR optimization of Kolesnikov & Schneider [14] When using Free-XOR, wire i = ∆, where ∆ ∈ {0, 1}λ labels are chosen so that W 0 is a secret value that is common to the entire circuit|,Non-data,42
| In other words, the wire label that encodes x can be written as i ⊕ x∆ The result of this choice of wire labels is W x i = W 0 i ⊕ W y j ) ⊕ (x ⊕ y)∆; that is, simply that (W x XORing two wire labels that encode x & y results in a wire label encoding x ⊕ y, if we take W 0 j to be the “false” wire label of the output wire As a consequence, garbled values can be XOR’ed without any cryptographic operations by the evaluator or any garbled-gate information in the garbled circuit i ⊕ W 0 i ⊕ W 0 j ) = (W 0 k = W 0 To support point-and-permute, consider appending an additional bit to both ∆ and each wire label to represent the color bits|,Non-data,42
| Suppose this last bit of ∆ is 1, and we extend the relation W 0 i = ∆ to include these color bits, then on every wire the two wire labels W 0 i will still have opposite and random color bits This is all that is required for point-and-permute i ⊕ W 1 i and W 1 The Free-XOR optimization is easily compatible with the row reduction trick above, allowing for 3 ciphertexts per AND gate and 0 per XOR It is not compatible with the 2-row reduction of [18], since that technique constrains the selection of both wire labels, and thus does not allow to maintain the required ∆ relation|,Non-data,42
| However, the half-gates technique of [21] provides a way to achieve a 2 ciphertext AND that is compatible with free-XOR 4 OUR BUILDING BLOCKS 41 Generalizing Free-XOR & Point-Permute Our starting point is a natural generalization of Free- XOR which permits free addition mod m for any fixed m (collapsing to Free-XOR when m = 2)|,Non-data,42
| This generalization was also used by [15] In this section, and throughout the rest of this paper, we interpret wire labels as vectors of Zm- elements We use bold-face symbols to denote wire labels (Zm-vectors) Each wire carries a logical value in Zm|,Non-data,42
| The wire label encoding x ∈ Zm is W x i + x∆m, where now addition refers to component-wise addition in Zm The value ∆m is a random vector of Zm-elements that is global to the circuit Our construction will involve wires with different moduli, and we use a different ∆m for each modulus m (but all wires with associated modulus m will share the same ∆m) Like Free-XOR, this generalization supports several com- i = W 0 putations on garbled values for free: • Addition mod m: We can add garbled values mod m 567for free, since (W x (where additions are mod m)|,Non-data,42
| i + W y j ) = (W 0 i + W 0 j ) + (x + y)∆m • Multiplication by a public/constant c mod m, provided that c is coprime to m: This becomes nontrivial only when generalizing beyond m = 2 Indeed, let c ∈ Zm be a known constant, then cW x i + x∆m) = cW 0 i +(cx)∆m, where the operations are component-wise mod m We require c to be coprime to m for technical reasons in the security proof — intuitively, multiplying W 0 i by c preserves its uniform distribution i = c(W 0 We can similarly generalize the point-permute optimiza- tion|,Non-data,42
| As described in Section 3, imagine appending an extra color “digit” (now a Zm element rather than a single bit) to each wire label and a 1 ∈ Zm digit to ∆m (any other digit value that is coprime to m would also work) Let τm(W ) denote the last component of such a wire label, then we have τm(W x j ) = τm(W 0 j ) + x · τm(∆m) = τm(W 0 j ) + x In other words the m possible wire labels for this wire are assigned a random cyclic shift of the set Zm of possible colors, with the cyclic shift amount being determined by the random value τm(W 0 j ) This turns out to be sufficient to prove security of this generalization of point-permute|,Non-data,42
| In short, seeing the color of a single label W x i on a wire leaks no information about its truth value x Length of the wire labels Let λ denote the global security parameter, and define λm = (cid:100)λ/ log m(cid:101) Suppose wire labels mod m have λm components, each from Zm|,Non-data,42
| Then the length of wire labels when written as strings is at least λ bits, which is important for security When accounting for the point-permute optimization, we In the end, wire  Their length in bits add an extra component to wire labels labels mod m are elements of Zλm+1 is therefore at most λ + 2 log m bits|,Non-data,42
| m Instead of starting with λ-bit wire labels and adding a few bits for the “color digit,” one could alternatively think of all wire labels having exactly λ bits (including color digits), but the color digits slightly degrading the effective security parameter by log m bits For instance, in practice one would typically use AES-128 to implement garbled circuits Then it is convenient if all wire labels are exactly 128 bits One would require AES to provide security when the last log m bits of the key are known|,Non-data,42
| In our final constructions, we never suggest a modulus m larger than, say, 256 So in practice our construction would degrade the AES security by only 8 bits We note that all implementations of garbled circuits take this approach, but for the case of simple point- permute where the degradation of security is only 1 bit 4|,Non-data,42
|2 Garbling Mixed Moduli Simple Circuits Next, we construct a simple and practical garbling scheme for a special subclass of circuits In the following sections we will show how to efficiently express more general compu- tations with this subclass A mixed-modulus simple circuit is a circuit (directed acyclic graph) where each wire has an associated modulus (ie|,Non-data,42
|, the wire can carry values from Zm for its preferred m) In addition to standard input/output gates, the circuit is allowed to have the following types of internal gates: • An addition-mod-m gate (of unbounded fan-in) is allowed if all the wires touching the gate are mod-m wires • A unary gate that multiplies by a constant mod m is allowed if both the input and output wire are mod m, and if the constant is coprime to m • Arbitrary unary “projection” gates: if the input wire is mod-m and the output wire is mod-n, then the gate can apply an arbitrary function φ : Zm → Zn|,Non-data,42
| We refer to a gate with this functionality as Projφ In our construction, the first two types of gates are “free”, and the third type uses at most m − 1 ciphertexts (the “−1” follows from the row-reduction technique) The main idea follows the discussion above For each modulus m that appears in the circuit, we choose a global value ∆m (interpreted as a vector in Zλm+1 ), and use the generalized free-XOR method of choosing wire labels|,Non-data,42
| That is, W 0 is i random and W x i + x∆m Addition mod m and multiplication by a (coprime) constant can be garbled for free, as described above i = W 0 m A projection gate Projφ can be garbled using m cipher- texts, where each wire label W x is used to encrypt the i associated payload W φ(x)  These m ciphertexts can be ordered by the color digits of the input wire labels, namely by x+τ , where τ = τm(W 0 i )|,Non-data,42
| Thus, the garbled gate consists of the following m ciphertexts (one for each x): j ˆGx+τ = H(g, W 0 = H(g, W x i + x∆m) + W 0 i ) + W φ(x) , j j + φ(x)∆n where H is a hash/key derivation function (see below) and g is the gate index (used as a tweak in the hash function) The outer vector addition (as well as the value of φ(x)) is over Zn, while the inner vector addition (as well as the values of x, τ ) are over Zm The evaluator will decrypt only one of these ciphertexts, specifically the one whose subscript is the color digit of the input wire label she holds Using the row reduction trick described above [16], we can remove one of the ciphertexts (getting m− 1) by setting )−φ(−τ )∆n|,Non-data,42
| ˆG0 = 0 To do this, choose W 0 We could also remove 2 ciphertexts (getting m − 2) using the approach of [18, 11], but at the cost of having the output wire labels no longer satisfy the ∆m-correlation property j = −H(g, W −τ i The scheme is presented formally in Figure 1 4|,Non-data,42
|3 Security Here we prove security of the basic garbling scheme we just presented We point out that the security of our constructions in later sections will follow from the fact that we express the desired functionality as a mixed-modulus simple circuit, to be garbled using our basic scheme The original free-XOR construction of [14] was proven secure in the random oracle model Choi et al|,Non-data,42
| [9] later proved that the security depends only on a specific prop- erty of the oracle that they called circular correlation- robustness Let H be a hash function and define an oracle OH ∆ (g, X, Y, a, b, c) = H(g, X ⊕ a∆, Y ⊕ b∆) ⊕ c∆ Here X, Y, ∆ are string of length λ, while a, b, c are bits, and g is an arbitrary string Then H is circular-correlation-robust if the outputs of this oracle appear random, to adversaries that query on distinct g values with a, b not both zero, when ∆ is chosen uniformly|,Non-data,42
| We use the corresponding generalization to multiple ∆ 568procedure Gb(1λ, f ) for m ∈ fwiredomains do λm ←(cid:108) λ (cid:109) log m u← Zλm m (cid:107)1 ∆m for i ∈ finputs do Zm ← idomain u← Zλm+1 W 0 i 1 , |,Non-data,42
|   , W 0 ˆe ← (W 0 for g ← fgatestopo do m q , ∆m1 , |,Non-data,42
|   , ∆mr ) a1 − τ ∆m) − φ(−τ )∆n (cid:1) + W 0 a1 + x · ∆m g + φ(x)∆n a ← ginputs Zm ← g|,Non-data,42
|domain if g is Addm-gate then g ←(cid:80)b i=1 W 0 ai W 0 else if g is Multc-gate then else if g is Projφ gate then a1 g ← c · W 0 W 0 Zn ← grange τ ← τ (W 0 a1 ) W 0 for x ∈ Zm do g ← −H(g, W 0 x+τ ← H(cid:0)g, W 0 ˆGg k−1) ˆGg ← ( ˆGg 1,   |,Non-data,42
| , ˆGg ˆF ← ( ˆG1,    , ˆG||gates|,Non-data,42
|proj||) for i ∈ foutputs do Zm ← idomain, for k ∈ Zm do di ← (d0 i ,  |,Non-data,42
|  , dm−1 i ← H(out(cid:107)i(cid:107)k, W 0 dk ) i ˆd ← (d1,   |,Non-data,42
| , d(cid:96)) return ( ˆF , ˆe, ˆd) i + k∆m) procedure En(ˆe, ˆx) for xi ∈ ˆx do Zm ← idomain Xi ← W 0 i + xi · ∆m return ˆX ← (X1,   |,Non-data,42
| , Xq) for di ∈ ˆd do procedure De( ˆd, ˆY ) Zm ← idomain (h1,   |,Non-data,42
| , hm) ← di for k ∈ Zm do yi ← k if H(out(cid:107)i(cid:107)k, Yi) = hk then if yi unassigned then return ⊥ return ˆy ← (y1,    , y(cid:96)) procedure Ev( ˆF , ˆX) for i ∈ f|,Non-data,42
|inputs do for g ← fgatestopo do Wi ← Xi a ← ginputs Zm ← gdomain if g is Addm-gate then Wg ←(cid:80)b i=1 Wai else if g is Multc-gate then else if g is Proj gate then ˆτ − H(g, Wa1 ) Wg ← c · Wa1 ˆτ ← τ (Wa1 ) Wg ← ˆGg for i ∈ f|,Non-data,42
|outputs do return ˆY ← (Y1,    , Y(cid:96)) Yi ← Wi Figure 1: Our garbling scheme for mixed moduli simple circuits (g, i, j, X, a, c) = H(g, X + a∆mi ) + c∆mj values (one for each modulus)|,Non-data,42
| We define the following oracle: OH ∆m1 ,,∆mn We assume that the inner addition is mod mi and the outer addition is mod mj|,Non-data,42
| The parameter a is interpreted as a value mod mi and c as a value mod mj We also assume that the inputs and outputs of H can be interpreted as vectors of Zm-elements for appropriate m whenever needed Definition 1 We say that H is mixed-modulus cir- cular correlation robust if for all polynomial time ad- versaries that query their oracle on distinct g values and a (cid:54)= 0, the oracle OH (with ∆mi values chosen uniformly) is indistinguishable from a random function|,Non-data,42
| ∆m1 ,,∆mn As usual, this assumption can be abstracted away if one is willing to use the random oracle model|,Non-data,42
| Theorem 1 The scheme in Figure 1 satisfies the prvsim, obvsim, and aut security definitions (Section 2|,Non-data,42
|1), when the function H is mixed-modulus circular correlation robust (Definition 1) Proof Sketch The proofs follow very closely the secu- rity proof for Free-XOR in [9] and a similar proof in [13] We start out with (F, X, d) generated via (F, e, d) ← Gb(f ) and X ← En(e, x)|,Non-data,42
| The main idea is to first perform a conceptual shift to this hybrid The garbling procedure is normally written from the garbler’s point of view, maintaining the “false” wire labels W for each wire We can instead compute for every wire i in the circuit the value vi that is on that wire when the circuit’s input is x Note that this hybrid still requires knowing the circuit input x — only in later hybrids can we argue that x is not used|,Non-data,42
| Then we can identify for each wire which wire label W ∗ i will be visible to the evaluator Finally, we replace every reference to a wire label W z i + (z − vi)∆m i with W ∗ After this conceptual shift, we see that all garbled gate ciphertexts (and decoding information d) can be written in the following form: H(g, W ∗ i + a∆m) + c∆m(cid:48) + Q where W ∗ i and Q are known to the evaluator (Q is either another visible wire label, or an empty string in the case of the decoding information) Because of the shift to the evaluator’s point of view, whenever a = 0, we also have c = 0|,Non-data,42
| Hence all of these ciphertexts can be computed without the ∆m values, and only oracle access to the mixed-modulus-correlation-robustness oracle of Definition 1 Hence all ciphertexts, apart from the ones where a = 0 above, can be replaced with uniformly chosen values After doing such a replacement, we see that the vi values (the truth values on each wire of the circuit) are no longer 569needed They were used to compute a and c values in the above|,Non-data,42
| The only other place there were used is to determine which cyclic shift of the decoding information d to apply on each output wire But the vi values for output wires are simply the circuit output f (x) Hence, the final result is a simulator that depends only on f (x) For obv|,Non-data,42
|sim security, we simply observe that in the above simulator, f (x) is used only to compute d So when d is not given, the simulator does not require f (x) For aut security, we observe that all other entries in d (apart from the ones obtainable by Ev(F, X)) are chosen uniformly by the simulator Hence, the probability that the evaluator guesses any other output wire label correctly is 1/2λ|,Non-data,42
| 5 SIMPLE IMPROVEMENTS TO GARBLED SYMMETRIC BOOLEAN GATES In the previous section we saw a gadget extending Free- XOR to allow free addition-mod-m for m > 2 (assuming all wires have mod-m labels) Perhaps surprisingly, this turns out to be useful not only for (arithmetic) modular addition, but even for boolean computations For example, consider an AND gate x1 ∧ ··· ∧ xb with fan-in b|,Non-data,42
| We observe that i xi) where χb(n) = 1 if n = b and χb(n) = 0 otherwise1 In the terminology above, we have expressed an AND as a projection of a sum this gate can be expressed as χb((cid:80) If the input wires to this AND gate have mod-(b + 1) wire labels, then the addition is free (and will not wrap around) So the total cost of the AND gate is that of the Zb+1 projection gate, which is b ciphertexts|,Non-data,42
| By comparison, the best-known way to garble a fan-in-b AND gate using existing boolean techniques is to make a tree of b − 1 binary AND gates and use the construction of [21], costing 2 ciphertexts per AND gate for a total of 2b− 2 ciphertexts Thus, our basic building blocks already give a constant size improvement (from 2b − 2 to b) It is also clear that any t-out-of-b threshold gate can be garbled at the same cost (b ciphertexts) by substituting χb for an appropriate projection function Most generally, we can garble at a cost of b ciphertexts any symmetric fan-in-b Boolean gate (a symmetric gate is one whose output depends only on the Hamming weight of its inputs)|,Non-data,42
| While these improvements are already significant, we later show how to do exponentially better for threshold gates in the case of very high fan-in Circumventing a lower bound For b = 2, this gives us a boolean AND gate at a cost of 2 ciphertexts, which matches the half-gates construction of [21] The half-gates construction is compatible with Free- XOR (in our terminology, it uses wire labels that are ∆2- correlated), while ours requires input wire labels to be mod-3 (the output labels in our construction can use any modulus)|,Non-data,42
| Looking more closely at our construction, we express an AND as a projection of a sum As explained above, the nominal cost of the projection is b + 1 ciphertexts, which we reduce to b using the simple row-reduction idea However, as we pointed out, we can further reduce it to b− 1 using the more involved row reduction technique of [18], at the price 1As previously mentioned, this can be viewed as generalizing the representation of fan-in-2 NAND gates in [17] of having both output wire labels constrained, and thus not satisfying the required ∆ correlation|,Non-data,42
| Consider now a single boolean AND gate (thus, correlation of the output wire labels is unimportant) We can garble this AND gate with just a single ciphertext This construction is not very useful in itself, since it does not compose even with itself (although it may give some savings for boolean circuits of a certain structure, that doesn’t require all wires to have a ∆ correlation) However, it is of theoretical interest, since it circumvents a lower bound|,Non-data,42
| Specifically, [21] show not only a 2-ciphertext upper bound for garbled AND gates, but also that the cost of 2 ciphertexts is optimal in a model they define, capturing all previously known garbling schemes The reason our construction is able to circumvent the lower bound is that their model includes the implicit assumption that there is a single color bit per wire label Our construction breaks the bound by using a generalized color digit from Z3 instead of from Z2 This underscores the power of our point-permute generalization, whose main technical difference from Free-XOR is the use of generalized color digits for wire labels|,Non-data,42
| 6 GARBLING ARITHMETIC GATES OVER LARGE MODULI Our basic construction (Figure 1) can in principle be used to represent any boolean circuit However, while it supports free addition mod m, the cost of the non-free projection gates is linear in the modulus m, which is clearly impractical for large values of m We are interested in large values of m both for boolean circuits with massive fan-in (say m ∼ 1000), and even more so for arithmetic circuits (with, e|,Non-data,42
|g, m ∼ 264) Indeed, one of the most natural uses of arithmetic circuits is to carry out computations over the integers, by choosing a modulus that is larger than any intermediate value in the computation In this section we suggest new representations and gadgets that allow for radically more efficient garbling over large moduli|,Non-data,42
| Despite the arithmetic nature of the gadgets, we will show applications for both boolean and arithmetic circuits Rather than choosing a prime modulus, we choose a composite primorial modulus Pk = 2·3··· pk, the product of the first k primes Then values can be represented in terms of smaller moduli Z2 × Z3 × ··· Zpk using the Chinese Remainder Theorem (CRT) Define the residue representation of x as: [[x]]crt := ([x]2, [x]3, |,Non-data,42
|   , [x]pk ) In terms of mixed-modulus circuits, we represent [[x]]crt with a bundle of wires having wire-moduli 2, 3, and so on Bounds on parameter sizes|,Non-data,42
| Suppose we wish to support arithmetic over the integers, and we require a modulus at least as large as some bound Z on the possible intermediate values in the computation We have the following facts from number theory: Lemma 1 Let k be the smallest integer such that(cid:81) k(cid:88) Z (where pi denotes the ith prime) Then, asymptotically: k(cid:88) pk = O(k log k) = Θ(log Z); (cid:100)log2 pi(cid:101) = Θ(log Z)|,Non-data,42
| i≤k pi > k = O(log Z/ log log Z); pi = O(log2 Z/ log log Z); i=1 i=1 570(cid:80)k Concrete example parameters are given below: i=1(cid:100)log2 pi(cid:101) (cid:80)k Z 28 216 232 264 2128 k 5 7 10 16 27 pk 11 17 29 53 103 i=1 pi 28 58 129 381 1264 13 22 37 72 147 Our constructions in this section have cost either O((cid:80) O(log2 Z) or O(k(cid:80) i pi) = O(log3 Z) ciphertexts (each of length λ bits) To represent a single value [[x]]crt requires a bundle of k = O(log Z) wires and hence that many wire labels (each λ bits long) This is comparable to representing the number x in binary for a standard boolean garbled circuit, which would also require log Z wires/labels 6|,Non-data,42
|1 Basic Arithmetic i pi) = Addition & multiplication by a constant To add [[x]]crt and [[y]]crt (modulo the primorial composite), one simply adds their CRT residues component-wise The cost is free in our garbling scheme Similarly, to multiply [[x]]crt by a constant c, one simply multiplies by c within each individual CRT residue|,Non-data,42
| For residues p where c is coprime to p, the operation is free in our garbling scheme For residues where c is not coprime to p, this only happens when c ≡ 0 (mod p) by our choice of prime CRT moduli Hence the result of the multiplication- by-c will be zero (and since c is public, it is known that the result will be zero) For these CRT residues, we instead use a global wire label representing [0]p (this is common to the whole circuit and sent as part of the garbling procedure - independent of the number of gates)|,Non-data,42
| Overall the cost of multiplying by any constant c is free Exponentiation To raise [[x]]crt to the power n (modulo the primorial composite), for a public constant n, it again suffices to do so within each CRT residue This can be done with a simple projection gate φp(x) = [xn]p within each modulus p|,Non-data,42
| The cost of a mod-p projection gate is p − 1 ciphertexts, so the i(pi − 1) ciphertexts For the use case of arithmetic over integers bounded by Z, the cost is O(log2 Z) ciphertexts total cost of exponentiation is (cid:80) This construction works also when the exponent is secret but known only to the circuit garbler This is because our projection gates hide the actual choice of projection function|,Non-data,42
 Remainder mod pi Suppose we wish to transform [[x]]crt into [[x mod pi]]crt for some pi that is among the primes in our CRT representation Note that the value [x]pi already exists within [[x]]crt All that is needed is to “copy” that value to the other residues,Non-data,42
| This is achieved by using an identity projection gate [x]pi (cid:55)→ [x]pj for each other prime pj The cost is pi − 1 ciphertexts for each projection, for a total of (k − 1)(pi − 1) As a special case, when the remainder is mod 2, the total cost is k − 1 ciphertexts General Multiplication|,Non-data,42
| To multiply two (private) values [[x]]crt and [[y]]crt, we again simply multiply their residues component-wise A na ̈ıve way to multiply two values mod p would be to generate a truth table of all p2 combinations, resulting in p2 ciphertexts However, we can take advantage of the fact that each p is prime and instead garble a multiplication with only O(p) ciphertexts (with small constants) For example, Malkin, Pastro & shelat [15] suggest such a way based on a generalization of [21] (who constructed a low-cost multiplication gate over Z2)|,Non-data,42
| Here we suggest the following alternative approach (which let us conveniently scales well with high fan-in) First, blatantly ignore the case where 0 ∈ {x, y} Doing so, we may write x · y = gdlogg (x)+dlogg (y) where g is any primitive root mod p The addition in the exponent is mod p − 1|,Non-data,42
| Hence, our approach for multiplication is to first use a projection gate to map Zp values to their discrete logs (in Zp−1) The cost is p−1 ciphertexts for each input While the discrete logarithm problem is of course difficult in general, we are only asking for a lookup table of discrete logarithms to be precomputed for very small p (eg|,Non-data,42
|, p ≤ 103 for all of our proposed instantiations) The discrete logs can then be added mod p− 1 for free, and finally the result promoted to the final product using a projection gate z (cid:55)→ gz (mod p) The final projection gate uses p−2 ciphertexts, but to handle zeroes we will use a slightly different projection To handle the case where one of the multiplicands may be zero mod p, we write: x · y = 0 gdlogg (x)+dlogg (y) if OR(x = 0, y = 0) else To compute the comparisons x = 0 and y = 0 requires 2p−2 total ciphertexts|,Non-data,42
| We arrange for these comparisons to have output wire with modulus 2 That way, we can compute their OR for only 2 ciphertexts The two dlog projections require 2p − 2 total ciphertexts (cid:40) The final operation is f (z, b) = (cid:40) gz 0 if b = 0 else |,Non-data,42
| We can garble this operation with the standard Yao truth- table approach, using 2(p−1)−1 ciphertexts if we use a row- reduction trick The total cost of the entire multiplication mod p is 6p − 5 ciphertexts For the entire CRT representa- i(6pi − 5) ciphertexts For the use case of arithmetic over integers bounded by tion, the cost of multiplication is(cid:80) Z, the cost is O(log2 Z) ciphertexts|,Non-data,42
| each residue The total cost is(cid:80) In the special case where one of the multiplicands y is a (secret) value known to the garbler, the cost can be reduced The idea is to garble a projection gate [x]p (cid:55)→ [xy]p within i(pi − 1) ciphertexts The asymptotic cost is the same as a general multiplication, but the concrete cost is roughly 6 times better|,Non-data,42
| 57162 Equality Tests & Exact Weighted Threshold To test whether [[x]]crt = [[y]]crt, we observe that [[x]]crt = [[y]]crt ⇐⇒ AND([x − y]p1 = 0,   |,Non-data,42
| , [x − y]pk = 0) The subtractions mod each pi are free We can test whether z ≡ 0 (mod p) using a simple projection gate The cost of such a projection gate is p − 1 ciphertexts|,Non-data,42
| Note that the output of this projection gate can be any modulus, and we choose the output modulus to be k + 1 where k is the number of primes in the CRT representation That way, we can garble the final AND gate using k ciphertexts using the construction described in Section 5 The total cost to garble this equality test is therefore k + i pi ciphertexts However, this assumes an output of a single mod-2 wire|,Non-data,42
| To use the output of the equality test in other gadgets, the output would have to be represented as [[x]]crt — that is, as a bundle of wires with distinct moduli This simply requires an identity projection Z2 → Zpi for each prime pi The cost is 1 ciphertext per projection, bringing the total cost of a composable equality i(pi + 1) ciphertexts, where k is the test to k +(cid:80) i pi =(cid:80) (cid:80) i(pi − 1) =(cid:80) number of CRT moduli For the use case of arithmetic over integers bounded by Z, the cost is O(log2 Z) ciphertexts|,Non-data,42
| Application to exact-weighted-threshold gates An exact weighted threshold gate refers to the following kind of computation: Tht,c1,|,Non-data,42
|,cb (x1,    , xb) = (cid:40) 1 if t =(cid:80) 0 otherwise i cixi For example, an AND gate is an exact weighted threshold, corresponding to the case where c1 = ··· = cb = 1 and t = b and where the xi’s are bits|,Non-data,42
