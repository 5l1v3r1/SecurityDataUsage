 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| test The equality test requires(cid:80) We can garble these kinds of gates efficiently in our scheme when the inputs are in our CRT residue encoding The computation consists of a weighted sum followed by equality i pi ciphertexts When the weights ci are public, the weighted sum is free, so there is no additional cost|,Non-data,42
| must have k primes where (cid:81)k In the case of boolean circuits (where xi’s and ci’s are bits), this construction gives exponential improvements over the state of the art for AND/OR gates To use this construction in a boolean circuit, the inputs must still be CRT-encoded, and the CRT encoding must be spacious enough to not overflow during the addition step The maximum possible sum is equal to the fan-in b, hence we i=1 pi > b Compared to the boolean case, each bit will have k wire labels rather than just one, but the cost of the AND/OR gate will be asymptotically O(log2 b) ciphertexts rather than 2b − 2 ciphertexts (via a tree of binary AND gates)|,Non-data,42
| 63 Comparisons & Weighted Threshold Gates While the CRT representation is effective for arithmetic operations, it does not lend itself to simple comparisons In this section we discuss how to compare [[x]]crt and [[y]]crt Our approach has several steps|,Non-data,42
| Our high-level idea is to convert the CRT representation into a positional number system Specifically, we use a primorial mixed-radix (PMR) system This number system is defined as [[x]]pmr := (dk,  |,Non-data,42
|  , d1) ∈ Zpk ×···× Zp1 , where: (cid:22) (cid:23) di = x p1p2 ··· pi−1 (mod pi) Whereas binary has a 1s-digit, 2s-digit, 4s-digit, 8s-digit, and more generally a 2i-digit, PMR has a 1s-digit, 2s-digit, 6s-digit, 30s-digit, and more generally a(cid:81) j<i pj digit2 Once a number is converted into PMR form, a comparison can be done easily, as we show First steps|,Non-data,42
| (cid:104)(cid:98)x/p(cid:99)(cid:105) , We will first show how to efficiently compute q given [x]p, [x]q and using the operations we have previously discussed (namely, free modular additions and projections) A running example corresponding to p = 3, q = 5 is given in Figure 2 The idea is to consider the function δ(x) = [x]p − [x]q, where we interpret the terms [x]p and [x]q as integers (from {0,  |,Non-data,42
|  , p − 1} and {0,   |,Non-data,42
| , q − 1}, respectively), and the subtraction also over the integers δ has the property that it is piecewise constant, with a constant “run” ending each time x is a multiple of p or of q In Figure 2, the “runs” are shown divided by vertical lines In particular, if (cid:98)x/p(cid:99) (cid:54)= (cid:98)x(cid:48)/p(cid:99), then x and x(cid:48) will be in different “runs” of δ|,Non-data,42
| With p and q relatively prime, there are p + q − 1 runs Furthermore, each run gives a distinct output of δ mod p + q − 1 In other words, if (cid:98)x/p(cid:99) (cid:54)= (cid:98)x(cid:48)/p(cid:99) then δ(x) (cid:54)≡ δ(x(cid:48)) (mod p + q − 1) This implies that we can write (cid:104)(cid:98)x/p(cid:99)(cid:105) = φ q (cid:16)(cid:2)[x]p − [x]q (cid:3) (cid:17) p+q−1 for a suitable projection φ|,Non-data,42
| For the example in Figure 2, we can obtain [(cid:98)x/3(cid:99)]5 as φ([[x]3 − [x]5]7) where φ is the projection 0 (cid:55)→ 0; 1 (cid:55)→ 3; 2 (cid:55)→ 1; 3 (cid:55)→ 3; 4 (cid:55)→ 1; 5 (cid:55)→ 4; 6 (cid:55)→ 2 The cost to compute this in a garbled circuit is the cost of Projφ (p + q − 2 ciphertexts) plus the cost to project [x]p and [x]q to Zp+q−1 (another p + q − 2 ciphertexts) The subtraction mod p+q−1 is free The total cost is 2p+2q−4 ciphertexts|,Non-data,42
| Full conversion Now we show how to use the previous gadget to convert [[x]]crt to [[x]]pmr Define: xi,j := (cid:107)(cid:21) pj x p1 ··· pi To compute [[x]]pmr it suffices to compute xi,i+1 for all i We proceed recursively|,Non-data,42
| In the base case, x0,j = [x]pj , which is given as part of [[x]]crt For the recursive step, we use the identity (cid:98)(cid:98)a/b(cid:99)/c(cid:99) = (cid:98)a/bc(cid:99) and observe that xi,j = x p1 ··· pi = pj x p1···pi−1 pi (cid:34)(cid:22)(cid:4) (cid:5) (cid:23)(cid:35) pj (cid:20)(cid:106) which is just the previous gadget applied to xi−1,i and xi−1,j Inductively, the total cost to obtain [[x]]pmr is the cost to 2In fact, one can obtain the binary number system by setting every pi = 2 (cid:20)(cid:106) (cid:107)(cid:21) 572x [x]3 [x]5 [x]3 − [x]5 [[x]3 − [x]5]7 [(cid:98)x/3(cid:99)]5 0 0 0 0 0 0 1 1 1 0 0 0 2 2 2 0 0 0 3 0 3 -3 4 1 4 1 4 -3 4 1 5 2 0 2 2 1 6 0 1 -1 6 2 7 1 2 -1 6 2 8 2 3 -1 6 2 9 0 4 -4 3 3 10 1 0 1 1 3 11 2 1 1 1 3 12 0 2 -2 5 4 13 1 3 -2 5 4 14 2 4 -2 5 4 Figure 2: An example of the gadget computing [(cid:98)x/p(cid:99)]q|,Non-data,42
| apply the gadget for all pairs pi, pj with i < j: (2pi + 2pj + 4) = 2(k − 1) pi + 4 (cid:88) 1≤i<j≤k k(cid:88) i=1 (cid:33) (cid:32) k 2 Comparing values via PMR representation Suppose we wish to determine whether [[x]]crt < [[y]]crt (note the CRT representation, not PMR) This is equivalent to the comparison [[x − y]]crt < 0 Suppose our CRT representation uses one more prime modulus than is necessary|,Non-data,42
| Then by assumption, all intermediate values in the circuit are at most p1 ··· pk−1 in absolute value Then if x − y is positive, the most significant digit of [[x − y]]pmr will be zero If x − y is negative, the sum will wrap around mod p1 ··· pk and be a number larger than p1 ··· pk−1 Hence the most significant digit of [[x − y]]pmr will be nonzero|,Non-data,42
| Hence, to compare [[x]]crt to [[y]]crt, we obtain [[x − y]]crt for free, convert to [[x−y]]pmr at the above cost, then do a simple projection on the most significant digit of [[x− y]]pmr, costing pk ciphertexts If we desire to have the result of the comparison as a CRT-encoded wire bundle, an additional k ciphertexts are required, as was the case for exact thresholds Overall, the total cost will be k(cid:88) 2(k − 1) pi + 2k2 − k + pk i=1 For the use case of arithmetic over integers bounded by Z, the cost of a comparison is O(log3 Z) ciphertexts Application to weighted threshold gates|,Non-data,42
| A weighted threshold gate refers to the following kind of computation: Tht,c1,,cb (x1, |,Non-data,42
|   , xb) = (cid:40) 1 if t >(cid:80) 0 otherwise i cixi Since a weighted threshold gate is simply a weighted sum followed by a comparison, the cost of such a threshold gate is simply the cost of a comparison as described above The weighted sum is free if the weights are public|,Non-data,42
| 7 USING OUR SCHEME AND COMPARI- SON TO STANDARD GARBLING We have now introduced all of the low-level gates that are supported compactly by our garbling scheme In this section we discuss the costs involved when using our scheme in the context of a secure computation protocol In particular, we focus on the “hidden” costs involved in: (1) transferring garbled inputs via oblivious transfers (2) ensuring that all of our low-level gate gadgets interoperate within a common circuit|,Non-data,42
| We discuss these costs in the context of a natural application scenario, and provide a comprehensive comparison of our scheme to standard state- of-the-art garbling techniques Our focus is on the communication costs: size (number of ciphertexts) of the garbled circuits, and costs of OTs With the use of hardware-accelerated AES instructions, current 2PC applications of garbled circuits are usually network- bound,3 so communication cost reflects the dominant bot- tleneck 7|,Non-data,42
|1 Transferring Wire Labels via OT In Yao’s protocol paradigm, the circuit evaluator obtains her garbled input via oblivious transfer (OT) For boolean circuits, there are two possible wire labels per input wire, and 1-out-of-2 OT is the natural way for the evaluator to obtain the one wire label of her choice on each wire In practice, OT instances are realized via OT extension protocols [4, 12] The main idea behind OT extension is that after performing only λ so-called base OTs on random strings, the parties can obtain a large number N (cid:29) λ of effective OTs using only cheap symmetric-key operations|,Non-data,42
| Only the base OTs require expensive public-key operations When discussing the cost of OT, we ignore the fixed cost of the base OTs The marginal cost incurred by each 1-out-of-2 OT instance (for OT of λ-bit messages) is 2λ bits However, when using OT to transfer wire labels in particular, it is possible to use an optimization similar to row-reduction for garbled circuits|,Non-data,42
| One can allow the OT protocol itself to randomly choose one of the two possible wire labels This reduces the marginal cost of each OT to just λ bits (cf [3]) In our scheme, we consider circuits whose wires carry values in Zp for some prime p|,Non-data,42
| There are p possible wire labels for each such wire When these wires are the input wires of a circuit, we must provide a way for the receiver to obtain appropriate garbled input The naive way to do this is using 1-out-of-p OTs, at the cost of (p − 1)λ bits However, we suggest the following superior approach which takes advantage of the specific form of the strings|,Non-data,42
| (cid:100)log p(cid:101) and write w in binary as w =(cid:80)(cid:96)−1 computation w = (cid:80)(cid:96)−1 Consider a mod-p input wire w to the circuit Set (cid:96) = j=0 wj2j Our idea is to use (cid:96) 1-out-of-2 OTs to obtain garbled inputs encoding the bits of w While these wj inputs are bits, we require them to be represented as mod-p wire labels|,Non-data,42
| Then the j=0 wj2j can be done for free within the circuit, as the values 2j are public We note that the free addition will be mod p, but by construction the result of the weighted sum is w < p 3As a concrete example, the garbling scheme of Zahur et al [21] reduced garbled circuit size by 33% but doubled the number of AES calls for the evaluator (compared to prior work)|,Non-data,42
| The changes were still a significant net improvement 573The total cost of these OTs (using the OT-row-reduction optimization described above) is only (cid:96) ciphertexts For an input value [[x]]crt represented by k primes, the total cost of all OTs under this method is(cid:80) i(cid:100)log pi(cid:101) Consider the setting of garbling an arithmetic circuit using CRT representations with k primes, where(cid:81) 7|,Non-data,42
2 Arithmetic Circuits involving operations over the integers Let (cid:98) Z−1 upper bound on the absolute value of intermediate values within the circuit Then our scheme should be instantiated i≤k pk > Z to avoid any wrap-arounds We make a distinction between the logical values of the arithmetic circuit (i,Non-data,42
|e, values in {−(cid:98) Z−1 (encoding) values in our mixed-modulus simple circuit (ie, values mod p for some prime p)|,Non-data,42
| 2 (cid:99)}) and the physical 2 (cid:99),−Z + 1,    ,(cid:98) Z−1 2 (cid:99) be an In Figure 3 we summarize the cost of various arithmetic including concrete costs for Z ∈ gates in our scheme, {216, 232, 264}|,Non-data,42
| The numbers in the table reflect gates whose (logical) input and output wires are all [[x]]crt bundles (eg, not just single boolean wires in the case of comparisons) A single logical value in the circuit is encoded by k = O(log Z/ log log Z) wire labels|,Non-data,42
| The total OT cost for a logical circuit input is(cid:80) i(cid:100)log pi(cid:101) = O(log Z) The figure also includes a comparison to the “standard boolean garbled circuit” approach To obtain these numbers, we consider directly converting the arithmetic circuit into a boolean circuit, and representing its logical values as binary integers of length log Z bits In particular, this means that the outputs of the multiplication/exponentiation gates, not the inputs, are taken to be log Z bits long|,Non-data,42
| To generate optimized boolean subcircuits for these operations, we first used Cryptol [10] to convert the input/output specification into an unoptimized circuit We then used the ABC [8] and Yosys [19] circuit synthesis tools to create an optimized Verilog sequential circuit Yosys was configured to treat XOR and NOT gates as free and otherwise minimize the circuit The numbers in the table reflect the cost to garble each such subcircuit using the state-of-the art half-gates garbling scheme [21]|,Non-data,42
| For multiplication- and exponentiation-by-constant, we chose arbitrary constants to obtain the subcircuits We see that, with the exception of comparison gates, our scheme results in less cost in almost all dimensions Both the size of the garbled circuit and the memory requirement (to store garbled values) are smaller in our construction The cost of OTs is slightly higher (12-37%)|,Non-data,42
| Additionally, we emphasize that linear operations (addition and multiplication by a constant) are free in our scheme 73 Boolean Circuits with High Fan-In Gates Our construction also gives improvements for Boolean circuits, specifically when gates have high fan in In this setting, we consider Boolean circuits consisting of AND, OR, XOR, and threshold gates|,Non-data,42
| Let b be an upper bound on the fan-in of any non-XOR gate in a circuit representation with k primes, where Pk := (cid:81) Our approach is to encode boolean values in a CRT i≤k pi > b This suffices for us to use the boolean AND/OR and threshold gates described in Sections 62 & 6|,Non-data,42
|3 The costs are summarized in Figure 4, and they reflect composable gates whose logical outputs are also in the CRT representation i xi]]crt (cid:55)→ [[(cid:80) the transformation [[(cid:80) single bits is that we no longer have XOR for free Rather, we have addition mod Pk for free|,Non-data,42
| However, since 2 || Pk, the cost of XOR is indeed low To compute the XOR of values x1,   |,Non-data,42
| , xn, we add them mod Pk (for free), and then perform i xi mod 2]]crt using the method in 61 The total cost of the final transformation is k − 1 ciphertexts, regardless of the fan-in of this XOR gate As above, the figure also contains a comparison to the standard boolean garbled circuit paradigm|,Non-data,42
| The correspond- ing numbers reflect the cost of garbling the best available boolean circuit using the half-gates construction The numbers for threshold gates are for a majority gate (whereas the numbers for our scheme are for any threshold gate) For circuits of this kind, our cost for OTs and for XOR gates is certainly higher However, our exponential improvement for AND/OR/threshold gates is striking even for the modest values of fan-in that we consider|,Non-data,42
| 74 Application Scenario compute the inner product(cid:80) We now focus our comparison to a specific application Suppose Alice and Bob have private vectors (a1,  |,Non-data,42
|  , an) and (b1,   |,Non-data,42
| , bn), respectively, and they would like to privately i aibi, in the presence of semi- honest adversaries (ie, using Yao’s protocol) The entries of these vectors are 32-bit nonnegative integers (for example, these matrices could be a 32-bit fixed-point representation of real numbers), and so the inner product may contain 64-bit values|,Non-data,42
| Such a computation is representative of a natural class of elementary linear-algebraic computations — for example, a matrix multiplication consists of many such inner products i≤k pi > 264 (cid:81) multiplication gate is (cid:80)16 The computation consists of (1) an OT, (2) a multiplica- tion gate, and (3) an addition gate, for each component of the parties’ input vectors (of course there are n multiplica- tions and n − 1 additions, but we assume n is large enough that the difference of 1 addition is insignificant) • Using our scheme, the parties would choose a CRT encoding large enough to avoid overflow — i|,Non-data,42
|e, so that In this case, k = 16 Alice can garble the simple arithmetic circuit using the approach outlined in Section 61|,Non-data,42
| Since Alice knows one argument of each of the multiplication gates, the cost to garble each i=1(pi − 1) = 365 ciphertexts Additions are free, and the cost of OT per input element is 74 ciphertexts • Using the standard boolean approach, the parties must generate a boolean circuit that expresses the arith- metic computation For each component of the vectors, the circuit includes a 32-bit × 32-bit multiplication and 64-bit addition circuit|,Non-data,42
| Using Figure 3, we see that the cost of an addition subcircuit is 126 ciphertexts, and the cost of a multiplication-by-constant is at least 3744 ciphertexts Note that in the desired functionality, the garbled circuit must hide Alice’s argument to the multiplication gate, so it is perhaps rather optimistic to use the cost of a multiplication-by-constant gate in our calculation The OT cost per input element is 32 ciphertexts Overall, our total protocol cost per vector-component is 365 + 74 = 439 ciphertexts compared to 3744 + 126 + 32 = 3902 for the boolean case — an improvement of 88%|,Non-data,42
| A side-effect of using a CRT representation to encode This simple example demonstrates that our construction 574fan-in-2 addition gate multiplication-by-constant gate exponentiation-by-constant gate fan-in-2 multiplication gate comparison gate OT cost per input integer value total wire label size per integer value scheme asymptotic cost concrete cost Z = 216 Z = 232 Z = 264 us standard us standard us standard us standard us standard us standard us standard 0 log Z 0 log1585 Z log2 Z/ log log Z log2 Z log2 Z/ log log Z log1585 Z log3 Z/ log log Z log Z log Z log Z log Z/ log log Z log Z 0 30 0 232 51 44 313 330 804 32 22 16 7 16 0 62 0 758 119 1864 724 1200 2541 64 37 32 10 32 0 126 0 3744 365 8496 2206 4494 11979 128 72 64 16 64 Figure 3: Cost of various operations garbling an arithmetic circuit, where (cid:98) Z−1 magnitude of any intermediate value in the computation Costs are in # of ciphertexts (multiples of λ bits)|,Non-data,42
 “Standard” scheme refers to encoding values in binary and using the half-gates garbling scheme [21] on the best available boolean circuit 2 (cid:99) is an upper bound on the scheme asymptotic cost concrete cost b = 10 b = 100 b = 1000 arbitrary fan-in XOR gate fan-in-≤ b AND/OR gate fan-in-≤ b threshold/majority gate OT cost per input bit total wire label size per logical bit us standard us standard us standard us standard us standard log b 0 log2 b/ log log b b log3 b/ log log b b log b log b 1 log b/ log log b 1 2 0 13 18 60 36 6 1 3 1 3 0 21 198 137 948 9 1 4 1 4 0 33 1998 280 30082 13 1 5 1 Figure 4: Cost of various operations garbling a boolean circuit consisting of high fan-in gates b is an upper bound on the fan-in of any AND/OR/threshold gate in the circuit Costs are in # of ciphertexts (multiples of λ bits),Non-data,42
| “Standard” scheme refers to using the half-gates garbling scheme [21] on the best available boolean circuit provides significant concrete improvement for secure com- putations of arithmetic operations In larger and more realistic computations each input values is likely to be used many times, so the cost of the garbled circuit itself easily dominates the cost of the OTs We note that our garbled circuit cost in this example is 365 vs 3744 + 12 = 3870, a factor 10 difference|,Non-data,42
| This example used the fact that Alice knew one of the inputs to every multiplication gate Even when that is not the case, our construction is more efficient by a non-trivial factor 8 COMPARISON TO OTHER SECURE COM- PUTATION TECHNIQUES Above we have extensively compared our scheme with the state of the art for standard garbling of boolean circuits, and its application to arithmetic circuits (when those are first converted to boolean)|,Non-data,42
| In this section we compare our results to other approaches to 2PC (the most natural application of garbled circuits) and other relevant work on garbled circuits & randomized encodings Secret-sharing-based 2PC A completely different paradigm for 2PC uses secret sharing, and natively supports addition and multiplication operations over a prime modulus In this paradigm, addition is free and (depending on the required security) multiplica- tion can be performed by exchanging a constant number of GF (p)-elements|,Non-data,42
| Garbled-circuit-based and secret-sharing-based 2PC are fundamentally different, so direct comparisons are difficult We simply point out the similarities and differences Cer- tainly secret-sharing-based 2PC is and will likely always be better for some cases Our focus here is on improving the garbled circuit paradigm for computations that are currently expensive/cumbersome in that paradigm, thus significantly closing the gap with secret-sharing-based 2PC in these cases|,Non-data,42
| Our scheme allows addition for free, just as in secret- sharing protocols We require a particular type of modulus which makes our scheme likely only useful for computations over the integers (where any modulus large enough to prevent overflows works), whereas secret-sharing can use any prime modulus Our other non-free operations are 575certainly more expensive than in a secret-sharing protocol, but we highlight that the garbled circuit paradigm results in a constant-round protocol while multiplications require interaction in a secret-sharing protocol Hence, our work can be thought of combining some of the best features of both worlds for arithmetic computations (free addi- tion, but constant-round, easily mixing boolean/arithmetic paradigms)|,Non-data,42
| Garbled Arithmetic Circuits & Arithmetic Model Like us, Applebaum, Ishai, and Kushilevitz [2] also de- scribe a scheme for directly garbling arithmetic circuits over the integers, and like us, their scheme supports additions for free Their construction requires a particular assumption, namely LWE over the integers, whereas our construction uses a simpler correlation-robust hash function assumption As a practical consequence, our scheme can be instantiated using concrete primitives like AES to give much lower overhead (than LWE) in the constant factors and also to take advantage of hardware-accelerated AES that has already been extremely successful for traditional garbled circuits|,Non-data,42
| We also point out that our scheme uses the conventional paradigm for garbled circuits, making our scheme easier to integrate into existing systems, and combine with other gar- bling schemes (eg, garble part of a computation using our scheme, and other parts using standard boolean garbling) Finally, we note that [2] also outline a construction for garbling arithmetic circuits based on one-way functions, and relying on CRT encoding|,Non-data,42
| The CRT encoding use as a technical tool is thus similar in our construction and the one they outline However, their construction uses the CRT encoding simply to get the integer input into more efficient eventual bit-wise representation (with bit- wise representation of the input modulo each of the CRT components); after this, standard boolean garbled circuit techniques (eg, Yao) are applied|,Non-data,42
| As a result, that scheme is more efficient than directly transforming the circuit from arithmetic to boolean, but less efficient than either their main LWE construction or our constructions here Applebaum, Avron & Brzuska [1] define an arithmetic model for cryptography, in which primitives work by ma- nipulating field elements in a black-box way In this work they prove some lower bounds related to garbled circuits & randomized encodings While our construction takes advantage of certain algebraic structures, it does not fall within this arithmetic model|,Non-data,42
| An important feature of the arithmetic model is that the construction is oblivious to the choice of underlying field, whereas we rely on specific choices of the underlying algebraic structure Furthermore, their model focuses on information-theoretic constructions, or at least constructions that can be constructed in a black-box way from an arbitrary field This does not capture our use of generic cryptographic assumptions like correlation-robust hash functions Fully Homomorphic Encryption|,Non-data,42
| Fully homomorphic encryption can be used for secure computation in a natural way One party sends an en- cryption of his input E(x), while the other party uses the homomorphic properties to compute E(f (x, y)) (here we assume semi-honest parties) While we cannot compete with such a protocol in terms of its asymptotically optimal communication overhead, our construction requires only symmetric-key operations and has small concrete constants Other Related Work|,Non-data,42
| We mention the recent work of Malkin, Pastro & she- lat [15], which bears some similarities with our work in terms of high level themes explored, though the goals and directions they take and the concrete results obtained are quite different from ours First, as we already pointed out, they also use the free- XOR generalization to a larger modulus, yielding the same basic (free) addition as us However, their multiplication is linear in the modulus size, and thus they can only apply this to small fields (they suggest fields of size up to 27) In contrast, we can handle moduli that are orders of magnitude larger, with CRT based polylogarithmic multiplication (and other gadgets)|,Non-data,42
| In fact, garbling arithmetic gates is only a small part of their work, and their main focus is boolean circuits There, similarly to us, they consider direct garbling of more complex gates, with higher fan-in, rather than the standard fan-in 2 gates Specifically, they provide a garbling scheme for gates computing low-degree polynomials with many terms However, their scheme does not yield any improvement when applied to the type of boolean gadgets that we consider here, e|,Non-data,42
|g, a high fan-in AND gate On the technical level, they do not use their generalized free- XOR technique in the boolean domain (it’s only used for an arithmetic circuits over the given field) In contrast, for us, the free-XOR generalization is a major insight we use in obtaining improvements in the boolean domain|,Non-data,42
| It would be interesting to explore whether a combination of their techniques and ours can yield even more significant improvements for specific, useful circuits Finally, they bypass the [21] lower bound of 2 ciphertexts per AND gate, by directly garbling a composition of several binary gates together, while [21] only consider a gate-by- gate garbling model (for binary gates) We bypass the lower bound in a very different way, breaking it even for a single binary AND gate As explained above, we do so by exposing an implicit assumption embedded in the model of [21], namely that there’s a single color bit|,Non-data,42
| 9 CONCLUSIONS We have introduced new techniques for garbled circuits, based on a generalization of Free-XOR that yields free addition mod m Starting with rather simple building blocks, we show how to construct gadgets for garbling boolean and arithmetic gates with significantly lower cost (both asymptotically and concretely) than state-of-the- art garbling techniques In particular, we can garble arithmetic circuits over the integers with free addition and multiplication by a constant, and we can garble boolean circuits of high fan-in exponentially better than standard techniques|,Non-data,42
| Acknowledgements We are grateful to Brent Carmer for help synthesizing the boolean circuits considered in Figures 3 and 4 This work was initiated while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collabo- 576[12] Ishai, Y, Kilian, J, Nissim, K|,Non-data,42
|, and Petrank, E Extending oblivious transfers efficiently In CRYPTO 2003 (Aug 2003), D|,Non-data,42
| Boneh, Ed, vol 2729 of LNCS, Springer, Heidelberg, pp 145–161|,Non-data,42
| [13] Kolesnikov, V, Mohassel, P, and Rosulek, M FleXOR: Flexible garbling for XOR gates that beats free-XOR|,Non-data,42
| In CRYPTO 2014, Part II (Aug 2014), J A Garay and R|,Non-data,42
| Gennaro, Eds, vol 8617 of LNCS, Springer, Heidelberg, pp 440–457|,Non-data,42
| [14] Kolesnikov, V, and Schneider, T Improved garbled circuit: Free xor gates and applications In Automata, Languages and Programming|,Non-data,42
| Springer, 2008, pp 486–498 [15] Malkin, T, Pastro, V|,Non-data,42
|, and shelat, a An algebraic approach to garbling Unpublished manuscript See https: //simons|,Non-data,42
|berkeleyedu/talks/tal-malkin-2015-06-10, 2016 [16] Naor, M, Pinkas, B|,Non-data,42
|, and Sumner, R Privacy preserving auctions and mechanism design In Proceedings of the 1st ACM conference on Electronic commerce (1999), ACM, pp 129–139|,Non-data,42
| [17] Nielsen, J B, and Orlandi, C LEGO for two-party secure computation|,Non-data,42
| In TCC 2009 (Mar 2009), O Reingold, Ed, vol|,Non-data,42
| 5444 of LNCS, Springer, Heidelberg, pp 368–386 [18] Pinkas, B, Schneider, T|,Non-data,42
|, Smart, N P, and Williams, S C|,Non-data,42
| Secure two-party computation is practical In ASIACRYPT 2009 (Dec 2009), M Matsui, Ed|,Non-data,42
|, vol 5912 of LNCS, Springer, Heidelberg, pp 250–267 [19] Wolf, C|,Non-data,42
 Yosys open synthesis suite http://wwwcliffordat/yosys/,Non-data,42
| [20] Yao, A C-C How to generate and exchange secrets (extended abstract)|,Non-data,42
| In 27th FOCS (Oct 1986), IEEE Computer Society Press, pp 162–167 [21] Zahur, S|,Non-data,42
|, Rosulek, M, and Evans, D Two halves make a whole - reducing data transfer in garbled circuits using half gates In EUROCRYPT 2015, Part II (Apr|,Non-data,42
| 2015), E Oswald and M Fischlin, Eds, vol|,Non-data,42
| 9057 of LNCS, Springer, Heidelberg, pp 220–250 ration in Cryptography through NSF grant #CNS-1523467 The first two authors are supported in part by the Defense Advanced Research Project Agency (DARPA) and Army Research Office (ARO) under Contract #W911NF-15-C- 0236, and NSF grants #CNS-1445424 and #CCF-1423306|,Non-data,42
| Part of the work was done while the first author was visiting IDC Herzliya’s FACT center and supported by NSF-BSF Cyber Security and Privacy grant #2014/632 The third author is supported by NSF award #1149647 Any opinions, findings, and conclusions or recommendations expressed are those of the authors and do not necessarily reflect the views of the Defense Advanced Research Projects Agency, Army Research Office, the National Science Foundation, or the US|,Non-data,42
|ABSTRACT Authenticated encryption schemes guarantee both privacy and integrity, and have become the default level of encryp- tion in modern protocols One of the most popular au- thenticated encryption schemes today is AES-GCM due to its impressive speed The current CAESAR competition is considering new modes for authenticated encryption that will improve on existing methods One property of impor- tance that is being considered more today – due to multiple real-life cases of faulty sources of randomness – is that re- peating nonces and IVs can have disastrous effects on secu- rity|,Non-data,43
| A (full) nonce misuse-resistant authenticated encryp- tion scheme has the property that if the same nonce is used to encrypt the same message twice, then the same cipher- text is obtained and so the fact that the same message was encrypted is detected Otherwise, full security is obtained – even if the same nonce is used for different messages In this paper, we present a new fully nonce misuse-resistant authenticated encryption scheme that is based on carefully combining the GCM building blocks into the SIV paradigm of Rogaway and Shrimpton We provide a full proof of secu- rity of our scheme, and an optimized implementation using the AES-NI and PCLMULQDQ instruction sets|,Non-data,43
| We com- pare our performance to the highly optimized OpenSSL 102 implementation of GCM and show that our nonce misuse- resistant scheme is only 14% slower on Haswell architecture and 19% slower on Broadwell architecture On Broadwell, GCM-SIV encryption takes only 0|,Non-data,43
|92 cycles per byte, and GCM-SIV decryption is exactly the same as GCM decryp- tion taking only 077 cycles per byte In addition, we com- pare to other optimized authenticated-encryption implemen- tations carried out by Bogdanov et al, and conclude that our mode is very competitive|,Non-data,43
| Beyond being very fast, our new ∗ Supported by the PQCRYPTO project, which was partially funded by the European Commission Horizon 2020 Research Programme, grant #645622 † Supported by the BIU Center for Research in Applied Cryptography and Cyber Security in conjunction with the Israel National Cyber Bureau in the Prime Minster’s Office Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page Copyrights for components of this work owned by others than ACM must be honored|,Non-data,43
| Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from Permissions@acmorg|,Non-data,43
| CCS’15, October 12–16, 2015, Denver, Colorado, USA c(cid:13) 2015 ACM ISBN 978-1-4503-3832-5/15/10 |,Non-data,43
$1500 DOI: http://dx,Non-data,43
doiorg/101145/28101032813613,Non-data,43
| mode of operation uses the same building blocks as GCM and so existing hardware and software can be utilized to eas- ily deploy GCM-SIV We conclude that GCM-SIV is a viable alternative to GCM, providing full nonce misuse-resistance at little cost 1 INTRODUCTION Authenticated encryption|,Non-data,43
| A symmetric encryption scheme achieves authenticated encryption if it provides both privacy and integrity Informally, such a scheme provides the guarantee that no adversary can generate a ciphertext that decrypts to a valid value, and that encryptions of plain- texts are indistinguishable from each other Classically, au- thenticated encryption was achieved via the “encrypt-then- authenticate” paradigm that states that one should first en- crypt and then apply a message authentication code to the obtained ciphertext [5, 13] This methodology is sound, but is often inefficient|,Non-data,43
| A more general study of composition methods, considering multiple different options and secu- rity goals, was carried out in [18] However, in many cases, dedicated modes of encryption have been proposed that are optimized for high performance One of the most popular such modes used today is GCM, and it has very fast per- formance on the latest Intel architectures For example, it achieves performance of 0|,Non-data,43
|77 cycles per byte (C/B hereafter) on the architecture codename Broadwell1 Many authenti- cated encryption modes have been proposed, and the CAE- SAR competition currently being run is considering some of them IV and nonce misuse resistance For a long time, au- thenticated encryption was considered the highest level of security for symmetric encryption schemes|,Non-data,43
| Indeed, with re- spect to adversarial capabilities, this is the case However, it has been observed that in many cases, something can go wrong in the encryption procedure For example, when ran- dom IVs are needed and encryption is carried out on devices with weak randomness (like mobile phones), the IV may re- peat with high probability This same problem arises on strong devices, where the random source is buggy|,Non-data,43
| Likewise, in nonce-based encryption schemes (where the requirement is just that a unique nonce is used every time), the repetition 1 Broadwell (and similarly Haswell) is an Intel Architecture Codename of a very recently announced micro-architecture Broadwell is the 5th Generation Intel R(cid:13) Core(cid:32)l Processor, and Haswell is the 4th Generation Intel R(cid:13) CoreTM Processor They can have different configurations in different products Hereafter, for short, we refer to them simply as Broadwell and Haswell (or BDW/HSW)|,Non-data,43
| 109of a nonce happens in practice and compromises security2 In order to see why repeating IVs or nonces can have disas- trous results, consider the case that the counter is repeated in counter-mode encryption In this case, all security is lost (an attacker can easily detect that this is the case, and can just XOR the ciphertexts in order to obtain the XOR of the plaintexts) In another example, in GCM encryption, if the initial counter is repeated, then this also completely compro- mises the integrity property and an attacker who views the two encryptions can generate as many forgeries as it wishes in the future|,Non-data,43
| These observations prompted Rogaway and Shrimpton in a breakthrough work to define the notion of nonce misuse- resistant authenticated encryption [20] An encryption scheme with this property provides an extraordinarily high level of security If the same nonce is used to encrypt the same mes- sage, then this will be detected by the adversary (since the same output will be obtained both times) Otherwise, full security will be obtained|,Non-data,43
| This means that encrypting differ- ent messages with the same nonce will reveal nothing what- soever (except for the fact that the messages were different) Such an encryption scheme can be used comfortably in sce- narios where devices cannot be trusted to generate good quality randomness Indeed, it is advisable to always use misuse resistant encryption, since low quality randomness has shown up multiple times due to software bugs Unfor- tunately, nonce misuse-resistant authenticated encryption is inherently less efficient since it requires two passes over the data|,Non-data,43
| We remark that a weaker notion of nonce misuse-resistance has been proposed, where some more information is allowed to be revealed in the case of a nonce repeating Specifically, if a nonce repeats between two messages that have a com- mon prefix, then this fact is revealed, along with the length of the common prefix [6] This definition allows for achiev- ing support for online encryption, where the encryptor does not need to hold the entire plaintext at any time (this is im- possible to achieve under the more stringent notion of [20]) In this paper, we adopt the stronger notion|,Non-data,43
| In this paper, we present a new fast Our contributions mode of encryption that achieves nonce misuse-resistant au- thenticated encryption Our mode of encryption is based on the GCM mode of encryption, and a careful combination of the building blocks used in GCM together with the SIV construction paradigm of [20]; we call this mode GCM-SIV Our mode of operation works by first applying GHASH (the GCM authenticator) to the plaintext and any associated au- thenticated data, and then applying a pseudorandom func- tion to the result XORed with the IV|,Non-data,43
| We show that this is a pseudorandom function over the nonce, plaintext and associated data, and thus the result can be used as the IV in CTR mode Therefore, this is a highly efficient instanti- ation of the IV misuse resistance mode proven in [20] (and further abstracted in [18]) Beyond a full specification of the scheme and proof of se- curity, we provide optimized implementations of GCM-SIV and compare their performance to GCM on the Haswell and Broadwell Intel architectures We compare our performance to the highly optimized OpenSSL (v|,Non-data,43
|102) implementation of GCM on the same architectures, and provide exact cycle 2 In this paper, we refer to IVs as values that must be randomly chosen, whereas nonces must simply be non repeating counts|,Non-data,43
| (We argue that such a detailed study is essential to truly understand the efficiency of new modes of encryption) The advantages of our construction are: 1 Ease of deployment: Our construction uses the same building blocks as GCM Therefore, existing code bases (and hardware implementations) can be used to imple- ment GCM-SIV|,Non-data,43
| This is an important consideration when adopting new modes of operation In addition, our construction only uses AES encryption (and not its inverse) 2 Encryption performance on Intel architectures: Encryption under GCM-SIV is not far from the per- formance of GCM|,Non-data,43
| For encryption, GCM-SIV is only 14% (resp, 19%) slower than GCM on Haswell (resp, Broadwell) This difference is due to the fact that us- ing the Intel AES-NI and PCLMULQDQ instructions, the GHASH and AES operations can be run in parallel in GCM, but must be computed one after the other in GCM-SIV|,Non-data,43
| Concretely, our implementation runs at 117 cycles per byte on the Haswell architecture, and 092 cycles per byte on the recent Broadwell architecture Thus, we obtain full nonce misuse-resistance on the latest Intel architecture with encryption costing less than one cycle per byte! 3|,Non-data,43
| Encryption performance on other architectures: GCM-SIV is fast on every architecture that has sup- port for AES-NI and carry-less multiplication, in some form The current trend is that such support is offered on most (if not all) the new 64-bit architectures Some examples are AMD (Bulldozer) and NVidia (Denver), ARM little core (A53) and big core (A57), and Apple (A7/A8) With this ubiquitous support, AES-GCM (and hence our GCM-SIV) would enjoy the best per- formance on most modern platforms|,Non-data,43
| We remark that on architectures where AES-NI is not available (and a single thread is used), the cost of GCM-SIV is the same as GCM alone This is due to the fact that the operations carried out in GCM- SIV are almost identical to that of GCM, and on such architectures the computation of GCM cannot be par- allelized with a single thread 4 Decryption performance: Decryption of GCM-SIV has the exact same cost as decryption of GCM|,Non-data,43
 This is due to the fact that they have the same operations and in decryption they can both be parallelized Both achieve rates of 077 cycles per byte on Broadwell 5,Non-data,43
| Encryption of short messages: For short messages (up to 32 bytes), GCM-SIV is actually more efficient than GCM Thus, it is preferable for key wrapping and in settings were many short messages are sent In summary, GCM-SIV achieves full nonce misuse-resistant authenticated encryption at an extremely low cost It has a proof of security, and a full implementation to validate its true cost|,Non-data,43
| Finally, it is easily deployable due to existing hardware support on a wide range of processors 110Comparison to other full nonce-misuse resistant schemes We compare GCM-SIV to other schemes that provide the same level of nonce-misuse resistance Clearly, GCM-SIV is much faster than the original SIV of [20] since it uses CMAC which is not parallelizable|,Non-data,43
| Therefore, on a platform using AES-NI, the performance is dominated by the latency of the AES-NI (7 cycles on Broadwell/Haswell), and is 444 cycles per byte Therefore, the performance of the original SIV scheme would be at least 5 cycles per byte on Broadwell/Haswell The HBS and BTM modes of operation [14, 15] have a similar theoretical complexity to our implementation|,Non-data,43
| How- ever, our scheme is far simpler, on small messages our mode is faster, and importantly we can reuse GCM software and hardware which are already widely deployed Finally, we have a fully optimized implementation to validate our claims of efficiency, whereas we are not aware of such results for HBS and BTM Of the CAESAR competition candidates, the only three that achieve full nonce misuse-resistance are AEZ [12], Julius [2] and HS1-SIV [16]; see also [1] On Broadwell, AEZ can achieve (for long messages) a throughput of 0|,Non-data,43
|7 C/B [12] This relative performance advantage of AEZ over GCM-SIV exists for encryption only, and not decryption In addition, AEZ meets a slightly stronger form of security, called robust authenticated encryption However, this comes at the cost of relying on a nonstandard security assumption; specifically, AEZ internally uses AES with just 4 rounds and so is not a full block cipher operation|,Non-data,43
| Julius (ECB/CTR) requires 1 AES computation plus 2 field multiplications per block An optimized software implementation of Julius using the AES-NI instruction set was carried out by [3] as discussed below As can be seen in Table 1, it is significantly slower than GCM-SIV HS1-SIV takes a different approach, and is targeted at achieving good performance on platforms that do not have the AES-NI/PCLMULQDQ instructions (e|,Non-data,43
|g, embedded sys- tems) ChaCha20/Poly1305 is another authenticated en- cryption scheme that targets performance on CPUs that have no AES-NI/PCLMULQDQ It is gaining popularity on small-device client platforms|,Non-data,43
| However, on platforms with AES-NI/PCLMULQDQ (eg, servers that service such con- nections and the latest mobile devices that do have strong CPUs with these instructions), ChaCha20/Poly1305 (stream cipher and authenticator) is outperformed by GCM-SIV (and AES-GCM) due to the dedicated hardware support Opti- mized ChaCha20 (i|,Non-data,43
|e, encryption alone) consumes approx- imately 104 cycles per byte on Broadwell, and the fastest Poly1305 implementations we are aware of performs at 067/ 0|,Non-data,43
|66 C/B on HSW/BDWThis is significantly slower than GCM-SIV on these platforms In addition to the above, [19] recently presented a nonce misuse-resistant version of OMD Their scheme requires 2 AES operations per block, and so would cost at least 1|,Non-data,43
|3 cycles per byte using optimized code and AES-NI Comparison to nonce-misuse AE modes on HSW In a recent publication [3], Bogdanov et al report on opti- mized AES-NI implementations of authenticated-encryption modes of operation on Intel Haswell architecture|,Non-data,43
| In Table 1, we show the results for the nonce misuse-resistant schemes and compare them to ours We note that amongst these modes, only Julius receives full nonce misuse-resistance; the others achieve online encryption and thus the weaker notion Mode 128 256 512 1024 2048 Message length (bytes) single message McOE-G COPA POET Julius McOE-G COPA POET Julius 777 337 5|,Non-data,43
30 418 191 162 3,Non-data,43
24 253 # msgs 7 15 8 7 717 2,Non-data,43
27 475 324 707 7,Non-data,43
36 208 264 468 4,Non-data,43
93 308 469 multiple messages 164 1,Non-data,43
76 146 153 324 2,Non-data,43
79 209 227 168 1,Non-data,43
48 298 216 702 1,Non-data,43
88 462 303 162 1,Non-data,43
45 275 206 GCM-SIV 220 1,Non-data,43
|66 141 128 122 single message Table 1: Performance comparison of GCM-SIV (bottom row) to the AES-NI optimized implemen- tations of nonce misuse-resistant schemes, reported in [3] (top rows)|,Non-data,43
| The measurements are on a Haswell processor and are in cycles per byte of misuse resistance The optimized implementations by [3] are for a single message and for multiple messages processed in parallel; see Table 1 Observe that GCM-SIV is faster than Julius for all mes- sage sizes, and even when considering the speed for paral- lel multiple messages for Julius versus a single message for GCM-SIV|,Non-data,43
| The fastest mode shown by [3] is COPA [4] Ob- serve that GCM-SIV is significantly faster than COPA for all message sizes when processing a single message In ad- dition, for large messages (of size greater than 512 bytes), GCM-SIV outperforms COPA, even when comparing par- allel multiple messages for COPA to a single message for GCM-SIV (In contrast, for short messages COPA is up to 25% faster for multiple messages|,Non-data,43
| However, recall that GCM-SIV achieves a higher level of security than COPA, and COPA is only faster when processing multiple messages in parallel) This comparison sheds significant light on the efficiency of GCM-SIV since it compares it to highly optimized imple- mentations of analogous modes on exactly the same archi- tecture3 Organization We use the notions of CPA-secure IV- based encryption (ivE), nonce-based authenticated encryp- tion (nAE), and nonce misuse-resistant authenticated en- cryption (mrAE), as defined in [20, 18]|,Non-data,43
| These definitions are repeated in Appendix A for the sake of completeness In Section 2 we describe the abstract SIV scheme of Rog- away and Shrimpton [20], and in Section 3 we present and prove the security of our specific instantiation based on any XOR universal hash function and any pseudorandom func- tion Our proof includes a concrete analysis and bounds In Section 4, we describe the final concrete scheme that uses the GHASH universal hash function (from GCM) and AES|,Non-data,43
| Finally, in Section 5 we provide an in-depth analysis of the 3 We stress that McOE-G, COPA and POET do not achieve full mis- use resistance, and only achieve a weaker notion called “online authen- ticated encryption” However, they do enable online encryption with a single pass and constant memory, unlike any full misuse-resistant scheme Nevertheless, the comparison is helpful to understanding the performance of GCM-SIV 111performance of our scheme|,Non-data,43
| Our analysis includes an exact operation count, along with a description of our empirical results We provide actual cycle counts for different size messages on Haswell and Broadwell, and compare them to the actual cycle counts of the optimized OpenSSL (v10|,Non-data,43
|2) implementation of GCM 2 THE ABSTRACT SIV ENCRYPTION SCHEME In [18], a number of constructions for authenticated en- cryption were considered The construction called A4 is a generalisation of the SIV mode of operation [20] that has been proven to be nonce-misuse resistant|,Non-data,43
| In this section, we describe this abstraction Let FK1 : {0, 1}∗ → {0, 1}n be a pseudorandom function and let (Gen, Enc, Dec) be a CPA-secure IV-based encryption scheme For simplicity, we assume that all keys are of length n Let k be a parameter such that the maximum message length is 2k · n bits|,Non-data,43
| Let Encode be a function that outputs a unique encoding of its (multiple) inputs as a string Thus Encode(x, y) fully determines the pair of inputs x and y We remark that simply concatenating x with y is not a unique encoding, since this would imply that Encode(x, y) = Encode(x(cid:107)y1, y2) where y = y1(cid:107)y2 and (cid:107) denotes concatenation Construction 2|,Non-data,43
|1 • Key generation: K1, K2 ∈ {0, 1}n chosen uniformly and independently at random • Encryption of M with associated data A and nonce N : 1 Compute T = FK1 (Encode(N, A, M )) 2 Let IV be the n − k most significant bits of T ,4 and compute C = EncK2 (IV, M ) 3|,Non-data,43
| Output: (N, A, C, T ) • Decryption of (N, A, C, T ): 1 Let IV be the n − k most significant bits of T  2 Compute M = DecK2 (IV, C) 3|,Non-data,43
| Compute T (cid:48) = FK1 (N, A, M ) 4 Output: If T (cid:48) = T then output (A, M ); else out- put ⊥ Security In [18], the following is proven (this construction is called A4 in [18]) Theorem 2|,Non-data,43
|2 (Proven in Section A3 of [18]) If (Gen, Enc, Dec) is a secure IV-based encryption scheme and F is a pseudorandom function, then Construction 21, denoted Π, is a secure nonce-based authenticated encryption scheme|,Non-data,43
| Concretely, [18, Section A3] proves that the nAE advan- tage of any adversary A for this construction is: AdvnAE Π (A) ≤ Advprf F (B(A)) + AdvivE Enc (D(A)) + qd 2n 4 This is not necessary in the abstract SIV scheme, but we will use this later on with the following parameters Let n be the output length of the pseudorandom function|,Non-data,43
| Let A ask qE queries to its encryption oracle, and qd queries to its decryption oracle, with q = qE + qd The encryption queries have total length Le, and the decryption queries have total length Ld, with L = Le + Ld Let tA be the running time of A, given this total number and length of queries, let tF (L) be the running-time to compute the pseudorandom function F on inputs of length L, and likewise tEnc(L) for the underlying ivE encryption Then reduction B has running time at most tA + 2tF (L) + tEnc(L), asks at most 2(qE + qd) queries to its oracle, with total length at most L|,Non-data,43
| Reduction D has running time tA + tF (L) + tEnc(Le), asks at most qE queries to its oracle, with total length at most Le Theorem 22 considers nonce-based authenticated encryp- tion However, we have to prove nonce misuse-resistant au- thenticated encryption|,Non-data,43
| In order to see that this holds, note that the security of the nonce-based authenticated encryp- tion holds as long as the input to the pseudorandom function is different each time, since this guarantees pseudorandom output each time (up to the probability of a collision) In the nonce-based encryption setting this is guaranteed by always using a different nonce However, since the pseudorandom function is applied to entire triple (N, A, M ) in this con- struction, it receives a different input each time as long as the same (N, A, M ) is not used twice However, this is ex- actly what happens in the nonce misuse-resistant setting|,Non-data,43
| Thus, we conclude that the exact same security and bounds are achieved in this setting We conclude: Corollary 23 If (Gen, Enc, Dec) is a secure IV-based encryption scheme and F is a pseudorandom function, then Construction 2|,Non-data,43
|1, denoted Π, is a secure nonce misuse-resistant authenticated encryption scheme In addition, AdvmrAE Π (A) ≤ Advprf F (B(A)) + AdvivE Enc (D(A)) + where B, D, qd and n are as above qd 2n 3 THE UNIVERSAL-SIV INSTANTIATION In this section, we describe our Universal-SIV construc- tion, which is an instantiation of the abstract construction provided in Section 2 as follows: • The pseudorandom function applied to the data (as- sociated authentication data as well as plaintext) is constructed by computing a universal hash function on the data, XORing in the nonce, and then applying a pseudorandom function to the result|,Non-data,43
| • The encryption scheme used is CTR mode, where the initial counter is n − k bits long and the remaining k bits in the block are used for counters for a message with at most 2k blocks of length n Note that this method ensures that as long as the same initial counter is not used twice, no counter in any block is reused 31 The Universal-SIV Specification The scheme uses the following primitives: • An -XOR universal hash function HK1 : {0, 1}∗ → {0, 1}n|,Non-data,43
| Formally, a hash function is -XOR universal if for every x, y, z ∈ {0, 1}∗ it holds that PrK1 [HK1 (x) ⊕ HK1 (y) = z] ≤ (n), where the probability is over the 112choice of K1 For simplicity, we assume that the key length is n • A pseudorandom function FK2 : {0, 1}n → {0, 1}n; for simplicity, we assume that the key length is n • A parameter k < n, where 2k · n is the maximum message length|,Non-data,43
| • The GCM encoding function Encode(x, y) This en- coding works by adding an additional block of 128 bits, where the 64-bits contains the length of x and the sec- ond 64-bits contains the length of y Construction 31|,Non-data,43
| (The Universal-SIV scheme for block length n): • Key generation: K1, K2, K3 ∈ {0, 1}n chosen uni- formly and independently at random • Encryption of M with associated data A and n-bit nonce N : 1 Step 1: Compute h = HK1 (Encode(A, M )) 2 Step 2: Compute T = FK2 (h ⊕ N ) 3 Step 3: Encrypt M with CTR mode using the pseudorandom function F with key K3|,Non-data,43
| The ini- tial counter is taken to be the n − k most sig- nificant bits of T followed by k zeroes Denote the initial counter by I1(cid:107)I2 where I1 ∈ {0, 1}n−k and I2 = 0k; stated otherwise, the initial counter equals I1 · 2n−k + I2 The jth counter is defined to be I·2n−k +[(I2 +j) mod 2k] for j = 0,  |,Non-data,43
|  , 2k−1 Denote the resulting ciphertext by C 4 Output: (N, A, C, T ) • Decryption of (N, A, C, T ): 1|,Non-data,43
| Step 1: Decrypt C with CTR mode using F with key K3, and using the n − k most significant bits of T as the initial counter; denote the resulting plaintext by M  2 Step 2: Compute h = HK1 (Encode(A, M )) 3 Step 3: Compute T = FK2 (h ⊕ N ) 4|,Non-data,43
| Output: If T (cid:48) = T then output (A, M ); else out- put ⊥5 We remark that for standard nonce-based authenticated encryption, it would suffice to take T = h ⊕ FK2 (N ) How- ever, if T is computed in this way and a nonce N is repeated for two different messages with hash results h, h(cid:48) then it is possible to XOR the two tags together and obtain h ⊕ h(cid:48) (since the mask FK2 disappears) In this case, the adversary obtains two messages and their hash, and can forge messages (since this suffices to learn the key K1 for H)|,Non-data,43
| For this rea- son, we compute the tag as T = FK2 (h⊕ N ) Formally, it is required that T be computed by applying a pseudorandom function to (N, A, M ), as described in Construction 21 5 A constant-time comparison function must be used here|,Non-data,43
| 32 Proof of Security of Universal-SIV Notation We provide a concrete analysis of security, counting the running time of the adversaries, the number of oracle queries that they make, and their advantage For an adversary A we denote by t(A) its running time, and by q(A) the number of oracle queries it makes|,Non-data,43
| For the sake of clarity, we differentiate between different types of oracle queries and denote by qE(A) the number of oracle queries to the encryption oracle (where such an oracle is given), by qD(A) the number of oracle queries to the decryption oracle (where such an oracle is given), and by qf (A) the number of oracle queries to the function oracle (for adversaries dis- tinguishing a pseudorandom function from a random one) Finally, for a function F , we denote by tF (L) the time taken to compute F on overall inputs of length L Proof of security By Corollary 2|,Non-data,43
|3, in order to prove security we need to show that FK1,K2 (N(cid:107)M ) def= FK2 (HK1 (M ) ⊕ N ) is a pseudorandom function from {0, 1}n → {0, 1}n, when H is an -XOR universal hash function from {0, 1}∗ → {0, 1}n (Note that M here includes an encoding of both the asso- ciated data and plaintext message used in the encryption process We removed the explicit reference to A for clarity) Before proving that F is indeed a pseudorandom func- tion, we define security for pseudorandom functions via the following experiment: Experiment ExptbA,F 1|,Non-data,43
| If b = 0 then choose K at random and set O = FK  Else, if b = 1, set O to be a truly random function f : {0, 1}∗ → {0, 1}n 2 b(cid:48) ← AO(·) 3|,Non-data,43
| Output 1 if and only if b(cid:48) = b Definition 32 A family of functions F is a (t, qf , δ)- pseudorandom function if for every adversary A running in time at most t and asking at most qf queries to its oracle it holds that, AdvprfF (A) def= (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12) ≤ δ Recall that tH (L) denotes the time to compute the univer- sal hash function H on overall input of length L, that t(A) denotes the running time of algorithm A, and that qf (A) denotes the number of queries made by A to its function oracle|,Non-data,43
| We use the following lemma: Lemma 33 Let F be a family of pseudorandom func- tions from {0, 1}n to {0, 1}n, and let H be a family of - XOR universal hash functions from {0, 1}∗ to {0, 1}n De- fine FK1,K2 (N(cid:107)M ) = FK2 (HK1 (M ) ⊕ N )|,Non-data,43
| Then, F is a family of pseudorandom functions from {0, 1}∗ to {0, 1}n, and there exists an adversary A1 such that for every adver- sary A: F (A1) +  ·(cid:16) qf (A) (cid:17) AdvprfF (A) ≤ Advprf 2 where t(A1) = t(A) + tH (L) · qf (A), qf (A1) = qf (A), and the overall length of message sent by A to its oracle is L 113Proof: Before beginning the proof, we rewrite the pseu- dorandom function experiment using our specific scheme: Experiment ExptbA,F (1n) 1 If b = 0 then choose K1, K2 ← {0, 1}n, and set O = FK2 ◦ HK1  Else, if b = 1, set O to be a truly random function f : {0, 1}∗ → {0, 1}n|,Non-data,43
| 2 b(cid:48) ← AO(·)(1n) 3 Output 1 if and only if b(cid:48) = b We first change the experiment to ExptA,f,H (1n) where K1 is chosen as above, but a truly random function f : {0, 1}n → {0, 1}n is used instead of FK2 in the case of b = 0 (and so O = f ◦ HK1 when b = 0) A straightfor- ward reduction to the pseudorandomness of F yields that for every adversary A1, (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[ExptA,f,H = 1](cid:12)(cid:12) ≤ Advprf F (A1)|,Non-data,43
| (1) The adversary A1 attacking the underlying pseudorandom function invokes A, chooses K1 itself and answers every oracle query M(cid:107)N of A by first computing HK1 (M ) ⊕ N and then sending the result to its oracle If A1 received a truly random function as an oracle, then this perfectly sim- ulates ExptA,f,H ; in contrast, if A1 received the pseudoran- dom function F as its oracle, then this perfectly simulates Expt0A,F  The running time of A1 is exactly that of A plus qf computations of H, and the number of queries made by A1 to its oracle is exactly the same number made by A Thus, t(A1) = t(A) + tH (L) · qf (A), and qf (A1) = qf (A)|,Non-data,43
| Next, we prove that for every adversary A making qf (cid:12)(cid:12)Pr[ExptA,f,H (1n) = 1]−Pr[Expt1A,F (1n) = 1](cid:12)(cid:12) ≤ ·(cid:16) qf (A) queries to its oracle, (cid:17) 2 (2) In order to see this, consider first the event coll which equals 1 if and only if there exist two queries M(cid:107)N, M(cid:48)(cid:107)N(cid:48) with M(cid:107)N (cid:54)= M(cid:48)(cid:107)N(cid:48) made by A such that HK1 (M ) ⊕ N = HK1 (M(cid:48)) ⊕ N(cid:48) Then, it holds that Pr[ExptA,f,H (1n) = 1 || ¬coll] = Pr[Expt1A,F (1n) = 1] This holds because when HK1 (M ) ⊕ N (cid:54)= HK1 (M(cid:48)) ⊕ N(cid:48) for every pair of distinct M(cid:107)N, M(cid:48)(cid:107)N(cid:48) queried by A to the oracle, the inputs to f in Expt are all distinct Thus, the output distribution over f (HK1 (M )⊕N ) in Expt is the same as the output distribution over f (M(cid:107)N ) in Expt1|,Non-data,43
| Since Pr[ExptA,f,H (1n) = 1] = Pr[ExptA,f,H (1n) = 1 || ¬coll] · Pr[¬coll] + Pr[ExptA,f,H (1n) = 1 || coll] · Pr[coll] ≤ Pr[ExptA,f,H (1n) = 1 || ¬coll] + Pr[coll] it remains to prove that Pr[coll] ≤  ·(cid:16) qf (cid:17)  2 to see this, observe that A never In order receives HK1 (M ) ⊕ N , but rather receives f (HK1 (M ) ⊕ N ) where f is a truly random function Thus, A learns nothing about K1 Intuitively, this means that there will be a collision on the queries made by A with the same probability that there will be a collision if all the queries are first made and then K1 is chosen at random|,Non-data,43
| In order to prove this formally, we modify ExptA,f,H (1n) so that in the ith query, the out- put f (i) is given (we assume without loss of generality that A never makes the same query twice to the oracle) Then, at the end of the experiment, K1 is chosen at random and HK1 (M ) ⊕ N is computed on all the values M(cid:107)N queried to the oracle As long as no collision takes place, the distri- bution over the outputs that A receives is identical in both experiments Furthermore, if a collision occurs, then it has already occurred and it makes no difference what happens to A’s view afterwards (since a collision already occurred and we are only interested in the question of whether collisions occur)|,Non-data,43
| Thus, the collision probability in both experiments is identical M1(cid:107)N1,   |,Non-data,43
| , Mqf (cid:107)Nqf to the oracle, we have that Pr[coll] = Pr [∃i, j ∈ [qf ] : HK1 (Mi) ⊕ Ni = HK1 (Mj) ⊕ Nj] In this latter experiment, for a series of qf distinct queries Pr[HK1 (Mi) ⊕ HK1 (Mj) = Ni ⊕ Nj] qf(cid:88) qf −1(cid:88) (cid:17) ·  (cid:16) qf i=1 2 j=i+1 = =  Combining Equations (1) and (2), we have that where the probability is taken over the choice of K1 (that specifies the concrete hash function H) Note that the last equality is obtained since H is an -XOR universal hash function|,Non-data,43
| AdvprfF (A) = (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12) ≤ (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[ExptA,f,H = 1](cid:12)(cid:12) +(cid:12)(cid:12)Pr[ExptA,f,H = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12) ≤ AdvprfF (A1) +  ·(cid:16) qf (A) (cid:17) 2 and this completes the proof The security of counter mode based on a pseudorandom function is well known Here we provide the bounds for encryption of messages with at most 2k − 1 blocks, and where the initial counter is of length n− k bits This ensures that as long as the initial counters are all different, then the pseudorandom function is applied to a different input each time|,Non-data,43
| Since we consider the case of random initial counters, it follows that the probability that a counter repeats is at 2n−k , where qE(A) is the number of queries made most qE (A)2 by adversary A to the encryption oracle The reduction to security is very straightforward, with the adversary for the pseudorandom function just querying all the appropri- ate counters to its oracle We therefore conclude: AdvivE Lemma 34|,Non-data,43
| Let F : {0, 1}n → {0, 1}n be a pseudoran- dom function Then, there exists an adversary A2 making such that for every adversary A: Enc (A) ≤ Advprf qE(A)2 2n−k  where t(A2) = t(A) + Le(A) and qf (A2) = Le(A) n , with qE being the number of queries made by A to its encryption oracle, Le(A) being the total length of all plaintexts queried by A to its encryption oracle, and qf being the number of queries made by A2 to its function oracle F (A2) + 114We are now ready to state the main theorem that provides the security bounds for our construction (we use Π to denote Construction 3|,Non-data,43
|1): Theorem 35 Let F be a pseudorandom function, and let H be an -XOR universal hash function Then, Con- struction 3|,Non-data,43
|1 is a nonce misuse-resistant authenticated en- cryption scheme, and there exists an adversary A(cid:48) for F such that for every A attacking Construction 31: (A) ≤ 2·Advprf qd(A) AdvmrAE 2n  (The running time and oracle query complexity of A(cid:48) is given in the proof) qE(A)2 2n−k + F (A(cid:48) )+·(cid:16) qE(A) (cid:17) + 2 Π Π Proof: By Corollary 2|,Non-data,43
|3, we have that: (A) ≤ AdvprfF (B(A)) + AdvivE AdvmrAE where F is the pseudorandom function used that combines the universal hash and underlying pseudorandom function F  By Lemma 33 we have that there exists an adversary A1 such that Enc (D(A)) + qd(A) 2n F (A1) +  ·(cid:16) qf (A) (cid:17) 2 AdvprfF (A) ≤ Advprf and by Lemma 34 we have that there exists an adversary A2 such that AdvivE Enc (A) ≤ Advprf F (A2) + qE(A)2 2n−k |,Non-data,43
| Now, adversary B(A) is a PRF adversary who runs it time at most t(A) + 2tF (L) + tEnc(L) (where L is the total length of the values queried to oracles by A) and asks at most 2(qE(A) + qd(A)) queries to its oracle, and A1(B(A)) runs in time t(B(A))+tH (L)·qf (B(A)) and asks qf (B(A)) queries to its oracle Thus, A1 is an adversary for the pseudoran- dom function who runs in time t(A) + 2tF (L) + tEnc(L) + tH (L)·2(qE(A)+qd(A)) and asks qf (A1) = 2(qE(A)+qd(A)) queries to its oracle Furthermore, adversary D(A) is an ivE encryption ad- versary who runs in time t(A) + tF (L) + tEnc(L) and asks at most qE(A) queries to its oracle Thus, A2 is an ad- versary for the pseudorandom function who runs in time t(A) + tF (L) + tEnc(L) + Le(A) ≈ t(A) + tF (L) + tEnc(L) (we can ignore the Le(A) factor since it is just the length of the plaintext, whereas tEnc(L) is the actual cost of encryption which is greater), and asks qf (A2) = Le(A) n queries to its oracle|,Non-data,43
| Take A(cid:48) to be the adversary that incorporates A1 and A2 Then, we have that there exists an adversary A(cid:48) for the un- derlying pseudorandom function so that for every adversary A for the mrAE setting: n < L • A(cid:48) runs in time [t(A) + 2tF (L) + tEnc(L) + tH (L) · 2(qE (A) + qd(A))] = 2 ·(cid:16) + [t(A) + tF (L) + tEnc(L)] (cid:17) t(A) + tF (L) + tEnc(L) + tH (L) · (qE (A) + qd(A)) Observe that the running time of A(cid:48) is essentially linear in the running time of A (under the very rea- sonable assumption that the cost of applying the pseu- dorandom function to the plaintexts queried by A and encrypting them, is not more than the running time of A itself) It is reasonable to therefore writhe that t(A(cid:48)) ≤ 6 · t(A) • The number of queries made by A(cid:48) to its function or- acle is at most 2qE(A) + 2qd(A) + L n • The advantage of A in the mrAE setting, when reduc- ing to the underlying pseudorandom function F , is AdvmrAE Π (A) ≤ Advprf ) + Advprf F (A(cid:48) + ·(cid:16) qE(A) (cid:17) 2 + ) F (A(cid:48) qE(A)2 2n−k + (3) qd(A) 2n |,Non-data,43
| This completes the proof 4 THE GCM-SIV INSTANTIATION In this section, we describe our concrete instantiation of the universal-SIV construction that uses GHASH, which is a part of the GCM specification Thus, this construction uses the exact same components as GCM in a slightly dif- ferent way, with the result being nonce misuse resistance|,Non-data,43
| Throughout this section, we use the following lemma, that states the GHASH is indeed a XOR universal hash function: Lemma 41 (Lemma 2 in [17]) The GHASH function n + 1(cid:101) · 2−t, is an -XOR universal hash function with  = (cid:100) L where L is an upper bound on the length of the input, n is the length of the block, and t is the length of the output 4|,Non-data,43
|1 Theoretical 3-Key Instantiation In this instantiation, we simply use the GHASH universal hash function in Construction 31 This hash function works by first concatenating zeroes to each of A and M to make them of length that is a multiple of the block length n Then, an additional block that contains the lengths of both A and M is concatenated (where the length of A is given in the first n/2 bits of the block, and the length of M in the last n/2 bits)|,Non-data,43
| Finally, a polynomial is evaluated over this result Observe that GHASH requires a key, the pseudorandom function applied to the output of GHASH requires a key, and finally the pseudorandom function used in counter mode re- quires a key Thus, this instantiation requires three separate keys Although this is a perfectly reasonable instantiation, 3 keys would typically be considered too much for real world usages; we therefore refer to this as a “theoretical instantia- tion”|,Non-data,43
| Later, we present 2-key and 1-key instantiations When plugging GHASH directly into Construction 31, all that is required is to plug in the value of  given in Lemma 41 into the bounds of Theorem 3|,Non-data,43
5 Theorem 42 (3-Key GCM-SIV) Construction 3,Non-data,43
|1 with the pseudorandom function F and the hash function GHASH is a nonce misuse-resistant authenticated encryp- tion scheme Furthermore, there exists an adversary A(cid:48) for F such that for every A attacking Construction 31 making qE encryption queries and qd decryption queries of overall length L: n(cid:101) + 1(cid:1) · qE(A)2 + qd(A) (cid:0)(cid:100) L (A) AdvmrAE qE(A)2 < 2 · Advprf 2n−k where t(A(cid:48)) ≤ 6 · t(A) and qf (A(cid:48)) ≤ 2qE(A) + 2qd(A) + L n  F (A(cid:48) ) + 2n + Π Proof: We take t = n in Lemma 4|,Non-data,43
|1 and so obtain  = n + 1(cid:101) · 2−n Plugging this into Eq (3) in the proof of (cid:100) L 115Theorem 35, we obtain: AdvmrAE Π (A) ≤ 2 · Advprf ≤ 2 · Advprf (cid:17) ·(cid:16) qE(A) ) +  ·(cid:16) qE(A) n(cid:101) + 1(cid:1) · qE(A)2 + qd(A) (cid:0)(cid:100) L qE(A)2 2n−k + (cid:100) L n + 1(cid:101) 2n qd(A) 2n qE(A)2 2n−k + (cid:17) ) + + + 2 2 2qE(A)2 2n−k + ) + 2n qE(A)2 + qd(A) 2n F (A(cid:48) F (A(cid:48) F (A(cid:48) F (A(cid:48) qd(A) 2n qE(A)2 2n−k + < 2 · Advprf ) + ≤ 2 · Advprf where the last inequality holds since L ≤ 2k · n and so 2n ≤ 1 (cid:100)L/n(cid:101) 2n−k |,Non-data,43
| The running time and number of oracle queries are taken directly from the proof of Theorem 35 In the specific AES instantiation with n = 128 and k = 32, we conclude: Π AdvmrAE 2 · Advprf (A) < F (A(cid:48) ) + qE(A)2 295 + qE(A)2 + qd(A) 2128  Note that setting k = 32 limits the number of blocks to be 232 and so the maximum length message that can be encrypted is 64GB|,Non-data,43
| This is standard and is used in typical implementations of GCM 42 Two-Key GCM-SIV In this instantiation, the same key is used for the pseu- dorandom function applied to the output of GHASH and for the counter mode encryption (ie|,Non-data,43
|, we take K2 = K3) There are two possible ways of doing this The first is to simply bound the probability that the output of GHASH collides with a possible counter However, this will result in an additional birthday degradation|,Non-data,43
| The other possibility is to force the output from GHASH to always be different from the counters used in the encryption This is achieved by truncating the output of GHASH to n− 1 bits and using an n − 1-bit nonce Then, the most significant bit of the in- put to the pseudorandom function in order to generate T is always zero Furthermore, the initial counter is taken to be the n− k − 1 most significant bits of T followed by k zeroes, and the most significant bit is set to 1|,Non-data,43
| This ensures that the counter never overlaps with the input to the pseudoran- dom function for generating T  From a security perspective, this means that the same key can be reused with no affect on security at all (a single reduction for the pseudorandom function suffices) This variant yields the following bounds (obtained as in the 3-key case while changing the exact parameters due to the single bit): length L: AdvmrAE Π (A) < 2 · Advprf F (A(cid:48) ) + qE(A)2 2n−k−2 + qE(A)2 + qd(A) 2n−1 where t(A(cid:48)) ≤ 6 · t(A) and qf (A(cid:48)) ≤ 2qE(A) + 2qd(A) + L n  4|,Non-data,43
|3 Single-Key GCM-SIV In this final instantiation, we take a single key K0 and de- rive two keys K1 and K2 by computing K1 = AESK0 (0128) and K2 = AESK0 (0127(cid:107)1) We then proceed as in the two- key case The bounds for here almost identical (with an additional reduction for a single query to the pseudorandom function, which is not significant here) 5|,Non-data,43
| THE PERFORMANCE OF GCM-SIV In this section, we provide a detailed performance analy- sis of our GCM-SIV construction together with experimental results of an optimized software implementation, measured on the latest high end processors with architecture code- names Haswell (HSW) and Broadwell (BDW) The perfor- mance of GCM-SIV depends on the message length We measure the length of the message ||M|| and the length of the associated data ||A|| in bytes 5|,Non-data,43
|1 Encryption Operations The computational cost of computing GCM-SIV is the following sum: GCM-SIV Encryption = Key Derivation + GHASH + Tag Generation + CTR INPUT Generation + CTR ENCRYPTION We discuss each component separately Key Derivation: Derivation is required only with the one- key GCM-SIV variant (to derive K1, K2 from the input key K0) This derivation requires expanding one AES key and using it to encrypt 2 blocks GHASH: This requires a field multiplication in GF (2128) for every 16-byte block or part thereof (in the plaintext mes- sage M and associated data A), plus a block containing the data length|,Non-data,43
| Thus, the number of field multiplications equals (cid:96) = (cid:108) ||M||+||A|| (cid:109) + 1 16 Tag Generation: Generating the authentication tag from the output of GHASH involves executing AES key expansion with K2, and using it to encrypt a single block (the cost of XORing with IV , and forcing the top bit to 1, is negligible) CTR INPUT Generation: This involves preparing the input blocks to AES in the counter-mode encryption The cost of forcing the top bit to 0, and incrementing the 32- bit counters (in the least significant quarter of the counter block) is negligible|,Non-data,43
| CTR ENCRYPTION This is the cost of AES op- (cid:108) ||M|| (cid:109) 16 Theorem 43 (2-Key GCM-SIV) Consider the above variant of Construction 31 with one key for the pseudoran- dom function F and one key for the hash function GHASH|,Non-data,43
| Then, the result is a nonce misuse-resistant authenticated encryption scheme, and there exists an adversary A(cid:48) for F such that for every A attacking Construction 31 making qE encryption queries and qd decryption queries of overall erations on preprepared input (Note that the key used has already been expanded when preparing the tag) 5|,Non-data,43
|2 Implementation Optimizations Software implementations on high end Intel processors use the AES-NI and the PCLMULQDQ instructions There ex- ist optimizations that improve the performance significantly, 116# bytes HSW/BDW GCM-SIV Two keys 149 / 136 198 / 171 322 / 281 516 / 440 674 / 566 966 / 796 16 32 64 128 256 512 1,024 1,536 2,048 4,096 8,192 1566 / 1252 2159 / 1713 2751 / 2171 5118 / 4005 9862 / 7666 Full Cycles GCM-SIV One key 297 / 241 318 / 284 444 / 417 645 / 568 800 / 694 1093 / 930 1695 / 1385 2274 / 1843 2869 / 2300 5244 / 4136 9994 / 7782 C/B AES-GCM 1289 / 1263 1277 / 1318 1292 / 1335 1415 / 1371 1558 / 1417 1808 / 1730 2312 / 2108 2816 / 2416 3372 / 2842 5332 / 4354 9521 / 7388 No Init Cycles GCM-SIV One key 133 / 121 178 / 153 319 / 278 282 / 262 426 / 401 722 / 626 GCM-SIV Two keys 133 / 121 178 / 153 319 / 278 282 / 262 426 / 401 722 / 626 1315 / 1085 1907 / 1544 2498 / 1996 4867 / 3837 9611 / 7498 1315 / 1085 1907 / 1544 2498 / 1996 4867 / 3837 9611 / 7498 C/B AES-GCM 178 / 172 219 / 217 236 / 238 293 / 266 421 / 385 760 / 651 1252 / 989 1714 / 1305 2287 / 1765 4296 / 3243 8399 / 6289 8,192 12/094 1|,Non-data,43
22/095 116/09 1,Non-data,43
17/092 117/092 1,Non-data,43
|03/077 Table 2: GCM-SIV encryption performance for different message lengths, on the Haswell and Broadwell (HSW/BDW) archi- tectures Comparison to the performance of AES-GCM (OpenSSL 10|,Non-data,43
|2) is provided The numbers are in cycles, except for the last row which reports the performance in C/B compared to straightforward implementations We briefly describe these optimizations|,Non-data,43
 1 The key derivation (required only for one-key GCM- SIV) can be reduced by a new software optimization that pipelines the instructions efficiently We were able to execute this derivation in 84 cycles (on HSW/BDW architectures) 2,Non-data,43
| When the message includes more than 8 blocks, then GHASH can be optimized by: (1) Preparing a lookup table with “powers” of H, (2) Interleaving the polyno- mial multiplications, and (3) Deferring the reduction modulo Q(x) (the field polynomial) to take place only once per 8 blocks [10, 11] See also [8]for an analysis and an improved reduction method Effectively, this reduces the cost of GHASH to (cid:96) polynomial multipli- cations + 1 8 (cid:96) reductions, instead of (cid:96) field multiplica- tions We were able to compute GHASH using this method at the asymptotic performance of 0|,Non-data,43
|56 and 03 cycles per byte (C/B) on HSW and BDW, respectively (for an 8KB message) 3 For long enough messages, the encryption can operate on 8 blocks interleaving AESENC/ AESENCLAST instructions [7, 9]|,Non-data,43
| We were able to encrypt at the asymptotic performance of 063 C/B on both HSW and BDW in parallel, Remark 51|,Non-data,43
| For long messages the setup cost is small, and the differences between one key and two keys become negligible From the above data, we can predict the perfor- mance (for long messages) to be the sum of GHASH and encryption, which is 119 C/B for HSW, and 093 C/B for BDW|,Non-data,43
| 53 Theoretical Comparison to AES-GCM AES-GCM uses CTR mode for encryption, and GHASH for the authentication It uses a single key, and involves a derivation step: H = AESK (0128) and M ASK = AESK (·)6 6 The mask is XOR-ed with the GHASH result, to make it a MAC tag|,Non-data,43
| Here, · denotes the first counter block used in AES-GCM When counting the number of operations, GCM and GCM- SIV have roughly the same performance In fact, GCM-SIV is slightly cheaper due to a simpler counter incrementing However, for encryption, the main difference between GCM and GCM-SIV is in the possible order of operations|,Non-data,43
| By definition, GCM-SIV can start AES-CTR encryption only after the authentication tag has been computed By con- trast, GCM can interleave the AES and GHASH computa- tions (for the message; not for the AAD) This enables GCM encryption to be faster than GCM-SIV Note, however, that for decryption GCM-SIV can also in- terleave the AES and GHASH computations, and so its per- formance is identical to that of GCM|,Non-data,43
| 54 Experimental Results For our study, we prepared an optimized software imple- mentation of GCM-SIV, and measured it on the Haswell and Broadwell (HSW/BDW) architectures The results are summarized in Table 2 The table provides the cycles count for GCM-SIV for various message lengths, to illustrate the performance characteristics|,Non-data,43
| They are compared to the op- timized AES-GCM implementation of OpenSSL (102) We note that the cost of the “Init” step in OpenSSL is approxi- mately 1,100 cycles|,Non-data,43
| This includes, among other operations the preparation of a lookup table, keys setup, and more Therefore, to facilitate a more detailed comparison, Table 1 also shows the AES-GCM performance without the Init step, as well as GCM-SIV without the initialization (this neutralises the fact that OpenSSL carries out more opera- tions in its Init than we do in our implementation) Needless to say, the two-key and one-key variants are identical after Init, as can be seen in the table The last row of the table shows the performance in C/B, for a long message|,Non-data,43
 Note that the measured performance matches the predictions of Remark 51 The methodology used for carrying out these measure- ments is as follows (and is the same for GCM-SIV and AES- GCM) The following process was repeated 30 times: com- pute the operation 500 times for a ”warmup” (e,Non-data,43
|g, to place code/data in the caches) Then, compute and clock the op- eration 500 times, and take the average result The output 117appearing in the table is the minimum value over the 30 runs|,Non-data,43
| The reason that we take the minimum is to neutralize noise caused by interrupts to the operating system All the runs were carried out on a system where the Intel R(cid:13) Turbo Boost Technology, the Intel R(cid:13) Hyper-Threading Tech- nology, and the Enhanced Intel Speedstep R(cid:13) Technology, were disabled The results show that up to 32 bytes (including), GCM- SIV with 2 keys is faster even than GCM without Init Therefore, for key wrap, GCM-SIV is an excellent choice|,Non-data,43
| It is also very efficient for scenarios that encrypt many short messages with the same key (since the key derivation is car- ried out only once here and so the cost is like without Init) For long messages, as expected, we see only a very small difference between the 2-key and 1-key versions of GCM- SIV, in the “full” implementation This allows for choosing the more cost effective variant (ie|,Non-data,43
|, 1 key) from the network traffic viewpoint We observe that on the latest Broadwell architecture, the cost of GCM-SIV encryption falls below 1 cycle per byte For encryption, Table 2 shows that GCM-SIV is 14% slower than AES-GCM on Haswell, and 19% slower than AES- GCM on Broadwell The reason for this difference is that the optimized AES-GCM software is able to interleave AES and GHASH computations, while GCM-SIV cannot|,Non-data,43
| Recall that nonce misuse-resistance provably requires two passes, and thus there is an inevitable cost incurred However, we point out that for decryption, optimized AES-GCM and GCM-SIV would have the same performance because the AES and GHASH operations can be interleaved We comment about the performance of GCM-SIV without initialization for 64 and 128 bytes messages Our optimized GHASH code prepares a lookup table to aggregate 8 block multiplications before the reduction step|,Non-data,43
| Of course, this becomes relevant only when the message length is at least 128 bytes If the cost of the setup is not (including the preparation of the table), then this leads to the seeming anomaly in Table 2 where 128-byte GCM-SIV takes less time than 64-byte GCM-SIV 6 |,Non-data,43
|ABSTRACT An Android app’s graphical user interface (GUI) displays rich semantic and contextual information about the smart- phone’s owner and app’s execution Such information pro- vides vital clues to the investigation of crimes in both cyber and physical spaces In real-world digital forensics however, once an electronic device becomes evidence most manual in- teractions with it are prohibited by criminal investigation protocols Hence investigators must resort to “image-and- analyze” memory forensics (instead of browsing through the subject phone) to recover the apps’ GUIs|,Non-data,44
| Unfortunately, GUI reconstruction is still largely impossible with state- of-the-art memory forensics techniques, which tend to fo- cus only on individual in-memory data structures An An- droid GUI, however, displays diverse visual elements each built from numerous data structure instances Furthermore, whenever an app is sent to the background, its GUI struc- ture will be explicitly deallocated and disintegrated by the Android framework In this paper, we present GUITAR, an app-independent technique which automatically reassembles and redraws all apps’ GUIs from the multitude of GUI data elements found in a smartphone’s memory image|,Non-data,44
| To do so, GUITAR involves the reconstruction of (1) GUI tree topol- ogy, (2) drawing operation mapping, and (3) runtime envi- ronment for redrawing Our evaluation shows that GUITAR is highly accurate (80-95% similar to original screenshots) at reconstructing GUIs from memory images taken from a vari- ety of Android apps on popular phones Moreover, GUITAR is robust in reconstructing meaningful GUIs even when fac- ing GUI data loss Categories and Subject Descriptors D|,Non-data,44
46 [Operating Systems]: Security and Protection General Terms Security Keywords Memory Forensics; Android; Digital Forensics Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted,Non-data,44
| To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from Permissions@acmorg CCS’15, October 12–16, 2015, Denver, Colorado, USA|,Non-data,44
 Copyright is held by the owner/author(s) Publication rights licensed to ACM c(cid:13) 2015 ACM ISBN 978-1-4503-3832-5/15/10 ,Non-data,44
$1500,Non-data,44
 DOI: http://dxdoiorg/101145/2810103,Non-data,44
2813650 1 INTRODUCTION The graphical user interface (GUI) of an application ren- ders semantic information (eg,Non-data,44
|, text, images, and graph- ics) for human users to interact with Further, GUIs of- ten reflect our only perception of an application’s execu- tion state This is even more true for the GUIs of Android apps, which users interact with — one at a time — on the smartphone’s screen while numerous other apps run in the background Moreover, smartphone apps are long-running (compared with their desktop counterparts) as users seldom terminate an app explicitly, and the apps keep running even with the screen turned off or in “airplane” mode|,Non-data,44
| Now imag- ine the following digital forensics scenario: Law enforcement agents obtain a suspect’s smartphone which they believe can reveal vital evidence for their investigation Ideally, investi- gators would inspect the GUIs of the apps, specifically those not currently on screen, for evidence to review, catalog, and later present in court It turns out that this is far more difficult than it ap- pears for both policy and technical reasons Due to strict legal interpretations of “digital evidence preservation” in US court proceedings [2–10], once an electronic device becomes a piece of raw evidence, most manual interaction with it (e|,Non-data,44
