 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| Each facet compares AFLFast on the left hand-side and AFL on the right hand side using a box plot with a jitter overlay In all of eight runs, AFLFast consistently and significantly outperforms classic AFL The average time to first exposure is shown in Figure 8 All vulnerabilities are exposed within the first six hours|,Non-data,22
 The exponential power schedule and improved search strategies clearly boost the e ciency of the state-of-the-art coverage- based greybox fuzzer Bugs in nm AFLFast finds two bu↵er overflows seven (7) times faster than AFL AFLFast also exposes a third bug which is not exposed by AFL at all,Non-data,22
| The three overflows are invalid reads and unlikely to be exploitable The last row of Figure 1 shows more details Again, our extension consistently outperforms the classic version of AFL 9Notice the logarithmic scale in Figure 6|,Non-data,22
 CVE−2016−2226 CVE−2016−4487 CVE−2016−4488 ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● CVE−2016−4489 CVE−2016−4490 CVE−2016−4491 ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ●● ●● ● ●●● CVE−2016−4492 CVE−2016−4493 CVE−2016−6131 ) s r u o h   n i (  e m T i 24 20 16 12 8 4 0 24 20 16 12 8 4 0 24 20 16 12 8 4 0 24 20 16 12 8 4 0 ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● Bug 1 ● ● ● ● ● ● ● ●● ● ● ● AFL−FAST AFL ● ● ● ● ●● ● ● ● ● ● ●● ● ● ● ● Bug 2 ● Bug 3 ● ● ● ● ● ● AFL−FAST  AFL AFL−FAST AFL Figure 7: Time to expose the vulnerability Vulnerability CVE-2016-2226 > 2400 h 263 h CVE-2016-4487 6,Non-data,22
92 h CVE-2016-4488 1068 h CVE-2016-4489 CVE-2016-4490 368 h CVE-2016-4491 > 2400 h 12,Non-data,22
18 h CVE-2016-4492 CVE-2016-4493 448 h CVE-2016-6131 > 2400 h 2043 h Bug 1 20,Non-data,22
91 h Bug 2 Bug 3 > 2400 h AFL AFL-Fast Factor N/A 58 70 3,Non-data,22
8 91 N/A 141 45 N/A 6,Non-data,22
0 72 N/A 385 h 046 h 0,Non-data,22
98 h 278 h 041 h 474 h 0,Non-data,22
87 h 100 h 548 h 338 h 2,Non-data,22
|89 h 507 h Figure 8: Time to expose the vulnerability Independent Evaluation We note that our collaborators, Team Codejitsu at DARPA Cyber Grand Challenge (CGC), evaluated both AFL and AFLFast on all 150 benchmark programs that are provided as part of the CGC|,Non-data,22
| On these binaries, AFLFast exposes errors 19x faster than AFL, on average In one run, AFL exposed four errors that are not exposed by our extension However, AFLFast exposed seven errors that are not exposed by AFL Team Codejitsu inte- grated AFLFast in their bot Galatica to prove vulnerabilities in the other teams’ binaries|,Non-data,22
| Galactica went on to take 2nd place in the CGC finals in terms of number of bugs found A thorough discussion and reflection of the CGC experience will not be covered in this article However, we think that Codejitsu’s success demonstrates the potential of AFLFast 1040s e s a C  t s e T  f o  r e b m u N 105 104 103 102 101 100 s e s a C  t s e T  f o  r e b m u N 105 104 103 102 101 100 AFL−FAST ●● ● ● ●●● ● ●●●● ●●●● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● ●●●●●●●●●●●●●●● ●●●●●●●●●●●●● mean = 382 ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● 350 400 450 500 250 200 300 Path Index AFL mean = 1288 0 50 100 150 ●● ● ● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● ●●●●●●●●●● ●●●●●●●●●● 0 50 100 150 ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● 250 200 300 Path Index 350 400 450 500 Figure 9: #Fuzz exercising a path (on a log-scale) after running AFL for 10 minutes on the nm-tool|,Non-data,22
| Low-frequency Paths In this paper, we argue that the fuzzing time is better spent exploring low-frequency paths Firstly, we believe that low-frequency paths are more likely to be exercised by valid inputs that stress di↵erent behav- iors of the program Secondly, less time is wasted fuzzing high-frequency paths that are exercised by most fuzz any- ways|,Non-data,22
| Finally, it allows the coverage-based greybox fuzzer to e ciently discover more paths per generated input As we can see in Figure 9, indeed our heuristics generate more fuzz for low-frequency paths and less fuzz for high-frequency paths In 10 minutes, AFLFast discovered twice as many paths as AFL For AFLFast only 10% of the discovered (low-frequency) paths are exercised by just one input while for AFL, 30% are exercised by just one input|,Non-data,22
| The mean amount of generated test inputs per path is about three times higher for AFLFast This clearly demonstrates the ef- fectiveness of our heuristics in exploring a maximal number of (low-frequency) paths while expending minimum energy 53 Comparison of Power Schedules Earlier, we introduced two constant and four monotonous power schedules|,Non-data,22
| AFL adopts a constant power schedule and assigns a fairly high amount of energy Basically, the same input will get the same performance score the next time it is fuzzed This is the exploitation-based constant schedule (exploit) To understand the impact of our choice to start with a reduced fuzzing time per input, we also investigate an exploration-based constant schedule (explore) that assigns a fairly low and constant amount of energy|,Non-data,22
| The monotonous schedules increase the fuzzing time in a linear, quadratic, or exponential manner Specifically, AFLFast implements an exponential schedule 1250 1000 750 500 250 0 s e h s a r C  e u q n U i  f o  r e b m u N Schedule afl−fast coe exploit (afl) explore linear quad 0 5 10 15 Time (in hours) 20 25 Results The exponential schedule that is implemented in AFLFast outperforms all other schedules|,Non-data,22
| The cut-o↵ ex- ponential schedule (coe) performs only slightly worse than AFLFast After 24 hours, both schedules (fast and coe) exposed 50% more unique crashes than the other three (lin- ear, quad, and explore) Interestingly, the exploration-based constant schedule (explore) starts o↵ by discovering a larger number of crashes than any of the other schedules; it fuzzes each input quickly and swiftly moves on to the next How- ever, this strategy does not pay o↵ in the longer run|,Non-data,22
| After 24 hours, it performs worse than any of the other schedules (except AFL’s exploitation-based constant schedule) The quadratic schedule (quad) starts o↵ revealing a similar num- ber of unique crashes as AFLFast but at the end of the 24 hour budget it performs comparably to the other two (linear and explore) 54 Comparison of Search Strategies Our search strategies prioritize inputs that have not been fuzzed very often (small s(i)) and inputs that exercise low- frequency paths (small f (i))|,Non-data,22
| In the following, we investigate two strategies targeting the implementation of perf score and chooseNext in Algorithm 1 Strategy 1 designates as favourites ti 2 T where s(i) and f (i) are small, and then where execution time, transition coverage, and creation time are minimal10 Without Strategy 1, AFLFast (like AFL) designates as favorites ti 2 T where execution time, tran- sition coverage, and creation time are minimal Strategy 2 chooses the next input ti from the queue where s(i) and f (i) are minimal and ti is a favourite|,Non-data,22
 Without Strategy 2 AFLFast (like AFL) chooses the next input from the queue that is marked as favourite All strategies are run with the exponential power schedule 1250 1000 750 500 250 0 Schedule Both Strategies No Strategy Strategy 1 Strategy 2 s e h s a r C e u q n U   i  f o  r e b m u N 0 5 10 15 Time (in hours) 20 25 Figure 11: #Crashes over Time (Search Strategies) Results,Non-data,22
| The combination of both strategies is signifi- cantly more e↵ective than any of the strategies individually Until about 12 hours the other strategies perform very simi- larly After 24 hours as individual strategy, strategy 1 which changes how AFL designates the favourite is more e↵ective than strategy 2 and no strategy in the long run As indi- vidual strategy, the strategy 2 which changes the order in which test inputs are chosen from the queue seems to be not e↵ective at all|,Non-data,22
| It performs similarly compared to running AFLFast without any strategies (comparable to AFL but with exponential power schedule) However, after 24 hours, AFLFast with both strategies exposes almost twice as many unique crashes as AFLFast with no strategy or with only strategy 1 Figure 10: #Crashes over Time (Schedules) 10For more details see Section 4|,Non-data,22
3 104155 Result Summary We evaluated AFLFast and several schedules plus search strategies on the GNU binutils The exponential schedule outperforms all other schedules while our search strategies turn out to be e↵ective,Non-data,22
| In eight runs of six hours, AFLFast with an exponential schedule found an average of more than one order of magnitude more unique crashes than AFL for the tools nm and c++filt; it found crashing inputs for obj- dump where AFL did not expose any crashes at all In eight runs of 24 hours, AFLFast found 6 vulnerabilities in nm 7x faster than AFL and exposed 3 vulnerabilities that were not exposed by AFL AFLFast also exposes two bugs in nm (that are unlikely exploitable) about seven times faster than AFL and exposed one bug that is not exposed by AFL An in- dependent evaluation of Team Codejitsu on all 150 binaries that are provided in the benchmark for the Cyber Grand Challenge establishes similar results|,Non-data,22
| On average, AFLFast exposes an error 19 times faster than AFL and also exposes 7 errors that are not found by AFL, at all 6 RELATED WORK Several techniques [30, 17, 6, 22] have been proposed to in- crease the e ciency of automated fuzzing An important op- timization pertains to selecting the seed inputs wisely from a wealth of inputs [17]|,Non-data,22
| Our work makes no assumptions about the existance seed inputs; we seeded our experiments with the empty file However, Coverage-based Greybox Fuzzing (CGF) would clearly benefit from a smart seed selection if many seed files are available Others suggest to use program analysis to detect dependencies among the bit positions of an input [6] For instance, the image width occupies four bytes in the PNG image file format which are best modified together|,Non-data,22
| The dependency analysis allows to fuzz such de- pendent bytes as a group In our work, we do not change the mutation operators or ratio Woo et al [30] recognize the exploration-exploitation trade-o↵ between fuzzing an input for a shorter versus a longer amount of time|,Non-data,22
| They proceed to model blackbox fuzzing as a multi-armed bandit problem where the seed’s “energy” is computed based on whether or not it has exposed a (unique) crash in any previous fuzzing iteration So, the fuzzer is e↵ectively biased towards gener- ating more crashing inputs for already known errors In our work, there is no such bias Instead, we direct the search towards low-frequency paths in order to stress more of the program’s behavior in the same time|,Non-data,22
| Symbolic execution-based whitebox fuzzers can generate files that stress low-frequency paths Probabilistic symbolic execution [10] uses model counting to compute the proba- bility that a random input exercises a given path Symbolic execution is very e↵ective because it enumerates paths es- sentially independent of their “frequency” and because it can be directed towards “dangerous” program locations [5, 8, 11, 2] It can generate the specific values that are needed in order to negate an if-condition and exercise the alternative branch|,Non-data,22
| Taint-based fuzzing [9, 29] is a directed whitebox fuzzing technique It exploits classical taint analysis to lo- calize parts of the input which should be marked symbolic For instance, it marks portions of the input file as sym- bolic that control arguments of executed and critical system calls Model-based Whitebox Fuzzing [16] leverages an input model to synthesize and “transplant” complete data chunks to exercise so called critical branches that are only exercised if a certain data chunk is present in the input file|,Non-data,22
| However, symbolic execution-based techniques rely on program anal- ysis and constraint solving which hampers their scalability Imprecisions during lifting of the program binary and during the encoding of the path constraints hamper their applica- bility In contrast, CGF completely relinquishes program analysis for the sake of scalability with tremendous success in the vulnerability detection practice [27] Colleagues have combined lightweight blackbox/greybox fuzzers and symbolic execution-based whitebox fuzzers to get the best of both worlds [19, 15]|,Non-data,22
| For instance, Hybrid- Fuzz first runs symbolic execution to generate inputs leading to “frontier nodes” and then passes these inputs to a black- box fuzzer In contrast, Driller [19] begins with AFL and seeks help from symbolic execution when it “gets stuck”, for instance, to generate a magic number Our monotonous power schedules allow to employ expensive symbolic execu- tion for seeds/states with a su ciently high energy Markov chains can model a variety of random processes in fuzz testing|,Non-data,22
| Markov Chain Monte Carlo Random Testing (MCMC-RT) uses a Markov Chain Monte Carlo (MCMC) method to leverage knowledge about an input’s probability to reveal an error However, MCMC-RT is not entirely scal- able because it maintains this probability for every input in the program’s input space While CGF can be well explained as Markov chain, it does not actually maintain the chain or any probabilities in-memory While MCMC-RT is biased to- wards revealing suspected or known errors, CGF can expose unknown errors that hide deep in the program|,Non-data,22
 The bias of boosted CGF is towards low-frequency paths Chen et al [7] utilize MCMC to leverage knowledge about a mutation operator’s e↵ectiveness Operators that have been shown to be more e↵ective in previous fuzzing iterations are chosen with greater probability during fuzzing,Non-data,22
| Sparks et al [18] model program control-flow as Markov chain to prioritize seeds that exercise less explored paths In contrast, we use Markov chains to explain why it is more e cient to smartly control the time spent fuzzing a seed and which seed to fuzz next without program analysis 7|,Non-data,22
| CONCLUSION While symbolic execution-based techniques have gained prominence, their scalability has not approached those of blackbox or greybox fuzzers While blackbox and greybox techniques have shown e↵ectiveness, the limited semantic oversight of these techniques do not allow us to explain the working of these techniques even when they are e↵ective In this work, we take a state-of-the-art greybox fuzzer AFL which keeps track of path identifiers We enhance the e↵ectiveness and e ciency of AFL in producing crashes, as evidenced by our experiments and those of our collabora- tors|,Non-data,22
| AFLFast, our extension of AFL exposes an order of magnitude more unique crashes than AFL in the same time budget Moreover, AFLFast can expose several bugs and vulnerabilities that AFL cannot find Other vulnerabilities AFLFast exposes substantially earlier than AFL More importantly, we provide an explanation of the en- hanced e↵ectiveness by visualizing CGF as the exploration of the state space of a Markov chain|,Non-data,22
| We observe that ex- isting CGF tools much too often visit states in high-density regions We have devised and investigated several strategies to force the CGF tool to visit more states that are otherwise hidden in a low-density region and to generate less inputs for states in a high-density region 10428 ACKNOWLEDGMENTS This research was partially supported by a grant from the National Research Foundation, Prime Minister’s O ce, Singapore under its National Cybersecurity R&D Program (TSUNAMi project, No|,Non-data,22
|ABSTRACT Covert channels present serious security threat because they allow secret communication between two malicious pro- cesses even if the system inhibits direct communication We describe, implement and quantify a new covert channel through shared hardware random number generation (RNG) module that is available on modern processors We demon- strate that a reliable, high-capacity and low-error covert channel can be created through the RNG module that works across CPU cores and across virtual machines We quan- tify the capacity of the RNG channel under different set- tings and show that transmission rates in the range of 7-200 kbit/s can be achieved depending on a particular system used for transmission, assumptions, and the load level|,Non-data,23
| Fi- nally, we describe challenges in mitigating the RNG channel, and propose several mitigation approaches both in software and hardware CCS Concepts •Security and privacy → Side-channel analysis and countermeasures; Security in hardware; Keywords Covert channels; Random number generator 1 INTRODUCTION Modern computer systems are commonly shared among multiple groups of applications executing in different secu- rity domains The security domain determines if an ap- plication can be granted access to certain data, perform privileged operations, or communicate with other applica- tions|,Non-data,23
| Such application isolation is typically implemented using system software, and the safety of user data critically depends on this support The general principle of least priv- ilege [46], which applies to many systems including the An- droid OS [15], advocates granting each application only a minimal set of permissions that are sufficient to support its Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted|,Non-data,23
| To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acmorg CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s)|,Non-data,23
 Publication rights licensed to ACM ISBN 978-1-4503-4139-4/16/10  ,Non-data,23
 $1500 DOI: http://dxdoiorg/10,Non-data,23
|1145/29767492978374 proper functionality For example, an application managing local personal data should be restricted from communicating over the network However, a sophisticated attacker or a malicious devel- oper can use two colluding applications to create an attack that would send personal data over the network under such restrictions|,Non-data,23
| The first malicious application has access to personal data and the second application has the network access For consistency with previous works in this area, we refer to the first application as the trojan and the second application as the spy To create an attack, the adversary first passes sensitive data from the trojan to the spy and then uses the spy to send the data over the network How- ever, since the trojan and the spy reside in two different security domains, a properly implemented permission sys- tem prevents them from directly communicating with each other|,Non-data,23
| To bypass this restriction, the trojan and the spy can communicate using covert channels created by modulating the use of shared hardware resources in a microprocessor Recent literature demonstrated many types of timing chan- nels through shared CPU resources and their application to secret key reconstruction [36, 29], secret communication [17, 44] and bypassing of security mechanisms [13, 16, 25] These implicit channels can even be used to compromise security of systems that provide hardware supported isolated execution environments [40, 10, 11, 57] Covert channels are particularly dangerous in virtualized environments, such as computational clouds|,Non-data,23
| Since virtual- ization naturally provides logical isolation between processes executing in different virtual machines, such environment seemingly provides a safe platform for manipulating secret data Monitoring network traffic or direct information flows would prevent a malicious program from sending sensitive data to the outside world [6, 4, 42, 45] Unfortunately, these safety guarantees can be bypassed if the attackers can com- municate through covert channels In general, covert channels can be categorized into tim- ing channels and storage channels [31]|,Non-data,23
| Timing channels are created when the trojan performs manipulations with a shared resource in a way that interferes with the timing of some operations performed by the spy In contrast, a storage channel is created by explicitly or implicitly writ- ing a value to a shared resource by the trojan so that this write can be observed by the spy Previous works demon- strated the exploitation of several shared hardware resources to create covert communication channels These include the CPU functional units [53], the on-chip caches [56, 39], the AES hardware [22], the branch predictor [14, 12, 22] and the 843memory bus [55]|,Non-data,23
| The temperature of the CPU cores has also been used as covert channel media and temperature- based channels have been shown to exist between air-gaped systems [18] Researchers also demonstrated the feasibility of covert channels in GPGPUs [43] While a number of covert channels inside a modern mi- croprocessor chip have been demonstrated (as exemplified above), many of these channels have significant practical limitations These include low transmission rate, difficulty of establishing and maintaining the channel, low resiliency to system noise and external interference, and fairly simple solutions to mitigate the channel|,Non-data,23
| More details are presented in the related work section In this paper, we discover, implement and analyze a new covert channel that exploits hardware random number gen- eration (RNG) module as the channel media In most re- cent Intel processors (based on Skylake microarchitecture), the hardware RNG module is shared between all processor cores and is connected to them through the ring intercon- nect The RNG module has a fixed number of precomputed random bits that are stored inside the module and are sup- plied to instructions that request a random seed|,Non-data,23
| Once the random bits stored inside the RNG module are used, it takes a significant amount of time to regenerate them using the entropy source available in silicon Consequently, the trojan can either exhaust the RNG module causing the spy to fail in its request for a random seed, or avoid using the RNG and allow the spy to succeed in its requests Consequently, the trojan can use these two scenarios to either transmit a one or a zero to the spy Compared to previously demonstrated covert channels, the RNG channel has many important advantages from the attacker’s standpoint|,Non-data,23
| The RNG channel is fast, has low error rate, is easy to establish and maintain, and works re- liably across CPU cores and virtual machines The channel readings are easy to obtain without any system calls, be- cause software (the spy in this case) is directly informed by the RNG module when an attempt to acquire a random seed fails In this sense, the RNG channel is the storage channel and thus its maintenance does not require access to the processor timing infrastructure which often requires privileged access The RNG module is rarely used in typi- cal workloads, therefore the RNG channel is not impacted by the external interference|,Non-data,23
| Finally, the RNG channel is difficult to mitigate in a non-virtualized system because the RNG instructions cannot be disabled by the operating sys- tem and are used directly from user space without system calls In addition, techniques that disable or fuzz [21, 37, 51] with the processor timekeeping facilities will not provide protection in this case, because the RNG channel does not rely on timing infrastructure The main contributions and the key results of this paper are: • We introduce a new covert communication channel that uses hardware random number generation mod- ule that is available in modern processors and is shared among all CPU cores • We demonstrate this channel on a recent Intel Skylake processor and show that the channel reliably works across CPU cores and virtual machines|,Non-data,23
| Furthermore, the channel can be established and maintained purely from the user space without requiring any system calls • We quantify the capacity of the RNG channel under different scenarios While the capacity of the hardware channel itself can be as high as 3 Mbit/s in idealistic scenario, we show that transmission rates between 7 kbit/s and 200 kbit/s can be realized depending on the system and the load level during transmission • We present a simple implementation of the RNG covert channel transferring bytes of data over the channel with the support for error correction and synchroniza- tion|,Non-data,23
| This end-to-end channel supports transmission rates of up to 7 kbit/s • We explore the impact of other system activities (such as the intense GPU activity) on the channel quality and show that the impact is minimal, thus making the RNG channel robust to the internal system noise • We discuss the difficulties involved in mitigating the RNG channel and propose two software and two hardware-supported mitigation schemes The soft- ware schemes involve modifications to the hypervisor to handle the timing of the rdseed instructions differ- ently and also running a background thread to create the RNG noise|,Non-data,23
| Hardware approaches include modi- fications to the RNG logic to remove the dependency of the rdseed instruction delays on the instructions generated by another thread 2 BACKGROUND Secure generation of truly random values is essential for producing encryption keys to support cryptographic opera- tions Using weak sources of randomness during key gener- ation process is a well-known security threat [9, 32, 3, 28]|,Non-data,23
| Random numbers can be generated either in software or in hardware Software schemes [19] use various sources of en- tropy with non-deterministic nature, such as the disk seek time, the timing between user keystrokes, and the movement of the mouse Software techniques are often slow, require user involvement, and do not have enough true entropy [26] In contrast, hardware-based random number generators do not exhibit such limitations|,Non-data,23
| Hardware generators rely on sources of non-determinism in silicon, such as the thermal noise [5], providing provable randomness at high speed [50] To equip programmers with a fast, secure and easy source of random and pseudo-random numbers, hardware develop- ers started to embed random number generators (RNG) in- side the CPU chips For example, Intel introduced the new hardware RNG [23] in their Ivy Bridge microarchitecture In the initial offering, only pseudo-random number genera- tor was available via the new rdrand instruction|,Non-data,23
| The later Broadwell microarchitecture introduced the new rdseed in- struction to add the capability to read true random numbers derived directly from the entropy source AMD also added support for rdrand instruction and plans to add support for rdseed instruction in the upcoming microarchitecture IBM POWER7+ also has hardware-based true random number generator [35] Without loss of generality, the demonstration of the RNG covert channel in this paper is performed on Intel’s CPU based on Skylake microarchitecture|,Non-data,23
| Figure 1 depicts a high- level overview of the RNG mechanism in Skylake processor The Entropy Source derives the entropy bits from thermal noise within the silicon at the rate of around 3 Gbit/s The 844ments Since the interconnection network is shared among all components, the activity of other devices can affect the timing of rdseed requests and result deliveries|,Non-data,23
| 3 THREAT MODEL AND ASSUMPTIONS We assume that the attacker controls two malicious ap- plications in the system - the trojan and the spy The tro- jan is a more privileged process that has access to sensitive data that it attempts to transmit to the spy process No other communication channels (through the network, shared memory, file system, etc|,Non-data,23
|) exist between the trojan and the spy, therefore these two processes can only communicate by means of covert channels We also assume that both the trojan and the spy have access to shared hardware RNG module The system software is assumed to be secure, so that it properly enforces the access control and preserves legitimate information flows The two processes only require normal user-level privileges|,Non-data,23
| The RNG channel does not require access to performance counters, and therefore would work even if these counters are disabled as is commonly done on cloud systems [58] Creating the channel also does not re- quire access to processor timekeeping resources, therefore we assume that any protection that fuzz the resolution of the CPU timers can be in place 4 COVERT CHANNEL THROUGH INTEL RNG HARDWARE In this section we demonstrate how the RNG hardware can be utilized to construct a fast and reliable inter-core covert channel|,Non-data,23
| We begin by demonstrating our ideas to implement covert communication within a single process, and then build up to practically usable channels 41 RNG Channel in a Single-Process The fundamental principle of data transmission through RNG is to control the contention for random values accu- mulated in the Conditioner Buffer (CB) by modulating the number of rdseed instructions executed at a given time in- terval To transmit secret information, the trojan process either creates the high contention or the low contention for the use of CB resources|,Non-data,23
| The high contention is created when the CB is exhausted and the new rdseed requests fail In contrast, the low-contention condition is created when there are available entries in the CB We assume that the high contention is associated with the trojan sending a value of ”1” and the low contention is associated with the trojan sending a value of ”0” To estimate the theoretical maximum capacity of the RNG channel, we first describe its idealized implementa- tion|,Non-data,23
| The conditions required for this idealized scenario are, of course, impossible to support in a real-world environment Our goal here is to estimate the upper bound on the trans- mission rate through the RNG channel A CPU core can produce rdseed requests at a faster rate than the rate of refreshing the RNG hardware Therefore, it is possible for the trojan process (or a group of processes) to create and sustain a situation where the CB has just enough bits to support a single rdseed instruction|,Non-data,23
| At the same time, the spy process constantly executes one rdseed instruction and checks its status at the same rate as the rate of replenishing the CB In such a setup, the trojan can send ”1” by execut- Figure 1: Organization of RNG Module in Intel Processors quality of randomness is then verified by performing sev- eral health tests Bits that passed the health tests form a pair of 256-bit numbers that are fed into the Conditioner This circuitry distills the entropy into more concentrated single 256-bit sample|,Non-data,23
| The 256 bits are stored as four 64-bit random values in Conditioner Buffer (CB), thus allowing to serve up to four rdseed instructions requiring 64-bit seeds The outputs of the conditioner are then used directly by the rdseed instruction logic In addition, the output bits of the conditioner are used to seed the deterministic random number generator This generator uses CTR DRBG pseudo random number generator and is accessed by the rdrand instruction|,Non-data,23
| While both of the above instructions are used to obtain random bits, there are significant differences between them The rdrand instruction produces deterministic random num- bers that depend on the instruction’s previous outputs Con- sequently, the rdrand instruction should not be used for se- curity critical tasks requiring true randomness, such as the key generation In contrast, the rdseed instruction outputs true random numbers|,Non-data,23
| However, the rdseed instruction has a much lower throughput Based on our observations, while the throughput of the rdrand instruction is almost always sufficient to service all hardware threads constantly requesting pseudo-random bits, the resources of the rdseed instruction are easily ex- haustible This temporal exhaustion of resources needed by the rdseed instruction is the key observation exploited in creating the RNG-based covert channel Both rdrand and rdseed instructions explicitly inform the software on about successful completion by setting the carry flag|,Non-data,23
| The rdseed instruction does not have any fairness mechanism built into it, therefore the availability of the random bits at the time of high demand has probabilistic nature Modern processors, such as the Intel’s Skylake, are de- signed as complex System-on-Chip (SoC) with many com- ponents placed on the CPU die and interconnected to- gether These components include multiple cores, banks of the shared last-level cache, graphics processing unit (GPU), memory and PCI-express controllers and other peripheral hardware units Recent Intel processors utilize the ring- based interconnect topology [27] in which all on-chip com- ponents are connected in a closed loop|,Non-data,23
| The RNG module is organized as an independently clocked device built-in into the processor chip and connected via the ring While pub- licly available documentation does not specify how exactly the RNG module is placed on this network, it is reasonable to assume that the connection is similar to any other device; this assumption is supported by the results of our experi- Entropy SourceHealth TestsConditionerConditioner BufferDeterministicRNGseedCore 0Core 1Core 2Core 3rdrandrseed845ing a single rdseed instruction and it can send ”0” by not executing it Hence, in order to estimate the time required to transmit a single bit from the trojan to the spy, we need to know the latency of the rdseed instruction and the rate at which the CB is replenished This communication proto- col’s algorithm is demonstrated in the pseudo-code form in Listing 1|,Non-data,23
| To empirically determine the latency of the rdseed in- struction, we developed a benchmark that executes and mea- sures the latency of 2 000 rdseed instructions To allow the RNG to refill the CB during each iteration, we executed 1 million nop instructions before executing the rdseed instruc- tions Executing this benchmark, we observed that the av- erage latency of rdseed instructions was not identical when they were issued from different CPU cores The results of this experiment are presented in Figure 2 with data collected on each core shown in a different color|,Non-data,23
| As seen from the figure, the number of cycles taken by the rdseed instruction is lowest on core 0 (average of 402 cycles), and it is the high- est on core 3 (417 cycles) The Simultaneous Multithreaded (SMT) virtual cores (cores 4, 5, 6 and 7) have similar la- tencies Such variation in instruction latencies can be at- tributed to the specifics of the communication between the computing cores and the peripheral RNG module through the ring interconnect For the CPU with 4 Ghz frequency, each rdseed instruction takes about 0|,Non-data,23
|1 microsecond on the average The CB update rate was determined using the following experiment We executed a stream of rdseed instructions on a core, checked their success status and counted the num- ber of successful instructions Since the core issues requests for random seeds at much higher frequency than the RNG hardware can produce, our experiment estimates the max- imum throughput of the RNG and thus the refill rate of the CB|,Non-data,23
| We observed that rdseed instructions can be suc- cessfully executed each 032 microseconds Therefore, the CB is updated at a rate that is about three times slower than the rate at which the rdseed instructions can execute Consequently, the CB update becomes the bottleneck in our idealized covert channel scenario, thus determining the max- imum theoretical capacity of such idealized channel|,Non-data,23
| Assum- ing that one bit can be transferred in 032 microseconds, the resulting bit rate (and thus the channel capacity) is 3125 Mbit/s This number represents the upper bound on the ca- pacity of a channel that can be obtained through the RNG hardware|,Non-data,23
 42 Creating a Robust Channel in Single- Process Setting A successful implementation of a covert channel requires solving two orthogonal problems The first problem is how to transfer data through the shared media efficiently and with low error rate The second problem is how to synchro- nize the spy and the trojan processes,Non-data,23
| Since our main goal is to study the methodology for using the RNG hardware as a covert channel and to estimate its capacity, we primarily focus on the first problem We address the synchronization problem in Section 46 In addition, synchronization pro- tocols presented in prior works [22, 48, 55] can be used to fine-tune the timings of communication phases|,Non-data,23
| The assumptions used in the previous subsection for es- timating the maximum channel bit rate cannot be met in practice due to several reasons • The RNG hardware itself does not impose time lim- its in which the CB must be refilled Although the hardware derives random bits at a constant rate, the built-in health checks can create some disparity and thus the CB can be replenished at arbitrary time • Other system-level activity such as context switches and accesses to shared caches by other processes can distort the perfect synchronization of the trojan and the spy|,Non-data,23
| • The RNG hardware is integrated into the processor chip as one of the peripheral devices sitting on a shared interconnect network Therefore, the activity in this network can interfere with the fine-grain timing re- quired for the idealized covert channel One option to bypass these limitations is to adapt the protocols used by the trojan and the spy by using slower bit rate or by using error-correcting codes [20] However, such optimizations would significantly reduce the effective capac- ity of the channel, we describe the use of error-correcting codes later|,Non-data,23
| We now examine the interference problem due to the ac- tivity of other resources connected to the ring interconnect in more detail Through experimentation, we observed that the Graphics Processing Unit (GPU) has the highest effect on the rdseed latency compared to other components con- nected to the ring interconnect This can be an artifact of the RNG module placement on the ring, and high in- terference between the GPU-generated traffic and the RNG requests To assess the impact of such GPU interference, we mea- sured the rdseed instruction latencies under two conditions: 1) the Graphical User Interface (GUI) is disabled and there is no GPU activity in the system; and 2) the system per- forms active 3D animation|,Non-data,23
| Both parts of the experiment were conducted on the same core The results are presented in Figure 3 As seen from the figure, the GPU activity in- troduces periodic, but significant delay into the RNG oper- ation The average values of the rdseed latency are 912 and 400 cycles with and without the GPU activity respectively|,Non-data,23
| The slowdown is only observed during the phases of active animation For example, GUI is enabled but the image is not moving, the results are similar to the case without GUI Similar levels of interference were observed when the GPU was performing 2D animation (for example, a video play- back) or computations on the GPU were performed when running OpenCL [49] code On the other hand, our experi- ments showed that CPU-intensive activity does not increase the rdseed instruction latency|,Non-data,23
| Interference from the GPU makes it impossible for the trojan process to perform high-accuracy manipulations re- quired to create the idealized channel described earlier In particular, the variability of rdseed instruction timing intro- duces uncertainty in terms of when the request for random bits will be delivered to the RGN module Thus, the tro- jan process can no longer keep the exhausted state of the CB, therefore making it difficult to construct a channel that exploits the fine-grained capabilities of the RNG As an alternative to fine-grain approach to channel cre- ation, the trojan and the spy can use a more coarse-grained approach of treating the entire CB as a single unit and en- coding transmission bits by altering high and low contention 846Protocol 1 Fine-grained communication protocol DSend[N ], DRecv[N ] : N bits to transmit and receive; NP rime : Number of rdseed instructions to empty the CB Trdseed : Time needed to execute rdseed instruction; TRef ill : Time needed for RNG to refill one CB entry TP rime : Time needed to execute NP rime rdseed instructions wait(T ): Wait for time T ; rdseed(): Execute rdseed, returns False if failed Trojan’s operation: for i ← 0 to NP rime − 1 do Spy’s operation: wait(TP rime) Description: rdseed() for j ← 0 to N − 1 do if DSend[i] = 0 then wait(TRef ill) else rdseed() wait(TRef ill − Trdseed) Trojan prepares removing all of its entries the CB by for j ← 0 to N − 1 do wait(Trdseed) status ← rdseed() if status = True then DRecv[i] ← 0 DRecv[i] ← 1 else Each cycle a single CB entry is generated|,Non-data,23
| Trojan transfers 1 by consuming this entry, and 0 by allowing the spy to consume it Listing 1: A fine-grained communication protocol (Protocol 1) Figure 2: Latency of rdseed instruction on different CPU cores Figure 3: Latency of rdseed instruction with and without GPU interference phases for the entire unit To this end, we now describe a protocol that creates the RNG channel that is resilient to interference from the GPU and other hardware components connected to the ring The noise resiliency comes with a slightly lowered channel capacity The pseudo-code of the coarse-grain RNG covert channel is presented in Listing 2|,Non-data,23
| Transmission of a single bit of information through this channel consists of two stages In stage 1, the trojan creates a desired contention state of the CB If the trojan wishes to transmit a ”0”, it performs a busy wait The waiting time (TRef ill) is the time needed for the CB to be refilled, as determined by the CB refill rate|,Non-data,23
| If the trojan wishes to send a ”1”, it executes NP rime rdseed instructions To equalize the time needed to send both values prior to priming the CB, the trojan performs a short wait 1  The spy process remains inactive during stage 1 and waits for this stage to finish During stage 2, the spy probes the CB to determine the CB’s state by executing NP robe rdseed instructions and checking their status|,Non-data,23
| If any of these rdseed instructions fails, then the spy detects the exhausted state of the CB, treating this event as the reception of ”1” It is important to execute not one, but several rdseed instructions in order to mitigate possible CB refill during the probing process, as the exact timing of such refill is impossible to predict The trojan remains inactive during stage 2 The bit rate of this channel depends on the number of rd- seed instructions required to exhaust the CB and to detect such exhaustion, and the number of cycles required for the CB to be fully refilled|,Non-data,23
| Therefore, to estimate the channel bit rate, it is necessary to determine the values of NP rime, NP robe and TRef ill The best values for NP rime and NP robe depend on the capacity of the CB Although the buffer itself is only 256- bit long, it is constantly updated Therefore, the practi- cal capacity (the number of bits the CPU can receive from the RNG without a failure) is higher than its size|,Non-data,23
| We de- termined such capacity by conducting the following experi- ment For each instruction sequence of size N , we performed several steps First, we execute a large number (1 million) of 847Protocol 2 Coarse-grained communication protocol DSend[N ], DRecv[N ] : N bits to transmit and receive NP rime : Number of rdseed instructions to prime CB; NP robe : Number of rdseed instructions to probe CB TP rime : Time for trojan to prime CB; TP robe : Time for spy to probe CB; TRef ill : Time for a full CB refill wait(T ): Wait for time T ; rdseed(): Execute rdseed, returns False if failed Trojan’s operation: for i ← 0 to N − 1 do Spy’s operation: for i ← 0 to N − 1 do Description: if DSend[i] = 0 then wait(TRef ill) else 1 wait()(TRef ill − TP rime) for j ← 0 to NP rime − 1 do rdseed() wait(TP robe) wait(TRef ill) f ail ← False for j ← 0 to NP robe − 1 do status ← rdseed() if status = False then f ail ← True Stage 1 Depending on the value to be sent, the trojan either removes all entries from the CB (primes it) or waits for the CB to refill Stage 2|,Non-data,23
| The spy probes the CB by executing a sequence of rdseed instructions and checking their status if f ail = True then DRecv[i] ← 1 DRecv[i] ← 0 else Listing 2: A coarse-grained communication protocol (Protocol 2) nop instructions allowing the CB to refill The nop instruc- tions serve the purpose of busy wait Since no other pro- cesses are using the RNG hardware at this point, the buffer is guaranteed to be full by the end of this step Following that, we executed the sequence of N rdseed instructions and checked for their status|,Non-data,23
| If one of these instructions failed, we recorded a failure If no failures were observed, we recorded a successful sequence We collected 1 million measurements for each sequence size and calculated average values The results are pre- sented in Figure 4|,Non-data,23
| As seen from the figure, a process can always successfully execute a sequence of 5 rdseed instruc- tions without any failures (failure rate 0%) Since each in- struction fetches 64 bits, the practical capacity of the CB is 320 bits, which is 64 bits more than CB’s physical size A sequence of 6 rdseed instructions also has a low failure rate of 123%|,Non-data,23
| As the number of instructions in the sequence continues to increase, the probability of success drops fur- ther since it is less likely for the RNG to refill the CB by the time the request arrives The failure rates of sequences of size 7 and 8 are 286% and 1598% respectively|,Non-data,23
| Starting from sequence size of 9, the failure rate approaches 100%, with only a small number of successful sequences out of one million attempts The results of the above experiment can be used to detect the appropriate values for NP rime and NP robe Selecting the value of NP rime greater or equal to 5 ensures that the CB is exhausted during the prime stage The value of NP robe needs to be selected to allow the detection of missing CB en- tries with high probability, but with minimal false-positives|,Non-data,23
| Choosing the value of NP robe equal to 5 provides the maxi- mum sequence with zero failure rate To select the optimal value of TRef ill, we performed an- Figure 4: Failure rate of rdseed instruction groups executed on core 0 other experiment First, we primed the CB with a large number of requests for seed values, thus draining all ran- dom bits from it Second, we allowed the RNG module to stay idle by executing a parameterizable number of nop instructions|,Non-data,23
| Third, we repeatedly executed five rdseed in- structions and checked the failure status of this sequence For each value of the waiting period, we repeated the ex- periment one million times and calculated the average fail- ure rate The results are presented in Figure 5 As seen from the figure, any waiting period shorter than 3 000 cycles does not allow the CB enough time to be fully refilled to service five successive rdseed instructions|,Non-data,23
| As the waiting time grows, the failure rate decreases When the number 123456789101112131415Number of RDSEED instructions in sequence00%200%40|,Non-data,23
|0%600%800%1000%Percent of sequences encountered a fail848of cycles spent in waiting stage approaches 7 000, the fail- ure rate becomes very low|,Non-data,23
| Since the probabilistic nature of CB refill frequency makes it impossible to precisely compute the perfect value of TRef ill, one can experimentally select a value that results in a low waiting period and a low failure rate We conservatively chose the waiting period value of 7 800 cycles for subsequent channel capacity estimation as it demonstrates a very low error rate the GPU activity has a notable effect on the time needed by the CPU to service an rdseed instruction When the GPU is performing active animation, the rdseed instructions are significantly slowed down, thus interfering with the data en- coding mechanism described in Protocol 2|,Non-data,23
| In particular, slowed down delivery of seed requests allows the RNG mod- ule to have more time to re-generate random bits and refill the CB This distorts the correct channel functionality dur- ing the transmission of ”1”, because the correctness hinges on the predictable exhaustion of the CB Based on our ob- servations, the GPU activity can result in situations when even a CB that was fully exhausted during the priming stage will successfully provide five random seeds without a single failure In such a case, the spy will incorrectly decode a ”0”|,Non-data,23
| Erroneous switching from ”0” to ”1” is also possible Such errors happen when the CB is not given a sufficient amount of time to re-generate the random bits, which results in a failure It appears that the number of such errors does not depend on external interference from the GPU and has a probabilistic nature Therefore, a longer wait time (TRef ill) results in less errors of this type, but the channel bit rate is reduced|,Non-data,23
| Figure 5: Percentage of failed 5-long rdseed instruction se- quences after the CB is allowed to rest for a given number of cycles Equipped with these parameters, we can now estimate the RNG channel bit rate under this setting The bit rate can be calculated as 1/(cid:0)M ax(TP rime, TRef ill) + TP robe (cid:1) In the Prime stage (stage 1), the trojan either executes five rd- seed instructions (to transfer ”1”) or busy-waits (to transfer ”0”) for the length of TRef ill Since each rdseed instruction takes about 400 cycles, the total time to execute five such instructions is 2 000 cycles|,Non-data,23
| Therefore, the duration of the prime stage is determined by the larger value of busy-wait time and is 7 800 cycles Note that when the trojan commu- nicates a ”1”, it can first busy-wait for 5 800 cycles and then perform five rdseed instructions to match the time required to transmit a ”0” Alternatively, the trojan can execute rd- seed instruction for the whole duration of the 7 800 cycles prime period The duration of the probe stage (stage 2) is 2,000 cycles, because only five rdseed instructions need to be executed by the spy|,Non-data,23
| Therefore, 9 800 cycles are required to transmit a single bit of information (2 000 + 7 800) Since our experimental processor is clocked at 4GHz, this trans- lates into the bit rate of 408 kbit/s Note that the chan- nel bit rate is mostly dictated by the characteristics of the RNG module itself and is almost independent of the CPU speed For example, in processors with lower frequency, the latency of rdseed instructions and the number of CPU cy- cles required to refill the CB will also decrease|,Non-data,23
| Therefore, the channel bit rate is likely to stay at a similar level 421 Channel Capacity Estimation in Noisy Envi- ronments The RNG covert channel that we described above features high bit rate with a low error rate|,Non-data,23
| However, several sources of interference exist that can increase the channel’s error rate An abstract scheme showing the channel operation un- der noise is shown in Figure 6 As we described previously, Using the parameters selected earlier, we constructed a benchmark to evaluate the error rate of the channel and cal- culate its capacity We assume that our channel is mem- oryless, i|,Non-data,23
|e the output probability only depends on the current input, and not on previous channel states To cor- rectly compute the error rate under this assumption, we base our computations on transmitting random bits through the channel Specifically, we generated 100 million random bits, transferred them through the RNG channel, and computed the error rate separately for transmitting zeroes and ones|,Non-data,23
| We observed that the error rate was different when sending ones and when sending zeroes Therefore, the channel can be characterized as a binary asymmetric channel with noise The capacity of such channel can be calculated using the equation below [41] Hb(0) (cid:19) Hb (0 )−Hb (1 ) 1−0−1 (1) C = 0 1 − 0 − 1 Hb(1) − 1 − 1 1 − 0 − 1 (cid:18) + log2 1 + 2 where 0 is the probability of the trojan sending ”0” and spy receiving ”1” and 1 is the probability of a bit flip when the trojan sends ”1”|,Non-data,23
 Such transitions are demonstrated in Figure 6 Hb(p) is the binary entropy function of probability p which is defined as: Hb(p) = −p log2 p − (1 − p) log2(1 − p) (2) Figure 6: Binary asymmetric channel with noise between the trojan and the spy Values 0 and 1 represent probabilities of errors when the trojan sends ”0” and ”1” respectively 20003000400050006000700080009000 10000Number of cycles spent in the waiting stage0%20%40%60%80%100%Average failure rateTrojanSpy01011−ε01−ε1ε0ε1849We evaluated the RNG channel based on Protocol 2 under the following settings,Non-data,23
| • No GUI: System’s GUI was disabled • Static GUI: The GUI was enabled, but no active an- imation was performed • 2D: The GUI was enabled and a window was moved on the desktop while performing the benchmark • 3D: A 3D benchmark was executed during the covert channel operation, creating a high GPU load|,Non-data,23
| The results of these experiments are presented in Table 1 As seen from the results, the GPU activity, even 3D anima- tion, impacts the channel capacity only slightly, still allowing the attackers to maintain the bit rate of about 390 kbit/s No GUI Static GUI 000066 0|,Non-data,23
19719 2982e-05 000029 2D 020122 0,Non-data,23
60933 3D 019959 084875 099578 0,Non-data,23
98784 096276 095437 406 443 403 198 392 965 389 540 0 1 Bits per Channel Use Channel Capacity (bit/s) Table 1: Channel Characteristics Under Noisy Conditions 43 Detecting the Trojan and the Spy Up until now we described the RNG channel in the frame- work of one process,Non-data,23
| The focus of previous discussions was on the hardware vulnerability itself and the quantification of a possible threat If we now consider covert communication through the RNG module by two different processes, then a problem that is common to all covert channels arises: how to synchronize the trojan and the spy To properly synchro- nize the transmission, both the trojan and the spy have to be made aware of the other’s presence, so that the trans- mission and reception only occur when the two processes are running simultaneously In addition, a mechanism for acknowledging the reception of data has to be incorporated|,Non-data,23
| In this section, we design the synchronized communication protocol that utilizes the RNG hardware for sending both data and acknowledgments In realistic system operation, a process context switch (or a VM switch in virtualized systems) is the most significant obstacle to synchronized data transmission For example, when the trojan process is scheduled by the OS, it has no in- formation on whether the spy process is running on another core or not The temporal inactivity of the spy process leads to the loss of large amount of bits — this is known as burst erasure [34]|,Non-data,23
| In a similar spirit, it is difficult for the spy to distinguish the absence of the signal (when the trojan is switched out) from a sequence of zeroes sent by the trojan While it is possible to adopt error correcting codes [30] that can correct burst erasures [34], this significantly complicates the design and lowers the channel capacity In any case, the ability to detect the presence of the other party needs to be added to both the trojan and the spy We now demonstrate how this can be accomplished using the same RNG hardware module that is used as the communication medium|,Non-data,23
| 431 Detecting the Spy As shown in the code of Protocol 2, the spy process mea- sures the CB contention by executing five rdseed instruc- tions at the probing stage of each communication cycle Note that this activity by itself creates contention for the CB|,Non-data,23
| Even if the CB was full prior to the probing stage, the five rdseed instructions executed by the spy will empty the CB The next communication cycle begins right after the probing stage of the spy completes, with the trojan either waiting or priming the CB with new rdssed instructions If the bit to be communicated by the trojan is ”1”, the trojan has the ability to not only execute the five priming instruc- tions, but also check for their status If the instruction se- quence fails, the trojan can detect the presence of the spy since the CB was accessed right before the trojan began the priming stage|,Non-data,23
| Such capability of the trojan to perform the CB priming and probing at the same time enables the detection of the spy’s presence without incurring the loss of channel capacity Therefore, the trojan can check for the spy’s presence every time it primes the CB When the trojan cannot detect the spy, it can temporary interrupt the trans- mission and continue probing the CB until the spy process is switched back in 4|,Non-data,23
|32 Detecting the Trojan Detecting the trojan process is more tricky The Na ̈ıve im- plementation of communication protocol relies on the Non- Return-to-Zero (NRZ) line code In this code, ”one” (the presence of contention) is encoded by a high voltage level, and ”zero” (the absence of contention) is encoded by a low voltage level|,Non-data,23
| The problem is that it is impossible for the spy to distinguish the absence of the trojan process from the tro- jan that sends a sequence of zeroes We address this problem by adopting the Manchester coding In Manchester coding, ones and zeroes are encoded as state transitions, rather than the states themselves Therefore, during each communica- tion cycle, even when the trojan sends ”0”, there will be the high and the low contention levels|,Non-data,23
| This allows the spy to detect the absence of the trojan when it does not see high contention levels While this approach lowers the bit rate of the channel, it allows for a clear and easy way for the spy to detect the absence of the trojan Similar mechanism was used in [55] to synchronize their covert channel Combining the techniques for detecting the presence of spy and trojan processes, the RNG channel becomes self- synchronized|,Non-data,23
| Occasional communication errors can be de- tected and corrected with proper error correcting codes 44 Supporting Error Correction in Multi- Process Setting In previous subsections, we estimated the capacity of the RNG covert channel in several different ways by modeling the behavior of the spy and the trojan in a single process scenario This estimation quantifies the potential threat of exploiting the RNG hardware as a covert channel|,Non-data,23
| In this section, we demonstrate the implementation of the RNG channel under realistic multi-process scenario where the spy and the trojan are two different processes running on the same machine The implementation is based on the trans- mission principles described in the earlier sections, and we also take into account errors that can inevitably occur dur- ing the transmission As we described earlier, whether the rdseed instruction 850succeeds or fails is a probabilistic function even in cases when high demand for random seeds is created Therefore, it is impossible to implement an error-free RNG channel using the existing RNG hardware|,Non-data,23
| To implement reliable commu- nication over the RNG channel in the presence of occasional errors, it is necessary to carefully select and use a proper Error Correcting Code (ECC) We now describe how this can be accomplished in a simple and effective way Most commonly used ECCs are block codes that operate on a block-by-block basis A popular variation of such codes is the Reed-Solomon [54] (RS) group of codes|,Non-data,23
| The RS code is capable of detecting and correcting a number of corrupt- ed/erased symbols in a block The number of symbols the code can correct depends on the specific parameters of the code and is highly configurable An RS code is typically de- scribed by a set of parameters: s is the number of bits per code symbol; n is the number of symbols per block, and k is the message length in symbols per block The parameter t represents the number of symbols that can be corrected in each block|,Non-data,23
| It is defined as t = (n−k)  For example, the widely used code with n = 255 and m = 223 is usually de- noted as RS(255,223) and it is capable of correcting up to 16 erroneous symbols In order to select appropriate parame- ters of the code, one must determine the maximum possible number of corrupted symbols that can appear in a block and set the parameter k accordingly 2 To make the RNG channel compatible with the RS codes, we adjusted the communication protocol based on Protocol 1 to send and receive bytes instead of the individual bits|,Non-data,23
| We used Protocol 1 as a starting point for this experiment because it is based on simultaneous execution of the trojan and the spy and is easier to use in this case A limitation of the byte-granularity channel is its lower tolerance to errors, because an error in any bit of a transmitted byte corrupts the entire byte To overcome this limitation, we used the following approach We reduced the speed of the trojan while keeping the speed of the spy at the maximum level|,Non-data,23
| This allows the spy to perform multiple measurements (14 measurements in our setup) during the transmission of each bit by the trojan This approach also has the additional advantage of easing the timing constraints Figure 7 demonstrates the spy’s observations when the trojan transfers a byte with the bit value of 10110011 In this protocol, the spy makes the decision about the received value based on the majority of its readings|,Non-data,23
| In most cases when the trojan transfers logical ”0”, the spy observes a se- quence of all zeroes Decoding of such readings is straight- forward However, when logical ”1” is transferred, some of the readings will appear to the spy as zeroes The spy can make a decision based on the number of observed ones in a sequence of readings|,Non-data,23
| We adjust this threshold in such a way that minimizes the number of incorrectly decoded bits For example, the leftmost bit in the sequence is decoded as logical one, because most of the readings are ones, as seen from the figure The next bit is decoded as logical zero We set the number of rdseed instructions that the spy executes during each probing stage in such a way that allows the spy to monitor the state of the RNG module at any given time, but at the same time creating minimal parasitic contention from performing the probes|,Non-data,23
| We implemented this channel and discovered that it takes 200 657 cycles to transmit one byte of data, which involves making the required number of probes by the spy and stor- Figure 7: Spy’s observation when the trojan transfers a byte of data over the channel ing the values read by these probes in memory Thus, the attackers can transmit 19 93442 bytes per second|,Non-data,23
| This esti- mation assumes ideal inter-byte synchronization so that the primes and probes occur at exactly the same time In prac- tice, context switches and timing variations may distort this synchrony We discuss possible solutions to synchronization and demonstrate one of them in Section 46|,Non-data,23
| Although the rate of about 20 kB/sec is lower than the theoretical rates that we showed above, the channel can still be considered as a high-bandwidth channel We studied this channel under several noisy conditions To be consistent with the previous measurements, we evaluated the chan- nel under the same effect of the GPU noise as we did in Section 42|,Non-data,23
|1 We did not measure the impact of legiti- mate programs that use RNG hardware in our evaluation model, because normal programs request random seeds very rarely, usually only during startup and initial key genera- tion Such events do not create a steady contention for the random seeds and thus do not introduce significant noise Programs that have high demand for the random values (e|,Non-data,23
|g Monte Carlo simulations) rely on pseudo-random [8] num- bers, rather than on true random seeds This is one of the critical advantages for considering the RNG hardware unit as covert communication medium To perform this experiment, we first set up the RNG chan- nel equipped with ECC to transfer blocks of 255 bytes|,Non-data,23
| Fol- lowing that, we evaluated the channel under different noise conditions and recorded the maximum number of errors ob- served in any of the transferred blocks for each environment setting This statistics allowed us to select the best value of parameter k for each case This parameter was selected to allow the correction of all errors that occurred during our ex- periments The resulting error rates, along with the value of parameter k and the resulting channel bit rates are presented in Table 2|,Non-data,23
| As seen from the presented data, the observed er- ror rate increases with the interference from the GPU which confirms the earlier observed behavior However, we note that covert channels are considered more dangerous in server machines which usually do not have graphics Even in the case of active 3D animation performed in the background, the channel error rate is still within acceptable ranges and can be easily corrected with the use of ECC Finally, we note that the bit rates reported here should 10111001851Maximum block error rate (= t) k Bit rate with ECC (bytes/s) No GUI Static GUI 6 11 2D 3D 33 40 243 18 996 233 18 215 189 14 775 13 680 175 Table 2: Channel Characteristics Under Noisy Conditions not be interpreted as the maximum achievable practical bit rate|,Non-data,23
| Further optimizations such as more sophisticated en- coding/decoding and aggressive timing optimizations can achieve higher rates Our goal was to demonstrate that rea- sonably high transmission rates can be achieved even with a simple implementation 45 Capacity Estimation of Multi-process Channels With the trojan and the spy detection capability in place, the actual channel capacity when operating in a multi- process setting will be limited by the amount of time that the spy and the trojan execute simultaneously on two different cores|,Non-data,23
| Naturally, this time depends on the OS scheduling and also on the external system load (eg on other pro- cesses also running in the system at the same time) To estimate the impact of scheduling and interference on the achievable transmission rate, we performed the experiments on three different systems: a desktop system with 4-core processor running standard user environment applications, a server-class system with 16 computing cores, and a dedi- cated virtual machine running on Amazon EC2 cloud|,Non-data,23
| For each experiment, we measured the percentage of trojan’s cy- cles during which the spy also executes on one of the other cores We did not change the scheduler policy and allowed normal competition for the time resources with other pro- cesses The results are presented in Table 3 Desktop Server EC2 Clean Loaded Clean Loaded Normal Load 0|,Non-data,23
937 1874 0991 1982 0,Non-data,23
319 638 0179 358 0,Non-data,23
850 170 71212 24244 75316 13,Non-data,23
|604 646 P Protocol 2 bit rate (kbit/s) ECC nel bit (kbit/s) chan- rate Table 3: Fraction of time P the trojan runs simultaneously with the spy and estimated bit rate For each system, the table shows the percentage of cycles (out of the total trojan’s cycles) when the trojan and the spy are co-executing together (P) It also shows the result- ing channel capacity that would be achieved on each system under each scheduling scenario and the additional load from external processes We used two baseline capacities|,Non-data,23
| First is the upper bound capacity of 400 kbit/s as shown in Table 1 (Protocol 2 channel) and the second capacity of 152 kbit/s (189 kB/S) with built in error correction as shown in Ta- ble 2 (ECC channel) We used the value of P to adjust the capacities under the normal scheduling policies For exam- ple, if the value of P is 0|,Non-data,23
|5, then 50% of the time the trojan executes together with the spy and the capacity in this case would decrease by two times For the desktop system in a clean state (no other processes are running), the spy runs alongside trojan 94% of the cy- cles, resulting in the channel capacity of 375 and 142 kbit/s for the channel based on Protocol 2 and the ECC-equipped channel respectively In order to allow the spy to detect when the trojan is not executing, the usage of Manchester codes is needed as we discussed in Section 43|,Non-data,23
|2 Incorpo- rating Manchester codes into the ECC channel results in the reduction of the throughput by two times Although 8 bits are still transferred and decoded, only 4 bits are then extracted by the spy However, to be consistent with our previous ECC parameters, we let the ECC still operate on the symbol size s of 8|,Non-data,23
| The spy simply combines two 4-bit symbols into one and uses it in error correction As a result, the capacity is lowered by a factor of two Resulting bit rates when Manchester codes are used are 187 and 71 kbit/s for Protocol 2 and ECC channel respectively We also ex- perimented with noisy environment, where two CPU-bound external processes are scheduled on the cores where the tro- jan and the spy execute|,Non-data,23
| In this case, the co-scheduled time is only about 32%, resulting in the channel capacity of 64 and 24 kbit/s for the two channels (again, accounting for the effects of Manchester encoding) On the server, the co- scheduled percentages are 99% which results in bit rates of 198 and 75 kbit/s In noisy environment, the two processes are co-scheduled 18% of the time, resulting in the bit rate of 36 and 14 kbit/s for both channels We also performed scheduling experiments on the EC2 cloud with normal load|,Non-data,23
| In this setting, the experimental VM shares the hardware with other VMs running on the cloud The trojan and the spy run together 85% of the time, resulting in the channel capacities of 170 and 65 kbit/s for the two channels In all of these scenarios, a high-capacity channel can be realized 4|,Non-data,23
|6 Channel Synchronization: Simultaneous Scheduling Intervals In previous sections, we demonstrated the RNG covert channel in single and multi-process settings, discussed how to detect the presence of trojan and spy, and demonstrated how to adapt the transmission protocol to incorporate the error correction using Reed-Solomon ECC However, previ- ous discussions and results assume ideal internal synchro- nization and the described channels are suitable for the transmission of short byte-sized messages We conclude the attack part of this paper by demonstrating a simple covert channel synchronization mechanism to support the transmission of longer messages Our implementation is simple and is only intended to show practical end-to-end RNG channel realization|,Non-data,23
| Higher transmission rates can be realized using more complicated fine-grain synchronization schemes, this is left for future work To understand the need for synchronization, consider a situation when the trojan is interrupted by a context switch in the middle of its message, and later resumes execution In this case, both the trojan and the spy need to know that the transmission resumes when the trojan is rescheduled More generally, both processes need to know when the message begins and when it ends|,Non-data,23
| Synchronization of this nature is not a problem that is unique to the RNG channel — any covert channel needs to be synchronized Several previous studies considered this problem For example, [22] used the idea of a pilot signal For simplicity, we implemented a dif- ferent approach that we call Simultaneous Scheduling Inter- 852vals (SSI)|,Non-data,23
| The key idea is to schedule the trojan and the spy for short time intervals, so that they run simultaneously multiple times per second without interrupts During each interval, the transmission of a single byte occurs The syn- chrony is achieved by accurately aligning the times when the trojan and the spy wake up for the next interval To implement SSI, we relied on the timer_create POSIX interface available on Unix-like systems|,Non-data,23
| Specifically, both the trojan and the spy use this system call to request to be woken up 1,000 times per second During each interval, the two processes send and receive a small amount of data Due to the very short duration of the execution periods, the trojan and the spy are not interrupted by the OS To synchronize the clocks more closely, both processes perform some additional tuning during the first interval|,Non-data,23
| Specifically, they read the system timer (with microsecond resolution), and insert the additional sleep time to the first execution interval to end it at the millisecond boundary, or as close to it as possible After that, the scheduling of the conse- quent intervals occurs at the millisecond boundaries, with slight deviations due to system noise The OS assures that these deviations do not accumulate over consecutive inter- vals and synchronous execution of the two processes is sus- tained Our experiments showed that these deviations do not impact the transmission and error-free channel can be realized in this manner|,Non-data,23
| Note that the nature of this par- ticular approach to synchronization also makes the spy and the trojan detection unnecessary, thus obviating the need for Manchester coding However, Manchester coding will still be needed if more fine-grain and high-performance syn- chronization schemes are used The simplest way to use the SSI synchronization is to transmit a single bit during each interval This results in a bit rate of 1 kbit/s, but does not require ECC or Manchester coding|,Non-data,23
| Our experiments showed that on a clean system such bit rate can be reliably achieved with no errors, as the clocks of the trojan and the spy are very closely synchronized with typical deviation of about 3-5 microseconds It is also possible to use SSI for transmitting a byte of data per inter- val However, occasional decoding errors occur in this case, requiring ECC for error correction According to our exper- iments, the average error rate of 0|,Non-data,23
|9% was observed The maximum number of errors in a block of 255 bytes (ECC parameter t) was observed to be 19 Therefore, for this ex- periment 38 ECC bytes of ECC are needed inside every 255 bytes of transmitted data to correct all errors Consequently, the channel bit rate is 6|,Non-data,23
|8 kbit/s While representing a true end-to-end transmission rate that we achieved on a real sys- tem, this number should not be viewed as the best achiev- able rate Timing optimizations and more efficient fine-grain synchronization can increase the channel capacity further 5|,Non-data,23
| MITIGATING THE RNG COVERT CHANNEL The new covert channel through the RNG hardware mod- ule presented in this paper imposes security risks that have to be addressed In general, several classes of mitigation techniques against side channels and covert channels to elim- inate information leakage are well known from prior litera- ture, and some of these can be adapted to mitigate the RNG channel These solution classes include static partitioning of hardware resources, approaches targeted at equalizing access delays by different instructions, and approaches designed to complicate or disable the usage of timekeeping infrastruc- ture by the attackers In terms of closing the RNG covert channel, the defense goal is to ensure that the latency (and, more specifically, the failures) experienced by an rdseed in- struction executed by one process is not impacted by any activity of another process|,Non-data,23
| Compared to many other architectural covert channels, the RNG channel is relatively more difficult to mitigate This is because the communicating processes in most covert channels have to rely on a measurement mechanism by ei- ther using hardware performance-monitoring counters [22] or the processor time stamp counter [39] The access to these counters is typically offered through the use of spe- cific instructions, such as rdpmc and rdtsc on x86 systems However, since these instructions can carry a potential se- curity risk, the hardware designers make their availability configurable|,Non-data,23
| In particular, system software can set up these instructions to be either available to software executing at any privilege level, or restrict it to only software executing in ring 0 Restricting the usage of these instructions to ring 0 programs essentially closes the user-level covert channels that rely on such measurement Since accurate and frequent time measurement is criti- cal for proper functionality of many applications, techniques have been proposed to make the timing measurements less precise (thus distorting the timing channels), while main- taining the capabilities of benign applications [37, 51] How- ever, fuzzing with or disabling the time measurement infras- tructure does not close the RNG channel, because the CPU explicitly informs the software about the availability of ran- dom bits|,Non-data,23
| Moreover, operating systems in non-virtualized environments cannot restrict programs from executing the rdseed instructions, thus making it impossible to mitigate the RNG channel by simply applying configuration tweaks in such systems In the rest of this section we propose two software mitiga- tion techniques that can either disable the RNG channel or bring its capacity down to impractical levels In addition, we propose two hardware-supported mechanisms to make the design of RNG modules in future processors immune to the exploitation as covert channel media 5|,Non-data,23
|1 Software Mitigations First, we describe possible software-only protections from the RNG channel We propose two software-based mitiga- tions: one approach is based on the support available in Intel-based virtualized systems, and the other approach re- lies on executing a background thread to add constant load on the RNG hardware 51|,Non-data,23
|1 Virtualization Based Solution As we discussed above, the OS does not have the capabili- ties to directly disable the RNG channel However, it is pos- sible to mitigate the RNG channel in a virtualized system Specifically, the Intel virtualization technology [24] (VMX) allows to configure the hardware to cause a VM exit oper- ation and trap into the Virtual Machine Monitor (VMM) every time rdrand and rdseed instructions are executed by a guest VM This provides an effective mechanism to control accesses by guest VMs to the RNG hardware and allows for a number of defenses to be implemented within the VMM to disable the RNG covert channel|,Non-data,23
| 853One mitigation technique that can be implemented within the VMM is to completely emulate the functionality of the RNG hardware in software Specifically, whenever a trap to the VMM occurs after the guest VM executes the rdseed instruction, the VMM provides a software-generated random value Unfortunately, this approach loses the benefits of pure hardware-based random seed generation Another solution is to add the capability of distributing random seeds to the VMM itself|,Non-data,23
| In particular, the VMM software can execute the rdseed instructions to fill up its own pool of random seeds and then pass these seeds to the guest VMs whenever a VM makes an attempt to execute the rdseed instruction Finally, the VMM can introduce a delay following a trap from the VM upon encountering the rdseed instruction and then return the control to the VM If the delay is sufficiently long to allow the RNG hardware to completely replenish its random bits, then no rdseed instruction will experience failure because they are separated by a sufficient number of cycles The VMM-based mitigations described above will cur- rently only work on Intel processors|,Non-data,23
| While AMD processors do not implement the rdseed instruction, they support the rdrand instruction The support for rdseed is expected to be added to AMD processors in the next microarchitecture revision According to recent documentation [1], the AMD virtualization hardware does not allow configuring it to pro- duce a VM exit when executing rdrand Unless this support is added with the introduction of the rdseed instruction, al- ternative mitigation strategies for AMD processors have to be used|,Non-data,23
| 512 Equalizing the RNG Loading If the VMM-based solution described above can be used, it represents the simplest way to mitigate the RNG covert channel However, virtualization is not always used or is not always available|,Non-data,23
| Another potential limitation of VMM- based approach is that it may not always be possible to modify the VMM’s code In those cases, alternative solu- tions need to be used Another approach to mitigating the RNG channel is to make the load on the RNG module equal at any time, thus making it impossible for the attackers to encode information using the RNG state For example, if we introduce constant high-intensity demand for the RNG services in the back- ground, then the spy process will always detect the high- contention RNG state, making it impossible to distinguish between one and zero for data transmission using the RNG channel|,Non-data,23
| We propose to achieve such constant pressure on the RNG hardware by dedicating a hardware thread to repeatedly ex- ecute the rdseed instructions at a high rate To evaluate the effectiveness of such mitigation, we repeated the experiment described in Section 421 by transmitting a large number of bits (100 million bits) through the RNG channel using Protocol 2|,Non-data,23
| The only difference was that this time we also executed the protection thread in the background (on one of the available cores) that presented constant high-level de- mand for the RNG hardware As expected, the noise process significantly interferes with the functionality of the RNG channel Specifically, almost all of the transferred bits were decoded as ”1” by the spy process, regardless on their actual value For example, of the 50 million zeroes that were trans- mitted, only 556 were correctly received by the spy|,Non-data,23
| This translates into the values of 0 and 1 of 099998886 and 254e-06, the transmitted bits per one channel use of 2132e- 06, and the resulting theoretical bit rate of 0|,Non-data,23
|87 bit/s An extremely high error rate caused by this protection makes the channel with such a low bit rate (less than a bit per sec- ond) unusable for transmitting any practical information While the protection based on running a spurious thread looks expensive, it can be enabled only when the system detects that potential trojan and spy processes have been scheduled This protection also does not impede the capa- bility of processes to obtain small random seeds|,Non-data,23
| Based on our experiments, a process can still receive seeds, possibly after repeating the attempts several times In particular, when a single RNG-equalizing process is present, a legiti- mate process needs to perform 5 failed rdseed attempts on average before succeeding Since random seed generation is an infrequent operation in typical scenarios during normal program execution, the normal system functionality is not significantly distorted by this mechanism 5|,Non-data,23
|2 Hardware-supported Mitigations In future systems, the hardware design itself can be modi- fied to mitigate the RNG-based covert channel We describe two possible approaches that future RNG modules can im- plement to support security: equalization-based approach and partitioning-based approach 52|,Non-data,23
|1 Equalizing Delay of rdseed Instructions To eliminate the RNG-based channel, future RNG hard- ware can be designed in a way that ensures uniform latency of every rdseed operation and eliminates random seed re- quest failures First, the explicit failure signal that the RNG hardware currently uses to inform software about the lack of random bits can be eliminated Instead, the rdseed in- structions can be required to wait until the random bits are replenished if the module is currently out of bits This tweak does not completely eliminate the vulnerability, but requires the attackers to use timing infrastructure instead of capital- izing on the explicit failure signal|,Non-data,23
| This makes the attack more difficult and allows the defenses based on fuzzing the timers to be used Going a step further, the hardware can also equalize the timing of each rdseed request by main- taining only a single 64-bit random seed inside the RNG unit When a request is made, the RNG unit will first gen- erate another seed and only then return the original seed to the requesting process This also eliminates failures and simplifies the RNG hardware design, removing the need for multiple CB entries|,Non-data,23
| The drawback of this approach is in- creased delay of the rdseed instructions However, since these instructions are typically not used often, such an in- crease may be acceptable Another potential problem is that it is not clear how the increased delays of some instructions impact interrupt handling and the application’s response to interrupts 5|,Non-data,23
|22 Partitioning RNG Resources If the performance impact of the equalization-based ap- proach described above is too high, or significant issues with interrupt handling arise, an alternative mechanism can also be implemented in hardware, where vulnerable hardware re- sources of the RNG module can be fairly partitioned among the CPU cores Specifically, each core can be assigned a slice 854of the CB and can only operate on that slice As a result, the RNG activity performed by one process (the trojan) sched- uled on one core will not impact a successful completion of an rdseed instruction issued by another process (the spy) executed on another core|,Non-data,23
| Consequently, the RNG channel disappears This approach requires a larger number of en- tries in the CB, but supports high performance and security Partitioning the CB bits closes all inter-core channels, only leaving the possibility of a channel when the trojan and the spy are consecutively scheduled on the same core To pre- vent such a channel, the RNG logic must ensure that the CB slice belonging to the core on which the communicating processes execute is completely refilled during the context switch interval|,Non-data,23
| Fortunately, this is already the case with the current RNG implementation According to our evalua- tion, the complete CB refill takes about 175 microseconds, while the context switch interval is typically around 3-4 mi- croseconds [33, 47] 6|,Non-data,23
| RELATED WORK Several covert channels through shared processor re- sources have been described and analyzed in recent litera- ture In this section, we review some of these related works and contrast them with the RNG channel described in this paper The work of [56] presented a cross-VM covert channel through the L2 cache According to the results, the L2 chan- nel has a theoretical capacity of 262 bit/s, which is signifi- cantly lower than the capacity of the RNG channel|,Non-data,23
| Under realistic loads in EC2 cloud, the mean bit rate was reported to drop further to 32 bit/s with the error rate of above 9% Since the L2 cache is private to each core, the chan- nel can only be used when two virtual machines share the same CPU Core migration drastically reduces the channel’s capacity|,Non-data,23
| Maurice et al [39] developed a cross-core covert chan- nel through shared Last Level Caches (LLC) The authors demonstrated the bit rate of about 1300 bit/s for a non- virtualized setup, and 751 bit/s for a virtualized setup Set- ting up the channel through the LLC requires significant ef- fort and understanding of complex LLC addressing nuances|,Non-data,23
| In contrast, the RNG channel only requires simple manipu- lations with RNG instructions and trivial knowledge about the details of the RNG module operation The work of [55] presented a timing covert channel be- tween virtual machines exploiting contention on the memory bus through the use of atomic memory instructions The au- thors achieved the channel transmission rate over 700 bit/s in their laboratory setup and over 100 bit/s in Amazon EC2 cloud This channel works in cross-core and cross-VM set- ting|,Non-data,23
| All channels created through caches and memory bus re- quire access to either processor timekeeping infrastructure or to the hardware performance counters to allow the spy to time the events and recognize transmission of bits However, the access to such infrastructure is not always available at the user level In addition, such access can be disabled just to secure systems against such channels Wang et al|,Non-data,23
| [52] an- alyzed timing channels through shared memory controllers and proposed techniques to close this channel Hunger et al [22] present an excellent summary of multiple covert chan- nels, including the ones through caches, memory bus, branch predictor and the AES hardware They also analyze chan- nel capacities and discuss synchronization protocols|,Non-data,23
| [14, 12] perform a detailed analysis of covert channels through branch prediction units The branch predictor channels only work if the trojan and the spy execute on the same physical core, either in two hardware thread contexts of a simulta- neously multithreaded processor, or consecutively scheduled on a single-threaded core Because the channel is on a single core, no additional synchronization is required in this case CC-Hunter [7] is a technique that detects the presence of covert timing channels by dynamically tracking conflict patterns on shared processor hardware|,Non-data,23
| In principle, if CC- Hunter can be repurposed to track the rdseed events, it is conceivable that it will detect the RNG-based channel, but further investigations are needed to establish that Besides exploiting the shared physical CPU structures as covert communication medium, recent work also inves- tigated the use of thermal characteristics of the CPU for secret data transmission [38, 2] This example demonstrates that unexpected covert channels can be created and it is important to investigate, discover and mitigate all sources of such covert communications This paper makes a contri- bution in this direction by uncovering a new and powerful covert channel and proposing software and hardware miti- gations for it|,Non-data,23
| 7 CONCLUDING REMARKS In this paper, we introduced a new covert communication channel using the shared hardware random number gener- ator unit as communication medium The key idea is to control the pressure on the shared RNG hardware unit by the sender by either executing a sequence of rdseed instruc- tions or busy-waiting, thus impacting the behavior of the rdseed instructions issued by the receiver We showed that this channel works reliably and with high transmission rate across cores and across virtual machines and can be imple- mented directly within user space with no OS assistance|,Non-data,23
| In addition, we showed that the RNG channel can be created without relying on any processor timekeeping infrastructure or hardware performance counters The above characteristics make the RNG channel easy to establish and difficult to mitigate In terms of protection, we proposed two software approaches and two hardware ap- proaches The software approaches either utilize support available on Intel virtualization platforms to handle the rd- seed instructions in special ways or executing the additional thread to create constant pressure on the hardware RNG unit|,Non-data,23
| The hardware approaches are based on either equaliz- ing the timing of the rdseed instructions across threads, or partitioning the RNG resources among cores to remove the dependency of instruction latencies issued by one thread on the instructions of the other For secure system design, it is important to develop ar- chitectures that do not have paths for information leakage, either through side channels or covert channels To this end, it is critical to discover the new vulnerabilities in the existing and emerging systems and propose defenses against them This paper makes contributions on both of these fronts|,Non-data,23
| 8 ACKNOWLEDGMENT We would like to thank our shepherd Edward Suh for his insight and suggestions for improving the paper, and the anonymous reviewers for their useful comments This mate- 855rial is based on research sponsored by the National Science Foundation grant CNS-1422401 49th International Symposium on Microarchitecture (MICRO) (2016)|,Non-data,23
|ABSTRACT Differential privacy is a precise mathematical constraint meant to ensure privacy of individual pieces of information in a database even while queries are being answered about the aggregate Intuitively, one must come to terms with what differential privacy does and does not guarantee For exam- ple, the definition prevents a strong adversary who knows all but one entry in the database from further inferring about the last one This strong adversary assumption can be over- looked, resulting in misinterpretation of the privacy guaran- tee of differential privacy|,Non-data,29
| Herein we give an equivalent definition of privacy using mutual information that makes plain some of the subtleties of differential privacy The mutual-information differential privacy is in fact sandwiched between -differential privacy and (, δ)-differential privacy in terms of its strength In con- trast to previous works using unconditional mutual informa- tion, differential privacy is fundamentally related to condi- tional mutual information, accompanied by a maximization over the database distribution The conceptual advantage of using mutual information, aside from yielding a simpler and more intuitive definition of differential privacy, is that its properties are well understood|,Non-data,29
| Several properties of differ- ential privacy are easily verified for the mutual information alternative, such as composition theorems Keywords Differential privacy, information theory 1 INTRODUCTION Differential privacy is a concept proposed in [12] for database privacy|,Non-data,29
| It allows queries to be answered about aggregate quantities of data while protecting the privacy of individual entries in the database In the absence of a precise mathe- matical framework such as differential privacy, practitioners have been tempted to use various rules-of-thumb to pro- tect privacy (eg “don’t answer a query that averages fewer than k entries together”—see the query restriction approach Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page|,Non-data,29
| Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acm|,Non-data,29
|org CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s) Publication rights licensed to ACM ISBN 978-1-4503-4139-4/16/10|,Non-data,29
   $1500 DOI: http://dx,Non-data,29
doiorg/101145/29767492978308 in [1]),Non-data,29
| Instead, differential privacy directly addresses the statistical distinguishability of the database and has led to algorithms for answering general queries with just the right amount of randomness used in order to preserve privacy1 Differential privacy requires that two adjacent databases, which differ in only one entry, are statistically indistinguish- able, as measured by a probabilistic metric defined in Sec- tion 2 This guarantee is particularly effective for making in- dividuals feel comfortable contributing personal information to a dataset For instance, if a person decides to participate in a survey, his answers only constitute one response out of the entire collection, and the responses of other people re- main unchanged|,Non-data,29
 Differential privacy is meant to assure the one participant that his answers are concealed This privacy metric has gained a lot of traction in recent years The main contribution of this work is to cast differen- tial privacy as a mutual information constraint There have been many attempts in the literature to connect differen- tial privacy to mutual information,Non-data,29
| Here we give not only a connection but an equivalence To briefly summarize the main result, consider a database X n = (X1,   |,Non-data,29
| , Xn) that returns a query response Y accord- ing to a random mechanism PY ||Xn  Let X−i denote the set of database entries excluding Xi Definition 1 ((, δ)-Differential Privacy [13]) A ran- domized mechanism PY ||Xn satisfies (, δ)-differential privacy if for all neighboring database instances xn and ̃xn PY ||Xn=xn (,δ)≈ PY ||Xn= ̃xn , (1) where the approximation in (1) is defined later in Defini- tion 4, and neighboring database instances are defined in Definition 3 as any pair of database vectors that differ in only one entry (i|,Non-data,29
e Hamming distance one)2 Definition 2 (Mutual-Information Diff Priv,Non-data,29
|) A randomized mechanism PY ||Xn satisfies -mutual-information differential privacy if I(Xi; Y ||X −i) ≤  nats (2) sup i,PXn Note that nats are the information units that result from using the natural logarithm instead of the logarithm base two, which would give bits 1Differential privacy does not assume the adversary has any computational limitation|,Non-data,29
| 2Another similar definition for “neighbor” exists in the liter- ature, involving the removal of one entry of the database 43The main claim of this paper, which appears in Section 3, is an equivalence between mutual-information differential privacy (MI-DP) and the standard definition of (, δ)-differential privacy ((, δ)-DP) The original definition of differential pri- vacy [12], defined formally in Section 2, parameterized pri- vacy with a single positive number  For various reasons it has since been relaxed [13] to have two parameters  and δ playing multiplicative and additive roles in the likelihood constraint|,Non-data,29
| We refer to the original DP as -DP and the relaxed form as (, δ)-DP In this notation, -DP is simply (, 0)-DP The claim herein is that MI-DP is sandwiched between these two definitions in the following sense: It is weaker than -DP but stronger than (, δ)-DP That is, a mechanism that satisfies -DP also satisfies -MI-DP|,Non-data,29
|3 Similarly, if -MI-DP holds then ((cid:48), δ)-DP also must hold, where (cid:48) and δ vanish as  goes to zero In fact, the connection between MI-DP and (, δ)-DP is an equivalence if either the domain or range of the query mechanism is a finite set The advantage of this alternative but equally strong defi- nition of differential privacy is that mutual information is a well-understood quantity It provides a clear picture of what differential privacy does and does not guarantee|,Non-data,29
| Further- more, several properties of differential privacy are immediate to prove in this form While the mathematics of differential privacy, in its stan- dard form, are straightforward, an intuitive understanding can be elusive The definition of (, δ)-DP involves a notion of neighboring database instances Upon examination one realizes that this has the affect of assuming that the ad- versary has already learned about all but one entry in the database and is only trying to gather additional information about the remaining entry|,Non-data,29
| We refer to this as the strong adversary assumption, which is implicit in the definition of differential privacy Notice that MI-DP needs no definition of neighborhood The strong adversary assumption is made explicit in the conditioning within the conditional mutual information term The strong adversary assumption is both a feature and a vulnerability of the definition of differential privacy|,Non-data,29
| It is a feature when recruiting individual participants for a survey The individual can decide whether or not to participate but cannot do anything about the information contributed by others (which may inform on them indirectly) Differential privacy assures them that even with access to everyone else’s responses, the survey reports will not further reveal anything about their individual response However, DP also has its shortcomings as a privacy guarantee|,Non-data,29
| Among all adversaries with different prior knowledge of the database, the strong adversary may not be the one which benefits the most from the query output Indeed, it is shown in [18] that a weaker adversary can compromise privacy severely if the entries in the database are correlated, which is quite typical in certain applications such as social networks As an equivalent privacy metric, MI-DP benefits and suf- fers in the same way Fortunately, the definition of MI- DP puts this potential weakness in plain sight|,Non-data,29
| It shows explicitly that information leakage is only being restricted conditioned on the remainder of the database being known Clearly, this does not bound the unconditional mutual in- formation when correlations are present 3The other direction is not true in general, as there exist mechanisms which satisfy -MI-DP but not (cid:48)-DP for any (cid:48) Somewhat paradoxically, mutual information can serve si- multaneously as both a measure of privacy, as in MI-DP, and as a quantification of utility—for example, the mutual infor- mation between the entire database and the query response, I(X n; Y )|,Non-data,29
| The close connection between mutual information and estimation and detection further captures the privacy- utility trade-off Several works [20, 9, 4, 3, 10] relate mutual information to differential privacy by upper bounding mutual information given a differential privacy achieving mechanism One com- mon point of these works is that they all use unconditional mutual information rather than conditional Often, the con- clusion is a bound on the unconditional mutual information between the whole database and the private output|,Non-data,29
 The use of conditional mutual information in Definition 2 captures the prior knowledge of the database possessed by a potential adversary (ie the strong adversary assumption implicit in DP) This is crucial in developing an equivalence with the standard DP definition,Non-data,29
| Another crucial ingredient that some of the literature fails to properly incorporate (eg [25]) when applying mutual in- formation to differential privacy is that differential privacy is a property of the query mechanism and assumes no specific prior distribution on the database Mutual information, on the other hand, is not well defined without a joint distri- bution, which must include a distribution for the database|,Non-data,29
| The remedy is to maximize the mutual information over all possible distributions on the database, as seen in the defini- tion of MI-DP in Definition 24 Had we defined MI-DP with respect to any particular database distribution (eg with independent and identically distributed entries), we would have significantly reduced its strength as a privacy metric|,Non-data,29
 The formula in Definition 2 in fact looks like a channel ca- pacity formula one would encounter in expressing the fun- damental limit of communication through a noisy channel This maximization removes any distributional assumption and makes MI-DP a property of the mechanism itself 2 PRELIMINARIES 2,Non-data,29
|1 Notation The set {1, 2,··· , m} is denoted as [m] An index set I is a subset of [n] whose elements are enumerated as (i1,··· , i||I||), where || · || denotes the cardinality of a set We use X n as shorthand notation for the sequence of ran- dom variables (X1,··· , Xn) The symbol X−i denotes the sequence of n−1 random variables (X1,··· , Xi−1, Xi+1,··· , Xn), in other words, all of X n except Xi|,Non-data,29
| The lower case symbol x−i is an instance of X−i For any index set I, we use XI to denote the sequence of random variables (Xi1 ,··· , Xi||I|| ) specified by I Similarly the lower case xI = (xi1 ,··· , xi||I|| ) is an instance of XI A database X n consists of n entries, where the i-th entry takes values from Xi|,Non-data,29
| Definition 3 (Neighbor) Two database instances xn and ̃xn are neighbors if they differ in only one entry In other words, dH (xn, ̃xn) = 1, where dH (·,·) is Hamming distance 4This approach, using worst-case database distribution, ap- pears in various works throughout the literature, e|,Non-data,29
g [11] (3) 44The output of a privacy mechanism is a random variable represented as Y and takes values from Y 2,Non-data,29
|2 Statistical Indistinguishability Two probability distributions can be considered statisti- cally indistinguishable if they are close under an appropri- ate metric The criterion for indistinguishability used in the standard definition of differential privacy is the following Definition 4 ((, δ)-Closeness) Two probability dis- tributions P and Q over the same measurable space (Ω,F) are (, δ)-close, denoted as (,δ)≈ Q P if P (A) ≤ eQ(A) + δ, Q(A) ≤ eP (A) + δ, ∀A ∈ F , ∀A ∈ F |,Non-data,29
| (4) (5) (6) Consider two special cases, δ = 0 and  = 0 If δ = 0, then P and Q are mutually absolutely continuous, denoted as P (cid:28)(cid:29) Q, and (, 0)-closeness is a statement about the Radon-Nikodym derivative dP dQ : (cid:12)(cid:12)(cid:12)(cid:12)ln (cid:12)(cid:12)(cid:12)(cid:12) ≤  ∀a ∈ Ω dP dQ (a) (7) (,0)≈ Q ⇐⇒ P On the other hand, with  = 0, (0, δ)-closeness is a statement about the total variation distance: (0,δ)≈ Q ⇐⇒ (cid:107)P − Q(cid:107)T V ≤ δ P (8) We can also relate (, δ)-closeness to Kullback-Leibler di- vergence, denoted as D(·(cid:107)·)|,Non-data,29
| For example, by relaxing the right side of (7) to be an expected value rather than a state- ment about all a ∈ Ω, we immediately get the following implication: (,0)≈ Q =⇒ D(P(cid:107)Q) ≤  nats, D(Q(cid:107)P ) ≤  nats P (9) Tighter expressions of the relationship to Kullback-Leibler divergence are given next, in Properties 1 and 2 We give a proof of Property 1 in Appendix A Property 1|,Non-data,29
| P (,0)≈ Q =⇒ D(P(cid:107)Q) ≤ min(cid:8), 2(cid:9) nats, D(Q(cid:107)P ) ≤ min(cid:8), 2(cid:9) nats (e − 1)(cid:0)1 − e−(cid:1) (e − 1)(cid:0)1 − e−(cid:1) D(P(cid:107)Q) ≤  (e − 1) + (1 − e−) D(Q(cid:107)P ) ≤  (e − 1) + (1 − e−) (,0)≈ Q =⇒ P In fact, the tightest possible statement of this form is nats, nats (11) Equality on the right side of (11) can be achieved with bi- nary distributions For small , the right side of (11) is asymptotically 1 2 2 nats|,Non-data,29
| Property 1 and Property 2 are strict in the sense that the reverse implications are not true in any form (ie closeness bounds on the right, no matter how small the parameters, do not even imply finiteness of the parameters on the left) Also, we already mentioned that Property 1 is tight|,Non-data,29
| Prop- erty 2 is known to be tight up to a multiplicative constant The quantities arising in the above definitions and prop- erties have concrete connections to inference Total varia- tion distance precisely captures the error probability in a binary hypothesis test That is, one minus the total varia- tion distance is the minimum sum of the two types of binary error probability|,Non-data,29
| Kullback-Leibler divergence precisely cap- tures the asymptotic hypothesis testing error upon observ- ing many independent observations [8, Chapter 11] The strongest of these metrics, (, 0)-closeness, has an interpre- tation in the Bayesian setting as a bound on the Bayes fac- tor That is, the log-posterior-odds-ratio cannot change by more than  due to the observation Finally, (, δ)-closeness is shown in [17] to be precisely a piecewise linear constraint on the error region in a binary hypothesis test|,Non-data,29
| By inspec- tion of that relationship, the following property is apparent (proven in Appendix B) (cid:16) Property 3 For any non-negative (cid:48) < , let δ(cid:48) = 1 − e(cid:48) (1−δ) (cid:17) +1 e+1  (,δ)≈ Q =⇒ P P ((cid:48),δ(cid:48))≈ Q|,Non-data,29
| (13) Property 3 is the tightest possible trade-off between  and δ with respect to (, δ)-closeness Notice that δ(cid:48) > δ It is not possible for a larger δ to imply a smaller one, for any finite  and (cid:48) 2|,Non-data,29
