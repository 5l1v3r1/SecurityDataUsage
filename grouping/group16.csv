 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
|g, browsing through a smartphone’s screen) is prohibited by US DOJ, American Law Reports, and other’s investiga- tion protocols [1,14,16,20,27] Moreover, if the app requires a password login every time it is brought to the foreground (see the case study in Section 42|,Non-data,44
|2), then its earlier GUI could not be restored even if operating the phone were al- lowed To overcome this, modern digital investigators now rely on memory forensics With a search warrant, investigators can capture the phone’s memory image, using certified min- imally intrusive tools [21, 44], which will be analyzed in the forensics lab without fear of jeopardizing the investigation Therefore, the most desirable outcome of this analysis would be the recovery of the GUIs that the suspect was interacting with — revealing the evidence stored on the device|,Non-data,44
| Despite recent advances in computer memory forensics, GUI recovery remains largely impossible Specifically, nearly all state-of-the-art memory forensics techniques [19, 24, 29, 30, 37, 39–41, 45] focus on the recovery of individual data structures Given a memory image and a data structure of interest, existing techniques (eg|,Non-data,44
|, [24, 29, 30, 37, 38, 41, 45]) rely on signature-based scanning of the memory image to locate raw in-memory instances of that data structure To render a discovered data structure instance in human per- 120ceivable format, a recent solution [40] derives that struc- ture’s rendering logic from the application it belongs to Unfortunately, an Android app GUI is much more com- plex than an individual data structure — it is a virtual “billboard” of many diverse, application-specific data objects with geometric and semantic dependencies defined by each individual app As detailed in Section 2, a GUI is inter- nally represented as a tree whose structure and nodes change dynamically at runtime|,Non-data,44
| More significantly, whenever an app is backgrounded (ie, replaced on the phone’s screen by a newly in-focus app), Android will explicitly nullify many key pointers in the tree, effectively disintegrating the GUI As such, existing data structure-oriented memory forensics techniques can only identify the GUI’s “element” data struc- tures from the memory image (i|,Non-data,44
|e, “identifying the puzzle pieces”) But they cannot reassemble the elements (hun- dreds or even thousands of them) into the original GUI or further visually redraw the GUI (ie|,Non-data,44
|, “putting the puzzle pieces together”) Here the new challenge is analogous to that faced by an archaeologist who tries to piece together an ancient fresco or pottery (the GUI) from its unearthed fragments (data struc- tures) [25] To address this challenge, we present GUITAR1, a system which automatically reconstructs app GUIs from Android phone memory images and redraws them as they originally appeared Interestingly, GUITAR does not re- quire app-specific knowledge and hence can reconstruct any Android app’s GUI generically|,Non-data,44
| Unlike existing techniques, GUITAR presents investigators with the “same view” of the suspect’s app(s) rather than individual data structure in- stances For example, for an instant messaging app, GUI- TAR will reconstruct its GUI with contents (eg, contacts, messages, timestamps, etc|,Non-data,44
|) all in their original layout GUITAR targets the low-level GUI framework defined by the Android graphical windowing system library (analogous to X11 commonly used with Linux), which is common to all apps’ implementation Given the GUI element data struc- ture instances, GUITAR employs a depth-first topology re- covery algorithm to reconstruct the app’s graphical layout hierarchy Next, graphical GUI contents are remapped to the geometric layout using a bipartite graph weighted assign- ment solver and corresponding drawing-content based fitness function|,Non-data,44
| Finally, GUITAR recreates the runtime environ- ment to redraw the GUI using an unmodified Android win- dowing system binary, and outputs the app’s redrawn GUI as it would have appeared had it been displayed on-screen when the memory image was taken If present in a mem- ory image, GUITAR can recover previous GUI constructs, allowing investigators to see some previous GUI state of the same app Our evaluation, performed with memory images taken from a number of popular Android apps on three new An- droid smartphones, shows that GUITAR is able to recon- struct and redraw entire app GUIs with very high accuracy We use Content Based Image Recognition (CBIR) to mea- sure the visual similarity between GUITAR-reconstructed GUIs and screenshots taken from the original app, and GUI- TAR scores 80-95% (high similarity) in all cases|,Non-data,44
| Further, our evaluation shows that GUITAR is adaptive and robust for reconstructing partial, meaningful GUIs when faced with GUI data loss over time 1GUITAR stands for “GUI Tree ARchaeology” Figure 1: Overview of a Windowing System Library Each app maintains a GUI tree, with each leaf node containing Drawing Operations|,Non-data,44
| Changes to the app’s GUI are reflected by changes to the GUI tree 2 THE ANDROID GUI FRAMEWORK The Android platform exhibits many features which in- herently pose challenges to GUI reconstruction, and these motivate many of our design decisions in Section 3 For ex- ample, we originally considered recovering the pixel buffer to which the Android windowing system projects the entire GUI for on-screen display|,Non-data,44
| However, this approach turned out to be infeasible because that buffer is located in the graphics card driver’s memory which is quickly deallocated and reused when an app is backgrounded Thus, recovering this buffer yields only the currently visible app’s GUI Seeking an alternative solution, we instead target a much more robust in-memory artifact of the windowing system: the GUI hierarchy tree (“GUI tree” for short) with drawing operations (“draw ops” for short) Figure 1 illustrates how draw ops are organized in a GUI tree|,Non-data,44
| The Android window- ing system library included in each graphical app maintains a GUI tree to represent the GUI’s current geometric lay- out and graphical content Further, despite the vast variety of visually different apps, such a tree generically represents each app’s visual presentation and display The GUI tree resides in each app’s heap Each node in the GUI tree (called a “TreeNode”) contains a pointer to a list of draw ops (a “DrawOpList”) which describes a portion of the screen space|,Non-data,44
| A parent TreeNode points to a DrawOpList which contains pointers to child TreeNodes; whereas a leaf TreeNode points to a DrawOpList which contains actual draw ops with graphical content When an app invokes the windowing system’s drawing functions (eg, drawText(|,Non-data,44
|) shown in Figure 1), the GUI modifications will be converted into an array of draw ops (TranslateOp, DrawTextOp, ClipRectOp) and stored in a leaf TreeNode A single drawing function may create mul- tiple draw ops and store them in one or more leaves|,Non-data,44
| Thus, whenever the app is visible, a GUI tree of parent TreeNodes (describing relative geometric positions and screen layout hierarchy) and leaf TreeNodes (containing actual graphical draw ops) will be created in the process’ heap memory However, Android always tries to save memory, and when an app is backgrounded its GUI tree will be deallocated and critical pointers within it (in particular the ones from TreeN- odes to their DrawOpLists) will be set to NULL (a good pro- gramming practice, but bad for memory forensics) This 1 void onDraw(Canvas canvas) {2|,Non-data,44
  superonDraw(canvas);3  // Draw the label text4  canvas,Non-data,44
|drawText (mText, );5|,Non-data,44
  6,Non-data,44
 }DrawOpListGUI Hierarchy TreeDrawTextOpClipRectOpTranslateOpApp CodeApp HeapWindowing System Lib Code1 status_t DisplayListRenderer::drawText(,Non-data,44
) {2 ,Non-data,44
|3 DrawOp* op = new (alloc()) 4        DrawTextOp(text, |,Non-data,44
);5 addDrawOp(op);6 ,Non-data,44
7}121(a) Instagram (b) WhatsApp (c) Messaging (d) Contacts Figure 2: Number of recoverable GUI data struc- tures of backgrounded apps over 24 hours,Non-data,44
| effectively disintegrates the tree and, by doing so, makes its reconstruction challenging We profiled several Android apps’ memory use before and after backgrounding and found that the GUI tree deallo- cation is among the last operations an app will perform, because background apps cannot receive user input In fact, many nodes of the old GUI tree remain in the app’s free heap space until the app is returned to the foreground, when an entirely new GUI tree will be built Further, if the app is not returned to the foreground for some time, we observe that a non-trivial portion of the GUI data is still recover- able (i|,Non-data,44
|e, their heap space is not reallocated and overwrit- ten) Figure 2 shows measurements of 4 apps’ GUI tree data structures after those apps were left in the background for a period of 24 hours For this experiment, we took an initial measurement at time t0, backgrounded the app, then took measurements at times t0 + 1 (hour), t0 + 2, t0 + 5, t0 + 10, and t0 + 24|,Non-data,44
| The smartphone (LG G3) belongs to one of the authors, with all other apps (except the one profiled) heavily used during that period From Figure 2 we can make a few key observations: First, although some apps have background activities (which re- allocated the free heap space), a large amount of GUI data is recoverable even after 24 hours In fact our evaluation in Section 4 shows that once an app is backgrounded 43% to 98% of its GUI data remains intact, which is sufficient to redraw the GUI — either completely or partially Another key observation is that, since each node describes a small portion of the screen, any missing nodes do not affect the redrawing of the remaining GUI|,Non-data,44
| In Section 4 we present a number of case studies demonstrating how missing internal nodes or leaf nodes may cause slight visual variations to re- constructed GUIs, which still retain reasonable appearance 21 Challenges and Solution Overview Firstly, because key pointers in the GUI tree are explic- itly nullified, the GUI’s original layout needs to be pieced together from the many disconnected nodes GUITAR de- fines a depth-first topology recovery algorithm (Section 3|,Non-data,44
|1) to reconnect internal parent nodes to their DrawOpLists and hence to their children nodes Complicating the recovery, GUITAR often encounters old or partially destroyed nodes which appear to be valid children of the parent nodes, and GUITAR must automatically identify (and later remove) such conflicting branches in the tree Secondly, the GUI’s graphical contents need to be re- stored by geometrically re-mapping the leaf TreeNodes back to their DrawOpLists GUITAR leverages semantic hints in the drawable graphical content described by each Dra- wOpList|,Non-data,44
| More formally, such leaf mapping can be reduced to a bipartite graph weighted assignment problem GUITAR uses the drawable GUI content to build a drawing-content- based fitness function (Section 32) which computes the like- lihood that each leaf matches to some graphical content Finally, several key data structures’ functional inheritance, which is necessary for GUI redrawing, is lost in the memory image|,Non-data,44
| GUITAR employs a technique called forced poly- morphism (Section 33) to patch the lost inheritance infor- mation Then, GUITAR recreates the GUI redrawing run- time using an unmodified Android windowing system library binary, which will redraw the reassembled GUI tree, as it would have appeared in the foreground of the original phone 3|,Non-data,44
| GUITAR DESIGN The input to the GUITAR technique is a set of data struc- ture instances corresponding to draw ops, TreeNodes, and graphical content elements, recovered from the subject app’s memory image For self-containedness, GUITAR’s imple- mentation includes a linear brute-force memory image scan- ner with 248 distinct signatures of data structures, defined by Android’s windowing system and stable across all An- droid versions we tested This signature set can be easily updated with any future changes to those data structures Alternatively, the recovery can be done using any existing or future memory forensics techniques (e|,Non-data,44
|g, those cited in Section 1) Note also, that because many of the target data structures have been deallocated, it is possible that some instances are partially corrupted (overwritten) To avoid complications from corrupted structures, GUITAR’s data structure signature matching entails checks on every field needed to reconstruct the GUI, and if an object is partially broken then it will be conservatively discarded|,Non-data,44
| Interested readers are directed to Appendix A for more information about GUITAR’s data structure signatures 31 Reconstructing GUI Tree Topology Once the GUI “elements” (data structures) are recovered, GUITAR will reconstruct the GUI tree This section de- tails how GUITAR reconnects the tree’s parent TreeNodes to their children|,Non-data,44
| However, recall that key pointers are set to NULL when the app is backgrounded, causing each TreeNode to lose connection to its DrawOpList As Figure 3 shows, losing the node’s connection to its DrawOpList also breaks any connection to its children Further, these parent-to-child links are the only ones that the windowing system binary follows to redraw the GUI Thus, GUITAR must first re- cover the GUI tree’s parent-to-child structure from two sets of disconnected TreeNodes and DrawOpLists (Figure 3)|,Non-data,44
| The GUI’s layout semantics provide a valuable hint to- ward solving this problem We observe that, in addition to the GUI tree, several Java objects encode a “reverse” GUI layout (ie, which layers are drawn in front of other lay- ers)|,Non-data,44
| By traversing these Java objects, the parent of each TreeNode can be reached Unfortunately, these additional structures are unusable during GUI redrawing (which only uses TreeNodes and DrawOpLists), but GUITAR can lever- age these “child to parent” paths and the “DrawOpList to child” pointers (shown in Figure 3) to recover the “parent to DrawOpList” pointers However, an issue arises during topology recovery: con- flicting branches may be introduced to the reconstructed 06012018024030001251024040801201602000125102402040608010001251024014028042056070001251024122Figure 3: Broken tree structure due to nullified pointers (marked with a red X) GUITAR must re- build the tree from the recovered TreeNodes and DrawOpLists|,Non-data,44
| Note the conflicting branch intro- duced by historic data structures GUI tree when DrawOpLists or TreeNodes from previously drawn GUI screens remain (not overwritten) in memory af- ter those portions of the GUI have been modified Essen- tially, these old structures correspond to historical portions of the GUI which were rendered, changed, and replaced with new DrawOpLists and TreeNodes before the app was backgrounded Figure 3 shows an example: a historic Dra- wOpList is recovered and introduces a conflict into an oth- erwise valid parent TreeNode|,Non-data,44
| At this point, GUITAR can- not distinguish between the most recent versus older TreeN- odes and DrawOpLists, but GUITAR will mark the conflict while mapping both DrawOpLists to the parent TreeNode in Figure 3 Similarly, old TreeNodes can cause conflicts with a parent TreeNode (via a historic Java object’s encoding) which has already been updated with new children Con- flicting branches will be removed later by leveraging charac- teristics of the visual GUI content (Section 32)|,Non-data,44
| Our evalu- ation in Section 4 shows that conflicting branches occur for only a small number of nodes Notably, we did find one case where a full conflicting branch (all parent and child TreeNodes and DrawOpLists) was recovered, leading to two drawable GUI versions: one shows the most recent view and the other shows elements of a prior view GUITAR’s depth-first tree topology recovery algorithm (Algorithm 1) uses a pre-order depth-first traversal of the recovered TreeNodes to rebuild the GUI hierarchy The re- cursive algorithm starts at the tree’s root|,Non-data,44
| Given a par- ent TreeNode, GUITAR first locates all TreeNodes which have that TreeNode as a parent Then GUITAR searches Algorithm 1 Depth-First Tree Topology Recovery Input: TreeNode Set N , DrawOpList Set D Output: GUI Tree T = (V, E) procedure MapNode(node) for other ∈ N do if other ; node then (cid:46) ;: child-to-parent path exists for list ∈ D do (cid:46) Find DrawOpLists pointing to other if other ∈ listpoints to then nodechildren ← node|,Non-data,44
|children ∪ other nodeopsLists ← nodeopsLists ∪ list if ||nodeopsLists|| > 1 then node|,Non-data,44
conf lict ← T rue (cid:46) Map list to node for child ∈ nodechildren do MapNode(child) (cid:46) Mark the conflict (cid:46) Continue recursion end procedure for node ∈ N do if nodeparent = ∅ then MapNode(node) (cid:46) Start at the root nodes Figure 4: Example of drawing-content based bipar- tite graph matching each DrawOpList for those which point to any child of the parent,Non-data,44
| If any are located, then these DrawOpLists must belong to this parent, because they point to the parent’s children A conflicting branch is identified if this search re- turns more than one DrawOpList The algorithm matches the located DrawOpLists to the parent TreeNode, and con- tinues the recursion with only those children pointed to by the DrawOpLists The recursion will stop when a leaf (i|,Non-data,44
|e, a node that is not any other node’s parent) is reached 32 Remapping Drawing Operations Having reconstructed the GUI tree’s internal structure, GUITAR must now map the leaf TreeNodes to the remaining DrawOpLists|,Non-data,44
| Note that these DrawOpLists contain only graphical content (such as created by drawText in Figure 1), unlike those pointed to by non-leaf nodes Figure 4 illus- trates our key intuition of matching leaf TreeNodes to the DrawOpLists’ drawable GUI content First, GUITAR com- putes the geometric screen area described by each leaf TreeN- ode Based on this, GUITAR finds a best global match to the drawable GUI content that fits in that screen area|,Non-data,44
| Formally, we define a drawing-content-based fitness function to compute the fit between any leaf TreeNode and Dra- wOpList’s graphical content We then reduce the problem of mapping DrawOpLists to leaf TreeNodes to a weighted assignment problem Problems of this class can be solved in polynomial time when modeled as a weighted bipartite graph matching problem Thus, GUITAR must first set up a multi-source multi-sink bipartite graph with the graphical DrawOpLists as a source vertex set and the leaf TreeNodes as the sink vertex set|,Non-data,44
| Building a Weighted Bipartite Graph Algorithm 2 shows how GUITAR builds the weighted bipartite graph For each DrawOpList, GUITAR computes the maximum di- mensions (opswidth, opsheight) of the graphical output pro- duced by those draw ops (ie, the pixels to be drawn on screen)|,Non-data,44
| Next, GUITAR must compute the screen area de- scribed by each leaf TreeNode, by subtracting the leaf’s screen coordinates (xleaf , yleaf ) from the closest neighbor- ing leaves’ coordinates However, each leaf only describes its coordinates relative to its parent TreeNode Thus, to find the neighboring leaves and compute each leaf’s true (full screen) coordinates, GUITAR must look backwards through the tree’s hierarchy This is performed by a recursive func- tion summarized by the getN eighbors and getF ullCoord functions in Algorithm 2|,Non-data,44
| After finding the two closest neigh- boring leaves’ coordinates (xbelow, ybelow) and (xright, yright), the current leaf’s dimensions are computed as shown in the second loop of Algorithm 2 DrawOpDrawOpXXTreeNodeHistoric Conflicting BranchLive DrawOpListDrawOpDrawOpDead DrawOpListXRecovered DrawOpList SetRecovered TreeNode SetDead DrawOpListLive DrawOpListDrawOpDrawOpDrawOpDrawOp13Graphical DrawOpList Set2Leaf TreeNode SetDrawBitmapOpTranslateOpDrawTextOpTranslateOpAliceDrawing-Content Based Bipartite Graph Matching123ClipRectOpDrawBitmapOp123Algorithm 2 Building Draw-Content-Weighted Bi-graph Input: Leaf Set L, DrawOpList Set D, ScalingFactor f Output: Graph G = (Vleaves, VopLists, E), maxW eight Vleaves ← ∅ VopLists ← ∅ E ← ∅ maxW eight ← 0 for ops ∈ D do (cid:46) Compute DrawOpList dimensions (opswidth, opsheight) ← computeDrawSize(ops) opswidth ← opswidth opsheight ← opsheight VopLists ← VopLists ∪ ops (cid:46) Insert DrawOpList vertex for leaf ∈ L do (cid:46) Compute leaf dimensions right, below ← getN eighbors(leaf ) (xright, yright) ← getF ullCoord(right) (xbelow, ybelow) ← getF ullCoord(below) (xleaf , yleaf ) ← getF ullCoord(leaf ) (leafwidth, leafheight) = (xright − xleaf , ybelow − yleaf ) leaf|,Non-data,44
width ← leafwidth leafheight ← leafheight Vleaves ← Vleaves ∪ leaf (cid:46) Insert leaf vertex for ops ∈ VopLists do for leaf ∈ Vleaves do (cid:46) Compute edge weights dwidth ← leafwidth − opswidth dheight ← leaf,Non-data,44
|height − opsheight if dwidth < 0 or dheight < 0 then scale ← f scale ← 10 else weight ← scale ∗ ((cid:112)(dwidth)2 + (dheight)2) E(ops, leaf ) ← weight if weight > maxW eight then maxW eight ← weight (cid:46) Insert edge weight (cid:46) Update max weight (cid:46) Scale factor for over-drawing Note that leaves and their DrawOpLists often do not have the same dimensions It is possible that a DrawOpList draws graphics smaller or larger than its leaf’s dimensions|,Non-data,44
| To ac- count for this, the dimensions of each leaf and each Dra- wOpList are compared using Euclidean distance A scaling factor is used to make the comparisons favor under-drawing to over-drawing (ie, it is more likely that the draw ops draw something smaller than the leaf rather than larger)|,Non-data,44
| The scaling factor is configurable (input f in Algorithm 2), and in our evaluation a scale of 13 resulted in the best map- pings The resulting weights are assigned to the bipartite graph edges in the final loop of Algorithm 2, and we update a maximum weight variable to be used later Solving the Assignment Unfortunately, the resulting graph is not suitable for assignment solving because GUI- TAR will likely recover an unequal number of DrawOpLists and leaf TreeNodes|,Non-data,44
| However, weighted assignment solv- ing algorithms require the bipartite graph to be balanced (ie, ||source vertices|| = ||sink vertices|| ) and complete (ie|,Non-data,44
|, edge set = source vertices × sink vertices) Typically, this is solved by adding fake vertices to the smaller half of the bipartite graph, but this would allow GUI elements to go unmatched or be matched to fake leaves Instead, GUITAR aims to redraw the most complete GUI possible by finding the most valid matches To overcome this, we build upon two key observations: In the case that GUITAR recovers more DrawOpLists than leaf TreeNodes, we can be sure that at least one leaf has a conflict (like before, a conflict is a TreeNode with two or more DrawOpLists)|,Non-data,44
| In this case, we want to allow some TreeNodes to map to multiple DrawOpLists to preserve as much graphical data as possible In the case that GUITAR recovers more leaf TreeNodes than DrawOpLists, we observe that adding fake DrawOpList vertices will not harm the resulting GUI because they will Algorithm 3 Correcting Bipartite Graph and Mapping Input: Graph G = (Vleaves, VopLists, E), maxW eight Output: Matched Graph G while ||Vleaves|| < ||VopLists|| do for leaf ∈ unique(Vleaves) do (cid:46) Duplicate all the unique leaf vertices newLeaf = copy(leaf ) Vleaves ← Vleaves ∪ newLeaf for ops ∈ VopLists do E(ops, newLeaf ) ← E(ops, leaf ) (cid:46) Duplicate edge weights while not||VopLists|| = ||Vleaves|| do f akeOps ← new F akeOpList VopLists ← VopLists ∪ f akeOps for leaf ∈ Vleaves do E(f akeOps, leaf ) ← maxW eight + 1 (cid:46) Add fake DrawOpLists to balance G KuhnM unkresAlgo(G) represent “empty space” where no leaf mapping could be found However, GUITAR must only consider mapping a fake DrawOpList if no real DrawOpList remains mappable (all real DrawOpLists have been assigned), simply put: try to draw as many DrawOpLists as possible even if some are over-drawn Algorithm 3 builds the balanced and complete bipartite graph and performs the weighted assignment|,Non-data,44
| In the first loop, GUITAR checks if we have recovered fewer leaf TreeN- odes and, if so, repeatedly duplicates the leaf vertices until there are more leaf vertices than DrawOpList vertices Note that GUITAR also copies the corresponding edge weights so that each duplicate of a TreeNode vertex has an equal likelihood of mapping to the same DrawOpList Next, in the second loop, GUITAR adds fake DrawOpList vertices until the graph is balanced For each fake DrawOpList ver- tex, GUITAR adds edges to every leaf vertex with weight equal to maxW eight + 1 (calculated in Algorithm 2)|,Non-data,44
| Us- ing maxW eight + 1 edge weights ensures that the fake Dra- wOpLists are only considered for mapping after all real Dra- wOpLists (with lower, more favorable edge weights) have been mapped After this step, the bipartite graph is bal- anced and complete — allowing any leaf TreeNode to map to any DrawOpList per their minimal edge weights The weighed bipartite graph assignment solving algorithm is represented in Algorithm 3 as the KuhnM unkresAlgo function The Kuhn-Munkres algorithm (also known as the Hungarian method) solves the weighted assignment prob- lem in polynomial time|,Non-data,44
| Our implementation uses an open- source version of the algorithm with time complexity O(n3) [11] The Kuhn-Munkres algorithm takes the bipartite graph (ie, two disjoint, balanced vertices sets and the complete edge set) as input|,Non-data,44
| Internally, the algorithm maintains an adjacency matrix representing the weights of the complete edge set The matrix values are iteratively reduced by the balanced cost (ie, edge weight) of the minimum weight edges|,Non-data,44
| Thus, at the end of each iteration the lowest weight edges will have cost 0 The iteration continues (balancing by the minimum weights and reducing) until: for each source vertex, the weight of one edge to a distinct sink vertex re- duces to 0 (ie, at least one 0 value in each row and column)|,Non-data,44
| The algorithm outputs the edge set which matches every source vertex to a distinct sink vertex with the minimum possible combined edge weights To GUITAR, this edge set represents the global best mapping of the DrawOpLists’ vi- sual content to the leaf TreeNodes’ geometric area on screen 124At this point, any mappings to fake DrawOpList ver- tices are removed and those leaf TreeNodes are marked as empty space on the resulting GUI Now, GUITAR can re- move conflicting branches based on two criteria leveraging the mapped visual GUI content: If a branch 1) has a dead end (i|,Non-data,44
|e, TreeNodes without mapped DrawOpLists) or 2) describes a visual portion of the screen that is covered by a more complete branch with overlapping DrawOpList map- pings To ensure visual GUI data is not removed, GUITAR ensures that the DrawOpLists of leaf TreeNodes marked for removal are mapped to a different branch of the tree (even if that requires adding a new branch) In practice a conflicting branch is rarely mapped to any valid (not fake) DrawOpList|,Non-data,44
| 33 Runtime Recreation for GUI Redraw Once the GUI tree has been reconstructed, GUITAR has everything needed to redraw the app GUI, but a few chal- lenges still remain First, the majority of the GUI drawing functionality is invoked via inherited methods in the C++ GUI objects Since these objects are recovered from a static memory image, the functional inheritance has been broken|,Non-data,44
| GUITAR recreates this inheritance via a technique called forced polymorphism Second, after recreating the polymor- phism, the GUI tree needs to be grafted into a live “host tree” which will be redrawn by Android’s windowing system Runtime Setup for Redrawing To preserve the inter- connection between the recovered GUI data, GUITAR first maps the recovered data structures back to their original locations (ie|,Non-data,44
|, the addresses they occupied when the mem- ory image was taken) in the memory of the Android em- ulator2 This ensures that Android’s windowing system — without modification — can follow any data pointers needed to redraw the GUI Note that we map neither any addi- tional data nor code segments from the memory image into the live memory This makes GUITAR applicable to mem- ory images from any Android device without concern about vendor-customizations|,Non-data,44
| Forced Polymorphism Many of the GUI data structures are polymorphic, and when inherited methods are invoked against these objects, dynamic function pointer tables are consulted to determine which implementation of an inher- ited function should be invoked Unfortunately for recovered objects from a memory image, these function dispatch tables are unusable because the values in those tables are highly sensitive to each execution of the application This situation is further confounded by ASLR present on modern Android devices (ie|,Non-data,44
|, functions pointed to by the dispatch tables will be at random addresses in the memory image) Further, recovering both the object’s code and data from the mem- ory image would require GUITAR to handle a significant number of inconsistencies between the old (frozen) execu- tion environment and the new one — making GUITAR a less portable and more heavy-weight solution To overcome this, we have developed a technique called forced polymorphism to force the “recovered objects” to in- herit from newly allocated “live objects” GUITAR must rebuild the recovered objects’ function dispatch tables to al- low the windowing system to invoke any inherited drawing functions|,Non-data,44
| However, due to lack of type and symbol infor- 2This mapping is done using a newly started “stub” pro- cess in the emulator, before any heap or data segments are allocated, to avoid conflicts with new “live” memory usage Figure 5: Illustration of forced polymorphism mation3 in the memory image and the multiple-inheritance used by these objects, GUITAR must first determine the true runtime type of each recovered object GUITAR leverages the GUI data structure signatures to guide the forced polymorphism|,Non-data,44
| For each recovered object, GUITAR recalls the object-type recognition performed dur- ing memory image scanning During scanning, many objects are recovered based on their common superclass To identify the recovered object’s true type inheritance, GUITAR com- pares the object to signatures from every object along that object’s inheritance tree The deepest matching subclass is then marked as the object’s previous runtime-type, which GUITAR uses to reconnect the function dispatch table|,Non-data,44
| Based on the recovered object’s true inheritance, GUI- TAR allocates a new instance of the matching type (a live object) GUITAR then redirects the recovered object’s func- tion dispatch table to that of the live object Now, when the Android windowing system attempts to invoke an inherited function from one of the recovered objects, it will be redi- rected to the correct function in the current address space This also avoids any complications from ASLR present in the memory image, because the function’s old location is aban- doned and corrected to the live location|,Non-data,44
| Figure 5 shows an example of a recovered DrawBitmapOp being forced to in- herit a live DrawBitmapOp function dispatch table Notice that when the inherited applyDraw function is invoked, the lookup consults the live function dispatch table but the re- covered object’s data (eg GUI content) is preserved|,Non-data,44
| GUI Redraw Once the recovered structures’ functional inheritance has been recreated, the reconstructed GUI is ready to be redrawn Because the recovered objects have been mapped back to their original memory locations, the windowing system code can interact with them seamlessly, without any instrumentation for address translation GUITAR is prepackaged with unmodified Android win- dowing system binary code and a minimal Android app GUI, used as a “host” for grafting the recovered GUI tree When redrawing the GUI tree, GUITAR inserts the entire recovered GUI tree as a subtree within the running host app’s GUI|,Non-data,44
| GUITAR then marks the tree as “dirty,” caus- ing the windowing system to redraw the GUI content At this point the windowing system executes unsuspectingly, accessing the recovered GUI data as if it had naturally been allocated and initialized in the new process The GUI con- tent is displayed as it would have appeared on the original device’s screen the last time that app was in focus The newly drawn GUI then replaces the host app’s GUI|,Non-data,44
| 3Android devices are shipped with stripped versions of all system binaries, including the windowing system library Live Code SectionOld Code Section    RecoveredDrawBitmapOpInstanceLiveDrawBitmapOpInstanceapplyDraw FunctionapplyDraw FunctionMemory ImageNew Memory Space    RecoveredDrawBitmapOpInstancemultiDraw|,Non-data,44
applyDrawmultiDrawapplyDrawForce Inheritance from Live ObjectRecovered Object mapped into Live Memory125Device App Samsung S4 LG G3 HTC One Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp Foreground Instances 546 221 511 655 262 120 172 753 220 731 926 301 101 214 276 191 358 608 355 392 130 Background Instances 507 168 476 634 240 102 148 738 172 640 884 259 90 165 259 170 285 593 319 371 123 % Persists 92,Non-data,44
86 7601 9315 9679 91,Non-data,44
60 8500 8605 9800 78,Non-data,44
18 8755 9546 8605 89,Non-data,44
11 7897 9384 8901 79,Non-data,44
60 9753 8986 9464 94,Non-data,44
61 Recovered by GUITAR 507 168 476 634 240 102 148 738 172 640 884 259 90 165 259 170 285 593 319 371 123 Table 1: Recovery of backgrounded GUI data structures 4 EVALUATION We have implemented GUITAR as a plug-in for the An- droid emulator (∼2000 lines of C++ code) GUITAR takes a subject Android device’s memory image as input and re- draws the recovered app GUIs on the emulator’s screen,Non-data,44
| GUITAR requires no modification to the Android frame- work code but leverages the (open-source) data structure definitions of its windowing system Experimental Setup We used three Android smart- phones as “suspect devices”: an HTC One, Samsung Galaxy S4, and LG G3 The devices are all different OEM cus- tomized versions of Android 444|,Non-data,44
| We first installed a variety of apps on all 3 devices, and one of the authors interacted with each to cause several GUIs to be displayed and changed Among these were 2 of the most popular social networking apps: Facebook and Instagram, whose GUIs reveal signifi- cant personal information about the device’s owner, friends, and activities We also evaluated WhatsApp, a widely used chat and instant messaging app, to reveal a suspect’s re- cent conversations and contact list Also 3 vendor-specific apps (Calendar, Contacts, and Messaging) were tested, each of which is implemented by smartphone vendors specifically for their devices with vastly different GUI constructs|,Non-data,44
| 41 GUI Data Elements (Puzzle Pieces) As stated in Section 2, most GUI data structures are freed and key pointers nullified when an app is backgrounded In this section, we evaluate how many of these data structure instances persist in the app’s free heap space after being backgrounded For these tests, we interacted with each app, backgrounded it, and waited 15 minutes while interacting with another app, before capturing memory images from the app while it was in the background|,Non-data,44
| Our results will be leveraged in the next subsections to connect the quantity of recovered data structures to the quality of the redrawn GUIs To establish ground truth, we instrumented each app to log allocations and deallocations of the GUI data struc- tures5 When a data structure instance was deallocated, we also logged its contents, allowing us to verify which freed instances had been overwritten (fully or partially) We then analyzed the log to identify how many GUI data structures existed before and after the app was backgrounded|,Non-data,44
| Finally, we tested GUITAR with each memory image to ensure that all remaining valid data structures could be located Note that GUITAR has no knowledge of our profiling results and relies only on signature-based scanning for data structure recovery Table 1 presents the results for all 7 apps on each of the 3 devices The devices and app names are listed in Columns 1 and 2, respectively|,Non-data,44
| Column 3 shows the count of GUI data structure instances that were in the app’s heap when the app was in the foreground Column 4 shows those which remained in the app’s heap after the app was backgrounded, and Column 5 shows this as a percentage Lastly, Column 6 presents the number of data structure instances which GUI- TAR recovered from the memory image From Table 1, we make several observations: First, GUIs are built from a significant number of data structure in- stances|,Non-data,44
| This may seem intuitive, but it confirms our earlier claim that focusing on individual data structures is insuf- ficient Many apps require more than 500 data structure instances for their GUIs Notably, the LG G3 Facebook app reports the most data structures: 926 Overall, 11 of the 21 test cases have more than 300 data structure instances each|,Non-data,44
| Table 1 also shows that vendor-specific apps show very different results on each smartphone For example, each ven- dor’s Calendar app has very different GUI construction and thus contains a disparate number of data structures: 546 for Samsung, 753 for LG, and 276 for HTC In contrast, vendor-generic apps tend to have very similar results (eg|,Non-data,44
|, 262, 301, and 355 for Instagram) 4To handle different Android versions, GUITAR only needs to update its data structure signatures for memory image scanning (if those versions change any GUI object defini- tions) 5This was done via in-place binary instrumentation of the windowing system library and, by design, neither interacts with any memory management components nor changes how the structures are used by the library 126Samsung S4 LG G3 HTC One Recovered Tree Size 57 33 57 113 57 22 30 76 33 101 128 58 23 37 40 34 73 78 58 83 25 22 4 11 48 6 2 4 18 6 19 41 9 3 8 8 5 12 23 5 34 1 Device App Edit Distance % Original CBIR Similarity Ground Truth Tree Size 62 33 50 85 54 22 30 79 33 98 116 58 23 37 38 33 73 79 58 85 25 Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp Calendar Chase Banking Contacts Facebook Instagram Messaging WhatsApp 85|,Non-data,44
05 N/A 9464 9547 8914 85,Non-data,44
75 8217 9462 N/A 8016 85,Non-data,44
52 8775 8078 8085 80,Non-data,44
33 N/A 8416 9052 9325 86,Non-data,44
02 9270 Table 2: Reconstruction of GUI trees of various apps from different phones 6451 87,Non-data,44
88 9200 7765 9444 90,Non-data,44
91 8667 7722 8182 83,Non-data,44
67 7672 8448 8696 76,Non-data,44
30 8421 8788 8356 70,Non-data,44
89 9138 6000 9600 Table 1 shows that a large percentage of these data struc- tures persist after the application is backgrounded,Non-data,44
| As pre- sented in Section 2, this percentage will drop over time if the app remains in the background — Section 43 expands on this by evaluating GUITAR’s GUI recovery capability over a period of 24 hours For all 21 cases, an average 8923% of the data structures persist|,Non-data,44
| We only see 4 cases where less than 80% persist Further, recall that GUITAR can re- construct an app’s remaining GUI even if some of the data structures are missing — the missing pieces might simply be blank spaces on the screen Lastly, these results show that GUITAR’s memory im- age scanner is robust enough to recover 100% of the data structure instances in the backgrounded apps’ memory im- ages Although we point out that individual data structure recovery is not GUITAR’s primary capability and may be performed by other existing memory forensics techniques|,Non-data,44
| 42 Reconstructed GUIs (Finished Puzzles) Using the recovered GUI data “pieces,” we now evaluate how accurately GUITAR reconstructs each GUI tree and the quality of each redrawn GUI We first need to compare a GUITAR-reconstructed GUI tree with a Ground Truth Tree (ie|,Non-data,44
|, the app’s true GUI tree as it was in the memory image) To obtain the Ground Truth Tree, we instrumented each app to log the structure and content of its GUI tree in the foreground From that log, we subtracted the elements of the tree that were lost when the app was backgrounded (recall that the tree’s structure is explicitly destroyed when the app is backgrounded) This yielded the ideal tree which GUITAR could reconstruct with the remaining data structures|,Non-data,44
| However, the most important (and interesting) test for GUITAR is: How does the reconstructed GUI look? To reliably compare each GUITAR-reconstructed GUI to the app’s original GUI, we used Content Based Image Recogni- tion (CBIR) to score the similarity between the GUI recon- structed by GUITAR and a screenshot of the original app (from Android’s screencap program) Note that CBIR is used instead of a naive per-pixel comparison because GUI- TAR may rearrange a few GUI elements — causing many pixels to change though the overall image’s content remains the same For this, we employed the widely used LIRE open source CBIR library [32,33] and the default CEDD indexing feature [23] Notice that this comparison is actually unfavor- able to GUITAR because the screenshot is taken when the app is in the foreground, and GUITAR has no control over what data is overwritten when the app is backgrounded|,Non-data,44
| Table 2 presents the devices and app names in Columns 1 and 2 Columns 3 and 4 show the size (number of nodes) of the Ground Truth Tree and GUITAR-reconstructed tree, respectively6 Note that the number of edges is always the number of nodes minus 1 Column 5 presents the edit dis- tance (number of node additions and deletions) between the Ground Truth Tree and reconstructed tree|,Non-data,44
| The percentage of the GUITAR-rebuilt tree that is strictly identical (con- tent, structure, and position in the tree) to the Ground Truth Tree is shown in Column 6 Lastly, Column 7 lists the CBIR score between the GUITAR-reconstructed GUI and a screenshot of the foreground app Table 2 shows that GUITAR-reconstructed GUI trees are very similar to the apps’ original GUI trees Column 6 shows that most of the reconstructed trees (14 out of 21) are more than 80% strictly identical to the Ground Truth Trees (with an average of 82|,Non-data,44
|63%) Moreover, the edit dis- tances in Column 5 show that many rebuilt trees only differ from the (ideal) Ground Truth Trees by less than 10 modifi- cations (node additions or deletions) Further, as described in Section 3, often the reconstructed tree branches that are not identical to the Ground Truth Tree are simple permu- tations of the tree’s structure In the following section, we will highlight LG G3’s WhatsApp test to demonstrate how reconstructed GUIs are often a slightly “rearranged” form of the original GUIs|,Non-data,44
| Table 2 also shows that 7 reconstructed trees are slightly larger than their Ground Truth Trees A larger tree is al- ways caused by historic GUI data For instance, the Sam- sung S4 Contacts GUI is reconstructed with several elements 6The number of nodes is smaller than the number of data structure instances because each TreeNode includes the node plus all elements in its DrawOpList and graphical contents 127(a) Earlier Screen|,Non-data,44
 (b) Latest Screen (c) Conflict Branch(d) Recovered GUI (a) App Screen,Non-data,44
 (b) Recovered GUI Figure 6: Samsung Contacts app with redrawn full conflict branch Figure 7: HTC Messaging (a) App Screen,Non-data,44
 (b) Recovered GUI (a) App Screen (b) Recovered GUI (a) App Screen,Non-data,44
 (b) Recovered GUI Figure 8: LG WhatsApp Contacts Figure 9: Samsung Facebook Figure 10: LG Contacts app,Non-data,44
| that were present on an even earlier screen Figure 6 shows the two previous GUI screens which contributed to the re- sulting GUITAR-reconstructed GUIs: one from the most recently viewed screen (Figure 6(b)), and a portion of the earlier screen (a full conflicting branch, Figure 6(c)) Of the 21 test cases, only 4 have reconstructed trees smaller than the Ground Truth Trees Smaller trees are caused when too few data structures with visual GUI contents are recov- ered|,Non-data,44
| As detailed in Section 32, GUITAR removes empty branches of the reconstructed tree, yielding a tree smaller than the Ground Truth Tree (which does not remove empty branches) Empty branches result in blank areas in the re- drawn GUI As Figure 7 shows, the HTC One’s Messaging app GUI loses three of the icons on the top of the screen and one thumbnail image when the app is backgrounded|,Non-data,44
| Most importantly, the CBIR results summarize how vi- sually similar the re-drawn GUIs are to the original app’s screens Column 7 of Table 2 shows that all test cases score between 8016% and 9547%, with an overall average of 87|,Non-data,44
|16% similarity To illustrate this measurement Figure 9 shows the best case: Samsung S4’s Facebook, and Figure 10 shows the worst case: LG G3’s Contacts Even in the worst case (8016%) the GUITAR-reconstructed GUI is quite sim- ilar to the original GUI|,Non-data,44
| From the CBIR similarity scores, we make a few observa- tions: First, certain apps have consistent GUI reconstruc- tion results For instance, Instagram has good scores for all devices (8914% for Samsung, 8775% for LG, and 93|,Non-data,44
|25% for HTC) Again, the vendor-specific apps do not show any similarity across devices For example, Samsung’s Contacts is among the best cases at 9547%, but the LG G3 Contacts GUI is 80|,Non-data,44
|16% We also find that no device outperforms the others by a significant margin The device-specific averages are all very similar: 8750% for Samsung, 84|,Non-data,44
|25% for LG, and 8677% for HTC Also note that the GUI tree reconstruction metrics are somewhat misrepresentative, which prompted us to perform the CBIR similarity comparison Several apps have recon- structed trees that seem fairly different from their Ground Truth Trees, but the displayed GUIs are very similar to the original apps’ GUIs|,Non-data,44
| One such example is the Samsung S4’s Facebook app In this case, the reconstructed tree is 7765% identical to the Ground Truth Tree with an edit distance of 48 (ie|,Non-data,44
|, it would take 48 additions or deletions to make the trees fully identical) However, the GUITAR-redrawn GUI scores 9547% similarity to the app’s screenshot (as highlighted in Figure 9) This is due to many small GUI elements being “best fit” matches for the same GUI tree nodes|,Non-data,44
| Therefore, GUITAR reconstructed a GUI tree which has many nodes mapped to alternate locations, but in fact the visual elements are nearly interchangeable Lastly, we found that several test cases had similar data structure destruction patterns caused by backgrounding the app Manual investigation revealed that textual glyphs and UI colors are often the first data structures to be deallocated and overwritten This turns out to be favorable for inves- tigators because glyphs and colors can be reconstructed by analyzing the app’s APK from a forensic image of the smart- phone’s SD card (acquired alongside a memory image)|,Non-data,44
| For these cases, we used a python script to extract the glyph icons and colors from the APKs and patch them into the overwritten data structures 128GUI Reconstruction Time We measured the GUI re- construction time for each case in Table 2 GUITAR’s run- ning time ranges from 5 minutes to 10 minutes, including the scanning of the memory image for GUI element data struc- ture recovery If such recovery time is excluded (because it is not the main capability of GUITAR), the GUI reconstruc- tion time alone ranges from 3 to 5 minutes, which is very acceptable for (off-line) digital forensics investigations|,Non-data,44
| 421 Case Study: WhatsApp on LG G3 In several test cases presented in Table 2 we found that GUITAR-reconstructed GUIs are slightly “rearranged” forms of the original apps’ GUIs In this case study, we examine one such case in detail where this effect is most obvious|,Non-data,44
| When we performed the LG G3’s WhatsApp experiment, the last GUI we viewed was the app’s Friends List window Thus, this is the GUI we aimed to redraw using GUITAR As shown in Row 14 of Table 1, 7897% of WhatsApp’s GUI data structures persisted in the backgrounded app’s memory|,Non-data,44
| From those recovered structures, GUITAR was able to reconstruct the app’s GUI tree of 37 nodes Table 2 shows that the reconstructed tree has the same size as the Ground Truth Tree but is only 7630% identical Curiously, when we looked at the GUITAR-redrawn GUI everything appeared to be drawn correctly|,Non-data,44
| Through further investigation we found that 4 of the ma- jor GUI elements were virtually interchangeable: each sub- tree having the same geometric on-screen dimensions and identical tree structure Correlating these 4 GUI elements to the redrawn GUI revealed that these were the 4 rows for each friend in our Friends List While rebuilding the GUI tree, GUITAR could not determine the order of these sub- trees (given their similarity) and thus broke the tie randomly — swapping 2 of the friends in the list Figure 8 presents the app’s foreground screenshot and the GUITAR-reconstructed GUI|,Non-data,44
| Notice how the first and sec- ond friend in the list have swapped positions in the rebuilt GUI The only other difference between the GUIs is the miss- ing icons at the bottom of the screen which were lost when the app was backgrounded To correct this, GUITAR could leverage heuristics (eg|,Non-data,44
|, the structures’ offset in the heap) to help break such “best match” ties more accurately We leave this as future work 42|,Non-data,44
|2 Bypassing the Password Check In this section, we highlight another interesting feature of GUITAR: It helps bypass an app’s password protection Many Android apps (particularly those handling highly sen- sitive data) require users to log in when they bring the app back to the foreground after a certain (short) period of time One such example is the Chase Banking app Like many other highly secure apps, the Chase app requires users to log into their Chase account every time the app is brought to the foreground|,Non-data,44
| This login is cached and a timer is used to automatically log the user out after some time of inactiv- ity Thus, if someone later opened the app it would again ask for login credentials Importantly however, when such a secure app is being used, the last screen the user views before backgrounding the app is always some internal screen of the app after the user has already logged in Further, this most recent internal screen will be the one present in the app’s heap even after the app has logged the user out|,Non-data,44
| For these apps, GUITAR can recover confidential personal information frozen in the memory image long after the app’s session has expired We have evaluated GUITAR with memory images from the Chase Banking app on all three test smartphones In each case, we logged into our personal Chase Bank account, checked our account balances, and backgrounded the app We then waited for the app’s session timer to expire (thus requiring us to log in if we brought up the app again) and then took the memory image of the backgrounded app|,Non-data,44
| Note that Table 2 shows “N/A” for the Chase Banking app’s CBIR scores This is because the Chase Banking app, like many other secure apps, has explicitly disabled screen- shots from being taken when the app is in the foreground This however cannot prevent GUITAR from reconstructing the app’s GUI from the memory image Table 2 shows that GUITAR was able to rebuild the Chase Banking app’s GUI tree with very high accuracy: 87|,Non-data,44
|88% identical to the Ground Truth Tree for the Samsung S4 and HTC One devices and 8182% identical for the LG G3 For visual comparison, Figure 11 shows the reconstructed app GUIs for all 3 devices (and one of the authors’ graduate- student-size account balance) We point out that a broader impact of this case study is the user privacy concerns it raises for running highly sensi- tive apps on smartphones|,Non-data,44
| Interestingly, even apps focusing on privacy (such as TextSecure [36]) cannot disrupt GUI- TAR’s recovery This is because GUITAR operates on the lowest-level GUI objects (defined by Android, not by the apps) Such GUI data is used directly by the system for GUI display Thus any app which displays a GUI will have to use these objects, leaving behind the GUI-related data that GUITAR will (later) use for GUI recovery|,Non-data,44
| In our tar- geted application scenario (digital investigation), we assume that the privacy issues are addressed by legal protocols and policies (eg, requirement of a search warrant) (a) LG G3 (b) Samsung S4 (c) HTC One Figure 11: Reconstructed Chase Banking GUIs|,Non-data,44
| Al- though the user was logged out, recovered GUIs still reveal sensitive information Note: we manually blocked out the account number 43 GUI Reconstruction Over Time In this section, we evaluate GUITAR’s GUI reconstruction capability for memory images captured over a longer period of time since the app was backgrounded|,Non-data,44
| As described in Section 2, Android rebuilds an app’s GUI from scratch (ie, allocates and builds a new GUI tree) every time it is brought to the foreground; as such, data of its previous GUI are freed and risk being overwritten if the app performs background processing However, as shown in Figure 2, a non-trivial amount of the GUI data persist in the app’s free heap space over a period of 24 hours|,Non-data,44
 1298755 8755 8687 49,Non-data,44
79 4378 App Fore/Backgound Backgrounded Time Foreground Contacts Background Foreground Instagram Background Foreground Messaging Background Foreground WhatsApp Background 1 hour 2 hours 5 hours 10 hours 24 hours 1 hour 2 hours 5 hours 10 hours 24 hours 1 hour 2 hours 5 hours 10 hours 24 hours 1 hour 2 hours 5 hours 10 hours 24 hours 7708 7708 77,Non-data,44
08 7708 6811 Instances % Persists Tree Size Edit Distance % Original 731 640 640 635 364 320 301 232 232 232 232 205 101 90 84 84 56 56 214 157 116 115 115 109 98 101 101 97 65 63 58 58 58 58 58 51 23 23 21 21 18 18 37 37 35 35 35 32 8203 82,Non-data,44
03 8203 8203 7451 71,Non-data,44
94 6502 6413 6413 50,Non-data,44
71 19 19 24 43 47 11 11 11 11 18 3 6 6 11 11 10 13 13 13 18 8911 8317 8317 55,Non-data,44
45 5545 7336 5421 53,Non-data,44
74 5374 5093 8367 83,Non-data,44
67 7906 5423 5156 86,Non-data,44
96 8252 8252 5701 57,Non-data,44
01 Table 3: Reconstruction of background apps’ GUI trees over a 24 hour period (a) 1 hour (b) 5 hours (c) 24 hours (d) 1 hour (e) 5 hours (f) 24 hours Figure 12: Contacts and WhatsApp GUIs with varying degree of loss over time Using the memory images of 4 apps taken in Section 41 as a baseline (i,Non-data,44
|e, time t0), we left the apps in the background, untouched, and took additional memory images at times t0+ 1 (hour), t0 + 2, t0 + 5, t0 + 10, and t0 + 24 During this time period, the other apps on the smartphone were heavily used We employed the same ground truth collection as in the previous sections, and then applied GUITAR on these memory images|,Non-data,44
| Table 3 presents our results for the LG G3 phone For comparison, we include each app’s foreground data (with 100% of the intact GUI tree in memory) Note that each app’s GUI reconstruction results for the memory image cap- tured at t0 are already presented in Tables 1 and 2 Column 1 of Table 3 shows each app’s name|,Non-data,44
| Column 2 shows if the app was in the foreground or background, and Column 3 lists the time each app had been in the background when the memory image was taken The number of data struc- tures in the memory images is listed in Column 4 (like before, GUITAR located all recoverable data structures) Column 5 presents the percentage of the foreground data structures which persist in the memory Columns 5, 6, and 7 present the reconstructed GUI tree’s size, edit distance, and percent- age that is identical to the Ground Truth Tree, respectively|,Non-data,44
| Table 3 presents several interesting results: First, as ex- pected, after 1 hour in the background the GUI recovery results are similar to those reported in the previous sections (ie, 15 minutes in the background) On average, 81|,Non-data,44
|78% of the data structures are recoverable — fairly close to the average in Section 41: 8923% Further, GUITAR recon- structs GUI trees that are all more than 71% identical to their Ground Truth Trees|,Non-data,44
| Notably, Table 3 shows that loss of GUI data is non-linear over time For example, the Instagram GUI data had no loss until 9% of the data structures were overwritten in the 24 hour-memory image Intuitively, this is because those data structures remain intact, until one or more bursts of background computation have requested enough memory to overwrite the GUI data Because of this, the apps tend to exhibit “stepwise” GUI data loss|,Non-data,44
| The Messaging app in Table 3 shows this trend: 6% of the data were lost after 2 hours, and then no data were lost until 28% more data were lost after 10 hours To visually compare the reconstructed GUIs, Figure 12 shows the gradual (but graceful) degradation of GUITAR- reconstructed GUIs over the 24-hour period Again, the GUIs reconstructed from the 1-hour-memory images are very similar to those reconstructed in the previous subsections After 24 hours, the GUIs will be missing some non-trivial content|,Non-data,44
| But GUITAR is robust enough to reconstruct the partial GUIs showing the graphical content of the remaining GUI data, which (as shown in Figure 12) are still of forensic value 1305 RELATED WORK By and large, memory forensics tools have focused on recovering individual data structure instances as evidence They can be roughly divided into two categories based on the data structure signatures they employ|,Non-data,44
| Value-invariant sig- natures leverage known in-memory value patterns or invari- ants to locate data structure instances via brute-force scan- ning [17, 18, 24, 37, 41, 45] Structural-invariant (or “points- to”) signatures rely on the interconnection of data structure networks [30] To date, most forensic tools and reverse en- gineering systems rely on traversing data structures (mak- ing use of structural-invariant assumptions) [19, 22, 35, 48] Many techniques, such as HOWARD [42], REWARDS [31], and TIE [28], leveraged program analysis to automatically infer data structure definitions for deriving their signatures|,Non-data,44
| DIMSUM [29] used hybrid-signatures along with probabilis- tic inference to identify data structure instances without memory mapping information (eg, page tables) GUITAR, however, addresses a different problem: reconstructing GUIs by piecing together data structures already recovered|,Non-data,44
| As such, the input of GUITAR is the output of existing data structure recovery tools Recently, DSCRETE [40] was proposed to automatically render application output for recovered data structures It still focuses on individual structure instances and involves an application-specific dynamic analysis step DSCRETE requires the data structure it renders to be “live” and in- tact|,Non-data,44
| By comparison, GUITAR is app-independent and re- constructs entire GUIs, each containing hundreds of inter- dependent deallocated data structures, with critical pointers between them nullified by Android Forensics research has only recently started to focus on mobile devices DEC0DE [47] employed probabilistic finite state machines to recover plain-text call logs and address book entries from phone storage Spurred by the release of Android memory acquisition tools [13, 43], several efforts began recovering app-specific data from memory images|,Non-data,44
| VCR [39] recovers photographic evidence from the camera service’s memory Thing et al [46] aimed at recovering low- level inter-app communications from memory images Other works [12, 34] have investigated Dalvik-JVM control struc- tures and raw Java object content|,Non-data,44
| Apostolopoulos et al [15] later found several login credentials in app memory images Lastly, Hilgers et al [26] proposed using memory analysis on cold-booted Android phones|,Non-data,44
| GUITAR shares the same analysis subjects with these efforts: Android memory im- ages However, GUITAR is unique in focusing on recon- structing GUIs (instead of specific types of program data) and redrawing the GUIs in the same, full-screen view as seen by smartphone users 6 CONCLUSION To address a real-world smartphone forensics challenge, we have presented GUITAR, a memory forensics technique which automatically reconstructs and redraws Android app GUIs frozen in a memory image|,Non-data,44
| Instead of focusing on recovering individual data structures (as most existing tech- niques do), GUITAR takes recovered GUI data structures — already deallocated by Android — as input and pieces them back together to recreate the original GUI Our evalu- ation results show that GUITAR achieves high accuracy in GUI tree reconstruction and redrawing, and tolerates loss of GUI data elements over time by reconstructing partial yet meaningful GUIs 7 ACKNOWLEDGMENTS We thank the anonymous reviewers for their insightful comments and suggestions|,Non-data,44
 We also thank Dr Golden G Richard III for his valuable input on the legal and technical aspects of memory forensics This work was supported in part by NSF under Award 1409668,Non-data,44
|ABSTRACT In this paper, we describe a new information-theoretic proto- col (and a computationally-secure variant) for secure three- party computation with an honest majority The proto- col has very minimal computation and communication; for Boolean circuits, each party sends only a single bit for every AND gate (and nothing is sent for XOR gates) Our protocol is (simulation-based) secure in the presence of semi-honest adversaries, and achieves privacy in the client/server model in the presence of malicious adversaries On a cluster of three 20-core servers with a 10Gbps con- nection, the implementation of our protocol carries out over 1|,Non-data,47
|3 million AES computations per second, which involves processing over 7 billion gates per second In addition, we developed a Kerberos extension that replaces the ticket- granting-ticket encryption on the Key Distribution Center (KDC) in MIT-Kerberos with our protocol, using keys/ pass- words that are shared between the servers This enables the use of Kerberos while protecting passwords Our implemen- tation is able to support a login storm of over 35,000 logins per second, which suffices even for very large organizations|,Non-data,47
| Our work demonstrates that high-throughput secure com- putation is possible on standard hardware INTRODUCTION 1 11 Background In the setting of secure computation, a set of parties with private inputs wish to compute a joint function of their inputs, without revealing anything but the output|,Non-data,47
 Pro- tocols for secure computation guarantee privacy (meaning ∗ Supported by the European Research Council under the ERC con- solidators grant agreement n 615172 (HIPS) and by the BIU Center for Research in Applied Cryptography and Cyber Security in conjunc- tion with the Israel National Cyber Bureau in the Prime Minister’s Office Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page Copyrights for components of this work owned by others than ACM must be honored,Non-data,47
| Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from Permissions@acmorg|,Non-data,47
| CCS’16, October 24-28, 2016, Vienna, Austria c(cid:13) 2016 ACM ISBN 978-1-4503-4139-4/16/10  |,Non-data,47
 $1500 DOI: http://dxdoiorg/10,Non-data,47
|1145/29767492978331 Kazuma Ohara NEC Corporation, Japan k-ohara@axjpnec|,Non-data,47
|com that the protocol reveals nothing but the output), correct- ness (meaning that the correct function is computed), and more These security guarantees are to be provided in the presence of adversarial behavior There are two classic ad- versary models that are typically considered: semi-honest (where the adversary follows the protocol specification but may try to learn more than allowed from the protocol tran- script) and malicious (where the adversary can run any arbi- trary polynomial-time attack strategy) In the information- theoretic model, security is obtained unconditionally and even in the presence of computationally unbounded adver- saries|,Non-data,47
| In contrast, in the computational model, security is obtained in the presence of polynomial-time adversaries and relies on cryptographic hardness assumptions Despite its stringent requirements, it has been shown that any polynomial-time functionality can be securely computed with computational security [25, 12, 3] and with information- theoretic security [2, 8] These results hold both for semi- honest and malicious adversaries, but an honest majority must be assumed in order to obtain information-theoretic se- curity even for semi-honest adversaries There are two main approaches to secure computation protocols: the secret- shar- ing approach (followed by [2, 8, 12]) works by having the parties interact for every gate of the circuit, whereas the garbled-circuit approach (followed by [25, 3]) works by hav- ing the parties construct an encrypted version of the circuit which can be computed at once|,Non-data,47
| Both approaches have im- portance and have settings where they perform better than the other On the one hand, the garbled-circuit approach yields protocols with a constant number of rounds Thus, in high-latency networks, they far outperform secret-sharing based protocols which have a number of rounds linear in the depth of the circuit being computed On the other hand, protocols based on secret-sharing typically have low band- width and send small messages per gate, in contrast to gar- bled circuits that are large and costly in bandwidth|,Non-data,47
| This limits the potential throughput of protocols following the garbled-circuit approach, even when run in very low-latency networks Note that information-theoretic protocols typi- cally rely on simple operations making them fast (but no constant-round protocol for this setting is known to exist and this is conjectured to be hard if not impossible [14]) Another question determining the type of protocol to use is whether or not high throughput or low latency is the goal If low latency is needed (and the circuit being computed is deep), then constant-round protocols like [25] outperform secret-sharing based protocols, even on very fast networks|,Non-data,47
| 805However, these same protocols fail to achieve high though- put due to the large bandwidth incurred Due to this situation, it is important to develop protocols for low and high latency networks, with better response time and/or throughput 12 Our Results In this paper, we focus on the question of achieving se- cure computation with very high throughput on a fast net- work (without utilizing special-purpose hardware beyond the widespread Intel AES-NI and AVX instruction sets)|,Non-data,47
| The challenge in achieving this is both on the computational and network levels Specifically, a protocol achieving very high throughput would need to both be very simple compu- tationally and also utilize very little bandwidth Achieving both of these tasks is challenging The BGW protocol [2] for semi-honest adversaries requires each party to send 3 field elements to each other party per multiplication gate, whereas the Sharemind protocol [4, 5, 27] (in its latest op- timized version [16]) requires each party to send 5 elements per multiplication gate, and further reduces the number of field multiplications|,Non-data,47
| For Boolean circuits and 3 parties, this translates to sending just 12 bits per AND gate in BGW and sending just 10 bits per gate in Sharemind A new protocol We describe a new three-party proto- col that is both extremely simple and has seemingly optimal bandwidth Our protocol is suitable for arithmetic circuits over any field or over the ring modulo 2n|,Non-data,47
| Addition gates require local addition only, and multiplication gates require that each party send just a single field/ring element to one other party In the Boolean case, this means that each party transmits a single bit only per AND gate1 Furthermore, the computation in our protocol is extraordinarily simple: in the case of Boolean circuits, each party carries out a sin- gle XOR operation per XOR gate, and 2 AND and 3 XOR operations per AND gate Since all operations are merely XOR and AND, this also lends itself to parallelization on standard computers (in particular, XOR and AND over 128 bit registers can be carried out in the same time as for a single bit using Intel intrinsics)|,Non-data,47
| Security We prove that our protocol is secure in the presence of semi-honest adversaries with at most one cor- rupted party, under the standard simulation-based defini- tions The basis of our protocol is information theoretic (and in fact perfectly secure) However, we save on commu- nication by generating correlated randomness computation- ally, and therefore our overall protocol is computationally secure|,Non-data,47
| (This combination enables us to achieve simple op- erations and save on additional bandwidth) In addition to the above, we also consider a client/server model where any number of clients send shares of their inputs to 3 servers that carry out the computation for the clients and return the results to them (without learning anything) This model makes sense for “outsources secure computation services” and indeed is the business model of Cybernetica We show that in this model, our protocol actually achieves privacy in the presence of malicious adversaries, meaning that a single malicious server cannot learn anything about the input or output|,Non-data,47
| (We stress that this notion is strictly weaker than simulation-based security in the presence of malicious ad- 1 This is “seemingly” optimal in terms of bandwidth, but this has not been proven and seems hard to do so; see [14] versaries, and in particular, does not guarantee correctness Nevertheless, it does guarantee that privacy is not breached even if one of the servers behaves maliciously) Number of parties|,Non-data,47
| As in Sharemind [4, 5], our proto- col is specifically designed for 3 parties with at most one corrupted This is unlike BGW [2] that works for any num- ber of parties with an honest majority An important open question left by this paper is the design of a protocol with comparable complexity that works for any number of par- ties This seems to be very challenging, based on attempts that we have made to extend our protocol|,Non-data,47
| Experimental results We implemented our new pro- tocol for Boolean circuits in C++ and using standard op- timizations In order to take advantage of the very simple operations required in our protocol, we used Intel intrinsics in order to carry out many executions in parallel This is described in detail in Section 5|,Non-data,47
|1 We ran our experiments on a cluster of three nodes, each with two 10-core Intel Xeon (E5-2650 v3) processors and 128GB RAM, connected via a 10Gbps Ethernet (We remark that little RAM was utilized and thus this is not a parameter of importance here) We carried out two main experiments, both based on securely computing the AES circuit on shared keys|,Non-data,47
| First, we computed AES in counter mode, with the aim of obtaining maximal throughput Using the full power of the cluster (all cores), we computed over 13 million AES operations per second Furthermore, utilizing a single core we achieved 100,000 AES operations per second, and utiliz- ing 10 cores we achieved amost 1 million AES operations per second|,Non-data,47
| As we will show below in Section 13, this way outperforms all previous protocols of this type Second, we wished to demonstrate that this type of proto- col can be incorporated into a real system We chose to in- tegrate our protocol into a Kerberos KDC in order to carry out Ticket-Granting-Ticket encryption without any single server holding the encryption key (whether it be a server’s key or user’s hashed password)|,Non-data,47
| Such an architecture pro- tects against administrators stealing passwords, or an at- tacker who breaches the network being able to steal all users’ passwords (We stress that in Kerberos, the raw password is never used so once the hashed password is stolen the at- tacker can impersonate the user) We obtained a latency of 110ms on the server and 232ms on the client (over a LAN) for the entire Kerberos login (excluding database lookup) Given that this is for the purpose of user authentication, this is well within the acceptable range|,Non-data,47
| In addition, we are able to support a login storm of over 35,000 user authen- tications per second, which is sufficient even for very large organizations Our results demonstrate that secure computation can be used to solve large-scale problems in practice (at least, for the cases that semi-honest security or privacy for a malicious adversary suffices) 13 Related Work We compare our results with previously reported results on secure AES computation for 3 parties with an honest majority and semi-honest adversaries; see Table 1|,Non-data,47
| We stress that this table gives only very partial informa- tion since different hardware was used for each; we provide it to show the progress made and where we fit into it How- ever, fortunately, the setup used by us is almost the same as that of the latest Sharemind results in [22] (using op- 806timized code that was completely rewritten), and we now provide an in-depth comparison to it The benchmarking in [22] was carried out between three computers with two 8- core Intel Xeon (E5-2640 v3) processors and 128GB RAM, connnected via a 10Gbps Ethernet (this configuration is de- scribed in [16] and by personal communication is that used in [22]), which is almost identical to our configuration de- scribed above The number that we provide in Table 1 for this work is when utilizing 16 cores, and thus this is an almost identical configuration as Sharemind [22] (with 20 cores we achieve 1,324,117 AES operations per second)|,Non-data,47
| Ob- serve that our latency (response time) is 70% of [23] and we achieve a throughput that is 14 times faster than [22] (and so over an order of magnitude improvement) In fact, using a single core and a 1Gbps connection, we achieve approxi- mately 100,000 AES operations per second (and latency of only 129ms); thus we can outperform the best Sharemind results on a very basic setup Year 2010 2012 2013 2016 2016 2016 Ref [10] [18] [19] [23, Table 5|,Non-data,47
|3] [22] Latency Throughput 2000s 1428ms 323ms 223ms - - 320 3450 25,000 90,000 this work 166ms 1,242,310 Table 1: Reported times for semi-honest 3-party computation & honest majority; the throughput is measured in AES computa- tions per second (the last two rows with similar configurations) We remark that other work on garbled circuits (eg|,Non-data,47
|, two- party Yao with semi-honest adversaries) achieves much lower latency (eg, 16ms reported in [13]) However, each garbled AES circuit is of size at least 1|,Non-data,47
|3Mb (using the latest half- gates optimization [26]), not taking into account additional messages that are sent It is therefore physically impossi- ble to go beyond 7500 AES computations per second on a 10Gbps network (where we achieve 14 million) In addi- tion, the two-party GMW approach using efficient oblivious transfer (OT) extensions is blocked by the speed of the OTs (with two OTs required per gate)|,Non-data,47
| Considering the commu- nication bottleneck, each OT requires transmitting a mini- mum of 128 bits Thus, the communication is approximately the same as with a garbled circuit (The fastest known im- plementation [15] can process 5 million OTs per second on a 1Gbps network giving under 500 AES computations per sec- ond This is not far from optimal assuming linear scale-up on a 10Gbps network|,Non-data,47
|) Of course, we require an additional server, in contrast to the Yao and GMW protocols 2 THE NEW PROTOCOL In this section, we describe our new protocol for three par- ties Our protocol works for arithmetic circuits over the ring modulo 2n with Boolean circuits being a special case (with n = 1)|,Non-data,47
| The protocol uses only very simple ring addition and multiplication operations, which in the Boolean case reduces simply to bitwise AND and XOR In addition, the protocol has very low communication: a single ring element is sent per multiplication gate and there is no communication for addition gates In the Boolean case, we therefore have that the only communication is a single bit per AND gate Correlated randomness|,Non-data,47
| Our protocol assumes that for every multiplication gate the three parties P1, P2, P3 are given correlated randomness in the form of random ring ele- ments x1, x2, x3 under the constraint that x1 + x2 + x3 = 0 We show how this can be achieved in practice with great efficiency using AES (Thus, our protocol is information- theoretically secure with perfect correlated randomness, but the actual implementation is computationally secure due to the use of AES to generate the correlated randomness) 2|,Non-data,47
|1 Securely Computing Boolean Circuits In order to simplify the exposition, we begin by describing the protocol for the special case of Boolean circuits with AND and XOR gates We assume that the parties P1, P2, P3 are able to obtain random x1, x2, x3 ∈ {0, 1} such that x1 ⊕ x2 ⊕ x3 = 0 Secret sharing We define a 2-out-of-3 secret sharing bit v, the dealer chooses three random bits x1, x2, x3 ∈ {0, 1} under the constraint that x1 ⊕ x2 ⊕ x3 = 0|,Non-data,47
| Then: (cid:1)-sharing, as follows In order to share a scheme, denoted(cid:0)3 2 • P1’s share is the pair (x1, a1) where a1 = x3 ⊕ v • P2’s share is the pair (x2, a2) where a2 = x1 ⊕ v • P3’s share is the pair (x3, a3) and a3 = x2 ⊕ v|,Non-data,47
| (cid:1)- In order to see that the result constitutes a valid (cid:0)3 It is clear that no single party’s share reveals anything about v In addition, any two shares suffice to obtain v; eg, given x1, x2, a1, a2 we can compute v = a2 ⊕ x1|,Non-data,47
| XOR (addition) gates Let (x1, a1), (x2, a2), (x3, a3) be a secret sharing of v1, and let (y1, b1), (y2, b2), (y3, b3) be a secret sharing of v2 Then, in order to compute a secret sharing of v1 ⊕ v2, each Pi locally computes (zi, ci) with zi = xi ⊕ yi and ci = ai ⊕ bi (no communication is needed) sharing of v1 ⊕ v2, observe first that z1 ⊕ z2 ⊕ z3 = 0 (since both x1 ⊕ x2 ⊕ x3 = 0 and y1 ⊕ y2 ⊕ y3 = 0)|,Non-data,47
| Next, observe that for every i ∈ {1, 2, 3} it holds that ci = zi−1 ⊕ (v1 ⊕ v2) where i−1 = 3 when i = 1; eg, we have c1 = a1⊕b1 = x3⊕ v1⊕y3⊕v2 = (x3⊕y3)⊕(v1⊕v2) = z3⊕(v1⊕v2) Thus, this constitutes a sharing of v1 ⊕ v2 with randomness z1, z2, z3|,Non-data,47
| AND (multiplication) gates We now show how the par- ties can compute AND (equivalently, multiplication) gates; this subprotocol requires each party to send a single bit only The protocol works in two phases: in the first phase the par- ties compute a simple (cid:0)3 (cid:1) XOR-sharing of the AND of the input bits, and in the second phase they convert the (cid:0)3 (cid:1)- sharing into the above-defined(cid:0)3 pute(cid:0)3 1 Step 1 – compute (cid:0)3 Let (x1, a1), (x2, a2), (x3, a3) be a secret sharing of v1, and let (y1, b1), (y2, b2), (y3, b3) be a secret sharing of v2|,Non-data,47
| We as- sume that the parties P1, P2, P3 hold correlated randomness α, β, γ, respectively, where α ⊕ β ⊕ γ = 0 The parties com- (cid:1)-shares of v1 · v2 = v1 ∧ v2 as follows (from here on, we will denote multiplication of a and b by simply ab): (cid:1)-sharing: (cid:1)-sharing 2 2 3 3 3 2 (a) P1 computes r1 = x1y1⊕a1b1⊕α, and sends r1 to P2 (b) P2 computes r2 = x2y2⊕a2b2⊕β, and sends r2 to P3|,Non-data,47
| (c) P3 computes r3 = x3y3⊕a3b3⊕γ, and sends r3 to P1 These messages are computed and sent in parallel 8072 Step 2 – compute(cid:0)3 construct a(cid:0)3 (cid:1)-sharing: In this step, the parties (cid:1)-sharing and (cid:1)-sharing from their given(cid:0)3 2 2 3 the messages sent in the previous step|,Non-data,47
| This requires local computation only (a) P1 stores (z1, c1) where z1 = r1 ⊕ r3 and c1 = r1 (b) P2 stores (z2, c2) where z2 = r2 ⊕ r1 and c2 = r2 (c) P3 stores (z3, c3) where z3 = r3 ⊕ r2 and c3 = r3|,Non-data,47
| (cid:1) sharing of v1v2, meaning fined in Step 1 are indeed a (cid:0)3 Explanation of Step 1: We now show that r1, r2, r3 de- that r1 ⊕ r2 ⊕ r3 = v1 ∧ v2 Observe first that: a1b1 = (x3 ⊕ v1)(y3 ⊕ v2) = x3y3 ⊕ x3v2 ⊕ y3v1 ⊕ v1v2 (1) and similarly a2b2 = x1y1 ⊕ x1v2 ⊕ y1v1 ⊕ v1v2, and a3b3 = x2y2 ⊕ x2v2 ⊕ y2v1 ⊕ v1v2 Thus, r1 ⊕ r2 ⊕ r3 3 = (x1y1 ⊕ a1b1 ⊕ α) ⊕ (x2y2 ⊕ a2b2 ⊕ β) ⊕ (x3y3 ⊕ a3b3 ⊕ γ) = x1y1 ⊕ x2y2 ⊕ x3y3 ⊕ a1b1 ⊕ a2b2 ⊕ a3b3 = x1y1 ⊕ x2y2 ⊕ x3y3 ⊕ (x3y3 ⊕ x3v2 ⊕ y3v1 ⊕ v1v2) ⊕ (x1y1 ⊕ x1v2 ⊕ y1v1 ⊕ v1v2) ⊕ (x2y2 ⊕ x2v2 ⊕ y2v1 ⊕ v1v2) = (x1 ⊕ x2 ⊕ x3)v2 ⊕ (y1 ⊕ y2 ⊕ y3)v1 ⊕ v1v2 = v1v2 is a valid(cid:0)3 (cid:1)-sharing of v1v2 according to our definition, we where the second equality is because α⊕β⊕γ = 0, the third equality is from the equivalences of a1b1, a2b2, a3b3 above (see Eq (1)), the fourth equality is by cancelling repeated values and rearranging the remainder, and the last equality is because x1 ⊕ x2 ⊕ x3 = y1 ⊕ y2 ⊕ y3 = 0|,Non-data,47
| Explanation of Step 2: In order to show that the result need to show that z1, z2, z3 are such that z1 ⊕ z2 ⊕ z3 = 0, and that c1, c2, c3 are of the defined form First, z1 ⊕ z2 ⊕ z3 = (r1 ⊕ r3) ⊕ (r2 ⊕ r1) ⊕ (r3 ⊕ r2) = 0 Second, observe that since c1 ⊕ c2 ⊕ c3 = r1 ⊕ r2 ⊕ r3 = v1v2 (as shown above), it holds that c1 = r1 = v1v2 ⊕ r2 ⊕ r3 However, r2 ⊕ r3 = z3 (by the protocol definition) and thus c1 = v1v2 ⊕ z3, as required|,Non-data,47
 A similar calculation shows the equality for c2 and c3 as well 2 The above explanation shows that the gate computation “works” in the sense that the invariant of the format of the shares is preserved after every gate is computed The fact that the protocol is secure is proved later in Section 3 The protocol,Non-data,47
| The full 3-party protocol works in the nat- ural way The parties first share their inputs using the secret sharing method They then compute each XOR and AND gate in the circuit according to a predetermined topological ordering fo the circuit Finally, the parties reconstruct their output on the output wires|,Non-data,47
| (In the client/server model, ex- ternal clients send the three parties sharings of their input according, and the three parties then compute the circuit in the same way on the shares received) Observe that each party communicates with exactly one other party only This property also holds for the protocol of Sharemind [4, 5] However, our secret-sharing scheme and multiplication protocol are completely different|,Non-data,47
| 22 Generating Correlated Randomness Our protocol relies on the fact that the parties hold ran- dom bits α, β, γ ∈ {0, 1} such that α ⊕ β ⊕ γ = 0 for every AND gate In this section, we show how the parties can efficiently generate such α, β, γ Information-theoretic correlated randomness|,Non-data,47
| It is possible to securely generate correlated randomness with perfect security by having each party Pi simply choose a random ρi ∈ {0, 1} and send it to Pi+1 (where P3 sends to P1) Then, each party takes its random bit to be the XOR of the bit it chose and the bit it received: P1 computes α = ρ3 ⊕ ρ1, P2 computes β = ρ1 ⊕ ρ2 and γ = ρ2 ⊕ ρ3 Observe that α + β + γ = 0 as required In addition, if P1 is corrupted, then it knows nothing about β and γ except that β ⊕ γ = α|,Non-data,47
| This is because β and γ both include ρ2 in their computation and this is unknown to P1 A similar ar- gument holds for a corrupted P2 or P3 Despite the elegance and simplicity of this solution, we use a different approach This is due to the fact that this would double the commu- nication per AND gate; it is true that this is still very little communication|,Non-data,47
| However, given that communication is the bottleneck, it would halve the throughput Computational correlated randomness We now show how it is possible to securely compute correlated randomness computationally without any interaction beyond a short ini- tial setup This enables us to maintain the current situa- tion where parties need only transmit a single bit per AND gate|,Non-data,47
| This method is similar to that of the PRSS subprotocol in [9], but simpler since Shamir sharing is not needed Let κ be the security parameter, and let F : {0, 1}κ × {0, 1}κ → {0, 1} be a pseudorandom function outputting a single bit 1 Init: (a) Each Pi chooses a random ki ∈ {0, 1}κ|,Non-data,47
| (b) Party P1 sends k1 to P3, party P2 sends k2 to P1 and party P3 sends k3 to k1 P1 holds k1, k2, P2 holds k2, k3 and P3 holds k3, k1 2 GetNextBit: Given a unique identifier id ∈ {0, 1}κ, (a) P1 computes α = Fk1 (id) ⊕ Fk2 (id)|,Non-data,47
| (b) P2 computes β = Fk2 (id) ⊕ Fk3 (id) (c) P3 computes γ = Fk3 (id) ⊕ Fk1 (id) Observe that α⊕ β ⊕ γ = 0 Furthermore, P1 does not know k3 which is used to generate β and γ|,Non-data,47
| Thus, β and γ are pseudorandom to P1, under the constraint that β ⊕ γ = α In practice, the id can be a counter that all parties locally increment at every call to GetNextBit 23 The Ring Modulo 2n and Fields Our protocol above works for Boolean circuits|,Non-data,47
| However, in some cases arithmetic circuits are far more efficient In this section, we show how to generalize the protocol above to the general case of the ring modulo 2n and arbitrary fields of size greater than 2 We describe the protocol for the ring modulo 2n; it is clear that everything holds for arbitrary finite fields and rings in which 3−1 exists (The only thing that is needed is to be able to divide by 3 which is defined by adding the unity to itself 3 times|,Non-data,47
| This is possible in the ring modulo 2n since gcd(3, 2n) = 1, and is always possible in a field) From here-on in this section, all arithmetic is mod2n We remark that when taking n = 1 we have that addition (and subtraction) is the same as XOR, and multiplication is the same as AND In this case, the protocol here is exactly that described in Section 2|,Non-data,47
|1 (cid:1)-secret sharing In order to share an element v mod 2n the dealer chooses three random elements x1, x2, x3 ∈ Z2n (cid:0)3 2 808under the constraint that x1 + x2 + x3 = 0 Then, P1’s share is (x1, a1) where a1 = x3 − v, P2’s share is (x2, a2) where a2 = x1−v, and P3’s share is (x3, a3), where a3 = x2−v|,Non-data,47
| As in the Boolean case, it is easy to see that each share reveals nothing of v, and that any two shares suffice to reconstruct v We now show that each party’s share reveals nothing about the secret For simplicity, we show this for P1 (all others are shown in a similar way) Party P1’s share consists of the pair (a1, x1) where a1 = x3 − v|,Non-data,47
| Since x1, x2, x3 are random under the constraint that x1 + x2 + x3 = 0, this is equiva- lent to x1 and x3 being chosen independently at random and then x2 being chosen to equal −x1 − x3 In this light, a1 in P1’s share is a one-time pad encryption of v using random key x3, and x1 is an independent random value Thus, P1’s share reveals nothing about v whatsoever This implies: Lemma 2|,Non-data,47
|1 For any two values va, vb ∈ Z2n and any i ∈ {1, 2, 3}, the distribution over Pi’s share (xi, ai) of va is identical to the distribution over Pi’s share (yi, bi) of vb Addition gates As in the Boolean case, addition gates are computed by locally adding the shares modulo 2n|,Non-data,47
| Multiplication gates: Let (x1, a1), (x2, a2), (x3, a3) be a secret sharing of v1, and let (y1, b1), (y2, b2), (y3, b3) be a secret sharing of v2, and assume the parties P1, P2, P3 hold α, β, γ ∈ Z2n respectively, such that α + β + γ = 0 In order (cid:1)-sharing of the product of two values, the to compute a (cid:0)3 2 3 and sends r1 to P2 parties work as above with the following differences: 1 P1 computes r1 = a1b1−x1y1+α 2|,Non-data,47
 P2 computes r2 = a2b2−x2y2+β 3 P3 computes r3 = a3b3−x3y3+γ 4 P1 defines its share as z1 = r3 − r1 and c1 = −2r3 − r1 5,Non-data,47
 P2 defines its share as z2 = r1 − r2 and c2 = −2r1 − r2 6 P3 defines its share as z3 = r2 − r3 and c3 = −2r2 − r3 and sends r3 to P1,Non-data,47
| and sends r2 to P3 3 3 We remark that the above computation is legal since 3 is relatively prime to 2n; thus 3 has an inverse In addition, the above all holds in finite fields with more than 3 elements In order to see that r1 + r2 + r3 = v1v2, first observe that a1b1 = (x3 − v1)(y3 − v2) = x3y3 − x3v2 − y3v1 + v1v2 (2) and likewise a2b2 = x1y1 − x1v2 − y1v1 + v1v2 and a3b3 = x2y2 − x2v2 − y2v1 + v1v2|,Non-data,47
| Then, 3(r1 + r2 + r3) = a1b1 − x1y1 + α + a2b2 − x2y2 + β + a3b3 − x3y3 + γ = a1b1 + a2b2 + a3b3 − x1y1 − x2y2 − x3y3 = 3v1v2 − v1(y1 + y2 + y3) − v2(x1 + x2 + x3) = 3v1v2 where the second equality holds since α + β + γ = 0 and the third equality follows by plugging in the equivalences of a1b1, a2b2, a3b3 above (see Eq (2)) and rearranging the elements, and the fourth equality follows from the fact that x1 + x2 + x3 = y1 + y2 + y3 = 0 Since we can divide by 3 in this ring (and in a field) we have that r1 + r2 + r3 = v1v2 Next, we show that the shares the parties hold are a valid shares are (z1, z3 − v1v2), (z2, z1 − v1v2) and (z3, z2 − v1v2) such that z1 + z2 + z3 = 0 mod 2n|,Non-data,47
| First, observe that the sum of the first elements of the shares is z1 + z2 + z3 = (r3 − (cid:1)-sharing of v1v2 according to our definition ie, that the (cid:0)3 2 r1) + (r1 − r2) + (r2 − r3) = 0 as required Second, for party P1 it holds that, c1 = −2r3 − r1 = −r3 − r3 − r1 − r2 + r2 = (r2 − r3)− (r1 + r2 + r3) = z3 − v1v2 as required (recall that z3 = r2 − r3 in the protocol)|,Non-data,47
| Correctness for P2 and P3 follows similarly In the proof of security, we show that the secret is per- fectly hidden by the resulting secret sharing This hiding follows from the use of the correlated randomness in the computation In particular, the random values α, β, γ that the parties add in the local computation perfectly mask the value on the wire|,Non-data,47
| Generating correlated randomness The parties use the same (computational) method as described in Section 22, with the following differences First, we assume that Fk is a pseudorandom function mapping strings into Z2n (or equivalently to {0, 1}n)|,Non-data,47
| Second, party P1 computes α = Fk1 (id)− Fk2 (id), party P2 computes β = Fk2 (id)− Fk3 (id), and party P3 computes γ = Fk3 (id) − Fk1 (id) 24 Protocol Efficiency and Comparison In the case of arbitrary finite fields, Shamir’s secret-sharing [24] is “ideal”, meaning that the size of the share equals the size of the secret (which is minimum size), as long as the number of parties is less than the size of the field In our pro- tocol, the secret sharing scheme is not ideal since it consists of two ring or field elements instead of a single field element|,Non-data,47
