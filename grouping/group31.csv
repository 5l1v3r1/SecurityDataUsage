 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| That is, we define the functional- ity f×(a, b) = (c, d) where c⊕ d = a· b The folklore protocol for computing f× works as follows: 1 Parties P1 and P2 hold input bits a ∈ {0, 1} and b ∈ {0, 1}, respectively 2|,Non-data,76
| P1 chooses a random r ∈ {0, 1} P1 sets x0 = r and x1 = r ⊕ a 3 P1 and P2 run a bit oblivious transfer where P1 plays the sender with inputs (x0, x1) and P2 plays the receiver with input bit b|,Non-data,76
 Party P2 receives xb 4 P1 outputs r and P2 outputs xb Observe that xb = r ⊕ a · b (since b = 0 implies that xb = x0 = r and b = 1 implies that xb = x1 = r ⊕ a),Non-data,76
| Thus, r ⊕ xb = a · b, as required The cost of securely computing f× is therefore a single OT The protocol is trivially secure since the only information received is via the OT; thus P1 learns nothing and P2 learns only its share of the output Secure string-bit multiplication|,Non-data,76
| Observe that within Eq (2), we need to also multiply Rj by a bit It is possible to use f× for this However, since Rj is of length κ (in practice, say 128), this increases the number of oblivious transfers by κ, which is very significant|,Non-data,76
| We therefore would like to securely compute the functionality f κ×(s, b) = (c, d) where c ⊕ d = s · b and where s ∈ {0, 1}κ and b ∈ {0, 1} Fortunately, f κ× can be securely computed using a single string OT in the exact same way as f× with P1 inputting (r, r ⊕ s) in the oblivious transfer Thus, this also costs a single oblivious transfer 3|,Non-data,76
|12 The Protocol for FGC We describe our protocol in the (f×, f κ×)-hybrid model where the parties have access to a trusted party computing f× and f κ× for them As we have seen, these functionalities can be securely computed efficiently using oblivious transfer Protocol 3|,Non-data,76
|1 (Securely Computing Eq (2)) 1 Step 1: In this step, the parties securely compute XOR def= λu · λv|,Non-data,76
| Recalling that each party Pi shares of λuv holds λi u, λi v, we have that λuv = λu · λv = (cid:16)⊕n = i=1λi u · λi v (cid:16)⊕n (cid:17) ·(cid:16)⊕n (cid:17) ⊕(cid:16)⊕i(cid:54)=jλi i=1λi u i=1λi u u · λj v (cid:17) (cid:17)  (3) u · λi u, λi u·λi v In addition, u, λj v) v) in order to obtain XOR shares of the prod- v together with all of the uv Each party Pi can locally compute λi each pair of parties Pi, Pj (with i (cid:54)= j) runs f×(λi and f×(λj ucts|,Non-data,76
| Finally, each Pi XORs λi output shares received from f×; denote the result by λi By Eq (3), it follows that ⊕n uv = λuv, as required 2 Step 2: Given shares of λuv = λu · λv, the parties gener- def= λu · ̄λv ⊕ def= ̄λu · ̄λv ⊕ λw|,Non-data,76
| def= λuv ⊕ λw, of λu ̄vw ate XOR shares of λuvw λw, of λ ̄uvw This can be carried out using local computation only def= ̄λu · λv ⊕ λw, and of λ ̄u ̄vw i=1λi uv ⊕ λi w (where λi Trivially, in order to obtain shares of λuvw it suffices for each Pi to compute λi uvw = λi w is its input share on the output wire) Furthermore, observe that λu · ̄λv = λu · (λv ⊕ 1) = λu · λv ⊕ λu Thus, each Pi can compute its share λi u ̄vw = uv ⊕ λi λi w|,Non-data,76
| In a similar way, each Pi computes its u⊕λi v⊕λi shares λi w (where P1 XORs its result with 1 in this last case) u ⊕ λi ̄uvw = λi uv⊕λi uv⊕λi  ̄u ̄vw = λi w and λi v⊕λi 3 Step 3: In this step, the parties securely compute XOR shares of Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw), for every j = 1,  |,Non-data,76
|  , n and every α, β ∈ {0, 1} Observe that they al- ready have XOR shares of λuvw, λu ̄vw, λ ̄uvw, λ ̄u ̄vw, and so need only to run f κ× That is, for every j = 1, |,Non-data,76
|   , n, party Pj runs four invocations of f κ× with every Pi In ev- ery invocation Pj inputs Rj, whereas Pi inputs its share λi uvw in the first invocation, λi u ̄vw in the second invoca- tion, and so on|,Non-data,76
| Denote by ρi j,α,β party Pi’s share of Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw) 4 Step 4: In this final step, the parties conclude the secure computation of Eq (2); recall that the aim is for each party to hold the 4n values { ̃gj j=1|,Non-data,76
| We describe this for general α, β and use the shares of ρi that were generated above 1,1}n 1,0, ̃gj 0,1, ̃gj 0,0, ̃gj j,α,β 584For every j = 1,   |,Non-data,76
| , n and every α, β ∈ {0, 1}, party Pj sends F 2 j,α,β to all other parties, u,α,kj kj (g ◦ j) ⊕ kj w,0 ⊕ ρj v,β and each party Pi sends the string F 2 u,α,ki j,α,β ki to all other parties The parties then XOR all these values together, and the result is ̃gj α,β, as required v,β (g◦j)⊕ρi Security Intuitively, the protocol is secure since in Steps 1– 3 the only values that the parties see are random shares out- put from f× and f κ×|,Non-data,76
| Then, in Step 4, the parties all send their shares to each other However, these shares are all random under the constraint that their XOR is ̃gj α,β, and so reveal nothing but the result The full proof of the following will appear in the full version of this paper Theorem 3|,Non-data,76
|2 Protocol 31 securely computes the n-party FGC functionality with n parties in the (f×, f κ×)-hybrid model, in the presence of a semi-honest adversary corrupting any number of parties Cost|,Non-data,76
| Using the OT extension protocol of [20, 3], we have that each (bit or string) oblivious transfer costs two hash function invocations and two rounds of communication (a single message from the receiver to the sender and a sin- gle message back) However, bit-OT is significantly cheaper than string-OT since it requires much less communication, which is the bottleneck Note that bit-OT is much faster than string-OT, but a single string-OT for strings of length κ is much faster than running κ executions of bit-OT We count the number of OT calls run by each party (as sender and as receiver); recall that f× is just a single bit- OT and f κ× is just a single string-OT|,Non-data,76
| The number of OT invocations equals 2(n−1) bit-OT plus 8(n−1) string-OT: in Step 1 each party computes 2(n− 1) bit-OTs, and in Step 3 each party computes 8(n− 1) string-OTs (4(n− 1) as sender and 4(n− 1) as receiver) Observe that the use of f κ× instead of κ calls to f× is very significant and reduces the cost in Step 3 from 8(n − 1)κ bit-OTs to 8(n − 1) string-OTs The number of rounds in the entire protocol is five; two rounds in each of Step 1 and 3, and a single message in Step 4 3|,Non-data,76
|13 Reducing the Number of String-OTs We now show that it is possible to reduce the number of string-OTs from 8(n−1) to 6(n−1), saving 25% Specifically, we show how it is possible to securely compute ̃gj 1,1 from the shares ρi j,1,0 (see Step 3 of the protocol) without running any OTs As a result, the parties do not need to run the f κ× invocations where the receiver inputs its share of λi ̄u ̄vw|,Non-data,76
| This means that each Pj only needs to run three invocations of f κ× as sender, instead of four j,0,1⊕ρj parties, and each party Pi sends the string F 2 ki u,1,ki j,0,0 ⊕ ρi ρi XOR of all these values is ̃gj denote ⊕n the XOR of all these values equals 1,1, party Pj sends the message j,1,0 to all other (g◦ j)⊕ j,1,0 to all other parties We argue that the In order to see this, first (g ◦ j) by Kg,j Then, we have that w,0 ⊕ Rj(cid:1)⊕ρj (g◦j)⊕(cid:0)kj In order to compute ̃gj i=1F 2 ki u,1,ki j,0,1 ⊕ ρi j,0,0⊕ρj F 2 kj u,1,kj j,0,1, ρi j,0,0, ρi 1,1|,Non-data,76
| v,1 v,1 v,1 Kg,j ⊕ kj w,0 ⊕ Rj ⊕ Rj · (λu · λv ⊕ λw) ⊕ Rj ·(cid:0) ̄λu · λv ⊕ λw (cid:1) ⊕ Rj ·(cid:0)λu · ̄λv ⊕ λw (cid:1)  Rewriting the above, we have that it equals Kg,j ⊕ kj ⊕Rj · (1 ⊕ λu · λv ⊕ ̄λu · λv ⊕ λu · ̄λv ⊕ λw) w,0 (Note that v,1 λw appears 3 times and so 2 cancel out) Now, for any bits x, y ∈ {0, 1}, it holds that 1 ⊕ x · y ⊕ ̄x · y ⊕ x · ̄y = ̄x · ̄y|,Non-data,76
| Thus, we conclude that the XOR of all the values equals Kg,j ⊕ kj w,0 ⊕ Rj ·(cid:0) ̄λu · ̄λv ⊕ λw (cid:1) which is exactly ̃gj 1,1 The security of this optimization holds since all messages (g◦j) and therefore reveal noth- sent are masked by F 2 ki u,1,ki ing (They look random and so can be easily simulated) 3|,Non-data,76
|14 Using More Efficient OT It was shown in [3] that in the Yao protocol, it is pos- sible to use a variant of OT – called correlated OT – that is significantly more efficient This version of OT can be used when there is a difference ∆ and the sender’s input is a random pair (x0, x1) with x0 ⊕ x1 = ∆ When using the free-XOR method within Yao’s protocol, it follows that the garbled labels on the input wires can be random un- der the constraint that they have a fixed difference|,Non-data,76
| Thus, correlated-OT suffices Observe now that all the calls to OT are for computing f× and f κ× In these protocols, party P1 with input bit a (resp, string s) runs the OT-sender with random inputs (x0, x1) under the constraint that x0⊕x1 = a (resp|,Non-data,76
|, x0 ⊕ x1 = s) The protocols are not described in that way, but this is the result of choosing r and setting x0 = r and x1 = r⊕ a Thus, it is possible to use the correlated-OT protocol here and save additional cost 3|,Non-data,76
|2 A New BGW-Based Protocol The FairplayMP [7] system used the information-theoretic BGW protocol [8] in order to securely compute the FGC functionality In this section, we present a protocol that also uses the BGW protocol in order to securely compute FGC  However, there are a number of important differences: 1 We point out and fix a small bug in the FairplayMP pro- tocol: In FairplayMP, each party singlehandedly chooses all the keys for its input wires|,Non-data,76
| This renders the protocol insecure: every party is able to compute the circuit mul- tiple times, with different inputs of its own (with a fixed setting of the other parties’ inputs) 2 FairplayMP works over a prime-order field In contrast, we work in GF (2k) which is a field of characteristic 2|,Non-data,76
| First and foremost, this makes it possible to incorporate the free-XOR technique into BMR Second, by using a field of characteristic 2, we are able to reduce the round complexity of the protocol This is due to the fact that in such a field the XOR of λuv with λw (as required when computing Eq (2)) can be carried out with local compu- tation only|,Non-data,76
| In contrast, FairplayMP requires interaction to compute this (XOR is not addition in their finite field, and so they need a protocol to compute this) 3 We use a finite field that is large enough to embed each individual key kj u,α, whereas FairplayMP embed the en- u,α of length n · κ in the finite u,α,  |,Non-data,76
|  , kn tire “superseed” k1 In the case of 33 parties and keys of length 128 field bits, FairplayMP would have to work in a finite field with elements of size at least 4,224 bits This means that Fair- playMP scales poorly for large numbers of parties (since each operation becomes more expensive)|,Non-data,76
| In contrast, we work with each key separately and so the finite field is always of length κ, resulting in linear growth in the cost per party (at least with respect to the basic operations over k1 u,α,    , kn u,α)|,Non-data,76
| 5854 We compute multiplications of the λ combinations only with R1,   |,Non-data,76
| , Rn In contrast, FairplayMP compute their analog of Eq (2) by multiplying both k1 u,0 and u,1 ◦ ··· ◦ kn k1 u,1 with the λ combinations u,0 ◦···◦ kn As we will see below, the focus of our protocol design here was to reduce the number of rounds to an absolute minimum|,Non-data,76
| Our basic BGW-based protocol In general, BGW can be used to compute any arithmetic circuit Furthermore, addition is free in the circuit, and multiplication requires in- teraction (and computation) When working in a finite field of characteristic 2, it follows that XOR equals addition, mak- ing the computation of Eq|,Non-data,76
| (2) trivial Specifically, Eq (2) simply defines an arithmetic circuit over the field with two multiplications and 4n additions To be exact, in order to compute ̃gj α,β: ⊕ kj F 2 kj u,α,kj 1|,Non-data,76
| Party Pj inputs values Kj, Rj, Uj, Vj, Wj where Kj = v ⊕ β and Wj = λj w 2 Each party Pi (i (cid:54)= j) inputs Ki, Ui, Vi, Wi where Ki = u⊕ α, Vj = λj w,0, Uj = λj v,β F 2 u,α,ki ki v,β , Ui = λi u, Vi = λi v and Wi = λi w 3|,Non-data,76
| Using BGW, the parties evaluate the circuit for: i=1Wi)) i=1Ki)⊕Rj·((⊕n i=1Vi)⊕(⊕n i=1Ui)·(⊕n (⊕n Beyond the ability to use free-XOR, we therefore see that the choice of the field to be of characteristic 2 yields a much simpler protocol as well Since BGW is secure, we have that this protocol for computing FGC is automatically secure Protocol details and round complexity – BGW4|,Non-data,76
| The above BGW protocol can be carried out in just 4 rounds of communication; for this reason we call it BGW4 (to distin- guish it from other variants that we will describe below) In order to see how 4 rounds suffice, we describe its steps in de- α,β values (for all j = 1,   |,Non-data,76
| , n, all α, β ∈ {0, 1} and tail All ̃gj all gates) are computed in parallel Each value is computed as follows: Communication round 1: All inputs are shared using t-out- of-n Shamir secret sharing, with t = (cid:100)n/2(cid:101) − 1 Local computation: The parties carry out local additions, as required by the circuit, in order to obtain shares of λu⊕ α = i=1Ui and λv⊕β = ⊕n ⊕n i=1Vi|,Non-data,76
| In addition, the parties locally multiply their shares of λu ⊕ α and λv ⊕ β Denote this product by λα,β u,v  Communication round 2: The parties run the GRR [14] de- gree reduction step on the product λα,β u,v to recover legitimate shares of λα,β u,v of degree t This is best achieved by each party i resharing ci · λα,β u,v in a t-out-of-n sharing, where ci is a fixed (degree-reduction) constant of that party (which is precomputed once), and then summing the received shares|,Non-data,76
| u,v ⊕ λw with Rj Local computation: The parties locally add their shares of λw to λα,β u,v  Next, the parties once again locally multiply their shares of λα,β Communication round 3: The parties run the GRR degree reduction step on Rj · (λα,β Local computation: The parties locally add the shares of the Ki values to the result of the previous step Communication round 4: The parties send their shares to each others and reconstruct to obtain ̃gj u,v ⊕ λw) as above|,Non-data,76
| α,β Computational complexity The above is repeated 4n times for each gate with each computation requiring 3 Shamir secret sharings Each sharing requires evaluating a degree-t polynomial on n points, which takes t· n ≈ n2/2 field multi- plications|,Non-data,76
| The number of multiplications is therefore dom- inated by the first and third communication rounds, where the number of shares is ≈ 4n per gate, thus requiring ≈ 2n3 multiplications per gate Therefore, asymptotically, the par- ties compute 4n3 field multiplications per gate of the circuit (concretely, there are slightly more), which is cubic in the number of parties As we will see in Section 4, this signifi- cantly affect performance when the number of parties is not small (We stress that the number of multiplications would be only quadratic had we worked in a field of size n·κ|,Non-data,76
| How- ever, since multiplication is quadratic, the cost of computing one multiplication in a field of size n · κ is n2 · κ2, versus a cost of n · κ2 for n multiplications in a field of size κ) 33 Reducing the Round Complexity In this section, we briefly describe how the number of rounds can be further reduced The idea of reducing rounds by omitting reduction steps in BGW already appeared in [19], but the following is a more concretely efficient way of achieving this|,Non-data,76
| BGW3 – three rounds with an honest majority The protocol described above that is secure with an honest ma- jority has 4 rounds of communication However, it is possible to save one round of communication by simply not running the degree reduction step on the Rj · (λα,β u,v ⊕ λw) values This works since the parties only add their shares of the Ki values to Rj · (λα,β u,v ⊕ λw)|,Non-data,76
| Thus, if the Ki values are shared using a 2t-degree polynomial instead (at the onset), then the degrees of the shares of Ki and Rj ·(λα,β u,v ⊕λw) will be equal, and so they can be locally added The reconstruction works in the same way, and thus this yields a 3-round protocol We remark that beyond the fact that this has one round less, it also has far less communication This is because the second degree-reduction is carried out on the shares of Rj · (λα,β u,v ) and so there are 4n degree-reductions per gate, resulting in a large amount of bandwidth|,Non-data,76
| Thus, as we will see in Sec- tion 4, this protocol is always better, and often significantly better, than the 4-round protocol BGW4 BGW2 – two rounds with more than 2/3 honest It is possible to further reduce the round complexity of the protocol to just two rounds in the case that more than 2/3 of the parties are guaranteed to be honest, since no degree reduction is needed at all However, this has less effect on the amount of communication (since there are only a small number of degree reductions remaining)|,Non-data,76
 34 Optimizing Field Multiplications We use κ = 128 and therefore work in GF (2128) We use the Intel PCLMULQDQ carry-less multiplication instruc- tion to obtain extremely fast pipelined multiplication oper- ations in GF (2128) [16] This works by combining 4 carry- less multiplication operations over 64-bit operands,Non-data,76
| In addi- tion, observe that the majority of the multiplications are for generating Shamir secret sharing This works by taking a distinct field element ωi for every party, and evaluating ran- dom polynomials on these values (which means multiplying by ωi, ω2 i ) By choosing ωi to be of small degree, we have that for a small enough d, all of ωi, ω2 i are less i ,  |,Non-data,76
|  , ωd i ,   |,Non-data,76
| , ωd 586than 64 bits long, and so a 128-bit element is multiplied with a 64-bit element This can be achieved in just 2 carry-less multiplications instead of 4 When the number of parties exceeds 15, at least 5 bits are needed for each ωi value and so the length of ωd i exceeds 64 bits, making the optimization no longer applicable 4|,Non-data,76
| EXPERIMENTAL EVALUATION We implemented our protocols and ran multiple experi- ments for different circuit sizes and depths, different num- ber of parties, and different latencies In order to obtain a deeper understanding of the strengths and (possible) weak- nesses of the BMR protocol, we included the GMW proto- col in our experiments The GMW protocol has multiple rounds of communication, but far less bandwidth than the BMR protocol In addition, it is currently the only other general protocol for multiparty computation for the case of dishonest majority known|,Non-data,76
| We used the code of [10] for these experiments As described in Section 13, this code is highly optimized and uses OT extension in an offline phase for precomputing the oblivious transfers We ran their code on the same circuits and platforms as our BMR code|,Non-data,76
| (For the sake of brevity, in this section we refer to “BMR” as our different protocols; it is not to be misinterpreted as the original protocol of [5] which was purely theoretical) We measured times separately for the offline and online portion of the executions In BMR, the entire construction of the circuit can be run offline, before the inputs are given Thus, the online phase has very little communication and is dominated by local computation of the circuit|,Non-data,76
| In con- trast, in the GMW protocol, the offline phase consists only of preprocessing the oblivious transfers We stress that the code of [10] does not merely run the base OTs as part of the OT extensions in the offline phase Rather, they run random OTs and use the OT preprocessing method of [4] Thus, in the online phase, the receiver sends a single bit to the sender and the sender replies with two bits|,Non-data,76
| In addition, the parties entire computation requires merely XORing the preprocessed bits with the actual inputs As a result, the GMW online phase has very little computation and com- munication, but many rounds of communication We stress that in applications where low latency is required, the online time of a protocol is the main factor to be considered (as- suming reasonable offline time) In contrast, in cases where the overall throughput is what is important, the total time is the main factor to be considered|,Non-data,76
| Platforms and parameters We ran our experiments on three different platforms First, we ran them on a clus- ter with a very low latency network called CREATE [1] (which is part of the DETER project) The cluster is com- prised of Intel XEON 2|,Non-data,76
|20 GHz machines (E5-2420) with 6 cores running Linux (Ubuntu1404-64-STD), and with a 1Gb connection and ping time between computers of ap- proximately 01ms In addition, we ran our experiments on Amazon c48xlarge instances (running Windows Server 2012 R2 Base) in two configurations: in the first, all ma- chines are located in a single zone (Virginia); in the second, the machines were split between Ireland and Virginia (in preliminary experiments, this gave similar performance to where the latency was the same between all parties)|,Non-data,76
| The ping time within a single region is approximately 1ms, and the ping time between Virginia and Ireland is approximately 75ms The bandwidth of all connections (according to Ama- zon’s specifications) is 10Gb The experiments in CREATE provide a very clean (low-latency) environment without ex- ternal network effects, whereas the experiments in Amazon reflect performance in more “real-world” settings with net- working fluctuation We ran the protocol for 3, 5, 7, 9, 11 and 13 parties, and in some cases 33 parties|,Non-data,76
| We used 2 different circuits: a circuit computing the AES function with 6,800 AND gates and 256 input wires per party, and a circuit computing SHA256 with 90,825 AND gates and 512 input wires per party Since the depth of the circuit is very significant for GMW, we also generated 4 synthetic circuits of the same size as the SHA256 circuit, but with respective depths of d = 10, d = 100, d = 1000 and d = 4000 (the real SHA256 circuit has depth 4000) Raw results Each experiment was run 50 times, and we computed the mean and standard deviation of all runs|,Non-data,76
| The numbers in the tables here are measured in milliseconds, and present a 95% confidence interval Observe that the interval is sometimes very large This is especially true in Amazon in Virginia-Ireland This expresses the reality that when sending a large amount of data over the Internet, the fluctuations are significant|,Non-data,76
 The full tables containing all results will appear in the full version of this paper 41 Protocol Improvements Measurements We measured the effect of the different protocol optimiza- tions on the running time We ran the basic OT-based pro- tocol without additional optimizations (Section 3,Non-data,76
|12), with the reduced number of OTs (Section 313), using correlated- OT (Section 3|,Non-data,76
|14), with the free-XOR optimization, and with two threads between every pair of parties (increasing to more than two threads between every pair of parties reduced performance since the number of threads becomes very high with many parties) Our measurements were made on the CREATE platform, with 13 parties and the SHA-256 circuit with 90,825 AND gates and 42,029 XOR gates The results are as follows: Basic Red|,Non-data,76
| OT Free-XOR 2 OT-Threads OT-Off 6434 5549 ± 207 4011 ± 156 2851 ± 101 2633 ± 117 311 ± 20 OT-On 434 ± 36 399 ± 46 313 ± 18 C-OT The gain by using a reduced number of OTs and by using the correlated-OT protocol is very significant In all cases, free-XOR provides exactly the expected speedup by drop- ping the cost by the ratio of XOR gates to overall gates Since all the improvements are also related to communica- tion, we also tested them in a network with network latency of 76 ms (with 13 parties and the SHA-256 circuit, as above) The results are: Basic Red|,Non-data,76
| OT Free-XOR 2 OT-Threads OT-Off 45631 42408 ± 6300 40644 ± 6266 31071 ± 6720 28805 ± 6878 OT-On 664 ± 128 746 ± 56 773 ± 49 655 ± 81 C-OT We also ran our 3-round BGW-based protocol in the LAN setting on the CREATE platform, measuring the influence of optimized multiplications, free-XOR, and multithreading Basic Opt Mult Free-XOR 2 Mult|,Non-data,76
 Threads BGW3 Offline 9179 ± 278 8472 ± 294 5809 ± 236 42 Protocol Comparison – High Latency 5027 ± 101 Our focus in this paper is the design and implementation of a protocol that is suitable for Internet settings with high 587computation time of BMR-type protocols may become a fac- tor See Fig 4 for a graph comparing the total running time,Non-data,76
 latency We compared our OT-based protocol of Section 31 with the BGW-based protocols described in Section 32 and with GMW,Non-data,76
| The running-time of our protocol using mul- tiparty garbled circuits is unaffected by the circuit depth, in contrast to GMW We therefore ran GMW on different depths for the SHA256-type circuit but not our protocols The results of these executions are found in Tables 1 and 2 We remark that the variance of the executions is very large, resulting in some unexplained anomalies|,Non-data,76
| (For exam- ple, the online time should be the same for all versions, and should increase with the number of parties However, in Ta- ble 1 you can see that the online time for 7 parties in the OT version is lower than expected) We conjecture that this is due to the large bandwidth of the protocols and the “noisy” Amazon environment 3 OT 698 ± 930 138 ± 88 329 ± 688 143 ± 81 Off On BGW3 Off On BGW2 Off On 498 ± 737 BGW4 Off 139 ± 78 On 231 ± 143 GMW Off On 3337 ± 166 7 13 9699 ± 6119 1093 ± 1249 362 ± 515 107 ± 87 9774 ± 8181 2314 ± 1218 329 ± 533 142 ± 76 2212 ± 1440 8745 ± 6832 264 ± 409 148 ± 92 3149 ± 2065 13298 ± 10576 308 ± 473 159 ± 70 277 ± 1067 382 ± 290 3232 ± 9 3341 ± 213 Table 1: The AES circuit – 6800 AND gates (depth 40) OT BGW2 BGW4 BGW3 Off On Off On Off On Off On Off (d=4000) On Off On Off On Off (depth=10) On (d=1000) (d=100) GMW GMW GMW GMW 3 6426 ± 1651 5404 ± 11751 172 ± 76 182 ± 77 8124 ± 8000 226 ± 78 850 ± 900 701 ± 556 77147 ± 4031 735 ± 509 8038 ± 518 598 ± 362 880 ± 75 7 226 ± 62 237 ± 91 283 ± 86 282 ± 86 10291 ± 4968 17011 ± 23574 14781 ± 12134 23521 ± 20794 5002 ± 10643 3581 ± 4976 83168 ± 19932 2610 ± 8173 8327 ± 80 1180 ± 521 906 ± 25 13 456 ± 357 520 ± 659 459 ± 325 454 ± 281 25215 ± 4784 38584 ± 35997 37585 ± 17255 65736 ± 45895 5042 ± 9212 7932 ± 16242 82111 ± 5584 4969 ± 9222 8341 ± 271 5360 ± 12829 904 ± 84 309741 ± 32130 333996 ± 92024 329220 ± 31340 Table 2: The SHA256 circuit – 90,825 AND gates In this Internet-setting, for not shallow circuits, the com- munication rounds become the dominating factor and so GMW becomes untenable in the online phase for deep cir- cuits|,Non-data,76
| At its most extreme, for the real SHA256 circuit of depth 4000, we have that BMR-OT with 13 parties took 26 seconds overall and under half a second online time, whereas GMW took 335 seconds overall and 330 seconds online time (a difference of one order of magnitude overall, and two or- ders of magnitude for the online time) This difference grows even larger for 3 parties since GMW is less affected by the number of parties than our protocols It is important to note that for low-depth circuits, GMW performs remarkably well even in an Internet setting This is no surprise for depth-10 and overall time, since the round complexity of both protocols is almost the same|,Non-data,76
| However, even for depth-100, GMW outperforms our protocols for 7 or more parties This is very informative and is important to explain The complexity of GMW is linear in the number of parties, versus BMR that is quadratic Thus, when the number of parties grows, this becomes a factor|,Non-data,76
| Despite this, the online time of our protocols are always better (even for depth 10 circuits alone), and the number of parties is heavily outweighed by the networking cost for non-shallow circuits However, for a very large number of parties, the quadratic Figure 4: Total time GMW vs BMR in Amazon (Virginia-Ireland) 43 Protocol Comparison – Low Latency Over the past years it has become clear that different se- cure computation protocols are better suited to different set- tings As such, an important question to answer is when is one protocol better than another|,Non-data,76
| We therefore ran experi- ments comparing our protocols on two low latency networks: on the CREATE platform with a ping time of 01ms and within the Amazon Virginia region with a ping time of 1ms Our aim was to understand at what point GMW becomes better than our constant-round protocols based on BMR Before proceeding to the results, we review the running- time of the protocol as a function of the number of parties|,Non-data,76
| A theoretical analysis shows that with respect to the number of parties, in the offline phase: GMW scales linearly, the BMR- OT protocol scales quadratically (the OT part is linear, but each party sends messages of length 4nκ||C|| to each other party, meaning that each party must send messages of total size 4n2κ||C||), while the BMR-BGW protocols scale cubically (recall that by this we mean that each party works linearly, quadratically or cubically) In contrast, in the online phase, the BMR protocols are all the same and we have that GMW scales linearly and BMR scales quadratically This analysis yields an interesting and rather complicated tradeoff On the one hand, GMW scales better than BMR with respect to the number of parties; on the other hand, BMR scales far better as the depth of the circuit increases|,Non-data,76
| This tradeoff becomes more extreme when considering the BGW-based protocols for BMR since they are cubic As we will see, this is the cause of their downfall, and they rarely perform well CREATE – 01ms ping time|,Non-data,76
| The aforementioned dif- ference in computational time is most evident in CREATE where latency is very low; see Figure 5 for a graph of the total times including both the offline and online phases (OT stands for the protocol in Section 31) Recall that the mul- tiplication optimization for BGW in Section 34 only works for up to 15 parties; thus the curve steepens for 33 parties Before proceeding, we stress that the scale factor is exactly as expected from the theoretical analysis|,Non-data,76
| However, the big surprise is that in this setting GMW actually outperforms all of the BMR versions of the protocol when the number of parties is 7 or more, even though the circuit has depth 5884000 In [31], they showed that in the two-party setting, GMW can outperform Yao for low-depth circuits and low- latency networks Our conclusion here is far more dramatic; in low-latency networks GMW can outperform BMR even for very deep circuits We stress that BMR protocols have between 3 and 5 rounds whereas GMW has 8000 rounds (2- rounds per level of the circuit)|,Non-data,76
| The disparity between this and the two-party setting is due to the significant additional communication and computational overhead in BMR versus Yao (observe that for only a few parties, the running times are comparable) with 91,000 AND gates for 33 parties requires 332× 91000 ≈ 10,000,000 invocations of AES This therefore becomes a dominating factor In the two-party setting, the protocol cost has been reduced so significantly that communication is the bottleneck|,Non-data,76
| In the multiparty setting, this is currently not the case (We stress that state-of-the-art pipelining us- ing AES-NI with a fixed-key was used, as in the fastest Yao garbled circuit implementations) Amazon Virginia – 1ms ping time The above relates to a very low latency network with a single message latency of approximately 0|,Non-data,76
|05ms In the Virginia-Virginia setting of Amazon, a similar phenomenon happens in terms of the scaling curves However, they are less pronounced because (a) the latency of the network plays more of a role, and (b) the CPUs on the Amazon machines are stronger, reducing the cost of computation See Figure 7|,Non-data,76
| For the online time in this setting, the GMW protocol already behaves much more poorly; see Figure 8, even though this is still a fast network (with a 1ms latency) Nevertheless, it is clear from the graph that BMR degrades quickly and so with a larger number of parties (say, 50), GMW will beat BMR even in the online time in Amazon Virginia Figure 5: Total time GMW vs BMR in CREATE Of course, the above considers the total running time However, the strength of our protocols over GMW is in the online time, since BMR requires sending only garbled values on the input wires and local computation|,Non-data,76
| In contrast, GMW still has 8000 rounds of communication in the online phase This means that GMW cannot go below 400ms in the online time To our great surprise, although BMR was significantly faster than GMW for a small number of parties, GMW was faster for 33 parties Indeed, although for 3 parties, GMW takes approximately 400ms, it grows to only 1113ms for 33 parties|,Non-data,76
| In contrast, BMR takes only 85ms for 3 parties but grows to 1506ms for 33 parties; see Figure 6 Figure 7: Total time GMW vs BMR in Amazon Virginia Figure 6: Online time GMW vs BMR in CREATE We explain this as being due to the quadratic complexity of the BMR circuit Specifically, evaluating a BMR circuit Figure 8: Online time GMW vs BMR in Amazon Virginia 589Acknowledgements We sincerely thank Meital Levy, Assi Barak, Shay Gueron, and Roi Inbar for their help on the implementations and experiments in this paper 5|,Non-data,76
|ABSTRACT In the last few years, there has been significant interest in de- veloping methods to search over encrypted data In the case of range queries, a simple solution is to encrypt the contents of the database using an order-preserving encryption (OPE) scheme (ie, an encryption scheme that supports compar- isons over encrypted values)|,Non-data,77
| However, Naveed et al (CCS 2015) recently showed that OPE-encrypted databases are extremely vulnerable to “inference attacks” In this work, we consider a related primitive called order- revealing encryption (ORE), which is a generalization of OPE that allows for stronger security We begin by con- structing a new ORE scheme for small message spaces which achieves the “best-possible” notion of security for ORE|,Non-data,77
| Next, we introduce a “domain-extension” technique and apply it to our small-message-space ORE While our domain-extension technique does incur a loss in security, the resulting ORE scheme we obtain is more secure than all existing (state- less and non-interactive) OPE and ORE schemes which are practical All of our constructions rely only on symmetric primitives As part of our analysis, we also give a tight lower bound for OPE and show that no efficient OPE scheme can satisfy best-possible security if the message space contains just three messages|,Non-data,77
| Thus, achieving strong notions of secu- rity for even small message spaces requires moving beyond OPE Finally, we examine the properties of our new ORE scheme and show how to use it to construct an efficient range query protocol that is robust against the inference attacks of Naveed et al We also give a full implementation of our new ORE scheme, and show that not only is our scheme more secure than existing OPE schemes, it is also faster: encrypting a 32-bit integer requires just 55 microseconds, which is more than 65 times faster than existing OPE schemes ∗The full version of this paper [43] with complete proofs is available at http://eprint|,Non-data,77
iacrorg/2016/612 Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page Copyrights for components of this work owned by others than ACM must be honored,Non-data,77
| Abstracting with credit is permitted To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acmorg|,Non-data,77
| CCS’16, October 24-28, 2016, Vienna, Austria c(cid:13) 2016 ACM ISBN 978-1-4503-4139-4/16/10  |,Non-data,77
 $1500 DOI: http://dxdoiorg/10,Non-data,77
|1145/29767492978376 1 INTRODUCTION Today, large corporations and governments collect and store more personal information about us than ever before And as high-profile data breaches on companies and organi- zations (such as Anthem [1], eBay [39], and the U|,Non-data,77
|S Voter Database [26]) become startlingly common, it is imperative that we develop practical means for securing our personal data in the cloud One way to mitigate the damage caused by a database breach is to encrypt the data before storing it in the cloud This, however, comes at the price of functionality: once data is encrypted, it is more difficult to execute searches over the data without first decrypting the data|,Non-data,77
| As a result, security researchers have turned to developing methods that both protect the contents of the database, as well as support efficient operations, such as search, over the encrypted data Property-preserving encryption One way to support searching over an encrypted database is through property- preserving encryption (PPE) [9, 48, 21] A PPE scheme is an encryption scheme where the ciphertexts reveal a par- ticular property on their underlying plaintexts|,Non-data,77
| Examples include deterministic encryption, where the ciphertexts re- veal equality between messages, and order-preserving en- cryption (OPE) [2, 9], where the ciphertexts reveal the or- dering of messages Deterministic and order-preserving en- cryption schemes have been used in CryptDB [51], and also commercially by SkyHigh Networks, CipherCloud, Google Encrypted BigQuery, and others One of the main appeals of PPE for encrypting relational databases is that they are lightweight, and hence, can be deployed with minimal changes to existing databases For instance, in an OPE scheme, the ciphertexts themselves are numeric and the order of the ci- phertexts precisely coincides with the order of the plaintexts|,Non-data,77
| Thus, searching over a column encrypted using OPE is iden- tical to searching over an unencrypted column Limitations of PPE and OPE While PPE, and in partic- ular, OPE, provides a practical solution for searching on en- crypted data, these schemes also leak significant amounts of information about their underlying plaintexts For instance, Boldyreva et al|,Non-data,77
| [10] showed that a single OPE ciphertext leaks half of the most significant bits of its underlying plain- text! More recently, Naveed et al [46] described a series of in- ference attacks on relational databases encrypted using de- terministic and order-preserving encryption schemes They show that, given just a data dump of an encrypted database along with auxiliary information from a public database, an 1167attacker can successfully recover nearly all of the underlying plaintext values from their respective ciphertexts Our goals|,Non-data,77
| Motivated by the limited security of existing OPE schemes and the emerging threat of inference attacks on databases encrypted using PPE, our goal in this work is to construct a practical property-preserving encryption for comparisons that achieves stronger security guarantees compared to existing OPE schemes while at the same time providing robustness against offline inference attacks, such as those considered by Naveed et al Order-revealing encryption To address the limitations of OPE, we rely on a closely-related, but more flexible, no- tion called order-revealing encryption (ORE) [12, 22] In this work, we focus exclusively on non-interactive and state- less schemes—these are the only schemes we know of that are deployed on a large scale|,Non-data,77
| We survey the work on alter- native solutions in Section 8 In an OPE scheme, both the plaintext and ciphertext spaces must be numeric and well-ordered Moreover, the ciphertexts themselves preserve the order of the underlying plaintexts While this property makes OPE suitable for per- forming range queries on encrypted data, it also limits the achievable security of OPE schemes|,Non-data,77
| In their original work, Boldyreva et al [9] introduced the notion of “best-possible” semantic security for OPE, which states that the cipher- texts do not leak any information beyond the ordering of the plaintexts Unfortunately, in the same work and a follow- up work [10], they show that any OPE scheme with best- possible security must have ciphertexts whose length grows exponentially in the length of the plaintexts Popa et al|,Non-data,77
| [50] further extended this lower bound to apply to stateful, in- teractive OPE schemes These lower bounds rule out any hope of constructing efficient OPE schemes for large message spaces As a compromise, Boldyreva et al [9] introduced a weaker notion of security (POPF-CCA) for OPE schemes, but it is difficult to quantify the leakage of schemes which are POPF-CCA secure|,Non-data,77
| Recently, Boneh et al [12] introduced the notion of ORE, which does not place any restrictions on the structure of the ciphertext space An ORE scheme simply requires that there exists a publicly computable function that compares two ciphertexts By relaxing the constraint on the ciphertext space, the Boneh et al|,Non-data,77
| scheme is the first (non-interactive and stateless) scheme to achieve best-possible semantic se- curity However, their construction relies on multilinear maps [14, 27, 23], and is extremely far from being practi- cally viable More recently, Chenette et al [22] introduced a new security model for ORE that explicitly models the information leakage of an ORE scheme|,Non-data,77
| They also give the first efficiently-implementable ORE scheme However their scheme also reveals the index of the first bit that differs be- tween two encrypted values 11 The Left/Right Framework for ORE Before describing our main contributions, we first high- light the “left/right” framework for order-revealing encryp- tion that we use in this work|,Non-data,77
| Our notions are adapted from similar definitions for multi-input functional encryption [33, 12], where the encryption function operates on different “in- put slots” In a multi-input functional encryption scheme (of which ORE is a special case), information about plaintexts is only revealed when one has a ciphertext for every slot We now describe how this notion of encrypting to differ- ent input slots applies to order-revealing encryption In a vanilla ORE scheme, there is a single encryption algorithm that takes a message and outputs a ciphertext|,Non-data,77
| The compar- ison algorithm then takes two ciphertexts and outputs the comparison relation on the two underlying messages In the left/right framework, we modify this interface and decom- pose the encryption function into two separate functions: a “left” encryption function and a “right” encryption function Each of these encryption functions takes a message and the secret key, and outputs either a “left” or a “right” cipher- text, respectively Next, instead of taking two ciphertexts, the comparison function takes a left ciphertext and a right ciphertext, and outputs the comparison relation between the two underlying messages (encrypted by the left and right ci- phertexts)|,Non-data,77
| We note that any ORE scheme in the left/right framework can be converted to an ORE scheme in the usual sense by simply having the ORE encryption function output both the left and right ciphertexts for a given message This left/right notion is a strict generalization of the usual notion of order-revealing encryption, and thus, can be used to strengthen the security guarantees provided by an ORE scheme In particular, a key advantage of working in this framework is that we can now define additional security re- quirements on collections of left or right ciphertexts taken in isolation For example, in both of the ORE constructions we introduce in this work (Sections 3 and 4), a collection of right ciphertexts taken individually is semantically secure—that is, no information about the underlying plaintexts (includ- ing their order relations) is revealed given only a collection of right ciphertexts|,Non-data,77
| In Section 5, we describe precisely how semantic security of the right ciphertexts can be leveraged to obtain a range query protocol that is robust against offline inference attacks We also note that the schemes presented in this work are the first practical ORE constructions in the left/right framework where one side (the right ciphertexts) achieves semantic security Finally, we note that the left/right framework extends nat- urally to property-preserving encryption schemes, and thus, opens up many new avenues of developing more secure cryp- tographic primitives for searching on encrypted data 1|,Non-data,77
|2 Our Contributions In this work, we describe a new ORE scheme that achieves stronger security compared to existing practical OPE and ORE schemes, as well as a method to leverage our new ORE scheme to efficiently perform range queries while providing robustness against inference attacks We now highlight our main contributions An efficient small-domain ORE We begin by giving the first construction of a practical, small-domain ORE scheme with best-possible semantic security that only relies on pseu- dorandom functions (PRFs)|,Non-data,77
|1 The restriction to “small” do- mains is due to the fact that the ciphertext length in our scheme grows linearly in the size of the plaintext space All existing constructions of ORE that achieve best-possible security in the small-domain setting rely on pairings [42], general-purpose functional encryption [3, 16], or multilinear maps [12], and thus, are not yet practical Our particular 1We prove security in the random oracle model, but it is possible to replace the random oracle with a PRF to show security under a slightly weaker indistinguishability-based notion of security 1168construction is inspired by the “brute-force” construction of functional encryption by Boneh et al|,Non-data,77
| [13, §41] They show that functional encryption with respect to a “small” (ie|,Non-data,77
|, polynomially-sized) class of functions can be constructed us- ing only symmetric primitives We adapt these methods to show how best-possible ORE (and more generally, functional encryption) can be efficiently constructed from symmetric primitives when the message space is small Our construc- tion is described in Section 3 Domain extension for ORE|,Non-data,77
| Of course, a small-domain ORE by itself is not very useful for range queries Our sec- ond contribution is a recasting of the Chenette et al [22] ORE construction as a general technique of constructing a large-domain ORE from a small-domain ORE The trans- formation is not perfect and incurs some leakage|,Non-data,77
| Applying this domain-extension technique to our new small-domain ORE, we obtain an ORE scheme whose leakage profile is significantly better than that of the Chenette et al con- struction In particular, our new ORE scheme operates on blocks (where a block is a sequence of bits) and the addi- tional leakage in our scheme is the position of the first block in which two messages differ For instance, if blocks are byte- sized (8 bits), then our ORE scheme only reveals the index of the first byte that differs between the two messages (and nothing more)|,Non-data,77
| In contrast, the Chenette et al construction always reveals the index of the first bit that differs2 Thus, our new ORE construction provides significantly stronger security, at the cost of somewhat longer ciphertexts Encrypted range queries|,Non-data,77
| While our new ORE scheme can almost3 be used as a drop-in replacement for OPE to enable searching over an encrypted database, the scheme remains susceptible to an offline inference attack To carry out their inference attacks, Naveed et al [46] rely on the fact that OPE-encrypted ciphertexts enable equality tests and comparisons (by design) In our setting, we take advantage of the special structure of the ciphertexts in our ORE scheme to obtain a way of supporting range queries on encrypted data while protecting against offline inference attacks|,Non-data,77
| Our range query protocol critically relies on the fact that our ORE scheme is a left/right ORE scheme (Section 11) More precisely, a ciphertext ct in our ORE scheme natu- rally decomposes into a left component ctL and a right com- ponent ctR To compare two ciphertexts, the comparison function only requires the left component of one cipher- text and the right component of the other|,Non-data,77
| More impor- tantly, the right components have the property that they are semantically-secure encryptions of their messages To build an encrypted database system with robustness against range queries, the database server only stores the “right” ciphertexts (in sorted order) To perform a range query, the client provides the “left” ciphertexts corresponding to its range The server can respond to the range query as usual since comparisons are possible between left and right ciphertexts|,Non-data,77
| Robustness against offline inference attacks is ensured since the database dump only contains the right ci- phertexts stored on the server, which are semantically-secure 2While Chenette et al also describe a multi-bit generalization of their scheme, the generalized version leaks more information, namely the difference of the values in the first differing block In our construction, only the index and nothing else is revealed 3We say “almost,” since using ORE in place of OPE would require writing a custom comparator for database elements|,Non-data,77
 encryptions of their underlying messages We describe our method in greater detail in Section 5 New lower bounds for OPE The core building block in our new ORE construction is a small-domain ORE with best-possible security,Non-data,77
| This raises the natural question of whether we could construct a small-domain OPE that also achieves best-possible security Previously, Boldyreva et al [9, 10] and Popa et al [50] gave lower bounds that ruled out schemes where the ciphertext space is subexponential in the size of the plaintext space|,Non-data,77
| But when the plaintext has size poly(λ) for a security parameter λ, there could conceivably exist an efficient OPE scheme with best-possible security In this work, we show that this is in fact impossible Us- ing a very different set of techniques compared to [9, 10, 50], we show (Section 6) that no efficient (stateless and non-interactive) OPE scheme can satisfy best-possible secu- rity, even when the message space contains only 3 elements! Thus, to achieve strong security even in the small-domain setting, it is necessary to consider relaxations of OPE, such as ORE Experimental evaluation|,Non-data,77
| Finally, we implement and compare our new ORE scheme to the ORE scheme by Ch- enette et al [22] and the OPE scheme by Boldyreva et al [9] For typical parameters, our new ORE scheme is over 65 times faster than the Boldyreva et al|,Non-data,77
| scheme, but has longer ciphertexts For example, when working with byte- size blocks, encrypting a 32-bit integer requires just 55 μs and produces a ciphertext that is 224 bytes Typically, range queries are not performed over extremely long fields, so the extra space overhead of our scheme is not unreasonable Given the superior security conferred by our scheme (in both the online and offline settings), and faster throughputs, our ORE scheme is a very compelling replacement for existing OPE schemes|,Non-data,77
| Applying ORE To conclude, we make a cautionary note that because of the leakage associated with any ORE scheme, the primitive is not always suitable for applications that de- mand a high level of security Our hope, however, is that by giving precise, concrete characterization of the leakage profile of our construction (in both the online and offline settings when used to support encrypted database queries), practitioners are able to make better-informed decisions on the suitability of our construction for a specific application 2|,Non-data,77
| PRELIMINARIES For n ∈ N, we write [n] to denote the set of integers {1,    , n}|,Non-data,77
| If P is a predicate on x, we write 1(P(x)) to denote the indicator function for P: that is, 1(P(x)) = 1 if and only if P(x) = 1, and 0 otherwise For a distribution D, we write x ← D to denote a draw from D For a finite set r←− S to denote a uniformly random draw from S, we write x S In this work, we write λ to denote a security parameter|,Non-data,77
| We say a function f (λ) is negligible in λ if f = o(1/λc) for all c ∈ N We write negl(λ) to denote a negligible function in λ and poly(λ) to denote a polynomial in λ We say that an event occurs with negligible probability if the probability of the event occurring is negl(λ) For two bit strings x, y, we write x(cid:107)y to denote the concatenation of x and y|,Non-data,77
| We also review the standard definition of pseudorandom functions (PRFs) [31] A function F : K×X → Y is a secure PRF if no efficient adversary can distinguish (except perhaps 1169with negligible probability) the outputs (on arbitrary points chosen adaptively by the adversary) of F (k,·) for a randomly r←− K from that of a truly random function f (·) chosen k from X to Y Similarly, a function F : K × X → X is a secure pseudorandom permutation (PRP) if for all k ∈ K, F (k,·) is a permutation on X and no efficient adversary can distinguish the outputs of F (k,·) where k r←− K from the outputs of π(·) where π is a random permutation on X  2|,Non-data,77
|1 Order-Revealing Encryption An order-revealing encryption (ORE) scheme [12, 22] is a tuple of three algorithms Π = (ORESetup, OREEncrypt, ORECompare) defined over a well-ordered domain D with the following properties: • ORE|,Non-data,77
|Setup(1λ) → sk: On input a security parameter λ, the setup algorithm outputs a secret key sk • OREEncrypt(sk, m) → ct: On input a secret key sk and a message m ∈ D, the encryption algorithm outputs a ciphertext ct • ORE|,Non-data,77
|Compare(ct1, ct2) → b: On input two ciphertexts ct1, ct2, the compare algorithm outputs a bit b ∈ {0, 1} Correctness We say an ORE scheme over a well-ordered domain D is correct if for sk ← ORESetup(1λ) and all mes- sages m1, m2 ∈ D, Pr[ORE|,Non-data,77
|Compare(ct1, ct2) = 1(m1 < m2)] = 1 − negl(λ) (ORE Decryption) Our above schema Remark 21 for ORE does not include a decryption function, but as noted by Chenette et al|,Non-data,77
| [22, Remark 23], this is without loss of generality In particular, we can construct a decryption algo- rithm OREDecrypt using the ORE|,Non-data,77
Encrypt and ORECompare algorithms (by performing a binary search) Security The “best-possible” notion of security for order- revealing encryption is the notion of indistinguishability un- der an ordered chosen plaintext attack (IND-OCPA) intro- duced by Boldyreva et al,Non-data,77
| [9] The IND-OCPA notion of se- curity is a generalization of semantic security [34], and states that no efficient adversary can distinguish between the en- cryptions of any two sequences of messages, provided that the ordering of the messages in the two sequences is identi- cal We give the formal definition in the full version [43] Due to the apparent difficulty in constructing efficient schemes that satisfy IND-OCPA security, Chenette et al|,Non-data,77
 [22] introduced a weaker simulation-based notion of security for ORE schemes that allows for some leakage beyond just the ordering of the plaintexts We recall their definition here Definition 22 (ORE with Leakage [22]),Non-data,77
| Let Π be an ORE scheme—that is, Π = (ORESetup, OREEncrypt, ORECompare), and let A = (A1, |,Non-data,77
|   ,Aq) be an adversary for some q = poly(λ) Let S = (S0,S1, |,Non-data,77
|   ,Sq) be a sim- ulator, and let L(·) be a leakage function We define the experiments REALoreA (λ) and SIMoreA,S,L(λ) in Figure 1|,Non-data,77
| We say that Π is a secure ORE scheme with leakage function L(·) if for all polynomial-size adversaries A = (A1,    ,Aq), there exists a polynomial-size simulator S = (S0,S1, |,Non-data,77
|   ,Sq) such that the outputs of the two distributions REALoreA (λ) and SIMoreA,S,L(λ) are computationally indistinguishable Remark 2|,Non-data,77
|3 (Best-Possible Security) The strongest notion of simulation-security is security with respect to the leakage function that only reveals the ordering of the plain- texts This is the minimal leakage possible from an order- revealing encryption scheme In particular, we define Lcmp as follows: Lcmp(m1, |,Non-data,77
|   , mt) = {(i, j, cmp(mi, mj) || 1 ≤ i < j ≤ t)} , where cmp(mi, mj) is the comparison function that outputs −1 if mi < mj, 0 if mi = mj and 1 if mi > mj 3|,Non-data,77
| ORE FOR SMALL DOMAINS The order-revealing encryption in [22] reveals a significant amount of information, namely, the index of the first bit position that differs between two encrypted plaintexts In this work, we show how to construct an ORE scheme that only leaks the first block that differs, where a block is a collection of one or more bits For instance, we can construct an ORE scheme that only reveals the first byte that differs between two encrypted plaintexts, and nothing more The starting point for our construction is a “small-domain” ORE scheme with best-possible simulation security|,Non-data,77
| The limitation is that the length of the ciphertexts in our ORE scheme grows linearly with the size of the message space, hence the restriction to small (polynomially-sized) domains We show in Section 4 how to extend our small-domain ORE to obtain an order-revealing encryption scheme over large domains (ie, exponentially-sized) that leaks strictly less in- formation compared to the scheme by Chenette et al|,Non-data,77
| [22] As described in Section 11, we give our ORE construc- tion in the left/right framework where we decompose the OREEncrypt function into two functions: ORE|,Non-data,77
|EncryptL and OREEncryptR We refer to them as the “left encryption” and “right encryption” functions, respectively Our particular construction has the property that only “left ciphertexts” can be compared with “right ciphertexts|,Non-data,77
|” Note that this is with- out loss of generality and we can recover the usual notion of ORE by simply defining the output of OREEncrypt(sk, m) to be the tuple (OREEncryptL(sk, m), OREEncryptR(sk, m))|,Non-data,77
| 31 Small-Domain ORE Construction We begin with a high-level overview of our construction Our scheme is defined with respect to a plaintext space [N ] where N = poly(λ) First, we associate each element x ∈ [N ] in the domain with an encryption key kx|,Non-data,77
| A (right) ciphertext for a value y ∈ [N ] consists of N encryptions of the comparison output cmp(x, y) between y and every el- ement x ∈ [N ] in the domain, where the value cmp(x, y) is encrypted under kx The left encryption of a value x is simply the encryption key kx Given kx and an encryp- tion of cmp(x, y) under kx, the evaluator can decrypt and learn the comparison bit cmp(x, y) The values of the other comparison bits are hidden by semantic security of the en- cryption scheme|,Non-data,77
| Note, however, that we still need a way for the evaluator to determine which of the N ciphertexts is encrypted under kx without learning the value of x To en- sure this, we sample a random permutation π on the domain [N ] during setup The components in the right ciphertexts are then permuted according to π and the left encryption of x includes the permuted position π(x) Given π(x), the evaluator learns which component in the right ciphertext to decrypt, but learns nothing about x|,Non-data,77
| Finally, to show sim- 1170REALoreA (λ): 1 sk ← ORESetup(1λ) 2 (m1, stA) ← A1(1λ) 3|,Non-data,77
| c1 ← OREEncrypt(sk, m1) 4 for 2 ≤ i ≤ q: (a) (mi, stA) ← Ai(stA, c1,  |,Non-data,77
|  , ci−1) (b) ci ← OREEncrypt(sk, mi) SIMoreA,S,L(λ): 1 stS ← S0(1λ) 2|,Non-data,77
| (m1, stA) ← A1(1λ) 3 (c1, stS ) ← S1(stS ,L(m1)) 4 for 2 ≤ i ≤ q: (a) (mi, stA) ← Ai(stA, c1,  |,Non-data,77
|  , ci−1) (b) (ci, stS ) ← Si(stS ,L(m1,   |,Non-data,77
| , mi)) 5 output (c1,   |,Non-data,77
| , cq) and stA 5 output (c1,   |,Non-data,77
| , cq) and stA Figure 1: Real and ideal experiments for ORE with leakage (Definition 22) ulation security, we require a “non-committing” encryption scheme, and for this, we rely on a random oracle [6]4 Construction|,Non-data,77
| Let [N ] be the message space Let F : {0, 1}λ×{0, 1}λ → {0, 1}λ be a secure PRF and H : {0, 1}λ× {0, 1}λ → Z3 be a hash function (modeled as a random ora- cle in the security proof) Let cmp be the comparison func- tion from Remark 23|,Non-data,77
| Our ORE scheme Π(s) ore is defined as follows: • ORESetup(1λ) The setup algorithm samples a PRF key r←− {0, 1}λ for F , and a uniformly random permutation • OREEncryptL(sk, x)|,Non-data,77
| Write sk as (k, π) The left en- cryption algorithm computes and returns the tuple ctL = (F (k, π(x)), π(x)) • OREEncryptR(sk, y)|,Non-data,77
| Write sk as (k, π) First, the right r←− {0, 1}λ k π : [N ] → [N ] The secret key sk is the pair (k, π)|,Non-data,77
| encryption algorithm samples a random nonce r Then, for each i ∈ [N ], it computes the value vi = cmp(π −1(i), y) + H(F (k, i), r) (mod 3) Finally, it outputs the ciphertext ctR = (r, v1, v2   |,Non-data,77
| , vN ) • ORECompare(ctL, ctR) The compare algorithm first parses (cid:48) ctL = (k , h) and ctR = (r, v1, v2, |,Non-data,77
|   , vN ), and then outputs the result vh − H(k(cid:48), r) (mod 3) (cid:48) , ct(y) Correctness|,Non-data,77
| Let sk = (k, π) ← ORESetup(1λ), and take any x, y ∈ [N ] Let ct(x) L = (k(cid:48), h) ← OREEncryptL(sk, x) R = (r, v1, |,Non-data,77
|   , vN ) ← OREEncryptR(sk, y), Then, and and ct(y) setting z = ORE|,Non-data,77
|Compare(ct(x) z = vh − H(k = cmp(π = cmp(π = cmp(x, y) ∈ Z3, Note that cmp(x, y) provides the same amount of informa- tion as 1(x < y) and 1(y < x), so correctness follows −1(h), y) + H(F (k, h), r) − H(k −1(π(x)), y) + H(F (k, π(x)), r) − H(F (k, π(x)), r) R ), we have , r) , r) (cid:48) L Space usage Before we give our formal security analy- sis, we first characterize the length of the ciphertexts in our ORE scheme for a message space of size N  The left cipher- texts ctL in our scheme consists of a PRF key and an index, which are λ + (cid:100)log N(cid:101) bits long|,Non-data,77
| The right ciphertexts ctR consists of a nonce, together with N elements in Z3, which 4We believe we can replace the random oracle with a PRF if we aim to prove an indistinguishability notion of security for our construction For simplicity of presentation in this paper, we work with a simulation-based definition and prove security in the random oracle model can be represented using λ + (cid:100)N log2 3(cid:101) bits Thus, a com- plete ciphertext consists of 2λ + (cid:100)log N(cid:101) + (cid:100)N log2 3(cid:101) bits|,Non-data,77
| However, as we note in the following remark, it is possible to obtain shorter ciphertexts if we allow the comparison algo- rithm to take the full ciphertext (ctL, ctR) as opposed to only the left half of the first ciphertext and the right half of the second ciphertext Thus, when using the construction as a pure ORE scheme, we can obtain shorter ciphertexts When leveraging our ORE scheme to build a range query system (Section 5), we will exploit the fact that comparisons can be performed given just the left component of one ciphertext and the right component of the other L Remark 3|,Non-data,77
|1 (Shorter Ciphertexts) For a domain of size N , the right ciphertexts in our ORE construction contain N elements of Z3 Suppose instead we replaced the comparison function cmp with a function cmp(cid:48) where cmp(cid:48)(x, y) = 1 if x ≤ y and 0 otherwise Then, a left encryp- tion ct(x) of y can be used to compute cmp(cid:48)(x, y), or equivalently, whether x ≤ y|,Non-data,77
| If , ct(x) the comparison algorithm takes as input ct(x) =(cid:0)ct(x) and ct(y) =(cid:0)ct(y) (cid:1) (cid:1), then it can compute both cmp(cid:48)(x, y) of x and a right encryption ct(y) and cmp(cid:48)(y, x) This means that given ct(x) and ct(y), the comparison algorithm can still determine if x < y, x = y, or x > y With this modification, the right ciphertexts in our scheme have length N rather than (cid:100)N log2 3(cid:101) L , ct(y) R R R L In the full version [43], we also show how our construction above can be extended to support more general function- alities (beyond just comparisons) over polynomial-sized do- mains|,Non-data,77
| We now state our main security theorem, but defer the formal proof to the full version Theorem 32 The ORE scheme Π(s) ore is secure with the best-possible leakage function Lcmp from Remark 2|,Non-data,77
|3 assum- ing that F is a secure PRF and H is modeled as a random oracle 4 DOMAIN EXTENSION FOR ORE Although our small-domain ORE construction from Sec- tion 3 achieves the strongest possible notion of security for ORE, it is limited to polynomially-sized message spaces In this section, we show how to construct an efficient ORE scheme for large domains which achieves provably stronger security guarantees than all existing efficient ORE construc- tions for large domains|,Non-data,77
| Our construction can be viewed as a composition of our small-domain ORE construction together with the ORE scheme by Chenette et al [22] Intuitively, we can view the techniques used in the Ch- enette et al construction as a domain-extension mechanism 1171for ORE|,Non-data,77
| In particular, their construction can be viewed as a general transformation that takes as input a k-bit ORE scheme and outputs an kn-bit ORE scheme, with ciphertext expansion that grows linearly in n and a slight reduction in security (that degrades with n) Under this lens, the Ch- enette et al construction can be viewed as taking a 1-bit ORE scheme (with best-possible security) and extending it to an n-bit ORE scheme In this work, we apply this general domain-extension technique to our small-domain ORE from Section 3, and show how we can start with a d-bit ORE and extend it to a dn-bit ORE|,Non-data,77
| By varying the parameters n and d, we obtain a performance-security tradeoff At a high level, our composed construction implements encryption via several parallel (prefix-dependent) instances of the small- domain ORE scheme Π(s) ore from Section 3, one for each block of the plaintext Using the techniques of Chenette et al [22], a blinding factor is derived from the prefix of each block and used to mask the Π(s) ore ciphertexts for that block|,Non-data,77
| We give the precise leakage of our construction in Theorem 41 Construction Fix a security parameter λ ∈ N, a message space size N > 0, and integers d, n > 0 such that dn ≥ N |,Non-data,77
| Let F : {0, 1}λ×[N ] → {0, 1}λ be a secure PRF on variable- length inputs,5 H : {0, 1}λ×{0, 1}λ → Z3 be a hash function (modeled as a random oracle), and π : {0, 1}λ × [d] → [d] be a secure PRP For a d-ary string x = x1x2 ··· xn, let x||i = x1x2 ··· xi denote the d-ary string representing the first i digits of x (ie, the length-i prefix of x), and let x||0 be the empty prefix|,Non-data,77
| We define our ORE scheme Πore = (ORESetup, OREEncryptL, OREEncryptR, ORE|,Non-data,77
|Compare) as follows • ORESetup(1λ) The setup algorithm samples PRF keys r←− {0, 1}λ|,Non-data,77
| The master secret key is sk = (k1, k2) • OREEncryptL(sk, x) Let sk = (k1, k2)|,Non-data,77
| For each i ∈ [n], the left encryption algorithm first computes the quantity ̃x = π(F (k2, x||i−1), xi) and then sets ui = (F (k1, x||i−1(cid:107) ̃x), ̃x) It returns the ciphertext ctL = (u1,   |,Non-data,77
| , un) • OREEncryptR(sk, y) Let sk = (k1, k2)|,Non-data,77
| First, the right en- r←− {0, 1}λ cryption algorithm uniformly samples a nonce r Then, for each i ∈ [n] and j ∈ [d], it first sets j∗ = π−1(F (k2, y||i−1), j), it computes k1, k2 zi,j = cmp(j ∗ , yi) + H(F (k1, y||i−1(cid:107)j), r) (mod 3) It then defines the tuple vi = (zi,1,  |,Non-data,77
|  , zi,d) and outputs the ciphertext ctR = (r, v1, v2   |,Non-data,77
| , vn) • ORECompare(ctL, ctR) The compare algorithm first parses ctL = (u1, |,Non-data,77
|   , un) and ctR = (r, v1, v2,  |,Non-data,77
|  , vn), where for each i ∈ [n], we write ui = (k(cid:48) i, hi) and vi = (zi,1,   |,Non-data,77
| , zi,d) Then, let (cid:96) be the smallest index i for which zi,hi − H(k(cid:48) i, r) (cid:54)= 0 (mod 3) If no such (cid:96) exists, output 0 Otherwise, output z(cid:96),h(cid:96) − H(k(cid:48) (cid:96), r) (mod 3)|,Non-data,77
 Correctness Correctness follows similarly to that for the small-domain ORE in Section 3 We give the full argument in the full version [43] Security,Non-data,77
| Before stating our security theorem, we first spec- ify our leakage function L(d) blk Each ciphertext block in our 5The Chenette et al ORE construction also used a PRF on variable-length inputs We refer to their construction [22, §3] for one possible way of constructing a PRF on variable-length inputs from a standard PRF|,Non-data,77
| ORE scheme is essentially a ciphertext for the underlying small-domain ORE, and the comparison operation proceeds block-by-block Intuitively then, since our small-domain ORE scheme leaks nothing except the ordering (Theorem 32), the additional leakage of our new ORE scheme is the index of the first block that differs between two ciphertexts In particular, for messages x = x1x2 ··· xn and y = y1y2 ··· yn written in base d, we define the first differing block function diff (x, y) to be the first index i ∈ [n] such that xj = yj ind(d) for all j < i and xi (cid:54)= yi|,Non-data,77
| If x = y, we define ind(d) diff (x, y) to be n + 1 Then, our leakage function L(d) blk for our extended ORE scheme is given by L(d) blk(m1,   |,Non-data,77
| , mt) = {(i, j, blk(mi, mj)) || 1 ≤ i < j ≤ t} , where blk(mi, mj) = (cmp(mi, mj), ind(d) diff (mi, mj)) In gen- eral, we refer to the parameter d as the arity (or base) of the plaintext space, which grows exponentially in the length (in bits) of the block We now state our main security theorem Theorem 4|,Non-data,77
1 The ORE scheme Πore is secure with leak- age function Lblk assuming that F is a secure PRF and H is modeled as a random oracle The proof of Theorem 41 can be viewed as a composition of the security proof for our underlying small-domain ORE (Theorem 3,Non-data,77
|2) and the security proof of the Chenette et al scheme [22, Theorem 32] We give the proof in the full version|,Non-data,77
| Space usage Ciphertexts in our new ORE scheme con- sist essentially of n ciphertexts for our small-domain ORE scheme (with domain size d) More concretely, a left cipher- text in our new scheme consists of n(λ + (cid:100)log d(cid:101)) bits and a right ciphertext consists of λ + n(cid:100)d log2 3(cid:101) bits Since the size of the plaintext space N satisfies N ≤ dn, ciphertext size in our new ORE scheme grow as O((λ + d) logd N )|,Non-data,77
| Non-uniform block sizes In practice, some bits of the plaintext may be more sensitive than others Leaking infor- mation about these bits is less desirable than leaking infor- mation about less sensitive bits To accommodate the differ- ent sensitivities, we can use different input bases (e|,Non-data,77
|g, use larger blocks for more sensitive bits) for the different blocks of the ciphertext The leakage in the resulting scheme is still the index of the first (variable-sized) block that differs between two messages Correctness is unchanged|,Non-data,77
| 5 ENCRYPTED RANGE QUERIES In this section, we formally define the properties of a client-server protocol for range queries over an encrypted database In our model, a client stores an encrypted database on the server The client can update the database (e|,Non-data,77
|g, by adding or removing records) and issue range queries against the database In a range query, the client specifies a numeric interval and the server responds by returning all ciphertexts whose underlying messages fall within that interval Although our definitions are stated in terms of numeric in- tervals, our methods are broadly applicable to more general settings—in particular, to any well-ordered domain such as English names|,Non-data,77
| For example, when the database consists of encrypted alphanumeric strings, range queries can be used for both exact-keyword as well as prefixed-based search Our security definitions are adapted from existing defi- nitions for searchable symmetric encryption (SSE) [24, 20] 1172We survey some of the work on SSE in Section 8 In our def- initions we consider both the online and offline settings|,Non-data,77
| In the online setting, the adversary sits on the server and sees both the encrypted database as well as the client’s queries, while in the offline setting, the adversary just obtains a dump of the server’s encrypted database By showing that in the offline setting, the server’s encrypted database pro- vides semantic security, we can argue that our new range query scheme provides robustness against the kinds of of- fline inference attacks considered by Naveed et al [46] After formally defining the security requirements for a range query protocol, we give a construction based on our ORE scheme Πore from Section 4|,Non-data,77
| Our protocol not only satisfies our security properties, but also has several addi- tional appealing properties such as sublinear query time (in the size of the database) and optimal round complexity Our proposed protocol is easily extensible to the multi- client setting where many clients are interacting with the server Each authorized client is simply given the secret key needed to query and update the database 5|,Non-data,77
|1 Range Query Schemes We begin with a formal definition of a range query scheme, followed by our notions of online and offline security We describe a range query scheme in terms of a set of algo- rithms, where each algorithm is a single-round protocol be- tween the client and the server In each protocol, the client is always stateless, but the server is stateful—in particular, the server’s state represents the information stored on the server needed to efficiently respond to the client’s queries, including the encrypted database itself Initially, the client runs a setup procedure that takes as input a plaintext database D of values and outputs a se- cret key sk and some token t representing the encrypted database|,Non-data,77
| The token t is given to the server, and the server outputs some initial state st Then, for each query (range query, insert query, delete query), the client uses the secret key sk to derive a token t representing its query, and sends t to the server This token contains a masked version of the client’s input for the query On input a query token t, the server processes the query and updates its internal state|,Non-data,77
| In a range query, the server also returns a response r, which the client uses to learn the answer to the range query More formally, let D ∈ [N ]M represent a (possibly empty) database consisting of M ≥ 0 values, each in the range [N ] A range query scheme Πrq = (RQSetup, RQ|,Non-data,77
|Range, RQInsert, RQDelete) consists of a tuple of algorithms defined as fol- lows: • RQSetup(1λ, D) → (t, st)|,Non-data,77
| The setup algorithm between the client and server proceeds as follows: – Client(1λ, D) → (sk, t) The client, on input the secu- rity parameter λ and database D, produces a key sk which is kept secret, and a token t which is sent to the server – Server(t) → st The server takes as input the token t and outputs an initial state st|,Non-data,77
| • RQRange(sk, q, st) → (t, st(cid:48)) The range query algorithm between the client and server proceeds as follows: – Client(sk, q = (x, y)) → t The client, on input the secret key sk and a query q for the range [x, y], produces a token t which is sent to the server|,Non-data,77
| – Server(st, t) → (st(cid:48), r) The server takes as input its cur- rent state st and the token t and produces an updated state st(cid:48), along with a response r, which is sent to the client – Client(sk, r) → S The client, on input the secret key sk and the response r from the server, obtains a subset S of entries which represent the answer to the range query|,Non-data,77
| • RQInsert(sk, q, st) → (t, st(cid:48)) The insert algorithm be- tween the client and server proceeds as follows: – Client(sk, q = x) → t The client, on input the secret key sk and a query q representing an insertion of the value x, produces a token t which is sent to the server|,Non-data,77
| – Server(st, t) → (st(cid:48), r) The server takes as input its cur- rent state st and the token t and produces an updated state st(cid:48) • RQDelete(sk, q, st) → (t, st(cid:48))|,Non-data,77
| The delete algorithm be- tween the client and server proceeds as follows: – Client(sk, q = x) → t The client, on input the secret key sk and a query q representing a deletion of the value x, produces a token t which is sent to the server – Server(st, t) → (st(cid:48), r) The server takes as input its cur- rent state st and the token t and produces an updated state st(cid:48)|,Non-data,77
| We now define the correctness and security properties of a range query scheme At a high level, we say that a range query scheme is correct if for all range queries (x, y) the client makes, it obtains the set of entries in the database D (taking into account any insertion and deletion queries occurring before the range query) that lie in the interval [x, y] Correctness Fix a security parameter λ, positive inte- gers x, y, N, M where x ≤ y ∈ [N ], a database D ∈ [N ]M and a sequence of (cid:96) insertion, deletion, and range queries q1, |,Non-data,77
|   , q(cid:96)−1 Let q(cid:96) = (x, y) be a range query|,Non-data,77
| Let (st(cid:96), r) ← Server(st(cid:96)−1, Client(sk, q(cid:96))) and S ← Client(sk, r), where st(cid:96)−1 is the server’s state after processing queries q1,    , q(cid:96)−1|,Non-data,77
| Let D0 = D, D1,    , D(cid:96) be the effective database elements af- ter each query—that is, for all i ∈ [(cid:96)], Di = Di−1 if qi is a range query, Di = Di−1 ∪ {x} if qi−1 is an insertion query for x, and Di = Di−1 \ {x} if qi−1 is a deletion query for x|,Non-data,77
| We say a range query scheme Πrq = (RQSetup, RQRange, RQInsert, RQ|,Non-data,77
|Delete) is correct if for all security parameters λ, integers N, M, x, y, databases D ∈ [N ]M and sequence of queries q1,    , q(cid:96), we have that the client’s re- sponse S satisfies S = D(cid:96) ∩ [x, y]|,Non-data,77
| Security Our first notion of security is online security, which models the information revealed to a malicious server in the range query protocol Here, the adversary sees both the contents of the server’s state (ie|,Non-data,77
|, the encrypted database) as well as the client’s queries We give a simulation-based definition with respect to a concrete leakage function that operates over the plaintext values in the database and the queries Our definition is adapted from the standard paradigm used to define security in searchable symmetric encryption schemes [24, 20] Definition 5|,Non-data,77
|1 (Online Security) For all databases D and sequences of (cid:96) queries q1,   |,Non-data,77
| , q(cid:96), define the sequence of states st0,    , st(cid:96) and tokens t0, |,Non-data,77
|   , t(cid:96) where (t0, st0) ← RQSetup(1λ, D), and for each i ∈ [(cid:96)], (ti, sti) is the output of the ith query on input sk, qi, and sti−1|,Non-data,77
| A range query scheme is online secure with respect to a leakage function L 1173if for every efficient adversary A, there exists a simulator S where (cid:12)(cid:12) Pr[A(1λ, st0,    ,st(cid:96), t0, |,Non-data,77
|   , t(cid:96)) = 1] − Pr[S(1λ,L(D, q1,  |,Non-data,77
|  , q(cid:96))) = 1](cid:12)(cid:12) = negl(λ) We also define an “offline” notion of security for a range query scheme The offline setting models scenarios where the adversary obtains a dump of the contents of the server (i|,Non-data,77
|e, the server’s state), but does not observe any queries made by the client Against offline adversaries, we require the much stronger property that the only thing leaked by the encrypted database is the size of the encrypted database This is the best-possible leakage|,Non-data,77
| Definition 52 (Offline Security) For all databases D and sequences of (cid:96) queries q1,  |,Non-data,77
|  , q(cid:96), define the sequence of states st0,   |,Non-data,77
| , st(cid:96) and tokens t0,    , t(cid:96) as in Definition 5|,Non-data,77
|1 Let ||st(cid:96)|| be the bit-length of st(cid:96) A range query scheme is of- fline secure if for all efficient adversaries A, there exists an efficient simulator S where (cid:12)(cid:12)(cid:12)Pr[A(1λ, st(cid:96)) = 1] − Pr[S(1λ,||st(cid:96)||) = 1] (cid:12)(cid:12)(cid:12) = negl(λ) The importance of offline security Although offline se- curity is strictly weaker than online security, it captures the real-world scenario where an attacker breaks into a server and exfiltrates any data the server has stored on disk|,Non-data,77
| While companies are often able to detect and protect against active online corruption of their servers, the question remains what happens after the fact when the attacker has also exfiltrated the database for offline analysis Of course, the ideal solu- tion to this problem is an encrypted database system that provides strong online security guarantees However, exist- ing systems with strong online security typically require re- designing the database management system and implement- ing elaborate cryptographic protocols for querying [17, 25], or leverage heavy, less practical tools such as fully homo- morphic encryption [29] or oblivious RAMs [32] On the flip side, an OPE-based solution yields a scheme that does not provide offline security in our model; this is one reason why OPE and other PPE-based encrypted database schemes are vulnerable to inference attacks|,Non-data,77
| This is true even if we use an (interactive) OPE scheme with best-possible security; the ability to directly compare ciphertexts is sufficient to carry out the inference attacks Thus, there is an interesting inter- mediate ground where we build systems that achieve decent online security, while still providing strong offline security guarantees to be robust against inference attacks 52 An Efficient Range Query Scheme We now describe how to build an efficient range query scheme using our ORE construction from Section 4|,Non-data,77
| At a high level, the server’s encrypted database consists of right ciphertexts for each value, stored in sorted order The to- kens t for each query consist of a left encryption of the query value This allows the server to use the ORE comparison algorithm to perform binary search over the encrypted ci- phertexts in the database Thus, the server is able to an- swer queries efficiently and maintain the database in sorted order (during updates)|,Non-data,77
