 6303. DATASETS Our Internet-wide study of key sharing in the HTTPS ecosystem is driven by four datasets: SSL certificates We use SSL certificates from full IPv4 scans as the basis of our measurements,Data,0
| Our SSL scans [30] also contain information on the IP address(es) that advertised each certificate. To obtain in- formation about the entity that controls this IP address, we use full IPv4 reverse DNS scans [29] that are also conducted by Rapid7|,Data,0
| Each AS is assigned an AS Number (ASN): for example, MIT is AS 3 and the Chicago Public Schools are AS 1416 [26]. CAIDA collects and publishes mappings between IP addresses and ASNs via their Route- Views datasets [7]|,Data,0
| For example, AT&T owns 160 unique ASNs. To aggregate these, we use CAIDA’s AS- to-Organization dataset [8] to group together ASes owned by the same organization|,Data,0
| For that, we rely on WHOIS [12], a protocol for querying domain registrars to obtain data on the domain owner. In practice, WHOIS data often contains fields such as the con- tact information for the owner of the domain, the contact for technical issues, where to send abuse complaints, and so on|,Data,0
| Here, we expand upon these prior findings by evaluating whether there is a correlation between centralized management and the quality of the keys chosen. Figure 13 compares several different features of self- managed and outsourced certificates across our entire cor- pus of leaf certificates (3,275,635 self-managed and 1,781,962 outsourced): (a) Key lengths in self-managed certificates are nearly identical to those managed by third-party hosting providers|,Data,0
|1 Combining Packet Capture (PCAP) Files The data set used in this study is a combination of the packet capture files obtained from two main sources. First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour|,Data,1
| First of all, the APTs were collected from Contagio malware database [15] contributed by Mila Parkour. The normal and non-malicious data is obtained from PREDICT internet data set repository [18] under the category of “DARPA Scalable Network Monitoring (SNM) Program Traffic”|,Data,1
| The data collection was performed during April 2016 using ZGrab, an application-layer scanner that operates with ZMap [15]. In the first phase, we performed an Internet-wide scan of all IPv4 addresses on port 500 to determine which hosts were configured 16This defect was corrected quite recently, years after the version of OpenSSL ScreenOS uses was written|,Data,6
|, download from an external source). Running on 71,000 articles collected from 45 leading technical blogs, this new approach demonstrates a remarkable performance: it gener- ated 900K OpenIOC items with a precision of 95% and a coverage over 90%, which is way beyond what the state-of-the-art NLP tech- nique and industry IOC tool can achieve, at a speed of thousands of articles per hour|,Data,7
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
| To structure our efforts, we followed a multi- step process. First, we collected exploits from various online databases and exploit frameworks, including Metasploit (22 exploits)3, Exploit-DB (2)4, Packet Storm (5)5, from the security research company Security Explorations (52)6, and an online repository for Java exploits7|,Data,11
 5. ANALYSIS AND FINDINGS In the following we use the extensive documentation of the 61 minimal exploits to provide insight into how attackers use specific vulnerabilities and features of the Java platform to implement their attacks,Data,11
| We run our event analysis on the top 100 free applications in the Android application store to determine how often this happens. In total, our analysis finds 1060 errors across 88 of the top 100 applications (10|,Data,12
| To our knowledge, AUTOREB is the first work that explores the user review information and utilizes the review semantics to predict the risky behaviors at both review-level and app-level. We crawled a real-world dataset of 2, 614, 186 users, 12, 783 apps and 13, 129, 783 reviews from Google play, and use it to comprehensively evaluate AUTOREB|,Data,14
| 4.1 Data collection For each team, we collected a variety of observed and self- reported data|,Data,16
| To demonstrate this, we scraped greatfire.org for websites in the top 1000 Alexa websites that are blocked by the GFW|,Data,18
| (cid:15) Identifying New Vulnerabilities. Our tool successfully an- alyzed 1,591 service interfaces of all the 80 system services in Android 5|,Data,19
| To understand the scope and magnitude of this new XARA threat, we developed an ana- lyzer for automatically inspecting Apple apps’ binaries to deter- mine their susceptibility to the XARA threat, that is, whether they perform security checks when using vulnerable resource-sharing mechanisms and IPC channels, a necessary step that has never been made clear by Apple. In our study, we ran the analyzer on 1,612 most popular MAC apps and 200 iOS apps, and found that more than 88|,Data,24
| To assist software developers (or secu- rity analysts) in tracking down a memory corruption vulnerability, CREDAL also performs analysis and highlights the code fragments corresponding to data corruption. To demonstrate the utility of CREDAL, we use it to analyze 80 crashes corresponding to 73 memory corruption vulnerabilities archived in Offensive Security Exploit Database|,Data,25
| These techniques may be applicable in other scenarios. We implemented and evaluated the attacks against the popular Gmail and Bing services, in several environments and ethical experiments, taking careful, IRB-approved mea- sures to avoid exposure of personal information|,Data,26
|, CSPAutoGen can handle all the inline and dynamic scripts. We have implemented a prototype of CSPAutoGen, and our eval- uation shows that CSPAutoGen can correctly render all the Alexa Top 50 websites|,Data,27
| 5. EXPERIMENTAL RESULTS This section reports on our evaluation of the moments ac- countant, and results on two popular image datasets: MNIST and CIFAR-10|,Data,28
| 6.1 Mobility Trace Dataset We use the CRAWDAD dataset roma/taxi [2, 3] for our simu- lations|,Data,31
 6.1 Evaluation We evaluated the performance of Σoφoς using 4 data sets of increasing size and also the English Wikipedia,Data,33
|1 Datasets, Metrics, Competitors & Settings Datasets. We test EpicRec on two real-world datasets: MovieLens1: a movie rating dataset collected by the Grou- pLens Research Project at the University of Minnesota through the website movielens|,Data,36
| 1 http://grouplens.org/datasets/movielens 188Yelp2: a business rating data provided by RecSys Chal- lenge 2013, in which Yelp reviews, businesses and users are collected at Phoenix, AZ metropolitan area|,Data,36
| The number of movie categories is 18. We use the MovieLens- 1M, with 1000,209 ratings from 6,040 users on 3,883 movies|,Data,36
| Our goal is to show that an ad- versary can insert an unbounded number of Sybil identities in the SybilLimit protocol, breaking its security guarantees. For our evaluation, we consider a real-world Facebook inter- action graph from the New Orleans regional network [28]|,Data,38
| We utilize these papers to extract Android malware behaviors and to construct the semantic network. From the electronic proceedings distributed to conference participants, we collect the papers from the IEEE Sympo- sium on Security and Privacy (S&P’08–S&P’15)4, the Com- puter Security Foundations Symposium (CSF’00–CSF’14), and USENIX Security (Sec’11)|,Data,39
 We conduct experiments on two publicly available set-valued datasets. • AOL search log dataset [1],Data,45
 90% of the users have fewer than 84 keywords in their logs. • Kosarak dataset [2],Data,45
 We select one month of data for our study. The data logs we used are col- lected from more than 30 machines with various server mod- els and operating systems,Data,46
| This paper rigorously investigates how users’ security beliefs, knowledge, and demographics corre- late with their sources of security advice, and how all these factors influence security behaviors. Using a carefully pre- tested, U|,Data,48
 We have ported Valgrind to iOS and implemented a prototype of iRiS on top of it. We evaluated iRiS with 2019 applications from the official App Store,Data,54
| from manufacturing equipment, as shown in Figure 1. We capture the relevant sensor data by deliberately or accidentally placing an attack-enabled phone close to, on top of, or inside a piece of manu- facturing equipment while the machinery is fabricating the target object|,Data,55
| Our new metric helps us compare in a fair way previously proposed attack-detection mechanisms. (ii) We compare previous attack-detection proposals across three di↵erent experimental settings: a) a testbed operating real-world systems, b) network data we collected from an operational large-scale Supervisory Control and Data Acqui- sition (SCADA) system that manages more than 100 Pro- grammable Logic Controllers (PLCs), and c) simulations|,Data,57
| Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs|,Data,58
| First, we consolidate the eight origin-exposing vectors into one auto- mated origin-exposing system called Cloudpiercer. Then, we assemble a list of clients from five CBSP companies by studying their DNS configurations and obtaining their adop- tion rate across the Alexa top 1 million websites|,Data,59
| The vast majority of them were exposed through their A record, indicating a brief dis- abling of the protection system. SSL certificate exposure In order to find IP addresses hosting SSL certificates associ- ated with the domains in the evaluation set, we made use of the publicly available data of Rapid7’s Project Sonar [42]|,Data,59
| 4. LARGE-SCALE ANALYSIS To assess the magnitude of the origin-exposure problem, we conduct a large-scale analysis in which we attempt to uncover the origin of CBSP-protected domains|,Data,59
|1 Dataset Description The dataset was first presented and used by Keller et al. in [23], and is publicly available in the gene expression om- nibus (GEO) database under reference GSE61741|,Data,61
| Although the cost of stor- age and processing have diminished, the cost of maintaining reliable infrastructure for transaction logs is still noticeable. Figure 1: A plot of transaction fee versus frequency for 1 million transactions in May 2015|,Data,65
| To estimate the cost of producing the preprocessing data (multiplication triples, random bits etc.), we used figures from the recent MASCOT protocol [31], which uses OT ex- tensions to obtain what are currently the best reported triple generation times with active security|,Data,67
| In this section, we validate whether the smartphone’s acoustic data can be utilized to deduce the movements. To conduct the validation, we implement an application on Nexus 5 (Android OS v6|,Data,68
| As seen in Table 4, we found that about half of the servers in Alexa’s top 10 support a large number of requests without rekeying. For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client|,Data,72
| For a better estimate of the number of vulnerable servers, we tested servers from Alexa’s top 10k that negotiate 3DES with a modern client. We identified 11483 different HTTPS servers11, and found that 226 of them (1|,Data,72
| In this paper, we study the possible techniques to detect and measure this fraud and evaluate the real impact of OTT bypass on a small European country. For this, we performed more than 15,000 test calls during 8 months and conducted a user study with more than 8,000 users|,Data,78
|, the server cannot learn their relative order) after some number of queries are performed over real-world data. Specifically, we ran an experiment where we inserted over 2 million public employee salary figures from [1] and then performed 1000 random range queries|,Data,79
| In this study, we are interested in finding answers to security- and privacy-related questions about libraries, such as “How prevalent are third- party libraries in the top apps and how up-to-date are the library versions?”, “Do app developers update the libs included in their apps and how quickly do they update?”, or “How prevalent are vulnerabilities identified in prior research [28, 9] in libraries and how many apps are affected?” To answer these questions, we first built a comprehensive repository of third-party libraries and applications (see Section 5). Our library set contains 164 libraries of different categories (Ad- vertising, Cloud,|,Data,84
|) and a total of 2,065 versions. We then collected and tracked the version histories for the top 50 apps of each category on Play between Sep 2015 and July 2016, accumulating to 96,995 packages from 3,590 apps|,Data,84
|6.1, we found in our sample set 360 affected packages from 23 distinct apps, when only considering exact library matches|,Data,84
|15 for Android, which contained an account hijacking vulnerability, on 06/11/2014. In the histories of our sample set apps, we discovered, in total, 394 affected packages from 51 distinct apps, when only considering packages with exact matches of the vulner- able lib version|,Data,84
| We used LibScout to detect the affected application packages in our data set. In total 2,667 app versions of 296 distinct apps with a cumu- lative install-base of 3|,Data,84
| We observed that there is a significant variance in ACFG size. To reduce the sampling bias, we first collect a dataset which covers ACFGs of different functions from various architec- tures|,Data,89
| This dataset was used for base- line comparison, and all functions in this dataset has known ground truth for metric validation. We prepared this dataset using BusyBox (v1|,Data,89
| Dataset II – Public dataset. Recent work such as Pewny et al [45] and Eschweiler et al [23] used the same public dataset based upon two publicly-available firmware images for baseline comparison [7, 8]|,Data,89
| Dataset III – Firmware image dataset. This dataset of 33,045 firmware images was collected from the wild|,Data,89
| As a result, we created a freely available vulnerability database for this effort and for the broader research community. To build this database, we mined official software websites to collect lists of vulnerabilities with the corresponding CVE num- bers|,Data,89
| We selected OpenSSL for demonstration, since it is widely used in IoT devices. The resulting vulnerability database includes 154 vulnerable functions|,Data,89
| Roughly speaking, our measurement methods can be divided into two kinds: those that could be fully automated and scaled eas- ily, and those that required some manual interaction. For the latter, we used a set of 302938 major email providers and email genera- tors, while for the former, we used a much larger set of a million popular providers occurring in the Adobe leak and the Alexa top million Web sites (as potential email generators)|,Data,90
1.2 Provider List We created the set of popular email providers based on the top 1 million email address domains occurring in the leaked Adobe user data set of September 2013,Data,90
| Using a combination of mea- surement techniques, we determine whether major providers sup- ports TLS at each point in their email message path, and whether they support SPF and DKIM on incoming and outgoing mail. We found that while more than half of the top 20,000 receiving MTAs supported TLS, and support for TLS is increasing, servers do not check certificates, opening the Internet email system up to man- in-the-middle eavesdropping attacks|,Data,90
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
|26 and are configured with 4G RAM and 2 virtual processors. The VMs for TorA run on a workstation and are connected to a campus wired network, whereas the VMs for TorB and TorC are run on a laptop and connect to a home wired network, Each of these three datasets contains 30,000 traces collected as follows: (1) For each target obfuscator, we used our trace collection framework to visit Alexa Top 5,000 websites to collect 5,000 traces (labeled as obfs3, obfs4, fte, meekG, and meekA, corresponding to obfsproxy3, obfsproxy4, FTE, meek-google, and meek-amazon respectively); (2) In addition, we visited the same set of websites without Tor and obfuscators to collect 5,000 traces and labeled them as nonTor|,Data,91
| 3.1 Datasets We use two major types of datasets: (1) packet-level traffic traces collected at various locations in a campus network, and (2) packet-level traces for Tor Pluggable Transport traffic collected in controlled environments|,Data,91
 Evaluation: local mixing time in social graphs. We use 10 various large-scale real-world social network topolo- gies that mainly come from the Stanford Large Network Dataset Collection [23] and other sources [45] to evaluate the local mixing time for nodes in social graphs,Data,92
| Feature Functions and Weights. To learn all feature functions and weights, we downloaded 1784 non-obfuscated Android applications from F-Droid [3], a popular repository for open-source Android applications|,Data,93
2.2 Experiments with Malware Samples We randomly selected one sample from each of the 49 mal- ware families reported in [40],Data,93
1_r1). Apps in our dataset used for the case study are downloaded from the Google official market (Google Play) in May 2016,Data,95
| • Using SInspector, we perform the first study of Unix domain sockets on Android, including the categoriza- tion of usage, existing security measures being en- forced, and common flaws and security implications. We analyze 14,644 apps and 60 system daemons, find- ing that 45 apps, as well as 9 system daemons, have vulnerabilities, some of which are very serious|,Data,98
| We presented SInspector, a tool for discovering potential security vulnerabilities through the process of identifying socket addresses, detecting authen- tication checks, and performing data flow analysis on na- 90tive code. We analyzed 14,644 Android apps and 60 system daemons, finding that some apps, as well as certain system daemons, suffer from serious vulnerabilities, including root privilege escalation, arbitrary file access, and factory reset- ting|,Data,98
| Our results show that many of our attacks succeed with a 100% chance such that the Sound-Proof cor- relation algorithm will accept the attacked audio samples as valid. Third, we collect general population statistics via an online sur- vey to determine the phone usage habits relevant to our attacks|,Data,100
 We find that the larger width of integer types and the increased amount of addressable memory introduce previously non-existent vulnerabilities that often lie dormant in program code. We empirically evaluate the prevalence of these flaws on the source code of Debian stable (“Jessie”) and 200 popular open-source projects hosted on GitHub,Data,104
| We have applied UniSan to the latest Linux kernel and Android kernel and found that UniSan can successfully prevent 43 known uninitialized data leaks, as well as many new ones. In particular, 19 of the new data leak vulnerabilities in the latest kernels have been confirmed by the Linux community and Google|,Data,107
| This allows us to prevent replay attacks, which are possibly the most applicable attack vectors against biometric authentication. Using a gaze tracking device, we build a prototype of our system and perform a series of systematic user experiments with 30 participants from the general public|,Data,108
| If two commits were blamed for the same amount of lines, blame both. Our heuristic maps the 718 CVEs of our dataset to 640 VCCs|,Data,109
| However, improving our blame heuristics further is an interesting avenue for future research. Apart from the 640 VCCs, we have a large set of 169,502 unclassified commits|,Data,109
|9 The SVM detected a high amount of excep- tions, a high number of changed code, inline ASM code, and variables containing user input such as __input and user. 6As previously mentioned we use the years 2011–2014 as the test dataset, since we have ground truth data on which to base the discussion|,Data,109
| When given a source file, Flawfinder returns lines with suspected vul- nerabilities. It offers a short explanation of the finding as well as a link to the Common Weakness Enumeration (CVE) database|,Data,109
| The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database|,Data,109
| Our results show that our approach significantly outperforms the vulner- ability finder Flawfinder. We created a large test database containing 66 C and C++ project with 170,860 commits on which to evaluate and compare our approach|,Data,109
 VoiceLive takes advantages of the user’s unique vocal system and high quality stereo recording of smartphones. • We conduct extensive experiments with 12 participants and three different types of phones under various ex- perimental settings,Data,111
| To test if WebCapsule can successfully record and subsequently replay real-world phishing attacks, we proceeded as follows, us- ing Chromium on our desktop machine. We selected a large and diverse set of recently reported phishing web pages from Phish- Tank8|,Data,112
| 2.4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime|,Data,113
|4 Datasets and implementation We use two real geographic datasets Cal, SpitzLoc, one synthetic geographic distribution Globe, and one real time- stamp dataset SpitzTime. The dataset Cal represents the latitude and longitude of about 21,000 intersections in the California road network1 (also used by Mavroforakis et al|,Data,113
294258. The dataset SpitzLoc consists of latitude and longitude coordinates tracking the movement of German Green party politician Malte Spitz over six months,Data,113
| In this section, we aim to explore whether the differences of keystroke wave- forms are large enough to be used for recognizing different keys inputs in the real-world setting. We collected training and testing data from 10 volunteers|,Data,114
 B. Real Attacks MAD uniformly detects attacks more quickly than the PAD; we use the former method to detect the presence of an attack in real Internet traces3,Data,119
 III. DATA SET  changes  The data used was the PREDICT ID USC-Lander!  (- 60  The total  were DNS attack packets,Data,120
|395326000  files IPs. There are total 59,928,920 packet counts out of which there was a total of  DoS_DNS_amplification-20130617 (2013-06-17) (2013-06-17) with anonymized million) 358019 DNS packets|,Data,120
| The maximum number of unique hosts per day we measured was 106,000. To understand these differences, we compared the observations from our network monitor to data collected from DShield (www|,Data,121
| 3.1 From our own transactions We engaged in 344 transactions with a wide variety of services, listed in Table 1, including mining pools, wallet services, bank ex- changes, non-bank exchanges, vendors, gambling sites, and mis- cellaneous services|,Data,122
| Wallets. We kept money with most of the major wallet services (10 in total), and made multiple deposit and withdrawal transac- Bank exchanges|,Data,122
|, in which the exchange rate is not fixed) also function as banks. As such, we tagged these services just as we did the wallets: by depositing into and withdrawing from our accounts (but rarely par- ticipating in any actual currency exchange)|,Data,122
|info/tags, including both addresses provided in users’ signatures for Bitcoin forums, as well as self-submitted tags. We collected all of these tags — over 5,000 in total — keeping in mind that the ones that were not self-submitted (and even the ones that were) could be regarded as less reliable than the ones we collected ourselves|,Data,122
| 3.1 Data analysis overview We use three data sets, summarized in Table 1|,Data,123
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
|1 PlanetLab Deployment We deployed tracebox on PlanetLab, using 72 machines as vantage points (VPs). Each VP had a target list of 5,000 items build with the top 5,000 Alexa web sites|,Data,124
| We also describe our application of the technique to the IPv6 interface-level graph captured by CAIDA’s Archipelago (Ark) infrastructure [14] for March 2013. The graph consists of all the 52,986 IPv6 interfaces numbered within the 2000::/3 unicast prefix captured from all 27 Ark vantage points (VPs) with IPv6 connectivity|,Data,125
| cause the counters of distinct routers to diverge, and (4) confirm aliases with pairwise probing. Given the absence of velocity in ID counters and the large probes required for the technique to work, we probe at a low rate of 20pps from a single VP, producing 26Kbps of traffic|,Data,125
| 3. METHODOLOGY In this section, we describe the design of our experiment and our data collection methodology, as well as the mitigating steps and proactive measurements we conducted to ensure a minimal im- pact of our covering routes|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| of IPs 1622 1219 159 9,409 9 12,418 No. of Unique ASNs 603 530 62 3,654 8 4,857 In order to validate minimal impact on data plane connectivity, we performed the following: We collected a set of public IPv6 addresses by querying the Alexa top 1M domains [2] for AAAA records|,Data,126
| Our IPv6 network telescope results suggest sev- eral important differences (and some similarities) compared to that body of work. To produce a more recent and valid comparison, we analyzed a single week of IPv4 background radiation captured during the course of our ongoing IPv6 packet capture|,Data,126
| 4. DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1|,Data,127
| DATA COLLECTION In this section we describe the datasets used in our analysis, which we summarize in Table 1. Our primary dataset consists of changes made to the |,Data,127
| domains, (2) the removal of existing domains, and (3) changes to existing domains in terms of revisions to their associated name- servers. Our data includes captures of the DNZA files as recorded every five minutes, time periods we refer to as epochs|,Data,127
| Since we lack comprehensive ground truth regarding the ultimate use of domains, to this end we use two proxies: subsequent appearance of a newly registered do- main in: (1) an email spam campaign, or (2) a domain blacklist. For the first of these, we operated a spam trap, i|,Data,127
|com), by restricting our focus to domains recently registered (March–July 2012) we can filter down the do- mains appearing in the spam trap to those very likely used for spam- ming. For the second, we subscribed to three major DNS blacklists, URIBL, SURBL, and Spamhaus DBL|,Data,127
| In this paper, we examine the effectiveness of these inter- ventions in the context of an understudied market niche, counterfeit luxury goods. Using eight months of empirical crawled data, we identify 52 distinct SEO campaigns, document how well they are able to place search results for sixteen luxury brands, how this ca- pability impacts the dynamics of their order volumes and how well existing interventions undermine this business when employed|,Data,128
| For a small number of stores, we were also able to collect user traffic data that directly measures an SEO campaign’s effectiveness in attracting customers to their stores. Specifically, we were able to periodically collect AWStats data for 647 storefronts in 12 cam- paigns|,Data,128
| One issue that undermines coverage is that Google only labels the root of a Web site as “hacked”, and does not label search results that link to sub-pages within the same root domain. In the PSR data set, we found 68,193 “hacked” search results|,Data,128
| We begin by exam- ining the properties of individual darknets and in particular the behavior of source IP addresses. We provide these char- acterizations by looking at data from 14 darknet monitors ranging in size from a /25 monitor to a /17 monitor over a period of 10 days between August 18, 2004 and August 28, 2004|,Data,129
| Figure 10: The number of darknets (of 31) reporting a port in the top 10 ports over a day, week, and month time frame. The analysis is performed for the top 10 destination ports over a day, top 10 destination ports over a week, and top 10 destination ports over a month|,Data,129
| 3.6 Datasets This paper uses DNS datasets from three authorities: one national-level top-level domain, operators of two root servers as shown in Table 1|,Data,130
 JP-DNS operates the .jp country code domain for Japan; we have data from all seven of their anycast sites,Data,130
|) part of the 2014 DITL collection [16] (for B-Root, shortly after 2014 DITL). We also use data for M-Root’s 2015 DITL collection (§ 4|,Data,130
 These root datasets are available to re- searchers through DNS-OARC. For longitudinal analysis we draw on 9 months of data taken at the M-Root server,Data,130
| However, we treat the union of these classes together. We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness|,Data,131
| We use data from 103 surveys taken between April 2006 and February 2015, and performed initial studies based on 2011–2013 data, but focus on the most recent of them, in January and February of 2015 for data quality and time- liness. The dataset consists of all echo requests that were sent as part of the surveys in this period, as well as all echo responses that were received|,Data,131
|, “host unreachable”); we ignore all probes as- sociated with such responses since the latency of ICMP error responses is not relevant. In later sections, we will complement this dataset with results from Zmap [5] and additional experiments includ- ing more frequent probing with Scamper [13] and Scrip- troute [22]|,Data,131
| 3.2 Milking 3 Methodology To collect the information needed to cluster servers into oper- ations, we have built an infrastructure to track individual exploit servers over time, periodically collecting and classi- fying the malware they distribute|,Data,132
 2. We receive feeds of drive-by download URLs (Sect,Data,132
 2. CHARACTERISTICS OF CHECK-INS We use three different datasets that capture human mobility,Data,133
 First we consider two online location-based social networks. We col- lected all the public check-in data between Feb,Data,133
| There are 196,591 nodes, 950,327 edges in Gowalla and 58,228 nodes, 214,078 edges in Brightkite. To ensure that our observations on human movement are not specific to data based on check-ins from location-based social net- works, we also include a dataset of cell phone location trace data|,Data,133
| Backscatter DDoS is a commonly seen behaviour in darknets where the attacker uses simultaneous bots to generate the actual attack packets to reach the targeted (original) victim. In our study, five publicly available network traffic datasets from CAIDA’s archives are employed|,Data,134
| Datasets Employed In this research, five publicly available real-life network traffic traces (datasets) from CAIDA’s archives are employed. Three of them, which were captured by a passive darknet in 2007, 2008 and 2012 [27][26][28], namely UCSD Network Telescope [21], include mostly one-way malicious traffic while the remaining ones collected in 2008 [29] and 2014 [30] via CAIDA’s Internet backbone links include only normal traffic|,Data,134
| 3 Approach This section presents our approach for the evalua- tion of reputation based blacklists. We evaluated the blacklists by deploying them in a large academic net- work of over 7,000 hosts|,Data,135
| This was a preliminary step to preventing inexperienced and non-serious workers from participating in our survey. Our survey is based on the participants’ actual check-ins on Foursquare posted over the last 24 months (that we collected through a specific application we developed), and it requires a significant amount of time to complete (30-45 minutes)|,Data,136
| The third phase of worm activ- ity is the persistence phase which for the Blaster worm has continued through 2004. In this one-week period of measurement, the IMS system observed over 286,000 unique IP addresses displaying the characteristics of Blaster activity|,Data,137
| published a study in 2011 that focused on the dynamics of leaf cer- tificates and the distribution of certificates among IP addresses, and attempted to roughly classify the overall quality of served certifi- cates. The study was based on regular scans of the Alexa Top 1 Mil- lion Domains [1] and through passive monitoring of TLS traffic on the Munich Scientific Research Network [17]|,Data,138
| Our study is founded on what is, to the best of our knowledge, the most comprehensive dataset of the HTTPS ecosystem to date. Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443|,Data,138
| Between June 2012 and August 2013, we completed 110 exhaustive scans of the public IPv4 address space in which we performed TLS handshakes with all hosts publicly serving HTTPS on port 443. Over the course of 14 months, we completed upwards of 400 billion SYN probes and 2|,Data,138
| Content Provider e Service Provider v i t c e p s r e P Content Consumer Addressing Prerequisite IP Functions Routing Naming A1: Address Allocation; A2: Address Advertisement N1: Nameservers; R1: Server Readiness N2: Resolvers N3: Queries A2: Address Advertisement; T1: Topology End-to-End Reachability R1: Server Readiness Operational Characteristics Usage Profile Performance U3: Transition Technologies U1: Traffic Volume; U3: Transition Technologies P1: Network RTT R2: Client Readiness U2: Application Mix; N3: Queries Table 2: Dataset summary showing the time period, scale, and public or new status of the datasets we analyzed. Dataset RIR Address Allocations Routing: Route Views Routing: RIPE Google IPv6 Client Adoption Verisign TLD Zone Files CAIDA Ark Performance Data Arbor Networks ISP Traffic Data Verisign TLD Packets: IPv4 Verisign TLD Packets: IPv6 Alexa Top Host Probing Time Period Metrics Jan 2004 – Jan 2014 A1 Jan 2004 – Jan 2014 A2, T1 Jan 2004 – Jan 2014 A2, T1 Sep 2008 – Dec 2013 R2, U3 Apr 2007 – Jan 2014 N1 P1 Dec 2008 – Dec 2013 U1, U2, U3 Mar 2010 – Dec 2013 Jun 2011 – Dec 2013 N2, N3 N2, N3 Jun 2011 – Dec 2013 Apr 2011 – Dec 2013 R1 Recent Scale ≈18K allocation snapshots (5 daily) 45,271 BGP table snapshots millions of daily global samples daily snapshots of ≈2|,Data,139
com & .net) ≈10 million IPs probed daily ≈33-50% of global Internet traffic; 2013 daily median: 50 terabits/sec (avg,Data,139
| To put the IPv6 allocation data in context, Figure 1 also shows IPv4 prefix allocations over the same period. The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled|,Data,139
| There were less than 30 IPv6 prefixes al- located per month prior to 2007, generally increasing thereafter. In the past several years, we typically find more than 300 prefixes allocated per month, with a high point of 470 prefix allocations in February 2011|,Data,139
| The number of IPv4 prefix allocations grows from roughly 300 per month at the begin- ning of our observation period to a peak of 800–1000 per month at the start of 2011, after which it drops to around 500 per month in the last year, as the number of available addresses at RIRs has dwindled. 1 Overall, we find nearly 69K IPv4 prefix allocations at the beginning of our dataset and just over 136K at the end|,Data,139
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| We deployed this detection mechanism on an Alexa top 10 website, Facebook, which terminates connections through a diverse set of network operators across the world. We analyzed 3, 447, 719 real-world SSL connections and successfully discovered at least 6, 845 (0|,Data,140
| Table 1 shows the datasets we use in our paper. We use two ICMP surveys taken by USC [12]: IT17ws and IT16ws; IT17ws is the main dataset used in this paper, while we use IT16ws for validation in Section 6|,Data,142
2. We collected VUSC s at our enterprise in order to compare our inferences with network operators as discussed in Section 6,Data,142
| # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ- ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs|,Data,144
| Third, this method is not specific to C or C++, and can be applied to any programming language. We collected C++ source of thousands of contestants from the annual international competition “Google Code Jam”|,Data,145
| Finally, we analyze various attributes of programmers, types of programming tasks, and types of features that appear to influence the success of attribution. We identified the most important 928 fea- tures out of 120,000; 44% of them are syntactic, 1% are layout-based and the rest of the features are lexical|,Data,145
|3.1ScalingWecollectedalargerdatasetof1,600programmersfromvariousyears|,Data,145
| ) s y a D n i (    e m T i  7  6  5  4  3  2  1  10  20  30  40  50  60  70  80  90 Time Before Accounts Suspension Number of IP Addresses 2 Motivation: Analysis of Malicious Activ- ity on a Webmail Service We want to understand the way in which cybercrimi- nals abuse accounts on online services, to identify weak points that we could leverage for detection. To this end, we observed the email-sending activity on a large web- mail service|,Data,147
| Following accepted frameworks for qualitative research [18, 30, 35], we focus closely on a small number of participants. We interviewed 15 journalists employed in a range of well-respected journalistic institutions in the United States and France, analyzing these interviews using a grounded theory approach [18, 30]|,Data,146
| 3.1 Datasets We examine 13,345 passwords from four sets created under composition policies ranging from the typical to the currently less common to understand the suc- cess of password-guessing approaches against passwords of different characteristics|,Data,149
| Had we used any major password leak, their analysts would have already been familiar with most or all of the passwords contained in the leak, biasing results. The passwords in these sets were collected using Ama- zon’s Mechanical Turk crowdsourcing service|,Data,149
| The decision for or against pinning is always a trade- off between increasing security and keeping mainte- nance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps|,Data,152
| Therefore, we instrument telemetry data from a popular anti-virus software provider. We evaluate the update behaviour of 871,911 unique users from January 2014 to December 2014 and find that only 50% of the users update to a new app version within the first week after release|,Data,152
| Developer View Although pinning is only ap- plicable in relatively few cases, the nominal-actual comparison leaves room for improvement. We there- fore collected feedback from 45 developers of apps for which we would recommend pinning|,Data,152
| Section 4). Altogether we found 20,020,535 calls to network related API calls (cf|,Data,152
| Instability of the routes to the sensor address space can also result in reachability problems, especially given that route flap damping can be triggered during convergence to suppress unstable routes [9]. Using the BGP updates data from RouteViews BGP monitor, we studied the availability of the routes to the sensor blocks in our de- ployment from a large set of ASes|,Data,154
| This section probes these differences using three successively more specific views of traffic to a network of distributed blackhole sensors. The data was recorded over a one month period with SYN responders on TCP port 135, 445, 4444, and 9996 across all sen- sors|,Data,154
|  V. EXPERIMENT RESULTS  In this section, we mainly focus on how our router-to-AS Mapping method and other baseline methods behave on global router-level topology, as discussed above, we use PeeringDB data as ground truth, and apply clustering method on global topology based on CAIDA ITDK project|,Data,155
| It describes the properties that a dataset should have in order to be used for comparison purposes. The dataset used in the paper includes an IRC-based Botnet attack1, but the bot used for the attack was developed by the authors and therefore it may not represent a real botnet behavior|,Data,156
| This dataset may be downloaded with authorization. The Protected Repository for the Defense of Infrastructure Against Cyber Threats (PRE- DICT) indexed three Botnet datasets2 until May 16th, 2013|,Data,156
 None of them are labeled. A custom botnet dataset was created to verify five P2P botnet detection algorithms in Saad et al,Data,156
| Unfortunately, there is only one infected machine for each type of botnet, therefore no synchronization analysis can be done. The Traffic Laboratory at Ericsson Research created a normal dataset that was used in Saad et al|,Data,156
 This is the only normal dataset that is labeled inside the pcap file. A considerable amount of malware traffic in pcap format was published in the Contagio blog9,Data,156
| But since each scenario includes only one infected computer, it should be possible to label them. Another dataset with malware logs and benign logs was collected in NexGinRC (2013)|,Data,156
 Access to this dataset may be granted upon request10. The last dataset analyzed is currently created by the MAWI project described in Cho et al,Data,156
| Methodology and datasets We deployed Paris Traceroute with its Multipath Detection Algorithm (MDA) [29] enabled in 90 PlanetLab nodes. We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]|,Data,158
| We configured each node to trace IP-level routes toward 10 thou- sand destinations selected at random from a list of 102,404 reachable destinations in different /16 prefixes we obtained from the PREDICT project [11]. Our dataset contains more than 900 thousand IP-level (multi)routes and 324,313 IP addresses|,Data,158
1 3.1 Address Allocation and BGP Data We analyzed BGP announcements captured by all collectors (24 collectors peering with 184 peers) of the Routeviews [3] and RIPE RIS [52] projects,Data,159
| For each /24 block, we computed the maximum number of peers that saw it reachable at any time within the full observation period of 92 days. To determine which address blocks are available for assignment, we used a dataset compiled by Geoff Hus- ton [23], which merges the extended delegation files from the 5 RIRs [4, 6, 7, 41, 51] with IANA’s published registries [31–36]|,Data,159
| SWITCH. We collected unsampled NetFlow records from all the border routers of SWITCH, a national aca- demic backbone network serving 46 single-homed uni- versities and research institutes in Switzerland [55]|,Data,159
| R-ISP. We collected per-flow logs from a vantage point monitoring traffic of about 25,000 residential ADSL customers of a major European ISP [21]|,Data,159
 UCSD-NT. We collected full packet traces from the /8 network telescope operated at the University of Cal- ifornia San Diego [1],Data,159
| IXP. Our fourth VP is a large European IXP inter- connecting more than 490 networks, exchanging more than 400 PB monthly [5]|,Data,159
|3 Active Measurements ISI. We used the ISI Internet Census dataset it55w- 20130723 [37], obtained by probing the routed IPv4 address space with ICMP echo requests and retaining only those probes that received an ICMP echo reply from an address that matched the one probed (as rec- ommended [38])|,Data,159
| HTTP. We extracted IP addresses from logs of Project Sonar’s HTTP (TCP port 80) scan of the entire IPv4 address space on October 29, 2013 [24]|,Data,159
| Definitions of graph parameters measuring metric tree-likeness of a graph, as well as notions and notations local to a section, are given in appropriate sections. 3 Datasets Our datasets come from different domains like Internet measurements, biological datasets, web graphs, social and collaboration networks|,Data,160
| The experiments were executed as follows. Traces were col- lected by using ICMP, UDP, and TCP Traceroute to probe the paths to a set of 100 destination websites from a source located on the Pennsylvania State University, University Park campus|,Data,161
| For UDP and TCP Traceroute, traces were collected using the default destination port numbers. We also collected traces using other ports and observed similar results|,Data,161
| Realistic Networks Here we compare the merged topologies produced by iTop, MN, and Isomap for realistic topologies. We use the Au- tonomous System (AS) topologies from both the Rocketfuel [20] and the CAIDA [21] projects, which represent IP-level connections between backbone/gateway routers of several ASes from major Internet Service Providers (ISPs) around the globe|,Data,161
| Although the paris-traceroute output of ITDK is more reliable than that of IPlane’s traceroute, the random selection of endpoints implemented by CAIDA hinders the collection of routes between the same vantage- and endpoints. Therefore we used the data of IPlane’s traceroute measurements|,Data,162
| They can also be used for constructing maps of the Internet at the Autonomous Systems level [, ]. In this work we used the CAIDA router-level Internet map from October th,  []|,Data,163
| 3 Table 1: Dataset Description Name BGP Usage AS Geolocation; Detour Detection Date 2016-01 Sources Info RouteViews, RIPE 38,688 RIBS, 416 peers, RIS 30 countries, 55GB Infrastructure IP List AS Geolocation 2016-01 to 2016-03 CAIDA Ark, iPlane, OpenIPMap, RIPE Atlas Measurements 3M Router IPs Infrastructure IPs to AS Mapping Infrastructure IP geolocation 2015-08 CAIDA ITDK, iPlane 6.6M IP to AS mappings AS to IXP Mapping AS Relationship AS Geolocation 2016-01 to 2016-03 Filtering peered paths from detection 2016-01 Traceroute Detour Validation 2016-05-01 IXP websites, PeeringDB, PCH CAIDA AS Relationship RIPE Atlas MaxMind Prefix Geolocation; Detour Validation 2016-01, 2016-03 MaxMind GeoLite City (free and paid) 368 IXP websites crawled 482,657 distinct relationships Used by Netra, 163 traceroutes Paid version used only for geolocating infrastructure IPs and detour validation longest prefix match on the global routing table and map the IP to the AS announcing the longest matching prefix|,Data,164
| As shown in Figure 3, we install LaBrea on a /29 subnetwork and use PlanetLab [9] to probe from multiple vantage points the entire /24 aggre- gate to which the /29 belongs. We scan the /24 network by attempting to establish TCP connections to each IP address in the subnet and capture the packets for further analysis|,Data,165
| • Active IPs in a Subnet: Intuitively, we might ex- pect high-occupancy subnets to be good indicators of pos- sible tarpits. To this end, we initially investigated using a hitlist of probable tarpits as inferred from the /24 subnets with more than 240 responding web hosts in the scans|,Data,165
| To facilitate large-scale scanning and avoid triggering anomaly detectors, degreaser uses permu- tation scanning [7, 12] to pseudo-randomly iterate through the IP address space when probing. Our real-world Internet scan, which probes at least one address in each /24 network in the Internet, discovers 107 different tarpit subnetworks (cid:20)(cid:24)(cid:25) ranging in size from /16 (with up to 216 fake hosts) to /24 (with up to 28 fake hosts)|,Data,165
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
  III. DATA SET  The data used in this work was the PREDICT ID USC-Lander/ DoS_DNS_amplification-20130617 (2013- 06-17) to (2013-06-17) [26],Data,166
| • Discovering correlations between anomalous traffic types detected with deep inspection techniques and traffic feature entropy variations. • Providing a traffic-type dissection (in-depth and entropy based) of a representative portion of the IBR for three weeks of April, 2012, with a 10-minute time scope|,Data,167
 Following is the summary of information about these data sets:  1. Data set from PREDICT USA [24] which contains traces of a DNS distributed denial of service attack (DDOS),Data,168
  from optical  2. Data set from CAIDA USA [25] which contains internet internet connectivity from 2002 and 2003,Data,168
  3. Data set from our experiment in which a PCAP file is captured from a lab computer which is being used for browsing and software development for the cyber security project,Data,168
| With certain mining pool reward schemes, the miner’s ex- pected reward for participation varies over time, depend- ing on how many shares have been contributed since the pool found its last block The concern is that miners would respond by “hopping” in real time to the pool that max- imizes their expected rewards For another illustration of this theme, consider a future where there are multiple cryp- tocurrencies with time-varying rewards which can be mined by the same hardware Perhaps this will give rise to coin- hopping, i|,Non-data,71
|e, miners hopping to the cryptocurrency with the largest transaction fee pool Contribution 1: A mining strategy simulator While we establish a number of theoretical results in Sections 5 and 6, the variety of possible parameters and assumptions makes it completely infeasible to pose a perfectly accurate Game-Theoretic model of Bitcoin that is also tractable|,Non-data,71
| To fill the gaps and to confirm our theoretical results, we’ve built a mining strategy simulator Theoretical results in simple yet principled models provide good intuition to guide practice, and simulations of more complex scenarios confirm that these results have applicability to more realistic models where mathematical proofs are intractable Miners in our simulation learn over time which strate- gies are successful using no-regret learning algorithms that iteratively update a probability distribution over strategies (Section 42)|,Non-data,71
| Our simulator is versatile and allows model- ing different numbers of miners, hash power distributions, network latencies, and reward schemes We show how it allows researchers to quickly prototype and study new set- tings within this parameter space The simulator does have limitations: it cannot model mining pools or a non-constant arrival rate of transactions We have made the simulator open source|,Non-data,71
|1 In addition to the versatility of settings, our simulator allows exploring a large space of mining strategies, defined by the miner’s responses to three questions: which block to extend, how much of the outstanding transactions to include in the block, and when to publish found blocks We define a formal language to compactly express any strategy in this space (Section 4) Contribution 2: Undercutting attacks The focus of this paper is on analyzing deviant mining strategies in the transaction-fee regime that can harm Bitcoin’s security|,Non-data,71
| We begin with the observation that if there is a 1-block fork, it is more profitable for the next miner to break the tie by extending the block that leaves the most available transaction fees rather than the oldest-seen block We call this strategy PettyCompliant Once any non-zero fraction of miners is PettyCompli- ant, it enables various strategies that are more aggressive and harmful to Bitcoin consensus We call this the undercut- ting attack, where miners will actively fork the head of the chain and leave transactions unclaimed in the hope of incen- tivizing PettyCompliant miners to build on their block|,Non-data,71
| 1https://githubcom/citp/mining simulator In some scenarios, our simulation reveals a non-equilibrium with increasingly aggressive undercutting But with an ex- panded strategy space, and suitable assumptions, we are able to prove that an equilibrium exists However, it is one where miners include only a fraction of available transactions into their blocks|,Non-data,71
| This results in a backlog of transactions whose size grows indefinitely with time We confirm this result using simulation Accurately predicting the steady-state mining behavior requires modeling a vast number of variables such as miners’ cost structure, and is not the goal of our work Instead, our results can be seen as an informal “lower bound” on the departures from compliant behavior that are likely in a transaction-fee regime|,Non-data,71
| We can realistically predict that PettyCompliant miners will arise, and that the existence of such miners opens the field for various more aggressive strategies (Section 5) Contribution 3: Revisiting selfish mining We re- visit the selfish mining strategy of Eyal and Sirer [9] and show that, contrary to intuition, it performs even better in the transaction-fee regime than in the block-reward regime Next, we propose a more sophisticated selfish mining strat- egy that accounts for the non-uniformity of rewards and out- performs both default mining and “classic” selfish mining|,Non-data,71
| Worse, unlike classic selfish mining, this strategy works for miners with arbitrarily low hash power and regardless of their connectedness in the Bitcoin network Moreover, the attack is profitable as soon as it is deployed, whereas classic selfish mining only becomes profitable after a two-week dif- ficulty adjustment period, arguably giving the community a crucial window of time to detect and respond to such an attack [10] We validate these results via both theory and simulation (Section 6) Impact on Bitcoin security|,Non-data,71
| If any of the deviant min- ing strategies we explore were to be deployed, the impact on Bitcoin’s security would be serious At best, the block chain will have a significant fraction of stale or orphaned blocks due to constant forks, making 51% attacks much eas- ier and increasing the transaction confirmation time At worst, consensus will break down due to block withholding or increasingly aggressive undercutting This suggests a fundamental rethinking of the role of block rewards in cryptocurrency design|,Non-data,71
| Nakamoto appears to have viewed the block reward as a necessary but temporary evil to achieve an initial allocation of bitcoins in the absence of a central authority, with the transaction fee regime being the ideal, inflation-free steady state of the system But our work shows that incentivizing compliant miner behavior in the transaction fee regime is a significantly more daunting task than in the block reward regime Perhaps instead, de- signers of new cryptocurrencies must resign themselves to the inevitability of monetary inflation and make the block reward permanent Transaction fees would still exist, but merely as an incentive for miners to include transactions in their blocks|,Non-data,71
| 2 RELATED WORK Several recent works analyze incentives in Bitcoin min- ing Some examples include [12] and [8], which analyze how strategic mining pools may attack competing pools in vari- ous ways, and [15], which analyzes how strategic Ethereum miners can trick others into wasting their computational 155power verifying the validity of complex scripts Understand- ing miner incentives in the Bitcoin system is important — there is empirical evidence that miners/mining pools are willing to attack others in order to maximize their own prof- its (e|,Non-data,71
|g by launching DDoS attacks against other mining pools) [23] Eyal and Sirer develop the selfish mining attack [9], a de- viant mining strategy that enables miners to get more than their fair share of rewards We build on their results in Sec- tion 6|,Non-data,71
| Other works, notably Sapirshtein et al [22] have analyzed selfish mining in more detail using Markov Deci- sion Processes (MDP) In an MDP, a player moves through a discrete state space and tries to maximize reward (the state- transition function and reward function are probabilistic) This makes it a good fit for modeling Bitcoin mining|,Non-data,71
| How- ever, in our case the state space (specifically, the amount of remaining transaction fees) is continuous and not discrete, so we do not use the machinery of MDPs There is some work on understanding the market for trans- action fees and its relation to the block size (ie what fees will users have to pay in order for transactions to be in- cluded in a block?) [13, 11, 20, 17]|,Non-data,71
| Our work avoids this discussion; we show that undesirable behavior emerges even if the market reaches an equilibrium where transaction fees are non-negligible, and arrive steadily and reliably Inter- estingly, M ̈oser and B ̈ohme reach the same conclusion as us (that monetary inflation is a preferable mechanism to trans- action fees) through very different methods [17] On the simulation side, numerous prior works have devel- oped simulators for some aspect of Bitcoin Some simulators are aimed at aspects of Bitcoin aside from strategic min- ing, such as privacy [3], or the peer-to-peer network [16]|,Non-data,71
| Those developed in [9] and [8] also focus on simulating de- viant mining strategies, but our understanding is that these simulators are tailor-made for the specific deviant strategies they wish to test In comparison, our simulator allows for easy implementation of a broad range of strategies in var- ious environments Indeed, the versatility of our simulator is crucial for getting intuition for every result in this paper We have made it open-source and hope it will be a useful tool for future research on strategic miner behavior|,Non-data,71
| 3 MODEL AND STRATEGIES In this section, we cover the model of Bitcoin that we investigate We will use this model to quickly illustrate how the switch to transaction-fee dominated rewards may lead to interesting and potentially harmful effects for Bitcoin We also introduce a formal language for describing Bitcoin strategies that we will use throughout the paper|,Non-data,71
| 31 Model of the system Briefly, let us describe the theme of our model before get- ting into specific details The goal of this work is not to accurately predict exactly what mining behavior will arise in practice, but instead to uncover incentive issues that arise solely due to the time-varying nature of transaction fees ver- sus block rewards To this end, our model is intentionally simple because we want to isolate the effects of time-varying versus fixed rewards|,Non-data,71
| As an example, we will assume that transactions (and their associated fees) arrive at a constant and continuous rate We make this assumption not be- cause we necessarily predict it will hold in practice, but because without it we can’t guarantee that we’ve isolated time-varying transaction fees as the cause for any incentive issues we uncover Put another way, our results are only made stronger by simplifying assumptions, because we are claiming that weird and undesirable consequences arise even if one is willing to grant simplifying assumptions Getting to details, the model of Bitcoin that we analyze is after the block reward has dropped to zero|,Non-data,71
| That is, trans- action fees are the only source of revenue for miners, and we model available transaction fees as arriving to the Bit- coin system at a constant rate Specifically, we assume that for any time interval I of length t, the total sum of transac- tion fees for transactions announced during I is t (the choice of t instead of ct for some constant c is just normalization) This is different from Bitcoin as it is today with a large block reward compared to the small transaction fees, but this sce- nario is consistent with the vision of the long-term steady state behaviour of Bitcoin after all Bitcoins have eventually been minted We also assume that the difficulty is set so that a hash puz- zle is solved by someone in the network every one time unit in expectation (this is again just a normalization)|,Non-data,71
| Addition- ally, for simplicity, in our theoretical results and reported simulations we model the network having no latency (unless otherwise stated) Once a miner publishes a block, all other miners immediately gain knowledge of it Similarly, once a transaction is announced, all miners immediately learn of its existence However, our simulator is capable of simulating latency of both types, and we do not see any substantive change in our results as latency changes|,Non-data,71
| Finally, we assume that when there are R transaction fees available, the miner can choose to include any real-valued number of transaction fees between 0 and R in their block That is, transactions are fine-grained enough that a miner can selectively choose a set of transactions whose fees are very close to whatever real-valued target they have in mind We believe this is a reasonable approximation due to the large number of transactions per block We also assume that miners always have space to include all available transactions|,Non-data,71
| If the block size is not large enough to meet demand for transactions, we believe the qualitative content of all our results continue to hold, but the quantitative impact is mitigated This belief is supported by the following data, taken from the most recent 1000 blocks (roughly one week’s worth) as of July 11, 2016: of these 1000 blocks, 702 are full Of the full blocks, the total sum of transaction fees ranges from 003 BTC to 4|,Non-data,71
|51 BTC The mean is 049 BTC and the standard deviation is 025 BTC, more than half the mean|,Non-data,71
| It’s unclear how to extrapolate these data to the future, but it is clear that there will indeed be fluctuation in the available fees that fit in a block So if the block size is not large enough to meet demand for trans- actions, even though the available fees immediately after a block is found will not be zero (as in our analysis), they may be significantly lower than (say) ten minutes later So even though our exact analysis will not apply in this setting, the intuition does carry over 3|,Non-data,71
|2 What could go wrong? The mining gap Without a block reward, immediately after a block is found there is zero expected reward for min- ing but nonzero electricity cost, making it unprof- itable for any miner to mine 156structure At each instant, every miner makes several dis- tinct decisions: • Which block to extend • How much of the available transactions (and associated fees) to include in the block they are solving|,Non-data,71
| • For each unpublished block, whether or not to publish The first decision is which block to extend As an ex- ample, the default compliant miner chooses to mine on the longest chain that they are aware of, and in the case of multi- ple blocks that are tied for the longest chain, they will favor mining on the first of these blocks that they became aware of This decision forms the basis for how a mining strat- egy will determine which side of a fork it wants to support, or, alternatively, if the miner wants to create a new fork|,Non-data,71
| The next decision is how much of the available transaction fees to claim Again, as an example, the default compliant miner will include all of the unclaimed transaction fees they are aware of in their block The final decision is when to publish blocks When a miner mines a block, only they are aware of its existence|,Non-data,71
| At each moment, miners can choose whether or not to alert the other miners of the block that they have found This allows for mining strategies where miners intentionally choose to not reveal their blocks (such as selfish mining [9]) We define the following concepts in order to more rig- orously describe the mining strategies: First, for a set of transactions T , we will abuse notation and use T to also denote the total transaction fees included for transactions in T  For a block, B, we will denote Tx(B) to be the set of transactions included in block B, and Rem(B) to denote the remaining transactions after block B|,Non-data,71
| That is, Rem(B) contains all announced transactions in that are not included in B or any of its predecessors (thus, this is a set that varies over time) We will also use Height(B) to denote the height of a block (ie the height of a chain that ends at block B), denoting by H the height of the current longest chain that has been announced,2 and Owner(B) to denote the miner that produced block B|,Non-data,71
| When a miner m is deciding which block of height i to extend in the case of a tie, all strategies considered in this pa- per first select a block that they themselves mined (Owner(B) = m) Also, all strategies in this paper avoid mining multiple blocks at the same height, so if a block with Owner(B) = m at height i exists, it would be unique If m did not pro- duce any blocks at height i, the default client would then select the first block that m became aware of So we define Oldestm to be the unique block of height i produced by i miner m if it exists, or the first block of height i that m became aware of|,Non-data,71
| Note that if i = H, then this is the block m would extend using the default strategy We also define Mosti to be the block of height i that maximizes the remain- ing transaction fees (formally: argmaxB||Height(B)=i{Rem(B)}) Note that while Rem(B) changes over time, the block Mosti can only change if a new block of height i is published Fi- nally, we denote by Mostm the block of height i produced i by m (if it exists), or the block of height i that maximizes the remaining transaction fees otherwise|,Non-data,71
| 2So for instance, if a chain of height 2 has been announced, but some miner is privately storing a chain of length 10, we would define H = 2 Figure 2: Illustration of Mining Gaps Miners will only mine when the instantaneous expected reward exceeds the instantaneous cost In order to provide insight as to how time-varying rewards could be harmful for Bitcoin, let’s walk through an example|,Non-data,71
| Imagine that we are in the model previously described, that all miners are using the default compliant strategy (mine on top of the longest chain, authorize all available transactions, publish immediately), but also that that miners have some cost in electricity to run their mining rigs (ie, running one rig for t units of time costs pt Bitcoin worth of electricity) Now, immediately after a block is found, there will be no more transactions in the network to be claimed by a miner making the next block|,Non-data,71
| This means that for the instant fol- lowing the discovery of a new block, there is actually zero expected reward for mining, but a non-zero electricity cost for doing so! Figure 2 shows how to extend this reasoning to the time period beyond Essentially, every instant your rig is running, you claim some expected reward, which increases depending on the available transaction fees But every in- stant your rig is running, you also have to pay a constant amount for electricity So the expected reward for running your rig won’t exceed the cost of electricity until some min- imum number of transaction fees are available to include|,Non-data,71
| If a is the fraction of the total (effective) hash power that a single rig generates, then a miner must wait t = p/a time steps after a block is found before mining becomes profitable again In the full version of this paper, we discuss in more detail the effects of such a mining gap, and find that it leads to miners mining for a smaller and smaller fraction of the time between the arrival of blocks (with the difficulty dropping to compensate) Clearly, this would have a negative im- pact for Bitcoin security, as the effective hash power in the network would drop, and it would become easier for a mali- cious miner to fork Of course, turning a rig on and off every ten minutes may be practically infeasible|,Non-data,71
| Nevertheless, this analysis illustrates that strategic miners might look for ways to deviate when the default protocol would have them wast- ing electricity to mine a near-valueless block 33 Formal language for mining strategies In the rest of this paper, we focus on mining strategies that always mine within the same cryptocurrency, but may deviate from the default protocol in choosing how to build blocks and what to do with them once they’re found We consider a variety of known and novel Bitcoin mining strate- gies|,Non-data,71
| All of these can be formalized into the same general 157We can now formally define mining strategies we consider We model strategies as time-driven (rather than event-driven): in every infinitesimally small time step, the miner must de- cide which block to extend (denoted by Mining(m)), what set of transactions to include, and for each of their own unpublished blocks, whether to publish Note that by pub- lishing a block B, we mean ensuring that every node in the network is aware of B and all its predecessors, and aren’t concerned with exactly what physical measures m takes to ensure this In this language, the default mining strategy would be formalized as follows: DefaultCompliant: The default Bitcoin mining strategy, including all avail- able transactions, mining on the end of the longest chain, choosing the older block in a tie, and publishing all blocks|,Non-data,71
 Which Block: Mining(m) = Oldestm H  How much: include Rem(Mining(m)) Publish(B)?: yes 4,Non-data,71
| MINING STRATEGY SIMULATOR In order to more clearly analyze what the game theoretic landscape will look like once the Bitcoin mining incentive be- comes transaction fee based instead of block reward based, we have developed a versatile Bitcoin mining strategy sim- ulator3 Here we discuss the strategies our simulator is ca- pable of implementing, the process by which our simulator can explore a strategy space, the configurable parameters of the simulator, and its limitations 41 Strategies, Rounds, and Games We first describe the basic units of our simulator and how they interact with each other before getting into details|,Non-data,71
| Strategies The simulator is designed in such a way to be able to run any strategy that fits the strategy space detailed in Section 33 That is, every strategy is fully defined by a function that outputs a block to extend, a set of trans- actions to include, and a rule to decide whether to publish any found blocks|,Non-data,71
| All of these functions may take as input any public information, including all published blocks and all announced transactions Rounds Our simulator is time-driven, as opposed to event- driven We made this decision because we want it to be easy to add new strategies to the simulator|,Non-data,71
| In an event-driven simulation, new strategies would be limited by the current list of possible events However, in our time-based simula- tions, any strategy that details how to make the decisions above at any moment can be easily implemented A round is the smallest unit of time in our simulator (cur- rently, 1/600 of the time it takes for the entire network to find a block) During a round, every miner first takes as in- put the block chain (that they’re aware of) and all transac- tions (that they’re aware of) and decides which block to (try to) extend, and which transactions to include|,Non-data,71
| Then there is a random check (as a function of that miner’s hash rate 3While this is the original motivation for developing our simulator, it is indeed capable of simulating non-zero block reward as well — more on that in Section 43 and the current network difficulty) to determine whether the miner successfully found a block or not Then, the miner de- cides which unpublished blocks to publish|,Non-data,71
| The duration of a round is a configurable parameter, which we discuss shortly in Section 43 Games A game involves setting parameters such as choos- ing a number of miners, assigning their strategies and hash power, etc|,Non-data,71
| (all detailed in Section 43) Once these parame- ters are set, a game runs for several rounds, and keeps track of the rewards earned by each miner Simulations|,Non-data,71
| A simulation might consist of a single game (to see how certain strategies fare against each other), or several games with parameter adjustments in between For example, in order to model miners who learn over time, we have them play several games and decide which strategies to use in future games based on results of past games In principle, any parameters can be adjusted between games 4|,Non-data,71
|2 Strategy exploration For several of our simulations we want miners to utilize the strategies that are doing the best, to simulate how strate- gic miners might adapt over time In order to accomplish this, we run several games, with hundreds of miners in each game Miners choose strategies proportional to how success- ful those strategies have historically done Formally, min- ers in our simulator perform no-regret learning, a standard notion of learning that is popular in game theoretic con- texts|,Non-data,71
| This is due to the fact that in any repeated game where each player separately performs no-regret learning, the repeated play converges to a coarse correlated equilib- rium [1, 2] Moreover, numerous simple no-regret learning algorithms are known that converge quickly (ie in a num- ber of rounds sublinear in the number of possible strate- gies) [5, 6, 4, 14]|,Non-data,71
| If a miner has no regret, their total re- ward across all of time is at least as good as had they instead picked “the best” strategy and used it in every game Sim- ilarly, a coarse correlated equilibrium is a joint distribution over strategy profiles such that every miner gets more ex- pected payoff by following the equilibrium than deviating to any possible strategy These learning algorithms all maintain a weight for every strategy, and adjust the weights of the strategies from game to game depending on how well they’re doing Our simulator offers two alternatives for these update rules|,Non-data,71
| The first al- ternative is an exact implementation of the EXP3 algorithm for learning with adversarial bandits [5, 6] This update rule provides a theoretical guarantee on the regret of each miner as a function of the number of games played and a tunable parameter in the update rule,  The second alternative is based on the multiplicative weights update rule (MWU) for learning with experts [4, 14] We find that MWU is com- putationally expensive, so we use a less expensive proxy in- stead|,Non-data,71
| That means there is no theoretical guarantee on the regret bounds But in practice this update rule is signifi- cantly faster and does converge quickly to coarse correlated equilibrium For a further discussion of these update rules, see the full version 4|,Non-data,71
|3 Versatility Our simulator has many configurable parameters: Strategies Just to reiterate: every miner in our simulator is assigned a time-driven strategy that chooses which block to extend, how many transactions to include, and whether 158to publish any found blocks Any strategy that fits this framework can be implemented in the simulator To design a new strategy, a user would create a new function that takes as input the current public state of Bitcoin network (the blockchain and available transaction fees), and the miner who is using the strategy|,Non-data,71
| The function would then use this information to determine which block to extend, and how many of the transaction fees to include in the next block Finally, the user would go to the publication rules and add a rule for how the strategy should choose whether or not to publish any found blocks Hash Power Every miner m is assigned a hash power αm|,Non-data,71
| m αm = 1 Any number of miners, and any αm such that(cid:80) can be supported Round Duration The size of a round can be set so the network finds a block every r rounds in expectation, for any r > 0 Rewards|,Non-data,71
| At the end of each game, miners are rewarded based on their blocks within the longest chain The reward they receive is b per block (fixed reward), plus any trans- action fees a transaction fees accrue in the system every round Both of these parameters are configurable|,Non-data,71
 Costs There is a configurable parameter cm for every miner m that denotes the cost (ie in electricity) for miner m to mine,Non-data,71
| For our simulations, we always set cm = 0 because we aren’t looking at this aspect of mining Latency If desired, latency can be introduced to the simu- lation There is a configurable parameter λ such that when blocks are published, it takes λ rounds before other miners are aware of this blocks existence|,Non-data,71
| Latency in hearing about transactions can also be implemented — it is currently easi- est to do this by modifying strategies to randomly “pretend” they haven’t heard of some transactions Learning parameter Our learning rules are parameter- ized by an  ∈ [0, 1/2] For EXP3, it is customary to set  ≈ (cid:112)n ln n/T , where n is the number of strategies con-  ≈ (cid:112)ln n/T |,Non-data,71
| Smaller  encourages more exploration, and sidered and T is the number of games played For MWU (and our “MWU-like” update rule), it is customary to set larger  encourages more exploitation Atomic versus Non-Atomic Miners We say miners are atomic if there are finitely many of them, and each has a finite fraction of the total hash power|,Non-data,71
| Such miners may have an interest in sacrificing immediate gains related to a block mined now in order to achieve greater gains for blocks mined in the future Non-atomic miners are infinitesimally small, but there are infinitely many of them When such miners find a block, they are only interested in maximizing their gains related to that block (because they will never find another block in the future) Obviously our simulation cannot create infinitely many miners, but we can functionally simulate them|,Non-data,71
| To simulate that an α fraction of non-atomic miners are using strategy s, we instead create a single atomic miner with an α fraction of the hash power, and ensure that all of this miner’s strategic decisions take as input only the public information available to the entire network, and does not treat “their own” blocks any differently than generic blocks Of course, the real world is atomic But it is extremely helpful to compare simulation results between the two mod- els to isolate behavior that arises only when miners are atomic (example: selfish mining), as intuitively this behav- ior “gets worse” with big miners (as with selfish mining) 4|,Non-data,71
|4 Implementation and performance The simulator is written in C++, and has a running time that is linearly proportional to the product of the number of games, the number of rounds per game, and the number of miners As an optimization to the algorithm, we have the miner determine if they find a block at each time step prior to actually computing which block they will extend and how many transaction fees they will include We find that for accurate results, the games need to include enough rounds so that that for every strategy, the miners using it together find tens of blocks|,Non-data,71
| We also find that it takes on the order of a few hundred games for our MWUs to converge to an equilibrium On a commodity laptop with a 27 GHz Intel Core i5 processor, running a simulation of a single game with 200 miners, an average interarrival time of 600 rounds, and a total of 6,000,000 rounds (≈10,000 blocks will be created), takes approximately 400 seconds (65 minutes)|,Non-data,71
| Limitations A current limitation of the simulator is that the transaction fees can only be modeled as coming in at a uniform rate in time Additionally, the simulator is not capable of modeling mining pool dynamics beyond treating them as a single miner with hash power equal to that of the pool This doesn’t allow for consideration of attacks such as those presented in [8]|,Non-data,71
| 5 NEW DEVIANT MINING BEHAVIOR In this section, we examine what deviant mining behavior might unfold in the transaction fees model that doesn’t arise in the block-reward model Specifically, we argue that: • It is reasonable to expect self-interested miners to be- come PettyCompliant instead of DefaultCompli- ant once transaction fees take over • The existence of PettyCompliant miners in the net- work opens the field for a range of aggressive strategies with detrimental effects to Bitcoin’s stability|,Non-data,71
 51 Phase One: Petty compliant Observation: The default client behavior of min- ing on the oldest block is not optimal Miners can do strictly better by mining on the block that leaves the most transactions fees unclaimed Consider the case where there is a fork: two blocks are tied for longest chain,Non-data,71
| The traditional behavior, and the one programmed into the default client,4 would have the miner select the older of the two potential block heads However, there is really no cost for that miner instead to tie-break arbitrarily In particular, if the miner is planning to in- clude all unclaimed transactions in their block, it would be in that miner’s interest not to mine on the oldest block, but instead the block that leaves the most remaining fees Therefore, a strategic miner would want to mine on Mostm H instead of Oldestm H |,Non-data,71
| We call this strategy petty compliant, as it is still mining on a longest chain, including all available transactions, and publishing all blocks that are found (like a default compliant miner) It is just tie-breaking between longest chains in a “petty” way to achieve greater revenue 4Note: this is not a self-enforcing part of the protocol It’s purely client-side behavior|,Non-data,71
| 159PettyCompliant: Mine like a default compliant miner, except when choos- ing between two sides in a fork; mine on the block that has claimed the fewest transaction fees Which Block: Mining(m) = Mostm H  How much: include Rem(Mining(m)) Publish(B)? yes|,Non-data,71
| If forks ever exist, then PettyCompliant strictly outper- forms DefaultCompliant The two are identical except for the case where the miner is required to choose between two equal height blocks to mine on In this case PettyCompli- ant always makes the decision to mine in a location that maximizes their rewards, and DefaultCompliant might In our mining strategy simulator, we compare De- not faultCompliant to PettyCompliant and do in fact see that PettyCompliant outperforms DefaultCompliant, regardless of the breakdown of other miners in any simula- tion where there is enough latency (in learning of both new blocks and transactions) that forks naturally occur|,Non-data,71
| Note that the existence of petty compliant miners is not necessarily harmful by itself: so what if miners are tie- breaking differently in the rare event that forks naturally occur? The problem arises when other strategic miners no- tice the existence of petty compliant miners and choose to exploit this with more aggressive tactics We’ll see some examples of this in the remainder of this section The ex- istence of PettyCompliant miners impact other deviant strategies in surprising ways too For example, a selfish miner (discussed more in Section 6), performs better against PettyCompliant miners than DefaultCompliant|,Non-data,71
| 52 Phase Two: Lazy Undercutting Observation: Once some fraction of miners is petty compliant, other miners may profit by in- tentionally forking the chain The key insight for more aggressive strategies is that a deviant miner can incentivize petty compliant miners to ex- tend their block, even if an older block of the same height was discovered several minutes earlier, for instance, by ex- tending that block’s direct predecessor and including slightly fewer transaction fees If the current unauthorized transac- tion fees are substantially fewer than those included by the current MostH, then maybe it is in a miner’s interest to try and replace MostH with a new block of height H, instead of continuing on top of it|,Non-data,71
| We call this undercutting So what might a strategic miner do to take advantage of this? They might first compare between the maximum rewards they could get by continuing versus undercutting (while still becoming the new MostH), and mine on top of whichever block yields greater rewards Then, to protect themselves with certainty against future undercutters using the same rule, they could take half of the remaining transac- tions Because of the somewhat lax reasoning used to choose these parameters, we call this strategy LazyFork|,Non-data,71
| While the existence of PettyCompliant miners them- selves is relatively benign, the existence of LazyFork min- ers would be bad: they frequently decide to intentionally orphan blocks in order to achieve greater rewards In addi- tion to creating uncertainty about when blocks are “safely” in the eventual longest chain, this decreases the effective hash power of the network and makes Bitcoin more prone to double spend attacks For cleanliness in formally defining LazyFork and other undercutting strategies, we introduce the notation Gapi = Rem(Mosti−1) − Rem(Mosti), the maximum transaction fees that a miner could include while mining on top of Mosti−1 to become the new Mosti LazyFork: Forks the blockchain if the head block is more valuable than the unclaimed transaction fees it leaves behind|,Non-data,71
 Only takes half of the possible transaction fees to prevent other lazy forkers from forking their block if Owner(Mostm H ) = m or Rem(Mostm H ) ≥ GapH Which Block: Mining(m) = Mostm H  else Mining(m) = Mostm H−1 How much: include Rem(Mining(m))/2,Non-data,71
| Publish(B)?: yes 53 Phase Three: Aggressive Undercutting Simulation result: increasingly aggressive under- cutting behavior evolves when miners strategize Once miners consider undercutting, they may also try to aggressively optimize the tradeoff between maximizing the transaction fees included in blocks they mine and minimizing the chance that their block will be undercut by other miners in the system (as opposed to using the less-principled reason- ing of LazyFork)|,Non-data,71
| We define these strategies so that when they are presented with Rem(Mining(m)) = x, they will authorize f (x) transactions, for some f (·) with f (x) ∈ [0, x] for all x, and call them forkers While in principle, forkers could consider going back sev- eral blocks to undercut, the strategies we study only consider mining on top of a block of height H or H − 1 Certainly, it would be an interesting direction for future work to see if any additional gains can be achieved by considering blocks of height H − 2 or less, but already we uncover interesting behavior when forkers go back just a single block A function forking miner looks at potential blocks at height H that they could extend, and within this set considers ex- tending only Mostm H , since it leaves the most remaining transaction fees|,Non-data,71
| If a miner indeed chooses to mine on top of Mostm H , we call this continuing They also look at poten- tial blocks of height H− 1, again considering only extending the block Mostm H−1 from this set If a miner indeed chooses to mine on top of Mostm H−1, we call this undercutting When deciding whether to continue or undercut, a forker simply observes that they will choose to claim f (Rem(Mostm H )) by H−1)), GapH} if they continuing, versus min{f (Rem(Mostm undercut (the min is taken because they must actually un- dercut in order to incentivize future miners to select their block)|,Non-data,71
| So for a given f , we can define: Valcont(f ) = f (Rem(Mostm Valunder(f ) = min{f (Rem(Mostm H )) H−1)), GapH} 160Figure 3: Normalized weights of different linear co- efficient function forking strategies over a series of games Strategies that are slightly more aggressive than the most common strategy perform the best and have their normalized weights increase This simulation had 500 miners, 20 strategies and 1000 blocks per game If Valcont(f ) > Valunder(f ), then more rewards can be achieved by continuing|,Non-data,71
| Otherwise, more rewards can be achieved through undercutting Formally, for any function f (·), this induces the following formal strategy: Function-Fork(f ): Always takes a certain function, f (·), of the possible transactions it could claim Always mines in the location to maximize the size of the block they would make, with the constraint that if they fork, they must undercut Which Block: if Owner(Mostm H ) = m or Valcont(f ) > Valunder(f ) Mining(m) = Mostm H |,Non-data,71
 else Mining(m) = Mostm H−1 How much: if Mining(m) = Mostm H include Valcont(f ) else include Valunder(f ) Publish(B)?: yes,Non-data,71
| Any reasonable choice of f (·) will be monotonically in- creasing, which means that f (Mostm H−1) will always be larger than f (Mostm H ), so the decision on whether to continue or undercut will come down to a comparison of f (Mostm H ) ver- sus GapH One natural family of f (·) to consider is linear functions (that is, f (x) = kx for some k ∈ [0, 1]) If we take a group of these strategies, and let non-atomic strategic miners learn over many games which perform best, we get the plot in Figure 3 What we see is the following: when the majority of miners are using Function-Fork(kx), the best response is to use Function-Fork(k(cid:48)x), for k(cid:48) a little smaller than Figure 4: This is a simulation of atomic miners undercutting more and more aggressively|,Non-data,71
| We see that more and more aggressive undercutters per- form better until at some point the potential re- ward of mining two blocks in a row dominates all else, and PettyCompliant goes back to being the strongest strategy, then the cycle repeats k, (ie to undercut just a little bit more aggressively)|,Non-data,71
| So eventually the smallest coefficient in our simulation becomes dominant If we instead consider atomic miners, we ob- serve the behavior in Figure 4: Once Function-Fork(kx) is dominant for small enough k, the pool of available trans- actions will grow pretty large (and stabilize around 1/k) Therefore, PettyCompliant miners have the potential to get a huge payoff if they get lucky and mine two blocks in a row (note that this probability is zero for non-atomic min- ers) As the dominant k gets smaller and smaller, eventually the huge reward from this unlikely event dominates, Petty- Compliant becomes the dominant strategy again, and the cycle repeats|,Non-data,71
| 54 An Undercutting Equilibrium Analytical result: An equilibrium exists where all miners use the same undercutting strategy It in- duces a growing backlog of transactions Linear function-forking is of course a natural class of strate- gies to consider, but our simulations in the previous section show that long-term behavior may be erratic if miners only consider these strategies|,Non-data,71
| Our goal in this section is to un- derstand what undercutting behavior is stable Our approach is to find a function f (·) such that Function- Fork(f ) is an equilibrium That is, as long as every other miner is using the strategy Function-Fork(f ), it is in your interest to do so as well In other words, we would like to find an f such that Function-fork(f ) is a best-response to the case when all other miners themselves use Function- fork(f )|,Non-data,71
| We provide now intuition for why the f (·) we present yields an equilibrium So what does it mean for a strategy to be a best-response to other miner behavior? Recall that a strategy proposes which block to extend, how many transaction fees to claim, and which blocks to publish as a function of the currently held information A strategy is a best response if it maxi- mizes the miner’s expected reward (taking into account fu- 161ture events, and in particular the probability that the cur- rent block is in the eventual longest chain) over all potential strategies that miner could have used instead In particular, a best-response must be at least as good as all other strate- gies that mine at the same location and publish the same blocks (but differ in which transactions to include)|,Non-data,71
| To get some intuition for what conditions a potential equi- librium must satisfy, let’s first consider the decision facing a miner who has already decided to continue on top of the longest chain and is just deciding how many transaction fees to include If F denotes the number of transaction fees in- cluded, define π(F, f, x) to be the probability that this block is included in the eventual longest chain, conditioned on including F BTC worth of transaction fees in the block, all other miners using strategy Function-Fork(f ), and x = Rem(Mostm H ) (note that π is well-defined) Then the miner’s expected reward, should they be fortunate enough to find a block right now would be F · π(F, f, x) A best-response would then be to include argmaxF≤x{F · π(F, f, x)} transaction fees|,Non-data,71
| The strategy Function-Fork(f ) would recommend including f (x) transaction fees So for Function-Fork(f ) to be a best-response to other min- ers using Function-fork(f ), it better be the case that f (x) ∈ argmaxF≤x{F · π(F, f, x)} for all x Note that this is a somewhat strong condition on f , as the fact that the other miners are using Function-fork(f ) affects π(F, f, x), whereas we also want this miner’s best response to have f (x) ∈ argmaxF≤x{F · π(F, f, x)} At this point, we show that there is a continuous and piece-wise differentiable function f (·) that satisfies this con- dition|,Non-data,71
| We also show that combined with the fact that f (·) is monotonically non-decreasing, this is sufficient for Function-fork(f ) to be an equilibrium under some as- sumptions (which we will discuss post-theorem) In the theorem statement below, W0 is the upper branch of the Lambert W function which satisfies W0(xex) = x for all x ∈ [−1/e,∞), and W0(x) ∈ [−1,∞) The “Furthermore|,Non-data,71
” portion of the theorem is proved by showing a connection between the number of backlogged transactions and an un- biased single-dimensional random walk Theorem 51,Non-data,71
| For any constant y ≤ 1/2 such that 2y − ln(y) ≥ 2,5 define: f (x) = x, ∀ x ≤ y f (x) = −W0(−yex−2y), ∀ y < x < 2y − ln(y) − 1 f (x) = 1, ∀ x ≥ 2y − ln(y) − 1 (1) (2) (3) Then it is an equilibrium for every miner to use the strategy Function-fork(f ) as long as: • Every miner is non-atomic • Miners may only mine on top of chains of length H or H − 1 Furthermore, in any such equilibrium, the expected number of backlogged transactions after n time steps is Θ( √ n) A proof of Theorem 5|,Non-data,71
|1 appears in the full version To un- derstand the impact of Theorem 51, first consider the block reward model With non-atomic miners, DefaultCompli- ant is trivially an equilibrium, and this result is robust to 5Such y exist|,Non-data,71
| This range is (0,≈ 02] Figure 5: Plot of the lambert function fork becom- ing the strongest strategy in a learning simulation This simulation had 200 miners, and 1,000 blocks per game|,Non-data,71
| These miners are non-atomic and there is no latency general models of latency (proof in the full version) But as we move to atomic miners, strategies like selfish mining arise and equilibria get messy (if they exist at all) Now, in the transaction-fee model, even when miners are non-atomic, equilibrium behavior is complex and undesir- able, as we have just shown|,Non-data,71
| Therefore, we should expect that analysis with atomic miners should conclude with even more chaos 55 Undercutting Non-strategic Miners Analytical and simulation result: even if 66% of miners remain default compliant, undercutting is profitable Our analysis and simulations in the previous sections as- sumed that all miners were strategic learners|,Non-data,71
| While we clearly learn a lot from this analysis, it is perhaps more realistic to also consider a setting where some miners will stubbornly (or honestly, depending on your perspective), continue running DefaultCompliant even if it is subop- timal If a large fraction of the miners are non-strategic, then function-forking becomes immediately less profitable, because only a small fraction of the network will actually mine on top of your block when you undercut In particu- lar, if 100% of other miners are non-strategic, undercutting serves no purpose In this section, we detail results from our simulation when varying fractions of miners are non-strategic|,Non-data,71
| In these sim- ulations, we find surprisingly that if we fix a fraction of the network to always mine DefaultCompliant, then after a series of games the strategy distribution of the remaining strategies resulting from our update rules will stabilize Fur- thermore, multiple strategies will be present in the stable distribution (ie, it would appear that this distribution of strategies form an equilibrium)|,Non-data,71
| Figure 6 shows a stacked area plot of our simulation results for equilibria at different fractions of miners refusing to abandon DefaultCompli- ant There are many interesting features of the plot, but 162we focus on one: even if the majority of miners choose to stay DefaultCompliant (and the rest strategize), then forking strategies start to become viable A theoretical analysis indeed predicts the continuing pres- ence of FunctionFork(x) until 2/3 of the miners remain DefaultCompliant To see this, imagine that every miner is the system is currently DefaultCompliant or Petty- Compliant, and we want to see if it is profitable for a Pet- tyCompliant miner to switch to FunctionFork(x)|,Non-data,71
| At any point in time, consider the current MostH Then if the miner runs PettyCompliant, they will always try to con- tinue, and will get Rem(MostH) should they find a block (because no one else in the network is undercutting) If in- stead they run FunctionFork(x), they will continue when- ever Rem(MostH) > GapH and undercut otherwise When they continue, they will always get Rem(MostH)|,Non-data,71
| When they undercut, they would include GapH transaction fees If the next miner to find a block is PettyCompliant (or this miner), then the undercut will be successful and the miner will receive GapH in rewards But if the next block is found by a DefaultCompliant miner, the undercut fails and they get nothing So if y is the fraction of the network that remains DefaultCompliant, we see that the expected reward obtained by FunctionFork(x) is proportional to:6 E[Rem(MostH) · I(Rem(MostH) > GapH)] + (1 − y) · E[GapH · I(GapH > GapH)] Finally, because Rem(MostH) and GapH are i|,Non-data,71
|id exponen- tial random variables with mean 1, we have that E[GapH · I(GapH > Rem(MostH))] = E[Rem(MostH)·I(Rem(MostH) > GapH)] = 3/4 Therefore, whenever y ≤ 2/3, the reward from FunctionFork(x) is at least one, and therefore it is a better choice than PettyCompliant (which gets expected reward exactly one)|,Non-data,71
| 6 SELFISH MINING WITH TRANSACTION FEES Selfish mining is a deviant strategy first identified by Eyal and Sirer [9] Essentially, a selfish miner chooses not to release blocks immediately upon being found, instead with- holding them in hopes of tricking the rest of the network into wasting their mining power mining blocks that will be orphaned Surprisingly, the selfish mining strategy performs even better in the transaction fees model than the block-reward model|,Non-data,71
| A priori, there’s no reason to expect this In this sec- tion we provide simulation results, along with some intuition and a theoretical analysis proving this Essentially what winds up happening is that while the selfish miner mines the same fraction of blocks in either reward model, the self- ish miner’s blocks will tend to be larger In the block-reward model, this doesn’t matter because all blocks are worth the same, but in the transaction fees model this means the self- ish miner gets greater reward|,Non-data,71
| 61 The Selfish Mining Strategy Analytical and simulation result: selfish mining performs slightly better in the transaction fee model 6E[X] denotes the expectation of the random variable X, and I(E) denotes the indicator random variable for event E (that is 1 when E occurs and 0 otherwise) Figure 6: This is a stacked area chart showing the equilibrium distributions of strategies covered thus far for a fraction of miners that will use the de- fault strategy regardless of its relative performance|,Non-data,71
| These simulations involved 200 miners, with 10,000 blocks per game We found that the strategies would reach an equilibrium around 120 games The goal of a miner employing the selfish mining strategy is to essentially trick the other miners in the Bitcoin network to mine on top of a block that will be orphaned By having other miners waste their power, the selfish miner is capa- ble of exaggerating their own portion of the overall network hash-rate|,Non-data,71
| Selfish miners do this by maintaining a chain in private that only they know about When the selfish miner initially finds a block, they will not announce their block to the rest of the network They will continue to mine on their private block, hoping to find a second block before the rest of the network finds a block If the miner succeeds, now they’re in a very strong posi- tion: they know of a block with height H + 2, whereas the rest of the network only knows a block of height H|,Non-data,71
| If the rest of the network finds the next block at height H + 1, the selfish miner can reveal their private chain and the public block will be immediately orphaned Of course, maybe the selfish miner will find the third block as well In this case, they’re in an even better position and can waste even more of the network’s power But the point is that with a lead of two or more, the selfish miner can guarantee that the rest of the network is wasting power|,Non-data,71
| Of course, the selfish miner might also fail to find a sec- ond block before the rest of the network finds their first In this case, they immediately release their block and hope that others hear about theirs first Obviously this is not ideal: had they released their block immediately, they could have guaranteed that it was heard about first So there’s a trade- off - withholding the block has a chance to give the selfish miner a private chain of length two or more, in which case the selfish miner benefits, but it also has the chance to cause their own block to be orphaned, resulting in less profits to the selfish miner|,Non-data,71
| 163Assuming the selfish miner has less than half of the overall hash power of the network, they will eventually need to pub- lish their private chain In order to maintain our focus on the difference between transaction fees and fixed block-rewards, we consider just “vanilla” selfish mining, although it is an interesting consideration for future work to consider selfish miners who also undercut, or various other generalizations (eg [7, 19, 22])|,Non-data,71
| Similarly to [9], we examine the potential rewards a selfish miner would receive assuming that the rest of the network is default mining In our analysis, we also use α to denote the fraction of the total mining power pos- sessed by the selfish miner, and γ to be the probability that in the event of a race (selfish miner is triggered to release a private block of length one) that ends with the honest portion of the network finding the next block, that the self- ish miner’s block is not orphaned We introduce notation Privatem to denote the height of the longest chain that m is aware of (at least as long as H, and possibly longer if m is keeping any blocks private) We also introduce notation Racingm i to be a boolean variable that is true iff there exist two blocks B1, B2 with Height(B1) = Height(B2) = i, and Owner(B1) = m (cid:54)= Owner(B2)|,Non-data,71
| In other words, Racingm i denotes whether or not there are two competing blocks of height i, one of which was produced by m Selfish-Mine: Selfish mining strategy from [9] This miner hides their blocks, which risks losing their first block, in order to try to get the rest of the network mining in a useless location, amplifying their own apparent hash power Which Block: Oldestm Privatem |,Non-data,71
| How much: include Rem(Mining(m)) Publish(B)?: if Height(B) = H yes elseif Racingm H , and Privatem = H + 1 yes else no|,Non-data,71
| Analysis We proceed now with an analysis of the rewards obtained in the transaction fee model by a selfish miner Parts will look similar to the analysis done in [9] For every infinitesi- mally small transaction fee that arrives, we wish to compute the probability that it winds up in a block mined by the self- ish miner|,Non-data,71
| Note that if the selfish miner just used default mining instead, this probability would be exactly α The determining factor in this probability will be the size of the selfish miner’s private chain To this end, let’s de- fine the following states (same states used in [9]), and we’ll compute this probability separately for each state • State 0: Everyone agrees on the longest chain — Racingm H = false|,Non-data,71
| • State i > 0: The selfish miner m has a private chain of length i — Privatem = H + i • State 0(cid:48): There are competing blocks of height H, one of which was produced by the selfish miner, and the selfish miner has no private blocks — Racingm and Privatem = H H = true Let fs denote the probability that a transaction winds up in a block mined by the selfish miner in the eventual longest chain, conditioned on the system being in state s when the transaction is announced We claim that we can compute these probabilities and do so below|,Non-data,71
| If we then define ps to be the probability that the system is in state s, we can then observe that the expected fraction of transaction fees s fs · ps Eyal and Sirer [9] have already computed ps for all s The values for ps are: claimed by the selfish miner is exactly(cid:80) p0 = p0(cid:48) = 1 − 2α 2α3 − 4α2 + 1 (1 − α)(α − 2α2) 2α3 − 4α2 + 1 α )i−1 pi = ( 1 − α α − 2α2 2α3 − 4α2 + 1 , i > 0 To complete the analysis, we just need to compute fs for each s The full version of the paper contains the derivation of fs for all s, which are stated below: f0 = α2 + α(1 − α) (α + γ(1 − α)) |,Non-data,71
| f0(cid:48) = α f1 = α + (1 − α)α = α(2 − α) fi = 1 − ((1 − α)i−1(1 − f0)) Finally, when α ∈ (0, |,Non-data,71
|5) and γ ∈ [0, 1], we show in the full version that the selfish miner’s rewards are given by Reward(α, γ) = 5α2 − 12α3 + 9α4 − 2α5 + γ(α − 4α2 + 6α3 − 5α4 + 2α5) 2α3 − 4α2 + 1 We make the following observations: • Simulation confirms the above analytical formula for Reward(α, γ) (Figure 7) • This function is extremely close to the reward function with block rewards ( α(1−α)2(4α+γ(1−2α))−α3 ) from [9] We find, numerically, that the absolute difference never exceeds 0026 in the region of interest 1−α(1+(2−α)α) • For 0 ≤ γ < 0|,Non-data,71
|55 (in particular, for γ = 0), for all α ∈ (0, 05), the reward is strictly greater in the transaction fee model than in the block reward model We provide some intuition for this last point First, it is clear that the fraction of blocks mined by the selfish vs|,Non-data,71
| default miners is independent of the reward model So the gap must come from the size of blocks found by the respec- tive miners Let’s assume just for the sake of example that we are in state 100 and the selfish miner has an α = 1/10 fraction of the mining power Almost certainly, the next un-orphaned block will be found by the selfish miner|,Non-data,71
| How long will it take for this block to be found? The answer is 164Figure 7: We see simulation matching the theory for selfish mining in a transaction based model for γ = 0, 05, and 1 approximately 10 time steps This is because while the en- tire network finds a block roughly every time step, because the selfish miner is the only miner extending his chain (and he mines at 1/10 the speed of the full network) it will take ten times as long|,Non-data,71
| What this means is that blocks found by the selfish miner while the selfish miner has a huge lead are disproportionately large compared to blocks found when the selfish miner has no lead (or a tiny lead) So even though the selfish miner wins the same fraction of blocks, some of these blocks are much larger than those won by the default miners A brief discussion The main point of this section is to highlight one example of surprising incentive issues that dif- fer between the transaction fees model and the block-reward model, not to argue that selfish mining becomes significantly better (the improvement is minor)|,Non-data,71
| Still, we wish to point out two possibly salient differences between selfish mining in the two models First, in the block-reward model, self- ish mining is actually not ever immediately profitable — it only becomes profitable once the difficulty readjusts to ac- count for the fact that the effective mining power in the network is lower This is because before the difficulty ad- justs, the selfish miner is literally just throwing blocks away, but tricking the rest of the network into throwing blocks away at a higher rate In the transaction fees model, selfish mining is immediately profitable — every transaction that arrives goes somewhere, so neither the selfish miner nor the default miners are throwing rewards away|,Non-data,71
| Note also that our analysis in no way requires the difficulty to adjust before it becomes accurate — our analysis would hold no matter how the difficulty of hash puzzles adjusted or didn’t adjust over time Moreover, if some of the rest of the network has switched to the PettyCompliant strategy, then the selfish miner’s block is actually more likely to win when a race is triggered (because it was mined earlier and therefore contains fewer transactions) So the existence of Petty- Compliant miners in the transaction fees regime indirectly improves Selfish-Mine’s performance by increasing γ Figure 8: We show the ideal cutoff factor, β, for a selfish miner with mining power α, and γ = 0|,Non-data,71
| 62 An Improved Selfish-Mine Analytical and simulation result: in the transac- tion fee model, selfish miners can make the de- cision whether to hide their first block based on the value of the block This improved selfish min- ing strictly and always outperforms both default mining and traditional selfish mining In this section we develop an improved selfish mining strategy|,Non-data,71
| Essentially, we observe that in the transaction fees model, a selfish miner has additional information when de- ciding whether to hide or publish their private chain (namely, how many transactions are included) We show that, for all α, γ < 1, our strategy strictly outperforms both default mining and “vanilla” selfish mining in the transaction fees model Our strategy will decide to hide only “small” blocks, with at most β (some cutoff parameter chosen by the strat- egy as a function of α, γ) transaction fees included, but will immediately publish any “large” blocks, with more than β transaction fees in order to avoid the risk of losing them Intuitively, imagine you are mining and find yourself solv- ing a new block immediately after a previous block was announced and before any new transactions have been an- nounced|,Non-data,71
| This block is literally worthless, so instead of pub- lishing, why not use it to try and selfish mine? There is no cost, but a positive probability that you build a lead of two, no matter your hash power Similarly, imagine instead that just by chance an hour goes by since the last block was found and you just solved a new block including all trans- actions that arrived during that period This block is worth roughly six “normal” blocks, so why risk losing it? Unless your hash power is very close to 50%, the expected gains from selfish mining are dwarfed by the possibility of losing this unusually wealthy block So the trick is just choosing the proper cutoff β as a function of your hash power α and network connectivity γ|,Non-data,71
| Note that Selfish-Mine(0) = DefaultCompliant, and that Selfish-Mine(∞) = Selfish-Mine So clearly, taking the optimal choice of β will result in a strategy that equals or outperforms both Using an analysis similar to that of Section 61, we are able to compute the expected reward achieved by a miner with an α fraction of the mining power, 165Figure 9: Theory matching simulation for a variety of cutoff thresholds for selfish mining, all with γ = 0|,Non-data,71
| The smaller cutoffs do better for a miner with a smaller hash-power (α) and the larger cutoffs do better with a larger hash-power Intuitively, this makes sense as a more powerful miner should be willing to risk a larger block to try to selfishly mine a γ success probability of winning a race, and using strat- egy Selfish-Mine(β) A derivation is included in the full version|,Non-data,71
| Selfish-Mine(β): An improvement to the selfish mining strategy, where the miner will chose to mine as a selfish miner or a default compliant miner based on the value of the block they risk losing Which Block: Oldestm Privatem  How much: include Rem(Mining(m)) Publish(B)? if Height(B) = H or Tx(B) ≥ β yes|,Non-data,71
| elseif Racingm H , and Privatem = H + 1 yes else no Reward(α, γ, β) = (cid:18) 1 + β(1 − α)2(1 − γ) eβ − 1 (cid:19) − 2α2 (cid:19) (cid:18) + 5α + (1 − α)2γ + 2α2 1 − 2α α(1 − 2α)(1 − e−β) 1 − 2e−βα − 3(1 − e−β)α2 × Figure 8 contains a plot showing the optimal choice of β as a function of α when γ = 0 A few noteworthy points from this plot: as α → 0, so does the optimal β|,Non-data,71
| As α → 1/2, the optimal β approaches ∞ Figure 9 plots our theoretical predictions against simulation results, confirming that the analysis is correct We conclude this section with Figure 10 plotting the (the- oretical) performance of default mining, selfish mining, and Figure 10: A selfish miner using the optimal cutoff outperforms both the original selfish mining proto- col and default mining for all values of α, with γ = 0 The simulation points confirm that the theory is ac- curate|,Non-data,71
| selfish mining with the optimal cutoff for a range of α and γ = 0 Note that in some ranges, the gains are quite signif- icant Specifically, when α = 1/3, both selfish mining and default mining achieve expected reward of ≈ 1/3, but selfish mining with the optimal cutoff achieves an expected reward of ≈ 38, a 13|,Non-data,71
|6% increase! 7 IMPACT ON BITCOIN AND LESSONS FOR CRYPTOCURRENCY DESIGN We have argued that deviant mining strategies in a transaction- fee regime could hurt the stability of Bitcoin mining and harm the ecosystem In a block chain with constant forks caused by undercutting, an attacker’s effective hash power is magnified because he will always mine to extend his own blocks whereas other miners are not unified This would make a “51%” attack possible with much less than 51% of the hash power|,Non-data,71
| Many other unanticipated side-effects may arise In the block size debate, it is frequently argued or assumed that space in the block chain will be a scarce resource and a market will emerge, with users being able to speed up the confirmation of a transaction by paying a sufficiently large transaction fee But if miners intentionally “leave money on the table” when solving blocks, as is the case in undercutting attacks, it breaks this assumption That is because under- cutting miners are not looking to maximize the transaction fee that they can claim, and don’t have a strong reason to prioritize a transaction with a high fee|,Non-data,71
|7 Put another way, the block size imposes a constraint on the total size of trans- actions in a block and the threat of being undercut imposes another constraint on the total fee The two interact in complex ways We believe that qualitatively our results will 7They do have a weak reason: miners benefit from creat- ing the smallest possible block for a given value of the to- tal transaction fee they seek to claim, since smaller blocks propagate faster through the network and are less likely to be orphaned 166continue to hold in a world where the available block size is much smaller than the demand, but quantitatively the im- pact of undercutting will be mitigated (see end of Section 3|,Non-data,71
|1) Still, it is an important direction for future research to understand this connection more rigorously Despite the variety of our results, we believe we have only scratched the surface of what can go wrong in a transaction- fee regime To wit: we have not presented an analysis of miners whose strategy space includes both undercutting and selfish mining, primarily due to the complexity of the result- ing models|,Non-data,71
 There has been scant attention paid to the transition to a transaction-fee regime The Nakamoto paper addresses it briefly: “The incentive can also be funded with transaction fees,Non-data,71
| Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transac- tion fees and be completely inflation free” [18] Similar com- ments on the Bitcoin Wiki and other places suggest that the community views the transition as unremarkable Some altcoins (Monero, Dogecoin) have even opted to hasten the block reward halving time Our results suggest a different view|,Non-data,71
| We see the block re- ward as integral to the stability of the mining game At a minimum, analyzing equilibria in the transaction-fee regime appears dramatically harder than in the block-reward regime, which is a cause for concern by itself The monetary infla- tion resulting from making the block reward permanent, as Ethereum does, may be a small price to pay to ensure the stability of a cryptocurrency 8|,Non-data,71
 ACKNOWLEDGMENTS [9] I Eyal and E G Sirer,Non-data,71
| Majority is not enough: Bitcoin mining is vulnerable In Financial Cryptography and Data Security, pages 436–454 Springer, 2014 [10] K|,Non-data,71
| Hill Bitcoin is not broken Forbes, 2013 http://www|,Non-data,71
forbescom/sites/kashmirhill/2013/11/ 06/bitcoin-is-not-broken/#55d4a8812568 [11] N Houy,Non-data,71
| The economics of bitcoin transaction fees Working Paper GATE 2014-07 halshs-00951358, 2014|,Non-data,71
| [12] B Johnson, A Laszka, J Grossklags, M|,Non-data,71
| Vasek, and T Moore Game-theoretic analysis of ddos attacks against bitcoin mining pools In Proceedings of the First Workshop on Bitcoin Research, 2014|,Non-data,71
| [13] J A Kroll, I C|,Non-data,71
| Davey, and E W Felten The economics of bitcoin mining, or bitcoin in the presence of adversaries|,Non-data,71
| In Proceedings of the Twelfth Annual Workshop on the Economics of Information Security (WEIS), 2013 [14] N Littlestone and M K|,Non-data,71
 Warmuth The weighted majority algorithm Inf Comput,Non-data,71
|, 108(2):212–261, 1994 [15] L Luu, J Teutsch, R|,Non-data,71
| Kulkarni, and P Saxena Demystifying incentives in the consensus computer In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2015|,Non-data,71
 [16] A Miller and R Jansen Shadow-bitcoin: scalable simulation via direct execution of multithreaded applications,Non-data,71
| In Proceedings of the eighth workshop on Cybersecurity Experimentations and Test (CSET), 2015 We are extremely grateful to Jiechen Chen, Kira Goldner, Anna Karlin, and Rainer B ̈ohme for very detailed feedback on an earlier draft of this paper [17] M M ̈oser and R|,Non-data,71
| B ̈ohme Trends, tips, tolls: A longitudinal study of bitcoin transaction fees In Workshop on Bitcoin Research, pages 19–33, 2015 [18] S|,Non-data,71
| Nakamoto Bitcoin: A peer-to-peer electronic cash system, 2008 [19] K Nayak, S|,Non-data,71
| Kumar, A Miller, and E Shi Stubborn mining: Generalizing selfish mining and combining with an eclipse attack|,Non-data,71
| In IEEE European Symposium on Security and Privacy (EuroS&P), 2016 [20] R Peter A transaction fee market exists without a block size limit|,Non-data,71
 2015 [21] M Rosenfeld Analysis of bitcoin pooled mining reward systems,Non-data,71
| CoRR, abs/11124980, 2011 [22] A Sapirshtein, Y|,Non-data,71
| Sompolinsky, and A Zohar Optimal selfish mining strategies in bitcoin In Financial Cryptography and Data Security, 2016|,Non-data,71
| [23] M Vasek, M Thornton, and T Moore|,Non-data,71
| Empirical analysis of denial-of-service attacks in the bitcoin ecosystem In Proceedings of the First Workshop on Bitcoin Research, 2014 9 |,Non-data,71
|ABSTRACT Proof of Work (PoW) powered blockchains currently account for more than 90% of the total market capitalization of existing digi- tal cryptocurrencies Although the security provisions of Bitcoin have been thoroughly analysed, the security guarantees of variant (forked) PoW blockchains (which were instantiated with different parameters) have not received much attention in the literature In this paper, we introduce a novel quantitative framework to analyse the security and performance implications of various con- sensus and network parameters of PoW blockchains Based on our framework, we devise optimal adversarial strategies for double- spending and selfish mining while taking into account real world constraints such as network propagation, different block sizes, block generation intervals, information propagation mechanism, and the impact of eclipse attacks|,Non-data,73
| Our framework therefore allows us to capture existing PoW-based deployments as well as PoW blockchain variants that are instantiated with different parameters, and to objec- tively compare the tradeoffs between their performance and security provisions 1 INTRODUCTION Since its inception in 2009, Bitcoin’s blockchain has fueled inno- vation and a number of novel applications, such as smart contracts, have been designed to take advantage of the blockchain Bitcoin has been forked a number of times in order to fine-tune the con- sensus (i|,Non-data,73
|e, the block generation time and the hash function), and the network parameters (eg, the size of blocks and the information propagation protocol) and to increase the blockchain’s efficiency|,Non-data,73
| For instance, Litecoin and Dogecoin—Bitcoin’s most prominent forks—reduce the block generation time from 10 to 25 and 1 minute Parallel to these efforts, alternative decentralised blockchain-based networks (such as Ethereum) emerged with the ambition to optimize the consensus and network parameters and to ease the deployment of decentralised applications on top of the blockchain Although a number of consensus protocols (PBFT [5], Proof of Stake [30], Proof of Elapsed Time [22]) have been proposed, most Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page|,Non-data,73
| Copyrights for components of this work owned by others than the author(s) must be honored Abstracting with credit is permitted To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee Request permissions from permissions@acm|,Non-data,73
|org CCS’16, October 24 - 28, 2016, Vienna, Austria c(cid:13) 2016 Copyright held by the owner/author(s) Publication rights licensed to ACM ISBN 978-1-4503-4139-4/16/10|,Non-data,73
   $1500 DOI: http://dx,Non-data,73
doiorg/101145/29767492978341 existing blockchains leverage the computationally expensive Proof of Work (PoW) consensus mechanism—which currently accounts for more than 90% of the total market capitalization of existing digital cryptocurrencies [6],Non-data,73
| While the security provisions of Bit- coin have been thoroughly analysed [15, 23, 31, 33], the security guarantees of variant PoW blockchains have not received much attention in the literature Recent studies hint that the performance of PoW based blockchains cannot be enhanced without impacting their security However, the relationship between performance and security provisions of PoW blockchains has so far not been studied in much detail In this paper, we address this problem and provide a novel quan- titative framework to analyse the security and performance im- plications of various consensus and network parameters of PoW blockchains|,Non-data,73
| Leveraging our framework, we capture the security properties of existing PoW instantiations (eg, Bitcoin, Ethereum, Litecoin, and Dogecoin) as well as other possible instantiations subject to different consensus and network parameters Our framework (cf|,Non-data,73
| Figure 1) consists of two key elements: (i) a blockchain instance and (ii) a blockchain security model A blockchain instance is a PoW blockchain instantiated with a given set of consensus and network parameters, such as network delays, block generation times, block sizes, information propagation mech- anisms, etc For example, Bitcoin, Litecoin, and Ethereum corre- spond to 3 different blockchain instances To realistically capture any other blockchain instance, we design a simulator that mim- ics the blockchain consensus and network layer by implementing advertisement-based information propagation, unsolicited block pushes, the relay network, the sendheader propagation mechanism, among others|,Non-data,73
|1 The main output of the blockchain instance is the (measured or simulated) stale (orphan) block rate, which is fed as input into our security model On the other hand, our security model is based on Markov Decision Processes (MDP) for double-spending and selfish mining and allows us to reason about optimal adver- sarial strategies while taking into account the adversarial mining power, the impact of eclipse attacks, block rewards, and real world network and consensus parameters—effectively captured by the stale block rate Given the current discussions in the Bitcoin community about a suitable maximum block size that ensures the scalability and growth in the system [1], our work provides a way to holistically compare the security and performance of PoW blockchains when subject to different parameters—-including the block size For instance, we find that increasing the block size from the current Bitcoin 1Our simulator is accessible at http://arthurgervais|,Non-data,73
githubio/ Bitcoin-Simulation/indexhtml 32,Non-data,73
|1 Consensus Layer The proof of work (PoW) consensus mechanism is the widest deployed consensus mechanism in existing blockchains PoW was introduced by Bitcoin [28] and assumes that each peer votes with his “computing power” by solving proof of work instances and constructing the appropriate blocks Bitcoin, for example, employs a hash-based PoW which entails finding a nonce value, such that when hashed with additional block parameters (eg|,Non-data,73
|, a Merkle hash, the previous block hash), the value of the hash has to be smaller than the current target value When such a nonce is found, the miner creates the block and forwards it on the network layer (cf Section 22) to its peers|,Non-data,73
| Other peers in the network can verify the PoW by computing the hash of the block and checking whether it satisfies the condition to be smaller than the current target value Block interval: The block interval defines the latency at which content is written to the blockchain The smaller the block interval is, the faster a transaction is confirmed and the higher is the probability of stale blocks The block interval adjustment directly relates to the difficulty change of the underlying PoW mechanism|,Non-data,73
| A lower difficulty results in a larger number of blocks in the network, while a higher difficulty results in less blocks within the same timeframe It is therefore crucial to analyse whether changing the difficulty affects the adversarial capabilities in attacking the longest chain— which is the main pillar of security of most PoW-based blockchains This also implies the adjustment of the required number of con- firmations that a merchant should wait in order to safely accept transactions (and avoid double-spending attacks) (cf Section 3)|,Non-data,73
 211 PoW security PoW’s security relies on the principle that no entity should gather more than 50% of the processing power because such an entity can effectively control the system by sustaining the longest chain We now briefly outline known attacks on existing PoW-based blockchains,Non-data,73
| First, an adversary can attempt to double-spend by using the same coin(s) to issue two (or more) transactions—thus effectively spend- ing more coins than he possesses Recent studies have shown that accepting transactions without requiring blockchain confirmations is insecure [23] The more confirmations a transaction obtains, the less likely this transaction will be reversed in the future Second, miners might attempt to perform selfish mining [15] at- tacks in order to increase their relative mining share in the blockchain, by selectively withholding mined blocks and only gradually pub- lishing them [15, 32]|,Non-data,73
| Recent studies show that, as a result of these attacks, a selfish miner equipped with originally 33% mining power can effectively earn 50% of the mining power Double-spending attacks and selfish mining can be alleviated if all nodes in the blockchain system are tightly synchronised Note that, in addition to network latency, synchronisation delays can be aggravated due to eclipse attacks [18,19] where an adversary creates a logical partition in the network, ie|,Non-data,73
|, provides contradicting block and transaction information to different blockchain network nodes 22 Network Layer On the network layer, we identify two main parameters that are of particular importance for PoW-based blockchains, namely: the block size, and the information propagation mechanism 2|,Non-data,73
|21 Block size The maximum block size indirectly defines the maximum number of transactions carried within a block This size therefore controls the throughput attained by the system Large blocks incur slower propagation speeds, which in turn increases the stale block rate (and weaken the security of the blockchain as stated earlier)|,Non-data,73
| Figure 1: Components of our quantitative framework transaction load (average 05MB) to up to 4 MB, does not signifi- cantly affect the selfish mining and double-spending resilience of the blockchain—provided that the block propagation mechanism en- sures a low stale block rate We summarize our findings as follows|,Non-data,73
| Summary of findings • We show that selfish mining is not always a rational strat- egy To capture rational adversaries, we therefore quantify the double-spending resilience of PoW blockchains and objec- tively compare the security of different PoW blockchains with respect to the required number of transaction confirmations By doing so, we provide merchants with the knowledge to decide on the required number of confirmations for a given transaction value to ensure security against double-spending • Our results show that, due to the smaller block rewards and the higher stale block rate of Ethereum2 compared to Bitcoin (from 0|,Non-data,73
|41% to 68% due to the faster confirmation time), Ethereum (block interval between 10 and 20 seconds) needs at least 37 confirmations to match Bitcoin’s security (block interval of 10 minutes on average) with 6 block confirmations against an adversary with 30% of the total mining power Similarly, Litecoin would require 28, and Dogecoin 47 block confirmations respectively to match the security of Bitcoin • We show that the higher the block reward of a blockchain (in e|,Non-data,73
|g, USD) the more resilient it is against double-spending • Finally, we analyze the impact of changing the block size and/or the block interval on selfish mining and double-spending Our results surprisingly show that setting the block size to an average 1 MB, and decreasing the block interval time to 1 minute do not considerably penalize security|,Non-data,73
| Our results therefore suggest that PoW blockchains can attain an effec- tive throughput above 60 transactions per second (tps) (which implies that the current throughput of Bitcoin of 7 tps can be substantially increased) without compromising the security of the system The remainder of the paper is organized as follows In Section 2, we overview the basic concepts behind PoW blockchain In Sec- tion 3, we introduce our MDP model to quantitatively analyze the security of PoW blockchains|,Non-data,73
| In Section 4, we present our simulator and evaluate the security and performance of a number of variant PoW-based blockchain instances In Section 5, we overview related work, and we conclude the paper in Section 6 2 BACKGROUND In this section, we briefly recap the operations of the consensus layer and the network layer of existing PoW blockchains|,Non-data,73
| 2We show that, contrary to common beliefs, Ethereum does not apply GHOST’s principle to include the contributions of “uncles” in the main chain and therefore currently resembles Bitcoin PoW BlockchainOptimal adversarial strategyStale block rateBlock propagation timesThroughputConsensus & NetworkParametersSecurity ProvisionsStaleblock rateSecurityParametersSecurity Model4Information propagation mechanism 222 The block request management system dictates how information is delivered to peers in the network|,Non-data,73
| Eventually, since all peers are expected to receive all blocks, a broadcast protocol is required The choice of the underlying broadcast protocol clearly impacts the robustness and scalability of the network (cf Section 4) In what follows, we briefly describe well-known network layer implementa- tions of existing PoW-based blockchains|,Non-data,73
| Advertisement-based information dissemination: Most PoW blockchains propagate messages with the help of an advertisement- based request management system If node A receives information about a new object (eg, a transaction or a block) from another node, A will advertise this object to its other connections (e|,Non-data,73
|g node B) by sending them an inv message (the hash and type of the advertised object) Only if node B has not previously received the advertised object, B will request the object from A with a getdata request Node A will subsequently respond with a Bitcoin object, e|,Non-data,73
|g, the contents of a transaction or a block Send headers: Peers can alternatively issue a sendheaders mes- sage in order to directly receive block headers in the future from their peers—skipping the use of inv messages This reduces the latency and bandwidth overhead of block message propagation and is adopted by Bitcoin since version 0|,Non-data,73
|12 Unsolicited block push: This mechanism enables miners to broad- cast their generated blocks without advertisement (ie, since they mined the block)|,Non-data,73
| Note that this push system is recommended3, but not implemented in Bitcoin Relay networks: Relay networks [7] primarily enhance synchro- nization of miners that share a common pool of transactions Trans- actions are typically only referenced in relayed blocks with a trans- action ID (2 bytes per transaction instead of an average of 250 bytes per transaction) As a consequence, the resulting block size is smaller than the regular block (cf|,Non-data,73
| Bitcoin Relay Network [7]) Hybrid Push/Advertisement Systems: A number of systems, such as Ethereum, combine the use of push and advertisement dissemina- √ tion Here, a block is directly pushed to a threshold number of peers (eg|,Non-data,73
|, Ethereum directly pushes blocks to n peers, where n is the total number of neighbors connected to the peer) Concurrently, the sender advertises the block hash to all of its neighbors 23 Stale blocks Stale blocks refer to blocks that are not included in the longest chain, e|,Non-data,73
|g, due to concurrency, conflicts Stale blocks are detrimen- tal to the blockchain’s security and performance because they trigger chain forks—an inconsistent state which slows down the growth of the main chain and results in significant performance and security implications On the one hand, stale blocks increase the advantage of the adversary in the network (e|,Non-data,73
|g, double-spending) On the other hand, stale blocks result in additional bandwidth overhead and are typically not awarded mining rewards (except in Ethereum) In an experiment that we conducted, we measure the stale block rate in the Bitcoin (block generation time = 10 minutes, average block size = 534|,Non-data,73
|8KB), Litecoin (block generation time = 25 min- utes, average block size = 611KB) and Dogecoin (block generation time = 1 minute, average block size = 8KB) network All three blockchains rely on a PoW-based blockchain (with different gen- eration times) and the same information propagation system (with different block sizes)|,Non-data,73
 We crawled the available nodes in Litecoin and Dogecoin [3] in 3https://bitcoinorg/en/developer-reference#data-messages Block interval Public nodes Mining pools tM BP rs sB Bitcoin 10 min 6000 16 87 s [9] 041% 534,Non-data,73
8KB 611KB Litecoin Dogecoin Ethereum 25 min 800 12 102 s 0,Non-data,73
273% 0619% 1 min 600 12 085 s 10-20 seconds 4000 [12] 13 05 - 0,Non-data,73
|75 s [13] 68% 15KB 8KB Table 1: Comparison of different Bitcoin forks, Ethereum and the impact of parameter choices on the network propagation times Stale block rate (rs) and average block size (sB) were measured over the last 10000 blocks|,Non-data,73
| tM BP stands for median block propagation time February 2016 and found about 800 and 600 IP addresses respec- tively We then measured the block propagation times by registering the times at which we receive the block advertisements from a par- ticular block from all our connections in the respective network [10] We operated one node for Litecoin and Dogecoin, which we con- nected to 340 and 200 peers, respectively|,Non-data,73
| Once one of these peers advertises block information in form of either (i) a new hash of a block (inv message) or (ii) a block header (headers message), we registered the time this block information appeared Every sub- sequent reception of a particular piece of block information then provides information about the propagation of the block Our results (cf Table 1) suggest that the stale block rate indeed largely depends on the block interval and the block sizes|,Non-data,73
| For instance, unlike Dogecoin and Litecoin, Bitcoin features larger block sizes due to a higher transaction load (of up to 1MB which results in a higher stale block rate (041% vs 0273%)—although the block interval of Bitcoin is 4 times longer than that of Litecoin|,Non-data,73
| Moreover, the stale block rate differences between Litecoin and Dogecoin are mainly due to the difference in the block interval (25 minutes vs 1 minute), since their average block sizes are comparable (611KB and 8KB)|,Non-data,73
| Given a confirmation time reduction of 60%, the stale block rate increased by 127% from Litecoin to Dogecoin Notice that in Ethereum, uncle blocks correspond to stale blocks that are referenced in the main chain The uncle block rate in Ethereum is almost 68%, compared to a stale block rate of 0|,Non-data,73
|41% in Bitcoin In Section 3, we study the impact of the stale block rate on the security of PoW blockchains 3 POW SECURITY MODEL In this section, we introduce our blockchain security model that we leverage to quantify the optimal adversarial strategies for double- spending and selfish mining|,Non-data,73
| We then use these strategies as a basis to compare the security provisions of PoW-based blockchains when instantiated with different parameters 31 Security Model Our model extends the Markov Decision Process (MDP) of [32] to determine optimal adversarial strategies, and captures: Stale block rate The stale block rate rs allows us to account for different block sizes, block intervals, network delays, infor- mation propagation mechanisms and network configuration (eg|,Non-data,73
|, number of nodes) adversary (the rest is controlled by the honest network) Mining power α is the fraction of the total mining power of the Mining costs The adversarial mining costs cm ∈ [0, α] correspond to the expected mining costs of the adversary (ie|,Non-data,73
|, total min- ing costs such as hardware, electricity, man-power) and are expressed in terms of block rewards For example, if cm = α, 5the mining costs of the adversary are equivalent to its min- ing power times the block reward, ie, the mining costs are covered exactly by the earned block revenue in honest mining|,Non-data,73
| The number of block confirmations k This corresponds to the num- ber of blocks that need to confirm a transaction, such that a merchant accepts the transaction Propagation ability The propagation parameter γ captures the con- nectivity of the adversary within the network (ie, captures the fraction of the network that receives the adversary’s blocks in the case when the adversary and the honest miner release their blocks simultaneously in the network)|,Non-data,73
| The impact of eclipse attacks Our model accounts for eclipse at- tacks Here, we assume that the miners of the honest network are affected by the stale block rate, while the adversary and the colluding eclipsed victims do not mine stale blocks This is due to the fact that the adversary can use any mined blocks for an attack and effectively only has a small chance of min- ing a stale block after adopting the honest chain Therefore, in practice, the adversary exhibits a significantly lower real stale block rate than the honest network|,Non-data,73
| The honest network features propagation and validation delays—hence it will wit- ness a higher stale block rate Note that the blocks found by the eclipsed victim can also count towards the private chain of the adversary We contrast this to existing models, such as Sapirshtein et al’s [32], which only focus on selfish mining and cannot capture different blockchain instances (with various stale block rates and confirma- tions) and real-world parameters such as network delays|,Non-data,73
| To analyze optimal double-spending strategies, we define the double-spending amount vd that corresponds to the minimum trans- action value that makes double-spending more profitable than honest mining We argue that vd emerges as a robust metric to quantify secu- rity under double-spending attacks Namely, if the reward of honest mining is larger than that of dishonest behaviour, merchants can safely accept a payment transaction of value vd (since such a value is considered secure, eg|,Non-data,73
|, based on a given confirmation number) If however, adversarial behaviour is financially more rewarding, a merchant should be aware of the associated double-spending risks and of the related incentives of miners We capture the blockchain model using a single-player decision problem M := (cid:104)S, A, P, R(cid:105) where all other participants follow the standard protocol, and S corresponds to the state space, A to the action space, P to the stochastic transition matrix, and R to the reward matrix We instantiate M as a Markov Decision Process (MDP) as outlined in Section 3|,Non-data,73
|2 and 33 In our model, the following actions are available to the adversary: Adopt The adversary accepts the chain of the honest network, which effectively corresponds to a restart of the attack This action is appropriate if the adversary deems that the likelihood to win over the honest chain is small|,Non-data,73
 Override The adversary publishes one block more than the honest chain has and consequently overrides conflicting blocks This happens when the adversary’s secret chain is longer than the currently known public chain (ie la > lh) and it is optimal for the adversary to publish lh + 1 of his blocks to replace the honest network’s chain with his own,Non-data,73
| If the adversary exploits the mining power of the victim, the adversary might use be blocks from the victim for an override action Match The adversary publishes as many blocks as the honest chain has, and triggers an adoption race between the two chains instead of overriding the honest chain Wait The adversary continues mining on its hidden chain until a block is found Exit This action is only relevant when studying double-spending as it corresponds to a successful double-spending with k con- firmations and is only feasible if la > lh and la > k|,Non-data,73
| The state space S is defined as a four-tuple of the form (la, lh, be, fork), where la and lh represent the length of the adversarial and honest chain respectively, be the blocks mined by the eclipsed victim, and fork can take three values, irrelevant, relevant and active: relevant The label relevant signifies that (i) the last block has been found by the honest network, and (ii) if la ≥ lh the match action is applicable A state of the form (la, lh − 1, be,·) for instance results in (la, lh, be, relevant) irrelevant When the adversary found the last block, the previous block has likely already reached the majority of the nodes in the network The adversary is therefore not able to perform a match action|,Non-data,73
| A state of the form (la−1, lh, be,·) for instance results in (la, lh, be, irrelevant) active The state is described with the label active, if the adversary performed a match action, ie, the network is currently split and in process of determining the longest chain|,Non-data,73
| In our model, every state transition (except exit) corresponds to the creation of a block Consequently, a state transition implies a reward for the honest network, the adversary, or the eclipsed victim Given the adversarial mining power α, the initial state (0, 0, 0, irrelevant) transitions to (1, 0, 0, irrelevant) with probability α, ie|,Non-data,73
|, the adversary found one block If the honest network finds a non-stale block, the resulting state is (0, 1, 0, relevant) On the other hand, if the honest network’s block results in a stale block, the state remains (0, 0, 0, irrelevant) since a stale block does not count towards the longest chain The last case accounts for the eclipsed victim which finds a block with probability ω, resulting in state (1, 0, 1, irrelevant)|,Non-data,73
| Selfish Mining vs Double-spending In this work, we consider double-spending and selfish mining independently, since selfish mining is not always a rational strategy: the objective of selfish mining is to increase the relative share of the adversarial blocks committed to the main chain, while in double- spending the adversary aims to maximize his absolute revenue Namely, as long as the difficulty of a PoW blockchain does not change (e|,Non-data,73
|g Bitcoin’s difficulty changes only once every two weeks), selfish mining yields fewer block rewards than honest min- ing In honest mining, the adversary is rewarded for every mined block, while he will lose any previously mined blocks when adopt- ing the main chain in selfish mining Since the adversary has less mining power than the honest network, he has a high probability of falling behind the main chain, causing him to adopt the main chain when he has no significant chance of catching up—which in turn leads to lost block rewards|,Non-data,73
| For instance, following our optimal selfish mining strategy (cf Section 32), an adversary with 30% of the mining power earns 209 block rewards on average in a duration where 1000 blocks are mined by the whole network (as opposed to 300 for honest mining) Similarly, Eyal and Sirer’s [15] strategy yields on average 205|,Non-data,73
|80 blocks rewards Eclipse attacks In an eclipse attack, a fraction ω of the overall mining power is eclipsed [19, 29] from receiving information from the honest network Here, a number of eclipse attack variants arise: No eclipse attack This case is captured in our model if ω = 0|,Non-data,73
| 6Isolate the victim This is captured implicitly in our model Namely, this corresponds to a decrease of the total mining power and thus an increase of the attacker mining power to α(cid:48) = α 1−ω  Exploit the eclipsed victim Here, the adversary exploits the vic- tim’s mining power ω and uses it to advance his private chain This is the most likely choice of a rational adversary when performing double-spending attacks|,Non-data,73
| In this case, we assume that the victim is fully eclipsed from the network and does not receive/send blocks unless permitted by the adversary [19,29] 32 Selfish Mining MDP Our goal is to find the optimal adversarial strategy for selfish mining Recall that the objective of the adversary in selfish mining is not to optimise the absolute reward, but to increase the share of blocks that are included in the chain accepted by the network|,Non-data,73
| We capture this by optimising the relative revenue rrel as defined in Equation 1, where rai and rhi are the rewards in step i for the adversary and the honest network, respectively: (cid:20) (cid:80)n (cid:80)n rrel = E lim n→∞ i=1 rai i=1(rai + rhi ) (cid:21) (1) Since an adversary aims to increase his relative reward rrel (Equa- tion 1) in selfish mining, as opposed to the absolute reward, the single-player decision problem cannot be modelled directly as an MDP, since the reward function is non-linear In order to trans- form the problem into a family of MDPs, we adapt the technique of Sapirshtein et al’s [32], which we describe below We assume that the value of the objective function (i|,Non-data,73
|e, the op- timal relative reward) is rho and define for any ρ ∈ [0, 1] the transformation function wρ : N2 → R with the adversarial reward ra and the reward of the honest network rh in Equation 2 wρ(ra, rh) = (1 − ρ) · ra − ρ · rh (2) This results in an infinite state MDP Mρ = (cid:104)S, A, P, wρ(R)(cid:105) for each ρ that has the same action and state space as the original decision problem and the same transition matrix but the reward matrix is transformed using wrho The expected value of such an MDP under policy π is then defined by vπ ρ in Equation 3, where ri(π) is the reward tuple in step i under policy π|,Non-data,73
| (cid:34) n(cid:88) i=1 ρ = E vπ lim n→∞ 1 n wρ(ri(π)) (cid:35) The expected value under the optimal policy is then given : (cid:8)vπ ρ (cid:9) v ∗ ρ = max π∈A We base our method to optimise rrel on the following proposi- tions [32]: ρ = 0 for some ρ ∈ [0, 1], then an optimal policy π∗ in 1 If v∗ the transformed MDP Mρ also maximises rrel and rrel = ρ 2 v∗ ρ is monotonically decreasing in ρ|,Non-data,73
| Since standard MDP solvers are not able to solve infinite state MDPs, we restrict the state space of our family of MDPs by only allowing either chain to be of length at most c, resulting in a finite state MDP M c ρ If either chain reaches length c, the adversary is only allowed to perform the override or adopt action This gives a lower bound for the optimal value of the infinite state MDP Intuitively, one can reason about the correctness of the first propo- sition as follows for the bounded single-player decision problem|,Non-data,73
