RTRlib: An Open-Source Library in C for

RPKI-based Preﬁx Origin Validation

Matthias Wählisch

Freie Universität Berlin

waehlisch@ieee.o.rg

Hamburg University of Applied Sciences

Fabian Holler

mail@fholler.de

Thomas C. Schmidt

Hamburg University of Applied Sciences

t.schmidt@ieee.org

Jochen H. Schiller

Freie Universität Berlin

jochen.schiller@fu-berlin.de

Abstract

A major step towards secure Internet backbone routing
started with the deployment of the Resource Public Key
Infrastructure (RPKI). It allows for the cryptographic
strong binding of an IP preﬁx and autonomous systems
that are legitimate to originate this preﬁx. A fundamen-
tal design choice of RPKI-based preﬁx origin validation
is the avoidance of cryptographic load at BGP routers.
Cryptographic veriﬁcations will be performed only by
cache servers, which deliver valid AS/preﬁx mappings
to the RPKI-enabled BGP router using the RPKI/RTR
protocol.

In this paper, we give ﬁrst insights into the additional
system load introduced by RPKI at BGP routers. For this
purpose, we design and implement a highly efﬁcient C li-
brary of the RPKI/RTR router part and the preﬁx origin
validation scheme.
It fetches and stores validated pre-
ﬁx origin data from an RTR-cache and performs origin
veriﬁcation of preﬁxes as obtained from BGP updates.
We measure a relatively small overhead of origin vali-
dation on commodity hardware (5% more RAM than re-
quired for full BGP table support, 0.41% load in case of
≈ 92,000 preﬁx updates per minute), which meets real-
world requirements of today.

1

Introduction

The current Internet backbone is quite threatened by mis-
conﬁgurations as well as intended attacks such as pre-
ﬁx hijacks. Both lead to disturbances on the BGP layer.
A common threat is the incorrect announcement of the
origin autonomous system (AS). Several prominent ex-
amples are known like the recent (April 2010) cause of
redirection of 15% US trafﬁc to China due to incorrectly
announced IP preﬁxes [1, 243 et seqq.].

Securing BGP has been discussed in the research com-
munity since more than one decade [2]. Current ef-
forts of the Secure-Inter Domain (SIDR) working group

within the IETF lie in the standardization of a set of pro-
tocols to enhance the security of BGP. They focus on
solving two problems: enable a router (a) to verify that
a BGP update did originate at an authorized AS and (b)
to verify that the AS path within the BGP update corre-
sponds to the route traversed. Even though the latter is far
from global deployment, ﬁrst steps have been performed
to tackle the ﬁrst challenge.

An integral part for securing BGP is the Resource Pub-
lic Key Infrastructure (RPKI) [3]. The RPKI is a robust
security framework. It consists of a distributed repository
that stores certiﬁcates and Route Origin Authorization
(ROAs). ROAs provide a secure binding between an IP
preﬁx and an AS that is allowed to originate that preﬁx.
For a nice overview on this topic we refer to [4]. RPKI-
enabled routers do not store ROAs itself but only the val-
idated content of these (ROA) authorities. The valida-
tion of ROAs will be performed by trusted cache servers,
which will be deployed at the network operator site. The
RPKI/Router (or short RPKI/RTR) protocol [5] deﬁnes
a standard mechanism to maintain the exchange of the
preﬁx/origin AS mapping between the cache server and
routers. In combination with a BGP preﬁx origin valida-
tion scheme [6] a router is able to verify received BGP
updates without suffering from cryptographic complex-
ity.

In this paper, we study the overhead introduced by
RPKI-based preﬁx origin validation at routers. Cur-
rent implementations of the RPKI/RTR protocol do not
allow for detailed analysis as they are either closed
source or have not been developed for real deployment.
To achieve our goal, we carefully designed and imple-
mented a lightweight C library that implements (a) the
client part of the RPKI/Router protocol and (b) preﬁx
origin validation. This library, called RTRlib, provides
functions to establish a connection to a single or mul-
tiple trusted caches and to determine the correctness of
a preﬁx/origin AS mapping. We apply this library in
experiments and real-world measurements and give ﬁrst

1

insights into the load behaviour of RPKI-enabled com-
modity routers. Based on our analysis we show that the
overhead of RPKI-based origin validation at BGP routers
is negligible for current and increasing update rates.

Built as a library RTRlib can be included in vari-
ous application scenarios beyond this work.
It is use-
ful for researchers, network operators, and for develop-
ers of routing software. Researchers may use the library
to get a better understanding of preﬁx origin validation
and identify improvements (e.g., performance evalua-
tion). Network operators may apply the RTRlib to de-
velop monitoring tools (e.g., to detect RPKI misconﬁgu-
ration in ’real-time’). Developers can integrate the RTR-
lib into a BGP daemon to extend their implementation
towards RPKI. We argue that in particular the research
community beneﬁts from an implementation which is
suitable for both, experiments and real-world deploy-
ment as this allows for comparable and realistic analysis.
The remainder of this paper is structured as follows.
Section 2 presents the design and architecture of the
RTRlib. Section 3 analyses characteristic performance
aspects. In Section 4 we give a short overview about re-
lated work. We conclude in Section 5.

2 RTRlib

preﬁx

origin

veriﬁcation,

independent

For RPKI-based
the
RPKI/RTR protocol needs to be implemented on
routers. The RTRlib assembles the required functions
as an external
library, which simpliﬁes
code reuse. Existing BGP daemons can be extended by
simply integrating the library or parts of it. We provide
a Quagga extension, which allows for RFC-compliant
preﬁx origin validation. The same code base may also
be used to build tools for researchers or ISPs. All
source code of the RTRlib project is released under
GNU LGPL. In addition to the basic protocol functions,
the source code package includes command line tools
to get quickly in touch with RPKI/RTR protocol and
debug origin validation. The RTRlib is available at
http://rpki.realmv6.org/.

2.1 Design
Our implementation of the RPKI/RTR protocol considers
the subsequent design goals:

Broad system integration The library shall run on dif-
ferent system environments and thus minimize depen-
dencies on speciﬁc operating system calls and third party
tools. We implement the library in C because several
BGP daemons are written in C (e.g., BIRD, Quagga) or
C++ (e.g., XORP). In contrast to C++, C-functions can

2

be invoked or adopted into other C/C++ programs with-
out modiﬁcations. To facilitate the smooth migration to
a variety of operating systems, our library is based on
POSIX interfaces.

Interoperability The implementation shall be able to
exchange data with existing and upcoming RTR cache
servers. The presented RPKI/RTR library implements
the latest version of the protocol speciﬁcation. We per-
formed interop tests with the RPKI/RTR cache servers
available [7], which helped to reveal errors on both sites.

Extensibility The library shall be easy to modify for
supporting upcoming protocol changes and extensions as
well as speciﬁc user demands. To support this require-
ment, the library consists of separate components with
high cohesion and low coupling. Sufﬁcient abstraction
allows easy exchange of the modules.

Efﬁciency BGP routers are confronted with high BGP
update rates and must currently store more than 400,000
IP preﬁxes. With respect to memory and CPU consump-
tions, the RPKI/RTR implementation shall be prepared
to handle these data even though not all preﬁxes are part
of the RPKI at the moment. In addition, the implementa-
tion should minimize the internal overhead. We designed
our library to scale very well with current and upcoming
BGP data. It does not require speciﬁc hardware, but runs
on commodity devices and thus supports an easy migra-
tion to RPKI origin validation without introducing addi-
tional costs.

2.2 Architecture
Our implementation follows a ﬂexible design. The soft-
ware architecture includes different layers to simplify the
extension or an exchange of individual parts as shown in
Figure 1. The lowest layer of the architecture is built by
the transport sockets. They allow for the implementa-
tion of different transport channels that provide a com-
mon interface to exchange PDUs with the cache (i.e., the
RPKI/RTR server). The current version of RTRlib sup-
ports unprotected TCP and SSH.

On top of the transport layer, the RTR socket uses
a transport socket for RTR-speciﬁc data exchange with
the RPKI/RTR server. The RTR socket implements the
RPKI/RTR protocol, i.e., fetches validation records and
stores them in a preﬁx table data structure.

The preﬁx validation table stores validated preﬁx ori-
gin data. This abstract data structure provides a com-
mon interface to add and delete entries as well as to ver-
ify a speciﬁc preﬁx. Its implementation is crucial as the
data structure stores all preﬁxes received from the cache

Figure 1: Software architecture of RTRlib

transforms the received BGP update data into an XML
stream. This XML stream can be parsed with very low
additional costs. After extracting preﬁx, netmask, and
origin AS the update data will be validated by the RTR-
lib. An operator needs only to add an additional peering
session at the BGP router. Further conﬁguration changes
are not required. As a real-world use-case we started
the deployment of this setup at one of Germany’s largest
Internet Exchange Points to provide IXP members with
most current analysis of their preﬁxes.

Ofﬂine experiments:

The design of the RTRlib al-
lows for easy embedding of the library into Python or
Perl scripts, which are part of the common toolchain in
analysing BGP dump data.

3 Performance Analysis

In this section, we analyse the runtime performance and
the scaling behaviour of RPKI-based origin validation
at the system level based on our reference implementa-
tion. The experiments have been conducted on commod-
ity hardware, i.e., a dual AMD Opteron 280 processor
(2.4 GHz) and 8 GB RAM with Linux Ubuntu (2.6.32-
33 kernel) as underlying operating system.

We explicitly note that any comparison with other im-
plementations of the RPKI/RTR router part would be un-
fair because they either are not designed for real-time
purposes (rpki.net) or do not allow for RPKI-speciﬁc sys-
tem measurements (Cisco/Juniper).

3.1 Memory Consumption
The memory consumption of RTRlib mainly depends on
the number of preﬁxes inserted into the preﬁx validation
table. Considering a 64 bit architecture with 8 bytes per
pointer, a single record within the preﬁx validation table
consumes 78 bytes in our implementation of the longest
preﬁx ﬁrst search tree. Padding bytes, which maybe be

Figure 2: Principle monitoring setup: Preﬁx origin vali-
dation without changig BGP router ﬁrmware

servers (i.e., low memory overhead required) and is re-
sponsible to perform preﬁx lookup for the BGP updates
(i.e., ﬁnd validated IP preﬁxes very fast). Our library im-
plements a Longest Preﬁx First Search Tree (LPFST) [8],
but can be extended to other data structures. In contrast
to common data structures for IP preﬁx lookup such as
Tries or Patricia, the LPFST needs fewer memory access
and exhibits lower memory overhead [8].

Internally, the RTRlib uses two separate preﬁx val-
idation tables, one for IPv4 records and one for IPv6
records. This makes tree operations (insert, delete, ﬁnd)
more efﬁcient as the height per tree is lower in contrast
to a combined IPv4/v6 tree. The appropriate preﬁx vali-
dation table will be chosen according to the IP version.
On top of the modular architecture, the RTR connec-
tion manager maintains connections to multiple RTR
servers. This includes failover mechanisms. It represents
the main interface for users of the library.

2.3 Use Cases
Online experiments:
Changing the ﬁrmware of a de-
ployed BGP router for research experiments is an unpop-
ular option. To emulate preﬁx origin validation of ded-
icated BGP peers in real-time, we propose a mirroring
concept (cf., Figure 2). The measurement node deploys
BGPmon [9] and the RTRlib. BGPmon allows for the
establishment of (unidirectional) peering sessions and

3

AS BAS ABGPmonXML StreamPeeringBGP SessionRTRlibParsing & AnalysingFigure 3: Memory consumption of the RTRlib

inserted by the compiler, are omitted in this calculation.
Note, a common BGP route entry requires between 100
and 200 bytes [10].

To measure the memory required on a real system, we
added randomly generated preﬁxes to the preﬁx valida-
tion table. Figure 3 displays the scaling behaviour for
different table sizes. The overall memory consumption
scales linearly as expected. ROAs for all ≈ 400,000
active IP preﬁxes included in current BGP routing ta-
bles would result in additional ≈ 30 MB of RAM for an
RPKI/RTR-enabled router. Cisco suggests to equip their
devices with 512 MB of RAM for storing a complete
global BGP routing table [11]. Thus a full RPKI vali-
dation table would lead to a 5% increase of RAM—a rel-
atively small overhead. In particular, BGP services im-
plemented on commodity hardware, where several giga-
bytes of RAM are common, should not suffer from RPKI
requirements.

3.2 CPU Consumption
The processing overhead of RPKI/RTR on the router is
dominated by the complexity that results from update
and lookup operations on the data structure holding the
valid ROA information. Update operations on the pre-
ﬁx validation table are triggered by new, modiﬁed, or
deleted ROAs, whereas lookups follow BGP updates.

A fast initial creation of the preﬁx validation table
(e.g., after booting the router) is necessary to start imme-
diately with origin validation of BGP updates. With the
ﬁrst connection to the RPKI/RTR cache server, the com-
plete set of valid ROA data must be (a) transferred to the
router and (b) added to the preﬁx tree. Performance of
the ﬁrst part depends on the network topology, i.e., the
distance between router and cache server. The second
part is only related to the local system. We keep our setup
simple, abstract from (a), and focus on (b). Note, the la-
tency introduced by the cache-router communication is
an additive term to the overall delay.

In this experiment we read different sized sets of ROA

Figure 4: Delay to load a bulk of ROA data into the BGP
router for different mask lengths

data from a ﬁle and measure the import delay introduced
by the RTRlib. Figure 4 visualizes the required time
for preﬁxes with different (minimal and maximal) mask
lengths. Inserting 1,000,000 preﬁx/AS mappings into an
empty preﬁx table needs ≈ 4 seconds. Overall, the per-
formance does neither depend on the IP version nor on
the ROA conﬁguration. Applying a non-linear ﬁt shows
a complexity of O(n· log(n)), with n describes the num-
ber of entries.

From a router perspective, the RPKI deployment state
is measured by the amount of additional lookups, i.e.,
the ratio of valid (or invalid) versus not found IP preﬁxes.
Once origin veriﬁcation is enabled, even a preﬁx that is
not part of the RPKI requires a lookup within the preﬁx
validation table. In the worst case, the complete height
of the preﬁx tree must be traversed. In the following, we
analyze the CPU load for a varying mixture of validation
outcome to quantify overhead based on different states
of deployment.

The performance of tree data structures correlates with
the tree shape, which is inﬂuenced by the inserted data.
A future ROA preﬁx distribution could be derived from
the current Internet backbone routing table. However,
the Internet itself is a continuously evolving structure,
which makes predictions quite hard [12]. In proceeding
this way, we evaluate the CPU load by randomly gener-
ating 100,000 ROA IPv4 preﬁxes with a ﬁxed minimum
and maximum /24-netmask. The AS number of the au-
thorized origin AS is randomly generated, as well. We
consider ratios per validation state of 0%, 25%, 50%,
75%, and 100%. For each combination of all possible
validation outcomes (e.g., 25% valid, 50% invalid, and
25% not found BGP preﬁx announcements), we create a
total of 2,000 IP preﬁxes that match the required states.
We emulate a very high BGP update rate of 2,000 veriﬁ-

4

0,0500,0k1,0M1,5M2,0M050100150~400k prefixes: ~30 MBNumerically (78 Bytes/entry)  Required Memory [MB]Entries in Prefix Validation Table [#]Measured1k10k100k1M10M1E-41E-30,010,1110100Processing Time [s]Imported Entries in Prefix Validation Table [#] IPv4 /8-31 IPv4 /24-24 IPv6 /48-48Figure 5: CPU overhead for varying validation outcomes

Figure 6: Real-world measurement setup

cations per second.

The average CPU load is shown in Figure 5. It ranges
between 0.17 and 1.0 clock ticks (or jifﬁes). The CPU
load ﬂuctuates (cid:28) 1 tick. It is worth noting that our mea-
surement resolution is bound to the predeﬁned timer in-
terrupt handler of the system, which is 10 ms; and we
keep system default conﬁguration to avoid side effects.
Many events require less time than covered by the jiffy
resolution. This ﬁne-grained scale (maximum 1 jiffy)
makes it difﬁcult to predict the impact of the validation
state on the system performance in more detail, i.e., is
the value close to 10 ms or signiﬁcantly less. However,
we emphasize two observations. First, there is a depen-
dency of the ROA validation mix on the lookup costs.
Second, this complexity is—under normal conditions—
insigniﬁcant and thus does not affect BGP routers. De-
tails on this are part of our future work.

In a second step, we quantify the CPU load intro-
duced by current ROA data and real BGP updates.

5

Figure 7: Characteristic CPU load for preﬁx validation
and the number of received preﬁxes for January 5, 2012

To receive live BGP data, we connect to the BGPmon
live stream [13], which provides real-time BGP updates
(cf., Figure 6). The BGPmon projects maintains nine di-
rect peerings as well as indirect peerings via three col-
lectors of the RouteViews project. The indirect peering
includes routing updates from more than 100 peers such
as AOL, Hurricane Electric, and AT&T. The amount of
peering relations allows us to experience live BGP Up-
date rates similar to those seen at a larger ISP. We run
this setup since January 2012.

The CPU load correlates with the number of preﬁx val-
idations (i.e., the BGP update rate). Figure 7 visualizes
both measurements per minute for January 5, 2012. All
other days show the same qualitative behaviour. Dur-
ing the measurement period, we observed a maximum
of 92,549 preﬁx announcements per minute and a max-
imum CPU load of 0.41%. The average CPU load per
day was 0.02% with a standard deviation of 0.04%.

3.3 Future Research Directions
Attacks on RPKI-enabled routers
An legitimate
owner of an IP preﬁx may create intentionally AS/preﬁx
mappings that are cryptographically valid but misses a
counterpart in the BGP system. Note, there are no re-
strictions on creating a huge number of ROAs. With-
out any pre-ﬁltering by the cache server, this will un-
necessarily allocate memory at BGP routers and can be
misused by an attacker. Another attack is the creation
of ROA/BGP data that harms the router with respect to
its processing capacities. Our analysis revealed a val-
idation overhead that slightly depends on the result of
the BGP update veriﬁcation (i.e., valid, invalid, or not
found). Even though this is not signiﬁcant in current de-
ployment, an attacker may exploit this dependency.

In this paper we argue for the need of further research
that analyzes the vulnerability of RPKI-enabled routers.

025507510002550751000,00,20,40,60,81,0Invalid BGP Prefix Update [%]CPU Load [Ticks]Not Found BGP Prefix Updates [%]Receive XML BGP UpdatesExtract Prefix, Prefix Length, ASNs from BGP Announcementsrtr-origin Server (primary)RPKI-Validator-Server (secondary)BGP Live Data Service(livebgp.netsec.colorado.edu)XML StreamTCP-RTRTCP-RTRInitiate BGP Update validationReceive validation recordsWrite logfilesRTRlibbgp_xml_parser.pybenchmark.cMeasurement Node00:0004:0008:0012:0016:0020:0024:000,000,050,100,150,200,250,30010.00020.00030.00040.00050.00060.00070.000CPU Usage [%]Time [hh:mm]BGP Prefix Updates [#]The processing complexity is mainly controlled by the
concrete data structure in use. The RTRlib allows for a
ﬂexible exchange of the embedded data structure, which
makes future evaluation of this topic less complicated.

Modeling cache server dynamic
The daily load on
RPKI-enabled routers is strongly bound to the frequency
of creating and updating ROA data as well as the BGP
update rate. BGP routing dynamic has been analyzed in
great detail during the last years (e.g., [14], [15], [16]).
One might argue that the ROA dynamic implicitly fol-
lows BGP announcements, as a new IP preﬁx requires
a valid ROA in a full RPKI deployment. Such a corre-
lation is not obvious. ROAs can be created in advance
for backup situations or missed due to misconﬁguration,
for example.

We considered extreme cases as well as real world
BGP and ROA streams, which help to anticipate a gen-
eral performance space. However, at the moment it is too
early to ﬁnally judge the typical load signature, because
the RPKI deployment is still in vivid progress. We expect
models that describe the dynamic of ROA updates when
the data within the RPKI repositories is more stable.1

Cache server placement
The total delay for adding
ROA data to the BGP router depends also on the place-
ment of the cache server within the network topology
relatively to the BGP router. There are two reasons to
place the cache server in the vicinity of the router. First,
topological closeness allows to omit preﬁx origin valida-
tion without introducing vulnerability. Secondly, low la-
tencies reduce the transmission time to update the preﬁx
origin validation table. On the other hand, operating mul-
tiple primary cache servers increases maintenance costs.
Our analysis showed that a router is able to create the
preﬁx validation table fast. The RTRlib loads one mil-
lion entries in approximately four seconds. For n entries,
the asymptotic overhead is O(n·log(n)). Combining net-
work latency and processing costs may help to adjust the
placement question.

Online monitoring to reveal preﬁx hijacks A recent,
preliminary study of the RPKI [17] analyzed the vali-
dation outcome of BGP updates in detail. The authors
found that a surprisingly large number of updates are in-
valids according to the RPKI validation process. Most of
them are very likely the result of misconﬁgurations of the
RPKI data. Separating those misconﬁgurations from real
preﬁx hijacks is a challenge that needs to be addressed in
the future. We consider the RTRlib as a helpful tool that
complies with the real-time demands caused by the cor-
responding research questions.

1For an early discussion of this topic, we refer to the very re-
cent email thread at http://www.ietf.org/mail-archive/web/
sidr/current/msg05346.html, November 2012.

4 Related Work

Support for the RPKI/RTR cache is available and de-
ployed, the number of RPKI/RTR clients, though, is lim-
ited [7]. Cisco and Juniper recently implemented RPKI-
based preﬁx origin validation in their ﬁrmware. These
implementations are not fully open-source. More im-
portantly, measuring system behaviour on a ﬁne-grained
base is difﬁcult up to impossible in those closed environ-
ments.

The BGP–SRx framework [18] provides RPKI secu-
rity extension for the open-source BGP daemon Quagga.
This extension does not comply with the current IETF
spec as not only the validation of ROAs but also the vali-
dation of the BGP updates is delegated to a speciﬁc SRx
server. Furthermore, this software is not intended to be
used in production systems. To the best of our knowl-
edge, rpki.net/rtr-origin [19] is the only open-source im-
plementation of the RPKI/RTR client part in addition to
the RTRlib. However, rtr-origin was explicitly developed
in Python to debug the protocol and not designed for real-
time operations or router integration.

The Regional Internet Registries provide looking
glasses to monitor the creation of ROAs [20] and to re-
quest the validation outcome of preﬁx origination [21],
[22]. It is worth noting that the looking glasses are based
on 6 hours dumps of external BGP data and thus do not
provide real-time validation but off-line testing.

5 Conclusion and Outlook

In January 2011, practical steps have been implemented
towards securing the Internet backbone routing. With
the deployment of the Resource Public Key Infrastruc-
ture (RPKI) by the Regional Internet Registries (e.g.,
ARIN, RIPE) owners of IP preﬁxes are able to attest au-
tonomous systems the legitimate announcement of these
preﬁxes. Based on this information BGP routers may
perform preﬁx origin validation and thus prevent preﬁx
hijacking.

Supporting the research community by appropriate
tools and testbeds to increase the understanding of se-
cure Internet backbone routing is an ongoing effort (e.g.,
[23]). In this paper we introduced RTRlib, a very efﬁ-
cient open-source implementation of the required func-
tions for preﬁx origin validation. Our implementation is
built as modular C library making it applicable for real
routers and online monitoring systems as well as script-
based evaluations. We hope that the research community
will beneﬁt from an implementation that is tailored for
real-world deployment, experiments, and measurements
as this may help to increase reproducibility.

Using this reference implementation in C, we pre-
sented a ﬁrst load analysis of preﬁx origin validation at

6

BGP commodity hardware. The overall system scales
surprisingly well even under very high BGP update rates.
Including all presently announced IP preﬁxes into the
RPKI would lead to a 5% increase of RAM compared
to current vendor suggestions for memory resources.

In future work, we will elaborate our public online
monitoring system based on RTRlib, which is fed by a
BGP live stream and provides information about preﬁx
origin validation outcome. We will reﬁne our Quagga
integration to complement the evaluation part. We will
extend our preliminary work [17] on the distinction of
RPKI-misconﬁguration from preﬁx hijacks.

Acknowledgements
We would like to thank the SIDR community for very
valuable discussions. We thank Rob Austein, Tim Brui-
jnzeels (RIPE NCC) and Andrew Chi (BBN) for fruitful
interoperability tests with their implementations of the
RPKI/RTR cache server. Olaf Maennel is gratefully ac-
knowledged for discussions on BGP routing table mod-
eling and adjusting the question on CPU performance.

This work is partially supported by the German
Federal Ministry of Education and Research within
the project Peeroskop (http://peeroskop.realmv6.
org).

References

[1] D. M. Slane, C. Bartholomew et al., “2010 Report
to Congress,” U.S.–China Economic and Security
Review Commission, Annual Report, November
2010. [Online]. Available: http://www.uscc.gov/
annual_report/2010/annual_report_full_10.pdf

[2] K. Butler, T. Farley, P. McDaniel, and J. Rexford,
“A Survey of BGP Security Issues and Solutions,”
Proc. of the IEEE, vol. 98, no. 1, pp. 100–122, Jan-
uary 2010.

[3] M. Lepinski and S. Kent, “An Infrastructure to Sup-
port Secure Internet Routing,” IETF, RFC 6480,
February 2012.

[4] G. Huston, “Resource Certiﬁcation,” The Internet
Protocol Journal, vol. 12, no. 1, pp. 13–26, March
2009.

[5] R. Bush and R. Austein, “The Resource Public Key
Infrastructure (RPKI) to Router Protocol,” IETF,
RFC 6810, January 2013.

[6] P. Mohapatra, J. Scudder, D. Ward, R. Bush, and
R. Austein, “BGP Preﬁx Origin Validation,” IETF,
RFC 6811, January 2013.

7

[7] R. Bush, R. Austein, K. Patel, H. Gredler, and
M. Waehlisch, “RPKI Router Implementation Re-
port,” IETF, Internet-Draft – work in progress 01,
January 2012.

[8] L.-C. Wuu, T.-J. Liu, and K.-M. Chen, “A longest
preﬁx ﬁrst search tree for IP lookup,” Computer
Networks, vol. 51, no. 12, pp. 3354–3367, August
2007.

[9] H. Yan, R. Oliveira, K. Burnett, D. Matthews,
L. Zhang, and D. Massey, “BGPmon: A real-time,
scalable, extensible monitoring system,” in Proc. of
the 2009 Cybersecurity Applications & Technology
Conference for Homeland Security (CATCH’09).
Washington, DC, USA: IEEE Computer Society,
2009, pp. 212–223.

[10] K. Dooley and I. Brown, Cisco IOS Cookbook,

2nd ed. Sebastopol, USA: O’Reilly, 2006.

[11] Cisco,

“BGP: Frequently Asked Questions,”

http://www.cisco.com/image/gif/paws/5816/
bgpfaq_5816.pdf, 2012.

[12] M. Roughan, W. Willinger, O. Maennel, D. Perouli,
and R. Bush, “10 Lessons from 10 Years of Measur-
ing and Modeling the Internet’s Autonomous Sys-
tems,” IEEE Journal on Selected Areas in Commu-
nications, vol. 29, no. 9, pp. 1810–1821, 2011.

[13] D. Massey, H. Yan, M. Strizhov et al., “BGPmon.
Next generation BGP Monitor,” http://bgpmon.
netsec.colostate.edu/, 2012.

[14] A. Feldmann, O. Maennel, Z. M. Mao, A. Berger,
and B. Maggs, “Locating Internet Routing Instabil-
ities,” in Proc. of SIGCOMM.
New York, NY,
USA: ACM, 2004, pp. 205–218.

[15] J. Li, M. Guidero, Z. Wu, E. Purpus, and
T. Ehrenkranz, “BGP Routing Dynamics Revis-
ited,” ACM SIGCOMM CCR, vol. 37, no. 2, pp.
5–16, 2012.

[16] A. Elmokashﬁ, A. Kvalbein, and C. Dovrolis,
“BGP Churn Evolution: A Perspective from the
Core,” IEEE/ACM Trans. Netw., vol. 20, no. 2, pp.
571–584, 2012.

the RPKI,”

[17] M. Wählisch, O. Maennel, and T. C. Schmidt,
“Towards Detecting BGP Route Hijacking us-
of ACM SIG-
ing
COMM, Poster Session. New York: ACM,
August 2012, pp. 103–104.
[Online]. Avail-
able:
http://conferences.sigcomm.org/sigcomm/
2012/paper/sigcomm/p103.pdf

in Proc.

[18] NIST, “BGP Secure Routing Extension (BGP-

SRx),” http://www-x.antd.nist.gov/bgpsrx/, 2012.

[19] R.

Austein,

rpki.hactrn.net/trunk/, 2012.

“rpki.net,”

http://subvert-

[20] “RIPE NCC. RIR Trust Anchor Statistics,”

https://www.ripe.net/lir-services/resource-
management/certiﬁcation/rir-trust-anchor-
statistics, 2012.

[21] RIPE

NCC,

“Making

Better

Through

RPKI

Decisions
http://www.ripe.net/lir-services/resource-
management/certiﬁcation/making-better-routing-
decisions-through-rpki-validation, 2012.

Validation

Routing
,”

[22] L. labs, “Origin Validation Looking Glass,” http:

//www.labs.lacnic.net/rpkitools/looking_glass/,
2012.

[23] O. Maennel,

I. Phillips, D. Perouli, R. Bush,
R. Austein, and A. Jaboldinov, “Towards a Frame-
work for Evaluating BGP Security,” in Proc. of the
5th Workshop on Cyber Security Experimentation
and Test. Berkeley, CA, USA: USENIX Associa-
tion, 2012.

8

