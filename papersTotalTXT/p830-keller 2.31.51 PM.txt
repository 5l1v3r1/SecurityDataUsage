MASCOT: Faster Malicious Arithmetic Secure Computation

with Oblivious Transfer

Marcel Keller∗

Emmanuela Orsini†

Department of Computer Science, University of Bristol

{m.keller,emmanuela.orsini,peter.scholl}@bristol.ac.uk

Peter Scholl‡

ABSTRACT
We consider the task of secure multi-party computation of
arithmetic circuits over a ﬁnite ﬁeld. Unlike Boolean cir-
cuits, arithmetic circuits allow natural computations on in-
tegers to be expressed easily and eﬃciently. In the strongest
setting of malicious security with a dishonest majority —
where any number of parties may deviate arbitrarily from
the protocol — most existing protocols require expensive
public-key cryptography for each multiplication in the pre-
processing stage of the protocol, which leads to a high total
cost.

We present a new protocol that overcomes this limita-
tion by using oblivious transfer to perform secure multipli-
cations in general ﬁnite ﬁelds with reduced communication
and computation. Our protocol is based on an arithmetic
view of oblivious transfer, with careful consistency checks
and other techniques to obtain malicious security at a cost of
less than 6 times that of semi-honest security. We describe a
highly optimized implementation together with experimen-
tal results for up to ﬁve parties. By making extensive use of
parallelism and SSE instructions, we improve upon previous
runtimes for MPC over arithmetic circuits by more than 200
times.

Keywords
Multi-party computation; oblivious transfer

1.

INTRODUCTION

Secure multi-party computation (MPC) allows a set of
parties to jointly compute a function on their private inputs,
∗
†

Supported by EPSRC via grant EP/M016803.
Supported by ERC Advanced Grant ERC-2010-AdG-

267188-CRIPTO.
‡

Supported by the Defense Advanced Research Projects
Agency (DARPA) and Space and Naval Warfare Systems
Center, Paciﬁc (SSC Paciﬁc) under contract No. N66001-
15-C-4070.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:2) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978357

learning only the output of the function. In the last decade,
MPC has rapidly moved from purely theoretical study to an
object of practical interest, with a growing interest in prac-
tical applications, and many implementations now capable
of handling complex computations [28, 29].

Most MPC protocols either perform secure computation
of Boolean circuits, or arithmetic circuits over a ﬁnite ring or
ﬁeld such as Fp, for some prime p. Historically, the Boolean
circuit approach has led to fast protocols that mostly need
only symmetric cryptography, such as two-party protocols
based on Yao’s garbled circuits [41], or protocols based on
fast oblivious transfer techniques [30, 34]. In contrast, pro-
tocols for arithmetic circuits are typically based on more
expensive, public-key technology (except for special cases
when a majority of the parties are honest).

Despite the need for expensive techniques, secret-sharing-
based MPC protocols for arithmetic circuits have the key
advantage that secure addition requires no communication
and essentially come ‘for free’, whereas with current Boolean
circuit-based 2-PC, the only ‘free’ operation is XOR.

The following motivating examples further highlight the
practical applicability of integer-based secure computation,
compared with Boolean circuits:

- Bogdanov et al. [8, 9] describe using MPC to perform
secure statistical analysis of income tax records for
the Estonian government. The latter work analyzed a
large database with over 600000 students and 10 mil-
lion tax records. The kinds of computations involved
were very simple statistics, but made heavy use of the
fact that secure additions are non-interactive.

- In [13], an application of MPC to conﬁdential bench-
marking was presented, allowing banks to jointly eval-
uate customers’ risks whilst retaining privacy for the
customers’ data. They used secure linear program-
ming, which is a highly complex task in MPC, requir-
ing either secure ﬂoating point arithmetic or very large
integer arithmetic (to emulate real numbers without
overﬂow), both of which would be impractical using
Boolean circuits.

- MPC has been suggested as a tool for helping pre-
vent collisions between satellites, by securely perform-
ing collision detection using sensitive location and tra-
jectory data. Kamm et al. [25] showed how to imple-
ment the relevant conjunction analysis algorithms in
MPC with a protocol based on secret-sharing. This
also requires secure ﬂoating point operations.

830Unfortunately, all of the above case studies are somewhat
limited, in either the security properties obtained, or the ef-
ﬁciency. The ﬁrst and third examples above used the Share-
mind system [1], which is restricted to semi-honest security
with three parties, where at most one is corrupt. The second
example used the SPDZ MPC protocol [17], which has se-
curity against any number of maliciously corrupted parties,
but is much slower. They report a fairly quick evaluation
time of around 20–30 s with a prototype implementation,
but this does not include the costly ‘preprocessing’ stage
required in SPDZ, which would likely take several hours.

We conclude that although these applications are practi-
cal, the MPC protocols used still fall short:
in many real-
world applications, semi-honest adversaries and an honest
majority are not realistic assumptions, and MPC may not
be cost-eﬀective if it requires several hours of heavy compu-
tation.

Furthermore, it is the case that all known practical proto-
cols for MPC with integer operations either require an hon-
est majority, or expensive public-key techniques for every
multiplication in the circuit. For example, the SPDZ proto-
col [15, 17] mentioned above uses a somewhat homomorphic
encryption scheme to perform secure multiplications, whilst
the BDOZ protocol [6] uses additively homomorphic encryp-
tion, and both of these require expensive zero-knowledge
proofs or cut-and-choose techniques to achieve security against
malicious adversaries.

These protocols mitigate this cost to an extent by restrict-

ing the expensive computation to a preprocessing phase, which
is independent of the inputs and can be done in advance. Al-
though this is highly eﬀective for reducing the latency of the
secure computation — as the online phase is indeed very ef-
ﬁcient — the total cost of these protocols can still be thou-
sands of times greater than the online phase, which may
render them ineﬀective for many applications.

Frederiksen et al. [19] recently showed how to eﬃciently
use oblivious transfer to generate multiplication triples —
the main task of the SPDZ preprocessing — in binary ﬁelds,
and estimated much improved performance, compared with
previous methods. However, this does not give the beneﬁts
of general arithmetic circuits that allow integer operations.
1.1 Our contributions

In this paper, we present MASCOT: a new MPC proto-
col designed to overcome the above limitations of the pre-
processing phase, allowing for eﬃcient, secure computation
of general arithmetic circuits using almost exclusively fast,
symmetric cryptography.

Protocol

Field

SPDZ (active)

SPDZ (covert,
pr. 1/10)

Ours (active)

Fp, 128-bit
F240
Fp, 128-bit
F240
Fp, 128-bit
F2128

Comms.

(kbit)

215n(n − 1)
2272n(n−1)
66n(n − 1)
844n(n − 1)
180n(n − 1)
180n(n − 1)

Throughput,
n = 2 (/s)

23.5
3.68
204
31.9
4842
4827

Table 1: Comparing the cost of n-party secure mul-
tiplication in our OT-based protocol with previous
implementations of SPDZ [14, 15].

Arithmetic-circuit MPC from OT.

We present a practical protocol for secure multi-party
computation of arithmetic circuits based on oblivious trans-
fer (OT), for the ﬁrst time with malicious security in the
dishonest majority setting. We achieve this by taking an
“arithmetic” view of OT (as was done by Gilboa for two-
party RSA key generation [20] and Demmler et al. [18] for
two-party computation in the semi-honest model), which al-
lows us to generalize the preprocessing protocol by Frederik-
sen et al. [19] to create multiplication triples in any (suﬃ-
ciently large) ﬁnite ﬁeld, instead of just binary ﬁelds. We
achieve security against malicious adversaries using simple
consistency checking and privacy ampliﬁcation techniques,
with the result that our maliciously secure protocol is only 6
times less eﬃcient than a semi-honest version of the protocol.
Moreover, our protocol can be based entirely on symmetric
primitives, after a one-time setup phase, by using eﬃcient
OT extensions [23, 26].

Implementation.

A key advantage of our approach to triple generation is

that we obtain a streamlined protocol, which is highly amenable
to a parallelized and pipelined implementation that inter-
leaves computation and communication. Table 1 highlights
this: the time for a single secure multiplication in a prime
ﬁeld is 200 times faster than the previous best actively se-
cure implementation based on somewhat homomorphic en-
cryption [15], in spite of a fairly small improvement in com-
munication cost. Compared with a covertly secure imple-
mentation1 using SHE [15], our actively secure protocol re-
quires slightly more communication, but still runs over 20
times faster. In binary ﬁelds, where SHE is much less suited,
the improvement is over 1000 times, compared to previous
ﬁgures [14]. Note that the online phase of our protocol is
identical to that of SPDZ, which has been previously re-
ported to achieve very practical performance for a range of
applications [28].

Our optimized implementation utilizes over 80% of the
network’s capacity, whereas the previous schemes based on
SHE are so computation-intensive that the network cannot
come close to capacity. We also describe new techniques
for reducing the cost of OT extension using consumer hard-
ware instructions, namely eﬃcient matrix transposition us-
ing SSE instead of Eklundh’s algorithm, and hashing using
the Matyas–Meyer–Oseas construction from any block ci-
pher, which allows hashing 128-bit messages with AES-NI
whilst avoiding a re-key for every hash.

More general assumptions.

We also improve upon the previous most practical pro-
tocol by allowing a much wider variety of cryptographic
assumptions, since we only require a secure OT protocol,
which can be built from DDH, quadratic residuosity or lat-
tices [36]. In contrast, security of the SHE scheme used in
SPDZ is based on the ring learning with errors assumption,
which is still relatively poorly understood — it is possible
that new attacks could surface that render the protocol to-
tally impractical for secure parameters. So as well as in-
creasing eﬃciency, we obtain much greater conﬁdence in the

1For F240 in SPDZ with covert security, we could not ﬁnd
precise ﬁgures so the throughput in Table 1 is estimated
based on other results.

831security of our protocol, and it seems more likely to with-
stand the test of time.
1.2 Technical overview

The main goal of our MPC protocol is to create multipli-
cation triples, which are essentially additive secret sharings
of tuples (a, b, a· b, a· Δ, b· Δ, a· b· Δ) where a, b are random
values and Δ is a secret-shared global random MAC key.
Shares of a, b and Δ can be generated by every party choos-
ing a random share. It remains to generate secret sharings
of the products.

Our starting point is the passively secure two-party product-

sharing protocol of Gilboa [20], which uses k oblivious trans-
fers to multiply two k-bit ﬁeld elements. By running OT
instances between every pair of parties, the multiplication
triples can be created.

However, corrupted parties can deviate by providing in-
consistent inputs to the diﬀerent OT instances.2 These de-
viations will not only lead to potentially incorrect results
when the triples are used in SPDZ but also to selective fail-
ures, that is, the checks used in SPDZ might fail (or not)
depending on secret information.

To obtain an actively secure protocol, we use two diﬀerent
strategies: one to ensure correctness of the products in the
MAC generation, and one to ensure correctness and privacy
of the multiplication triples themselves.

For the MAC generation, it turns out the passively secure
protocol is almost enough; we just need to check random
linear combinations of the MACs immediately after creation,
and also when later opening values. Proving the security of
this, however, is not straightforward and requires a careful,
technical analysis of the possible deviations. To simplify
this as much as possible, we model the MAC generation
and opening requirements in a separate functionality, F(cid:2)·(cid:3),
which can be seen as a generalization of veriﬁable secret-
sharing to the case of full-threshold corruption. This greatly
reduces the work in proving higher-level protocols secure, as
these can then be made independent of the MAC scheme
and underlying MAC keys.

For triple generation, we need to ensure correctness and
privacy of the triples. Correctness is easily veriﬁed with a
standard sacriﬁce technique [16, 17], which checks a pair of
triples such that one can then be used securely. To guaran-
tee privacy we use a simple variant of privacy ampliﬁcation,
where ﬁrst several leaky triples are produced, from which a
single, random triple is extracted by taking random combi-
nations.
In more detail, the protocol starts by generating shares of
a correlated vector triple (a, b, c), where b ∈ F and a, c ∈ Fτ
for some constant τ , using Gilboa’s multiplication protocol.
If at this point the triple is checked with a sacriﬁce, b is
guaranteed to be uniformly random, but the fact that the
sacriﬁce passes may leak a few bits of a, if a corrupt party
used inconsistent inputs to some of the OTs. To counteract
this, the parties sample a public random vector r ∈ Fτ and
obtain the triple (a, b, c) by deﬁning

a = (cid:3)a, r(cid:4),

c = (cid:3)c, r(cid:4)

In the security proof, the simulator can precisely deﬁne any
leakage and bound the min-entropy of a by analysing the

2We assume that the OT instances themselves are secure
against malicious parties.

adversary’s inputs to the OTs. We then use the leftover
hash lemma to show that a is uniformly random when τ is
large enough.

At this point, we could repeat the process to obtain an-
other triple, then authenticate both triples and check cor-
rectness with a sacriﬁce. However, we observe that this stage
can be optimized by using the original vector triple (a, b, c)
to obtain a second, correlated triple, with the same b value,
at a lower cost. To do this, we simply sample another ran-
dom vector ˆr and compute ˆa, ˆc accordingly. Again, we can
show (for suitable τ ) that ˆa is uniformly random and inde-
pendent of a. We can then use (ˆa, b, ˆc) to check correctness of
(a, b, c), as follows. After adding MACs to both triples, the
parties sample a random value s ∈ F and open ρ = s · a − ˆa.
Now, we have:

s · c − ˆc − b · ρ = s · (c − a · b) + (ˆa · b − ˆc)

Since the left-hand side is linear in the shared values, the
parties can compute this and check that it opens to zero. If
one or both triples are incorrect then this is non-zero with
probability at most 1/|F|, since s is uniformly random and
unknown at the time of authentication.

It turns out that for this optimized method, using τ = 4
suﬃces to give a correct triple and ensure a distinguishing
advantage in O(1/|F|).
then we can have τ = 3. Concretely, this means that we can
use τ = 3 for ≥ 128-bit ﬁelds with 64-bit statistical security.

If we allow this to be O(1/

p|F|)

Comparison with Previous Techniques.

Previous works have used similar privacy ampliﬁcation
techniques for MPC. In [16], privacy ampliﬁcation was done
on a large batch of triples using packed Shamir secret-sharing,
which leads to high computation costs. In contrast, our pro-
tocol only requires removing leakage on one of the three
triple values, which we do very eﬃciently by combining a
constant-sized vector of correlated triples. In situations where
leakage is possible on more than one triple component, our
techniqe would have to be repeated and [16] may be more
eﬃcient, at least in terms of communication. Other works
use more complex ‘bucketing’ techniques [35] to remove leak-
age in F2, but when working in large ﬁnite ﬁelds this is not
needed.

We also note that our authentication method is similar
to that of the triple generation protocol for binary ﬁelds
in [19], except there, MACs are only checked after opening
values, whereas we also check MACs at time of creation.
That work did not describe the online phase of the resulting
MPC protocol, and it turns out that for creating inputs in
the online phase, this is not enough, and our additional check
is crucial for security of the whole protocol.

Roadmap.
We model oblivious transfer and random oblivious trans-
fer with FOT and FROT, respectively. The multiplication
with ﬁxed element provided by OT extension with FCOPEe
described in Section 3. This functionality is then used to
implement F(cid:2)·(cid:3) in Section 4, which guarantees the correct-
ness of linear operations. Both FROT and F(cid:2)·(cid:3) are required to
implement the triple generation functionality FTriple in Sec-
tion 5, which is used for the online protocol described in the
full version [27]. In Section 6, we evaluate the complexity

832and the implementation of our protocol. Fig. 1 illustrates
the relationship between our functionalities.

FOT

FCOPE

F(cid:2)·(cid:3)

FROT

FTriple

Figure 1: Dependency among functionalities

1.3 Related work

Aside from the works already mentioned, many other se-
cure computation protocols use oblivious transfer. Proto-
cols based on GMW [2, 21] and TinyOT [10, 30, 34] use OT
extensions for eﬃcient MPC on binary circuits, and fast gar-
bled circuit protocols use OT extensions in the input stage
of the protocol [31]. Pinkas et al. [37, 38] used OT exten-
sions to achieve a very eﬃcient and scalable protocol for the
dedicated application of private set intersection.

Ishai et al. [24] present another protocol achieving mali-
cious security based on OT. However, they only give asymp-
totic complexity measures. Furthermore, the building blocks
of their protocol such as codes and fast fourier transforms
suggest more expensive computation than our protocol, where
the computation mainly consists of a few ﬁeld operations.

Baum et al. [3] described improvements to the ‘sacriﬁce’
step and the zero-knowledge proofs used with somewhat ho-
momorphic encryption in SPDZ. Their sacriﬁce technique
requires generating triples that form codewords, which does
not seem straightforward with our protocol. Their zero-
knowledge proofs improve upon the method by Damg˚ard
et al. [15] by roughly a factor of two, but our protocol still
performs much faster.

2. PRELIMINARIES

In this section, we describe the security model, introduce
some important notation, deﬁne the oblivious transfer prim-
itive, and give a basic overview of the SPDZ protocol.

Security model.

We prove our security statements in the universal com-
position (UC) framework of Canetti [11], and assume famil-
iarity with this. Our protocols work with n parties from
the set P = {P1, . . . , Pn}, and we consider security against
malicious, static adversaries, i.e. corruption may only take
place before the protocols start, corrupting up to n − 1 par-
ties. When we say that a protocol Π securely implements
a functionality F with statistical (resp. computational) se-
curity parameter κ (resp. λ), our theorems guarantee that
the advantage of any environment in distinguishing the real
−λ)). Here,
and ideal executions is in O(2
κ and λ denote the statistical and computational security
parameters, respectively.

−κ) (resp. O(2

Notation.

2k , and write F

statistical security parameter κ, and μ ∈ poly(k) then with
overwhelming probability a random element of Fp can be
represented with k bits in {0, 1}, and likewise for any ele-
∼
2k . Let F denote the ﬁnite ﬁeld, which will be either
ment of F
Fp or F
= F2[X]/f (X) for some monic, ir-
reducible polynomial f (X) of degree k. We use lower case
letters to denote ﬁnite ﬁeld elements and bold lower case let-
ters for vectors in F, for any ﬁnite ﬁeld F. If x, y are vectors
over F, then x ∗ y denotes the component-wise products of
the vectors. We denote by a $← A the uniform sampling of
a from a set A, and by [d] the set of integers {1, . . . , d}.

2k

Following notation often used in lattice-based cryptogra-
phy, deﬁne the ‘gadget’ vector g consisting of the powers of
two (in Fp) or powers of X (in F

2k ), so that
g = (1, g, g2, . . . , gk−1) ∈ F
k,
−1 : F → {0, 1}k
2k . Let g
where g = 2 in Fp and g = X in F
be the ‘bit decomposition’ function that maps x ∈ F to a
−1(x) ∈ {0, 1}k, such that xB can be
bit vector xB = g
−1(x)(cid:4) =
mapped back to F by taking the inner product (cid:3)g, g
x. These basic tools allow us to easily switch between ﬁeld
elements and vectors of bits whilst remaining independent
of the underlying ﬁnite ﬁeld.

Oblivious Transfer.

Oblivious transfer (OT) is a protocol between a sender and
a receiver, where the sender transmits one of several mes-
sages to the receiver, whilst remaining oblivious to which
message was sent. All known constructions of OT require
public-key cryptography, but in 1996, Beaver [5] introduced
the concept of OT extensions, where cheap, symmetric prim-
itives (often available in consumer hardware) are used to
produce many OTs from only a few. Ishai et al. [23] later
optimized this concept to the form that we will use in this
paper.

Recently, Keller et al. [26] presented a simple consistency
check that allows maliciously secure OT extension at essen-
tially no extra cost: the cost for a single OT on random
strings is almost that of computing two hash function eval-
uations and sending one string.

The ideal functionality for a single 1-out-of-2 oblivious
transfer on k-bit strings is speciﬁed as follows, along with
the random OT variant, where the sender’s messages are
sampled at random:

(cid:10)→ (⊥, sb)
(cid:10)→ ((r0, r1), rb),

F 1,k
OT : ((s0, s1), b)
ROT : (⊥, b)
F 1,k
$← {0, 1}k, and b ∈ {0, 1} is the receiver’s input.
ROT to denote l sets of oblivious

where r0, r1
We use the notation F l,k
transfers on k-bit strings.
2.1 The SPDZ Protocol

OT ,F l,k

The online phase of SPDZ [15, 17] uses additive secret
sharing over a ﬁnite ﬁeld, combined with information-theoretic
MACs to ensure active security. A secret value x ∈ F is rep-
resented by

The protocols we present in this paper work in both Fp,
for prime p = 2k + μ, and F
2k ; we introduce some notation
to unify the two ﬁnite ﬁelds. First note that if k ≥ κ, for

(cid:2)x(cid:3) = (x(1), . . . , x(n), m(1), . . . , m(n), Δ(1), . . . , Δ(n)),

where each party Pi holds the random share x(i), the random

833which is illustrated for Fp in Fig. 2, and also used in our
triple generation protocol later. The two parties run k sets
of OTs on k-bit strings, where in each OT the sender, PS,
$← F and the correlated value ti +a,
inputs a random value ti
where a ∈ F is the sender’s input. The receiver inputs the
bit decomposition of their input, (b1, . . . , bk) ∈ {0, 1}k, and
receives back either ti or ti + a, depending on the bit bi.
Since the sender’s correlation is computed over F, we have
the relation

qi = ti + bi · a,

where qi is the receiver’s output in the i-th OT. Now both
parties simply compute the inner product of their values
(qi)i, (−ti)i with the gadget vector g to obtain values q and
t which form an additive sharing of the product of the inputs,
so that

q + t = a · b ∈ F.

Correlated OPE.

To obtain COPE, where one party’s input is ﬁxed for
many protocol runs, we only need to perform the k OTs
once, where the receiver, PB, inputs their bits of Δ ∈ F
and the sender, PA, inputs k pairs of random λ-bit seeds
(recall that λ is the computational security parameter and
k = (cid:12)log |F|(cid:13)). This is the Initialize phase of ΠCOPEe (Pro-
tocol 1).

After initialization, on each Extend call the parties ex-
pand the original seeds using a PRF to create k bits of fresh
random OTs, with the same receiver’s choice bits ΔB. Party
PA now creates a correlation between the two sets of PRF
outputs using their input, x (step (b)). The masked correla-
tion is sent to PB, who uses this to adjust the PRF output
accordingly; now both parties have k correlated OTs on ﬁeld
elements. These are then mapped into a single ﬁeld element
by taking the inner product of their outputs with the gadget
vector g to obtain an additive sharing of x · Δ in steps 4–5.

Malicious behavior.

Now consider what happens in ΠCOPEe if the parties do
not follow the protocol. Party PB ﬁxes their input Δ at the
start of the protocol, and sends no more messages thereafter,
so cannot possibly cheat. On the other hand, PA may use
diﬀerent values of x in each ui that is sent in step 2 of
Extend. Suppose a corrupt PA uses xi to compute ui, for
i ∈ [k], then in step 4 we will instead have q = t + x ∗ ΔB,
where x = (x1, . . . , xk), which then results in

t + q = (cid:3)g ∗ x, ΔB(cid:4)

We do not prevent this in our protocol, but instead model
this behavior in the functionality FCOPEe (given in the full
version [27]).
The proof of the following theorem, showing that our pro-
tocol securely implements FCOPEe in the FOT-hybrid model
if F is a PRF, is given in the full version.

Theorem 1. The protocol ΠCOPEe securely implements FCOPEe

in the FOT-hybrid model with computational security param-
eter λ, ifF is a PRF.

Figure 2: Two-party secret-shared multiplication in
Fp using 1-out-of-2 OT

MAC share m(i) and the ﬁxed MAC key share Δ(i), such
that the MAC relation m = x · Δ holds, for
X

X

X

x(i), m =

m(i), Δ =

Δ(i)

x =

i

i

i

over F.

When opening a shared value (cid:2)x(cid:3), parties ﬁrst broadcast
their shares x(i) and compute x. To ensure that x is correct,
they then check the MAC by committing to and opening
m(i) − x · Δ(i), and checking these shares sum up to zero.
To increase eﬃciency when opening many values, a random
linear combination of the MACs can be checked instead.

The main task of the SPDZ preprocessing phase is to pro-
duce the following types of random, authenticated shared
values:

Input Pi: ((cid:2)r(cid:3), i) a random, shared value r, such that
only party Pi knows the value r.

Triple: ((cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3)) for uniformly random a, b, with
c = a · b.

In the online phase, parties interact and use the Input val-
ues to create shared representations of their private inputs,
and the Triple values to perform multiplications on secret-
shared values. Note that since the (cid:2)·(cid:3) representation is lin-
ear, additions and linear functions can be computed locally.

3. CORRELATED OBLIVIOUS PRODUCT

EVALUATION

In this section we describe an arithmetic generalization of
the passively secure OT extension of Ishai et al. [23], which
we call correlated oblivious product evaluation (COPE). This
allows two parties to obtain an additive sharing of the prod-
uct x · Δ, where one party holds x ∈ F and the other party
holds Δ ∈ F. The correlation, Δ, is ﬁxed at the start of
the protocol, and then future iterations create sharings for
diﬀerent values of x.

Oblivious product evaluation.

The key mechanism behind COPE is a general method
for (possibly non-correlated) oblivious product evaluation,

834Protocol 1 The protocol ΠCOPEe: Oblivious correlated prod-
uct evaluation with errors over the ﬁnite ﬁeld F.
The protocol uses a PRF F : {0, 1}λ × {0, 1}λ → F and
maintains a counter j := 0. After initialization, Extend
may be called multiple times.
Initialize: On input Δ ∈ F from PB:
1: PA samples k pairs of seeds, {(ki
2: Both parties call F k,λ

{0, 1}λ.
PA and ΔB = (Δ0, . . . , Δk−1) ∈ {0, 1}k from PB.

0, ki
OT with inputs {ki

i=1, each in
1}i∈[k] from

1)}k

0, ki

3: PB receives ki

Extend: On input x ∈ F from PA:

Δi for i ∈ [k].

1: For each i = 1, . . . , k:

(a) Deﬁne

0 = F (ki
ti

so PA knows (ti
(b) PA sends ui = ti
(c) PB computes

0, j) ∈ F and ti

1 = F (ki
0, ti
1) and PB knows ti
0 − ti

1 + x to PB.

1, j) ∈ F
Δi .

qi = Δi · ui + ti
0 + Δi · x

= ti

Δi

2: Store j := j + 1
3: Let q = (q1, . . . , qk) and t = (t1

0, . . . , tk

0 ). Note that

q = t + x · ΔB ∈ F
k.

4: PB outputs q = (cid:3)g, q(cid:4).
5: PA outputs t = −(cid:3)g, t(cid:4).
6: Now it holds that t + q = x · Δ ∈ F.

Complexity.

The communication complexity of a single iteration of our
COPE protocol, after the k base OTs in initialization, is k
ﬁeld elements, for a total of k2 bits. The computation cost
is 3k PRF evaluations and 8k ﬁnite ﬁeld operations between
the two parties.

4. AUTHENTICATING AND OPENING AD-

DITIVE SHARES

In this section we show how to create authenticated SPDZ
shares using COPE and securely open linear combinations
of these shares with a MAC checking procedure. The main
challenge is to ensure that an adversary who inputs errors
in our COPE protocol cannot later open an authenticated
share to the incorrect value. We model these requirements
in a single functionality, F(cid:2)·(cid:3) (Fig. 3), which is independent
of the details of the MAC scheme used and the underlying
MAC keys. One can see this functionality as a generaliza-
tion of veriﬁable secret sharing with the main diﬀerence that
it allows full-threshold corruption. We ﬁrst explain the me-
chanics of the functionality, and then describe the protocols
for implementing it.

Inputs are provided to the functionality with the Input
command, which takes as input a list of values x1, . . . , xl
from one party and stores these along with the identiﬁers

Protocol 2 MAC checking subprotocol
On input an opened value y, a MAC share m(i) and a MAC
key share Δ(i) from party Pi, eachP i does the following:
1: Compute σ(i) ← m(i)−y·Δ(i) and call FComm to commit
2: Call FComm with (Open, τi) to open the commitments.
3: If σ(1) + ··· + σ(n) (cid:14)= 0, output ⊥ and abort, otherwise

to this and receive the handle τi.

continue.

id1, . . . , idl. Linear functions can then be computed on values
that have been input using the LinComb command.

The Open command lets the adversary output inconsistent
or incorrect values. However, if this happened to honest
parties, the Check command will reveal this.
4.1 Authentication using COPE

We ﬁrst consider a natural approach for one party to cre-
ate an authenticated sharing of their private inputs using
the correlated oblivious product evaluation protocol, and
describe why this is not suﬃcient for active security on its
own. We then show that an actively secure protocol can
be obtained by authenticating one extra random value and
checking a random linear combination of all MACs during
the input phase. For ease of exposition, we restrict ourselves
to the two-party setting, and brieﬂy explain at the end how
Π(cid:2)·(cid:3) (Protocol 3) extends this to n parties.
Suppose party P1 is honest and wishes to authenticate
an input x ∈ F. P1 runs an instance of FCOPEe with P2
and inputs x into the Extend command, whilst P2 inputs
a MAC key share Δ(2). P1 then receives t and Pj receives q
such that q + t = x · Δ(2). P1 then deﬁnes the MAC share
m(1) = x· Δ(1) + t, and P2 deﬁnes the MAC share m(2) = q.
Clearly, we have m(1) + m(2) = x · Δ, as required.

To convert x into shares, P1 simply generates random ad-
ditive shares x(1), x(2) and sends x(2) to P2. Note that since
the shares and MACs are linear, computing linear combi-
nations on authenticated values is straightforward. Parties
can also add a constant by adjusting their MAC shares ac-
cordingly, and choosing one party (say, P1) to adjust their
share.
FCOPEe. If P
this is 1 in the ﬁrst k/2 positions and 0 elsewhere, then the
relation between the MAC shares becomes:

∗
1 , who can input a vector x into
1 chooses x = (1, . . . , 1, 0, . . . , 0) ∈ Fk, where
∗

Now consider a corrupt P

m(1) + m(2) = (cid:3)g ∗ (1, . . . , 1, 0, . . . , 0), ΔB(cid:4)

where we have deﬁned m(1) = t + (cid:3)g ∗ x, Δ(1)(cid:4) for conve-
nience.
∗
1 ’s input is later opened, then to pass the MAC check,
If P
∗
1 essentially needs to come up with a value x and a valid
+ m(2) = x· Δ. One possibility
, and compute

P
MAC share m
is to guess the ﬁrst k/2 bits of Δ, denoted Δ

such that m

∗

∗

(cid:4)

∗

= m(1) − (cid:3)g, Δ

m

B(cid:4)
(cid:4)

∗
which gives a valid MAC relation for x = 0. However, P
1
could similarly try to guess the latter k/2 bits of Δ, which
corresponds to opening to x = 1. Note that each of these
−k/2, but for eﬃ-
openings only succeeds with probability 2

835Functionality F(cid:2)·(cid:3)

The functionality maintains a dictionary, Val, to keep track of the authenticated values. Entries of Val lie in the (ﬁxed) ﬁnite ﬁeld
F and cannot be changed, for simplicity.

set Val[idi] ← xi for i = 1, . . . , l.

Input: On receiving (Input, id1, . . . ,id l, x1, . . . , xl, Pj ) from party Pj and (Input, id1, . . . ,id l, Pj ) from all other parties, where xi ∈ F,
Linear comb.: On receiving (LinComb, id, id1, . . . ,id t, c1, . . . , ct, c) from all parties, where (id1, . . . , idt) ⊆ Val.keys() and the com-
Open: On receiving (Open, id) from all parties, where id ∈ Val.keys(), send Val[id], wait for x from the adversary, and output x to

bination coeﬃcients c1, . . . , ct, c ∈ F, set Val[id] ← P

Val[idi] · ci + c.

t
i=1

all parties.

and Val[idj ] = xj for all j, return OK to all parties, otherwise return ⊥ and terminate.

Check: On receiving (Check, id1, . . . , idt, x1, . . . , xt) from every party Pi, wait for an input from the adversary. If it inputs OK,
Abort: On receiving Abort from the adversary, send ⊥ to all parties and terminate.

Figure 3: Functionality for authenticating, computing linear combinations of, and opening additively shared
values

−k.

The main problem here is that P

ciency we would like to achieve a failure probability much
closer to 2

∗
1 can choose, at the time
of opening, what to open to, and is not committed to one
particular value. This means the simulator cannot compute
a valid input during the Input stage, and we cannot securely
realize the functionality.

To get around this problem, we require two changes to the
Input stage. Firstly, P1 samples a random dummy input
$← F, and authenticates this as well as the m actual in-
x0
puts. Secondly, after computing the MACs using FCOPEe, P1
opens a random linear combination of the inputs x0, . . . , xl,
and the MAC on this is checked by all parties. This ensures
that P1 is committed to their inputs during the input stage
and cannot later open to a diﬀerent value, whilst x0 masks
the actual inputs in this opening.

We now examine in more detail why this suﬃces. Suppose
∗
1 is meant to input m values to be shared, in
a corrupt P
the actual protocol Π(cid:2)·(cid:3). A dummy value x0 ∈ F is sampled,
and P

∗
1 , P2 can obtain MAC shares such that:

1 ’s inputs to FCOPEe. In the MAC check of
∗
where xh are P
the Input stage, the parties sample a random r ∈ Fl+1, and
∗
∗
1 can force to be any
1 then opens the value y, which P
P
value. Next, P2 computes during steps 8–9 the values:

lX

rh · m(2)
m(2) =
σ(2) = m(2) − y · Δ.

h=0

h

⇔ σ(1) −

X

h

h = y · Δ − lX

rh · m(1)

h=0

rh · (cid:3)g ∗ xh, ΔB(cid:4).

(1)

Since rh, m(1)

h are known to P

Clearly, one way of achieving this is letting xh = (xh, . . . , xh)

∗
1 , this is equivalent to guess-
ing the right-hand side of (1), after choosing xh (indepen-
dently of rh) and y.
P
for some xh ∈ F, which implies that (cid:3)g ∗ xh, ΔB(cid:4) = xh · Δ,
h=0 rh · xh. This corresponds to the hon-
and letting y =
est behavior. Otherwise, we prove in the full version that
∗
1 , passing the check implies being able to compute a
for P
correct MAC share for xh. Once a correct MAC share for
a speciﬁc value is known, passing a later MAC check for
another value implies knowledge of the MAC key.
for some xh (cid:14)= 0, h ∈ [l]. This implies that

As an example, consider the case of xh = (0, xh, . . . , xh)

l

lX

i=0

rh · (cid:3)g ∗ xh, ΔB(cid:4) =

lX
lX

h=0

rh · (xh · Δ − xh · Δ1)

rh · xh · (Δ − Δ1),

where Δ1 denotes the ﬁrst bit of ΔB. Deﬁne Δ
Then, (1) can be written as

σ(1) − lX
P

h=0

h = (y − lX

h=0

rh · m(1)
h=0 rh · xh, P

l

(cid:4)

= Δ − Δ1.

rh · xh · Δ1.

(cid:4) − lX

h=0

rh · xh) · Δ

If y (cid:14)=
the check. Otherwise, P
by “guessing” Δ1. If successful, P
Δ1, which is a correct MAC share for xh because

∗
1 has only negligible chance of passing
∗
1 can succeed with probability 1/2
h + xh ·

∗
1 can compute m(1)
h = (cid:3)g ∗ xh, ΔB(cid:4) + xh · Δ1

h + xh · Δ1 + m(2)
m(1)

m(1)

h + m(2)

h = (cid:3)g ∗ xh, ΔB(cid:4),

for h = 0, . . . , l

=

h=0

∗
1 must then come up with a value σ(1) such that σ(1) +

P

σ(2) = 0, which implies:

σ(1) = −σ(2) = y · Δ − lX

rh · ((cid:3)g ∗ xh, ΔB(cid:4) − m(1)
h )

0 =

h=0

h=0

∗
1 is eﬀectively committed to xh. Finally,

This means that P
the simulation involves solving

D

g · y − g ∗ lX

E

rh · xh, ˜ΔB

= (cid:3)g · xh, ΔB(cid:4)
= xh · Δ.

836Protocol 3 Π(cid:2)·(cid:3), creating (cid:2)·(cid:3) elements
This protocol additively shares and authenticates inputs in
F, and allows linear operations and openings to be carried
out on these shares. Note that the Initialize procedure only
needs to be called once, to set up the MAC key.
Initialize:

Each party Pi samples a MAC key share
Δ(i) ∈ F. Each pair of parties (Pi, Pj) (for i (cid:14)= j) calls
FCOPEe.Initialize(F) where Pj inputs Δ(j).

Input: On input (Input, id1, . . . , idl, x1, . . . , xl, Pj) from Pj

and (Input, id1, . . . , idl, Pj) from all other parties:

$← F.

P

1: Pj samples x0
2: For h = 0, . . . , l, Pj generates a random additive
3: For every i (cid:14)= j, Pi and Pj call FCOPEe.Extend, where

sharing
Pj inputs (x0, . . . , xl) ∈ Fl+1.

h = xh and sends x(i)

h to Pi.

i x(i)

4: Pi receives q(i,j)

and Pj receives t(j,i)

such that

h

h

q(i,j)
h + t(j,i)

h = xh · Δ(i), for h = 0, . . . , l.

5: Each Pi, i (cid:14)= j, deﬁnes the MAC shares m(i)

h = q(i,j)

h

,

and Pj computes the MAC shares

h = xh · Δ(j) +
m(j)

t(j,i)
h

X

j(cid:5)=i

to obtain (cid:2)xh(cid:3), for h = 0, . . . , l.

P
6: The parties sample r ← FRand(Fl+1).
P
h=0 rh · xh.
7: Pj computes and broadcasts y =
h=0 rh · m(i)
8: Each party Pi computes m(i) =
h .
9: The parties execute ΠMACCheck with y and {m(i)}i∈[n].

l

l

10: All parties store their shares and MAC shares under

the handles id1, . . . , idl.

Linear comb.:

input

(LinComb, id, id1, . . . , idt, c1, . . . , ct, c),
On
the parties retrieve their shares and MAC shares
j , m(xj)(i)}j∈[t],i∈[n] corresponding to id1, . . . , idt,
{x(i)
and each Pi computes:

(

y(i) =

m(y)(i) =

j +

cj · x(i)

c
i = 1
0 i (cid:14)= 1
cj · m(xj)(i) + c · Δ(i),

tX
tX

j=1

j=1

P

They then store the new share and MAC of (cid:2)y(cid:3) under
the handle id.

Open: On input (Open, id):

1: Each Pi retrieves and broadcasts their share x(i).
i=1 x(i) and output it.
2: Parties reconstruct x =

n

Check: On input (Check, id1, . . . , idt, x1, . . . , xt), the par-

2: Compute y ←P

ties do the following:
1: Sample a public, random vector r ← FRand(Ft).

j=1 rj · xj and m(y)(i) ←P

j=1 rj ·
idj denotes Pi’s MAC share stored un-

m(i)
idj , where m(i)
der idj for all i ∈ [n] and j ∈ [t].

t

t

3: Execute ΠMACCheck with y and m(y)(i).

lX

=

h=0

rh · xh · ˜Δ1

for ˜Δ. Clearly, the ﬁrst bit of any solution ˜Δ must be zero.
It is easy to see that
−1 · (cid:3)g ∗ xh, ˜Δ(cid:4) = xh
˜Δ

We need that, once P

for any such ˜Δ. This is how the simulator in our proof
∗
1 is committed to after passing the
computes the value P
check.

∗
1 has passed the check in the input
phase, they are committed to a particular value. However,
the adversary has an edge because only a random combina-
tion of inputs can be checked (otherwise all the inputs would
be revealed). This can be seen as follows: Denote by xh,g the
g-th entry of the vector xh input when authenticating the
h-th value, and denote by {rh}h∈[l] the random coeﬃcients
P
(cid:4) ∈ [k], if xh,g (cid:14)= xh,g(cid:2) , there
generated using FRand. For g (cid:14)= g
is a 1/|F| chance that
rhxh,g(cid:2) . Because the
check only relates to the randomly weighted sum, the adver-
sary could therefore act as if xh,g = xh,g(cid:2) and decide later
between {xh,g}h∈[l] and {xh,g(cid:2)}h∈[l]. The fact that there are
explains the 2 log log |F|
log |F|(log |F|−1)/2 such pairs g (cid:14)= g
subtrahend in the theorem below. It is easy to see that a
repeated check would suﬃce for security parameter log |F|.

rhxh,g =

P

(cid:4)

Extension to more than two parties.

P

Extending the authentication protocol to n parties is rela-
tively straightforward. When party Pj is inputing a value x,
Pj runs FCOPEe (on input x) with every other party Pi (cid:14)= Pj,
who each inputs the MAC key share Δ(i). Summing up
these outputs allows Pj to obtain an authenticated share
i Δ(i). Note that this
under the global MAC key, Δ =
introduces further potential avenues for cheating, as Pj may
provide inconsistent x’s to FCOPEe with diﬀerent parties, and
the other parties may not use the correct Δ(i). However, it
is easy to see that except with probability 1/|F|, these devi-
ations will cause the MAC check to fail in the Input stage,
so are not a problem.

The security of our authentication and MAC checking pro-
tocols is given formally in the following theorem, which we
prove in the full version [27].

Theorem 2. The protocol Π(cid:2)·(cid:3) securely implements F(cid:2)·(cid:3)
in the (FCOPEe,FComm,FRand)-hybrid model, with statistical
security parameter log |F| − 2 log log|F|.

5. MULTIPLICATION TRIPLES

USING OBLIVIOUS TRANSFER

In the previous section we showed how parties can com-
pute linear functions on their private inputs using the au-
thentication and MAC checking protocols. We now extend
this to arbitrary functions, by showing how to create multi-
plication triples using F(cid:2)·(cid:3) and OT.
Recall that a multiplication triple is a tuple of shared val-
ues ((cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3)) where a, b $← F and c = a·b. Given F(cid:2)·(cid:3) and
a protocol for preprocessing triples, the online phase of the
resulting MPC protocol is straightforward, using Beaver’s
method for multiplying two secret-shared values [4]. For
completeness, this is detailed in the full version [27].

Throughout this section, we write (cid:2)x(cid:3) to mean that each
party holds a random, additive share of x, and the value of
x is stored in the ideal functionality F(cid:2)·(cid:3).
The protocol ΠTriple (Protocol 4) begins with the Multi-
ply step, which uses FOT to compute a secret sharing of the

837Protocol 4 Triple generation protocol, ΠTriple
The integer parameter τ ≥ 3 speciﬁes the number of triples
to be generated per output triple.
Multiply:

1: Each party samples a(i) $← Fτ , b(i) $← F.
2: Every ordered pair of parties (Pi, Pj) does the follow-

ROT where Pi

inputs

ing:
(a) Both parties
1 , . . . , a(i)

(a(i)

τ k) = g

call F τ k,k
−1(a(i)) ∈ Fτ k
2 .

(b) Pj receives q(j,i)

0,h , q(j,i)

1,h

∈ F and Pi receives s(i,j)

h =

q(j)
(i)
a
h ,h

, for h = 1, . . . , τ k.

(c) Pj sends d(j,i)
(d) Pi sets t(i,j)

h = s(i,j)

h = q(j,i)

0,h

− q(j,i)
h +a(i)·d(j,i)

1,h + b(j), h ∈ [τ k].
h = q(j,i)
0,h +a(i)

h

·b(j),

for h = 1, . . . , τ k. Set q(j,i)

h = q(j,i)
0,h .
, . . . , q(j,i)

(e) Split (t(i,j)

, . . . , t(i,j)

τ k ) intoτ
vectors of k components each, (t1, . . . , tτ ) and
(q1, . . . , qτ ).

τ k ) and (q(j,i)

1

1

(f) Pi sets c(i)
(g) Pj sets c(j)
(h) Now we have

i,j = ((cid:3)g, t1(cid:4), . . . , (cid:3)g, tτ(cid:4)) ∈ Fτ .
i,j = −((cid:3)g, q1(cid:4), . . . , (cid:3)g, qτ(cid:4)) ∈ Fτ .

c(i)
i,j + c(j)
3: Each party Pi computes:

i,j = a(i) · b(j) ∈ F

τ

c(i) = a(i) · b(i) +

(c(i)

i,j + c(i)
j,i )

X

j(cid:5)=i

Combine:

1: Sample r, ˆr ← FRand(Fτ ).
2: Each party Pi sets
a(i) = (cid:3)a(i), r(cid:4),
ˆa(i) = (cid:3)a(i), ˆr(cid:4),

c(i) = (cid:3)c(i), r(cid:4)
ˆc(i) = (cid:3)c(i), ˆr(cid:4)

and

Authenticate:

Each party Pi runs F(cid:2)·(cid:3).Input on their
shares to obtain authenticated shares (cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3), (cid:2)ˆa(cid:3), (cid:2)ˆc(cid:3).
Sacriﬁce: Check correctness of the triple ((cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3)) by

sacriﬁcing (cid:2)ˆa(cid:3), (cid:2)ˆc(cid:3).
1: Sample s ← FRand(F).
2: Call F(cid:2)·(cid:3).LinComb to store s · (cid:2)a(cid:3) − (cid:2)ˆa(cid:3) under (cid:2)ρ(cid:3).
3: Call F(cid:2)·(cid:3).Open on input (cid:2)ρ(cid:3) to obtain ρ.
4: Call F(cid:2)·(cid:3).LinComb to store s · (cid:2)c(cid:3) − (cid:2)ˆc(cid:3) − (cid:2)b(cid:3) · ρ under
5: Run F(cid:2)·(cid:3).Check((cid:2)ρ(cid:3), (cid:2)σ(cid:3), ρ, 0) and abort if F(cid:2)·(cid:3) aborts.

(cid:2)σ(cid:3).

Output:

((cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3)) as a valid triple.

product of b ∈ F and a ∈ Fτ , where τ ≥ 3 is a parame-
ter aﬀecting security. This is done by running τ copies of
the basic two-party product sharing protocol between every
pair of parties (steps (a)–(g)), followed by each party locally
summing up their shares.

During this stage, a corrupt Pj may attempt to guess some
bits of a by using values other than b(j) in step (c). This is
why we start with τ components for a instead of just one,
ensuring that a still has suﬃcient randomness to produce a
triple. Note that there is no need for privacy ampliﬁcation
on b, which is already protected by the protocol because the

− q(j,i)

shares b(j) are only used to compute d(j,i) = q(j,i)
1,h +
0,h
b(j), which is uniformly random because Pj learns only one
of q(j,i)

0,h and q(j,i)
1,h .
After the Multiply step, the parties have an additively
shared triple (a, b, c), which may be incorrect if someone was
dishonest. In the Combine step, they take random linear
combinations of the τ components of (a, b, c) using random
r and ˆr in Fτ obtained from FRand. By using two sets of
random coeﬃcients, this produces two triples with the same
b component; later, one of these will be ‘sacriﬁced’ to check
correctness of the other.

Using random combinations ensures that even if a few bits
of the vector a are leaked to the adversary, the values a, ˆa
are still statistically close to uniform. The parties then use
F(cid:2)·(cid:3) to Authenticate their shares of a, ˆa, b, c and ˆc.

Finally, correctness of the triple (cid:2)a(cid:3), (cid:2)b(cid:3), (cid:2)c(cid:3) is checked in
a Sacriﬁce phase, using (cid:2)ˆa(cid:3) and (cid:2)ˆc(cid:3). The idea of this step
is similar to the corresponding step in previous works [15,
17], with the key diﬀerence that in our case both triples
have the same b value. We observe that this still suﬃces to
check correctness of the triples, and means we only need to
authenticate 5 values instead of 6.
5.1 Security analysis

Then, for each i (cid:14)∈ A, let δ(j,i)

We now give some more intuition behind the security of
the protocol. Let us ﬁrst examine the possible adversarial
deviations in the Multiply step.
Suppose Pj is corrupt. Let a(j,i) ∈ Fτ and b(j,i) ∈ Fτ k be
the actual values used by Pj in the two executions of steps 1
and 3 with an honest Pi, instead of a(j) and b(j). Deﬁne the
values a(j) and b(j) to be those values used in the instance
with an arbitrary (e.g. lowest index) honest party Pi0 .
a = a(j,i) − a(j) ∈ Fτ and
= b(j,i) − (b(j), . . . , b(j)) ∈ Fτ k be the deviation in
P
and

δ(j,i)
b
Pj’s input with an honest Pi. Let δ(i)
a =
δ(i)
as a length τ vector
b =
with components in Fk (similarly to th, qh in the protocol).
Now by analyzing the possible adversarial deviations and
summing up shares, we can see that the h-th component of
c (for h ∈ [τ ]), at the end of the Multiply stage, is
b(i) · δ(i)
c[h] =a[h] ·b+
{z

X
(cid:3)(a(i)[h])B, δ(i)
|

, and consider δ(i)
b

b [h](cid:4)
}

X
|

P

{z

a [h]

δ(j,i)

δ(j,i)

. (2)

j∈A

j∈A

i(cid:5)∈A

i(cid:5)∈A

}

+

a

b

=eah

=ebh

Intuitively, it is easy to see that any non-zero δ(i)
a

errors
will be blown up by the random honest party’s share b(i),
so should result in an incorrect triple with high probability.
On the other hand, the δ(i)
errors can be chosen so that eah
b
only depends on single bits of the shares a(i). This means
that a corrupt party can attempt to guess a few bits (or
linear combinations of bits) of a(i). If this guess is incorrect
then the resulting triple should be incorrect; however, if all
guesses succeed then the triple is correct and the sacriﬁce
step will pass, whilst the adversary learns the bits that were
guessed.

This potential leakage (or selective failure attack ) is mit-
igated by the Combine stage. The intuition here is that,
to be able to guess a single bit of the ﬁnal shares a(i), ˆa(i),
the adversary must have guessed many bits from the input
vector a(i), which is very unlikely to happen. To prove this

838intuition, we analyze the distribution of the honest party’s
output shares using the Leftover Hash Lemma, and show
that if τ is large enough, the combined output is statisti-
cally close to uniform to the adversary.
opens ρ = s · a − ˆa and then checks that

Regarding the Sacriﬁce stage, note that the check ﬁrst

s · c − ˆc − b · ρ = 0

which is equivalent to s · (c − a · b) = ˆc − ˆa · b. If the triples
are incorrect then this will only pass with probability 1/|F|,
since s is random and unknown when the triples are authen-
ticated.

The following results (proven in the full version [27]) state
the security of our protocol. The ﬁrst requires the combining
parameter set to τ = 4, to obtain a a general result for
any k-bit ﬁeld, whilst the second (which is evident from the
proof of the theorem) shows that for k-bit ﬁelds and k/2-bit
statistical security, τ = 3 suﬃces.

Theorem 3. If τ = 4 then the protocol ΠTriple (Protocol 4)
securely implements FTriple in the (FROT,F(cid:2)·(cid:3))-hybrid model
with statistical security parameter k.

Corollary 1. If τ = 3 then ΠTriple securely implements
FTriple in the (FROT,F(cid:2)·(cid:3))-hybrid model with statistical secu-
rity parameter k/2.

6. PERFORMANCE

We ﬁrst analyse the complexity of our preprocessing pro-
tocol, and then describe our implementation and experi-
ments.
6.1 Complexity

We measure the communication complexity of our pro-
tocol in terms of the total amount of data sent across the
network. Note that the number of rounds of communication
is constant ((cid:16) 100), so is unlikely to heavily impact per-
formance when generating large amounts of preprocessing
data. Throughout this section, we exclude the cost of the λ
base OTs (between every pair of parties) in the initialization
stages, as this is a one-time setup cost that takes less than
a second using [12].

Input tuple generation.
The main cost of authenticating one party’s ﬁeld element
in a k-bit ﬁeld with Π(cid:2)·(cid:3) is the n − 1 calls to ΠCOPEe, each of
which sends k2 bits, plus sending n − 1 shares of k bits, for
a total of (n− 1)(k2 + k) bits. We ignore the cost of authen-
ticating one extra value and performing the MAC check, as
this is amortized away when creating a large batch of input
tuples.

Triple generation.
To generate a triple, each pair of parties makes τ k calls
to FROT, followed by sending a further τ k2 bits in step (c)
and then 5 calls to ΠCOPEe for authentication (ignoring FRand
and sending the input shares as these are negligible). Since
each call to FROT requires communicating λ bits, and ΠCOPEe
requires k2 bits, this gives a total of n(n−1)(τ λk+(τ +5)k2)
bits sent across the network.

Table 2 shows these complexities for a few choices of ﬁeld
size, with λ = 128 and τ chosen to achieve at least 64 bit

statistical security. We observe that as k increases, the cost
of inputs scales almost exactly quadratically. For triples,
k = 64 is slightly less eﬃcient as we require τ = 4 (instead of
3), whilst for larger k the cost reduces slightly as k becomes
much larger than λ. Note also that the cost of an input
is much lower than a triple, as the input protocol does not
require any of the expensive sacriﬁcing or combining that
we use to obtain active security with triples. This is in
contrast to the SPDZ protocol [15, 17], where creating input
tuples requires complex zero-knowledge or cut-and-choose
techniques.

Comparison with a passive protocol.

A passively secure (or semi-honest) version of our proto-
col can be constructed by setting τ = 1 and removing the
authentication step, saving 5 calls to ΠCOPEe for every pair
of parties. Note that for two parties this is essentially the
same as the protocol in ABY [18]. The communication cost
of a single triple is then n(n − 1)(λk + k2) bits. For triples
where k ≥ 128, and 64-bit statistical security, the actively
secure protocol achieves τ = 3, so is just 5.5 times the cost
of the passive variant.

Field bit length

64
128
256
512

Input cost (kbit)

4.16(n − 1)
16.51(n − 1)
65.79(n − 1)
262.66(n − 1)

Triple cost (kbit)
53.25n(n − 1)
180.22n(n − 1)
622.59n(n − 1)
2293.76n(n − 1)

Table 2: Communication cost of our protocols for
various ﬁeld sizes, with n parties.

6.2

Implementation

As part of our implementation, we have used the opti-
mizations described below. The ﬁrst two apply to the OT
extension by Keller et al. [26].

Bit matrix transposition.

Asharov et al. [2] mention the bit matrix transposition as
the most expensive part of the computation for their OT
extension. They propose Eklundh’s algorithm to reduce the
number of cache misses. Instead of transposing a matrix bit
by bit, the matrix is transposed with respect to increasingly
small blocks while leaving the blocks internally intact. Keller
et al. also use this algorithm.
However, for security parameter λ, the OT extension re-
quires the transposition of a n × λ-matrix. We store this
matrix as list of λ × λ-blocks, and thus, we only have to
transpose those blocks. For λ = 128, one such block is 2
KiB, which easily ﬁts into the L1 cache of most modern
processors.

Furthermore, we use the PMOVMSKB instruction from
SSE2. It outputs a byte consisting of the most signiﬁcant
bits of 16 bytes in a 128-bit register. Together with a left
shift (PSLLQ), this allows a 16 × 8-matrix to be trans-
posed [33] with only 24 instructions (eight of PMOVSKB,
PSLLQ, and MOV each).

Pseudorandom generator and hashing.

Keller et al. [26] used AES-128 in counter mode to imple-
ment the PRG needed for the OT extension. This allows to

839use the AES-NI extension provided by modern processors.
We have also implemented the hash function using AES-
128 by means of the Matyas–Meyer–Oseas construction [32],
which was proven secure by Black et al. [7]. This construc-

tion uses the compression function hi = Eg(hi−1)(mi) ⊕ mi,
where mi denotes the i-th message block, hi is the state
after the i-th compression, and g denotes a conversion func-
tion. In our case, the input is only one block long (as many
bits as the computational security parameter of the OT ex-
tension), and g is the identity. This gives a hash function
H(m) =E IV (m) ⊕ m for some initialization vector IV ,
which allows to precompute the key schedule. This pre-
computation in turn allows to easily take advantage of the
pipelining capabilities of AES-NI in modern Intel proces-
sors: While the latency of the AESENC instruction is seven
clock cycles, the throughput is one per clock cycle [22]. This
means that the processor is capable of computing seven en-
cryptions in parallel.

. Elements of both F

Inner product computation.
Both ΠCOPEe and ΠTriple involve the computation of (cid:3)g, x(cid:4)
for x ∈ Flog |F|
2k and Fp are commonly
represented as elements of larger rings (F2[X] and Z, respec-
tively), and some operations involves a modular reduction
(modulo an irreducible polynomial or p). When computing,
we defer this reduction until after computing the sum. Fur-
thermore, we use the mpn_* functions of MPIR [40] for the
large integer operations for Fp. For F
2k on the other hand,
the computation before the modular reduction is straight-
forward because addition in F2[X] corresponds to XOR.

Multithreading.

In order to make optimal use of resources, we have or-
ganized the triple generation as follows: There are several
threads independently generating triples, and every such
thread controls n − 1 threads for the OTs with the n − 1
other players. Operations independent of OT instances, such
as ampliﬁcation and sacriﬁcing, are performed by the triple
generation threads. We found that performance is optimal
if the number of generator threads is much larger than the
number of processor cores. This is an indication that the
communication is the main bottleneck.
6.3 Experiments

We have tested our implementation for up to ﬁve parties
on oﬀ-the-shelf machines (eight-core i7 3.1 GHz CPU, 32 GB
RAM) in a local network. Fig. 4 shows our results.

We could generate up to 4800 and 1000 F2128 triples per
second with two and ﬁve parties, respectively, using 100
threads. For Fp with p a 128-bit prime, the ﬁgures are the
same. These ﬁgures come close to the maximum possible
throughput of the correlation steps, which is 5500 and 1400,
respectively. The maximum ﬁgures are computed from the
analysis above, with τ = 3 and k = λ = 128. Assuming a 1
Gbit/s link per party and unlimited routing capacity gives
the desired result.

Using just a single thread, we can produce 2000 triples/s
with two parties, which is still over 72 times faster than the
single-threaded implementation of SPDZ [15].

By increasing the bandwidth to 2 Gbit/s, we could in-
crease the throughput to 9500 and 1600 triples per seconds
for two and ﬁve parties, respectively. This conﬁrms the ob-
servation that the communication is the main bottleneck.

F

F

2k , 1 thread
2k , 10 threads
2k , 100 threads
F
Fp, 100 threads

)
s
/
(

t
u
p
h
g
u
o
r
h
T

5,000

4,000

3,000

2,000

1,000

0

2

3

4

5

Number of parties

Figure 4: Triple generation throughput for 128-bit
ﬁelds.

1.2

1

0.8

0.6

0.4

0.2

0

)
s
/
(

t
u
p
h
g
u
o
r
h
T

·104

11,000

9,515

5,500

4,828

241

275

50Mbps WAN 1Gbps LAN

2Gbps LAN

Actual Max. possible

Figure 5: Throughput and maximum possible
throughput for diﬀerent networks with two parties

Fig. 5 shows the throughput for two parties in various net-
work environments. The WAN environment was simulated
over a LAN by restricting bandwidth to 50 Mbit/s and a
round-trip latency of 100 ms.

6.3.1 Vickrey Auction
To highlight the practicality of our protocol, we have im-
plemented the Vickrey second-price auction. Figure 6 shows
the results for the oﬄine and online phase run between two
parties on a local network. This clearly illustrates the 200-
fold performance improvement of our protocol, compared
with (actively secure) SPDZ. Now the preprocessing phase
in within 2–3 orders of magnitude of the online phase.

840s
d
n
o
c
e
s

n

i

e
m
T

i

104

102

100

−2

10

100

101

102

103

Number of bids

SPDZ oﬄine phase
MASCOT oﬄine phase
Online phase

[8] Bogdanov, D., J˜oemets, M., Siim, S., and Vaht,

M. How the Estonian tax and customs board
evaluated a tax fraud detection system based on secure
multi-party computation. In Financial Cryptography
and Data Security - 19th International Conference,
FC 2015, Revised Selected Papers (2015), pp. 227–234.

[9] Bogdanov, D., Kamm, L., Kubo, B., Rebane, R.,
Sokk, V., and Talviste, R. Students and taxes: a
privacy-preserving social study using secure
computation. IACR Cryptology ePrint Archive (2015).

[10] Burra, S. S., Larraia, E., Nielsen, J. B.,
Nordholt, P. S., Orlandi, C., Orsini, E.,
Scholl, P., and Smart, N. P. High performance
multi-party computation for binary circuits based on
oblivious transfer. Cryptology ePrint Archive, Report
2015/472, 2015. http://eprint.iacr.org/.

[11] Canetti, R. Universally composable security: A new
paradigm for cryptographic protocols. In 42nd Annual
Symposium on Foundations of Computer Science,
FOCS (2001), pp. 136–145.

Figure 6: Vickrey auction run by two parties.

[12] Chou, T., and Orlandi, C. The simplest protocol

Acknowledgements
We thank Claudio Orlandi and the anonymous reviewers for
valuable feedback that helped to improve the presentation.

References
[1] The Sharemind project. http://sharemind.cs.ut.ee,

2007.

[2] Asharov, G., Lindell, Y., Schneider, T., and
Zohner, M. More eﬃcient oblivious transfer and
extensions for faster secure computation. In
Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security (2013), ACM,
pp. 535–548.

[3] Baum, C., Damg˚ard, I., Toft, T., and Zakarias,

R. Better preprocessing for secure multiparty
computation. IACR Cryptology ePrint Archive (2016).

[4] Beaver, D. Eﬃcient multiparty protocols using
circuit randomization. Advances in Cryptology -
CRYPTO 1991 (1992).

[5] Beaver, D. Correlated pseudorandomness and the

complexity of private computations. In Proceedings of
the Twenty-Eighth Annual ACM Symposium on the
Theory of Computing (1996), G. L. Miller, Ed., ACM,
pp. 479–488.

[6] Bendlin, R., Damg˚ard, I., Orlandi, C., and
Zakarias, S. Semi-homomorphic encryption and
multiparty computation. In Advances in Cryptology -
EUROCRYPT 2011 (2011), pp. 169–188.

[7] Black, J., Rogaway, P., Shrimpton, T., and

Stam, M. An analysis of the blockcipher-based hash
functions from PGV. J. Cryptology 23, 4 (2010),
519–545.

for oblivious transfer. In Progress in Cryptology -
LATINCRYPT 2015 - 4th International Conference
on Cryptology and Information Security in Latin
America (2015), pp. 40–58.

[13] Damg˚ard, I., Damg˚ard, K., Nielsen, K.,

Nordholt, P. S., and Toft, T. Conﬁdential
benchmarking based on multiparty computation. In
Financial Cryptography (2016).

[14] Damg˚ard, I., Keller, M., Larraia, E., Miles, C.,

and Smart, N. P. Implementing AES via an
actively/covertly secure dishonest-majority MPC
protocol. In SCN (2012), I. Visconti and R. D. Prisco,
Eds., vol. 7485 of Lecture Notes in Computer Science,
Springer, pp. 241–263.

[15] Damg˚ard, I., Keller, M., Larraia, E., Pastro,

V., Scholl, P., and Smart, N. P. Practical covertly
secure MPC for dishonest majority - or: Breaking the
SPDZ limits. In ESORICS (2013), J. Crampton,
S. Jajodia, and K. Mayes, Eds., vol. 8134 of Lecture
Notes in Computer Science, Springer, pp. 1–18.

[16] Damg˚ard, I., and Orlandi, C. Multiparty

computation for dishonest majority: From passive to
active security at low cost. In Advances in Cryptology
- CRYPTO (2010), pp. 558–576.

[17] Damg˚ard, I., Pastro, V., Smart, N. P., and

Zakarias, S. Multiparty computation from somewhat
homomorphic encryption. In Advances in Cryptology –
CRYPTO 2012 (2012), R. Safavi-Naini and
R. Canetti, Eds., vol. 7417 of Lecture Notes in
Computer Science, Springer, pp. 643–662.

[18] Demmler, D., Schneider, T., and Zohner, M.

ABY - A framework for eﬃcient mixed-protocol secure
two-party computation. In 22nd Annual Network and
Distributed System Security Symposium, NDSS
(2015), The Internet Society.

841[19] Frederiksen, T. K., Keller, M., Orsini, E., and

Scholl, P. A uniﬁed approach to MPC with
preprocessing using OT. In Advances in Cryptology –
ASIACRYPT 2015, Part I (2015), T. Iwata and J. H.
Cheon, Eds., vol. 9452 of Lecture Notes in Computer
Science, Springer, pp. 711–735.

[20] Gilboa, N. Two party RSA key generation. In

Advances in Cryptology - CRYPTO (1999),
pp. 116–129.

[21] Goldreich, O., Micali, S., and Wigderson, A.

How to play any mental game or A completeness
theorem for protocols with honest majority. In
Proceedings of the 19th Annual ACM Symposium on
Theory of Computing (1987), pp. 218–229.

[22] Intel. Intel intrinsics guide. https://software.intel.

com/sites/landingpage/IntrinsicsGuide, 2016. Online;
accessed February 2016.

[23] Ishai, Y., Kilian, J., Nissim, K., and Petrank, E.
Extending oblivious transfers eﬃciently. In Advances
in Cryptology - CRYPTO (2003), pp. 145–161.

[24] Ishai, Y., Prabhakaran, M., and Sahai, A. Secure

arithmetic computation with no honest majority. In
Reingold [39], pp. 294–314.

[25] Kamm, L., and Willemson, J. Secure ﬂoating point

arithmetic and private satellite collision analysis.
International Journal of Information Security 14, 6
(2015), 531–548.

[26] Keller, M., Orsini, E., and Scholl, P. Actively

secure OT extension with optimal overhead. In
Advances in Cryptology - CRYPTO 2015, Part I
(2015), pp. 724–741.

[27] Keller, M., Orsini, E., and Scholl, P. MASCOT:

Faster malicious arithmetic secure computation with
oblivious transfer. Cryptology ePrint Archive, Report
2016/505, 2016. http://eprint.iacr.org/2014/505.

[28] Keller, M., Scholl, P., and Smart, N. P. An
architecture for practical actively secure MPC with
dishonest majority. In ACM Conference on Computer
and Communications Security (2013), pp. 549–560.

[29] Kreuter, B., Shelat, A., and Shen, C.

Billion-gate secure computation with malicious
adversaries. In Proceedings of the 21st USENIX
conference on Security symposium (2012), USENIX
Association, pp. 14–14.

[30] Larraia, E., Orsini, E., and Smart, N. P.

Dishonest majority multi-party computation for
binary circuits. In Advances in Cryptology - CRYPTO
2014, Part II (2014), pp. 495–512.

[31] Lindell, Y., and Riva, B. Blazing fast 2PC in the

oﬄine/online setting with security for malicious
adversaries. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications
Security (2015), pp. 579–590.

[32] Matyas, S. M., Meyer, C. H., and Oseas, J.

Generating strong one-way functions with
cryptographic algorithm. IBM Technical Disclosure
Bulletin 27, 10A (1985), 5658–5659.

[33] mischasan. What is SSE !@# good for? Transposing
a bit matrix. https://mischasan.wordpress.com/2011/
07/24/what-is-sse-good-for-transposing-a-bit-matrix,
2011. Online; accessed February 2016.

[34] Nielsen, J. B., Nordholt, P. S., Orlandi, C.,

and Burra, S. S. A new approach to practical
active-secure two-party computation. In Advances in
Cryptology–CRYPTO 2012. Springer, 2012,
pp. 681–700.

[35] Nielsen, J. B., and Orlandi, C. LEGO for

two-party secure computation. In Reingold [39],
pp. 368–386.

[36] Peikert, C., Vaikuntanathan, V., and Waters,

B. A framework for eﬃcient and composable oblivious
transfer. In Advances in Cryptology - CRYPTO
(2008), pp. 554–571.

[37] Pinkas, B., Schneider, T., Segev, G., and

Zohner, M. Phasing: Private set intersection using
permutation-based hashing. In 24th USENIX Security
Symposium, USENIX Security 15 (2015), pp. 515–530.

[38] Pinkas, B., Schneider, T., and Zohner, M. Faster

private set intersection based on OT extension. In
Proceedings of the 23rd USENIX Security Symposium
(2014), pp. 797–812.

[39] Reingold, O., Ed. Theory of Cryptography, 6th
Theory of Cryptography Conference, TCC (2009),
vol. 5444 of Lecture Notes in Computer Science,
Springer.

[40] The MPIR team. Multiple precision integers and

rationals. https://www.mpir.org, 2016. Online;
accessed February 2016.

[41] Yao, A. C. How to generate and exchange secrets
(extended abstract). In 27th Annual Symposium on
Foundations of Computer Science (1986).

842