ZKBoo: Faster Zero-Knowledge  

for Boolean Circuits

Irene Giacomelli, Jesper Madsen, and Claudio Orlandi, Aarhus University

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/giacomelli

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX ZKBoo: Faster Zero-Knowledge for Boolean Circuits

Irene Giacomelli

Jesper Madsen

Computer Science Department, Aarhus University

Claudio Orlandi

Abstract

In this paper we describe ZKBoo1, a proposal for practi-
cally efﬁcient zero-knowledge arguments especially tai-
lored for Boolean circuits and report on a proof-of-
concept implementation. As an highlight, we can gen-
erate (resp. verify) a non-interactive proof for the SHA-1
circuit in approximately 13ms (resp. 5ms), with a proof
size of 444KB.

Our techniques are based on the “MPC-in-the-head”
approach to zero-knowledge of Ishai et al. (IKOS), which
has been successfully used to achieve signiﬁcant asymp-
totic improvements. Our contributions include:
◦ A thorough analysis of the different variants of IKOS,
which highlights their pros and cons for practically rele-
vant soundness parameters;
◦ A generalization and simpliﬁcation of their approach,
which leads to faster Σ-protocols (that can be made
non-interactive using the Fiat-Shamir heuristic) for state-
ments of the form “I know x such that y = φ (x)” (where
φ is a circuit and y a public value);
◦ A case study, where we provide explicit protocols,
implementations and benchmarking of zero-knowledge
protocols for the SHA-1 and SHA-256 circuits.

1

Introduction

Since their introduction in the 80s [16], zero-knowledge
(ZK) arguments have been one of the main building
blocks in the design of complex cryptographic protocols.
However, due to the lack of practically efﬁcient solutions
for proving generic statements, their application in real-
world systems is very limited. In particular, while there
is a large body of work considering the efﬁciency of ZK
protocols for algebraic languages (following the seminal
work of Schnorr for discrete logarithm [26]), things are
quite different when it comes to general purpose ZK.

1Sounds like Peekaboo.

A notable exception is the recent

line of work
on succinct non-interactive arguments of knowledge
(SNARKs) (e.g. Pinocchio [23], libsnark [4], etc.).
SNARKs are an extremely useful tool when the size of
the proof and the veriﬁcation time matters: SNARKs are
less than 300 bytes and can be veriﬁed in the order of
5ms, which makes them perfect for applications such as
ZeroCash [3]. However, on the negative side, SNARKs
require very large parameters (which must be generated
in a trusted way) and the time to generate proofs are pro-
hibitive for many applications. As an example, the run-
ning time of the prover for generating a proof for SHA-
1 is in the order of 10 seconds. There is an inherent
reason for this inefﬁciency: current SNARKs technol-
ogy requires to perform expensive operations (in pairing
friendly groups) for each gate in the circuit.

Jawurek et al. [21] proposed a different approach to
efﬁcient ZK, namely using garbled circuits (GC). Using
GC, it is possible to prove any statement (expressed as
a Boolean circuit) using only a (low) constant number
of symmetric key operations per gate in the circuit, thus
decreasing the proving time by more than an order of
magnitude. On the ﬂip-side, GC-based ZK are inher-
ently interactive, and they still require a few public-key
operations (used for implementing the necessary oblivi-
ous transfers).

In this paper we describe efﬁcient ZK protocols for cir-
cuits based on the “MPC-in-the-head” paradigm of Ishai
et al. [19] (IKOS). In IKOS, a prover simulates an MPC
protocol between a number of “virtual” servers (at least
3) and then commits to the views and internal state of the
individual servers. Now the veriﬁer challenges the prover
by asking to open a subset of these commitments. The
privacy guarantee of the underlying MPC protocol guar-
antees that observing the state of a (sufﬁciently small)
subset of servers does not reveal any information. At the
same time, the correctness of the MPC protocol guaran-
tees that if the prover tries to prove a false statement,
then the joint views of some of the server must nec-

USENIX Association  

25th USENIX Security Symposium  1069

essarily be inconsistent, and the veriﬁer can efﬁciently
check that. By plugging different MPC protocols into
this approach, [19] shows how to construct ZK protocols
with good asymptotic properties. However, to the best
of our knowledge, no one has yet investigated whether
the IKOS approach can be used to construct practically
efﬁcient ZK protocols. This paper is a ﬁrst step in this
direction.

Structure of the paper.
In Section 3 we describe the
different variants of the IKOS framework. IKOS presents
two strategies to achieve a negligible soundness error: ei-
ther repeating a passive secure MPC protocol with few
parties, or using a single instance of an active secure
MPC protocol with a large number of parties. While
IKOS only provides asymptotic estimates of the sound-
ness parameters, we concretely estimate the soundness
of IKOS with different kind of MPC protocols and show
that, if one is interested in a (reasonable) soundness er-
ror of 2−80, then the version of IKOS without repetition
does not (unfortunately) lead to any practical advantage.
Then (in Section 4) we present a new interpretation of the
IKOS framework when instantiated with a 2-private 3-
party version of the GMW [15] protocol, where each pair
of parties is connected with an OT-channel. We observe
that in general the OT-channels can be replaced with ar-
bitrary 2-party functionalities. Since those ideal func-
tionalities do not have to be implemented using cryp-
tographic protocols (remember, they are executed be-
tween pair of virtual servers in a simulation performed by
the prover), this increases the degrees of freedom of the
protocol designer and allows to construct more efﬁcient
MPC protocols (or, as we prefer to call them, function
decompositions) that can be used for constructing ZK
protocols. (Note that this class of protocol has not been
studied before, since it does not lead to any advantage
in the standard MPC setting, and therefore we expect fu-
ture work to improve on our approach by designing bet-
ter MPC protocols for this special setting.) All resulting
protocols are Σ-protocols (3-move honest-veriﬁer zero-
knowledge protocols with special soundness) which can
therefore be made non-interactive in the random oracle
model using the Fiat-Shamir heuristic.

Finally (in Section 5) we describe how our approach
can be used to construct very efﬁcient ZK protocols for
proving knowledge of preimages for SHA-1 and SHA-
256. The resulting proofs are incredibly efﬁcient:
the
veriﬁcation time is essentially the same as the veriﬁca-
tion time for SNARKs, but the prover runs approximately
1000 times faster. On the negative side the size of our
proofs scales linearly with the circuit size, but we believe
that in some applications this is a desirable trade-off.

Recent Related Work. Ranellucci et al. [25] proposed
a general-purpose public-coin ZK protocol which can be
based on any commitment scheme. The asymptotic per-
formances are the same as ours (both communication and
computation complexity are linear in the circuit size) but
the concrete constants are higher (e.g., the proofs are ap-
proximately 3 times larger and computation more than
10 times slower). Hazay et al. [18] show how to extend
the IKOS technique to the case of two-party MPC proto-
cols (2PC) with application to adaptive ZK protocols. It
is an open question whether their approach might lead to
concrete efﬁciency improvements.

2 Preliminaries

Standard notations: For an integer n, we write [n] =
{1,2, . . . ,n} and, given A ⊆ [n], |A| denotes the cardi-
nality of A. We say that a function ε is negligible in
n, ε(n) =negl (n), if for every polynomial p there ex-
ists a constant c such that ε(n) < 1
p(n) when n > c.
Given two random variables X ad Y with support S,
the statistical distance between X and Y is deﬁned as
SD(X,Y ) = 1
2 ∑i∈S | Pr[X = i ]−Pr[Y = i ]|. Two families
X = {Xk} and Y = {Yk}, k ∈ {0,1}∗ of random variables
are said to be statistically indistinguishable if there exists
a negligible function ε(·) such that for every k ∈ {0,1}∗,
SD(Xk,Yk) ≤ ε(|k|). They are said to be computationally
indistinguishable if for every efﬁcient non-uniform dis-
tinguisher D there exists a negligible function ε(·) such
that for every k ∈ {0,1}∗, | Pr[D(Xk) =1] − Pr[D(Yk) =
1] ≤ ε(|k|).
2.1 Multi-Party Computation (MPC)
Consider a public function f : ({0,1}k)n → {0,1}(cid:27) and
let P1, . . . ,Pn be n players modelled as PPT machines.
Each player Pi holds the value xi ∈ {0,1}k and wants to
compute the value y = f (x) with x = (x1, . . . ,x n) while
keeping his input private. The players can communicate
among them using point-to-point secure channels CHi, j
in the synchronous model. These can be classical se-
cure channels (i.e. encrypted channels) or more powerful
channels (e.g. OT-channel [11, 24]). If necessary, we also
allow the players to use a broadcast channel. To achieve
their goal, the players jointly run a n-party MPC proto-
col Π f . The latter is a protocol for n players that is spec-
iﬁed via the next-message functions:
there are several
rounds of communication and in each round the player
Pi sends into the channel CHi, j (or in the broadcast chan-
nel) a message that is computed as a deterministic func-
tion of the internal state of Pi (his initial input xi and his
random tape ki) and the messages that Pi has received
in the previous rounds of communications. The view of
the player Pj, denoted by ViewPj (x), is deﬁned as the

1070  25th USENIX Security Symposium 

USENIX Association

concatenation of the private input x j, the random tape
k j and all the messages received by Pj during the ex-
ecution of Π f . Each channel CHi, j deﬁnes a relation of
consistency between views. For instance, in a plain chan-
nel two views are consistent if the messages reported in
ViewPj (x) as incoming from Pi are equal to the outgoing
message implied by ViewPi(x) (i (cid:31)= j). More powerful
channels (such as OT channels), are deﬁned via some
function ϕ and we say that two views are consistent if
the view of the sender implies an input x to the channel
and the view of the receiver implies an input y and con-
tains an output z such that z = ϕ(x,y). For instance, in
OT channels x = (m0,m1), y is a bit and z = my.

Finally, the output y can be computed from any of the
view ViewPi(x), i.e. there are n functions Π f ,1, . . . ,Π f ,n
such that y = Π f ,i(ViewPi(x)) for all i ∈ [n]. In order to
be private, the protocol Π f needs to be designed in such
a way that a curious player Pi can not infer information
about x j with j (cid:31)= i from his view ViewPi(x). An addi-
tional security property, robustness, assures that a cheat-
ing player Pi (who may not follow the instructions in the
protocol) can not mislead the honest players, who still
compute the correct output y. More precisely, we have
the following deﬁnition.
Deﬁnition 2.1.

• (Correctness) We say that the pro-
tocol Π f realizes f with perfect (resp. statistical)
correctness if for any input x = (x1, . . . ,x n), it holds
that Pr[ f (x) (cid:31)= Π f ,i(ViewPi(x)) ] = 0 (resp. negligi-
ble) for all i ∈ [n]. The probability is over the choice
of the random tapes ki.

• (Privacy) Let 1 ≤ t < n, the protocol Π f has perfect
t-privacy if it is correct and for all A ⊆ [n] satisfy-
ing |A| ≤ t there exists a PPT algorithm SA such that
the joint views (ViewPi(x))i∈A have the same distri-
bution as SA( f , (xi)i∈A,y), for all x = (x1, . . . ,x n).
statistical
We will
(resp. com-
putational)
the two distributions
SA( f , (xi)i∈A,y) and (ViewPi(x))i∈A are statistically
(resp. computationally) indistinguishable.

speak about
t-privacy if

• (Robustness) Let 0 ≤ r < n, the protocol Π f has
perfect (resp. statistical) r-robustness if it is correct
and for all A ⊆ [n] satisfying |A| ≤r even assuming
that all the players in A have been arbitrarily cor-
rupted, then Pr[ f (x) (cid:31)= Π f ,i(ViewPi(x)) ] = 0 (resp.
negligible) for all i ∈ Ac.

3 Zero Knowledge

In this section we recall the notion of zero-knowledge
and Σ-protocols, we review the IKOS construction [19]
for zero-knowledge, and we discuss different possible in-
stantiations.

3.1 Deﬁnitions
Let R ⊆ {0,1}∗ ×{0,1}∗ be a binary relation represent-
ing some computational problem (e.g. R = {(y,x)|y =
SHA-256(x)}). We will interpret R as a binary func-
tion from {0,1}∗ ×{0,1}∗ to {0,1} (i.e. R(y,x) = 1 ⇔
(y,x) ∈ R) and we will assume that:

• ∀ y and ∀ x, R(y,x) can be computed in polynomial-

time by a probabilistic Turing machine;

• there exists a polynomial p such that if R(y,x) =1

then the length of x is less or equal to p(|y|).

Such relation is called NP relation. With L we indi-
cate the set of the yes-instances of the relation R, i.e.
L = {y|∃x s.t. R(y,x) =1}.
An argument for L is a cryptographic protocols be-
tween two players: the prover P and the veriﬁer V with
the following features. We assume that both P and V
are probabilistic polynomial time (PPT) machines and
that they know y, an instance of the relation R. The sit-
uation is that P wants to convince V that y ∈ L. This
clearly makes sense only if the prover has some advan-
tage over the veriﬁer. Thus, we allow the prover to have
an extra private input (for example P knows x such that
R(y,x) = 1). The protocol is described by instructions
for the players and has different rounds of communi-
cation. At the end of the protocol, the veriﬁer outputs
accept if he is convinced or reject otherwise. If y ∈ L,
we require that an honest veriﬁer convinces an honest
prover with probability 1 (the protocol is complete). On
the other hand, we say that the protocol has soundness
error ε if for all y /∈ L Pr[V (y) =accept ] ≤ ε, no mat-
ter what the prover does. In other words, ε is an upper-
bound of the probability that a cheating prover makes an
honest veriﬁer output accept for a false instance.

However, in many interesting cryptographic applica-
tions, the language L is trivial and therefore the sound-
ness property gives absolutely no guarantees: for every
string y there exist a x s.t., y =SHA-256(x). In this case
we need a stronger property, namely proof-of-knowledge
(PoK), which informally states that the veriﬁer should
output accept only if the prover knows the value x.

Finally, ZK protocols get their name from the zero-
knowledge property: Here, we want to express the re-
quirement that whatever strategy a cheating veriﬁer fol-
lows, he learns nothing except for the truth of the
prover’s claim. In particular, he can not obtain informa-
tion about the private input of P. This is captured using
the simulation-paradigm and saying that the messages
received by the veriﬁer during the protocol can be efﬁ-
ciently simulated only knowing the public input y. More
precisely, we have the following requirement: for any
corrupted PPT veriﬁer V ∗, there is a PPT algorithm S
(the “simulator”) with access to V∗ such that the output

USENIX Association  

25th USENIX Security Symposium  1071

of S(y) and the real conversation between P and V∗ on
input y are indistinguishable.

In the rest of the paper we will be concerned with
public-coin two-party protocols with a speciﬁc commu-
nication pattern known as Σ-protocols.

Deﬁnition 3.1 (Σ-protocol). A protocol ΠR between two
players P and V is a Sigma Protocol for the relation R if
it satisﬁes the following conditions:

• ΠR has the following communication pattern:
1. (Commit) P sends a ﬁrst message a to V ;
2. (Challenge) V sends a random element e to P;
3. (Prove) P replies with a second message z.

• (Completeness) If both players P and V are honest

and y ∈ L, then Pr[ (P,V )(y) =accept ] = 1;

• (s-special soundness) For any y and any set of s ac-
cepting conversations {(a,ei,zi)}i∈[s] with ei (cid:26)= e j if
i (cid:26)= j, a witness x for y can be efﬁciently computed;
• (Special honest-veriﬁer ZK) There exists a PPT
simulator S such that on input y ∈ L and e outputs
a triple (a(cid:25),e,z(cid:25)) with same probability distribution
of real conversations (a,e,z) of the protocol.

Prover

Veriﬁer

commitment a

challenge e

openings z

Figure 1: The communication pattern of a Σ-protocol.

Σ-protocols have several properties (e.g. parallel com-
position, witness indistinguishability) that make them a
useful building block for many other cryptographic prim-
itives (identiﬁcation schemes, signatures, etc). See [7]
or [17, Chapter 6] for more details on this. Here we
are mainly interested in the following facts: First, Σ-
protocols are public-coin protocols and thus they can be
made non-interactive in the random oracle model using
the Fiat-Shamir heuristic [12]. Second, there exist efﬁ-
cient transformations from Σ-protocols to fully-ﬂedged
ZK and PoK: indeed, it is possible to efﬁciently trans-
form a Σ-protocol into a zero-knowledge argument (resp.
zero-knowledge proof of knowledge) with the addition of
one additional round (resp. two additional rounds). Note

ﬁnally that if the challenge e is chosen uniformly at ran-
dom form a set of cardinality c, then s-special soundness
implies a bound of (s−1)/c on the soundness error of the
protocol: if y (cid:26)∈ L, then there exist no x s.t. R(x,y) =1,
and therefore ﬁxed any a there are at most s − 1 chal-
lenges such that an accepting conversation for them ex-
ists.

IKOS Construction

3.2
In 2007 Ishai et al. show how to use any MPC proto-
col and the commitment-hybrid (Com) model2 to obtain
a ZK proof for an arbitrary NP relation R with asymp-
totically small soundness error. Here we brieﬂy recall
their construction and moreover we explicitly analyse its
soundness error.

Let Π f be an MPC protocol that realizes any n-party
function f with perfect correctness (Deﬁnition 2.1). De-
pending on the features of Π f (privacy, robustness, com-
munication channels used), [19] presents slightly differ-
ent ZK protocols. However, the general structure is al-
ways the same and is the structure of a Σ-protocol, see
Figure 1. The high-level idea is the following: assume
that y ∈ L is the public input of the ZK protocol, while x
is the private input of the prover (i.e. R(y,x) = 1). The
prover ﬁrst takes n random values x1, . . . ,x n such that
x = x1 ⊕···⊕ xn, then he considers the n-input function
fy deﬁned as

fy(x1,··· ,xn) := R(y,x1 ⊕···⊕x n)

and emulates “in his head” the protocol Π fy on in-
puts x1, . . . ,x n. After the emulation, he computes the
commitments to each of the n produced views (i.e.
Com(ViewPi(x)) for i = 1, . . . ,n). After all the commit-
ments have been stored, the veriﬁer challenges the prover
to open some of them (i.e. the challenge is a random sub-
set of [n] of a given size). Finally, the prover opens the
requested commitments and the veriﬁer outputs accept if
and only if all the opened views are consistent with each
other and with output 1.

Here we focus on the ZK protocols presented in [19]
that assume a perfectly correct (and eventually perfectly
robust) MPC protocol and we collect them in two ver-
sions. Version 1 considers the case of an MPC protocol
with t-privacy and perfect r-robustness with t > 1.3 Ver-
sion 2 shows that 2-privacy is not necessary condition
and indeed considers the case of an MPC protocol with
1-privacy only.

2In the commitment-hybrid model the two parties have access to an
idealized implementation of commitments, which can be imagined as
a trusted third party which stores the messages of the sender and only
reveals them if told so by the sender.

3This is a generalization of [19] as they only consider the case t = r.

1072  25th USENIX Security Symposium 

USENIX Association

IKOS Protocol (Version 1)

The veriﬁer and the prover have input y ∈ L. The
prover knows x such that R(y,x) =1. A perfectly
correct and t-private n-party MPC protocol Π fy is
given (2 ≤ t < n).
Commit: The prover does the following:

1. Sample random vectors x1, . . . ,x n s.t.

2. Run Π fy(x1, . . . ,x n) and obtain the views

x1 ⊕···⊕x n = x;
wi = ViewPi(x) for all i ∈ [n];

3. Commit to w1, . . . ,w n.

Prove: The veriﬁer chooses a subset E ⊆ [n] such
that |E| = t and sends it to the prover. The
prover reveals the value we for all e ∈ E.
Verify: The veriﬁer runs the following checks:

reject;

1. If ∃e ∈ E s.t. Π f ,e(ViewPe (x)) (cid:24)= 1, output
2. If ∃{i, j} ⊂E s.t. ViewPi(x) is not consis-
3. Output accept;

tent with ViewPj (x), output reject;

Figure 2: The IKOS zero-knowledge protocol for the re-
lation R in the commitment-hybrid model.

Version 1: Let t and r be two integers, 2 ≤ t < n and
0 ≤ r ≤ t. We assume that the protocol Π fy is perfectly
correct and satisﬁes two more properties: perfect, statis-
tical or computational t-privacy and perfect r-robustness.
In this version of the IKOS protocol (Figure 2) the veri-
ﬁer is allowed to ask for the openings of t of the commit-
ments Com(ViewPi(x)). In this way, the zero-knowledge
property follows easily by the t-privacy of the protocol
Π fy.

For the analysis of the soundness error of this proto-
col we use the so-called inconsistency graph G. Given
an execution of Π fy, the graph G has n nodes and there
is an edge (i, j) if and only if the views of the play-
ers Pi and Pj are inconsistent. Assume that y /∈ L and
that the execution of Π fy is not a correct one (otherwise
Pr[V (y) =accept ] =0 because of the checks in step 1 of
the procedure Verify). Then we have two cases:

1. There is in G a vertex cover set4 B of size at most

4B is a vertex cover set for the graph G if each edge in G is incident

to at least 1 node in B.

r. Intuitively, this means that in the current execu-
tion of Π fy only the players in B have been actively
corrupted. Indeed, if we remove the nodes in B, we
obtain a graph without edges. That is, all the play-
ers not in B have views consistent among them and
we can consider these players honest. Since the size
of B is less or equal to the parameter r, the robust-
ness property assures that for all the players not in
B (honest players) the view implies a 0 output (the
correct output of the protocol Π fy). The probabil-
ity that the veriﬁer will not see one of these views
choosing t of them uniformly at random is less or
equal to5

p1(n,t,r) =(cid:31)r

t(cid:30)−1
t(cid:30)(cid:31)n

2. If the size of the minimum vertex cover is > r, then
the graph G has a matching6 of size > r/2. The
probability that the veriﬁer accepts the wrong proof
is equal to the probability that between the t nodes
that he chooses there are no edges of G and this
is less or equal to the probability that there are no
edges from the matching. Clearly, this probabil-
ity reaches the maximum when the matching is the
smallest possible, that is it has size k = (cid:19)r/2(cid:18) + 1.
In this situation the aforementioned probability is

otherwise
if n− 2k > 0

p2(n,t,r) =(cid:29)0
(cid:28)∑k
j=0 2 j(cid:27)k

t− j(cid:26)(cid:25)(cid:27)n
j(cid:26)(cid:27)n−2k
t(cid:26)−1
In general, the soundness error is equal to the value
p(n,t,r) =max{ p1(n,t,r), p2(n,t,r)}.
Version 2: A second version of the protocol was pro-
posed in [20] to show that 2-privacy is not a necessary
condition for the IKOS construction. In other words, we
can construct ZK proofs in from 1-private MPC proto-
cols. Notice that in this case the MPC protocol is allowed
to use only standard point-to-point secure channels. The
idea of the construction is very similar to the previous

one, but now the prover commits to all the(cid:27)n
2(cid:26) channels
in addition to committing to the n views. The veriﬁer
picks a random i ∈ [n] and challenges the prover to open
the view of the player Pi and all the n− 1 channels CHi j
incident to him. Finally, the veriﬁer accepts if the opened
view is consistent with the channels and with the output
1. Again, the ZK property follows from the privacy prop-
erty of the MPC protocol: the information revealed to the
veriﬁer is implied by the view of a single player. To com-
pute the soundness error in this case, observe that for any

5(cid:27)r
t(cid:26) is 0 if r < t.

6A matching is a set of edges without common nodes.

USENIX Association  

25th USENIX Security Symposium  1073

)
t
,
t
,
4
2
(
p

1

0.8

0.6

0.4

0.2

0

Soundness error in IKOS (version 1)

5

10

15

20

Privacy parameter t

t
σ

15
8.7

16
19.5

17
18.4

18
17

19
15.4

20
13.4

Figure 3: The graph represents the soundness error
p(n,t,r) in function of t when t = r and n = 24. The
table shows the values of σ such that p(24,t,t) =2 −σ
for t ∈ {15, . . . ,20}.

incorrect execution of Π fy there is at least one player Pi
such that ViewPi(x) is inconsistent with a channel CHi j.
The probability Pr[V (y) =accept ] is less or equal to the
probability that V does not choose this index i. There-
fore, the soundness error of this version is 1− 1/n.
3.3 Our choice of version and parameters
In this section we discuss and motivate some of our de-
sign choices.

Which MPC protocol? As discussed, IKOS can be in-
stantiated with a large number of MPC protocols.
In
particular, using MPC protocols with good asymptotic
properties (such as [8, 9], etc.), one can obtain ZK proto-
cols with equally good asymptotic properties. However
in this paper we are concerned with concrete, constant
size circuits, and we do not want to put any restriction
on the shape or width of the circuits. Thus, the best two
choices are BGW [2] style protocols with t = r = (cid:27) n−1
3 (cid:26)
which use simple point-to-point channels and GMW [15]
style protocols with t = n− 1,r = 0 which use OT chan-
nels between each pair of parties. Then we have the fol-
lowing two cases:

1. (GMW [15]:) In this case the soundness error is 2
n

and we open n− 1 views. Note that in these proto-
cols each party must communicate with every other
party, thus the size of the proof for soundness 2−σ
is given by

c·

(n− 1)2
log2(n)− 1 · σ

where c is a constant which depends on the exact
protocol. It is easy to see that the function grows
with n and therefore smallest proofs are achieved
with n = 3. Looking ahead, our protocol in Sec-
tion 4 has c = 1/2 and σ = 80 and therefore the
size of the proof is 274 bits per multiplication gate.

2. (BGW [2]:)

3 (cid:26),(cid:27) n−1

In this case the soundness error is
given by p2(n,(cid:27) n−1
3 (cid:26)). To get soundness er-
ror ≤ 2−80, we get that n ≥ 1122 and therefore the
number of opened views is (cid:27) n−1
3 (cid:26) = 373. Thus,
even if each party only had to store a single bit for
each multiplication gate, the size of the proof would
already be larger than in the previous case.

3. (Future Work:) Our analysis shows that using an

MPC protocol with t = r =(cid:31) 2
3 n(cid:30) it would be enough
to use (n,t,r) = (92,64,64) to achieve soundness
2−80. The existence of such a protocol, where in
addition each party only needs to store ≤ 4 bits per
multiplication gate, would give rise to ZK proofs
of size smaller than the one we construct. We are
not aware of any such protocols, however we cannot
rule out their existence. In particular, we note that
such protocols have not been considered in the liter-
ature, since they give rise to poor MPC protocols in
practice (note that such a protocol necessarily uses
advanced channels, which in the standard MPC pro-
tocol need to be implemented using expensive cryp-
tographic operations), and we believe that the quest
for “MPC protocols” optimized for the ZK applica-
tions has just begun. Figure 3 shows how, for a ﬁxed
number of parties n, the soundness error decreases
as a function of t = r. Note that the soundness error
for 2

3 n is much smaller than 1

3 n.

Why only perfect correctness and robustness?
[19]
presented also two extensions of the basic construction
that allow to use MPC protocol with statistical correct-
ness or with statistical robustness, but we are not con-
sidering those cases here for two reasons: ﬁrst, the re-
sulting ZK protocols have higher round complexity (and
are therefore not Σ-protocols); second, perfectly secure
MPC protocols are more efﬁcient: practically efﬁcient
MPC protocols which only achieve statistical security
(even when allowing arbitrary two-party channels, such
as in [5, 22]) require parties to store tags or MACs to-
gether with their shares, and to make sure that the sta-

1074  25th USENIX Security Symposium 

USENIX Association

tistical error is negligibly small these tags need to be at
least as long as the security parameter7, whereas in per-
fectly secure MPC protocols the share size can be made
constant.

Why not Version 2? Note that the soundness error
of Version 1 with (n,t,r) = (3,2,0) is the same as the
soundness error of Version 2 with (n,t,r) = (3,1,0), thus
the number of required rounds is exactly the same. How-
ever (i) Version 2 requires to compute and open more
commitments and (ii) Version 2 only works with plain
channels, while Version 1 allows to use arbitrary chan-
nels which helps in constructing more efﬁcient protocols.

4 Generalizing IKOS

This section contains a generalized and optimized ver-
sion of the IKOS protocol that works for any relation de-
ﬁned by a function, φ : X → Y which can be decomposed
in the “right way”. In particular, in Section 4.2 we will
describe a ZK Σ-protocol for the relation Rφ deﬁned by
Rφ (y,x) =1 ⇔ φ (x) =y, while the decomposition used
to construct it is formalized in the following section.

Protocol Π∗φ

Let φ : X → Y be a function and D a related
(2,3)-decomposition as deﬁned in Deﬁnition 4.1.

Input: x ∈ X
1. Sample random tapes k1,k2,k3;
2. Compute (x1,x2,x3) ← Share(x;k1,k2,k3);
3. Let w1,w2,w3 be vectors with N + 1 entries;
• Initialize wi[0] = xi for all i ∈ {1,2,3};
• For j = 1, . . . ,N , compute:
• For i = 1,2,3, compute
i (cid:31)(wm[0.. j− 1],km)m∈{i,i+1}(cid:30)
4. Compute yi = Outputi(wi,ki) for i ∈ {1,2,3};
5. Compute y = Rec(y1,y2,y3);
Output: y ∈ Y

wi[ j] = φ ( j)

Figure 4: Given a correct decomposition D, the protocol
Π∗φ can be used to evaluate the function φ.

7This can be avoided for SIMD computations [10].

j=1{φ ( j)

1 ,φ ( j)

2 ,φ ( j)
3

1 ,φ ( j)

2 ,φ ( j)

3 }. The function φ ( j)

(2,3)-Function Decomposition

4.1
Given an arbitrary function φ : X → Y and an input value
x ∈ X we want to compute the value φ (x) splitting the
computation in 3 branches such that the values com-
puted in 2 branches reveals no information about the
input x.
In order to achieve this, we start by “split-
ting” the value x in three values x1,x2,x3 (called input
shares) using a surjective function that we indicate with
Share. These input shares as well as all the interme-
diate values are stored in 3 string w1,w2,w3 called the
views. More precisely, wi contains the values computed
in the computation branch i. In order to achieve the goal
and compute the value y = φ (x), we use a ﬁnite fam-
ily of efﬁciently computable functions that we indicate
with F =(cid:29)N
m takes
as inputs speciﬁc values from the views wm,wm+1 with
m ={1,2,3} and where 3+1 = 1. The functions are used
in the following way: we use functions φ ( j)
to
compute the next value to be stored in each view wm:
The function φ (1)
m takes as input wm,wm+1 (which at this
point contain only the shares xm,xm+1) and outputs one
value which is saved in position 1 of the views wm. We
continue like this for all N functions, with the difference
that in step j > 1, the function φ ( j)
m can receive as in-
put (any subset of) the current views wm,wm+1. The
initial function Share and all subfunctions φ ( j)
m are al-
lowed to be randomized, and they get their coins from
k1,k2,k3, three random tapes which correspond to the
three branches. Finally, after the N steps described, the 3
functions Output1, Output2, Output3 are used to com-
pute the values yi = Outputi(wi) that we call output
shares. From these three values we compute the ﬁnal
output y = φ (x) using the function Rec. The entire pro-
cedure is described in detail in Figure 4 (Protocol Π∗φ ).
Deﬁnition 4.1. A (2,3)-decomposition for the function
φ is the set of functions

D = {Share, Output1, Output2, Output3, Rec}∪F

such that Share is a surjective function and φ ( j)
m , Outputi
and Rec are functions as described before. Let Π∗φ be the
algorithm described in Figure 4, we have the following
deﬁnitions.

• (Correctness) We say that D is correct if Pr[φ (x) =
Π∗φ (x) ] = 1 for all x ∈ X. The probability is over
the choice of the random tapes ki.

• (Privacy) We say that D has 2-privacy if it is correct
and for all e ∈ [3] there exists a PPT simulator Se
such that

({ki,wi}i∈{e,e+1},ye+2) and Se(φ ,y)

have the same probability distribution for all x ∈ X.

USENIX Association  

25th USENIX Security Symposium  1075

samples

random x1,x2,x3

cation gates8. The total number of gates in the circuit is
N, the gates are labelled with indices in [N]. The linear
(2,3)-decomposition of φ is deﬁned as follows:
• ShareZ(x;k1,k2,k3)
such that x = x1 + x2 + x3;
• The family F Z =(cid:31)N

3 } is deﬁned
in the following way. Assume that the c-th gate has
input wires coming from the gate number a and the
gate number b (or only gate number a in the case
of a unary gate), then the function φ (c)
is deﬁned as
follows: If the c-th gate is a (∀α ∈ Z)
− unary “add α” gate, then ∀i ∈ [3]:

c=1{φ (c)

1 ,φ (c)

2 ,φ (c)

i

(wi[a]) =(cid:30)wi[a] +α if i = 1

wi[a] else

x

Share

x1

x2

x3

w1[0] = x1

w2[0] = x2

w3[0] = x3

φ (1)
1

φ (1)
2

φ (1)
3

wi[c] = φ (c)

i

w1[1]

w2[1]

w3[1]

φ (2)
1

φ (2)
2

φ (2)
3

w1[2]

w2[2]

w3[2]

...

w1

...

w2

...

w3

Output1

Output2

Output3

y1

y2

y3

Rec

y

Pictorial

Figure 5:
(2,3)-
decomposition of the computation y = φ (x) showing the
three branches.

representation of

a

4.1.1 The Linear Decomposition
We present here an explicit example of a convenient
(2,3)-decomposition. Let Z be an arbitrary ﬁnite ring
such that φ : Zk → Z(cid:31) can be expressed by an arithmetic
circuit over the ring using addition by constant, multipli-
cation by constant, binary addition and binary multipli-

− unary “mult. α” gate, then ∀i ∈ [3]:

wi[c] = φ (c)

i

(wi[a]) = α · wi[a]

− binary addition gate, then ∀i ∈ [3]:

wi[c] = φ (c)

i

(wi[a],wi[b]) = (wi[a] +w i[b])

wi[c] = φ (c)

− binary multiplication gate, then ∀i ∈ [3]:
i (cid:29)wi[a,b],wi+1[a,b])(cid:28)
= wi[a]· wi[b] +w i+1[a]· wi[b]
+ wi[a]· wi+1[b] +R i(c)− Ri+1(c)

i (wi,ki) simply selects all the

where Ri(c) is a uniformly random function sam-
pled using ki.
• For all i ∈ [3], OutputZ
shares of the output wires of the circuit;
• Finally, RecZ(y1,y2,y3) outputs y = y1 + y2 + y3
decomposition DZ =
Proposition
The
{ShareZ, RecZ, OutputZ
1 , OutputZ
3} ∪F Z
deﬁned above is a (2,3)-decomposition. Moreover, the
length of each view in DZ is (k + N + (cid:31))log|Z| + κ bits.
Correctness of the decomposition follows from in-
spection. Privacy can be shown by constructing an ap-
propriate simulator as shown in Appendix A

2 , OutputZ

4.1.

In the linear decomposition just presented, the param-
eter N is equal to the total number of gates (unary and
binary) in the circuit computing φ. It is easy to slightly
modify the deﬁnition of the functions φ (c)
in DZ in such

i

8Note that Boolean circuits are a special case of this, with the XOR,

AND and NOT gate.

1076  25th USENIX Security Symposium 

USENIX Association

a way that N results equal to the number of multiplica-
tion gates only.
In particular, note that the evaluation
of addition gates (both unary and binary) only requires
computation on values from the same branch, thus they
can be embedded in a generalized multiplication gates
which take as input arbitrary subsets of wires A, B, con-
tains constants α,β ,γ and computes the value:

w[c] =(cid:31)∑

a∈A

α[a]w[a](cid:30)·(cid:31)∑

b∈B

β [b]w[b](cid:30) + γ

4.2 ZKBoo Protocol
Following the idea of
[19], we turn a (2,3)-
decomposition of a function φ into a zero-knowledge
protocol for statements of the form “I know x such
that φ (x) = y”. We indicate with Lφ the language
{y|∃x s.t. φ (x) =y}.

Assume that a (2,3)-decomposition of the function φ
is known (see Section 4.1). The structure of the result-
ing protocol (Figure 6) is very similar to the structure of
the IKOS protocol. If y ∈ Lφ is the public input of the
proof, then the prover P uses his private input x (with
φ (x) =y) to run “in his head” the protocol Π∗φ . After
the emulation of the protocol, P commits to each of the 3
produced views w1,w2,w3. Now the veriﬁer challenges
the prover to open 2 of the commitments. Finally, the
veriﬁer accepts if the opened views are consistent with
the decomposition used and with output y.

Proposition 4.2. The ZKBoo protocol (Figure 6) is a Σ-
protocol for the relation Rφ with 3-special soundness.

Proof. Clearly, the ZKBoo protocol has the right com-
munication pattern and it is complete given that the de-
composition D is correct. Moreover, the protocol satis-
ﬁes the 3-special soundness property: consider 3 accept-
ing conversations (a,i,zi), i ∈ [3]: ﬁrst note that thanks
to the binding property of the commitment, the view w1
contained in z1 and the one contained in z3 are identi-
cal, and the same holds for the other views w2,w3 and
random tapes k1,k2,k3. Then, we can traverse the de-
composition of φ backwards from the output to the input
shares: since the three conversations are accepting, we
have that Rec(y1,y2,y3) = y, that yi = Outputi(wi) ∀i,
and ﬁnally that every entry in all of wi was computed
correctly. Therefore, since the Share function is surjec-
tive, we can compute x(cid:23) = Share−1(w1[0],w2[0],w3[0]).
Thanks to the correctness of the decomposition we thus
have that φ (x(cid:23)) = y, which is what we wanted to prove.
Note that the protocol does not satisfy 2-special sound-
ness, even if two accepting conversation actually contain
all three views: in this case, since one of the branches of

ZKBoo Protocol

The veriﬁer and the prover have input y ∈ Lφ .
The prover knows x such that y = φ (x). A (2,3)-
decomposition of φ is given. Let Π∗φ be the protocol
related to this decomposition.

Commit: The prover does the following:

1. Sample random tapes k1,k2,k3;
2. Run Π∗φ (x)

and obtain the views
shares

output

w1,w2,w3
y1,y2,y3;

and

the

3. Commit to ci = Com(ki,wi) for all i∈ [3];
4. Send a = (y1,y2,y3,c1,c2,c3).

Prove: The veriﬁer choose an index e ∈ [3] and
sends it to the prover. The prover answers
to the veriﬁer’s challenge sending opening
ce,ce+1 thus revealing z = (ke,we,ke+1,we+1).

Verify: The veriﬁer runs the following checks:
1. If Rec(y1,y2,y3) (cid:21)= y, output reject;
2. If ∃i ∈ {e,e + 1} s.t. yi (cid:21)= Outputi(wi),
output reject;
3. If ∃ j such that
we[ j] (cid:21)= φ ( j)
output reject;

e (cid:29)we,we+1,ke,ke+1(cid:28)

4. Output accept;

Figure 6: ZKBoo protocol for the language Lφ in the
commitment-hybrid model.

the computation has not been checked, ∃ i s.t. wi might
i (cid:29)wi,wi+1,ki,ki+1(cid:28).
not be equal to φ ( j)
To prove the special honest-veriﬁer ZK property, we
consider the simulator S deﬁned by the following steps.
The input are y ∈ Lφ and e ∈ [3]:
run the 2-privacy
simulator (which is guaranteed to exist thanks to the
2-privacy property of the decomposition D as in Deﬁ-
nition 4.1), which returns ({ki,wi}i∈{e,e+1},ye+2), sets
we+2 = 0|w|,ke+2 = 0|k| and then constructs a by com-
mitting to the three views and tapes.

Efﬁciency. Let φ : Zk → Z(cid:30) be a function that can be
expressed by a circuit over the ﬁnite ring Z with N mul-

USENIX Association  

25th USENIX Security Symposium  1077

tiplication gates. If we repeat σ (log2 3− 1)−1 copies of
the ZKBoo protocol instantiated with the linear decom-
position described in Section 4.1.1, and where we gener-
ate the random tapes pseudo-randomly with security pa-
rameter κ, we get a Σ-protocol with soundness 2−σ and
bit-size

σ (log2 3− 1)−1 · 2· [log2(|Z|)(k + N + (cid:31)) +κ ]
5 Zero-Knowledge for SHA-1/SHA-256

In this section we describe our case study, in which
we implemented the protocol described in Section 4 for
proving knowledge of preimages of SHA-1 and SHA-
256. We start describing the choices we made in our
implementation, describe the result of our empirical val-
idation and ﬁnally compare with state-of-the-art proto-
cols for the same task. Our implementation is available
at https://github.com/Sobuno/ZKBoo.

5.1 Circuits For SHA-1/SHA-256
The linear-decomposition protocol described in Sec-
tion 4 can be used with arithmetic circuits over arbi-
trary rings. Our ﬁrst choice is picking a ring in which to
express the computation of SHA-1/SHA-256. The two
functions are quite similar, and they both use vectors of
32 bits for internal representation of values. Three kind
of operations are performed over these bit-vectors: bit-
wise XORs, bitwise ANDs, and additions modulo 232.
Implementing the two algorithms (after some simple op-
timization to reduce the number of bitwise ANDs) re-
quires the following number of operations9:

SHA-1
SHA-256

AND XOR ADD
325
40
192
600

372
704

Hence, the two natural choices for the ring are Z2
(where XOR gates are for free but AND/ADD require
32 multiplication gates) and Z232 (where ADD is free but
bitwise operations require a linear number of multiplica-
tion gates). Since the number of XORs dominates in both
algorithms, we opted for an implementation over the ring
Z2.

Implementation of Building Blocks

5.2
We wrote our software in C, using the OpenSSL10 li-
brary. We instantiated the building blocks in our protocol
in the following way:

9Note that the AND complexity of our circuits is approximately 1/3
of the “standard MPC circuit” from https://www.cs.bris.ac.uk/
Research/CryptographySecurity/MPC/.

10https://www.openssl.org

RNG: We generate the random tapes pseudorandomly
using AES in counter mode, where the keys are gener-
ated via the OpenSSL secure random number generator.
In the linear decomposition of multiplication gates, we
use a random function R : [N] → Z2. We implement this
function by picking a bit from the stream generated using
AES. In particular, we compute

R(i) =AES(K ,(cid:27)i/128(cid:26))[i mod 128]

which means that 3 calls to AES are sufﬁcient to eval-
uate 128 individual AND gates. Note that since N (the
number of AND gates) is known in advance, we can pre-
compute all calls to AES at the beginning of the proto-
col. These two optimizations, together with the native
support for AES in modern processors, proved very ef-
fective towards decreasing running times.
Commitments:
In the ﬁrst step of the protocol the
prover commits to the three views w1,w2,w3. Those
commitments have been implemented using SHA-
256 as the commitment function i.e., Com(x,r) =
SHA-256(x,r). Under the (mild) assumptions that SHA-
256 is collision resistant and that SHA-256(·,r) is a PRF
(with key r) the commitments are binding and hiding.
The Fiat-Shamir Oracle. To make the proofs non-
interactive, we need a random oracle H : {0,1}∗ →
{1,2,3}r where r is the number of repetitions of our
basic protocol. We instantiate this using SHA-256 as
a random oracle and by performing rejection sampling.
In particular, we compute the ﬁrst output coordinate of
H(x) by looking at the ﬁrst two output bits of SHA-
256(0,x) and mapping (a,b) → 2a + b + 1. In case that
(a,b) = (1,1) we look at the third-fourth bit instead and
repeat.
If there are no more bits left in the output of
the hash function, we evaluate SHA-256(1,x) and so on.
In our experiments the maximum number of repetition
is r ∈ {69,137}, thus we call the hash function once or
twice (on expectation).

5.3 Experimental Setup
We report on the results of the implementation of SHA-
1 and SHA-256 for 69 and 137 repetitions each. Those
correspond to soundness errors 2−40 and 2−80. While the
security level 2−40 is not sufﬁcient for the case of non-
interactive zero-knowledge, it offers reasonable security
guarantees in the interactive case – note however that in
this case our timings are only indicative of the local com-
putation as they do not account for the necessary network
communication.

Our experiments were run on a machine with an AMD
FX-8350 CPU, running 8 cores at 4.00 GHz. The pro-
grams were run under Windows 10 Pro version 1511
(OS Build 10586.14) on a Seagate Barracuda 7200 RPM
SATA 3.0 Gb/s hard drive with 16MB cache. Note that

1078  25th USENIX Security Symposium 

USENIX Association

computing and verifying our proofs is an embarrassingly
parallel task, thus it was possible to effortlessly take ad-
vantage of our multi-core architecture using OpenMP11,
an API useful for making a C program multi-threaded.
We note that we have only done this for the main loop
of the program, which iterates over the individual repeti-
tions of the proofs (which are clearly independent from
each other), thus it is likely that there is room for fur-
ther parallelisation. Timings were done using C native
clock() function and are measured in milliseconds.

5.4 Experimental Results
Breakdown.
In Table 1 we report on the timings we
obtained for both SHA-1 and SHA-256, with 69 and 137
rounds, both enabling and disabling parallelisation. In
this table we also present a breakdown of the running
time. In particular we measure the following phases for
the prover:

• Commit: This is the time to run the Commit pro-
cedure (Figure 6) to produce a. It is further divided
into the following sub-timings: (Rand. gen.) Gen-
eration of all needed randomness using OpenSSL
RNG as well as preprocessing of the PRF; (Algo-
rithm exec.) Time taken to run the algorithm Π∗φ .
This is the total time for all 69/137 rounds; (Com-
mitment) Generating commitments of the views;

• Gen. challenge: Using the random oracle to gener-

ate the challenge vector as e = H(y,a);

• Prove: Building the vector z;
• Output to disk: Writing (a,e,z) to disk;12
For the veriﬁer:

)
s

m

(

e
m
T

i

• Input from disk: Reading the proof from ﬁle;
• Gen. challenge: Regenerate the challenge vector

using the random oracle;

• Verify: The time to run all the rounds of the Verify

procedure;

Finally, with proof size we indicate the size of the string
π = (y,a,z) on disk in KB.

Parallelisation. Figure 7 and 8 show how the run-
ning time of the prover (resp. veriﬁer) changes when we
change the number of rounds (from 1 to 137) and the
number of threads (from 1 to 8). We include the graphs
for SHA-256 only. It is easy to see that the running time

11http://openmp.org
12We observed that the timings of writing to disk are very noisy, and

not always monotone in the size of the written ﬁle.

)
s

m

(

e
m
T

i

60

40

20

0

SHA-256 prover running time

1 thread
2 threads
3 threads
4 threads
5 threads
6 threads
7 threads
8 threads

20

40

60

80

100

120

Number of rounds

Figure 7: Relation between the total running time and
the number of rounds for the SHA-256 prover, average
over 100 runs.

SHA-256 veriﬁer running time

60

40

20

0

20

40

60

80

100

120

Number of rounds

Figure 8: Relation between the total running time and
the number of rounds for the SHA-256 veriﬁer, average
over 100 runs.

increases linearly with the number of rounds, and that the
improvement due to multithreading is signiﬁcant. The
graph indicates that there is some ﬂuctuation in the al-
gorithm’s run time for all number of threads when us-
ing up to about 85 rounds, which is mostly due to the

USENIX Association  

25th USENIX Security Symposium  1079

Serial
18.98
13.45
1.35
10.41
1.37
0.06
0.12
5.35
11.68
0.09
0.06
11.53

Paral.
8.12
3.68
0.60
2.69
0.39
0.05
0.18
4.21
2.35
0.11
0.05
2.20

Prover (ms)
Commit
- Rand. gen.
- Algorithm exc.
- Commitment
Gen. challenge
Prove
Output to disk
Veriﬁer (ms)
Input from disk
Gen. challenge
Verify
Proof size (KB)

Serial
31.73
26.73
2.47
21.55
2.71
0.10
0.28
4.62
22.85
0.13
0.10
22.63

Paral.
12.73
6.59
0.88
5.06
0.64
0.13
0.32
5.70
4.39
0.16
0.10
4.12

Serial
30.81
24.47
2.28
19.60
2.56
0.05
0.32
5.08
34.16
0.15
0.06
33.95

Paral.
12.45
5.86
0.80
4.44
0.62
0.06
0.39
5.39
6.77
0.16
0.05
6.56

Serial
54.63
48.25
4.46
38.68
5.09
0.09
0.07
4.76
67.74
0.29
0.10
67.35

Paral.
15.95
10.07
1.13
7.87
1.07
0.09
0.53
4.43
13.20
0.25
0.11
12.85

69 rounds

137 rounds

SHA-1

SHA-256

69 rounds

137 rounds

223.71

444.18

421.01

835.91

Table 1: Breakdown of times and proof size for 69/137 rounds of SHA-1/SHA-256, average of 1000 runs

ZKBoo
ZKGC (Estimates)
Pinocchio

Veriﬁer (ms)
Preproc. (ms)
0
5
0 > 19 (OT only) > 25 (OT only)
8

Prover (ms)
13

12059

9754

Proof size (B)
454840
186880
288

Table 2: Comparison of approaches for SHA-1

noise introduced by disk operations13. We note that the
runtime of the veriﬁer beneﬁts more from parallelisation.
This is consistent with Amdahl’s law since, as shown in
Table 1, the prover spends signiﬁcantly more time per-
forming tasks which do not beneﬁt from parallelisation
(e.g., writing to disk).

5.5 Comparison
Here we compare the performances of ZKBoo with some
of the state-of-the-art protocol for the same task. In par-
ticular, we compare the performances of proving/veri-
fying knowledge of SHA-1 preimages across ZKBoo,
Pinocchio [23] and ZKGC [21].

Pinocchio [23]
is an implementation of SNARKs for
veriﬁable outsourcing of computation. While not its
main purpose, it can generate zero-knowledge proofs at a
negligible extra cost over sound-only proofs. The choice
of benchmarking SHA-1 only (and not SHA-256) is due
to the fact that the Pinocchio library only contains SHA-
1. The runtime reported for Pinocchio are obtained on
the same machine as our implementation. The results
shows that ZKBoo is faster at both proving and verify-
ing, with an incredible 103 factor for the prover. Note

13See the full version [14] for graphs showing the running times

without disk operations.

here that if the underlying circuit had been larger, the
proof size and the veriﬁcation time of Pinocchio would
not change, while its preprocessing and proving time
would grow accordingly. We note also that Pinocchio
has a large preprocessing time where some prover/veri-
ﬁer key are generated. Those keys are circuit dependent,
and for SHA-1 the prover key is 6.5 MB and the veri-
ﬁer key is 1.1 MB. To Pinocchio’s defence, it must be
noted that 1) Pinocchio is a general purpose system that
can generate proofs for any circuit (provided as an in-
put ﬁle) while our implementation contains the SHA cir-
cuit hard-coded; 2) according to [23], Pinocchio has not
been parallelised; and 3) Pinocchio uses a SHA-1 circuit
which is approximately 3 times larger than ours. While it
is conceivable that Pinocchio could be made faster using
some of the optimizations introduced here, we do not be-
lieve that Pinocchio could ever reach proving times sim-
ilar to ZKBoo, due to the use of heavy public-key tech-
nology (exponentiations in a pairing-friendly group) for
each gate in the circuit.

ZKGC [21]. For the case of ZKGC, we could not di-
rectly compare implementations, since the source code
for [21] is not publicly available.
In addition, since
the publication of [21], several signiﬁcant improvements
have been proposed but have not been implemented yet.
Therefore, in Table 2, we give an accurate estimate of

1080  25th USENIX Security Symposium 

USENIX Association

the size of the proofs generated using ZKGC but only a
lower-bound for its runtime. The estimates are computed
using the following tools: (GC) we estimate the proof
size using the communication complexity of the most ef-
ﬁcient (in terms of communication complexity) garbled
circuits, namely privacy-free garbled circuits [13, 27]
that can be instantiated with as little as one ciphertext
(128 bits using AES) per AND gate in the circuit; (OT)
we plug the size and runtime given by the most efﬁ-
cient OT available [6]. Since the input size of SHA-1
is quite large (512 bits), it might be that using OT exten-
sion would prove useful. Therefore, to make the com-
parison even more favourable towards ZKGC, we only
count the runtime of 190 base OTs necessaries for active
secure OT extensions [1] and we do not account at all for
the runtime of the OT extension protocol nor the genera-
tion/veriﬁcation of the GC. The resulting estimates show
that even when counting the base OTs alone, the run-
time of ZKGC is already larger than the runtime of ZK-
Boo for the SHA-1 circuit. As for proof size, we note
that ZKGC produces shorter proofs. However, the ap-
proach of ZKGC cannot be made non-interactive which
is a qualitative drawback and it is likely to introduce sig-
niﬁcant slow-downs due to network latency.

6 Conclusions

the ﬁrst attempt
In this paper we described ZKBoo,
to make general purpose zero-knowledge practical us-
ing the “MPC-in-the-head” approach of Ishai et al. [19].
We discussed how to generalize their protocol using the
idea of (2,3)-function decompositions, we showed sim-
ple linear decompositions for arithmetic circuits over any
ring and we leave it as a future work to ﬁnd compact de-
compositions for other interesting functions.

Our experimental results show that for practically rel-
evant circuits (such as SHA-1), our protocol is the fastest
in terms of proving time, and where the veriﬁcation time
is comparable even with SNARKs technology.

Acknowledgements

This project was supported by: the Danish National Re-
search Foundation and The National Science Foundation
of China (grant 61361136003) for the Sino-Danish Cen-
ter for the Theory of Interactive Computation; the Cen-
ter for Research in Foundations of Electronic Markets
(CFEM); the European Union Seventh Framework Pro-
gramme ([FP7/2007-2013]) under grant agreement num-
ber ICT-609611 (PRACTICE).

References
[1] ASHAROV, G., LINDELL, Y., SCHNEIDER, T., AND ZOHNER,
M. More efﬁcient oblivious transfer extensions with security for
malicious adversaries. In Advances in Cryptology - EUROCRYPT
2015 - 34th Annual International Conference on the Theory and
Applications of Cryptographic Techniques, Soﬁa, Bulgaria, April
26-30, 2015, Proceedings, Part I (2015), pp. 673–701.

[2] BEN-OR, M., GOLDWASSER, S., AND WIGDERSON, A.
Completeness theorems for non-cryptographic fault-tolerant dis-
tributed computation (extended abstract). In STOC (1988), pp. 1–
10.

[3] BEN-SASSON, E., CHIESA, A., GARMAN, C., GREEN, M.,
MIERS, I., TROMER, E., AND VIRZA, M. Zerocash: Decen-
tralized anonymous payments from bitcoin. In 2014 IEEE Sym-
posium on Security and Privacy, SP 2014, Berkeley, CA, USA,
May 18-21, 2014 (2014), pp. 459–474.

[4] BEN-SASSON, E., CHIESA, A., TROMER, E., AND VIRZA, M.
Succinct non-interactive zero knowledge for a von neumann ar-
chitecture. In Proceedings of the 23rd USENIX Security Sympo-
sium, San Diego, CA, USA, August 20-22, 2014. (2014), pp. 781–
796.

[5] BENDLIN, R., DAMG ˚ARD, I., ORLANDI, C., AND ZAKARIAS,
S. Semi-homomorphic encryption and multiparty computation.
In Advances in Cryptology - EUROCRYPT 2011 - 30th An-
nual International Conference on the Theory and Applications
of Cryptographic Techniques, Tallinn, Estonia, May 15-19, 2011.
Proceedings (2011), K. G. Paterson, Ed., vol. 6632 of Lecture
Notes in Computer Science, Springer, pp. 169–188.

[6] CHOU, T., AND ORLANDI, C. The simplest protocol for obliv-
ious transfer.
In Progress in Cryptology - LATINCRYPT 2015
- 4th International Conference on Cryptology and Information
Security in Latin America, Guadalajara, Mexico, August 23-26,
2015, Proceedings (2015), pp. 40–58.

[7] DAMGAARD, I. On σ-protocols (2010). Lecture on Cryptologic

Protocol Theory (Aaurhus Unvivesrity, course notes).

[8] DAMG ˚ARD, I., AND ISHAI, Y. Scalable secure multiparty com-
In Advances in Cryptology-CRYPTO 2006. Springer,

putation.
2006, pp. 501–520.

[9] DAMG ˚ARD, I., ISHAI, Y., AND KRØIGAARD, M. Perfectly
secure multiparty computation and the computational overhead
of cryptography. In Proceedings of EuroCrypt (Springer Verlag
2010), pp. 445–465.

[10] DAMG ˚ARD, I., AND ZAKARIAS, S. Constant-overhead secure
In TCC

computation of boolean circuits using preprocessing.
(2013), pp. 621–641.

[11] EVEN, S., GOLDREICH, O., AND LEMPEL, A. A randomized
protocol for signing contracts. Commun. ACM 28, 6 (1985), 637–
647.

[12] FIAT, A., AND SHAMIR, A. How to prove yourself: Practical
solutions to identiﬁcation and signature problems. In Advances
in Cryptology—CRYPTO’86 (1986), Springer, pp. 186–194.

[13] FREDERIKSEN, T. K., NIELSEN, J. B., AND ORLANDI, C.
Privacy-free garbled circuits with applications to efﬁcient zero-
knowledge.
In Advances in Cryptology - EUROCRYPT 2015 -
34th Annual International Conference on the Theory and Appli-
cations of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-
30, 2015, Proceedings, Part II (2015), pp. 191–219.

[14] GIACOMELLI, I., MADSEN, J., AND ORLANDI, C. Zkboo:
Faster zero-knowledge for boolean circuits. Cryptology ePrint
Archive, Report 2016/163, 2016. http://eprint.iacr.org/.

USENIX Association  

25th USENIX Security Symposium  1081

[15] GOLDREICH, O., MICALI, S., AND WIGDERSON, A. How to
play any mental game. In Proceedings of the nineteenth annual
ACM symposium on Theory of computing (1987), ACM, pp. 218–
229.

[16] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The knowl-
edge complexity of interactive proof-systems (extended abstract).
In Proceedings of the 17th Annual ACM Symposium on Theory
of Computing, May 6-8, 1985, Providence, Rhode Island, USA
(1985), pp. 291–304.

[17] HAZAY, C., AND LINDELL, Y. Efﬁcient secure two-party proto-
cols: Techniques and constructions. Springer Science & Business
Media, 2010.

[18] HAZAY, C., AND VENKITASUBRAMANIAM, M. On the power
of secure two-party computation. Cryptology ePrint Archive,
Report 2016/074. To appear in Crypto 2016, 2016. http://
eprint.iacr.org/.

[19] ISHAI, Y., KUSHILEVITZ, E., OSTROVSKY, R., AND SAHAI,
A. Zero-knowledge from secure multiparty computation. In Pro-
ceedings of the Thirty-ninth Annual ACM Symposium on Theory
of Computing (2007), STOC ’07, ACM, pp. 21–30.

[20] ISHAI, Y., KUSHILEVITZ, E., OSTROVSKY, R., AND SAHAI,
A. Zero-knowledge proofs from secure multiparty computation.
SIAM Journal on Computing 39, 3 (2009), 1121–1152.

[21] JAWUREK, M., KERSCHBAUM, F., AND ORLANDI, C. Zero-
knowledge using garbled circuits: how to prove non-algebraic
statements efﬁciently.
In 2013 ACM SIGSAC Conference on
Computer and Communications Security, CCS’13, Berlin, Ger-
many, November 4-8, 2013 (2013), pp. 955–966.

[22] NIELSEN, J. B., NORDHOLT, P. S., ORLANDI, C., AND
BURRA, S. S. A new approach to practical active-secure two-
party computation. In Advances in Cryptology - CRYPTO 2012
- 32nd Annual Cryptology Conference, Santa Barbara, CA, USA,
August 19-23, 2012. Proceedings (2012), pp. 681–700.

[23] PARNO, B., HOWELL, J., GENTRY, C., AND RAYKOVA, M.
Pinocchio: Nearly practical veriﬁable computation.
In 2013
IEEE Symposium on Security and Privacy, SP 2013, Berkeley,
CA, USA, May 19-22, 2013 (2013), pp. 238–252.

[24] RABIN, M. O. How to exchange secrets with oblivious transfer.

IACR Cryptology ePrint Archive 2005 (2005), 187.

[25] RANELLUCCI, S., TAPP, A., AND ZAKARIAS, R. W. Efﬁcient
generic zero-knowledge proofs from commitments. Cryptology
ePrint Archive, Report 2014/934. To appear in ICITS 2016, 2014.
http://eprint.iacr.org/.

[26] SCHNORR, C.-P. Efﬁcient identiﬁcation and signatures for smart

cards. In CRYPTO (1989), pp. 239–252.

[27] ZAHUR, S., ROSULEK, M., AND EVANS, D. Two halves make
a whole - reducing data transfer in garbled circuits using half
gates.
In Advances in Cryptology - EUROCRYPT 2015 - 34th
Annual International Conference on the Theory and Applications
of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-30, 2015,
Proceedings, Part II (2015), pp. 220–250.

A Appendix

Proof of Proposition 4.1
Proof. In order to prove that the decomposition DZ is
correct is enough to prove that for any c ∈ [N] the fol-
lowing holds.
(1) if the c-th gate is an “add α” gate, then:

(2) if the c-th gate is an “mult. α” gate, then:

(3) if the c-th gate is an addition gate, then:

wi[c] =(cid:31) 3
∑
wi[c] =(cid:31) 3
∑

3

∑

i=1

3

∑

i=1

i=1

i=1

wi[a](cid:30) + α
wi[a](cid:30)· α
wi[a](cid:30) +(cid:31) 3
∑
wi[a](cid:30)·(cid:31) 3
∑

i=1

i=1

wi[b](cid:30)
wi[b](cid:30)

i=1

wi[c] =(cid:31) 3
∑
wi[c] =(cid:31) 3
∑

i=1

3

∑

i=1

3

∑

i=1

(4) if the c-th gate is a multiplication gate, then:

Indeed, using (1), (2), (3) and (4) iteratively for all
the gates in the circuit we can prove that ∑3
i=1 wi[N] =
φ (∑3

Π∗φ (x) =Rec Z(y1, . . . ,y n) =

i=1 xi) and from this it follows that
3
∑
xi(cid:30) = φ (x)

wi[N] = φ(cid:31) 3
∑

∑

i=1

i=1

i=1

yi

=

3

The ﬁrst three follow trivially by the deﬁnition of the
function φ (c)
Ai when the c-th gate is a an “add α”, “mult.
α” and addition gate, respectively. Now assume that the
c-th gate is a multiplication gate. Then, using the deﬁni-
tion for the function φ (c)
for this case and recalling that
Ai
the index values are computed modulo 3, we have that

3

∑

i=1

wi[c] =

=

3

i=1(cid:29)wi[a]· wi[b] +w i+1[a]· wi[b] +w i[a]· wi+1[b]
∑

+ Ri(c)− Ri+1(c)(cid:28)
wi[a]· (wi[b] +w i+1[b]) +

3

∑

i=1

3

∑

i=1

wi[a]· wi+2[b]+

Ri(c)

3

+

i=1

∑
=(cid:31) 3
∑

i=1

3

i=1

∑
Ri(c)−
wi[a](cid:30)·(cid:31) 3
∑

i=1

wi[b](cid:30)

1082  25th USENIX Security Symposium 

USENIX Association

We now pass to prove the 2-privacy property. Given
e ∈ [3], we deﬁne the simulator Se on input y with the
following instructions:

1. Sample random tapes k(cid:30)e,k(cid:30)e+1;
2. Sample uniformly at random the values w(cid:30)e[0] and
w(cid:30)e+1[0]. Then, for all c ∈ [N]: If the c-th gate is
an “add α”, “mult. α” or addition gate then deﬁne
w(cid:30)e[c] and w(cid:30)e+1[c] using the functions φ (c)
and φ (c)
e+1,
e
respectively. If the c-th gate is a multiplication gate
then sample uniformly at random the value w(cid:30)e+1[c]
and compute the value w(cid:30)e[c] using φ (c)
; In this way
e
deﬁne the entire views w(cid:30)e and w(cid:30)e+1;

3. Compute

y(cid:30)e = Outpute(w(cid:30)e)

and

y(cid:30)e+1 =

Outpute+1(w(cid:30)e+1);

4. Compute y(cid:30)e+2 = y− (y(cid:30)e + y(cid:30)e+1);
5. Output ({k(cid:30)i,w(cid:30)i}i∈{e,e+1},y(cid:30)e+2)
is easy to verify that

It
the output of
the sim-
ulator Se has the same distribution of
the string
({ki,wi}i∈{e,e+1},ye+2) produced by the protocol Π∗φ .
Indeed, all the elements in the output of Se are computed
using the same commands used in Π∗φ , except for the ele-
ment w(cid:30)e+1[c] when the c-th gate is a multiplication gate.
In this case w(cid:30)e+1[c] is sample uniformly at random, while
we+1[c] in the protocol is computed using the function
φ (c)
e+1. In particular, we+1[c] is computed by subtracting to
determined value the element Ri+2(c). Since Ri+2 is an
uniformly random function sampled using an indepen-
dent tape ke+2, the distribution of we+1[c] in the protocol
is the uniform one, that is it has the same distribution of
w(cid:30)e+1[c] in the output of Se. Therefore, we can conclude
that Se is a correct simulator for the decomposition DZ.
Finally, by inspection we have that |wi| = (k + N +

(cid:30))log|Z| + κ for all i ∈ [3].

USENIX Association  

25th USENIX Security Symposium  1083

