2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Security of the J-PAKE

Password-Authenticated Key Exchange Protocol

Michel Abdalla

CNRS, ENS, INRIA, and PSL

45 Rue d’Ulm, 75005 Paris, France

Email: michel.abdalla@ens.fr

Fabrice Benhamouda

ENS, CNRS, INRIA, and PSL

45 Rue d’Ulm, 75005 Paris, France
Email: fabrice.ben.hamouda@ens.fr

Philip MacKenzie

Google, Inc.

Mountain View, CA 94043
Email: philmac@google.com

Abstract—J-PAKE is an efﬁcient password-authenticated key
exchange protocol that is included in the OpenSSL library and
is currently being used in practice. We present the ﬁrst proof
of security for this protocol
in a well-known and accepted
model for authenticated key-exchange, that incorporates online
and ofﬂine password guessing, concurrent sessions,
forward
secrecy, server compromise, and loss of session keys. This proof
relies on the Decision Square Difﬁe-Hellman assumption, as well
as a strong security assumption for the non-interactive zero-
knowledge (NIZK) proofs in the protocol (speciﬁcally, simulation-
sound extractability). We show that
the Schnorr proof-of-
knowledge protocol, which was recommended for the J-PAKE
protocol, satisﬁes this strong security assumption in a model with
algebraic adversaries and random oracles, and extend the full J-
PAKE proof of security to this model. Finally, we show that by
modifying the recommended labels in the Schnorr protocol used
in J-PAKE, we can achieve a security proof for J-PAKE with a
tighter security reduction.

I. INTRODUCTION

In a password-authenticated key exchange (PAKE) protocol,
two parties who share only a password (i.e., a short secret)
communicate with each other to compute a cryptographically
strong shared secret key, using the password for mutual
authentication. The protocol should not allow an attacker to
obtain any information about the password through simple
eavesdropping, and only allow the attacker to gain information
about one password per protocol session in an active attack.
Basically, this implies that the attacker is not able to obtain
data with which to perform an ofﬂine dictionary attack, in
which the attacker would run through a dictionary of possible
passwords ofﬂine, checking each one for consistency with the
data. A very good introduction and discussion of this problem
may be found in Jablon [29] or Wu [47]. The seminal work
in the ﬁeld was the development of Encrypted Key Exchange
(EKE) by Bellovin and Merritt [7], [8], and there has been a
great deal of work since then (for references see, e.g., [28]).
The J-PAKE protocol [24] is a PAKE protocol that has
started seeing wide usage. It is included as an optional protocol
in the OpenSSL library [39] (enabled using a conﬁg parameter
during install, see directory crypto/jpake), and has been used in
various products, such as Firefox Sync [16] and Nest products
[38] (as part of the Thread protocol [46]). Its popularity is
likely due not only to its easy description, straightforward
implementation, and practical efﬁciency, but also because it
seems to be based on a different paradigm than previous

© 2015, Michel Abdalla. Under license to IEEE.
© 2015, Michel Abdalla. Under license to IEEE.
DOI 10.1109/SP.2015.41
DOI 10.1109/SP.2015.41

571
571

practical PAKE protocols. Those protocols basically used the
password to obfuscate the inputs to a key exchange (e.g., the
gx and gy values in a Difﬁe-Hellman key exchange), whereas
the J-PAKE protocol uses ephemeral values like a standard
Difﬁe-Hellman key exchange, but then combines them with
a password in an extra round, such that use of the correct
password makes certain randomization factors vanish. The J-
PAKE designers call this the “juggling” technique and attribute
the ﬁrst use of the idea to Hao and Zielinski [25]. Due to its
novelty, the designers of J-PAKE claim that it might be useful
in avoiding patent issues around other PAKE protocols.

The original J-PAKE paper claimed to give a proof of
security, but, as pointed out by Katz [31], the proof was not
in one of the well-known accepted models for authenticated
key exchange (e.g., the model from Bellare, Pointcheval, and
Rogaway [5]), and simply proved some ad-hoc properties in an
isolated setting, using implicit assumptions on the adversarial
model. Given its growing popularity, it is important to have
a better understanding of the security of this protocol, using
rigorous and explicit deﬁnitions and models. This is especially
true for PAKE protocols, since there are many subtleties
to their security, and many previous PAKE protocols, or
early versions of PAKE protocols (that did not have rigorous
security proofs) have been shown to be insecure [36], [41].

In this paper we present a proof of security for the J-PAKE
protocol in the well-known authenticated key exchange model
of Bellare, Pointcheval, and Rogaway [5], under the Decision
Square Difﬁe-Hellman (DSDH) assumption, along with other
assumptions described below. The DSDH assumption is sim-
ilar to and at least as strong as the Decision Difﬁe-Hellman
assumption, but it is not known whether it is strictly stronger.
We note that we could reduce this assumption to DDH and
Computational Square Difﬁe-Hellman (CSDH)1 by using the
random-oracle model.2

One interesting technique used in the J-PAKE protocol that
has not been used in previous PAKE proofs is the zero-

1Since there is a reduction from DDH to CSDH, we could say this is only
based on DDH. However, there is a quadratic loss in concrete security, so we
prefer to keep the assumptions separate.

2Bellare and Rogaway [6] introduced the random-oracle model in which
hash functions are modeled as random oracles, and argue that proofs in
such an ideal model provide evidence that when the ideal constructs are
instantiated properly (with strong cryptographic implementations), then the
protocol remains secure in practice.

knowledge (ZK) proof of knowledge. Generally it is difﬁcult
to argue about the security of ZK proofs of knowledge in
a concurrent protocol model. This is because for most known
ZK proofs of knowledge, and even non-interactive ZK (NIZK)
proofs of knowledge in the random-oracle model, rewinding
arguments have been used to prove the extraction property,
which is problematic in a concurrent setting since it can
cause an exponential expansion in simulation cost during
reduction arguments. We initially avoid this issue and assume
the use of NIZK proofs of knowledge that are simulation-
sound extractable [22], with non-rewinding extractors. We call
these SE-NIZK proofs. One could say that this proves the
security of J-PAKE in a rigorous model that captures the
standard intuition behind NIZK proofs of knowledge, and
more speciﬁcally, proves security under the DSDH assumption
and the assumptions necessary to prove the internal NIZK
proof of knowledge is simulation-sound extractable.

However, the NIZK proof of knowledge recommended by
the designers of J-PAKE (and used in the current implemen-
tations) is the Schnorr protocol [43], which seems to require
rewinding arguments to prove the extraction property, at least
in the standard computation model. Therefore,
to provide
a rigorous proof of security of J-PAKE using the Schnorr
protocol, we turn to the algebraic model [40] (with respect
to a group G), in which an adversary is limited to perform
only group operations on group elements in G. It is similar
to the generic group model of Shoup [44], in which all group
operations are performed using an oracle, but is weaker as,
in particular, it makes no assumption on the representation
of group elements and does not imply by itself that, e.g.,
the discrete logarithm is hard. We show that in the algebraic
model, the Schnorr protocol can be seen as an SE-NIZK proof,
in any proof by reduction, with some restrictions (on the group
elements used by the proof) that our J-PAKE proof does in fact
satisfy. This proof relies on the Discrete Log (DL) assumption
in the random-oracle model. Putting this all together, we have
proven the security of J-PAKE using Schnorr in the algebraic
model and random-oracle model, under the DSDH assumption.
It is worth emphasizing that this is a proof of security that
matches the underlying implementation in OpenSSL, and this
is important in that it allows applications to use J-PAKE in a
way that exactly matches the security proof.3

Returning to the standard computation model, Groth, Os-
trovsky, and Sahai [23] and Groth [22] show how to achieve
SE-NIZK proofs in the common reference string (CRS model).
Garay, MacKenzie, and Yang [17] and MacKenzie and Yang
[37] show how to achieve non-malleable ZK proofs (which
are like SE-NIZK proofs but allowed to be interactive) which
trivially imply SE-NIZK proofs in the CRS and random-oracle
model, and require only a constant number of exponentiations
(but over multiple groups with larger non-prime moduli). Any
of these could replace the Schnorr proof of knowledge in the

3Applications do have some ﬂexibility in how certain labels are chosen
within the protocol, which may affect the security. We discuss this after the
proof in Section VI.

J-PAKE protocol, though none of them would be nearly as
practical.

As a ﬁnal result, we show that by slightly modifying the
labels used in the Schnorr proofs in the J-PAKE protocol, one
can obtain a simpler security proof, with tighter security reduc-
tions from known cryptographic assumptions. We recommend
using these modiﬁed labels in future implementations of the J-
PAKE protocol, if they don’t require backwards compatibility.
Other PAKE protocols. Many previous practical PAKE pro-
tocols have been proven secure in either the random-oracle
model or ideal-cipher model, e.g., [3], [5], [7], [10], [29],
[35], [36]. As shown in [15], [27], the ideal-cipher model
is equivalent to the random-oracle model, when the inputs
and outputs are binary strings. In practice, however, ideal
ciphers for group elements, as required in [5], [7], are difﬁcult
to construct and can have an impact on the efﬁciency of
the schemes. In addition, a few PAKE protocols have been
proven secure without ideal assumptions. For instance, the
practical protocol of Katz, Ostrovsky, and Yung [32] only
relies on a reasonably short common reference string that is
produced before the protocol begins. This protocol has been
generalized and improved in several follow-up works, such
as [1], [12], [18], [21], [30], [33]. For these protocols, the
common reference string could be simulated using a random
oracle. The protocol of Goldreich and Lindell [19] does not
rely on a common reference string either, but is only proven
secure when protocols sessions are not run concurrently, and
does not seem practical. More recently, Goyal, Jain, and
Ostrovsky [20] improved the work of Goldreich and Lindell
by providing a protocol
is proven secure even when
protocols sessions are run concurrently. Their protocol also
does not seem practical. A detailed comparison of practical
Difﬁe-Hellman-based PAKE protocols can be found in Table I.

that

II. DEFINITIONS

Let κ be the cryptographic security parameter. Let G denote
a ﬁnite (cyclic) group of order p, where |p| ≥ 2κ. Let g be a
generator of G. We will assume the Decision Square Difﬁe-
Hellman (DSDH) assumption holds over G (see Section VI).
Let texp be the time required to perform an exponentiation in
G.
If Adv(A) denotes the advantage of some adversary in some
experiment, we write Adv(t) = maxA {Adv(A)}, where the
maximum is taken over all adversaries of time complexity at
most t.

A. Random Oracle

In some cases, cryptographic hash functions will be modeled
as random oracles. Thus whenever a party computes a function
H(x), the party is actually sending a query x to the random
oracle designated for H, and that oracle returns H(x), where
H is a truly random function with domain {0, 1}∗ and range
{0, 1}κ or Zp depending on the case.

572572

COMPARISON OF PRACTICAL DIFFIE-HELLMAN-BASED PAKE PROTOCOLS PROVEN SECURE IN THE BPR MODEL [5]

TABLE I

Rounds / Flows

CRS

ROM ICM AAM

Assumptionsa

J-PAKE with Schnorr [24]

2 / 4 or 3 / 3





Communicationb
12 × G + 6 × Zp

Complexity

Timec

28 exp (12 exp + 8 mexp)

DSDH or

(CSDH + DDH)







1 / 2
1 / 2
2 / 2
1 / 2

EKE [5], [7]
SPEKE [29], [35]
PPK [10]
SPAKE2 [3]

2 × G
2 × G
2 × G
2 × G
6 × G
GK-SPOKE [1], [21], [30]
7 × G
GL-SPOKE [1], [18], [32]
10 × G
KV-SPOKE [1], [33]
a CRS: common reference string, ROM: random-oracle model, ICM: ideal-cipher model, AAM: algebraic-adversary model;
b G: group elements, Zp: scalars;
c exp: number of exponentiations; mexp: number of multi-exponentiations; memb: veriﬁcation of the membership of a group element to the cyclic group G. For elliptic curve
with small co-factor, this only costs a small number of additions on the curve, but for subgroups of Zq (q being a prime larger than p, the order of the group G), this costs
an exponentiation (with exponent p − 1); enc: encryption with the ideal cipher; multiplications, hash evaluations, and PRG evaluations are omitted;
d DIDH: decision inverted-additive Difﬁe-Hellman assumption [35] (see Fig. 2 and the Appendix);
e PRG: pseudo-random generator.

17 exp (4 exp + 7 mexp) + 6 memb
21 exp (4 exp + 7 mexp) + 7 memb
30 exp (2 exp + 12 mexp) + 10 memb

4 exp + 2 memb
6 exp + 2 memb
4 exp + 2 memb

CDH
DIDHd
DDH
CDH

4 exp + 2 memb + 2 enc

DDH + PRGe

2 / 2
2 / 2
1 / 2

DDH
DDH





B. Simulation-Sound Extractable Non-Interactive
Knowledge Proofs

Zero-

We will assume the zero-knowledge proofs of knowledge
in the J-PAKE protocol are simulation-sound extractable non-
interactive zero-knowledge proofs (SE-NIZK) [22].

Informally, a SE-NIZK enables a prover to prove that some
word or statement x is in a given NP-language L , deﬁned with
some witness relation R, i.e., L = {x | ∃ω, R(x, ω) = 1},
in a zero-knowledge and extractable way. If ω is such that
R(x, ω) = 1, ω is said to be a witness for x. Given, a witness
ω for x, the prover can generate a proof π R← PK(x, ω, (cid:5)) for
some label (cid:5) (and maybe some implicit common reference
string or CRS σ). This proof can be checked by anyone by
running an algorithm VK(x, π, (cid:5)). We insist that we introduce
an optional CRS for the sake of completeness, but that for
the instantiation of J-PAKE using Schnorr proofs, no CRS is
used.

In addition, knowing some trapdoor τ, it is possible to
simulate any proof for any word x (even outside L ) without
knowing a witness ω. And, knowing some other trapdoor ξ,
it is possible to extract from any valid proof π for any word
x, a witness ω for x. Simulation-sound extractability ensures
that the extraction works even if the adversary sees simulated
proofs (except for the simulated tuples (x, π, (cid:5)) obviously).
Concretely, in this article, we only consider SE-NIZK proofs
for the language of discrete logarithms: x = (u, h) ∈ G2,
ω = r ∈ Zp, and

R((u, h), r) = 1 ⇐⇒ u = hr.

In other words, our SE-NIZK proofs are proofs of knowledge
of the discrete logarithm of u in base h.

Formal deﬁnitions can be found in Section VIII.
We should point out that we assume the extractor is straight-
line: no rewinding is authorized. This rules out using directly
Schnorr proofs, also known as Schnorr signatures [43], (which
are the most efﬁcient NIZK for the discrete logarithm lan-
guage, in the random-oracle model) with a rewinding extractor

based on the forking lemma [42]. Nevertheless, in Section IX,
we show that Schnorr signatures can still be used in J-PAKE,
if we assume adversaries are algebraic. This, however, requires
a careful analysis and the introduction of a weaker form
of simulation-sound extractability, called algebraic-simulation-
sound extractability.

C. Computational Randomness Extractor

The last step of the original J-PAKE protocol consists in
deriving a secret key from a group element. In the original
paper, this is done by using a hash function implicitly modeled
as a random oracle. In this paper, we prefer to formally deﬁne
the requirements for this derivation function. More precisely
we suppose it is a (computational) randomness extractor [34],
for random group elements.

Note that

if no randomness extractor is used in the J-
PAKE protocol, the protocol would still be secure4. The only
difference would be that the session key would be a random
group element G instead of a random bitstring in {0, 1}κ.
A computational randomness extractor for (uniform) group
elements is a function rExt : {0, 1}t× G → {0, 1}κ, for some
non-negative integer t, such that, when s R← {0, 1}t and u R← G
(independent of s), then (s, rExt(s, u)) is computationally
indistinguishable from a uniform bit string in {0, 1}t×{0, 1}κ.
Formally, given a poly-time adversary A, we consider the
advantage Advcomp-ext

(A) deﬁned as:

(cid:2)
s R← {0, 1}t; u R← G : A(s, rExt(s, u)) = 1

(cid:2)
(cid:3)
s R← {0, 1}t; k R← {0, 1}κ : A(s, k) = 1

−

(cid:3)

rExt

Pr

Pr

.

As shown in [34], a hash function H modeled as a random
oracle gives a randomness extractor without seed (s = ⊥, t =
(A) ≤
0, rExt(⊥, u) = H(u) ∈ {0, 1}κ) with Advcomp-ext
nro/p, with nro the number of queries to the random oracle.

rExt

4The proof would be the one in Section VI, without the last protocol P8,

and so would actually be slightly simpler.

573573

Considering a hash function to be a randomness extractor is
weaker than modeling it as a random oracle. However, if such
an assumption is not deemed acceptable, there exist various
alternative solutions: some with seeds such as the left over
hash lemma [26], and some without seeds, but speciﬁc to some
groups [13]. For further references on randomness extractors,
see [14].

III. MODEL

For our proofs of security we use a real-or-random variant
of the model of [5] with weak adaptive corruptions (corruption
queries do not reveal the internal state of the principals, but
reveal the password of the principal and can be made at
any point during the protocol) and forward secrecy In [2],
it is shown that this real-or-random variant is stronger than
the original ﬁnd-then-guess model in [5]. The only difference
with [5] is that we allow multiple Test queries.
Protocol participants and long-lived keys. Participants in
the protocol are either clients and servers. Each client A holds
a password pw
A chosen uniformly (and independently) at
random from a dictionary of size N. Each server B holds
a vector of the passwords of all clients, and when running the
protocol with some client A, uses the password pw
A of A.
Users are modeled as probabilistic poly-time algorithms that
respond to queries. For any user U, we will let U denote both
the user, and the identiﬁer for the user (e.g., to be used as
input to a function).
Execution of the protocol. A protocol P is an algorithm
that determines how principals behave in response to inputs
from their environment. In the real world, each principal is
able to execute P multiple times with different partners, and
we model this by allowing unlimited number of instances of
i .
each principal. Instance i of principal U is denoted ΠU
To describe the security of the protocol, we assume there is
an adversary A that has complete control over the environment
(mainly, the network), and thus provides the inputs to instances
of principals. Formally, at
the beginning of the protocol,
a random bit b is chosen. The adversary is a probabilistic
algorithm with a distinguished query tape. Queries written to
this tape are responded to by principals according to P ; the
allowed queries are formally deﬁned in [5] and summarized
here:
Send (U, i, M ): causes message M to be sent to instance
i . The instance computes what the protocol says to,
ΠU
state is updated, and the output of the computation is
given to A. If this query causes ΠU
to accept or terminate,
this will also be shown to A. To initiate a session between
users A and B the adversary should send a message
containing B to an unused instance of A, or a message
containing A to an unused instance of B.

Execute (A, i, B, j): causes P to be executed to completion
between ΠA
j , and outputs the transcript of the
execution. This query captures the intuition of a passive
adversary who simply eavesdrops on the execution of
P . It could be simulated with Send queries, but having

i and ΠB

i

separate Execute queries enable to state stronger security
results.

Reveal (U, i): causes the output of the session key held by

i .
ΠU

Test (U, i): causes the output of the session key ski

U , if b =
1; otherwise, a string is drawn uniformly from the space
of session keys and output.

, sk(cid:3)

Corrupt (U ): causes the client U to output its password.
Partnering. A client or server instance that accepts holds a
partner-id pid, session-id sid (which is the transcript of the
whole protocol), and a session key sk. Then instances ΠA
i
j are said to be partnered if both accept, they hold
and ΠB
(pid , sid , sk) and (pid(cid:3)
, sid(cid:3)
), respectively, with pid = B,
pid(cid:3)
= A, sid = sid(cid:3)
, and sk = sk(cid:3)
, and no other instance
accepts with session-id equal to sid.
Freshness. An instance ΠU
is fresh unless either (1) a
i
Reveal (U, i) query occurs, or (2) a Reveal (U
, j) query
(cid:3)
U , or (3) a Corrupt (U
occurs where Πj
)
U
query occurs before ΠU
U , and a
(cid:3) is any participant.
i
Send (U, i, M ) query occurred, where U
Advantage of the adversary. We now formally deﬁne the
authenticated key exchange (ake) advantage of the adversary
P (A) be the event that A makes
against protocol P . Let Succake
only Test queries directed to fresh instances ΠU
that have
(cid:3)
(cid:3), where b
i
= b for
terminated, and eventually outputs a bit b
the bit b that was selected at the beginning of the protocol.
The ake advantage of A attacking P is deﬁned to be
(cid:3)

deﬁned its key ski

(cid:2) is the partner of Πi

(cid:2)

(cid:3)

Advake

P (A)

def
= 2 Pr

Succake

P (A)

− 1.

The authenticated key exchange is considered secure if only
online dictionary attacks are possible. Concretely, this means
that, if passwords are uniformly and independently drawn from
a dictionary of size N:

Advake

P (t) ≤ nse/N + ,

where nse is the number of Send queries (to distinct instances
Πi

U ), and  is negligible in the security parameter:
The following fact is easily veriﬁed.

Fact III.1. Pr(Succake
P (A) = Advake
if Advake
P

P (A)) = Pr(Succake
(cid:2) (A) + 2.

P

(cid:2) (A))+ if and only

Both the model and our proofs can be extended (in a
straightforward way) when the password distribution is not
uniform but only has some min-entropy m. In this case, we
want that Advake

P (t) ≤ nse/2m + .

IV. J-PAKE PROTOCOL

Here we present the J-PAKE protocol from [24].

A. Informal version

Informally, Alice and Bob, who share a password pw, do

the following:
Round 1 Alice randomly generates gx1 , gx2, Bob randomly
generates gx3 , gx4, Alice and Bob send these values to each

574574

(cid:4)

Pr

(x, y) R← Z

corresponding to X and Y , or is a random element of G. Let
G (A) be
A be an algorithm with input (X, Y, Z). Let AdvDDH
p; X ← gx; Y ← gy; Z ← DH(X, Y ) :
(cid:5)
A(X, Y, Z) = 1
p; X ← gx; Y ← gy; Z ← gz :
(cid:5)
A(X, Y, Z) = 1

(x, y, z) R← Z

− Pr

(cid:4)

2

3

.

See [9] for a discussion on hardness of DDH over various

groups.

Note that DDH is random self-reducible. That is, from a
single DDH tuple (X, Y, Z) we can generate any number
of random independent DDH tuples with the same property
R← Zp, and
(either DH or random) by choosing a1, b1, b2
generating (X a1 gb1 , Y gb2 , Z a1 X a1b2 Y b1 gb1b2 ).

Note also that DDH can be solved with one application of
CDH, and CDH can be solved with one application of DL so
G (t) + 1/p ≥ AdvCDH
AdvDDH

G (t) ≥ AdvDL

G (t).

Computational Square Difﬁe-Hellman (CSDH). For value
2 be the square Difﬁe-Hellman
X = gx, let SDH(X) = gx
value corresponding to X. An algorithm for Computational
Square Difﬁe-Hellman takes an element of G, and computes
the square Difﬁe-Hellman value. Let A be an algorithm with
input X. Let AdvCSDH

(A) be

(cid:2)
x R← Zp; X ← gx : A(X) = SDH(X)

(cid:3)

Pr

G

.

Note that CSDH is random self-reducible. That is, from a
single instance of CSDH we can generate multiple random
instances such that if we ﬁnd the square of one, then we can
ﬁnd the square of the original instance. Given an instance X,
= Xgr for r R← Zp. Then X
(cid:3) is a
generate a new instance X
−r
2.
random instance, where SDH(X) = SDH(X

−2rg

)X

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

G

G

(t

= t + O(texp), AdvCDH

(t) ≤ (AdvCDH
G (t

G (t) ≥ (AdvCSDH

Since the CDH problem can be solved using 2 SDH values
of independently chosen elements [11], it is easy to show
))2, or
that for t
equivalently, AdvCSDH
))1/2, where texp is
the time for an exponentiation in G.
Decision Square Difﬁe-Hellman (DSDH). An algorithm for
Decision Square Difﬁe-Hellman takes two elements X and
Y , and attempts to distinguish wether Y is the square Difﬁe-
Hellman value corresponding to X, or is a random element of
(A) be
G. Let A be an algorithm with input X. Let AdvDSDH
(cid:5)
x R← Zp; X ← gx; Y ← SDH(X) : A(X, Y ) = 1
(cid:5)
(cid:4)
p; X ← gx; Y ← gy : A(X, Y ) = 1
(cid:3)

(cid:4)
Pr
− Pr
Bao et al. [4] show that AdvDDH
= t + O(texp).
Note that DSDH is random self-reducible. That is, from
a single DSDH tuple (X, Y ) we can generate any number
of random independent DSDH tuples with the same property
(either SDH or random) by choosing a, b R← Zp, and generating
(X agb, Y a

G (t) ≤ AdvDSDH

(x, y) R← Z

X 2abgb

), for

).

(t

G

G

t

2

2

2

.

(cid:4)

Pr

(x, y) R← Z

2

p; X ← gx; Y ← gy :

A(X, Y ) = DH(X, Y )

(cid:5)

.

(cid:3)

other, along with NIZK proofs for the exponents (denoted
π1, π2, π3, π4 respectively).
Round 2 Alice sends α = (gx1+x3+x4 )x2pw to Bob along
with an NIZK proof πα for the exponent x2pw. Bob sends
β = (gx1+x2+x3 )x4pw to Alice along with an NIZK proof πβ
for the exponent x4pw.
Session Key Generation, Alice
=
(β/gx2x4pw)x2, and Bob computes K = (α/gx2x4pw)x4.
They both compute a session key sk = rExt(s, K), where
s is a public random seed in {0, 1}t. This is a slight
generalization of the original J-PAKE protocol, where there
was no seed (t = 0) and sk = rExt(⊥, K) = H(K), with H
being a hash function behaving as a randomness extractor.

computes K

B. Formal version

In Fig. 1, we present a fully speciﬁed version of the J-PAKE

protocol.

While the protocol is written symmetrically for users A
and B, clients and servers are disjoint, and thus only clients
generate X1, X2, α, and only servers generate X3, X4, β.

We do not need to suppose any ordering between ﬂows
in each round. In particular, it is possible to merge the ﬂow
(B, X3, X4, π3, π4) with the ﬂow (β, πβ) to get a three-
ﬂow protocol, although it seems it was not done in concrete
implementations [16], [39].

V. SECURITY ASSUMPTIONS

Here we state the assumptions we use for the remainder of
the paper. We assume we have a cyclic group G of prime order
p generated by element g. Relations between assumptions are
summarized in Fig. 2 on Page 6.
Discrete Logarithm (DL). An algorithm for the discrete
logarithm problem takes an element X = gx ∈ G, and
its discrete logarithm x. Let A be an
attempts to output
algorithm with input X. Let AdvDL
(cid:4)

(cid:5)
x R← Zp; X ← gx : A(X) = x

G (A) be

Pr

.

Computational Difﬁe-Hellman (CDH). For two values X =
gx and Y = gy, let DH(X, Y ) = gxy be the Difﬁe-Hellman
value corresponding to X and Y . An algorithm for the
Computational Difﬁe-Hellman takes two elements X and Y ,
and outputs the Difﬁe-Hellman value of X and Y . Let A be
an algorithm with input (X, Y ). Let AdvCDH

G (A) be

Decision Difﬁe-Hellman (DDH). An algorithm for the Deci-
sion Difﬁe-Hellman takes three elements X, Y , and Z, and
attempts to distinguish whether Z is the Difﬁe-Hellman value

575575

Public information: G, g, p, σ R← Setup(1κ), s R← {0, 1}t

Secret information: pw ∈ Zp, pw (cid:4)= 0

Client A

Server B

R← Zp

x1
x2

x1, x2
X1 ← g
X2 ← g
π1
π2

R← PK((X1, g), x1, A)
R← PK((X2, g), x2, A)

(cid:2)A,X1,X2,π1,π2(cid:3)-
(cid:2)B,X3,X4,π3,π4(cid:3)


R← Zp

x3
x4

x3, x4
X3 ← g
X4 ← g
π3
π4

R← PK((X3, g), x3, B)
R← PK((X4, g), x4, B)

Abort if X4 = 1
Abort if VK((X3, g), π3, B) fails
Abort if VK((X4, g), π4, B) fails
α ← (X1X3X4)x2pw
R← PK((α, X1X3X4), x2pw, A)
πα

Abort if VK((α, X1X3X4), πα, A) fails
K ← (βX
−x2pw
)x2
sk ← rExt(s, K)
4



(cid:2)α,πα(cid:3) -
(cid:2)β,π

(cid:3)

β

Abort if X2 = 1
Abort if VK((X1, g), π1, A) fails
Abort if VK((X2, g), π2, A) fails
β ← (X1X2X3)x4pw
R← PK((β, X1X2X3), x4pw, B)
πβ

Abort if VK((β, X1X2X3), πβ, B) fails
K ← (αX
−x4pw
)x4
sk ← rExt(s, K)
2

Fig. 1. Generalized version of J-PAKE in which a random extractor is used to derive sk from K. The original J-PAKE protocol is a particular case where
t = 0, s =⊥, rExt(s, K) = H(K), and H is a hash function behaving as a randomness extractor.

DDH ≥ CDH − 1/p

CDH

DDH

CDH ≥ DL

2
)
H
D
S
C
(
≥
H
D
C

H
D
C
≥
H
D
S
C

CSDH ≥ DL

DL

CSDH

DDH ≥
DTGDH/3

DTGDH ≥
DDH

DSDH ≥ DDH

DTGDH

DSDH ≥ CSDH − 1/p

DSDH

CIDH ≥ (DL)2

I

p
/
1
−
H
D
C
≥
H
D
S
C

CIDH

DIDH

DIDH ≥ CIDH − 1/p

DSDH ≥ DIDH − 1/p

Fig. 2. Relations between assumptions. DL, CDH, . . . correspond to the advantage of an adversary for these problems (AdvDL
G (t), . . . ). An arrow indicates
an implication, e.g., the arrow from CDH to DL means that, if CDH is hard, so is DL. A dotted arrow means there is an important loss in the reduction (here
a quadratic loss). Our proof for J-PAKE is either under DSDH (the strongest assumption), or under DDH and CSDH (slightly weaker assumptions) but in the
random-oracle model. CIDH and DIDH are used to prove the security of the SPEKE protocol [29], [35] (see Table I and the Appendix).

576576

Decision Triple Group Difﬁe-Hellman (DTGDH). For val-
ues X = gx, Y = gy, Z = gz, let TDH(X, Y, Z) = gxyz be
the triple Difﬁe-Hellman value corresponding to X, Y , and
Z. An algorithm for Decision Triple Group Difﬁe-Hellman
takes a triple of elements of G, their pairwise Difﬁe-Hellman
values, and an element W from G, and attempts to distinguish
whether W is the Triple Difﬁe-Hellman value corresponding
to X, Y , and Z, or is a random element of G. Let A be
an algorithm with input (X, Y, Z, DXY , DXZ, DY Z, W ). Let
AdvDTGDH

(cid:4)

(A) be
(x, y, z) R← Z

G

Pr

(cid:4)

− Pr

(x, y, z, w) R← Z

3

p; X ← gx; Y ← gy; Z ← gz;
DXY ← DH(X, Y ); DXZ ← DH(X, Z);
DY Z ← DH(Y, Z); W ← TDH(X, Y, Z) :
(cid:5)
A(X, Y, Z, DXY , DXZ, DY Z, W ) = 1
p; X ← gx; Y ← gy; Z ← gz;
DXY ← DH(X, Y ); DXZ ← DH(X, Z);
DY Z ← DH(Y, Z); W R← gw :
(cid:5)
A(X, Y, Z, DXY , DXZ, DY Z, W ) = 1

4

.

Note that DTGDH is random self-reducible. That is, from

a single DTGDH tuple

(X, Y, Z, DXY , DXZ, DY Z, W )

we can generate any number of random independent DTGDH
tuples with the same property (either TDH or random) by
choosing a, b1, b2, b3
(cid:3)

R← Zp, and generating
(cid:3)

(cid:3)

(cid:3)

(cid:3)
XY , D

(cid:3)
XZ, D

(cid:3)
Y Z, W

),

(X

, Y

, Z

, D

where

X

Y

Z

W

(cid:3) ← X agb1 ,
(cid:3) ← Y gb2 ,
(cid:3) ← Zgb3 ,
(cid:3) ← W a(DXY )ab3 (DXZ)ab2 (DY Z)b1

← DY ZY b3 Z b2 gb2b3 ,
← (DXZ)aX ab3 Z b1 gb1b3 ,
← (DXY )aX ab2 Y b1 gb1b2 ,

(cid:3)
D
Y Z
(cid:3)
D
XZ
(cid:3)
XY

D

X ab2b3 Y b1b3 Z b1b2 gb1b2b3 .

DTGDH is also random partial self-reducible, in that from

a single DTGDH tuple

(X, Y, Z, DXY , DXZ, DY Z, W )

we can generate any number of random DTGDH tuples with
R← Zp, and generating
the same Y value by choosing a, b1, b3

(X agb1 , Y, Zgb3 , (DXY )aY b1 , (DXZ)aX ab3 Z b1 gb1b3 ,

DY ZY b3 , W a(DXY )ab3 (DY Z)b1 Y b1b3 ).

Steiner et al. [45] show that polynomial indistinguishability
of DDH implies polynomial indistinguishability of DTGDH,
(cid:3)
and from their proof one can see that for t
(t) ≤ 3AdvDDH
G (t

= t + O(texp),
(cid:3)

AdvDTGDH

).

G

VI. J-PAKE SECURITY

Here we prove that the J-PAKE protocol is secure, in the
sense that an adversary attacking the system cannot determine
session keys with advantage non-negligibly greater than that
of an online dictionary attack.
Theorem VI.1. Let P be the protocol described in Fig. 1,
using group G, and with a password dictionary of size N. Fix
an adversary A that runs in time t, and makes nse queries of
type Send to different instances, and makes nex, nre, nte, nco
queries of type Execute, Reveal, Test, Corrupt, respectively.
Then for t

= O(t + (nse + nex + nco)texp):

(cid:3)

(cid:6)

Advake

nse
N

P (A) =
nseAdvDSDH
NIZK(t

(cid:3)

Advuzk

+ O

(cid:3)

(t

) + (nex + n
G
, 2nse + nex) + Advext

(nse + nex)2

p

+ nseAdvDL

G (t

(cid:3)

)+

)+

se)AdvDDH
2
NIZK(t

(cid:3)
G (t
, 2nse + nex)+
(cid:3)

(cid:3)

(cid:7)

(nre + nte)Advcomp-ext

rExt

(t

)

,

where Advuzk and Advext are advantages for the security of
the SE-NIZK, formally deﬁned in Section VIII.

Proof: Our proof will proceed by introducing a series
of protocols P0, P1, . . . , P8 related to P , with P0 = P .
We will bound the decrease in the advantage of A in each
successive protocol, and ﬁnally in P8, A will be reduced to a
simple online guessing attack that will admit a straightforward
analysis. We describe these protocols informally in Fig. 3.

We will assume the session key is simply the K value
instead of H(K), and use that for all Reveal and Test queries.
Since H(K) can be computed from K, this only strengthens
our proof.

To simplify our analysis, we use the following terminology
and shorthand. When we say an instance receives a value
that has a corresponding NIZK proof, this implies that the
instance was ready to accept that value and that the NIZK
proof was valid. Otherwise, the instance simply rejects. We
say a client (resp. server) instance is a matching instance if
it has a buddy instance with the same X1, X2, X3, X4 values
and also the same β (resp. α) value. We say a client (resp.
server) instance is a swapping instance if it has a buddy
instance with the same X3, X4, β (resp. X1, X2, α) values, but
ﬂipped X1, X2 (resp. X3, X4) values We say a client (resp.
server) instance is an almost matching/swapping instance if
it is a matching/swapping instance except for the value of
X4 (resp. X2). We say an instance is detached if it is not a
matching/swapping or almost matching/swapping instance.

For a detached instance, we say a Send query containing
α (resp. β) to corresponds to a password pw if for the
X1, X2, X3, X4 values of the instance receiving the Send
query, pw = DL(α, X1X3X4)/DL(X2, g) (resp. pw =
DL(β, X1X2X3)/DL(X4, g)). The exact way in which these
values are computed depends on the speciﬁc protocol and
will be explained later in the proof. For a matching/swapping
instance, we say the Send query containing α or β always

577577

P0 Original: The original protocol P .
P1 Simulate and Extract: Choose all passwords pw of clients randomly (and independently) and simulate
all Execute, Send, Reveal, Test, and Corrupt queries just like normal instances, except using the
simulator for the NIZK proof in Execute and Send queries, and running the extractor for the NIZK
proofs produced by the adversary, failing if the extraction fails.

P2 Force Uniqueness: If any instance chooses an X1, X2, X3, or X4 value seen previously in the execution

of the protocol, the protocol halts and the adversary fails.

P3 Disallow Trivial DL Attacks: Take two instances ΠA

i and ΠB
j

that generate X1, X2 and X3, X4,

respectively. Then on any of the following situations, the protocol halts and the adversary fails.
(cid:4)
1) Before sending a β query to ΠA
1X
(cid:4)
3X

2) Before sending an α query to ΠB

i , the adversary sends X

j , the adversary sends X

j where X1X2 = X

i where X3X4 = X

X

(cid:4)
2 but
(cid:4)
4 but

X

1 (cid:4)= X2.
(cid:4)
3 (cid:4)= X4.
(cid:4)

1 (cid:4)= X1 and X
(cid:4)
3 (cid:4)= X3 and X
(cid:4)
(cid:4)
(cid:4)
4 = X
1X3X4, but X
(cid:4)
(cid:4)
3 = X
1X

3) Before sending an α query to ΠB
1 (cid:4)= X1.
(cid:4)
3 (cid:4)= X3.
(cid:4)

4) Before sending a β query to ΠA

(cid:4)
2X3, but X

X1X2X

(cid:4)
3X

X1X

(cid:4)
2 to ΠB
(cid:4)
4 to ΠA

(cid:4)
1, X
(cid:4)
3, X
(cid:4)
(cid:4)
4 to ΠA
j , the adversary sends X
3, X
(cid:4)
(cid:4)
2 to ΠB
1, X

i , the adversary sends X

i and X

j , where

j and X

i , where

(cid:4)
1 to ΠB
(cid:4)
3 to ΠA

P4 Check Password Guesses: If before a Corrupt query, the adversary makes a Send query to an instance
corresponding to a correct password pw using an α or β value such that the instance is not a matching
instance or swapping instance, the protocol halts and the adversary succeeds.

P5 Randomize Session Keys For Wrong Password Guesses: In any instance that is not a matching or
swapping instance, and whose Send query (for α or β) corresponds to an incorrect password, set K
randomly.

P6 Randomize Session Keys For Paired Instances: In any matching or swapping instance, set K randomly

(with matching buddies getting the same K).

P7 Randomize α and β: If a Corrupt query has not occurred, generate α and β values randomly in all
instances. For an instance that is not a matching nor swapping instance, and whose Send query (for α
or β) corresponds to the correct password (i.e., after a Corrupt query), compute K as the other party
would have.

P8 Randomize sk: In any instance in which K is set randomly, set sk randomly (with matching buddies

getting the same sk).

Fig. 3. Description of protocols P0 through P8

corresponds to the correct password pw. For an almost match-
ing/swapping instance, we say the Send query containing α
or β always corresponds to an incorrect password. Note that
in P8, the passwords aren’t used anymore in any simulations,
except for checking passwords in P4. It is easy to see that this
is equivalent to a protocol with a password guessing oracle,
that is queried at most once per non-matching instance (since
we know the discrete logs of all values). Then it is trivial
to show that when the passwords are chosen randomly (and
independently) from a set of size N the probability of an
attacker succeeding is at most nse/N.
For each i from 1 to 8, we will bound the increase in
the advantage of A attacking protocol Pi−1 compared to the
advantage of A attacking protocol Pi.
Protocol P1 (simulate and extract).
In this protocol, we
choose all passwords pw of clients randomly (and indepen-
dently) and simulate all Execute, Send, Reveal, Test, and
Corrupt queries just like normal instances, except using the
simulator for the NIZK proof in Execute and Send queries,
and running the extractor for the NIZK proofs produced by
the adversary, failing if the extraction fails.

Protocol P1 behaves exactly like P0, except for the simula-
tion of the NIZK proofs and failing on unsuccessful NIZK
extractions. From the unbounded zero-knowledge property,

578578

and the simulation-sound extractability property of the NIZK,
(cid:9)

P0 (A) = Advake

P1 (A) + O

Advake

NIZK(t

, 2nse + nex)+
(cid:3)

(cid:3)

Advuzk
Advext

NIZK(t

, 2nse + nex)

(cid:8)

Note that in P1, the simulator obtains all adversarial values of
x1, x2, x3, x4, pw from the NIZK extractions.
Protocol P2 (force uniqueness). If any instance chooses an
X1, X2, X3, or X4 value seen previously in the execution
of the protocol, the protocol halts and the adversary fails.

Protocols P1 and P2 are only distinguishable if we hit the

“birthday paradox”.

Advake

P1 (A) = Advake

P2 (A) + O

(nse + nex)2

p

(cid:6)

(cid:7)

.

i and ΠB

Protocol P3 (disallow trivial DL attacks). Take two
instances ΠA
that generate X1, X2 and X3, X4,
respectively. Then on any of the following situations, Pro-
tocol P3 halts and the adversary fails.
1) Before sending a β query to ΠA

j

i , the adversary sends
1 (cid:11)= X1
(cid:3)

(cid:3)
2 but X

(cid:3)
1X

j where X1X2 = X

(cid:3)
1, X
X
and X

(cid:3)
2 to ΠB
1 (cid:11)= X2.
(cid:3)

2) Before sending an α query to ΠB

j , the adversary sends

i where X3X4 = X

(cid:3)
3X

(cid:3)
4 but X

3 (cid:11)= X3
(cid:3)

(cid:3)
3, X
X
and X

(cid:3)
4 to ΠA
3 (cid:11)= X4.
(cid:3)
(cid:3)
4 to ΠA

X
X

3) Before sending an α query to ΠB
(cid:3)
i and X
1 to ΠB
1 (cid:11)= X1.
(cid:3)
4) Before sending a β query to ΠA
(cid:3)
j and X
3 to ΠA
3 (cid:11)= X3.
(cid:3)

(cid:3)
3, X
(cid:3)
1X3X4, but X
(cid:3)
(cid:3)
2 to ΠB
1, X
(cid:3)
(cid:3)
2X3, but X
1X

X
X

j , the adversary sends
(cid:3)
j , where X1X
4 =

(cid:3)
3X

i , the adversary sends
(cid:3)
i , where X1X2X
3 =

We will bound the advantage increase in each part using

reduction from DL. Take an instance of DL with value X.

1 (cid:11)= X2, use x
(cid:3)

For part 1, choose a random client instance ΠA

i and set
(cid:3)
(cid:3)
X1 = X and X2 = gx2. Then if the adversary sends X
1, X
1 (cid:11)= X1
2
(cid:3)
to an instance of B where X1X2 = X
(cid:3)
and X
2 obtained from extracting witness
from NIZK proofs (or from the simulation of an instance of
(cid:3)
A), and compute the discrete log of X as x
2/x2. Note that
i can still be simulated perfectly since the discrete log of
ΠA
X1 is never used except in an NIZK proof, which is already
simulated.

(cid:3)
2 but X

(cid:3)
1, x

(cid:3)
1X

(cid:3)
1x

(cid:3)
1, X

Part 2 is similar.
For part 3, choose a random client instance ΠA

i and set
(cid:3)
(cid:3)
X1 = X and X2 = gx2. Then if the adversary sends X
3, X
4
(cid:3)
(cid:3)
2 (for some X
2) to an instance ΠB
to ΠA
that
i and X
1 (cid:11)= X1,
(cid:3)
(cid:3)
(cid:3)
j
produced X3, X4, where X1X
3X
4 = X
(cid:3)
(cid:3)
4 obtained from extracting witnesses from NIZK
use x
1, x
proofs (or from simulations of instances of A and B), and
(cid:3)
compute the discrete log of X as x
4. Note that
i can still be simulated perfectly since the discrete log of
ΠA
X1 is never used except in an NIZK proof, which is already
simulated.

(cid:3)
1X3X4 but X

(cid:3)
1x3x4/x

(cid:3)
3, x

(cid:3)
3x

Part 4 is similar.

Advake

P2 (A) = Advake

P3 (A) + O

(cid:10)
nseAdvDL

G (t

(cid:11)

(cid:3)

)

.

Protocol P4 (check password guesses). If before a Corrupt
query, the adversary makes a Send query to an instance
corresponding to a correct password pw using an α or β
value such that the instance is not a matching instance
or swapping instance, the protocol halts and the adversary
succeeds.
Note that to determine if a Send query corresponds to a
correct password pw, it is only necessary to know either the
2 discrete logs (of α and X2, or β and X4) or one of the
discrete logs and the password pw. For instance, with just pw
and the discrete log y of α we can check if gy/pw = X2. Also
note that for an NIZK proof generated by the adversary, this
value y can be extracted by the NIZK extractor and veriﬁed.
In every protocol and reduction argument used before P8, we
will know pw, and at least one of the discrete logs for every
Send query of interest, and in P8, we will know all discrete
logs for any Send query of interest.

Note that in P4, the advantage of the adversary can only

increase.

Advake

P3 (A) ≤ Advake

P4 (A).

579579

Protocol P5 (randomize session keys for wrong password
guesses). In any instance that is not a matching or swapping
instance, and whose Send query (for α or β) corresponds
to an incorrect password, we set K randomly.

At this point we may assume that for a Send query with
α or β, the recipient is either matching or swapping, the
query corresponds to an incorrect password guess, or the query
corresponds to a correct password guess and either there has
been a Corrupt query or the simulation is halted.

We split this proof up and ﬁrst examine a protocol P4.5
that only sets K randomly in the relevant instances of A. We
bound the advantage increase using a reduction from DSDH.
Use a hybrid argument and consider the ith instance of A,
where all previous instances set K randomly if necessary, and
all later instances use the normally computed K.

2

(cid:2)

(cid:2)

x

gx

(cid:2)
3)x

(cid:2)
3)x

(cid:2)
3+x

(cid:2)
4pw(cid:2)

(cid:2)
4pw(cid:2)

(cid:3)
3, X

receives X

Y x
−x

(cid:3)
4 values, use x

(cid:2)
4xpw)x = gx(x1+x

Given a DSDH instance (X, Y ), let ΠA
i

set X1 = gx1
(cid:3)
(cid:3)
and X2 = X. When ΠA
3, x
4
i
values obtained from extracting witnesses from NIZK proofs
(or from the simulation of an instance of B), and set α =
(cid:2)
4 )pw. If that instance receives a Send query with
(X x1+x
β, use the y value obtained from extracting a witness for β (or
from the simulation of an instance of B), and let pw(cid:3)
= y/x4
be the password associated with the β value and compute
4(pw(cid:2)−pw). Note that if x is the (un-
K = X (x1+x
known) discrete log of X, then K would have been computed
4(pw(cid:2)−pw),
by A as K = (βg
2, or if
which is the actual K value computed if Y = gx
pw(cid:3)
= pw (which will always be the case for matching or
swapping instances). On the other hand, if Y is random and
(cid:11)= pw), then
this is an incorrect password guess (i.e., pw(cid:3)
4 (cid:11)= 0
(cid:3)
K will be random since it will depend on Y , since x
(because the protocol checks that X4 (cid:11)= 1) and pw(cid:3) − pw (cid:11)= 0.
j that generates
(cid:3)
2, and that that receives a Send
X3, X4, and has received X
query using this α may be simulated. If it doesn’t use this α,
then it can obtain the discrete log of α and satisfy P4. If it
2 (cid:11)= X2, then it can obtain the discrete
(cid:3)
uses this α, and X
(cid:3)
(cid:3)
log of X
2 = X2,
2 and satisfy P4. If it uses this α and X
(cid:3)
(cid:3)
4, we
then because the NIZK proof for α speciﬁes X1X
3X
(cid:3)
4 = X1X3X4. But by P3, this implies
can assume X1X
(cid:3)
4 = X3X4, and again by P3, this
X
(cid:3)
4) = (X4, X3), i.e.,
implies (X
it is matching or swapping. Therefore no password test is
necessary, so no discrete log is necessary.

All that is left to show is that any instance ΠB

(cid:3)
4) = (X3, X4) or (X

(cid:3)
1 = X1. But then X

(cid:3)
1, X

(cid:3)
3, X

(cid:3)
3, X

(cid:3)
3X

(cid:3)
3X

The number of hybrids is bounded by the number of
different instances, which is bounded by nse. Therefore we
get the following bound.

Advake

P4 (A) ≤ Advake

P4.5 (A) + nseAdvDSDH

G

(cid:3)

(t

).

Using a perfectly analogous argument, we can prove the
same bound on the advantage increase from P5 to P4.5.
Combining the two results above, we have

Advake

P4 (A) = Advake

P5 (A) + O(nseAdvDSDH

G

(cid:3)

(t

)).

Protocol P6 (randomize session keys for paired instances).
In any matching or swapping instance, we set K randomly
(with matching buddies getting the same K).

We bound the advantage increase in the advantage of the

adversary from P6 to P5 using a reduction from DTGDH.

Use a hybrid argument and consider the ith instance of A
(ΠA
i ) and jth instance of B (ΠB
j ), where all lexicographically
previous instances of A and B that are full-matching or
full-swapping set K randomly, and all lexicographically later
instances set K normally. We will proceed assuming Send
queries between these instances. For Execute queries,
the
results hold by assuming they are matching Send queries.

(cid:3)
3, X

Take a DTGDH instance (X, Y, Z, DXY , DXZ, DY Z, W ).
For ΠA
j , set X3 =
i , set X1 = gx1 and X2 = X, and for ΠB
4} =
i with {X
(cid:3)
(cid:3)
(cid:3)
4) to ΠA
Y , X4 = Z. On a query (X
3, X
{X3, X4}, set α = (DXY DXZX x1 )pw. For other queries to
(cid:3)
(cid:3)
4 values obtained by
3 and x
A, compute α using either the x
extraction from the NIZK proof, or from the simulation of
an instance of B, or the DXY and DXZ values. Similarly,
2} = {X1, X2}, set
j with {X
(cid:3)
on a query (X
β = (DXZDY ZZ x1 )pw. For other queries to B, compute β
(cid:3)
2 values obtained by extraction from
using either the x
the NIZK proof, or from the simulation of an instance of A,
or the DXZ and DY Z values.

(cid:3)
1, X
(cid:3)
1 and x

(cid:3)
2) to ΠB

(cid:3)
1, X

Now consider a Send query to ΠA

i with a value β. If
this is a matching or swapping instance with buddy ΠB
j ,
XZW )pw. If W = T GDH(X, Y, Z), then this
set K = (Dx1
simulates computing K normally, and if W is random, then
K is random.

j , X
(cid:3)
1, X

Now for the other cases, if β is not from ΠB

j , then we
can extract the discrete log, and satisfy P4. If β is taken
2} = {X1, X2} for the
3 = X3 and {X
(cid:3)
(cid:3)
(cid:3)
from ΠB
1, X
(cid:3)
2 received by ΠB
j , by P3. But because this is
values X
4 (cid:11)= X4, so the instance is
(cid:3)
not matching of swapping, X
almost matching/swapping and the corresponding password
guess would be incorrect. Again this satisﬁes P4. Note that
in the case when the password guess is correct and we are
continuing (which because of P4 means there was a Corrupt
query), then we will know DL(X4, g), so we can compute K
as B would.

Now consider a Send query to ΠB

i with a value α. If
this is a matching or swapping instance with buddy ΠA
i ,
XZW )pw. If W = T GDH(X, Y, Z), then this
set K = (Dx1
simulates computing K normally, and if W is random, then
K is random.

i , X
(cid:3)
3, X

Now for the other cases, if α is not from ΠA

i , then we
can extract the discrete log, and satisfy P4. If α is taken
1 = X1 and {X
4} = {X3, X4} for the
(cid:3)
(cid:3)
(cid:3)
from ΠA
3, X
(cid:3)
i , by P3. But because this is
4 received by ΠA
values X
2 (cid:11)= X2, so the instance is
(cid:3)
not matching of swapping, X
almost matching/swapping and the corresponding password
guess would be incorrect. Again this satisﬁes P4. Note that
in the case when the password guess is correct and we are
continuing (which because of P4 means there was a Corrupt
query), then we will know DL(X2, g), so we can compute K

580580

as A would.

Because there are at most n2

se pairs of instances receiving
Send queries, and at most nex pairs of instances in execute
queries, we get the following bound.
Advake

P6 (A) + O((nex + n

P5 (A) = Advake

se)AdvDTGDH
2

)).

(t

G

(cid:3)

Protocol P7 (randomize α and β).
If a Corrupt query
has not occurred, we generate α and β values randomly in
all instances. For an instance that is not a matching nor
swapping instance, and whose Send query (for α or β)
corresponds to the correct password (i.e., after a Corrupt
query), compute K as the other party would have.

(cid:2)
4

First consider generating only the α values randomly.
Use a hybrid argument and consider the ith instance of A
i ), where all previous instances use random exponents in
(ΠA
place of x2pw to compute their α values and all later instances
use actual α values.

(cid:2)
3+x

(cid:3)
3, X

We reduce from DDH. If the attacker succeeds in the
protocol, we let the DDH attacker guess b = 1 (i.e., a valid
DDH instance). Take a DDH instance (X, Y, Z). Let ΠA
i set
(cid:3)
(cid:3)
(cid:3)
X1 = X, X2 = Y . On a Send query with X
4, use x
3, x
4
values obtained from the NIZK extractor, or from a simulation
of B, and compute α = (ZX x
)pw. On a Send query with
2
β, use the y value obtained from the NIZK extractor to satisfy
P7, and complete the simulation of A. For other instances of
A which receive Send queries with β corresponding to the
(cid:3)
correct password, use the x
4, y values obtained from the
NIZK extractor, or from the simulation of B to compute K as
B would. This is critical when α is random, to ensure that the
instance computes the same K as the adversary would. Given a
real DDH tuple, this will be equivalent to P6. Given a random
tuple, this will be equivalent to the hybrid protocol. If the
adversary succeeds in the protocol, output b = 1, otherwise
output b = 0.

(cid:3)
3, x

it

To show that

is equivalent, we must show that we
can determine correct password guesses for Send queries
that do not correspond to matching, swapping, or almost
matching/swapping instances. Consider a Send query to ΠB
j
with a value α, where ΠB
is not matching, swapping, or
j
i , then we
almost matching/swapping. If α is not from ΠA
can extract the discrete log, determine whether it is correct
or not and satisfy P4. Note that if the password guess is
correct and we are continuing (which because of P4 means
there was a Corrupt query), then we will know DL(X2, g), so
we can compute K as A would. If α is taken from ΠA
i , then
1 = X1 and {X
4} = {X3, X4} for the values X
(cid:3)
(cid:3)
(cid:3)
(cid:3)
3, X
X
4
received by ΠA
is a matching/swapping or
almost matching/swapping instance, and we set K randomly
in either case, by P5 and P6.

i , by P3. So ΠB

(cid:3)
3, X

j

The reduction for generating random β values is analogous.

Advake

P6 (A) ≤ Advake

P7 (A) + 2nseAdvDDH
(cid:3)
G (t

).

Protocol P8 (randomize sk). In any instance in which K is
set randomly, we set sk randomly (with matching buddies
getting the same sk).

This protocol is computationally indistinguishable from the
previous one, as rExt is a computational randomness extractor.

Advake

P7 (A) ≤ Advake

P8 (A) + (nre + nte)Advcomp-ext

rExt

(cid:3)

(t

).

That concludes the proof.

VII. J-PAKE LABEL VARIANTS

In the proof of Theorem VI.1, the labels in the NIZK proofs
are the ones suggested in [24], namely, the label is the identity
of the principal who generated the proof. Since principals are
either server or client, this label implicitly indicates whether
the proof has been generated by a client or a server.

In the OpenSSL implementation [39] of J-PAKE (more
precisely, in programs s_client and s_server) and in the
Firefox Sync [16] implementation, the label is just “client” or
“sender” for the client and “server” or “receiver” for the server.
We could actually adapt our proof to these labels, in the case
where there is only a single server. However, when there are
many servers, the adversary can make a client A authenticate
to a server B1, while making the client believe it authenticates
to another server B2, if A uses the same password on B1 and
B2. The attack just consists in redirecting ﬂows from A to B1
to B2.

Finally,

if labels contained more information, such as
(A, X1, X2) for π1 and π2, (A, B, X1, X2, X3, X4) for πα,
and the corresponding data for the server’s labels, then the
proof would be simpler and tighter. In particular, protocol P3
would not be necessary anymore, and we could use random
self-reducibility of the DSDH assumption. If,
in addition,
the server B only sends its ﬁrst ﬂow after receiving the
client’s ﬁrst ﬂow,
then the proof would be even simpler
and tighter, by using partial random self-reducibility of the
DTGDH assumption. With these changes,
Theorem VII.1. Let P be the protocol described in Fig. 1
with modiﬁed labels as described above, using group G, and
with a password dictionary of size N, and where the ﬁrst
ﬂow of the server is sent after receiving the ﬁrst ﬂow of the
client. Fix an adversary A that runs in time t, and makes nse
queries of type Send to different instances, and makes nex,
nre, nte, nco queries of type Execute, Reveal, Test, Corrupt,
respectively. t
P (A) =
(nse + 1)AdvDDH

= O(t + (nse + nex + nco)texp):

p
NIZK(t

+ AdvDSDH

(nse + nex)2

) + Advuzk

Advake

nse
N

(cid:6)

+ O

)+

(t

G

(cid:3)

(cid:3)

(cid:3)

(cid:3)

G (t

Advext

NIZK(t

(cid:3)

, 2nse + nex) + (nre + nte)Advcomp-ext

rExt

(t

)

.

, 2nse + nex)+
(cid:3)

(cid:7)

Finally, we note that if we set sk = H(K) where H
is a random oracle (or, in other words, if the randomness
extractor rExt is a random oracle), we could replace the

581581

(cid:3)

G

(t

) with nroAdvCSDH

DSDH assumption with the CSDH assumption, and speciﬁ-
cally replace AdvDSDH
) in the theo-
rem above, where nro is the number of random oracle queries.
This follows from modifying the reduction in P5 to use the
adversaries random oracle queries to H to determine guesses
for the square Difﬁe-Hellman values.

(t

G

(cid:3)

VIII. SIMULATION-SOUND EXTRACTABLE

NON-INTERACTIVE ZERO-KNOWLEDGE PROOFS

Before explaining how to extend the proof of security of
J-PAKE to use Schnorr proofs instead of SE-NIZK proofs, let
us ﬁrst formally recall some deﬁnitions from [22], extended
to the case of labeled non-interactive proof systems.

A. Non-interactive proof systems

Intuitively a proof system is a protocol which enables a
prover to prove to a veriﬁer that a given word or statement x
is in a given NP-language. We are interested in non-interactive
proofs, i.e., proofs such that the prover just sends one message.
More formally, let L be a language in NP with witness
relation R,
i.e., L = {x | ∃ω, R(x, ω) = 1}. We
suppose R(x, ω) can be checked in poly-time. A labeled
non-interactive proof system for L is deﬁned by a tuple
(Setup, PK, VK), such that:
Setup(1κ) outputs a common reference string (CRS) σ;
PK(σ, x, ω, (cid:5)) takes as input a CRS σ R← Setup(1κ), a word
x ∈ L , a witness ω for x (such that R(x, ω) = 1), and a
label (cid:5) ∈ {0, 1}∗, and outputs a proof π that x is in L ,
for label (cid:5);

VK(σ, x, π, (cid:5)) takes as input the CRS σ, a word x, a proof π,
and a label (cid:5), and outputs 1 to indicate acceptance and 0
otherwise;

and such that the following two properties hold:
Perfect completeness. A non-interactive proof is complete if
an honest prover knowing a statement x ∈ L and a
witness ω for x can convince an honest veriﬁer that x
is in L , for any label. More formally, (Setup, PK, VK)
is said to be perfectly complete, if for all (cid:5), for all x ∈ L
and ω such that R(x, ω) = 1, for all σ R← Setup(1κ), we
have VK(σ, x, PK(σ, x, ω, (cid:5)), (cid:5)) = 1;
Soundness. A non-interactive proof is sound if no poly-
time adversary A can prove a false statement with non-
negligible probability. Let Advsound

NIZK (A) be:
σ R← Setup(1κ); ((cid:5), x, π) R← A(σ) :

(cid:2)

Pr

(cid:3)

VK(σ, x, π, (cid:5)) = 1 and x /∈ L
Extractable Non-interactive

≤ ε.
zero-

B. Simulation-Sound
knowledge proofs (SE-NIZK)

An (unbounded) SE-NIZK (simulation-sound extractable
non-interactive zero-knowledge) proof is a non-interactive
proof system with two simulators Sim1 and Sim2, which can
simulate Setup and PK, but such that Sim2 does not need
any witness. More formally an SE-NIZK proof is deﬁned by

a tuple (Setup, PK, VK, Sim1, Sim2, Ext) such that (Setup,
PK, VK) is a non-interactive proof system, and:
Sim1(1κ) generates a CRS σ and two trapdoors τ, ξ, such that
Sim2 can use τ to simulate proofs under σ, and Ext can
use ξ to extract witnesses from proofs;

Sim2(σ, τ, x, (cid:5)) takes as input the CRS σ, the corresponding
trapdoor τ, a word x (not necessarily in L ), and a label
(cid:5), and outputs a (fake or simulated) proof π for x;

Ext(σ, ξ, x, π, (cid:5)) takes as input the CRS σ, the corresponding
trapdoor ξ, a word x, a label (cid:5), and a valid proof π,
and extracts from π a witness ω for x if possible (and
otherwise outputs ⊥).

and such that it veriﬁes the following property:
Unbounded zero-knowledge. An
zero-knowledge

(unbounded)
are indistinguishable from real proofs. Let Advuzk
be:

NIZK
if

proof

is
proofs
NIZK(A)

simulated
(cid:3)

(cid:2)

(cid:2)

Pr
− Pr

σ R← Setup(1κ) : APK(σ,·,·,·)
(σ) = 1
(σ, τ, ξ) R← Sim1(1κ) : ASim(cid:2)(σ,τ,·,·,·)

(σ) = 1

(cid:3)

(cid:3)

(σ, τ, x, ω, (cid:5)) = Sim2(σ, τ, x, (cid:5)); we write
where Sim
NIZK(t, nsim) = maxA {Adv(A)}, where the maxi-
Advuzk
mum is taken over all adversaries of time complexity at
or PK.
most t and making at most nsim queries to Sim
is
simulation-sound extractable if Ext can extract a witness
from any proof generated by the adversary, even if the
NIZK(A) be:
adversary can see simulated proofs. Let Advext

NIZK

proof

Simulation-sound extractability. An

(cid:3)

(cid:2)

Pr

(σ, τ, ξ) R← Sim1(1κ);

(x, π) R← ASim2(σ,τ,·,·)

(σ, ξ) :
VK(σ, x, π, (cid:5)) = 1, ((x, (cid:5)), π) /∈ S
and R(x, Ext(σ, ξ, x, π, (cid:5))) = 0

(cid:3)

where S is the set of query-response pairs ((x, (cid:5)), π)
for Sim2(σ, τ,·,·); we write Advext
NIZK(t, nsim) =
maxA {Adv(A)}, where the maximum is taken over all
adversaries of time complexity at most t and making at
most nsim queries to Sim2.

IX. ALGEBRAIC SIMULATION-SOUND EXTRACTABLE

NIZK AND SCHNORR PROOFS

Schnorr signatures [43] can be seen as the most efﬁcient
NIZK proof (in the random-oracle model) for the discrete
logarithm language. However, while there exists an extractor
using rewinding for Schnorr signatures using the forking
lemma [42], no straight-line extractor (which can directly
extract the witness from the proof, as in our deﬁnition in
Section II-B) is known. Unfortunately, using rewinding ex-
tractors would induce an exponential blow-up in our security
reduction for J-PAKE (as it is the case in the proof for blind
signatures in [42]).

582582

In this section, we show how to circumvent this problem
if we assume the adversary is algebraic. After recalling the
deﬁnition of algebraic adversaries, we ﬁrst
introduce the
notion of algebraic-simulation-sound extractable NIZK (which
is a weak variant of simulation-sound extractable NIZK). We
then show that Schnorr proofs are algebraic-simulation-sound
extractable NIZK proofs (in the random-oracle model), and
that the J-PAKE proof can be adapted to only require that
the NIZK proofs are algebraic-simulation-sound extractable
instead of simulation-sound extractable.

A. Algebraic Adversaries

Algebraic adversaries were introduced by Paillier and
Vergnaud in [40]. An adversary is algebraic (with respect
to G) if it is limited to perform group operations on group
elements in G, and no other operations. Operations on non-
group elements are not restricted.

This means that if the adversary only see groups elements
g1, . . . , gn, and if it outputs some group element h, then there
is a way to extract from the adversary λ1, . . . , λn ∈ Zn
p such
that:

h = gλ1

1 ··· gλn
n .

We call (λ1, . . . , λn) the discrete logarithms of h in base
(g1, . . . , gn). This property even holds for group elements
given as inputs to the random oracle, if any.

Assuming the adversary to be algebraic is a weaker as-
sumption than using the (non-programmable) generic group
model [44]. In particular, all the proofs of this section are also
valid in the non-programmable generic group model.

A subtle point in all this section is that that the “adversary”
for the extractor Ext (or what generates the proof π) is not
simply the adversary of J-PAKE, but very roughly, a “part of”
the reduction from J-PAKE to some hard problem. This means
that we also need the reduction to be algebraic and we cannot
assume that the reduction knows the discrete logarithms of
(g2, . . . , gn) in base g1. Indeed, these values (g1, . . . , gn) will
often come from an instance of a hard problem such as DDH
or DTGDH.

A completely wrong but very tempting way to make our
proof work for Schnorr proofs would be to just forget about
the bases and to say that in the generic group model, by
controlling the group operation oracles5, Ext can extract the
discrete logarithm of any element. However, if that were true,
NIZK proofs would be useless (since we can compute the
discrete logarithm of any element without them) and could
be removed. But, clearly, the J-PAKE protocol without NIZK
proof is insecure.

What is going wrong is that this solution supposes that
Ext has full control over the group operation oracles, but the
reduction also needs control on these oracles to work properly.
So there is a conﬂict for the group operation oracles. The
introduction of bases for discrete logarithms is a way to solve

5In the generic group model, group element are represented by random
strings, and group operations are performed by calling some group operation
oracles.

this conﬂict. We remark there is no such conﬂict with the
random oracle, because we suppose that the NIZK has full
control on it, and that it is not the same random oracle as the
one used in J-PAKE to derive the secret key sk.

B. Schnorr Proofs and Issues

CRS and parameters, and the elements sent in the protocol),
this is not the case for the extractor Ext which explicitly needs
to be given the discrete logarithms of all group elements in
the base (g1, . . . , gn). So we need to ensure that Ext does not
change its behavior when we change bases. We will do it by
introducing a property called base indistinguishability.

(cid:2)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

).

(g1,...,gn)

(σ, ξ, x, π, (cid:5)).

, e ← H((cid:5), (u, h), u

Schnorr Proof
for Discrete Logarithm. Let us recall
the Schnorr proof for the discrete logarithm language (see
Section II-B for notations). There is no setup and no CRS, but
a random oracle6 H : {0, 1}∗ → Zp. There is no trapdoor τ
and ξ: the trapdoor τ (for simulation Sim2) consists in being
able to program the random oracle and the trapdoor ξ (for
extraction Ext) consists in being able to extract the discrete
logarithms of all group elements. This input of the discrete
logarithms of all group elements for Ext is implicit in what
follows. When needed, we indicate the base which is used in
exponent of Ext, e.g., Ext
The Schnorr proof for the word (u, h) = (hr, h) and label
(cid:5), with witness r = ω ∈ Zp is π = (z, e), with r
(cid:3) R← Zp,
(cid:3) ← hr
(cid:3)−er mod p. Check-
u
ing a proof π = (z, e) for (u, h) and (cid:5) consists in computing
(cid:3) ← hzue and checking that e = H((cid:5), (u, h), u
u
The simulator Sim2(σ, τ, x = (u, h), π, (cid:5)) just picks e
and z at random in Zp, and then programs H such that
= hzue. Unbounded zero-knowledge
H((cid:5), x, u
is straightforward: Advuzk ≤ (nro + nsim)/p, with nro the
number of queries to the random oracle and nsim the number
(cid:3) is uniform in Zp, and H((cid:5), x, u
(cid:3)
of queries to Sim
)
is not already deﬁned (and so can be programmed) with
probability at least 1 − (nro + nsim)/p.
Issues. Ideally, we would like to prove that Schnorr proofs
are extractable when adversaries are algebraic, or in other
words, when the extractor Ext also takes as input the discrete
logarithms of all group elements of the proof and the word (in
some base (g1, . . . , gn)).

) and z ← r

) = e, with u

, since u

However, two issues arise. First, if the adversary knows the
discrete logarithms of g2, . . . , gn in base g1, and the extractor
does not, there seems to be no way to extract the witness. For
example, let us suppose that the base is (g1, g2, g3) with g1 =
g R← G, g2 ← gα and g3 ← gβ, with α, β R← Zp. Then, if the
(cid:3) R← Zp,
adversary is able to compute α and β, it can pick s, s
β−
set (u, h) ← (gs
esα mod p, and π ← (z, e). The fact the adversary is algebraic
(cid:3), and z, while the fact the proof
only enables us to recover s, s
. Hence it is
is valid only ensures that gz = u
not clear at all how to extract a scalar r such that u = gr.

3 , e ← H((cid:5), (u, h), u

−e = gs
(cid:2)
2 g

), z ← s

(cid:3) ← gs

2, g), u

−se
3

Second, when doing a proof by games (or protocols as in
Section VI), we use various assumptions, and so the base
(g1, . . . , gn) (which basically depends on the assumption)
changes during the proof. While this is transparent for the
J-PAKE adversary, which never really sees (g1, . . . , gn) but
derived elements from this base (the elements of the potential

u

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:2)

6This random oracle should be different from the one in the J-PAKE. We
recall that using preﬁxes enable to generate multiple random oracles from one
random oracle.

583583

C. Hard-Linear Distributions and Algebraic Simulation-
Sound Extractable NIZK

Let us ﬁrst introduce the notion of a hard-linear distribution.
A hard-linear distribution D is a distribution of tuples in Gn
(for some n), such that, given G and (g1, . . . , gn) R← D, it
is computationally hard to ﬁnd (μ1, . . . , μn) (cid:11)= 0n such that
1 ··· gμn
gμ1

n = 1. More precisely, let Advhard-lin

(A) be

D

(cid:4)

Pr

(g1, . . . , gn) R← D; (μ1, . . . , μn) R← A(g1, . . . , gn) :
n = 1

1 ··· gμn
gμ1

(cid:5)

.

We also suppose in hard-linear distributions that g1 = g,
a random generator of G (this can be done without
loss
of generality) and that there is a way to generate the base
(g1, . . . , gn) R← D, such that the discrete logarithms ν2, . . . , νn
of g2, . . . , gn in base g1 = g are known.

Now to deﬁne

algebraic-simulation-sound extractable
NIZK, we replace the simulation-sound extractability property
by the following two properties (where we assume for the sake
of simplicity, that σ, τ, and ξ do not contain group elements):

Weak algebraic simulation-sound extractability. It is simi-
lar to simulation-sound extractability except the extractor
is given the discrete logarithms of all group elements in
a base (g = g1), with g R← G\{1} (n = 1). Formally, for
(A)
any poly-time algebraic adversary A, let Advw-a-ext
be

NIZK

(cid:2)

(σ, τ ) R← Sim1(1κ); g R← G;

Pr
(x, π) R← A(g),Sim2(σ,τ,·,·),Ext(g)(σ,ξ,·,·,·)

(G, g, σ, ξ) :
VK(σ, x, π) = 1, ((x, (cid:5)), π) /∈ S

and R(x, Ext

(g)

(σ, ξ, x, π, (cid:5))) = 0

(cid:3)

where S is the set of query-response pairs ((x, (cid:5)), π) for
Sim2(σ, τ,·,·).

Base indistinguishability. A

NIZK
everything

base-
indistinguishable
indistinguishable
when used with the base (g = g1) with g R← G \ {1},
or with a hard linear base (g1, . . . , gn) R← D. More
formally, for any poly-time algebraic adversary A, let

proof

is

is

if

Advbase-ind

NIZK,D,D(cid:2) (A) be:
(cid:2)

(σ, τ ) R← Sim1(1κ); (g1, . . . , gn) R← D :
(cid:2)

Pr
ASim2(σ,τ,·,·),Ext(g1)(σ,ξ,·,·,·)
− Pr
ASim2(σ,τ,·,·),Ext(g1 ,...,gn )(σ,ξ,·,·,·)

(σ, τ ) R← Sim1(1κ); (g1, . . . , gn) R← D :

(G, g1, . . . , gn, σ) = 1

(cid:3)

(G, g1, . . . , gn, σ)

(cid:3)

= 1

where in the ﬁrst case, (g1, . . . , gn) are generated such
that their discrete logarithms 1, ν2, . . . , νn in base g1 are
known, and so the discrete logarithm λ in base g1 of
any group element v ∈ G generated by A (needed by
(g1)) can be computed from the discrete logarithms
Ext
(λ1, . . . , λn) in base (g1, . . . , gn) of v (these discrete
logarithms can be extracted from A, since A is algebraic
and only take as input the following group elements:
g1, . . . , gn): λ = λ1 + ν2λ2 + ··· + νnλn. In the second
(g1,...,gn) just
case, no such transform is required since Ext
need the discrete logarithms in base (g1, . . . , gn), which
can be directly extracted from the algebraic adversary A.
Ext is assumed to return ⊥, when (x, π, (cid:5)) comes from
a query-response pair of Sim2.

The resulting scheme is called an algebraic-simulation-
sound extractable NIZK. A priori, an algebraic-simulation-
sound extractable is not an SE-NIZK, but an SE-NIZK is
trivially algebraic-simulation-sound extractable even without
any condition on the bases.

D. Algebraic Simulation-Sound Extractability of Schnorr
Proofs

(g1,...,gn)

Weak Algebraic Simulation-Sound Extractability. Let us
ﬁrst deﬁne the extractor Ext
(σ, τ, x, π, (cid:5)) as follows:
it ﬁrst checks the proof π (using VK), and returns ⊥ if this
proof is not valid. Otherwise, it gets the discrete logarithms
(cid:15)λu = (λu,1, . . . , λu,n) ∈ Zn
p for u (in base (g1, . . . , gn)) and
(cid:15)λh = (λh,1, . . . , λh,n) ∈ Zn
p of h, and returns r, such that
(cid:15)λu = r (cid:15)λh, if possible, and ⊥ otherwise. When the base is
(g = g1) R← G\{1}, if h (cid:11)= 1, (cid:15)λh ∈ Zp and (cid:15)λh (cid:11)= 0, therefore
r always exists and the extractor clearly always output the
correct answer. If h = 1 and u (cid:11)= 1, then, with probability
1 − 1/p, H((cid:5), x, u
(A) ≤ 1 −
(1 − 1/p)nro ≤ nro/p, where nro is the number of random
oracle queries.
Base Indistinguishability. To prove base indistinguishability,
we ﬁrst remark that when Ext does not return ⊥, it will
return the same value with (g1, . . . , gn) as with (g1), as it
always return either ⊥ or the correct discrete logarithm of u
in base h. With the base (g1), the extraction always works
(as seen previously in the proof of weak algebraic simulation-
sound extractability). Therefore, we only need to prove that
with any hard linear base (g1, . . . , gn), if π = (z, e) is a

(cid:3), and so Advw-a-ext

) (cid:11)= logu u

(cid:3)

(cid:3)

valid proof for x = (u, h) and (cid:5), then the probability that
Ext

(σ, τ, x, π, (cid:5)) returns ⊥ is negligible.

(g1,...,gn)
For that purpose, we write (cid:15)λu, (cid:15)λu

(cid:2), and (cid:15)λh the discrete
(cid:3)
= hzue, and h in base (g1, . . . , gn). For
logarithms of u, u
(cid:3), h, and (cid:5), if (cid:15)λu and (cid:15)λh are not linearly dependent
any u, u
(i.e., if we cannot extract the proof for (u, h)), there exists at
most one scalar e ∈ Zp, such that (cid:15)λu
(cid:2)−e (cid:15)λu and (cid:15)λh are linearly
) R← Zp does not output that value
dependent. If H((cid:5), (u, h), u
e, and π = (z, e) is valid for word x = (u, h) and label (cid:5),
(cid:2) − z (cid:15)λh − e (cid:15)λu (cid:11)= 0n
then u
where gμ1
n = 1. In other words, if we cannot extract the
witness from a valid proof π = (z, e) for word x = (u, h) and
label (cid:5), then with probability ≥ (1− 1/p)nro ≥ 1− nro/p (the
probability that for any query to the random oracle, the output
is not the bad value e), we can extract a vector (cid:15)μ breaking the
hard linear property of D. Hence:
D

= hzue and one can ﬁnd (cid:15)μ = (cid:15)λu
1 ··· gμn

NIZK,D (A) ≤ Advhard-lin

Advbase-ind

) + nro/p

(t

(cid:3)

= t + O(notexp), no the number of queries to the Sim2

with t
and Ext oracles, and t the running time of A.
E. Update of the J-PAKE Security Proof

(cid:3)

(cid:3)

Overview. We ﬁrst remark that our reduction for J-PAKE
is algebraic: in each protocol of the proof in Section VI,
instances are algebraic. To prove the J-PAKE security with
algebraic-simulation-sound extractable proofs, it is therefore
sufﬁcient to exhibit which bases are used in each protocol
(which basically correspond to the group elements coming
from the assumptions used) and to show that all these bases are
hard-linear. Bases just consist of the group elements coming
from the hard problems used in the proof: DDH, DSDH, and
DTGDH (which can be replaced by three DDH).

More precisely, when we are doing a reduction from a
distinguisher between protocols Pi and Pi+1, to e.g., DDH,
what we do is, from a tuple (g1 = g, g2 = X, g3 = Y, g4 =
Z) ∈ G4, simulate instances of the protocol such that, if
Z = DH(X, Y ) (DDH tuple) then we simulate everything as
in Pi, while if Z is random (random tuple), then we simulate
+
everything as in Pi+1. So we just consider a protocol P
i
which is as Pi except every group element is computed from
a DDH tuple (g1, . . . , g4) as in the reduction, and a protocol
−
i+1 which is as Pi+1 except every group element is computed
P
from a random tuple (g1, . . . , g4). In addition, we suppose
that in Pi and Pi+1, the extraction Ext is made in base
−
i+1, the extraction is made in base
(g1), while in P
(g1, . . . , g4). Then the DDH assumption ensures that P
i and
−
i+1 are indistinguishable (as in the original proof), while
P
the base indistinguishability from DDH tuples (g1, . . . , g4)
+
and random tuples (g1, . . . , g4) ensures that Pi and P
are
−
i
i+1 and Pi+1 are indistinguishable,
indistinguishable and P
assuming (as proved below) that these bases are hard-linear.
So ﬁnally: Pi and Pi+1 are indistinguishable under base
indistinguishability and DDH.

and P

+
i

+

From the above discussion, we only need to prove that the

following bases are hard-linear:

584584

• (g1 = g, g2 = X = gx, g3 = Y = gy, g4 = Z) with
g R← G \ {1}, x, y R← Zp, and Z = gxy in the one hand,
or Z R← G on the other hand (for DDH);
) with g R← G\{1},
• (g1 = g, g2 = X = gx, g3 = Z = gx
2 on the one hand, or Z R← G on the
x R← Zp, and Z = gx
other hand (for DSDH);
• (g1 = g, g2 = X = gx, g3 = Y = gy, g4 = Z = gz, g5 =
gxy, g6 = gxz, g7 = gyz, g8 = Z) with g R← G \ {1},
x, y, z R← Zp, and Z = gxyz on the one hand, or Z R← G
on the other hand (for DTGDH).

2

Hard linearity of random bases. Let us ﬁrst prove the hard
linearity of random bases (g1 = g, g2, . . . , gn) R← D = (G \
{1})× Gn−1, under the discrete logarithm assumption, which
states it is hard to compute the discrete logarithm of a random
group element X ∈ G in base g, a generator of G.
R← Zp, sets gi =
The reduction ﬁrst picks α2, β2, . . . , αn, βn
gαi X βi for i = 2, . . . , n, and gives it to the adversary for the
hard linearity problem A. Then A outputs (μ1, . . . , μn) (cid:11)=
1 ··· gμn
(0, . . . , 0), such that gμ1
n = 1. If we take the discrete
logarithm of the previous relation
(μ1 + μ2α2 + ··· + μnαn) + (μ2β2 + ··· + μnβn)x = 0,
where x is the discrete logarithm of X in base g,
i.e.,
to the discrete logarithm instance X. Since
the answer
(μ1, . . . , μn) (cid:11)= (0, . . . , 0), there exists i = 2, . . . , n such
(cid:11)= 0, and in addition, (β2, . . . , βn) are hidden to
that μi
the adversary (from an information theoretic point of view),
hence μ2β2 + ··· + μnβn = 0 with probability 1/p. And
when, μ2β2 + ··· + μnβn (cid:11)= 0, the reduction can compute
x = −(μ1 + μ2α2 + ··· + μnαn)/(μ2β2 + ··· + μnβn).
Hence:

Advhard-lin

D

(A) ≤ AdvDL
G (t

(cid:3)

) + 1/p,

(cid:3)

= t + O(ntexp), and t the running time of A.

with t
Hard linearity of bases used in the proof. To prove the hard
linearity of the bases used in the proof, it is therefore sufﬁcient
to prove that they are computationally indistinguishable from
random bases. Clearly, bases from DDH and DSDH are either
random or indistinguishable from random.

(cid:2)

(cid:2)

It remains to show that bases (g1 = g, g2 = X = gx, g3 =
Y = gy, g4 = Z = gz, g5 = gxy, g6 = gxz, g7 = gyz, g8 = Z)
with g R← G \ {1}, x, y, z R← Zp, and Z = gxyz on the one
hand, or Z R← G on the other hand, for DTGDH are hard linear.
They are indistinguishable from (g1 = g, g2 = X = gx, g3 =
Y = gy, g4 = Z = gz, g5 = gx
, g8 =
Z), with g R← G \ {1}, x, y, z, x
(cid:3) R← Zp, with Z = gxyz
(cid:3)
or Z R← G respectively, under the DDH assumption (properly
randomized). When Z R← G, this is a random tuple, otherwise
this is indistinguishable from a random tuple under DDH, so
(cid:3)
ﬁnally, Advhard-lin
) + 1/p + 2AdvDDH
),
G (t
for D any of the two base distributions for DTGDH, and t
(cid:3)
=
t + O(ntexp).

(A) ≤ AdvDL
G (t

, g6 = gy
(cid:3)

, g7 = gz

, y

, z

D

(cid:3)

Putting this all

is
instantiated with Schnorr proofs of knowledge, and we work

together, when the J-PAKE protocol

(cid:2)

585585

in a model with algebraic adversaries and random ora-
cles, we can plug the following bounds into Theorem VI.1
and Theorem VII.1:
Advuzk

, nsim) ≤ (nsim + nro)/p,

NIZK(t

(cid:3)

and

Advext

NIZK(t

(cid:3)

, nsim) = Advw-a-ext

(t

(cid:3)

, nsim) ≤ nro/p,

where nro is the number of queries to the random oracle
made by the adversary A. Technically we should also add
the advantage Advbase-ind each time the base changes, but
this only adds O(AdvDDH
(t
) +
(cid:3)
nro/p) = O(AdvDSDH
)) which is a term already present in
the original bound.

) + AdvDSDH

) + AdvDL

(t

(t

(t

(cid:3)

(cid:3)

(cid:3)

ACKNOWLEDGMENTS

This work was supported in part by the CFM Foundation
and the European Research Council under the European Com-
munity’s Seventh Framework Programme (FP7/2007-2013
Grant Agreement no. 339563 – CryptoCloud).

REFERENCES

[1] M. Abdalla, F. Benhamouda, and D. Pointcheval, “Public-key encryption
indistinguishable under plaintext-checkable attacks,” in PKC 2015, ser.
LNCS, J. Katz, Ed., vol. 9020. Springer, Mar. / Apr. 2015, pp. 332–352.
[2] M. Abdalla, P.-A. Fouque, and D. Pointcheval, “Password-based au-
thenticated key exchange in the three-party setting,” in PKC 2005, ser.
LNCS, S. Vaudenay, Ed., vol. 3386. Springer, Jan. 2005, pp. 65–84.
[3] M. Abdalla and D. Pointcheval, “Simple password-based encrypted key
exchange protocols,” in CT-RSA 2005, ser. LNCS, A. Menezes, Ed., vol.
3376. Springer, Feb. 2005, pp. 191–208.

[4] F. Bao, R. H. Deng, and H. Zhu, “Variations of Difﬁe-Hellman problem,”
in ICICS 03, ser. LNCS, S. Qing, D. Gollmann, and J. Zhou, Eds., vol.
2836. Springer, Oct. 2003, pp. 301–312.

[5] M. Bellare, D. Pointcheval, and P. Rogaway, “Authenticated key ex-
change secure against dictionary attacks,” in EUROCRYPT 2000, ser.
LNCS, B. Preneel, Ed., vol. 1807. Springer, May 2000, pp. 139–155.
[6] M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm
for designing efﬁcient protocols,” in ACM CCS 93, V. Ashby, Ed. ACM
Press, Nov. 1993, pp. 62–73.

[7] S. M. Bellovin and M. Merritt, “Encrypted key exchange: Password-
based protocols secure against dictionary attacks,” in 1992 IEEE Sym-
posium on Security and Privacy.
IEEE Computer Society Press, May
1992, pp. 72–84.

[8] ——, “Augmented encrypted key exchange: A password-based protocol
secure against dictionary attacks and password ﬁle compromise,” in ACM
CCS 93, V. Ashby, Ed. ACM Press, Nov. 1993, pp. 244–250.

[9] D. Boneh, “The decision Difﬁe-Hellman problem,” in Algorithmic

number theory. LNCS, 1998, pp. 48–63.

[10] V. Boyko, P. D. MacKenzie, and S. Patel, “Provably secure
password-authenticated key exchange using Difﬁe-Hellman,” in EURO-
CRYPT 2000, ser. LNCS, B. Preneel, Ed., vol. 1807.
Springer, May
2000, pp. 156–171.

[11] E. Bresson, O. Chevassut, and D. Pointcheval, “New security results on
encrypted key exchange,” in PKC 2004, ser. LNCS, F. Bao, R. Deng,
and J. Zhou, Eds., vol. 2947. Springer, Mar. 2004, pp. 145–158.

[12] R. Canetti, S. Halevi, J. Katz, Y. Lindell, and P. D. MacKenzie, “Univer-
sally composable password-based key exchange,” in EUROCRYPT 2005,
ser. LNCS, R. Cramer, Ed., vol. 3494. Springer, May 2005, pp. 404–
421.

[13] C. Chevalier, P.-A. Fouque, D. Pointcheval, and S. Zimmer, “Optimal
randomness extraction from a Difﬁe-Hellman element,” in EURO-
CRYPT 2009, ser. LNCS, A. Joux, Ed., vol. 5479.
Springer, Apr.
2009, pp. 572–589.

[14] Y. Cliff, C. Boyd, and J. M. González Nieto, “How to extract and
expand randomness: A summary and explanation of existing results,”
in ACNS 09, ser. LNCS, M. Abdalla, D. Pointcheval, P.-A. Fouque, and
D. Vergnaud, Eds., vol. 5536. Springer, Jun. 2009, pp. 53–70.

[15] J.-S. Coron, J. Patarin, and Y. Seurin, “The random oracle model and
the ideal cipher model are equivalent,” in CRYPTO 2008, ser. LNCS,
D. Wagner, Ed., vol. 5157. Springer, Aug. 2008, pp. 1–20.

[16] “Firefox Sync.” [Online]. Available: https://www.mozilla.org/en-US/

ﬁrefox/sync/

[17] J. A. Garay, P. D. MacKenzie, and K. Yang, “Strengthening zero-
knowledge protocols using signatures,” Journal of Cryptology, vol. 19,
no. 2, pp. 169–209, Apr. 2006.

[18] R. Gennaro and Y. Lindell, “A framework for password-based authen-
ticated key exchange,” ACM Transactions on Information and System
Security, vol. 9, no. 2, pp. 181–234, 2006.

[19] O. Goldreich and Y. Lindell, “Session-key generation using human
passwords only,” in CRYPTO 2001, ser. LNCS, J. Kilian, Ed., vol. 2139.
Springer, Aug. 2001, pp. 408–432.

[20] V. Goyal, A. Jain, and R. Ostrovsky, “Password-authenticated session-
key generation on the internet in the plain model,” in CRYPTO 2010,
ser. LNCS, T. Rabin, Ed., vol. 6223. Springer, Aug. 2010, pp. 277–294.
[21] A. Groce and J. Katz, “A new framework for efﬁcient password-based
authenticated key exchange,” in ACM CCS 10, E. Al-Shaer, A. D.
Keromytis, and V. Shmatikov, Eds. ACM Press, Oct. 2010, pp. 516–
525.

[22] J. Groth, “Simulation-sound NIZK proofs for a practical language and
constant size group signatures,” in ASIACRYPT 2006, ser. LNCS, X. Lai
and K. Chen, Eds., vol. 4284. Springer, Dec. 2006, pp. 444–459.

[23] J. Groth, R. Ostrovsky, and A. Sahai, “Perfect non-interactive zero
knowledge for NP,” in EUROCRYPT 2006, ser. LNCS, S. Vaudenay,
Ed., vol. 4004. Springer, May / Jun. 2006, pp. 339–358.

[24] F. Hao and P. Ryan, “J-pake: Authenticated key exchange without pki,”
in Transactions on Computational Science XI, ser. Lecture Notes in
Computer Science, M. Gavrilova, C. Tan, and E. Moreno, Eds. LNCS,
2010, vol. 6480, pp. 192–206.

[25] F. Hao and P. Zielinski, “A 2-round anonymous veto protocol,” in Se-
curity Protocols, 14th International Workshop, Cambridge, UK, March
27-29, 2006, Revised Selected Papers, ser. Lecture Notes in Computer
Science, B. Christianson, B. Crispo, J. A. Malcolm, and M. Roe, Eds.,
vol. 5087. LNCS, 2006, pp. 202–211.

[26] J. Håstad, R. Impagliazzo, L. A. Levin, and M. Luby, “A pseudorandom
generator from any one-way function,” SIAM Journal on Computing,
vol. 28, no. 4, pp. 1364–1396, 1999.

[27] T. Holenstein, R. Künzler, and S. Tessaro, “The equivalence of the
random oracle model and the ideal cipher model, revisited,” in 43rd
ACM STOC, L. Fortnow and S. P. Vadhan, Eds. ACM Press, Jun.
2011, pp. 89–98.

[28] D. P. Jablon. [Online]. Available: http://www.jablon.org/passwordlinks.

html

[29] ——, “Strong password-only authenticated key exchange,” SIGCOMM

Comput. Commun. Rev., vol. 26, no. 5, pp. 5–26, Oct. 1996.

[30] S. Jiang and G. Gong, “Password based key exchange with mutual
authentication,” in SAC 2004, ser. LNCS, H. Handschuh and A. Hasan,
Eds., vol. 3357. Springer, Aug. 2004, pp. 267–279.

[31] J. Katz. [Online]. Available: https://www.lightbluetouchpaper.org/2008/

05/29/j-pake/\#comment-9547

[32] J. Katz, R. Ostrovsky, and M. Yung, “Efﬁcient and secure authenticated
key exchange using weak passwords,” Journal of the ACM, vol. 57,
no. 1, 2009.

[33] J. Katz and V. Vaikuntanathan, “Round-optimal password-based authen-
ticated key exchange,” in TCC 2011, ser. LNCS, Y. Ishai, Ed., vol. 6597.
Springer, Mar. 2011, pp. 293–310.

[34] H. Krawczyk, “Cryptographic extraction and key derivation: The HKDF
scheme,” in CRYPTO 2010, ser. LNCS, T. Rabin, Ed., vol. 6223.
Springer, Aug. 2010, pp. 631–648.

[35] P. MacKenzie, “On the security of the SPEKE password-authenticated
key exchange protocol,” Cryptology ePrint Archive, Report 2001/057,
2001. [Online]. Available: http://eprint.iacr.org/2001/057

[36] P. D. MacKenzie, S. Patel, and R. Swaminathan, “Password-
authenticated key exchange based on RSA,” in ASIACRYPT 2000, ser.
LNCS, T. Okamoto, Ed., vol. 1976. Springer, Dec. 2000, pp. 599–613.
[37] P. D. MacKenzie and K. Yang, “On simulation-sound trapdoor commit-
ments,” in EUROCRYPT 2004, ser. LNCS, C. Cachin and J. Camenisch,
Eds., vol. 3027. Springer, May 2004, pp. 382–400.

[38] “Nest.” [Online]. Available: http://nest.com
[39] “OpenSSL project.” [Online]. Available: http://www.openssl.org

[40] P. Paillier and D. Vergnaud, “Discrete-log-based signatures may not be
equivalent to discrete log,” in ASIACRYPT 2005, ser. LNCS, B. K. Roy,
Ed., vol. 3788. Springer, Dec. 2005, pp. 1–20.

[41] S. Patel, “Number theoretic attacks on secure password schemes,” in
IEEE Computer

1997 IEEE Symposium on Security and Privacy.
Society Press, 1997, pp. 236–247.

[42] D. Pointcheval and J. Stern, “Security arguments for digital signatures
and blind signatures,” Journal of Cryptology, vol. 13, no. 3, pp. 361–396,
2000.

[43] C.-P. Schnorr, “Efﬁcient signature generation by smart cards,” Journal

of Cryptology, vol. 4, no. 3, pp. 161–174, 1991.

[44] V. Shoup, “Lower bounds for discrete logarithms and related problems,”
Springer,

in EUROCRYPT’97, ser. LNCS, W. Fumy, Ed., vol. 1233.
May 1997, pp. 256–266.

[45] M. Steiner, G. Tsudik, and M. Waidner, “Difﬁe-Hellman key distribution
extended to group communication,” in ACM CCS 96. ACM Press, Mar.
1996, pp. 31–37.

[46] “Thread protocol.” [Online]. Available: http://www.threadgroup.org
[47] T. D. Wu, “The secure remote password protocol,” in NDSS’98. The

Internet Society, Mar. 1998.

APPENDIX

THE INVERTED-ADDITIVE DIFFIE-HELLMAN

ASSUMPTIONS (CIDH AND DIDH)

Here we recall

two assumptions used in [35] to prove
the security of the SPEKE protocols (for the comparison in
Table I), and show some relations between these assumptions
and the other assumptions we consider in this paper. These
relations are summarized in Fig. 2.

A. Deﬁnition of CIDH and DIDH

Computational Inverted-Additive Difﬁe-Hellman (CIDH).
For two values X = gx and Y = gy, let IDH(X, Y ) =
gxy/(x+y) (or 1 if x + y = 0) be the Inverted Additive Difﬁe-
Hellman value corresponding to X and Y . An algorithm for
the Computational Inverted-Additive Difﬁe-Hellman takes two
elements X and Y , and outputs the Inverted-Additive Difﬁe-
Hellman value of X and Y . Let A be an algorithm with input
(X, Y ). Let AdvCIDH

(A) be

G

(x, y) R← Z

2

p; X ← gx; Y ← gy :

A(X, Y ) = IDH(X, Y )

(cid:5)

.

(cid:4)

Pr

Decision Inverted-Additive Difﬁe-Hellman (DIDH). An al-
gorithm for the Decision Inverted-Additive Difﬁe-Hellman
takes three elements X, Y , and Z, and attempts to distinguish
whether Z is the Inverted-Additive Difﬁe-Hellman value cor-
responding to X and Y , or is a random element of G. Let A
(A) be
be an algorithm with input (X, Y, Z). Let AdvDIDH
p; X ← gx; Y ← gy; Z ← IDH(X, Y ) :
(cid:5)
A(X, Y, Z) = 1
p; X ← gx; Y ← gy; Z ← gz :
(cid:5)
A(X, Y, Z) = 1

(x, y, z) R← Z

(x, y) R← Z

− Pr

Pr

(cid:4)

(cid:4)

G

2

3

.

B. Relations

Hardness of DSDH Implies Hardness of DIDH. Let
A be an adversary against DIDH. Then we can construct
an adversary B against DSDH as follows: B(X, Y ) picks

586586

(t) ≤ AdvCIDH

G

G

(t) + 1/p.

that we have AdvDIDH
Hardness of CSDH Implies Hardness of CIDH. The proof
is very similar to the one that DSDH implies DIDH. More
precisely, let A be an adversary against CIDH. Then we can
construct an adversary B against CSDH as follows: B(X)
picks z R← Zp, computes Z
) =
(gzX, gzX

(cid:3) R← A(X
−1), and outputs Y = Z
probability AdvCIDH
have Z
) = (z2 − x2)/(2z), hence Y = gx
(cid:3)

(cid:3)
(cid:3)
) with (X
, Y
(cid:3)−2zgz
2.
(A), we

With
IDH(X
X = gx, except if z = 0. Therefore, we get

=
2, where

, Y

, Y

G

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(B) + 1/p.

AdvCIDH

G

G

(A) ≤ AdvCSDH
(cid:11)2 ≤ AdvCIDH

(cid:10)

Hardness of CIDH Implies Hardness of DL. It is clear that
we have
(t), as knowing the discrete
logarithms of X and Y enables to compute IDH(X, Y ).

AdvDL

G (t)

G

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:2)

(cid:2)

2

(cid:2)

(cid:3)

Y

, Y

, Y

, Z

) =

−1)

, gy
(cid:3)
(cid:3)
y

, gz
(cid:3)
/(x

−1, (gz

(cid:3)
1/(2z)

, Z
, Y
(cid:3)
) (Z

= z+x, y
(cid:3)

), with x
+ y

, Z
(cid:3) and Y

z R← Zp and outputs A(X
) with (X
= 0 when z = 0).
(gzX, gzX
Indeed, if x R← Zp, X = gx, and Y = SDH(X) = gx
2, then
= z−x, z
(cid:3)
(cid:3)
) = (gx
(X
=
(z2− x2)/(2z) = x
= IDH(X, Y ),
(cid:3) are two independent uniform random group
and X
elements in G, as (x, z) (cid:12)→ (z + x, z − x) is a bijection of Z
2
p.
if x, y R← Zp,
then
Otherwise,
= z − x,
(cid:3)
), with x
, gz
, Y
(X
= (z2 − y)/(2z). The function (x, y, z) (cid:12)→ (z + x, z −
(cid:3)
z
x, (z2 − y)/(2z)) is a bijection of Z
3
p, if we exceptionally set
(z2 − y)/(2z) = y when z = 0. Therefore, (X, Y, Z) are
1/p-statistically close to the uniform distribution of G3.

(X, Y ) = (gx, gy),

). Therefore, Z

= z + x, y

) = (gx

, gy

, Z

(cid:3)

(cid:3)

(cid:3)

(cid:2)

(cid:2)

(cid:2)

(cid:3)

(cid:3)

(cid:3)

Finally, we get:

AdvDIDH

G

(A) ≤ AdvDSDH

G

(B) + 1/p.

Hardness of DIDH Implies Hardness of CIDH. It is clear

587587

