Proofs of Proofs of Work with Sublinear

Complexity

Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka

National and Kapodistrian University of Athens⋆⋆

aggelos@di.uoa.gr,fnikolaoslabrou,katerinastou21g@yahoo.gr

Abstract. In the setting of blockchain based transaction ledgers we
study the problem of \simpli(cid:12)ed payment veri(cid:12)cation" (SPV) which
refers to the setting of a transaction veri(cid:12)er that wishes to examine
the last k blocks of the blockchain (e.g., for the purpose of veri(cid:12)cation
of a certain transaction) using as only advice the genesis block (or some
\checkpoint" block that is known to it).
The straightforward solution to this task requires the delivery of the
blockchain, the veri(cid:12)cation of the proof of work it contains, and subse-
quently the examination of the last k blocks. It follows that the com-
munication required to complete this task is linear in the length of the
chain.
At (cid:12)rst thought the above seems the best one can hope: a sublinear in
the length of the chain solution to the problem will be susceptible to an
attacker that, using precomputation, can fool the veri(cid:12)er.
Contrary to this intuition, we show that with a suitable modi(cid:12)cation to
the current Bitcoin blockchain protocol (that incurs a single hash ex-
pansion in each block and gives rise to the notion of an interconnected
blockchain) we can produce proofs of proof of work with sublinear com-
plexity in the length of the chain hence enabling SPV to be performed
much more eﬃciently.

1

Introduction

Bitcoin, introduced by Nakamoto [10], and other numerous decentralized cryp-
tocurrencies that were developed using the same codebase, have at their core
a blockchain-based ledger of transactions. In these systems the ledger is a dis-
tributed data structure where transactions are organized into blocks. The blocks
themselves form a hash chain so that each block is associated with a proof of
work puzzle [1,4,7,11] and it points to a single previous block. A valid blockchain
is rooted at a genesis block that is hard-coded into the client software that sup-
ports the distributed ledger.

The blockchain is maintained by a dynamically changing set of players that
are called miners. The main task of each miner is to solve a proof of work and
thus produce the next block. A transaction is validated when it is added to
the blockchain. The certainty placed upon a certain transaction is associated to

⋆⋆ This research was supported by ERC project CODAMODA, # 259152.

1

the depth that is found in the blockchain. The deeper a transaction is placed
in the blockchain the more certain it becomes that it will remain there. This
was originally argued in [10] in a simpli(cid:12)ed model where the honest players are
assumed to act in unison and the adversary follows a speci(cid:12)c strategy. Security
in the setting where the honest players are distributed and the adversary may
exploit this was subsequently formally considered and proven in [6]. In this latter
work two properties are introduced: common pre(cid:12)x and chain quality, and it is
shown that with overwhelming probability in a parameter k, honest players will
agree on the same pre(cid:12)x of the blockchain (after k blocks are pruned) and such
chain will contain a certain percentage of blocks produced by honest players.
These two properties were shown to imply that transactions in the ledger are
\persistent" and that the ledger itself has \liveness" i.e., it is impossible for the
adversary to sti(cid:13)e new transactions inde(cid:12)nitely.

In this work we study the problem of simpli(cid:12)ed payment veri(cid:12)cation or SPV.
Introduced in [10], this problem considers a veri(cid:12)er that wishes to examine the
ledger for a recent transaction. The veri(cid:12)er has as input a transaction identi(cid:12)er,
say tx as well as the genesis block.1 The veri(cid:12)er, with only this information,
wishes to verify with high probability that the transaction has been included
in the ledger and be sure that it will remain there with high probability. Based
on the results stated above it is simple to implement such SPV veri(cid:12)cation
as follows: the veri(cid:12)er will query the network and receive various blockchains
(possibly some generated by an adversary that wishes to fool him) containing
only the block headers for most blocks except the last k ones that are provided
with all transactions (such communications have been referred as \SPV proofs");
the veri(cid:12)er will verify the integrity of the received chains and will select the one
with the most proof of work. Finally, if the transaction with identi(cid:12)er tx is found
at a depth say k it will conclude that the transaction is valid (with a probability
of error as detailed by the persistence property of [6]). This SPV operation is
more eﬃcient than running a \full node" since not all transaction history needs
to be received and veri(cid:12)ed.

An important observation regarding the above solution is that it is seemingly
impossible to improve to below linear complexity in the length of the blockchain.
Indeed, if a veri(cid:12)er is only allowed sublinear complexity it will not be able to
verify that all the proofs of work in the received blockchains are valid. In this
way it will only be able to verify fragments of given blockchains at best and this
may open the door to potential attacks by an adversary that prepares ahead of
time suitable blockchain fragments that are unrelated to the genesis block but
are otherwise seemingly valid portions of the main blockchain.

Our Results. In this work, we present a method to construct proofs of proof of
work that have sublinear complexity in the blockchain length. These proofs are
capable of enabling \lite" SPV veri(cid:12)cation that is substantially more eﬃcient
compared to the full SPV veri(cid:12)cation described above. Our solution requires
a modi(cid:12)cation in the current Bitcoin codebase that incurs a small overhead
per each block that never exceeds a logarithmic function in the length of the

1 or a checkpoint block, if the veri(cid:12)er is in possession of such a block.

2

blockchain and can be compressed to a single hash value; this gives rise to a
special type of blockchain that we call an interconnected blockchain.
In our solution the lite veri(cid:12)er receives a pair (X ,(cid:25)), where X is a blockchain
fragment corresponding to the rightmost k blocks of the senders’ chain and (cid:25) is
a proof of the proof of work that the pruned chain (denoted by C⌈k) represents.
Constructing the proof (cid:25) is achieved via the following mechanism.

Recall that each block in a blockchain is associated with a proof of work which
corresponds to a suitably formed value w that satis(cid:12)es the inequality H(w) < T
where H is a hash function (e.g., SHA-256 in the case of Bitcoin) and T is a
target value which is determined via a target calculation function (this function
takes into account the rate of growth of the blockchain and re(cid:13)ects the size of
the set of miners that participate in the protocol).

Our new mechanism operates as follows: whenever a block with a lower than
usual hash is created we mark this in the next block as a continuation of a
\deeper" chain that we call the inner chain of depth i where i is the greatest
integer for which it holds H(w) < T =2i. Speci(cid:12)cally, each block carries a vector of
pointers (which can be thought of expanding the standard reverse pointing link
in a blockchain across multiple levels). In this way, in our modi(cid:12)ed blockchain, a

block will have a vector of pointers denoted as interlink = ⟨s0; : : : ; sl⟩ such that
s0 points to the genesis block and for i = 1; : : : ; l, si points to the previous block
with hash value smaller than T =2i. Note that l would be the largest integer for
which a hash in the blockchain is less than T =2l (and sl is a pointer to the most
recent such hash).
The construction of the proof (cid:25) is as follows: the sender will remove the k-
suﬃx from its local chain C and denote it as X . Then, in the remaining pre(cid:12)x
denoted as C⌈k, he will attempt to (cid:12)nd the deepest inner chain (cid:25) that is of length
at least m (the value m is a security parameter). The pair (X ; (cid:25)) will be the
proof and will be transmitted to the lite veri(cid:12)er. In the optimistic scenario where
the adversary does not actively interfere there is no further interaction between
the lite veri(cid:12)er and the prover. In the general case, the adversary may invest
hashing power in order to produce blocks with very low target, with the only
purpose to increase the communication complexity between a lite veri(cid:12)er and
a prover. In such case, the lite veri(cid:12)er engages in further interaction with the
provers in order to be fully convinced.

Finally, we present a formal treatment of security for lite SPV proofs. Our
argument is a simulation-based one. Security for a lite veri(cid:12)er is captured by the
following statement: for any adversary that produces an SPV proof directed to
a lite veri(cid:12)er there is an adversary producing an SPV proof directed to a regular
SPV veri(cid:12)er that produces the same outcome. We establish the above security
condition with overwhelming probability in m where m is a parameter of the
lite veri(cid:12)cation protocol.

In our construction the complexity of the lite veri(cid:12)er will be shown to be
O(m log n) in the optimistic case which can be improved in a straightforward
manner to be O(m log log n) where n is the blockchain length using Merkle trees.

3

Related Work. The (cid:12)rst suggestion we are aware of2 regarding the use of low
hash values that appear naturally in the blockchain as an indicator of total proof
of work was in a post in the Bitcoin forum [9]. A suggestion for a modi(cid:12)cation
of the Bitcoin protocol was made in this post to include in each block a single
\back-link" to the most recent block with a hash value less than half that of the
previous block. Potential bene(cid:12)ts of this modi(cid:12)cation were discussed including
the possibility of using such pointers in SPV proofs.

In a short article posted in the Bitcoin-development list [5] this idea was
taken further by suggesting to include a data structure containing various such
back-links to previous blocks. An exact form of the data structure was not de-
scribed and it was suggested that further research would be required to determine
the most suitable data structure. A number of use-cases were discussed includ-
ing the possibility of constructing compact SPV proofs as well as the design of
\symmetrical two-way pegging schemes" between Bitcoin and side-chains. This
latter concept, formulated in [2], enables the transfer of ledger assets from one
main chain (say Bitcoin) to pegged side-chains. It is argued that such side-chains
enable experimentation with new features in blockchain design and hence peg-
ging them to, say, the Bitcoin blockchain enables the (cid:13)uid transition of assets
to these alternative blockchains (that potentially oﬀer enhanced functionality or
robustness features that are diﬃcult to be assessed ahead of time). The pegging
operation itself requires the main blockchain to enable transactions that move
assets to special outputs that can only be \unlocked by an SPV proof of posses-
sion in the side-chain." This eﬀectively enables the transfer of assets from the
main chain to the side-chain as well as their return to the main chain in case
the owner of the assets wishes to do that. Building eﬃcient SPV proofs is an
important aspect of this mechanism and a suggestion along the lines of [5] is
presented in [2]. The possibility of exploiting the SPV proof mechanism by an
adversary is recognized and some countermeasures are brie(cid:13)y discussed however
without any formal analysis or the conclusion to an explicit data structure and
a proof construction algorithm.

Finally, we note that the Bitcoin modi(cid:12)cations related to SPV node veri(cid:12)ca-
tion do not aﬀect the operation of the full nodes of the blockchain protocol and
thus are of a diﬀerent nature to chain selection and reward mechanism modi(cid:12)-
cations such as those suggested in the GHOST rule for blockchain selection [12]
or the inclusive blockchain protocols of [8].

2 Preliminaries

We follow the same notation as the Bitcoin backbone protocol, [6]. Below we
introduce some basic notation and terminology.
− G(:); H(:) are cryptographic hash functions with output in f0; 1g(cid:20).

2 We thank the anonymous reviewers of the 3rd Workshop on Bitcoin and Blockchain

Research for providing pointers to the relevant forum posts.

4

− A block B has the following form: B = ⟨s; x; ctr⟩ where s 2 f0; 1g(cid:20); x 2

f0; 1g(cid:3)

; ctr 2 N.

− A round is the period during which all the parties in the network are able to
synchronize and obtain each other’s messages. The scheduling of messages
is controlled by the adversary. Furthermore, in each round, the adversary is
able to introduce arbitrary number of messages and deliver them selectively
to the parties.
− The rightmost block of the chain C is the head(C) and C⌈k is the chain
C without the rightmost k blocks. If we suppose that head(C)= ⟨s; x; ctr⟩
and the previous block is ⟨s
′
)); in
general every block has a reference to the previous block and thus all the
blocks form a chain.

− The block header can be de(cid:12)ned as ⟨ctr; G(s; x)⟩.
− A proof of work is (cid:12)nding a value ctr : 0 (cid:20) ctr < 232 so that H(ctr; G(s; x)) <

′⟩ then it holds s = H(ctr

; ctr

; x

′

′

′
; G(s

; x

′

T where T 2 f0; 1g(cid:20) is the target of the block.

− The value x is the information is stored in the a block. In the case of the
Bitcoin protocol this information is a sequence of transactions (organized in
the form of a Merkle tree).

Interconnected Blockchains

3
In order to produce a proof of proof of work, the prover with local chain C will
produce the pair (X ; (cid:25)) by setting the X to be the k-suﬃx of its local chain C
and computing the proof (cid:25). The proof (cid:25) constitutes a collection of blocks that
are part of chain C⌈k and are collected in a speci(cid:12)c way detailed below.
A proof (cid:25) is associated with an integer i 2 N which is the depth of the proof.
The blocks contained in the proof are determined by a special type of chain that
we will call innerchaini.

De(cid:12)nition 1. An innerchaini parameterized by an index i > 0 is a valid chain
derived from a chain C that has the feature that each block B = ⟨s; x; ctr⟩ satis(cid:12)es
H(ctr; G(s; x)) < T =2i.

In an innerchaini we observe that, intuitively, each block represents as much
proof of work as 2i blocks with target T of the parent chain C. As a result, if
the proof (cid:25) consists of m blocks, then the innerchaini represents proof of work
as much as m (cid:1) 2i blocks of target T .
In our system, in order to produce the proof, provers should extract innerchaini
for some i > 0 from C⌈k. This means that for every i 2 N all blocks with hash
value smaller than T =2i should form a chain. This leads to the notion of an
interconnected blockchain.

Every block with hash value smaller than T =2i needs a pointer to the pre-
vious block with hash value smaller than T =2i. This does not exist in regular
blockchains of Bitcoin, so a suitable modi(cid:12)cation with a sequence of pointers in
each block in C is needed. The addition of this data structure inside each block,

5

Fig. 1. A graphical depiction of an interconnected blockchain of 11 blocks that contains
an inner chain of depth 1 (comprised of blocks (1; 4; 7; 9)) and an inner chain of depth
2 (comprised of blocks (1; 7). The value of the interlink vector for each block is also
shown.

that we will call interlink[] will give rise to an \interconnected blockchain." A
graphical description of an interconnected chain is shown in (cid:12)gure 1.

The interlink data structure which should be included in each block B is
dynamic and we formally de(cid:12)ne it below. Note that a block will be de(cid:12)ned as
B = ⟨s; x; ctr; interlink⟩ and the blockheader as ⟨ctr; G(s; x; interlink)⟩.

De(cid:12)nition 2. interlink is a vector, which is included in each block B and for
which it holds that, for all i > 0, interlink[i] is the hash of the previous block of
B in chain C with hash value smaller than T =2i. interlink[0] is the hash of the
genesis block.

Note that the length of the vector depends on the type of blocks that exist in
′
=
′⟩ is the previous block; then interlink is equal to interlink
′

chain C. Suppose that B = ⟨s; x; ctr; interlink⟩ is the head of the chain and B
⟨s
′
after being updated with the algorithm we describe next.

; interlink

; ctr

; x

′

′

3.1 Description of the interlink-Update Algorithm

The purpose of this algorithm is to determine the operation that is needed in
order to properly form an interconnected chain. When mining a new block, we
must determine the appropriate set of pointers that will be used. Given the hash
of the previous block denoted by s, the algorithm performs the following.

− Finds max i, so that s = H(ctr
′
− Extends the size of interlink

′
equals sizeof (interlink
′

′

− Assign H(ctr

′
; G(s

; x

′
; interlink

′

; x

′
′
; G(s
by adding i (cid:0) i
′
′
; interlink

) (only if i

< i).

′

)) = s to interlink[1]; : : : ; interlink[i].

)) < T =2i.

elements where the value i

′

6

Algorithm 1: interlink -Update

= ⟨s
′
Input : B
Output: interlink

′

′

; x

; ctr

′

′⟩
; interlink

1 dynamic data structure interlink;
2 int entry; i = 0;
′
3 interlink = interlink
′

;

′

′

′

4 while (H(ctr

; G(s

; x

; interlink

)) <

5

6

7

entry = i;
i = i + 1;

T
2i ) do ; // finds vector’s max length

8 if entry = 0 then
9

10 else
11

return interlink;
for (i = 1; i (cid:20) entry; i + +) do
if i > sizeof (interlink) then

sizeof (interlink)+ = 1;

12

13

14

15

interlink[i] = H(ctr

return interlink;

′

′
; G(s

′

; interlink

′

));

; x

4 Proving Proof of Work with Sublinear Complexity

4.1 Description of the Prover
When a prover with a local chain C receives a request from a lite veri(cid:12)er that
asks for the rightmost k blocks, then it constructs a proof (cid:25) of the proof of work
in C⌈k using the algorithm ConstructProof.

This algorithm’s input is C⌈k(cid:0)1 and its output is innerchaini = (cid:25), where i
is the max i so that there are at least m (security parameter) blocks with hash
value smaller than T =2i in C⌈k. The algorithm ConstructProof (which we will
describe below) calls the next algorithm, which is ConstructInChain.

This algorithm uses a hash table, which is a data structure that stores
(key,value) pairs. In our case, the hash table stores blocks with their hash values.
The algorithm ConstructInChain has as input a chain C and an i. Its output
is a chain with all the blocks with hash value smaller than T =2i in C⌈1.

4.2 Description of the Lite Veri(cid:12)er

We consider the case when a lite veri(cid:12)er has received (XA; (cid:25)A) and (XB; (cid:25)B) from
provers A; B respectively that supposedly hold chains CA and CB. Its purpose is

to (cid:12)nd which proof represents the chain with the most proof of work.

− Without loss of generality, let (cid:25)A = innerchain(cid:22), so its blocks have hash
= T =2(cid:22) and (cid:25)B = innerchaini+(cid:22), so its blocks have

′

value smaller than T
hash value smaller than T =2i+(cid:22) = T

′

=2i with i (cid:21) 0.

7

Algorithm 2: ConstructInChain
Input : C,i
Output: InnerChain[ ]
1 data structure hashtable;
2 int x; y = 0;
3 int j = C:length;
4 int inner=0;
5 block B ;
6 B = C[j];
7 x = B:interlink[i] ;
8 y = B:interlink[i];
9 initialize hashtable((cid:1)) with all pairs (s; B) from C;
10 while (x!= 0) do
11

x = B:interlink[i];
if x!= 0 then

B = hashtable(x);
inner = inner + 1;

12

13

14

19

20

21

22

15 int c = inner;
16 chain InnerChain[c] ;
17 while (y!= 0) do
18

y = B:interlink[i];
if y!= 0 then

B = hashtable(y);
InnerChain[c] = B;
c = c (cid:0) 1;

// as it is defined above

// B:interlink is interlink in block B

// data structure which stores blocks

23 return InnerChain;

Firstly the lite veri(cid:12)er examines whether the length of (cid:25)A and (cid:25)B is more than
m without the genesis and whether the length of the suﬃxes is k respectively. If
a proof does not satisfy the above properties, it is rejected.

Next, the lite veri(cid:12)er examines whether there is a common block x in XA and
XB, because in this case the lite veri(cid:12)er can (cid:12)nd which chain represents more
proof of work easily. Speci(cid:12)cally this means that there is a fork between CA and
CB in the last k blocks. So the lite veri(cid:12)er chooses the suﬃx that represents the

most proof of work (more blocks after x since we assume the same T ).

If there is no common block in the suﬃxes then the lite veri(cid:12)er will exe-
cute the algorithm MaxChain[(cid:25)A; (cid:25)B] which will decide which proof represents
the chain with the most proof of work. This algorithm may require additional
interaction with A; B and operates as follows.

MaxChain uses two sub-procedures called RemoveCPhigh and RemoveCPlow.
The RemoveCPlow algorithm with input ((cid:25)A; (cid:25)B) just prunes the common blocks,
′
sets (cid:25)
B to be the proofs without these common blocks and sets b to be the
most recent common block in (cid:25)A; (cid:25)B.

′
A; (cid:25)

8

Algorithm 3: ConstructProof
Input : C⌈k(cid:0)1
Output: P roof [ ]

1 int size = C⌈k(cid:0)1:length;
2 int maxtarget = 0;
3 chain P roof [ ];
4 while (C[size]:interlink[maxtarget + 1] != 0) do

5

maxtarget = maxtarget + 1 ;

6 int i = maxtarget;
7 if maxtarget > 0 then
8

P roof [ ] = ConstructInChain [C⌈k(cid:0)1; i];
while (P roof:length < m ^i > 0) do

if (i > 0) then

i = i (cid:0) 1;
P roof [ ] = ConstructInChain [C⌈k(cid:0)1; i];
return genesis∥P roof ;
return C⌈k(cid:0)1;

else

9

10

11

12

13

14

15

16 return C⌈k(cid:0)1;

The RemoveCPhigh on input ((cid:25)A; (cid:25)B) will actively query B for the chain with
blocks with hash value smaller than T =2(cid:22) that is omitted in (cid:25)B. Formally, it will
′
B are the proofs without the common pre(cid:12)x and
return ((cid:25)
b is the most recent common block with hash value smaller than T =2(cid:22) in CA and
CB. In more detail, it operates as follows:

′
B; b), where (cid:25)

′
A; (cid:25)

′
A; (cid:25)

between (cid:25)B[i
not returned by B.

′ (cid:0) j].

− We suppose that the proofs are stored in two arrays respectively. The al-
′
gorithm looks for block (cid:25)B[1] in (cid:25)A and it continues until it (cid:12)nds a (cid:25)B[i
]
′ (cid:0) 1] is included in (cid:25)A, there is a j, so that
that it is not in (cid:25)A. As (cid:25)B[i
(cid:25)A[j]= (cid:25)B[i

− It asks B for an array V with blocks with hash value smaller than T =2(cid:22)
]. RemoveCPhigh will fail in case the array V is

′ (cid:0) 1].
′ (cid:0) 1] and (cid:25)B[i
′
′ (cid:21) j + 1 so that (cid:25)A[j

′

− It (cid:12)nds min j
− (cid:25)B′ is (cid:25)B without the (cid:12)rst i

] diﬀers from V [j

′ (cid:0) 1 blocks and (cid:25)A′ is (cid:25)A without the (cid:12)rst j

′ (cid:0) 1

blocks.

− b = (cid:25)A[j
− Return (b; (cid:25)

′ (cid:0) 1] .
′
A; (cid:25)

′
B).

Next we describe the algorithm MaxChain. Given diverging (cid:25)A; (cid:25)B, the algo-
rithm will select the proof with the most proof of work as long as the diverging
suﬃx is long enough (as determined by a parameter m). In case the algorithm
cannot make a decision it will recurse, requesting proofs with lower depths from

9

A; B as needed, until it reaches level 0 where a decision will be made indepen-
dently of the parameter m. During these recursion steps if one of the communi-
cating nodes, A; B, fails to support its proof (by providing the extra blocks that
the lite node requests) the MaxChain algorithm will conclude that the opposing
chain is the correct one (or it will inevitably fail in case no node is responding
to its requests). In more detail the algorithm operates as follows:

− Firstly, the algorithm calls RemoveCPlow to obtain the pruned suﬃxes (this
does not require interaction). Then, it checks whether i > 0. In this case,
B:pow (cid:21)
′
the proofs have diﬀerent depths and the algorithm checks whether (cid:25)
B:length (cid:21) m. If these two conditions hold, the
′
′
(cid:25)
A:pow and simultaneously (cid:25)
lite veri(cid:12)er will choose (cid:25)B. Otherwise the algorithm uses RemoveCPhigh in
order to discover the common pre(cid:12)x from the proofs (cid:25)A; (cid:25)B (this will require
interacting with B).

− Secondly the algorithm checks which of the proofs represents the most proof
of work. The proof with the most proof of work is returned if it has length
′
at least m for (cid:25)
A. Note that in this case a decision is made
whose security hinges on the parameter m.

′
B and 2im for (cid:25)

− If the proof with the most proof of work is not long enough the algorithm
asks B or both A; B for a proof with a lower depth of the part of the chain
(C⌈k
A or C⌈k
B ) without the common pre(cid:12)x and continues recursively. We use
RequestB[b; y] to denote a request from B for a proof with hash value smaller
than T =2y of the chain C⌈k
B that is rooted at block b. Similarly, RequestA[b; y]
functions in the same way for player A.3

Eventually, the algorithm will either obtain diverging suﬃxes that are long
enough or will reach the depth 0 (where the actual target T is used) where
a decision will be made based solely on the amount of proof of work. This will
determine the winning proof and the lite veri(cid:12)er may proceed to execute another
comparison or conclude the process.

5 Eﬃciency Analysis

In this section we present the eﬃciency analysis of the proof system: (cid:12)rst we
discuss space complexity, i.e., the expansion that is required in the local storage
of the full nodes due to the data structure of the interconnected blockchain.
Then, we analyze the communication that is required to send the proof and the
veri(cid:12)cation complexity of the lite veri(cid:12)er.

5.1 Space Complexity

We (cid:12)rst show a suitable upper bound on the vector interlink that is the only
addition in each block of the interconnected blockchain.

3 We note that there is no provision for authenticated channels in the Bitcoin setting;
hence when we refer to a request for information from a certain player this is not
performed in an authenticated fashion.

10

Algorithm 4: MaxChain

Input : (cid:25)A; (cid:25)B chains consisted of blocks with hash value smaller than

T =2(cid:22); T =2i+(cid:22) resp., s.t. i (cid:21) 0, or fail

Output: M ax[ ]

1 chain M ax[ ],P roofA[ ], P roofB[ ];
2 block b;
3 if either of (cid:25)A; (cid:25)B equals fail then
4
5 else
6

return the other one ;

′
A; (cid:25)

(b; (cid:25)
if (i > 0) then

′
B) = RemoveCPlow[(cid:25)A; (cid:25)B];
B:pow (cid:21) (cid:25)
′
return (cid:25)B

A:pow) ^((cid:25)
′

if (((cid:25)

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

B:length (cid:21) m)) then
′

else

response:= RemoveCPhigh[(cid:25)A; (cid:25)B];
if response = fail then

return (cid:25)A

else

parse response as (b; (cid:25)

′
A; (cid:25)

′
B);

B:pow (cid:21) (cid:25)
′

′
A:pow) then

if ((cid:25)

if (((cid:25)

B:length (cid:21) m) _ (i + (cid:22) = 0)) then
′
return (cid:25)B

else

if (i > 0) then

else

P roofB = RequestB[b; (cid:22)];
P roofA = b∥(cid:25)
′
A;
P roofA = RequestA[b; (cid:22) (cid:0) 1];
P roofB = RequestB[b; (cid:22) (cid:0) 1];

else

if (((cid:25)

A:length (cid:21) 2i (cid:1) m) _ (i + (cid:22) = 0)) then
′

return (cid:25)

′
A

else

if (i > 0) then

else

P roofB = RequestB[b; (cid:22)];
P roofA = b∥(cid:25)
′
A;
P roofA = RequestA[b; (cid:22) (cid:0) 1];
P roofB = RequestB[b; (cid:22) (cid:0) 1];

return MaxChain[P roofA; P roofB];

11

Theorem 1. Let n be the length of a chain C that is consisted of blocks with
hash value smaller than T = 2f . Then the expected size of the dynamic vector

interlink, is f (cid:0)∑

Proof. We de(cid:12)ne a discrete random variable Xj 2 f0; :::; fg associated with each
block C[j] so that

f

i=1(1 (cid:0) 1

2i )n.

Xj = i () T
2i+1

(cid:20) HB <

T

2i ; i 2 f0; :::; f (cid:0) 1g

Xj = f () 0 (cid:20) HB <

T
2f

The hash value of each chain’s block HB follows the uniform discrete distri-

(HB is the hash value of C[j]).
bution on f0; :::; T (cid:0) 1g. So

Pr(Xj = i) = Pr(

It holds:

T

T
2i ) =
Pr(Xj = f ) = Pr(0 (cid:20) HB <

2i+1

(cid:20) HB <
f∑

Pr(Xj = i) = 1

1

2i+1 ; i 2 f0; :::; f (cid:0) 1g
T
2f ) =

1
2f

y∑

Then the size of the interlink follows Y = maxfX1; :::; Xng distribution.

i=0

If 0 (cid:20) y < f then:

Pr(Y (cid:20) y) =(Pr(Xj (cid:20) y))n = (
2i+1 )n = (1 (cid:0) 1
Pr(Y = y) =Pr(Y (cid:20) y) (cid:0) Pr(Y (cid:20) y (cid:0) 1) = (1 (cid:0) 1
It also holds: Pr(Y (cid:20) f ) = 1 and Pr(Y = f ) = 1 (cid:0) (1 (cid:0) 1

i=0

1

2y+1 )n
2y+1 )n (cid:0) (1 (cid:0) 1
2y )n
2f )n

In Figure 2 we demonstrate a graph that shows that the size of interlink is
logarithmic in n when n ranges in the current Bitcoin blockchain length and the
target is kept stable at 2200.

12

⊓⊔

We have:

f(cid:0)1∑

y (cid:1) [(1 (cid:0) 1

E(Y ) =

y=0

=(f (cid:0) 1) (cid:1) (1 (cid:0) 1

=f (cid:0) f∑

i=1

(1 (cid:0) 1

2i )n

2y+1 )n (cid:0) (1 (cid:0) 1
2y )n] + f (cid:1) [1 (cid:0) (1 (cid:0) 1
2f )n]
2i )n + f (cid:1) [1 (cid:0) (1 (cid:0) 1
(1 (cid:0) 1

2f )n (cid:0) f(cid:0)1∑

2f )n]

i=1

Fig. 2. Size of interlink as a function of blockchain length when target is T = 2200.

Compressing the interlink vector using Merkle trees. To reduce the
storage per block it is possible to compress the interlink vector using a Merkle
tree. In more detail, instead of storing the whole interlink in each block we
can organize the vector in a Merkle tree and store only the root hash in each
blockheader. This demands the addition of only a hash value in each block
instead of the sequence of hash values in interlink. The modi(cid:12)cations needed in
the ConstructProof algorithm are straightforward and we omit them.

5.2 Communication and Time Complexity

We will analyze now the size of the proof (cid:25). We will focus in the optimistic
scenario, where the adversary does not create deep forks that cut into the proofs
of the honest parties, i.e., when the k-suﬃx that the adversary sends has a
common block with the suﬃx of the proofs sent by the honest provers. Note that
the honest parties will not fork in the part of the chain before the k-suﬃx with
overwhelming probability in k [6]. In such case the lite veri(cid:12)er chooses the chain
with the most proof of work without having to perform any extra interaction with
the provers (performing the Request steps in the MaxChain algorithm). Therefore
the size of the proof will be the output of the ConstructProof algorithm.
Let C⌈k be the pruned local chain without the k-suﬃx of a prover that a
lite veri(cid:12)er has asked, n the length of the chain and m the security parameter.
Firstly we will prove that the probability with which a block of C⌈k has hash
value smaller than

If HB is the hash value of a block B and j 2 N, j < T then Pr(HB = j j

T
2i is

1
2i .

HB < T ) = 1=T . It follows,

Pr(HB < T =2i j HB < T ) =

T =2i(cid:0)1∑

Pr(HB = j j HB < T ) =

T =2i

T

=

1
2i

j=0

13

100000200000300000400000141516171819200-∑j=12001-2-jxlog1.95(x)The number of blocks in C⌈k with hash value smaller than T =2i is a discrete
random variable Di that follows the Binomial distribution with parameters (n,
pi = 1=2i) and its expected value is E(Di) = n (cid:1) pi.

Recall that the ConstructProof algorithm has output the innerchaini0 = (cid:25),
where i0 is the maximum i so that there are at least m blocks with hash value
smaller than T =2i in C⌈k. As a result we must examine what is the depth i0 of
the proof that the algorithm returns and how many blocks (denoted by Di0) the
proof (cid:25) will contain.

In the next lemma we establish that the depth of the inner chain that the
ConstructProof algorithm returns is quite close to the optimal value (which is
roughly log(n=m)).
Lemma 1. Let n be the size of the local pruned chain C⌈k of the prover. Assume
that n < T m and de(cid:12)ne i so that 2im (cid:20) n < 2i+1m. Then it holds Pr(Di(cid:0)1 (cid:20)
m (cid:0) 1) (cid:20) exp((cid:0)Ω(m)).
Proof. Observe that n (cid:1) pi(cid:0)1 = n=2i(cid:0)1 (cid:21) 2im=2i(cid:0)1 = 2m > m (cid:0) 1. So according
to the Chernoﬀ bound4 for the Binomial distribution it holds that:

Pr(Di(cid:0)1 (cid:20) m (cid:0) 1) (cid:20) exp((cid:0)(npi(cid:0)1 (cid:0) (m (cid:0) 1))2=2npi(cid:0)1)

(cid:20) exp((cid:0)1=(2=(2i(cid:0)1)) (cid:1) (n(1=(2i(cid:0)1)) (cid:0) (m (cid:0) 1))2=n))
(cid:20) exp((cid:0)(2m (cid:0) m + 1)2=23m) (cid:20) exp((cid:0)Ω(m))

This completes the proof.

⊓⊔

Armed with this lemma we next observe that the length of the inner chain

for the suitable index is not going to be substantially larger than m.
Lemma 2. Let n < T m and de(cid:12)ne i so that 2im (cid:20) n < 2i+1m. It holds that
Pr(Di(cid:0)1 (cid:21) 5m) (cid:20) exp((cid:0)Ω(m)).
Proof. Observe (cid:12)rst that 2m=n (cid:20) pi(cid:0)1 = 1=2i(cid:0)1 < 4m=n. Consider the Chernoﬀ
bound on the upper tail that states Pr[X (cid:21) (1 + (cid:14))(cid:22)] (cid:20) exp((cid:0)(cid:14)2(cid:22)=3) when X
is a Binomial distribution with mean (cid:22) and (cid:14) 2 (0; 1]. It follows that Pr[Di(cid:0)1 (cid:21)
5m] (cid:20) Pr[Di(cid:0)1 (cid:21) (1 + 1=4)pi(cid:0)1n] (cid:20) exp((cid:0)pi(cid:0)1n=48) (cid:20) exp((cid:0)m=24).
⊓⊔

We are now ready to state the theorem that establishes the eﬃciency of the

proof that is constructed and communicated to the lite veri(cid:12)er.

Theorem 2. The size of the proof (cid:25) that the prover sends in response to a lite
veri(cid:12)er in the optimistic case is O(m) with overwhelming probability in m.

Proof. In the optimistic case the proof (cid:25) that the prover sends to the lite veri(cid:12)er
is the output of the ConstructProof algorithm. If n is the length of the local
chain from which the prover constructs the proof and we have 2im (cid:20) n <
2i+1m for an i (cid:21) 1 then it holds that: The ConstructProof algorithm will return
4 Here we use the following variant: Pr(X (cid:20) k) (cid:20) exp((cid:0)(np(cid:0)k)2=2np), where k (cid:20) np.

14

a proof of depth i (cid:0) 1 with overwhelming probability in m, as we proved in
lemma 1. Furthermore, the size Di(cid:0)1 of the proof (cid:25) will be bounded by 5m with
overwhelming probability in m, as we proved in lemma 2. This completes the
⊓⊔
proof.

The above completes the argument for the optimistic case, where the adver-
sary does not explicitly interfere and attempts to increase the complexity of the
lite veri(cid:12)er. We note that in the case that the adversary interferes and makes the
lite node to engage in extra communication by issuing the Request commands, he
can only succeed in this with signi(cid:12)cant eﬀort (by mining very low target blocks)
and with bounded, albeit non-negligible, probability. It seems unlikely that an
adversary will engage in this eﬀort for the sole purpose of delaying a lite veri-
(cid:12)er and for this reason, we consider the optimistic eﬃciency analysis performed
above to be quite indicative of the actual performance of the protocol.

Finally with respect to time complexity observe that in the optimistic case,
the veri(cid:12)er will have to perform a number of veri(cid:12)cation steps that are propor-
tional to the size of the proof that is received. It follows that the complexity of
the veri(cid:12)er is also O(m log n).

Complexity when using a compressed interlink vector. The communica-
tion and time complexity in this case can be improved since in each block from
the interlink vector committed in the Merkle root hash only a path in the tree
needs to be transmitted. It follows easily that the complexity of the lite veri(cid:12)er
in the optimistic case will be O(m log log n).

6 Security Analysis

A successful attack against our lite veri(cid:12)cation mechanism suggests that a lite
veri(cid:12)er reaches a diﬀerent conclusion about a certain transaction compared to a
full veri(cid:12)er. The proof argument for security is as follows: given an adversary A
that responds to a lite veri(cid:12)er we construct an adversary A(cid:3)
that responds to a
full veri(cid:12)er. We will argue that with high probability the full veri(cid:12)er operating
with A(cid:3)

reaches the same conclusion as the lite veri(cid:12)er operating with A.

Intuitively the above means that for any proof that a lite veri(cid:12)er accepts and
processes there exists a full chain that can be recovered and produces the same
output behavior for a regular SPV veri(cid:12)er.

The description of A(cid:3)

is as follows:

1. A(cid:3)

simulates the operation of A while additionally in each round acts as a
full veri(cid:12)er and requests the chains from all the honest nodes denoted by
C1; : : : ;Ce for some integer e. It maintains a \block tree" BT containing all
blockchains and adds there any blocks that are produced by the adversary.
Note that it is possible to A(cid:3)
to perform this since in the random oracle
model (that we adopt from [6]) it is possible for A(cid:3)
to monitor all queries of
A to the hash function H((cid:1)). Any queries made by A that do not correspond
to valid blocks are ignored.

15

2. When A responds to a lite veri(cid:12)er with a pair (X ; (cid:25)), A(cid:3)

searches in BT for
a chain C that is consistent with (X ; (cid:25)), i.e., X is the suﬃx of C and (cid:25) is a
sub-chain of C. If such a chain is found, then A(cid:3)
response to a full veri(cid:12)er
with C. If no chain is found then A(cid:3)
returns no response to the full veri(cid:12)er.

We perform our analysis in the model of [6]. Recall that in their model,
there are n parties maintaining the blockchain, each allowed q queries to the
hash function (thought of as a random oracle) and t of the parties are controlled
by the adversary. The probability of (cid:12)nding a proof of work with a single hash
query is T =2(cid:20) (recall that the target is T and is stable). We use the same notation
as [6] and we denote (cid:11) = (n (cid:0) t)pq, (cid:12) = pqt and (cid:13) = (cid:11) (cid:0) (cid:11)2. Intuitively, the
parameter (cid:11) represents the hashing power of the honest parties; it is also an
upper bound on the expected number of solutions that the honest parties will
obtain in one round; on the other hand (cid:12) is the expected number of solutions
that the adversary may produce in one round. Finally, (cid:13) is a lower bound on the
expectation of a uniquely successful round, i.e., a round where a single honest
party (cid:12)nds a proof of work solution.

We are now ready to formulate the theorem that establishes the security of
lite veri(cid:12)cation. The theorem is conditioned on (cid:13) > (1 + (cid:14))(cid:12) which roughly5
corresponds to the setting where the honest parties command the majority of
the hashing power.

Theorem 3. (Security of lite veri(cid:12)cation) Let (cid:13) > (1 + (cid:14))(cid:12) for some (cid:14) > 0. A
full veri(cid:12)er interacting with A(cid:3)
reaches the same conclusion as the lite veri(cid:12)er
operating with A with probability 1 (cid:0) exp((cid:0)Ω((cid:14)2m)).
Proof. (Sketch). We compare any execution with A where a lite veri(cid:12)er requests
a proof to an execution where a full veri(cid:12)er requests a proof from A(cid:3)
. We de(cid:12)ne
an event BAD to be the event that the two veri(cid:12)ers report a diﬀerent conclusion.
An event BAD would necessarily correspond to the case 2 above in the de(cid:12)nition
of A(cid:3)
when the latter fails to reconstruct a chain C from BT that corresponds
to the proof (X ; (cid:25)) that the adversary A produces. Let NOWIT be this latter
event and observe BAD (cid:18) NOWIT. We will argue that whenever NOWIT happens
then with overwhelming probability in m it holds that a proof originating from
an honest party will win the comparison performed by the MaxChain. Let this
event be HWIN. In more detail we will prove that Pr(:HWIN ^ NOWIT) drops
exponentially in m. Observe that this is suﬃcient since BAD (cid:18) :HWIN and
hence it will follow that Pr(BAD) drops exponentially in m.
The event :HWIN suggests that the adversary A has managed to produce a
proof for which no honest party could outperform in the view of the MaxChain
procedure. Furthermore, if NOWIT happens also, it follows that it is impossi-
ble for A(cid:3)
to reconstruct a chain that corresponds to the proof that wins the
MaxChain algorithm. This suggests that the winning proof (X ; (cid:25)) contains blocks
that were impossible to attach to the blockchain tree BT by A(cid:3)
, due to the fact
5 Roughly because (cid:13) = (cid:11) (cid:0) (cid:11)2 and thus this condition approximates the \honest
majority" condition only if (cid:11)2 is close to 0. See [6] for more details.

16

of not being valid extensions of a (level-0) chain. It follows that in the response
(X ; (cid:25)), the proof (cid:25) should diverge from all chains that belong to an honest party
(otherwise all the blocks in X would have been attached to BT and a witness
for (X ; (cid:25)) would be reconstructed by A(cid:3)
). Let b be the most recent common
honestly generated block of (cid:25) with the longest chain C from BT that belongs to
an honest party. Given that MaxChain elected (X ; (cid:25)) over the proof provided by
the owner of C it holds that (cid:25) contains a sequence of at least m blocks starting
from b (or later) that are of target T =2i where i > 0 is the depth of (cid:25). Let r be
the round that block b was created. We will next show that the probability that
A obtains m blocks with hashes less than T =2i faster than the honest parties’
chains advance by 2im blocks is negligible in m. It follows that it will be with
negligible in m probability that A can produce a proof that will be selected by
MaxChain.
∑

Let Xr be the random variable that is equal to 1 if r is a successul round
(following the terminology of [6]). In [6] it is shown that in any s rounds following
round r it holds that the length of the honest parties’ chains will be at least
ℓ +

s
l=r Xl where ℓ is the length of an honest parties’ chain at round r.

The number of rounds that will be required for the adversary to compute m
blocks with hash less than T =2i follows a negative binomial distribution. The
(cid:0)1m where p = T =2(cid:20) and (cid:12) = pqt. By
expectation for the number of rounds is 2i(cid:12)
applying a tail bound for the negative binomial distribution we obtain that the
(cid:0)1m is exp((cid:0)Ω((cid:14)2m)).
probability the number of rounds is less than (1(cid:0)(cid:14)=4)2i(cid:12)
On the other hand, in (1(cid:0)(cid:14)=4)2i(cid:12)
(cid:0)1m rounds, by applying a Chernoﬀ bound,
the probability that the honest parties will produce less than (1(cid:0) (cid:14)=4)2(cid:13)2i(cid:12)
(cid:0)1m
blocks is bounded by exp((cid:0)Ω((cid:14)2m)).
(cid:0)1 > 1 and thus the
probability that the proof of work of the chains owned by the honest parties will
⊓⊔
exceed that of the adversary is 1 (cid:0) exp((cid:0)Ω((cid:14)2m)).

Observe now that (cid:13) > (1 + (cid:14))(cid:12) implies (cid:13)(1 (cid:0) (cid:14)=4)2(cid:12)

On the feasibility and infeasibility of non-interactive and/or constant
size proofs. Observe that our security parameter for the proof is m and the size
of the proof in the optimistic case is O(m). In our construction, the lite veri(cid:12)er
may require further interaction with the provers if it discovers forks in the inner
chains that it receives. This leaves open the question whether shorter proofs
can be achieved (e.g., constant size) or whether it is possible to obtain non-
interactive proofs, i.e., proofs that require always a single message from the full
nodes to the lite veri(cid:12)er. With respect to constant size proofs it is unlikely that
the techniques like the ones we consider here would provide such an improvement:
for instance, if a single block of exceptionally low hash value is transmitted as a
proof of many proofs of work of proportional length, concentration bounds will
not be able to provide a suﬃciently low probability of attack. In other words,
such short proofs might be exploitable by an attacker in very much the same
way that the diﬃculty raising attack of [3] operates and hence they will not
be secure. Similarly, given any non-interactive proof that goes arbitrarily low
in terms of the inner chain it selects, one can always imagine an attacker that

17

attempts to fork in the very last block of the inner chain and thus gain an unfair
advantage compared to the honest parties even in the honest majority setting.
However this may be countered by requiring suﬃcient number of blocks following
such low hash blocks; we leave for future work the feasibility of investigatng the
design of short and secure non-interactive SPV proofs.

The dynamic setting. To account for a dynamically changing population of
miners, in Bitcoin and related blockchain protocols, the target is recalculated
at regular intervals. It is possible to build our interconnected blockchains in the
dynamic setting as well; some care needs to be applied during veri(cid:12)cation of
proofs however since target recalculation will need to be performed over the
inner chains. We leave the analysis in the dynamic setting for future work.

Acknowledgement. The authors wish to thank Giorgos Panagiotakos for help-
ful discussions as well as the anonymous referees of the 3rd Workshop on Bitcoin
and Blockchain Research for their valuable comments.

References

1. A. Back. Hashcash. http://www.cypherspace.org/hashcash, 1997.
2. A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra,
J. Timn, and P. Wuille. Enabling Blockchain Innovations with Pegged Sidechains,
https://blockstream.com/sidechains.pdf, 2014.

3. L. Bahack. Theoretical Bitcoin Attacks with less than Half of the Computational

Power, 2013.

4. C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In
E.F.Brickell, editor, CRYPTO, volume 740 of Lecture Notes in ComputerScience,
pages 139147. Springer, 1992.

5. M. Friedenbach, Compact SPV proofs via block header commitments, 2014,
Bitcoin-development mailing list post, https://lists.linuxfoundation.org/
pipermail/bitcoin-dev/2014-March/004727.html

6. J. A. Garay, A. Kiayias, and N. Leonardos. The Bitcoin Backbone Protocol: Anal-
ysis and Applications. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015,
Part II, LNCS 9057, pp. 281-310, 2015.

7. A. Juels and J.G. Brainard. Client puzzles: A cryptographic countermeasure

against connection depletion attacks. In NDSS. The Internet Society, 1999.

8. Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive Block Chain Protocols. In
R.B(cid:127)ohme and T. Okamoto, editors, International Financial Cryptography Associ-
ation 2015, LNCS 8975, pp. 528-547, 2015.

9. A. Miller, The high-value-hash highway, Bitcoin forum post, 2012, https://

bitcointalk.org/index.php?topic=98986.0

10. S. Nakamoto. Bitcoin: A peer to peer electronic cash system, http://bitcoin.

org/bitcoin.pdf, 2008.

11. R.L. Rivest, A. Shamir, and D.A. Wagner. Time-lock puzzles and timed-release

crypto. Technical report, Cambridge, MA, USA, 1996.

12. Y. Sompolinsky and A. Zohar, Secure High-Rate Transaction Processing in Bit-
coin, In R.B(cid:127)ohme and T. Okamoto, editors, International Financial Cryptography
Association 2015, LNCS 8975, pp. 507-527, 2015.

18

