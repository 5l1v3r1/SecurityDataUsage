Privacy Enhanced Access Control for

Outsourced Data Sharing

Mariana Raykova, Hang Zhao, and Steven M. Bellovin

Columbia University, Department of Computer Science,

New York, NY 10027-7003, USA,

{mariana,zhao,smb}@cs.columbia.edu

Abstract. Traditional access control models often assume that the en-
tity enforcing access control policies is also the owner of data and re-
sources. This assumption no longer holds when data is outsourced to a
third-party storage provider, such as the cloud. Existing access control
solutions mainly focus on preserving conﬁdentiality of stored data from
unauthorized access and the storage provider. However, in this setting,
access control policies as well as users’ access patterns also become pri-
vacy sensitive information that should be protected from the cloud. We
propose a two-level access control scheme that combines coarse-grained
access control enforced at the cloud, which provides acceptable com-
munication overhead and at the same time limits the information that
the cloud learns from his partial view of the access rules and the ac-
cess patterns, and ﬁne-grained cryptographic access control enforced at
the user’s side, which provides the desired expressiveness of the access
control policies. Our solution handles both read and write access control.

Introduction

1
The emerging trend of outsourcing of data storage at third parties – “cloud stor-
age” – has recently attracted tremendous amount of attention from both research
and industry communities. Outsourced storage makes shared data and resources
much more accessible as users can retrieve them anywhere from personal com-
puters to smart phones. This alleviates data owner from the burden of data
management and leaves this task to service providers with dedicated resources
and more advanced techniques. By adopting the cloud computing solution, gov-
ernment agencies will drastically save budget and increase productivity by utiliz-
ing low-cost and maintenance-free services available on the Internet rather than
purchasing, designing and installing new IT infrastructure themselves. Similar
beneﬁts could be realized in ﬁnancial services, health care, education, etc [10].
Security remains the critical issue that concerns potential clients, especially
for the banks and government sectors. A major challenge for any comprehensive
access control solution for outsourced data is the ability to handle requests for re-
sources according to the speciﬁed security policies to achieve conﬁdentiality, and
at the same time protect the users’ privacy. Several solutions have been proposed
in the past [6, 8, 12, 13, 15], but none of them considers protecting privacy of the
policies and users’ access patterns as an essential goal. In this paper we address

2

these privacy requirements and propose a mechanism to achieve a ﬂexible level
of privacy guarantee for the client. We introduce a two-level access control model
that combines ﬁne-grained access control, which supports the precise granular-
ity for access rules, and coarse-grained access control, which allows the storage
provider to manage access requests while learning only limited information from
its inputs. This is achieved by arranging outsourced resources into units called
access blocks and enforcing access control at the cloud only at the granularity
of blocks. The ﬁne-grained access control within each access block is enforced
at the user’s site and remains oblivious to the cloud. The mapping between ﬁles
and access blocks is transparent to the users in the sense that they can submit
ﬁle requests without knowing in what blocks the ﬁles are contained. While most
existing solutions [2, 13, 15] focus on read request, we present a solution that
provides both read and write access control.

1.1 Motivation
Traditional access control models often make an implicit assumption that the
entity enforcing access control policies is also the owner of data. However, in
many cases of distributed computing, this assumption no longer holds, and access
control policies are enforced at points which should not have direct access to the
data content itself, such as data outsourced to an untrusted third party. Hence
we need to store data in encrypted form and enforce access control over the
encrypted data. The setting of cloud computing falls into this category. The cloud
servers are considered to be honest but curious. They will follow our proposed
protocol in general, but try to ﬁnd out as much information as possible based on
their inputs. Hence data conﬁdentiality is not the only security concern. Privacy
becomes one of the major reasons that drives big companies to build their own
private cloud infrastructure rather than making use of the public cloud services.
First of all, access control policies deﬁned by the data owner that govern who
can have access to what data become private information with respect to the
storage provider. For example, suppose that a business newspaper reports that
a secretive company has just hired a new top-level executive who has specialized
in a particular ﬁeld. By watching what other organizations in the company –
perhaps ﬁrst research, then development, then procurement and manufacturing
– share access groups with this executive, an observer can learn signiﬁcant details
about the company’s strategy and progress. This is similar to what military
intelligence agencies do when using traﬃc analysis to determine an enemy’s
order of battle [7]. In fact, protecting access rules against privacy leakage is a
long-standing problem, and has been studied a lot in the past especially for
enforcing access control in databases [3]. This problem is mitigated by the use of
cryptography as an enforcement mechanism, which translates the access control
problem into the question of key management for decryption keys.

A more challenging task, that cannot be solved by data encryption alone, is
to protect data access patterns from careful observations on the inputs of the
storage provider. Even if data is stored and transferred in an encrypted format,
traﬃc analysis techniques can reveal privacy sensitive information. For example,
analysis on the length of encrypted traﬃc could reveal certain properties of the

3

enclosed data; access history could disclose a particular user’s access habits and
privileges; access to the same data object from multiple users could suggest a
common interest or collaborative relationship; a ranking of data popularity can
also be built upon access requests that the cloud receives. One trivial solution
is to return all encrypted data upon any access request. However, this comes
with prohibitive communication costs for data transfer as well as storage and
computation costs for decryption at the user’s side, which rules out this obvi-
ous solution. The question of hiding access pattern is challenging while avoiding
work proportional to the total size of all stored ﬁles. There have been several
cryptographic solutions that realize the notion of oblivious RAM and manage to
achieve improved amortized complexity for queries while hiding access patterns
[4, 11, 1, 5]. However, such solutions are highly interactive and still require com-
munication polylogarithmic in the size of the database, which in the setting of
large storage cloud providers, weak client devices and expensive network commu-
nication will not be practical (e.g., wireless network communication with limited
bandwidth). Furthermore, they assume that the user submitting the query is the
owner of all data, which does not ﬁt into our scenario where access control is
enforced on data shared by multiple users, not limited to the data owner.

An equally important, but often overlooked, aspect of access control for out-
sourced data is to enforce the write access. Existing solutions often handle only
read requests, which is obviously impractical in a more ﬂexible data sharing sce-
nario. For example, co-workers contribute to the same project document in a
collaborative working environment. While data encryption naturally preserves
authorization of the read access through key management, the procession of
a decryption key implies authorized read access but not necessarily the write.
Therefore, diﬀerent cryptographic schemes are mandatory to manage read and
write accesses separately. Further, a full-ﬂedged access control solution should
assume no relationship between read and write access rules (a user may have
both types of access, only one of them or none).

Therefore we summarize that a privacy-aware access control solution for data

sharing in outsourced storage needs to meet the following requirements:
1. it provides data conﬁdentiality by implementing a ﬁne-grained cryptographic

access control mechanism;

2. it supports practical and ﬂexible data sharing scheme by handling both read

and write operations in the access control model;

3. it enhances data and user privacy by protecting access control rules and

access patterns from the storage provider.

2 Two-level Access Control Model – Solution Overview
We consider the following scenario: a set of users outsource their data to a remote
storage (cloud) provider. These users further would like to be able to share
selectively some of their data among themselves. This data sharing should be
enabled directly at the cloud through appropriate access control rules that allow
users to retrieve all data that they are authorized to access (i.e. not involving the
actual data owner). Further, the access control rules governing the data sharing

4

and the data that users access are private information of the users and our goal
will be to protect this information from the cloud provider.

We distinguish the following three roles in this access control model: the data
owner who creates data to be stored at the remote storage in an encrypted for-
mat and regulates who has what access to each part of the data; the data user
who may have read and write access to the protected data; the cloud provider
that stores the encrypted data and responds to access requests. While a solution
that enforces access control solely through encryption of the data and appro-
priate decryption key distribution can achieve complete privacy for the access
patterns and access control rules by allowing users to retrieve the whole en-
crypted database, such an approach will be completely impractical requiring an
enormous amount of communication. We suggest a hybrid solution that oﬀers a
way to trade oﬀ privacy and eﬃciency guarantees. The basic idea behind it is to
provide two levels of access control: coarse-grained and ﬁne-grained. The coarse-
grained level access control will be enforced explicitly by the cloud provider and
it would also represent the granularity at which he will learn the access pattern
of users. Even though the cloud provider will learn the access pattern over all
user requests, he will not be able to distinguish requests from diﬀerent users,
which would come in the form of anonymous tokens. The ﬁne-grained access
control will be enforced obliviously to the cloud through encryption and would
prevent him from diﬀerentiating requests that result in the same coarse-grained
access control decision but have diﬀerent ﬁne-grained access pattern.

We realize the above two levels of access control by introducing division of the
data resources of the same owner into units called access blocks, which would
represent the coarse-level granularity in the system. Now the cloud provider
would be able to map user requests to the respective access blocks containing
the relevant data only if the user has access to the requested data and without
learning which part of the block is accessed. The provider would also not learn
the reason for no match: missing data or no access authorization. Our solution
does not require users to know the exact access blocks that would contain the
data they are searching for. Files might be moved between diﬀerent blocks, and
the only information that users would need in order to request them will be
a unique ﬁle identiﬁer rather than the id of the current block where the ﬁle is
residing. We will enable this oblivious mapping of ﬁles to blocks using techniques
from predicate encryption and some extensions to the scheme [9]. Once a user
retrieves the content of the matching block, he would be able to decrypt only the
part of the block, which he is authorized to access. We use the ideas of [13] to
minimize the decryption keys that need to be distributed for ﬁne-grained access
control within access blocks.

While the above suﬃces for read access control, handling write access control
is a little more subtle. The main issue there is that the cloud would need to allow
users to submit updates for diﬀerent parts of an access block without learning
which part are updated, and at the same time prevent users authorized to write
to one ﬁle in the block from writing to another ﬁle. In order to facilitate this
functionality the cloud provider would accept write updates for blocks only from

5

users that provide tokens granting them write access to some part of the block
(not revealing which part). These updates will be appended to the content of
the block but also the cloud would obliviously tag the updates with the id of the
ﬁle for which the user has been authorized, but without learning which this ﬁle
is. We achieve this functionality again through a modiﬁcation of the searchable
ciphertexts in a predicate encryption scheme.

3 Read Access Control

In this section, we present in detail the two-level access control scheme for read
access only after describing the following techniques applied in our protocol.

3.1 Techniques
Fine-Grained Access Control Fine-grained access control is applied to ﬁles
inside each access block to explicitly enforce access control rules. While the
cloud provider is able to determine whether a user submits a legitimate request
for some ﬁle within a block, he should remain oblivious to the access control rules
deﬁned for that ﬁle. To guarantee this property the access control view presented
to the cloud treats blocks as entities, and the cloud grants a read access by
providing the content of an entire block. Fine-grained access control is enforced
by encrypting ﬁles per block under diﬀerent keys, and the access control problem
is mitigated to appropriate key distribution. Even a user receives the encrypted
content of a block, he is able to decrypt only the ﬁles that he has access to. Access
revocation requires re-encryption of the resource and re-distribution of the new
key to the remaining authorized users. Our goal is to minimize the amount of
work and interaction between users and the system upon policy updates.

The work of [13] proposes an encryption-based access control solution for
outsourced data. Their key distribution is facilitated by the construction of a
public tree structure that allows each user to derive ﬁle decryption keys using
a secret, which he establishes once in the beginning. The leaf nodes in the tree
represent initial secrets distributed to users when they join the system, and the
internal nodes denote the ﬁle decryption keys derivable from leaf nodes using
public tokens along a directed path. Any update of the access control rules entails
a change in the tree. Access revocation requires re-encryption of aﬀected ﬁles.

In our scheme, each user generates a public-private key pair, and the public
key is used by data owners as initial secret to construct trees. Hence each user
only needs to maintain one key in the system and the distribution of leaf nodes is
implicit through the asymmetric key scheme. If some resources are only accessible
by a single user, instead of encrypting ﬁles using a leaf node (i.e., the public key),
we generate a symmetric key for ﬁle encryption, which is further encrypted under
that public key to avoid expensive computation of asymmetric scheme. In that
case, the initial secret needs to be explicitly distributed to an authorized user.
Unlike in [13], key derivation tokens have to be protected. First a user’s initial
secret is generally available to anyone in the system. More importantly, the tree
structure itself can reveal certain sensitive information to the cloud. For example,
a user having access to one ﬁle will have access to all the ﬁles along a directed

6

path. So the ontent of each node, a pointer to next node and the token to derive
next key are all protected under the current encryption key. Thus we can achieve
eﬃcient key distribution without requiring any direct interaction between data
owners and users beyond some initial set-up assuming only the cloud will be
online all the time. A list of algorithms for key distribution and management are
summarized in Figure 1.

– Publish(r, o, eo, acl): adds a resource r owned by o with a secret eo and

an access control list acl = acl read(r) for read access.

– Access Read(u, r, o): returns the encryption key for a resource r owned

by o, if u is an authorized user.

– Find Chain(u, r): ﬁnds the shortest chain of tokens from the secret key

of user u to derive the decryption key for resource r.

– Compute Key(u, chain): derives the secret key for a user u given a chain

of transition tokens.

– Find Resources(u, r): ﬁnds the set of nodes that lie on any path from

the user u to the node corresponding to resource r.

– Update(r, acl): if there is another resource with the same access control
list acl, i.e., there is a node in the tree accessable exactly by a subset of
users in acl, then encrypt r with the key contained in that node. Otherwise,
encrypt r with a new key, add a new node containing this key to the tree
and add appropriate edges to connect the new node to the users who
have access to r. (Note that certain subgroups of the users in acl might
already have a shared key through another node in tree, and in that case
we connect to that node rather than all the users’ nodes separately.)

Fig. 1: Algorithms for key distribution and management for ﬁne-grained AC.

Coarse-Grained Access Control The main goal to achieve at the level of
coarse-grained access control is to enable the cloud provider to obliviously match
a user’s request to an access block without learning which part of the block the
user is authorized to access. In addition we provide unlinkability among multiple
requests for the same resource even if coming from the same user, which further
protects users’ access patterns from the cloud provider. In order to achieve these
goals we apply the predicate encryption scheme of [9]. Observing that in this
scheme ciphertext can be re-randomized even without knowledge of the secret
key, we deﬁne a re-randomization algorithm in Deﬁnition 1.
Deﬁnition 1. A re-randomizable predicate encryption scheme consists of the
following algorithms:

– Setup(1n): produces a master secret key SK and public parameters;
– EncSK(x): encrypts an attribute x using key SK;
– GenKeySK(f ): generate a decryption key SKf associated with a function f ;
– DecSKf (c): outputs 1 if the attribute encrypted in c = EncSK(x) satisﬁes f ,
– Rand(c): computes a new encryption c(cid:48) of the value encrypted in c but with

i.e. f (x) = 1, and output a random value, otherwise;

diﬀerent randomness without the secret key.
We present the predicate encryption scheme of [9] and the instantiation of the
function Rand(c) for that scheme in Appendix A. This scheme handles a class of

7

functions f , which includes polynomials of bounded degree. We use polynomial
functions of the type f (x) = (x − id1)··· (x − idn), to implement coarse-grained
access control. Figure 2 present a list of algorithms to enforce access control
on the block level granularity without revealing the exact ﬁles that are being
accessed insider a block. The algorithm File Access Check grants access if the
submitted access token matches any of the ﬁles in the block without revealing
the ﬁle identity. The request token produced by File Access Request is an
encryption that does not leak information about the ﬁle id it contains.

– Block Access Setup: data owner runs Setup(1n), publishes the public
parameters and keeps the master secret key SK. For ﬁles id1, . . . , idn in
each block, he computes SKf = GenKeySK (f ) for f (x) = (x−id1)··· (x−
idn) and sends SKf to the cloud provider.

– File Access Authorization: data owner provides access to a ﬁle id by

sending cid = EncSK (id) to an authorized user.

– File Access Request: user generates a token tid = Rand(cid) for ﬁle id.
– File Access Check: upon receiving a request token t, the cloud computes

DecSKf (t) for each block, and returns those blocks that compute to 1.

Fig. 2: Algorithms for enforcing coarse-grained AC at the access block level.

3.2 Read Access Control

We present a read access control solution consisting of the following algorithms.
Unless explicitly stated, all the actions are performed by individual data owners.
– System Setup: At the ﬁne-grained level, ﬁles are distributed into access
blocks. Generate a tree graph per block by running Publish(r, o, eo, acl) for
each resource r owned by o with initial ACLs, and encrypt resources using keys
from the tree graph. At the coarse-grained level, each data owner computes
parameters for a predicate encryption scheme. Then he constructs a separate tree
graph over all resources he owns to distribute authorization tokens of the form
cid = EncP K(id) (i.e., now tree nodes contain authorizations tokens rather than
ﬁle decryption keys). Finally, data owner computes a key SKf = GenKeySK(f )
per block where f is the polynomial derived from the ids of the ﬁles contained
in that block as described above, and gives this key to the cloud provider, which
will use it to obliviously check read access on authorization tokens.
– Access Authorization: At the ﬁne-grained level, add a leaf node contain-
ing the new user’s public key to the corresponding tree graph with encryption
keys. Update the graph by adding new internal nodes and appropriate edges if
necessary. Update ﬁle encryptions if new internal nodes were added previously.
At the coarse-grained level, perform similar operations with respect to the tree
graph containing read access tokens.
– Access Request: At the ﬁne-grained level, an authorized user u derives the
decryption key from the tree graph for resource r by calling Find Chain(u, r),
Find Resources (u, r) and Compute Key(u, chain). At the coarse-grained
level, he calls the same set of functions but to query the tree graph with access
tokens and ﬁnd token cid = EncSK(id) for the requested ﬁle id, and then submit
a randomized token tid = Rand(cid) to the cloud.

8

– Access Check: At the ﬁne-grained level, only authorized users can derive the
correct decryption key for any ﬁle using the public tree structure. At the coarse-
grained level, the cloud provider executes File Access Check to identify the
block that contains the requested ﬁle.
– Access Rule Update: At the ﬁne-grained level, changes are applied im-
mediately upon policy updates. If the policy update involves access revocation,
the data owner changes the encryption of corresponding ﬁles. The data owner
identiﬁes the blocks aﬀected by those ﬁles and updates their tree graphs with
decryption keys. The changes at the coarse-grained level happen at longer in-
tervals of time, the length of which would depend on the resources of the data
owner. They involve updating of the tree graph with access tokens.

4 Write Access Control

Enforcing write access control presents more challenges, mainly for the fact that
access control through data encryption does not apply to cases when data can be
modiﬁed. Without revealing ﬁne-grained access control policies, it is not guar-
anteed that a user will modify only ﬁles that he is granted write access to. An
unauthorized user can overwrite and destroy data without being detected by the
cloud, regardless of whether he has the read privilege. A trivial solution is to rely
on the cloud provider to restrict the memory regions to which users may submit
changes, which however reveals to the cloud access rules and access patterns.

The approach that we adopt is to record modiﬁcations of ﬁles in new regions
of memory without overwriting previous content. The coarse-grained access con-
trol enforced by the cloud allows users to submit changes for ﬁles only if they can
demonstrate write permission for some resource in that block, without revealing
the exact content to be changed. At the ﬁne-grained level, a public encryption
scheme is used to separate read and write privileges by providing a key pair for
each ﬁle. The only information that the cloud tags to each ﬁle change obliviously
contains implicit information on ﬁle identiﬁer. However, using a submitted write
authorization token directly as an update identiﬁer will enable users with only
read access to copy and reuse it later to obtain write privilege. To prevent this
undesired situation, we take advantage of the predicate encryption ciphertexts
constituting access tokens, which allows us to use part of the token as identiﬁer.
We generate predicate that allows users with read access to identify relevant
updates, but this identiﬁer on its own is not suﬃcient to grant write access.

4.1 Techniques

File Encryption We apply an asymmetric encryption scheme to handle all
possible combinations of read and write access to a ﬁle. Since such scheme is
computationally expensive for large size of data, ﬁle content is still encrypted
using a symmetric key (e.g., AES), which is further encrypted under the public
key. Two trees are constructed for key distribution per block – one for the public
(encryption) keys and the other for the private (decryption) keys. These two
trees share the same set of internal nodes for an one to one correspondence
between public and private key pair. Only ﬁles readable and writable by the
same set of users can share the same public key pair.

9

Access Authorization Tokens Two trees are constructed by each data owner
for the distribution of read and write access tokens respectively.
File Identiﬁers for Write Updates We observe that the write authorization
token is a valid encryption for a predicate encryption that provides polynomials
evaluation, and the structure of the encrypted plaintext for access to ﬁle id is a
vector of the form (1, id, id2, . . . , idn), where n is the number of ﬁles placed in
a block. The structure of the ciphertext allows it to be split into parts where
one part is an encryption of the vector (1, id, id2, . . . , idk) (k < n, n > 2),
which is no longer a valid write access token for that ﬁle, but can still be used
identify ﬁle updates for users with read privilege. This can be achieved using a
decryption predicate for a polynomial of degree k that has id as a zero point.
(See Appendix A for details.)

4.2 Integrated Read and Write Access Control
We realize the above proposal for the write access control enforcement and de-
scribe an integrated solution for both read and write access. Because of space
constraints we describe only the functionality associated with write access en-
forcement. The read access is the same as the construction in the previous section
with the exception that once a client has retrieved a block he needs to identify
both the original encryption of the ﬁle as well as all updates for that ﬁle. The
latter will be achieved using an additional key (a new part in his authorization
token) that will allow him to identify the valid updates submitted for that ﬁle.
– Setup: At the ﬁne-grained level, construct a key distribution tree per block
based on read access rules. For each node in the tree, generate a public-private
key pair (skn, pkn), but only store the secret key skn. Construct another tree
with the same set of nodes to store the public key pkn, with edges determined by
write access rule. For each ﬁle id generate a AES key skaes
for encryption, and
id
append to the ciphertext Encpkn (skaes
id ). At the coarse-grained level, each data
owner generates two sets of parameters (pk(cid:48), sk(cid:48)) and (pk”, sk”) for the predicate
encryption. Then he constructs a tree graph, where each node contains read
access token Encpk(cid:48)
(id) (used by the cloud provider to check the read access)
(f ) where f (x) = x− id (used by the user to identify
and SKx−id = GenKeysk(cid:48)(cid:48)
all updates to the ﬁle within the retrieved block). Similarly, construct another
tree to distribute write access tokens Encpkwa(id).
– Access Authorization: At the coarse-grained level, extend the trees with
read and write access tokens with new leaves for the new user and update the
edges according to his read and write permissions. This may involve splitting of
nodes and re-encrypting ﬁles with new keys if the user has read access only to a
subset of ﬁles that have been encrypted with the same key.
– Write Access Request: At the ﬁne-grained level, obtain the encryption key
pkn for the ﬁle to be updated from the write tree. Encrypt the new content
for that ﬁle with key pkn. At the coarse-grained level, submit to the cloud a
re-randomized copy of the write authorization token for that ﬁle.
– Write Access Check: At the ﬁne-grained level, a user can modify a ﬁle
only if he has the encryption key and the write authorization token. Upon read
he will check at the end of a block a list of updates with valid write access

ra

ra

10

tokens. At the coarse-grained level, the cloud ﬁnds if there is a block for which
the authorization token grants write access. The write access token is of the form
(C0,{C1,i, C2,i}n
i=1)
as an identiﬁer for updates appended to a block.
– Write Access Rule Update: Update per-block trees for encryption keys
and the tree for distributing write access tokens accordingly.

i=1), and the cloud uses the ﬁrst components (C0,{C1,i, C2,i}2

4.3 An Example
To facilitate our discussion, consider a system with ﬁve users U = {A, B, C, D,
E}. Let Ro denote the set of resources owner by user o ∈ U , and we have
RA = {r1, r2, r3, r4}, RB = {r5, r6, r7} and RC = RD = RE = ∅. Access control
lists (ACLs) are used to represent ﬁne-grained level access policies, and the owner
of each resource automatically entails both read and write access privilege. At the
coarse-grained level, user A maintains two blocks b1 = {r1, r2} and b2 = {r3, r4},
and user B maintains a single block b3 = {r5, r6, r7}.
1. acl read(r1) = {A, B, C}, acl write(r1) = {A, B, C};
2. acl read(r2) = {A, B, C}, acl write(r2) = {A, B, C};
3. acl read(r3) = {A, E}, acl write(r3) = {A};
4. acl read(r4) = {A, B, C, E}, acl write(r4) = {A, D};
5. acl read(r5) = {A, B}, acl write(r5) = {A, B, C};
6. acl read(r6) = {B, C, D}, acl write(r6) = {B, D, E};
7. acl read(r7) = {A, B, C, D, E}, acl write(r7) = {A, B, C, D, E}.

Follow the above example, two trees are constructed per block for read and
write access respectively at the ﬁne-grained level in Figure 3. Each block stores
ﬁles owned by a single user (shaded), and a public key pair is generated for each
contained resource ri, where skid is stored in the read tree and pkid in the write
∗j
tree. Leaf nodes v
1n store users’ initial public keys, which are connected to in-
ternal nodes following key derivation paths (think links). Each row in the table
states ri in block bj is associated with key skid (pkid) at vertex vRj
mn ). Dif-
ferent ACLs on read and write for the same resource entail diﬀerent labels of user
31 is labeled as [ABCE] since acl read(r4) = {A, B, C, E}; whereas
list, e.g., vR2
is labeled as [AD] given acl write(r4) = {A, D}. In Figure 3(a), both trees
vW 2
31
share the same set of vertexes and edges, as acl read(r1) = acl read(r2) =
acl write(r1) = acl write(r2) = {A, B, C}. Figure 4 depicts tree graphs per
data owner to distribute read and write access tokens respectively at the coarse-
grained level. (Due to space limitation, coarse-grained graphs for resources owned
by user B are omitted.) Each row in the table states ri is associated with an
unique read (write) access token Encpk(cid:48)
ra(id) (Encpkwa(id)) encrypted on its id
and stored at vertex vRO
mn (vW O
mn ). For example, r1 and r2 are now given diﬀer-
ent access tokens at vertexes v∗A
22 respectively. Each authorized write
operation requires an additional update token SKx−id distributed to authorized
users the same way as read access tokens.

21 and v∗A

mn (vW j

5 Analysis

5.1 Security Guarantees
Our two-leveled access control scheme provides the following privacy guarantees
for data owners and users in the system:

11

Fig. 3: Tree graphs per block for read and write access at the ﬁne-grained level.

Fig. 4: Distribution of read and write access tokens at the coarse-grained level.

Read Access For the privacy of the data owners, the cloud provider does
not learn any of the content of the ﬁles that he stores. The cloud learns the
frequency of access to particular blocks but not the exact ﬁles that have been
accessed within a block. For users’ privacy, the cloud provider cannot relate
access requests to particular users’, neither can he infer which requests were
submitted from the same user. However, he can observe the block access pattern
from the requests of all users. The data owner does not learn anything about
the access requests for the data.

Write Access For privacy of the data owners, the cloud provider learns
how often update requests are submitted for each block but without ﬁnding
out which ﬁles have been written. Similarly to the read requests, write requests
coming from the users are anonymous and unlinkable. Thus the cloud provider
cannot learn anything about the access behavior of a particular user, but only
a cumulative view over the requests from all users.

5.2 Performance Analysis

Read Access During setup, data owners compute of the authorization trees
with decryption keys and access tokens. The work is proportional to the number
of ﬁles in the database and the number of users. In order to authorize or to

b1	  =	  {r1,	  r2}	  b2	  =	  {r3,	  r4}	  (a)	  Encryp4on	  policy	  graph	  of	  read-­‐and-­‐write	  access	  for	  block	  b1	  b3	  =	  {r5,	  r6,	  r7}	  r	  	  node	  key	  r1	  vR121	  sk(1,2)	  r2	  vR121	  sk(1,2)	  b1	  =	  {r1,	  r2}	  r	  	  node	  key	  r1	  vW121	  pk(1,2)	  r2	  vW121	  pk(1,2)	  r	  	  node	  key	  r3	  vR221	  sk3	  r4	  vR231	  sk4	  b2	  =	  {r3,	  r4}	  r	  	  node	  key	  r3	  vW221	  pk3	  r4	  vW231	  pk4	  (b)	  Encryp4on	  policy	  graph	  of	  read-­‐and-­‐write	  access	  for	  block	  b2	  r	  	  node	  key	  r5	  vR321	  sk5	  r6	  vR322	  sk6	  r7	  vR331	  sk7	  b3	  =	  {r5,	  r6,	  r7}	  r	  	  node	  key	  r5	  vW321	  pk5	  r6	  vW322	  pk6	  r7	  vW331	  pk7	  (c)	  Encryp4on	  policy	  graph	  of	  read-­‐and-­‐write	  access	  for	  block	  b3	  A	  B	  C	  D	  E	  VR111	  [A]	  VR121	  [ABC]	  VR112	  [B]	  VR113	  [C]	  A	  B	  C	  D	  E	  VW111	  [A]	  VW121	  [ABC]	  VW112	  [B]	  VW113	  [C]	  A	  B	  C	  D	  E	  VR211	  [A]	  VR212	  [E]	  VR213	  [B]	  VR214	  [C]	  VR221	  [AE]	  VR231	  [ABCE]	  A	  B	  C	  D	  E	  VR311	  [A]	  VR313	  [C]	  VR312	  [B]	  VR322	  [BCD]	  VR315	  [E]	  VR314	  [D]	  VR321	  [AB]	  VR331	  [ABCDE]	  A	  B	  C	  D	  E	  VW311	  [A]	  VW313	  [C]	  VW312	  [B]	  VW322	  [BDE]	  VW315	  [E]	  VW314	  [D]	  VW331	  [ABCDE]	  VW321	  [ABC]	  A	  B	  C	  D	  E	  VW211	  [A]	  VW212	  [E]	  VW213	  [B]	  VW214	  [C]	  VW221	  [A]	  VW231	  [AD]	  r	  	  node	  	  token	  r1	  	  vWA21	  	  Encpkwa(r1)	  r2	  	  vWA22	  	  Encpkwa(r2)	  r3	  	  vWA11	  	  Encpkwa	  (r3)	  r4	  	  vWA23	  	  Encpkwa	  (r4)	  A	  B	  C	  D	  E	  VWA11	  [A]	  VWA12	  [B]	  VWA13	  [C]	  VWA14	  [D]	  VWA21	  [ABC]	  VWA23	  [AD]	  (b)	  Write	  access	  token	  graph	  for	  owner	  A	  VWA22	  [ABC]	  A	  B	  C	  D	  E	  VRA11	  [A]	  VRA21	  [ABC]	  VRA12	  [B]	  VRA13	  [C]	  VRA14	  [E]	  VRA23	  [AE]	  VRA31	  [ABCE]	  (a)	  Read	  access	  token	  graph	  for	  owner	  A	  r	  	  node	  	  token	  r1	  	  vRA21	  	  Encpk’ra(r1)	  r2	  	  vRA22	  	  Encpk’ra(r2)	  r3	  	  vRA23	  	  Encpk’ra(r3)	  r4	  	  vRA31	  	  Encpk’ra(r4)	  VRA22	  [ABC]	  12

revoke ﬁle access to a user, data owner updates the tree with decryption keys
and the tree with access tokens: in the worst case proportional to the depth of
the trees. The updates for the tree with the access tokens can be executed at
larger intervals of time to achieve better amortized eﬃciency for updates. For
users, retrieving access tokens requires reading the coarse-level tree with access
tokens for the data of a particular provider. Decryption keys retrieval can be
proportional to the number of ﬁles that the user is authorized to access. For the
cloud provider, in order to map an access request to a particular block the cloud
provider will have to execute the File Access Check function for the submitted
token and each block. We describe in the following optimization section how we
can reduce the costs estimated here.

Write Access From the perspective of a data owner, the enforcement of
write access control requires duplication of the tree structures that were neces-
sary for the read access control but this time with credentials necessary for the
write access. This comes as an overhead in the setup phase when these structures
are computed by the data owner and also each update of the access rules will
necessitate update of both types of trees since the encryption and decryption
(relevant for write and read access) need to be synchronized. Also periodically
the data owner would need to process the blocks and compact the updates for
each ﬁle back in its initial memory location. For a user, the size of the blocks
that he receives, and hence the time he needs to locate the ﬁle and its updates
at read access, will increase depending on the frequency of the updates for a
block as well as the time period at which the data owner processes the blocks
and brings the updates back in place. The cloud provider would need to transfer
larger blocks including both the original ﬁles as well as the updates. He would
need to compute the identiﬁcation tag for each authorized write update, which
requires constant time.
Optimizations. Some optimizations that help improve the performance of the
scheme are as follows. If the user has enough memory, he can cache both autho-
rization tokens and decryption keys for multiple accesses of the same ﬁles. This
optimization applies to the read and the write access tokens as well as the de-
cryption key for read. The only exception is the encryption key for write access
— the user should always derive the current public encryption key for the ﬁle,
which he wants to update since if the key has been changed, he will not be able
to detect it and will submit an invalid update. Similarly the user can cache the
identiﬁer of the block in which a ﬁle is located and use it in repeated requests,
which will save the search time at the cloud avoiding checks of all blocks. Further
the user can trade-oﬀ the privacy guarantee for his request within its block for
smaller communication overhead by revealing the exact memory address of the
ﬁle after proving that he is authorized to access the block.

5.3 Discussion
Choosing the granularity for the access blocks in the read and write access control
schemes aﬀects the privacy guarantees for the scheme as well as its eﬃciency
performance. The right granularity for each speciﬁc usage scenario will depend
on the privacy and eﬃciency requirements for it, the expected patterns of access

13

to the ﬁles and the expected frequency of access control rules’ updates. The
following points should be taken into consideration when choosing how to divide
the ﬁles into access blocks: the size of a block should depend on the expected
bandwidth of the clients and the acceptable delays for the system. Files that
contain “complementary” information, i.e., a user is likely to access only one of
a these ﬁles (e.g. a ﬁle to sell stocks, a ﬁle to buy stocks) should be located in
the same block since their access pattern is highly sensitive. Data that requires
frequent updates should be split into smaller blocks since the size of those blocks
will grow faster. Accessing ﬁles with frequently changing access rules will require
derivation of the corresponding decryption keys, which is proportional to the
number of ﬁles in the block, such ﬁles should be located in blocks with fewer
items (that can still be of big size). Since the view of the cloud provider of the
access requests amounts to the frequency at which each access block is matched,
ﬁles that are expected to have high access rates should be distributed across
diﬀerent blocks.

6 Related Work
Existing access control solution in outsourced storage usually apply crypto-
graphic methods by disclosing data decryption keys only to authorized users. [8]
proposed a cryptographic storage system, called Plutus, which arranges ﬁles with
similar attributes into ﬁlegroups, applying two-level ﬁle encryption and distin-
guishes read and write access. [6] designed a secure ﬁle system to be layered over
insecure network and P2P ﬁle system, like NFS. Each ﬁle is attached a meta data
containing the ﬁle’s access control list. [15] deﬁnes and enforces ﬁne-grained ac-
cess control policies based on data attributes, and delegates most of computation
tasks to untrusted cloud server without disclosing data content. [12] proposed
a cloud storage system, called CloudProof, that enables meaningful security
Service Level Agreements (SLAs) by providing a solution to detect violations
of security properties, namely conﬁdentiality, integrity, write-serializability, and
read freshness. The problem presented in this paper shares some similarity with
the proposals in [14, 2]. [14] introduced a practical oblivious data access protocol
using pyramid-shaped database layout and an enhanced reordering techniques
to ensure access pattern conﬁdentiality. [2] proposed a shuﬄe index structure,
adapting traditional B-tree, to achieve content, access and pattern conﬁdential-
ity in the scenario of outsourced data. All those proposals focus on one or more
aspects, such as scalability, eﬃciency, minimizing key distribution, etc., but none
of them consider privacy issues as well as write access control.

7 Conclusion
We presented a two-level access control scheme enabling data sharing in out-
sourced storage, like the cloud environment. The ﬁne-grained and the coarse-
grained access control schemes complement each other to achieve both data
conﬁdentiality and privacy protection on access patterns. To the best of our
knowledge, we are the ﬁrst to handle both read and write access rights entailing
a more practical data sharing solution. As follow-on work, we will conduct ex-
periments on a full implementation of our scheme. As a more ambitious goal, we

14

would like to further extend our scheme for a complete solution that guarantees
both security and privacy protection for a remote ﬁle storage system.

References

1. Ivan Damg˚ard, Sigurd Meldgaard, and Jesper Buus Nielsen. Perfectly secure obliv-

ious ram without random oracles. In TCC, 2011.

2. S. De Capitani di Vimercati, S. Foresti, S. Paraboschi, G. Pelosi, and P. Samarati.
Eﬃcient and private access to outsourced data. In Proc. of the 31st International
Conference on Distributed Computing Systems (ICDCS 2011), Minneapolis, Min-
nesota, USA, June 2011.

3. S. De Capitani di Vimercati, S. Foresti, and P. Samarati. Recent advances in
access control. In M. Gertz and S. Jajodia, editors, Handbook of Database Security:
Applications and Trends. Springer-Verlag, 2008.

4. O. Goldreich and R. Ostrovsky. Software protection and simulation on oblivious

RAMs. Journal of the ACM (JACM), 43(3):473, 1996.

5. Michael T. Goodrich and Michael Mitzenmacher. Privacy-preserving access of
outsourced data via oblivious ram simulation. In in Proc. International Colloquium
on Automata, Languages and Programming, ICALP’11, 2011.

6. Eu jin Goh, Hovav Shacham, Nagendra Modadugu, and Dan Boneh. Sirius: Se-
In in Proc. Network and Distributed Systems

curing remote untrusted storage.
Security (NDSS) Symposium 2003, pages 131–145, 2003.

7. David Kahn. The Codebreakers. Macmillan, New York, 1967.
8. Mahesh Kallahalla, Erik Riedel, Ram Swaminathan, Qian Wang, and Kevin Fu.
Plutus: Scalable secure ﬁle sharing on untrusted storage. In USENIX Conference
on File and Storage Technologies, 2003.

9. Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption support-
ing disjunctions, polynomial equations, and inner products. In Proceedings of the
theory and applications of cryptographic techniques 27th annual international con-
ference on Advances in cryptology, EUROCRYPT’08, pages 146–162, Berlin, Hei-
delberg, 2008. Springer-Verlag.

10. Vivek Kundra.

Tight budget?

Times,

York
tight-budget-look-to-the-cloud.html?_r=1.

2011.

look to

The New
http://www.nytimes.com/2011/08/31/opinion/

‘Cloud’.

the

11. B. Pinkas and T. Reinman. Oblivious RAM Revisited. Advances in Cryptology–

CRYPTO 2010, pages 502–519, 2010.

12. Raluca Ada Popa, Jacob R. Lorch, David Molnar, Helen J. Wang, and Li Zhuang.
In in Proc. USENIX

Enabling security in cloud storage slas with cloudproof.
Annual Technical Conference ATC’11, 2011.

13. S. De Capitani di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, G. Pelosi, and
P. Samarati. Encryption-based policy enforcement for cloud storage. In Proceedings
of the 2010 IEEE 30th International Conference on Distributed Computing Systems
Workshops, ICDCSW ’10, pages 42–51, 2010.

14. Peter Williams, Radu Sion, and Bogdan Carbunar. Building castles out of mud:
practical access pattern privacy and correctness on untrusted storage. In Proceed-
ings of the 15th ACM conference on Computer and communications security, CCS
’08, pages 139–148, New York, NY, USA, 2008. ACM.

15. Shucheng Yu, Cong Wang, Kui Ren, and Wenjing Lou. Achieving secure, scalable,
and ﬁne-grained data access control in cloud computing.
In Proceedings of the
29th conference on Information communications, INFOCOM’10, pages 534–542,
Piscataway, NJ, USA, 2010. IEEE Press.

A Predicate Encryption and Extensions

We present the construction of predicate encryption of [9] as follows:

15

– Setup(1n): Choose primes p, q and r and groups Gp, Gq and Gr with genera-
tor gp, gq and gr respectively. Let G = Gp×Gq×Gr. Choose R1,i, R2,i ∈ Gr,
h1,i, h2,i ∈ Gp uniformly at random for 1 ≤ i ≤ n and R0 ∈ Gr. The public
parameters for the scheme are (N = pqr, G, GT , e). The public key P K and
master secret key SK are deﬁned as follows:

P K = (gp, gr, Q = gq · R0,{H1,i = h1,i · R1,i, H2,i = h2,i · R2,i}n

i=1),

SK = (p, q, r, gq,{h1,i, h2,i}n

i=1).

– EncSK(x1, . . . , xn): Choose randoms s, α, β ∈ ZN , R3,i, R4,i ∈ Gr for 1 ≤

i ≤ n, then output the following ciphertext:

p,{C1,i = H s

1,i · Qα·xi · R3,i, C2,i = H s

2,i · Qβ·xi · R4,i}n

i=1

– GenKeySK(v1, . . . , vn): Choose randoms r1,i, r2,i ∈ Zp for 1 ≤ i ≤ n, R5 ∈

Gr, f1, f2 ∈ Zq and Q6 ∈ Gq, then output SKv that consists of
, K2,i = gr2,i

, {K1,i = gr1,i

· gf1·vi

· gf2·vi

q

}n

i=1

−r1,i
h
1,i

p

· h

−r2,i
2,i

p

q

(cid:1).

C =(cid:0)C0 = gs
(cid:0)K = R5 · Q6 · n(cid:89)

i=1

(cid:1)

– DecSKf (c): The decryption algorithm outputs 1 if and only if

e(C0, K)

e(C1,i, K1,i) · e(C2,i, K2,i) = 1.

n(cid:89)

i=1

We deﬁne an algorithm called Rand(C) that re-randomizes any ciphertext
produced by the predicate encryption. Given a ciphertext of form (C0,{C1,i, C2,i}n
choose a random s(cid:48) ∈ ZN and output C(cid:48) = C0 · gs(cid:48)
p ,{C1,i·H s(cid:48)
i=1. The
resulting ciphertext is the same as freshly generated ciphertext for the encrypted
value using random value s + s(cid:48), if s was the value used in C.

1,i, C2,i·H s(cid:48)

2,i}n

i=1),

Now we look closely at the instantiation of the predicate encryption scheme
that handles polynomial evaluation as its predicate. In this case the predicate
(v1, . . . , vn) consists of the coeﬃcients of the polynomial that is being evalu-
ated and the attribute vector that is used for an evaluation point x is of the
form (1, x, x2, . . . , xn−1). The ciphertext for the encryption of (1, x, x2, . . . , xn−1)
has components (C0,{C1,i, C2,i}n
i=1), where C1,i, C2,i correspond to the vec-
tor point xi−1. Thus we can view the ﬁrst view components of the ciphertext
(C0,{C1,i, C2,i}2
i=1) as an encryption of the vector (1, x) that can be used for
evaluation of predicates that are linear functions.

We use the above observation in the instantiation of the tags that the cloud
derives for each of the accepted write updates. He uses the token that the client
has used to prove his write access to a particular block, which a predicate encryp-
tion ciphertext (C0,{C1,i, C2,i}n
i=1), to derive identiﬁer for the ﬁles with which
the submitted update will be associated by taking the ﬁrst part of the ciphertext
(C0,{C1,i, C2,i}2
i=1). This identiﬁer cannot be used as a write access token since
it is missing substantial part of the ciphertext, and no party without the master
secret key can extend an identiﬁer to a valid write token. Also any party that
has read access to the ﬁle associated with the update will be given a key that
would allow it to recognize the updates for that ﬁle. This key is the predicate
corresponding to the linear function that evaluates to zero at the ﬁle id.

