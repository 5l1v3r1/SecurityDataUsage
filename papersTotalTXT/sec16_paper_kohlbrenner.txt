Trusted Browsers for Uncertain Times

David Kohlbrenner and Hovav Shacham, University of California, San Diego

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/kohlbrenner

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Trusted browsers for uncertain times
Hovav Shacham†
David Kohlbrenner∗
UC San Diego

UC San Diego

Abstract
JavaScript in one origin can use timing channels in
browsers to learn sensitive information about a user’s in-
teraction with other origins, violating the browser’s com-
partmentalization guarantees. Browser vendors have at-
tempted to close timing channels by trying to rewrite sen-
sitive code to run in constant time and by reducing the
resolution of reference clocks.

We argue that these ad-hoc efforts are unlikely to suc-
ceed. We show techniques that increase the effective
resolution of degraded clocks by two orders of magni-
tude, and we present and evaluate multiple, new implicit
clocks: techniques by which JavaScript can time events
without consulting an explicit clock at all.

We show how “fuzzy time” ideas in the trusted operat-
ing systems literature can be adapted to building trusted
browsers, degrading all clocks and reducing the band-
width of all timing channels. We describe the design of
a next-generation browser, called Fermata, in which all
timing sources are completely mediated. As a proof of
feasibility, we present Fuzzyfox, a fork of the Firefox
browser that implements many of the Fermata principles
within the constraints of today’s browser architecture.
We show that Fuzzyfox achieves sufficient compatibil-
ity and performance for deployment today by privacy-
sensitive users.
In summary:

• We show how an attacker can measure durations in
web browsers without querying an explicit clock.
• We show how the concepts of “fuzzy time” can ap-

ply to web browsers to mitigate all clocks.

• We present a prototype demonstrating the impact of

some of these concepts.

Introduction

1
Web browsers download and run JavaScript code from
sites a user visits as well as third-party sites like ad net-
works, granting that code access to system resources
through the DOM. Keeping that untrusted code from tak-
ing control of the user’s system is the conﬁnement prob-
lem.
In addition, browsers must ensure that code run-
ning in one origin does not learn sensitive information

∗dkohlbre@cs.ucsd.edu
†hovav@cs.ucsd.edu

about the user’s interaction with another origin. This is
the compartmentalization problem.

A failure of confinement can lead to a failure of com-
partmentalization. But JavaScript can also learn sen-
sitive information without escaping from its sandbox,
in particular by exploiting timing side channels. A
timing channel is made possible when an attacker can
compare a modulated clock — one in which ticks ar-
rive faster or slower depending on a secret — to a ref-
erence clock — one in which ticks arrive at a consis-
tent rate. For example, browsers allow web pages to
apply SVG transformations to page elements, includ-
ing cross-origin frames, via CSS. Paul Stone showed
that a fast-path optimization in the feMorphology
filter created a timing attack that allowed attackers to
steal pixels or sniff a user’s browsing history, using
Window.requestAnimationFrame() as a modu-
lated clock [24]. More recently, Oren et al. showed that,
in the presence of a high-resolution reference clock like
performance.now, attackers could use JavaScript
TypedArrays to measure instantaneous load on the last-
level processor cache [19].

Browser vendors are aware of the danger that timing
channels pose compartmentalization and have made ef-
forts to address it.

First,

they have attempted to eliminate modulated
clocks by making any code that manipulates secret
values run in constant time.
In a hundred-message
Bugzilla thread, for example, Mozilla engineers decided
to address Stone’s pixel-stealing work by rewriting the
feMorphology filter implementation using constant-
time comparisons.1

Second, they have attempted to reduce the resolution
of reference clocks available to JavaScript code. In May,
2015, the Tor Browser developers reduced the resolu-
tion of the performance.now high-resolution timer
to 100 ms as an anti-fingerprinting measure.2
In late
2015, some major browsers (Chrome, Firefox) applied
similar patches (see Figure 1), reducing timer resolution
to 5 µs to defeat Oren et al.’s cache timing attack [19].

These efforts are unlikely to succeed, because they se-

riously underestimate the complexity of the problem.

First, eliminating every potential modulated clock
would require an audit of the entire code base, an ambi-
tious undertaking even for a much smaller, simpler sys-
tem such as a microkernel [3]. Indeed, the Mozilla fix
for feMorphology did not consider the possibility that

USENIX Association  

25th USENIX Security Symposium  463

floating-point instructions execute faster or slower de-
pending on their inputs, allowing pixel-stealing attacks
even in supposedly “constant-time” code [1].

Second, there are many ways by which JavaScript
synthesize a reference clock besides
code might
naively querying performance.now.
In this paper,
we show that clock-edge detection allows JavaScript
to increase the effective resolution of a degraded
performance.now clock by two orders of magni-
tude. We also present and evaluate multiple, new
implicit clocks:
techniques by which JavaScript can
time events without consulting an explicit clock like
performance.now at all. For example, videos in an
HTML5 <video> tag are decoded in a separate thread.
JavaScript can play a simple video that changes color
with each frame and examine the current frame by ren-
dering it to a canvas. This immediately gives an implicit
clock with resolution 60 Hz, and the resolution can be
improved using our techniques.

In short, timing channels pose a serious danger to
compartmentalization in browsers; browser vendors are
aware of the problem and are attempting to address
it by eliminating or degrading clocks attackers would
rely on, but their ad-hoc efforts are unlikely to succeed.
Our thesis in this paper is that the problem of timing
channels in modern browsers is analogous to the prob-
lem of timing channels in trusted operating systems and
that ideas from the trusted systems literature can in-
form effective browser defenses.
Indeed, our descrip-
tion of timing channels as the comparison of a reference
clock and a modulated clock is due to Wray [28], and
our fuzzy mitigation strategy technique is directly in-
spired by Hu [10] — both papers resulting from the VAX
VMM Security Kernel project, which targeted an A1 rat-
ing [12].

In this paper, we show that “fuzzy time” ideas due
to Hu [10] can be adapted to building trusted browsers.
Fuzzy time degrades all clocks, whether implicit or ex-
plicit, and it reduces the bandwidth of all timing chan-
nels. We describe the properties needed in a trusted
browser where all timing sources are completely medi-
ated. Today’s browsers tightly couple the JavaScript en-
gine and the DOM and would need extensive redesign
to completely mediate all timing sources. As a proof
of feasibility, we present Fuzzyfox, a fork of the Fire-
fox browser that works within the constraints of today’s
browser architecture to degrade timing sources using
fuzzy time. Fuzzyfox demonstrates a principled clock
fuzzing scheme that can be applied to both mainstream
browsers and Tor Browser using the same mechanics.
We evaluate the performance overhead and compatibil-
ity of Fuzzyfox, showing that all of its ideas are suitable
for deployment in products like Tor Browser and a milder
version are suitable for Firefox.

double PerformanceBase::clampTimeResolution

(double timeSeconds)

{

}

const double resolutionSeconds =

0.000005;

return floor(timeSeconds /

resolutionSeconds) *
resolutionSeconds;

Figure 1: Google Chrome performance.now round-
ing code

// Find minor ticks until major edge
function nextedge(){

start = performance.now();
stop = start;
count = 0;

while(start == stop){

stop = performance.now();
count++;

}

return [count,start,stop];

}

// run learning
nextedge();
[exp,pre,start] =nextedge();

// Run target function
attack();

// Find the next major edge
[remain,stop,post] =nextedge();

// Calculate the duration
duration = (stop-start)+((exp-remain)/exp)*

grain;

Figure 2: Clock-edge fine-grained timing attack in
JavaScript

2 Clock-edge attack
Web browser vendors have attempted to mitigate tim-
ing side channel attacks like [19] by rounding down the
explicit clocks available to JavaScript to some grain g.
For example, Google Chrome and Firefox have imple-
mented a 5µs grain. Figure 1 shows the C++ code
used for rounding a performance.now call in Google
Chrome. Tor Browser makes a different privacy and per-
formance tradeoff and has implemented an aggressive
100ms grain.

Unfortunately, rounding down does not the guarantee
that an attacker cannot accurately measure timing differ-
ences smaller than g. We present the clock-edge tech-
nique for improving the granularity of time measure-
ments in the context of JavaScript clocks. Experimen-

464  25th USENIX Security Symposium 

USENIX Association

USENIX Association  

25th USENIX Security Symposium  465

Figure3:Clock-edgelearningandtimingtally,thistechniqueresultsinanincreaseinresolutionofatleasttwoordersofmagnitudetolargegrainedclocks.Thistechniquecanbegeneralizedtoanypairofclocks:amajorclock,whichhasaknownlargeperiod,andaaminorclock,whichhasashortunknownperiod.Themajorclockisusedtoestablishtheperiodoftheminorclock,andtogethertheycantimeeventswithmoreaccu-racythanalone.ConsiderthecaseofapagewishingtotimesomeJavaScriptfunctionattack()withagranularitysmallerthansomeknownperformance.nowgraing.Themajorclockinthiscaseisthedegradedperformance.now,andweuseatightincrementingforloopastheminorclock.Figures2and3showhowapagemightexecutethistechniqueandavisualrepre-sentationoftheprocess.Thepagefirstlearnstheaveragenumberofloopiter-ations(Lexp)betweenthemajorclockticksCl1andCl2.Afterlearning,thepagethenrunsuntilamajorclockedgeisdetected(Cstart)andthenexecutesattack().Whenattack()returnsatmajorclocktimeCstop,thepagerunstheminorclock(forLremainticks)untilthenextmajorclockedge(Cpost)isdetected.Thepagethencal-culatesthedurationofattack()as(Cstop−Cstart)+g∗(Lexp−Lremain)/(Lexp).Inthecaseofgnotremainingconstant,wescaletheLexpby(Cpost−Cstop)/(Cl2−Cl1)andsetg=Cpost−Cstop.Since(Lexp−Lremain)/(Lexp)representsafractionalportionofg,thedurationmeasurementcanplausiblyob-tainmeasurementsasfinegrainedasg/Lexp.Thus,aslongastheattackerhasaccesstoasuitableminorclock,thedegradationofamajorclocktogbyroundingdoesnotensureanattackercannotmeasureatagrainlessthang.Grain(ms)MinorMeasuredDurations(ms)None–0.0030.0300.2983.0330.00120.0020.0290.2993.1030.005940.0040.0320.3043.0310.011920.0030.0300.2982.9980.0816490.0030.0300.3033.0090.119650.0110.0270.2993.0061204700.0530.0380.2963.010101931510.1120.2080.3323.15910019282830.4360.4690.5603.33050096472651.0451.0761.2943.437Table1:Resultsforrunningtheclock-edgefine-grainedtimingattackagainstvariousgrainsettings.Averagesfor100runsshown.Table1showstheresultsofapplyingtheclock-edgetechniqueonadegradedperformance.nowmajorclockon4differenttargetsatdifferentgrains.Thecodeinfigure2isanabbreviatedversionofthetestingcode.Eachdurationcolumnrepresentsadifferentnumberofiterationsintheattack()function,whichisanemptyforloop.Theminortickscolumnindicatesthenumberofiterationsthelearningphasedetectedthateachma-jorticktakes.The“None”rowindicatestheruntimeofattackwithnoroundingenabled,andotherrowsin-dicatethedurationsmeasuredatdifferentgrainsettingsusingtheclock-edgetechnique.Measurementswereper-formedwithamodifiedbuildofFirefoxthatenabledset-tingarbitrarygrainsviaJavaScript.Astable1shows,theclock-edgeattackrecoversdu-rationssignificantlysmallerthanthegrainsettings.No-tably,grainsinthemillisecondandhigherrangestillper-mitthedifferentiationofeventslastingonlytensofµs!Simplyroundingdowntheavailableexplicitclocksonlyhasanotableimpactiftheattackerisattemptingtodifferentiatebetweeneventseachlastinglessthanamicrosecond,atwhichleveltheclock-edgeattackoftenprovidesnoadditionalresolutiontotheroundedclock.3Measuringtimeinbrowserswithoutex-plicitclocksInthissection,wedemonstratedifferentmethodsanattackercanusemeasurethedurationofeventsinJavaScript.Anattackerwishingtomountatimingat-tackagainstawebbrowserisnotrestrictedtotheuseofperformance.nowfortimingmeasurements,thissectionwillpresentanumberofalternativemethodsavailable.Browserfeaturesthatenablethesemeasure-mentsareimplicitclocks.Dependingonthehowthetar-getandtheclockinteractwiththeJavaScriptruntime,wedefinethemasexitingorexitless.Wedonotpresentanexhaustivelistofimplicitclocks.Rather,thissectionshould be considered the tip of the iceberg for clock tech-
niques in browsers.
3.1 Measurement targets
Recall that the adversary’s goal in a timing attack is to
measure the duration of some event and differentiate be-
tween two or more possible executions. We assume our
adversary’s goal is to measure the duration of some piece
of JavaScript target() or to measure the time until
some event target fires a callback. There are many
potential targets, exemplified by two different timing at-
tacks on web browsers. We categorize targets and attacks
into exiting and exitless and describe a canonical exam-
ple for each.
3.1.1 Exiting targets:

privacy breaches with

requestAnimationFrame

Previous work [1] [24] has shown several different ways
to achieve history sniffing or cross frame pixel reading
via timing the rendering of an SVG filter over secret data.
Andrysco et al [1] demonstrate a timing attack on privacy
that differentiates pixels based on how long rendering an
SVG convolution filter takes. This timing requires that
the attacking JavaScript know exactly when the SVG fil-
ter is applied to the target and when the SVG filter fin-
ishes rendering. This is accomplished by sampling a high
resolution time stamp (performance.now) when ap-
plying the CSS style containing the filter and when a
callback for requestAnimationFrame fires. In this
case, JavaScript must exit to allow some other computa-
tion to occur and then receives a notification via a call-
back that the event has completed. We refer to this type
of target as an exiting target, as it exits the JavaScript
runtime before completion.
3.1.2 Exitless targets: cache timing attacks from

JavaScript

Conversely, there are exitless targets, such as Oren et
al’s [19] cache timing attack. This attack does not need to
exit JavaScript for the target to run, instead they need
only perform some synchronous JavaScript function call,
and measure the duration of it. Any exitless target
can be scheduled in callbacks, thus making it an exiting
target, but an exiting target cannot be run in an
exitless manner.
3.2
Supposing that all explicit clocks were removed from the
browser, it is still possible that a motivated attacker can
measure fine-grained durations. Rather than query an ex-
plicit clock, the attacker can find some other feature of
the browser that has a known or definable execution time
and use that as an implicit clock.

Implicit clocks in browsers

We did not test any clocks that resolve durations at an
external observer, such as a cooperating server. For ex-

Description

Explicit clocks
Video frames
Video played
WebSpeech API
setTimeout
CSS Animations
WebVTT API
Rate-limited server

Clock type
Firefox Chrome

Safari

L
L
X
L
X
X
X
X

L
L
L
+
X
X
X
X

L
L
L
—
X
X
X
X

Table 2: Implicit clock type in different browsers
L Exitless , X Exiting , — Not implemented, + Buggy

ample, a piece of JavaScript could generate a network
request, run a target, and then generate another net-
work request. These clocks are mitigated by the defenses
discussed in section 4.

We observe that just as with exiting and exitless
targets, there are exiting and exitless implicit clocks.
We will refer to a clock or timing method that does not
need to leave JavaScript execution for the value reported
by the clock to change as exitless. Similarly, a timing
method that requires JavaScript execution to exit before
time moves forward is exiting.

All exitless clocks can work for both exiting and ex-
itless targets. However, an exitless target cannot func-
tion with an exiting clock, as the execution of the tar-
get will take control of the main thread, stopping regular
callbacks or events that the exiting clock needs from fir-
ing. There may be exotic exiting clocks that do not have
this restriction, but all of the ones detailed below do. An
exitless attack requires using both an exitless target and
clock (such as in the cache timing attack.)

Depending on the implementation of a browser fea-
ture, the clock technique may be exiting or exitless. A
good example is the updating of the played informa-
tion for an <audio> or <video> tag. This information
is updated asynchronously to the main browser thread
in Google Chrome but will not update during JavaScript
execution in Firefox. Thus, it can be used to construct
a exitless clock in Chrome but only an exiting clock in
Firefox.

See table 2 for how the following clocks manifest in

Chrome 48 (stable), Firefox3, and Safari 9.0.3.
3.2.1 Exitless clocks
Since JavaScript is single threaded and non-preemptable,
exitless clocks do not have to worry about the scheduling
of other JavaScript callbacks or any other events occur-
ring between the target and timing measurements. By the
semantics of JavaScript, an exitless clock is considered a
run-to-completion violation[18] and is a bug. Any time
JavaScript can observe changes caused externally during

466  25th USENIX Security Symposium 

USENIX Association

a single callback qualifies as such a bug; it is only when
their timing is dependable that we can construct a clock.
Mozilla has explicitly stated their goal to make Spider-
Monkey (the Firefox JavaScript engine) free of run-to-
completion violations.

We found several exitless clocks available to

JavaScript in different browsers.

1. Explicit clock queries. While expected, explicit clock
queries are run-to-completion violations and expose
the most accurate timing data. performance.now
is the best source of explicit timing data in JavaScript.

2. Video frame data. By rendering a <video> to
<canvas>, JavaScript can recover the current video
frame. Since the video updates asynchronous to the
browser event loop, this can be used to get a fine
grained time-since-video-start value repeatedly.
On Firefox, video frame data updates at 60 FPS, giv-
ing a granularity of 17ms. We can load a video at
120FPS, which does not allow JavaScript access to
new frames faster, but the frames JavaScript gets are
a more accurate clock. We demonstrate this by gen-
erating a long-running video at 120FPS that changes
the color of the entire video every frame. Thus, by
sampling the current color via rendering the video to
<canvas>, the page can measure how much time
has elapsed since the video started. Video can be ren-
dered off-screen or otherwise invisible to the user and
will still update at 60FPS, making it an ideal choice
for an implicit clock. We have also found that using
multiple videos and averaging the reported time be-
tween them provides additional accuracy.

3. WebSpeech API. This can start/stop the speaking
of a phrase from JavaScript and will give a high-
resolution duration measurement when stopped.
The WebSpeech API allows JavaScript to define a
SpeechSynthesisUtterance, which contains
a phrase to speak.
This process can be started
with speak() and then stopped at any time with
cancel(). The cancelation can fire a callback
whose event contains a high resolution duration of
how long the system was speaking for. Thus, the
attacker can start a phrase, run some target JavaScript
function, and then cancel the phrase to obtain a timing
target. Note that while the callback must fire to get
the duration value, the duration measurement stops
when window.speechSynthesis.cancel()
is called, not when the callback eventually fires. This
makes the WebSpeech API a pseudo-exitless clock in
Firefox, even though we must technically wait for a
callback to get back the duration measurement. Time
moved forward, we just couldn’t observe repeatedly.
Since we can only measure the clock by stopping it,

the clock-edge technique cannot be used to enhance
the accuracy of the clock.
The WebSpeech API is only supported in Firefox
44+, and on many systems will need to be man-
ually enabled in about:config. Additionally,
unless the OS has speech synthesis support,
the
clock cannot be used as it will never start speak-
ing. Ubuntu can get this support by installing the
speech-dispatcher package.

4. SharedArrayBuffers. While we did not test these, as
the implementation is still ongoing, any sort of shared
memory between JavaScript instances constitutes an
exitless clock. As demonstrated in [23], this can be
used as a very precise clock in real attacks.

3.2.2 Exiting clocks
Exiting clocks are far more numerous but also signifi-
cantly less useful to an attacker, as their measurements
and target execution are unlikely to be continuous.

1. setTimeout. Set to fire every millisecond, these
then set a globally visible “time” variable when they
do. This is the most basic of the exiting clocks. We set
timeouts every millisecond as this is lowest resolution
that can be set.

2. CSS animations. Set to finish every millisecond, these
then set a globally visible “time” variable in their
completion callback. These behave almost identically
to setTimeouts and are measured in the same way.

3. WebVTT. This API can set subtitles for a <video>
with up to millisecond precision and check which
subtitles are currently displayed. The WebVTT in-
terface provides a way for <video> elements to
have subtitles or captions with the <track> element.
These captions are loaded from a specified VTT file,
which can specify arbitrary subtitles to appear for
unlimited duration with up to millisecond precision.
By setting a different subtitle to appear every mil-
lisecond,
the page can determine how much time
has elapsed since the video started by checking the
track.activeCues attribute of the <track> el-
ement. This only updates when JavaScript is not exe-
cuting.

4. A rate limited download. Using a cooperating server
to send a file to the page at a known rate causes reg-
ular progress updates to be queued in callbacks. Us-
ing the onprogress event for XMLHTTPRequests
(XHRs), the page can get a consistent stream of call-
backs to a clock update function. Note that the rate
of these callbacks is related to the size of the file be-
ing retrieved, as well as the upload rate of the server.

USENIX Association  

25th USENIX Security Symposium  467

468  25th USENIX Security Symposium 

USENIX Association

Figure4:WebVTTerrormeasurementswithandwithoutclock-edgetechniqueInourexperiments,weusedafile100mBinsize,withaserverratelimitedto100kB/susingtheLinuxutilitytrickle.Thepagethenassumesthattheserverissendingdataatexactly100kB/sandhasaninitiallearningperiodtodeterminetherateatwhichtheonprogresscallbacksfire.Afterthatiscom-plete,thepagecancontinuerunningasusual,withtheassumptionthatitnowhasaregularcallbackfir-ingatthecalculatedrate.Notethattheonprogresseventscanalsoberequestedtofireduringtheloadingof<video>elements.5.Video/audiotagplayeddata.Thesecontainthein-tervalsofthemediaobjectthathavethusfarbeenplayed.Bycheckingthefurthestplayedpointre-peatedly,wecanmeasurethedurationofevents.InFirefox,thisonlyupdatesafterJavaScriptexits,butinChrome,itupdatesasynchronously(makingitanexitlessclockforChrome).6.Cooperatingiframes/popupsfromsameorigin.Bycreatingapopupinthesameorigin,orbyembeddingiframesfromtheorigin,twopagescancooperateandactonthesameDOMelements.InourtestingtherewasnowaytogetexitlessDOMelementmanipula-tionsupdatesinthissituation.Thus,thiscasereducestothesetTimeoutcaseoranothersimilarmethod.Wedonotpresentanytimingresultsfortheseclocks.Critically,ifamethodofsharingDOMelementup-datesexitlesslywerefoundthiswouldbecomeanex-itlessclock.3.3PerformanceofimplicitclocksThegranularity,precision,andaccuracyofimplicitclocksvarieswidelybytechnique.WeobservethatFigure5:setTimeouterrormeasurementswithandwithoutclock-edgetechniqueFigure6:Videoframeerrormeasurementswithandwithoutclock-edgetechniquemostimplicitclockscanbeimprovedwiththeclock-edgetechniquefromsection2.Bysubstitutingtheperformance.nowmajorclockwiththeimplicitclocktechnique,andusingasuitableminorclock,mosttechniquesshowednotableimprovementsinaccuracy.Inthiscase,wewanttoexaminehoweasyitwouldbetodifferentiatetwodifferentdurationevents.Thus,tighterrorboundsthatareconsistentareideal.Applyingtheclock-edgetechniquetoexitlessclocksonlyrequiresthereplacementoftheexplicitperformance.nowcalltosomeotherexitlessclock;nochangetotheminorclockisneeded.Exitingclocksrequireanewminorclocktechnique;insteadofatightloop,theminorclockmustscheduleregulartimeoutsthatcheckthestateoftheimplicitmajorclock.Otherwise,theexitingmajorclockwouldnotchangeUSENIX Association  

25th USENIX Security Symposium  469

Figure7:ThrottledXMLHTTPRequesterrormeasure-mentswithandwithoutclock-edgetechniqueFigure8:CSSanimationerrormeasurementswithandwithoutclock-edgetechniquestatewhiletheminorclockisrunning.WhilerepeatedsetTimeoutcallswouldwork,setTimeoutof0isactuallya4mstimeoutpertheHTML5spec,makingitamajorclock.Instead,weuserepeatedpostMessagecallstothecurrentwindow.Theseexecuteatamuchhigherrate,buttheperiodisunknown.Thusthenewimplicitmajorclocknowhasafast,unknownperiodminorclock,justasintheexitlesscase.MeasurementsweredonewiththesameFirefoxasinsection2.Error(yvalues)wascalculatedasthedif-ferencebetweentheclocktechniquemeasurementandtheactualdurationasreportedbyperformance.now.Targetdurations(xvalues)aretheexpectedduration(Nmilliseconds)ofthetargetevent,whichmaydifferslightlyfromactualdurationduetosystemloadoreventheimplicitclocksthemselvesinterferinginthecaseofFigure9:WebSpeecherrormeasurementswithoutclock-edgetechniqueexitingclocks.Eachtargetwasmeasured100times,withmeasureddurationsof0orlessremoved.Whileactualdurationsvariedslightlyfromexpected,therewasnotconsiderablenoise.TheexitlesstargetwemeasureisaloopthatrunsforNmilliseconds,asdeterminedbyperformance.now.OurexitingtargetisasetTimeoutforNmilliseconds.Figures4,5,6,7,8,and9showtheclocktechniqueer-rorwithandwithoutclock-edgeimprovementsforavari-etyofclocktechniquesdescribedabove.WebSpeechhasnoclockedgedataforthereasonsdetailedin3.2.1.Notethatthey-axisdiffersperfigure,toallowforeasiercom-parisonbetweenclock-edgeandnon-clock-edgeresults.AscanbeseeninWebVTT,throttledXHRs,andvideoframedata,manyclocktechniqueshavealargenativepe-riodthattheyoperateat.Theselargeperiodsleaveplentyofspaceforclock-edgetoimproveaccuracy.WebVTTshowsmassiveimprovementintheclock-edgecaseduetotheprecisionofitsmajorclockticks;themoreprecisetheoriginaltechnique,themoreaccurateclock-edgecanbe.Figures11and10showthecomparisonoftheav-eragederrorforalltechniquesandalltechniqueswithclock-edgerespectively.Thecloseralineisto0onthesegraphs,themoreaccuratetheaveragedmeasure-mentswillbeforthattechnique.Again,theexceptionalaccuracyofWebVTTwithclock-edgeforlong-durationeventsisevident.4FermataInthissectionwedescribeFermata,atheoreticalbrowserdesignthatprovablydegradesallattackervisi-bleclocks.Sections5and6describeourprototypeim-plementation,Fuzzyfox,andanevaluation.Fermatais470  25th USENIX Security Symposium 

USENIX Association

Figure10:Averageerrorforallclocktechniqueswith-outclock-edgeFigure11:Averageerrorforallclocktechniqueswithclock-edgewhereavailableanadaptationofthefuzzytimeoperatingsystemscon-ceptdetailedin[10]towebbrowsers.SincebrowservendorshaveexpressedaninterestindegradingtimesourcesavailabletoJavaScript,wepresentFermataasadesignidealforabrowserthatwillprovablydegradeallclocks.Fermata’sgoalistopro-videtheattackerwithonlytimesourcesthatupdateataratesuchthatallpossibletimingsidechannelshaveaboundedmaximumbandwidth.Thisincludestheuseofalltheimplicitclocksdescribedinsection3aswellasanyothersuchclockunknowntous.4.1WhyFermata?WeproposeFermatabecausewebelievethatattemptingtoauditandsecureallpossiblechannelsinamodernwebbrowserisinfeasible.Theevaluationofaprovablese-curityfocusedmicrokernelfoundseveraltrickytimingchannels[3].Inthatcase,themicrokernelwasdesignedtobeauditedandalreadyhadanumberofconcernsac-countedfor;thisisnottrueinthecaseofamodernwebbrowser.Ratherthanallowanyunknownchanneltoleakdataarbitrarilyuntilfixed,Fermatarestrictsallknownandunknownchannelstoleakatorbelowatargetac-ceptablerate.Fermataproposesaprincipledalternativetothe“findandmitigateallclocks”methodologythatTorBrowserhasalreadybegun.RatherthanmanuallyexamineeveryDOMmanipulation,extension,ornewfeature,Fermatarequiresminimaldefinedinterfacesbetweenallcom-ponents.Byautomatedlyprovingthatallinformationpassesthroughtheseinterfacesandthatallsuchinter-facesaresubjecttothefuzzyingprocess,Fermatawilldrasticallyreducetheburdenofcodethatneedstobeex-amined.Thisisanalogoustoothersuchapproachesintheprogramminglanguagesandformalsoftwarecom-munity.Limitingthechannelbandwidthforanattackerleak-inginformationisnotacompletesolutiontotimingattacksonbrowsers,butitisarealisticone.Previ-ousattacksonhistorysniffing[1][24]haveconsistentlycroppedup.Theseprivacybreachesareonlyasvaluableastheamountofdatatheycancollect.Learningthatauserhasvisited2-3websitesisnotlikelytocreateauniqueprofileofthem.Learningtensofthousandsofwebsiteslikelywould[27].HistorysniffingattacksarethereforeclassifiedbasedonhowfasttheycanextractthevisitedstatusofaURL.Bylimitingtherateatwhichthisinformationcanleak,Fermatacanmakehistorysniffingimpractical.Asanexample,[27]indicatesthatanat-tackermayneedtosniffinexcessof10,000URLstocreateareasonablefingerprintforauser.Withanattacklike[24]theattackercanread60ormoreURLspersec-ond.Previousattacksnotutilizingtimingsidechannelsreadinexcessof30,000URLspersecond.WeexpectthatFermatawouldallowachannelband-widthof≤50bitspersecondinthegeneralcase,and≤10forsecuritycriticalworkflows.Theprotectionisevenstrongerthaninitiallyobvious,asattacksthatrelyonsmalltimingdifferencesareentirelyunusable.Onlyattacksthatcanscaletheirdetectionthresholdsup(forexample,Andryscoetal[1])canstillleakdata.Iftheat-tackreliesonasmall,inherentmicroarchitecturetiming,suchasOrenetal’s[19]cachetimingattack,whichmea-sureddifferencesaround100ns,thistimingdifferencemaynolongerbeperceptibleatall.Anadditionalben-efitisthatmanyoftheseattacksrequireintensivelearn-ingphases,duringwhichmanymeasurementsmustbetakentoestablishtimingprofiles.Fermatawouldforcethislearningphasetotakesignificantlylonger,addingto the time-per-bit of information extracted. From this
survey of previous attacks, we believe that a strong lim-
itation on channel bandwidth represents an powerful de-
fense against timing attacks in browsers.
4.2 Threat model
We define our attacker as the canonical web attacker who
legitimately controls some domain and server. They are
able to cause the victim to visit this page in Fermata
and run associated JavaScript. The attacker thus has two
viewpoints we must consider: any external server con-
trolled by the attacker and the JavaScript running in Fer-
mata.

The attacker in our case possesses a timing side-
channel vulnerability they wish to use on Fermata. The
specific form of the vulnerability does not matter, only
that it can be abstracted as a single JavaScript function
that is called either synchronously or asynchronously.
The attacker uses the duration of this function to derive
secret information about the victim, possibly repeatedly.
We do not present a solution for plugins like Adobe
Flash or Java applets. Significant changes to the runtime
of these plugins on-par with Fermata itself would need to
be made for them to be similarly resistant. Considering
the number of known vulnerabilities and privacy disclo-
sures in most of these plugins, we do not believe they
should be a part of a browser design focusing on secu-
rity and privacy. Alternatively, such plugins should be
disabled during sensitive work flows.

The attacker succeeds against Fermata if they are able
to extract bits using their side channel at a higher rate
than the maximum channel bandwidth.
4.3 Design goals and challenges for Fermata
Fermata must mediate the execution of JavaScript to re-
move all exitless clocks and degrade all exiting clocks.
This would include mediating and randomly delay-
ing all network I/O, local I/O, communication between
JavaScript instances (iframes, workers, etc), and commu-
nication to other processes (IPC). If Fermata were addi-
tionally able to make all DOM accesses by JavaScript
asynchronous and delay them in the same principled
fashion, this would accomplish our goals. The coupling
of JavaScript’s globally accessible variables to the DOM
represents the most significant challenge to such a de-
sign and presents a shared state problem not found in the
model for this work [10].

Given this shared state problem, Fermata has two op-
tions for JavaScript: redesign JavaScript execution to be
entirely asynchronous or degrade explicit clocks and me-
diate known APIs in a principled manner. The former
provides a formal guarantee but cannot be done in cur-
rent browser architectures. We explore options for the
latter later in this section and in Fuzzyfox.

4.4 Fermata guarantees
We believe that the analysis of Hu’s fuzzytime by Gray
in [5] applies to Fermata. The means that we can place
1
an upper bound on the leakage rate of Fermata at
g/2
symbols per second, assuming the median tick rate of g
2.
As in [5], we assume that increasing the size of the al-
phabet used will provide negligible benefits. Thus, this
bound is an upper bound for the bits-per-second leakage
rate of Fermata. We view the vulnerable functionality
targeted by the attacker in the strongest possible way:
the attacker has complete control over when and how it
leaks timing information. This is effectively the high/low
privilege covert channel scenario the fuzzytime disk con-
tention channel is analyzed under. Similarly, in Fermata,
the leaking feature may have access to the same fuzzy
clock as the attacker. This allows them to synchronize in-
stantly from “low to high” privilege as in the fuzzytime
analysis. Thus, the side channel threat model Fermata
operates under is a subset of the fuzzy time model.

There is further analysis of the capacity of covert chan-
nels with fuzzy time defenses in [6]. The general case
problem of covert channel capacity under fuzzy time ap-
pears to be intractable but can be bounded under specific
circumstances.
4.4.1 Transmitted bits vs information learned
Fermata makes a guarantee about the actual transmitted
bitrate of some side channel. This has obvious benefits in
the case of leaking a CSRF token or a cryptographic key:
the bits the attacker needs to learn equals the number of
bits in the key or token. However, this becomes trickier
to quantify with a goal like history sniffing where the
details of the side channel can influence what the attacker
learns with each leaked bit.

Consider a timing side channel that can indicate if a
single URL has been visited by the victim one at a time.
Each time the channel is used one bit of information
(visit status of the URL) is leaked. If the attacker wishes
to learn the visit status of 10,000 URLs they must check
each individually.

If instead a timing side channel could indicate if any
URLs from an arbitrary set were visited, the attacker
could use this along with prior knowledge that almost all
URLs have not been visited to learn about more URLs in
less bits. Given some set of 10,000 URLs, the side chan-
nel indicates that at least one was visited and then, in a
divide-and-conquer approach, the first half indicates that
none were visited. How many bits were leaked? Two
bits were transmitted: that some URLs were visited in
the 10,000, and that no URLs in the first 5,000 were vis-
ited. However, we have learned the visit status of 5,000
URLs. This is only possible because the attacker can as-
sume the majority of URLs are not visited.

We believe that Fermata’s guarantees still constitute a

USENIX Association  

25th USENIX Security Symposium  471

valuable defense against using timing side channels for
history sniffing. First, not all history sniffing side chan-
nels have allowed checking the visit status of batches of
URLs. In these cases Fermata limits learning the visit
status of each URL individually. Second, if the attacker
wishes to learn specific URLs from the browsing history
(ex: to launch a targeted phishing attack), rather than just
learn a rough fingerprint, they will still need to examine
each individual URL regardless of how the side channel
can operate.

Isolating JavaScript from the world

Fermata cannot provably prevent a timing side chan-
nel from operating; it can only constrain the rate of bits
transmitted across the channel. For any side channel it
is important to consider the attacker’s goals along with
how the side channel operates to understand what level
of mitigation Fermata will provide. There are multiple
reasons (compression, prior knowledge, etc.) that might
lead to a side channel exhibiting behavior like described
above. In all of these cases Fermata provides the same
guarantee about channel bandwidth.
4.5
A potential solution for JavaScript is to remove all
run-to-completion violations, effectively ensuring that
JavaScript cannot observe any state changes to the DOM
or otherwise during a single execution. This necessarily
includes all realtime clock accesses, as well as any
other discovered exitless clocks. Since JavaScript will
always have access to a fine grained minor clock (the
for loop), it is critical that all exitless major clocks be
removed. In the case of performance.now, this will
result in the feature becoming an exiting clock, requiring
that JavaScript stop execution before the available clock
value changes.

The catch of the latter method is in how to remove all
potential exitless clocks. If the upcoming SharedArray-
Buffer API becomes available, this presents a highly ac-
curate exitless clock that Fermata cannot mitigate with-
out returning it to a message passing interface. Remov-
ing all of these potential exitless clocks requires an ex-
amination of all interfaces the JavaScript runtime has.

With all exitless clocks removed, the design need only
focus on degrading exiting clocks to meet the target max-
imum channel bandwidth.
4.6 Degrading explicit clocks
Explicit clocks (ex: performance.now, Date, etc.)
are degraded to some granularity g and update unpre-
dictably. As in Hu [10], we accomplish this by perform-
ing updates to the clock value (at the granularity g) at
randomized intervals. g is a multiple of the native OS
time grain gn (generally 1ns). Each randomized inter-
val is a “tick,” during which the available explicit clocks
do not change. At the beginning of each tick, we up-

date the Fermata clock to the rounded-down wallclock.
Since the tick duration is not the same as g, the Fermata
clocks will not always change in value every tick. This
design guarantees that the available explicit clocks are
only ever behind and are behind by a bounded amount of
time, g−gn + (g/2). Note that a clock’s granularity does
not alone define the accuracy to which it can be used to
time some event, as seen with section 2.

Tick duration is not constant but is instead drawn from
a uniform distribution with a mean of g/2. If intervals
were constant and thus clock updates occurred exactly
on the grain, the attacker could use the same clock-edge
technique as in section 2.

4.7 Delaying events
The randomized update intervals (ticks) are further di-
vided into alternating upticks and downticks for the pur-
poses of delaying events and I/O. This mimics their usage
in Hu [10]. Downticks cause outbound queued events to
be flushed, and upticks cause inbound events to be deliv-
ered.

4.8 Tuning Fermata
Since the defensive guarantee provided by Fermata is
only a maximum channel bandwidth, a few users may
want to change the tradeoff between responsiveness and
privacy. Fermata will provide this option via a tunable
privacy setting that allows setting the acceptable leaking
channel bandwidth. In turn, this will modify the aver-
age tick duration and the explicit time granularity, both
of which affect usability. We expect that only developers
(including of browser forks like Tor Browser) or users
with specific privacy needs would interact with these set-
tings.
5 Fuzzyfox prototype implementation
In this section we describe Fuzzyfox4, a prototype imple-
menting many of the principles of the Fermata design in
Mozilla Firefox. Fuzzyfox is not a complete Fermata so-
lution but does show that the removal of exitless clocks
and the delaying of events is a feasible design strategy
for a browser.

Fuzzyfox attempts to mitigate the clocks of sections 2
and 3 by using the ideas in Fermata. Web browsers have
an interest in degrading clocks available to JavaScript to
reduce the impact of both known and unknown timing
channel attacks. Fuzzyfox is a concrete demonstration
of techniques that will make a browser more resistant to
such timing attacks. As in Fermata, Fuzzyfox has a clock
grain setting (g) and an average tick duration (ta = g/2).
All explicit clocks in Fuzzyfox report multiples of g.

We will refer to Firefox when discussing default be-
havior and Fuzzyfox when discussing the changes made.

472  25th USENIX Security Symposium 

USENIX Association

5.1 Why Fuzzyfox?
We built Fuzzyfox for three reasons:

1. Building a new web browser is a monumental task.
2. We did not know if a Fermata-style design would re-
sult in a usable experience. It was entirely possible
that the delays induced would render any Fermata-
style designs unusable.

3. We want to deploy the insights of channel bandwidth

mitigation to real systems like Tor Browser.

Fuzzyfox does not have the complete auditability ad-
vantages that Fermata would. However, we believe that
our insights about principled fuzzying of explicit clocks
can be directly applied to Tor Browser as an improve-
ment to their ongoing efforts.
5.2 PauseTask
The core of
the Fuzzyfox implementation is the
PauseTask, a recurring event on the main thread event
queue. The PauseTask provides two primary func-
tions:
it implicitly divides the execution of the event
queue into discrete intervals, and it serves as the arbiter
of uptick and downtick events.

Once Firefox has begun queuing events on the event
queue, Fuzzyfox ensures that the first PauseTask gets
added to the queue. From this point on, there will always
be exactly one PauseTask on the event queue.

PauseTask does the following on each execution:
determines remaining duration, generates retroactive
ticks, sleeps remaining duration, updates clocks, flushes
queues, and queues the next PauseTask.

Determine remaining duration
The PauseTask checks the current OS realtime clock
(T1) with microsecond accuracy using gettimeofday.
Comparing this against the expected time between ticks
(De) and the end of the last PauseTask (T2) gives the
actual duration (Da). If Da ≤ De, PauseTask skips di-
rectly to sleeping away the remaining duration, De − Da.
Optional: Retroactive ticks
Otherwise, PauseTask must retroactively generate the
upticks and downticks that should have occurred. This
ensures that even by being long running JavaScript can-
not force a 0 sleep duration PauseTask.

Sleep remaining duration
PauseTask finishes out
the remaining duration via
usleep. usleep is not perfectly accurate, and has a
fixed overhead cost. In our testing, usleep error varies
based on the duration but is never enough to be an issue
for Fuzzyfox.

Update all system clocks and flush queues
PauseTask now generates the new canonical system
time. This is accomplished by taking the OS realtime
clock and rounding down to the Fuzzyfox clock grain
setting.

There are two underlying explicit

time sources
available to JavaScript, Time and performance.
PauseTask directly updates the canonical TimeStamp
time, which is used by performance, and delivers a
message to the JavaScript runtimes to update Time’s
canonical time. Our review found that all of the other
time sources we knew of used TimeStamp.

In our prototype, the only I/O queue that needs to
be flushed is the DelayChannelQueue (see section 5.3.)
This only occurs if the currently executing PauseTask
is a downtick.
Queue next PauseTask event
Finally, PauseTask queues the next PauseTask on
the event queue. This sets the start time (T1), marks
the new PauseTask as either uptick or downtick, as
well as drawing a random duration from the uniformly
random distribution between 1 to 2× ta. PauseTasks
are queued exclusively on the main thread to ensure they
block JavaScript execution as well as all DOM manipu-
lation events.
5.3 Queuing
All events visible to JavaScript must be queued in Fuzzy-
fox. Unfortunately, there is not a singular place or even
explicit queues available for all events in Firefox. We
use PauseTask to create implicit queues for all main
thread events (including JavaScript callbacks, all DOM
manipulations, all animations, and others) and construct
our own queuing for network connections.
CSS

animations,
setTimeout, etc.)
do not need to be explicitly
modified from Firefox behavior, as they run in a separate
thread that checks when timers should fire based on
TimeStamp. As Fuzzyfox ensures all TimeStamps are
set to our canonical Fuzzyfox time, this is not a problem.
DelayChannelQueue
length
We
called
queue
DelayChannelQueue.
This queue contains any
channels that have started to open and stops them from
connecting to their external resource.
In the Fuzzyfox
prototype, we only queue outgoing HTTP requests,
although it could easily be extended to more channel
types. Upon receiving a downtick notification from
PauseTask,
the queue is locked and all currently
queued channel connections are completed and flushed
from the queue.

arbitrary
connections

simple
network

for

outgoing

implemented

a

Timer

events

(including

USENIX Association  

25th USENIX Security Symposium  473

474  25th USENIX Security Symposium 

USENIX Association

6FuzzyfoxevaluationWeevaluatedourprototypeFuzzyfoxinbotheffective-ness(howitdegradesclocks)andperformance.AllevaluationsarecomparedagainstacleanFirefoxbuildwithouttheFuzzyfoxpatches.Firefoxtrunk5wasusedasthebasisandbuiltwithdefaultbuildsettings.Fuzzyfoxpatchesarethenappliedontopofthiscom-mitandbuiltwiththesameconfiguration.AlltestswereperformedonanupdatedUbuntu14.04machinewithanInteli5-4460and14GBofRAM.TheonlyapplicationsrunningduringtestingweretheXFCEwindowmanagerandFuzzyfox.FuzzyfoxandFirefoxwerebothtestedusingtheexperimentale10sFirefoxarchitecture.NSPRloggingwasenabledtocapturedataaboutFuzzyfoxin-ternals.6.1LimitationsFuzzyfoxisnotacompleteFermataimplementationandisunabletoguaranteeamaximumchannelbandwidth.SincewedidnotisolatetheJavaScriptenginefromtheDOMorallI/Ooperations,wedidnotinterposeonallinterfacesaswouldberequiredinaFermataimplemen-tation.Thisispurelyapracticaldecision,asaccomplish-ingthisinFirefoxwouldrequiremanuallyauditingtheentirecodebase.Wedonot,forexample,interposeonsynchronousIPCcallsfromJavaScript.Seesection6.2.3foranexampleofhowthiscanbreaktheFermataguar-antees.Unfortunately,sinceourPauseTaskscanbedelayedbylongrunningJavaScriptonthemainthread,wecannolongerboundthedifferencebetweentheOSrealtimeclockandtheavailableexplicitclocks.Wedostillguar-anteethatallexplicitclocksareonlyeverbehindreal-time.Whileweexperimentedwithanumberofdifferentgrainsettings,thesettingsprovidingveryhighprivacyguarantees(100sofmilliseconds)havesevereusabilityimpact.WebelievethatacleanFermataimplementationmaynotincursuchastrongusabilityimpactatsimilargrainsettings.6.2EffectivenessEffectivenessismeasuredastheavailableresolutionforagivenclock.Intheidealcase,allclocksinFuzzyfoxshouldbedegradedprovidearesolutionnolessthang.Wemeasuretheobservedpropertiesoftheclocksde-scribedinsection3betweenFirefoxandFuzzyfox.Wesettheexplicittimegranularity(g)to100msandtheav-eragePauseTaskinterval(ta)to50msforthesetests.Wechoseg=100msbecausealargegvaluemostclearlyillustratesthedifferencebetweenFuzzyfoxandFirefox.Seesection6.3foranevaluationoftheimpactofhighgvaluesonperformance.ThefollowingfiguresshowscatterplotsforseveralFigure12:performance.nowmeasurementswithclock-edgeonFuzzyfox(exiting)andFirefox(exitless,100msgrain)Figure13:FramedataclockmeasurementsonFirefoxandFuzzyfoxclocktechniquesastheyoperateinFirefoxandinFuzzy-fox.Ineach,aperfectlyaccurateclockwouldfollowthedashedgreylineonx=y.Notethatthesefiguresshowactualdurationandclocktechniqueduration,ratherthantargetdurationanderrorasinsection3.3.ThisisduetoFuzzyfoxbeingunabletodependablyscheduletargetslessthang(100ms)induration.Thus,whilethesametestingcodewasusedinFuzzyfoxandinFirefox,theactualdurationsofeventsaremuchlongerinFuzzyfox.Finally,therearenoexitlessclocksthatweknowofinFuzzyfoxtotest,whichwouldhavebeenaclosercom-parison.6.2.1performance.nowSincetimenolongermovesforwardduringJavaScriptexecution,performance.nowisnowanexitingUSENIX Association  

25th USENIX Security Symposium  475

Figure14:WebVTTclockmeasurementsonFirefoxandFuzzyfoxclock.Figure12showstheresultsofusingtheclock-edgetechniqueonperformance.nowforbothFuzzyfoxandFirefoxwithagrainsetto100ms.Notably,clock-edgenolongerimprovestheaccuracyofthemea-surements!ThisdemonstratesthattheFuzzyfoxmodelsuccessfullydegradesexplicitclocks.6.2.2VideoframedataUnexpectedly,Fuzzyfoxtransformsthevideoframedataclockfromexitlesstoexiting.Thisisprobablybecausetheframeextractedforcanvasisdeterminedusingthecurrentexplicitclockvalues(TimeStamp.)SincetimedoesnotmoveforwardduringJavaScriptexecution,framedataisnowanexitingclock.Ingeneral,weexpectthatrun-to-completionviolations(andbyextensionmostexitlessclocks)wouldnotbeproperlydegradedbyFuzzyfox.Figure13showstheexitingframedataclockonFuzzyfoxandFirefox.6.2.3WebSpeechAPIFuzzyfoxdegradestheWebSpeechAPIonlybecausetheelapsedTimefieldisdrawnusingtheexplicitclocksinFuzzyfox.Thestartingandstoppingofthespeechisstillsynchronous,soitispossiblesomeotherpieceofinformationpassedbackbythespeechsynthesisprovidercouldprovideamoreaccurateclock.WebSpeechshouldnotbeconsideredproperlyisolatedbyFuzzyfox.OnlyifthestartingandstoppingofspeechsynthesiswerequeuedlikeothereventswouldFuzzyfoxcorrectlyhandleWebSpeech.6.2.4setTimeoutAssetTimeouteventsarefiredfromthetimerthreadbasedonthedegradedexplicitclocks,theyarenolongerabletofiremoreoftenthantheexplicittimegraingof100ms.Figure15:PageloadtimeswithvariabledepthforallFuzzyfoxconfigurationsataspreadof2varnjs=document.createElement(’script’)njs.setAttribute(’type’,’text/javascript’)njs.setAttribute(’src’,’layer2.js’)document.getElementsByTagName(’head’)[0].appendChild(njs)Figure16:IterativepageloadJavaScript6.2.5CSSAnimationsAswithsetTimeout,CSSanimationeventsarefiredfromthetimerthreadbasedonthedegradedexplicitclocks.Thus,theytooarenotabletobeusedasaclockoffinergrainthantheexplicittimegraing.6.2.6XMLHTTPRequestsXMLHTTPRequestsareproperlydegradedbyFuzzyfox.SincethecallbacksforonprogressarequeuedonthemaineventqueueandthengatedbyPauseTask,theyarenolongertimelywhenprocessed.6.2.7WebVTTsubtitlesWeexaminedtheWebVTTsubtitleimplicitexitingclockindetail,asitperformedamongthebestwiththeclock-edgetechniqueonvanillaFirefox.Figure14showstheresultsforthesameWebVTTclocktechniquesasde-scribedinsection3.2.2onbothFuzzyfoxandFirefox.NotethattheclockedgecodeprovidednobenefitstotheFuzzyfoxcase.6.3PerformancePerformanceimpactisdifficulttomeasure,asmostper-formancetoolsforbrowsersrelyonaccuratetimemea-surementsviaJavaScript.Weperformedaseriesofpageloadtimetests,whichshowpredictableresults.Wemeasuretheimpactofbothdepthofpageloadsandthespreadofinitialrequests.476  25th USENIX Security Symposium 

USENIX Association

Figure17:Pageloadtimeswithvariablespreadanddepthforg=100msFigure18:Pageloadtimeswithvariablespreadanddepthforg=5msOurtestingsetupconsistedof20testpagesand5dif-ferentfuzzyfox/Firefoxconfigurations.Thedepthofthetestpagesrepresentshowmanysequentialrequestsaremade.Eachrequestconsistsofinsertingascriptfileoftheforminfigure16.Eachonehastheloadedscriptbethenext“layer”down,withlayer0beinganemptyscript.Thus,atestpagethatis3deepmakes4sequentialrequests:page.html,layer2.js,layer1.js,layer0.js.Spreadisachievedbythebasepage.htmlperformingseveralduplicateinitialrequeststothetoplayer.Thus,aspreadof2andadepthof2resultsinrequestsfor:page.html,layer1.js,layer1.js,layer0.js,layer0.js.Afterthefi-nalpageloadcompletes,thetotaltimefrominitialpagenavigationuntilcompletionisstored,andthisprocessisrepeated1000timesperpagetest.Wegenerate20testpagesbycombiningupto5layersofdepthwithaspreadfrom1to5.Weservedthetestpagesviaabasicnginxconfigurationrunningonthesamehostasthebrowser.Figures15and17showtwodifferentviewsofsomeoftheresults,withthe95thpercentileofloadtimesbe-ingshownforg=100ms.Asexpected,increasingthespreadforagivendepth(asshowninfigure17)resultsinalmostnochangetoloadtimes.Allotherbrowserconfigurations(seefigure18forg=5ms)hadnearlyidenticalresults,withdifferingy-interceptsbasedong.ThisoccursbecauseoutgoingHTTPrequestsinFuzzy-foxarebatched,soqueuingmultiplerequestsatoncedoesnotincuranyg-scaledpenalties.However,asfigure15shows,increasingthedepthincursalinearoverheadwiththeslopeandinterceptscaledbythevalueofg.TheworstcaseforFuzzyfoxarepagesthatdolargenumbersofsequentialloads,eachrequiringJavaScripttorunbe-forethenextloadcanbequeued.Unfortunately,manymodernwebpagesendupperformingrepeatedloadsofvariouslibrariesandpartialcontent.Onepotentialsolu-tionwouldbemorewidespreaduseofHTTP2’sServerPushwhichwouldalleviatetherepeatedgscaledpenal-tiesforresourcerequests.JavaScriptenginetests,suchasJetStream,reportedidenticalscoresof181forbothFirefoxandFuzzyfox.6FuzzyfoxpredictablyrecordsamaximumFPSequaltotheaveragePauseTaskfirerateor20FPSforg=100ms,ascomparedto60FPSintheFirefoxcase.6.3.1TorBrowserWealsoranourpageloadtestsonvanillaTorBrowser7.Ratherthanaccessthepagesoverthelocalhostinterface,theyareaccessedovertheTornetwork.Nootherchangestothetestsetupweremade.Duetothemajorchangesinrouting,theloadtimesweobservedarefarmorevariablethanintheFirefoxorFuzzyfoxcaseandshownosignif-icanttrendsonthewhole.IfwecomparetherangeofpageloadtimesbetweenFuzzyfox(g=100ms)andTorBrowserinfigures19and20,weseethatTorBrowserimposesasignificantlyhigheroverheadmostofthetimeinbothinitialpageloadandinpageloadcompletion.Otherspreadlevelsshowsimilarbehavior.Asinpre-viousfiguresweshowthe95thpercentileloadcomple-tiontimesbutweadditionallyshowtherangefromtheminimumcompletion(onloadfires)timeasashadedregion.6.3.2RealworldpageloadsTable3showsaroughmacro-benchmarkofreal-worldpageloadtimesforFirefox,Fuzzyfox(variousgrains),andTorBrowser.Ineachcase,thesameGooglesearchresultspagewasloaded.Thesetestsweremanuallyper-formedandthereportedpageloadtimecomesfromtheFirefoxdevelopertools.EachloadrequestedbetweenUSENIX Association  

25th USENIX Security Symposium  477

Figure19:Rangeofpageloadcompletiontimeswithvariabledepthataspreadof0forTorBrowserandFuzzyfoxg=100msFigure20:Rangeofpageloadcompletiontimeswithvariabledepthataspreadof4forTorBrowserandFuzzyfoxg=100msBrowserorGrain(ms)Reportedloadtime(s)ReloadForceReloadFirefox0.820.860.50.840.7910.850.8550.940.94101.031.04502.091.711002.862.60Tor3.787.18Table3:Averagepageloadtimesforhttps://www.google.com/?gws_rd=ssl#q=test+searchwith10reloadsand10forcereloads(nocaching)onFirefox,Fuzzyfox,andTorBrowser9and12resources.The“forcereload”columncorre-spondstoacache-lessreloadofthepage,whereasthe“reload”columnindicatestheloadtimewithcachingal-lowed.Minordifferencesbetweenthereloadandforcereloadresultsforagivenbrowserarenotstatisticallysig-nificantasweonlyhave10samples.Whilealargerstudyofmorereal-worldpageswouldbevaluable,suchastudyislargerinscopethanthispapercancover.Toperformsuchameasurement,wewouldneedtoindividuallydeterminea“loadcomplete”pointforeachtestpageandre-instrumentFuzzyfoxtoenablemeasurementsattheseexactpoints.Googlesearchre-sultswerechosenspecificallybecausetheydonotcon-tinuetoloadresourcesindefinitelyasmanymajorweb-sitesdo.(Ex:nytimes.com,youtube.com,etc.)Wethereforeleaveamoredetailedreal-worldpageloadtimeanduserexperienceimpactstudytofuturework.Thesemetricsareincomplete,astheydonotmeasureinteractivityofthepages,whichcansufferintheFuzzy-foxcasemorethaninTorBrowser.Weleavefurtheranalysisofvariousperformanceimpactstofuturework.Whilehighergsettingscausesignificantpageloadtimeincreases,theseoverheadsareacceptabletosomeprivacyconscioususersanddevelopersasdemonstratedbyTorBrowser.WedonothavemetricsfortheimpactofusingbothTorBrowserandourFuzzyfoxpatchset,butweexpecttheoverheadstobeadditiveintheworstcase.OneoptionforintegrationwithTorBrowserspecificallywouldbetotunethevalueofgbasedonthesettingofthe“securityslider”[20].Inlightofthesemetrics,agsettingofg≤5msislikelytolerableforaverageusecases,whilehighersettings(uptoandincludingg=100ms)wouldlikelybetoleratedbyusersofTorBrowser.IdeallytheclockfuzzingandotherfeaturesasappropriatewillbedeployedinFirefox,andcanbeconfiguredforahigherginTorBrowser.IfamorecompleteversionofFermataisdeveloped,itwillbeworthwhiletorunuserstudiesbeforedeployinggset-tings.7RelatedworkPopekandKline[21]werethefirsttoobservethatthepresenceofclocksopenscovertchannels.Theysug-gestedthatvirtualmachinesbepresentedonlywithvir-tualclocks,not“arealtimemeasure.”Lipner[16]re-spondedthatkeepingvirtualmachinesfromcorrelatingvirtualtimetorealtimeisa“difficultproblem,”sincetimeis“theonesystem-wideresource[...]thatcanbeobservedinatleastacoarsewaybyeveryuserandev-eryprogram.”Lipnersuggested“randomizingtherela-tionofvirtualandrealtime”toaddnoisetothechannel.LipneralsoreportedprivatecommunicationfromSaltzerthat timing channels had been demonstrated in Multics
by mid-1975.

Digital’s VAX VMM Security Kernel project( initiated
in 1981 and canceled in 1990 before its evaluation at the
A1 level could be completed [12]) was the first system to
attempt to randomize the relationship of virtual and real
time. The VAX VMM Security Kernel team published
three important papers describing their system. The first,
by Karger et al. [11, 12], gave an overview of the system.
The second, by Wray [28], presented a theory of time
(“[w]e view the passage of time as being characterized
by a sequence of events which can be distinguished one
from another by an observer") and of timing channels
and is the source for our view, in this paper, of timing
channels as arising from the comparison of a reference
clock with a modulated clock. Wray noted that a process
that increments a variable in a loop can be used as a
clock. The third, by Hu [9, 10], described the VAX
VMM’s fuzzy time system and is the inspiration for
our paper.
(A 2012 retrospective [15], though not the
contemporaneous papers, reveals that the fuzzy time idea
was developed in collaboration with the National Secu-
rity Agency’s Robert Morris.) We describe many of the
details of the fuzzy time system elsewhere in the paper.
The 1992 journal version [9] of Hu’s paper gives a more
complete security analysis than does the 1991 conference
version [10]. In particular, it notes that fuzzy time would
be defeated if the VM could devote a processor thread to
incrementing a counter in memory shared with its other
processor threads. This attack did not affect the Vax
VMM Security Kernel, since it limited virtual machines
to a single processor and did not support shared mem-
ory; it would apply to browsers if the proposed Shared
Memory and Atomics specification [8] is implemented.
Several followup papers examined the security of
fuzzy time. Trostle [25] observed that if scheduler
time quanta coincide with upticks and if the scheduler
employs a simple FIFO policy, then the scheduler can be
used as a covert channel with 50 bps channel capacity.
To send a bit, a high process either takes its entire time
quantum or yields the processor; low processes try to
send messages to each other in each time quantum.
Which and how many messages arrived reveals the
high process’ bit. Gray showed attacks on fuzzy time
that exploit bus contention [7] and calculated a channel
capacity for shared buses under fuzzy time under the
assumption (satisfied in the case of the VAX VMM
Security Kernel) that a low receiver can immediately
notify the high sender when it receives an uptick [5]. A
later tech report combines both papers by Gray [6].

Martin et al. [17] translated fuzzy time to the mi-
croarchitectural setting, proposing and evaluating a new
microarchitecture in which execution is divided into
variable-length “epochs.” The rdtsc instruction delays

execution until the next epoch and returns a cycle count
randomly chosen from the last epoch. Because their fo-
cus is microarchitectural timing channels, Martin et al.
argue that other sources of time, such as interrupt deliv-
ery, are inherently too coarse grained to need fuzzing.
Martin et al. observe that simply rounding rdtsc to
some granularity would be susceptible to clock-edge ef-
fects.

The success of

infrastructure-as-a-service cloud
computing brought with it the risk of cross-VM side
channels [22]. Aviram et al. [2] proposed to close timing
channels in cloud computing by enforcing deterministic
execution and experimented with compiling a Linux
kernel and userland not to use high-resolution timers
like rdtsc, observing a drop in throughput. Vattikonda
et al. [26] showed that it is possible to virtualize rdtsc
for Xen guests, reducing its resolution (but allowing
clock-edge attacks). Ford [4] proposed timing infor-
mation flow control, or TIFC, “an extension of DIFC
for reasoning about [. . . ]
the propagation of sensitive
information into, out of, or within a software system
via timing channels,” and proposed two mechanisms
for implementing TIFC: deterministic execution and
“pacing queues,” which are an extension of the VAX
VMM Security Kernel’s interrupt queue mechanism.

Li et al. [13, 14] describe StopWatch, a virtual ma-
chine manager designed to defeat timing side channel
attacks. In StopWatch, clocks are virtualized to “a de-
terministic function of the VM’s instructions executed so
far”; multiple replicas of each VM are run in lockstep,
and I/O timing for all of them is determined by the (vir-
tual) time observed by the median replica.

Finally, Wu et Al. [29] present Deterland, a hypervisor
that runs legacy operating systems deterministically. De-
terland splits time into ticks and allows I/O only on tick
boundaries. As in StopWatch, virtual time in Deterland
is a function of the number of instructions executed.

8 Conclusions and future work
Restricting or removing timing side channels is a com-
plex task. Simple degradation of available explicit clocks
is an insufficient solution, allowing clock-edge tech-
niques and implicit clocks to obtain additional timing in-
formation.

By drawing upon the lessons learned from trusted op-
erating systems literature, we believe that browsers can
be architected to mitigate all possible timing side chan-
nels. We propose Fermata as a design goal for such a
verifiably resistant browser. Our Fuzzyfox patches to
Firefox show that a Fermata-like design can intelligently
make tradeoffs between performance and security, while
not breaking the current interactions with JavaScript.
Fuzzyfox empirically degrades clocks in a way that is

478  25th USENIX Security Symposium 

USENIX Association

not susceptible to clock-edge techniques, protecting tim-
ing information.

Fuzzyfox requires a number of engineering improve-
ments before it is ready to deploy to users, but it has
proved that the fuzzy time concept can be applied to
browsers. Notably, more experiments with setting chan-
nel bandwidth and exposing such settings to users need to
be performed. Additionally, Fuzzyfox does not hook in-
bound network events, which a cooperating server could
use to derive the duration of events in Fuzzyfox. Other
interfaces (WebSockets, WebAudio, other media APIs)
should be investigated for behavior that would break the
Fuzzyfox design. We expect that with these changes
Fuzzyfox could be adapted for use in projects like Tor
Browser and protect real users against timing attacks.
Acknowledgements
We thank Kyle Huey, Patrick McManus, Eric Rescorla,
and Martin Thomson at Mozilla for helpful discussions
about this work, and for sharing their insights with us
about Firefox internals. We are also grateful to Keaton
Mowery and Mike Perry for helpful discussions, and
to our anonymous reviewers and to David Wagner, our
shepherd, for their detailed comments.

We additionally thank Nina Chen for assistance with

editing and graph design.

This material

is based upon work supported by
the National Science Foundation under Grants No.
1228967 and 1514435, and by a gift from Mozilla.
References
[1] M. Andrysco, D. Kohlbrenner, K. Mowery, R. Jhala,
S. Lerner, and H. Shacham, “On subnormal floating
point and abnormal timing,” in Proceedings of IEEE
Security and Privacy (“Oakland”) 2015, L. Bauer and
IEEE Computer Society, May 2015.
V. Shmatikov, Eds.

[2] A. Aviram, S. Hu, B. Ford, and R. Gummadi, “Determi-
nating timing channels in compute clouds,” in Proceed-
ings of CCSW 2010, A. Perrig and R. Sion, Eds. ACM
Press, Oct. 2010.

[3] D. Cock, Q. Ge, T. Murray, and G. Heiser, “The last mile:
An empirical study of timing channels on seL4,” in Pro-
ceedings of CCS 2014, M. Yung and N. Li, Eds. ACM
Press, Nov. 2014, pp. 570–81.

[4] B. Ford, “Plugging side-channel leaks with timing infor-
mation flow control,” in Proceedings of HotCloud 2012,
R. Fonseca and D. Maltz, Eds. USENIX, Jun. 2012.

[5] J. W. Gray, “On analyzing the bus-contention channel un-
der fuzzy time,” in Proceedings of CSFW 1993, C. Mead-
ows, Ed.

IEEE Computer Society, Jun. 1993, pp. 3–9.

[6] ——, “Countermeasures and tradeoffs for a class of
covert timing channels,” Hong Kong University of Sci-
ence and Technology, Tech. Rep. HKUST-CS94-18,
1994, online: http://hdl.handle.net/1783.1/25.

[7] ——, “On introducing noise into the bus-contention
channel,” in Proceedings of IEEE Security and Privacy
(“Oakland”) 1993, R. Kemmerer and J. Rushby, Eds.
IEEE Computer Society, May 1993, pp. 90–98.

[8] L. T. Hansen, “ECMAScript shared memory and atom-
ics,” Online: http://tc39.github.io/ecmascript_sharedm
em/shmem.html, Feb. 2016.

[9] W.-M. Hu, “Reducing timing channels with fuzzy time,”
J. Computer Security, vol. 1, no. 3-4, pp. 233–54, 1992.

[10] ——, “Reducing timing channels with fuzzy time,” in
Proceedings of IEEE Security and Privacy (“Oakland”)
1991, T. F. Lunt and J. McLean, Eds.
IEEE Computer
Society, May 1991, pp. 8–20.

[11] P. A. Karger, M. E. Zurko, D. W. Bonin, A. H. Mason,
and C. E. Kahn, “A VMM security kernel for the VAX ar-
chitecture,” in Proceedings of IEEE Security and Privacy
(“Oakland”) 1990, D. M. Cooper and T. F. Lunt, Eds.
IEEE Computer Society, May 1990, pp. 2–19.

[12] ——, “A retrospective on the VAX VMM security ker-
nel,” IEEE Trans. Software Engineering, vol. 17, no. 11,
pp. 1147–65, Nov. 1991.

[13] P. Li, D. Gao, and M. K. Reiter, “Mitigating access-driven
timing channels in clouds using StopWatch,” in Proceed-
IEEE/IFIP, Jun. 2013.
ings of DSN 2013, G. Candea, Ed.

[14] ——, “StopWatch: A cloud architecture for timing chan-
nel mitigation,” ACM Trans. Info. & System Security,
vol. 17, no. 2, Nov. 2014.

[15] S. Lipner, T. Jaeger, and M. E. Zurko, “Lessons from
VAX/SVS for high-assurance VM systems,” IEEE Secu-
rity & Privacy, vol. 10, no. 6, pp. 26–35, Nov.–Dec. 2012.

[16] S. B. Lipner, “A comment on the confinement problem,”
ACM SIGOPS Operating Systems Review, vol. 9, no. 5,
pp. 192–96, Nov. 1975.

[17] R. Martin, J. Demme, and S. Sethumadhavan, “Time-
Warp: Rethinking timekeeping and performance moni-
toring mechanisms to mitigate side-channel attacks,” in
Proceedings of ISCA 2012, J. Torrellas, Ed. ACM Press,
Jun. 2012, pp. 118–29.

[18] Mozilla, “Javascript concurrency model and event loop,”
2016, online: https://developer.mozilla.org/en-US/docs/
Web/JavaScript/EventLoop#Run-to-completion.

[19] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D.
Keromytis, “The spy in the sandbox: Practical cache at-
tacks in JavaScript and their implications,” in Proceed-
ings of CCS 2015, C. Kruegel and N. Li, Eds. ACM
Press, Oct. 2015.

[20] M. Perry, “Tor browser 4.5 is released,” Apr. 2015, online:
https://blog.torproject.org/blog/tor-browser-45-released.

USENIX Association  

25th USENIX Security Symposium  479

[21] G. J. Popek and C. S. Kline, “Verifiable secure operating
system software,” in Proceedings of the May 6-10, 1974,
National Computer Conference and Exposition. ACM,
May 1974, pp. 145–51.

[22] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage,
“Hey, you, get off of my cloud! Exploring information
leakage in third-party compute clouds,” in Proceedings of
CCS 2009, S. Jha and A. Keromytis, Eds. ACM Press,
Nov. 2009, pp. 199–212.

[23] M. Seaborn, “Security: Chrome provides high-res timers
which allow cache side channel attacks,” 2015, on-
line: https://bugs.chromium.org/p/chromium/issues/deta
il?id=508166.

[24] P. Stone, “Pixel perfect timing attacks with HTML5,” Pre-
sented at Black Hat 2013, Jul. 2013, online: http://contex
tis.co.uk/documents/2/Browser_Timing_Attacks.pdf.

[25] J. T. Trostle, “Modelling a fuzzy time system,” in Pro-
ceedings of IEEE Security and Privacy (“Oakland”)
1993, R. Kemmerer and J. Rushby, Eds.
IEEE Com-
puter Society, May 1993, pp. 82–89.

[26] B. C. Vattikonda, S. Das, and H. Shacham, “Eliminating
fine grained timers in Xen (short paper),” in Proceedings
of CCSW 2011, T. Ristenpart and C. Cachin, Eds. ACM
Press, Oct. 2011.

[27] G. Wondracek, T. Holz, E. Kirda, and C. Kruegel, “A
practical attack to de-anonymize social network users,”
in Security and Privacy (SP), 2010 IEEE Symposium on.
IEEE, 2010, pp. 223–238.

[28] J. C. Wray, “An analysis of covert timing channels,” in
Proceedings of IEEE Security and Privacy (“Oakland”)

1991, T. F. Lunt and J. McLean, Eds.
Society, May 1991, pp. 2–7.

IEEE Computer

[29] W. Wu, E. Zhai, D. I. Wolinsky, B. Ford, L. Gu, and
D. Jackowitz, “Warding off timing attacks in Deterland,”
in Proceedings of TRIOS 2015, L. Shrira, Ed.
ACM
Press, Oct. 2015.

Notes

1https://bugzilla.mozilla.org/
show_bug.cgi?id=711043
2https://trac.torproject.org/projects/
tor/ticket/1517
3commit 0ec3174fe63d8139f842ce9eb6639349759ff4e5
4Fuzzyfox is available as a branch at https://gi
thub.com/dkohlbre/gecko-dev.
It should be
treated as an engineering prototype.
5Firefox
done
0ec3174fe63d8139f842ce9eb6639349759ff4e5
for
c4afaf3404986ccc1d221bc7f4f3f1dcf39b06fc
the page load tests
6Fuzzyfox
valid
performance.now results for performance test-
ing
7Tor
b60b8871fa08feaaca24bcf6dff43df0cd1c5f29
fied to report accurate performance.now values

revision:
modi-

was modified

to

report

with

commit

tests

were

Browser

git

clock

tests,

and
for

480  25th USENIX Security Symposium 

USENIX Association

