2014 IEEE Symposium on Security and Privacy

Analyzing Forged SSL Certiﬁcates in the Wild

Lin-Shung Huang∗, Alex Rice†, Erling Ellingsen†, Collin Jackson∗

∗Carnegie Mellon University, {linshung.huang, collin.jackson}@sv.cmu.edu

†Facebook, {arice, erling}@fb.com

the attacker’s certiﬁcates were signed by trusted CAs, standard
browsers cannot simply distinguish the attacker’s intercepting
server from the legitimate server (unless the forged certiﬁcate
is later revoked). Hypothetically [9], some governments may
also compel CAs to issue trusted SSL certiﬁcates for spying
purposes without the website’s consent.

Abstract—The SSL man-in-the-middle attack uses forged SSL
certiﬁcates to intercept encrypted connections between clients
and servers. However, due to a lack of reliable indicators, it is
still unclear how commonplace these attacks occur in the wild. In
this work, we have designed and implemented a method to detect
the occurrence of SSL man-in-the-middle attack on a top global
website, Facebook. Over 3 million real-world SSL connections
to this website were analyzed. Our results indicate that 0.2%
of the SSL connections analyzed were tampered with forged
SSL certiﬁcates, most of them related to antivirus software and
corporate-scale content ﬁlters. We have also identiﬁed some SSL
connections intercepted by malware. Limitations of the method
and possible defenses to such attacks are also discussed.
Keywords-SSL; certiﬁcates; man-in-the-middle attack;

I. INTRODUCTION

Secure Socket Layer (SSL) [1], or its successor, Transport
Layer Security (TLS) [2], is an encryption protocol designed
to provide secure communication and data transfers over the
Internet.1 SSL allows clients to authenticate the identity of
servers by verifying their X.509 [3] digital certiﬁcates, and
reject connections if the server’s certiﬁcate is not issued by
a trusted certiﬁcate authority (CA). SSL is most popular for
enabling the encryption of HTTP trafﬁc between websites
and browsers, but also widely used for other applications
such as instant messaging and email transfers. An SSL man-
in-the-middle attack is an interception of such an encrypted
connection between a client and a server where the attacker
impersonates the server through a forged SSL certiﬁcate —
that is, an SSL certiﬁcate not provided or authorized by the
legitimate owner. We explain how this is possible below.

In practice, certiﬁcates issued through hundreds [4] of
CAs are automatically trusted by modern browsers and client
operating systems. Under the current X.509 public key in-
frastructure, every single CA has the ability to issue trusted
certiﬁcates to any website on the Internet. Therefore, CAs must
ensure that trusted certiﬁcates are only issued to the legitimate
owners of each website (by certifying the real identities of
their customers). However, if any of the trusted CAs suffers a
security breach, then it is possible for attackers to obtain forged
CA certiﬁcates for any desired website. In other words, a
single CA failure would allow the attacker to intercept all SSL
connections on the Internet. In fact, multiple commercial CAs
(DigiNotar [5], Comodo [6], and TURKTRUST [7]) have been
found to mis-issue fraudulent certiﬁcates in the past. Some of
these CA incidents actually resulted in real man-in-the-middle
attacks against high-proﬁle websites such as Google [8]. Since

1For brevity, we refer to SSL/TLS as SSL in this paper.

© 2014, Lin-Shung Huang. Under license to IEEE.
DOI 10.1109/SP.2014.13

83

Furthermore, even if the attacker cannot obtain a trusted
certiﬁcate of legitimate websites, it is still possible to intercept
SSL connections against some users (that ignore browser secu-
rity warnings). Historically, browsers tend to behave leniently
when encountering errors during SSL certiﬁcate validation,
and still allow users to proceed over a potentially insecure
connection. One could argue that certiﬁcate warnings are
mostly caused by server mis-conﬁgurations (e.g. certiﬁcate
expirations) rather than real attacks, therefore browsers should
let users determine whether they should dismiss the errors.
However, designing an effective security warning dialog has
been a challenging task for browser vendors. A number of
usability studies [10], [11], [12], [13] have shown that many
users actually ignore SSL certiﬁcate warnings. Note that
users who incautiously ignore certiﬁcate warnings would be
vulnerable to the simplest SSL interception attacks (using self-
signed certiﬁcates).

Despite that SSL man-in-the-middle attack attempts have
previously been observed in the wild (e.g. in Iran [8] and
Syria [14]), it is unclear how prevalent these attacks actually
are. Several existing SSL surveys [4], [15], [16], [17] have
collected large amounts of SSL certiﬁcates via scanning public
websites or monitoring SSL trafﬁc on institutional networks,
yet no signiﬁcant data on forged SSL certiﬁcates have been
publicly available. We hypothesize that real attackers are
more likely to perform only highly targeted attacks at certain
geographical locations, or on a small number of high-value
sessions, therefore, previous methodologies would not be able
to detect these attacks effectively.

Unfortunately, detecting SSL man-in-the-middle attacks
from the website’s perspective, on a large and diverse set
of clients, is not a trivial task. Since most users do not use
client certiﬁcates, servers cannot simply rely on SSL client
authentication to distinguish legitimate clients from attackers.
Furthermore, there is currently no way for a web application
to check the certiﬁcate validation status of the underlying SSL
connection, not even when an SSL error has occurred on the
client. Also, it is currently not possible for web applications
to directly access the SSL handshake with native browser
networking APIs, like XMLHttpRequest and WebSockets, to
validate SSL certiﬁcates on their own.

In this paper, we ﬁrst introduce a practical method for
websites to detect SSL man-in-the-middle attacks in a large
scale, without alterations on the client’s end (e.g. custom
browsers). We utilized the widely-supported Flash Player
plugin to enable socket functionalities not natively present in
current browsers, and implemented a partial SSL handshake
on our own to capture forged certiﬁcates. We deployed this
detection mechanism on an Alexa top 10 website, Facebook,
which terminates connections through a diverse set of network
operators across the world. We analyzed 3, 447, 719 real-world
SSL connections and successfully discovered at least 6, 845
(0.2%) of them were forged SSL certiﬁcates.

Our contributions can be summarized as follows:
• We designed a novel method for websites to collect
direct evidence of man-in-the-middle attacks against their
SSL connections. We further implemented this detection
method on Facebook’s website.

• We conducted the ﬁrst analysis on forged SSL certiﬁcates
by measuring over 3 million SSL connections. Our results
show that 0.2% SSL connections are in fact tampered
with forged certiﬁcates.

• Based real-world data, we categorized the root causes
of forged SSL certiﬁcates. We showed that most of
the SSL interceptions are due to antivirus software and
organization-scale content ﬁlters.

• We provided evidence of SSL interceptions by malware,

which have infected users across at least 45 countries.

The rest of this paper is organized as follows. Section II
provides background information and surveys related work.
Section III details the design, implementation, and experimen-
tation of our plugin-based detection method. Section IV gives
an analysis of the forged SSL certiﬁcates that were observed.
Section V surveys possible mitigations. Section VI concludes.

II. BACKGROUND

In this section, we provide an overview of the SSL protocol,
and how the SSL man-in-the-middle attack works. We then
survey related work, and discuss existing tamper detection
techniques that may be used by websites to detect network
interceptions.

A. The SSL Protocol

The Secure Socket Layer (SSL) protocol was designed
to ensure secure communications between two entities over
untrusted networks. The SSL protocol provides authentication
based on the X.509 public key infrastructure, protects data
conﬁdentiality using symmetric encryption, and ensures data
integrity with cryptographic message digests. SSL is com-
monly used for securing websites and mail servers, preventing
passive network attackers from eavesdropping or replaying the
client’s messages, and is generally considered security best
practice for websites. By enabling encryption, websites can
easily prevent the eavesdropping of unencrypted conﬁdential
data (e.g. Firesheep [18]).

To establish an SSL connection, the client and the server
performs a handshake to authenticate each other, and negotiate

84

Fig. 1. A basic SSL handshake with no client certiﬁcates

the cipher algorithms and parameters to be used. Figure 1
depicts a basic SSL handshake using the RSA key exchange
with no client certiﬁcates. First, the client sends a ClientHello
message to the server, which speciﬁes a list of supported
cipher suites and a client-generated random number. Second,
the server responds with the ServerHello message which
contains the server-chosen cipher suite and a server-generated
random number. In addition, the Certiﬁcate message contains
the server’s public key and hostname, digitally signed by
a certiﬁcate authority, in which the client is responsible of
verifying. The client then encrypts the pre-master secret using
the server’s public key and sends the pre-master secret to the
server over a ClientKeyExchange message. Both the client
and server can hence derive the same session key from the
pre-master secret and random numbers. Finally,
the client
and server exchanges ChangeCipherSpec messages to notify
each other that subsequent application data within the current
session will be encrypted using the derived session key.

As mentioned in Section I, the SSL protocol allows clients
to authenticate the identity of servers by verifying their SSL
certiﬁcates. In practice, commercial SSL certiﬁcates are often
signed by intermediate CAs (a delegated certiﬁcate signer),
instead of directly signed by a trusted root CA (which are kept
ofﬂine to reduce the risk of being compromised). Therefore,
the server’s Certiﬁcate message normally includes a chain
of certiﬁcates, consisting of one leaf certiﬁcate (to identify
the server itself), and one or more intermediate certiﬁcates (to
identify the intermediate CAs). Each certiﬁcate is cryptograph-
ically signed by the entity of the next certiﬁcate in the chain,
and so on. A valid certiﬁcate chain must chain up to a root
CA that is trusted by the client. Note that SSL certiﬁcates are
by design transferred in plaintext since the integrity can be
veriﬁed by signatures. It is critical that clients must validate
every certiﬁcate in the chain. In the following section, we will
explain why validating SSL server certiﬁcates is necessary.

B. The SSL Man-in-the-Middle Attack

The SSL man-in-the-middle (MITM) attack is a form of
active network interception where the attacker inserts itself
into the communication channel between the victim client and

Browser HTTPS server ClientHello ServerHello, Certificateserver, ServerHelloDone ClientKeyExchange, ChangeCipherSpec, Finished ChangeCipherSpec, Finished between them (decrypting messages from the client, and
then re-encrypting them before sending to the server).
Now, the attacker can read and even modify the en-
crypted messages between the client and the server.

As soon as the client accepts the forged SSL certiﬁcate, the
client’s secrets will be encrypted with the attacker’s public key,
which can be decrypted by the attacker. Note that regardless of
whether the attacker’s forged certiﬁcate is issued by a trusted
CA, the attack steps are the same. If one of the client’s trusted
CAs went rogue or was otherwise coerced [9] into issuing
a certiﬁcate for the attacker, the browser will automatically
accept the forged certiﬁcate. In fact, professional attackers
have proven capable of compromising CAs themselves in
order to obtain valid certiﬁcates, as has occurred during the
security breaches of DigiNotar [5] and Comodo [6]. Moreover,
even if the attacker does not have a trusted certiﬁcate of the
victim server and uses a self-signed certiﬁcate, researchers
have shown that many users ignore SSL certiﬁcate warnings
presented by the browser [11]. Even worse, studies have
discovered that some non-browser software and native mobile
applications actually contain faulty SSL certiﬁcate validation
code, which silently accepts invalid certiﬁcates [20], [21], [22].
Lastly, numerous automated tools that can mount SSL man-
in-the-middle attacks are publicly available on the Internet
(e.g. sslsniff [23]), which greatly reduce the level of technical
sophistication necessary to mount such attacks.

C. Certiﬁcate Observatories

A number of SSL server surveys [4], [15], [16], [17] have
analyzed SSL certiﬁcates and certiﬁcate authorities on the
Internet. The EFF SSL Observatory [4] analyzed over 1.3
million unique SSL certiﬁcates by scanning the entire IPv4
space, and indicated that 1,482 trusted certiﬁcate signers are
being used. Similarly, Durumeric et al. [17] collected over
42 million unique certiﬁcates by scanning 109 million hosts,
and identiﬁed 1,832 trusted certiﬁcate signers. Holz et al. [15]
analyzed SSL certiﬁcates by passively monitoring live SSL
trafﬁc on a research network in addition to actively scanning
popular websites, and found that over 40% certiﬁcates ob-
served were invalid due to expiration, incorrect host names, or
other reasons. Akhawe et al. [16] analyzed SSL certiﬁcates by
monitoring live user trafﬁc at several institutional networks,
and provided a categorization of common certiﬁcate warn-
ings, including server mis-conﬁgurations and browser design
decisions. However, existing studies do not provide insights
on forged certiﬁcates, probably since network attackers are
relatively rare on those research institutional networks. In our
work, we set out to measure real-world SSL connections from
a large and diverse set of clients, in an attempt to ﬁnd forged
SSL certiﬁcates.

D. Tamper Detection Techniques for WebSites

Several techniques have been proposed to assist websites
in detecting whether the client’s network connections has
been tampered with. In this paper, we focus on detection
methods that do not require user interaction, and do not require

85

Fig. 2. An SSL man-in-the-middle attack between the browser and the server,
using a forged SSL certiﬁcate to impersonate as the server to the client.

the server (typically for the purpose of eavesdropping or ma-
nipulating private communications). The attacker establishes
two separate SSL connections with the client and the server,
and relays messages between them, in a way such that both the
client and the server are unaware of the middleman. This setup
enables the attacker to record all messages on the wire, and
even selectively modify the transmitted data. Figure 2 depicts
an SSL man-in-the-middle attack with a forged certiﬁcate
mounted between a browser and a HTTPS server. We describe
the basic steps of a generic SSL man-in-the-middle attack as
follows:

1) The attacker ﬁrst inserts itself into the transport path
between the client and the server, for example, by
setting up a malicious WiFi hotspot. Even on otherwise
trusted networks, a local network attacker may often
successfully re-route all of the client’s trafﬁc to itself
using exploits like ARP poisoning, DNS spooﬁng, BGP
hijacking, etc. The attacker could also possibly conﬁgure
itself as the client’s proxy server by exploiting auto-
conﬁguration protocols (PAC/WPAD) [19]. At this point,
the attacker has gained control over the client’s trafﬁc,
and acts as a relay server between the client and the
server.

2) When the attacker detects an SSL ClientHello message
being sent from the client, the attacker accurately deter-
mines that the client is initiating an SSL connection. The
attacker begins the impersonation of the victim server
and establishes an SSL connection with the client. Note
that the attacker uses a forged SSL certiﬁcate during its
SSL handshake with the client.

3) In parallel

to the previous step,

the attacker creates
a separate SSL connection to the legitimate server,
impersonating the client. Once both SSL connections are
established, the attacker relays all encrypted messages

ClientHello ServerHello Certificateattacker ServerHelloDone ClientKeyExchange ChangeCipherSpec Finished ChangeCipherSpec Finished Man-in-the-middle ClientHello ServerHello Certificateserver ServerHelloDone ClientKeyExchange ChangeCipherSpec Finished ChangeCipherSpec Finished Encryptattacker(data) Encryptattacker(data) Browser HTTPS server the installation of additional software or browser extensions.
Notably, Web Tripwires [24] uses client-side JavaScript code
to detect in-ﬂight modiﬁcations to a web page. Several other
studies [25], [26], [27], [28] have utilized Java applets to probe
the client’s network conﬁgurations and detect proxies that are
altering the client’s trafﬁc.

• Web Tripwires. Web Tripwires [24] was a technique
proposed to ensure data integrity of web pages, as an
alternative to HTTPS. Websites can deploy JavaScript
to the client’s browser that detects modiﬁcations on
web pages during transmission. In their study of real-
world clients, over 1% of 50, 000 unique IP addresses
observed altered web pages. Roughly 70% of the page
modiﬁcations were caused by user-installed software that
injected unwanted JavaScript into web pages. They found
that some ISPs and enterprise ﬁrewalls were also injecting
ads into web pages, or benignly adding compression to
the trafﬁc. Interestingly, they spotted three instances of
client-side malware that modiﬁed their web pages. Web
Tripwires was mainly designed to detect modiﬁcations to
unencrypted web trafﬁc. By design, Web Tripwires does
not detect passive eavesdropping (that does not modify
any page content), nor does it detect SSL man-in-the-
middle attacks. In comparison, our goal is to be able to
detect eavesdropping on encrypted SSL connections.

• Content Security Policy. Content Security Policy
(CSP) [29] enables websites to restrict browsers to load
page content, like scripts and stylesheets, only from a
server-speciﬁed list of trusted sources. In addition, web-
sites can instruct browsers to report CSP violations back
to the server with the report-uri directive. Interest-
ingly, CSP may detect untrusted scripts that are injected
into the protected page, and report them to websites. Like
Web Tripwires, CSP does not detect eavesdropping on
SSL connections.

• Browser Plugins. Another technique for websites to
diagnose the client’s network is by using browser plugins,
such as Java and Flash Player. Browser plugins may
provide more network capabilities than JavaScript, in-
cluding the ability to open raw network sockets and even
perform DNS requests. For instance, the Illuminati [25]
project used Java applets to identify whether clients were
connecting through proxies or NAT devices. Jackson et
al. conducted studies using both Java and Flash Player
on real-world clients to ﬁnd web proxy vulnerabilities,
including multi-pin DNS rebinding [26] and cache poi-
soning [27]. The ICSI Netalyzer [28] used a signed Java
applet to perform extensive tests on the client’s network
connectivity, such as detecting DNS manipulations.

In our work, we focused on detecting SSL man-in-the-
middle attacks in real-world, from a website’s perspective,
without modiﬁcations to current browsers. Other proposals to
prevent or mitigate SSL interception will be later discussed in
Section V.

86

III. SSL TAMPER DETECTION METHOD

In Section II-D, we discussed a number of existing tech-
niques for websites to detect network tampering. However,
none of the current methods (without browser modiﬁcations)
are effective in detecting SSL man-in-the-middle attacks. In
this section, we present a new method for detecting SSL
man-in-the-middle attacks from the website’s end. First, we
describe our threat model. We then detail the design and our
implementation of the detection method on the Facebook web-
site. Lastly, we present our ﬁndings from analyzing millions
of real-world SSL connections.

A. Threat Model

We primarily consider an active network attacker who has
control over the victim’s network connection. However, the
attacker does not have control over the website (such as
accessing internal machines and stealing the server’s private
key). The goal of the adversary is to read encrypted messages
between the victim client and the HTTPS website. The attacker
may impersonate the legitimate website with either (1) a
trusted certiﬁcate issued by a trusted CA, or (2) an untrusted
certiﬁcate (e.g. a self-signed certiﬁcate). In the case of an
untrusted certiﬁcate, we assume that users may still be vulner-
able, since previous studies [11], [12] have shown that many
users ignore browser security warnings. Users are assumed to
use up-to-date browsers (with no SSL implementation bugs).
In addition, we will discuss separately another type of
local attacker, where the attacker may be a piece of software
running on the client with the ability to modify the client’s
trusted CA store, as well as manipulate network connections.
Such local attackers are much stronger than active network
attackers, and are naturally not in scope of the SSL protocol’s
protection.

B. Design

There are several obstacles for websites to detect whether
any SSL man-in-the-middle attacks are mounted against their
connections. First of all, since SSL client certiﬁcates are rarely
sent by normal users, it is not possible to distinguish a legit-
imate client from an attacker directly via the SSL handshake
from the server’s perspective. In order to determine whether
an SSL connection is being intercepted, our fundamental
approach is to observe the server’s certiﬁcate from the client’s
perspective. Intuitively, if the client actually received a server
certiﬁcate that does not exactly match the website’s legitimate
certiﬁcate, we would have direct evidence that the client’s
connection must have been tampered with.

Although one could easily develop a binary executable ﬁle
or a custom browser extension that probes SSL certiﬁcates as
an SSL client, it would not be scalable to distribute additional
software to a large number of normal users, especially for
non-tech-savvy users. Ideally, we would like to develop a
JavaScript code snippet to observe SSL certiﬁcates, which
runs in existing browsers and can reach a large population of
clients. However, there are currently no existing browser APIs
that allows web applications to directly check the observed

order for a SWF applet from example.com to open a socket
connection to a HTTPS server example.com on port 443, a
valid socket policy ﬁle must be served at example.com on
port 843, which permits socket access from example.com
applications to port 443, as follows (in XML format):

<?xml version="1.0"?>
<!DOCTYPE cross-domain-policy SYSTEM

"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">

<cross-domain-policy>

<allow-access-from domain="example.com" to-ports="443" />

</cross-domain-policy>

Note that the socket policy ﬁle should not be confused with
the crossdomain.xml ﬁle served by web servers, which
restricts access to HTTP, HTTPS, and FTP access, but not
socket access. If the Flash Player cannot successfully retrieve
a valid socket policy (e.g. blocked by a ﬁrewall), the socket
connection will be aborted and an exception will be thrown.
Once the socket connection is permitted, our applet will
initiate an SSL handshake by sending a ClientHello message
over the socket, and wait for the server to respond with
the ServerHello and Certiﬁcate messages, which will be
recorded. To support clients behind explicit HTTP proxies,
the applet may send a CONNECT request over the socket to
create an SSL tunnel prior to sending the ClientHello message,
as follows:

CONNECT example.com:443 HTTP/1.1

Our SSL handshake implementation was based on the SSL
3.0 protocol version. Since our goal to observe the server’s
certiﬁcate chain, our applet closes the socket connection
after successfully receiving the certiﬁcate chain. Lastly, our
applet converts the raw bytes of the recorded SSL handshake
responses into an encoded string, and sends it back to our log
server with a POST request.

We note that the Flash Player plugin is currently supported
on 95% of web browsers [31], therefore, our applet should
be able to run on most clients. In fact, one of the major
browsers, Google Chrome, has the Flash Player plugin built
in by default. Also, SWF applets are usually allowed to
execute without any additional user conﬁrmation, and do not
trigger any visual indicators (e.g. system tray icons) while
running, thus, deploying this method should not affect the
visual appearance of the original web page.

Alternatively, the client-side applet may be implemented
using other browser plugins, for example, the Java plugin.
Java applets are allowed to create socket connections from
the client to any port on the same host that the applet was
served from. As an example, an applet served from port
80 on example.com can open a raw socket to port 443
on example.com without requesting any additional access.
However, due to security concerns, the Java plugin is currently
blocked by default on several client platforms, and may require
additional user interaction to activate the Java plugin. Such
user interaction would be too obtrusive for our experiment
and client diversity suffers greatly once all potential interactive
platforms are removed from the experiment. Another side
effect of running a Java applet on some platforms is that a

Fig. 3.
The website loads a client-side applet, that performs the SSL
handshake over a Flash-based socket connection to observe SSL certiﬁcates.

server certiﬁcate or validation status of their SSL connections.
To workaround this, we utilized browser plugins to implement
a client-side applet that is capable of imitating the browser’s
SSL handshake, accompanied with the ability to report the
observed certiﬁcate chain. The applet can open a socket con-
nection to the HTTPS server (skipping the browser’s network
stack), perform an SSL handshake over the socket, record
the SSL handshake, and report the certiﬁcate chain back to
our logging servers, shown in Figure 3. We describe our
implementation details below.

1) Client-Side Applet: Our approach is to use a client-
side applet that observes the server’s SSL certiﬁcate from
the client’s perspective, directly during the SSL handshake.
Since native browser networking APIs like XMLHttpRequest
and WebSockets do not provide web applications access to
raw bytes of socket connections, we must utilize browser
plugins. We implemented a Shockwave Flash (SWF) applet
that can open a raw socket connection to its own HTTPS server
(typically on port 443), and perform an SSL handshake over
the connection in the Flash Player.

By default, the Flash Player plugin does not allow any
applets to access socket connections, unless the remote host
runs a Flash socket policy server [30]. The Flash socket policy
server, normally running on port 843, serves a socket policy
ﬁle that declares whether SWF applications may open socket
connections to the server. Note that even if a SWF ﬁle is
requesting a socket connection to the same host it was served
from, a socket policy server is still required. As a result, in

87

Request HTML <html>… <object src="applet.swf"></object> … Request applet.swf applet.swf <policy-file-request /> <cross-domain-policy>...</cross-domain-policy> Port 843 ClientHello ServerHello, Certificateattacker… Port 443 Flash Player Log Certificateattacker Browser HTTPS server visible icon would be displayed in the system tray, which
might annoy or confuse some of the website’s users.

2) Lenient Certiﬁcate Extraction: Since we implemented
the SSL handshake process on our own, we must extract
the SSL certiﬁcates from a raw byte dump of the SSL
handshake observed on the client, by parsing the Server-
Hello and ServerCertiﬁcate messages. Surprisingly, in our
initial attempts, we found that this seemingly straightforward
extraction process failed occasionally. By manual inspection,
we noticed that some of the recorded SSL messages were
slightly different from the SSL/TLS standards. As a result,
we intentionally parsed the SSL handshake in as lenient a
manner as possible in order to extract certiﬁcates even if the
SSL message format did not conform exactly to the standards.
We did not discard these malformed handshakes as we theorize
that they are caused by either transmission errors or software
errors in the intercepting proxy.

Websites may choose to perform certiﬁcate extraction on-
the-ﬂy in the client-side applet, or simply send the handshake
raw bytes to their log servers for post-processing. We took
the latter approach, since it enabled us to preserve the SSL
handshake bytes for further investigation, even if early versions
of our extraction code failed (or even crashed unexpectedly)
while parsing certiﬁcates.

C. Implementation

We have implemented our client-side applets for both the
Flash Player and Java plugins. With similar functionality,
the SWF ﬁle (2.1 KB) was slightly smaller than the Java
applet (2.5 KB). Since Flash Player was supported on a larger
client population and is considered less obtrusive to users, we
deployed the SWF ﬁle for our experiments.

To observe SSL connections on a large set of real-world
clients, we deployed our client-side applet on Facebook’s
servers to run our experiments. We sampled a small portion
(much less than 1%) of the total connections on Facebook’s
desktop website, particularly on the www.facebook.com
domain. To avoid affecting the loading time of the website’s
original web pages, our applets are programmed to load several
seconds after the original page has completed loading. This is
done by using a JavaScript snippet that dynamically inserts a
HTML object tag that loads the SWF ﬁle into the web page
visited by the user. Basically, the script is triggered only after
the original page ﬁnishes loading, and further waits a few
seconds, before actually inserting the applet. Additionally, we
built server-side mechanisms to allow granular control over
the sampling rates in speciﬁc countries or networks. This
granularity enables us to increase the sampling rate for certain
populations in response to the detection of a speciﬁc attack.
To support Flash-based socket connections used by our SWF
ﬁles, we have set up Flash socket policy servers that listens on
port 843 of the website, which are conﬁgured with a socket
policy ﬁle that allows only its own applets to open socket
connections to port 443. We also setup a logging endpoint
on the HTTPS servers, in PHP, that parses the reports, and
aggregates data into our back-end databases. The extracted

Fig. 4. Browser usage share of sampled clients. Note that given our sampling
parameters, this is not directly representative of the entire population of
Facebook’s website.

NUMBER OF CLIENTS THAT COMPLETED EACH STEP OF THE DETECTION

TABLE I

PROCEDURE

Procedure

Count

1. Inserted HTML object tag into web page
2. Downloaded SWF ﬁle from server
3. Sent report to logging server

9, 179, 453
6, 908, 675
5, 415, 689

SSL certiﬁcates were processed and read using the OpenSSL
library. In addition, we built an internal web interface for
querying the log reports.

D. Experimentation

Using the Flash-based detection method, we conducted the
ﬁrst large-scale experiment in an attempt to catch forged SSL
certiﬁcates in the wild. We served our client-side applet to
a set of randomly sampled clients on Facebook’s website.
We collected and analyzed data from November 20, 2012 to
March 31, 2013.2 Our dataset consists of reports from a variety
of browsers, shown in Figure 4. The most popular browser
versions in our dataset were (in descending order) Chrome
23, Chrome 24, Internet Explorer 9, Chrome 25, and Firefox
18.

First of all, we noticed that only a portion of the sampled
clients actually completed our detection procedure, explained
below. As shown in Table I, a total of 9, 179, 453 page
views on Facebook’s desktop website had our HTML object
tag dynamically inserted. Our web servers logged 6, 908, 675
actual downloads for the SWF ﬁle. The download count for
the SWF ﬁle was noticeably lower than the number of object
tags inserted. We reason that this is possibly due to: (1) the
Flash Player plugin was not enabled on the client, (2) a few
legacy browsers did not support our SWF object embedding
method, or (3) the user navigated away from the web page
before the object tag was loaded. Our log servers received
a total of 5, 415, 689 reports from applets upon successful
execution. Again, the number of received reports is lower than
the number of SWF ﬁle downloads. This is likely due to the
web page being closed or navigated away by the user, before
the applet was able to ﬁnish execution.

2Personally identiﬁable information (IP addresses and HTTP cookies) were

removed from our database after a 90-day retention period.

88

(cid:23)(cid:18)(cid:20)(cid:24)(cid:18)(cid:20)(cid:22)(cid:69)(cid:85)(cid:82)(cid:90)(cid:86)(cid:72)(cid:85)(cid:17)(cid:75)(cid:87)(cid:80)(cid:79)(cid:73)(cid:76)(cid:79)(cid:72)(cid:29)(cid:18)(cid:18)(cid:79)(cid:82)(cid:70)(cid:68)(cid:79)(cid:75)(cid:82)(cid:86)(cid:87)(cid:18)(cid:56)(cid:86)(cid:72)(cid:85)(cid:86)(cid:18)(cid:79)(cid:76)(cid:81)(cid:86)(cid:75)(cid:88)(cid:81)(cid:74)(cid:75)(cid:88)(cid:68)(cid:81)(cid:74)(cid:18)(cid:39)(cid:85)(cid:82)(cid:83)(cid:69)(cid:82)(cid:91)(cid:18)(cid:47)(cid:68)(cid:55)(cid:72)(cid:59)(cid:18)(cid:73)(cid:69)(cid:66)(cid:80)(cid:76)(cid:87)(cid:80)(cid:18)(cid:69)(cid:85)(cid:82)(cid:90)(cid:86)(cid:72)(cid:85)(cid:17)(cid:75)(cid:87)(cid:80)(cid:79)(cid:20)(cid:18)(cid:20)(cid:38)(cid:75)(cid:85)(cid:82)(cid:80)(cid:72)(cid:41)(cid:76)(cid:85)(cid:72)(cid:73)(cid:82)(cid:91)(cid:44)(cid:81)(cid:87)(cid:72)(cid:85)(cid:81)(cid:72)(cid:87)(cid:3)(cid:40)(cid:91)(cid:83)(cid:79)(cid:82)(cid:85)(cid:72)(cid:85)(cid:54)(cid:68)(cid:73)(cid:68)(cid:85)(cid:76)(cid:50)(cid:83)(cid:72)(cid:85)(cid:68)(cid:50)(cid:87)(cid:75)(cid:72)(cid:85)(cid:23)(cid:27)(cid:17)(cid:26)(cid:8)(cid:26)(cid:17)(cid:24)(cid:8)(cid:20)(cid:27)(cid:17)(cid:26)(cid:8)(cid:21)(cid:21)(cid:17)(cid:26)(cid:8)TABLE II

CATEGORIZATION OF REPORTS

Type

Count

Well-formed certiﬁcates
Flash socket errors
Empty reports
Bogus reports
HTTP responses

3, 447, 719 (64%)
1, 965, 186 (36%)
2, 398 (0%)
290 (0%)
96 (0%)

Next, we noticed that only 64% out of the 5, 415, 689 re-
ceived reports contained complete and well-formed certiﬁcate
records, as shown in Table II. We observed that 1, 965, 186
(36%) of the reported data indicated that the client caught
SecurityErrorEvent or IOErrorEvent exceptions in the Flash
Player and failed to open a raw socket. We believe that most
of these errors were caused by ﬁrewalls blocking the socket
policy request (for example, whitelisting TCP ports 80 and 443
to only allow web trafﬁc), thus not allowing the Flash Player to
retrieve a valid socket policy ﬁle from our socket policy servers
(over port 843). For clients behind these ﬁrewalls, we were not
able to open socket connections using Flash Player, although
using Java might have worked in some legacy client platforms.
We discuss in Section III-E that similar measurements can be
conducted on native mobile platforms to avoid the drawbacks
of Flash sockets.

In addition to the Flash socket errors, we also observed a
few other types of erroneous reports. There were 2, 398 reports
that were empty, indicating that the SWF ﬁle failed to receive
any certiﬁcates during the SSL handshake. This might have
been caused by ﬁrewalls that blocked SSL trafﬁc (port 443).
There were 96 reports that received HTTP responses during
the SSL handshake, mostly consisting of error pages (HTTP
400 code) or redirection pages (HTTP 302 code). These
responses suggest that some intercepting proxies contained
logic that were modifying the client’s web trafﬁc to block
access to certain websites (or force redirection to certain web
pages, known as captive portals). We found that some clients
received a HTML page in plaintext over port 443, for instance,
linking to the payment center of Smart Bro, a Philippine
wireless service provider. These type of proxies do not appear
to eavesdrop SSL trafﬁc, but they inject unencrypted HTTP
responses into the client’s web trafﬁc.

In addition, there were 290 reports that contained garbled
bytes that could not be correctly parsed by our scripts. Al-
though we could not successfully parse these reports, manual
inspection determined that 16 of the reports contained seem-
ingly legitimate VeriSign certiﬁcates that had been truncated in
transit, presumably due to lost network connectivity. Another
37 of these reports appear to be issued by Kurupira.NET, a
web ﬁlter, which closed our SSL connections prematurely.
We also found that 17 of the unrecognized POST requests
on our log servers were sent from a Chrome extension called
Tapatalk Notiﬁer (determined by the HTTP origin header),

however we have no evidence that these false POST requests
were intentional.

Finally, we successfully extracted 3, 447, 719 (64%) well-
formed certiﬁcates from the logged reports. We used custom
scripts (mentioned in Section III-B2) to parse the recorded
SSL handshake bytes. A total of 3, 440, 874 (99.8%) out of
3, 447, 719 observed certiﬁcates were conﬁrmed to be the
website’s legitimate SSL certiﬁcates, by checking the RSA
public keys (or more strictly, by comparing the observed
certiﬁcate bit-by-bit with its legitimate certiﬁcates). We note
that there were multiple SSL certiﬁcates (thus, multiple RSA
public keys) legitimately used by Facebook’s SSL servers
during the period of our study,
issued by publicly-trusted
commercial CAs including VeriSign, DigiCert, and Equifax.
Most interestingly, we discovered that 6, 845 (0.2%) of the
observed certiﬁcates were not legitimate, nor were they in
any way approved by Facebook. We further examine these
captured forged certiﬁcates in Section IV.
E. Limitations

Before we move on, we offer insights on the limitations
of our detection method. It is important to point out that the
goal of our implementation was not to evade the SSL man-in-
the-middle attacks with our detection mechanism. Admittedly,
it would be difﬁcult to prevent professional attackers that are
fully aware of our detection method. We list below some ways
that an attacker might adaptively evade our detection:

• Attackers may corrupt all SWF ﬁles in transmission, to
prevent our client-side applet from loading. However, this
approach would cause many legitimate applications using
SWF ﬁles to break. Of course, the attacker could narrow
the scope of SWF blacklisting to include only the speciﬁc
SWF ﬁles used in this detection. In response, websites
may consider randomizing the locations of their SWF
ﬁles.

• Attackers may restrict Flash-based sockets by blocking
Flash socket policy trafﬁc on port 843. To counter this,
websites could possibly serve socket policy ﬁles over
ﬁrewall-friendly ports (80 or 443), by multiplexing web
trafﬁc and socket policy requests on their servers. In
addition, websites could try falling back to Java applets
on supporting clients if Flash-based sockets are blocked.
• Attackers may try to avoid intercepting SSL connections
made by the Flash Player. However, the website may
tailor its client-side applet to act similarly to a standard
browser.

• In theory, attackers could possibly tamper the reports
(assuming that the measured client was under an SSL
man-in-the-middle attack, and probably clicked through
SSL warnings, if any), and trick our log servers to believe
that
the website’s legitimate certiﬁcate was observed.
Under this scenario, the website may need additional
mechanisms to verify the integrity of their reports.

At the time of this study, there is no reason to think that
any attacker is tampering our reports, or even aware of our
detection method. We do not consider attackers that have

89

TABLE III

FORGED CERTIFICATE CHAIN SIZES

Size (bytes)
0 - 1000
1000 - 2000
2000 - 3000
3000 - 4000
4000 - 5000
5000 - 6000
6000 - 7000

Count
6,154 (90%)
508 (7%)
140 (2%)
29 (0%)
2 (0%)
23 (0%)
13 (0%)

obtained access to Facebook’s internal servers. As shown
in Section III-D, our current methodology has successfully
captured direct evidences of unauthorized SSL interceptions in
the wild. However, if more websites become more aggressive
about this sort of monitoring, we might get into an arms race,
unfortunately.

Fortunately, many popular websites nowadays have the op-
tion to leverage their native mobile applications for detecting
attacks. While our initial
implementation targeted desktop
browsers, we suggest that similar mechanisms can be im-
plemented, more robustly, on mobile platforms such as iOS
and Android.3 Native mobile applications have the advantage
of opening socket connections without Flash-based socket
policy checks, and are more difﬁcult for network attackers
to bypass (since the Flash applet is no longer necessary, and
native applications can be programmed to act exactly like
a standard browser). Furthermore, mobile clients can also
implement additional defenses (e.g. certiﬁcate pinning [22])
to harden itself against SSL man-in-the-middle attacks (e.g.
preventing the tampering of reports), while performing similar
measurement experiments.

IV. ANALYSIS OF FORGED SSL CERTIFICATES

From the experiments in Section III-D, we collected 6, 845
forged certiﬁcates from real-world clients connecting to Face-
book’s SSL servers. In this section, we analyze the root cause
of these injected forged SSL certiﬁcates. First, we survey the
characteristics of the forged certiﬁcate chains, including the
certiﬁcate chain sizes, certiﬁcate chain depths, and public key
sizes. Subsequently, we examine the subject names and the
issuer names of the forged certiﬁcates.

A. Size Characteristics

We ﬁrst examine the size characteristics of the forged SSL

certiﬁcates, as follows:

• Certiﬁcate chain sizes. Table III summarizes the total
sizes in bytes of the forged certiﬁcate chains. Notably,
most of the forged certiﬁcate chains were actually very
small (less than a kilobyte). By manual inspection, these
small certiﬁcates were generally self-signed certiﬁcates

3After our initial study, Facebook has implemented our methodology across

their native mobile applications.

90

TABLE IV

FORGED CERTIFICATE CHAIN DEPTHS

Depth
1
2
3
4
5

Count
6,173 (90%)
617 (9%)
19 (0%)
34 (0%)
2 (0%)

PUBLIC KEY SIZES OF FORGED SERVER CERTIFICATES

TABLE V

Public Key Size (bits)

512
1024
2048

Count
119 (2%)
3,447 (50%)
3,279 (48%)

that did not include any intermediate CA certiﬁcates (thus
the smaller chain size). A small number of certiﬁcate
chains were larger than 5 KB in size, where the size
overhead might have a negative impact on page load time
for victim users.

• Certiﬁcate chain depths. Table IV shows the distribution
of certiﬁcate chain length. Here, we refer to the certiﬁcate
chain depth as the number of certiﬁcates (including any
intermediate CA certiﬁcates) actually transmitted during
the SSL handshake. We note that on most websites, the
certiﬁcate chains normally do not include the issuing root
CA certiﬁcate (since trusted CA certiﬁcates are presumed
to be installed on the client, thus omitted in transmission).
The majority of the forged certiﬁcate chains have a
depth of one, which only contained the server’s end
entity certiﬁcate without any intermediate certiﬁcates.
Since most commercial CAs nowadays issue certiﬁcates
using intermediate keys (rather than their root keys), one
should probably raise some suspicion when encountering
certiﬁcate chains with a depth of one. There were 55 of
the forged certiﬁcates that had a depth of 3 or larger,
which is actually longer than the website’s legitimate
certiﬁcate chain. For these certiﬁcate chains, additional
cryptographic computations or even online revocation
checks on the client might be required, since the client
needs to verify signatures for all of the intermediate
certiﬁcates when establishing an SSL connection. On
slower devices, the additional veriﬁcation time might be
noticeable by the victim user.

• Public key sizes. Table V shows the RSA public key sizes
in bits carried in the forged certiﬁcates. Most of the forged
certiﬁcates had either 1024-bit or 2048-bit public keys,
which are not characteristically different from legitimate
SSL certiﬁcates (although websites should transition to
2048-bit or stronger RSA keys by 2014 according to the
CA/Browser forum’s recommendations). We noticed that
a few certiﬁcates actually contained relatively weak 512-

SUBJECT ORGANIZATIONS OF FORGED CERTIFICATES

TABLE VI

Subject Organization

Facebook, Inc.
Empty
Fortinet Ltd. / Fortinet
Lousville Free Public Library
Other

Count
6,552
131
93
10
59

SUBJECT COMMON NAMES OF FORGED CERTIFICATES

TABLE VII

Subject Common Name

*.facebook.com
www.facebook.com
pixel.facebook.com
m.facebook.com
facebook.com
*
IP addresses
FG... / Fortinet / FortiClient
Other

Count
6,491
117
1
1
1
1
118
93
22

bit public keys. These users may have become further
vulnerable to a second attacker given the considerably
weakened public key.

B. Certiﬁcate Subjects

First, Table VI shows the subject organizations of forged
certiﬁcates. As expected, the majority of them spoofed the
organization as Facebook. There were over a hundred forged
certiﬁcates that excluded the organization attribute entirely.
Again, we conﬁrmed 93 certiﬁcates that were attributed to
Fortinet Ltd.

Next, we inspect the observed subject common names of the
forged SSL certiﬁcates, summarized in Table VII. Normally,
the subject common name of the SSL certiﬁcate should match
the hostname of the website to avoid triggering SSL certiﬁcate
warnings in the browser. While most of the forged certiﬁcates
used the legitimate website’s domains as the subject common
name, there were a few certiﬁcates that used unrelated domains
as well.

Unsurprisingly, most of the forged SSL certiﬁcates used the
wildcard domain *.facebook.com as the subject common
name in order to avoid certiﬁcate name validation errors.
This suggests that most of the attacking entities were either
speciﬁcally targeting Facebook’s website by pre-generating
certiﬁcates that match the website’s name, or using automated
tools to generate the certiﬁcates on-the-ﬂy. None of the forged
certiﬁcates were straight clones of Facebook’s legitimate cer-
tiﬁcates (that replicated all the X.509 extension ﬁelds and
values). There were some certiﬁcates that used IP addresses as
common name, for example, 69.171.255.255 (which ap-
pears to be one of Facebook’s server IP addresses). We noticed

that a number of forged certiﬁcates used a subject name that
starts with two characters FG concatenated with a long numeric
string (e.g. FG600B3909600500). These certiﬁcates were
issued by Fortinet Ltd., a company that manufactures SSL
proxy devices which offer man-in-the-middle SSL inspection.
Similarly, we found 8 certiﬁcates that had a subject common
name “labris.security.gateway SSL Filtering Proxy,” which is
also an SSL proxy device. There were a few other common
names observed that were likely amateur attempts of SSL
interception, such as localhost.localdomain, which
is the default common name when generating a self-signed
certiﬁcate using the OpenSSL library.

For the forged SSL certiﬁcates that did not use a subject
common name with facebook.com as sufﬁx, we also
checked if any subject alternative names were present in the
certiﬁcate. Subject alternative names are treated as additional
subject names, and allow certiﬁcates to be shared across
multiple distinct hostnames. This may allow attackers to gen-
erate a single forged certiﬁcate for attacking multiple different
websites. For the 233 forged certiﬁcates that did not provide a
matching common name, none of them provided a matching
subject alternative name. Even though these 233 (3.4%) forged
certiﬁcates would deﬁnitely trigger name mismatch errors,
there is still a signiﬁcant possibility that users may ignore
the browser’s security warnings anyway.

C. Certiﬁcate Issuers

In this section, we examine the issuer organizations and is-
suer common names of each forged SSL certiﬁcate. Table VIII
lists the top issuer organizations of the forged certiﬁcates.
At ﬁrst glance, we noticed several forged certiﬁcates that
fraudulently speciﬁed legitimate organizations as the issuer,
including 5 using Facebook, 4 using Thawte, and one using
VeriSign. These invalid certiﬁcates were not actually issued
by the legitimate companies or CAs, and were clearly mali-
cious attempts of SSL interception. Since 166 of the forged
certiﬁcates did not specify its issuer organization (or empty),
we also checked the issuer common names, listed in Table IX.
We manually categorized the certiﬁcate issuers of forged
certiﬁcates into antivirus, ﬁrewalls, parental control software,
adware, and malware. Notably, we observed an intriguing
issuer named IopFailZeroAccessCreate that turned out to
be produced by malware, which we discuss in detail below.
• Antivirus. By far the top occurring issuer was Bitde-
fender with 2, 682 certiﬁcates, an antivirus software prod-
uct which featured a “Scan SSL” option for decrypting
SSL trafﬁc. According to their product description, Bit-
defender scans SSL trafﬁc for the presence of malware,
phishing, and spam. The second most common issuer was
ESET with 1, 722 certiﬁcates, another antivirus software
product
that provides SSL decryption capabilities for
similar purposes. Several other top issuers were also ven-
dors of antivirus software, such as BullGuard, Kaspersky
Lab, Nordnet, DefenderPro, etc. These software could
possibly avoid triggering the browser’s security errors by
installing their self-signed root certiﬁcates into the client’s

91

ISSUER ORGANIZATIONS OF FORGED CERTIFICATES

TABLE VIII

ISSUER COMMON NAMES OF FORGED CERTIFICATES

TABLE IX

Issuer Organization

Bitdefender
ESET, spol. s r. o.
BullGuard Ltd.
Kaspersky Lab ZAO / Kaspersky Lab
Sendori, Inc
Empty
Fortinet Ltd. / Fortinet
EasyTech
NetSpark
Elitecore
ContentWatch, Inc
Kurupira.NET
Netbox Blue / Netbox Blue Pty Ltd
Qustodio
Nordnet
Target Corporation
DefenderPro
ParentsOnPatrol
Central Montcalm Public Schools
TVA
Louisville Free Public Library
Facebook, Inc.
thawte, Inc.
Oneida Nation / Oneida Tribe of WI
VeriSign Trust Network
Other (104)

Count
2,682
1,722
819
415
330
166
98
78
55
50
48
36
25
21
20
18
16
14
13
11
10
5
4
2
1
186

system. Note that the observed antivirus-related certiﬁcate
counts are not representative of the general antivirus
usage share of the website’s users, since SSL interception
is often an optional feature in these products. However,
if any antivirus software enabled SSL interception by
default, we would expect a higher number of their forged
certiﬁcates observed.

Supposing that these users intentionally installed the an-
tivirus software on their hosts, and deliberately turned on
SSL scanning, then these antivirus-generated certiﬁcates
would be less alarming. However, one should be wary of
professional attackers that might be capable of stealing
the private key of the signing certiﬁcate from antivirus
vendors, which may essentially allow them to spy on the
antivirus’ users (since the antivirus’ root certiﬁcate would
be trusted by the client). Hypothetically, governments
could also compel antivirus vendors to hand over their
signing keys.

• Firewalls. The second most popular category of forged
certiﬁcates belongs to commercial network security appli-
ances that perform web content ﬁltering or virus scanning
on SSL trafﬁc. As observed in the certiﬁcate subject
ﬁelds, Fortinet was one of the issuers that manufactures

92

Issuer Common Name

Bitdefender Personal CA.Net-Defender
ESET SSL Filter CA
BullGuard SSL Proxy CA
Kaspersky Anti-Virus Personal Root Certiﬁcate
Sendori, Inc
IopFailZeroAccessCreate

...

*.facebook.com
VeriSign Class 4 Public Primary CA
Production Security Services
Facebook
thawte Extended Validation SSL CA
Other (252)

Count
2,670
1,715
819
392
330
112

6
5
3
1
1
794

devices for web content ﬁltering with support for HTTPS
deep inspection. NetSpark was another web content ﬁl-
tering device manufacturer offering similar capabilities.
According to their product description, the user’s content
is unencrypted for inspection on NetSpark’s servers, and
then re-encrypted under NetSpark’s SSL certiﬁcate for
the end user. We observed a number of device vendors
that provided similar devices, such as EliteCore, Con-
tentWatch, and Netbox Blue. There were also software
solutions that provided selective website blocking, such
as Kurupira.NET. Some appliance vendors aggressively
marketed SSL content inspection as a feature which can-
not be bypassed by users. For example, ContentWatch’s
website provided the following product description for
their ﬁrewall devices:4

“This technology also ensures the users cannot by-
pass the ﬁltering using encrypted web trafﬁc, remote
proxy servers or many of the other common methods
used circumvent content ﬁlters.”

Interestingly, EliteCore’s Cyberoam appliances have pre-
viously been discovered [32] to be using the same CA
private key across all Cyberoam devices. This is partic-
ularly dangerous, since the universal CA private key can
be extracted from any single device by an attacker. This
vulnerabilitiy allows an attacker to seamlessly perform
SSL man-in-the-middle attacks against users of benign
Cyberoam devices, because the attacker can issue forged
server certiﬁcates that will be accepted by other clients
that have installed Cyberoam’s CA certiﬁcate. Reportedly,
Cyberoam issued an over-the-air patch to generate unique
CA certiﬁcates on each device. Nevertheless, we should
be aware that other device manufacturers are likely to
introduce similar security vulnerabilities.

• Adware. We observed 330 instances of forged certiﬁcates

4http://www.contentwatch.com/solutions/industry/government

issued by a company named Sendori. This company of-
fers a browser add-on that claims to automatically correct
misspelled web pages. However, using Google Search to
query the string “Sendori” revealed alarming discussions
about
the add-on actually hijacking DNS entries for
the purposes of inserting advertisements into unrelated
websites.5 This form of adware actively injects content
into webpages, and could possibly be detected using Web
Tripwires or CSP (as described in Section II-D).

• Malware. As previously mentioned, we noticed that
an unknown issuer named IopFailZeroAccessCreate
appeared relatively frequently in our dataset. We man-
ually searched the name on the Internet and noticed
that multiple users were seeing SSL certiﬁcate errors
of the same issuer, and some were suggesting that the
user could be under SSL man-in-the-middle attacks by
malware.6 Upon deeper investigation, we discovered 5
forged certiﬁcates that shared the same subject public
key as IopFailZeroAccessCreate, yet were generated
with their issuer attribute set as “VeriSign Class 4 Public
Primary CA.” We conﬁrmed with Symantec/VeriSign that
these suspicious certiﬁcates were not issued through their
signing keys. This was obviously a malicious attempt
to create a certiﬁcate with an issuer name of a trusted
CA. These variants provide clear evidence that attackers
in the wild are generating certiﬁcates with forged issuer
attributes, and even increased their sophistication during
the time frame of our study.

In Figure 5, we illustrate the geographic distribution
of the certiﬁcates issued by IopFailZeroAccessCreate
(and the forged “VeriSign Class 4 Public Primary CA”)
on a world map. As shown, the infected clients were
widespread across 45 different countries. The countries
with the highest number of occurrences were Mexico,
Argentina and the United States, with 18, 12, and 11
occurrences, respectively. This shows that the particular
SSL man-in-the-middle attack is occurring globally in the
wild. While it is possible that all of these attacks were am-
ateur attackers individually mounting attacks (e.g. at their
local coffee shop), it is certainly odd that they happened
to use forged certiﬁcates with the same subject public key.
However, this is not so unreasonable if these attacks were
mounted by malware. Malware researchers at Facebook,
in collaboration with the Microsoft Security Essentials
team, were able to conﬁrm these suspicions and identify
the speciﬁc malware family responsible for this attack.
Since our experiments only tested SSL connections to
Facebook’s servers (only for the www.facebook.com
domain), we cannot conﬁrm whether this attack also
targeted other websites. In response to our discovery, the
website notiﬁed the infected users, and provided them
with malware scan and repair instructions.

5http://helpdesk.nwciowa.edu/index.php?/News/NewsItem/View/10
6http://superuser.com/q/421224

Fig. 5. Geographic distribution of forged SSL certiﬁcates generated by the
malicious issuer IopFailZeroAccessCreate

In addition, there were 4 other suspicious certiﬁcates
issued under the organization name of thawte, Inc with
three of them using “Production Security Services” as
the issuer common name, and one using “thawte Ex-
tended Validation SSL CA.” These instances could be
the same malware attack previously spotted by some
Opera users [33], in which forged certiﬁcates pretending
to be issued by Thwate were observed. These 4 forged
certiﬁcates were observed in Italy, Spain, and the United
States.

We note that a sophisticated attacker utilizing malware
could install their self-signed CA certiﬁcates on clients
in order to suppress browser security errors. Such an
attacker is likely capable of stealing conﬁdential infor-
mation, by reading from protected storage or logging
the user’s keystrokes. Nevertheless, mounting an SSL
man-in-the-middle attack further enables a general way
of capturing and recording the victim’s web browsing
activities in real-time.

• Parental Control Software. Some forged SSL certiﬁ-
cates were issued by parental control software, including
21 from Qustodio and 14 from ParentsOnPatrol. These
type of software are designed to enable parents to monitor
and ﬁlter the online activities of their children. Whether
such level of control is appropriate is beyond the scope
of our work.

While the remaining 104 other distinct issuer organizations
in Table VIII and 252 other distinct common names in
Table IX do not appear to be widespread malicious attempts
(based on manual
the possibility remains that
inspection),
some may still be actual attacks.

For example, we found two unexpected instances of forged
certiﬁcates issued by the Oneida Nation of Wisconsin, an
Indian tribe. We have little clue of why encrypted trafﬁc would
be eavesdropped by such entities. It is possible that this is
another case of corporate surveillance. We also found that

93

(cid:20)(cid:20)(cid:20)(cid:20)(cid:27)(cid:20)(cid:27)(cid:20)(cid:27)some schools and libraries were using forged certiﬁcates for
SSL interception, such as “Central Montcalm Public Schools”
and “Louisville Free Public Library.”

For some certiﬁcates, the certiﬁcate attributes alone provide
insufﬁcient clues to determine their origin. For example, an
issuer named EasyTech could either implicate the PC repair
service at Staples EasyTech, or the EasyTech digital education
system on learning.com. In either case, we were unclear
why SSL connections were being intercepted for those partic-
ular targets.

V. SURVEY OF MITIGATIONS

We provided direct evidences of a variety of forged SSL
certiﬁcates from real-world connections in Section IV. In
this section, we list some possible defenses that websites or
browser vendors may consider to help mitigate these attacks.

A. Strict Transport Security

HTTP Strict Transport Security (HSTS) [34], the successor
of ForceHTTPS [35], is a HTTP response header that allows
websites to instruct browsers to make SSL connections manda-
tory on their site. By setting the HSTS header, websites may
prevent network attackers from performing SSL stripping [36].
A less obvious security beneﬁt of HSTS is that browsers sim-
ply hard-fail when seeing invalid certiﬁcates, and do not give
users the option to ignore SSL errors. This feature prevents
users from accepting untrusted certiﬁcates when under man-in-
the-middle attacks by amateur script kiddies. However, HSTS
is not designed to protect against malware or professional
attackers that use forged certiﬁcates that would be accepted
by the browser.

B. Public Key Pinning

The Public Key Pinning Extension for HTTP (HPKP) [37]
proposal allows websites to specify their own public keys with
a HTTP header, and instruct browsers to reject any certiﬁ-
cates with unknown public keys. HPKP provides protection
against SSL man-in-the-middle attacks that use unauthorized,
but possibly trusted, certiﬁcates. HPKP automatically rejects
fraudulent certiﬁcates even if they would be otherwise trusted
by the client. Both HSTS and HPKP defenses require that
clients must ﬁrst visit the legitimate website securely before
connecting from untrusted networks. This requirement is lifted
if public key pins are pre-loaded in the browser, such as in
Google Chrome [38] and Internet Explorer (with EMET) [39],
although this approach may not scale for the entire web.
Notably, Chrome’s pre-loaded public key pinning mechanism
has successfully revealed several high-proﬁle CA incidents,
in which mis-issued certiﬁcates were used to attack Google’s
domains in the wild. However, in current implementations,
Chrome’s public key pinning does not reject certiﬁcates that
are issued by a locally trusted signer, such as antivirus,
corporate surveillance, and malware.

A related proposal, Trust Assertions for Certiﬁcate Keys
(TACK) [40], allows SSL servers to pin a server-chosen
signing key with a TLS extension. In contrast with HPKP,

TACK pins a signing key that chosen by the server, separate
from the private key corresponding to the server’s certiﬁcate,
and can be short-lived. TACK allows websites with multiple
SSL servers and multiple public keys to pin the same signing
key. Once the browser receives a TACK extension from an SSL
site, it will require future connections to the same site to be
signed with the same TACK signing key, or otherwise, reject
the connection. Another proposal called DVCert [41] delivers
a list of certiﬁcate pins over a modiﬁed PAKE protocol in
an attempt to detect SSL man-in-the-middle attacks, but also
requires modiﬁcations to existing clients and servers.

The concept of public key pinning (or certiﬁcate pinning)
has previously been implemented as a pure client-side defense
as well. Firefox add-ons such as Certiﬁcate Patrol [42] and
Certlock [9] were designed to alarm users when a previously
visited website starts using a different certiﬁcate. However,
without explicit signals from the server, it may be difﬁcult to
accurately distinguish real attacks from legitimate certiﬁcate
changes, or alternative certiﬁcates.

C. Origin-Bound Certiﬁcates

The TLS Origin-Bound Certiﬁcates (TLS-OBC) [43] pro-
posal revisits TLS client authentication, by enabling browsers
to generate self-signed client certiﬁcates on demand without
requiring any user conﬁgurations. TLS-OBC may block most
of the existing man-in-the-middle attack toolkits, since attack-
ers cannot impersonate the client (without stealing the self-
signed private key from the legitimate browser). However, it
does not prevent an impersonated server from supplying a
cacheable malicious JavaScript ﬁle to the client, which later
executes in the context of the victim website, and potentially
exﬁltrates data by reconnecting to the legitimate server. Fur-
ther, TLS-OBC requires code changes to the network stack on
servers (while HSTS and HPKP do not), and induces extra
computational costs for client certiﬁcate generation. Websites
should assess whether this is an acceptable trade-off.

D. Certiﬁcate Validation with Notaries

Perspectives [44] is a Firefox add-on that compares server
certiﬁcates against multiple notaries (with different network
vantage points) to reveal inconsistencies. Since public no-
taries observe certiﬁcates from diverse network perspectives,
a local impersonation attack could be easily detected. Conver-
gence [45] extends Perspectives by anonymizing the certiﬁcate
queries for improved privacy, while allowing users to conﬁgure
alternative veriﬁcation methods (such as DNSSEC). The De-
tecTor [46] project (which extends Doublecheck [47]) makes
use of the distributed Tor network to serve as external notaries.
Crossbear [48] further attempts to localize the attacker’s posi-
tion in the network using notaries. However, notary approaches
might produce false positives when servers switch between
alternative certiﬁcates, and clients may experience slower SSL
connection times due to querying multiple notaries during
certiﬁcate validation. Further, these pure client-side defenses
have not been adopted by mainstream browsers, thus cannot
protect the majority of (less tech-savvy) users.

94

E. Certiﬁcate Audit Logs

Several proposals have suggested the idea of maintaining
cryptographically irreversible records of all the legitimately-
issued certiﬁcates, such that mis-issued certiﬁcates can be
easily discovered, while off-the-record certiﬁcates are sim-
ply rejected. Sovereign Keys [49] requires clients to query
public timeline servers to validate certiﬁcates. Certiﬁcate
Transparency (CT) [50] removes the certiﬁcate queries from
clients by bundling each certiﬁcate with an audit proof of its
existence in the public log. Accountable Key Infrastructure
(AKI) [51] further supports revocation of server and CA
keys. These defenses are designed to protect against network
attackers (not including malware). However, browsers need
to be modiﬁed to support the mechanism, and changes (or
cooperation) are needed on the CAs or servers to deliver the
audit proof. Encouragingly, Google has announced their plan
to use Certiﬁcate Transparency for all EV certiﬁcates in the
Chrome browser [52].

F. DNS-based Authentication

DNS-based Authentication of Named Entities (DANE) [53]
allows the domain operator to sign SSL certiﬁcates for web-
sites on its domain. Similar to public key pinning defenses,
DANE could allow websites to instruct browsers to only accept
speciﬁc certiﬁcates. This approach prevents any CAs (gone
rogue) from issuing trusted certiﬁcates for any domain on the
Internet. Another related proposal, the Certiﬁcation Authority
Authorization (CAA) [54] DNS records, can specify that a
website’s certiﬁcates must be issued under a speciﬁc CA.
However, these approaches fundamentally rely on DNSSEC
to prevent forgery and modiﬁcation of the DNS records. Until
DNSSEC is more widely deployed on the Internet, websites
must consider alternative defenses.

G. Discussion

In this last section, we analyze the robustness of the possible
defenses with regards to four common types of SSL man-in-
the-middle attackers:

1) Script kiddie. A script kiddie is a relatively unskilled
individual who simply downloads attack toolkits that
have been created by others. These attackers generally
only attempt to perform attacks with less sophisticated
methods (with self-signed forged certiﬁcates) and on a
smaller scale, such as a local public WiFi hotspot. All of
the defenses are immune to script kiddies. Even HSTS
can block these attacks, because any invalid certiﬁcates
will hard-fail in supporting browsers.

2) Corporate-level surveillance. Most SSL man-in-the-
middle attacks are attributed to corporate-level surveil-
lance. In such scenarios, the corporate IT technicians
may access the client’s machine to establish trust with
their self-signed root certiﬁcates. SSL interception is
typically done without any authorization from the le-
gitimate websites. HSTS, by design, does not reject
browser-accepted certiﬁcates. HPKP also does not reject
certiﬁcates signed by locally trusted CAs, as mentioned

in Section V-B. Other defenses including audit logs and
notary-based approaches can detect these attacks.

3) Professional attacker. Next, we consider the profes-
sional attackers, which we deﬁne as an entity that has
managed to obtained a forged certiﬁcate from a trusted
CA. This classiﬁcation may include a state-sponsored
attacker who may compel trusted CAs to issue forged
certiﬁcates, or a sophisticated hacker who has success-
fully compromised a trusted CA directly. Server-side
defenses including CT, AKI, SK, TACK, and HPKP are
designed to block this type of mis-issued certiﬁcates,
although at varying deployment costs (e.g. HPKP is
the most lightweight in terms of server modiﬁcations).
Notary-based defenses may spot local inconsistencies if
the attacker mounted the attacks discriminately.

4) Malware. As discussed in Section IV-C, malware nowa-
days may also perform SSL interception. None of the
possible defenses are designed to prevent malware at-
tackers, which may have access to the victim client’s
machine, and simply tamper with the client’s root CA
store.

In all, websites may consider reaping the security beneﬁts
of deploying HSTS and HPKP defenses in conjunction, since
they are most readily supported in at least one of the major
browsers today. Unfortunately,
these two defenses do not
prevent all types of attacks such as corporate-level surveil-
lance, as discussed. Several defense proposals (and prototypes)
are more robust against most attacks (with the exception of
malware, which is out-of-scope), but are not yet available for
websites to use. Websites may want to stay agile and deploy
multiple approaches for defense in depth. In the meantime, we
recommend that websites or mobile applications can adopt our
detection method (as publicized in this paper), and possibly
collaborate to detect SSL interceptions in the wild.

VI. CONCLUSION

In this paper, we introduced a new method for detecting
SSL man-in-the-middle attacks against a website’s users. We
demonstrated the feasibility of detecting man-in-the-middle
attacks by implementing this mechanism on millions of SSL
connections at a top global website, Facebook. We presented
the ﬁrst analysis of forged SSL certiﬁcates in the wild. We
revealed direct evidences that 0.2% of real-world connections
were substituted with unauthorized forged certiﬁcates. While
most of the SSL interceptions were due to antivirus software
and corporate surveillance devices, we also observed a few
amateur attack attempts, and even traces of pervasive malware
in the wild that intercepted SSL connections. Our data suggest
that browsers could possibly detect many of the forged certiﬁ-
cates based on size characteristics, such as checking whether
the certiﬁcate chain depth is larger than one. We strongly
encourage popular websites, as well as mobile applications, to
deploy similar mechanisms to start detecting SSL interception.
Lastly, we assessed possible mitigations for SSL man-in-the-
middle attacks, and recommend websites to deploy multiple
available defenses, in conjunction, for better protection.

95

ACKNOWLEDGMENT

This work was done during Huang’s internship at Facebook.
We thank Adam Langley, Scott Renfro, Zack Weinberg, and
the anonymous reviewers for providing feedback on drafts
of the paper. Special thanks to Mark Hammell and Joren
McReynolds for their code reviews.

REFERENCES

[1] A. O. Freier, P. Karlton, and P. C. Kocher, “The Secure Sockets Layer
(SSL) Protocol Version 3.0,” RFC 6101 (Historic), Internet Engineering
Task Force, Aug. 2011.

[2] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) Protocol
Version 1.2,” RFC 5246 (Proposed Standard), Internet Engineering Task
Force, Aug. 2008.

[3] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk,
“Internet X.509 Public Key Infrastructure Certiﬁcate and Certiﬁcate
Revocation List (CRL) Proﬁle,” RFC 5280 (Proposed Standard), Internet
Engineering Task Force, May 2008.

[4] Electronic Frontier Foundation, “The EFF SSL Observatory,” https://

www.eff.org/observatory.

[5] VASCO, “DigiNotar reports security incident,” http://www.vasco.com/

company/about vasco/press room/news archive/2011/news diginotar
reports security incident.aspx, Aug. 2011.

[6] Comodo, “Comodo Report of Incident - Comodo detected and thwarted
an intrusion on 26-MAR-2011,” http://www.comodo.com/Comodo-
Fraud-Incident-2011-03-23.html, Mar. 2011.
announcements,”

http://turktrust.com.tr/en/

[7] TURKTRUST,

“Public

kamuoyu-aciklamasi-en.html, Jan. 2013.

[8] H. Adkins, “An update on attempted man-in-the-middle attacks,”
http://googleonlinesecurity.blogspot.com/2011/08/update-on-attempted-
man-in-middle.html.

[9] C. Soghoian and S. Stamm, “Certiﬁed lies: detecting and defeating
government interception attacks against SSL,” in Proceedings of the 15th
International Conference on Financial Cryptography and Data Security,
2011.

[10] S. E. Schechter, R. Dhamija, A. Ozment, and I. Fischer, “The emperor’s
new security indicators,” in Proceedings of the IEEE Symposium on
Security and Privacy, 2007.

[11] J. Sunshine, S. Egelman, H. Almuhimedi, N. Atri, and L. F. Cranor,
“Crying wolf: an empirical study of SSL warning effectiveness,” in
Proceedings of the 18th USENIX Security Symposium, 2009.

[12] D. Akhawe and A. P. Felt, “Alice in warningland: A large-scale ﬁeld
study of browser security warning effectiveness,” in Proceedings of the
22nd USENIX Security Symposium, 2013.

[13] A. P. Felt, H. Almuhimedi, S. Consolvo, and R. W. Reeder, “Experi-
menting at scale with Google Chrome’s SSL warning,” in Proceedings
of the ACM Conference on Human Factors in Computing Systems, 2014.
[14] P. Eckersley, “A Syrian man-in-the-middle attack against Facebook,”

https://www.eff.org/deeplinks/2011/05/syrian-man-middle-against-
facebook, May 2011.

[15] R. Holz, L. Braun, N. Kammenhuber, and G. Carle, “The SSL land-
scape: a thorough analysis of the x.509 PKI using active and passive
measurements,” in Proceedings of the ACM SIGCOMM Conference on
Internet Measurement, 2011.

[16] D. Akhawe, B. Amann, M. Vallentin, and R. Sommer, “Here’s my
cert, so trust me, maybe? Understanding TLS errors on the web,” in
Proceedings of the International Conference on World Wide Web, 2013.
[17] Z. Durumeric, J. Kasten, M. Bailey, and J. A. Halderman, “Analysis
of the HTTPS certiﬁcate ecosystem,” in Proceedings of the 13th ACM
SIGCOMM Conference on Internet Measurement, 2013.

[18] E. Butler, “Firesheep,” http://codebutler.com/ﬁresheep.
[19] S. Chen, Z. Mao, Y.-M. Wang, and M. Zhang, “Pretty-Bad-Proxy: An
overlooked adversary in browsers’ HTTPS deployments,” in Proceedings
of the IEEE Symposium on Security and Privacy, 2009.

[20] M. Georgiev, S.

Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov, “The most dangerous code in the world: validating
SSL certiﬁcates in non-browser software,” in Proceedings of the ACM
Conference on Computer and Communications Security, 2012.

[21] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B. Freisleben, and
M. Smith, “Why eve and mallory love Android: an analysis of Android
SSL (in)security,” in Proceedings of the ACM Conference on Computer
and Communications Security, 2012.

96

[22] S. Fahl, M. Harbach, H. Perl, M. Koetter, and M. Smith, “Rethinking
SSL development in an appiﬁed world,” in Proceedings of the ACM
Conference on Computer and Communications Security, 2013.

[23] M. Marlinspike,

“sslsniff,”

http://www.thoughtcrime.org/software/

sslsniff.

[24] C. Reis, S. D. Gribble, T. Kohno, and N. C. Weaver, “Detecting in-ﬂight
page changes with web tripwires,” in Proceedings of the 5th USENIX
Symposium on Networked Systems Design and Implementation, 2008.
the
effect of edge opacity on IP-based client identiﬁcation,” in Proceedings
of
the 4th USENIX Symposium on Networked Systems Design and
Implementation, 2007.

[25] M. Casado and M. J. Freedman, “Peering through the shroud:

[26] C. Jackson, A. Barth, A. Bortz, W. Shao, and D. Boneh, “Protecting
browsers from DNS rebinding attacks,” in Proceedings of the ACM
Conference on Computer and Communications Security, 2007.

[27] L.-S. Huang, E. Y. Chen, A. Barth, E. Rescorla, and C. Jackson, “Talking
to yourself for fun and proﬁt,” in Proceedings of the Web 2.0 Security
and Privacy, 2011.

[28] C. Kreibich, N. Weaver, B. Nechaev, and V. Paxson, “Netalyzr: Illu-
minating the edge network,” in Proceedings of the ACM SIGCOMM
Conference on Internet Measurement, 2010.

[29] S. Stamm, B. Sterne, and G. Markham, “Reining in the web with content
security policy,” in Proceedings of the 19th International Conference on
World Wide Web, 2010.

[30] P. Uhley, “Setting up a socket policy ﬁle server,” http://www.adobe.com/

devnet/ﬂashplayer/articles/socket policy ﬁles.html, Apr. 2008.

[31] StatOwl.com, “Flash player version market share and usage statistics,”

http://www.statowl.com/ﬂash.php.

[32] R. A. Sandvik, “Security vulnerability found in Cyberoam DPI
https://blog.torproject.org/blog/security-

devices
vulnerability-found-cyberoam-dpi-devices-cve-2012-3372, Jul. 2012.

(CVE-2012-3372),”

[33] Y. N. Pettersen, “Suspected malware performs man-in-the-middle
attack on secure connections,” http://my.opera.com/securitygroup/blog/
2012/05/16/suspected-malware-performs-man-in-the-middle-attack-on-
secure-connections, May 2012.

[34] J. Hodges, C. Jackson, and A. Barth, “HTTP Strict Transport Security
(HSTS),” RFC 6797 (Proposed Standard), Internet Engineering Task
Force, Nov. 2012.

[35] C. Jackson and A. Barth, “ForceHTTPS: protecting high-security web
sites from network attacks,” in Proceedings of the 17th International
Conference on World Wide Web, 2008.

[36] M. Marlinspike, “New techniques for defeating SSL/TLS,” in Black Hat

DC, 2009.

[37] C. Evans and C. Palmer, “Public Key Pinning Extension for HTTP,”

IETF, Internet-Draft draft-ietf-websec-key-pinning-03, Oct. 2012.

[38] A. Langley, “Public key pinning,” http://www.imperialviolet.org/2011/

05/04/pinning.html.

[39] C. Paya, “Certiﬁcate pinning in Internet Explorer with EMET,”

http://randomoracle.wordpress.com/2013/04/25/certiﬁcate-pinning-in-
internet-explorer-with-emet/.

[40] M. Marlinspike and E. T. Perrin, “Trust Assertions for Certiﬁcate Keys,”

IETF, Internet-Draft draft-perrin-tls-tack-02, Jan. 2013.

[41] I. Dacosta, M. Ahamad, and P. Traynor, “Trust no one else: Detecting
MITM attacks against SSL/TLS without third-parties,” in Proceedings
of the European Symposium on Research in Computer Security, 2012.
[42] “Certiﬁcate Patrol - a psyced Firefox/Mozilla add-on,” http://patrol.

psyced.org.

[43] M. Dietz, A. Czeskis, D. Balfanz, and D. Wallach, “Origin-bound
certiﬁcates: A fresh approach to strong client authentication for the web,”
in Proceedings of the 21st USENIX Security Symposium, 2012.

[44] D. Wendlandt, D. Andersen, and A. Perrig, “Perspectives: Improving
SSH-style host authentication with multi-path probing,” in Proceedings
of the USENIX Annual Technical Conference, 2008.

[45] M. Marlinspike, “SSL and the future of authenticity,” in Black Hat USA,

2011.

[46] K. Engert, “DetecTor,” http://detector.io/DetecTor.html.
[47] M. Alicherry and A. D. Keromytis, “Doublecheck: Multi-path ver-
iﬁcation against man-in-the-middle attacks,” in IEEE Symposium on
Computers and Communications, 2009.

[48] R. Holz, T. Riedmaier, N. Kammenhuber, and G. Carle, “X. 509
forensics: Detecting and localising the SSL/TLS men-in-the-middle,”
in Proceedings of the European Symposium on Research in Computer
Security, 2012.

https://git.eff.org/?p=sovereign-keys.git;a=blob;f=sovereign-key-
design.txt;hb=master.

[50] B. Laurie, A. Langley, and E. Kasper, “Certiﬁcate Transparency,” IETF,

[49] P. Eckersley, “Sovereign key cryptography for

internet domains,”

Internet-Draft draft-laurie-pki-sunlight-02, Oct. 2012.

[51] T. H.-J. Kim, L.-S. Huang, A. Perrig, C. Jackson, and V. Gligor,
“Accountable Key Infrastructure (AKI): A proposal for a public-key
validation infrastructure,” in Proceedings of the International Conference
on World Wide Web, 2013.

[52] R. Sleevi, “[cabfpub] Upcoming changes to Google Chrome’s certiﬁ-
cate handling,” https://cabforum.org/pipermail/public/2013-September/
002233.html, 2013.

[53] P. Hoffman and J. Schlyter, “The DNS-Based Authentication of Named
Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA,” RFC
6698 (Proposed Standard), Internet Engineering Task Force, Aug. 2012.
[54] P. Hallam-Baker and R. Stradling, “DNS Certiﬁcation Authority Au-
thorization (CAA) Resource Record,” RFC 6844 (Proposed Standard),
Internet Engineering Task Force, Jan. 2013.

97

