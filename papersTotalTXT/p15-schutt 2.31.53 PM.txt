Early Detection of

Malicious Behavior in JavaScript Code

Technische Universität Berlin

Technische Universität Berlin

Kristof Schütt

Berlin, Germany

Marius Kloft

Berlin, Germany

Alexander Bikadorov

Technische Universität Berlin

Berlin, Germany

Konrad Rieck

University of Göttingen
Göttingen, Germany

ABSTRACT
Malicious JavaScript code is widely used for exploiting vul-
nerabilities in web browsers and infecting users with mali-
cious software. Static detection methods fail to protect from
this threat, as they are unable to cope with the complexity
and dynamics of interpreted code. In contrast, the dynamic
analysis of JavaScript code at run-time has proven to be
eﬀective in identifying malicious behavior. During the exe-
cution of the code, however, damage may already take place
and thus an early detection is critical for eﬀective protec-
tion. In this paper, we introduce EarlyBird: a detection
method optimized for early identiﬁcation of malicious be-
havior in JavaScript code. The method uses machine learn-
ing techniques for jointly optimizing the accuracy and the
time of detection.
In an evaluation with hundreds of real
attacks, EarlyBird precisely identiﬁes malicious behavior
while limiting the amount of malicious code that is executed
by a factor of 2 (43%) on average.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and protection; I.5.1 [Pattern Recognition]: Mod-
els—Statistical

Keywords
JavaScript Attacks, Dynamic Analysis, Machine Learning

1.

INTRODUCTION

Malicious JavaScript code in web pages has become one
of the major threats in the Internet. JavaScript code often
provides the basis for drive-by-download attacks that unno-
ticeably infect users with malicious software during the visit
of a web page. These attacks are conducted at a large scale

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
AISec’12, October 19, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1664-4/12/10 ...$10.00.

and according to a recent study reach millions of victims
per day [24]. Unfortunately, the JavaScript language pro-
vides a perfect platform for these attacks, as it allows for
programmatically probing and exploiting vulnerabilities in
web browsers and their extensions.

In contrast to other types of network attacks, malicious
JavaScript code is particularly hard to detect in the content
of web pages. As the code is directly interpreted during the
visit of a web page, the attacker is able to literally program
his attack. For example, JavaScript attacks often probe for
the browser environment, check for particular vulnerabilities
and use dynamic exploiting techniques, such as heap spray-
ing, for compromising a victim’s system. Even worse, the
direct execution of the code also enables eﬀectively obfuscat-
ing the attack, such that indicative patterns are only visible
at run-time and not accessible by static detection methods,
such as conventional anti-virus scanners.

As a result of this development, the detection of mali-
cious JavaScript code at run-time has gained a focus in se-
curity research. Several methods have been developed for
dynamically spotting malicious activity, which range from
speciﬁc detection systems for certain attack types [e.g., 7, 18]
to general-purpose systems that inspect the behavior using
various analysis techniques [e.g., 4, 12, 13]. The diﬃculty
of manually crafting rules for malicious behavior has further
motivated the application of machine learning techniques.
Several detection systems have been proposed that apply
learning methods to automatically distinguish benign from
malicious behavior, for example, the detectors Cujo [20],
Zozzle [6] and IceShield [9].

While these learning-based detectors provide an accurate
identiﬁcation of malicious code at run-time, none of the de-
tectors is optimized for an early detection of attacks. The
longer a malicious code runs before it is detected, the more
harm it can cause to the underlying system. Consequently,
the aspired protection can be signiﬁcantly weakened, if ma-
licious behavior is identiﬁed too late. However, spotting at-
tacks early is not a trivial task, as it imposes two challenges
on a detector’s design: First, malicious behavior should be
detected as fast as possible, but never at the expense of ac-
curacy. Second, the detection needs to be resistant against
evasion that simply delays malicious activity to a later point
in the execution of the code.

In this paper, we address the problem of detecting mali-
cious behavior in JavaScript code as early as possible. We

15introduce EarlyBird: a learning method optimized for fast
identiﬁcation of malicious behavior. EarlyBird extends
the learning algorithm of support vector machines [15, 23],
such that the accuracy and the time of detection are jointly
optimized during learning. The method is integrated into
the Cujo detector [20] and allows for an early identiﬁcation
of malicious behavior with no loss of accuracy. Moreover,
it is resistant against evasion attacks delaying malicious be-
havior during the execution.

We demonstrate the capabilities of EarlyBird in an em-
pirical evaluation with real JavaScript code from 100,000
benign web pages and 609 drive-by-download attacks. Our
method detects 93.2% of the attacks with less than 5 false
alarms and performs on par with related detection approaches.
In contrast to other approaches, EarlyBird limits the amount
of malicious code that is executed during the analysis by a
factor of 2 (43%), resulting in a better protection of the
underlying system.

The rest of this paper is organized as follows: we consider
the generic detection of malicious behavior using machine
learning in Section 2. Our method EarlyBird is introduced
in Section 3 and an empirical evaluation of its performance
is presented in Section 4. Finally, Section 5 reviews related
work and Section 6 concludes.

2. RUN-TIME DETECTION

Before introducing EarlyBird, we study the process of
detecting malicious behavior using machine learning in the
general case. We formalize some aspects of this process and
thereby establish a mathematical view on the problem. We
focus on the learning-based detector Cujo, as it provides the
basis for the implementation of EarlyBird. Nonetheless,
our approach is agnostic to the detector and could be incor-
porated in the detectors Zozzle or IceShield with minor
modiﬁcations.
2.1 Run-time Monitoring

Identifying malicious activity in web pages requires a de-
tection system to monitor the execution of JavaScript code
at run-time. This monitoring is often realized by executing
the code in a separate sandbox [e.g., 4, 20] or by interacting
with the JavaScript engine of the web browser [e.g., 6, 9].
In both settings the ﬂow of the execution is tracked using
events that indicate changes in the state of the environment.
Depending on the granularity of the monitoring, these events
may range from calls to certain JavaScript functions to the
observation of every state-changing action.

As an example, Figure 1 shows a snippet of a JavaScript
attack and Figure 2 the corresponding events monitored by
Cujo. The detector supports ﬁve basic types of events,
where each type is recorded with respective arguments dur-
ing the execution. For example, line 3 in Figure 2 shows
a SET event that assigns the string “exe” to an internal ob-
ject. The code snippet contains a trivial form of obfuscation
that hides the download of an executable ﬁle. After a series
of diﬀerent events, this hidden download is revealed in the
FUNCTIONCALL event at lines 11–12 of Figure 2.

To formally describe this process of run-time monitoring,
we consider a set of events E, such that the execution of
JavaScript code in web pages results in a sequence x of these
events, that is,

x = (e1, e2, . . . , en) with ei ∈ E.

1 a=new Array("XML", "foo", "exe")
2 try {
3

o=new ActiveXObject("MS2"+a[0]+"."+a[0]+"HTTP")
o.open("GET","http://"+a[1]+".com/x." + a[2],true);

4
5 } catch(e) {};

Figure 1: Obfuscated JavaScript code.

1 SET CUSTOM_OBJECT_22.0 TO "XML"
2 SET CUSTOM_OBJECT_22.1 TO "foo"
3 SET CUSTOM_OBJECT_22.2 TO "exe"
4 SET global.a TO CUSTOM_OBJECT_22
5 CONVERT ActiveXObject TO A FUNCTION
6 CONSTRUCTOR ON CUSTOM_OBJECT_24 CALLED
7 SET global.o TO NEW_OBJECT_FROM_CONSTRUCTOR
8 CONVERT NEW_OBJECT_FROM_CONSTRUCTOR TO A OBJECT
9 CALL open

10 CONVERT NEW_OBJECT_FROM_CONSTRUCTOR.open TO A FUNCTION
11 FUNCTIONCALL open ("GET", "http://foo.com/x.exe",
12

"BOOLEAN PRIMITIVE true")

Figure 2: Example of monitored events.

Diﬀerent features can be derived from the monitored events,
for example, Zozzle constructs abstract syntax trees from
executed code and Cujo extracts q-grams of tokens from
the events and their arguments. Without loss of generality
these derived features can be viewed as events themselves
and thus it suﬃces in our case to consider sequences of events
for modeling the detection process.
2.2 From Events to Vectors

Sequences are a natural representation of behavior, yet
they are not directly suitable for the application of learning
methods, as these usually operate on vectorial data. To ad-
dress this problem, we map each sequence x of monitored
events to a vector φ(x). Our map φ : x (cid:55)→ R|E| embeds x
in a binary vector space spanned by all observable events E.
A dimension in φ(x) is 1 if the corresponding event occurs
in the sequence x and 0 otherwise. Using an indicator func-
tion Ie, we can express this map as follows

(cid:40)

φ : x → (Ie(x))e∈E with Ie(x) =

1 if e occurs in x
0 otherwise.

Note that depending on the size of E the resulting vec-
tor space may yield a huge dimensionality. Fortunately, a
sequence of n events, only induces n non-zero dimensions in
the vector space and thus the map φ is sparse. This sparsity
can be exploited to eﬃciently operate in the vector space and
apply learning methods with little overhead [see 19].

The map φ enables us to describe the problem of detect-
ing malicious behavior using the geometry of the mapped
sequences. Instead of matching patterns directly, we can use
geometric models, such as hyperplanes and hyperspheres, to
derive detection models. Moreover, the mapping enables us
to apply standard optimization techniques to tune the de-
tection for an early identiﬁcation of malicious activity.
2.3 Learning and Detection

Once the sequences of events have been mapped to a
vector space, several algorithms from the area of machine
learning can be applied for detecting malicious behavior of
JavaScript code. For analyzing behavior dynamically, lin-
ear detection methods are favorable over involved learning

16algorithms, as they allow to eﬃciently update the detection
function during operation.

For the construction of EarlyBird we focus on linear
support vector machines [SVM, 5, 8] which are also used in
the Cujo detector. Given vectors of two classes as training
data, a linear SVM learns a hyperplane in the vector space
that separates the two classes with maximum margin.
In
our setting, these classes correspond to sequences of mon-
itored events for benign (−) and malicious (+) JavaScript
code. The hyperplane is learned by determining a weight
vector w specifying its direction and a bias b specifying its
oﬀset from the origin. The detection function of an SVM
for an unknown sequence x of events is given by
Ie(x) we + b.

f (x) = (cid:104)φ(x), w(cid:105) + b =

(cid:88)

e∈E

where f (x) simply returns the orientation of φ(x) with re-
spect to the hyperplane. That is, f (x) > 0 indicates mali-
cious behavior in the sequence x and f (x) ≤ 0 corresponds
to benign activity.

The computation of f amounts to a simple summation of
linear terms over the events E, where the indicator function
Ie(x) picks only those e occurring in x. Consequently, we
can unroll this summation and express f (x) as follows

f (x) = we1 + we2 + . . . + wen

+b.

events occurring in x

(cid:123)(cid:122)

(cid:125)

(cid:124)

The indication function Ie(x) can be omitted here, as it is
only 1 for events occurring in x. This formulation allows us
to compute f incrementally and thereby provides the basis
for an early detection of attacks. Whenever a new event ei
is monitored, f (x) is updated by adding the corresponding
weight wei from the vector w to f (x). If the update results
in the condition f (x) > 0, malicious behavior is detected
and an alert can be raised.

Similar learning methods are also applied in other detec-
tors for malicious JavaScript code. For example, IceShield
uses linear discriminant analysis for detection of malicious
code. Similar to SVMs, this learning method also determines
a vector w and a bias b, and thus with minor modiﬁcations
can also be updated at run-time.

3. EARLY DETECTION

After discussing the generic of detection malicious behav-
ior, we turn to the temporal aspect of our work. Since the
detection is to be applied during the execution of possibly
malicious code, an alert should be raised as early as possible.
On the other hand, the overall performance in regard to a
high detection rate and few false alarms shall not be sacri-
ﬁced for earliness. As a remedy, we propose EarlyBird, a
method for early detection of malicious code based on the
paradigm of support vector machines [3, 15, 23].
3.1 Core Idea: Temporal Weighting

The general idea of our approach is to favor dimensions
in the vector space corresponding to malicious events that
occur early in time, while penalizing those corresponding to
events that occur in the ﬁnal execution phase of malicious
code and thus are not of much use for early detection.

For an illustration consider Figures 3 (a) and (b), which
depict the temporal weightings of a regular SVM and the
proposed EarlyBird method, respectively. We can observe

(a) Regular SVM

(b) EarlyBird SVM

(c) Truncated SVM

Figure 3: Schematic depiction of temporal weight-
ings for the regular SVM, EarlyBird SVM and the
truncated SVM.

from the ﬁgure that EarlyBird uses a temporal weighting
that smoothly decreases over time (as detailed in the next
section). Note, that we only penalize events from malicious
code to avoid overﬁtting to early benign behavior. For com-
parison with EarlyBird we also consider a truncated SVM
as depicted in Figure 3(c). The truncated SVM is identi-
cal to a regular SVM except that all sequences of events
for learning are truncated at a speciﬁed point. As a conse-
quence, the truncated SVM is forced to pick early events for
learning a detection model.
3.2 The EarlyBird SVM

In this section, we mathematically introduce the employed
learning method. To this end, we use the following notation
for weighted Lp-norms (p ≥ 1), where the circle operator
represents the element-wise product between vectors,

(cid:107)w(cid:107)(p,λ) = (cid:107)λ ◦ w(cid:107)p

(cid:115)(cid:88)

e∈E

= p

|λewe|p.

Given a vector λ = (λe)e∈E of time penalties for each
observed event, the core learning problem of this paper,
EarlyBird, is given as follows:

min

w

(cid:107)w(cid:107)p

(cid:124)(cid:123)(cid:122)(cid:125)

p

regularizer

+ C1

N(cid:88)
(cid:124)

i=1

(cid:96) (yi,(cid:104)w, φ(xi)(cid:105))

+ C2 (cid:107)w(cid:107)q

,

(q,λ)

(cid:123)(cid:122)

training loss

(cid:125)

(cid:125)

(cid:124)

(cid:123)(cid:122)

time

penalty

where (cid:96) : R → R denotes a convex loss function that incurs
a penalty if a sequence of events is misclassiﬁed.

We can interpret the above mathematical optimization
problem as follows: the goal is to minimize the training loss
(≈ error on the training data), while the regularizer avoids
overﬁtting and ensures that we obtain a small error on un-
seen data. Additionally, the time penalizer discourages se-
lecting late occurring events. Its inﬂuence depends on the
time penalty vector λ and the weight vector w. The pa-
rameters C1 and C2 trade oﬀ loss against time and need to

Time Weights →Time Weights →maliciousbenignTime Weights →17be tuned empirically on a hold-out set. If a data set is un-
suitable for early prediction, a proper tuning will simply let
EarlyBird degenerate to the regular SVM with C2 = 0.

The norm parameters p and q regulate the sparseness of
the weights. Small values of q lead to EarlyBird focusing
on a few high-weighted early events, while larger values tend
to suppress those in favor of more events with moderate time
penalty and weight. In this case, early events will be aﬀected
only marginally. A good compromise it thus setting q = 2,
which is our choice for the experiments.

The formulation of EarlyBird can be signiﬁcantly sim-
pliﬁed if we set p = q. In this case, we can deﬁne a vector
e)e∈E and rewrite the optimization problem

h = ( p√

1 + C2λp

as follows

min

w

(p,h)

+ C1

(cid:124)

(cid:107)w(cid:107)p

(cid:123)(cid:122)

(cid:125)

time-weighted

regularizer

N(cid:88)
(cid:124)

i=1

(cid:96) (yi,(cid:104)w, φ(xi)(cid:105)) .

(cid:123)(cid:122)

training loss

(cid:125)

Instead of having independent terms for the time penalty
and the regularization, we obtain a formulation consisting
of a time-weighted regularizer and the training loss. This
formulation shares similarities with a so-called regularized
risk minimization problem [25].
In fact, by introducing a
weighted feature map ˜φ(x) = h−1 ◦ φ(x) and substituting
w with ˜w := h ◦ w, we arrive at a classic, regularized risk
minimization problem

min

˜w

(cid:107) ˜w(cid:107)p

(cid:124)(cid:123)(cid:122)(cid:125)

p

time-weighted

regularizer

+ C1

N(cid:88)
(cid:124)

i=1

(cid:96)

(cid:16)

yi,(cid:104) ˜w, ˜φ(xi)(cid:105)(cid:17)
(cid:123)(cid:122)

training loss

(1)

.

(cid:125)

Similar formulations of learning problems have been widely
studied and there exists several techniques for eﬃciently de-
termining their optima. As we are interested in SVMs, all
that needs to be done is setting the loss function in Eq. (1)
to the loss of the SVM, (cid:96)(y, f (x)) = max(0, 1 − yf (x)), and
we obtain a formulation that can be easily minimized using
standard SVM solvers.

For eﬃcient computation, we additionally derive the dual
problem of Eq. (1) and thereby realize the time-weighting
solely in terms of a kernel function

k(xi, xj) = (cid:104)h

−1 ◦ φ(xi), h
= (cid:104) ˜φ(xi), ˜φ(xj)(cid:105)

−1 ◦ φ(xj)(cid:105)

Note that we can still calculate our original weight vector
using back-substitution and the representer theorem [21],

w = h

−1 ◦ ˜w

−1 ◦ h

= (h

−1) ◦ N(cid:88)

i=1

yiαi(φ(xi)).

(2)

The technical derivation of the dual problem for Eq. (1)
is provided in Appendix B. After this, there is no need
for individual time-weighting of incoming events, as this is
done implicitly by the learned w. Consequently, the explicit
time-weighting of events is only needed during the training
of EarlyBird.
3.3 Time Penalty

So far, we have shown how our method EarlyBird jointly
optimizes the error (training loss) and the time of detection

(time-weighted regularizer). However, we have not discussed
how the time penalties λ for events in our method are de-
ﬁned. For this deﬁnition we ﬁrst need to specify a measure
of time. In the case of JavaScript, a natural measure is the
position of an event in the monitored sequence of events. We
deliberately do not consider the time passing between events
but just their positions, as this measure is robust against
temporal noise and independent of the concrete execution
speed of the detector.

Formally, we deﬁne the time t(x, e) of an event e in a se-

quence x as the ﬁrst position of e occurring in x = (e1, . . . , en),
that is,

t(x, e) :=

if ∃ei = e with ei (cid:54)= ej for j < i

i

0 otherwise.

(cid:40)

Note that further occurrences of events do not need to be
considered here, since they provide no additional informa-
tion when using a binary vector space. If an event is not
part of the sequence x, its time value will be zero, so that
the penalty will not be inﬂuenced.
Moreover, given a set X + of sequences containing mali-
cious behavior, we deﬁne E+ ⊆ E to be the set of events
occurring in at least one of these sequence. For each event
e ∈ E+, we calculate the average position µe of its occur-
rences in the set X + as follows

(cid:88)

x∈X+

µe =

1
M

t(x, e),

where M is the number of sequences in X + that contain the
event e. For all other events not occurring in X +, we simply
set µe = 0. Based on this deﬁnition of µe, we can deﬁne the
time penalty vector λ as

(cid:16)

(cid:17)

λ :=

a
p
e

µ

.

e∈E

The parameter a controls the steepness of the penalty and
is tuned empirically in our experiments. A higher choice of a
implies increased suppression of late events relative to early
events. Finally, we obtain the following time-weighting of
events which is implemented in EarlyBird,

−1 =

h

p(cid:113)

1

.

1 + (µa

e )e∈E

4. EMPIRICAL EVALUATION

After discussing the rather technical details of our method,
we proceed to present an empirical evaluation using real
JavaScript code of malicious and benign web site. Besides
studying the overall detection performance of EarlyBird,
we focus on experiments concerning the performance over
time. Furthermore, we examine the robustness against sim-
ple evasion attacks and provide exemplary explanation for
the earlier detection compared to the regular SVM.
4.1 Evaluation Data

As a data set of (mostly) benign JavaScript code, we con-
sider the 100,000 most visited web sites according to the
Alexa ranking1. Each of these web sites is visited automati-
cally and its JavaScript code is executed using the dynamic
analysis implemented in the Cujo detector. While we can

1Alexa Top Sites, http://www.alexa.com/topsites

18not rule out the presence of some malicious behavior in this
set, our experiments do not indicate any inﬂuence from such
behavior on the ﬁnal results.

Table 1 lists the data sets of malicious JavaScript code
used in our experiments together with their origin and size.
These attacks have already been used to evaluate Cujo.
Malware Forum, Spam Trap, SQL Injection and Wepawet
are taken from Cova et al. [4], whereas the Obfuscated set
consists of 84 additionally generated obfuscated attacks from
the other sets [see 20].

Data sets

Origin

# attacks

Malware Forum Internet forums
Spam Trap
SQL Injection
Wepawet
Obfuscated

URLs spread by spam
Injection into benign web sites
Submissions to Wepawet service
Additionally obfuscated attacks

256
22
201
46
84

Table 1: Description of the attack data sets.

To emphasize the need for an early detection of malicious
activity, Figure 4 presents histograms of the number of mon-
itored events for both data sets. We observe that there are
short and long sequences for both malicious and benign web
sites with up to 106 events. Clearly, there is potential to re-
duce the ratio of executed malicious code and limit possible
damage with our approach to early detection.

(a) Benign web pages.

(b) Malicious web pages.

Figure 4: JavaScript events when visiting benign
and malicious web pages.
The distribution is
smoothed using a cubic spline (black line).

4.2 Experimental Setting

In our experiments, the detection performance is mea-
sured in terms of true-positive rate and false-positive rate.
As our method requires labeled data for learning, we split
each data set into a known partition (75%) and an unknown
partition (25%). The known partition is used to train the
classiﬁer and determine the parameters. The detection per-
formance is measured on the unknown data set, thus all de-
tected attacks are unknown during the learning phase. To
achieve statistical sound results, we repeat this procedure
50 times and average the results.

EarlyBird operates over time so that all attacks de-
tected during run-time need to be taken into account. It is
not suﬃcient to only evaluate the attacks a posteriori, i.e.,
after all events of a script have been observed. To tackle
this, we take snapshots of detected attacks at predeﬁned
numbers of already observed events. The accumulated true-
positive rates TPRt and false-positive rates FPRt are then

determined on the union of snapshots taken until t events
have been observed.

Furthermore, we need an appropriate target function for
parameter selection. Given the vector of true-positive rates
on the snapshots TPR = (TPRi)i=1...N and the numbers
of observed events at those snapshots t = (ti)i=1...N with
ti < ti+1, we choose the parameters of EarlyBird that
maximize the following function on the known partition

(cid:18) ti+1

(cid:19)

.

ti

ftarget(T P R, t) =

TPRi log

N−1(cid:88)

i=1

The detection threshold of the SVM (bias b) for each snap-
shot is then determined so that there are no false alarms on
the known partition. The snapshot times t for the experi-
ments are chosen to be on a logarithmic scale. In our ex-
perimental setting, they are used not only for parameter se-
lection, but also for testing. The logarithmic scale is chosen
to emphasize early detection. Besides that, later occurring
events have less inﬂuence relative to the events already seen,
so later detections are less frequent.
4.3 Detection Performance

We ﬁrst study the overall performance of EarlyBird,
that is, the accumulated true-positive and false-positive rates.
As a simple baseline, we use the truncated SVM that only
considers the ﬁrst 100 observed events during training. We
further evaluate two setups for the regular SVM: Testing
over time with accumulated detections as described in the
previous section and testing with the full behavior as re-
alized in Cujo. Moreover, we run the anti-virus scanner
AVG Anti-Virus against our data as a baseline for static
detection of malicious JavaScript code.

Table 2 shows the ﬁnal detection performances of the con-
sidered methods for each data set individually as well as
averaged over all sets. The left part of the table presents
methods capable of detecting malicious code at run-time
(EarlyBird, truncated SVM and the SVM over time), while
the right part shows approaches only detecting attacks at the
end of monitoring (the SVM as implemented in Cujo and
the anti-virus scanner AVG Anti-Virus).

EarlyBird achieves the highest averaged true-positive
rate with 93.2%. The method outperforms each of the other
methods in three out of ﬁve attack sets. In contrast to results
reported in [20], the second best method is the anti-virus
scanner. As all of the considered attacks are over one year
old, it is not surprising that corresponding signatures have
been added to anti-virus scanners by now. While Early-
Bird can not quite reach the low false-positive rates of ap-
proaches applied to the full monitored behavior, it achieves
the lowest false-positive rate of the methods operating over
time. Those approaches have the disadvantage that they ac-
cumulate not only true-positives but also false-positives. It
is an important insight that the increased false-positive rates
are not caused by the emphasis on early prediction but are
a generic problem of detection methods operating over time.
4.4 Detection Time

After demonstrating the overall performance of Early-
Bird, we explore its time-based detection in more detail.
The truncated SVM and the regular SVM over time will
serve as comparison, again.

First, we want to study which ratio of malicious code is
executed before an attack is detected. Attacks that are not

101102103104# of events per visit0.00.51.01.52.02.5Frequency (%)101102103104# of events per visit0.00.51.01.52.02.5Frequency (%)19Data sets

EarlyBird

TPR

FPR

Truncated SVM SVM (over time)
TPR
FPR

TPR

FPR

Alexa-100k
Malware Forum
Spam Trap
SQL Injection
Wepawet
Obfuscated

-
81.9%
100.0%
99.0%
92.8%
98.9%

0.005%
-
-
-
-
-

-
75.5%
95.8%
86.3%
90.3%
97.5%

0.012%
-
-
-
-
-

-
75.2%
98.3%
99.7%
89.0%
99.0%

0.010%
-
-
-
-
-

SVM (end)

AVG

TPR

-
70.5%
98.1%
99.0%
87.5%
97.0%

FPR

TPR

FPR

0.000%
-
-
-
-
-

-
93.0%
88.3%
95.5%
100.0%
25.0%

0.002%
-
-
-
-
-

Average

93.2% 0.005% 88.5% 0.012% 90.1% 0.010% 88.0% 0.000%

91.8% 0.002%

Table 2: Accumulated true-positive and false-positive rates of all evaluated detection approaches. Methods
on the left detect attacks over time, while methods on the right identify attacks at the end of their execution.

Data sets

EarlyBird Truncated SVM

SVM

Malware Forum
Spam Trap
SQL Injection
Wepawet
Obfuscated

Average

46.4%
33.7%
55.7%
54.8%
57.2%

43.6%

49.4% 68.2%
42.4% 70.0%
47.9% 78.7%
50.7% 80.8%
28.9% 69.5%

43.8% 70.5%

Table 3: Ratios of executed code of EarlyBird, reg-
ular SVM and truncated SVM.

detected are considered to be 100% executed. Table 3 shows
those ratios for each attack set. This experiment is per-
formed on snapshots, so the values can be understood as
upper bounds. As expected, the SVM detects attacks the
latest of the three compared methods because it is not opti-
mized for early detection. With an average execution ratio
of 70.5%, it executes more than 1.5 times the code of Early-
Bird and the truncated SVM. Those lie level at 43.6% and
43.8% execution ratio, respectively.

We additionally study the performance over time in terms
of true-positive rate. Since it does not matter when a benign
example is misclassiﬁed as an attack, the false-positive rate
does not need to be analyzed time-wise.

Figure 5 shows the results of this experiment. Most of
the time, EarlyBird performs best and it succeeds in its
main objective of early detection. The truncated SVM is
only for a short period time better than our method, while
the regular SVM is outperformed completely. After 1,000
observed events, our method detects 91.4% of the attacks,
while the regular SVM achieves a rate of 65.5%. Only af-
ter more than 30.000 observed events, the SVM attains a
true-positive rate of 90%. Thus, EarlyBird reaches this
detection performance more than 30 times faster than the
regular SVM in this experiment.
4.5 Explanation

An advantage of the linear SVM over other learning al-
gorithms is that the learned weight vector can be analyzed
for explaining the detection of attacks [see 20]. In particu-
lar, we use this technique to study why EarlyBird identi-
ﬁes attacks faster than the regular SVM. In contrast to the
previous experiments, we now have to look at the speciﬁc
events that achieved high weights during learning. Since
EarlyBird builds on Cujo each event here corresponds to
a 3-gram of tokens from the dynamic analysis.

Figure 6 shows the ﬁve highest increases and decreases
of contributions of an attack from the Malware Forum set
in comparison with the regular SVM. Non-printable binary

Figure 5: Accumulated true-positive rates over time
of EarlyBird, regular SVM and truncated SVM.

data occurring has been replaced by ”. . . ”. All top 5 in-
creases include the word unescape which signals an obfus-
cation. Those events occur very early at an average of 8.5
to 10.5 observed events.
In contrast, the top 5 decreases
in Figure 6(b) occur quite late and represent the features
indicating the actual attack. HEAPSPRAYING DETECTED is an
event triggered by the sandbox used in Cujo reﬂecting un-
usual memory activity. Obviously we want to detect the
attack before the sandbox does.

For the presented example, EarlyBird seems to detect
the attack faster than the regular SVM, because it focuses
on the obfuscation instead of the heap spraying. However,
this is only a small extract from a far more complex de-
tection model with several millions of events. Neither is the
detected obfuscation the only factor taken into consideration
by EarlyBird for this example nor does the result imply a
general detection preference of obfuscation over full attacks.

4.6 Evasion Attempts

Finally, we explore how robust EarlyBird is against sim-
ple evasion attempts. Using the average time of events for
early detection could possibly expose new vulnerabilities.
An attack that is padded with benign events at the begin-
ning might exploit the increased emphasis on early events
and evade the detection.

For this experiment, we modify the malicious behavior
such that it is padded at the beginning with the 100 events
taken randomly from benign behavior. We then explore two
diﬀerent evasion setups:

• Padding of 10% of both the unknown and known par-

1001021041060%25%50%75%100%TPR# of observed events  EarlyBirdTruncated SVMSVM20Change Feature

s ∈ S (3-grams of words)
OBJECT CALL unescape

NATIVE FUNCTIONCALL unescape

unescape NATIVE FUNCTIONCALL

CALL unescape NATIVE

FUNCTIONCALL unescape SET

(a) Top 5 contribution increases

∆ws · φs(x)
0.059
0.051
0.051
0.051
0.044

∆ws · φs(x)
-0.795
-0.628
-0.103
-0.102
-0.101

Change Feature

s ∈ S (3-grams of words)
CALL substring SET

TO HEAPSPRAYING DETECTED

TO "..." SET

TO "..." SET

TO "..." SET

(b) Top 5 contribution decreases

Time
µe
8.5
9.5
9.5
9.5
10.5

Time
µe
3068.3
2700.5
3706.2
3692.5
3685.2

Figure 6: Exemplary explanation of faster detection
by EarlyBird.

tition, corresponding to the case where training data
is poisoned.

• Padding of 10% of the unknown partition only, corre-
sponding to the case where the evasion attack starts
after the training.

The results for this experiment are presented in Table 4
and Figure 7. The truncated SVM breaks down severely as
soon as the training data is padded. The reason is that this
method takes only the ﬁrst 100 events in account, i.e.
it
considers only the added benign events of the padded at-
tacks in our setting. All other methods handle the evasion
attempts reasonably well. While the false-positive rates re-
main obviously unaﬀected when only the unknown attack
data is modiﬁed, the impact on true-positive rates is more
severe than with all data padded.

Padding

10% attack data
FPR

TPR

10% unknown attack data
FPR

TPR

EarlyBird
90.4% 0.010% 89.6%
Truncated SVM 51.1% 0.008% 80.4%
SVM (over time)
87.1% 0.011% 85.6%
SVM (end)
84.3% 0.000% 83.7%

0.005%
0.012%
0.010%
0.000%

Table 4: Comparison of performances for the evasion
experiments with either the unknown data padded
or all data padded.

An evasion attack with 50% or more padded data causes
a large performance impact on EarlyBird, so that the reg-
ular SVM would in this case achieve a better performance if
the modiﬁed attacks inﬂuence the training process. In case
of 100% padded test data but unmodiﬁed training data, the
performance of EarlyBird would decrease to 66.5%. How-
ever, even in this setting our method would still outperform
the regular SVM by 8%.

We need to note here that we have studied only a simple
evasion scenario and more involved settings can be thought
of. In fact, there is a branch of machine learning research ex-
clusively concerned with learning on poisoned training data.
Some of the concepts of this research can be implemented

(a) Padding on known and unknown partition

(b) Padding on unknown partition only

Figure 7: Accumulated true-positive rates for the
evasion experiment with 10% padded attacks.

into EarlyBird, but such extensions are out of the scope
of this paper.

5. RELATED WORK

With the proliferation of malicious JavaScript code in the
Internet, the detection and mitigation of this threat has been
a vivid area of research. Several approaches have been pro-
posed for observing, analyzing, and detecting JavaScript at-
tacks in the wild, for example, using high-interaction hon-
eypots [17, 22, 26] and low-interaction honeypots [1, 10, 16].
Similarly, diﬀerent systems have been proposed for oﬄine
analysis of JavaScript code [2, 4, 11, 12]. While all these
approaches are eﬀective in detecting malicious code, they
usually require considerable analysis time and thus are in-
applicable for protecting users at run-time.

Concurrently to these oﬄine approaches, other work has
studied the detection of particular attack types, such as
heap-spraying attacks [7, 18] and drive-by downloads [14].
This work rests on identifying symptoms of certain attacks,
for example, the presence of shellcode in JavaScript strings.
Although these approaches mitigate the threat of web-based
attacks to some extent, they are limited to speciﬁc attack
types and unable to cope with the evolving domain of mali-
cious JavaScript code.

Recent work has thus studied combining JavaScript analy-
sis with techniques from machine learning for deriving auto-
matic defenses. Most notably are the learning-based detec-
tion systems Cujo [20], Zozzle [6], and IceShield [9]. Our

1001021041060%25%50%75%100%TPR# of observed events  EarlyBirdTruncated SVMSVM1001021041060%25%50%75%100%TPR# of observed events  EarlyBirdTruncated SVMSVM21method EarlyBird is closely related to these approaches,
as it also uses dynamic analysis to detect malicious code
at run-time. Similarly, EarlyBird also builds on machine
learning for automatically learning a discrimination between
benign and malicious code. Nonetheless, EarlyBird signif-
icantly diﬀers from previous approaches in that not only the
accuracy is considered but also the time of detection. To
the best of our knowledge, EarlyBird is the ﬁrst method
to provide an early detection of malicious JavaScript code,
while attaining the same accuracy as related approaches.

The concepts developed in this paper can also be applied
to other detection systems. In particular, it is possible to
extend Zozzle and IceShield by replacing their underly-
ing learning algorithm with EarlyBird. As a result, our
approach is agnostic to the concrete realization of a detec-
tor and can be applied in several scenarios where an early
detection improves the quality of a security system.

6. CONCLUSIONS

In this paper, we have proposed a ﬂexible detection method
for early identiﬁcation of malicious JavaScript behavior. The
method uses machine learning techniques for optimizing the
accuracy as well as the time of detection It allows for using
arbitrary loss functions and (cid:96)p-norm regularizers as well as
time penalties. Empirically, the early detection of malicious
code has been demonstrated in diﬀerent experiments, where
our method EarlyBird outperforms regular detectors and
limits the execution of malicious code to a fraction of 43.6%.
Furthermore, the method is robust against evasion attempts
that try to exploit its time dependency.

The present work gives a technological foundation for the
early detection of malicious events in general and can be ap-
plied well beyond the setting considered in this paper, for
example, for classic network intrusion and behavior-based
malware analysis. It can also be used beyond computer se-
curity in settings where appropriately ﬁltering temporal or
sequential data is crucial, such as in brain computer inter-
facing and bioinformatics.

Acknowledgements
The authors would like to thank Andreas Dewald for provid-
ing a modiﬁed version of ADSandbox as well as Marco Cova
for providing a data set of JavaScript attacks. Moreover,
the authors gratefully acknowledge funding from the Ger-
man Federal Ministry of Education and Research (BMBF)
under the project PROSEC (FKZ 01BY1145), the German
National Science Foundation (DFG) under MU 987/6-1 and
the National Research Foundation of Korea under Grant
R31-10008.

References
[1] A. B¨uscher, M. Meier, and R. Benzm¨uller. Throwing a

monkeywrench into web attackers plans. In Proc. of
Communications and Multimedia Security (CMS),
pages 28–39, 2010.

[2] D. Canali, M. Cova, G. Vigna, and C. Kruegel.

Prophiler: a fast ﬁlter for the large-scale detection of
malicious web pages. In Proc. of the International
World Wide Web Conference (WWW), pages
197–206, Apr. 2011.

[3] C. Cortes and V. Vapnik. Support-vector networks.

Machine learning, 20(3):273–297, 1995.

[4] M. Cova, C. Kruegel, and G. Vigna. Detection and
analysis of drive-by-download attacks and malicious
JavaScript code. In Proc. of the International World
Wide Web Conference (WWW), 2010.

[5] N. Cristianini and J. Shawe-Taylor. An Introduction
to Support Vector Machines. Cambridge University
Press, Cambridge, UK, 2000.

[6] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert.

Zozzle: Fast and precise in-browser javascript malware
detection. In Proc. of USENIX Security Symposium,
2011.

[7] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda.

Defending browsers against drive-by downloads:
Mitigating heap-spraying code injection attacks. In
Detection of Intrusions and Malware & Vulnerability
Assessment (DIMVA), pages 88–106, 2009.

[8] R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang,

and C.-J. Lin. LIBLINEAR: A library for large linear
classiﬁcation. Journal of Machine Learning Research
(JMLR), 9:1871–1874, 2008.

[9] M. Heiderich, T. Frosch, and T. Holz. IceShield:

Detection and mitigiation of malicious websites with a
frozen dom. In Recent Adances in Intrusion Detection
(RAID), Sept. 2011.

[10] A. Ikinci, T. Holz, and F. Freiling. Monkey-spider:

Detecting malicious websites with low-interaction
honeyclients. In Proc. of Conference “Sicherheit,
Schutz und Zuverl¨assigkeit” (SICHERHEIT), pages
891–898, 2008.

[11] S. Karanth, S. Laxman, P. Naldurg, R. Venkatesan,
J. Lambert, and J. Shin. ZDVUE: Prioritization of
javascript attacks to surface new vulnerabilities. In
Proc. of CCS Workshop on Security and Artiﬁcial
Intelligence (AISEC), Oct. 2011.

[12] C. Kolbitsch, B. Livshits, B. Zorn, and C. Seifert.

Rozzle: De-cloaking internet malware. Technical
Report MSR-TR-2011-94, Microsoft Research, Aug.
2011.

[13] Z. Li, Y. Tang, Y. Cao, V. Rastogi, Y. Chen, B. Liu,

and C. Sbisa. WebShield: enabling various web
defense techniques without client side modiﬁcations.
In Proc. of Network and Distributed System Security
Symposium (NDSS), 2011.

[14] L. Lu, V. Yegneswaran, P. A. Porras, and W. Lee.

BLADE: An attack-agnostic approach for preventing
drive-by malware infections. In Proc. of Conference on
Computer and Communications Security (CCS), pages
440–450, Oct. 2010.

[15] K. M¨uller, S. Mika, G. R¨atsch, K. Tsuda, and

B. Sch¨olkopf. An introduction to kernel-based learning
algorithms. Neural Networks, IEEE Transactions on,
12(2):181–201, 2001.

22[16] J. Nazario. A virtual client honeypot. In Proc. of

USENIX Workshop on Large-Scale Exploits and
Emergent Threats (LEET), 2009.

[17] N. Provos, P. Mavrommatis, M. A. Rajab, and

F. Monrose. All Your iFRAMEs Point to Us. In Proc.
of USENIX Security Symposium, 2008.

[18] P. Ratanaworabhan, B. Livshits, and B. Zorn. Nozzle:

A defense against heap-spraying code injection
attacks. In Proc. of USENIX Security Symposium,
2009.

[19] K. Rieck and P. Laskov. Linear-time computation of

similarity measures for sequential data. Journal of
Machine Learning Research, 9(Jan):23–48, Jan. 2008.

[20] K. Rieck, T. Krueger, and A. Dewald. Cujo: Eﬃcient
detection and prevention of drive-by-download attacks.
In 26th Annual Computer Security Applications
Conference (ACSAC), pages 31–39, Dec. 2010.

[21] B. Sch¨olkopf and A. Smola. Learning with kernels:

Support vector machines, regularization, optimization,
and beyond. the MIT Press, 2002.

[22] C. Seifert and R. Steenson. Capture – honeypot client

(Capture-HPC). Victoria University of Wellington,
NZ, https://projects.honeynet.org/capture-hpc,
2006.

[23] J. Shawe-Taylor and N. Cristianini. Support Vector
Maschines and other kernel-based learning methods.
Cambridge University Press, 2000.

[24] Symantec. Symantec Internet Security Threat Report:

Trends for 2010. Vol. 16, Symantec, Inc., 2011.

[25] V. Vapnik. The nature of statistical learning theory.

Springer-Verlag New York Inc, 1995.

[26] Y.-M. Wang, D. Beck, X. Jiang, R. Roussev,

C. Verbowski, S. Chen, and S. T. King. Automated
web patrol with strider honeymonkeys: Finding web
sites that exploit browser vulnerabilities. In Proc. of
Network and Distributed System Security Symposium
(NDSS), 2006.

APPENDIX
A. MODEL SELECTION

EarlyBird is able to use arbitrary losses, Lp-norm reg-
ularizers and Lq-norm time penalizers. For this work, we
restrict our model selection to the simple case p = q.

We use Liblinear [8], a library for large-scale linear clas-
siﬁcation, and try various available classiﬁers. The results
of these experiments are presented in Table 5. They are
produced with the procedure described in Section 4.2. All
evaluated EarlyBird variants achieve true-positive rates
above 90%. However, the variant with 2-norm regularizer
and hinge loss, corresponding to an adapted SVM formula-
tion, detects the most attacks and raises substantially less
false alarms than the other variants.

Figure 8 shows the true-positive rates of the EarlyBird
candidates over time. The variant with logistic loss performs

EarlyBird

Regularizer/Loss

TPR

FPR

2-norm regularizer,
hinge loss

2-norm regularizer,
logistic loss

1-norm regularizer,
squared hinge loss

93.2% 0.005%

91.6% 0.020%

90.1% 0.030%

Table 5: Comparison of accumulated true-positive
and false-positive rates of various EarlyBird vari-
ants.

Figure 8: Accumulated true-positive rates over time
of various EarlyBird variants.

best in terms of early prediction. However, its false-positive
rate is too high for detection malicious JavaScript code in
practice. Hence, we choose the 2-norm regularization and
hinge loss as default setting for this work.

B. DUALISATION

We derive the the dual problem of EarlyBird for the
special case using the hinge loss and L2-regularization. This
is similar to the standard setting for an SVM and was used
to obtain the results presented in this paper. It is possible
to use the substitution derived in Section 3.2 and just plug
the time-weighted map into the regular SVM. However, we
dualize the original problem and show that we gain the time-
weighted kernel implicitly.

√
1 + C2λ2

As shown in (1), we employ a regularizer weighted with
e)e∈E in order to combine the regularizer
h = (
and the time-penalty. We can write the hinge loss using the
slack variable ξ as follows:

N(cid:88)

min
w,ξ

s.t.

ξi

(2,h) + C1

(cid:107)w(cid:107)2
1
2
yi(cid:104)w, φ(xi)(cid:105) ≥ 1 − ξi ∀i
ξi ≥ 0.

i=1

We incorporate the constraints using the Lagrange multipli-
ers α ≥ 0, β ≥ 0 and gain the following Lagrangian:

1001021041060%25%50%75%100%TPR# of observed events  EarlyBird LREarlyBird 1−normEarlyBird 2−norm23L(w, ξ, α, β) =

(2,h) + C1

N(cid:88)

i=1

ξi

(cid:107)w(cid:107)2

1
2

+

N(cid:88)
− N(cid:88)

i=1

i=1

αi(1 − ξi − yi(cid:104)w, φ(xi)(cid:105))

βiξi.

Since the SVM is convex and Slater’s condition is fulﬁlled,
the KKT conditions are necessary and suﬃcient for the dual
solution to be optimal.

we − N(cid:88)

i=1

∂L
∂we

=

1
h2
e

αiyiφe(xi) != 0

−1) ◦ N(cid:88)

⇒ w = (h

−1 ◦ h

αiyiφ(xi)

i=1

∂L
∂ξi

= C1 − αi − βi
⇒ 0 ≤ αi ≤ C1

!= 0

We gain a constraint and the formula for the weights that
we also derived in (2) by back-substitution. Plugging this
into the Lagrangian yields the dual optimization problem

N(cid:88)
N(cid:88)

i=1

max

α

− 1
2

αi

N(cid:88)

αiαjyiyjk(xi, xj)

i=1

j=1

s.t. 0 ≤ αi ≤ C1 ∀i

with

k(xi, xj) = (cid:104)h

−1 ◦ φ(xi), h
= (cid:104) ˜φ(xi), ˜φ(xj)(cid:105).

−1 ◦ φ(xj)(cid:105)

24