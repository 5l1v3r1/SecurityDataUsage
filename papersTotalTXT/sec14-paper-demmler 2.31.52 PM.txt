Ad-Hoc Secure Two-Party Computation on  

Mobile Devices using Hardware Tokens

Daniel Demmler, Thomas Schneider, and Michael Zohner, Technische Universität Darmstadt

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/demmler

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXAd-Hoc Secure Two-Party Computation on

Mobile Devices using Hardware Tokens

Daniel Demmler, Thomas Schneider, and Michael Zohner

Technische Universit¨at Darmstadt, Germany

{daniel.demmler,thomas.schneider,michael.zohner}@ec-spride.de

Abstract

Secure two-party computation allows two mutually dis-
trusting parties to jointly compute an arbitrary function
on their private inputs without revealing anything but the
result. An interesting target for deploying secure compu-
tation protocols are mobile devices as they contain a lot
of sensitive user data. However, their resource restriction
makes the deployment of secure computation protocols a
challenging task.

In this work, we optimize and implement

the
secure computation protocol by Goldreich-Micali-
Wigderson (GMW) on mobile phones. To increase per-
formance, we extend the protocol by a trusted hardware
token (i.e., a smartcard). The trusted hardware token al-
lows to pre-compute most of the workload in an initial-
ization phase, which is executed locally on one device
and can be pre-computed independently of the later com-
munication partner. We develop and analyze a proof-
of-concept implementation of generic secure two-party
computation on Android smart phones making use of
a microSD smartcard. Our use cases include private
set intersection for ﬁnding shared contacts and private
scheduling of a meeting with location preferences. For
private set intersection, our token-aided implementation
on mobile phones is up to two orders of magnitude faster
than previous generic secure two-party computation pro-
tocols on mobile phones and even as fast as previous
work on desktop computers.

1

Introduction

Secure two-party computation allows two parties to pro-
cess their sensitive data in such a way that its privacy
is protected.
In the late eighties, Yao’s garbled cir-
cuits protocol [Yao86] and the protocol of Goldreich-
Micali-Wigderson (GMW) [GMW87] showed the fea-
sibility of secure computation. However, secure com-
putation was considered to be mostly of theoretical in-

terest until the Fairplay framework [MNPS04] demon-
strated that it is indeed practical. Since then, many op-
timizations have been proposed and several frameworks
have implemented Yao’s garbled circuits protocol (e.g.,
FastGC [HEKM11]) and the GMW protocol (e.g., the
framework of [CHK+12]) on desktop PCs.

Motivated by the advances of secure computation
on desktop PCs, researchers have started to investigate
whether secure computation can also be performed in
the mobile domain. Mobile devices, in particular smart-
phones, are an excellent environment for secure compu-
tation, since they accompany users in their daily lives and
typically hold contact information, calendars, and pho-
tos. Users also store sensitive data, such as passwords
or banking information on their devices. Moreover, typ-
ical smartphones are equipped with a multitude of sen-
sors that collect a lot of sensitive information about their
users’ contexts. Therefore, it is of special importance to
protect the privacy of data handled in the mobile domain.
In contrast to desktop PCs, mobile devices are rather
limited in computational power, available memory, com-
munication capabilities, and most notably battery life.
Although mobile phones have seen an increase in pro-
cessing speed over the past years, they are still about one
order of magnitude slower than typical desktop comput-
ers when evaluating cryptographic primitives (cf. §5.4).
These differences are due to the CPU architectures hav-
ing a more restrictive instruction set and being opti-
mized for low power consumption rather than perfor-
mance, since mobile devices are battery-powered and
lack active cooling. Moreover, the limited size of the
main memory requires the programmer to carefully han-
dle data objects in order to avoid costly garbage col-
lections on Java-based Android smartphones. Network
connections of mobile devices are almost exclusively es-
tablished via wireless connections that have lower band-
width and higher, often varying latency compared to
wired connections. Tasks that are computationally in-

USENIX Association  

23rd USENIX Security Symposium  893

tensive or require long send/receive operations should be
avoided when a mobile device is running on battery, as
such tasks quickly drain the battery charge and thereby
reduce the phone’s standby time.
Instead, such oper-
ations could be pre-computed when the mobile device
is connected to a power source, which usually happens
overnight. These limitations pose a big challenge for efﬁ-
cient secure computation and cause generic secure com-
putation protocols to be several hundred times slower on
mobile devices than on desktop PCs [HCE11], even in
the semi-honest adversary model.

To enable secure two-party computation in the mobile
domain, solutions have been developed that outsource
secure computation to the cloud, e.g., [KMR12, Hua12,
CMTB13]. However, recent events have shown that
cloud service providers can be forced to give away data
to third parties that are not necessarily trusted, such as
foreign government agencies. Even if the employed pro-
tocols ensure that the cloud provider learns no informa-
tion about the users’ sensitive data, he can still learn and
hence be forced to reveal meta-information such as the
frequency of access, communication partners involved,
the computed function, or the size of the inputs. More-
over, these server-aided approaches require the mobile
device to be connected to the Internet which might not be
possible in every situation or may cause additional costs.
An alternative solution, which we also use in this
work, is to outsource expensive operations to a trusted
hardware token that has very limited computational re-
sources and is locally held by one of the communica-
tion partners.1 Such hardware tokens are increasingly
being adopted in practice, e.g., trusted platform modules
(TPMs). Their adoption is particularly noteworthy on
mobile devices in the form of smartcards that are the ba-
sis for subscriber identity modules (SIM cards), as well
as for mobile payment or ticketing systems. A ﬁrst ap-
proach for outsourcing Yao’s garbled circuits protocol to
such a trusted hardware token was proposed in [JKSS10].
However, this protocol requires the function to be known
in advance and uses costly symmetric cryptographic op-
erations during the online phase. We give an alternative
solution that removes these drawbacks.

1.1 Outline and Our Contributions
In this work, we introduce a scheme for token-aided ad-
hoc generic secure two-party computation on mobile de-
vices based on the GMW protocol. After introducing
preliminaries (§2) we detail our setting and trust assump-
tions that are similar to the ones in a TPM scenario (§3).
We outline how a trusted hardware token can be used

1This locality is also a security feature, as external adversaries either
need to corrupt the token before it is shipped to the user or later get
physical access to break into it.

to shift major parts of the workload into an initializa-
tion phase that can be pre-computed on the token, inde-
pendently of the later communication partner (§4), e.g.,
while the mobile device is charging. We thereby obtain
a token-aided scheme that is well-suited for efﬁcient and
decentralized (ad-hoc) secure computation in the mobile
domain. We implement and evaluate our scheme (§5)
and demonstrate its performance using typical secure
computation applications for mobile devices, such as se-
curely scheduling a meeting with location preferences
and privacy-preserving set intersection (§6). We com-
pare our scheme to related work (§7) and conclude and
present directions for future work (§8). More detailed,
our contributions are as follows.

Token-Aided Ad-Hoc Secure Two-Party Computa-
tion on Mobile Devices (§4) We develop a token-aided
secure computation protocol which ofﬂoads the main
workload of the GMW protocol to a pre-computation
phase by introducing a secure hardware token T , held by
one party A (cf. §3). T is issued by a trusted third party
and provides correlated randomness [Hua12, Chap. 6]
to both parties that is later used in the secure computa-
tion protocol. To prepare the secure computation, the
other party B obtains seeds for his part of the correlated
randomness from T via an encrypted channel. To fur-
ther increase ﬂexibility, we describe how to make the
pre-computation independent of the size of the evaluated
function | f|, at the cost of a t · log2| f| factor communi-
cation overhead between T and B, where t is the sym-
metric security parameter. In contrast to Yao-based ap-
proaches [MNPS04,JKSS10,HCE11,HEK12] and previ-
ous realizations of the GMW protocol [CHK+12, SZ13,
ALSZ13], our protocol offers several beneﬁts as summa-
rized in Tab. 1 (cf. §4.5 for details).

Table 1: Comparison with related work.

Property

Yao

[HCE11]

Token Yao
[JKSS10]

GMW

[CHK+12]

com-

f unknown in
init phase
ad-hoc
munication
(cid:25) t ·| f|
(cid:25) | f|
operations
ad-hoc phase

crypto
in



















Ours
§4







Implementation (§5) We implement our token-aided
protocol for semi-honest participants and evaluate its
performance using two consumer-grade Android smart-
phones and an off-the-shelf smartcard. Thereby, we pro-
vide an estimate for the achievable runtime of generic se-

894  23rd USENIX Security Symposium 

USENIX Association

cure computation in the mobile domain. Our implemen-
tation enables a developer to specify the functionality
as a Boolean circuit, which can, for instance, be gener-
ated from a high-level speciﬁcation language. We show
that the performance of our token-aided pre-computation
phase is comparable to interactively generating the cor-
related randomness using oblivious transfer.

Applications (§6) We demonstrate the practical feasi-
bility of the GMW protocol on mobile devices by per-
forming secure two-party computation on two smart-
phones using various privacy-preserving applications
location-aware
such as availability scheduling (§6.1),
scheduling (§6.2), and set-intersection (§6.3). Most
notably,
for private set-intersection, our token-aided
scheme outperforms related work that evaluates generic
secure computation schemes on mobile devices [HCE11]
by up to two orders of magnitude and has a performance
that is comparable with secure computation schemes that
are executed in a desktop environment [HEK12].

2 Preliminaries
In the following, we deﬁne our notation (§2.1) and the
ad-hoc scenario (§2.2), and give an overview of oblivi-
ous transfer (§2.3) and the GMW protocol (§2.4). We de-
scribe Yao’s garbled circuits in the full version [DSZ14].

2.1 Notation
We denote the two parties that participate in the secure
computation as A and B. We use the standard notation
for bitwise operations, i.e., x⊕ y denotes bitwise XOR,
x∧ y bitwise AND, and x||y the concatenation of two bit
strings x and y. We refer to the symmetric security pa-
rameter as t and the function to be evaluated as f .

2.2 Ad-Hoc Scenario
In an ad-hoc secure two-party computation scenario, two
parties that do not necessarily know each other in ad-
vance want to spontaneously perform secure computa-
tion of an arbitrary function f on their private inputs x
and y. Traditionally, secure computation protocols con-
sist of two interactive phases: the setup phase (indepen-
dent of x and y) and the online phase. We extend this
setting by a local init phase as depicted in Fig. 1.

The init phase takes place at any time before the
parties have identiﬁed each other and is used for pre-
processing.
In the setup phase, the parties have deter-
mined their communication partner, establish a commu-
nication channel, and know an upper bound on the func-
tion size | f|. In the online phase, the parties provide their
private inputs x and y to the function f that they want to

Init Phase

Setup Phase

Online Phase

A

?

A

B

A
x

f
...
f(x,y)

B
y

Figure 1: The three secure computation phases.

evaluate and begin the secure computation. The ad-hoc
time is the combined time for setup and online phase.

2.3 Oblivious Transfer
Oblivious transfer (OT) is a fundamental building block
for secure computation. In an OT protocol [Rab81], the
sender inputs two strings (s0,s1). The receiver inputs a
bit c ∈ {0,1} and obtains sc as output without reveal-
ing to the sender which of the two messages he chose
and without the receiver learning any information about
s1−c. OT protocols, such as [NP01], require public-key
cryptography and make OT a relatively costly operation.
OT extension [IKNP03] allows to increase the efﬁciency
of OT by extending a small number of t base OTs to
a large number n (cid:21) t of OTs whilst only using O(n)
symmetric cryptographic operations. Optimizations to
the OT extension protocol of [IKNP03] were suggested
in [ALSZ13], which allow the parties to reduce the
amount of data sent per OT. Moreover, [ALSZ13] de-
scribes a more efﬁcient variant of the OT extension pro-
tocol for computing random OT, where the sender ob-
tains two random values as output of the OT protocol.

2.4 The GMW Protocol
In the GMW protocol [GMW87], two (or more) parties
compute a function f , represented as Boolean circuit on
their private inputs by secret sharing their inputs using
an XOR secret sharing scheme and evaluating f gate by
gate. Each party can evaluate XOR gates locally by com-
puting the XOR of the input shares. AND gates, on the
other hand, require the parties to interact with each other
by either evaluating an OT or by using a multiplication
triple [Bea91] as shown in the full version [DSZ14]. Fi-
nally, all parties send the shares of the output wires to the
party that shall obtain the function output. The main cost
factors in GMW are the total number of AND gates in
the circuit, called (multiplicative) size | f|, and the high-
est number of AND gates between any input wire and
any output wire, called (multiplicative) depth d( f ).

Because an interactive OT is required for each AND
gate, it was believed that GMW is very inefﬁcient com-
pared to Yao’s garbled circuits. However, in [CHK+12]
it was shown that by using OT extension [IKNP03]
and OT pre-computation [Bea95] many OTs can be

USENIX Association  

23rd USENIX Security Symposium  895

pre-computed efﬁciently in an interactive setup phase.
Thereby, all use of symmetric cryptographic operations
is shifted to the setup phase, leaving only efﬁcient one-
time pad operations for the online phase. Additionally,
the setup phase only requires an upper bound on | f|
to be known before the secure computation. Follow-up
work of [SZ13] demonstrated that, by using OT to pre-
compute multiplication triples in the setup phase, the on-
line phase can be further sped up. Multiplication triples
are random-looking bits ai,bi, and ci, for i ∈ {A,B}, sat-
isfying (cA ⊕ cB) = (aA ⊕ aB)∧ (bA ⊕ bB), that are held
by the respective parties and used to mask private data
during the secure computation. This masking is done
very efﬁciently, since no cryptographic operations are re-
quired.
In [ALSZ13] it was shown that multiplication
triples can be generated interactively using two random
OTs. [Hua12] proposed to let a trusted server generate
the multiplication triples and send (ai,bi,ci) to party i
over a secure channel via the Internet. In our work, we
propose to do this locally, without knowing the commu-
nication partner in advance.

3 Our Setting

In our setting, depicted in Fig. 2, we focus on ef-
ﬁcient ad-hoc secure computation between two semi-
honest (cf. §3.1) parties A and B who each hold a mo-
bile device, which are approximately equally powerful
but signiﬁcantly weaker than typical desktop computer
systems. The parties’ devices are connected via a wire-
less network and are battery-powered.

B

A

T

Figure 2: The parties involved in the secure computation.

A holds a general-purpose tamper-proof hardware to-
ken T that has very few computational resources. T is
powered by A, and its functionalities are limited to the
standard functionalities described in §3.2. A and T are
connected via a physical low-bandwidth connection and
communicate via a ﬁxed interface. B and T communi-
cate via A, i.e., every message that B and T exchange, is
seen and relayed by A. Note that this directly requires all
communication between B and T to be encrypted such
that it cannot be read by A. We assume that T behaves
semi-honestly, and is issued by a third party, external to
and trusted by both A and B (cf. §3.2).

3.1 Adversary Model
We assume that both parties behave semi-honestly in
the online phase, i.e., they follow the secure computa-
tion protocol, but may try to infer additional information
about the other party’s inputs from the observed mes-
sages. To the best of our knowledge, all previous work on
secure computation between two mobile phones is based
on the semi-honest model (cf. §7.1). The semi-honest
model is suitable in scenarios where the parties want to
prevent inadvertent information leakage and for devices
where the software is controlled by a trusted party (e.g.,
business phones managed by an IT department) or where
code attestation can be applied. Moreover, this model
gives an estimate on the achievable performance of se-
cure computation. We outline how to extend our protocol
to malicious security in the full version [DSZ14].

3.2 Trusted Hardware Token
We use the term trusted hardware token T to refer to
a tamper-proof, programmable device, such as a Java
smartcard,
that offers a restricted set of functionali-
ties. Such functionalities include, for instance, hash-
ing, symmetric and asymmetric encryption/decryption,
secure storage and secure random number generation.
A detailed summary of standard smartcard functionali-
ties is given in [HL08]. The hardware token is passive,
i.e., it cannot initiate a communication by itself and only
responds to queries from its host. It contains both per-
sistent and transient memory. T is physically protected
against attacks and is securely erased if it is opened by
force. Each token holds an asymmetric key pair, similar
to an endorsement key used in TPMs [TCG13], where
the public key is certiﬁed by a known trusted third party
and allows unique identiﬁcation of T .

Tiny Trusted Third Party T acts as a tiny trusted
third party that behaves semi-honestly. This assumption
is similar to the TPM model that is widely used in desk-
top environments. T only provides correlated random-
ness that is later used in the secure computation and does
never receive any of A or B’s private inputs. We assume
that only certiﬁed code is allowed to be executed on T ,
and that T can only actively deviate from the protocol
if the hardware token’s manufacturer programmed it to
be malicious. We assume the code certiﬁcation was car-
ried out by a trusted third party, and argue that both the
manufacturer and the certiﬁcation authority would face
severe reputation loss if it was discovered that they built
backdoors into their products. Moreover, we assume that
neither A nor B colludes with the hardware token man-
ufacturer. This non-collusion assumption is a common
requirement for outsourced secure computation schemes

896  23rd USENIX Security Symposium 

USENIX Association

such as [Hua12,KMR12,CMTB13] and enables the con-
struction of efﬁcient protocols. Finally, note that, al-
though T is in A’s possession, A cannot easily corrupt T
or obtain its internal information, since T is assumed to
be tamper-proof and does not reveal internal secrets, i.e.,
the costs of an attack are higher than the beneﬁts from
breaking T ’s security. This assumption also holds if A
colludes with or impersonates B.
Protection Against Successful Hardware Attacks
A malicious adversary could try to break into the hard-
ware token. If such an attack is successful, the follow-
ing standard countermeasures can be used to prevent fur-
ther damage: A binding between token and key pair can
be realized by using techniques such as physically un-
cloneable functions (PUFs), however, we are not aware
of solutions that are available in commercial products.
To bind a token to a certain mobile device or person,
T ’s certiﬁcate could be personalized with one or mul-
tiple values that are unique per user and that can be ver-
iﬁed over an off-band channel, such as the user’s tele-
phone number or the ID of the user’s passport. Another
line of defense can be certiﬁcate revocation lists (CRLs)
that allow the users to check if a token is known to be
compromised or malicious.

4 Token-aided Mobile GMW

In the following section, we give details on our token-
aided GMW-based protocol on mobile devices. Our goal
is to minimize the ad-hoc time, i.e., the time from es-
tablishing the communication channel between A and B
until receiving the results of the secure computation. We
consider the init phase to not be time critical, but we try
to keep its computational overhead small.

InitvPhase

MTvGen.v(§4.1)

SetupvPhase

SeedvTransferv(§4.2)

OnlinevPhase
CircuitvEvaluation

A

T

A

T

...

B

B

A

T

Figure 3: The three phases, workload distribution, and
communication in our token-aided scheme.

An overview of our protocol is given in Fig. 3. The
general idea is to let the hardware token generate mul-
tiplication triples from two (or more) seeds in the init
phase that are independent of the later communication
partner (§4.1).
In the setup phase, T then sends one
seed to A and the other seed over an encrypted channel

to B (§4.2). The token thereby replaces the OT protocol
in the setup phase and allows pre-computing the multipli-
cation triples independently of the communication part-
ner. The online phase of the GMW protocol remains un-
changed.
In order to overcome the restriction that the
function size needs to be known in advance, we describe
a method that pre-computes several multiplication triple
sequences of different size and only adds a small com-
munication overhead in the setup phase (§4.3). Finally,
we analyze the security of our protocol (§4.4) and com-
pare its performance to previous solutions (§4.5).

4.1 Multiplication Triple Pre-Computation

in the Init Phase

B,cn

A,cn

A,bn

In the original GMW protocol, A and B interactively
compute their multiplication triples (an
A) and
B,bn
(an
B) in the setup phase using 2n random OT ex-
tensions (cf. §2.4).
Instead, we avoid this overhead in
the setup phase and let T pre-compute the multiplica-
tion triples in the init phase as shown in Fig. 4: T ﬁrst
generates random seeds and then expands these seeds in-
ternally into the multiplication triples and sends cn
to A.
A

A
cn
A

cn
A

an
B

d
T

cn
B

bn
B
sB
kB

Seed Generation

Seed Expansion

an
A

bn
A

sA
kA

Figure 4: Multiplication triple pre-generation in the init
phase between A and T .

(d) and sB = GkB

Seed Generation In the seed generation step, T gen-
erates two seeds sA = GkA
(d) us-
ing a cryptographically strong Pseudo-Random Gener-
ator (PRG) G, two master keys kA and kB, and a state
value d, which is unique per multiplication triple se-
quence and can be instantiated with a counter. The two
master keys kA and kB are constant for all multiplica-
tion triple sequences and have to be generated and stored
only once. Thereby, T has to store only the unique
state value d in its internal memory for every multipli-
cation triple sequence. Note that the only values that will
leave the internal memory of T are the seeds sA and sB

USENIX Association  

23rd USENIX Security Symposium  897

B)∧ (bn

A) =G sA

that will be sent in the setup phase to A and B, respec-
tively (cf. §4.2). In order to ensure that sB is not sent out
twice, we require sA to be queried before sB and delete
the state value d as soon as sB has been sent out. A secu-
rity analysis of this scheme is given in §4.4.
Seed Expansion The seed expansion step com-
putes a valid multiplication triple sequence from the
A,bn
seeds sA and sB by computing (an
(dA) and
B,bn
B,cn
(an
(dB) and setting the remaining value
B) = GsB
B)⊕ cn
A ⊕ an
A = (an
cn
A ⊕ bn
, where dA and dB are
B
publicly known state values of A and B, respectively.
Due to the limited memory of the hardware token, the se-
quence cn
is computed block-wise such that T requires
A
only a ﬁxed amount of memory, independently of n, and
each block is sent to A, who stores it locally. Note that
the values (an
B) do not need to be stored,
since they can be expanded from sA and sB, respectively.
4.2 Seed Transfer in the Setup Phase
In the setup phase, the hardware token sends the seeds sA
and sB to A and B, respectively, and the parties generate
their multiplication triples as depicted in Fig. 5. A ob-
tains his seed sA directly from T and can read the se-
quence cn
, which was obtained in the init phase, from
A
its internal ﬂash storage. B’s seed sB, on the other hand,
cannot be sent in plaintext from T to B as the communi-
cation between the token and B is relayed over A, which
would allow A to intercept sB. We therefore require the
communication between B and T to be encrypted and T
to authenticate itself to B with a certiﬁcate.

B,cn

A,bn

A,an

B,bn

an
B

B
bn
B
sB

cn
B

an
A
sA

sA
kA

A
bn
A

cn
A

sB
kB

d

T

Figure 5: Seed transfer and seed expansion in the setup
phase. sB is sent from T to B over a secure channel.

An encrypted and one-way authenticated communica-
tion channel can be established using a key agreement
protocol from a wide variety of choices (cf. [MvOV96]).
We choose two protocols that allow us to handle dif-
ferent attacker models: For security against a malicious
(active) A we use TLS [IET08] (with RSA for public-
key crypto, AES for symmetric encryption, and HMAC

as message authentication code) and for security against
a semi-honest (passive) A we use KAS1-basic [NIS09]
the full ver-
(with AES for symmetric encryption), cf.
sion [DSZ14] for details. Both schemes use T ’s public-
key certiﬁcate that is signed by a trusted third party. For
every new connection this certiﬁcate is veriﬁed by B and
optionally checked against a CRL and/or is checked to be
consistent with A’s identity over an out-of-band channel
to protect against hardware attacks (cf. §3.2).

4.3 Multiplication Triple Composition
The multiplication triple generation described until now
requires the function size n = | f| to be known before-
hand. While this may be the case for some functions,
e.g., for set intersection using bitwise AND (cf. §6.1),
the size of other functions depends on the number of
the number of contacts in the address
inputs, e.g.,
The naive solution to not know-
book (cf. §6.3).
ing n in advance would be to generate several mul-
tiplication triple sequences of ﬁxed size (cid:30) in the init
phase and send their (cid:24)n/(cid:30)(cid:23) seeds in the setup phase,
when n is known. However, on average this approach
wastes (cid:30)/2 multiplication triples and requires to send
(cid:24)n/(cid:30)(cid:23) multiplication triple seeds. Thus, a smaller (cid:30)
results in fewer wasted multiplication triples but more
communication overhead, while a higher (cid:30) results in
more wasted multiplication triples but less communica-
tion. Since typical function sizes in secure computation
range from millions [HEKM11] to even a billion AND
gates [CMTB13], an appropriate (cid:30) is difﬁcult to choose.
Instead of generating ﬁxed-length blocks of multipli-
cation triple sequences, we propose to generate m mul-
tiplication triple sequences s0, ...,sm−1 in the init phase,
where si contains 2i (0 ≤ i < m) multiplication triples.
In the setup phase, we then send a set of multiplication
triple seeds {sk |nk = 1}, where nk is the k-th bit of n.
This approach requires sending at most (cid:24)log2 n(cid:23) seeds.
As communication between T and A is the bottleneck in
our implementation, we set the smallest size of a multi-
plication triple sequence such that it ﬁts into one packet.

4.4 Security Analysis
In this section, we brieﬂy analyze the security of our pro-
tocol for each of the three secure computation phases.

Init Phase
In the init phase no private inputs are in-
volved and B is unknown. Therefore, A can only try to
manipulate the token, which is hard since the hardware
token is tamper-proof. Moreover, A receives only its cA
shares that do not reveal anything about B’s shares or T ’s
internal state, due to the cryptographically strong PRG.

898  23rd USENIX Security Symposium 

USENIX Association

Setup Phase The only attack a malicious A could play
in the setup phase, is to impersonate B. This attack
is prevented, since every seed sB can only be queried
once (cf. §4.1). The communication between the hard-
ware token and B is done through an encrypted channel,
so that A cannot get access to those messages. For active
security, we use TLS and add a MAC to every packet to
prevent modiﬁcations and avoid replay attacks. B can-
not actively attack the token since all communication to
the hardware token is controlled by A. Obviously, any
party can drop or ignore messages, but we exclude this
simple denial of service attack from our system model
since we assume both parties to be willing to participate
in the secure computation. The seeds that each party ob-
tains from the hardware token do also not reveal any ad-
ditional information since they are directly output from
a cryptographically strong PRG to which the hardware
token’s internal state is used as seed.

Online Phase The security for the online phase di-
rectly carries over from the GMW protocol, as we do
not introduce any modiﬁcations to this phase.

4.5 Performance Comparison
We show that the asymptotic performance of our protocol
improves over existing solutions. A summary is shown in
Tab. 1 on page 2 and a more detailed comparison is given
in the full version [DSZ14]. An experimental evaluation
of our protocol is provided in §5.4 and its performance
on applications is evaluated in §6.

Asymptotic Performance The init phase of our pro-
tocol is, unlike [JKSS10], independent of a concrete in-
stance of f and can thus be pre-computed without know-
ing a communication partner. During the setup phase, the
communication complexity of our protocol is only O(t)
(or O(t · log2| f|) if | f| is unknown), which improves
upon the communication of Yao’s protocol and the GMW
protocol [CHK+12, SZ13, ALSZ13] with O(t ·| f|) com-
munication. Both parties have to do O(| f|/b) sym-
metric cryptographic operations to expand their seeds.2
The online phase is the ﬁrst phase where f needs to be
known. Here, A and B send O(| f|) bits in d( f ) rounds,
where d( f ) is the depth of f . The parties’ computation
complexity is negligible, as no cryptographic operations
are evaluated. This is the biggest advantage over Yao’s
garbled circuits protocol [MNPS04, JKSS10, HCE11],
where O(| f|) symmetric cryptographic operations have
to be evaluated during the online phase.

2In our implementation, we instantiate the PRG G with AES-128-

CTR, which has block size b = 128.

Concrete Performance For 80 bit security, the best
known instantiation of Yao’s garbled circuits protocol
(resp. the GMW protocol) require per AND gate 240 bit
(resp. 164 bit) communication and 4 + 1 (resp. 12 + 0)
evaluations of symmetric cryptographic primitives in the
setup +online phase.
In comparison, our solution re-
quires only 4 bit communication and 0.04 + 0 ﬁxed-key
AES operations per AND gate.

5

Implementation

This section details the implementation of our scheme.
We introduce the smartcard that we use to instantiate
the hardware token (§5.1), give an overview of our An-
droid implementation (§5.2), outline our benchmarking
environment (§5.3), and experimentally compare the OT
extension-based multiplication triple generation to our
hardware token-based protocol (§5.4).
5.1 G&D Mobile Security Card
In our implementation we instantiate the trusted hard-
ware token T with the Giesecke & Devrient (G&D) Mo-
bile Security Card SE 1.0 (MSC). It is embedded into a
microSD card that additionally contains 2 GB of separate
ﬂash memory. The MSC is based on an NXP SmartMX
P5CD080 micro-controller that runs at a maximum fre-
quency of 10 MHz, has 6 kB of RAM, 80 kB of persistent
EEPROM, and is based on Java Card version 2.2.2. Note
that an applet can only use 1,750 Bytes of the 6 kB RAM
for transient storage. The MSC has co-processors for
3DES, AES and RSA that can be called from a Java
Card applet, as well as native routines for MD5, SHA-1
and SHA256. The MSC runs the operating system G&D
Sm@rtCafe Expert 5.0 which manages the installed Java
Card applets, personalization data, and communication
keys. The communication between the Android operat-
ing system and the MSC is done by a separate service via
the SIMalliance Open Mobile API.

5.2 Architecture
The architecture of our implementation is depicted in
Fig. 6. To support ﬂexibility and extensibility, our modu-
lar architecture consists of the Application that speciﬁes
the functionality, the GMWService that performs secure
computation, and the MTService that performs the mul-
tiplication triple generation and transfer. All communi-
cation between A and T is done via the MSC Smart-
card Service supplied by G&D. The Application can be
implemented by a designer and speciﬁes the desired se-
cure computation functionality as a Boolean circuit that
can, for instance, be compiled from a high-level cir-
cuit description language such as the Secure Function

USENIX Association  

23rd USENIX Security Symposium  899

Deﬁnition Language (SFDL) [MNPS04, MLB12] or the
Portable Circuit Format (PCF) [KMSB13].

The GMWService implements the GMW protocol and
performs the secure computation, given a circuit descrip-
tion and corresponding inputs. The MTService generates
the multiplication triples using either OT extension (OT-
Ext) based on the memory efﬁcient
implementation
of [HS13] including the optimizations from [ALSZ13]
or, if one of the parties holds a hardware token, our
If a hardware token is
token-aided protocol of §4.
present, the MTService manages the multiplication triple
generation during the init phase by querying the token
and storing the received cA sequences. For the MSC, the
multiplication triple generation on T is performed via
a Java Card applet (MT JC Applet) that implements the
functionality in §4.1 and is accessible through the Java
Card interface. Our implementation can be installed as a
regular Android app and does not require root access to
the smartphone or a custom ﬁrmware.

A

Application

f;x

zA
GMWService

aA;bA;cA

jfj
MTService

. . .

. . .

. . .

B

Application

f;y

zB
GMWService

aB;bB;cB

jfj
MTService

G&D MSC
SCService

OT-Ext

OT-Ext

MT  

JC Applet

T

Figure 6: Modular architecture design.

Secure computation is performed by having an Appli-
cation running on each smartphone, which speciﬁes the
function f both parties want to compute securely. From
this function the Application generates a circuit descrip-
tion, which it sends to the GMWService. The GMWSer-
vice interprets the circuit and queries the MTService
for the required number of multiplication triples | f|.
The MTServices on both smartphones then communi-
cate with each other and check whether one of the smart-
phones holds a hardware token (A in Fig. 6). If so, both
MTServices perform the seed transfer protocol (cf. §4.2),

expand the obtained seeds (A loads the corresponding
cA sequences obtained in the init phase), and merge the
obtained multiplication triple sequences (cf. §4.3).
If
no hardware token is present, the MTServices gener-
ate the multiplication triples by invoking OT extension.
The MTService then provides the multiplication triples
(ai,bi,ci) for i ∈ {A,B} to the GMWService. Finally,
the Applications send their inputs x and y, respectively,
to the GMWService, which performs the secure compu-
tation and returns the output zi = f (x,y).

5.3 Benchmarking Environment
For our mobile benchmarking environment we use two
Samsung Galaxy S3’s, which each have a 1.4 GHz ARM-
Cortex-A9 Quad-Core CPU, 1 GB of RAM, 16 GB of
internal ﬂash memory, a mircoSD card slot, and run the
Android operating system version 4.1.2 (Jelly Bean). For
the communication between the smartphones, we use
Wi-Fi direct. For the evaluation, we put the smartphones
next to each other on a table. The G&D mobile security
card is connected to the mircoSD card slot of one of the
phones. We use the short-term security setting recom-
mended by NIST [NIS12], i.e., a symmetric key size of
80 bits and a public key size of 1,024 bit with a 160 bit
subgroup. We instantiated the pseudo-random genera-
tor G that is used for seed expansion (cf. §4.1) with AES-
128 in CTR mode. The hardware token generates multi-
plication triple sequences of size 2m for 11 ≤ m ≤ 24. We
used m = 11 as lower bound on the size, since 2,048 is
the biggest size we can transfer from T to A with a single
packet, and m = 24 as upper bound, since it was appro-
priate for our case studies in §6. Finally, we point out that
our implementation is single-threaded and utilizes only
one of the four available cores of our smartphones. We
leave the extension to multiple threads as future work.

5.4 Performance Evaluation
First, we want to quantify the runtime differences be-
tween the mobile and the desktop environment. We
measure the execution time for AES-128 in ECB mode
for an identical single-threaded Java implementation in
both domains. The smartphone version is running with
5.5 MB/s while the desktop version achieves 61.1 MB/s.
The optimized AES-256 implementation of Truecrypt3,
written in C/C++ and assembly, achieves 143.1 MB/s on
the same desktop machine, running without paralleliza-
tion. For comparison, the smartcard (cf. §5.1) is running
AES-128 at a maximum speed of 16.7 KB/s.
In the following we evaluate the performance of our
token-based scheme (cf. §4) on smartphones, using TLS
or KAS1-basic as key agreement protocol, and compare

3http://www.truecrypt.org

900  23rd USENIX Security Symposium 

USENIX Association

it to the OT extension based multiplication triple genera-
tion. In our evaluations we only include the time for init
and setup phase, since the online phase is identical for
both approaches. Results for the online phase are given
in §6. All values are averaged over 10 measurements.
Fig. 7 gives an overview over the timings for the gen-
eration of 2m (11 ≤ m ≤ 24) multiplication triples using
either OT extension in the setup phase or the hardware
token (§4.1) in the init phase. Additionally, the setup
phase using TLS and KAS1-basic is depicted, which in-
cludes the seed transfer and the seed expansion of B.
We always assume the worst case number of seeds to be
transferred, i.e., for 224 multiplication triples, we trans-
fer 24− 10 = 14 seeds (cf. §4.3). Both axes in Fig. 7 are
given in a logarithmic scale.

Figure 7: Performance evaluation of the multiplication
triple generation and setup phase.

We observe that OT extension on mobile devices is
able to generate 224 multiplication triples in 1,529 s,
corresponding to 10,971 multiplication triples per sec-
ond. We ran the same code on two desktop PCs with
a 2.5 GHz Intel Core2Quad CPU and 4 GB RAM,
connected via Gigabit LAN and were able to compute
224 multiplication triples in 139 s, which indicates a
performance decrease of factor 11. While the perfor-
mance decrease on mobile devices compared to desktop
computers was signiﬁcantly less than the factor of 1000
observed in [HCE11],
it is still insufﬁcient for efﬁ-
ciently computing complex functions such as private set-
intersection, which typically requires millions of OTs.

In comparison, the multiplication triple generation of
the hardware token during the init phase is able to gener-
ate 224 multiplication triples in 2,883 s, corresponding to
5,819 multiplication triples per second. For the hardware
token-based protocol we observe that the times for send-
ing the seeds using the TLS and KAS1 key agreement
protocols grow very slowly with the number of multipli-
cation triples, since the amount of data to be encrypted

and sent grows only with log2| f|. Additionally, the TLS-
based key agreement protocol (4.6 s for 211 multiplica-
tion triples) is around factor 3 slower than the KAS1-
based key agreement (1.3 s for 211 multiplication triples).
The overall computation and communication work-
load of OT extension is substantially larger than in our
token-based scheme, but its multiplication triple gener-
ation rate is not much faster. This can be explained by
the faster processing power of the smartphones compared
to that of T and the higher bandwidth of Wi-Fi direct
compared to the relatively slow communication chan-
nel between A and T . However, OT extension suffers
from high energy consumption, due to the CPU utiliza-
tion incurred by the symmetric cryptographic operations,
as well as the Wi-Fi direct communication [PFW11].

We use PowerTutor4 to measure the energy consump-
tion of the smartphone’s CPU for generating 219 multi-
plication triples and compare the interactive evaluation of
random OT extensions with our smartcard solution. Note
that Fig. 8 only displays the CPU’s energy consumption
whereas the energy consumption of Wi-Fi and the smart-
card is not included. However, we argue that the en-
ergy consumption of the smartcard is not a critical factor,
since these operations can be performed when the phone
is charging. The Wi-Fi connection, on the other hand, is
required for OT during the setup phase, thus increasing
the already high battery drain even further. Moreover,
the OT computations have to be done on both devices
simultaneously, draining both devices’ batteries. There-
fore, our token-based solution is particularly well-suited
for the mobile domain, where energy consumption and
battery lifetime are critical factors.

Figure 8: Accumulated smartphone CPU energy con-
sumption during the generation of multiplication triples.

4http://powertutor.org

USENIX Association  

23rd USENIX Security Symposium  901

0.1110100100010000211212213214215216217218219220221222223224Token MTGen (Init, §4.1)OT Extension (Setup, §2.3)Token TLS (Setup, §4.2)Token KAS1 (Setup, §4.2)Runtime [s]Number of Multiplication Triples0102030405060708090Energy Consumption [Ws]OT Extension (§2.3)Smartcard (§4.1)Time [s]2.55.07.510.012.515.017.56 Applications

To evaluate the performance of our protocols, we use
the mobile phones and setting as speciﬁed in §5.3 and
consider the following privacy-preserving applications:
availability scheduling (§6.1), location-aware schedul-
ing (§6.2), and set intersection (§6.3). We implemented
the applications and depict the performance results for an
average of 10 iterations. We use KAS1-basic [NIS09] as
key authentication scheme. We pre-generated the circuits
using the framework of [SZ13], wrote them into a ﬁle,
and read them on the smartphone. The time for reading
the circuit ﬁle is included in the setup phase.

6.1 Availability Scheduling
Privacy-preserving availability scheduling is a com-
mon example for secure computation on mobile de-
vices [HCC+01, BJH+11] and enables A and B to ﬁnd a
possible time slot for a meeting without disclosing their
schedules to each other. To schedule a meeting, A and B
specify a duration and time frame for the meeting. Each
party i ∈ {A,B} then divides the time frame when the
meeting can take place (e.g., a week) into n time slots
tn
i = (ti,1, ...,ti,n) and denotes each time slot ti, j ∈ {0,1}
as either free (ti, j = 1) or occupied (ti, j = 0). The parties
compute their common availability tn
Avail by computing
the bitwise AND of their time slots, i.e., tn
A ∧ tn
.
B
Overall, this circuit has n AND gates and depth 1. Note
that the bitwise AND circuit performs a general function-
ality and can, for instance, be used for privacy-preserving
set intersection where elements are taken from a small
domain [HEK12] or location matching [CADT13]. For
our experiments, we set the time frames s.t. meetings
can be scheduled between 8 am and 10 pm for one day
divided into 15 minute slots (n = 56 slots), one week di-
vided into 15 minute slots (n = 392 slots), and one month
divided into 10 minute slots (n = 2,604 slots). We depict
our results in the upper half of Tab. 2.

Avail = tn

The multiplication triple generation in the init phase
can be performed in several hundred milliseconds, since
it requires only one (for 56 and 392 time slots) or two
(for 2,604 time slots) packet transfers between T and A.
The setup phase, more detailed the seed transfer proto-
col, is the main bottleneck in this application, as T has
to perform asymmetric and symmetric cryptographic op-
erations. Finally, the online phase requires only millisec-
onds but has a high variance, due to the communication
over Wi-Fi direct and the small number of communica-
tion rounds that are performed in the online phase.

For comparison, we evaluated the same circuit using
the mobile Yao implementation of [HCE11] on the same
phones, which took factor 1.6 (for the day time frame) up
to factor 12 (for the month time frame) longer, cf. Tab. 2.

Day

Week

Month

Table 2: Performance for availability and location-aware
scheduling.
| f| is the size of the circuit and d( f ) its
depth. All values measured on smartphones (cf. §5.3).
Time Frame
Availability Scheduling §6.1
| f| / d( f )
56 / 1
Init [s]
0.37 (±1.6%)
Setup [s]
1.3 (±13%)
Online [s]
0.002 (±150%)
Ad-Hoc [s]
1.3 (±13%)
Mobile Yao [HCE11]
Ad-Hoc [s]
2.14 (±7.1%)
Location-Aware Scheduling §6.2
| f| / d( f )
39,864 / 69
Init [s]
6.9 (±0.3%)
1.4 (±7.1%)
Setup [s]
Online [s]
0.16 (±35%)
1.5 (±8.4%)
Ad-Hoc [s]

392 / 1
0.37 (±1.6%)
1.3 (±13%)
0.003 (±167%)
1.3 (±13%)
3.82 (±4.7%)
280,605 / 87
48.5 (±0.2%)
1.8 (±7.0%)
0.82 (±7.4%)
2.6 (±6.5%)

2,604 / 1
0.73 (±1.0%)
1.3 (±13%)
0.007 (±129%)
1.3 (±13%)
15.9 (±2.7%)
1,872,206 / 106
319.6 (±0.5%)
4.8 (±4.8%)
5.9 (±18%)
10.7 (±11%)

6.2 Location-Aware Scheduling

In the following we show that our system can be adapted
to compute arbitrary and complex functions. We intro-
duce the location-aware scheduling functionality which
extends the availability scheduling of §6.1, s.t. the dis-
tance between the users is considered as well. The
location-aware scheduling functionality takes into ac-
count the user’s location in a time slot, computes the dis-
tance between the users, veriﬁes if a meeting is feasible,
and outputs the time slot in which the users have to travel
the least distance to meet each other. We argue that this
approach is practical, since such position information are
often already included in the users’ schedules.

In the location-aware scheduling scheme, we assume
that the user i ∈ {A,B} also inputs the location of the
previous appointment Pi and the next appointment Ni and
the distances that he can reach from his previous appoint-
ment pi and from his next appointment ni (cf. Fig. 9 for
an example). Such pi and ni can be computed in plain-
text using the distance between Pi and Ni, the free time
until the next appointment and the duration of the meet-
ing. The minimal distance among all time slots where the
reachable ranges for A and B overlap is selected as ﬁnal
result. If successful, the function outputs the identiﬁed
time slot and for each user whether he should leave from
the location of the previous or next appointment. A de-
tailed description of the functionality is given in the full
version [DSZ14]. We evaluate the scheme on the same
number of time slots used in §6.1 (day, week, month) and
depict the performance in the lower half of Tab. 2.
the location-
aware scheduling circuit is signiﬁcantly bigger and re-
quires more communication rounds. When performing
the scheduling for a month, the circuit consists of 1.8 mil-
lion instead of 2,604 AND gates for availability schedul-

Compared to availability scheduling,

902  23rd USENIX Security Symposium 

USENIX Association

pA

PA

nA

NA

pB

PB

nB

NB

Figure 9: Location-aware scheduling for one time slot of A and B with previous locations PA and PB, reachable
distances from previous appointments pA and pB, next locations NA and NB and corresponding reachable distances
nA and nB. The meeting can be scheduled between NA and PB as the reachable ranges overlap.

ing. The time for the init phase increases linearly with
the number of AND gates and requires 319 s when per-
forming scheduling for a month. The time for the setup
phase is increased less, since the seed transfer grows only
logarithmically in | f| and the seed expansion is done ef-
ﬁciently. The online phase is also slowed down substan-
tially (6 s for a month time frame), but is still practical.

6.3 Private Set Intersection
Private set intersection (PSI) is a widely studied problem
in secure computation and can be used for example to
ﬁnd common contacts in users’ address books [HCE11].
It enables two parties, each holding a set SA and SB with
elements represented as σ-bit strings to determine which
elements both have in common, i.e., SA ∩ SB, without
disclosing any other contents of their sets. While many
special-purpose protocols for PSI exist, e.g.,
[CT10,
CT12, CADT13], generic protocols mostly build on
the work of [HEK12], where the Sort-Compare-Shufﬂe
(SCS) circuit was outlined. The idea is to have both par-
ties locally pre-sort their elements, privately merge them,
check adjacent values for equality, and obliviously shuf-
ﬂe the resulting values to hide their order.

We implement the SCS-WN circuit of [HEK12] which
uses a Waksman permutation network to randomly shuf-
ﬂe the resulting elements. We perform the compar-
ison for bit sizes σ ∈ {24,32,160} and compare the
ad-hoc runtime of our protocol to the implementation
of [HCE11] for σ ∈ {24,32}. The results from [HEK12]
are compared to ours for σ ∈ {32,160}. The results
are given in Fig. 10 and in Tab. 3. Note that [HCE11]
and [HEK12] implement Yao’s garbled circuits protocol
using pipelining, whereas we use the GMW protocol.

100

[HEK12] SCS-WN (Desktop)
§4 Token Ad-Hoc (Phone)

]
s
[
 
e
m

i
t
n
u
R
 
c
o
H
-
d
A

10

1
128

256

512
Number of Inputs

1024

2048

4096

Figure 10: Private set intersection runtime for σ = 32 bit
elements using our token-based protocol on two smart-
phones (§5.3) and [HEK12] on two desktop PCs.

For a fair comparison, we ran the code from [HCE11]
on our Samsung Galaxy S3 smartphones and observed an
approximate speedup of factor 2 compared to the mea-
surements from their paper, that were made on older
hardware (two Google Nexus One phones). Note that
our performance results, as well as the values for the im-
plementation of [HCE11] are benchmarked on mobile
devices connected via Wi-Fi Direct, while [HEK12] is
benchmarked on two desktop PCs (two Core2Duo E8400
3GHz PCs connected via 100 Mbps LAN).

From Fig. 10 we observe that, due to the seed transfer
in our setup phase (cf. §4.2), the Yao’s garbled circuits
implementation of [HEK12] is faster for up to 256 inputs.
However, the seed transfer time amortizes for larger in-
puts and our token-based scheme outperforms the imple-

USENIX Association  

23rd USENIX Security Symposium  903

Table 3: Ad-hoc runtime of private set intersection where each party inputs n values of σ bits, measured on identical
mobile phones (§5.3). [HEK12] results are on PCs and taken from the paper (— indicates that no numbers were given).

Number of Inputs n

σ = 24bit

σ = 32bit

σ = 160bit

| f|
Ours [s]
[HCE11] [s]
| f|
Ours [s]
[HCE11] [s]
[HEK12] [s]
| f|
Ours [s]
[HEK12] [s]

32
22,432
1.7 (±2.2%)
30
30,368
1.7 (±2.7%)
42
—
156,768
2.2 (±8.8%)
—

64
52,096
1.9 (±3.4%)
68
70,528
1.9 (±3.5%)
87
—
364,096
2.7 (±16%)
—

128
118,656
2.1 (±2.4%)
161
160,640
2.3 (±7.7%)
233
1
829,312
4.0 (±1.9%)
—

256
266,240
2.5 (±2.4%)
410
360,448
3.0 (±18%)
565
2.2
1,860,864
7.0 (±1.9%)
—

512
590,336
3.6 (±4.2%)
1,052
799,232
4.4 (±9.8%)
1,468
4.95
4,126,208
14.3 (±2.9%)
—

1,024
1,296,384
7.4 (±8.7%)
3,010
1,755,136
8.5 (±20%)
4,662
10.5
9,061,376
28.7 (±1.4%)
51.5

mentation of [HEK12], even though our implementation
runs on substantially slower mobile phones while theirs
is evaluated on two desktop PCs. From Tab. 3 we ob-
serve that our scheme outperforms the Yao’s garbled cir-
cuits implementation of [HCE11], evaluated on identical
mobile phones, by factor 18 for 32 inputs with σ = 24 bit
and by up to factor 550 for 1,024 inputs with σ = 32 bit.
Finally, we compare the performance of our protocol
to the PSI protocol of [CADT11,CADT13]. We use their
reported numbers for pre-computed PSI on 20 input val-
ues and set the bit size σ = 160 in our protocol.5 The
protocol of [CADT11, CADT13] needs 3.7 s, while our
ad-hoc runtime is only 2.1 s (±4.8%). Note, however,
that their approach has only a constant number of rounds
and can be sped up using multiple cores.

7 Related Work

We classify related work into three categories: secure
function evaluation (§7.1), server-aided secure function
evaluation (§7.2), and token-based cryptography (§7.3).
7.1 Generic Secure Function Evaluation
The foundations for secure function evaluation (SFE)
were laid by Yao [Yao86] and Goldreich et al. [GMW87]
who demonstrated that every function that is efﬁciently
representable as Boolean circuit can be computed se-
curely in polynomial time with multiple parties.

SFE Compiler A ﬁrst compiler for speciﬁc secure
two-party computation functionalities was presented in
[MOR03]. The Fairplay framework [MNPS04] was the
ﬁrst efﬁcient implementation of Yao’s garbled circuits
protocol [Yao86] for generic secure two-party compu-
tation and enabled a user to specify the function to be
computed in a high-level language. The FastGC frame-
work [HEKM11] improved on the results of Fairplay by

5Note that [CADT11, CADT13] also support bigger bit sizes, since

they operate on 1,024-bit ElGamal ciphertexts.

evaluating functions with millions of Boolean gates in
mere minutes using optimizations such as the free XOR
technique [KS08] and pipelining. The FastGC frame-
work has been used to implement various functions such
as privacy-preserving set intersection [HEK12], genomic
sequencing, or AES [HEKM11], and was optimized with
respect to a low memory footprint in [HS13].

Next to Yao’s garbled circuits protocol, the GMW pro-
tocol [GMW87] recently received increasing attention.
The work of [CHK+12] efﬁciently implemented GMW
in a setting with multiple parties. Subsequently, [SZ13]
optimized GMW for the two-party setting and showed
that GMW has advantages over Yao’s garbled circuits
protocol as it allows to pre-compute all symmetric cryp-
tographic operations in a setup phase and that the work-
load can be split evenly among both parties.

SFE on Mobile Devices A recent line of research aims
at making SFE available on mobile devices, such as
smartphones. In [HCE11] the authors port the FastGC
framework [HEKM11] to smartphones and observe a
substantial performance reduction when compared to the
desktop environment. They identify the slower process-
ing speed and the high memory requirements as the main
bottlenecks. Similarly, [CMSA12] ported the Fairplay
framework [MNPS04] to smartphones. A compiler with
smaller memory constraints than Fairplay was presented
in [MLB12]. We emphasize that previous works on
generic SFE on mobile devices use Yao’s garbled circuits
protocol, whereas our approach is based on GMW.

Several special-purpose protocols for mobile de-
vices using homomorphic encryption were proposed in
[BJH+11] (activity scheduling), [CDA11] (scheduling,
interest sharing), and [CADT11,CADT13] (comparison,
location-based tweets, common friends). In contrast to
generic solutions, such custom-tailored protocols can be
more efﬁcient, but are restricted to speciﬁc functionali-
ties. Their extension to new use cases is complex and
usually requires new security proofs.

904  23rd USENIX Security Symposium 

USENIX Association

7.2 Server-Aided SFE
One way to speed up generic secure computations on re-
source constrained devices is to outsource expensive op-
erations to one or more servers. In [HS12] a system for
fair server-aided secure two-party computation using two
servers was introduced. SALUS [KMR12] is a system
for fair SFE among multiple parties using a single server.
A system that allows cloud-aided garbled circuits evalu-
ation between one mobile device and a server was intro-
duced in [CMTB13] and its efﬁciency was demonstrated
on large-scale practical applications, such as a secure
path ﬁnding algorithm. Both [CMTB13] and [KMR12]
achieve security against malicious adversaries, but re-
quire at least one party to be a machine with more com-
puting power than a mobile phone as it evaluates multiple
garbled circuits. [Hua12] proposes that a trusted server
generates multiplication triples that are sent to both par-
ties over a secure channel, requiring O(| f|) bits commu-
nication. Instead, we propose to replace the server with
a trusted hardware token and show that the communica-
tion to one party can be reduced to sub-linear complexity.
Moreover, they achieve security against malicious adver-
saries based on [NNOB12]; we sketch how to extend our
work to malicious security in the full version [DSZ14].
We consider this line of research as orthogonal to ours,
since it focuses on outsourcing secure computations to a
powerful but untrusted cloud server. In contrast, we fo-
cus on secure computation between two mobile devices
where computations are outsourced to a trusted, but re-
source constrained smartcard locally held by one party.

7.3 Token-Based Cryptography
Another approach is to outsource computations to trusted
hardware tokens, such as smartcards. These tokens are
typically resource-constrained, but have the advantage of
offering a tamper-proof trusted execution environment.

Setup Assumptions for UC Hardware tokens can be
used as setup assumption for Canetti’s universal compos-
ability (UC) framework, as they allow to construct UC
commitments, with which in turn any secure computa-
tion functionality can be realized, e.g., [Kat07, DNW09,
DKMQ11]. These works are mainly feasibility results
and have not been implemented yet.

SFE in Plaintext As discussed in [HL08], the trivial
solution to performing SFE using hardware tokens would
be to have each party send its inputs over a secure chan-
nel to the token, which evaluates f and returns the output.
A similar approach with multiple tokens, which addition-
ally provides fault tolerance was given in [FFP+06].

When using the hardware token for plaintext evalua-
tion, the performance of the time-critical online phase is
limited by the performance of the token, which is typi-
cally very low. Moreover, this requires the token to hold
all input values in memory, which quickly exceeds its
very limited resources.6 Alternatively, the token could
use external secure memory to store inputs and inter-
mediate values, e.g., [IS05, IS10], but this would require
symmetric cryptographic operations in the online phase.
Additionally, each new functionality would have to be
implemented on the token, whereas our scheme is imple-
mented only once and supports arbitrary functionalities.

Speciﬁc Functionalities An efﬁcient protocol for pri-
vate set-intersection using smartcards was presented
in [HL08]. This protocol was extended to multiple un-
trusted hardware tokens in [FPS+11]. An anonymous
credential protocol was presented in [BCGS09].

Outsourcing Oblivious Transfer There are several
works that use hardware tokens to compute oblivious
transfer (OT): [GT08] implemented non-interactive OT
using an extension of a TPM, [Kol10] proposed OT se-
cure in the malicious model using a stateless hardware
token, and [DSV10] provided non-interactive OT in the
malicious model using two hardware tokens.

We outsource the setup phase of the GMW proto-
col, which previously was done via OT, to the hard-
ware token. Previous works on outsourcing n OTs re-
quire the hardware token to evaluate O(n) symmetric (or
even asymmetric) cryptographic operations in the ad-hoc
phase. In comparison, our scheme requires T to evaluate
O(n/t) symmetric cryptographic operations in the init
phase and only O(log2 n) symmetric cryptographic oper-
ations in the setup phase (cf. the full version [DSZ14]).

8 Conclusion and Future Work

In this work, we demonstrated that generic ad-hoc se-
cure computation can be performed efﬁciently on mo-
bile devices when aided by a trusted hardware token.
We showed how to extend the GMW protocol by such
a token, similar to a TPM, to which most costly cryp-
tographic operations can be outsourced. Our scheme
pre-computes most of the workload of GMW in an
initialization phase, which is performed independently
of the later communication partner and without know-
ing the function or its size in advance. This is par-
ticularly desirable as the pre-computation can happen
at any time, e.g., when the device is connected to a

6The smartcard we use in our experiments has 1,750 Bytes of RAM,
which would be completely ﬁlled if each party provided 300 inputs of
24 bits length in private set intersection (cf. §6.3).

USENIX Association  

23rd USENIX Security Symposium  905

power source, which happens regularly with modern
smartphones. The remaining interactive ad-hoc phase
is very efﬁcient and can be executed in a few seconds,
even for complex functionalities. We implemented sev-
eral privacy-preserving applications that are typical for
mobile devices (availability scheduling, location-aware
scheduling, and set-intersection) on off-the-shelf smart-
phones using a general-purpose smartcard and showed
that their execution times are truly practical. We found
that the performance of our scheme is two orders of mag-
nitude faster than that of other generic secure two-party
computation schemes on mobile devices and comparable
to the performance of similar schemes in the semi-honest
adversary model implemented on desktop PCs.

We see several interesting directions for future re-
search. As our scheme is based on the GMW protocol,
it can easily be extended to more than two parties, e.g.,
for securely scheduling a meeting, cf. [CHK+12]. More-
over, our scheme can be modiﬁed to also provide security
against malicious parties, cf. [Hua12] (we provide more
details in the full version [DSZ14]). Another direction
might be equipping both mobile devices with a hardware
token to further improve efﬁciency and/or security.

Acknowledgements

We thank the anonymous reviewers of USENIX Security
2014 for their helpful comments on our paper. We also
thank Giesecke & Devrient for providing us with mul-
tiple smartcards and the authors of [HCE11] for shar-
ing their code with us. This work was supported by
the German Federal Ministry of Education and Research
(BMBF) within EC SPRIDE, by the Hessian LOEWE
excellence initiative within CASED, and by the Euro-
pean Union Seventh Framework Program (FP7/2007-
2013) under grant agreement n. 609611 (PRACTICE).

References

[ALSZ13] G. Asharov, Y. Lindell, T. Schneider,
M. Zohner. More efﬁcient oblivious trans-
fer and extensions for faster secure com-
putation.
In Computer and Communica-
tions Security (CCS’13), p. 535–548. ACM,
2013.

J. Camenisch, T. Groß,
[BCGS09] P. Bichsel,
Anonymous credentials on
V. Shoup.
a standard Java card.
In Computer and
Communications Security (CCS’09), p.
600–610. ACM, 2009.

[Bea91]

D. Beaver. Efﬁcient multiparty protocols
using circuit randomization.
In Advances

[Bea95]

[BJH+11]

in Cryptology – CRYPTO’91, volume 576
of LNCS, p. 420–432. Springer, 1991.

D. Beaver. Precomputing oblivious transfer.
In Advances in Cryptology – CRYPTO’95,
volume 963 of LNCS, p. 97–109. Springer,
1995.

I. Bilogrevic, M. Jadliwala, J.-P. Hubaux,
I. Aad, V. Niemi. Privacy-preserving activ-
ity scheduling on mobile devices. In ACM
Data and Application Security and Privacy
(CODASPY’11), p. 261–272. ACM, 2011.

[CADT11] H. Carter, C. Amrutkar,

I Dacosta,
P. Traynor. Efﬁcient oblivious computation
techniques for privacy-preserving mobile
applications.
Technical report, Georgia
Institute of Technology, 2011.

[CADT13] H. Carter, C. Amrutkar,

I. Dacosta,
P. Traynor. For your phone only: Custom
protocols for efﬁcient secure function eval-
uation on mobile devices. Journal of Secu-
rity and Communication Networks (SCN),
2013.

[CDA11]

E. D. Cristofaro, A. Durussel, I. Aad. Re-
claiming privacy for smartphone applica-
tions.
In Pervasive Computing and Com-
munications (PerCom’11), p. 84–92. IEEE,
2011.

[CHK+12] S. G. Choi, K.-W. Hwang,

J. Katz,
T. Malkin, D. Rubenstein. Secure multi-
party computation of Boolean circuits with
applications to privacy in on-line mar-
ketplaces.
In Cryptographers’ Track at
the RSA Conference (CT-RSA’12), volume
7178 of LNCS, p. 416–432. Springer, 2012.

[CMSA12] G. Costantino, F. Martinelli, P. Santi,
D. Amoruso. An implementation of secure
two-party computation for smartphones
with application to privacy-preserving
interest-cast. In Privacy, Security and Trust
(PST’12), p. 9–16. IEEE, 2012.

[CMTB13] H. Carter, B. Mood, P. Traynor, K. Butler.
Secure outsourced garbled circuit evalua-
tion for mobile phones. In USENIX Secu-
rity’13, p. 289–304. USENIX, 2013.

[CT10]

E. De Cristofaro, G. Tsudik. Practical pri-
vate set intersection protocols with linear
complexity. In Financial Cryptography and
Data Security (FC’10), volume 6052 of
LNCS, p. 143–159. Springer, 2010.

906  23rd USENIX Security Symposium 

USENIX Association

[CT12]

E. De Cristofaro, G. Tsudik. Experimenting
with fast private set intersection.
In Trust
and Trustworthy Computing (TRUST’12),
volume 7344 of LNCS, p. 55–73. Springer,
2012.

[DKMQ11] N. D¨ottling, D. Kraschewski, J. M¨uller-
Quade. Unconditional and composable se-
curity using a single stateful tamper-proof
hardware token.
In Theory of Cryptogra-
phy Conference (TCC’11), volume 6597 of
LNCS, p. 164–181. Springer, 2011.

[DNW09]

I. Damg˚ard, J. B. Nielsen, D. Wichs.
Universally composable multiparty com-
putation with partially isolated parties.
In Theory of Cryptography Conference
(TCC’09), volume 5444 of LNCS, p. 315–
331. Springer, 2009.

[DSV10] M. Dubovitskaya, A. Scafuro, I. Visconti.
On efﬁcient non-interactive oblivious trans-
fer with tamper-proof hardware. Cryptol-
ogy ePrint Archive, Report 2010/509, 2010.
http://eprint.iacr.org/2010/509.

[DSZ14]

D. Demmler, T. Schneider, M. Zohner. Ad-
hoc secure two-party computation on mo-
bile devices using hardware tokens. Cryp-
tology ePrint Archive, Report 2014/467,
2014. http://eprint.iacr.org/2014/
467.

[FFP+06] M. Fort, F. C. Freiling, L. D. Penso, Z. Be-
nenson, D. Kesdogan. TrustedPals: Se-
cure multiparty computation implemented
with smart cards.
In European Sympo-
sium on Research in Computer Security
(ESORICS’06), volume 4189 of LNCS, p.
34–48. Springer, 2006.

[FPS+11] M. Fischlin, B. Pinkas, A.-R. Sadeghi,
T. Schneider, I. Visconti. Secure set inter-
section with untrusted hardware tokens. In
Cryptographers’ Track at the RSA Confer-
ence (CT-RSA’11), volume 6558 of LNCS,
p. 1–16. Springer, 2011.

[GMW87] O. Goldreich, S. Micali, A. Wigderson.
How to play any mental game or a com-
pleteness theorem for protocols with hon-
est majority.
In Symposium on Theory of
Computing (STOC’87), p. 218–229. ACM,
1987.

[GT08]

V. Gunupudi, S. R. Tate. Generalized non-
interactive oblivious transfer using count-
limited objects with applications to secure

mobile agents. In Financial Cryptography
and Data Security (FC’08), volume 5143 of
LNCS, p. 98–112. Springer, 2008.

[HCC+01] T. Herlea,

J. Claessens, D. De Cock,
B. Preneel, J. Vandewalle. Secure meet-
ing scheduling with agenTa. In Communi-
cations and Multimedia Security (CMS’01),
volume 192 of IFIP Conference Proceed-
ings, p. 327–338. Kluwer, 2001.

[HCE11]

[HEK12]

Y. Huang, P. Chapman, D. Evans. Privacy-
preserving applications on smartphones.
In Hot
topics in security (HotSec’11).
USENIX, 2011.

Y. Huang, D. Evans, J. Katz. Private set in-
tersection: Are garbled circuits better than
custom protocols?
In Network and Dis-
tributed Security Symposium (NDSS’12).
The Internet Society, 2012.

[HEKM11] Y. Huang, D. Evans, J. Katz, L. Malka.
Faster secure two-party computation using
garbled circuits. In USENIX Security’11, p.
539–554. USENIX, 2011.

[HL08]

[HS12]

[HS13]

[Hua12]

[IET08]

C. Hazay, Y. Lindell. Constructions of truly
practical secure protocols using standard
smartcards. In Computer and Communica-
tions Security (CCS’08), p. 491–500. ACM,
2008.

A. Herzberg, H. Shulman.
Oblivious
and fair server-aided two-party computa-
tion. In Availability, Reliability and Secu-
rity (ARES’12), p. 75–84. IEEE, 2012.

W. Henecka, T. Schneider.
Faster se-
cure two-party computation with less mem-
ory.
In Symposium on Information, Com-
puter and Communications Security (ASI-
ACCS’13), p. 437–446. ACM, 2013.

Y. Huang.
Practical Secure Two-Party
Computation. PhD dissertation, University
of Virginia, 2012.

IETF. The Transport Layer Security (TLS)
Protocol Version 1.2.
Technical report,
Internet Engineering Task Force (IETF),
2008.

[IKNP03] Y. Ishai, J. Kilian, K. Nissim, E. Pe-
trank. Extending oblivious transfers ef-
ﬁciently.
In Advances in Cryptology –
CRYPTO’03, volume 2729 of LNCS, p.
145–161. Springer, 2003.

USENIX Association  

23rd USENIX Security Symposium  907

[IS05]

[IS10]

A. Iliev, S. Smith. More efﬁcient secure
function evaluation using tiny trusted third
parties. Technical report, Dartmouth Col-
lege, Computer Science, 2005.

Small, stupid,
A. Iliev, S. W. Smith.
secure computing with
and scalable:
Faerieplay.
In Workshop on Scalable
Trusted Computing (STC’10), p. 41–52.
ACM, 2010.

[JKSS10] K. J¨arvinen, V. Kolesnikov, A.-R. Sadeghi,
T. Schneider. Embedded SFE: Ofﬂoading
server and network using hardware tokens.
In Financial Cryptography and Data Se-
curity (FC’10), volume 6052 of LNCS, p.
207–221. Springer, 2010.

[Kat07]

[KMR12]

J. Katz. Universally composable multi-
party computation using tamper-proof hard-
ware. In Advances in Cryptology – EURO-
CRYPT’07, volume 4515 of LNCS, p. 115–
128. Springer, 2007.

S. Kamara, P. Mohassel, B. Riva. Salus:
a system for server-aided secure function
evaluation. In Computer and Communica-
tions Security (CCS’12), p. 797–808. ACM,
2012.

[KMSB13] B. Kreuter, B. Mood, A. Shelat, K. Butler.
PCF: a portable circuit format for scalable
two-party secure computation. In USENIX
Security’13, p. 321–336. USENIX, 2013.

[Kol10]

[KS08]

[MLB12]

V. Kolesnikov. Truly efﬁcient string obliv-
ious transfer using resettable tamper-proof
tokens. In Theory of Cryptography Confer-
ence (TCC’10), volume 5978 of LNCS, p.
327–342. Springer, 2010.

V. Kolesnikov, T. Schneider.
Improved
garbled circuit: Free XOR gates and ap-
plications.
In International Colloquium
on Automata, Languages and Program-
ming (ICALP’08), volume 5126 of LNCS,
p. 486–498. Springer, 2008.

B. Mood, L. Letaw, K. Butler. Memory-
efﬁcient garbled circuit generation for mo-
bile devices.
In Financial Cryptography
and Data Security (FC’12), volume 7397 of
LNCS, p. 254–268. Springer, 2012.

[MNPS04] D. Malkhi, N. Nisan, B. Pinkas, Y. Sella.
Fairplay – a secure two-party computation
system.
In USENIX Security’04, p. 287–
302. USENIX, 2004.

[MOR03]

P. MacKenzie, A. Oprea, M. K. Reiter.
Automatic generation of two-party com-
putations.
In Computer and Communica-
tions Security (CCS’03), p. 210–219. ACM,
2003.

[MvOV96] A. Menezes, P. C. van Oorschot, S. A. Van-
stone. Handbook of Applied Cryptography.
CRC Press, 1996.

[NIS09]

[NIS12]

NIST. NIST Special Publication 800-56b,
Recommendation for Pair-Wise Key Estab-
lishment Schemes Using Integer Factoriza-
tion). Technical report, National Institute of
Standards and Technology (NIST), 2009.

NIST.
NIST Special Publication 800-
57, Recommendation for Key Management
Part 1: General (Rev. 3). Technical report,
National Institute of Standards and Tech-
nology (NIST), 2012.

[NNOB12] J. B. Nielsen, P. S. Nordholt, C. Or-
landi, S. S. Burra.
A new approach
to practical active-secure two-party com-
putation.
In Advances in Cryptology –
CRYPTO’12, volume 7417 of LNCS, p.
681–700. Springer, 2012.

[NP01]

[PFW11]

[Rab81]

[SZ13]

[TCG13]

[Yao86]

M. Naor, B. Pinkas. Efﬁcient oblivious
transfer protocols.
In ACM-SIAM Sympo-
sium On Discrete Algorithms (SODA’01),
p. 448–457. Society for Industrial and Ap-
plied Mathematics, 2001.

G. P. Perrucci, F. H. P. Fitzek, J. Wid-
mer. Survey on energy consumption enti-
ties on the smartphone platform. In Vehicu-
lar Technology Conference (VTC’11), p. 1–
6. IEEE, 2011.

M. O. Rabin. How to exchange secrets with
oblivious transfer, TR-81 edition, 1981.
Aiken Computation Lab, Harvard Univer-
sity.

T. Schneider, M. Zohner.
GMW vs.
Yao? Efﬁcient secure two-party compu-
tation with low depth circuits.
In Fi-
nancial Cryptography and Data Security
(FC’13), volume 7859 of LNCS, p. 275–
292. Springer, 2013.

TCG. TCG TPM speciﬁcations 2.0, 2013.
Trusted Computing Group.

A. C. Yao. How to generate and exchange
secrets.
In Foundations of Computer Sci-
ence (FOCS’86), p. 162–167. IEEE, 1986.

908  23rd USENIX Security Symposium 

USENIX Association

