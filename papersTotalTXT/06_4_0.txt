Contextual Policy Enforcement in Android Applications

with Permission Event Graphs

Kevin Zhijie Chen†, Noah Johnson†, Vijay D’Silva†, Shuaifu Dai†, Kyle MacNamara†, Tom Magrino†,

Edward Wu†, Martin Rinard‡, and Dawn Song†

†University of California, Berkeley∗
‡Massachusetts Institute of Technology

Abstract

The difference between a malicious and a benign An-
droid application can often be characterised by context and
sequence in which certain permissions and APIs are used.
We present a new technique for checking temporal proper-
ties of the interaction between an application and the An-
droid event system. Our tool can automatically detect sensi-
tive operations being performed without the user’s consent,
such as recording audio after the stop button is pressed, or
accessing an address book in the background. Our work
centres around a new abstraction of Android applications,
called a Permission Event Graph, which we construct with
static analysis, and query using model checking. We eval-
uate application-independent properties on 152 malicious
and 117 benign applications, and application-speciﬁc prop-
erties on 8 benign and 9 malicious applications. In both
cases, we can detect, or prove the absence of malicious be-
haviour beyond the reach of existing techniques.

1

Introduction

Users of smartphones download and install software
from application markets. According to the Google I/O
keynote in 2012, by June 2012, the ofﬁcial market for An-
droid applications, Google Play, hosted over 600,000 appli-
cations, which had been installed over 20 billion times. De-
spite recent advances in mobile security, there are examples
of malware that cannot be detected by existing techniques.

∗The 4-7th authors are now at Peking Univerisity, UC Santa Barbara,
Cornell University and University of Washington, Seattle, respectively.
The work was done when the authors were in UC Berkeley.

A malicious application can compromise a user’s secu-
rity in several ways. Examples include leaking phone iden-
tiﬁers, exﬁltrating the contents of an address book, or audio
and video eavesdropping. Consult recent surveys for more
examples of malicious behaviour [12, 14, 19].

In this paper, we focus on detecting malicious behaviour
that can be characterised by the temporal order in which
an application uses APIs and permissions. Consider a ma-
licious audio application and which eavesdrops on the user
by recording audio after the stop-button has been pressed,
and a benign one. Both applications use the same permis-
sions, and start and stop recording in response to button
clicks. Malware detection based on syntactic or statistical
patterns of control-ﬂow or permission requests cannot dis-
tinguish between these two applications [14, 15, 18]. The
difference between the two applications is semantic and re-
quires semantics-based analysis.

The intuition behind our work is that user expectations
and malicious intent can be expressed by the context in
which APIs and permissions are used at runtime. A user
expects that clicking a start or stop button, will respectively,
start or stop recording, and further, that this is only way an
audio application records. This expectation can be encoded
by two API usage policies. The API to start recording au-
dio should be called if and only if the event handler for the
start button was previously called. The API to stop record-
ing should be called if and only if the event handler for the
stop button was previously called. Policies requiring that
sensitive resources are not accessed by background tasks or
in response to timer events can also aid in distinguishing
benign from malicious behaviour.

We present Pegasus, a system for specifying and auto-
matically enforcing policies concerning API and permission
use. Pegasus combines static analysis, model checking, and

runtime monitoring. We anticipate several applications of
such technology. One is automatic, semantics-based screen-
ing for malware. Another is as a diagnostic tool that se-
curity analysts can use to dissect potentially malicious ap-
plications. A third is to provide ﬁne-grained information
about permission use to enable users to make an informed
decision about whether to install an application.

Our system can be attacked by malware writers who ob-
fuscate their applications to avoid static detection. How-
ever, such obfuscation will trigger our runtime checks and
lead to convoluted code structures, which can be detected
syntactically. Thus an attempt to evade our system and may
only result in drawing greater scrutiny to the application.

1.1 Problem and Approach

We now describe the challenges behind policy speciﬁca-
tion and checking in greater detail, and the insights behind
our solution.
Problem Deﬁnition. We consider three closely related
problems. The ﬁrst problem is to design a language for
specifying the event-driven behaviour of an Android appli-
cation. The second problem is to construct an abstraction of
the interaction between an Android application and the An-
droid event system. The third problem is to check whether
this abstraction satisﬁes a given policy. A solution to these
problems would allow us to specify security policies and de-
tect (or prove the absence of) certain malicious behaviour.
Challenges. Property speciﬁcation mechanisms typically
focus on an application. Executing a task in the background,
or calling an API after a button is clicked, are properties of
the Android event system, not the application. Specifying
policies governing event-driven API use requires a language
that can describe properties of an application as well as of
the operating system. For example, specifying that audio
should not be recorded after a stop button is clicked, re-
quires us to describe an application artefact, such as a but-
ton, a system artefact, such as a recording API, and the in-
teraction between the two.

Checking policies of the form above is a greater chal-
lenge. Software model checking is a powerful technique for
checking temporal properties of programs. Software model
checkers construct abstractions of a program and then check
properties using ﬂow-sensitive analysis. The execution of
an Android application is the result of intricate interplay
between the application code and the Android system or-
chestrated by callbacks and listeners. Constructing an ab-
straction of such behaviour is difﬁcult because control-ﬂow
to event-handlers is invisible in the code. Moreover, static
analysis of event-driven programs has received little atten-
tion, and was recently shown to be EXPSPACE-hard [25].
The ﬁrst analysis challenge is to model control-ﬂow be-
tween the event system and application.

The second analysis challenge is to design and compute
an abstraction that can represent event-driven behaviour, but
is small compared to the Android system. Most existing
techniques abstract data values in a program, but our focus
on the Android event system mandates a new abstraction.
The challenge in computing an abstraction lies in modelling
the Android event system, and dealing with complex heap
manipulation in Android programs, and their use of reﬂec-
tion, and APIs from the Java and Android SDK.
Insights. We overcome the aforementioned challenges us-
ing the insights described next. Our ﬁrst insight is that
though the Android system is a large, complicated object,
it changes the state of the application using a ﬁxed set of
event handlers. It sufﬁces for a policy language to express
event handlers, APIs, and certain arguments to APIs to spec-
ify the context in which an application uses permissions.

Even a restricted analysis of the Android event system
or event handlers deﬁned in an application is not feasible
due to the size of the code and the state-space explosion
problem. Our second insight is to use a graph to make the
interaction between an application and the system explicit.
We introduce Permission Event Graphs (PEGs), a new rep-
resentation that abstracts the interplay between the Android
event system, and permissions and APIs in an application,
but excludes low-level constructs.

Our third insight is that a PEG can be viewed as a pred-
icate abstraction of an Android application and the An-
droid system, where predicates describe which events can
ﬁre next. Standard predicate abstraction engines use theo-
rem provers to compute how program statements transform
predicates over data. We implement a new, Android spe-
ciﬁc, event semantics engine, which can compute how API
calls transform predicates over the Android event queue.

The ﬁnal challenge, once an abstraction has been con-
structed is to check that it satisﬁes a given policy. We use
standard model checking algorithms for this purpose. De-
tecting sequences or repeating patterns in an application can
be implemented using basic graph-theoretic algorithms for
reachability and loop detection.

Our experience suggests that PEGs reside in a sweet-spot
in the precision-efﬁciency spectrum. Our analysis based on
PEGs is more precise than existing syntactic analyses and is
more expensive to construct. However, we gain efﬁciency
because a single PEG can be queried to check several poli-
cies pertaining to a single application.

1.2 Content and Contributions

In this paper, we study the problem of detecting mali-
cious behaviour that manifests via patterns of interaction
between an application and the Android system. We design
a new abstraction of the context in which event-handlers
ﬁre, and present a system for specifying, computing and

checking properties of this abstraction. We make the fol-
lowing contributions:

1. Permission Event Graphs: A novel abstraction of the
context in which events ﬁre, and event-driven manner
in which an Android application uses permissions.

2. Encoding user and malicious intent: We encode
user expectations and malicious behaviour as tempo-
ral properties of PEGs.

3. PEG construction: We devise a static analysis algo-
rithm to construct PEGs. The algorithm computes a
ﬁxed point involving transformers, generated by the
program, the event mechanism, and APIs. Our event
model supports 63 different event handling methods in
21 Android SDK classes.

4. PEG analysis: We implement Pegasus, an automated
analysis tool that takes as input a property, and checks
if the application satisﬁes that property.

5. Experiments: We check 6 application-independent
properties of 269 applications, and check application-
speciﬁc properties of 17 applications. Pegasus can au-
tomatically identify malicious behaviour, which was
previously discovered by manual analysis.

The paper is organised as follows: We summarise back-
ground on Android and introduce our running example in
Section 2. PEGs are formally deﬁned in Section 3 and can
be constructed using the algorithm in Section 4. The details
of our system appear in Section 5, followed by our evalua-
tion in Section 6. We conclude in Section 8 after discussing
related work in Section 7.

2 Background and Overview

In this section, we give an overview of the Android plat-
form as relevant for this paper and illustrate PEGs with a
running example.

2.1 Android

Android is a computing platform for mobile devices.
It includes a multi-user operating system based on Linux,
middleware, and a set of core applications. Users install
third-party applications acquired from application markets.
An Android package is an archive (.apk ﬁle) containing
application code, data, and resource information.

Applications are typically written in Java but may also
include native code. Applications compile into a custom
Dalvik executable format (.dex), which is executed by the
Dalvik virtual machine.
Permissions. A permission allows an application to access
APIs, code and data on a phone. Permissions are required to
access the user’s contacts, SMS messages, the SD card, cam-
era, microphone, Bluetooth, and other parts of the phone.

All permissions required by an application must be granted
by a user at install time.
The Manifest.
Every application has a manifest ﬁle
(AndroidManifest.xml) describing the application’s re-
quirements and constituents. The manifest contains com-
ponent information, the permissions required, and Android
API version requirements. The component information lists
the components in an application and names the classes im-
plementing these components.
Components. The building blocks of Android applica-
tions are components. A component is one of four types:
activity, service, content provider, and broadcast receiver,
each implemented as a subclass of Activity, Service,
ContentProvider, and BroadcastReceiver, respec-
tively. An activity is a user-oriented task (such as a
user interface), a service runs in the background. a con-
tent provider encapsulates application data, and a broad-
cast receiver responds to broadcasts from the Android sys-
tem. Components (consequently, applications) interact us-
ing typed messages called intents.
Lifecycles. A lifecycle is a pre-deﬁned pattern governing
the order in which the Android system calls certain meth-
ods. An application can deﬁne callbacks and listeners that
contribute to the lifecycle.

An activity is started using the startActivity or
startActivityForResult API calls. During execution,
an activity may be running, meaning it is visible and has
focus, paused, if it is visible but not in focus, or stopped
if it is not visible. Application execution usually begins in
an activity. A service may be started or bound. A service
is started if a component calls startService, following
which the service runs indeﬁnitely, even if the component
invoking it dies. The bindService call allows components
to bind to a service. A bound service is destroyed when all
components bound to it terminate.
Events and APIs. Events and APIs are the two ways an
Android application interacts with the system. We deﬁne
an event as a situation in which the Android system calls
application code. Examples of events are taps, swipes, SMS
notiﬁcations, and lifecycle events. The code that is called
when an event occurs is called an event handler. We deﬁne
an API to be a system deﬁned function, which applications
In this paper, we are concerned with event and
can call.
permission APIs. An event API
is one that changes how
events are handled, such as registering a Button.onClick
listener, or making a button invisible.

2.2 Overview and Running Example

We now demonstrate the concepts in this paper with a
running example, as well as how we envision the system
being used. Consider a malicious audio recording applica-

Figure 1. User interface for the running example.
The application records audio in a background service
after the user has clicked the stop button.

tion, which eavesdrops on the user. On startup, the applica-
tion displays the interface shown in Figure 1. This interface
is implemented as a Recorder activity and contains two
buttons, REC and STOP.

Initially, only REC is clickable. Clicking REC initiates
recording, makes STOP clickable, and disables REC from
being clicked. Clicking STOP terminates recording, enables
REC, and disables STOP. When the application is started,
it registers a service, which creates a system timer callback,
which is invoked every 15 minutes. The callback function
records 3 minutes of audio and stores it on the SD card.
Since services run in the background, this application will
eavesdrop even after the recorder application is closed.

We now consider two problems: How can we precisely
deﬁne malicious behaviour such as surreptitious recording?
How can we automatically detect such behaviour?
Deﬁning Malicious Intent. Rather than deﬁne malicious
intent, we focus on deﬁning user intent, or user expecta-
In our example, the details of how recording hap-
tions.
pens is determined by the developer, but a user expects to
be deﬁning when recording happens. Moreover, the user
expects that clicking REC will start recording, that clicking
STOP will stop recording, and that this is the only situa-
tion in which recording occurs. This expectation contains a
logical component and a temporal component, and can be
formally expressed by a temporal logic formula.
(¬Start-Recording U REC.onClick)

∧ (Stop-Recording ⇐⇒ STOP.onClick)

in English, asserts that

the proposition
This formula,
Start-Recording does not become true until the proposition
REC.onClick is true, and that Stop-Recording is true if and
only if STOP.onClick is true. Such a formula is interpreted
over an execution trace. REC.onClick and STOP.onClick are
true at the respective instants in a trace when the eponymous
buttons are clicked. The propositions Start-Recording and
Stop-Recording are true in the respective instants when the
APIs to start and stop recording are called.

A second example of user expectation is that an SMS is
not sent unless the user performs an action, such as click-
ing a button. A third example is that when an SMS arrives,

Figure 2. Permissions requested by the recording ap-
plication during installation.

the user is notiﬁed. These properties can be expressed by
the two formula below. The second formula expresses that
a broadcast message (such as an SMS notiﬁcation) is not
aborted by the application.

¬Send-SMS U Button.onClick
¬BroadcastAbort

The three formulae above fall into two different cate-
gories. The SMS and broadcast properties are application
independent. They can be checked against all applications,
and are part of a cookbook of generic properties we have
developed. The properties about recording are application
speciﬁc and have to be written by the analyst.

The set of propositions is deﬁned by our tool, and in-
cludes permissions, API calls, certain event handlers, and
constant arguments to API calls. To aid the analyst, we have
implemented a tool that extracts from an application’s man-
ifest, the names and types of user interface entities such as
buttons and widgets, and their relevant event-handlers.

We express user intent with formulae. We say that an
application exhibits potentially malicious intent if it does
not satisfy a user intent formula. Our tool Pegasus auto-
matically checks if an application satisﬁes a formula. If an
application violates a property, Pegasus provides diagnostic
information about why the property fails. The analyst has to
decide if failure to respect user intent is indeed malicious.
We discuss this issue in greater detail later.
Detecting Potentially Malicious Intent. How can we de-
termine if an Android application respects a formula spec-
ifying user intent? Figure 2 depicts the permissions re-
quested by the recorder during installation. Techniques
that only examine permission requests [1, 18, 20] will only

know that the application uses audio and SD card permis-
sions. Since control-ﬂow between the Android system and
event-handlers is not represented in a call graph, structural
analysis of call graphs [12, 23], will not identify the be-
haviours discussed above.

The challenge in checking temporal properties is to con-
struct an abstraction satisfying two requirements: It must
be small enough for model checking to be tractable.
It
must be large enough to avoid generating a large number
of false positives. Permissions used by an application, call
graphs, and control ﬂow graphs can be viewed as abstrac-
tions that can be efﬁciently analysed but do not satisfy the
second requirement. We now describe an abstraction that
enriches permission sets and call graphs with information
about event contexts.
Permission Event Graphs. We have devised a new ab-
straction called a Permission Event Graph (PEG). In a PEG,
every vertex represents an event context and edges repre-
sent the event-handlers that may ﬁre in that context. Edges
also capture the APIs and permissions that are used when
an event-handler ﬁres. Since permissions such as those for
accessing contact lists, are determined by APIs calls and the
argument values, knowledge of APIs does not subsume per-
missions. Example information that a PEG can represent is
that clicking a speciﬁc button causes the READ CONTACTS
permission to be used, while the ACCESS FINE LOCATION
permission is used in a background task.

A portion of the PEG for the running example is shown
in Figure 3. Every vertex represents an event context. There
are two types of edges. Solid edges represent synchronous
behaviour, and dashed edges represent asynchronous be-
haviour. We refer to the ﬁring of one or more event handlers
as an event and the use of one or more APIs and permissions
as an action. An edge label E
A represents that when the event
E occurs, the action A is performed.

Figure 3 shows that when the event-handler REC.onClick
is called, the action denoted Start-Recording occurs. This
action represents calling an API to start recording. We have
omitted portions of the PEG related to the activity initialisa-
tion, destruction, and the service lifecyle. Next, the event
STOP.onClick is enabled, and when it occurs, causes the
Stop-Recording action. The dashed edge from onResume
indicates an asynchronous call to start a service.

The PEG captures semantic information about an appli-
cation that is not computed by existing techniques. For ex-
ample, we see that there are two distinct contexts in which
the audio is recorded. We also see that recording stops if we
click STOP, but this is not the only way to stop recording.
Examining the PEG reveals that the application records
audio even if REC is not clicked. Moreover, we can deter-
mine the sequence of events leading to this malicious be-
haviour: a new service is started, a timer is then created,
and timer events start recording. PEGs generated in practice

are too large to examine manually. In such cases, speciﬁ-
cations can be treated as queries about the application, and
model checking can be used to answer such queries.
Security Analysis with PEGs. The techniques we develop
have several uses. All the uses follow the workﬂow of start-
ing with a set of properties, automatically constructing a
PEG for an application and model checking the PEG, manu-
ally examining the results of model checking, and repeating
this process if required.

There are several kinds of properties that an analyst can
check. We have developed a cookbook of application-
independent properties, such as background audio or video
recording. An analyst can write application-speciﬁc proper-
ties to check that an application functions as expected. For
example, clicking REC should start recording, and STOP
should stop recording. An analyst can also pose questions
about the behaviour of speciﬁc event-handlers: Does click-
ing the STOP button stop recording? If the application is
sent to the background, will recording continue or stop? If
the application is killed while recording, will the data be
saved to the SD card? All these questions can be encoded as
temporal properties.

Our tool Pegasus can be used to automatically construct
the PEG for an application and model check the PEG. If a
property is satisﬁed, the analyst will have to check if it was
too general, and try a more speciﬁc property. If a property is
not satisﬁed, the model checker will generate a counterex-
ample trace: a sequence of events and actions violating the
property. The analyst has to examine the trace and see if it is
symptomatic of malicious behaviour. If the behaviour is po-
tentially malicious, the analyst will have to reproduce it at
runtime. If the behaviour is benign, the analyst will have to
strengthen the property that is checked to narrow the search
for malicious behaviour.

To summarise, a vocabulary based on events and actions
allows for describing a new family of benign and malicious
behaviour beyond the reach of existing speciﬁcation mech-
anisms. Events are a runtime manifestation of user inter-
action with an application, and actions describe an applica-
tion’s response. Speciﬁcations involving events and actions
allow us to encode user intent in mechanical terms. From a
user’s perspective, a PEG summarises the dialogue between
a user (via events) and an application. From an algorithmic
perspective, a PEG is a data-structure encoding the interac-
tion between the Android event system (via calls to event-
handlers) and application code.

3 An Abstraction of Android Applications

The contributions of this section are a formal deﬁnition

of PEGs, and a symbolic encoding of PEGs.

Recorder
Activity

a0

onCreate

initialization

onResume
startService

Recorder
Service

s0

s1

onCreate

onStart

Timer.run

Start-Recording

STOP.onClick
Stop-Recording

a1

a2

REC.onClick

Start-Recording

s2

s3

Timer.run

Stop-Recording

ﬁnalization

ﬁnalization

Figure 3. Permission Event Graph for the running example. Vertices represent event contexts and an edge label E
A
represents that when the event-handler E ﬁres, an action A is performed. Dashed edge represent asynchronous tasks.

3.1 Transition Systems from Android Apps

An Android application deﬁnes an inﬁnite-state transi-
tion system, which describes the runtime behaviour of an
application. The transition system we deﬁne makes the
control-ﬂow and event-relationships in an application ex-
plicit. It is a mathematical object that we never construct,
but it informs the design of our analysis.
States. A runtime state, or just state, is composed of an
application state and a system state. The application state
consists of the application program counter, a valuation of
program variables, and the contents of the stack and the
heap. The system state consists of the contents of the event
queue, event handlers and listeners that are enabled, and
other global system states. The set of states

State = App-States × Sys-States

contains all combinations of application and system states.
These sets include unreachable states. A state σ = (p, s),
consists of an application state p and a system state s. We
denote the set of initial states of execution as Init.
Transitions. An application changes its internal state by
executing statements, and changes the system state by mak-
ing API calls. Conversely, the system may change its own

state or change application state by calling event handlers.
A transition is the smallest change in the state of an appli-
cation or system, and

Trans ⊆ State × State

is the transition relation of an application. A transition t
is caused by executing a statement, denoted stmt(t), in the
application or system code. We call t is an application tran-
sition if stmt(t) is in the application code and is a system
transition otherwise.
Transition Systems. The evolution of an application and
the Android system over time is mathematically described
by a transition system

T = (State, Trans, Init, stmt)

consisting of a set of states State, a transition relation
Trans, a set of initial states Init, and a function stmt that
labels transitions with statements.
Traces. We formalise the execution of the application in the
system. A trace of T is a sequence of states π = π0, π1, . . .
in which π0 is an initial state and every pair (πi, πi+1) is a
transition. We write traces(σ) for the set of traces originat-
ing from σ, and write traces(T ) for the set of traces of T . A
trace contains complete information about application and
system transitions.

3.2 Permission Event Graphs

The transition system deﬁned by an application is inﬁnite
and checking its properties is undecidable in general. The
standard approach to addressing such undecidability is to
construct an abstraction of this transition system. We now
introduce Permission Event Graphs , a variation of transi-
tion systems, which can represent ﬁnite-state abstractions
of Android applications.

Example 1. Revisit the PEG for the running example in
Figure 3. A vertex in the ﬁgure is called an abstract state.
The abstract state a1 represents all possible runtime states
in which the REC.onClick event-handler may be called in
the recorder activity. An edge in the ﬁgure is an abstract
transition. The abstract transition from a1 to a2 has a label
representing that if the event-handler REC.onClick is called,
the application will disable the REC, enable the STOP, start
recording, and transition to the state a2. The dashed edge
is an asynchronous transition, representing that the action
Start-Recording launches an asynchronous task.
In this
(cid:67)
case, a service is started.

A formal deﬁnition of PEGs follows. We use the preﬁx
“a” to indicate sets used as abstractions. We write P(S) for
the set of all subsets of a set S.

We deﬁne an event to be a set of event handlers. For
example, the event STOP.onClick represents a single event
handler. We can also deﬁne an event onClick that corre-
sponds to all event handlers which may be called when a
button is clicked. Formally, let Handler be a set of event
handlers and Event be a set of symbols, each representing
one or more event-handlers.

Deﬁnition 1. A Permission Event Graph (PEG) over a set
of event symbols Event and APIs API is a tuple

P EG = (aState, aTrans, bTrans, aInit)

consisting of the following.

• A set of abstract states aState. Every abstract state
represents a set of runtime states, which form the con-
text of an event.
• A labelled transition relation aTrans ⊆ aState ×
Event × P(API) × aState, where each transition
(s1, E, A, s2), represents that in state s1, the event E
may ﬁre, and causes the APIs in A to be called, leading
to abstract state s2.
• A relation bTrans ⊆ P(API)×aState, where each tu-
ple (A, s), represents that the action A causes an asyn-
chronous transition to the abstract state s.

• A set aInit of abstract initial states.
PEGs are different from control ﬂow graphs, call graphs,
and other standard graph-based abstractions of programs.

A PEG is different from to a control ﬂow graph because it
does not represent the syntactic structure of source code. A
PEG only contains calls to system APIs, rather than all calls,
as in a call graph, but also includes the values of arguments,
hence is related, but incomparable (mathematically) to a call
graph. We use the word “Permission” in the name because
permissions are determined by calls to APIs and their argu-
ments. We use the word “Event” to emphasise that state
transitions represent the effect of ﬁring event handlers.

We use graph algorithms to analyse PEGs. To derive the
PEGs of an application efﬁciently, our abstraction engine
uses the symbolic encoding introduced next.

3.3 A Symbolic Encoding of PEGs

We now devise a compact encoding of PEGs. Our en-
coding uses Boolean variables to represent PEG states and
labels to represent actions, and can be exponentially more
succinct than representing a PEG as a labelled graph.
Mode Variables and Event-Modalities. We ﬁrst encode
PEG states using Boolean variables. Deﬁne a set ModeVars
of Boolean-valued mode variables. The Boolean encoding
of an abstract state is a function

s : ModeVars → {true, false}

that assigns truth values to mode variables. The number
of mode variables we need is logarithmic in the number of
states of a PEG.

A Boolean formula ϕ over ModeVars represents the set
of Boolean encodings that make ϕ true. Recall that a literal
is a Boolean variable or its negation, and a cube is a con-
junction of literals. Let Cube be the set of cubes over mode
variables in a subset of ModeVars. We only use cubes and
not arbitrary Boolean formula over ModeVars to represent
sets of encodings because cubes can be efﬁciently manipu-
lated, while arbitrary formula cannot. The same encoding
choice is used in the SLAM project [2].

We encode abstract transitions using tuples called event-

modalities. An event-modality is a tuple

(P re, A, P ost) ∈ Cube × P(API) × Cube

consisting of a precondition P re, a set of API labels A, and
a postcondition P ost. An event-modality (P re, A, P ost)
represents the set of abstract transitions that begin in some
abstract state represented by P re, and transition to some
abstract state represented by P ost, while causing the action
A. Notice that events are not part of an event-modality.

Event-modalities encode abstract states and actions. We

also have to encode events. An event-map is a function

event-map : Handler → Cube

that maps each event-handler to a cube representing the set
of abstract states in which that event-handler may ﬁre. A
symbolic encoding of a PEG is a tuple

sP EG = (aInit, EventModality, event-map)

consisting of a cube aInit representing initial states, a set
EventModality of event-modalities, and an event-map.

Example 2. Consider a Boolean variable TimerEnabled
and a label Start-Recording. The timer-related behaviour
in Figure 3 can be encoded using the value true for
TimerEnabled to represent s2 and the value false to repre-
sent s3. The abstract transition from s1 to s2 is represented
by the event-modality below.
(TimerEnabled ,{Start-Recording},¬TimerEnabled )

If the precondition TimerEnabled is true, the timer event
TIMER.run is enabled. If the event ﬁres, the event handler
causes the application to transition to a state satisfying the
postcondition ¬TimerEnabled.
(cid:67)

4 The Abstraction Engine

The contribution of this section is a procedure and ar-
chitecture for constructing PEGs from Android applications.
Our implementation of this procedure combines a model of
the Android event system and APIs with ﬁxed point iteration
in a lattice to derive PEGs.

4.1 The Core Algorithm

The interaction between an application, the event mecha-
nism and libraries in an Android application is summarised
in the upper part of Figure 4. The dashed arrows show that
the state of an execution is modiﬁed either by executing ap-
plication code or when the event system ﬁres an event han-
dler. The solid arrows denote calls. An application may call
the Android APIs, and if the call is to register a listener, the
APIs in turn access the event system.

The architecture we use to compute a symbolic PEG is
shown in the lower part of Figure 4. Each shaded box rep-
resents an engine in our implementation. The different en-
gines interact to compute a set of event-modalities. We ab-
stract application code with a static analyser, model event
generation and destruction with an event semantics engine,
and model APIs with an API semantics engine.

Our static analyser determines a set of preconditions,
which specify event contexts. When an API call is encoun-
tered, the precondition and API name are given to the API
semantics engine. If the API modiﬁes the application state,
a postcondition is returned to the static analyser. If the API
modiﬁes the system state, the name of the API is given to the

Application

Call Event
Handler

States

API call

Event System

Libraries

Register
Listener

Application
Analyzer

Preconditions

EventM odalities

API call

Precondition
Postconditions

Event

Semantics

Engine

API

Semantics

Engine

Handler name

Figure 4. Intuition behind the abstraction engine.
The system computes event modalities by combining
a static analyser, which abstracts application seman-
tics, an API semantics engine, which abstracts API
calls, and an event semantics engine, which abstracts
the event system.

event semantics engine. The event semantics engine com-
putes the set of preconditions for that event handler to ﬁre,
and the static analyser had to determine whether to analyse
the event handler code. By iterating between these three en-
gines, we derive a set of event-modalities that symbolically
encode a PEG for an application.

The functions below formalise these components.

entry : Handler → P(API)
next : Handler ×API → P(API)

event-sem : Handler → P(Cube)

api -sem : API × Cube → P(Cube)
app-sem : Handler ×Cube

→ P(P(API) × Cube)

The function entry takes as input an event-handler name,
retrieves the code, constructs the CFG for the event-handler,
and retrieves the ﬁrst set of API calls reachable from the
entry of the CFG, without calling other APIs. The function
next is similar to entry. When invoked as next(h, A) on
an event handler h with API call A, next will return the set

C of APIs in h that may be called after calling A, such that
there is no API call between A and each API in C. These
functions are implemented in the static analyser, by com-
bining control-ﬂow reachability with pointer analysis.

The function event-sem takes as input an event handler
and returns as output a set of cubes representing precondi-
tions for that event handler to ﬁre. This function is imple-
mented by the event semantics engine.

The function api -sem takes as input an API call A and
a precondition p and returns a set Q of postconditions. The
postconditions satisfy that executing A in a state satisfying
p leads to a state satisfying some cube in Q. This function
is implemented by the API semantics engine.

The function app-sem takes as input an event handler
and a precondition, and returns a set of pairs of the form
(A, q). Let h be an event handler. Towards formally deﬁn-
ing app-sem, we deﬁne a function

reach-sem h :P(P(API) × API × Cube)

→ P(P(API) × API × Cube)

that maps a tuple (A, a, p) representing a set of APIs A pre-
vious executed, and the API a that will be executed with
precondition p to the tuple (A∪{a}, b, q), where b is an API
that can be executed after a and q is the postcondition of
executing a when p holds.
reach-sem h(R) = R ∪ {(A ∪ {a},{b}, q) | where

(A, a, p) is in reach-sem h(R), and
b is in next(h, a), and
q is in api -sem(b, p)}

Note that reach-sem h occurs on both sides of the deﬁni-
tion. The function is implemented by ﬁxed point iteration
over the CFG to compute a set of action, postcondition pairs.
The function app-sem computes event modalities by com-
puting reach-sem h and projecting out the action, postcon-
dition pairs that reach the exit point of the event handler.
Formally, app-sem satisﬁes the condition below.
app-sem(h, p) = {(A, q)|q ∈ Cube, and

(cid:91)

B ∪ {b},

A =

(B,b,q)∈R

where R = {(∅, a, p) | a ∈ entry(h)},
and next(h, b) = ∅}

A pair (A, q) is produced by app-sem(h, p) exactly if A
is a set of APIs reachable in h, and executing h in a state
satisfying p leads to the postcondition q at the exit point of
h. We now describe how the precondition p is generated.
Fixed Point. We combine the functions above to compute a

ﬁxed point whose result is the PEG for a given application:

EventModality = {(p, A, q) | p ∈ event-sem(h),
and (A, q) ∈ app-sem(h, p),
and h ∈ Handler}

In words, we consider each event handler h in Handler,
use the event semantics engine to generate preconditions
for h to ﬁre, and then combine app-sem and api -sem to
determine the postconditions derived by ﬁring h. The im-
plementation of each function above is discussed below.

4.2

Implementation of the Engines

A contribution we make, en route to computing PEGs,
is to engineer a static analyser, an event semantics engine,
and an API semantics engine. We discuss implementation
details below.
Static Analysis. We implement a partially context-sensitive
points-to analysis serving two purposes. First, the analysis
overapproximates the targets of the method call. Overap-
proximation arises due to dynamic dispatch, where differ-
ent executions of a given method call may invoke differ-
ent methods. The second purpose is computing informa-
tion about method arguments. For example, consider a call
to Button.setOnClickListener. The ﬁrst argument to
this method is the event handler to attach as the onClick
listener. We use the points-to analysis to disambiguate ar-
guments and to overapproximate the set of event handlers
the application will attach. Resolving arguments is nec-
essary to derive sufﬁcient information for veriﬁcation, be-
cause an API call can map to different permissions depend-
ing on the values of its arguments. For example, a call to
the ContentResolver.query(URI) method will access
the phone’s contacts if the URI points to the contacts con-
tent provider, while the same API will access the phone’s
SMS messages for a different URI. The two operations re-
quire different permissions.

We augment the context-insensitive analysis for event
handlers by propagating the points-to information for
method call parameters from the caller to the callee. This
provides partial context-sensitivity. In particular, it allows
the analysis of sub-functions to reason about values which
are computed in parent functions. Our experience shows
that this is important to handle, since many applications
pass arguments for system APIs through helper functions or
wrappers for those APIs. For ﬂow-sensitivity, we use ﬂow-
insensitive analysis for class ﬁelds and ﬂow-sensitive anal-
ysis for local variables to balance efﬁciency and precision.
Our hybrid approach to points-to analysis is similar to the
use of object representatives or instance keys [5, 21, 30].
Event Semantics Engine. The event semantics engine im-
plements the event-sem function. It receives a method han-

Class name

android .app. Activity

android .app.Dialog
android .app. ListActivity
android .app. Service
android . content . BroadcastReceiver
android . content . ContentProvider
android . content .ServiceConnection
android .os.AsyncTask
android .os.Handler
android . preference . PreferenceActivity
android . preference . Preference .OnPreferenceChangeListener
android . preference . Preference . OnPreferenceClickListener
android . telephony . PhoneStateListener
android .view.View.OnClickListener
android .view.View.OnTouchListener
android .webkit.WebChromeClient
android .webkit.WebViewClient
android .widget.AdapterView.OnItemClickListener
android .widget.AdapterView.OnItemLongClickListener
java . lang .Runnable
java . lang .Thread

Methods

onCreateOptionsMenu, onKeyDown, onOptionsItemSelected, onPrepareOptionsMenu,
<init>, onActivityResult , onConﬁgurationChanged, onCreate, onCreateContextMenu, onDestroy,
onPause, onRestart, onResume, onSaveInstanceState, onStart, onStop, onWindowFocusChanged
<init>, onCreate
<init>, onCreate
onBind, <init>, onCreate, onDestroy, onLowMemory, onStart, onStartCommand
<init>, onReceive
query, insert , onCreate, delete , update, getType, <init>
onServiceConnected, onServiceDisconnected
doInBackground, onPostExecute, onPreExecute
handleMessage
onPreferenceTreeClick, <init>, onCreate, onDestroy, onStop
onPreferenceChange
onPreferenceClick
onCallStateChanged
onClick
onTouch
onProgressChanged
shouldOverrideUrlLoading, onPageFinished, onPageStarted, onReceivedError
onItemClick
onItemLongClick
run, run
run

Table 1. Event handling APIs supported by the event semantics engine.

dler name as input and returns the preconditions for the han-
dler to execute. This engine models the semantics of events
by capturing the context in which an event may ﬁre. We
implemented the engine by examining the effect of event
handling mechanism as speciﬁed in the Android documen-
tation and in the Android platform code. A list of 63 event
handlers we model is given in Table 1.
API semantics engine. The api -sem receives as input a
method call and a precondition, and generates as output the
event-modalities generated by executing the method when
that precondition is satisﬁed, and the postcondition in which
the method terminates. Though these event-modalities are
determined by the implementation of Android APIs, we do
not analyse the Android API source code. Instead, we model
every API call we have found necessary to support during
analysis. Figure 5 summarises the API coverage of the API
semantics engine. We support 1200 API calls, which covers
over 90% of the call-sites we found on a data set of over
95, 000 applications. The entire list of methods we support
is too long to recall here.

5 Pegasus

We design and implement Pegasus, an analysis system
that combines the abstraction procedure in Section 4 with

analysis of PEGs and rewriting of Android applications.
System Overview. Figure 6 presents an overview of the
Pegasus architecture. Pegasus takes as input an Android
application and a speciﬁcation expressed as safety property
over events and actions. It uses a translation tool to convert
Dalvik bytecode to Java bytecode. Using Java bytecode al-
lows us to use off-the-shelf analysis frameworks.

The abstraction engine takes as input Java bytecode and
generates an PEG as output. The PEG is fed to the veri-
ﬁcation tool, along with a speciﬁcation to check for con-
formance. If certain application behaviour cannot be anal-
ysed (for instance, due to unresolved reﬂection), the rewrit-
ing tool generates a new application that contains dynamic
checks when reﬂective calls are made.

If the PEG satisﬁes the speciﬁcation, and the implemen-
tation of the API and event semantics engines, and the ver-
iﬁcation procedure is sound, the application is guaranteed
to satisfy the speciﬁcation as well. If the PEG does not sat-
isfy the speciﬁcation, it may be because the application vi-
olates the speciﬁcation, or because the overapproximation
creates false positives. For each violation, Pegasus produces
a counterexample trace which can be used to determine if
the violation corresponds to a feasible execution.
Speciﬁcations. Recall that safety properties assert that cer-
tain undesirable behaviours never occur. Researchers have

Input

Speciﬁcation

in Java

System

Veriﬁcation

Tool

Output

Event

Sequence

Application
dex bytecode

Translation

Tool

Abstraction

Engine

PEG

Java

Bytecode

Rewriting

Tool

Rewritten
Application

Figure 6. Pegasus architecture. The system consists of a translation and a veriﬁcation tool, and an abstraction engine.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Figure 5. Coverage of API calls in the API seman-
tics engine. API calls are represented by numbers on
the x-axis. A vertical blue line represents the num-
ber of applications in which an API call occurs. The
red line represents the cumulative distribution of API
calls across call-sites. 1062 APIs make up for 90% of
the calls in 95910 applications, and are part of those
supported by our API semantics engine.

public class RunningExample implements SpeciﬁcationChecker {

// is the application currently recording?
private boolean isRecording = false;
// is the application allowed to record? (i.e., did the user
// press the Record button and not yet press the Stop button?)
private boolean recordingAllowed = false;
public boolean checkEvent(EventModality event) {

if (event.getEventHandler() ==

getClickHandlerForButtonByLabel(‘‘REC’’))

recordingAllowed = true;

else if (event.getEventHandler() ==

getClickHandlerForButtonByLabel(‘‘STOP’’))

recordingAllowed = false;

for (Action action : event.getActions()) {

if (action == RECORD START)

isRecording = true;

else if (action == RECORD STOP)

isRecording = false;

}

boolean violation = (isRecording && !recordingAllowed);
return violation;

}

}

Figure 7. Speciﬁcation for the running example.

developed a numerous languages for safety properties. The
SLAM project used a C-like speciﬁcation language called
SLIC [3], because it was convenient to use speciﬁcation lan-
guage with similar syntax to the analysed programs. Simi-
larly, we write speciﬁcation monitors in Java.

A speciﬁcation for the running example is shown in Fig-
ure 7. The callback function checkEvent is used to deter-
mine if the current event modality corresponds to the but-
ton click handler for REC. If the current event modality
corresponds to the REC button click event, the speciﬁca-
tion checker sets class ﬁeld recButtonClicked to true.

It then scans all the behaviours associated with the current
event modality. If it ﬁnds the RecordStart behaviour and
the record button has not been previously clicked, it signals
a violation by returning true.

A user of our system implements speciﬁcations using
the SpecificationChecker interface, which deﬁnes the
callback function checkEvent. The veriﬁcation algo-
rithm calls this function for each event modality reached
during exploration. Depending on the speciﬁcation, the
checkEvent function inspects the event type, the actions
associated with the event, or both. The checkEvent returns

true if a violation has occurred based on the current event
modality, and false otherwise. The speciﬁcation checker
can maintain a speciﬁcation state in its class ﬁelds. The
speciﬁcation state is stored and restored by the veriﬁcation
tool using Java serialization.

To ease the task of writing speciﬁcations, we also im-
plement a mapping from low-level API calls to high-level
actions, such as maps from API calls to permissions [1, 18],
and other security relevant actions, such as the start and the
stop of recording. Pegasus enumerates the application’s se-
quences of actions.
It uses a Java interface to pass these
sequences to the Java speciﬁcation, which updates the state
of the speciﬁcation until a violation state is reached. If no
sequence in a PEG leads to a violation, the application satis-
ﬁes the speciﬁcation.
Veriﬁcation. Pegasus includes a veriﬁcation algorithm that
uses a bounded, breadth-ﬁrst graph search with pruning, to
check security properties written as Java checkers. Once the
PEG has been generated, speciﬁcations can also be checked
using other model checkers.
Rewriting. Our analysis is designed to successfully analyse
many common-case uses of potentially problematic Java
constructs such as reﬂection and dynamic invoke dispatch-
ing. The semantics of these constructs depends on infor-
mation that is available only when the program executes, so
static analyses may be unable to precisely analyse programs
that use them. We rewriting applications to include runtime
checks to account for cases where static analysis does not
succeed.

When the abstraction engine fails to analyse part of an
application, three strategies can be applied. The ﬁrst one
is to introduce a havoc statement and assume anything can
happen. This strategy usually leads to a high false positive
rate, and consequently, a tool that is not usable in practice.
The second strategy is to add runtime checks to only
allow executions that respect the conditions computed by
static analysis. For example, we can add runtime checks
only allow a reﬂective call if the target call was already de-
rived by static analysis. Static analysis may also fail to de-
termine all the sensitive resources an application accesses.
We can similarly add runtime checks to only permit ac-
cesses to URIs that were either statically determined, or are
not considered sensitive, such as contact lists or SMSes.

We use the second strategy. In speciﬁc cases, where we
have manually scrutinised an application, we permit exe-
cutions even if they have not been analysed statically. This
occurs when we believe the behaviour that was not statically
analysed is benign. Such manually aided rewriting allows
us to reduce the overhead of runtime checks.

In Section 6 we evaluate the number of unresolved tran-
sitions in the applications we analysed. The number is gen-
erally small, a fact we attribute to the simple coding patterns
used by most applications (e.g., using a constant string as

the argument to a reﬂection call), as well as our per-event
context-sensitive analysis which allows us to propagate in-
formation through method calls within each event handler.
We do not support unknown native code. Known native
code is modelled by the API semantics engine. Known dy-
namic class loading is supported by analysing the class and
treating its loading point as a reﬂective call.
Implementation. Pegasus is implemented in 11,626 lines
of Java code, including the code for the abstraction, model
generation, and veriﬁcation phases. The API semantics en-
gine models 1218 APIs and the event semantics engine sup-
ports 62 different types of events. We developed a transla-
tion framework to translate Dalvik bytecode to Java byte-
code; the dataﬂow analysis and rewriting are implemented
in Soot [31], a compiler and static analysis framework for
Java bytecode.

6 Evaluation

This section describes our experiments using Pegasus to
demonstrate that PEGs can be used to automatically check
and enforce policies in Android applications. All experi-
ments are performed on an Intel Core i7 CPU machine with
4GB physical memory.

6.1 Generic Speciﬁcation Checking

We run Pegasus on 152 malicious and 117 benign An-
droid applications, and measure the execution and the size
of the PEG. Figure 8 presents the Cumulative Distribution
Function (CDF) of the time spent on PEG generation. On
over 80% of the applications, the abstraction phase termi-
nates within 600 seconds. The abstraction phase also al-
ways terminated within 2 hours. Figure 9 presents the CDF
of PEG veriﬁcation time, on a logarithmic scale. The ver-
iﬁcation phase terminates within 1000 seconds, for over
80% of the inputs, and the veriﬁcation phase always termi-
nates within 3.6 hours. To boost efﬁciency, we heuristically
bounded veriﬁcation to terminate after 50000 states were
explored. The justiﬁcation behind this heuristic is shown
in Figure 10, where most of the applications have at most
10000 unique states, so the probability of an unsound result
is low.

In the veriﬁcation phase, we check 6 application-
independent properties to determine if sensitive operations
are guarded by user interaction. The three sensitive oper-
ations we consider are reading the GPS location, accessing
the SD card, and sending SMSes. The properties we check
are that the three behaviours above are always bracketed by
user interaction, such as a button click. The result of veriﬁ-
cation is shown in Table 2. We see that malicious applica-
tions performing sensitive operations without user consent
more frequently than benign applications.

Figure 8. CDF of abstraction time.

Figure 10. CDF of PEG size measured by the number
of states.

Sensitive
Operation NoUI

Malicious

GPS
SD card
SMS

15
25
10

Benign

Total NoUI
15
26
11

18
25
0

Total
30
32
1

Figure 9. CDF of the veriﬁcation time.

6.2 Application-Speciﬁc Properties

In this

Sample Applications.
section, we check
application-speciﬁc properties on 17 sample applications,
including 8 benign applications and 9 applications with
known malicious behaviours, to demonstrate Pegasus used
as a diagnostic tool. Table 4 in Appendix A lists these sam-
ple applications and presents a short description for each
application. The ﬁrst 8 applications are benign samples se-
lected from the ofﬁcial Android Market and third-party ap-
plication stores. We selected these applications to represent
a broad variety of different application classes that together
exercise most of the core functionality supported in the An-
droid system. These applications implement a variety of
behaviours such as recording audio, accessing the phone’s
contacts, sending SMS messages, and accessing the device
GPS location. The remaining 9 samples are malware which
exhibit a variety of malicious behaviours.
Speciﬁcations.
For these applications, we constructed
application-speciﬁc properties after installing each applica-
tion, reading its documentation to understand its intended

checking

2. Results

Table
application-
of
The ﬁrst column is
independent speciﬁcations.
the name of the sensitive resource accessed. The
“NoUI” columns list
the number of applications
accessing these resources without user consent.

functionality, looking at the list of events and GUI widgets
used by the application, then determining a security policy
which an analyst might reasonably wish to impose on the
application. We wrote 23 application-speciﬁc properties.
PEG Generation. Table 3 summarises the results of PEG
generation. The last two columns of Table 3, show how
often the analysis can resolve the targets of intent calls and
reﬂective calls. We also manually inspected the decompiled
source code to resolve values that were not automatically
determined, then used the rewriting tool to enforce those
values at runtime.
Veriﬁcation. We used Pegasus to check the generated PEGs
for conformance to their properties. When Pegasus found a
violation, we manually executed the applications and used
the counterexample trace to determine if the violation rep-
resented a feasible behaviour of the application. If source
code was available, we also inspected the code.

Our results show that Pegasus completes veriﬁcation of
most applications in less than a second, with a maximum
veriﬁcation time of 10 seconds. The length of the coun-
terexample traces for violations ranges from 4 to 10 events.

Name

Who’s Calling?
Share Contacts
Geotag
Find My Phone
Simple Recorder
Diet SD Card
SMS Cleaner Free
SyncMyPix

SMS Replicator
ADSms
ZitMo
HippoSMS
DroidDream
Zsone
Geinimi
Spitmo
Malicious Recorder

Size
KB

148
135
117
285
20
304
159
425

63
41
20
404
204
241
558
20
20

EM
#

83
359
226
29
16
155
175
300

18
38
19
434
89
30
51
6
25

Intents
T
UR

Reﬂection
T
UR

0
0
0
0
0
0
0
4

0
0
0
0
12
0
4
0
0

2
9
19
2
0
14
14
12

0
0
0
38
15
0
4
0
0

0
1
1
6
0
2
0
1

0
0
0
0
0
1
4
0
0

0
2
2
11
0
5
3
3

0
0
0
0
0
3
6
0
0

Table 3. Summary of the evaluation results. The
columns are: (1) name of application, (2) size of the
.apk ﬁle, (3) number of event-modalities, (4) number
of (unresolved) intents, (5) number of (unresolved)
reﬂection calls.

The properties we checked are discussed in detail in Sec-
tion 6.3. We checked 8 benign applications, against a total
of 16 properties. For 11 of these properties, Pegasus de-
termined that the application satisﬁed the property. For 3 of
the remaining properties, we determined that Pegasus found
a property violation due to legitimate but unexpected appli-
cation behaviour. We believe that analysts would ﬁnd such
information valuable.

For 1 of the remaining 2 properties, Pegasus determined
that an infeasible path involving dead code violated the
property. For the last property, imprecision in the analysis
caused Pegasus to determine that the application violated
the property. Consequently, we conclude that Pegasus has
false positives for 2 of the 16 properties.

For all 9 malicious applications, Pegasus correctly re-
ported violations of at least one of the 7 properties. In other
words, there were no false negatives for these properties.

6.3 Case Studies

We now present case studies illustrating properties one
can check with Pegasus. Table 5 in Appendix A provides
detailed information about the security actions and events
used in the speciﬁcations in this section.

Speciﬁcation Format. For brevity, we present speciﬁca-
tions as LTL formulae. Note that Pegasus does not actually
take LTL formulae as input but requires speciﬁcations to be
encoded as a Java checker. A speciﬁcation for the Find My
Phone application is shown below.

¬Send-SMS U Receive-SMS

The symbol U is the until operator, while Send-SMS is an
action and Receive-SMS is an event. The speciﬁcation is
read in English as asserting that

The application does not send an SMS until it re-
ceives an SMS.

A important technical clariﬁcation is in order: the tempo-
ral logics supported by standard model checkers are usually
state-based, meaning the propositions occurring in formu-
lae describe properties of states. In our speciﬁcation, mode-
variables describe states and action labels describe proper-
ties of transitions. In technical temporal logic parlance, our
speciﬁcations are both state and event-based. Consult [9]
for an in-depth discussion of such issues.

6.3.1 Benign Applications

Simple Recorder. The simple recorder contains two but-
tons to start and stop recording, and behaves as expected.
We check that the application only records audio when the
REC is clicked, and stops when STOP is clicked. This prop-
erty is expressed in LTL as

(¬Start-Recording U REC.onClick)

∧ (Stop-Recording ⇐⇒ STOP.onClick)

The application satisﬁes this property.
Diet SD Card. We check that the application accesses the
SD card only after a button labelled Clean is clicked.

¬Access-SD U Clean.onClick

The application satisﬁes this property, showing that the SD
card is only accessed after Clean is clicked.
Geotag. We check that the application accesses geolocation
information only after the user clicks the Locate button.

¬Access-GPS U Locate.onClick

Pegasus discovers a property violation. On examining the
counterexample, we determined that the main activity’s
onCreate event handler initialises the Google Ads library,
which spawns a new background task and accesses the ge-
olocation information. If we reﬁne our property to

¬Access-GPS U

Locate.onClick

∨ AdTask.onPreExecute

(cid:18)

(cid:19)

Pegasus no longer reports a violation. We have also learnt
that the only way the geolocation can be accessed without
the user’s consent is via the Google Ads library.
Who’s Calling?. Similar to the Geotag application, we
check the that contacts information is only accessed after
a phone call is received.

¬Access-Contacts U PhoneCall.onReceive

Pegasus returns a counterexample which shows that the ap-
plication retrieves and caches the contact list when it starts
up. We veriﬁed this behaviour manually by running the ap-
plication in an emulator and observing its API calls.
Share Contacts. We check whether the application ac-
cesses contacts if an SMS is not sent.

¬Send-SMS U Access-Contacts

This property holds. We then checked that SMSes are sent
in response to user input.

¬Send-SMS U Send.onClick

This property also holds. Finally, we check if adding a new
contact requires user consent.

¬Insert-Contacts U Insert.onClick

This property too is satisﬁed.
SMS Cleaner Free. This application allows users to delete
SMS messages that match a user-provided contact name. We
check if accessing contacts is user-driven.

¬Access-Contacts U Select-Contact.onClick

Pegasus reports a property violation. We manually investi-
gated the counterexample generated and concluded that the
counterexample was not feasible. The reported violation is
a false positive. This application uses a switch statement to
register the same event handler for different button clicks.
Our abstraction engine does not consider branch conditions,
so in the generated PEG every button click can trigger every
event handler.
Find My Phone. This application responds to the receipt
of an SMS containing a speciﬁc keyword by sending the
phone’s GPS location. We check if an SMS can be sent with-
out any being received.

¬Send-SMS U Receive-SMS

Pegasus reports a violation. We manually veriﬁed that the
violation was a false positive.
SyncMyPix.The SyncMyPix application speciﬁes the tar-
get of an intent by looking at the conﬁguration ﬁle and

using a default value if the user does not specify the tar-
get. The set of possible runtime targets is not arbitrary, be-
cause they must be components in the application, but static
analysis does not have this information and is inconclusive.
We rewrite the application to force the target of the intent
to be the default one. The rewriting takes 5 seconds and
the rewritten application works correctly. We check if the
rewritten application can access contacts without the Sync
being clicked.

¬Access-Contacts U Sync.onClick

Pegasus reports a property violation. The counterexample
revealed that the application may access the contacts if the
user clicks the Result button. We veriﬁed manually that
clicking Result displays the results of synchronising pic-
tures. This behaviour is innocuous, so we reﬁned the prop-
erty as below.

(cid:18)

(cid:19)

¬Access-Contacts U

Result.onClick
∨ Sync.onClick

The application satisﬁes the reﬁned property.

6.3.2 Malicious Applications

Malicious Recorder. This application contains the same
functionality as the benign recording application. However,
it also records audio for 15 seconds whenever a new SMS is
received. We check the same speciﬁcations as the Simple
Recorder application and veriﬁcation fails. The counterex-
ample shows that that a timer can trigger recording.
ZitMo. In most benign applications, the SMS messages re-
ceived should either be passed on to the next Broadcast Re-
ceiver or displayed to the user. Thus we check

¬BroadcastAbort

to see whether the ZitMo application discards SMSes with-
out notifying the user. Pegasus reports a violation, which
we conﬁrmed manually.
SMS Replicator Secret. We checked two properties of this
application.

¬Send-SMS U Button.onClick
¬BroadcastAbort

Both properties are violated, because the application mali-
cious sample sends SMS messages without user interaction,
and deletes certain incoming SMS messages.
ADSms. We use Pegasus to study this application and un-
derstand how it uses permissions. We check three proper-

ties.

¬Kill-Background-Processes
¬Read-IMEI
¬Send-SMS

The counterexamples show that this application registers
a broadcast receiver to kill anti-virus processes. We also
discovered that the broadcast receiver starts a new process,
which reads IMEI information and sends SMS messages to
premium-rate numbers.

7 Related Work and Discussion

We build upon work at the intersection of speciﬁcation
languages, program analysis, model checking, and Android
security. These areas are all mature and a comprehensive
survey is beyond the scope of this paper. We only attempt
to place our work in the context of either seminal or very
recent papers in each area.
Speciﬁcation Languages. A speciﬁcation language may
be external to a program, as with a temporal logic or in-
ternal to a program as in design-by-contract mechanisms.
See [32] for a hardware-oriented survey of industrial for-
mats for temporal logics, and [6] for an overview of JML
and ESC/Java2, which is well known, but only one of many
speciﬁcation mechanisms for Java.

Our use of rewriting achieves a form of in-line mon-
itoring, an idea articulated in [17]. Monitoring for se-
curity policies has been implemented in EFSA [29] and
PSLang [16], and with a focus on mobile security.
in the
S3MS project [10], The Apex [27] system uses Android per-
missions to guide runtime monitoring, while our monitoring
policies are deﬁned by custom security properties.

We use runtime monitoring to deal with cases in which
static analysis is ineffective, such as in the presence of dy-
namic class loading or running native code. This combi-
nation can also be viewed as an optimisation that reduces
the overhead of runtime checks, and leverages the strengths
of both.
JAM, developed concurrent to our work, com-
bines model checking with abstraction-reﬁnement to alle-
viate monitoring overheads [22]. Techniques from JAM can
be used to improve our rewriting tool.
Static Analysis. The design of our abstraction engine com-
bines ideas from abstract interpretation [7] and software
model checking. The closest related work is the SLAM
toolkit [2], for checking properties of device drivers. Sim-
ilar to SLAM, we check policies about the interaction of
an application and the operating system, and use cubes
over Boolean variables for symbolically encoding . Unlike
SLAM, we abstract the operating system context of an event.
Moreover, instead of a theorem prover, we use a domain

speciﬁc event- and API-semantics engines to determine how
mode variables are transformed.

The ideas in SLAM has been extended to lazy abstrac-
tion [24], which interleaves the abstraction and checking
process, and to YOGI [4], which combines testing and the-
orem proving to construct abstractions. Most developments
that follow SLAM, such as those surveyed in [26] focus on
improving either model checking or abstraction. Our work
is orthogonal because we compute a different type of ab-
straction. Much work successive to SLAM, can be lifted to
Android and used to improve the construction or veriﬁca-
tion of PEGs.

Though program analysis is a mature ﬁeld, event driven
programs have only recently received attention. Interpro-
cedural data-ﬂow analysis with a ﬁnite-height, powerset
lattice is EXPSPACE-hard [25].
In a language like Java,
all analysis depends on the quality of points-to analysis.
Points-to-analysis in the presence of an event-queue faces
similar complications as with function pointers [11]. These
are obstacles that will have to overcome if we wish to im-
prove our analysis.
Android Security. TaintDroid [13] supports dynamic taint-
tracking for Android applications. It explores one execution
at a time, while our system checks all the possible behaviors
of an application. Security analysis based on control-ﬂow
patterns and simple static analysis has been used in [14] to
detect a range of malicious behaviour. A semantically richer
static analysis has been applied to Android in [28], but the
focus is on common bugs rather than security properties.

The Stowaway system [18] combines static analysis with
a permission map to identify applications requesting more
permissions than they use. Permission-based approaches [1,
15, 27] use a map from API calls to Android permissions.
Pegasus uses use a map from API calls and arguments to a
custom-deﬁned set of actions. This set of actions extends
the abstraction of APIs provided by permissions.
Discussion. Analysis of PEGs provides richer semantic in-
formation than is available in standard program representa-
tions. PEGs abstract the operating system context in which
event handlers execute, and model checking of PEGs pro-
vides more information than pattern matching on syntactic
program artefacts. We can detect permissions used in back-
ground tasks, or in event-handlers triggered by invisible but-
tons. We are not aware of other techniques that can detect
such behaviour.

Analysis of PEGs is not a panacea for malware detec-
tion. However, our analysis gives security analysts an ad-
vantage in their arms race against new malware, by aiding
in identifying a new class of malicious behaviour. While
attackers can work to evade our analysis mechanisms, e.g.,
using native code or dynamic class loading, such evasion
requires code to adopt a more convoluted structure or ex-
hibit more circuitous behavior, compared to benign applica-

tions — thereby making the code more conspicuous. Thus,
much as the ZOZZLE defense against heap spraying attacks
in Javascript [8], our analysis can support and facilitate the
identiﬁcation of malware. Even simple pattern matching of
syntactic structure, or triggered runtime checks, may be suf-
ﬁcient to reveal anomalies that indicate malicious intent.

8 Conclusion

We have presented a new approach to specifying and de-
tecting malicious behaviour in Android applications. Our
conceptual contribution is the Permission Event Graph
(PEG) a new, domain-speciﬁc program abstraction, which
captures the context in which events ﬁre, and the context-
sensitive effect of event-handlers. We devised a new static
analysis procedure for constructing PEGs from Dalvik byte-
code, and our implementation models of the Android event-
handling mechanism and several APIs. Our system Pegasus
can detect and prevent security speciﬁcations that charac-
terises safe interaction between user-driven events and ap-
plication actions. Given the rapidly increasing popularity
and sophisticated functionality of mobile applications, we
believe that analysis systems such as Pegasus will improve
the capabilities of security analysts.

Our work leads to several questions. One question is
to incorporate existing techniques to improve the precision
and efﬁciency of analyses used to construct and analyse
PEGs. A particularly interesting question is to determine
if counterexample-driven reﬁnement can be used to im-
prove both veriﬁcation and rewriting. A second problem
is to identify applications PEGs in other contexts, such as
to measure the complexity and usability of user-interfaces,
and statically provided permission information. Answering
such questions is left as future work.

9 Acknowledgements

We are deeply indebted to ´Ulfar Erlingsson for his as-
sistance, feedback and encouraging support. We thank the
anonymous reviewers for their comments.

This material is based upon work partially supported
by the National Science Foundation under Grants No.
0842695, No. 0831501 and the Air Force Ofﬁce of Sci-
entiﬁc Research (AFOSR) under MURI award FA9550-09-
1-0539. Any opinions,ﬁndings, and conclusions or recom-
mendations expressed in this material are those of the au-
thors and do not necessarily reﬂect the views of the funding
agencies.

References

[1] K. Au, Y. Zhou, Z. Huang, and D. Lie. PScout: Analyz-
In Proc. of the

ing the Android permission speciﬁcation.

ACM Conference on Computer and Communications Secu-
rity, pages 217–228. ACM, 2012.

[2] T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani. Au-
tomatic predicate abstraction of C programs. In Proc. of the
Symposium on Programming Language Design and Imple-
mentation, pages 203–213. ACM, 2001.

[3] T. Ball and S. K. Rajamani. SLIC: A Speciﬁcation Language
for Interface Checking (of C). Technical Report MSR-TR-
2001-21, Microsoft Resesarch, 2001.

[4] N. E. Beckman, A. V. Nori, S. K. Rajamani, and R. J. Sim-
In Proc. of the International
mons. Proofs from tests.
Symposium on Software Testing and Analysis, pages 3–14.
ACM, 2008.

[5] E. Bodden, P. Lam, and L. Hendren. Object representa-
tives: a uniform abstraction for pointer information. In Proc.
of the 1st International Academic Research Conference of
the British Computer Society (Visions of Computer Science),
pages 391–405, 2008.

[6] P. Chalin, J. R. Kiniry, G. T. Leavens, and E. Poll. Be-
yond assertions: Advanced speciﬁcation and veriﬁcation
with JML and ESC/Java2. In Proc. of the International Sym-
posium on Formal Methods for Components and Objects,
pages 342–363. Springer, 2005.

[7] P. Cousot and R. Cousot. Abstract interpretation frame-
Journal of Logic and Computation, 2:511–547,

works.
1992.

[8] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert. ZOZ-
ZLE: fast and precise in-browser JavaScript malware detec-
tion. In Proc. of the USENIX conference on Security, pages
3–3. USENIX Association, 2011.

[9] R. De Nicola and F. Vaandrager. Action versus state based
In Proc. of the LITP Spring
logics for transition systems.
school on theoretical computer science on Semantics of
systems of concurrent processes, pages 407–419. Springer,
1990.

[10] L. Desmet, W. Joosen, F. Massacci, K. Naliuka, P. Philip-
paerts, F. Piessens, and D. Vanoverberghe. The S3MS.NET
run time monitor. Electronic Notes in Theoretical Computer
Science, 253(5):153–159, 2009.

[11] M. Emami, R. Ghiya, and L. J. Hendren. Context-sensitive
interprocedural points-to analysis in the presence of func-
tion pointers. In Proc. of the Symposium on Programming
language design and implementation, PLDI ’94, pages 242–
256. ACM, 1994.

[12] W. Enck. Defending users against smartphone apps: Tech-
niques and future directions. In International Conference on
Information Systems Security, pages 49–70. Springer, 2011.
[13] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. Mc-
Daniel, and A. N. Sheth. Taintdroid: an information-ﬂow
tracking system for realtime privacy monitoring on smart-
phones. In Proc. of the USENIX Conference on Operating
Systems Design and Implementation, pages 1–6. USENIX,
2010.

[14] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A
In Proc. of the
study of Android application security.
USENIX conference on Security, pages 21–21. USENIX As-
sociation, 2011.

[15] W. Enck, M. Ongtang, and P. McDaniel. On lightweight
In Proc. of the

mobile phone application certiﬁcation.

[31] R. Vall´ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and
V. Sundaresan. Soot - a Java bytecode optimization frame-
work. In Proc. of the Conference of the Centre for Advanced
Studies on Collaborative research, CASCON ’99, pages 13–
. IBM Press, 1999.

[32] M. Y. Vardi. From philosophical to industrial logics.

In
Proc. of the Indian Conference on Logic and Its Applica-
tions, pages 89–115. Springer, 2009.

A Application, Action and Event Details

Table 4 lists the sample applications used to evaluate
Pegasus. Table 5 lists the security actions and events used
in the speciﬁcations.

[16]

[17]

ACM conference on Computer and communications secu-
rity, pages 235–245. ACM, 2009.
´U. Erlingsson. The inlined reference monitor approach to
security policy enforcement. PhD thesis, Cornell University,
2004.
´U. Erlingsson and F. B. Schneider. SASI enforcement of
security policies: a retrospective. In Proc. of the Workshop
on New security paradigms, pages 87–95. ACM, 2000.

[18] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner. An-
In Proc. of the Conferenc.
droid permissions demystiﬁed.
on Computer and Communication Security, pages 627–638.
ACM, 2011.

[19] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and D. Wagner. A
survey of mobile malware in the wild. In Proc. of the work-
shop on Security and privacy in smartphones and mobile
devices, SPSM ’11, pages 3–14. ACM, 2011.

[20] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin.
Permission re-delegation: attacks and defenses. In Proc. of
the USENIX Security Conference. USENIX Association,
2011.

[21] S. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay.
Effective typestate veriﬁcation in the presence of aliasing.
ACM Transactions on Software Engineering and Methodol-
ogy (TOSEM), 17(2):9, 2008.

[22] M. Fredrikson, R. Joiner, S. Jha, T. Reps, P. Porras, H. Sa¨ıdi,
and V. Yegneswaran. Efﬁcient runtime policy enforcement
using counterexample-guided abstraction reﬁnement.
In
Proc. of the Conference on Computer Aided Veriﬁcation,
pages 548–563. Springer, 2012.

[23] M. C. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.
RiskRanker: scalable and accurate zero-day Android mal-
In Proc. of Mobile Systems, Applications,
ware detection.
and Services, pages 281–294. ACM, 2012.

[24] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy
abstraction. In Proc. of the Symposium on Principles of Pro-
gramming Languages, POPL, pages 58–70. ACM, 2002.

[25] R. Jhala and R. Majumdar. Interprocedural analysis of asyn-
In Symposium on Principles of Pro-
chronous programs.
gramming Languages, volume 42 of POPL, pages 339–350.
ACM, Jan. 2007.

[26] R. Jhala and R. Majumdar. Software model checking. ACM

Computing Surveys, 41(4):21:1–21:54, Oct. 2009.

[27] M. Nauman, S. Khan, and X. Zhang. Apex: extending An-
droid permission model and enforcement with user-deﬁned
runtime constraints. In Proc. of the Symposium on Informa-
tion, Computer and Communications Security, pages 328–
332. ACM, 2010.
´E. Payet and F. Spoto. Static analysis of Android programs.
In Proc. of the Conference on Automated Deduction, pages
439–445. Springer, 2011.

[28]

[29] R. Sekar, V. Venkatakrishnan, S. Basu, S. Bhatkar, and
D. DuVarney. Model-carrying code: a practical approach
for safe execution of untrusted applications. ACM SIGOPS
Operating Systems Review, 37(5):15–28, 2003.

[30] S. Shoham, E. Yahav, S. Fink, and M. Pistoia.

Static
speciﬁcation mining using automata-based abstractions.
IEEE Transactions on Software Engineering, 34(5):651–
666, 2008.

Name
Who’s Calling?
Share Contacts
Geotag
Find My Phone
Simple Recorder
Diet SD Card
SMS Cleaner Free
SyncMyPix

SMS Replicator
Secret
ADSms

ZitMo

HippoSMS
DroidDream
(Steamy Window)
Zsone (iMatch)
Geinimi (Monkey
Jump 2)
Spitmo
Malicious
Recorder

Description
An application that uses text-to-speech to announce the caller ID of an incoming call.
An application that allows users to send and receive contacts via SMS.
An application that embeds the users current GPS location into uploaded pictures.
Responds with the GPS location of the device upon receiving a message containing a speciﬁc keyword.
An application that recording audio from the microphone.
An application that recommends ﬁles to delete from the SD card.
An application that allows the user to delete SMS messages based on a variety of features.
An application that syncs pictures from Facebook friends to the contact list in the phone.

Spyware that automatically forwards SMS messages to a number selected by the user installing the application.

A malicious application that stealthily sends premium SMS messages and kills certain background processes.
A malicious application that intercepts SMS messages in order to harvest two-factor authentication codes issued
by banks.
A malicious application that stealthily deletes all incoming SMS messages.
A trojan packaged with a benign application that stealthily sends SMS messages, installs new applications and
receives commands from a C&C server.
A malicious application that sends SMS messages to premium numbers.
A trojan packaged with a benign application that stealthily sends SMS messages, installs new applications and
receives commands from a C&C server.
A trojan that intercepts and ﬁlters incoming SMS messages.

Mimics a benign sound recorder but also records audio when an SMS message is received.

Table 4. Sample applications used in the evaluation: 8 benign applications (top) and 9 malicious applications (bottom).

Description
Access the contacts list.
Insert to the contacts list.
Send SMS.
Access GPS location information.
Start recording audio.
Stop recording audio.
Abort an ordered broadcast (used by many malicious applications to prevent SMS messages from
being displayed to the user).
Access the SD card.

Name
Access-Contacts
Insert-Contacts
Send-SMS
Access-GPS
Start-Recording
Stop-Recording
BroadcastAbort
Access-SD
Kill-Background-Processes Kill background processes.
Read-IMEI
Access-Internet
REC.onClick
STOP.onClick
Clean.onClick
Locate.onClick
Send.onClick
Insert.onClick
Select-Contact.onClick
Button.onClick
AdTask.onPreExecute
AdTask.doInBackground
PhoneCall.onReceive

Read IMEI information.
Access the Internet.
The REC button’s onClick handler.
The STOP button’s onClick handler.
The Clean button’s onClick handler in Diet SD Card.
The Locate button’s onClick handler in Geotag.
The Send button’s onClick handler in Share Contacts.
The Insert button’s onClick handler in Share Contacts.
The Select-Contact button’s onClick handler in SMS Cleaner Free.
The general onClick handler for any button.
The onPreExecute handler from a ASyncTask created by Google Ads library in Geotag.
The doInBackground handler from a ASyncTask created by Google Ads library in Geotag.
The onReceive event from a broadcast receiver in the Who’s Calling? application.

Table 5. Security actions and events used in speciﬁcations.

