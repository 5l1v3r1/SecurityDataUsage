Making Smart Contracts Smarter

Loi Luu

National University of Singapore

loiluu@comp.nus.edu.sg

Duc-Hiep Chu

National University of Singapore

hiepcd@comp.nus.edu.sg

Hrishi Olickel
Yale-NUS College

hrishi.olickel@yale-nus.edu.sg

Prateek Saxena

National University of Singapore
prateeks@comp.nus.edu.sg

ABSTRACT
Cryptocurrencies record transactions in a decentralized data
structure called a blockchain. Two of the most popular
cryptocurrencies, Bitcoin and Ethereum, support the fea-
ture to encode rules or scripts for processing transactions.
This feature has evolved to give practical shape to the ideas
of smart contracts, or full-ﬂedged programs that are run on
blockchains. Recently, Ethereum’s smart contract system
has seen steady adoption, supporting tens of thousands of
contracts, holding millions dollars worth of virtual coins.

In this paper, we investigate the security of running smart
contracts based on Ethereum in an open distributed network
like those of cryptocurrencies. We introduce several new se-
curity problems in which an adversary can manipulate smart
contract execution to gain proﬁt. These bugs suggest subtle
gaps in the understanding of the distributed semantics of the
underlying platform. As a reﬁnement, we propose ways to
enhance the operational semantics of Ethereum to make con-
tracts less vulnerable. For developers writing contracts for
the existing Ethereum system, we build a symbolic execution
tool called Oyente to ﬁnd potential security bugs. Among
19, 366 existing Ethereum contracts, Oyente ﬂags 8, 833 of
them as vulnerable, including the TheDAO bug which led
to a 60 million US dollar loss in June 2016. We also discuss
the severity of other attacks for several case studies which
have source code available and conﬁrm the attacks (which
target only our accounts) in the main Ethereum network.

1.

INTRODUCTION

Decentralized cryptocurrencies have gained considerable
interest and adoption since Bitcoin was introduced in 2009 [1].
At a high level, cryptocurrencies are administered publicly
by users in their network without relying on any trusted
parties. Users in a cryptocurrency network run a consen-
sus protocol to maintain and secure a shared ledger of data
(the blockchain). Blockchains were initially introduced for
peer-to-peer Bitcoin payments [1], but more recently, it has

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978309

Aquinas Hobor
Yale-NUS College&

National University of Singapore

hobor@comp.nus.edu.sg

been used more broadly [2–4]. One prominent new use for
blockchains is to enable smart contracts.

A smart contract is a program that runs on the blockchain
and has its correct execution enforced by the consensus pro-
tocol [5]. A contract can encode any set of rules represented
in its programming language—for instance, a contract can
execute transfers when certain events happen (e.g. pay-
ment of security deposits in an escrow system). Accordingly,
smart contracts can implement a wide range of applications,
including ﬁnancial instruments (e.g., sub-currencies, ﬁnan-
cial derivatives, savings wallets, wills) and self-enforcing or
autonomous governance applications (e.g., outsourced com-
putation [6], decentralized gambling [7]).

A smart contract is identiﬁed by an address (a 160-bit
identiﬁer) and its code resides on the blockchain. Users in-
voke a smart contract in present cryptocurrencies by sending
transactions to the contract address. Speciﬁcally, if a new
transaction is accepted by the blockchain and has a con-
tract address as the recipient, then all participants on the
mining network execute the contract code with the current
state of the blockchain and the transaction payloads as in-
puts. The network then agrees on the output and the next
state of the contract by participating in a consensus proto-
col. Ethereum, a more recent cryptocurrency, is a promi-
nent Turing-complete smart contract platform [2]. Unlike
Bitcoin, Ethereum supports stateful contracts in which val-
ues can persist on the blockchain to be used in multiple
invocations.
In the last six months alone, roughly 15, 000
smart contracts have been deployed in the Ethereum net-
work, suggesting a steady growth in the usage of the plat-
form (see Figure 1). As Ethereum receives more public expo-
sure and other similar projects like Rootstock [8] and Coun-
terParty [9] emerge on top of the Bitcoin blockchain, we
expect the number of smart contracts to grow.
Security problems in smart contracts. Smart contracts
can handle large numbers of virtual coins worth hundreds of
dollars apiece, easily making ﬁnancial incentives high enough
to attract adversaries. Unlike traditional distributed appli-
cation platforms, smart contract platforms such as Ethereum
operate in open (or permissionless) networks into which arbi-
trary participants can join. Thus, their execution is vulner-
able to attempted manipulation by arbitrary adversaries—
a threat that is restricted to accidental failures in tradi-
tional permissioned networks such as centralized cloud ser-
vices [10, 11]. Although users in Ethereum have to follow a
predeﬁned protocol when participating in the network, we
show that there is considerable room for manipulation of

254risk of not seeing real deployment.
If such a requirement
is unacceptable, we provide a tool called Oyente for users
to detect bugs in as a pre-deployment mitigation. Oyente
is a symbolic execution tool exclusively designed to analyze
Ethereum smart contracts. It follows the execution model
of Ethereum smart contracts [15] and directly works with
Ethereum virtual machine (EVM) byte code without ac-
cess to the high level representation (e.g., Solidity [16], Ser-
pent [17]). This design choice is vital because the Ethereum
blockchain only stores the EVM byte code of contracts, not
their source. Oyente is open source and will be available
for public use soon from our project page [18].
Evaluation. We ran Oyente on 19, 366 smart contracts
from the ﬁrst 1, 460, 000 blocks in Ethereum network and
found that 8, 833 contracts potentially have the documented
bugs. These contracts currently have a total balance of
about 3, 068, 654 million Ethers, approximately equivalent
to 30 million USD at the time of writing. Moreover, Oyente
can detect the infamous TheDAO bug, which caused a loss
of 60 million US dollars to TheDAO’s investors in June
2016 [19]. We further discuss our results and our veriﬁed
attack with one of the most active contracts of Ethereum
(aﬀecting only our own accounts), in Section 6.

Although we use Ethereum’s smart contracts throughout
this paper, Oyente and the security problems are largely
platform agnostic. We believe Oyente can be extended to
upcoming platforms such as CounterParty or Rootstock.
Contributions. This paper makes the following contribu-
tions.
• We document several new classes of security bugs in Ethereum

smart contracts.

• We formalize the semantics of Ethereum smart contracts
and propose recomendations as solutions for the docu-
mented bugs.

analyses Ethereum smart contracts to detect bugs.

• We provide Oyente, a symbolic execution tool which
• We run Oyente on real Ethereum smart contracts and

conﬁrmed the attacks in the real Ethereum network.

2. BACKGROUND

We give a brief introduction to smart contracts and their
execution model. Our discussion is restricted to most pop-
ular smart contract platform called Ethereum, but the se-
curity problems discussed in this paper may be of wider
application to other open distributed application platforms.
2.1 Consensus Protocol

Decentralized cryptocurrencies secure and maintain a shared

ledger of facts between a set of peer-to-peer network opera-
tors (or miners). Miners run a peer-to-peer consensus pro-
tocol called the Nakamoto consensus protocol. The shared
ledger is called a blockchain and is replicated by all miners.
The ledger is organized as a hash-chain of blocks ordered by
time, wherein each block has a set of facts, as shown in Fig-
ure 2. In every epoch, each miner proposes their own block
to update the blockchain. Miners can select a sequence of
new transactions to be included in the proposed block. At
a high level, Nakamoto consensus works by probabilistically
electing a leader among all the miners via a proof-of-work
puzzle [1]. The leader then broadcasts its proposed block
to all miners.
If the proposed block obeys a certain pre-

Figure 1: Number of smart contracts in Ethereum has increased
rapidly.

a smart contract’s execution by the network participants.
For example, Ethereum (and Bitcoin) allow network partic-
ipants (or miners) to decide which transactions to accept,
how to order transactions, set the block timestamp and so
on. Contracts which depend on any of these sources need to
be aware of the subtle semantics of the underlying platform
and explicitly guard against manipulation.

Unfortunately, the security of smart contracts has not
received much attention, although several anecdotal inci-
dents of smart contracts malfunctioning have recently been
reported,
including contracts that do not execute as ex-
pected [7, 12, 13] and/or that have locked away thousands of
dollars worth of virtual coins [7, 13]. In contrast to classical
distributed applications that can be patched when bugs are
detected, smart contracts are irreversible and immutable.
There is no way to patch a buggy smart contract, regardless
of its popularity or how much money it has, without revers-
ing the blockchain (a formidable task). Therefore, reasoning
about the correctness of smart contracts before deployment
is critical, as is designing a safe smart contract system.

In this paper, we document several new security ﬂaws of
Ethereum smart contracts and give examples of real-world
instances for each problem. These security ﬂaws make con-
tracts susceptible to abuse by several parties (including min-
ers and contracts’ users). We believe that these ﬂaws arise
in practice because of a semantic gap between the assump-
tions contract writers make about the underlying execution
semantics and the actual semantics of the smart contract
system. Speciﬁcally, we show how diﬀerent parties can ex-
ploit contracts which have diﬀering output states depending
on the order of transactions and input block timestamp. To
our knowledge, these semantic gaps have not been previ-
ously identiﬁed. We also document other serious but known
problems such as improperly handled aborts/exceptions and
logical ﬂaws. Previous work has discussed these conceptu-
ally, often with simple self-constructed examples [14]. In our
work, we study their impact on tens of thousands of real-life
contracts, showing how these vulnerabilities can be used to
sabotage or steal coins from benign users.

More importantly, our work emphasizes the subtle and/or
missing abstractions in smart contract semantics that lead
developers to a false sense of security. We propose reﬁne-
ments to Ethereum’s protocol that do not require changes
to existing smart contracts. However, such solutions do re-
quire all clients in the network to upgrade, thus running the

25.08.201515.09.201506.10.201525.10.201514.11.201504.12.201524.12.201513.01.201602.02.201621.02.201612.03.201629.03.201615.04.201603.05.201605000100001500020000DateNumberofsmartcontracts255f u n c t i o n Puzzle () // c o n s t r u c t o r {

f u n c t i o n (){ // main code , runs at every i n v o c a t i o n

address public owner ;
bool public locked ;
uint public reward ;
bytes32 public diff ;
bytes public s o l u t i o n ;

owner = msg . sender ;
reward = msg . value ;
locked = false ;
diff = bytes32 ( 1 1 1 1 1 ) ; // pre - defined d i f f i c u l t y

1 c o n t r a c t Puzzle {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
Figure 3: A contract that rewards users who solve a computa-
tional puzzle.

msg . sender . send ( reward ); // send reward
s o l u t i o n = msg . data ;
locked = true ;

if ( locked ) throw ;
if ( sha256 ( msg . data ) < diff ){

if ( msg . data . length > 0){ // submit a s o l u t i o n

if ( msg . sender == owner ){ // update reward

}}}}

}

if ( locked )

throw ;

owner . send ( reward );
reward = msg . value ;

}
else

modify the blockchain state σ, adding a new contract ac-
count in three following steps. First, a unique address for
the new contract is prepared. Then the contract’s private
storage is allocated and initialized by running the construc-
tor (i.e., Puzzle() function in Line 8). Finally, the executable
EVM code portion that corresponds to the anonymous func-
tion (Line 15 onwards) is associated with the contract.

Any transaction invoking this contract will execute the
anonymous function() (Line 15) by default. The informa-
tion of the sender, the value (amount of Ether sent to the
contract) and the included data of the invocation transaction
is stored in a default input variable called msg. For example,
the contract owner updates the reward variable by invoking
a transaction To with some Ether (i.e., in msg.value). Be-
fore updating the reward variable to the new value (Line 20),
the contract indeed sends back to the owner, an amount of
Ether that is equal to the current reward value (Line 19).
The result of To is a new state of Puzzle which has a diﬀerent
reward value. Similarly, users can submit their solution in
a diﬀerent transaction payload (e.g., msg.data) to claim the
reward (Line 22–29). If the solution is correct, the contract
sends the reward to the submitter (Line 26).
Gas system. By design, the smart contract is a mech-
anism to execute code distributively. To ensure fair com-
pensation for expended computation eﬀort, Ethereum pays
miners some fees proportional to the required computation.
Speciﬁcally, each instruction in the Ethereum bytecode has
a pre-speciﬁed amount of gas. When a user sends a transac-
tion to invoke a contract, she has to specify how much gas
she is willing to provide for the execution (called gasLimit)
as well as the price for each gas unit (called gasPrice). A
miner who includes the transaction in his proposed block
subsequently receives the transaction fee corresponding to
the amount of gas the execution actually burns multiplied
by gasPrice.
If some execution requires more gas than
gasLimit, the execution is terminated with an exception,

Figure 2: The blockchain’s design in popular cryptocurrencies
like Bitcoin and Ethereum. Each block consists of several trans-
actions.

deﬁned validity constraints, such as those ensuring mitiga-
tion of “double-spending” attacks, then all miners update
their ledger to include the new block. We exclude certain
details about the consensus protocol, such as the use of the
longest-chain rule for resolving probabilistic discrepancies in
leader election. Instead, we refer readers to the original Bit-
coin or Ethereum paper for details [1, 2].

A blockchain state σ is a mapping from addresses to ac-
counts; the state of an account at address γ is σ[γ]. While
Bitcoin only has normal accounts which hold some coins,
Ethereum additionally supports smart contract accounts which
have coins, executable code and persistent (private) stor-
age. Ethereum supports its own currency called Ether; users
can transfer coins to each other using normal transactions
as in Bitcoin, and additionally can invoke contracts using
contract-invoking transactions. Conceptually, Ethereum can
be viewed as a transaction-based state machine, where its
state is updated after every transaction. A valid transition
from σ to σ
2.2 Smart Contracts in Ethereum

, via transaction T is denoted as σ

T−→ σ

.

(cid:48)

(cid:48)

A smart contract (or contract for short) is an “autonomous
agent” stored in the blockchain, encoded as part of a “cre-
ation” transaction that introduces a contract to the blockchain.
Once successfully created, a smart contract is identiﬁed by
a contract address; each contract holds some amount of of
virtual coins (Ether), has its own private storage, and is
associated with its predeﬁned executable code. A contract
state consists of two main parts: a private storage and the
amount of virtual coins (Ether) it holds (called balance).
Contract code can manipulate variables like in traditional
imperative programs. The code of an Ethereum contract is
in a low-level, stack-based bytecode language referred to as
Ethereum virtual machine (EVM) code. Users deﬁne con-
tracts using high-level programming languages, e.g., Solid-
ity [16] (a JavaScript-like language), which are then com-
piled into EVM code. To invoke a contract at address γ,
users send a transaction to the contract address. A trans-
action typically includes: payment (to the contract) for the
execution (in Ether) and/ or input data for the invocation.
An Example. Figure 3 is a simple contract, deﬁned in
Solidity, which rewards anyone who solves a computational
puzzle and submits the solution to the contract. The creator
of the contract includes the compiled (EVM) code of Puzzle
in a “contract creation” transaction. When such transaction
is accepted to the blockchain, all miners will unanimously

Code	Storage	Balance	PrivBlock	Nonce	ListOfTxs	Blockchain	state	TimeStamp	PrivBlock	Nonce	ListOfTxs	Blockchain	state	TimeStamp	Update(PrevState,	ListOfTxs)	Block	i	Block	i+1	Time	256the state σ is reverted to the initial state as if the execution
did not happen. In case of such aborts, the sender still has
to pay all the gasLimit to the miner though, as a counter-
measure against resource-exhaustion attacks [6].

3. SECURITY BUGS IN CONTRACTS

We discuss several security bugs which allow malicious

miners or users to exploit and gain proﬁt.
3.1 Transaction-Ordering Dependence

As discussed in Section 2, a block includes a set of transac-
tions, hence the blockchain state is updated several times in
each epoch. Let us consider a scenario where the blockchain
is at state σ and the new block includes two transactions
(e.g., Ti, Tj) invoking the same contract. In such a scenario,
users have uncertain knowledge of which state the contract
is at when their individual invocation is executed. For exam-
ple, Ti is applied when the contract is at either state σ[α] or

(cid:48)

(cid:48)

Tj−→ σ

[α] where σ

state σ
, depending on the order between
Ti and Tj. Thus, there is a discrepancy between the state
of the contract that users may intend to invoke at, and the
actual state when their corresponding execution happens.
Only the miner who mines the block can decide the order of
these transactions, consequently the order of updates. As a
result, the ﬁnal state of a contract depends on how the miner
orders the transactions invoking it. We call such contracts
as transaction-ordering dependent (or TOD) contracts.
3.1.1 Attacks
It may be not obvious to the readers why having depen-
dence on the transaction ordering is problematic for smart
contracts. The reasons are twofold. First, even a benign
invocation to the contract may yield an unexpected result
to users if there are concurrent invocations. Second, a mali-
cious user can exploit the TOD contracts to gain more prof-
its, even steal users’ money. We explain the two scenarios
below by using the Puzzle contract in Figure 3.
Benign scenario. We consider two transactions To and
Tu sending to Puzzle at roughly the same time. To is from
the contract owner to update the reward and Tu is from
a user who submits a valid solution to claim the reward.
Since To and Tu are broadcast to the network at roughly
the same time, the next block will most likely include both
the transactions. The order of the two transactions decides
how much reward the user receives for the solution. The
user expects to receive the reward that he observes when
submitting his solution, but he may receive a diﬀerent re-
ward if To is executed ﬁrst. The problem is more signiﬁcant
if the contract serves as a decentralized exchange or market
place [20, 21]. In these contracts, sellers frequently update
the price, and users send their orders to buy some items
(Figure 4). Depending on the transaction ordering, users’
buy requests may or may not go through. Even worse, buy-
ers may have to pay much higher than the observed price
when they issue the buy requests.
Malicious scenario. The above scenario may just be an
accident because the owner of Puzzle does not know when a
solution is submitted. However, a malicious owner can ex-
ploit transaction-ordering dependence to gain ﬁnancial ad-
vantage. Note that there is a time gap between when trans-
action Tu is broadcast and when it is included in a block.
In Ethereum, the time to ﬁnd a new block is around 12 sec-

price = _price ;

if ( msg . sender == owner )

}
f u n c t i o n buy ( uint quant ) returns ( uint ){

uint public price ;
uint public stock ;
/.../
f u n c t i o n u p d a t e P r i c e ( uint _price ){

1 c o n t r a c t M a r k e t P l a c e {
2
3
4
5
6
7
8
9
10
11
12
13
14
Figure 4: A contract that acts as a market place where users can
buy/ sell some tokens. Due to TOD, some order may or may not
go through.

if ( msg . value < quant * price || quant > stock )

stock -= quant ;
/.../

throw ;

}}

block . t i m e s t a m p ;

uint256 y = salt * block . number /( salt %5);
uint256 seed = block . number /3 + ( salt %300)

uint private L a s t _ P a y o u t = 0;
uint256 salt =
f u n c t i o n random returns ( uint256 result ){

1 c o n t r a c t theRun {
2
3
4
5
6
7
8
9
10
11
12
Figure 5: A real contract which depends on block timestamp to
send out money [22]. This code is simpliﬁed from the original
code to save space.

// h = the b l o c k h a s h of the seed - th last block
uint256 h = uint256 ( block . b l o c k h a s h ( seed ));
// random number between 1 and 100
return uint256 ( h % 100) + 1;

+ L a s t _ P a y o u t + y ;

}}

onds. Thus, a malicious owner of the Puzzle contract can
keep listening to the network to see if there is a transaction
which submits a solution to his contract. If so, he sends his
transaction To to update the reward and make it as small as
zero. With a certain chance, both To and Tu are included in
the new block and his To is placed (so executed) before the
Tc. Thus the owner can enjoy a free solution for his puz-
zle. The owner can even bias the chance of his transaction
winning the race (i.e., to be executed ﬁrst) by participating
directly in the mining, setting higher gasPrice for his trans-
action (i.e., to incentivize miners to include it in the next
block) and/or colluding with other miners.
3.2 Timestamp Dependence

The next security problem that a contract may have uses
the block timestamp as a triggering condition to execute
some critical operations, e.g., sending money. We call such
contracts as timestamp-dependent contracts.

A good example of a timestamp-dependent contract is the
theRun contract in Figure 5, which uses a homegrown ran-
dom number generator to decide who wins the jackpot [22].
Technically TheRun uses the hash of some previous block
as the random seed to select the winner (Line 9–10). The
choice of block is determined based on the current block
timestamp (Line 5–7).

Let us recall that when mining a block, a miner has to set
the timestamp for the block (Figure 2). Normally, the times-
tamp is set as the current time of the miner’s local system.
However, the miner can vary this value by roughly 900 sec-
onds, while still having other miners accept the block [23] 1.

1The variation of block timestamp may now be less than 900
seconds according to the fact that Ethereum requires nodes
in the network to have roughly “same” local timestamps.

257Speciﬁcally, on receiving a new block and after checking
other validity checks, miners check if the block timestamp is
greater than the timestamp of previous block and is within
900 seconds from the timestamp on their local system. Thus,
the adversary can choose diﬀerent block timestamps to ma-
nipulate the outcome of timestamp-dependent contracts.
3.2.1 Attacks
A miner can set the block timestamp to be a speciﬁc
value which inﬂuences the value of the timestamp-dependent
condition and favor the miner. For example in the theRun
contract, the hash of previous block and block number are
known, other contract variables like last payout which con-
tribute to the generation of the random seed are also known.
Thus the miner can precompute and select the timestamp so
the function random produces an outcome that favors him.
As a result, the adversary may completely bias the outcome
of the random seed to be any value, thus awarding the jack-
pot to any player he pleases. Thus, theRun is vulnerable to
any adversary who can manipulate the block timestamp.

While theRun uses timestamp as a insecure deterministic
random seed, other contracts use block timestamp as global
timestamp and perform some time-dependent computation.
We show in Section 6 an example which uses timestamp for
this purpose and is vulnerable to manipulation. Unfortu-
nately, there are many other contracts which are timestamp-
dependent. As we show in Section 6, among the ﬁrst 19, 366
contracts, 83 of them depend on the block timestamp to
transfer Ether to diﬀerent addresses.
3.3 Mishandled Exceptions

In Ethereum, there are several ways for a contract to call
another, e.g., via send instruction or call a contract’s func-
tion directly (e.g.,aContract.someFunction()). If there is an
exception raised (e.g., not enough gas, exceeding call stack
limit) in the callee contract, the callee contract terminates,
reverts its state and returns false. However, depending on
how the call is made, the exception in the callee contract
may or may not get propagated to the caller. For example,
if the call is made via the send instruction, the caller con-
tract should explicitly check the return value to verify if the
call has been executed properly. This inconsistent exception
propagation policy leads to many cases where exceptions are
not handled properly. As we later show in Section 6, 27.9%
of the contracts do not check the return values after call-
ing other contracts via send. We discuss the threats of not
validating return value of a contract call via our example in
Figure 6, which is a code snippet of a real contract [12].
3.3.1 Attacks
The KingOfTheEtherThrone (KoET for short) contract in
Figure 6 allows users to claim as “king of Ether” by paying
some amount of Ether that the current king requires. A king
gets proﬁt (i.e., compensation) from the diﬀerence between
the price he paid to the king before him and the price other
pays to be his successor. When a user claims the throne, the
contract sends the compensation to the ceded king (Line 15),
and assigns the user as the new king (Line 18—20).

The KoET contract does not check the result of the com-
pensation transaction in Line 15 before assigning the new

However, we could not ﬁnd any updated document from
Ethereum regarding the new possible variation, thus keeping
900 seconds.

struct Monarch {

Monarch public c u r r e n t M o n a r c h ;
// claim the throne
f u n c t i o n c l a i m T h r o n e ( string name ) {

// address of the king .
address ethAddr ;
string name ;
// how much he pays to p r e v i o u s king
uint c l a i m P r i c e ;
uint c o r o n a t i o n T i m e s t a m p ;
}

1 c o n t r a c t K i n g O f T h e E t h e r T h r o n e {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
Figure 6: A code snippet of a real contract which does not check
the return value after calling other contracts [12].

/.../
if ( c u r r e n t M o n a r c h . ethAddr != w i z a r d A d d r e s s )
c u r r e n t M o n a r c h . ethAddr . send ( c o m p e n s a t i o n );

/.../
// assign the new king
c u r r e n t M o n a r c h = Monarch (

msg . sender , name ,
valuePaid , block . t i m e s t a m p );

}}

king. Thus, if for some reason, the compensation transaction
does not ﬁnish properly, the current king loses his throne
without any compensation. In fact, an instance of such a
problem occurred and led to the termination of KoET [12].
The reason reported in [12] is that the address Ak of the cur-
rent king is not a normal address, but a contract address.
When sending a transaction (or call) to Ak, some code will
be executed, thus requiring more gas than a transaction to
a normal address. However, KoET does not know what Ak
executes internally beforehand to decide how much gas to
give in the send instruction. Hence Ak runs out of gas and
throws an exception. As a result, the state (and balance)
of Ak remains unchanged, the compensation is returned to
KoET and the current king loses his throne without any
compensation.

The above problem often arises when a contract sends
money to a dynamic address, since the sender does not know
how much gas to allocate for the transaction. The contract
should always check if the transaction succeeds before exe-
cuting subsequent logic. The callee contract may throw an
exception of any type (e.g., division by zero, array index out
of bound and so on).

In this scenario, the recipient (or callee) seems at fault,
causing the send to fail. However, as we show next, a mali-
cious user who invokes the caller contract can cause the send
to fail deliberately, regardless of what the callee does.
Deliberately exceeding the call-stack’s depth limit.
The Ethereum Virtual Machine implementation limits the
call-stack’s depth to 1024 frames. The call-stack’s depth
increases by one if a contract calls another via the send or
call instruction. This opens an attack vector to deliberately
cause the send instruction in Line 15 of KoET contract to
fail. Speciﬁcally, an attacker can prepare a contract to call
itself 1023 times before sending a transaction to KoET to
claim the throne from the current king. Thus, the attacker
ensures that the call-stack’s depth of KoET reaches 1024,
causing the send instruction in Line 15 to fail. As the result,
the current king will not receive any payment. This call-
stack problem was identiﬁed in a previous report [24], but
remains unﬁxed in the current Ethereum protocol.
Exploiting call stack limit to gain beneﬁt. In the previ-
ous attack to KoET, the attacker does not receive any direct

2581 c o n t r a c t S e n d B a l a n c e {
2 mapping ( address = > uint ) u s e r B a l a n c e s ;
3 bool w i t h d r a w n = false ;
4 f u n c t i o n g e t B a l a n c e ( address u ) c o n s t a n t returns ( uint ){
5
6 }
7 f u n c t i o n a d d T o B a l a n c e () {
8
9 }

u s e r B a l a n c e s [ msg . sender ] += msg . value ;

return u s e r B a l a n c e s [ u ];

if (!( msg . sender . call . value (

u s e r B a l a n c e s [ msg . sender ])())) { throw ; }

10 f u n c t i o n w i t h d r a w B a l a n c e (){
11
12
13
14
Figure 7: An example of the reentrancy bug. The contract im-
plements a simple bank account.

u s e r B a l a n c e s [ msg . sender ] = 0;
}}

beneﬁt besides causing other users to lose their entitlement.
However, in many other examples, the attacker can exploit
to directly beneﬁt as well.
In Ethereum, many contracts
implement veriﬁable Ponzi (or pyramid) schemes [22,25,26].
These contracts pay investors interest for their investments
from the subsequent investments by others. An attacker can
invest his money, make payments to previous investors fail
so he can receive his interest early. We discuss one of such
contracts in Section 6. Speciﬁcally, we show that 5, 411 con-
tracts (27.9%) are vulnerable to attacks that deliberately ex-
ceed the call-depth limit. We also conduct the attack in one
of the most popular contracts in Ethereum (with no harm
to others, but our own accounts) to conﬁrm our ﬁnding.
3.4 Reentrancy Vulnerability

Reentrancy is a well-known vulnerability with a recent
TheDao hack [19], where the attacker exploited the reen-
trancy vulnerability to steal over 3, 600, 000 Ether, or 60
million US Dollars at the time the attack happened. For
the completeness of this paper, we discuss the vulnerability
here as we later on describe how one can implement reen-
trancy’s detection in our tool Oyente in Section 5.

In Ethereum, when a contract calls another, the current
execution waits for the call to ﬁnish. This can lead to an
issue when the recipient of the call makes use of the inter-
mediate state the caller is in. This may not be immediately
obvious when writing the contract if possible malicious be-
havior on the side of the callee is not considered.
Attack example. We can see an example of this attack
in sendBalance (Figure 7). The contract being called by
sendBalance can simply call it again, since the balance for
this contract has not yet been set to zero.
In Figure 7,
Line 15 sends the current balance of the withdrawer — as
indicated by the internal variable userBalances — to the
contract address wishing to withdraw its balance. How-
ever, the variable userBalances is only zeroed after the call is
made, which means that the persistent storage of the con-
tract which records users’ balances has not yet been altered.
The callee contract of the call in Line 15, using its default
function, can call withdrawBalance until the contract is emp-
tied of Ether — or it depletes available gas — whichever
comes ﬁrst.

4. TOWARDS A BETTER DESIGN

We formalize a “lightweight” semantics for Ethereum in
Section 4.1, and then build on this formalism in Section 4.2
to recommend solutions to the security issues identiﬁed in

Section 3. Despite being lightweight, our formalism rigor-
ously captures interesting features of Ethereum, exposing
the subtleties in its semantics, which further enables us to
state our proposed solutions precisely.

We use the following notation: ← to denote assignment,
• to denote an arbitrary element (when the speciﬁc value
is important), ⇓ to denote big-step evaluation, and ; to
denote small-step evaluation. Finally, a[i (cid:55)→ v] returns a
new array identical to a, but on position i contains the value
v; this notation of array update also applies to nested arrays.
4.1 Operational Semantics of Ethereum

(cid:48)

(cid:48)

.

T−→ σ

Recall (from Section 2) that a canonical state of Ethereum,
denoted by σ, is a mapping between addresses and account
states. We write a valid transition from σ to σ
via transac-
tion T as σ
Formation and Validation of a Block. To model the
formation of the blockchain and the execution of blocks, we
deﬁne a global Ethereum state as a pair (cid:104)BC, σ(cid:105), where BC
is the current block chain and σ is as before. Γ denotes the
stream of incoming new transactions. For simplicity, we do
not model miner rewards.

TXs ← Some transaction sequence (T1 . . . Tn) from Γ

B ← (cid:104)blockid ; timestamp ; TXs ; . . .(cid:105)

proof-of-work(B, BC)
Ti−→ σi
∀ i, 1 ≤ i ≤ n : σi−1
(cid:104)BC, σ0(cid:105) ⇓ (cid:104)B · BC, σn(cid:105)

Remove T1 . . . Tn from Γ and broadcast B

Receive B ≡ (cid:104)blockid ; timestamp ; TXs ; . . .(cid:105)

TXs ≡ (T1 . . . Tn)

Ti−→ σi
∀ i, 1 ≤ i ≤ n : σi−1
(cid:104)BC, σ0(cid:105) ⇓ (cid:104)B · BC, σn(cid:105)

Remove T1 . . . Tn from Γ and broadcast B

Propose

Accept

Figure 8: Proposing and Accepting a Block

The actions of the miners to form and validate blocks
are given in Figure 8. Only one “elected leader” executes
successfully the Propose rule at a time. Other miners use
Ti−→ σi after
the Accept rule to “repeat” the transitions σi−1
the leader broadcasts block B.
Security Issues: As discussed earlier, the issue of timestamp-
dependence arises because the elected leader has some slack
in setting the timestamp, yet other miners still accept the
block. On the other hand, the issue of transaction-ordering-
dependence exists because of some inevitable order among
Ti; yet we have shown that when dealing with Ether (or
money), this might lead to undesirable outcomes.
Transaction Execution. A transaction can activate the
code execution of a contract. In Ethereum, the execution
can access to three types of space in which to store data:
(1) an operand LIFO stack s; (2) an auxiliary memory l,
an inﬁnitely expandable array; and (3) the contract’s long-
term storage str, which is part of σ[id] for a given contract
address id. Unlike stack and auxiliary memory, which reset
after computation ends, storage persists as part of σ.

We deﬁne a virtual machine’s execution state µ as a conﬁg-
uration (cid:104)A, σ(cid:105), where A is a call stack (of activation records)

259and σ is as before. The activation record stack is deﬁned as:

A ∆= Anormal | (cid:104)e(cid:105)exc · Anormal
∆= (cid:104)M, pc, l, s(cid:105) · Anormal | 

Anormal

where  denotes an empty call stack; (cid:104)e(cid:105)exc denotes that an
exception has been thrown; and each part of an activation
record (cid:104)M, pc, l, s(cid:105) has the following meaning:

M :
pc :
l :
s :

the contract code array
the address of the next instruction to be executed
an auxiliary memory (e.g. for inputs , outputs)
an operand stack.

Though a transaction in Ethereum is a complex structure
and speciﬁes a number of ﬁelds, we abstract it to a triple
(cid:104)id, v, l(cid:105) where id is the identiﬁer of the to-be-invoked con-
tract, v is the value to be deposited to the contract, and l
is an data array capturing the values of input parameters.
Thus a transaction execution can be modeled with the rules
in Figure 9: the ﬁrst rule describes an execution that ter-
minates successfully (or “normal halting”) while the second
rule describes one that terminates with an exception.

Note that the execution of a transaction is intended to
follow the “transactional semantics” of which two important
properties are: (1) Atomicity, requiring that each transac-
tion be “all or nothing”. In other words, if one part of the
transaction fails, then the entire transaction fails and the
state is left unchanged; and (2) Consistency, ensuring that
any transaction will bring the system from one valid state to
another. We will show, later in this section, how these prop-
erties might be violated, when we discuss the operational
semantics of EVM instructions.

T ≡ (cid:104)id, v, l(cid:105)

(cid:48)

σ

M ← Lookup(σ, id)

← σ[id][bal (cid:55)→ (σ[id][bal] + v)]
(cid:104)(cid:104)M, 0, l, (cid:105) · , σ
T−→ σ

(cid:105) ;∗

(cid:104), σ

(cid:105)

σ

(cid:48)(cid:48)

(cid:48)

(cid:48)(cid:48)

TX-success

TX-exception

(cid:48)

T ≡ (cid:104)id, v, l(cid:105)
σ
(cid:104)(cid:104)M, 0, l, (cid:105) · , σ
σ

M ← Lookup(σ, id)
← σ[id][bal (cid:55)→ (σ[id][bal] + v)]
(cid:105) ;∗
(cid:104)(cid:104)e(cid:105)exc · ,•(cid:105)
T−→ σ

(cid:48)

Figure 9: Rules for Transaction Execution. Lookup(σ,id) ﬁnds
the associated code of contract address id in state σ; σ[id][bal]
refers to the balance of the contract at address id in state σ.

Execution of EVM Instructions. We have distilled EVM
into a language EtherLite, which is a stack machine aug-
mented with a memory and some Ethereum-like features.
The instructions ins ∈ instruction of EtherLite are:

ins ∆= push v | pop | op | bne |

mload | mstore | sload | sstore |
call | return | suicide | create | getstate

The push instruction takes an argument v ∈ value which is
either a numeric constant z, code label λ, memory address
α, or contract/recipient address γ and adds it to the top of
the “operand stack”. The pop instruction removes (forgets)
the top element of the operand stack. The op instruction,
representing all of the arithmetic and logical etc. operations,
pops its arguments, performs the operation, and pushes the
result. Conditional branch bne is a standard “branch if not

equal to zero”. It pops two elements z and λ from the top of
the operand stack; if z is nonzero then the program counter
is set to λ, otherwise it is the program counter is incre-
mented. The load and store instructions respectively reads
from and writes to memory in the natural way. However,
here we have two types of load and store, dealing with two
types of memory mentioned above. While mload and mstore
deal with the auxiliary memory l, sload and sstore respec-
tively assesses and updates the contract storage str, i.e., the
state of the contract.

Let us now discuss more interesting instructions inspired
from Ethereum. The key instructions are call and return,
whose operational semantics are provided in Table 12. Each
row describes the conditions under which an execution can
(cid:48)
move from conﬁguration µ to conﬁguration µ
.
The ﬁrst column indicates the instruction form captured by
the rule. If the instruction about to be executed matches
that form and all the (side) conditions in the second column
are satisﬁed, then a step may be made from a conﬁguration
matching the pattern in the third column to a conﬁguration
matching the pattern in the last column.

, i.e. µ ; µ

(cid:48)

A call instruction is roughly analogous to a remote pro-
cedure call3. The arguments placed on the operand stack,
are the destination γ, amount of Ether to transfer z, and two
values st and sz (for “start address” and “size”) to specify a
slice of memory which contains additional function-speciﬁc
parameters. The next two values in the operand stack simi-
larly specify a place for the return value(s); they are exposed
(in the rules) when the call is returned, or an exception has
occurred. Unlike the operand stack, which has no ﬁxed max-
imum size, the call stack has a maximum size of 1, 024. If
the call stack is already full then the remote call will cause
an exception (second rule for call). When the remote call
returns, a special ﬂag is placed onto the operand stack, with
1 indicating a successful call (second rule for return) and 0
indicating an unspeciﬁed exception (rule EXC).

There are two important points to note. First, an excep-
tion at a callee is not limited to (call) stack overﬂow. It could
be due to various reasons such as gas exhaustion, division by
zero, etc. Second, exceptions are not propagated automat-
ically. Contract writers who wish to do so must explicitly
check for the 0 and then raise a new exception, typically
by jumping to an invalid label. For certain high-level com-
mands in Solidity, a code snippet to perform these steps is
inserted by the compiler.
Security Issues: Recall the security issues discussed in Sec-
tion 3.3, in particular when exceptions are mishandled. The
root cause of the problem is in the inconsistency of how ex-
ceptions inﬂuence the ﬁnal state, depending whether a con-
tract method is invoked as a transaction, or via the call
instruction. In the former case, rule TX-exception in Fig-
ure 9, the execution is aborted ; while in the latter case, row
exc Table 1, a ﬂag 0 is pushed into the operand stack of the
caller. The way that an exception occurs at a callee, and
is converted into a ﬂag 0 (and the execution continues nor-
mally) indeed breaks the atomicity property. In other words,
Ethereum transactions do not have atomicity in their seman-
tics. This can lead to serious consequences, especially given

2For completeness, operational semantics of other instruc-
tions are provided in the Appendix.
3Ethereum has several additional variants of call, includ-
ing CALLCODE and DELEGATECALL which we do not model in
EtherLite.

260Table 1: Operational Semantics of call and return. EXC stands for “Exception”.

M [pc]

Conditions

µ

(cid:48)

µ

(cid:48)

← (cid:104)M, pc, l, s(cid:105)
(cid:48)
← Lookup(σ, γ)
← σ[id][bal (cid:55)→ σ[id][bal] − z]
[γ][bal (cid:55)→ σ[id][bal] + z]
← σ

id ← address of the executing contract
(cid:48)
a
M
(cid:48)
σ
(cid:48)(cid:48)
σ
id ← address of the executing contract
σ[id][bal] < v or |A| = 1023
(cid:48)
(cid:48)
(cid:48)
· s
(cid:105)
, l
a
, pc
(cid:48)
n ← min(sz
, sz)
(cid:48)
0 ≤ i < n : l
i+1 ← l
+ i (cid:55)→ l[st + i]]
exceptional halting of callee

· sz
(cid:48)
(cid:48)
i[st

≡ (cid:104)M

(cid:48)
0, st

(cid:48)

(cid:48)

(cid:48)

call

call

return

return

EXC

(cid:104)(cid:104)M, pc, l, γ · z · st · sz · s(cid:105) · A, σ(cid:105)

(cid:48)

(cid:48)

, 0, l

, (cid:105) · a

(cid:48)

· A, σ

(cid:48)(cid:48)

(cid:105)

(cid:104)(cid:104)M

(cid:104)(cid:104)M, pc, l,• · v · • · • · • · • · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc,•,•(cid:105) · , σ(cid:105)
(cid:104)(cid:104)M, pc, l, st · sz · s(cid:105) · a
(cid:104)(cid:104)e(cid:105)exc · (cid:104)M, pc, l, st · sz · s(cid:105) · A, σ(cid:105)

· A, σ(cid:105)

(cid:48)

(cid:104)(cid:104)M, pc + 1, l, 0 · s(cid:105) · A, σ(cid:105)
(cid:104), σ(cid:105)
(cid:48)
(cid:104)(cid:104)M
(cid:104)(cid:104)M, pc + 1, l, 0 · s(cid:105) · A, σ(cid:105)

(cid:48)
n, 1 · s

+ 1, l

, pc

(cid:48)

(cid:48)

(cid:105) · A, σ(cid:105)

that money transfers in Ethereum are mostly done using the
call instruction.

There are three remaining instructions: suicide, cre-
ate, and getstate. The suicide instruction transfers all of
the remaining Ether to recipient γ and then terminates the
contract; although somewhat similar to call in that Ether
changes hands, it does not use the call stack. The create
instruction creates a new contract account, taking three ar-
guments from the operand stack. They are the amount of
Ether to be put in the new contract, and two values to spec-
ify a slice of memory which contains the bytecode for the
new contract. It proceeds in three steps:

1. Creating a new address and allocating storage for the
new contract. The speciﬁed amount of Ether is also
deposited into the contract.

2. Initializing the contract’s storage.

3. Depositing the associated code body into the contract.

If the contract creation is successful, the address of new
contract is pushed onto the operand stack; otherwise, a ﬂag
value of 0 is pushed. The three above-mentioned steps rely
on certain helper procedures, which we will not attempt to
capture with our formalism. Note that: (1) while the initial-
ization code is executing, the newly created address exists
but with no intrinsic body code; and (2) if the initialization
ends up with an exception then the state is left with a “zom-
bie” account, and any remaining balance will be locked into
the account forever.
In other words, an unsuccessful con-
tract creation might lead to an invalid contract residing in
the system, breaking the consistency property of the “trans-
actional semantics”. This issue might not directly lead to
some security attacks, it is clearly undesirable in the cur-
rent design of Ethereum.

Lastly, getstate is an abstract instruction of which the
concrete instance related to the security problem in 3.2 is
to get the current block timestamp. A getstate instruction
typically pushes certain “special” value onto the stack:
in
particular, the current timestamp, block id, remaining gas,
current balance, and this contract’s own address. Note that
some of these values should be thought of as constants (e.g.
current timestamp, block id), while others are updated in
tandem with the execution of a transaction (e.g. remaining
gas, current balance).

4.2 Recommendations for Better Semantics

We propose improvements to the operational semantics
of Ethereum to ﬁx the security problems discussed in Sec-
tion 3. To deploy these proposals, all clients in the Ethereum
network must upgrade.

4.2.1 Guarded Transactions (for TOD)
Recall that a TOD contract is vulnerable because users are
uncertain about which state the contract will be in when
their transactions is executed. This seems inevitable be-
cause miners can set arbitrary order between transactions
(rule Propose). To eliminate the TOD problem, we need
to guarantee that an invocation of a contract code either
returns the expected output or fails, even given the inherent
non-deterministic order between selected transactions.

TX-stale T ≡ (cid:104)g,•,•,•(cid:105)
T−→ σ

σ

σ (cid:54)(cid:96) g

TX-success

T ≡ (cid:104)g, id, v, l(cid:105)
σ (cid:96) g

σ

(cid:48)

M ← Lookup(σ, id)
← σ[id][bal (cid:55)→ (σ[id][bal] + v)]
(cid:105) ;∗
(cid:48)

(cid:104), σ

(cid:105)

(cid:48)(cid:48)

(cid:104)(cid:104)M, 0, l, (cid:105) · , σ
T−→ σ

σ

(cid:48)(cid:48)

TX-exception

T ≡ (cid:104)g, id, v, l(cid:105)
σ (cid:96) g

σ

(cid:48)

(cid:48)

M ← Lookup(σ, id)
← σ[id][bal (cid:55)→ (σ[id][bal] + v)]
(cid:105) ;∗
T−→ σ

(cid:104)(cid:104)e(cid:105)exc · ,•(cid:105)

(cid:104)(cid:104)M, 0, l, (cid:105) · , σ
σ

Figure 10: New Rules for Transaction Execution.

Guard Condition. Our new rules for transaction execu-
tion are given in Figure 10. A transaction T now addition-
ally speciﬁes a guard condition g; the current state σ needs
to satisfy g for the execution of T to go through. If g is not
satisﬁed, the transaction is simply dropped by the new rule
TX-stale. For transactions which do not provide g, we sim-
ply consider g ≡ true. This solution guarantees that either
the sender gets the expected output or the transaction fails.
The solution is also backward-compatible because we do not
require changes in existing contract code: old transactions
can simply take the default guard condition true.

To illustrate, let us revisit the Puzzle contract in Sec-

261tion 3.1. A user who submits a transaction Tu to claim
the reward should specify the condition g ≡ (reward == R),
where R is the current reward stored in the contract. If the
owner’s transaction is executed ﬁrst, g is invalidated and
the user’s transaction Tu will abort, meaning the owner will
not get the solution4. Note that Puzzle is only one example
of a more serious class of contracts serving as decentralized
exchanges or market places (see Section 3.1). With our so-
lution, buyers can easily avoid paying a price much higher
than what they observe when issuing the buy orders.

Note that “guarded transactions” resemble the “compare-
and-swap” (CAS) instruction supported by most modern
processors. CAS is a key standard multithreaded synchro-
nization primitive, and “guarded transactions” equips Ether-
eum with equivalent power.
4.2.2 Deterministic Timestamp
Allowing contracts to access to the block timestamp is
essentially a redundant feature that renders contracts vul-
nerable to manipulation by adversaries. Typically, block
timestamp is used for two purposes:
serving as a deter-
ministic random seed (e.g., in theRun contract) and as a
global timestamp in a distributed network (in [25, 26, 28]).
Using block timestamp as a random seed is not wise since
the entropy is low and the timestamp is easy to manipu-
late. There are ways to obtain better random seeds on the
blockchain [29, 30].

Rather than using the easily-manipulable timestamp, con-
tracts should use the block index—a new block is created ap-
proximately every 12 seconds in Ethereum—to model global
time. The block index always increments (by one), removing
any ﬂexibility for an attacker to bias the output of contract
executions that access the time.

A practical ﬁx is to translate existing notions of times-
tamp into block numbers. The change can be implemented
by returning the block id for the instruction TIMESTAMP and
translating the associated expressions. For example, the
condition timestamp - lastTime > 24 hours can be rewrit-
ten as blockNumber - lastBlock > 7,200. This implementa-
tion requires changes to only the getstate instruction from
Section 4.1.
4.2.3 Better Exception Handling
A straightforward solution is to check the return value
whenever a contract calls another. Currently, the Solid-
ity compiler inserts a code snippet to perform exception
forwarding, except when the call is made via send or call,
which are considered low-level instructions (from Solidity
point of view). This half-way solution still leaves the “atom-
icity property” broken.

A better solution is to automatically propagate the excep-
tion at the level of EVM from callee to caller; this can be
easily implemented but requires all clients to upgrade. We
can additionally provide a mechanism for proper exception
handling, e.g., by having explicit throw and catch EVM in-
structions. If an exception is (implicitly or explicitly) thrown
in the callee and not properly handled, the state of the caller
can be reverted. This approach and has been used in many
popular programming languages including C++, Java and
Python. Note that adding throw and catch instructions

4Owners can read the solution from the transaction data if
it is in plain-text, but solutions to this are well-studied [6,
14, 27].

Figure 11: Overview Architecture of Oyente. Main components
are within the dotted area. Shaded boxes are publicly available.

does not help when the contract owner/writer is malicious
and deliberately plants a bug in the contract.

5. THE Oyente TOOL

Our solutions proposed in the previous Section do require
all clients in the network to up-grade, thus running the risk
of not seeing real deployment. As a pre-deployment mitiga-
tion, we provide a tool called Oyente to help: (1) develop-
ers to write better contracts; and (2) users to avoid invoking
problematic contracts. Importantly, other analyses can also
be implemented as independent plugins, without interfering
with our existing features. E.g., a straightforward exten-
sion of Oyente is to compute more precise estimation of
worst-case gas consumption for contracts.

Our analysis tool is based upon symbolic execution [31].
Symbolic execution 5 represents the values of program vari-
ables as symbolic expressions of the input symbolic values.
Each symbolic path has a path condition which is a formula
over the symbolic inputs built by accumulating constraints
which those inputs must satisfy in order for execution to fol-
low that path. A path is infeasible if its path condition is
unsatisﬁable. Otherwise, the path is feasible.

We choose symbolic execution because it can statically
reason about a program path-by-path. On one hand, this is
superior to dynamic testing, which reasons about a program
input-by-input. For Ethereum, dynamic testing would even
require much more eﬀort to simulate the execution envi-
ronment. As an example, to detect the transaction-ordering
dependence, we must compare the outcomes of the interleav-
ing of diﬀerent execution paths. It is diﬃcult to approach
this with dynamic testing, given the non-determinism and
complexity of the blockchain behaviors.

On the other hand, by reasoning about one path at a
time, symbolic execution can achieve better precision (or
less false positives) compared to traditional approaches us-
ing static taint analysis or general data ﬂow analysis.
In
those approaches, abstract program states are often merged,
admitting states that never happen in a real execution, and
eventually lead to high false positives.
5.1 Design Overview

Figure 11 depicts the architecture overview of Oyente.
It takes two inputs including bytecode of a contract to be
analyzed and the current Ethereum global state. It answers
whether the contract has any security problems (e.g., TOD,
timestamp-dependence, mishandled exceptions), outputting
“problematic” symbolic paths to the users. One by-product
of our tool is the Control Flow Graph (CFG) of the contract
5Symbolic execution can also be viewed as abstract inter-
pretation [32].

EXPLORER	CORE	ANALYSIS	Z3	Bit-Vector	Solver	VALIDATOR	ByteCode	Ethereum	State	CFG	Builder	Visualizer	262bytecode. We plan that in the future Oyente will be able
to work as an interactive debugger, thus we feed the CFG
and the problematic paths into a Graph Visualizer.

The bytecode is publicly available on the blockchain and
Oyente interprets EVM instruction set to faithfully maps
instructions to constraints, i.e., bit-level accuracy. The Ether-
eum global state provides the initialized (or current) values
of contract variables, thus enabling more precise analysis.
All other variables including value, data of message call are
treated as input symbolic values.

Oyente follows a modular design. It consists of four main
components, namely CFGBuilder, Explorer, CoreAnalysis and
Validator. CFGBuilder constructs a Control Flow Graph of
the contract, where nodes are basic execution blocks, and
edges represent execution jumps between the blocks. Ex-
plorer is our main module which symbolically executes the
contract. The output of Explorer is then fed to the CoreAnal-
ysis where we implement our logic to target the vulnerabili-
ties identiﬁed in Section 3. Finally, Validator ﬁlters out some
false positives before reporting to the users.

5.2 Implementation

We implement Oyente in Python with roughly 4, 000
lines of code. Currently, we employ Z3 [33] as our solver to
decide satisﬁability. Oyente faithfully simulates Ethereum
Virtual Machine (EVM) code which has 64 distinct instruc-
tions in its language. Oyente is able to detect all the three
security problems discussed in Section 3. We describe each
component below.
CFG Builder. CFGBuilder builds a skeletal control ﬂow
graph which contains all the basic blocks as nodes, and some
edges representing jumps of which the targets can be de-
termined by locally investigating the corresponding source
nodes. However, some edges cannot be determined stat-
ically at this phase, thus they are constructed on the ﬂy
during symbolic execution in the later phase.
Explorer. Our Explorer starts with the entry node of the
skeletal CFG. At any one time, Explorer may be executing a
number of symbolic states. The core of Explorer is an inter-
preter loop which gets a state to run and then symbolically
executes a single instruction in the context of that state.
This loop continues until there are no states remaining, or
a user-deﬁned timeout is reached.

A conditional jump (JUMPI) takes a boolean expression
(branch condition) and alters the program counter of the
state based on whether the condition is true or false. Ex-
plorer queries Z3 to determine if the branch condition is ei-
ther provably true or provably false along the current path;
if so, the program counter is updated to the appropriate tar-
get address. Otherwise, both branches are possible: we then
explore both paths in Depth First Search manner, updating
the program counter and path condition for each path ap-
propriately. More edges might be added to the skeletal CFG.
At the end of the exploration phase, we produce a set of
symbolic traces. Each trace is associated with a path con-
straint and auxiliary data that the analyses in later phase
require. The employment of a constraint solver, Z3 in par-
ticular, helps us eliminate provably infeasible traces from
consideration.
Core Analysis. CoreAnalysis contains sub-components to
detect contracts which are TOD, timestamp-dependent or
mishandled exceptions. Currently, the Explorer collects only

paths which exhibit distinct ﬂows of Ether. Thus, we detect
if a contract is TOD if it sends out Ether diﬀerently when
the order of transactions changes. Similarly, we check if a
contract is timestamp-dependent if the condition to send in-
cludes the block timestamp. We describe how we implement
our analyses as below.
• TOD detection. Explorer returns a set of traces and the
corresponding Ether ﬂow for each trace. Our analysis thus
checks if two diﬀerent traces have diﬀerent Ether ﬂows. If
a contract has such pairs of traces, Oyente reports it as
a TOD contract.

• Timestamp dependence detection. We use a special sym-
bolic variable to represent the block timestamp. Note that
the block timestamp stays constant during the execution.
Thus, given a path condition of a trace, we check if this
symbolic variable is included. A contract is ﬂagged as
timestamp-dependent if any of its traces depends on this
symbolic variable.

• Mishandled exceptions. Detecting a mishandled exception
is straightforward. Recall that if a callee yields an excep-
tion, it pushes 0 to the caller’s operand stack. Thus we
only need to check if the contract executes the ISZERO
instruction (which checks if the top value of the stack is
0) after every call. If it does not, any exception occurred
in the callee is ignored. Thus, we ﬂags such contract as a
contract that mishandles exceptions.

• Reentrancy Detection. We make use of path conditions in
order to check for reentrancy vulnerability. At each CALL
that is encountered, we obtain the path condition for the
execution before the CALL is executed. We then check if
such condition with updated variables (e.g., storage val-
ues) still holds (i.e., if the call can be executed again). If
so, we consider this a vulnerability, since it is possible for
the callee to re-execute the call before ﬁnishing it.

Validation. The last component is Validator which at-
tempts to remove false positives. For instance, given a con-
tract ﬂagged as TOD by CoreAnalysis and its two traces t1
and t2 exhibiting diﬀerent Ether ﬂows, Validator queries Z3
to check if both ordering (t1, t2) and (t2, t1) are feasible. If
no such t1 and t2 exist, the case is considered as a false
positive. However, because we have not fully simulated the
execution environment of Ethereum, Validator is far from
being complete. For the results presented in Section 6, we
resort to best-eﬀort manual analysis to conﬁrm the security
bugs. In other words, the current main usage of Oyente
is to ﬂag potentially vulnerable contracts; full-ﬂedged false
positive detection is left for future work.

6. EVALUATION

We measure the eﬃcacy of Oyente via quantitative and
qualitative analyses. We run Oyente on all contracts in the
ﬁrst 1, 459, 999 blocks of Ethereum. Our goals are three-
fold. First, we aim to measure the prevalence of the security
bugs discussed in Section 3 in the real Ethereum contracts.
Second, we highlight that our design and implementation
choices are driven by the characteristics of real-life smart
contracts, and that Oyente is robust enough to handle
them. Lastly, we present several case studies demonstrat-
ing misunderstandings that many contract developers have
about the subtle semantics of Ethereum.

263Figure 12: Number of buggy contracts per each security problem
reported by Oyente.

6.1 Benchmarks and Tool Robustness

We collected 19, 366 smart contracts from the blockchain
as of May 5, 2016. These contracts currently hold a total
balance of 3, 068, 654 Ether, or 30 Million US dollars at the
time of writing. The balance in contracts vary signiﬁcantly:
most of contracts do not hold any Ether (e.g., balance is
zero), 10% of them have at least 1 Ether, while the highest
balance (2, 401, 557 Ether) accounts for 38.9% of the total
balance in all contracts. On an average, a contract has 318.5
Ether, or equivalently 4523 US dollars. This suggests that
attackers are well-incentivized to target and exploit ﬂaws in
smart contracts to gain proﬁt.

Ethereum contracts vary from being simple to fairly com-
plex. Figure 13 shows that the number of instructions in a
contract ranges from 18 to 23, 609, with an average of 2, 505
and a median of 838. The number of distinct instructions
used in a single contract is shown in Figure 13.
It shows
that to handle these real-world contracts, Oyente needs
to correctly handle the logic of 63 instructions. We choose
to build Oyente on EVM bytecode rather than the source
code (e.g., Solidity [16]) because only a small number con-
tracts have source code publicly available on public repos-
itories [34, 35]. Oyente ﬁnds a total number of 366, 213
feasible execution paths which took a total analysis time of
roughly 3, 000 hours on Amazon EC2.
6.2 Quantitative analysis
Experimental setup. We run Oyente on 19, 366 con-
tracts in our benchmark. All experiments are conducted on
4 Amazon EC2 m4.10xlarge instances, each has 40 Ama-
zon vCPU with 160 GB of memory and runs 64-bit Ubuntu
14.04. We use Z3 v4.4.1 as our constraint solver [33]. We
set a timeout for our symbolic execution (e.g.,Explorer com-
ponent) of 30 mins per contract. The timeout for each Z3
request is set to 1 second.
Performance. On average, Oyente takes 350 seconds to
analyze a contract. 267 contracts require more than 30 min-
utes to analyze. The number of paths explored by Oyente
ranges from 1 to 4613 with an average of 19 per contract
and a median of 6. We observe that the running time de-
pends near linearly on the number of explored paths, i.e.,
the complexity of contracts.
6.2.1 Results
Figure 12 reports our results. Oyente ﬂags 8, 833 con-

Figure 13: Number of instructions in each contract

tracts which have at least one security issue discussed in
Section 3. Out of these, 1, 682 are distinct (by direct com-
parison of the bytecode). Of these, we were able to collect
source code for only 175 contracts to conﬁrm the tool’s cor-
rectness; we manually check for false positives. Among all
contracts with source, Oyente has a low false positive rate
of 6.4%, i.e., only 10 cases out of 175.
Mishandled exceptions. 5, 411 contracts have mishan-
dled exceptions ﬂagged by Oyente, which account for 27.9%
of the contracts in our benchmark. Out of these 5, 411 con-
tracts, 1, 385 are found to be distinct and 116 contracts have
source code available. By manual analysis, we verify that
all these 116 contracts are true positives. In order to con-
ﬁrm, we identify if any external calls (SEND, CALL instruc-
tions) are present and not followed by any checks for failures.
These failure checks are implemented by verifying if the re-
turn value is non-zero.

The prevalence of this problem is explained by the follow-
ing observation. In the ﬁrst 1, 459, 999 blocks on the public
blockchain, 180, 394 cross-contract calls were processed. For
each contract invocation, there may be additional calls to
other contracts, thus increasing the call-stack depth. These
can be due to function or library calls, external account
transactions, or nested recursive contract calls. We plot the
call-stack depths of these contract invocations in Figure 14,
which shows that most of them involve some level of nesting
(e.g., invoking other contracts). Further, all contract invo-
cations do not exceed the call-stack depth of 50 in benign
runs, which is far below the call-stack depth’s limit of 1, 024.
This explains why exceptions are commonly unexpected and
unhandled in benign invocations.
Transaction-ordering dependence. The TOD contracts
are less common with 3, 056 contracts, or 15.7% of the con-
tracts in our benchmarks. Of these contracts, there are 135
distinct contracts and 32 have source code available. We
manually verify that 9 of them are false positives and 23
are true positives. In order to conﬁrm, we look for diﬀerent
ﬂows of Ether wherein the outcome depends on the order of
the input transactions.

Several true positive cases, where this dependence is ex-
ploitable, are discussed later. As an example of a false pos-
itive, Figure 15 shows a case where there are two separate
ﬂows of Ether, but the order of their execution does not
change the outcome of the contract. The ﬁrst ﬂow (send

ExceptionTODReentrancyTimestamp02,0004,0005,4113,056340831,38513518652No.ofcontractsNo.ofuniquecontracts051015202530354045500200040006000800010000120001400002000400060008000100001200014000160001800020000Distinct InstructionsTotal instructionsContracts (numbered from 1 to 19, 366)No. of instructionsNo. of distinct instructions264uint amount = msg . value ;
if (( amount < c o n t r i b u t i o n )...) {

msg . sender . send ( msg . value );
return ;

uint toSend = rest /2;
next . send ( toSend );
/.../

}
a d d P a r t i c i p a n t ( msg . sender , inviter );
address next = inviter ;
uint rest = amount ;
uint level = 1;
while ( ( next != top ) && ( level < 7) ){

1 f u n c t i o n enter (){
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18 }
Figure 15: A false positive TOD contract ﬂagged by Oyente.
This contract implements a typical ponzi scheme.

}
next . send ( rest );
Tree [ next ]. t o t a l P a y o u t += rest ;

vestor and the contract owner shares the jackpot.

• After 12 hours without no new investment, the last in-
The code to handle the last step is in Figure 17. Line 7
and 9 use send instructions to send Ether, which may not
execute correctly as discussed in Section 3.3. The contract
does not check if the operations were successful, leaving it
vulnerable to attack.
Stealing Ether from investors. Let us consider the code
snippet from Figure 17 which has a subtle bug. Line 11
seems harmless in that it pays out the owners after all cred-
itors have been paid, with all remaining amount. However,
if the owners were to call the contract with a carefully con-
structed call-stack size of 1023, none of the send instructions
would succeed, resulting in no Ether going out. A second
call to the contract would result in the owners receiving the
entirety of the contract’s balance and forcing previous in-
vestors to lose all Ether invested in the contract. Similar
attacks exist in other contracts as well (see [22, 25]).
Manipulation of contract outcome. PonziGovernMen-
tal is another example of timestamp-dependent contract.
In Line 5, PonziGovernMental determines the current time
by using the current block timestamp.
If a user invokes
PonziGovernMental when it is close to 12 hours since the last
deposit, the miner can set the next block timestamp to make
the condition in Line 5 either valid or invalid. Thus, min-
ers can force the PonziGovernMental contract to ﬁnish the
current round earlier by picking a timestamp value which is
ahead of the current time. Alternatively, miners can extend
the round for 12 hours by choosing a smaller timestamp.
Thus, miners who have a stake in the contract will set the
timestamp to a value which favors their outcome. The prob-
lem also exists in other contracts (see [28]).
Lock or Sabotage Others’ Funds. Attackers can also
prevent others from receiving their legitimate payments. One
example of such an attack is in EtherID, which is one of the
most active contracts in Ethereum with 57, 738 received/sent
transactions as of writing [38]. EtherID works as a name
registrar for Ethereum network to allow users to create, buy
and sell any ID (like a token). The code which handles
users’ requests to buy a registered ID is in Figure 18. The
code checks if the buyer has enough Ethers (Line 2), sends
the payment to the existing owner (Line 4) and change the
ownership of the ID (Line 5–10). As described in Section 3.3,
the send instruction in Line 4 may fail. As a result, the ID

Figure 14: Call-stack depth statistics in 180, 394 contract
invocations in Ethereum network

in Line 4) returns Ether to the sender if some requirement
is not met, while the latter (Line 7–17) pays out to previ-
ous participants. Oyente recognized the two ﬂows of Ether
and ﬂagged the contract as potentially buggy. However, the
order in which these ﬂows are executed by incoming trans-
actions does not aﬀect the intended payouts and recipients
therein. The tool could involve more time-consuming anal-
yses to resolve such cases in the future. The ﬁnal state of
the contract remains the same.
Timestamp dependence. Oyente reports 83 timestamp-
dependent contracts in our benchmark, out of which 52 are
distinct. Only 7 of these have source code available, which
we manually veriﬁed for false positives. To conﬁrm, we check
if timestamp is included in the path condition of a ﬂow of
Ether, such that manipulation of the block timestamp would
result in a diﬀerent payout or recipient from the contract.
Reentrancy Handling. Oyente reports 340 instances of
this vulnerability, out of which 186 are distinct. Only 2 of
these have source code available, one of which is the infa-
mous TheDAO contract [19]. The other known-source con-
tract has reentrancy vulnerability, but the vulnerability is
not exploitable since it uses the SEND instruction instead of
a CALL to call to a diﬀerent account. The signiﬁcant diﬀer-
ence here is that a CALL sends all of the remaining gas to
the callee at the time it is made, whereas a SEND limits this
amount. This simple change would limit the damage from
possible reentrancy attack. We further test Oyente on a
number of publicly available reentrancy examples [36] [37],
and Oyente conﬁrms all cases where repeated execution of
a call was possible.
6.3 Qualitative Analysis

We investigate several contracts ﬂagged by Oyente to

show how it helps analyze Ethereum smart contracts.

6.3.1 Severity of Attacks
We have found vulnerable contracts which have diﬀer-
ent levels of damage severity reported in Section 6.2. For
instance, the PonziGovernMental [26] contract with highest
balance (1, 099.5 Ether) ﬂagged by Oyente among the mis-
handled exception category. The contract operates as below.
• The contract accepts investments from users. New invest-
ments pay to previous investors and add to the jackpot.

010203040500246·104Call-stackdepthNumberofInvocations265if ( counter < 1023){

Foo public self ;
EtherId public etherid ;
uint256 public domain ;
/../
f u n c t i o n c a l l s e l f ( int counter ){

1 c o n t r a c t Foo {
2
3
4
5
6
7
8
9
10
11
12
13
14
Figure 16: A contract conducts the call-stack attack by calling
itself 1023 times before sending a buy request to EtherID.

}
else etherid . c h a n g e D o m a i n . value ( this . balance )\

self . c a l l s e l f . gas ( msg . gas -2000)( counter +1);

( domain , 10000000 , 1 ether /100 , 0);

else self . c a l l s e l f ( counter +1);

if ( counter > 0)

}}

owners may not receive the payment and still have to trans-
fer the ownership of their ID to the buyers. There is no way
for the owners to claim the payment later on. The Ether
value is locked in the contract forever.
6.4 Public Veriﬁcation

Verifying the above attack on the public blockchain is fea-
sible, but for ethical reasons we do not conduct our attack
conﬁrmation on contracts [22, 25, 26] where users may lose
funds. Instead, we perform our veriﬁcation on EtherID con-
tract on which the attack has less severity. More impor-
tantly, EtherID allows us to target our own accounts, other
accounts are not aﬀected in the experiments.

We verify the problem of EtherID by creating our own IDs
and self-purchasing them. We show that the registers of our
IDs do not receive the intended payments when the registers
use contract wallets, or when the buyers are malicious and
conduct the call-stack exceeding attack.

Our two IDs are dummywallet and foowallet registered by
two addresses 0x33dc532ec9b61ee7d8adf558ﬀ248542c2a2a62e
and 0x62ec11a7fb5e35bd9e243eb7f867a303e0dfe08b respectively.
The price to buy either of the ID is 0.01 Ether. The address
0x33dc532...
is a contract address, which performs some
computation (thus burning gas) on receiving any payment.
We then send two transactions from diﬀerent addresses to
buy the two IDs. The ﬁrst transaction 6 purchases dummy-
wallet. However, 0x33dc532... is a contract address, which is
implemented to burn all the provided gas on receiving any
payment without doing anything else. Thus the send func-
tion in Line 4 of EtherID to 0x33dc532... will fail. As a result,
0x33dc532... sells it ID without receiving any payment. The
fund 0.01 Ethers is kept in the contract EtherID forever.

The second transaction 7 sent from a contract, which calls
itself 1023 times before sending a buy request to EtherID to
buy foowallet. The code snippet to perform such attack is
in Figure 16. When EtherID executes send in Line 4, the
call stack already has 1024 frames, so send fails regardless
of how much gas is used. Hence, the address 0x62ec11a7...
does not receive the payment of 0.01 Ethers as it should.

7. RELATED WORK
Smart Contract Security. Delmolino et al. [14] show that
even a simple self-construct contract (e.g., “Rock, Paper,

6TX hash:
4c1216cd659350f83ef44ba071b4
7TX
986cc1050c850481f79b1a862bb10a

hash:

0xb169b07c274a71727ecfe9d0610d09917c45-

0x0c10fafe0cdbﬀf32abfe53d57ec861d09-

. send ( p r o f i t F r o m C r a s h );

owner . send ( this . balance );

block . t i m e s t a m p ) {
msg . sender . send ( amount );
// Sends jacpot to the last c r e d i t o r
c r e d i t o r A d d r e s s e s [ c r e d i t o r A d d r e s s e s . length - 1]

returns ( bool ) {
uint amount = msg . value ;
// check the c o n d i t i o n to end the game
if ( l a s t T i m e O f N e w C r e d i t + T W E L V E _ H O U R S >

1 f u n c t i o n l e n d G o v e r n m e n t M o n e y ( address buddy )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
Figure 17: PonziGovernmentMental contract, with over 1000
Ether, allows users to participate/proﬁt from the creation/fall
of a government.

// Reset c o n t r a c t state
l a s t C r e d i t o r P a y e d O u t = 0;
l a s t T i m e O f N e w C r e d i t = block . t i m e s t a m p ;
p r o f i t F r o m C r a s h = 0;
c r e d i t o r A d d r e s s e s = new address [](0);
c r e d i t o r A m o u n t s = new uint [](0);
round += 1;
return false ;

}}

Scissors”) can contain several logic problems, including:
• Contracts do not refund. Some contracts proceed further
only if users send a certain amount of Ether. However,
these contracts sometimes “forget” to refund users if users
send less than what is required.

• Lack of cryptography to achieve fairness. Some contracts
perform computation based on users’ inputs to decide the
outcome (e.g., rolling a die). However, those contracts
store users’ input in plaintext on the blockchain. Thus,
malicious users can submit inputs biased in their favor.
• Incentive misalignment. Some contracts do not incen-
tivize users to follow intended behavior. Consider a gam-
bling game that uses a commit-reveal scheme in which
participants ﬁrst submit their encrypted move along with
a deposit before later revealing it. After the ﬁrst move is
revealed, the second user may realize his move will lose.
Since his deposit lost, he may not be willing to spend gas
to reveal his choice.

These security problems are more about logical ﬂaws in the
implementation of contracts. In contrast, our paper docu-
ments new security bugs stemming from semantic misunder-
standings of smart contract developers. We suggest improve-
ments to the semantics and introduce Oyente to detect
these bugs in existing contracts in the Ethereum blockchain.
Our evaluation showed that 8, 519 existing contracts con-
tain at least one of the new bugs. The call-stack problem
of Ethereum was reported previously in a security audit by
Miller et al. [24]. The bug, however, still remains unﬁxed.

Other work also studies security and/or privacy concerns
in designing smart contracts [6, 27, 39, 40]. For instance,
Hawk [27] provides conﬁdential execution for contracts by
leveraging cryptographic techniques and Town Crier [39]
feeds reliable, trustworthy data from trusted web servers to
smart contracts via hardware rooted trust.
Distributed Systems and Programming Languages.
Security problems in smart contracts are often related to
problems in traditional distributed systems. For example,
concurrency control in multiuser distributed database sys-
tems (DBMS) [41] is superﬁcially similar to the transaction-
order dependency problem. However, transaction-ordering
problems in permissionless distributed systems like cryp-

266if ( d . price > 0)

msg . value >= d . price ){

address ( d . owner ). send ( d . price );

1 // ID on sale , and enough money
2 if ( d . price > 0 &&
3
4
5
6
7
8
9

d . owner = msg . sender ; // Change the o w n e r s h i p
d . price = price ;
d . t r a n s f e r = t r a n s f e r ;
d . expires = block . number + expires ;
D o m a i n C h a n g e d ( msg . sender , domain , 0 );

// New price

// New t r a n s f e r

10 }
Figure 18: EtherID contract, which allows users to register, buy
and sell any ID. This code snippet handles buy requests from
users.

tocurrencies are more complex than in traditional systems
because adversaries can manipulate the order.

Many previous works attempt to build a global times-
tamp in distributed systems, in both asynchronous and syn-
chronous settings [42–44]. Time in distributed systems tra-
ditionally forms a partial order rather than the the total
order given by the blockchain. As we discussed in Section 3,
having access to the block timestamp (in addition to the
block id) is redundant and invites attack. Lastly, propagat-
ing exceptions is inspired by the exception handling mecha-
nism in modern languages [45, 46].
8. ACKNOWLEDGMENT

We thank Brian Demsky, Vitalik Buterin, Yaron Welner,
Gregory J. Duck, Christian Reitwiessner, Dawn Song, An-
drew Miller, Jason Teutsch, Alex Zikai Wen, Patrick Cousot
and Joseph Chow for useful discussions and feedback on the
early version of the paper. This work is supported by the
Ministry of Education, Singapore under Grant No. R-252-
000-560-112 and in part by Yale-NUS College under Grant
No. R-607-265-045-121. All opinions expressed in this work
are solely those of the authors.
9. REFERENCES
[1] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic

cash system. bitcoin.org, 2009.

[2] Ethereum Foundation. Ethereum’s white paper. https:

//github.com/ethereum/wiki/wiki/White-Paper,
2014.

[3] A Miller, A Juels, E Shi, B Parno, and J Katz.

Permacoin: Repurposing Bitcoin work for long-term
data preservation. IEEE Security and Privacy, 2014.

[4] Use case for factom: The world’s ﬁrst blockchain

operating system (bos). http://kencode.de/projects/
ePlug/Factom-Linux-Whitepaper.pdf, Feb 2015.

[5] Nick Szabo. The idea of smart contracts.

http://szabo.best.vwh.net/smart contracts idea.html,
1997.

[6] Loi Luu, Jason Teutsch, Raghav Kulkarni, and
Prateek Saxena. Demystifying incentives in the
consensus computer. In Proceedings of the 22Nd ACM
SIGSAC Conference on Computer and
Communications Security, CCS ’15, pages 706–719.
ACM, 2015.

[7] EtherDice smart contract is down for maintenance.

https:
//www.reddit.com/r/ethereum/comments/47f028/
etherdice is down for maintenance we are having/.

[8] RSK Labs. Rootstock: Smart contracts platform

powered by Bitcoin. http://www.rootstock.io/, 2015.

[9] Counterparty platform. http://counterparty.io/, 2015.

[10] James C. Corbett, Jeﬀrey Dean, Michael Epstein,

Andrew Fikes, Christopher Frost, J. J. Furman, Sanjay
Ghemawat, Andrey Gubarev, Christopher Heiser,
Peter Hochschild, Wilson Hsieh, Sebastian Kanthak,
Eugene Kogan, Hongyi Li, Alexander Lloyd, Sergey
Melnik, David Mwaura, David Nagle, Sean Quinlan,
Rajesh Rao, Lindsay Rolig, Yasushi Saito, Michal
Szymaniak, Christopher Taylor, Ruth Wang, and Dale
Woodford. Spanner: Google’s globally distributed
database. ACM Trans. Comput. Syst., aug 2013.

[11] Jason Baker, Chris Bond, James C. Corbett,
JJ Furman, Andrey Khorlin, James Larson,
Jean-Michel Leon, Yawei Li, Alexander Lloyd, and
Vadim Yushprakh. Megastore: Providing scalable,
highly available storage for interactive services. In
Proceedings of the Conference on Innovative Data
system Research (CIDR), pages 223–234, 2011.
[12] KingOfTheEtherThrone smart contract. https:

//github.com/kieranelby/KingOfTheEtherThrone/
blob/v0.4.0/contracts/KingOfTheEtherThrone.sol.

[13] GovernMental’s 1100 ETH payout is stuck because it

uses too much gas. https:
//www.reddit.com/r/ethereum/comments/4ghzhv/
governmentals 1100 eth jackpot payout is stuck/.
[14] Kevin Delmolino, Mitchell Arnett, Ahmed Kosba,

Andrew Miller, and Elaine Shi. Step by step towards
creating a safe smart contract: Lessons and insights
from a cryptocurrency lab. Cryptology ePrint Archive,
Report 2015/460, 2015. http://eprint.iacr.org/.
[15] Gavin Wood. Ethereum: A secure decentralised

generalised transaction ledger.
http://gavwood.com/paper.pdf, 2014.

[16] Ethereum Foundation. The solidity contract-oriented

programming language.
https://github.com/ethereum/solidity.

[17] Ethereum Foundation. The serpent contract-oriented

programming language.
https://github.com/ethereum/serpent.

[18] Oyente project page.

https://www.comp.nus.edu.sg/˜loiluu/oyente.html.

[19] TheDAO smart contract. http://etherscan.io/address/
0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code.

[20] EtherEx: A fully decentralized cryptocurrency

exchange. https://etherex.org/.

[21] EtherOpt: A decentralized options exchange.

http://etheropt.github.io/.

[22] The Run smart contract.

https://etherscan.io/address/
0xcac337492149bdb66b088bf5914bedfbf78ccc18.

[23] Ethereum Foundation. Block validation algorithm.

https://github.com/ethereum/wiki/wiki/Block-
Protocol-2.0#block-validation-algorithm.

[24] Andrew Miller, Brian Warner, and Nathan Wilcox.

Gas economics. https://github.com/LeastAuthority/
ethereum-analyses/blob/master/GasEcon.md.

[25] Protect The Castle Contract.

http://protect-the-castle.ether-contract.org/.

[26] GovernMental Smart Contract.

http://governmental.github.io/GovernMental/.

267[27] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen,

and Charalampos Papamanthou. Hawk: The
blockchain model of cryptography and
privacy-preserving smart contracts. In Proceedings of
the 2016 IEEE Symposium on Security and Privacy,
SP ’16. IEEE Computer Society, 2016.

[28] Lottopolo smart contract.

https://etherchain.org/account/
0x0155ce35fe73249fa5d6a29f3b4b7b98732eb2ed.

[29] Random number generator contract.
https://github.com/randao/randao.

[30] Joseph Bonneau, Jeremy Clark, and Steven Goldfeder.
On Bitcoin as a public randomness source. Cryptology
ePrint Archive, Report 2015/1015, 2015.
http://eprint.iacr.org/.

[31] James C. King. Symbolic execution and program

testing. Commun. ACM, 19(7):385–394.

[32] Patrick Cousot and Radhia Cousot. Abstract

interpretation: A uniﬁed lattice model for static
analysis of programs by construction or approximation
of ﬁxpoints. In Proceedings of the 4th ACM
SIGACT-SIGPLAN Symposium on Principles of
Programming Languages, pages 238–252, New York,
NY, USA, 1977. ACM.

[33] Microsoft Corporation. The Z3 theorem prover.

https://github.com/Z3Prover/z3.

[34] The Ethereum block explorer. https://etherscan.io/.
[35] The Ethereum network stats. https://etherchain.org/.
[36] Peter Borah. Tokenwith invariants - vulnerable

contracts in ethereum. https://github.com/
PeterBorah/smart-contract-security-examples/blob/
7d7ef27b12f15318871c44512b70737176d23c5f/
contracts/TokenWithInvariants.sol.

[37] Peter Vessenes. More ethereum attacks:

Race-to-empty is the real deal.

http://vessenes.com/more-ethereum-attacks-race-to-
empty-is-the-real-deal/.

[38] Alexandre Naverniouk. EtherID: Ethereum name

registrar. http://etherid.org/.

[39] Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels,

and Elaine Shi. Town crier: An authenticated data
feed for smart contracts. Cryptology ePrint Archive,
Report 2016/168, 2016. http://eprint.iacr.org/.

[40] Ari Juels, Ahmed Kosba, and Elaine Shi. The ring of

Gyges: Investigating the future of criminal smart
contracts. Cryptology ePrint Archive, Report
2016/358, 2016. http://eprint.iacr.org/.

[41] Philip A. Bernstein and Nathan Goodman.

Concurrency control in distributed database systems.
ACM Comput. Surv., 13(2):185–221, June 1981.

[42] Friedemann Mattern. Virtual time and global states of

distributed systems. In Parallel and Distributed
Algorithms, pages 215–226. North-Holland, 1989.

[43] C. J. Fidge. Timestamps in message-passing systems
that preserve the partial ordering. Proceedings of the
11th Australian Computer Science Conference,
10(1):56ˆa ˘A¸S66, 1988.

[44] Leslie Lamport. Time, clocks, and the ordering of

events in a distributed system. Commun. ACM, pages
558–565, July 1978.

[45] Andrew Koening and Bjarne Stroustrup. Exception

handling for C++. Journal of Object-Oriented
Programming, 3(2):16–33, 1990.

[46] Robin Milner, Mads Tofte, and David MacQueen. The

Deﬁnition of Standard ML. MIT Press, Cambridge,
MA, USA, 1997.

APPENDIX
Table 2 describes the operational semantics of EtherLite.

268Table 2: Operational Semantics of EtherLite. EXC stands for “Exception”.

M [pc]
push v
pop
op
op
bne
bne
bne
mload
mstore

sload

sstore

call

call

return

return

EXC

suicide

suicide

Conditions

(cid:48)

(cid:48)

(cid:48)

(cid:48)

← op v
← v1 op v2

← σ[id][i (cid:55)→ v]
← (cid:104)M, pc, l, s(cid:105)
(cid:48)
← Lookup(σ, γ)
← σ[id][bal (cid:55)→ σ[id][bal] − z]
← σ
[γ][bal (cid:55)→ σ[id][bal] + z]

op: unary operator and v
op: binary operator and v
z = 0
z (cid:54)= 0 and λ is a valid target
z (cid:54)= 0 and λ is NOT a valid target
v ← l[i]
(cid:48)
← l[i (cid:55)→ v]
l
id ← address of the executing contract
v ← σ[id][i]
id ← address of the executing contract
(cid:48)
σ
id ← address of the executing contract
(cid:48)
a
M
(cid:48)
σ
(cid:48)(cid:48)
σ
id ← address of the executing contract
σ[id][bal] < v or |A| = 1023
(cid:48)
(cid:48)
(cid:48)
· s
(cid:105)
, l
a
, pc
(cid:48)
n ← min(sz
, sz)
(cid:48)
+ i (cid:55)→ l[st + i]]
i+1 ← l
0 ≤ i < n : l
exceptional halting of callee
id ← address of the executing contract
(cid:48)
← σ[γ][bal (cid:55)→ (σ[γ][bal] + σ[id][bal])]
σ
(cid:48)(cid:48)
← σ
σ
Register id for later deletion
id ← address of the executing contract
(cid:48)
≡ (cid:104)M
a
(cid:48)
← σ[γ][bal (cid:55)→ (σ[γ][bal] + σ[id][bal])]
σ
(cid:48)
(cid:48)(cid:48)
← σ
σ
Register id for later deletion

[id][bal (cid:55)→ 0]

[id][bal (cid:55)→ 0]

(cid:48)
0,• · • · s

· sz
(cid:48)
(cid:48)
i[st

≡ (cid:104)M

(cid:48)
0, st

, pc

, l

(cid:105)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

µ
(cid:104)(cid:104)M, pc, l, s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, v · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, v · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, v1 · v2 · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l,• · z · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, λ · z · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, λ · z · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, i · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, i · v · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, i · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc, l, i · v · s(cid:105) · A, σ(cid:105)

(cid:48)

µ

(cid:48)
(cid:48)

(cid:104)(cid:104)M, pc + 1, l, v · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, v
· s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, v
· s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, λ, l, s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)e(cid:105)exc · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, v · s(cid:105) · A, σ(cid:105)
(cid:48)
(cid:104)(cid:104)M, pc + 1, l
(cid:104)(cid:104)M, pc + 1, l, v · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc + 1, l, s(cid:105) · A, σ

, s(cid:105) · A, σ(cid:105)

(cid:105)

(cid:48)

(cid:104)(cid:104)M, pc, l, γ · z · st · sz · s(cid:105) · A, σ(cid:105)

(cid:48)

(cid:48)

, 0, l

, (cid:105) · a

(cid:48)

· A, σ

(cid:48)(cid:48)

(cid:105)

(cid:104)(cid:104)M

(cid:104)(cid:104)M, pc, l,• · v · • · • · • · • · s(cid:105) · A, σ(cid:105)
(cid:104)(cid:104)M, pc,•,•(cid:105) · , σ(cid:105)
(cid:104)(cid:104)M, pc, l, st · sz · s(cid:105) · a
(cid:104)(cid:104)e(cid:105)exc · (cid:104)M, pc, l, st · sz · s(cid:105) · A, σ(cid:105)

· A, σ(cid:105)

(cid:48)

(cid:104)(cid:104)M, pc + 1, l, 0 · s(cid:105) · A, σ(cid:105)
(cid:104), σ(cid:105)
(cid:48)
(cid:104)(cid:104)M
(cid:104)(cid:104)M, pc + 1, l, 0 · s(cid:105) · A, σ(cid:105)

(cid:48)
n, 1 · s

+ 1, l

, pc

(cid:48)

(cid:48)

(cid:105) · A, σ(cid:105)

(cid:104)(cid:104)M, pc,•, γ · s(cid:105) · , σ(cid:105)

(cid:48)(cid:48)

(cid:105)

(cid:104), σ

(cid:104)(cid:104)M, pc,•, γ · s(cid:105) · a

(cid:48)

· A, σ(cid:105)

(cid:48)

(cid:48)

, pc

+ 1, l

(cid:48)

(cid:48)
n, 1 · s

(cid:105) · A, σ(cid:105)

(cid:104)(cid:104)M

269