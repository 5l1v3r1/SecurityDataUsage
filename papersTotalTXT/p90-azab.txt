Hypervision Across Worlds: Real-time Kernel Protection

from the ARM TrustZone Secure World

Ahmed M. Azab1
Rohan Bhutkar1 Guruprasad Ganesh1

Peng Ning1,2

Jitesh Shah1

Jia Ma1

Quan Chen2
Wenbo Shen2

{a.azab, peng.ning, j1.shah, r1.bhutkar, g.ganesh, jia.ma}@samsung.com

1 Samsung KNOX R&D, Samsung Research America

2 Department of Computer Science, NC State University

{pning, qchen10, wshen3}@ncsu.edu

ABSTRACT
TrustZone-based Real-time Kernel Protection (TZ-RKP) is
a novel system that provides real-time protection of the OS
kernel using the ARM TrustZone secure world. TZ-RKP is
more secure than current approaches that use hypervisors
to host kernel protection tools. Although hypervisors pro-
vide privilege and isolation, they face fundamental security
challenges due to their growing complexity and code size.

TZ-RKP puts its security monitor, which represents its
entire Trusted Computing Base (TCB), in the TrustZone
secure world; a safe isolated environment that is dedicated
to security services. Hence, the security monitor is safe
from attacks that can potentially compromise the kernel,
which runs in the normal world. Using the secure world for
kernel protection has been crippled by the lack of control
over targets that run in the normal world. TZ-RKP solves
this prominent challenge using novel techniques that deprive
the normal world from the ability to control certain privi-
leged system functions. These functions are forced to route
through the secure world for inspection and approval before
being executed. TZ-RKP’s control of the normal world is
non-bypassable. It can eﬀectively stop attacks that aim at
modifying or injecting kernel binaries. It can also stop at-
tacks that involve modifying the system memory layout, e.g,
through memory double mapping.

This paper presents the implementation and evaluation
of TZ-RKP, which has gone through rigorous and thorough
evaluation of eﬀectiveness and performance. It is currently
deployed on the latest models of the Samsung Galaxy series
smart phones and tablets, which clearly demonstrates that
it is a practical real-world system.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660350.

General Terms
Security

Keywords
Integrity Monitoring; ARM TrustZone; Kernel Protection

1.

INTRODUCTION

Despite recent advances in systems security, attacks that
compromise the OS kernel still pose a real threat [1,5,27,37].
Such attacks can access system sensitive data, hide mali-
cious activities, escalate the privilege of malicious processes,
change the OS behavior or simply take control of the system.
Previous Attempts: Traditionally, kernel protection was
done using security tools that run in the same address space
and privilege level as the kernel. This approach is not se-
cure because an attack compromising the kernel would con-
sequently compromise these security tools as well. To pro-
tect the kernel, security protection tools should be properly
isolated. Recent eﬀorts to achieve this objective can be di-
vided into two categories: Hypervisor-based approaches and
hardware-based approaches.

Hypervisor-based approaches, such as [12,20,23,24,30,31,
35, 38, 43–45, 50, 52], use virtualization to provide their secu-
rity tools with high privilege and isolation. Nevertheless, hy-
pervisors face security challenges of their own. They become
more complex because they are required to do more tasks for
system management and resource distribution. Hence, they
become subject to numerous vulnerabilities [2, 3, 6, 7, 48, 49,
56]. Although dedicating the whole virtualization layer to
hosting security tools will decrease the chances of exploita-
tion by reducing the hypervisor code size, this is not a prac-
tical solution because it will deprive the system from using
other virtualization capabilities. Furthermore, hardware-
based virtualization is not supported on all platforms. For
example, the widely-used Qualcomm Snapdragon MSM8974
and APQ8084 ARM processors do not implement the hyper-
visor extension. Hence, these platforms need an alternative
method to host their security protection tools.

Hardware-based approaches use a diﬀerent type of hard-
ware protection. Realizing the security threats to kernels
and hypervisors, popular hardware platforms introduced a
new secure and isolated execution environment, which is
sometimes called the “secure world.” The secure world con-
sists of a thinner, more secure software layer dedicated to

90hosting security services. Moreover,
it has both limited
interface with the normal world and hardware protection
against illegal memory access from the normal world kernel
or hypervisor. Examples of the secure world include Intel
TXT [29], AMD SVM [8] and ARM TrustZone [9].

Hardware-based approaches, such as [13, 41, 55], use the
secure world to host kernel security protection tools. How-
ever, these systems are crippled by their inability to closely
monitor events that happen inside the target kernel. There-
fore, they do periodic kernel integrity checking, which has
limited eﬀectiveness because it can only detect attacks af-
ter they have already happened. Moreover, it can miss the
attack altogether, if the traces are properly hidden.

In summary, previous research shows that using the hy-
pervisor for kernel protection has security risks. At the
same time, hardware-based isolation lacks a critical capa-
bility, which is event-driven monitoring. Hence, there is a
trade oﬀ between the isolation provided to the security tool
and the control it possesses over the system to be measured.
Introducing TZ-RKP: TrustZone-based Real-time Kernel
Protection (TZ-RKP) provides the basic architecture re-
quired to protect the OS kernel using a security monitor that
is entirely located within the secure world of ARM Trust-
Zone. TZ-RKP enjoys the strongest possible isolation from
potential attacks. At the same time, it gives the security
monitor full control over the target kernel’s memory man-
agement. Moreover, it can intercept critical events and in-
spect their impact on security before allowing them to get
executed. As a result, TZ-RKP solves the dilemma that
previous approaches face because it does not have to trade
oﬀ between isolation and eﬀectiveness.

Current TZ-RKP design relies on hardware features that
are speciﬁc to the ARM architecture, which is used by the
majority of today’s mobile devices. Mobile devices, such
as smart phones and tablets, are getting more ubiquitous.
They also expose many interfaces and carry sensitive data,
hence compromising the kernel of such devices can cause
devastating consequences [15]. Having a trustworthy kernel
allows the target platform to have a secure foundation that
hardens the security of higher level system components.
Technical Challenges: A security protection tool running
in the TrustZone secure world has two main technical chal-
lenges. First, the normal world, which hosts the target OS,
has full control over its own resources, such as its physi-
cal memory and its Memory Management Unit (MMU). In-
tuitively, such control would allows attackers that exploit
the normal world to bypass any regular security monitoring
technique. For instance, attackers can change the location
of interrupt handlers to create invisible hooks that hijack
the kernel’s control ﬂow [22].

Second, the TrustZone secure world is not capable of inter-
cepting many of the critical events that occur in the normal
world, e.g., page fault exceptions and execution of system
control instructions. If these events are not trapped by the
secure world, their impact on the system security can go
unnoticed by the security monitor.
An Overview of TZ-RKP: TZ-RKP achieves two impor-
tant objectives. First, it completely prevents running unau-
thorized privileged code on the target system, which is ac-
complished by preventing modiﬁcation of the target kernel
code, injection of unauthorized code into the kernel, or exe-
cution of the user space code in the privileged mode. Second,
it prevents kernel data from being directly accessed by user

level processes. This includes preventing double mapping of
physical memory that contains critical kernel data into user
space virtual memory. This is an important step toward
complete security protection of the kernel using TrustZone.
In the proposed architecture, the security monitor runs in
the TrustZone secure world, while the kernel to be monitored
runs in the normal world. For convenience, we refer to the
the security monitor as TZ-RKP and to the OS kernel being
monitored as “the kernel.”

TZ-RKP provides two features that allow for an eﬀec-
tive kernel protection: (1) Event-driven monitoring of the
normal world critical events, and (2) memory protection of
critical parts of the normal world memory.

The ﬁrst feature, event-driven monitoring, is enforced by
depriving the kernel from its ability to control certain crit-
ical functions. Hence, it is forced to route requests to per-
form these functions through TZ-RKP. These functions in-
clude system control instructions and updates to the mem-
ory translation tables.

TZ-RKP instruments the kernel so that certain system
control instructions are removed from its executable mem-
ory, which is the only memory that can execute privileged
instructions in the normal world. The removed system con-
trol instructions are the ones that allow the normal world
to control security critical system state, such as deﬁning the
location of memory translation tables and exception han-
dlers. Therefore, the only way to execute these instructions
is through emulating them from the secure world. We call
this operation Control Instruction Emulation.

Memory translation tables, a.k.a. page tables, deﬁne the
virtual to physical address mapping and the access permis-
sions of virtual memory. TZ-RKP ensures that translation
tables cannot be modiﬁed by the normal world. Moreover,
it modiﬁes the kernel so that requests to update the trans-
lation tables are routed through the secure world.

The second feature provided by TZ-RKP is memory pro-
tection, which ensures that the target kernel cannot be modi-
ﬁed. It also prevents kernel code injection and return-to-user
attacks. Memory protection plays an important role to guar-
antee that monitoring is non-bypassable. It also provides a
new method to prevent kernel critical data from being di-
rectly accessed by potentially malicious user processes

The core TZ-RKP techniques presented in this paper were
ﬁrst invented and recorded in a provisional patent submitted
on August 2012. Afterwards, a patent application that is
publicly accessible was submitted on March 2013 [11].

Currently, TZ-RKP is implemented and deployed on re-
cent models of Samsung Galaxy smartphones and tablets, in-
cluding Samsung Note 3 and Samsung S5 smartphones, pro-
tecting millions of these devices. These models are among
the most advanced mobile devices on the market today. TZ-
RKP is deployed as a part of the TrustZone-base Integrity
Measurement Architecture (TIMA), which provides a suite
of TrustZone integrity measurement and security services on
Samsung smartphones and tablets [47].

TZ-RKP demonstrates that the security provided by Trust-
Zone does not have to be limited to executing isolated appli-
cations; it can be extended to provide non-bypassable secu-
rity protection for the running OS. TZ-RKP has been sub-
ject to rigorous evaluation. The results show that it is feasi-
ble to implement with minor instrumentation of the kernel,
resulting in an acceptable performance overhead.

91Summary of Contributions: We make several technical
contributions in this paper:

(cid:15) We provide a complete and feasible solution for kernel
protection using TrustZone, which is the most secure
component of the ARM architecture.

(cid:15) We provide techniques that allow the secure world to
control certain critical functions of the normal world.
This allows non-bypassable event-driven monitoring of
the normal world, which solves the main challenge that
faced previous approaches.

(cid:15) We provide techniques to guarantee a non-bypassable
memory protection of the normal world’s critical mem-
ory regions.

(cid:15) We provide a novel memory protection technique to

prevent unauthorized direct access of kernel data.

(cid:15) We present full implementation and rigorous evalua-

tion of TZ-RKP using advanced mobile devices.

This paper is organized as follows: Section 2 discusses
our assumptions and threat model. Section 3 provides re-
quired background information. Section 4 presents TZ-RKP
in detail. Section 5 presents our implementation. Section 6
presents our experimental evaluation. Section 7 presents re-
lated work. Section 8 concludes this paper with some future
research directions.

2. THREAT MODEL AND ASSUMPTIONS
Threat model: Threats against the OS kernel are divided
into three main categories.

The ﬁrst category includes attacks that aim at execut-
ing unauthorized privileged code inside the normal world.
This includes all attacks that aim to: (1) inject malicious
code into the kernel, (2) modify privileged code binaries
that already exist in memory or (3) escalate the privilege
of user space code. A real world example of these attacks
is vroot [5], where the adversary modiﬁes a kernel function
pointer to jump back into a malicious user space code in the
privileged mode. TZ-RKP prevents all these attacks with-
out relying on the target kernel itself.

The second category includes attacks that use malicious
double mapping to modify kernel data. These are special
class of data attacks that exploit kernel vulnerabilities to
generate user space mapping of kernel memory. A real world
example of these attacks is motochopper [1]. TZ-RKP pre-
vents this type of attacks, but this protection relies on the
kernel to provide information about its own memory usage
ﬁrst. This information is provided before the designated
memory areas are used to store data. Hence, the kernel data
double mapping protection is eﬀective on all kernel memory
ranges before they become a valid target for attackers.

The third category includes another type of data attacks,
where an adversary exploits a vulnerability to trick the ker-
nel to directly change one or more critical data ﬁelds inside
its own memory. A real world example of these attacks is
towelroot [27], which uses a pointer manipulation vulnerabil-
ity to modify the data ﬁeld that deﬁnes process credentials
leading to privilege escalation. Attackers may also exploit
these vulnerabilities to modify control ﬂow data, such as
function pointers or return addresses. In this case, these at-
tacks can escalate to hijack the kernel control ﬂow, such as

return oriented attacks [28,51]. Unfortunately, these attacks
cannot be currently prevented or detected by TZ-RKP.

Although TZ-RKP cannot prevent the third category of
kernel attacks, this does not undermine its security value
for two main reasons. First, TZ-RKP’s active monitoring
and memory protection does not rely on the target kernel.
Hence, these attacks cannot bypass TZ-RKP’s control of
system critical functions, even if they compromise the ker-
nel control ﬂow.
In other words, attackers cannot change
the state of the MMU, memory translation tables or even
switch among diﬀerent processes without passing through
TZ-RKP. These forced hooking points provide a secure base
for anomaly detection mechanisms, such as [33], to detect
the presence of these vulnerabilities.

Second, many of the vulnerabilities found in the kernel al-
low limited access to kernel data, which sometimes prevent
attackers from accessing certain critical memory areas, such
as the kernel stack. This limited access would prevent kernel
data attacks from doing eﬀective damage through control
ﬂow hijacking. For example, a theoretical return-oriented
attack would require a complete manipulation of the ker-
nel stack to allow the attack code to jump to multiple code
gadgets. Such manipulation cannot be achieved if the vul-
nerability only allows the attack to corrupt a single return
address or a limited range of the kernel memory. In these
cases, TZ-RKP would prevent the damage that can result
from having these vulnerabilities exploited by attacks of the
ﬁrst or the second categories.
Assumptions: TZ-RKP assumes an ARM-based architec-
ture that implements the TrustZone extensions. It also as-
sumes that it runs as a part of the secure world, while the
target OS runs in the normal world. TZ-RKP also assumes
that the whole system is loaded securely, including both the
secure and the normal worlds. This process is straightfor-
ward using trusted boot. Intuitively, trusted boot only guar-
antees the integrity of the kernel during the boot-up process.
It cannot guarantee the integrity of the kernel after the sys-
tem runs and starts to interact with potential attackers.
TZ-RKP also assumes that the kernel can function prop-
erly using W(cid:8)X memory mapping (i.e., using mutually ex-
clusive memory pages for data and code). Finally, TZ-RKP
assumes that the hardware platform implements the Priv-
ileged eXecute Never (PXN) memory access permission as
deﬁned by the ARM speciﬁcations.

3. BACKGROUND

TZ-RKP relies on some hardware features of the ARM ar-
chitecture. These features include ﬁxed length instructions,
control of privileged mode memory, and the TrustZone se-
curity extension.

ARMv7 uses memory aligned instructions that have a
ﬁxed length of either 16 bits for the Thumb mode or 32 bits
for the ARM mode. This is in contrast to other architectures
like x86, where the instructions can be located at any oﬀset
in memory. Having a ﬁxed-length aligned instruction set al-
lows TZ-RKP to restrict the presence of certain instructions
within the normal world kernel.

ARM provides two code execution modes; privileged and
unprivileged. It provides control ﬂags that prevent certain
virtual memory pages from executing privileged code. It also
provides control ﬂags to mark certain memory areas, such as
the kernel memory, as privileged. It prevents unprivileged
code from accessing privileged memory. Intuitively, the un-

924.1 Control Instruction Emulation

Control instructions change the system state, and hence
may impact the system security. Thus, TZ-RKP implements
a novel technique to deprive the target kernel from the abil-
ity to execute certain instructions so that it is forced to route
the execution to TZ-RKP to emulate these instruction.

In the widely used ARMv7 32-bit architecture, control
instructions are done by writing to certain coprocessor reg-
ister, which can only be done by the two privileged ARM
instructions LDC and MCR. In this section, we use this particu-
lar architecture to demonstrate our technique. Nevertheless,
the same technique works on the 64-bit ARMv8 architecture
that uses direct control instructions, rather than coprocessor
register writes.

To achieve control instruction emulation, TZ-RKP over-
comes a key TrustZone limitation; the secure world is not
capable of preventing and intercepting control instruction
execution in the the normal world. It is worth noting that
this limitation is not speciﬁc to TrustZone. Although hyper-
visor extensions usually allow for event interception, isolated
execution environments do not usually provide this feature.
The solution is to remove certain control instruction from
the normal world and replace them by hooks so that they
can be emulated by TZ-RKP. Nevertheless, providing a non-
bypassable guarantee for this solution is not straightforward.
Our technique to make this solution secure is based on
three distinct hardware features. First, instructions that
change the system state are always privileged and cannot
be executed in the unprivileged execution mode. Second,
ARM virtual memory system allows restricting certain mem-
ory ranges from executing privileged instructions using the
Privileged eXecute Never (PXN) access restriction. There-
fore, privileged instructions, such as LDC an MCR, are only
allowed to be fetched, i.e., executed, from certain memory
areas. Finally, the ARM instruction set requires instructions
to incorporate both the opcode and operands in either 16-bit
THUMB mode or 32-bit ARM mode aligned memory.

Based on these properties, the technique to solve this

problem can be summarized in the following principle:

Given that (1) only certain memory regions are
mapped with the permission to execute privi-
leged instructions, (2) the same memory regions
are mapped with read-only permission and (3)
the same memory regions do not contain a sin-
gle memory word that matches the encoding of a
particular instruction, then it will be absolutely
impossible for the normal world to execute this
instruction, because it can neither ﬁnd this in-
struction in its privileged executable memory nor
it can execute it from the rest of the memory.

All three conditions are achieved by TZ-RKP. It enforces
a strict policy that the whole normal world memory, ex-
cept the memory range that hosts the veriﬁed kernel code,
is mapped with the PXN ﬂag set. It also enforces a policy
that the target kernel is mapped read-only. The target OS
memory layout is shown in Figure 2. TZ-RKP uses its con-
trol of the normal world memory protection, which will be
discussed in Section 4.3, to enforce these policies.

The third condition is satisﬁed by instrumenting the ker-
nel to replace all the LDC and MCR instructions that target
speciﬁc control registers with SMC instructions. The instru-
mentation can be either done by code modiﬁcation or binary

Figure 1: TZ-RKP Basic Components

privileged mode is used to run the user process, while the
privileged mode is used to run the kernel. TZ-RKP relies
on this access control mechanism to enforce its protection.
TrustZone is a security extension deﬁned by ARM. The
basic idea is to logically partition the computing platform
into two execution domains: the normal world and the se-
cure world. To facilitate context switch between the two
worlds, a special processor mode, known as the monitor
mode, is introduced. The monitor mode, which is part of
the secure world, is the only entry point from normal world
to secure world. Execution jumps from the normal world
to the secure world by explicitly issuing the Secure Monitor
Call (SMC) instruction. The secure world can access the full
range of the physical memory and all hardware peripher-
als. It can also emulate the execution of normal world con-
trol instruction. On the other hand, some physical memory
ranges and hardware peripherals can be restricted to be only
accessed by the secure world. Hence, these secure physical
memory and hardware peripherals enjoy full hardware-based
protections from attacks that can potentially compromise
the normal world.

4. TZ-RKP DESIGN

TZ-RKP can be implemented on any ARM processor that
supports TrustZone. The design presented here solely re-
lies on the architectural speciﬁcations deﬁned by ARM [10].
TZ-RKP can be customized to monitor any target OS. The
current implementation is customized to target Android’s
Linux Kernel. We use this implementation as an example
to clarify our approach.

Figure 1 shows the system architecture. TZ-RKP runs in
the TrustZone secure world, while the target kernel runs in
the normal world. The target kernel is forced to request TZ-
RKP to perform two operations on its behalf: (1) emulating
control instructions that change the system state and (2)
updating the target OS memory translation tables.

In the following, we present the control instruction em-
ulation. Then, we present how TZ-RKP traps updates to
memory translation tables. Afterwards, we discuss how TZ-
RKP uses these two features to achieve the required memory
protection. Next, we present kernel data double mapping
prevention. Finally, we summarize the security guarantees
provided by TZ-RKP.

934.2 Trapping Translation Table Updates

TZ-RKP traps all updates to the memory translation ta-
bles so that it can always keep an up-to-date information
about two key aspects of the memory layout: (1) the virtual-
to-physical mapping of the normal world memory and (2)
the access permission of each memory page.

The main challenge is the absence of a hardware-based
control or a single entry point to update the translation ta-
bles. Translation tables can be anywhere in the physical
memory. Therefore, translation table updates are normal
memory writes that can only be controlled by memory ac-
cess permissions.

The kernel creates a new set of translation tables for each
process it creates. When a process is scheduled, it modiﬁes
the TTBR register to point to the translation tables corre-
sponding to that process. The translation tables can only be
accessed by the kernel. Hence, they should be only mapped
within the kernel virtual memory range. They should never
be mapped or accessed by a user process. Figure 2 shows
the typical virtual memory layout of the Linux kernel.

The technique to intercept translation table updates starts
by depriving the kernel from its own ability to do these up-
dates. Hence, it is forced to request their modiﬁcations from
TZ-RKP in the secure world.

This is achieved by modifying the access permissions of
the kernel virtual address space so that the memory host-
ing translation tables become read-only memory. As dis-
cussed in Section 4.1, TZ-RKP intercepts writes to the TTBR
registers. Hence, it detects the physical address of transla-
tion tables, before they are actually used. At that point,
TZ-RKP modiﬁes the kernel address space mapping to en-
sure that these new translation tables are mapped read-only.
This process starts when the kernel boots up and is repeated
with every new process that starts in the normal world.

Now that all translation tables are non-writable by the
kernel, they are only modiﬁable by the secure world. When-
ever the kernel needs to modify the translation tables, it
sends a request to TZ-RKP. This can be done by either one
of two ways. First, the kernel code can be modiﬁed to call
the SMC command instead of writing the translation tables.
TZ-RKP would intercept the request and carry it over once
it veriﬁes the new translation table entries. Second, the ker-
nel can be instrumented so that the page fault handler is
replaced by an SMC instruction. Hence, page faults will trap
into TZ-RKP, which in turn emulate the ones that originate
from writing translation table entries. The second method
is described in more detail in Section 5.2.
Security Guarantee: Trapping updates to translation ta-
bles is non-bypassable if two requirements are met: 1) the
kernel is not able to hide its translation tables from TZ-
RKP, and 2) the kernel is not able to modify its translation
tables without TZ-RKP’s knowledge.

As long as control instruction emulation is non-bypass-
able, the ﬁrst requirement will be satisﬁed because the ker-
nel cannot use its translation tables without updating the
TTBR hardware registers. The second requirement is satis-
ﬁed through TZ-RKP’s memory protection feature, which
will be discussed in detail in Section 4.3.

Trapping translation table updates does not require trust
in the kernel even if the implementation relies on the ker-
nel to explicitly request the translation table updates from
TZ-RKP. Since the translation tables are mapped read-only
and cannot be modiﬁed by the kernel, there is no way for

Figure 2: Target OS Virtual Memory Layout

rewriting. When TZ-RKP receives these SMC calls from the
kernel, it emulates the required instruction by writing to the
target control coprocessor registers from the secure side.

Satisfying all three conditions leads to the deﬁnitive and
unique situation that the target kernel cannot execute cer-
tain privileged instructions. Hence, it loses control over cer-
tain critical functions. In our case, we select the instructions
that manage the normal world MMU and deﬁne the location
of exception handlers. Nevertheless, the same technique can
be extended to monitor other kernel functions.
Security Guarantee: Control instruction emulation is both
secure and does not involve complex implementation details.
ARM enforces alignment and ﬁxed size instructions that
include both the opcode and the operands within the same
word. Hence, each instruction can be represented by a
unique set of words. For example, the layout of the MCR
instruction word incorporates all the parameters that deﬁne
the target register, which are the coprocessor number the
crn, crm, op1 and op2. Hence, it is easy to form a tem-
plate of all MCR and LDC instructions that write to a speciﬁc
coprocessor register. TZ-RKP examines every word of the
kernel executable binary and replaces all words that match
this template with the SMC instruction. This template will
not match any other word within the kernel executable code,
which eliminates any side eﬀects of this operation.

This technique is secure against control ﬂow hijacking,
including return oriented attacks. Since ARM instructions
take no operand to deﬁne the target register, no other word
can be used to replace the write to the intended register even
if an attacker completely controls the ﬂow of the kernel.

For this technique to be secure, we have to emulate all the
relevant control instructions. On ARMv7, four basic sets of
instructions need to be emulated. First, system control reg-
isters, such as the SCTLR, that can disable the MMU, change
the location of the exception handlers or disable the enforce-
ment of instruction alignment. Second, the translation table
base registers that deﬁne the base address for translation ta-
ble walks. Third, the domain access control registers, such
as the DACR, that can disable all the page table protection
for select memory ranges. Fourth, the cache maintenance
registers, such as NMRR and PRRR, which may need to be
monitored to avoid attacks based on cache poisoning.

94memory page against the stored state to verify that there is
no violation to the memory protection. The state of physical
frames is stored in an array called the physmap. Each entry
of the array corresponds to a 4KB physical memory page.
Each entry has some status bits and a counter to indicate
how many virtual page mappings each physical page has.

The physmap decides which physical pages should be pro-
tected. TZ-RKP marks physical pages that are currently
used by kernel code or translation tables as protected. Any
request to create a writable mapping of these pages is re-
jected. TZ-RKP also prevents this scenario from happening
in the reverse direction. If a page is mapped writable to a
user process, TZ-RKP will record this event in the physmap.
If TZ-RKP receives a request to use the same page as a
translation table, then it will reject the request knowing
that this translation table can be modiﬁed by the user pro-
cess that has the previous writable mapping. TZ-RKP also
uses a counter to follow the status of pages with multiple
mappings. The counters are incremented and decrements as
pages get mapped and unmapped.
Security Guarantee: Memory protection relies on the fol-
lowing principle: As long as all virtual-to-physical mappings
of a physical memory page only allow for the read-only per-
mission, it will be impossible for this page to be modiﬁed by
the normal world.

The memory pages protected by TZ-RKP will have only
one virtual address mapping, which is the lowmem. TZ-RKP
modiﬁes the lowmem mapping of protected pages to be read-
only. Hence, neither kernel code nor translation tables would
be writable by the normal world even if the kernel is com-
pletely compromised.

As mentioned in Section 4.2, the memory protection guar-
antees that updates to translation tables are trapped by TZ-
RKP. Using the physmap, TZ-RKP inspects the virtual-to-
physical mapping created by each translation table update
or decides to reject the update, if it violates the security
principal stated above.

4.4 Kernel Data Double Mapping Prevention
Kernel data structures are critical to the system security.
Maliciously modifying kernel data can lead to wide range
of damage from privilege escalation to process hiding [14].
Since TZ-RKP completely protects the kernel code base and
prevents “return-to-user” attacks, there are only two possible
methods to exploit kernel data. The ﬁrst is through double
mapping the memory hosting kernel data into the address
space of the malicious process. The second is to alter the
kernel control ﬂow so that it maliciously modiﬁes its own
data (e.g., using pointer manipulation or overﬂow [4]).

In this paper, we focus on defeating the ﬁrst class of at-
tacks. Double mapping is a real threat to the kernel. For
instance, the Motochopper [1] android exploit used an inte-
ger overﬂow to trick the kernel into mapping a huge range
of the physical memory into the address space of the attack-
ing process. We leave the second class of kernel attacks to
future work.

To prevent malicious double mapping of the kernel data,
TZ-RKP should ensure that physical memory pages hosting
this data are not mapped to user space processes. They can
only be mapped as privileged pages that cannot be accessed
by the user space. TZ-RKP enforces this policy using its
control of the guest translation table. TZ-RKP rejects all
translation table entries that map kernel data to user space.

Figure 3: Double mapping of a physical memory
area to both user space and kernel space

a compromised kernel to skip these hooks. Moreover, the
new values of the translation table entries to be written
is inspected by TZ-RKP so verify that they does not vio-
late the security guarantees. A compromised kernel sending
malicious requests to update the translation tables will be
simply blocked by TZ-RKP.
4.3 Memory Protection

The main objective of memory protection is to guaran-
tee that both control instruction emulation and trapping
translation table updates are non-bypassable. The former
requires preventing unauthorized writes to the kernel code,
while the later requires preventing unauthorized writes to
translation tables.

The main challenge of memory protection lies in double
mapping. Double mapping happens when the same physical
memory is mapped to multiple virtual memory addresses.
An example of double mapping is shown in Figure 3. To
avoid bypassing the memory protection using double map-
ping, TZ-RKP has to enforce the protection on every vir-
tual mapping of the protected memory. This is speciﬁcally
hard for dynamic memory ranges, such as translation tables,
which can be created and discarded anywhere in the system
memory and at anytime. A potentially malicious writable
mapping can be created either after or before a certain mem-
ory region is used to host translation tables.

To achieve memory protection, TZ-RKP separates the tar-
get OS virtual memory into three distinct ranges: the ker-
nel code, user memory and the kernel lowmem. The last is
a term used to describe the physical memory that is con-
stantly mapped by the kernel. The kernel allocates memory
from the lowmem when it needs to create new objects such
as translation tables.

The kernel code is the only memory range that has the
privileged execution permission and it is mapped read-only.
TZ-RKP enforces the strict policy that user space virtual
memory ranges are mapped as Privileged eXecute Never
(PXN). The kernel lowmem is mapped as non-executable
privileged memory. Hence, it cannot be accessed by unpriv-
ileged code (i.e., user processes). Whenever TZ-RKP de-
cides to protect a certain memory region (e.g., a translation
table), it modiﬁes its lowmem mapping to be read-only.

To protect against double mapping, TZ-RKP records the
state of every page of the physical memory. Whenever a
new virtual-to-physical mapping is about to be created, TZ-
RKP checks the new access permission given to the physical

95Nevertheless, there is a big challenge that needs to be
solved ﬁrst. The kernel data is scattered over the physi-
cal memory among other memory areas that belong to the
user processes, which need to be double mapped so that the
system functions correctly.

To solve this challenge, TZ-RKP relies on the target ker-
nel to inform it about the location of its critical data. Mod-
ern kernels use allocation techniques, such as slub in Linux,
to aggregate data objects together so that fragmentation is
minimized. TZ-RKP embeds hooks inside the kernel code
so that it gets informed whenever a new memory area is go-
ing to be allocated to the kernel. It then marks this memory
area in the physmap so that it prevents it from being double
mapped to writable memory anywhere in the system.
Security Guarantee: This protection is eﬀective against
attacks that use double mapping to exploit kernel data. In
our experimental evaluation, implementing this protection
stopped the Motochopper kernel exploit.

As discussed in Section 2, this protection has a diﬀerent
threat model than the other techniques. While all other
TZ-RKP techniques do not require trust in the kernel, data
double mapping prevention requires the kernel to inform TZ-
RKP about the allocated data memory areas. This depen-
dency is imminent because the allocation can happen any-
time and anywhere in the system memory.

This dependency does not weaken the protection. The
kernel is assumed to be secure when it sends the informa-
tion to TZ-RKP because this happens before the data pages
are allocated. TZ-RKP prevents the data from being modi-
ﬁed, except by the kernel itself. Thus, it prevents this class
of attacks from exploiting the kernel and sending falsiﬁed
information about memory allocations.

Indeed, this interface is not safe against the second class
of attacks, e.g., return oriented attacks. These attacks can
directly modify the kernel data despite the presence of our
data double mapping protection, hence they are out of the
scope of this paper.

4.5 Security Analysis

Throughout section 4, we discussed the security guaran-
tee provided by each TZ-RKP feature. These guarantees are
interdependent and compliment each other. In this section,
we summarize these guarantees by discussing how they de-
feat security threats. We categorize security threats by the
attack surface they target.
Kernel Attack Surface: The ﬁrst threat to the kernel
is to run a modiﬁed binary during system load-time. As
mentioned in Section 2, TZ-RKP assumes the presence of
trusted boot to defeat that threat.

Trusted boot is also critical to TZ-RKP. It is the only
guarantee that the loaded kernel binary is instrumented to
remove control instructions, as mentioned in Section 4.1.
Once that binary is loaded, the memory protection will guar-
antee that it cannot be modiﬁed.

The security guarantees provided by both control instruc-
tion emulation and memory protection are non-bypassable
because there is nowhere in the normal world that can ex-
ecute the emulated instructions or modify the translation
tables. These security guarantees are also interdependent.
The control instruction emulation relies on the memory pro-
tection to guarantee that the kernel will not be modiﬁed,
while the memory protection relies on the control instruc-
tion emulation to detect the presence of new translation ta-

ble. Hence, TZ-RKP has to be implemented as a complete
integrated solution to provide proper protection. Neverthe-
less, neither of these two security guarantees require trust
in the kernel code during system runtime.

Modern kernels usually support extending their code using
loadable modules. These modules are not veriﬁed by trusted
boot because they are loaded after the system starts. TZ-
RKP supports these kernel code extensions as long as they
are known to the system and they are subject to instrumen-
tation to remove control instructions from their binaries. We
rely on an orthogonal system to verify the binaries of load-
able kernel modules before they are loaded into memory.
This system restricts the modules to be loaded a predeﬁned
set of modules. This requirement does not violate any of the
common use cases of Android.
Return-to-user Attacks: Another threat that aims at hi-
jacking privileged execution is return-to-user attacks, where
a kernel exploit is used to return the execution to user space
in the privileged mode. User space code will be then allowed
to execute privileged instructions and access privileged data.
As discussed in [32], these attacks can have a huge impact
on the system security. Moreover, they pose a threat to
TZ-RKP because they potentially allow the unveriﬁed user
space code to execute control instructions, which breaks the
non-bypassable monitoring guarantee.

As mentioned in Section 4.3, TZ-RKP stops these at-
tacks using the PXN access restriction of user space mem-
ory. Hence, the processor prohibits executing code from this
region while running in the privileged mode. Another hard-
ware mechanism that can also be used is the Unprivileged
Write Permission implies PL1 Execute Never (UWXN) pro-
vided by ARM. UWXN prevents user pages from running
privileged code, which can be used to provide additional se-
curity restrictions besides the PXN ﬂag.
Kernel Data Attacks: As mentioned in Section 4.4, TZ-
RKP prevents direct access of kernel data from user space.
User space will have the PXN access restriction so it can-
not escalate its privilege to access the privileged kernel data.
Moreover, TZ-RKP will prevent kernel data from being double-
mapped to user space.

For this particular security guarantee, TZ-RKP uses the
kernel to get information about the memory layout. This
is acceptable because this type of attacks can only originate
from the user space. The philosophy behind using TZ-RKP
to provide this protection is to avoid vulnerabilities that
usually exist in the huge kernel code base. Such vulnerabil-
ities have been previously exploited [1] to give unauthorized
access to kernel data.
DMA Attacks: Hardware peripherals are sometimes al-
lowed to bypass the MMU and do a Direct Memory Access
(DMA) to the physical memory. Attackers may use an ex-
ploit to trick the kernel into allowing these devices to directly
access its memory.

DMA attacks are not a threat to TZ-RKP. The secure
world side of TZ-RKP is inherently secure against DMA us-
ing the TrustZone protection provided to the secure world.
DMA attacks that aim at modifying the kernel binary or
the translation tables can be stopped by TZ-RKP using in-
struction emulation. TZ-RKP needs to further instrument
the kernel so that the kernel cannot manage the DMA con-
troller. The exact implementation will diﬀer according to
the used hardware platform. For instance, if the DMA con-
troller is managed by a memory mapped register, then TZ-

96RKP would make this memory read-only to enforce the in-
terception of DMA mapping. Finally, TZ-RKP would ex-
amine these mapping to conﬁrm that none of the hardware
devices is allowed access to critical system memory.
Control Flow Attacks: As discussed in Section 2, TZ-RKP
cannot prevent all types of kernel data attacks. Some type
of kernel data attacks can cause the kernel control ﬂow to
change, which may lead to malicious behavior without the
change of the kernel code. One example is return oriented
attacks [16, 28, 51]. Another example is using a kernel inte-
ger overﬂow or pointer manipulation to trick the kernel code
into maliciously modifying its own memory, e.g., [4]. Recent
research shows that these attacks are hard to prevent [26,54].
These attacks are considered out of the scope of this paper.
Nevertheless, TZ-RKP guarantees that these attacks will
not subvert its monitoring framework or load new unautho-
rized privileged code. Completely eliminating these attacks
requires orthogonal techniques, such as [17, 19, 21, 57].
Attacks Against TrustZone: TZ-RKP is hosted by the
TrustZone secure world, hence all its security properties,
including the non-bypassable monitoring, are conditional to
the security of TrustZone. A recent publication [46] showed
that one of the TrustZone interfaces can be exploited by an
integer overﬂow vulnerability.

Despite this speciﬁc attack, the TrustZone secure world is
still the most secure software layer in the whole system be-
cause it enjoys hardware protection to its memory from nor-
mal world software. Moreover, the secure world has a small
controlled interface to the target kernel, which eﬀectively
reduces the TrustZone attack surface. This is evident by
the fact that exploits that break the TrustZone protection,
such as [46], are seldom compared to those that break the
kernel, which has a much bigger attack surface and trusted
computing base.

5.

IMPLEMENTATION

TZ-RKP is implemented and deployed on recent Samsung
smartphones and tablets, including Samsung Galaxy Note 3
and Samsung Galaxy S5. In this section, we present the im-
plementation of TZ-RKP on Samsung Galaxy Note 3, which
is equipped with Snapdragon quad-core MSM8974 processor
from Qualcomm. The target OS is Android Jelly Bean ver-
sion 4.3, which runs on Linux kernel version 3.4. The kernel
uses two-level short descriptor translation tables format as
speciﬁed by ARM. In the following, we present more details
about our implementation.
5.1 System Organization

In our implementation, the target kernel runs in the nor-
mal world, while the TrustZone secure world is controlled by
a propitiatory Trusted Execution Environment (TEE) that
hosts TZ-RKP and other security services. There are three
privileged levels of execution in the secure world. The high-
est is PL2, which hosts the monitor mode that controls the
entry point between the normal world and the secure world.
The other two are PL1 and PL0, who respectively host the
TEE’s supervisor code and trusted applications.

Only signed and veriﬁed applications are allowed to run
in TrustZone. These applications, which are carefully in-
spected for security, have minimal interface to the normal
world. Hence, the attack surface of the secure world as a
whole is much smaller than that of the normal world kernel.
TZ-RKP is also isolated from other TrustZone applications

because it runs in the monitor mode, which is the most
secure and privileged level of the secure world and conse-
quently the whole system.

Running TZ-RKP in the monitor mode allows it to read
and write control coprocessor registers of the normal world,
which is a required feature for critical instruction emulation.
Moreover, running TZ-RKP in the monitor mode reduces
the performance overhead by avoiding mode switches inside
the secure world.

5.2 Kernel Instrumentation

In the current implementation, we directly modify the ker-
nel’s source code to place hooks upon writing to critical co-
processor registers and upon modifying translation tables.
These hooks execute an SMC instruction to jump to the se-
cure world. To diﬀerentiate the SMC instructions called by
TZ-RKP’s kernel hooks from those requesting other Trust-
Zone services, we use a command ID that is placed in a
general purpose register upon the SMC call. Once the ex-
ecution jumps to the monitor mode, TZ-RKP checks that
register value to determine the call type.

As discussed in Section 4, using these hooks does not im-
ply that TZ-RKP security relies on the target kernel because
the enforcement does not allow the kernel to either execute
critical instructions or to modify memory translation tables
without going through TZ-RKP. Moreover, the hook inter-
faces cannot be exploited by a compromised kernel (e.g.,
using a man-in-the-middle type of attack) because TZ-RKP
inspects the values passed by the kernel and conﬁrms they
do not have an impact on the system security before emu-
lating the requested operation.

In addition to code instrumentation, we also use a binary
analysis tool to conﬁrm that all critical control coprocessor
writes are removed from the target kernel binary and re-
placed by TZ-RKP hooks. As discussed in Section 4.1, this
is a basic requirement for TZ-RKP.

Another method to implement TZ-RKP is to instrument
the kernel binary by inserting an SMC instruction in place of
the page fault exception handler. Hence, every page fault
would trap into TZ-RKP, which in turn emulates the ones
that result from trying to write the read-only translation
table entries. Intuitively, this method is more suitable if the
kernel code is not available.

We implemented a proof-of-concept system using binary
instrumentation.
In that prototype, the protection is ini-
tialized by changing the mapping of the ﬁrst set of transla-
tion tables to make them read-only in the same way as the
original system, which will be discussed in more details in
Section 5.3.

After the system is initialized, the kernel would attempt
to normally modify these translation tables, which causes a
page fault that jumps into the secure world to be trapped by
TZ-RKP. In turn, TZ-RKP inspects the DFAR register that
stores the virtual address that caused the page fault. If this
address matches one of the protected memory translation ta-
bles, TZ-RKP ﬁrst inspects the value to be written to check
that it conforms with its security guarantees. Afterwards, it
updates the target translation table entry to the new value
before returning to the normal world.

To ﬁnd the value to be written to the memory transla-
tion tables, TZ-RKP decodes the instruction that caused
the fault to identify the general purpose register that holds
that value. The instruction address is stored in the banked

97link register (LR) of the normal world’s abort mode, which
is the execution mode that handles page faults in ARMv7.
Binary instrumenting the kernel faces two challenges that
are related to the system performance: 1) There is an extra
mode switch that occurs as a result of the data abort and 2)
it is hard to modify the kernel behavior to achieve non func-
tional requirements, such as enhancing the system perfor-
mance, without modifying the kernel’s source code. These
problems can be solved with more research eﬀort. The main
purpose of this prototype is to show that it is feasible to
implement TZ-RKP on systems with closed source code.

5.3 Initialization and Basic Operations

Secure system initialization is an essential requirement
of TZ-RKP, which needs a guarantee that only the instru-
mented kernel can be loaded into the normal world. Our
implementation achieves this property using trusted boot,
which is a part of the TIMA services suite that runs on
most recent Samsung mobile devices. The trust chain starts
from the boot loader, which veriﬁes the signature of the
kernel binary before loading it into memory. Hence, only
known kernel binaries are allowed to run on these devices.
Indeed, the hardware vendor only signs kernel binaries that
are instrumented to comply with TZ-RKP’s requirements.
After the instrumented kernel is loaded, it has to trap to
TZ-RKP to initialize its MMU. Given that the loaded kernel
is deprived from the privilege of setting its own TTBR register,
then it has to jump to TZ-RKP to emulate this operation.
Upon the ﬁrst write to the TTBR register, TZ-RKP exam-
ines every entry of the translation tables to verify that the
corresponding address translation and access permissions do
not violate its security guarantees. It veriﬁes that that all
translation table entries that map privileged code page are
mapped read-only. It also veriﬁes that all user space mem-
ory ranges have the PXN ﬂag set and that the translation
tables themselves are mapped read-only, so that they can-
not be modiﬁed by the target kernel. Finally, TZ-RKP up-
dates its own data structures to reﬂect the current status
of the normal world. For instance, it updates the physmap
to mark the physical memory pages that host the transla-
tion tables as protected, so they are never allowed to have
another writable mapping.

These operations are repeated when the TTBR register is
updated to point to new translation tables, which occurs
whenever a new process is spawned. These steps are also
repeated when the translation tables are updated.
If the
update is in the L1 translation table, it implies that an L2
translation table is either being created or deleted. In both
cases, TZ-RKP checks its policies, updates the physmap and
changes the memory protection accordingly.

TZ-RKP removes the protection from translation tables
after they are discarded. The kernel notiﬁes TZ-RKP when
a process is killed and a set of translation tables are no longer
in use. This operation does not aﬀect the security of TZ-
RKP because it checks that the translation tables are not
currently being used (i.e., none of the processor cores TTBR
registers point to these tables). Hence, the protection is
never removed from an actively running process. Even if an
attacker removes the protection from the translation tables
of an active process, the translation tables will be protected
again once the TTBR register points to them and before they
are actually used.

5.4 Performance Enhancement

TZ-RKP is already designed to optimize the execution
time of a single trapped event. However, a better perfor-
mance is achievable when the number of monitored events
is reduced.
In our implementation, which targets a ker-
nel that uses two-level translation table, evaluation results
showed that the highest number of trapped events were up-
dates to the second level (L2) of the translation tables, which
frequently happens when new processes and apps are loaded.
TZ-RKP aims at reducing the performance overhead re-
sulting from these frequent traps. It relies on the fact that
the majority of translation table updates follow a certain
predictable pattern. The motivation is to leverage this pat-
tern to reduce the number of context switches and therefore
improve the performance.

This predictable pattern happens when multiple entries
of L2 translation tables are modiﬁed together to map or
unmap contiguous virtual memory ranges. In this case, the
kernel copies all the entries to be updated along with their
new values into a buﬀer and passes this buﬀer to TZ-RKP
so they can be written together using a single switch to the
TrustZone secure world. We call this operation grouping of
translation tables updates.

Another predictable pattern happens when a new process
is forked, because the kernel copies all the exiting transla-
tion table entries of the parent process to the translation
tables of the newly forked process. We avoid causing unnec-
essary overhead in this event by allowing the kernel to ﬁll the
translation tables directly without trapping to TZ-RKP. Af-
terwards, TZ-RKP would start protecting these new trans-
lation tables, once the process is scheduled into the system
(i.e, once they are pointed to by the ttbr register).

6. EXPERIMENTAL EVALUATION

Table 1: Android attacks

TZ-RKP passed through rigorous testing and evaluation
that includes both validating the eﬀectiveness of its protec-
tion and measuring its impact on system performance and
power consumption.
Eﬀectiveness
Against At-
tacks: We
tested TZ-RKP
using the real
world exploits
shown in Ta-
ble 1. First,
we tested two Android malware: Motochopper and vroot.
The former was stopped by the prevention of the kernel data
double mapping, as explained in Section 4.4. The later was
stopped by the prevention of return-to-user attacks using
the PXN access restriction, as explained in Section 4.3

Vulnerability
Attack
Data double mapping
Motochopper
return-to-user
vroot
Write kernel memory
/dev/mem
CVE-2013-6432 Write kernel memory

We also wrote our own attack code that exploits two other
real-world Linux vulnerabilities: 1) writing to the physical
memory using the /dev/mem interface [37], and 2) a pointer
manipulation vulnerability that exists in the ping_recvmsg
kernel function, which is reported as CVE-2013-6432 [4]. Ex-
ploiting this vulnerability allows a user process to trick the
kernel into maliciously modifying its own memory.

We use these exploits to request the kernel to write its
own code, translation tables and parts of its data. Writing
to kernel code failed because it is mapped read-only. We
tried writing to the translation tables to change the kernel

98memory access permission, which also failed because they
are also mapped read-only by TZ-RKP. We also tried to
use the TZ-RKP interfaces to send a request to write the
translation tables, however it got rejected because the val-
ues did not comply with TZ-RKP’s policies. Nevertheless,
we succeeded to write the kernel data using both exploits
because the kernel data double mapping prevention was not
eﬀective against these attacks. When exploited by the user
space, the kernel is doing the write to its own memory us-
ing the copy_from_user function without the need of double
mapping. As mentioned in Sections 4.4 and 4.5, attacks that
trick the kernel control ﬂow to maliciously modifying its own
data are out of scope of that protection.
Performance Overhead: Performance is critical to mo-
bile devices due to their limited resources. Indeed, TZ-RKP
adds some performance overhead because it adds more pro-
cessing time to the intercepted events. The execution path
of an event intercepted by TZ-RKP includes a switch to the
secure world, an emulation of the event, and policy checking.
The main anticipated source of overhead is the time required
to enter and exit the TrustZone secure world. Other opera-
tions are not anticipated to cause big overhead because they
mainly rely on a single lookup of the physmap array.

As mentioned previously, TZ-RKP is deployed on mul-
tiple mobile phones and tablets. Each of them has been
carefully evaluated for performance overhead. For the sake
of brevity, we present the performance evaluation on only
one of these devices, which is a smart phone equipped with
the Qualcomm Snapdragon msm8974 quad-core processor.
The target OS is Jelly Bean Android v4.3; kernel v3.4.

We perform a set of experiments to evaluate the perfor-
mance of TZ-RKP. To measure the performance overhead
introduced by TZ-RKP, we measure and compare the per-
formance of an original system against a TZ-RKP system.
Both the original and the TZ-RKP systems are special en-
gineering builds that only diﬀer in the presence of the TZ-
RKP protection. Hence, the performance measurement re-
sults presented in this paper are diﬀerent from those of the
commercial products, which are usually subject to multi-
ple cycles of performance enhancement and tuning before
they are commercially released. The TZ-RKP system used
in these experiments is our ﬁrst development version, which
includes all the performance enhancements presented in Sec-
tion 5.4. It is worth noting that it might have been subject
to slight changes to enhance the performance or change its
properties before it was commercially released. In the rest
of this section, we present the result of these experiments.
Overhead of Switching to the Secure World: Our ﬁrst
experiment is to measure the execution time needed for a full
context switching to and from the isolated environment. We
used ARM cycle count register (CCNT) to measure the num-
ber of cycles of a full round trip from the normal world to
the secure world. The switching time on our target platform
was around 2000 cycles.

We also tested multiple other ARM processors and we
found out that the switching time varies between several
hundred to several thousand cycles. This variation is mainly
caused by the way TrustZone memory protection is imple-
mented on each processor. The numbers of cycles is also de-
pendent on the secure world software implementation, such
as the way caching is conﬁgured on the secure world.

Since TZ-RKP requires frequent switching to the secure
world, the variation of the number of cycles required for a

Table 2: Benchmark results *

Benchmark

Original

TZRKP

Overhead

Quadrant
Antutu
GL Frame
GL FPS
Linpack
Single Thread
Multi Thread
RL
Vellamo
HTML 5
Metal
CF-Bench
Smartbench
Geekbench

16406.17
34828.67
4171.83
43.42

16171.39
33919.00
4165.50
43.33

438.19
1052.31
12.55

434.47
1041.39
12.74

2159.33
1224.00
34855.33
7178.00
4066.33

2089.33
1130.33
32221.33
7081.67
3789.00

1.43%
2.61%
0.39%
0.19%

0.85%
1.43%
1.51%

3.24%
7.65%
7.55%
1.40%
6.80%

* The presented performance measurement results
are diﬀerent from commercial products.

single switch would greatly impact the overall system perfor-
mance. Hence, we recommend that TZ-RKP’s performance
overhead should be carefully examined before it is imple-
mented in a production environment.
Benchmark Performance Comparison: Our second ex-
periment is to use benchmarking tools to evaluate the per-
formance overhead of our TZ-RKP implementation.

We used multiple benchmark tools to compare the perfor-
mance of TZ-RKP with the original system. The averaged
results are shown in table 2. When tested using nine diﬀer-
ent benchmarking tools, TZ-RKP shows a low overhead that
ranges between 0.19% to 7.65%. The result is expected be-
cause these benchmarks incorporate a thorough evaluation
of the overall system performance, which includes CPU, I/O,
and memory. TZ-RKP adds overhead to a small portion of
these operation. In particular, operations related to mem-
ory allocation that involve translation table updates, which
are intercepted by TZ-RKP.
App Load Time Delay: Our third experiment is to mea-
sure the impact of TZ-RKP on the load time of Android
apps. App load time is a critical aspect of the performance
of smart phones and tablets because it impacts user expe-
rience. We also anticipated that loading an app would be
impacted by TZ-RKP because of the high number of mem-
ory allocation requests required by this operation.

Measuring the app load time was done using a high deﬁni-
tion camera by recording a video for the device display when
an app is open. The video was later played back to extract
the exact time needed for the app window to ﬁll the screen.
We measured the load time of each app twice. The ﬁrst time
incorporates creating a new process for the app, loading the
app binary from the disk and drawing the app display for
the ﬁrst time. The second time is faster because the app
process usually still exists in memory, so it only involves re-
drawing the app window to the display. Table 3 shows the
result of this experiment. The overhead represents the extra
time needed to load the app when TZ-RKP is present.

It is observed that there is a noticeable diﬀerence between
the time needed to load the app when TZ-RKP is present
in both the ﬁrst and second times; the TZ-RKP overhead
in the second load time is less than that of the ﬁrst load
time of the app. When we investigated this issue further, we
found that the delay in the ﬁrst time happens due to multiple
operations that include mapping the memory needed to load
the binaries of the application and its libraries. In the second

99Table 3: App load time (in seconds) *

App

Gallery
Clock
Calendar
Camera
Contacts
Dialer
Message
Music
Setting
Google
Calculator
Downloads

Original
1st
1.08
1.20
1.02
2.07
1.30
1.06
0.91
1.12
0.97
1.60
0.97
1.04

2nd
0.74
0.97
0.74
1.59
0.57
0.47
0.52
0.89
0.79
1.30
0.64
0.47

TZ-RKP
1st
1.36
1.39
1.25
2.59
1.54
1.29
1.08
1.28
1.20
1.83
1.12
1.27

2nd
0.84
1.04
0.87
2.01
0.68
0.56
0.61
1.00
0.89
1.42
0.75
0.50

Overhead
2nd
1st
0.10
0.28
0.07
0.19
0.12
0.23
0.42
0.52
0.24
0.11
0.09
0.23
0.09
0.17
0.11
0.16
0.10
0.23
0.23
0.12
0.11
0.15
0.23
0.03

* The presented performance measurement results
are diﬀerent from commercial products.

time, most of the delay happens when Android maps the
memory needed for the application process to control the
screen display. The same operation is needed in both the
ﬁrst and subsequent app loading.

It is also observed that the camera app has substantially
bigger delay when TZ-RKP is present. When we investi-
gated this issue, we found out that most of the delay occurs
when the kernel allocates the I/O memory needed for the
camera display driver.
Power Consumption Overhead: Our fourth experiment
showed that TZ-RKP does not cause a measurable increase
in power consumption.

Power consumption was ﬁrst measured during sleep time.
TZ-RKP did not cause overhead because the CPU is in sleep
mode and there is no events to be monitored. Afterwards,
the powers consumption was measured on various system
events that include: boot-up the device, app load time and
playback of videos. In all cases, the diﬀerence in the power
consumption between the original system and the one with
TZ-RKP was within the margin of error of the experiment.
Device Bootup Time: We anticipated some delay in the
boot up time due to the enormous number of memory al-
locations required. Nonetheless, system bootup is not very
important to Android users because the devices are usually
kept in the sleeping mode and rarely rebooted. In our exper-
iment the average original system bootup time is 21.72 sec-
ond, while the average bootup time for a TZ-RKP equipped
system was 24.30 seconds.

Finally, it is worth noting that before TZ-RKP is com-
mercially deployed, the hardware vendor may opt to reduce
the performance overhead on certain types of devices by se-
lectively suspending the protection for certain operations or
by using other optimization techniques that are out of the
scope of this paper.

7. RELATED WORK

The two main research directions that target integrity
monitoring are: hypervisor-based and hardware-based ap-
proaches. In Section 1, we discussed the problems they face
and how TZ-RKP solved them.

Another method to do system protection without relying
on the hypervisor is to use a thin privileged software layer,
such as microhypervisors [36, 40, 53] or formally veriﬁed mi-
crokernels [34]. These approaches are eﬀective in isolating
sensitive workloads. Nevertheless, microhypervisors monop-

olize the hardware virtualization extensions, which impact
the portability and ﬂexibility of these approaches. Moreover,
both hypervisors and microhypervisors rely on the virtual-
ization extension which is not available on all ARM plat-
forms. Indeed, these approaches are more suitable than TZ-
RKP for platforms that implement the hypervisor extensions
but do not implement the TrustZone extensions.

Formally veriﬁed microkernels are currently far from the
point of being commercialized because of the challenges they
face to formally verify every operation needed to completely
isolate a security tool and monitor the kernel integrity using
software. Hardware isolation mechanisms, such as Trust-
Zone, solve this problem because the hardware itself pro-
vides the protection required for the integrity monitor.

In Section 1, we discussed the main limitations of existing
hardware-based solutions. Some research eﬀorts [18, 39, 42,
58] proposed new hardware modiﬁcations to achieve event-
driven monitoring using hardware-based techniques. Nev-
ertheless, modifying the hardware is a long-term objective
that is not achievable for existing systems.

Finally, SPROBES [25], a recent publication, realized the
same research problem tackled by this paper. It presents a
generic system that was developed in parallel to TZ-RKP
to enforce kernel code integrity on TrustZone architecture.
Many of the techniques presented in SPROBES overlaps
with the TZ-RKP techniques presented in this paper and
described in the prior patent application [11]. Nevertheless,
we present a real world prototype and implementation of
the proposed system.
In addition, we presented addition
techniques that focus on data integrity and on performance
enhancement to make TZ-RKP a real world solution.

8. CONCLUSION

We introduced TZ-RKP, a system that provides kernel
real-time protection from within the TrustZone secure world.
TZ-RKP runs in the TrustZone secure world. Hence, it is
safe from attacks that compromise the kernel, which runs
in the normal world. TZ-RKP solves the dilemma that pre-
vious approaches face because it does not have to trade oﬀ
isolation and eﬀectiveness.

TZ-RKP provides non-bypassable event-driven monitor-
ing of the target OS kernel. It uses memory protection to
prevent attacks that aim at modifying the running version
of the kernel. This paper also introduced the current TZ-
RKP implementation and experimental evaluation. Results
indicate that TZ-RKP is an eﬀective and practical security
solution for real world systems.

Since TZ-RKP completely protects the kernel code base,
our future work will focus on preventing attacks that trick
the kernel into maliciously modifying its own data. Such
attacks can hijack the control ﬂow of the kernel and cause
severe damage. Fortunately, these attacks cannot bypass the
control of TZ-RKP of the system’s critical functions. Hence,
it can still inspect the kernel for anomalies or traces of these
attacks. Our future work will speciﬁcally focus on building
a detection mechanisms that runs inside TZ-RKP to detect
these attacks and take the proper corrective action.

Acknowledgments
We would like to thank Xun Chen, Michael Grace, Kirk
Swidowski, Vinod Ganapathy, and the anonymous reviewers

100for their valuable input that helped us improve the quality
of the paper.

9. REFERENCES
[1] Android rooting method: Motochopper. http:

//hexamob.com/how-to-root/motochopper-method.

[2] CVE-2007-4993: Xen guest root can escape to domain

0 through pygrub. https://bugzilla.redhat.com/
show_bug.cgi?id=CVE-2007-4993.

[17] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng.

ROPecker: A generic and practical approach for
defending against ROP attacks. In Proceedings of the
21th Annual Network and Distributed System Security
Symposium (NDSS ’14), 2014.

[18] S. Chhabra, B. Rogers, Y. Solihin, and M. Prvulovic.

SecureME: a hardware-software approach to full
system security. In Proceedings of the international
conference on Supercomputing (ICS ’11), pages
108–119, 2011.

[3] CVE-2008-2100: VMware buﬀer overﬂows in VIX API

[19] J. Criswell, N. Dautenhahn, and V. Adve. KCoFI:

let local users execute arbitrary code.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2008-2100.

Complete control-ﬂow integrity for commodity
operating system kernels. In Proceedings of the 35th
IEEE Symposium on Security and Privacy, 2014.

[4] CVE-2013-6432. http://cve.mitre.org/cgi-bin/

[20] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve.

cvename.cgi?name=CVE-2013-6432.

[5] How to root my Android device using vRoot.

http://http://androidxda.com/download-vroot.
[6] Vulnerability in xenserver could result in privilege

escalation and arbitrary code execution.
http://support.citrix.com/article/CTX118766.

[7] Xbox 360 hypervisor privilege escalation vulnerability.

http://www.securityfocus.com/archive/1/461489.

[8] Advanced Micro Devices. AMD64 architecture

programmer’s manual: Volume 2: System
programming, September 2007.

[9] ARM Ltd. TrustZone. http://www.arm.com/

products/processors/technologies/trustzone.php.

[10] ARM Ltd. ARM Architecture Reference Manual.

ARMv7-A and ARMv7-R edition, 2012.

[11] A. M. Azab and P. Ning. Methods, systems, and
computer readable medium for active monitoring,
memory protection and integrity veriﬁcation of target
devices, Feb. 6 2014. WO Patent App.
PCT/US2013/000,074.

[12] A. M. Azab, P. Ning, E. C. Sezer, and X. Zhang.
HIMA: A hypervisor-based integrity measurement
agent. In Proceedings of the 25th Annual Computer
Security Applications Conference (ACSAC ’09), pages
193–206, 2009.

[13] A. M. Azab, P. Ning, Z. Wang, X. Jiang, X. Zhang,

and N. C. Skalsky. HyperSentry: enabling stealthy
in-context measurement of hypervisor integrity. In
Proceedings of the 17th ACM conference on Computer
and communications security (CCS ’10), pages 38–49,
2010.

[14] A. Baliga, V. Ganapathy, and L. Iftode. Automatic
inference and enforcement of kernel data structure
invariants. In Proceedings of the 24th Annual
Computer Security Applications Conference (ACSAC
’08), pages 77–86, 2008.

[15] J. Bickford, R. O’Hare, A. Baliga, V. Ganapathy, and

L. Iftode. Rootkits on smart phones: Attacks,
implications and opportunities. In Proceedings of the
Eleventh Workshop on Mobile Computing Systems and
Applications (HotMobile ’10), pages 49–54, 2010.

[16] E. Buchanan, E. Roemer, H. Shacham, and S. Savage.

When good instructions go bad: generalizing
return-oriented programming to RISC. In Proceedings
of the 15th ACM conference on Computer and
communications security (CCS ’08), pages 27–38,
2008.

Secure virtual architecture: a safe execution
environment for commodity operating systems. In
Proceedings of the 21st ACM SIGOPS symposium on
Operating systems principles (SOSP ’07), pages
351–366, 2007.

[21] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz,
R. Hund, S. N¨urnberger, and A.-R. Sadeghi. Mocﬁ: A
framework to mitigate control-ﬂow attacks on
smartphones. In Proceedings of the 19th Symposium
on Network and Distributed System Security
(NDSS’12), 2012.

[22] F. M. David, E. M. Chan, J. C. Carlyle, and R. H.

Campbell. Cloaker: Hardware supported rootkit
concealment. In Proceedings of the 29th IEEE
Symposium on Security and Privacy. IEEE, 2008.

[23] T. Garﬁnkel, B. Pfaﬀ, J. Chow, M. Rosenblum, and

D. Boneh. Terra: a virtual machine-based platform for
trusted computing. In Proceedings of the 19th ACM
symposium on Operating systems principles (SOSP
’03), pages 193–206, 2003.

[24] T. Garﬁnkel and M. Rosenblum. A virtual machine

introspection based architecture for intrusion
detection. In Proceedings of the 10th Network and
Distributed Systems Security Symposium (NDSS ’03),
pages 191–206, 2003.

[25] X. Ge, H. Vijayakumar, and T. Jaeger. SPROBES:

Enforcing kernel code integrity on the trustzone
architecture. In Proceedings of the 2014 Mobile
Security Technologies (MoST) workshop, 2014.

[26] E. G¨oktas, E. Athanasopoulos, H. Bos, and
G. Portokalidis. Out of control Overcoming
control-ﬂow integrity. In Proceedings of the 35th IEEE
Symposium on Security and Privacy, 2014.

[27] G. Hotz. towelroot. https://towelroot.com/.
[28] R. Hund, T. Holz, and F. C. Freiling. Return-oriented

rootkits: Bypassing kernel code integrity protection
mechanisms. In Proceedings of the 18th USENIX
Security Symposium, 2009.

[29] Intel Corporation. Trusted eXecution Technology

preliminary architecture speci(cid:12)cation and enabling
considerations, 2006.

[30] X. Jiang, X. Wang, and D. Xu. Stealthy malware

detection through vmm-based “out-of-the-box”
semantic view reconstruction. In Proceedings of the
14th ACM conference on Computer and
communications security (CCS ’07), pages 128–138,
2007.

101[31] S. T. Jones, A. C. Arpaci-Dusseau, and R. H.

Arpaci-Dusseau. Antfarm: tracking processes in a
virtual machine environment. In Proceedings of the
annual conference on USENIX ’06 Annual Technical
Conference (ATEC ’06), pages 1–1, 2006.

[32] V. P. Kemerlis, G. Portokalidis, and A. D. Keromytis.

kGuard: Lightweight kernel protection against
return-to-user attacks. In Proceedings of the 21st
USENIX Security Symposium, 2012.

[33] C. Kil, E. C. Sezer, A. M. Azab, P. Ning, and

X. Zhang. Remote attestation to dynamic system
properties: Towards providing complete system
integrity evidence. In Proceedings of the 39th
International Conference on Dependable Systems and
Networks (DSN’09), 2009.

Symposium on Security and Privacy, pages 233–247,
2008.

[44] N. L. Petroni Jr. and M. Hicks. Automated detection

of persistent kernel control-ﬂow attacks. In
Proceedings of the 14th ACM conference on Computer
and communications security (CCS ’07), pages
103–115, 2007.

[45] J. Rhee, R. Riley, D. Xu, and X. Jiang. Defeating

dynamic data kernel rootkit attacks via VMM-based
guest-transparent monitoring. In Proceedings of the
International Conference on Availability, Reliability
and Security (ARES ’09), pages 74–81, 2009.

[46] D. Rosenberg. QSEE TrustZone kernel integer over

ﬂow vulnerability. In Black Hat conference, 2014.
[47] Samsung. White paper: An overview of Samsung

[34] G. Klein, K. Elphinstone, G. Heiser, J. Andronick,

KNOX, 2013.

D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt,
R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and
S. Winwood. sel4: formal veriﬁcation of an OS kernel.
In Proceedings of the ACM SIGOPS 22nd symposium
on Operating systems principles (SOSP ’09), pages
207–220, 2009.

[35] K. Kourai and S. Chiba. Hyperspector: virtual
distributed monitoring environments for secure
intrusion detection. In Proceedings of the 1st
ACM/USENIX international conference on Virtual
execution environments (VEE ’05), pages 197–207,
2005.

[36] M. Lange, S. Liebergeld, A. Lackorzynski, A. Warg,

and M. Peter. L4android: A generic operating system
framework for secure smartphones. In Proceedings of
the 1st ACM Workshop on Security and Privacy in
Smartphones and Mobile Devices (SPSM ’11), 2011.

[37] A. Lineberry. Malicious code injection via /dev/mem.

Black Hat Europe, 2009.

[38] L. Litty, H. A. Lagar-Cavilla, and D. Lie. Hypervisor
support for identifying covertly executing binaries. In
Proceedings of the 17th USENIX Security Symposium,
pages 243–258, 2008.

[39] Z. Liu, J. Lee, J. Zeng, Y. Wen, Z. Lin, and W. Shi.

Cpu transparent protection of os kernel and hypervisor
integrity with programmable dram. In Proceedings of
the 40th Annual International Symposium on
Computer Architecture (ISCA ’13), 2013.

[40] J. McCune, Y. Li, N. Qu, A. Datta, V. Gligor, and

A. Perrig. Eﬃcient TCB reduction and attestation. In
the 31st IEEE Symposium on Security and Privacy,
May 2010.

[41] J. McCune, B. Parno, A. Perrig, M. Reiter, and

H. Isozaki. Flicker: an execution infrastructure for
TCB minimization. In Proceedings of the ACM
European Conference on Computer Systems
(EuroSys), 2008.

[42] H. Moon, H. Lee, J. Lee, K. Kim, Y. Paek, and B. B.
Kang. Vigilare: Toward snoop-based kernel integrity
monitor. In Proceedings of the 2012 ACM Conference
on Computer and Communications Security (CCS
’12), 2012.

[43] B. D. Payne, M. Carbone, M. Sharif, and W. Lee.

Lares: An architecture for secure active monitoring
using virtualization. In Proceedings of the 29th IEEE

[48] Secunia. Vulnerability report: VMware ESX server

3.x.
http://secunia.com/advisories/product/10757/.

[49] Secunia. Xen multiple vulnerability report.
http://secunia.com/advisories/44502/.

[50] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor:

a tiny hypervisor to provide lifetime kernel code
integrity for commodity OSes. In Proceedings of
twenty-(cid:12)rst ACM SIGOPS symposium on Operating
systems principles (SOSP ’07), pages 335–350, 2007.
[51] H. Shacham. The geometry of innocent ﬂesh on the
bone: return-into-libc without function calls (on the
x86). In Proceedings of the 14th ACM conference on
Computer and Communications Security (CCS ’07),
pages 552–561, 2007.

[52] M. Sharif, W. Lee, W. Cui, and A. Lanzi. Secure

in-vm monitoring using hardware virtualization. In
Proceedings of the 16th ACM conference on Computer
and communications security (CCS ’09), pages
477–487, 2009.

[53] U. Steinberg and B. Kauer. NOVA: a

microhypervisor-based secure virtualization
architecture. In Proceedings of the 5th European
conference on Computer systems (EuroSys’10), pages
209–222. ACM, 2010.

[54] S. Vogl, J. Pfoh, T. Kittel, and C. Eckert. Persistent
data-only malware: Function hooks without code. In
Proceedings of the 21th Annual Network and
Distributed System Security Symposium (NDSS’14),
2014.

[55] J. Wang, A. Stavrou, and A. K. Ghosh. HyperCheck:
A hardware-assisted integrity monitor. In Proceedings
of the 13th International Symposium on Recent
Advances in Intrusion Detection (RAID’10),
September 2010.

[56] R. Wojtczuk and J. Rutkowska. Xen 0wning trilogy.

In Black Hat conference, 2008.

[57] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres,

S. McCamant, D. Song, and W. Zou. Practical control
ﬂow integrity and randomization for binary
executables. In Proceedings of the 34th IEEE
Symposium on Security and Privacy, 2013.

[58] V. Zimmer and Y. Rasheed. Hypervisor runtime

integrity support. US Patent 20090164770, June 2009.

102