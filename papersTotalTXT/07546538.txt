2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy

Hawk: The Blockchain Model of Cryptography and

Privacy-Preserving Smart Contracts

Ahmed Kosba∗, Andrew Miller∗, Elaine Shi†, Zikai Wen†, Charalampos Papamanthou∗

∗University of Maryland and †Cornell University

{akosba, amiller}@cs.umd.edu, {rs2358, zw385}@cornell.edu, cpap@umd.edu

Abstract—Emerging smart contract systems over decentralized
cryptocurrencies allow mutually distrustful parties to transact
safely without trusted third parties. In the event of contrac-
tual breaches or aborts, the decentralized blockchain ensures
that honest parties obtain commensurate compensation. Existing
systems, however, lack transactional privacy. All transactions,
including ﬂow of money between pseudonyms and amount
transacted, are exposed on the blockchain.

We present Hawk, a decentralized smart contract system that
does not store ﬁnancial transactions in the clear on the block-
chain, thus retaining transactional privacy from the public’s view.
A Hawk programmer can write a private smart contract in an
intuitive manner without having to implement cryptography, and
our compiler automatically generates an efﬁcient cryptographic
protocol where contractual parties interact with the blockchain,
using cryptographic primitives such as zero-knowledge proofs.
To formally deﬁne and reason about the security of our
protocols, we are the ﬁrst to formalize the blockchain model
of cryptography. The formal modeling is of independent interest.
We advocate the community to adopt such a formal model when
designing applications atop decentralized blockchains.

I. INTRODUCTION

Decentralized cryptocurrencies such as Bitcoin [48] and alt-
coins [20] have rapidly gained popularity, and are often quoted
as a glimpse into our future [5]. These emerging cryptocur-
rency systems build atop a novel blockchain technology where
miners run distributed consensus whose security is ensured if
no adversary wields a large fraction of the computational (or
other forms of) resource. The terms “blockchain” and “miners”
are therefore often used interchangeably.

Blockchains like Bitcoin reach consensus not only on a
stream of data but also on computations involving this data. In
Bitcoin, speciﬁcally, the data include money transfer transac-
tion proposed by users, and the computation involves transac-
tion validation and updating a data structure called the unspent
transaction output set which, imprecisely speaking, keeps track
of users’ account balances. Newly emerging cryptocurrency
systems such as Ethereum [57] embrace the idea of running
arbitrary user-deﬁned programs on the blockchain, thus creat-
ing an expressive decentralized smart contract system.

In this paper, we consider smart contract protocols where
parties interact with such a blockchain. Assuming that the
decentralized concensus protocol is secure, the blockchain can
be thought of as a conceptual party (in reality decentralized)
that can be trusted for correctness and availability but not for

privacy. Such a blockchain provides a powerful abstraction for
the design of distributed protocols.

The blockchain’s expressive power is further enhanced by
the fact that blockchains naturally embody a discrete notion
of time, i.e., a clock that increments whenever a new block
is mined. The existence of such a trusted clock is crucial
for attaining ﬁnancial
fairness in protocols. In particular,
malicious contractual parties may prematurely abort from a
protocol to avoid ﬁnancial payment. However, with a trusted
clock, timeouts can be employed to make such aborts evident,
such that
the blockchain can ﬁnancially penalize aborting
parties by redistributing their collateral deposits to honest,
non-aborting parties. This makes the blockchain model of
cryptography more powerful than the traditional model without
a blockchain where fairness is long known to be impossible
in general when the majority of parties can be corrupt [8],
[17], [24].
In summary, blockchains allow parties mutually
unbeknownst to transact securely without a centrally trusted
intermediary, and avoiding high legal and transactional cost.
Despite the expressiveness and power of the blockchain
and smart contracts, the present form of these technologies
lacks transactional privacy. The entire sequence of actions
taken in a smart contract are propagated across the network
and/or recorded on the blockchain, and therefore are publicly
visible. Even though parties can create new pseudonymous
public keys to increase their anonymity, the values of all trans-
actions and balances for each (pseudonymous) public key are
publicly visible. Further, recent works have also demonstrated
deanonymization attacks by analyzing the transactional graph
structures of cryptocurrencies [42], [52].

We stress that lack of privacy is a major hindrance towards
the broad adoption of decentralized smart contracts, since ﬁ-
nancial transactions (e.g., insurance contracts or stock trading)
are considered by many individuals and organizations as being
highly secret. Although there has been progress in designing
privacy-preserving cryptocurrencies such as Zerocash [11] and
several others [26], [43], [54], these systems forgo programma-
bility, and it is unclear a priori how to enable programmability
without exposing transactions and data in cleartext to miners.

A. Hawk Overview

We propose Hawk, a framework for building privacy-
preserving smart contracts. With Hawk, a non-specialist pro-
grammer can easily write a Hawk program without having to

2375-1207/16 $31.00 © 2016 IEEE
© 2016, Ahmed Kosba. Under license to IEEE.
DOI 10.1109/SP.2016.55
DOI 10.1109/SP.2016.55

839
839

implement any cryptography. Our Hawk compiler is in charge
of compiling the program to a cryptographic protocol between
the blockchain and the users. As shown in Figure 1, a Hawk
program contains two parts:
1) A private portion denoted φpriv which takes in parties’ input
data (e.g., choices in a “rock, paper, scissors” game) as well
as currency units (e.g., bids in an auction). φpriv performs
computation to determine the payout distribution amongst
the parties. For example, in an auction, winner’s bid goes to
the seller, and others’ bids are refunded. The private Hawk
program φpriv is meant to protect the participants’ data and
the exchange of money.

Manager

Blockchain

Protocol

Users

Coins

Data

Hawk Contract

Compile

Public Фpub    Private Фpriv

Programmer

Fig. 1. Hawk overview.

2) A public portion denoted φpub that does not touch private

data or money.
Our compiler will compile the Hawk program into the
following pieces which jointly deﬁne a cryptographic protocol
between users, the manager, and the blockchain:
• the blockchain’s program which will be executed by all

consensus nodes;

• a program to be executed by the users; and
• a program to be executed by a special facilitating party

called the manager which will be explained shortly.

Security guarantees. Hawk’s security guarantees encompass
two aspects:
• On-chain privacy. On-chain privacy stipulates that transac-
tional privacy be provided against the public (i.e., against
any party not involved in the contract) – unless the con-
tractual parties themselves voluntarily disclose information.
Although in Hawk protocols, users exchange data with
the blockchain, and rely on it to ensure fairness against
aborts, the ﬂow of money and amount transacted in the
private Hawk program φpriv is cryptographically hidden
from the public’s view. Informally,
this is achieved by
sending “encrypted” information to the blockchain, and
relying on zero-knowledge proofs to enforce the correctness
of contract execution and money conservation.

• Contractual security. While on-chain privacy protects con-
tractual parties’ privacy against
the public (i.e., parties
not involved in the ﬁnancial contract), contractual secu-
rity protects parties in the same contractual agreement
from each other. Hawk assumes that contractual parties
act selﬁshly to maximize their own ﬁnancial interest. In
particular, they can arbitrarily deviate from the prescribed
protocol or even abort prematurely. Therefore, contractual
security is a multi-faceted notion that encompasses not only
cryptographic notions of conﬁdentiality and authenticity,
but also ﬁnancial fairness in the presence of cheating and
aborting behavior. The best way to understand contractual
security is through a concrete example, and we refer the
reader to Section I-B for a more detailed explanation.

Minimally trusted manager. The execution of Hawk con-
tracts are facilitated by a special party called the manager.
The manager can see the users’ inputs and is trusted not to
disclose users’ private data. However, the manager is NOT to

840840

be equated with a trusted third party — even when the manager
can deviate arbitrarily from the protocol or collude with the
parties, the manager cannot affect the correct execution of
the contract. In the event that a manager aborts the protocol,
it can be ﬁnancially penalized, and users obtain compensation
accordingly.

The manager also need not be trusted to maintain the
security or privacy of the underlying currency (e.g., it cannot
double-spend,
inﬂate the currency, or deanonymize users).
Furthermore, if multiple contract instances run concurrently,
each contract may specify a different manager and the effects
of a corrupt manager are conﬁned to that instance. Finally,
the manager role may be instantiated with trusted comput-
ing hardware like Intel SGX, or replaced with a multiparty
computation among the users themselves, as we describe in
Section IV-C and Appendix A.
Terminology. In Ethereum [57], the blockchain’s portion of
the protocol is called an Ethereum contract. However, this
paper refers to the entire protocol deﬁned by the Hawk
program as a contract; and the blockchain’s program is a
constituent of the bigger protocol. In the event that a manager
aborts the protocol, it can be ﬁnancially penalized, and users
obtain compensation accordingly.
B. Example: Sealed Auction
Example program. Figure 2 shows a Hawk program for
implementing a sealed, second-price auction where the highest
bidder wins, but pays the second highest price. Second-
price auctions are known to incentivize truthful bidding under
certain assumptions, [55] and it
that bidders
submit bids without knowing the bid of the other people. Our
example auction program contains a private portion φpriv that
determines the winning bidder and the price to be paid; and
a public portion φpub that relies on public deposits to protect
bidders from an aborting manager.

is important

For the time being, we assume that the set of bidders are

known a priori.
Contractual security requirements. Hawk will compile this
auction program to a cryptographic protocol. As mentioned
earlier, as long as the bidders and the manager do not volun-
tarily disclose information, transaction privacy is maintained
against the public. Hawk also guarantees the following con-
tractual security requirements for parties in the contract:

1
2

3
4
5
6
7

8
9
10
11
12
13
14
15
16

17
18
19
20
21
22
23
24
25
26

27
28
29
30
31
32
33
34
35

HawkDeclareParties(Seller,/* N parties */);
HawkDeclareTimeouts(/* hardcoded timeouts */);

// Private portion φpriv

private contract auction(Inp &in, Outp &out) {

int winner = -1;
int bestprice = -1;
int secondprice = -1;

for (int i = 0; i < N; i++) {

if (in.party[i].$val > bestprice) {

secondprice = bestprice;
bestprice = in.party[i].$val;
winner = i;

} else if (in.party[i].$val > secondprice) {

secondprice = in.party[i].$val;

}

}

// Winner pays secondprice to seller
// Everyone else is refunded
out.Seller.$val = secondprice;
out.party[winner].$val = bestprice-secondprice;
out.winner = winner;
for (int i = 0; i < N; i++) {

if (i != winner)

out.party[i].$val = in.party[i].$val;

}

}

// Public portion φpub

public contract deposit {

// Manager deposited $N earlier
def check():

// invoked on contract completion

send $N to Manager
def managerTimeOut():

for (i in range($N)):
send $1 to party[i]

}

// refund manager

Fig. 2. Hawk program for a second-price sealed auction. Code described
in this paper is an approximation of our real implementation. In the public
contract, the syntax “send $N to P ” corresponds to the following semantics
:= ledger[P ] + $N – see
in our cryptographic formalism:
Section II-B.

ledger[P ]

• Input independent privacy. Each user does not see others’
bids before committing to their own (even when they collude
with a potentially malicious manager). This way, users bids
are independent of others’ bids.

• Posterior privacy. As long as the manager does not disclose
information, users’ bids are kept private from each other
(and from the public) even after the auction.

• Financial fairness. Parties may attempt to prematurely abort
from the protocol to avoid payment or affect the redistribu-
tion of wealth. If a party aborts or the auction manager
aborts,
the aborting party will be ﬁnancially penalized
while the remaining parties receive compensation. As is
well-known in the cryptography literature, such fairness
guarantees are not attainable in general by off-chain only
protocols such as secure multi-party computation [7], [17].
As explained later, Hawk offers built-in mechanisms for
enforcing refunds of private bids after certain timeouts.
Hawk also allows the programmer to deﬁne additional rules,

841841

as part of the Hawk contract, that govern ﬁnancial fairness.
• Security against a dishonest manager. We ensure authen-
ticity against a dishonest manager: besides aborting, a dis-
honest manager cannot affect the outcome of the auction
and the redistribution of money, even when it colludes with
a subset of the users. We stress that to ensure the above,
input independent privacy against a faulty manager is a
prerequisite. Moreover, if the manager aborts, it can be
ﬁnancially penalized, and the participants obtain correspond-
ing remuneration.
An auction with the above security and privacy requirements
cannot be trivially implemented atop existing cryptocurrency
systems such as Ethereum [57] or Zerocash [11]. The former
allows for programmability but does not guarantee transac-
tional privacy, while the latter guarantees transactional privacy
but at the price of even reduced programmability than Bitcoin.
Aborting and timeouts. Aborting is dealt with using timeouts.
A Hawk program such as Figure 2 declares timeout parame-
ters using the HawkDeclareTimeouts special syntax. Three
timeouts are declared where T1 < T2 < T3:
T1 : The Hawk contract stops collecting bids after T1.
T2 : All users should have opened their bids to the manager
within T2; if a user submitted a bid but fails to open by T2,
its input bid is treated as 0 (and any other potential input
data treated as ⊥), such that the manager can continue.
T3 : If the manager aborts, users can reclaim their private bids

after time T3.
The public Hawk contract φpub can additionally implement
incentive structures. Our sealed auction program redistributes
the manager’s public deposit if it aborts. Speciﬁcally, in our
sealed auction program, φpub deﬁnes two functions, namely
check and managerTimeOut. The check function will be in-
voked when the Hawk contract completes execution within T3,
i.e., manager did not abort. Otherwise, if the Hawk contract
does not complete execution within T3, the managerTimeOut
function will be invoked. We remark that although not explic-
itly written in the code, all Hawk contracts have an implicit
default entry point for accepting parties’ deposits – these
deposits are withheld by the contract till they are redistributed
by the contract. Bidders should check that the manager has
made a public deposit before submitting their bids.
Additional applications. Besides the sealed auction example,
Hawk supports various other applications. We give more
sample programs in Section VI-B.

C. Contributions

To the best of our knowledge, Hawk is the ﬁrst to simulta-
neously offer transactional privacy and programmability in a
decentralized cryptocurrency system.
Formal models for decentralized smart contracts. We are
among the ﬁrst ones to initiate a formal, academic treatment
of the blockchain model of cryptography. We present a formal,
Universal Composability (UC) model for the blockchain model
of cryptography – this formal model is of independent interest,

and can be useful in general for deﬁning and modeling the
security of protocols in the blockchain model. Our formal
model has also been adopted by the Gyges work [35] in
designing criminal smart contracts.

In deﬁning for formal blockchain model, we rely on a notion
called wrappers to modularize our protocol design and to sim-
plify presentation. Wrappers handle a set of common details
such as timers, pseudonyms, global ledgers in a centralized
place such that they need not be repeated in every protocol.
New cryptography suite. We implement a new cryptography
suite that binds private transactions with programmable logic.
Our protocol suite contains three essential primitives freeze,
compute, and finalize. The freeze primitive allows parties
to commit to not only normal data, but also coins. Committed
coins are frozen in the contract, and the payout distribution will
later be determined by the program φpriv. During compute,
parties open their committed data and currency to the manager,
such that the manager can compute the function φpriv. Based on
the outcome of φpriv, the manager now constructs new private
coins to be paid to each recipient. The manager then submits
to the blockchain both the new private coins as well as zero-
knowledge proofs of their well-formedness. At this moment,
the previously frozen coins are now redistributed among the
users. Our protocol suite strictly generalizes Zerocash since
Zerocash implements only private money transfers between
users without programmability.

We deﬁne the security of our primitives using ideal func-
tionalities, and formally prove security of our constructions
under a simulation-based paradigm.
Implementation and evaluation. We built a Hawk prototype
and evaluated its performance by implementing several ex-
ample applications, including a sealed-bid auction, a “rock,
paper, scissors” game, a crowdfunding application, and a
swap ﬁnancial instrument. We propose interesting protocol
optimizations that gained us a factor of 10× in performance
relative to a straightforward implementation. We show that
for at about 100 parties (e.g., auction and crowdfunding), the
manager’s cryptographic computation (the most expensive part
of the protocol) is under 2.85min using 4 cores, translating
to under $0.14 of EC2 time. Further, all on-chain computation
(performed by all miners) is very cheap, and under 20ms for
all cases. We will open source our Hawk framework in the
near future.

D. Background and Related Work

1) Background: The original Bitcoin offers limited pro-
grammability through a scripting language that
is neither
Turing-complete nor user friendly. Numerous previous endeav-
ors at creating smart contract-like applications atop Bitcoin
(e.g., lottery [7], [17], micropayments [4],veriﬁable computa-
tion [40]) have demonstrated the difﬁculty of in retroﬁtting
Bitcoin’s scripting language – this serves well to motivate a
Turing-complete, user-friendly smart contract language.

Ethereum is the ﬁrst Turing-complete decentralized smart
contract system. With Ethereum’s imminent launch, companies
and hobbyists are already building numerous smart contract

applications either atop Ethereum or by forking off Ethereum,
such as prediction markets [3], supply chain provenance [6],
crowd-based fundraising [1], and security and derivatives
trading [28].
Security of the blockchain. Like earlier works that design
smart contract applications for cryptocurrencies, we rely on the
underlying decentralized blockchain to be secure. Therefore,
we assume the blockchain’s consensus protocol attains security
when an adversary does not wield a large fraction of the com-
putational power. Existing cryptocurrencies are designed with
heuristic security. On one hand, researchers have identiﬁed
attacks on various aspects of the system [29], [34]; on the
other, efforts to formally understand the security of blockchain
consensus have begun [32], [45].
Minimizing on-chain costs. Since every miner will execute
the smart contract programs while verifying each transaction,
cryptocurrencies including Bitcoin and Ethereum collect trans-
action fees that roughly correlate with the cost of execution.
While we do not explicitly model such fees, we design our
protocols to minimize on-chain costs by performing most of
the heavy-weight computation off-chain.

2) Additional Related Works: Leveraging blockchain for
ﬁnancial fairness. A few prior works have explored how to
leverage the blockchain technology to achieve fairness in pro-
tocol design. For example, Bentov et al. [17], Andrychowicz
et al. [7], Kumaresan et al. [40], Kiayias et al. [36], as well
as Zyskind et al. [59], show how Bitcoin can be used to
ensure fairness in secure multi-party computation protocols.
These protocols also perform off-chain secure computation
of various types, but do not guarantee transactional privacy
(i.e., hiding the currency ﬂows and amounts transacted). For
example, it is not clear how to implement our sealed auction
example using these earlier techniques. Second, these earlier
works either do not offer system implementations or provide
implementations only for speciﬁc applications (e.g., lottery). In
comparison, Hawk provides a generic platform such that non-
specialist programmers can easily develop privacy-preserving
smart contracts.
Smart contracts. The conceptual idea of programmable elec-
tronic “smart contracts” dates back nearly twenty years [53].
Besides recent decentralized cryptocurrencies, which guaran-
tee authenticity but not privacy, other smart contract imple-
mentations rely on trusted servers for security [46]. Our work
therefore comes closest to realizing the original vision of
parties interacting with a trustworthy “virtual computer” that
executes programs involving money and data.
Programming frameworks for cryptography. Several works
have developed programming frameworks that take in high-
level programs as speciﬁcations and generate cryptographic
implementations, including compilers for secure multi-party
computation [19], [39], [41], [51], authenticated data struc-
tures [44], and (zero-knowledge) proofs [12], [30], [31], [49].
Zheng et al. show how to generate secure distributed protocols
such as sealed auctions, battleship games, and banking applica-
tions [58]. These works support various notions of security, but

842842

none of them interact directly with money or leverage public
blockchains for ensuring ﬁnancial fairness. Thus our work
is among the ﬁrst to combine the “correct-by-construction”
cryptography approach with smart contracts.
Concurrent work. Our framework is the ﬁrst to provide a
full-ﬂedged formal model for decentralized blockchains as
embodied by Bitcoin, Ethereum, and many other popular
decentralized cryptocurrencies. In concurrent and independent
work, Kiayias et al. [36] also propose a blockchain model
in the (Generalized) Universal Composability framework [23]
and use it
to derive results that are similar to what we
describe in the online version [37], i.e., fair MPC with public
deposits. However, the “programmability” of their formalism
is limited to their speciﬁc application (i.e., fair MPC with
public deposits). In comparison, our formalism is designed
with much broader goals, i.e., to facilitate protocol designers
to design a rich class of protocols in the blockchain model. In
particular, both our real-world wrapper (Figure 11) and ideal-
world wrapper (Figure 10) model the presence of arbitrary user
deﬁned contract programs, which interact with both parties and
the ledger. Our formalism has also been adopted by the Gyges
work [35] demonstrating its broad usefulness.

II. THE BLOCKCHAIN MODEL OF CRYPTOGRAPHY

A. The Blockchain Model

We begin by informally describing the trust model and
assumptions. We then propose a formal framework for the
“blockchain model of cryptography” for specifying and rea-
soning about the security of protocols.

In this paper, the blockchain refers to a decentralized set
of miners who run a secure consensus protocol to agree upon
the global state. We therefore will regard the blockchain as a
conceptual trusted party who is trusted for correctness and
availability, but not trusted for privacy. The blockchain
not only maintains a global ledger that stores the balance for
every pseudonym, but also executes user-deﬁned programs.
More speciﬁcally, we make the following assumptions:
• Time. The blockchain is aware of a discrete clock that
increments in rounds. We use the terms rounds and epochs
interchangeably.

• Public state. All parties can observe the state of the block-
chain. This means that all parties can observe the public
ledger on the blockchain, as well as the state of any user-
deﬁned blockchain program (part of a contract protocol).
• Message delivery. Messages sent to the blockchain will
arrive at
the beginning of the next round. A network
adversary may arbitrarily reorder messages that are sent
to the blockchain within the same round. This means that
the adversary may attempt a front-running attack (also
referred to as the rushing adversary by cryptographers), e.g.,
upon observing that an honest user is trading a stock, the
adversary preempts by sending a race transaction trading the
same stock. Our protocols should be proven secure despite
such adversarial message delivery schedules.
We assume that all parties have a reliable channel to the
blockchain, and the adversary cannot drop messages a party

sends to the blockchain. In reality, this means that the
overlay network must have sufﬁcient redundancy. However,
an adversary can drop messages delivered between parties
off the blockchain.

• Pseudonyms. Users can make up an unbounded polynomial
number of pseudonyms when communicating with the
blockchain.

• Correctness and availability. We assume that the blockchain
will perform any prescribed computation correctly. We also
assume that the blockchain is always available.

Advantages of a generic blockchain model. We adopt
a generic blockchain model where the blockchain can run
arbitrary Turing-complete programs. In comparison, previous
and concurrent works [7], [17], [40], [50] retroﬁt the artifacts
of Bitcoin’s limited and hard-to-use scripting language. In
Section VII and the online version [37], we present additional
theoretical results demonstrating that our generic blockchain
model yields asymptotically more efﬁcient cryptographic pro-
tocols.
B. Formally Modeling the Blockchain

Our paper adopts a carefully designed notational system
such that readers may understand our constructions without
understanding the precise details of our formal modeling.

We stress, however, that we give formal, precise speciﬁ-
cations of both functionality and security, and our protocols
are formally proven secure under the Universal Composability
(UC) framework. In doing so, we make a separate contribution
of independent interest: we are the ﬁrst to propose a formal,
UC-based framework for describing and proving the security
of distributed protocols that interact with a blockchain —
we refer to our formal model as “the blockchain model of
cryptography”.
Programs, wrappers, and functionalities. In the remainder
of the paper, we will describe ideal speciﬁcations, as well
as pieces of the protocol executed by the blockchain, the
users, and the manager respectively as programs written in
pseudocode. We refer to them as the ideal program (denoted
Ideal), the blockchain program (denoted B or Blockchain), and
the user/manager program (denoted UserP) respectively.

All of our pseudo-code style programs have precise mean-
ings in the UC framework. To “compile” a program to a
UC-style functionality or protocol, we apply a wrapper to
a program. Speciﬁcally, we deﬁne the following types of
wrappers:
• The ideal wrapper F(·) transforms an ideal program IdealP
into a UC ideal functionality F(IdealP).
• The blockchain wrapper G(·) transforms a blockchain pro-
gram B to a blockchain functionality G(B). The blockchain
functionality G(B) models the program executing on the
blockchain.
• The protocol wrapper Π(·) transforms a user/manager
program UserP into a user-side or manager-side protocol
Π(UserP).

One important reason for having wrappers is that wrappers im-
plement a set of common features needed by every smart con-

843843

tract application, including time, public ledger, pseudonyms,
and adversarial reordering of messages — in this way, we
need not repeat this notation for every blockchain application.
We defer our formal UC modeling to Appendix B. This will
not hinder the reader in understanding our protocols as long
as the reader intuitively understands our blockchain model and
assumptions described in Section II-A. Before we describe our
protocols, we deﬁne some notational conventions for writing
“programs”. Readers who are interested in the details of our
formal model and proofs can refer to Appendix B.
C. Conventions for Writing Programs

take place immediately, but

Our wrapper-based system modularizes notation, and allows
us to use a set of simple conventions for writing user-deﬁned
ideal programs, blockchain programs, and user protocols. We
describe these conventions below.
Timer activation points. The ideal functionality wrapper
F(·) and the blockchain wrapper G(·) implement a clock that
advances in rounds. Every time the clock is advanced, the
wrappers will invoke the Timer activation point. Therefore,
by convention, we allow the ideal program or the blockchain
program can deﬁne a Timer activation point. Timeout oper-
ations (e.g., refunding money after a certain timeout) can be
implemented under the Timer activation point.
Delayed processing in ideal programs. When writing the
blockchain program, every message received by the blockchain
program is already delayed by a round due to the G(·) wrapper.
When writing the ideal program, we introduce a simple
convention to denote delayed computation. Program instruc-
tions that are written in gray background denote computation
that does not
is deferred to
the beginning of the next timer click. This is a convenient
shorthand because in our real-world protocol, effectively any
computation done by a blockchain functionality will be de-
layed. For example,
in our IdealPcash ideal program (see
Figure 3), whenever the ideal functionality receives a mint or
pour message, the ideal adversary S is notiﬁed immediately;
however, processing of the messages is deferred till the next
timer click. Formally, delayed processing can be implemented
simply by storing state and invoking the delayed program in-
structions on the next Timer click. By convention, we assume
that the delayed instructions are invoked at the beginning of
the Timer call. In other words, upon the next timer click, the
delayed instructions are executed ﬁrst.
Pseudonymity. All party identiﬁers that appear
in ideal
programs, blockchain programs, and user-side programs by
default refer to pseudonyms. When we write “upon receiving
message from some P ”, this accepts a message from any
pseudonym. Whenever we write “upon receiving message
from P ”, without the keyword some, this accepts a message
from a ﬁxed pseudonym P , and typically which pseudonym
we refer to is clear from the context.
Whenever we write “send m to G(B) as nym P ” inside a
user program, this sends an internal message (“send”, m, P )
to the protocol wrapper Π. The protocol wrapper will then
authenticate the message appropriately under pseudonym P .

IdealPcash

Init:
Mint:

Pour:

(cid:2)
1, $val

2) from P:
(cid:2)

(cid:2)
2

Coins: a multiset of coins, each of the form (P, $val)
Upon receiving (mint, $val) from some P:
send (mint,P, $val) to A
assert ledger[P] ≥ $val
ledger[P] := ledger[P] − $val
append (P, $val) to Coins

On (pour, $val1, $val2,P1,P2, $val
(cid:2)
assert $val1 + $val2 = $val
1 + $val
if P is honest,
assert (P, $vali) ∈ Coins for i ∈ {1, 2}
assert Pi (cid:4)= ⊥ for i ∈ {1, 2}
remove one (P, $vali) from Coins for i ∈ {1, 2}
for i ∈ {1, 2}, if Pi is corrupted, send (pour, i,
Pi, $val
if P is corrupted:
assert (P, $vali) ∈ Coins for i ∈ {1, 2}
remove one (P, $vali) from Coins for i ∈ {1, 2}
for i ∈ {1, 2}: add (Pi, $val
for i ∈ {1, 2}: if Pi (cid:4)= ⊥, send (pour, $val
i) to Pi
(cid:2)

i) to A; else send (pour, i,Pi) to A
(cid:2)

(cid:2)
i) to Coins

Fig. 3. Deﬁnition of IdealPcash. Notation: ledger denotes the public ledger,
and Coins denotes the private pool of coins. As mentioned in Section II-C,
gray background denotes batched and delayed activation. All party names
correspond to pseudonyms due to notations and conventions deﬁned in
Section II-B.

When the context is clear, we avoid writing “as nym P ”,
and simply write “send m to G(B)”. Our formal system also
allows users to send messages anonymously to the blockchain
– although this option will not be used in this paper.
Ledger and money transfers. A public ledger is denoted
ledger in our ideal programs and blockchain programs. When a
party sends $amt to an ideal program or a blockchain program,
this represents an ordinary message transmission. Money
transfers only take place when ideal programs or blockchain
programs update the public ledger ledger. In other words,
the symbol $ is only adopted for readability (to distinguish
variables associated with money and other variables), and does
not have special meaning or signiﬁcance. One can simply think
of this variable as having the money type.

III. CRYPTOGRAPHY ABSTRACTIONS

We now describe our cryptography abstraction in the form
of ideal programs. Ideal programs deﬁne the correctness and
security requirements we wish to attain by writing a speci-
ﬁcation assuming the existence of a fully trusted party. We
will later prove that our real-world protocols (based on smart
contracts) securely emulate the ideal programs. As mentioned
earlier, an ideal program must be combined with a wrapper F
to be endowed with exact execution semantics.
Overview. Hawk realizes the following speciﬁcations:
• Private ledger and currency transfer. Hawk relies on the
existence of a private ledger that supports private currency
transfers. We therefore ﬁrst deﬁne an ideal functionality
called IdealPcash that describes the requirements of a private
ledger (see Figure 3). Informally speaking, earlier works
such as Zerocash [11] are meant to realize (approximations

844844

of) this ideal functionality – although technically this ought
to be interpreted with the caveat that these earlier works
prove indistinguishability or game-based security instead
UC-based simulation security.

• Hawk-speciﬁc primitives. With a private ledger speciﬁed,
we then deﬁne Hawk-speciﬁc primitives including freeze,
compute, and ﬁnalize that are essential for enabling trans-
actional privacy and programmability simultaneously.

A. Private Cash Speciﬁcation IdealPcash

At a high-level, the IdealPcash speciﬁes the requirements of a
private ledger and currency transfer. We adopt the same “mint”
and “pour” terminology from Zerocash [11].
Mint. The mint operation allows a user P to transfer money
from the public ledger denoted ledger to the private pool
denoted Coins[P]. With each transfer, a private coin for user
P is created, and associated with a value val.
For correctness, the ideal program IdealPcash checks that
the user P has sufﬁcient funds in its public ledger ledger[P]
before creating the private coin.
Pour. The pour operation allows a user P to spend money
in its private bank privately. For simplicity, we deﬁne the
simple case with two input coins and two output coins. This
is sufﬁcient for users to transfer any amount of money by
“making change,” although it would be straightforward to
support more efﬁcient batch operations as well.
For correctness, the ideal program IdealPcash checks the
following: 1) for the two input coins, party P indeed possesses
private coins of the declared values; and 2) the two input coins
sum up to equal value as the two output coins, i.e., coins
neither get created or vanish.
Privacy. When an honest party P mints,
the ideal-world
adversary A learns the pair (P, val) – since minting is raising
coins from the public pool to the private pool. Operations on
the public pool are observable by A.
When an honest party P pours, however, the adversary A
learns only the output pseudonyms P1 and P2. It does not learn
which coin in the private pool Coins is being spent nor the
name of the spender. Therefore, the spent coins are anonymous
with respect to the private pool Coins. To get strong anonymity,
new pseudonyms P1 and P2 can be generated on the ﬂy to
receive each pour. We stress that as long as pour hides the
sender, this “breaks” the transaction graph, thus preventing
linking analysis.

If a corrupted party is the recipient of a pour, the adversary

additionally learns the value of the coin it receives.
Additional subtleties. Later in our protocol, honest parties
keep track of a wallet of coins. Whenever an honest party
pours, it ﬁrst checks if an appropriate coin exists in its local
wallet – and if so it immediately removes the coin from the
wallet (i.e., without delay). In this way, if an honest party
makes multiple pour transactions in one round, it will always
choose distinct coins for each pour transaction. Therefore, in
our IdealPcash functionality, honest pourers’ coins are immedi-
ately removed from Coins. Further, an honest party is not able

to spend a coin paid to itself until the next round. By contrast,
corrupted parties are allowed to spend coins paid to them in
the same round – this is due to the fact that any message is
routed immediately to the adversary, and the adversary can
also choose a permutation for all messages received by the
blockchain in the same round (see Section II and Appendix B).
Another subtlety in the IdealPcash functionality is while hon-
est parties always pour to existing pseudonyms, the function-
ality allows the adversary to pour to non-existing pseudonyms
denoted ⊥ — in this case, effectively the private coin goes
into a blackhole and cannot be retrieved. This enables a
performance optimization in our UserPcash and Blockchaincash
protocol later – where we avoid including the cti’s in the NIZK
of LPOUR (see Section IV). If a malicious pourer chooses to
compute the wrong cti, it is as if the recipient Pi did not
receive the pour, i.e., the pour is made to ⊥.

B. Hawk Speciﬁcation IdealPhawk

To enable transactional privacy and programmability simul-
taneously, we now describe the speciﬁcations of new Hawk
primitives, including freeze, compute, and ﬁnalize. The formal
speciﬁcation of the ideal program IdealPhawk is provided in
Figure 4. Below, we provide some explanations. We also refer
the reader to Section I-C for higher-level explanations.
Freeze. In freeze, a party tells IdealPhawk to remove one
coin from the private coins pool Coins, and freeze it in the
blockchain by adding it to FrozenCoins. The party’s private
input denoted in is also recorded in FrozenCoins. IdealPhawk
checks that P has not called freeze earlier, and that a coin
(P, val) exists in Coins before proceeding with the freeze.
Compute. When a party P calls compute, its private input
in and the value of its frozen coin val are disclosed to the
manager PM.
Finalize. In finalize, the manager PM submits a public
input inM to IdealPhawk. IdealPhawk now computes the outcome
of φpriv on all parties’ inputs and frozen coin values, and
redistributes the FrozenCoins based on the outcome of φpriv.
To ensure money conservation, the ideal program IdealPhawk
checks that the sum of frozen coins is equal to the sum of
output coins.
Interaction with public contract. The IdealPhawk functional-
ity is parameterized by a public Hawk contract φpub, which is
included in IdealPhawk as a sub-module. During a finalize,
IdealPhawk calls φpub.check. The public contract φpub typically
serves the following purposes:
• Check the well-formedness of the manager’s input inM.
For example, in our ﬁnancial derivatives application (Sec-
tion VI-B), the public contract φpub asserts that the input
corresponds to the price of a stock as reported by the stock
exchange’s authentic data feed.

• Redistribute public deposits. If parties or the manager have
aborted, or if a party has provided invalid input (e.g., less
than a minimum bet) the public contract φpub can now
redistribute the parties’ public deposits to ensure ﬁnancial

845845

IdealPhawk(PM,{Pi}i∈[N ], T1, T2, φpriv, φpub)
Init: Call IdealPcash.Init. Additionally:

FrozenCoins: a set of coins and private in-
puts received by this contract, each of the form
(P, in, $val). Initialize FrozenCoins := ∅.
Freeze: Upon receiving (freeze, $vali, ini) from Pi for some
i ∈ [N ]:
assert current time T < T1
assert Pi has not called freeze earlier.
assert at least one copy of (Pi, $vali) ∈ Coins
send (freeze,Pi) to A
add (Pi, $vali, ini) to FrozenCoins
remove one (Pi, $vali) from Coins
Compute: Upon receiving compute from Pi for some i ∈ [N ]:
assert current time T1 ≤ T < T2
if PM is corrupted, send (compute,Pi, $vali, ini)
to A
else send (compute,Pi) to A
let (Pi, $vali, ini) be the item in FrozenCoins
corresponding to Pi
send (compute,Pi, $vali, ini) to PM
assert current time T ≥ T2
assert PM has not called finalize earlier
for i ∈ [N ]:
let ($vali, ini) := (0,⊥) if Pi has not called
i}, out
({$val
(cid:2)
assert out
(cid:2)
i∈[N ] $val
assert
send (finalize, inM, out) to A
for each corrupted Pi that called compute: send (Pi,
$val
call φpub.check(inM, out)
for i ∈ [N ] such that Pi called compute:
add (Pi, $val
send (finalize, $val

Finalize: Upon receiving (finalize, inM, out) from PM:

†) := φpriv({$vali, ini}, inM)

† = out
i∈[N ] $vali =

(cid:2)

(cid:2)
i) to Coins

i) to Pi
(cid:2)

compute

i) to A
(cid:2)

(cid:2)
i

φpub: Run a local instance of public contract φpub. Messages
between the adversary to φpub, and from φpub to parties
are forwarded directly.
Upon receiving message (pub, m) from party P:
notify A of (pub, m)
send m to φpub on behalf of P

IdealPcash: include IdealPcash (Figure 3).

Fig. 4. Deﬁnition of IdealPhawk. Notations: FrozenCoins denotes frozen coins
owned by the contract; Coins denotes the global private coin pool deﬁned by
IdealPcash; and (ini, vali) denotes the input data and frozen coin value of
party Pi.

fairness. For example, in our “Rock, Paper, Scissors” exam-
ple (see Section VI-B), the private contract φpriv checks if
each party has frozen the minimal bet. If not, φpriv includes
that information in out so that φpub pays that party’s public
deposit to others.

Security and privacy requirements. The IdealPhawk speciﬁes
the following privacy guarantees. When an honest party P
freezes money (e.g., a bid), the adversary should not observe
the amount frozen. However, the adversary can observe the

846846

party’s pseudonym P. We note that leaking the pseudonym P
does not hurt privacy, since a party can simply create a new
pseudonym P and pour to this new pseudonym immediately
before the freeze.
When an honest party calls compute, the manager PM gets
to observe its input and frozen coin’s value. However, the
public and other contractual parties do not observe anything
(unless the manager voluntarily discloses information).

Finally, during a finalize operation, the output out is
declassiﬁed to the public – note that out can be empty if we
do not wish to declassify any information to the public.

It is not hard to see that our ideal program IdealPhawk
satisﬁes input independent privacy and authenticity against a
dishonest manager. Further, it satisﬁes posterior privacy as
long as the manager does not voluntarily disclose information.
Intuitive explanations of these security/privacy properties were
provided in Section I-B.
Timing and aborts. Our ideal program IdealPhawk requires
that freeze operations be done by time T1, and that compute
operations be done by time T2. If a user froze coins but did
not open by time T2, our ideal program IdealPhawk treats
(ini, vali) := (0,⊥), and the user Pi essentially forfeits
its frozen coins. Managerial aborts is not handled inside
IdealPhawk, but by the public portion of the contract.
Simplifying assumptions. For clarity, our basic version of
IdealPhawk is a stripped down version of our implementation.
Speciﬁcally, our basic IdealPhawk and protocols do not realize
refunds of frozen coins upon managerial abort. As mentioned
in Section IV-C, it is not hard to extend our protocols to
support such refunds.

Other simplifying assumptions we made include the follow-
ing. Our basic IdealPhawk assumes that the set of pseudonyms
participating in the contract as well as timeouts T1 and T2 are
hard-coded in the program. This can also be easily relaxed as
mentioned in Section IV-C.

IV. CRYPTOGRAPHIC PROTOCOLS

that

Our protocols are broken down into two parts: 1) the private
cash part
implements direct money transfers between
users; and 2) the Hawk-speciﬁc part that binds transactional
privacy with programmable logic. The formal protocol descrip-
tions are given in Figures 5 and 6. Below we explain the high-
level intuition.

A. Warmup: Private Cash and Money Transfers

Our construction adopts a Zerocash-like protocol for im-
plementing private cash and private currency transfers. For
completeness, we give a brief explanation below, and we
mainly focus on the pour operation which is technically more
interesting. The blockchain program Blockchaincash maintains
a set Coins of private coins. Each private coin is of the format

(P, coin := Comms($val))

where P denotes a party’s pseudonym, and coin commits to
the coin’s value $val under randomness s.

Blockchaincash

Init:

crs: a reference string for the underlying NIZK system
Coins: a set of coin commitments, initially ∅
SpentCoins: set of spent serial numbers, initially ∅
Mint: Upon receiving (mint, $val, s) from some party P,
coin := Comms($val)
assert (P, coin) /∈ Coins
assert ledger[P] ≥ $val
ledger[P] := ledger[P] − $val
add (P, coin) to Coins

Pour: Anonymous receive (pour, π,{sni,Pi, coini, cti}i∈{1,2}})

let MT be a merkle tree built over Coins
statement := (MT.root,{sni,Pi, coini}i∈{1,2})
assert NIZK.Verify(LPOUR, π, statement)
for i ∈ {1, 2},
assert sni /∈ SpentCoins
assert (Pi, coini) /∈ Coins
add sni to SpentCoins
add (Pi, coini) to Coins
send (pour, coini, cti) to Pi,

i}i∈{1,2})
(cid:2)

Relation (statement, witness) ∈ LPOUR is deﬁned as:
parse statement as (MT.root,{sni,Pi, coin
parse witness as (P, skprf,{branchi, si, $vali, s(cid:2)
assert P.pkprf = PRFskprf (0)
(cid:2)
assert $val1 + $val2 = $val
1 + $val
for i ∈ {1, 2},
coini := Commsi ($vali)
assert MerkleBranch(MT.root, branchi, (P(cid:8)coini))
assert sni = PRFskprf (P(cid:8)coini)
(cid:2)
i)
assert coin

(cid:2)
i = Comms(cid:2)

($val

(cid:2)
2

i

i, ri, $val

Init: Wallet: stores P’s spendable coins, initially ∅

Protocol UserPcash

GenNym:

sample a random seed skprf
pkprf := PRFskprf (0)
return pkprf

Mint: On input (mint, $val),

sample a commitment randomness s
coin := Comms($val)
store (s, $val, coin) in Wallet
send (mint, $val, s) to G(Blockchaincash)

Pour (as sender): On input (pour, $val1, $val2, P1, P2, $val

(cid:2)
1,

(cid:2)
2),

$val

(cid:2)
1 + $val

(cid:2)
2

assert $val1 + $val2 = $val
for i ∈ {1, 2}, assert (si, $vali, coini) ∈ Wallet for some
(si, coini)
let MT be a merkle tree over Blockchaincash.Coins
for i ∈ {1, 2}:
remove one (si, $vali, coini) from Wallet
sni := PRFskprf (P(cid:8)coini)
let branchi be the branch of (P, coini) in MT
sample randomness s(cid:2)
($val
coin
cti := ENC(Pi.epk, ri, $val
statement := (MT.root,{sni,Pi, coin
witness := (P, skprf,{branchi, si, $vali, s(cid:2)
π := NIZK.Prove(LPOUR, statement, witness)
AnonSend(pour, π,{sni,Pi, coin

(cid:2)
i := Comms(cid:2)

i}i∈{1,2})
(cid:2)

i, ri, $val

i(cid:8)s(cid:2)
(cid:2)
i)

i, ri
(cid:2)
i)

i})
(cid:2)

i

i, cti}i∈{1,2})
(cid:2)
to G(Blockchaincash)
(pour, coin, ct)

receive

from

i})
(cid:2)

Pour

(as
recipient): On
G(Blockchaincash):

let ($val(cid:8)s) := DEC(esk, ct)
assert Comms($val) = coin
store (s, $val, coin) in Wallet
output (pour, $val)

Fig. 5. UserPcash construction. A trusted setup phase generates the NIZK’s common reference string crs. For notational convenience, we omit writing the
crs explicitly in the construction. The Merkle tree MT is stored on the blockchain and not computed on the ﬂy – we omit stating this in the protocol for
notational simplicity. The protocol wrapper Π(·) invokes GenNym whenever a party creates a new pseudonym.
During a pour operation, the spender P chooses two coins
in Coins to spend, denoted (P, coin1) and (P, coin2) where
($vali) for i ∈ {1, 2}. The pour operation
coini := Commsi
(cid:3)
(cid:3)
pays val
2 amount to two output pseudonyms denoted
1 and val
P1 and P2 respectively, such that val1 + val2 = val
(cid:3)
(cid:3)
1 + val
2.
i for i ∈ {1, 2}, and
The spender chooses new randomness s(cid:3)
computes the output coins as

can be demonstrated by a Merkle branch consistent with the
root hash, and this is done in zero-knowledge.
• No double spending. Each coin (P, coin) has a cryptograph-
ically unique serial number sn that can be computed as
a pseudorandom function of P’s secret key and coin. To
pour a coin, its serial number sn must be disclosed, and a
zero-knowledge proof given to show the correctness of sn.
Blockchaincash checks that no sn is used twice.

(cid:3)

(cid:2)Pi, coini := Comms(cid:2)

(cid:3)
i)
($val
i to the recipient Pi
(cid:3)
The spender gives the values s(cid:3)
i and val
for Pi to be able to spend the coins later.

i

Now, the spender computes a zero-knowledge proof to show
the output coins are constructed appropriately, where

that
correctness compasses the following aspects:
• Existence of coins being spent. The coins being spent
(P, coin1) and (P, coin2) are indeed part of the private pool
Coins. We remark that here the zero-knowledge property
allows the spender to hide which coins it is spending – this
is the key idea behind transactional privacy.
To prove this efﬁciently, Blockchaincash maintains a Merkle
tree MT over the private pool Coins. Membership in the set

847847

• Money conservation. The zero-knowledge proof also attests
to the fact that the input coins and the output coins have
equal total value.
We make some remarks about the security of the scheme.
Intuitively, when an honest party pours to an honest party,
the adversary A does not
learn the values of the output
coins assuming that the commitment scheme Comm is hiding,
and the NIZK scheme we employ is computational zero-
knowledge. The adversary A can observe the nyms that receive
the two output coins. However, as we remarked earlier, since
these nyms can be one-time, leaking them to the adversary
would be okay. Essentially we only need to break linkability
at spend time to ensure transactional privacy.

Blockchainhawk(PM,{Pi}i∈[N ], T1, T2, φpriv, φpub)
Init: See IdealPhawk for description of parameters

Freeze: Upon receiving (freeze, π, sni, cmi) from Pi:

Call Blockchaincash.Init.
assert current time T ≤ T1
assert this is the ﬁrst freeze from Pi
let MT be a merkle tree built over Coins
assert sni /∈ SpentCoins
statement := (Pi, MT.root, sni, cmi)
assert NIZK.Verify(LFREEZE, π, statement)
add sni to SpentCoins and store cmi for later
Compute: Upon receiving (compute, π, ct) from Pi:
assert T1 ≤ T < T2 for current time T
assert NIZK.Verify(LCOMPUTE, π, (PM, cmi, ct))
send (compute,Pi, ct) to PM
Finalize: On receiving (finalize, π, inM, out,{coin

from PM:

assert current time T ≥ T2
for every Pi that has not called compute, set cmi := ⊥
statement := (inM, out,{cmi, coin
assert NIZK.Verify(LFINALIZE, π, statement)
for i ∈ [N ]:
i /∈ Coins
(cid:2)
assert coin
(cid:2)
i to Coins
add coin
send (finalize, coin

i, cti) to Pi
(cid:2)
Call φpub.check(inM, out)

i, cti}i∈[N ])
(cid:2)

i, cti}i∈[N ])
(cid:2)

Blockchaincash: include Blockchaincash
φpub : include user-deﬁned public contract φpub
Relation (statement, witness) ∈ LFREEZE is deﬁned as:

parse statement as (P, MT.root, sn, cm)
parse witness as (coin, skprf, branch, s, $val, in, k, s(cid:2))
coin := Comms($val)
assert MerkleBranch(MT.root, branch, (P(cid:8)coin))
assert P.pkprf = skprf(0)
assert sn = PRFskprf (P(cid:8)coin)
assert cm = Comms(cid:2) ($val(cid:8)in(cid:8)k)

Relation (statement, witness) ∈ LCOMPUTE is deﬁned as:

parse statement as (PM, cm, ct)
parse witness as ($val, in, k, s(cid:2), r)
assert cm = Comms(cid:2) ($val(cid:8)in(cid:8)k)
assert ct = ENC(PM.epk, r, ($val(cid:8)in(cid:8)k(cid:8)s(cid:2)))

i}i∈[N ], out) := φpriv({$vali, ini}i∈[N ], inM)
(cid:2)
(cid:2)

Relation (statement, witness) ∈ LFINALIZE is deﬁned as:
parse statement as (inM, out,{cmi, coin
i, cti}i∈[N ])
(cid:2)
parse witness as {si, $vali, ini, s(cid:2)
i, ki}i∈[N ]
({$val
i∈[N ] $val
assert
for i ∈ [N ]:
assert cmi = Commsi ($vali(cid:8)ini(cid:8)ki))
assert cti = SENCki (s(cid:2)
(cid:2)
i = Comms(cid:2)
assert coin

∨($vali, ini, ki, si, cmi) = (0,⊥,⊥,⊥,⊥)

i(cid:8)$val
(cid:2)
i)
(cid:2)
($val
i)

i∈[N ] $vali =

(cid:2)

(cid:2)
i

i

Protocol UserPhawk(PM,{Pi}i∈[N ], T1, T2, φpriv, φpub)
Init: Call UserPcash.Init.
Protocol for a party P ∈ {Pi}i∈[N ]:
Freeze: On input (freeze, $val, in) as party P:

assert current time T < T1
assert this is the ﬁrst freeze input
let MT be a merkle tree over Blockchaincash.Coins
assert that some entry (s, $val, coin) ∈ Wallet for some
(s, coin)
remove one (s, $val, coin) from Wallet
sn := PRFskprf (P(cid:8)coin)
let branch be the branch of (P, coin) in MT
sample a symmetric encryption key k
sample a commitment randomness s(cid:2)
cm := Comms(cid:2) ($val(cid:8)in(cid:8)k)
statement := (P, MT.root, sn, cm)
witness := (coin, skprf, branch, s, $val, in, k, s(cid:2))
π := NIZK.Prove(LFREEZE, statement, witness)
send (freeze, π, sn, cm) to G(Blockchainhawk)
store in, cm, $val, s(cid:2)
assert current time T1 ≤ T < T2
sample encryption randomness r
ct := ENC(PM.epk, r, ($val(cid:8)in(cid:8)k(cid:8)s(cid:2)))
π := NIZK.Prove((PM, cm, ct), ($val, in, k, s(cid:2), r))
send (compute, π, ct) to G(Blockchainhawk)
decrypt (s(cid:8)$val) := SDECk(ct)
store (s, $val, coin) in Wallet
output (finalize, $val)

, and k to use later (in compute)

Finalize: Receive (finalize, coin, ct) from G(Blockchainhawk):

Compute: On input (compute) as party P:

Protocol for manager PM:
Compute: On receive (compute,Pi, ct) from G(Blockchainhawk):

decrypt and store ($vali(cid:8)ini(cid:8)ki(cid:8)si) := DEC(esk, ct)
store cmi := Commsi ($vali(cid:8)ini(cid:8)ki)
output (Pi, $vali, ini)
If this is the last compute received:
for i ∈ [N ] such that Pi has not called compute,
($vali, ini, ki, si, cmi) := (0,⊥,⊥,⊥,⊥)
i}i∈[N ], out) := φpriv({$vali, ini}i∈[N ], inM)
({$val
(cid:2)
store and output ({$val
i}i∈[N ], out)
(cid:2)
Finalize: On input (finalize, inM, out):
assert current time T ≥ T2
for i ∈ [N ]:
sample a commitment randomness s(cid:2)
(cid:2)
(cid:2)
i := Comms(cid:2)
i)
($val
coin
i(cid:8)$val
cti := SENCki (s(cid:2)
(cid:2)
i)
statement := (inM, out,{cmi, coin
i, cti}i∈[N ])
(cid:2)
witness := {si, $vali, ini, s(cid:2)
i, ki}i∈[N ]
π := NIZK.Prove(statement, witness)
send (finalize, π, inM, out,{coin
i, cti})
(cid:2)

i

i

to G(Blockchainhawk)

UserPcash: include UserPcash.

Fig. 6. Blockchainhawk and UserPhawk construction.

848848

When a corrupted party P∗ pours to an honest party P, even
though the adversary knows the opening of the coin, it cannot
spend the coin (P, coin) once the transaction takes effect by
the Blockchaincash, since P∗ cannot demonstrate knowledge
of P’s secret key. We stress that since the contract binds the
owner’s nym P to the coin, only the owner can spend it even
when the opening of coin is disclosed.
Technical subtleties. Our Blockchaincash uses a modiﬁed ver-
sion of Zerocash to achieve stronger security in the simulation
paradigm. In comparison, Zerocash adopts a strictly weaker,
indistinguishability-based privacy notion called ledger indis-
tinguishability. In multi-party protocols, indistinguishability-
based security notions are strictly weaker than simulation
security. Not only so, the particular ledger indistinguishability
notion adopted by Zerocash [11] appears subtly questionable
upon scrutiny, which we elaborate on in the online ver-
sion [37]. This does not imply that the Zerocash construction
is necessarily insecure – however, there is no obvious path
to proving their scheme secure under a simulation based
paradigm.
B. Binding Privacy and Programmable Logic

So far, Blockchaincash, similar to Zerocash [11], only sup-
ports direct money transfers between users. We allow transac-
tional privacy and programmable logic simutaneously.
Freeze. We support a new operation called freeze, that does
not spend directly to a user, but commits the money as well
as an accompanying private input to a smart contract. This is
done using a pour-like protocol:
• The user P chooses a private coin (P, coin) ∈ Coins, where
coin := Comms($val). Using its secret key, P computes the
serial number sn for coin – to be disclosed with the freeze
operation to prevent double-spending.
• The user P computes a commitment (val||in||k) to the
contract where in denotes its input, and k is a symmetric
encryption key that is introduced due to a practical opti-
mization explained later in Section V.
• The user P now makes a zero-knowledge proof attesting to
similar statements as in a pour operation, i.e., that the spent
coin exists in the pool Coins, the sn is correctly constructed,
and that the val committed to the contract equals the value
of the coin being spent. See LFREEZE in Figure 6 for details
of the NP statement being proven.

Compute. Next, computation takes place off-chain to compute
the payout distribution {val
i}i∈[n] and a proof of correctness.
(cid:3)
In Hawk, we rely on a minimally trusted manager PM to
perform computation. All parties would open their inputs to
the manager PM, and this is done by encrypting the opening
to the manager’s public key:

ct := ENC(PM.epk, r, ($val(cid:4)in(cid:4)k(cid:4)s(cid:3)))

The ciphertext ct is submitted to the smart contract along with
appropriate zero-knowledge proofs of correctness. While the
user can also directly send the opening to the manager off-
chain, passing the ciphertext ct through the smart contract

849849

would make any aborts evident such that the contract can
ﬁnancially punish an aborting user.
After obtaining the openings, the manager now computes
the payout distribution {val
i}i∈[n] and public output out by
(cid:3)
applying the private contract φpriv. The manager also constructs
a zero-knowledge proof attesting to the outcomes.
Finalize. When the manager submits the outcome of φpriv
and a zero-knowledge proof of correctness to Blockchainhawk,
Blockchainhawk veriﬁes the proof and redistributes the frozen
money accordingly. Here Blockchainhawk also passes the man-
ager’s public input inM and public output out to the public
Hawk contract φpub. The public contract φpub can be invoked
to check the validity of the manager’s input, as well as
redistribute public collateral deposit.
Theorem 1. Assuming that the hash function in the Merkle
tree is collision resistant,
the commitment scheme Comm
is perfectly binding and computationally hiding, the NIZK
scheme is computationally zero-knowledge and simulation
sound extractable, the encryption schemes ENC and SENC
are perfectly correct and semantically secure, the PRF scheme
PRF is secure, then, our protocols in Figures 5 and 6 securely
emulates the ideal functionality F(IdealPhawk) against a ma-
licious adversary in the static corruption model.
Proof. Deferred to our online version [37].

C. Extensions and Discussions
Refunding frozen coins to users.
In our implementation,
we extend our basic scheme to allow the users to reclaim
their frozen money after a timeout T3 > T2. To achieve this,
user P simply sends the contract a newly constructed coin
(P, coin := Comms($val)) and proves in zero-knowledge that
its value $val is equal to that of the frozen coin. In this case,
the user can identify the previously frozen coin in the clear,
i.e., there is no need to compute a zero-knowledge proof of
membership within the frozen pool as is needed in a pour
transaction.
Instantiating the manager with trusted hardware. In some
applications, it may be a good idea to instantiate the manager
using trusted hardware such as the emerging Intel SGX. In this
case, the off-chain computation can take place in a secret SGX
enclave that is not visible to any untrusted software or users.
Alternatively, in principle, the manager role can also be split
into two or more parties that jointly run a secure computation
protocol – although this approach is likely to incur higher
overhead.

We stress that our model is fundamentally different from
placing full trust in any centralized node. Trusted hardware
cannot serve as a replacement of the blockchain. Any off-
chain only protocol that does not interact with the blockchain
cannot offer ﬁnancial fairness in the presence of aborts – even
when trusted hardware is employed.

Furthermore, even the use of SGX does not obviate the need
for our cryptographic protocol. If the SGX is trusted only by
a subset of parties (e.g., just the parties to a particular private
contact), rather than globally, then those users can beneﬁt from

the efﬁciency of an SGX-managed private contract, while still
utilizing the more widely trusted underlying currency.
Pouring anonymously to long-lived pseudonyms. In our
basic formalism of IdealPcash, the pour operation discloses
the recipient’s pseudonyms to the adversary. This means that
IdealPcash only retains full privacy if the recipient generates
a fresh, new pseudonym every time. In comparison, Zero-
cash [11] provides an option of anonymously spending to a
long-lived pseudonym (in other words, having IdealPcash not
reveal recipients’ pseudonyms to the adversary).

the transfer is subsequent

It would be straightforward to add this feature to Hawk as
well (at the cost of a constant factor blowup in performance);
however, in most applications (e.g., a payment made after
receiving an invoice),
to some
interaction between the recipient and sender.
Open enrollment of pseudonyms. In our current formalism,
parties’ pseudonyms are hardcoded and known a priori. We can
easily relax this to allow open enrollment of any pseudonym
that joins the contract (e.g., in an auction). Our implementation
supports open enrollment. Due to SNARK’s preprocessing,
right now, each contract
instance must declare an upper-
bound on the number of participants. An enrollment fee
can potentially be adopted to prevent a DoS attack where
the attacker joins the contract with many pseudonyms thus
preventing legitimate users from joining. How to choose the
correct fee amount to achieve incentive compatibility is left as
an open research challenge. The a priori upper bound on the
number of participants can be avoided if we adopt recursively
composable SNARKs [18], [25] or alternative proofs that do
not require circuit-dependent setup [16].

V. ADOPTING SNARKS IN UC PROTOCOLS AND

PRACTICAL OPTIMIZATIONS

A. Using SNARKs in UC Protocols

Succinct Non-interactive ARguments of Knowledge [12],
[33], [49] provide succinct proofs for general computation
tasks, and have been implemented by several systems [12],
[49], [56]. We would like to use SNARKs to instantiate the
NIZK proofs in our protocols — unfortunately, SNARK’s
security is too weak to be directly employed in UC protocols.
Speciﬁcally, SNARK’s knowledge extractor is non-blackbox
and cannot be used by the UC simulator to extract witnesses
from statements sent by the adversary and environment —
doing so would require that the extractor be aware of the
environment’s algorithm, which is inherently incompatible
with UC security.

UC protocols often require the NIZKs to have simulation
extractability. Although SNARKs do not satisfy simulation
extractability, Kosba et al. show that it is possible to apply
efﬁcient SNARK-lifting transformations to construct simula-
tion extractable proofs from SNARKs [38]. Our implementa-
tions thus adopt the efﬁcient SNARK-lifting transformations
proposed by Kosba et al. [38].

850850

B. Practical Considerations
Efﬁcient SNARK circuits. A SNARK prover’s performance
is mainly determined by the number of multiplication gates
in the algebraic circuit to be proven [12], [49]. To achieve
efﬁciency, we designed optimized circuits through two ways:
1) using cryptographic primitives that are SNARK-friendly,
i.e. efﬁciently realizable as arithmetic circuits under a speciﬁc
SNARK parametrization. 2) Building customized circuit gen-
erators to produce SNARK-friendly implementations instead
of relying on compilers to translate higher level implementa-
tion.

The main cryptographic building blocks in our system are:
collision-resistant hash function for the Merkle trees, pseudo-
random function, commitment, and encryption. Our imple-
mentation supports both 80-bit and 112-bit security levels. To
instantiate the CRH efﬁciently, we use an Ajtai-based SNARK-
friendly collision-resistant hash function that is similar to the
one used by Ben-Sasson et al. [14]. In our implementation, the
modulus q is set to be the underlying SNARK implementation
254-bit ﬁeld prime, and the dimension d is set to 3 for the 80-
bit security level, and to 4 for the 112-bit security level based
on the analysis in [38]. For PRFs and commitments, we use
a hand-optimized implementation of SHA-256. Furthermore,
we adopt the SNARK-friendly primitives for encryption used
in the study by Kosba et al. [38], in which an efﬁcient circuit
for hybrid encryption in the case of 80-bit security level was
proposed. The circuit performs the public key operations in a
prime-order subgroup of the Galois ﬁeld extension Fpμ, where
μ = 4, p is the underlying SNARK ﬁeld prime (typically 254-
bit prime, i.e. pμ is over 1000-bit ), and the prime order of the
subgroup used is 398-bit prime. This was originally inspired
by Pinocchio coin [26]. The circuit then applies a lightweight
cipher like Speck [10] or Chaskey-LTS [47] with a 128-bit key
to perform symmetric encryption in the CBC mode, as using
the standard AES-128 instead will result in a much higher
cost [38]. For the 112-bit security, using the same method for
public key operations requires intensive factorization to ﬁnd
suitable parameters, therefore we use a manually optimized
RSA-OAEP encryption circuit with a 2048-bit key instead.
In the next section, we will illustrate how using SNARK-
friendly implementations can lead to 2.0-3.7× savings in the
size of the circuits at the 80-bit security level, compared to
the case when naive straightforward implementation are used.
We will also illustrate that the performance is also practical
in the higher security level case.
Optimizations for finalize.
In addition to the SNARK-
friendly optimizations, we focus on optimizing the O(N )-
sized finalize circuit since this is our main performance
bottleneck. All other SNARK proofs in our scheme are for
O(1)-sized circuits. Two key observations allow us to greatly
improve the performance of the proof generation during
finalize.
Optimization 1: Minimize SSE-secure NIZKs. First, we ob-
serve that in our proof, the simulator need not extract any new
witnesses when a corrupted manager submits proofs during a

finalize operation. All witnesses necessary will have been
learned or extracted by the simulator at this point. Therefore,
we can employ an ordinary SNARK instead of a stronger
simulation sound extractable NIZK during finalize. For
freeze and compute, we still use the stronger NIZK. This
optimization reduces our SNARK circuit sizes by 1.5× as can
be inferred from Figure 9 of Section VI, after SNARK-friendly
optimizations are applied.
Optimization 2: Minimize public-key encryption in SNARKs.
Second, during finalize, the manager encrypts each party
Pi’s output coins to Pi’s key, resulting in a ciphertext cti.
The ciphertexts {cti}i∈[N ] would then be submitted to the
contract along with appropriate SNARK proofs of correctness.
Here,
if a public-key encryption is employed to generate
the cti’s, it would result in relatively large SNARK circuit
size. Instead, we rely on a symmetric-key encryption scheme
denoted SENC in Figure 6. This requires that the manager
and each Pi perform a key exchange to establish a symmetric
key ki. During an compute, the user encrypts this ki to the
manager’s public key PM.epk, and prove that the k encrypted
is consistent with the k committed to earlier in cmi. The
SNARK proof during finalize now only needs to include
commitments and symmetric encryptions instead of public key
encryptions in the circuit – the latter much more expensive.
This second optimization additionally gains us a factor of
1.9× as shown in Figure 9 of Section VI after applying the
previous optimizations. Overall, all optimizations will lead to
a gain of more than 10× in the finalize circuit.
Remarks about the common reference string. SNARK
schemes require the generation of a common reference string
(CRS) during a pre-processing step. This common reference
string consists of an evaluation key for the prover, and a
veriﬁcation key for the veriﬁer. Unless we employ recursively
composed SNARKs [18], [25] whose costs are signiﬁcantly
higher, the evaluation key is circuit-dependent, and its size
is proportional
the
veriﬁcation key is O(|in| + |out|) in size, i.e., depends on
the total length of inputs and outputs, but independent of the
circuit size. We stress that only the veriﬁcation key portion of
the CRS needs to be included in the public contract that lives
on the blockchain.

to the circuit’s size.

In comparison,

We remark that the CRS for protocol UserPcash is shared
globally, and can be generated in a one-time setup. In com-
the CRS for each Hawk contract would depend
parison,
on the Hawk contract, and therefore exists per instance of
Hawk contract. To minimize the trust necessary in the CRS
generation, one can employ either trusted hardware or use
secure multi-party computation techniques as described by
Ben-Sasson et al. [13].

Finally, in the future when new primitives become sufﬁ-
ciently fast, it is possible to drop-in and replace our SNARKs
with other primtives that do not require per-circuit preprocess-
ing. Examples include recursively composed SNARKs [18],
[25] or other efﬁcient PCP constructions [16]. The commu-
nity’s efforts at optimizing these constructions are underway.

851851

Program 

Φpriv

Compile 



.. 

Augment 

Private Input 
Private inCoin Values 
Private outCoin Values 
Symmetric Enc Key 
Public statement  
(seen by contract) 
randomness 

T/F? 

Balance 
Check 

.. 



Comm 

Enc 

Comm 

Enc 

Comm 

.. 

Comm 

To Libsnark 

Fig. 7. Compiler overview. Circuit augmentation for finalize.

VI. IMPLEMENTATION AND EVALUATION

A. Compiler Implementation

Our compiler consists of several steps, which we illustrate

in Figure 7 and describe below:
Preprocessing: First, the input Hawk program is split into its
public contract and private contract components. The public
contract is Serpent code, and can be executed directly atop
an ordinary cryptocurrency platform such as Ethereum. The
private contract is written in a subset of the C language,
and is passed as input to the Pinocchio arithmetic circuit
compiler [49]. Keywords such as HawkDeclareParties are
implemented as C preprocessors macros, and serve to de-
ﬁne the input (Inp) and output (Outp) datatypes. Currently,
our private contract inherits the limitations of the Pinocchio
compiler, e.g., cannot support dynamic-length loops. In the
future, we can relax these limitations by employing recursively
composition of SNARKs.
Circuit Augmentation: After compiling the preprocessed pri-
vate contract code with Pinocchio, we have an arithmetic
circuit representing the input/output relation φpriv. This be-
comes a subcomponent of a larger arithmetic circuit, which we
assemble using a customized circuit assembly tool. This tool
is parameterized by the number of parties and the input/output
datatypes, and attaches cryptographic constraints, such as
computing commitments and encryptions over each party’s
output value, and asserting that the input and output values
satisfy the balance property.
Cryptographic Protocol: Finally,
the augmented arithmetic
circuit is used as input to a state-of-the-art zkSNARK library,
Libsnark [15]. To avoid implementing SNARK veriﬁcation
in Ethereum’s Serpent
language, we must add a SNARK
veriﬁcation opcode to Ethereum’s stack machine. We ﬁnally
compile an executable program for the parties to compute the
Libsnark proofs according to our protocol.
B. Additional Examples

Besides our running example of a sealed-bid auction (Fig-
ure 2), we implemented several other examples in Hawk,
demonstrating various capabilities:
Crowdfunding: A Kickstarter-style crowdfunding campaign,
(also known as an assurance contract in economics litera-
ture [9]) overcomes the “free-rider problem,” allowing a large

TABLE I

Performance of the zk-SNARK circuits for the user-side circuits: pour,

freeze AND compute (SAME FOR ALL APPLICATIONS). MUL denotes

multiple (4) cores, and ONE denotes a single core. The mint operation does

not involve any SNARKs, and can be computed within tens of

microseconds. The Proof includes any additional cryptographic material

used for the SNARK-lifting transformation.

80-bit security

112-bit security

KeyGen(s) MUL 26.3
ONE 88.2
Prove(s) MUL 12.4
ONE 27.5
9.7

Verify(ms)

pour freeze compute pour freeze compute
34.6
131.8
16.8
41.7
9.9

15.9
36.7
54.42 137.2
18.5
42.2
9.9

30.5
111.1
15.7
40.5
9.3

18.2
63.3
8.4
20.7
9.1

9.3
22.5
10.0

EvalKey(MB)
VerKey(KB)
Proof(KB)
Stmt(KB)

148
7.3
0.68
0.48

106
4.4
0.68
0.16

90
7.8
0.68
0.53

236
8.7
0.71
0.57

189
5.3
0.71
0.19

224
8.4
0.71
0.53

number of parties to contribute funds towards some social
good. If the minimum donation target is reached before the
deadline, then the donations are transferred to a designated
party (the entrepreneur); otherwise, the donations are refunded.
Hawk preserves privacy in the following sense: a) the do-
nations pledged are kept private until the deadline; and b)
if the contract fails, only the manager learns the amount by
which the donations were insufﬁcient. These privacy properties
may conceivably have a positive effect on the willingness
of entrepreneurs to launch a crowdfund campaign and its
likelihood of success.
Rock Paper Scissors: A two-player lottery game, and natu-
rally generalized to an N-player version. Our Hawk imple-
mentation provides the same notion of ﬁnancial fairness as
in [7], [17] and provides stronger security/privacy guarantees.
If any party (including the manager), cheats or aborts, the
remaining honest parties receive the maximum amount they
might have won otherwise. Furthermore, we go beyond prior
works [7], [17] by concealing the players’ moves and the
pseudonym of the winner to everyone except the manager.
“Swap” Financial Instrument: An individual with a risky
investment portfolio (e.g, one who owns a large number
of Bitcoins) may hedge his risks by purchasing insurance
(e.g., by effectively betting against the price of Bitcoin with
another individual). Our example implements a simple swap
instrument where the price of a stock at some future date
(as reported by a trusted authority speciﬁed in the public
contract) determines which of two parties receives a payout.
The private contract ensures the privacy of both the details of
the agreement (i.e., the price threshold) and the outcome.
The full Hawk programs for these examples are provided in
our online version [37].

C. Performance Evaluation

We evaluated the performance for various examples, using
an Amazon EC2 r3.8xlarge virtual machine. We assume
a maximum of 264 leaves for the Merkle trees, and we

Performance of the zk-SNARK circuits for the manager circuit

finalize for different applications. The manager circuits are the same
for both security levels. MUL denotes multiple (4) cores, and ONE denotes a

TABLE II

single core.

swap rps

auction crowdfund

#Parties
KeyGen(s) MUL

Prove(s) MUL
ONE

Verify(ms)

2

2

10

10

100

100
8.6 8.0 32.3 300.4 32.16 298.1
ONE 27.8 24.9 124 996.3 124.4 976.5
15.2 169.2
40.3 377.5
19.8

3.2 3.1 15.4 169.3
7.6 7.4 40.1 384.2
8.4 8.4
19.9

10

10

EvalKey(GB)
VerKey(KB)
Proof(KB)
Stmt(KB)

1.92 0.21

0.04 0.04 0.21
3.3 2.9 12.9 113.8
0.28 0.28 0.28
0.22 0.2 1.03

0.28 0.28
9.47 1.03

1.91
12.9 113.8
0.28
9.47

Naïve

SNARK-friendly Impl.

2.6x

1.0x

1.0x

2.0x

1.0x

1.5

)
n
o

i
l
l
i

2.3x

 

m
1
 
x
(
 
s
e
t
a
g

 
l

u
m

 
f
o
 
r
e
b
m
u
N

1

0.5

0

pour

freeze

compute

Fig. 8. Gains of using SNARK-friendly implementation for the user-side
circuits: pour, freeze and compute at 80-bit security.

present results for both 80-bit and 112-bit security levels. Our
benchmarks actually consume at most 27GB of memory and 4
cores in the most expensive case. Tables I and II illustrate the
results – we focus on evaluating the zk-SNARK performance
since all other computation time is negligible in comparison.
We highlight some important observations:

• On-chain computation (dominated by zk-SNARK veriﬁca-
tion time) is very small in all cases, ranging from 9 to 20
milliseconds The running time of the veriﬁcation algorithm

10.5x

Naïve
SNARK-friendly Impl.
With Opt 1
With Opt 2 (overall)

10.5x

10.5x

2.8x

1.9x 1.0x

2.8x

1.9x

1.0x

2.8x

1.9x

1.0x

80

)
n
o

i
l
l
i

 

m
1
 
x
(
 
s
e
t
a
g

 
l

u
m

 
f
o
 
r
e
b
m
u
N

60

40

20

0

Auction (25)

Auction (50)

Auction (100)

Fig. 9. Gains after adding each optimization to the finalize auction
circuit, with 25, 50 and 100 Bidders. Opt 1 and Opt 2 are two practical
optimizations detailed in Section V.

852852

is just linearly dependent on the size of the public statement,
which is far smaller than the size of the computation,
resulting into small veriﬁcation time.

• On-chain public parameters: As mentioned in Sec-
tion IV-C, not the entire SNARK common reference string
(CRS) need to be on the blockchain, but only the veriﬁcation
key part of the CRS needs to be on-chain. Our imple-
mentation suggests the following: the private cash protocol
requires a veriﬁcation key of 23KB to be stored on-chain –
this veriﬁcation key is globally shared and there is only a
single instance. Besides the globally shared public param-
eters, each Hawk contract will additionally require 13-114
KB of veriﬁcation key to be stored on-chain, for 10 to 100
users. This per-contract veriﬁcation key is circuit-dependent,
i.e., depends on the contract program. We refer the readers
to Section IV-C for more discussions on techniques for
performing trusted setup.

• Manager computation: Running private auction or crowd-
funding protocols with 100 participants requires under
6.5min proof time for the manager on a single core, and
under 2.85min on 4 cores. This translates to under $0.14 of
EC2 time [2].

• User computation: Users’ proof times for pour, freeze
and compute are under one minute, and independent of the
number of parties. Additionally, in the worst case, the peak
memory usage of the user is less than 4 GB.

Savings from protocol optimizations. Figure 8 illustrates
the performance gains attained by using a SNARK-friendly
implementation for the user-side circuits, i.e. pour, freeze
and compute w.r.t. the naive implementation at the 80-bit
security level. We calculate the naive implementation cost
using conservative estimates for the straightforward implemen-
tation of standard cryptographic primitives. The ﬁgure shows a
gain of 2.0-2.6× compared to the naive implementation. Fur-
thermore, Figure 9 illustrates the performance gains attained
by our protocol optimizations described in Section V The
ﬁgure considers the sealed-bid auction ﬁnalize circuit at dif-
ferent number of bidders. We show that the SNARK-friendly
implementation along with our two optimizations combined
signiﬁcantly reduce the SNARK circuit sizes, and achieve a
gain of 10× relative to a straightforward implementation. The
ﬁgure also illustrates that the manager’s cost is proportional
to the number of participants. (By contrast, the user-side costs
are independent of the number of participants).

VII. ADDITIONAL THEORETICAL RESULTS

Last but not the least, we present additional theoretical
results to fruther illustrate the usefulness of our formal block-
chain model. In the interest of space, we defer details to the
online version [37], and only state the main ﬁndings here.
Fair MPC with public deposits in the generic blockchain
model. As is well-understood, fairness is in general impossible
in plain models of multi-party computation when the majority
can be corrupted. This was ﬁrst observed by Cleve [24]
and later extended in subsequent papers [8]. Assuming a

853853

TABLE III

Additional theoretical results for fair MPC with public deposits. The
table assumes that N parties wish to securely compute 1 bit of output that
will be revealed to all parties at the end. For collateral, we assume that each

aborting party must pay all honest parties 1 unit of currency.

claim-or-refund [17] multi-lock [40]

On-chain cost
# rounds
Total collateral

O(N 2)
O(N )
O(N 2)

O(N 2)
O(1)
O(N 2)

generic

blockchain

O(N)
O(1)
O(N2)

blockchain trusted for correctness and availability (but not
for privacy), an interesting notion of fairness which we refer
to as “ﬁnancial fairness” can be attained as shown by recent
works [7], [17], [40]. In particular, the blockchain can ﬁnan-
cially penalize aborting parties by conﬁscating their deposits.
Earlier works in this space [7], [17], [40], [50] focus on
protocols that retroﬁt the artifacts of Bitcoin’s limited scripting
language. Speciﬁcally, a few works use Bitcoin’s scripting
language to construct intermediate abstractions such as “claim-
or-refund” [17] or “multi-lock” [40], and build atop these
abstractions to construct protocols. Table VII shows that by
assuming a generic blockchain model where the blockchain
can run Turing-complete programs, we can improve the efﬁ-
ciency of ﬁnancially fair MPC protocols.
Fair MPC with private deposits. We further illustrate how to
perform ﬁnancially fair MPC using private deposits, i.e., where
the amount of deposits cannot be observed by the public. The
formal deﬁnitions, constructions, and proofs are supplied in
the online version [37].

ACKNOWLEDGMENTS

We gratefully acknowledge Jonathan Katz, Rafael Pass,
and abhi shelat for helpful technical discussions about the
zero-knowledge proof constructions. We also acknowledge
Ari Juels and Dawn Song for general discussions about
cryptocurrency smart contracts. This research is partially sup-
ported by NSF grants CNS-1314857, CNS-1445887, CNS-
1518765, CNS-1514261, CNS-1526950, a Sloan Fellowship,
three Google Research Awards, Yahoo! Labs through the
Faculty Research Engagement Program (FREP) and a NIST
award.

REFERENCES

[1] http://koinify.com.
[2] Amazon ec2 pricing. http://aws.amazon.com/ec2/pricing/.
[3] Augur. http://www.augur.net/.
[4] bitoinj. https://bitcoinj.github.io/.
[5] The rise and rise of bitcoin. Documentary.
[6] Skuchain. http://www.skuchain.com/.
[7] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L. Mazurek.

Secure Multiparty Computations on Bitcoin. In S&P, 2013.

[8] G. Asharov, A. Beimel, N. Makriyannis, and E. Omri. Complete
characterization of fairness in secure two-party computation of boolean
functions. In TCC, 2015.

[9] M. Bagnoli and B. L. Lipman.

Provision of public goods: Fully
implementing the core through private contributions. The Review of
Economic Studies, 1989.

[17] I. Bentov and R. Kumaresan. How to Use Bitcoin to Design Fair

[49] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly

[41] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi. ObliVM: A

programming framework for secure computation. In S&P, 2015.

[42] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy, G. M.
Voelker, and S. Savage. A ﬁstful of bitcoins: characterizing payments
among men with no names. In IMC, 2013.

[43] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous

Distributed E-Cash from Bitcoin. In S&P, 2013.

[44] A. Miller, M. Hicks, J. Katz, and E. Shi. Authenticated data structures,

generically. In POPL, 2014.

[45] A. Miller and J. J. LaViola Jr. Anonymous Byzantine Consensus from

Moderately-Hard Puzzles: A Model for Bitcoin, 2014.

[46] M. S. Miller, C. Morningstar, and B. Frantz. Capability-based ﬁnancial

instruments. In FC, 2001.

[47] N. Mouha, B. Mennink, A. Van Herrewege, D. Watanabe, B. Preneel,
and I. Verbauwhede. Chaskey: An efﬁcient mac algorithm for 32-bit
microcontrollers. In Selected Areas in Cryptography–SAC 2014, pages
306–323. Springer, 2014.

[48] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. http:

//bitcoin.org/bitcoin.pdf, 2009.

practical veriﬁable computation. In S&P, 2013.

[50] R. Pass and abhi shelat. Micropayments for peer-to-peer currencies. In

CCS, 2015.

[51] A. Rastogi, M. A. Hammer, and M. Hicks. Wysteria: A programming
In S&P,

language for generic, mixed-mode multiparty computations.
2014.

[52] D. Ron and A. Shamir. Quantitative Analysis of the Full Bitcoin

Transaction Graph. In FC, 2013.

[53] N. Szabo. Formalizing and securing relationships on public networks.

First Monday, 1997.

[54] N. van Saberhagen. Cryptonote v 2.0. https://goo.gl/kfojVZ, 2013.
[55] W. Vickrey.

Counterspeculation, auctions, and competitive sealed

tenders. Journal of ﬁnance, 1961.

[56] R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh.
Efﬁcient RAM and control ﬂow in veriﬁable outsourced computation.
In NDSS, 2015.

[57] G. Wood. Ethereum: A secure decentralized transaction ledger. http:

//gavwood.com/paper.pdf.

[58] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using replication

and partitioning to build secure distributed systems. In S&P, 2003.

[59] G. Zyskind, O. Nathan, and A. Pentland.

Enigma: Decentralized

computation platform with guaranteed privacy.

[10] R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and
L. Wingers. The simon and speck families of lightweight block ciphers.
http://ia.cr/2013/404.

[11] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza. Zerocash: Decentralized anonymous payments from
Bitcoin. In S&P, 2014.

[12] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. Snarks
for C: verifying program executions succinctly and in zero knowledge.
In CRYPTO, 2013.

[13] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure
sampling of public parameters for succinct zero knowledge proofs. In
S&P, 2015.

[14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero

knowledge via cycles of elliptic curves. In CRYPTO, 2014.

[15] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-
interactive zero knowledge for a von neumann architecture. In Security,
2014.

[16] E. Ben-Sasson and M. Sudan. Short pcps with polylog query complexity.

SIAM J. Comput., 2008.

Protocols. In CRYPTO, 2014.

[18] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive compo-
sition and bootstrapping for snarks and proof-carrying data. In STOC,
2013.

[19] D. Bogdanov, S. Laur, and J. Willemson. Sharemind: A Framework for

Fast Privacy-Preserving Computations. In ESORICS. 2008.

[20] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and
E. W. Felten. Research Perspectives and Challenges for Bitcoin and
Cryptocurrencies. In S&P, 2015.

[21] R. Canetti. Universally composable security: A new paradigm for

cryptographic protocols. In FOCS, 2001.

[22] R. Canetti. Universally composable signature, certiﬁcation, and authen-

tication. In CSF, 2004.

[23] R. Canetti, Y. Dodis, R. Pass, and S. Walﬁsh. Universally composable

security with global setup. In TCC. 2007.

[24] R. Cleve. Limits on the security of coin ﬂips when half the processors

are faulty. In STOC, 1986.

[25] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile veriﬁable
computation. In S & P, 2015.

[26] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno. Pinocchio Coin:
In

building Zerocoin from a succinct pairing-based proof system.
PETShop, 2013.

[27] C. Decker and R. Wattenhofer. Bitcoin transaction malleability and

mtgox. In ESORICS. Springer, 2014.

[28] A. K. R. Dermody and O. Slama. Counterparty announcement. https:

//bitcointalk.org/index.php?topic=395761.0.

[29] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is

vulnerable. In FC, 2014.

[30] C. Fournet, M. Kohlweiss, G. Danezis, and Z. Luo. Zql: A compiler for

privacy-preserving data processing. In USENIX Security, 2013.

[31] M. Fredrikson and B. Livshits. Zø: An optimizing distributing zero-

knowledge compiler. In USENIX Security, 2014.

[32] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone

protocol: Analysis and applications. In Eurocrypt, 2015.

[33] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span

programs and succinct NIZKs without PCPs. In Eurocrypt, 2013.

[34] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg. Eclipse attacks on

bitcoin’s peer-to-peer network. In USENIX Security, 2015.

[35] A. Juels, A. Kosba, and E. Shi. The ring of gyges: Using smart contracts

for crime. Manuscript, 2015.

[36] A. Kiayias, H.-S. Zhou, and V. Zikas. Fair and robust multi-party

computation using a global transaction ledger. http://ia.cr/2015/574.

[37] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk:
The blockchain model of cryptography and privacy-preserving smart
contracts. http://ia.cr/2015/675.

[38] A. Kosba, Z. Zhao, A. Miller, H. Chan, C. Papamanthou, R. Pass,
abhi shelat, and E. Shi. How to use snarks in universally composable
protocols. https://eprint.iacr.org/2015/1093, 2015.

[39] B. Kreuter, B. Mood, A. Shelat, and K. Butler. PCF: A portable circuit

format for scalable two-party secure computation. In Security, 2013.

[40] R. Kumaresan and I. Bentov. How to Use Bitcoin to Incentivize Correct

Computations. In CCS, 2014.

APPENDIX A

FREQUENTLY ASKED QUESTIONS

we address frequently asked questions. Some of this con-
tent repeats what is already stated earlier, but we hope that
addressing these points again in a centralized section will help
reiterate some important points that may be missed by a reader.

A. Motivational
“How does Hawk’s programming model differ from
Ethereum?” Our high-level approach may be superior than
Ethereum: Ethereum’s language deﬁnes the blockchain pro-
gram, where Hawk allows the programmer to write a single
global program, and Hawk auto-generates not only the block-
chain program, but also the protocols for users.
“Why not spin off the formal blockchain modeling into
a separate paper?” The blockchain formal model could be
presented on its own, but we gain evidence of its usefulness
by implementing it and applying it to interesting practical
examples. Likewise our system implementation beneﬁts from
the formalism because we can use our framework to provide
provable security.

854854

B. Technical
“SNARKs do not offer simulation extractability required
for UC.” See Section V-A as well as Kosba et al. [38].
SNARK’s common reference string. See discussions in
Section V-B.
“Why are the recipient pseudonyms P1 and P2 revealed
to the adversary? And what about Zerocash’s persistent
addresses feature?” See discussions in Section IV-C.
“Isn’t the manager a trusted-third party?” No, our man-
ager is not a trusted third party. As we mention upfront
in Sections I-A and I-B, the manager need not be trusted
for correctness and input independence. Due to our use of
zero-knowledge proofs, if the manager deviates from correct
behavior, it will get caught.

Further, each contract instance can choose its own manager,
and the manager of one contract instance cannot affect the
security of another contract instance. Similarly, the manager
also need not be trusted to retain the security of the crypto-
currency as a whole. Therefore, the only thing we trust the
manager for is posterior privacy.

As mentioned in Section IV-C we note that one can possi-
bly rely on secure multi-party computation (MPC) to avoid
having to trust
the manager even for posterier privacy –
however such a solution is unlikely to be practical in the
near future, especially when a large number of parties are
involved. The thereotical formulation of this full-generality
MPC-based approach is detailed in the online version [37].
In our implementation, we made a conscious design choice
and opted for the approach with a minimally trusted manager
(rather than MPC), since we believe that this is a desirable
sweet-spot that simultaneously attains practical efﬁciency and
strong enough security for realistic applications. We stress that
practical efﬁciency is an important goal of Hawk’s design.

In Section IV-C, we also discuss practical considerations
for instantiating this manager. For the reader’s convenience,
we iterate: we think that a particularly promising choice is to
rely on trusted hardware such as Intel SGX to obtain higher
assurance of posterior privacy. We stress again that even when
we use the SGX to realize the manager, the SGX should not
have to be trusted for retaining the global security of the
cryptocurrency. In particular, it is a very strong assumption to
require all participants to globally trust a single or a handful
of SGX prcessor(s). With Hawk’s design, the SGX is only
very minimally trusted, and is only trusted within the scope
of the current contract instance.

APPENDIX B

FORMAL TREATMENT OF PROTOCOLS IN THE

BLOCKCHAIN MODEL

We are the ﬁrst to propose a UC model for the blockchain
model of cryptography. First, our model allows us to easily
capture the time and pseudonym features of cryptocurrencies.
In cryptocurrencies such as Bitcoin and Ethereum, time pro-
gresses in block intervals, and the blockchain can query the
current time, and make decisions accordingly, e.g., make a

855855

refund operation after a timeout. Second, our model captures
the role of a blockchain as a party trusted for correctness and
availability but not for privacy. Third, our formalism modular-
izes our notations by factoring out common speciﬁcs related
to the smart contract execution model, and implementing these
in central wrappers.

For simplicity, we assume that there can be any number
of identities in the system, and that they are ﬁxed a priori.
It is easy to extend our model to capture registration of new
identities dynamically. We allow each identity to generate an
arbitrary (polynomial) number of pseudonyms as in Bitcoin
and Ethereum.
A. Programs, Functionalities, and Wrappers

To make notations simple for writing ideal functionalities
and smart contracts, we make a conscious notational choice of
introducing wrappers. Wrappers implement in a central place
a set of common features (e.g., timer, ledger, pseudonyms) that
are applicable to all ideal functionalities and contracts in our
blockchain model of execution. In this way, we can modularize
our notational system such that these common and tedious
details need not be repeated in writing ideal, blockchain and
user/manager programs.
Blockchain functionality wrapper G: A blockchain function-
ality wrapper G(B) takes in a blockchain program denoted B,
and produces a blockchain functionality. Our real world proto-
cols will be deﬁned in the G(B)-hybrid world. Our blockchain
functionality wrapper is formally presented in Figure 11. We
point out the following important facts about the G(·) wrapper:
• Trusted for correctness and availability but not privacy.
The bloc kchain functionality wrapper G(·) stipulates that a
blockchain program is trusted for correctness and availabil-
ity but not for privacy. In particular, the blockchain wrapper
exposes the blockchain program’s internal state to any party
that makes a query.

• Time and batched processing of messages. In popular de-
centralized cryptocurrencies such as Bitcoin and Ethereum,
time progresses in block intervals marked by the creation
of each new block. Intuitively, our G(·) wrapper captures
the following fact. In each round (i.e., block interval), the
blockchain program may receive multiple messages (also
referred to as transactions in the cryptocurrency literature).
The order of processing these transactions is determined
by the miner who mines the next block. In our model, we
allow the adversary to specify an ordering of the messages
collected in a round, and our blockchain program will then
process the messages in this adversary-speciﬁed ordering.
• Rushing adversary. The blockchain wrapper G(·) naturally
captures a rushing adversary. Speciﬁcally, the adversary
can ﬁrst see all messages sent to the blockchain program
by honest parties, and then decide its own messages for
this round, as well as an ordering in which the blockchain
program should process the messages in the next round.
Modeling a rushing adversary is important, since it captures
a class of well-known front-running attacks, e.g., those that
exploit transaction malleability [11], [27]. For example, in

F(idealP) functionality

Given an ideal program denoted idealP, the F(idealP) functionality is deﬁned as below:
Init: Upon initialization, perform the following:

Time. Set current time T := 0. Set the receive queue rqueue := ∅.
Pseudonyms. Set nyms := {(P1, P1), . . . , (PN , PN )}, i.e., initially every party’s true identity is recorded as a default
pseudonym for the party.
Ledger. A ledger dictionary structure ledger[P ] stores the endowed account balance for each identity P ∈ {P1, . . . , PN}.
Before any new pseudonyms are generated, only true identities have endowed account balances. Send the array ledger[]
to the ideal adversary S.
idealP.Init. Run the Init procedure of the idealP program.

Tick: Upon receiving tick from an honest party P : notify S of (tick, P ). If the functionality has collected tick
conﬁrmations from all honest parties since the last clock tick, then

Call the Timer procedure of the idealP program.
Apply the adversarial permutation perm to the rqueue to reorder the messages received in the previous round.
For each (m, ¯P ) ∈ rqueue in the permuted order, invoke the delayed actions (in gray background) deﬁned by ideal
program idealP at the activation point named “Upon receiving message m from pseudonym ¯P ”. Notice that the program
idealP speaks of pseudonyms instead of party identiﬁers. Set rqueue := ∅.
Set T := T + 1
Assert that ( ¯P , P ) ∈ nyms.
Invoke the immediate actions deﬁned by ideal program idealP at the activation point named “Upon receiving message
m from pseudonym ¯P ”.
Queue the message by calling rqueue.add(m, ¯P ).

Other activations: Upon receiving a message of the form (m, ¯P ) from a party P :

Permute: Upon receiving (permute, perm) from the adversary S, record perm.
GetTime: On receiving gettime from a party P , notify the adversary S of (gettime, P ), and return the current time T
to party P .
GenNym: Upon receiving gennym from an honest party P : Notify the adversary S of gennym. Wait for S to respond with
a new nym ¯P such that ¯P /∈ nyms. Now, let nyms := nyms ∪ {(P, ¯P )}, and send ¯P to P . Upon receiving (gennym, ¯P )
from a corrupted party P : if ¯P /∈ nyms, let ¯P := nyms ∪ {(P, ¯P )}.

Ledger operations: // inner activation
Transfer: Upon receiving (transfer, amount, ¯Pr) from some pseudonym ¯Ps:

Notify (transfer, amount, ¯Pr, ¯Ps) to the ideal adversary S.
Assert that ledger[ ¯Ps] ≥ amount.
ledger[ ¯Ps] := ledger[ ¯Ps] − amount
ledger[ ¯Pr] := ledger[ ¯Pr] + amount

/* ¯Ps, ¯Pr can be pseudonyms or true identities. Note that each party’s identity is a default pseudonym for the party. */
Expose: On receiving exposeledger from a party P , return ledger to the party P .

Fig. 10. The F (idealP) functionality is parameterized by an ideal program denoted idealP. An ideal program idealP can specify two types of activation points,
immediate activations and delayed activations. Activation points are invoked upon recipient of messages. Immediate activations are processed immediately,
whereas delayed activations are collected and batch processed in the next round. The F (·) wrapper allows the ideal adversary S to specify an order perm in
which the messages should be processed in the next round. For each delayed activation, we use the leak notation in an ideal program idealP to deﬁne the
leakage which is immediately exposed to the ideal adversary S upon recipient of the message.

a “rock, paper, scissors” game, if inputs are sent in the
clear, an adversary can decide its input based on the other
party’s input. An adversary can also try to maul transactions
submitted by honest parties to potentially redirect payments
to itself. Since our model captures a rushing adversary,
we can write ideal functionalities that preclude such front-
running attacks.

functionality wrapper F: An ideal

Ideal
functionality
F(idealP) takes in an ideal program denoted idealP. Specif-
ically, the wrapper F(·) part deﬁnes standard features such

as time, pseudonyms, a public ledger, and money transfers
between parties. Our ideal functionality wrapper is formally
presented in Figure 10.
Protocol wrapper Π: Our protocol wrapper allows us to
modularize the presentation of user protocols. Our protocol
wrapper is formally presented in Figure 12.
Terminology. For disambiguation, we always refer to the
user-deﬁned portions as programs. Programs alone do not
have complete formal meanings. However, when programs
are wrapped with functionality wrappers (including F(·)

856856

G(B) functionality

Given a blockchain program denoted B, the G(B) functionality is deﬁned as below:
Init: Upon initialization, perform the following:

A ledger data structure ledger[ ¯P ] stores the account balance of party ¯P . Send the entire balance ledger to A.
Set current time T := 0. Set the receive queue rqueue := ∅.
Run the Init procedure of the B program.
Send the B program’s internal state to the adversary A.

Tick: Upon receiving tick from an honest party, if the functionality has collected tick conﬁrmations from all honest
parties since the last clock tick, then

Apply the adversarial permutation perm to the rqueue to reorder the messages received in the previous round.
Call the Timer procedure of the B program.
Pass the reordered messages to the B program to be processed. Set rqueue := ∅.
Set T := T + 1
Other activations:
• Authenticated receive: Upon receiving a message (authenticated, m) from party P :

• Pseudonymous receive: Upon receiving a message of the form (pseudonymous, m, ¯P , σ) from any party:

Send (m, P ) to the adversary A
Queue the message by calling rqueue.add(m, P ).
Send (m, ¯P , σ) to the adversary A
Parse σ := (nonce, σ(cid:3)), and assert Verify( ¯P .spk, (nonce, T, ¯P .epk, m), σ(cid:3)) = 1
If message (pseudonymous, m, ¯P , σ) has not been received earlier in this round, queue the message by calling
rqueue.add(m, ¯P ).
Send m to the adversary A
If m has not been seen before in this round, queue the message by calling rqueue.add(m).

• Anonymous receive: Upon receiving a message (anonymous, m) from party P :

Permute: Upon receiving (permute, perm) from the adversary A, record perm.
Expose: On receiving exposestate from a party P , return the functionality’s internal state to the party P . Note that this
also implies that a party can query the functionality for the current time T .

Ledger operations: // inner activation
Transfer: Upon recipient of (transfer, amount, ¯Pr) from some pseudonym ¯Ps:

Assert ledger[ ¯Ps] ≥ amount
ledger[ ¯Ps] := ledger[ ¯Ps] − amount
ledger[ ¯Pr] := ledger[ ¯Pr] + amount

Fig. 11. The G(B) functionality is parameterized by a blockchain program denoted B. The G(·) wrapper mainly performs the following: i) exposes all of
its internal states and messages received to the adversary; ii) makes the functionality time-aware: messages received in one round and queued and processed
in the next round. The G(·) wrapper allows the adversary to specify an ordering to the messages received by the blockchain program in one round.
and G(·)), we obtain functionalities with well-deﬁned formal
meanings. Programs can also be wrapped by a protocol
wrapper Π to obtain a full protocol with formal meanings.

B. Modeling Time

At a high level, we express time in a way that conforms
to the Universal Composability framework [21]. In the ideal
world execution,
time is explicitly encoded by a variable
T in an ideal functionality F(idealP). In the real world
execution, time is explicitly encoded by a variable T in our
blockchain functionality G(B). Time progresses in rounds. The
environment E has the choice of when to advance the timer.
We assume the following convention: to advance the timer,
the environment E sends a “tick” message to all honest parties.
Honest parties’ protocols would then forward this message
to F(idealP) in the ideal-world execution,
or to the G(B)

functionality in the real-world execution. On collecting “tick”
messages from all honeset parties, the F(idealP) or G(B)
functionality would then advance the time T := T + 1. The
functionality also allows parties to query the current time T .
When multiple messages arrive at the blockchain in a time
interval, we allow the adversary to choose a permutation
to specify the order in which the blockchain will process
the messages. This captures potential network attacks such
as delaying message propagation, and front-running attacks
(a.k.a. rushing attacks) where an adversary determines its own
message after seeing what other parties send in a round.

C. Modeling Pseudonyms

We model a notion of “pseudonymity” that provides a form
of privacy, similar to that provided by typical cryptocurren-
cies such as Bitcoin. Any user can generate an arbitrary

857857

Pseudonym related:

Π(UserP) protocol wrapper in the G(B)-hybrid world
Given a party’s local program denoted prot, the Π(prot) functionality is deﬁned as below:
GenNym: Upon receiving input gennym from the environment E, generate (epk, esk) ← Keygenenc(1λ), and (spk, ssk) ←
Keygensign(1λ). Call payload := prot.GenNym(1λ, (epk, spk)). Store nyms := nyms ∪ {(epk, spk, payload)}, and output
(epk, spk, payload) as a new pseudonym.
Send: Upon receiving internal call (send, m, ¯P ):
If ¯P == P : send (authenticated, m) to G(B).
Else,
Assert that pseudonym ¯P has been recorded in nyms;
Query current time T from G(B). Compute σ(cid:3) := Sign(ssk, (nonce, T, epk, m)) where ssk is the recorded secret signing
key corresponding to ¯P , nonce is a freshly generated random string, and epk is the recorded public encryption key
corresponding to ¯P . Let σ := (nonce, σ(cid:3)).
Send (pseudonymous, m, ¯P , σ) to G(B).

// this is an authenticated send

// this is a pseudonymous send

AnonSend: Upon receiving internal call (anonsend, m, ¯P ): send (anonymous, m) to G(B).
Transfer: Upon receiving input (transfer, $amount, ¯Pr, ¯P ) from the environment E:
Assert that ¯P is a previously generated pseudonym.
Send
Tick: Upon receiving tick from the environment E, forward the message to G(B).
Act as pseudonym: Upon receiving any input of the form (m, ¯P ) from the environment E:

to G(B) as pseudonym ¯P .

Timer and ledger transfers:

transfer, $amount, ¯Pr

Other activations:

(cid:2)

(cid:3)

Assert that ¯P was a previously generated pseudonym.
Pass (m, ¯P ) the party’s local program to process.

Others: Upon receiving any other input from the environment E, or any other message from a party: Pass the input/message
to the party’s local program to process.

Fig. 12. Protocol wrapper.

of their pseudonyms, as described above. Additionally, “anon-
send” allows a user to publish a message without reference to
any pseudonym at all.

In spite of pseudonymity, it is sometimes desirable to assign
a particular user to a speciﬁc role in a blockchain program
(e.g., “auction manager”). The alternative is to assign roles
on a “ﬁrst-come ﬁrst-served” basis (e.g., as the bidders in an
auction). To this end, we allow each party to deﬁne generate
a single “default” pseudonym which is publicly-bound to
their real identity. We allow applications to make use of this
through a convenient abuse of notation, by simply using a
party identiﬁer as a parameter or hardcoded string. Strictly
speaking, the pseudonym string is not determined until the
“gennym” subroutine is executed; the formal interpretation is
that whenever such an identity is used, the default pseudonym
associated with the identity is fetched from the blockchain
program. (This approach is effectively the same as taken by
Canetti [22], where a functionality FCA allows each party to
bind their real identity to a single public key of their choice).
Additional appendices are supplied in the online full ver-
sion [37].

(polynomially-bounded) number of pseudonyms, and each
pseudonym is “owned” by the party who generated it. The
correspondence of pseudonyms to real identities is hidden
from the adversary.

Effectively, a pseudonym is a public key for a digital
signature scheme, and the corresponding private key is known
by the party who “owns” the pseudonym. The blockchain
functionality allows parties to publish authenticated messages
that are bound to a pseudonym of their choice. Thus each inter-
action with the blockchain program is, in general, associated
with a pseudonym but not to a user’s real identity.

We abstract away the details of pseudonym management
by implementing them in our wrappers. This allows user-
deﬁned applications to be written very simply, as though
using ordinary identities, while enjoying the privacy beneﬁts
of pseudonymity.

Our wrapper provides a user-deﬁned hook, “gennym”, that
is invoked each time a party creates a pseudonym. This
allows the application to deﬁne an additional per-pseudonym
payload, such as application-speciﬁc public keys. From the
point-of-view of the application, this is simply an initialization
subroutine invoked once for each participant.

Our wrapper provides several means for users to communi-
cate with a blockchain program. The most common way is for
a user to publish an authenticated message associated with one

858858

