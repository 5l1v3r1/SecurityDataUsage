Zero-Knowledge Using Garbled Circuits
∗
or How To Prove Non-Algebraic Statements Efﬁciently

Marek Jawurek
SAP, Karlsruhe

Germany

marek@jawurek.net

Florian Kerschbaum

SAP, Karlsruhe

Germany

ﬂorian.kerschbaum@sap.com

Claudio Orlandi
Aarhus University
orlandi@cs.au.dk

Denmark

ABSTRACT
Zero-knowledge protocols are one of the fundamental con-
cepts in modern cryptography and have countless applica-
tions. However, after more than 30 years from their intro-
duction, there are only very few languages (essentially those
with a group structure) for which we can construct zero-
knowledge protocols that are eﬃcient enough to be used in
practice.

In this paper we address the problem of how to construct
eﬃcient zero-knowledge protocols for generic languages and
we propose a protocol based on Yao’s garbled circuit tech-
nique.

The motivation for our work is that in many cryptographic
applications it is useful to be able to prove eﬃciently state-
ments of the form e.g., “I know x s.t. y = SHA-256(x)” for
a common input y (or other “unstructured” languages), but
no eﬃcient protocols for this task are currently known.

It is clear that zero-knowledge is a subset of secure two-
party computation (i.e., any protocol for generic secure com-
putation can be used to do zero-knowledge). The main con-
tribution of this paper is to construct an eﬃcient protocol
for the special case of secure two-party computation where
only one party has input (like in the zero-knowledge case).
The protocol achieves active security and is essentially only
twice as slow as the passive secure version of Yao’s garbled
circuit protocol. This is a great improvement with respect
to the cut-n-choose technique to make Yao’s protocol ac-
tively secure, where the complexity grows linearly with the
security parameter.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—
Cryptographic controls; C.2.4 [Computer-Communication
Networks]: Distributed Systems—distributed applications

∗A full version of this paper is available at [JKO13].

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516662 .

Keywords
Zero-Knowledge Proof; Garbled Circuits; Eﬃciency

1.

INTRODUCTION

Zero-knowledge (ZK) protocols have countless applications
in cryptography and therefore eﬃciency is of paramount im-
portance. Consequently, a huge eﬀort has been put into
designing eﬃcient ZK protocols for speciﬁc tasks.
In par-
ticular there are very eﬃcient protocols for languages with
some algebraic structure. There are, for instance, eﬃcient
protocols for proving knowledge and relations of discrete log-
arithms [Sch89, CDS94], for proving that RSA public keys
are well formed [CM99], for statements in post-quantum
cryptography [BD10, JKPT12, MV03], for bilinear equa-
tions [GS12, GSW10], for shuﬄes [BG12, KMW12] and frame-
works for modular design of zero-knowledge protocols [CKS11].

However, generic constructions for ZK protocols use Karp
reductions to NP-complete languages and are therefore too
impractical to be used in practice.
In particular, so far
there has been no practical solution to problems that do
not exhibit an algebraic structure. Examples for proto-
cols that could be used in many cryptographic applications
are e.g., the problem of eﬃciently proving statements of
the form “I know x s.t. y = SHA-256(x)” or “I know k
s.t. y1 = AESk(y2)” (the common input is y in the ﬁrst
example and (y1, y2) in the second)1.

In this work we provide a generic and eﬃcient solution
for proving any such statements in zero-knowledge, by con-
structing a protocol based on Yao’s garbled circuits tech-
nique. The complexity of our protocol is proportional to the
size of the circuit of the NP veriﬁcation function. To sup-
port the validity of our eﬃciency claim, we present also a
proof-of-concept implementation of our protocol. The per-
formance measurements of our prototypical implementation
show the viability of our protocol for realistic problems.
1.1 Zero-Knowledge and 2PC

Zero-knowledge proofs were introduced more than 30 years
ago by Goldwasser, Micali and Rackoﬀ [GMR85]. A zero-
knowledge argument (ZK) is an interactive protocol that
allows a prover P to persuade a veriﬁer V of the valid-
ity of some NP statement y by using the knowledge of a
witness w. Informally, an honest prover should be able to

1Note that in both cases the prover is not only showing that
the instance belongs to the language (both languages are
trivial), but moreover that the prover knows a valid witness
for this. So these proofs are meaningful as we believe that
it is hard to compute such a witness.

955convince an honest veriﬁer of the validity of the statements
(completeness). Moreover, a zero-knowledge protocol should
give guarantees against corrupted parties: Even a malicious
prover cannot persuade an honest veriﬁer of a false state-
ment (soundness) and even a malicious veriﬁer does not
learn anything from the execution of the protocol, except
for the validity of the statement itself, hence the name “zero-
knowledge”.

Approximately at the same time, Yao [Yao82] introduced
the problem of two-party secure computation (2PC) and
showed how to solve it using the famous “garbled circuits”
construction. In 2PC the parties hold secret inputs x1 and
x2 respectively and want to jointly compute some function
z = f (x1, x2) while keeping their inputs secret.

Observe that ZK is a proper subset of 2PC: ZK is an
instance of 2PC where there is an asymmetry between the
parties and only P holds an input w (the witness for the NP
statement) and where the function fy(w) outputs accept iﬀ
w is a valid witness for y (note that y here is not a secret,
and therefore is not considered as an input but as part of
the circuit description).

However, with few notable exception (see the related work
in Section 1.6), the techniques used to implement eﬃcient
zero-knowledge protocols and the techniques used to imple-
ment eﬃcient secure computation are very diﬀerent from
each other.
1.2 ZK with 2PC techniques

From a very high-level point of view, our construction
works as follows: V and P run the standard (passive-secure)
Yao protocol, where V acts as the circuit constructor and P
acts as the circuit evaluator. After the evaluation P sends
V the output key (this step can be seen as a conditional
disclosure of secret [GIKM98, AIR01]). The security of
Yao’s protocol implies that a computationally bounded P
cannot guess the output key corresponding to the output
value accept unless he has a valid witness for y.

This ﬁrst, partial solution works in the case of a semi-
honest veriﬁer and it is described in Section 3. However,
this protocol is not zero-knowledge against a malicious V ,
who can mount all the well-known active attacks against
Yao’s protocol (garbling a function diﬀerent than the one
he is supposed to, selective failure attack during the input
phase [KS06] etc.).
1.3 Actively secure ZK

To make our protocol actively secure one can use oﬀ-the-
shelf solutions for two-party computation with active secu-
rity, like the cut-n-choose technique.
In cut-n-choose, the
circuit constructor sends multiple copies of the circuit to
the circuit evaluator, who chooses a random subset of the
circuits. Then the circuit constructor “opens” the chosen
garbled circuits so that the other party can verify that they
garble the correct function, and then they evaluate the re-
maining unopened garbled circuits. However even with the
most recent versions of cut-n-choose (e.g. [FJN+13, Lin13,
HKE13]), the complexity of the resulting protocol still grows
with the statistical security parameter and this represents a
big drawback in practice.

Our approach for active security is diﬀerent and takes ad-
vantage of the diﬀerence between ZK and 2PC. In the case
of ZK the veriﬁer V (i.e., the circuit constructor), has no
secrets. Therefore, after the protocol is completed, V can

“open” the circuit and let P verify that it computes the right
function. This allows to achieve active security by using only
a single garbled circuit.
1.4 Protocol idea

In a nutshell our actively secure protocol works as follows:
P and V run the OTs, where P uses as inputs the bits of
his witness, and V inputs the keys for the input layer of
the garbled circuit. Then V sends the garbled circuit (if
the employed OT has two rounds, the garbled circuit can be
sent with the second message of the OT). Now the prover
can evaluate the circuit and retrieve the output key Z cor-
responding to the circuit output being “accept” or “reject”.
However, the prover does not reveal this key just yet.
It
rather commits to it and waits with revealing the actual
value until after the veriﬁer “opens” the garbled circuit and
the prover can check the honesty of the veriﬁer. Note that
we need the OT protocol to have “committing” properties, as
it is important for the prover to verify that the keys revealed
in this stage are consistent with the ones used previously in
the OT phase.
1.5 Applications

Private-key cryptographic primitives (such as block ci-
phers and hash functions) are orders of magnitude faster
than their public-key counterparts: this is mostly due to the
fact that the algebraic structure of many number-theoretic
assumptions allows for more eﬃcient attacks than those for
symmetric primitives. Therefore to achieve the same level
of security, the parameters used in public key cryptography
are much bigger than the ones used in symmetric key cryp-
tography.

However this extra algebraic structure allows for the con-
struction of naturally eﬃcient protocols and advanced func-
tionalities. For example, AES encryption is much faster
than RSA encryption. However, if one wants to be able
to prove that the encrypted message has a particular struc-
ture (for instance, in escrow applications) one needs to take
into account the eﬃciency of the zero-knowledge protocol
as well, and therefore public-key primitives are sometimes
favoured over symmetric key primitives because the public
key schemes are compatible with the most eﬃcient zero-
knowledge protocols. The results of this paper change the
state of things and allow for proving statements about cryp-
tographic protocols with no algebraic structure in an prac-
tically eﬃcient way.

As a motivating real life example, consider the following
event: In 2010 Julian Assange released a “thermonuclear ﬁle
insurance” i.e., a 1.4GB ﬁle allegedly consisting of an AES
encryption of highly sensitive information. This encrypted
data has been released as a countermeasure to protect Wiki-
Leaks from being shut down by the U.S. government. The
ﬁle had been extensively distributed using peer-to-peer ap-
plication, and therefore simply releasing the encryption key
would allow a great number of people to have access to this
secret information. Note that it is important that the secret
key is short, and can therefore be released in a very short
time and with a wide variety of means, if one wants to.

It is natural to wonder whether this is just an empty
threat (i.e., the ﬁle just contains random data) or whether
the encrypted ﬁle really contains sensitive information. To
show that the ﬁle actually contains sensitive information,
one could imagine a randomized check in which the veriﬁer

956Informal Description for Zero-Knowledge Using Garbled Circuits

OT-Choose(cid:0){wi}i
(cid:9)

 OT-Transfer(cid:0)(cid:8)K0

i , K1
i

(cid:1)
(cid:1) , GC

i

Veriﬁer’s input y

- (cid:0)GC,(cid:8)K0

i , K1
i

(cid:9)

i , Z(cid:1) ← Garble(cid:0)1k, fy

(cid:1)

Prover’s input (y, w)

Z(cid:48) ← Evaluate(cid:0)GC,(cid:8)Kwi

i

(cid:9)

(cid:1)

i

(cid:9)

C = Commit (Z(cid:48))

(cid:8)K0
Verify(cid:0)fy, GC,(cid:8)K0

i , K1
i

i = OT-OpenAll()

i , K1
i

i


if
then:
else:

-

(cid:9)

(cid:1) = 1

Reveal Z(cid:48)
reject

-

Output (Z(cid:48) ?

= Z).

Figure 1: An informal description of our zero-knowledge protocol.

asks to see the decryption of a random, but small portion
of the ﬁle. To do this without releasing the decryption key
a zero-knowledge protocol that “works well” with AES is
required.

Finally, consider the Fiat-Shamir [FS86] heuristic for NIZK
or signatures, widely used in practice due to its extreme ef-
ﬁciency.
In many application it is desirable to prove that
“I know a proof of x” or “I have a signature on m” with-
out revealing the proof/signature. Doing so requires an eﬃ-
cient way to prove non-algebraic statement about the hash-
functions used to instantiate the random oracle in the Fiat-
Shamir construction.
1.6 Related Work

As discussed before, although zero-knowledge and secure
computation are clearly related, few works have been ex-
ploiting MPC techniques in zero-knowledge protocols. Some
few notable exceptions are listed here.
Ishai, Kushilevitz,
Ostrovsky and Sahai [IKOS07] use MPC protocols for hon-
est majority to achieve eﬃcient zero-knowledge protocols;
their idea is to have the prover simulate “in its head” n
parties running an MPC protocol for the veriﬁcation func-
tion and commit to their internal states. Then the veriﬁer
gets to pick a subset of the parties and checks that their
state is consistent with an accepting veriﬁcation. Intuitively,
given that the MPC protocol is secure against a minority
of passively-corrupted players, the proof is zero-knowledge.
This allows to construct zero-knowledge protocols with very
good asymptotic complexity. However, as the authors goal is
to optimize for asymptotic complexity, IKOS use tools that
are rather cumbersome in practice (see the full version for
a detailed comparison.). Designing a “practically eﬃcient”
protocol in the IKOS framework is an interesting open prob-
lem.

Gennaro, Gentry and Parno [GGP10] combine garbled cir-
cuits with fully-homomorphic encryption to obtain a ver-
iﬁable computation protocol but due to the use of fully-
homomorphic encryption this protocol is far from being prac-
tical. Bitansky and Paneth [BP12] also use Yao garbled
circuits in order to achieve zero-knowledge protocols, how-
ever their constructions fall short of the goal and they only
achieve witness hiding and weak zero-knowledge (two strictly
weaker properties than zero-knowledge). Moreover, their
construction uses point obfuscation as a tool, and there-

fore their security reduction makes non black-box use of
the adversary and requires non-standard cryptographic as-
sumptions. This is inherent, as their goal is to build 3-
round protocols and it is known that black-box 3-round zero-
knowledge is impossible under standard assumptions [GK96].
By relaxing the requirement on round-complexity we achieve
full zero-knowledge using only standard assumptions and a
black-box security reduction.

A number of papers investigate the feasibility (e.g., [GOS06a,

GOS06b]) and the eﬃciency (e.g., [Gro10, Lip12, GGPR13])
of non-interactive zero-knowledge proofs for SAT. On the
positive side, those protocols are non-interactive. On the
negative side, all these protocols require expensive public
key operations (exponentiations and pairings) for each gate
in the circuit, and therefore our protocol is more eﬃcient
in practice, as it can be seen from the timings reported
in [PHGR13]. It is a very interesting open problem to con-
struct a protocol that is non-interactive and only uses cheap
(symmetric) cryptographic primitives at the same time.
1.7 Structure

The remainder of this paper is structured as follows: Sec-
tion 2 introduces and deﬁnes preliminaries for the presenta-
tion of our protocol. Section 3 then presents our protocol
for an honest veriﬁer as a warm-up. Then, in Section 4, we
build upon that and present our actively secure protocol for
a malicious veriﬁer. Finally, in Section 5 we describe a pro-
totype implementation and the results of our experiments
regarding its performance.
2. PRELIMINARIES

Let [n] = {1, . . . , n}. If S is a set x ∈R S denotes a uni-
formly random element sampled from S. We call a function
 : N → R+ negligible if for every polynomial p and big
enough n, (n) < 1/p(n).
Let L ⊂ {0, 1}∗ be a language in NP and ML be the
language veriﬁcation function i.e., for all y ∈ L there exist a
string w of length polynomial in the size of y s.t. ML(y, w) =
accept and for all y (cid:54)∈ L, w ∈ {0, 1}∗ then ML(y, w) =
reject.
2.1 Deﬁning Security

We use the standard security notion for static, active (ma-
licious) adversaries deﬁned as indistinguishability between

957the real world (where the adversary interacts with a hon-
est party) and the ideal world (where the adversary inter-
acts with a simulator with access to the ideal functionality),
see [Can00, Can01, Gol04]. We will write our proofs in an
hybrid model where real world parties have oracle access to
a given functionality, while in the ideal world the simulator
“controls” this functionality. We use the standard commit-
ment functionality and slight augmentation of the oblivious
transfer (OT) functionality.

All our simulators are straight-line and the protocols a-
chieve UC-security [Can01] when instantiated with UC se-
cure oblivious transfers, for instance [PVW08, DNO08].

For the sake of simplicity, we neglect some details from
our ideal functionalities, such as the fact that all the com-
munication can be deleted and delayed by the adversary.
This has no impact on our proofs as we only prove static
security.
2.2 Zero-Knowledge: The Ideal Functionality
We deﬁne the task of zero-knowledge with an ideal func-
tionality, as in [Can01]. This is a convenient way of deﬁning
all the properties we want from a zero-knowledge protocol
(including the proof-of-knowledge property) in a compact
way.

The ideal functionality F R

ZK

• F R
ZK is parametrized by a binary relation R.
• On input (prove, sid, x, w) from P and (verify, sid, x(cid:48))
from V , if x = x(cid:48) and R(x, w) = 1 output (verified, x)
to V .

Figure 2: The ideal functionality F R
Knowledge

ZK for Zero-

The ideal functionality FCOT

Choose: On input (choose, id, b) from the receiver, with b ∈
{0, 1}, if no messages of the form (choose, id, ·) is present
in memory, store (choose, id, b) and send (chosen, id) to
the sender.

Transfer: On input

(transfer, id, tid, m0, m1)

from the
sender, with m0, m1 ∈ {0, 1}k, if no messages of the
form (transfer, id, tid, ·, ·) is present in memory and
a message of the form (choose, id, b) is stored, send
(transferred, id, tid, mb) to the receiver.

Open-all: On input (open-all) from the sender, reveal all
messages (transfer, id, m0, m1) to the receiver. Then
the functionality halts and does not reply to any further
command.

Figure 3: The ideal functionality FCOT for OT with
Sender Veriﬁability

2.3 A Weak Flavor of Committing Oblivious

Transfer

One of the ingredients in our construction is a ﬂavor of
oblivious transfer, deﬁned in Figure 3. Similar primitives ap-
peared in literature under the name of veriﬁable OT [Cr´e89],
committed OT [CvdGT95], authenticated OT [NNOB12] just
to name a few. The main diﬀerence here is that we only
need to have commitments to the sender’s input, and not
the receiver, like in the notion of committing OT [KS06]. In

The ideal functionality FCOM

Commit: On input (commit, id, m) from the sender, with
m ∈ {0, 1}∗, if no messages of the form (commit, id, ·)
is present in memory, store (commit, id, m) and send
(committed, id, |m|) to the receiver.

Reveal: On input (reveal, id) from the sender, if a message
of the form (commit, id, m) is present in memory send
(reveal, id, m) to the receiver.

Figure 4: The ideal functionality FCOM for commit-
ment

fact, our ﬂavor of OT is even weaker than committing OT,
as we do not need to have individual commitments to the
messages. The only extra property we need is that after all
the OTs have been performed, the sender can reveal all its
input messages to the receiver and cannot lie about them.
This can in general be achieved by letting the sender com-
mit to a seed in the beginning of the protocol, and then run
any secure OT protocol using the output of a pseudorandom
generator on the seed as its random tape. Then the open-
all phase can be implemented by simply letting the sender
reveal the seed and all the messages.

In Appendix A we show how some “natural” (and eﬃcient)
OT protocols already satisfy this extra property and securely
implement the FCOT functionality.
2.4 Commitment
We describe the protocol in an hybrid model where parties
have access to the FCOM functionality. The FCOM function-
ality can be implemented in a black-box way given the FCOT
functionality2, or it is also possible to implement directly
UC commitment in an eﬃcient way using e.g., the proto-
col in [Lin11]). The (standard) commitment functionality is
presented for completeness in Figure 4.
2.5 Garbling Scheme Requirements

We follow and extend the deﬁnition of garbled circuits
by Bellare et al. [BHR12b]. A veriﬁable projective garbling
scheme is deﬁned by a tuple G = (Gb, En, De, Ev, ev, Ve)3
such that:

• The garbled circuit generation function Gb is a ran-
domized algorithm that on input a security parame-
ter 1k and the description of a Boolean function f :
{0, 1}n → {0, 1}, with n = poly(k) and |f| = poly(k)
outputs a triple of strings (GC, e, d).

• The algorithm ev allows to evaluate the function de-

scribed by f i.e., ev(f, x) = f (x).

• The encoding function En is a deterministic function
that uses e to map an input x to a garbled input X.
In this paper we will only be concerned with projective

schemes where e = (cid:0){K 0

(cid:1) and the garbled

i , K 1

i }i∈[n]

2The committer inputs her message at the choice bit in the
OT, while the veriﬁer inputs two random strings as the mes-
sages of the OT. To decommit, the received random message
is revealed. To break the binding property one would have
to guess the message that was not chose in the OT, thus
breaking the security of the OT protocol.
3A standard garbling scheme as deﬁned by Bellare et al.
does not contain the Ve procedure.

958input X is simply {K xi
further use the En function in the paper.

i }i∈[n], and therefore we will not

• The evaluation function Ev is a deterministic function
that evaluates a garbled circuit GC on an encoded in-
put X and produces an encoded output Z(cid:48).

• The decoding function De, using the string d, decodes
the encoded output Z(cid:48) into a plaintext output z. In
this paper we are only interested in whether z = 1 (i.e.,
the NP relation accepts), therefore we let d = Z(cid:48) and
De(d, Z) outputs z = 1 if Z(cid:48) ?= Z or z = 0 otherwise
(we will drop the De notation from now on).

• In addition to the standard algorithms, a veriﬁable gar-
bled scheme has an extra procedure Ve that, on input
garbled circuit GC, a description of a Boolean function
f : {0, 1}n → {0, 1} and the input encoding informa-
tion e = {K 0

i }i∈[n] outputs accept or reject.

i , K 1

The correctness and security deﬁnitions that we are going
to provide are very similar to those given by Bellare et al.,
but they are relaxed to be as loose as they can while being
suﬃcient for our goal. The hope is that our relaxed deﬁni-
tions can be achieved by simpler or more eﬃcient garbling
schemes that do not achieve the deﬁnitions given by Bellare
et al.

Definition 1

(Correctness). Let G be a veriﬁable pro-
jective garbling scheme described as above. We say that G
enjoys correctness if for all n = poly(k), f : {0, 1}n → {0, 1}
and all x ∈ {0, 1}n s.t. f (x) = 1 the following probability

(cid:18) Ev(GC,{K xi

(GC,{K 0

Pr

i }i∈[n]) (cid:54)= Z :
i }i, Z) ← Gb(1k, f )

i , K 1

(cid:19)

(cid:19)

is negligible in k.

Intuitively, Deﬁnition 1 says that it is possible to recover
the secret Z by evaluating a honestly generated circuit with
input keys corresponding to a value x such that f (x) = 1.
This is clearly implied by the standard correctness require-
ment that asks for correctness on all possible values of x.

Definition 2

(Soundness). Let G be a garbling scheme
described as above. We say that G enjoys authenticity if for
all n = poly(k), f : {0, 1}n → {0, 1} and all pairs x ∈ {0, 1}n
s.t. f (x) = 0 and for all PPT A, the following probability:

(cid:18) A(f, x, GC,{K xi

(GC,{K 0

i , K 1

Pr

i }i∈[n]) = Z :

i }i, Z) ← Gb(1k, f )

is negligible in k.

Intuitively, Deﬁnition 2 (which is a more succinct way of
describing the “authenticity” property of Bellare et al., when
restricted to our setting) says that no malicious evaluator
can extract the secret Z unless she has access to input keys
corresponding to a value x such that f (x) = 1.

Definition 3

(Verifiability). Let G be a garbling scheme

described as above. We say that G enjoys veriﬁability if for
all n = poly(k), f : {0, 1}n → {0, 1} and all x, y ∈ {0, 1}n
with x (cid:54)= y and f (x) = f (y) = 1 and for all PPT A the
probability:

 Ev(GC,{K xi

Ev(GC,{K yi
Ve(f, GC,{K 0
(GC,{K 0
i , K 1

Pr

i }i∈[n]) (cid:54)=
i }i∈[n]) :
i , K 1
i }i∈[n]) ← A(1k, f )

i }i∈[n]) = accept



is negligible in k.

In addition, we require the existence of a expected polyno-
mial time algorithm Ext s.t., for all x satisfying f (x) = 1
the probability:

 Ext(GC,{K 0

Ev(GC,{K xi
Ve(f, GC,{K 0
(GC,{K 0
i , K 1

Pr

i }i∈[n]) (cid:54)=

i , K 1
i }i∈[n]) :
i , K 1
i }i∈[n]) ← A(1k, f )

i }i∈[n]) = accept



is negligible in k.

Intuitively, Deﬁnition 3 says that even a malicious con-
structor cannot create circuits that are successfully veriﬁable
(i.e., make Ve output accept) and at the same time can out-
put diﬀerent values as a function of the evaluator’s input x,
as long as f (x) = 1. Jumping ahead, this is going to guar-
antee that the veriﬁer cannot distinguish between diﬀerent
witnesses used by the prover.

Moreover, we require that the input of the testing function
is enough to extract the secret in polynomial time. Note that
this is trivial when it is easy to ﬁnd an x s.t., f (x) = 1 but
non-trivial otherwise. Jumping ahead, this extra guarantee
will enable our simulator to extract the secret Z from the
input of the malicious veriﬁer to the oblivious transfer pro-
tocol, and it is therefore crucial to prove the zero-knowledge
protocol.
Intuitively, this is because this requirement en-
sures that the veriﬁer already knows the (unique) secret Z
when he sends the garbled circuit to the prover, and there-
fore the veriﬁer is not learning any information when he
receives back the secret Z as the output of the circuit eval-
uation by the prover (given that the check passes).

It is natural at this point to ask if there exist garbling
schemes satisfying this deﬁnition.
In Appendix B we dis-
cuss the most eﬃcient Yao garbling schemes and argue how
they satisfy all these properties under reasonable assump-
tions. Correctness follows from the correctness of Yao’s con-
struction. Intuitively soundness follows from the privacy of
Yao’s protocol (the output keys are encrypted using a secure
encryption scheme under the input keys). The last require-
ment is satisﬁed by any garbling scheme good enough to be
used in a cut-n-choose context. Note that the extraction
requirement is very natural in Yao’s scheme because, having
access to all input keys, one can “fully decrypt” every gar-
bled gate iteratively and get access to the key corresponding
to the output bit 1 even without computing an input x such
that f (x) = 1.
3. WARM-UP: HONEST VERIFIER ZERO-

KNOWLEDGE

It is trivial to construct zero-knowledge proofs when the
prover is semi-honest. However, it is in some cases inter-
esting to consider a relaxation of zero-knowledge in which
the veriﬁer is semi-honest i.e., where the veriﬁer follows the
protocol correctly but then tries to extract additional infor-
mation about the prover’s witness from the transcript of the
protocol. This notion can be found in the literature under
the name of honest-veriﬁer zero-knowledge or HVZK.

In this section we start by presenting an eﬃcient protocol
for this scenario. Note however, that our protocols are pri-
vate coin zero-knowledge protocols and therefore standard
transformations from HVZK to full ZK cannot be used4.
4In a public-coin zero-knowledge protocol, the veriﬁer does
not have any private randomness and is limited to sam-

959Constructing HVZK protocols using garbled circuits is rel-
atively easy, and the main idea is as follows: the veriﬁer,
acting as the circuit constructor, constructs a Yao circuit
that evaluates the function fy. This function outputs 1 if
R(y, w) = 1 otherwise it outputs 0. Then the parties run
n = |w| OTs, where V acting as the sender inputs the keys
corresponding to the input wires and P inputs the bits of
its witness (w1, . . . , wn). Now V sends the garbled circuit to
P ,5 who evaluates and sends V the output of the evaluation
of the garbled circuit. The formal description of the protocol
is provided in Figure 5. Note that the algorithm Ve is not
needed in this case. Note also that if the OT protocol has
a two move form, then the whole protocol has only 3 moves
(ﬁrst choose from P to V , then transfer and GC from V to
P and ﬁnally S(cid:48) from P to V ).

The protocol πHVZK.

Let G = (Gb, Ev) be a garbling scheme. Let L be an NP lan-
guage with |w| < n = poly(|y|) and fy : {0, 1}n → {0, 1} be
the veriﬁcation function that outputs 1 if w is a valid witness
for y.
Both parties have input y and a security parameter 1k.
addition, the prover P has input w = (w1, . . . , wn).
1. For all i ∈ [n], P sends (choose, i, wi) to FOT;
2. FOT sends V messages (chosen, i) (for all i ∈ [n]);
3. V runs (GC, {K1
4. For all

i }i∈[n], Z) ← Gb(1k, fy);

i ∈ [n], V sends

to FOT the

i , K0

input

In

(transfer, i, Ki

0, Ki

1);

5. FOT sends P messages (transferred, i, K(cid:48)

i) (for all i ∈

[n]);

6. V sends GC to P ;
7. P runs Z(cid:48) ← Ev(GC, {K(cid:48)
8. V outputs accept iﬀ Z = Z(cid:48);

i}i∈[n]) and sends Z(cid:48) to V ;

Figure 5: The protocol for honest-veriﬁer zero-
knowledge in the FOT-hybrid model

Theorem 1. Let G be a garbling scheme satisfying Def-
inition 1 and 2. Then protocol πHVZK in Figure 5 securely
implements the zero knowledge functionality F R
ZK in the pres-
ence of an actively corrupted P or a passively corrupted V
in the FOT-hybrid model.

1 , . . . , w∗

Proof. When playing against a corrupted P ∗: the sim-
ulator S extracts P ∗’s input w∗ = (w∗
n) from the
ﬁrst step by simulating the FOT functionality and the simu-
lator continues the protocol like an honest veriﬁer with the
only exception that at the end, it outputs accept iﬀ w∗ is
a valid witness for y. We argue that the view of P ∗ in the
pling random challenges and sending them to the prover.
In this case it is possible to transform an HVZK into a ZK
by letting the veriﬁer commits to his challenges ahead of
time and/or by sampling them using a coin ﬂip protocol.
In addition, public coin ZK protocols can be turned into
non-interactive zero-knowledge protocols (NIZK) using the
Fiat-Shamir heuristic. This is not possible for our construc-
tion, as here the messages sent by the veriﬁer are not simply
its random choices.
5Note that this is the proper order of things. If the circuit
is sent before the OTs then the garbling scheme needs to
be secure against adaptive attacks at the price of reduced
eﬃciency, see [BHR12a].

real world and in a simulated execution are computationally
close as follows: up to the last step the view of P ∗ is dis-
tributed identically in the two settings (the simulator acts
as an honest veriﬁer except for its ﬁnal output), and due to
Deﬁnition 2 the probability that the corrupted P ∗ manages
to make the real veriﬁer output accept when he does not
input a valid witness in the OT phase is negligible.
The simulator can produce the view of a passively cor-
rupted V ∗ by simulating the messages of the FOT function-
ality in Step 2. In Step 7, the simulator chooses sets Z(cid:48) to
be Z, the output of Gb (instead of the output of Ev). Due to
Deﬁnition 1 the two values are equal except with negligible
probability.

4. ZERO-KNOWLEDGE FROM GARBLED

CIRCUITS

In this section we describe our ﬁnal protocol, that achieves
full zero-knowledge also in the presence of a malicious veri-
ﬁer. An intuitive explanation of the protocol has been pro-
vided in the introduction, and therefore we proceed to for-
mally describe the protocol in Figure 6 and prove its security.
Note that the steps 1 − 6 are the same as in the protocol
πHVZK.

The protocol πZK.

Let G = (Gb, Ev, Ve) be a garbling scheme. Let L be an NP
language with |w| < n = poly(|y|) and fy : {0, 1}n → {0, 1} be
the veriﬁcation function that outputs 1 if w is a valid witness
for y.
Both parties have input y and a security parameter 1k.
addition, the prover P has input w = (w1, . . . , wn).

In

1. For all i ∈ [n], P sends (choose, i, wi) to FCOT;
2. FCOT sends V messages (chosen, i) (for all i ∈ [n]);
3. V runs (GC, {K1
4. For all

i }i∈[n], Z) ← Gb(1k, fy);

i ∈ [n], V sends

i , K0

(transfer, i, Ki

0, Ki

1);

5. FCOT sends P messages (transferred, i, K(cid:48)

to FCOT the input
i) (for all i ∈

[n]);

6. V sends GC to P ;
7. P runs Z(cid:48) ← Ev(GC, {K(cid:48)

aborts, set Z(cid:48) to ⊥;

(committed, 1, |Z(cid:48)|) to V ;

i}i∈[n]); In case the function Ev
8. P send (committ, 1, Z(cid:48)) to FCOM and FCOM outputs
9. V sends the message (open-all) to the FCOT function-
10. FCOT sends P ,
0, Ki
1);
11. P runs Ve(GC, {K0
i , K1

if the output is not
accept, P terminates the protocol. Otherwise, if Ve out-
puts accept, P sends (reveal, 1) to FCOM;

i ∈ [n],

(transfer, i, Ki

0}i∈[n]),

12. When V receives (reveal, 1, Z(cid:48)) from FCOM, V outputs

the values

for all

ality;

accept if Z(cid:48) ?

= Z;

Figure 6: The protocol for honest-veriﬁer zero-
knowledge in the (FCOT,FCOM)-hybrid model

Theorem 2. Let G be a garbling scheme satisfying Def-
inition 1, 2 and 3. Then protocol πZK in Figure 5 securely
implements the zero knowledge functionality F R
ZK in the pres-

960ence of actively corrupted parties in the (FCOT,FCOM)-hybrid
model.

1 , . . . , w∗

Proof. When playing against a corrupted P ∗: the simu-
lator S extracts P ∗’s input w∗ = (w∗
n) from the ﬁrst
step by simulating the FCOT functionality and the simula-
tor continues the protocol like an honest veriﬁer with the
only exception that at the end, it outputs accept iﬀ w∗ is
a valid witness for y. We argue that the view of P ∗ in the
real world and in a simulated execution are computationally
close as follows: up to the last step the view of P ∗ is dis-
tributed identically in the two settings (the simulator acts as
an honest veriﬁer except for its ﬁnal output): as discussed,
the simulator only outputs accept when P ∗ uses a valid wit-
ness in the OT phase, while a real veriﬁer will accept if the
value received from the prover in step 11 is a valid opening
of the commitment and Z is consistent with the secret hid-
den in the garbled circuit. But this can only happen with
negligible probability if w is s.t. f (w) = 1: for the sake of
contradiction, assume that P ∗ can use w s.t. f (w) = 0 in the
OT phase and yet input Z(cid:48) = Z to the ideal commitment
functionality in Step 8, then P ∗ can be used in a straight-
forward way to break the soundness property of the garbled
circuit as deﬁned in Deﬁnition 2.6
When playing against a corrupted V ∗: The simulator
sends messages (chosen, i) to V ∗ and extracts V ∗’s input
i}i∈[n] from step 4 by simulating the FCOT
{(K∗)0
functionality. It then receives GC in step 6, sends the committed
message to V ∗, and waits to receive the message (open-all)
from V ∗. Finally in step 12, the simulator sends
i}i∈[n])
)1

i , (K∗)1

Z

(cid:48) ← Ext(GC,{(K
i , (K∗)1

)0
i , (K

∗
i}i∈[n]) accepts or Z(cid:48) = ⊥ oth-

∗

to V ∗ if Ve(GC,{(K∗)0
erwise.

Note that the simulator sends the committed message even
if it already knows that the Ve is going to fail. We argue that
this simulated view of a malicious veriﬁer is indistinguishable
from the view of the interaction with a real prover: note
that if the veriﬁer “cheats” (i.e., sends keys and circuit that
make Ve reject) then the simulator always commits to the
value ⊥ in step 8 while an honest prover might commit to a
diﬀerent value (i.e., the output of the evaluation function on
the garbled circuit with a speciﬁc set of input keys). As we
are using an ideal commitment scheme, this does not change
the distribution of the view of the adversary: in this case in
fact (both in the simulated view and in the real world) the
protocol ends at step 10, and the veriﬁer does not get to see
the committed value. In the other case i.e., when the veriﬁer
behaves honestly and the simulator commits to the secret
value Z, then the view of the adversary in the real world and
in the simulated execution is computationally close: this is
guaranteed by Deﬁnition 3 that states that the output of
the circuit is unique and therefore independent from the
actual witness used – therefore the value committed by the
simulator and the value committed by an honest prover are
the same except with negligible probability.

6This is where we need to use the fact that the commitment
is “extractable”, as it guarantees that the adversary P ∗ com-
puted the value Z using only the set of keys received from
the OT phase and not the extra information received during
the openall phase.

5. EXPERIMENTAL RESULTS

To show that our protocol πZK can be used in practice we
implemented it and measured its performance. We stress
that the goal of this section is not to show the best possi-
ble implementation of our protocol, but to show that the
overhead to get active security on top of passive security
when using garbled circuits for the case of zero-knowledge
(as opposed to general 2PC) is very limited.
5.1 Choosing the Building Blocks

We chose only publicly available tools to implement our
protocol, instead of creating an ad-hoc implementation from
scratch. While this negatively aﬀects our performance, it
allows anyone interested in verifying our results to do so
with only minimal eﬀort.

5.1.1 Garbled Circuits
For the implementation of Gb and Ev we chose FastGC [HEKM11].

FastGC implements the evaluation of garbled circuits with
state-of-the-art techniques like free-XOR [KS08] or pipelin-
ing [HEKM11]. Furthermore we employed GCParser [EMZ12]
that parses circuit descriptions in an intermediate language
for use with FastGC. This allows us to use the circuits avail-
able at [ST12] with little additional manipulation.

5.1.2 Commitment Scheme
The commitment scheme used by the prover in step 8 can
be implemented as Com(m, r) = SHA-256(m||r). This is an
UC commitment scheme in the random oracle model: the
use of the random oracle model seems necessary here, as we
know that UC commitments are impossible to realize in the
plain model and we do not wish to use impractical setup
assumptions like the common reference string.

Note however that one has to be very careful and im-
plement the commitment scheme in such a way that the
commitment scheme is “non-malleable” with respect to the
garbling scheme: this means that seeing the garbled circuit
GC, the input keys and the opening in step 9 should not help
a corrupted prover create and correctly open a commitment
C for the secret Z. To see why this is necessary, consider an
(artiﬁcial) garbling scheme that includes a commitment C to
Z in the description of the garbled circuit GC. Now a mali-
cious prover can simply send back to V this commitment C,
wait for V to perform open-all in step 9. At this point he
can open the commitment and make V accept, completely
breaking the soundness of the protocol. To avoid this, one
needs to use “diﬀerent random oracles” for the commitment
and for the circuit generator – in practice one could e.g.,
use diﬀerent preﬁxes for the two diﬀerent functions or use
completely diﬀerent functions e.g., AES to garble the circuit
and SHA in the commitment.

5.1.3 Oblivious Transfer
We implemented Naor-Pinkas [NPS99] OT (NPOT) using
the SCAPI library [EFLL12]. As SCAPI’s backend driver
we chose the MIRACL Crypto SDK7 and used the group
of points of the Koblitz 224 curve. We tested the use of
OT-extension, but due to the low number of input bits in
our applications (the witness size), we found that using OT-
extension produced worse results than simply using one OT
per input bit.

7https://certivox.com/solutions/miracl-crypto-sdk/

9615.2 Experiments

We have measured performance in four experiments:

HVZK AES: P proves knowledge of private k so that c =
AESk(x) for public plaintext x and public ciphertext c
using protocol πHVZK. AES key expansion for k is per-
formed in the circuit. The bit lengths of the circuit’s
inputs are: |k|2 = |c|2 = |x|2 = 128. This is essentially
a passive secure evaluation of AES, and therefore gives
us a “base case” to measure the performance of our pro-
tocol.

ZK AES: As HVZK AES but this time we run the com-

plete πZK protocol.

MD5: P proves knowledge of private x so that h = MD5(x)
for public hash h using πZK. The circuit only performs
one invocation of the MD5 compression function, x
is padded outside the circuit. The bit lengths of the
circuit’s inputs are: |x|2 = 512,|h|2 = 128.

SHA-256: P proves knowledge of private x so that h =
SHA-256(x) for public hash h using πZK. The circuit
only performs one invocation of the SHA-256 compres-
sion function, x is padded outside the circuit. The bit
|x|2 = 512,|h|2 =
lengths of the circuit’s inputs are:
256
Implementation details

5.3

In all experiments both parties, prover and veriﬁer, were

executed on the same “Intel(R) Core(TM) i7-2600 CPU 3.40GHz”
and 16GBytes of RAM and averaged over 100 runs. How-
ever, prover and veriﬁer had their own JVM and communi-
cated over (local) network sockets.8
5.4 Performance measurements

In Figure 1 we present our results. The individually mea-

sured operations are characterized next9:

Circuit Parsing (1): P and V both independently parse
the GC’s description in the intermediate language. Fur-
thermore this also includes some initializations. Clearly
the time for parsing can be amortized over multiple ex-
ecutions or could be precomputed once and for all.

Oblivious Transfers: P and V run NPOT with the wit-
ness and the keys corresponding the input wires as
inputs.

Circuit Generation/Evaluation: P and V evaluate the
GC using the pipelining technique: Both traverse the
circuit in parallel and V creates and sends a garbled
table (GTT) whenever he and P encounter a gate. P
decrypts the respective entry in the GTT. FastGC’s
use of the free-XOR technique only requires GTT for
AND and OR gates. Finally, P commits to the GC’s
output.

8As shown in the table, the communication complexity of
the protocol is just a few hundreds kilobytes, so moving the
protocol to a LAN should not change the timings signiﬁ-
cantly.
9Note that those operations are quite diﬀerent from the ide-
alized version of πZK. The reason for this is that in the
“idealized” protocol V generates the whole circuit and then
sends it to P . This generates a lot of idle time for the par-
ties, while to get more eﬃciency it is useful to have both
parties work in parallel.

Circuit Parsing (2): During the circuit veriﬁcation, the
prover parses the circuit again. This is just an imple-
mentation issue due to the “black-box” use of FastGC
but could clearly be optimized away.

Circuit veriﬁcation: V sends P the seed it used for the
random creation of wire labels of the circuit and the
OT. Furthermore, it also sends its inputs to the circuit
to P . P starts evaluating it in the role of V . P com-
pares the output it creates (the GTTs) to the GTTs
it received from V previously. P accepts if both are
equal for the entire GC. In this case it opens the com-
mitment and V veriﬁes the opening.

5.4.1 Discussion of results
Our experiments show that thanks to our protocol we can
prove complex non-algebraic statements in only a few sec-
onds.

We believe that our main contribution can be seen by
comparing the timings of HVZK AES and ZK AES. Our
protocol achieves active security on top of passive security
with a slowdown of less than 20% with respect to the passive
secure version, much better than the factor 2 we would have
predicted.

The absolute value of 1.7s for AES ZK shows the com-
petitiveness of our approach versus the standard techniques
for active secure two-party computation: the best solution
based on Yao on standard hardware [SS11]10 reports a time
of 192s for one AES evaluation. The GMW-based active
secure protocol in [NNOB12] requires 64s per AES instance
(the timings go down to 2.5s but only when running many
instances in parallel).

We conjecture that all our timings could be reduced by
a signiﬁcant factor if we were willing to sacriﬁce general-
ity for performance: to see why, compare the timings for
HVZK AES with the timings for passive secure 2PC of AES
reported in [HEKM11], performing almost the same task11:
they have a timing of 0.2s versus our 1.4s. We believe that
the main reason for this (apart from running the code on
diﬀerent hardware)12 is that the AES circuit is hard-coded
in their Java program and thus they do not perform circuit
parsing at runtime – this generates also less overhead during
evaluation. Therefore we believe that an ad-hoc implemen-
tation of our protocol for a speciﬁc circuit could run much
faster than our prototype.

Acknowledgement.

We thank Yan Huang for his support with FastGC and
his OT implementation, Stefan Tillich for his support with
their circuits, Yael Ejgenberg for support for the SCAPI
framework and Omkant Pandey for noticing an issue in a
previous version of this paper. The third author is supported
by The Danish Council for Independent Research (DFF)
Grant 11-116416/FTP.

10[KSS12] reports better timings, but they run their experi-
ments on machines with more than 60000 cores.
11Their implementation performs the AES key expansion at
the prover side – this is not a problem when the prover is
semi-honest but cannot be done in our case.
12They also instantiate the NPOT in the multiplicative group
of Zp with p = 1024 while we use the Koblitz 224 curve which
is considered more secure.

962AES Decrypt

ZK

MD5
ZK

SHA256

ZK

Operation

Circuit Parsing (1)
Oblivious Transfers

Circuit Generation/Evaluation

HVZK

Prover
239 ± 3
731 ± 4
335 ± 3

Veriﬁer
243 ± 4
766 ± 5
298 ± 3

Circuit Parsing (2)
Circuit Veriﬁcation

Total time

Data transferred

P ’s input bits

#Gates

1404 ± 6
256256 ± 0

Veriﬁer
247 ± 3
772 ± 5
296 ± 3

Prover
239 ± 3
736 ± 4
332 ± 3
91 ± 1
163 ± 1

Prover
336 ± 5
2078 ± 7
605 ± 8
82 ± 1
410 ± 2

Veriﬁer
343 ± 3
2115 ± 7
602 ± 8

Veriﬁer
585 ± 9
2118 ± 8
1700 ± 7

Prover
565 ± 6
2081 ± 7
1701 ± 7
240 ± 1
1059 ± 15

1667 ± 6
262022 ± 2

3617 ± 11
1069647 ± 3

5761 ± 20
3052635 ± 4

128
6927

512

29211

512

91080

Table 1: Execution times and conﬁdence intervals in milliseconds with conﬁdence level 99%, averaged over
100 runs, rounded to ms. #Gates is the sum of AND and OR gates. The total runtime is the time (in ms)
between the establishment of the network connection and the point where V accepts/rejects. Data transferred
is the number of bytes exchanged between P and V . P ’s inputs indicates the number of input bits for which
OTs have to be executed. #Gates is the number of non-free gates in the circuits.

6. REFERENCES
[AIR01] William Aiello, Yuval Ishai, and Omer

Reingold. Priced oblivious transfer: How to
sell digital goods. In Birgit Pﬁtzmann, editor,
EUROCRYPT, volume 2045 of Lecture Notes
in Computer Science, pages 119–135. Springer,
2001.
Rikke Bendlin and Ivan Damg˚ard. Threshold
decryption and zero-knowledge proofs for
lattice-based cryptosystems. In TCC, pages
201–218, 2010.
Stephanie Bayer and Jens Groth. Eﬃcient
zero-knowledge argument for correctness of a
shuﬄe. In EUROCRYPT, pages 263–280, 2012.

[BD10]

[BG12]

[BHKR13] Mihir Bellare, Viet Tung Hoang, Sriram

Keelveedhi, and Phillip Rogaway. Eﬃcient
garbling from a ﬁxed-key blockcipher. In IEEE
Symposium on Security and Privacy, pages
478–492, 2013.

[BHR12a] Mihir Bellare, Viet Tung Hoang, and Phillip

[BP12]

[BHR12b] Mihir Bellare, Viet Tung Hoang, and Phillip
Rogaway. Foundations of garbled circuits. In
ACM Conference on Computer and
Communications Security, pages 784–796,
2012.
Nir Bitansky and Omer Paneth. Point
obfuscation and 3-round zero-knowledge. In
TCC, pages 190–208, 2012.
Ran Canetti. Security and composition of
multiparty cryptographic protocols. J.
Cryptology, 13(1):143–202, 2000.
Ran Canetti. Universally composable security:
A new paradigm for cryptographic protocols.
FOCS, 2001. Updated version at
http://eprint.iacr.org/2000/067.
Ronald Cramer, Ivan Damg˚ard, and Berry
Schoenmakers. Proofs of partial knowledge and

[CDS94]

[Can00]

[Can01]

Rogaway. Adaptively secure garbling with
applications to one-time programs and secure
outsourcing. In ASIACRYPT, pages 134–153,
2012.

[DNO08]

simpliﬁed design of witness hiding protocols.
In CRYPTO, pages 174–187, 1994.

[CKKZ12] Seung Geol Choi, Jonathan Katz, Ranjit

[CKS11]

[CM99]

[Cr´e89]

Kumaresan, and Hong-Sheng Zhou. On the
security of the ”free-XOR” technique. In TCC,
pages 39–53, 2012.
Jan Camenisch, Stephan Krenn, and Victor
Shoup. A framework for practical universally
composable zero-knowledge protocols. In
ASIACRYPT, pages 449–467, 2011.
Jan Camenisch and Markus Michels. Proving
in zero-knowledge that a number is the
product of two safe primes. In EUROCRYPT,
pages 107–122, 1999.
Claude Cr´epeau. Veriﬁable disclosure of secrets
and applications (abstract). In EUROCRYPT,
pages 150–154, 1989.

[CvdGT95] Claude Cr´epeau, Jeroen van de Graaf, and

Alain Tapp. Committed oblivious transfer and
private multi-party computation. In CRYPTO,
pages 110–123, 1995.
Ivan Damg˚ard, Jesper Buus Nielsen, and
Claudio Orlandi. Essentially optimal
universally composable oblivious transfer. In
ICISC, pages 318–335, 2008.

[EFLL12] Yael Ejgenberg, Moriya Farbstein, Meital

Levy, and Yehuda Lindell. Scapi: The secure
computation application programming
interface. Cryptology ePrint Archive, Report
2012/629, 2012.
http://crypto.biu.ac.il/scapi.
David Evans, William Melicher, and Samee
Zahur. Interpreter for Garbled Circuits
Intermediate Language, 2012.
http://mightbeevil.org/gcparser/.

[EMZ12]

[FJN+13] Tore Kasper Frederiksen, Thomas Pelle

Jakobsen, Jesper Buus Nielsen,
Peter Sebastian Nordholt, and Claudio
Orlandi. Minilego: Eﬃcient secure two-party
computation from general assumptions. In
EUROCRYPT, 2013.

963[FS86]

[GGP10]

Amos Fiat and Adi Shamir. How to prove
yourself: Practical solutions to identiﬁcation
and signature problems. In CRYPTO, pages
186–194, 1986.
Rosario Gennaro, Craig Gentry, and Bryan
Parno. Non-interactive veriﬁable computing:
Outsourcing computation to untrusted
workers. In CRYPTO, pages 465–482, 2010.

[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno,

and Mariana Raykova. Quadratic span
programs and succinct nizks without pcps. In
EUROCRYPT, pages 626–645, 2013.

[Gol04]

[GK96]

[GMR85]

[GOS06a]

[GIKM98] Yael Gertner, Yuval Ishai, Eyal Kushilevitz,
and Tal Malkin. Protecting data privacy in
private information retrieval schemes. In
Jeﬀrey Scott Vitter, editor, STOC, pages
151–160. ACM, 1998.
Oded Goldreich and Hugo Krawczyk. On the
composition of zero-knowledge proof systems.
SIAM J. Comput., 25(1):169–192, 1996.
Shaﬁ Goldwasser, Silvio Micali, and Charles
Rackoﬀ. The knowledge complexity of
interactive proof-systems (extended abstract).
In Robert Sedgewick, editor, STOC, pages
291–304. ACM, 1985.
Oded Goldreich. Foundations of Cryptography
Volume 2, Basic Applications. Cambridge
University Press, 2004.
Jens Groth, Rafail Ostrovsky, and Amit Sahai.
Non-interactive zaps and new techniques for
nizk. In CRYPTO, pages 97–111, 2006.
Jens Groth, Rafail Ostrovsky, and Amit Sahai.
Perfect non-interactive zero knowledge for np.
In EUROCRYPT, pages 339–358, 2006.
Jens Groth. Short pairing-based
non-interactive zero-knowledge arguments. In
ASIACRYPT, pages 321–340, 2010.
Jens Groth and Amit Sahai. Eﬃcient
noninteractive proof systems for bilinear
groups. SIAM J. Comput., 41(5):1193–1232,
2012.
Essam Ghadaﬁ, Nigel P. Smart, and Bogdan
Warinschi. Groth-sahai proofs revisited. In
Public Key Cryptography, pages 177–192, 2010.
[HEKM11] Yan Huang, David Evans, Jonathan Katz, and

[GOS06b]

[GSW10]

[Gro10]

[GS12]

[HKE13]

Lior Malka. Faster secure two-party
computation using garbled circuits. In
USENIX Security Symposium, 2011.
Yan Huang, Jonathan Katz, and Dave Evans.
Eﬃcient secure two-party computation using
symmetric cut-and-choose. In CRYPTO, 2013.

[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail

Ostrovsky, and Amit Sahai. Zero-knowledge
from secure multiparty computation. In
David S. Johnson and Uriel Feige, editors,
STOC, pages 21–30. ACM, 2007.

[JKO13] Marek Jawurek, Florian Kerschbaum, and

Claudio Orlandi. Zero-knowledge using garbled
circuits: How to prove non-algebraic
statements eﬃciently. Cryptology ePrint
Archive, Report 2013/073, 2013.
http://eprint.iacr.org/.

[JKPT12] Abhishek Jain, Stephan Krenn, Krzysztof

Pietrzak, and Aris Tentes. Commitments and
eﬃcient zero-knowledge proofs from learning
parity with noise. In ASIACRYPT, pages
663–680, 2012.

[KS08]

[KS06]

[KSS12]

[KMW12] Shahram Khazaei, Tal Moran, and Douglas
Wikstr¨om. A mix-net from any cca2 secure
cryptosystem. In ASIACRYPT, pages 607–625,
2012.
Mehmet S. Kiraz and Berry Schoenmakers. A
protocol issue for the malicious case of yao’s
garbled circuit construction. In In Proceedings
of 27th Symposium on Information Theory in
the Benelux, pages 283–290, 2006.
Vladimir Kolesnikov and Thomas Schneider.
Improved garbled circuit: Free XOR gates and
applications. In ICALP (2), pages 486–498,
2008.
Benjamin Kreuter, Abhi Shelat, and Chih-Hao
Shen. Towards billion-gate secure computation
with malicious adversaries. IACR Cryptology
ePrint Archive, 2012:179, 2012.
Yehuda Lindell. Highly-eﬃcient
universally-composable commitments based on
the ddh assumption. In EUROCRYPT, pages
446–466, 2011.
Yehuda Lindell. Fast cut-and-choose based
protocols for malicious and covert adversaries.
In CRYPTO, 2013.
Helger Lipmaa. Progression-free sets and
sublinear pairing-based non-interactive
zero-knowledge arguments. In TCC, pages
169–189, 2012.
Daniele Micciancio and Salil P. Vadhan.
Statistical zero-knowledge proofs with eﬃcient
provers: Lattice problems and more. In
CRYPTO, pages 282–298, 2003.

[MV03]

[Lin11]

[Lin13]

[Lip12]

[NNOB12] Jesper Buus Nielsen, Peter Sebastian

Nordholt, Claudio Orlandi, and Sai Sheshank
Burra. A new approach to practical
active-secure two-party computation. In
CRYPTO, pages 681–700, 2012.

[NPS99] Moni Naor, Benny Pinkas, and Reuban

Sumner. Privacy preserving auctions and
mechanism design. In ACM Conference on
Electronic Commerce, pages 129–139, 1999.

[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and

Mariana Raykova. Pinocchio: Nearly practical
veriﬁable computation. In IEEE Symposium
on Security and Privacy, pages 238–252, 2013.

[PVW08] Chris Peikert, Vinod Vaikuntanathan, and

Brent Waters. A framework for eﬃcient and
composable oblivious transfer. In CRYPTO,
pages 554–571, 2008.
Claus-Peter Schnorr. Eﬃcient identiﬁcation
and signatures for smart cards. In CRYPTO,
pages 239–252, 1989.
Abhi Shelat and Chih-Hao Shen. Two-output
secure computation with malicious adversaries.
In EUROCRYPT, pages 386–405, 2011.
Nigel Smart and Stefan Tillich. Circuits of
basic functions suitable for mpc and fhe, 2012.

[Sch89]

[SS11]

[ST12]

964[Yao82]

http://www.cs.bris.ac.uk/Research/
CryptographySecurity/MPC/.
Andrew Chi-Chih Yao. Protocols for secure
computations (extended abstract). In FOCS,
pages 160–164. IEEE Computer Society, 1982.

APPENDIX
A. PROTOCOLS FOR FCOT
In this section we discuss the relationship between the
FOT functionality and the FCOT functionality. While it is
clear that the FOT functionality cannot be used in a black
box way to run FCOT, we argue that any protocol based
on computational assumptions can be used to implement
FCOT. (Oblivious transfer can be instantiated using non-
computational assumptions, such as noisy channels, quan-
tum cryptography etc. We do not expect these kind of pro-
tocols to work in our context.) This can be done by letting
the sender commit to a random seed s at the beginning of
the protocol and then use the output of a pseudorandom
generator P RG(s) as its random tape in the protocol. Then
during the open-all phase the sender reveals the seed and
the messages and the receiver can check that the messages
are consistent.

In order to make the paper self-contained, we describe here
two eﬃcient OT protocols that can be used to instantiate
our construction, and discuss how those protocols already
commit the sender to his choice of messages.
A.1 OT with UC-Security

We consider the UC-secure OT protocol proposed in [PVW08],

instantiated using discrete logarithm. The reason for this
choice is that the PVW OT appears to be the most eﬃcient
protocol for UC-OT in the literature. Let (G, q, g) be the de-
scription of a group of prime order q generated by g where
the decisional Diﬃe-Hellman assumption is believed to hold.

CRS: The parties have access to a random string:

(g0, h0, g1, h1) ∈ G4

and aborts if not. Otherwise, compute

v0 = gr0 hs0 and v1 = gr1 hs1

and output

m0 = w0 · v

−1
0

and m1 = w1 · v

−1
1

The sender cannot lie about the messages without break-
ing the discrete logarithm assumption: the values u0, u1 can
be seen as Pedersen commitments, and if the adversary can
ﬁnd two diﬀerent openings then the adversary can be used
to ﬁnd the discrete logarithms of hi in base gi for some
i ∈ {0, 1}.
A.2 Naor-Pinkas OT

A problem with PVW OT is that it requires a common-
reference string. Naor and Pinkas [NPS99] proposed a very
eﬃcient OT protocol in the plain model. It does not satisfy
full-simulatabilty as PVW, but it is appears a good choice
in practice as it uses fewer exponentiations and does not
require a common reference string. The protocol proceeds
as follows:
Setup: The sender chooses a random d ∈R G and sends it

to the receiver.;

Choose: The receiver chooses a random α ∈R Zq, computes
hb = gα and h1−b = d · (hb)−1, and sends h0 to the
sender.

Transfer The sender computes h1 = d · (h0)−1, and sends

(c0, c1, c2) = (hr

0 · m0, hr

1 · m1, gr)

to the receiver.

Retrieve: R outputs: mb = cb · (c2)−α

This protocol can be augmented in the following way:

Choose: R chooses a random α ∈R Zq, computes

Open-All: The sender reveals r to the receiver, who checks

that c2 = gr and in this case outputs

g = (gb)α, h = (hb)α

and sends (g, h) to S;

Transfer: The sender operates in the following way:

1. S chooses random r0, s0, r1, s1 ∈R Z4

q and com-

putes

u0 = gr0

0 hs0

0 , v0 = gr0 hs0

u1 = gr1

1 hs1

1 , v1 = gr1 hs1

2. S sends R the values (u0, w0) where w0 = v0 · m0,

and (u1, w1) where w1 = v1 · m1;
Retrieve: R outputs: mb = wb · (ub)−α

In [PVW08] the authors prove that this protocol securely
implement the FOT functionality in the CRS-hybrid model.
We can easily augment this protocol with the following pro-
cedure:

Open-All: S sends R the randomness r0, r1, s0, s1. R checks

that

u0 = gr0

0 hs0

0 and u1 = gr1

1 hs1

1

m0 = c0 · (h0)

−r and m1 = c1 · (h1)

−r

In this case the transfer message is a perfectly binding com-
mitment to m0, m1, therefore no adversary can send incon-
sistent values.

We remark that if we use this OT protocol in our con-
struction the simulator cannot extract the witness (i.e., the
choice bits) of the prover/receiver, and in order to argue
that the protocol πZK is also a proof-of-knowledge we need
to rely on some extra assumption on the garbling scheme or
by rewriting the proof in the random oracle model.

Saving on Communication Complexity

A.2.1
In both protocols the “Open-All” procedure simply con-
sists of having the sender reveal all of its internal coins to
the receiver.
In practice one could have the sender pro-
ducing his random tape by stretching a short seed with a
pseudorandom generator. Then the receiver can regenerate
the random tape on his side and perform the same computa-
tion as described above. This helps saving in communication
complexity.

965B. WHICH GARBLING SCHEME CAN BE

USED?

The protocol described in Section 4 is compatible with
every garbling schemes that can be used in standard cut-n-
choose protocols. In particular, it is possible to use very op-
timized garbling schemes. To make the paper self-contained,
we describe in this section such a garbling scheme that com-
bines the state of the art optimizations for Yao Gates i.e.,
free XOR [KS08], permutation bits [NPS99], garbled row-
reduction [NPS99].

This means that to garble a gate 4 evaluations of encryp-
tion are needed, and a garbled gate consists of only 3 cipher-
texts (therefore saving on communication complexity). The
evaluation of the gate consists of a single decryption.

How to garble gates.

For the sake of exposition we will only describe how to
garble NAND gates – as those are complete for Boolean
circuits. It is straightforward to see how to garble other non-
linear gates (remember that XOR-gates will be “for free”).

Free-XOR: When generating the circuit, the circuit con-
structor chooses a random ∆ ∈ {0, 1}k and then, for
each wire in the circuit, it will choose the key K0 cor-
responding to the bit 0 at random in {0, 1}k and set
K1 = K0 ⊕ ∆ for each wire in the circuit.
This allows to evaluate XOR gates for free: let L0, L1 ∈
{0, 1}k be the keys associated to the left input wire and
R0, R1 corresponding to the right input wire and O0, O1
the keys associated to the output wire. Remember that
L0 ⊕ L1 = R0 ⊕ R1 = O0 ⊕ O1 = ∆. Then, if the circuit
constructor sets O0 = L0 ⊕ R0 it is easy to see that
the circuit evaluator can use two keys La, Rb (without
knowing a, b) to compute Oa⊕b as follows:

La ⊕ Rb =L0 ⊕ a · ∆ ⊕ R0 ⊕ b · ∆
=(L0 ⊕ R0) ⊕ (a ⊕ b) · ∆
=Oa⊕b

Encryption scheme: Let L, R be the input keys for a gate
with identiﬁer id and O the output key. We deﬁne some
key derivation function KDF and encrypt the output
key under the input keys as follows:

C = KDF(L, R, id) ⊕ O

In our implementation we use the same KDF as FastGC
i.e., we hash the input keys and the id using SHA-1.
In [BHKR13], is suggested to use a diﬀerent KDF based
on the assumption that AES with a random (constant)
key behaves like a random permutation. This can lead
to eﬃciency improvements, especially when using new
CPUs where AES encryption is implemented directly as
a machine instruction.

Note that, as with every other free-XOR based con-
struction, we need to assume that the KDF satisﬁes
some kind of related key-attack security [CKKZ12].

Point-and-permute: We call the least signiﬁcant bit of
every key the permutation bit and write pK = lsb(K)
and we assume that lsb(∆) = 1. (This is not a problem
as in our application the prover will learn all input keys
(and therefore ∆) and can therefore check it during Ve.)
Then, for each gate in the circuit Gb samples random
L, R ∈ {0, 1}k and computes:
1. Deﬁne

ρ0 = pL ∧ pR
ρ2 = pL ∧ pR

ρ1 = pL ∧ pR
ρ3 = pL ∧ pR
2. Compute O0 = KDF(LpL , RpR , id) ⊕ ρ0∆;
3. Compute:

α1 = Oρ1 ⊕ KDF(LpL , RpR , id)
α2 = Oρ2 ⊕ KDF(LpL , RpR , id)
α3 = Oρ3 ⊕ KDF(LpL , RpR , id)

4. Output (id, α1, α2, α3)

Evaluation: The function Ev on input (id, α1, α2, α3),

L(cid:48), R(cid:48) does:
1. Deﬁne α0 = 0k.
2. Compute pL(cid:48) = lsb(L(cid:48)) and pR(cid:48) = lsb(R(cid:48)) and let
3. Compute O(cid:48) = αj ⊕ KDF(L(cid:48), R(cid:48), id);

j = 2pL(cid:48) + pR(cid:48) .

Remember that the requirement for correctness is: Let

(gg, O0) ← Gb(id, L0, R0, ∆), then for all a, b ∈ {0, 1}

Ev(gg, La, Rb) = Oa∧b

except with negligible probability over the choices of L0, R0,
∆ and the random coins of Gb and Ev.
This is the case because, let L(cid:48) = La, R(cid:48) = Rb, then
lsb(L(cid:48)) = a⊕ pL and lsb(R(cid:48)) = b⊕ pR. Then by construction
ρj = a ∧ b and

and therefore

αj = Oρj ⊕ KDF(La, Rb, id)

(cid:48)

O

= Oρj = O(pL⊕a)∧(pR⊕b) .

966