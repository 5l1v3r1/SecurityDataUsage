Efﬁcient, Compromise Resilient and Append-only
Cryptographic Schemes for Secure Audit Logging

Attila A. Yavuz and Peng Ning

Michael K. Reiter

Department of Computer Science,
North Carolina State University

Raleigh, NC 27695-8206,

{aayavuz,pning}@ncsu.edu
Department of Computer Science

University of North Carolina, Chapel Hill

Chapel Hill, NC

reiter@cs.unc.edu

Abstract. Due to the forensic value of audit logs, it is vital to provide compro-
mise resiliency and append-only properties in a logging system to prevent ac-
tive attackers. Unfortunately, existing symmetric secure logging schemes are not
publicly veriﬁable and cannot address applications that require public auditing
(e.g., public ﬁnancial auditing), besides being vulnerable to certain attacks and
dependent on continuous trusted server support. Moreover, Public Key Cryptog-
raphy (PKC)-based secure logging schemes require Expensive Operations (Ex-
pOps) that are costly for both loggers and veriﬁers, and thus are impractical for
computation-intensive environments.
In this paper, we propose a new class of secure audit logging scheme called
Log Forward-secure and Append-only Signature (LogFAS). LogFAS achieves
the most desirable properties of both symmetric and PKC-based schemes. Log-
FAS can produce publicly veriﬁable forward-secure and append-only signatures
without requiring any online trusted server support or time factor. Most notably,
LogFAS is the only PKC-based secure audit logging scheme that achieves the
high veriﬁer computational and storage efﬁciency. That is, LogFAS can verify
L log entries with always a small-constant number of ExpOps regardless of the
value of L. Moreover, each veriﬁer stores only a small and constant-size pub-
lic key regardless of the number of log entries to be veriﬁed or the number of
loggers in the system. In addition, a LogFAS variation allows ﬁne-grained ver-
iﬁcation of any subset of log entries and fast detection of corrupted log entries.
All these properties make LogFAS an ideal scheme for secure audit logging in
computation-intensive applications.

Keywords: Secure audit logging; applied cryptography; forward security; signature ag-
gregation.

1

Introduction

Audit logs have been used to track important events such as user activities and pro-
gram execution in modern computer systems, providing invaluable information about

the state of the systems (e.g., intrusions, crashes). Due to their forensic value, audit
logs are an attractive target for attackers. Indeed, an experienced attacker may erase the
traces of her malicious activities from the logs, or modify the log entries to implicate
other users after compromising the system. Therefore, ensuring the integrity, authentic-
ity and accountability of audit logs in the presence of attackers is critical for any modern
computer system [9, 20, 25, 29].

There are straightforward techniques to protect audit logs from active adversaries:
(i) Using a tamper resistant hardware on each logging machine to prevent the adversary
from modifying audit logs and (ii) transmitting each log entry as soon as it is generated
to a remote trusted server. Unfortunately, these approaches have signiﬁcant limitations
as identiﬁed in [9, 19–21]: First, it is impractical to assume both the presence and the
“bug-freeness” of a tamper resistant hardware on all types of platforms (e.g., wireless
sensors [18], commercial off-the-shelf systems [7]) [17, 20]. Second, it is difﬁcult to
guarantee timely communication between each logging machine and the remote trusted
server in the presence of active adversaries [11, 19, 29].

Limitations of Previous Cryptographic Log Protection Techniques: Cryptograp-
hic mechanisms can protect the integrity of audit logs without relying on such tech-
niques. In these settings, the log veriﬁers might not be available to verify the log entries
once they are generated. Hence, a logger may have to accumulate log entries for a period
of time. If the adversary takes full control of the logging machine in this duration, no
cryptographic mechanism can prevent her from modifying the post-attack log entries.
However, the integrity of log entries accumulated before the attack should be protected
(i.e., forward-security property) [1, 7, 9, 12, 17, 19, 20, 29]. Furthermore, this protection
should not only guarantee the integrity of individual log entries but also the integrity
of the log stream as a whole. That is, no selective deletion or truncation of log entries
should be possible (i.e., append-only (aggregate) property [17,18,20]). Forward-secure
and aggregate signatures (e.g., [17,18,20,29,30]) achieve forward-security and append-
only properties simultaneously.

Pioneering forward-secure audit logging schemes [6,7,25] rely on symmetric prim-
itives such as Message Authentication Code (MAC) to achieve computationally efﬁ-
cient integrity protection. However, the symmetric nature of these schemes does not
allow public veriﬁability. This property is necessary for applications such as ﬁnancial
auditing applications where ﬁnancial books of publicly held companies need to be ver-
iﬁed by the current and potential future share holders [12, 20]. Furthermore, symmetric
schemes require online remote trusted server support, which entails costly maintenance
and attracts potential attacks besides being a potential single-point of failures. Finally,
these schemes are shown to be vulnerable against the truncation and delayed detection
attacks [19, 20] (no append-only property).

To mitigate the above problems, several PKC-based secure audit logging schemes
have been proposed (e.g., [12, 17, 18, 20, 29]). These schemes are publicly veriﬁable
and do not require an online TTP support. However, they are costly for loggers (except
for BAF [29]) and extremely costly for the log veriﬁers. Second, to verify a particular
log entry, all these schemes [17–19, 29] force log veriﬁers to verify the entire set of log
entries, which entails a linear number of Expensive Operations (ExpOps)1, and failure

1 For brevity, we denote an expensive cryptographic operation such as modular exponentiation or pairing as an ExpOp.

2

Table 1. Comparison of LogFAS schemes and their counterparts for performance, applicability,
availability and security parameters

PKC-based
FssAgg/iFssAgg BAF Logcrypt
AR BM BLS

SYM
[7, 25]

LogFAS
ExpOp

Sig&Upd (per item)

Ver, (L items)

ExpOp + O(L · H)

ExpOp
O(L · (ExpOp + H))

H

′ · H) O(2l

′

(ExpOp + H)) Not immutable O(l

< L) ExpOp + O(l
Available

Not Available

O(L · ExpOp)
O(S · |K|)

O(L · |D|) + |K|

O(L · S)|K|

ExpOp

H
O(L · H)
′ · H)
-
O(L · H)
O(S · |K|)
O(L · |K|) O(L · |K|)

Criteria

Computational

On-
line

Subset ver (l

′

Efﬁcient Search
Key Generation (Ofﬂine)

Storage

Veriﬁer
Signer

Communication
Public Veriﬁability

Ofﬂine Server

Immediate Veriﬁcation
Immediate Detection
Truncation Resilience

|K|

O(L · (|D| + |K|))

Y
Y
Y
Y
Y

O(L · |D|)
Y
Y
Y
Y
Y

N
N
N
N
N

N

LogFAS is the only PKC-based secure audit logging scheme that can verify O(L) items with a small-constant number of
ExpOps; all other similar schemes require O(L) ExpOps. Similarly, LogFAS is the only one achieving constant number of
public key storage (with respect to both number of data items and log entries to be veriﬁed) on the veriﬁer side, while all
other schemes incur either linear or quadratic storage overhead (S; |D|; |K| denote the number of signers in the system,
the approximate bit lengths of a log entry and the bit length of a keying material, respectively). At the same time, LogFAS is
the only scheme that enables truncation-free subset veriﬁcation and sub-linear search simultaneously.

of this veriﬁcation does not give any information about which log entry(ies) is (are)
responsible for the failure.

Our Contribution: In this paper, we propose a new secure audit logging scheme,
which we call Log Forward-secure and Append-only Signature (LogFAS). We ﬁrst de-
velop a main LogFAS scheme, and then extend it to provide additional capabilities.
The desirable properties of LogFAS are outlined below. The ﬁrst three properties show
the efﬁciency of LogFAS compared with their PKC-based counterparts, while the other
three properties demonstrate the applicability, availability and security advantages over
their symmetric counterparts. Table 1 summarizes the above properties and compares
LogFAS with its counterparts.
1. Efﬁcient Log Veriﬁcation with O(1) ExpOp: All existing PKC-based secure audit log-
ging schemes (e.g., [12,17–20,29,30]) require O(L· (ExpOp + H)) to verify L log
entries, which make them costly. LogFAS is the ﬁrst PKC-based secure audit log-
ging scheme that achieves signature veriﬁcation with only a small-constant number
of ExpOps (and O(L) hash operations). That is, LogFAS can verify L log entries
with only a small-constant number of ExpOps regardless of the value of L. There-
fore, it is much more efﬁcient than all of its PKC-based counterparts, and is also
comparably efﬁcient with symmetric schemes (e.g., [7, 18, 25]) at the veriﬁer side.

2. Efﬁcient Fine-grained Veriﬁcation and Change Detection: LogFAS allows ﬁne-grained

veriﬁcation with advantages over iFssAgg [20], the only previous solution for ﬁne-
grained veriﬁcation:
(i) Unlike iFssAgg schemes [20], LogFAS prevents the truncation attack2 in the
presence of individual signatures without doubling the veriﬁcation cost.

2 The truncation attack is a special type of deletion attack, in which the adversary deletes a continuous subset of tail-end log
entries. This attack can be prevented via “all-or-nothing” property [18]: The adversary either should remain previously

3

′

(ii) LogFAS can verify any selected subset with l
constant number of ExpOps, while iFssAgg schemes require O(2l
(iii) LogFAS can identify the corrupted log entries with a sub-linear number of Ex-
pOps when most log entries are intact. In contrast, iFssAgg schemes always require
a linear number of ExpOps.

< L log entries with a small-

)ExpOps.

′

3. Veriﬁer Storage Efﬁciency with O(1) Overhead: Each veriﬁer in LogFAS only stores
one public key independent of the number of loggers or the number of log entries
to be veriﬁed. Therefore, it is the most veriﬁer-storage-efﬁcient scheme among all
existing PKC-based alternatives. This enables veriﬁers to handle a large number of
log entries and/or loggers simultaneously without facing any storage problem.

4. Public Veriﬁcation: Unlike the symmetric schemes (e.g., [7, 18, 25]), LogFAS can
produce publicly veriﬁable signatures, and therefore it can protect applications re-
quiring public auditing (e.g., e-voting, ﬁnancial books) [12, 20].

5. Independence of Online Trusted Server: LogFAS schemes do not require online trusted

server support to enable log veriﬁcation. Therefore, LogFAS schemes achieve high
availability, and are more reliable than the previous schemes that require such sup-
port (e.g., [7, 25, 30]).

6. High Security: We prove LogFAS to be forward-secure existentially unforgeable
against adaptive chosen-message attacks in Random Oracle Model (ROM) [4]. Fur-
thermore, unlike some previous symmetric schemes [7, 25], LogFAS schemes are
also secure against both truncation and delayed detection attacks.

2 Preliminaries
Notation. || denotes the concatenation operation. |x| denotes the bit length of variable
x. x $← S denotes that variable x is randomly and uniformly selected from set S. For
any integer l, (x0; : : : ; xl) $← S means (x0
$← S). We denote by {0; 1}∗
the set of binary strings of any ﬁnite length. H is an ideal cryptographic hash function,
which is deﬁned as H : {0; 1}∗ → {0; 1}|H|; |H| denotes the output bit length of H.
AO0;:::;Oi (·) denotes algorithm A is provided with oracles O0; : : : ;Oi. For example,
AScheme:Sig sk (·) denotes that algorithm A is provided with a signing oracle of signature
scheme Scheme under private key sk.

$← S; : : : ; xl

Deﬁnition 1. A signature scheme SGN is a tuple of three algorithms (Kg; Sig; Ver )
deﬁned as follows:
- (sk ; PK ) ← SGN :Kg(1(cid:20)): Key generation algorithm takes the security parameter
1(cid:20) as the input. It returns a private/public key pair (sk ; PK ) as the output.
- (cid:27) ← SGN :Sig(sk ; D): The signature generation algorithm takes sk and a data
item D as the input. It returns a signature (cid:27) as the output (also denoted as (cid:27) ←
SGN :Sig sk (D)).
- c ← SGN :Ver (PK ; D; (cid:27)): The signature veriﬁcation algorithm takes PK , D and (cid:27)
as the input. It outputs a bit c, with c = 1 meaning valid and c = 0 meaning invalid.

accumulated data intact, or should not use them at all (she cannot selectively delete/modify any subset of this data [20]).
LogFAS is proven to be secure against the truncation attack in Section 5.

4

SGN

(A)

Deﬁnition 2. Existential Unforgeability under Chosen Message Attack (EU-CMA) ex-
periment for SGN is as follows:
Experiment Expt EU -CMA
(sk ; PK ) ← SGN :Kg(1(cid:20)), (D
If SGN :Ver (PK ; D
) = 1 and D
EU-CMA-advantage of A is Adv EU -CMA
EU-CMA-advantage of SGN is Adv EU -CMA
the maximum is over all A having time complexity t, making at most L oracle queries,
and the sum of lengths of these queries being at most (cid:22) bits.

) ← ASGN :Sig sk (·)(PK ),
∗ was not queried, return 1, else, return 0.
(A) = P r[Expt EU -CMA

(A) = 1].
(t; L; (cid:22)) = maxA{Adv EU -CMA

SGN

SGN

SGN

SGN

; (cid:27)

; (cid:27)

∗

∗

∗

∗

(A)}, where

q is a random oracle.

LogFAS is built on the Schnorr signature scheme [26]. It also uses an Incremental
Hash function IH [3] and a generic signature scheme SGN (e.g., Schnorr) as building
blocks. Both Schnorr and IH require that H : {0; 1}∗ → Z∗
Deﬁnition 3. The Schnorr signature scheme is a tuple of three algorithms (Kg; Sig; Ver )
behaving as follows:
- (y;⟨p; q; (cid:11); Y ⟩) ← Schnorr :Kg(1(cid:20)): Key generation algorithm takes 1(cid:20) as the input.
It generates large primes q and p > q such that q|(p − 1), and then generates a
q; Y ←
generator (cid:11) of the subgroup G of order q in Z∗
(cid:11)y mod p), and returns private/public keys (y;⟨p; q; (cid:11); Y ⟩) as the output.
- (s; R; e) ← Schnorr :Sig(y; D): Signature generation algorithm takes private key y
and a data item D as the input. It returns a signature triplet (s; R; e) as follows:
R←(cid:11)r mod p; e←H(D||R); s←(r − e · y) mod q, where r $← Z∗
q.
- c ← Schnorr :Ver (⟨p; q; (cid:11); Y ⟩; D;⟨s; R; e⟩): Signature veriﬁcation algorithm takes
public key ⟨p; q; (cid:11); Y ⟩, data item D and signature ⟨s; R; e⟩ as the input. It returns a
bit c, with c = 1 meaning valid if R = Y e(cid:11)s mod p, and with c = 0 otherwise.

p. It also generates (y $← Z∗

Deﬁnition 4. Given a large random integer q and integer L, incremental hash func-
tion family IH is deﬁned as follows: Given a random key z = (z0; : : : ; zL−1), where
(z0; : : : ; zL−1) $← Z∗
q and hash function H, the associated incremental hash function
IHq;L
takes an arbitrary data item set D0; : : : ; DL−1 as the input. It returns an integer
T ∈ Zq as the output,
Algorithm IHq;L
L−1
z
j=0 H(Dj)zj mod q, return T .

T ←∑

(D0; : : : ; DL−1)

z

Target Collision Resistance (TCR) [5] of IH relies on the intractability of Weighted

Sum of Subset (WSS) problem [3, 13] assuming that H is a random oracle.
, let A0 be an algorithm that returns a set of target mes-
Deﬁnition 5. Given IHq;L
sages, and A1 be an algorithm that returns a bit. Consider the following experiment:
Experiment Expt TCRIHq;L
(D0; : : : ; DL−1) ← A0(L), z = (z0; : : : ; zL−1) $← Z∗
q,
T ← IHq;L

L−1) ← A1(D0; : : : ; DL−1; T;IHq;L
∗

(A = (A0;A1))

(D0; : : : ; DL−1); (D

∗
0; : : : ; D

)

z

z

z

z

5

L−1) ∧ ∃j ∈ {0; : : : ; L − 1} : D
∗

∗
j

̸= Dj, return 1, else,

z

(D

∗
0; : : : ; D

If T = IHq;L
return 0.
TCR-advantage of A is Adv TCRIHq;L
TCR-advantage of IHq;L
mum is over all A having time complexity t.

is Adv TCRIHq;L

z

z

(A) = P r[Expt TCRIHq;L

(A) = 1].
(t) = maxA{AdvTCRIHq;L

z

z

z

(A)}, where the maxi-

3 Syntax and Models

LogFAS is a Forward-secure and Append-only Signature (FSA) scheme, which com-
bines key-evolve (e.g., [2, 15]) and signature aggregation (e.g., [8]) techniques. Specif-
ically, LogFAS is built on the Schnorr signature scheme [23, 26], and it integrates
forward-security and signature aggregation strategies in a novel and efﬁcient way. That
is, different from previous approaches (e.g., [17–20, 25, 29, 30]), LogFAS introduces
veriﬁcation with a constant number of ExpOps, selective subset veriﬁcation and sub-
linear search properties via incremental hashing [3] and masked tokens in addition to
the above strategies.

Before giving more details, we brieﬂy discuss the append-only signatures. A forward-
secure and aggregate signature scheme is an append-only signature scheme if no mes-
sage can be re-ordered or selectively deleted from a given stream of messages, while
new messages can be appended to the stream [18, 20]. In Section 5, we prove that Log-
FAS is an append-only signature scheme.

Deﬁnition 6. A FSA is comprised of a tuple of three algorithms (Kg; FASig; FAVer )
behaving as follows:
- (sk ; PK ) ← FSA:Kg(1(cid:20); L): The key generation algorithm takes the security pa-
rameter 1(cid:20) and the maximum number of key updates L as the input. It returns a
private/public key pair (sk ; PK ) as the output.
- (sk j+1; (cid:27)0;j) ← FSA:FASig(sk j; Dj; (cid:27)0;j−1): The forward-secure and append-
only signing algorithm takes the current private key sk j, a new message Dj to be
signed and the append-only signature (cid:27)0;j−1 on the previously signed messages (D0;
: : : ; Dj−1) as the input. It computes an append-only signature (cid:27)0;j on (D0; : : : ; Dj),
evolves (updates) sk j to sk j+1, and returns (sk j+1; (cid:27)0;j) as the output.
- c ← FSA:FAVer (PK ;⟨D0; : : : ; Dj⟩; (cid:27)0;j): The forward-secure and append-only
veriﬁcation algorithm takes PK , ⟨D0; : : : ; Dj⟩ and their corresponding (cid:27)0;j as the
input. It returns a bit c, with c = 1 meaning valid, and c = 0 otherwise.

In LogFAS, private key sk is a vector, whose elements are comprised of specially
constructed Schnorr private keys and a set of tokens. These tokens later become the part
of append-only signature (cid:27) accordingly. The public key PK is a system-wide public key
that is shared by all veriﬁers, and is comprised of two long-term public keys. Details
are given in Section 4.

6

3.1 System Model

LogFAS system model is comprised of a Key Generation Center (KGC) and multiple
signers (i.e., logging machines that could be compromised) and veriﬁers. As in forward-
secure stream integrity model (e.g., [7, 17, 18]), signers honestly execute the scheme
until they are compromised by the adversary. Veriﬁers may be untrusted.

The KGC executes LogFAS :Kg once ofﬂine before the deployment, and distributes
a distinct private key/token set (auxiliary signature) to each signer, and two long-term
public keys to all veriﬁers. After the deployment, a signer computes the forward-secure
and append-only signature of log entries with LogFAS :FASig, and veriﬁers can verify
the signature of any signer with LogFAS :FAVer via two public keys without commu-
nicating with KGC (constant storage overhead at the veriﬁer side).

In LogFAS, the same logger computes the append-only signature of her own log
entries. Note that this form of signature computation is ideal for the envisioned secure
audit logging applications, since each logger is only responsible for her own log entries.

3.2 Security Model

A FSA scheme is proven to be ForWard-secure Existentially Unforgeable against Cho-
sen Message Attack (FWEU-CMA) based on the experiment deﬁned in Deﬁnition 7. In
this experiment, A is provided with two types of oracles that she can query up to L
messages in total as follows:
A is ﬁrst provided with a batch signing oracle FASig sk (·). For each batch query j,
−→
D j of her choice once. FASig sk (·) re-
A queries FASig sk (·) on a set of message
turns a forward-secure and append-only signature (cid:27)0;j under sk by aggregating (cid:27)j
−→
D j with the previous signature (cid:27)0;j−1 on
(i.e., the current append-only signature) on
−→
−→
D j−1 that A queried. Assume that A makes i batch queries (with 0 ≤ l ≤ L
D 0; : : : ;
individual messages) as described the above until she decides to “break-in”.
A then queries the Break -in oracle, which returns the remaining L − l private keys
to A (if l = L Break -in rejects the query).
Deﬁnition 7. FWEU-CMA experiment is deﬁned as follows:
(A)
Experiment Expt FWEU -CMA
(sk; P K) ← FSA:Kg(1(cid:20); L), (
If FSA:FAVer (P K;
return 0.
FWEU-CMA-advantage of A is Adv FWEU -CMA

) ← AFASig sk (·);Break -in (P K),
−→
D k, return 1, else,
(A) = 1].
(t; L; (cid:22)) = maxA{AdvFWEU -CMA
FWEU-CMA-advantage of FSA is Adv FWEU -CMA
where the maximum is over all A having time complexity t, making at most L oracle
queries, and the sum of lengths of these queries being at most (cid:22) bits.
The above experiment does not implement a random oracle for A explicitly. How-
ever, we still assume the Random Oracle Model (ROM) [4], since Schnorr signature
scheme [26] on which LogFAS is built requires the ROM. Note that this experiment
also captures the truncation attacks:

(A) = P r[Expt FWEU -CMA

−→
∗ ̸= ||k∈I
D

−→
∗
D

∗

) = 1 ∧ ∀I ⊆ {0; : : : ; l};

; (cid:27)

FSA

−→
∗
D

∗

; (cid:27)

FSA

FSA

FSA

7

FSA

(A)},

(i) The winning condition of A subsumes the truncation attack in addition to data
modiﬁcation. That is, A wins the experiment when she either modiﬁes a data item or
keeps data items intact but outputs a valid signature on a subset of a given batch query
(i.e., she splits an append-only signature without knowing its individual signatures).

(ii) LogFAS uses a standard signature scheme SGN to prevent truncation attacks by
computing signatures of counter values. Resilience against the traditional data forgery
(without truncation) relies on EU-CMA property of Schnorr and target collision-freeness
of IH. In Theorem 1, we prove that a successful truncation attack against LogFAS is
equivalent to breaking SGN , and a successful data modiﬁcation (including re-ordering)
against LogFAS is equivalent to breaking Schnorr or IH.
4 LogFAS Schemes
In this section, we ﬁrst present the intuition and detailed description of LogFAS, and
then describe a LogFAS variation that has additional capabilities.

4.1 LogFAS Scheme

All existing FSA constructions [17–20, 29] rely on a direct combination of an aggre-
gate signature (e.g., [8]) and a forward-secure signature (e.g., [1, 15]). Therefore, the
resulting constructions simultaneously inherit all overheads of their base primitives:
(i) Forward-secure signatures on individual data items, which are done separately from
the append-only design, force veriﬁers to perform O(l) ExpOps. (ii) These schemes ei-
ther eliminate ExpOps from the logging phase with pre-computation but incur quadratic
storage overhead to the veriﬁers (e.g., [29]), or require ExpOps in the logging phase for
each log entry and incur linear storage overhead to the veriﬁers (e.g., [12, 17, 20]).

The above observations inspired us to design cryptographic mechanisms that can
verify the integrity of entire log entry set once directly (preserving forward-security),
instead of checking the integrity of each data item individually, though the signing
operations have to be performed on individual data items. That is, instead of verifying
each item one-by-one with the corresponding public key(s), verify all of them via a
single set of aggregated cryptographic components (e.g., tokens as auxiliary signatures).
These mechanisms also achieve constant storage overhead at the veriﬁer side3.
incremental hash IH as follows:
a) To compute a forward-secure and append-only Schnorr signature, we aggregate
each individual signature sl on Dl with the previous aggregate signature as s0;l ←
s0;l−1 + sl mod q; (0 < l ≤ L − 1; s0;0 = s0). This is done by using a distinct private
key pair (rj; yj) for j = 0; : : : ; L − 1 on each data item.

We achieve these goals with a provable security by using Schnorr signature and

b) Despite being forward-secure, the above construction still requires an ExpOp
for each data item. To verify the signature on D0; : : : ; Dl with only a small-constant
number of ExpOps, we introduce the notion of token.
In LogFAS, each Schnorr private yj is comprised of a random key pair (aj; dj) for
j = 0; : : : ; L − 1. Random key aj is mutually blinded with another random factor xj
and also a long-term private key b for j = 0; : : : ; L − 1. The result of these blinding
3 In all existing forward-secure and/or aggregate (append-only) logging schemes (e.g., [7,12,17,19,20,29]), the signer side

storage overhead is dominated by the accumulated logs, which already incur a linear storage overhead.

8

Rj as R0;l ← ∏

operations is called auxiliary signature (token) zj, which can be kept publicly without
revealing information about (aj; xj) and also can be authenticated with the long-term
public key B by all veriﬁers. Furthermore, these masked tokens z = z0; : : : ; zl also
serve as a one-time initialization key for the incremental hash as IHq;l
(Deﬁnition 4),
which enable veriﬁers to reduce the integrity of each Dj into the integrity of a ﬁnal tag
z0;l. This operation preserves the integrity of each Dj and veriﬁability of each zj (via
public key B) without ExpOps.

z

l

c) To verify (s0;l; z0;l) via B in an aggregate form, veriﬁers also aggregate tokens
j=0 Rj mod p, where p a large prime on which the group was con-
structed. However, initially, (s0;l; R0;l; z0;l) cannot be veriﬁed directly via B, since the
reduction operations introduce some extra veriﬁcation information. LogFAS handles
′
this via auxiliary signature (token) M
0;l that bridges (s0;l; R0;l; z0;l) to B. That is, the
l mod p, where 0 < l ≤ L − 1
′
signer computes an aggregate token M
0;l
and M0;0 = M0), along with s0;l in the signing process. During veriﬁcation, this ag-
gregate token eliminates the extra terms and bridges (s0;l; R0;l; z0;l) with B.

′
0;l−1M ej

← M

−1

q; B ← (cid:11)b

private key of all signers in the system. System-wide public key of all veriﬁers is

This approach allows LogFAS to compute publicly veriﬁable signatures with only
one ExpOp per-item, and this signature can be veriﬁed with only a small-constant num-
ber of ExpOps by storing only two public keys at the veriﬁer side (regardless of the
number of signers). This is much more efﬁcient than all of its PKC-based counterparts,
and also is as efﬁcient as the symmetric schemes at the veriﬁer side.
The detailed description of LogFAS algorithms is given below:
1) LogFAS :Kg(1(cid:20); L): Given 1(cid:20), generate primes q and p > q such that q|(p − 1), and
then generate a generator (cid:11) of the subgroup G of order q in Z∗
p.
a) Generate (b $← Z∗

mod p) and (bsk ;dPK ) ← SGN :Kg(1(cid:20)). System-
wide private key of KGC is sk ← (b; bsk ). This private key is used to compute the
PK ← {p; q; (cid:11); B;dPK ; L}. This public key can verify any valid signature gener-
q for j = 0; : : : ; L − 1. The private key of signer IDi
is sk ← {rj; yj; zj; Mj; Rj; (cid:12)j}L−1
j=0 , where
- Generate the Schnorr private key of each IDi as yj ← aj − dj mod q. Generate
the masked token of IDi as zj ← (aj − xj)b mod q, which is used for integrity
reduction at the veriﬁcation phase.
- Rj ← (cid:11)rj mod p; Mj ← (cid:11)xj−dj mod p. Each Rj serves as a part of Schnorr
signature and it is aggregated by the veriﬁer upon its receipt. Mj is the aggregate
token and is aggregated by the signer during the logging process.

- (cid:12)j ← SGN :Sig(bsk ; H(IDi||j)). Note that each (cid:12)j is kept secret initially, and

b) Generate (rj; aj; dj; xj) $← Z∗

ated by a legitimate signer.

then released as a part of a signature publicly.

2) LogFAS :FASig(⟨rl; yl; zl; Ml; Rl; (cid:12)l⟩; Dl; (cid:27)0;l−1): Given (cid:27)0;l−1 on D0; : : : ; Dl−1,
compute (cid:27)0;l on D0; : : : ; Dl as follows,
a) el ← H(Dl||l||zl||Rl); M
← M el
b) s0;l ← s0;l−1 + sl mod q; (0 < l ≤ L − 1; s0;0 = s0),

l mod p; sl ← rl − elyl mod q,

′
l

9

′
0;l

← M

l mod p; (0 < l ≤ L − 1; M
′
′
c) M
0;l−1M
0;l; (cid:12)l; Rj; ej; zj}l
d) (cid:27)0;l ← {s0;l; M
′
3) LogFAS :FAVer (PK ;⟨D0; : : : ; Dl⟩; (cid:27)0;l):

a) If SGN :Ver (dP K; H(IDi||l); (cid:12)l) = 0 then return 0, else continue,

′
0;0 = M0),

j=0 and erase (rl; yl; s0;l−1; sl; (cid:12)l−1).

(D0||w||z0|| R0; : : : ; Dl||w||zl||Rl).

z0;:::;zl

∏
z0;l = IHq;l

b) If

l
j=0 Rj mod p = M

′
0;l

· Bz0;l · (cid:11)s0;l mod p holds return 1, else return 0, where

4.2 Selective Veriﬁcation with LogFAS

All the previous FSA constructions (e.g., [17–19, 29, 30]) verify the set of log entries
via only the ﬁnal aggregate signature to prevent the truncation attack and save the stor-
age. However, this approach causes performance drawbacks: (i) The veriﬁcation of any
subset of log entries requires the veriﬁcation of the entire set of log entries (i.e., always
O(L) ExpOps for the subset veriﬁcation). (ii) The failure of signature veriﬁcation does
not give any information about which log entries were corrupted.

Ma et al. proposed immutable-FssAgg (iFssAgg) schemes in [20] to allow ﬁne-
grained veriﬁcation without being vulnerable to truncation attacks. However, iFssAgg
schemes double the signing/verifying costs of their base schemes. In addition, even if
the signature veriﬁcation fails due to only a few corrupted log entries (i.e., accidentally
damaged entry(ies)), detecting which log entry(ies) is (are) responsible for the failure
requires verifying each individual signature.

LogFAS can address the above problems via a simple variation without incurring
any additional costs: The signer keeps all signatures and tokens in their individual forms
(including sj for j = 0; : : : ; l) without aggregation. The veriﬁers can aggregate them
according to their needs by preserving the security and veriﬁability. This offers perfor-
mance advantages over iFssAgg schemes [20]:

(i) LogFAS protects the number of log entries via pre-computed tokens (cid:12)0; : : : ; (cid:12)l,
and therefore individual signatures can be kept without a truncation risk. This elim-
inates the necessity of costly immutability strategies used in iFssAgg schemes [20].
Furthermore, a veriﬁer can selectively aggregate any subset of l
< l log entries and
verify them by performing only a small-constant number of ExpOps as in the original
′
LogFAS. This is much more efﬁcient than the iFssAgg schemes, which require O(2l
)
ExpOps.

′

(ii) LogFAS can use a recursive subset search strategy to identify corrupted log en-
tries causing the veriﬁcation failure faster than linear search4. That is, the set of log en-
tries is divided into subsets along with their corresponding individual signatures. Each
subset is then independently veriﬁed by LogFAS :AVer via its corresponding aggregate
signature, which is efﬁciently computed from individual signatures. Subsets returning
1 are eliminated from the search, while each subset returning 0 is again divided into
subsets and veriﬁed by LogFAS :AVer as described. This subset search continues re-
cursively until all the corrupted log entries are identiﬁed.

4 Note that the previous PKC-based audit logging schemes cannot use such a recursive subset search strategy to identify
corrupted log entries with a sub-linear number ExpOps, since they always require linear number of ExpOps to verify a
given subset from the entire log entry set (in contrast to LogFAS that requires O(1)ExpOp to verify a given subset).

10

The above strategy can quickly identify the corrupted entries when most log entries
are intact. For instance, if only one entry is corrupted, it can identify the corrupted entry
by performing (2 log2 l) ExpOps + O(l) hash operations. This is much faster than linear
search used in the previous PKC-based schemes, which always requires O(l) ExpOps
+ O(l) hash operations.
Recursive subset strategy remains more efﬁcient than linear search as long as the
number of corrupted entries c satisﬁes c ≤ l
2 log2 l , depending on c
and the distribution of corrupted entries, recursive subset search might be more costly
than linear search. To minimize the performance loss in such an inefﬁcient case, the
veriﬁer can switch from recursive subset search to the linear search if the recursive
division and search step continuously returns 0 for each veriﬁed subset. The veriﬁer
can ensure that the performance loss due to an inefﬁcient case does not exceed the
average gain of an efﬁcient case by setting the maximum number of recursive steps to
=2 − log2 l
be executed to l
5 Security Analysis
We prove that LogFAS is a FWEU-CMA signature scheme in Theorem 1 below.

′ for each subset with l

2 log2 l . When c > l

′ entries.

′

Theorem 1 Adv FWEU -CMA

LogFAS

(t; L; (cid:22)) is bounded as follows,

Adv FWEU -CMA

LogFAS

(t; L; (cid:22)) ≤ L · Adv EU -CMA
Schnorr (t

′

; 1; (cid:22)
Adv EU -CMA

SGN

′

)+
′′

(t

; L; (cid:22)

′′

) + Adv TCRIHq;L

z

(t

′′′

);

′
where t

= O(t) + L · O((cid:20)3) and (cid:22)

′

= (cid:22)=L.

The proof of the theorem can be found in our accompanying technical report [31].

Remark 1 Another security concern in audit logging is delayed detection identiﬁed
in [19]. In delayed detection, log veriﬁers cannot detect whether the log entries are
modiﬁed until an online TTP provides auxiliary keying information to them. LogFAS
does not rely on an online TTP support or time factor to achieve the signature veriﬁca-
tion, and therefore it is not prone to delayed detection.

6 Performance Analysis and Comparison

In this section, we present the performance analysis of LogFAS and compare it with
previous schemes.

Computational Overhead: From a veriﬁer’s perspective, LogFAS requires only a
small-constant number of modular exponentiations regardless of the number of log en-
tries to be veriﬁed. Therefore, it is much more efﬁcient than all PKC-based schemes,
which require one modular exponentiation (or a pairing) per log entry. Besides, it does
not double the veriﬁcation cost to prevent the truncation attacks, providing further efﬁ-
ciency over iFssAgg schemes [20]. The veriﬁcation of subsets from these entries with
LogFAS is also much more efﬁcient than all of its counterparts.

11

Table 2. Execution time (in ms) comparison of LogFAS and its counterparts

Sym.

LogFAS
′
(l = 104; l
5:06 × 104

Criteria

Off. Kg, L = 104
Sig&Upd (1)
= 102
l
= 103
l
l = 104

Ver.

Onl.

′
′

PKC-based

FssAgg (l) / iFssAgg (l

)

′

AR / i

< l) BLS / i

BM / i

Logcrypt

BAF
3:3 × 103 8:8 × 104 1:7 × 1052:6 × 104 4 × 104
˜20
1.8 / 3.6
0.007
0.004
4:8 × 103 1:8 × 103 1:6 × 1051:4 × 103 0:2 × 103 0.2
4:8 × 104 1 × 104 1:8 × 1051:5 × 104 2:05 × 103
2
2:6 × 105 4:7 × 104 1:9 × 1051:4 × 105 2:04 × 104 19.9

13.1 / 26.2

28 / 56

2.05

1.2
72.87
75.2
98.12

From a logger’s perspective, LogFAS is also more efﬁcient than its PKC-based

counterparts with the exception of BAF.

We prototyped our schemes and their counterparts on a computer with an Intel(R)
Xeon(R)-E5450 3GHz CPU and 4GB RAM running Ubuntu 9.04. We tested LogFAS,
BAF [29], FssAgg-BLS [18], Logcrypt (with DSA), and the symmetric schemes (e.g.,
[7, 18, 25]) using the MIRACL library [27], and FssAgg-AR/BM using the NTL li-
brary [28] 5. Table 2 compares the computational cost of LogFAS with its counterparts
numerically in terms of their execution times (in ms). The execution time differences
with LogFAS and its PKC-based counterparts grow linearly with respect to the number
of log entries to be veriﬁed. Initially, the symmetric schemes are more efﬁcient than all
PKC-based schemes, including ours. However, since the veriﬁcation operations of Log-
FAS are dominated by H, their efﬁciency become comparable with symmetric schemes
as the number of log entries increases (e.g., l = 104)6.

Figure 1 and Figure 2 further compare LogFAS and previous schemes that allow
public veriﬁcation in terms of signature generation and veriﬁcation times as the number
of log entries increases. These ﬁgures demonstrate that LogFAS is the most veriﬁer
computationally efﬁcient scheme among all these choices. It is also more efﬁcient than
its counterparts for the signature generation with the exception of BAF.

All PKC-based schemes require O(L) ExpOps in the key generation phase.
Signature/Key/Data Storage and Transmission Overheads:
LogFAS is a veriﬁer storage friendly scheme; it requires each veriﬁer to store only
two public keys and an index along with system-wide parameters (e.g., |q| + |4p|),
regardless of the number of signers or the number of log entries to be veriﬁed.
In LogFAS, the append-only signature size is |q|. The key/token and data storage
overheads on the logger side are linear as O(L(5|q| + 2|p|)) + O(l|D|) (assuming SGN
is chosen as Schnorr [26]). LogFAS transmits a token set along with each data item re-
quiring O(l(|q|+|p|+|D|)) transmission in total. The ﬁne-grain veriﬁcation introduces
′
) extra storage/communication overhead due to the individual signatures.
O(l
From a veriﬁer’s perspective, LogFAS is much more storage efﬁcient than all ex-
isting schemes, which require either O(L · S) storage (e.g., FssAgg-BLS [18] and
BAF [29]), or O(S) storage (e.g., [7,12,17,20,25]). From a logger’s perspective, all the

5 Suggested bit lengths to achieve 80-bit security for each compared schemes are as follows (based on the parameters
suggested by Lenstra et al. in [16] and Ma et al. in [17, 18]): Large primes (|p| = 2048; |q| = 1600) for LogFAS and
Logcrypt, primes (|p
′| = 1024; z = 160) for FssAgg-AR and
′| = 512; |q
′
FssAgg-BM, where n
6 To achieve TCR property for IH, LogFAS uses relatively larger modulo sizes than its counterparts. However, since
LogFAS requires only a small-constant number of ExpOps for the signature veriﬁcation and a single ExpOp for the
signature generation, the effect of large modulo size over its performance is negligible.

′| = 160) for BAF and FssAgg-BLS, (|n

is Blum-Williams integer [17].

12

Fig. 1. Signing time comparison of LogFAS and
its counterparts (in ms)

Fig. 2. Veriﬁcation time comparison of LogFAS
and its counterparts (in ms)

Table 3. Key size, signature size and storage overheads of LogFAS and previous schemes

Criteria

LogFAS

Key size O(L)(|q| + |p|)
Sig. size O(l)(|q| + |p|)
Storage O(L + l)(|q| + |p|)

Sig.

Ver. Key size
Storage

|q| + 4|p|
|q| + 4|p|

BAF
3|q
′|
|q
′|
4|q
′|
′|
2|p

O(L · S)(2|p

PKC-based

BLS [18]

FssAgg Schemes [19, 20]
Logcrypt [12]
AR [17]
′|
′| + |p
′|
|q
′|
3|n
|q
2|q
′|
|p
′|
|n
′|
′| O(L)(|q
′| + 3|p
4|n
′| + |p
′|
′|
′| + |p
3|n
′|
|q
′|O(L)(|q
′|)O(L · S)|q
′| + |p
′|zO(S)|3n

BM [17]
|n
′|z
|n
′|
|n
′|l
′|
′|z
|n
′|O(S)|n

2|q

2|q

Symmetric

[18, 24, 25]

Sym.
|H|
|H|
|H|

′|) O(V )|H|
′|) O(S)|H|

The values in this table are simpliﬁed by omitting some constant/neglibigle terms. For instance, the overhead of data items
to be transmitted are the same for all compared schemes and therefore are omitted.

compared schemes both accumulate (store) and transmit linear number of data items
(i.e., O(l)|D|) until their veriﬁers become available to them. This dominates the main
storage and communication overhead for these schemes. In addition to this, LogFAS
requires linear key storage overhead at the logger side, which is slightly less efﬁcient
than [17, 18, 29]. LogFAS with ﬁne-grained veriﬁcation and its counterpart iFssAgg
schemes [20] both require linear key/signature/data storage/transmission overhead.

Availability, Applicability and Security: The symmetric schemes [7, 25] are not
publicly veriﬁable and also require online server support to verify log entries. Further-
more, they are vulnerable to both truncation and delayed detection attacks [19,20] with
the exception of FssAgg-MAC [18]. In contrast, PKC-based schemes [12, 17–20] are
publicly veriﬁable without requiring online server support, and they are secure against
the truncation and delayed detection attacks, with the exception of Logcrypt [12].

7 Related Work
Most closely related are those forward-secure audit logging schemes [6,7,12,17–20,25,
29]. The comparison of these schemes with LogFAS has been presented in Section 6.

Apart from the above schemes, there is a set of works complementary to ours.
Itkis [14] proposed cryptographic tamper resistance techniques that can detect tam-
pering even if all the keying material is compromised. LogFAS can be combined with
Itkis model as any forward-secure signature [14]. Yavuz et al. [30] proposed a Hash-
based Forward-Secure and Aggregate Signature Scheme (HaSAFSS) for unattended

13

020004000600080001000010−410−2100102104106Number of log entries to be signed (l)Execution time (in ms)LogFASFssAgg−BLSFssAgg−BMFssAgg−ARLogcryptBAF010002000300040005000600070008000900010000100102104106108Number of log entries to be verified (l)Execution time (in ms)LogFASFssAgg−BLSFssAgg−BMFssAgg−ARLogcryptBAFwireless sensor networks, which uses timed-release encryption to achieve computa-
tional efﬁciency. Davis et al. proposed time-scoped search techniques on encrypted au-
dit logs [10]. There are also authenticated data structures that can be used for audit
logging in distributed systems [9,22]. LogFAS can serve as a digital signature primitive
needed by these constructions.
8 Conclusion
In this paper, we proposed a new forward-secure and append-only audit logging scheme
called LogFAS. LogFAS achieves public veriﬁability without requiring any online trusted
server support, and is secure against truncation and delayed detection attacks. LogFAS
is much more computationally efﬁcient than all existing PKC-based alternatives, with a
performance comparable to symmetric schemes at the veriﬁer side. LogFAS is also the
most veriﬁer storage efﬁcient scheme among all existing alternatives. Last, a variation
of LogFAS enables selective subset veriﬁcation and efﬁcient search of corrupted log
entries. Overall, our comparison with the existing schemes shows that LogFAS is an
ideal choice for secure audit logging by offering high efﬁciency, security, and public
veriﬁability simultaneously for real-life applications.
References

1. M. Abdalla and L. Reyzin. A new forward-secure digital signature scheme. In Advances in

Crpytology (ASIACRYPT ’00), pages 116–129. Springer-Verlag, 2000.

2. R. Anderson. Two remarks on public-key cryptology, invited lecture. Proceedings of the 4th

ACM conference on Computer and Communications Security (CCS ’97), 1997.

3. M. Bellare and D. Micciancio. A new paradigm for collision-free hashing: Incrementality at
reduced cost. In Proc. of the 16th International Conference on the Theory and Applications
of Cryptographic Techniques (EUROCRYPT ’97), pages 163–192. Springer-Verlag, 1997.

4. M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efﬁcient
In Proceedings of the 1st ACM conference on Computer and Communications

protocols.
Security (CCS ’93), pages 62–73, NY, USA, 1993. ACM.

5. M. Bellare and P. Rogaway. Collision-resistant hashing: Towards making UOWHFs prac-
tical. In Proceedings of Advances in Cryptology (CRYPTO ’97), pages 470–484, London,
UK, 1997. Springer-Verlag.

6. M. Bellare and B. S. Yee. Forward integrity for secure audit logs. Technical report, San

Diego, CA, USA, 1997.

7. M. Bellare and B. S. Yee. Forward-security in private-key cryptography. In Proceedings of

the The Cryptographers Track at the RSA Conference (CT-RSA ’03), pages 1–18, 2003.

8. D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and veriﬁably encrypted signa-
tures from bilinear maps. In Proc. of the 22th International Conference on the Theory and
Applications of Cryptographic Techniques (EUROCRYPT ’03), pages 416–432. Springer-
Verlag, 2003.

9. S. Crosby and D. S. Wallach. Efﬁcient data structures for tamper evident logging. In Pro-

ceedings of the 18th conference on USENIX Security Symposium, August 2009.

10. D. Davis, F. Monrose, and M. Reiter. Time-scoped searching of encrypted audit logs. In Proc.
of the 6th International Conference on Information and Communications Security (ICICS
’04), pages 532–545, 2004.

11. K. Fall. A delay-tolerant network architecture for challenged internets. In Proceedings of
the 9th conference on Applications, technologies, architectures, and protocols for computer
communications, (SIGCOMM ’03), pages 27–34. ACM, 2003.

14

12. J. E. Holt. Logcrypt: Forward security and public veriﬁcation for secure audit logs. In Proc.
of the 4th Australasian workshops on Grid computing and e-research (ACSW ’06), pages
203–211, 2006.

13. R. Impagliazzo and M. Naor. Efﬁcient cryptographic schemes provably as secure as subset
sum. In Proceedings of the 30th Annual Symposium on Foundations of Computer Science,
pages 236–241, Washington, DC, USA, 1989. IEEE Computer Society.

14. G. Itkis. Cryptographic tamper evidence. In Proc. of the 10th ACM conference on Computer
and communications security (CCS ’03), pages 355–364, New York, NY, USA, 2003. ACM.
15. H. Krawczyk. Simple forward-secure signatures from any signature scheme. In Proceedings
of the 7th ACM conference on Computer and Communications Security, (CCS ’00), pages
108–115. ACM, 2000.

16. A. K. Lenstra and E. R. Verheul. Selecting cryptographic key sizes. Journal of Cryptology,

14(4):255–293, 2001.

17. D. Ma. Practical forward secure sequential aggregate signatures. In Proceedings of the 3rd
ACM symposium on Information, Computer and Communications Security (ASIACCS ’08),
pages 341–352, NY, USA, 2008. ACM.

18. D. Ma and G. Tsudik. Forward-secure sequential aggregate authentication. In Proceedings

of the 28th IEEE Symposium on Security and Privacy (S&P ’07), pages 86–91, May 2007.

19. D. Ma and G. Tsudik. A new approach to secure logging.

In Proc. of the 22nd Annual
IFIP WG 11.3 Working Conference on Data and Applications Security (DBSEC ’08), pages
48–63, 2008.

20. D. Ma and G. Tsudik. A new approach to secure logging. ACM Transaction on Storage

(TOS), 5(1):1–21, 2009.

21. A. Oprea and K. D. Bowers. Authentic time-stamps for archival storage. In 14th European
Symposium on Research in Computer Security, (ESORICS ’09), pages 136–151, Berlin, Hei-
delberg, 2009. Springer-Verlag.

22. C. Papamanthou, R. Tamassia, and N. Triandopoulos. Authenticated hash tables. In Proc.
of the 15th ACM conference on Computer and Communications Security (CCS 2008), pages
437–448, New York, NY, USA, 2008. ACM.

23. D. Pointcheval and J. Stern. Security proofs for signature schemes.

In Proc. of the 15th
International Conference on the Theory and Application of Cryptographic Techniques (EU-
ROCRYPT ’96), pages 387–398. Springer-Verlag, 1996.

24. B. Schneier and J. Kelsey. Cryptographic support for secure logs on untrusted machines. In

Proc. of the 7th conference on USENIX Security Symposium. USENIX Association, 1998.

25. B. Schneier and J. Kelsey. Secure audit logs to support computer forensics. ACM Transaction

on Information System Security, 2(2):159–176, 1999.

26. C. Schnorr. Efﬁcient signature generation by smart cards. Journal of Cryptology, 4(3):161–

174, 1991.

27. Shamus. Multiprecision integer and rational arithmetic c/c++ library (MIRACL). http:

//www.shamus.ie/.

28. V. Shoup. NTL: A library for doing number theory. http://www.shoup.net/ntl/.
29. A. A. Yavuz and P. Ning. BAF: An efﬁcient publicly veriﬁable secure audit logging scheme
In Proceedings of 25th Annual Computer Security Applications

for distributed systems.
Conference (ACSAC ’09), pages 219–228, 2009.

30. A. A. Yavuz and P. Ning. Hash-based sequential aggregate and forward secure signature
In Proceedings of the 6th Annual International

for unattended wireless sensor networks.
Conference on Mobile and Ubiquitous Systems (MobiQuitous ’09), July 2009.

31. A. A. Yavuz, P. Ning, and M. K. Reiter. Efﬁcient, compromise resilient and append-only
cryptographic schemes for secure audit logging. Technical Report TR-2011-21, Raleigh,
NC, USA, September 2011.

15

