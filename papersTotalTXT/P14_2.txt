Static detection of C++ vtable 
escape vulnerabilities in binary 
code 

David Dewey

 Jonathon Giffin 
School of Computer Science  
Georgia Institute of Technology 
{ddewey, giffin}@gatech.edu 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Common problem in C++ 

In C++ specifically, how does one convert and instance of an 
object into an instance of another object? 

 “…use static_cast in all cases and see what the compiler 
 

 says.” 

 
 

 B. Stroustrup. The Design and Evolution of C++.  
 

 Pearson Education, 1994. 

2 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

C++ Type confusion vulnerabilities 

Adobe Flash Player SharedObject Type Confusion Vulnerability 

 CVE-2011-0611 

Microsoft ATL/MFC ActiveX Type Confusion Vulnerability 

 CVE-2009-2494 

Microsoft Office Excel Conditional Expression Ptg Type Confusion 
Vulnerability 

 CVE-2011-1989 

The list goes on… and on… and on… 

3 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Reverse engineering C++ binaries is hard 

4 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

As it turns out, these are all the same problem… 

• Recently, many software-level vulnerabilities caused by C++ 
type confusion 
• Compiled C++ code can be very difficult to analyze 
• IDS/IPS vendor wanted to provide signature coverage 
• Software consumer concerned with application security 
• Third-party interoperation 
• Software developers regularly incorrectly use the static_cast 
operator 
• No compiler warning from most modern compilers 
• C++ standard only requires “cv-check” 

5 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Root of the problem 

• This code compiles without 
warning with Visual Studio 
and g++ (< 4.6) 
• Running this code causes a 
call to arbitrary memory 

class class1 { 
public: 
class1(); 
~class1(); 
virtual void addRef(); 
virtual void print(); 

}; 
class class2 : public class1 { 
public: 

} 

6 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

class2(); 
~class2(); 
virtual void voidFunc1() {}; 
virtual void debug(); 

}; 
int tmain(int argc, TCHAR* argv[]) 
{ 

class1 C1; 
C1.addRef(); 
C1.print(); 
static cast<class2*>(&C1)->debug(); 
return 0; 

Same problem 

• In the previous slide, the 
problem should be obvious 
to a developer 
• Consider this code.  _tmain() 
and internalFunction() may 
be “miles apart” 
• Separate libraries 
•  Not caught by g++ 4.6 
• Very common code 
construct in MS COM 

7 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

int internalFunction(void *pv)  
{ 
  static_cast<class1*>(pv)->addRef(); 
  static_cast<class1*>(pv)->print(); 
  static_cast<class1*>(pv)->debug(); 
  return 0; 
} 
int _tmain(int argc, _TCHAR* argv[]) 
{ 
  class1 *C1 = new class1; 
  class2 *C2 = new class2; 
  internalFunction((void *)C1); 
  internalFunction((void *)C2); 
  return 0; 
} 

Structure of a C++ object after compilation 

Class2 

ptr to VTable 

prop1 

prop2 

… 

VTable 

void (Class1::*AddRef)() 

void (Class1::*print)() 

void (Class2::*voidFunc1)

() 

void (Class2::*debug)() 

void Class1::print() 
{ 
    cout << “I’m in 
Class1” <<           endl; 

    return; 
} 

void Class1::AddRef() 
{ 
    prop1++; 

void Class2::voidFunc1
() 
{ 
    return; 
} 

void Class2::debug() 
    return; 
{ 
} 
    cout<<“In       
            debug”<<endl; 

    return; 
} 

8 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

00402138 off 402138 dd offset sub 4010D0 
0040213C dd offset sub 4010A0 
00402140 dd offset nullsub 1 
00402144 dd offset sub 4010B0 
00402148 dd offset dword 402274 
0040214C off 40214C dd offset sub 4010D0 
00402150 dd offset sub 4010A0 
00402154 align 8 
00402158 db 48h ; H 
00402159 db 0 
0040215A db 0 
0040215B db 0 
0040215C db 0 

RECALL 

• Reconstruct C++ objects from binary code 

• Perform reaching definition analysis on object definitions to 
determine which object is being referenced at a given use 
point (make reverse engineering easier) 

• Perform a “congruence check” to determine the safety of the 
use of a given object (detects vtable escape vulnerabilities) 

9 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

High-level architecture of RECALL 

ClassTracker 

Type Mismatches 

llvm-bcwriter 

LLVM bitcode 

x86 Machine Code 

Assembly 

IDA Pro 

LLVM IR 

opt 

Resolved Methods 

10 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

x86 to SSA 

• First, we translate x86 machine code into an SSA-based IR 
• We chose an SSA-based IR to make translation simpler 
• x86 assembly is mostly triple-based 
• Use-def chains are implicit (core requirement for reaching definitions) 
• Problems with going to higher-level IR 
• Chose the LLVM IR due to the robustness of the LLVM 
analysis framework 
• LLVM is attractive from a licensing perspective 

11 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Object reaching definition analysis 

Where: 

 GEN is the set of objects that are 
 instantiated in a given basic block 

 KILL is the set of objects that are 
 deleted in a given basic block 

 For interprocedural analysis, 
 REACHIN  at the entry of a function 
 F is equal to REACH[c] at the call 
 to F from a call site c 

12 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Indentifying object instantiation 

• Stack-allocated 
 

 

 Implement object structure heuristics 
•  Inline constructor
•  Explicit constructor 

  

• Heap-allocated – new() operator 
 

 Call to YAPAXI(uint size) 
•  Inline constructor 
•  Explicit constructor 

13 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Tracking object types 

• For each object, create a structure mapping the structure of 
the object 
• Tag each object type with the virtual address of the 
constructor 

Class2 

ptr to VTable 

prop1 

prop2 

… 

VTable 

void (Class1::*AddRef)() 

void (Class1::*print)() 

void (Class2::*voidFunc1)

() 

void (Class2::*debug)() 

void Class1::print() 
{ 
    cout << “I’m in 
Class1” <<           endl; 

    return; 
} 

void Class1::AddRef() 
{ 
    prop1++; 

void Class2::voidFunc1
() 
{ 
    return; 
} 

void Class2::debug() 
    return; 
{ 
} 
    cout<<“In       
            debug”<<endl; 

14 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

    return; 
} 

Congruence Check 

Class X 
ptr to VTable 

prop1 

prop2 
… 

VTable 

void (Class1::*AddRef)() 

void (Class1::*print)() 

void (Class2::*voidFunc1)() 

void (Class2::*debug)() 

void Class1::AddRef() 
{ 
    prop1++; 

    return; 
} 

void Class1::print() 
{ 
    cout << “I’m in Class1” 
<<         
 endl; 

void Class2::voidFunc1() 
{ 
    return; 
} 

void Class2::debug() 
{ 
    cout<<“In       
            debug”<<endl; 

    return; 
} 

    return; 
} 

VTable 

void (Class1::*AddRef)() 

void (Class1::*print)() 

void (Class2::*voidFunc1)() 

void (Class2::*debug)() 

ClassY 
ptr to VTable 

prop1 

prop2 

… 

Do 
these 
align? 

Do 
these 
align? 

void Class1::AddRef() 
{ 
    prop1++; 

    return; 
} 

void Class1::print() 
{ 
    cout << “I’m in Class1” 
<<         
 endl; 

void Class2::voidFunc1() 
{ 
    return; 
} 

void Class2::debug() 
{ 
    cout<<“In       
            debug”<<endl; 

    return; 
} 

15 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

    return; 
} 

Caveats 

• Not designed for the analysis of malware or obfuscated code 
• Does not require RTTI or debug symbols 
• Focus is on code compiled with Visual Studio, but techniques 
can be generalized to other compilers 
• If an object is allocated and the class pointer is stored in a 
collection, when the pointer is retrieved, we cannot track the 
type (future work) 

16 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Results 

• Able to reconstruct and analyze objects from sample code 
that models: 

 [stack-allocated, heap-allocated] x [inlined ctor, explicit ctor] 

• Able to identify vulnerabilities in microbenchmarks designed 
to simulate real vulnerabilities: 
• Simulated CVE-2011-0611(Adobe Reader) 
• Simulated CVE-2010-0258 (Microsoft Excel) 

17 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Why microbenchmarks? 

REACHIN: 
{} 
REACH: 
{x} 

REACH: {x,y} 

REACH: 
{x} 

Function_A: 
… 
%3 = new() 
… 
%6 = new() 
… 
delete(%6) 
… 
call Function_B(%3) 

18 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

•  Analysis is performed interprocedurally 
•  Procedures can be analyzed 
independent of their location in the 
binary 
•  “Moving” procedures does not impact 
the correctness of the analysis 

Function_B(void* a): 
… 
%2 = new() 
… 
%5 = new() 
… 
delete(%2) 
… 
Call [a+0x4] 

REACHIN: 
{x} 
REACH: {x,z} 

REACH: 
{x,z,w} 
REACH: {x,w} 

Select Related Work 

D. F. Bacon and P. F. Sweeney. Fast static analysis of C++ virtual function calls. In Proceedings of the ACM SIGPLAN 
Conference   on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 1996. 
B. Calder and D. Grunwald. Reducing indirect function call overhead in C++ programs. In Proceedings of the ACM SIGPLAN-

 SIGACT Symposium on Principles of Programming Languages (POPL), Portland, Oregon, 1994. 

C. Meadows. A procedure for verifying security against type confusion attacks. In IEEE Computer Security Foundations 

 Workshop (CSFW), Pacific Grove, California, June 2003. 

H. Pande and B. Ryder. Data-flow-based virtual function resolution. In Proceedings of the Third International Symposium on 
Static  Analysis (SAS), 1996. 
H. D. Pande and B. G. Ryder. Static type determination for C++. In Proceedings of the 6th USENIX C++ Technical 
Conference,  1994. 
A. Slowinska, T. Stancescu, and H. Bos. Howard: A dynamic excavator for reverse engineering data structures. In 

 Proceedings of the Network and Distributed Systems Security Symposium (NDSS), 2011. 

D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. Kang, Z. Liang, J. Newsome, P. Poosankam, and P. Saxena. 

 BitBlaze: A new approach to computer security via binary analysis. In International Conference on Information 
 Systems Security, 2008. 

J. Viega, J. T. Bloch, Y. Kohno, and G. McGraw. ITS4: A static vulnerability scanner for C and C++ code. In Proceedings 

 of the 16th Annual Computer Security Applications Conference (ACSAC), 2000. 

19 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Conclusion 

• In our paper, we make the following contributions: 
• Resolve vtable dispatch calls in compiled binaries 
• Programmatically identify vtable escape vulnerabilities introduced by C++ 
developers 
• Construct a general C++ decompilation framework for use in other analyses 

20 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

Questions? 

ddewey@gatech.edu 

giffin@gatech.edu 

21 

© Copyright 2012 Hewlett-Packard Development Company, L.P.  The information 
contained herein is subject to change without notice.  

