2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy

On the Practicality of Cryptographically Enforcing

Dynamic Access Control Policies in the Cloud

William C. Garrison III
University of Pittsburgh

Adam Shull

Indiana University

Steven Myers

Indiana University

Adam J. Lee

University of Pittsburgh

over objects stored on untrusted platforms. Our primary result
is negative: we demonstrate that prohibitive computational
burdens are likely to be incurred when supporting practical,
dynamic workloads.

Abstract—The ability to enforce robust and dynamic access
controls on cloud-hosted data while simultaneously ensuring
conﬁdentiality with respect to the cloud itself is a clear goal
for many users and organizations. To this end, there has been
much cryptographic research proposing the use of (hierarchical)
identity-based encryption, attribute-based encryption, predicate
encryption, functional encryption, and related technologies to
perform robust and private access control on untrusted cloud
providers. However, the vast majority of this work studies static
models in which the access control policies being enforced do not
change over time. This is contrary to the needs of most practical
applications, which leverage dynamic data and/or policies.

In this paper, we show that the cryptographic enforcement of
dynamic access controls on untrusted platforms incurs computa-
tional costs that are likely prohibitive in practice. Speciﬁcally,
we develop lightweight constructions for enforcing role-based
access controls (i.e., RBAC0) over cloud-hosted ﬁles using identity-
based and traditional public-key cryptography. This is done
under a threat model as close as possible to the one assumed
in the cryptographic literature. We prove the correctness of
these constructions, and leverage real-world RBAC datasets and
recent techniques developed by the access control community to
experimentally analyze, via simulation, their associated compu-
tational costs. This analysis shows that supporting revocation,
ﬁle updates, and other state change functionality is likely to
incur prohibitive overheads in even minimally-dynamic, realistic
scenarios. We identify a number of bottlenecks in such systems,
and fruitful areas for future work that will lead to more natural
and efﬁcient constructions for the cryptographic enforcement of
dynamic access controls. Our ﬁndings naturally extend to the use
of more expressive cryptographic primitives (e.g., HIBE or ABE)
and richer access control models (e.g., RBAC1 or ABAC).

I. INTRODUCTION

In recent years, numerous cryptographic schemes have been
developed to support access control on the (untrusted) cloud.
One of the most expressive of these is attribute-based encryption
(ABE) [31], which is a natural ﬁt for enforcing attribute-based
access control (ABAC) policies [40]. However, the practical
implications of using these types of cryptographic schemes to
tackle realistic access control problems are largely unexplored.
In particular, much of the literature concerns static scenarios
in which data and/or access control policies are rarely, if
ever, modiﬁed (e.g., [5], [30], [31], [42], [49], [52], [59]).
Such scenarios are not representative of real-world systems,
and oversimplify issues associated with key management and
revocation that can carry substantial practical overheads. In this
paper, we explore exactly these types of issues in an attempt
to understand the computational overheads of using advanced
cryptographic techniques to enforce dynamic access controls

2375-1207/16 $31.00 © 2016 IEEE
© 2016, William C. Garrison_III. Under license to IEEE.
DOI 10.1109/SP.2016.54
DOI 10.1109/SP.2016.54

819
819

The push to develop and use cryptography to support adaptive
access control on the cloud is natural. Major cloud providers
such as Google, Microsoft, Apple, and Amazon are providing
both large-scale, industrial services and smaller-scale, consumer
services. Similarly, there are a number of user-focused cloud-
based ﬁle sharing services, such as Dropbox, Box, and Flickr.
However, the near-constant media coverage of data breaches
has raised both consumer and enterprise concerns regarding the
privacy and integrity of cloud-stored data. Among the widely-
publicized stories of external hacking and data disclosure
are releases of private photos [56]. Some are even state-
sponsored attacks against cloud organizations themselves, such
as Operation Aurora, in which Chinese hackers inﬁltrated
providers like Google, Yahoo, and Rackspace [20], [51].
Despite the economic beneﬁts and ease-of-use provided by
outsourcing data management to the cloud, this practice raises
new questions regarding the maintenance and enforcement of
the access controls that users have come to expect from ﬁle
sharing systems.

Although advanced cryptographic primitives seem well-
suited for protecting point states in many access control
paradigms, supporting the transitions between protection states
that are triggered by administrative actions in a dynamic
system requires addressing very subtle issues involving key
management, coordination, and key/policy consistency. While
there has been some work seeking to provide a level of
dynamism for these types of advanced cryptographic primitives,
this work is not without issues. For instance, techniques have
been developed to support key revocation [8] and delegated
re-encryption [32], [58]. Unfortunately, these techniques are not
compatible with hybrid encryption—which is necessary from
an efﬁciency perspective—under reasonable threat models.

In this paper, we attempt to tease out these types of critical
details by exploring the cryptographic enforcement of a widely-
deployed access control model: role-based access control
(speciﬁcally, RBAC0 [61]). In particular, we develop two
constructions for cryptographically enforcing dynamic RBAC0
policies in untrusted cloud environments: one based on standard
public-key cryptographic techniques, and another based on
identity-based encryption/signature (IBE/IBS) techniques [11],
[13], [59]. By studying RBAC0 in the context of these relatively

efﬁcient cryptographic schemes, we can effectively lower-
bound the costs that would be associated with supporting richer
access controls (e.g., ABAC) by using more advanced—and
more expensive—cryptographic techniques exhibiting similar
administrative and key delegation structures (e.g., ABE).

We use tools from the access control literature [36] to
prove the correctness of our RBAC0 constructions. To quantify
the costs of using these constructions in realistic access
control scenarios, we leverage a stochastic modeling and
simulation-based approach developed to support access control
suitability analysis [26]. Our simulations are driven by real-
world RBAC datasets that allow us to explore—in a variety
of environments where the RBAC0 policy and ﬁles in the
system are subject to dynamic change—the costs associated
with using these constructions. In doing so, we uncover several
design considerations that must be addressed, make explicit
the complexities of managing the transitions that occur as
policies or data are modiﬁed at runtime, and demonstrate
the often excessive overheads of relying solely on advanced
cryptographic techniques for enforcing dynamic access controls.
This provides us with a number of insights toward the
development of more effective cryptographic access controls.
Through our analysis, we make the following contributions:
• We demonstrate that the cryptographic enforcement of role-
based access controls on the cloud incurs overheads that
are likely prohibitive in realistic dynamic workloads. For
instance, we show that removing a single user from a role
in a moderately-sized organization can require hundreds or
thousands of IBE encryptions! Since our constructions are
designed to lower-bound deployment costs (given current
cryptographic techniques), this indicates that cryptographic
access controls are likely to carry prohibitive costs for even
mildly dynamic scenarios.

• Prior work often dismisses the need for an access control
reference monitor when using cryptographically-enforced
access controls (e.g., [5], [30], [31], [52]). We discuss the
necessity of some minimal reference monitor on the cloud
when supporting dynamic, cryptographically-enforced access
controls, and we outline other design considerations that
must be addressed in dynamic environments.

• We develop constructions that use either the IBE/IBS or
public-key cryptographic paradigms to enable dynamic
outsourced RBAC0 access controls. In an effort to lower-
bound deployment costs, our constructions exhibit design
choices that emphasize efﬁciency over the strongest possible
security (e.g., using lazy rather than online re-encryption,
cf. Section IV-C), but are easily extended to support
stronger security guarantees (albeit at additional costs). These
constructions further highlight practical considerations that
are often overlooked in the literature, or that prevent the
application of techniques designed to enhance the dynamism
of advanced cryptographic techniques.

• Having established the infeasibility of enforcing even the
relatively simple RBAC0 in dynamic scenarios, we discuss
the increase in costs that would be associated with more

expressive cryptographically-enforced access control such
as hierarchical RBAC (RBAC1) using HIBE [10], [29], or
attribute-based access control (ABAC) using ABE.
The remainder of this paper is organized as follows. In Sec-
tion II, we discuss relevant related work. Section III documents
our system model and assumptions, and provides background
on RBAC0 and the cryptographic techniques used in this paper.
In Section IV, we describe our IBE/IBS construction in detail,
and overview the key differences between it and our PKI-
based construction. Section V presents theorems stating the
correctness of our constructions, as well as experimental results
showing the overheads incurred by our constructions when
applied to real-world RBAC datasets. In Section VI, we identify
interesting directions for future work informed by our ﬁndings.
Section VII details our conclusions.

II. RELATED WORK

A. Access Control

Access control is one of the most fundamental aspects
of computer security, with instances occurring pervasively
throughout most computer systems: relational databases often
provide built-in access control commands; network administra-
tors implement access controls, e.g., ﬁrewall rules and router
ACLs; operating systems provide access control primitives that
enable users to protect their private ﬁles; and web applications
and other frameworks typically implement purpose-speciﬁc
access controls to control access to the information that
they manage. The literature describes a diversity of access
control systems supporting policies including basic access
control lists [60], cryptographically-enforced capabilities [64],
group- [43], role- [61], and attribute-based [40] controls.
Despite this diversity, a central theme in most access control
work is the reliance on a fully-trusted reference monitor to
check compliance with the policy to be enforced prior to
brokering access to protected resources. This dependency on
a trusted reference monitor is problematic, however, when
resources are stored on (potentially) untrusted infrastructure.
Distributed or decentralized approaches to access control
have also been well studied in the literature and in practice.
Work in the trust management space (e.g., [4], [7], [21],
[45]) allows the speciﬁcation of declarative access control
policies for protecting resources, which are satisﬁed using
digital credentials of various forms. For instance, a research
portal may allow free access to publications, provided that the
requester is a graduate student at an accredited university. This
allows the portal to delegate trust: provided that a requestor
can produce a proof-of-ownership for a “graduate student”
attribute certiﬁcate issued by an accredited university, she
will be permitted access. We note that these approaches need
not rely on heavyweight certiﬁcate infrastructures; recent
work has provided similar functionality using lightweight
cryptographic bearer credentials [6]. Further, widely-deployed
identity management solutions (e.g., OAuth [35]) can also be
viewed as simpliﬁed trust management approaches that ofﬂoad
identity veriﬁcation to a third party, receiving only a “token”

820820

attesting to a requestor’s identity. In all cases, however, a trusted
reference monitor is still required to validate that the presented
credentials actually satisfy the policy protecting a resource.

In this paper, by contrast, we investigate the implications of
using cryptography to enforce access controls on cloud-based
storage infrastructure, where the provider is not trusted to view
ﬁle contents.

B. Cryptography

We assume the reader is familiar with basic concepts
from symmetric-key and public-key cryptography, and many
references exist (e.g., [41]) discussing these topics. Starting
with the development of practical identity-based encryption
(IBE) schemes [11], there has been considerable work on the
development of cryptographic systems that directly support
a number of access control functionalities, with examples
including hierarchical IBE [29], [37], attribute-based encryp-
tion [59], and functional encryption [57]. At a high level,
these encryption schemes encrypt data to a policy, so that
only those who have secret keys satisfying the policy can
decrypt. What varies between these types of schemes is the
expressiveness of the policies that are supported. With IBE and
traditional public-key encryption, one can encrypt to a given
target individual, and only that individual can decrypt. With
attribute-based encryption, a ciphertext can be encrypted to a
certain policy, and can be decrypted only by individuals whose
secret keys satisfy that policy. With functional encryption, a
certain function is embedded in the ciphertext, and when one
“decrypts,” one does not retrieve the underlying value, but rather
a function of the encrypted value and the decryptor’s secret
key. One underlying motivation in all of the above work is the
ability to enforce access controls on encrypted data.

Each cryptographic scheme has its own associated costs,
but they can be broadly categorized as follows. Symmetric
cryptography is orders of magnitude faster than traditional
public-key encryption, and traditional public-key encryption is
an order of magnitude faster than pairing-based cryptography,
in which the pairing operation itself typically carries the largest
cost.1 The vast majority of IBE, IBS, HIBE and ABE schemes
are pairing-based cryptographic schemes. IBE schemes use
a small constant number of pairings in either encryption
or decryption. In contrast, ABE schemes use a number of
pairings that is a function of the policy being encoded, and
thus, assuming minimally expressive access policies, have
computational costs substantially greater than IBE.

Much of the work on these advanced cryptographic systems
allows for data to be stored on the cloud, but it does not
address the issue of revocation or dynamic modiﬁcation of
the access control structure being used to store data on
the cloud. This can, of course, be done by downloading
the data, decrypting it, and then re-encrypting under a new
policy, but this is communication intensive, and potentially
computationally intensive too. Further, for large ﬁles, clients

1We will exclude lattice-based systems, due to the difﬁculty in determining
appropriate security parameters. This, amongst other factors, makes such
generic comparisons difﬁcult.

821821

making the changes in the access structure may not be able to
support the entire ﬁle locally (e.g., smartphones). Therefore,
there has been some work done in considering delegated
encryption and revocation in these models (e.g., [8], [32],
[33], [46], [53], [58], [62]).

C. Cryptographic Access Controls

There has been signiﬁcant work on using cryptography as an
access control mechanism, starting with seminal works such as
that by Gudes [34]. This work describes how access controls
can be enforced using cryptography, but does not address many
practical issues such as key distribution and management, policy
updates, and costs. Furthermore, as the work’s motivation is
a local ﬁle system, the access control system must be trusted
with the keys (and trusted to delete them from memory as soon
as possible). Work by Akl and Taylor [1] addresses some of the
key management issues by proposing a key assignment scheme:
a system for deriving keys in a hierarchical access control
policy, rather than requiring users higher in the hierarchy to
store many more keys than those lower in the hierarchy. Again,
this work does not consider key distribution or policy updates.
Later work in key hierarchies by Atallah et al. [3] proposes a
method that allows policy updates, but in the case of revocation,
all descendants of the affected node in the access hierarchy
must be updated, and the cost of such an operation is not
discussed. Continued work in key assignment schemes has
improved upon the efﬁciency of policy updates; see [16] for a
survey of such schemes that discusses tradeoffs such as how
much private vs. public information must be stored and how
much information must be changed for policy updates. Much
of this work focuses on the use of symmetric-key cryptography,
and so its use for the cloud is potentially limited.

De Capitani di Vimercati et al. [18], [19] describe a method
for cryptographic access controls on outsourced data using
double encryption (one layer by the administrator and one by
the service). An extension to this work also enforces write
privileges [17]. However, this solution requires a high degree
of participation by the cloud provider or third party, and the
work does not address the high cost of such operations as
deleting users (which can incur cascading updates). Ibraimi’s
thesis [38] proposes methods for outsourcing data storage using
asymmetric encryption. However, the proposed method for
supporting revocation requires a trusted mediator and keyshare
escrow to verify all reads against a revocation list (and does not
address revoked users reusing cached keyshares). Furthermore,
policy updates require an active entity to re-encrypt all affected
ﬁles under the new policy. Similarly, work by Nali et al. [50]
enforces RBAC using public-key cryptography, but requires a
series of active security mediators.

Crampton has shown that cryptography is sufﬁcient to
enforce RBAC policies [14] and general interval-based access
control policies [15], but revocation and policy updates are not
considered (i.e., the constructions are shown only for static
policies). Ferrara et al. [24] formally deﬁne a cryptographic
game for proving the security of cryptographically-enforced
RBAC systems and prove that such properties can be satisﬁed

Organization

Cloud storage

r
o
t
i

n
o
m
e
c
n
e
r
e
f
e
r

U R
P A

Policy
data

i

l
a
m
n
M

i

Update policy

Admin

Users

Write ﬁles

Read ﬁles

Encrypted

ﬁles

Fig. 1: Diagram of a cloud storage system

using an ABE-based construction. This construction has since
been extended to provide policy privacy and support writes
with less trust on the provider [23]. The latter is accomplished
by eliminating the reference monitor that checks if a write is
allowed and instead accepting each write as a new version;
versions must then be veriﬁed when downloaded for reading
to determine the most recent permitted version (the provider
is trusted to provide an accurate version ordering). However,
these works do not consider the costs and other practical
considerations for using such a system in practice (e.g., lazy
vs. active re-encryption, hybrid encryption). In this paper, we
consider exactly these types of issues.

Pirretti et al. [55] have shown that distributed ﬁle systems and
social networks can use ABE-based constructions to perform
practical access control, but they leave dynamic revocation as
future work.

III. BACKGROUND AND ASSUMPTIONS

Our goal is to understand the practical costs of leveraging
public-key cryptographic primitives to implement outsourced
dynamic access controls in the cloud. In this section, we (i)
deﬁne the system and threat models in which we consider
this problem, (ii) specify the access control model that we
propose to enforce, and (iii) deﬁne the classes of cryptographic
primitives that will be used in our constructions.

A. System and Threat Models

The environment that we consider—which is based on the
untrusted cloud provider typically assumed in the cryptographic
literature—is depicted in Fig. 1. The system consists of
three main (classes of) entities: access control administrators,
users/clients, and cloud storage providers. In particular, we
consider a model
in which a single storage provider is
contracted by an organization. This is analogous to companies
contracting with providers like Microsoft (via OneDrive for
Business) or Dropbox (via Dropbox Business) to outsource
enterprise storage, or individuals making use of cloud platforms
like Apple iCloud or Google Drive for hosting and sharing
personal media. Further, this simpliﬁes the overall system
design by eliminating the need for a secondary mechanism
that synchronizes cryptographic material and other metadata.

Assumptions. The cloud storage provider is contracted to
manage the storage needs of a (perhaps virtual) organization.
This includes storing the ﬁles hosted in the cloud, as well
as any metadata associated with the access control policies
protecting these ﬁles. We assume that the cloud is not trusted
to view the contents of the ﬁles that it stores. However, it is
trusted to ensure the availability of these ﬁles, and to ensure
that only authorized individuals update these ﬁles. File access
is assumed to occur directly though the cloud provider’s API,
with read access permissions being enforced cryptographically
on the client side, and write access permissions being enforced
by a minimal reference monitor on the cloud provider that
validates client signatures that prove write privileges prior to
ﬁle updates.2 In short, the storage provider ensures ﬁle system
consistency by preventing unauthorized updates, yet cannot
read or make legitimate modiﬁcations to ﬁles or metadata.

Access control administrators are tasked with managing the
protection state of the storage system. That is, they control the
assignment of access permissions, which entails the creation,
revocation, and distribution of cryptographic keys used to
protect ﬁles in a role-based manner. Metadata to facilitate key
distribution is stored in a cryptographically-protected manner
on the cloud provider. Users may download any ﬁle stored
on the storage provider, but may decrypt, read, and (possibly)
modify only the ﬁles for which they have been issued the
appropriate (role-based) keys. All ﬁles are encrypted and signed
prior to being uploaded to the cloud storage provider. Finally,
we assume that all parties can communicate via pairwise-
authenticated and private channels (e.g., SSL/TLS tunnels).

Implications. To simplify presentation and analysis, the
above threat model does leave some degree of trust in the
cloud provider (albeit far less than is routinely placed in
these providers today). In particular, the cloud provider is
trusted to verify digital signatures prior to authorizing write
operations. This could be avoided by using a versioning ﬁle
system, allowing all writes, and relying on clients to ﬁnd
the most recent version of a ﬁle that has a valid signature
prior to accessing that ﬁle. Similarly, it is possible—although
prohibited by our threat model—for a malicious provider
to “roll back” the ﬁlesystem to a prior state by replacing
current ﬁles and metadata with previous versions. We note that
it is possible to detect (e.g., via comparison with off-cloud
metadata) or prevent (e.g., by splitting metadata and ﬁle storage
across multiple providers) this issue, and thus this prohibition
could be dropped. Further, we do not consider the denial-of-
service threat of a user overwhelming the storage provider with
spurious ﬁle downloads; in practice, this is easily addressed by
using unguessable (perhaps cryptographically-produced) ﬁle
names, or lightweight authorization tokens. However, all of
these types of relaxations come with additional complexity. As
we will demonstrate, the costs associated with cryptographic
enforcement of dynamic access controls are likely prohibitive,
even under the above threat model. This, effectively, lower-

2Note that this eliminates the possibility of a purely symmetric-key approach:
the ability to validate, e.g., symmetric-key MACs would also allow the cloud
provider to modify these MACs.

822822

bounds the costs entailed by weaker threat models (which
require more complex mechanisms). For the bulk of this paper,
we will therefore focus on the above threat model, leaving
discussion of further relaxations to Section VI.

B. Access Control Model

In this paper, we focus on cryptographic enforcement of a
role-based access control (RBAC) system, given the prevalence
of this type of access control system in both the research
literature and commercial systems. RBAC systems simplify
permission management through the use of abstraction: roles
describe the access permissions associated with a particular
(class of) job function, users are assigned to the set of
roles entailed by their job responsibilities, and a user is
granted access to an object if they are assigned to a role
that is permitted to access that object. In this paper, we
will investigate cryptographic implementations of the simplest
RBAC formulation: RBAC0 [61]. More formally, the state of
an RBAC0 system can be described as follows:

• U is a set of users,
• R is a set of roles,
• P is a set of permissions (e.g., (cid:2)f ile, op(cid:3)),
• P A ⊆ R × P is the permission assignment relation, and
• U R ⊆ U × R is the user assignment relation.
The authorization predicate auth : U × P → B determines
whether user u can use permission p and is deﬁned as follows:

auth(u, p) = ∃r : [(u, r) ∈ U R] ∧ [(r, p) ∈ P A]

Many variants of RBAC exist, but we focus on the use of
RBAC0 as it is conceptually the simplest of these variants
yet still provides adequate expressive power to be interesting
for realistic applications. Generalizing this model to richer
RBAC variants (e.g., RBAC1) and attribute-based access control
(ABAC) is discussed in Section VI-C.

C. Cryptographic Primitives

Both of our constructions make use of symmetric-key
authenticated encryption (GenSym, EncSym, DecSym). Our
PKI scheme uses public-key encryption and digital signatures
(GenPub, EncPub, DecPub, GenSig, SignSig, VerSig).
While many attribute-based encryption (ABE) schemes are
being developed to support policy constructions of varying
expressivity, RBAC0 does not require this level of sophistication.
To this end, we instead use identity-based encryption (IBE):
• MSKGenIBE(1n): Takes security parameter n; generates
public parameters (which are implicit parameters to every
other IBE algorithm) and master secret key msk.

• KeyGenIBE(ID, msk): Generates a decryption key kID

for identity ID.

• EncIBE
ID (M ): Encrypts message M under identity ID.
• DecIBE
kID (C): Decrypts ciphertext C using key kID; correct-
ness requires that ∀ ID if kID = KeyGenIBE(ID) then
∀ M, DecIBE
We also use identity-based signature (IBS) schemes:

ID (M )) = M.

kID (EncIBE

• MSKGenIBS(1n): Takes security parameter n; generates
public parameters (which are implicit parameters to every
other IBS algorithm) and master secret key msk.

• KeyGenIBS(ID, msk): Generates a signing key sID for

identity ID.

• SignIBS

ID,sID (M ): Generates a signature sig on message M

ID (M, SignIBS

ID,sID (M )) = 1.

ID (M, sig): Veriﬁes whether sig is a valid signature

if sID is a valid signing key for ID.
• VerIBS
on message M for identity ID; requires that ∀ ID
if sID = KeyGenIBS(ID) then
∀ M, VerIBS
IBE (resp. IBS) schemes build upon traditional public-key
schemes by allowing any desired string to act as one’s en-
cryption (resp. veriﬁcation) key. This requires the introduction
of a third party who can generate the decryption and signing
keys corresponding to these identity strings. This third party,
who holds the master keys, is able to produce decryption
or signing keys for anyone, and thus the system has inbuilt
escrow. In our use of these systems, the RBAC administrator(s)
will act as this third party. Since administrators traditionally
have the power to access/assign arbitrary permissions, this
escrow is not a weakness. In practice, if this is still a concern,
threshold/secret splitting schemes can be used to distribute trust
amongst several individuals. However, such schemes would
increase the cryptographic costs of operations associated with
the master key.

IV. CONSTRUCTION

While cryptographic access control enforcement has been
studied in the past, the focus has been almost entirely on
techniques that are best suited for mostly static scenarios
lacking a trusted reference monitor (e.g., [31], [49]), in which
the policies to be enforced and ﬁles to be protected change
very little over time. As such, the particulars associated with
securely managing policy change and the associated overheads
have been largely under-explored. In this section, we begin
with a strawman construction for cryptographic access control
enforcement, and use it to highlight a variety of limitations and
design considerations that must be addressed. We conclude with
a detailed description of our IBE/IBS and PKI constructions
for RBAC0, which address these issues.

A. A Strawman Construction

At ﬁrst blush, it seems conceptually simple to provision a
cryptographically-enforced RBAC0 system. We now overview
such a system, which will allow us to highlight a variety of
issues that arise as a result. This strawman construction will
make use of IBE/IBS; the use of a more traditional PKI is a
straightforward translation. We assume that the administrator
holds the master secret keys for the IBE/IBS systems.
• Registration. Each user, u, of the system must carry out an
initial registration process with the administrator. The result
of this process is that the user will obtain identity-based
encryption and signing keys ku ← KeyGenIBE(u) and
su ← KeyGenIBS(u) from the administrator.

823823

• Role Administration. For each role, r, the administrator
will generate identity-based encryption and signing keys
kr ← KeyGenIBE(r) and sr ← KeyGenIBS(r). For
each user u that is a member of r (i.e., for each (u, r) ∈ U R
in the RBAC0 state), the administrator will create and upload
a tuple of the form:

(cid:2)RK, u, r, EncIBE

u

SU (cid:3).
(kr, sr), SignIBS

This tuple provides u with cryptographically-protected access
to the encryption and signing keys for r, and is signed
by the administrator. Here, SignIBS
SU at the end of the
tuple represents an IBS signature by identity SU (the
administrator), and RK is a sentinel value indicating that this
is a role key tuple.
• File Administration. For each ﬁle f to be shared with a
role r (i.e., for each (r,(cid:2)f, op(cid:3)) ∈ P A in the RBAC0 state),
the administrator will create and upload a tuple:

(cid:2)F, r,(cid:2)f n, op(cid:3), EncIBE

r

SU (cid:3).
(f ), SU, SignIBS

This tuple contains a copy of f that is encrypted to members
of r. Here, f n represents the name of the ﬁle f, while op is
the permitted operation—either Read or Write. As before,
SU is a signature by the administrator, and F is a
SignIBS
sentinel value indicating that this is a ﬁle tuple.
• File Access. If a user u who is authorized to read a ﬁle f
(i.e., ∃r : (u, r) ∈ U R ∧ (r,(cid:2)f, Read(cid:3)) ∈ P A) wishes to do
so, she must (i) download an RK tuple for the role r and
an F tuple for f; (ii) validate the signatures on both tuples;
(iii) decrypt the role key kr from the RK tuple using their
personal IBE key ku; and (iv) decrypt the ﬁle f from the F
tuple using the role key kr.
Writes to a ﬁle are handled similarly. If u is authorized to
write a ﬁle f via membership in role r (i.e., ∃r : (u, r) ∈
U R ∧ (r,(cid:2)f, Write(cid:3)) ∈ P A), she can upload a new F tuple
(cid:2)F, r,(cid:2)f n, Write(cid:3), EncIBE
(cid:3). If the signature
(cid:2)
), SignIBS
authorizing the write (SignIBS
) can be veriﬁed by the cloud
provider, the existing F tuple for f will be replaced.
This construction describes a cryptographic analog to
RBAC0. The U R relation is encoded in the collection of RK
tuples, while the P A relation is encoded in the collection
of F tuples. The authorization relation of RBAC0 is upheld
cryptographically: to read a ﬁle f, a user u must be able to
decrypt a tuple granting her the permissions associated with a
role r, which can be used to decrypt a tuple containing a copy
of f encrypted to role r.
B. Design Considerations

(f

r

r

r

While conceptually straightforward, the strawman construc-
tion is by no means a complete solution. We now use this
construction as a guide to discuss a number of design tradeoffs
that must be addressed to support cryptographic enforcement
of dynamic RBAC0 states.

PKI vs. IBE. Basing an RBAC0 system on IBE and IBS
allows for a simple mapping from encryption keys to roles
in RBAC0: The name of the role is the public-key used to
encrypt under that role. This is conceptually simpler than what

is achieved by traditional public key or symmetric encryption,
which may help limit certain key management issues in soft-
ware. IBE-based constructions also generalize to richer access
control models (e.g., enforced using HIBE or ABE), which
we explore in Section VI. That said, rich infrastructure has
been developed to support public key cryptography, which may
make the systems support issues inherent in these constructions
easier to manage. To this end, we present constructions based
on both IBE and public key cryptography.

Inefﬁciency Concerns. The strawman construction exhibits
two key issues with respect to efﬁciency. First, IBE (like
public-key cryptography) is not particularly well-suited for
the bulk encryption of large amounts of data. As such, the
performance of this construction would suffer when large ﬁles
are shared within the system. Second, this construction requires
a duplication of effort when a ﬁle, say f, is to be shared with
multiple roles, say r1 and r2. That is, f must actually be
encrypted twice: once with r1 and once with r2. We note that
this also leads to consistency issues between roles when f is
updated. Fortunately, both of these concerns can be mitigated
via the use of hybrid cryptography. Rather than storing F tuples
of the form:

(cid:2)F, r,(cid:2)f n, op(cid:3), EncIBE
the
instead

store

r

SU (cid:3)
(f ), SU, SignIBS
tuples, where

following

can

We
k ← GenSym is a symmetric key:

(cid:2)FK, r,(cid:2)f n, op(cid:3), EncIBE

SU (cid:3)
(k), SU, SignIBS

(cid:2)F, f n, EncSym

k

r
(f ), r, SignIBS

r

(cid:3)

The FK tuples are similar to the ﬁle encryption tuples in the
strawman construction, except that the ciphertext portion of
the tuple now includes an IBE-encrypted symmetric key rather
than an IBE-encrypted ﬁle. F tuples contain a symmetric-key-
encrypted (using an authenticated mode) version of the ﬁle f,
and are IBS-signed using the role key of the last authorized
updater. This adjustment to the metadata improves the efﬁciency
of bulk encryption by using symmetric-key cryptography, and
greatly reduces the duplication of effort when sharing a ﬁle
with multiple roles: a single F tuple can be created for the ﬁle
along with multiple FK tuples (i.e., one per role).

Handling Revocation. The strawman construction can
neither revoke a permission from a role, nor remove a user
from a role. The former case can be handled by versioning the
F and FK tuples stored within the system, and the latter case
handled by adding role versioning to the role key tuples and
FK tuples in the system:

(cid:2)RK, u, (r, vr), EncIBE
(cid:2)FK, r,(cid:2)f n, op(cid:3), v, EncIBE

u

(cid:2)F, f n, v, EncSym

k

SU (cid:3)
(k(r,vr), s(r,vr)), SignIBS
SU (cid:3)
(r,vr)(k), SU, SignIBS
(r,vr)(cid:3)
(f ), (r, vr), SignIBS

Here, v represents a version number for the symmetric key used
to encrypt a ﬁle. Role names have been replaced with tuples
that include the role name (e.g., r), as well as a version number
(vr). Removing a permission from a role entails re-keying and

824824

re-encrypting the ﬁle (i.e., creating a new F tuple), and creating
new FK tuples for each role whose access to the ﬁle has not
been revoked. The roles increment their previous role number.
Similarly, removing a user u from a role r entails deleting
u’s RK tuple for r, generating new role keys for r (with an
incremented version number) and encoding these into new RK
tuples for each user remaining in r, and re-versioning all ﬁles
to which the role r holds some permission. We note that both
of these processes must be carried out by an administrator,
as only administrators can modify the RBAC0 state. There is
much nuance to these processes, and we defer a full discussion
to Section IV-C.

Online, Lazy, and Proxy Re-Encryption. Supporting revo-
cation leads to an interesting design choice: should ﬁles be re-
encrypted immediately upon re-key, or lazily re-encrypted upon
their next write? From a conﬁdentiality standpoint, forcing an
administrator—or some daemon process running on her behalf—
to re-encrypt ﬁles immediately upon re-key is preferential, as
it ensures that users who have lost the ability to access a
ﬁle cannot later read its contents. On the other hand, this
comes with a potentially severe efﬁciency penalty in the
event that many ﬁles are re-keyed due to changes to some
role, as access to these ﬁles must be locked while they are
downloaded, re-encrypted, and uploaded. In this paper, we opt
for a lazy re-encryption strategy, in which ﬁles are re-encrypted
by the next user to write to the ﬁle (cf., Section IV-C). We
note that such a scheme is not appropriate for all scenarios,
but substantially reduces the computational burden on the
cloud when allowing for dynamic updates to the RBAC0 state
(cf., Section V-D). Similarly, if a client is powerful enough
to download a source ﬁle and decrypt it to view the material,
it presumably is powerful enough to perform the roughly
computationally equivalent operation of re-encrypting it. Note
that a single client is unlikely to need to re-encrypt large
numbers of ﬁles, unlike the cloud if a lazy re-encryption strategy
were not used. Adapting our construction to instead use online
re-encryption is a straightforward extension.

While appealing on the surface, IBE schemes that support
proxy re-encryption, or revocation (e.g., [8], [32]) are not
suitable for use in our scenario. These types of schemes
would seemingly allow us to remove our reliance on lazy
re-encryption, and have the cloud locally update encryptions
when a permission is revoked from a role, or a role from a
user. This would be done by creating an updated role name,
using proxy re-encryption to move the ﬁle from the old role
name to the updated one, and then revoking all keys for the
old ﬁle. The signiﬁcant issue, here, is that such schemes do
not address how one would use them with hybrid encryption.
We do not believe that a reasonable threat model can assume
that even a limited adversary would be unable to cache all the
symmetric keys for ﬁles she has access to. Thus, using proxy
re-encryption on the RK and FK tuples and not the F tuples
would allow users to continue to access ﬁles to which their
access has been revoked, and so our construction would still
require online or lazy re-encryption of the ﬁles themselves.

As a ﬁnal note, we acknowledge that key-homomorphic

PRFs [12] could be combined with revocation and proxy re-
encryption schemes, solving the revocation problem completely
on the cloud in the hybrid model. However, current technology
does not solve the computational effort, as costs of current
key-homomorphic PRFs are comparable or greater than the
IBE and PKI technologies in consideration.

Multiple Levels of Encryption. We note that our construc-
tion has levels of indirection between RK, FK, and F tuples that
mirror the indirection between users, roles, and permissions
in RBAC0. This indirection could be ﬂattened to decrease the
number of cryptographic operations on the critical path to ﬁle
access; this would be akin to using an access matrix to encode
RBAC0 states. While this is possible, it has been shown to
cause computational inefﬁciencies when roles’ memberships
or permissions are altered [27]; in our case this inefﬁciency
would be ampliﬁed due to the cryptographic costs associated
with these updates.

Other Issues and Considerations. Our constructions are
measured without concern for concurrency-related issues that
would need to be addressed in practice. We note, however, that
features to handle concurrency would be largely independent of
the proposed cryptography used to enforce the RBAC0 policies.
As such, we opt for the analysis of the conceptually-simpler
schemes presented in this paper. Finally, our analysis is agnostic
to the underlying achieved security guarantees and hardness
assumptions of the public-key and IBE schemes. Production
implementations would need to consider these issues.

C. Detailed IBE/IBS Construction

We now ﬂesh out the strawman and previously-discussed
enhancements. This produces a full construction for enforcing
RBAC0 protections over an evolving collection managed by a
minimally-trusted cloud storage provider.

1) Overview and Preliminaries: We reiterate that the admin-
istrators act as the Master Secret Key Generator of the IBE/IBS
schemes. Users add ﬁles to the system by IBE-encrypting these
ﬁles to the administrators, using hybrid cryptography and F
tuples. Administrators assign permissions (i.e., (cid:2)f ile, op(cid:3) pairs)
to roles by distributing symmetric keys using FK tuples. Role
keys are distributed to users using RK tuples. Recall the format
of these tuples is as follows:
(cid:2)RK, u, (r, vr), EncIBE
(cid:2)FK, r,(cid:2)f n, op(cid:3), v, EncIBE

SU (cid:3)
(k(r,vr), s(r,vr)), SignIBS
SU (cid:3)
(r,vr)(k), SU, SignIBS
(r,vr)(cid:3)
(f ), (r, vr), SignIBS

(cid:2)F, f n, v, EncSym

u

k

Note that symmetric keys and role keys are associated with
version information to handle the cases where a user is removed
from a role or a permission is revoked from a role.

We assume that ﬁles have both read and write permissions
associated with them. However, we cannot have write without
read, since writing requires decrypting the ﬁle’s symmetric
key, which then can be used to decrypt and read the stored
ﬁle. Thus we only assign either Read or RW, and only revoke
Write (Read is retained) or RW (nothing is retained). When a
user wishes to access a ﬁle, she determines which of her roles

825825

has access to the permission in question. She then decrypts
the role’s secret key using her identity, and then decrypts the
symmetric key for the ﬁle using the role’s secret key, and ﬁnally
uses the symmetric key to decrypt the symmetrically-encrypted
ciphertext in question.

2) Full Construction: Figure 2 lists every RBAC0 operation
and shows how each can be implemented using IBE, IBS, and
the metadata structures described previously. This ﬁgure uses
the following notation: u is a user, r and q are roles, p is a
permission, f n is a ﬁle name, f is a ﬁle, c is a ciphertext
(either IBE or symmetric), sig is an IBS signature, and v is
a version number. Users are listed in a ﬁle called USERS.
The identity corresponding to a role r is (r, v), where v is a
positive integer representing the version number. We use vr to
denote the latest version number for role r. Roles and versions
are stored as (r, vr) pairs in a ﬁle called ROLES, which is
publicly viewable and can only be changed by the administrator.
Similarly, we use vf n to denote the latest version number for
the ﬁle with name f n. Filenames and versions are stored
as (f n, vf n) pairs in a ﬁle called FILES, which is publicly
viewable and can only be changed by the admin or reference
monitor (R.M.). SU is the superuser identity possessed by the
administrators. We use “−” to represent a wildcard. SignIBS
at the end of a tuple represents an IBS signature by identity id
over the rest of the tuple. The subscript after an operation name
identiﬁes who performs the operation if it is not performed by
an administrator.

id

Many operations described in Fig. 2 are straightforward
given the discussion earlier in this section. To demonstrate
some of the more complicated aspects of this construction,
we now describe the procedure to revoke a role from a user,
which demonstrates several types of re-keys as well as our
notion of lazy re-encryption. The procedure for removing a
user u from a role r consists of three steps: (i) re-keying r,
(ii) re-encrypting existing ﬁle keys stored in FK tuples to the
new role key, and (iii) re-keying all ﬁles accessible by r.

To re-key a role r, we must transition from (r, vr) to
(r, vr + 1), generating new IBE keys for this new role version.
The old RK tuples for r are deleted, and each remaining
(cid:2) of role r is given the new RK tuples of the
member u
SU (cid:3), where c contains
form of (cid:2)RK, u
(cid:2)
, (r, vr + 1), c, SignIBS
(cid:2)’s identity key. Next,
the new IBE/IBS keys encrypted to u
all (symmetric) ﬁle keys encrypted to (r, vr) in FK tuples are
replaced with ﬁle keys encrypted to (r, vr + 1). This allows
the remaining members of r to retain access to existing ﬁles,
while preventing the revoked user u from accessing any ﬁle
keys that he has not already decrypted and cached.

Finally, each ﬁle to which r has access must be re-keyed
to prevent u from accessing future updates to this ﬁle using
cached symmetric keys. For each ﬁle f, a new symmetric
key is generated via GenSym. This key is then encrypted
(cid:2) that has access to f (including r), and new
for each role r
SU (cid:3) are uploaded
FK tuples (cid:2)FK, r
SU (cid:3) tuples. Here,
alongside existing (cid:2)FK, r
v + 1 is the new ﬁle key version, c is the existing encrypted
(cid:2) is the new ﬁle key IBE-encrypted to identity r
(cid:2).
ﬁle key, and c

, SignIBS
,(cid:2)f, op(cid:3), v, c, SignIBS

,(cid:2)f, op(cid:3), v + 1, c

(cid:2)

(cid:2)

(cid:2)

The next time f is read, the key contained in c will be used for
(cid:2)
decryption; the next time f is written, the key contained in c
will be used for encryption. This process obviates the need for
a daemon to re-encrypt all ﬁles at revocation time, but prevents
the revoked user u from accessing any future modiﬁcations to
these ﬁles using cached symmetric ﬁle keys.

D. PKI Construction Overview

We now provide an intuition for how traditional public-key
cryptography can be used in place of IBE/IBS to implement
RBAC0. Due to space limitations, full details will be left
to a technical report version [28] of this paper. In our PKI
construction, public-key encryption and signatures take the
place of IBE and IBS. Each role is assigned a public/private
key pair rather than IBE/IBS keys. The primary difference
between the IBE and PKI constructions is that IBE/IBS
clients are given escrowed IBE/IBS identity private keys by
the role administrator, while PKI clients generate their own
public/private key pairs and upload their public keys. Note that
in both systems, the administrators have access to all of the
roles’ private keys.

V. ANALYSIS

We now describe our evaluation of the suitability of IBE/IBS
and PKI constructions for enforcing RBAC0 access controls.
We utilize a workﬂow similar to that proposed in [26], in which
we ﬁrst evaluate the candidates’ expressive power (i.e., ability
to represent the desired policy as it evolves), then evaluate the
cost of using each candidate using Monte Carlo simulation
based on initial states obtained from real-world datasets.

A. Qualitative Analysis

We analyze the correctness and security guarantees of
our implementations using the access control expressiveness
framework known as parameterized expressiveness [36]. In
particular, we ensure that the implementation properties of
correctness, AC-preservation, and safety are preserved by these
constructions. Correctness ensures that the RBAC0 state’s
image in our constructions answers queries exactly as the
original RBAC0 system would, and that the same end state
is reached by either executing an RBAC0 action natively and
mapping the result into our construction or by mapping the
initial RBAC0 state and executing the action’s image in our
construction. AC-preservation says that the RBAC0 system’s
authorization requests must be asked directly in the simulating
system. For instance, the policy must be simulated in such
a way that the RBAC0 request “Can subject s read ﬁle f?”
is asked directly in the simulated state rather than being
translated to any other queries. Finally, safety ensures that our
constructions do not grant or revoke unnecessary permissions
during the simulation of a single RBAC0 command. That is, the
intermediate states through which our constructions travel while
implementing an RBAC0 command do not add or remove any
granted requests except those that must be added or removed as
determined by the start and end states of the RBAC0 command.

826826

addU (u)
– Add u to USERS
– Generate IBE private key ku ← KeyGen
– Give ku and su to u over private and authenticated channel

key su ← KeyGen

IBS(u) for the new user u

IBE(u) and IBS private

delU (u)
– For every role r that u is a member of:

∗ revokeU (u, r)

(cid:5)

(cid:4)F, f n, 1, Enc

(cid:4)f n, RW(cid:5), 1, Enc

Sym
k
IBE
SU (k), u, Sign

Sym
(f ), u, Sign
IBS
u

addPu(f n, f )
– Generate symmetric key k ← Gen
(cid:4)FK, SU,
– Send
– The R.M. receives (cid:4)F, f n, 1, c, u, sig(cid:5) and (cid:4)FK, SU, (cid:4)f n, RW(cid:5),
(cid:2)(cid:5) and veriﬁes that the tuples are well-formed and the

1, c
signatures are valid, i.e., Ver
Ver
stores (cid:4)F, f n, 1, c, u, sig(cid:5) and (cid:4)FK, SU, (cid:4)f n, RW(cid:5), 1, c

– If veriﬁcation is successful, the R.M. adds (f n, 1) to FILES and
(cid:2)(cid:5)
(cid:2), u, sig

((cid:4)F, f n, 1, c, u(cid:5), sig) = 1 and
(cid:2), u(cid:5), sig

((cid:4)FK, SU, (cid:4)f n, RW(cid:5), 1, c

and
(cid:5) to R.M.

(cid:2), u, sig

(cid:2)) = 1.

IBS
u

IBS
u

IBS
u

delP (f n)
– Remove (f n, vf n) from FILES
– Delete (cid:4)F, f n, −, −, −, −(cid:5) and all (cid:4)FK, −, (cid:4)f n, −(cid:5), −, −, −, −(cid:5)
addR(r)
– Add (r, 1) to ROLES
– Generate IBE private key k(r,1) ← KeyGen
– Send (cid:4)RK, SU, (r, 1), Enc
delR(r)
– Remove (r, vr) from ROLES
– Delete all (cid:4)RK, −, (r, vr), −, −(cid:5)
– For all permissions p = (cid:4)f n, op(cid:5) that r has access to:

IBE((r, 1)) and IBS
(cid:3)
SU (cid:5) to R.M.

private key s(r,1) ← KeyGen

IBS((r, 1)) for role (r, 1)
(cid:2)
IBS

k(r,1), s(r,1)

, Sign

IBE
SU

∗ revokeP (r, (cid:4)f n, RW(cid:5))

assignU (u, r)
– Find (cid:4)RK, SU, (r, vr), c, sig(cid:5) with Ver
– Decrypt keys (k(r,vr ), s(r,vr )) = Dec
– Send (cid:4)RK, u, (r, vr), Enc

sig) = 1

IBE
u

(cid:2)

R.M.

IBS

SU ((cid:4)RK, SU, (r, vr), c(cid:5),

IBE
kSU

(c)

k(r,vr ), s(r,vr )

(cid:3)

, Sign

IBS

SU (cid:5) to

(cid:2)

IBS

IBS

IBS

Sign

IBE
u(cid:2)

IBS((r, vr + 1))

(cid:2) (cid:6)= u and Ver

IBE((r, vr + 1)),
SU ((cid:4)RK, u
(cid:2),
(cid:3)

(cid:2), (r, vr), c, sig(cid:5) with u
(cid:2), (r, vr + 1), Enc

revokeU (u, r)
– Generate new role keys k(r,vr +1) ← KeyGen
– For all (cid:4)RK, u

s(r,vr +1) ← KeyGen
(r, vr), c(cid:5), sig) = 1:
∗ Send (cid:4)RK, u
SU (cid:5) to R.M.
SU, sig(cid:5) with Ver
∗ For every (cid:4)FK, (r, vr), (cid:4)f n, op
(cid:2)(cid:5), v, c
Ver
· Decrypt key k = Dec
(cid:2))
(c
· Send (cid:4)FK, (r, vr + 1), (cid:4)f n, op
(cid:2)(cid:5), v, Enc
Sign

,
k(r,vr +1), s(r,vr +1)
– For every f n such that there exists (cid:4)FK, (r, vr), (cid:4)f n, op(cid:5), vf n, c,
SU ((cid:4)FK, (r, vr), p, vf n, c, SU(cid:5), sig) = 1:
(cid:2), SU, sig(cid:5) with

SU ((cid:4)FK, (r, vr), (cid:4)f n, op
IBE
k(r,vr )

(cid:2), SU(cid:5), sig) = 1:

IBE
(r,vr +1)(k), SU,

SU (cid:5) to R.M.
(cid:2) ← Gen
∗ Generate new symmetric key k
∗ For all (cid:4)FK, id, (cid:4)f n, op
(cid:2)(cid:5), vf n, c
(cid:2)(cid:2), SU, sig(cid:5) with Ver
(cid:2)(cid:5), vf n, c
(cid:2)(cid:2), SU(cid:5), sig) = 1:
SU (cid:5) to R.M.

(cid:2)(cid:5), vf n + 1, Enc
∗ Increment vf n in FILES, i.e., set vf n := vf n + 1

id, (cid:4)f n, op
· Send (cid:4)FK,
Sign

SU ((cid:4)FK,
(cid:2)), SU,
(k

id, (cid:4)f n, op

(cid:2)(cid:5), v, c

Sym for p

IBE
id

IBS

IBS

IBS

IBS

– Increment vr in ROLES, i.e., set vr := vr + 1
– Delete all (cid:4)RK, −, (r, vr), −, −(cid:5)
– Delete all (cid:4)FK, (r, vr), −, −, −, −, −(cid:5)

IBS

IBS

assignP (r, (cid:4)f n, op(cid:5))
– For all (cid:4)FK, SU, (cid:4)f n, RW(cid:5), v, c, id, sig(cid:5) with Ver

id ((cid:4)FK, SU,
(cid:4)f n, RW(cid:5), v, c, id(cid:5), sig) = 1:
∗ If this adds Write permission to existing Read permission, i.e.,
(cid:2), SU,
(cid:2), SU(cid:5), sig) = 1:
SU (cid:5) to R.M.
∗ If the role has no existing permission for the ﬁle, i.e., there does not
SU ((cid:4)FK,

op = RW and there exists (cid:4)FK, (r, vr), (cid:4)f n, Read(cid:5), v, c
SU ((cid:4)FK, (r, vr), (cid:4)f n, op
sig(cid:5) with Ver
· Send (cid:4)FK, (r, vr), (cid:4)f n, RW(cid:5), v, c
· Delete (cid:4)FK, (r, vr), (cid:4)f n, Read(cid:5), v, c
exist (cid:4)FK, (r, vr), (cid:4)f n, op
(cid:2)(cid:5), v, c, SU(cid:5), sig) = 1:
(r, vr), (cid:4)f n, op
· Decrypt key k = Dec
· Send (cid:4)FK, (r, vr), (cid:4)f n, op(cid:5), v, Enc
to R.M.

(cid:2)(cid:5), v, c
(cid:2), SU, Sign
(cid:2), SU, sig(cid:5)

(cid:2), SU, sig(cid:5) with Ver

IBE
(r,vr )(k), SU, Sign

(cid:2)(cid:5), v, c

IBS

SU (cid:5)

IBE
kSU

(c)

IBS

IBS

revokeP (r, (cid:4)f n, op(cid:5))
– If op = Write:
(cid:4)FK,

∗ For all

IBS

(r, vr),

SU ((cid:4)FK, (r, vr), (cid:4)f n, RW(cid:5), v, c, SU(cid:5), sig) = 1:

Ver
· Send (cid:4)FK, (r, vr), (cid:4)f n, Read(cid:5), v, c, SU, Sign
· Delete (cid:4)FK, (r, vr), (cid:4)f n, RW(cid:5), v, c, SU, sig(cid:5)

(cid:4)f n, RW(cid:5), v, c, SU, sig(cid:5) with
SU (cid:5) to R.M.

IBS

– If op = RW:

∗ Delete all (cid:4)FK, (r, vr), (cid:4)f n, −(cid:5), −, −, −(cid:5)
∗ Generate new symmetric key k
∗ For all (cid:4)FK, r

(cid:2) ← Gen

(cid:2), (cid:4)f n, op

(cid:2)(cid:5), vf n, c, SU, sig(cid:5) with Ver

(cid:2)(cid:5), v, c, SU(cid:5), sig) = 1:

(cid:2), (cid:4)f n, op
r
· Send (cid:4)FK, r
Sign

(cid:2)(cid:5), vf n + 1, Enc
∗ Increment vf n in FILES, i.e., set vf n := vf n + 1

SU (cid:5) to R.M.

(cid:2), (cid:4)f n, op

IBE
id

Sym

IBS

IBS

SU ((cid:4)FK,
(cid:2)), SU,
(k

IBS

readu(f n)
– Find (cid:4)F, f n, v, c, id, sig(cid:5) with valid ciphertext c and valid signature
id ((cid:4)F, f n, 1, c, id(cid:5), sig) = 1
– Find a role r such that the following hold:
(cid:2)(cid:5), sig) = 1

sig, i.e., Ver
∗ u is in role r, i.e., there exists (cid:4)RK, u, (r, vr), c
(cid:2), sig(cid:5) with
∗ r has read access to version v of f n, i.e., there exists (cid:4)FK, (r, vr),
(cid:2)(cid:5) with Ver
SU ((cid:4)FK, (r, vr), (cid:4)f n, op(cid:5),
(cid:2))

Ver
(cid:4)f n, op(cid:5), v, c
(cid:2)(cid:2), SU(cid:5), sig
v, c

SU ((cid:4)RK, u, (r, vr), c

(cid:2)(cid:2), SU, sig
(cid:2)) = 1

IBS

IBS

– Decrypt role key k(r,vr ) = Dec
– Decrypt ﬁle key k = DecIBE
k(r,vr )
– Decrypt ﬁle f = Dec
(c)

Sym
k

IBE
ku
(c

(c
(cid:2)(cid:2))

IBS

IBS

writeu(f n, f )
– Find a role r such that the following hold:
SU ((cid:4)RK, u, (r, vr), c(cid:5), sig) = 1

∗ u is in role r, i.e., there exists (cid:4)RK, u, (r, vr), c, sig(cid:5) with
∗ r has write access to the newest version of f n, i.e., there exists
SU ((cid:4)FK,

(cid:2)(cid:5) and Ver

Ver
(cid:4)FK, (r, vr), (cid:4)f n, RW(cid:5), vf n, c
(r, vr), (cid:4)f n, RW(cid:5), v, c
– Decrypt role key k(r,vr ) = Dec
– Decrypt ﬁle key k = DecIBE
k(r,vr )
– Send (cid:4)F, f n, vf n, Enc
– The R.M. receives r and (cid:4)F, f n, v, c

Sym
k

(cid:2), SU, sig
(cid:2), SU(cid:5), sig
(cid:2)) = 1
(c)
(cid:2))

IBE
ku
(c

(cid:2)(cid:2)(cid:5) and veriﬁes the

(r,vr )(cid:5) to R.M.

(f ), (r, vr), Sign

, (r, vr), sig

(cid:2)(cid:2)) = 1

following:
∗ The tuple is well-formed with v = vf n
, (r, vr)(cid:5),
∗ The signature is valid, i.e., Ver
∗ r has write access to the newest version of f n, i.e., there exists
SU ((cid:4)FK,
– If veriﬁcation is successful, the R.M. replaces (cid:4)F, f n, −, −, −, −(cid:5)

sig
(cid:4)FK, (r, vr), (cid:4)f n, RW(cid:5), vf n, c
(r, vr), (cid:4)f n, RW(cid:5), vf n, c

(r,vr )((cid:4)F, f n, v, c

(cid:2), SU, sig
(cid:2)) = 1

(cid:2)(cid:5) and Ver

(cid:2), SU(cid:5), sig

IBS

IBS

IBS

(cid:2)(cid:2)

(cid:2)(cid:2)

with (cid:4)F, f n, vf n, c

(cid:2)(cid:2)

, (r, vr), sig

(cid:2)(cid:2)(cid:5)

Fig. 2: Implementation of RBAC0 using IBE and IBS

827827

For formal deﬁnitions of these properties, see [36]. Using

parameterized expressiveness, we get the following results:

Theorem 1: The implementation of RBAC0 using IBE and

IBS detailed in Fig. 2 is correct, AC-preserving, and safe.

Theorem 2: The implementation of RBAC0 using public key
cryptographic techniques is correct, AC-preserving, and safe.
We now give an overview of the structure of and ideas behind
the proof of Theorem 1. This proof begins by formalizing
the IBE/IBS construction presented in Section IV using the
parameterized expressiveness framework. We then provide a
formal mapping from RBAC0 to our IBE/IBS system. We show
that this mapping preserves user authorization, meaning that a
user is authorized for a permission in RBAC0 if and only if
the user is also authorized by the IBE/IBS construction.

The tricky part of this proof involves showing that changes to
the RBAC0 state map correctly as changes to the IBE/IBS state.
This means that changing the RBAC0 state and then mapping
to IBE/IBS has the same effect as mapping to IBE/IBS and
then changing the state there in an equivalent way. Our use of
version numbers in IBE/IBS means that a single RBAC0 state
may map to multiple IBE/IBS states; i.e., if a user is granted
permissions that are later revoked, the resulting RBAC0 state
will be the same as if the permissions were never granted, but
the IBE/IBS state will have different version numbers as a
result of the revocation. Therefore, we consider IBE/IBS states
that only differ in version numbers to be congruent. We show
that the IBE/IBS state resulting from a change to the RBAC0
state, followed by mapping to IBE/IBS, is congruent to one
crafted by ﬁrst mapping to IBE/IBS, and then changing the
IBE/IBS state in a corresponding way.

The full proof of Theorem 1 can be found in Appendix A.
We note that the proof of Theorem 2 is very similar in structure,
and an accompanying technical report [28] provides the details.

B. Algebraic Costs

Table I lists the costs for each RBAC operation based on the
system state. All costs are incurred by the user or administrator
running the operation unless otherwise noted. In order to
simplify the formulas, we employ a slight abuse of notation:
we use the operation itself to represent its cost (e.g., EncIBE
is used to represent the cost of one EncIBE operation). We
use the following notation:

• roles(u) is the set of roles to which user u is assigned
• perms(r) is the set of permissions to which role r is

assigned

assigned

• users(r) is the set of users to which role r is assigned
• roles(p) is the set of roles to which permission p is

• versions(p) is the number of versions of permission p

C. Experimental Setup

To evaluate the costs of using our constructions to enforce
RBAC0, we utilize the simulation framework proposed in [26].
We encode RBAC0 as a workload, with implementations in
IBE/IBS and PKI as described in Sections IV-C and IV-D.
Simulations are initialized from start states extracted from

828828

assign
user

∞

μRU

μAU
∞

assign
perm.

μAP

∞

revoke
user

∞

μRP

revoke
perm.

var
R
μA
μU
μAU
μRU
μAP
μRP

semantics

administrative rate

add bias
UR bias

Rate of assignUser
Rate of revokeUser

Rate of assignPermission
Rate of revokePermission

value

0.1 × (cid:2)|U|/day

[0.7, 1.0]
[0.3, 0.7]

μA × μU × R

(1 − μA) × μU × R
μA × (1 − μU ) × R

(1 − μA) × (1 − μU ) × R

Fig. 3: Administrative actions in our experiments

real-world RBAC datasets. We then generate traces of access
control actions using actor-speciﬁc continuous-time Markov
chains, or actor machines. While this is a fairly simple model
of actors’ behaviors, it allows us to easily investigate trends in
costs. In particular, we are able to investigate changes in the
relative frequencies of the various administrative actions, and
the costs resulting from these changes.

We simulate one-month periods in which the administrator
of the system behaves as described in the actor machine
depicted in Fig. 3. The administrative workload increases with
the number of users in the system, and we randomly sample
an add bias parameter that describes the relative proportion
of assignment vs. revocation operations. We do not include
administrative actions that add or remove users or roles, due to
the unlikely occurrence of these actions on such short timescales
(one-month simulations).

(cid:2)|U| (with |U| the number of users), ranging

This administrative behavior model describes a range of real-
istic scenarios and thus allows us to investigate the interactions
in which we are interested. The overall administrative rate is
approximately
from about 0.6 administrative actions per day on our smallest
dataset to 2.2 on the largest. We consider the range of 0%
to 30% of the administrative load consisting of revocations,
since in realistic scenarios permissions tend to be assigned at
a greater rate than they are revoked [63].

To quantify the costs associated with our cryptographic
constructions, we record the number of instances of each
cryptographic operation executed, including counts or averages
for traces of related operations (e.g., the average number of
IBE encryptions needed to revoke a role from a user).

As mentioned above, simulation start states are extracted
from real-world RBAC datasets. These datasets are summarized
in Table II. All of these datasets, aside from university,
were originally provided by HP [22]. The domino dataset
is from a Lotus Domino server, emea is from a set of
Cisco ﬁrewalls, ﬁrewall1 and ﬁrewall2 are generated from
network reachability analysis, and healthcare is a list of

(cid:2)

addU (u) : KeyGen
delU (u) :
addP (p) : Enc
delP (p) : None
addR(r) : KeyGen
delR(r) :

(cid:2)

IBS

IBE + KeyGen
r∈roles(u) revokeU (u, r)
IBE + 2 · Sign

IBS and 2 · Ver

IBS by R.M.

IBE + Enc

IBE + KeyGen

IBS + Sign

IBS

IBE + Dec

p∈perms(r) revokeP (p, r)
IBE + Sign
assignU (u, r) : Enc
(cid:3)
IBE + KeyGen
revokeU (u, r) : KeyGen
(cid:6)
IBE · (cid:2)
+
versions(p)·(cid:5)
IBS + Ver
Revokes only write access: |versions(p)| · (cid:5)

revokeP (p, r) : Revokes all access: |roles(p)| · (cid:5)

IBS + Ver
IBS +

assignP (p, r) :

Sign

Dec

Enc

Ver

(cid:3)

IBS

IBS

(cid:6)

read(f n) : 2 · (cid:5)

write(f n, f ) : Sign

(cid:2)
(cid:4)

p∈perms(r)(versions(p) + |roles(p)|)

|users(r)| +
p∈perms(r) versions(p)
; if r has no permissions for the ﬁle then also versions(p)·(cid:5)
(cid:6)

IBS

Enc

IBE + Sign

IBS +

Enc

IBE + Dec

IBE

(cid:6)

(cid:4)(cid:5)

IBE + Sign
Sign

IBS + Ver
IBS + Ver

IBS

IBS

(cid:6)
(cid:6)

;

Dec

IBS

IBE + Ver
Dec

IBS + 2 · (cid:5)
TABLE I: Algebraic costs of RBAC0 operations in our IBE/IBS implementation

and 2 · Ver

IBS by R.M.

IBE + Ver

IBS

(cid:6)

set

domino
emea
ﬁrewall1
ﬁrewall2
healthcare
university

users
79
35
365
325
46
493

|P|
231
3046
709
590
46
56

|R|
20
34
60
10
13
16

|UR|
75
35
1130
325
55
495

roles/user

users/role

perm./role

roles/perm.
|PA| max min max min max min max min
1
629
1
7211
3455
1
1
1136
1
359
202
1

30
2
174
222
17
288

209
554
617
590
45
40

10
31
25
8
12
12

3
1
14
1
5
2

0
1
0
1
1
1

1
1
1
1
1
1

1
9
1
6
7
2

TABLE II: Overview of the datasets used in our experiments

healthcare permissions from the US Veteran’s Administration.
The university dataset describes a university’s access control
system, and was developed by IBM [48], [65].

D. Experimental Results

Figure 4 presents a sampling of our results. First, we consider
the cost of performing revocations in our implementation of
RBAC0 using IBE/IBS. Figure 4a shows the average number
of IBE encryptions needed for a single user revocation (i.e.,
removing a user from a role), and Fig. 4b shows the same
for permission revocation (i.e., revoking a permission from a
role). This shows that revoking a permission can cost several
IBE encryptions, while user revocation incurs hundreds or
thousands of IBE encryptions, on average. We note that, by
inspection of the code in Fig. 2, a user revocation also requires
an equal number of IBS signatures and veriﬁcations, a smaller
number of IBE decryptions, and the generation of new IBE
and IBS keys for the role.

For our chosen distribution of administrative actions, Fig. 4c
shows the total number of IBE encryptions performed over a
month for all user revocations. As the add bias approaches 1,
the number of revocations (and thus the total number of IBE
encryptions for user revocation) approaches 0. However, even
when only 5–10% of administrative actions are revocation, the
number of monthly IBE encryptions under this parameterization
is often in the thousands.

In Fig. 4d, we show the number of ﬁles that must be re-
keyed for a single user revocation. This highlights the beneﬁt
of utilizing lazy re-encryption; if we had instead utilized
active re-encryption, each of these ﬁles would need to be
locked, downloaded, decrypted, re-encrypted, and re-uploaded
immediately following revocation. In certain scenarios, active
re-encryption may be computationally feasible. For instance, in
university, only ≈ 10 ﬁles must be re-encrypted for the average
user revocation, adding less than 1% to the total number of ﬁle
encryptions executed over the entire simulation, even at the
highest rate of revocations that we consider. However, in most
other scenarios, a user revocation triggers the re-key of tens or
hundreds of ﬁles, such as in emea or ﬁrewall2, where active
re-encryption increases the total number of ﬁle encryptions
by 63% and 12%, respectively (at 20–30% revocation rate).
Thus, in most scenarios, active re-encryption is likely to be
infeasible, as discussed in Section IV-B.

Given the administrative behavior model depicted in Fig. 3,
Fig. 4e shows the total number of ﬁle re-keys that take place
over a month for the purpose of user revocation. For scenarios
with very user- and permission-dense roles (e.g., ﬁrewall1
and ﬁrewall2), we see several times as many re-keys as total
ﬁles, indicating that, on average, each ﬁle is re-keyed multiple
times per month for the purposes of user revocation. This
further enforces that inefﬁciencies that active re-encryption
would bring, as each ﬁle (on average) would be locked and

829829

d
e
k
o
v
e
r
 
r
e
s
u

 
r
e
p

 
s
n
o

i
t

p
y
r
c
n
e
E
B

 

I

d
e
k
o
v
e
r
 
r
e
s
u

 
r
e
p

 
s
y
e
k
e
r
 
e

l
i

F

0
0
0
4

0
0
0
3

0
0
0
2

0
0
0
1

0

0
0
6

0
0
5

0
0
4

0
0
3

0
0
2

0
0
1

0

●

●

●●●●

a
e
m
e

1

l
l

a
w
e
r
i
f

2

l
l

a
w
e
r
i
f

Dataset

●

e
r
a
c
h

t
l

a
e
h

●

y
t
i
s
r
e
v
n
u

i

●
●

●
●
●

●
●
●
●
●
●
●
●
●

●

●
●
●

●

i

o
n
m
o
d

(a) IBE encs. per user revoked

●

●●●●

●

●

●●
●

●
●
●●●●

●
●

y
t
i
s
r
e
v
n
u

i

●

e
r
a
c
h
t
l
a
e
h

a
e
m
e

1

l
l

a
w
e
r
i
f

2

l
l

a
w
e
r
i
f

Dataset

●
●

●
●
●

●

●
●

●
●

●
●
●
●

●

●
●

i

o
n
m
o
d

0
0
7

0
0
6

0
0
5

0
0
4

0
0
3

0
0
2

0
0
1

0

0
2
1

0
0
1

0
8

0
6

0
4

0
2

0

d
e
k
o
v
e
r
 

i

n
o
s
s
m
r
e
p

i

 
r
e
p

 
s
n
o

i
t

p
y
r
c
n
e
E
B

 

I

n
o

i
t

a
c
o
v
e
r
 
r
e
s
u
 
r
o

f
 
s
y
e
k
e
r
 
e

l
i

F

0
2

5
1

0
1

5

●

●

●

●

●

a
e
m
e

1

l
l

a
w
e
r
i
f

n
o

i
t

a
c
o
v
e
r
 
r
e
s
u

 
r
o

f
 
s
n
o

i
t

p
y
r
c
n
e
E
B

 

I

0
0
0
5
1

0
0
0
0
1

0
0
0
5

0

●

●

y
t
i
s
r
e
v
n
u

i

●

●●

i

o
n
m
o
d

●
●
●

●
●
●

2

l
l

a
w
e
r
i
f

e
r
a
c
h

t
l

a
e
h

Dataset

●

●

●

●

●

●

●
●

●
●

●

●

●

●

●

●

●

●

●
●●

●

●

●

●

●
●

●
●

●

●

●

●

●

●
●

●

●

●
●

●
●
●
●
●
●
●
●
●

●
●
●
●

●
●

●

●

●

●

●
●

●

●

●

●

●
●

●

●

●

●

●

●
●

●

●

●

●

●
●

●

●
●
●
●
●
●

●

●
●
●
●

●
●
●
●●
●
●
●

●

●
●
●
●
●
●
●

●

●

●
●

●

●
●

●
●
●
●
●

●

●

●

●
●

●
●
●

●
●
●

●
●

●

●

●

●

●

●
●
●
●
●
●
●
●
●

●
●
●
●
●●
●
●

●
●
●

●

●

●

●

●

●
●
●
●
●
●●
●
●
●
●
●
●
●
●
● ●
●
●
●
●●
●
●
●
●
●
●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●

●

●

●

●

●

●

●

emea
firewall1
firewall2
healthcare
university
domino

●

●

●

●

●

●

●

●

●

●

●

●

●
●

●

●

●
●

●

●

●

●
●
●
●

●

●

●

●

●

●

●

●

●

●

●

●
●

●
●
●
●
●

● ●
●

●
●
●

●

●
●

●

●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●

●

●

●
●

●
●
●
●
●
●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●●
●●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●●●
●
●
● ●
●
●●
● ●
● ●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●
●
●

●
●

●
●
●

●

●

●

●

●

●

●
●
●
●

●

0
7

.

0

5
7

.

0

0
8

.

0

5
8

.

0

0
9

.

0

5
9

.

0

0
0

.

1

Add bias

(b) IBE encs. per permission revoked

(c) IBE encs. for user revocation vs. add bias

0
0
0
2

0
0
5
1

0
0
0
1

0
0
5

0

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

emea
firewall1
firewall2
healthcare
university
domino

●
●

●

●

●

●
●

●

●

●

●

●

●
●
●
●

●

●

●
●

●

●

●

●

●
●

●

●
●
●
●
●
●
●

●
●

●

●

●
●

●

●

●

●

●

●
●
●
●
●

●

●

●

●

●
●
●
●
●
●
●

●

●

●

●
●

●

●
●

●

●

●

●
●
●

●
●

●

●

●
●

●

●

●
●

●

●

●

●

●

●
●

●

●

●
●

●

●

●

●

●
●

●

●

●
●
●

●
●

●

●

●
●

●

●

●
●

●

●

●

●
●

●
●

●

●

●

●
●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●

●
●
●

●
●
●

●
●
●
●
●

●
●

●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
● ●
●
●●
●
●
●
●
●
●●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●●●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●●
●
●
●
●
●
● ●
●
●
●●
●
● ●
●
●
●
●
●
●
●
● ●
●
●
●
●
●●
●
●
●
●
●
●●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●

●
●
●
●
●
●
●
●
●

●
●
●
●

●
●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●
●

●

●

●

●
●

●

●
●
●

●

●
●

●

●
●

●
●

●

s
n
o

i
t

p
y
r
c
n
e
 
y
e
K

0
0
0
0
2

0
0
0
0
1

0
0
0
5

0

●

●

●

●

●

●

●

●

●

●

●
●

●

●

●
●
●
●
●

●
●

●

●

●
●

●

●

●
●

●

●
●●
●

●

●
●
●

●

●

●

●

●
●
●

●

●

●
●
●

●

●

●

●

0
7
0

.

5
7
0

.

0
8
0

.

5
8
0

.

0
9
0

.

5
9
0

.

0
0
1

.

0
7
0

.

5
7
0

.

0
8
0

.

5
8
0

.

Add bias

Add bias

●

●

IBE encryptions
Asymmetric encryptions

●

●

●

●

●
●

●

●

●

●

●

●

●
●
●
●

● ●

●
●

●

●

●
●

●

●

●

●

●

●
●
●

●

●
●
●
●

●
●
●

●
●
●
●
●
●

●

●
●

●

●
●

●
●

●
●

●
●

●

●

●

●

●

●

●

●

● ●
● ●
●
●

●
●
●
●

●

●
●

●
●
●
●

●
●
●●
●
●
●
●

●
●
●

●

●
●

●
●

●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●

●

●
●

0
9
0

.

5
9
0

.

0
0
1

.

(d) File rekeys per user revoked

(e) File rekeys for user revoc. vs. add bias

(f) Key encryptions vs. add bias (ﬁrewall1)

Fig. 4: Results of running 100 one-month simulations on each dataset (each data point is a simulation)

re-encrypted by the administrator multiple times per month.

Finally, we note that the costs for our IBE/IBS- and PKI-
based constructions for RBAC0 are not notably different. For
instance, Fig. 4f compares, for scenario ﬁrewall1, the number
of IBE encryptions with the number of asymmetric encryptions
executed over each simulated month and reveals the same
distribution in both IBE/IBS- and PKI-based constructions.
Given the similarity in the cost of these classes of operations,
we can conclude that these constructions are similarly expensive
from a computational standpoint.
E. Converting Experimental Results to Real Costs

We now demonstrate how the costs of generic IBE encryp-
tions turn into actual computational costs for given schemes.
Since any implementation’s running time is contingent on
a myriad of variables (e.g., processor speed, memory, etc.)
we focus on the number of (pairing friendly) elliptic curve
cryptographic operations that need to be performed. We assume
schemes are implemented using an asymmetric (Type 3) pairing:
e : G × ˆG → GT , where G, ˆG, GT are groups of prime order;
this is more efﬁcient than a symmetric (Type 1) pairing [25].
Additive notation is used in G and ˆG, while multiplicative
notation is used in GT .

We use multiplication in G as our cost unit, expressing the
relative costs of other operations in terms of this operation. The
relative costs should be somewhat stable across hardware and

830830

reasonable implementations. These relative costs are given in
Table III and are based on data provided by Ayo Akinyele, an
ABE/pairing implementation expert at Zeutro LLC (personal
communication). Costs of addition in G, ˆG, and multiplication
in GT are so low that we ignore them. These relative costs
are based on the implementation of RELIC v0.4 [2], using
a Barreto-Naehrig curve with a 256-bit base ﬁeld, GMP for
big number operations, and standard conﬁguration options for
prime ﬁeld arithmetic. For a point of reference, a reasonable
modern workstation running RELIC v0.4 on such curves
will take approximately 0.2 ms on average to compute a
multiplication in G.

Operation
G Multiplies

ˆG Multiply GT Exp.

4.5

9

Pairing (e)

9

TABLE III: Relative cost of Type 3 pairing operations in terms
of multiplication in G in RELIC v0.4

To determine concrete costs, we consider three representative

combinations of IBE and IBS algorithms:

BF+CC: The IBE scheme from [11, Sec. 4.1] and the IBS
scheme from [13, Sec. 2]. Both are efﬁcient and are proven
secure in the random oracle model.

BB1+PS: The IBE scheme from [9, Sec. 4] and the IBS
scheme from [54, Sec. 4]. These schemes are less efﬁcient
than BF+CC but are proven secure in the standard model.

LW+PS: The IBE scheme from [44, App. C] and the IBS
scheme from [54, Sec. 4]. The IBE scheme here is less efﬁcient
but has stronger security properties.

Table IV lists the cost of each additive RBAC0, read and
write operation in terms of total “multiplication units” in G.
That is, we sum the cost of cryptographic operations in terms
of multiplication units using the conversion factor in Table III.
Table IV speciﬁes the costs incurred by the invoker of the
operation (either the admin or the user) as well as the reference
monitor. For completeness, a table documenting the individual
costs of each basic IBE/IBS operation for these schemes can
be found in [28], an accompanying technical report.

Incurred by Operation BF+CC BB1+PS

LW+PS

addU
addP
addR
assignU
assignP3
read
write
addP
write

5.5
15
18.5
41
41
56
58
38
38

14.5
25
33
63.5
63.5
90
96.5
54
54

32.5
29
55

103.5
103.5
162
168.5

54
54

Invoker

R.M.

TABLE IV: Costs of operations in terms of G multiplications

The cost to delete a user/role or to revoke a user/permission
depends on the RBAC state at the time of revocation, so we
cannot give deﬁnite costs for these operations. Instead, we
use the experimental results from Section V-D to get an idea
of how expensive revocation can be. The results of this are
in Fig. 5, where we plot the costs for each dataset using the
three IBE/IBS combinations listed above. Figure 5a shows
the cost of revoking a user in terms of multiplications in G;
Fig. 5b does the same for revoking a permission. Note that for
our datasets, a single user revocation usually costs more than
10,000 multiplications in G (≈ 2 s. on a modern workstation),
and often costs more than 100,000 multiplications (≈ 20 s.)
for some datasets. While not exceedingly huge, we remind the
reader that our costing does not account for many costs, such
as concurrency, communication, and storage costs. Further, our
construction minimizes other costs through the use of lazy
re-encryption and hybrid encryption.

VI. DISCUSSION

There is no doubt that IBE and ABE can enable various
forms of cryptographic access control for data in the cloud.
In fact, the results presented in Figs. 4c, 4e and 4f show
that in situations in which the system grows in a monotonic
manner (i.e., users and ﬁles are added to the system and roles
are provisioned with new permissions), there is no need for
revocation, re-keying, or complicated metadata management:
IBE alone can enforce RBAC access controls on the cloud.
In fact, there are even implications or direct claims in the
literature that, in the static setting, the reference monitor can
be removed entirely (e.g., [30], [31], [49]). However, this does
not imply that IBE or ABE alone can entirely replace the use

of a reference monitor when implementing outsourced access
controls: it is not the case when dynamic controls are required.
Speciﬁcally, this paper shows that IBE and PKI systems
are well-suited for implementing point states of an RBAC0
system. However, managing transitions between these states—
speciﬁcally, supporting the removal of a user from a role, the
revocation of a permission from a role, and efﬁcient updates to
ﬁles shared with multiple roles—requires non-trivial metadata
management and a small, minimally-trusted reference monitor
that veriﬁes signatures prior to ﬁle deletion and replacement.
In some of the datasets that we analyzed, this could lead to
thousands of IBE encryptions (Fig. 4a) and over one hundred
ﬁle re-keys/re-encryptions (Fig. 4d) when a single user is
removed from a role.

The above considerations lead to a tradeoff between con-
ﬁdentiality and efﬁciency that must be weighed by both
cryptographers and system designers. There are two obvious
ways that this can be accomplished: by altering the threat
model assumed, or developing cryptographic approaches that
are more amenable to the dynamic setting. We now discuss
both of these approaches, and comment on lessons learned
during our analysis that can be applied to richer cryptographic
access control, such as using HIBE to support RBAC1, or ABE
to support ABAC.

A. Alternate Threat Models

Many of the overheads that we report on in the previous
section result from the threat model often implied by the
cryptographic literature (i.e., untrusted storage server, minimal
client-side infrastructure). Altering this model can reduce the
cryptographic costs of enforcing dynamic access controls on
the cloud. Here we consider two such alternate models.

Encryption/Decryption Proxy. A large amount of overhead
comes from relying the cloud storage provider to act as a
(cryptographic) metadata broker, as well as a ﬁle store. An al-
ternative approach might make use of an encryption/decryption
proxy server situated within an organization, using the cloud
provider solely as a backing store for encrypted ﬁles. This proxy
would act as a traditional reference monitor, mediating all ﬁle
access requests, downloading and decrypting ﬁles for authorized
readers4, and returning plaintext to the user. This would obviate
the need for any cryptography beyond authenticated symmetric
key encryption, and could make use of tried-and-true access
control reference monitors. However, this approach carries an
extra infrastructure overhead (the proxy server, itself) that could
make it unappealing to individuals hoping to enforce access
controls over cloud hosted ﬁles. Large organizations may also
have to deal with synchronizing access control policies and
key material across multiple proxies in the event that ﬁle I/O
demands outpace the abilities of a single server.

Trusted Hardware. A more extreme approach to simplify-
ing the cryptographic overheads of access control enforcement
would be to use, e.g., an SGX enclave [39], [47] to carry out
the work of the encryption/decryption proxy discussed above.

3Assumes permission is for new ﬁle; cost is per version of the ﬁle

4Writes could be handled symmetrically.

831831

d
e
k
o
v
e
r
 
r
e
s
u
 
r
e
p
 
G
 
n
i
 
s
n
o
i
t
a
c

i
l

p
i
t
l
u
M

0
0
0
0
5
2

0
0
0
0
0
2

0
0
0
0
5
1

0
0
0
0
0
1

0
0
0
0
5

0

G

G

G

G

G

G

BF+CC
BB+PS
LW+PS

GGGG

GGGG

GGGG

G

G

G

G

G

G

G
G

G
G
G

G
G
G
G
G
G
G
G
G

G
G
G
G

G
G
G

G
G

G
G
G

G
G
G
G
G
G
G
G
G

G
G
G
G

G

G
G

G
G
G

G
G
G
G
G
G
G
G
G
G
G
G
G

G

0
0
0
0
4

0
0
0
0
3

0
0
0
0
2

0
0
0
0
1

0

d
e
k
o
v
e
r
 

i

i

n
o
s
s
m
r
e
p
 
r
e
p
G
n

 

 

i
 
s
n
o

i
t

a
c

i
l

p

i
t
l

u
M

0
0
0
1

0
0
8

0
0
6

0
0
4

0
0
2

0

●

●

●

●

●

●

●

●

●

BF+CC
BB+PS
LW+PS

●

●

●

●

●

●

●
●
●
●
●
●

●
●
●
●
●
●

●
●
●
●
●
●

0
0
0
1

0
0
8

0
0
6

0
0
4

0
0
2

0

●

●

●

●

●

●

●

●●

●

●●

●

●●

emea

firewall1

firewall2

healthcare

university

domino

emea

firewall1

firewall2

healthcare

university

domino

Dataset

Dataset

(a) Multiplications in G per user revoked

(b) Multiplications in G per permission revoked

Fig. 5: Costs of revocation in different IBE/IBS schemes, in terms of elliptic curve point multiplications in group G

In this scenario, ﬁles could be stored encrypted on the cloud
server, while ﬁle encryption keys and the access control policy
to be enforced would be managed by a process running within
an SGX enclave. To access a ﬁle, a user would negotiate an
authenticated channel (e.g., using public key cryptography) with
this trusted process/reference monitor. The reference monitor
could then check the user’s permission to access the ﬁle, and
transmit the encrypted ﬁle and its associated key to the user
using a session key that is unknown to any process outside of
the SGX enclave. This approach frees organizations from the
overheads of running their own encryption/decryption proxies,
but is not without its limitations. For instance, this approach
will not work on commonly-used, storage-only services (e.g.,
Dropbox). Further, this approach may be subject to architectural
compromises or ﬂaws (e.g., memory integrity vulnerabilities)
that cryptography-only solutions are not.

While these and other alterations to the threat model that
we consider can lead to decreased cryptographic overheads,
each incurs other costs or tradeoffs. We now consider future
research directions that may decrease the costs associated with
cryptography-only solutions to the problem of outsourcing
dynamic access controls.

B. Future Directions

Our experimentation and analysis has led to a number of

interesting directions for future work:
• Revocation. It

is unclear how to use IBE to enforce
even RBAC0 without incurring high costs associated with
revocation-based state changes. Given our use of hybrid
cryptography for efﬁciency reasons, existing schemes for
revocation or proxy re-encryption (e.g., [8], [32]) cannot
solve the problem. Developing techniques to better facilitate
these forms of revocation and efﬁcient use of hybrid
encryption is an important area of future work.

• Trust Minimization. Our construction makes use of a
reference monitor on the cloud to validate signatures prior
to ﬁle replacement or metadata update. Moving to ﬁle
versioning (e.g., based on trusted timestamping or block-
chaining) rather than ﬁle replacement may result
in a

minimization of the trust placed in this reference monitor,
but at the cost of potential conﬁdentiality loss, since old key
material may remain accessible to former role members. It
is important to better explore this tradeoff between reference
monitor trust and conﬁdentiality guarantees.

• “Wrapper” Minimization. Our construction required the
management and use of three types of metadata structures to
correctly implement RBAC0 using IBE or PKI technologies.
It would be worth exploring whether the core cryptography
used to support outsourced access controls could be enhanced
to reduce the use of trusted management code needed to
maintain these sorts of structures.

• Deployability/Usability Costs. We did not consider issues
related to the use of the cryptographic tools underlying our
constructions. Further, our simulations do not separate our
IBE- and PKI-based constructions5 on the basis of RBAC0
implementation complexity. However, it may be the case
that the maturity of tools to support the use of PKIs or the
conceptual simplicity of IBE techniques tips the scales in
one direction or the other. Developing reasonable approaches
for considering these types of tradeoffs would greatly inform
future analyses.
While this paper focused on the use of IBE/IBS and PKI
schemes to enforce RBAC0 access controls, our ﬁndings
translate in a straightforward manner to the use of other
cryptographic tools (e.g., HIBE or ABE/ABS) to implement
more complex access control policies (e.g., RBAC1 or ABAC).
We now discuss some lessons learned when considering these
richer access control models.

C. Lessons Learned for More Expressive Systems

RBAC0 and IBE were natural choices for our initial ex-
ploration of the costs associated with using cryptography to
implement dynamic access control: RBAC0 is a simple, but
widely used, access control system; roles in RBAC0 have a
natural correspondence to identities in IBE; and the use of
hybrid encryption allows us to easily share resources between

5Our PKI construction and its corresponding simulations were omitted from

this paper due to space limitations.

832832

roles. Further, it seemed like an implementation of RBAC0
using IBE would be a jumping-off point for exploring the
use of hierarchical roles in RBAC1 via an analogous use of
HIBE. However, many of the costs that we see with our IBE
implementation of RBAC0 have analogues (or worse) in any
reasonable RBAC1 or ABAC implementation that we foresee
based on respective cryptographic operations.

We ﬁrst note that we assume that any reasonable cryp-
tographic access control system must make use of hybrid
encryption. Without hybrid encryption, we would need to
continuously apply expensive asymmetric operations to small
“blocks” of a ﬁle that is to be encrypted. Given the complexity
of IBE/ABE encryption operations, the associated overheads of
this approach would be prohibitive, even for moderately-sized
ﬁles. Additionally, depending on the security requirements of
the application (e.g., Chosen Ciphertext Attack security), even
more complicated constructions than this simple blocking will
be required. The following observations may not apply to an
access control scheme where all ﬁles are small enough to do
away with the need of hybrid-encryption. However, the use
cases for such schemes seem limited.

A seemingly natural extension of our IBE-based RBAC0
scheme to a HIBE based RBAC1 scheme exploits the fact that
the HIBE can be used to encode hierarchical relationships,
such as those that exist between roles in a RBAC1 role
hierarchy. However, the costs of this implementation proved to
be considerable. A large initial problem is that an RBAC1 role
hierarchy can be an arbitrary DAG structure, while HIBE only
supports trees. Yet, even limiting RBAC1 to role hierarchies
that form a tree structure comes with serious costs. For example,
removing non-leaf roles in the hierarchy cascades re-encryption
down to all ﬁles at descendant leaves of the role, the creation of
new roles for each descendant node, and associated rekeying.
Similarly, practical operations like moving sub-trees in the
access structure can only be achieved by breaking the operation
down into addition and deletion of roles, which comes with
the associated costs of these primitive operations. We note that
we have developed a full RBAC1 implementation using HIBE,
which attempts to minimize costs. Unfortunately, a simple
inspection of this implementation shows that it would incur
signiﬁcantly more computational expense than the RBAC0
scheme discussed herein.

Similarly, one might hope that the expressiveness of the ABE
encryption schemes would allow us to naturally implement
ABAC access control schemes. Further, there has been some ini-
tial work [58] supporting dynamic (restrictive) credentials and
revocations. However, there is still signiﬁcant work associated
with making a practical ABE implementation of ABAC, and
such schemes will still have signiﬁcant costs and meta-data to
manage (as in our IBE/RBAC0 implementation). For example,
revoking a secret-key in an KP-ABE/ABAC setting requires
the dynamic re-encryption of every ciphertext whose attributes
satisfy the policy in the revoked user’s key. Each attribute in
each ciphertext that is re-encrypted must given a new version,
and then ﬁnally all users whose keys have policies affected by
the re-versioning of the attributes must be re-issued. Further,

833833

there are ABAC design decisions that must be informed by
the ABE scheme being implemented. For example, suppose
a single ﬁle is to be accessed by multiple policies in a CP-
ABE scheme. One can support multiple policies p1, . . . , pn
as individual public-key encryptions all encrypting the same
hybrid key, or as a single encryption supporting the disjunction
of all previous policies, p1 ∨ p2 ∨ ··· ∨ pn. The cost trade-
offs are completely dependent on the ABE scheme used for
the implementation, as the cost of ABE encryption is highly
dependent on the policy encoded into the ciphertext.

VII. CONCLUSIONS

Advanced cryptographic techniques (e.g., IBE and ABE)
are promising approaches for cryptographically enforcing rich
access controls in the cloud. While prior work has focused on
the types of policies that can be represented by these approaches,
little attention has been given to how policies may evolve
over time. In this paper, we move beyond cryptographically
representing point states in an access control system for cloud-
hosted data, and study constructions that cryptographically
enforce dynamic (role-based) access controls. We provide
evidence that, given the current state of the art, in situations
involving even a minimal amount of policy dynamism, the
cryptographic enforcement of access controls is likely to
carry prohibitive costs. Further, these costs are seemingly
ampliﬁed when enforcing richer policies (e.g., RBAC1 or
ABAC), requiring more stringent security guarantees (e.g.,
online, rather than lazy, re-encryption), or assuming more
relaxed threat models.

To conduct our analysis, we developed IBE- and PKI-based
constructions that use hybrid cryptography to enforce dynamic
RBAC0 access controls over ﬁles hosted on a third-party
cloud storage provider. In addition to proving the correctness
of our constructions, we used real-word RBAC datasets to
experimentally analyze their associated cryptographic costs.
Our ﬁndings indicate that IBE and ABE are a natural ﬁt to
this problem in instances where users, roles, and permissions
increase monotonically, but incur very high overheads—e.g.,
sometimes exceeding thousands of encryption operations to
support a single revocation—when updates and revocation
must be supported. In doing so, we have identiﬁed a number
of fruitful areas for future work that could lead to more natural
constructions for cryptographic enforcement of access control
policies in cloud environments.

Acknowledgements. We would like to offer our thanks to
´Ulfar Erlingsson, for his guidance in
our paper shepherd,
reﬁning this paper. This work was supported, in part, by
the National Science Foundation under awards CNS–1111149,
CNS–1228697, and CNS–1253204.

REFERENCES

[1] S. G. Akl and P. D. Taylor, “Cryptographic solution to a problem of

access control in a hierarchy,” TOCS, vol. 1, no. 3, 1983.

[2] D. F. Aranha and C. P. L. Gouvˆea, “RELIC is an efﬁcient library for

cryptography,” http://code.google.com/p/relic-toolkit/.

[3] M. J. Atallah, M. Blanton, N. Fazio, and K. B. Frikken, “Dynamic and
efﬁcient key management for access hierarchies,” TISSEC, vol. 12, no. 3,
2009.

[4] M. Y. Becker, C. Fournet, and A. D. Gordon, “Secpal: Design and
semantics of a decentralized authorization language,” Journal of Computer
Security, vol. 18, no. 4, pp. 619–665, 2010.

[5] J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-policy attribute-

based encryption,” in S&P, 2007.

[6] A. Birgisson, J. G. Politz,

´U. Erlingsson, A. Taly, M. Vrable, and
M. Lentczner, “Macaroons: Cookies with contextual caveats for de-
centralized authorization in the cloud,” in NDSS, 2014.

[7] M. Blaze, J. Feigenbaum, and J. Lacy, “Decentralized trust management,”

in S&P, 1996.

[8] A. Boldyreva, V. Goyal, and V. Kumar, “Identity-based encryption with

efﬁcient revocation,” in CCS, 2008.

[9] D. Boneh and X. Boyen, “Efﬁcient selective identity-based encryption
without random oracles,” Journal of Cryptology, vol. 24, no. 4, 2011.
identity based

[10] D. Boneh, X. Boyen, and E.-J. Goh, “Hierarchical

encryption with constant size ciphertext,” in EUROCRYPT, 2005.

[11] D. Boneh and M. Franklin, “Identity-based encryption from the Weil

pairing,” SIAM Journal on Computing, vol. 32, no. 3, 2003.

[12] D. Boneh, K. Lewi, H. W. Montgomery, and A. Raghunathan, “Key

homomorphic prfs and their applications,” in CRYPTO, 2013.

[13] J. C. Cha and J. H. Cheon, “An identity-based signature from gap

difﬁe-hellman groups,” in PKC, 2003.

[14] J. Crampton, “Cryptographic enforcement of role-based access control,”

in FAST, 2010.

[15] ——, “Practical and efﬁcient cryptographic enforcement of interval-based

access control policies,” TISSEC, vol. 14, no. 1, 2011.

[16] J. Crampton, K. M. Martin, and P. R. Wild, “On key assignment for

hierarchical access control,” in CSFW, 2006.

[17] S. De Capitani di Vimercati, S. Foresti, S. Jajodia, G. Livraga, S. Para-
boschi, and P. Samarati, “Enforcing dynamic write privileges in data
outsourcing,” Computers & Security, vol. 39, 2013.

[18] S. De Capitani di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and
P. Samarati, “Over-encryption: Management of access control evolution
on outsourced data,” in VLDB, 2007.

[19] S. De Capitani di Vimercati, S. Foresti, S. Jajodia, S. Paraboschi, and
P. Samarati, “Encryption policies for regulating access to outsourced
data,” TODS, vol. 35, no. 2, 2010.

[20] D. Drummond, “A new approach to China,” Jan. 2010, http://googleblog.

blogspot.com/2010/01/new-approach-to-china.html.

[21] C. M. Ellison, B. Frantz, B. Lampson, R. Rivest, B. Thomas, and
T. Ylonen, “SPKI certiﬁcate theory,” IETF RFC 2693, Sep. 1999,
http://www.ietf.org/rfc/rfc2693.txt.

[22] A. Ene, W. Horne, N. Milosavljevic, P. Rao, R. Schreiber, and R. E.
Tarjan, “Fast exact and heuristic methods for role minimization problems,”
in SACMAT, 2008.

[23] A. L. Ferrara, G. Fuchsbauer, B. Liu, and B. Warinschi, “Policy privacy

in cryptographic access control,” in CSF, 2015.

[24] A. L. Ferrara, G. Fuchsbauer, and B. Warinschi, “Cryptographically

enforced RBAC,” in CSF, 2013.

[25] S. D. Galbraith, K. G. Paterson, and N. P. Smart, “Pairings for

cryptographers,” Discrete Appl. Math., vol. 156, no. 16, 2008.

[26] W. C. Garrison III, A. J. Lee, and T. L. Hinrichs, “An actor-based,
application-aware access control evaluation framework,” in SACMAT,
2014.

[27] W. C. Garrison III, Y. Qiao, and A. J. Lee, “On the suitability of
dissemination-centric access control systems for group-centric sharing,”
in CODASPY, 2014.

[28] W. C. Garrison III, A. Shull, S. Myers, and A. J. Lee, “On the practicality
of cryptographically enforcing dynamic access control policies in the
cloud (extended version),” Computing Research Repository, Tech. Rep.
arXiv:1602.09069, Feb. 2016.

[29] C. Gentry and A. Silverberg, “Hierarchical ID-based cryptography,” in

ASIACRYPT, 2002.

[30] V. Goyal, A. Jain, O. Pandey, and A. Sahai, “Bounded ciphertext policy

attribute based encryption,” in ICALP, 2008.

[31] V. Goyal, O. Pandey, A. Sahai, and B. Waters, “Attribute-based encryption

for ﬁne-grained access control of encrypted data,” in CCS, 2006.

[32] M. Green and G. Ateniese, “Identity-based proxy re-encryption,” in

ACNS, 2007.

[33] M. Green, S. Hohenberger, and B. Waters, “Outsourcing the decryption

of abe ciphertexts,” in USENIX Security, 2011.

834834

[34] E. Gudes, “The Design of a Cryptography Based Secure File System,”

IEEE Transactions on Software Engineering, vol. 6, no. 5, 1980.

[35] D. Hardt, “The OAuth 2.0 authorization framework,” IETF RFC 6749,

Oct. 2012, https://tools.ietf.org/html/rfc6749.

[36] T. L. Hinrichs, D. Martinoia, W. C. Garrison III, A. J. Lee, A. Panebianco,
and L. Zuck, “Application-sensitive access control evaluation using
parameterized expressiveness,” in CSF, 2013.

[37] J. Horwitz and B. Lynn, “Toward hierarchical identity-based encryption,”

in EUROCRYPT, 2002.

[38] L. Ibraimi, “Cryptographically enforced distributed data access control,”

Ph.D. dissertation, University of Twente, 2011.

[39] “Intel software guard extensions programming references,” Intel, Tech.

Rep. 329298–002, Oct. 2014.

[40] X. Jin, R. Krishnan, and R. S. Sandhu, “A uniﬁed attribute-based access

control model covering DAC, MAC and RBAC,” in DDBSec, 2012.

[41] J. Katz and Y. Lindell, Introduction to Modern Cryptography, 2nd ed.

Chapman & Hall/CRC, 2014.

[42] J. Katz, A. Sahai, and B. Waters, “Predicate encryption supporting
disjunctions, polynomial equations, and inner products,” in EUROCRYPT,
2008.

[43] R. Krishnan, J. Niu, R. S. Sandhu, and W. H. Winsborough, “Group-
centric secure information-sharing models for isolated groups,” TISSEC,
vol. 14, no. 3, 2011.

[44] A. Lewko and B. Waters, “New techniques for dual system encryption

and fully secure hibe with short ciphertexts,” in TCC, 2010.

[45] N. Li, J. C. Mitchell, and W. H. Winsborough, “Design of a role-based
trust-management framework,” in IEEE Symposium on Security and
Privacy, 2002.

[46] B. Libert and D. Vergnaud, “Adaptive-id secure revocable identity-based

encryption,” in CT-RSA, 2009.

[47] F. McKeen, I. Alexandrovich, A. Berenzon, C. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. Savaganokar, “Innovative instructions and software
model for isolated execution,” in HASP, 2013.

[48] I. Molloy, H. Chen, T. Li, Q. Wang, N. Li, E. Bertino, S. B. Calo, and

J. Lobo, “Mining roles with semantic meanings,” in SACMAT, 2008.

[49] S. M¨uller and S. Katzenbeisser, “Hiding the policy in cryptographic

access control,” in STM, 2011.

[50] D. Nali, C. M. Adams, and A. Miri, “Using mediated identity-based
cryptography to support role-based access control,” in Information
Security, 7th International Conference, ISC 2004, 2004.

[51] “Operation Aurora,” Jun. 2015, https://en.wikipedia.org/wiki/Operation

Aurora.

[52] R. Ostrovsky, A. Sahai, and B. Waters, “Attribute-based encryption with

non-monotonic access structures,” in CCS, 2007.

[53] S. Park, K. Lee, and D. Lee, “New constructions of revocable identity-

based encryption from multilinear maps,” TIFS, 2015.

[54] K. G. Paterson and J. C. N. Schuldt, “Efﬁcient identity-based signatures

secure in the standard model,” in ACISP, 2006.

[55] M. Pirretti, P. Traynor, P. McDaniel, and B. Waters, “Secure attribute-

based systems,” in CCS, ser. CCS ’06. ACM, 2006, pp. 99–112.

[56] T. Ring, “Cloud computing hit by celebgate,” http://www.scmagazineuk.

com/cloud-computing-hit-by-celebgate/article/370815/, 2015.

[57] A. Sahai and H. Seyalioglu, “Worry-free encryption: functional encryption

with public keys,” in CCS, 2010.

[58] A. Sahai, H. Seyalioglu, and B. Waters, “Dynamic credentials and
ciphertext delegation for attribute-based encryption,” in CRYPTO, 2012.
[59] A. Sahai and B. Waters, “Fuzzy identity-based encryption,” in EURO-

CRYPT, 2005.

[60] J. H. Saltzer and M. D. Schroeder, “The protection of information in

computer systems,” Proceedings of the IEEE, vol. 63, no. 9, 1975.

[61] R. S. Sandhu, “Rationale for the RBAC96 family of access control

models,” in ACM Workshop on RBAC, 1995.

[62] J. H. Seo and K. Emura, “Revocable identity-based encryption revisited:

Security model and construction,” in PKC, 2013.

[63] S. Sinclair, S. W. Smith, S. Trudeau, M. E. Johnson, and A. Portera,
“Information risk in ﬁnancial institutions: Field study and research
roadmap,” in FinanceCom, 2007.

[64] J. G. Steiner, B. C. Neuman, and J. I. Schiller, “Kerberos: An authentica-
tion service for open network systems,” in USENIX Winter Conference,
1988.

[65] S. D. Stoller, P. Yang, C. R. Ramakrishnan, and M. I. Gofman, “Efﬁcient
policy analysis for administrative role based access control,” in CCS,
2007.

APPENDIX A

IBE/IBS PROOF

We ﬁrst provide a formal deﬁnition of an access control
system that uses IBE, IBS, and symmetric-key cryptography,
and then show it implements RBAC0, proving Theorem 1. The
proof of Theorem 2 is analogous, replacing IBE/IBS with
public-key equivalents.

A. Our IBE/IBS System

1) Preliminaries:
• We use m as the symmetric-key size, which is also the

size of the IBE and IBS message spaces.

• For signatures, we assume that hash-and-sign is used,
where the message is hashed with a collision-resistant
hash function and then signed using IBS.

2) States:
• USERS: a list of user names
• ROLES: a list of (r, vr) pairs containing role names and

version numbers

version numbers

• FILES: a list of (f n, vf n) pairs containing ﬁle names and

• F S: the set of tuples (RK, FK, or F) stored on the ﬁlestore
3) Request:
• u, p for whether user u has permission p
4) Queries:
• RK returns whether a user is in a role. Note that we do
not verify the validity of the encrypted keys because the
encryption is performed by the trusted admin, and the
signature ensures integrity.

RK(u, r) (cid:2) ∃(c, sig).((cid:2)RK, u, (r, vr), c, sig(cid:3) ∈ F S
SU ((cid:2)RK, u, (r, vr), c(cid:3)))

∧ sig = SignIBS

Checking RK requires one instance of VerIBS.

• F K returns whether a role has a permission for the latest
version of a ﬁle. As is the case RK, we do not need to
verify the validity of the encrypted key.

F K(r,(cid:2)f n, op(cid:3)) (cid:2) ∃(c, sig).(

(cid:2)FK, r,(cid:2)f n, op(cid:3), vf n, c, SU, sig(cid:3) ∈ F

∧ sig = SignIBS

SU ((cid:2)FK, r,(cid:2)f n, op(cid:3), vr, c, SU(cid:3)))

Checking F K requires one instance of VerIBS.
• Role(r) (cid:2) ∃v.((r, v) ∈ ROLES)
• auth returns whether a user has a permission.
auth(u, p) (cid:2) ∃r.(RK(u, r) ∧ F K(r, p))

Checking auth requires two instances of VerIBS.

5) Labels: The labels used in this system are simply the

operations in Fig. 2.

835835

B. Implementing RBAC0 using IBE/IBS

Because our IBE/IBS system uses versioning to handle
revocation, assigning and then revoking a user/permission will
not result in the same state as if the user/permission were never
assigned. However, it will result in the same set of users having
access to the latest versions of the same ﬁles, so the results of
authorization requests will not be changed. We consider such
states, which are equal except for differences in versioning, to
be congruent, and represent this with the ∼
= relation. We also
say that state mappings σ and σ
(x)
for all states x.
The deﬁnition of correctness from [36] requires that α
preserves σ, which means the following: For all n ∈ N, states
x0, and labels (cid:4)1, . . . , (cid:4)n, let y0 = σ(x0), xi = next(xi−1, (cid:4)i)
for i = 1, . . . , n, and yi = terminal(yi−1, α(yi−1, (cid:4)i)) for
i = 1, . . . , n. Then α preserves σ means that yi = σ(xi) for
all i = 1, . . . , n.

(cid:2) are congruent if σ(x)

∼
= σ

(cid:2)

We cannot achieve this in our system because of version
numbers, e.g., if (cid:4)1 assigns a user to a role and then (cid:4)2 revokes
that user from the role, x2 will be equal to x0 (and thus σ(x2)
will be equal to σ(x0)), but y2 will have version numbers
∼
different from y0. Thus instead we will show that yi
= σ(xi)
for all i = 1, . . . , n, which we deﬁne as α congruence-
preserves σ.

In [27], α preserves σ is deﬁned as
(cid:3)
σ(x), α

(cid:3)
(cid:4)
x, (cid:4)
next

= terminal

(cid:5)(cid:6)

σ

(cid:5)(cid:6)

(cid:4)
σ(x), (cid:4)

(1)

for every state x and label (cid:4). This implies the deﬁnition from
[36] by the following inductive argument:

Proof: By deﬁnition, y0 = σ(x0). Now assume that yi =

σ(xi). Then by Eq. (1),

yi+1 = terminal

yi, (cid:4)i+1

(cid:4)

(cid:3)
(cid:3)
yi, α
σ(xi), α

(cid:4)

(cid:5)(cid:6)

(cid:5)(cid:6)

(cid:3)
= terminal
(cid:4)
xi, (cid:4)i+1
next

= σ

(cid:5)(cid:6)

σ(xi), (cid:4)i+1
(cid:5)
.

(cid:4)
xi+1

= σ

However, an analogous proof with congruence instead of
equality does not work because we cannot substitute σ(xi) for
yi if they are not equal. Thus

(cid:3)

(cid:4)
x, (cid:4)
next

(cid:5)(cid:6) ∼

σ

(cid:3)

(cid:5)(cid:6)

(cid:4)
σ(x), (cid:4)

= terminal

σ(x), α

(cid:2)

σ

(cid:5)(cid:6) ∼

(cid:3)
(cid:4)
next

does not imply that α congruence-preserves σ. This may occur,
for instance, if one of the IBE/IBS labels does not work
correctly when multiple versions of a ﬁle are present.
(cid:5)(cid:6)

Instead we will show that

= terminal

(2)
σ
(x), (cid:4)
(cid:2) congruent to σ.
for all states x, labels (cid:4), and state mappings σ
This proves that α congruence-preserves σ by the following
inductive argument:
∼
=
∗ be the state mapping equivalent to σ except

∼
= σ(x0). Now assume that yi

Proof: By deﬁnition, y0

σ(xi). Let σ

(cid:3)
σ

(x), α

x, (cid:4)

(cid:4)

(cid:2)

(cid:2)

∗

that σ
∗
(xi)
σ

∗

(x) = σ(x) for all x (cid:15)= xi and
(cid:4)

yi+1 = terminal

(cid:5)(cid:6)

(xi) = yi. Since σ
∼
= σ(xi), σ

∗ ∼
= σ. Thus by Eq. (2),
(cid:3)
(cid:3)
yi, α
(cid:3)
σ
= terminal
(cid:4)
∼
xi, (cid:4)i+1
next
= σ

yi, (cid:4)i+1
∗

(xi), α

(cid:5)(cid:6)

∗(cid:4)

= σ

(cid:4)

σ

∗

∗

(xi), (cid:4)i+1

(cid:5)(cid:6)
(cid:5) ∼

(cid:4)
xi+1

(cid:5)
.

xi+1

= σ

If we have an implementation (cid:2)α, σ, π(cid:3) such that α
congruence-preserves σ and σ preserves π, we say that the
implementation is congruence-correct.
Theorem 3: There exists an implementation (cid:2)α, σ, π(cid:3) of

RBAC0 using IBE and IBS where:

• α congruence-preserves σ and preserves safety
• σ preserves π
• π is AC-preserving

Thus there exists a congruence-correct, AC-preserving, safe
implementation of RBAC0 using IBE and IBS.

Proof:

The notation and conventions used here are listed in

and su ←

Section IV-C2.
1) State mapping σ:
For each u ∈ U ∪ {SU}:
• Add u to USERS.
• Generate ku ← KeyGenIBE(u)
KeyGenIBS(u).

Let F S = {}.
Let ROLES and FILES be blank.
Run MSKGenIBE(m) to get IBE system parameters and
master secret key msk.
Run MSKGenIBS(m) to get IBS system parameters and
(cid:2).
master secret key msk
For each R(r) ∈ M:

• Add (r, 1) to ROLES.
• Let

(cid:3)
F S
KeyGenIBE
SU (cid:3)}.

EncIBE
SU
SignIBS

=

F S ∪ {(cid:2)RK,

SU,
msk ((r, 1)), KeyGenIBS
msk(cid:2) ((r, 1))

(cid:6)
(r, 1),
,

For each P (f n) ∈ M where f n is the name of ﬁle f:

k

SU (cid:3)}.

• Add (f n, 1) to FILES.
• Produce a symmetric key k = GenSym(m).
• Let F S = F S ∪{(cid:2)F, f n, 1, EncSym
(f ), SU, SignIBS
• Let F S = F S ∪ {(cid:2)FK, SU, (cid:2)f n, RW(cid:3), 1, EncIBE
SU, SignIBS
• Find (cid:2)RK, SU, (r, 1), c, sig(cid:3) ∈ F S.
• Let
SU (cid:3)}.

F S ∪ {(cid:2)RK,
(cid:6)
, SignIBS

For each U R(u, r) ∈ M:

(cid:3)
=
F S
DecIBE
kSU (c)
For each P A(r,(cid:2)f n, op(cid:3)):

EncIBE

SU,

u

SU (cid:3)}.
SU (k),

(r, 1),

• Find (cid:2)FK, SU,(cid:2)f n, RW(cid:3), 1, c, SU, sig(cid:3).
• Let F S = F S ∪ {(cid:2)FK,
(r, 1),
SU (cid:3)}.
EncIBE
(r,1)

(cid:6)
, SU, SignIBS

(cid:3)
DecIBE

kSU (c)

output(F S, ROLES, FILES)

(cid:2)f n, op(cid:3),

1,

836836

2) Query mapping π:

πU R(u,r)(T ) = RK(u, r) ∈ T
πP A(r,p)(T ) = F K(r, p) ∈ T
πR(r)(T ) = Role(r) ∈ T

πauth(u,p)(T ) = auth(u, p) ∈ T

The query mapping π is AC-preserving because it maps
auth(u, p) to TRUE for theory T if and only if T contains
auth(u, p).

3) σ preserves π: This means that for every RBAC0 state
x, T h(x) = π(T h(σ(x))). To prove this, we show that for
each RBAC0 state x and query q, x (cid:17) q if and only if
πq(T h(σ(x))) = TRUE.

If x

T h(x), meaning

T h(x), meaning that

We consider each type of query separately.
If x (cid:17) U R(u, r) then U R(u, r) ∈ T h(x),
• UR:
in x, (cid:2)u, r(cid:3) ∈ U R. Thus in σ(x),
meaning that
vr = 1 and ∃(c, sig).((cid:2)RK, u, (r, 1), c, sig(cid:3) ∈ F S ∧
SU ((cid:2)RK, u, (r, vr), c(cid:3))). Hence RK(u, r) ∈
sig = SignIBS
T h(σ(x)), so πU R(u,r)(T h(σ(x))) = TRUE.
If x (cid:2) U R(u, r) then U R(u, r) /∈ T h(x), mean-
in x, (cid:2)u, r(cid:3) /∈ U R. Thus in σ(x), vr =
ing that
1 and (cid:3)(c, sig).((cid:2)RK, u, (r, 1), c, sig(cid:3) ∈ F S). Hence
/∈ T h(σ(x)), so πU R(u,r)(T h(σ(x))) =
RK(u, r)
FALSE.
(cid:17)
P A(r, p) with p = (cid:2)f n, op(cid:3),
• PA:
∈
in x,
then P A(r, p)
(cid:2)r, p(cid:3) ∈ P A. Thus
in σ(x), vf n = 1 and
∃(c, sig).((cid:2)FK, r,(cid:2)f n, op(cid:3), vf n, c, SU, sig(cid:3) ∈ F S ∧
SU ((cid:2)FK, r,(cid:2)f n, op(cid:3), vf n, c, SU(cid:3))). Hence
sig = SignIBS
F K(r, p) ∈ T h(σ(x)), so πP A(r,p)(T h(σ(x))) = TRUE.
P A(r, p) with p = (cid:2)f n, op(cid:3),
(cid:2)
then
If x
/∈
x,
in
P A(r, p)
(cid:2)r, p(cid:3)
/∈ P A. Thus
in σ(x), vf n = 1 and
(cid:3)(c, sig).((cid:2)FK, r,(cid:2)f n, op(cid:3), vf n, c, SU, sig(cid:3)
F S).
Hence F K(r, p) /∈ T h(σ(x)), so πP A(r,p)(T h(σ(x))) =
FALSE.
• R: If x (cid:17) R(r) then R(r) ∈ T h(x), meaning that in x,
r ∈ R. Thus in σ(x), (r, 1) ∈ ROLES. Hence Role(r) ∈
T h(σ(x)), so πR(r)(T h(σ(x))) = TRUE.
If x (cid:2) R(r), then R(r) /∈ T h(x), meaning that in x, r /∈
R. Thus in σ(x), (cid:3)v.((r, v) ∈ ROLES). Hence Role(r) /∈
T h(σ(x)), so πR(r)(T h(σ(x))) = FALSE.
• auth: If x (cid:17) auth(u, p) then auth(u, p) ∈ T h(x), so
there exists r such that U R(u, r) ∈ T h(x) ∧ P A(r, p) ∈
T h(x). Since σ preserves π for U R and P A queries,
RK(u, r) ∈ T h(σ(x)) ∧ F K(r, p) ∈ T h(σ(x)). Hence
auth(u, p) ∈ T h(σ(x)), so πauth(u,p)(T h(σ(x))) =
TRUE.
/∈ T h(x), so
If x (cid:2) auth(u, p) then auth(u, p)
(cid:3)r.(U R(u, r) ∈ T h(x) ∧ P A(r, p) ∈ T h(x)). Since σ
preserves π for U R and P A queries, (cid:3)r.(RK(u, r) ∈
T h(σ(x))∧ F K(r, p) ∈ T h(σ(x))). Hence auth(u, p) /∈
T h(σ(x)), so πauth(u,p)(T h(σ(x))) = FALSE.

that
∈

4) Label mapping α: The label mapping α simply maps
any RBAC0 label, regardless of the state, to the IBE/IBS label

of the same name found in Fig. 2. The only difference is that
in IBE/IBS, addP takes as input a ﬁlename and ﬁle instead
of a permission and delP takes as input a ﬁlename instead of
a permission.

(cid:2)

5) α congruence-preserves σ: We consider each type of
(cid:2) be a state mapping congru-
RBAC0 label separately. We let σ
ent to σ and let x
= next(x, (cid:4)) be the result of executing label
(cid:4) in state x. While key generation and encryption algorithms
are normally randomized, for determining equality of states
we assume that they are deterministic.
= x∪U (u).

• addU: If (cid:4) is an instance of addU (u), then x

(cid:2)

(cid:5)
.

Thus

(cid:2)

(cid:2)

σ

(x

) = σ

(cid:5)

(cid:2)(cid:4)
x ∪ U (u)
(cid:5)
(cid:4)
(cid:4)
(x), addU (u)
σ
= next
(cid:2)

= σ

(cid:2)

(cid:2)

(cid:2)

(x) ∪ USERS(u)

(cid:2)

(cid:2)

(cid:2)

σ

σ

(x

) = σ

(x), α(σ

then x

= terminal

(x), (cid:4))
• delU: If (cid:4) is an instance of delU (u),
=
x \ (U (u) ∪ {U R(u, r) | U R(u, r) ∈ x}). Let T =
{(r, c, sig) | (cid:2)RK, u, (r, vr), c, sig(cid:3) ∈ F S} and T
= {r |
∃(c, sig).((r, c, sig) ∈ T )}. Let {r1, r2, . . . , rn} be the
(cid:2) in arbitrary order. Then
elements of T
(cid:5)
(cid:2)(cid:4)
x \ (U (u) ∪ {U R(u, r) | U R(u, r) ∈ x})
(cid:2)
(x) \ USERS(u)
(cid:2)
(cid:4)(cid:2)RK, u, (r, vr), c, sig(cid:3)(cid:5) | (r, c, sig) ∈ T
\ (cid:7)
= σ
(cid:4)
F S
∼
σ
= terminal
revokeU (u, r1) ◦ revokeU (u, r2)
◦ ··· ◦ revokeU (u, rn)
(cid:5)
(cid:4)
(cid:4)
(x), delU (u)
σ
= next
(cid:2)
σ

(x) \ USERS(u),

= terminal

(x), α(σ

(x), (cid:4))

(cid:5)
.

(cid:5)

(cid:2)

(cid:2)

(cid:2)

(cid:8)

• addR: If (cid:4) is an instance of addR(r), then x

(cid:2)

= x∪ R(r).

RK, SU, (r, 1),

Thus

(cid:2)

(cid:2)

σ

(x

) = σ

= σ

(cid:3)(cid:9)

(cid:5)

(cid:2)(cid:4)
x ∪ R(r)
(x) ∪ ROLES(r, 1) ∪ F S
(cid:2)

EncIBE
SU

(cid:3)
KeyGenIBE
(cid:6)
msk ((r, 1)),
, SignIBS
(cid:5)
SU
(cid:2)

(cid:4)
σ
= next

KeyGenIBS
msk(cid:2) ((r, 1))
(cid:4)
(x), addR(r)

(cid:2)

(cid:10)(cid:6)

(cid:2)

(cid:2)

σ

(x), (cid:4))

(x), α(σ

= terminal

(cid:5)
.
= x\(R(r)∪
• delR: If (cid:4) is an instance of delR(r), then x
{U R(u, r) | U R(u, r) ∈ x} ∪ {P A(r, p) | P A(r, p) ∈
x}). Let T = {(u, c, sig) | (cid:2)RK, u, (r, vr), c, sig(cid:3) ∈
F S} and F = {f n | ∃(op, vf n, cf n, sig).((cid:2)FK, (r, vr),
(cid:2)f n, op(cid:3), vf n, cf n, SU, sig(cid:3) ∈ F S)}. For each f n ∈ F ,
let Tf n = {(op
(cid:2)(cid:3), v,
cv, SU, sig(cid:3) ∈ F S}. Let {f n1, f n2, . . . , f nn} be the
elements of F in arbitrary order. Then
(cid:2)

(cid:2)(cid:4)
x \ (R(r) ∪ {U R(u, r) | U R(u, r) ∈ x}

, v, cv, sig) | (cid:2)FK, (r, vr), (cid:2)f n, op

) = σ

(x

σ

(cid:2)

(cid:2)

∪ {P A(r, p) | P A(r, p) ∈ x}(cid:5)

(cid:2)

F S

= σ

(cid:4)(cid:2)RK, u, (r, vr),
(cid:4)(cid:2)FK, (r, vr),
F S
f n ∈ F

(x) \ ROLES(r, vr) \ (cid:7)
(cid:8) \ (cid:7)
c, sig(cid:3)(cid:5) | (u, c, sig) ∈ T
(cid:2)(cid:3), v, cv, SU, sig(cid:3)(cid:5) | (cid:4)
(cid:2)f n, op
(cid:5)(cid:8)
, v, cv, sig) ∈ Tf n
∧ (op
(cid:2)
(cid:3)
∼
(cid:4)(cid:2)RK, u, (r, vr), c, sig(cid:3)(cid:5) | (u, c, sig) ∈ T
\ (cid:7)
σ
= terminal
(cid:4)

F S

(cid:4)

(cid:8)

(cid:2)

(x) \ ROLES(r, vr)
r,(cid:2)f n1, RW(cid:3)(cid:5) ◦ revokeP
r,(cid:2)f nn, RW(cid:3)(cid:5)(cid:6)
(cid:5)
(cid:2)

(cid:4)

(cid:2)

(cid:5)
.

(cid:4)
(x), delR(r)

= terminal

σ

(x), α(σ

(x), (cid:4))

revokeP
◦ ··· ◦ revokeP

(cid:4)
= next

(cid:2)

σ

r,(cid:2)f n2, RW(cid:3)(cid:5)

,

• addP: If (cid:4) is an instance of addP (p) with p = (cid:2)f n, op(cid:3)
= x ∪ P (p). Thus for
and f n the name of ﬁle f, then x
k ← GenSym(m),
(cid:2)
σ

(x

(cid:5)

(cid:2)

(cid:2)

(cid:2)(cid:4)
x ∪ P (p)
(cid:3)(cid:9)

) = σ
(x) ∪ FILES(f n, 1)

(cid:2)
= σ
∪ F S
(cid:2)f n, RW(cid:3), 1, EncIBE
(cid:4)
(x), addP (f n, f )

(cid:4)
= next

F, f n, 1, EncSym

σ

k

(cid:2)

(cid:5)

(cid:2)

(cid:2)

= terminal

σ

(x), α(σ

(x), (cid:4))

(cid:5)
.

(cid:10)(cid:6)

(f )

∪ F S

(cid:3)(cid:9)

FK, SU,
(cid:10)(cid:6)

SU (k), SU, SignIBS
SU

(cid:2)

(cid:2)

(cid:2)

(cid:2)(cid:3), v, c

• delP: If (cid:4) is an instance of delP (p) with p = (cid:2)f n, op(cid:3),
= x \ (P (p) ∪ {P A(r, p) | P A(r, p) ∈ x}).
then x
Let T = {(v, c) | (cid:2)F, f n, v, c(cid:3) ∈ F S} and T
=
, id, sig) | (cid:2)FK, r, (cid:2)f n, op
(cid:2), id, sig(cid:3) ∈
{(r, op
(cid:2)
(cid:2)
, v, c
F S}. Then
(cid:2)(cid:4)
x \ (P (p) ∪ {P A(r, p) | P A(r, p) ∈ x})
(cid:2)
) = σ
(x
σ
(x) \ FILES(f n, vf n)
(cid:2)
\ (cid:7)
(cid:4)(cid:2)F, f n, v, c(cid:3)(cid:5) | (v, c) ∈ T
(cid:4)(cid:2)FK, r,(cid:2)f n, op
\ (cid:7)
F S
(cid:8)
F S
, id, sig) ∈ T
(cid:2)
(cid:4)
v, c
(cid:2)
σ
= next

, id, sig(cid:3)(cid:5) | (r, op

(cid:2)(cid:3), v, c
(cid:5)

= σ

(cid:8)

(cid:5)

(cid:2)

(cid:2)

,

(cid:4)
(x), delP (f n)
(cid:2)
σ

(x), α(σ

(cid:2)

(x), (cid:4))

(cid:5)
.

= terminal

• assignU: If (cid:4) is an instance of assignU (u, r), then x
=
x ∪ U R(u, r). Thus for (cid:2)RK, SU, (r, 1), c, sig(cid:3) ∈ F S in
(cid:2)
(x),
σ

(cid:2)

(cid:2)

(cid:2)

σ

(x

) = σ

= σ

(cid:5)

(cid:2)(cid:4)
x ∪ U R(u, r)
(cid:3)(cid:9)
(x) ∪ F S
(cid:2)
(cid:3)
DecIBE
(cid:4)
(x), assignU (u, r)

kSU (c)

(cid:6)

u

RK, SU, (r, 1),

(cid:5)

EncIBE
(cid:2)

(cid:4)
= next

σ

= terminal

σ

(x), α(σ

(x), (cid:4))

(cid:2)

(cid:2)

(cid:5)
.

, SignIBS
SU

(cid:10)(cid:6)

• revokeU: If (cid:4) is an instance of revokeU ser(u, r), then
= x\U R(u, r). Let k(r,vr+1) ← KeyGenIBE((r,vr +
(cid:2)
x
1)) and s(r,vr+1) ← KeyGenIBS((r,vr + 1)). Let T =
{(u
, cu(cid:2) , sig) | (cid:2)RK, u
(cid:2), (r, vr), cu(cid:2), sig(cid:3) ∈ F S} and
(cid:2)

837837

FK, (r, vr),(cid:2)f n, op(cid:3), v,

(cid:3)(cid:9)

(cid:11)
(cid:3)
F S
DecIBE
(cid:10)(cid:6)
kSU (cv)
| (v, cv) ∈ T

= σ

(cid:2)

(x) ∪
EncIBE
(r,vr)

SignIBS
(cid:4)
SU
(cid:2)
= next

σ

(cid:4)
(x), assignP (r, p)

(cid:2)

(cid:2)

= terminal

σ

(x), α(σ

(x), (cid:4))

(cid:6)
(cid:12)
, SU,

(cid:5)

(cid:5)
.

(cid:2)

= x \ P A(r, p).

• revokeP: If (cid:4) is an instance of revokeP (r, p) with p =
(cid:2)f n, op(cid:3), then x
|
– If op = Write,

then let T = {(v, cv, sig)
(cid:2)FK, (r, vr),(cid:2)f n, RW(cid:3), v, cv, SU, sig(cid:3) ∈ F S}. Then
(cid:5)
(cid:2)
(cid:4)(cid:2)FK, (r, vr),(cid:2)f n, RW(cid:3), v, cv,
σ
FK, (r, vr),(cid:2)f n, Read(cid:3), v, cv, SU,
(cid:10)(cid:6)

(cid:2)(cid:4)
x \ P A(r, p)
(x) \ (cid:7)
(cid:2)
SU, sig(cid:3)(cid:5) | (v, cv, sig) ∈ T
F S
(cid:3)(cid:9)
(cid:11)

) = σ

= σ

F S

(cid:12)

∪

(cid:8)

(x

(cid:2)

(cid:4)
= next

SignIBS
SU
(cid:2)
(cid:4)
(x), assignP (r, p)

| (v, cv, sig) ∈ T
(cid:5)
.

(x), α(σ

= terminal

σ

(cid:5)

σ

(cid:2)

(cid:2)
(x), (cid:4))
(cid:2) ← GenSym, T =
(cid:2)(cid:3), v, cv, SU,
id (cid:15)= r ∧
(cid:2)(cid:3), vf n, cid, SU, sig(cid:3) ∈

– If op = Read,

then let k

, v, cv, sig) | (cid:2)FK, (r, vr), (cid:2)f n, op
) |

= {(id, op
(cid:2)

(cid:2)

(cid:2)

(cid:2)

{(op
sig(cid:3) ∈ F S}, and T
∃(cid, sig).((cid:2)FK, id, (cid:2)f n, op
F S)}. Then
(cid:2)(cid:4)
(cid:5)
x \ P A(r, p)
(cid:2)
(x) \ (cid:7)
) = σ
σ
(cid:2)
F S
= σ
SU, sig(cid:3)) | (op
(cid:2)
(x) \ (cid:7)
∼
(cid:2)
SU, sig(cid:3)(cid:5) | (op
F S
= σ
(cid:3)(cid:9)
(cid:11)

(x

∪

F S

(cid:2)(cid:3), v, cv,

(cid:4)(cid:2)FK, (r, vr),(cid:2)f n, op
(cid:8)
, v, cv, sig) ∈ T
(cid:4)(cid:2)FK, (r, vr),(cid:2)f n, op
(cid:2)(cid:3), v, cv,
(cid:8)
, v, cv, sig) ∈ T
(cid:2)(cid:3), vf n + 1,
FK, id,(cid:2)f n, op
(cid:10)(cid:6)

(cid:2)

(cid:2)

id

(k

| (id, op
(cid:2)
EncIBE
∪ FILES(f n, vf n + 1) \ FILES(f n, vf n)
(cid:4)
σ
= next

), SU, SignIBS
SU
(cid:5)

(cid:4)
(x), assignP (r, p)

(cid:2)

(cid:2)

(cid:2)

= terminal

σ

(x), α(σ

(x), (cid:4))

(cid:5)
.

(cid:12)

) ∈ T

6) Safety: The label mapping α is safe by inspection—for
any RBAC0 state x and label (cid:4), the IBE/IBS label α(σ(x), (cid:4))
never revokes or grants authorizations except the images of
those that are revoked or granted by (cid:4).

= σ
∼
= σ

F = {f n | ∃(op, vf n, cf n, sig).((cid:2)FK, (r, vr), (cid:2)f n, op(cid:3),
vf n, cf n, SU, sig(cid:3) ∈ F S). For each f n ∈ F , let
kf n ← GenSym, Tf n = {(op
(cid:2)FK,
(cid:2)
, v, cv, sig)
(r, vr), (cid:2)f n, op
(cid:2)
f n =
{id, op
(cid:2)(cid:3), vf n, cid, SU,
, cid, sig) | (cid:2)FK, id, (cid:2)f n, op
sig(cid:3) ∈ F S}. Then
(cid:2)
(x
σ

|
(cid:2)(cid:3), v, cv, SU, sig(cid:3) ∈ F S} and T

) = σ

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:8)

(cid:8)

, (r, vr), cu(cid:2) ,

(cid:2)(cid:4)
(cid:5)
x \ U R(u, r)
(cid:4)(cid:2)RK, u, (r, vr), cu,
(x) \ (cid:7)
sig(cid:3)(cid:5) | (u, cu, sig) ∈ T
F S
(cid:4)(cid:2)RK, u
(x) \ (cid:7)
(cid:2)
sig(cid:3)(cid:5) | (u
F S
, cu(cid:2) , sig) ∈ T
(cid:2)
(cid:3)(cid:9)
(cid:11)
(cid:2)
RK, u
, (r, vr), EncIBE
(cid:10)(cid:6)
| (u
, cu(cid:2) , sig) ∈ T ∧ u
(cid:2)
(cid:2)(cid:3), v, cv,
, v, cv, sig) ∈ Tf n
(cid:2)
FK, (r, vr + 1),(cid:2)f n, op
(cid:6)

∪
\ (cid:7)
(cid:4)(cid:2)FK, (r, vr),(cid:2)f n, op
SU, sig(cid:3)(cid:5) | f n ∈ F ∧ (op
F S
(cid:3)(cid:9)
(cid:11)

SignIBS
SU

(cid:2)(cid:3), v,

F S

F S

∪

u(cid:2)

(cid:8)

(cid:4)
(cid:12)
k(r,vr+1), s(r,vr+1)
(cid:2) (cid:15)= u

EncIBE

(r,vr+1)

(cid:10)(cid:6)

SignIBS
(cid:3)(cid:9)
(cid:11)
SU

(cid:3)
DecIBE
k(r,vr ) (cv)
| f n ∈ F ∧ (op
(cid:2)

(cid:12)

, SU,
, v, cv, sig) ∈ Tf n
(cid:2)
(cid:12)
p),
(cid:2)
f n

(cid:2)(cid:3), vf n + 1, EncIBE
(k
| f n ∈ F ∧ (id, cid, sig) ∈ T

id

F S

(cid:10)(cid:6)

FK, id,(cid:2)f n, op

∪
SU, SignIBS
∪ (cid:7)
SU
FILES(f n, vf n + 1) | f n ∈ F
\ (cid:7)
FILES(f n, vf n) | f n ∈ F
∪ ROLES(r, vr + 1) \ ROLES(r, vr)
(cid:5)
(cid:4)
σ
= next

(cid:4)
(x), revokeU (u, r)

(cid:8)

(cid:8)

(cid:2)

(cid:2)

(cid:2)

(cid:5)
.

(cid:2)

(x), (cid:4))

(x), α(σ
= terminal
σ
• assignP: If (cid:4) is an instance of assignP (r, p) with p =
= x ∪ P A(r, p). We have two cases
(cid:2)f n, op(cid:3), then x
where assignP (r, p) has an effect on x:
– If op = RW and there exists (cid:2)FK, (r, vr), (cid:2)f n, Read(cid:3),
then let T = {(v, cv, sig)
vf n, c, SU, sig(cid:3),
|
(cid:2)FK, (r, vr),(cid:2)f n, Read(cid:3), v, cv, SU, sig(cid:3) ∈ F S}. Then
(cid:2)
(cid:4)(cid:2)FK, (r, vr),(cid:2)f n, Read(cid:3), v, cv,
σ
FK, (r, vr),(cid:2)f n, RW(cid:3), v, cv, SU,
(cid:10)(cid:6)

(cid:2)(cid:4)
x ∪ P A(r, p)
(x) \ (cid:7)
(cid:2)
SU, sig(cid:3)(cid:5) | (v, cv, sig) ∈ T
(cid:3)(cid:9)
∪ (cid:7)

) = σ

= σ

F S

F S

(cid:8)

(x

(cid:5)

(cid:2)

(cid:8)

(cid:4)
σ
= next

SignIBS
SU
(cid:2)
(cid:4)
(x), assignP (r, p)

| (v, cv, sig) ∈ T
(cid:5)
.

(x), (cid:4))

(cid:5)

(cid:2)

(cid:2)
(cid:2)FK,

– If

there does not exist

(x), α(σ
= terminal
σ
(cid:2)(cid:3),
(cid:2)f n, op
vf n, c, SU, sig(cid:3),
then let T = {(v, cv)
|
∃(id, sig).((cid:2)FK, SU,(cid:2)f n, RW(cid:3), v, cv, id, sig(cid:3) ∈ F S)}.
Then
(cid:2)

(cid:2)(cid:4)
(cid:5)
x ∪ P A(r, p)

(r, vr),

) = σ

(x

σ

(cid:2)

(cid:5)

,

838838

