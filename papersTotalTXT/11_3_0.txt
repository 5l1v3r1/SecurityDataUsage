Verito: A Practical System for Transparency and Accountability in Virtual

Economies

Raghav Bhaskar, Saikat Guha, Srivatsan Laxman, Prasad Naldurg

Microsoft Research India, Bangalore, India

{rbhaskar,saikat,slaxman,prasadn}@microsoft.com

Abstract

Purchase of virtual goods and services is now a major
source of revenue for developers on platforms like Face-
book, Xbox, and iOS. These virtual economies are typi-
cally based on users maintaining a stored-value account
of virtual-currency (purchased with real-currency) with the
platform. While the model is similar to that of a bank,
these economies lack transparency and regulatory over-
sight that protect a consumer’s ﬁnancial interests. We
propose Verito, a practical solution that provides trans-
parency and accountability in this context. We combine
state-of-the-art cryptographic constructs in novel ways to
design a system that provides four desirable properties, viz.,
transparency (money-in equals money-out), fairness (users
treated equally), non-repudiation (users’ virtual money is
safe), and scalability (low processing and storage costs).
Our design also accommodates nuances such as support for
multiple-currencies, and defense against arbitrage, while
addressing scalability bottlenecks. We present an exper-
imental evaluation based on our implementation of Ver-
ito and study its performance characteristics. Overall, we
show that it is possible to protect consumer interests in vir-
tual economies in a practical manner, without relying only
on regulation.

1

Introduction

Virtual economies, where users buy virtual goods and
services, have seen phenomenal growth in recent years.
Facebook transacts over 1.5 billion dollars in in-game pur-
chases for social games like Farmville and Maﬁa Wars, ac-
counting for 15% of its net 2011 revenue [5]; the market
has averaged around 300% year-on-year growth over the
last three years as reported by Facebook [5]. In-app pur-
chases netted Apple, Google and Xbox over 2.1 billion dol-
lars in 2011 [6]. Massively-multiplayer online games such
as Second Life, World of Warcraft, and the Sims Online
have thriving economies, including black-markets for users

to convert between real and virtual currency for games that
prohibit this practice [2, 14].

These economies typically use a virtual currency rather
than a real currency for individual transactions. This is be-
cause there are a large number of small-valued transactions
(sometimes of just a few cents). Using real currency for in-
dividual transactions is uneconomical due to regulatory and
compliance obligations for ﬁnancial transactions. As a re-
sult, most economies allow the user to purchase virtual cur-
rency in bulk (using real currency); merchants are similarly
paid in bulk. Examples of these virtual currencies include
Facebook credits, Linden dollars (Second Life), and Xbox
points.

Virtual economies are not regulated. Facebook, for in-
stance, declared “in July 2010, we seeded users with free
seeded credits [...] in order to drive user awareness and ed-
ucation around credits. These credits are zero-value, and
developers do not realize revenue from them when spent by
users.” [4]. In essence, Facebook unilaterally devalued its
currency overnight. Unfortunately for developers, an un-
intentional consequence was that the effective conversion
rate from Facebook credits to dollars became unpredictable.
Since credits are opaque to the developer, for a batch of 100
credits, the developer could be paid anywhere between the
fair value of 0 and 100 credits; the developer would have no
way to verify if he was paid correctly. Facebook reserves
for itself the right to seed these zero-valued credits at any
time and for any reason [4].

The global reach of these virtual economies introduces
additional complications. Xbox points were, for instance,
priced similarly in all currencies when they were ﬁrst in-
troduced (around $1 for 80 points). However, due to ﬂuc-
tuating currency exchange rates, the current value of these
points varies considerably between regions. This can create
an arbitrage scenario where a merchant can turn a proﬁt by
buying points in one currency and encashing it in another.
Currently, points purchased in one currency cannot be spent
in a different geography. Further, trading points between
user accounts is also not supported.

Our main contribution with Verito is a technical solution

1

that provides transparency in accounting in such economies
without relying on external audits or trusted third parties.
Applied to Facebook, Verito would allow game developers
to verify that they were paid correctly, while preserving user
privacy. Applied to Xbox, Verito would allow promotional
points, with ﬂexible support for multiple currencies and user
relocation, while preventing arbitrage.

We identify and deﬁne the accountable virtual economy
problem as having the following properties. First, is trans-
parency, i.e., money entering the economy (e.g., through
user purchase of credits) should equal money exiting the
economy (either as payments to merchants, or as commis-
sions and fees charged by the platform). Second, is fair-
ness, i.e., the merchants should not be able to distinguish
between credits acquired at different rates and treat users
differently. However, the platform should be able to distin-
guish between credits of different values (e.g., zero-value
vs. non-zero value for Facebook, different currencies for
Xbox points, etc.). Third, is non-repudiation of transac-
tions to protect users, merchants and the platform. Fourth,
is scalability of processing, storage, and network costs. We
formalize these properties in Section 2.

Verito combines existing cryptographic constructs in a
novel way. At a high-level, we use homomorphic com-
mitments [32] to create an audit trail for virtual transac-
tions. A na¨ıve application of commitments, however, may
compromise fairness when the commitments are eventually
opened. A second problem is the storage requirements for
non-repudiation (e.g., to prevent a user from spending a
credit multiple times), which would normally require a large
database. We address the ﬁrst issue through aggregate com-
mitments, and the second by combining commitments with
dynamic accumulators [17]. While accumulators solve the
storage issue, a na¨ıve application of accumulators would in-
cur high network and processing overheads. Our construc-
tion avoids both these issues. We present a detailed design
of our approach in Section 3, and formally deﬁne and prove
that the design achieves our properties in Section 4. Sec-
tions 5 and 6 report on our implementation of Verito and
experimental evaluation that demonstrates its practicality.
We also outline how Verito can be deployed incrementally,
as a proxy service that is available to interested users and
developers of any platform.

There is considerable interest

in virtual currencies,
though much of it is focused on legal and regulatory as-
pects (See Section 8). One technical solution, which is de-
signed with similar goals of transparency and accountabil-
ity in mind, is Bitcoin [1]. However, Bitcoin assumes a
fully-decentralized world, where every Bitcoin user tracks
the history of every credit and ratiﬁes every transaction.
This is impractical in our setting, with millions of credits
and transactions. There is also a substantial body of work
concerning e-cash [18] and related schemes, which seek to

Figure 1. Architecture of an accountable vir(cid:173)
tual economy.

provide anonymity and unlinkability, and are not directly
applicable.

Overall this paper makes three contributions: First, we
deﬁne the accountable virtual economy problem, and iden-
tify the properties which make it an interesting research
problem that is highly-relevant to industry. Second, we
present a rigorous solution that addresses this problem
through a novel combination of commitments and accu-
mulators. Finally, we build and evaluate our proposed ap-
proach, and ﬁnd it to be practical and scalable on current
hardware. In Section 7 we also discuss how it can be de-
ployed incrementally, and in response to stronger regulatory
laws.

2 Accountable Virtual Economy

In this section, we formulate the accountable virtual
economy problem. We ﬁrst introduce the players, deﬁne
the transactions between them, and call out the properties
that must be satisﬁed in this context.

2.1 Players

There are three types of players in a virtual economy as
shown in Fig. 1. First, we have the platform (P) which owns
and maintains the infrastructure, e.g., an online-gaming
ecosystem. Examples of such platforms include Facebook
and Xbox Live. Next there are the merchants (M) who are
registered with a P and use P’s infrastructure to host their
services. Examples of Ms include companies like Zynga,
which make games like Farmville, Cityville and MaﬁaWars
hosted on Facebook. Finally, there are the users (U ) who
are also registered with P and interface with the services
provided by Ms.

As a part of its business infrastructure, P issues and reg-
ulates credits, which can be thought of as a form of virtual
currency. Users playing a game can either purchase or earn
these credits, and subsequently redeem them with M to buy

Figure 2. A credit message

virtual goods (such as tractors in Farmville) and services. In
other words, Ms can offer products and services to users in-
exchange for credits, and Ms can later encash spent credits
at P.

Each credit is associated with a nominal value, which is
equal to the price that the P charged a user for its purchase.
Credits can be associated with different nominal values. For
example, in Xbox Live, 80 credits (Microsoft Points) can
be purchased for 1 USD, but cost 54.4 INR in India, and
are not tied to the current exchange rate. There are many
reasons for this, including different market conditions, dif-
ferent regulations, and tax laws across geographical regions.
In addition, Ps (or Ms) can hand out free credits to users,
which do not have any monetary value when they are re-
deemed. These can be thought of as loyalty points or incen-
tives to increase user participation as exercised by Facebook
in 2010. Verito is architected to support multiple types of
credits (including e.g., zero value credits, credits in differ-
ent currencies, and discounted credits in the same currency),
with a predeﬁned maximum limit on the number of distinct
nominal values a credit can be associated with.

One of the requirements in these virtual economies is
that no matter what the nominal value, an M must provide
the same experience for each credit spent by U s. That is,
at the time of spend by users, Ms cannot distinguish the
nominal values of individual credits directly. This ensures a
fair and consistent experience for users.

A credit in Verito is a commitment on a message which
describes the nominal value of the credit. The message (hid-
den in the credit) comprises of exactly log2 q bits, which is
divided into ⌊ log2 q
⌋ buckets each of size k, as shown in
Figure 2. q is a security parameter in the system (i.e., re-
lated to a large prime), and k is a fairness parameter in the
system (i.e., aggregation level for revealed commitments).
Different buckets represent different distinct nominal val-
ues. A valid credit message has the least signiﬁcant bit set
to one for exactly one bucket. The rest of the message is
ﬁlled with zeros. The bucket with the non-zero bit implic-
itly indicates the nominal value of the credit applied for its
purchase. Thus, the number of distinct nominal values we
can support is determined by system parameters q and k
(and is equal to ⌊ log2 q

⌋).

k

k

2.2 Transactions

We now describe the transactions (or interfaces) in a vir-
tual economy. Let CREDITS denote a set of credits and let
MONEY denote its corresponding aggregate nominal value.
Since the set may contain credits with different nominal val-
ues, MONEY must be thought of as an array of aggregate
values, where the jth entry represents the aggregate cor-
responding to jth distinct nominal value. Thus, MONEY[1]
may, for instance, correspond to credits purchased at 80
credits per USD in the US, MONEY[2] to credits purchased
at 1.47 credits per INR in India, etc. There are three trans-
actions in a virtual economy, namely, PURCHASE, SPEND
and ENCASH (See Fig. 1):

1. PURCHASE (U , MONEY):

• Description: U buys credits worth MONEY from
P. There will only be at most one non-zero en-
try in the MONEY array (which corresponds to
the particular nominal value applied for this pur-
chase). A zero-value credit, issued as incentive,
may also be “purchased” from the P using the
same interface.

• Initiated by: U

• Output: CREDITS

2. SPEND (U , M, CREDITS):

• Description: U gives CREDITS to M in-
exchange for virtual goods and/or services. Dif-
ferent CREDITS may contain distinct nominal
values.

• Initiated by: U

• Output: None

3. ENCASH (M, CREDITS):

• Description: M deposits CREDITS to P and
gets back MONEY corresponding to (1-PROFIT)
times the aggregate value of CREDITS (where
PROFIT represents the ﬁxed proﬁt margin of P
that is published ahead of time). Again, for each
j, P pays M a sum of MONEY[j] for credits asso-
ciated with the jth distinct nominal value.

• Initiated by: M

• Output: MONEY

2.3 Properties

Currently, virtual economies strongly rely on fair play
by the platform for their accountability. Our goal is develop
a system that minimizes trust assumptions on the platform.

To this end, we identify four system-wide properties that an
accountable virtual economy should support, namely trans-
parency, fairness, non-repudiation, and scalability. We do
not require merchants or users to trust the platform as long
as neither colludes with the platform to compromise the
other.

• Transparency: This property ensures that all the

money in the system can be properly accounted for.

Let MONEYIN denote the total value of all the real cur-
rencies that users have used to purchase credits inside
the virtual economy. Let MONEYOUT denote the total
amount of real currencies that P has paid-out to mer-
chants in ENCASH transactions. As earlier, MONEYIN
and MONEYOUT are represented as arrays with the jth
entry corresponding to the jth distinct nominal value.

The set of currently valid (unspent) credits is de-
noted VALIDCR and the set of credits already en-
cashed by M is denoted ENCASHEDCR. The subset
of VALIDCR constituted by credits associated with
the jth nominal value is denoted VALIDCRj and sim-
ilarly ENCASHEDCRj is the corresponding subset of
ENCASHEDCR. Given any set of credits associated
with same nominal value, its aggregate value is given
by the function Value(·).

For transparency we will require that the money within
each nominal value bucket is properly accounted for.
To this end an accountable virtual economy should en-
force the following system-wide property at all times
(invariant) and for all j:

MONEYIN[j] = MONEYOUT[j] + Value(VALIDCRj)
+ PROFIT ∗ Value(ENCASHEDCRj)(1)

where MONEYOUT[j] is given by:

MONEYOUT[j] = (1 − PROFIT) ∗ Value(ENCASHEDCRj)
(2)
This security property can be satisﬁed if CREDITS
←PURCHASE (U , MONEY) satisﬁes

Value(CREDITS) = MONEY

and MONEY ←ENCASH (M, CREDITS) satisﬁes

MONEY = (1 − PROFIT) ∗ Value(CREDITS)

(3)

The ﬁrst condition above guarantees transparency for
the user, while the second one guarantees it for the
merchant.

• Fairness: This property ensures that an M cannot
preferentially treat users based on the values of cred-
its used in the game. For this, we need to hide from

M, the nominal value of credits spent in any individ-
ual SPEND (U ,M,CREDITS) transaction. Note that
the system must allow Ms to check the correctness of
money received from P in ENCASH (M,CREDITS)
transactions, without allowing an M to eventually in-
fer the value of credits in any individual spend transac-
tion.

• Non-repudiation: The third security property disal-
lows any party from repudiating any transaction after-
the-fact. For example, a user should not be able to
deny having spent a credit (in an attempt to re-spend
that credit), and a merchant should not be able to deny
having encashed a credit.

• Scalability: For scalability, P must not have to store
each credit issued. While users and merchants natu-
rally have to store each credit in their possession, net-
work costs for any transaction they engage in must be
a function of the number of credits exchanged in that
transaction (and not a function of the total number of
credits in their possession).

Note that both Ms and Ps have a natural incentive to
detect any fraud by U s involving use of invalid credits or
re-use of already spent credits. Further, P has a natural in-
centive to ensure that Ms do not encash credits that were
already paid out. No other trust assumptions are needed
except that there are no collusions between the players.
Speciﬁcally, it is trivially possible for the user and platform
to collude and and erode a merchant’s revenue. Similarly, a
merchant and the platform can collude to deny fair service
to the user. Finally, since an accountable virtual economy
by design ensures that the money associated with every dis-
tinct nominal value is separately accounted for, it automati-
cally prevents arbitrage that can arise out of differentials in
currency exchange rates. We explain how Verito provides
support for these properties using cryptographic schemes in
the next section.

3 Verito

In this section, we describe our approach to achieve the
properties proposed in Section 2. To recall, the key prop-
erties are transparency, fairness, non-repudiation and scala-
bility. We explain the underlying cryptographic primitives,
and describe our Verito scheme that uses these primitives in
detail. In Section 4, we formally deﬁne our security proper-
ties and explain how our design meets these goals.

3.1 Preliminaries

To ensure transparency while maintaining fairness, we
use homomorphic commitments on the credit values. A

commitment to the credit value hides the actual value but
allows the credit values to be aggregated (see next subsec-
tion for details.) To get non-repudiation and scalability, we
use an efﬁcient cryptographic primitive called dynamic ac-
cumulators, without requiring zero-knowledge proofs that
make them inefﬁcient in traditional applications, to track all
the credits ”spent” and ”encashed”. These accumulators re-
quire much less storage at the platform than the traditional
approach of maintaining lists or hashed trees.

3.1.1 Commitment scheme

A commitment scheme is a protocol executed by a sender
and a receiver and has two stages, Commit and Reveal.
During the Commit stage, the sender commits to a (secret)
value to the receiver, by sending some function of the value.
Knowledge of the committed value does not allow the re-
ceiver to learn anything about the secret value. In the sec-
ond phase, the sender reveals the hidden value along with
some useful auxiliary information, which the receiver can
use to check the validity of the revealed value. Homomor-
phic commitments have the additional property that mul-
tiplying two commitments results in a commitment on the
sum of their committed messages, without revealing indi-
vidual values. More formally, a commitment scheme con-
sists of three algorithms: Setup, Commit and Open. The
Setup algorithm generates a public commitment key which
is used by either party to commit to a message m to the other
party. The committing party runs the Commit algorithm to
commit to a message m and sends the output c of the algo-
rithm to the other party. At some future time, the commit-
ting party can open the commitment by sending the message
m with auxiliary information aux to the other party. The
second party checks the correctness of the committed value
by running Open(c, aux). A secure commitment scheme
has two security properties: hiding and binding. The hiding
property ensures that the other party cannot learn anything
about the committed message m even after receiving the
output of the Commit algorithm. The binding property en-
sures that the committing party cannot “open” the commit-
ment to a different message m, once the Commit algorithm
has been executed. An additively homomorphic commit-
ment scheme has the additional property that a commitment
on m1 + m2 can be computed directly from the individual
commitments on m1 and m2, i.e. Commit(m1 + m2) =
Commit(m1) ⊙ Commit(m2). Several homomorphic com-
mitment schemes are known [10, 19, 32]. In our protocol,
we use Pedersen’s commitment scheme [32], which is one
of the most efﬁcient additively homomorphic commitment
schemes.
Setup(1k): Takes a security parameter k as input and gen-
erates a (k+1) bit prime prime p such that p = 2q +1 where
q is prime. Pick a random generator g of Z∗
q and a random

element h of Z∗
q.
Commit(m ∈ Zq): In order to commit m, choose random
element r ∈ Z∗
Open(c, r, m): Outputs 1 if grhm mod p equals c else 0.
Note r is revealed in this step allowing the validation of the
hidden value m.

q and output c = grhm mod p.

3.1.2 Dynamic Accumulators

Another cryptographic primitive that we use in Verito is a
dynamic accumulator. Cryptographic accumulator schemes
allow a publisher to “hash” a large set of input values to a
single short value (typically, of constant-size) called the ac-
cumulator [13, 15, 17], and provide for checking if a value
is contained (or alternately not contained) in the set rep-
resented by the accumulator, by generating a witness.
It
is infeasible to ﬁnd a witness for a value that was not ac-
cumulated. Accumulators have been proposed for revoca-
tion lists in anonymous credential systems, for identity es-
crow, and group signatures etc. Dynamic accumulators [17]
further extend this functionality by allowing dynamic ad-
dition or deletion of input values to this accumulator efﬁ-
ciently, where the cost of the add or delete is independent
of the number of accumulated values. We use accumu-
lators in the context of checking double-spending/double-
encashing of credits (for non-repudiation by users or mer-
chants), though we do not use the accompanying (often ex-
pensive) Zero-knowledge protocols that are often required
in settings requiring anonymity. Different dynamic accu-
mulator schemes have been proposed, including those based
on the strong RSA assumption [17], and from bilinear pair-
ings [16, 28]. Accumulators can represent either the list of
valid values (white-list) or the list of invalid values (black-
list).

Any secure accumulator consists of four algorithms Ac-
cGen, AccAdd, AccWitUpdate, and AccVerify. There
are typically four actors: an accumulator authority, an (un-
trusted) update entity, users and veriﬁers. The accumula-
tor authority runs the AccGen algorithm after creating a
new accumulator key pair (skA, pkA). New values can be
added to the accumulator accV using the AccAdd to obtain
a new value acc′
V . AccAdd produces a witness witi. Both
accV and witi are of ﬁxed length. Each time an accumu-
lator changes, witi becomes invalid. All witnesses need to
be updated, and this can be ofﬂoaded to a witness-update
entity, which does not need any secret security parameters.
Users who obtain the current witness for a value i can prove
to any veriﬁer that this value is in the accumulator using
AccVerify. In our architecture, the role of the authority and
the veriﬁer is played by P. The role of the users is played
by U in the SPEND transaction and by M in the ENCASH
transaction. There is no third party update entity. U and
M can update their witnesses by receiving a witness update

from P.

3.2 Verito Protocol

Now we present technical details of the dynamic univer-
sal accummulator (DUA) scheme used in our implementa-
tion. This scheme is due to Au et al., [11], which is based
on an original proposal by Nguyen [28]. The scheme uses
Bilinear pairings and augments Nguyen’s construction to
work on the ring of polynomials over a ﬁnite ﬁeld (i.e., a
Euclidean domain). The security of this scheme is based on
the strong or decisional Difﬁe-Hellman assumption.

A bilinear pairing is a mapping from a pair of group el-
ements to another group element. Let G1 and G2 be cyclic
groups of prime order p. Let g be a generator of G1. Func-
tion ˆe : G1 × G1 −→ G2 is a bilinear map if:

• Each element in G1, G2 has a unique binary represen-

tation.

• ˆe(Ax, gy) = ˆe(A, B)xy for all A, B ∈ G1 and x, y ∈

Zp (bilinearity).

• ˆe(g, g) 6= 1, 1 is identity in G2.

• Computation of ˆe(A, B) is efﬁcient.

We now describe the various algorithms:

p × Z∗

p −→ Z∗

p. Deﬁne function f : Z∗

AccGen: Let ˆe : G1 × G1 −→ G2 be a bilinear pairing
such that |G1| = |G2| = p for some λ bit prime p (λ is
the security parameter). Let g0 be a generator of G1 and
Gq =< h > be a cyclic group of prime order q such that
Gq ⊂ Z∗
p. The generation algorithm picks α randomly from
Z∗
p such that f :
u, y → u(y + α). Deﬁne function g : Z∗
p × G1 s. t., g : y →
gy
0 . The domain of accumulatable elements is Gq and the
auxiliary information is α. To compute the accummulator
v = g ⊗ f (1, Y ) if α is available is efﬁcient. If α is not
available, one can publish gαi
for i = 0, k where k is the
0
maximum number that can be accumulated. If we denote
the polynomial Qy∈Y (y + α) = Pi=k
i=0(uiαi) of maximum
degree k as v(α), then v = g ⊗ f (1, Y ) can be efﬁciently
computed as Qi=k
AccAdd: To add element y to the accumulator v, compute
ˆv = vy+α. Deleting y from v gives ˆv = v
y+α . Both cases
require knowledge of α.
AccWitUpdate: Let w is the original witness for y and
v the original accumulator. If y′ has been added, the new
membership witness for y can be computed as vwy′
AccVerify: The veriﬁcation relation Ω(w, y, v) = 1 iff
ˆe(w, gy
0 ) = ˆe(v, g0). For elements Y = y1, · · · , yk ∈
Gq, a membership witness for y ∈ Y can be computed as:

i ∈ G1 without knowledge of α.

i=0 gui

0 , gα

1

−y.

• w = (Qi=k

i=1(yi + α). 1

α+y if α is known

• Qi=k

i=1 gui

i ∈ G1 otherwise

Please refer to [11] for a detailed description of its con-

struction and properties.

At a high-level, Verito works as follows: When a user
initiates a PURCHASE transaction, P creates the required
number of credits by committing to the nominal value re-
quested (using Commit), and sends them to U . P also pro-
vides U with a commitment key so that U may open the
credits and verify the nominal value of each credit. This
is implemented as CheckCredit, implemented as Open(c,
r, m) as described in the Pedersen’s commitment scheme
earlier. P also white-lists the credits generated by adding
them to the accumulator (using AccAdd) it maintains per
U ; this results in a witness for each credit added to the ac-
cumulator, which P sends to U along with the credits. Since
modifying the accumulator requires that existing witnesses
(of past credits still in the user’s possession) are updated, P
computes the witness update for the transaction and sends it
to U . The witness update is a single quantity (independent
of the number of credits in the user’s possession). U com-
bines the witness update with the witness for each credit
in his possession (using AccWitUpdate) to derive the new
witness for that credit.

The SPEND transaction proceeds as follows: U ﬁrst ac-
quires a transaction nonce from a merchant M; this is used
to ensure freshness and protect against replay attacks. Next,
U contacts P with the credit(s) it would like to spend along
with their witnesses, the merchant M it would like to spend
the credits with, and the nonce. P veriﬁes that the credits
are present in the accumulator (white-list using AccVerify)
it is maintaining for U . If the veriﬁcation succeeds, it up-
dates the accumulator by removing the credits spent (using
AccAdd) and sends U a witness update, so U can update the
witnesses of other credits in his possession. Note that if U
attempts to re-spend credits he previously spent, the mem-
bership check in the accumulator (white-list) will fail and
the transaction will be aborted.

When the SPEND transaction succeeds, P also adds the
spent credits to the accumulator (using AccAdd) he is main-
taining for the merchant (i.e., merchant M sent by the user
when he initiated the transaction). This accumulator for M
is used as a white-list to protect against M attempting to
encash a credit multiple times. The witness update (for the
merchant) that this generates, and the transaction nonce, are
together signed by P as a receipt for the transaction. P
sends this receipt to U , who forwards it to M as proof of
the transaction along with the actual credits. M stores these
credits and applies the witness update (using AccWitUp-
date).

In the ENCASH transaction, M sends a set of credits and
their respective witnesses to P. As before, P checks if the
credits are indeed present in the merchant’s accumulator
(using AccVerify). If the veriﬁcation succeeds, it updates
the accumulator by removing the credits and returning the

witness update. It also reveals to the merchant the aggre-
gate commitment opening key (the sum of individual credit
opening keys) for the set of credits encashed. The merchant
opens the set of credits to learn the aggregate nominal value
of the credits he encashed. When M is later paid, he can en-
sure his payment matches the aggregate he computed (while
accounting for P’s proﬁt).

3.2.1 Concrete Instantiation

Our concrete construction uses the additively homomorphic
commitment scheme of Pedersen described above to gener-
ate credits. The dynamic accumulator scheme of [11, 28]
is used to check the validity of the credits in an efﬁcient
manner. The details are provided below:

1) SETUP (1k): P runs this algorithm to set up the sys-
tem parameters. It takes the security parameter as input and
generates a symmetric key K and a public-private key pair
(pk, sk). While K is used by P to encrypt parts of the credit
that it wants to hide from M, sk is used to sign messages.
P shares this pk with all users and game developers. For
each user U and game developer M, it runs AccGen(1k, n)
to initialize their respective dynamic accumulators.

2) PURCHASE (U , MONEY): The Purchase transaction is
initiated by user U by sending its id and the amount #cred-
its to P. P creates #credits number of credits, where each
credit is constructed as follows: Depending on the currency
type and other transaction details, P chooses the bucket i
It deﬁnes m = 2j where
to be populated in the credit.
j = (i − 1) × k. It chooses r uniformly at random from Zq
and computes gr · hm mod p. Then, it adds the credit to the
U ’s accumulator by calling AccAdd(U , gr ·hm mod p). The
returned witness update wit also forms part of the message
returned by P to U . P sends back {Credit=(gr · hm mod p,
EK (r, m)), σsk(Credit), r, m, wit}, where σsk(Credit)
is a signature on the credit under the signing key sk. Note
that the encryption of (r, m) is also included in the credit
as this is can be decrypted later by P to know the value
of the credit. U runs the CheckCredit (c,m) = Open(c, r,
m), which veriﬁes if grhm mod p equals the ﬁrst part of
the Credit, and veriﬁes the signature on the credit using P’s
public key pk. U updates the witnesses for all existing cred-
its by running AccWitUpdate and stores the credit along
with its witness for future transactions.

3) SPEND (U , M, CREDITS): WhenU wants to spend
in-app, it initiates the SPEND transaction by sending its id,
M’s id and the transaction number/nonce (received from
M) along with a set of credits with respective witnesses
to P. P retrieves r and m for each credit by decrypting
EK (r, m) and checks if grhm mod p indeed equals the ﬁrst
part of the credit. It also veriﬁes its own signature on the
credit. It calls AccVerify (grhm mod p, wit) to check if the
credit is in the accumulator of that user. If all these checks

are passed, P removes the credits from U ’s accumulator and
adds it to M’s accumulator using the AccAdd function. It
sends back witness updates for both U and M along with a
signed acknowledgment of the success of the transaction. U
updates witnesses for all of its credits using AccWitUpdate
and also forwards M’s witnesses to the latter.

4) ENCASH (M, CREDITS): Whenever M wants to
encash the credits she has earned through various users,
she can send these CREDITS in the ENCASH transaction
along with their respective witnesses. Note, M can send
at most 2k − 1 CREDITS at a time, to prevent overﬂow
when these CREDITS are multiplied later. P retrieves r
and m for each credit by decrypting EK(r, m) and checks
if grhm mod p indeed equals the ﬁrst part of the credit. It
It calls Ac-
also veriﬁes its own signature on the credit.
cVerify (grhm mod p, wit) to check if the credit is in M’s
accumulator.
If all the checks are passed, it removes the
CREDITS from the M’s accumulator using AccAdd func-
tion, computes R = Σr and M = Σm of the presented
credits and returns the witness update along with money
worth (1 − PROFIT) ∗ M to the M. M checks that the
product of the submitted credits i.e. Πgrhm mod p equals
gRhM mod p.

4 Properties

In this section, we formally deﬁne our security properties
as a game between a benign challenger and a malicious ad-
versary (see [33]). We model the adversary and challenger
as probabilistic processes that are allowed to communicate
with each other, creating a probability space for the attack-
game. Associated with each game is a security parameter
which affects this probability space. For every ”efﬁcient”
adversary (a probabilistic polynomial time algorithm), the
probability that the adversary succeeds in winning the game
should be negligible. Note that the protocol also uses sig-
natures for non-repudiation, and since this is standard, we
do not include it in the games. As noted in Sect 2, we as-
sume that no parties collude in the system. Thus, each of
our security games assumes one party is the challenger, and
the other the adversary, while the third party is neutral. The
properties are deﬁned in Section 4.1. We present proofs and
how can use these properties to achieve our global invari-
ants in Sect 4.2.

4.1 Property Deﬁnitions

1) User transparency: For this game, the challenger is the
user U and the adversary is the platform P. P should not be
able to claim different values for the credits once they are
committed at the time of purchase.

• The challenger U initiates PURCHASE (U , 1)

• The adversary creates a single credit ci which includes
the commitment, the nominal value mi and its com-
mitment key, and sends ci to the challenger. The chal-
lenger runs CheckCredit (ci, mi) and accepts only if
its output is true.

The adversary wins the attack-game if P can produce an-
other m′

i 6= mi and CheckCredit (ci, m′

i) is true.

2) Merchant transparency: For this game, the challenger
is M and the adversary is P. The idea is that the platform
cannot cheat merchants when credits are encashed.

• The challenger initiates an ENCASH (M, CREDITS)
transaction by presenting credits (ck) along with their
corresponding accummulator witnesses wk.

• The adversary sends (M, R) in response to the chal-

lenger.

• The challenger computes Aggregate (ck) (product
of credits in our protocol) and Commit (M, R) and
checks if Aggregate (ck) = Commit (M, R)

The adversary wins the attack game if Commit (M, R) =
Aggregate (ck) and M 6= Σmk.

3) User fairness: For this game the challenger is U and
the attacker is M. We assume that P is not malicious. The
idea is that the merchant cannot distinguish between differ-
ent valued (say paid and free) credits.

• The challenger picks r from {0, 1} uniformly at ran-
dom and sends credit cr to the adversary. Previously,
the challenger has initiated PURCHASE (U ,1), to obtain
c0 and c1 with nominal values m0 and m1 respectively
from P.

• The adversary returns r′ ∈ 0, 1

The adversary wins the attack-game if M can correctly re-
turn r′ = r with probability non-negligibly higher than 1
2 .
4) Double spending prevention: For this game the chal-
lenger is P and the attacker is U . M is only an ob-
server, and has a natural incentive to be honest, as dou-
ble spending by U will impact M’s proﬁt directly. The
idea is that the user cannot spend a used credit at any mer-
chant more than once. The adversary purchases n credits
C = {(c1, m1), · · · , (cn, mn)} and obtains the appropriate
witnesses wi.

• The adversary initiates a SPEND (U , M, C1) of C1 ⊂ C
consisting of l < n credits by sending the correspond-
ing witnesses

• The challenger retrieves the mis corresponding to the
credits in C1, and calls AccVerify(mi, wi) on the cor-
responding witnesses and updates these witness values
and communicates it to both M and U

• The adversary initiates another SPEND (U , M, C2) of
C2 ⊂ C consisting of m < n credits and (C)1∩(C)2 6=
φ, by sending the corresponding (updated) witnesses

The adversary wins the attack-game if upon retrieving the
corresponding mjs, j ∈ C2, AccVerify(mj , wj) succeeds.

5) Double encashment prevention: For this game the ad-
versary is M and the challenger is P. Users are not in-
volved in encash. The idea is that the merchant cannot en-
cash the same credit twice. We assume that the adversary
has n credits C = {(c1), · · · , (cn)} and obtains the appro-
priate witnesses wi.

• The adversary initiates an ENCASH (M, C1) of C1 ⊂ C
consisting of l < n credits by sending the correspond-
ing witnesses

• The challenger retrieves the mis corresponding to the
credits in C1, calls AccVerify(mi, wi) for 1 ≤ i ≤
l on the corresponding witnesses, and updates these
witness values and communicates it to M

• The adversary initiates another ENCASH (U , M, C2) of
C2 ⊂ C consisting of m < n credits and (C)1∩(C)2 6=
φ, by sending the corresponding (updated) witnesses

The adversary wins the attack-game if upon retrieving the
corresponding mjs, j ∈ C2, AccVerify(mj , wj) succeeds.

4.2 Analysis

We show how these properties are achieved in our instan-
tiation, and describe what cryptographic hard-problems are
needed for their security.

1) User transparency: We will show that the probability
of the adversary U winning this game is negligible in the
security parameter. The security parameter here is deﬁned
in terms of the number of bits needed to represent the com-
mitments ci, i.e., the number of elements n of a group G
of cyclic order with generators g, h. We will use the dis-
crete logarithm (DL) problem in G for a given h ∈ G, com-
pute r ∈ Zn such that h = gr. The DL assumption is a
computational hardness assumption: Given G, for all PPT
algorithms A, P r[A(h) = logg h] is negligible.

From our deﬁnition of the User transparency game,
P r[Adv wins] = P r[CheckCredit(ci, mi) = 1 ∧
CheckCredit(ci, m

i) = 1 ∧ mi 6= m

′

′

i].

Thus, in our protocol,

P r[Adv wins] = P r[ci = gri hmi ∧ ci = gr

i hm

′

′

i

∧mi 6= m

′

i]

= P r[gri hmi = gr

i hm

i ∧ mi 6= m

′

′

′

i]

For given mi, m

′

′

i(6= mi) and ri, coming up with r

i that
satisﬁes the above relation is equivalent to ﬁnding the dis-
crete logarithm (DL) of gri hmi−m
i with respect to gener-
ator g, which can happen with only negligible probability
(DL assumption).

′

2) From our deﬁnition of the merchant transparency
attack-game, P r[Adv wins] = P r[Commit(M, R)] =
Aggregate(ck) ∧ M 6= Σmk].

P r[Adv wins] = P r[Commit(M, R) =

Aggregate(ck) ∧ M 6= Σmk]

= P r[gRhM mod p =

Πgrhmk mod p ∧ M 6= Σmk]

From the homomorphic property of Pedersens commit-
ments, we know that Commit(Σmk) = ΠCommit(mk),
so the adversary has to ﬁnd a R equal to the discrete log of
gΣrhΣmk−M . Finding such a R is equivalent to solving the
DL problem. The DL Assumption asserts that the probabil-
ity of this is negligible.

3) From our deﬁnition of the user fairness attack-game
P r[Adv wins] = P r[r′ = r]. Now r is picked by the
challenger uniformly at random, and causes the adversary
to obtain either c0 = gr
2hm1 mod p.
Since, the values c0 and c1 are information-theoretically in-
distinguishable from random numbers (hiding property of
Pedersen’s commitment), the adversary cannot guess r with
probability better than random chance.

1hm0 mod p or c1 = gr

4) Since in the double spending attack-game, (C)1 ∩
(C)2 6= φ, let us focus on one credit ck in (C)1 ∩ (C)2.
When this credit is presented in the SPEND transaction (as
part of (C)1), the challenger removes ck from the accumula-
tor and sends an update for the adversary’s witnesses. Now,
since credits get added only once to the accumulator us-
ing the PURCHASE transaction, there is only a negligible
probability that the adversary can produce a witness for ck
when presenting it again in the SPEND transaction (as part
of (C)2). This follows from the fact that security of our
accumulator scheme, which is equivalent to solving the q-
strong Difﬁe-Hellman problem.

5) From our deﬁnition of the double encashment attack-
game, the probability that the adversary wins depends on
the same property as the double spending, and the analysis
follows from 4) with the ENCASH instead of SPEND calling
AccVerify under the same conditions.

Note that all transactions have a built in authentication
and non-repudiation properties (using encryption and digi-
tal signatures). We summarize our properties and the cryp-
tographic assumptions required for ready reference below

the Discrete-Log assumption). Merchant transparency
follows from the binding property and the homomor-
phic property of Pedersen commitments.

2. User Fairness follows from the hiding property
(information-theoretic, no assumption) of Pedersen
commitments

3. Double spending and Double encashment protec-
tion ensue from the Accumulator scheme (Decisional
Difﬁe Hellman and q-Strong Difﬁe Hellman assump-
tions)

Global Properties: It is easy to see that Verito system
guarantees global transparency, as the value of the credits in
PURCHASE, SPEND and ENCASH transactions can be ver-
iﬁed by the interested parties as soon the transaction com-
pletes by the concerned parties. Note that ENCASH is ac-
companied by a privacy policy that may not allow certain
kinds of transactions, but if a transaction completes that ad-
heres to this policy, the guarantee is still valid. Since the
property is true for every transaction, it is true globally.

Let all users verify all their PURCHASE transactions by
checking if the product of their credits equals the opened
value of their sum revealed by P, and no credits are dupli-
cated when a user spends them with Ms. Further all Ms
verify each ENCASH, assuming the privacy policy allows
them. Arbitrage is not an issue as different currencies are
not allowed to mix (by credit design).

Now let us examine the Fairness property. As long as the
M can only see the aggregate value of the tokens presented,
and cannot game the system (because of the privacy policy)
to infer values of individual tokens, M cannot discriminate
between credits with different nominal values.

Non-repudiation, i.e., both double-spending and double-
encashment are prevented by the white-list accumulator
scheme.

Scalability is achieved through the use of ﬁxed-size ac-
cumulators (sza), ﬁxed-size credits (szc), ﬁxed-size wit-
nesses (szw), and ﬁxed-size witness updates (szwu). The
storage at P is O (1) for each user and merchant, and in-
dependent of the number of credits they possess. The re-
sponse to the PURCHASE transaction for n credits is of size
n(szc + szw) + szwu) which is O (n) in the credits pur-
chased, and independent of the total number of credits the
user already has. The messages in the SPEND and ENCASH
transaction for n credits are similarly O (n) and indepen-
dent of the total number of credits the user or the merchant
have.

5

Implementation

1. Transparency: User transparency follows from the
binding property of Pedersen’s commitment (based on

Our implementation of Verito comprises of the following
components: Interfaces for P, M and U , a credit generation

module using Pedersen’s commitment scheme, a double-
spending prevention module using dynamic accumulators
from [28] and an example game which allows for in-game
purchases. P exposes its functionality over HTTP, and can
therefore interact with programs written in any language,
including browser-based applications.

The commitment part of our P implementation consists
of 760 lines of C code. The accumulator part consists of
an additional 130 lines of C++ code. Our example M
component consists of 470 lines of C, and U component
consists of 130 lines of HTML and Javascript. We use
the libevent library [25] for all HTTP communication. We
use the NTL library [29] for performing modular arithmetic
with k = 1024 unless otherwise speciﬁed, and an in-house
library for pairing-based operations. The example game in-
cluding both the M and U components was created in under
six hours by a single person demonstrating the ease of pro-
gramming to the P webservice API.

5.1 Optimizations

While our commitment module, and most of the accumu-
lator module could perform at high-speed, one accumulator
operation (AccVerify) was the performance bottleneck. We
design an optimization that avoids this bottleneck in most
cases.

We cache the last l credits added to an accumulator.
Credits are removed from the cache either when they are
deleted from the accumulator (AccUpdate), or evicted
(e.g., in FIFO order) when cache size exceeds k. As a re-
sult, if a credit exists in the cache, it is guaranteed to exist in
the accumulator (i.e., AccVerify is guaranteed to succeed).
If, however, a credit does not exist in the cache, AccVerify
must be executed to check if the credit exists in the accu-
mulator. The optimization, thus, skips AccVerify when the
credit exists in the cache. Note that generating the witness
update (after deleting a credit from the accumulator) is not
impacted by skipping AccVerify when the credit is guaran-
teed to exist in the accumulator.

Picking l and the eviction policy to maximize the cache-
hit rate depends on the application, and is best arrived at
during performance tests, and we do not prescribe a ﬁxed
value in this paper.

5.2 Putting it Together

Figure 3 demonstrates through screenshots our proof-of-
concept in-game purchase scenario, and how Verito can de-
tect an accounting anomaly we deliberately injected into P.
Figures 3a and 3b show an in-game shopping menu, and
the user’s in-game credits account where the user can pur-
chase credits by paying actual money, or redeem a promo-
tional coupon (modeled along Facebook’s credit system as

(a)

(b)

(c)

(d)

(e)

(f)

Figure 3. a,b: U purchases in(cid:173)game items.
c,d:M encashes credits. e,f: Bug in P results
in incorrect pay(cid:173)out. M catches the problem.

discussed earlier). In our test, the user redeems a coupon
for 10cr, and purchases 10cr for $1. Once the user buys
the Tractor, M’s console (Figure 3c) shows the credits re-
ceived from the user. When M chooses to encash his cred-
its, the veriﬁcation succeeds (Figure 3d) showing the value
of the encashed credits as $1. Next, we enable an account-
ing anomaly in P (Figure 3e) where P siphons off $1 from
the payout. We re-run the test, but let the user buy all 20cr
by paying $2. The (anomalous) payout is therefore $1 in-
stead of $2; this duplicates the previous scenario where P
offers to payout $1 for the 20cr encashed. M can, however,
detect the accounting anomaly since the veriﬁcation fails as
shown in Figure 3f.

6 Performance Evaluation

We

performance

evaluate Verito

using macro-
benchmarks, and perform a feasibility analysis based
on transaction volumes we acquired from a large gam-

 1000

 900

 800

 700

 600

 500

 1

 180000

 160000

 140000

 120000

 100000

 80000

 60000

 40000

 20000

)
d
n
o
c
e
s
 
r
e
p
(
 

d
e
s
a
h
c
r
u
P
 
s
t
i

d
e
r
C

)
d
n
o
c
e
s
 
r
e
p
(
 

d
e
h
s
a
c
n
E
 
s
t
i

d
e
r
C

 10

 100

 1000

Batch size

(a) PURCHASE

 0

 1

 10

 100

 1000

Batch size

(b) ENCASH

Figure 4. Performance macro(cid:173)benchmark

ing company. Macro-benchmarks test
the end-to-end
aspects of our implementation,
including not only the
underlying cryptography performance, but also overheads
associated with processing HTTP requests, and serializing
and deserializing credits. All experiments are run on a
typical workstation-class machine with an Intel Core2 Duo
processor running at 2 GHz with 4 GB memory.

6.1 Macro(cid:173)Benchmarks

We benchmark the performance of our P implementa-
tion (with the cache-based optimization) by measuring end-
to-end latency of each of the operations it participates in.
The measured latency includes HTTP overheads, however,
we exclude network bandwidth and latency related over-
heads by using the loopback network interface. We restrict
the P to only one core of the dual-core machine, and use
the second core for the benchmarking process.

Purchase. Figure 4a plots the performance of PUR-
CHASE transactions as a function of the size of the batches

Time

0.14 ms
3.12 ms

Operation (single-thread)
PURCHASE
P: Accumulator Add
U : Witness Update
SPEND
P: Accumulator Verify worst-case
156 ms
P: Accumulator Verify best-case* <0.1 ms
P: Accumulator Update × 2
0.28 ms
U : Witness Update
3.12 ms
M: Witness Update
3.12 ms
ENCASH
P: Accumulator Verify worst-case
156 ms
P: Accumulator Verify best-case* <0.1 ms
P: Accumulator Update
0.14 ms
M: Witness Update
3.12 ms

*Cache-based optimization

Table 1. Accumulators micro(cid:173)benchmark

in which credits are purchased. Since the end-to-end la-
tency includes a ﬁxed communication overhead and vari-
able cryptography cost, the larger the batch-size, the more
credits the network overhead is amortized over, and there-
fore the higher the performance. That said, cryptographic
cost clearly dominates network overhead as performance
holds steady at around 830 credits per second with minimal
improvement from batching. Each datapoint is the average
per-second throughput computed for a benchmark-run last-
ing 15 seconds.

Spend/Encash. Figure 4b plots the performance of EN-
CASH transactions as a function of batch-size. The im-
pact of batching is far more dramatic since the ﬁxed over-
heads dominate. Encashing credits in batches of around 100
yields the best performance for our implementation. Net-
work overheads dominate below this threshold. Above this
threshold memory-related overheads (i.e., holding larger re-
quests and responses in memory). While we believe we
can optimize our implementation to maintain peak perfor-
mance for larger batches, there is little reason to, consid-
ering ENCASH performance already outstrips PURCHASE
performance by two orders of magnitude.

The performance of the validation step in the SPEND
transaction (to guard against invalid credits and double-
spent credits) is identical to ENCASH performance, and in-
deed uses identical code. The only difference is that EN-
CASH in addition generates the correctness proof (for open-
ing commitments). Generating the proof adds negligible
overheads since it involves only product operations on large
numbers (and no modular exponentiations).

6.2 Micro(cid:173)Benchmarks

We benchmark our accumulator performance in Table 1.
PURCHASE transactions require very little processing at P
(0.14 ms). U must apply the witness update to all witnesses
he has, however, this operation does not need to be syn-
chronous. The witnesses can be updated lazily at any time
before the credit is spent. Each witness update operation
takes 3.12 ms on a typical laptop (single-threaded), which
can be trivially parallelized. Thus thousands of credits can
be updated in just a few seconds.

As mentioned, the dominant performance cost comes
from the unoptimized verify operation in the SPEND and
ENCASH transactions. By using our cache-based optimiza-
tion, and tuning the cache size for best performance, we
can reduce the veriﬁcation cost to practically nothing (<
0.1 ms) for almost all requests. As before, witness updates
can be performed lazily in parallel.

6.3 Feasibility Study

To estimate feasibility, we approached a large online-
gaming platform for transaction volume data; the online-
platform in question transacts several hundreds of millions
of dollars each year. Given the exchange rate between $1
and credits in the platform, and the platform’s growth target
over the next few years, a rough target for Verito would be
to generate on the order of 100 billion credits in a year.

Our P implementation can generate 71 million credits
per day (26 billion per year) on a single-core. Thus a single
quad-core workstation we estimate can serve the demands
of the real-world gaming platform we approached.

Overall we believe Verito is both practical (in terms
of performance) and signiﬁcantly raises the functionality
bar (in terms of adding transparency and accountability) to
Internet-scale gaming platforms.

7 Discussion

The biggest concern with Verito is how to incentivise
adoption.
It is true that in the current climate, Facebook
or Xbox (perhaps) have little reason to give up transparency
of their economies. We envision two complementary ap-
proaches that can drive Verito adoption.

Verito overlay. Verito can run as an overlay on top of an
existing economy (e.g., Facebook credits). The user installs
a browser extension that modiﬁes the existing Facebook
UI, say, to add the option of purchasing “veriﬁed credits”,
which are processed by a Verito platform that runs indepen-
dently from Facebook. Game developers allow users to pay
using regular Facebook credits, or using “veriﬁed credits”.
The independent Verito platform, which may be run by a
startup, makes a commission per-transaction like Facebook

does. Game developers don’t get any guarantees for regu-
lar credits, but for the fraction of their income coming from
“veriﬁed credits”, they have strong guarantees.

Regulation. While virtual economies have, so far, es-
caped regulation, the same reasons for regulating banks ap-
plies to virtual economies — i.e., protecting customers. If
today a user were to buy $100 in Facebook or Xbox cred-
its, he would not have any legal recourse if due to a bug
or a breach Facebook or Xbox were to lose these credits.
Regulators could encourage (or force) virtual economies
to be transparent to protect consumers. Verito presents a
proof-of-concept of how it is technologically feasible to add
transparency while balancing competing interests and con-
straints that naturally arise in these virtual economies.

8 Related Work

The past decade has seen a growing interest in research
revolving around virtual economies, what drives them [24],
their legal implications [26], etc. (See [9] for an extensive
bibliography). However, there has been very little work on
the design and implementation of these virtual economies.
Nevertheless, token (or credit) based virtual economy sys-
tems exist around the world: Xbox Live Marketplace uses
Microsoft Points as the currency to purchase games and
other online services without repetitive use of credit cards
or banking accounts [7]; Facebook Credits is a system that
enables users to buy digital and virtual goods in games
and apps across Facebook [3]; Octopus Card (a contactless
stored-value card) was originally introduced to collect fares
in the Hong Kong Mass Transit Railway (MTR) system, and
it is now a widely used payment system in supermarkets,
fast-food restaurants, car parks, etc. [8]; and in Second Life,
the virtual economy of Linden Dollars allows users to make
in-game purchases to acquire virtual goods and services [2].
Microsoft Points, Octopus Cards and Linden Dollars are
transparent systems, in that the nominal value associated
with a spent credit is clearly known to the player encashing
it for real money. However, these systems offer very little
ﬂexibility with respect to accommodating multiple nominal
values (whether for pricing differently in different geogra-
phies or for offering promotions/discounts to encourage ac-
tive user-participation in the virtual economy, etc.). On the
other hand, the Facebook Credits system admits a ﬂexible
pricing of credits, but does not provide transparency – game
developers cannot independently verify the correctness of
the amount of money received from Facebook in-return for
the spent credits. Facebook may be able to trivially offer
a transparent payout summary, but that would compromise
the privacy of users (exposing users to the risk of preferen-
tial/unequal treatment by game developers). Moreover, the
differentials in credit nominal values may be exploited by
game developers masquerading as users, raising the possi-

bility of arbitrage.

Recently, a token-based scheme for privacy-preserving
toll collection was proposed in [12, 27]. Their focus was on
preserving privacy of user-locations during automatic toll
collection. While their scheme uses similar primitives as
ours, such as homomorphic commitment schemes, their ar-
chitecture does not quite adapt to the virtual economy set-
tings we consider, with multiple nominal values for credits.
Electronic cash (e-cash) systems [18] also have an ar-
chitecture similar to our system in terms of the kinds of
players and transactions. The three players in an e-cash
system are: the Bank, customers and merchants, while the
three main transactions are Withdraw, Payment and De-
posit. Even some of the desired security properties are
similar: Unforgeability of digital cash and over-spending
(sometimes called double spending) prevention. The key
differences are the requirements of anonymity of users (no
one should be able to infer the identity of the user by view-
ing the e-cash tokens) and unlinkabilty of user transactions
(no one should be able to infer that two payment transac-
tions are with the same user). Because of these privacy
requirements, e-cash systems tend to rely on stronger and
less efﬁcient cryptographic techniques. There are also two
desirable properties in our system which are often absent
in e-cash systems: ﬂexibility (multiple-valued credits) and
non-repudiation. While we support multiple nominal values
for virtual credits in Verito, we also provide non-repudiation
as a security property.

Finally, we also present references for homomorphic
commitment schemes and dynamic accumulators: Only
a few direct constructions of homomorphic commitments
are known [20, 32]. Many other constructions can be de-
rived from homomorphic encryption schemes [22, 30, 31],
but [32] continues to remain one of the most efﬁcient and
widely used commitment schemes. Several other commit-
ment schemes [21, 23] have been derived from it to achieve
some additional properties.
In terms related work for of
dynamic accumulators, they were ﬁrst introduced in Ca-
menisch et al. [17], and many schemes have been pro-
posed [13, 15]. The dynamic accumulator scheme used is
this work is a modiﬁcation [11] of the scheme presented by
Nguyen [28] and we picked the scheme for its efﬁciency.

9 Summary and Future Work

In this paper we argue that the accountable virtual econ-
omy problem is very relevant to the industry today. Cred-
its, which constitute the currency in virtual economies, may
be associated with multiple nominal values, depending on
the geographic region where they are sold, or depending
on whether the credits are paid-for or offered free as part
of a promotion, etc. Currently it is not possible for users
and content-creators to audit the accounting practices of

platform-providers, i.e., they cannot validate the value of
credits spent on the platform without resorting to legal pro-
cedures (as in the case of a dispute). In addition to scala-
bility as a performance requirement, we identify three de-
sirable security properties viz., transparency, fairness and
non-repudiation, which are currently enforced by simply
trusting the platform provider. Using well-established cryp-
tographic primitives such as commitment schemes and dy-
namic accumulators, we develop a framework that satisﬁes
these security properties, and is efﬁcient and scalable to a
large number of users, credits and transactions.

From the adoption angle, a shortcoming of our approach
is that it requires explicit cooperation from existing plat-
forms. While one can imagine regulatory pressure to extract
this cooperation, a better solution would be one that lever-
ages existing platforms without major modiﬁcations. To ad-
dress this, we propose a web-proxy based overlay solution
that can be incrementally deployed. We hope this paper will
spark further research within the community to explore all
aspects of this important problem.

References

[1] Bitcoin:

A peer-to-peer

electronic

cash

system.

http://bitcoin.org/.

[2] Economy of second life.
[3] Facebook credits. http://developers.facebook.com/docs/cre

dits/.

[4] Facebook

[5] Facebook

for

credits

developers.
https://www.facebook.com/help/?page=199374706772290.
S1.
http://www.sec.gov/Archives/edgar/data/1326801/0001193
12512175673/d287954ds1a.htm.

Form

Inc.

[6] Inside virtual goods the us virtual goods market 2011 - 2012.

http://www.insidevirtualgoods.com/us-virtual-goods/.

[7] Microsoft

points.

http://www.xbox.com/en-

US/Live/MicrosoftPoints.

[8] Octpus card. http://en.wikipedia.org/wiki/Octopus card.
[9] Virtual

economy

research

network

bibliography.

http://virtual-economy.org/biblio.

[10] M. Abe, R. Cramer, and S. Fehr. Non-interactive distributed-
veriﬁer proofs and proving relations among commitments.
In Proceedings of the 8th International Conference on the
Theory and Application of Cryptology and Information Se-
curity: Advances in Cryptology, ASIACRYPT ’02, pages
206–223, London, UK, UK, 2002. Springer-Verlag.

[11] M. Au, P. Tsang, W. Susilo, and Y. Mu. Dynamic uni-
versal accumulators for ddh groups and their application to
attribute-based anonymous credential systems.
In M. Fis-
chlin, editor, Topics in Cryptology – CT-RSA 2009, volume
5473 of Lecture Notes in Computer Science, pages 295–308.
Springer Berlin / Heidelberg, 2009.

[12] J. Balasch, A. Rial, C. Troncoso, B. Preneel,

I. Ver-
bauwhede, and C. Geuens. PrETP: Privacy-preserving elec-
tronic toll pricing. In USENIX Security ’10, 2010.

pages 32–32, Berkeley, CA, USA, 2011. USENIX Associa-
tion.

[28] L. Nguyen. Accumulators from bilinear pairings and appli-

cations. In Proceedings of CT-RSA ’05, 2005.

[29] NTL: A Library

for

doing Number

Theory.

http://www.shoup.net/ntl/.

[30] T. Okamoto and S. Uchiyama. A new public-key cryptosys-
tem as secure as factoring. In K. Nyberg, editor, Advances
in Cryptology — EUROCRYPT’98, volume 1403 of Lecture
Notes in Computer Science, pages 308–318. Springer Berlin
/ Heidelberg, 1998. 10.1007/BFb0054135.

[31] P. Paillier. Public-key cryptosystems based on composite
degree residuosity classes.
In Proceedings of the 17th in-
ternational conference on Theory and application of cryp-
tographic techniques, EUROCRYPT’99, pages 223–238,
Berlin, Heidelberg, 1999. Springer-Verlag.

[32] T. P. Pedersen. Non-interactive and information-theoretic
secure veriﬁable secret sharing. In Proceedings of the 11th
Annual International Cryptology Conference on Advances
in Cryptology, CRYPTO ’91, pages 129–140, London, UK,
1992. Springer-Verlag.

[33] V. Shoup. Sequences of games: a tool for taming complexity
in security proofs. Cryptography ePrint Archive 2004/32,
2004.

[13] N. Bari´c and B. Pﬁtzmann. Collision-free accumulators and
fail-stop signature schemes without trees. In W. Fumy, ed-
itor, Advances in Cryptology (EUROCRYPT ’97), volume
1233 of Lecture Notes in Computer Science, pages 480–494.
Springer Berlin / Heidelberg, 1997.

[14] M. W. Bell. Virtual Worlds Research: Past, Present & Fu-

ture. Journal of Virtual Worls Research, 1(1), July 2008.

[15] J. Benaloh and M. de Mare. One-way accumulators: A de-
centralized alternative to digital signatures. In T. Helleseth,
editor, Advances in Cryptology (EUROCRYPT ’93), volume
765 of Lecture Notes in Computer Science, pages 274–285.
Springer Berlin / Heidelberg, 1994.

[16] J. Camenisch and A. Lysyanskaya. Dynamic accumulators
and application to efﬁcient revocation of anonymous creden-
tials. In M. Yung, editor, Advances in Cryptology (CRYPTO
2002), volume 2442 of Lecture Notes in Computer Science,
pages 101–120. Springer Berlin / Heidelberg, 2002.

[17] J. Camenisch and A. Lysyanskaya. Dynamic accumulators
and applications to efﬁcient revocation of anonymous cre-
dentials. Advances in Cryptology (Crypto’02), 2442:61–76,
2002.

[18] D. Chaum. Blind signatures for untraceable payments. In

CRYPTO, pages 199–203, 1982.

[19] D. Chaum, J.-H. Evertse, and J. Van De Graaf. An improved
protocol for demonstrating possession of discrete logarithms
and some generalizations.
In Proceedings of the 6th an-
nual international conference on Theory and application
of cryptographic techniques, EUROCRYPT’87, pages 127–
141, Berlin, Heidelberg, 1988. Springer-Verlag.

[20] R. Cramer and I. B. Damgard. Zero-knowledge proofs for ﬁ-
nite ﬁeld arithmetic, or: Can zero-knowledge be for free? In
IN PROC. CRYPTO, pages 424–441. Springer-Verlag, 1997.
[21] I. Damgard and E. Fujisaki. A statistically-hiding integer
commitment scheme based on groups with hidden order. In
Proceedings of the 8th International Conference on the The-
ory and Application of Cryptology and Information Secu-
rity: Advances in Cryptology, ASIACRYPT ’02, pages 125–
142, London, UK, UK, 2002. Springer-Verlag.

[22] T. El Gamal. A public key cryptosystem and a signature
scheme based on discrete logarithms.
In Proceedings of
CRYPTO 84 on Advances in cryptology, pages 10–18, New
York, NY, USA, 1985. Springer-Verlag New York, Inc.

[23] E. Fujisaki and T. Okamoto. Statistical zero knowledge pro-
tocols to prove modular polynomial relations. In Proceed-
ings of the 17th Annual International Cryptology Confer-
ence on Advances in Cryptology, pages 16–30, London, UK,
1997. Springer-Verlag.

[24] Y. Guo and S. Barnes. Virtual item purchase behavior in vir-
tual worlds: an exploratory investigation. Electronic Com-
merce Research, 9(1–2):97–113, 2009.

[25] LibEvent. http://monkey.org/ provos/libevent/.
[26] H. Lin and S. C-T. Cash trade within the magic circle: Free-
to-play game challenges and massively multiplayer online
game player responses. In Proceedings of DiGRA 2007: Sit-
uated Play, 2007.

[27] S. Meiklejohn, K. Mowery, S. Checkoway, and H. Shacham.
The phantom tollbooth: privacy-preserving electronic toll
collection in the presence of driver collusion. In Proceed-
ings of the 20th USENIX conference on Security, SEC’11,

