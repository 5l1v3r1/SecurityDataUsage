Advanced Probabilistic Couplings for Differential Privacy∗

Gilles Barthe

IMDEA Software Institute

Madrid, Spain

Benjamin Grégoire

Inria

Sophia-Antipolis, France

Noémie Fong

ENS

Paris, France
‡

Justin Hsu

University of Pennsylvania

Philadelphia, USA

†

Marco Gaboardi

University at Buffalo, SUNY

Buffalo, USA

Pierre-Yves Strub

IMDEA Software Institute

Madrid, Spain

ABSTRACT
Differential privacy is a promising formal approach to data privacy,
which provides a quantitative bound on the privacy cost of an al-
gorithm that operates on sensitive information. Several tools have
been developed for the formal veriﬁcation of differentially private
algorithms, including program logics and type systems. However,
these tools do not capture fundamental techniques that have emerged
in recent years, and cannot be used for reasoning about cutting-edge
differentially private algorithms. Existing techniques fail to handle
three broad classes of algorithms: 1) algorithms where privacy de-
pends on accuracy guarantees, 2) algorithms that are analyzed with
the advanced composition theorem, which shows slower growth in
the privacy cost, 3) algorithms that interactively accept adaptive
inputs.

We address these limitations with a new formalism extending
apRHL [6], a relational program logic that has been used for proving
differential privacy of non-interactive algorithms, and incorporating
aHL [11], a (non-relational) program logic for accuracy properties.
We illustrate our approach through a single running example, which
exempliﬁes the three classes of algorithms and explores new variants
of the Sparse Vector technique, a well-studied algorithm from the
privacy literature. We implement our logic in EasyCrypt, and for-
mally verify privacy. We also introduce a novel coupling technique
called optimal subset coupling that may be of independent interest.

1.

INTRODUCTION

Differential privacy, a rigorous and quantitative notion of sta-
tistical privacy, is one of the most promising formal deﬁnitions of
privacy to date. Since its initial formulation by Dwork et al. [19],
differential privacy has attracted substantial attention throughout
∗The
at
https://arxiv.org/abs/1606.07143.
†Partially supported by NSF grants CNS-1237235 and CNS-
1565365, and by EPSRC grant EP/M022358/1.
‡Partially supported by NSF grants TC-1065060 and TWC-1513694,
and a grant from the Simons Foundation (#360368 to Justin Hsu).

available

version

paper

this

full

of

is

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978391

computer science, including areas like databases, machine learning,
and optimization, and more.

There are several reasons for this success. For one, differential
privacy allows a formal trade-off between privacy and accuracy:
differentially private algorithms come with a privacy guarantee
expressed in terms of two parameters  (expressing the privacy cost)
and δ (expressing the probability of violating the privacy cost). For
both parameters, smaller values offer stronger privacy guarantees.
Another important advantage differential privacy is that it com-
poses well: differentially private algorithms can be easily combined
to build new private algorithms. The differential privacy literature
offers several composition theorems, differing in how the privacy
parameter of the larger algorithm depends on the parameters of the
components. These composition properties can also be used in inter-
active and adaptive scenarios where an adversary can decide which
algorithm to run depending on the outputs of previous algorithms.
Differential privacy’s clean composition properties also make it
an attractive target for an unusually diverse array of formal veriﬁ-
cation techniques. By now, there are tools that formally guarantee
differential privacy via relational program logics [2, 6], linear type
systems [25, 29, 42], interactive automata [50, 51], product pro-
grams [7], satisﬁability modulo theories [28], reﬁnement type sys-
tems [9], and more. While these systems formalize privacy through
a wide variety techniques, most of these approaches analyze a com-
position of private algorithms using the sequential composition
theorem of differential privacy, which guarantees that the resulting
algorithms have parameter  and δ equal to the sum of the parameters
of their components.

Recently, Barthe et al. [10] highlighted a close connection be-
tween approximate couplings and differential privacy which enables
formal veriﬁcation beyond sequential composition. Barthe et al.
[10] work with the relational program logic apRHL [6], extended
with a new composition principle called pointwise privacy. The
idea is to ﬁrst prove a restricted case of privacy—corresponding
roughly to privacy for a single output—and then combine the results
to prove the full differential privacy property. Combined with the
composition principle for approximate couplings, which generalizes
the sequential composition theorem, apRHL can express simple,
compositional proofs of algorithms like the one-side Laplace im-
plementation of the Exponential mechanism [17] and the Above
Threshold algorithm [17] while abstracting away reasoning about
probabilistic events. Existing privacy proofs for these algorithms,
even on paper, involve ad hoc computation of probabilities.

While apRHL substantially expands the range of formal veriﬁ-
cation in differential privacy, there are still private algorithms that
apRHL cannot verify. Roughly, there are three missing pieces:

55• Accuracy-dependent privacy. Some algorithms are only pri-

vate if an accuracy property holds.

• Advanced composition. This principle shows slower growth
in the privacy cost, in exchange for a small probability of
violating privacy. The proof involves an technical martingale
concentration argument.

• Interactive privacy. Some private algorithms are interactive,
receiving a continuous sequence of adaptive inputs while
producing intermediate outputs.

These three missing pieces correspond to three fundamental prin-
ciples of differential privacy. While there are many algorithms from
the privacy literature that use one (or more) of these three features, to
structure our presentation we will work with a variant of the Sparse
Vector technique based on the Between Thresholds algorithm [13],
a single unifying example that uses all three features (§ 2). After
reviewing some technical preliminaries about differential privacy,
approximate couplings, and the logic apRHL (§ 3), we describe
extensions to apRHL to verify privacy for new classes of algorithms.
• New proof rules that allow reasoning within apRHL while
assuming an accuracy property, incorporating accuracy proofs
from the Hoare logic aHL [11] (§ 4). We demonstrate these
rules on a classic example of accuracy-dependent privacy: the
Propose-test-release framework [16, 48].

• A proof rule that analyzes loops using the advanced composi-
tion principle; soundness relies on a novel generalization of
advanced composition to approximate couplings (§ 5).

• New proof rules for adversaries, external procedure calls that

model an adaptive source of inputs (§ 6).

• Orthogonal to reasoning about accuracy, advanced composi-
tion, and adversarial inputs, we introduce a general construc-
tion that may be of independent interest called the optimal
subset coupling. This construction gives an approximate lift-
ing relating subsets that yields the best possible , and we use
this construction to give a new interval coupling rule for the
Laplace distribution (§ 7).

We then show how to combine these ingredients to verify our
main running example, the Between Thresholds algorithm (§ 8). We
ﬁnish with related work (§ 9) and some concluding thoughts (§ 10).

2. MOTIVATING EXAMPLE

Before diving into the technical details we’ll ﬁrst present our
motivating example, which involves accuracy-dependent privacy,
advanced composition, and interactive privacy. We ﬁrst review the
deﬁnition of differential privacy, a relational property about proba-
bilistic programs proposed by Dwork, McSherry, Nissim and Smith.
Deﬁnition 1. Let the adjacency relation be Φ ⊆ A × A, and , δ >
0. A program M : A → Distr(B) satisﬁes (, δ)-differential
privacy with respect to Φ if for every pair of inputs a, a(cid:48) ∈ A such
that Φ(a, a(cid:48)) and every subset of outputs S ⊆ B, we have
y←M a(cid:48)[y ∈ S] + δ.
When δ = 0, we say that M is -differentially private.

[y ∈ S] ≤ exp() Pr

y←M a

Pr

Intuitively, Φ relates inputs that differ in a single individual’s data.
Then, differential privacy requires that the two resulting distributions
on outputs should be close.

ASVbt(a, b, M, N, d) :=
i ← 0; l ← [];
u $← L/2(0);
A ← a − u; B ← b + u;
while i < N ∧ |l| < M do
q ← A(l);
S $← L(cid:48)/3(evalQ(q, d));
if (A ≤ S ≤ B) then l ← i :: l;
i ← i + 1;

return l

Figure 1: Sparse Vector for Between Thresholds

Our motivating example is Adaptive Sparse Vector for Between
Thresholds (ASVbt), a variant of the Sparse Vector algorithm. Our
algorithm takes a stream of numeric queries as input, and answers
only the queries that take a value within some range. The main
beneﬁt of Sparse Vector is that queries that take a value outside
the range do not increase the privacy cost, even though testing
whether whether the query is (approximately) in the range involves
private data. Sparse Vector is an appealing example, because of its
popularity and its difﬁculty. In particular, the privacy proof of Above
Threshold is non-compositional and notoriously tricky, and several
variants1 of the algorithm were supposedly proved to be private
but were later shown to be non-private (Lyu et al. [34] provide a
comprehensive survey).

The code of ASVbt is shown in Fig. 1. At a high level, the algo-
rithm accepts a stream of adversarially chosen queries and produces
a list of queries whose answer lies (approximately) between two
threshold parameters a and b. The algorithm computes noisy ver-
sions A and B of a and b using the Laplace mechanism L, which
we review in the next section, and then performs an interactive loop
for a ﬁxed number (N) of iterations. Each step, a stateful adver-
sary A receives the current list l of queries whose answer on input
database d lies between [A, B] and selects a new query q. If its noisy
answer S lies in [A, B] and there have been fewer than M queries
between threshold, the algorithm adds q to the list l. Our algorithm
differs from standard presentations of Adaptive Sparse Vector [17]
in two signiﬁcant respects:

• we use BetweenThresholds rather than AboveThreshold

for deciding whether to add a query to the list;

• we do not rerandomize the noise on the thresholds each time
a query is added to l; therefore, our algorithm adds less noise.

ASVbt satisﬁes the following privacy guarantee.

Theorem 2. Let  and δ both be in (0, 1). Set

4(cid:112)2M ln(2/δ)



,

(cid:48) (cid:44)


and suppose a and b are such that

b − a ≥ 6

(cid:48) ln(4/

(cid:48)

) +

4


ln(2/δ).

1There exist multiple versions of Sparse Vector. The earliest ref-
erence seems to be Dwork et al. [20]; several reﬁnements were
proposed by Hardt and Rothblum [30], Roth and Roughgarden [44].
Applications often use their own variants, e.g. Shokri and Shmatikov
[46]. The most canonical version of the algorithm is the version
by Dwork and Roth [17].

56The level of privacy depends on the sensitivity of the query, which
measures how far the function may differ on two related inputs.
Roughly, adding the same level of Laplace noise to a higher sensi-
tivity query will be less private.
Deﬁnition 4 (Sensitivity). A function F : A → Z is k-sensitive
with respect to Φ ⊆ A × A if |F (a1) − F (a2)| ≤ k for every
a1, a2 ∈ A such that Φ(a1, a2).

The Laplace mechanism satisﬁes an accuracy speciﬁcation.

Proposition 5 (Laplace accuracy). Let , β > 0, and suppose x is
the result from running L(t). Then |x−t| ≤ 1
β with probability
at least 1 − β.

 ln 1

Besides private primitives, the other main tools for construct-
ing private programs are the composition theorems. These results
describe the privacy level for a combination of private programs—
say, calls to the Laplace mechanism. We will use a bit of nota-
tion for compositions. Let {fi} be a set of n functions of type
A → D → Distr(A). Denote the n-fold composition f n : A →
D → Distr(A) by

f k(a, d) =

unit a
bind f k−1(a, d) fk(−, d)

: k = 0
: k ≥ 1.

Here, unit : A → Distr(A) and bind : Distr(A) → (A →
Distr(B)) → Distr(B) are the monadic operations for distribu-
tions. They satisfy the following equalities:

(cid:40)

(cid:26) 1 if a = b
(cid:88)

0 otherwise

b

unit(a)(b) =

and for f : A → Distr(B) and F : A → B → Distr(C) ,

(bind f F )(a)(c) =

f (a)(b) F (a)(b)(c).

We will also use this composition notation when the functions {fi}
have type A → Distr(A), simply dropping the parameter d above
when deﬁning f n : A → Distr(A).

Then, the most basic composition theorem in differential privacy

is sequential composition.
: A → D →
Theorem 6 (Sequential composition). Let fi
Distr(A) be a sequence of n functions, such that for every ﬁxed
a ∈ A, the functions fi(a) : D → Distr(A) are (i, δi)-
differentially private for some adjacency relation on D. Then for
every initial value a ∈ A, the composition f n(a) : D → Distr(A)
is (∗, δ∗)-differentially private for

n(cid:88)

n(cid:88)

∗


=

i

and

∗

δ

=

δi.

If all adversarial queries q are 1-sensitive (i.e. |evalQ(q, d) −
evalQ(q, d(cid:48))| ≤ 1 for every adjacent databases d and d(cid:48)), then
ASVbt is (, δ)-differentially private.

The formal proof of this theorem, which we have veriﬁed in an
implementation of our logic within the EasyCrypt system, involves
several features:

• reasoning principles for mixing accuracy and privacy guar-
antees, using a combination of relational logics [6, 10] and
non-relational logics [11];

• a generalization of the advanced composition theorem for

handling the body of the loop;

• an adversary rule for handling interactive inputs in the loop;

and

• a new reasoning principle, called optimal subset coupling, for

handling the Laplace mechanism in the loop.

We stress that the use of pointwise equality, which is required for
proving privacy of between thresholds, makes the proof signiﬁcantly
more challenging than other examples involving solely adaptive
adversaries, advanced composition, and accuracy-dependent privacy.
We remark that Bun et al. [13] proposed Between Threshold and
proved its privacy. Their proof does not use advanced composition,
and follows from a somewhat complicated calculations about the
probabilities of certain events. Our proof demonstrates the power of
approximate liftings: somewhat surprisingly, we arrive at an elegant
privacy proof without probabilistic reasoning.

3. BACKGROUND

is a distribution over B if(cid:80)

Before presenting our new extensions, we ﬁrst review some pre-
liminaries about differential privacy, the connection to approximate
liftings, the program logic apRHL [6] and its extension apRHL+
[10], and the union bound logic aHL [11].
3.1 Mathematical preliminaries
To avoid measure-theoretic issues, we base our technical develop-
ment on distributions over discrete sets B. A function µ : B → R≥0
b∈supp(µ) µ(b) = 1. As usual, the sup-
port supp(µ) is the subset of B with non-zero weight under µ. We
write Distr(B) for the set of discrete distributions over B. Equality
of distributions is deﬁned as pointwise equality of functions.
We will also use marginal distributions. Formally, the ﬁrst and
second marginals of a distribution µ ∈ Distr(B1 × B2) are simply
the projections: the distributions π1(µ) ∈ Distr(B1) and π2(µ) ∈
Distr(B2) given by

(cid:88)

(cid:88)

b2∈B2

π1(µ)(b1) =

µ(b1, b2)

π2(µ)(b2) =

µ(b1, b2).

i=1

i=1

That is, the epsilons and deltas sum up through composition.

b1∈B1

3.2 Differential privacy

We will need several tools from differential privacy; readers
should consult the textbook by Dwork and Roth [17] for a more
comprehensive introduction. Most differentially private algorithms
are constructed from private primitive operations. The most famous
primitive is the Laplace mechanism.

Deﬁnition 3 (Laplace mechanism [19]). Let  > 0. The (discrete)
Laplace mechanism L : Z → Distr(Z) is deﬁned by L(t) =
t + ν, where ν ∈ Z with probability proportional to

Pr[ν] ∝ exp (− · |ν|).

The sequential composition theorem is quite useful, and is the
main principle supporting modular veriﬁcation of differential pri-
vacy. However, there is another composition theorem, known as
advanced composition [22]. Instead of summing up the privacy
costs, this theorem gives slower growth of  in exchange for in-
creasing the δ parameter. Advanced composition is an extremely
common tool for analyzing differentially private algorithms, but it
is not supported by most formal veriﬁcation systems today.
: A → D →
Theorem 7 (Advanced composition). Let fi
Distr(A) be a sequence of n functions, such that for every ﬁxed a ∈
A, the functions fi(a) : D → Distr(A) are (, δ)-differentially

57private for some adjacency relation on D. Then, for every a ∈ A
and ω ∈ (0, 1), the composed function f n(a) : D → Distr(A) is
(∗, δ∗)-differentially private for

 + n(e − 1)

and

∗

δ

= nδ + ω.

(cid:16)(cid:112)2n ln(1/ω)
(cid:17)

∗


=

In particular, if we have (cid:48) ∈ (0, 1), ω ∈ (0, 1/2), and

2(cid:112)2n ln(1/ω)

(cid:48)

,

 =

a short calculation shows that
differentially private.

the function f n is ((cid:48), δ∗)-

Kairouz et al. [32] propose sharper versions of this composition
theorem, including a provably optimal version and a version for the
heterogeneous case when the privacy level (i, δi) may depend on
i. We will use Theorem 7 for simplicity, but our techniques enable
other composition theorems to be easily plugged in.
3.3 Approximate liftings

While the deﬁnition of differential privacy seems to be a straight-
forward property about probabilities in two distributions, a recent
line of work initiated by Barthe et al. [6] and subsequently devel-
oped [2, 10] shows that differential privacy is a consequence of an
approximate version of probabilistic coupling, called approximate
liftings. Couplings are a long-standing tool in probability theory for
analyzing pairs of distributions, but the relation between differential
privacy and approximate couplings is still being explored.

Unlike couplings, where there is a single accepted deﬁnition,
several incomparable notions of approximate liftings have been
proposed. The ﬁrst deﬁnition is by Barthe et al. [6] but has some
technical shortcomings; we will use a more recent deﬁnition by
Barthe and Olmedo [2]. We begin by deﬁning a distance on distribu-
tions, closely related to (, δ)-differential privacy.
Deﬁnition 8 (Barthe and Olmedo [2]). Let  ≥ 0. The -DP diver-
gence ∆(µ1, µ2) between two distributions µ1 ∈ Distr(A) and
µ2 ∈ Distr(A) is deﬁned as

(cid:18)

(cid:19)

sup
S⊆A

Pr
x←µ1

[x ∈ S] − exp() Pr
x←µ2

[x ∈ S]

.

For the connection to differential privacy, it is not hard to see
that if M : D → Distr(A), then M is (, δ)-differentially
inputs d, d(cid:48), we have
private iff for every pair of adjacent
∆(M (d), M (d(cid:48))) ≤ δ. This distance is also central to the deﬁ-
nition of approximate liftings.
Deﬁnition 9 (Barthe and Olmedo [2]). Two distributions µ1 ∈
Distr(A1) and µ2 ∈ Distr(A2) are related by the (, δ)-lifting
of Ψ ⊆ A1 × A2, written µ1 Ψ(cid:93)(,δ) µ2, if there exist two witness
distributions µL ∈ Distr(A1 × A2) and µR ∈ Distr(A1 × A2)
such that

1. π1(µL) = µ1 and π2(µR) = µ2;
2. supp(µL) ⊆ Ψ and supp(µR) ⊆ Ψ; and
3. ∆(µL, µR) ≤ δ.
Approximate liftings generalize several concepts for relating dis-
tributions. When µL = µR, we have a (0, 0)-lifting, sometimes
called an exact probabilistic lifting. Such a lifting, with any Ψ,
implies a probabilistic coupling between (µ1, µ2).

Approximate liftings satisfy the following property, also known

as the fundamental lemma of approximate liftings.

Lemma 10 (Barthe and Olmedo [2]). Let E1 ⊆ B1, E2 ⊆ B2,
µ1 ∈ Distr(B1) and µ2 ∈ Distr(B2). Let

Ψ = {(x1, x2) ∈ B1 × B2 | x1 ∈ E1 ⇒ x2 ∈ E2}.

If µ1 Ψ(cid:93)(,δ) µ2, then

Pr

x1←µ1

[x1 ∈ E1] ≤ exp() Pr
x2←µ2

[x2 ∈ E2] + δ.

Using this lemma, one can prove that differential privacy is equiv-

alent to a particular form of approximate lifting.
Proposition 11 (Barthe and Olmedo [2]). A probabilistic compu-
tation M : D → Distr(A) is (, δ)-differentially private for adja-
cency relation Φ iff

M (a) =(cid:93)(,δ) M (a

(cid:48)

)

for every two adjacent inputs a and a(cid:48).

Approximate liftings form the basis of the program logic apRHL,

to which we turn next.
3.4 The relational program logic

The logic apRHL, originally proposed by Barthe et al. [6], is a
relational program logic for verifying differential privacy. We take
this logic as our point of departure; we brieﬂy recall the main points
here.

We consider a simple imperative language with random sampling,
oracle calls and adversary calls; the latter two are new to the present
work. The set of commands is deﬁned inductively:
C ::= skip
| C; C
| X ← E
| X $← L(E)
| if E then C else C
| while E do C
| (X , . . . ,X ) ← A(E, . . . ,E)
| (X , . . . ,X ) ← O(E, . . . ,E)

noop
sequencing
deterministic assignment
Laplace mechanism
conditional
while loop
adversary call
procedure call

where X is a set of variables and E is a set of expressions. Vari-
ables and expressions are typed, and range over standard types like
booleans, integers, databases, queries, lists, etc. We omit the seman-
tics of expressions, which is standard. Commands are interpreted
as maps State → Distr(State); this is also a standard choice
(e.g., see Barthe et al. [6]).2 We will write [[c]]m to mean the output
distribution of command c, executed on input memory m.

An apRHL judgment has the form

(cid:96) c ∼(cid:104),δ(cid:105) c

(cid:48)

: Φ =⇒ Ψ.

Reminiscent of Hoare logic, Φ represents the pre-condition while Ψ
represents the post-condition. Both Φ and Ψ are ﬁrst order formulas
over the program variables. For expressing relational properties,
program variables are tagged with either (cid:104)1(cid:105) or (cid:104)2(cid:105) to indicate
whether they belong to c or c(cid:48) respectively. For instance, we can
assert that the variable x differs by at most 1 in the two runs with
the assertion |x(cid:104)1(cid:105) − x(cid:104)2(cid:105)| ≤ 1.

Crucially, the post-condition Ψ is interpreted as an approximate
lifting over the output distributions. More formally, the judgment is
valid iff for every two memories m1 and m2 such that m1 Φ m2,
we have

([[c1]]m1 ) Ψ(cid:93)(,δ) ([[c2]]m2 ).

2We will assume that commands are terminating on all executions.
The logic apRHL can also reason about possibly non-terminating
programs by working with sub-distributions instead of distributions.

58We present selected rules, taken from prior presentations of apRHL
[6, 10] in Fig. 2; F V (Φ) denotes the set of program variables in
the assertion Φ, and M V (c) denotes the set of program variables
that are modiﬁed (i.e., written) by program c. Many of the rules
bear a resemblance to the standard Hoare logic rules. The rules
[ASSN] and [COND] are relational versions of the assignment and
conditional rules; note that [COND] assumes that the two guards are
equal in the pre-condition. The rule [SEQ] reﬂects the composition
principle of approximate liftings, where the indices  and δ add; this
rule generalizes the standard composition theorem of differential
privacy. The rule [WHILE] extends this reasoning to loops with
a bound number of iterations, again assuming that the guards are
equal in both programs.

The next two rules, [LAPNULL] and [LAPGEN], are for relating
two sampling instructions from the Laplace distribution. Intuitively
[LAPNULL] models adding identical noise on both sides, so that
the distance between the samples (y1(cid:104)1(cid:105), y2(cid:104)2(cid:105)) is equal to the
distance between the means (e1(cid:104)1(cid:105), e2(cid:104)2(cid:105)). [LAPGEN] is a general
rule for assuming that the two samples are shifted and related by
y1(cid:104)1(cid:105) + k = y2(cid:104)2(cid:105); the privacy cost depends on how far the means
(e1(cid:104)1(cid:105) + k, e2(cid:104)2(cid:105)) are.

The ﬁnal group of rules are the structural rules. Besides the usual
rules for consequence and framing ([CONSEQ] and [FRAME]), the
most interesting rule is the pointwise equality rule [PW-EQ]. This
rule proves differential privacy by showing a pointwise judgment
for each possible output value i, and is the key tool for supporting
privacy proofs beyond the standard composition theorems.
3.5 The union bound logic

When reasoning about privacy, we will sometimes need to prove
probabilistic bounds on accuracy. Since accuracy properties are not
relational, we cannot verify them in apRHL. There is a long history
of research for formally verifying probabilistic properties, and we
are free to choose any of these techniques to interface with our logic.
In our favor, we are interested in simple accuracy properties of the
form Pr[Ψ] < β, where Ψ is an assertion on the program memory.
We call such assertions bad event assertions, since they state that the
probability of some event Ψ—the “bad event”—is at most β. We
will prove accuracy assertions in the Hoare logic aHL [11], which
is specialized to prove bad event assertions.

We will highlight just the features of aHL needed for our purposes;
readers should consult Barthe et al. [11] for a complete presentation.
Concretely, aHL judgments have the following form:

(cid:96)β c : Φ =⇒ Ψ,

where Φ and Ψ are (non-probabilistic) assertions over program
memories, and β ∈ [0, 1] is a real-valued index. Assertions in aHL
are non-relational, and mention program variables from a single
memory instead of program variables tagged with (cid:104)1(cid:105) or (cid:104)2(cid:105). To
mediate between the non-relational assertions of aHL and the rela-
tional assertions of apRHL, from a non-relational assertion Φ we
can deﬁne relational assertions Φ(cid:104)1(cid:105) and Φ(cid:104)2(cid:105) by interpreting Φ
where all program variables are tagged with (cid:104)1(cid:105) or (cid:104)2(cid:105) respectively.
The semantics of commands is unchanged from apRHL; we
interpret commands as maps State → Distr(State). The above
judgement means: for any initial memory satisfying Φ, the prob-
ability that ¬Ψ holds in the resulting distribution on memories is
at most β. For instance, the accuracy speciﬁcation of the Laplace
mechanism (Proposition 5) is given by the following aHL judgment:

(cid:96)β y $← L(e) : (cid:62) =⇒ |y − e| ≤ 1


log

1
β

for every β ∈ (0, 1).

4. ACCURACY-DEPENDENT PRIVACY

Let us begin with our ﬁrst class of private algorithms, where
privacy follows from an accuracy property. For our purposes, these
accuracy properties are non-relational probabilistic properties that
hold on a single execution of a single program. For instance, the
assertion Pr[x > 0] < 0.2, stating that the probability x is positive
is at most 0.2, is an accuracy property. Accuracy properties appear
in privacy proofs in a variety of ways. For instance, they may imply
that the privacy cost  is smaller than expected. Or, privacy may be
conditional: if the accuracy property holds then we have differential
privacy, otherwise the algorithm fails and there is no guarantee.
Programs in the latter case satisfy (, δ)-differential privacy, where
the probability of failure is included in δ.
4.1 Up-to-bad reasoning

To integrate accuracy assertions into apRHL, we will use a
technique from cryptographic veriﬁcation: up-to-bad reasoning.
Roughly speaking, rather than directly proving the equality lifting
corresponding to differential privacy:

µ1 (=)(cid:93)(,δ) µ2,

we will prove a conditional, up-to-bad lifting:

µ1 {(x1, x2) | (¬Φ(x1, x2) → x1 = x2)}(cid:93)(,δ) µ2.

Here, Φ is an assertion involving just variables from one side.
Roughly speaking, the lifting shows that if the bad event Φ does not
hold, then we have differential privacy. Then, we conclude the proof
with a structural rule that combines the bad event assertion—proved
externally in aHL—with the up-to-bad lifting, removing the bad
event while adjusting the privacy parameters (, δ).

To support this reasoning in our program logic, we propose the
two rules in Fig. 3. The rules, [UTB-L] and [UTB-R], internalize
an approximate version of up-to-bad reasoning. If the assertion Θ
holds, then we have the (, δ)-lifting of equality. So, if we know
the probability of ¬Θ is at most δ(cid:48), then we can show the (, δ +
δ(cid:48))-differential privacy when Θ is a property of the ﬁrst run, and
(, δ + eδ(cid:48))-differential privacy when Θ is a property of the second
run. The asymmetry in the left and right versions of the rule reﬂects
the asymmetric deﬁnition of approximate lifting, which is in turn
inspired by the asymmetric deﬁnition of differential privacy.

In order to include these rules, we show that they are valid. To
prove the equality lifting for privacy, we would like to use the equiv-
alence in Proposition 11. However, there is a catch: we only know
that the distributions over e are differentially private—the distri-
butions over the whole memory may not be differentially private.
Therefore, we will use a new property of approximate liftings: they
are well-behaved when mapping the underlying distribution.
Proposition 12. For a function f : A → B, let f (cid:93): Distr(A) →
Distr(B) denote function lifted to a map on distributions. If f is
surjective, and R is a relation on B, then

µ1 {(x1, x2) | f (x1) R f (x2)}(cid:93)(,δ) µ2

if and only if

f (cid:93) (µ1) {(y1, y2) | y1 R y2}(cid:93)(,δ)f (cid:93) (µ2).

In particular, if we have a set E of equivalence classes of A
and the distribution µ/E : Distr(E) represents the probability of
being in each equivalence class, taking f : A → E mapping an
element to its equivalence class and R to be the equivalence relation
gives a result by Barthe and Olmedo [2, Proposition 8]:
µ1 (=E)(cid:93)(,δ) µ2 ⇐⇒ µ1/E (=)(cid:93)(,δ) µ2/E.

59ASSN (cid:96) x1 ← e1 ∼(cid:104)0,0(cid:105) x2 ← e2 : Ψ{e1(cid:104)1(cid:105), e2(cid:104)2(cid:105)/x1(cid:104)1(cid:105), x2(cid:104)2(cid:105)} =⇒ Ψ

COND

(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Φ ∧ b1(cid:104)1(cid:105) =⇒ Ψ
(cid:96) if b1 then c1 else c

1 ∼(cid:104),δ(cid:105) if b2 then c2 else c
(cid:48)

(cid:96) c

1 ∼(cid:104),δ(cid:105) c
(cid:48)

2 : Φ ∧ ¬b1(cid:104)1(cid:105) =⇒ Ψ
(cid:48)
2 : Φ ∧ b1(cid:104)1(cid:105) = b2(cid:104)2(cid:105) =⇒ Ψ
(cid:48)

SEQ

(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Φ =⇒ Ψ
(cid:48)

1 ∼(cid:104)(cid:48),δ(cid:48)(cid:105) c
(cid:96) c
(cid:48)
(cid:48)
(cid:48)
2 : Ψ
1 ∼(cid:104)+(cid:48),δ+δ(cid:48)(cid:105) c2; c
2 : Φ =⇒ Ψ
(cid:48)
(cid:48)

(cid:96) c1; c

=⇒ Ψ

WHILE

(cid:96) c1 ∼(cid:104)k,δk(cid:105) c2 : Θ ∧ b1(cid:104)1(cid:105) ∧ b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) = k =⇒ Θ ∧ b1(cid:104)1(cid:105) = b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) < k
(cid:96) while b1 do c1 ∼(cid:104)(cid:80)n

|= Θ ∧ e(cid:104)1(cid:105) ≤ 0 → ¬b1(cid:104)1(cid:105)
k=1 δk(cid:105) while b2 do c2 : Θ ∧ b1(cid:104)1(cid:105) = b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) ≤ n =⇒ Θ ∧ ¬b1(cid:104)1(cid:105) ∧ ¬b2(cid:104)2(cid:105)

k=1 k,(cid:80)n

LAPNULL

(cid:96) y1 $← L(e1) ∼(cid:104)0,0(cid:105) y2 $← L(e2) : (cid:62) =⇒ y1(cid:104)1(cid:105) − y2(cid:104)2(cid:105) = e1(cid:104)1(cid:105) − e2(cid:104)2(cid:105)

y1 /∈ F V (e1)

y2 /∈ F V (e2)

LAPGEN (cid:96) y1 $← L(e1) ∼(cid:104)k(cid:48)·,0(cid:105) y2 $← L(e2) : |k + e1(cid:104)1(cid:105) − e2(cid:104)2(cid:105)| ≤ k
(cid:48) → Ψ

(cid:48) ∼(cid:104)(cid:48),δ(cid:48)(cid:105) c1 : c2 =⇒ Ψ
(cid:48)

(cid:96) Φ

(cid:48)

=⇒ y1(cid:104)1(cid:105) + k = y2(cid:104)2(cid:105)

(cid:48) ≤ 



(cid:48) ≤ δ

δ

CONSEQ

(cid:48)

|= Φ → Φ

|= Ψ
(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Φ =⇒ Ψ

FRAME

(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Φ =⇒ Ψ

F V (Θ) ∩ M V (c1, c2) = ∅

(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Φ ∧ Θ =⇒ Ψ ∧ Θ

PW-EQ

∀i. (cid:96) c1 ∼(cid:104),δi(cid:105) c2 : Φ =⇒ x(cid:104)1(cid:105) = i → x(cid:104)2(cid:105) = i
(cid:96) c1 ∼(cid:104),(cid:80)

i∈I δi(cid:105) c2 : Φ =⇒ x(cid:104)1(cid:105) = x(cid:104)2(cid:105)

Figure 2: Selected proof rules of apRHL [6, 10]

|= Φ → Φ0(cid:104)1(cid:105)

|= Φ → Φ0(cid:104)2(cid:105)

UTB-L

UTB-R

(cid:96) c ∼(cid:104),δ(cid:105) c

(cid:48)

(cid:96) c ∼(cid:104),δ+δ(cid:48)(cid:105) c

(cid:96) c ∼(cid:104),δ(cid:105) c

(cid:48)

(cid:96) c ∼(cid:104),δ+eδ(cid:48)(cid:105) c

(cid:48)

: Φ =⇒ Θ(cid:104)1(cid:105) → e(cid:104)1(cid:105) = e(cid:104)2(cid:105)
: Φ =⇒ e(cid:104)1(cid:105) = e(cid:104)2(cid:105)
: Φ =⇒ Θ(cid:104)2(cid:105) → e(cid:104)1(cid:105) = e(cid:104)2(cid:105)
: Φ =⇒ e(cid:104)1(cid:105) = e(cid:104)2(cid:105)

(cid:48)

(cid:96)δ(cid:48) c : Φ0 =⇒ Θ

(cid:96)δ(cid:48) c

(cid:48)

: Φ0 =⇒ Θ

Figure 3: Up-to-bad rules

This result allows us to prove an approximate lifting for a distri-
bution over memories by proving an approximting lifting for the
distribution over a single variable or expression. We defer the details
of the proof to the full version. Now, we are ready to show soundness
of the up-to-bad rules.

Theorem 13. The rules [UTB-L] and [UTB-R] are sound.

Proof. We will start with [UTB-L]. Take any two memories
(m1, m2) such that (m1, m2) |= Φ, and let µ1, µ2 be [[c]]m1 and
[[c(cid:48)]]m2 respectively. Note that m1 |= Φ0. By validity of the premise,
we know

[¬Θ] ≤ δ

(cid:48)

Pr
m∼µ1

and we have a pair of witnesses µL, µR for the relation

R (cid:44) Θ(cid:104)1(cid:105) → e(cid:104)1(cid:105) = e(cid:104)2(cid:105),

such that ∆(µL, µR) ≤ δ. Our goal is to show that the marginal
distributions of [[e]] in µ1, µ2 satisfy (, δ + δ(cid:48))-differential privacy,
i.e. for any set S,

Pr
m∼µ1

[[[e]]m ∈ S] ≤ e Pr
m(cid:48)∼µ2

[[[e]]m(cid:48) ∈ S] + δ + δ

(cid:48)

.

To begin, we know that

Pr
m∼µ1

[[[e]]m ∈ S] = Pr
m∼µ1

[[[e]]m ∈ S ∧ m |= Θ]
[[[e]]m ∈ S ∧ m |= ¬Θ]
[[[e]]m ∈ S ∧ m |= Θ] + δ

(cid:48)

+ Pr
m∼µ1
≤ Pr
m∼µ1

since the probability of ¬Θ in µ1 is at most δ(cid:48). Now, we can con-
clude with the coupling:

[[[e]]m ∈ S ∧ m |= Θ] + δ

(cid:48)

[[[e]]m ∈ S ∧ m |= Θ] + δ

(cid:48)

[[[e]]m ∈ S ∧ m |= Θ] + δ + δ

(cid:48)

Pr
m∼µ1
=
≤ e
≤ e

Pr

(m,m(cid:48))∼µL
Pr

(m,m(cid:48))∼µR

Pr

m ∈ S] + δ + δ
(cid:48)
[[[e]]
(m,m(cid:48))∼µR
m ∈ S] + δ + δ
(cid:48)
[[[e]]

,

(cid:48)

(cid:48)

= e Pr

m(cid:48)∼µ2

where the ﬁrst inequality uses ∆(µL, µR) ≤ δ, while the second
inequality uses (m, m(cid:48)) ∈ supp(µR). So, the distributions of [[e]]
satisfy differential privacy. By Proposition 11 and Proposition 12

60with equivalence classes deﬁned by the value of [[e]], we can con-
clude soundness of [UTB-L].

We can show soundness of [UTB-R] in a similar way. Let µ1, µ2

be as above. We can use the coupling as follows:

Pr
m∼µ1
=
≤ e

= e

+ e
≤ e

[[[e]]m ∈ S]

Pr

(m,m(cid:48))∼µL
Pr

(m,m(cid:48))∼µR

[[[e]]m ∈ S]

Pr

(m,m(cid:48))∼µR

Pr

(m,m(cid:48))∼µR

Pr

(m,m(cid:48))∼µR

[[[e]]m ∈ S] + δ
[[[e]]m ∈ S ∧ m
[[[e]]m ∈ S ∧ m
m ∈ S] + e
(cid:48)
[[[e]]
[[[e]]m(cid:48) ∈ S] + e Pr
m(cid:48)∼µ2
[[[e]]m(cid:48) ∈ S] + δ + eδ
(cid:48)

= e Pr
m(cid:48)∼µ2
≤ e Pr
m(cid:48)∼µ2

(cid:48) |= Θ]
(cid:48) |= ¬Θ] + δ

(cid:48) |= ¬Θ] + δ

(m,m(cid:48))∼µR

[m

Pr
(cid:48) |= ¬Θ] + δ

[m

The ﬁrst inequality uses the bound on the distance between the wit-
nesses: ∆(µL, µR) ≤ δ. The second inequality uses the support of
µR. The ﬁnal inequality uses the fact that Prm(cid:48)∼µ2 [m(cid:48) |= ¬Θ] ≤
δ(cid:48). Since the distributions of [[e]] in µ1, µ2 satisfy (, δ + eδ(cid:48))-
differential privacy, we can again use Proposition 11 and Proposi-
tion 12 to show [UTB-R] is sound.
4.2 Propose-Test-Release

To give a small example of up-to-bad reasoning, we can prove
privacy for the Propose-Test-Release (PTR) framework [16, 48], a
classic example of privacy depending on an accuracy guarantee. The
goal is to release the answer to a function f. Rather than adding
noise directly to the answer (which may be non-numeric), PTR
estimates the distance to instability of the database d with respect
to f, denoted DistToInst f (d). This quantity measures the distance
from d to the closest database d(cid:48) such that f (d) (cid:54)= f (d(cid:48)), where
adjacent databases are at distance 1. We will use the following two
properties of DistToInst:

DistToInst f (d) > 1 → ∀d
Adj(d, d

(cid:48)

(cid:48)

) → |DistToInst f (d) − DistToInst f (d

(cid:48)

) → f (d) = f (d
(cid:48)
)| ≤ 1

(cid:48)

. (Adj(d, d

))

Since the distance itself is private information, PTR ﬁrst adds
noise to the distance, calling the noisy result dist. If it is large
enough, then PTR returns the value of f with no noise. Otherwise,
PTR returns a default value ⊥. In code:

dist $← L(DistToInst f (d));
if dist > ln(1/δ)/ + 1 then

r ← f (d);
r ← ⊥;

else

return r

The key to the privacy of PTR is that if the noise when estimating
dist is not too large, then there are two cases. If dist is large, then
there is no privacy cost for releasing the value of q when dist is
large. Otherwise, we return a default value ⊥ revealing nothing. In
either case, we just have privacy cost  from computing the noisy
distance. If the noise when estimating dist is too large (happening
with probability at most δ), we may violate privacy. So, we get an
(, δ)-private algorithm.

Theorem 14. PTR is (, δ)-differentially private for , δ > 0.

Proof sketch. To prove differential privacy, we will use the rule
[UTB-L]. We can take the event Θ to hold exactly when the noise
is not too large:

Θ (cid:44) |dist − DistToInst f (d)| < ln(1/δ)/.

Then, we couple the noise to be the same, so that we take the same
branch in both runs. Then, under assumption Θ, we know that if we
estimate that the distance to instability is large and we take the ﬁrst
branch, then in fact f (d(cid:104)1(cid:105)) = f (d(cid:104)2(cid:105)) as desired. Finally, using a
tail bound for the Laplace distribution in aHL gives

(cid:96)δ c : Φ(cid:104)1(cid:105) =⇒ Θ,

and rule [UTB-L] gives (, δ)-differential privacy.

5. ADVANCED COMPOSITION

Advanced composition is a key tool for giving a more precise
privacy analysis of a composition of private programs. In this section,
we extend apRHL with a new loop rule that supports advanced
composition for arbitrary invariants and we show how the rule can
be applied for proving privacy of a non-interactive variant of ASVbt.
Before presenting our solution, we stress that there are some tech-
nical challenges in extending apRHL with advanced composition.
On the one hand, apRHL derives its expressiveness from its ability
to reason about arbitrary approximate liftings, and not simply about
approximate liftings for the equality relation; as a consequence,
an advanced composition rule for apRHL should support approxi-
mate liftings in order to be useful (in fact, an advanced composition
rule for just approximate liftings of equality would be too weak
for verifying our running example). On the other hand, the proof
of advanced composition is substantially more technical than the
proof for the sequential composition theorem, using sophisticated
results from ﬁelds such as martingale theory and hypothesis test-
ing. We overcome these obstacles by showing approximate liftings
from a version of differential privacy; as we saw before, differ-
ential privacy is also a consequence of an approximate lifting of
equality. The key observation is that the two witnesses µL and µR
used in the deﬁnition of an approximate lifting deﬁne a mecha-
nism µ : B → Distr(A1 × A2) such that µ(true) = µL and
µ(false) = µR where ∆(µL, µR) ≤ δ iff µ is (, δ)-differentially
private. Next, we show how to take advantage of this observation.
Since the (, δ) parameters from approximate lifting are deﬁned
by the -distance ∆(µ1, µ2) between the two witnesses, we will
ﬁrst show an advanced composition theorem for -distance.

Proposition 15 (Advanced composition for -distance). Let fi, gi :
A → Distr(A) such that ∆(fi(a), gi(a)) ≤ δ for every a ∈ A.
For any ω > 0, let:

∗ (cid:44)(cid:16)(cid:112)2n ln(1/ω)

(cid:17)



 + n(e − 1)

and

∗ (cid:44) nδ + ω.

δ

Then for every n ∈ N and a ∈ A, ∆∗ (f n(a), gn(a)) ≤ δ∗.

: A → B → Distr(A) be such that for every
Proof. Let hi
a ∈ A, hi(a, true) = fi(a) and hi(a, false) = gi(a). Then
∆(fi(a), gi(a)) ≤ δ iff hi(a) : B → Distr(A) is (, δ)-
differentially private for every a ∈ A.
By directly applying the advanced composition theorem of differ-
ential privacy (Theorem 7), the function hn(a) : B → Distr(A)
is (∗, δ∗)-differentially private for each a ∈ A. So for every
b, b(cid:48) ∈ B and a ∈ A, ∆∗ (hn(a, b), hn(a, b(cid:48))) ≤ δ∗. Now for
every a ∈ A, hn(a, true) = f n(a) and hn(a, false) = gn(a).
Therefore, ∆∗ (f n(a), gn(a)) ≤ δ∗.

61Now that we have an advanced composition for -distance, it is
a simple matter to extend our result to approximate liftings. Note
here that we apply advanced composition not to the distributions
on A—which are related by an approximate lifting, but perhaps not
related by differential privacy—but rather to the two witnesses of
the lifting, distributions on pairs in A × A.
Proposition 16 (Advanced composition for lifting). Let fi, f(cid:48)
:
A → Distr(A) and Φ ⊆ A × A such that for every a, a(cid:48) ∈ A,
(a, a(cid:48)) |= Φ implies

i

fi(a) Φ(cid:93)(,δ) f

(cid:48)
(cid:48)
i (a

).

Let n ∈ N and let ((cid:48), δ(cid:48)) be as in Theorem 7. For any ω > 0, let
(cid:48) (cid:44) nδ + ω.

(cid:48) (cid:44)(cid:16)(cid:112)2n ln(1/ω)
(cid:17)

 + n(e − 1)

and

δ



Then for every a, a(cid:48) ∈ A such that (a, a(cid:48)) |= Φ, we have

f n(a) Φ(cid:93)((cid:48),δ(cid:48)) f

(cid:48)n(a

(cid:48)

).

Proof. We can map any pair (a, a(cid:48)) ∈ Φ to the left and right
witnesses of the approximate lifting. That is, there exists hl
i, hr
i :
(A × A) → Distr(A × A) such that for every (a, a(cid:48)) |= Φ:

• π1(hl
• supp(hl
• ∆(hl

i(a, a(cid:48))) = fi(a) and π2(hr
i(a, a(cid:48))) ⊆ Φ and supp(hr
i(a, a(cid:48)), hr

i (a, a(cid:48))) ≤ δ

i (a(cid:48))

i (a, a(cid:48))) = f(cid:48)
i (a, a(cid:48))) ⊆ Φ

i(a, a(cid:48)) =
Without loss of generality, we can assume that hl
i (a, a(cid:48)) = 0 if (a, a(cid:48)) |= ¬Φ. By Proposition 15, we also
hr
i (a, a(cid:48))) ≤ δ(cid:48) for every i ∈ N and
have ∆(cid:48) (hl
(a, a(cid:48)) |= Φ. By induction on i, for every (a, a(cid:48)) |= Φ we
have supp((hl)n(a, a(cid:48))) ⊆ Φ and supp((hr)n(a, a(cid:48))) ⊆ Φ,
π1((hl)n(a, a(cid:48))) = f n(a) and π2((hr)n(a, a(cid:48))) = f(cid:48)n

i(a, a(cid:48)), hr

i (a(cid:48)).

We remark that our connection between the witnesses of liftings
and differential privacy allows us to directly import other composi-
tion theorems of differential privacy and their proofs without change.
For instance, Kairouz et al. [32] consider two variants of advanced
composition: an optimal variant that provably gives the best bound
on  and δ, and a heterogeneous variant that allows  and δ be dif-
ferent for the different mechanisms. In unpublished work, Rogers
et al. [43] consider a version of the advanced composition theorem
where the privacy level i and δi for the i-th mechanism may be
chosen adaptively, i.e., depending on the results from the ﬁrst i − 1
mechanisms. These composition theorems are quite tricky to prove,
involving sophisticated tools from martingale theory and hypothesis
testing. We expect that we can internalize all of these composition
theorems—and directly generalize to liftings—with minimal effort.
Based on the previous result, we introduce a new rule [AC-
WHILE] that formalizes advanced composition for loops. The sound-
ness for the new rule, which is given in Fig. 4 follows immediately
from the results of the previous section.

Theorem 17. The rule [AC-WHILE] is sound.

6.

INTERACTIVE PRIVACY

So far, we have seen how to incorporate composition theorems
and accuracy proofs into our logic. Now, we consider the last piece
needed to verify ASVbt: proving privacy for interactive algorithms.
To date, privacy has only been formally veriﬁed for algorithms where
the entire input is available in a single piece; such algorithms are
called ofﬂine algorithms. In contrast, interactive or online algorithms

accept input piece by piece, in a ﬁnite stream of input, and must
produce an intermediate outputs as inputs arrive.

The differential literature proposes several interactive algorithms;
examples include private counters [14, 21], the Sparse Vector mech-
anism, and other algorithms using these mechanisms [30]. The main
difﬁculty in verifying privacy is to model adaptivity: later inputs can
depend on earlier outputs. Indeed, differential privacy behaves well
under adaptivity, a highly useful property enabling applications to
adaptive data analysis and statistics [23].

We can view adaptive inputs as controlled by an adversary, who
receives earlier outputs and selects the next input. We draw on tech-
niques for formally verifying cryptographic proofs, which often also
involve an adversary who is trying to break the protocol. We take
inspiration from the treatment of adversaries in the logic pRHL,
an exact version of apRHL that has been used for verifying cryp-
tographic proofs [4]. Speciﬁcally, we extend apRHL with a rule
[ADV] for the adversary. The rule, displayed in Figure 5, general-
izes the adversary rule from pRHL; let Φ an assertion that does not
contain any adversary variable, and assume that the adversary A
has access to oracles O1, . . . , On and that each oracle guarantees
equality of outputs and an invariant Φ, provided it is called on equal
inputs that satisfy Φ. Then, A guarantees equality of outputs and
an invariant Φ, provided it is called on equal inputs that satisfy Φ.
Moreover, the privacy cost of calling the adversary A is equal to
k=1 qkδk(cid:105) where (cid:104)i, δi(cid:105) is the cost of calling once
the oracle Oi, and qi is the maximal number of adversarial queries
for oracle Oi. One can prove the soundness of the adversary rule by
induction on the code of the adversary.
Proposition 18. The rule [ADV] is sound.

(cid:104)(cid:80)n
k=1 qkk,(cid:80)n

Note that the proof of sparse vector only makes a restricted use of
the [ADV] rule: as A does not have access to any oracle, the pRHL
rule sufﬁces for the proof. However, the following, oracle based,
presentation of sparse vector uses the full power of the [ADV] rule:

l ← [];
u $← L/2(0);
A ← a − u;
B ← b + u;
x ← AO();
return l

where O is an oracle that takes a query and checks whether it is
between thresholds and updates a public list l, and A is allowed
to query O up to N times. In addition, we note that our new rule
can also be useful for cryptographic proofs which involve reasoning
about statistical distance.
7. OPTIMAL SUBSET COUPLING

The privacy proof of ASVbt relies on a new interval coupling
rule [LAPINT] for Laplace sampling, Fig. 6. This rule allows us to
relate a larger interval with a smaller interval nested inside. That
is, we can assume that the sample y1(cid:104)1(cid:105) lies in [p, q] if and only if
the sample y2(cid:104)2(cid:105) lies in [r, s] contained in [p, q]. The privacy cost
depends on two things: the difference in sizes of the two intervals
(q − p) − (s − r), and the size of the inner interval s − r. Roughly,
a larger inner interval and smaller outer interval yield a smaller
privacy cost.

To show that this rule is sound, we will ﬁrst prove a general

construction for liftings of the form

µ (y1 ∈ P ↔ y2 ∈ Q)(cid:93)(,0) µ

for Q ⊆ P . We call such such liftings subset couplings, since they
relate a set of outputs to a subset of outputs. Our construction applies

62|= Θ ∧ e(cid:104)1(cid:105) ≤ 0 → ¬b1(cid:104)1(cid:105)

 + n(e − 1)

∗ (cid:44) nδ + ω

δ

ω > 0

AC-WHILE

(cid:96) c1 ∼(cid:104),δ(cid:105) c2 : Θ ∧ b1(cid:104)1(cid:105) ∧ b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) = k =⇒ Θ ∧ b1(cid:104)1(cid:105) = b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) < k

(cid:96) while b1 do c1 ∼(cid:104)∗,δ∗(cid:105) while b2 do c2 : Θ ∧ b1(cid:104)1(cid:105) = b2(cid:104)2(cid:105) ∧ e(cid:104)1(cid:105) ≤ n =⇒ Θ ∧ ¬b1(cid:104)1(cid:105) ∧ ¬b2(cid:104)2(cid:105)

∗ (cid:44)(cid:16)(cid:112)2n ln(1/ω)

(cid:17)



Figure 4: Advanced composition rule

ADV

(cid:96) (cid:126)x ← A((cid:126)e) ∼(cid:104)(cid:80)n

k=1 qkk,(cid:80)n

∀i, (cid:126)y, (cid:126)z. (cid:96) (cid:126)y ← Oi((cid:126)z) ∼(cid:104)i,δi(cid:105) (cid:126)y ← Oi((cid:126)z) : (cid:126)z(cid:104)1(cid:105) = (cid:126)z(cid:104)2(cid:105) ∧ Φ =⇒ (cid:126)y(cid:104)1(cid:105) = (cid:126)y(cid:104)2(cid:105) ∧ Φ

k=1 qkδk(cid:105) (cid:126)x ← A((cid:126)e) : (cid:126)e(cid:104)1(cid:105) = (cid:126)e(cid:104)2(cid:105) ∧ xA(cid:104)1(cid:105) = xA(cid:104)2(cid:105) ∧ Φ =⇒ (cid:126)x(cid:104)1(cid:105) = (cid:126)x(cid:104)2(cid:105) ∧ xA(cid:104)1(cid:105) = xA(cid:104)2(cid:105) ∧ Φ

where q1, . . . , qn are the maximal number of queries that A can make to oracles O1, . . . ,On and xA is the state of the adversary.

Figure 5: Adversary rule

to all discrete distributions, and is optimal in a precise sense: among
all liftings of the relation, our construction gives the smallest (i.e.,
the most precise) .

proving a property of the discrete Laplace distribution. Formally, let
L(v) for v ∈ Z have distribution over Z with probability propor-
tional to

Theorem 19 (Optimal subset coupling). Let µ be a distribution over
S, and consider two proper subsets P, Q of S such that Q ⊆ P .
Then µ(P ) ≤ αµ(Q) if and only if the following lifting holds:

µ R(cid:93)(ln α,0) µ

where the relation R is deﬁned by the following clause:

(y1, y2) ∈ R (cid:44) y1 ∈ P ↔ y2 ∈ Q

Pr[r] ∝ exp(−|r − v|).

We write L to mean L(0). We will use the following property, a
discrete version of Bun et al. [13, Claim 5.13].
Lemma 20. Let r be a draw from L, and take a, a(cid:48), b, b(cid:48) ∈ Z such
that a < b and [a, b] ⊆ [a(cid:48), b(cid:48)]. Then,

Pr[r ∈ [a

(cid:48)

(cid:48)

]] ≤ α Pr[r ∈ [a, b]]

, b

Proof. The reverse direction follows from the fundamental lemma
of approximate liftings [2]. For the forward implication, we con-
struct two witnesses. Note that the theorem is trivial if µ(P \Q) = 0
since we can just take the identity coupling, so we will assume oth-
erwise. Deﬁne the following witnesses:

µ(x)µ(y)

µ(Q)

0

µ(x)


µ(y)
0

µ(y)
λ · µ(y)
(1−λ)µ(x)µ(y)

µ(P\Q)

µL(x, y) =

µR(x, y) =

if x /∈ P \ Q ∧ x = y
if x ∈ P \ Q ∧ y ∈ Q
otherwise.

if x = y ∧ y /∈ P
if x = y ∧ y ∈ Q
if x ∈ P \ Q ∧ y ∈ Q
if x = x0 ∈ S \ P ∧ y ∈ P \ Q
otherwise.

Here, x0 is an arbitrary element of S \ P . We set λ = µ(Q)/µ(P ).
Note that λ satisﬁes:

λ = (1 − λ)

µ(Q)

µ(P \ Q)

.

For the witnesses, it is not hard to see that the marginal conditions are
satisﬁed, and that x R y for all pairs (x, y) in the supports of µL and
µR. Furthermore, for all x ∈ P and y ∈ Q, we have µL(x, y) =
(1/λ) · µR(x, y) by our choice of λ. By the condition on marginals
and the support, we have a (ln(1/λ), 0)-lifting. This immediately
implies the (ln α, 0)-lifting for any α ≥ 1/λ = µ(P )/µ(Q).

This result is very much in the spirit of the optimal or maximal
coupling for exact probabilistic couplings (see, e.g., [49]). By com-
puting the total variation distance between two distributions, the
maximal coupling construction shows how to create a coupling that
exactly realizes the total variation distance.

Similarly, by the optimal subset coupling, we can construct a
subset coupling and calculate the distance  in the lifting by simply

with

α =

exp(η)

1 − exp(−(b − a + 2)/2)

,

η = (b

(cid:48) − a

(cid:48)

) − (b − a).

The proof follows by a small calculation; we defer the details to
the full version. With this property, we can now prove soundness of
our subset rule for sampling from the Laplace distribution.

Theorem 21. The rule [LAPINT] is sound.
Proof. Suppose that [[e(cid:104)1(cid:105)]] = v1, [[e(cid:104)2(cid:105)]] = v2, and |v1 − v2| =
∆ ≤ k. Let the noises be w1 = x(cid:104)1(cid:105) − v1, w2 = x(cid:104)2(cid:105) = v2; note
that both samples are distributed as L(0). Note that x(cid:104)1(cid:105) ∈ [a(cid:48), b(cid:48)]
exactly when w1 ∈ [a(cid:48) − v1, b(cid:48) − v1], and similarly for x2 and w2.
By Proposition 12, to show a lifting on memories, it sufﬁces to ﬁnd
a lifting on the distribution over the sampled variable y, taking f
to be the function that maps a memory m to the value m(y). So, it
sufﬁces to show

L(0) {w1 ∈ I1 ↔ w2 ∈ I2}(cid:93)((cid:48),0) L(0)

where I1 (cid:44) [a(cid:48) − v1, b(cid:48) − v1] and I2 (cid:44) [a − v2, b − v2]. Since
a(cid:104)1(cid:105) + k ≤ a(cid:104)2(cid:105) and b(cid:104)1(cid:105) ≤ b(cid:104)2(cid:105) − k, we know I2 ⊆ I1. Then,
we can directly apply Lemma 20 on these two intervals with η =
|I1| − |I2| = (b(cid:48) − a(cid:48)) − (b − a), and we are done.

8. PROVING PRIVACY FOR ASVbt

We verify differential privacy for the full version of ASVbt with
an adaptive adversary that chooses its queries interactively. We recall
the theorem.

Theorem 22. Let  and δ both be in (0, 1). Set

4(cid:112)2M ln(2/δ)



.

(cid:48) (cid:44)


63(cid:18)

(cid:48) (cid:44) ln



LAPINT

(cid:19)

exp(η)

1 − exp(−σ/2)

Φ (cid:44) |e(cid:104)1(cid:105) − e(cid:104)2(cid:105)| ≤ k ∧ (p + k ≤ r < s ≤ q − k) ∧ (q − p) − (s − r) ≤ η ∧ 0 < σ ≤ (s − r) + 2

(cid:96) y1 $← L(e) ∼(cid:104)(cid:48),0(cid:105) y2 $← L(e) : Φ =⇒ y1(cid:104)1(cid:105) ∈ [p, q] ↔ y2(cid:104)2(cid:105) ∈ [r, s]

Figure 6: Interval coupling for Laplace

If all adversarial queries q are 1-sensitive (i.e. |evalQ(q, d) −
evalQ(q, d(cid:48))| ≤ 1 for every adjacent databases d and d(cid:48)), then
ASVbt is (, δ)-differentially private. Formally,

(cid:96) ASVbt ∼(cid:104),δ(cid:105) ASVbt : Φ =⇒ r(cid:104)1(cid:105) = r(cid:104)2(cid:105)

where Φ is deﬁned as

={a,b,N,qs} ∧Adj(d(cid:104)1(cid:105), d(cid:104)2(cid:105)) ∧ b(cid:104)1(cid:105) − a(cid:104)1(cid:105) ≥ γ

for

γ (cid:44) 6

(cid:48) ln(4/

(cid:48)

) +

4


ln(2/δ).

Proof sketch. Now, we put everything together to prove ASVbt is
(, δ)-private algorithm. We present just the key points of the proof
here; the full proof is formalized in the EasyCrypt system. We ﬁrst
transform the algorithm to an equivalent algorithm:3

ASVbt(a, b, M, N, d) :=
i ← 0; l ← [];
u $← L/2(0);
A ← a − u; B ← b + u;
while i < N ∧ |l| < M do

i(cid:48) ← i; hd ← −1;
while i(cid:48) < N do
if (hd = −1)
q ← A(l);
S $← L(cid:48)/3(evalQ(q, d));
if (A ≤ S ≤ B) then hd ← i;
i ← i + 1;
i(cid:48) ← i(cid:48) + 1;

if (hd (cid:54)= −1) then l ← hd :: l;

return l

The main change is that the loop iterations in Fig. 1 are grouped
into blocks of queries, each handled by an inner loop. Each outer
iteration now corresponds to ﬁnding a single query between the
thresholds. The inner iterations loop through the queries until there
is a between threshold query. To allow the inner loop to be analyzed
in a synchronized fashion, the inner loop always continues up to
iteration N, doing nothing for all iterations beyond the ﬁrst between
threshold query.

This transformation allows us to use both advanced composition
and pointwise equality. At a high level, we follow four steps. First,
we set up the threshold noise, so that the noisy interval [A, B]
is smaller in the ﬁrst run than in the second run; this costs a bit
of privacy. Then, we handle the loop working inside to out: we
apply the adversary rule, the subset coupling, and pointwise equality
to the inner loop to show privacy for each block of queries that
stops as soon as we see a between threshold query, assuming that
the noisy intervals [A, B] are sufﬁciently large. Next, we apply
advanced composition to bound the privacy cost of the outer loop,
3We have formally veriﬁed equivalence of this program with the
program in Fig. 1 by using a recently-proposed asynchronous loop
rule [3].

still assuming [A, B] is sufﬁciently large. Finally, we use up-to-bad
reasoning to remove this assumption, increasing δ slightly for the
ﬁnal (, δ)-privacy bound.
We now detail each step. To reduce notation, we will suppress the
adjacency predicate Adj(d(cid:104)1(cid:105), d(cid:104)2(cid:105)) which is preserved throughout
the computation and the proof.

Threshold coupling. Let ct be the initialization command, in-
cluding all commands before the loop. First, we can prove:

(cid:96) ct ∼(cid:104) 

2 ,0(cid:105) ct : Φ =⇒ Φ
(cid:48)

where Φ(cid:48) (cid:44) A(cid:104)1(cid:105) + 1 = A(cid:104)2(cid:105) ∧ B(cid:104)1(cid:105) = B(cid:104)2(cid:105) + 1, by applying
the rule [LAPGEN] to ensure u(cid:104)1(cid:105) = u(cid:104)2(cid:105) + 1 as a post-condition.
This step costs (/2, 0) privacy.

The inner loop. For the inner loop, we will assume the threshold
condition Φ(cid:48) and l(cid:104)1(cid:105) = l(cid:104)2(cid:105) initially; both conditions are preserved
by the inner loop. We will also assume that the noisy interval [A, B]
is sufﬁciently large:4

Ψ (cid:44) B − A ≥ 6

(cid:48) ln(4/

(cid:48)

).

Let ci be the inner loop. We will ﬁrst prove the pointwise judgment:

(cid:96)ci ∼(cid:104)(cid:48),0(cid:105) ci :
(cid:48) ∧ Ψ(cid:104)1(cid:105) ∧ l(cid:104)1(cid:105) = l(cid:104)2(cid:105) =⇒ (hd(cid:104)1(cid:105) = v) → (hd(cid:104)2(cid:105) = v)
Φ

(1)

for each index v.

We focus on the case where 0 ≤ v ≤ N, as other cases are easy.
First, we apply the [WHILE] rule, with i = 0 except for i = v,
where we set v = 
2 . Whenever we call the adversary for the next
query, we know that l(cid:104)1(cid:105) = l(cid:104)2(cid:105), so we may apply adversary rule
with cost (0, 0) to ensure that q(cid:104)1(cid:105) = q(cid:104)2(cid:105) throughout.

Then, the proof for the rest of the loop body goes as follows:
• For the iterations i < v and i > v, we use the rule [LAP-
NULL] to couple the noisy query answers S(cid:104)1(cid:105), S(cid:104)2(cid:105). This
has no privacy cost and preserves the invariant.

• For the iteration i = v, suppose that S(cid:104)1(cid:105) ∈ [A(cid:104)1(cid:105), B(cid:104)1(cid:105)]
(otherwise we are done). We can apply a coupling for the
Laplace distribution, [LAPINT], to ensure that S(cid:104)2(cid:105) ∈
[A(cid:104)2(cid:105), B(cid:104)2(cid:105)] as well. Under Ψ(cid:104)1(cid:105) and the coupling on
the noisy thresholds Φ(cid:48), the inner interval [A(cid:104)2(cid:105), B(cid:104)2(cid:105)]
has size at least (6/(cid:48)) ln(4/(cid:48)) − 2. Taking (p, q, r, s) =
(A(cid:104)1(cid:105), B(cid:104)1(cid:105), A(cid:104)2(cid:105), B(cid:104)2(cid:105)), η = 2, σ = (6/(cid:48)) ln(4/(cid:48)), and
k = 1, a calculation shows that [LAPINT] gives a ((cid:48), 0)-
lifting so the critical iteration has privacy cost (cid:48).

This establishes Eq. (1). By the pointwise equality rule [PW-EQ],
we have:
(cid:96) ci ∼(cid:104)(cid:48),0(cid:105) ci : Φ
(cid:48) ∧ Ψ(cid:104)1(cid:105) ∧ l(cid:104)1(cid:105) = l(cid:104)2(cid:105) =⇒ hd(cid:104)1(cid:105) = hd(cid:104)2(cid:105)
4While Ψ does not have tagged variables, we will later interpret A
and B as coming from the ﬁrst run.

64By [FRAME] and some manipulations, we can assume that l(cid:104)1(cid:105) =
l(cid:104)2(cid:105) at the end of each iteration of the outer loop.

The outer loop. For the outer loop, we apply advanced compo-
sition. Letting co be the outer loop, our choice of (cid:48) and corresponds
to the setting in Theorem 7, so we have the following judgment by
[AC-WHILE]:

(cid:96) co ∼(cid:104)/2,0(cid:105) co : l(cid:104)1(cid:105) = l(cid:104)2(cid:105) ∧ Φ

(cid:48) ∧ Ψ(cid:104)1(cid:105) =⇒ l(cid:104)1(cid:105) = l(cid:104)2(cid:105).

Since co does not modify the thresholds and preserves Ψ(cid:104)1(cid:105),
[FRAME] and some manipulations allows us to move this asser-
tion into the post-condition:
(cid:96) co ∼(cid:104)/2,0(cid:105) co : l(cid:104)1(cid:105) = l(cid:104)2(cid:105) ∧ Φ

=⇒ Ψ(cid:104)1(cid:105) → l(cid:104)1(cid:105) = l(cid:104)2(cid:105).

(cid:48)

Applying up-to-bad reasoning. Finally, we can apply [SEQ]
with our judgement for the initialization ci and the outer loop co,
giving:

(cid:96) ASVbt ∼(cid:104)/2,0(cid:105) ASVbt : Φ0 =⇒ Ψ(cid:104)1(cid:105) → l(cid:104)1(cid:105) = l(cid:104)2(cid:105)

for

Φ0 (cid:44) ={a,b,N,qs} ∧ Adj(d(cid:104)1(cid:105), d(cid:104)2(cid:105)) ∧ b(cid:104)1(cid:105) − a(cid:104)1(cid:105) ≥ γ.

To conclude the proof, all that remains is to remove the assertion
Ψ(cid:104)1(cid:105). We will bound the probability that Ψ(cid:104)1(cid:105) does not hold. The
accuracy rule for the Laplace mechanism gives

(cid:96)δ u $← L/2(0) : b − a ≥ γ =⇒ |u| ≤ 2


log(1/δ),

from which we can conclude

(cid:96)δ ASVbt : b − a ≥ γ =⇒ Ψ.

Finally, applying [UTB-L] yields the desired judgment:
(cid:96) ASVbt ∼(cid:104)/2,δ(cid:105) ASVbt : Φ0 =⇒ l(cid:104)1(cid:105) = l(cid:104)2(cid:105)

9. RELATED WORKS

Differential privacy [19] has been an area of intensive research
in the last decade. We refer readers interested in a more compre-
hensive treatment of the algorithmic aspects of differential privacy
to the excellent monograph by Dwork and Roth [17]. Several tools
have been developed to support the development of differentially
private data analysis. PINQ [36] internalizes the use of standard
composition in the form of a privacy budget management platform,
Airavat [45] uses differential privacy combined with the map-reduce
approach, GUPT [40] implements the general idea of sample and
aggregate [41]. Other tools implement algorithms targeting speciﬁc
applications like: location data [35], genomic data [27, 47], mobility
data [37], and browser error reports [26].

Several tools have been proposed for providing formal veriﬁca-
tion of the differential privacy guarantee, using a wide variety of
veriﬁcation approaches: dynamic checking [24, 36], relational pro-
gram logic [2, 6] and relational reﬁnement type systems [9], linear
(dependent) type systems [29, 42], product programs [7], meth-
ods based on computing bisimulations families for probabilistic
automata [50, 51], and methods based on counting variants of satis-
ﬁability modulo theories [28]. None of these techniques can handle
advanced composition, interactive online algorithms and privacy
depending on accuracy. Barthe et al. [5] present a system for rea-
soning about computational differential privacy [39] a relaxation of
differential privacy where the adversary are computationally-bound.
Coupling is an established tool in probability theory, but it seems
less familiar to computer science. It was only quite recently that

couplings have been used in cryptography; according to Hoang and
Rogaway [31], who use couplings to reason about generalized Feis-
tel networks, Mironov [38] ﬁrst used this technique in his analysis
of RC4. There are seemingly few applications of coupling in formal
veriﬁcation, despite considerable research on probabilistic bisimu-
lation (ﬁrst introduced by Larsen and Skou [33]) and probabilistic
relational program logics (ﬁrst introduced by Barthe et al. [4]).
The connection between liftings and couplings was recently noted
by Barthe et al. [8] and explored for differential privacy by Barthe
et al. [10]. The latter uses a coupling argument to prove differen-
tially private the sparse vector algorithm that we also consider in
this work. The additional challenges that we face are: ﬁrst, the inte-
gration of advanced composition, providing a much better privacy
bound; second, the proof that sparse vector is differentially private
also in the interactive model, which requires additionally to have a
logic that permits to reason about the adversary. Moreover, Barthe
et al. [10] do not provide methods to prove privacy using accuracy.
In promising recent work, Zhang and Kifer [52] design a system
to automatically verify differentially privacy for examples where
the privacy proof uses tools beyond the standard composition the-
orem, including the Sparse Vector technique. Their proof strategy
is morally similar to couplings, but their work uses a combination
of product programs and lightweight reﬁnement types backed by
novel type-inference techniques, rather than a relational program
logic like we consider. Their system can also optimize the privacy
cost, something that we do not consider. While their work is highly
automated, their system is limited to pure, (, 0) differential privacy,
so it cannot verify the algorithms we consider, where privacy fol-
lows from accuracy or the advanced composition theorem. Their
techniques also seem limited to couplings from bijections; in partic-
ular, it is not clear how to prove privacy for examples that use more
advanced couplings like the optimal subset coupling.

10. CONCLUDING REMARKS

We have presented an extension of the logic apRHL [6] that
can express three classes of privacy proofs beyond current state-of-
the-art techniques for privacy veriﬁcation: privacy depending on
accuracy, privacy from advanced composition, and privacy for inter-
active algorithm. We have formalized a generalization of the adap-
tive Sparse Vector algorithm, known as Between Thresholds [13].
This and other possible generalizations of sparse vector could bring
interesting results in domains like geo-indistinguishability [1].

For the future, it would be interesting to explore generalizations
of differential privacy like the recent notion of concentrated dif-
ferential privacy [12, 18]. This generalization features a simple
composition principle that internalizes the advanced composition
principle of standard differential privacy. However, it is currently
unclear whether the deﬁnition of concentrated differential privacy,
which involves Rényi divergences, can be modeled using apRHL.
Additionally, there is still room for improving the expressivity of
apRHL for differential privacy. One interesting example combin-
ing accuracy and privacy is the large margin mechanism [15]. The
privacy proof for this algorithm requires careful reasoning about
the size of the support when applying pointwise equality, and so-
phisticated facts about the accuracy Sparse Vector. This example
seems beyond the reach of our techniques, but we believe it could
be handled by generalizing the existing rules.

Finally, it would be interesting to explore a tighter integration of
accuracy and privacy proofs. We currently use two systems, aHL
and apRHL, to verify privacy. This can lead to awkward proofs
since the two logics can only interact in speciﬁc places in the proof
(i.e., the up-to-bad rules). A combined version of the logics could
allow more natural proofs.

65References
[1] M. E. Andrés, N. E. Bordenabe, K. Chatzikokolakis, and

C. Palamidessi. Geo-indistinguishability: differential privacy
for location-based systems. In ACM SIGSAC Conference on
Computer and Communications Security (CCS), Berlin,
Germany, pages 901–914, 2013.

[2] G. Barthe and F. Olmedo. Beyond differential privacy:

Composition theorems and relational logic for f-divergences
between probabilistic programs. In International Colloquium
on Automata, Languages and Programming (ICALP), Riga,
Latvia, volume 7966 of Lecture Notes in Computer Science,
pages 49–60. Springer, 2013.

[3] G. Barthe, B. Grégoire, J. Hsu, and P.-Y. Strub. Coupling

proofs are probabilistic product programs.

[4] G. Barthe, B. Grégoire, and S. Zanella-Béguelin. Formal
certiﬁcation of code-based cryptographic proofs. In ACM
SIGPLAN–SIGACT Symposium on Principles of
Programming Languages (POPL), Savannah, Georgia, pages
90–101, New York, 2009.

[5] G. Barthe, G. Danezis, B. Grégoire, C. Kunz, and S. Z.

Béguelin. Veriﬁed computational differential privacy with
applications to smart metering. In IEEE Computer Security
Foundations Symposium (CSF), New Orleans, Louisiana,
pages 287–301, 2013.

[6] G. Barthe, B. Köpf, F. Olmedo, and S. Zanella-Béguelin.
Probabilistic relational reasoning for differential privacy.
ACM Transactions on Programming Languages and Systems,
35(3):9, 2013.

[7] G. Barthe, M. Gaboardi, E. J. Gallego Arias, J. Hsu, C. Kunz,
and P.-Y. Strub. Proving differential privacy in Hoare logic. In
IEEE Computer Security Foundations Symposium (CSF),
Vienna, Austria, 2014.

[8] G. Barthe, T. Espitau, B. Grégoire, J. Hsu, L. Stefanesco, and
P.-Y. Strub. Relational reasoning via probabilistic coupling. In
International Conference on Logic for Programming,
Artiﬁcial Intelligence and Reasoning (LPAR), Suva, Fiji,
volume 9450, pages 387–401, 2015.

[9] G. Barthe, M. Gaboardi, E. J. Gallego Arias, J. Hsu, A. Roth,

and P.-Y. Strub. Higher-order approximate relational
reﬁnement types for mechanism design and differential
privacy. In ACM SIGPLAN–SIGACT Symposium on
Principles of Programming Languages (POPL), Mumbai,
India, 2015.

[10] G. Barthe, M. Gaboardi, B. Grégoire, J. Hsu, and P.-Y. Strub.

Proving differential privacy via probabilistic couplings. In
IEEE Symposium on Logic in Computer Science (LICS), New
York, New York, 2016.

[11] G. Barthe, M. Gaboardi, B. Grégoire, J. Hsu, and P.-Y. Strub.

A program logic for union bounds. In International
Colloquium on Automata, Languages and Programming
(ICALP), Rome, Italy, 2016.

[12] M. Bun and T. Steinke. Concentrated Differential Privacy:
Simpliﬁcations, Extensions, and Lower Bounds. May 2016.

[13] M. Bun, T. Steinke, and J. Ullman. Make Up Your Mind: The

Price of Online Queries in Differential Privacy. Apr. 2016.

[14] T.-H. H. Chan, E. Shi, and D. Song. Private and continual
release of statistics. ACM Transactions on Information and
System Security, 14(3):26, 2011.

[15] K. Chaudhuri, D. J. Hsu, and S. Song. The large margin

mechanism for differentially private maximization. In
Conference on Neural Information Processing Systems (NIPS),
Montréal, Québec, pages 1287–1295, 2014.

[16] C. Dwork and J. Lei. Differential privacy and robust statistics.

In ACM SIGACT Symposium on Theory of Computing
(STOC), Bethesda, Maryland, pages 371–380, 2009.

[17] C. Dwork and A. Roth. The algorithmic foundations of

differential privacy. Foundations and Trends in Theoretical
Computer Science, 9(3–4):211–407, 2014.

[18] C. Dwork and G. N. Rothblum. Concentrated Differential

Privacy. Mar. 2016.

[19] C. Dwork, F. McSherry, K. Nissim, and A. Smith. Calibrating
noise to sensitivity in private data analysis. In IACR Theory of
Cryptography Conference (TCC), New York, New York, pages
265–284, 2006.

[20] C. Dwork, M. Naor, O. Reingold, G. N. Rothblum, and S. P.

Vadhan. On the complexity of differentially private data
release: efﬁcient algorithms and hardness results. In ACM
SIGACT Symposium on Theory of Computing (STOC),
Bethesda, Maryland, pages 381–390, 2009.

[21] C. Dwork, M. Naor, T. Pitassi, and G. N. Rothblum.

Differential privacy under continual observation. In ACM
SIGACT Symposium on Theory of Computing (STOC),
Cambridge, Massachusetts, pages 715–724, 2010.

[22] C. Dwork, G. N. Rothblum, and S. Vadhan. Boosting and

differential privacy. In IEEE Symposium on Foundations of
Computer Science (FOCS), Las Vegas, Nevada, pages 51––60,
2010.

[23] C. Dwork, V. Feldman, M. Hardt, T. Pitassi, O. Reingold, and
A. Roth. The reusable holdout: Preserving validity in adaptive
data analysis. Science, 349(6248):636–638, 2015.

[24] H. Ebadi, D. Sands, and G. Schneider. Differential privacy:

Now it’s getting personal. In ACM SIGPLAN–SIGACT
Symposium on Principles of Programming Languages
(POPL), Mumbai, India, pages 69–81, 2015.

[25] F. Eigner and M. Maffei. Differential privacy by typing in

security protocols. In IEEE Computer Security Foundations
Symposium (CSF), New Orleans, Louisiana, pages 272–286,
2013.

[26] Ú. Erlingsson, V. Pihur, and A. Korolova. RAPPOR:

randomized aggregatable privacy-preserving ordinal response.
In ACM SIGSAC Conference on Computer and
Communications Security (CCS), Scottsdale, Arizona, pages
1054–1067, 2014.

[27] S. E. Fienberg, A. B. Slavkovic, and C. Uhler. Privacy
preserving GWAS data sharing. In IEEE International
Conference on Data Mining Workshops (ICDMW), Vancouver,
British Colombia, pages 628–635, 2011.

66[28] M. Fredrikson and S. Jha. Satisﬁability modulo counting: a

new approach for analyzing privacy properties. In IEEE
Symposium on Logic in Computer Science (LICS), Vienna,
Austria, pages 42:1–42:10, 2014.

[41] K. Nissim, S. Raskhodnikova, and A. Smith. Smooth

sensitivity and sampling in private data analysis. In ACM
SIGACT Symposium on Theory of Computing (STOC), San
Diego, California, 2007.

[29] M. Gaboardi, A. Haeberlen, J. Hsu, A. Narayan, and B. C.
Pierce. Linear dependent types for differential privacy. In
ACM SIGPLAN–SIGACT Symposium on Principles of
Programming Languages (POPL), Rome, Italy, pages
357–370, 2013.

[30] M. Hardt and G. N. Rothblum. A multiplicative weights
mechanism for privacy-preserving data analysis. In IEEE
Symposium on Foundations of Computer Science (FOCS), Las
Vegas, Nevada, pages 61–70, 2010.

[31] V. T. Hoang and P. Rogaway. On generalized Feistel networks.

In IACR International Cryptology Conference (CRYPTO),
Santa Barbara, California, volume 6223 of Lecture Notes in
Computer Science, pages 613–630. Springer, 2010.

[32] P. Kairouz, S. Oh, and P. Viswanath. The composition

theorem for differential privacy. 2015.

[33] K. G. Larsen and A. Skou. Bisimulation through probabilistic

testing. In ACM Symposium on Principles of Programming
Languages (POPL), Austin, Texas, pages 344–352, 1989.

[34] M. Lyu, D. Su, and N. Li. Understanding the sparse vector

technique for differential privacy. 2016.

[35] A. Machanavajjhala, D. Kifer, J. M. Abowd, J. Gehrke, and
L. Vilhuber. Privacy: Theory meets practice on the map. In
International Conference on Data Engineering (ICDE),
Cancún, México, pages 277–286, 2008.

[36] F. McSherry. Privacy integrated queries. In ACM SIGMOD

International Conference on Management of Data (SIGMOD),
Providence, Rhode Island, 2009.

[37] D. J. Mir, S. Isaacman, R. Cáceres, M. Martonosi, and R. N.

Wright. DP-WHERE: differentially private modeling of
human mobility. In IEEE International Conference on Big
Data (ICBD), Santa Clara, California, pages 580–588, 2013.

[38] I. Mironov. (Not so) random shufﬂes of RC4. In IACR
International Cryptology Conference (CRYPTO), Santa
Barbara, California, volume 2442 of Lecture Notes in
Computer Science, pages 304–319. Springer, 2002.

[39] I. Mironov, O. Pandey, O. Reingold, and S. P. Vadhan.

Computational differential privacy. In IACR International
Cryptology Conference (CRYPTO), Santa Barbara,
California, pages 126–142, 2009.

[40] P. Mohan, A. Thakurta, E. Shi, D. Song, and D. E. Culler.

GUPT: privacy preserving data analysis made easy. In ACM
SIGMOD International Conference on Management of Data
(SIGMOD), Scottsdale, Arizona, pages 349–360, 2012.

[42] J. Reed and B. C. Pierce. Distance makes the types grow

stronger: A calculus for differential privacy. In ACM
SIGPLAN International Conference on Functional
Programming (ICFP), Baltimore, Maryland, 2010.

[43] R. Rogers, A. Roth, J. Ullman, and S. Vadhan. Privacy

odometers and ﬁlters: Pay-as-you-go composition. 2016.

[44] A. Roth and T. Roughgarden. Interactive privacy via the

median mechanism. In ACM SIGACT Symposium on Theory
of Computing (STOC), Cambridge, Massachusetts, pages
765–774, 2010.

[45] I. Roy, S. T. V. Setty, A. Kilzer, V. Shmatikov, and E. Witchel.

Airavat: Security and privacy for MapReduce. In USENIX
Symposium on Networked Systems Design and
Implementation (NSDI), San Jose, California, pages 297–312,
2010.

[46] R. Shokri and V. Shmatikov. Privacy-preserving deep learning.

In ACM SIGSAC Conference on Computer and
Communications Security (CCS), Boulder, Colorado, pages
1310–1321, 2015.

[47] S. Simmons, C. Sahinalp, and B. Berger. Enabling
privacy-preserving GWAS in heterogenous human
populations. In RECOMB, 2016.

[48] A. Thakurta and A. Smith. Differentially private feature

selection via stability arguments, and the robustness of the
lasso. In Conference on Computational Learning Theory
(CoLT), Princeton, New Jersey, pages 819–850, 2013.

[49] H. Thorisson. Coupling, Stationarity, and Regeneration.

Springer, 2000.

[50] M. C. Tschantz, D. Kaynar, and A. Datta. Formal veriﬁcation

of differential privacy for interactive systems (extended
abstract). Electronic Notes in Theoretical Computer Science,
276(0):61–79, 2011.

[51] L. Xu, K. Chatzikokolakis, and H. Lin. Metrics for
differential privacy in concurrent systems. In IFIP
International Conference on Formal Techniques for
Distributed Objects, Components and Systems (FORTE),
Berlin, Germany, volume 8461 of Lecture Notes in Computer
Science, pages 199–215, June 2014.

[52] D. Zhang and D. Kifer. AutoPriv: Automating differential

privacy proofs. 2016.

67