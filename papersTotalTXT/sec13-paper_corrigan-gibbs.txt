Proactively Accountable Anonymous 

Messaging in Verdict

Henry Corrigan-Gibbs, David Isaac Wolinsky, and Bryan Ford, Yale University

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Proactively Accountable Anonymous Messaging in Verdict

Henry Corrigan-Gibbs, David Isaac Wolinsky, and Bryan Ford

Yale University

Abstract

Among anonymity systems, DC-nets have long held at-
traction for their resistance to trafﬁc analysis attacks, but
practical implementations remain vulnerable to internal
disruption or “jamming” attacks, which require time-
consuming detection procedures to resolve. We present
Verdict, the ﬁrst practical anonymous group communi-
cation system built using proactively veriﬁable DC-nets:
participants use public-key cryptography to construct
DC-net ciphertexts, and use zero-knowledge proofs of
knowledge to detect and exclude misbehavior before dis-
ruption. We compare three alternative constructions for
veriﬁable DC-nets: one using bilinear maps and two
based on simpler ElGamal encryption. While veriﬁable
DC-nets incur higher computational overheads due to the
public-key cryptography involved, our experiments sug-
gest that Verdict is practical for anonymous group mes-
saging or microblogging applications, supporting groups
of 100 clients at 1 second per round or 1000 clients at
10 seconds per round. Furthermore, we show how exist-
ing symmetric-key DC-nets can “fall back” to a veriﬁable
DC-net to quickly identify misbehavior, speeding up pre-
vious detections schemes by two orders of magnitude.

1

Introduction

A right to anonymity is fundamental to democratic cul-
ture, freedom of speech [3, 46], peaceful resistance
to repression [39], and protecting minority rights [45].
Anonymizing relay tools, such as Tor [18], offer practi-
cal and scalable anonymous communication but are vul-
nerable to trafﬁc analysis attacks [4, 34, 38] feasible for
powerful adversaries, such as ISPs in authoritarian states.
(DC-nets)
promise security even against trafﬁc analysis attacks,
and recent systems such as Herbivore [24, 44] and Dis-
sent [14, 52] have improved the scalability of DC-net-
style systems. However, these systems are still vulner-
able to internal disruption attacks in which a misbehav-
ing member anonymously “jams” communication, either

Dining cryptographers networks

[13]

completely or selectively. Dissent includes a retrospec-
tive blame procedure that can eventually exclude disrup-
tors, but at high cost:
tracing a disruptor in a 1,000-
member group takes over 60 minutes [52], and the pro-
tocol makes no communication progress until it restarts
“from scratch.” An adversary who inﬁltrates such a
group with f colluding members can “sacriﬁce” them
one at a time to disrupt all communication for f con-
tiguous hours at any time—long enough time to cause a
communications blackout before or during an important
mass protest, for example.

Verdict, a novel but practical group anonymity sys-
tem, thwarts such disruptions while maintaining DC-
nets’ resistance to trafﬁc analysis. At Verdict’s core lies
a veriﬁable DC-net primitive, derived from theoretical
work proposed and formalized by Golle and Juels [25],
which requires participating nodes to prove proactively
the well-formedness of messages they send. The ﬁrst
working system we are aware of to implement veriﬁable
DC-nets, Verdict supports three alternative schemes for
comparison: a pairing scheme using bilinear maps simi-
lar to the Golle-Juels approach, and two schemes based
on ElGamal encryption in conventional integer or ellip-
tic curve groups. Verdict incorporates this veriﬁable core
into a client/server architecture like Dissent’s [52], to
achieve scalability and robustness to client churn. As
in Dissent, Verdict maintains security as long as at least
one of the participating servers is honest, and participants
need not know or guess which servers are honest.

Due to their reliance on public-key cryptography, ver-
iﬁable DC-nets incur higher computation overheads than
traditional DC-nets, which primarily use symmetric-key
cryptography (e.g., AES). We expect this CPU cost to
be acceptable in applications where messages are usually
short (e.g., chat or microblogging), where costs are dom-
inated by network delays, or in groups with relatively
open or antagonistic membership where disruption risks
may be high. Under realistic conditions, we ﬁnd that
Verdict can support groups of 100 users while maintain-

USENIX Association  

22nd USENIX Security Symposium  147

1

ing 1-second messaging latencies, or 1000-user groups
with 10-second latencies.
In a trace-driven evaluation
of full-system performance for a microblogging applica-
tion, Verdict is able to keep up with symmetric-key DC-
nets in groups of up to 250 active users.

In contrast with the above “purist” approach, which
uses expensive public-key cryptography to construct all
DC-net ciphertexts, Verdict also implements and evalu-
ates a hybrid approach that uses symmetric-key DC-nets
for data communication when not under disruption at-
tack, but leverages veriﬁable DC-nets to enable the sys-
tem to respond much more quickly and inexpensively
to disruption attacks. Dissent uses a veriﬁable shuf-
ﬂe [36] to broadcast an accusation anonymously; this
shufﬂe dominates the cost of identifying disruptors. By
replacing this veriﬁable shufﬂe with a veriﬁable DC-nets
round, Verdict preserves the disruption-free performance
of symmetric-key DC-nets, but reduces the time to iden-
tify a disruptor in a 1000-node group by two orders of
magnitude, from 20 minutes to 26 seconds.

This paper’s primary contributions are:

• the ﬁrst working implementation and experimental
evaluation of veriﬁable DC-nets in a practical anony-
mous communication system,

• two novel veriﬁable DC-nets constructions using stan-
dard modular integer and elliptic curve groups, offer-
ing an order of magnitude lower computational cost
than the original pairing approach [25],

• a hybrid system design that preserves performance
of symmetric-key DC-nets, while reducing disruption
resolution costs by two orders of magnitude, and

• experimental evidence suggesting that veriﬁable DC-
nets may be practical for realistic applications, such as
anonymous microblogging.
Section 2 introduces DC-nets and the disruption prob-
lem. Section 3 outlines Verdict’s architecture and adver-
sary model, and Sections 4 and 5 describe its messaging
protocol and cryptographic schemes. Section 6 presents
application scenarios and evaluation results, Section 7
describes related work, and Section 8 concludes.

2 Background and Motivation

This section ﬁrst introduces the basic DC-nets concept
and known generalizations, then motivates the need for
proactive accountability.

2.1 Anonymity with Strong Adversaries

To make the need for trafﬁc-analysis-resistant anonymity
systems more concrete, consider a political journalist
who obtains some important secret government docu-
ments (e.g., the Pentagon Papers) from a conﬁdential
source. If the journalist publishes these documents un-
der her own name, the journalist might risk prosecution

Figure 1: The basic DC-nets algorithm

or interrogation, and she might be pressured to reveal the
source of the documents.

To reduce such risks, a number of political journalists
could form a Verdict communication group. Any partic-
ipating journalist may then anonymously broadcast the
documents to the entire group of journalists, such that
no member of the group can determine which journal-
ist sent the documents. With Verdict, even if a govern-
ment agency plants agents within the group of journalists
and observes all network trafﬁc during a protocol run, the
agency remains unable to learn the source of the leak.

Existing systems such as Tor, which are practical
and scalable but vulnerable to known trafﬁc analysis at-
tacks [16, 18, 32], cannot guarantee security in this con-
text. For example, if a US journalist posts a leak to a US
website, via a Tor connection whose entry and exit relays
are in Europe, then an eavesdropper capable of moni-
toring transatlantic links [31] can de-anonymize the user
via trafﬁc analysis [18, 35]. Prior anonymity systems at-
tempting to offer resistance to trafﬁc analysis, discussed
in Section 7, suffer from poor performance or vulnera-
bility to active denial-of-service attacks.

2.2 DC-nets Overview

DC-nets [13] provide anonymous broadcast within a
group of participants, who communicate lock-step in a
series of rounds. In a given round, each group member
contributes an equal length ciphertext that, when com-
bined with all other members’ ciphertexts, reveals one or
more cleartext messages. All group members know that
each message was sent by some group member—but do
not know which member sent each message.

In its simplest form, illustrated in Figure 1, we assume
one group member wishes to broadcast a 1-bit message
anonymously. To do so, every pair of members ﬂips a
coin, secretly agreeing on the random outcome of that
coin ﬂip. An N-member group thus ﬂips N(N − 1)/2
coins in total, of which each member observes the out-
come of N − 1 coins. Each member then XORs to-
gether the values of the N − 1 coins she observes, ad-
ditionally the member who wishes to broadcast the 1-bit

148  22nd USENIX Security Symposium 

USENIX Association

2

message XORs in the value of that message, to produce
that member’s DC-nets ciphertext. Each group member
then broadcasts her 1-bit ciphertext to the other mem-
bers. Finally, each member collects and XORs all N
members’ ciphertexts together. Since the value of each
shared coin is XORed into exactly two members’ cipher-
texts, all the coins cancel out, leaving only the anony-
mous message, while provably revealing no information
about which group member sent the message.

2.3 Practical Generalizations

As a standard generalization of DC-nets to communicate
L-bit messages, all members in principle simply run L in-
stances of the protocol in parallel. Each pair of members
ﬂips and agrees upon L shared coins, and each member
XORs together the L-bit strings she observes with her
optional L-bit anonymous message to produce L-bit ci-
phertexts, which XOR together to reveal the L-bit mes-
sage. For efﬁciency, in practice each pair of group mem-
bers forms a cryptographic shared secret—via Difﬁe-
Hellman key agreement, for example—then group mem-
bers use a cryptographic pseudo-random number gener-
ator (PRNG) to produce the L-bit strings.

As a complementary generalization, we can use any
ﬁnite alphabet or group in place of coins or bits, as long
as we have: (a) a suitable combining operator analogous
to XOR, (b) a way to encode messages in the chosen al-
phabet, and (c) a way to generate complementary pairs
of one-time pads in the alphabet that cancel under the
chosen combining operator. For example, the alphabet
might be 8-bit bytes, the combining operator might be
addition modulo 256, and from each pairwise shared se-
cret, one member of the pair generates bytes B1, . . . , Bk
from a PRNG, while the other member generates corre-
sponding two’s complement bytes −B1, . . . , −Bk.

2.4 Disruption and Veriﬁable DC-nets

A key weakness of DC-nets is that a single malicious in-
sider can easily block all communication. An attacker
who transmits arbitrary bits—instead of the XORed ci-
phertext that the protocol prescribes—unilaterally and
anonymously jams all DC-net communication.

In many online venues such as blogs, chat rooms, and
social networks, some users may have legitimate needs
for strong anonymity—protest organizers residing in an
authoritarian state, for example—while other antagonis-
tic users (e.g., secret police inﬁltrators) may attempt to
block communication if they cannot de-anonymize “un-
approved” senders. Even in a system like Dissent that
can eventually trace and exclude disruptors, an adver-
sary with multiple colluding dishonest group members
may still be able to slow or halt communication for long
enough to ruin the service’s usability for honest partici-
pants. Further, if the group’s membership is open enough

to allow new disruptive members to join more quickly
than the tracing process operates, then these inﬁltrators
may be able to shut down communication permanently.

Veriﬁable DC-nets [25] leverage algebraic groups,
such as elliptic curve groups, as the DC-nets alphabet.
Using such groups allows for disruption resistance, by
enabling members to prove the correctness of their ci-
phertexts’ construction without compromising the se-
crecy of the shared pseudo-random seeds. Using a hybrid
approach that combines a traditional DC-net with a veri-
ﬁable DC-net, Verdict can achieve the messaging latency
of a traditional XOR-based DC-net while providing the
strong disruption-resistance of veriﬁable DC-nets.

3 Verdict Architecture Overview

In this section, we describe the individual components of
Verdict and how they combine to form the overall anony-
mous communication system.

3.1 Deployment and Adversary Model

Verdict builds on Dissent [51, 52] and uses the multi-
provider cloud model
illustrated in Figure 2 (a) to
achieve scalability and resilience to ordinary node
and link failures.
In this model, a communication
group consists of mostly unreliable clients, and a few
servers we assume to be highly available and well-
provisioned. Servers in a group should be administered
independently—each furnished by a different anonymity
provider, for example—to limit risk of all servers be-
ing compromised and colluding against the clients. The
servers may be geographically or topologically close,
however—possibly even hosted in the same data center,
in locked cages physically and administratively accessi-
ble only to separate, independent authorities.

Clients directly communicate, at a minimum, with a
single upstream server, while each server communicates
with all other servers. This topology, shown in Fig-
ure 2 (b), reduces the communication and computation
burden on the clients, and enables the system to make
progress regardless of client churn. In particular, clients
need not know which other clients are online at the time
they submit their DC-net ciphertexts to their upstream
server; clients only assume that all servers are online.

To ensure anonymity, clients need not assume that any
particular server is trustworthy—a client need not even
Instead, clients
trust its immediately upstream server.
trust only that there exists at least one one honest
server, an assumption previously dubbed anytrust [51,
52], as a trust analog to anycast communication.

Verdict,

like Dissent, achieves security under the
anytrust assumption through the DC-nets key-sharing
model shown in Figure 2 (c). Each client shares a se-
cret with every server, rendering client ciphertexts in-
decipherable without the cooperation of all servers, and

USENIX Association  

22nd USENIX Security Symposium  149

3

(a) Multi-provider cloud model [52]

(b) Communication topology

(c) DC-nets secret sharing

Figure 2: Verdict/Dissent deployment model, physical communication topology, and DC-nets secret sharing

hence protecting a client’s anonymity even if its immedi-
ately upstream server is malicious. Each client ultimately
obtains an anonymity set consisting of the set of all hon-
est clients, provided that the anytrust assumption holds,
and provided the message contents themselves do not in
some way reveal the sender’s identity.

A malicious server might refuse to service honest
clients, but such refusal does not compromise clients’
anonymity—victims can simply switch to a different
server. Although not yet supported in our Verdict pro-
totype, Section 4.6 discusses how one might use thresh-
old secret sharing to tolerate server failures, at the cost of
requiring that we assume multiple servers are honest.

3.2 Security Goals

Verdict’s goal is to offer anonymity and disruption resis-
tance in the face of a strong adversary who can poten-
tially monitor all network links, modify packets as they
traverse the network, and compromise a potentially large
fraction of a group’s participating members. We say that
a participant is honest if it follows the protocol exactly
and does not collude with or leak secret information to
other nodes. A participant is dishonest otherwise. Dis-
honest nodes can exhibit Byzantine behavior—they can
be arbitrarily incorrect and can even just “go silent.”

The system is designed to provide anonymity among
the set of honest participants, who remain online and un-
compromised throughout an interaction period, and who
do not compromise their identity via the content of the
messages they send. We deﬁne this set of honest and
online participants as the anonymity set for a protocol
run. If a group contains many colluding dishonest par-
ticipants, Verdict can anonymize the honest participants
only among the remaining subset of honest members:
in the worst case of a group containing only one hon-
est member, for example, Verdict operates but can offer
that member no meaningful anonymity.

Similarly, Verdict does not prevent long-term inter-
section attacks [28] against otherwise-honest participants
who repeatedly come and go during an interaction pe-
riod, leaking information to an adversary who can corre-
late online status with linkable anonymous posts. Rea-
soning about anonymity sets generally requires making
inherently untestable assumptions about how many group

members may be dishonest or unreliable, but Verdict at
least does not assume that the honest participants know
which other participants are honest and reliable.

Finally, Verdict’s disruption-resistant design addresses
internal disruption attacks by misbehaving anonymous
participants, a problem speciﬁc to anonymous commu-
nication tools and particularly DC-nets. Like any dis-
tributed system, Verdict may be vulnerable to more gen-
eral network-level Denial-of-Service (DoS) attacks as
well, particularly against the servers that are critical to
the system’s availability and performance. Such attacks
are important in practice, but not speciﬁc to anonymous
communication systems. This paper thus does not ad-
dress general DoS attacks since well-known defenses ap-
ply, such as server provisioning, selective trafﬁc block-
ing, and proof-of-life or proof-of-work challenges.

4 Protocol Design

Verdict consists of two major components: the messag-
ing protocol, and the cryptographic primitive clients and
servers use to construct their ciphertexts. This section de-
scribes the Verdict messaging protocols, and the follow-
ing section describes the cryptographic constructions.

4.1 Core Verdict Protocol

Figure 3 summarizes the steps comprising a normal-case
run of the Verdict protocol. This protocol represents a
direct adaptation of the DC-nets scheme (Section 2.2) to
the two-level communication topology illustrated in Fig-
ure 2 (b), and to the client/server secret-sharing graph in
Figure 2 (c). As in Dissent, Verdict’s anonymity guar-
antee relies on Chaum’s original security analysis [13],
in which an honest node’s anonymity set consists of the
set of honest nodes that remain connected in the secret-
sharing graph after removing links to dishonest nodes.
Since each client shares a secret with every server, and
we assume that there exists at least one honest server, this
honest server forms a “hub” connecting all honest nodes.
This anonymity property holds regardless of physical
communication topology, which is why the clients need
not trust their immediately upstream server.

The ciphertext- and proof-generation processes as-
sume that communication in the DC-net is broken up into
time slots (akin to TDMA), such that only one client—

150  22nd USENIX Security Symposium 

USENIX Association

4

1. Client Ciphertext Generation. Each client i gen-
erates a client ciphertext, and submits this cipher-
text to client i’s upstream server.
If client i is the
anonymous owner of the current slot, the client com-
putes and submits a slot owner ciphertext using her
pseudonym secret key and her plaintext message m.
2. Client Set Sharing. After receiving valid client
ciphertexts from its currently connected downstream
clients, each server j broadcasts to all servers its set
C j of collected client ciphertexts.
3. Server Ciphertext Generation. After receiving
client ciphertext sets from all servers, each server j

computes C =(cid:31)k Ck, the set of client ciphertexts col-

lected by all servers. Server j then uses C to compute
a server ciphertext corresponding to the set of submit-
ted client ciphertexts. Server j broadcasts this server
ciphertext to all other servers.
4. Plaintext Reveal. After receiving a server cipher-
text from every other server, each server j combines
the |C| client ciphertexts and M server ciphertexts to
reveal the plaintext message m. Server j signs m and
broadcasts its signature σj to all servers.
5. Plaintext Sharing. After receiving valid signa-
tures from all servers, server j sends the plaintext
message m and the M signatures σ1, . . . ,σM (one from
each server) to its downstream clients.
6. Client Veriﬁcation. Upon receiving the plaintext
m and M valid signatures from its upstream server,
client i accepts the plaintext message and considers
the messaging round to have completed successfully.

All messages sent over the network include a session
nonce and are signed with the sender’s long-term
well-known (non-anonymous) signing key.

Figure 3: Core Verdict messaging protocol

the slot’s owner—is allowed to send an anonymous mes-
sage in each time slot. The owner of a slot is the client
who holds the private key corresponding to a pseudonym
public key assigned to the slot. To maintain the slot
owner’s anonymity, no one must know which client owns
which transmission slot. Section 4.3 below describes the
assignment of pseudonym keys to transmission slots.

Figure 4 shows an example DC-net

transmission
schedule with three slots, owned by pseudonyms A, B,
and C. Each slot owner can transmit one message per
messaging round, and the slot ordering in the schedule
remains the same for the duration of the Verdict session.

4.2 Veriﬁable Ciphertexts in Verdict

While Verdict’s anonymity derives from the same prin-
ciples as Dissent’s, the key difference is in the “alpha-

Figure 4: Example DC-net transmission schedule, where
anonymous authors A, B, and C transmit in each round.

bet” with which Verdict generates DC-net ciphertexts,
and in the way Verdict combines and checks those ci-
phertexts. Dissent uses a symmetric-key cryptographic
pseudo-random number generators (PRNG) to generate
shared secrets, and uses bitwise XOR to combine them
and later to reveal the plaintext message. While efﬁcient,
the symmetric-key approach offers no way to check that
any node’s ciphertext was generated correctly until the ﬁ-
nal cleartext messages are revealed. If any node corrupts
a protocol round by sending an incorrect ciphertext, Dis-
sent can eventually identify that node only via a complex
retroactive blame procedure.

Verdict,

in contrast, divides messages into chunks
small enough to be encoded into elements of algebraic
groups, such as Schnorr [42] or elliptic curve groups,
to which known proof-of-knowledge techniques apply.
Section 5 later outlines three particular ciphertext gen-
eration schemes that Verdict implements, although Ver-
dict’s architecture and protocol design is agnostic to the
speciﬁc scheme. These schemes may be considered anal-
ogous to “pluggable” ciphersuites in SSL/TLS.

Thus, any Verdict ciphertext is generated on behalf of
the holder of some particular pseudonym keypair. While
the details of a ciphertext correctness proof depend on
the particular scheme, all such proofs have the general
form of an “either/or” knowledge proof, of the type sys-
tematized by Camenisch and Stadler [11]. In particular,
a ciphertext correctness proof attests that either:
• the ciphertext is an encryption of any message, and the
producer of the ciphertext holds the private part of the
pseudonym key for this slot, OR

• the ciphertext is an encryption of a null cover message,
which, when combined with other cover ciphertexts
and exactly one actual encrypted message ciphertext,
will combine to reveal the encrypted message.
Only the pseudonym key owner can produce a correct-
ness proof for an arbitrary message following the ﬁrst al-
ternative above, while any node can generate an “honest”
cover ciphertext—and the proof by construction reveals
no information about which alternative the proof gener-
ator followed. We leave discussion of further details of
this process to Section 5, but merely note that such “ei-
ther/or” proofs are pervasive and well-understood in the
cryptographic theory community.

USENIX Association  

22nd USENIX Security Symposium  151

5

In Verdict, each client computes and attaches a crypto-
graphic correctness proof to each ciphertext it sends to its
upstream server, and each server in turn attaches a cor-
rectness proof to the server-side ciphertext it generates
in Phase 3 of each round (Figure 3). In principle, there-
fore, each server can immediately verify the correctness
of any client’s or other server’s ciphertext it receives, be-
fore “accepting” it and combining it with the other ci-
phertexts for that protocol round. As in Dissent, Verdict
achieves resilience to client churn by (optionally) requir-
ing clients to submit their ciphertexts before a certain
“deadline” in each messaging round. We describe this
technique in Section 4.5.

While Verdict nodes can in principle verify the cor-
rectness of any received ciphertext immediately, actually
doing so has performance costs. These costs lead to de-
sign tradeoffs between “eager” and “lazy” veriﬁcation,
both of which we implement and evaluate later in Sec-
tion 6. Lazy veriﬁcation enables the critical servers to
avoid signiﬁcant computation costs during rounds that
are not disrupted, at the expense of making a round’s out-
put unusable if it is disrupted. Even if a lazily-veriﬁed
round is disrupted, however, the fact that Verdict nodes
always generate and transmit signed ciphertext correct-
ness proofs greatly simpliﬁes and shortens the retroactive
blame process with respect to Dissent.

Verdict currently treats server-side failures of all
types, including invalid server ciphertexts, as “major
events” requiring administrative action, and simply halts
the protocol with an alert until such action is taken. Sec-
tion 4.6 later discusses approaches to make Verdict re-
silient against server-side failures, but we leave imple-
menting and evaluating such mechanisms to future work.
Such server-side failures affect only availability, how-
ever; anonymity remains protected as long as at least one
(not necessarily online) server remains uncompromised.

4.3 Scheduling Pseudonym Keys

To assign ownership of transmission slots to clients in
such a way that no one knows which client owns which
slot, Verdict applies an architectural idea from Dis-
sent [52]. At the start of a Verdict session, each of the
N clients secretly submits a slot owner pseudonym key
to a veriﬁable shufﬂe protocol [36] run by the servers.
The public output of the shufﬂe is the N pseudonym keys
in permuted order—such that no one knows which node
submitted which pseudonym key other than their own.
Verdict participants then use each of these N pseudonym
keys to initialize N concurrent instances of the core Ver-
dict DC-net with each instance becoming a slot in a ver-
iﬁable DC-net transmission schedule.

Scheduling Policy Not every client will necessarily
want to transmit an anonymous message in every mes-
saging round. In addition, clients may want to transmit

messages of different lengths. To make Verdict more ef-
ﬁcient in these cases, Verdict allows clients to request a
change in the length of their messaging slot (e.g., so that
a client can send a long message in a single messaging
round) and to temporarily “close” their transmission slot
(if a client does not expect to send a message for several
rounds). Clients issue these requests by prepending a few
bits of control data to the anonymous message they send
in their transmission slot.

4.4 Hybrid XOR/Veriﬁable DC-Nets

While the veriﬁable DC-net design above may be needed
in scenarios in which disruptions are frequent, the public-
key cryptography involved imposes a much higher com-
putational cost than traditional XOR-based DC-nets. To
offer better performance in groups with fewer or less fre-
quent disruptions, Verdict has a “hybrid” mode of opera-
tion that uses the fast XOR-based DC-net when there are
no active disruptors in the group, and reverts to a veriﬁ-
able DC-net in the presence of an active disruptor. This
hybrid Verdict DC-net marries the relatively low com-
putational cost of the XOR-based DC-net with the low
accountability cost of the veriﬁable DC-net.

To set up a hybrid DC-net session, all protocol partici-
pants ﬁrst participate in a pseudonym signing key shufﬂe,
as described above in Section 4.3. At the conclusion of
the shufﬂe, all nodes initialize two DC-net slots for each
of the N clients: one traditional Dissent-style DC-net,
and one veriﬁable Verdict DC-net.

When the group is not being disrupted, clients trans-
mit in their Dissent DC-net slot, allowing nodes to take
advantage of the speed of Dissent’s XOR-based DC-net.
When nodes detect the corruption of a message in the
Dissent DC-net, the client whose message was corrupted
reverts to transmitting in its veriﬁable DC-net slot. This
client can use the veriﬁable slot to transmit anonymously
the “accusation” necessary to identify the disruptor in the
Dissent accusation process [52, Section 3.9]. The Verdict
DC-net replaces the expensive veriﬁable shufﬂe neces-
sary for nodes to exchange the accusation information in
Dissent. In this way, Verdict offers the normal-case ef-
ﬁciency of XOR-based DC-nets while greatly reducing
the cost of tracing and excluding disruptors.

4.5 Client Churn

In realistic deployments clients may go ofﬂine at any
time, and this problem becomes severe in large groups
of unreliable clients exhibiting constant churn. To pre-
vent slow or unresponsive clients from disrupting com-
munication, the servers need not wait in Phase 2 for
all downstream clients to submit ciphertexts.
Instead,
servers can wait for a ﬁxed threshold of t ≤ N clients
to submit ciphertexts, or for some ﬁxed time interval τ.
Servers might also use some more complicated window

152  22nd USENIX Security Symposium 

USENIX Association

6

closure policy, as in Dissent [52]: e.g., wait for a thresh-
old of clients and then an additional time period before
proceeding. The participants must agree on a window
closure policy before the protocol run begins.

There is an inherent tradeoff between anonymity and
the system’s ability to cope with unresponsive clients. If
the servers close the ciphertext submission window too
aggressively, honest but slow clients might be unable to
submit their ciphertexts in time, reducing the anonymity
of clients who do manage to submit messages. In con-
trast, if the servers wait until every client has submitted
a ciphertext, a single faulty client could prevent protocol
progress indeﬁnitely. Optimal policy choices depend on
the security requirements of the application at hand.

4.6 Limitations and Future Enhancements

This section outlines some of Verdict’s current limita-
tions, deployment issues, and areas for future work.

Group Evolution Verdict’s architecture assumes that,
at the start of the protocol, group members agree to
a “roster” of protocol participants—essentially a list of
public keys deﬁning the group’s membership. The cur-
rent prototype simplistically assumes that this group ros-
ter is a static list, and that the session nonce is a hash
of a ﬁle containing this roster and other group policy in-
formation. This design trivially ensures that all nodes
participating in a given group (uniquely identiﬁed by its
session nonce) agree upon the same roster and policy.
Changing the group roster or policy in the current pro-
totype requires forming a new group, but we are explor-
ing approaches to group management which would allow
for on-the-ﬂy membership changes. For now, we simply
note that Verdict’s security properties critically depend
on group membership policy decisions, which affect how
quickly adversarial participants can inﬁltrate a group. We
consider group management policy to be orthogonal to
this paper’s communication mechanisms.

Sybil Attacks
If it is too easy to join a group, dishon-
est participants might ﬂood the group with Sybil identi-
ties [19], giving an anonymous slot owner the impression
that she has more anonymity than she actually does. The
current “static group” design shifts the Sybil attack pre-
vention problem to whomever formulates the group ros-
ter. Dynamic group management schemes could leverage
existing Sybil prevention techniques [47, 53, 54], but we
do not consider such approaches herein.

Membership Concealment Verdict considers
the
group roster, containing the public keys of all partici-
pants, to be public information: concealing participation
in the protocol is an orthogonal security goal that Verdict
currently does not address. We are exploring the use
of anonymous authentication techniques [22, 29, 41] to
enable Verdict clients to “sign on” and prove member-

ship in the group without revealing to the Verdict servers
(or to the adversary) which speciﬁc group members are
online at any given time. Further, we expect that Ver-
dict’s design could be composed with other techniques to
achieve membership concealment [33, 49], but we leave
such enhancements to future work.

Unresponsive Servers Verdict currently assumes that
the servers supporting a group are well-provisioned and
highly reliable, and the system simply ceases communi-
cation progress in the face of any server’s failure. Any
fault-masking mechanism would be problematic, in fact,
in the face of Verdict’s assumption that only one server
might be honest: if that one honest server goes ofﬂine
and the protocol continues without it, then the remaining
dishonest servers could collude against all honest users.
If we assume that there are h > 1 honest servers,
however, a currently unimplemented variation of Verdict
could allow progress if as many as h − 1 servers are un-
responsive. Before the protocol run, every server uses
a publicly veriﬁable secret sharing scheme [43], to dis-
tribute shares of its per-session secret key. The scheme
is conﬁgured such that any quorum of M − h + 1 shares
is sufﬁcient to reconstruct the secret. Thus, at least one
honest server must remain online and contribute a share
for a secret to be reconstructed. (Golle and Juels [25] also
use a secret-sharing scheme, but they rely on a trusted
third-party to generate and distribute the shares.)

If a server becomes unresponsive, the remaining on-
line servers can broadcast their shares of the unrespon-
sive server’s secret key. Once a quorum of servers broad-
casts these shares, the remaining online servers will be
able to reconstruct the unresponsive server’s private key.
Thereafter, each server can simulate the unresponsive
server’s messages for the rest of the protocol session.

Blame Recovery The current Verdict prototype can
detect server misbehavior, but it does not yet have a
mechanism by which the remaining servers can collec-
tively form a new group “roster” with the misbehaving
nodes removed. We expect off-the-shelf Byzantine Fault
Tolerance algorithms [12] to be applicable to this group
evolution problem. Using BFT to achieve agreement,
however, requires a stronger security assumption:
in a
group with f dishonest servers, there must be at least
3 f + 1 total servers. We sketch a possible BFT-based
group evolution approach here.

The BFT cluster’s shared state in this case is the group
“roster,” containing the session nonce and a list of all ac-
tive Verdict clients and servers, identiﬁed by their public
keys. The two operations in this BFT system are:
• EVOLVE GROUP(nonce, node index, proof),

a
request to remove a dishonest node (identiﬁed by
node index) from the group roster. BFT servers

USENIX Association  

22nd USENIX Security Symposium  153

7

remove the dishonest node from the group if the proof
is valid, yielding the new group roster.

• GET GROUP(), which returns current the group roster.
If, at some point during the Verdict session, a Ver-
dict node concludes that the protocol has failed due to
the dishonesty of node d, this honest node makes an
EVOLVE GROUP request to the BFT cluster and waits for
a response. The honest BFT servers will agree on a
new group roster with the dishonest node d removed
and the Verdict servers will begin a new instance of the
Verdict protocol with the new group roster. Clients use
GET GROUP to learn the new group roster.

5 Veriﬁable DC-net Constructions

The Verdict architecture relies on a veriﬁable DC-net
primitive that has many possible implementations. In this
section, we ﬁrst describe the general interface that each
of the cryptographic constructions must implement—
which could be described as a “Verdict ciphersuite
API”—then we describe the three speciﬁc experimental
schemes that Verdict currently implements.

All three schemes are founded on standard, well-
understood cryptographic techniques that have been for-
mally developed and rigorously analyzed in prior work.
As with most practical, complex distributed systems with
many components, however, we cannot realistically offer
a rigorous proof that these cryptographic tools “ﬁt to-
gether” correctly to form a perfectly secure overall sys-
tem. (This is true even of SSL/TLS and its ciphersuites,
which have received far more cryptographic scrutiny
than Verdict but in which ﬂaws are still found regularly.)
We also make no claim that any of the current schemes
are “the right” ones or achieve any particular ideal; we
merely offer them as contrasting points in a large design
space. To lend some informal credibility to their secu-
rity, we note that our pairing-based scheme is closely
modeled on the veriﬁable DC-nets scheme that Golle and
Juels already developed formally [25], and the extended
version of this paper [15] sketches a security argument
for the third and most computationally efﬁcient scheme.

5.1 Veriﬁable DC-net Primitive API

The core cryptographic primitive consists of a set of six
methods. Each of these six methods takes a list of proto-
col session parameters (e.g., group roster, session nonce,
slot owner’s public key) as an implicit argument:
• Cover Create: Given a client session secret key, return
a valid client ciphertext representing “cover trafﬁc,”
which do not contain actual messages.

• Owner Create: Given a client session secret key, the
slot owner’s pseudonym secret key, and a plaintext
message m to be transmitted anonymously, return a
valid owner ciphertext that encodes message m.

• Client Verify: Given a client public key and a client
ciphertext, return a boolean ﬂag indicating whether the
client ciphertext is valid.

• Server Create: Given a server private key and a set of

client ciphertexts, return a valid server ciphertext.

• Server Verify: Given a server public key, a set of valid
client ciphertexts, and a server ciphertext, return a ﬂag
indicating whether the server ciphertext is valid.

• Reveal: Combine N client ciphertexts and M server

ciphertexts, returning the plaintext message m.

However these methods are implemented,
they must
obey the following security properties, stated informally:
• Completeness: An honest veriﬁer always accepts a

ciphertext generated by an honest client or server.

• Soundness: With overwhelming probability an hon-
est veriﬁer rejects an incorrect ciphertext, such as an
owner ciphertext formed without knowledge of the
owner’s pseudonym secret key.

• Zero-knowledge: A veriﬁer learns nothing about a ci-

phertext besides the fact that it is correctly formed.

• Integrity: Combining N valid client ciphertexts,
including one ciphertext from the anonymous slot
owner, and M valid server ciphertexts, reveals the slot
owner’s plaintext message.

• Anonymity: A veriﬁer cannot distinguish a client ci-
phertext from the anonymous slot owner’s ciphertext.
The extended version of this paper [15] offers a game-
based deﬁnition of anonymity.

In practice, each of our current
implementations of
this veriﬁable DC-nets primitive achieve these security
properties in the random-oracle model [5] using non-
interactive zero-knowledge proofs [26].

5.2 ElGamal-Style Construction

The ﬁrst scheme builds on the ElGamal public-key cryp-
tosystem [20]. In ElGamal, a public/private keypair has
the form �B, b� = �gb, b�,1 and plaintexts and ciphertexts
are elements of an algebraic group G.2 We refer to this
as the “ElGamal-style” construction because its use of an
ephemeral public key and encryption by multiplication
structurally resembles the ElGamal cryptosystem. Our
construction does not exhibit the malleability of textbook
ElGamal encryption, however, because a proof of knowl-
edge of the secret ephemeral public key is attached to
every ciphertext element.

Client Ciphertext Construction Given a list of server
public keys �B1, . . . ,B M�, a client constructs a ciphertext

1 We do not require that a trusted third party generate participants’
keypairs, but we do require participants to prove knowledge of their
secret key at the start of a protocol session, for reasons described in the
extended version of this paper [15].

2 Throughout, unless otherwise noted, group elements are members
of a ﬁnite cyclic group G in which the Decision Difﬁe-Hellman (DDH)
problem [6] is assumed computationally infeasible, and g is a public
generator of G.

154  22nd USENIX Security Symposium 

USENIX Association

8

by selecting an ephemeral public key Ri = gri at random
and computing the ciphertext element:

Ci = m(cid:31)ΠM

j=1B j(cid:30)ri

If the client is the slot owner, the client sets m to its secret
message, otherwise the client sets m = 1.

To satisfy the security properties described in Sec-
tion 5.1, the client must somehow prove that the ci-
phertext tuple �Ri,Ci� was generated correctly. We
adopt the technique of Golle and Juels [25] and use
a non-interactive proof-of-knowledge of discrete loga-
rithms [11] to prove that the ciphertext has the correct
form.
If the slot owner’s pseudonym public key is Y ,
the client’s ephemeral public key is Ri, and the client’s
ciphertext element is Ci, the client generates a proof:

PoK{ri, y :(cid:31)Ri = gri ∧ Ci = (ΠM

j=1B j )

ri(cid:30) ∨ Y = gy}

In words: the sender demonstrates that either it knows
the discrete logarithm ri of the ephemeral public key Ri,
and the ciphertext is the product of all server public keys
raised to the exponent ri; or the sender knows the slot
owner’s secret pseudonym key y, in which case the slot
owner can set Ci to a value of her choosing. The extended
version of this paper [15] details how to construct and
verify this type of non-interactive zero-knowledge proof.
Note that a dishonest slot owner can set Ci to a mali-
ciously constructed value (e.g., Ci = 1). The only effect
of such an “attack” is that the slot owner compromises
her own anonymity. Since a dishonest slot owner can
always compromise her own anonymity (e.g., by pub-
lishing her secret keys), a dishonest slot owner achieves
nothing by setting Ci maliciously.

The tuple �Ri,Ci, PoK� serves as the client’s cipher-
text. As explained in Section 4.1, all participants sign
the messages they exchange for accountability.

Server Ciphertext Construction Given a server pub-
lic key B j = gb j and a list of ephemeral client public keys
�R1, . . . , RN�, server j generates its server ciphertext as:

S j =(cid:31)ΠN

i=1Ri(cid:30)−b j

The server proves the validity of its ciphertext by creating
a non-interactive proof of knowledge that it knows its
secret private key b j and that its ciphertext element S j
is the product of the ephemeral client keys raised to the
exponent −b j:

PoK{b j : B j = gb j ∧ S j = (ΠN

i=1Ri)−b j }

Message Reveal To reveal the plaintext message, a
participant computes the product of N client ciphertext
elements and M server ciphertext elements:

m =(cid:31)ΠN

i=1Ci(cid:30)(cid:31)ΠM

j=1S j(cid:30)

Each factor grib j , where ri is client i’s ephemeral secret
key and b j is server j’s secret key, is included exactly

twice in the above product—once with a positive sign in
the client ciphertexts and once with a negative sign in the
server ciphertexts. These values therefore cancel, leaving
only the plaintext m.

the

clients must use

Drawbacks Since
a new
ephemeral public key for each ciphertext element, send-
ing a plaintext message that is L group elements in length
requires each client to generate and transmit L ephemeral
public keys. The proof of knowledge for this construc-
tion is L + O(1) group elements long, so a message of L
group elements expands to 3L + O(1) elements.

5.3 Pairing-Based Construction

A major drawback of the ElGamal construction is that,
due to the need for ephemeral keys, every ciphertext is
three times as long as the plaintext it encodes. Golle
and Juels [25] use bilinear maps to eliminate the need for
ephemeral keys. Our pairing-based construction adopts
elements of their technique, while avoiding their reliance
on a trusted third party, a secret-sharing scheme, and a
probabilistic transmission scheduling algorithm.

A symmetric bilinear map ˆe maps two elements of
a group G1 into a target group G2— ˆe : G1 × G1 →
G2. A bilinear map has the property that: ˆe(aP, bQ) =
ˆe(P, Q)ab.3 To be useful, the map must also be non-
degenerate (if P is a generator of G1, ˆe(P, P) is a gen-
erator of G2) and efﬁciently computable [8]. We assume
that the decision bilinear Difﬁe-Hellman assumption [7]
holds in G1.4

Since pairing allows a single pair of public keys to
generate a sequence of shared secrets, clients need not
generate ephemeral public keys for each ciphertext ele-
ment they send. This optimization leads to shorter ci-
phertexts and shorter correctness proofs.

Client Ciphertext Construction For a set of server
public keys �B1, . . . , BM�, a public nonce τ ∈ G1 com-
puted using a hash function, and a client public key
Ai = gai , a pairing-based client ciphertext has the form:

Ci = m ˆe(ΠM

j=1B j,τ)

ai

As before, if the client is not the slot owner, the client sets
m = 1. Each client can produce a proof of the correctness
of its ciphertext by executing a proof of knowledge simi-
lar to one used in the ElGamal-style construction above:
PoK{ai, y : (Ai = gai ∧ Ci = ˆe(ΠM
ai ) ∨ Y = gy}

j=1B j,τ)

While the ElGamal-style scheme requires 3L + O(1)
group elements to encode L elements of plaintext, a

3 Since G1 is usually an elliptic curve group, the generator of G1
is written as P (an elliptic curve point) and the repeated group opera-
tion is written as aP instead of ga. We will use the latter notation for
consistency with the rest of this section.

4 Note that the decision Difﬁe-Hellman problem is easy in G1, since
given g, ga, gb, gc ∈ G1, a DDH tuple will always satisfy ˆe(ga, gb) =
ˆe(g, gc) if c = ab mod q.

USENIX Association  

22nd USENIX Security Symposium  155

9

pairing-based ciphertext requires only L + O(1) group el-
ements to encode an L-element plaintext.

Server Ciphertext Construction Using a server pub-
lic key B j = gb j , a public round nonce τ, and client public
keys �A1, . . . , AN�, a server ciphertext has the form:

S j = ˆe(ΠN

i=1Ai,τ)−b j

The server proof of correctness is then:

PoK{b j : B j = gb j ∧ S j = ˆe(ΠN

i=1Ai,τ)−b j }

Message Reveal To reveal the plaintext, the servers
take the product of all client and server ciphertexts:

m = (ΠN

i=1Ci)(ΠM

j=1S j )

Drawbacks The main downside of this construction is
the relatively high computational cost of the pairing oper-
ation. Computing the pairing operation on two elements
of G1 can take an order of magnitude longer than a nor-
mal elliptic curve point addition in a group of similar se-
curity level, as Section 6.2 below will show.

5.4 Hashing-Generator Construction

Our hashing-generator construction pursues a “best of
both worlds” combination of the ElGamal-style and
pairing-based constructions.
This construction has
short ciphertexts,
like the pairing-based construction,
but avoids the computational cost of the pairing-based
scheme by using conventional integer or elliptic curve
groups. To achieve both of these desired properties, the
hashing-generator construction adds some protocol com-
plexity, in the form of a session set-up phase.

Set-up Phase
In the set-up phase, each client i es-
tablishes a Difﬁe-Hellman shared secret ri j with every
server j using their respective public keys gai and gb j by
computing ri j = KDF(gaib j ) using a key derivation func-
tion KDF. Clients publish commitments to these shared
secrets Ri j = ˆgri j using another public generator ˆg.

The hashing-generator construction requires a process
by which participants compute a sequence of generators
g1, . . . , gL of the group G, such that no participant knows
the discrete logarithm of any of these generators with
respect to any other generator. In other words, no one
knows an x such that gx
= g j, for any i, j pair. In prac-
i
tice, participants compute this sequence of generators by
hashing a series of strings, (e.g., the round nonce con-
catenated with “1”, “2”, “3”, . . . ), to choose the set of
generating group elements.

At the end of the set-up phase, every client i can
produce a sequence of shared secrets with each server
j using their shared secret ri j and the L generators:
ri j
ri j
1 , . . . , g
L . In the ℓth message exchange round, all par-
g
ticipants use generator gℓ as their common generator.

Client Ciphertext Construction To use the hashing-
generator scheme to create a ciphertext, the client uses its
shared secrets ri1, . . . ,r iM with the servers, and generator
gℓ for the given protocol round to produce a ciphertext:

(∑M
Ci = mg
ℓ

j=1 ri j )

As before, m = 1 if the sender is not the slot owner.

To prove the validity of a ciphertext element, the client
executes the following proof of knowledge, where Y is
the slot owner’s pseudonym public key, ri = ∑M
j=1 ri j, and
Ri j is the commitment to the secret shared between client
i and server j:

PoK{ri, y : ((ΠM

j=1Ri j ) = ˆgri ∧ Ci = gri
ℓ

) ∨ Y = gy}

Server Ciphertext Construction Server j’s ciphertext
for the ℓth message exchange round is similar to the
client ciphertext, except with negated exponents:

(−∑N
S j = g
ℓ

i=1 ri j )

The server proves correctness of a ciphertext by execut-
ing a proof of knowledge, where r j = ∑N

PoK{r j : (ΠN

i=1Ri j ) = ˆgr j ∧ S j = g

i=1 ri j:
−r j
ℓ }

Message Reveal The product of the client and server
ciphertexts reveals the slot owner’s plaintext message m:

m = (ΠN

i=1Ci)(ΠM

j=1S j )

Failed Session Set-up A dishonest client i might try
to disrupt the protocol by publishing a corrupted com-
mitment R′
i j that disagrees with server j’s commitment
Ri j to the shared secret ri j = KDF(gaib j ). If the commit-
ments disagree, the honest server can prove its innocence
by broadcasting the Difﬁe-Hellman secret ρi j = gaib j
along with a proof that it correctly computed the Difﬁe-
Hellman secret using its public key B j and the client’s
public key Ai.

b j
PoK{b j : ρi j = A
i ∧ B j = gb j }

If the server is dishonest, the client can produce a simi-
lar proof of innocence. Any user can verify this proof,
and then use gaib j to recreate the correct commitment
Ri j. Once the veriﬁer has the correct commitment Ri j,
the veriﬁer can conﬁrm either that the client in question
published an invalid commitment or that the server in
question dishonestly accused the client.

Since the session set-up between client i and server
j will only fail if either i or j is dishonest, there is no
security risk to publishing the shared secret gaib j after a
failed set-up—the dishonest client (or server) could have
shared this secret with the adversary anyway.

Long Messages The client and server ciphertext con-
structions described above allow the slot owner to trans-
mit a plaintext message m that is at most one group el-
ement in length in each run of the protocol. To encode

156  22nd USENIX Security Symposium 

USENIX Association

10

longer plaintexts efﬁciently, participants use a modiﬁed
proof-of-knowledge construction that proves the validity
of L ciphertext elements (Ci,1 through Ci,L) at once:
PoK{ri, y : ((ΠM

j=1Ri j = ˆgri ) ∧ (∧L

ℓ=1Ci,ℓ = gri
ℓ

)) ∨ Y = gy}

Servers can use a similarly modiﬁed proof of knowledge.
This modiﬁed knowledge proof is surprisingly compact:
the length of the proof is constant in L, since the length
of the proof is linear in the number of proof variables
(here, the only variables are ri and y). The total length of
the tuple ��Ci, PoK� using this proof is L + O(1).
Lazy Proof Veriﬁcation In the basic protocol, every
server veriﬁes the validity proof on every client cipher-
text in every protocol round. To avoid these expensive
veriﬁcation operations, servers can use lazy proof veri-
ﬁcation: servers check the validity of the client proofs
only if they detect, at the end of a protocol run, that the
anonymous slot owner’s message was corrupted. For rea-
sons discussed in the extended version of this paper [15],
lazy proof veriﬁcation is possible only using the pairing-
based or hashing-generator ciphertext constructions.

Security Analysis Since
hashing-generator
scheme is the most performant variant, we sketch an
informal security proof for the hashing-generator proof
construction in the extended version of this paper [15].

the

6 Evaluation

This section describes our Verdict prototype implemen-
tation and summarizes the results of our evaluations.

6.1

Implementation

We implemented the Verdict protocol in C++ using the
Qt framework as an extension to the existing Dissent pro-
totype [52]. Our implementation uses OpenSSL 1.0.1 for
standard elliptic curve groups, Crypto++ 5.6.1 for big in-
teger groups, and the Stanford Pairing-Based Cryptogra-
phy (PBC) 0.5.12 library for pairings [48]. Unless other-
wise noted, the evaluations use 1024-bit integer groups,
the 256-bit NIST P-256 elliptic curve group [37], and
a pairing group in which G1 is an elliptic curve over a
512-bit ﬁeld (using PBC’s “Type A” parameters) [30].
We collected the macrobenchmark and end-to-end eval-
uation results on the DeterLab [17] testbed.

The source code for our implementation is available at

https://github.com/DeDiS/Dissent.

6.2 Microbenchmarks

To compare the pure computational costs of the differ-
ent DC-net schemes, Figure 5 shows ciphertext gener-
ation and veriﬁcation throughput measured at a variety
of block sizes, running on a workstation with a 3.2 GHz
Intel Xeon W3565 processor. These experiments involve
no network activity, and are single-threaded, thus they do
not reﬂect any speedup that parallelization might offer.

Figure 5: Ciphertext generation and veriﬁcation through-
put for the three veriﬁable DC-net variants and the XOR-
based scheme.

The hashing-generator construction, which is the
fastest scheme tested, encrypts 20 KB of client plaintext
per second. The slowest, paring-based construction en-
crypts around 3 KB per second. The fastest veriﬁable
scheme is still over an order of magnitude slower than
the traditional (unveriﬁable) XOR-based scheme, which
encrypts 600 KB of plaintext per second. The hashing-
generator scheme performs best because it needs no pair-
ing operations and requires fewer group exponentiations
than the ElGamal construction.

Figure 5 shows that ciphertext veriﬁcation is slightly
faster than ciphertext generation. This is because gener-
ating the ciphertext and zero-knowledge proof requires
more group exponentiations than proof veriﬁcation does.
The three constructions also vary in the size of ci-
phertexts they generate (Figure 6). While the pairing-
based scheme and the hashing-generator schemes en-
crypt length L plaintexts as ciphertexts of length L +
O(1),
the ElGamal-style scheme encrypts length L
plaintexts as length 3L + O(1) ciphertexts. As dis-
cussed in Section 5.2, for every plaintext message ele-
ment encrypted, ElGamal-style ciphertexts must include
an ephemeral public key and an additional proof-of-
knowledge group element. Since the hashing-generator
scheme is the fastest and avoids the ElGamal scheme’s
ciphertext expansion, subsequent experiments use the
hashing-generator scheme unless otherwise noted.

6.3 Accountability Cost

Figure 7 presents three graphs: (a) the time it takes to set
up a transmission schedule via a veriﬁable shufﬂe, prior
to DC-net communication, (b) the time required to exe-
cute a single DC-net protocol round in each scheme, and
(c) the time required to identify a disruptor. The graphs
compare four protocol variants: Dissent, Verdict, Verdict

USENIX Association  

22nd USENIX Security Symposium  157

11

 10000

 1000

s
d
n
o
c
e
s
 

n

i
 

e
m
T

i

 100

 10

 1

 0.1

Session Setup (Shuffle)

DC-net Messaging Round

Identify Disruptor

 

 

 

 

 

 

 

 

 

 

 

 

 10

 100

 1000

 10

 100

 1000

 10

 100

 1000

Dissent

Dissent+Verdict

Verdict

Verdict (lazy)

Number of clients

Figure 7: Time required to initialize a session, perform one messaging round, and to identify a disruptor.

In contrast, Verdict becomes computationally limited at
64 clients, taking approximately 2.5 seconds per round.
Verdict (lazy) improves upon this by becoming compu-
tationally limited at 256 clients, requiring approximately
3 seconds per messaging round.

Verdict incurs the lowest accountability (blame) cost
of the four schemes. Verdict’s veriﬁable DC-net checks
the validity of each client ciphertext before processing it
further, so the time-to-blame in Verdict is equal to the
cost of verifying the validity proofs on N client cipher-
texts. “Verdict (lazy)” uses the lazy proof veriﬁcation
technique described in Section 5.4—servers verify the
client proofs of correctness only if they detect a disrup-
tion. Lazy proof veriﬁcation delays the veriﬁcation op-
eration to the end of a messaging phase, so the time-to-
blame is slightly higher than in pure Verdict.

Dissent, which has the highest time-to-blame, has an
accountability process that requires the anonymous client
whose message was corrupted to submit an “accusation”
message to a lengthy veriﬁable shufﬂe protocol, in which
all members participate. This veriﬁable shufﬂe is the rea-
son that Dissent takes the longest to identify a disruptor.
The hybrid Dissent+Verdict DC-net (Section 4.4) avoids
Dissent’s extra veriﬁable shufﬂe by falling back instead
to a veriﬁable DC-net to resolve disruptions.

As Figure 7 shows, the messaging round time in the
hybrid Dissent+Verdict DC-net is as fast as in Dissent,
but the hybrid scheme reduces Dissent’s time to detect
misbehavior by roughly two orders of magnitude.

6.4 Anonymous Microblogging

Verdict’s ability to tolerate many dishonest nodes makes
it potentially attractive for anonymous microblogging in
groups of hundreds of nodes. In Twitter, messages have a
maximum length of 140 bytes, which means that a single
tweet can ﬁt into a few 256-bit elliptic curve group ele-
ments. Twitter users can also tolerate messaging latency

Figure 6: Ciphertext expansion factor (overhead) using
the integer ElGamal-style, pairing-based, and hashing-
generator protocol variants.

with lazy proof veriﬁcation, and the Dissent+Verdict hy-
brid DC-net. We ran this experiment on DeterLab using
8 servers and 128 clients. To scale beyond 128 clients,
we ran multiple client processes on each client machine.
Session setup time measures the time from session start
to just before the ﬁrst DC-net messaging round.

The one-time session setup time for Verdict is longer
than for Dissent because the veriﬁable shufﬂe imple-
mentation Dissent uses is heavily optimized for shufﬂing
DSA signing keys. Shufﬂing Verdict public keys, which
are drawn from different group types, requires using a
less-optimized version of the veriﬁable shufﬂe. We do
not believe this cost is fundamental to the Verdict ap-
proach, and in any case these setup costs are typically
amortized over many DC-net rounds.

The Dissent+Verdict hybrid DC-net is just as fast as
Dissent in the normal case, since Dissent and the hy-
brid DC-net run exactly the same code if there is no ac-
tive disruptor in the group. Network latency comprises
the majority of the time for a messaging round when
using the Dissent and the hybrid Dissent+Verdict DC-
nets—messaging rounds take between 0.6 and 1.4 sec-
onds to complete in network sizes of 8 to 1,024 clients.

158  22nd USENIX Security Symposium 

USENIX Association

12

i

e
t
u
n
m
/
s
t
e
e
w
T

 60
 50
 40
 30
 20
 10
 0

 40

 72

 136

 264

 520

 1032

Active Twitter users

No anonymity
Dissent
Dissent+Verdict
Verifiable Mix Cascade

Verdict: Hashing
Verdict: Pairing
Verdict: ElGamal

Figure 8: Rate at which various anonymity schemes pro-
cess tweets, for varying numbers of active users.

of tens of seconds or even a few minutes, which would
be unacceptable for interactive web browsing.

This experiment evaluates the suitability of Verdict for
small-scale anonymous microblogging applications, giv-
ing users anonymity among hundreds of nodes, e.g., for
students microblogging on a university campus. To test
Verdict in this scenario, we recorded 5,000 Twitter users’
activity for one-hour and then took subsets of this trace:
the smallest subset contained only the Tweets of the 40
most active users, and the largest subset contained the
Tweets of the 1,032 most active users. We replayed each
of these traces through Dissent and through Verdict, us-
ing each of the three ciphertext constructions.

We ran our experiment on DeterLab [17], on a test
topology consisting of eight servers connected to a 100
Mbps LAN with 10 ms of server-to-server latency, and
with each set of clients connecting to their upstream
server over a shared 100 Mbps link with 50 ms of latency.
Scarcity of testbed resources limited the number of avail-
able delay links, but our experiment attempts to approxi-
mate a wide-area deployment model in which clients are
geographically dispersed and bandwidth-limited.

Figure 8 shows the Tweet-rate latency induced by the
different anonymity systems relative to the baseline (no
anonymity) as the number of active users (and hence, the
anonymity set size) in the trace increases. Both Dissent
and the Dissent+Verdict hybrid systems can keep pace
with the baseline in a 1,000-node network—the largest
network size feasible on our testbed. The pure Verdict
variants could not keep pace with the baseline in a 1,000-
node network, while hashing-generator variant of Verdict
runs almost as quickly as the baseline in an anonymity
set size of 264. These results suggest that Verdict might
realistically support proactively accountable anonymity
for microblogging groups of up to hundreds of nodes.

Figure 8 also compares Verdict to a mix-net cascade
(a set of mix servers) in which each mix server uses a
Neff proof-of-knowledge [36] to demonstrate that it has

performed the mixing operation properly. Like Verdict,
this sort of mix cascade forms a trafﬁc-analysis-resistant
anonymity system, so it might be used as an alternative
to Verdict for anonymous messaging. Our evaluation re-
sults demonstrate that the hashing-generator variant of
Verdict outperforms the mix cascade at all network sizes
and that the Tweet throughput of the Dissent+Verdict hy-
brid is more than 6× greater than the throughput of the
mix cascade at a network size of 564 participants.

6.5 Anonymous Web Browsing

Dissent demonstrated that accountable DC-nets are fast
enough to support anonymous interactive Web browsing
in local-area network deployments [52]. We now evalu-
ate whether Verdict is similarly usable in a web brows-
ing scenario. Our experiment simulates a group of nodes
connected to a single WLAN network. This conﬁgura-
tion emulates, for example, a group of users in an Inter-
net caf´e browsing the Internet anonymously.

In our simulation on DeterLab [17], 8 servers and 24
clients communicate over a network of 24 Mbps links
with 20 ms node-to-node latency. To simulate a Web
browsing session, we recorded the sequence of requests
and responses that a browser makes to download home
page content (HTML, CSS ﬁles, images, etc.) from the
Alexa “Top 100” Web pages [2]. We then replayed this
trace with the client using one of four anonymity over-
lays: no anonymity, the Dissent DC-net, the Verdict-
only DC-net, and the Dissent+Verdict hybrid DC-net.
The simulated client sends the upstream (request) traf-
ﬁc through the anonymity network and servers broadcast
the downstream (response) trafﬁc to all nodes.

Figure 9 charts the time required to download all home
page content using the four different network conﬁgura-
tions. The median Web page took one second to load
with no anonymity, fewer than 10 seconds over Dissent,
and around 30 seconds using Verdict only (Figure 10).
Notably, the hybrid Dissent+Verdict scheme exhibits per-
formance nearly identical to that of Dissent alone, since it
it falls back to the slower veriﬁable Verdict DC-net only
when there is active disruption. The Verdict-only DC-net
is much slower than Dissent because every node must
generate a computationally expensive zero-knowledge
proof in every messaging round.

These experiments show that Verdict adds no overhead
to Dissent’s XOR-based DC-net in the absence of disrup-
tion. In addition, these experiments illustrate the ﬂexi-
bility of veriﬁable DC-nets, which can be used either as
a “workhorse” for anonymous communication or more
selectively in combination with traditional XOR-based
DC-nets; we suspect that other interesting applications
will be discovered in the future.

USENIX Association  

22nd USENIX Security Symposium  159

13

mous only among a small constant (k) number of nodes.
In contrast, Verdict clients in principle obtain anonymity
among the set of all honest clients using the system.

Dissent [14, 52] uses veriﬁable shufﬂes [10, 36] to
establish a transmission schedule for DC-nets, enabling
groups to guarantee a one-to-one correspondence of
group members to anonymous transmission slots. The
original Dissent protocol [14] offered accountability but
limited performance. A more recent version [52] im-
proves performance and scalability, but uses a retrospec-
tive “blame” protocol which requires an expensive shuf-
ﬂe when disruption is detected.

Golle and Juels [25] introduced the veriﬁable DC-net
concept and formally developed a scheme based on bilin-
ear maps, forming Verdict’s starting point. To our knowl-
edge this scheme was never implemented in a work-
ing anonymous communication system, however, and we
ﬁnd that its expensive pairing operations limit its practi-
cal performance.

Crowds [40], LAP [27], Mixminion [16], Tarzan [21],
and Tor [18], provide anonymity in large networks, but
these systems cannot protect against adversaries that ob-
serve trafﬁc [4, 35] or perform active attacks [9] on a
large fraction of network links. Verdict maintains its se-
curity properties in the presence of this type of strong ad-
versary. A cascade of cryptographically veriﬁable shuf-
ﬂes [23, 36] can offer the same security guarantees that
Verdict does, but these shufﬂes generally require more
expensive proofs-of-knowledge.

8 Conclusion

Verdict is a new anonymous group messaging system
that combines the trafﬁc analysis resistance of DC-nets
with disruption resistance based on public-key cryptog-
raphy and knowledge proofs. Our experiments show that
Verdict may be suitable for messaging in groups of hun-
dreds to thousands of users, and can be combined with
traditional XOR-based DC-nets to offer good normal-
case performance while reducing the system’s vulnera-
bility to disruption events by two orders of magnitude.

Acknowledgments

We wish to thank Aaron Johnson, Ewa Syta, Michael J.
Fischer, Michael Z. Lee, Michael “Fitz” Nowlan, and
Ramki Gummadi for their helpful comments. We also
thank our shepherd, Micah Sherr, and the anonymous
USENIX reviewers, for their valuable feedback. Finally,
we thank the DeterLab staff for their ﬂexibility, patience,
and support during the evaluation process. This material
is based upon work supported by the Defense Advanced
Research Agency (DARPA) and SPAWAR Systems Cen-
ter Paciﬁc, Contract No. N66001- 11-C-4018.

Figure 9: Time required to download home page context
for Alexa “Top 100” Web sites (with linear trend lines).

Figure 10: CDF of time required to download home page
context for Alexa “Top 100” Web sites.

7 Related Work

Chaum recognized the risk of anonymous disruption at-
tacks in his original formulation of DC-nets [13], and
proposed a probabilistic tracing approach based on traps,
upon which Waidner and Pﬁtzmann expanded [50].

Herbivore [24, 44] sidestepped the disruption issue by
forming groups dynamically, enabling nodes to leave dis-
rupted groups and form new groups until they ﬁnd a
disruption-free group. Unfortunately, the likelihood that
a group contains some malicious node likely increases
rapidly with group size, and hence anonymity set, lim-
iting this and related partitioning approaches [1] to sys-
tems supporting small anonymity sets. Further, in an ana-
log to a known attack against Tor [9], an adversary might
selectively disrupt only groups he has only partially but
not completely compromised. With a powerful adversary
controlling many nodes, after some threshold a victim
becomes more likely to “settle into” a group that works
precisely because it is completely compromised, than to
ﬁnd a working uncompromised group.

k-anonymous message transmission [1] also achieves
disruption resistance by partitioning participants into
small disruption-free groups. A crucial limitation of the
k-anonymity system is that an honest client is anony-

160  22nd USENIX Security Symposium 

USENIX Association

14

References

[1] Luis von Ahn, Andrew Bortz, and Nicholas J. Hopper.
k-anonymous message transmission. In ACM conference
on Computer and Communications Security (CCS), pages
122–130, 2003.

[2] Alexa top 500 global sites, April 2012. http://www.

alexa.com/topsites.

[3] Jack M. Balkin. Digital speech and democratic culture: A
theory of freedom of expression for the information soci-
ety. Faculty Scholarship Series, 2004. Paper 240.

[4] Kevin Bauer, Damon McCoy, Dirk Grunwald, Tadayoshi
Kohno, and Douglas Sicker. Low-resource routing attacks
against Tor.
In Workshop on Privacy in the Electronic
Society (WPES), pages 11–20, October 2007.

[5] Mihir Bellare and Phillip Rogaway. Random oracles are
practical: A paradigm for designing efﬁcient protocols. In
ACM conference on Computer and communications secu-
rity (CCS), pages 62–73, 1993.

[6] Dan Boneh.

The decision Difﬁe-Hellman prob-
lem.
In Joe Buhler, editor, Algorithmic Number The-
ory, volume 1423 of Lecture Notes in Computer Sci-
ence, pages 48–63. Springer Berlin / Heidelberg, 1998.
10.1007/BFb0054851.

[7] Dan Boneh and Xavier Boyen. Efﬁcient selective-ID se-
cure identity-based encryption without random oracles.
In International Conference on the Theory and Appli-
cations of Cryptographic Techniques (Eurocrypt), pages
223–238, 2004.

[8] Dan Boneh and Matt Franklin. Identity-based encryption
from the Weil pairing. In IACR International Cryptology
Conference (CRYPTO), pages 213–229. 2001.

[9] Nikita Borisov, George Danezis, Prateek Mittal, and
Parisa Tabriz. Denial of service or denial of security?
How attacks on reliability can compromise anonymity. In
ACM Conference on Computer and Communications Se-
curity (CCS), pages 92–102, October 2007.

[10] Justin Brickell and Vitaly Shmatikov.

Efﬁcient
anonymity-preserving data collection. In ACM SIGKDD
International Conference on Knowledge Discovery and
Data Mining (KDD), pages 76–85, August 2006.

[11] Jan Camenisch and Markus Stadler. Proof systems for
general statements about discrete logarithms. Technical
Report 260, Dept. of Computer Science, ETH Zurich,
March 1997.

[12] Miguel Castro and Barbara Liskov. Practical Byzantine
fault tolerance. In USENIX Symposium on Operating Sys-
tems Design and Implementation (OSDI), pages 173–186,
February 1999.

[13] David Chaum. The dining cryptographers problem: Un-
conditional sender and recipient untraceability. Journal
of Cryptology, pages 65–75, January 1988.

[14] Henry Corrigan-Gibbs and Bryan Ford. Dissent: account-
able anonymous group messaging.
In ACM conference
on Computer and communications security (CCS), pages
340–350, October 2010.

[15] Henry Corrigan-Gibbs, David Isaac Wolinsky, and Bryan
Ford. Proactively accountable anonymous messaging in
Verdict. Technical Report YALEU/DCS/TR1478, De-
partment of Computer Science, Yale University, 2013.

[16] George Danezis, Roger Dingledine, and Nick Mathew-
son. Mixminion: Design of a Type III anonymous re-
mailer protocol.
In IEEE Security and Privacy (SP),
pages 2–15, May 2003.

[17] DeterLab network security testbed, September 2012.

http://isi.deterlab.net/.

[18] Roger Dingledine, Nick Mathewson, and Paul Syverson.
Tor: the second-generation onion router. In USENIX Se-
curity Symposium, pages 303–320, 2004.

[19] John R. Douceur. The Sybil attack.

In 1st Interna-
tional Workshop on Peer-to-Peer Systems, pages 251–
260, March 2002.

[20] Taher ElGamal. A public key cryptosystem and a sig-
nature scheme based on discrete logarithms. In George
Blakley and David Chaum, editors, Advances in Cryptol-
ogy, volume 196 of Lecture Notes in Computer Science,
pages 10–18. Springer Berlin / Heidelberg, 1985.

[21] Michael J. Freedman and Robert Morris. Tarzan: A peer-
to-peer anonymizing network layer. In ACM conference
on Computer and communications security (CCS), pages
193–206, 2002.

[22] Eiichiro Fujisaki and Koutarou Suzuki. Traceable ring
signature.
In International Conference on Theory and
Practice of Public Key Cryptography (PKC), pages 181–
200, April 2007.

[23] Jun Furukawa and Kazue Sako. An efﬁcient scheme for
proving a shufﬂe. In CRYPTO, pages 368–387, August
2001.

[24] Sharad Goel, Mark Robson, Milo Polte, and Emin Gun
Sirer. Herbivore: A scalable and efﬁcient protocol for
anonymous communication.
Technical Report 2003-
1890, Cornell University, February 2003.

[25] Philippe Golle and Ari Juels. Dining cryptographers re-

visited. Eurocrypt, pages 456–473, May 2004.

[26] Jens Groth. Honest veriﬁer zero-knowledge arguments
applied. PhD thesis, University of Aarhus, October 2004.

[27] Hsu-Chun Hsiao, Tiffany Hyun-Jin Kim, Adrian Perrig,
Akira Yamada, Samuel C. Nelson, Marco Gruteser, and
Wei Meng. LAP: Lightweight anonymity and privacy. In
IEEE Security and Privacy, pages 506–520, 2012.

[28] Dogan Kedogan, Dakshi Agrawal, and Stefan Penz. Lim-
its of anonymity in open environments. In 5th Interna-
tional Workshop on Information Hiding, pages 53–69,

USENIX Association  

22nd USENIX Security Symposium  161

15

October 2002.

[29] Joseph K. Liu, Victor K. Wei, and Duncan S. Wong. Link-
able spontaneous anonymous group signature for ad hoc
groups. In Australian Conference on Information Security
and Privacy, pages 614–623, July 2004.

[30] Ben Lynn. On the implementation of pairing-based cryp-
tosystems. PhD thesis, Stanford University, Stanford, CA,
USA, 2007.

[31] Ewen MacAskill,

and James Ball.

Julian Borger, Nick Hopkins,
GCHQ taps
to world’s
June
2013.

Nick Davies,
ﬁbre-optic
communications.
http://www.guardian.co.uk/uk/2013/jun/21/
gchq-cables-secret-world-communications-nsa.

The Guardian,

access

cables

for

secret

[32] Ulf Moeller

and Lance Cottrell.

Version 2,

protocol:
www.eskimo.com/~rowdenw/crypt/Mix/
draft-moeller-mixmaster2-protocol-00.txt.

January 2000.

Mixmaster
http://

[33] Hooman Mohajeri Moghaddam, Baiyu Li, Mohammad
Derakhshani, and Ian Goldberg. SkypeMorph: Protocol
obfuscation for Tor bridges. In ACM Conference on Com-
puter and Communications Security (CCS), pages 97–
108, 2012.

[34] Steven J. Murdoch and George Danezis. Low-cost trafﬁc
analysis of Tor. In IEEE Security and Privacy, pages 183–
195, May 2005.

[35] Steven J. Murdoch and Piotr Zieli´nski. Sampled traf-
ﬁc analysis by Internet-exchange-level adversaries.
In
Proceedings of the 7th international conference on Pri-
vacy enhancing technologies, PETS’07, pages 167–183,
Berlin, Heidelberg, 2007. Springer-Verlag.

[36] C. Andrew Neff. A veriﬁable secret shufﬂe and its ap-
plication to e-voting. In ACM Conference on Computer
and Communications Security, pages 116–125, Novem-
ber 2001.

[37] National Institute of Standards and Technology. FIPS

PUB 186-3: Digital Signature Standard (DSS), 2009.

[38] Andriy Panchenko, Lukas Niessen, Andreas Zinnen, and
Thomas Engel. Website ﬁngerprinting in onion routing
based anonymization networks. In Workshop on Privacy
in the Electronic Society (WPES), pages 103–114, Octo-
ber 2011.

[39] Jennifer Preston.

Facebook ofﬁcials keep quiet
in its role in revolts.
New York Times, Febru-
ary 2011. http://www.nytimes.com/2011/02/15/
business/media/15facebook.html.

[40] Michael K. Reiter and Aviel D. Rubin. Anonymous Web
transactions with Crowds. Communications of the ACM,
42(2):32–48, 1999.

[41] Ronald Rivest, Adi Shamir, and Yael Tauman. How to
leak a secret. In ASIACRYPT, pages 552–565, December
2001.

[42] Claus P. Schnorr. Efﬁcient signature generation by smart

cards. Journal of Cryptology, 4(3):161–174, 1991.

[43] Berry Schoenmakers. A simple publicly veriﬁable secret
sharing scheme and its application to electronic voting. In
IACR International Cryptology Conference (CRYPTO),
pages 784–784, 1999.

[44] Emin G¨un Sirer, Sharad Goel, Mark Robson, and Do˘gan
Engin. Eluding carnivores: File sharing with strong
anonymity.
In ACM SIGOPS European Workshop
(SIGOPS EW), September 2004.

[45] Edward Stein. Queers anonymous: Lesbians, gay men,
free speech, and cyberspace. Harvard Civil Rights-Civil
Liberties Law Review, 2003.

[46] Al Teich, Mark S. Frankel, Rob Kling, and Ya-ching Lee.
Anonymous communication policies for the Internet: Re-
sults and recommendations of the AAAS conference. In-
formation Society, May 1999.

[47] Nguyen Tran, Bonan Min, Jinyang Li, and Lakshmi-
narayanan Submaranian. Sybil-resilient online content
voting. In Symposium on Networked System Design and
Implementation (NSDI), pages 15–28, April 2009.

[48] Stanford University. The pairing-based cryptography li-

brary. http://crypto.stanford.edu/pbc/.

[49] Eugene Vasserman, Rob Jansen, James Tyra, Nicholas
Hopper, and Yongdae Kim. Membership-concealing
overlay networks.
In ACM conference on Computer
and Communications Security (CCS), pages 390–399,
November 2009.

[50] Michael Waidner and Birgit Pﬁtzmann. The dining cryp-
tographers in the disco: Unconditional sender and recip-
ient untraceability with computationally secure service-
ability. In Eurocrypt, pages 302–319, April 1989.

[51] David Isaac Wolinsky, Henry Corrigan-Gibbs, Bryan
Ford, and Aaron Johnson. Scalable anonymous group
communication in the anytrust model. In European Work-
shop on System Security (EuroSec), April 2012.

[52] David Isaac Wolinsky, Henry Corrigan-Gibbs, Aaron
Johnson, and Bryan Ford. Dissent in numbers: Making
strong anonymity scale. In USENIX Symposium on Oper-
ating Systems Design and Implementation (OSDI), pages
179–192, October 2012.

[53] Haifeng Yu, Phillip B. Gibbons, Michael Kaminsky, and
Feng Xiao. SybilLimit: A near-optimal social network
defense against sybil attacks. In IEEE Symposium on Se-
curity and Privacy, pages 3–17, May 2008.

[54] Haifeng Yu, Michael Kaminsky, Phillip B. Gibbons, and
Abraham Flaxman. SybilGuard: Defending against sybil
attacks via social networks. In ACM SIGCOMM, pages
267–278, September 2006.

162  22nd USENIX Security Symposium 

USENIX Association

16

