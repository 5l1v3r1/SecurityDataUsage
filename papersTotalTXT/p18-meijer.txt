Ciphertext-only Cryptanalysis on Hardened Mifare Classic

Cards

Carlo Meijer

The Kerckhoffs Institute

Institute for Computing and Information Sciences

Roel Verdult

Radboud University, The Netherlands.

Radboud University, The Netherlands.

carlo@youcontent.nl

rverdult@cs.ru.nl

ABSTRACT

Despite a series of attacks, mifare Classic is still the world’s
most widely deployed contactless smartcard on the market.
The Classic uses a proprietary stream cipher crypto1 to
provide conﬁdentiality and mutual authentication between
card and reader. However, once the cipher was reverse engi-
neered, many serious vulnerabilities surfaced. A number of
passive and active attacks were proposed that exploit these
vulnerabilities. The most severe key recovery attacks only
require wireless interaction with a card. System integrators
consider such card-only attacks as one of the most serious
threat vectors to their mifare Classic-based systems, since it
allows the adversary to avoid camera detection, which is of-
ten present at an access control entrance or public transport
gate. However, all card-only attacks proposed in the liter-
ature depend on implementation mistakes which can easily
be mitigated without breaking backwards compatibility with
the existing reader infrastructure.

Consequently, many manufactures and system integrators
started to deploy “ﬁxed” mifare Classic cards which are re-
silient to such vulnerabilities. However, these countermea-
sures are rather palliating and inadequate for a cryptograph-
ically insecure cipher such as crypto1. In support of this
proposition, we present a novel cipher-text card-only attack
that exploits a crucial and mandatory step in the authentica-
tion protocol and which solely depends on the cryptographic
weaknesses of the crypto1 cipher. Hence, in order to avoid
this attack, all cards and readers should be upgraded to sup-
port an alternative authentication protocol which inherently
breaks their backwards compatibility. Our attack requires
only a few minutes of wireless interaction with the card,
in an uncontrolled environment and can be performed with
consumer-grade hardware. The information obtained allows
an adversary to drop the computational complexity from
248 to approximately 230, which enabled us to practically
recover a secret key from a hardened mifare Classic card in
about 5 minutes on an single core consumer laptop.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813641 .

Categories and Subject Descriptors: E.3 [Data En-
cryption]: Code Breaking

General Terms: Security

Keywords: stream ciphers; cryptanalysis; security; RFID.

Introduction

1
mifare Classic cards occupy a considerable part of the con-
tactless smartcard market. Such cards oﬀer, in addition to
simple identiﬁcation, a modest amount of memory and cryp-
tographic capability, making them suitable for applications
such as access control and fare collection systems.

The mifare Classic cards are still widely deployment in
many public transport payment systems. Examples of such
systems include the Oyster Card1 in London, the Char-
lie Card in Boston2, the EasyCard in Taiwan3, and the
OV-chipkaart in the Netherlands4.
In addition to public
transport, it is also still used for contactless access control
systems, integrated in many oﬃce buildings, including even
high-security facilities such as ministries, banks, prisons and
nuclear power stations.

mifare Classic cards are compatible with parts 1 to 3 of
the ISO/IEC 14443-A standard [ISO01], specifying physi-
cal characteristics, radio frequency interface and the anti-
collision protocol. However, part 4 of the standard, de-
scribing the transmission protocol, is not implemented. In-
stead, it uses its own secure communication layer. In this
layer, mifare Classic cards communicate encrypted by us-
ing a proprietary stream cipher, named crypto1, to provide
data conﬁdentiality and mutual authentication between card
and reader. The manufacturer, NXP Semiconductors, never
publicly released details of the cipher, nor the communica-
tion layer used in mifare Classic. However, both have been
successfully reverse engineered and their workings are pub-
lished in the literature [NESP08, GKGM+08].

Shortly after reverse engineering, serious vulnerabilities
were identiﬁed and several attacks surfaced that demon-
strated to be mountable in practice. For instance, the at-
tacks described in [GKGM+08] and [KGHG08] enable an
adversary to recover encryption keys used during commu-
nication and manipulate the related data segments on the
card. This allows the adversary to (partially) clone the card.
However, all the attacks mentioned above require the ad-
versary to have access to a legitimate reader, or eavesdrop

1http://oyster.tﬂ.gov.uk
2http://www.mbta.com/fares and passes/charlie
3http://www.easycard.com.tw
4http://wwww.ov-chipkaart.nl

18on genuine communication. Not long after, several attacks
were proposed [GRVS09, Cou09, CHC+14] which demon-
strate how to recover all encryption keys, and hence clone a
full card, only by wirelessly interacting with it. These card-
only attacks are the most eﬀective way for an adversary to
compromise the security of a mifare Classic based system.
Since a perpetrator can perform such an attack in an iso-
lated, non-controlled environment, they cause the maximal
amount of damage against the least possibility of detection.
Interestingly, all card-only attacks proposed in the liter-
ature rely on non-cryptographically related implementation
ﬂaws. Moreover, these implementation issues can be mit-
igated by issuing replacement cards where such ﬂaws are
removed, without even breaking backwards compatibility to
the original mifare Classic cards. However, these replace-
ment cards do not provide a solution to the actual problem,
which is the insecurity of the underlying cryptographic al-
gorithm and authentication protocol.

Table 1.1 gives a (non-exhaustive) overview of mifare
Classic compatible cards, together with revisions made to
the original mifare Classic card with respect to security.

Table 1.1: The mifare Classic compatible cards

Card
mifare Classic
mifare Classic EV1
mifare Plus in security level 1
mifare SmartMX in Classic mode
NFC controllers with mifare Classic card emulation
X X
Third party licensed products, such as the Inﬁneon SLE-66 X X
mifare Classic clones, such as the Fudan FM11RF08
× ×
Newer clones, used in Taiwan EasyCard 2.0

X X

X X

X X

a

b

× ×

X ×

aHas a proper pseudo-random number generator
bDoes not send encrypted error code after failed authentication

Contribution In this paper we propose a ciphertext-only
attack against mifare Classic cards, which only requires
wireless interaction with the card for a few minutes with
consumer-grade hardware. We have fully implemented and
tested our attack in practice and recovered secret keys within
minutes from various hardened mifare Classic cards. In or-
der to give a better estimate of the average running-time,
theoretical boundaries and a performance analysis based on
simulations are given in this paper.

The attack proposed in this paper requires the adversary
to know at least one single key in advance. In practice, how-
ever, this typically the case. The ﬁrst key can be retrieved
by eavesdropping only one genuine authentication or two
failed authentication attempts, see [VKGG12, GKGV12,
GKGM+08] for more details. However, in many situations,
this is not necessary since most deployed systems leave de-
fault keys intact for unused sectors. Additionally, nearly all
deployed systems that use key diversiﬁcation leave at least
one sector key non-diversiﬁed, namely for storing the diversi-
ﬁcation information. Moreover, the manufacturer guidelines
for system integrators [MAD07] especially recommends this.

Overview This paper is organized as follows. Section 2
gives a broad overview of the literature related to attack
stream ciphers in general and the more closely related papers
that also attack the mifare Classic cryptosystem. Section 3
introduces the memory layout, cipher description and au-
thentication protocol that is used by a mifare Classic card.
Vulnerabilities to the mifare Classic cryptosystem are ad-
dressed in Section 4. Then, a novel method to attack the ci-

pher is proposed in Section 5, which is followed by Section 6
where we analyze the performance of the attack. Finally,
a summary of the attack and its practical implications are
given in Section 7.

2 Related work
In this section we ﬁrst explore similar general attack tech-
niques and then highlight the diﬀerent methods that were
proposed in the literature to attack a mifare Classic card.
For each previously proposed attack we analyze its signiﬁ-
cance and the corresponding practical implications.

2.1 General Stream Cipher attacks
In the last decades there are three main techniques intro-
duced to attack LFSR-based stream ciphers, such as the
one used in a mifare Classic card. First, the guess-and-
determine attack can be mounted if the cipher does not use
its complete internal state to compute a keystream bit, de-
spite several well-known historical recommendations in the
literature [Kuh88, And91, Gol96]. Besides the mifare Clas-
sic cryptosystem, many proprietary LFSR-based stream ci-
phers [Gol97, DHW+12, VGB12] lack this property and are
therefore vulnerable to partial and incremental internal state
guessing. Secondly, there is the correlation attack, which
was originally proposed by Siegenthaler [Sie84, Sie85] and
later improved by others [MS88, And95, CS91, CCCS92,
JJ00, CJM02].
It exploits the weakness of a relation be-
tween the internal state bits and the keystream. The ﬁl-
ter function of the mifare Classic cryptosystem uses some
input bits which are more inﬂuencing than others. This
allows for a similar correlation attack to be mounted. Fi-
nally, more recently, various algebraic attacks on general
stream ciphers were proposed [CP02, AK03, FJ03, CM03].
A property of a linear Boolean function is the possibility to
postpone an evaluation. Computational problems which are
formalized during a cryptographic attack can be written as
a system of Boolean equations [TT80]. Instead of comput-
ing the outcome directly, a combination of these equations
can be solved by well-known techniques such as Gaussian
elimination [Hil29, Mul56, Mar57, Str69]. Because of the
regularity of the chosen indexes of the ﬁlter function inputs,
the mifare Classic cryptosystem is particularly vulnerable
to these attacks.

2.2 Attacks on MIFARE Classic
Keystream recovery attack The ﬁrst practical attack
against mifare Classic was carried out in [KGHG08]. It re-
covers the used keystream in a transaction between a reader
and a card. Due to a weak pseudo-random number genera-
tor (PRNG), the resulting keystream can be kept constant
and reused by a malleability attack. For such an attack
knowledge about the secret key and encryption algorithm is
not required.

Genuine reader attacks The inner workings of crypto1
were reverse engineered shortly after the ﬁrst attack.
The Linear Feedback Shift Register (LFSR) is available
in [NESP08] and the non-linear ﬁlter function and authen-
tication protocol are shown in [GKGM+08]. The latter pro-
posed a serious attack that exploited weaknesses in the ﬁlter
function, allowing an adversary to invert the ﬁlter function
in an extremely eﬃcient way. This enables an adversary to
recover the secret key from a single captured authentication
session within a fraction of a second on ordinary hardware.

19Card-only attacks A number of attacks that require only
interaction with a card were introduced by Garcia, van
Rossum, Verdult and Wichers Schreur in [GRVS09]. The
ﬁrst can be mounted against a single authentication and re-
quires precomputation tables. The knowledge of one sector
key allows for their second attack, which is mounted against
a nested authentication, it is extremely fast, and does not
require precomputation tables. The attack against a single
authentication was improved by Courtois [Cou09]. This at-
tack does not require any precomputation and is faster than
the one proposed by Garcia et al.

More recently, Chiu, Hong, Chou, Ding, Yang and
Cheng [CHC+14] proposed a card-only attack that does not
depend on a weak random number generator, instead it ex-
ploits another implementation mistake, the encrypted error
code response. Unfortunately, this attack requires a large
amount of online generated traces which signiﬁcantly in-
creases the total running time of their attack.

In fact, all card-only attacks that are proposed in the liter-
ature depend on either a weak random number generator, or
keystream leakage through known error messages, or both.
A straightforward solution against these attacks is to replace
the vulnerable cards with modiﬁed cards that do not contain
any known implementation mistake, but which are still fully
compatibility with the mifare Classic protocol. In this pa-
per we will refer to ﬁxed modiﬁed cards as hardened mifare
Classic cards, examples of such cards are given in Table 1.1.

3 Background
mifare Classic cards are one of the ﬁrst generation RFID
tags designed in the 90s. Since then, it has been a tradition
for the industry to design proprietary RFID products. Such
a proprietary design often contains custom deﬁned modula-
tion/encoding schemes, packets, checksums, instruction sets
and in some cases even custom made cryptographic algo-
rithms and authentication protocols.

There is not much wrong in designing a custom way of
RFID communication.
It allows the industry to optimize
products and boost the performance for speciﬁc applica-
tions. However, this argument certainly does not hold for
the proprietary and secret cryptosystems. Designing secure
algorithms is proven to be a diﬃcult task without feedback
from the scientiﬁc community [Ker83, JS97, SN97, Ver15].

3.1 MIFARE Classic cards
The mifare Classic card is an interesting example which im-
plements besides a custom communication protocol, a pro-
prietary cipher and also an authentication protocol. The
datasheet [PHI98] of the mifare Classic card suggests that
the security properties are compliant to standardized au-
thentication protocols [ISO99]. However, in practice the se-
curity properties are signiﬁcantly weaker than advertised.
3.2 Memory Structure
A mifare Classic card is es-
sentially a memory chip with
encrypted wireless capabili-
ties. The memory is divided
into sectors, each of which is
further divided into blocks of
sixteen bytes each. The last
block of each sector is the sec-
tor trailer and stores two se-
cret keys and the access conditions for that sector.

Sector 0x27
16 blocks, 256 bytes

Sector 0x00
4 blocks, 64 bytes

Sector 0x01
4 blocks, 64 bytes

UID, BCC, Manufacturer data

0x04

0x05

0x06

Access control

0x00

0x01

0x02

0x03

0x07

Key A

Access control

Key B

Access control

Key B

Data block

Data block

Data block

Data block

0x(cid:1)

Key A

0xf0

Data block

Key A

Data block

Sector trailer

Key B

To perform an action on a speciﬁc block, the reader must
ﬁrst authenticate itself for the sector containing that block.
The access conditions determine, for both keys separately,
which actions are allowed to be performed by the reader.

3.3 Notation
The mathematical symbols are deﬁned as follows:

Let F2 = {0, 1} be the ﬁeld of two elements (or the set
of Booleans). The vector space Fn
2 represents a bitstring of
length n. Given two bitstrings x and y, xy denotes their
concatenation.

Given a bitstring x ∈ Fn

2 , xi denotes the i-th bit of x,
where 0 ≤ i < n. Furthermore, x[i,j] denotes the substring of
x that starts at index i and ends at index j, inclusive. Thus,
representing the substring xixi+1 . . . xj. For instance, given
the bitstring x = 0x010203 ∈ F24
2 , then byte x[16,23] = 0x03
and the bits x22 = x23 = 1.

i=0 xi = x0 ⊕ x1 ⊕ x2 ⊕ x3.

The symbol ǫ represents the empty bitstring, ⊕ denotes
the bitwise exclusive-or (XOR) and x denotes the bitwise
complement of x. The large XOR symbol denotes an inner
XOR of multiple bits, i.e. a repeated logical exclusive-or.
For example L3
3.4 Cipher and Tag Nonces
At the heart of the cipher lies an LFSR, which, on every
step, shifts its contents one position to the left. The most
signiﬁcant bit is then discarded and a new bit is generated by
the feedback function and, during the authentication phase,
the input. Besides being shifted, all other bits remain unaf-
fected.

To increase readability, we adapt the same notation as
used in [GRVS09] and comply with their formalization. Con-
cretely, the cipher feedback, ﬁlter and tag-nonce related
functions of crypto1 are speciﬁed in Deﬁnition 3.1–3.4.

Deﬁnition 3.1. The cipher feedback function L : F48
2 → F2
is deﬁned by L(x0x1 . . . x47) := x0⊕x5⊕x9⊕x10⊕x12⊕x14⊕
x15⊕x17⊕x19⊕x24⊕x25⊕x27⊕x29⊕x35⊕x39⊕x41⊕x42⊕x43.

Deﬁnition 3.2. The ﬁlter function f : F48
by

2 → F2 is deﬁned

f (x0x1 . . . x47) := fc(fa(x9, x11, x13, x15),

fb(x17, x19, x21, x23), fb(x25, x27, x29, x31),
fa(x33, x35, x37, x39), fb(x41, x43, x45, x47)).

Here fa, fb : F4

2 → F2 and fc : F5

2 → F2 are deﬁned by
fa(y0, y1, y2, y3) := ((y0 ∨ y1) ⊕ (y0 ∧ y3)) ⊕ (y2 ∧ ((y0 ⊕ y1) ∨
y3)), fb(y0, y1, y2, y3) := ((y0∧y1)∨y2)⊕((y0⊕y1)∧(y2∨y3)),
and fc(y0, y1, y2, y3, y4) := (y0 ∨ ((y1 ∨ y4) ∧ (y3 ⊕ y4))) ⊕
((y0 ⊕ (y1 ∧ y3)) ∧ ((y2 ⊕ y3) ∨ (y1 ∧ y4))).

Because f (x0x1 . . . x47) only depends on x9, x11, . . . , x47,
2 → F2,

we shall overload notation and see f as a function F20
writing f (x0x1 . . . x47) as f (x9, x11, . . . , x47).

Deﬁnition 3.3. The pseudo-random generator feedback
function L16 : F16

2 → F2 is deﬁned by

L16(x0x1 . . . x15) := x0 ⊕ x2 ⊕ x3 ⊕ x5.

Deﬁnition 3.4. The successor function suc : F32
deﬁned by

2 → F32
2

is

suc(x0x1 . . . x31) := x1x2 . . . x31L16(x16x17 . . . x31) .

200 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 2122 23 24 25 26 27 28 29 30 3132 33 34 35 36 37 38 39 40 4142 43 44 45 46 47

in

fa

fb

fa

fb

fb

fc

out

Figure 3.1: Structure of the crypto1 stream cipher

3.5 Authentication Protocol and Initialization

The authentication protocol was reverse engineered in
[GKGM+08]. During the anti-collision phase, the tag is se-
lected and sends its UID u to the reader. Then, the reader
asks to authenticate for a speciﬁc memory block b. Con-
sequently, the tag sends a challenge nT . From this point
on, the communication is encrypted, i.e. XOR-ed with the
keystream. The reader responds with its own challenge nR
followed by the answer aR = suc64(nT ) to the tag chal-
lenge. The authentication is concluded with the tag answer
aT = suc96(nR). At this point, both the reader and tag are
authenticated.

T ag

select

u

−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−
−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−

select u

sak

Reader

During the authentication
protocol, the internal state of
the stream cipher is initial-
ized.
Initially, the state is
set to the sector key. Then,
nT ⊕u is fed and the feedback
is applied accordingly. Sub-
sequently, nR is fed and feed-
back is applied. Since the
communication is encrypted
starting from nR, the latter
bits of nR are inﬂuenced by
the former bits of nR. See
Deﬁnition 3.5 for a more for-
mal description of the initialization process.

auth b

−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−

nT

{nR}{aR}

−−−−−−−−−−−−−−→

{aT }

←−−−−−−−−−−−−−−

We deﬁne the LFSR-stream, which allows us to conve-
niently address internal states as a whole and individual
bits at any point in time. Below we deﬁne the LFSR-stream
a0a1 . . . and keystream ks0ks1 . . . . We broadly employ the
same notation as in [GRVS09], which is where the deﬁni-
tions are taken from. We will be using these deﬁnitions
extensively throughout this paper.

Deﬁnition 3.5. Given a key k = k0k1 . . . k47 ∈ F48
2 , a tag
nonce nT = nT0 nT1 . . . nT31 ∈ F32
2 , a UID u = u0u1 . . . u31 ∈
F32
2 , and a reader nonce nR = nR0 nR1 . . . nR31 ∈ F32
2 , the in-
ternal state of the cipher at time i is αi := aiai+1 . . . ai+47 ∈
F48
2 .

Here the ai ∈ F2 are given by

ai := ki

a48+i := L(ai, . . . , a47+i) ⊕ nTi ⊕ ui
a80+i := L(a32+i, . . . , a79+i) ⊕ nRi
a112+i := L(a64+i, . . . , a111+i)

∀i ∈ [0, 47]

∀i ∈ [0, 31]
∀i ∈ [0, 31]
∀i ∈ N.

Furthermore, we deﬁne the keystream bit ksi ∈ F2 at time
i by

ksi := f (aia1+i . . . a47+i)

∀i ∈ N.

We denote encryptions by {·} and deﬁne {nRi }, {aRi } ∈ F2
by

{nRi } := nRi ⊕ ks32+i
{aRi } := aRi ⊕ ks64+i

∀i ∈ [0, 31]
∀i ∈ [0, 31].

Note that the ai, αi, ksi{nRi }, and {aRi } are formally
functions of k, nT , u, and nR. Rather than making this
explicit by writing, e.g. ai(k, nT , u, nR), we just write ai,
where k, nT , u, and nR are clear from the context.

Nested authentication When a reader is authenticated for
a sector and hence communicating encrypted, a subsequent
authentication request for another sector is also sent en-
crypted. At this point, the internal state of the cipher is
initialized with the new key, which corresponds with the sec-
tor where the authentication is requested for. Furthermore,
the authentication protocol is slightly diﬀerent, since tag
challenge nT is also sent encrypted, i.e. {nT }. Concretely,
the initialization is similar to Deﬁnition 3.5, except that the
bits of {nT } are decrypted before they are loaded into the
internal state as shown in Deﬁnition 3.6. We refer to this
procedure as a nested authentication. The attack proposed
in this paper only concerns the nested authentication.

Deﬁnition 3.6. In the situation from Deﬁnition 3.5, we
deﬁne {nTi } ∈ F2 by {nTi } := nTi ⊕ ksi∀i ∈ [0, 31]

4 Known Vulnerabilities
In this section we highlight the various mifare Classic vul-
nerabilities which are described in the scientiﬁc literature.
4.1 Short Key Length
The key size of 48 bits is too small to prevent a success-
ful brute force attack within reasonable time. Initially, this
was compensated for by the delay introduced by the com-
munication and authentication procedure. Every attempt
would take about 6 milliseconds. Hence, an online attack
on a single card for a single sector would take more than
44 thousand years, searching through all 248 possible keys.
However, when the crypto1 algorithm was exposed, an of-
ﬂine brute force attack could be mounted, eliminating the
delay caused by the communication with the card. In 1996 it
was already strongly recommended against using symmet-
ric cryptosystems that use 56 bits keys [BDR+96]. Nohl
and Pl¨otz stated in December 2007 [NP07] that a $100 key
cracker will ﬁnd a key in approximately 1 week. It can even
be done much faster when trading memory for time.
4.2 Predictable Nonces
It is commonly known that proper pseudo-random number
generators are essential for cryptographic protocols to pro-
vide proper security. The 32 bits nonce used by the mifare
Classic is generated by a 16 bit LFSR, meaning the entropy
of the nonces is only 16 bits, which is clearly insuﬃcient.
Given its structure, the sequence of nonces is repeated ev-
ery 216 − 1 cycles. On top of that, whenever the card is

21powered up, the LFSR is reset to a known state. Hence,
if an adversary carefully keeps the time constant between
powering up the card and requesting a nonce, the nonce will
be constant. This essentially removes all the randomness
introduced by the card from the authentication.

This weakness is exploited in many of the known at-
tacks. Furthermore, besides the attack described in Chiu
et al. [CHC+14], all card-only attacks proposed in the liter-
ature exploit this particular implementation mistake.

The attack presented in this paper does not exploits on
this vulnerability and works on hardened mifare Classic
cards that use a proper PRNG.
4.3 The Nested Authentication
Once a single key of a single sector is known, an adversary
can authenticate against that sector, and while communicat-
ing (encrypted) with the tag, send another authentication
request for a diﬀerent sector and/or key. When this authen-
tication command has been processed, the internal cipher
state is set to the key of the new sector and the authenti-
cation protocol depicted in Section 3.5 starts again. This
time, though, the challenge generated by the tag is also sent
encrypted.

In case the card has the weak pseudo-random number gen-
erator vulnerability mentioned above, and hence allowing
an adversary to predict the nonce, the nested authentica-
tion can be used to recover 32 bits of keystream by only
wirelessly interacting with a card. This phenomenon was
exploited in [GRVS09] in one of their attacks, which is re-
ferred to as the nested attack.

The attack presented in this paper relies on the nested
authentication, since, if we assume are concerned with a
hardened card and with no access to a genuine reader, it
is the only channel through which secret key information is
leaked.
4.4 Parity bits
The mifare Classic sends a parity bit for each byte it trans-
mits. Contrary to the ISO/IEC 14443-A standard [ISO01],
the data link layer and communication layer are mixed.
Rather than computing parity bits over the bits that are
sent over the air, i.e., the ciphertext, they are computed over
the plaintext. On top of that, the parity bits are sent en-
crypted with the same keystream bit that is used to encrypt
the next bit of plaintext. See Figure 4.1 for an illustration
of this property.

plaintext

b0

b1

b2

b3

b4

b5

b6

b7

p0

b8

b9

b10

b11

b12

b13

b14

b15

keystream

ks0

ks1

ks2

ks3

ks4

ks5

ks6

ks7

ks8

ks9

ks10

ks11

ks12

ks13

ks14

ks15

Figure 4.1: The encryption of parity bits

Given this property an adversary can learn information
about the plaintext by observing only the ciphertext. Con-
sequently, this already breaks the conﬁdentiality of the en-
cryption scheme. For example: suppose we observed the
encrypted parity bit {p0}, which is computed over the ﬁrst
nonce byte nT[0,7] , and {nT8 }, the ﬁrst bit of the second
encrypted nonce byte. Since both are encrypted (XOR-ed)
with the same keystream bit ks8, we can deduce whether or
not the plaintext parity p0 equals nT8 .

In this research, we focus only on the parity bits of {nT }.
The ISO standard speciﬁes odd parity, hence the “⊕1” in the
deﬁnition below.

Deﬁnition 4.1. In the situation from Deﬁnition 3.5, we
deﬁne the parity bits pj ∈ F2 by

pj :=

7

M

i=0

nT8j+i ⊕ 1

∀j ∈ [0, 3]

and the encryptions {pj } of these parity bits by

{pj} := pj ⊕ ks8j+8

∀j ∈ [0, 3]

The only way left in hardened cards leak secret key in-
formation without communicating with a genuine reader is
through parity bits. Hence, the attack presented in this pa-
per is built upon this vulnerability.

4.5 Keystream leakage through errors
While the authentication protocol is running, the card al-
ways ﬁrst checks the parity bits before doing anything else.
Hence, during the authentication protocol, when the card
receives {nR} and {aR}, if at least one of the eight parity
bits is wrong, the card does not respond.
In the case all
eight parity bits are correct, but the answer aR is wrong,
the card replies with the 4-bit error code 0x5, indicating
a failed authentication. The error code is sent encrypted,
even though the reader has not successfully authenticated
itself and hence cannot be assumed to be able to decrypt it
correctly.

From this encrypted error code, 4 bits of keystream is
leaked and can be obtained by XOR-ing the encrypted er-
ror code with its plaintext value. The leakage of 4 bits of
keystream may not seem a severe issue. However, the leak-
age is a crucial ingredient for several card-only key recovery
attacks [GRVS09, Cou09, CHC+14].

The weakness can be mitigated by issuing cards that do
not send authentication error codes. This does not break
compatibility with the mifare Classic protocol since, as
stated, the reader is unable to decrypt it anyway.

4.6 LFSR Rollback
Initially, the cipher’s internal state is set to the secret key.
During authentication and during encryption, the state is
manipulated. However, given an internal state at any given
point in time, and given the data fed into the LFSR, u, nT
and {nR}, the previous state can be computed determin-
istically. Hence, it is suﬃcient for an adversary to obtain
the internal state at any point in time. The LFSR state can
then be rolled back to time 0, wherein it holds the secret key.
Many, if not all attacks rely on this weakness, including the
one presented in this paper. The fact that this vulnerability
is present in mifare Classic was ﬁrst pointed out by Garcia
et al. [GKGM+08].

4.7 Odd Inputs to the Filter Function
The nonlinear ﬁlter function f that takes inputs from the
LFSR to produce a keystream bit exclusively uses bits on
odd-numbered positions, i.e. a9, a11, a13, . . . , a47 (see Fig-
ure 3.1). The fact that they are so evenly placed can be ex-
ploited. Given a part of keystream, the bits of the LFSR rel-
evant for generating the even and odd bits of the keystream
can be generated separately. By splitting the feedback into
two parts as well, those even and odd states can be combined
eﬃciently to recover exactly those LFSR states that produce
a given keystream. This reduces the computing power re-
quired for an exhaustive search from 239 to approximately
220 + 219 ≈ 220.58. It may be understood as “inverting” the
ﬁlter function f . The attack presented in this paper makes

22extensive use of this vulnerability. The complete attack is
described in full detail in the next section.

5 Attacking Mifare Classic
In this section we describe the process of mounting an attack
without exploiting the two main implementation mistakes:
the weak pseudo random number generator (Section 4.2)
and the encrypted error message (Section 4.5). We pro-
pose a novel attack that solely depends on design issues in
the crypto1 cipher. Hence, in order to avoid this attack,
backwards compatibility with the mifare Classic protocol
is inherently broken.
Stage 1 We start retrieving encrypted nonces {nT } using
the nested authentication, i.e. by authenticating for a sector
for which the key is known, followed by an authentication
request for the target sector. This process is repeated in the
background until the key is recovered.
Stage 2 Given the set of encrypted nonces we have obtained
so far, we determine Sǫ, the sum property of the cipher’s ini-
tial state. This property is explained in detail in Section 5.2
We also determine S{b}, the sum property of the cipher’s
state after byte {b} is fed (i.e. at time 8), for all 256 possi-
ble ﬁrst input bytes {b}. Depending on the probability that
we guessed S{b} correctly, we choose to incorporate byte {b}
in the diﬀerential analysis described in Section 5.5. This is
done using a probability threshold value. How the proba-
bility of correctly guessing the sum property for input byte
{b} is computed is explained in detail in Section 5.4. Ad-
ditionally, we incorporate all input bytes {b} for which we
observe that f (α8) 6= f (α8 ⊕ 1), i.e. all ﬁrst nonce bytes
for which the ﬁlter ﬂip property holds. This is explained in
Section 5.6.

Next, given the information determined from the set of en-
crypted nonces, we determine the size of the leftover search
space. The leftover search space shrinks as the number of
harvested encrypted nonces increases since more nonces al-
low us to more accurately guess sum properties and observe
ﬁlter ﬂip properties. We repeat this information gathering
step until the search space is suﬃciently small, as subjec-
tively assessed by the adversary. Once this is the case, we
move on to Stage 3.
Stage 3 Given the information determined from the set of
encrypted nonces so far, we construct a candidate list for
a[9,55] (Section 5.5). Which we extend to a[8,55] by pre-
ﬁxing both 0 and 1. Then, we perform an LFSR-rollback
described in Section 4.6 to transform them into candidates
for a[0,47], i.e. the secret key. Subsequently, we carry out
the oﬄine brute force attack presented in Section 5.1. The
key is not always found since sum properties are guessed
correctly with high probabilities, not certainty. In case the
key is not found, we revert to Stage 2, optionally with an in-
crease of the probability threshold, causing the search space
to increase. However, gathering of more nonces increases
the certainty and reduces the number of candidate keys.
5.1 Ofﬂine Brute Force Attack
Recall from Deﬁnition 4.1 that a parity bit pi is computed
over plaintext byte nT[8i,8i+7] , and subsequently encrypted
(XOR-ed) with the next keystream bit ks8i+8. This property
can be exploited in order to verify whether a candidate key is
the correct key. Given an encrypted nonce obtained through
a nested authentication attempt, the adversary can attempt
to “decrypt” the nonce using the candidate key. In case the

candidate is the correct key, the parity bits will be correct.
However, in case a wrong key was used, a parity bit will be
correct with probability 1
2 .

An encrypted nonce holds 4 bytes, thus 4 encrypted parity
bits. Therefore, on average, 48/4 = 12 encrypted nonces are
enough to determine the key uniquely.

We implemented this brute-force attack and executed it on
an nvidia gtx460 GPU. From our experiments we deduced
that performing a full 48-bit exhaustive search takes ap-
proximately 1 month. However, our implementation leaves
headroom for optimizations, such as bitslicing [Bih97]. We
assume that such optimizations improve the attack perfor-
mance by at least a factor of four.

By today’s standards the gtx460 is considered a low end
GPU. It has 336 cores and runs at 675 Mhz. Clearly, the
attack scales linearly by the amount of parallel computing
power available. As of today, a gtx460 costs approximately
$50 USD. Therefore, its price/performance ratio is among
the best available. We reserve another $20 USD per GPU
for hardware driving the GPUs (CPUs, mainboards, power
supplies). Hence, recovering a single key within an hour
by means of a brute force attack would require a hardware
budget of approximately $12,600 USD.

The attack mounted in [NP07] seems signiﬁcantly faster.
However, this is mainly because it operates directly on the
keystream, while the brute force attack described here oper-
ates on contiguously reinitializing the state with encrypted
nonces.

Although we have not researched the possibility to mount
a time-memory trade-oﬀ extensively, on the surface, doing so
seems very diﬃcult and comes with negligible performance
impact. This is due to the fact that time-memory trade-oﬀ
strategies found in scientiﬁc literature [Hel80, BS00] operate
on keystream, while our attacker model dictates that we can
only deduce indirect properties of the keystream. On top of
that, the cipher’s internal state is initialized by a random
nonce which can not be inﬂuenced by an adversary.

In the next sections we describe several properties that
can be observed by only analyzing the ciphertext. Once
the properties are determined, all candidate keys for which
these properties do not hold can be discarded, signiﬁcantly
reducing the search space.

Note that an exhaustive search and subsequently testing
each candidate for the properties found is a computationally
expensive task, since an oﬄine brute force attack is rather
slow. Therefore, we introduce an eﬃcient method for con-
structing a list of key candidates.
5.2 Sum Property
The ﬁrst property that can be observed by analyzing the
ciphertext is the sum property. In order to deﬁne it, we ﬁrst
need to establish a number of lemmas.

Given an encrypted nonce byte {nT[8i,8i+7] } and corre-
sponding parity bit {pi}, we can cancel out the plaintext by
XOR-ing the two together, yielding the inner XOR of the
corresponding keystream bits ks8i . . . ks8i+8.
Lemma 5.1. Let {nT[8i,8i+7] } be the ith encrypted nonce
byte obtained from the card and let {pi} be its corresponding
encrypted parity bit. Then

7

M

{nT8i+j } ⊕ {pi} =

j=0

8

M

j=0

ks8i+j ⊕ 1

Proof. Published in [Mei15].

23The lemma depicted above is applicable to any ciphertext,
e.g. it can also be applied to {nR} or {aR}. However, in this
paper we are only concerned with the analysis of {nT }. The
following lemma states that for two encrypted nonces with
a common preﬁx of j bits, the LFSR-stream a48a49 . . . a48+j
is equal.

:= {nT0 nT1 . . . nT31 } and {n′

T }

Lemma 5.2. Suppose
{nT }
nonces
{n′
T1 . . . n′
T0 n′
a0a1 . . . and a′
mon preﬁx of j bits, i.e. {nTi } = {n′
also a48+i = a′

two encrypted
:=
T31 }, and their corresponding LFSR-streams
0a′
1 . . . . Let the encrypted nonces have a com-
Ti }, for all i < j. Then

48+i and ksi = ks′

that we have

i for i < j.

Proof. Published in [Mei15].

Finally, we describe another property that, when taken
together with Lemma 5.1, allows us to deﬁne the desired
sum property. Let’s focus on any of the encrypted nonce
bytes {nT[8i,8i+7] } where i ∈ [0, 3]. The value of this
byte is mapped to the LFSR-stream byte a[8i+48,8i+55].
The value is not taken directly, but ﬁrst manipulated by
keystream and feedback loop. If we only take nonces with a
common {nT[0,8i−1] }, a one-to-one mapping exists between
{nT[8i,8i+7] } and a[8i+48,8i+55].

Lemma 5.3. Given that {nT[0,8i−1] } is constant, a one-to-
one mapping exists between all 256 possible values for nonce
byte {nT[8i,8i+7] } and LFSR-stream byte a[8i+48,8i+55].

Proof. Published in [Mei15].

Suppose we have collected suﬃciently many encrypted
nonces such that we observed all 256 possible values for an
encrypted nonce byte {nT[8i,8i+7] }, with the previous bytes
{nT[0,8i−1] } being constant. This information allows us to
compute the sum property.

Deﬁnition 5.4. The sum property, S is a property of the in-
ternal state at time 8i, where i ∈ [0, 3], that can be observed
by retrieving all possible values for {nT[8i,8i+7] }, i.e. the ith
encrypted nonce byte, with {nT[0,8i−1] }, i.e. all previous en-
crypted nonce bytes, being constant. For each encrypted
nonce byte we take the inner XOR and XOR it together
with its corresponding parity bit. Next, we take the sum
over all the resulting values, ignoring the modulo operation
of ﬁnite ﬁelds. The result is a number ranging from 0 until
and including 256.

S(α8i) :=

255

X

7

M

{nT8i+h } ⊕ {pi},

j=0

h=0

for {nT[8i,8i+7] } = j

The sum property is equivalent to a property that depends
only on the cipher’s internal state at time 8i. The following
lemma formilizes this.

Lemma 5.5. Sum property S is equivalent to the following
function over the cipher’s internal state

S(α8i) =

255

8

X

M

j=0

h=0

f (a8i+h+9a8i+h+11 . . . a8i+h+47),

for a[8i+48,8i+55] = j

Proof. Published in [Mei15].

Because S(a[8i,8i+47]) only depends on a[8i+9,8i+47], we
2 →

shall overload notation and see S as a function F39
[0, 256], writing S(a[8i,8i+47]) as S(a[8i+9,8i+47]).

Note that, at this point, we can already reduce the ex-
haustive search space signiﬁcantly by collecting all possible
values for the ﬁrst encrypted nonce byte, which determine
the sum property of the cipher’s initial state, i.e. at time 0,
and discard all states having a sum property value diﬀerent
from the one observed by means of precomputed lookup ta-
bles. In the next section we show how to do this eﬃciently
and without lookup tables.
5.3 Splitting the Sum property
In section 4.7 we described a vulnerability of the ﬁlter func-
tion f , namely that all its inputs are evenly placed at odd
positions. In this section we show how we can exploit this
property to construct candidate key lists such that each can-
didate has a certain given value for the sum property, with-
out the need for going through the entire 39-bit search space
and testing for this property.

To do so, we ﬁrst introduce the partial sum property, which
is the sum taken over only the odd or even bits of the cipher’s
internal state.

Deﬁnition 5.6. The odd sum, SO depicts the sum property
computed over the odd bits of the cipher’s internal state.
Likewise, SE depicts the even sum. Both values range from
0 until and including 16. Note that both values are do not
share a single input, hence they are completely independent
of one another. They are deﬁned as follows.

SO(a9a11 . . . a47) :=

SE(a10a12 . . . a46) :=

15

4

X

M

j=0

i=0

15

3

X

M

j=0

i=0

f (a9+2ia11+2i . . . a47+2i),

for (a49a51a53a55) = j

f (a10+2ia12+2i . . . a48+2i),

for (a48a50a52a54) = j

Next, we deﬁne sets consisting of all possible internal state
bits TOp, TEq determined by partial sum property p, q for
the odd and even sum property, respectively.

TOp := {x | x ∈ F20
TEq := {x | x ∈ F19

2 and SO(x) = p}

2 and SE(x) = q}

Now suppose that we have determined both the odd and
even sum property of the cipher’s internal state. As we will
see below, this uniquely determines the sum property.

Lemma 5.7. Suppose that both SO and SE of the cipher’s
internal state are known. Then also S is known and is given
by the following equation.
s = p(16 − q) + (16 − p)q, where p, q, s = SO(·), SE(·), S(·)

Proof. Published in [Mei15].

Note that one may expect the sum property value to seem
normally distributed by its deﬁnition. However, this is not
the case due to, among other phenomena, the property just
described. See Figure 5.1 for a bar chart depicting the possi-
ble values for the sum property against their corresponding
probabilities for a randomly chosen cipher state.

At this point, we have all the building blocks needed for
constructing a candidate key list without iterating through

24Obtaining this number of nonces would typically take time
in the order of hours. However, by taking a probabilistic
approach we can determine the sum property at time 8 with
very high probability with much fewer nonces.

The relation between byte {nT[8,15] } and a[56,63]

is un-
known to us since it depends on the key. However, accord-
ing to lemma 5.3, it is one-to-one, hence collision-free. Addi-
tionally, {nT }, and thus {nT[8,15] } is chosen randomly by the
card. As such, we regard every unique {nT[8,15] } we receive
as a random (though unknown) sample for a[56,63].

Let U be a set of tuples ({b}, {p}) ∈ F8

2 × F2 storing en-
crypted nonce bytes together with their corresponding en-
crypted parity bits. We deﬁne U such that it contains all
unique samples we received for {nT[8,15] }, i.e.
the second
nonce byte, with a constant {nT[0,7] }.

We give a brief example in order to clarify the in-
tuition behind the probabilistic approach:
Suppose U
has 20 entries. From these samples, we compute k =
P({b},{p})∈U L7
i=0{b} ⊕ {p}, i.e. the sum property over the
sample space. Now suppose that we ﬁnd k = 0. From this
observation we may conclude that the sum property at time
8 with the preﬁx chosen is very likely 0. In fact, the actual
probability for this to be the case is approximately 0.9775.
Although we only have 20 samples for {nT[8,15] }. Hence, in
this example, we require to gather only

256 · (

256
256

+

256
255

+

256
254

+ · · · +

256
237

) ≈ 5320.24

nonces on average. We now formalize this this intuition. A
key concept we use here is the Hypergeometric distribution.

Deﬁnition 5.8. The hypergeometric distribution is a dis-
crete probability distribution that describes the probability
of k successes in n draws, without replacement, from a ﬁ-
nite population of size N containing exactly K successes,
wherein each draw is either a success or failure.

A random variable X follows the hypergeometric distri-

bution if its probability mass function (pmf) is given by

P (X = k) = (cid:0)K

k (cid:1)(cid:0)N−K
n−k (cid:1)
(cid:0)N
n(cid:1)

Where

N is the population size
K is the number of success states in the population
n is the number of draws
k is the number of successes

We deﬁne the following random variables

S := The sum property
T := The result of P({b},{p})∈U L7
X := The result of P({b},{p})∈U L7

ﬁxed value K of the sum property

sum property over the current sample space

i=0{b} ⊕ {p}, i.e. the

i=0{b} ⊕ {p}, for a

X follows a hypergeometric distribution with parameters
N, K, n and output k, where

N = 256
K = S(α8), i.e. the sum property at time 8
n = #U , i.e. the number of unique samples gathered for

{nT[8,15] }, for some constant {nT[0,7] }

k = P({b},{p})∈U L7

i=0{b} ⊕ {p}, i.e. the sum property

computed over the current sample space

By deﬁnition of the random variables we get
P (X = k) = P (T = k|S = K)

Figure 5.1: Sum values and probabilities. Probabilities are
obtained by averaging over 8192 random cipher states

the entire 39-bit search space and subsequently testing for
the sum property and without using (large) precomputation
tables. To do so:

(i) We generate all tables TOp and TEq , where p, q ∈
[0, 16], consisting of all possible odd and even LFSR
bits used by their corresponding partial sum function.
Precomputation is not necessary as computation com-
pletes within one second on an ordinary laptop.

(ii) We determine s = S(a[9,47]), the sum property of the
initial LFSR state by retrieving all 256 possible values
for the ﬁrst encrypted nonce byte nT[0,7] , and subse-
quently apply Lemma 5.5.

(iii) Once s has been determined, we take all possible
combinations for (p, q) ∈ [0, 16] × [0, 16] such that
s = p(16 − q) + (16 − p)q holds.

(iv) For each such a combination, we take all values x ∈ TOp
and combine them with all values y ∈ TEq . We deﬁne
z ∈ F39
2 , z := x0y0x1y1 . . . x18y18x19. By construction
S(z) = S(a[9,47]). Therefore, every z is a candidate
for 39 bits of the cipher’s internal state. Lemma 5.7
states the sum property is deﬁned by its partial sum
properties. Hence, a value z must exist such that z =
a[9,47].

In the resulting candidate list, each entry holds 39 bits
of LFSR state, whereas the length of this list is given by
the probability of the observed sum property times 239. On
average the list holds 236.72 entries, i.e. a drop of 2.28 bits
in complexity. In the next section, we describe how we can
eﬃciently determine the sum property at time 8.
5.4 Determining the sum property at time 8
As we have seen in the last section, by determining the sum
property of the cipher’s initial internal state, the exhaustive
search space can be signiﬁcantly reduced. We can apply the
same technique once more, only this time we determine the
sum property of the cipher’s internal state at time 8, i.e.
after the ﬁrst nonce byte is fed. As stated as a requirement
in Lemma 5.5, in order to determine the sum property at
time 8, we need to collect all possible values for the second
nonce byte nT[8,15] , while the ﬁrst byte nT[0,7] is constant.
We assume the encrypted nonce {nT } produced by the tag
is random and beyond our control. Hence, we require

256 · (

256
256

+

256
255

+

256
254

+ · · · +

256

1

) ≈ 401365.07

nonces on average. This analysis relates to the well-known
coupon collector problem [FGT92].

25Our goal is to compute the probability of the sum property
having a certain value, given the sum property computed over
the sample obtained so far, hence P (S = K|T = k). We use
Bayes’ theorem [BP63] to obtain it.

P (S = K|T = k) =

P (T = k|S = K) P (S = K)

P (T = k)

To obtain P (T = k), we take P (T = k|S = i)P (S = i) for all
possibilities for i. The events are mutually exclusive.

P (S = K|T = k) =

P (T = k|S = K) P (S = K)
P256
i=0 P (T = k|S = i)P (S = i)

Deﬁnition of X

P (S = K|T = k) =

P (X = k) P (S = K)
i=0 P (X = k)P (S = i)

P256

Our strategy becomes to take every possible sum property
value for K and compute P (S = K|T = k). Our guess for
S(α8) will be the K that yields the highest probability.

From the result we see that, in order to compute the prob-
ability for a sum property value given a sample, we need to
know P (S = i) for every possible value of i from 0 until and
including 256. These probabilities are depicted in Figure 5.1.

5.5 Differential Analysis
From section 5.4 we have seen that we can determine S(α0)
and guess S(α8) for a given {nT[0,7] } by gathering only a
modest number of encrypted nonces. Additionally, once the
value for S(α8) is known, Section 5.3 has shown that we
can construct candidate lists containing 39 bits of LFSR
state, without the need of going through all 239 possible
states, computing the sum property, and testing whether
this results in the correct value. In this section, we show how
we can combine two or more sum properties and eliminate
a signiﬁcant amount of impossible key candidates prior to
constructing the ﬁnal candidate list.

Given that we guessed S(α8) for a given {nT[0,7] } with
near certain probability, it is very likely that we can also
guess this for other input bytes without requiring to collect
additional nonces, since we assume the encrypted nonces
generated by the card are random and beyond our control.
Input byte {nT[0,7] } is mapped to a[48,55] and therefore af-
fects S(α8). Hence, S(α8) typically diﬀers for each choice for
{nT[0,7] }. Below we deﬁne a notation for the sum property
at the moment the ﬁrst input byte was fed.

Deﬁnition 5.9. Given the LFSR-stream a0a1 . . . , the sum
property value of the cipher’s internal state after encrypted
input byte {b}, is fed is S{b}.

Here the S{b} is given by

Sǫ := S(a[9,47])
S{b} := S(a[17,55])

where {nT[0,7] } = {b}

Furthermore, the set of all possible internal state bits de-
termined by the sum property after input byte {b} is fed is
S{b}. S{b} is given by
Sǫ := {x | x ∈ F39
S{b} := {x | x ∈ F39

2 and S(x) = S{b}}

2 and S(x) = Sǫ}

Combining two sum properties Suppose we have deter-
mined Sǫ, and also S{b} with high probability, for a cer-
tain input byte {b}. Since every entry u ∈ Sǫ is a candi-
date for α9α10 . . . α47, and every v ∈ Sǫ is a candidate for

α17α18 . . . α55, every u must have a corresponding v such
that u8u9 . . . u38 = v0v1 . . . v30 and vice versa.

This property can be evaluated for the odd and even LFSR
state bits separately. This allows us to eliminate candidate
keys prior to building the entire candidate list.

Building a candidate list from Sǫ and S{b} is done as fol-

lows

(i) We take all pairs (p, q) ∈ [0, 16] × [0, 16] for which Sǫ =

p(16 − q) + (16 − p)q.

(ii) We do the same for time 8: for a certain encrypted in-
put byte {b}, for which we know S{b} with high proba-
bility, we determine all pairs (r, s) ∈ [0, 16] × [0, 16] for
which S{b} = r(16 − s) + (16 − r)s.

(iii) For each pair (p, q), we iterate through all pairs (r, s).
For each x ∈ TOp, we look up all entries y ∈ TOr such
that x4x5 . . . x19 = y0y1 . . . y15. If none exist, then x
is an impossible candidate for α9α11 . . . α47. Let zO ∈
F24
2 be a candidate for α9α11 . . . α55. It is constructed
by taking zO := x0x1x2x3y. The even case is similar:
for each x ∈ TEq , we look up all entries y ∈ TEs such
that x3x4 . . . x18 = y0y1 . . . y15. zE ∈ F23
2 is a candidate
for α10α12 . . . α54 and is constructed by taking zE :=
x0x1x2y.

(iv) We now deﬁne z ∈ F47

2 , which is a candidate for α[9,55].
It is constructed by combining every zO with every zE
and taking z := zO0 zE0 zO1zE1 . . . zO22 zE22 zO23 . Stage
3 of Section 5 describes how the resulting candidate
list is used to perform a key recovery.

Optionally, the size of the search space is determined
by, rather than actually constructing the candidate list,
multiplying the number of candidates zO by the num-
ber of candidates zE for each pair (p, q) and (r, s) and
summing them up.

We somewhat naively assume that Sǫ and S{b} are statis-
tically independent. In case we are concerned with a random
{b}, we gain a complexity drop of 2.28 bits on average, in
addition to the same drop described in Section 5.3. How-
ever, in practice, the drop is even greater since relatively few
nonces are required for determining a byte {b} for which S{b}
is an extreme value, i.e. 0 or 256 (yielding a drop of approx-
imately 5.15 bits). The same holds to a lesser extent for
values 32 and 224 (approximately 6.81 bits). Moreover, all
sum property values except 128 yield a greater complexity
drop than 2.28 since their corresponding probabilities are
below the average (Figure 5.1), hence so are the numbers of
corresponding possible cipher states.

The remainder of Section 5 is concerned only with extend-
ing step (iii) such that we eliminate additional zO and zE
candidates. The methodology of constructing a candidate
list presented here is ﬁnal.
Combining additional sum properties Everything pre-
sented in this paragraph aims to eliminate odd candidates
zO in step (iii) of the methodology described above, and
hence further drop the computational complexity. It is also
applicable to even candidates. However, to avoid repetition,
we will not concern ourselves with this.

Suppose, in addition to Sǫ and S{b}, we also determine
S{b′} with high probability, for encrypted input byte {b′},
where {b} 6= {b′}. We refer to a0a1 . . . and a′
1 . . . as the

0a′

26LFSR-stream resulting from feeding {b} and {b′} as input,
respectively.

deﬁnition of a49+j , we obtain
a49+j ⊕ a′

49+j =f (a10+j a12+j . . . a48+j ) ⊕ {bj+1} ⊕ uj+1⊕

Suppose {b} and {b′} have a common preﬁx of i bits, i.e.
{bj } = {b′
j } for all j < i. In step (iii) of the methodology
from the previous paragraph we, for each pair (p, q), iterate
through all pairs (r, s). Within this iteration, we will now
also go through all values r′ ∈ [0, 16], for which a value
S{b′} = r′(16 − k) + (16 − r′)k exists, where k ∈ [0, 16].
Recall that every y ∈ TOr is a candidate for a17a19 . . . a55.
Per lemma 5.2, we know that a48+j = a′
48+j for all j < i.
Therefore, a y′ ∈ TOr′ must exist such that yj = y′
j for all
j < 16 + ⌊ 1
2 i⌋. If this is not the case, we can eliminate y as
a candidate for a17a19 . . . a55.

Next we focus on the remainder of {b},

the bits
beyond the constant preﬁx of i bits, to further eliminate
candidates. We eliminate the entry y ∈ TOr if we can prove
that the candidate is invalid, regardless of what value is
stored in the even bits of the LFSR.

i.e.

We follow deﬁnitions 3.5 and 3.6 and obtain, for 0 ≤ k < 8

a48+k =f (a9+ka11+k . . . a47+k) ⊕ {bk} ⊕ uk⊕

L(a0+ka5+k . . . a43+k)

We take j := i (note that later we want to increase j) and
take the diﬀerence between {a48+j } and {a′

48+j }. We get

a48+j ⊕ a′

48+j =f (a9+ja11+j . . . a47+j ) ⊕ {bj } ⊕ uj ⊕

L(a0+ja5+j . . . a43+j )⊕
f (a′
L(a′

11+j . . . a′
5+j . . . a′

9+ja′
0+ja′

47+j ) ⊕ {b′
43+j )

j } ⊕ uj ⊕

Obviously, uj is XOR-ed twice, so it is canceled out.
Recall that we are concerned with odd bits, thus j is
odd. Therefore, f (a9+ja11+j . . . a47+j ) depends only on even
LFSR stream bits. We introduce an invariant stating that
the even bits are equal:

47+j

9+ja′

9+ja′

11+j . . . a′

11+j . . . a′

a9+ja11+j . . . a47+j = a′

(1)
Given that j = i, we know that the invariant holds. Hence,
also f (a9+ja11+j . . . a47+j ) = f (a′
47+j ), regard-
less of what the actual value for a9+ja11+j . . . a47+j is. Fur-
thermore, since all even positioned bits fed to the feedback
function L are equal, they are canceled out. Thus, the above
is equivalent to
a48+j ⊕ a′
43+j
Hence, in order for candidate y to be valid, a y′ must exist
such that

48+j = {bj } ⊕ {b′

41+j ⊕ a43+j ⊕ a′

j } ⊕ a41+j ⊕ a′

y16+⌊ 1

2

j⌋ ⊕ y′

16+⌊ 1
2

j⌋ ={bj } ⊕ {b′

j }⊕
j⌋ ⊕ y′
j⌋ ⊕ y′

y13+⌊ 1

2

y14+⌊ 1

2

13+⌊ 1
2

14+⌊ 1
2

j⌋⊕

j⌋

Suppose such a y′ indeed exists such that the above is true.
At this point, we need not immediately accept y as a valid
candidate. Rather, we may test whether the above also holds
for j ← j +2. However, in order to do so, we must ﬁrst check
whether invariant (1) still holds. Given that it holds for j,
all we need to do is verify that a49+j = a′
49+j . Following the

L(a1+ja6+j . . . a44+j )
f (a′
L(a′

12+j . . . a′
6+j . . . a′

10+j a′
1+ja′

44+j )

48+j ) ⊕ {b′

j+1} ⊕ uj+1⊕

Similar as before, uj+1 is XOR-ed twice and hence canceled
out. Also the even positioned bits and all odd bits positioned
between 0 and 47 + i fed to the feedback function are equal,
thus canceled out. Hence, the above becomes
a49+j ⊕ a′

j+1} ⊕ f (a10+j a12+j . . . a48+j )⊕

49+j ={bj+1} ⊕ {b′

f (a′

10+j a′

12+j . . . a′

48+j ) ⊕ a42+j ⊕ a′

42+j

Translating this into terms of y and y′ again, we obtain
(recall x in step (iii) from the methodology described in the
last paragraph)

{bj+1} ⊕ {b′

j+1} ⊕ f (x[1+⌊ 1

f (x[1+⌊ 1

2

j⌋,3]y′

[0,16+⌊ 1
2

j⌋]) ⊕ y14+⌊ 1

2

14+⌊ 1
2

i⌋

2

j⌋,3]y[0,16+⌊ 1
i⌋ ⊕ y′

2

j⌋])⊕

If the above evaluates to 0, we have proven that, in case
y is valid, then a49+j = a′
49+j, and hence we have proven
that invariant (1) still holds. We proceed by attempting
to disprove the validity of y once more with j ← j + 2.
Otherwise, we stop and accept y as a candidate. In case we
reach j = 7 we always stop and accept y as a candidate.

In case no y′ exists such that y is accepted, we have proven

the invalidity of y and eliminate it.

Obviously, the diﬀerential analysis presented here can be
repeated with other input bytes {b′}, which will result in the
elimination of additional key candidates.

Due to the sheer complexity of analyzing the average size
of the leftover complexity yielded by the diﬀerential anal-
ysis, we will not concern ourselves with this. Practical ex-
periments indicate that it is sensible to assume a drop of
approximately 1 bit per byte {b′} involved in the analysis.
However, it is important to note that a single incorrect guess
for S{b′} will likely cause the correct key to be absent from
the resulting leftover search space.

In the next section, we present another independent prop-
erty of the cipher’s internal state that we can deduce by
observing the ciphertext. We may use this property to elim-
inate additional key candidates, hence even further dropping
the computational complexity.
5.6 Filter Flip Property
The second property that can be observed by analyzing the
ciphertext is what we name the ﬁlter ﬂip property. It was
ﬁrst documented in the literature by Garcia et al.
in 2009
[GRVS09].

Lemma 5.10. Suppose we obtained two encrypted nonces
{nT } and {n′
T }. Their corresponding LFSR-streams are
a0a1 . . . and a′
0a′
1 . . . , respectively and their parity bits are pi
and p′
i for all i ∈ N. Suppose that we observe that all bytes
before byte i, where i ∈ [0, 3], are equal and that only the
last bit of byte i diﬀers, i.e. {nT[0,8i+7] } = {n′
T[0,8i+7] } ⊕ 1.
Furthermore, we ﬁnd that {pi} = {p′

i}.

Then f (α8i+8) 6= f (α8i+8 ⊕ 1).

Proof. Published in [Mei15].

Suppose that we ﬁnd a case of {nT[8i,8i+7] } where the
above is not the case. Then we can observe the ﬁlter ﬂip
property on even bits. The following lemma states this.

27T } such that {nT[0,8i+7] } = {n′

Lemma 5.11. Suppose we obtained two encrypted nonces
{nT } and {n′
T[0,8i+7] } ⊕ 2,
where i ∈ [0, 3]. Furthermore, we observe that {pi} = {p′
i},
and we have deduced through lemma 5.10 that f (α8i+7) =
f (α8i+7 ⊕ 1).

Then f (α8i+7) 6= f (α8i+7 ⊕ 1).

Proof. Published in [Mei15].

We continue with the lemma showing that only approxi-
mately 9.4% of the possible inputs to the ﬁlter function f
have this property.

Lemma 5.12. Let Y0, . . . , Y4 be independent uniformly dis-
tributed random variables over F2. Then

P [fb(Y0, Y1, Y2, Y3) 6= fb(Y0, Y1, Y2, Y3)] = 1
4
P [fc(Y0, Y1, Y2, Y3, Y4) 6= fc(Y0, Y1, Y2, Y3, Y4)] = 3
8 .

Proof. By inspection.

Since only the twenty bits that are input to f are relevant,
such that f (x) 6= f (x ⊕ 1) can be easily

all states x ∈ F20
2
generated. Below the set of these states F is deﬁned

F := {x | x ∈ F20

2 and f (x) 6= f (x ⊕ 1)}

We can use the diﬀerential analysis described in the pre-
vious section to further narrow down the search space. We
may do so by applying it to F , rather than TOr in case we
observe that f (α8) 6= f (α8 ⊕ 1) for a certain input byte {b′}.
Practical experiments indicate that, for every ﬁlter ﬂip
property observed, we may assume a complexity drop of ap-
proximately 1
2 bits during the diﬀerential analysis described
in the previous section.

In the next section we shall more concretely analyze the

performance of the attack by means of simulations.

6 Performance analysis
In this section, we analyze the performance of the attack.
We implemented the attack and ran simulations, wherein
we vary the number of nonces gathered and the probability
threshold. The performance of the attack is expressed by
the size of the resulting leftover search space, which is de-
termined as described in step (iv) in Section 5.5. The sum
property value and the ﬁlter ﬂip property being present both
depend on the cipher’s internal state. Hence, the resulting
complexity depends heavily on the key. Due to this fact, in
order to assess the overall eﬃciency of the attack, we simu-
lated the attack using 100 randomly chosen keys.

Figure 6.1 contains a graph depicting the median leftover
complexity. The translucent planes depict the second and
third quartile. From this ﬁgure we can observe that the
leftover complexity quickly becomes within reach of solv-
ing on ordinary hardware within minutes. Typically, after
collecting approximately 10,000 - 20,000 nonces, the leftover
complexity is solvable even within seconds. The trade-oﬀ be-
tween gathering additional nonces or starting a brute force
attempt within the leftover search space depends on which
is on the upper hand: the nonce-retrieving hardware or the
computational power we have at our disposal.

Contrary to the expectations, the leftover complexity may
increase slightly when the number of nonces increases. We
suspect this is due to the fact that, in our implementation,
we select a single byte {b} and perform the diﬀerential anal-
ysis presented in Section 5.5 against all other bytes {b′}.
The selection of {b} is based on heuristics which we will not

Figure 6.1: Median leftover complexity

explain in detail. The consequence of this is that the anal-
ysis runs signiﬁcantly faster than when we would perform
the analysis for every possible {b} against all other bytes
{b′} and subsequently select the smallest resulting set, at
the cost of the resulting search space becoming somewhat
suboptimal. However, the total time needed to recover a
key is decreased.

Every time we choose to involve another input byte/sum
property pair in the diﬀerential analysis (i.e. the sum prop-
erty value is known with a probability exceeding the thresh-
old chosen), the leftover search space decreases in size. Since
sum property values at time 8 are determined probabilisticly,
the probability that the correct keys exists within the left-
over search space also decreases. Therefore, another aspect
of the performance analysis is determining the actual prob-
ability that the correct key lies within the leftover search
space, given the probability threshold chosen.

Figure 6.2 depicts the probability of the correct key ly-
ing within the leftover search space. One may expect it to
rapidly decrease in case we involve a large number of input
bytes in the analysis. Fortunately for the adversary, this is
not the case. This is because the sum property values for
each input byte are not statistically independent from one
another.

Figure 6.2: Leftover search space with the correct key.

Finally, we should highlight that our implementation of
the attack only returns the leftover search space if at least
a single input byte is involved in the analysis, i.e. the prob-
ability of guessing the sum property correctly exceeds the
chosen threshold for at least a single input byte at time 8).
Though this is not strictly necessary, as one could simply
take the set of all possible values for the internal state at
time 8. However, implementing the attack this way resulted
in cleaner code. Therefore, in the statistics depicted above,

28every sample wherein we do not assign a sum property value
to any of the input bytes is not taken into account.

Figure 6.3 depicts the number of samples having at least
a single sum property guess exceed the probability thresh-
old. Thus, depicting the number of samples being taken into
account in the other statistics presented in this section.

Figure 6.3: Number of samples involved in the statistics

7 Conclusion
Over the last years there are a number of vulnerabilities and
attacks identiﬁed in the cryptography and implementation
of mifare Classic cards. The most serious of them are the
card-only attacks, which can recover the secret key simply
through wireless interaction with a card in an uncontrolled
environment. System integrators consider these attacks as
one of most serious threats to their mifare Classic based
systems, since it allows the adversary to avoid camera de-
tection.

We are the ﬁrst to discover a card-only attack that de-
pends solely on the design issues of the cipher and authen-
tication protocol. To the best of our knowledge, every mi-
fare Classic compatible card that is currently in circulation
is vulnerable to our attack. Table 7.1 shows a comparison
between our attack and previous card-only attacks found in
the literature.

Table 7.1: Comparison of card-only attacks

Attack
[GRVS09]
[Cou09]
[CHC+14]
Our

2
300
∼ 1,000,000

Traces Gather Compute a b
< 1s × X
< 1s × ×
2-15m X ×
5-10m X X

< 1s
3m
10-20h
∼ 10,000 6-12m

aDoes not require a weak PRNG
bDoes not require the error code after a failed authentication

Hardened mifare Classic cards (e.g. SmartMX and mi-
fare Plus) are not susceptible to previously published card-
only attacks. However, they are vulnerable to our attack
described in this paper. Moreover, in order to mitigate our
attack, backwards compatibility with the mifare Classic
protocol is inherently broken. Therefore, we conclude that
all mifare Classic compatible cards should be regarded as
plain memory cards and system integrators can no longer
trust their data’s authenticity and conﬁdentiality.

We have fully implemented and tested our attacks in prac-
tice on various hardened MIFARE Classic cards and recov-
ered secret keys within minutes. Furthermore, we present
an extensive complexity analysis with the theoretical bound-
aries to give a better estimate of the average running-time.
The only prerequisite of our attack is that a single key
must be known in advance. However, in practice this re-

quirement is almost always satisﬁed due to the massive de-
ployment of cards that use a default key for at least one or
more memory sectors.

We have notiﬁed the manufacturer NXP seven months in
advance of publication and practically demonstrated our at-
tack on their hardened mifare Classic cards. After notiﬁca-
tion, we attended several meetings to discuss the attack and
its impact. Furthermore, they asked us to review a draft of
their customer notiﬁcation letter wherein they acknowledge
our work and discourage to use the mifare Classic compat-
ible technology in the future.
7.1 Recommendations
We strongly advice system integrators to migrate away from
mifare Classic compatible systems and start using strong
and cryptographically secure systems. There are many al-
ternative contactless smart cards that support well-studied
cryptographic algorithms and formally veriﬁed authentica-
tion protocols. However, system integrators which are ab-
solutely unable to upgrade their infrastructure could tem-
porarily consider the following palliating countermeasures:

(i) Deploy hardened cards and diversify all keys. – Re-
quires the adversary to perform a diﬀerent attack prior
to ours, involving either eavesdropping or communica-
tion with a reader. This has to take place in a con-
trolled environment, risking camera detection.

(ii) Perform authenticity and integrity checks in the back-
oﬃce on a regular basis to detect fraudulent transac-
tion.

8 References

[AK03]

[And91]

[And95]

Frederik Armknecht and Matthias Krause. Algebraic
attacks on combiners with memory. In 23rd
International Cryptology Conference, Advances in
Cryptology (CRYPTO 2003), pages 162–175.
Springer-Verlag, 2003.
Ross J Anderson. Tree functions and cipher systems.
Cryptologia, 15(3):194–202, 1991.
Ross Anderson. Searching for the optimum correlation
attack. In 2nd International Workshop on Fast
Software Encryption (FSE 1994), volume 1008 of
Lecture Notes in Computer Science, pages 137–143.
Springer-Verlag, 1995.

[BDR+96] Matt Blaze, Whitﬁeld Diﬃe, Ronald L Rivest, Bruce

Schneier, and Tsutomu Shimomura. Minimal key
lengths for symmetric ciphers to provide adequate
commercial security. a report by an ad hoc group of
cryptographers and computer scientists. Technical
report, DTIC Document, 1996.
Eli Biham. A fast new DES implementation in
software. In 4th International Workshop on Fast
Software Encryption (FSE 1997), volume 1267 of
Lecture Notes in Computer Science, pages 260–272.
Springer-Verlag, 1997.
Mr. Bayes and Mr Price. An essay towards solving a
problem in the doctrine of chances. by the late rev.
mr. bayes, frs communicated by mr. price, in a letter
to john canton, amfrs. Philosophical Transactions
(1683-1775), pages 370–418, 1763.
Alex Biryukov and Adi Shamir. Cryptanalytic
time/memory/data tradeoﬀs for stream ciphers. In
Advances in Cryptology–ASIACRYPT 2000, pages
1–13. Springer, 2000.
Paul Camion, Claude Carlet, Pascale Charpin, and
Nicolas Sendrier. On correlation-immune functions. In
11th International Cryptology Conference, Advances
in Cryptology (CRYPTO 1991), volume 576 of
Lecture Notes in Computer Science, pages 86–100.
Springer-Verlag, 1992.
Yi-Hao Chiu, Wei-Chih Hong, Li-Ping Chou, Jintai
Ding, Bo-Yin Yang, and Chen-Mou Cheng. A

[Bih97]

[BP63]

[BS00]

[CCCS92]

[CHC+14]

29[CJM02]

[CM03]

[Cou09]

[CP02]

[CS91]

Practical Attack on Patched MIFARE Classic. In
Information Security and Cryptology, pages 150–164.
Springer, 2014.
Philippe Chose, Antoine Joux, and Michel Mitton.
Fast correlation attacks: An algorithmic point of view.
In 21st International Conference on the Theory and
Application of Cryptographic Techniques, Advances
in Cryptology (EUROCRYPT 2002), volume 2332 of
Lecture Notes in Computer Science, pages 209–221.
Springer-Verlag, 2002.
Nicolas T Courtois and Willi Meier. Algebraic attacks
on stream ciphers with linear feedback. In 22nd
International Conference on the Theory and
Application of Cryptographic Techniques, Advances
in Cryptology (EUROCRYPT 2003), pages 345–359.
Springer-Verlag, 2003.
Nicolas T Courtois. The dark side of security by
obscurity and cloning Mifare Classic rail and building
passes, anywhere, anytime. SECRYPT: International
Conference on Security and Cryptography, 2009.
Nicolas T Courtois and Josef Pieprzyk. Cryptanalysis
of block ciphers with overdeﬁned systems of equations.
In 8th International Conference on the Theory and
Application of Cryptology and Information Security,
Advances in Cryptology (ASIACRYPT 2002), pages
267–287. Springer-Verlag, 2002.
Vladimir Chepyzhov and Ben Smeets. On a fast
correlation attack on certain stream ciphers. In 10th
International Conference on the Theory and
Application of Cryptographic Techniques, Advances
in Cryptology (EUROCRYPT 1991), volume 547 of
Lecture Notes in Computer Science, pages 176–185.
Springer-Verlag, 1991.

[DHW+12] Benedikt Driessen, Ralf Hund, Carsten Willems,

[FGT92]

[FJ03]

Carsten Paar, and Thorsten Holz. Don’t trust satellite
phones: A security analysis of two satphone standards.
In 33rd IEEE Symposium on Security and Privacy
(S&P 2012), pages 128–142. IEEE, 2012.
Philippe Flajolet, Daniele Gardy, and Lo¨ys Thimonier.
Birthday paradox, coupon collectors, caching
algorithms and self-organizing search. Discrete
Applied Mathematics, 39(3):207–229, 1992.
Jean-Charles Faugere and Antoine Joux. Algebraic
cryptanalysis of hidden ﬁeld equation (hfe)
cryptosystems using gr¨obner bases. In 23rd
International Cryptology Conference, Advances in
Cryptology (CRYPTO 2003), pages 44–60.
Springer-Verlag, 2003.

[GKGM+08] Flavio D Garcia, Gerhard de Koning Gans, Ruben

Muijrers, Peter Van Rossum, Roel Verdult,
Ronny Wichers Schreur, and Bart Jacobs. Dismantling
MIFARE classic. In Computer Security-ESORICS
2008, pages 97–114. Springer, 2008.
Flavio D. Garcia, Gerhard de Koning Gans, and Roel
Verdult. Tutorial: Proxmark, the swiss army knife for
RFID security research. Technical report, Radboud
University Nijmegen, 2012.
Jovan Dj Goli´c. On the security of nonlinear ﬁlter
generators. In 3rd International Workshop on Fast
Software Encryption (FSE 1996), volume 1039 of
Lecture Notes in Computer Science, pages 173–188.
Springer-Verlag, 1996.
Jovan Dj. Goli´c. Cryptanalysis of alleged A5 stream
cipher. In 16th International Conference on the
Theory and Application of Cryptographic
Techniques, Advances in Cryptology (EUROCRYPT
1997), volume 1233 of Lecture Notes in Computer
Science, pages 239–255. Springer-Verlag, 1997.
Flavio D Garcia, Peter van Rossum, Roel Verdult, and
Ronny Wichers Schreur. Wirelessly pickpocketing a
Mifare Classic card. In Security and Privacy, 2009
30th IEEE Symposium on, pages 3–15. IEEE, 2009.
Martin E Hellman. A cryptanalytic time-memory
trade-oﬀ. Information Theory, IEEE Transactions
on, 26(4):401–406, 1980.
Lester S. Hill. Cryptography in an algebraic alphabet.
American Mathematical Monthly, 36(6):306–312,
1929.
Mechanisms using symmetric encipherment algorithms
(ISO/IEC 9798 part 2), 1999. International
Organization for Standardization (ISO).

[GKGV12]

[Gol96]

[Gol97]

[GRVS09]

[Hel80]

[Hil29]

[ISO99]

[ISO01]

[JJ00]

[JS97]

[Ker83]

Identiﬁcation cards — contactless integrated circuit
cards — proximity cards (ISO/IEC 14443), 2001.
Thomas Johansson and Fredrik J¨onsson. Fast
correlation attacks through reconstruction of linear
polynomials. In 20th International Cryptology
Conference, Advances in Cryptology (CRYPTO
2000), volume 1880 of Lecture Notes in Computer
Science, pages 300–315. Springer-Verlag, 2000.
Norman D. Jorstad and Landgrave T. Smith.
Cryptographic algorithm metrics. In 20th National
Information Systems Security Conference. National
Institute of Standards and Technology (NIST), 1997.
Auguste Kerckhoﬀs. La cryptographie militaire.
Journal des Sciences Militaires, 9(1):5–38, 1883.

[Mar57]

[Mei15]

[MS88]

[Mul56]

[NP07]

[Kuh88]

[MAD07]

[NESP08]

[KGHG08] Gerhard de Koning Gans, Jaap-Henk Hoepman, and
Flavio D Garcia. A practical attack on the MIFARE
Classic. In Smart Card Research and Advanced
Applications, pages 267–282. Springer, 2008.
GJ Kuhn. Algorithms for self-synchronizing ciphers. In
1st Southern African Conference on
Communications and Signal Processing (COMSIG
1988), pages 159–164. IEEE, 1988.
Mifare application directory. http://www.nxp.
com/acrobat download/other/identiﬁcation/
M001830.pdf, May 2007.
Harry M Markowitz. The elimination form of the
inverse and its application to linear programming.
Management Science, 3(3):255–269, 1957.
Carlo Meijer. Ciphertext-only cryptanalysis on
hardened mifare classic cards extended. Master’s
thesis, Radboud University Nijmegen, 2015.
Willi Meier and Othmar Staﬀelbach. Fast correlation
attacks on stream ciphers. In 7th Conference on the
Theory and Application of Cryptographic
Techniques, Advances in Cryptology (EUROCRYPT
1988), volume 330 of Lecture Notes in Computer
Science, pages 301–314. Springer-Verlag, 1988.
David E Muller. A method for solving algebraic
equations using an automatic computer. Mathematical
Tables and Other Aids to Computation,
10(56):208–215, 1956.
Karsten Nohl, David Evans, Starbug Starbug, and
Henryk Pl¨otz. Reverse-Engineering a Cryptographic
RFID Tag. In USENIX Security Symposium,
volume 28, 2008.
Karsten Nohl and Henryk Pl¨otz. Mifare, little security,
despite obscurity. In 24th congress of the Chaos
Computer Club in Berlin, 2007.
MIFARE Classic 1k, MF1ICS50. Public product data
sheet, July 1998. Philips Semiconductors.
Thomas Siegenthaler. Correlation-immunity of
nonlinear combining functions for cryptographic
applications. IEEE Transactions on Information
Theory, 30(5):776–780, 1984.
Thomas Siegenthaler. Decrypting a class of stream
ciphers using ciphertext only. IEEE Transactions on
Computers, 100(1):81–85, 1985.
National Institute for Standards and Technology
(NIST). Announcing request for candidate algorithm
nominations for the advanced encryption standard
(AES). Federal Register, 62(177):48051–48058, 1997.
Volker Strassen. Gaussian elimination is not optimal.
Numerische Mathematik, 13(4):354–356, 1969.
Moiez A. Tapia and Jerry H. Tucker. Complete
solution of boolean equations. IEEE Transactions on
Computers, 100(7):662–665, 1980.
Roel Verdult. The (in)security of proprietary
cryptography. PhD thesis, Radboud University, The
Netherlands and KU Leuven, Belgium, April 2015.
Roel Verdult, Flavio D. Garcia, and Josep Balasch.
Gone in 360 seconds: Hijacking with Hitag2. In 21st
USENIX Security Symposium (USENIX Security
2012), pages 237–252. USENIX Association, 2012.

[Str69]

[TT80]

[PHI98]

[Sie84]

[Sie85]

[SN97]

[VGB12]

[Ver15]

[VKGG12] Roel Verdult, Gerhard de Koning Gans, and Flavio D.

Garcia. A toolbox for RFID protocol analysis. In 4th
International EURASIP Workshop on RFID
Technology (EURASIP RFID 2012), pages 27–34.

IEEE Computer Society, 2012.

30