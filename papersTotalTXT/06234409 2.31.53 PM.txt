2012 IEEE Symposium on Security and Privacy

Don’t Trust Satellite Phones:

A Security Analysis of Two Satphone Standards

Benedikt Driessen, Ralf Hund, Carsten Willems, Christof Paar, Thorsten Holz

Horst-Goertz Institute for IT Security
Ruhr-University Bochum, Germany

{benedikt.driessen, ralf.hund, carsten.willems, christof.paar, thorsten.holz}@rub.de

Abstract—There is a rich body of work related to the
security aspects of cellular mobile phones, in particular with
respect to the GSM and UMTS systems. To the best of our
knowledge, however, there has been no investigation of the
security of satellite phones (abbr. satphones). Even though a
niche market compared to the G2 and G3 mobile systems, there
are several 100,000 satphone subscribers worldwide. Given the
sensitive nature of some of their application domains (e.g.,
natural disaster areas or military campaigns), security plays a
particularly important role for satphones.

In this paper, we analyze the encryption systems used in
the two existing (and competing) satphone standards, GMR-1
and GMR-2. The ﬁrst main contribution is that we were able
to completely reverse engineer the encryption algorithms em-
ployed. Both ciphers had not been publicly known previously.
We describe the details of the recovery of the two algorithms
from freely available DSP-ﬁrmware updates for satphones,
which included the development of a custom disassembler
and tools to analyze the code, and extending prior work on
binary analysis to efﬁciently identify cryptographic code. We
note that these steps had to be repeated for both systems,
because the available binaries were from two entirely different
DSP processors. Perhaps somewhat surprisingly, we found that
the GMR-1 cipher can be considered a proprietary variant of
the GSM A5/2 algorithm, whereas the GMR-2 cipher is an
entirely new design. The second main contribution lies in the
cryptanalysis of the two proprietary stream ciphers. We were
able to adopt known A5/2 ciphertext-only attacks to the GMR-
1 algorithm with an average case complexity of 232 steps. With
respect to the GMR-2 cipher, we developed a new attack which
is powerful in a known-plaintext setting. In this situation, the
encryption key for one session, i.e., one phone call, can be
recovered with approximately 50–65 bytes of key stream and
a moderate computational complexity. A major ﬁnding of our
work is that the stream ciphers of the two existing satellite
phone systems are considerably weaker than what is state-of-
the-art in symmetric cryptography.

Keywords-Mobile Security; Satellite Phone Systems; Crypt-

analysis; Binary Analysis

I. INTRODUCTION

Mobile communication systems have revolutionized the
way we interact with each other. Instead of depending on
landlines, we can talk to other people wherever we are and
also send data from (almost) arbitrary locations. Especially
the Global System for Mobile Communications (GSM) has
attracted quite a lot of attention and with more than four
billion subscribers in 2011, it is the most widely deployed
standard for cellular networks. Many other cellular network

standards like Universal Mobile Telecommunications System
(UMTS), CDMA2000 (also known as IMT Multi-Carrier
(IMT-MC)), or 3GPP Long Term Evolution (LTE) exist and
are continuously enhanced to meet the growing customer
demands.

Cellular mobile networks require a so called cell site
to create a cell within the network. The cell site provides
all the necessary equipment for transmitting and receiving
radio signals from mobile handsets and the radio network.
For example, the cell site contains one or more sets of
transmitter/receivers, the necessary antennas, digital signal
processors to perform all computations, a GPS receiver for
timing, and other control electronics. Within GSM, the cell
site is called Base Transceiver Station (BTS) and other
cellular networks also require this kind of equipment. The
cells within a network have only a limited operating distance
and thus a certain proximity to a cell site is necessary to
establish a connection to the mobile network.

In practice, however, it is not always possible to be close
to a cell site and there are many use cases in which no cover-
age is provided. Workers on an oil rig or on board of a ship,
researchers on a ﬁeld trip in a desert or near the poles, people
living in remote areas or areas that are affected by a natural
disaster, or certain military and governmental systems are a
few of many uses cases where terrestrial cellular networks
are not available. To overcome this limitation, satellite
telecommunication systems were introduced that provide
telephony and data services based on telecommunications
satellites. In such systems, the mobile handset (typically
called satellite phone, abbr. satphone) communicates directly
with satellites in orbit and thus coverage can be provided
without the need of an infrastructure on the Earth’s surface.
At this point, there are two satphone standards that were

both developed in the past few years:

• Geostationary Earth Orbit (GEO) Mobile Radio Inter-
face (better known as GMR-1) is a family of ETSI
standards that were derived from the terrestrial cellular
standard GSM. In fact,
the speciﬁcations of GMR
are an extension of the GSM standard, where certain
aspects of the speciﬁcation are adjusted for satphone
settings. This protocol family is supported by several
providers and the de-facto standard in this area and has
undergone several revisions to support a broader range
of services.

© 2012, Benedikt Driessen. Under license to IEEE.
DOI 10.1109/SP.2012.18

128

• The GMR-2 family is also an ETSI standard that
is even closer to GSM. It deviates from the GMR-
1 speciﬁcations in numerous ways, most notably the
network architecture is different.

The speciﬁcations of GMR-1 and GMR-2 are available
since both are ETSI standards. However, the speciﬁcations
do not provide any information about implementation details
of security aspects. More precisely, it is for example not
publicly known which encryption algorithm is actually used
to secure the communication channel between a satphone
and a satellite. This implies that the security aspects of
both standards are poorly documented and proprietary. This
is problematic due to the fact that an attacker can easily
eavesdrop on the communication channel since the radio
signal can be captured with antennas even at some distance
to the satphone. At
is thus unclear what
effort would be needed by an attacker to actually intercept
telephony and data services for common satphone systems.
In this paper, we address this problem and perform a
security analysis of the two satphone standards GMR-1 and
GMR-2. More speciﬁcally, we are interested in the stream
ciphers A5-GMR-1 and A5-GMR-2 implemented on the sat-
phones since they are responsible for providing conﬁdential
communication channels. To assess the attack surface, we
analyzed two popular satellite phones that represent typical
handsets:

this point,

it

1) The Thuraya SO-2510 phone implements the GMR-1
standard. It was released in November 2006 and one
of the most popular handsets sold by Thuraya.

2) The Inmarsat IsatPhone Pro implements the GMR-
2 standard1 and supports functions such as voice
telephony and text/email messaging. It was introduced
in June 2010 by Inmarsat.

In principle, satphones implement a hardware architec-
ture similar to typical mobile phones used in terrestrial
networks. However, since satphones operate according to
different standards, we had to reverse-engineer the phones
in detail to understand the algorithms implemented in them.
More speciﬁcally, we developed our own set of tools to
disassemble the machine code and to perform typical binary
analysis tasks such as control and data ﬂow analysis. This is
challenging since satphones do not use the Intel x86 instruc-
tion set architecture but typically a combination of an ARM-
based CPU and a digital signal processor (DSP). Recently,
several techniques were introduced to detect cryptographic
code within a binary in a generic way [1]–[3]. While such
techniques can also be leveraged for our analysis, it turned
out that these methods have certain limitations in practice
since signal processing code and speech encoding algorithms
exhibit patterns similar to crypto code. To overcome this
problem, we developed our own set of heuristics and pro-
gram analysis techniques to isolate the cryptographic algo-
rithms of the GMR-1 and GMR-2 standards implemented

1Inmarsat actually refers to their standard as GMR-2+.

129

in the phones. We are the ﬁrst to publish these algorithms,
thus disclosing which crypto algorithms are actually used to
secure the communication channel in satphone systems.

Based on our analysis results, we also performed crypt-
analysis of both algorithms. We introduce different variants
of known and novel attacks and successfully break both
algorithms. More speciﬁcally, GMR-1 uses a stream-cipher
that
is a modiﬁed version of the A5/2 cipher used in
GSM, for which we develop both a known-keystream and
a ciphertext-only attack. Furthermore, we propose an attack
against a speciﬁc GMR-1 channel which has some properties
that we can take advantage of. In contrast, GMR-2 uses a
proprietary cipher, for which we present a known-plaintext
attack whose parameters can be tuned with a time/keystream
trade-off. Effectively, we thus demonstrate that current sat-
phone systems are vulnerable to eavesdropping attacks and
the results of this paper can be used to build an interceptor
for satellite telecommunication systems.

In summary, we make the following contributions:

• We are the ﬁrst to perform an empirical security analy-
sis of the satellite phone standards GMR-1 and GMR-
2, focusing on the encryption algorithms implemented
in the handsets. This includes reverse-engineering of
ﬁrmware images to understand the inner working of
the phones, developing our own disassembler and tools
to analyze the code, and extending prior work on binary
analysis to efﬁciently identify cryptographic code.

• We perform a formal cryptanalysis of the extracted
algorithms and extend a known attack on GSM for
GMR-1 and introduce an entirely new attack for GMR-
2. Thus we are able to break the encryption in both
standards. The attacks can be tuned by a time/ciphertext
trade-off for GMR-1 and a time/keystream trade-off for
GMR-2. We thus demonstrate that the current satphone
standards are vulnerable to eavesdropping attacks.

II. BACKGROUND AND RELATED WORK

We now introduce the necessary background information
to understand the basics of satellite telephone systems, their
security mechanisms, and the architecture of the mobile
handsets. More information about these topics can be found
in the literature [4]–[8]. Furthermore, we discuss related
work in this area.

A. Satellite Telecommunication Systems

A geostationary orbit telephone network consists of a
set of satellites and terrestrial gateway/control stations, as
depicted in Figure 1. Gateway stations provide the con-
nectivity to any tethered networks, e.g., telephone calls to
a landline are forwarded to the public switched telephone
network (PSTN). Satellite operators also run additional con-
trol facilities for maintenance and conﬁguration purposes.
Both types of transmissions employ conventional wavelength
(C-Band) signals. Each satellite serves a speciﬁc region,

with each region being further subdivided by several spot
beams. This mainly allows to transfer multiple signals from
different regions on equal frequencies. The system uses long
wavelength transmission (L-Band) for spotbeams.









 




 





Figure 2. Authentication and encryption in GMR systems (simpliﬁed)

Figure 1. Layout of a geostationary orbit telephone network [8]

In this paper, we focus on the communication channel
between end user devices and satellites. This is the only
part of the system that is (partially) publicly documented
by the GMR speciﬁcation [6], [9]. The ofﬁcial speciﬁcation
discusses topics relevant to signaling, encoding, and similar
aspects of the system. However, no implementation details
about
the actual cryptographic algorithms that are used
between satphones and satellites are disclosed.

The frequency band in GMR systems is divided into
different channels and just like in GSM the Time Division
Multiple Access (TDMA) time slot architecture is employed
which divides each channel into TDMA frames with mul-
tiple time slots. Several logical channels (called channels
from now on) are mapped on these time slots. There are
different types of channels, but all are either trafﬁc channels
(TCH) for voice- or fax-data, or control channels (CCH).
Data which is sent over any channel is encoded to add
redundancy and protect against transmission failures. For
some channels, the encoded data is subsequently encrypted.
The encoded (and encrypted) data is ﬁnally modulated
accordingly before it is transmitted via the phone’s antenna.
The encoding scheme differs from channel to channel and
is dependent on the respective reliability requirements as
deﬁned in the various standards.

Figure 2 provides a highly abstract sketch of the authen-
tication and encryption protocol used by GMR-1 and GMR-
2. In this protocol, the satellite initiates authentication by
sending a request to the phone shortly after the phone has
established a connection. This request contains a random
number RAND, which is sent to the phone’s SIM card. On
the SIM card, the A3 and A8 algorithm are implemented
that generate a session key Kc and an authentication token
SRES. Both algorithms are not disclosed in the speciﬁcation
and use the SIM card speciﬁc key Ki as second input. After
authentication, the encryption is switched on and all subse-
quent communication on the relevant channels is encrypted
by a stream cipher denoted as A5-GMR, which is also not

publicly documented. Due to the limited computing power
of the SIM card and the limited bandwidth of the physical
connection, the stream cipher is typically implemented on
the satphone2. The cipher is used to generate a keystream
speciﬁc for blocks of data, which we will denote as frames.
In this protocol, the keystream is dependent on the frame’s
number N and Kc, which was derived from RAND. Due to
this architecture, only the stream cipher is responsible for
conﬁdentiality which is why we focus on this algorithm in
the rest of this paper.

B. Satellite Telephone Architecture

We now brieﬂy elaborate on the general architectural
structure of satellite phones and the hardware behind such
devices. In a later section, we provide more details on the
speciﬁc phones we studied during our analysis, including a
discussion of the actual processors used in typical satphones.
In general, the architecture of satellite phones is similar to
the architecture of cellular phones [10]. Both types of phones
have to perform a lot of signal processing due to speech
processing and wireless communication, thus they typically
ship with a dedicated digital signal processor (DSP) for such
purposes. Consequently, complex mathematical operations
like for example data compression or speech encoding
are outsourced to the DSP where the actual computations
are performed. More relevant for our purpose is the fact
that DSPs are also suitable for executing cryptographic
algorithms, which makes DSP code a prime candidate for
holding GMR cipher code.

The core of the phone is a standard microprocessor
(usually an ARM-based CPU) that serves as the central
control unit within the system. This CPU initializes the DSP
during the boot process. Furthermore, both processors share
at least parts of the main memory or other peripheral devices
to implement inter-processor communication. To understand
the ﬂow of code and data on a phone, we thus also need to
analyze the communication between the two processors.

2Page 37 of the speciﬁcation [9] actually states that the encryption

algorithm has to be stored on the SIM card.

130

The operating system running on a phone is typically a
specialized embedded operating system that is designed with
respects to the special requirements of a phone system (e.g.,
limited resources, reliability, real-time constraints, etc.). All
of the software is deployed as one large, statically linked
ﬁrmware binary. For our analysis, we were especially in-
terested in the inter-processor communication functionality
provided by the operating system as well as the DSP
initialization routine. This is due to the fact that cipher
code will likely be implemented in the DSP for performance
reasons. Our interest for the DSP initialization routine arises
from the fact that it typically reveals where DSP code is
located in the ﬁrmware and how it is mapped to memory.

C. Related Work

Satellite telecommunication systems are related to terres-
trial cellular systems, the GMR-1 standard is for example
derived from the GSM standard. We can thus leverage
work on the analysis of cellular systems for our security
analysis as we discuss in the following. Briceno et al.
published in 1999 an implementation of the GSM A5/1 and
A5/2 algorithms, which they apparently obtained by reverse
engineering an actual GSM handset [11]. However, no actual
details about the analysis process were ever published and
it remains unclear how they actually derived the algorithms.
Our analysis is also based on actual satellite phones, we
discuss the general approach in Section III and provide
analysis details in later sections.

There has been lots of work on the security analysis of the
ciphers used within GSM [12]–[20]. A5-GMR-1 is related to
the A5/2 algorithm used within GSM, but the conﬁguration
of the cipher is different. Our attack for this algorithm builds
on the ideas of Petrovic and Fuster-Sabater [13] and Barkan
et. Al. [18] which we extended to enable a time/ciphertext
trade-off.

Up to now, there has been no work on the security aspects
of satellite telecommunication systems that we are aware of
and we are the ﬁrst to explore this topic.

III. GENERAL APPROACH

In this section, we outline the general methodology we
used for identifying and extracting cipher algorithms from
satellite phones. Furthermore, we also discuss the assump-
tions that helped us during the analysis phase and provide
an overview of our target satphones.

We analyzed two representative phones that use the two
different standards we are interested in. More precisely, we
analyzed the ﬁrmwares of the following two phones:

• Thuraya SO-2510 satphone that implements the GMR-

1 speciﬁcation

• Inmarsat IsatPhone Pro satphone that implements the

GMR-2 speciﬁcation

The starting point of our analysis was the publicly avail-
able ﬁrmware upgrade of each of these two devices. The
entire analysis was performed purely statically since we did

not have a real satellite phone at our disposal that we could
instrument to perform a dynamic analysis. Furthermore, we
did not have access to a whole device simulator that enables
debugging of arbitrary ﬁrmware image,
thus we had to
develop our own set of analysis tools. However, the ARM
code for the main microprocessor (used by both phones) can
be partially executed and debugged in a CPU emulator such
as QEMU.

The approach we followed to analyze both satphones can

be separated into the following ﬁve phases:

1) Obtain the ﬁrmware installer (usually a Windows setup

program).

2) Extract the ﬁrmware image from the installer.
3) Reconstruct the correct memory mappings of the code

and data sections in the ﬁrmware image.

4) Identify the DSP initialization procedure in order to

extract the DSP code/mapping.

5) Search for the cipher algorithms in the DSP code using
speciﬁc heuristics as well as control and data ﬂow
analysis techniques.

Several steps can be automated, but some manual analysis
is nevertheless required. We successfully applied this method
to the two phones we analyzed. In addition, we speculate that
also other kinds of satphones can be analyzed in this way.
Two assumptions also helped us to ﬁnd the relevant pieces
of code in a shorter amount of time:

1) The key length of the stream cipher algorithms is

known.

2) The frame length is equal to the key length.
3) Since the GMR standards are derived from GSM, the
ciphers bear at least some resemblance to the well-
known, LFSR-based A5 algorithms.

The ﬁrst two assumptions can be derived from the publicly
available parts of the GMR speciﬁcation [9]. The third as-
sumption was conjectured by us. Note that the standard only
speciﬁes the general parameters of the crypto algorithms, but
no details about the actual algorithm are publicly available.
Nevertheless, these assumptions enabled us to decrease the
search space of potential code. The last assumption is
rather speculative, but helped us in ﬁnding one of the two
algorithms.

IV. SECURITY ANALYSIS OF GMR-1

We used the Thuraya SO-2510 phone as an example for
a handset that operates according to the GMR-1 standard.
This decision was solely driven by the fact that the ﬁrmware
of this satphone is publically available from the vendor’s
website. In fact, we did not analyze any other GMR-1
satellite phone, but since the protocol is standardized we are
conﬁdent that our analysis results apply to all other GMR-1
phones as well.

A. Hardware Architecture

The Thuraya SO-2510 runs on a Texas Instruments
OMAP 1510 platform. The core of the platform is an ARM

131

CPU along with a TI C55x DSP processor. This information
can be deduced from corresponding strings in the binary
and from pictures of the actual components soldered on the
circuit board [21]. Figure 3 provides a high-level overview
of the architecture.

Function address % relevant instr.

0001D038
0001CFC8
0001D000
0001D064
00014C9C
00014CAC

43%
41%
41%
37%
25%
25%








 















Figure 3. The OMAP1510 Platform [22]

Both processors can communicate with each other using
a special shared peripherals bus. Furthermore, they share the
same RAM and can access additional memory (e.g., SRAM
or Flash) on equal terms. Initially, DSP code or data has
to be loaded by the ARM CPU into the speciﬁc memory
regions of the DSP. The DSP code can be located in either
the on-chip SARAM (which holds 96 KB of memory) or in
the SRAM, which is accessed through the memory interface
controller (MIC). Writes to the SARAM region of the DSP
are especially interesting for extracting the corresponding
DSP code. The ofﬁcial OMAP1510 documents suggest pre-
deﬁned memory regions to be used by the ARM-MMU
for mapping this memory area [22]. During our analysis,
we could conﬁrm that the ﬁrmware uses exactly the same
mappings.

B. Finding the Crypto Code

The ﬁrmware of the Thuraya SO-2510 is publically avail-
able as a 16 MB sized binary ﬁle from the vendor’s website.
The ﬁrmware ﬁle is neither (partially) packed nor encrypted
and thus the ARM code can be analyzed directly. In the
very beginning of the ARM CPU initialization routine, the
code sets up the virtual memory system by enabling the
MMU with a static translation table. Using this translation
table, we deduced the correct memory mapping at runtime.
By searching for accesses to the DSP SARAM memory and
through string references within the ARM code, we were
able to determine the DSP setup code that copies the DSP
code from the ﬁrmware into the SARAM before resetting
the DSP. Brieﬂy speaking, the code is extracted and byte-
swapped (due to the differing endianness of both processors)

FUNCTIONS RATED BY PERCENTAGE OF BIT-LEVEL INSTRUCTIONS

Table I

from a number of separate chunks from the ﬁrmware image.
For convenience, we ran the related ARM code in the QEMU
emulator and dumped the resulting DSP code afterwards.
This yields approximately 240 KB of DSP code (located in
both SARAM and SRAM) that can be readily disassembled
by tools such as IDA Pro.

Since GMR-1 is derived from GSM, we speculate that
the cipher algorithm employed in GMR-1 bears at least
some resemblance to the A5/2 cipher from GSM. Due to the
nature of this algorithm (e.g., the presence of feedback shift
registers), the cipher code is bound to contain a lot of bit shift
and XOR operations — unless it is somehow obfuscated.
We thus implemented an analysis tool within IDA Pro that
counts the occurrences of such instructions in each function
and sets them in relation to the total number of instruc-
tions in the function. Similar ideas to spot cryptographic
primitives have already been published in the literature [1]–
[3]. Table I lists the six top-rated functions found when
using this heuristic. The four topmost functions are rather
short sequences of code that bear striking resemblance to
feedback register shift operators; a disassembly is depicted
in Figure 12 in the Appendix. Further analyzing the call sites
of these four functions revealed an exposed memory region
holding variables which equal
• the assumed key length,
• the assumed number and length of the feedback regis-

ters, and

• the assumed frame-number lengths (see Section III).

These were all strong indicators that we have spotted the
correct region of the code. Starting from this code area, we
reverse-engineered the relevant code portions to obtain the
cryptographic algorithm employed in the DSP.

C. Structure of the Cipher

The cipher used in GMR-1 is a typical stream-cipher.
Its design is a modiﬁcation of the A5/2 cipher [13], [18],
which is used in GSM networks. The cipher uses four
linear feedback shift registers (LFSR) which are clocked
irregularly. We call these registers R1, R2, R3 and R4, see
Fig. 4 for a schematic of the structure.

Comparing A5/2 and A5-GMR-1, we see that for most
registers the feedback polynomials and also the selection of
input taps for the non-linear majority-function M with

M : {0, 1}3 (cid:2)→ {0, 1}

x (cid:2)→ x2x1 ⊕ x2x0 ⊕ x0x1

132

Figure 4. The A5-GMR-1 cipher

Size
19
22
23
17

R1
R2
R3
R4

Feedback polynomial

x19 + x18 + x17 + x14 + 1
x22 + x21 + x17 + x13 + 1
x23 + x22 + x19 + x18 + 1
x17 + x14 + x13 + x9 + 1

Taps
1,6,15
3,8,14
4,15,19
1,6,15

Final
11
1
0
-

Table II

CONFIGURATION OF THE LFSRS

were changed, see Tab. II for details. Also, the positions
of the bits that are xor’ed with the respective outputs of
the majority functions are different. For curious reasons, all
feedback-polynomials have ﬁve monomials.

D. Mode of Operation

Next we focus on the mode of operation. Clocking a single
LFSR means evaluating its respective feedback polynomial
and using the resulting bit to overwrite the leftmost position
of the LFSR, after shifting its current state by one bit to
the right. When the cipher is clocked for the l-th time with
irregular clocking active, the following happens:

1) The irregular clocking component C evaluates all taps
of R4, the remaining registers are clocked accordingly,
i.e.,

a) Iff M(R4,1, R4,6, R4,15) =R 4,15, register R1 is

clocked.

b) Iff M(R4,1, R4,6, R4,15) = R4,6, register R2 is

clocked.

c) Iff M(R4,1, R4,6, R4,15) = R4,1, register R3 is

clocked.

2) The taps of R1, R2, and R3 are evaluated and one bit

of keystream is output accordingly, i.e.,
zl =M(R1,1, R1,6, R1,15) ⊕ M(R2,3, R2,8, R2,14)⊕

M(R3,4, R4,15, R3,19) ⊕ R1,11 ⊕ R2,1 ⊕ R3,0

is generated.

3) R4 is clocked.

A5-GMR-1 is operated in two modes, initialization and
generation mode. Running the cipher in former mode in-
cludes setting the initial state of the cipher, which is done
in the following way:

1) All four registers are set to zero.
2) A 64-bit initialization value I is computed by xor’ing
the 19-bit frame-number N and 64-bit key K in a
certain way. However, the speciﬁc mapping is not
relevant in the remainder.

3) I is clocked into all four registers, i.e., R1 is clocked
and one bit of I is xor’ed with the feedback-bit, R2 is
clocked and xor’ed with the same bit of I, etc. While
doing this, no irregular clocking takes place, i.e., the
taps of R4 are not evaluated.

4) The least-signiﬁcant bits of all four registers are set to

1, i.e., R1,0 = R2,0 = R3,0 = R4,0 = 1.

After all registers are initialized, irregular clocking is acti-
vated and the cipher is clocked for 250 times. The resulting
output bits are discarded.

Now the cipher is switched into generation mode and
clocked for 2 · m times, generating one bit of keystream
at a time. We denote the l-th keystream-bit by z(N )
, where
250 ≤ l ≤ 250 + 2 · m is the number of irregular clockings
and N the frame-number that was used for initialization.

l

The number of keystream-bits depends on the type of
channel for which data is encrypted or decrypted, see
Tab. III. Note that the encoded blocks on channels TCH6,
FACCH6, TCH9, and FACCH9 are always multiplexed with
ten bits of the SACCH channel. After 2 · m bits have been
generated, the cipher is re-initialized with the next frame-
number.

Depending on the direction bit, either the ﬁrst or the
second half of the keystream is used. Here, we assume that

133

Channel
TCH3/SDCCH
TCH6/FACCH6+SACCH
TCH9/FACCH9+SACCH

n: size of
raw data
80/84 bits

144/188+10 bits
480/300+10 bits

m: size of
encoded data

208 bits

420+10 bits
648+10 bits

Table III

PAYLOAD SIZES IN GMR-1 [9]

only the ﬁrst3 half of each block with only m bits is used,
therefore we deﬁne z(cid:2) as the actual keystream with

z(cid:2) = (z(0)

250, . . . , z(0)

250+m, z(1)

250, . . . , z(1)

250+m, z(2)

250, . . . )2.

E. Cryptanalysis

Since A5-GMR-1 is similar to A5/2, known attacks
against that cipher [13], [17], [18] apply. We build on the
ideas of Petrovic and Fuster-Sabater [13] and present a
known-keystream attack which systematically guesses all
possible 216 initial states of R4. Knowing R4 completely
determines the clocking behavior of the cipher and allows us
to express the known keystream as binary quadratic equation
system in variables which determine the state of R1, R2, and
R3 before warm-up. Taking the ﬁxed bits in these LFSRs
as well as symmetries in the quadratic terms into account,
the equation system can be linearized by replacing quadratic
terms, thus yielding a linear equation system

A · x = z(cid:2)

(cid:3)

(cid:2)

in v variables with
21
2

18
2

v =

+

(cid:5)(cid:6)

(cid:2)
(cid:4)

(cid:2)

(cid:3)

+

(cid:3)
(cid:7)

22
2

linearized variables

+ (18 + 21 + 22)

(cid:5)(cid:6)

(cid:7)

(cid:4)

original variables

(1)

= 655

for each guess of R4. After obtaining 655 linearly indepen-
dent equations, each of these systems can be solved, yielding
a potential initialization-state for R1, R2, and R3. To test the
candidate, the registers are initialized with the guessed value
of R4 and the state candidate, then the cipher is clocked for
several times and the resulting keystream is compared with
the known keystream. If both keystreams match, we have
most likely found the correct initial state. Given the frame-
number N that was used to initialize the registers, K can
be derived efﬁciently.

The known-keystream attack can be modiﬁed in order to
obtain a time/keystream trade-off which enables a ciphertext-
only attack. The number of keystream bits required to solve
the equation system is directly dependent on the number of
unknowns. We can reduce the size of the equation system by
guessing parts of R1, R2 and R3 as well. By k1, k2, k3 we
denote the number of bits we guess for each of the respective

3The ﬁrst m bits are used on the handset’s side for decryption, on the

satellite side for encryption

134

registers, thus the number of variables is reduced to

(cid:2)

v =

(cid:3)

(cid:2)

+

18 − k1

21 − k2

22 − k3

2

2
+(18 − k1) + (21 − k2) + (22 − k3)

2

(cid:3)

(cid:2)

+

(cid:3)

On the downside,
the number of guesses increases and
becomes 216 · 2k1+k2+k3 in the worst case. However, this
makes it possible to mount a direct ciphertext-only attack
on any of the channels (see Tab. II) which exploits the facts
that encryption is applied after encoding and encoding is
linear. This attack was inspired by a work of Barkan et. al. in
2003 [23]. Given a block of raw data d(N ) of n bits which is
transmitted in the N-th frame on one of the relevant channels
in GMR-1, encoding is basically4 a matrix multiplication,
i.e.,

c(cid:2)(N ) = (d(N ) · G)

and c(N ) = c(cid:2)(N ) ⊕ z(N )

where G is called the n×m generator-matrix of the code. By
z(N ) we denote a key-frame (i.e., a block of keystream bits
to encrypt one frame of equal size) for one direction, c(cid:2)(N )
is the encoded and c(N ) the encoded and encrypted block
of m bits. A property of the encoding scheme is that there
exists a corresponding parity-check matrix H of (m−n)×m
size with

H · c(cid:2)(N ) = 0

and therefore H · c(N ) = H · z(N )

if c(cid:2)(N ) is a valid code-word (and was received without bit-
errors). In this case, we can set up an equation system in
the variables z(N )
with 250 ≤ i ≤ 250 + m by computing
the syndrome r = H · c(N ), i.e.,

i

H · z(N ) = r.

(2)

This equation system has (m − n) equations and is there-
fore underdetermined but completely independent from the
encoded plaintext. Given that v ≤ (m − n) holds due to a
proper choice of k1, k2, and k3 and combining Eq. 1 and
Eq. 2, we can set up a uniquely solvable equation system

H · (A · x) = S · x = r

where A is a m × v matrix for a particular guess of R4 (and
parts of R1, R2, R3) and S a (m−n)×v matrix. Solving the
right-hand system results in a potential initialization-state.
This can be tested by deriving a key candidate which can
then be used to generate the keystream for a different frame-
number M and test whether the following relation holds:
H · (c(M ) ⊕ z(M )) ?= 0 with N − 1 > M > N + 1.

4After encoding, a pseudo-random sequence is xor’ed with the encoded
block “[...] to randomize the number of 0s and 1s in the output bit
stream.” [24]. This process is called scrambling and not to be confused with
the subsequent encryption-step, which does basically the same. However,
since the parameters of the LFSR used to generate the scrambling-sequence
are publicly known, scrambling can be inverted easily which is why we
ignore it completely.

The attack can be greatly accelerated by pre-computing and
storing all possible S matrices in advance. Even better, if S
is quadratic, we can store the LU-decompositions of all pos-
sible matrices, which reduces solving the equation systems
to a forward- and backward-substitution step. Typically, S
is not quadratic, but can be made quadratic by dropping an
appropriate selection of rows while maintaining full rank of
the matrix, i.e.,

S(cid:2) = L · U with S(cid:2) = E · S

where S(cid:2) is a v × v matrix, U is an upper triangular matrix
and L a lower triangular matrix. For each guess, we need to
pre-compute and store the tuple (L, U, E) in order to solve
S · x = r in two steps. First, we compute r(cid:2) = E · (H · c(N ))
which is then used to solve the equation system with the
LU-decomposition of S(cid:2), i.e., solve

L · r(cid:2) = y

and U · y = x.

Finally, we propose an attack against the FACCH9 chan-
nel which has some properties that we can take advantage
of: one encoded and encrypted block c(N ) has 658 bits. This
attack requires only one of these blocks, which must be
received without a single bit-error, otherwise H · c(N ) (cid:6)=
H · z(N ). The FACCH9 channel is always multiplexed with
ten bits from SACCH which can be removed, but then we
have to account5 for this when generating the A matrices.
By choosing k1 = 3, k2 = 6 and k3 = 8 the number of
variables representing the remaining unknown bits of the
LFSRs is v = 345. Attacking the demultiplexed FACCH9
channel directly by utilizing only one block of encrypted
data thus requires solving

(216 · 217)/2 = 232

equation systems on average. One of these systems has the
form

S · x = r with S = H · A,

r = H · (D · c(N ))

where D is a 648 × 658 matrix responsible for demulti-
plexing FACCH9/SACCH by removing ten bits from c, A
is a 648 × 345 matrix describing the state of the cipher
for 648 of 658 clockings, H is the 348 × 648 syndrome
matrix for this particular channel and S a slightly overde-
ﬁned 348 × 345 matrix. As stated above, pre-computations
and LU-decomposition can be used if enough memory is
available.

Evidently, there are several variants of this attack possible
on different channels, even more so when multiple frames
are used. These attacks have a lower computational com-
plexity but require more ciphertext. To justify our approach,
we argue that being able to intercept a single block with-
out errors is a more reasonable assumption than receiving
multiple consecutive blocks correctly.

5Multiplexing is done by taking 52 encoded bits from FACCH9, con-
catenating ten bits from SACCH and then appending the remaining 596
encoded bits from FACCH9. We account for this by clocking the cipher
ten times between the generation of the 52-nd and 53-rd equation.

V. SECURITY ANALYSIS OF GMR-2

To obtain the code responsible for implementing the
cipher according to the GMR-2 standard, we analyzed the
latest publically available ﬁrmware image of the Inmarsat
IsatPhone Pro, which was released in June 2010. Only
Inmarsat handsets support the GMR-2 standard at this point
and we are conﬁdent that our analysis results apply to all of
these satphones.

A. Hardware Architecture

The Inmarsat IsatPhone Pro runs on an Analog Devices
LeMans AD6900 platform. The core of the platform is an
ARM 926EJ-S CPU, which is supplemented by a Blackﬁn
DSP (see Figure 5 for a schematic overview). This archi-
tecture can be deduced from plain text strings within the
ﬁrmware image. We identiﬁed an operating system function
that returns information on the underlying hardware of the
system and this function returns the platform name as a static
string.

Both CPUs connect to the same bus interface, which is
attached to the system RAM, any external memory that
might be present as well as the shared peripherals (e.g., SIM
card, keypad, SD/MMC slots, etc.). The system is initialized
by the boot ROM code of the ARM CPU. The ARM CPU
then has the task to initialize the DSP for further operations.

B. Finding the Crypto Code

The ﬁrmware ﬁle is delivered in a special, proprietary
format. When loading it
into the update program from
Inmarsat, the program extracts6 three ﬁles, with each ﬁle
having a header of 80 bytes. After removing the header, two
resulting binary ﬁles can be ARM-disassembled by setting
the correct base address, which can be deduced from the
respective headers. The third ﬁle is seemingly used in a

6This was discovered while disassembling the Dynamic Link Libraries

(DLLs) of the update program.























Figure 5. The LeMans AD6900 Platform [25]

135

standardized Device Firmware Upgrade (DFU) protocol and
we discarded it from the analysis process since it is not
relevant for our security analysis.

The two relevant ﬁrmware ﬁles contain plenty of strings.
Based on these strings, we can make the educated guess
that
there are indeed two separate platforms combining
an ARM926EJ-S CPU and a Blackﬁn DSP, where both
processors share the same memory for their code and data.
The second ﬁle also contains string references related to
encryption, which lead us to focus on this part of the
whole ﬁrmware image. The ARM part of this ﬁle can
be disassembled using existing tools such as IDA Pro. In
contrast,
the memory mapping of the DSP code cannot
be inferred without additional efforts. However, a correct
mapping of the DSP code and data section is required for our
analysis since correct references in subroutine calls or string
references from within the code are crucial to disassemble
and understand the code.

Therefore, we reverse-engineered the very ﬁrst initializa-
tion routines in the Blackﬁn code, which turned out to hold
a DSP memory initialization routine that builds the DSP
code and data from the ﬁrmware image into another memory
region (presumably RAM). In the ﬁrmware image, the actual
DSP code and data regions are stored as multiple chunks of
data that are either uninitialized (i.e., ﬁlled with null bytes)
or initialized. Initialized blocks are repeated consecutively in
memory multiple times. The meta information for each data
chunk (i.e., chunk type, block length, etc.) is prepended as
a header. The ﬁrst chunk starts at a ﬁxed address and each
header also contains an offset to the next chunk in memory.
As no encryption or compression for the DSP code and
data is used within the ﬁrmware, the corresponding ﬁrmware
regions can be extracted directly. Using this information, we
were able to reconstruct the actual memory layout of the
DSP in RAM.

As there is no support for Blackﬁn assembler in IDA
Pro, we developed our own disassembler with the help of
the ofﬁcial Blackﬁn reference that disassembles the DSP
ﬁrmware image by following the program ﬂow using a
recursive traversal approach:

1) The disassembler performs a linear sweep over the

image to obtain target adresses of call instructions.

2) In a second step, the disassembler analyzes all adresses
identiﬁed in the ﬁrst step and starts to recursively
disassemble these locations by following the program
ﬂow. Each subsequent call and jump instruction is
taken and switch statements are resolved on-the-ﬂy.
By following this approach and assuming that no
obfuscation is used within the ﬁrmware image, we can
be sure that only code that is actually reachable by the
program ﬂow is interpreted as code.

3) In a third step, all gaps between valid code blocks
(i.e., functions) are disassembled recursively to obtain
functions that are accessed by indirect means.

Applying our custom disassembler on the reconstructed
DSP-image yielded more than 300,000 lines of assembler
code, where cross-references are also annotated. An example
of a disassembly is shown in the Appendix in Figure 11.
Due to the large amount of DSP code, an extensive manual
analysis is unfeasible in a reasonable amount of time. Hence,
we again applied the same heuristics used in the previous
analysis to spot cryptographic code, i.e., we searched for
subroutines holding a signiﬁcant percentage of mathematical
operations one would expect from an encryption algo-
rithm [1]–[3]. Unfortunately, this approach did not reveal any
code region that could be attributed to keystream generation.
This is explained by the fact that the DSP code also contains
plenty of demodulation and speech encoding algorithms that
naturally bear some resemblance to cryptographic algorithms
in that they make extensive use of mathematical operations.
Hence, we decided to follow another approach. The
Blackﬁn code contains a number of debug messages which
include the name of the source ﬁles of the respective
code. This allowed us to directly infer preliminary func-
tion names and to derive the purpose of several functions.
More speciﬁcally, we identiﬁed one subroutine where the
debug message contains a reference to a source ﬁle with
the name ..\..\modem\internal\Gmr2p_modem_
ApplyCipher.c. Hence, we named this function Apply-
Cipher() and we found out that it takes two 120-bit inputs
which are then xor’ed. Since we deal with cryptographic
code, we assumed that one of these parameters is the output
of a stream cipher because the lengths match the expected
frame size of 120 bits according to the GMR-2 speciﬁca-
tion [26]. Starting from this subroutine, we identiﬁed the
cipher code by applying a number of different techniques
that we explain in the following. All these techniques aim
at narrowing down the potentially relevant code base in
the disassembly. This is an essential and inevitable step in
the analysis process since the keystream generation code is
located in an entirely different part within the DSP code than
ApplyCipher().

First, we created the reverse call graph of the ApplyCi-
pher() function, i.e., we recursively identiﬁed all call sites
of this subroutine. Each call site is represented as a node
in the graph, and an edge from one node to another node
indicates that the destination node’s subroutine is called
from the source node’s subroutine. This process is repeated
until there is no caller left. Figure 6 depicts the reverse call
graph of ApplyCipher(), where root nodes (shown in grey)
constitute thread start routines. Subroutine names, if present,
were extracted from debug string within the corresponding
subroutine code. Accordingly, in a forward call graph, an
edge from one node to another indicates that the source
node’s subroutine calls the destination node’s subroutine.
The forward call graph is built recursively starting from a
given root node.

Our ﬁrst approach was to manually back track the data
ﬂow of the keystream parameter of ApplyCipher(). Unfortu-

136

-#+&+)%#-/

-#+&+)%&,#

-#+&+)%#-/

-#+&+)%#

-#+&+)%#

-#+&+)'"( %//

-#+&+)%#/#+ 

$-# *&+)%#-/

$(,%%('!&+)%#/

-#+&+)'"( %/

-#+&+)'"( %/'!!

&+)%#/

,. 

,. 

,.

-#+&+)&( &#',-

&+)# %%(

&+)&( &#',-

&+)&( &(

&+)&( &))%0$)# +

Figure 6. Reverse call graph of ApplyCipher() (the ten grey nodes are root nodes)

nately, this did not turn out to be promising since a myriad of
additional functions are being called in between the thread
creation and ApplyCipher(). We were only able to identify
a subroutine (denoted by us as CreateChannelInstance())
that allocates the memory region of the key data before
initializing it with zeros. However, we needed to ﬁnd the
piece of code that ﬁlls the keystream buffer with the actual
key data. Additional techniques were needed that enable us
to exclude those large portions of code that are irrelevant
for this purpose.

An analysis of the control ﬂow graphs of the thread start
routines (the nine grey nodes in Figure 6) suggests that
each routine implements a state machine using one switch
statement. By generating the forward call graph for each
case in the switch statement, we can derive which functions
are called in each corresponding state. Most notably, this
allows us to identify the points at which the keystream
buffer is created (by calling CreateChannelInstance()) and
the encryption of the plain text happens (by calling ApplyCi-
pher()). The code responsible for generating the keystream
naturally has to be called in between these two points.

The remaining code (approximately 140 subroutines) was
still too large for a manual analysis. In order to further
narrow down the relevant code parts, we created the forward
call graphs of all nine thread routines and computed the
intersection of all the nodes in the graphs. The idea behind
this approach is that in every case the stream cipher has
to be called eventually, regardless of the actual purpose of
the thread. The intersection greatly reduces the candidate
set of code regions from about 140 subroutines to only
13 functions shared by all threads (not including further
nested subroutine calls). In the last step, we analyzed these
remaining functions manually. At ﬁrst, this analysis revealed
the subroutine which encodes the TDMA-frame counters
into a 22-bit frame-number. Shortly after this function,
the actual cipher code is called. The algorithm itself, as
explained in the next section, is completely dissimilar to
A5/2, which also explains why we were not able to spot the
cipher with the same methods as in the analysis of GMR-1.

C. Structure of the Cipher

After having obtained the cipher’s assembler code, we had
to ﬁnd a more abstract description in order to enhance intu-
itive understanding of its way of functioning. We arbitrarily

chose to split the cipher into several distinct components
which emerged after examining its functionality. Note that,
for the sake of symmetry, we denote the cipher as A5-
GMR-2, althtough it shows no resemblance to any of the
A5-type ciphers and is called GMR-2-A5 in the respective
speciﬁcation [27].

The cipher uses a 64-bit encryption-key and operates on
bytes. When the cipher is clocked, it generates one byte of
keystream, which we denote by Zl, where l represents the
number of clockings. The cipher exhibits an eight byte state
register S = (S0, S1, . . . , S7)28 and three major components
we call F, G, and H. Additionally, there is a 1-bit register
T that outputs the so-called “toggle-bit”, and a 3-bit register
C that implements a counter. Figure 7 provides a schematic
overview of the cipher structure. In the following, we detail
the inner workings of each of the three major components.

















Figure 7. The A5-GMR-2 cipher

We begin with the F-component, which is certainly the
most interesting part of this cipher – Fig. 8 shows its internal
structure. On the left we see another 64-bit register split into

Figure 8. F-component of A5-GMR-2

137

x

T1(x)

T2(x)

T2(T1(x))

(0, 0, 0, 0)2
(0, 0, 0, 1)2
(0, 0, 1, 0)2
(0, 0, 1, 1)2
(0, 1, 0, 0)2
(0, 1, 0, 1)2
(0, 1, 1, 0)2
(0, 1, 1, 1)2
(1, 0, 0, 0)2
(1, 0, 0, 1)2
(1, 0, 1, 0)2
(1, 0, 1, 1)2
(1, 1, 0, 0)2
(1, 1, 0, 1)2
(1, 1, 1, 0)2
(1, 1, 1, 1)2

2
5
0
6
3
7
4
1
3
0
6
1
5
7
4
2

4
5
6
7
4
3
2
1
-
-
-
-
-
-
-
-

6
3
4
2
7
1
4
5
7
4
2
5
3
1
4
6

*

*

*

*

Table IV

T1 AND T2 AS LOOKUP-TABLE

eight bytes (K0, K1, . . . , K7)28. The register is read from
two sides, on the lower side one byte is extracted according
to the value of c, i.e., the output of the lower multiplexer
is Kc. The upper multiplexer outputs another byte, but this
one is determined by a 4-bit value we will call α. On the
right side, two smaller sub-components
T1 : {0, 1}4 (cid:2)→{0, 1}3
T2 : {0, 1}3 (cid:2)→{0, 1}3

are implemented via table-lookups (see Tab. IV). Also two
bit-wise modulo-2 additions are used. The input of T1 is
determined by p, Kc and the toggle-bit t. Note that we use
p = Zl−1 as a shorthand to denote one byte of keystream
that was already generated. We model the behavior of the
small vertical multiplexer by N (·), which we deﬁne as

N : {0, 1} × {0, 1}8 (cid:2)→{0, 1}4

(cid:8)

(t, x) (cid:2)→

(x3, x2, x1, x0)2
(x7, x6, x5, x4)2

if t = 0,
if t = 1.

With the help of N , which returns either the higher or lower
nibble of its second input, the following holds for the output
of the mentioned multiplexer

α = N (t, Kc ⊕ p) =N (c mod 2, Kc ⊕ p).

The output of the upper multiplexer is rotated to the right
by as many positions as indicated by the output of T2,
therefore the 8-bit output O0 and the 4-bit value O1 are
of the following form,

O0 = (KT1(α) ≫ T2(T1(α)))28
O1 = (Kc,7 ⊕ p7 ⊕ Kc,3 ⊕ p3,
Kc,6 ⊕ p6 ⊕ Kc,2 ⊕ p2,
Kc,5 ⊕ p5 ⊕ Kc,1 ⊕ p1,
Kc,4 ⊕ p4 ⊕ Kc,0 ⊕ p0)2.

Figure 9. G-component of A5-GMR-2

of the state is used as input. As can be seen in Figure 9,
three sub-components, denoted as B1, B2, B3, are employed
– again, they are implemented in the form of lookup-tables.
Each of these components works on 4-bit inputs and equally
returns 4-bit. After analyzing the tables, we found that all
three simply implement linear boolean arithmetic, i.e.,

B1 : {0, 1}4 (cid:2)→ {0, 1}4

x (cid:2)→ (x3 ⊕ x0, x3 ⊕ x2 ⊕ x0, x3, x1)2,

B2 : {0, 1}4 (cid:2)→ {0, 1}4

x (cid:2)→ (x1, x3, x0, x2)2,

B3 : {0, 1}4 (cid:2)→ {0, 1}4

x (cid:2)→ (x2, x0, x3 ⊕ x1 ⊕ x0, x3 ⊕ x0)2.

Since these sub-components and the modulo-2 addition are
linear and all other operations on single bits just amount to
permutations, the G-component is entirely linear. Therefore,
we can write the 6-bit outputs O(cid:2)
1 as linear functions of
the inputs I0, I1 and Sc, i.e.,

0, O(cid:2)

O(cid:2)

0 = (I0,7 ⊕ I0,4 ⊕ S0,5,

I0,7 ⊕ I0,6 ⊕ I0,4 ⊕ S0,7,
I0,7 ⊕ S0,4,
I0,5 ⊕ S0,6,
I1,3 ⊕ I1,1 ⊕ I1,0,
I1,3 ⊕ I1,0)2,

O(cid:2)

1 = (I0,3 ⊕ I0,0 ⊕ S0,1,

I0,3 ⊕ I0,2 ⊕ I0,0 ⊕ S0,3,
I0,3 ⊕ S0,0,
I0,1 ⊕ S0,2,
I1,2,
I1,0)2.

Finally, the H-component gets I (cid:2)

1 = O(cid:2)
1
as input and constitutes the non-linear “ﬁlter” of the cipher
(see Figure 10). Here, two new sub-components

0 = O(cid:2)

0 and I (cid:2)

The G-component gets the outputs of the F-component
as inputs, i.e., I0 = O0, I1 = O1. Additionally, one byte S0

S2 : {0, 1}6 (cid:2)→ {0, 1}4
S6 : {0, 1}6 (cid:2)→ {0, 1}4

138

are used and implemented via lookup-tables. Interestingly,
these tables were taken from the DES, i.e., S2 is the second
S-box and S6 represents the sixth S-box of DES. However,
in this cipher, the S-boxes have been reordered to account for
the different addressing, i.e., the four most-signiﬁcant bits
of the inputs to S2 and S6 select the S-box-column, the two
least-signiﬁcant bits select the row. Note that this is crucial
for the security of the cipher. The inputs to the S-boxes are

denote the l-th (l ≥ 8) byte of keystream generated after
initialization with frame-number N. In GMR-2, the frame-
number is always incremented after 15 byte of keystream,
which forces a re-initialization of the cipher. Therefore, the
keystream Z (cid:2) that is actually used for N ∈ {0, 1, 2 . . . } is
made up of blocks of 15 bytes (which we call a key-frame
with respect to frame-number N) that are concatenated as
follows:

Figure 10. H-component of A5-GMR-2

swapped with the help of two multiplexers, depending on
1, and t we can express
the value of t. Given the inputs I (cid:2)
the l-th byte of keystream as

0, I (cid:2)

(cid:8)

Zl =

(S2(I (cid:2)
(S2(I (cid:2)

1), S6(I (cid:2)
0), S6(I (cid:2)

0))24
1))24

if t = 0,
if t = 1.

D. Mode of Operation

Next we describe the mode of operation. When the cipher

is clocked for the l-th time, the following happens:

1) Based on the current state of the S-, C-, and T -
register, the cipher generates one byte Zl of keystream.
2) The T -register is toggled, i.e., if it was 1 previously,

it is set to 0 and vice versa.

3) The C-register is incremented by one, when 8 is

reached the register is reset to 0.

4) The S-register is shifted by 8 bits to the right, i.e.,
S7 := S6, S6 := S5 etc. The previous value of S7 is
fed into the G-component, the subsequent output Zl of
H is written back to S0, i.e., S0 := Zl. This value is
also passed to the F-component as input for the next
iteration.

The cipher is operated in two modes, initialization and
generation. In the initialization phase, the following steps
are performed:

1) The T - and C-register are set to 0.
2) The 64-bit encryption-key is written into the K-

register in the F-component.

3) The state-register S is initialized with the 22-bit frame-
number N, this procedure is dependent on the “direc-
tion bit” but not detailed here as it is irrelevant for the
remainder of this paper.

After C, T and S have been initialized, the cipher is clocked
eight times, but the resulting keystream is discarded.

After initialization is done,

generate and output actual keystream bytes. By Z (N )

the cipher is clocked to
we

l

Z (cid:2) = (Z (0)

8 , . . . , Z (0)

22 , Z (1)

8 , . . . , Z (1)

22 , Z (2)

8 , . . . , Z (2)

22 , . . . )28

E. Cryptanalysis

In this section, we present a known-plaintext attack that
is based on several observations that can be made when
carefully examining the F-component (and the starred rows
in Tab. IV):

1) If α ∈ {(0, 0, 1, 0)2, (1, 0, 0, 1)2} then T1(α) = 0 and
T2(T1(α)) = 4, thus O0 = (N (0, K0), N (1, K0))24.
2) If α ∈ {(0, 1, 1, 0)2, (1, 1, 1, 0)2} then T1(α) = 4 and
T2(T1(α)) = 4, thus O0 = (N (0, K4), N (1, K4))24.
3) If T1(α) = c, both multiplexers select the same key-

byte. We call this a read-collision in Kc.

In the following, we describe how to obtain K0 and K4 with
high probability, which is then leveraged in a second step
in order to guess the remaining 48 bits of K in an efﬁcient
way.

i−1, Z (cid:2)

The key idea to derive K0 is to examine keystream bytes
i−8)28 with i ∈ {8, 23, 38, . . . } in order to
i, Z (cid:2)
(Z (cid:2)
detect when a read-collision in K0 has happened during the
i. Please note that due to our choice of i this
generation of Z (cid:2)

8 = Z (0)
Z (cid:2)

16 , Z (cid:2)

23 = Z (1)

16 , Z (cid:2)

38 = Z (2)

16 , . . .

i.e, for each i we already know that

the lower
holds,
multiplexer has selected K0. In general, if the desired read-
collision has happened in the F-component, the outputs of
the F-component are

O0 = (p3 ⊕ α3, p2 ⊕ α2, p1 ⊕ α1, p0 ⊕ α0,

K0,7, K0,6, K0,5, K0,4)2,

O1 = (K0,7 ⊕ p7 ⊕ α3, K0,6 ⊕ p6 ⊕ α2,

K0,5 ⊕ p5 ⊕ α1, K0,4 ⊕ p4 ⊕ α0)2,

and the subsequent outputs of G are

O(cid:2)

0 = (p3 ⊕ α3 ⊕ p0 ⊕ α0 ⊕ S0,5,

p3 ⊕ α3 ⊕ p2 ⊕ α2 ⊕ p0 ⊕ α0 ⊕ S0,7,
p3 ⊕ α3 ⊕ S0,4,
p1 ⊕ α1 ⊕ S0,6,
K0,7 ⊕ p7 ⊕ α3 ⊕ K0,5 ⊕ p5 ⊕ α1 ⊕ K0,4 ⊕ p4 ⊕ α0,
K0,7 ⊕ p7 ⊕ α3 ⊕ K0,4 ⊕ p4 ⊕ α0)2,

139

O(cid:2)

1 = (K0,7 ⊕ K0,4 ⊕ S0,1,

K0,7 ⊕ K0,6 ⊕ K0,4 ⊕ S0,3,
K0,7 ⊕ S0,0
K0,5 ⊕ S0,2,
K0,6 ⊕ p6 ⊕ α2,
K0,4 ⊕ p4 ⊕ α0)2.

Considering the H-component, we also know that

Z (cid:2)

i = (S2(O(cid:2)

1), S6(O(cid:2)

0))24

holds.

In order to determine K0, we examine the inputs and
outputs of S6 and S2 in the H-component, starting with S6.
Due to the reordering of the DES S-boxes, the column of
S6 is selected by the four most-signiﬁcant bits of O(cid:2)
0. If we
assume a collision in K0 has happened while generating Z (cid:2)
i,
we can compute these most-signiﬁcant bits due to the fact
that

S0

!= Z (cid:2)

and p != Z (cid:2)

i−1

i−8

from the rest. Experiments show that about a dozen key-
frames are usually enough so that the correct key-byte is
among the ﬁrst two hypotheses. The principle we outlined
above not only works for K0, it also allows to recover
the value of K4 when α ∈ {(0, 1, 1, 0)2, (1, 1, 1, 0)2},
i ∈ {12, 27, 42, . . . } are chosen appropriately.

In the following we assume that we have obtained a set
of hypotheses for K0 – we might also have K4, but this
improves the efﬁciency of the remainder of the attack only
slightly. Based on theses hypotheses, starting with the most
plausible one, we can brute-force the remaining key-bytes
separately. Please note that the following process will only
produce the correct key, if our hypothesis for K0 was correct.
To obtain K1, ..., K7 we examine a few keystream-bytes
for a second time, while focusing on the F-component.
For each Kj with j ∈ {0, 1, . . . , 7} for which we already
have a hypothesis, we can use the corresponding key-stream
i+j−8)28 with i ∈ {8, 23, 38, . . . } to
bytes (Z (cid:2)
compute

i+j−1, Z (cid:2)

i+j, Z (cid:2)

α = N (j mod 2, Kj ⊕ Z (cid:2)

i+j−1).

are also known for all of our choices of i. If, for α ∈
{(0, 0, 1, 0)2, (1, 0, 0, 1)2} the lower nibble of Z (cid:2)
i is found in
the row with index β, a collision may indeed have happened
0 must be (β1, β0)2, which
and the lower two bits of O(cid:2)
implies
K0,7 ⊕ K0,5 ⊕ K0,4 = β1 ⊕ p7 ⊕ α3 ⊕ p5 ⊕ α1 ⊕ p4 ⊕ α0,

K0,7 ⊕ K0,4 = β0 ⊕ p7 ⊕ α3 ⊕ p4 ⊕ α0.

Here we gain “some” information about the bits of K0, K0,5
can even be computed. We can then use the output of S2 to
verify whether a collision has happened for the particular α
we used above. Due to the structure of the S-box, there are
only four 6-bit inputs γ with

S2(γ) = (Z (cid:2)

i,7, Z (cid:2)

i,6, Z (cid:2)

i,5, Z (cid:2)

i,4)2.

Due to our partial knowledge about (K0,4, K0,5, K0,7)2 we
can test each γ whether the following relations hold:

γ5

γ3 ⊕ γ0

γ4 ⊕ γ1

?=β0 ⊕ p7 ⊕ α3 ⊕ p4 ⊕ α0 ⊕ S0,1,
?=β0 ⊕ p7 ⊕ α3 ⊕ p4 ⊕ α0 ⊕ S0,3 ⊕ p6 ⊕ α2,
?=β0 ⊕ p7 ⊕ α3 ⊕ S0,0,
?=β1 ⊕ p7 ⊕ α3 ⊕ p5 ⊕ α1 ⊕ p4 ⊕ α0 ⊕ S0,1 ⊕ S0,2.
γ2 ⊕ γ5
If all of these relations hold for one γ, we can be sure with
sufﬁciently high probability that a read-collision has indeed
happened. A probable hypothesis for K0 is now given by

(γ3 ⊕ S0,0, γ1 ⊕ p6 ⊕ α2, γ2 ⊕ S0,2, γ0 ⊕ p4 ⊕ α0,
p3 ⊕ α3, p2 ⊕ α2, p1 ⊕ α1, p0 ⊕ α0)2.

Our method detects all read-collisions, but there may also be
false positives, therefore the process described above must
be iterated for a few times for different portions of the
keystream. Typically, over time, one or two hypotheses occur
more often than others and distinguish themselves quite fast

140

If we do not already have a plausible hypothesis for Kk
with k = T1(α), we can simply try out all possible values
δ ∈ {0, 1, . . . , 255} and compute the output of the cipher.
If we ﬁnd for one value that the output equals Z (cid:2)
i+j we
keep δ as hypothesis for Kk. This can be repeated for a
few different i until a hypothesis for the full key has been
recovered. Since the validity of the full hypothesis solely
depends on the correctness of K0, we must verify each key
candidate by generating and comparing keystream.

The overall complexity of this attack depends on how
many hypotheses for K0 are used to derive the remaining
key. Given 15-20 key-frames, the correct byte for K0 is
usually ranked as best hypothesis so deriving the complete
key means testing

(7 · 28)/2 ≈ 210

single byte hypotheses for the missing bytes (on average).
Clearly, a keystream/time trade-off is possible: The more
key-frames are available to test hypotheses for K0, the more
the right hypothesis distinguishes itself from all others. As
a matter of fact, the most extreme trade-off is simply trying
all 28 possible values for K0 (without even ranking them),
which reduces the required amount of known keystream to
about 400–500 bits but increases the computational com-
plexity to

(7 · 28 · 28)/2 ≈ 218

guesses on average.

VI. CONCLUSION AND IMPLICATIONS

Despite a large body of work related to the security
aspects of the GSM, and to a lesser extend, the UMTS
system, there had been no scientiﬁc or other publicly avail-
able investigation of the security mechanisms employed by
the two existing satphone standards, GMR-1 and GMR-2.

Contrary to the practice recommended in modern security
engineering, both standards rely on proprietary algorithms
for (voice) encryption. Even though it is impossible for
outsiders (like us) to decide whether this is due to historic
developments or because secret algorithms were believed
to provide a higher level of “security”,
the ﬁndings of
our work are not encouraging from a security point of
view. GMR-1 relies on a variant of the GSM cipher A5/2,
for which serious weakness have been demonstrated for
more than a decade. The GMR-2 cipher, which appears
to be an entirely new stream cipher, shows even more
serious cryptographic weaknesses. In the case of GMR-1, an
attacker can mount a successful ciphertext-only attack. With
respect to the GMR-2 cipher, in a known-plaintext setting
where approximately 50–65 bytes plaintext are known to
the attacker, it is possible to recover a session key with
a moderate computational complexity, allowing the attack
to be easily performed with a current PC. Both algorithms
are cryptographically dramatically weaker than would be
possible with state-of-the-art ciphers, e.g., AES. Even if AES
is considered too “heavy” for realtime encryption on mobile
phones, the Phase 2 eSTREAM ﬁnalist stream ciphers [28]
or lightweight block ciphers such as PRESENT [29], provide
considerably better cryptographic protection.

The cipher code inside the ﬁrmware was not speciﬁcally
protected against reverse-engineering efforts. The difﬁculty
in reconstructing both algorithms thus stems from the in-
herent complexity in analyzing large pieces of code. If
software engineers had employed state-of-the art obfuscation
schemes, the analysis could have been at least complicated
signiﬁcantly. Furthermore, implementing the ciphers in hard-
ware would also hamper reverse-engineering.

In this paper, we do not address the issue of obtaining
ciphertext or plaintext data. However, follow-up work on
GMR-1 has done this, executing the attack on GMR-1 and
revealing the session key with moderate effort [30]. This
clearly demonstrates the impact and validity of our analysis.

ACKNOWLEDGMENT

We would like to thank Sylvain Munaut from the Osmo-
comGMR project [31] for verifying the reconstructed A5-
GMR-1 cipher with real-world data.

This work has been supported by the Ministry of Eco-
nomic Affairs and Energy of the State of North Rhine-
Westphalia (Grant IV.5-43-02/2-005-WFBO-009).

REFERENCES

[1] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace,
“ReFormat: Automatic Reverse Engineering of Encrypted
Messages,” in European Symposium on Research in Computer
Security (ESORICS), 2009.

[2] J. Caballero, P. Poosankam, C. Kreibich, and D. Song, “Dis-
patcher: Enabling Active Botnet Inﬁltration using Automatic
Protocol Reverse-Engineering,” in ACM Conference on Com-
puter and Communications Security (CCS), 2009.

[3] F. Gröbert, C. Willems, and T. Holz, “Automated Identi-
ﬁcation of Cryptographic Primitives in Binary Programs,”
in Symposium on Recent Advances in Intrusion Detection
(RAID), 2011.

[4] D. Wright, “Reaching out to remote and rural areas: Mobile
satellite services and the role of Inmarsat,” Telecommunica-
tions Policy, vol. 19, no. 2, pp. 105 – 116, 1995.

[5] D. Matolak, A. Noerpel, R. Goodings, D. Staay, and J. Bal-
dasano, “Recent progress in deployment and standardization
of geostationary mobile satellite systems,” in Military Com-
munications Conference (MILCOM), 2002.

[6] ETSI, ETSI TS 101 376-3-2 V1.1.1 (2001-03); GEO-Mobile
Radio Interface Speciﬁcations; Part 3: Network speciﬁca-
tions; Sub-part 2: Network Architecture; GMR-1 03.002, Std.,
2001.

[7] G. Maral and M. Bousquet, Satellite Communications Sys-
John

tems: Systems, Techniques and Technology, 5th ed.
Wiley & Sons, 2009.

[8] Jim Geovedi and Raoul Chiesa, “Hacking a Bird in the Sky,”

in HITBSecConf, Amsterdam, 2011.

[9] ETSI, ETSI TS 101 376-3-9 V1.1.1 (2001-03); GEO-Mobile
Radio Interface Speciﬁcations; Part 3: Network speciﬁca-
tions; Sub-part 9: Security related Network Functions; GMR-
1 03.020, Std., 2001.

[10] H. Welte, “Anatomy of contemporary GSM cellphone
http://laforge.

hardware,”
gnumonks.org/papers/gsm_phone-anatomy-latest.pdf

2010.

[Online]. Available:

[11] M. Briceno, I. Goldberg, and D. Wagner, “A pedagog-
ical
implementation of the GSM A5/1 and A5/2 “voice
privacy” encryption algorithms,” 1999, originally pub-
lished at http://www.scard.org, mirror at http://cryptome.org/
gsm-a512.htm.

[12] J. D. Golic, “Cryptanalysis of alleged A5 stream cipher,”
in Proceedings of the 16th annual international conference
on Theory and application of cryptographic techniques, ser.
EUROCRYPT’97. Springer-Verlag, 1997, pp. 239–255.

[13] S. Petrovic and A. Fuster-Sabater, “Cryptanalysis of the A5/2
Algorithm,” Cryptology ePrint Archive, Report 2000/052,
Tech. Rep., 2000, http://eprint.iacr.org/.

[14] E. Biham and O. Dunkelman, “Cryptanalysis of the A5/1

GSM Stream Cipher,” in Indocrypt, 2000.

[15] A. Biryukov, A. Shamir, and D. Wagner, “Real Time Crypt-
analysis of A5/1 on a PC,” in Fast Software Encryption (FSE),
2000.

[16] P. Ekdahl and T. Johansson, “Another Attack on A5/1,” IEEE

Transactions on Information Theory, vol. 49, no. 1, 2003.

[17] A. Bogdanov, T. Eisenbarth, and A. Rupp, “A Hardware-
Assisted Realtime Attack on A5/2 Without Precomputations,”
in Cryptographic Hardware and Embedded Systems (CHES),
2007.

[18] E. Barkan, E. Biham, and N. Keller, “Instant Ciphertext-Only
Cryptanalysis of GSM Encrypted Communication,” Journal
of Cryptology, vol. 21, March 2008.

141

[19] K. Nohl and C. Paget, “GSM: SRSLY?” 2009, 26th Chaos

Communication Congress.

[20] O. Dunkelman, N. Keller, and A. Shamir, “A Practical-
Time Related-Key Attack on the KASUMI Cryptosystem
Used in GSM and 3G Telephony,” in International Crytology
Conference (CRYPTO), 2010.

[21] OsmocomGMR. Thuraya SO-2510.

[Online]. Available:

http://gmr.osmocom.org/trac/wiki/Thuraya_SO2510

[22] Texas Instruments. The OMAP 5910 Platform. [Online].

Available: http://www.ti.com/product/omap5910

[23] E. Barkan, E. Biham, and N. Keller, “Instant Ciphertext-
Only Cryptanalysis of GSM encrypted communication,” in
International Crytology Conference (CRYPTO), 2003, pp.
600–616.

sub_20000000: x-refs 204fe02c

20000000 LINK 0x18;
20000004 [--SP] = (R7:6, P5:3);
20000006 P5 = R1;
20000008 P4 = R0;
2000000a P0.L = 0x2034;
2000000e P0.H = 0x2046;
20000012 R2.L = 0x7410;
20000016 R2.H = 0x2054;
2000001a SP += -0x24;
2000001c R0 = 0x4a8 (X);
20000020 R1 = B[P0] (Z);
20000022 [SP + 0xc] = P0;
20000024 P1.L = 0x6010;
20000028 P1.H = 0xc000;
2000002c CALL (P1);
2000002e P3 = R0;
20000030 CC = R0 == 0x0;
20000032 R0 = 0x1 (X);
20000034 IF CC JUMP 0x2000015c;
...

/* P0=0x00002034 */
/* @P0=hex:0x00000001 */
/* R2=0x00007410 */
/* @R2=str:’pDecTemp0’ */

/* R0=0x000004a8 */

/* P1=0x00006010 */
/* P1=0xc0006010 */

[24] ETSI, ETSI TS 101 376-5-3 V1.2.1 (2002-04); GEO-Mobile
Radio Interface Speciﬁcations; Part 5: Radio interface physi-
cal layer speciﬁcations; Sub-part 3: Channel Coding; GMR-1
05.003, Std., 2002.

loc_2000015c: x-refs 20000034

2000015c SP += 0x24;
2000015e (R7:6, P5:3) = [SP++];
20000160 UNLINK;
20000164 RTS;

Figure 11. Example for disassembly of Blackﬁn code

B. DSP Code of Feedback Register Shift Subroutine

ROM:1D038 update_reg3:
ROM:1D038
ROM:1D03D
ROM:1D040
ROM:1D045
ROM:1D047
ROM:1D04B
ROM:1D04E
ROM:1D051
ROM:1D053
ROM:1D055
ROM:1D058
ROM:1D05A
ROM:1D05F

mov
sftl
mov
xor
bfxtr
and
and
xor
xor
sftl
xor
mov
ret

dbl(*abs16(#reg3)), AC1
AC1, #-1, AC2
dbl(*abs16(#reg3)), AC1
AC2, AC1
#0FFF0h, AC1, AR1
#1, AR1, AC3
#1, AC1, AC1
AC3, AC1
AC0, AC1
AC1, #22, AC0
AC2, AC0
AC0, dbl(*abs16(#reg3))

Figure 12. DSP code of a feedback register shift subroutine

Figure 12 depicts the TMS320C55x DSP code of one of
the feedback register shift subroutines. Note that the subrou-
tine and variable names were inserted by us afterwards and
are not present in the binary.

[25] Jose

Fridman, Analog Devices. How to

optimize
H.264 video decode on a digital baseband proces-
sor.
[Online]. Available: http://www.eetimes.com/General/
DisplayPrintViewContent?contentItemId=4016202

[26] ETSI, ETSI TS 101 377-5-3 V1.1.1 (2001-03); GEO-Mobile
Radio Interface Speciﬁcations; Part 5: Radio interface physi-
cal layer speciﬁcations; Sub-part 3: Channel Coding; GMR-2
05.003, Std., 2001.

[27] ——, ETSI TS 101 377-3-10 V1.1.1 (2001-03); GEO-Mobile
Radio Interface Speciﬁcations; Part 3: Network speciﬁca-
tions; Sub-part 9: Security related Network Functions; GMR-
2 03.020, Std., 2001.

[28] M. Robshaw and O. Billet, Eds., New Stream Cipher Designs:
Springer, 2008, vol.

The eSTREAM Finalists, ser. LNCS.
4986.

[29] A. Bogdanov, G. Leander, L. R. Knudsen, C. Paar,
A. Poschmann, M. J. Robshaw, Y. Seurin, and C. Vikkelsoe,
“PRESENT—An Ultra-Lightweight Block Cipher,” in CHES
’07: Proceedings of the 9th International Workshop on Cryp-
tographic Hardware and Embedded Systems, ser. LNCS, no.
4727. Springer, 2007, pp. 450–466.

[30] B. Driessen, “Eavesdropping on Satellite Telecommunication
Systems,” Cryptology ePrint Archive, Report 2012/051, 2012,
http://eprint.iacr.org/2012/051.

[31] S. Munaut. (2012, Jan.) OsmocomGMR. [Online]. Available:

http://gmr.osmocom.org/

A. Disassembly of Blackﬁn Code

APPENDIX

Figure 11 shows an excerpt from the output of our
Blackﬁn disassembler. As can be seen, cross-references
(i.e., who calls a function or where a jump originates)
are annotated. Additionally,
if a register is loaded with
an address which points to a memory location which is
within the ﬁrmware image, the disassembler also reads and
interprets the respective data.

142

