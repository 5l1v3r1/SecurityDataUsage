Fix Me Up: Repairing Access-Control Bugs in Web Applications

Sooel Son†

Kathryn S. McKinley†∗

Vitaly Shmatikov†

†The University of Texas at Austin

∗Microsoft Research

{samuel,mckinley,shmat}@cs.utexas.edu

Abstract

Access-control policies in Web applications ensure that
only authorized users can perform security-sensitive oper-
ations. These policies usually check user credentials be-
fore executing actions such as writing to the database or
navigating to privileged pages. Typically, every Web ap-
plication uses its own, hand-crafted program logic to en-
force access control. Within a single application, this logic
can vary between different user roles, e.g., administrator
or regular user. Unfortunately, developers forget to include
proper access-control checks, a lot.

This paper presents the design and implementation of
FIXMEUP, a static analysis and transformation tool that
ﬁnds access-control errors of omission and produces can-
didate repairs. FIXMEUP starts with a high-level speciﬁ-
cation that indicates the conditional statement of a correct
access-control check and automatically computes an inter-
procedural access-control template (ACT), which includes
all program statements involved in this instance of access-
control logic. The ACT serves as both a low-level policy
speciﬁcation and a program transformation template. FIX-
MEUP uses the ACT to ﬁnd faulty access-control logic that
misses some or all of these statements, inserts only the miss-
ing statements, and ensures that unintended dependences
did not change the meaning of the access-control policy.
FIXMEUP then presents the transformed program to the de-
veloper, who decides whether to accept the proposed repair.
Our evaluation on ten real-world PHP applications
shows that FIXMEUP is capable of ﬁnding subtle access-
control bugs and performing semantically correct repairs.

Introduction

1
Modern Web-based software, such as e-commerce appli-
cations, blogs, and wikis, typically consists of client-side
scripts running in a Web browser and a server-side program
that (1) converts clients’ requests into queries to a back-
end database and (2) returns HTML content. Because any
Internet user can invoke the server, application developers
must ensure that unauthorized users cannot reach database

queries, administrator functionality, pages with conﬁdential
or paid content, and other privileged operations.

Developers usually program access-control logic from
scratch because there is no standard framework for imple-
menting access control in Web applications. Access-control
logic is often fairly sophisticated, spread over multiple func-
tions, with different checks performed for different user
roles [32, 36]. The scripting language of choice for server-
side applications is PHP [27, 28]. In PHP, a network user
can directly invoke any program ﬁle by providing its name
as part of a URL. This feature introduces unintended entry
points into programs and permits “forced browsing,” where
a user navigates to pages without following the intended
pattern and therefore bypasses access-control checks. As a
consequence, incorrectly implemented access-control vul-
nerabilities occur prominently in the OWASP Top 10 Ap-
plication Security Risks [24]. For example, all but one of
the ten real-world PHP applications analyzed in this paper
contain access-control vulnerabilities.

Whereas ﬁnding bugs is now a mature area, repairing
them is a much harder problem and only recently has some
progress been made on semi-automated methods for soft-
ware repair. Static repair techniques can now ﬁx viola-
tions of simple local patterns that need only one- or two-
line edits [14, 25], or ﬁnd one- or two-line changes that
pass unit tests [41], or perform user-speciﬁed transforma-
tions within a single method [1, 19]. None of these tech-
niques address interprocedural bugs. Several recent meth-
ods ﬁnd access-control bugs using interprocedural analy-
sis [32, 36] but how to repair them has been an open prob-
lem. A key issue for repairing these bugs is that many, but
not all of the statements implementing the access-control
logic are often already present in the vulnerable code. None
of the prior patch, transformation, refactoring, or repair al-
gorithms check if the statements are already present in the
target of transformation.

We design and implement a static analysis and program
transformation tool called FIXMEUP. FIXMEUP ﬁnds vi-
olations of access-control policies, produces candidate re-
pairs, eliminates repairs that incorrectly implement the pol-
icy, and suggests the remaining repairs to developers.

As input, FIXMEUP takes an access-control check, i.e.,
a conditional statement that determines whether or not
some security-sensitive operation executes. These checks,
marked by the developer or inferred by static analysis [32],
serve as the high-level speciﬁcation of the access-control
policy. Our analysis computes interprocedural control and
data dependences of the check, extracting an interproce-
dural slice containing all program statements that imple-
ment the access-control logic. FIXMEUP creates an access-
control template (ACT) from these statements. The ACT
serves both as a low-level policy speciﬁcation and a pro-
gram transformation template. FIXMEUP then uses the
ACT to (1) ﬁnd security-sensitive operations not protected
by appropriate access-control logic; (2) transform the pro-
gram by inserting only the missing logic into the vulner-
able calling contexts, while preserving the statements and
dependences already present; and (3) verify the transforma-
tion did not accidentally introduce unwanted dependences,
changing the semantics of the inserted policy.

We evaluate FIXMEUP on ten real-world Web appli-
cations varying in size from 1,500 to 100,000+ lines of
PHP code. We chose these benchmarks because (i) prior
work used them to specify and/or infer access-control poli-
cies [32, 36]; (ii) they contain known access-control bugs
that FIXMEUP ﬁnds and repairs; and (iii) they demonstrate
the scalability of FIXMEUP.

FIXMEUP found 38 access-control bugs and correctly
repaired 30 of them. We conﬁrmed all bugs and repairs by
hand and with experimental testing on attack inputs. In par-
ticular, FIXMEUP found and repaired 5 bugs in two bench-
marks that prior analysis of the same code missed [36]. In
7 cases, the inserted access-control check was added to an
existing, alternative check.
In one case, our repair vali-
dation procedure automatically detected an unwanted con-
trol dependence and issued a warning. In 28 cases, FIX-
MEUP detected that vulnerable code already contained one
or more, but not all, of the statements prescribed by the
access-control template and adjusted the repair accordingly.
This result shows that detecting which parts of the access-
control logic are already present and correct is critical to re-
pairing access-control vulnerabilities. No prior program re-
pair or transformation approach detects whether the desired
logic is already present in the program [1, 14, 19, 25, 41].

FIXMEUP guarantees that the repaired code implements
the same access-control policy as the template, but it cannot
guarantee that the resulting program is “correct.” For ex-
ample, FIXMEUP may apply the policy to a context where
the developer did not intend to use it, or the repair may in-
troduce an unwanted dependence into the program (adding
an access-control check always changes the program’s con-
trol ﬂow). Static analysis in FIXMEUP is neither sound,
nor complete because it does not consider language features
such as dynamic class loading, some external side effects,

or eval. The developer should examine the errors found by
FIXMEUP and the suggested repairs.

Using automated program analysis tools for veriﬁcation
and bug ﬁnding is now a well-established approach that
helps programmers discover errors and improve code qual-
ity in large software systems. No prior tool, however, can
repair access-control errors of omission. These errors may
appear relatively simple, but our analysis shows that they
are common in Web applications. FIXMEUP is a new tool
that can help Web developers repair common access-control
vulnerabilities in their applications.

2 Overview of our approach
FIXMEUP starts with a high-level speciﬁcation of the
access-control policy. A policy prescribes one or more
access-control checks on execution paths leading to sensi-
tive operations, such as database queries, links to privileged
pages, operations that rewrite cookies and delete ﬁles. Sen-
sitive operations must be speciﬁed in advance. If the checks
fail, the program does not execute the sensitive operations.
Because access-control logic varies between different user
roles and entry points within the same application [32, 36],
different paths may require different checks or no checks at
all. Access-control logic in Web applications is often inter-
procedural and context-sensitive.

FIXMEUP is agnostic about the source of the policy and
works equally well with user-speciﬁed policies and with
policies inferred by program analysis. Our focus in this pa-
per is on program repair and not on the orthogonal problem
of policy speciﬁcation or inference.

For simplicity, assume that the high-level policy is speci-
ﬁed explicitly by the developer who adds annotations to the
PHP source code marking (1) access-control checks, (2) the
protected sensitive operation, and (3) a tag indicating the
user role to which the policy applies (e.g., root, admin, or
blog poster). Section 3 presents examples of speciﬁcations
and policies. FIXMEUP assumes that each high-level pol-
icy applies throughout the indicated user role.

FIXMEUP uses this speciﬁcation to compute an access-
control template (ACT). FIXMEUP starts with the con-
ditional statement performing the correct access-control
check and computes all methods and statements in its back-
ward, interprocedural slice. Given this slice, FIXMEUP
builds an interprocedural, hierarchical representation of all
statements in the check’s calling context on which the check
depends. The ACT is both a low-level policy speciﬁcation
and a program transformation template.

To ﬁnd missing access-control checks, FIXMEUP looks
at every calling context in which a sensitive operation may
be executed and veriﬁes whether the access-control logic
present in this context matches the ACT for the correspond-
ing role. Of course, FIXMEUP cannot decide general se-
mantic equivalence of arbitrary code fragments. In practice,

the access-control logic of Web applications is usually very
stylized and located close to the program entry points. The
resulting templates are loop-free, consist of relatively few
statements, and have simple control and data dependences
(see Table 2). A few statements may have side effects on the
global variables, such as opening database connections and
initializing session state. For example, a typical Web appli-
cation may open the database once and then permit only the
authorized users to store into the database; these stores may
be sprinkled throughout the application.

FIXMEUP generates candidate repairs by replicating the
access-control logic in program contexts where some or all
of it is missing.
If FIXMEUP ﬁnds a vulnerable context
that permits execution of some sensitive operation with-
out an access-control check, it transforms the context using
the access-control template. This transformation ﬁnds and
reuses statements already present in the vulnerable code and
only inserts the statements from the template that are miss-
ing. The repair procedure uses and respects all control and
data dependences between statements.

To ensure that the reused statements do not change the
meaning of the inserted policy, FIXMEUP computes a fresh
template starting from the access-control check and matches
If the templates do not
it against the original template.
match, FIXMEUP issues a warning.
If they match, FIX-
MEUP provides the transformed code to the developer as
the suggested repair.
3 Access-Control Policies
Access control is the cornerstone of Web-application secu-
rity. Several of the OWASP Top 10 Application Security
Risks [24] are access-control bugs: broken authentication
and session management, insecure direct object references,
and failure to restrict URL accesses. Access-control bugs
can expose other types of vulnerabilities, too.
3.1 Examples of correct policies and bugs
In general, an access-control policy requires some checks
prior to executing security-sensitive operations. Web appli-
cations frequently implement multiple user roles. For ex-
ample, an online store may have customers and administra-
tors, while a blogging site may have blog owners, publish-
ers, and commenters. Access-control policies are thus role-
sensitive. Different calling contexts associated with differ-
ent user roles often require different checks.

Figures 1 and 2 show examples of access-control checks
in real-world PHP applications. Figure 1 shows a correct
check (line 4) in Add.php from minibloggie. Add.php in-
vokes a dedicated verifyuser function that queries the user
database with the username and password. If veriﬁcation
fails, the application returns the user to the login page.
Figure 2 shows a correct check (line 3) performed by Ac-
ceptBid.php in the DNscript application. It reads the hash
table containing the session state and checks the member

Add.php

s e s s i o n s t a r t ( ) ;

1 <? . . .
2
3 dbConnect ( ) ;
4
5

( ! v e r i f y u s e r ( )

header ( ” L o c a t i o n :

i f
6 }

) { / / a c c e s s−c o n t r o l c h e c k

. / l o g i n . php ” ) ;

. . .

s e c u r i t y −s e n s i t i v e o p e r a t i o n
7
8 $ s q l = ”INSERT INTO b l o g d a t a SET u s e r

/ /

i d = ’ $ i d ’ ,

s u b j e c t = ’ $ s u b j e c t ’ , message = ’ $message ’ , d a t e t i m e
= ’ $ d a t e t i m e ’ ” ;

. . .
f u n c t i o n v e r i f y u s e r ( ) {

9 $query = mysql query ( $ s q l ) ;
10
11
12
13
14
15

. . . .
s e s s i o n s t a r t ( ) ;
g l o b a l $user , $pwd ;
i f

pwd ’ ] ) ) {

( i s s e t ( $ SESSION [ ’ u s e r ’ ] ) && i s s e t ( $ SESSION [ ’

$ u s e r = $ SESSION [ ’ u s e r ’ ]
$pwd
= $ SESSION [ ’pwd ’ ]
$ r e s u l t = mysql query ( ”SELECT u s e r , password
FROM b l o g u s e r n a m e WHERE u s e r = ’ $ u s e r ’ AND
BINARY password = ’$pwd ’ ” ) ;

;

;

i f ( mysql num rows ( $ r e s u l t

) == 1 )

r e t u r n true ;

}
r e t u r n f a l s e ;

16
17
18

19
20
21
22

23 }
24 ?>

Figure 1: minibloggie: Access-control check

ﬂag. Both access-control policies protect the same oper-
ation—a mysql query call site that updates the back-end
database—but with very different logic.

The access-control checks are role-speciﬁc. For exam-
ple, the DNscript application has two roles. Figure 2 shows
the check for the “regular user” role and Figure 3 shows the
check for the “administrator” role.

DelCb.php in Figure 2 shows an access-control bug in
the DNscript application: the check on $ SESSION for
the “regular user” role is present in AcceptBid.php, but
missing in DelCb.php. The developer either forgot the
check or did not realize that any network user can directly
invoke DelCb.php. The bottom of Figure 2 shows how FIX-
MEUP repairs DelCb.php by replicating the correct access-
control logic from AcceptBid.php (associated with the “reg-
ular user” role). Similarly, Figure 3 shows how FIXMEUP
repairs an access-control bug in AddCat2.php (associated
with the “administrator” role) by replicating the access-
control check from Del.php.

Invalid control ﬂow distinguishes access-control vulner-
abilities from data-ﬂow vulnerabilities, such as cross-site
scripting and SQL injection studied in prior work [13, 15,
17, 39, 42]. The access-control policy determines if the user
is authorized to perform a particular operation, regardless
of whether or not there are tainted data ﬂows into the argu-
ments of the operation.
3.2 Design patterns for access control
There is no standard access-control library or framework for
Web applications, thus each application implements access-

AcceptBid.php

Del.php

s e s s i o n s t a r t ( ) ;
i f

( ! $ SESSION [ ’ member ’ ] ) { / / a c c e s s−c o n t r o l c h e c k
header ( ’ L o c a t i o n :
e x i t ;

l o g i n . php ’ ) ;

i n c l u d e
i n c l u d e
. . .

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

7
8
9
10 $q5 = mysql query ( ”INSERT INTO c l o s e b i d ( item name ,

s e c u r i t y −s e n s i t i v e o p e r a t i o n

/ /

s e l l e r n a m e , bidder name ,

c l o s e p r i c e ) ” . $ s q l 5 ) ;

DelCb.php

1 <? / / No a c c e s s−c o n t r o l c h e c k

i n c l u d e
i n c l u d e
/ /

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

2
3
4
5 $ d e l e t e = mysql query ( ”DELETE FROM c l o s e b i d where

s e c u r i t y −s e n s i t i v e o p e r a t i o n

item name = ’ ” . $item name . ” ’ ” ) ;

i f ( $ d e l e t e ) {

m y s q l c l o s e ( $conn ) ;
. . .

DelCb.php repaired by FIXMEUP

s e s s i o n s t a r t ( ) ;
i f

( ! $ SESSION [ ’ member ’ ] ) { / /
header ( ’ L o c a t i o n :
e x i t ; / /

[ FixMeUp r e p a i r ]

/ /

[ FixMeUp r e p a i r ]

[ FixMeUp r e p a i r ]

l o g i n . php ’ ) ; / /

[ FixMeUp r e p a i r ]

i n c l u d e
i n c l u d e
/ /

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

7
8
9
10 $ d e l e t e = mysql query ( ”DELETE FROM c l o s e b i d where

s e c u r i t y −s e n s i t i v e o p e r a t i o n

item name = ’ ” . $item name . ” ’ ” ) ;

i f ( $ d e l e t e ) {

m y s q l c l o s e ( $conn ) ;
. . .

1 <?
2
3
4
5

6 }

. . .
11
12 ?>

6
7
8

9 }
10 ?>

1 <?
2
3
4
5

6 }

11
12
13

14 }
15 ?>

Figure 2: DNscript: Correct access-control check in Ac-
ceptBid.php for the “regular user” role, a missing check in
DelCb.php, and the repair by FIXMEUP

control policies in its own, idiosyncratic way. The variables
that hold users’ credentials and authorization information,
as well as the semantics of access-control checks, vary sig-
niﬁcantly from application to application. Fortunately, they
tend to follow a stylized code design pattern.

Access control is typically enforced near the program’s
entry point. First, the program collects relevant information.
For example, the SELECT query returns the user’s record
from the administrative database in minibloggie in Figure 1,
while the session state variable holds user data in DNscript
in Figure 2. Typically, only a few security-critical vari-
ables hold access-control information—for example, vari-
ables $user, $pwd, and $result in minibloggie—and they
are updated in a very small number of places. The corre-
sponding program slice is thus relatively small. All of our
benchmark applications exhibit these features (see Table 2).
Second, the application executes one or more condi-

1 <?php
2
3

s e s s i o n s t a r t ( ) ;
i f

( $ SESSION [ ’ admin ’ ]

c h e c k
header ( ’ L o c a t i o n :
e x i t ;

4
5

6 }

!= 1 ) { / / a c c e s s−c o n t r o l

l o g i n . php ’ ) ;

i n c l u d e
i n c l u d e
. . .

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

7
8
9
10 $ s q l = mysql query ( ”DELETE FROM d o m a i n l i s t WHERE

s e c u r i t y −s e n s i t i v e o p e r a t i o n

/ /

dn name = ’ ” . $dn name . ” ’ ” ) ;

AddCat2.php

1 <? / / No a c c e s s−c o n t r o l c h e c k

i n c l u d e
i n c l u d e
. . .

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

2
3
4
5 $ i n s e r t = mysql query ( ”INSERT INTO g e n c a t ( c a t n a m e )

s e c u r i t y −s e n s i t i v e o p e r a t i o n

/ /

” . $ v a l u e s ) ;

AddCat2.php repaired by FIXMEUP

s e s s i o n s t a r t ( ) ;
i f

( $ SESSION [ ’ admin ’ ]
header ( ’ L o c a t i o n :
e x i t ; / /

/ /

[ FixMeUp r e p a i r ]

[ FixMeUp r e p a i r ]

!= 1 ) { / /
l o g i n . php ’ ) ; / /

[ FixMeUp r e p a i r ]

[ FixMeUp r e p a i r ]

i n c l u d e
i n c l u d e
. . .
/ /

’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;

7
8
9
10
11 $ i n s e r t = mysql query ( ”INSERT INTO g e n c a t ( c a t n a m e )

s e c u r i t y −s e n s i t i v e o p e r a t i o n

” . $ v a l u e s ) ;

. . .
12
13 ?>

. . .
11
12 ?>

. . .
6
7 ?>

1 <?
2
3
4
5

6 }

Figure 3: DNscript: Correct access-control check in
Del.php for the “administrator” role, a missing check in Ad-
dCat2.php, and the repair by FIXMEUP

tional statements that evaluate a predicate over security-
critical variables. These statements implement the actual
access-control checks, e.g., line 4 of Figure 1 and line 3
of acceptBid.php in Figure 2. If the check fails, the pro-
gram terminates or returns to the login page. Otherwise, it
continues execution, eventually reaching the sensitive oper-
ation protected by the check. In many applications, these
steps are distributed over multiple functions and ﬁles, e.g.,
the verifyuser function in Figure 1.
3.3 Specifying access-control policies
FIXMEUP takes as input an explicitly speciﬁed or inferred
access-control policy. An access-control policy is a set
of role-speciﬁc mappings from program statements execut-
ing security-sensitive operations—such as SQL queries and
ﬁle operations—to one or more conditional statements that
must be executed prior to these operations. Because this
paper focuses on program repair and not on policy speciﬁ-
cation or inference (see Section 7 for a discussion of policy
sources), we limit our attention to policies speciﬁed by ex-

1 <?
2
3
4
5
6
7
8
9
10
11
12
13

14

15

16
17
18
19
20
21
22
23
24
25
26

plicit annotation.

The developer marks the access-control checks and the
security-sensitive operations and assigns them a user-role
tag. This high-level speciﬁcation informs FIXMEUP that
the marked check must be performed before the marked op-
eration in all calling contexts associated with the indicated
user role. In Figure 4, line 8 of admin.php shows an anno-
tation that marks the access-control check with the “admin”
role tag. Lines 22 and 26 show the annotations for security-
sensitive operations. FIXMEUP does not currently support
disjunctive policies where operations may be protected by
either check A or check B.

Unlike GuardRails [3], FIXMEUP does not require
an external speciﬁcation of all statements involved in
access-control enforcement. Instead, FIXMEUP automati-
cally computes access-control policies from the annotations
marking the checks and the protected operations.
4 Access-Control Templates
This section describes how FIXMEUP computes access-
control templates. We implemented this analysis in PHC,
an open-source PHP compiler [26], and analyze PHC-
generated abstract syntax trees (AST). We started by adding
standard call graph, calling context, data dependence, and
control dependence analyses to PHC.

FIXMEUP takes as input an explicit mapping from sensi-
tive operations to correct access-control checks. FIXMEUP
then performs interprocedural program slicing on the call
graph and on the data- and control-dependence graphs of
each method to identify the program statements on which
each access-control check is data- or control-dependent.
FIXMEUP converts each slice into a template, which serves
as a low-level speciﬁcation of the correct policy logic and
a blueprint for repair. Informally, the template contains all
statements in the check’s calling context that are relevant
to the check: (1) statements on which the check is data- or
control-dependent, and (2) calls to methods that return be-
fore the check is executed but contain some statements on
which the check is dependent.
4.1 Computing access-control slices
Given a conditional access-control check, FIXMEUP picks
an entry which has the shortest call depth to check. FIX-
MEUP iteratively computes the transitive closure of the
statements on which check is control- or data-dependent.
This analysis requires the call graph, control-ﬂow graphs,
intraprocedural aliases, and intraprocedural def-use chains.
For each call site, FIXMEUP computes an interprocedural
summary of side effects, representing the def-use informa-
tion for every parameter, member variable, and base vari-
able at this site. These analyses are standard compiler fare
and we do not describe them further.

In general, a slice may execute an arbitrary computa-
tion, but as we pointed out in Section 3, slices that perform

admin.php

/ /

s l i c e & ACT

i n c l u d e ( ” c o n f i g u r a t i o n . php ” ) ;
i n c l u d e ( ” f u n c t i o n s . php ” ) ;
require ( ” l a n g / $ l a n g u a g e . php ” ) ;
$ s e c u r i t y = ” yes ” ;
$ i n c l u d e s c r i p t = ” yes ” ;
i f

( $ s e c u r i t y == ” yes ” ) { / /
/ / @ACC( ’ admin ’ )
i f

/ /

s l i c e & ACT

( ( ! i s s e t ( $PHP AUTH USER ) )
| |
( ! i s s e t ( $PHP AUTH PW ) )
| |
( $PHP AUTH USER != ’UT ’ )
( $PHP AUTH PW != ’UTCS ’ ) ) {
| |

/ /

s l i c e & ACT

s l i c e & ACT

header ( ’WWW−A u t h e n t i c a t e : B a s i c r ea lm =”

n e w s a d m i n i s t r a t i o n ” ’ ) ;

/ /

s l i c e & ACT

header ( ’HTTP / 1 . 0 401 U n a u t h o r i z e d ’ ) ;

/ /

s l i c e &

ACT

echo ’<html><head><t i t l e >Access Denied ! </ t i t l e

></head><body>A u t h o r i z a t i o n R e q u i r e d . </
body></html>’ ;

s l i c e & ACT

/ /

/ /

e x i t ;
. . .

}

}
switch ( $ a c t i o n ) {

s l i c e & ACT

case ” check ” :
case ” add ” :

check ( ) ; break ;
/ / @SSO( ’ admin ’ )

add ( ) ;
break ;

case ” d e l e t e ” :

d e l e t e ( ) ;
break ;
. . . } ?>

/ / @SSO( ’ admin ’ )

conﬁguration.php

. . .

1 <?php
2
3
4

. . . ?>

$PHP AUTH PW = $ SERVER [ ’PHP AUTH PW ’ ] ;
$PHP AUTH USER = $ SERVER [ ’PHP AUTH USER ’ ] ;

/ /
/ /

s l i c e
s l i c e

Access-control template for admin users

(m0 = admin . php ( program e n t r y ) ,
S0 = {

i n c l u d e ( ” c o n f i g u r a t i o n . php ” ) ;
$ s e c u r i t y = ” yes ” ;
i f

( $ s e c u r i t y == ” yes ” ) {
i f

( ( ! i s s e t ( $PHP AUTH USER ) )
| |
( ! i s s e t ( $PHP AUTH PW ) )
| |
( $PHP AUTH USER != ’UT ’ )
| |
( $PHP AUTH PW != ’UTCS ’ ) ) {
header ( ’WWW−A u t h e n t i c a t e : B a s i c re al m =”

n e w s a d m i n i s t r a t i o n ” ’ ) ;

header ( ’HTTP / 1 . 0 401 U n a u t h o r i z e d ’ ) ;
echo ’<html><head><t i t l e >Access Denied ! </

t i t l e ></head><body>A u t h o r i z a t i o n
R e q u i r e d . </ body></html>’ ;

e x i t ;

}

} )

Figure 4: Newsscript: Slice and access-control template

access-control enforcement are typically loop-free compu-
tations that ﬁrst acquire or retrieve user credentials or ses-
sion state, and then check them. All of our benchmarks
follow this pattern. Statements in these slices update only a
small set of dedicated variables which are used in the check
but do not affect the rest of the program. The exceptions are
global variables that hold database connections and session
state. These variables are typically initialized before per-
forming access control and read throughout the program.
When FIXMEUP inserts code to repair vulnerabilities, it
takes care not to duplicate statements with side effects.

1
2

3

4
5

6
7
8
9
10
11
12
13
14
15 }

4.2 Computing access-control templates
Statements in a slice may be spread across multiple meth-
ods and thus do not directly yield an executable code se-
quence for inserting elsewhere. Therefore, FIXMEUP con-
verts slices into templates.

An access-control template (ACT) is a hierarchical data
structure whose hierarchy mirrors the calling context of the
access-control check. Each level of the ACT corresponds
to a method in the context. For each method, the ACT
records the statements in that method that are part of the
slice. These statements may include calls to methods that
return before the access-control check is executed, but only
if the call subgraphs rooted in these methods contain state-
ments that are part of the slice.

The last level of the ACT contains the access-control
check and the failed-authorization code that executes if the
check fails (e.g., termination or redirection). The developer
optionally speciﬁes the failed-authorization branch. With-
out such speciﬁcation, FIXMEUP uses the branch that con-
tains a program exit call, such as die or exit. We label
each ACT with the programmer-speciﬁed user role from the
check’s annotation.
Formally, ACTrole is an ordered list of (mi, Si) pairs,
where mi are method names and Si ∈ mi are ordered lists
of statements. Each mi is in the calling context of check,
i.e., it will be on the stack when check executes. Each state-
ment s ∈ Si is part of the access-control logic because (1)
the check is data- or control-dependent on s, or (2) s is a call
to a method n that contains such a statement somewhere in
its call graph, but n returns before the check executes, or (3)
s is a statement in the failed-authorization branch of check.
Consider the following example:

1 main ( ) {
a = b ;
c = c r e d e n t i a l s ( a ) ;
i f
p e r f o r m s e c u r i t y −s e n s i t i v e o p e r a t i o n

t h e n f a i l ( . . . ) ;

( c )

2
3
4
5

6 }

the

conditional

statement if (c) is

access-
The
is simply main.
control check and its calling context
The computed template ACTrole includes the call
to
credentials, as well as fail(...) in the branch cor-
responding to the failed check. We add the following pair
to the ACTrole: (main, { a=b, c=credentials(a),
if (c) then fail(...) }).

Figure 5 shows the algorithm that, given a calling context
and a slice, builds an ACT. The algorithm also constructs
data- and control-dependence maps, DDACT and CDACT ,
which represent all dependences between statements in the
ACT. FIXMEUP uses them to (1) preserve dependences be-
tween statements when inserting repair code, and (2) match
templates to each other when validating repairs. Figure 4
gives an example of an access-control slice and the corre-
sponding ACT from Newsscript 1.3.

GetACT (CC, SLICE) {

// INPUT

CC = {(cs1, m0), (cs2, m1) . . . (check, mn)}: calling context of the
SLICE: statements on which the check is data− or control−dependent

check, where csi+1 ∈ mi is the call site of mi+1

and statements executed when authorization fails

// OUTPUT

ACT : template {(mi, si)}, where si is an ordered list of statements in

method mi

DDACT , CDACT : data and control dependences in ACT

ACT ← ∅
ACT.CCsrc ← CC
BuildACT (m0, CC, SLICE)
DDACT = {(sk, sj ) s.t. sk,j ∈ ACT and sk is data−dependent on sj}
CDACT = {(sk, sj ) s.t. sk,j ∈ ACT and sk is control−dependent on sj}
return ACT

BuildACT (mi, CC, SLICE) {
Si ← ∅
j ← 0
for (k = 0 to |mi|, sk ∈ mi) { // |mi| is the number of statements in mi

1
2
3
4
5
6
7
8
9
10
11 ACT ← {(mi, Si)} ∪ ACT
12 }

if (sk ∈ SLICE) {
Si[j + +] = sk
}
if (sk is a callsite s . t . (sk, mi+1) ∈ CC) {
}

BuildACT (mi+1, CC, SLICE)

}

Figure 5: Computing an access-control template (ACT)

5 Finding and Repairing Vulnerabilities
We ﬁrst give a high-level overview of how FIXMEUP ﬁnds
vulnerabilities, repairs them, and validates the repairs, and
then we describe each step in more detail.

FIXMEUP considers all security-sensitive operations in
the program. Recall that each sensitive operation is asso-
ciated with a particular user role (see Section 3.3). For
each operation, FIXMEUP computes all of its calling con-
texts. For each context, it considers all candidate checks,
computes the corresponding access-control template ACT (cid:48),
and compares it with the role’s access-control template
ACTrole. If some context CCtgt is missing the check, its
ACT (cid:48) will not match ACTrole. This context has an access-
control vulnerability and FIXMEUP targets it for repair.

To repair CCtgt, FIXMEUP inserts the code from
ACTrole into the methods of CCtgt. ACTrole contains
the calling context CCsrc of a correct access-control check
and FIXMEUP uses it to guide its interprocedural repair
of CCtgt. FIXMEUP matches CCsrc method by method
against CCtgt. At the last matching method minline, FIX-
MEUP inlines all statements from the methods deeper in
CCsrc than minline into minline. We call this adapting
the ACT to a target context. Adaptation produces a method
map indicating, for each msrc ∈ ACTrole, the method
mtgt ∈ CCtgt where to insert statements from msrc.

For each statement in ACTrole, FIXMEUP inserts state-

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 }

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

22
23
24
25
26
27
28 }

ments from msrc into the corresponding mtgt only if they
are missing from mtgt. In the simplest case, if the vulner-
able context has only the entry method and no code that
corresponds to any code in ACTrole, FIXMEUP inserts the
entire template into the entry method.

A repair can potentially introduce two types of undesired
semantic changes to the target code. First, statements al-
ready present in the target may affect statements inserted
from the template. We call these unintended changes to
the inserted policy. Second, inserted statements may affect
statements already present in the target. We call these unin-
tended changes to the program. Because our analysis keeps
track of all data and control dependences and because our
repair procedure carefully renames all variables, we prevent
most of these errors. As we show in Section 6, FIXMEUP
detects when template statements with side effects are al-
ready present in the program and does not insert them.

To validate that there are no unintended changes to an
inserted policy, FIXMEUP computes a fresh ACT from the
repaired code and compares it with the adapted ACT . If
they match, FIXMEUP gives the repaired code to the devel-
oper; otherwise, it issues a warning.

In general,

5.1 Matching templates
To ﬁnd vulnerabilities and validate repairs, FIXMEUP
matches templates.
it is impossible to de-
cide whether two arbitrary code sequences are semantically
equivalent. Matching templates is tractable, however, be-
cause ACTs of real-world applications are loop-free and
consist of a small number of assignments, method invoca-
tions, and conditional statements. Furthermore, when de-
velopers implement the same access-control policy in mul-
tiple places in the program, they tend to use structurally
identical code which simpliﬁes the matching process.

Figure 6 shows our template matching algorithm and the
statement matching algorithm that it uses. The latter algo-
rithm compares statements based on their data and control
dependences, and therefore the syntactic order of statements
does not matter. Matching is conservative: two matching
templates are guaranteed to implement the same logic.
Let ACTx and ACTy be two templates. For every
sx ∈ ACTx, FIXMEUP determines if there exists only one
matching statement sy ∈ ACTy, and vice versa. The de-
velopers may use different names for equivalent variables
in different contexts, thus syntactic equivalence is too strict.
Given statements sx ∈ ACTx and sy ∈ ACTy, FIXMEUP
ﬁrst checks whether the abstract syntax tree structures and
operations of sx and sy are equivalent. If so, sx and sy are
syntactically isomorphic, but can still compute different re-
sults. FIXMEUP next considers the data dependences of sx
and sy. If the dependences also match, FIXMEUP declares
that the statements match. Table 1 shows the matching rules
when neither statement has any dependences.

isMatchingACT (ACTx, ACTy) {
// INPUT: two ACTs to be compared
// OUTPUT: true if ACTx and ACTy match, false otherwise
if (|ACTx| (cid:54)= |ACTy|) return false;
V arM ap ← φ
StatementM ap ← φ
for( sx ∈ ACTx in order ) {

StatementM ap ← StatementM ap ∪ {(sx, sy)}

if ( ∃only one (sx, sy) s.t. sy ∈ ACTy and isM atching(sx, sy) ) {
} else {
}

return false ;

}
return true;

isMatching (ssrc, stgt) {

// INPUT: statements ssrc ∈ ACT , stgt ∈ mtgt to be compared
// OUTPUT: true if ssrc and stgt match, false otherwise

V arM ap: updated variable mappings

if ( ∃(ssrc, stgt) ∈ StatementM ap ) return true
if (AST structures of ssrc and stgt are equivalent) {
msrc ←method containing ssrc ∈ ACT
DDsrc ← {(ssrc, d) s.t. ssrc is data−dependent on d ∈ msrc}
DDtgt ← {(stgt, d) s.t. stgt is data−dependent on d ∈ mtgt}
if (DDsrc ≡ φ and DDtgt ≡ φ) {
// no data dependences
if ( ssrc and stgt are one of the types described in Table 1 ) {
if (ssrc = “vx = Cx” and stgt = “vy = Cy” and

constants Cx and Cy are equal) {

V arM ap = V arM ap ∪ {(vx, vy)}

}
return true

} else return false
} else if (|DDsrc| == |DDtgt|) {
if (∀(ssrc, dx) ∈ DDsrc, ∃ (stgt, dy) ∈ DDtgt and
if (ssrc = “vx = . . . ” and stgt = “vy = . . . ”) {
V arM ap = V arM ap ∪ {(vx, vy)}
}
return true

(dx, dy) ∈ StatementM ap) {

} } }
return false

Figure 6: Matching access-control templates

5.2 Finding access-control vulnerabilities
For each security-sensitive operation (sso), FIXMEUP
computes the tree of all calling contexts in which it may
execute by (1) identifying all methods that may directly in-
voke sso and (2) performing a backward, depth-ﬁrst pass
over the call graph from each such method to all possible
program entries. FIXMEUP adds each method to the call-
ing context once, ignoring cyclic contexts, because it only
needs to verify that the access-control policy is enforced
once before sso is executed.

For each calling context CC in which sso may be
executed, FIXMEUP ﬁrst ﬁnds candidate access-control
checks. A conditional statement b is a candidate check if it
(1) controls whether sso executes or not, and (2) is syntacti-
cally equivalent to the correct check given by the ACTrole.
For each such b, FIXMEUP computes its slice, converts it
into ACTb using the algorithms in Figure 5, and checks

methoda(C0, ..., Ci)
localvara = C ∈ methodi
globalvara = C ∈ methodi

0, ..., C(cid:48)
i)

methodb(C(cid:48)
localvarb = C(cid:48) ∈ methodk
globalvarb = C(cid:48) ∈ methodk Match if (1) globalvara = globalvarb and (2) constants C = C(cid:48)

Match if (1) methoda = methodb and (2) all constants Ck = C(cid:48)
Match if (1) methodi = methodk or both methods are entry methods
and (2) constants C = C(cid:48)

k

Table 1: Matching statements without dependences

whether ACTb matches ACTrole.
If so, this context al-
ready implements correct access-control logic. Otherwise,
if there are no candidate checks in the context or if none of
the checks match the correct check, the context is vulnera-
ble and FIXMEUP performs the repair.

DoRepair (ACT , CCtgt) {

1
2
3

// INPUT

ACT : access−control template speciﬁcation
CCtgt = {(cs(cid:48)

1) . . . (sso, m(cid:48)
vulnerable security−sensitive operation sso

0), (cs(cid:48)

1, m(cid:48)

2, m(cid:48)

n)}: calling context of the

// OUTPUT

StatementM ap ← φ
V arM ap ← φ

RepairedAST : repaired program AST
M atchCount: number of ACT statements already in the target

4
5
6
7
8 M ethodM ap ← φ // Initialize maps between ACT and target context
9
10
11
12
13
14
15
16
17
18
19 }

ACTadapted = AdaptACT (ACT, CCtgt)
(RepairedAST, InsertedCheck, M atchCount) ←
(ACTadapted, InsertedCheck)) {

if ( ValidateRepair
}
return warning

return (RepairedAST, M atchCount)

ApplyACT (ACTadapted, CCtgt)

ValidateRepair (ACTorig, InsertedCheck) {
ACTorig: applied access−control template
InsertedCheck: inserted access−control check

// INPUT

// OUTPUT:

true if extracted ACT from the repaired code matches ACTorig
SEEDS ← {InsertedCheck, exit branch of InsertedCheck}
newSLICE ← doSlicing (SEEDS)
newCC ← calling context of InsertedCheck
ACTrepair ← GetACT (newSLICE, newCC)
return isMatchingACT (ACTorig, ACTrepair)

1
2
3
4
5
6
7
8
9
10
11
12 }

Figure 7: Repairing vulnerable code and validating the re-
pair

5.3 Applying the template
Formally, CCsrc = {(cs1, m0) . . . (check, mn)}, CCtgt =
i+1 ∈ m(cid:48)
{(cs(cid:48)
i
are the call sites of mi+1, m(cid:48)
i+1 respectively. For simplicity,
we omit the subscript from ACTrole.

l)}, where csi+1 ∈ mi, cs(cid:48)

0) . . . (sso, m(cid:48)

1, m(cid:48)

FIXMEUP uses DoRepair in Figure 7 to carry out a re-
pair. It starts by adapting ACT to the vulnerable calling
context CCtgt.
If CCtgt already invokes some or all of
the methods in ACT , we do not want to repeat these calls
because the policy speciﬁes that they should be invoked

only once in a particular order. After eliminating redun-
dant method invocations, FIXMEUP essentially inlines the
remaining logic from ACT into ACTadapted.

Formally,

the algorithm ﬁnds common method invo-
cations in CCsrc and CCtgt by computing the deepest
minline ∈ CCsrc such that for all i ≤ inline mi matches
m(cid:48)
i. For i = 0, m0 and m(cid:48)
0 match if they are both entry
methods. For i ≥ 1, mi and m(cid:48)
i match if they are invo-
cations of exactly the same method. The ﬁrst for loop in
AdaptACT from Figure 8 performs this process.

i), including minline, in M ethodM ap.

In the simplest case, the entry m(cid:48)

The algorithm then adapts ACT to CCtgt by inlining
the remaining statements—those from the methods deeper
than minline in ACT —into minline. The second for loop
in AdaptACT from Figure 8 performs this process and pro-
duces ACTadapted. While matching methods and inlining
statements, FIXMEUP records all matching method pairs
(mi, m(cid:48)
0 ∈ CCtgt is the only
method matching minline = m0. In this case, FIXMEUP
inlines every statement in ACT below m0 and produces a
ﬂattened ACTadapted.
Otherwise, consider the longest matching method se-
quence (m0 . . . minline) and (m(cid:48)
inline) in CCsrc
and CCtgt, respectively. For 1 ≤ i ≤ inline−1, mi and m(cid:48)
i
are exactly the same; only m0 and minline are distinct from
m(cid:48)
0 and m(cid:48)
inline, respectively. AdaptACT stores the (m0,
0) and (minline,m(cid:48)
m(cid:48)
FIXMEUP uses the resulting template ACTadapted to re-
pair the target context using the ApplyACT algorithm in Fig-
ure 9. This algorithm respects the statement order, control
dependences, and data dependences in the template. Fur-
thermore, it avoids duplicating statements that are already
present in the target methods.

inline) mappings in M ethodM ap.

0 . . . m(cid:48)

The algorithm iterates msrc over m0 and minline in
ACTadapted because, by construction, these are the only
methods that differ between the template and the target. It
ﬁrst initializes the insertion point iptgt in mtgt correspond-
ing to msrc in M ethodM ap. The algorithm only inserts
statements between the beginning of mtgt and the sensi-
tive operation sso, or—if mtgt calls other methods to reach
sso—the call site of the next method in the calling context
of sso. Intuitively, the algorithm only considers potential
insertion points and matching statements that precede sso.
Before FIXMEUP inserts a statement s, it checks if there

AdaptACT (ACTsrc, CCtgt) {

ApplyACT (ACT, CCtgt) {

// Adapt ACTsrc to the target context CCtgt
ACT ←clone ACTsrc
CCsrc = ACT.CCsrc
l ← 0

for ( i = 0;

i < |CCsrc|; i++ ) {

iterate from the entry to the bottom method in CCsrc

//
mi ← ith method in CCsrc
mtgt ← ith method in CCtgt
if ( mi and mtgt are entries or mi == mtgt ) {
M ethodM ap ← M ethodM ap ∪ {(mi, mtgt)}
l ← i
} else break;

}
minline ← lth method in CCtgt
for ( k = l+1 ; k < |CCsrc|; k++ ) {

inline method mk from CCsrc into minline in ACT
M ethodM ap ← M ethodM ap ∪ {(mk, minline)}

}
return ACT

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22 }

Figure 8: Adapting ACT to a particular calling context

and false branches of s(cid:48).

already exists a matching statement s(cid:48) ∈ mtgt. If so, FIX-
MEUP adds s and s(cid:48) to StatementM ap, sets the current
insertion point iptgt to s(cid:48), and moves on to the next state-
ment. Otherwise, it inserts s as follows:
1. Transform s into s(cid:48) by renaming variables.
2. If s is a conditional, insert empty statements on the true
3. If iptgt has not been set yet, insert s(cid:48) at the top of mtgt.
4. Otherwise, if s is immediately control-dependent on
some conditional statement t, insert s(cid:48) as the last state-
ment on the statement list of the matching branch of
the corresponding conditional t(cid:48) ∈ mtgt.
5. Otherwise, insert s(cid:48) after iptgt, i.e., as the next state-
ment on the statement list containing iptgt. For exam-
ple, if iptgt is an assignment, insert s(cid:48) as the next state-
ment. If iptgt is a conditional, insert s(cid:48) after the true
and false clauses, at the same nesting level as iptgt.
6. Add (s, s(cid:48)) to StatementM ap and set iptgt to s(cid:48).
ApplyACT returns the repaired AST, the inserted check,

and the number of reused statements.
Variable renaming. When FIXMEUP inserts statements
into a method, it must create new variable names that do not
conﬂict with those that already exist in the target method.
Furthermore, because FIXMEUP, when possible, reuses ex-
isting statements that match statements from the ACT se-
mantically (rather than syntactically), it must rename vari-
ables. Lastly, as the algorithm establishes new names and
matches, it must rewrite subsequent dependent statements
to use the new names. The isMatching function in Figure 6
establishes a mapping between a variable name from the
template and a variable name from the target method when
it matches assignment statements.

As FIXMEUP inserts subsequent statements, it uses the
variable map to replace the names from the template. Be-

25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43 }

1
2
3
4
5
6
7
8
9
10
11
12
13 }

1

2
3
4

//

Insert

statements only in entry and/or

last method of CCtgt that
matches a method from adapted ACT . Other methods match ACT
exactly (see AdaptACT).

// INPUT

ACT : access−control template
CCtgt = {(cs(cid:48)
0), (cs(cid:48)

1, m(cid:48)

2, m(cid:48)

vulnerable sensitive operation sso

1) . . . (sso, m(cid:48)

n)}: calling context of the

RepairedAST : AST of the repaired code
InsertedCheck: inserted access−control check
M atchCount: number of ACT statements found in the target

// OUTPUT

5
6
7
8
9
10 M atchCount ← 0
11
12
13
14
15
16
17
18
19
20
21
22
23
24

Is there a statement after iptgt in mtgt that matches s?

InsertedCheck ← null
m0 ← the entry of ACT
minline ← the method containing check in ACT
for ( msrc ∈ {m0, minline} ) {
iptgt ← null
mtgt ← M ethodM ap(msrc)
for ( s ∈ ACT (msrc) in order ) {
//
s(cid:48) ← FindMatchingStmt(s, iptgt, mtgt)
if (s(cid:48) (cid:54)= null) { // target method already contains s
iptgt ← s(cid:48)
M atchCount++
} else { // no match,
(t, d) ← a pair of statement t and direction d s.t. s is immediately control
s(cid:48) ← RenameVars(s, mtgt) // rename variables in s for mtgt
if (s(cid:48) is a conditional statement ) { // add two branches
add true and f alse branches to s(cid:48) with empty statements
if (s is the access control check)

−dependent on t in d

insert s into target

InsertedCheck ← s(cid:48)

}
if (iptgt == null) {
insert s(cid:48) at the ﬁrst
} else if (t (cid:54)= null) { // s is immediately control−dependent on t

statement

in mtgt

insert on the corresponding conditional branch

//
t(cid:48) ← StatementM ap(t)
insert s(cid:48) at the last statement on branch d of t(cid:48)
} else { insert s(cid:48) immediately after iptgt in mtgt }
iptgt ← s(cid:48)
StatementM ap ← StatementM ap ∪ {(s, s(cid:48))}

} } }
RepairedAST s ← all modiﬁed ASTs of mtgt ∈ M ethodM ap
return (RepairedAST s, InsertedCheck, M atchCount)

RenameVars (s, mtgt) {

// INPUT: s ∈ ACT , target method mtgt
// OUTPUT: s(cid:48) with variables remapped, updated V arM ap
s(cid:48) ← clone s
if (s = “vACT = . . . ” and vACT is local) {
if ((cid:54) ∃t s.t. (vACT , t) ∈ V arM ap) {

V arM ap ← V arM ap ∪ {(vACT , vnew)}

}}
for (v ∈ s(cid:48)) {

if (∃(v, vnew) ∈ V arM ap)
replace v with vnew in s(cid:48)

}
return s(cid:48)

Figure 9: Applying an access-control template

fore ApplyACT inserts a statement, it calls RenameVars to
remap all variable names to the names used by the target
method. For unmapped variables, RenameVars creates fresh
names that do not conﬂict with the existing names.
Dealing with multiple matching statements.
In theory,
there may exist multiple statements in mtgt that match s

FindMatchingStmt(s, iptgt, mtgt) {

// INPUT:

s: statement
iptgt: last inserted statement in mtgt

in ACT

if (mtgt contains the sensitive operation sso)
SL = { statements in mtgt after iptgt that dominate sso}
else
SL = { statements in mtgt after iptgt that dominate the callsite of next
for(t ∈ SL) {

method in CCtgt }
if (isM atching(s, t)) {

StatementM ap ← StatementM ap ∪ {(s, t)}
return t

If multiple statements in SL match s, they are handled as described in

1
2
3
4
5
6
7
8

9
10
11
12
13
14

15
16
17 }

}
//

Section 5.3

}
return null

Figure 10: Matching statements

and thus multiple ways to insert ACTadapted into the tar-
get context. Should this happen, FIXMEUP is designed
to exhaustively explore all possible matches, generate the
corresponding candidate repairs, and validate each candi-
date. FIXMEUP picks the validated candidate that reuses
the most statements already present in the target and sug-
gests it to the developer.
5.4 Validating repairs
As mentioned above, FIXMEUP can potentially introduce
two types of semantic errors into the repaired program: (1)
unintended changes to the inserted policy, and (2) unin-
tended changes to the program. Unintended changes to the
inserted policy may occur when existing statements change
the semantics of the inserted code. Unintended changes to
the program may occur when the inserted code changes the
semantics of existing statements.

To detect type (1) errors, FIXMEUP computes afresh an
ACT from the repaired code and compares it—using Vali-
dateRepair from Figure 7—with the ACT on which the re-
pair was based. An ACT captures all control and data de-
pendences. Any interference from the existing statements
that affects the inserted code must change the dependences
of the inserted statements. For example, suppose the reused
statement has dependent statements already in the program
that are not part of the ACT. In this case, the ACTs will not
match and FIXMEUP will issue a warning. This validation
procedure guarantees that reusing an existing statement is
always safe. We examined all 38 repairs suggested by FIX-
MEUP for our benchmarks (see Section 6) and in only one
case did the insertion of the repair code change the ACT
semantics. FIXMEUP’s validation algorithm detected this
inconsistency and issued a warning.

With respect to type (2) errors, unintended changes to the
program, observe that the actual purpose of the repair is to
change the program’s semantics by adding access-control
logic. FIXMEUP therefore cannot guarantee that the re-

paired program is free from type (2) errors because it cannot
know the full intent of the programmer.

The purpose of repair is to introduce a new dependence:
all statements after the inserted access-control check be-
come control-dependent on the check, which is a desired se-
mantic change. Because FIXMEUP inserts the check along
with the statements deﬁning the values used in the check,
the inserted access-control logic may change both control
and data dependences of statements that appear after the
check. Our repair procedure minimizes the risk of unin-
tended dependences by reusing existing statements as much
as possible and by renaming all variables deﬁned in the
template to fresh names, thus preventing unintended depen-
dences with the variables already present in the program.
In just one of the 38 repairs on our benchmarks (see Fig-
ure 14 in Section 6) did an incorrectly annotated role cause
FIXMEUP to “repair” a context that already implemented a
different access-control policy and thus introduce unwanted
changes to the program.

5.5 Discussion and limitations
Good program analysis and transformation tools help de-
velopers produce correct code. They are especially useful
for subtle semantic bugs such as inconsistent enforcement
of access-control policies, but developers must still be inti-
mately involved in the process. The rest of this section dis-
cusses the general limitations of any automated repair tool
and the speciﬁc limitations of our implementation.
Programmer burden. Suggesting a repair, or any pro-
gram change,
to developers requires some speciﬁcation
of correct behavior. We rely on developers to annotate
access-control checks and security-sensitive operations in
their applications and tag them with the corresponding user
role. We believe that this speciﬁcation burden is relatively
light and, furthermore, it can be supported by policy in-
ference tools [32]. We require that the speciﬁcations be
consistent for all security-sensitive operations in a given
role.
If the programmer wants different checks in differ-
ent contexts for the same operation, the speciﬁcation won’t
be consistent and our approach will attempt to conserva-
tively over-protect the operation. For example, Figure 11
shows that FIXMEUP inserts a credential check performed
in one context into a different context that already performs
a CAPTCHA check, in this case introducing an unwanted
duplicate check. Developers should always examine sug-
gested repairs for correctness.

We believe that the consequences of access-control er-
rors are sufﬁciently dire to motivate the developers to bear
this burden in exchange for suggested code repairs, since it
is easier to reject or manually ﬁx a suggested change than it
is to ﬁnd the error and write the entire repair by hand. The
latter requires systematic, tedious, error-prone examination
of the entire program and its call graph. Language features

of PHP, such as the absence of a proper module system, dy-
namic typing, and eval, further complicate this process for
PHP developers. The number of errors found by FIXMEUP
in real-world PHP applications attests to the difﬁculty of
correctly programming access control in PHP.
Static analysis. FIXMEUP uses a standard static interpro-
cedural data- and control-dependence analysis to extract the
program slice representing the access-control logic. Be-
cause this analysis is conservative, the slice could contain
extraneous statements and therefore would be hard to ap-
ply as a transformation. Program slicing for more general
debugging purposes often produces large slices [34]. Fortu-
nately, access-control policies are typically self-contained
and much more constrained. They consist of retrieving
stored values into local variables, checks on these variables,
and code that exits or restarts the program after the check
fails. Consequently, access-control templates tend to be
short (see Table 2).

Our FIXMEUP prototype does not handle the dynamic
language features of PHP, nor does it precisely model all
system calls with external side effects.
In particular, the
analysis resolves dynamic types conservatively to build the
call graph, but does not model eval or dynamic class
loading, which is unsound in general.
In practice, only
myBB uses eval and we manually veriﬁed that there are
no call chains or def-use chains involving eval that lead to
security-sensitive operations, thus eval does not affect the
computed ACTs.

Static analysis can only analyze code that is present at
analysis time. PHP supports dynamic class loading and thus
potentially loads classes our code does not analyze. How-
ever, our benchmarks use dynamic class loading in only a
few cases, and we do analyze the classes they load. To han-
dle these cases, we annotated 18 method invocations with
the corresponding dynamic methods to generate a sound
call graph that includes all possible call edges.

etc., but

imprecision.

Our analysis models database connections such as
open, close, and write, ﬁle operations that return ﬁle
it does not perform symbolic
descriptors,
string analysis on the arguments.
This is a pos-
sible source of
For example, consider
two statements: writeData("a.txt",$data) and
$newdata = readData($b). If $b is “a.txt”, the sec-
ond statement is data-dependent on the ﬁrst. A more precise
algorithm would perform symbolic analysis to determine if
the two statements may depend on each other and conserva-
tively insert a dependence edge. Not doing this makes our
analysis unsound in general, but in practice, we never ob-
served these types of dependences. Therefore, even a more
conservative analysis would have produced the same results
on our benchmarks.

Statement matching is weaker than semantic equiva-
lence. For example, our matching algorithm does not cap-

ture that statements a = b + c and a = add(b, c) are equiva-
lent. Another minor limitation of our matching algorithm is
the use of coarse-grained statement dependences instead of
variable def-use chains on the remapped variable names. A
more precise algorithm would enforce consistency between
the def-use information for each variable name varx used in
sx and vary used in sy, even if the names are not the same
given the variable mapping produced thus far. The current
algorithm may yield a match with an inconsistent variable
mapping in distinct statements and thus change the def-use
dependences at the statement level. We never encountered
this problem in practice and, in any case, our validation pro-
cedure catches errors of this type.

6 Evaluation
We evaluate FIXMEUP on ten open-source interactive PHP
Web applications, listed in Table 2. We chose SCARF,
YaPiG, AWCM, minibloggie, and DNscript because they
were analyzed in prior work on detecting access-control
vulnerabilities [32, 36]. Unlike FIXMEUP, none of the pre-
vious techniques repair the bugs they ﬁnd. In addition to
repairing known vulnerabilities, FIXMEUP found four new
vulnerabilities in AWCM 2.2 and one new vulnerability in
YaPiG that prior analysis [36] missed. We added Newss-
cript and phpCommunityCal to our benchmarks because
they have known access-control vulnerabilities, all of which
FIXMEUP repaired successfully. To test the scalability of
FIXMEUP, we included two relatively large applications,
GRBoard and myBB. Table 2 lists the lines of code (LoC)
and total analysis time for each application, measured on a
Linux workstation with Intel dual core 2.66GHz CPU with
2 GB of RAM. Analysis time scales well with the number
of lines in the program.

Our benchmarks are typical of server-side PHP applica-
tions: they store information in a database or local ﬁle and
manage it based on requests from Web users. Table 2 shows
that four applications have a single access-control policy
that applies throughout the program. The other six have two
user roles each and thus two role-speciﬁc policies. Policies
were speciﬁed by manual annotation. They are universal,
i.e., they prescribe an access-control check that must be per-
formed in all contexts associated with the given role.

FIXMEUP ﬁnds 38 access-control bugs, correctly re-
pairs 30 instances, and issues one warning. Nine of the ten
benchmarks contained bugs. Seven bugs were previously
unknown. As mentioned above, ﬁve of the previously un-
known bugs appeared in applications that had been analyzed
in prior work which missed the bugs. Five of the ten appli-
cations implement seven correct, but alternative policies in
some of their contexts (i.e., these policies differ from the
policy in the template).

The fourth and ﬁfth columns in Table 2 characterize the
access-control templates; the third column lists the user role

Analysis
LoC time (s)
26
2,287
3,150
22

Web applications
minibloggie 1.1
DNscript

Events Lister 2.03
Newsscript 1.3
SCARF (before patch)

YaPiG 0.95

2,571
2,635
1,490

7,194

phpCommunityCal 4.0.3 12,298
AWCM 2.2
11,877

GRBoard 1.8.6.5

50,491

myBB 1.6.7

107,515

totals

ACT

Role
tag instances LoC
6
4
4
4
8
4
4
5
11
8
8
4
4
4
2
8

admin
admin
normal
admin
admin
admin
normal
admin
normal
admin
admin
normal
admin
normal
admin
normal

2
14
8
9
1
4
1
3
3
5
38
8
14
9
38
31

missing alternative inserted policies
checks

unwanted
partial full warn side effects

policies

1
3
1
2
1
1
0
0
1
12
0
4
2
3
0
0

31

0
0
1
1
0
0
0
0
1
0
0
3
0
1
0
0

7

0
0
1
0
1
1
0
0
2
12
0
6
1
4
0
0

28

0
3
1
3
0
0
0
0
0
0
0
1
1
0
0
0

9

1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

1

0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0

1

24
65
40

250

367
1221

1742

5133

Table 2: PHP benchmarks, analysis time in seconds, ACT characterization, and repair characterization

to which each policy applies. Six applications have two
policies, admin or normal. The fourth column shows the
total instances of the template in the code, showing that de-
velopers often implement the same access-control logic in
multiple places in the program. For example, the DNscript
application has two roles and thus two role-speciﬁc access-
control policies. Out of the 22 templates in DNscript, only
2 are unique. The “LoC” column shows the size of each
template (in AST statements). The templates are relatively
small, between 2 and 11 statements each.

The “missing checks” and “alternative policies” columns
in Table 2 show that FIXMEUP ﬁnds a total of 38 miss-
ing checks. The “alternative policies” column shows that in
seven cases FIXMEUP inserts an access-control policy, but
that the target code already has a different check. Figure 11
shows a code example of this case, where process.php is
repaired using the policy from AddDn.php. However, it
already contained a different, CAPTCHA-based check.

For the other 7,

The “inserted polices” columns shows that FIXMEUP
made 37 validated repairs with one warning, 30 of which
ﬁxed actual vulnerabilities.
the pro-
gram already contained alternative logic for the same
role (e.g., CAPTCHA vs. login). The case that gen-
erated the warning is shown in Figure 12. FIXMEUP
only inserts statements that are missing from the tar-
get. In minibloggie, the statements session start()
and dbConnect() are both in the template and in
Del.php, thus FIXMEUP does not insert them.
It only
inserts the missing statement if (!verifyuser())
{header (’Location: ./login.php’);}. The
access-control check at line 10, however, now depends on

AddDn.php

s e s s i o n s t a r t ( ) ;
i f

( ! $ SESSION [ ’ member ’ ] ) {
header ( ’ L o c a t i o n :
e x i t ;

l o g i n . php ’ ) ;

1 <?
2
3
4
5

6 } . . .
7 ?>

Process.php

1 <?
2
3
4

5

6 }

s e s s i o n s t a r t ( ) ;
i f

( ! $ SESSION [ ’ member ’ ] ) { / /
header ( ’ L o c a t i o n :

/ /

l o g i n . php ’ ) ;

e x i s t i n g s t a t e m e n t

[ FixMeUp r e p a i r ]

/ /

[ FixMeUp r e p a i r

]

e x i t ;

/ /

[ FixMeUp r e p a i r ]

. . .

7
8 $number = $ POST [ ’ image ’ ] ;
9
10

i f (md5( $number )

!= $ SESSION [ ’ i m a g e r a n d o m v a l u e ’ ] ) {

echo ’ V e r i f i c a t i o n does n o t match . . Go back and

r e f r e s h your b r o w s e r and t h e n r e t y p e your
v e r i f i c a t i o n ’ ;

e x i t ( ) ;

11

12 }
13 \?>

Figure 11: DNscript: Different access-control checks
within the same user role

the conditional at line 7. This dependence did not exist in
the original ACT and does not pass FIXMEUP validation.

The “partial” and “full” columns shows that, in 28 of
38 attempted repairs, FIXMEUP reused some of the exist-
ing statements in the target when performing the repair, and
only in 9 cases did it insert the entire template. This reuse
demonstrates that repairs performed by FIXMEUP are not
simple clone-and-patch insertions, and adapting the tem-

Attempted repair of Del.php

Correct repair of remove multi ﬁle.php

i n c l u d e ( ’ c l a s s / common . php ’ ) ;
/ /

1 <?
2
3 $GR newone = new COMMON( ) ;
4
5

i f

[ FixMeUp r e p a i r ]

/ /
[ FixMeUp r e p a i r ]
!= 1 ) ) { / /

[ FixMeUp r e p a i r ]
( ( $ SESSION [ ’ no ’ ]
$GR newone−>e r r o r ( ’ R e q u i r e admin p r i v i l e d g e ’ , 1 ,

’

CLOSE ’ ) ;

/ /

[ FixMeUp r e p a i r ]

6 }

t o

i d =” .

1 <? . . .
2
3
4
5

6 }

e l s e i f

s e s s i o n s t a r t ( ) ;
. . .
i f

/ /
( $ c o n f i r m ==” ” ) {
n o t i c e ( ” C o n f i r m a t i o n ” , ” Warning : Do you want

e x i s t i n g s t a t e m e n t

t h i s p o s t ? <a h r e f = d e l . php ? p o s t

i d . ”&c o n f i r m =yes>Yes </a>” ) ;

d e l e t e
$ p o s t
( $ c o n f i r m ==” yes ” ) {

dbConnect ( ) ;

/ /

e x i s t i n g s t a t e m e n t

( ! v e r i f y u s e r ( ) )

/ /

[ FixMeUp r e p a i r ]

header ( ’ L o c a t i o n :

r e p a i r ]

. / l o g i n . php ’ ) ;

/ /

[ FixMeUp

i f
{

}

$ s q l = ”DELETE FROM b l o g d a t a WHERE p o s t

i d =

$ p o s t

i d ” ;

$query = mysql query ( $ s q l ) o r di e ( ” Cannot q ue ry

t h e d a t a b a s e .<br>” . mysql error ( ) ) ;

$ c o n f i r m =” ” ;
n o t i c e ( ” Del P o s t ” , ” Data D e l e t e d ” ) ;

Access-control template of minibloggie

7
8
9
10
11
12

13
14
15

16

17
18

19 }
20 ?>

i f ( ! $ POST [ ’ i d ’ ]

7
| |
8
9 $ POST [ ’ i d ’ ] = s t r
$ POST [ ’ i d ’ ] ) ;

! $ POST [ ’ f i l e n a m e ’ ] )
r e p l a c e ( array ( ’ . . / ’ ,

e x i t ( ) ;
’ . php ’ ) ,

’ ’ ,

10 $ POST [ ’ f i l e n a m e ’ ] = s t r

r e p l a c e ( array ( ’ . . / ’ ,

’ . php ’ )

,

’ ’ , $ POST [ ’ f i l e n a m e ’ ] ) ;

/ / @SSO( ’ admin ’ )

11
12 @unlink ( ’ d a t a / ’ . $ POST [ ’ i d ’ ] . ’ / ’ . $ POST [ ’ f i l e n a m e ’ ] ) ;
. . .
13
14 ?>

Correct repair of swfupload ok.php

1

i f

( i s s e t ( $ POST [ ”PHPSESSID” ] ) )

PHPSESSID” ] ) ;

s e s s i o n i d ( $ POST [ ”

i n c l u d e

2
3
4 $GR = new COMMON( ) ;
5
6

’ c l a s s / common . php ’ ;
e x i s t i n g s t a t e m e n t
( ! $ SESSION [ ’ no ’ ] ) { / /
$GR−>e r r o r ( ’ R e q u i r e l o g i n p r o c e d u r e ’ ) ;

[ FixMeUp r e p a i r ]
/ /

i f

/ /

/ /

e x i s t i n g s t a t e m e n t

[ FixMeUp

7 }

r e p a i r ]

8
9

. . .
i f ( time ( ) > 600+ @filemtime ( $tmp ) ) $tmpFS = @fopen (

e l s e $tmpFS = @fopen ( $tmp ,

’ a ’ ) ;

$tmp ,

’w’ ) ;
/ / @SSO( ’ member ’ )

10
11 @fwrite ( $tmpFS , $ s a v e R e s u l t ) ;
12 @fclose ( $tmpFS ) ;

Figure 13: GRBoard: Same ACT in different contexts

already present alternative policy. Line 13 shows an access-
control check already present in slidesshow.php. Because
the policy implemented by the existing check does not
match the ACT that prescribes additional checks for the ad-
ministrator role, FIXMEUP inserts Line 3-11. However, the
function call on Line 8 has a side effect on $ SESSION
and $ COOKIE which are used in the function call at Line
13. This side effect is easy to detect with standard depen-
dence analysis, but the reason it occurred is a faulty anno-
tation:
the access-control policy represented by the ACT
should not have been applied to this context.

We reported the new vulnerabilities found by FIXMEUP
and they were assigned CVE candidate numbers: CVE-
2012-2443, 2444, 2445, 2437 and 2438. We conﬁrmed the
correctness of our repairs by testing each program and ver-
ifying that it is no longer vulnerable. When an unautho-
rized user invokes the repaired applications through either
an intended or unintended entry point and attempts to ex-
ecute the sensitive operation, every repaired application re-
jects the attempt and executes the code corresponding to the
failed check from the original ACT.
7 Related Work
Related work includes techniques for ﬁnding access-control
bugs, since it is a necessary ﬁrst step to repairing them, gen-
eral bug ﬁnding, program repair, and transformation tools.

i n c l u d e ” c o n f . php ” ;
i n c l u d e o n c e ” i n c l u d e s . php ” ;
s e s s i o n s t a r t ( ) ;

1 <?
2 1 . ProgramEntry
3
4
5
6 dbConnect ( ) ;
7
8

( ! v e r i f y u s e r ( ) ) {
header ( ’ L o c a t i o n :

. / l o g i n . php ’ ) ;

i f
9 }
10 ?>

Figure 12: minibloggie: Attempted repair

plate for each target is critical to successful repair.

Figure 13 shows repairs to GRBoard in remove
multi f ile.php and swf upload ok.php. These two ﬁles
implement different access-control logic to protect role-
speciﬁc sensitive operations. Observe that $GR variable in
swf upload ok.php is not renamed and the existing vari-
able is used instead, i.e., $GR = new COMMON() at line
4. On the other hand, in remove multi f ile.php, FIX-
MEUP deﬁnes a new variable $GR newone to avoid un-
wanted dependences when it inserts this statement.

Figure 11 also shows how FIXMEUP leaves line 2 in-
tact in process.php when applying the template based on
AddDn.php. This reuse is crucial for correctness. Had
FIXMEUP naively inserted this statement from the template
rather than reuse the existing statement, the redundant, du-
plicated statement would have introduced an unwanted de-
pendence because this function call has a side effect on the
$ SESSION variable. Because of statement reuse, how-
ever, this dependence remains exactly the same in the re-
paired code as in the original.

The last column demonstrates that the inserted state-
ments in 37 repair instances introduce no unwanted depen-
dences that affect the rest of the program. Figure 14 shows
one instance where a repair had a side effect because of an

slidesshow.php

. . .

1
2 $ g i d =$ GET [ ’ g i d ’ ] ;
3 $form pw newone = $ POST [ ’ form pw ’ ] ;

/ / e x i s t i n g s t a t e m e n t s

/ /

[ FixMeUp

r e p a i r ]

. . . .
i f

( ! c h e c k a d m i n l o g i n ( ) ) { / /
i f

( ( s t r l e n ( $ g i d i n f o [ ’ g a l l e r y p a s s w o r d ’ ] ) > 0 ) ) {

[ FixMeUp r e p a i r ]

4
5
6

7
8

9

10

12
13

11 }

}
. . . .
i f

14
15

16 }

/ /

[ FixMeUp r e p a i r ]

/ / @ACC( ’ g u e s t ’ )
i f

( ! c h e c k g a l l e r y p a s s w o r d ( $ g i d i n f o [ ’

g a l l e r y p a s s w o r d ’ ] , $form pw newone ) ) { / /
FixMeUp r e p a i r ]

[

’ f a c e b e g i n . php . mphp ’ ) ;

i n c l u d e ( $TEMPLATE DIR .
[ FixMeUp r e p a i r ]

/ /

e r r o r ( y ( ’ Password i n c o r r e c t . ’ ) ) ;
}

r e p a i r ]

/ /

[ FixMeUp

( ! c h e c k g a l l e r y p a s s w o r d ( $ g i d i n f o [ ’

g a l l e r y p a s s w o r d ’ ] , $form pw ) ){
i n c l u d e ( $TEMPLATE DIR .
e r r o r ( y ( ” Password i n c o r r e c t . ” ) ) ;

’ f a c e b e g i n . php . mphp ’ ) ;

Figure 14: YaPiG: Attempted repair

Static detection of access-control bugs. Prior work sim-
ply reports that certain statements are reachable without an
access-control check. Sun et al. require the programmer
to specify the intended check for each application role and
then automatically ﬁnd execution paths with unchecked ac-
cess to the role’s privileged pages [36]. Chlipala ﬁnds secu-
rity violations by statically determining whether the appli-
cation’s behavior is consistent with a policy speciﬁed as a
database query [5].

One consequence of access-control bugs in Web appli-
cations is that attackers may perform unintended page nav-
igation. Several approaches ﬁnd these unintended naviga-
tion ﬂows [2, 10]. They generally rely on heuristics and/or
dynamic analysis to learn the intended ﬂows and are thus
incomplete. Furthermore, they cannot detect ﬁner-grained
access-control bugs. For example, a missing check on the
same page as the protected operation will not manifest as an
anomalous page navigation.

Without a programmer-provided speciﬁcation, static
analysis may infer the application’s access-control poli-
cies. Son and Shmatikov use consistency analysis to ﬁnd
variables in access-control logic [33]. Son et al. devel-
oped RoleCast, a tool that ﬁnds role-speciﬁc access-control
checks without speciﬁcation by exploiting software engi-
neering conventions common in Web applications [32].

None of these approaches automatically repair the bugs
they ﬁnd, whereas FIXMEUP (1) computes code templates
that implement access-control logic, (2) ﬁnds calling con-
texts that implement this logic incorrectly, (3) transforms
the code by inserting the template into one or more methods
in the vulnerable contexts, and (4) validates that the trans-
formed code implements the correct logic.

Code mining. A popular bug ﬁnding approach is to mine

the program for patterns and looks for bugs as deviations or
anomalies. This approach typically ﬁnds frequently occur-
ring local, intraprocedural patterns [9]. Tan et al. showed
how to ﬁnd access-control bugs in SELinux using similar
techniques, but with interprocedural analysis [37]. When
applied to Web applications, heuristics based on ﬁnding de-
viations from common, program-wide patterns will likely
generate an overwhelming number of false positives. As
shown in [36] and [32], access-control logic in Web appli-
cations is signiﬁcantly more sophisticated than simple “this
check must always precede that operation” patterns. They
are role- and context-sensitive, with different policies en-
forced on different execution paths. Simple pattern match-
ing won’t ﬁnd violations of such policies.

Verifying access control in Java libraries. Access-
control checks are standardized in Java libraries and are
simply calls to the SecurityManager class. A rich body
of work developed techniques for verifying access control
in Java class libraries [16, 29, 31, 35], but none of them
attempt to repair access-control bugs.
Dynamic detection of access-control bugs. In the secu-
rity domain, dynamic analysis ﬁnds security violations by
tracking program execution [4, 7, 12, 43]. For example,
Hall´e et al. dynamically ensure that page navigation within
the application conforms to the state machine speciﬁed by
the programmer [12]. GuardRails requires the develop-
ers to provide explicit access-control speciﬁcations and en-
forces them dynamically within its framework for Ruby [3].
Alternatives to explicit speciﬁcation include learning the
state machine by observing benign runs and then relying
on anomaly detection to ﬁnd violations [6], or using static
analysis of the server code to create a conservative model
of legitimate request patterns and detecting deviations from
these patterns at runtime [11]. Violations caused by missing
access-control checks are an example of generic “execution
omission” bugs. Zhang et al. presented a general dynamic
approach to detecting such bugs [44].

In addition to the usual challenges of dynamic analy-
sis, such as incomplete coverage, dynamic enforcement of
access-control policies is limited in what it can do once
it detects a violation. Typically, the runtime enforcement
mechanism terminates the application since it does not
know what the programmer intended for the application to
do when an access-control check fails.

By contrast, our objective is to repair the original pro-
gram. In particular, for the program branch corresponding
to a failed access-control check, we insert the exact code
used by the programmer as part of the correct checks (it
may generate an error message and return to the initial page,
terminate the program, etc.). The repaired program thus be-
haves as intended, does not require a special runtime envi-
ronment, and can be executed anywhere.
Dynamic repair of software bugs. Dynamic program

repair ﬁxes the symptom, but not the cause of the er-
ror [4, 7, 12, 22, 30, 43]. For example, dynamic repair
allocates a new object on a null-pointer exception, or ig-
nores out-of-bounds references instead of terminating the
program. The dynamic ﬁxes, however, are not reﬂected in
the source code and require a special runtime.

Static detection of injection vulnerabilities. Many tech-
niques detect data-ﬂow vulnerabilities, such as cross-site
scripting and SQL injection [13, 15, 17, 39, 42]. These bugs
are characterized by tainted inputs ﬂowing into database
queries and HTML content generation. Access-control bugs
are control-ﬂow vulnerabilities: they enable the attacker to
execute a sensitive operation, which may or may not be ac-
companied by illegitimate data ﬂows. For example, if a con-
stant query deletes the database, there is no tainted data ﬂow
into the operation.

Automatic remediation of software bugs. Much prior
work ﬁnds code clones within the same application to help
programmers refactor, ﬁx bugs, and add features consis-
tently [8, 18, 20, 23, 38]. These tools suggest where a bug
ﬁx may be needed, but do not transform the program. FIX-
MEUP solves the dual of this problem:
it inserts similar
code where it is missing.

Several tools learn from a developer-provided ﬁx and
help apply similar ﬁxes elsewhere. They perform the same
syntactic edit on two clones [21], or suggest changes for
API migration [1], or do not perform the edit [23], or ask
users where to apply the edit [19]. These approaches only
apply local edits and none of them consider the interproce-
dural edits that are required to repair access-control logic.
In the more limited domain of access-control bugs, we au-
tomate both ﬁnding the missing logic and applying the ﬁx.

Generating program ﬁxes. A few approaches automati-
cally generate a candidate patch and then check correctness
with compilation and testing. For example, Perkins et al.
generate patches to enforce invariants that are are observed
in correct executions but violated in erroneous ones [25].
They test several patched executions and select the most
successful one. Weimer et al. [40, 41] generate candidate
patches by randomly replicating, mutating, or deleting code
from the program. Jin et al. automatically ﬁx bugs by ﬁnd-
ing violations of pre-deﬁned patterns encoded as ﬁnite-state
machines, such as misplaced or missing lock and unlock
pairs [14]. Their static analysis moves or inserts one or
two lines of code to satisfy the correct pattern. All of these
approaches focus on one- or two-line changes that satisfy
some dynamic or static local predicate. By contrast, FIX-
MEUP extracts and inserts multi-line code sequences re-
sponsible for enforcing the application’s context-sensitive
access-control policy.

8 Conclusion
We presented FIXMEUP, the ﬁrst static analysis and pro-
gram transformation tool for ﬁnding and repairing access-
control bugs in server-side Web applications. FIXMEUP
starts with an access-control policy that maps security-
sensitive operations—such as database queries and privi-
leged ﬁle operations—to access-control checks that protect
them from unauthorized execution. FIXMEUP then auto-
matically extracts the code responsible for access-control
enforcement, uses it to create an access-control template,
ﬁnds calling contexts where the check is missing or im-
plemented incorrectly, repairs the vulnerability by applying
the template, and validates the repair. The key to seman-
tically correct repairs is the novel algorithm that ﬁnds and
reuses existing statements that are part of the access-control
logic. In particular, reuse of existing statements helps FIX-
MEUP avoid duplicating statements that have side effects
on the rest of the program. FIXMEUP successfully repaired
30 access-control bugs in 10 real-world PHP applications,
demonstrating its practical utility.
Acknowledgments. This research was partially supported
by the NSF grants CNS-0746888, SHF-0910818, CCF-
1018271, and CNS-1223396, a Google research award,
the MURI program under AFOSR Grant No. FA9550-
08-1-0352, and the Defense Advanced Research Agency
(DARPA) and SPAWAR Systems Center Paciﬁc, Contract
No. N66001-11-C-4018.
References
[1] J. Andersen and J. Lawall. Generic patch inference. In ASE,

pages 337–346, 2008.

[2] D. Balzarotti, M. Cova, V. Felmetsger, and G. Vigna. Multi-
module vulnerability analysis of Web-based applications. In
CCS, pages 25–35, 2007.

[3] J. Burket, P. Mutchler, M. Weaver, M. Zaveri, and D. Evans.
GuardRails: A data-centric Web application security frame-
work. In USENIX WebApps, 2011.

[4] W. Chang, B. Streiff, and C. Lin. Efﬁcient and extensible
security enforcement using dynamic data ﬂow analysis. In
CCS, pages 39–50, 2008.

[5] A. Chlipala. Static checking of dynamically-varying se-
In OSDI,

curity policies in database-backed applications.
pages 105–118, 2010.

[6] M. Cova, D. Balzarotti, V. Felmetsger, and G. Vigna. Swad-
dler: An approach for the anomaly-based detection of state
violations in Web applications. In RAID, pages 63–86, 2007.
[7] M. Dalton, C. Kozyrakis, and N. Zeldovich. Nemesis: Pre-
venting authentication and access control vulnerabilities in
In USENIX Security, pages 267–282,
Web applications.
2009.

[8] E. Duala-Ekoko and M. Robillard. Tracking code clones in

evolving software. In ICSE, pages 158–167, 2007.

[9] D. Engler, D. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs
as deviant behavior: A general approach to inferring errors
in systems code. In SOSP, pages 57–72, 2001.

[10] V. Felmetsger, L. Cavedon, C. Kruegel, and G. Vigna. To-

ward automated detection of logic vulnerabilities in Web ap-
plications. In USENIX Security, pages 143–160, 2010.

[11] A. Guha, S. Krishnamurthi, and T. Jim. Using static analy-
sis for Ajax intrusion detection. In WWW, pages 561–570,
2009.

[12] S. Hall´e, T. Ettema, C. Bunch, and T. Bultan. Eliminating
navigation errors in Web applications via model checking
and runtime enforcement of navigation state machines. In
ASE, pages 235–244, 2010.

[13] Y. Huang, F. Yu, C. Hang, C. Tsai, D. Lee, and S. Kuo. Se-
curing Web application code by static analysis and runtime
protection. In WWW, pages 40–52, 2004.

[14] G. Jin, L. Song, W. Zhang, S. Lu, and B. Liblit. Automated
atomicity-violation ﬁxing. In PLDI, pages 389–400, 2011.
[15] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static anal-
In

ysis tool for detecting Web application vulnerabilities.
S&P, pages 258–263, 2006.

[16] L. Koved, M. Pistoia, and A. Kershenbaum. Access rights

analysis for Java. In OOPSLA, pages 359–372, 2002.

[17] B. Livshits, A. Nori, S. Rajamani, and A. Banerjee. Merlin:
Speciﬁcation inference for explicit information ﬂow prob-
lems. In PLDI, pages 75–86, 2009.

[18] J. Mayrand, C. Leblanc, and E. Merlo. Experiment on the
automatic detection of function clones in a software system
using metrics. In ICSM, 1996.

[19] N. Meng, M. Kim, and K. McKinley. Systematic editing:
In

Generating program transformations from an example.
PLDI, pages 329–342, 2011.

[20] R. Miller and B. Myers.

Interactive simultaneous editing
of multiple text regions. In USENIX ATC, pages 161–174,
2001.

[21] H. Nguyen, T. Nguyen, G. Wilson Jr., A. Nguyen, M. Kim,
and T. Nguyen. A graph-based approach to API usage adap-
tation. In OOPSLA, pages 302–321, 2010.

[22] H. Nguyen and M. Rinard. Detecting and eliminating mem-
ory leaks using cyclic memory allocation. In ISMM, pages
15–29, 2007.

[23] T. Nguyen, H. Nguyen, N. Pham, J. Al-Kofahi, and
T. Nguyen. Recurring bug ﬁxes in object-oriented programs.
In ICSE, pages 315–324, 2010.

[24] OWASP top 10 application security risks. https://www.

owasp.org/index.php/Top_10_2010-Main,
2010.

[25] J. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach,
M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sul-
livan, W.-F. Wong, Y. Zibin, M. Ernst, and M. Rinard. Au-
tomatically patching errors in deployed software. In SOSP,
pages 87–102, 2009.

[26] PHC: the open source php compiler.

http://www.

phpcompiler.org.

[27] PHP. http://www.php.net.
[28] PHP

advent

2010:

Usage

statistics.

http://phpadvent.org/2010/
usage-statistics-by-ilia-alshanetsky.

[29] M. Pistoia, R. Flynn, L. Koved, and V. Sreedhar. Interpro-
cedural analysis for privileged code placement and tainted
variable detection. In ECOOP, pages 362–386, 2005.

[30] M. Rinard, C. Cadar, D. Dumitran, D. Roy, T. Leu, and
W. Beebee.
Enhancing server availability and security
through failure-oblivious computing. In OSDI, pages 303–
316, 2004.

[31] A. Sistla, V. Venkatakrishnan, M. Zhou, and H. Branske.
CMV: Automatic veriﬁcation of complete mediation for
Java Virtual Machines. In ASIACCS, pages 100–111, 2008.
[32] S. Son, K. McKinley, and V. Shmatikov. RoleCast: Finding
missing security checks when you do not know what checks
are. In OOPSLA, pages 1069–1084, 2011.

[33] S. Son and V. Shmatikov. SAFERPHP: Finding semantic

vulnerabilities in PHP applications. In PLAS, 2011.

[34] M. Sridharan, S. Fink, and R. Bodik. Thin slicing. In PLDI,

pages 112–122, 2007.

[35] V. Srivastava, M. Bond, K. McKinley, and V. Shmatikov. A
security policy oracle: Detecting security holes using multi-
ple API implementations. In PLDI, pages 343–354, 2011.

[36] F. Sun, L. Xu, and Z. Su. Static detection of access control
In USENIX Security,

vulnerabilities in Web applications.
2011.

[37] L. Tan, X. Zhang, X. Ma, W. Xiong, and Y. Zhou. AutoISES:
Automatically inferring security speciﬁcations and detecting
violations. In USENIX Security, pages 379–394, 2008.

[38] M. Toomim, A. Begel, and S. Graham. Managing duplicated
code with linked editing. In VLHCC, pages 173–180, 2004.
[39] G. Wasserman and Z. Su. Sound and precise analysis of Web
applications for injection vulnerabilities. In PLDI, pages 32–
41, 2007.

[40] W. Weimer, S. Forrest, C. Le Goues, and T. Nguyen. Auto-
matic program repair with evolutionary computation. Com-
mun. ACM, 53(5):109–116, 2010.

[41] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest. Au-
tomatically ﬁnding patches using genetic programming. In
ICSE, pages 364–374, 2009.

[42] Y. Xie and A. Aiken. Static detection of security vulnera-
bilities in scripting languages. In USENIX Security, pages
179–192, 2006.

[43] A. Yip, X. Wang, N. Zeldovich, and F. Kaashoek. Improv-
ing application security with data ﬂow assertions. In SOSP,
pages 291–304, 2009.

[44] X. Zhang, S. Tallam, N. Gupta, and R. Gupta. Towards lo-
cating execution omission errors. In PLDI, pages 415–424,
2007.

