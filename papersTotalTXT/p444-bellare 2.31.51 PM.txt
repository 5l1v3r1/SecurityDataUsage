Message-Recovery Attacks on

Feistel-Based Format Preserving Encryption

Mihir Bellare

Viet Tung Hoang

Dept of CS and Engineering

UC San Diego, USA

Dept of Computer Science

Florida State University, USA

Stefano Tessaro

Dept of Computer Science
UC Santa Barbara, USA

ABSTRACT

We give attacks on Feistel-based format-preserving encryp-
tion (FPE) schemes that succeed in message recovery (not
merely distinguishing scheme outputs from random) when
the message space is small. For 4-bit messages, the at-
tacks fully recover the target message using 221 examples
for the FF3 NIST standard and 225 examples for the FF1
NIST standard. The examples include only three messages
per tweak, which is what makes the attacks non-trivial even
though the total number of examples exceeds the size of the
domain. The attacks are rigorously analyzed in a new deﬁni-
tional framework of message-recovery security. The attacks
are easily put out of reach by increasing the number of Feistel
rounds in the standards.

INTRODUCTION

1.
Format-preserving encryption (FPE) schemes based on Feis-
tel were standardized by NIST in [7] and are in widespread
use for the encryption of credit card numbers. This paper
gives new attacks on these schemes that succeed in message
recovery in the case that the message space is small.

FPE. An FPE scheme [1, 5] speciﬁes a deterministic en-
cryption function F.E : F.Keys × F.Twk × F.Dom → F.Dom
that takes a key K, a tweak T and a message X to return
a ciphertext Y = F.E(K, T, X). There is a corresponding
decryption function F.D : F.Keys× F.Twk× F.Dom → F.Dom
such that the maps F.E(K, T, ·), F.D(K, T, ·) are permuta-
tions over F.Dom that are inverses of each other.
What makes an FPE scheme special —compared to a
tweakable blockcipher [8]— is that the domain F.Dom can be
arbitrary, and, most importantly, can be very small. Some
examples are F.Dom = {0, 1}8 (encrypt a byte so that the ci-
phertext is also a byte), F.Dom = Z4
10 (encrypt a 4 digit PIN
so that the ciphertext is also four decimal digits), F.Dom =
Z16
10 (encrypt a 16-digit credit-card number so that the re-
sult is also a 16-digit credit-card number). FPE is motivated
by legacy constraints which in many systems mandate that

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.

CCS’16, October 24-28, 2016, Vienna, Austria

c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978390

the ciphertext replace the plaintext, and must thus have the
same “format” as the plaintext.

Schemes and standardization. FPE is harder than it may
look. Blockciphers like AES can encipher 128-bit messages
but it isn’t clear how to encipher messages of length signif-
icantly shorter than 128. The main paradigm for FPE has
been to use a Feistel network. Feistel based FPE schemes
were given in [5, 1]. (Tweaking is done by incorporating the
tweak as an input to the round functions.) The growing use
of FPE led to interest in standardization. Several submis-
sions were made to NIST [4, 6, 3]. Based on these, in March
2016, NIST SP 800-38G [7] standardized two Feistel-based
FPE schemes, FF1 and FF3.

In Fig. 3 we specify Feistel-based FPE in a general and
parameterized way. Prior schemes, including the standards,
are special cases, and our attacks apply to all of these.

Summary. This paper has three main contributions:
(1)
New message recovery attacks on Feistel-based FPE that
are practical for small messages (2) A deﬁnitional frame-
work for message recovery security that allows us to pre-
cisely say what our attacks accomplish and why they are
interesting (3) Rigorous analyses establishing lower bounds
on the advantages of the attacks in our framework.

For the purpose of this Introduction, we take, as illustra-
tive example, balanced Feistel with F.Dom = {0, 1}2n. We
denote by r ≥ 2 the number of Feistel rounds. It is r = 10
for FF1 and r = 8 for FF3. Prior attacks and our new ones
are summarized in Fig. 1. Our attacks are the ﬁrst to have
all of the following properties: they succeed in (partial or
full) recovery of the target message, not just in distinguish-
ing outputs of the FPE from random; they have advantage
as close to one as possible, rather than very small; and they
succeed given a number Q of examples —an example is a
tweak, ciphertext pair (T, Y ) possessed by the adversary—
that, for the values of r in the standards, makes the attacks
feasible for small n.

There has been a misconception that attacks using a num-
ber Q of examples in excess of the size 22n of the domain
are uninteresting. This is not necessarily true. It depends
on the nature of the examples. Amongst the elements that
make our attacks non-trivial are that they involve only a
tiny number qe of examples for any particular tweak and en-
cryptions of the target message are provided only under a
tiny number of tweaks. In this case, FPE ought to provide
very good security even for a number Q of examples well in
excess of the domain size. We are saying that Feistel-based
FPE with the standardized number of rounds fails to do so
on small message spaces.

444Attack
Name

Attack type

Advantage ǫ

Number of
tweaks, qt

Examples

per tweak, qe

Source

Distinguishing

Distinguishing

Recovery of left half of message

LHR

RHR

FMR

Recovery of left half of message

Recovery of right half of message

Recovery of entire message

2−(r−2)n

1/3

2−(r−2)n
1 − 2/2n
1 − 2/2n
1 − 2/2n

1

2 · 2(r−2)n

1

24(n + 4) · 2(r−3)n
24(n + 4) · 2(r−2)n
24(n + 4) · 2(r−2)n

2

2

2

2

2

3

[9]

[11]

[1]

Here

Here

Here

Figure 1: Attack parameters and eﬀectiveness. This is for balanced-Feistel FPE with domain {0, 1}2n (n ≥ 2) and r
rounds. We show the type of attack (distinguishing from random, or recovery, of part or all of the message), and the advantage
(success probability of the attack). The number of examples used is Q = qt · qe, broken down into the number qt of tweaks
involved and the number qe of examples per tweak. The running time of all attacks is O(Q).

r = 8 (FF3)

r = 10 (FF1)

2n

4

8

ǫ

1/2

14/16

Q

221
232
253

ǫ

1/2

14/16

63/64

Q

225
240
267

14

63/64

Figure 2: Attack numbers. We show the advantage and
number of examples for the FMR attack for various input
lengths 2n and the number of rounds of the standards.

Prior deﬁnitions for message recovery security [1] cannot
capture the distinctions we make above. The purpose and
value of our new deﬁnitional framework for message-recovery
security is to elucidate when an attack is non-trivial.
It
is so when the adversary advantage under our deﬁnition is
large. Beyond this, our framework allows us to capture ﬁne-
grained distinctions between attacks (for example, full versus
partial plaintext recovery, known versus unknown example
plaintexts, ...) allowing theorem statements about attacks
that are correspondingly ﬁne-grained and informative.

It is common to have theorems, making precise statements
and giving rigorous proofs, in support of security. Such the-
orems give upper bounds on adversary advantage. It is less
common than it should be to have similarly rigorous the-
orems about attacks, giving lower bounds on adversary ad-
vantage. We give such theorems for our attacks, in the model
where the Feistel round functions are random. The analyses
establishing this were challenging and also allow us to give
rigorous and improved analyses of some prior attacks.

The second table in Fig. 2 shows, for the full message re-
cover (FMR) attack on the standardized schemes FF3 and
FF1, the advantage ǫ and number of examples Q, for dif-
ferent message lengths 2n. The attack is feasible for 4-bit
messages and 8-bit messages. At 14-bit messages —this cor-
responds roughly to four decimal digits, the subset of the
digits of the credit-card number that is encrypted in many
FPE-based credit-card transactions— the attacks are not
practical. In all cases, the attacks are signiﬁcantly faster for
FF3 than for FF1.

The attacks can be defended against quite simply by in-
creasing the number of rounds on small inputs. The BRS [4]
submission to NIST had, in fact, speciﬁed the number of

rounds as a function of the input length. The r = 10 rounds
adopted by NIST for FF1 was based on BRS’s later adden-
dum [3]. BPS [6] had proposed r = 8 rounds from the start,
and this was adopted for FF3 [7]. Reverting to the formula
of BRS [4] would put our attacks out of reach for the message
spaces they consider. Their suggestion, for FF1 on domain
{0, 1}m, was to use r = 12 rounds if 31 ≤ m ≤ 128, r = 18
rounds if 20 ≤ m ≤ 31, r = 24 rounds if 14 ≤ m ≤ 19, r = 30
rounds if 10 ≤ m ≤ 13, and r = 36 rounds if 8 ≤ m ≤ 9.
BRS [4] do not consider m < 8, although the standard [7]
does.

We now expand on all the above. Our starting point is def-
initions, meaning attack types and taxonomy, because this
is crucial towards determining the eﬀectiveness of attacks.

Types of attacks. A distinguishing attack aims to violate
(tweakable) PRP security [1, 8]. The adversary has an or-
acle taking T, X and returning Y such that either Y =
F.E(K, T, X) for the target key K or Y is the result of a
tweak-determined random permutation on X. In this case
the examples (T1, X1, Y1), . . . , (TQ, XQ, YQ) are triples where
Yi is the result of the oracle on Ti, Xi. The advantage is that
of determining the type of the oracle.

Distinguishing attacks have not been considered a signiﬁ-
cant threat in practice because they do not, in general, ap-
pear to cause any practical damage in envisaged applications
of FPE. The concern in practice, rather, is message recovery.
BRRS [1] give the ﬁrst deﬁnition of message recovery se-
curity for FPE. The adversary gets input (T ∗, Y ∗) where
Y ∗ = F.E(K, T ∗, X ∗), and its goal is to recover the tar-
get message X ∗. To aid in this task, it is allowed Q − 1
queries to an encryption oracle. The latter, given T, X re-
turns Y = F.E(K, T, X). The advantage of the adversary is
the probability that it wins (returns X ∗) minus the prob-
ability that a simulator, on input T ∗, wins (returns X ∗),
given Q − 1 queries to a test oracle. The latter, given X,
returns true if X = X ∗ and false otherwise. The intuition
is that since F.E(K, ·, ·) is deterministic, the adversary can
use its encryption oracle to test candidate plaintexts, so the
simulator gets the same ability via its test oracle.

Notice that the simulator can always win with probability
one when Q ≥ 22n is more than the size of the domain,
because it can simply query all possible messages to its test
oracle. Thus, any adversary making Q− 1 ≥ 22n − 1 queries
to its encryption oracle has zero advantage. Based in part on
this, the conception in this area has been that an attack using

445a number of examples larger than the size of the domain is
trivial and not interesting.

Our framework. We argue that the above conclusion is in-
correct. Attacks can be interesting, non-trivial and of prac-
tical signiﬁcance even when the number of examples is much
more than the size of the domain. We give a new deﬁni-
tion for message recovery security in which this and other
distinctions surface.

In our framework of Section 4, an algorithm XS called a
message sampler produces Q tweak-message pairs (T1, X1),
. . . , (TQ, XQ), a target message X ∗ and auxiliary informa-
tion a. Now let Yi = F.E(K, Ti, Xi) for 1 ≤ i ≤ Q, where K
is the target key. The adversary A gets examples (T1, Y1),
. . . , (TQ, YQ), as well as a. It wins if it outputs the target
message X ∗. Its mr-advantage is its winning probability mi-
nus what we call the mg-advantage of XS. The latter is the
maximum, over all simulators S, of the probability that S,
given T1, . . . , TQ and a, returns X ∗ . The auxiliary infor-
mation encodes partial information about the messages that
the adversary may have. There are no oracles involved.

Now, there are many choices of XS for which we would
expect and want the mr-advantage to be small, even for Q
much larger than the domain size. The instance we consider
here is that, in the list (T1, X1), . . . , (TQ, XQ), the number qe
of times any particular tweak T shows up is very small, much
smaller than the size 22n of the domain, or the number of i
such that Xi = X ∗ is very small. So if X ∗ is (say) random,
the mr-advantage should be small. Our attacks say that, for
the standardized schemes, this advantage is not small.

The problem with the BRRS deﬁnition [1] is that the sim-
ulator queries may all be under the target tweak even if the
adversary makes few queries under the target tweak. Our
deﬁnition models security more accurately by forcing the
simulator to use exactly the same tweaks as the adversary.

Prior attacks. Row 1 of Fig. 1 is a distinguishing attack
of Patarin [9] that in Q = 2 examples gets a distinguish-
ing advantage ǫ ≈ 2−(r−2)n/2. Row 2 is a variant he gives
in [11] which achieves a constant distinguishing advantage
using Q = 4 · 2(r−2)n examples.
BRSS [1] extend Patarin’s ideas [9, 10, 11] to give a mes-
sage recovery attack under their deﬁnition discussed above.
It recovers the left half of a message with known right half.
Thus the target message X ∗ = (L∗, R∗) has a random left
half L∗ and an adversary-known right half R∗. Given T ∗
and target ciphertext Y ∗ = (A∗, B∗) = F.E(K, T ∗, X ∗), the
adversary picks a random left-half L and queries its en-
cryption oracle with T ∗, X for X = (L, R∗) to get back
Y = F.E(K, T ∗, X).
It returns (A⊕A∗⊕L, R∗). The ad-
vantage as per the BRRS deﬁnition is about 2−(r−2)n.
These attacks were known at the time of standardization
but not considered signiﬁcant. In the case of Patarin’s at-
tacks, this is because they are distinguishing attacks that
did not appear to cause any practical damage in envisaged
applications of FPE. In the case of the BRRS attack, the ad-
vantage seems too tiny to matter. For example. say n = 4
(one byte messages). The a priori probability of guessing
the target message is 2−4. The attack recovers the target
message with a probability only marginally higher, namely
2−4(1 + 2−28) ≈ 2−4 in the case r = 10 (FF1). The concern
in practice is message recovery with high advantage.

Overview of our attacks. Our attacks boost the mes-

sage recovery advantage to close to one. This is done by
using more examples than BRRS, but, importantly, there
are very few examples for any given tweak. Our LHR attack,
like the one of BRRS [1], recovers the left half of the message
when the right half is known. Our RHR attack recovers the
right half of the message when the left is known, but using
diﬀerent and more novel techniques. We then put these to-
gether to get the FMR attack recovering the entire target
message. The attack parameters are shown in Fig. 1, and
we now discuss the attacks at a more technical level.

The LHR and RHR attacks target a sampler XS which, for
two plaintexts X and X ′, produces 2qt tweak-message pairs
(T1, X ′), (T1, X), . . . , (Tqt , X ′), target message X ∗ = X, and
some side information a about X and X ′. In particular, the
end goal is recovering X ∗ = X. Here, we illustrate the
main ideas behind the attacks for the special case of r-round
balanced Feistel with F.Dom = {0, 1}2n.
The LHR attack assumes that X and X ′ share the same
right half R and have diﬀerent left halves L 6= L′. Here,
a = (L′, R). The starting point is Patarin’s observation [9,
11] that if Lr and L′
r are left halves of the encryptions of X
r ⊕ L′ is more likely
and X ′ under some tweak, then Lr ⊕ L′
to be L than any other value. This property was exploited
already in the aforementioned distinguishing attacks [9, 11]
and in the low-advantage recovery attack from [1]. In con-
trast, here we show that under many tweaks, this fact can be
exploited to recover L with constant probability – namely, if
Li,r and L′
i,r are the left halves of the encryptions of X and
X ′ under Ti, respectively, the attack analyzes the empirical
i,r ⊕ L′, and takes the most
distribution of the values Li,r ⊕ L′
frequent value as the guess for L. Our analysis shows that
qt = O(2(r−3)n) suﬃces for the guess to be correct with con-
stant probability. While qt is well above the domain size,
the crucial point is that we only obtain two ciphertexts per
tweak for the same two plaintexts, and this should not help
for non-trivial message recovery.

In the RHR attack, the plaintexts X and X ′ are distinct,
but do not satisfy any other relation. Also, a = (L, R′), and
the attack recovers the right half R of X. To understand
the main ideas behind the attack, assume we are given two
encryptions of X and X ′ such that the left halves Lr and L′
r
of the ciphertexts are equal, while their right halves Rr 6= R′
r
diﬀer. Then, we show that R′ ⊕ Rr ⊕ R′
r is more likely to
equal R than any other value. Intuitively, the reason for this
is the similarity between evaluating Feistel in the forward
and backward direction, combined with the ideas from the
LHR attack. However, making this precise requires more
work. Also, this by itself is not useful – we have no control
on whether Lr = Lr′ occurs or not. However, on average,
this will be true once every (roughly) 2n tweaks.
Indeed,
we show that the number of examples required for the RHR
attack to succeed is indeed 2n larger than for the LHR attack,
i.e., qt = O(2(r−2)n).

The ﬁnal FMR attack combines both attacks, and recovers
X when given three ciphertexts per tweak of plaintexts X,
X ′ and X ∗. In conjunction with ciphertexts of X, those of
X ′ will be used to perform the RHR attack ﬁrst, and this
will then allow, together with ciphertexts of X ∗, performing
the LHR attack.

2. NOTATION

If y is a string then |y| denotes its length and y[i] denotes
If X is a ﬁnite set, we let

its i-th bit for 1 ≤ i ≤ |y|.

446x ←$ X denote picking an element of X uniformly at ran-
dom and assigning it to x. Algorithms may be randomized
unless otherwise indicated. Running time is worst case. If A
is an algorithm, we let y ← A(x1, . . . ; r) denote running A
with random coins r on inputs x1, . . . and assigning the out-
put to y. We let y ←$ A(x1, . . .) be the result of picking r
at random and letting y ← A(x1, . . . ; r). We use the code
based game playing framework of [2]. By Pr[G] we denote
the event that the execution of game G results in the game
returning true. If D is a set then Perm(D) denotes the set of
all permutations on D. Let exp(x) denote ex, where e is the
base of the natural logarithm.

3. FPE AND FEISTEL-BASED FPE

FPE. An FPE scheme F speciﬁes a deterministic encryption
algorithm F.E : F.Keys × F.Twk × F.Dom → F.Dom and a
deterministic decryption algorithm F.D : F.Keys × F.Twk ×
F.Dom → F.Dom. The sets F.Keys, F.Twk and F.Dom are,
respectively, the key space, the tweak space and the domain.
For every key K ∈ F.Keys and tweak T ∈ T, the maps
F.E(K, T, ·), F.D(K, T, ·) ∈ Perm(F.Dom) are permutations
over F.Dom that are inverses of each other.

Feistel-based FPE. Feistel-based constructions represent
the currently most important method to obtain FPE. The
FF1 and FF2 standards [7] are both Feistel based. We
now specify Feistel-based FPE in a general, parameterized
way. Particular choices of the parameters allow us to talk
of schemes with ideal round functions or with concrete ones,
and to recover the standards.

We associate to parameters r, M, N, ⊞, PL an FPE scheme
F = Feistel[r, M, N, ⊞, PL]. Here r ≥ 2 is an even integer,
the number of rounds. Integers M, N ≥ 1 deﬁne the domain
of F as F.Dom = ZM × ZN . Let ⊞ be an operation for which
(ZM , ⊞) and (ZN , ⊞) are Abelian groups. We let ⊟ denote
the inverse operator of ⊞, meaning that (X ⊞Y ) ⊟Y = X for
every X and Y . PL = (T , K, F1, . . . , Fr) is a list. It speciﬁes
the set T of tweaks, meaning F.Twk = T . It speciﬁes a set
K of keys, so that F.Keys = K. Finally it speciﬁes round
functions F1, . . . , Fr where Fi : K × T × ZN → ZM if i is
odd, and Fi : K×T × ZM → ZN if i is even. The encryption
and decryption functions of F are shown in Fig. 3.
The simplest instance is the boolean one, where M = 2m
and N = 2n are powers of two. We identify ZM , ZN with
{0, 1}m and {0, 1}n, respectively, and let ⊞ = ⊕ be bit-
wise xor. Classical Feistel was, in this way, boolean. How-
ever FPE schemes sometimes operate on integers, whence
the generalization. The scheme is balanced if M = N and
unbalanced otherwise.

We will focus on the case where the round functions are
random. Proceeding formally, let RF(T , r, M, N ) denote the
:
set of all tuples of functions (G1, . . . , Gr) such that Gi
T × ZN → ZM if i is odd, and Gi : T × ZM → ZN if i is
even. Let T = {0, 1}∗ and let K = RF(T , r, M, N ). Then
for 1 ≤ i ≤ r deﬁne Fi, on input K, T, X, to parse the key
as (G1, . . . , Gr) ← K and simply return Gi(T, X). Now let
PL = (T , K, F1, . . . , Fr). We write Feistel[r, M, N, ⊞] to
denote Feistel[r, M, N, ⊞, PL] for this particular choice of
PL.

Schemes in the standards [7] correspond, in our frame-
work, to particular choices of r, M, N, ⊞, PL. In particular
they specify the round functions using AES. The analysis
of our attacks, as with prior ones, is for Feistel[r, M, N, ⊞],

meaning round functions are truly random. However, the
round functions in the standardized schemes are conjectured
to be PRFs, and this means that the bounds we show on ad-
versary advantage with random round functions translate to
the standards with small diﬀerences.

For X = (L, R) ∈ ZM × ZN , we call L and R the left
segment and right segment of X, respectively. For simplicity,
we assume that 0 is the zero element of the groups (ZM , ⊞)
and (ZN , ⊞).

4. MESSAGE RECOVERY FRAMEWORK
Here we give a new formalization of message-recovery se-

curity, deﬁning the goal our attacks will violate.

Samplers and guessing probability. A message sampler
is an algorithm XS that returns a tuple

((T1, X1), . . . , (TQ, XQ), X, a)

consisting of Q tweak-message pairs called the example tweak-
message pairs, a message X called the target message and
a string a called the auxiliary information. The number of
examples Q is a parameter of XS that is denoted XS.Q. We
require (in our FPE context, for reasons explained below)
the following distinctness condition: the Q pairs (T1, X1),
. . . , (TQ, XQ) are all distinct. On the bottom of Fig. 4 is a
message guessing (mg) game associated to XS and an adver-
sary S. Let

Advmg

XS = max

Pr[Gmg

S

XS (S)] .

This represents the best possible probability at guessing the
target message X given the tweaks and auxiliary informa-
tion. There is nothing cryptographic involved here, and the
probability depends only on the message sampler.

Further parameters and terms of interest for a sampler are
as follows. The number of tweaks of XS, denoted qt, is the
number of distinct values in the list T1, . . . , TQ, meaning the
size of the set {T1, . . . , TQ}. The number of examples per
tweak, denoted qe, is the maximum, over all T , of the size of
the set { i : Ti = T }. A tweak T is called a target tweak
if there is some i such that (T, X) = (Ti, Xi), meaning that
the target message occurs with this tweak, and q∗ denotes
the number of target tweaks. Note that this number could
be zero, one or more than one.

Message recovery security. Let F be an FPE scheme.
Let XS be a message sampler such that T1, . . . , TQ ∈ F.Twk
and X1, . . . , XQ ∈ F.Dom for any ((T1, X1), . . . , (TQ, XQ),
X, a) ∈ [XS]. On the top of Fig. 4 is a message recovery
(mr) game associated to F, XS and an adversary A. Let

Advmr

F,XS(A) = Pr[Gmr

F,XS(A)] − Advmg
XS .

This measures A’s advantage at recovering the target mes-
sage given the tweaks, ciphertexts, and auxiliary informa-
tion.

Discussion. The deﬁnition is a framework parameterized by
the message sampler XS. An attack or a security claim can
be made relative to a particular sampler or, more generally,
a class of samplers. Specifying the sampler(s) allows us to
precisely and formally capture attack features and draw ﬁne-
grained distinctions between attacks.

In the mr game, X1, . . . , XQ represent messages that the
user of the target key K encrypts under tweaks T1, . . . , TQ,
respectively, so that the adversary is in possession of the
tweaks, and of the ciphertexts Y1, . . . , YQ. The adversary is

447F.E(K, T, X)
(L, R) ← X
For i = 1 to r do

If (i mod 2 = 1) then L ← L ⊞ Fi(K, T, R)
Else R ← R ⊞ Fi(K, T, L)

Return (L, R)

F.D(K, T, Y )
(L, R) ← Y
For i = r to 1 do

If i mod 2 = 1 then L ← L ⊟ Fi(K, T, R)
Else R ← R ⊟ Fi(K, T, L)

Return (L, R)

ZM

L0

ZN

R0

K, T

F1

L1

L2

L3

L4

K, T

F2

R1

R2

K, T

F3

K, T

F4

R3

R4

Figure 3: On the left is code for the encryption and decryption algorithms of F = Feistel[r, M, N, ⊞, PL], where
PL = (T , K, F1, . . . , Fr). On the right is an illustration of encryption with r = 4 rounds.

Game Gmr

F,XS(A)

K ←$ F.Keys
((T1, X1), . . . , (TQ, XQ), X, a) ←$ XS
For i = 1, . . . , Q do Yi ← F.E(K, Ti, Xi)
X ∗ ←$ A((T1, Y1), . . . , (TQ, YQ), a)
Return (X ∗ = X)

XS (S)

Game Gmg
((T1, X1), . . . , (TQ, XQ), X, a) ←$ XS
X ∗ ←$ S(T1, . . . , TQ, a)
Return (X ∗ = X)

Figure 4: Games deﬁning message-recovery security
of an FPE scheme F, parameterized by a message
sampler XS.

trying to recover the target message X given the tweaks and
ciphertexts. The auxiliary information a represents partial
information about the messages X1, . . . , XQ that may be
known to the adversary.

A common cryptanalytic setting is a known-message at-
tack. This would be captured in our setting by letting a be a
list of all the non-target messages, meaning all Xi diﬀerent
from X. But our framework is more general, allowing us
to capture attacks where the information the adversary has
about the example messages is partial, for example their ﬁrst
halves. Diﬀerent distributions on the data, as well as rela-
tions between the example and target message, are captured
by diﬀerent choices of XS.

The mg advantage captures the a priori probability of
guessing the target message given the tweaks and auxiliary
information. The mr advantage is the excess of the adver-
sary’s probability of winning the mr game over this mg ad-
vantage. To explain the distinctness condition on the mes-
sage sampler, associate to XS the Q by Q matrix M whose
(i, j)-th entry M [i, j] is the boolean ((Ti, Xi) = (Tj, Xj)).
Given Y1, . . . , YQ, an adversary can immediately compute
the entire matrix M because F.E is deterministic and a per-
mutation for each ﬁxed key and tweak. If we put no restric-
tions on the message sampler, we should thus give S the

matrix M . A simpler alternative, and the one we adopted,
is the distinctness condition, which eﬀectively says that all
non-diagonal entries of the matrix M are false.

In their work giving the ﬁrst theoretical treatment of FPE,
BRRS [1] gave a deﬁnition of message recovery security that
we overviewed in Section 1. Here examples (T1, X1), . . . ,
(TQ−1, XQ−1) are chosen by the adversary and submitted
to an oracle that encrypts them under the target key and
returns ciphertexts Y1, . . . , YQ−1. The adversary also knows
a target tweak T ∗ and an encryption Y ∗ of the target mes-
sage X ∗ under T ∗, and wins if it ﬁnds X ∗. Its advantage is
relative to a simulator who gets Q − 1 queries to an oracle
that, given X returns the boolean (X = X ∗). A weakness
of their deﬁnition is that the simulator’s test queries may
use diﬀerent tweaks than the ones in the examples obtained
by the adversary. BRRS is concerned only with the number
of queries, not their type. As a result, the deﬁnition indi-
cates that any attack with a number of examples in excess
of the domain size has zero advantage and is thus trivial
and un-interesting. But many attacks using a number of ex-
amples more than the domain size are interesting and can
be captured in our framework. In particular, the advantage
ought to remain low if qe is low, even if Q is high. Also,
in the BRRS deﬁnition, the target message is encrypted un-
der only one tweak.
In our terminology, this means there
is exactly one target tweak, q∗ = 1. Our deﬁnition covers
the target message being encrypted under multiple tweaks.
Indeed, our attacks are for a situation where the number
of target tweaks is large. Finally, the BRRS deﬁnition in-
herently captures only a chosen-plaintext attack, meaning
the adversary knows the example messages in their entirety.
There is no language to express the diﬀerence between at-
tacks that know the example messages in their entirety and
ones that do not, yet such a diﬀerence is important in prac-
tice.

The determinant of attack quality and non-triviality is
exactly the mr-advantage as we have deﬁned it. That an at-
tack might be considered non-trivial, despite Q being larger
than the domain, if qe and q∗ are small, is a good rule of
thumb, but one must be careful in using it alone. We will

448discuss these parameters for our attacks but also bound the
mr-advantage.

In our framework, attacks are non-adaptive, meaning ex-
amples cannot depend on prior ciphertexts. This reﬂects
that in practice, it is such attacks that matter much more.
It is much harder to mount an adaptive attack. Deﬁnition-
ally, the adaptive case is more complex. We can extend the
mr game quite easily to this case but there are subtle issues
in trying to extend the mg game that we are not sure how
to address.

We view meeting our deﬁnition as a necessary but not suf-
ﬁcient condition for a scheme to be considered secure. That
is, a feasible attack with high advantage under our deﬁni-
tion indicates the scheme is insecure, but absence of such
an attack does not necessarily mean the scheme is secure, in
particular because there could be a feasible adaptive attack.
In the full version of this paper, we discuss the BRRS
deﬁnition in more detail. We also show that the tweakable
PRP notion [1, 8] implies our mr notion.

5. THE LEFT-HALF RECOVERY ATTACK
The attack. Our ﬁrst attack is given encryptions of two
samples X and X ′ under q tweaks T1, . . . , Tq (for an ap-
propriately large q), together with X ′, where X and X ′
have equal right segment, whereas their left segments dif-
fer. We do not make any assumptions on the distribution of
T1, . . . , Tq, X ′, but assume the left segment of X is uniform,
conditioned on being distinct from the left segment of X ′.
Our ﬁrst attack will recover X, and thus in particular its
(unknown) left segment.

We formalize this using our message-recovery framework.
We want to characterize under what conditions the attack
works. This is done by specifying a class SC1q of samplers,
and then lower bounding the mr-advantage of the attack for
any sampler in this class. We ﬁrst let DC1q be the class
of all algorithms D that output X ′ ∈ ZM × ZN and distinct
T1, . . . , Tq ∈ {0, 1}∗. To any such D we associate the sampler

Sampler XS[D]
(X ′, T1, . . . , Tq) ←$ D ; (L′, R) ← X ′
L ←$ ZN\{L′} ; X ← (L, R) ; a ← X ′
Return ((T1, X ′), (T1, X), . . . , (Tq, X ′), (Tq, X), X, a)

The sampler XS[D] above chooses a target message X that
has the same right segment as the message X ′ produced by
D. The number of examples is Q = 2q; the number of tweaks
is qt = q; the number of target tweaks is q∗ = q; and the
number of examples per tweak is qe = 2. Since X 6= X ′, each
sampler in SC1q satisﬁes the distinctness condition. Finally
we deﬁne SC1q = {XS[D] | D ∈ DC1q]. Note that we do
not prescribe any particular behavior for D. Thus, we are
considering a large class of samplers, as D ranges over DC1q.
Since qe is small, we would expect and desire that adver-
saries have low mr-advantage, even if Q is big. Indeed, an
ideal FPE scheme has this property. Our LHR attack shows
that Feistel-based FPE fails to have this property. The Left-
Half Recovery (LHR) attack LHR against SC1q is given in
Fig. 5. It can recover the left segment of X from the cipher-
texts and the left segment of X ′. Since our mr notion asks
for full message recovery, the right segment of X is included
in a, but this information is not needed for recovering the
left segment of X. Theorem 5.1 below gives a lower bound
on the mr advantage of LHR; this bound is illustrated in
Fig. 6.

1), (T1, C1), . . . , (Tq, C′

q), (Tq, Cq), a)

Adversary LHR((T1, C′
X ′ ← a ; L ← 0 ; (L′, R) ← X ′
For s ∈ ZM do Vs ← 0
For i = 1 to q do

(A, B) ← Ci; (A′, B′) ← C′

i ; s ← A⊟A′ ⊞L′; Vs ← Vs+1

For s ∈ ZM do

If Vs > VL then L ← s

X ← (L, R) ; Return X

Figure 5: The Left-Half Recovery attack.

 1

 0.8

 0.6

FF1

8 bits
9 bits
10 bits
11 bits
12 bits

 30

 35

 40

 45

 50

 55

 60

 0.4

 0.2

 0

 25

 1

 0.8

 0.6

FF3

 0.4

 0.2

 0

 15

8 bits
9 bits
10 bits
11 bits
12 bits

 20

 25

 30

 35

 40

 45

Figure 6: The mr advantage of the Left-Half Recov-
ery attack for binary strings of 8–12 bits. The x-axis
shows the log, base 2, of the number q of ciphertext
pairs, and the y-axis shows Advmr
Feistel[r,M,N,⊞],XS(LHR),
for XS ∈ SC1q. On the top, we use the parameters of
the FF1 standard, meaning that r = 10, and for ℓ-bit
strings, M = 2⌊ℓ/2⌋ and N = 2⌈ℓ/2⌉. At the bottom, we
use parameters of FF3, meaning that r = 8, and for
ℓ-bit strings, M = 2⌈ℓ/2⌉ and N = 2⌊ℓ/2⌋.

Theorem 5.1. Let M ≥ 3, N ≥ 2 and q ≥ 1 be integers,
and let r ≥ 4 be an even integer such that N (r−2)/2 ≥ 2M .
M N(cid:17) and F = Feistel[r, M, N, ⊞].
Let λ =(cid:16)1− 1

M −1(cid:17)2(cid:16)1− 1

Then for any sampler XS in the class SC1q,

Advmr

12·N r−2(cid:17)
F,XS(LHR) ≥ 1 − exp(cid:16) −λM q
− M · exp(cid:16) −λM q

9·N r−2(cid:17) − 1

M −1 .

Ideas of the attack. The key idea of our Left-Half Re-
covery attack relies on the following fact, formalized and
proved in Lemma 5.3, which strengthens a previous result
by Patarin [9], as we explain below. Suppose that we en-
crypt both X = (L, R) and X ′ = (L′, R) under the same
tweak T . Let Lt and Rt be the left and right segments of
the round-t output of X. Deﬁne L′
t for X ′ likewise.
Then, we show that Lt ⊟L′
t is most likely to be L ⊟L′, where
the probability is taken over a uniformly random choice of

t and R′

449Indeed,
1 = L ⊟ L′ with probability 1, and moreover, L2 = L1
2 = L ⊟ L′ is also always
2 = L′

the key K. This is clear for t = 1 and t = 2.
L1 ⊟ L′
and L′
true. For t = 3, let F3 be the third round function. Then
2 .

1, and therefore L2 ⊟ L′

3 = F3(K, T, R′

2) ⊞ L′

L3 = F3(K, T, R2) ⊞ L2, and L′
If R2 6= R′
as L3 and L′

2 then L3 ⊟ L′

3 is uniformly distributed over ZM ,

3 are uniform. However, if R2 = R′

2, then

L3 ⊟ L′

3 = L2 ⊟ L′

2 = L ⊟ L′ .

Therefore, at round t = 3, while much closer to uniform, the
distribution of Lt ⊟L′
t still remains slightly biased toward the
point L ⊟ L′. A bias remains as the round number increases,
although it will decrease exponentially in t. Lemma 5.3 will
concretely quantify this bias.

From the observation above, if we have ciphertexts C =
(A, B) and C ′ = (A′, B′) of X and X ′ = (L′, R) under a
single tweak T , and we know X ′, we can recover the left
segment of X via L = A ⊟ A′ ⊞ L′. This is exactly the
message-recovery attack in [1]. However, compared to ran-
dom guessing the left segment of X, this strategy only fares
a little better, with advantage about 1−1/(M −1)
N (r−2)/2 . To am-
plify the advantage, we need ciphertexts of X and X ′ under
many tweaks. Hence if we have ciphertexts (Ai, Bi) ← Ci
and (A′
i, for i = 1, . . . , q, then the Left-Half Re-
⊞ L′, and
covery attack simply computes all values Ai ⊟ A′
i
output the majority value. In order to properly analyze the
ampliﬁcation process, we will need to develop a ﬁne-grained
understanding of the probability distribution of Lt⊟L′
t which
was not necessary in [1].

i) ← C ′

i, B′

As mentioned above, we’ll need to study Pr[Lt ⊟ L′

t = Z]
for Z ∈ ZM . The point Z = 0 is an outlier; it needs a sepa-
rate Lemma 5.2 below. This lemma will also be used several
times in subsequent proofs for diﬀerent purposes. Lemma 5.2
generalizes a result in [9] for the boolean case; the proof is
in the full version.

Lemma 5.2. Let F = Feistel[r, M, N, ⊞]. Fix distinct
X, X ′ ∈ ZM × ZN , a tweak T ∈ F.Twk, and an even t ∈
{2, 4, . . . , r}. Pick K ←$ F.Keys. Let Lt be the left segment
of the round-t output of X under F.E(K, T, ·). Deﬁne L′
t for
X ′ likewise.

(a) If X and X ′ have the same right segment then

N −1

M N −1 −

1

M ·(M N )(t−2)/2 ≤ Pr[Lt = L′

t] ≤ N −1

M N −1

(b) If X and X ′ have diﬀerent right segments then

N −1

M N −1 ≤ Pr[Lt = L′

t] ≤ N −1

M N −1 +

1

(M N )t/2 .

1

Proof of Theorem 5.1. First we’ll show that Advmg
XS ≤
M −1 . Consider an arbitrary simulator S. The simulator is
given X ′ = (L′, R), and has to guess X = (L, R), where
L ←$ ZM\{L′}. The chance that the simulator can guess
M −1 .
L correctly is at most
Since this bound holds for any simulator,

M −1 , and thus Pr[Gmg

XS (S)] ≤ 1

1

Advmg

XS = max

S

Pr[Gmg

XS (S)] ≤

1

M − 1

.

What’s left is to bound Pr[Gmr
F,XS(LHR)]. Recall that in the
Left-Half Recovery attack, we’ll iterate q times, and in the
ith iteration, we’ll compute a number Si ← A ⊟ A′ ⊞ L′,
where A and A′ are the left segments of the ciphertexts Ci

and C ′
i, respectively. For each number s ∈ ZM , let Vi,s be
the Bernoulli random variable such that Vi,s = 1 if and only
if Si = s. The attack computes Vs = V1,s + · · · + Vq,s, ﬁnds
a number z such that Vz = maxs∈ZM {Vs}, and then outputs
z as the left segment of the target message X. Note that
for any ﬁxed s ∈ ZM , the random variables V1,s, . . . , Vq,s are
independent and identically distributed.
Let s∗ be the left segment of X and p = N
M N −1 . If we use an
ideal FPE instead of F, then for each s ∈ ZM , Pr[V1,s = 1]
is exactly p. In Lemma 5.3 below, we’ll show that although
F is not ideal, for any s ∈ ZM\{s∗}, Pr[V1,s = 1] ≤ p. Yet
the attack succeeds, because Pr[V1,s∗ = 1] ≥ p + ∆, where
∆ = 1−1/(M −1)
N (r−2)/2 . We give the proof of Lemma 5.3 further
below.

(b) Pr[Lt ⊟ L′

Lemma 5.3. Let F = Feistel[r, M, N, ⊞]. Fix distinct
X, X ′ ∈ ZM × ZN of the same right segment, T ∈ F.Twk,
and an even integer t ∈ {2, 4, . . . , r}. Pick K ←$ F.Keys. Let
Lt and L′
t be the the left segment of the round-t output of X
and X ′ under F(K, T, ·), respectively. Then
(a) Pr[Lt ⊟ L′

t = L0 ⊟ L′
t = Z] ≤ N

M N −1 + 1−1/(M −1)
N (t−2)/2 .

0] ≥ N
M N −1 , for any Z ∈ ZM\{L0 ⊟ L′

0}.
The probabilities above are taken over a random sampling
K ←$ F.Keys.
To analyze the advantage, our goal is to give (i) an up-
per bound bound for the probability that Vs < q(p + ∆/2)
for every s ∈ ZM\{s∗}, and (ii) a lower bound for the
probability that Vs∗ > q(p + ∆/2). By standard Chernoﬀ
12·N r−2(cid:17), whereas
bounds, Pr[Vs∗ ≤ q(p + ∆/2)] ≤ exp(cid:16) −λM q
9·N r−2(cid:17). We’ll elaborate the
Pr[Vs ≥ q(p + ∆/2)] ≤ exp(cid:16) −λM q

details in the full version.
Hence the adversary LHR can correctly guess s∗ with prob-
ability at least

1 − Pr[Vs∗ ≤ q(p + ∆/2)] − Xs∈ZM \{s∗}

Pr[Vs ≥ q(p + ∆/2)]
12·N r−2(cid:17) − M · exp(cid:16) −λM q
9·N r−2(cid:17)

≥ 1 − exp(cid:16) −λM q

as claimed.

Proof of Lemma 5.3. Let Hitt(Z) denote the event that
Lt ⊟ L′
t = Z. Recall that we’d like to give a lower bound
for Pr[Hitt(L0 ⊟ L′
0)], and an upper bound for Pr[Hitt(Z)],
for every Z ∈ ZM\{L0 ⊟ L′
0}. Lemma 5.2 already gives
the bound for Pr[Hitt(0)]. For the rest, we use the follow-
ing Lemma 5.4; its proof is deferred to further below. This
lemma shows that (i) Pr[Hitt(Z)] is the same for any Z ∈
ZM\{0, L0 ⊟ L′
0}, and (ii) the gap between Pr[Hitt(L0 ⊟ L′
0)]
and Pr[Hitt(Z)] is at least 1/N (r−2)t for any Z ∈ ZM\{0, L0⊟
L′
0}. Combining these properties with Lemma 5.2, we have
the complete picture of the distribution of Lt ⊟ L′
t, and thus
can derive the desired bounds.

Lemma 5.4. Let F = Feistel[r, M, N, ⊞]. Fix distinct
X, X ′ ∈ ZM × ZN , T ∈ F.Twk, and an even t ∈ {2, 4, . . . , r}.
Pick K ←$ F.Keys. Let Lt and Rt be the left and right seg-
ments of the round-t output of X under F.E(K, T, ·), respec-
t for X ′ likewise. Let Hitt(Z) denote
tively. Deﬁne L′
the event that Lt ⊟ L′
t = Z; the distribution is taken over a
random sampling of K ←$ F.Keys. Then

t and R′

4501. Pr[Hitt(Z)] = Pr[Hitt(Z ′)] for all Z and Z ′ in the set

ZM\{0, L0 ⊟ L′
2. Pr[Hitt(L0 ⊟ L′
ZM\{0, L0 ⊟ L′

0}.
0)] ≥ Pr[Hitt(Z)] + 1
0}.

N (r−2)t , for any Z ∈

Back to the proof of Lemma 5.3, from Lemma 5.4, for any
Z ∈ ZM\{0, L0 ⊟ L′
0}, the probability Pr[Hitt(Z)] is the
same. Then for any Z ∈ ZM\{0, L0 ⊟ L′
0)](cid:17) .
Pr[Hitt(Z)] =

M − 2(cid:16)1− Pr[Hitt(0)]− Pr[Hitt(L0 ⊟ L′

Hence, once we establish the lower bound of the probability
Pr[Hitt(Lt ⊟ L′
t)], using the lower bound of Pr[Hitt(0)] as
given in Lemma 5.2, the upper bound of Pr[Hitt(Z)] will
automatically follow. Next, from Lemma 5.4,

0},

1

Pr[Hitt(L0 ⊟ L′

0)] ≥ Pr[Hitt(Z)] +

1

N (r−2)t ,

for any Z ∈ ZM\{0, L0 ⊟ L′
0}, and thus
1 − Pr[Hitt(L0 ⊟ L′
0)]

= Pr[Hitt(0)] +

XZ∈ZM \{0,L0⊟L′

0}

Pr[Hitt(Z)]

N − 1
M N − 1

+ (M − 2)(cid:16)Pr[Hitt(L0 ⊟ L′

0)] −

1

N (r−2)t(cid:17).

≤
Hence

Pr[Hitt(L0 ⊟ L′

0)] ≥

N

M N − 1

+

1 − 1/(M − 1)

N (r−2)t

,

giving the claimed lower bound for Pr[Hitt(L0 ⊟ L′

0)].

Proof of Lemma 5.4. Let Fi be the round function of F at
round i, and let Gi(·, ·) be Fi(K, ·, ·). We’ll prove that for
any Z in ZM\{0}, if t ≥ 4 then
Pr[Rt−26=R′

t−2]

+ Pr[Hitt−2(Z)]

.

N

(1)

Pr[Hitt(Z)] =

M

We postpone justifying Equation (1). We now show that our
claims are implied by Equation (1), via induction on t.
Proceeding to details, let’s ﬁrst prove the ﬁrst claim. Fix
Z, Z ′ in ZM\{0, L0 ⊟L′
0}. First, consider the base case t = 2.
Since R0 = R′
0, and recall that
2. Hence Pr[Hit2(Z)] and Pr[Hit2(Z ′)]
L2 = L1 and L′
2 = L′
are 0, and the ﬁrst claim holds for the base case. Suppose
that it holds for t − 2, we’ll show that it holds for t as well.
From Equation (1),

0, we have L1 ⊟ L′

1 = L0 ⊟ L′

Pr[Hitt(Z)] =

1
M · Pr[Rt−2 6= R′

t−2] +

1
N · Pr[Hitt−2(Z)] .

Likewise,

Pr[Hitt(Z ′)] =

1
M · Pr[Rt−2 6= R′
From the induction hypothesis,

t−2] +

1
N · Pr[Hitt−2(Z ′)] .

Pr[Hitt−2(Z)] = Pr[Hitt−2(Z ′)] .

Hence

Pr[Hitt(Z)] = Pr[Hitt(Z ′)] .

Next, we’ll prove the second claim. Fix Z ∈ ZM\{0, L0 ⊟
L′
0}. Again, we’ll prove by induction on t. First consider
the base case t = 2. As above, Pr[Hit2(Z) = 0], while

Pr[Hit2(L0 ⊟ L′
0)] = 1. Then the second claim holds for
the base case. Suppose that it holds for t − 2, we’ll show
that it holds for t as well. From Equation (1),

Pr[Hitt(Z)] =

1
M · Pr[Rt−2 6= R′

t−2] +

1
N · Pr[Hitt−2(Z)],

whereas

Pr[Hitt(L0⊟L′

0)] =

Pr[Rt−2 6= R′

t−2]

M

+

From the induction hypothesis,

Pr[Hitt−2(L0 ⊟ L′

0)] ≥ Pr[Hitt−2(Z)] +

Pr[Hitt−2(L0 ⊟ L′

0)]

,

N

1

N (r−2)(t−2)

.

Hence the second claim also holds for t.
We now prove Equation (1). Fix Z ∈ ZM\{0}. Note that

Lt = Lt−1 = Gt−1(T, Rt−2) ⊞ Lt−2, and
L′

t−1 = Gt−1(T, R′

t = L′

t−2) ⊞ L′

t−2 .

On the one hand, since Gt−1 is a truly random function

Pr[Hitt(Z)∧ (Rt−2 6= R′
On the other hand, if Rt−2 = R′
L′

t−2, and thus

t−2)] =

1
M · Pr[(Rt−2 6= R′
t−2 then Lt ⊟ L′

t−2)]. (2)

t = Lt−2 ⊟

Pr[Hitt(Z) ∧ (Rt−2 = R′

t−2)]
= Pr[Hitt−2(Z) ∧ (Rt−2 = R′
t−2 = Z then Lt−3 6= L′

t−2, and thus

t−2)].

(3)

t−3, because Lt−3 = Lt−2

If Lt−2 ⊟ L′
and L′

t−3 = L′

Pr[Rt−2 = R′

t−2 | Hitt−2(Z)] =

1
N

,

since Rt−2 = Gt−2(T, Lt−3) ⊞Rt−3, R′
R′

t−3, and Gt−2 is independent of Lt−3 and L′

t−2 = Gt−2(T, L′

t−3. Hence

t−3) ⊞

1
Pr[Hitt−2(Z) ∧ (Rt−2 = R′
N · Pr[Hitt−2(Z)] . (4)
Combining Equations (2), (3), and (4) yields Equation (1).

t−2)] =

Comparison with prior attacks. Our attack is inspired
by previous distinguishing attacks by Patarin [9, 10, 11] for
the case where M = N = 2n, and ⊞ is the xor opera-
tor.
In the ﬁrst attack [9], given ciphertexts C = (A, B)
and C ′ = (A′, B′) of two known messages X = (L, R) and
X ′ = (L′, R), the distinguisher outputs 1 (meaning the ci-
phertexts are indeed encrypted via Feistel[r, 2n, 2n, ⊕]) if
A⊕A′ = L⊕L′, and outputs 0 (meaning the ciphertexts
are encrypted via an ideal FPE) otherwise. This attack
wins with advantage about ∆ = 1−1/(2n−1)
2(r−2)n/2 . The later at-
tacks [10, 11] improved the advantage to constant by having
ciphertexts of X and X ′ under many tweaks.1 His analy-
ses (see below for a detailed discussion) suggest Θ(2(r−2)n)
tweaks are suﬃcient to distinguish with constant advantage.

Compared with Patarin’s attack, our Left-Half Recovery at-
tack is better in every front:
(i) it can recover the left
segment of the target message, while Patarin’s attack only
distinguishes the ciphertexts from random strings, (ii) it
handles any domain ZN × ZN and any operator ⊞, (iii)
1Note that tweakable block ciphers were introduced by
LRW [8] after Patarin’s work, and Patarin’s wording was
of attacking “independent permutations.” His attacks are
however easily translated to tweakable block ciphers.

451our analysis shows that O(n · 2(r−3)n) ciphertexts are suf-
ﬁcient, whereas Patarin’s only showed the attack succeeds
(in achieving a weaker goal) with a larger number of cipher-
text, namely Θ(2(r−2)n).

2(r−2)n

6= C ′

1), . . . , (Tq, Cq, C ′

q)).

To justify our comparison, we give a concise description
of the most reﬁned of Patarin’s attacks [11], and sketch
an analysis of the resulting advantage following Patarin’s
approach.
(The original paper does not spell out many
of these details, thus some of the following is our own in-
In this distinguishing attack, one is given
terpretation.)
((T1, C1, C ′
In the real game, Ci and
C ′
i are pairs ciphertexts under tweak Ti of the known mes-
sages X = (L, R) and X ′ = (L′, R), respectively.
In the
ideal game, Ci and C ′
i are uniformly chosen from {0, 1}2n
subject to the constraint that Ci
i. Let Vi = 1 if
i = L⊕L′, and Vi = 0 otherwise, where Ai and A′
Ai⊕A′
i
are left segments of Ci and C ′
i in the real game, respectively.
Deﬁne Ui for the ideal game likewise. Let p = 2n
22n−1 and
∆ = 1−1/(2n−1)
. Patarin shows that V1, . . . , Vq are indepen-
dent and identically distributed Bernoulli random variables,
with Pr[V1] ≥ p + ∆. Moreover, U1, . . . , Uq are independent
and identically distributed Bernoulli random variables, with
Pr[U1] = p.
Let V = V1 + · · · Vq and U = U1 + · · · + Uq. Patarin
suggests that q should be picked so that E[V ] − E[U ] ≥
√2 ·(cid:0)pVar[U ] +pVar[V ](cid:1), meaning q ≈ 2 · 2(r−2)n (the
additional factor √2 was not present in the original paper,
but it makes calculations somewhat easier). The distin-
guisher receives (T1, C1, C ′
q) and lets Zi = 1
i = L⊕L′, and Zi = 0 otherwise, where Ai and A′
if Ai⊕A′
i
are left segments of Ci and C ′
It outputs 1
if Z1 + · · · + Zq ≥ E[V ] − √2 · pVar[V ], and outputs 0
1 − PrhV < E[V ] −
PrhU ≥ E[U ] + √2 ·pVar[U ]i ≤

otherwise. In the real game, by Chebyshev’s inequality, the
chance that the distinguisher outputs 1 is at least

√2 ·pVar[V ]i ≥ 1 −

In the ideal game, the chance it outputs 1 is at most

Hence, the distinguisher wins with advantage 1/3. We note
that the attack complexity can in fact be reduced by using
a better concentration bound (like Chernoﬀ) to match what
achieved by our attacks – however, we recall the reader that
we target message recovery.

1), . . . , (Tq, Cq, C ′

i respectively.

=

.

1
3

=

.

2
3

1

1 + 2

1

1 + 2

In the same work, Patarin also suggests an improved distin-
guishing attack, where ℓ > 2 messages per tweak are queried.
The distinguisher picks ℓ distinct messages X1, . . . , Xℓ and
q tweaks T1, . . . , Tq.
It then asks to get the correspond-
ing ciphertexts (C1,1, . . . , C1,ℓ), . . . , (Cq,1, . . . , Cq,ℓ) for each
message-tweak pair. Let Li be the left segment of Xi, and
As,i be the left segments of Cs,i.
In the real game, for
s ∈ {1, . . . , q} and i, j ∈ {1, . . . , ℓ} such that i < j and
Xi and Xj have identical right segments, let Vs,i,j = 1 if
As,i⊕As,j = Li⊕Lj, and let Vs,i,j = 0 otherwise. Now,
the random variables Vs,i,j are dependent Bernoulli ran-
dom variables, as multiple queries are made on the same
tweak. However, Patarin conjectures that there is suﬃcient
independence to apply the above Chebyshev argument while
at the same time choosing ℓ to be suﬃciently large, up to
ℓ = Θ(22n). This would allow for (at best) Θ(23n) possible

pairs i, j such that Xi and Xj have identical right segment,
giving us Θ(q23n) random variables Vs,i,j. Under Patarin’s
conjecture, we can choose q = Θ(2(r−5)n) to have more than
2(r−2)n variables, and apply the above argument.

This would however also result in Θ(2(r−3)n) ciphertexts,
as in our attack, at the cost of an unproved conjecture, and
still for the simpler goal of distinguishing.2

6. THE RIGHT-HALF RECOVERY ATTACK

In the Left-Half Recovery attack, the target message X
and the known message X ′ must have the same right seg-
ment, and the attack recovers the left segment of X.
In
contrast, in the Right-Half Recovery attack, we have no re-
quirement on the relationship between X and X ′, and the
attack will recover the right segment of X.
The attack. Fix an integer q ≥ 1. Let DC2q be the class
of all algorithms D that output X ′ ∈ ZM × ZN and distinct
T1, . . . , Tq ∈ {0, 1}∗. Let SC2 = {XS[D] | D ∈ DC2], where
each sampler XS[D] in SC2q behaves as follows.

Sampler XS[D]
(X ′, T1, . . . , Tq) ←$ D ; (L′, R′) ← X ′
(L, R) ← X ←$ (ZM × ZN )\{X ′} ; a ← (L, R′)
Return ((T1, X ′), (T1, X), . . . , (Tq, X ′), (Tq, X), X, a)

Here the sampler XS[D] picks a target X that is diﬀerent
from the message X ′ produced by D. The number of exam-
ples Q = 2q; the number of tweaks is qt = q; the number
of target tweaks is q∗ = q; and the number of examples per
tweak is qe = 2. Since X 6= X ′, each sampler in SC2q sat-
isﬁes the distinctness condition. The Right-Half Recovery
attack RHR against SC2q is shown in Fig. 7. Since qe is
small, we would expect and desire that adversaries have low
mr-advantage, even if Q is big. Indeed, an ideal FPE scheme
has this property. Our RHR attack shows that Feistel-based
FPE fails to have this property. It can recover the right seg-
ment of X from the ciphertexts and the right segment R′ of
X ′; the left segment of X ′ is not needed. Since our mr no-
tion asks for full message recovery, the auxiliary information
contains the left segment L of X, but this information is not
needed for recovering the right segment of X. Theorem 6.1
below gives a lower bound on the mr advantage of RHR; this
bound is illustrated in Fig. 8.

Theorem 6.1. Let M ≥ 2, N ≥ 3 and q ≥ 1 be inte-
gers, and let r ≥ 6 be an even integer such that M (r−2)/2 ≥
36M 2(cid:17) and F =
2N . Let λ = (cid:16)1 − 1
Feistel[r, M, N, ⊞]. Then for any sampler XS ∈ SC2q,

N −1(cid:17)2(cid:16)1 − 2

N(cid:17)(cid:16)1 − 1

Advmr

F,XS(RHR) ≥ 1 − N · exp(cid:16) −λqN
9 · M r−1(cid:17)
− exp(cid:16) −λqN
12 · M r−1(cid:17) −

1

N − 1

.

Ideas of the attack. The key idea of our Right-Half Re-
covery attack is based on the observation speciﬁed and proved
2We note that Patarin appears to claim a lower attack com-
plexity, but this seems to be due to a small error assuming
that all pairs i, j give two inputs Xi and Xj with equal right
segment for ℓ = Θ(22n), which is easily seen not to be pos-
sible.

4521), (T1, C1), . . . , (Tq, C′

Adversary RHR((T1, C′
(L, R′) ← a ; R ← 0 ; ℓ ← 0 ; p ← 1
For s ∈ ZN do Vs ← 0
For i = 1 to q do

q), (Tq, Cq), a)
N −1 ; ∆ ← 1−1/(N −1)
M (r−2)/2

(A, B) ← Ci ; (A′, B′) ← C′
i
If A = A′ then s ← B ⊟ B′ ⊞ R′ ; ℓ ← ℓ + 1 ; Vs ← Vs + 1

For s ∈ ZN do

If Vs > VR then R ← s

If VR ≤ ℓ(p + ∆/2) then R ← R′
X ← (L, R) ; Return X

Figure 7: The Right-Half Recovery attack.

 1

 0.8

 0.6

FF1

8 bits
9 bits
10 bits
11 bits
12 bits

 35

 40

 45

 50

 55

 60

 65

 0.4

 0.2

 0

 30

 1

 0.8

 0.6

FF3

 0.4

 0.2

 0

 20

8 bits
9 bits
10 bits
11 bits
12 bits

 25

 30

 35

 40

 45

 50

 55

Figure 8: The mr advantage of the Right-Half
Recovery attack for binary strings of 8–12 bits.
The x-axis shows the log, base 2, of the num-
ber q of ciphertext pairs, and the y-axis shows
Advmr
Feistel[r,M,N,⊞],XS(RHR), for XS ∈ SC2q. On the top,
we use the parameters of FF1. At the bottom, we
use parameters of FF3.

by Lemma 6.2 below. Now, instead of requiring the known
message X ′ and the target message X to have the same
right segment, we only consider ciphertexts C and C ′ of
X = (L, R) and X ′ = (L′, R′) such that C and C ′ have the
same left segment. (Of course on average, if one encrypts X
and X ′ under q tweaks then we only have q/M such pairs
of ciphertexts.) For those C = (A, B) and C ′ = (A, B′),
the value of B ⊟ B′ is most likely to be R ⊟ R′. In some
sense, this observation is the dual of the idea in Lemma 5.3
for the Left-Half Recovery. To give an intuitive (but not
quite correct) explanation for this duality, note that in the
boolean case, the decryption of F1 = Feistel[r, M, N, ⊕] is
the encryption of F2 = Feistel[r, N, M, ⊕], but pre- and
post-processed by a rotation. Then, one can imagine that,
the process of encrypting X and X ′ via F1 to get C an C ′
is eﬀectively “encrypting” C and C ′ via F2 (with additional
pre- and post-processing) to get X and X ′.
Then, if we have ciphertexts Ci and C ′
i of a target message
X and a known message X ′ ← (L′, R′) under several tweaks,

i

i = (Ai, B′

i) such that Ci and C ′

N −1 and ∆ = 1−1/(N −1)
M (r−2)/2 .

then we can recover the right segment of X as follows. First,
keep only pairs (Ci, C ′
i agree on their
left segments, and suppose that there are ℓ such pairs. Then,
⊞ R′ for all such pairs, where Ci =
compute Pi ← Bi ⊟ B′
(Ai, Bi) and C ′
i). Let P be the most frequent
value of those Pi. Let p = 1
If
X and X ′ agree on their right segments then expectedly, P
appears ℓp times. In contrast, if X and X ′ diﬀer in their right
segments then P is most likely to be the right segment of X,
and expectedly, it appears at least ℓ(p + ∆) times. Hence if
P appears at most (p + ∆/2)ℓ times then we’ll output R′,
otherwise we’ll output P .
Proof of Theorem 6.1. First we’ll show that Advmg
XS ≤
N −1 . Consider an arbitrary simulator S. The simulator is
given the right segment R′ of X ′ and the left segment L of
X ←$ (ZM × ZN )\{X ′}, and has to guess the right segment
of X. We’ll give entire X ′ to the simulator instead of just the
right segment; it only improves the simulator’s advantage. If
L is also the left segment of X ′, then the right segment R
of X is uniformly distributed over ZN\{R′}, and one can
guess R with probability at most 1/(N − 1).
If L is not
the left segment of X ′ then R is uniformly distributed over
ZN , and one can guess it with probability at most 1/N ≤
1/(N−1). Hence Pr[Gmg
N −1 . Since this bound holds
for any simulator, Advmg

XS (S)] ≤ 1
XS = maxS Pr[Gmg

1

XS (S)] ≤ 1

N −1 .

i

i) ← C ′

1), . . . , (Cℓ, C ′

i. For each s ∈ ZN ,
N −1 and ∆ = 1−1/(N −1)

What’s left is to bound Pr[Gmr
F,XS(RHR)]. Recall that in the
Right-Half Recovery attack, we only keep pairs (Ci, C ′
i) such
that Ci and C ′ agree on their left segments. The num-
ber of such pairs is a Binomial random variable, but for
now, suppose that there are ℓ such pairs. By reindexing,
let (C1, C ′
ℓ) be the pairs of ciphertexts that we
keep. In the attack, we iterate ℓ times, and in the i-th itera-
⊞ R′, where (Ai, Bi) ← Ci
tion, we’ll compute Si ← Bi ⊟ B′
and (Ai, B′
let Vi,s be the
Bernoulli random variable such that Vi,s = 1 if and only
if Si = s. Let p = 1
M (r−2)/2 . The attack
computes Vs = V1,s + · · · + Vℓ,s, and ﬁnds P ∈ ZN such that
VP = maxs∈ZN {Vs}. If VP ≤ ℓ(p + ∆/2) then we output R′
as the right segment of the target message X. Otherwise,
we’ll output P .
Our goal is to bound the probability of Pr[Vs ≥ ℓ(p + ∆/2)]
for every s ∈ ZN . This can be done via Chernoﬀ bounds, if
we know the distribution of each Vi,s. For the unlikely case
that X and X ′ have the same right segment (meaning that
R ⊟ R′ = 0), Lemma 6.2 below shows Pr[Vi,s = 1] = p for
every s ∈ ZN\{0}. Intuitively, since X and X ′ are diﬀerent,
for each given tweak, they must have diﬀerent ciphertexts.
Since we consider only Ci and C ′
i of the same left segment,
they must diﬀer in the right segment. So Bi ⊟ B′
i can’t be
0 in this case, but it’s equally likely to be any other value
in ZN . In this case, we’re already given the right segment
R of X via R′; the purpose of the ciphertexts is to help us
realize that we’re lucky. For the “usual” case that X and
X ′ have diﬀerent right segments, Lemma 6.2 shows that for
any s ∈ ZN\{R ⊟ R′}, Pr[Vi,s = 1] is still bounded by p.
However, for s∗ = R ⊟ R′, the probability Pr[Vi,s∗ = 1]
jumps beyond p + ∆, making the attack possible. The proof
of Lemma 6.2 is in the full version.

Lemma 6.2. Let F = Feistel[r, M, N, ⊞]. Fix distinct
X, X ′ ∈ ZM,N , Z ∈ ZN\{0}, T ∈ F.Twk, and an even in-
teger t ∈ {4, 5, . . . , r}. Pick K ←$ F.Keys. Let Lt and Rt

453denote the left and right segment of the round-t output of X
under F.E(K, T, ·). Deﬁne L′

t for X ′ likewise.

t and R′

(a) If R0 = R′

0 then

Pr[Rt ⊟ R′

t = Z | Lt = L′

t] =

1

N − 1

.

(b) For R0 6= R′

0, Pr[Rt ⊟ R′

1

N −1 if Z 6= R0 ⊟ R′
otherwise.

t = Z | Lt = L′

t] is at most
N −1 + 1−1/(N −1)
M (t−2)/2

1

0, but at least

As explained above, we consider two cases for whether X
and X ′ agree on their right segments.

Case 1: X and X ′ diﬀer in their right segments. From
Lemma 6.2, for any s ∈ ZN\{s∗}, the random variables
V1,s, . . . , Vq,s are independent and identically distributed,
with Pr[Vi,s = 1] ≤ p. Likewise, V1,s∗ , . . . , Vq,s∗ are inde-
pendent and identically distributed, with Pr[V1,s = 1] ≥
p + ∆. The chance that the adversary RHR can correctly
guess s∗ is at least the probability that Vs < ℓ(p + ∆/2)
for every s ∈ ZN\{s∗}, and Vs∗ > ℓ(p + ∆/2). By using
Chernoﬀ bounds, Pr[Vs ≥ ℓ(p + z · ∆)] ≤ e−zℓ/9 for any
s ∈ ZN\{s∗}, and Pr[Vs∗ ≤ ℓ(p + ∆/2)] ≤ e−zℓ/12, where
z = ∆2/p. Now, given q pairs of ciphertexts, the number
of pairs (C,C ′) among such that C and C ′ agree on their
left segments is not a constant ℓ, but a random variable U .
From Lemma 5.2, U is a Binomial random variable B(q, θ),
with θ ≥ N −1
. Hence the adversary RHR
can correctly guess s∗ with probability at least

M N −1 ≥ 1−1/(N −1)

M

q

q

q

−

1 −

Pr[Vs ≥ ℓ(p + ∆/2)]

Pr[U = ℓ] · Pr[Vs∗ ≤ ℓ(p + ∆/2)]

Xℓ=0
Xℓ=0
Pr[U = ℓ] · Xs6=s∗
ℓ!θℓ(1 − θ)q−ℓ(cid:16)e−zℓ/12 + N · e−zℓ/9(cid:17)
Xℓ=0 q
≥ 1 −
= 1 −(cid:16)θe−z/12 + 1 − θ(cid:17)q
− N(cid:16)θe−z/9 + 1 − θ(cid:17)q
We ﬁrst bound the term(cid:16)θe−z/12+1−θ(cid:17)q
From the fact that (1 − x)q ≤ e−qx for every 0 < x < 1,
≤ exp(cid:16)−qθ(1 − e−z/12)(cid:17) .

(cid:16)θe−z/12 + 1 − θ(cid:17)q

.

Next, from the hypothesis that r ≥ 6 and M (r−2)/2 ≥ 2N ,

(5)

(6)

in Equation (5).

1

z ≤

M r−2/N ≤

1

2 · M (r−2)/2 ≤

1
2M 2 .

Therefore, by using the fact that 1 − e−x ≥ x − x2/2 for
every 0 < x < 1,

(1 − e−z/12) ≥

z

12(cid:16)1 −

z

24(cid:17) ≥

z

12(cid:16)1 −

1

36M 2(cid:17) .

Then
θ(1 − e−z/12) ≥

1

θz

12(cid:16)1 −
≥ (cid:16)1 − 1

36M 2(cid:17)
N −1(cid:17)2(cid:16)1 − 2

=

λN

12 · M (r−1)

N(cid:17)(cid:16)1 − 1

36M 2(cid:17) · N

12 · M (r−1)
.

(7)

(8)

(9)

From Equation (6) and Equation (7),

Analogously, we can show that

(cid:16)θe−z/12 + 1 − θ(cid:17)q
(cid:16)θe−z/9 + 1 − θ(cid:17)q

≤ exp(cid:16) −λqN
≤ exp(cid:16) −λqN

12 · M r−1(cid:17) .
9 · M (r−1)(cid:17) .

From Equation (5), Equation (8), and Equation (9), we ob-
tain the claimed result.
Case 2: X and X ′ agree in the right segments. This case
can be handled similar to Case 1. We’ll elaborate the details
in the full version.

7. THE FULL-MESSAGE RECOVERY AT-

TACK

Recall that the LHR attack recovers the left segment of
the target message X, while the RHR attack recovers the
right segment of X. By combining them, one can fully re-
cover X as follows. We require ciphertexts of three messages
X, X ′, X ∗ for q tweaks, with suﬃciently large q, to recover
X. The message X ′ is fully known but has no relation with
the target X; this is already enough to recover the right seg-
ment of X, according to the RHR attack. The message X ∗
is required to have the same right segment as the target,
but it’s only partially known: only the left segment of X ∗
is included in the auxiliary information. For example, X ∗
is the “default” version of X, in which the left segment is 0.
Although X ∗ is only partially known, as mentioned above,
we already recovered the right segment of X (and also X ∗).
Then the LHR attack gives us the left segment of X.
The attack. Fix integer q ≥ 1. Let DC3q be the class
of all algorithms D that output (L′, R′) ← X ′ ∈ ZM ×
ZN , L∗ ∈ ZM\{L′} and distinct tweaks T1, . . . , Tq ∈ F.Twk.
Let SC3q = {XS[D] | D ∈ DC3q], where each sampler XS[D]
in SC3q behaves as follows

Sampler XS[D]
(X ′, L∗, T1, . . . , Tq) ←$ D ; (L′, R′) ← X ′
L ←$ ZM\{L′, L∗} ; R ←$ ZN ; X ← (L, R)
X ∗ ← (L∗, R) ; a ← (X ′, L∗)
For i = 1 to q do Zi ← ((Ti, X ∗), (Ti, X ′), (Ti, X))
Return (Z1, . . . , Zq, X, a)

The sampler above picks the left segment L of the target X
uniformly random, with the condition that L must be dif-
ferent from both L∗ and the left segment L′ of the known
message X ′ produced by D. It then picks the right segment
R of X uniformly, and let X ∗ = (L∗, R) be another partially
known message. The auxiliary information contains X ′ and
the left half L∗ of X ∗. The number of examples is Q = 3q;
the number of tweaks is qt = q; the number of target tweaks
is q∗ = q; and the number of examples per tweak is qe = 3.

454i ), (Ti, C′

Adversary FMR(U1, . . . , Uq, a)
For i = 1 to q do ((Ti, C∗
(X ′, L∗) ← a ; (L′, R′) ← X ′ ; a1 ← (L∗, R′)
X ∗ ← RHR((T1, C′
a2 ← X ∗
X ← LHR((T1, C∗
Return X

1 ), (T1, C1), . . . , (Tq, C∗

1), (T1, C1), . . . , (Tq, C′

i), (Ti, Ci)) ← Ui

q), (Tq, Cq), a1)

q ), (Tq, Cq), a2)

Figure 9: The Full-Message Recovery attack.

 1

 0.8

 0.6

FF1

8 bits
9 bits
10 bits
11 bits
12 bits

 35

 40

 45

 50

 55

 60

 65

 0.4

 0.2

 0

 30

 1

 0.8

 0.6

FF3

 0.4

 0.2

 0

 20

8 bits
9 bits
10 bits
11 bits
12 bits

 25

 30

 35

 40

 45

 50

 55

Figure 10: The mr advantage of FMR attack for bi-
nary strings of 8–12 bits. The x-axis shows the log,
base 2, of the number q of ciphertext pairs, and the
y-axis shows Advmr
Feistel[r,M,N,⊞],XS(FMR), for XS ∈ SC3q.
On the top, we use the parameters of the FF1. At
the bottom, we use parameters of FF3.

Since X, X ′, and X ∗ are distinct, each sampler in SC3q sat-
isﬁes the distinctness condition. The Full-Message Recovery
attack FMR against SC3q is shown in Fig. 9. Since qe is
small, we would expect and desire that adversaries have low
mr-advantage, even if Q is big. Indeed, an ideal FPE scheme
has this property. Our FMR attack shows that Feistel-based
FPE fails to have this property. Theorem 7.1 below gives
a lower bound on the mr advantage of FMR; this bound is
illustrated in Fig. 10.

Theorem 7.1. Let N, M ≥ 3 and q ≥ 1 be integers, and
let r ≥ 6 be an even integer such that M (r−2)/2 ≥ 2N and
36M 2(cid:17)
N (r−2)/2 ≥ 2M . Let λ1 =(cid:16)1 − 1
M N(cid:17). Let F = Feistel[r, M, N, ⊞].
and λ2 =(cid:16)1− 1

Then for any sampler XS in the class SC3q,

M −1(cid:17)2(cid:16)1− 1

N −1(cid:17)2(cid:16)1 − 2

N(cid:17)(cid:16)1 − 1

Advmr

F,XS(FMR) ≥ 1 − N · exp(cid:16) −λ1qN
M · exp(cid:16) −λ2M q

9 · M r−1(cid:17)−
9 · N r−2(cid:17) − exp(cid:16) −λ2M q
12 · M r−1(cid:17) −

exp(cid:16) −λ1qN

12 · N r−2(cid:17)−

1

.

N (M − 2)

Acknowledgments

We thank the CCS reviewers for their insightful comments.
Bellare was supported in part by NSF grant CNS-1526801,
ERC Project ERCC FP7/615074 and a gift from Microsoft.
Hoang and Tessaro were supported in part by NSF grants
CNS-1423566 and CNS-1553758 (CAREER), and by the Glen
and Susanne Culler Chair. Hoang’s work was done while at
UCSB.

8. REFERENCES
[1] M. Bellare, T. Ristenpart, P. Rogaway, and T. Stegers.

Format-preserving encryption. In M. J. Jacobson Jr.,
V. Rijmen, and R. Safavi-Naini, editors, SAC 2009,
volume 5867 of LNCS, pages 295–312. Springer,
Heidelberg, Aug. 2009.

[2] M. Bellare and P. Rogaway. The security of triple

encryption and a framework for code-based
game-playing proofs. In S. Vaudenay, editor,
EUROCRYPT 2006, volume 4004 of LNCS, pages
409–426. Springer, Heidelberg, May / June 2006.

[3] M. Bellare, P. Rogaway, and T. Spies. Addendum to

“the FFX mode of operation for Format-Preserving
Encryption”. Draft 1.0. Submission to NIST, Sept.
2010. http://csrc.nist.gov/groups/ST/toolkit/BCM/
documents/proposedmodes/ﬀx/ﬀx-spec2.pdf.

[4] M. Bellare, P. Rogaway, and T. Spies. The FFX mode

of operation for format-preserving encryption. Draft
1.1. Submission to NIST, Feb. 2010.
http://csrc.nist.gov/groups/ST/toolkit/BCM/
documents/proposedmodes/ﬀx/ﬀx-spec.pdf.

[5] J. Black and P. Rogaway. Ciphers with arbitrary ﬁnite
domains. In B. Preneel, editor, CT-RSA 2002, volume
2271 of LNCS, pages 114–130. Springer, Heidelberg,
Feb. 2002.

[6] E. Brier, T. Peyrin, and J. Stern. BPS: a

format-preserving encryption proposal. Submission to
NIST, 2010. http://csrc.nist.gov/groups/ST/toolkit/
BCM/documents/proposedmodes/bps/bps-spec.pdf.

[7] M. Dworkin. Recommendation for Block Cipher

Modes of Operation: Methods for Format-Preserving
Encryption. NIST Special Publication 800-38G, Mar.
2016. http://dx.doi.org/10.6028/NIST.SP.800-38G.
[8] M. Liskov, R. L. Rivest, and D. Wagner. Tweakable
block ciphers. Journal of Cryptology, 24(3):588–613,
July 2011.

[9] J. Patarin. New results on pseudorandom permutation

generators based on the DES scheme. In
J. Feigenbaum, editor, CRYPTO’91, volume 576 of
LNCS, pages 301–312. Springer, Heidelberg, Aug.
1992.

[10] J. Patarin. Generic attacks on Feistel schemes. In

C. Boyd, editor, ASIACRYPT 2001, volume 2248 of
LNCS, pages 222–238. Springer, Heidelberg, Dec. 2001.

[11] J. Patarin. Security of random Feistel schemes with 5

or more rounds. In M. Franklin, editor,
CRYPTO 2004, volume 3152 of LNCS, pages 106–122.
Springer, Heidelberg, Aug. 2004.

455