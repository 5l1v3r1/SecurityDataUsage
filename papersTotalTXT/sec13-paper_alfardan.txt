On the Security of RC4 in TLS

Nadhem AlFardan, Royal Holloway, University of London;  

Daniel J. Bernstein, University of Illinois at Chicago and Technische Universiteit Eindhoven; 

Kenneth G. Paterson, Bertram Poettering, and Jacob C.N. Schuldt,  

Royal Holloway, University of London

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4On the Security of RC4 in TLS1

Nadhem J. AlFardan
Information Security Group,

Royal Holloway, University of London

Daniel J. Bernstein

University of Illinois at Chicago and
Technische Universiteit Eindhoven

Kenneth G. Paterson
Information Security Group,

Royal Holloway, University of London

Bertram Poettering
Information Security Group,

Jacob C. N. Schuldt
Information Security Group,

Royal Holloway, University of London

Royal Holloway, University of London

Abstract

The Transport Layer Security (TLS) protocol aims to
provide conﬁdentiality and integrity of data in transit
across untrusted networks. TLS has become the de facto
protocol standard for secured Internet and mobile ap-
plications. TLS supports several symmetric encryption
options, including a scheme based on the RC4 stream
cipher. In this paper, we present ciphertext-only plain-
text recovery attacks against TLS when RC4 is selected
for encryption. Our attacks build on recent advances in
the statistical analysis of RC4, and on new ﬁndings an-
nounced in this paper. Our results are supported by an
experimental evaluation of the feasibility of the attacks.
We also discuss countermeasures.

1

Introduction

TLS is arguably the most widely used secure communi-
cations protocol on the Internet today. Starting life as
SSL, the protocol was adopted by the IETF and speciﬁed
as an RFC standard under the name of TLS 1.0 [7]. It
has since evolved through TLS 1.1 [8] to the current ver-
sion TLS 1.2 [9]. Various other RFCs deﬁne additional
TLS cryptographic algorithms and extensions. TLS is
now used for securing a wide variety of application-level
trafﬁc: It serves, for example, as the basis of the HTTPS
protocol for encrypted web browsing, it is used in con-
junction with IMAP or SMTP to cryptographically pro-
tect email trafﬁc, and it is a popular tool to secure com-
munication with embedded systems, mobile devices, and
in payment systems.

Technically speaking, TLS sessions consist of two
consecutive phases: the execution of the TLS Handshake
Protocol which typically deploys asymmetric techniques
to establish a secure session key, followed by the exe-
cution of the TLS Record Protocol which uses symmet-
ric key cryptography (block ciphers, the RC4 stream ci-
pher, MAC algorithms) in combination with the estab-
lished session key and sequence numbers to build a se-

cure channel for transporting application-layer data. In
the Record Protocol, there are mainly three encryption
options:

• HMAC followed by CBC-mode encryption using a

block cipher,

• HMAC followed by encryption using the RC4

stream cipher, or

• authenticated encryption using GCM or CCM mode

of operation of a block cipher.

The third of these three options is only available with
TLS 1.2 [21, 18], which is yet to see widespread adop-
tion.2 The ﬁrst option has seen signiﬁcant cryptanalysis
(padding oracle attacks [6], BEAST [10], Lucky 13 [3]).
While countermeasures to the attacks on CBC-mode in
TLS exist, many commentators now recommend, and
many servers now offer, RC4-based encryption options
ahead of CBC-mode.3 Indeed, the ICSI Certiﬁcate No-
tary4 recently performed an analysis of 16 billion TLS
connections and found that around 50% of the trafﬁc was
protected using RC4 ciphersuites [5].

This makes it timely to examine the security of RC4 in
TLS. While the RC4 algorithm is known to have a variety
of cryptographic weaknesses (see [23] for an excellent
survey), it has not been previously explored how these
weaknesses can be exploited in the context of TLS. Here
we show that new and recently discovered biases in the
RC4 keystream do create serious vulnerabilities in TLS
when using RC4 as its encryption algorithm.

While the main focus of this paper lies on the security
of RC4 in TLS, our attacks (or variants thereof) might
also be applicable to other protocols where RC4 is meant
to ensure data conﬁdentiality. Indeed, the WPA proto-
col used for encrypting wireless network trafﬁc also uti-
lizes the RC4 stream cipher in a way that allows (partial)
plaintext recovery in speciﬁc settings — using basically
the same attack strategies as in the TLS case.

USENIX Association  

22nd USENIX Security Symposium  305

1

We hope that this work will help spur the adoption of
TLS 1.2 and its authenticated encryption algorithms, as
well as the transition from WPA to (the hopefully more
secure) WPA2.

1.1 Overview of Results
We present two plaintext recovery attacks on RC4 that
are exploitable in speciﬁc but realistic circumstances
when this cipher is used for encryption in TLS. Both at-
tacks require a ﬁxed plaintext to be RC4-encrypted and
transmitted many times in succession (in the same, or in
multiple independent RC4 keystreams). Interesting can-
didates for such plaintexts include passwords and, in the
setting of secure web browsing, HTTP cookies.

A statistical analysis of ciphertexts forms the core of
our attacks. We stress that the attacks are ciphertext-
only: no sophisticated timing measurement is needed on
the part of the adversary, the attacker does not need to be
located close to the server, and no packet injection capa-
bility is required (all premises for Lucky 13). Instead, it
sufﬁces for the adversary to record encrypted trafﬁc for
later ofﬂine analysis. Provoking the required repeated
encryption and transmission of the target plaintext, how-
ever, might require more explicit action: e.g., resetting
TCP connections or guiding the victim to a website with
specially prepared JavaScript (see examples below).

Since both our attacks require large amounts of cipher-
text, their practical relevance could be questioned. How-
ever, they do show that the strength of RC4 in TLS is
much lower than the employed 128-bit key would sug-
gest. We freely admit that our attacks are not particularly
deep, nor sophisticated: they only require an understand-
ing of how TLS uses RC4, solid statistics on the biases
in RC4 keystreams, and some experience of how modern
browsers handle cookies. We consider it both surprising
and alarming that such simple attacks are possible for
such an important and heavily-studied protocol as TLS.
We further discuss the implications of our attack in Sec-
tion 6 and in the full version of this paper [4].

1.1.1 Our single-byte bias attack

Our ﬁrst attack targets the initial 256 bytes of RC4 ci-
phertext. It is ﬁxed-plaintext and multi-session, meaning
that it requires a ﬁxed sequence of plaintext bytes to be
independently encrypted under a large number of (ran-
dom) keys. This setting corresponds to what is called a
“broadcast attack” in [17, 15, 23]. As we argue below,
such attacks are a realistic attack vector in TLS. Observe
that, in TLS, the ﬁrst 36 bytes of the RC4 keystream are
used to encrypt a TLS Handshake Finished message.
This message is not ﬁxed across TLS sessions. As a con-
sequence, our methods can be applied only to recover up

to 220 bytes of the TLS application plaintext.

Our attack exploits statistical biases occurring in the
ﬁrst 256 bytes of RC4 keystream. Such biases, i.e., devi-
ations from uniform in the distributions of the keystream
bytes at certain positions, have been reported and the-
oretically analyzed by [17], [15], and [23]. The corre-
sponding authors also propose algorithms to exploit such
biases for plaintext recovery. In this paper, we discuss
shortcomings of their algorithms, empirically obtain a
complete view of all single-byte biases occurring in the
ﬁrst 256 keystream positions, and propose a generalized
algorithm that fully exploits all these biases for advanced
plaintext recovery. As a side result of our research, in
Section 3.1 we report on signiﬁcant biases in the RC4
keystream that seemingly follow speciﬁc patterns and
that have not been identiﬁed or analysed previously.

For concreteness, we describe how our single-byte
bias attack could be applied to recover cookies in HTTPS
trafﬁc. Crucial here is to ﬁnd an automated mechanism
for efﬁciently generating a large number of encryptions
of the target cookie. In line with the scenario employed
by the BEAST and Lucky 13 attacks against CBC-mode
encryption in TLS [3, 10], a candidate mechanism is
for JavaScript malware downloaded from an attacker-
controlled website and running in the victim’s browser
to repeatedly send HTTPS requests to a remote server.
The corresponding cookies are automatically included in
each of these requests in a predictable location, and can
thus be targeted in our attack.
If client and server are
conﬁgured to use TLS session resumption, the renewal of
RC4 keys could be arranged to happen with particularly
high frequency — as required for our attack to be suc-
cessful.5 Alternatively, the attacker can cause the TLS
session to be terminated after the target encrypted cookie
is sent; the browser will automatically establish a new
TLS session when the next HTTPS request is sent.

As a second example, consider the case where IMAP
passwords6 are attacked. In a setup where an email client
regularly connects to an IMAP server for (password-
authenticated) mail retrieval, let the adversary reset the
TCP connection between client and server immediately
after the encrypted password is transmitted.
In some
client conﬁgurations this might trigger an automatic re-
sumption of the session, including a retransmission of the
(encrypted) password. If this is the case, the adversary
is in the position to harvest a large set of independently
encrypted copies of the password —one per reset— pre-
cisely fulﬁlling the precondition of our attack.

Our single-byte bias attack is on the verge of prac-
ticality.
In our experiments, the ﬁrst 40 bytes of TLS
application data after the Finished message were re-
covered with a success rate of over 50% per byte, using
226 sessions. With 232 sessions, the per-byte success rate
is more than 96% for the ﬁrst 220 bytes (and is 100%

306  22nd USENIX Security Symposium 

USENIX Association

2

for all but 12 of these bytes). If, for example, a target
plaintext byte is known to be a character from a set of
cardinality 16 (e.g., in a 4-bits-per-byte-encoded HTTP
cookie), our algorithm recovers the ﬁrst 112 bytes of
plaintext with a success rate of more than 50% per byte,
using 226 sessions. For further details, see Section 5.

1.1.2 Our double-byte bias attack

As we have seen, our single-byte bias attack on RC4 is
quite effective in recovering ‘early’ plaintext bytes in the
ﬁxed-plaintext multi-session setting. It has, however, a
couple of limitations when it comes to attacking practi-
cal systems that employ TLS. Focussing on the recovery
of cookies in HTTPS-secured web sessions, we note that
modern web browsers typically send a large number of
HTTP headers before any cookies (these headers carry
information about the particular client or server software,
accepted MIME types, compression options, etc.).
In
practice, cookie data appears only at positions that come
after the attackable initial 220 bytes of the ciphertext7.
Independently of this issue, in the attack scenarios pro-
posed above, a large number of HTTPS sessions would
have to be established and torn down again, inducing
non-negligible computing and bandwidth overheads via
the TLS Handshake. Lastly, it has been proposed to rou-
tinely drop the ﬁrst few hundred keystream bytes of RC4
before starting encryption in order to avoid the relatively
strong early keystream biases [19] — if this were to be
implemented in TLS, our single-byte bias attack would
effectively be defeated.

Complementary to our single-byte bias attack, we
present a second ﬁxed-plaintext ciphertext-only attack
on RC4.
It exploits biases that appear in the entire
keystream (and not just in the ﬁrst 256 positions) and
does not assume, but tolerates, frequent changes of the
encryption key. Our second attack hence covers some
scenarios where our single-byte bias attack does not
seem to be applicable; it would, for example, be able to
recover cookies from (long-persisting) HTTPS sessions.
It would also be applicable if the initial keystream bytes
were to be discarded.

In contrast to our ﬁrst attack, our second attack ex-
ploits certain biases in consecutive pairs of bytes in the
RC4 keystream that were ﬁrst reported by Fluhrer and
McGrew [12]. We empirically evaluate the probability
of occurrence for each possible pair of bytes beginning at
each position (modulo 256), obtaining a complete view
of the distributions of pairs of bytes in positions (i,i + 1)
(modulo 256). Our analysis strongly suggests that there
are no further biases in consecutive positions of the same
strength as the Fluhrer-McGrew biases. We use the ob-
tained results in a specially designed attack algorithm to
recover repeatedly encrypted plaintexts.

Our double-byte bias attack is again close to being
practical. In our experiments, we focus on our attack’s
ability to correctly recover 16 consecutive bytes of plain-
text, roughly equating to an HTTP cookie. With 13· 230
encryptions of the plaintext, we achieve a success rate of
100% in recovering all 16 bytes. We obtain better suc-
cess rates for restricted plaintexts, as in the single-byte
case. For further details, see Section 5.

1.2 Related Work
In independent and concurrent work, Isobe et al. [13]
have considered the security of RC4 against broadcast
attacks. They present attacks based on both single-byte
and multi-byte biases. They identify three biases in the
ﬁrst output bytes Zr of RC4 that we also identify (speciﬁ-
cally, the biases towards Z3 = 0x83, Zr = r, and Zr = −r
when r is a multiple of 16) as well as a new conditional
bias Z1 = 0|Z2 = 0.
The single-byte bias attack in [13] only considers the
strongest bias at each position, whereas our single-byte
bias attack simultaneously exploits all biases in each
keystream position. Speciﬁcally, we use Bayes’s law to
compute the a posteriori plaintext distribution from the a
priori plaintext distribution and the precomputed distri-
butions of the Zr. This explains why our single-byte at-
tack out-performs that of [13]. For example, we achieve
reliable plaintext recovery in the ﬁrst 256 positions with
232 ciphertexts, while Isobe et al. [13] require 234 cipher-
texts. We also achieve uniformly higher success rates for
lower numbers of sessions. Previous authors exploring
broadcast attacks on RC4 also only used single biases,
leading to attacks that simply do not work [15, 23] or
which have inferior performance to ours [22].

The multi-byte bias attack in [13] exploits the positive
bias towards the pattern ABSAB that was identiﬁed by
Mantin [16]. Here A and B are keystream bytes and S
is a short string consisting of any keystream bytes (pos-
sibly of length 0). The attack in [13] assumes that 3-
out-of-4 bytes in particular positions are known and uses
the Mantin bias to recover the fourth. A limited ex-
perimental evaluation of the attack is reported in [13]:
the attack is applied only to recovery of plaintext bytes
258-261, assuming all previous plaintext bytes have been
successfully recovered, with success rates of 1 (for each
of the 4 targeted bytes) using 234 ciphertexts. As ex-
plained in [13], this multi-byte attack would fail if the
initial bytes of RC4 output were to be discarded. By
contrast, our double-byte bias attack, which exploits the
Fluhrer-McGrew biases, recovers more bytes with com-
parable success rate using slightly fewer ciphertexts and
is resilient to initial byte discarding. It is an interesting
open problem to determine whether the Mantin ABSAB
bias can be combined with the Fluhrer-McGrew biases to

USENIX Association  

22nd USENIX Security Symposium  307

3

gain enhanced attack performance.

A further point of comparison between our work and
that of [13] concerns practical implementation. We have
extensively explored the applicability of our attacks to
RC4 as used in TLS, while [13] makes only brief men-
tion of TLS in its concluding section and gives no mech-
anisms for generating the large numbers of ciphertexts
needed for the attacks.

Finally, the authors of [13] claim in their abstract that
their methods “can recover the ﬁrst 250 bytes ≈ 1000 T
bytes of the plaintext, with probability close to 1, from
only 234 ciphertexts”. We point out that their methods
would only recover 216 distinct bytes of output, rather
than the advertised 250 bytes, since their attacks require
the same plaintext to be encrypted 234 times. Further-
more, their multi-byte bias attack is not resilient to er-
rors occurring in the recovery of early plaintext bytes
(whereas ours is), so this claim would only be true if their
multi-byte bias attack does not fail at any stage, and this
is as yet untested.

1.3 Paper Organisation
Section 2 provides further background on the RC4
stream cipher and the TLS Record Protocol. Section 3
summarises weaknesses in RC4 that we exploit in our at-
tacks. Section 4 describes our two plaintext recovery at-
tacks on RC4. We evaluate the attacks in Section 5, with
our main focus there being on TLS. Finally, Section 6
discusses countermeasures to our attacks, and concludes
with a recap of the main issues raised by our work.

2 Further Background

2.1 The RC4 Stream Cipher
The stream cipher RC4, originally designed by Ron
Rivest, became public in 1994 and found application in a
wide variety of cryptosystems; well-known examples in-
clude SSL/TLS, WEP [1], WPA [2], and some Kerberos-
related encryption modes [14]. RC4 has a remark-
ably short description and is extremely fast when imple-
mented in software. However, these advantages come
at the price of lowered security: several weaknesses have
been identiﬁed in RC4 [12, 11, 17, 16, 15, 23, 25, 24, 26],
some of them being conﬁrmed and exploited in the cur-
rent paper.

Technically, RC4 consists of two algorithms: a key
scheduling algorithm (KSA) and a pseudo-random gen-
eration algorithm (PRGA), which are speciﬁed in Fig-
ure 1. The KSA takes as input a key K, typically a byte-
array of length between 5 and 32 (i.e., 40 to 256 bits), and
produces the initial internal state st0 = (i, j,S), where S
is the canonical representation of a permutation on the set

Algorithm 1: RC4
scheduling (KSA)

key

Algorithm 2: RC4 keystream
generator (PRGA)

input : key K of l bytes
output: internal state st0
begin

for i = 0 to 255 do

S[i] ← i

j ← 0
for i = 0 to 255 do

j ←j +S[i]+K[i mod l]
swap(S[i],S[j])

i, j ← 0
st0 ← (i, j,S)
return st0

input : internal state str
output: keystream byte Zr+1

internal state str+1

begin

parse (i, j,S) ← str
i ← i + 1
j ← j + S[i]
swap(S[i],S[j])
Zr+1 ← S[S[i] + S[j]]
str+1 ← (i, j,S)
return (Zr+1, str+1)

Figure 1: Algorithms implementing the RC4 stream ci-
pher. All additions are performed modulo 256.

[0,255] as an array of bytes, and i, j are indices into this
array. The PRGA will, given an internal state str, output
‘the next’ keystream byte Zr+1, together with the updated
internal state str+1. Particularly interesting to note is the
fact that updated index j is computed in dependence on
current i, j, and S, while i is just a counter (modulo 256).
2.2 The TLS Record Protocol
We describe in detail the cryptographic operation of the
TLS Record Protocol in the case that RC4 is selected as
the encryption method.

Data to be protected by TLS is received from the ap-
plication and may be fragmented and compressed before
further processing. An individual record R (viewed as
a sequence of bytes) is then processed as follows. The
sender maintains an 8-byte sequence number SQN which
is incremented for each record sent, and forms a 5-byte
ﬁeld HDR consisting of a 2-byte version ﬁeld, a 1-byte
type ﬁeld, and a 2-byte length ﬁeld. It then calculates
an HMAC over the string HDR||SQN||R; let T denote the
resulting tag.
For RC4 encryption, record and tag are concate-
nated to create the plaintext P = R||T . This plaintext
is then xored in a byte-by-byte fashion using the RC4
keystream, i.e., the ciphertext bytes are computed as

Cr = Pr ⊕ Zr

for r = 1,2,3, . . .

,

where Pr are the individual bytes of P, and Zr are the RC4
keystream bytes. The data transmitted over the wire then
has the form

HDR||C ,

where C is the concatenation of the bytes Cr.

The RC4 algorithm itself is initialised at the start of
each TLS connection, using a 128 bit encryption key K.
This key K is computed with a hash-function-based key

308  22nd USENIX Security Symposium 

USENIX Association

4

derivation function from the TLS master secret that is es-
tablished during the TLS Handshake Protocol. In more
detail, the key K may be established either via a full TLS
Handshake or via TLS session resumption. In a full TLS
Handshake, a total of 4 communication round-trips are
needed, and usually some public key cryptographic op-
erations are required of both client and server. A full
TLS Handshake run establishes a new TLS session and
a new TLS master secret from which all other keys, in-
cluding RC4 key K, are derived. TLS session resumption
involves a lightweight version of the TLS Handshake
Protocol being run to establish a new connection within
an existing session: essentially, an exchange of nonces
takes place, followed by an exchange of Finished mes-
sages; no public key cryptographic operations are in-
volved. The keys for the new connection, including K,
are derived from the existing master secret and the new
nonces. Given the design of the key derivation process,
it is reasonable to model K as being uniformly random in
the different sessions/connections.

The initialisation of RC4 in TLS is the standard one
for this algorithm. Notably, none of the initial keystream
bytes is discarded when RC4 is used in TLS, despite
these bytes having known weaknesses. Note also that
the ﬁrst record sent under the protection of RC4 for each
session or connection will be a Finished message, typ-
ically of length 36 bytes, consisting of a Handshake Pro-
tocol header, a PRF output, and a MAC on that output.
This is typically 36 bytes in size. This record will not
be targeted in our attacks, since it is not constant across
multiple sessions.

The decryption process reverses this sequence of
steps, but its details are not germane to our attacks.
For TLS, any error arising during decryption should be
treated as fatal, meaning an (encrypted) error message
is sent to the sender and the session terminated with all
keys and other cryptographic material being disposed of.
This gives an attacker a convenient method to cause a
session to be terminated and force new encryption and
MAC keys to be set up. Another method is to somehow
induce the client or server to initiate session resumption.

3 Biases in the RC4 Keystream

In this section, we summarise known biases in the RC4
keystream, and report new biases that we have observed
experimentally.

3.1 Single-byte Biases
The ﬁrst signiﬁcant bias in the RC4 keystream was ob-
served by Mantin and Shamir in [17]. Their main result
can be stated as:

Result 1. [17, Thm 1] The probability that Z2, the sec-
ond byte of keystream output by RC4, is equal to 0x00
is approximately 1/128 (where the probability is taken
over the random choice of the key).

Since this result concerns only the second byte of the
keystream, and this byte is always used to encrypt a
Finished message in TLS, we are unable to exploit it
in our attacks. More recently, the following result was
obtained by Sen Gupta et al. in [23] as a reﬁnement of an
earlier result of Maitra et al. [15]:
Result 2. [23, Thm 14 and Cor 3] For 3 ≤ r ≤ 255, the
probability that Zr, the r-th byte of keystream output by
RC4, is equal to 0x00 is

Pr(Zr = 0x00) =

1
256

+

cr
2562 ,

where the probability is taken over the random choice of
the key, c3 = 0.351089, and c4,c5 . . . ,c 255 is a decreasing
sequence with terms that are bounded as follows:

0.242811 ≤ cr ≤ 1.337057.

In other words, bytes 3 to 255 of the keystream have
a bias towards 0x00 of approximately 1/216. This re-
sult was experimentally veriﬁed in [23] and found to be
highly accurate (see Figure 11 of that paper). The bi-
ases here are substantially smaller than those observed in
Result 1.

Additionally, Sen Gupta et al. [23] have identiﬁed a
key-length-dependent bias in RC4 keystreams. Speciﬁ-
cally, [23, Theorem 5] shows that when the key-length
is (cid:28) bytes, then byte Z(cid:28) is biased towards value 256− (cid:28),
with the bias always being greater than 1/216. For RC4
in TLS, we have (cid:28) = 16.

Experimentally, we have observed additional biases in
the RC4 keystream that do not yet have a theoretical ex-
planation. As an example, Figure 2 shows the empir-
ical distribution for the RC4 keystream bytes Z16, Z32
and Z50, calculated over 244 independent, random 128-bit
keys. For Z16, we have 3 main biases: the bias towards
0x00, the very dominant key-length-dependent bias to-
wards 0xF0 (decimal 240) from [23], and a new bias to-
wards 0x10 (decimal 16). For Z32, we also have 3 main
biases: the bias towards 0x00, a large, new bias towards
0xE0 (decimal 224), and a new bias towards 0x20 (dec-
imal 32). For Z50, there are signiﬁcant biases towards
byte values 0x00 and 0x32 (decimal 50), as well as an
upward trend in probability as the byte value increases.
Individual inspection of ciphertext distributions at all
positions 1 ≤ r ≤ 256 reveals two new signiﬁcant bi-
ases that occur with speciﬁc regularities: a bias towards
value r for all r, and a bias towards value 256− r at po-
sitions r that are multiples of (key-length) 16; note that

USENIX Association  

22nd USENIX Security Symposium  309

5

0.00406%

0.00404%

0.00402%

0.004%

0.00398%

0.00396%

0.00394%

0.00392%

0.0039%

0.00388%

0.00402%

0.004%

0.00398%

0.00396%

0.00394%

0.00392%

0.0039%

0.00388%

0%

10%

20%

30%

40%

50%

60%

70%

80%

90%

100%

110%

120%

130%

140%

150%

160%

170%

180%

190%

200%

210%

220%

230%

240%

250%

0%

10%

20%

30%

40%

50%

60%

70%

80%

90%

100%

110%

120%

130%

140%

150%

160%

170%

180%

190%

200%

210%

220%

230%

240%

250%

0.00405&

0.00403&

0.00401&

0.00399&

0.00397&

0.00395&

0.00393&

0.00391&

0.00389&

0&

10&

20&

30&

40&

50&

60&

70&

80&

90&

100&

110&

120&

130&

140&

150&

160&

170&

180&

190&

200&

210&

220&

230&

240&

250&

0.003922&

0.00392&

0.003918&

0.003916&

0.003914&

0.003912&

0.00391&

0.003908&

0.003906&

0.003904&

0.003902&

0&

10&

20&

30&

40&

50&

60&

70&

80&

90&

100&

110&

120&

130&

140&

150&

160&

170&

180&

190&

200&

210&

220&

230&

240&

250&

Figure 2: Measured distributions of RC4 keystream
bytes Z16 (top), Z32 (middle), and Z50 (bottom).

the latter ﬁnding both conﬁrms and extends the results
from [23]. Both of these new biases were also observed
by Isobe et al. [13], with a theoretical explanation be-
ing given for the bias towards r. Figure 3 shows the es-
timated strength of these biases in comparison with the
strength of the bias towards 0x00 for the keystream bytes
Z1, . . . ,Z 256. The estimates are based on the empirical
distribution of the RC4 keystream bytes, calculated over
244 random 128-bit RC4 keys. We note that the key-
length dependent bias dominates the other two biases un-
til position Z112, and that the bias of Zr towards r dom-
inates the bias towards 0x00 observed by [15] between
positions Z5 and Z31, except for byte Z16 where the bias
towards 0x00 is slightly stronger.

Furthermore, for the ﬁrst keystream byte Z1, we have
observed a bias away from value 0x81 (decimal 129) in
the addition to the known bias away from value 0x00.
This additional bias is not consistent with the recent re-
sults of Sen Gupta et al. [23] who provide a theoreti-
cal treatment of the distribution of Z1. The disparity
likely arises because Sen Gupta et al. work with 256-
byte keys, while our work is exclusively concerned with
128-bit (16-byte) keys as used in TLS; in other words,
our observed bias in Z1 = 0x81 seems to be key-length-
dependent. Finally, our computations have revealed a
number of other, smaller biases in the initial bytes of the
RC4 keystream.

Figure 3: Measured strength of the bias towards 0x00
(green), the bias towards value r in Zr (blue), and the key-
length dependent bias towards byte value 256− r (red)
for keystream bytes Z1, . . . ,Z 256, based on keystreams
generated by 244 independent random keys. Note that
the large peak for the 0x00 bias in Z2 extends beyond the
bounds of the graph and is not fully shown for illustrative
purposes.

3.2 Multi-byte Biases
Besides the single-byte biases highlighted above, sev-
eral multi-byte biases have been identiﬁed in the RC4
keystream.
In contrast to the single-byte biases, most
of the identiﬁed multi-byte biases are “long term” bi-
ases which appear periodically at regular intervals in the
keystream.

The most extensive set of multi-byte biases was
identiﬁed by Fluhrer and McGrew [12] who analyzed
the distribution of pairs of byte values for consecutive
keystream positions (Zr,Zr+1), r ≥ 1. More precisely,
they estimated the distribution of consecutive keystream
bytes for scaled-down8 versions of RC4 by assuming an
idealized internal state of RC4 in which the permuta-
tion S and the internal variable j are random (see Fig-
ure 1), and then extrapolated the results to standard RC4.
The reported biases for standard RC4 are listed in Ta-
ble 1. Note that all biases are dependent on the internal
variable i which is incremented (modulo 256) for each
keystream byte generated. It should also be noted that,
due to the assumption that S and j are random, the bi-
ases cannot be expected to hold for the initial keystream
bytes. However, this idealization becomes a close ap-
proximation to the internal state of RC4 after a few invo-
cations of the RC4 keystream generator, [12].

We experimentally veriﬁed the Fluhrer-McGrew bi-
ases by analysing the output of 210 RC4 instances using
128-bit keys and generating 240 keystream bytes each.
For each keystream, the initial 1024 bytes were dropped.
Based on this data, we found the biases from [12] to be
accurate, also for 128-bit keys. This is in-line with the

310  22nd USENIX Security Symposium 

USENIX Association

6

experiments and observations reported in [12]. Further-
more, we did not identify any additional signiﬁcant long
term biases for consecutive keystream bytes which are
repeated with a periodicity that is a proper divisor of 256.
Hence, for the purpose of implementing the attack pre-
sented in Section 4.2, we assume that the biases iden-
tiﬁed in [12] are the only existing long term biases for
consecutive keystream bytes, and that all other pairs of
byte-values are uniformly distributed.

Byte pair

Condition on i

(0,0)
(0,0)
(0,1)

(i + 1,255)
(255,i + 1)
(255,i + 2)

(255,0)
(255,1)
(255,2)
(129,129)
(255,255)
(0,i + 1)

i = 1

i (cid:30)= 0,253,254,255

i (cid:30)= 1,255
i (cid:30)= 0,1
i (cid:30)= 254
i (cid:30)= 1,254
i = 254
i = 255
i = 0,1
i = 2
i (cid:30)= 254
i (cid:30)= 0,255

Probability
2−16(1 + 2−9)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1− 2−8)
2−16(1− 2−8)

Table 1: Fluhrer-McGrew biases for consecutive pairs of
byte values. In the table, i is the internal variable of the
RC4 keystream generation algorithm (see Section 2.1).

Independently of [12], Mantin [16] identiﬁed a pos-
itive bias towards the pattern ABSAB, where A and B
represent byte values and S is a short string of bytes
(possibly of length 0). The shorter the string S is, the
more signiﬁcant is the bias. Additionally, Sen Gupta
et al. [23] identiﬁed a bias towards the byte values (0,0)
for keystream positions (Zr,Zr+2), separated by any sin-
gle keystream byte for r ≥ 1. However, we do not make
use of these biases in the attacks presented in this paper.

4 Plaintext Recovery Attacks

For the purpose of exposition, we ﬁrst explain how the
broadcast attack by Maitra et al. [15] and Sen Gupta
et al. [23] is meant to work. Suppose byte Zr of the
RC4 keystream has a dominant bias towards value 0x00.
As RC4 encryption is deﬁned as Cr = Pr ⊕ Zr, the cor-
responding ciphertext byte Cr has a bias towards plain-
text byte Pr. Thus, obtaining sufﬁciently many ciphertext
samples Cr for a ﬁxed plaintext Pr allows inference of Pr
by a majority vote: Pr is equal to the value of Cr that
occurs most often. This is the core idea of Algorithm 3
that we reproduce from [15, 23]. Let S denote the num-
ber of ciphertexts available to the attacker and, for all
1 ≤ j ≤ S, let Cj,r denote the r-th byte of ciphertext Cj.
For a ﬁxed position r, Algorithm 3 runs through all j,
and in each iteration increments one out of 256 counters,

Algorithm 3: Basic plaintext recovery attack
input : S independent encryptions (Cj)1≤ j≤S of
output: estimate P∗r for plaintext byte Pr
begin

ﬁxed plaintext P, position r

N0x00 ← 0, . . . , N0xFF ← 0
for j = 1 to S do

NCj,r ← NCj,r + 1

P∗r ← argmaxµ∈{0x00,...,0xFF} Nµ

namely the one that corresponds to value Cj,r. After pro-
cessing all ciphertexts, the character corresponding to the
largest counter in the obtained histogram is the output of
the algorithm.

The algorithm is tailor-made for plaintext recovery
in the case described by Result 2:
it assumes that the
largest bias in the RC4 keystream is towards 0x00. How-
ever, it is highly likely to fail to reliably suggest the cor-
rect plaintext byte Pr if the RC4 keystream has, in posi-
tion r, additional biases of approximately the same size
(or larger) as the bias towards 0x00. Such additional
biases would simply be misinterpreted as the bias to-
wards 0x00 and hence falsify the result. As we observed
in Section 3.1 (and Figure 3), several other quite strong
biases in the RC4 keystream do indeed exist. This clearly
invalidates Algorithm 3 for practical use.

4.1 Our Single-byte Bias Attack
We propose a plaintext-recovery algorithm that takes into
account all possible single-byte RC4 biases at the same
time, along with their strengths. The idea is to ﬁrst obtain
a detailed picture of the distributions of RC4 keystream
bytes Zr, for all positions r, by gathering statistics from
keystreams generated using a large number of indepen-
dent keys (244 in our case). That is, for all r, we (empiri-
cally) estimate

pr,k := Pr(Zr = k),

k = 0x00, . . . ,0xFF ,

where the probability is taken over the random choice
of the RC4 encryption key (i.e., 128 bit keys in the
TLS case). Using these biases pr,k, in a second step,
plaintext can be recovered with optimal accuracy using
a maximum-likelihood approach, as follows.

0xFF) with

Suppose we have S ciphertexts C1, . . . ,CS available
for our attack.
For any ﬁxed position r and any
candidate plaintext byte µ for that position, vector
0x00, . . . ,N (µ)
(N(µ)
N(µ)
k = |{ j | Cj,r = k⊕ µ}1≤ j≤S|
(0x00 ≤ k ≤ 0xFF)
represents the distribution on Zr required to obtain the
observed ciphertexts {Cj,r}1≤ j≤S by encrypting µ. We

USENIX Association  

22nd USENIX Security Symposium  311

7

Algorithm 4: Single-byte bias attack
input : S independent encryptions {Cj}1≤ j≤S of
ﬁxed plaintext P, position r, keystream
distribution (pr,k)0x00≤k≤0xFF at position r

output: estimate P∗r for plaintext byte Pr
begin

N0x00 ← 0, . . . , N0xFF ← 0
for j = 1 to S do

for µ = 0x00 to 0xFF do

NCj,r ← NCj,r + 1
for k = 0x00 to 0xFF do

N(µ)
k ← Nk⊕µ
k=0x00 N(µ)
k

λµ ← ∑0xFF

log pr,k
P∗r ← argmaxµ∈{0x00,...,0xFF} λµ
return P∗r

compare these induced distributions (one for each pos-
sible µ) with the accurate distribution pr,0x00, . . . , pr,0xFF
and interpret a close match as an indication for the cor-
responding plaintext candidate µ being the correct one,
i.e., Pr = µ. More formally, we observe that the proba-
bility λµ that plaintext byte µ is encrypted to ciphertext
bytes {Cj,r}1≤ j≤S follows a multinomial distribution and
can be precisely calculated as

λµ =

S!

N(µ)
0x00!···N (µ)
0xFF!

∏

k∈{0x00,...,0xFF}

pN(µ)

k
r,k

.

(1)

By computing λµ for all 0x00 ≤ µ ≤ 0xFF and identify-
ing µ such that λµ is largest, we determine the (optimal)
maximum-likelihood plaintext byte value. Algorithm 4
speciﬁes the details of the described single-byte bias at-
tack, including the optimizations discussed next.
Observe that, for each ﬁxed position r and set of
ciphertexts {Cj,r}1≤ j≤S, values N(µ)
can be computed
from values N(µ(cid:23))
by equation N(µ)
k⊕µ(cid:23)⊕µ, for
In other words, vectors (N(µ)
0xFF) and
all k.
(N(µ(cid:23))
0xFF) are permutations of each other; by
consequence, term S!/(N(µ)
0xFF!) in equation (1)
can safely be ignored when determining the largest λµ.
Furthermore, computing and comparing log(λµ ) instead
of λµ makes the computation slightly more efﬁcient.

k = N(µ(cid:23))
0x00, . . . ,N (µ)

0x00!···N (µ)

0x00, . . . ,N (µ(cid:23))

k

k

4.2 Our Double-byte Bias Attack
As we have seen, Algorithm 4 allows the recovery of the
initial 256 bytes of plaintext when multiple encryptions
under different keys are observed by the attacker. In the
following, we describe an algorithm which allows the re-
covery of plaintext bytes at any position in the plaintext.

8

Furthermore, the algorithm does not require the plain-
text to be encrypted under many different keys but works
equally well for plaintexts repeatedly encrypted under a
single key.

Our algorithm is based on biases in the distribution of
consecutive bytes (Zr,Zr+1) of the RC4 keystream that
occur as long term biases, i.e., that appear periodically
at regular intervals in the keystream. As described in
Section 3, we empirically measured the biases which are
repeated with a period of 256 bytes. However, in 250 ex-
perimentally generated keystream bytes we observed no
signiﬁcant new biases besides those already identiﬁed by
Fluhrer and McGrew [12]; for the purpose of construct-
ing our algorithm, we hence use the biases described in
Table 1 and assume that all other consecutive byte pairs
are equally likely to appear in the keystream. In other
words, we assume that we have accurate estimates pr,k1,k2
such that

pr,k1,k2 = Pr[(Zr,Zr+1) = (k1,k2)]

for 1 ≤ r ≤ 256 and 0x00 ≤ k1,k2 ≤ 0xFF, where the
probability is taken over all possible conﬁgurations of
the internal state S and the index j of the RC4 keystream
generation algorithm.9 Note that, since these proba-
bilities express biases that are repeated with a period
of 256 bytes, we have pr,k1,k2 = p(r mod 256),k1,k2 for all
r,k1,k2.

Let L be an integer multiple of 256. In the following
description of our plaintext recovery algorithm, we as-
sume that a ﬁxed L-byte plaintext P = P1||···||PL is en-
crypted repeatedly under a single key, i.e., we consider a
ciphertext C obtained by encrypting P||···||P. (In fact, it
is sufﬁcient for our attack that the target plaintext bytes
form a subsequence of consecutive bytes that are con-
stant across blocks of L bytes.) Let Cj denote the sub-
string of C corresponding to the encryption of the j-th
copy of P, and let Cj,r denote the r-th byte of Cj (i.e.,
Cj,r corresponds to byte ( j− 1)· L + r of C).
Given this setting, it seems reasonable to take an ap-
proach towards plaintext recovery similar to that of Al-
gorithm 4: for each position r, the most likely plaintext
pair (µr, µr+1) could be computed from the ciphertext
bytes {(Cj,r,Cj,r+1)}1≤ j≤S and the probability estimates
{pr,k1,k2}0x00≤k1,k2≤0xFF. In other words, a plaintext can-
didate would be obtained by splitting ciphertexts C into
byte pairs and individually computing the most likely
corresponding plaintext pairs.

However, by considering overlapping byte pairs, it is
possible to construct a more accurate estimate of the like-
lihood of a plaintext candidate being correct than by just
considering the likelihood of individual byte-pairs. More
speciﬁcally, for any plaintext candidate P(cid:23) = µ1||···||µL
we compute an estimated likelihood λP(cid:23) = λµ1||···||µL for

312  22nd USENIX Security Symposium 

USENIX Association

(cid:31)=2 δµ(cid:31)|µ(cid:31)−1.

((cid:31) ≤ L),

P(cid:31) being correct via the recursion
λµ1||···||µ(cid:31)−1||µ(cid:31) = δµ(cid:31)|µ(cid:31)−1 · λµ1||···||µ(cid:31)−1
(2)
where δµ(cid:31)|µ(cid:31)−1 denotes the probability that P(cid:31) = µ(cid:31)
assuming P(cid:31)−1 = µ(cid:31)−1, and λµ1||···||µ(cid:31)−1
is the esti-
mated likelihood of µ1||···||µ(cid:31)−1 being the correct
((cid:31) − 1)-length preﬁx of P. We show below how
values δµ(cid:31)|µ(cid:31)−1 can be computed given the ciphertext
bytes {(Cj,(cid:31)−1,Cj,(cid:31))}1≤ j≤S and the probability estimates
{p(cid:31)−1,k1,k2}0x00≤k1,k2≤0xFF. Note that, by rewriting equa-
tion (2) and assuming that λµ1 = Pr[P1 = µ1] is accurately
known, we obtain likelihood estimate λP(cid:31) = Pr[P1 =
µ1]∏L

Our algorithm computes the plaintext candidate P∗ =
µ1||···||µL which maximizes the estimated likelihood
λP∗. This is done by exploiting the following easy-
to-see optimality-preserving property:
for all preﬁxes
µ1||···||µ(cid:31) of P∗, (cid:31) ≤ L, we have that λµ1||···||µ(cid:31)−1 is the
largest likelihood among all ((cid:31)− 1)-length plaintext can-
didates with µ(cid:31)−1 as the last byte.
The basic idea of our algorithm is to iteratively con-
struct P∗ by considering the preﬁxes of P∗ with increas-
ing length. As just argued, these correspond to the
(partial) plaintext candidates with the highest likelihood
and a speciﬁc choice of the last byte value. However,
when computing a candidate for a length (cid:31) ≤ L, it is
not known in advance what the speciﬁc value of the
last byte µ(cid:31) should be. Our algorithm hence computes
the most likely partial plaintext candidates for all pos-
sible values of µ(cid:31). More speciﬁcally, for each ((cid:31) − 1)-
length partial candidate µ1||···||µ(cid:31)−1 and any value µ(cid:31),
we compute the likelihood of the (cid:31)-length plaintext can-
didate µ1||···||µ(cid:31)−1||µ(cid:31) via equation (2) as λµ1||···||µ(cid:31) =
δµ(cid:31)|µ(cid:31)−1 · λµ1||···||µ(cid:31)−1. Due to the optimality-preserving
property, the string µ1||···||µ(cid:31) with the highest likeli-
hood will correspond to the most likely plaintext can-
didates of length (cid:31) with the last byte µ(cid:31). This guarantees
that the (cid:31)-length preﬁx of (optimal) P∗ will be among the
computed candidates and, furthermore, when the length
of P∗ is reached, that P∗ itself will be obtained.

To initialize the above process, the algorithm assumes
that the ﬁrst plaintext byte µ1 of P is known with cer-
tainty, i.e., λµ1 = 1 (this can, for example, be assumed
if the attack is used to recover HTTP cookies from an
encrypted HTTP(S) header). Likewise, the algorithm as-
sumes that the last byte µL of P is known, i.e., λµL = 1
(also this is the case when recovering HTTP cookies).
This leads to a single µL being used in the last iteration of
the above process which will then return the most likely
plaintext candidate P∗. (See Remark 1 for how the al-
gorithm can be modiﬁed to work without these assump-
tions.)

remains to show the details of how δµi+1|µi
This is done similarly to the

can be computed.

It

of

the

computation

proba-
maximum-likelihood
bility estimate used in Algorithm 4. More pre-
cisely, each combination of index i, pair (µi, µi+1),
in-
and
duces
keystream bytes
{(Z( j−1)L+i,Z( j−1)L+i+1)}1≤ j≤S.
The latter can be
represented as a vector (Ni,0x00,0x00, . . . ,Ni,0xFF,0xFF),
where

{(Cj,i,Cj,i+1)}1≤ j≤S

ciphertext
a

distribution

bytes

the

on

Ni,k1,k2 =|{ j| (Cj,i, Cj,i+1) = (k1⊕µi,k2⊕µi+1)}1≤ j≤S| .
As in Section 4.1, we see that this vector follows a
multinomial distribution, and that the probability that
(Ni,0x00,0x00, . . . ,Ni,0xFF,0xFF) will arise (i.e., the probabil-
ity that (µi, µi+1) corresponds to the i-th and the (i+1)-th
plaintext bytes) is given by

Pr[Pi = µi ∧ Pi+1 = µi+1|C] =

S!

Ni,0x00,0x00!···Ni,0xFF,0xFF!
We can now compute δµi+1|µi as

∏

k1,k2∈{0x00,...,0xFF}

(3)

p

Ni,k1,k2
i,k1,k2

.

δµi+1|µi = Pr[Pi+1 = µi+1|Pi = µi ∧C]
Pr[Pi = µi ∧ Pi+1 = µi+1|C]

=

Pr[Pi = µi|C]

.

(4)

We assume that no signiﬁcant single-byte biases are
present in the keystream, i.e., that Pr[Pi = µi|C] is uni-
form over the possible plaintext values µi. Under this
condition, since the term will stay invariant for all plain-
text candidates, we can ignore the contribution of fac-
tor 1/Pr[Pi = µi|C] in (4), when comparing probabil-
ity estimates. This is likewise the case for the terms
S!/(Ni,0x00,0x00, . . . ,Ni,0xFF,0xFF) in (3), due to similar ob-
servations as made for Algorithm 4.

We combine the results of the discussion from the
preceeding paragraphs, including the proposed optimiza-
tions, to obtain our double-byte bias attack in Algo-
rithm 5.
Remark 1. The above assumption, that the ﬁrst and last
byte of the plaintext P is known, can easily be avoided.
Speciﬁcally, if the ﬁrst byte is unknown, Algorithm 5 can
be initialized by computing, for each possible value µ2,
the most likely pairs (µ1, µ2). This can be done based
on the ciphertext bytes {(Cj,1,Cj,2)}1≤ j≤S and the proba-
bility estimates {p1,k1,k2}0x00≤k1,k2≤0xFF. Likewise, if the
last byte is unknown, the algorithm will identify P∗ as the
plaintext candidate with the highest likelihood estimate
among the computed plaintext candidates of length L.
Note, however, that knowing the ﬁrst and last plaintext
byte will lead to a more accurate likelihood estimate and
will thereby increase the success rate of the algorithm.

USENIX Association  

22nd USENIX Security Symposium  313

9

Algorithm 5: Double-byte bias attack
input : C – encryption of S copies of ﬁxed plaintext P

(Cj,r denotes the r-th byte of the substring of C encrypting the j-th copy of P)
L – length of P in bytes (must be a multiple of 256)
µ1 and µL – the ﬁrst and last byte of P
{pr,k1,k2}1≤r≤L−1, 0x00≤k1,k2≤0xFF – keystream distribution

output: estimate P∗ for plaintext P
notation: let max2(Q) denote (P,λ ) ∈ Q such that λ ≥ λ(cid:24)∀(P(cid:24),λ(cid:24)) ∈ Q
begin

N(r,k1,k2) ← 0
for j = 1 to S do

for all 1 ≤ r < L, 0x00 ≤ k1,k2 ≤ 0xFF

for r = 1 to L− 1 do

N(r,Cj,r,Cj,r+1) ← N(r,Cj,r,Cj,r+1) + 1

Q ← {(µ1,0)}
for r = 1 to L− 2 do
Qext ← {}
for µr+1 = 0x00 to 0xFF do

// List of plaintext candidates of length r + 1

// List of plaintext candidates ending with µr+1

Qµr+1 ← {}
for each (P(cid:24),λP(cid:24)) ∈ Q do
P(cid:24) → µ1||···||µr
λP(cid:24)||µr+1 ← λP(cid:24) + ∑0xFF
Qµr+1 ← Qµr+1 ∪{(P(cid:24)||µr+1 ,λP(cid:24)||µr+1)}

k1=0x00 ∑0xFF

Qext ← Qext ∪{max2(Qµr+1 )}

k2=0x00 N(r,k1⊕µr,k2⊕µr+1) · log p(r,k1,k2)

// List of plaintext candidates ending with µL

Q ← Qext

QµL ← {}
for each (P(cid:24),λP(cid:24)) ∈ Q do
P(cid:24) → µ1||···||µL−1
λP(cid:24)||µL ← λP(cid:24) + ∑0xFF
k1=0x00 ∑0xFF
QµL ← QµL ∪{(P(cid:24)||µL ,λP(cid:24)||µL )}
(P∗,λP∗) ← max2(QµL )
return P∗

k2=0x00 N(r,k1⊕µL−1,k2⊕µL) · log p(r,k1,k2)

5 Experimental Results

Through simulation, we measured the performance of
the single-byte and double-byte bias attacks. We further-
more validated our algorithms in real attack scenarios.

5.1 Simulation of Single-byte Bias Attack
We simulated the ﬁrst plaintext recovery attack described
in Section 4. We used RC4 keystreams for 244 ran-
dom keys to estimate the per-output-byte probabilities
{pr,k}1≤r≤256,0x00≤k≤0xFF. We then ran the attack in Al-
gorithm 4 256 times for each of S = 224,225, . . . ,2 32 ses-
sions to estimate the attack’s success rate. The results for
S = 224,226, . . . ,2 30 are shown in Figures 4–7. In each
ﬁgure, we show the success rate in recovering the correct
plaintext byte versus the position r of the byte in the out-
put stream (but recall that, in practice, the ﬁrst 36 bytes

are not interesting as they contain the Finished mes-
sage). Some notable features of these ﬁgures are:
• Even with as few as 224 sessions, some positions
of the plaintext are correctly recovered with high
probability. The ones with highest probability seem
to arise because of the key-length-dependent bi-
ases that we observed in positions that are multiples
of 16. These large biases make it easier to recover
the correct plaintext bytes when compared to other
ciphertext positions.
• With S = 226 sessions, the ﬁrst 46 plaintext bytes
are recovered with rate at least 50% per byte.
• With S = 232 sessions (not shown here; see [4]), all
of the ﬁrst 256 bytes of output are recovered with
rate close to 100%: the rate is at least 96% in all
positions, and is 100% for all but 12 positions.

314  22nd USENIX Security Symposium 

USENIX Association

10

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

Figure 4: Recovery rate of the single-byte bias attack for
S = 224 sessions for ﬁrst 256 bytes of plaintext (based on
256 experiments).

Figure 6: Recovery rate of the single-byte bias attack for
S = 228 sessions for the ﬁrst 256 bytes of plaintext (based
on 256 experiments).

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

Figure 5: Recovery rate of the single-byte bias attack for
S = 226 sessions for the ﬁrst 256 bytes of plaintext (based
on 256 experiments).

Figure 7: Recovery rate of the single-byte bias attack for
S = 230 sessions for the ﬁrst 256 bytes of plaintext (based
on 256 experiments).

• The rate at which bytes are correctly recovered in-
creases steadily as the number of sessions S is in-
creased, with all but the last few bytes being reliably
recovered already for 231 trials.

Secondly, we executed the recovery attack in a setting
where plaintexts are encoded with a 4-bits-per-byte en-
coding scheme using the characters ‘0’ to ‘9’ and ‘a’
to ‘f’. Such restricted plaintext character sets are rou-
tinely used in different applications [4]; for instance,
in the popular PHP server-side scripting language, the
encoding of HTTP cookies can be limited to a repre-
sentation with 4 bits per character [20]. We reused
the probability estimates {pr,k}1≤r≤256,0x00≤k≤0xFF for
the RC4 keystream bytes generated for the simulation
above, and ran a modiﬁed version of Algorithm 4 which
takes into account the restricted plaintext space. The
modiﬁed algorithm was run 256 times for each of S =
224,225, . . . ,2 32 sessions. The results for S = 224, S = 226
and S = 228 are shown in Figures 8–10. For comparison,
the ﬁgures include the success rate of the original attack

for an unrestricted plaintext space. We note:
• With S = 226 sessions, the ﬁrst 112 plaintext bytes
are recovered with rate at least 50% per byte. This
represents a marked improvement over the case of
an unrestricted plaintext space, where only the ﬁrst
46 bytes were recovered with rate at least 50% per
byte.
• With S = 224, . . . ,2 28 sessions, the recovery attack
for the restricted plaintext space has a better success
rate than the recovery attack for the unrestricted
plaintext space with twice the number of sessions
(i.e. S = 225, . . . ,2 29) for almost all positions.

5.2 Simulation of Double-byte Bias Attack
We simulated the second plaintext recovery attack based
on Algorithm 5.
In the simulation, we encrypted S =
1· 230, . . . ,13 · 230 copies of the same 256-byte plaintext

USENIX Association  

22nd USENIX Security Symposium  315

11

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

Figure 8: Recovery rates for the restricted plaintext space
(red) and the original single-byte bias attack (blue) for
S = 224 sessions (based on 256 experiments).

Figure 10: Recovery rates for the restricted plaintext
space (red) and the original single-byte bias attack (blue)
for S = 228 sessions (based on 256 experiments).

1.2"

1"

0.8"

0.6"

0.4"

0.2"

0"

0"

10"

20"

30"

40"

50"

60"

70"

80"

90"

100"

110"

120"

130"

140"

150"

160"

170"

180"

190"

200"

210"

220"

230"

240"

250"

Figure 9: Recovery rates for the restricted plaintext space
(red) and the original single-byte bias attack (blue) for
S = 226 sessions (based on 256 experiments).

and attempted to recover 16 bytes located at a ﬁxed po-
sition in the plaintext. More precisely, we simulated an
attack in which we assume the ﬁrst byte of the plaintext
is known, the following 16 bytes are the unknown bytes
targeted by the attack, and the byte immediately follow-
ing these is known. The remaining bytes are assumed
not to be of interest in the attack. This attack scenario is
very similar to the case in which an adversary attempts to
recover a cookie value from an HTTP request. Depend-
ing on the number of plaintext copies, we used between
one and ﬁve 128-bit RC4 keys for the encryption10. As
highlighted in Section 4.2, we used the biases described
by Fluhrer-McGrew [12] to compute the probability esti-
mates {pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF required by Algo-
rithm 5.
The attack was run 128 times for each of S = 1 ·
230, . . . ,13 · 230 encrypted copies of the plaintext to esti-
mate the success rate of the attack. The results are shown
in Figure 11: the dashed line shows the average fraction
of successfully recovered plaintext bytes versus the num-

ber of encrypted plaintexts, whereas the solid line shows
the success rate of recovering the full 16-byte plaintext
versus the number of encrypted plaintexts. We note:
• With S = 6 · 230 encrypted copies of the plaintext,
more than 50% of the plaintext is correctly recov-
ered on average. Furthermore, in 19% of the 128
trials, the full 16-byte plaintext was recovered.
• With S = 8 · 230 encrypted copies of the plaintext,
the full plaintext is correctly recovered in signiﬁ-
cantly more than 50% of the 128 trials (more pre-
cisely, the full plaintext was recovered in 72% of
the trials).
• With S = 13· 230 the full plaintext was recovered in
all trials.

• The rate at which the full plaintext is correctly re-
covered increases fairly rapidly after S = 5 · 230
copies of the plaintext are encrypted, and with S =
11· 230, the full plaintext is correctly recovered in
nearly all trials (99%).

In addition, similar to Section 5.1, we simulated
the attack for plaintexts encoded with a 6-bits-per-byte
(base64) and a 4-bits-per-byte encoding scheme. Specif-
ically, we ﬁrstly ran a modiﬁed version of Algorithm 5
which takes into account the restricted plaintext space by
only considering candidate plaintext bytes which corre-
spond to byte-values used in a base64 encoding. Fur-
thermore, we used a plaintext where the 16 bytes tar-
geted by the attack consisted of bytes with a byte-value
corresponding to the character ‘b’, which is a valid
base64 encoded message. As in the attack above for a
non-restricted plaintext space, the probability estimates
{pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF were based on the biases
from [12]. The attack was run 128 times for each of

316  22nd USENIX Security Symposium 

USENIX Association

12









	













	




















	









	













	




















	

Figure 11: Average fraction of successfully recovered
plaintext bytes (dashed line), and success rate for recov-
ering the full 16-byte plaintext (solid line) of the double-
byte bias attack based on 128 experiments. The unit of
the x-axis is 230 encrypted copies of the plaintext.

Figure 13: Average fraction of successfully recovered
plaintext bytes (dashed line), and success rate for re-
covering the full 16-byte plaintext (solid line) of the
double-byte bias attack for 4-bit-per-byte encoded plain-
texts (based on 128 experiments). The unit of the x-axis
is 230 encrypted copies of the plaintext.









	













	




















	

Figure 12: Average fraction of successfully recovered
plaintext bytes (dashed line), and success rate for recov-
ering the full 16-byte plaintext (solid line) of the double-
byte bias attack for base64 encoded plaintexts (based on
128 experiments). The unit of the x-axis is 230 encrypted
copies of the plaintext.

S = 1· 230, . . . ,12· 230 encrypted copies of the plaintext,
and the results are shown in Figure 12. We note:
• With S = 4 · 230 encrypted copies of the plaintext,
more than 50% of the plaintext is correctly recov-
ered on average. Furthermore, in 4% of the 128 tri-
als, the full 16-byte plaintext is recovered.
• With S = 6 · 230 encrypted copies of the plaintext,
the full plaintext is correctly recovered in 50% of
the 128 trials.
• With S = 10· 230 encrypted copies of the plaintext,
the full plaintext is correctly recovered in nearly all
trials (98%).

Regarding the 4-bit-per-byte encoding scheme, we
again assumed a plaintext character set consisting of

‘0’ to ‘9’ and ‘a’ to ‘f’. The setup was similar to the
above experiment for base64 encoded messages: we ran
a modiﬁed version of Algorithm 5 which takes into ac-
count the restricted plaintext space, the probability esti-
mates {pr,k1,k2}1≤r≤255,0x00≤k1,k2≤0xFF was based on the
biases from [12], and we used a plaintext consisting
of bytes with a byte-value corresponding to the char-
acter ‘b’. The attack was run 128 times for each of
S = 1· 230, . . . ,10· 230 encrypted copies of the plaintext,
and the results can be seen in Figure 13. We note:
• With S = 3 · 230 encrypted copies of the plaintext,
signiﬁcantly more than 50% of the plaintext is cor-
rectly recovered on average (more precisely, 72% is
recovered correctly on average).
• With S = 5 · 230 encrypted copies of the plaintext,
the full plaintext is recovered in more than 50% of
the 128 trials.
• With S = 8 · 230 encrypted copies of the plaintext,
the full plaintext is recovered in nearly all trials
(98%).

5.3 Practical Validation
We tested the success rates of our plaintext recovery al-
gorithms in realistic attack settings involving web servers
and browsers that are connected through TLS-secured
network links. Here, we report on the results.

5.3.1 Validating the operation of RC4 in TLS
We ﬁrst experimentally veriﬁed that the OpenSSL im-
plementation of TLS does indeed use RC4 in the way

USENIX Association  

22nd USENIX Security Symposium  317

13

explained in Section 2.2, in particular without discard-
ing any initial keystream bytes. We did this by setting
up an OpenSSL version 1.0.1c client and server running
in a virtualised environment, making use of s client
and s server, generic tools that are available as part
of the OpenSSL distribution package. The two virtual
machines were running Ubuntu 12.10 and kernel version
3.5.0-17.

5.3.2 Validating the single-byte bias attack

Recall that our single-byte bias attack targets the ﬁrst 256
bytes of plaintext across multiple TLS sessions or con-
nections with random keys. In order to efﬁciently gen-
erate the large number of ciphertexts needed to test our
attack, we again used the s client and s server tools,
this time modifying the s client source code to force a
session resumption for each TLS packet sent.

Using this approach, we were able to generate around
221 encryptions of a ﬁxed plaintext per hour; with 225
recorded ciphertexts, we obtained results comparable to
the simulation of our single-byte bias attack reported in
Section 5.1 above. A second possible approach to ensure
frequently enough rekeying is to actively interfere with
the TLS session after each ciphertext is sent, causing it
to fail and be restarted, by injecting a bad TLS packet or
by resetting the corresponding TCP connection.

We admit that we do not currently have an automated
mechanism for forcing session resumption, e.g., from
JavaScript. However, JavaScript running in the browser
can trigger the browser to establish a fresh TLS session
(with a fresh, random key) after each HTTP connection
torn down by the attacker. We estimate that this second
approach would be signiﬁcantly slower than using ses-
sion resumption because of the additional overhead of
running the full TLS Handshake. Thus, even though our
double-byte bias attack has higher complexity in terms
of its ciphertext requirements than our single-byte bias
attack, in practice it could be the more efﬁcient attack in
terms of total running time, because it can be executed in
a single session (or a small number of sessions).

Furthermore, while the single-byte bias attack suc-
cessfully recovered ﬁxed plaintext bytes in the initial
256 bytes of the TLS ciphertexts, our subsequent experi-
mentation with modern web browsers revealed that these
bytes consisted mostly of less interesting HTTP head-
ers rather than cookies. For this reason, after this ba-
sic validation, we switched our experimental focus to the
double-byte bias attack.

5.3.3 Validating the double-byte bias attack

The double-byte bias attack does not rely on session re-
sumption or session renegotiation and is hence easier to

implement in practice. As our experimental setup for
this attack, we used a network comprising three (non-
virtualized) nodes: a legitimate web server (www.abc.
com) that serves 16-byte secure cookies over HTTPS,
a malicious web server (www.evil.com) serving a ma-
licious JavaScript, and a client running a web browser
representing a user. The legitimate and malicious web
servers run Apache and PHP. For the client, we experi-
mented with various browsers, including Firefox, Opera
and Chrome. The nodes were connected through a
100 Mbps Ethernet link; they were equipped with Intel
Core i7 processors with 2.3 GHz cores and 16 GB of
RAM. None of our experiments used all available CPU
resources, nor saturated the network bandwidth.

In this setup, we let the client visit https://www.
abc.com. This will result in the legitimate web server
sending the client a secure cookie which will be stored
by the client’s browser. This cookie will be the tar-
get of the attack. We then let the client visit http://
www.evil.com and run the malicious JavaScript served
by the malicious web server. Note that the same-origin
policy (SOP) implemented by the client’s browser will
prevent the JavaScript from directly accessing the se-
cure cookie. However, the JavaScript will direct repeated
HTTP requests to the legitimate server over TLS (i.e. us-
ing HTTPS)11. The client’s browser will then automat-
ically attach the cookie to each request and thereby re-
peatedly encrypt the target cookie as required in our at-
tack.

The JavaScript uses XMLHttpRequest objects12 to
send the requests. We tested GET, POST, and HEAD re-
quests, but found that POST requests gave the best per-
formance (using Firefox). Furthermore, we found that
the requests needed to be send in blocks to ensure that
the browser stayed responsive and didn’t become over-
loaded.

For all the browsers we tested (Firefox, Chrome, and
Opera), we found that the requests generated by the
JavaScript resulted in TLS messages containing more
than 256 bytes of ciphertext. To keep the target cookie
in a ﬁxed position in the TLS message (modulo 256)
as needed for the double-byte bias attack, we therefore
added padding by manipulating the HTTP headers in the
request to bring the encrypted POST requests up to ex-
actly 512 bytes. This padding introduces some overhead
to the attack. The exact amount and location of padding
needed is browser-dependent, since different browsers
behave differently in terms of the content and order of
HTTP headers included in POST requests.
In practice,
then, the attacker’s JavaScript would need to perform
some browser ﬁngerprinting before carrying out its at-
tack.

As an alternative method for generating request to the
legitimate web server, we tried replacing the JavaScript

318  22nd USENIX Security Symposium 

USENIX Association

14

code with basic HTML code, using HTML tags such as img,
pointing to https://www.abc.com. The target cookie
was still sent in every request, but we found this approach
to be less effective (i.e. slower) than using JavaScript.

For Firefox with 512-byte ciphertexts encrypting
padded XMLHttpRequest POST requests, we were able
to generate 6 million ciphertexts per hour on our net-
work, with each request containing the target cookie in
the same position (modulo 256) in the corresponding
plaintext. Given that our attack needs on the order of
13 · 230 encryptions to recover a 16-byte plaintext with
high success probability, we estimate that the running
time for the whole attack would be on the order of 2000
hours using our experimental setup. The attack gener-
ates large volumes of network trafﬁc over long periods of
time, and so should not be considered a practical threat.
Nevertheless, it demonstrates that our double-byte bias
attack does work in principle.

6 Discussion and Conclusions

We have shown that plaintext recovery for RC4 in TLS
is possible for the ﬁrst about 200 or so bytes of the
plaintext stream (after the Finished message), provided
sufﬁciently many independent encryptions of the same
plaintext are available. The number of encryptions re-
quired (around 228 to 232 for reliable recovery) is large,
but not completely infeasible. We have also shown that
plaintext recovery for RC4 is possible from arbitrary po-
sitions in the plaintext, given enough encryptions of the
same plaintext bytes. Here, the number of encryptions
required is rather higher (around 13· 230), but the attack
is more ﬂexible and more efﬁcient in practice because
it avoids rerunning the TLS Handshake. Certainly, the
security level provided by RC4 in TLS is far below the
strength implied by the 128-bit key in TLS.

This said, it would be incorrect to describe the attacks
as being a practical threat to TLS today. However, our
attacks are open to further enhancement, using, for ex-
ample, the ability of our algorithms to output likelihoods
for candidate plaintext bytes coupled with more sophis-
ticated plaintext models. It may also be possible to en-
hance the rate of ciphertext generation in browsers using
methods beyond our knowledge. It would seem danger-
ous to assume that the attacks will not be improved by
other researchers in future.

There are countermeasures to the attacks. We dis-
cussed these countermeasures extensively with vendors
during the disclosure process that we followed prior to
making our attacks public. They include: discarding
the initial keystream bytes output by RC4, as recom-
mended in [19]; fragmenting the initial HTTP requests at
the browser so that the initial keystream bytes are mostly
(or entirely) used to encrypt MAC ﬁelds; adding random

padding to HTTP requests; and limiting the lifetime of
cookies or the number of times they can be sent from
the browser. The ﬁrst countermeasure cannot easily be
implemented in TLS because it would require mass co-
ordination between the many different client and server
implementations. The ﬁrst two countermeasures are not
effective against our double-byte bias attack. The third
countermeasure can be relatively easily implemented in
browsers but increases the complexity of our attacks
rather than defeating them completely. The fourth coun-
termeasure is currently effective, but not immune to fur-
ther improvements of our attacks. Some vendors (e.g.
Opera13) have implemented a combination of these (and
other) countermeasures; others (e.g. Google in Chrome)
are focussing on implementing TLS 1.2 and AES-GCM.
We recognise that, with around 50% of TLS trafﬁc
currently using RC4, recommending that it be avoided
completely in TLS is not a suggestion to be made lightly.
Nevertheless, given the rather small security margin pro-
vided by RC4 against our attacks, our recommendation
is that RC4 should henceforth be avoided in TLS, and
deprecated as soon as possible.

Acknowledgements

We thank David McGrew for raising the question of the
security of RC4 in TLS.

References
[1] Wireless LAN medium access control (MAC) and physical layer

(PHY) speciﬁcation, 1997.

[2] Wireless LAN medium access control (MAC) and physical layer
(PHY) speciﬁcation: Amendment 6: Medium access control
(MAC) security enhancements, 2004.

[3] ALFARDAN, N., AND PATERSON, K. G. Lucky 13: Breaking
In IEEE Symposium on

the TLS and DTLS record protocols.
Security and Privacy (2013).

[4] ALFARDAN, N. J., BERNSTEIN, D. J., PATERSON, K. G., PO-
ETTERING, B., AND SCHULDT, J. C. N. On the security of RC4
in TLS and WPA.
Information Security Group at Royal Hol-
loway, University of London, 2013. http://www.isg.rhul.
ac.uk/tls/RC4biases.pdf.

[5] AMMAN, B. Personal communication, February 2013.
[6] CANVEL, B., HILTGEN, A., VAUDENAY, S., AND VUAGNOUX,
M. Password interception in a SSL/TLS channel. Advances in
Cryptology-CRYPTO 2003 (2003), 583–599.

[7] DIERKS, T., AND ALLEN, C. The TLS Protocol Version 1.0.

RFC 2246, Internet Engineering Task Force, Jan. 1999.

[8] DIERKS, T., AND RESCORLA, E. The Transport Layer Secu-
rity (TLS) Protocol Version 1.1. RFC 4346, Internet Engineering
Task Force, Apr. 2006.

[9] DIERKS, T., AND RESCORLA, E. The Transport Layer Secu-
rity (TLS) Protocol Version 1.2. RFC 5246, Internet Engineering
Task Force, Aug. 2008.

[10] DUONG, T., AND RIZZO, J. Here come the ⊕ Ninjas. Unpub-

lished manuscript, 2011.

USENIX Association  

22nd USENIX Security Symposium  319

15

Notes

of RC4
see

being
advice

the
at Qualys’ website

in

1The research of the third, fourth and ﬁfth authors was supported
by an EPSRC Leadership Fellowship, EP/H005455/1. The research of
the second author was supported by the National Science Foundation
under grant 1018836 and by the Netherlands Organisation for Scientiﬁc
Research (NWO) under grant 639.073.005.

Pulse

(https://www.trustworthyinternet.org/
ssl-pulse/) reported in June 2013 that only 15.1% of 170,000
websites surveyed support TLS 1.2; most major browsers currently do
not support TLS 1.2.
examples

recommended

3For

2SSL

of CBC attacks,

face
https://community.qualys.com/blogs/securitylabs/
2011/10/17/mitigating-the-beast-attack-on-tls,
Ivan Ristic’s personal blog http://blog.ivanristic.com/
2009/08/is-rc4-safe-for-use-in-ssl.html,
PhoneFac-
tor’s
http://blog.phonefactor.com/2011/09/23/
slaying-beast-mitigating-the-latest-ssltls
-vulnerability, and F5’s suggested Lucky 13 mitigation at
http://support.f5.com/kb/en-us/solutions/public/
14000/100/sol14190.html. Other examples abound on discussion
forums and vendor websites.

blog

4http://notary.icsi.berkeley.edu
5Unfortunately, we do not currently know of a way to trigger TLS

session resumption from JavaScript running in a browser.

6The Internet Message Access Protocol (IMAP) is a popular proto-

col for email retrieval.

7Note that when attacking secret URL parameters from HTTPS
connections or passwords from IMAP sessions such limitations do not
arise.

8 In detail, instead of an internal permutation S of 8-bit values,
Fluhrer and McGrew consider variants of RC4 based on permutations
of 3-bit, 4-bit, and 5-bit values, respectively. Note that in these versions
of RC4, the internal variables i and j, as well as the output Zr, will also
be 3-bit, 4-bit and 5-bit values, respectively.
9Note that the internal state S, which corresponds to a permutation
over byte values, will not be distributed as a random permutation im-
mediately after the key scheduling algorithm is run, even if the used
key is picked uniformly at random. Furthermore, j will not be random,
but initialized to 0. However, random S and j will be a close approx-
imation after keystream bytes have been generated a short period of
time (see [12] for further discussion of this property).

10Our experiments showed that there is no signiﬁcant difference in
the recovery rate when running the attack on encryptions of the plain-
text generated by a single key and encryptions generated by a small
number of different keys.

11This is made possible by Cross-Origin Resource Sharing (CORS),
a mechanism developed to allow JavaScript to make requests to another
domain than the domain the script originates from.
12http://www.w3.org/TR/XMLHttpRequest/
13http://my.opera.com/securitygroup/blog/2013/03/

20/on-the-precariousness-of-rc4

[11] FLUHRER, S. R., MANTIN, I., AND SHAMIR, A. Weaknesses in
the key scheduling algorithm of RC4. In Selected Areas in Cryp-
tography (2001), S. Vaudenay and A. M. Youssef, Eds., vol. 2259
of Lecture Notes in Computer Science, Springer, pp. 1–24.

[12] FLUHRER, S. R., AND MCGREW, D. Statistical analysis of the
alleged RC4 keystream generator. In FSE (2000), B. Schneier,
Ed., vol. 1978 of Lecture Notes in Computer Science, Springer,
pp. 19–30.

[13] ISOBE, T., OHIGASHI, T., WATANABE, Y., AND MORII, M.
Full plaintext recovery attack on broadcast RC4. In Preproceed-
ings of FSE (2013).

[14] JAGANATHAN, K., ZHU, L., AND BREZAK, J. The RC4-HMAC
Kerberos Encryption Types Used by Microsoft Windows. RFC
4757 (Informational), Dec. 2006.

[15] MAITRA, S., PAUL, G., AND SENGUPTA, S. Attack on broad-
In FSE (2011), A. Joux, Ed., vol. 6733 of

cast RC4 revisited.
Lecture Notes in Computer Science, Springer, pp. 199–217.

[16] MANTIN,

I.

Predicting and distinguishing attacks on rc4
keystream generator. In EUROCRYPT (2005), R. Cramer, Ed.,
vol. 3494 of Lecture Notes in Computer Science, Springer,
pp. 491–506.

[17] MANTIN, I., AND SHAMIR, A. A practical attack on broadcast
RC4. In FSE (2001), M. Matsui, Ed., vol. 2355 of Lecture Notes
in Computer Science, Springer, pp. 152–164.

[18] MCGREW, D., AND BAILEY, D. AES-CCM Cipher Suites for
Transport Layer Security (TLS). RFC 6655 (Proposed Standard),
2012.

[19] MIRONOV, I.

(Not so) random shufﬂes of RC4.

In CRYPTO
(2002), M. Yung, Ed., vol. 2442 of Lecture Notes in Computer
Science, Springer, pp. 304–319.

[20] PHP DOCUMENTATION GROUP. PHP manual, Feb 2013. http:

//www.php.net/manual/en/session.configuration.
php#ini.session.hash-bits-per-character.

[21] SALOWEY, J., CHOUDHURY, A., AND MCGREW, D. AES Ga-
lois Counter Mode (GCM) Cipher Suites for TLS. RFC 5288
(Proposed Standard), Aug. 2008.

[22] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S.
Proof of empirical RC4 biases and new key correlations. In Se-
lected Areas in Cryptography (2011), pp. 151–168.

[23] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S.
(Non-) random sequences from (non-) random permutations –
analysis of RC4 stream cipher. Journal of Cryptology to appear
(2013).

[24] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Discov-
ery and exploitation of new biases in RC4. In Selected Areas in
Cryptography (2010), A. Biryukov, G. Gong, and D. R. Stinson,
Eds., vol. 6544 of Lecture Notes in Computer Science, Springer,
pp. 74–91.

[25] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Sta-
tistical attack on RC4 – distinguishing WPA. In EUROCRYPT
(2011), K. G. Paterson, Ed., vol. 6632 of Lecture Notes in Com-
puter Science, Springer, pp. 343–363.

[26] VAUDENAY, S., AND VUAGNOUX, M. Passive-only key recov-
ery attacks on RC4. In Selected Areas in Cryptography (2007),
C. M. Adams, A. Miri, and M. J. Wiener, Eds., vol. 4876 of Lec-
ture Notes in Computer Science, Springer, pp. 344–359.

320  22nd USENIX Security Symposium 

USENIX Association

16

