Constant Communication ORAM with Small Blocksize

Tarik Moataz

Colorado State University
Telecom Bretagne, IMT

tmoataz@cs.colostate.edu

Travis Mayberry

United States Naval Academy

travism@ccs.neu.edu

Erik-Oliver Blass

Airbus Group Innovations
81663 Munich, Germany

erik-oliver.blass@airbus.com

ABSTRACT
There have been several attempts recently at using homomorphic
encryption to increase the efﬁciency of Oblivious RAM protocols.
One of the most successful has been Onion ORAM, which achieves
O(1) communication overhead with polylogarithmic server com-
putation. However, it has two drawbacks. It requires a large block
size of B = Ω(log6 N ) with large constants. Moreover, while it
only needs polylogarithmic computation complexity, that compu-
tation consists mostly of expensive homomorphic multiplications.
In this work, we address these problems and reduce the required
block size to Ω(log4 N ). We remove most of the homomorphic
multiplications while maintaining O(1) communication complex-
ity. Our idea is to replace their homomorphic eviction routine with
a new, much cheaper permute-and-merge eviction which eliminates
homomorphic multiplications and maintains the same level of se-
curity. In turn, this removes the need for layered encryption that
Onion ORAM relies on and reduces both the minimum block size
and server computation.

1.

INTRODUCTION

With cloud storage becoming increasingly popular and relied
upon by both enterprise and individual users, ensuring proper se-
curity and privacy is a critical research problem. Reports indicate
that up to 88% of organizations [24] are using public cloud infras-
tructure for at least some of their data. It is fairly straightforward to
encrypt that data, but that is not always enough. Where, when and
how often a user accesses their data can reveal as much about it as
the plaintext itself. We call this information a user’s access pattern.
For instance, observing that an investment bank has repeatedly ac-
cessed their ﬁles on a speciﬁc company may reveal that they plan
to invest in that company. Crucially, there is no easy way to bound
what information you might leak as part of your access pattern, es-
pecially when an adversary can correlate those accesses with other
outside (potentially public) information he might have.

Oblivious RAM is a tool that was designed to solve exactly this
problem. Given a set of accesses to a block storage device, an
ORAM algorithm allows a user to perform them on an untrusted
storage device in such a way that an adversary observing those ac-

Publication rights licensed to ACM. ACM acknowledges that this contribution was au-
thored or co-authored by an employee, contractor or afﬁliate of the United States gov-
ernment. As such, the United States Government retains a nonexclusive, royalty-free
right to publish or reproduce this article, or to allow others to do so, for Government
purposes only.
CCS’15, October 12–16, 2015, Denver, CO, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813701 .

cesses cannot determine which block the user was reading/writing.
This generally involves shufﬂing and reencrypting the data some-
how each time it is read or written to in order to unlink two ac-
cesses to the same block. Unfortunately, ORAM has traditionally
been very expensive to implement, causing over a thousand-fold
increase in communication over unprotected accesses.

Recently there has been a ﬂurry of research on ORAM that has
managed to drastically decrease communication overhead with a
new tree-based paradigm [25]. Building on that, Stefanov et al. [27]
introduced Path ORAM which, along with some derivative works,
is the most efﬁcient construction currently known. However, it still
requires polylogarithmic communication overhead which can re-
sult in over a hundred-fold slowdown and may not be usable for
many cloud applications given that cost is a driving factor in out-
sourcing data. Along with work on pure Oblivious RAM, May-
berry et al. [17] introduced the idea that communication overhead
can be greatly reduced if the storage device is also considered to
have some computational ability, which it generally does in a cloud
setting. Using recent advances in homomorphic encryption, a small
amount of computation on the server can be leveraged to cut a sig-
niﬁcant amount of communication to the client, see also [1].

Furthering this research, Devadas et al. [6] have recently pro-
posed a hybrid ORAM-with-computation scheme that achieves O(1)
communication overhead. They achieve this by consecutively wrap-
ping blocks in further layers of encryption as they proceed down
the tree, effectively forming an “onion” out of the blocks. Unfortu-
nately, it still has some major drawbacks:

1. Their scheme requires that the block has a very large size of
Ω(log6 N ). In practice, it can be up to 30 MB for reasonably
sized databases.

2. The onion part of their scheme requires a large number of ho-
momorphic multiplications, which are computationally very
expensive. Depending on the encryption scheme used, over-
head on the server may outweigh any communication saved.

In this work we tackle these problems. We start by showing that
the homomorphic multiplications, and in fact the nesting “onion”
nature of their solution, is not necessary. With careful application
of an oblivious merging algorithm, all movement of blocks through
the tree can be done with only homomorphic addition, resulting in
a more computationally efﬁcient algorithm. This also reduced the
required block size by a O(log2 N ) factor and, as we will show,
allows for O(1) communication complexity in the worst case. Fi-
nally, we demonstrate via experimental evaluation that our scheme
requires only a small storage overhead compared to Onion ORAM.
For practical parameter values, we achieve signiﬁcant improvement
in block size and number of homomorphic operations. Table 1 sum-
marizes our improvements when compared to Onion ORAM.

862Table 1: Comparison of Onion ORAM and C-ORAM, containing block size, worst-case bandwidth, and number of homomorphic additions
and multiplications. The simpliﬁed block value is a looser bound for easier comparison using λ = ω(log N ) and γ = O(λ3).

Scheme

Onion ORAM

C-ORAM

Block size B
Ω(γλ log2 N )

Ω(λ[log λ log N + γ])

Simpliﬁed block size Worst-case bandwidth

# additions

Ω(log6 N )
Ω(log4 N )

O(1)
O(1)

Θ(Bλ log N )
Θ(Bλ log N )

# multiplications
Θ(Bλ log N )

Θ(Bλ)

2. BACKGROUND: ONION ORAM

We start by brieﬂy introducing the main idea of Onion ORAM [6]

and then analyze its complexity to motivate our improvements.

2.1 Overview

An Oblivious RAM is a block-based storage protocol whereby a
user can outsource some data to an untrusted server, and that server
does not learn anything about the pattern of accesses that the user
performs on that data. For instance, whether the user accesses the
same block many times in a row, or each block individually in se-
quence, the server will not be able to distinguish between these two
access patterns. In fact, a secure ORAM guarantees that any two
access patterns will be indistinguishable from the perspective of the
server. This is accomplished by periodically moving, shufﬂing and
reencrypting the data so that correlations between accesses are lost.
A twist on that model introduced by Mayberry et al. [17], and used
in Onion ORAM, is that instead of the traditional ORAM server
deﬁnition where it only stores the data passively, Onion ORAM
assumes that the server can also perform computations.

Onion ORAM is a tree-based ORAM, and shares many qualities
with existing schemes [23, 25, 27]. Most importantly, data blocks
are stored in a tree where each node of the tree is a “bucket” which
contains some number of blocks. When blocks are added to the
ORAM, they start at the root of the tree and are tagged as belonging
to one of the leaf nodes. As the lifecycle of the ORAM continues,
blocks percolate from the root to their assigned leaf node through
a process called eviction. This way, a block can be located at any
time by reading the path from its target leaf back to the root, since
it is guaranteed to always reside on this path. The eviction process
maintains a proper ﬂow of blocks from the root to the leaves so
that no buckets overﬂow with too many blocks. This is usually
accomplished by picking a path in the tree, from root to a particular
leaf node, and pushing all the blocks on that path as far as possible
down the path toward the leaf node.

The contribution of Onion ORAM is then that it achieves con-
stant communication complexity in the number of ORAM elements
N, while only requiring polylogarithmic computation on the server.
Although the client exchanges many pieces of data back and forth
with the server, the key to having O(1) communication complex-
ity is that the size of one data block B dominates the communi-
cation. All other messages, ciphertexts etc. are collectively small
compared to the actual data being retrieved. Therefore, it might be
more intuitive to say that communication is O(B). However, it is
customary in ORAM literature to refer to the communication com-
plexity in terms of multiplicative overhead, i.e., the cost compared
to retrieving the same data without security. Everything is then di-
vided by B, and we get to O(1) communication complexity. Note
that O(1) communication complexity is not difﬁcult if you allow
unrestricted computation (FHE for instance achieves this trivially),
so the limit to polylogarithmic computation is important.

The main idea behind Onion ORAM is an oblivious shufﬂing

based on (computational) Private Information Retrieval (PIR). There-
with, ORAM read, write, and eviction operations can be performed
without the client actually downloading data blocks and doing the
merging themselves. This saves a huge amount of communication

when compared to existing schemes like Path ORAM. Compared
to existing tree-based ORAM schemes, Onion ORAM introduces
a triple eviction that empties all buckets along the path instead of
only pushing some elements down and leaving others at interme-
diate points in the tree. Elements in any evicted bucket will be
pushed towards both children, thereby ensuring that after an evic-
tion the entire evicted path is empty aside from the leaves. The
authors take advantage of the fact that if you choose which path to
evict by reverse lexicographic ordering, then you are always guar-
anteed during an eviction that the sibling of every node on your
path will already be empty from a previous eviction. This allows
for the entire process to be done efﬁciently and smoothly, because
the entire contents of a parent can be copied into the empty bucket.
This triple eviction is accomplished by sending a logarithmic
number of oblivious shufﬂing vectors to the server. These vectors,
encrypted with an additively homomorphic encryption, obliviously
map an old block of the parent bucket to a new position in the child.
This operation is made by a matrix multiplication between the vec-
tor sent to the server and the bucket. Considering the size of the
bucket as logarithmic, this algebraic computation should be per-
formed a polylogarithmic number of times. This results that each
block is encrypted, without transitional decryption, a logarithmic
number of times, hence, the attributed name “onion”.

The above results in an ORAM with constant communication
complexity and constant client-memory in the number of elements
N stored in the ORAM, see Table 1.
2.2 Analysis

As noted above, O(1) communication complexity does not im-
ply that blocks are the only information exchanged between client
and server. In Onion ORAM, the client still needs to retrieve meta-
information and send PIR vectors for PIR reads and PIR writes.
Thus, Onion ORAM chooses the block size such that all commu-
nication between server and client is asymptotically dominated by
block size B. That is, if B ∈ O(|meta-information|+|PIR vectors|),
then Onion ORAM has constant communication complexity.
Large Block Size: Consequently, to achieve constant communi-
cation complexity, Onion ORAM requires a large block size B.
For a security parameter γ in the order of 2048 Bytes, bucket size
z = Θ(λ), and number of elements N, the block size B in Onion
ORAM is in Ω(γλ log2 N ). This is a signiﬁcant increase over
B ∈ Ω(log N ) as required by related work [25, 27]. Generally,
large block sizes render ORAMs impractical for many real world
scenarios where the block size is ﬁxed and simply predetermined by
an application. To mitigate the problem, Onion ORAM uses Lip-
maa’s PIR [15] instead of straightforward additively homomorphic
PIR [13]. This decreases block size to B ∈ Ω(γ log2 λ log2 N ).
Factor λ is replaced by log2 λ. On a side note, observe that using
Lipmaa’s PIR might not result in much (or any) gain in practice.
Parameter λ is a security parameter with λ ∈ ω(log N ). So, it is
typically small and therefore “close” to log2 λ. For example, for
λ = 80, log2 λ = 40 is in the same order of magnitude. Since
Lipmaa’s method requires substantially more computation than the
straightforward approach, the small gain in communication is likely
to be outweighed by additional computation time.

863Onion ORAM block size example: For security parameter γ =
2048, number of elements N = 220, and security parameter λ =
80, the block size must be at least B = 2048· log2 (80)· 202 ≈ 33
MBits. Thus, the dataset size equals 220 · 33 · 106 ≈ 35 TBits.
This computation is very rough and does not take into account ad-
ditional, hidden constants such as the constant for the additively
homomorphic cipher chunk in Ω(γ log N ), or smaller, yet still sig-
niﬁcant constants, like the fact that downloads have corresponding
uploads which multiplies everything by 2. Requiring blocks of size
at least 4 MBytes to store N = 220 elements is impractical for
many real world applications. In conclusion, Onion ORAM can
only be applied to very special data sets with very large block sizes.

3. CONSTANT COMMUNICATION ORAM
Overview: To achieve our increased efﬁciency and lower block
size, we present a novel, efﬁcient, oblivious bucket merging tech-
nique for Onion ORAM that replaces its expensive layered encryp-
tion. We apply our bucket merging during ORAM eviction. The
content of a parent node/bucket and its child node/bucket can be
merged obliviously, i.e., the server does not learn any information
about the load of each bucket. The idea is that the client sends a per-
mutation Π to the server. Using this permutation, the server aligns
the individual encrypted blocks of the two buckets and merges them
into a destination bucket. The client chooses the permutation such
that blocks containing real data in one bucket are always aligned
to empty blocks in the other bucket. As each block is encrypted
with additively homomorphic encryption, merging two blocks is a
simple addition of ciphertexts. For the server, merging is oblivious,
because, informally, any permutation Π from the client is indistin-
guishable from a randomly chosen permutation.

For buckets of size O(z), our oblivious merging evicts elements
from a parent bucket to its child with O(z log z) bits of communi-
cation instead of O(γz2) of Onion ORAM. As a result of applying
our merging technique, we only need a constant number of PIR
reads and writes for ORAM operations.

Based on our merging technique, we now present increasingly
sophisticated modiﬁcations to Onion ORAM to reduce its costs.
We call the resulting ORAM, i.e., Onion ORAM with our modi-
ﬁcation, C-ORAM. As a warm up, we present a technique allow-
ing amortized constant communication complexity with a smaller
block size B in Ω(z log z log N +γz log N ). Our second and main
technique achieves constant worst case communication complexity
with smaller block size in Ω(z log z log N + γz).
3.1 Oblivious Merging

Oblivious merging is a technique that obliviously lines up two
buckets in a speciﬁc order and merges them into one bucket. Us-
ing this technique, we can evict real data elements from a bucket to
another by permuting the order of blocks of one of them and then
adding additively homomorphically encrypted blocks. Oblivious
merging is based on an oblivious permutation generation that takes
as input the conﬁgurations of two buckets and outputs a permuta-
tion Π. A conﬁguration of a bucket speciﬁes which of the blocks
in the bucket are real blocks and which are empty. Permutation Π
arranges blocks in such a way that there are no real data elements
at the same position in the two blocks.

3.1.1 C-ORAM Construction
C-ORAM keeps Onion ORAM’s main construction. That is, C-
ORAM is a tree-based ORAM composed of a main tree ORAM
storing the actual data and a recursive ORAM storing the position
map. The position map consists of a number of ORAM trees with

Figure 1: C-ORAM bucket structure

linearly increasing height mapping a given address to a tag. For n
elements stored in the ORAM, the communication needed to access
the position map is in O(log2 N ). As with all recent tree-based
ORAMS, the recursive position map’s communication complexity
is dominated by the block size. For the remainder of this paper, we
therefore restrict our description to C-ORAM’s main data tree.
Let N be a power of 2. C-ORAM is a binary tree with L levels
and 2L leave nodes. Each node/bucket contains µ · z blocks. Here,
z is the number of slots needed to hold blocks as in Onion ORAM
and µ is a multiplicative constant that gives extra room in the buck-
ets for noisy blocks, a detail we will cover below which is important
for our construction. We maintain the same relation between N, L
and z as in Onion ORAM, namely N ≤ z · 2L−1. Each block in
a C-ORAM bucket is encrypted using an additively homomorphic
encryption, e.g., Pailler’s or Damgard-Jurik’s cryptosystem. Also,
each bucket contains IND-CPA encrypted meta-information, head-
ers, containing additional information about a bucket’s contents.
3.1.2 Headers
Bucket headers are an important component in C-ORAM as they
determine how oblivious permutations are generated. A bucket
header is comprised of two parts: the ﬁrst part stores for each block
whether it is noisy, contains real data or is empty. The second part
stores the block tags. More formally, the header is composed of two
vectors header1 and header2. Vector header1 has length µ · z, and
each element is either noisy, empty or real. Thus, each element has
a size of two bits. The total size of this vector is in O(µz). header2
is a (µ · z × log N ) binary matrix. The rows represent the address
of the blocks. Finally, as with all tree based ORAMS, each block
in a bucket also contains the encryption of its address. That is, the
address of each block is encrypted separately from the block itself.
We show a high level view of a C-ORAM bucket in Fig 1.
3.2 C-ORAM: First Construction

To prepare for our main contribution, we start by presenting a
new technique allowing amortized constant communication com-
plexity with a smaller block size.
3.2.1 Overview
To access an element in C-ORAM, i.e., read or write, the client
ﬁrst fetches the corresponding tag from the position map. This tag
deﬁnes a unique path starting from the root of the ORAM tree and
going to a speciﬁc leaf given by the tag. The element might reside
in any bucket on this path. To ﬁnd this element, we make use of a
PIR read [13] that will be applied to each bucket. To verify whether
the block exists in a bucket, the client downloads the encrypted
headers of each bucket. Therewith, the client can generate a PIR
read vector retrieving the block from a bucket. To preserve the
scheme’s obliviousness, the client sends PIR read vectors for each

864bucket on the path. Once the block has been retrieved, the client
can modify the block’s content if required, then insert it back into
the root of the C-ORAM tree using PIR write. This is the standard
Path-PIR behavior to read from or write into blocks [17].

Eviction in our ﬁrst construction takes place after every χ =
O(z) access operations. As in Onion ORAM, a path in C-ORAM is
selected following deterministic reverse lexicographic order. Then,
the entire root of the ORAM tree is downloaded, randomly shuf-
ﬂed and written back (additively homomorphically) encrypted. Fi-
nally, the eviction is performed by repeatedly applying an oblivious
merge on buckets along the selected path. Any bucket belonging to
this path is obliviously merged with its parent while the other child
of the parent will be overwritten by a copy of the parent bucket.
We call the former bucket on the path the destination bucket and
the latter one its sibling bucket.

Before starting the eviction of a speciﬁc path, an invariant of the
eviction process is that siblings of buckets of this path are empty,
except the leaves. After the eviction, all buckets belonging to the
evicted path will be empty except the leaf [6]. Note that siblings of
this path, after the eviction, will not be empty anymore. See Fig 2
for a sample eviction with N = 8.

Sibling buckets, since they are simply copies of their parents,
will contain blocks with tags outside the subtree of this bucket.
These blocks are called noisy blocks as they do not belong into this
subtree and are essentially leftover “junk”. Now for correctness, in
our construction, we will guarantee that the number of noisy blocks
in any bucket is upper bounded. So, there will always be space for
real elements in a bucket and will not overﬂow.

Elements in each bucket are encrypted using additively homo-
morphic encryption, respectively. Given two buckets B1 and B2,
oblivious merging will permute the position of blocks in B1 such
that there are no real or noisy element at the same positions in B1
and B2. Consequently, if there is a real element in the ith position
in B1, then for the scheme to be correct, the ith position in B2
should be empty. The following addition of elements at the same
position in B1 and B2 will preserve the value of the real element.
After χ operations, we also download the leaf bucket to delete its
noisy blocks.

3.2.2 Details and Analysis
Let P(tag) denote the path starting from the root and going to
the leaf identiﬁed by tag. The path is composed of L + 1 buckets
including the root. P(tag, i) refers to the bucket at the ith level
of P(tag). For example, P(tag, 0) is the root bucket. Ps(tag, i)
is the sibling of bucket P(tag, i). Let [N ] be the set of integers
{1,··· , N}, x $←− [N ] uniformly sampling a random element from
set [N ], and χ the period of eviction which is in O(z). Identity is
an empty bucket containing only encryptions of zero.

Algorithm 1 presents details of the access operation. An access
can be either an ORAM Read or a Write operation. The only dif-
ference between the two is that a write changes the value of the
block before putting it back in the root. The access operation in-
vokes a PIR read algorithm, see Algorithm 2 that obliviously re-
trieves a block. Algorithm 3 shows the eviction where elements
percolate towards their leaves using oblivious permutations, see Al-
gorithm 4.

Block size: The following asymptotic analysis will be in function
of z, N, and γ. z is the size of the bucket, N the number of ele-
ments, and γ the length of the ciphertext of the additively homo-
morphic encryption. The communication complexity induced by
an ORAM access operation comprises a PIR read operation and
the eviction process (happening every χ ∈ O(z) accesses). The

Input: Operation op, address adr, data data, counter ctr, state st
Output: Block B associated to address addr
// Fetch tag value from position map

1 tag = posMap(adr);
$← [N ];

2 posMap(adr)
3 if ctr = 0 mod (χ) then
4

Download root bucket, refresh encryptions, randomize order of
real elements;
Evict(st);
for i from 0 to L do B = B+PIR-Read(adr, P(tag, i)) ;

5
6 else
7
8 end
9 if op = write then set B = data ;
10 ctr = ctr + 1;
11 Upload IND-CPA encrypted block to root P(tag, 0);
Algorithm 1: Access(op, adr, data, ctr, st): C-ORAM access
operation, 1st construction

size of the bucket is µ · z, but we will show in our security analy-
sis section later that µ is a constant. Therefore, we ignore it in our
analysis.
First, the client performs PIR reads L + 1 times. For this, the
client has to download all addresses in the path, i.e., O(z·L·log N )
bits. Also, the client should send a logarithmic number of PIR read
vectors V with size O(γ · z · L) bits. Note that the computation of
PIR read vectors outputs, for all but one buckets’ block, encryption
of zeros. Instead of sending back a logarithmic number of blocks
to the client, the server only sends a single block, the summation
of all the blocks output, cf. Algorithm 1. Thus, the client only
retrieves a single block B. A PIR read applied to all buckets of the
path induces an overhead in O(z · L · log N + γ · z · L + B).

For the eviction, the client downloads header1 and the ith col-
umn of header2 and sends permutations for all buckets in the path.
Thus, the overhead induced by the permutations is O(L · z · log z)
bits. Also, after every χ = O(z) operations, the client downloads
the root and one leaf, which has O(zB) communication complex-
ity. Amortized, for each operation we have Oz(B) communication
complexity (amortized over z).
In conclusion, each access has Oz(z · L · log N + γ · z · L +
z · log(z) · L + B) communication complexity. To have constant
communication complexity in B, the block size should be B ∈
Ω(z·L·log N +γ·z·L+L·z·log z) ∈ Ω(λ·log2 N +γ·λ·log N ).
The above is a consequence of z = Θ(λ), λ ∈ ω(log n), and
L ∈ Θ(log N ). Based on current attacks [15], γ = O(λ3). There-
fore, λ · log2 N is dominated by γ · λ · log N, and B ∈ Ω(γ · λ ·
log N ).

The block size of our ﬁrst modiﬁcation is already a log N multi-
plicative factor improvement over the block size of Onion ORAM.
However, in practice, this value is still large. The main idea of
our second construction is based on the following observation. The
block size has exactly the same asymptotic as transmitted vectors
V. So to improve the block size, we change the way we are ac-
cessing the ORAM. Note that we can de-amortize C-ORAM ﬁrst
construction using techniques from [30].

3.3 C-ORAM: Second Construction

We start by further reducing the block size – again by a multi-
plicative factor of log N compared to our ﬁrst construction. Re-
call that in our ﬁrst construction, the worst case involves a blow-
up of O(z), because during eviction the client needs to download
O(z · B) bits. In our second and main construction, the eviction
remains exactly the same, and our focus will only be on ORAM
access.

865Input: Bucket P(tag, level)), address adr
Output: Block B
// Compute the PIR-Read vector V in client side

1 Retrieve and decrypt addresses Addr of bucket P(tag, level));
2 if adr ∈ Addr then

// Retrieve the index α
α = Addr[addr];
for i from 1 to µ · z do

if i (cid:54)= α then Vi ← ENC(0) else
Vi ← ENC(1) ;

3
4
5
6
7
8 else
9
10 end
11 Parse bucket P(tag, level) as (µ · z × |B|) binary matrix M;

end
for i from 1 to µ · z do Vi ← ENC(0) ;

// Retrieve block in server side

i=1 Vi · M1,i, · · · ,(cid:80)µ·z

12 B = ((cid:80)µ·z

i=1 Vi · M|B|,i);

13 Update headerlevel

of bucket P(tag, level);

1

Algorithm 2: PIR-Read(adr,P(tag, level))

3.3.1 Overview
In our ﬁrst modiﬁcation, we perform a PIR read per bucket dur-
ing an access. Contrary, we now perform an oblivious merge to
ﬁnd out the block to retrieve. For an ORAM access to tag, our idea
is to perform a special evict of path P(tag). We push all real el-
ements in P(tag) towards the leaf and then simply access the leaf
bucket. So, we preserve access obliviousness and make sure that
the element we want is pushed into leaf bucket tag.

This approach comes with several challenges. We must preserve
the bucket distribution. That is, we have to maintain the empty sib-
ling property, as guaranteed by the reverse lexicographic eviction,
before evicting any path. Instead of deterministically selecting a
path for eviction, we select randomly. However, with randomized
eviction, we still have to guarantee empty siblings on the evicted
path. By randomly evicting a path, we might copy a bucket in its
sibling resulting in a correctness ﬂaw.
Our approach will be to temporarily clone the path P(tag). The
clone of P(tag) serves to simulate the eviction towards the leaf
bucket, and we remove the clone after the access operation. We
apply the oblivious merging on the bucket of this cloned path, and
at the end we will have all real elements in the leaf bucket of the
cloned path. Finally, we apply a PIR read to retrieve the block.

Besides, to get rid of the amortized cost and have a scheme that
only requires a constant bandwidth in the worst case, we make use
of a PIR write operation that will be performed during every ac-
cess. In the ﬁrst construction, we have to shufﬂe the root bucket
since oblivious merging has to be performed on random buckets
for security purposes. Moreover, we need to eliminate noisy blocks
from the leaf buckets and therefore after each χ operations, the
client downloads the evicted leaf to eliminate all noisy blocks. In
our second C-ORAM construction, we are evicting after every ac-
cess. Consequently, we can be certain that the root bucket is always
empty after an eviction. The ﬁrst PIR write operation that we per-
form will randomly insert the block in an empty root bucket after
any access obliviously. The second use of PIR write is to delete the
retrieved element from the leaf. In fact, we can also delete noisy
blocks by the same tool but a PIR read is needed to retrieve ﬁrst the
noisy block that we will overwrite with a PIR write. We dedicate
Section 4.2 to analyze security and correctness of our modiﬁcation.
3.3.2 Details and Analysis
Algorithm 5 presents the core of our second C-ORAM construc-
tion. Now, instead of performing a logarithmic number of PIR
reads, we only invoke an Evict-Clone to read a block, cf. Algo-

Input: State st
Output: Evicted path and updated state st

1 for i from 0 to L − 1 do
2
3

;

1

1 and headeri+1

2 and headeri+1

Retrieve headeri
Retrieve Ci and Ci+1 respectively the ith and the (i + 1)th
of the bucket P(st, i) and
column of headeri
P(st, i + 1);
π ← GenPerm((headeri
the oblivious permutation π;
// Merge the parent and destination bucket
P(st, i + 1) = π(P(st, i)) + P(st, i + 1);
if i < L − 1 then

1, Ci), (headeri+1

, Ci+1)), generate

2

1

// Copy the parent bucket into its
Ps(st, i) = P(st, i);

sibling

else

// Merge the last bucket with the sibling

leaf

Retrieve headeri+1
π ← GenPerm((headeri
P(st, i + 1) = π(P(st, i)) + P(st, i + 1);

1, Ci), (header1

and Ci+1 from the sibling leaf;

i+1, Ci+1));

1

4

5
6

7
8

9

10
11
12
13

14
15
16 end

end
Update(headeri
Update(headeri+1
P(st, i) = Identity;

1

1) and store it with bucket Ps(st, i);

) and store it with bucket P(st, i + 1);

Algorithm 3: Evict(st), eviction process

rithm 6. Evict-Clone uses our oblivious merging together with one
PIR read to retrieve a block. We evict after every access. To elim-
inate noisy blocks that have been percolated to the leaf bucket, we
use a PIR write to delete the noisy block, cf. Algorithm 7.

Block size: The access operation in C-ORAM is composed of
scheduled path eviction, eviction in the cloned path, a PIR read,
and two PIR writes. The size of the headers are negligible com-
pared to the PIR read and write vectors. For sake of clarity, we
therefore avoid including them in our asymptotic analysis.

First, the eviction always involves an overhead of O(zL log z).
Evict-Clone performs one PIR read in addition to the regular evict.
Finally, we retrieve the block of size B. Therefore, the overhead in-
duced by these steps is O(zL log z + z log N + γz + B). Adding
the two PIR writes and single PIR read operation will not change
asymptotic behavior since the number of these operations is con-
stant in N. In conclusion, to have a bandwidth that is constant in
block size B, the block size should be B ∈ Ω(z · L · log z + z · γ).
With z ∈ Θ(λ), λ ∈ ω(log N ) and L ∈ Θ(log N ), we achieve
B ∈ Ω(λ · [log N · log λ + γ]). In practice, γ ∈ O(λ3), so γ
dominates log N · log λ. Therefore, block size B is B ∈ Ω(γλ).
Our second C-ORAM construction achieves worst-case constant
blow-up and omits inefﬁcient PIR reads performed for ORAM ac-
cess. This second construction improves the block size by a multi-
plicative factor of log2 N compared to Onion ORAM.
As you can see, the main overhead of C-ORAM’s block size
comes from the size of ciphertext γ. Recall that γ ∈ O(λ3). There-
fore, the smaller the additively homomorphic ciphertext will get,
the smaller the block size of C-ORAM will be.

4. C-ORAM ANALYSIS
4.1 C-ORAM correctness analysis

The goal of the correctness analysis section is to show that, dur-
ing any eviction (algorithms Evict and Evict-Clone), the probabil-
ity that a failure occurs is small. The failure in C-ORAM is deﬁned

866$← all noisy slots in A;
z
d2 = d2 − 1;

$← all empty slots in A;

z

end
case B[i] is empty
if d1 > 0 then

$← all non-assigned slots in A;
z
d1 = d1 − 1;

9
10
11

12
13
14
15
16

17
18
19

else

end

else

Input: Conﬁguration of buckets A and B
Output: A permutation randomly lining up bucket B to bucket A
// Slots in A and B start either empty, full

or noisy; mark slots in A as assigned if
block from B is assigned in π

1 Let x1, x2 be the number of empty and noisy slots in A;
2 Let y1, y2 be the number of full and noisy slots in B;
3 d1 = x1 − y1;
4 d2 = x2 − y2;
5 for i from 1 to µ · z do
case B[i] is full z
6
case B[i] is noisy
7
8

$← all empty slots in A ;

if d2 > 0 then

$← all full slots in A;

z

end

end
π[i] = z;
A[z] = assigned;

20
21
22
23
24
25 end
26 return π;
Algorithm 4: GenPerm(A, B), oblivious permutation generation

as the lack of encryption of zeros in the evicted path. In this sec-
tion, we only consider the proof of correctness of C-ORAM’s ﬁrst
construction. The proof of correctness of C-ORAM’s second con-
struction is a straightforward extension from the ﬁrst one. Before
presenting details of our correctness analysis, we introduce some
notations and assumptions.
Let Bi,j refer to the bucket at the ith level of the path evicted at
the jth step. Each bucket contains µ· z blocks, with integer µ > 1.
In C-ORAM’s ﬁrst construction, the root bucket contains z real
elements and (µ−1)·z empty blocks. We set φ = µ−1. An empty
block represents an additively homomorphic encryption of zero.
Each bucket cannot have more than z real elements at any time
with high probability, as we will prove in Theorem 4.3. Let Zi,j
be the discrete random variable of the number of blocks containing
an encryption of zero in bucket Bi,j. Similarly, Ri,j represents the
number of real blocks. Recall that if a real block is pushed to a
path leading to a leaf different from its own tag, this block is called
a noisy block. ˜Ni,j represents the random variable that counts the
number of noisy blocks in bucket Bi,j. Finally, the jth eviction
step is the eviction of the jth path following a deterministic reverse
lexicographic order.
Formally, the eviction in Evict algorithm fails if ∃i ∈ {0, . . . ,
L} and k ∈ N such that Zi+1,k < Ri,k or Zi,k < Ri+1,k. Thus,
the proof’s goal will be to show that there is no such integer i ∈ {0,
. . . , L} that veriﬁes both inequalities with high probability.

First, we need to introduce two properties that will help us to
understand the proof and the eviction mechanism more thoroughly.
The ﬁrst property is called the path composition history while the
second one is the bucket composition history. Given a path P(j),
the path composition history captures the eviction step in which
each bucket has been created. Given a bucket Bi,j, the bucket com-

Input: Operation op, address adr, data data, state st
Output: Block B associated to address adr
// Fetch tag value from position map

1 tag = posMap(adr);
$← [N ];

2 posMap(adr)

// Retrieve desired block

3 B =Evict-Clone(adr, tag);
4 if op = write then set B = data ;

// Select a random position in the root bucket

// Write back the block to the empty root

$← [µ · z];

5 pos1
6 PIR-Write(pos1, B, P(st, 0));
7 Evict(st);

// Select a random noisy block position from

the header of the leaf P(st, L)
$← headerL;

// Write back the negation of the noisy block

8 pos2
9 N =PIR-Read(pos2, P(st, L));
10 PIR-Write(pos2, −N, P(st, L));
Algorithm 5: Access(op, adr, data, st): C-ORAM access oper-
ation, 2th construction

Input: Leaf tag and address adr
Output: Block B

1 Create a copy of the C-ORAM path P(tag);
2 for i from 0 to L − 1 do
3
4

1 and headeri+1

1

;

2 and headeri+1

Retrieve headeri
Retrieve Ci and Ci+1 respectively the ith and the (i + 1)th
column of headeri
P(tag, i + 1);
// Generate the oblivious permutation π
π ← GenPerm((headeri
// Merge the parent and destination bucket
P(tag, i + 1) = π(P(tag, i)) + P(tag, i + 1);

of the bucket P(tag, i) and

1, Ci), (headeri+1

, Ci+1));

2

1

5

6
7 end
8 B =PIR-Read(adr, P(tag, L));
9 for i from 0 to L do
1 in P(tag, i);
Update headeri
10
11 end

Algorithm 6: Evict-Clone(adr, tag)

position history is a sequence that captures all buckets that have
contributed to the construction of the bucket Bi,j.

Path composition history: In C-ORAM, the eviction follows a de-
terministic reverse lexicographic order. In the jth step of eviction,
every bucket of the path P(j) has been created on a previous evic-
tion. Thus, we associate to a bucket its eviction step during which
it has been created. In particular, every bucket in this path has been
created from a different eviction step. We are interested on deﬁning
the relation between the eviction steps of buckets belonging to the
same evicted path. This relation follows a pattern which is common
to all evicted paths. For instance, in Fig. 3, the path P(9) of the 9th
eviction is composed of buckets B1,8, B2,7, B3,5. These are buck-
ets that were created, respectively, in the 8th, 7th, and 5th eviction
step. We do not count the root bucket and the leaf, because the pat-
tern of their eviction is clear. That is, the root is evicted every time
while the leaf is evicted following reverse lexicographic order.
Formally, for N elements stored in the ORAM and L ∈ Θ(log N ),
one can easily show by induction that the jth evicted path, for all
j ≥ 1, is composed of {B1,j−20 , B2,j−21 , . . . , BL−1,j−2L−2}.

After L evictions, buckets belonging to an evicted path, except
the leaves, are copies of a bucket from previous evictions. In our
proof, we will later assume that the ORAM has performed a num-
ber of evictions larger than L. We will also consider the worst case

867Input: Position pos, bucket P(tag, level), block B
Output: Updated bucket P(tag, level)
// Compute the PIR-Write vector V in client side

// Write block in server side

if i (cid:54)= pos then Vi ← ENC(0) else
Vi ← ENC(1) ;

1 for i from 1 to µ · z do
2
3
4 end
5 Parse bucket P(tag, level) as (µ · z × |B|) binary matrix M;
6 Mi,j = Wi · Bj;
7 P(tag, level) = M + P(tag, level);
Algorithm 7: PIR-Write(pos, block, P(tag, level)), PIR-write
process

Figure 2: Buckets on evicted path are with horizontal hatching.
Bucket 3 is a copy of the root. Bucket 4 results from merging buck-
ets 1 and 2. Bucket 6 results from merging 1, 2, and 5.

where all buckets might eventually contain real or noisy blocks.

Bucket composition history: This property follows from the pre-
vious one. Given a path P(j), the eviction will empty all buckets
in this path except the leaf. The eviction works as follows:
the
root B0,j will be merged with its destination child B1,j−20 in the
path while the sibling B(cid:48)
1,j, originally empty, will be overwritten
by a copy of the root. The root is ﬁnally overwritten by an empty
bucket. The bucket B1,j−20 will be merged with its destination
child B2,j−21 then emptied. The sibling of the bucket B1,j−20 will
be overwritten by the content of B1,j−20. We reiterate the process
until the end of the path (this was a recapitulation of Evict).

Given a bucket Bi,j, we are interested in enumerating the evic-
tion’s steps of creation of all buckets that have contributed to bucket
Bi,j. The bucket composition also follows a pattern that is unique
to any bucket in the construction. Given the eviction algorithm, ev-
ery bucket in the ith level is created by merging all buckets in the
path from the root to the (i− 1)th level, see Table 2 for an example
of this pattern for N = 16. As an example, the bucket in path 9 at
the 3rd level was created during the 5th eviction step. To determine
the buckets that contributed to this bucket’s creation, we check the

Illustration of nine evictions. Numbers below leaves
Figure 3:
represent the order of reverse deterministic lexicographic eviction.
Buckets with same shapes were full and then evicted at the same
step. Example: buckets with triangular shape are evicted in step 9.

Table 2: Bucket creation pattern in function of the eviction step.

Level1
Level2
Level3
Evicted path

8
7
5
9

7
6
4
8

6
5
3
7

5
4
2
6

4
3
1
5

3
2
-
4

2
1
-
3

1
-
-
2

-
-
-
1

column that has an evicted path equal to 5. Then, we consider all
buckets that are in upper levels: buckets 4 and 3 which are in lev-
els 2 and 1. In general, a bucket Bi,j is the result of merging the
following buckets: {B0,j, B1,j−20 , B2,j−21 , . . . , Bi−1,j−2i−2}.
Noisy blocks: It is important to understand the source of prove-
nance of noisy blocks. From a one hand, a noisy block can be cre-
ated whenever an access has been performed on C-ORAM. There-
fore, the accessed block is not valid anymore and should be turned
to a noisy block by updating the headers. On the other hand, a
noisy block can be also created from the eviction process. During
an eviction, and in particular, when a parent is copied to its sibling,
many real elements are no longer valid and become noisy. The main
goal of this section is to upper bound the number of noisy blocks
in all buckets with high probability. Our quantiﬁcation has then to
take into account both sources, however, one can show that the ﬁrst
source of noisy blocks can be included as a worst case of the second
source. Recall that a bucket cannot hold more than z real elements
which means that we can have up to z real elements turning to
noise –if we access the same bucket z times before eviction–. One
can only add z additional blocks to each bucket to handle reads, so
whatever computed bound on φ, one can increase it by one. How-
ever, one can show that it is not necessary. In fact, this situation is
equivalent to having all z real elements in a given bucket as noise
for its sibling (which is the worst case). Thus, one can consider the
ﬁrst source of noisy blocks as a sub-case of the second one. We are
now ready to state our main theorem.

THEOREM 4.1. If φ ∈ Θ(1), the probability that Zi+1,j ≥
Ri,j and Zi,j ≥ Ri+1,j is in O(z−z), for all i ∈ [L] and j ∈ N.
PROOF. Based on our assumption, we know that a path cannot
handle more than z real elements with high probability. This im-
plies that ∀i ∈ {0, . . . , L}, we have Ri+1 + Ri ≤ z.

Here, for sake of clarity and without loss of any generality, we
omit the eviction step j from notation just to minimize the burden
of additional indexes. To show that ∀i ∈ [L], Zi+1 ≥ Ri and
Zi ≥ Ri+1, it is equivalent to show that ˜Ni ≤ φ · z:

Ri+1 + Ri ≤ z

Ri+1 + Ri + ˜Ni + Zi ≤ z + ˜Ni + Zi
Ri+1 + µ · z ≤ z + ˜Ni + Zi

Ri+1 ≤ ( ˜Ni − φ · z) + Zi

Therefore, it is sufﬁcient to show that ˜Ni − φ · z ≤ 0 in order
to proof that ∀i ∈ [L], Zi+1 ≥ Ri and Zi ≥ Ri+1. It is clear that
these inequalities hold for any eviction step j ∈ [N ].
that ˜Ni,j > φ · z is negligible with very high probability.

Consequently, the proof boils down to show that the probability

Based on the bucket composition history, notice that the noisy
elements in the bucket Bi,j are exactly those that exist already in
the bucket Bi−1,j−2i−2, plus, all the real elements that will be
evicted to the other child and therefore they are considered noisy
elements for the bucket Bi,j. Thus, we have Pr( ˜Ni,j > φ · z) =
Pr( ˜Ni−1,j−2i−2 + R(cid:48)

i−1,j > φ · z).

We have shown in the bucket composition history that Bi,j is

868created by summing all the buckets {B0,j, B1,j−20 , B2,j−21 , . . . ,
Bi−1,j−2i−2}. The above equation can be then formulated more
accurately such that Pr( ˜Ni,j > φ · z) = Pr(maxi( ˜N1,j−20 , . . . ,
˜Ni−1,j−2i−2 ) + R(cid:48)

i−1,j > φ · z).

The equation can be understood as follows: the noise in bucket
Bi,j is the maximal amount of noise in any bucket in its history.
Each bucket is created independently of the other ones in the evicted
path. Therefore the quantity of noise in every bucket in the evicted
path is independent of the other ones. We give more details below
about the independence assumption. Since the noise is cumulative
during the eviction, the bucket that has the maximum noise will
represent the noise of the last bucket. Recall that based on Algo-
rithm 4, the noisy blocks are added up. Also, to this quantity of
noise, we add the sum of all real elements in the path that are no
longer considered real elements in Bi,j and therefore represent a
new noise denoted by R(cid:48)

i−1,j.

All buckets in an evicted path are independent of each others,
i.e., the number of real elements, the number of noisy elements are
independent of the the other buckets in the path. This holds since
the real elements, the noise in any bucket is generated from dis-
tinct evictions. First, note that a bucket is created by merging all
its ancestors. We have deﬁned in the previous section the notion
of bucket composition history that keeps track of each bucket’s an-
cestor that contributed to its creation. As have been shown, the
bucket ancestors emanate from different evictions’ steps which is
a consequence of the reverse deterministic lexicographic eviction.
More importantly, each bucket in the evicted path has a differ-
ent bucket composition history such that the intersection of all of
them is empty. Formally, an evicted path, based on the path com-
position history, of the jth step equals {B1,j−20 , B2,j−21 , . . . ,
BL−1,j−2L−2}.
Consider a bucket and its parent in the evicted path for i ∈ {1,
. . . , L − 1}, Bi,j−2i−1 and Bi+1,j−2i. The bucket composition is
{B0,j−2i−1 , B1,j−2i−1−20 , B2,j−2i−1−21 , . . . , Bi−1,j−2i−1−2i−2}
and {B0,j−2i , B1,j−2i−20 , B2,j−2i−21 , . . . , Bi,j−2i−2i−1}.

By replacing each bucket in the above sequence by its own bucket
composition history and by iterating the process, we will converge
to a state where each bucket is composed of root buckets that were
instantiated at different evictions’ steps. That is, no distinct buckets
in the evicted path have a root in common. Thus, the number of real
and noisy elements are independent from each other. Therefore,
Pr( ˜Ni,j > φ · z) = 1 − Pr(max

( ˜N1,j−20 , . . . , ˜Ni−1,j−2i−2 )

i

i−1,j ≤ φ · z)
(cid:48)

+R

= 1 − i−1(cid:89)

k=1

Pr( ˜Nk,j−2k−1 + R

i−1,j ≤ φ · z)
(cid:48)

We can reiterate the process of counting the noise until arriving

to the root. The quantity of noise in the root is null. Then

Pr( ˜Ni,j > φ · z) = 1 − i−1(cid:89)
= 1 − i−1(cid:89)

R

k=1

k−1(cid:89)
k−1(cid:89)

l=1

··· s−1(cid:89)
··· s−1(cid:89)

(cid:48)
1,s + . . . + R

t=1
i−1,j ≤ φ · z)
(cid:48)

Pr(R

(cid:48)
0,t + R

(cid:48)
1,s +

l=1

··· + R

k=1
i−1,j ≤ φ · z)
(cid:48)

t=1

Recall that R(cid:48)

i−1,j represents the number of real elements in the
bucket Bi−1,j that will be considered as noise in the bucket Bi,j.

Pr( ˜N0,t + R

(cid:48)
0,t +

≥ 1 − (i − φ) · z · (

Pr(R ≤ φ · z) ≥

≥

≥

Inequalities (2) and (3) are bounds that are reached ﬁrst by replac-
ing k = φ · z since it will result on the larger value (k is in the
denominator) and by summing over the ﬁnal probability by i · z.
Combining all results together, we have

Any bucket cannot have more than z elements with hight probabil-
ity, denoting R = R(cid:48)

1,s + . . . + R(cid:48)

i−1,j, we then have

0,t + R(cid:48)

Pr(R ≤ φ · z) =

=

1 − Pr(i · z ≥ R ≥ φ · z)

1 − i·z(cid:88)

k=φ·z

Pr(R = k)

(1)

Now, we have to compute an upper bound of Pr(R = k). One
can proceed by: (1) counting all possible solutions of R = k, then
(2) multiply this value by the probability of the most likely solution.
All the possible combinations of the equation x1 + . . . + xk =

(cid:1) possibilities. The non-trivial part is to ﬁnd an

0,t = x1 AND . . . AND R(cid:48)

upper bound of the most likely solution that, in its general form,
equals Pr(R(cid:48)
i−1,j = xi−1). We have
that R(cid:48)
i−1,t =
(2i)xi . Using the independence between buckets,

i−1,xi follows a binomial distribution such that Pr(R(cid:48)

N

1

see above for the independence argument, we obtain:

N equal(cid:0)k+N−1
(cid:1) ·
xi) ≤ (cid:0)2i−1
i−1(cid:94)

xi

Pr(R(cid:48)

Pr(

Pr(R(cid:48)

(cid:17) ·

1

(2j )xj

j = xj )) =

j=0

i−1(cid:89)
≤ i−1(cid:89)

j=0

e
2xj

(
j=0

(cid:16)2j−1
j = xj ) ≤ i−1(cid:89)
i−1(cid:89)

j=0

xj

)xj = (

)k

)xj

1
xj

(
j=0

e
2

We want to ﬁnd a readable upper bound only in function of k.
Also, remark that the above inequality is true iff, ∀j ∈ {1, . . . ,
i − 1}, the following statement holds xj ≤ 2j−1. One can ver-
ify with induction that with xj’s reaching their upper bounds 2j−1
and therefore maximizes the inverse of the
function. Also, there exists by construction a nonnegative inte-
i=1 2i, which implies that
γ − 1 ≤ log k ≤ γ + 1. Putting everything together we obtain:

minimizes(cid:81)i−1
ger γ such that (cid:80)γ−1

i=1 2i ≤ k ≤ (cid:80)γ

j=1 xxj

j

i−1(cid:94)

j=0

Pr(

i−1(cid:89)

(
j=0

1
xj

)xj

Pr(R(cid:48)

j = xj ) = (

≤ (

= (

≤ (

e
2

e
2
e
2

e
2

)k

)k ·

)k ·

)k ·

Now, we plug the above results in (1)

1

22 · (22)22 · · · (2γ−1)2γ−1
(cid:80)γ−1

)k ·

= (

1

1

21+(γ−2)2γ

j=1 j2j

2

1

21+(log k−3)k

e
2
≤ (

4e
k

)k

1 − i·z(cid:88)
1 − i·z(cid:88)

k=φ·z

(

k=φ·z

(cid:16)k + i − 1
(cid:17)

(

k

4e
k
4e2 · (k + i − 1)

k2

8e2 · (φ · z + i − 1)

)k

)k

)φ·z

2(φ · z)2
1 − i · z · (

8e2
φ · z

)φ·z

(2)

(3)

869Pr( ˜Nj,k > φ · z) ≤ 1 − i−1(cid:89)

k−1(cid:89)

· · · s−1(cid:89)

(1 − Pr(j · z ≥ R ≥ φ · z))

k=1

l=1

t=1

≤ 1 − (1 − Pr(j · z ≥ R ≥ φ · z))O( ii
i! )
≤ 1 − (1 − i · z · (

)φ·z)O( ii
i! )

8e2
φ · z

= O(

ii
i!

iz(

e2
φ · z

)φ·z) = O(eiiz(

e2
φ · z

)φ·z)

The last transitions are obtained by the binomial inequality and Stir-
ling approximation. Now, we deﬁne the value of φ for which this
probability is negligible. The probability above can be simpliﬁed
to Pr( ˜Ni,j > φ · z) = O(ei+ln(i·z)+2φ·z−ln(φ·z)·φ·z).
This probability computation is independent of the step of evic-
tion j ∈ N. Therefore, choosing φ ∈ Θ(1) (and assuming that L ∈
O(z ln z)), the probability equals: Pr( ˜Ni,j > φ·z) ∈ O(e−z ln z),
which is negligible in z.

COROLLARY 4.1. If bucket size z ∈ ω(log N ), L ∈ Θ(log N ),
and φ ∈ Θ(1), the probability that Zi+1,j ≥ Ri,j and Zi,j ≥
Ri+1,j is in O(N− log log N ), for all i ∈ [L] and j ∈ N.
The Corollary can be derived from the main theorem by taking z ∈
ω(log N ).
4.2 Security Analysis
4.2.1 Oblivious merging
We prove that permutations generated by Algorithm 4 are indis-
tinguishable from random permutations. Informally, we show that
the adversary cannot gain any knowledge about the load of a par-
ticular bucket. Applying a permutation from Algorithm 4 is equal
to applying any randomly chosen permutation. We formalize our
intuition in the security deﬁnition below.
First, we introduce our adversarial permutation indistinguisha-
bility experiment that we denote PermG. Let M denote a proba-
bilistic algorithm that generates permutations based on the conﬁgu-
rations of two buckets, and A a PPT adversary. Let k be the bucket
size and s the security parameter. By Perm we denote the set of
all possible permutations of size k. Let E1 = (Gen, Enc, Dec)
and E2 = (Gena, Enca, Deca) respectively denote an IND$-CPA
encryption and an IND-CPA additively homomorphic encryption
schemes. PermGA
M,E1,E2 (s) refers to the instantiation of the ex-
periments by algorithm M, E1, E2 and adversary A.

The experiment PermGA
M,E1,E2 (s) consists of:
• Generate two keys k1 and k2 such that k1

$←− Gena(1s) and
$←− Gen(1s) and send n buckets additively homomor-
k2
phic encrypted with Enca(k1, .) associated to their headers
encrypted with Enc(k2, .) to the adversary A

• The adversary A picks two buckets A and B, then sends the

encrypted headers header(A) and header(B)

• A random bit b

$←− {0, 1} is chosen.

M(header(A), header(B)), otherwise π0
πb to A

If b = 1, π1

$←−
$←− Perm. Send

• A has access to the oracle OM that issues permutation for
any couple of headers different from those in the challenge

• A outputs a bit b(cid:48)

• The output of the experiment is 1, if b(cid:48) = b, and 0 otherwise.

M,E1,E2 (s, b(cid:48)) = 1, we say that A succeeded.

If PermGA

DEFINITION 4.1

(INDISTINGUISHABLE PERMUTATION). Al-
gorithm M generates indistinguishable permutations iff for all PPT
adversaries A and all possible conﬁgurations of buckets A and B,
there exists a negligible function negl, such that

| Pr[PermG

M,E1,E2 (s, 1) = 1] − Pr[PermG
A

M,E1,E2 (s, 0) = 1]|
A
≤ negl(s).
THEOREM 4.2. If E1 is IND$-CPA secure, E2 IND-CPA se-
cure, then Algorithm 4 generates indistinguishable permutations.

Game2) deﬁned as follows:

PROOF. We consider a sequence of games (Game0, Game1,
Game0 is exactly the experiment PermGA
Game1 is similar to Game0, except that encrypted headers are

M,E1,E2 (s, 1)

replaced with random strings

Game2 is similar to Game1, except that encrypted buckets are
replaced with buckets with new randomly generated blocks which
are additively encrypted

From the deﬁnition above, we have

Pr[Game0] = Pr[PermG

A
M,E1,E2 (s, 1) = 1].

(4)

For Game1, we can construct an efﬁcient distinguisher B1 that re-
duces E1 to IND$-CPA security such that

| Pr[Game0] − Pr[Game1]| ≤ AdvIND$¯CPA

B1,E1

(s).

(5)

Similarly for Game1, we can build an efﬁcient distinguisher B2

that reduces the security of E2 to IND-CPA security such that

| Pr[Game1] − Pr[Game2]| ≤ AdvIND¯CPA
B2,E2
We will no show that Pr[Game2] = Pr[PermGA

M,E1,E2 (s, 0) =
1]. That is, we need to show that the distribution of the output of
algorithm M has a uniform distribution over the set Perm.

(s).

(6)

For sake of clarity, we assume that the number of noisy slots is
zero in both buckets. Therefore, slots in A and B are either full or
empty. We can easily extend the proof for the case where we have
full, empty and noisy blocks.

For clarity, let X denote the discrete random variable that repre-
sents the permutation selected by the adversary and by Loadi,j the
event of load(A) = i and load(B) = j. By load(A), we denote
the number of real elements in bucket A. If b = 0, the adversary
receives a permutation π0 selected uniformly at random. It is clear
that A cannot distinguish it from another uniformly generated ran-
dom permutation. Note that in this case, for buckets with k slots,
the probability that adversary selects a permutation from Perm uni-
formly at random equals
permutations output by M are uniformly distributed.

If b = 1, the adversary receives π1. We need to show that the

k! . Thus, Pr[X = π0] = 1
k! .

1|Perm| = 1

(cid:88)
(cid:88)

i,j∈[n]

i,j∈[n]

Pr(X = π1) =

=

Pr(X = π1 and Loadi,j)

Pr(X = π1 | Loadi,j) · Pr(Loadi,j)

We compute the probability of selecting a permutation while the
loads of buckets A and B are ﬁxed to i and j. The number of possi-

ble conﬁgurations of valid permutations equals Valid =(cid:0)k

(cid:1).
(cid:1)·(cid:0)k−i

i

j

870This represents the number of possible permutation from which the
client can choose to generate a valid permutation. From the ad-
versary view, it should take into consideration all possible conﬁg-
urations of blocks in both buckets A and B. The total number of

permutations computes to Total =(cid:0)k

(cid:1) · j! · (k − j)!.

(cid:1) ·(cid:0)k−i

(cid:1) ·(cid:0)k

The ﬁrst two terms count the possible conﬁgurations of the loads
in both buckets while the three last terms are for valid permuta-
tions for a ﬁxed setting of load distribution in the buckets. The
cardinality of possible conﬁgurations equals the number of possi-
ble combinations from which we can select j empty blocks from
permutations of the k − i full blocks and the j empty blocks that
are respectively equal to (k − j)! and j!. That is,

(cid:1). We then multiply this last value by the possible

k − i, i.e.,(cid:0)k−i

j

j

j

i

Valid
Total

(cid:1) ·(cid:0)k

Pr(X = π1 | Loadi,j) =

(cid:0)k
(cid:1) ·(cid:0)k−i
(cid:1)
(cid:0)k
(cid:1) · j! · (k − j)!
(cid:1) ·(cid:0)k−i
tain Pr(X = π1) =(cid:80)

=

j

j

j

i

i

=

1

j!·(k−j)! · j! · (k − j)!

k!

=

1
k!

We insert the result of this equation in the previous one and ob-
Thus for the adversary, permutations output by M are uniformly

k! · Pr(Loadi,j) = 1
k! .

i,j∈[n]

1

distributed, i.e.

Pr[X = π1] = Pr[X = π0] = Pr[PermGA

M,E1,E2

(s, 0) = 1]

(7)

Combining Equations 4, 5, 6, and 7, we obtain

A
M,E1,E2 (s, 1)] = Pr[Game0]

Pr[PermG
≤ Pr[Game1] + AdvIND$¯CPA
B1,E1
≤ Pr[Game2] + AdvIND¯CPA
B2,E2
≤ Pr[PermG
A
M,E1,E2 (s, 0)] + AdvIND¯CPA

(s)
(s) + AdvIND$¯CPA

B2,E2

B1,E1

(s)

(s) + AdvIND$¯CPA

B1,E1

(s).

4.2.2 Overﬂow probability of C-ORAM buckets
C-ORAM eviction is similar to Onion ORAM [6]. The distribu-
tion of real elements for both constructions is exactly the same. We
have a bucket size of µ · z where z elements are allocated for real
elements and (µ − 1)z is allocated for noisy elements to preserve
the correctness of C-ORAM construction. The overﬂow probabil-
ity denotes the fact that any bucket in C-ORAM will contain more
than z elements. We want to show that this probability is negligible
in n. For this, we borrow the results of Devadas et al. [6] and Ren
et al. [23] that have introduced the eviction factor χ. Throughout
the paper, we have been stating that χ = O(z), which is a result of
the following theorem, without explicitly stating it before to avoid
confusion.

THEOREM 4.3. For the eviction factor χ and height L such that
z ≥ χ and N ≤ χ · 2L−1, the overﬂow probability after every
eviction equals e

−(2z−χ)2

6χ

.

Choosing z ∈ Θ(λ), L ∈ Θ(log N ), χ ∈ Θ(λ) and λ ∈

ω(log N ) makes the the result of Th 4.3 negligible in N.

5. EVALUATION

We have shown analytically that it sufﬁces to set µ = Θ(1) and
have buckets of size Θ(z) = Θ(λ). However, we have not derived
precisely what bucket size is necessary for concrete security pa-
rameters. In order to get an idea of how bucket size in our scheme

scales with λ, we performed a series of experiments simulating our
ORAM and measuring the maximum number of used slots (real
data blocks plus junk blocks) after x number of operations, for var-
ious values of x. We performed 20 sets of runs for each value of the
security parameter where we executed 2λ operations to test security
parameter λ. For each of these runs, we measured the largest bucket
load in the tree and then averaged this value across all runs to deter-
mine a bucket size which matches the selected security parameter.
Figure 4b shows the results of this test, compared with equivalent
tests run using the original Onion ORAM algorithm. Our results
show that, because of the lower value of A in C-ORAM, our bucket
size is actually slightly smaller than Onion ORAM.

Additionally, we compare the efﬁciency of our scheme in terms
of server computation to that of Onion ORAM. We aim to quantify
the number of homomorphic addition and multiplication operations
in each scheme, to show that we have signiﬁcant improvement.
Throughout this analysis, we will consider a single multiplication
or addition to be over an entire block, although in practice it may
be divided into chunks of smaller ciphertext. Any changes in chunk
size will apply equally to both schemes so discussion of its impact
will be ignored. Note however that we do not have layered encryp-
tions and so, in fact, ciphertext operations in our scheme will be
cheaper simply because they are smaller.

During eviction Onion ORAM performs z select operations on
each bucket, which each require a PIR query over z slots. This re-
sults in a total of z2 multiplications for each bucket, over L buckets.
Amortized over z gives O(z · L) multiplications. Each multiplica-
tion also implies an addition in the select procedure, so the number
of ciphertext additions is the same.

C-ORAM contains one major modiﬁcation that is pertinent when
comparing ciphertext operations: PIR queries are only done on the
root bucket, to add new blocks, and on leaf buckets to read and re-
move blocks. C-ORAM then requires only O(z· µ) multiplications
and z · µ · L additions. Since we have shown that µ is a small con-
stant, we effective gain a factor of O(L) in multiplications. Cru-
cially, this means the number of multiplications for C-ORAM is
independent of log N, as can be seen in Figure 5a.

Figure 5b shows the results of tests we have run to determine the
computational speedup of C-ORAM compared to Onion ORAM.
We considered Pailler encryption as the homomorphic cipher for
our tests, using a 2048-bit semiprime, which results in ciphertexts
of size 4096 bits. Tests were done on a 2013 Macbook Pro with
a 2.5 GHz Intel Core i7 processor, which we found could perform
62 ciphertext multiplications per second. We then calculated how
much time it would take to perform the necessary ciphertext oper-
ations for one ORAM access, setting B = 100kb and varying N
from 216 to 223. Figure 5b also shows the computation necessary
for the online (read) portion of the access.

Although C-ORAM improves signiﬁcantly over Onion ORAM,
computation is the main bottleneck in both schemes. C-ORAM re-
quires less than one MB of communication for one of the queries
we tested. Using modern Internet connections, communication
would take only a matter of seconds compared to a minute for the
ciphertext computations. C-ORAM takes about 7 minutes for this
query, while Onion ORAM takes over an hour and a half.

We stress that these evaluation results are largely to show the
relative improvement of C-ORAM over Onion ORAM. We chose
Paillier, because it is an established additively homomorphic en-
cryption scheme, with well-understood levels of security. There are
new homomorphic encryption schemes which perform much better
than Paillier [2, 4, 16]. But stable, optimized implementations of
them do not yet exist, and concrete parameters choices are still up
for debate. Preliminary tests indicate that use of, for instance, the

871(a) Minimum efﬁcient block size for C-ORAM and Onion ORAM

(b) Required bucket size in relation to security parameter

Figure 4: Comparison of C-ORAM and Onion ORAM

(a) Required ciphertext operations for one access

(b) Comparison of computation time for one access

Figure 5: Comparison of C-ORAM and Onion ORAM

modern NTRU encryption scheme of López-Alt et al. [16] could
allow for accesses with as little as 5 to 10 seconds of computation.
However, a signiﬁcant drawback that must be balanced for NTRU
is that the ciphertexts are much larger, resulting in a tradeoff be-
tween increased computational efﬁciency and higher communica-
tion for the PIR portions of C-ORAM. We leave full exploration of
optimized homomorphic encryption schemes to future work.

Finally, we compare the optimal block size for C-ORAM in re-
lation to Onion ORAM, cf. Figure 4a. For each eviction, Onion
ORAM requires λ2L ciphertexts of size γ to be sent by the client,
while we require only permutation vectors of total size µλL log λ.
Since γ = O(λ3), this is a huge savings. For reads, Onion ORAM
requires λLγ bits of ciphertext while we require only 4µλγ.
Comparison results: C-ORAM is able to achieve constant com-
munication overhead in the worst-case, with signiﬁcantly less server
computation required in addition to smaller minimum block sizes.
Figure 5a shows that we lower both the required number of cipher-
text additions and multiplications by several orders of magnitude
when compared to Onion ORAM, and Figure 5b shows that in
practice this leads to a substantial improvement in efﬁciency. Fig-
ure 4b shows that, due to our lower value of A, the bucket size
for C-ORAM is actually smaller in practice than Onion ORAM as
well. Additionally, Figure 4a shows that C-ORAM requires much
smaller blocks than Onion ORAM in practice.

6. RELATED WORK

ORAM was ﬁrst introduced by Goldreich and Ostrovsky [9] and
has recently received an increasing interest with the introduction of
tree-based ORAM construction [3, 5, 7–12, 14, 17–19, 21–23, 25,

27–29]. ORAMs can be categorized based on the client memory
setting, namely, constant client memory or sublinear client mem-
ory. This categorization can be reﬁned by taking into account the
server computation nature, namely, storage-only server, versus, com-
putational servers.
In the following, we will brieﬂy recapitulate
some notable research works done in this area while arranging them
in their corresponding categories.
Constant client memory: This category of ORAMs is very useful
in the case of very restrained client memory devices such us smart-
phones, embedded devices. With constant client memory, the aim
of this research is to reduce the worst-case or amortized case com-
munication complexity between the client and server [6, 10, 11,
14, 17, 21, 22, 25]. Polylogarithmic amortized-case cost was intro-
duced by Goodrich and Mitzenmacher [10] and Pinkas and Rein-
√
man [22] in O(log2 N ) but with linear worst case communication
N · log2 N ) with
complexity. This last has been improved to O(
the work of Goodrich et al. [11]. The ﬁrst scheme to provide a poly-
logarithmic worst-case was presented by Shi et al. [25]. The idea
behind this scheme is a tree-based construction where nodes con-
sist of small bucket ORAMs, see [9, 20] while memory shufﬂing is
performed after every access. This scheme offers a communication
complexity in O(log3 N ) in term of number of blocks downloaded.
Asymptotics for constant-client memory has been enhanced by the
work of Kushilevitz et al. [14] with a communication complexity
equal to O( log2 N
log log N ). However, this construction suffers from a
large hidden constant ∼ 30 that make it less efﬁcient compared to
Shi et al. [25] for example.

While all the previous schemes are based on storage-only servers,
Mayberry et al. [17] have introduced a new paradigm that takes

 1 10 100 1000 10000 1000001617181920212223Optimal block size (KB)log NCORAMOnion ORAM 0 50 100 150 200 15 20 25 30 35 40 45 50 55 60Minimum bucket sizeSecurity parameterCORAMOnion ORAM 0 2000 4000 6000 8000 100001617181920212223Number of operationslog NCORAM MultsCORAM AddsOnion Adds/Mults 0 20 40 60 80 100 120 1401617181920212223Time (minutes)log NCORAM ReadCORAM TotalOnion ReadOnion Total872advantage of a computational server setting. In fact, their idea is
based on coupling PIR [13] with Shi et al. [25]’s ORAM. A PIR
vector is used to retrieve the searched for block from the desired
bucket that greatly reduces the amount of bits needed for one ac-
cess. The authors show therewith that the communication complex-
ity can be reduced to O(log2 N ). Devadas et al. [6] enhanced this
idea by proposing the ﬁrst amortized constant client bandwidth in
a computational server. The idea is also based on merging PIR
and ORAM, however, the client still needs to download a large
block size B = Ω(log6 N ) which is not very practical for real-
istic dataset.
√
Sub-linear client memory: Williams and Sion [28], Williams et al.
N ) but
[29] works introduce a sublinear client side memory in O(
with a linear worst-case cost complexity. Stefanov et al. [26] im-
proved this result by introducing a polylogarithmic communication
complexity in O(log2 N ) but with O(
Gentry et al. [7] improve the ORAM by Shi et al. [25] by replac-
ing the binary tree by a κ−array tree. They introduce a new de-
terministic eviction process adapted to this new structure based on
reverse lexicographic ordering of leaves. This eviction method is
the basis of many recent tree-based ORAMs such as Ren et al. [23]
or Devadas et al. [6]. With a branching factor equal to κ = log N,
the communication complexity of Gentry et al. [7]’s ORAM is in
log3 N
log log N . The polylogarithmic client memory is in O(log2 N ) be-
cause the client has to keep track of all elements in path during
the eviction. Stefanov et al. [27] present Path ORAM, one of the
most efﬁcient construction with only O(log N ) client memory. The
bandwidth is in O(log2 N ) if the block size is in Ω(log N ) or in
O(log N ) for Ω(log2 N ) block sizes. Ren et al. [23] further re-
duced the communication cost by 2 to 4 times.
Acknowledgements: We thank shepherds Chris Fletcher, Ling Ren, and Elaine Shi
for valuable discussions improving the paper. This work was partially supported by
NSF grant 1218197.

√
N ) client memory.

References
[1] D. Apon, J. Katz, E. Shi, and A. Thiruvengadam. Veriﬁable Oblivious
Storage. In Proceedings of Public-Key Cryptography, pages 131–148,
Buenos Aires, Argentina, 2014.

[2] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (leveled)
fully homomorphic encryption without bootstrapping. In Proceedings
of the 3rd Innovations in Theoretical Computer Science Conference,
pages 309–325. ACM, 2012.

[3] K.-M. Chung and R. Pass. A Simple ORAM. IACR Cryptology ePrint

Archive, 2013:243, 2013.

[4] Jean-Sébastien Coron, Tancrède Lepoint, and Mehdi Tibouchi.

Scale-invariant fully homomorphic encryption over the integers. In
Public-Key Cryptography–PKC 2014, pages 311–328. Springer, 2014.

[5] I. Damgård, S. Meldgaard, and J.B. Nielsen. Perfectly Secure

Oblivious RAM without Random Oracles. In Proceedings of Theory
of Cryptography Conference –TCC, pages 144–163, Providence, USA,
March 2011.

[6] Srinivas Devadas, Marten van Dijk, Christopher W. Fletcher, Ling

Ren, Elaine Shi, and Daniel Wichs. Onion ORAM: A Constant
Bandwidth Blowup Oblivious RAM. IACR Cryptology ePrint Archive,
2015:5, 2015.

[7] C. Gentry, K.A. Goldman, S. Halevi, C.S. Jutla, M. Raykova, and

Daniel Wichs. Optimizing ORAM and Using It Efﬁciently for Secure
Computation. In Proceedings of Privacy Enhancing Technologies,
pages 1–18, 2013.

[8] O. Goldreich. Towards a Theory of Software Protection and

Simulation by Oblivious RAMs. In Proceedings of the 19th Annual
ACM Symposium on Theory of Computing –STOC, pages 182–194,
New York, USA, 1987.

[9] O. Goldreich and R. Ostrovsky. Software protection and simulation on
oblivious rams. J. ACM, 43(3):431–473, May 1996. ISSN 0004-5411.

doi: 10.1145/233551.233553. URL
http://doi.acm.org/10.1145/233551.233553.

[10] M.T. Goodrich and M. Mitzenmacher. Privacy-preserving access of

outsourced data via oblivious ram simulation. In Proceedings of
Automata, Languages and Programming –ICALP, pages 576–587,
Zurick, Switzerland, 2011.

[11] M.T. Goodrich, M. Mitzenmacher, Olga Ohrimenko, and Roberto

Tamassia. Oblivious ram simulation with efﬁcient worst-case access
overhead. In Proceedings of the 3rd ACM Cloud Computing Security
Workshop –CCSW, pages 95–100, Chicago, USA, 2011.

[12] M.T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and R. Tamassia.

Privacy-preserving group data access via stateless oblivious RAM
simulation. In Proceedings of the Symposium on Discrete Algorithms
–SODA, pages 157–167, Kyoto, Japan, 2012.

[13] E. Kushilevitz and R. Ostrovsky. Replication is not Needed: Single

Database, Computationally-Private Information Retrieval. In
Proceedings of Foundations of Computer Science, pages 364–373,
Miami Beach, USA, 1997.

[14] E. Kushilevitz, S. Lu, and R. Ostrovsky. On the (in)security of

hash-based oblivious ram and a new balancing scheme. In
Proceedings of the Symposium on Discrete Algorithms –SODA, pages
143–156, Kyoto, Japan, 2012.

[15] H. Lipmaa. An Oblivious Transfer Protocol with Log-Squared

Communication. In Proceedings of Information Security Conference,
pages 314–328, Singapore, 2005.

[16] A. López-Alt, E. Tromer, and V. Vaikuntanathan. On-the-ﬂy

multiparty computation on the cloud via multikey fully homomorphic
encryption. In Proceedings of Symposium on Theory of Computing,
pages 1219–1234, 2012.

[17] T. Mayberry, E.-O. Blass, and A.H. Chan. Efﬁcient Private File
Retrieval by Combining ORAM and PIR. In Proceedings of the
Network and Distributed System Security Symposium, San Diego,
USA, 2014.

[18] T. Moataz, E.-O. Blass, and G. Noubir. Recursive Trees for Practical

ORAM. In Proceedings of Privacy Enhancing Technologies
Symposium, pages 115–134, Philadelphia, USA, 2015.

[19] T. Moataz, T. Mayberry, E.-O. Blass, and A.H. Chan. Resizable

Tree-Based Oblivious RAM. In Proceedings of Financial
Cryptography and Data Security, pages 147–167, San Juan, Puerto
Rico, 2015. ISBN 978-3-662-47853-0.

[20] R. Ostrovsky. Efﬁcient computation on oblivious rams. In

Proceedings of the Symposium on Theory of Computing –STOC, pages
514–523, Baltimore, USA, 1990.

[21] R. Ostrovsky and V. Shoup. Private information storage (extended

abstract). In Proceedings of the Symposium on Theory of Computing
–STOC, pages 294–303, El Paso, USA, 1997.

[22] B. Pinkas and T. Reinman. Oblivious ram revisited. In Advances in
Cryptology – CRYPTO, pages 502–519, Santa Barbara, USA, 2010.

[23] L. Ren, C.W. Fletcher, A. Kwon, E. Stefanov, E. Shi, M. van Dijk, and

S. Devadas. Constants Count: Practical Improvements to Oblivious
RAM , 2014. IACR Cryptology ePrint Archive 997.

[24] RightScale. State of the cloud report, 2015. URL

http://assets.rightscale.com/uploads/pdfs/
RightScale-2015-State-of-the-Cloud-Report.pdf.

[25] E. Shi, T.-H.H. Chan, E. Stefanov, and M. Li. Oblivious RAM with

O(log3(N )) Worst-Case Cost. In Proceedings of Advances in
Cryptology – ASIACRYPT, pages 197–214, Seoul, South Korea, 2011.
ISBN 978-3-642-25384-3.

[26] E. Stefanov, E. Shi, and D.X. Song. Towards practical oblivious ram.

In Proceedings of the Network and Distributed System Security
Symposium, San Diego, USA, 2012. The Internet Society.

[27] E. Stefanov, M. van Dijk, E. Shi, C.W. Fletcher, L. Ren, X. Yu, and

S. Devadas. Path ORAM: an extremely simple oblivious RAM
protocol. In Proceedings of Conference on Computer and
Communications Security, pages 299–310, Berlin, Germany, 2013.
ISBN 978-1-4503-2477-9.

[28] P. Williams and R. Sion. Usable pir. In Proceedings of the Network
and Distributed System Security Symposium, San Diego, USA, 2008.
[29] P. Williams, R. Sion, and B. Carbunar. Building castles out of mud:
practical access pattern privacy and correctness on untrusted storage.
In ACM Conference on Computer and Communications Security,
pages 139–148, Alexandra, USA, 2008.

[30] Peter Williams, Radu Sion, and Alin Tomescu. PrivateFS: A parallel
oblivious ﬁle system. In Proceedings of the 2012 ACM conference on
Computer and communications security, pages 977–988. ACM, 2012.

873