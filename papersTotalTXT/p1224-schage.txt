TOPAS

2-Pass Key Exchange with Full Perfect Forward Secrecy and Optimal

Communication Complexity

Sven Schäge

Ruhr-Universität Bochum

Germany

sven.schaege@rub.de

ABSTRACT
We present TOPAS (Transmission Optimal Protocol with Active
Security), the ﬁrst key agreement protocol with optimal commu-
nication complexity that provides security against fully active ad-
versaries. This solves a longstanding open problem. The size
of the protocol messages (≈ 160 bits for 80-bit security) and the
computational costs to generate them are comparable to the basic
Difﬁe-Hellman protocol over elliptic curves (which is well-known
to only provide security against passive adversaries). Session keys
are indistinguishable from random keys – even under reﬂection and
key compromise impersonation attacks – under generalizations of
the Computational Bilinear Difﬁe-Hellman Inversion assumption.
What makes TOPAS stand out is that it also features a security
proof of full perfect forward secrecy (PFS), where the attacker can
actively modify messages sent to or from the test-session. The
proof of full PFS relies on two new extraction-based security as-
sumptions. It is well-known that existing implicitly-authenticated
2-message protocols like HMQV cannot achieve this strong form of
(full) security against active attackers (Krawczyk, Crypto’05). We
also present a variant of our protocol, TOPAS+, which, under the
Strong Difﬁe-Hellman assumption, provides better computational
efﬁciency in the key derivation phase.

1.

INTRODUCTION

Besides encryption systems and digital signatures, key exchange
protocols are among the most important building blocks of cryp-
tography. It is well-known that the famous Difﬁe-Hellman (DH)
protocol [14] only provides security against passive attackers. This
is why since its introduction in 1976, many works focused on up-
grading the DH protocol to also shield it against active attacks while
trying to keep the overall efﬁciency as close as possible to the orig-
inal protocol. An important step in that direction are authenticated
DH-based protocols like MQV [21] and its successor HMQV [20].
As in the basic unauthenticated DH protocol, each message con-
sists of only a single group element and messages can be sent in
any order. An important feature of these DH-based protocols is
that no long-term secret is required when computing the protocol

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813683.

messages; it is only when the session key is derived that the long-
term secrets come into play. This generally makes the computa-
tion of protocol messages very efﬁcient. The class of protocols
that compute messages in this way (without the use of the long-
term secrets) are called “implicitly-authenticated” protocols [20].
Unfortunately, in 2005 Krawczyk presented an attack that shows
that implicitly-authenticated protocols inherently cannot provide
forward secrecy against active attackers [20] (see Appendix D for
a summary). Only if the attacker remains passive with respect to
the test-session, implicitly-authenticated protocols can provide per-
fect forward secrecy. This passive form of PFS is commonly called
weak PFS. We stress that weak forward secrecy is not a satisfying
deﬁnition of security in practice (see Appendix B for a brief ex-
ample). Ultimately, there is no reason to assume that an otherwise
unrestricted adversary (with respect to network control) may just
refrain from using its full power. Arguably, weak forward-secrecy
has rather been deﬁned to show what protocols like HMQV can
achieve. This is why Krawczyk proposes an extension of HMQV,
termed HMQV-C, which comprises three message ﬂows (while the
second ﬂow now also consists of more than 160 bits) and adds ex-
plicit key conﬁrmation to the protocol. This guarantees full-PFS
security but decreases the protocol’s overall efﬁciency.

We stress that (full) perfect forward secrecy is an important se-
curity property for key exchange protocols and that it is naturally
well-supported by the original, unauthenticated Difﬁe-Hellman pro-
tocol. As pointed out in [18], the support of PFS is an important
advantage over public-key based session key transport and the main
reason for the prevalence of DH-like protocols in protocol suites
like SSH, IPsec, and TLS. We note that although RSA-based key
transport is still the most common TLS variant in use, Google has
recently announced that it will push the use of TLS with ephemeral
Difﬁe-Hellman key exchange exactly because of its guarantee of
perfect forward secrecy [2]. Moreover, it is clear that the next ver-
sion of TLS will not support RSA-based key establishment partly
because of its lack of forward secrecy [24]. The only two-message
protocol we are aware of that provides truly satisfactory security
guarantees against active attackers while maintaining high efﬁcien-
cy is the modiﬁed Okamoto-Tanaka (mOT) protocol by Gennaro,
Krawczyk, and Rabin (GKR) [18]. Basically, mOT is an enhanced
variant of the classical Okamoto-Tanaka protocol [22] from 1989
that introduces additional hashing operations to protect it against
several practical attacks and allows a rigorous proof of security.1
Like the original Okamoto-Tanaka protocol, mOT is deﬁned in
groups of hidden order and its security relies on the RSA assump-

1In contrast to the original Okamoto-Tanaka protocol, all identities
are hashed before usage and the session key is hashed in the ﬁnal
step.

1224Alice (A)

skA = (H(idA))1/z

x $← Zp
b ∈ G1?

Bob (B)

skB = (H(idB))1/z

y $← Zp
a ∈ G1?

a = gx
b = gy

1 skA
1skB

kA = (e (b, gz
k(cid:48)
A = (e(b, hz
KA = H(cid:48)(kA, k(cid:48)

2) /e(H(idB), g2))x
2)/e(H(idB), h2))x
A, idA, idB, a, b)

kB = (e (a, gz
k(cid:48)
B = (e(a, hz
KB = H(cid:48)(kB, k(cid:48)

2) /e(H(idA), g2))y
2)/e(H(idA), h2))y
B, idA, idB, a, b)

2 , hz

Figure 1: Overview of TOPAS. The key generation center main-
tains public parameters mpk containing g1, g2, h2, gz
2, prime p,
a description of the pairing e, and descriptions of two hash func-
tions H : {0, 1}∗ → G1 and H(cid:48) : {0, 1}∗ → {0, 1}∗. These pa-
rameters are available to all parties. The master secret msk consists
of z and is used by the key generation center to derive the user se-
cret keys as ski = (H(idi))1/z. KA (resp. KB) is the session key
computed by Alice (Bob). The pairing operations in the denomina-
tor are message-independent and can be pre-computed (in times of
low workload) and stored for later use. If Alice also pre-computes
2)x and e(H(idB), g2)x, e(H(idB), h2)x
a = gx
the computation of k, k(cid:48) will require two pairing operations and two
divisions in GT per key exchange. Messages can be sent in any or-
der. Without loss of generality we assume that lexically idA ≤ idB.

1 skA, (gz

2 )x, (hz

tion. Unfortunately, group elements consists of at least 1024 bits so
that the overall number of transmitted bits for the two messages is
2048 bits which is much more than what is possible with the basic
DH protocol and protocols like HMQV when deﬁned over prime
order elliptic curves. However, the protocol has very good com-
putational efﬁciency. It is a longstanding open problem to design
a protocol with full security (including full PFS) against active at-
tackers and optimal communication complexity, i.e. where each
message only consists of about 160 bits.2 This is of course optimal,
since the birthday bound requires messages to be at least 160 bits
for 80 bit security.
Contribution
As our main result we present TOPAS (short for Transmission Op-
timal Protocol with Active Security), the ﬁrst two-message key ex-
change protocol that provides full perfect forward secrecy and op-
timal communication complexity (Figure 1). To achieve this, the
design of TOPAS relies on new ideas and techniques that are dif-
ferent from all existing two message protocols that we are aware
of. Key indistinguishability, security against key-compromise im-
personation (KCI) attacks and reﬂection attacks are proven under
generalizations of the Computational Bilinear Difﬁe-Hellman In-
version assumption. At the same time, TOPAS is weakly PFS
secure under the Computational Bilinear Difﬁe-Hellman assump-
tion. In Appendix C, we show that all our assumptions are con-
crete instantiations of the Uber-assumption introduced by Boyen in
2008 and therefore inherit its security in the generic bilinear group
model [8]. We stress that for none of our assumptions does the
2Of course, it is necessary that the protocol consists of at least two
messages to provide security against active attacks.
In any one-
message protocol the receiver’s computation of the session key can
only depend on its knowledge of the secret key (as it cannot feed
any session-speciﬁc random nonce or ephemeral secrets into the
key derivation process). Therefore corrupting the receiver will al-
ways reveal the session key (even after the session completes) and
PFS is not achievable.

input size grow with the number of adversarial queries (i.e.
they
do not constitute so-called q-type assumptions). Full-PFS secu-
rity is shown under two new knowledge-type (or extraction-type)
assumptions that are related to the difﬁculty of inverting bilinear
pairings. (Traditional knowledge-type assumptions are usually re-
lated to the difﬁculty of inverting the modular exponentiation func-
tion, i.e. computing discrete logarithms.) Our protocol is deﬁned
over asymmetric (Type-3) bilinear groups and all our proofs rely
on random oracles. Remarkably, for 80 bit security, each message
consists of only about 160 bits, resulting in the ﬁrst key exchange
protocol achieving full-PFS with an overall communication com-
plexity of only 320 bits. Moreover, our protocol is identity-based
what allows two parties to securely agree on a common session
key without a prior exchange of their certiﬁcates. With respect to
computational efﬁciency, we note that all protocol messages can
be computed very efﬁciently, virtually as efﬁcient as in the orig-
inal DH key exchange. In particular, each message consists of a
single ephemeral DH public key that is additionally multiplied by
the user’s secret long-term key. No additional exponentiation is
required. Thus the computational overhead when compared to pro-
tocols like HMQV is minimal. However, session key derivation in
our scheme is comparably slow. This is due to the application of
a bilinear pairing in the key derivation process. We note that half
of the required pairing operations must only be performed once per
communication partner as they only depend on the identity of the
communication partner. Finally, we remark that the size of the se-
cret keys derived by the key generation center (KGC) is also only
160 bits and thus optimal as well.

We also present, TOPAS+ (Figure 2), a slightly modiﬁed ver-
sion of TOPAS where the security proofs additionally rely on a
variant of the Strong Difﬁe-Hellman assumption [1]. Basically,
we require that our generalizations of the Computational Bilinear
Difﬁe-Hellman Inversion assumption remain valid even when the
adversary is also given access to an oracle that checks, given input
k and k, whether kz2
= k for z unknown to the adversary. The
resulting protocol requires less public parameters and only half the
number of pairings required to compute the session key. When pre-
computing message-independent values ofﬂine, key derivation only
requires a single pairing operation online. The cost for this modiﬁ-
cation is that we have to rely on interactive security assumptions
even when proving key indistinguishability and security against
KCI and reﬂection attacks.

As mentioned before, the identity-based properties of our pro-
tocols avoid that additional information like certiﬁcates have to be
exchanged between unknown communication partners, in contrast
to PKI-based protocols like for example HMQV. This guarantees
that in TOPAS and TOPAS+ the size of each messages does in-
deed never exceed 160 bits. Also the time for key derivation is
not slowed down by the additional veriﬁcation of the received cer-
tiﬁcate. We also remark that although message computation in-
volves the usage of the secret key, all our protocols provide the
strong form of deniability deﬁned in [13]. This means that Bob or
any other party cannot convince any third party that it once talked
to Alice (given that there are no additional side information avail-
able to Bob that prove this fact in another way). This is a valuable
privacy feature of our protocols that make them suitable for im-
plementing “off-the-record” communication over (insecure) digital
networks. We remark that, as with forward secrecy, the basic unau-
thenticated Difﬁe-Hellman protocol naturally supports this strong
form of deniability (simply because the session key entirely relies
only on ephemeral parameters). On the other hand, protocols based
on digital signatures (like signed Difﬁe-Hellman) do not provide
such deniability features.

1225Finally, we note that our proofs of TOPAS and TOPAS+ heav-
ily exploit the programmability of the random oracle model. Using
a separation technique that was introduced by Fischlin and Fleis-
chhacker [16] and applied to identity-based non-interactive key ex-
change by Chen, Huang, and Zhang [11] we can show that, in some
sense, the programmability of the random oracle model is actually
necessary for our reductions. More concretely, under a one-more-
type security assumption, the programmability of the random ora-
cle model is necessary for all security proofs that call the adversary
once and in a black-box manner, which is the most common type of
reduction in cryptography. Unfortunately, the results of [11] cannot
directly by applied to TOPAS and TOPAS+ such that we have to
rely on new ideas. Due to space limitations we postpone the formal
statement and proof of this result to the full version of this paper.

We admit that the feature of full PFS security comes at the cost
of relying on (highly) non-standard security assumptions. How-
ever, we stress that the existing two-message key exchange proto-
cols with 160 bit messages are implicitly-authenticated and there-
fore cannot provide full PFS under any security assumption.

Protocol

id-based
(no cert.)

message
bit-size

pairings
in key
derivat.
on./off.

HMQV [20]

no

mOT [18]

TOPAS

yes

yes

160
(+ cert.)3
1024

–

–

160

4/2

TOPAS+

yes

160

2/1

key indist.
KCI,
reﬂection
Gap DH
(interactive)
RSA
generaliz.
of CBDHI
(non-inter.)
generaliz.
of CBDHI,
SDH oracle
(interactive)

security assumptions

full PFS ephemeral
secret key
reveal

–

extract.

extract.

extract.

extract.

–

–

–

Table 1: Comparison of 2-pass key exchange protocols for 80-bit
security.

APPLICATION SCENARIOS. Our protocols are interesting for com-
munication networks where the transmission of data is very expen-
sive. Important examples are satellite-based communication net-
works and communication over low-battery powered wireless (sen-
sor) networks. Since our protocols are identity-based they ensure
that the optimal bound of 160 bits per key exchange message is
always met.

SECURITY MODEL. To prove security of our protocols we extend
and strengthen the security model of mOT [18]. Indistinguisha-
bility of session keys from random keys is shown in a variant of
the Canetti-Krawczyk (CK) model [9] that is restricted to two mes-
sage protocols. This variant was ﬁrst introduced for the analysis
of HMQV [20]. The mOT model has further adapted the HMQV
model to the identity-based setting. Our model captures security
against reﬂection attacks, key compromise attacks, and forward se-
crecy. There are two noteworthy ways in which our model differs
from [18]. The ﬁrst is that we provide an explicit Register query to
register new users. The second is that we introduce a strengthened
deﬁnition of weak PFS called enhanced weak PFS which allows
3We note that whenever the communication partners exchange cer-
tiﬁcates in HMQV to authenticate their public keys this not only
affects the message size but also the key derivation. In particular,
the time for key derivation is increased by the time for the addi-
tional certiﬁcate veriﬁcation. We stress that (long-lived) certiﬁcates
only have to be transferred and checked once per communication
partner.

the adversary to obtain the secret keys of all parties and the KGC
at protocol start-up, i.e. even before the session key is computed.
We note that like the mOT protocol, our protocols require that in-
termediate values computed in the generation of the protocol mes-
sages and the derivation of the session key cannot be revealed by
the adversary. Formally, we therefore do not consider state reveal
attacks. Technically, this is enforced by requiring that the interme-
diate values remain in the same protected memory as the long-term
key. This is for example similar to DSA signatures, where the ran-
dom exponent used in the signing procedure must not be revealed
to the adversary. Although this seems like a severe restriction, it is,
in some sense, the best we can hope for when using two-message
protocols. In Appendix E we show that any protocol which allows
the adversary to reveal ephemeral keys, cannot provide full PFS.
Related Work
It is well-known how to design 2-message protocols that are secure
against active adversaries. One way to do this is to add to each
(Difﬁe-Hellman) message a signature that authenticates the origi-
nator of that message and protects its integrity [23].4 This approach
has been generalized in [12, 4]. Another solution is to additionally
exchange two encrypted nonces that when combined give rise to a
symmetric key that is used to protect the integrity of the remaining
messages (as used in SKEME [19]). However, all these methods
require to send, besides the Difﬁe-Hellman shares, additional infor-
mation. For example, consider the most efﬁcient signature scheme
that is due to Boneh, Lynn, and Shacham (BLS) where each signa-
ture consists of roughly 160 bits. Using the signature-based method
with BLS signatures, each party has to exchange considerably more
than the optimal amount of bits, namely the key exchange messages
plus the size of the signatures (which already account for 160 bits).
This does not even consider the costs for certiﬁcates that are re-
quired when two parties communicate for the ﬁrst time. At the
same time, since these protocols use digital signatures they cannot
provide the strong form of deniability given in [13]. Moreover, we
remark that when using any two-message protocol that provides
full PFS we also must have that the corresponding security model
does not allow to reveal the ephemeral secrets as formally shown
in Appendix E. So, as the protocols in [12, 4] allow the adversary
to reveal ephemeral keys, they cannot be shown to provide full PFS
in the strong sense of [18].

Another interesting approach is to make practical 2-message pro-
tocols like MQV and HMQV identity-based, while keeping their
overall efﬁciency. Most noteworthy, Fiore and Gennaro presented
a protocol that features (computational) performance comparable
to MQV [15]. However, since it is identity-based there is no need
for transmitting certiﬁcates as in the original MQV protocol. There
are two drawbacks of their protocol. First, each messages consists
of two values, thus exceeding the optimum of 160 bits. Second,
their protocol does only provide weak PFS, not full PFS. Thus it
lacks protection against fully active adversaries. As an advantage,
their protocol offers very high computational efﬁciency.
Identity-based vs. PKI-based Protocols
Finally, we would like to comment on the fact that our protocol is
identity-based. Our main target is to obtain as short messages as
possible while providing high security guarantees. It is interesting
to note that when using protocols that provide enhanced weak PFS,
the introduction of a KGC does not increase the vulnerability to
long-term attacks as compared to relying on classical certiﬁcation

4Obviously, this solution does not preserve the strong deniability
property of the original unauthenticated Difﬁe-Hellman protocol.

1226authorities (CAs). As for authentication, any KGC can of course
impersonate its users as it can compute their secret keys. However,
this is not different from classical CAs that can always create a cer-
tiﬁcate that binds the identity of the user to a public key chosen by
the CA (such that it has access to the corresponding secret key).
Now, when it comes to the secrecy of keys of past sessions where
the adversary did not actively intervene, our notion of enhanced
weak PFS guarantees that even with the help of all user secret keys
and even that of the KGC no adversary can obtain the session key.
This is exactly what is guaranteed by weak PFS for PKI-based pro-
tocols. Indeed we can show that similar to mOT our identity-based
protocol can easily be turned into a PKI-based one. Of course we
then lose the advantage that users need to exchange certiﬁcates be-
fore communicating for the ﬁrst time. In Appendix A we brieﬂy
sketch this transformation. We leave a formal security analysis of
this protocol variant for future work.

2. PRELIMINARIES

Let κ be the security parameter. Let G1 and G2 be groups of
prime order p with generators g1 and g2 such that log2(p) be a
polynomial in κ. Let e : G1 × G2 → GT be a non-degenerate
bilinear pairing. We call G = (p, g1, g2, e) a bilinear group. We
will base our protocol on asymmetric bilinear groups of prime or-
der where no isomorphism is known between G2 and G1 (Type-3
pairings) [17]. When using asymmetric bilinear groups, we assume
that log2(p) ≈ 160 (effectively having log2(p) = 2κ) and that
elements of G1 can be implemented with roughly 160 bits for a
security level of approximately 80 bits [7, 3].
2.1 Security Assumptions

In the following, we will present the complexity assumptions
that our security analysis of our ﬁrst protocol relies on. Our main
proof will assume the hardness of a generalization of the Computa-
tional Bilinear Difﬁe-Hellman Inversion problem. In Appendix C
we will show that all our assumptions are covered by the Uber-
assumption introduced in [8] and thus hold in the generic (bilinear)
group model. For the proof of full PFS security we will rely on
two new “knowledge-type” (extraction-type) assumptions. We will
give a brief motivation for these new assumptions.

(k, l)-COMPUTATIONAL BILINEAR DIFFIE-HELLMAN INVER-
SION ((k, l)-CBDHI) ASSUMPTION. Let k = k(κ) and l = l(κ)
be polynomials. Assume G = (p, g1, g2, e) is a bilinear group.
The (k, l)-Computational Bilinear Difﬁe-Hellman Inversion prob-
2 for some
lem is, given G and gz
random z ∈ Zp to compute e(g1, g2)1/z. This is a generalization
of the Computational Bilinear Difﬁe-Hellman Inversion problem
introduced by Boneh-Boyen in [5] where k is ﬁxed to k = 2.

1 , . . . , gzk

2 , . . . , gzl

2 , gz2

1 , gz2

1 , gz

DEFINITION 1. We say that attacker A breaks the (k, l)-CBDHI
assumption if A succeeds in solving the (k, l)-Computational Bilin-
ear Difﬁe-Hellman Inversion problem (where the probability is over
the random coins of A and the random choices for G and z). We
say that the (k, l)-CBDHI assumption holds if no PPT attacker A
can break the (k, l)-CBDHI problem.

Looking ahead, in our proof of KCI security we reduce security to
the (2, 3)-CBDHI assumption while in our proof of full PFS secu-
rity we rely on the (3, 3)-CBDHI assumption.

(k, l)-GENERALIZED COMPUTATIONAL BILINEAR DIFFIE-HELL-
MAN INVERSION ((k, l)-GCBDHI) ASSUMPTION. Let again k =
k(κ) and l = l(κ) be polynomials in κ and G = (p, g1, g2, e)
be a bilinear group. The (k, l)-Generalized Computational Bilinear

Difﬁe-Hellman Inversion problem is, given G, random w ∈ Zp,
2 for some random z ∈ Zp to
1 , gz2
gz
compute e(g1, g2)

1 , and gz
z2 .

1 , . . . , gzk

2 , . . . , gzl

2 , gz2

z+w

DEFINITION 2. Adversary A breaks the (k, l)-GCBDHI assump-
tion if A succeeds in solving the (k, l)-Generalized Computational
Bilinear Difﬁe-Hellman Inversion problem (where the probability
is over the random coins of A and the random choices for G, z and
w). We say that the (k, l)-GCBDHI assumption holds if no PPT
attacker A can break the (k, l)-GCBDHI problem.

We will rely on this assumption for k = 2 and l = 3 to prove se-
curity of our protocol under reﬂection attacks where the adversary
is also allowed to make parties communicate with themselves. We
stress that since k, l are constant, the challenge size of both of our
assumptions does not grow with the security parameter (and so they
do not constitute “q-type” assumptions).

COMPUTATIONAL BILINEAR DIFFIE-HELLMAN (CBDH) AS-
SUMPTION IN G1. Assume G = (p, g1, g2, e) is a bilinear group.
The CBDH problem is, given G and gx
1 to compute e(g1, g2)xy.

1 , gy

DEFINITION 3. We say that attacker A breaks the CBDH as-
sumption if A succeeds in solving the CBDH problem (where the
probability is over the random coins of A and the random choices
for G and x, y). We say that the CBDH assumption holds if no PPT
attacker A can break the CBDH problem.

Later we will use this assumption to prove that our protocol guaran-
tees weak PFS. Observe that the CBDH assumption implies that the
classical Computational Difﬁe-Hellman assumption holds in G1.

KNOWLEDGE OF (PAIRING) PRE-IMAGE ASSUMPTION (KPA).
Recall the knowledge of exponent assumption for Difﬁe-Hellman
pairs. It states that for any adversary A which, given group G (of
prime-order p) and two generators X, Y ∈ G outputs X(cid:48), Y (cid:48) ∈ G
such that there is s ∈ Zp with X(cid:48) = X s and Y (cid:48) = Y s, there ex-
ists another adversary A(cid:48) which given the same inputs additionally
outputs the exponent s. However, when working in the target group
GT of a bilinear group this assumption can be false. For example,
assume X = e(A, g2) and Y = e(B, g2) for some A, B ∈ G1.
Then, an adversary that is given A, B ∈ G1 and g2 ∈ G2 can sim-
2 ∈ G2
ply output X(cid:48) = e(A, g(cid:48)
without knowing the discrete logarithm s between X(cid:48) and Y (cid:48).
The following assumption states that although the adversary may
not know the discrete logarithm s between X(cid:48), Y (cid:48) it must at least
know a suitable g(cid:48)
2. Observe, that if the adversary does indeed know
the discrete logarithm s it can easily compute g(cid:48)
2. In
some sense our new assumption can be viewed as a variant of the
knowledge of exponent assumption (which in its original form is
related to the problem of inverting modular exponentiations). How-
ever, it is rather a “knowledge of group element” assumption that
is related to the difﬁculty of inverting bilinear pairings.
ment played between challenger C and adversary A:

Formally, security is deﬁned via the following security experi-

2) and Y (cid:48) = e(B, g(cid:48)

2) for some g(cid:48)

2 as g(cid:48)

2 = gs

1. C sends a bilinear group G = (p, g1, g2, e) to A together

with A, B ∈ G1. Let X = e(A, g2) and Y = e(B, g2).

2. A outputs X(cid:48), Y (cid:48) (cid:54)= 1T .

We say that A wins if there is some t ∈ Zp with X(cid:48) = X t and
Y (cid:48) = Y t.

1227DEFINITION 4. We say that

the Knowledge of Pairing
Pre-Image assumption (KPA) holds if for every PPT algorithm A
in the above security game there exists another PPT algorithm A’
that given the same inputs and random coins as A behaves exactly
like A while additionally outputting g(cid:48)
2 besides X(cid:48), Y (cid:48) such
that X(cid:48) = e(A, g(cid:48)
2) and Y (cid:48) = e(B, g(cid:48)

2 = gt
2) whenever A wins.

MODIFIED KNOWLEDGE OF CO-CDH ASSUMPTION. The next
security assumption we rely on is based on the following problem
in bilinear group G = (p, g1, g2, e). Assume we provide attacker
A with A ∈ G1 (such that A = ga
1 for some a ∈ Zp) and let
X = e(A, g2). Intuitively, the task of A is to compute W such that
X = e(A, g2) = e(g1, W ) (i.e. W = ga
2 ). This is equivalent to
solving the Co-CDH assumption [6] in G with challenge A, g2, g1.
However, in our security experiment we will also give A access to a
Co-CDH oracle. To this end A may after receiving A specify Y ∈
GT . As a response A obtains U ∈ G2 such that XY = e(g1, U ).
The attacker is successful if it can now compute W . We observe
that by appropriate choices of Y , A can easily compute W .
- One way to do this is to have Y = X i for some i (cid:54)= −1. We
then have that XY = X i+1 = e(g1, U ). Therefore, W can
simply be computed from U as W = U 1/i+1.
- Another way is to set Y = e(g1, T ) for some T ∈ G2 known
to A. We then get that XY = X · e(g1, T ) = e(g1, U )
which is equivalent to X = e(g1, U/T ). Thus W = U/T is
a correct solution to the problem.

Basically, our new assumption states that every successful adver-
sary must follow one of these strategies – or a combination of both.
Intuitively this should still hold if the adversary is, besides U, also
provided with A(cid:48) = A1/z ∈ G2 (such that e(A, g2) = e(A(cid:48), gz
2 ))
since knowing the z-th root of A for some otherwise unrelated z
should not help to break the Co-CDH assumption.

The entire security experiment consists of four steps:
1. C sends a bilinear group G = (p, g1, g2, e) and gz

2for uni-
formly random z ∈ Zp to A together with uniformly random
A ∈ G1.

2. A outputs Y ∈ GT .
3. C outputs the group elements A1/z ∈ G1 and U ∈ G2 such

that e(A, g2) · Y = e(g1, U ).

4. A outputs W ∈ G2.

A wins if e(A, g2) = e(g1, W ).

DEFINITION 5. We say that the Modiﬁed Knowledge of Co-
CDH Assumption (MKCoCDH) holds if for every PPT algorithm
A there exists another algorithm A’ that given the same inputs and
random coins as A behaves exactly like A while in the second step
of the above security experiment additionally outputting i ∈ Zp
and T ∈ GT such that Y = e(A, g2)i · e(g1, T ) whenever A wins.
2.2 Hash Functions

DEFINITION 6. Consider a set H = {Ht}2κ

t=1 of hash func-
tions indexed by t where each Ht maps from {0, 1}∗ to the hash
space T . We require that log2(|T|) is a polynomial in κ. We say
that H is collision-resistant if for uniformly random t no PPT at-
tacker can output two distinct string m1, m2, such that Ht(m1) =
Ht(m2).
In the following we will always implicitly assume that t is chosen
uniformly at random at the beginning of the setup phase. We will
then drop t and simply write H (and H(cid:48)). In the security proofs we
model hash functions as random oracles.

2.3 Security Model

Let us very brieﬂy re-call the basic features of the security model

we use. For a more detailed exposition we refer to [18].

PROTOCOL FRAMEWORK. We consider a set of up to n = n(κ)
parties P1 to Pn, each of which is identiﬁed via unique (identity)
strings idi for i = 1, . . . , n, and a 2-pass key exchange protocol
Π that can be run between two parties that we typically denote as
idA and idB – or Alice and Bob. Unless stated explicitly otherwise
we always assume that idA (cid:54)= idB. Each instance of the protocol
run at party idi is called session while idi is also called the holder
of that session. A session can either complete, what involves pro-
cessing incoming messages and computing outgoing messages and
a session key K or abort in which case no session key will be com-
puted. Additionally we consider expired sessions which are com-
pleted sessions where the session key and all ephemeral values to
compute the session key have been erased.

2,z(cid:48)

3,z(cid:48)

1, z3 = z(cid:48)

2, z2 = z(cid:48)

4, and z4 = z(cid:48)

4) that z1 = z(cid:48)

The party with which the session key is intended to be shared
with after the protocol run is called peer. (More technically, Bob
is the the peer of one of Alice’s sessions if that session uses idB
to derive the session key.) The session identiﬁer (z1,z2,z3,z4) of
a session is a combination of the identity string of the holder z1,
the identity of the peer z2, the message sent by the session z3,
and the message received by the session z4. We say that two ses-
sions match if it holds for their session identiﬁers (z1,z2,z3,z4) and
(z(cid:48)
1,z(cid:48)
3. There
is also a special party called the key generation center that holds a
master secret key msk and publishes a corresponding master public
key mpk. The msk is used to derive secret keys ski for i = 1, . . . , n
for each of the parties from their corresponding identity strings. We
assume that each party idi receives its ski from the KGC (in an au-
thentic and conﬁdential way that is out of the scope of this paper).
The master public key contains all public information required by
the parties to run the protocol. We assume that each party knows
all identity strings of the other parties.
ATTACKER. We consider an attacker A that controls the entire
network, being able to intercept, modify, drop, replay, and insert
messages on transit. To model this, all outgoing messages are de-
livered to the adversary. If A only relays all the messages that are
sent to some session by its peer it is called passive with respect to
that session, otherwise it is called active. A can also activate ses-
sions of parties to make them engage in a protocol run with peers
of A’s choice. To model attack capabilities that grant the adversary
access to the secret information of sessions, parties, or the KGC,
we allow A to sent different types of queries to sessions.

- A Reveal query reveals the session key of a complete ses-

sion.

- A Corrupt query returns all information in the memory of
the holder of a session. This includes the secret keys of the
party as well as the state information of all its sessions. If a
query has been asked to a session with holder idi we also say
that idi is corrupted.

- A Test query can only be asked once and only to a complete
session that is not exposed. Depending on the outcome of a
randomly tossed coin c ∈ {0, 1}, the output of this query is
either the session key K stored at that session (in this context
also called the test-session) in case c = 0 or a random key
uniformly drawn from the space of session keys in case c =
1.
- The adversary may also make (up to n) Register queries.
On input the j-th identity idj with idj /∈ {id1, . . . , idj−1}

1228for 1 ≤ j ≤ n, this query creates5 party Pj and assigns
identity idj to it. Also the secret key skj corresponding to
identity idj is given to Pj. We assume that parties are ini-
tially uncorrupted.

Observe that in contrast to [18] we have formally introduced a
Register query. This models that the adversary may also adap-
tively choose the identities of the honest (uncorrupted) parties. This
is much stronger than in the mOT model, where the identities of
the uncorrupted parties are ﬁxed at start-up. (We consider it as an
essential feature of identity-based cryptography that the adversary
may choose the identities of the honest parties. This is in fact not
possible in classical key exchange, where we cannot rule out that
when an adversary registers a new public key that it knows the cor-
responding secret key.) Also, via a combination of Register and
Corrupt queries the adversary may obtain secret keys on identities
of his choice. The original model in [20] also speciﬁes queries
that reveal the secret state information of sessions. However, as
stated before, like mOT, our protocol will not be secure against
StateReveal queries (even not when only revealing the ephemeral
public keys gx
2 ). As in [18] we instead require protection
of these values to be at the same level as that of ski. As mentioned
before we can show in Appendix E that any protocol which allows
the adversary to obtain ephemeral secret keys, cannot provide full
PFS. In general, we require that except for session keys, all inter-
nal information of parties and sessions can only be revealed via full
party corruptions.

1 and gy

We say that a session is exposed if its holder has been corrupted
or its session key been revealed. Additionally sessions are consid-
ered exposed if there exists a matching session that is exposed.
SECURITY DEFINITIONS. Let SG denote the following security
game between a challenger C and an attacker A.
1. C gives to A the master public key mpk.
2. A may activate sessions and issue Reveal, Corrupt, and
Register queries to its liking. Also, A may use its control of
the network to modify messages on transit.

3. A may ask the Test query to some completed, unexposed
session with holder idA and peer idB such that idA (cid:54)= idB.
Let K be the response and c the internal random coin gener-
ated by the test session when answering the query.

4. A may activate sessions, issue Reveal, Corrupt, Register
queries, and use its control of the network to modify mes-
sages on transit.

5. A outputs c(cid:48) ∈ {0, 1}.

We say that an attacker A succeeds in a distinguishing attack if
c(cid:48) = c, the test session is not exposed and the peer of the test-
session has not been corrupted.

DEFINITION 7. An identity-based key agreement protocol Π is
secure if for all PPT attackers A that are given the above attack
capabilities, it holds that i) if two matching sessions of uncorrupted
parties complete the probability that the corresponding session keys
differ is negligibly close to zero and ii) A has success probability
in a distinguishing attack negligibly close to 1/2.
5Alternatively we may think of all the Pi for 1 ≤ i ≤ n to exists
before the security game without any identity or secret key. More-
over, they cannot be corrupted. Then Register only assigns idj and
skj to Pj.

DEFINITION 8

(WEAK PFS). We say that Π is secure with
weak perfect forward secrecy if in SG attacker A is also allowed
to corrupt the peer and the holder of the test-session after the test-
session key expired and A has remained passive (only) with respect
to the test-session and its matching session(s).

We stress that in our security proof of weak forward secrecy, secu-
rity even holds when the attacker knows the secret long term keys
(but no other session speciﬁc secret information) of the peer and the
holder and the KGC before the session key is computed. This can
be interesting when dealing with devices where long-term keys and
session speciﬁc information are stored separately in two different
memories possibly at different locations, but both with approxi-
mately the same level of protection against unauthenticated access.
Thus corruptions would not reveal session-speciﬁc information. In
these scenarios the Corrupt query would only allow to reveal the
long-term secrets. Next, we present a formal deﬁnition that cap-
tures this strengthened form of weak PFS. Essentially, it reﬂects
the intuition that forward secrecy should only rely on the secrecy
of the ephemeral keys but not of any long-term secret.

DEFINITION 9

(ENHANCED WEAK PFS). We say that Π pro-
vides enhanced weak perfect forward secrecy if Π is secure with
weak perfect forward secrecy even if A is additionally given the
secret keys of all parties and the secret key of the KGC at the be-
ginning of the security game and we allow that idA = idB.

Let us now deﬁne full PFS. In contrast to the previous deﬁnitions
we do not require the attacker to remain passive with respect to the
test-session.

DEFINITION 10

(FULL PFS). We say that Π is secure with
full perfect forward secrecy if in SG attacker A is additionally al-
lowed to i) obtain the secret key of the holder of the test session at
the beginning of the security experiment and ii) corrupt the peer of
the test session after the test-session key expired.

KEY COMPROMISE IMPERSONATION ATTACKS. We also cover
key compromise impersonation attacks. In a KCI attack, A may
after obtaining the secret key of party idA make idA falsely believe
that it is communicating with some other uncorrupted party idB al-
though idA actually isn’t. (Obviously impersonating Alice to other
parties with the help of Alice’s secret key is trivial.)

DEFINITION 11

(KCI SECURITY). We say that Π is secure
against KCI attacks if in SG attacker A is additionally given the
secret key of the holder of the test session at the beginning of the
security experiment.

Obviously, KCI security implies security under Deﬁnition 7 since
the adversary is only given additional information to mount its at-
tack.

REFLECTION ATTACKS. We additionally cover reﬂection attacks
in which an attacker makes two sessions of the same party com-
municate with each other. As pointed out by GKR, these attacks
are relevant in real-life scenarios when Alice wants to establish a
connection between two of her computers (for example access to a
home computer via her laptop).

DEFINITION 12

(SECURITY AGAINST REFLECT. ATTACKS).
We say that Π is secure against reﬂection attacks if in SG attacker
A may also choose a test-session whose peer is equal to its holder,
i.e. allowing idA = idB.

12293. MAIN RESULT

A detailed description of TOPAS is given in Figure 1. We re-
mark that the challenge in designing a protocol which provides
optimal message size and full PFS is that any such protocol must
provide two key properties. First, it must include an exchange of
ephemeral public keys as otherwise we cannot have any meaningful
form of forward secrecy. (Otherwise the session key can be derived
by Alice solely from her long-term key and any adversary that ob-
tains this key in a PFS experiment can also compute the session
key.) On the other hand, the protocol must also somehow make
the parties ‘authenticate’ their ephemeral public keys using their
corresponding long-term secrets as otherwise, by the impossibility
result of Krawczyk (Appendix D), we cannot have full PFS. The
difﬁculty when designing a protocol with optimal message length
now lies in the fact that we need to combine the two requirements
into a single short value.

In TOPAS, Alice and Bob exchange blinded versions of their
long-term keys. In particular, in each message the long-term secret
is multiplied by a fresh ephemeral Difﬁe-Hellman key. Each long-
term key in turn is a unique signature on the identity of its holder
under the master secret. The veriﬁcation equation for this signature
relies on the bilinear pairing and can be re-written as

e(skA, gz

2 )/e(H(idA), g2) ?= 1.

The crucial feature of the key derivation of TOPAS is that, due
to the bilinearity of the pairing, Bob can strip off the signature
skA (and thus any identity-speciﬁc information) from the message
1 skA. However, the result lies in the target group and has an
a = gx
additional exponent z:
e(a, gz

2 )/e(H(idB), g2)

2 )/e(H(idA), g2) = e(gx
= e(gx

1 , gz
1 , gz

2 )e(skA, gz
2 ) = e(g1, g2)xz.

By symmetry, Alice computes e(g1, g2)yz. Together with their own
secret ephemeral key, each party can now compute e(g1, g2)xyz.

In this rest of this section we present a security analysis of our
new protocol. We start by showing that TOPAS provides security
against KCI and reﬂection attacks, as well as enhanced weak PFS
under non-interactive security assumptions. Next, we provide a
proof of full PFS security.
3.1 Basic Security Properties

THEOREM 1. In the random oracle model, TOPAS is secure
against KCI attacks under the (2, 3)-CBDHI assumption, and se-
cure against reﬂection attacks under the (2, 3)-GCBDHI assump-
tion.

PROOF. It is straight-forward to show that two matching ses-
sions compute the same key. Since they are matching, they com-
pute the same session identiﬁer. Also, as shown above they com-
pute the same values k, k(cid:48). Thus all inputs to H(cid:48) are identical for
each session and the session key is equal too.

1, ˆgt

2, ˆgt2

1, ˆgt2

2, ˆgt3

In the next step, we show that real session keys are indistinguish-
able from random keys. Assume we are given the random input
G = (p, ˆg1, ˆg2, e) and (ˆgt
2 ) to the CBDHI/GCBDHI
2 = ˆgti
challenge. First, we let the simulator set g1 = ˆgt
2
for i = 1, 2, 3. This implicitly sets msk = z = t. Next, the simu-
lator draws random r, s ∈ Zp and sets h2 = gs
2 and
for some v ∈ Zp. This implicitly sets
hz
2 = (gz
v = s − rz2. Observe that all values are distributed exactly as in
the original security game.

2 )r = gvz
2

1 and gzi

2 )r = gv

2 )s/(gz3

2/(gz2

The simulator will randomly choose one party, Bob, to be the
peer of the test-session. Since there is only a polynomial number

of peers, the simulator’s guess is correct with non-negligible prob-
ability. Throughout the following, we therefore assume that Bob
will not be corrupted by the adversary. Similarly, the simulator will
guess the test-session with non-negligible probability.

We will consider two different types of attack strategies. Either
the attacker tries to launch a KCI attack or a reﬂection attack. We
exploit that security under KCI attacks implies security in the sense
of Deﬁnition 7. (The only difference is that the attacker may in a
KCI attack additionally request the secret key of Alice.) The proofs
for both attack types are slightly distinct in the extraction phase.
For ease of exposition, we describe a simulation strategy which is
for the most part valid for both attack types. We clearly mark when
and how the simulation strategies differ in the extraction phase. For
better overview, in both cases we always ensure that the peer (Bob)
of the test-session which is either held by Alice(cid:54)=Bob (in case of
KCI attacks) or Bob himself (when dealing with reﬂection attacks)
remains uncorrupted. Let us now present the general setup.

1

1 = ˆgzri

SETUP AND SIMULATION OF QUERIES. We will ﬁrst show how
the simulator will setup all parameters to be able to answer Corrupt
queries for any party except Bob. To this end, the simulator pro-
grams the outputs of the random oracle H for all inputs except for
idB as follows: given input idi it chooses a random value ri ∈ Zp
and outputs H(idi) := gri
. In this way, the simulator can
always compute a corresponding secret key as ski = ˆgri
1 and sim-
ulate the Register and Corrupt queries. However, for idB it sets
for some random rB ∈ Zp. Observe that the
−rB
H(idB) = ˆg
1
simulator does not know the corresponding secret key of Bob. In
almost all protocol runs the simulator makes sessions (except for
those whose holder is Bob) compute their messages and keys as
speciﬁed in the protocol description. In this way it can also answer
all Reveal queries (because the simulator knows the secret key of
any party except for Bob).

To compute messages in sessions where Bob is the session holder
(we denote the message produced by this session b), the simulator
does the following. It chooses a random b(cid:48) ∈ Zp and computes
= gb(cid:48)+rB /z
1 . It then holds that bz/H(idB) = ˆgzb(cid:48)+rB
b = ˆgb(cid:48)
.
1 (H(idB))1/z is
Observe that now the secret exponent y in b = gy
not known to Bob (i.e. the simulator that simulates Bob) as

1

1

(cid:48)

y = b

/z + rB/z2.

Observe that, as a consequence, the simulator cannot compute k
on behalf of Bob anymore when only given message a in case a is
produced by the adversary in an active attack.

SIMULATING REVEAL QUERIES FOR BOB. Let us show now how
the simulator can successfully simulate sessions (and in particular
Reveal queries) involving Bob (and the adversary). To this end
we ﬁrst show that, although the simulator cannot compute k, it can
nevertheless always compute k = kz2 even when the adversary A
makes Bob engage in a communication with Bob himself. Recall
that

(cid:16)
(cid:17)
 e
e(cid:0)H(idA), gz2

a, gz3

2

2

y

(cid:1)

.

kB =

Now, independent of whether a has been computed by Bob (when
considering reﬂection attacks), a session of any other party, or the
adversary, the simulator can compute kB for y = b(cid:48)/z + rB/z2 as

(cid:16)

(cid:17)

(cid:16)

e

kB =

e

a , gyz3

2

H(idA) , gyz2

2

(cid:17) =

e

e

(cid:16)

(cid:18)

(cid:16)

a ,

gz2

2

(cid:17)b(cid:48)·(gz

(cid:19)
2 )b(cid:48)·(g2)rB

2 )rB

(cid:17) .

H(idA) , (gz

12302 )s/(gz3

In the next step, we show that the simulator which knows k can
check, given k, k(cid:48), if indeed k = kz2 and k(cid:48) = kv. To this end
we apply a variant of the trapdoor test that was introduced in [10].
Recall that we have h2 = gv
2 =
2 )r for v = s − rz2 unknown to the simulator. We will
(gz
= k ∧ kv = k(cid:48)
now show that with overwhelming probability kz2
= k ∧ kv = k(cid:48). Then
iff k
r
= ks which shows the
k
k(cid:48) = ks. Observe that since
ﬁrst direction. Next assume that k

k(cid:48) = ks. First assume that kz2
ks−rz2

(cid:16)
kz2(cid:17)r

2 )r and hz

2 = gvz

2 = gs

2/(gz2

k(cid:48) =

kv =

r

r

(cid:16)
kz2(cid:17)r
k/kz2(cid:17)r

= kv/k

(cid:48)

s = v + rz2 we get that(cid:16)

(1)

(cid:16)

k/kz2(cid:17)r

while r is information-theoretically hidden from the adversary. Now
if k = kz2 this must imply kv = k(cid:48). In case k (cid:54)= kz2,
is uniformly distributed in GT (for random r) while kv/k(cid:48) is ﬁxed.
Thus the success probability of an adversary to produce k, k(cid:48) such
that Equation 1 is fulﬁlled is upper bounded by 1/p which is negli-
gible.
So we have now showed that the simulator can always compute k
and always check whether a given pair k, k(cid:48) happens to be “correct”
= k ∧ kv = k(cid:48).
(with respect to some session) in the sense of kz2
Let us next describe the strategy of the simulator to program the
second random oracle, H(cid:48), and answer Reveal queries to sessions
involving idB. The main problem is to keep the outputs of the
random oracle and the outputs to the Reveal queries consistent.
The simulator maintains two lists R and S which are initially both
empty. In R we store queries to the random oracle H(cid:48) and the cor-
responding answers. In S we simply store session-ids. Let us ﬁrst
describe the basic strategy. Whenever, the attacker queries the ran-
dom oracle with input xi we look up if there is some entry (xi, yi)
already in R. In case it is not, we generate and output a new ran-
dom string yi and add (xi, yi) to R. If (xi, yi) is already in R we
output yi. To compute session-keys for session-id idA, idB, a, b we
proceed as follows. We look up if there is some entry (ui, vi) with
ui = (idA, idB, a, b) already in S. In case it is not, we generate and
output a new random string vi and store (ui, vi) in S. If (ui, vi)
is already in S we output vi. The challenge now is that we have to
make sure that the answers stored in S and R remain consistent. In
particular, sometimes the outputs stored in S and R must be identi-
cal. (For example, imagine an adversary that successfully computes
the values k, k of some session with session-id idA, idB, a, b. Ob-
viously, querying xj = (k, k(cid:48), idA, idB, a, b) to the random oracle
must produce the same output as when asking the Reveal query
to session idA, idB, a, b.) To cope with such situations we need
to perform additional checks. So whenever we receive a query
xi = (k, k(cid:48), idA, idB, a, b) we additionally check whether there
is a corresponding query in S with uj = (idA, idB, a, b) such that
= k ∧ kv = k(cid:48) for the corresponding k value of that ses-
kz2
sion. On success we output yi = vj as stored in S. Otherwise we
output a random yi. On the other hand, whenever we encounter a
Reveal query for some session held by Bob we can always com-
pute ui = (idA, idB, a, b) and k. Next we also check whether
there is some entry (xj, yj) with xj = (k, k(cid:48), idA, idB, a, b) such
= k ∧ kv = k(cid:48). On success, we output vi = yj as
that again kz2
stored in R, otherwise we output a random vi.

EXTRACTION. Now that we have showed how to simulate all at-
tack queries, let us proceed to showing how the simulator extracts
a solution to the CBDHI challenge. From this point on, we cover

KCI attacks and reﬂection attacks separately. Either the test session
is held by Alice(cid:54)=Bob or Bob.

First we show how the simulator can extract a solution if the
test-session is held by Alice. For this session we deviate in the
simulation of the test-session from the general simulation strategy
that is described above. Instead of generating a honestly as a =
1 H(idA)1/z the simulator computes a as a = ˆga(cid:48)
1 H(idA)1/z for
gx
some random a(cid:48) ∈ Zp. Observe that now the discrete logarithm x
1 H(idA)1/z is implicitly set to x = a(cid:48)/z.
in a = gx

Suppose that the adversary has non-negligible success probabil-
ity when querying the Test query to this sessions. In particular, it
can decide whether the key provided by the Test query is the real
session key or a random key from the same key space. We know
that the attacker must ask the correct k, k(cid:48) values with respect to
the test-session to H(cid:48). With y = b(cid:48)/z + rB/z2 and x = a(cid:48)/z the
simulator in this way obtains k such that
k = e(g1, g2)xyz = e(ˆg1, ˆg2)xyz2

= e(ˆg1, ˆg2)a(cid:48)/z·(b(cid:48)/z+rB /z2)·z2

= e(ˆg1, ˆg2)a(cid:48)b(cid:48)+a(cid:48)rB /z.
From this we can easily compute a solution d to the CBDHI as-

sumption as

(cid:16)

−a(cid:48)b(cid:48)(cid:17)1/a(cid:48)rB

d =

ke(ˆg1, ˆg2)

= e(ˆg1, ˆg2)1/z.

z+w

Let us now show how to extract a solution to the GCBDHI chal-
lenge if the test-session is held by Bob. Recall that the GCBDHI
challenge also contains w ∈ Zp and the task is to compute the
z2 . In this case we already have that each mes-
value e(ˆg1, ˆg2)
sage output by Bob is constructed as b = ˆgb(cid:48)
1 for random b(cid:48). Now
for the test-session we slightly deviate and set a as a = ˆga(cid:48)
for
a(cid:48) ∈ Zp with a(cid:48) = rBw − b(cid:48) (i.e. such that rB/(a(cid:48) + b(cid:48)) = w).
−rB
1 H(idB)1/z =
Recall that H(idB) = ˆg
1
1 · ˆg
1 for random
gx
b(cid:48), implying y = b(cid:48)/z + rB/z2. This time the simulator obtains
the value k from the queries to the random oracle such that

to x = a(cid:48) + rB/z. Also assume that b = ˆgb(cid:48)

. This sets x in a = gx

−rB
1

1 ˆgrB

1

k = e(g1, g2)xyz = e(ˆg1, ˆg2)xyz2

= e(ˆg1, ˆg2)(a(cid:48)+rB /z)·(b(cid:48)/z+rB /z2)·z2
= e(ˆg1, ˆg2)a(cid:48)b(cid:48)+(a(cid:48)+b(cid:48))rB /z+(rB )2/z2

.

We now easily get a solution to the GCBDHI assumption as

(cid:16)

ke(ˆg1, ˆg2)

−a(cid:48)b(cid:48)(cid:17)1/(a(cid:48)+b(cid:48))rB

= e(ˆg1, ˆg2)

z+rB /(a(cid:48)+b(cid:48) )

z2

= e(ˆg1, ˆg2)

z+w
z2 .

This concludes the proof of security.

ENHANCED WEAK PFS. Let us now show that TOPAS provides
enhanced weak PFS. The proof is relatively straight-forward.

THEOREM 2. TOPAS provides enhanced weak forward secre-

cy under the CBDH assumption.

PROOF. Except for the generation of two messages a and b, the
simulator can setup everything as speciﬁed in the protocol descrip-
tion. As before, with non-negligible success probability a is the
message sent by the test-session and b is the message received by
the test-session.
(In contrast to the previous proof the simulator
will now also know the secret key of Bob and the master secret
z.) Since almost everything is computed as speciﬁed in the proto-
col description and since the session key is expired the simulator

1231can answer all queries of the attacker. We exploit that for enhanced
weak PFS security we can assume that a and b may not be produced
or modiﬁed by the adversary. Let gx
1 be the CBDH challenge.
The simulator computes

1 , gy

a = gx

1 H(idA)1/z and b = gy

1 H(idB)1/z.

We now have that k = e(g1, g2)xyz. As before, any success-
ful adversary must query this value to the random oracle H(cid:48) be-
fore answering the test-query. The simulator can guess with non-
negligible success probability which of the values queried to H(cid:48) is
equal to k. Then it can simply compute the answer to the CBDH
challenge as k1/z = e(g1, g2)xy.
3.2 Proof of Full PFS Security

THEOREM 3. The TOPAS protocol provides full PFS under the

(3, 3)-CBDHI, the KPA, and the MKCoCDH assumption.

In contrast to the previous security proof of enhanced weak PFS,
the adversary can also modify the messages sent and received by
the test-session in the security experiment for full PFS.

PROOF. Assume there exists an adversary A0 that breaks the
full PFS security of the protocol. In the following we will step-
wisely construct a chain of adversaries A0 to A6 such that A6
breaks the (3, 3)-CBDHI assumption. Each adversary Ai for i =
1, 2, 3, 4, 5, 6 is based on the existence of the previous one Ai−1.
Let us ﬁrst recall the essence of the security experiment when
proving full PFS security. Besides the setup parameters, the ad-
versary A0 is also given a = gx
1 H(idA)1/z, skA, H(idB) (but not
(H(idB))1/z). In response, the adversary computes b ∈ G1. Let
Y ∈ G1 be the value such that b = Y (H(idB))1/z. Next, the
challenger provides the adversary with skB = (H(idB))1/z. Now
since the adversary can distinguish K from a random key it must
query the corresponding

k = (e(b, gz

2 )/e(H(idB), g2))x = (e(a, gz

2 )/e(H(idA), g2))y

1 , ˆgt3

1 , ˆgt

2, ˆgt2

2 , ˆgt3

to the random oracle H. In the following we always assume, for
simplicity, that k is directly given to the challenger.
Attacker A6 will simulate the real security game to A5 using
a similar setup as in the proofs before. Assume we are given the
random CBDHI challenge consisting of G = (p, ˆg1, ˆg2, e) and
1, ˆgt2
2 ). Let us ﬁrst show how the simulator will
(ˆgt
construct the ﬁrst part of the public parameters in mpk that are to be
given to A5. Again we let the simulator output gz
2 as part of
mpk. Internally, it will also set gzi
2 for i = 2, 3. This implic-
itly sets msk = z = t. The simulator draws random r, s ∈ Zp and
sets sets h2 = gs
2 for
some v ∈ Zp. This implicitly sets v = s − rz2. Observe that all
values are distributed exactly as in the original security game.
Next, the simulator draws a random coin q ∈ {0, 1} and a uni-
formly random rB ∈ Zp. Depending on q, the remaining setup
values will slightly differ. That is, the simulator sets
1 )rB and g1 = ˆgtq+1

H(idB) = (ˆgtq

1 )rB = (ˆgzq

2 )r = gvz

2 )s/(gz3

2 )r = gv

2 = ˆgti

= ˆgzq+1

2 and hz

2 = (gz

2/(gz2

2 = ˆgt

.

1

1

Observe that the simulator does not know skB in case q = 0.
However, in case q = 1 the simulator knows skB = (H(idB))1/z =
ˆgrB
1

For q = 0 and q = 1, the simulator programs the outputs of
the random oracle H for all inputs except for idB as follows: given
input idi (regardless of it being chosen by the adversary as part of
a Register query or not) it chooses a random value ri ∈ Zp and

1

1

1 = ˆgzq+1ri

2 together with k such that k = e(X, g∗
2 ). Since k = e(g1, g2)xyz, we must have g∗

outputs H(idi) := gri
. In this way, the simulator can
always compute a corresponding secret key as ski = ˆgzq ri
and
answer the Corrupt query. As in the previous proofs, all sessions
can be simulated with this setup except for the test-session.
Our next goal is to step-wisely construct attacker A5. It behaves
like A0 but outputs some additional values in case the simulator
correctly guesses the test-session (and its peer). We stress that A5
is an attacker against the full PFS security just like A0. Let us begin
our formal analysis. Assume we have a successful adversary A0.
ATTACKER A1. Attacker A1 will work exactly like A0 except
2 )/e(H(idB), g2) together with b and
that it outputs k1/x = e(b, gz
g1, X = a/skA = gx
1 at the end of the security game. Observe that
these values can easily be computed from the public values alone.
ATTACKER A2. Now, since A1 outputs k, X, k1/x, g1, by the secu-
rity of the Knowledge of Pairing Pre-Image assumption there also
exists an adversary A2 that works exactly like A1 except that it also
outputs g∗
2 ) and k1/x =
e(g1, g∗
2 = gyz
2 .
ATTACKER A3. Next, we show that if A2 wins the security game
against a PFS challenger we can construct an attacker A3 that can
win in the security of the MKCoCDH assumption.
Let us recall the security game of the Modiﬁed Knowledge of
Co-CDH Assumption. First A3 receives G, gz
2 and B(cid:48) ∈ G1. Next,
A3 outputs Y (cid:48) ∈ GT . As a response, the challenger outputs B(cid:48)1/z
and U(cid:48) ∈ G2 with e(B(cid:48), g2) · Y (cid:48) = e(g1, U(cid:48)). Finally, A3 outputs
W (cid:48). It wins if e(B(cid:48), g2) = e(g1, W (cid:48)).
We will now describe how A3 works using the values provided
to A2 by the PFS challenger and A2’s output values. We then argue
that A3 always wins given that A2 wins against the PFS challenger.
1 H(idA)1/z, skA, H(idB) be the values
Let, G, gz
provided by the full PFS challenger to A2. The input to A3 is
2 , B(cid:48) = H(idB). When A2 outputs b, k1/x, A3 will output
G, gz
Y (cid:48) = k1/x to its challenger. In response A3 receives (H(idB))1/z
and U(cid:48) from its challenger. The value (H(idB))1/z is used as input
to A2. The ﬁnal output of A2 is k and g∗
2 . A3 can now
compute W (cid:48) = U(cid:48)/gyz

2, a = gx

2 = gyz

2 , h2, hz

2 . Observe that W (cid:48) is correct since
(cid:48)
)/e(g1, g
(cid:48)
).

)/Y
= e(g1, U
∗
2 ) = e(g1, W

/g

(cid:48)
(cid:48)

(cid:48)

, g2) = e(g1, U
= e(g1, U

(cid:48)

e(B

∗
2 )

So whenever A2 succeeds in a security game with the PFS chal-
lenger so will A3 in the security game of the Modiﬁed Knowledge
of Co-CDH Assumption.
ATTACKER A4. Now by the security of the MKCoCDH assump-
tion, as A3 succeeds there exists another adversary A4 that works
exactly like A3 except that it also outputs i ∈ Zp, T ∈ GT together
with Y (cid:48) such that

(cid:48)

Y

= e(B

(cid:48)

, g2)i · e(g1, T ).

We stress again that in the above series of attackers we have that

if A0 wins so will A4.
ATTACKER A5. Let us now show another adversary A5 that con-
trols A4 and A2 to win against a PFS challenger while outputting
additional values besides what is required by deﬁnition. By con-
struction we have that the Modiﬁed Knowledge of Co-CDH at-
tacker A4 uses the PFS attacker A2 as a (black-box) subroutine.
In the following A5 will modify the communication between A4
and A2 and play the role of the PFS challenger against A2. A5
2, skA, H(idB), and a as
receives the setup parameters G, gz
2 ,, and H(idB) to A4. At the same time A5
input. It relays G, gz

2 , h2, hz

12322, hz

2 , hz

2 = gyz

2, skA, H(idB), a to A2. In response,
sends all values G, gz
A2 outputs b and k1/x to A5. The other attacker, A4, outputs k1/x
together with i, T to A5. However, A5 will output b and i, T , i.e. a
mix of the outputs by A4 and A2. Next, A5 receives (H(idB))1/z
from its PFS challenger. Attacker A5 simply relays this value to
A2. As a response A2 outputs k and g∗
2 . Both values are
ﬁnally output by A5. Observe that we have not completed the run
for A4. However, we know by our previous analysis that if A2 is
successful, so will A4 (if we complete the run of A4). However,
at this point it is hidden from A4’s view that we abort as all val-
ues given to A4 are distributed exactly as in the real security game.
Nevertheless, already at this point we must have that the values i, T
are such that Y (cid:48) = e(B(cid:48), g2)i · e(g1, T ) (otherwise A4 could not
win in case we completed the run with a winning A2). In all of this,
A5 will deal with any attack queries made by A2 to its PFS envi-
ronment by simply relaying them to its own PFS challenger and the
corresponding answers back to A2.
ATTACKER A6. We will now present an attacker A6 that can break
the CBDHI assumption by using attacker A5. A6 will, using the
CBDHI challenge, simulate all sessions (except for the test-session)
as described before. Let us now turn our attention to the test-
session. We have to consider two cases: either it holds for the value
i output by A5 that i (cid:54)= −1 or i = −1.
Let us ﬁrst consider the case where i (cid:54)= −1. With probability at
least 1/2 we have that q = 0. In this case, it holds that H(idB) =
ˆgrB
1 . We also have that

e(b, gz
2 )

= e(Y, gz

2 ) = e(H(idB), g2)i · e(g1, T ).

e(H(idB), g2)

This directly gives(cid:18) e(b, gz

2 )
e(g1, T )

(cid:19)1/rB (i+1)

= e(ˆg1, ˆg2)1/z.

It is important to observe that in case i (cid:54)= −1 the simulator does
not need to know H(idB)1/z.
It can already break the CBDHI
assumption just after receiving b and (i, T ).

Now let us turn our attention to the case where i = −1.

In
this case, with probability at least 1/2 we have that q = 1 and
H(idB) = (ˆgt)rB and A6 knows skB = ˆgr1. It can thus success-
fully send skB to the adversary A5 and receive back gzy
2 . Since
i = −1 we have e(b, gz
2 ) = e(Y grB /z2

2 ) = e(g1, T ). It holds that

) = e(g1, T ).

, gz

2 ) = e(g1, gzy+rB /z

e(b, gz

1

2

This immediately shows that T /gzy
solution to the complexity challenge as

2 = grB /z

2

. We ﬁnally get a

e(ˆg1, T /gzy

2 )1/rB = e(ˆg1, ˆg2)1/z.

This completes the proof of security.

4. HIGHER EFFICIENCY

TOPAS+ is a variant of our protocol that features higher efﬁ-
ciency in the key derivation process (Figure 2). Essentially, it is
equivalent to our ﬁrst protocol except that now only one interme-
diate value k is computed and fed into the hash function H(cid:48). As
a consequence we can have a shorter master public key. More im-
portantly, when computing K each party only needs to apply two
pairings one of which is message-independent and only needs to
be computed once for every communication partner. The secu-
rity proof of this variant will additionally rely on a variant of the
so-called Strong Difﬁe-Hellman (SDH) assumption. Basically, it

Alice (A)

skA = (H(idA))1/z

x $← Zp
b ∈ G1?

Bob (B)

skB = (H(idB))1/z

y $← Zp
a ∈ G1?

a = gx
b = gy

1 skA
1skB

kA = (e (b, gz
KA = H(cid:48)(kA, idA, idB, a, b)

2) /e(H(idB), g2))x

kB = (e (a, gz
KB = H(cid:48)(kB, idA, idB, a, b)

2) /e(H(idA), g2))y

Figure 2: Overview of TOPAS+. The KGC maintains public pa-
rameters mpk containing g1, g2, gz
2 , p, a description of the pairing
e, and descriptions of two hash functions H : {0, 1}∗ → G1 and
H(cid:48) : {0, 1}∗ → {0, 1}∗. These parameters are available to all par-
ties. The master secret msk consists of z and is used by the KGC to
derive the user secret keys as ski = (H(idi))1/z.

states that the assumptions used in the proofs of key indistinguisha-
bility, security against reﬂection, KCI, and full PFS attacks remain
valid even if the adversary has access to an oracle Oz2 (·,·) with the
following property: given ˜k ∈ GT , ˜k∗ ∈ GT , Oz2 (·,·) outputs 1
iff ˜kz2

= ˜k∗ and 0 otherwise.

DEFINITION 13. We say that the (k, l)-CBDHI’ assumption
holds, if the (k, l)-CBDHI assumption holds even when the adver-
sary is additionally given access to oracle Oz2 (·,·) in the CBDHI
security game. Likewise we say that the (k, l)-GCBDHI’ assump-
tion holds if the (k, l)-GCBDHI assumption holds even when the
adversary is additionally given access to oracle Oz2 (·,·) in the
GCBDHI security game.

The security proof remains virtually untouched. The only differ-
ence is now that we do not need a trapdoor test to maintain consis-
tency when simulating the random oracle. Instead we can directly
use the oracle Oz2 to check whether a query k∗ = k of the ad-
versary (as part of the H(cid:48) query ˆk) actually equals the intermediate
value computed by some session in the real security game. Again,
the simulator is only able to compute k = kz2 for all sessions but
using Oz2 (·,·) it can check if Oz2 (k∗, k) is equal to 1. These mod-
iﬁcations affect all proofs except for the proof of enhanced weak
PFS.

THEOREM 4. TOPAS+ (Figure 2) has the same security prop-
erties under the same security assumptions as TOPAS (Figure 1),
except that it relies on the (2, 3)-CBDHI’, (3, 3)-CBDHI’, and
(2, 3)-GCBDHI’ assumptions instead of the (2, 3)-CBDHI, (3, 3)-
CBDHI, and (2, 3)-GCBDHI assumptions.

5. DENIABILITY

Deniable key exchange protocols protects Alice against the un-
wanted disclosure of her participation in a protocol run via Bob.
This can be used to implement a digital variant of “off-the-record”
communication over insecure networks. Intuitively, a key exchange
protocol provides deniability, if Bob cannot convince a judge, Judy,
that Alice once talked to him. To show deniability, it sufﬁces to
show that every transcript and corresponding session key that Bob
presents to Judy can equally have been produced by a public sim-
ulation algorithm that has no access to Alice. More formally, for
every PPT Bob that communicates with the PPT Alice, there exists
a PPT simulator which when given the same inputs (including the
same random coins) as Bob produces transcripts and correspond-
ing session keys which are indistinguishable from those produced

1233by Bob. For a formal treatment of deniability in key exchange pro-
tocols see [13].

In 2-message key exchange protocols where the computation of
the exchanged messages involve the secret keys, it may be impos-
sible to achieve deniability. As an example consider exchanging
signed DH shares where the signature involves the identities of both
parties. Of course, when Bob receives such a signature from Al-
ice and presents it to Judy this immediately proves that Alice once
talked to Bob. Fortunately, TOPAS and TOPAS+ provide a very
strong form of deniability, although the computation of a involves
Alice’s secret key.

THEOREM 5. TOPAS and TOPAS+ meet the strong notion of

deniability of [13].

PROOF. Observe that a = gxskA is uniformly distributed since
x is uniform. Therefore the simulator can simulate Alice’s message
a by just choosing a random group element in G1. Recall that by
deﬁnition the simulator is also given the same random coins as Bob.
Thus and because the simulator also knows Bob’s secret key, it can
compute y, b and the corresponding session key K in the exact
same way as Bob.

6. ACKNOWLEDGEMENTS

I am grateful to Yong Li, who generously allowed me to use his
observations in the impossibility result of Appendix E. I would also
like to thank the anonymous reviewers for their helpful comments.
This work was supported by the DFG-Research Training Group
UbiCrypt (GRK 1817/1).

7. REFERENCES
[1] Michel Abdalla, Mihir Bellare, and Phillip Rogaway. The

oracle Difﬁe-Hellman assumptions and an analysis of
DHIES. In David Naccache, editor, CT-RSA 2001, volume
2020 of LNCS, pages 143–158. Springer, April 2001.

[2] Google Security Team Adam Langley. Protecting data for the

long term with forward secrecy.
http://googleonlinesecurity.blogspot.co.
uk/2011/11/
protecting-data-for-long-term-with.html.

[3] Paulo S. L. M. Barreto and Michael Naehrig.

Pairing-friendly elliptic curves of prime order. In Bart
Preneel and Stafford E. Tavares, editors, Selected Areas in
Cryptography, volume 3897 of Lecture Notes in Computer
Science, pages 319–331. Springer, 2005.

[4] Florian Bergsma, Tibor Jager, and Jörg Schwenk. One-round
key exchange with strong security: An efﬁcient and generic
construction in the standard model. In PKC 2015, LNCS,
pages 477–494. Springer, 2015.

[5] Dan Boneh and Xavier Boyen. Efﬁcient selective

identity-based encryption without random oracles. Journal of
Cryptology, 24(4):659–693, October 2011.

[6] Dan Boneh, Craig Gentry, Ben Lynn, and Hovav Shacham.
Aggregate and veriﬁably encrypted signatures from bilinear
maps. In Eli Biham, editor, EUROCRYPT 2003, volume
2656 of LNCS, pages 416–432. Springer, May 2003.

[7] Dan Boneh, Ben Lynn, and Hovav Shacham. Short

signatures from the Weil pairing. Journal of Cryptology,
17(4):297–319, September 2004.

[8] Xavier Boyen. The uber-assumption family (invited talk). In

Steven D. Galbraith and Kenneth G. Paterson, editors,
PAIRING 2008, volume 5209 of LNCS, pages 39–56.
Springer, September 2008.

[9] Ran Canetti and Hugo Krawczyk. Analysis of key-exchange
protocols and their use for building secure channels. In Birgit
Pﬁtzmann, editor, EUROCRYPT 2001, volume 2045 of
LNCS, pages 453–474. Springer, May 2001.

[10] David Cash, Eike Kiltz, and Victor Shoup. The twin

Difﬁe-Hellman problem and applications. In Nigel P. Smart,
editor, EUROCRYPT 2008, volume 4965 of LNCS, pages
127–145. Springer, April 2008.

[11] Yu Chen, Qiong Huang, and Zongyang Zhang.

Sakai-Ohgishi-Kasahara identity-based non-interactive key
exchange revisited and more. In Willy Susilo and Yi Mu,
editors, ACISP 14, volume 8544 of LNCS, pages 274–289.
Springer, July 2014.

[12] Cas J. F. Cremers and Michele Feltz. Beyond eCK: Perfect

forward secrecy under actor compromise and ephemeral-key
reveal. In Sara Foresti, Moti Yung, and Fabio Martinelli,
editors, ESORICS 2012, volume 7459 of LNCS, pages
734–751. Springer, September 2012.

[13] Mario Di Raimondo, Rosario Gennaro, and Hugo Krawczyk.

Deniable authentication and key exchange. In Ari Juels,
Rebecca N. Wright, and Sabrina De Capitani di Vimercati,
editors, ACM CCS 06, pages 400–409. ACM Press,
October / November 2006.

[14] Whitﬁeld Difﬁe and Martin E. Hellman. New directions in
cryptography. IEEE Transactions on Information Theory,
IT-22(6):644–654, 1976.

[15] Dario Fiore and Rosario Gennaro. Making the

Difﬁe-Hellman protocol identity-based. In Josef Pieprzyk,
editor, CT-RSA 2010, volume 5985 of LNCS, pages 165–178.
Springer, March 2010.

[16] Marc Fischlin and Nils Fleischhacker. Limitations of the

meta-reduction technique: The case of schnorr signatures. In
Thomas Johansson and Phong Q. Nguyen, editors,
EUROCRYPT 2013, volume 7881 of LNCS, pages 444–460.
Springer, May 2013.

[17] Steven D. Galbraith, Kenneth G. Paterson, and Nigel P.

Smart. Pairings for cryptographers. Discrete Applied
Mathematics, 156(16):3113–3121, 2008.

[18] Rosario Gennaro, Hugo Krawczyk, and Tal Rabin.

Okamoto-Tanaka revisited: Fully authenticated
Difﬁe-Hellman with minimal overhead. In Jianying Zhou
and Moti Yung, editors, ACNS 10, volume 6123 of LNCS,
pages 309–328. Springer, June 2010.

[19] Hugo Krawczyk. SKEME: a versatile secure key exchange

mechanism for internet. In James T. Ellis, B. Clifford
Neuman, and David M. Balenson, editors, 1996 Symposium
on Network and Distributed System Security, (S)NDSS ’96,
San Diego, CA, February 22-23, 1996, pages 114–127. IEEE
Computer Society, 1996.

[20] Hugo Krawczyk. HMQV: A high-performance secure

Difﬁe-Hellman protocol. In Victor Shoup, editor,
CRYPTO 2005, volume 3621 of LNCS, pages 546–566.
Springer, August 2005.

[21] Laurie Law, Alfred Menezes, Minghua Qu, Jerome A.

Solinas, and Scott A. Vanstone. An efﬁcient protocol for
authenticated key agreement. Des. Codes Cryptography,
28(2):119–134, 2003.

[22] Eiji Okamoto and Kazue Tanaka. Key distribution system

based on identiﬁcation information. IEEE Journal on
Selected Areas in Communications, 7(4):481–485, 1989.

1234[23] Victor Shoup. On formal models for secure key exchange.

Cryptology ePrint Archive, Report 1999/012, 1999.
http://eprint.iacr.org/.

[24] Transport Layer Security working group of the IETF.

Conﬁrming consensus on removing RSA key transport from
TLS 1.3. http://www.ietf.org/mail-archive/
web/tls/current/msg12362.html.

APPENDIX
A. PKI-BASED PROTOCOL VARIANT

TOPAS and TOPAS+ can easily be turned into PKI-based proto-
cols. Due to space limitation we only sketch this here. The global
parameters are the public key of the KGC together with gz
1 (this
value is not required in our identity-based protocol). The certiﬁca-
tion authority creates a signature key pair and publishes the public
key. User keys are generated as follows. Each user chooses a ran-
dom r ∈ Zp and computes sk = gr
1 )r. The CA
provides a certiﬁcate for each user by signing the user’s public key
together with its identity. The rest of the protocol works exactly
as in the identity-based protocol instead that the public key of the
communication partner is used to derive the session key. For exam-
ple, Alice can compute her message a and the intermediate key k as
a = gx

1 skA for random x ∈ Zp and k = (e(b, gz

1 and pk = (gz

2 )/e(pkB, g2))x.

B. ON THE IMPORTANCE OF FULL PFS
Assume a two-message protocol executed between Alice and
Bob where Alice sends a to Bob and Bob sends b to Alice. Now
assume that after deriving the secret session key from b and her se-
cret key, Alice immediately sends a sensitive message to Bob that is
encrypted as ciphertext c with a key derived from the secret session
key. In particular, this message is produced without Alice knowing
whether Bob actually has computed the same key. Now assume an
adversary who is interested in the contents of the ﬁrst messages of
Alice. Whenever it observes that Alice sends a message a over the
network, it drop Bob’s b, computes its own value b(cid:48), and sends it
to Alice. Next it intercepts Alice’s ciphertext c and records a, b(cid:48), c
in a list. Assume that later on, the adversary learns the secret key
of Bob. Weak perfect forward secrecy does not guarantee the se-
crecy of the message c because the attacker changed b to b(cid:48) but full
perfect forward secrecy does so.

C. THE UBER-ASSUMPTION

The non-interactive (k, l)-CBDHI and (k, l)-GCBDHI assump-
tions, can be viewed as special instantiations of Boyen’s Uber-
assumption (and its extensions) restricted to univariate polynomi-
als. Following Boyen, our assumptions differ from the “classical”
Uber-assumption in two ways. First, we consider computational as-
sumptions (which are however implied by their decisional variants)
and second we use rational exponents. However, in [8] Boyen also
presents several extensions to the classical Uber-assumption that
also cover these classes of assumptions. To apply Boyen’s master
theorem and show security in the generic bilinear group model we
have to show independence of the polynomial 1/z (respectively
(z + w)/z2) over Zp from 1, z, z2, . . . , zk and 1, z, z2, . . . , zl.
This means that there do not exist (k + 1)(l + 1) constants {ai,j}
for i ∈ [0, k] and j ∈ [0; l] such that for all z (cid:54)= 0 we always have

1/z =

ai,jzi+j or (z + w)/z2 =

ai,jzi+j

i=0

j=0

i=0

j=0

k(cid:88)

l(cid:88)

k(cid:88)

l(cid:88)

k(cid:88)

l(cid:88)

k(cid:88)

l(cid:88)

over Zp. This is simple. These two equations are equivalent to

ai,jzi+j+1 − 1 = 0 or

ai,jzi+j+2 − z − w = 0.

i=0

j=0

j=0

i=0
Now for any choice of the ai,j, the polynomials on the left-hand
side have at least degree 1 (respectively 2). The maximal degree is
k+l+1 << p (respectively k+l+2 << p). This means they have
at most k + l + 1 (respectively k + l + 2) roots. Thus the equations
cannot be fulﬁlled for all z (cid:54)= 0. As a consequence we can apply
the master theorem of Boyen to show that our assumptions are se-
cure in the generic bilinear group model. Similarly, we can show
that the CBDH assumption is secure in the generic bilinear group
model. This time, we have to show that there do not exist constants
a0, a1, a2 with xy = a0+a1x+a2y for all x, y ∈ Zp. This is again
very simple, as for any x (cid:54)= a2 ∈ Zp there is only a single y ∈ Zp
fulﬁlling the above equation, namely y = (a0 + a1x)/(x − a2).
Thus we can apply the master theorem and obtain security of this
assumption in the generic bilinear group model. We stress that a
successful adversary against the CBDH assumption can easily be
used to break the DDH assumption in G1: assume we are given
the DDH challenge g1, ga
and we have to decide
whether c = 0. We can now use the CBDH attacker to compute
T = (g1, g2)ab. Next we compute e(h, g2) and check whether the
result equals T . On success, we output that c = 0 otherwise c = 1.

1, h = gab+c

1 , gb

1

D. EXISTING IMPOSSIBILITY RESULT

In [20], Krawczyk presented a simple attack against the full PFS
security of implicitly authenticated protocols. To illustrate it, as-
sume a protocol in which Alice and Bob only exchange ephemeral
Difﬁe-Hellman shares gx (sent by Alice) and gy (sent by Bob). Let
us consider the situation where Alice acts as the initiator. To this
end, she generates the ephemeral key gx and sends it to Bob who
responds with gy. The adversary intercepts this value, and gener-
ates its own share by choosing random y and computing gy. Then
it sends gy to Alice. Alice assumes this value was sent by Bob and
generates the session key K from her secret key, x, and gy. Now,
assume that the adversary learns the secret key skB of Bob after
Alice’s session expired. Since the computation of the session key
(from Bob’s perspective) only depends on gx and the knowledge
of y and skB, the adversary is able to re-compute the session key
K. Therefore it can always distinguish K from a random value.
Observe that this impossibility result holds even in the case the two
oracles have a common KGC that produces their secret keys or if
they share a secret key. Essentially, the problem is that the adver-
sary can always compute an ephemeral public key together with the
corresponding ephemeral secret key that seems to come from Bob.

E. NEW IMPOSSIBILITY RESULT

LEMMA 1. Any two-message protocol which provides full PFS

cannot allow the adversary to reveal ephemeral secret keys.

PROOF. Without loss of generality assume Bob sends his mes-
sage b ﬁrst. Since the protocol provides (full) PFS by deﬁnition,
any message b of Bob must contain an ephemeral public key epk.
For contradiction assume the adversary can for one b reveal the
corresponding ephemeral secret esk. The adversary can now eas-
ily break the security of the full PFS game by replaying b to the
test-session (held by some party). It obtains back Bob’s long-term
secret skB. With esk, skB, and the message output by the test-
session, the adversary can always derive the same session key as
the test-session and thus win in the full PFS game.

1235