Chainsaw: Chained Automated Workﬂow-based Exploit

Generation

Abeer Alhuzali

∗

, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan

University of Illinois at Chicago

Chicago, IL

{aalhuz2, eshete5, rgjome1, venkat}@uic.edu

ABSTRACT
We tackle the problem of automated exploit generation for
web applications. In this regard, we present an approach
that signiﬁcantly improves the state-of-art in web injection
vulnerability identiﬁcation and exploit generation. Our ap-
proach for exploit generation tackles various challenges as-
sociated with typical web application characteristics: their
multi-module nature, interposed user input, and multi-tier
architectures using a database backend. Our approach de-
velops precise models of application workﬂows, database
schemas, and native functions to achieve high quality exploit
generation. We implemented our approach in a tool called
Chainsaw. Chainsaw was used to analyze 9 open source
applications and generated over 199 ﬁrst- and second-order
injection exploits combined, signiﬁcantly outperforming sev-
eral related approaches.

Keywords
Exploit generation; Web security; Injection vulnerabilities

1.

INTRODUCTION

Web applications are the engines that drive modern
electronic commerce and banking applications. Therefore,
security of these applications is an important concern. Any
vulnerability that can be exploited in these applications
can be catastrophic in terms of ﬁnancial losses to the on-
line enterprise as well as privacy losses to the consumer.
Vulnerability analysis research eﬀorts try to proactively ex-
pose the ﬂaws in these applications before attackers can
leverage them, and therefore are crucial from a defense stand-
point.

Injection vulnerability analysis eﬀorts fall broadly into
two categories: penetration-testing approaches and program
analysis based approaches. Of these, penetration testing
tools work by injecting inputs (which resemble common ex-
ploit strings) in the application to check for the presence

∗Also aﬃliated with King Abdulaziz University, Saudi Arabia

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
© 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978380

of vulnerabilities. While they are easy to deploy, they lack
broad-coverage of the application and therefore miss vul-
nerabilities. In fact, recent studies [4] have shown that the
coverage of these tools is low.

[9])

for

[26],

[28],

Static analysis approaches do not suﬀer from the cover-
age problem, and are based on more directed exploration
of an application’s code.
In particular, they are focused
on identifying properties of certain sensitive sinks in the
application. There has been a large body of work (e.g., [17],
[20],
identifying web application
vulnerabilities such as SQL injection (SQLI) and Cross-site
scripting (XSS). However, due to technical and engineer-
ing considerations that go into modeling complex language
features, static analysis tools often suﬀer from false positives.
A direction that has received interest in the recent years
is automated exploit generation: approaches that convert
potential vulnerabilities resulting from a static analysis tool
into concrete exploits. Because an exploit is an actual input
to an application that can be veriﬁed, and in most cases
automatically, exploit ﬁnding has the potential to eliminate
false alarms from static tools.

We pursue an automated exploit generation approach in
the web application setting in this paper. That is, given an
application, the goal is to automatically construct a sequence
of malicious HTTP request inputs that direct an application’s
execution to a vulnerable sink. Given a web application’s
multi-module and multi-tier nature, the issues for automated
exploit generation are quite diﬀerent from those for binary
applications that are studied in [1, 15].

Our main contribution in this paper is an exploit gener-
ation technique that is able to ‘chain’ a sequence of HTTP
requests that, when issued in order, direct the execution of
the application to a vulnerable sink. Note that the sink may
be deeply nested in the module structure of an application
that could only be reached by supplying input sequences
starting from a publicly accessible module, and such paths
may frequently consult data stored in persistent storage.

The starting point for our approach is static analysis:
creation of models of the web application behavior along
its paths that is based on symbolic execution. From here,
there are two scalability challenges that must be overcome to
make exploit ﬁnding successful. The ﬁrst one involves path
selection: what are the paths that we must explore to make
opportunistic exploit generation successful? Our approach
makes the observation that it is possible to prioritize the
traversal of the paths by using their constraint solving costs,
such that we eﬃciently identify paths that lead to a successful
exploit.

641The second issue is about persistent database state: how
to deal with database queries that may be present along the
paths that are explored. This issue becomes particularly
important in the context of second-order attack creation,
where a vulnerable query, say, is exploited to store some
data that is subsequently read from a (second) exploit sink.
Our approach develops the use of both static and dynamic
techniques for dealing with persistent database state.

Our approach is implemented in a tool called Chainsaw,
and to the best of our knowledge it is the ﬁrst tool that
generates injection exploits that span several HTTP requests.
Chainsaw is built for the PHP language, but the concepts
behind it are general and are applicable to other web plat-
forms. Chainsaw leverages application workﬂow structures,
database schemas and precise modeling of PHP native func-
tions to achieve successful exploit detection, and is capable
of detecting second order exploits. Chainsaw was tested on
9 PHP web applications of diﬀerent complexities, generating
199 exploits, including 30 second-order exploits, and has
no false positives by design. A detailed comparison of re-
sults from related tools shows that Chainsaw is comparable
to, and in the most cases signiﬁcantly outperforms, other
state-of-art approaches.

This paper is organized as follows: Section 2 provides the
background, running example and the associated challenges
for exploit detection. We present a high-level overview of our
approach in Section 3, and a discussion of its implementation
in Section 4. We discuss our experiments and results in
Section 5. Related work is presented in Section 6 and we
conclude in Section 7.

2. BACKGROUND AND CHALLENGES

Assumptions and Goal. We assume the analysis sys-
tem has complete access to a web application’s source code.
In order to test exploits, we assume that the analysis system
also has a working installation of it, with appropriate login
credentials. It can test any generated inputs on the applica-
tion by sending requests to it and observing the results. The
goal is to construct a sequence of malicious HTTP requests
that navigate an application to a vulnerable sink in order to
perform SQLI or XSS attacks. These attacks are constructed
with the goal of exﬁltrating information from database, inject
malicious content in the database or obtain capability for
stealing client side content (e.g., cookies).
Problem Deﬁnition. An exploit is successful when a mali-
cious content is injected via a query to a database (SQLI)
or when it reaches echo-like statements that send content
(i.e. code) to a client (XSS). To trigger such behavior, the
malicious content must reach or inﬂuence execution at one
or more sensitive sinks along some path starting from the
input. In web applications, such paths to the sinks may span
several modules (sever-side scripts in PHP, similar to servlets
in Java) and the attacker may need to send malicious input
to all those modules.

The exploit generation problem can be formally stated as
follows: Given a web application, ﬁnd a sequence of pairs
((M1, IE1), (M2, IE2),..., (MN , IEN )), where each IEi is the
input that must be sent to the corresponding module Mi via
an HTTP request to exploit the vulnerable sink in MN .
2.1 Running example

We introduce an example of a chatroom application, which
will be used throughout the paper to illustrate our approach

15

16

17

18

4

5

6

7

(Listings 1-4). The example contains code snippets from
diﬀerent modules of the application, including several SQLI
and XSS vulnerabilities to illustrate the approach.

In particular, room.php starts by including a ﬁle with func-
tion deﬁnitions (line 1). Next, it retrieves user input (lines
4-11) and it sanitizes those inputs using two built-in func-
tions (lines 5, 12). Next, it builds a SQL query with the
sanitized version of the user input (line 15). Based on the
query results, the superglobal $_SESSION[‘room_name’] is set
(line 17) and the execution proceeds to dashboard.php via
the call to the header function (line 18). Superglobals are
built-in constructs in PHP that can be accessed from all the
modules. The module contains also a self redirection via the
HTML form (lines 21-22).

$room_name = $_POST[’room_name’];

header( "Location: ./login.php" );

$mode = htmlspecialchars($_GET[’mode’]) ;

1 include_once(’includes/function.php’);
2 if(!isset($_SESSION[’username’]))
3
4 if (isset($_GET[’mode’]))
5
6 if (isset($_POST[’room_name’]))
7
8 else $room_name = "";
9 if (isset($_POST[’category’]))
10
11 else $category = "";
12 $room_name = mysql_real_escape_string ($room_name);
13 if( isset( $mode ) ) {
14

$category = $_POST[’category’];

if( $mode == "enter" ) {

$result = mysql_query( "SELECT room_name FROM ROOM_TABLE WHERE

room_name=’$room_name’");

if (mysql_num_rows( $result ) == 1 ){
$_SESSION[’room_name’] = $room_name;
header( "Location: ./dashboard.php?mode=addcat&cat_desc=
$category");} ....}}

19
20 else{...
21 <form method="post" action="room.php?mode=enter">
22 ...<td><input type=’text’ name=’room_name’></td></tr>...
23 }

Listing 1: room.php (entry module): select the chatroom

header( "Location: ./login.php" );

1 if(!isset($_SESSION[’username’]))
2
3 if (isset($_GET[’mode’]))
4 $mode=$_GET[’mode’];
5 else $mode="";
6 if (isset($_GET[’cat_desc’]))
7 $cat_desc=$_GET[’cat_desc’];
8 else $cat_desc="";
9 if (isset($mode) && isset($_SESSION[’room_name’])) {
10 switch ($mode) {
11 case "addcat": header("Location: ./addcat.php?cat_desc=$cat_desc");
12 case "delcat": header("Location: ./delcat.php");
13 ...}}

Listing 2: module dashboard.php, dispatch execution to
diﬀerent functionalities (add category, delete category, etc)

1 if(!isset($_SESSION[’username’]))
2
3 else if (isset($_SESSION[’username’]) &&

header( "Location: ./login.php" );

isset($_SESSION[’room_name’])){

$room_name = $_SESSION[’room_name’]; // sanitized in room.php
$sql = "SELECT room_name, level FROM ROOM_TABLE WHERE

room_name=’$room_name’" ;

$result = mysql_query($sql);
$room_row = $db->sql_fetchrow($result);
$accesslevel = $room_row[’level’];

8
9 }
10 if ($accesslevel==1){
11

if (isset($_GET[’cat_desc’])) {

12

13

14

15

16

$cat_desc = htmlspecialchars($_GET[’cat_desc’]);
$sql = "SELECT cat_desc FROM CAT_TABLE WHERE

cat_desc=’$cat_desc’";
$result = mysql_query($sql);

} }......
//check if the category description exists.

642Listing 3: module addcat.php, retrieve a category description

header( "Location: ./login.php" );

1 if (!isset($_SESSION[’username’]))
2
3 else {
4

if (isset($_POST[’room_name’]))
$room_name = htmlspecialchars($_POST[’room_name’]);
else $room_name = "";
if (isset($_POST[’level’]))
$level = intval($_POST[’level’]);
if ($level==1 or $level==2) {

$sql = "INSERT INTO ROOM_TABLE (room_name, level) VALUES

(’$room_name’, ’$level’)";
$result = $db->sql_query($sql);

} ... }

5

6

7

8

9

10

11

12

sanitizations along paths to sensitive sinks and generate
exploits that are not prevented by those sanitizations.
Persistent Storage Eﬀect. The database state is another
important aspect that must be considered to automatically
build a working exploit. In fact, the values stored in the
database are additional inputs to the application that in-
ﬂuence its control and data paths during execution. For
instance, in the running example, the execution of the vul-
nerable query in line 13 in Listing 3 is dependent on the
value of $accesslevel, which is retrieved from the database
by a previous query. Therefore, we must be able to take
into account the control and data ﬂows that cross from the
application to the database and vice versa.

In the next section, we provide details of our approach,

Listing 4: module create.php, create a new chatroom

which addresses these challenges.

The code inside dashboard.php serves as a dispatcher to
several functionalities of the web application, such as adding
or deleting categories, creating chatrooms, and so on. Listing
3 shows a snippet from addcat.php, which checks if a category
exists before adding it. The code executes a ﬁrst query to
retrieve the room name and access level (lines 5-6), and next
a second query in line 13 if the $accesslevel value retrieved
by the ﬁrst query is equal to 1.

Note that the SQL query at line 13 in Listing 3 has a SQLI
vulnerability because htmlspecialchars does not escape the
single quote which leaves the query vulnerable to any attack
pattern that has a single quote such as 1’ OR ‘1’=‘1. The
other select queries (line 15 in Listing 1, line 5 in Listing 3)
contain no such vulnerabilities since their input is sanitized
by a stronger sanitization function (line 12 in Listing 1). The
last code snippet contains an insert query, which inserts
values of diﬀerent chatrooms in ROOM_TABLE. Note that this
query’s input is also insuﬃciently sanitized.
2.2 Exploit Generation Challenges
Complex Workﬂow. In general, the execution of vulner-
able queries depends on the application workﬂow, that is
on the sequence of visited modules and on the shared state
among those modules. In general, there can be several navi-
gation sequences in a web application. Some of them may
represent intended workﬂows where the sequence of module
execution follows the developers envisioned workﬂow, while
others may be unintended workﬂows where an attacker may
issue arbitrary requests and skip the execution of certain
modules from the intended sequence. Note that the intended
workﬂows may be exploitable too by changing values that
each module expects in input during a redirection. For in-
stance, in our running example, the execution of the vulnera-
ble query in module addcat.php depends on the execution of
module room.php, which sets the value of the PHP variable
$_SESSION[‘room_name’], which is checked in addcat.php
(line 1). To be able to generate non-trivial exploits, an
approach must take into account a wide range of possible
workﬂows both intended and unintended.
Data Sanitization and Path Sensitivity. To generate a
working exploit, the transformations and sanitizations of user
input along diﬀerent paths to the sinks must be precisely
modeled. For instance, even though the example contains
several queries, only two of them are vulnerable because of
insuﬃcient sanitization on some paths leading to them. For
example, the path going through line 6 in Listing 4 is not
vulnerable, while the path going through line 4 is vulnerable.
Our approach must therefore take into account the diﬀerent

3. APPROACH

In order to successfully generate exploits, we need to tackle
the challenge of scale: what are the paths that we must
explore to make opportunistic exploit generation successful?
Our approach makes the observation that it is possible to
rank the paths based on their constraint solving costs, and
proceeds to construct exploits starting from those that require
least analysis and solving complexity.

Our overall approach, as shown in Figure 1, is to gain
greater coverage in an initial analysis step and construct
working exploits in three subsequent steps. The ﬁrst step,
called Seed Generation, considers each module in isolation,
and builds a precise model of the computation on its inputs.
Speciﬁcally, the approach generates exploit seeds, which are
a veriﬁed set of inputs that direct the execution to a vul-
nerable sink inside a module. Seed generation is local to a
module and is guided by a detailed attack speciﬁcation and
database schema speciﬁcation In the subsequent stages of
the approach (i.e. Workﬂow Inference and Workﬂow Re-
ﬁnement), we use a conﬁned exploration strategy focused
at deriving a sequence of HTTP requests that navigates the
attacker along a sequence of modules to reach one of the ex-
ploit seeds generated in the prior step. This is done through
methods that selectively explore a subset of paths through
the application in order to generate exploits. In the next
subsections, we provide a detailed view of these steps.
3.1 Seed Generation

The goal of this phase is to identify sinks that are feasible
targets for exploits and to prune out sensitive sinks that
are not vulnerable. Speciﬁcally, an exploit seed is a pair
(S, I), where S denotes a sensitive sink that is vulnerable and
I = {(i1, v1), ...(in, vn)} is the set of variable-value pairs that
must be sent in input to the module containing S in order
to exploit S. The output of this phase is a list of exploit
seeds present in various modules of the application. Since
this phase represents only the starting point of our approach,
we keep its discussion brief.

For every sink inside a module, Chainsaw explores sym-
bolically all execution paths from sources (i.e. user input to
that module) to that sink (i.e. mysql query() and echo-like
functions) and, for each sink, it builds a symbolic sink ex-
pression and a symbolic formula FP . In the symbolic sink
expression, the data arguments are represented as program
constants or symbolic values computed from the operations
performed on variables used in the sink. In other words,
the symbolic execution constructs a symbolic expression for

643Figure 1: Approach Overview.

static (data arguments are constants) and dynamic sinks
(data arguments are variables).

The formula FP represents the (1) path conditions, (2)
input transformations along the paths to the sink and (3)
constraints arising out of the sink context. Finally, each
symbolic formula FP is joined with an attack speciﬁcation
FA, which contains constraints over the variable values at the
sinks. For instance, the symbolic formula FP related to the
sink at line 13 in Listing 3, and a possible attack speciﬁcation
FA are as follows:
FP : isset($ SESSION[‘username’]) ∧ isset($ SESSION[‘room name’])
∧ $room name==$ SESSION[‘room name’] ∧ $accesslevel== 1 ∧
isset($ GET[‘cat desc’]) ∧ $cat desc==htmlspecialchars($ GET[‘cat
desc’])
FA: $cat desc==”foo’ OR ’1’==’1”

Our analysis to obtain the symbolic sink and formula is
based on our past work [6]. It is inter-procedural, path sen-
sitive as well as context sensitive, based on performing inter-
procedural slicing of system dependency graphs (SDGs) [14].
For each sink, the corresponding SDG captures all program
statements that construct the queries (data dependencies)
and control ﬂows among these statements. We then compute
backward slices for sinks such that each slice represents a
unique control path from a source to the sink along with
path conditions. When this path contains statements in the
static-single-assignment (SSA) form (which is the ﬁrst step
in our analysis), constructing components (1) and (2) above
of the symbolic formula is straightforward (a discussion of
component (3) above appears in section 4.1).

One important detail to mention at this point is that any
PHP superglobal present in a module is left unconstrained in
this phase, making the analysis local to the module. These
superglobals may be constrained in this module, but may
be assigned values in other modules. For example, in mod-
ule room.php the superglobal $_SESSION[‘username’] is con-
strained, but is set in login.php. To make a successful exploit
out of an exploit seed, Chainsaw must ﬁnd a sequence of
module executions that produce appropriate assignments to
superglobals in order to direct the execution to the seed sink.
We explain this procedure in the next section.

3.2 Navigation Problem

This problem can be stated as follows: Given an exploit
seed in a module MN , is there an execution path along a
navigation sequence of modules (M1, ..., MN ) that satisﬁes
the constraints of the exploit seed? In the rest of the paper
we call such execution path that spans a navigation sequence
(M1, ..., MN ) global execution path. A global execution path
is essentially composed as a concatenation of local execution
paths belonging to each of the modules Mi. For instance, to
trigger an exploit in line 13 in addcat.php, a local execution

path from room.php must be executed ﬁrst, followed by a
local execution path from dashboard.php, which is ﬁnally
followed by the local execution path in addcat.php.

One of the main challenges of this problem, indeed the main
bottleneck for Chainsaw, is the number of global execution
paths that need to be considered for every exploit seed. This
number depends on the number of navigation sequences
that lead to the module containing that exploit seed and
on the number of local execution paths inside each module.
More speciﬁcally, given an exploit seed inside a module
MN , every navigation sequence (M1, ..., MN ), contains a
number of global execution paths equal to the product of
the numbers of local execution paths in each module. In
the worst case, these global paths must all be computed and
processed during the search. For this reason, to optimize
the search for feasible paths, Chainsaw eﬃciently ranks the
possible navigation sequences according to their number of
global execution paths, in an increasing order and chooses
the next possible navigation sequence based on this order.
The intuition behind this choice is to be able to process as
many navigation sequences as possible per unit of time.

Speciﬁcally, Chainsaw ﬁrst builds a navigation graph
called General Workﬂow Graph (GWFG), which represents
all possible navigation sequences and derives the ranking of
the navigation sequences from this graph. Next, for each
navigation sequence, Chainsaw builds a Reﬁned Workﬂow
Graph (RWFG) whose goal is to enable the search for global
execution paths that satisfy the exploit seed. We explain the
two steps below.

3.2.1 Workﬂow Inference
The General Workﬂow Graph (GWFG) is a weighted di-
graph G = (V, E) where each vertex v ∈ V represents a
module of the web application and each edge e = (vi, vk) ∈ E
represents a navigation from vi to vk. The weight on each
edge e = (vi, vk) represents the cost (as the increase in the
number of global execution paths) incurred by Chainsaw
if it were to explore that edge in the navigation sequence.
Speciﬁcally, to build a list of navigation sequences ranked by
the number of global execution paths, we use the k shortest
paths algorithm [11] on the GWFG, which, given a weighted
digraph ﬁnds the k shortest paths between two nodes ranked
by path cost. To reconcile the k shortest paths algorithm
cost deﬁnition as the sum of the weights along the edges
with the Chainsaw’ s cost deﬁnition as the product of the
execution paths along the edges, in the GWFG we assign to
each edge e = (vi, vk) a weight equal to log2(nk), where nk
is the number of execution paths in vk.

For instance, in Figure 2, which represents our example
(with one additional module: check.php), there are two navi-
gation sequences between room.php and create.php, one via
dashboard.php with a total cost of 10 (= 210 = 1024 global

SolverSeed GenerationExploit SeedWorkﬂow InferenceWorkﬂow ReﬁnementNavigationSequencesLocal PathConstraintsSolverWorking ExploitsGlobal Path ConstraintsDB DataAttack Spec.Application644collects a set of preconditions for every vertex vj. This
set contains the conditions that are checked along the path
represented by vj. Using these two sets, Chainsaw does not
connect vi and vj if there are inconsistencies between the
path summary of vi and the preconditions of vj. When we
cannot determine any inconsistencies, we connect the two
vertices. As an example, the table in Figure 3 shows the
summaries and preconditions of one possible global execution
path that leads to the vulnerable sink in addcat.php.

For every global execution path that leads to an exploit
sink, Chainsaw creates a symbolic formula that represents
the computations and conditions along that global path.
Next, it adds the constraints of the attack speciﬁcation to
this symbolic formula using the context of the exploit seed
(See section 4.1 for details on context awareness), and uses
the solver to look for a solution. The solver solution, if found,
contains the values to all local and superglobal variables that
need to be sent to every module in the navigation sequence
in order to reach the exploit seed.

3.3 Second Order Exploits

The backend database of a web application is an important
component that contains a large portion of that application’s
state. Such state often drives the control and data ﬂow
inside the application. When creating the symbolic formulas,
Chainsaw includes the state of the database by adding
constraints representing the database values. The main
challenge in dealing with the database state is that it is always
evolving, thus exploits may become feasible or unfeasible
depending on it.

In addition, the database can be used as a channel in second
order attacks, such as second-order SQLI and stored XSS.
In these attacks, speciﬁc content is entered in the database
using a SQL sensitive sink with the goal of reaching a second
sensitive sink after it is retrieved from the database. This
second sink can be another SQL query sink or an XSS sink.
One of the main strengths of Chainsaw is its ability to
precisely model the database state. This capability enables
a more precise generation of ﬁrst and second-order exploits.
We describe the techniques used by Chainsaw next.
Static Input Generation. Often, the feasibility of an
exploit at a sensitive sink relies on conditions along the path
to that sink that depend on the database state. For instance,
the execution of the query in line 13 of Listing 3 depends on
the value of the PHP variable $accesslevel, which in turn is
retrieved from the database by the query in Line 5. Clearly,
if the database does not contain a value equal to 1 for the
room level, then execution will not proceed further.

To ensure that the generated exploits are feasible, Chain-
saw generates new values for the database, when needed.
More speciﬁcally, Chainsaw ﬁrst builds (during analysis) a
mapping between writes to a database (insert and update
queries) and the select queries that read from the same
table. Using this mapping, Chainsaw identiﬁes the write
statement that can be used to insert the needed values in
the database. For instance, the insert query that inserts
the value of the column level, is in Listing 4.

As a next step, Chainsaw constructs inputs that will take
the application to insert the desired value in the database.
More speciﬁcally: (i) it sets that write operation as a sink and
derives the formula FP relative to that sink, (ii) a constraint
formula FD that represents the desired value to insert, and
(iii) sends the formula FP ∧ FD to the solver. In our example,

Figure 2: A simpliﬁed version of the running example General
Workﬂow Graph. For simplicity, some modules are not shown
such as delcat.php.

execution paths), and one via check.php with a total cost of
12 (212 = 4096 global execution paths). Therefore Chainsaw
processes the former ﬁrst, since it has a smaller number of
global execution paths.

The GWFG is constructed by identifying statements in
the code responsible for navigation (e.g. HTML forms, links,
PHP redirection, etc.) and their targets, and adding ver-
tices and edges to the graph correspondingly. In short, the
GWFG represents all possible navigation sequences in the
application.

The output of the workﬂow inference module is a set of
navigation sequences ranked by the total number of possi-
ble global execution paths. The next phase processes each
sequence to ﬁnd the global execution paths that satisfy the
constraints of the exploit seed.
3.2.2 Reﬁned Workﬂow Graph
Once a navigation sequence (M1,...,MN ) is selected, the
next task of Chainsaw is to ﬁnd a global execution path
inside that sequence that leads to an exploit seed. We note
that this global execution path is composed as the concate-
nation of execution paths inside each of the modules in the
navigation sequence.

To extract the global execution paths, Chainsaw builds
a reﬁned workﬂow graph (RWFG) for every navigation se-
quence. The RWFG is a directed graph G = (V, E) where
each vertex represents a local execution path from one of the
modules in the sequence and each edge e = (vi, vj) ∈ E rep-
resents a transition from one local execution path to another,
that is the fact that the execution path vj (in module Mj)
follows the execution path vi (in module Mi). Thus, a global
execution path corresponds to a path on the RWFG.

An instance of the RWFG, representing the navigation
sequence (room.php, dashboard.php, addcat.php), is shown
in the left half of Figure 3. In this ﬁgure, every module is
represented by a set of nodes, where each node represents a
local execution path (for space constraints we do not show
all local execution paths). A global execution path for this
sequence is represented by the RWFG path (L2, A3, D2).

As mentioned before, the number of global execution paths
that needs to be considered for every exploit seed is the
main bottleneck of Chainsaw. We can reduce this number
signiﬁcantly by removing from the RWFG those edges that
are clearly unfeasible. In other words, if we can show that a
local execution path Ai in a module cannot follow another
local execution path Li in another module, then we can
remove the corresponding edge from the RWFG. To do this,
Chainsaw ﬁrst builds a path summary for every vertex vi of
the RWFG. This summary includes the assignments to the
superglobals in the path represented by vi. Next, Chainsaw

    room.php functions.php include dashboard.php redirect form redirect redirect redirect create.php check.php redirect redirect link addcat.php 8 4 4 7 7 7 4 6 dashboard.php addcat.php redirect room.php redirect form L1 L2  D2 redirect A2 A1 A3  D1 Node Preconditions Summary   L2 1.isset($_GET[‘mode’])(cid:154) 2.isset($_SESSION[‘username’] (cid:154) 3.isset($_POST[‘room_name’]) (cid:154) 4.isset($_POST[‘category’]) (cid:154) 5.isset($mode) (cid:154) $mode==”enter”   $_SESSION[‘room_name’]    A3 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION  [‘room_name’])  (cid:154) 3.isset($_GET[‘mode’])  (cid:154) 4.isset($_GET[‘cat_desc’])  (cid:154) 5.isset($mode) (cid:154) $mode==”addcat” (cid:135)    D2 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION  [‘room_name’]) (cid:154) 3.isset($_GET[‘cat_desc’]) (cid:154) 4.$accesslevel==1 (cid:135)     645Figure 3: A Simpliﬁed Reﬁned Workﬂow Graph for the running example (on the left). The table (on the right) shows the
preconditions and the summary of the global execution path (nodes: L2, A3 and D2) to the vulnerable sink in addcat.php

we ask the solver to provide the input values needed, in order
to have the value 1 for the variable $level in the insert
query in line 10 of Listing 4.

For generating second order exploits, the procedure is
similar. Note that, for a second order exploit, there are
generally two sensitive sinks of interest. The ﬁrst sink is a
write query, which inserts a payload in the database. The
second sink is another query or statement, which uses the
payload data without proper sanitization (e.g., in a second-
order SQLI, or a stored XSS). For second order exploit
generation, the small addition from the above procedure
is that, Chainsaw uses an attack speciﬁcation FA that is
suitable to generate an exploit at the second sink.
Dynamic Auditing. In addition to static input generation,
which inserts data in the database, Chainsaw is also able to
use existing database data of a live system by including con-
straints arising from the its state in the symbolic execution.
We call this capability dynamic auditing. More speciﬁcally,
Chainsaw augments the symbolic formulas in three steps:
(1) DB-PHP mapping: by analyzing the symbolic query a
mapping is created between PHP variables and column names
of the corresponding table. In some cases these mappings
can be inferred directly from the WHERE clause construc-
tion, which concatenates a database column name with a
PHP variable name (e.g., WHERE room_name=‘$room_name’ in
room.php), while in other cases these mappings can be in-
ferred from the code that processes the query’s result set
(e.g., the PHP variable $room_row[’level’] is mapped to
the database column level in addcat.php). (2) Data re-
trieval: once a mapping is created, the query is modiﬁed by
removing the WHERE clause and by running a (Select *) query
over the same table. This ensures that all possible values
are retrieved from the database. (3) Constraints creation: a
new term TD is added to the current path formula FP repre-
senting the constraints on the PHP variable values derived
from the database.

To illustrate the above procedure, let us consider the query
in Listing 3: SELECT room_name,level FROM ROOM_TABLE WHE-
RE room_name=‘$room_name’. Suppose that ROOM_TABLE has
the following records for the attributes (level, room name):
(1, room1) and (2, room2).
In this case, we obtain the
following terms:
TD = C1 ∨ C2 where
C1 = $room row[(cid:48)level(cid:48)] == 1 ∧ $room name == ”room1”
C2 = $room row[(cid:48)level(cid:48)] == 2∧ $room name == ”room2”
Static Input Generation vs. Dynamic Auditing.

While the static input generation is a general technique, it
may create a large overhead. Consider, for instance, the
common problem of generating inputs for an insert query
Q1 in order to generate one feasible exploit for each query Qi
in a set, each dependent on Q1. With static input generation,
the input generation procedure (that is, path exploration,
symbolic evaluation, and constraint solving), for Q1 must
be repeated for as many times as the number of the Qi-
s, while with dynamic auditing, such input generation is
not needed, since the data can be directly retrieved from
the database. Metaphorically speaking, dynamic auditing is
similar to memorization, where results from previous compu-
tations are cached and reused when needed. The drawback
of dynamic auditing, however, is that the obtained exploits
are feasible only for a particular database instance.

For applications with databases that are initially popu-
lated from the code (e.g., a series of insert queries) rather
than from external data entry procedures, static input gener-
ation has visibility into the tuples that are inserted and can
generate the corresponding constraints. Therefore, for these
applications, the results obtained from dynamic auditing are
equivalent to those from static input generation with the
advantage of smaller overhead.

4.

IMPLEMENTATION

Our implementation is written on top of Pixy [18] and
TAPS [6] for source code analysis and Z3 [10] for constraint
solving. The input to Chainsaw is a web application source,
its database schema and the attack speciﬁcations. The output
is a set of HTTP requests that will exploit vulnerable sinks.
4.1 Context Awareness
Symbolic Parsers. Chainsaw symbolically evaluates each
path from a source to a sensitive sink (SQL or XSS) and
generates a symbolic expression by representing the sink
parameters as symbolic values. When it encounters loops,
Chainsaw symbolically executes them 0, 1 or 2 times.

To be able to derive the context of the user input in
these symbolic expressions, we implement two additional
(symbolic) parsers on top of the SQL and HTML parsers.
Our two parsers are able to create the abstract syntax trees
of the symbolic expressions and use those trees to derive the
context of the user input. For instance, the analysis identiﬁes
the context of the variables used in the sink by determining
whether each variable is single-, double-, or unquoted. As
another example, if the symbolic sink is a select query and
the user input is used in the WHERE clause, the parser is able

                 dashboard.php addcat.php redirect room.php redirect form L1 L2  D2 redirect A2 A1 A3  D1 Node Preconditions Summary   L2 1.isset($_GET[‘mode’])(cid:154) 2.isset($_SESSION[‘username’] (cid:154) 3.isset($_POST[‘room_name’]) (cid:154) 4.isset($_POST[‘category’]) (cid:154) 5.isset($mode) (cid:154) $mode==”enter”   $_SESSION[‘room_name’]    A3 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION [‘room_name’]) (cid:154) 3.isset($_GET[‘mode’]) (cid:154) 4.isset($_GET[‘cat_desc’]) (cid:154) 5.isset($mode) (cid:154) $mode==”addcat” (cid:135)    D2 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION [‘room_name’]) (cid:154) 3.isset($_GET[‘cat_desc’]) (cid:154) 4.$accesslevel==1 (cid:135)     646to derive the parsing context of user input. Subsequently, this
context is used to guide the expansion of the formula FA with,
say, a constraints expressing a tautology SQLI. In addition,
it is worth pointing out that, since Chainsaw automatically
includes the semantics of the sanitization functions when
creating the symbolic formula, it is sanitization-aware.
Context-awareness example. To see the relevance of the
context-awareness, let us consider Listing 5 for an XSS attack
scenario.

1 echo "<p> here is the user input $input’’</p>;
2 echo "<p style=’\$color\’>This is a paragraph.</p>’’;

Listing 5: Examples on context awareness in XSS.

For line 1 in Listing 5, the context of the variable $input
is: unquoted, paragraph, and any attack string such as
"<script>alert(’xss’)</script>" will trigger the attack. In
line 2, however, the user input $color is the value of an at-
tribute. Therefore, in the attack string, the quote and tag en-
closing character (>) must ﬁrst be closed and then followed by
the XSS payload (e.g.,"’><script>alert(’xss’)</script>
"). The symbolic parsers used in Chainsaw are able to
infer these diﬀerent contexts and guide the construction of
the ﬁnal formula that is sent to the solver.
4.2 Analysis of Navigation Structure
General workﬂow graph construction. To construct
the GWFG of an application, our approach uses an HTML
parser as well as the generated CFG for each module to
extract workﬂow inference features: HTTP links, forms,
meta tags, iframes and PHP redirection functions. After
the extraction, Chainsaw creates two nodes that represent
the source and destination modules of the workﬂow feature.
Since our analysis is inter-procedural, and context-sensitive
data and control ﬂow analysis, variables in workﬂow function
arguments can be resolved by consulting the data depen-
dence graph generated for each workﬂow function. While
the GWFG is constructed from HTML and PHP features,
our extraction technique can be applied to languages with
similar functions.
Informed traversal of the GWFG. The main challenge
in traversing the RWFG is to intelligently decide which
path to take.
In our implementation, we use the notion
of summary history, which is a mechanism to ‘remember’
the traversal history and to use it as a guide to search for
the next compatible node (execution path). In particular,
for each edge traversal from a node vi to a node vj, the
summary of vi is added to the summary history (initially
empty). Intuitively, the summary history of a path on the
RFWG is the collection of all the summaries of the nodes of
that path.

A concrete example where we use such summaries is based
on Figure 3. The vulnerable query is in two execution paths
D1 and D2. If the search starts at L2, then there are two
possible nodes to traverse next: A2 and A3. Our search
technique, chooses A3 over A2 because the summary history
at L2 satisﬁes the preconditions of A3. Next, the search
adds the summary of L2 and A3 to the summary history to
further guide the search of the next node. After reaching A3,
the search checks all A3 ’s outgoing edges (D1 and D2 ) and
repeats the same heuristics until it reaches the vulnerable
sink in D2.

This search technique signiﬁcantly reduces the number
of edges in the RWFG by keeping only the feasible path

transitions. In turn, this improves the eﬃciency of the gen-
eration of working exploits for deeply located exploit seeds
in a global execution path.
4.3 Database Schema Analysis

In static analysis, modeling data ﬂows that cross persistent
storage is not trivial due to the absence of database con-
straints in the source code. To this end, Chainsaw analyzes
the database schema to capture the additional constraints
imposed by the database. Speciﬁcally, tables names and
columns deﬁnitions such as their names, types and values
constraints (e.g., NOT NULL and length) are retrieved.

As an example, Listing 6 shows an insert query, which
seems vulnerable. However, if columns var1 and var2 in table
TBL are of type enum{1, 2}, then that query is no longer
exploitable because the database will not accept any other
values. Chainsaw captures such database constraints (e.g.,
($v1==1 ∨ $v1==2) and ($v2==1 ∨ $v2==2)) and adds them
to PHP variables used in an insert or update query. Our
database schema analysis is capable of analyzing a variety of
SQL-based database schemas (e.g., MS SQL, MySQL, Oracle,
etc.).

1 $v1= $_GET[’v1’];
2 $v2= $_GET[’v2’];
3 mysql_query(INSERT INTO TBL (var1, var2) VALUES ($v1, $v2));

Listing 6: Example that demonstrates the need for
considering database constraints on PHP variables.

Another source of database constraints occur due to stored
procedures. To analyze these, we need to statically analyze
the stored procedure to extract constraints. Our implemen-
tation currently does not have this support. However, none
of our evaluated applications make use of stored procedures.
4.4 Constraint Solving

To generate exploit seeds and the ﬁnal working exploits,
Chainsaw uses the Z3 SMT [10] solver and its plug-in Z3-
str [30]. For each global execution path, Chainsaw prepro-
cesses the path information to facilitate the translation to
solver speciﬁcations. To do so, we take advantage of the gen-
erated Three-Address-Code (TAC) representation of source
code during the CFG construction. Each TAC statement is
then encoded as a formula.
Notes on Translation Our tool recognizes and translates
binary and unary PHP expressions, built-in PHP functions,
and conditional statements. Our approach models the se-
mantics of the 70 most used PHP built-in functions. The
support for several string operations in Z3 is coarse, so we
have augmented these with our own Z3 speciﬁcations to
model built-in functions and to infer data types.

As an example, Listing 7 shows a translation of the PHP
statement $cat_desc=htmlspecialchars($_GET[’cat_desc’])
in Z3 performed by Chainsaw. This function replaces cer-
tain characters (e.g., single quotes, ampersands) with their
HTML entity encodings. To model this function using the
solver language, we use the Z3-str Replace function. Since
this function replaces only the ﬁrst occurrence of a substring,
Chainsaw replicates the code shown in Listing 7 for each
occurrence of a special character.

1 (assert (= temp_0 (Replace $_GET[’cat_desc’] "&" "&amp;")))
2 (assert (= temp_1 (Replace temp_0 "\"" "&quot;")))
3 (assert (= temp_2 (Replace temp_1 "<" "&lt;")))
4 (assert (= $cat_desc (Replace temp_2 ">" "&gt;")))

647Listing 7: Z3 speciﬁcations that model the semantic of
htmlspecialchars PHP built-in function

5. EVALUATION
Subject Applications. We evaluated Chainsaw on the
9 PHP applications shown in Table 1. The applications
are of varying complexity, with SLOC ranging from 323 to
65302. Our dataset covers all test subjects used in two close
works to Chainsaw, namely Ardilla [19] and CraxWeb [16].
In addition, our dataset covers test subjects from multiple
related works (e.g., 2 from [9], 1 from [8], 1 from [26], and 1
from [3]).

Application

myBloggie (2.1.4)
scarf beta
DNScript
WeBid (0.5.4)
Eve(1.0)
schoolmate (1.5.4)
geccbblite (0.1)
faqforge (1.3.2)
webchess (0.9)

PHP
Files

56
19
60
300

8
63
11
17
29

PHP
SLOC

9090
978
1322
65302

905

15375

323
1676
5219

SQL
Queries

59
20
73
616
41
400
23
54
134

DB
Tables

4
7
7
63
2
15
1
2
7

XSS
Sinks

160
251
334
450
102
559
40
35
504

Table 1: Subject applications of our evaluation.

Setup. Chainsaw was deployed on Ubuntu 12.04 LTS VM
with 2-cores of 2.4GHz each and 40GB RAM. For each appli-
cation, we ﬁrst ran the seed generation and then the exploit
generation step. We automatically veriﬁed each exploit seed
and each working exploit to ensure they reach the sink, and
manually conﬁrmed each exploit to ensure the exploit had
the desired eﬀect. We also measured the run time of Chain-
saw. For these applications, the dynamic auditing mode
is equivalent to the static input generation mode, and the
former was used for eﬃciency.
5.1 Overview of Results

Table 2 shows the summary of our results. On the 9 subject
applications, Chainsaw identiﬁed a total of 181 exploit seeds
and a total of 199 working exploits with no false positives.
While 149 (75%) of the working exploits are SQLI exploits,
50 (25%) are XSS exploits. Of all the working exploits, 30
(15%) are second-order exploits. 13 of the 30 second-order
exploits are second-order SQLI exploits and the remaining
17/30 are stored XSS exploits. We outperform most related
approaches in the precision and coverage of vulnerability
detection (Section 5.6).
5.2 Selected First-Order Exploits

For webchess, Chainsaw generated multiple SQLI and
XSS exploits located in diﬀerent modules. One of these
is the SQLI exploit generated for the vulnerable query in
viewmessage.php (see Listing 8). This exploit allows the
attacker to view the communication messages of other users.
The global navigation sequence for this exploit is as follows:

The number of generated constraints is 203 with exploit
generation time of 156 sec. The exploit string is shown
in Listing 21 in the Appendix. Note, for demonstration
purposes, we represent all exploits as GET requests.

1 if(isset($_POST[’messageID’]))
2

{$messageID = $_POST[’messageID’]; //no sanitization
$SqlQuery="SELECT * FROM communication WHERE commID=$messageID";}

3

Listing 8: Vulnerable query in viewmessage.php of Webchess.

In Addcat2.php (see Listing 9) of the DNScript applica-
tion, an attacker can insert a malicious domain name to
the database. AddCat2.php does not apply sanitization on
the user input before using it in the query. The navigation
sequence is as follows:

Chainsaw generated 2 exploits for this query. The ﬁrst
exploit follows the intended workﬂow and has a path length
of 4. The number of constraints collected from the ﬁve
modules is 27. Due to the presence of a CAPTCHA in
login.php, to generate a working exploit, we made very
minimal changes to the source code so that it generates a
valid CAPTCHA string. The other exploit generated by
Chainsaw for the same query follows a shorter programmer
unintended workﬂow path which hits AddCat2.php (a publicly
accessible page) with exploit path length equals to 1 and 3
constraints. As we noted before, while most exploit paths
follow the intended workﬂow of an application, an equally
feasible exploit can be generated by breaking the workﬂow. In
this particular context, the alternative exploit path requires
visiting 1 module (compared to 4 modules).

1 $values = ’VALUES ("’.$_POST[’cat_name’].’")’; //no sanitization
2 $insert = mysql_query("INSERT INTO gen_cat (cat_name) " .$values);

Listing 9: AddCat2.php in DNScript.

1 http://host/DNScript/AddCat2.php?cat_name=1’ OR ’1’=’1

Listing 10: Exploit for the query at line 2 in Listing 9.

For EVE, Chainsaw generated 5 SQLI in two modules:
Case 1: In edit.php, Chainsaw generated an SQLI exploit
that has a path length of 1 (edit.php is public) and the
number of constraints is 40. This exploit enables retrieving
other members’ information. Listing 11 (line 2) shows the
vulnerable query and the generated exploit (line 3).

1 $member = $_GET[’id’]; //no sanitization
2 mysql_query("SELECT MemberID, Name, Division, DateJoined, RankCorp,

Vacation, Comment, Deleted FROM MembersMain WHERE MemberID=
’".$member."’";

3 http://host/eveactive/edit.php?id=1’ OR ’1’=’1

Listing 11: Exploit for the query at line 2 in edit.php.

Case 2: In member.php, Chainsaw generated 4 SQLI ex-
ploits, all on update queries (see sample in Listing 12) in
which the attacker can inject a malicious payload in $comment
and $name. Other variables used in the queries are safe be-
cause the other columns in the MembersMain table are either
integers or of date data type. Chainsaw adds the type of
the columns associated with each variable used in a query
to the set of the constraints extracted for the source code as
discussed in Section 4.3. All 4 exploits have the following
navigation sequence:

WebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!index.phpmainmenu.phpformviewmessage.phpformWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!Login.phpDoLogin.phpformindex.phpheaderinc/nav.phpincludeAddCat2.phplinkWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!add.phpmember.phpform648Application

SQLI
Seeds

1st Order
SQLI Exploits

XSS
Seeds

1st Order
XSS Exploits

2nd order
SQLI Exploits

2nd order
XSS Exploits

Total
Exploits

myBloggie

scarf

DNScript

WeBid

Eve

schoolmate
geccbblite
faqforge
webchess

Total

24
0
4
42
5
51
3
4
15
148

21
0
1
40
5
49
3
4
13
136

1
1
1
7
2
5
0
4
12
33

1
1
1
7
2
5
0
4
12
33

7
0
0
0
0
0
3
0
3
13

0
1
3
0
2
2
4
2
3
17

29
2
5
47
9
56
10
10
31
199

Table 2: Summary of results for automatic exploit generation.

1 $name = $_POST["name"]; //no sanitization
2 $comment = $_POST["comment"];//no sanitization
3 ....
4 mysql_query ("UPDATE MembersMain SET Name = ’".$name."’, Division =

’".$division."’, RankCorp = ’".$rankcorp."’, Vacation =
’".$vacation."’, Comment = ’".$comment."’, Deleted =
’".$deleted."’ WHERE MemberID = ’".$memberid."’");

Listing 12: Vulnerable query in member.php, EVE.

Chainsaw also generated two XSS exploits for member.php.
Listing 13 shows the vulnerable sink (corresponding exploit
string is shown in Listing 22 in the appendix.

1 $nname = $_GET["nname"]; //no XSS sanitization
2 echo "<font color=\"#00FF00\">User <a href=\"evemail:".$nname.\">";

Listing 13: Vulnerable XSS sink in member.php, EVE.

5.3 Selected Second-Order Exploits

For myBloggie, Chainsaw generated 7 second-order SQLI
exploits. One of these exploits is demonstrated in listings
14 and 15. The ﬁrst step exploits the vulnerable insert
query in adduser.php (Listing 14) where $user is not suﬃ-
ciently sanitized for SQLI vulnerabilities. The second step
retrieves user data from USER_TBL without sanitization (see
Listing 15). Without our comprehensive modeling of PHP
functions, constraints that include calls to isset, intval,
md5 and htmlspecialchars would not captured correctly and
that could result in false positive or negative. The number
of generated constraints is 250 with exploit generation time
of 174 sec. The exploit string for this sequence is shown in
Listing 23 in the Appendix. The navigation to reach and
execute the queries in Listings 14 and 15 are as follows:

$user=htmlspecialchars($_POST[’user’]);//insufficient sanitization

1 if (isset($_POST[’user’]))
2
3 $password = $_POST[’password’];
4 $repassword = $_POST[’repassword’];
5 $level = intval($_POST[’level’]); //strong sanitization
6 $password = md5(trim($password)); //strong sanitization
7 if ($level==1 or $level==2) {
8

$sql = "INSERT INTO ".USER_TBL." SET user=’$user’,

password=’$password’, level=’$level’";

9

$result = $db->sql_query($sql); }

Listing 14: Step 1 (insert) in adduser.php.

1 $sql = "SELECT * FROM ".USER_TBL." WHERE id=’$id’";

Listing 15: Step 2 (select) in edituser.php, myBloggie.

For geccBBlite Chainsaw generated 7 second-order ex-
ploits in the modules scrivi.php and rispondi.php. The
following discusses one stored XSS exploit, as the other ex-
ploits are similar to this one. Listing 16 shows the ﬁrst step of
this exploit where the malicious XSS payload is written to the
database without suﬃcient sanitization for $titolo variable.
The second step occurred in leggi.php where all messages
stored in the geccBB_forum table are retrieved and rendered
to users without sanitization as in Listing 17. This exploit
has a navigation length of 2 (rispondi.php and leggi.php).
The number of generated constraints is 40 with exploit gen-
eration time of 13 sec. The corresponding exploit string is
shown in Listing 24 in the Appendix.

1 $titolo=$_POST[titolo];...
2 $query_ins_risposta="INSERT INTO geccBB_forum VALUES (’’,

’$postatoda’,’$data’,’$titolo’,’$testonuovo’,’$rispostadel’)";

3 $r=mysql_query($query_ins_risposta);

Listing 16: Step 1 (insert) in rispondi.php.

1 $rd=$_GET[rd];
2 if($rd)
3

$query_caga_messaggio="SELECT * FROM geccBB_forum WHERE id=$rd";
...
echo "re: " . $leggi[titolo];

4

5

Listing 17: Step 2 (select and then echo) in leggi.php.

On Schoolmate, our tool generated 2 stored XSS exploits.
Listings 18 and 19 show one of these exploits. In the ﬁrst
step, the attacker can execute the update query without any
authentication or authorization. The application receives
the attacker’s input and stores it in schoolinfo table in
which two columns schoolname and sitetext are of type
varchar (i.e., allows malicious characters if no sanitization
applied in the source code). In the second step, the malicious
payload is executed when any user of the site visits login.php.
This exploit has a navigation length of 2 (header.php and
login.php). The number of generated constraints is 150 with
exploit generation time of 98 sec. The exploit string is shown
in Listing 25 in the Appendix.

or die("Unable to retrieve school name: " . mysql_error());

1 $query = mysql_query("select schoolname from schoolinfo")
2
3 $schoolname = mysql_result($query,0);
4 if($_POST["infoupdate"] == 1)
5

$query = mysql_query("UPDATE schoolinfo SET schoolname=

".htmlspecialchars($_POST["schoolname"]).",address=
’$_POST[schooladdress]’, phonenumber=
’$_POST[schoolphone]’,sitetext=’$_POST[sitetext]’,
sitemessage= ’$_POST[sitemessage]’, numsemesters=
’$_POST[numsemesters]’, numperiods= ’$_POST[numperiods]’,
apoint= ’$_POST[apoint]’,bpoint= ’$_POST[bpoint]’,cpoint=
’$_POST[cpoint]’,dpoint= ’$_POST[dpoint]’,fpoint=
’$_POST[fpoint]’ where schoolname = ’$schoolname’ LIMIT 1");

Listing 18: Step 1 (update) in header.php.

1 $query = mysql_query("select sitetext from schoolinfo");

WebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!login.phpadmin.phpformadduser.phpincludeWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!login.phpadmin.phpformedituser.phpinclude6492 $text = mysql_result($query,0);
3 print("... <div class=’messagebox’>$text </div> ...);

Listing 19: Step 2 (select and print) in login.php.

5.4 Effect of Database Schema Analysis

Table 3 shows the contribution of the database schema
analysis we implemented in Chainsaw. Overall, Chainsaw
reduced the false positive rate on exploit seed generation by
an average of 16% per application on 8 of the 9 applications
in our dataset. For WeBid, Chainsaw’s DB-schema analysis
reduced the false positive rate on SQLI seed generation by
nearly 60%. Note that for Scarf the entries are zero because
we have not found SQLI seeds for it.

App.

Without Schema With Schema Conﬁrmed

myBloggie
scarf beta
DNScript

WeBid

Eve

schoolmate
geccbblite
faqforge
webchess

24
0
4
99
6
60
3
4
28

24
0
4
40
5
51
3
4
15

21
0
1
40
5
49
3
4
15

Table 3: Eﬀect of DB schema analysis on SQLI seed exploits

5.5 Overhead and Analysis Complexity

Table 4 summarizes the runtime overhead of Chainsaw
for exploit generation. The analysis time ranges from 10
to 600 minutes. For small applications such as geccbblite,
solving the ﬁnal exploit formula took less than a minute
while in big applications such as WeBid it took about 42
minutes. Generally, the increase in the number of possible
execution paths in each module and number of modules in
each application increases the analysis time. The maximum
length of navigation sequences traversed by the generated
exploits ranges from 2 to 5 modules. Note that for Webid,
schoolmate, and webchess, the analysis time and solving time
are exceptionally long because Chainsaw has to traverse
1.09 million, 1.93 million, and 1.5 million execution paths
respectively. For each execution path, our system has to
compute the symbolic formula and invoke the solver —thus
contributing to the analysis and solving overheads.

Analysis
Time
(m)

Solving
Time
(m)

Expl.
Gen.
Time
(m)

Max. Len. of
Nav. Seq.

Application

myBloggie

scarf

DNScript

WeBid

Eve

schoolmate
geccbblite
faqforge
webchess

125
10
20
600
19
400
10
20
136

95
39
120
345

5

159
10
8

120

20
2
4
42
3
23
<1
3
14

3
2
2
5
2
4
2
2
3

Table 4: Runtime summary of Chainsaw. Analysis Time:
total time before invoking solver. Solving Time: total
time to solve all SMT formulas (including unsatisﬁable ones).
Expl. Gen. Time: total time for solving satisﬁable SMT
formulas that represent exploits. Max. Len. of Nav.
Seq.: maximum length of navigation sequences for exploits.

5.6 Comparison with Related Work

Note that one-to-one comparison of Chainsaw with prior
work is not easy due to (i) absence of working tools for some

prior work (ii) outdated test subjects and (iii) lack of clarity
on how results are counted. Nevertheless, wherever we could
ﬁnd a common ground (e.g., common subject applications,
same attack types), we compare Chainsaw with prior work.
Regarding seed generation, we compare seeds generated by
Chainsaw with vulnerabilities reported in [8], [9], and [26].
On the exploit generation front, we compare Chainsaw
with [19] and [16] since both of their datasets are subsumed
by the test subjects in Chainsaw. Tables 5 and 6 show
the summary of Chainsaw’s comparison with these works.
Note that diﬀerent from some of these works, we count the
number of seeds based on the number of unique sinks not
per path. For instance, for n vulnerable paths leading to a
sink, Chainsaw reports only one seed for this sink.
Seed generation: Wassermann and Su [26] identiﬁed 5
SQLI vulnerabilities in EVE whereas Chainsaw generated 7
SQLI exploit seeds, all of which have been transformed into
working exploits. RIPS [8] identiﬁed 8 SQLI vulnerabilities
in myBloggie while Chainsaw generated 24 SQLI exploit
seeds (3 times more exploits than RIPS ) since it performs
path-sensitive analysis, which in RIPS is not available.
Exploit generation: Ardilla [19] generated 60 attacks (23
SQLI and 37 XSS) on a dataset of 5 applications (see Table
5). On the same dataset, Chainsaw generated 116 (56
more) working exploits, which shows that Chainsaw has
better coverage. For XSS exploits, Chainsaw generated 36
working exploits while Ardilla generated 37. On SQLI exploit
generation, Chainsaw outperforms Ardilla by 47 more as
it generated 80 exploits compared to 33 in Ardilla. The
reason behind 1 less XSS exploit in Chainsaw with respect
to Ardilla is traced to one case in the schoolmate.

For the code snippet in Listing 20 from schoolmate, Ardilla
generated an exploit for the print sink whereas Chainsaw
ﬂagged it as unfeasible because of the presence of the query
at line 1. This query needs to return some records that
satisfy the where clause or the execution of the module is
terminated and never reaches the print statement. However,
Ardilla’s input for $_POST[selectclass] will not make the
query return any records because courseid column is integer
and will not accept the supplied string input.

1 $query = mysql_query("SELECT aperc,bperc,cperc,dperc,coursename

FROM courses WHERE courseid = $_POST[selectclass]") or

2 die("ClassInfo.php: Unable to get the class info-".mysql_error());..
3 print(..<input... name=’selectclass’ value=’$_POST[selectclass]’/>);

Listing 20: Unfeasible exploit generated by Ardilla in
ClassSettings.php, schoolmate

On myBloggie, Chainsaw generated 7 exploits while [9]
generated 5 second-order vulnerabilities. On Scarf, both [9]
and Chainsaw generated 1 vulnerability and working exploit
respectively. CraxWeb [16] reports a total of 54 exploits (24
SQLI and 30 XSS) on 4 applications (Schoolmate, Webchess,
faqforge, and EVE). Over this set of applications, Chainsaw
generated 106 exploits (74 SQLI and 32 XSS). Chainsaw
generates 3-fold SQLI exploits compared to CraxWeb, and
32 XSS exploits versus CraxWeb’s 30.

Application Ardilla [19] CraxWeb [16]

Chainsaw

Eve

schoolmate

webchess
faqforge
geccbblite

6
18
25
5
6

5
31
11
7
-

9
56
31
10
10

Table 5: Comparison on working exploits generation (num-
bers reported are the sum of SQLI+XSS).

650Application

[26]

myBloggie

scarf
Eve

-
-
5

[8]
8
-
-

[9]
5
1
-

Chainsaw

25
1
7

Table 6: Comparison on exploit seeds generation.

5.7 Discussion
Static analysis limitations: Our tool can handle dynamic
workﬂow constructs where arguments are variables deﬁned
along an execution path. However, if the application code
contains dynamically generated workﬂow features (e.g., hy-
perlinks generated using JavaScript), Chainsaw cannot re-
solve the dynamic arguments of such functions. As a result,
when constructing the GWFG, Chainsaw may not infer the
existence of such dynamic edges. Thus, it may miss some
navigation links between modules. In our dataset, however,
we missed at most 0.23% of edges in all GWFGs. Addition-
ally, Chainsaw cannot construct symbolic sink expressions
if the structure (i.e., code, not arguments) of a SQL query
or an echo-like statement cannot be constructed statically
(e.g., determined by user input). A detailed discussion on
symbolic sink construction and its limitations can be found
in our previous work [6].
Solver failures: In few instances, Chainsaw encountered
a timeout or returned unknown (i.e., could not determine if
formula was satisﬁable). In our evaluation, the solver encoun-
tered undecidability in solving 28 out of 3463 seed SMT ﬁles
(less than 1% of the overall seed SMT ﬁles). Additionally, the
solver timed-out during the solving of 45 SMT ﬁles (about
1% of the overall seed SMT ﬁles).
Unsupported PHP features: Chainsaw uses Pixy [18]
for control ﬂow analysis in PHP web applications. Some
PHP features such as dynamic inclusions and certain object-
oriented features are not supported by Pixy. Consequently,
Chainsaw does not handle such features. In our evaluation,
however, these have not limited the applicability of Chainsaw
to the elaborate dataset that is used. Note, even though
Chainsaw is implemented for PHP (which is widely used),
our approach is applicable to other web platforms.

6. RELATED WORK
Exploit generation for binary programs. Brumley et
al. [7] developed an automatic exploit generation technique
that identiﬁes the diﬀerence between patched binaries and
their unpatched versions to generate inputs that trigger the
diﬀerence. Avgerinos et al. [1] developed AEG to generate
control ﬂow hijacking exploits on binary programs. FlowStich
[15] generated data-oriented attacks by connecting data-ﬂows
in binary programs assuming that control ﬂow integrity is
intact. All these works focus on generating exploits for
binaries while our approach deals with global navigation
structure and web applications state.
Exploit generation for web applications. Ardilla [19]
uses concolic execution and taint tracking (including database
tracking) to construct SQLI and XSS attack vectors. Ardilla
has three main limitations: low code coverage (<50%), sim-
ple attack library, and imprecise taint tracking via built-in
functions. Chainsaw outperformed Ardilla in the number
and the complexity of the generated exploits (second-order
SQLI and deeply located exploits) due to the use of static
analysis, search strategies and constraint solving to analyze
application navigation state and to model built-in sanitiza-
tion functions. CraxWeb [16] employs concrete and sym-

bolic execution supported by a constraint solver to generate
SQLI and XSS exploits. CraxWeb has lower code coverage
than Chainsaw and does not generate second-order exploits
which are harder to construct. Even though CraxWeb is plat-
form independent, the techniques implemented in Chainsaw
can be extended and applied to non-PHP web applications.
QED [21] generates ﬁrst-order SQLI and XSS attacks using
static analysis and model checking for Java web applica-
tions. In contrast to Chainsaw, QED does not consider
second-order exploits and it requires writing attack speciﬁca-
tions in a speciﬁc language. [27] generates inputs that expose
SQLI vulnerabilities using concolic execution of PHP appli-
cations. It ﬁnds only ﬁrst-order SQLI bugs, requires source
code instrumentation, and does not perform database analy-
sis. EKHunter [12] combines static analysis and constraint
solving to ﬁnd exploits in for-crime web applications. The
generated exploits do not span several HTTP requests, unlike
Chainsaw. WAPTEC [5] generates exploits for parameter-
tampering vulnerabilities, which are logical vulnerabilities as
opposed to injection vulnerabilities handled by Chainsaw.
Vulnerability analysis. There is a large body of research
that studied injection vulnerabilities detection. Broadly,
there are static analysis related works (such as [17], [18],
[26], [20] and [29]), dynamic analysis approaches (e.g., [22],
[13]), and hybrid approaches (such as [2]). Other approaches
focused on ﬁnding and ﬁxing sanitation related errors, the
main cause of injection vulnerabilities, as in [23] and [24].

MiMoSA [3] is a system that reasons across modules of
a web application to ﬁnd data and workﬂow attacks. Our
navigation-aware analysis is inspired by MiMoSA but it
advances the analysis to a systematic workﬂow exploration
to build working exploits using key features such as GWFG,
RWFG, preconditions-summaries, and summary histories.
Sun et al. [25] propose a technique to ﬁnd access control
vulnerabilities in web applications. Their approach builds a
graph similar to the GWFG, however, the purpose of that
graph is diﬀerent from the one generated by Chainsaw. [26] is
an approach that identiﬁes SQLI vulnerabilities by modeling
database queries using context free grammars. Chainsaw is
more precise as it factors in database schema analysis and a
constraint solver to generate concrete exploitation for SQLI
and XSS. In RIPS [8], a taint analysis system is proposed to
detect injection vulnerabilities. [9] develops a static analysis
technique that detects second-order vulnerabilities that cross
persistent storage. Even though RIPS and [9] can detect
vulnerabilities other than SQLI and XSS, in contrast to
Chainsaw, they implement a path insensitive analysis which
yields to high false positive rate and they do not generate
navigation-aware working exploits.

7. CONCLUSIONS

In this paper, we present Chainsaw, a system that reasons
systematically over the navigation structure and uses the
database state of web applications to automatically generate
working exploits. Chainsaw generated a total of 199 working
exploits on our dataset, of which 30 (15%) are second-order
exploits with no false positives. Finally, we also demon-
strated that Chainsaw signiﬁcantly outperforms prior work
on vulnerability detection and exploit generation.

Acknowledgments
We thank Bridget Basan, Antonio Shelton and Kyle Tulipano
for their help in modeling PHP functions. We also thank

651our shepherd Adam Doup´e and the anonymous reviewers
for their feedback. This material is supported in part by
NSF under Grant Nos. CNS-1514472, DGE-1069311 and by
DARPA under an AFOSR contract.

8. REFERENCES

[1] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG:

Automatic Exploit Generation. In NDSS, volume 11, pages
59–66, 2011.

[2] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E. Kirda,

C. Kruegel, and G. Vigna. Saner: Composing static and
dynamic analysis to validate sanitization in web applications.
In 2008 IEEE Symposium on Security and Privacy (sp 2008),
pages 387–401, 2008.

[3] D. Balzarotti, M. Cova, V. V. Felmetsger, and G. Vigna.

Multi-module Vulnerability Analysis of Web-based
Applications. In the 14th ACM Conference on Computer and
Communications Security (CCS), pages 25–35, 2007.

[4] J. Bau, E. Bursztein, D. Gupta, and J. Mitchell. State of the

art: Automated black-box web application vulnerability testing.
In Proceedings of the 2010 IEEE Symposium on Security and
Privacy, pages 332–345, 2010.

[5] P. Bisht, T. Hinrichs, N. Skrupsky, and V. Venkatakrishnan.

WAPTEC: Whitebox Analysis of Web Applications for
Parameter Tampering Exploit Construction. In the 18th ACM
conference on Computer and communications security, pages
575–586, 2011.

[6] P. Bisht, A. P. Sistla, and V. Venkatakrishnan. Automatically

preparing safe SQL queries. In International Conference on
Financial Cryptography and Data Security, pages 272–288.
Springer, 2010.

[7] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic

Patch-Based Exploit Generation is Possible: Techniques and
Implications. In Proceedings of the 2008 IEEE Symposium on
Security and Privacy, 2008.

[8] J. Dahse and T. Holz. Simulation of Built-in PHP Features for
Precise Static Code Analysis. In Symposium on Network and
Distributed System Security (NDSS), 2014.

[9] J. Dahse and T. Holz. Static Detection of Second-Order

Vulnerabilities in Web Applications. In 23rd USENIX Security
Symposium (USENIX Security 14), pages 989–1003, 2014.
[10] L. De Moura and N. Bjørner. Z3: An eﬃcient smt solver. In
Tools and Algorithms for the Construction and Analysis of
Systems, pages 337–340. Springer, 2008.

[11] D. Eppstein. Finding the k shortest paths. SIAM J. Comput.,

28(2):652–673, Feb. 1999.

[12] B. Eshete, A. Alhuzali, M. Monshizadeh, P. A. Porras, V. N.

Venkatakrishnan, and V. Yegneswaran. EKHunter: A
Counter-Oﬀensive Toolkit for Exploit Kit Inﬁltration. In 22nd
Annual Network and Distributed System Security Symposium,
NDSS, 2015.

[13] V. Haldar, D. Chandra, and M. Franz. Dynamic taint

propagation for java. In 21st Annual Computer Security
Applications Conference (ACSAC), pages 9–pp, 2005.

[14] S. Horwitz, T. Reps, and D. Binkley. Interprocedural slicing

using dependence graphs. In ACM SIGPLAN 1988 conference
on Programming Language design and Implementation, pages
35–46, 1988.

[15] H. Hu, Z. L. Chua, S. Adrian, P. Saxena, and Z. Liang.

Automatic Generation of Data-Oriented Exploits. In 24th
USENIX Security Symposium (USENIX Security 15), pages
177–192. USENIX Association, 2015.

[16] S. Huang, H. Lu, W. Leong, and H. Liu. CRAXweb: Automatic

Web Application Testing and Attack Generation. In IEEE 7th
International Conference on Software Security and
Reliability, SERE, pages 208–217, 2013.

[17] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and S.-Y.

Kuo. Securing web application code by static analysis and
runtime protection. In Proceedings of the 13th International
Conference on World Wide Web (WWW), pages 40–52, 2004.
[18] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A Static Analysis
tool for Detecting Web Application Vulnerabilities. In Security
and Privacy, 2006 IEEE Symposium on, pages 6–pp, 2006.

[19] A. Kieyzun, P. J. Guo, K. Jayaraman, and M. D. Ernst.

Automatic Creation of SQL Injection and Cross-Site Scripting
Attacks. In IEEE 31st International Conference on Software
Engineering (ICSE), pages 199–209, 2009.

[20] V. B. Livshits and M. S. Lam. Finding Security Vulnerabilities

in Java Applications with Static Analysis. In 14th USENIX
Security Symposium, Baltimore, Maryland, USA, 2005.

[21] M. Martin and M. S. Lam. Automatic generation of xss and sql

injection attacks with goal-directed model checking. In
Proceedings of the 17th conference on Security symposium,
pages 31–43, 2008.

[22] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and
D. Evans. Automatically hardening web applications using
precise tainting. In IFIP International Information Security
Conference, pages 295–307. Springer, 2005.

[23] M. Samuel, P. Saxena, and D. Song. Context-sensitive

auto-sanitization in web templating languages using type
qualiﬁers. In Proceedings of the 18th ACM conference on
Computer and communications security, pages 587–600, 2011.

[24] P. Saxena, D. Molnar, and B. Livshits. Scriptgard: automatic

context-sensitive sanitization for large-scale legacy web
applications. In Proceedings of the 18th ACM conference on
Computer and communications security, pages 601–614, 2011.

[25] F. Sun, L. Xu, and Z. Su. Static detection of access control

vulnerabilities in web applications. In USENIX Security
Symposium, 2011.

[26] G. Wassermann and Z. Su. Sound and precise analysis of web

applications for injection vulnerabilities. In ACM Sigplan
Notices, volume 42, pages 32–41. ACM, 2007.

[27] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura,
and Z. Su. Dynamic test input generation for web applications.
In Proceedings of the 2008 international symposium on
Software testing and analysis, pages 249–260, 2008.

[28] Y. Xie and A. Aiken. Static Detection of Security

Vulnerabilities in Scripting Languages. In USENIX Security,
volume 6, pages 179–192, 2006.

[29] F. Yu, M. Alkhalaf, and T. Bultan. Stranger: An

automata-based string analysis tool for php. In International
Conference on Tools and Algorithms for the Construction and
Analysis of Systems, pages 154–157, 2010.

[30] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A Z3-based String

Solver for Web Application Analysis. In Proceedings of the
2013 9th Joint Meeting on Foundations of Software
Engineering, pages 114–124, 2013.

Appendix

1 http://host/chess/index.php?txtNick=user&pwdPassword=pass&remember=yes
2 http://host/chess/mainmenu.php?messageID=
3 http://host/chess/viewmessage.php?messageID=1 OR 1=1

Listing 21: Exploit string for the query at line 3 in Listing 8.

1 http://host/eveactive/add.php?name=user&comment=hiThere&id=2&division=1

&rankcorp=1&vacation=0&deleted=0&action=add

2 http://host/eveactive/member.php?nname=<script>alert("error")</script>

Listing 22: Exploit for the query in Listing 13.

1 To insert:http://host/mybloggie/login.php?mode=login&username=user

&passwd=pass

2 http://host/mybloggie/admin.php?mode=adduser&username=foo’ OR ’’=’

&repassword=aaaa&password=aaaa&level=1&submit=yes

3 To select:http://host/mybloggie/login.php?mode=login&username=user

&passwd=pass

4 http://host/mybloggie/admin.php?mode=edituser&id=1&pass=no

Listing 23: second-order SQLI exploit for Listings 14 and 15.

1 http://host/geccBBlite/ripondi.php?titolo=<script>alert("error")</scr

ipt>&postatoda=aaaa&testo=aaaa&testonuovo=&ispostadel=0

2 http://host/geccBBlite/leggi.php?rd=1

Listing 24: Stored XSS exploit for Listing 17.

1 http://host/schoolmate/header.php?schoolname=name&schooladdress=23aaa&

schoolphone=1234&sitetext=<IFRAME SRC=http://site.html>&
sitemessage=hello&numperiods=2&numsemesters=2&numperiods=2&apoint
=90.0&bpoint=80.0&cpoint=70.0&dpoint=60.0&fpoint=40.0&infoupdate=1

2 http://host/schoolmate/login.php?

Listing 25: Stored XSS exploit for Listing 19.

652