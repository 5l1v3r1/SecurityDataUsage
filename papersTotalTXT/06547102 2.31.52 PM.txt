2013 IEEE Symposium on Security and Privacy

The Parrot is Dead:

Observing Unobservable Network Communications

Amir Houmansadr

Chad Brubaker

Vitaly Shmatikov

The University of Texas at Austin

Abstract—In response to the growing popularity of Tor
and other censorship circumvention systems, censors in non-
democratic countries have increased their technical capabilities
and can now recognize and block network trafﬁc generated by
these systems on a nationwide scale. New censorship-resistant
communication systems such as SkypeMorph, StegoTorus, and
CensorSpoofer aim to evade censors’ observations by imitating
common protocols like Skype and HTTP.

We demonstrate that these systems completely fail to achieve
unobservability. Even a very weak,
local censor can easily
distinguish their trafﬁc from the imitated protocols. We show
dozens of passive and active methods that recognize even a
single imitated session, without any need to correlate multiple
network ﬂows or perform sophisticated trafﬁc analysis.

We enumerate the requirements that a censorship-resistant
system must satisfy to successfully mimic another protocol and
conclude that “unobservability by imitation” is a fundamentally
ﬂawed approach. We then present our recommendations for the
design of unobservable communication systems.

Keywords-Censorship circumvention; unobservable commu-

nications; Tor pluggable transports

I. INTRODUCTION

Censorship-resistant communication systems such as the
Tor anonymity network1 are increasingly used by people in
non-democratic countries to bypass restrictions on Internet
access, share information, browse websites prohibited by the
regime, etc. In response, government censors have greatly
improved their technical capabilities and are now able to
perform real-time deep-packet inspection and trafﬁc analysis
on ISP-level volumes of network trafﬁc (see Section IV-C).
This increase in censors’ power threatens to make anony-
mous communication systems unavailable to users who need
them the most. Tor, in particular, has faced frequent blocking
even after deploying private “bridges” [17] that hide the
addresses of Tor relays in order to circumvent IP address
ﬁltering. The problem is that Tor trafﬁc remains recognizable
by its characteristic patterns and content signatures.

The continuing availability of low-latency, censorship-
resistant communications thus critically depends on their
unobservability. This has motivated an entire class of cir-
cumvention systems that aim to achieve unobservability
by imitating popular applications such as Web browsers
and Skype clients. In the rest of this paper, we refer to

1https://www.torproject.org/

them as parrot circumvention systems. For example, Skype-
Morph [41] hides Tor trafﬁc by mimicking Skype video
calls, CensorSpoofer [59] mimics SIP-based Voice-over-IP,
and StegoTorus [60] mimics Skype and/or HTTP.

Our contributions. We present the ﬁrst in-depth study of
unobservability in censorship-resistant communication sys-
tems. We develop a taxonomy of adversaries and a detailed
list of technical requirements that a parrot system must
satisfy to successfully mimic another protocol.

We analyze the recently proposed parrot systems, includ-
ing SkypeMorph, StegoTorus, CensorSpoofer and their vari-
ants, and show that they completely fail to achieve unobserv-
ability. We demonstrate multiple techniques to distinguish
their trafﬁc from the protocols they attempt to imitate and
prove that all of these techniques work in practice.

Most of our methods assume a much weaker adversary
than considered by the designers of these parrot systems.
They aim to foil large-scale statistical trafﬁc analysis by
ISP-level adversaries, yet even a single trafﬁc ﬂow generated
by any of their systems can be recognized at a low cost
by a local network adversary (e.g, a censor in control
of a Wi-Fi access point or local router) because of the
glaring discrepancies between their crude imitations and the
behavior of genuine protocol implementations.

To give just one example, SkypeMorph and StegoTorus
take great care to generate datagrams whose size distribu-
tions mimic a Skype video chat session, yet forget to mimic
the TCP control channel that always accompanies a genuine
Skype session. These imitation mistakes are numerous and
in many cases unﬁxable. Even plausible-looking ﬁxes (e.g.,
“add an imitated TCP channel”) do not help in practice
because they do not correctly mimic the complex, dynamic
dependences exhibited by the genuine protocols.

We argue that the entire approach of “unobservability by
imitation” is fundamentally ﬂawed. Convincingly mim-
icking a sophisticated distributed system like Skype, with
multiple, inter-dependent sub-protocols and correlations, is
an insurmountable challenge. To win, the censor needs only
to ﬁnd a few discrepancies, while the parrot must satisfy a
daunting list of imitation requirements. Furthermore, it is not
enough to mimic some protocol; the parrot must plausibly
mimic a speciﬁc implementation of the protocol down to
every quirk and implementation-speciﬁc bug. For example,

© 2012, Amir Houmansadr. Under license to IEEE.
DOI 10.1109/SP.2013.14

65

StegoTorus’s imitation of an HTTP server does not look like
any known Web server and is thus easily recognizable.

We conclude with the lessons and recommendations for
designing unobservable communication systems. A promis-
ing alternative to parrots is offered by systems that operate
higher in the protocol stack [28, 29]: for example, instead of
imitating Skype, they run genuine Skype and transport their
trafﬁc in the encrypted voice or video payloads.

II. UNOBSERVABILITY BY IMITATION

Intuitively, unobservability means that a censor can nei-
ther recognize the trafﬁc generated by the circumvention
system, nor identify the endpoints engaged in circumvention.
Parrot circumvention systems aim to achieve unobservability
by mimicking a widely used, uncensored target protocol.
Popular imitation targets include HTTP, Skype, and IETF-
based VoIP. It is essential that the target be a common
protocol which the censor may be unwilling to block for
political or economic reasons. Imitating an unpopular pro-
tocol is futile because the censor will simply block both the
genuine protocol and its imitations.

Skype. Skype is a very popular Voice-over-IP (VoIP) system
based on a P2P overlay network of users running Skype
software. Skype’s proprietary design has been extensively
studied and reverse-engineered (see Appendix A).

A Skype client

is an ordinary user who makes calls
and sends messages. Users are authenticated by a central
login server. A Skype supernode is a resource-rich user
with a public IP address and sufﬁcient CPU, memory, and
network bandwidth [1, 5]. Supernodes relay media and
signals between clients that cannot communicate directly due
to network address translation (NAT) and ﬁrewalls.

IETF-based VoIP. IETF has several standards for VoIP
protocols, including network discovery to connect to the
VoIP network, session control to set up and tear down calls,
and media transmission to communicate voice datagrams.

Session Initiation Protocol (SIP) [51] is a popular session
control protocol. SIP is an application-layer protocol and can
run over TCP or UDP. A SIP system comprises user agents,
location services, registrar servers, and proxy servers. User
agents have registered SIP IDs and run SIP client software. A
location service is the VoIP provider’s database listing users,
their SIP IDs and network locations, etc. Registrar servers
are network machines operated by the VoIP provider that
receive SIP registration requests from user agents and update
their information in the location service. Proxy servers
receive call requests from user agents and forward them
either to the requested callees, or to other SIP proxies.

they use a media transmission protocol

Once a VoIP session is established between two SIP
to
user agents,
trafﬁc, e.g., audio data. Real-time
communicate the call
Transport Protocol (RTP) [53] is an IETF standard for
media transmission. Real-time Transport Control Protocol

(RTCP) is a sister protocol that controls an established RTP
connection by exchanging out-of-band statistics and control
information. Both RTP and RTCP run over UDP and have
encrypted versions, called SRTP and SRTCP, respectively.
If SRTP/SRTCP is used, an additional protocol is needed to
establish a shared key, e.g., MIKEY [3], or else user agents
may use pre-established keys.

Session Traversal Utilities for NAT (STUN) [50] is a set
of methods that allows a VoIP client behind NAT to discover
this fact and connect to a VoIP network.

III. PARROT CIRCUMVENTION SYSTEMS

A. SkypeMorph

SkypeMorph [41] is a pluggable transport [46] for Tor
intended to make the trafﬁc between a Tor client and a Tor
bridge [17] look like a Skype video call.

The client obtains the bridge’s Skype ID in advance, e.g.,
through Tor’s BridgeDB [13]. The bridge logs into Skype
and picks a high UDP port. The client logs into Skype, picks
a high UDP port, and waits until the bridge’s ID is online,
then sends a Skype text message to the bridge containing the
client’s IP address, UDP port, and public key. The bridge
replies with a Skype message containing its own IP address,
UDP port, and public key. The exchanged public keys are
used to derive a shared secret key.

The client simulates the start of a video call by sending
a Skype ring signal to the server and then dropping the
call. The bridge does not “answer” this call. Instead, it
listens on its own UDP port for incoming SkypeMorph
messages and responds to the client’s UDP port. These
messages are encrypted with the shared secret key. Once
the encrypted UDP connection starts, both the client and
the bridge terminate their Skype runtime.

B. StegoTorus

StegoTorus [59] is a pluggable Tor transport derived from
Obfsproxy [44]. It adds chopping and steganography to
Tor clients and bridges. The chopper aims to foil statistical
analysis by changing packet sizes and timings. It carries Tor
trafﬁc over links comprised of multiple connections. Each
connection is a sequence of blocks, padded and delivered
out of order. The steganography module aims to hide trafﬁc
contents by mimicking HTTP, Skype, and Ventrilo.

Embed steganography. StegoTorus-Embed aims to mimic
a P2P connection such as Skype or Ventrilo VoIP. The
StegoTorus prototype uses a database of genuine, previously
collected Skype and Ventrilo packet traces to shape its trafﬁc,
but users can supply their own traces. To ensure that trafﬁc
patterns match, a StegoTorus client sends packet timings
and sizes to the StegoTorus server at the beginning of the
connection. In addition, StegoTorus emulates application
headers to match the trafﬁc payload. The current prototype
generates application headers “by hand” because neither
Skype, nor Ventrilo are open-source.

66

HTTP steganography. StegoTorus-HTTP aims to mimic
unencrypted HTTP trafﬁc by using a client-side request
generator and a server-side response generator. Both rely
on a pre-recorded trace of HTTP requests and responses.
Unlike StegoTorus-Embed, clients and servers use indepen-
dent HTTP traces; neither trace is temporally arranged.

The request generator picks a random HTTP GET request
from the trace and hides the payload produced by the
chopper in the <uri> and <cookie> ﬁelds of the request
by encoding the payload into a modiﬁed base64 alphabet
and inserting special characters at random positions to make
it look like a legitimate URI or cookie header.

The response generator picks a random HTTP response
consistent with the request and hides the data in the ﬁles
carried by this response. The StegoTorus prototype uses
PDF, SWF, and JavaScript ﬁles for this purpose.

C. CensorSpoofer

Unlike StegoTorus and SkypeMorph, which are pluggable
Tor transports, CensorSpoofer [59] is a standalone system
that (1) uses IP spooﬁng to obfuscate the server’s identity,
and (2) mimics VoIP trafﬁc to obfuscate trafﬁc patterns.

CensorSpoofer is mainly designed for censorship-resistant
Web browsing, where the upstream ﬂow (requested URLs)
requires much less bandwidth than the downstream ﬂow (po-
tentially large HTTP responses). Therefore, CensorSpoofer
decouples upstream and downstream connections. A Cen-
sorSpoofer client uses a low-capacity channel such as email
or instant messaging to send requests to the CensorSpoofer
server. The server hides HTTP responses by mimicking P2P
trafﬁc from an oblivious dummy host. The CensorSpoofer
prototype focuses on mimicking UDP-based VoIP trafﬁc,
thus dummy hosts are chosen by port-scanning random IPs
and picking the ones whose SIP ports are open.

A CensorSpoofer client initiates a SIP connection with
the CensorSpoofer server by sending a SIP INVITE to the
appropriate SIP ID. The CensorSpoofer spoofer replies with
a SIP OK message spoofed to look as if its origin is the
dummy host. Once the client receives this message, it starts
sending encrypted RTP/RTCP packets with random content
to the dummy host. At the same time, the spoofer starts
sending spoofed, encrypted RTP/RTCP packets to the client
ostensibly from the dummy host’s address.

To browse a URL, the client sends it through the upstream
channel. The spoofer fetches the contents and embeds them
in the spoofed RTP packets to the client. To terminate,
the client sends a termination signal upstream. The spoofer
replies with a spoofed SIP BYE message, the client sends a
SIP OK message and closes the call.

IV. ADVERSARY MODELS

A. Capability classiﬁcation

Passive attacks involve observing and analyzing network
trafﬁc and the behavior of Internet entities. Typical tech-

niques are statistical trafﬁc analysis, deep-packet inspection,
and behavioral analysis.

Active attacks involve manipulation of network trafﬁc.
Typical techniques are delaying, dropping, or injecting pack-
ets into existing connections, modifying packet contents,
throttling bandwidth, and terminating connections.

Proactive attacks aim to identify network entities involved
in circumvention by sending probes that are crafted to elicit
recognizable responses. For example, a censor may try to
discover Tor bridges by initiating connections to random
or suspected IP addresses [40]. By contrast, active attacks
perturb already existing connections.

B. Knowledge classiﬁcation

Local adversary (LO) controls at most a few network
devices and can only observe a small number of connec-
tions. Examples include compromised home routers or Wi-Fi
access points, corporations monitoring employees, etc.

By contrast, a state-level adversary observes large vol-
umes of network trafﬁc. Examples include malicious ISPs
and government censors. We further subdivide state-level
adversaries into two categories based on their resources.

State-level oblivious adversary (OB) has limited com-
putational and/or storage resources. He can neither keep
network traces for a long time, nor perform heavyweight
trafﬁc analysis. An OB censor may possess capabilities like
deep-packet inspection (DPI), but can only apply them at
close to line speeds to short observations of network trafﬁc:
for example, to individual packets but not across packets.

State-level omniscient adversary (OM) has ample process-
ing and storage resources. He can aggregate data collected
at different network locations and store all intercepted trafﬁc
for ofﬂine, computationally expensive analysis.

C. Real-world censors

Repressive states like China, Iran, Cuba, Syria, and North
Korea have deployed the most aggressive Internet censor-
ship [16, 31, 38, 49], but censorship is practiced even by
Australia [4] and Italy [33], as well as enterprise networks
and search engines [35]. Some government censors are
“passive OB” in our classiﬁcation, but the number of active
and proactive OM censors is growing [31].

The “Great Firewall of China” employs both active and
proactive censorship. Chinese censors proactively scan for
Tor bridges [61], even resorting to IP spooﬁng on occa-
sion [63]. In 2011, they were able to identify new Tor
bridges in less than 10 minutes [12] by actively probing SSL
trafﬁc [56, Slide 41]. Once a Chinese Tor user connects to a
bridge for the ﬁrst time, several probes requesting connection
are sent from different IP addresses inside China to verify
that this is indeed a bridge [63]. Chinese censors actively
enumerated all bridges offered on Tor’s website through
human interaction over several weeks [55, 56]. They also

67

enumerated and blocked all bridge IP addresses provided via
Gmail, leaving Tor with only the social network distribution
strategy and private bridges [56, Slide 24].

Iranian censors perform sophisticated deep-packet inspec-
tion. In 2011, they managed to detect and block all Tor
trafﬁc for several weeks by noticing the difference between
the Difﬁe-Hellman moduli
in “genuine” SSL and Tor’s
SSL. Later, they used the lifetime of Tor’s SSL certiﬁcates
to recognize Tor trafﬁc [56, Slide 38]. Furthermore, Iran
repeatedly blocks all encrypted trafﬁc [32].

Censors can even unplug an entire country from the

Internet, as in Egypt and Libya [56, Slides 29 and 31].

D. Adversary models of parrot circumvention systems

To infer the adversary models of the existing parrot
circumvention systems, we use the statements made in the
papers that describe their respective designs.

SkypeMorph. SkypeMorph acknowledges “probes per-
formed by hosts located in China, aimed quite directly at
Tor bridges” [41, §1, ¶4] and claims unobservability against
“a state-level ISP or authority,” able to “capture, block or
alter the user’s communications based on pre-deﬁned rules
and heuristics” [41, §3, ¶1]. We infer that the SkypeMorph
censor can perform passive, active, and proactive attacks.

SkypeMorph also claims unobservability against powerful
censors who can perform statistical analysis and deep-
packet inspection. For example, the designers state that “the
censorship arms race is shifting toward the characteristics
of connections” [41, §1, ¶5], acknowledging the feasibility
of resource-intensive analysis. They also consider “behav-
ioral heuristics” to “detect a user’s attempt to circumvent
censorship” [41, §3, ¶2], including detection of proxy con-
nections by port knocking: “a TCP SYN packet following
a UDP packet to the same host” [41, §3]. We infer that the
SkypeMorph censor is OM in our classiﬁcation.

SkypeMorph assumes that the censor’s activities are lim-
ited so as not
to interfere with the normal use of the
Internet by “benign” users (similar to CensorSpoofer), and
that the censor does not have prior information about the IP
addresses and Skype IDs of SkypeMorph servers.

StegoTorus. Censors can perform IP, content, and statistical
ﬁltering but only “in real
time on a tremendous trafﬁc
volume” [60, §2.2.2, ¶1]. StegoTorus “is not expected to
resist sophisticated, targeted attacks that might be launched
by a nation-state adversary.” The StegoTorus censor is thus
OB in our classiﬁcation.

StegoTorus considers their threat model to be “similar
to previous research like Telex” [60, §2.2, ¶1]. The Telex
censor can perform passive, active, and proactive attacks,
although the following statement implies that the StegoTorus
censor is not the Telex censor: “. . . potential application-
level attack that involves serving malicious content and then
observing a distinctive trafﬁc pattern; although relevant, we

are more interested in passive attacks that could be carried
out on a large scale” [60, §7].

CensorSpoofer. CensorSpoofer considers a “state-level ad-
versary” who has “sophisticated censorship capabilities of IP
ﬁltering, deep packet inspection, and DNS hijacking, and can
potentially monitor, block, alter, and inject trafﬁc anywhere
within or on the border of its network,” [59, §3.1, ¶1] “can
rent hosts outside of its own network, but otherwise has no
power to monitor or control trafﬁc outside its borders,” and
“has sufﬁcient resources to launch successful insider attacks,
and thus is aware of the same details of the circumvention
system as are known to ordinary users” [59, §3.1, ¶3]. We
infer that the CensorSpoofer censor is OM and capable of
passive, active, and proactive attacks.

V. REQUIREMENTS FOR PARROT CIRCUMVENTION

Parrot circumvention systems aim to make their com-
munications indistinguishable from another protocol. This
requires mimicking every observable aspect of the target
protocol. Not every requirement applies to a given cir-
cumvention system, and the ability to detect discrepancies
between the parrot and the genuine article may vary from
censor to censor. Nevertheless, in Sections VII, VIII, and IX,
we demonstrate that all recently proposed parrot circumven-
tion systems fail so many requirements that their sessions are
recognizable at a low cost even by a very weak censor.

A. Mimicking the protocol in its entirety

Correct. The most basic requirement is to mimic the target
protocol correctly. The parrot’s observable behavior must be
consistent with the protocol speciﬁcation.

SideProtocols. Many modern network protocols include
multiple “side” protocols and control channels that run
alongside the main session. For example, a typical VoIP
session involves three protocols: SIP for signaling the ses-
sion, RTP for streaming the media, and RTCP for controlling
the media stream. Another example is the STUN trafﬁc
generated by VoIP clients residing behind a ﬁrewall.

The parrot must mimic all channels and side protocols of
its target. For example, even a perfect imitation of an RTP
ﬂow is trivial to recognize if, unlike genuine RTP ﬂows, it
is not accompanied by a concurrent RTCP connection.

IntraDepend. Multiple connections comprising a single pro-
tocol session have complex dependences and correlations.
In particular, changes in the main channel often cause
observable activity in the control channel and vice versa.

For example, a typical VoIP session starts with an ex-
change of characteristic messages between the caller and a
SIP server, followed by the initialization of RTP and RTCP
connections between the caller and the callee. The SIP con-
nection is kept alive while the RTP/RTCP connections are
active. The session ends with characteristic SIP messages.

68

Dropping RTP packets may cause distinct RTCP activity as
the encoding of the media stream is being adjusted.

The parrot must faithfully mimic all dynamic dependences

and correlations between sub-protocols.

InterDepend. A session of a given protocol may trigger
other protocols. For example, an HTTP request often triggers
multiple DNS queries.

The parrot must (1) trigger other protocols whenever the
target protocol would have triggered them, and (2) mimic the
target protocol’s response when triggered by other protocols.

B. Mimicking reaction to errors and network conditions

Err. One of the easiest ways to tell a parrot from a genuine
protocol implementation is to observe its reaction to errors,
whether natural (e.g., caused by a buggy endpoint) or
artiﬁcial. Errors include malformed packets, invalid requests,
unwanted trafﬁc (e.g., packets from other sessions), etc.

The protocol standard may prescribe how certain errors
should be handled, but error handling is often underspeciﬁed
and left to the discretion of the implementation. Differences
in error handling can thus be used to ﬁngerprint implemen-
tations of common network protocols such as HTTP [30].

Error handling is extremely difﬁcult to mimic and most
parrots fail to do it properly or at all. First, the parrot must
produce at least some reaction to any possible error that
might occur in the target protocol (because any genuine
implementation would react in some way). The second re-
quirement is even more challenging. The parrot’s reactions to
all possible errors must be consistent: they should look as if
they were generated by a particular genuine implementation.
For example, a parrot Web server cannot react to some
erroneous requests as if it were a Microsoft IIS and to others
as if it were an Apache server.

Network. The Internet is a noisy medium, and network ﬂows
may experience packet drops and reorders, repacketization,
high latencies caused by dynamic changes in the throughput
of certain links, etc. Some protocols prescribe standard
reactions to changes in network conditions: for example,
TCP uses sequence numbers and a congestion control mech-
anism, while live-video environments have multiple patented
automatic repeat request (ARQ) mechanisms.2 Streaming
media protocols in particular react in very distinct ways
to congestion and other network issues. In general, packet
losses and congestion cause media applications to lower
codec quality and/or adjust transmission rates.

The parrot must mimic the target protocol’s responses to
all possible changes in network conditions, whether natural
or artiﬁcially induced. Furthermore, if a side protocol is
used—for example, to signal codec renegotiation—it must
be mimicked, too (see the InterDep requirement).

2http://www.techex.co.uk/other/arq-video-packet-resend

C. Mimicking typical trafﬁc

Content. Many network protocols have speciﬁc formats for
headers and payloads, all of which must be mimicked by
the parrot. For example, HTTP headers contain information
about the payload, while port numbers in IP headers reﬂect
higher-level protocols. Encryption does not conceal all of
this information. For example, headers of encrypted Skype
packets reveal their type and other information [10].

Message payloads generated by the parrot must be in-
distinguishable, too. In particular, imitated ﬁles must be
metadata-compatible with the genuine ﬁles. For example,
imitated PDF ﬁles must contain correct xref tables and other
metadata typically found in real PDF ﬁles.

Patterns. Many protocols produce characteristic patterns
of packet sizes, counts,
intervals, and ﬂow
rates. These patterns are often stable across the network,
observable even when packet contents are encrypted, and
can be exploited for trafﬁc analysis [42].

inter-packet

The parrot must produce network ﬂows all of whose ob-
servable characteristics, including packet sizes and timings,
are indistinguishable from the genuine protocol.

Users. User behavior often produces recognizable patterns
at the network level. For example, a typical Skype user only
makes a few Skype calls at a time. A parrot making hundreds
of concurrent Skype calls thus appears very anomalous and
can be easily distinguished from a genuine Skype client.
Similarly, a typical email user only sends and receives
a certain number of messages per day [48]. Users can
be ﬁngerprinted based on the frequency of their system
usage, number of connection peers, typical volume of trafﬁc
associated with each use, etc.

The parrot must faithfully mimic typical user behavior.

Geo. Observable behavior of protocol endpoints—including
their routing decisions, chosen peers, and even trafﬁc con-
tents—may depend on their geographic location. For ex-
ample, a Web server may respond differently to the same
request depending on its origin; network packets sent by a
remote peer enter a given ISP at different points depend-
ing on the peer’s location; SIP-based VoIP clients always
connect to the geographically closest SIP server, etc.

Some implementations of common protocols are country-
speciﬁc. For example, Skype users in mainland China use a
special implementation of Skype called TOM-Skype which
has built-in surveillance functionality [34]. Any parrot that
mimics a different Skype client is likely to stand out.

The parrot must mimic all geography-speciﬁc aspects of

the genuine protocol and its local implementations.

D. Mimicking implementation-speciﬁc artifacts

Soft. A protocol speciﬁcation can be realized by multiple
implementations. For example, there are dozens of Web
browsers and Web servers. For inter-operability, each imple-
mentation generally complies with its (often idiosyncratic)

69

interpretation of the standard, but often with characteristic
quirks and tell-tale signs. Sometimes these are explicit—for
example, HTTP request headers include information about
the browser—but even unintentional discrepancies can be
used to ﬁngerprint implementations and different versions
of the same implementation [30]. For example, different
versions of Apache Web server contain different bugs, which
can be triggered by a remote user to identify the version.

It is not enough to mimic or implement the protocol
speciﬁcation. The parrot must mimic a speciﬁc version of
a speciﬁc popular implementation, down to every last bug,
whether known or unknown! Any deviation can be used to
distinguish the parrot from the known implementations.

OS. Network protocols are usually designed to be oblivious
to the endpoint’s operating system (OS), yet the latter can
often be revealed by the recognizable characteristics of
speciﬁc client and server software. For instance, the IETF
standard requires that the initial sequence number of a TCP
connection be randomly generated. Different OSes, how-
ever, use different sequence number generation algorithms,
enabling OS identiﬁcation [43]. This information is also
explicitly included in HTTP headers.

The parrot must generate consistent OS ﬁngerprints. In
particular, when mimicking a network service, OS ﬁnger-
prints should not change frequently because servers’ OSes
do not change frequently.

VI. EXPERIMENTAL SETUP

We obtained the latest implementations of all analyzed
parrot systems and their imitation targets (Skype, Ekiga, etc.)
from their respective websites and/or authors.

For all Skype and CensorSpoofer experiments, we exe-
cuted the software in VirtualBox3 virtual machines (VMs),
running on a Funtoo Linux machine with an Intel i5 CPU
and 4GB of RAM. Skype clients were executed in two
Windows 7 VMs; SkypeMorph and StegoTorus-Embed in
separate Ubuntu 12.10 VMs. The VMs were connected
through Virtual Distributed Ethernet (VDE) [58], which
provides tools for network perturbation. We developed our
own plugins for VDE that allow us to drop packets at
different rates and modify packet contents on the wire. Each
VM is connected to a separate virtual VDE switch, and the
switches are connected to a central switch, which provides
DHCP connectivity to the Internet.

Experiments with StegoTorus clients and servers in Sec-
tion VIII were executed on two physical Ubuntu 12.04
machines, using the statistics module of iptables4 to drop
packets at different rates. Our StegoTorus server uses a real
Tor bridge to connect to the Tor network. VoIP clients in
Section IX were analyzed on a Windows 7 VM, Ubuntu
12.04 VM, and Mac OS X 10.7. The SIP probing test was

3https://www.virtualbox.org/
4http://www.netﬁlter.org/

implemented in Python and performed over a non-ﬁrewalled
Ubuntu 12.04 server with a public IP address.

VII. DETECTING SKYPE IMITATORS

We demonstrate that parrot circumvention systems that
aim to imitate Skype—in particular, SkypeMorph and
StegoTorus-Embed5—can be easily distinguished from gen-
uine Skype and thus fail to achieve unobservability.

First, we show that their imitation of Skype is incom-
plete and can thus be recognized even by low-cost, passive
attacks. Next, we describe hypothetical improved versions
of SkypeMorph and StegoTorus, designed speciﬁcally to
imitate Skype behaviors that are missing in their current
prototypes. We then demonstrate that even these hypothetical
improvements can be easily distinguished from genuine
Skype by active and proactive attacks.

A. Passive attacks

We present two classes of passive attacks. The ﬁrst uses
the Skype detection tests from Appendix A-B to recognize
partial imitations. The second exploits the fact that both
SkypeMorph and StegoTorus-Embed rely on recorded Skype
traces to mimic packet timings and sizes. All attacks have
been empirically conﬁrmed by (1) executing SkypeMorph
and StegoTorus prototypes and (2) analyzing their code.

Exploiting deviations from genuine Skype behavior.
Skype identiﬁcation tests (see Appendix A-B) are used by
ISPs and enterprise networks and can be easily performed
even by a passive, resource-constrained censor. To suc-
cessfully mimic Skype, a parrot system must pass all or
at least the majority of these tests. Unfortunately, Table I
demonstrates that both SkypeMorph and StegoTorus fail.

This indicates serious design ﬂaws in both systems.
They claim to provide unobservability against sophisticated
statistical
trafﬁc analysis, yet can be distinguished from
Skype even by extremely basic tests which are less resource-
intensive and more effective than the hypothetical
tests
considered by the designers of these systems.

StegoTorus mimics Skype’s trafﬁc statistics, but fails to
mimic much more visible aspects of genuine Skype such
as HTTP update and login trafﬁc. Neither SkypeMorph,
nor StegoTorus mimics Skype’s TCP channel, which is
an essential component of every genuine Skype session.
Furthermore, neither system generates SoM packet headers
(see Appendix A-B), which are present in every genuine
Skype UDP packet. These tests are (1) passive and (2)
can be performed at line speeds, thus SkypeMorph and
StegoTorus fail even against the weakest censor.

A censor can combine the tests listed in Table I into a
hierarchical detection tool. In fact, similar tools have been
proposed for real-time detection of Skype trafﬁc [9, 23],

5StegoTorus-Embed also aims to mimic Ventrilo, but we do not consider
it in this paper because Ventrilo is not as popular as Skype, and in any case
the latest StegoTorus prototype does not fully implement Ventrilo.

70

PASSIVE ATTACKS TO DETECT SKYPE PARROTS.

Table I

Attack
Skype HTTP update trafﬁc (T1)
Skype login trafﬁc (T2)
SoM ﬁeld of Skype UDP packets (T3)
Trafﬁc statistics (T4, T5)
Periodic message exchanges (T6, T7)
Typical Skype client behavior (T8)
TCP control channel (T9)

Imitation requirement
SideProtocols
SideProtocols
Content
Pattern
SideProtocols
IntraDepend
SideProtocols

Adversary
LO/OB/OM
LO/OB/OM
LO/OB/OM

LO/OM

LO/OB/OM

LO/OM

LO/OB/OM

SkypeMorph

StegoTorus-Embed

Satisﬁed
Satisﬁed

Failed

Satisﬁed

Failed
Failed
Failed

Failed
Failed
Failed

Satisﬁed

Failed
Failed
Failed

including line-rate detectors by Patacek [47], who used these
tests in an NfSen6 plugin, and by Adami et al. [1]. These
tools can be adapted to detect Skype parrots that pass a non-
trivial fraction of the tests, but not all of them.

Exploiting re-use of pre-recorded Skype traces. Both
StegoTorus and SkypeMorph clients come with pre-recorded
trafﬁc traces, which are used to mimic Skype by sending
packets with the exact same timings and sizes. Because the
censor also has access to the client software, he can match
observed ﬂows against these patterns and exploit the fact
that genuine Skype trafﬁc is unlikely to match them exactly,
while imitated trafﬁc always will.

Such censor must be OM because he needs to allocate
resources to match every observed ﬂow against the known
trace. This passive attack succeeds because SkypeMorph and
StegoTorus fail the Patterns requirement.

Exploiting re-use of client-generated Skype traces. To
foil the above attack, both StegoTorus and SkypeMorph
suggest that a client may generate its own Skype traces and
mimic those. This re-use can be detected by a long-term OM
censor since multiple genuine ﬂows from the same client are
unlikely to ever repeat the exact pattern of timings and sizes.
This passive attack succeeds because SkypeMorph and

StegoTorus fail the Patterns and User requirements.

B. Hypothetical SkypeMorph+ and StegoTorus+

Imagine hypothetical systems called SkypeMorph+ and
StegoTorus+ that add the patterns and messages from Ta-
ble I which are missing from, respectively, SkypeMorph
and StegoTorus. StegoTorus+ adds an imitated Skype login
(similar to the current SkypeMorph prototype). Both Skype-
Morph+ and StegoTorus+ add the missing messages from
Appendix A-B and put appropriate SoM ﬁelds into imitated
Skype packets. To mimic Skype’s TCP channel—which is
a dead giveaway that the current prototypes of SkypeMorph
and StegoTorus are not actually running Skype—they add a
fake TCP connection to each Skype call using the TCP port
with the same number as the corresponding UDP connection,
and send regular “garbage” trafﬁc on this connection to
mimic Skype’s control trafﬁc.

To foil detection based on trace re-use, StegoTorus and
SkypeMorph use a Skype pattern generator instead of pre-

6http://nfsen.sourceforge.net/

recorded or pre-generated traces. This generator produces
Skype-like packet timings and sizes on the ﬂy, thus the
resulting patterns are unique to each imitated connection.
For the sake of the argument, even imagine that this gen-
erator cannot be recognized by tools that discover covert
communications based on fabricated patterns [24].

C. Active and proactive attacks

Unfortunately, even SkypeMorph+ and StegoTorus+
would not achieve unobservability because they would suffer
from the same fundamental ﬂaw as SkypeMorph and Stego-
Torus: they do not actually run Skype, they only try to mimic
it, futilely. Table II summarizes active and proactive attacks
that can distinguish a Skype parrot from genuine Skype.

Verifying supernode behavior.
Requirements: SideProtocols, IntraDepend
Adversary: Proactive, LO/OM
Skype supernodes (SN) relay media trafﬁc and signaling
information for ordinary Skype clients [6]. In particular,
ordinary clients use nearby supernodes to connect to the
Skype network. The following two-stage attack enables a
censor to distinguish SkypeMorph+ and StegoTorus+ servers
from genuine Skype supernodes.

Phase 1: Supernode identiﬁcation. We give two ways to
ﬁnd out if a given node is (or pretends to be) a Skype
supernode. If it receives Skype calls from nodes behind
NAT in the censor’s network, then it must be a supernode
because ordinary Skype nodes cannot receive calls directly
(this supernode is either the callee, or relaying the call for an
ordinary node). Second, the censor can use the existing tools
for checking whether an IP address is performing NAT [54].
A Skype node that is not behind NAT is a supernode.

This phase ﬁlters out all genuine, ordinary Skype nodes,
leaving genuine supernodes as well as SkypeMorph+ and
StegoTorus+ parrots.

Phase 2: Supernode veriﬁcation. Consider a target node
that looks like a Skype supernode after Phase-1 ﬁltering.
The censor can run an ordinary Skype client and ﬂush
its supernode cache, which is the list of the supernodes
discovered by that client, to force the client to use the
target node as its supernode [5, 25]. If the target
is a
genuine supernode, the client will be able to connect to the
Skype network and make calls. If the target is a parrot, the

71

ACTIVE AND PROACTIVE ATTACKS TO DETECT IMPROVED SKYPE PARROTS.

Table II

Attack

Verify supernode behavior
by ﬂushing supernode cache

Drop a few UDP packets

Close TCP channel

Delay TCP packets

Close TCP connection to a SN

Block the default TCP port
for TCP channel

Imitation
requirement
SideProtocols
IntraDepend
Network,
Err
IntraDepend,
SideProtocols
IntraDepend,
SideProtocols,
Network
IntraDepend,
SideProtocols
IntraDepend
SideProtocols

Adversary

Skype

Proactive,
LO/OM
Active,

The target node serves as the adversary’s
SN, e.g., relays his Skype calls
A burst of TCP packets on the

LO/OB/OM control channel (Fig. 1)

Active,

Ends the UDP stream immediately

LO/OB/OM

Active,
LO/OM

Reacts depending on the type
of TCP messages

Active,

Client initiates UDP probes

LO/OB/OM to ﬁnd other SNs

Active,

Connects to TCP ports 80

LO/OB/OM or 443 instead

SkypeMorph+ and

StegoTorus+
Rejects all

Skype messages

No reaction

No reaction

No reaction

No reaction

No reaction

Figure 1. Skype TCP activity with and without changes in bandwidth.

]
s
d
n
o
c
e
s

0
1

r
e
p
[
s
t
e
k
c
a
p

f
o

r
e
b
m
u
N

Change in available bandwidth

With change in bandwidth

without

10

8

6

4

2

0
250

300

350

400
500
Time in seconds

450

550

600

650

connection will fail because StegoTorus and SkypeMorph
only mimic the Skype protocol but cannot actually run it.

Manipulating Skype calls.
Requirements: Network, Err, IntraDepend
Adversary: Active, LO/OB/OM
This attack tampers with a Skype connection by dropping,
reordering, and delaying packets or modifying their con-
tents, then observes the endpoints’ reaction. These changes
are fairly mild and can occur naturally, thus they do not
drastically affect genuine Skype connections.

When UDP packets are dropped in a genuine Skype call,
there is an immediate, very noticeable increase in the activity
on the TCP control channel that accompanies the main UDP
connection (see Fig. 1). We conjecture that this is caused by
Skype endpoints re-negotiating connection parameters due
to perceived changes in network conditions.

Neither SkypeMorph, nor StegoTorus implements the
TCP control channel. Our hypothetical SkypeMorph+ and
StegoTorus+ add a fake TCP connection and may even send
dummy packets over it, but this is not enough. The imitated
behavior will not be correlated to the network conditions in
the same way as in genuine Skype, enabling the censor to
distinguish parrots from Skype. We argue that it is extremely
difﬁcult to convincingly imitate dynamic dependences be-
tween network conditions and Skype’s control trafﬁc.

IntraDepend,

SideProtocols,

Manipulating the TCP control channel.
Requirements:
Network
Adversary: Active, LO/OB/OM
In the previous test, we showed that perturbing Skype’s
main UDP connection causes observable changes on the
TCP control channel. We now show that perturbing the TCP
channel causes observable changes on the UDP connection.

Close the TCP connection. Closing the TCP channel (e.g.,
by sending an RST packet) causes genuine Skype nodes to
immediately end the call. Our hypothetical parrots do not
mimic this behavior because their fake TCP channel has no
relationship to the actual call. While this attack interferes
with genuine Skype users to some extent, spurious call
disconnections are fairly common in Skype. A censor may
use this attack as a conﬁrmation on a relatively small set of
connections suspected to be imitations.

Withhold or drop selected TCP packets. The TCP connection
sends packets with frequency varying from 30 to 60 seconds,
or when network conditions change. Tampering with these
packets causes observable changes on the genuine UDP
channel, but not on the imitated one.

Trigger a supernode probe. A Skype client keeps a TCP
connection with its supernode. If this connection is closed,
a genuine client immediately launches a UDP probe (Ap-
pendix A-A) to search for new supernodes. A parrot doesn’t.

Block a supernode port. After a successful UDP probe, a
genuine client establishes a TCP connection with the same
port of its supernode. If this port is not available, the client
tries connecting to ports 80 or 443 [5]. A parrot doesn’t.

Similar attacks include tampering with SoM ﬁelds in UDP

packet headers.

VIII. DETECTING STEGOTORUS

This active attack does not adversely affect normal Skype
users. Dropping a few packets does not disconnect the call,
but only degrades its quality for a short period of time.

In Section VII, we showed how to detect StegoTorus-
Embed’s ﬂawed imitation of Skype. In this section, we show
how to detect the chopper and StegoTorus-HTTP.

72

Figure 2. Correlated behavior of StegoTorus connections.

160

140

120

100

80

60

40

20

e
t
a
R
t
e
k
c
a
P

0
35

start dropping
the dashed flow

40

45

50

55

60

65

70

Time (s)

A. Attacks on StegoTorus chopper

Correlating IP addresses between links.
Requirement: Geo
Adversary: Passive, LO/OM
A StegoTorus session, called a link, comprises several con-
nections. This enables easy passive detection of StegoTorus
clients because normal users do not keep multiple, concur-
rent HTTP and Skype connections to the same server.7 A
possible countermeasure is to have different links handled
by geographically distributed servers, but this will impose
an intolerable delay on low-latency trafﬁc (e.g., Tor) because
the servers must cooperate to reconstruct chopped packets.

Exploiting connection dependences.
Requirements: Network, User
Adversary: Passive/Active, LO/OM
Multiple connections created by the StegoTorus chopper
carry packets from the same Tor session, thus their reactions
to network conditions and perturbations are highly corre-
lated. By contrast, genuine HTTP connections to different
servers exhibit no such correlation. The correlations between
StegoTorus connections can be observed by a passive censor
or exploited for an active attack, as shown in Fig. 2: once
packets on one StegoTorus connection are dropped, the other
two belonging to the same link immediately slow down.

client via an HTTP request. The StegoTorus prototype sup-
ports PDF, SWF, and JavaScript, but instead of generating
documents in these formats, it uses real ﬁles and replaces
speciﬁc ﬁelds with hidden content. This preserves the ﬁle’s
syntactic validity, but not its semantics. The StegoTorus
paper claims that checking ﬁle semantics at line speeds
requires a lot of resources from a state-level censor dealing
with large volumes of trafﬁc.

This claim is false. We demonstrate that it is possible
to detect discrepancies between real ﬁles and StegoTorus’s
imitations at a very low cost and at line speed.

As a proof of concept, we show how to analyze PDF ﬁles,
but similar techniques work against any other format. The
fake-trace generator in the StegoTorus prototype produces
templates for PDF ﬁles that miss an essential object called
xref table. In a genuine PDF ﬁle, this table follows the xref
keyword and declares the number and position of various
objects. The absence of this table in StegoTorus’s imitations
is detectable via simple deep-packet inspection at line speed,
without any need to reconstruct or parse the ﬁle.

Adding a fake xref table to the PDF ﬁle will not help.
A simple script can verify the table’s (in)validity without
parsing the ﬁle by comparing the positions of PDF objects
with their xref entries. StegoTorus may try to adjust xref
tables to match the embedded hidden payload, but changing
even a single character in a PDF ﬁle results in multiple
format errors and is detectable by the most basic PDF parser.
Instead of replacing binary ﬁelds, a sophisticated steganogra-
phy module might craft PDF ﬁles that only show the hidden
content when rendered. This would complicate both the
client and the server and greatly reduce performance, making
the system unusable by Tor and other low-latency transports.
Furthermore, a simple script can extract the encoded text
from PDF ﬁles (e.g., using the pdftotext Unix command)
and perform linguistic veriﬁcation, although this test may not
be feasible at line speeds.

B. Passive attacks on StegoTorus-HTTP

C. Active and proactive attacks on StegoTorus-HTTP

The StegoTorus paper acknowledges several passive at-
tacks, including (1) discrepancies between the typical pat-
terns of GET requests and the StegoTorus imitation, and (2)
abnormal changes in cookies due to the embedding of hidden
payloads. The list in the paper is incomplete, illustrating how
difﬁcult it is to foresee all the ways in which an imitation
may deviate from the genuine protocol.

Exploiting discrepancies in ﬁle-format semantics.
Requirement: Content
Adversary: Passive, LO/OB/OM
StegoTorus-HTTP embeds hidden trafﬁc inside innocuous-
looking documents that appear to have been requested by the

7While the IETF standard [21] prohibits browsers from opening more
than two concurrent connections to the same server, some Web servers allow
this restriction to be circumvented [11]. Concurrent connections, however,
exhibit a characteristic pattern [2] not mimicked by StegoTorus.

Fingerprinting HTTP server.
Requirements: Correct, Err, Soft
Adversary: Proactive, LO/OB/OM
The HTTP module in StegoTorus does not actually run
an HTTP server. It responds to HTTP requests such as
GET, HEAD, OPTIONS, and DELETE simply by replaying
responses from its database. A censor may use an HTTP
server ﬁngerprinting tool to submit requests to the server
and analyze its responses to determine whether (a) the
server generates a consistent software ﬁngerprint, and (b)
the server’s reaction to erroneous and invalid requests is
consistent with its ﬁngerprint. This test can be active (the
censor manipulates requests sent by the clients) or proactive
(the censor generates his own probe requests).

We used the httprecon tool [30] to send 9 types of
requests: GET existing - a GET request for an existing

73

resource like the server’s front page; GET long request - a
very long (> 1024 bytes in URI) GET request for an existing
resource; GET non-existing - a GET request for a non-
existing resource, e.g., a randomly generated ﬁle name; GET
wrong protocol - a GET request with a non-existing protocol
version, e.g., HTTP/9.8; HEAD existing - a HEAD request
for an existing resource; OPTIONS common - an OPTIONS
request, which is used by HTTP clients to determine the
options and/or requirements associated with a resource or
the server’s capabilities; DELETE existing - a request to
delete an existing resource; TEST method - a non-existing
HTTP method called TEST; Attack request - a GET request
that tries to access a URI which includes well-known attack
patterns, e.g., SQL injection and cross-site scripting.

Table III summarizes how the HTTP module of the Stego-
Torus server reacts to these 9 tests. In summary, StegoTorus
fails the tests and can be easily distinguished from any real
HTTP server. In particular, StegoTorus does not generate ap-
propriate error responses to invalid and malformed requests.
This attack is feasible even for an OB censor who can
record at line speed the IP addresses of all packets destined
to port 80 and ﬁngerprint these addresses afterwards.

Manipulating HTTP requests.
Requirements: Err
Adversary: Active, LO/OB/OM
A censor can tamper with a suspected StegoTorus connection
and observe the server’s reaction to modiﬁed, possibly
malformed HTTP requests. Most of the proactive attacks
listed above can be carried out in this manner. For instance,
the censor can man-in-the-middle a connection and modify
the client’s request so that it asks for a non-existing URI.
If the server returns “404 Not Found,” the censor drops
the error response and replays the client’s original HTTP
request. If the server returns “200 OK,” it is a tell-tale sign
that the server is not an HTTP server but a (poor) imitation.

IX. DETECTING CENSORSPOOFER

SIP packets explicitly contain the name and version of
the SIP client. Therefore, each CensorSpoofer connection
must mimic a speciﬁc client. The CensorSpoofer prototype
mimics Ekiga.8 The attacks in this section exploit
the
discrepancies between CensorSpoofer and genuine Ekiga,
but would apply to any other SIP client, too.

Manipulating the tag ﬁeld.
Requirement: Soft
Adversary: Active, LO/OB/OM
SIP messages use random-looking tags in their headers to
identify a SIP session [51]. CensorSpoofer’s spoofer replaces
these tags with the hash of the spoofed IP address [59, § 6.4].
If a censor manipulates the spoofed address, the hash will
no longer verify and the CensorSpoofer client will close
the call, similar to a genuine client’s reaction to the change

8http://www.ekiga.net

of callee’s IP address. Unfortunately, this enables another,
much cheaper attack. The censor can simply change the tag
ﬁeld containing the hash to a different, valid tag value. A
CensorSpoofer client will terminate the call because the new
tag is not the hash of the spoofed IP address, but a genuine
SIP client will continue the call.

SIP probing.
Requirements: SideProtocols, Soft, Err
Adversary: Active, LO/OB/OM
The SIP connection between a client and a CensorSpoofer
server is relayed through a public Ekiga registrar located
outside the censoring ISP. Because the censor cannot verify
the callee’s IP address, the CensorSpoofer server can put a
spoofed address in its SIP messages.

What the censor can do, however, is probe the callee
by sending SIP messages to this IP address and checking
whether a genuine SIP client is listening. This is the exact
attack that CensorSpoofer aimed to prevent. To choose
the IP addresses to be spoofed,
the spoofer performs a
random nmap scan [59, Algorithm 1] and picks any address
that does not return either “closed” or “host seems down”
on the SIP, RTP, and RTCP ports. As mentioned in [59],
the censor cannot tell for sure whether these addresses are
running a SIP client.

Unfortunately, there is an easier way for the censor to
verify whether an IP address is running a SIP client. As
speciﬁed in the SIP standard [51], “more than one user
can be registered on a single device at the same time.”
Typical SIP clients thus respond to any SIP request that
looks for any SIP ID, even if it is not coming from the VoIP
provider’s registrar. We conﬁrmed this behavior for several
popular SIP clients, including Ekiga, PhonerLite,9 Blink,10
and Twinkle,11 on various operating systems.

The main functionality of a SIP registrar is to discover the
current IP addresses of dynamic SIP IDs. As speciﬁed in the
SIP standard, “registration is used for routing incoming SIP
requests and has no role in authorizing outgoing requests.”
If the censor knows the current IP address of a suspected
SIP client, he can directly call it instead of going through a
registrar. This is the basis of SIP probing.

We describe several SIP probing tests. In our experiments,
all of them were effective in distinguishing a CensorSpoofer
callee from a genuine Ekiga client—see Table IV. All IP
addresses in our tests satisfy the address selection algorithm
of [59]. Some of the tests may produce different results
depending on the type of the callee’s SIP client; however,
the censor can always identify the callee’s client from the
SIP messages and adjust the tests accordingly.

Send a SIP INVITE. The censor can call a fabricated SIP
ID at the suspected IP address by sending a SIP INVITE.

9http://phonerlite.de/index en.htm
10http://icanblink.com/
11http://www.twinklephone.com/

74

RESPONSES TO DIFFERENT httprecon REQUESTS BY STEGOTORUS SERVER AND REAL HTTP SERVERS.

Table III

HTTP request

Real HTTP server

GET existing

Returns “200 OK” and sets Connection to keep-alive

Returns “404 Not Found” since URI does not exist
Returns “404 Not Found”

GET long request
GET non-existing
GET wrong protocol Most servers produce an error message, e.g., “400 Bad Request”
HEAD existing
OPTIONS common
DELETE existing
TEST method
Attack request

Returns the common HTTP headers
Returns the supported methods in the Allow line
Most servers have this method not activated and produce an error message
Returns an error message, e.g., “405 Method Not Allowed” and sets Connection=Close
Returns an error message, e.g., “404 Not Found”

StegoTorus’s HTTP module
Arbitrarily sets Connection to
either keep-alive or Close
No response
Returns “200 OK”
Returns “200 OK”
No response
No response
No response
No response
No response

DISTINGUISHING CENSORSPOOFER FROM GENUINE SIP CLIENTS.

Table IV

Attack
Manipulate tag in SIP OK
SIP INVITE to
fakeID@suspiciousIP
SIP INVALID
SIP BYE with
invalid SIP-ID
Drop RTP packets
(only for conﬁrmation)

Imitation requirement
Soft
SideProtocols
Soft, Err
SideProtocols,Err
SideProtocols
Soft, Err
SideProtocols
Soft, Network

Adversary
LO/OB/OM Nothing

Typical SIP clients (e.g., Ekiga)

CensorSpoofer

Client closes the call

LO/OB/OM

Respond with “100 Trying” and “180 Ringing”,
“483 Busy Here”, “603 Decline”, or “404 Not Found”

LO/OB/OM Respond “400 BadRequest”

LO/OB/OM

LO/OB/OM

Respond “481 Call Leg/Transaction
Does Not Exist”
Terminate the call after a time period depending on
the client, may change codec in more advanced clients.

Nothing

Nothing

Nothing

Nothing

A genuine SIP client returns a status message, e.g., “100
Trying” and “180 Ringing”, or “483 Busy Here”, or “603
Decline”, or “404 Not Found”. CensorSpoofer returns noth-
ing and, furthermore, cannot ever mimic the proper response
because, by design, it does not receive the censor’s INVITE.

Send an invalid SIP message. In response to any message
not deﬁned by the SIP standard, a genuine SIP client returns
“400 BadRequest [Malformed Packet]”. CensorSpoofer re-
turns nothing. In contrast to the SIP INVITE probe, this test
is completely transparent to genuine callees.

Send a message for a non-existing call. Each SIP call has a
unique ID, which is negotiated in the call’s ﬁrst packet. If the
censor sends a SIP message (e.g., BYE) for a random call
ID, a genuine SIP client returns “481 Call Leg/Transaction
Does Not Exist”. CensorSpoofer returns nothing. This test,
too, is transparent to genuine callees.

To prevent these SIP probing attacks, a CensorSpoofer
spoofer may change its IP address selection algorithm and
use similar probes to ﬁnd addresses that are running genuine
SIP clients. This signiﬁcantly reduces the set of addresses
that can be used for spooﬁng. The nmap-based selection
algorithm of [59], which is less accurate than SIP probing,
ﬁnds only 12.1% of 10, 000 random IP addresses to be
suitable for spooﬁng. Our SIP probes to 10, 000 random
addresses did not return a single host running IETF-based
VoIP software such as Ekiga. The main reason is that pro-
prietary VoIP services like Skype, Oovoo, and Google Voice
are signiﬁcantly more popular than IETF-based services.

Instead of Ekiga, CensorSpoofer may attempt to mimic
a more popular proprietary service. This imitation will be
easily detectable due to CensorSpoofer’s use of spoofed IP
addresses. Genuine clients react in a certain way to probes

and manipulated messages, but CensorSpoofer cannot mimic
the right reaction because it does not actually receive the
probes sent to the spoofed IP address. This is a fundamental
design ﬂaw that cannot be ﬁxed.

Manipulating upstream packets.
Requirements: SideProtocols, Soft, Network
Adversary: Active, LO/OB/OM
According to the standard [53, § 6], the primary function
of RTCP is “to provide feedback on the quality” of RTP
sessions. This feedback may be used for “control of adaptive
encodings,” so one might expect that changes in network
bandwidth during an RTP session would result in RTCP
negotiations as clients adjust their VoIP codec. Nevertheless,
none of the tested VoIP clients, including Ekiga, Blink,
PhonerLite, and Twinkle, appear to react when RTP and
RTCP packets are dropped at various rates. Only dropping
all RTP packets for 10 seconds to 2 minutes, depending on
the client, results in the client terminating the call.

This allows easy detection of imitated sessions. Dropping
all RTP packets will cause a genuine RTP session to close,
but a CensorSpoofer session will not react. This attack is
acknowledged in [59], but described as expensive because it
interrupts genuine sessions. Note, however, that the censor
can use it only for conﬁrmation, e.g., for calls that failed
SIP probing tests. If a more advanced implementation of
RTP/RTCP adjusts codecs according to the network condi-
tions, this behavior must be imitated, too.

X. RELATED WORK

Pﬁtzmann and Hansen [45] proposed deﬁnitions for
privacy-related concepts including unobservability. Unob-
servability has been interpreted as anonymity or plausible

75

deniability in various systems [8, 37], none of which hide
the fact that a given user is participating in the system. We
do not consider such systems in this paper because they are
easily blockable and thus not censorship-resistant.

Several proposals for unobservable systems assume that
the participants share some secret not known to the censors.
An Infranet [20] client sends a special sequence of HTTP
requests to a friendly Web server who decodes the requested
URL and steganographically hides its content inside images
returned to the client. The identities of such servers must
be hidden from the censors. In Collage [14], a client and
a server secretly agree on websites with user-generated
content, e.g., ﬂickr.com, and use steganography to commu-
nicate through these sites. To achieve sender unobservability,
Nonesuch [26] steganographically hides data inside mes-
sages submitted to public Usenet newsgroups and dispatches
them through a cascade of mixes that probabilistically detect
and remove cover trafﬁc until the hidden message reaches
its intended recipient. None of these systems support low-
latency communications like Web browsing.

Pluggable Tor transports. To evade IP address ﬁltering,
many circumvention technologies rely on proxies such as
UltraSurf [57] and Tor bridges [17]. They face the problem
of distributing the proxies’ addresses to legitimate clients
while hiding them from the censors [39, 40].

With the emergence of advanced censorship techniques
like deep-packet inspection and active probing [63], hiding
the proxy’s address is not enough. A circumvention system
must also disguise is trafﬁc contents and patterns. Tor re-
cently adopted pluggable transports [46] that aim to remove
all content and pattern signatures characteristic of Tor.

Obfsproxy [44] is the ﬁrst pluggable Tor transport. It
tries to remove Tor-related content identiﬁers, but preserves
the patterns such as inter-packet times and packet sizes.
Therefore, it fails to achieve unobservability against today’s
censors [18]. Furthermore, Obfsproxy does not make Tor
trafﬁc look like another, “benign” protocol. This is the main
motivation for the recently proposed pluggable transports
that try to mimic Skype and/or HTTP (see Section III).

To evade proxy blocking, Flashproxy [22] proxies the traf-
ﬁc between a Tor client and a Tor bridge through short-term,
frequently changing proxies provided by Internet users who
visit volunteer websites helping Flashproxy. Flashproxy does
not attempt to mimic another protocol and our initial analysis
shows that it fails several requirements from Section V.
It fails Users: a Flashproxy client receives consecutive
incoming connections from geographically distributed IP
addresses and the lengths of these connections are similar
to typical Web browsing sessions. It also fails Content
and Pattern because it does not completely remove the
characteristic content and statistical patterns of Tor trafﬁc.

Other pluggable Tor transports include Dust [62], which
(as opposed to

deﬁnes a new format

for packet-level

connection-level) obfuscation, and FTE [19], a system for
imitating arbitrary packet formats. As we show in this paper,
packet-level imitation is insufﬁcient for unobservability.

Decoy routing. An alternative approach to unobservable
circumvention is decoy routing [27, 64]. In this approach,
a client steganographically hides her request to a blocked
destination inside trafﬁc sent to non-blocked destinations. A
friendly “decoy” router intercepts this trafﬁc, extracts the
request, and deﬂects it to the true destination. While not yet
implemented, trafﬁc shaping is essential in decoy routing
systems to protect against trafﬁc analysis [27].

In general, decoy routing systems do not mimic other
protocols and are outside the scope of our study. Further-
more, a recent study [52] shows that an adversary capable
of changing routing decisions can effectively block decoy
routing systems if they are deployed by only a few ISPs.

XI. LESSONS AND RECOMMENDATIONS

Unobservability may very well be the most important
property of censorship-resistant communication systems.
Users of these systems run a very real risk of imprisonment
and even death, and extra care must be taken to ensure that
censorship circumvention solutions offered to them provide
meaningful privacy and anonymity protection.

First, a thorough understanding of the adversaries is a
must. Systems like SkypeMorph, StegoTorus, and Censor-
Spoofer deploy ad-hoc defenses against large-scale trafﬁc
analysis, yet leave their communications trivially recogniz-
able even by very weak, local censors. Real-world censors
are much more likely to look for tell-tale local deviations
from genuine protocols (Section IV-C) than run sophisticated
statistical algorithms on ISP-wide trafﬁc traces.

Second, unobservability by imitation is a fundamen-
tally ﬂawed approach, unlikely to ever succeed due to the
daunting list of requirements that an imitator must satisfy
(Section V). The failure of all proposed parrot circumvention
systems to achieve unobservability conﬁrms this conclusion.
In particular, it is not enough to simply mimic a popular
protocol. To achieve unobservability, the parrot must mimic
a concrete implementation and be compatible with every
implementation-speciﬁc quirk and bug (a similar observation
has been made in other contexts such as HTML ﬁltering [7]
and ﬁle parsing [36]). For example, StegoTorus’s imitated
HTTP server is very distinct from any known HTTP server
and thus trivially recognizable. Mimicking side protocols
is especially difﬁcult due to their complex, dynamic inter-
dependences and correlations. As we demonstrated,
the
absence of such dependences is a dead giveaway of an
imitation. Some imitation ﬂaws are impossible to ﬁx at any
cost. For example, in the asymmetric, spooﬁng-based design
of CensorSpoofer, the imitator cannot see the censor’s probes
and thus cannot mimic appropriate responses.

Third, partial

imitation is worse than no imitation
at all. For example, Tor trafﬁc may be recognizable by

76

certain trafﬁc patterns, but this requires fairly sophisticated
analysis of multiple ﬂows. On the other hand,
the not-
quite-Skype imitation performed by SkypeMorph is easily
recognizable given even a short observation of a single ﬂow.
Users of SkypeMorph, StegoTorus, and similar systems may
be putting themselves at greater risk than the users of plain
Tor because these ostensibly “unobservable” Tor transports
are more distinct than Tor itself!

One promising alternative is to not mimic, but run the
actual protocol, i.e., move the hidden content higher in
the protocol stack. For example, FreeWave [28] hides data
in encrypted voice or video payloads sent over genuine
Skype, while SWEET [29] embeds it in email messages.
This approach is well-known in steganography [15]: the
covert information is always encoded into the features of
an actual cover medium (e.g., an image), as opposed to
synthesizing the medium. Embedding low-latency network
services like Tor into another protocol is a challenging task,
however. As in steganography, much research is needed to
ﬁnd the right balance between the unobservability of hidden
messages and communication efﬁciency. For example, sizes
of datagrams containing hidden messages may appear statis-
tically anomalous in comparison to regular Skype datagrams.
On the positive side, detection of such anomalies typically
requires large-scale analysis of multiple ﬂows and thus OM
capabilities, raising the technical threshold for the censors.

Acknowledgments. We are grateful to Suman Jana for his
insights and to Zack Weinberg for helping us understand
StegoTorus. This research was supported by the Defense
Advanced Research Agency (DARPA) and SPAWAR Sys-
tems Center Paciﬁc, Contract No. N66001-11-C-4018, NSF
grant CNS-0746888, and the MURI program under AFOSR
Grant No. FA9550-08-1-0352.

REFERENCES

[1] D. Adami, C. Callegari, S. Giordano, M. Pagano, and T. Pepe.
Skype-Hunter: A Real-Time System for the Detection and
Classiﬁcation of Skype Trafﬁc. Int. J. Communication Sys-
tems, 25(3):386–403, 2012.

[2] K. Allen. A Software Developer’s Guide to HTTP. http://

odetocode.com/articles/743.aspx.

[3] J. Arkko, E. Carrara, F. Lindholm, M. Naslund, and K. Nor-

rman. MIKEY: Multimedia Internet KEYing. RFC 3830.

China

[4] Joining
Internet.
like-china-iran-australia-ﬁlter-internet.

Filter
http://www.foxnews.com/scitech/2009/12/15/

Australia

Iran,

and

to

[5] S. Baset and H. Schulzrinne. An Analysis of the Skype Peer-

to-Peer Internet Telephony Protocol. In INFOCOM, 2006.

[6] S. Baset and H. Schulzrinne. Skype Relay Calls: Measure-

ments and Experiments. In INFOCOM, 2008.

[7] D. Bates, A. Barth, and C. Jackson. Regular Expressions
In WWW,

Considered Harmful in Client-side XSS Filters.
2010.

[8] O. Berthold, H. Federrath, and S. K¨opsell. Web MIXes: A
System for Anonymous and Unobservable Internet Access.
In Design Issues in Anonymity and Unobservability, 2000.

[9] D. Bonﬁglio and M. Mellia. Tracking Down Skype Trafﬁc.

In INFOCOM, 2008.

77

[10] D. Bonﬁglio, M. Mellia, and M. Meo. Revealing Skype
Trafﬁc: When Randomness Plays With You. In SIGCOMM,
2007.

[11] R. Breen. Circumventing Browser Connection Limits for
Fun and Proﬁt. http://www.ajaxperformance.com/2006/12/18/
circumventing-browser-connection-limits-for-fun-and-proﬁt/,
2006.

[12] Bridge Easily Detected by GFW. https://trac.torproject.org/

projects/tor/ticket/4185, 2011.

[13] Tor BridgeDB. https://gitweb.torproject.org/bridgedb.git/tree.
[14] S. Burnett, N. Feamster, and S. Vempala. Chipping Away
In

at Censorship Firewalls with User-Generated Content.
USENIX Security, 2010.

[15] I. Cox, J. Kilian, F. T. Leighton, and T. Shamoon. Secure
Spread Spectrum Watermarking for Multimedia. IEEE Trans-
actions on Image Processing, 6(12), 1997.

[16] Defeat Internet Censorship: Overview of Advanced Technolo-
gies and Products. http://www.internetfreedom.org/archive/
Defeat Internet Censorship White Paper.pdf, 2007.

[17] R. Dingledine and N. Mathewson. Design of a Blocking-
Resistant Anonymity System. https://svn.torproject.org/svn/
projects/design-paper/blocking.html.

[18] M. Dusi, M. Crotti, F. Gringoli, and L. Salgarelli. Tunnel
Hunter: Detecting Application-layer Tunnels with Statistical
Fingerprinting. Computer Networks, 53(1):81–97, 2009.

[19] K. Dyer, S. Coull, T. Ristenpart, and T. Shrimpton. Format-
Transforming Encryption: More than Meets the DPI. Cryp-
tology ePrint Archive, Report 2012/494, 2012.

[20] N. Feamster, M. Balazinska, G. Harfst, H. Balakrishnan, and
Infranet: Circumventing Web Censorship and

D. Karger.
Surveillance. In USENIX Security, 2002.

[21] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,
P. Leach, and T. Berners-Lee. Hypertext Transfer Protocol –
HTTP/1.1. RFC 2616.

[22] D. Fiﬁeld, N. Hardison, J. Ellithrope, E. Stark, R. Dingledine,
D. Boneh, and P. Porras. Evading Censorship with Browser-
Based Proxies. In PETS, 2012.

[23] E. Freire, A. Ziviani, and R. Salles. On Metrics to Distinguish
Skype Flows from HTTP Trafﬁc. J. Netw. Sys. Management,
17(1-2):53–72, 2009.

[24] S. Gianvecchio and H. Wang. Detecting Covert Timing

Channels: An Entropy-based Approach. In CCS, 2007.

[25] S. Guha, N. Daswani, and R. Jain. An Experimental Study

of the Skype Peer-to-Peer VoIP System. In IPTPS, 2006.

[26] T. Heydt-Benjamin, A. Serjantov, and B. Defend. Nonesuch:
a Mix Network with Sender Unobservability. In WPES, 2006.
[27] A. Houmansadr, G. Nguyen, M. Caesar, and N. Borisov. Cirri-
pede : Circumvention Infrastructure Using Router Redirection
with Plausible Deniability. In CCS, 2011.

[28] A. Houmansadr, T. Riedl, N. Borisov, and A. Singer.

I
Want My Voice to Be Heard: IP over Voice-over-IP for
Unobservable Censorship Circumvention. In NDSS, 2013.

[29] A. Houmansadr, W. Zhou, M. Caesar, and N. Borisov.
SWEET: Serving the Web by Exploiting Email Tunnels.
CoRR, abs/1211.3191, 2012.

[30] The httprecon Project.

http://www.computec.ch/projekte/

httprecon/.

[31] Internet Censorship Listed: How Does Each Country Com-
http://www.guardian.co.uk/technology/datablog/2012/

pare?
apr/16/internet-censorship-country-list.

[32] Iran

Reportedly

Trafﬁc.
iran-reportedly-blocking-encrypted-internet-trafﬁc.

Blocking

Internet
http://arstechnica.com/tech-policy/2012/02/

Encrypted

[33] Italy Censors Proxy That Bypasses BTjunkie and Pirate Bay

Block. http://tiny.cc/fcmksw.

[34] J. Knockel, J. Crandall, and J. Saia. Three Researchers,
Five Conjectures: An Empirical Analysis of TOM-Skype
Censorship and Surveillance. In FOCI, 2011.

[35] J. McNamee.

The Slide from Self-regulation to Cor-

porate Censorship. http://www.edri.org/ﬁles/EDRI selfreg
ﬁnal 20110124.pdf.

[36] S. Jana and V. Shmatikov. Abusing File Processing in

Using IP Spooﬁng for Censorship-Resistant Web Browsing.
In CCS, 2012.

[60] Z. Weinberg, J. Wang, V. Yegneswaran, L. Briesemeister,
S. Cheung, F. Wang, and D. Boneh. StegoTorus : A Camou-
ﬂage Proxy for the Tor Anonymity System. In CCS, 2012.

[61] T. Wilde.

Knock

Bridges
knock-knock-knockin-bridges-doors, 2012.

Doors.

Knock

on
https://blog.torproject.org/blog/

Knockin

Malware Detectors for Fun and Proﬁt. In S&P, 2012.

[62] B. Wiley. Dust: A Blocking-Resistant Internet Transport

[37] D. Kesdogan, M. Borning, and M. Schmeink. Unobservable
Surﬁng on the World Wide Web: Is Private Information
Retrieval an Alternative to the MIX based Approach?
In
PET, 2002.

[38] C. Leberknight, M. Chiang, H. Poor, and F. Wong. A
Taxonomy of Internet Censorship and Anti-censorship. http://
www.princeton.edu/∼chiangm/anticensorship.pdf.

[39] D. McCoy, J. Morales, and K. Levchenko. Proximax: A
In

Measurement Based System for Proxies Dissemination.
FC, 2011.

[40] J. McLachlan and N. Hopper. On the Risks of Serving When-
ever You Surf: Vulnerabilities in Tor’s Blocking Resistance
Design. In WPES, 2009.

[41] H. Moghaddam, B. Li, M. Derakhshani, and I. Goldberg.
SkypeMorph: Protocol Obfuscation for Tor Bridges. In CCS,
2012.

[42] S. Murdoch and G. Danezis. Low-Cost Trafﬁc Analysis of

Tor. In S&P, 2005.

[43] S. Murdoch and S. Lewis. Embedding Covert Channels into

TCP/IP. In Information Hiding, 2005.

[44] A Simple Obfuscating Proxy.

https://www.torproject.org/

projects/obfsproxy.html.en.

[45] A. Pﬁtzmann and M. Hansen. Anonymity, Unobservability,
and Pseudonymity: A Consolidated Proposal for Terminology.
In Design Issues in Anonymity and Unobservability, 2000.

[46] Tor: Pluggable transports.

https://www.torproject.org/docs/

pluggable-transports.html.en.

[47] L. Pt´aˇcek. Analysis and Detection of Skype Network Trafﬁc.

Master’s thesis, Masaryk University, 2011.

[48] S. Radicati and Q. Hoang. Email Statistics Report, 2011-

2015, 2011.

[49] H. Roberts, E. Zuckerman,

2007
Circumvention Landscape Report: Methods, Uses, and
Tools.
http://cyber.law.harvard.edu/sites/cyber.law.harvard.
edu/ﬁles/2007 Circumvention Landscape.pdf.

and J. Palfrey.

[50] J. Rosenberg, R. Mahy, P. Matthews, and D. Wing. Session

Traversal Utilities for NAT (STUN). RFC 5389.

[51] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston,
J. Peterson, R. Sparks, M. Handley, and E. Schooler. SIP:
Session Initiation Protocol. RFC 3261.

[52] M. Schuchard, J. Geddes, C. Thompson, and N. Hopper.

Routing Around Decoys. In CCS, 2012.

[53] H. Schulzrinne, S. L. Casner, R. Frederick, and V. Jacobson.
RTP: A Transport Protocol for Real-Time Applications. RFC
3550.

[54] D. Schwartz and B. Sterman. Method and Apparatus for
Server-side NAT Detection. US Patent US 2006/0187912 A1.
[55] Ten ways to discover tor bridges. https://blog.torproject.org/

blog/research-problems-ten-ways-discover-tor-bridges.

[56] How Governments Have Tried to Block Tor.

https://svn.

torproject.org/svn/projects/presentations/slides-28c3.pdf.

[57] Ultrasurf. http://www.ultrareach.com.
[58] Virtual Distributed Ethernet. http://vde.sourceforge.net/.
[59] Q. Wang, X. Gong, G. Nguyen, A. Houmansadr, and
N. Borisov. CensorSpoofer: Asymmetric Communication

78

Protocol. http://blanu.net/Dust.pdf.

[63] P. Winter and S. Lindskog. How the Great Firewall of China

Is Blocking Tor. In FOCI, 2012.

[64] E. Wustrow, S. Wolchok, I. Goldberg, and J. Halderman.
In

Telex: Anticensorship in the Network Infrastructure.
USENIX Security, 2011.

APPENDIX A.

BACKGROUND ON SKYPE

A. Overview of Skype protocol

Skype client start up. Every time the Skype application
launches, the Skype client (SC) checks for a Skype HTTP
update by connecting to ui.skype.com. The next step is
selecting the neighbor supernode (NSN). The client goes
through its supernode cache (also called host cache), which
is the “shared.xml” ﬁle with the list of nearby supernodes
(SNs), and sends batches of UDP probes. The ﬁrst SN who
returns a positive response is selected as the NSN. A Skype
UDP probe is an exchange of messages between SC and SN
to discover the Skype network and its characteristics. There
are two kinds of UDP probes, long and short, consisting of
four- and two-packet exchanges, respectively. These packets
have characteristic sizes [1] and contents [47].

SC then connects to the Skype network by opening a TCP
connection to the selected NSN, using the same port as UDP
probing. If the port is blocked, SC tries ports 80 and 443. If
TCP connection establishment fails, SC reruns UDP probes
to ﬁnd another NSN. SC and NSN then perform Skype TCP
handshake, which involves six messages. Their payloads
are encrypted, but the handshake packets have characteristic
sizes and the TCP PSH ﬂag set [1, Fig. 2].

The ﬁnal step is Skype TCP authentication. SC connects
over TCP to Skype’s central login server (LS) to get a
certiﬁcate that SC uses to authenticate to other Skype nodes.
This exchange involves several messages with the PSH ﬂag
set. The number of messages varies for different LSes and
under different network conditions [47], but they exhibit
characteristic sizes and patterns [5].

Making Skype calls. To make a call, a Skype client uses its
TCP connection with the neighbor supernode (NSN) to ﬁnd
the callee’s IP address and Skype port. The caller then uses
UDP probes to check network connectivity—in particular,
whether its own UDP port is open and whether its host
is behind NAT. If the callee is not behind NAT, then the
caller initiates a TCP connection to the callee and sends the
ringing signal. Finally, if the callee accepts the call, a UDP
connection is established for transferring the call data [47].

If the callee is behind NAT, then the caller, using the
SN as a relay, tells the callee to send a UDP packet to the
caller’s IP address/Skype port in order to add a NAT entry
for the call. The call then proceeds as without NAT. If both
the caller and the callee are behind NAT, they use the SN
to send UDP packets to each other. If Skype cannot bypass
NAT/ﬁrewall, the call is handled by a relay and all trafﬁc is
encapsulated in an encrypted TCP stream.
Unrestricted connection (both SCA and SCB have public IP
addresses). After probing multiple peers with UDP probes,
SCA establishes a TCP connection to SCB and sends
several signaling messages over it. This TCP connection is
kept alive until the end of call. Voice and/or video contents
are sent over a UDP connection between SCA and SCB.
NAT/ﬁrewall connection (SCA and/or SCB are located
behind a NAT or a ﬁrewall). In this case, SCA sends the
signaling information to SCB through the SNs. If only
SCA is behind NAT, SCA and SCB are usually able to
establish a direct UDP connection after the signaling [47].
Otherwise, SCA ﬁnds appropriate relay nodes, and SCA
and SCB directly connect to a relay which exchanges trafﬁc
between them. For fault tolerance and backup, several relays
are typically used [47]. Most calls use different relays for
the caller-to-callee and callee-to-caller ﬂows [6].

If the Skype TCP connection used for signaling is closed,
the UDP connection also closes. Furthermore, Skype clients
periodically send Skype UDP pings, which consist of two
keep-alive packets, in order to preserve their “online” status
in the Skype network. These packets can be identiﬁed by
the “0x02” string in their function ﬁeld.

B. Passive detection of Skype trafﬁc

There are many techniques for detecting Skype traf-
ﬁc [1, 5, 6, 10, 47]. They recognize characteristic strings sent
unencrypted during Skype sessions (content analysis) and/or
characteristic trafﬁc patterns such as packet sizes (pattern
analysis). The tests below work against all versions of Skype.

T1: HTTP update messages. When the Skype client (SC)
starts up, it makes an HTTP connection to ui.skype.com to
check for updates to the client software [47].

T2: Login messages. In order to authenticate itself, SC
needs to obtain a certiﬁcate from Skype’s login server (which
could be a Skype supernode) conﬁrming the client’s Skype
identity. Unlike software update messages, logins are not
handled by a single, known server, thus login messages
cannot be easily detected by IP address matching. They can
be recognized, however, by characteristic sizes and contents.
In particular, the second message in a login TCP connection
carries the header 0x170301 in plaintext.

T3: Start of Message (SoM) ﬁelds in UDP packets.
Skype uses special headers, so called SoM ﬁelds, for its
UDP packets [10]. The SoM ﬁelds are present in both UDP
probes and UDP packets carrying the media stream. They

are not encrypted and have speciﬁc values for different
kinds of packets. In particular, ID and Fun ﬁelds are easily
recognizable in a SoM header [10].

The ﬁrst two bytes of SoM contain an ID that uniquely
identiﬁes that message. This value is randomly generated
by the sender and copied in the receiver’s reply. Fun is a 5-
bit ﬁeld obfuscated into the third byte of SoM and revealed
by applying the 0x8f bitmask. Previous research [10, 47]
investigated the values of Fun for different messages. For
instance, ox02, 0x03, 0x07, and 0x0f indicate signaling
messages during the login process and connection manage-
ment, while 0x0d indicates a data message, which may
contain encoded voice or video blocks, chat messages, or
data transfer chunks.

T4: Packet sizes. A UDP probe consists of four packets [1].
The second packet is 11 bytes long, while the length of the
fourth packet reveals the outcome of that UDP probe.

A Skype TCP handshake consists of six messages with
the PSH ﬂag set and payload sizes of 27 and 4 bytes for the
fourth and sixth packets, respectively.

Authentication messages from a Skype client to the login
server include four or more packets with the PSH ﬂag set;
the ﬁrst two have 5-byte payloads.

An HTTP update request returns a single unencrypted
packet from ui.skype.com. This packet has a ﬁxed value in
the ﬁrst 29 bytes for the Linux version of Skype and another
ﬁxed value in bytes 95-124 for the Windows version [47].

T5: Packet timings and rate. Skype audio and video trafﬁc
exhibits a characteristic packet timing pattern, depending on
the codec used. SILK, Skype’s audio codec, samples at 8,
12, 16, or 24 KHz, resulting in four ranges of data rates for
UDP ﬂows carrying Skype audio [47, Fig. 3.6]. While Skype
voice packets are about 150 bytes, video packets are around
1380 bytes. Sample inter-packet gaps and size distribution
for a Skype video call can be found in [47, Fig. 3.10].

T6: NAT traversal. Once SC starts up,
it performs a
sequence of tests to detect whether it is behind NAT or
a ﬁrewall. SCs use different variants of the STUN [50]
protocol for NAT traversal.

T7: Periodic message exchanges. Skype is a P2P system,
and SCs frequently exchanges messages with other Skype
nodes to detetermine their online/ofﬂine status [47]. In par-
ticular, each SC establishes about ﬁve short TCP connections
per hour and performs UDP probes on approximately thirty
Skype peers per hour [47, Fig. 3.4].

task
T8: Typical Skype client behavior. Each typical
performed by a SC, like searching for a contact or placing
a call, generates characteristic trafﬁc (Appendix A-A).

T9: TCP control channel. Skype uses various TCP control
channels. In particular, each call is accompanied by a TCP
signaling connection, described in Appendix A-A, which
remains active during the call.

79

