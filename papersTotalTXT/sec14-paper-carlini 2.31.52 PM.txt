ROP is Still Dangerous: Breaking Modern Defenses

Nicholas Carlini and David Wagner, University of California, Berkeley

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/carlini

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXROP is Still Dangerous: Breaking Modern Defenses

Nicholas Carlini

David Wagner

University of California, Berkeley

Abstract

Return Oriented Programming (ROP) has become the ex-
ploitation technique of choice for modern memory-safety
vulnerability attacks. Recently, there have been multi-
ple attempts at defenses to prevent ROP attacks. In this
paper, we introduce three new attack methods that break
many existing ROP defenses. Then we show how to break
kBouncer and ROPecker, two recent low-overhead de-
fenses that can be applied to legacy software on existing
hardware. We examine several recent ROP attacks seen in
the wild and demonstrate that our techniques successfully
cloak them so they are not detected by these defenses. Our
attacks apply to many CFI-based defenses which we argue
are weaker than previously thought. Future defenses will
need to take our attacks into account.

1

Introduction

The widespread adoption of DEP, which ensures that all
writable pages in memory are non-executable, has largely
killed classic code injection attacks. In its place, Return
Oriented Programming (ROP) has become the attack tech-
nique of choice for nearly all modern exploits of memory-
safety vulnerabilities. In a ROP attack, the attacker does
not inject new code; instead, the malicious computation
is performed by chaining together existing sequences of
instructions (called gadgets) [27].

In response to this, there has been a large effort to ﬁnd
defenses that protect against ROP attacks. Defenses fall in
to two broad categories. The ﬁrst category of defenses re-
lies on recompilation to remove potential gadgets from the
program binary or to enforce the Control-Flow Integrity
(CFI) [4] of the binary. The other category of defenses at-
tempts to transparently protect legacy binaries using run-
time protections.

In this paper, we present three attack methods that can
be combined to break many existing ROP defenses from
both of these categories. Our ﬁrst method breaks the con-
ventional wisdom that it is difﬁcult to mount attacks in
a fully call-preceded manner, that is, where the instruc-
tion before each gadget is a call. Many CFI-based de-
fenses rely upon policies similar to this. Next, we show

that while most existing ROP attacks consist entirely of
short gadgets, it is possible to mount attacks which con-
sist of long gadgets as well. Therefore, defenses that dis-
tinguish a ROP attack from normal execution by looking
for a sequence of short gadgets are not secure. Finally,
we examine defenses that record a limited history of the
execution state of a process. We show it is possible to
effectively clear out any history kept by these defenses,
rendering them ineffective.

We use these attacks to break two recent state-of-the-
art runtime defenses, kBouncer [23] and ROPecker [11].
These defenses are particularly interesting because they
can be deployed on existing hardware, have nearly zero
performance overhead, and do not require binary rewrit-
ing. kBouncer [23] takes advantage of hardware support
for recording indirect branches and examines this history
at each system call in order to prevent ROP attacks from
issuing any malicious syscalls. ROPecker [11] extends
kBouncer in novel ways. In addition to checking for any
signs of a ROP attack at each system call, ROPecker ad-
ditionally checks for attacks at various points throughout
program execution.

We show that both of these schemes are broken. While
they may detect existing ROP attacks, we give ways of
modifying a ROP attack so it will not be detected by ei-
ther of these defenses. The attacks we develop in break-
ing these defenses are also applicable to many recent CFI-
based approaches, and discuss how our work can be ap-
plied to four in particular.

This paper makes three contributions:

1. We introduce three novel ROP attacks methods that

demonstrate weaknesses in multiple defenses.

2. We demonstrate these attacks on kBouncer and
ROPecker, two state-of-the-art ROP defenses. We
modify real-world exploits, which these defenses
were shown to prevent, to bypass them.

3. Our attacks provide a baseline set of attacks that can

be used to evaluate future ROP defenses.

USENIX Association  

23rd USENIX Security Symposium  385

386  23rd USENIX Security Symposium 

USENIX Association

2IntroductiontoROPAttacksReturnOrientedProgramming(ROP)[27]isageneral-izationofreturn-into-libc[24]attackswhereanattackercausestheprogramtoreturntoarbitrarypointsintheprogram’scode.Thisallowsonetoperformmaliciouscomputationwithoutinjectinganynewmaliciouscodebyonlycontrollingtheprogram’sexecutionﬂow.IthasbeenshownthatROPcanperformTuring-completecomputa-tion[30].Weprovideaverybriefoverviewofreturnori-entedprogramminginthissection.Foramorecompleteintroduction,wereferthereaderto[7,25,27].AROPexploitconsistsofmultiplegadgetsthatarechainedtogether.Eachgadgetperformssomesmallcom-putation,suchasloadingavaluefrommemoryintoareg-isteroraddingtworegisters.InaROPattack,theattackerﬁndsgadgetswithintheoriginalprogramtextandcausesthemtobeexecutedinsequencetoperformataskotherthanwhatwasintended.Gadgetchainingisachievedbyinﬂuencingindirectjumpsexecutedbytheprogram.Eachgadgetbeginswithsomeusefulinstructions(e.g.,movrax,rbx)andendswithanindirectjump(e.g.,retorjmp*rcx).Theat-tackerchainsgadgetstogetherbycontrollingthetargetofagadget’sindirectjumptopointtothebeginningofthenextgadgetinthesequence.InaclassicROPattack,gad-getsendwiththeretinstructionandtheattackerchainsgadgetsbywritingappropriatevaluesoverthestack.ManyROPattacksuseunintendedinstructionse-quences.Becausex86instructionsarevariable-width,itispossiblethatapotentiallyusefulgadgetsequenceexistswhenstartingatanoffsetthatwasnotintendedtobethebeginningofaninstruction.Ourattacksdonotrelyonunintendedinstructions.InFigure1,wegiveanexampleROPexploitthatadds0x32400tothevaluestoredataddress0x4a304120.Thisexploitbeginsbyinitializingtworegisters.Itthenreadsthevaluestoredataddresseax,storesitintoeax,addsebxtoeax,andstoresthisvaluebackintomemory.AddressSpaceLayoutRandomization(ASLR).OnecommondefenseforROPattacksisASLRwhichworksbyrandomlymovingthesegmentsofaprogram(includ-ingthetextsegment)aroundinmemory,preventingtheat-tackerfrompredictingtheaddressofusefulgadgets.De-spiteASLR,ROPattacksarestillcommoninthewildfortworeasons.First,ifevenasinglemodulehasASLRdisabled,aROPattackmaybeformedaroundonlythecodeinthatmodule.Second,anattackermayuseanin-formationdisclosurevulnerabilitytode-randomizesomemodule[29].Figure1:AnexampleROPexploitwhichaddsthecon-stant0x32400tothewordataddress0x4a304120.Attheleftisthestackoftheprocesswiththeaddressesofthegadgetsandthevaluestoinitializetheregisters.Atrightaretheinstructionsatthoseaddresses.3OurThreeAttackPrimitivesWehaveidentiﬁedthreebuildingblocksthatareusefulinattackingROPdefenses:•Call-PrecededROP.Normally,inawell-structuredprogram,everyretinstructionreturnsbacktoanin-structionthatimmediatelyfollowsacorrespondingcall.ROPattacksdeviatefromthispattern.There-fore,manyROPdefensesensurethateveryretin-structionalwaystargetsaninstructionthatimmedi-atelyfollowssomecall.Ourattackdemonstratesthatthispolicyisnotsufﬁcient:ROPattacksarestillpossibleevenwhenreturnsarerestrictedinthisway.•EvasionAttacks.Itiscommonfordefensesthatmonitorprogramexecutionatruntimetohaveamethodofclassifyingexecutionaseither“normalexecution”or“gadget”.Evasionattacksinvolveus-inggadgetsthatthedefenseclassiﬁesas“normal.”•HistoryFlushing.Somedefensesmaintainonlyalimitedamountofhistoryaboutexecutionandin-spectthishistoryperiodically.Wecanbypassde-fenseswiththispropertybyﬂushingthetruehistory(cleansingthehistoryofallsignsoftheROPattack)andthenpresentinganew,fakeviewofhistorythatthedefensewillnotclassifyasanattack.Each of these three attack primitives bypasses a common
defense mechanism. This section gives more detail about
each of these three primitives. We then combine them in
different ways to mount our full attacks on kBouncer [23]
and ROPecker [11] in the following sections.

3.1 Call-Preceded ROP
The call-preceded policy. We say that an instruction is
call-preceded if the instruction immediately preceding it
is a call instruction. Many ROP defenses [6, 23, 32, 34]
apply the following policy: any time a ret instruction is
executed, its target must be a call-preceded instruction.

This policy seems helpful for defending against ROP
attacks.
In well-structured programs, calls and returns
usually come in pairs. Any address that is returned to
was almost always pushed by a call instruction previ-
ously. In a ROP attack, gadgets use the ret instruction
to chain gadgets together, so this policy dramatically lim-
its the space of candidate addresses where gadgets can be
chosen from. For instance, one evaluation found that only
6% of gadgets are call-preceded [23]. Thus, one might
intuitively expect the call-preceded policy to signiﬁcantly
increase the difﬁculty of mounting a ROP attack.
Using only call-preceded gadgets. Despite this intu-
ition, we ﬁnd that it is possible to mount ROP attacks in
a fully call-preceded manner, where all gadgets start at a
call-preceded address. The key idea is we allow gadgets to
be more complex. This increases the space of candidate
gadgets enough to ﬁnd many call-preceded gadgets. By
allowing our gadgets to be long and contain direct jumps
or even conditional jumps, we ﬁnd many more useful gad-
gets. In our experiments (see § 8.2), 70KB of binary code
was sufﬁcient to mount fully call-preceded ROP attacks.

3.2 Evasion Attacks
Classiﬁcation-based defenses. Other ROP defenses
work by monitoring the runtime behavior of a process and
try to detect ROP attacks by classifying segments of ex-
ecution as either “gadget” or “non-gadget”, using some
signature that is intended to characterize attributes of ROP
gadgets. One of the most common approaches used to
classify execution, as used in [11, 23], uses a length-based
classiﬁer. Existing ROP attacks tend to consist of long se-
quences of short gadgets, and so these defenses use this as
their heuristic to classify gadgets.

These defenses separate the execution trace into seg-
ments of ordinary instructions, separated by indirect in-
structions (e.g., returns, indirect jumps). A length-based
defense classiﬁes each segment as gadget or non-gadget
by examining its length: a short segment is classiﬁed as a
gadget and a long segment as a non-gadget. If the defense

observes too many short segments within some window,
it reports a ROP attack.
Using gadgets that look like benign execution. A
powerful attack on such defenses is to look for instruc-
tion sequences that would be classiﬁed by the defense as
a non-gadget, but that perform some useful computation.
These can then be used as stealthy gadgets in a ROP at-
tack.

Length-based classiﬁers are particularly easy to evade.
A simple attack is to use long gadgets, since these will be
incorrectly classiﬁed by the defense as non-gadget. We
demonstrate that it is possible to mount a ROP attack that
contains a mixture of both short and long gadgets, thus
evading many published detectors.

More generally, one could imagine future ROP de-
fenses that rely on other heuristics for distinguishing ROP
attacks from normal program execution. An evasion at-
tack is one that will be classiﬁed by the defense as normal,
but in reality allows the attacker to mount a ROP attack.

3.3 History Flushing
History inspection defenses. There are many runtime
defenses that inspect program execution at different points
throughout its execution. Typically, these defenses keep
only a limited amount of history about the program’s exe-
cution, and so must decide whether an attack is occurring
or not based upon information saved in the recent past.
Usually, performance considerations rule out constantly
monitoring all execution, so this inspection process is only
invoked at certain points (e.g., when the application issues
a system call).
Using gadgets to hide history. Such defenses can be
fooled by preventing them from seeing any evidence of a
ROP attack. We perform the ROP attack when they are
not watching, periodically performing enough innocuous
actions to wipe the history clean of any evidence of the
past ROP attack before the defender’s inspection process
is invoked. While the defender is running, we do not at-
tempt to make progress towards our attack goal. Instead,
we insert effective no-op instructions so that the defender
does not see any evidence of attack.

Though similar, this attack is different from an evasion
attack. An evasion attack attempts to make progress in
the attack while being continuously monitored by the de-
fender. In a history ﬂushing attack, there is a period of
time when the defender is not running, when we make
forward progress. Before the defender runs, we clear out
this history so it is not visible to the defender, but do not
attempt to make forward progress while the defender is
watching. After the defender has made its observation,
we continue with our attack.

For instance, kBouncer uses the Last Branch Record, a

USENIX Association  

23rd USENIX Security Symposium  387

388  23rd USENIX Security Symposium 

USENIX Association

hardwarefeaturethatrecordsthe16mostrecentindirectjumps.Ourhistory-ﬂushingattackonkBouncerperformsthebulkoftheROPattack,thenperforms16innocuousindirectjumpstoremovetheevidenceoftheROPattackfromtheLastBranchRecord.Asweshow(§8.3),thispreventskBouncerfromdetectingtheROPattack.4AttackGoal&ThreatModelAttackGoal.Thegoalofeachofourattacks,with-outlossofgenerality,istoissueasinglesyscall.Itisusuallyenoughtoissueamprotect(onLinux)orVirtualProtect(onWindows)systemcalltomakeapageinmemorybothwritableandexecutable;afterthat,exploitationistrivial.1Thisisnottheonlypossiblegoalanattackermayhave.Thereareothermethodsofattackthatdonotinvolveis-suingsystemcalls[10].Wedonotconsidertheminthiswork,althoughourresultssuggesttheseattacksareequallypossible,andinsomecaseseventrivial.ThreatModel.Ataminimum,weassumethatanat-tackerhasaknownexploitthatallowscontrolofthein-structionpointerinthefuture.Astackoverﬂowissuf-ﬁcient;aheapoverﬂowthatallowsanarbitrarymemorywritetoafunctionpointerisalsosufﬁcient;asisdirectlyoverwritingotherfunctionpointers.Weassumetheat-tackerknowsthatthedefenseispresentandknowshowitworks.WeassumethatDEPisenabled,sonopageisbothwritableandexecutable.WefocusonthecasewheretheprogramcontainsatleastonelibrarywhoseexecutableregionhasnotbeenrandomizedwithASLR,orwhereallmoduleshaveASLRenabledbutthereexistsamemorydisclosurevulnerability,asthisisthesituationthatmod-ernROPattackstypicallyexploit.Wealsoassumethatthereexistssomewayofrunningarbitrarycodeifthenewdefenseswerenotpresent.Wedonotclaimtocreateattacksthatallowrunningarbitrarycodeinallsituations;weonlyhopetoshowthatifitispossibletomountaROPattackwhenthedefenseisnotpresent,thenitispossiblewhenitispresent.5DefeatingkBouncer5.1OverviewofkBouncerPappasetal.introducedkBouncer[23],aschemethatusesindirectbranchtracingtodetectROPattacks.Atahighlevel,kBouncerperiodicallypausesexecutionofthepro-gram,inspectsrecentexecutionhistory,andtheneitherallowstheprocesstoproceedorkillsit.1Alternatively,ifwecanexecutetheexecvesyscall,wecanspawnasecondprocessrunninganarbitraryprogram.Figure2:OverviewofourhistoryhidingattackonkBouncer.WemountatraditionalROPattack,insertanumberofinnocuousgadgetstohidethisfromkBouncer,andﬁnallyrestoreregistersandissuethedesiredsyscall.kBouncerusestheLastBranchRecord(LBR),afea-tureofmodernIntelCPUs,toinspectthelast16indirectbranchestakeneachtimetheprograminvokesasystemcall.kBouncercheckstwopropertiesofthehistorystoredintheLBR.First,itveriﬁesthatallretinstructionsintheLBRreturnedtoacall-precededaddress.Second,iftheeightmostrecentindirectbranchesareallgadget-like,theprocessiskilled.kBouncerdeﬁnesasequenceofin-structionsasgadget-likeifthereexistsaﬂowofexecutionfromtheﬁrstinstructionexecutedtoanyindirectbranchinunder20instructions.2kBouncerisveryefﬁcient:itonlyneedstochecktheLBRduringsystemcallsandonlychecks16differententriesintheLBR.5.2HistoryHidingAttack5.2.1AttackOverviewWedubourﬁrstattackonkBouncerthehistoryhidingat-tack(seeFig.2).AtthecoreofkBounceristheassump-tionthatanattackcanbedetectedbyinspectingthestateoftheprocessatthesyscallinterface,aftertheattackerhasalreadygainedcontrolofthesystemforapotentiallyunboundedperiodoftime.AftermountingatraditionalROPattacktopreparethestateofmemory(andpossiblydefeatASLR,ifrequired),weuseahistoryﬂushingattacktoclearevidenceoftheattackfromtheLBR.Finally,weuseanevasionattackandafewcarefully-chosengadgetstoissuethesyscall.WecallaprocessstatevalidifkBouncer’sinspectionmethodwillnotdetectanattackwhenrunfromthatstate.AstateisvalidifalloftheentriesintheLBRwhosesourceisaretinstructionhaveacall-precededdestina-tion,andifatleastoneofthelasteightentrieshasmore2kBouncercannotobservetheactualpathofexecutiontakendur-ingasequenceofinstructionsbetweentwoindirectjumps,soitcannotcountthenumberofinstructionsactuallyexecutedbetweentwoindirectjumps.Itcanonlyobservethebeginningandendofthatsequence.Forthisreason,kBouncerconservativelytreatsasequenceasgadget-likeifitstartswithaninstructionthatcanreachanindirectjumpinlessthan20instructions.than 20 instructions between source and the nearest indi-
rect branch. We show that it is easy to return to a valid
state while simultaneously maintaining control of the pro-
cess. The steps of the history hiding attack are as follows:
Initial exploitation.
Initially, we mount a traditional
ROP attack in whichever way is easiest. We ignore the
fact that kBouncer is running and use any gadgets we
would like, call-preceded or not. We then prepare mem-
ory so we are ready to make the syscall, but we do not
invoke it yet.
Hide the history. At this point in our exploit, we are
ready to make the syscall, but if we were to actually is-
sue it, kBouncer would detect an attack. To ﬁx this, we
must bring the process into a valid state without losing
our progress from the prior step. To do this we use the
history-ﬂushing primitive discussed previously. As a side
effect of using the ﬂushing primitive, the registers may be
clobbered, but important memory locations will remain
unchanged.
Restore registers and issue the system call. After
bringing the process into a valid state, we restore the regis-
ters to their desired values while maintaining a valid state.
Then, we issue the system call. This is via an evasion
attack: because the task is relatively simple, it can be ac-
complished with fewer than 8 call-preceded gadgets.

5.2.2 Initial Exploitation

This step prepares memory to make it as easy as possi-
ble to issue the syscall in as few gadgets as possible af-
ter the history has been ﬂushed.
In particular, we pre-
pare all of the arguments for the system call and save
them in some easily recoverable location. We make no
restrictions on the methods the attacker may use during
this step of our attack. Because we are going to hide our
history, kBouncer will not observe anything performed in
this step. Since ROP gadgets are Turing-complete, we are
able to perform arbitrary computation during this phase,
so this step is straightforward to implement.

5.2.3 Hiding the History
Hiding history through LBR ﬂushing. We use a
history-ﬂushing primitive, built from two gadgets (Fig. 3),
to remove all traces of our attack from the LBR:

1. A short ﬂushing gadget: a simple call-preceded gad-
get that performs a ret, and ideally does not modify
many registers.

2. A long termination gadget: a call-preceded gadget
that is long enough for kBouncer to not classify it
as a gadget:
there must be at least 20 instructions

pop ebp
ret

(1)

(2)

jmp A
...
A: mov
ret

eax,3

(3)

cmp eax,6
jbe B
...
B: ret

(4)

(5)

xor eax,eax
ret

mov [eax],0
ret

add [esp+17Ch],ebx
mov ebx,[esp+17Ch]
sub ebx,ebp
jmp A
...
A: add

[esp+64h],ebx

jmp B
...
B: mov

esi,[esp+1C0h]

lea eax,[esi*8-4]
sub eax,[esp+64]
and eax,7h
mov edi,[esp+64]
lea eax,[edi+eax+4]
shr eax,3
cmp eax,esi
jbe C
...
C: mov

eax,[esp+1C0h]

add esp,19Ch
pop ebx
pop esi
pop edi
pop ebp
ret

(a) Flushing Gadgets

(b) Termination Gadget

Figure 3: Examples of the two types of gadgets used by
our history-hiding attack on kBouncer. A ﬂushing gad-
get ﬂushes the contents of the LBR. A termination gadget
brings the system into a valid state.

along every possible control path from the start of
this gadget to any indirect branch.

We use these two gadgets as follows. First, we repeat-
edly use the ﬂushing gadget to completely clear the con-
tents of the LBR until it only contains the ﬂushing gadget
repeated 16 times. Though the LBR has been ﬂushed and
contains no history of the previous ROP attack, the state
is still not valid. If kBouncer were to be invoked at this
point, every entry in the LBR would be classiﬁed as a gad-
get by kBouncer and an attack would be detected.

We now use the termination gadget. The purpose of this
gadget is to bring the LBR into a valid state by making at
least one of the last eight entries in the LBR have length
greater than 20. That is, the termination gadget is used
to terminate kBouncer’s backwards search for gadget-like
sequences. We make no assumptions about the register
state after the termination gadget is executed:
the only
requirement is that after we use it, we still have control of
instruction ﬂow.

USENIX Association  

23rd USENIX Security Symposium  389

4a833dd4
4a833dd5
4a833ddb

dec
fmul
jne

ecx
[4A88BBC8h]
4A833DD4

Figure 4: An example of a context switch gadget found in
icucnv36.dll.

Note that during the ﬁrst step where the attacker pre-
pares memory, the attacker may perform arbitrarily com-
plex calculations. This may make it possible to initialize
registers and memory so that executing the ﬂushing gad-
gets and then the termination gadget results in exactly the
desired state to issue the syscall. However, this is not al-
ways possible. For example, the termination gadget may
set eax to 0, but issuing the syscall may require eax to
be 7. Our attack handles this situation by later restoring
register state (described below).

Because the termination gadget is over twenty instruc-
tions long and might contain conditional branches, it is
sometimes necessary to initialize registers and memory to
meet the preconditions for successful execution of the ter-
mination gadget. First, we need to ensure that any condi-
tional branches in the termination gadget will be followed
in a speciﬁc manner. Second, memory reads and writes
must not fault and crash the process. This is often as easy
as initializing registers to speciﬁc values before using the
termination gadget. We have found that termination gad-
gets are very common, and that it is often easy to ﬁnd
termination gadgets that perform only a few conditional
branches and memory reads and writes (see § 8.3.1).
History hiding by itself does not defeat kBouncer, but
it simpliﬁes the attacker’s job from expressing the entire
attack using call-preceded gadgets to expressing only the
ﬁnal step of the attack using call-preceded gadgets.

Hiding history through context switching. We also
found an alternative way to ﬂush history. The LBR is
shared across all user-space processes. This lets us ﬂush
the LBR using a single gadget, the context switch gad-
get. A context switch gadget is one that will run for many
seconds and will not contain any indirect branches. The
simplest way to ﬁnd such a gadget is to look for loops that
perform a very limited computation using only registers,
see Fig. 4 for one such example.

To ﬂush the LBR, we call the context switch gadget
once. Due to the number of cycles this gadget takes to ex-
ecute, it is almost certain that there will be several context
switches to other user threads during its execution. When
this happens, the other thread will write its own entries to
the LBR, ﬂushing all history of our prior attack. Even-
tually, when our context switch gadget ﬁnishes, the LBR
will be in a valid state as long as the other process was not
under attack, as the LBR is now full of innocuous entries

from the other process.

Future hardware could save and restore the LBR on
context switches, which would prevent this method of his-
tory ﬂushing. Therefore, we did not use this approach in
our case studies (§ 8); instead, we used ﬂushing and termi-
nation gadgets, which would sufﬁce to hide history even
if the LBR was saved and restored on each context switch.

5.2.4 Restoring Registers with Returns

We must now restore the registers to their desired values
in order for the syscall to proceed. This is by far the sim-
plest step and can be usually be accomplished with a few
gadgets that pop register values off the stack. kBouncer
will be able to observe each gadget we use, so each one
must be call-preceded and we must use fewer than eight.
This step is often very easy because of the x86 calling
convention: the procedure being called must restore al-
most all of the registers, so procedures tend to begin by
pushing all of the registers onto the stack and end by pop-
ping those values off to restore them. This allows us to
ﬁnd a gadget that pops all the registers off the stack and
then returns. Usually, we can ﬁnd all the (call-preceded)
gadgets we need in this way.

5.2.5 Restoring Registers without Returns

There are other ways to restore register state. We now
discuss four alternative methods. The ﬁrst two are existing
techniques that can be applied here, but in our experience
are difﬁcult to apply in practice due to the fact that we
must use fewer than eight gadgets. We have found the
later two techniques more applicable in practice.
ROP without return instructions. Checkoway et al.
found it is possible to mount a ROP attack by look-
ing for a pop followed by an indirect
jump (e.g.,
pop edx; jmp *edx) [8]. This instruction sequence is
functionally identical to a ret, and so can simply be used
in its place. However, these sequences are less common.
Jump Oriented Programming (JOP).
JOP attacks use
register-indirect jumps to chain gadgets together. Unfor-
tunately, each useful gadget must be followed by a dis-
patcher gadget, which is used for chaining. Since we must
restore register state with at most eight gadgets, if we want
to use JOP, we are limited to four useful JOP gadgets.
Using Non-Call-Preceded Gadgets. Occasionally,
it
may be easier to use non-call-preceded gadgets. We can
invoke a non-call-preceded gadget using a reﬂector gad-
get. A reﬂector gadget is a call-preceded gadget that ends
in a register-indirect jump; it can be used to jump to any
gadget we like, call-preceded or not. This is because
kBouncer imposes no constraints on indirect jumps. Our

390  23rd USENIX Security Symposium 

USENIX Association

experience is that this trick is rarely needed in practice,
but sometimes it makes constructing the attack easier.

Call Oriented Programming (COP). We have found
an alternate method of mounting a ROP-like attacks with-
out using ret instructions. We call our approach Call-
Oriented Programming (COP). Instead of using gadgets
that end in returns, we use gadgets that end with indirect
calls. This may at ﬁrst seem trivially similar to jump-
oriented programming, but there is one important distinc-
tion: indirect calls are usually memory-indirect (the lo-
cation to which control is transferred is determined by
a value in memory, not directly by the value of a regis-
ter). As a result, COP attacks do not require a dispatcher
gadget. In a COP attack, gadgets are chained together by
pointing the memory-indirect locations to the next gadget
in sequence. The initialization of these memory locations
can be done in advance.

This allows our attack to set up these memory locations
before the history hiding, then restore register state using
COP gadgets. As long as fewer than eight COP gadgets
are used, kBouncer will detect no attack. When mount-
ing a COP attack, it is trivial to directly issue the desired
system call as well: the ﬁnal gadget in the sequence will
point to the system call to be issued.

We have found that memory-indirect calls, and in par-
ticular COP gadgets, are common. They are even more
common than call-preceded gadgets that end in a ret.
There are two reasons why this is the case. First, with dy-
namically linked libraries, all calls to functions outside of
the current module are indirect calls, because the function
location is not known in advance. Second, most object-
oriented code relies on memory-indirect calls (e.g., the
vtable in C++).

COP attacks do not eliminate the need for ret-based
gadgets. Initializing a COP attack is much more difﬁcult:
the attacker must have control of program ﬂow, must over-
write speciﬁc indirect-call locations, and must control the
stack. This usually is not possible with a single exploit.
Therefore, it is natural to combine a ROP attack (for ini-
tial setup) with a COP attack (for restoring registers).

call [7C37A094]

A: mov eax,[_osplatform]

jmp B
...

B: dec eax
neg eax
sbb eax,eax
and eax,103
lea ecx,[ebp-0Ch]
push ecx
inc eax
push eax
push [EBP-8]
push [EBP-4]
call [VirtualProtect]

Figure 5: A call-preceded call to VirtualProtect in
msvcr71.dll. The attacker can return directly to A.

1. We can use a reﬂector gadget: a call-preceded gadget
that ends with a register-indirect jump. This allows
us to simply set a register to point to the function we
wish to call and then return to the reﬂector gadget.
This is the simplest approach if a reﬂector gadget can
be found.

2. It is still possible to exploit the desired function even
if no reﬂector gadgets are available. This is achieved
by ﬁnding an call to the desired function somewhere
in the program’s code and looking backwards in the
instruction sequence for a preceding call. Fig. 5
shows an example where the msvcr71.dll binary
directly calls VirtualProtect.

3. It is sometimes possible to return into the middle of
a desired function, right after a call instruction. For
example, execv() launches a shell with a string and
an array of arguments (Fig. 6). If we initially initial-
ize rax to contain a valid environment pointer, we
can call execv by returning directly to <execv+18>,
which is call-preceded.

5.2.6 Issuing the System Call

Any of these can be used to complete our attack.

The ﬁnal step of our attack is to issue the desired syscall.
We usually accomplish this by calling the appropriate
libc or kernel32 wrapper function.

There is one complication. We cannot simply return
directly to the beginning of the desired function (e.g.,
mprotect, VirtualProtect) as a normal ROP attack
would. When kBouncer is in place, this is not possible:
the attack would fail because the start of this function is
not call-preceded. We have found three different ways to
call a function without directly returning to it.

5.3 Evasion Attack
Our history hiding attack breaks kBouncer by taking ad-
vantage of its limited history. If kBouncer were extended
to have a complete view of history, would it become more
effective? We show that, even if the LBR were of inﬁnite
size, kBouncer could still be broken by an evasion attack.
Our attack is similar to the history hiding attack (§ 5.2),
except that the initial preparation phase is mounted us-
ing only call-preceded gadgets. This eliminates the need

USENIX Association  

23rd USENIX Security Symposium  391

<excve>:
push
mov
push
push
mov
mov
call
mov
mov
mov
call
mov
pop
pop
pop
ret

rbp
rbp,rsp
r14
rbx
r14,rsi
rbx,rdi
_NSGetEnviron
rdx,[rax]
rdi,rbx
rsi,r14
execve
eax,-1
rbx
r14
rbp

Figure 6: Disassembly of the execv function in libc on
our system. The call to NSGetEnviron allows a call-
preceded return directly into this function.

for a ﬂushing gadget, the only piece that an inﬁnite-LBR
kBouncer would preclude. Therefore, our attack consists
of a (call-preceded) setup, a (call-preceded) termination
gadget, followed by (call-preceded) register restoration
and syscall.

This yields a successful evasion attack on kBouncer.
By using only call-preceded gadgets and by breaking up
the chain of short gadgets with a long termination gad-
get, kBouncer can see the entire attack but still will not
recognize it as an attack. Our experiments show that if
over 70KB of program text is available, then there are
enough call-preceded gadgets that this attack is possible
(see § 8.2).

6 Defeating ROPecker

6.1 Overview of ROPecker
ROPecker [11] is a ROP defense that builds on ideas
found in kBouncer. ROPecker differs from kBouncer by
running its inspection method more frequently and in-
specting the program state more thoroughly at the time
of inspection. The actual policy it enforces is very similar
to the kBouncer policy.

In ROPecker, only a few pages are ever marked exe-
cutable at one time. We call these pages the executable
set. Whenever a page not in the executable set is exe-
cuted, a page fault is generated and ROPecker pauses pro-
cess execution to check for an attack. If ROPecker does
not detect an attack, it marks the new page as executable,
marks the least recently executed page as non-executable,

ROPecker’s detector

and resumes the process. ROPecker also runs its detector
whenever the process invokes a syscall as kBouncer does.
is more sophisticated than
kBouncer’s in that it looks at both the recent past and
projects forward into the near future. Similar to kBouncer,
ROPecker classiﬁes the current state as an attack if there
is a long chain of gadget-like sequences in the LBR (the
recent past). In addition, ROPecker attempts to emulate
what will happen in the near future once the process is re-
sumed. It counts the number of gadget-like sequences that
are about to execute. If the sum of the number of gadgets
found in the LBR and the number of gadgets looking for-
ward exceeds some threshold, ROPecker classiﬁes this as
an attack.

ROPecker’s emulation works by disassembling the in-
struction stream from the instruction that is about to ex-
ecute when the page fault occurs.
If there is a short
sequence of instructions that leads to an indirect jump,
ROPecker classiﬁes this as a potential gadget. ROPecker
will then emulate the effects of each of the instructions
leading to the indirect jump in order to compute where this
jump will go. ROPecker follows this indirect jump and
starts disassembling again. When it reaches an instruction
where there is not a short sequence of instructions leading
to an indirect jump, it stops the search. ROPecker then
counts the number of indirect jumps followed, and classi-
ﬁes each of those as gadgets.

ROPecker veriﬁes that from the current execution point
there are not 11 gadget-like sequences of instructions.3
ROPecker classiﬁes an instruction sequence as a gadget if
it contains six or fewer instructions ending in an indirect
branch, with no direct or conditional branches along the
way.

6.2 The Repeated History Hiding Attack
6.2.1 Attack Overview
We show how to break ROPecker using a repeated his-
tory hiding attack. This attack repeatedly invokes the
history-hiding primitive, introduced in § 3.3, just before
ROPecker’s detector is about to execute. We again deﬁne
a state to be valid if the inspection method will not detect
an attack. The state must be valid at two points in time:
whenever a new page is loaded in to the executable set and
whenever a syscall is executed.

Our attack alternates between three phases, as depicted
in Fig. 7. The loading phase loads useful pages into the
executable set. The attack phase invokes gadgets on these
pages. The ﬂushing phase mounts the history hiding at-
tack from § 5.2 using only gadgets from the pages that are
3The ROPecker paper does not pick a speciﬁc parameter for the max-
imum number of gadgets that may execute consecutively. It suggests this
number is chosen between 11 and 16, so we conservatively pick 11. Our
attacks are made easier if a larger number is chosen.

392  23rd USENIX Security Symposium 

USENIX Association

USENIX Association  

23rd USENIX Security Symposium  393

Figure7:AnoverviewoftherepeatedhistoryhidingattackonROPecker.Lngadgetsloadpagen.Ltloadstheterminationgadget.Gninvokesagadgetonpagen.Fisashortﬂushinggadget,andTisalongterminationgadget.intheexecutableset.Wemayneedtoexecuteeachofthesethreephasesmultipletimestoachieveourgoal.Weconcludewithoneﬁnalstepwhichactuallyissuesthede-siredsyscallafterrestoringtherequiredstate.Becauseweuseonlygadgetsintheexecutablesetduringeachattackphase,ROPecker’sdetectorwillexecuteonlywhennewpagesareloaded,whichallowsustoreasonaboutwhatwillbevisibletoROPecker.6.2.2AttackPhasesInitialization.Priortoourattack,weinsertatermina-tiongadget,whichwillstopROPeckerfromlookingfur-therbackintheLBR.ThislongterminationgadgetisidenticaltotheoneusedinthekBouncerattacks.ThisensuresthatwhenROPeckernextruns,itwillnotcountanyfunctionsonthecallstackpriortoinitializationasgadgets.LoadingPhase.Weloadusefulpagesintotheexe-cutablesetbyinvokingapageloadgadgetoneachpagewewantaddedtotheexecutableset.Apageloadgad-getisanycall-precededgadgetonthatpage,whichhastwoproperties:ﬁrst,itmustleavetheattackerwithcon-troloftheinstructionﬂow;andsecond,itmustnotcrashtheprocess.Thesetworequirementsarenotdifﬁculttomeet:anyusefulgadgetisalsoapageloadgadget.TheROPeckerdetectorwillrunimmediatelybeforeeachpageloadgadgetisinvoked.Afterinvokingeachsetofpageloadgadgetswecalltheterminationgadgettopreventthedetectorfromlookingforwardanyfartherintothefuture.ROPeckerwillnotdetectanattackbecauseeachse-quenceofpageloadgadgetsisimmediatelyprecededandfollowedbyaterminationgadget.Whenapagefaultoc-curs,ROPeckerwillcountthenumberofvisiblegadgetslookingbackwardsintheLBRandforwardsasfarasitcansee.Lookingbackwardswillstopatprecedingtermi-nationgadget,andlookingforwardwillstopatthesub-sequentterminationgadget.Thus,ROPeckerwillcountthenumberofpageloadgadgets.Bylimitingthenumberofconsecutivepageloadgadgets,theattackercanevadedetectionduringthisphase.AttackPhase.Nowthattheusefulpageshavebeenloaded,wecanuseanygadgetsonthesepagestomountanattack,ignoringanydefensewhichmayberunning.Aslongasweuseonlygadgetsonthesepages,thedefensewillnevertrigger.Recallthatthesethreephasesarerepeatedlyexecuted,sonooneattackphaseneedstoperformtheentireattack.Instead,theattackcanbedistributedamongmultipleat-tackphases,makingeachonesimpler.HistoryHiding.Afterinvokinggadgetsonthesepages,wenowusethehistoryﬂushingprimitivebeforethede-tectionmethodnextruns.WeusethesamemethodweappliedagainstkBouncertocleartheLBR.Inparticular,weinvokeashortﬂushinggadgetenoughtimestoﬁlltheLBRwithinnocuousentries,theninvokethelongtermi-nationgadget(whichwasloadedpreviously).WhentheROPeckerdetectornextruns,itwillseenoattackpriortothispointintime.6.2.3SegmentingtheAttackPayloadWhenmountingthisattack,wemustcarefullypickwhichtaskstoperformduringeachattackstep.Becausetheﬂushingandterminationgadgetsclobbersomeregisterstatebetweeneachattackstep,itisimportanttopicksmallindependentoperationsforeachstepoftheattack.Foranygivenattack,itmaynotbepossibletomodifyittoworkasanattackwhichbypassesROPecker.Instead,attacksmustbeformedwithROPeckerinmind.Eachstepintheattackmustbeconstructedtouseonlyalimitednumberofgadgets,sothatitsworkcanbesavedbeforeloadinginanewsetofgadgets.Often,westartbycomputingtheaddressofthedesiredlibcfunctionwewishtocall(e.g.,mprotect)eitherbyaddingaconstanttotheaddressofsomeotherfunctionin libc, or by loading it directly. We store the result in
memory. In the next attack step, we compute the address
of the page we wish to mark as executable (typically on
the stack). We continue in this way, computing any other
needed constants in separate attack steps. We then restore
register values and call mprotect on the desired page.
Finally we can execute a traditional payload with data we
have written to this page.

6.2.4 Selecting Pages to Load

Since the executable set can contain only a few pages at
one time, we must choose these pages with care. The
naive approach is to select each page to load for one use-
ful gadget on that page, and call each gadget exactly once.
We have found that this simple method works well in
practice in most cases. Because the ﬂushing and termi-
nation gadgets may clobber a few registers, we may need
reserve one or two of those gadgets to load and save reg-
isters to memory, so that a task can be partially completed
in one attack step.

A more advanced method is to pick pages that contain
multiple gadgets. In our evaluation, we found that in prac-
tice there tend to be many “useful” gadgets on the average
page. Thus, by selecting the pages carefully, we can ﬁnd
pages with enough useful gadgets. This is enough that we
can attack ROPecker even when the size of its executable
set is limited to just one or two pages.

6.2.5 Issuing the Syscall

Once we have executed sufﬁcient load/attack phases to set
up the state of the process, we append one ﬁnal step to
actually issue the desired syscall. This step is not executed
multiple times: it is done only once at the very end.

During this step, we ﬂush history, invoke the termina-
tion gadget, and then issue the syscall using one of the
three methods from § 5.2.6. We perform this step using
at most 10 gadget invocations so that ROPecker will not
detect an attack when it examines the LBR at the syscall.
Conveniently, it is possible to use any gadget in the
entire binary during this step, even if it is not contained
within the executable set. No page loading gadgets are
needed. This works because there will be at most 10
gadgets between the termination gadget and the syscall.
Thus, even though ROPecker’s detector may run during
this step (if we use a gadget that’s not in the executable
set), its count of the number of gadgets will be below 11,
the threshold for detecting an attack.

Note that, in particular, an attack which requires fewer
than ten gadgets to execute can skip the load/attack phases
and directly issue the syscall in this way.

6.3 The Evasion Attack
We now present the ROPecker evasion attack, an alter-
nate attack that would break ROPecker even if the size of
the executable set were reduced to just one page. As a
side beneﬁt, in our experience the evasion attack makes
it easier to automate attacks in practice than the repeated
history hiding attack of § 6.2.
At a high level, the idea is that we will let ROPecker
inspect the execution of our attack at arbitrary points
in time. We ensure that no matter when its detector
runs, it will never detect an attack. We achieve this
through an evasion attack similar to the one presented on
kBouncer (§ 5.3).
The ROPecker evasion attack works by inserting a ter-
mination gadget in between every ten useful gadgets.
When the detector runs, it will check forward and back-
ward to count the number of gadgets in use; there will
be fewer than 11 gadgets, the threshold for detection, so
ROPecker will not detect the attack.

The authors of ROPecker note that this attack may be
possible in § VII(b) of their paper [11]. They propose a
mitigation for such an attack. We show that even their
mitigation is broken.

The ROPecker mitigation. ROPecker detects an attack
if there are more than ten consecutive gadgets. The ex-
tended version of ROPecker records how many gadgets
existed in previous runs of the detector. It detects an at-
tack if the number of gadgets which executed in the last T
runs is larger than some threshold. While it is possible for
there to be 10 sequential gadget-like returns in benign pro-
gram execution, it is unlikely for there to be 10 sequential
gadget-like returns T times in a row.

Conceptually, this is analogous to running the detec-
tion mechanism both forwards and backwards, allowing
up to T − 1 long gadgets before stopping the search. An
attack is detected if the number of gadgets found by this
extended search is greater than some threshold.

This defense does not help against our repeated history
hiding attack.
In that attack, ROPecker only ever sees
as many gadgets as pages that are being loaded. This
constant is usually very small (e.g., two or four). The
ROPecker authors observed that benign execution does
occasionally execute four sequential gadget-like chains
(with frequency 0.58%). This frequency is large enough
that signaling an attack if there are four gadgets repeated
three times would cause too many false positives.

Breaking the mitigation. The extended version of
ROPecker can be broken by a simple modiﬁcation of our
evasion attack: instead of invoking the termination gad-
get once, invoke it T times in a row. We alternate making
one step of useful progress (with ten useful gadgets) with
invoking the termination gadget T times. This prevents

394  23rd USENIX Security Symposium 

USENIX Association

ROPecker from detecting consecutive long chains of gad-
gets. Instead, it sees a long chain followed by several short
chains, which will not trigger the defense.
Practicality. One might wonder whether evasion at-
tacks are practical.
If, between every ten useful opera-
tions, we must potentially destroy our progress, can we
achieve any useful computation?

We found it is still possible to perform useful tasks even
when inserting a termination gadget (or, potentially multi-
ple termination gadgets) in between every ten useful gad-
get (see § 8.3). We save register state to memory before
each termination gadget and restore it afterwards.
It is
only necessary to save and restore registers that are both
clobbered by the termination gadget and used by the rest
of our attack. In our experience, it is often possible to ﬁnd
termination gadgets that only clobber one or two registers.
This allows for many gadgets that make forward progress,
with a few dedicated to saving and restoring state.

6.4 Attack Comparison
These two attacks are useful in different circumstances.
The most important difference is when the detection
mechanism runs. In repeated history hiding, the detection
only ever runs after a history ﬂush, and so the defender
can never even see what the attacker is doing. In the eva-
sion attack, the defender is continuously monitoring the
attack progress. This leads to the key distinction between
the two attacks. In repeated history hiding, we have a very
limited set of gadgets, but may use them an unbounded
number of times before ﬂushing. In the evasion attack,
we have all of the gadgets in the program available to us,
but must ﬂush every ten gadgets.

7 Fixable Attacks on ROPecker

We now discuss several ways in which ROPecker is bro-
ken that our attack does not rely on. That is, the attacks
discussed in the previous sections work even if we improve
ROPecker’s detection mechanisms to prevent each of the
following speciﬁc attacks. We believe these modiﬁcations
are possible, and it is only the engineering difﬁculties of
obtaining a low overhead that explains why they are not
currently implemented. Because of this, we do not base
our previous attack on these ﬁxable implementation is-
sues.
Gadget deﬁnition does not allow any branches.
ROPecker’s deﬁnition of a gadget is overly speciﬁc and
does not allow gadgets to contain either direct or con-
ditional branches.
In comparison, we have found that
kBouncer’s deﬁnition of a gadget is strong: it is difﬁcult to
ﬁnd gadgets of length twenty or more that perform useful
computation.

ROPecker’s choice to not follow any direct or condi-
tional branches is a ﬂaw that, while allowing for a more
efﬁcient implementation, makes exploitation nearly triv-
ial. This decision allows an attacker to ﬂush the LBR,
and to stop the forward-inspection algorithm, with a no-
op-like gadget that jumps directly to a return instruction.
This form of gadget is pervasive in program binaries and
allows for a much simpler termination gadget that does
not clobber any register state.

In fact, when evaluating the practicality of our attacks
on kBouncer before becoming aware of ROPecker, nearly
all of our exploits contained at least one useful gadget that
would not be classiﬁed as a gadget by ROPecker’s deﬁni-
tion.
Gadget chain threshold is too short. ROPecker’s
choice to deﬁne gadgets as being a sequence of six or
fewer instructions makes it nearly trivial to ﬁnd gadgets
that have a predictable behavior while still being classi-
ﬁed as a non-gadget by ROPecker. For example, on 64-
bit systems, the gadget consisting of popping off registers
r10 through r15 followed by a ret is seven instructions
long: not only is this a useful gadget, it is very common.
ROPecker’s failure to recognize it as a gadget is a serious
limitation of ROPecker.
The set of risky system calls
is not complete.
ROPecker’s set of risky system calls is too limited and
needs to be updated to more closely match those used
in kBouncer. Because ROPecker is designed for Linux
and kBouncer for Windows, we cannot simply replace one
with the other. However, other than performance reasons,
there is no reason to not defend all system calls.

8 Evaluation

The attacks discussed in the previous sections are prac-
tical. We evaluate these attacks by modify real-world ex-
ploits, as well as by demonstrating that only 70KB of code
is needed to mount purely call-preceded attacks.

8.1 Our Tool
We built a tool to assist our efforts in ﬁnding attacks on
real-world exploits.
It does not automatically break ei-
ther of these two defenses, but assists in ﬁnding useful
gadgets. We wrote our tool as a 1K line Python pro-
gram. It takes as input a disassembled object ﬁle (from
objdump), and therefore only inspects intended instruc-
tion sequences: even though there may be unintended in-
struction sequences which are call-preceded, we ignore
these.4

4Even though ROPecker does not enforce gadgets are call-preceded,
we still use this tool to evaluate ROPecker, as we ﬁnd it is sufﬁcient to
identify useful sequences.

USENIX Association  

23rd USENIX Security Symposium  395

Binary
diff
grops
lsof
ltrace
grub-mkimage
strace
pic
apt-get
info
apt-ftparchive

Setup Flush
3
3
2
2
4
4
2
3
3
3

8
4
12
4
4
17
11
14
13
4

Syscall
2
4
3*
2
3
2*
3
2*
3*
2

Table 1: The number of gadgets for the three steps in
our kBouncer attack for binaries from /usr/bin/. En-
tries marked with an asterisk have success probability of
≥ 99.99%, the rest with 100%.

Our tool ﬁrst enumerates all potential call-preceded
gadgets. We implemented a simple symbolic execution
framework to determine the effects of each of these po-
tential gadgets. This system is not complete, but it mod-
els some of the effects of many common instructions.5 It
computes and outputs the path constraints that must hold
to follow the conditional branches in a gadget.
It also
outputs the list of modiﬁed memory locations, accessed
memory locations, and the new values of updated regis-
ters at the end of execution.

The tool returns a list of gadgets sorted by ease of use:
gadgets with fewer conditional branches and fewer mem-
ory locations which must be valid rise to the top. Each
gadget is marked with a hint on how it might be useful
(e.g., that the gadget is a memory-load gadget, or that it
computes the sum of two registers). It also provides us
with a list of termination gadgets, sorted by ease of use
and the number of other registers they clobber.

8.2 Fully Call-Preceded Attacks
How practical are fully call-preceded ROP attacks? Our
measurements indicate that they are quite practical. The
Q ROP compiler [26] is able to mount a ROP attack in
80% of binaries over 20KB in size. Given that only 6% of
gadgets Q ﬁnds are call-preceded, we would expect that
with 333KB of binary, we could achieve similar results.
We actually found that it is possible to exploit 10 out of
10 programs we analyzed of size 70KB or larger.

We analyzed 10 binaries from /usr/bin on Ubuntu

5The most important deﬁciencies in our tool are as follows: we im-
plement only the thirty most-used instructions (covering 99% of instruc-
tions used in our binaries), we ignore segment registers, we do not track
several of the ﬂags set by instructions, and we do not properly handle
referencing variable register widths. Despite this, we have found our
tool to be accurate in the vast majority of cases.

12.04. In particular, we selected the ﬁrst 10 binaries that
have ASLR disabled and have more than 20k instructions
(70KB binary size). In all 10 cases, we were able to ﬁnd
enough gadgets to mount a fully call-preceded history hid-
ing ROP attack on kBouncer. Table 1 shows, for each of
these ten binaries, the number of gadgets used for in each
of the three phases of our ROP attack. Attacks marked
with an asterisk have a success probability of ≥ 99.99%
due to the possibility of a module crossing a 32-bit bound-
ary. All other attacks have a 100% success probability.

In each of these binaries, we use only the code present
in the actual binary, not any other linked libraries. We are
not arguing that these binaries are vulnerable to attack; we
are only attempting to determine how much program text
is required to mount fully call-preceded attacks.

We believe there to be two main reasons why we were
so successful. First, we manually analyzed these binaries
in order to construct a ROP attack, whereas Q is an au-
tomated tool. However, given Q’s sophisticated analysis,
we do not believe this accounts for all of the difference.
We suspect that even though only 6% of gadgets are call-
preceded, they have more diversity and thus are dispro-
portionately likely to cover the space of different kinds of
gadgets that are needed.

8.3 Modifying Real-World Exploits
We now evaluate the difﬁculty of modifying real-world
exploits to bypass both kBouncer and ROPecker. To
choose our exploits, we pick the ROP attacks that were
shown to be prevented by kBouncer and ROPecker.

For kBouncer, we show how all four of these attacks

can be modiﬁed so kBouncer will not detect them.

We ﬁnally modify the one real-world exploit which

ROPecker is shown to prevent to bypass ROPecker.

8.3.1 kBouncer Exploits
We modiﬁed four real-world exploits to bypass kBouncer.
None of the modiﬁcations to these exploits took us sig-
niﬁcant effort. Once we were able to reproduce the ex-
ploit on our machine, each exploit took under half of a
day’s worth of work to make it bypass kBouncer. Given
the long and difﬁcult exploitation development process,
we do not think this is meaningfully harder, especially for
well-trained exploit developers.
MPlayer Lite r33063. This program [19] had a stack-
based buffer overﬂow vulnerability, which was ex-
ploited by overwriting the SEH pointer [20].
The
avcodec-52.dll does not have ASLR enabled. This
dll is 10MB, and contains plenty of gadgets: there were
748 potential termination gadgets with two or fewer con-
ditional branches. The ﬁrst of these that we tried worked,
and was given previously in Fig. 3(b).

396  23rd USENIX Security Symposium 

USENIX Association

Adobe Reader 9.3.4. This Adobe Reader exploit uses
a sophisticated JavaScript vulnerability and was built on
the Metasploit framework [1]. This exploit relied on
icucnv36.dll having ASLR disabled. This dll is
10MB and has 130 available termination gadgets with two
or fewer conditional branches. We created a ROP chain to
call VirtualProtect on a page and veriﬁed that code on
this page in memory could be executed.

Adobe Flash 11.3.300. An integer overﬂow caused this
vulnerability in Adobe Flash. This exploit was also built
with the Metasploit framework [2]. The exploit relied on
msvcr71.dll having ASLR disabled. This dll is 300KB
and has 64 available termination gadgets. In this exploit,
we were able to successfully change a page to be exe-
cutable and spawn another process.

Internet Explorer 8. The ﬁnal exploit we modiﬁed was
in IE8 and also used Metasploit [3]. This exploit was
the most difﬁcult for us to modify, and required a man-
ual stack-pivot to a controlled location so that we could
invoke VirtualProtect in a call-preceded manner. We
relied again on msvcr71.dll to spawn another process.

8.3.2 ROPecker Exploits

ROPecker was built as a Linux kernel module and was
shown to stop two exploits. One of these two exploits
by the authors is to exploit a 20-line example C program
with a trivial stack overﬂow from ROPEME [17]. The
other exploit is a real-world exploit in hteditor, which has
a published vulnerability [33] they veriﬁed they defend
against. Because they only evaluate their defense on one
binary, we have only this one binary to demonstrate our at-
tack on. We evaluate our two methods of attack (repeated
history hiding and evasion attacks) on this binary.

The public vulnerability disclosure included an ex-
ploitable version of the hteditor source. We downloaded
this and compiled it for our system with stack protection
disabled, as we want to test how well ROPecker defends
against attack, not how well stack canaries work.

Evasion attack. We successfully mounted an evasion
attack on hteditor. Our exploit required 12 gadgets. We
split the attack into two 10-gadget segments, with the sec-
ond segment calling execv by overwriting the GOT entry
for strlen and ﬁnding a call-preceded intended call to it.

Repeated history hiding attack. We successfully
mounted a repeated history hiding attack on hteditor as-
suming four pages in the executable set. Our attack con-
sisted of three phases. In the ﬁrst two phases we computed
the address of execv, and in the third we called it. In the
ﬁrst phase, we were able to use a gadget twice that we
loaded once.

9 Related Work

Randomization-based approaches. Address Space
Layout Randomization (ASLR) and Address Obfuscation
[5] were ﬁrst introduced to make it more difﬁcult to inject
shellcode, and were later applied to the text segment to
prevent ROP attacks. Shacham et al. demonstrated a
de-randomization attack [28] on PaX ASLR.

Address Space Layout Permutation (ASLP) [16] is
similar in many ways to ASLR but provides higher en-
tropy by permuting the locations of functions. Other de-
fenses extends this further by randomizing the addresses
of individual instructions [15, 31]. Another technique
replaces short sequences of instructions with alternate,
functionally-identical, equal-length sequence, hindering
an attacker’s ability to use unintended gadgets [22]. A
recent just-in-time code reuse attack [29] compiles ROP
on the ﬂy to bypass ASLR.
Control-Flow Integrity (CFI). Abadi et al. introduced
control-ﬂow integrity (CFI) [4] as a method of preventing
attacks by restricting jump, call, and return instructions
to follow the statically-determined control-ﬂow graph of
the program. Due to the difﬁculty of obtaining a precise
control-ﬂow graph of the program, many defenses choose
instead to enforce a less precise policy. Often, this policy
simply requires that returns be call-preceded, and indirect
calls point to the beginning of functions [34, 6, 32].

The attacks presented in this paper show these CFI
based defenses are weaker than previously thought. Since
call-preceded ROP is possible, most of these defenses can
be broken with that technique alone. Concurrent to this
work, a detailed examination of attacks on many CFI-
based schemes came to this same conclusion [14].
Runtime defenses. There are many other types of de-
fenses that can best be described as runtime defenses.
DROP [9] monitors the runtime behavior of the process
and, nearly identically to ROPecker, if there is a long con-
secutive sequence of returns, each of which contain fewer
than a ﬁxed length, the program is killed. Our work in this
paper constitutes a total break of DROP. ROPGuard [13]
contains several heuristics to detect ROP attacks. One
of these is the call-preceded defense introduced earlier.
ROPdefender [12] implements a shadow-stack and veri-
ﬁes that all returns exist somewhere on the shadow-stack.
Our work does not apply to shadow-stack defenses.
Recompilation-based defenses. Other defenses rely on
recompilation to remove gadget from the compiled binary.
G-Free [21] does this by removing unintended return in-
structions and encrypting return addresses, so that ret-
gadgets become nearly impossible to use. The return-less
kernel [18] entirely removes the c3 byte (the opcode of
ret) from all instructions, and replaces valid returns with
a lookup into a table containing the valid return sites.

USENIX Association  

23rd USENIX Security Symposium  397

10 Conclusion

In this paper, we have presented three building blocks
for ROP attacks that allow us to break two state-of-the-
art ROP defenses. We demonstrate the practicality of our
attacks by modifying real-world exploits to bypass these
defenses.

More broadly, our work disproves two pieces of con-
that ROP attacks only consist of
ventional wisdom:
short gadgets, and that ROP attacks cannot be effectively
mounted in call-preceded manner.

Future defenses must take care to guard against attacks
similar to ours. Speciﬁcally, we suggest two particular
requirements for future defenses. First, defenses should
argue either that they can inspect all relevant past history
or, if they have a limited history, that their limited view
of history cannot be effectively cleared out by an attacker.
Second, defenses that defend against one speciﬁc aspect
of ROP must argue that is a necessary component of one.
We believe an important open research question is to
determine what properties are truly fundamental about
ROP attacks that are different than typical program exe-
cution. We hope future work will explore how these fun-
damental differences can be exploited to create general-
purpose defenses.

Acknowledgments

We gratefully acknowledge Matthias Payer, Michael Mc-
Coyd, Thurston Dang, and the anonymous reviewers for
their helpful feedback. This research was supported
by Intel through the ISTC for Secure Computing, by
the AFOSR under MURI award FA9550-12-1-0040 and
MURI award FA9550-09-1-0539, and by the National
Science Foundation under grant CCF-0424422.

References

[1] Adobe CoolType SING Table “uniqueName” Stack Buffer
Overﬂow. http://www.rapid7.com/db/modules/exploit/
windows/browser/adobe_cooltype_sing.

[2] Adobe Flash Player 11.3 Kern Table Parsing Integer Overﬂow.
http://www.rapid7.com/db/modules/exploit/windows/
browser/adobe_flash_otf_font.

[3] Microsoft

Internet Explorer CButton Object Use-After-Free
https://www.rapid7.com/db/modules/

Vulnerability.
exploit/windows/browser/ie_cbutton_uaf.

[6] Tyler Bletsch, Xuxian Jiang, and Vince Freeh. Mitigating code-
reuse attacks with control-ﬂow locking. In Proceedings of the 27th
Annual Computer Security Applications Conference, pages 353–
362. ACM, 2011.

[7] Erik Buchanan, Ryan Roemer, Hovav Shacham, and Stefan Sav-
age. When good instructions go bad: generalizing return-oriented
programming to RISC. In Proceedings of the 15th ACM conference
on Computer and communications security, pages 27–38. ACM,
2008.

[8] Stephen Checkoway, Lucas Davi, Alexandra Dmitrienko, Ahmad-
Reza Sadeghi, Hovav Shacham, and Marcel Winandy. Return-
oriented programming without returns.
In Proceedings of the
17th ACM conference on Computer and communications security,
pages 559–572. ACM, 2010.

[9] Ping Chen, Hai Xiao, Xiaobin Shen, Xinchun Yin, Bing Mao, and
Li Xie. DROP: Detecting return-oriented programming malicious
code. In Information Systems Security, pages 163–177. Springer,
2009.

[10] Shuo Chen, Jun Xu, Emre C Sezer, Prachi Gauriar, and Ravis-
hankar K Iyer. Non-control-data attacks are realistic threats. In
Proceedings of the 14th conference on USENIX Security Sympo-
sium, volume 14, pages 12–12, 2005.

[11] Yueqiang Cheng, Zongwei Zhou, Miao Yu, Xuhua Ding, and
Robert H Deng. ROPecker: A generic and practical approach for
defending against rop attacks. NDSS14, 2014.

[12] Lucas Davi, Ahmad-Reza Sadeghi, and Marcel Winandy. ROPde-
fender: A detection tool to defend against return-oriented program-
ming attacks. In Proceedings of the 6th ACM Symposium on In-
formation, Computer and Communications Security, pages 40–51.
ACM, 2011.

[13] Ivan Fratric and Elias Bachaalany. ROPGuard. http://code.

google.com/p/ropguard/.

[14] Enes G¨oktas, Elias Athanasopoulos, Herbert Bos, and Gerogios
Portokalidis. Out of control: Overcoming control-ﬂow integrity.
In IEEE S&P, 2014.

[15] Jason Hiser, Anh Nguyen-Tuong, Michele Co, Matthew Hall, and
Jack W Davidson. ILR: Where’d my gadgets go? In Security and
Privacy (SP), 2012 IEEE Symposium on, pages 571–585. IEEE,
2012.

[16] Chongkyung Kil, Jinsuk Jim, Christopher Bookholt, Jun Xu, and
Peng Ning. Address space layout permutation (ASLP): Towards
ﬁne-grained randomization of commodity software. In Computer
Security Applications Conference, 2006. ACSAC’06. 22nd Annual,
pages 339–348. IEEE, 2006.

[17] Long Le. Payload already inside: Data re-use for ROP exploits.

Black Hat USA, 2010.

[18] Jinku Li, Zhi Wang, Xuxian Jiang, Michael Grace, and Sina
Bahram. Defeating return-oriented rootkits with return-less ker-
nels. In Proceedings of the 5th European conference on Computer
systems, pages 195–208. ACM, 2010.

[19] Nate M. MPlayer (r33064 Lite) Buffer Overﬂow + ROP exploit.

http://www.exploit-db.com/exploits/17124/.

[4] Mart´ın Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti.
Control-ﬂow integrity.
In Proceedings of the 12th ACM confer-
ence on Computer and communications security, pages 340–353.
ACM, 2005.

[5] Sandeep Bhatkar, Daniel C DuVarney, and Ron Sekar. Address ob-
fuscation: An efﬁcient approach to combat a broad range of mem-
ory error exploits.
In Proceedings of the 12th USENIX security
symposium, volume 120, 2003.

[20] Brian Mariani.

Structured exception handler exploitation.

http://www.exploit-db.com/wp-content/themes/
exploit/docs/17505.pdf.

[21] Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti,
and Engin Kirda. G-Free: defeating return-oriented programming
through gadget-less binaries. In Proceedings of the 26th Annual
Computer Security Applications Conference, pages 49–58. ACM,
2010.

398  23rd USENIX Security Symposium 

USENIX Association

[22] Vasilis Pappas, Michalis Polychronakis,

and Angelos D
Keromytis. Smashing the gadgets: Hindering return-oriented pro-
gramming using in-place code randomization. In Security and Pri-
vacy (SP), 2012 IEEE Symposium on, pages 601–615. IEEE, 2012.
and Angelos D
Keromytis. Transparent ROP exploit mitigation using indirect
branch tracing. In Proceedings of the 22nd USENIX Conference
on Security, 2013.

[23] Vasilis Pappas, Michalis Polychronakis,

[24] Jonathan Pincus and Brandon Baker. Beyond stack smashing: Re-
cent advances in exploiting buffer overruns. Security & Privacy,
IEEE, 2(4):20–27, 2004.

[25] Marco Prandini and Marco Ramilli. Return-oriented program-

ming. Security & Privacy, IEEE, 10(6):84–87, 2012.

[26] Edward J Schwartz, Thanassis Avgerinos, and David Brumley. Q:
In USENIX Security Symposium,

Exploit hardening made easy.
2011.

[27] Hovav Shacham. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In Proceed-
ings of the 14th ACM conference on Computer and communica-
tions security, pages 552–561. ACM, 2007.

[28] Hovav Shacham, Matthew Page, Ben Pfaff, Eu-Jin Goh, Nagen-
dra Modadugu, and Dan Boneh. On the effectiveness of address-
space randomization. In Proceedings of the 11th ACM conference
on Computer and communications security, pages 298–307. ACM,
2004.

[29] Kevin Z Snow, Fabian Monrose, Lucas Davi, Alexandra
Dmitrienko, Christopher Liebchen, and Ahmad-Reza Sadeghi.

Just-in-time code reuse: On the effectiveness of ﬁne-grained ad-
dress space layout randomization. In Security and Privacy (SP),
2013 IEEE Symposium on, pages 574–588. IEEE, 2013.

[30] Minh Tran, Mark Etheridge, Tyler Bletsch, Xuxian Jiang, Vincent
Freeh, and Peng Ning. On the expressiveness of return-into-libc
attacks.
In Recent Advances in Intrusion Detection, pages 121–
141. Springer, 2011.

[31] Richard Wartell, Vishwath Mohan, Kevin W Hamlen, and
Binary stirring: Self-randomizing instruction
Zhiqiang Lin.
addresses of legacy x86 binary code.
In Proceedings of the
2012 ACM conference on Computer and communications security,
pages 157–168. ACM, 2012.

[32] Yubin Xia, Yutao Liu, Haibo Chen, and Binyu Zang. CFIMon: De-
tecting violation of control ﬂow integrity using performance coun-
ters. In Dependable Systems and Networks (DSN), 2012 42nd An-
nual IEEE/IFIP International Conference on, pages 1–12. IEEE,
2012.

[33] ZadYree. HT Editor 2.0.20 Buffer Overﬂow (ROP PoC). http:

//www.exploit-db.com/exploits/22683/.

[34] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, L´aszl´o Szekeres,
Stephen McCamant, Dawn Song, and Wei Zou. Practical control
ﬂow integrity and randomization for binary executables. In Secu-
rity and Privacy (SP), 2013 IEEE Symposium on, pages 559–573.
IEEE, 2013.

USENIX Association  

23rd USENIX Security Symposium  399

