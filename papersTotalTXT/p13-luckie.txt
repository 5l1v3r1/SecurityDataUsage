Resilience of Deployed TCP to Blind Attacks

Matthew Luckie
University of Waikato
mjl@wand.net.nz

Robert Beverly

Naval Postgraduate School

rbeverly@nps.edu

Tiange Wu

CAIDA / UC San Diego
tiangewu@caida.org

Mark Allman

ICSI

mallman@icir.org

kc claffy

CAIDA / UC San Diego

kc@caida.org

ABSTRACT
As part of TCP’s steady evolution, recent standards have
recommended mechanisms to protect against weaknesses in
TCP. But adoption, conﬁguration, and deployment of TCP
improvements can be slow. In this work, we consider the re-
silience of deployed TCP implementations to blind in-window
attacks, where an oﬀ-path adversary disrupts an established
connection by sending a packet that the victim believes came
from its peer, causing data corruption or connection reset.
We tested operating systems (and middleboxes deployed in
front) of webservers in the wild in September 2015 and found
22% of connections vulnerable to in-window SYN and re-
set packets, 30% vulnerable to in-window data packets, and
38.4% vulnerable to at least one of three in-window attacks
we tested. We also tested out-of-window packets and found
that while few deployed systems were vulnerable to reset
and SYN packets, 5.4% of connections accepted in-window
data with an invalid acknowledgment number. In addition
to evaluating commodity TCP stacks, we found vulnerabili-
ties in 12 of 14 of the routers and switches we characterized –
critical network infrastructure where the potential impact of
any TCP vulnerabilities is particularly acute. This surpris-
ingly high level of extant vulnerabilities in the most mature
Internet transport protocol in use today is a perfect illus-
tration of the Internet’s fragility. Embedded in historical
context, it also provides a strong case for more systematic,
scientiﬁc, and longitudinal measurement and quantitative
analysis of fundamental properties of critical Internet infras-
tructure, as well as for the importance of better mechanisms
to get best security practices deployed.

Categories and Subject Descriptors
C.4 [Performance of Systems]: Measurement techniques;
C.2.0 [Computer-communication Networks]: Security

Keywords
TCP; security; blind attacks; middleboxes

c⃝ Association for Computing Machinery. ACM acknowledges that this contribu-
tion was authored or co-authored by an employee, contractor or afﬁliate of the United
States government. As such, the Government retains a nonexclusive, royalty-free right
to publish or reproduce this article, or to allow others to do so, for Government pur-
poses only.
IMC’15, October 28–30, 2015, Tokyo, Japan.
c⃝ 2015 ACM. ISBN 978-1-4503-3848-6/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2815675.2815700.

1.

INTRODUCTION

Despite the rich history of attacks against TCP [40, 38,
31, 14], and subsequent counter-measures [6, 36, 32, 15],
little recent empirical data exists on the current resilience
of deployed TCP implementations on the Internet. In this
paper, we focus on attacks against TCP by a “blinded” at-
tacker, i.e. an attacker that is oﬀ-path and does not observe
the TCP connection. Of particular interest is the vulnerabil-
ity of critical infrastructure, including web servers, routers,
and switches. For example, long-lived BGP and OpenFlow
TCP sessions are well-known to be vulnerable [8, 12], while
recent work [14] demonstrated new blinded attacks that pol-
lute web caches. As connection speeds increase and TCP re-
ceive windows grow, other long-lived TCP applications such
as ﬁle transfers, ssh, and rsync may become vulnerable.

We therefore take a multi-faceted measurement examina-
tion of both commodity operating system TCP stacks as
well as proprietary TCP implementations in routers and
switches. We adopted an oracle-based approach by simu-
lating a variety of blinded attacks. Our simulated exploits
sent packets (RST, SYN, data, both in and out of window)
that a blinded attacker might send as part of a brute-force
attack. We also examined ephemeral port selection strate-
gies in the wild, which impact the feasibility of blind attacks.
To test commodity TCP stacks as deployed in the wild,
we established connections to websites in the Alexa list [2],
and observed the behavior of their TCP implementations
in response to our oracle’s probing packets. We do not
claim that our results are representative of any particular
population; we tested websites to understand properties of
currently deployed web operating systems and middleboxes.
Nevertheless, we consider our results indicative of current
likely behavior in other populations, including systems that
support long-lived protocols including ssh and rsync.

In this population as measured in September 2015, we
found: (1) 38.4% of systems tested were vulnerable to at
least one blind in-window attack; (2) the in-window data at-
tack is the most signiﬁcant vulnerability, as 29.6% of systems
accepted data with inadequate validation of the acknowledg-
ment number; (3) systems that advertised a maximum seg-
ment size (MSS) of 1380 were almost never vulnerable to in-
window reset and SYN packets (suggesting that middleboxes
with this feature correctly ﬁltered those suspicious packets)
but incorrectly passed invalid in-window data packets, (4)
in response to an in-window SYN, 1.1% of hosts established
a parallel TCP connection using the same 4-tuple, which is
unexpected behavior as a 4-tuple can only support a single
TCP connection at any one time.

13We also investigated the TCP behavior of 14 network in-
frastructure devices (BGP routers and OpenFlow switches)
in a laboratory setting to assess their resilience to these same
oﬀ-path attacks. Of the devices we tested, 12 of 14 had some
vulnerability in their handling of packets that could have
been sent by a blinded attacker. In particular, 10 of 14 de-
vices accepted data that could have been sent by a blinded
attacker.

Finally, in addition to these active tests, we used pas-
sive captures of TCP connections to understand deployed
ephemeral port selection algorithms. Within a March 2015
packet trace from an internal 10Gbps link between Chicago
and Seattle belonging to a Tier-1 ISP, we observed 50% of
selected ports within a 2K range – a fraction of the available
ephemeral port range. Longitudinal analysis of an enterprise
trace suggests that the slow adoption of new operating sys-
tems is slowly increasing the range of ports used in the wild.
We begin by describing blind in-window attack methods
and defenses in section 2, and present our active measure-
ment techniques to test for the vulnerability in section 3.
In section 4 we present our ﬁndings from using our method
to test TCP stacks deployed in a webserver environment;
we found 22% of connections vulnerable to blind in-window
SYN and reset packets, and 30% vulnerable to in-window
data packets. In section 5 we report our ﬁndings from test-
ing embedded TCP stacks in routers and switches; we found
that while more recent stacks were not vulnerable to blind
in-window SYN and reset attacks, they have not deployed
best practices when validating data packets. In section 6 we
explore deployed port selection algorithms over time using
longitudinal connection summary logs from a campus intru-
sion detection system, and using a packet capture from a
Tier-1 ISP backbone link. We end with a brief discussion on
the current diﬃculty of mounting a blind attack in section 7,
a comparison with related work in section 8, and conclude
in section 9. We make our code publicly available as part
of scamper [24], allowing vendors to test their deployed im-
plementations of TCP for the mitigations recommended by
RFC 5961 [32].

2. BACKGROUND

A TCP connection is deﬁned by a four-tuple consisting of
source and destination IP addresses, and source and desti-
nation port numbers. To interfere with a TCP connection, a
“blinded” attacker (i.e. an attacker that is oﬀ-path and does
not observe the TCP connection) has to guess (or infer) all
four tuple values, as well as valid sequence (and sometimes
acknowledgment) numbers for the connection. The TCP
protocol has evolved, and vendors have strengthened imple-
mentations over time, to better resist attack. For example,
the initial sequence number (ISN) was once predictable –
allowing an attacker to infer acknowledgment numbers and
forge entire TCP connections [6]. Modern TCPs instead gen-
erate unpredictable ISN values using a cryptographic hash
function.

Despite unpredictable ISNs, Paul Watson demonstrated in
2004 that a blinded attacker could reset TCP connections
by: (1) guessing a sequence number within the receive win-
dow; and (2) leveraging the small range of likely source port
values [38]. Not only did operating systems at the time typ-
ically choose source ports from within a small range (1024-
5000), they were selected sequentially. Watson noted two
possible solutions. First, a host should choose an ephemeral

port value randomly when it initiates a new TCP connection
to increase the diﬃculty of blind-attacking a TCP connec-
tion by a factor of up to 216. Second, hosts should strictly
validate the sequence and acknowledgment values, so that
rather than requiring the packet to be merely in-window, it
has to be exactly congruent with the receiver’s position in
the connection’s window space. RFC 4953 [36], published
in 2007, described blinded attack vectors in TCP known
at that time. RFC 5961 [32], published in 2010, described
attacks that a blinded attacker could conduct in addition
to the well-known reset attack, and recommended that re-
ceivers strictly validate received packets for their position in
the receive window.

Blind attackers rely on brute force to attack TCP con-
nections, and are therefore constrained by network capacity.
With the exponential growth of network capacity, attacks
become easier. For example, a 100Mbps network link is ca-
pable of carrying 148,410 minimum-sized frames per second,
and can be rented from some hosting networks for less than
$100 per month. A blind attacker needs only small packets
that ﬁt entirely inside the minimum-sized Ethernet frame.
Therefore, an attack that requires 217 (131,072) packets to
succeed can complete in less than one second at 100Mbps.

2.1 Slipping in the window

Operating systems retain myriad state about each active
TCP connection. Beyond the source and destination IP ad-
dresses and port numbers that represent the 4-tuple, each
end of the TCP connection has a 32-bit number correspond-
ing to the next sequence number value it will use to send new
data (snd.nxt), a 32-bit number recording the next in-order
sequence number expected from the receiver (rcv.nxt), a 32-
bit number recording the last sequence number for which it
received an acknowledgment (snd.una), as well as a 16-bit
number the receiver advertises which represents the amount
of data it can accept (rcv.wnd). This 16-bit number can be
scaled by up to 14-bits with the TCP window scale option,
so that a TCP sender can have up to 1GB of data in ﬂight
provided the receiver advertises a suﬃcient window size [20].
The blind in-window reset attack described by Watson [38]
relies on the victim’s TCP stack following the original TCP
speciﬁcation from 1981, RFC 793 [30], which says that “a
reset is valid if its sequence number is in the window.” To
reset a TCP connection with a given four tuple, a blinded
attacker only has to try one packet in each possible window.
Therefore, the number of packets required to complete the
attack is inversely proportional to the size of the advertised
window, i.e. the diﬃculty of an attack reduces the larger
the receiver’s window becomes.

RFC 5961 [32] suggests TCP should tighten the original
speciﬁcation’s notion of an acceptable sequence number from
“in the window” to exactly the next expected sequence num-
ber (rcv.nxt). Otherwise, the victim must send a challenge
ACK, which is an acknowledgment reporting the current val-
ues of snd.nxt and rcv.nxt. The purpose of this ACK is to
double check that the sender of the reset actually intended
to reset the connection.
If so, it will send a second reset
packet, with the challenge ACK’s rcv.nxt value copied into
the sequence number space, conﬁrming the reset and provid-
ing a valid reset that the receiver will act on. This approach
increases the number of guesses the attacker must make from
232 / rcv.wnd to 232.

14RFC 5961 describes two additional attack vectors similar
in nature to the well-known reset attack: a blind reset at-
tack using the SYN bit, and a blind data injection attack.
The SYN attack is similar to the reset attack, and relies on
similar language in RFC 793 [30], which says that if a SYN
is received in the window it is an error, and to send a reset.
As with the reset attack, RFC 5961 says the receiver must
send a challenge ACK to conﬁrm the loss of the previous
connection; this challenge ACK must be sent regardless of
the sequence number in the SYN packet.

In a blind data injection attack, an attacker tries to in-
ject data into an existing TCP connection by guessing a
sequence number within the victim’s receive window. Un-
like the reset and SYN attacks, an attacker should also have
to guess an acknowledgment value that is acceptable to the
receiver. RFC 793 states that an acknowledgment number is
acceptable as long as it is not acknowledging data that has
not yet been sent. In practice, this means that the acknowl-
edgment number in the packet can be any value less than
the victim’s snd.nxt, which is a range of nearly 231 values.
To reduce the likelihood of success, RFC 5961 introduces a
variable to represent the maximum receive window the peer
has advertised to the victim (max.rcv.wnd) and limits the
acceptable acknowledgment range to lie between snd.una -
max.rcv.wnd and snd.nxt.

RFC 5961 explicitly states that these mitigations are not
required of TCP stacks – the mitigations to the blind reset
and SYN attacks are recommended, and the mitigation to
the blind data attack is optional because the attack is per-
ceived to be twice as diﬃcult (a blind attacker has to send
the data twice, with two diﬀerent acknowledgment values).
However, RFC 5961 also notes that all three mitigations in-
crease the robustness of TCP in general.

Finally, some connections are subject to a trivial blind
attack that does not require an in-window packet. Until
September 2014, all supported versions of FreeBSD were
susceptible to an attacker being able to tear down any TCP
connection by sending two packets with the SYN ﬂag set
that shared the same 4-tuple as an ongoing connection [1].
If an attacker has reason to believe there are connections
between two IP addresses and a destination port, and the
FreeBSD system has not been patched [1], the attacker could
tear down all connections with 217 packets (two packets for
all 216 ephemeral ports). While this vulnerability was ﬁxed
in all supported versions of FreeBSD, the recommendations
in RFC 5961 have only been added to the development ver-
sion of FreeBSD, and all supported versions of FreeBSD as
of August 2015 are still vulnerable to some blind attacks.

2.2 Defenses to blind in-window attacks

Beyond strictly checking incoming packets per the ad-
vice in RFC 5961, there are several mitigations to blind in-
window attacks that vendors can implement, ranging from
those that make the problem harder to cryptographic so-
lutions that make successful attacks practically impossible.
The simplest approach is for a host to choose a random
source port when establishing a TCP connection. Operat-
ing systems select port values from a conﬁgurable ephemeral
range. Historically, versions of Windows and BSD used the
range 1024 to 5000 – a range of 3976 port values.
IANA
now recommends the range 49152 to 65535 [10, 19] be used
by all transport protocols – a range of 16K port values. Ta-

Port Range
1024–5000

Size Operating System
3976 Windows XP and earlier

49152–65535

32768–61000
10000–65535

FreeBSD ≤ 4.11 (Jan 2005)
Linux ≤ 2.2
16384 FreeBSD ≥ 5.0 (Jan 2003)
Windows Vista (Jan 2007)
Apple MacOS X
Apple IOS
28232 Linux ≥ 2.4
55535 FreeBSD ≥ 8.0 (Nov 2011)

Table 1: Port ranges and sizes used by common
operating systems to select ephemeral ports. Port
selection strategies diﬀer among systems; Windows
and Apple currently assign ephemeral TCP ports se-
quentially, FreeBSD randomly, and Linux uses hash-
based port selection.

ble 1 summarizes the ephemeral port ranges used by popular
operating systems.

It is tempting to believe that operating systems choose
ports at random from within these ranges, making it diﬃ-
cult to guess which port values are likely to be used. This
was one of the pieces of advice made by Paul Watson in
2004 when he reported on the feasibility of blind in-window
attacks [38]. Researchers have since studied ephemeral port
selection strategies [3] and port randomization is IETF best
current practice [23] as of 2011.

Implementers made the well-known Kaminsky DNS cache
poisoning attack [21] much more diﬃcult to mount by using
a random ephemeral port value selection strategy. However,
for expediency, implementers made this ﬁx in DNS server
software, not in the operating systems, and while some op-
erating systems have chosen ports at random since at least
2004 (FreeBSD, OpenBSD) current popular operating sys-
tems (Windows and MacOS) choose TCP ports sequentially
from the global range of ephemeral ports. Linux kernels
since version 2.6.15 choose ports sequentially from an oﬀset
in the ephemeral range based upon a cryptographic hash of
the destination address and port with a secret, per [23].

Some protocols, such as BGP, typically operate between
topologically adjacent systems. Because they are adjacent,
the TTL value contained in the IP header will not be decre-
mented by outside routers before packets arrive at the peer.
The Generalized TTL Security Mechanism [15] relies on this
fact; if the peer requires the received IP TTL to be 255 (the
largest TTL value possible) then it will discard attack pack-
ets from outside the network because outside routers will
have decremented the TTL and therefore the packets’ TTL
value cannot be 255. This mitigation does not protect In-
ternet applications in the general case, though it does help
in some situations.

It is also possible to protect TCP sessions by using a cryp-
tographic authentication protocol between the hosts, to al-
low a receiver to validate that the packet must have come
from its peer and not a third-party attacker. The three
most common authentication options are the TCP MD5 op-
tion [16], the TCP authentication option [37], and the IP
authentication option [22]. In all cases, the peers must es-
tablish a shared secret, or deploy certiﬁcates, before estab-
lishing a TCP connection. This approach is feasible for BGP,
where sessions are conﬁgured between known endpoints, but

15Client

TCP Connection

Server

<src−port:x, dst−port:80, Seq: y, Ack: z, RST>

Attacker

(a) Attacker approach.

TCP Connection

Server

Client /
Prober

<Non−blind, Oracle TCP RST>

(b) Our oracle approach.

Figure 1: Comparing our oracle approach with that
of an attacker. We do not attempt to disrupt third-
party connections, rather we establish our own TCP
connection and send test packets with perfect knowl-
edge of the connection.

is more diﬃcult in the general transport protocol case be-
tween arbitrary endpoints.

Application-layer encryption, such as that provided by
TLS, does not prevent an attacker from disrupting a TCP
session. A blind in-window reset, SYN, or piece of data
can still cause the connection to terminate; the only advan-
tage of TLS is that, in the case of the blind data attack,
an attacker’s accepted data will cause the application-layer
decryption software to note the error and abort the TLS
connection rather than corrupting the transmitted data.

Some TCP stacks use automatic buﬀer tuning [35] and in-
crease the receive window (and max.rcv.wnd) when they in-
fer the sender’s transmission rate is receive window limited.
A TCP stack that uses automatic buﬀer tuning can reduce
their attack surface by using small initial receive windows,
and only increase the window when they detect the sender is
receive window limited. A study of TCP performance on a
ﬁber-to-the-home network during 2011 and 2012 found that
20%-41% of TCP connections increased their window dur-
ing the connection’s lifetime [34], suggesting modest use of
automatic buﬀer tuning.

Finally, since blind attacks require the attacker to use the
source IP address of an ongoing TCP connection, blind at-
tacks are possible because there is inadequate source ad-
dress validation and hence IP address spooﬁng is allowed.
RFC 2827 [13] describes best current practices for ﬁltering
spoofed packets, however previous work has found ﬁltering
not well deployed in the Internet [7] so blind attacks are
unfortunately still possible.

3. ACTIVE MEASUREMENT METHOD

Our general approach is to actively open a normal TCP
connection with some server and then simulate an attack on
this connection. Our attacks were conﬁned to our own ex-
perimental connections and at no point did we attempt to
disrupt production traﬃc. Figure 1 compares our approach
to that of a blind attacker. This methodology gives us per-
fect knowledge of the precise packets to use to determine if
the TCP connection was susceptible to packets from a blind
attacker who knows the four tuple of the target connection.
Our speciﬁc tests follow from RFC 5961 [32]: we sent pack-

Server

Server

Client
(a)

(b)

(c)

(d)

HTTP GET 1:1(174)
D A T A   1 : 1 7 5 ( 1 4 6 0 )
RST 10:−
A C K   1 4 6 1 : 1 7 5
(Retransmit
Timeout)
D A T A   1 : 1 7 5 ( 1 4 6 0 )
ACK 175:1461

(e)

(f)

Client
D A T A   1 4 6 1 : 1 7 5 ( 1 4 6 0 )
RST 1471:−
A C K   2 9 2 1 : 1 7 5
(Retransmit
Timeout)
D A T A   1 4 6 1 : 1 7 5 ( 1 4 6 0 )
ACK 175:2921
D A T A   2 9 2 1 : 1 7 5 ( 1 4 6 0 )

(g)

(h)

Figure 2: Overview of our blind reset and SYN test.
After the TCP (and TLS) handshake, we send an
HTTP request (a) to solicit a response to which we
send a reset packet (b). If the server follows RFC
5961, it will send a challenge ACK (c, f ) with the
expected sequence number in the acknowledgment
ﬁeld. When the server re-transmits the unacknowl-
edged data, we send an acknowledgment (d, g) and
send the next blind reset (e) when the server sends
new data. This method allows the TCP connection
to progress while we send our three reset attempts;
only two reset attempts (b, e) are shown.

ets that have a sequence or acknowledgment number that
should cause the receiver to reject or challenge the packet.

3.1 Blind Reset and SYN Tests

Figure 2 illustrates our blind reset and SYN tests. Our
tests began by establishing a TCP connection without the
use of any TCP options. We established a TLS session in
the HTTPS case, and sent a HTTP GET request specifying
the HTTP “Host” header for the server. From there, we
sent reset (or SYN) packets as if we were a blind attacker
by using a sequence number 10 greater than the ﬁrst byte of
data the receiver is expecting from our client. We sent up
to three reset (or SYN) packets to account for packet loss,
interspersing each with an ACK that acknowledged a new
segment of data to encourage the server to keep the TCP
connection alive. If the server sent multiple packets, we used
the ﬁrst to trigger our test, and subsequent packets to send
duplicate acknowledgments as if we had lost the ﬁrst.

If we received a reset packet in response to a duplicate
acknowledgment we sent, then we classiﬁed the server as
vulnerable because it reset the connection in response to
the reset or SYN. Likewise, if we received no other pack-
ets after sending the ﬁrst reset packet, then we inferred the
server reset the connection and was also vulnerable. If we
received a challenge ACK, or the server ignored the packets
and continued to send data, then we classiﬁed the server as
not vulnerable because it ignored the packets. Otherwise, if
we received a FIN before we could send all three packets, or
the server went silent before we could send all three packets,
then we classiﬁed the test as being inconclusive.

16Client
(a)

Server

DATA 1:1(60)
A C K   1 : 6 1

DATA 121:−70000(62)

(b)

(c)

(d)

(e)

DATA 121:−70000(62)

A C K   1 : 6 1
(2 Second
Pause)

A C K   1 : 6 0
(2 Second
Pause)

Client
(f)

Server
DATA 121:−70000(62)

A C K   1 : 6 1
(2 Second
Pause)
DATA 61:1(60)
A C K   1 : 1 2 1
DATA 121:1(60)
A C K   1 : 1 2 1
D A T A   1 : 1 2 1 ( 1 4 6 0 )

(g)

(h)

(i)

(j)

Figure 3: Overview of our blind data test. We
break the ﬁrst segment of data for the connection
into three pieces. After the TCP handshake, we
send the ﬁrst piece (a) with an expected acknowl-
edgment number, and then send the third piece (b)
with an invalid acknowledgment number. We send
the third piece twice more to account for potential
packet loss (d, f ), and then the second piece (h) with
an expected acknowledgment number. If the server
rejected the third piece, then we will not receive an
ACK for it after the hole is ﬁlled by the second piece.
We then send the third piece with an expected ac-
knowledgment number (i) to allow the connection
to complete (j). The acknowledgment packets (c, e,
and g) are recommended by RFC 5961 though they
are not challenge ACKs because they are not used
by the server to conﬁrm the loss of the connection.

The blind SYN test can reveal two additional behaviors.
First, if the server sent a reset packet in response to the SYN
(identiﬁed by the acknowledgment number in the reset being
one greater than the sequence number in our reset packet) we
inferred these systems were vulnerable. We conﬁrmed these
systems reset the original TCP connection, as any subse-
quent duplicate acknowledgments also solicited a reset. Sec-
ond, if the server sent a SYN/ACK packet acknowledging
the new sequence number, we classiﬁed these systems as es-
tablishing a parallel TCP connection using the same 4-tuple.
This behavior was an unexpected ﬁnding; we conﬁrmed that
data continued to ﬂow in the original TCP connection, and
that the new TCP connection re-transmitted the SYN/ACK
as if the server had state for both connections. We were able
to associate most of the systems that established a parallel
connection with a large content distribution network.

Finally, we also tested if the sequence number even had
to be in-window for the reset or SYN packet to cause the
connection to be reset. We begin a new test by sending
packets with a sequence number 70,000 earlier than would
be required for the packet to be in-window. We chose this
value arbitrarily but it is a value that is outside the window
and represents a position in the stream that our connection
has not covered.

3.2 Blind data test

Devising a realistic methodology to test for vulnerability
to the blind in-window data attack was not straight for-
ward. In our testing, if we sent the ﬁrst data packet for a
connection with an unexpected acknowledgment number, we
elicited a reset from 22% of the tested webserver population,
regardless of the sequence number chosen. The same sys-
tems did not send a reset if the packet with an unexpected
acknowledgment number was not the ﬁrst data packet for
the connection. In addition, we did not want to send the
ﬁrst segment with the exact sequence number expected by
the receiver, in case the receiver’s TCP has a special case
for that speciﬁc segment.

Therefore, we chose a slightly complicated approach where
we broke the ﬁrst segment of data (the HTTP GET or the
ﬁrst packet in the TLS handshake) into three equal-sized
pieces, and then sent the pieces as follows: (1) we sent the
ﬁrst piece with an acknowledgment number expected by the
receiver, (2) we sent the third piece with a sequence number
ahead of the receiver’s rcv.nxt (leaving a hole for the sec-
ond piece) and an acknowledgment number outside of the
acceptable range deﬁned by RFC 5961, and (3) we sent the
second piece with an acknowledgment number expected by
the receiver.

If the receiver accepted the third piece with an invalid ac-
knowledgment number, the second piece will ﬁll a hole and
the receiver will send an acknowledgment for both pieces.
We inferred the receiver is vulnerable to blind data attacks
if we receive an acknowledgment for the third piece. Oth-
erwise, we sent the third piece with the acknowledgment
number expected by the receiver to avoid conﬂating an un-
responsive TCP with a system that was ignoring our seg-
ments. Figure 3 illustrates our approach. We sent the third
piece three times, and with a two second delay, regardless of
the presence or absence of acknowledgments, and sent the
ﬁrst and second pieces up to three times each, to account
for transient packet loss.

If we received an acknowledgment for any of the third
pieces with an incorrect acknowledgment number, we classi-
ﬁed these systems as not vulnerable and report them in the
challenge ACK category, though these ACKs were not chal-
lenge ACKs because the sender was not using them to con-
ﬁrm the loss of the connection. If we did not receive an ac-
knowledgment for any of the third pieces we sent with an in-
correct acknowledgment number, we also classiﬁed these sys-
tems as not vulnerable because they ignored the data. If we
received a reset quoting our invalid acknowledgment num-
ber, we classiﬁed these systems as vulnerable because they
reset the connection, rather than discard the data packet.

Finally, we also tested if the acknowledgment number even
had to acknowledge previously sent data for a blind data
attack to be successful. We sent the third piece with an
acknowledgment number 70,000 ahead of the receiver’s po-
sition in the sequence number space, which we know from
the SYN, and is beyond the feasible range of sequence num-
bers it could have sent given our advertised receive window.
3.3 Fingerprinting test

We completed probing with a test that established a TCP
connection advertising support for TCP window scaling [20],
timestamps [20], and Selective Acknowledgments [26]. We
used this test to infer the normal behavior of a TCP connec-
tion with a peer, as well as to ﬁngerprint the peer’s operat-

17Parameters
Host’s snd.nxt + 10

Methods
Blind reset: in window
Blind reset: out of window Host’s snd.nxt - 70,000
Blind SYN: in window
Blind SYN: out of window Host’s snd.nxt - 70,000
Peer’s snd.una - 70,000
Blind data: behind
Host’s snd.nxt + x
Peer’s snd.una + 70,000
Host’s snd.nxt + x

Host’s snd.nxt + 10

Blind data: ahead

Table 2: Summary of blind tests we conducted. We
chose diﬀerent sequence and acknowledgment values
to test for diﬀerent checks made by the receiver.

ing system with p0f [39]. p0f can infer the operating system
using features found in the SYN/ACK packet, such as the
ordering of TCP options, the window size advertised, and
the IP-TTL value.
3.4 Implementation

Table 2 summarizes the blind TCP tests we implemented
in scamper, an open-source parallelized packet prober [24].
For each measurement, our tool records, in a single data
unit, meta-data about the test such as the URL and the
server MSS seen, and all packets sent and received for that
test. We also implemented a driver to coordinate scamper’s
measurements. Our driver ﬁrst performs the sequence of
blind tests towards the webserver one at a time, in random
order, waiting at least one minute between tests to each
unique IP address to avoid being a nuisance. Our driver
concludes with the null test to ﬁngerprint the operating sys-
tem of the host. Our code is publicly available and available
in scamper [24].

4. WEBSERVER VULNERABILITY
4.1 Targets

The ﬁrst step in our methodology was to choose a list of
web servers to test. We derived our targets from the Alexa
Top 1,000,000 websites list [2]. Each of our measurement
vantage points (see 4.2) independently chose 50K random
web sites from the Alexa list. We sent a DNS query for each
web site and used the ﬁrst returned IPv4 address for the
duration of our probing. Further, if multiple sites shared
an IP address, we only probed the IP address once. This
process yielded roughly 41K target IP addresses per vantage
point. Additionally, some of our tests require a transfer to
last long enough to conduct the test and therefore we must
ﬁnd a URL within each site that returns an object of at
least 25KB. Therefore, we run a pre-probing step with wget
against each IP address, as follows. If the default page for
the given site is at least 25KB, we use that for our tests.
Otherwise, we retrieved all objects required to display the
default page and used the ﬁrst that was at least 25KB in
size in our tests.
4.2 Vantage Points

We used two of CAIDA’s Archipelago vantage points (VPs)
to conduct measurements [18]: cld-us, hosted by CAIDA in
San Diego, and hlz-nz, hosted by the University of Waikato
in New Zealand. We used a third machine hosted by the
Massachusetts Institute of Technology (MIT) in Cambridge.

We used three VPs to attempt to avoid an undetected mid-
dlebox in the hosting network from impacted our measure-
ments by manipulating our test packets before they reached
the destination network. We obtained permission from the
operators of these three VPs to conduct our measurements
from their network.

4.3 Results

Table 3 summarizes the results of our testing the web-
server population from cld-us. The columns labeled in/out
represent SYN and reset tests where the sequence numbers
were in or out of window as per table 2, and the ahead/behind
represent data tests where the acknowledgment number was
behind or ahead of the range acceptable by RFC 5961. We
found 22.2% of the connections tested were vulnerable to an
in-window reset packet. Of these, most (18.8%) sent a reset
in response to duplicate acknowledgments, while 3.4% went
silent after we sent the reset packet. An additional 76.5% of
the connections were not vulnerable to the in-window reset
attack, with 71.4% issuing a challenge ACK as required by
RFC 5961, and the remaining 5.1% simply ignoring the reset
packets rather than conﬁrming the loss of the connection.

22.4% of the connections we tested were vulnerable to
an in-window SYN packet, with 17.1% sending a reset that
acknowledged the in-window sequence number, and 5.3%
sending a reset after we sent a duplicate acknowledgment.
Interestingly, 35.9% of the connections we tested did not
send a challenge ACK as required by RFC 5961, to conﬁrm
the loss of the previous TCP connection. Additionally, 1.1%
of TCP connections acted in an unexpected way by appear-
ing to create a second parallel TCP connection in response
to the in-window SYN packet. These TCP connections were
mostly with a large CDN provider, who appeared to termi-
nate TCP connections on their systems, and relayed data
from their customer’s webserver obtained over a separate
TCP connection.

30.3% of connections we tested were vulnerable to data
injection attacks. In most of the cases (29.6%) the injected
data was accepted by the stack, while the receiver sent a
reset in the remaining cases. Most of the systems that re-
set the connection conﬁrmed that they reset in response to
the data packet because they quoted the invalid acknowl-
edgment value in the reset packet. We also found that in
the majority of the non-vulnerable connections, the server
sent an ACK to the packets (37.1%) rather than just ignore
the packets (29.3%).

Table 4 shows the overall results collected from the VPs
we used to test webservers. Quantitatively, the results are
similar, with overall classiﬁcations from each VP usually
within 1% of each other, despite each VP testing a diﬀer-
ent set of random webservers. However the results of the
blind in-window SYN tests were impacted by a stateful on-
campus router at hlz-nz, which silently discarded outgoing
SYN packets belonging to an existing connection. Because
our results for each VP are quantitatively similar, we believe
the behaviors observed occur close to the webserver end of
the TCP connection.

Overall, 38.4% of the webservers tested from cld-us were
vulnerable to at least one blind in-window attack. Figure 4
shows the overlap of vulnerability to blind in-window tests
between tested systems. 12.4% of the webservers tested were
vulnerable to all three blind in-window attacks tested. The
vector with the largest exposure was the blind data injection

18Result

Accepted
Reset (ack-blind)
Reset (dup-ack)
Vulnerable
Challenge ACK
Ignored
Not Vulnerable
Parallel TCP
Early FIN
No Result
Other

Blind data

Blind SYN
in
out
-

-

Blind reset
out
in
0.4%

-

-

3.4%

behind
ahead
29.6% 5.4%
0.6%
0.6%
18.8% 0.6%
0.1%
0.2%
22.2% 1.0% 22.4% 1.2% 30.3% 6.2%
71.4% 1.1% 37.7% 57.0% 37.1% 8.1%
5.1% 91.8% 35.9% 38.3% 29.3% 81.3%
76.5% 93.0% 73.6% 95.3% 66.4% 89.4%

17.1% 0.0%
5.3%
1.2%

-

0.3%
1.0%
1.3%

-

3.3%
2.7%
6.0%

1.1%
1.5%
1.3%
4.0%

1.1%
1.6%
0.9%
3.6%

-

3.2%
0.1%
3.3%

-

3.7%
0.7%
4.4%

Table 3: Overview of results for the webserver population testing from cld-us VP in September 2015. In our
data, 22% of connections were vulnerable to in-window reset and SYN packets, and 30% of connections were
vulnerable to an in-window data packet. A further 6.2% of connections were vulnerable to data packets with
an acknowledgment ahead of the receiver’s window; 5.4% accepted the data without correctly validating the
acknowledgment number, and 0.8% reset the connection.

cld-us MIT

hlz-nz

Blind reset (in):
Vulnerable
Not Vulnerable
Other
Blind SYN (in):
Vulnerable
Not Vulnerable
Other
Blind data (behind):
Vulnerable
Not Vulnerable
Other

22.2% 22.1% 21.9%
76.5% 76.0% 76.5%
1.3%
1.6%

1.9%

22.4% 22.2% 0.3%
73.6% 73.2% 94.2%
4.0%
5.5%

4.6%

30.3% 30.3% 30.3%
66.4% 66.5% 66.2%
3.3%
4.5%

3.3%

Table 4: Summary of the blind tests conducted from
three VPs. Overall results are quantitatively simi-
lar, apart from the SYN tests from hlz-nz, which
were blocked by a stateful campus router.

attack, with 12.4% of the webservers tested (32.3% of the
vulnerable population) only vulnerable to that vector.
4.3.1 Out-of-window tests
Table 3 also contains the results of our out-of-window
tests.
In our experiments, we found that 1.0% of tested
systems incorrectly processed the reset and 1.2% incorrectly
processed the SYN even though the sequence number we in-
cluded was outside of the window. We are encouraged that
most TCP connections were not falsely reset, though these
represent systems where a blinded attacker with knowledge
of the use of an application port between two IPs only has
to brute force up to 65,536 ports to reset the connection, i.e.
on average a successful attack requires 215 packets.

More problematic is the in-window data attack, where
6.2% showed a vulnerability to packets containing an ac-
knowledgment value ahead of the peer’s send window that
the peer could not have sent. In fact, 5.4% of servers ac-
knowledged the data we sent, and sent a response anyway.
A further 0.6% of connections were reset, quoting the invalid
acknowledgment number we sent in our data packet. If an
attacker’s goal is simply to reset an arbitrary connection,
then the attacker merely has to brute force a packet into

Blind
Reset: 22.2%

1.2%

2.6%

1.2%

Blind
SYN: 22.4%

2.9%

5.9%

12.4%

12.4%

Blind Data: 30.3%

Figure 4: Overlap of vulnerability to blind in-
window attacks of systems tested from cld-us. 38.4%
of servers tested were vulnerable to at least one in-
window attack, with 12.4% of the servers tested only
vulnerable to the blind in-window data attack.

the receive window, acknowledging data that has not been
sent yet, a range of up to 231 values, or half the sequence
number space. Most (81.3%) systems simply ignored the
data packet with an acknowledgment value ahead of their
window, and 8.1% sent an acknowledgment before discard-
ing the packet.
4.3.2 Middlebox behavior
In our previous 2010 work examining the behavior of Path
MTU discovery (PMTUD) in the context of TCP [25], we
found that servers that advertised an MSS of 1380 bytes
were much more likely to fail PMTUD, suggesting a mid-
dlebox was interfering with PMTUD. We were curious if
we could ﬁnd evidence of middleboxes defending webservers
from blind attacks. Table 5 shows the ﬁve server MSS values
most frequently observed in our data and their vulnerability
to blind attack. Because most (87.2%) of the TCP con-
nections involved an MSS of 1460, the failure rate of these
systems is within 2-3% of that observed for all connections.
However, systems with an MSS of 1380 were almost never
vulnerable to blind in-window reset (2.0%) and SYN (0.5%)
packets, but were vulnerable to in-window data packets in
roughly half the cases. We found that 85.6% of TCP con-
nections with an MSS of 1380 sent an ACK in response

19 1

 0.8

 0.6

 0.4

 0.2

n
o
i
t
c
a
r
F
 
e
v
i
t
a
l
u
m
u
C

 0

0

TCP Reset
(dup−ack)

(18.8%)

Accepted
(3.4%)

 1

 0.8

 0.6

 0.4

 0.2

TCP Reset
(ack−blind)

(17.1%)

TCP Reset
(dup−ack)

(5.3%)

 1

 0.8

 0.6

 0.4

 0.2

TCP Reset
(ack−blind)
(0.6%)
Accepted
(29.6%)

16K

32K

8K
Largest Window Size Advertised

40K 48K 56K 64K

24K

(a) Blind Reset

 0

0

8K 16K
Largest Window Size Advertised

32K 40K 48K 56K 64K

24K

(b) Blind SYN

 0

0

8K 16K 24K 32K 40K
Largest Window Size Advertised

48K 56K 64K

(c) Blind Data

Figure 5: Largest window sizes observed for systems vulnerable to blind in-window attacks and their failure
modes. A larger receive window makes it easier for an attacker to disrupt a connection. The small (8K)
receive window we observed for most systems vulnerable to blind reset and SYN attacks makes it more
diﬃcult to attack those connections (219 packets), but 40% of the systems vulnerable to accepting in-window
data advertised a window of at least 64K.

Server MSS

Vulnerable Portion

Blind reset Blind SYN Blind data

1460 (87.2%)
1380 (5.4%)
8961 (2.3%)
1440 (0.8%)
1436 (0.7%)

23.9%
2.0%
2.3%
5.9%
22.2%

24.7%
0.5%
2.3%
4.7%
5.8%

28.1%
58.8%
4.7%
57.5%
32.5%

Table 5: Top ﬁve server MSS values advertised and
the corresponding portion that were vulnerable to
in-window reset, SYN, and data packets. Servers
that advertised an MSS of 1380 were much less likely
to be aﬀected by in-window reset and SYN packets
than the general population (MSS 1460), but were
aﬀected by in-window data packets.

to data with an acknowledgment ahead of the receiver’s
window, representing 57.6% of all connections that did so
yet only 5.4% of the population; only 3.3% of connections
with an MSS of 1460 behaved this way. Similarly, we ob-
served 96% of TCP connections with an MSS of 1380 to
send challenge ACKs to in-window SYNs and resets, and
out of window resets; interestingly, 1380-MSS connections
behaved identically to the general population, as 80% ig-
nored out-of-window resets. We further investigated for the
presence of middleboxes by searching for TCP connections
where we received packets with diﬀerent TTL values for the
blind in-window tests, but not for the null test. We found
that we received challenge ACKs with a diﬀerent TTL value
than the rest of the packets in the TCP ﬂow where a 1380
byte MSS value was advertised, indicating that a middlebox
intercepted the attack packets and correctly stopped them.
Challenge ACKs with diﬀerent TTL values were absent al-
most entirely from the other MSS values in table 5.

Systems with an MSS of 8961 were hosted by Amazon,
which likely had a middlebox rewriting the server MSS value.
It is unclear if this middlebox protected the TCP connec-
tions involved, or if the homogeneous nature of operating
systems images is responsible for the low vulnerability rate.

 1

 0.8

 0.6

 0.4

 0.2

n
o
i
t
c
a
r
F
 
e
v
i
t
a
l
u
m
u
C

 0

0

27.2% advertised > 64K

19.4% advertised ~16K

27.7% advertised ~8K

8K 16K 24K 32K 40K 48K 56K 64K

Largest Window Size Advertised

Figure 6: Largest window sizes observed for sys-
tems vulnerable to any blind in-window attack. 27%
advertise a window of at least 64K, so an attacker
requires a maximum of 216 packets to disrupt a cor-
responding 4-tuple (twice as many in the data case).

4.3.3 Window sizes observed
The ease at which a blind attacker can inject a packet
into a window depends on the size of the receiver’s window.
Figure 5 shows the largest window sizes observed to be ad-
vertised for the blind reset, SYN, and data tests. The blind
in-window reset and SYN attacks appear to be the most dif-
ﬁcult of the three attacks to accomplish, as most (60%) of
potential victims used a receive window less than 8K bytes.
A blind attacker would have to send more than 219 packets
to successfully disrupt a TCP connection that is using a re-
ceive window less than 8K bytes. However, a blind attacker
might have more luck using data packets, as 50% of poten-
tial victims will accept data into a receive window of 64K.
Because an attacker has to try each segment twice, with
diﬀerent acknowledgment values in diﬀerent halves of the
receiver’s sequence number space, an attacker would require
217 packets to successfully disrupt these TCP connections.
Figure 6 shows the landscape for systems vulnerable to
any of the blind attacks tested. Because of the prevalence

20Operating System

FreeBSD 8.x
FreeBSD 9.x
Linux 2.4-2.6
Linux 2.6.x
Linux 3.x
Windows 7 or 8
Windows XP
Unknown

Blind reset
in
out

Blind SYN
in
out

Blind data

Total

behind

ahead
193 (0.5%)
19.2% 0.5% 93.8% 56.5% 83.9% None
612 (1.5%)
18.8% 1.0% 88.1% 22.2% 54.7% None
269 (0.6%)
87.4% 3.0% 83.6% 0.4% 54.3% 40.5%
90.1% 0.9% 84.1% None
63.2% 35.8% 4903 (11.8%)
15.3% 0.6% 14.0% 0.1% 11.6% 0.6% 18021 (43.4%)
5.1% 2.1% 0.3%
3877 (9.3%)
7.9% 6.1% 3.0%
838 (2.0%)
9.6% 0.8% 12.7% 1.4% 23.9% 3.2% 12543 (30.2%)

0.3% 88.7% 0.9%
3.5%
1.8%

6.3%

Table 6: Vulnerability to blind attacks based on operating system inferred by the p0f tool for the cld-us VP.
Most vulnerable connections were Linux-based, and running older kernel releases. Many operating systems
handled in-window data incorrectly by accepting the data that could have come from a blind attacker. We
excluded operating systems that each accounted for fewer than 0.5% of observed connections (HP-UX, Linux
2.4, MacOS, OpenBSD, and Solaris).

of systems that will accept in-window data from a blind at-
tacker and advertise a receive window of at least 64KB, 23%
of tested connections could be disrupted with 217 packets.

4.3.4 Operating systems inferred
Table 6 correlates the behavior inferred for each TCP
connection with the OS inferred by the Passive OS Fin-
gerprinting (p0f) tool [39] for data collected by the cld-us
VP. The most vulnerable populations were inferred to be
running Linux 2.6, with nearly all tested systems (84–90%)
vulnerable to blind in-window reset and SYN attacks, and
more than half vulnerable to in-window data attacks. The
results for FreeBSD correlate with what is publicly known
about their vulnerability to SYN packets matching an exist-
ing connection [1].

Table 6 only lists operating systems that made up at least
0.5% of the population. Beyond the operating systems in
table 6, we also observed: (1) 0.3% of systems p0f clas-
siﬁed were HP-UX 11.x, most of which were not vulnera-
ble to blind reset or SYN attacks, but were vulnerable to
blind data; (2) 3 Mac OSX systems that were vulnerable
to the three blind in-window attacks tested, but not to the
out/ahead of window tests; (3) 6 OpenBSD systems that
were not vulnerable to any blind attacks.

4.3.5 Summary of ﬁndings for webservers
We found that 38.4% of currently deployed TCP stacks
that support popular websites were vulnerable to at least one
blind in-window attack, with the data attack the least well
defended. Most TCP stacks correctly ignored reset and SYN
attacks for out-of-window packets, but some incorrectly es-
tablished a parallel TCP connection (1.1%) and some incor-
rectly reset the connection (1.0–1.4%). Perhaps most trou-
bling was the 6.2% of tested systems whose connections were
vulnerable to a blind data attack with an acknowledgment
value ahead of the receiver’s send window.

Systems advertising an MSS of 1380 were almost never
vulnerable to in-window reset and SYN packets, because
they represented TCP connections likely protected by a mid-
dlebox that sent challenge ACKs on their behalf. It is likely
that the attack surface will reduce as the fraction of systems
running older versions of Linux are upgraded. For exam-
ple, we found approximately 3% fewer hosts vulnerable to
in-window SYN and reset attacks in September 2015 than
we found in April 2015.

5.

INFRASTRUCTURE VULNERABILITY
Blind attacks have the potential to disrupt not just end
stations, but also core infrastructure [8, 12]. For example,
both BGP-speaking routers and OpenFlow-speaking switch-
es establish TCP connections to exchange routing informa-
tion. BGP and OpenFlow connections are especially sus-
ceptable to brute forcing, as they are long-lived. Long-lived
ﬂows permit the attacker to feasibly probe the entire se-
quence and portions of the tuple space. Furthermore, the
four-tuples of control-plane ﬂows may be easier to discover
as BGP peers are well-known. An oﬀ-path attacker that is
able to successfully disrupt a BGP or OpenFlow TCP con-
nection can induce signiﬁcant harm. When a BGP session
with a peer that has advertised a large number of preﬁxes
terminates, signiﬁcant route recomputation and announce-
ments may occur while the routers involved reconverge.

In recognition of the dangers of blind attacks on infras-
tructure TCP stacks, several mechanisms have been devel-
oped to protect TCP sessions. First, the generalized TTL
mechanism (GTSM) [15] only accepts packets with a TTL of
255 (the maximum value), such that any packets not on the
local subnetwork will arrive with a lower TTL and will not
be accepted. While GTSM works for point-to-point eBGP
sessions, it does not generalize. Second, TCP MD5 [16] and
TCP-AO [37] options provide cryptographic authentication.
Unfortunately, these strong authentication mechanisms re-
quire conﬁguration of a shared secret, a manual and com-
plex process that can discourage use. Finally, best common
practices [12] dictate ﬁltering of control plane messages via
access control lists that admit only traﬃc from trusted net-
works. However, attackers able to employ IP source address
spooﬁng [7] can circumvent such ﬁltering.

5.1 Testing infrastructure stacks

Because routers and switches frequently use specialized
operating systems, we sought to better understand the be-
havior of these non-commodity TCP stacks. We chose not
to probe BGP or OpenFlow devices in the wild for several
reasons. First, we did not want our probing to be perceived
as an active attack by operators. In private discussions with
a network operator, we were strongly discouraged from at-
tempting to probe BGP routers in the wild. Second, many
BGP routers employ source address ﬁltering, yet may still
be vulnerable to spoofed-source attacks, which we did not
want to mount.

21Device

Cisco 2610 12.1(13)
Cisco 2610 12.2(7)
Cisco 2650 12.3(15b)
Cisco 7206 12.4(20)
Cisco 2811 15.0(1)
Cisco 2911 15.1(4)
Juniper M7i 8.2R1.7
Juniper EX9208 14.1R1.10
Juniper MX960 13.3
Juniper J2350 12.1X46-D35.1
HP 2920 WB.15.16.0006
HP e3500 K.15.16.0007
Brocade MLX-4 5.7.0bT177
Pica8 Pronto3290 v2.6

Blind data

behind

Blind SYN
in
out

Blind reset
in
out

OS
Port
date
ahead
range
2002-01 × (A) ! (I) × (R) ! (C) × (A) ! (C)
seq.
2002-01 × (A) ! (I) × (R) ! (C) × (A) ! (C)
seq.
2005-08 ! (C) ! (I) ! (C) ! (C) × (A) ! (C)
40785
2008-07 ! (C) ! (I) ! (C) ! (C) × (A) ! (C)
54167
2010-10 ! (C) ! (I) ! (C) ! (C) × (A) ! (C)
46166
2012-03 ! (C) ! (I) ! (C) ! (C) × (A) ! (C)
39422
2007-01 × (A) ! (I) × (R) ! (I) × (A) ! (C)
181
2014-06 ! (C) ! (I) ! (C) ! (I) × (A) ! (C)
13769
2015-05 ! (I) ! (I) ! (C) ! (I) × (A) ! (C)
13033
2015-05 ! (I) ! (I) ! (C) ! (I) × (A) ! (C)
12481
2015-01 ! (C) ! (C) ! (C) ! (C) ! (I)
! (I)
14273
2015-06 × (A) ! (I) × (R) ! (C) ! (I)
! (I)
15611
2014-10 ! (I) ! (I) ! (C) ! (C) ! (C) ! (C)
const.
2015-05 × (A) ! (I) × (R) ! (C) × (A) × (A) HBPS

Table 7: Laboratory testing of blind TCP attacks against BGP-speaking router and OpenFlow-speaking
switches. A cross-mark means the TCP connection accepted (A) or reset (R) in response to the packet that
it should have rejected. A tick-mark means the TCP connection challenged (C) or ignored (I) the packet. The
port range is reported from ten ephemeral port selections made by the device. Over time, implementations
have generally become more resilient to blind reset and SYN attacks, but not to blind data attacks.

We therefore used our oracle approach on a variety of
routers and switches available to us in a controlled labo-
ratory environment. To perform this testing, we added a
basic BGP application protocol [33] to scamper that sends
a valid BGP OPEN message with the correct autonomous
system number and no BGP options. We ensured that the
BGP keepalive time was large enough so that the router un-
der test did not prematurely terminate the TCP connection
during testing. Similarly, we implemented the basic Open-
Flow application protocol by sending an OpenFlow HELLO
message. We further explicitly conﬁgured each device we
tested to recognize our prober as a peer so that it would
establish a BGP or OpenFlow session, allowing the prober
to test the underlying TCP behavior. Concurrent to our
probing, we captured packets from the device under test so
that we could assess the device’s choice of ephemeral ports
from ten port selections, as we explain in the appendix.

Table 7 shows that while the overall protection mecha-
nisms within Cisco devices improved across subsequent re-
leases of the operating system, even versions released post
RFC 5961 exhibit weakness to the blind in-window data at-
tack. In fact, only 2 of 14 devices we tested were not vulner-
able to any of the blind attacks tested (the HP 2920 and the
Brocade MLX-4 switches). All of the Cisco and Juniper de-
vices we tested accepted the data with an acknowledgment
number behind the range recommended by RFC 5961.

Relatively obsolete operating systems (Cisco 12.1, 12.2,
Juniper 8.2) used sequential or a small range of ephemeral
ports, making these more predictable. While modern Cisco
devices used a much wider ephemeral port range, modern
Juniper and HP systems drew from a 16k range.

All systems we tested correctly ignored or challenged re-
set and SYN packets that were out of window, and all but
one (the Pica8 switch) correctly rejected the data that used
an acknowledgment value ahead of the sender’s send win-
dow. The Pica8 OpenFlow switch was built on a Linux
2.6.27 kernel and selected ephemeral ports using a hash-
based ephemeral port selection (HBPS) algorithm, but was
vulnerable to four of the six tests.

5.2 Implications

Most devices we tested correctly ignored SYN and reset
packets that could have come from a blind attacker, but
few rejected data with a behind-window acknowledgment
value. We encourage operators to remain vigilant in deploy-
ing available defense mechanisms such as GTSM [15] and
TCP authentication options [16, 37] to ensure the security
of their infrastructure, as well as ingress ﬁlter packets with
a source address purporting to be from their infrastructure
but arriving from outside of their network [4, 12].

6. PORT SELECTION OBSERVATIONS

Finally, we used passive network traces to infer current
ephemeral port selection algorithms in deployed TCP stacks.
Our goal was to understand the current degree to which TCP
endpoints use an ephemeral port selection algorithm that is
predictable, i.e.
selecting ports in sequence using a cen-
tral counter; as discussed in section 2.2, a predictable port
selection algorithm can make a blind attacker’s job easier.
However, gaining an accurate picture of the deployment of
port selection algorithms using passive data is diﬃcult for
a number of reasons. Figure 7 summarizes the two largest
challenges. First, multiple devices may share a single global
IP address if they are behind a router that does network
address translation. In ﬁgure 7, hosts X and Y are selecting
ephemeral port values sequentially in the range 1024–5000;
X selects 1050 at time T-1, and Y selects 1030 at time T-2.
Because these devices are behind a NAT device that rewrites
their source IP addresses, the port sequence observed begins
1050, 1030, i.e. goes backwards and therefore although not
predictable is not random.

Second, consider a passive tap at the edge of a network.
If we include the internal population of the edge network,
then we risk observing trends that do not hold in the general
population. However, if we use only the external population
who establish TCP connections to the internal population,
we can only observe an unknown fraction of the TCP con-
nections that each external host establishes.
In ﬁgure 7,
the passive tap does not observe connections from Y using

22Passive Tap

R2

 1

 0.8

R1

src−port
1050, T−1

src−ip
NAT

x

y

src−port
1030, T−2

src−port
1031, T−3
1032, T−4

.........

Figure 7: Challenges in using passive data to infer
port selection algorithms. A passive tap topologi-
cally distant from the sources it measures observes
an unknown fraction of the TCP connections estab-
lished by hosts X and Y. Further, X and Y might use
a predictable ephemeral ports assignment scheme,
but be behind a NAT that rewrites the source ad-
dress, which makes the predictable assignments in-
distinguishable from a hash-based counter.

source ports 1031, 1032, and so on. If the passive tap later
observes a connection established by Y, there may be a large
gap in the source port values chosen by Y.

Third, Linux hosts use a simple hash-based port selec-
tion technique to generate ephemeral ports, so the sequence
of ephemeral port values chosen by Linux systems may ap-
pear predictable, yet an attacker would have to know the
randomly-generated secret the system uses to select ephem-
eral port values to any given destination. To address this
concern, we only considered a source if we observed it estab-
lishing connections to multiple destinations.

In this section, we consider two sources of passive data:
(1) a passive tap operated by CAIDA on a Tier-1 ISP’s back-
bone link between Chicago and Seattle, which periodically
records 1-hour packet header traces, and (2) longitudinal
data recorded by a Bro intrusion detection system (IDS)
instance at ICSI containing logs of TCP ﬂows since 2005.
6.1 Equinix Chicago Passive Header Trace

CAIDA operates a passive monitor located at Equinix
Chicago, which since 2008 has captured a one-hour packet
header trace per-month from a Tier-1 ISP’s 10Gig Ether-
net backbone link between Chicago and Seattle (there was
an 18-month outage due to hardware failure from Septem-
ber 2011 to March 2013). From these ﬁles, we extracted
ephemeral ports with the following algorithm.

For each SYN packet, we created a 4-tuple containing the
source (the active opener) and destination IP addresses and
ports, as well as a ﬂag that records if the ﬂow carried data.
After two minutes had elapsed in the trace, we discarded the
ﬂow to allow for 4-tuple reuse. At this point we included the
ﬂow for further processing if we observed data transmission
and discarded it if no data was observed (i.e. the SYN was
a result of a scan or other anomalous behavior). Finally, we
grouped the 4-tuples by source IP address, and only consid-
ered sources that established at least ten TCP connections.

predictable
N=138144

49K − 64K

unpredictable
N=209738

 0.6

 0.4

n
o
i
t
c
a
r
F
 
e
v
i
t
a
l
u
m
u
C

 0.2

 0

0

8K

16K 24K 32K 40K 48K 56K 64K
Range of Ephemeral Port Selection

Figure 8: Range of ports observed (max - min) for
one hour packet trace collected on 19th March 2015
at 1pm UTC from a Tier-1 ISP link between Chicago
and Seattle. We observed that most port selections
used a fraction of the available port space, especially
the predictable port selections, where 50% of selec-
tions were in a range of 2K ports.

For each active opener, we classiﬁed the sequence of ports
as predictable (derived from a central counter) by consulting
a sliding windows of 3 ports at a time. We used windows of
3 ports at a time because these are the shortest window for
which we can test for an unpredictable sequence. We deemed
a single window to be “predictable” when ephemeral ports
were generally increasing – with the possibility of a single
wrap per window. For example, if we observed the ports [1,
2, 3], [2, 3, 1], or [3, 1, 2], then we would infer the use of
a counter, but if we observed [2, 1, 3], [3, 2, 1] or [1, 3, 2]
then we would infer the ports were selected unpredictably.
Note that this method would have incorrectly inferred some
busy active openers as unpredictable if we only observed
a fraction of their SYNs on the Chicago-Seattle link. We
also allowed for a small amount of packet reordering and
SYN loss: enough to allow for the ﬁrst retransmission of a
SYN which was previously lost before the SYN could have
crossed the link where we collected the passive header trace.
Speciﬁcally, if the diﬀerence between two port values was
less than 15 (a nominal value which is 0.4% of the smallest
ephemeral range in the operating systems listed in table 1)
and the diﬀerence in time was less than three seconds – then
we assumed the port values were generated in order and the
out-of-order observation was an artifact introduced by the
network. For a source IP address with 10 port observations,
we tested 8 windows; we inferred the address as generating
a predictable ephemeral port sequence if all windows were
inferred to be predictable.

Figure 8 shows the observed range (maximum - minimum)
of ephemeral ports for each source that established at least
10 connections over this link over the course of an hour on
19 March 2015 to at least two destinations. As shown in the
appendix, the expected port range given a host selecting
ephemeral ports at random from the entire 216 space given
10 observations is approximately 53,620. Of the hosts we in-
ferred to select predictable ephemeral ports, 50% established
all ports within a 2K port range – 3% of the total range of

23s
e
u
l
a
v

 
t
r
o
p

 
f
o
 
e
g
n
a
R

64K
56K
48K
40K
32K
24K
16K
8K
0

95th %

75th %

50th %

25th %
5th %

Jan
’06

Jan’07

Jan’08

Jan’09

Jan’10

Jan’11

Date

Jan’12

Jan’13

Jan’14

Jan’15

Figure 9: Range of ports observed (max - min) for one day of Bro logs collected one week per month since
October 2005 at ICSI. The points represent the 5th, 25th, 50th, 75th, and 95th percentiles for one day’s
traﬃc within each week. Beginning January 2014, the range of ports selected for the 25th percentile has
begun to widen.

port values potentially available, and 12% of the ephemeral
port range recommended by IANA. Of the hosts we inferred
to use an unpredictable strategy, a third chose ports from at
least a range of 32K ports; a blind attacker would have to
use other sophisticated means to infer port selection behav-
ior of these hosts [14]. These results are consistent with the
known port selection strategies of modern operating systems
shown in table 1. We conclude that some operating system
vendors continue to not follow best practices in ephemeral
port selection [23].
6.2 Longitudinal ICSI Trace

Finally, we investigated longitudinal patterns in port se-
lection using Bro logs collected at ICSI. We focused on in-
bound connections from external hosts, from sources that
established at least 10 data-carrying TCP connections to
internal hosts. Because of the sparsity of the data over the
course of a day, rather than try to infer whether or not
port selection is predictable or not, we instead focused on
the ranges observed to have been used by individual IP ad-
dresses. Figure 9 plots the ranges of ports selected from
October 2005 until May 2015. While the data is noisy, we
can see two encouraging shifts in port selection behavior.
First, between January 2006 and January 2008, the 95th per-
centile range rose from 32K to 62K, suggesting that systems
were gradually upgraded to choose ephemeral ports from a
larger range. Second, between October 2013 and May 2015,
the 25th percentile of port ranges gradually increases from
4K to 12K, suggesting a diﬀerent set of systems were gradu-
ally upgraded to choose ephemeral port ranges from a larger
range. We conjecture this trend is due to the well-publicized
end-of-life date for Windows XP systems, which chose port
values between 1024–5000 (see table 1).
6.3 Implications

Beyond these trends, it is diﬃcult to distill insight on port
selection algorithms from either passive data source (CAIDA
or ICSI) owing to many conﬂating factors. However, our
experimental data indicates that as of March 2015 that most
operating systems are choosing ports from a small fraction

of the ephemeral port ranges (ﬁgure 8) which is consistent
with MacOS and Windows operating systems choosing TCP
ephemeral ports sequentially (table 1).

7. DISCUSSION

Holistically, the ability of an attacker to mount a blind
attack is more diﬃcult than it was 2004, as there has been
some deployment of RFC 5961 into TCP stacks, and oper-
ating systems have been upgraded over time. In addition,
some operating systems are using automatic TCP buﬀer tun-
ing [35, 34] to increase the receive window as required, and
using small receive windows by default (ﬁgure 5). Never-
theless, we found a surprising fraction of webservers acted
inappropriately when they received a packet that could have
come from a blind attacker. In particular, defenses to blind
attackers forging data packets are less deployed than de-
fenses to reset and SYN packets, suggesting further imple-
mentation and deployment eﬀort is required. For example,
middleboxes that correctly challenged reset and SYN pack-
ets did not discard invalid data packets (section 4.3.2). In
addition, some popular operating systems (Windows and
MacOS) are choosing ephemeral ports from a 16K range in
a predictable fashion, allowing a blind attacker to optimize
their eﬀorts in relatively narrow port ranges.

8. RELATED WORK

Previous active measurement of TCP has focused on the
deployment and behavior of features that improve the per-
formance of TCP, such as algorithms used for congestion
control and slow-start [29, 28]. In addition, there has been
particular focus on the role that middleboxes play in ham-
pering deployment and use of TCP features (e.g. [27, 25, 5,
17, 11]). Our work focuses on active measurement of TCP
features that enhance TCP’s resilience to blind attack.

More recently, researchers have shown it is possible for
unprivileged malware deployed on a victim’s computer to
learn information that can help an otherwise blind attacker
to focus their eﬀorts [31], or even by visiting a malicious web-
site that uses a script to predict TCP parameters, including

24routers to test against. This work was supported in part
by U.S. NSF grants CNS-1111449, ACI-1127506, and CNS-
1237265, and by DHS S&T Cyber Security Division BAA
11-02 and SPAWAR Systems Center Paciﬁc via N66001-
12-C-0130 and Defence Research and Development Canada
(DRDC) pursuant to an Agreement between the U.S. and
Canadian governments for Cooperation in Science and Tech-
nology for Critical Infrastructure Protection and Border Se-
curity. This work represents the position of the authors and
not of NSF, DHS, DRDC, or the U.S. government. Matthew
Luckie conducted this work while at CAIDA, UC San Diego.

Appendix
In our analysis of ephemeral ports, we restricted our anal-
ysis to only those sources that established 10 or more con-
nections and reported on the ephemeral port range. For
the set of observed ephemeral ports S = {}, we compute
range = max(S) − min(S).
In this appendix, we derive
the expected value of range given a source that chooses
ports from a uniform random distribution over the inter-
val (0, high). (The following trivially extends to a non-zero
starting port range; we omit this detail for clarity). Given
n ﬂows from a source, the probability that the largest port
observed is k is given by:

P (max(S) = k) =

kn − (k − 1)n

highn

while the probability that the smallest port observed is k is:

P (min(S) = k) = P (max(S) = high − k)

Thus, the expected range is:
E[range] = E[max(S)] − E[min(S)]

=

high!k=1

k"P#max(S) = k$ − P#min(S) = k$%

For n = 10, we ﬁnd (corresponding to ranges of ephemeral
port numbers of operating systems in Table 1):
E[range|high = 216] ≃ 53620
E[range|high = 3976] ≃ 3253
E[range|high = 16384] ≃ 13404
E[range|high = 28232] ≃ 23098
E[range|high = 55535] ≃ 45438

source port values in the face of simple hash-based port se-
lection algorithms [14]. While dangerous and similar to the
attack we investigated, arguably the attackers in these cases
are not completely blind, which aids the attacker. Our work
holistically examines the state of TCP vulnerability to blind
attackers, in terms of TCP implementation, port selection,
and middlebox protections.

Convery and Franz examined the behavior of BGP speak-
ing routers in the wild in 2003 [9]. They encouraged oper-
ators to deploy ingress ﬁltering for router address space to
make blind attacks impossible from outside of the network,
and reported TCP enhancements (choosing ephemeral ports
unpredictably, and requiring the reset to exactly match the
receiver’s position in the sequence number space) made TCP
highly resistant to attacks. Our work examined the degree
to which TCP enhancements that make blind attacks diﬃ-
cult have been deployed.

9. CONCLUSION

TCP is the most important transport protocol in the In-
ternet, carrying the vast majority of the traﬃc volume on
the Internet, including web browsing, streaming video (e.g.,
YouTube and Netﬂix), email, and BGP. Because of its im-
portance, researchers and vendors are constantly developing
and deploying features to improve the security and perfor-
mance of TCP. However, for at least three reasons, little is
empirically known about the current state of TCP deploy-
ment: TCP features have evolved over time, there are many
vendors of operating systems and middleboxes, and there is
no dedicated instrumentation or sustained eﬀort to gather
longitudinal measurements on the deployed ecosystem.

Complicating the situation is the fact that TCP was im-
plemented with limited security functionality, and although
several RFCs have recommended modiﬁcations to improve
the security defenses of TCP, the adoption, conﬁguration,
and deployment of ﬁelded TCP improvements can be slow.
In this study we empirically assessed the resilience of de-
ployed commodity TCP implementations to blind in-window
attacks, where an oﬀ-path adversary can disrupt an estab-
lished connection, causing data corruption or connection re-
set. We also characterized router and switch behavior –
critical infrastructure where the impact of any TCP vulner-
abilities is particularly acute. We tested operating systems
(and middleboxes deployed in front) of webservers in the
wild and found 22% of connections vulnerable to in-window
SYN and reset packets, 30% vulnerable to in-window data
packets, and 38.4% vulnerable to at least one of the three
in-window attacks we tested. This surprisingly high level of
extant vulnerabilities we found in the most mature Internet
transport protocol in use today is a perfect illustration of
the Internet’s fragility. Given the largely unregulated and
insecure TCP/IP network architecture society relies on for
most of our communications, it also provides a strong case
for more systematic, scientiﬁc, and longitudinal measure-
ment and quantitative analysis of fundamental properties of
critical Internet infrastructure, as well as for the importance
of better mechanisms to get best security practices deployed.

Acknowledgments
We thank the UCSD systems and networking research group
for early feedback. Special thanks to John Gibson, Tom Hut-
ton, Bill Owens, and Brad Cowie for providing operational

25[22] S. Kent. IP authentication header. RFC 4302, Dec.

2005.

[23] M. Larsen and F. Gont. Recommendations for

transport-protocol port randomization. RFC 6056,
Jan. 2011.

[24] M. Luckie. Scamper: a scalable and extensible packet

prober for active measurement of the Internet. In
IMC, pages 239–245, Nov. 2010.

[25] M. Luckie and B. Stasiewicz. Measuring path MTU

discovery behaviour. In IMC, pages 102–108, Nov.
2010.

[26] M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow.
TCP selective acknowledgment options. RFC 2018,
Oct. 1996.

[27] A. Medina, M. Allman, and S. Floyd. Measuring

interactions between transport protocols and
middleboxes. In IMC, pages 336–341, Oct. 2004.

[28] A. Medina, M. Allman, and S. Floyd. Measuring the
evolution of transport protocols in the Internet. ACM
SIGCOMM Computer Communication Review,
35(2):37–52, 2005.

[29] J. Pahdye and S. Floyd. On inferring TCP behavior.

In SIGCOMM, pages 287–298, 2001.

[30] J. Postel. Transmission control protocol. RFC 791,

Sept. 1981.

[31] Z. Qian and Z. M. Mao. Oﬀ-path TCP sequence

number inference attack: How ﬁrewall middleboxes
reduce security. In IEEE Symposium on Security and
Privacy, pages 347–361, May 2012.

[32] A. Ramaiah, R. Stewart, and M. Dalal. Improving
TCP’s robustness to blind in-window attacks. RFC
5961, Aug. 2010.

[33] Y. Rekhter, T. Li, and S. Hares. A Border Gateway

Protocol 4 (BGP-4). RFC 4271 (Draft Standard), Jan.
2006.

[34] M. Sargent and M. Allman. Performance within a

ﬁber-to-the-home network. ACM SIGCOMM
Computer Communication Review, 44(3), July 2014.

[35] J. Semke, J. Mahdavi, and M. Mathis. Automatic
TCP buﬀer tuning. In SIGCOMM, pages 315–323,
Sept. 1998.

[36] J. Touch. Defending TCP against spooﬁng attacks.

RFC 4953, July 2007.

[37] J. Touch, A. Mankin, and R. Bonica. The TCP

authentication option. RFC 5925, June 2010.

[38] P. Watson. Slipping in the window: TCP reset

attacks, Apr. 2004.

[39] M. Zalewski. p0f v3 (version 3.08b).

http://lcamtuf.coredump.cx/p0f3/.

[40] M. Zalewski. Strange attractors and TCP/IP sequence

number analysis, 2002.

10. REFERENCES
[1] FreeBSD-SA-14:19.tcp: Denial of service in TCP

packet processing. https://www.freebsd.org/
security/advisories/FreeBSD-SA-14:19.tcp.asc.

[2] Alexa. Top 1,000,000 sites.

http://www.alexa.com/topsites.

[3] M. Allman. Comments on selecting ephemeral ports.
ACM SIGCOMM Computer Communication Review,
39(2):14–19, 2009.

[4] F. Baker and P. Savola. Ingress ﬁltering for

multihomed networks. RFC 3704, Mar. 2004.

[5] S. Bauer, R. Beverly, and A. Berger. Measuring the

state of ECN readiness in servers, clients, and routers.
In IMC, Nov. 2011.

[6] S. Bellovin. Defending against sequence number

attacks. RFC 1948, May 1996.

[7] R. Beverly, A. Berger, Y. Hyun, and k claﬀy.

Understanding the eﬃcacy of deployed Internet source
address validation. In IMC, pages 356–369, Nov. 2009.

[8] Cisco. TCP Vulnerabilities in Multiple IOS-Based
Cisco Products, 2004. http://tools.cisco.com/
security/center/content/CiscoSecurityAdvisory/
cisco-sa-20040420-tcp-ios.

[9] S. Convery and M. Franz. BGP vulnerability testing:

separating fact from FUD. In Blackhat, 2003.

[10] M. Cotton, L. Eggert, J. Touch, M. Westerlund, and

S. Cheshire. Internet assigned numbers authority
(IANA) procedures for the management of the service
name and transport protocol port number registry.
RFC 6335, Aug. 2011.

[11] R. Craven, R. Beverly, and M. Allman. A

middlebox-cooperative TCP for a non end-to-end
Internet. In SIGCOMM, pages 151–162, 2014.
[12] J. Durand, I. Pepelnjak, and G. Doering. BGP

Operations and Security. RFC 7454 (Best Current
Practice), Feb. 2015.

[13] P. Ferguson and D. Senie. Network ingress ﬁltering:
Defeating denial of service attacks which employ IP
source address spooﬁng. RFC 2827, May 2000.

[14] Y. Gilad and A. Herzberg. Oﬀ-path TCP injection

attacks. ACM Transactions on Information and
System Security, 16(4), Apr. 2014.

[15] V. Gill, J. Heasley, D. Meyer, and P. Savola. The

generalized TTL security mechanism (GTSM). RFC
5082, Oct. 2007.

[16] A. Heﬀernan. Protection of BGP sessions via the TCP

MD5 signature option. RFC 2385, Aug. 1998.

[17] B. Hesmans, F. Duchene, C. Paasch, G. Detal, and

O. Bonaventure. Are TCP extensions
middlebox-proof? In HotMiddlebox, pages 37–42, 2013.

[18] Y. Hyun and k. claﬀy. Archipelago measurement

infrastructure, 2015.
http://www.caida.org/projects/ark/.

[19] Internet Assigned Numbers Authority (IANA). Service

name and transport protocol port number registry.
http://www.iana.org/assignments/port-numbers.

[20] V. Jacobson, R. Braden, D. Borman, and

R. Scheﬀenegger. TCP Extensions for High
Performance. RFC 7323, Sept. 2014.

[21] D. Kaminsky. Black Ops 2008: It’s the end of the

cache as we know it. Black Hat USA, 2008.

26