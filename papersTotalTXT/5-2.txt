Aggregating CL-Signatures Revisited:

Extended Functionality and Better Eﬃciency

Kwangsu Lee1,2⋆, Dong Hoon Lee1⋆⋆, and Moti Yung2,3

1 CIST, Korea University, Korea
fguspin,donghleeg@korea.ac.kr
fkwangsu,motig@cs.columbia.edu

2 Columbia University, USA

3 Google Inc., USA

Abstract. Aggregate signature is public-key signature that allows any-
one to aggregate diﬀerent signatures generated by diﬀerent signers on
diﬀerent messages into a short (called aggregate) signature. The notion
has many applications where compressing the signature space is impor-
tant: in infrastructure: secure routing protocols, in security: compressed
certiﬁcate chain signature, in signing incrementally changed data: such
as software module authentications, and in transaction systems: like in
secure high-scale repositories and logs, typical in ﬁnancial transactions.
In spite of its importance, the state of the art of the primitive is such
that it has not been easy to devise a suitable aggregate signature scheme
that satisﬁes the conditions of real applications, with reasonable param-
eters: short public key size, short aggregate signatures size, and eﬃcient
aggregate signing/veriﬁcation. In this paper, we propose two aggregate
signature schemes based on the Camenisch-Lysyanskaya (CL) signature
scheme whose security is reduced to that of CL signature (i.e., secure un-
der the LRSW assumption) which substantially improve eﬃciency con-
ditions for real applications. The ﬁrst scheme is an “eﬃcient sequential
aggregate signature” scheme with the shortest size public key, to date,
and very eﬃcient aggregate veriﬁcation. The second scheme is an “eﬃ-
cient synchronized aggregate signature” scheme with a very short pub-
lic key size, and with the shortest (to date) size of aggregate signatures
among synchronized aggregate signature schemes. Signing and aggregate
veriﬁcation are very eﬃcient. The security of the schemes is proved by re-
ducing from the CL signature without random oracles (ﬁrst scheme) and
in the random oracle model (second scheme). Furthermore, our schemes
are compatible: a signer of our aggregate signature schemes can dynam-
ically use two modes of aggregation “sequential” and “synchronized,”
employing the same private/public key.

⋆ Supported by the MKE (The Ministry of Knowledge Economy), Korea, under the
ITRC (Information Technology Research Center) support program (NIPA-2012-
H0301-12-3007) supervised by the NIPA (National IT Industry Promotion Agency).
⋆⋆ Supported by the National Research Foundation of Korea (NRF) grant funded by

the Korea government (MEST) (No. 2012-0008697).

1 Introduction

Public-key signature (PKS) is a central cryptographic primitive with numerous
applications. However, constructing a PKS scheme that is eﬃcient, secure, and
ﬂexible enough for a range of possible applications is not easy. Among such
schemes, CL signature, proposed by Camenisch and Lysyanskaya [12], is one of
the pairing-based signature schemes [10, 8, 12, 23] that satisﬁes these conditions.
It was widely used as a basic component in various cryptosystems such as anony-
mous credential systems, group signature, RFID encryption, batch veriﬁcation
signature, ring signature [12, 3, 2, 11, 5], as well as in aggregate signature [21].

Pubic-key aggregate signature (PKAS), introduced by Boneh, Gentry, Lynn,
and Shacham [9], is a special type of PKS that enables anyone to aggregate
diﬀerent signatures generated by diﬀerent signers on diﬀerent messages into a
short aggregate signature. Boneh et al. proposed the ﬁrst full aggregate signature
scheme in bilinear groups and proved its security in the random oracle model
under the CDH assumption. After the introduction of aggregate signatures, var-
ious types of aggregate signatures such as sequential aggregate signatures [18,
17, 6, 15, 16] and synchronized aggregate signatures [14, 1] were proposed. PKAS
has numerous applications. In network and infrastructure: secure routing pro-
tocols, public-key infrastructure systems (signing certiﬁcate chains), sensor net-
work systems, proxy signatures, as well as in applications: dynamically changing
document composition (in particular, secure updating of software modules), se-
cure transaction signing, secure work ﬂow, and secure logs and repositories [9, 6,
1, 7]. In all these applications, compressing the space consumed by signatures is
the major advantage. Note that in the area of ﬁnancial transactions, in partic-
ular, logs and repositories are very large due to regulatory requirements to hold
records for long time periods. The eﬀect of compressing signatures by aggrega-
tion increases with the number of data items; thus it is quite plausible that the
ﬁnancial sector may ﬁnd variations of aggregate signature most useful.

Though PKAS can reduce the size of signers’ signatures by using the ag-
gregation technique, it cannot reduce the size of signers’ public keys since the
public keys are not aggregated. Thus, the total information the veriﬁer needs to
access is still proportional to the number of signers in the aggregate signature,
since the veriﬁer should retrieve all public keys of signers from a certiﬁcate stor-
age. Therefore, it is very important to reduce the size of public keys. An ideal
solution for this problem is to use identity-based aggregate signature (IBAS)
that represents the public key of a signer as an identity string. However, IBAS
requires a trust structure diﬀerent from public key infrastructure, namely, the
existence of an additional trusted authority, (the current IBAS schemes are in
[14, 6, 15] and are all secure in the random oracle model.) To construct a PKAS
scheme with short public keys, Schr¨oder proposed a sequential aggregate signa-
ture scheme with short public keys based on the CL signature scheme [21]. In
the scheme of Schr¨oder, the public key consists of two group elements and the
aggregate signature consists of four group elements, but the aggregate veriﬁca-
tion algorithm requires l pairing operations and l exponentiations where l is the
number of signers in the aggregate signature. Therefore, this work, while nicely

pointing at the CL signature as a source of eﬃciency for the context of aggre-
gate signatures, still leaves out desired properties to build upon while exploiting
the ﬂexibility of the CL signature: can we make the public key shorter? can we
require substantially less work in veriﬁcation? and, can we build other modes
of aggregate signatures? While asking such questions, we revisit the subject of
aggregate signature based on CL signatures.

1.1 Our Contributions

In this paper, we indeed solve the problem of constructing a PKAS scheme that
has short public keys, short aggregate signatures, and an eﬃcient aggregate ver-
iﬁcation algorithm. We ﬁrst propose an eﬃcient sequential aggregate signature
scheme based on the CL signature scheme and prove its security based on that of
CL signature (i.e., the LRSW assumption) without random oracles. A sequential
aggregate signature assumes that the aggregation mode is done in linear order:
signed message after signed message. In this scheme, the public key consists of
just one group element and the aggregate signature consists of just three group
element. The size of the public key is the shortest among all sequential aggregate
schemes to date (except IBAS schemes). The aggregate veriﬁcation algorithm of
our scheme is quite eﬃcient since it just requires ﬁve pairing operations and
l exponentiations (or multi-exponentiations). Therefore our scheme simultane-
ously satisﬁes the conditions of short public keys, short aggregate signatures,
and eﬃcient aggregate veriﬁcation.

Next, we propose an eﬃcient synchronized aggregate signature scheme based
on the CL signature scheme and prove its security based on the CL signature
security in the random oracle model (the random oracle can be removed if the
number of messages is restricted to be polynomial). Synchronized aggregate sig-
nature is a mode where the signers of messages to be aggregated are synchro-
nized, but aggregation can take any order. In this scheme, the public key consists
of just one group element and the aggregate signature consists of one group ele-
ment and one integer. The size of the aggregate signature is the shortest among
all synchronized aggregate signature schemes to date. The aggregate veriﬁcation
algorithm of this scheme is also quite eﬃcient since it just requires three pairing
operations and l exponentiations (or multi-exponentiations).

Additionally, our two aggregate signature schemes can be combined to give
a new notion of aggregate \multi-modal" signature scheme: A scheme which
supports, both, sequential aggregation or synchronized aggregation, since the
public key and the private key of two schemes are the same. This property can
increase the utility and ﬂexibility of the suggested scheme(s).

1.2 Related Work

Given the importance of aggregation to saving signature space, much work has
been invested in the various notions allowing aggregation.

Full Aggregation. The notion of public-key aggregate signature (PKAS) was
introduced by Boneh, Gentry, Lynn, and Shacham [9]. They proposed the ﬁrst

PKAS scheme in bilinear groups that supports full aggregation such that anyone
can freely aggregate diﬀerent signatures signed by diﬀerent signers on diﬀerent
messages into a short aggregate signature [9]. The PKAS scheme of Boneh et al.
requires l number of pairing operations in the aggregate veriﬁcation algorithm
where l is the number of signers in the aggregate signature. Bellare et al. modiﬁed
the PKAS scheme of Boneh et al. to remove the restriction such that the message
should be diﬀerent by hashing a message with the public key of a signer [4].

Sequential Aggregation. The concept of sequential aggregate signature was
introduced by Lysyanskaya, Micali, Reyzin, and Shacham [18]. In sequential ag-
gregate signature, a signer can generate an aggregate signature by adding his
signature to the previous aggregate signature that was received from a previous
signer. Lysyanskaya et al. proposed a sequential PKAS scheme using certiﬁed
trapdoor permutations, and they proved its security in random oracle models
[18]. Boldyreva et al. proposed an identity-based sequential aggregate signature
(IBSAS) scheme (in the trust model of identity-based schemes with a trusted
private keys authority), in bilinear groups and proved its security in the ran-
dom oracle model under an interactive assumption [6]. Recently, Gerbush et al.
showed that a modiﬁed IBSAS scheme of Boldyreva et al. in composite order bi-
linear groups can be secure in the random oracle model under static assumptions
[15].

The ﬁrst sequential PKAS scheme without random oracles was proposed by
Lu et al. [17]. They constructed a sequential PKAS scheme based on the PKS
scheme of Waters and proved its security without random oracles under the
CDH assumption. However, this sequential PKAS scheme has a disadvantage
such that the size of public keys is very long. To reduce the size of pubic keys
in PKAS schemes, Schr¨oder proposed the CL signature based scheme discussed
above [21]. Recently, Lee et al. proposed an eﬃcient sequential PKAS scheme
with short public keys and proved its security without random oracles under
static assumptions [16].

Synchronized Aggregation. The concept of synchronized aggregate signature
was introduced by Gentry and Ramzan [14]. In synchronized aggregate signa-
ture, all signers have synchronized time information and individual signatures
generated by diﬀerent signers within the same time period can be aggregated
into a short aggregate signature. They proposed an identity-based synchronized
aggregate signature scheme in bilinear groups and proved its security in the
random oracle model under the CDH assumption [14]. Ahn et al. proposed an
eﬃcient synchronized PKAS scheme based on the PKS scheme of Hohenberger
and Waters and proved its security without random oracles under the CDH
assumption [1].

2 Preliminaries

In this section, we deﬁne bilinear groups, and introduce the LRSW assumption
which is associated with the security of the CL signature scheme, which is, then,
presented as well.

2.1 Bilinear Groups
Let G and GT be multiplicative cyclic groups of prime order p. Let g be a
generator of G. The bilinear map e : G × G → GT has the following properties:
1. Bilinearity: ∀u, v ∈ G and ∀a, b ∈ Zp, e(ua, vb) = e(u, v)ab.
2. Non-degeneracy: ∃g such that e(g, g) has order p, that is, e(g, g) is a generator

of GT .

We say that G, GT are bilinear groups if the group operations in G and GT as
well as the bilinear map e are all eﬃciently computable.

2.2 Complexity Assumption

The security of our aggregate signature schemes is based on the following LRSW
assumption. The LRSW assumption was introduced by Lysyanskaya et al. [19]
and it is secure under the generic group model deﬁned by Shoup [22] (and
adapted to bilinear groups in [12]).
Assumption 1 (LRSW) Let G be an algorithm that on input the security pa-
rameter 1λ, outputs the parameters for a bilinear group as (p, G, GT , e, g). Let
X, Y ∈ G such that X = gx, Y = gy for some x, y ∈ Zp. Let OX,Y (·) be an oracle
that on input a value M ∈ Zp outputs a triple (a, ay, ax+M xy) for a randomly
chosen a ∈ G. Then for all probabilistic polynomial time adversaries A,

Pr[(p, G, GT , e, g) ← G(1λ), x ← Zp, y ← Zp, X = gx, Y = gy,

(M, a, b, c) ← AOX;Y (·)(p, G, GT , e, g, X, Y ) :
M /∈ Q ∧ M ∈ Z∗

∧ a ∈ G ∧ b = ay ∧ c = ax+M xy] < 1/poly(λ)

p

where Q is the set of queries that A made to OX,Y (·).

2.3 The CL Signature Scheme

The CL signature scheme is a public-key signature scheme that was proposed by
Camenisch and Lysyanskaya [12] and the security was proven without random
oracles under the LRSW assumption. Although the security of the CL signature
scheme is based on this interactive assumption, it is ﬂexible and widely used for
the constructions of various cryptosystems [19, 12, 5, 11, 21] (this is so, perhaps
due to its relatively elegant and simple algebraic structure).

PKS.KeyGen(1λ): The key generation algorithm ﬁrst generates the bilinear
groups G, GT of prime order p of bit size Θ(λ). Let g be the generator of G. It
selects two random exponents x, y ∈ Zp and sets X = gx, Y = gy. It outputs
a private key as SK = (x, y) and a public key as P K = (p, G, GT , e, g, X, Y ).
PKS.Sign(M, SK): The signing algorithm takes as input a message M ∈ Z∗
and a private key SK = (x, y). It selects a random element A ∈ G and
computes B = Ay, C = AxBxM . It outputs a signature as σ = (A, B, C).

p

PKS.Verify(σ, M, P K): The veriﬁcation algorithm takes as input a signature
σ = (A, B, C) on a message M ∈ Z∗
p under a public key P K = (p, G, GT , e,
g, X, Y ). It veriﬁes that e(A, Y ) ?= e(B, g) and e(C, g) ?= e(A, X)· e(B, X)M .
If these equations hold, then it outputs 1. Otherwise, it outputs 0.

Theorem 2 ([12]). The CL signature scheme is existentially unforgeable under
a chosen message attack if the LRSW assumption holds.

3 Sequential Aggregate Signature

In this section, we propose an eﬃcient sequential aggregate signature (SeqAS)
scheme based on the CL signature scheme, and prove its security without random
oracles.

3.1 Deﬁnitions

Sequential aggregate signature (SeqAS) is a special type of public-key aggregate
signature (PKAS) that allows each signer to sequentially add his signature on
a diﬀerent message to the aggregate signature [18]. That is, a signer with an
Σ from the signer of an index i − 1,
′
index i receives an aggregate signature σ
and he generates a new aggregate signature σΣ by aggregating his signature
on a message M to the received aggregate signature. The resulting aggregate
signature has the same size of the previous aggregate signature.

Formally, a SeqAS scheme consists of four PPT algorithms Setup, KeyGen,

AggSign, and AggVerify, which are deﬁned as follows:

– Setup(1λ). The setup algorithm takes as input a security parameter 1λ and

outputs public parameters P P .

– KeyGen(P P ). The key generation algorithm takes as input the public pa-

– AggSign(σ

rameters P P , and outputs a public key P K and a private key SK.

′
Σ, M, PK, M, SK, P P ). The aggregate signing algorithm takes
′
as input an aggregate-so-far σ
Σ on messages M = (M1, . . . , Mk) under public
keys PK = (P K1, . . . , P Kk), a message M , and a private key SK with P P ,
and outputs a new aggregate signature σΣ.

– AggVerify(σΣ, M, PK, P P ). The aggregate veriﬁcation algorithm takes as
input an aggregate signature σΣ on messages M = (M1, . . . , Ml) under pub-
lic keys PK = (P K1, . . . , P Kl) and the public parameters P P , and outputs
either 1 or 0 depending on the validity of the aggregate signature.

The correctness requirement is that for each P P output by Setup, for all
′
(P K, SK) output by KeyGen, any M , we have that AggVerify(AggSign(σ
Σ,
′||M, PK
M
′
so-far signature on messages M

′||P K, P P ) = 1 where σ

under public keys PK

′
Σ is a valid aggregate-

, PK

, M, SK, P K, P P ), M

′

.

′

′

The security model of SeqAS was introduced by Lysyanskaya et al. [18]. In
this paper, we follow the security model that was proposed by Lu et al. [17].
The security model of Lu et al. is a more restricted model that requires the

adversary to correctly generate other signers’ public keys and private keys except
the challenge signer’s key. To ensure the correct generation of public keys and
private keys, the adversary should submit the corresponding private keys of the
public keys to the challenger before using the public keys. A realistic solution of
this is for the signer to prove that he knows the corresponding private key of the
public key by using zero-knowledge proofs when he requests the certiﬁcation of
his public key.

Formally, the security notion of existential unforgeability under a chosen mes-
sage attack is deﬁned in terms of the following experiment between a challenger
C and a PPT adversary A:
Setup: C ﬁrst initializes a key-pair list KeyList as empty. Next, it runs Setup
to obtain public parameters P P and KeyGen to obtain a key pair (P K, SK),
and gives P K to A.
Certiﬁcation Query: A adaptively requests the certiﬁcation of a public key
by providing a key pair (P K, SK). Then C adds the key pair (P K, SK) to
KeyList if the key pair is a valid one.
Signature Query: A adaptively requests a sequential aggregate signature (by
′
providing an aggregate-so-far σ
),
under public keys PK
on a message M to sign under the challenge public key P K, and receives a
sequential aggregate signature σΣ.
Output: Finally (after a sequence of the above queries), A outputs a forged
∗
∗
under public keys PK
.
Σ on messages M
sequential aggregate signature σ
C outputs 1 if the forged signature satisﬁes the following three conditions,
∗
, P P ) = 1, 2) The chal-
or outputs 0 otherwise: 1) AggVerify(σ
∗
lenge public key P K must exist in PK
except
the challenge public key must be in KeyList, and 3) The corresponding mes-
sage M in M
of the challenge public key P K must not have been queried
by A to the sequential aggregate signing oracle.

∗
∗
Σ, M
and each public key in PK

′
′
Σ on messages M

∗

∗

, PK

∗

The advantage of A is deﬁned as AdvSeqASA

= Pr[C = 1] where the probability
is taken over all the randomness of the experiment. A SeqAS scheme is existen-
tially unforgeable under a chosen message attack if all PPT adversaries have at
most a negligible advantage (for large enough security parameter) in the above
experiment.

3.2 Construction

We ﬁrst describe the design idea of our SeqAS scheme. To construct a SeqAS
scheme, we use the “public key sharing” technique such that the element Y in
the public key of the original CL signature scheme can be shared with all signers.
The modiﬁed CL signature scheme that shares the element Y of the public key
is described as follows: The setup algorithm publishes the public parameters
that contain the description of bilinear groups and an element Y . Each signer

generates a private key x ∈ Zp and a public key X = gx. A signer who has

the private key x of the public key X can generate an original CL signature

σ = (A, B, C) on a message M just using the private key x and a random r as
A = gr, B = Y r, and C = AxBxM since the element Y is given in the public
parameters.

We construct a SeqAS scheme based on the modiﬁed CL signature scheme
that supports “public key sharing” by using the “randomness re-use” technique
of Lu et al. [17]. It is easy to sequentially aggregate signatures if the element
Y is shared with all signers since we only need to consider the aggregation of

the {Xi} values of signers instead of the {Xi, Yi} values of signers. For instance,
the ﬁrst signer who has a private key x1 generates a signature σ1 = (A1, B1, C1)
on a message M1 as A1 = gr1, B1 = Y r1, and C1 = (gr1)x1 (Y r1 )x1M1. The
second signer with a private key x2 generates a sequential aggregate signa-
ture σ2 = (A2, B2, C2) on a message M2 as A2 = A1, B2 = B1, and C2 =
C1(A1)x2 (B1)x2M2 by using the “randomness re-use” technique. Therefore a se-
quential aggregate signature of signers is formed as σΣ = (A = gr, B = Y r, C =
xiMi). Additionally, each signer should re-randomize the aggregate sig-
A
nature to prevent a simple attack.

∑

∑

xiB

Our SeqAS scheme is described as follows:

SeqAS.Setup(1λ): This algorithm ﬁrst generates the bilinear groups G, GT of
prime order p of bit size Θ(λ). Let g be the generator of G. It chooses a ran-
dom element Y ∈ G and outputs public parameters as P P = (p, G, GT , e, g, Y ).
P P . It selects a random exponent x ∈ Zp and sets X = gx. Then it outputs

SeqAS.KeyGen(P P ): This algorithm takes as input the public parameters

′

′

a private key as SK = x and a public key as P K = X.

′
′
Σ, M
SeqAS.AggSign(σ
, PK
, M, SK, P P ): This algorithm takes as input an
′
′
= (M1, . . . , Mk) under
Σ = (A
, B
aggregate-so-far σ
= (P K1, . . . , P Kk) where P Ki = Xi, a message M ∈ Z∗
′
p,
public keys PK
′
Σ by
and a private key SK = x with P P . It ﬁrst checks the validity of σ
′
Σ is not valid, then it halts. It
calling AggVerify(σ
′
. If
checks that the public key P K of SK does not already exist in PK
′
the public key already exists, then it halts. Note that if k = 0, then σ
Σ =

) on messages M

, P P ). If σ

′
Σ, M

, PK

, C

′

′

(g, Y, 1). It selects a random exponent r ∈ Zp and computes
)xM

′
A = (A

)r, B = (B

)x · (B

′ · (A

)r, C =

C

′

′

′

)r

.

′

′

(

It outputs an aggregate signature as σΣ = (A, B, C).

SeqAS.AggVerify(σΣ, M, PK, P P ): This algorithm takes as input an aggre-
gate signature σΣ = (A, B, C) on messages M = (M1, . . . , Ml) under public
keys PK = (P K1, . . . , P Kl) where P Ki = Xi. It ﬁrst checks that any Mi is
in Z∗
p, any public key does not appear twice in PK, and any public key in
PK has been certiﬁed. If these checks fail, then it outputs 0. If l = 0, then
it outputs 1 if σΣ = (1, Y, 1), 0 otherwise. Next, it veriﬁes that

l∏

l∏

e(A, Y ) ?= e(B, g) and e(C, g) ?= e(A,

Xi) · e(B,

X Mi

i

).

If these equations hold, then it outputs 1. Otherwise, it outputs 0.

i=1

i=1

A sequential aggregate signature σΣ = (A, B, C) on messages M = (M1, . . . , Ml)

under public keys PK = (P K1, . . . , P Kl) has the following form

(

)∑

(

)∑

gr

l
i=1 xi

Y r

l
i=1 xiMi

A = gr, B = Y r, C =

where P Ki = Xi = gxi.

3.3 Security Analysis

We prove the security of our SeqAS scheme based on the security of the CL
signature scheme without random oracles.

Theorem 3. The above SeqAS scheme is existentially unforgeable under a cho-
sen message attack if the CL signature scheme is existentially unforgeable under
a chosen message attack.

Proof. The main idea of the security proof is that the aggregated signature of
our SeqAS scheme is independent of the order of aggregation, and the simulator
of the SeqAS scheme possesses the private keys of all signers except the private
key of the challenge public key. That is, if the adversary requests a sequential
aggregate signature, then the simulator ﬁrst obtains a CL signature from the
target scheme’s signing oracle and runs the aggregate signing algorithm to gen-
erate a sequential aggregate signature. If the adversary ﬁnally outputs a forged
sequential aggregate signature that is non-trivial, then the simulator extracts
the CL signature of the challenge public key from the forged aggregate signature
by using the private keys of other signers.
Suppose there exists an adversary A that forges the above SeqAS scheme
with non-negligible advantage ϵ. A simulator B that forges the CL signature
scheme is ﬁrst given: a challenge public key P KCL = (p, G, GT , e, g, X, Y ). Then
B that interacts with A is described as follows:
Setup: B ﬁrst constructs P P = (p, G, GT , e, g, Y ) and P K

= X from P KCL.
Next, it initializes a key-pair list KeyList as an empty one and gives P P
and P K
Certiﬁcation Query: A adaptively requests the certiﬁcation of a public key
by providing a public key P Ki = Xi and its private key SKi = xi. B checks
the private key and adds the key pair (P Ki, SKi) to KeyList.
Signature Query: A adaptively requests a sequential aggregate signature by
= (M1, . . . , Mk) under
= (P K1, . . . , P Kk), and a message M to sign under the
. B proceeds the aggregate signature query as

′
′
Σ on messages M

to A.

∗

∗

′

providing an aggregate-so-far σ
public keys PK
challenge private key of P K
follows:
1. It ﬁrst checks that the signature σ
′
and that each public key in PK

∗

′
Σ is valid by calling SeqAS.AggVerify
exits in KeyList.

2. It queries its signing oracle that simulates PKS.Sign on the message M

for the challenge public key P K

and obtains a signature σ.

∗

3. For each 1 ≤ i ≤ k, it constructs an aggregate signature on message Mi

∗

using SeqAS.AggSign since it knows the private key that corresponds
to P Ki. The resulting signature is an aggregate signature for messages
M
since this scheme does not check
the order of aggregation. It gives the result signature σΣ to A.
∗

′||M under public keys PK

′||P K

Output: A outputs a forged aggregate signature σ
= (M1, . . . , Ml) under public keys PK

∗
sages M
some l. Without loss of generality, we assume that P K1 = P K
as follows:
1. B ﬁrst checks the validity of σ

∗
∗
Σ = (A

∗
Σ by calling SeqAS.AggVerify. Addi-
tionally, the forged signature should not be trivial: the challenge public
key P K
, and the message M1 must not be queried by
A to the signature query oracle.

must be in PK

) on mes-
, C
= (P K1, . . . , P Kl) for
. B proceeds

, B

∗

∗

∗

∗

∗

2. For each 2 ≤ i ≤ l, it parses P Ki = Xi from PK
(

((

private key SKi = xi of P Ki from KeyList. It then computes

∗

, and it retrieves the

)−1

∗)∑

∗

l
i=2 xi

B

l
i=2 xiMi

.

, B = B

, C = C

A

∗ ·

∗
A = A

∗

∗)∑

∗

This completes our proof.

3.4 Discussions

Eﬃciency. The public key of our SeqAS scheme consists of just one group el-
ement and the aggregate signature consists of three group elements, since the
public key element Y of the CL signature scheme is moved to the public pa-
rameters of our scheme. The aggregate signing algorithm requires one aggregate
veriﬁcation and ﬁve exponentiations, and the aggregate veriﬁcation algorithm
requires ﬁve pairing operations and l exponentiations where l is the number of
signers in the aggregate signature. In the SeqAS scheme of Schr¨oder [21], the

3. It outputs σ

= M1 as a non-trivial forgery
of the CL signature scheme since it did not make a signing query on M1.

= (A, B, C) on a message M

To ﬁnish the proof, we ﬁrst show that the distribution of the simulation is
correct. It is obvious that the public parameters and the public key are correctly
distributed. The distribution of the sequential aggregate signatures is correct
since this scheme does not check the order of aggregation. Finally, we can show
= (A, B, C) of the simulator is a valid signature
that the resulting signature σ
for the CL signature scheme on the message M1 under the public key P K
since
it satisﬁes the following equation:

∗

∗

e(C, g) = e(C

= e((A

∗ ·(
∑

∑

∗
(A

)

l

i=1 xi(B

∗
∗

)
)x1(B

l

i=2 xi(B

∑

)

∗
l
i=2 xiMi
i=1 xiMi · (A
∗

l

∗

)

∗

∗
)x1M1 , g) = e(A

∑

)−1
−∑
, gx1 ) · e(B

, g)

)

l

∗

= e((A
= e(A, X) · e(B, X M

(cid:3)

).

−∑

∗

)

l

i=2 xiMi , g)

i=2 xi(B

, gx1M1 )

⊓⊔

public key consists of two group elements, the aggregate signature consists of
four group elements, and the aggregate veriﬁcation algorithm requires l pairing
operations and l exponentiations.

4 Synchronized Aggregate Signature

In this section, we propose an eﬃcient synchronized aggregate signature (Syn-
cAS) scheme based on the CL signature scheme, and prove its security in the
random oracle model.

4.1 Deﬁnitions

Synchronized aggregate signature (SyncAS) is a special type of public-key ag-
gregate signature (PKAS) that allows anyone to aggregate signer’s signatures
on diﬀerent messages with a same time period into a short aggregate signature
if all signers have the synchronized time period information like a clock [14, 1].
In SyncAS scheme, each signer has a synchronized time period or has an access
to public time information. Each signer can generate an individual signature
on a message M and a time period w. Note that the signer can generate just
one signature per one time period. After that, anyone can aggregate individual
signatures of other signers into a short aggregate signature σΣ if the individual
signatures are generated on the same time period w. The resulting aggregate
signature has the same size of the individual signature.

Formally, a SyncAS scheme consists of six PPT algorithms Setup, KeyGen,

Sign, Verify, Aggregate, and AggVerify, which are deﬁned as follows:

– Setup(1λ). The setup algorithm takes as input a security parameter 1λ and

outputs public parameters P P .

– KeyGen(P P ). The key generation algorithm takes as input the public pa-

rameters P P , and outputs a public key P K and a private key SK.

– Sign(M, w, SK, P P ). The signing algorithm takes as input a message M , a
time period w, and a private key SK with P P , and outputs an individual
signature σ.

– Verify(σ, M, P K, P P ). The veriﬁcation algorithm takes as input a signa-
ture σ on a message M under a public key P K, and outputs either 1 or 0
depending on the validity of the signature.

– Aggregate(S, M, PK). The aggregation algorithm takes as input individual
signatures S = (σ1, . . . , σl) on messages M = (M1, . . . , Ml) under public keys
PK = (P K1, . . . , P Kl), and outputs an aggregate signature σΣ.

– AggVerify(σΣ, M, PK, P P ). The aggregate veriﬁcation algorithm takes as
input an aggregate signature σΣ on messages M = (M1, . . . , Ml) under pub-
lic keys PK = (P K1, . . . , P Kl), and outputs either 1 or 0 depending on the
validity of the aggregate signature.

The correctness requirement is that for each P P output by Setup, for all
(P K, SK) output by KeyGen, any M , we have that AggVerify(Aggregate(S,

M, PK), M, PK, P P ) = 1 where S is individual signatures on messages M un-
der public keys PK.

The security model of SyncAS was introduced by Gentry and Ramzan [14].
In this paper, we follow the security model that was proposed by Ahn et al.
[1]. The security model of Ahn et al. is a more restricted model that requires
the adversary to correctly generate other signers’ public keys and private keys
except the challenge signer’s key. To ensure the correct generation of public keys
and private keys, the adversary should submit the private key of the public
key, or he should prove that he knows the corresponding private key by using
zero-knowledge proofs.

tions, and receives a hash value.

Formally, the security notion of existential unforgeability under a chosen mes-
sage attack is deﬁned in terms of the following experiment between a challenger
C and a PPT adversary A:
Setup: C ﬁrst initializes a key-pair list KeyList as empty. Next, it runs Setup
to obtain public parameters P P and KeyGen to obtain a key pair (P K, SK),
and gives P K to A.
Certiﬁcation Query: A adaptively requests the certiﬁcation of a public key
by providing a key pair (P K, SK). Then C adds the key pair (P K, SK) to
KeyList if the key pair is a valid one.
Hash Query: A adaptively requests a hash on a string for various hash func-
Signature Query: A adaptively requests a signature on a message M and a
time period w that was not used before to sign under the challenge public
key P K, and receives an individual signature σ.
Output: Finally (after a sequence of the above queries), A outputs a forged
under public keys
synchronized aggregate signature σ
. C outputs 1 if the forged signature satisﬁes the following three condi-
PK
∗
∗
∗
, P P ) = 1, 2) The
Σ, M
tions, or outputs 0 otherwise: 1) AggVerify(σ
∗
∗
challenge public key P K must exist in PK
and each public key in PK
except the challenge public key must be in KeyList, and 3) The correspond-
∗
ing message M in M
of the challenge public key P K must not have been
queried by A to the signing oracle.
A

= Pr[C = 1] where the probability
The advantage of A is deﬁned as AdvSyncAS
is taken over all the randomness of the experiment. A SyncAS scheme is existen-
tially unforgeable under a chosen message attack if all PPT adversaries have at
most a negligible advantage (for large enough security parameter) in the above
experiment.

∗

∗
Σ on messages M

∗

, PK

4.2 Construction

We ﬁrst describe the design idea of our SyncAS scheme. In the previous section,
we proposed a modiﬁed CL signature scheme that shares the element Y in the
public parameters. The signature of this modiﬁed CL signature scheme is formed
as σ = (A = gr, B = Y r, C = AxBxM ). If we can force signers to use the same

∑

∑

xi B

A = gr and B = Y r in signatures, then we easily obtain an aggregate signature
as σΣ = (A = gr, B = Y r, C = A
xiMi) by just multiplying individual
signatures of signers. In synchronized aggregate signatures, it is possible to force
signers to use the same A and B since all signers have the same time period w.
Therefore, each signer ﬁrst sets A = H(0||w) and B = H(1||w) using the hash
function H and the time period w, and then he generates an individual signature
σ = (C = AxBxM , w). We need to hash a message for the proof of security.
Let W be a set of time periods where |W| is ﬁxed polynomial in the security

parameter4. Our SyncAS scheme is described as follows:

SyncAS.KeyGen(P P ): This algorithm takes as input the public parameters

SyncAS.Setup(1λ): This algorithm ﬁrst generates the bilinear groups G, GT
of prime order p of bit size Θ(λ). Let g be the generator of G. It chooses two
hash functions H1 : {0, 1} × W → G and H2 : {0, 1}∗ × W → Z∗
p. It outputs
public parameters as P P = (p, G, GT , e, g, H1, H2).
P P . It selects a random exponent x ∈ Zp and sets X = gx. Then it outputs
a private key as SK = x and a public key as P K = X.
SyncAS.Sign(M, w, SK, P P ): This algorithm takes as input a message M ∈
{0, 1}∗
, a time period w ∈ W, and a private key SK = x with P P . It ﬁrst
sets A = H1(0||w), B = H1(1||w), h = H2(M||w) and computes C = AxBxh.

It outputs a signature as σ = (C, w).

SyncAS.Verify(σ, M, P K, P P ): This algorithm takes as input a signature σ =
(C, w) on a message M under a public key P K = X. It ﬁrst checks that
the public key has been certiﬁed. If these checks fail, then it outputs 0.

Next, it sets A = H1(0||w), B = H1(1||w), h = H2(M||w) and veriﬁes that
e(C, g) ?= e(ABh, X). If this equation holds, then it outputs 1. Otherwise, it
outputs 0.

′
i, w

∏

′
1 is equal to w

′
i for i = 2 to l. If it fails, it halts. Next, it sets w = w
l
i=1 C

SyncAS.Aggregate(S, M, PK, P P ): This algorithm takes as input signatures
S = (σ1, . . . , σl) on messages M = (M1, . . . , Ml) under public keys PK =
′
i) and P Ki = Xi. It ﬁrst checks that that
(P K1, . . . , P Kl) where σi = (C
′
1 and
w
′
i. It outputs an aggregate signature as σΣ = (C, w).
computes C =
SyncAS.AggVerify(σΣ, M, PK, P P ): This algorithm takes as input an ag-
gregate signature σΣ = (C, w) on messages M = (M1, . . . , Ml) under pub-
lic keys PK = (P K1, . . . , P Kl) where P Ki = Xi. It ﬁrst checks that
any public key does not appear twice in PK and any public key in PK
has been certiﬁed. If these checks fail, then it outputs 0. Next, it sets

A = H1(0||w), B = H1(1||w), hi = H2(Mi||w) for all 1 ≤ i ≤ l and ver-
4 The set W does not need to be included in P P since an integer w in the range [1; T ]
can be used where T is ﬁxed polynomial in the security parameter. In practice, we
can set T = 232 if the maximum time period of certiﬁcates is 10 years and a signer
generates a signature per each second. The previous SyncAS schemes [14, 1] support
exponential size of time periods while our SyncAS scheme supports polynomial size
of time periods.

iﬁes that

l∏

i=1

l∏

i=1

X hi

i ).

Xi) · e(B,

e(C, g) ?= e(A,

If this equation holds, then it outputs 1. Otherwise, it outputs 0.

A synchronized aggregate signature σΣ = (C, w) on messages M = (M1, . . . , Ml)

under public keys PK = (P K1, . . . , P Kl) has the following form

∑

∑
i=1 xi H1(1||w)

l

l

i=1 xiH2(Mi||w)

C = H1(0||w)

where P Ki = Xi = gxi.

4.3 Security Analysis

We prove the security of our SyncAS scheme based on the security of the CL
signature scheme in the random oracle model.

Theorem 4. The above SyncAS scheme is existentially unforgeable under a cho-
sen message attack if the CL signature scheme is existentially unforgeable under
a chosen message attack.

′

′

′

Proof. The main idea of the security proof is that the random oracle model sup-
ports the programmability of hash functions, the adversary can request just one
signature per one time period in this security model, and the simulator possesses
the private keys of all signers except the private key of the challenge public key.
In the proof, the simulator ﬁrst guesses the time period w
of the forged syn-
chronized aggregate signature and selects a random query index k of the hash
function H2. After that, if the adversary requests a signature on a message M
and a time period w such that w ̸= w
, then he can easily generate the signature
by using the programmability of the random oracle model. If the adversary re-
quests a signature for the time period w = w
, then he can generate the signature
if the query index i is equal to the index k. Otherwise, the simulator should abort
the simulation. Finally, if the adversary outputs a forged synchronized aggregate
signature that is non-trivial on the time period w
, then the simulator extracts
the CL signature of the challenge public key from the forged aggregate signature
by using the private keys of other signers.
Suppose there exists an adversary A that forges the above SyncAS scheme
with non-negligible advantage ϵ. A simulator B that forges the CL signature
scheme is ﬁrst given: a challenge public key P KCL = (p, G, GT , e, g, X, Y ). Then
B that interacts with A is described as follows:
Setup: B ﬁrst constructs P P = (p, G, GT , e, g, H1, H2) and P K
= X from
′ ∈ Z∗
p and queries its signing oracle
P KCL. It chooses a random value h
′
). Let qH1 and qH2 be the maximum
PKS.Sign to obtain σ
, C
number of H1 and H2 hash queries respectively. It chooses a random index
k such that 1 ≤ k ≤ qH2 and guesses a random time period w
′ ∈ W of
the forged signature. Next, it initializes a key-pair list KeyList, hash lists
to A.
H1-List, H2-List as an empty one and gives P P and P K

′
= (A

, B

∗

∗

′

′

′

′

query as follows:

H1(0||wi) = gri .

H1(1||wi) = gsi.

Certiﬁcation Query: A adaptively requests the certiﬁcation of a public key
by providing a public key P Ki = Xi and its private key SKi = xi. B checks
the private key and adds the key-pair (P Ki, SKi) to KeyList.
Hash Query: A adaptively requests a hash value for H1 and H2 respectively.
If this is a H1 hash query on a bit b and a time period wi, then B treats the
, then it selects a random exponent ri ∈ Zp and sets
– If b = 0 and wi ̸= w
, then it sets H1(0||wi) = A
′
′
– If b = 0 and wi = w
, then it selects a random exponent si ∈ Zp and sets
– If b = 1 and wi ̸= w
′
, then it sets H1(1||wi) = B
′

– If b = 1 and wi = w
If this is a H2 hash query on a message Mi and a time period wj, then B
, then it selects a random value hi,j ∈ Zp and sets
– If i ̸= k or wj ̸= w
H2(Mi||wj) = hi,j.
, then it sets H2(Mi||wj) = h
′
– If i = k and wj = w
Note that the simulator keeps the tuple (bi, wi, ri, H1(bi||wi)) in H1-List and
the tuple (Mi, wj, hi,j) in H2-List.
Signature Query: A adaptively requests a signature by providing a message
. B

Mi and a time period wj to sign under the challenge private key of P K
proceeds the signature query as follows:
– If wi ̸= w

, then it responds σi,j = (X ri X sihi;j , wj) where ri, si, and hi,j

treats the query as follows:

∗

′

′

′

′

.

.

.

are retrieved from the H1-List and H2-List.
and i = k, then it responds σi,j = (C
and i ̸= k, it aborts the simulation.
Output: A outputs a forged aggregate signature σ
∗
Σ = (C

– If wi = w
– If wi = w

′
′

′

, wj).

∗

∗

∗

∗

, w
) on messages
= (P K1, . . . , P Kl) for some
. B proceeds as

= (M1, . . . , Ml) under public keys PK

M
l. Without loss of generality, we assume that P K1 = P K
follows:
1. It checks the validity of σ

∗
Σ by calling SyncAS.AggVerify. Addition-
ally, the forged signature should not be trivial: the challenge public key
, and the message M1 must not be queried by A
P K
to the signature query oracle.

∗

∗

∗

2. If w

, then it aborts the simulation since it fails to guess the forged

time period.

3. For each 2 ≤ i ≤ l, it retrieves the private key SKi = xi of P Ki from

must be in PK
∗ ̸= w

′

((
KeyList and sets hi,∗ = H2(Mi||w
∗ ·

, B = B

, C = C

A = A

∗

∗

∗

∗)∑

(

∗)∑

). Next, it computes

A

l
i=2 xi

B

l

i=2 xihi;(cid:3)

)−1

.

4. If H2(M1||w

5. It outputs σ

′

∗
) = h
∗
= (A, B, C) on a message h1,∗ as a non-trivial forgery of

, then it also aborts the simulation.

the CL signature scheme since h1,∗ ̸= h

′

where h1,∗ = H2(M1||w

∗

).

To ﬁnish the proof, we ﬁrst show that the distribution of the simulation is
correct. It is obvious that the public parameters and the public key are correctly
distributed. The distribution of the signatures is also correct. Next, we show
= (A, B, C) of the simulator is a valid signature
that the resulting signature σ
∗

for the CL signature scheme on the message h1,∗ ̸= h

under the public key P K

∗

′

since it satisﬁes the following equation:

)−1

l

l

)

(cid:3)

)

i=2 xiH2(Mi||w

∗
i=1 xihi;(cid:3) · (A
∗

−∑
, gx1 ) · e(B

)

∗

, g)
∗

−∑

l

i=2 xihi;(cid:3), g)

l

i=2 xi(B

)

, gx1h1;(cid:3))

e(C, g) = e(C

∗ ·(
∑

∑

∗
(A

)

l

i=2 xi (B

∑

∑

∗

)

i=1 xi(B

l

∗
)
= e((A
∗
∗
)x1 (B
= e((A
, X) · e(B
′
= e(A

∗
)x1h1;(cid:3), g) = e(A
′

, X h1;(cid:3)).

∗

∗

such that w

We now analyze the success probability of the simulator B. At ﬁrst, B suc-
ceeds the simulation if he does not abort in the simulation of signature queries
and he correctly guesses the time period w
in the forged
aggregate signature from the adversary A. B aborts the simulation of signature
is given from A and he incorrectly guessed the
queries if the time period w
index k since he cannot generate a signature. Thus B succeeds the simulation
−1
of signature queries at least q
probability since the outputs of H2 are inde-
pendently random. Next, B can correctly guess the time period w
H2
of the forged
aggregate signature with at least |W|−1 probability since he randomly chooses a
∗
is negligible. Therefore,
random w
) = h
the success probability of B is at least |W|−1·q
·AdvSyncAS
where AdvSyncAS
A
is the success probability of A. This completes our proof.
⊓⊔

. Note that the probability H2(M2||w
−1
H2

= w

A

∗

′

′

′

′

4.4 Discussions

Eﬃciency. The public key of our SyncAS scheme consists of just one group ele-
ment since our SyncAS scheme is derived from the SeqAS scheme of the previous
section, and the synchronized aggregate signature consists of one group element
and one integer since anyone can compute A, B using the hash functions. The
signing algorithm requires two group hash operations and two exponentiations,
and the aggregate veriﬁcation algorithm requires two group hash operations,
three pairing operations, and l exponentiations where l is the number of signers
in the aggregate signature. Our SyncAS scheme provides the shortest aggregate
signature size compared to the previous SyncAS schemes [14, 1]

Combined (Multi-Modal) Aggregate Signature. We can construct a com-
bined aggregate signature scheme that supports sequential aggregation and syn-
chronized aggregation at the same time by combining our SeqAS scheme and our
SyncAS scheme since the private key and the public key of our two schemes are
the same. In the combined aggregate signature scheme, the public parameters is
P P = (p, G, GT , e, g, Y, H1, H2), the private key and the public key are SK = x
and P K = X respectively. The security model of the combined aggregate sig-
natures can be deﬁned by combining the security models of SeqAS schemes and

SyncAS schemes. In this security model, the adversary is given sequential ag-
gregate signatures and synchronized aggregate signatures, and it ﬁnally outputs
a forged (sequential or synchronized) aggregate signature. The security proof of
the combined aggregate signature scheme easily follows from the security proof of
SeqAS schemes and the security proof of SyncAS schemes since the simulator’s
simulations of SeqAS signatures and SyncAS signatures can be done without
interference.

Removing Random Oracles. If the number of messages is restricted to be
polynomial, then we can use the universal one-way hash function [20, 13]. How-
ever, the SeqAS scheme using the universal one-way hash function of Canetti et
al. is ineﬃcient since it requires large number of exponentiations.

5 Conclusion

In this paper we concentrated on the notion of aggregate signatures which appli-
cations are in reducing space of signatures for large repositories (such as in the
legal, ﬁnancial, and infrastructure areas). We proposed a new sequential aggre-
gate signature scheme and a new synchronized aggregate signature scheme using
a newly devised “public key sharing” technique, and we proved their security
under the LRSW assumption. Our two aggregate signature schemes in this pa-
per suﬃciently satisfy the eﬃciency properties of aggregate signatures such that
the size of public keys should be short, the size of aggregate signatures should
be short, and the aggregate veriﬁcation should be eﬃcient.

References

1. Ahn, J.H., Green, M., Hohenberger, S.: Synchronized aggregate signatures: new
deﬁnitions, constructions and applications. In: ACM Conference on Computer and
Communications Security. (2010) 473–484

2. Ateniese, G., Camenisch, J., de Medeiros, B.: Untraceable rﬁd tags via insubvert-
ible encryption. In Atluri, V., Meadows, C., Juels, A., eds.: ACM Conference on
Computer and Communications Security, ACM (2005) 92–101

3. Ateniese, G., Camenisch, J., Hohenberger, S., de Medeiros, B.: Practical group
signatures without random oracles. Cryptology ePrint Archive, Report 2005/385
(2005) http://eprint.iacr.org/2005/385.

4. Bellare, M., Namprempre, C., Neven, G.: Unrestricted aggregate signatures. In
Arge, L., Cachin, C., Jurdzinski, T., Tarlecki, A., eds.: ICALP. Volume 4596 of
Lecture Notes in Computer Science., Springer (2007) 411–422

5. Bender, A., Katz, J., Morselli, R.: Ring signatures: Stronger deﬁnitions, and con-

structions without random oracles. J. Cryptology 22(1) (2009) 114–138

6. Boldyreva, A., Gentry, C., O’Neill, A., Yum, D.H.: Ordered multisignatures and
identity-based sequential aggregate signatures, with applications to secure routing.
Cryptology ePrint Archive, Report 2007/438 (2010) http://eprint.iacr.org/
2007/438.

7. Boldyreva, A., Palacio, A., Warinschi, B.: Secure proxy signature schemes for

delegation of signing rights. J. Cryptology 25(1) (2012) 57–115

8. Boneh, D., Boyen, X.: Short signatures without random oracles. In Cachin, C.,
Camenisch, J., eds.: EUROCRYPT. Volume 3027 of Lecture Notes in Computer
Science., Springer (2004) 56–73

9. Boneh, D., Gentry, C., Lynn, B., Shacham, H.: Aggregate and veriﬁably encrypted
signatures from bilinear maps. In Biham, E., ed.: EUROCRYPT. Volume 2656 of
Lecture Notes in Computer Science., Springer (2003) 416–432

10. Boneh, D., Lynn, B., Shacham, H.: Short signatures from the weil pairing.

In
Boyd, C., ed.: ASIACRYPT. Volume 2248 of Lecture Notes in Computer Science.,
Springer (2001) 514–532

11. Camenisch, J., Hohenberger, S., Pedersen, M.Ø.: Batch veriﬁcation of short signa-
tures. In Naor, M., ed.: EUROCRYPT. Volume 4515 of Lecture Notes in Computer
Science., Springer (2007) 246–263

12. Camenisch, J., Lysyanskaya, A.: Signature schemes and anonymous credentials
from bilinear maps. In Franklin, M.K., ed.: CRYPTO. Volume 3152 of Lecture
Notes in Computer Science., Springer (2004) 56–72

13. Canetti, R., Halevi, S., Katz, J.: A forward-secure public-key encryption scheme.
In Biham, E., ed.: EUROCRYPT. Volume 2656 of Lecture Notes in Computer
Science., Springer (2003) 255–271

14. Gentry, C., Ramzan, Z.: Identity-based aggregate signatures. In Yung, M., Dodis,
Y., Kiayias, A., Malkin, T., eds.: Public Key Cryptography. Volume 3958 of Lecture
Notes in Computer Science., Springer (2006) 257–273

15. Gerbush, M., Lewko, A.B., O’Neill, A., Waters, B.: Dual form signatures: An
approach for proving security from static assumptions.
In Wang, X., Sako, K.,
eds.: ASIACRYPT. Volume 7658 of Lecture Notes in Computer Science., Springer
(2012) 25–42

16. Lee, K., Lee, D.H., Yung, M.: Sequential aggregate signatures with short public
keys: Design, analysis, and implementation studies. In Kurosawa, K., Hanaoka, G.,
eds.: PKC. Volume 7778 of Lecture Notes in Computer Science., Springer (2013)
423–442

17. Lu, S., Ostrovsky, R., Sahai, A., Shacham, H., Waters, B.: Sequential aggregate
signatures and multisignatures without random oracles. In Vaudenay, S., ed.: EU-
ROCRYPT. Volume 4004 of Lecture Notes in Computer Science., Springer (2006)
465–485

18. Lysyanskaya, A., Micali, S., Reyzin, L., Shacham, H.: Sequential aggregate sig-
natures from trapdoor permutations. In Cachin, C., Camenisch, J., eds.: EURO-
CRYPT. Volume 3027 of Lecture Notes in Computer Science., Springer (2004)
74–90

19. Lysyanskaya, A., Rivest, R.L., Sahai, A., Wolf, S.: Pseudonym systems. In Heys,
H.M., Adams, C.M., eds.: Selected Areas in Cryptography. Volume 1758 of Lecture
Notes in Computer Science., Springer (1999) 184–199

20. Naor, M., Yung, M.: Universal one-way hash functions and their cryptographic

applications. In Johnson, D.S., ed.: STOC, ACM (1989) 33–43

21. Schr¨oder, D.: How to aggregate the cl signature scheme. In Atluri, V., D´ıaz, C.,
eds.: ESORICS. Volume 6879 of Lecture Notes in Computer Science., Springer
(2011) 298–314

22. Shoup, V.: Lower bounds for discrete logarithms and related problems. In Fumy,
W., ed.: EUROCRYPT. Volume 1233 of Lecture Notes in Computer Science.,
Springer (1997) 256–266

23. Waters, B.: Eﬃcient identity-based encryption without random oracles. In Cramer,
R., ed.: EUROCRYPT. Volume 3494 of Lecture Notes in Computer Science.,
Springer (2005) 114–127

