Automatically Detecting Error Handling Bugs 

Using Error Specifications

Suman Jana and Yuan Kang, Columbia University; Samuel Roth, Ohio Northern University; 

Baishakhi Ray, University of Virginia

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/jana

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Automatically Detecting Error Handling Bugs using Error Speciﬁcations

Suman Jana1, Yuan Kang1, Samuel Roth2, and Baishakhi Ray3

1Columbia University

2Ohio Northern University

3University of Virginia

Abstract
Incorrect error handling in security-sensitive code often
leads to severe security vulnerabilities.
Implementing
correct error handling is repetitive and tedious especially
in languages like C that do not support any exception
handling primitives. This makes it very easy for the de-
velopers to unwittingly introduce error handling bugs.
Moreover, error handling bugs are hard to detect and lo-
cate using existing bug-ﬁnding techniques because many
of these bugs do not display any obviously erroneous be-
haviors (e.g., crash and assertion failure) but cause subtle
inaccuracies.

In this paper, we design, implement, and evaluate
EPEX, a tool that uses error speciﬁcations to identify
and symbolically explore different error paths and re-
ports bugs when any errors are handled incorrectly along
these paths. The key insights behind our approach are:
(i) real-world programs often handle errors only in a lim-
ited number of ways and (ii) most functions have sim-
ple and consistent error speciﬁcations. This allows us
to create a simple oracle that can detect a large class of
error handling bugs across a wide range of programs.
We evaluated EPEX on 867,000 lines of C Code from
four different open-source SSL/TLS libraries (OpenSSL,
GnuTLS, mbedTLS, and wolfSSL) and 5 different ap-
plications that use SSL/TLS API (Apache httpd, cURL,
Wget, LYNX, and Mutt). EPEx discovered 102 new er-
ror handling bugs across these programs—at least 53 of
which lead to security ﬂaws that break the security guar-
antees of SSL/TLS. EPEX has a low false positive rate
(28 out of 130 reported bugs) as well as a low false neg-
ative rate (20 out of 960 reported correct error handling
cases).

1

Introduction

Error handling is an important aspect of software de-
velopment. Errors can occur during a program’s exe-

cution due to various reasons including network packet
loss, malformed input, memory allocation failure, etc.
Handling these errors correctly is crucial for develop-
ing secure and robust software. For example, in case
of a recoverable error, a developer must ensure that the
affected program invokes the appropriate error recov-
ery code.
In contrast, if an error is critical, the pro-
gram must display an appropriate error message and
fail in a safe and secure manner. Error handling mis-
takes not only cause incorrect results, but also often
lead to security vulnerabilities with disastrous conse-
quences (e.g., CVE-2014-0092, CVE-2015-0208,
CVE-2015-0288, CVE-2015-0285,
and CVE-
-2015-0292). More worryingly, an attacker can often
remotely exploit error handling vulnerabilities by send-
ing malformed input, triggering resource allocation fail-
ures through denial-of-service attacks etc.

the Internet,

To understand how incorrect error handling can lead
to severe security vulnerabilities in security-sensitive
code, consider the bug in GnuTLS (versions before
3.2.12), a popular Secure Sockets Layer (SSL) and
Transport Layer Security (TLS) library used for com-
municating securely over
that caused
CVE-2014-0092. Listing 1 shows the relevant part
of the affected X.509 certiﬁcate veriﬁcation code. The
function _gnutls_verify_certificate2 called
another function check_if_ca to check whether the
issuer of the input certiﬁcate is a valid Certiﬁcate Au-
thority (CA). check_if_ca returns < 0 to indicate
an error (lines 4 and 5 of Listing 1). However, as line
16 shows, _gnutls_verify_certificate2, the
caller function, only handles the case where the return
value is 0 and ignores the cases where check_if_ca
returns negative numbers as errors. This missing er-
ror check makes all applications using GnuTLS incor-
rectly classify an invalid certiﬁcate issuer as valid. This
bug completely breaks the security guarantees of all SS-
L/TLS connections setup using GnuTLS and makes them
vulnerable to man-in-the-middle attacks.
In summary,

USENIX Association  

25th USENIX Security Symposium  345

1

Listing 1:
GnuTLS error handling bug
(CVE-2014-0092). The lines marked in
color gray show an error path and
the red lines highlight the source of
error handling bug.

1
2

3

4

5

6
7
8
9
10

11
12
13
14
15

16

17
18
19
20

21
22
23

24

int check_if_ca (...)
{ ...

result = ...;
if (result < 0) {

goto cleanup;

}
...
result = 0;

cleanup:

return result;

}
int _gnutls_verify_certificate2 (...)
{ ...

if (check_if_ca (...)

== 0) {

result = 0;
goto cleanup;

}
...
result = 1;

cleanup:

return result;

this bug renders all protections provided by GnuTLS use-
less.

Developers often introduce error handling bugs unwit-
tingly, as adding error checking code is repetitive and
cumbersome (especially in languages like C that do not
provide any exception handling primitives). Moreover,
a large number of errors in real systems cannot be han-
dled correctly at their source due to data encapsulation
and, therefore, must be propagated back to the rele-
vant module. For example, if a protocol implementa-
tion receives a malformed packet that cannot be parsed
correctly, the parsing error must be appropriately trans-
formed and propagated to the module implementing the
protocol state machine in order to ignore the packet and
recover gracefully.
Implementing correct error propa-
gation in real-world software is non-trivial due to their
complex and intertwined code structure.

Automated detection of error handling bugs can help
developers signiﬁcantly improve the security and robust-
ness of critical software. However, there are three major
challenges that must be tackled in order to build such a
tool: (i) error path exploration. Error handling code
is only triggered in corner cases that rarely occur dur-
ing regular execution. This severely limits the ability of
dynamic analysis/testing to explore error paths. More-
over, error handling code is usually buried deep inside
a program and, therefore, is hard to reach using off-the-
shelf symbolic execution tools due to path explosion; (ii)
lack of an error oracle. Error handling bugs often result

in silent incorrect behavior like producing wrong output,
causing memory corruption, etc. as shown in the previ-
ous example. Therefore, accurately separating incorrect
error handling behavior from the correct ones is a hard
problem; and (iii) localizing error handling bugs. Fi-
nally, the effects of error handling bugs are usually man-
ifested far away from their actual sources. Accurately
identifying the origin of these bugs is another signiﬁcant
problem.
Our contributions. In this paper, we address all these
three problems as discussed below. We design, imple-
ment, and evaluate EPEX, a novel algorithm that can
automatically detect error-handling bugs in sequential C
code.
Identiﬁcation and scalable exploration of error paths.
As low-level languages like C do not provide any excep-
tion handling primitives, the developers are free to use
any arbitrary mechanism of their choice for communi-
cating errors. However, we observe that real-world C
programs follow simple error protocols for conveying
error information across different modules. For exam-
ple, distinct and non-overlapping integer values are used
throughout a C program to indicate erroneous or error-
free execution. Integer values like 0 or 1 are often used to
communicate error-free execution and negative integers
typically indicate errors. Moreover, functions that have
related functionality tend to return similar error values.
For example, most big number functions in OpenSSL re-
turn 0 on error. These observations allow us to create
simple error speciﬁcations for a given C program, in-
dicating the range of values that a function can return
on error. Given such speciﬁcations as input, our algo-
rithm performs under-constrained symbolic execution at
the corresponding call-sites to symbolically explore only
those paths that can return error values and ignores the
rest of the paths. Such path ﬁltering minimizes the path
exploration problem often plaguing off-the-shelf sym-
bolic execution tools.
Design of an error oracle. We observe that when an er-
ror occurs, most C programs usually handle the scenario
in one of the following simple ways: (i) propagate an
appropriate error value (according to the corresponding
error protocol) upstream, (ii) stop the program execution
and exit with an error code, or (iii) display/log a rele-
vant error message. We leverage this behavior to create a
simple program-independent error oracle. In particular,
our algorithm checks whether errors are handled follow-
ing any of the above three methods along each identiﬁed
error path; if not, we mark it as a potential bug.
Accurate bug localization. Our error oracle also helps
us accurately localize the error handling bugs as it al-
lows our algorithm to detect the bugs at their source. As
a side-effect, we can precisely identify buggy error han-
dling code and thus drastically cut down developers’ ef-

346  25th USENIX Security Symposium 

USENIX Association

2

fort in ﬁxing these bugs.
Implementation and large-scale evaluation. Using our
algorithm, we design and implement a tool, EPEX, and
evaluate it. EPEX’s analysis is highly parallelizable and
scales well in practice. EPEX can be used to ﬁnd error-
handling bugs in any C program as long as the above
mentioned assumptions hold true. We evaluated EPEX
on a total of 867,000 lines of C code [56] from 4 differ-
ent open-source SSL/TLS libraries (OpenSSL, GnuTLS,
mbedTLS, and wolfSSL) and 5 different applications us-
ing SSL/TLS APIs (cURL, Wget, Apache httpd, mutt,
and LYNX). EPEX discovered 102 new error handling
bugs across these programs—at least 53 of which lead
to critical security vulnerabilities that break the security
guarantees of SSL/TLS. We also found that EPEX has
both low false positive (28 out of 130 reported bugs)
and false negative rates (20 out of 960 reported correct
error handling cases). Thus, EPEX has a 78% preci-
sion and 83% recall on our tested programs. Several of
our tested programs (e.g., PolarSSL, cURL, and Apache
httpd) have been regularly checked with state-of-the-art
static analysis tools like Coverity, Fortify, etc. The fact
that none of these bugs were detected by these tools also
demonstrates that EPEX can detect bugs that the state-
of-the-art bug ﬁnding tools miss.

The rest of this paper is organized as follows. We
present a brief overview of error handling conventions
in C programs in Section 2. We describe our platform-
and language-independent technique for detecting error
handling bugs in Section 3. The details of implement-
ing our algorithm in Clang and the results are presented
in Sections 4 and 5 respectively. We survey the related
work in Section 6 and present several directions for fu-
ture work in Section 7. Section 8 concludes our paper.

2 Error handling in C programs

C does not support exception handling primitives like
try-catch. In C, a fallible function, which may fail
due to different errors, e.g., memory allocation failure or
network error, usually communicates errors to the caller
function either through return values or by modifying ar-
guments that are passed by reference. While there are no
restrictions on the data types/values that can be used to
communicate errors, C programmers, in general, create
an informal, program-speciﬁc error protocol and follow
it in all fallible functions of a program to communicate
errors. An error protocol consists of a range of error-
indicating and non-error-indicating values for different
data types. For example, a program may use an error pro-
tocol where any negative integer value indicates an error
and 0 indicates an error-free execution. Similarly, an er-
ror protocol may also use a NULL pointer or a boolean
value of false to indicate errors. The existence of such

Libraries

Applications

OpenSSL
GnuTLS
mbedTLS
wolfSSL

httpd [51]
curl
lynx
mutt
wget

−403 ≤ e ≤ −1
−213 ≤ e ≤ −1
1 ≤ e ≤ 720000
−29999 ≤ e ≤ −1

1 ≤ e ≤ 91
e = −1
e = −1

Error
Range
e ≤ 0
e < 0

Non-Error

Range

e = 1
e = 0
e = 0
e ∈ {0,1}
e = 0
e = 0
e ≥ 0
e ≥ 0
e = 0

e represents the return values of fallible functions

Table 1: Error protocols of the tested libraries/applications

error handling protocols makes it easier for us to create
error speciﬁcations for different functions of a program.
For example, consider the C programs that we studied
in this work. Table 1 shows their error protocols. Fal-
lible functions in OpenSSL usually return 0 or a nega-
tive integer to indicate errors and 1 to indicate error-free
execution. In contrast, GnuTLS uses negative integers
between -1 and -403 to indicate errors and 0 to indicate
error-free execution. In spite of the variety of protocols,
in all the cases, error-indicating and non-error-indicating
ranges for fallible functions do not overlap, to avoid am-
biguities.

3 Methodology

In this section, we introduce the details of EPEX (Error
Path Explorer), a tool for automatically detecting dif-
ferent types of error handling bugs in sequential C pro-
grams. Our key intuition is that if an error is returned
by a function in a program path, that error must be han-
dled correctly along that path according to the program’s
error convention. Given a function under test, say FT,
EPEX identiﬁes possible error paths—the paths along
which FT returns error values, and ensures that the er-
ror values are handled correctly along the error paths at
the call site; if not, EPEX reports bugs due to missing
error-handling.

3.1 Overview
An overview of EPEX’s workﬂow for an individual API
function is presented in Figure 1. EPEX takes ﬁve inputs:
the signature of the fallible function under test (FT), the
caller functions of FT (FTcallers), a speciﬁcation deﬁning
a range of error values that FT can return (FTerrSpec), a
range of return values that are used to indicate error-free
execution according to the test program’s error protocol
(GlobalnerrSpec), and a set of error logging functions used
by the program (Loggers). The list of fallible functions,

USENIX Association  

25th USENIX Security Symposium  347

3

GlobalnerrSpec 

Loggers 

FT 
FTcallers  
FTerrSpec  

(1)		

Iden)fying	
error	paths	

error 
paths 

Checking	error	
handling	at	call	

(2)		

site	

paths with  
incorrect 

error 

handling 

(3)		

Improving	precision	by			

leveraging	mul)ple	

error-handling	instances		

error handling  

bugs 

Figure 1: EPEX workﬂow

6
7
8
9
10
11
12
13
14
15
16

17
18
19
20
21
22
23

24

25
26
27

their error speciﬁcations, and list of error logging func-
tions are created manually, while their caller functions
are automatically identiﬁed by EPEX. EPEX then works
in three steps.

For example,

In Step-I, by performing under-constrained sym-
bolic execution at FTcallers, EPEX identiﬁes the er-
ror paths along which FT returns an error value,
based on FTerrSpec.
in Listing 1,
check_if_ca’s error speciﬁcation says the function
will return ≤ 0 on error. Hence, Step-I symbolically
executes _gnutls_verify_certificate2 func-
tion and marks the path along the if branch in the
check_if_ca function as an error path (marked in
color gray ).

Next, in Step-II, EPEX checks if the call site of FT
handles the error values correctly. In particular, EPEX
checks that if FT returns an error, the error value is han-
dled by the caller in one of the following ways:
it (i)
pushed the error upstream by returning a correct error
value from the caller function, (ii) stopped the program
execution with a non-zero error code, or (iii) logged the
error by calling a program-speciﬁc logging function. If
none of these actions take place in an error path, EPEX
reports an error handling bug. For instance, in case
of Listing 1, the error path returns < 0 at the call site,
_gnutls_verify_certificate2 (line 16). How-
ever, the error value is not handled at the call site; in fact
it is reset to 1 (line 21), which is a non-error value as per
GlobalnerrSpec. Thus, in this case, an error path will re-
turn a non-error value. EPEX reports such cases as the
potential error-handling bugs (marked in red).

Finally, in Step-III, EPEX checks how error handling
code is implemented in other call sites of FT. For ex-
ample, if all other FT call sites ignore an error value,
EPEX does not report a bug even if the error value is not
handled properly at the call site under investigation. As
FTerrSpec may be buggy or symbolic execution engines
may be imprecise, this step helps EPEX reduce false pos-
itives. The ﬁnal output of EPEX is a set of program error
paths—FT signature, call-site location, and error paths in
the caller functions along with EPEX’s diagnosis of cor-
rect and buggy error handling. We present the detailed
algorithm in the rest of this section.

Input

Algorithm 1: EPEX workﬂow
1 EPEX (FT, FTerrSpec, FTcallers, GlobalnerrSpec, Loggers)
: function FT, error spec FTerrSpec, callers of FT
FTcallers, global non-error spec GlobalnerrSpec,
error logging functions Loggers

Output: Bugs
2 ———————————————————————
3 Bugs ⇐ φ
4 shouldHandle ⇐ False
5 for each caller c ∈ FTcallers do
a.isSymbolic ⇐ True

for each argument a ∈ c.inputArguments do
end
for each path p ∈ c.Paths do

isErrPath ⇐ False
errPts ⇐ φ
for each program point s ∈ p do

/* Step-I : identifying error paths */
if s calls FT then

FTret ⇐ symbolic return value of FT
isErrPath ⇐ chkIfErrPath(FTret,
FTerrSpec)
if isErrPath = True then

errPts ⇐ errPts ∪ s.location

end

end
if isErrPath = True then

/* Step-II : checking error Handling */
isHandled ⇐ chkErrHandling(s,
GlobalnerrSpec, Loggers)
if (isHandled = unhandled) or
(isHandled = maybe_handled) then

Bugs ⇐ Bugs ∪ (cid:27)errPts, isHandled(cid:26)
end
if (isHandled = handled) or (isHandled =
maybe_handled) then
/* Resetting an error path */
isErrPath ⇐ False
errPts ⇐ φ

end
/* Example requires error handling */
if (isHandled = handled) then

28
29
30
31
32
33
34
35
36
37
38
39 end
40 /* Step-III : Leveraging multiple error-handling

shouldHandle ⇐ True

end

end

end

end

instances */

return Bugs

41 if shouldHandle then
42
43 else
44
45 end

return φ

348  25th USENIX Security Symposium 

USENIX Association

4

3.2 Step-I: identifying error paths
We deﬁne error paths to be the program paths in which
a function call fails and returns error values. To identify
the error paths for a function, EPEX ﬁrst has to know the
error values that a function can return; EPEX takes such
information as input (see Section 2 for details). Then the
program paths along which the function returns the error
values are identiﬁed as error paths. The call sites of the
failed function are treated as error points (errPts in Al-
gorithm 1). For example, in Listing 1, the program path
containing an if-branch (highlighted gray ) is an error
path; line 16 of _gnutls_verify_certificate2
is an error point along that error path. Note that an error
path can have one or more error points. Given a function
under test, say FT, and its caller functions FTcaller, the
goal of Step-I is to explore all possible error paths going
through FT and mark the corresponding error points.

Algorithm 2: Step-I: Identifying error paths
1 chkIfErrPath (FTret, FTerrSpec)

: FTret, FTerrSpec
Input
Output: isErrPath, FTret
2 ———————————————————————
3 if FTret ∧ FTerrSpec is satisﬁable then

/* Error path is possible */
if FTret ∧ ¬FT errSpec is satisﬁable then
/* Force the error path, if needed */
FTret ⇐ FTret ∧ FTerrSpec

return True

/* Error path is impossible */
return False

4
5
6
7
8
9 else
10
11
12 end

Exploring error paths.
First, EPEX performs under-
constrained symbolic execution at each caller function
in FTcallers, and monitors each method call to check if
FT is called. If EPEX ﬁnds such a call, then right after
returning from symbolically executing FT, EPEX checks
if the path conditions involving the symbolic return value
(FTret) satisfy its error speciﬁcations (FTerrSpec), as men-
tioned in the input spec (see Algorithm 2), i.e. if FTret ∧
FTerrSpec is satisﬁable. This helps EPEX identify two
main cases:

• Error path possible. If FTret ∧ FTerrSpec is satisﬁ-
able, the error path is possible. But while continu-
ing to analyze the error path, EPEX must make sure
the constraints make the error path inevitable, so it
checks if FTret ∧ ¬FT errSpec is satisﬁable, and if
so, sets FTret to FTret ∧ FTerrSpec, so that the con-
straints force the error path to be taken.

• Error path impossible. When FTret ∧ FTerrSpec is
unsatisﬁable, EPEX considers it as not an error path

and stops tracking it any further.

Algorithm 2 illustrates this process. If a path is con-
sidered to be an error path, EPEX notes the correspond-
ing call-site locations in the source code as error points
and continues tracking the path in Step-II. In Listing 1,
the buggy path has check_if_ca return a negative
value, which means that it is certainly an error path, and
the algorithm returns True, without having to further re-
strict the constraints.

3.3 Step-II: checking error handling
If a path is marked as an error path in Step-I (isErrPath=
=True in Algorithm 1), this step checks whether the er-
ror is handled properly along the error path in the caller
function. As the symbolic execution engine explores dif-
ferent error paths, we propagate the error path state (e.g.,
isErrPath, FT, and errPts) to any new path forked from
conditional branches. We let the rest of the symbolic exe-
cution proceed normally unless one of the following hap-
pens (see Algorithm 3):
At return point. If EPEX encounters a return statement
along an error path, it checks whether the error value is
pushed upstream. To do that, Step-II takes program-wide
speciﬁcations for non-error values (GlobalnerrSpec) as in-
put and checks the constraints on the returned variable
of FTcaller against GlobalnerrSpec to determine whether
FTcaller is returning an error value along the error path. If
the returned variable can only contain a non-error value,
EPEX marks the corresponding path to be unhandled; if
it may have a non-error value or an error value, EPEX
marks it as maybe_handled; and if it cannot have any
non-error values, EPEX marks the path as handled.

Although both maybe_handled and unhandled indi-
cate potential bugs, we differentiate between them be-
cause in Line 27 of Algorithm 1, we no longer count the
path as an error path in the case of maybe_handled, since
we have already found where the error could be handled;
the same error value does not have to be checked repeat-
edly.
At exit point. A call to libc function exit (or other re-
lated function like _exit) ends the execution of a path.
In such a case, EPEX checks the constraints on the sym-
bolic argument to the exit function along an error path: if
the symbolic argument can have only error or non-error
indicating value, EPEX marks the path as handled or
unhandled respectively. If the argument may have both
error and non-error indicating values, EPEX marks the
path as maybe_handled.
At logging point.
The global speciﬁcations also sup-
port providing the names of the program-speciﬁc error
logging functions (Loggers). In most C programs, errors
are logged through special logging or alerting functions.

USENIX Association  

25th USENIX Security Symposium  349

5

If an error path calls an error logging function, EPEX
marks that path as handled.

In Listing 1, _gnutls_verify_certificate2
sets result to the non-error value, 1, in the error path
before returning it, so the algorithm classiﬁes the error as
unhandled.

report any bugs. With manual analysis we conﬁrmed
that as trusted certiﬁcate authorities can be loaded from
multiple sources, such errors can indeed be ignored
safely.

4

Implementation

Algorithm 3: Step-II: Checking error handling
1 chkErrHandling (s, GlobalnerrSpec, Loggers)

Input

: program point s, global non-error spec
GlobalnerrSpec, error logging functions Loggers

Output: isHandled

2 ——————————————————————–
3 if (s is a top-level ret statement) or (s is a call to “exit”)

then

4
5

6
7

8
9

10

return unhandled

tval ← symbolic return value/exit argument
if (tval ∧ GlobalnerrSpec is satisﬁable) and (tval ∧ ¬
GlobalnerrSpec is unsatisﬁable) then
else if (tval ∧ GlobalnerrSpec is unsatisﬁable) and
(tval ∧ ¬Global nerrSpec is satisﬁable) then
else if (tval ∧ GlobalnerrSpec is satisﬁable) and (tval
∧ ¬Global nerrSpec is satisﬁable) then

return handled

return maybe_handled

11 else if s ∈ Loggers then
return handled
12
13 return not_checked

3.4 Step-III:

leveraging multiple error-

handling instances

As program documentation may be buggy or symbolic
execution engines may be imprecise, EPEX compares
the analysis results across multiple callers of the function
under test (FT) to minimize false positives. Lines 34−45
in Algorithm 1 present this step. If EPEX ﬁnds that all
the callers of FT return unhandled or maybe_handled,
EPEX ignores the corresponding bugs and does not re-
port them. However, if at least one caller sets isHandled
to handled, all the buggy paths marked from Step-II (line
25 in Algorithm 1) will be reported as bugs. The underly-
ing idea behind this step is inspired by the seminal work
of Engler et al. [16] where deviant behaviors were shown
to indicate bugs.

each

adds

trusted CAs.

returns the number of added CAs.

For example, function gnutls_x509_trust_li-
Certiﬁcate
st_add_trust_file
Authority (CA) mentioned in the input ﬁle to the
list of
In an error-free execution,
it
returns
a negative number
in case of a parsing error.
However,
the 5 instances in GnuTLS where
gnutls_x509_trust_list_add_trust_file
is called, step II indicates that error values are not
handled correctly. In such cases, Step III assumes that
the error values can be safely ignored and does not

in all

It

EPEX is implemented using the Clang static analysis
framework [42] (part of the LLVM project) and its un-
derlying symbolic execution engine. The Clang analyzer
core symbolically explores all feasible paths along the
control ﬂow graph of an input program and provides a
platform for custom, third-party checkers to monitor dif-
ferent paths, inspect the constraints of different symbolic
values along those paths, and add additional constraints
if necessary. A typical checker often looks for viola-
tions of different invariants along a path (e.g., division
by zero). In case of a violation, the checker reports bugs.
We implement EPEX as a checker inside the Clang an-
alyzer. The rest of this section describes how EPEX is
implemented as a Clang checker in detail.

speciﬁcation (GlobalnerrSpec),

Error speciﬁcations. EPEX takes a text ﬁle con-
taining the per-function error speciﬁcations (FTerrSpec),
and
global non-error
global error speciﬁcation (GlobalerrSpec) as input. List-
ing 2 shows a sample input ﬁle. FTerrSpec contains ﬁve
parameters: (cid:26)function name, number of arguments, re-
turn type, lower bound of error value, upper bound of
error value(cid:25). The ﬁrst three parameters deﬁne a func-
tion signature. The number of arguments and return type
(e.g., integer, boolean, etc.) help to disambiguate func-
tions with identical names. The last two optional param-
eters represent a range of error values that the function
can return. For example, error speciﬁcation for function
RAND_bytes is: (cid:26) RAND_bytes, 2, int, >= −1,<= 0(cid:25)
(see line 2 in Listing 2). This shows RAND_bytes takes 2
input arguments and returns an integer value. The fourth
and ﬁfth parameters indicate that error values range from
−1 to 0. Similarly, if a function foo takes four argu-
ments and it has a boolean return type where False
indicates an error, its error spec will be (cid:26) foo, 4, bool,
=False (cid:25). We also support speciﬁcations for functions
returning NULL pointers to indicate errors.
Since most functions in a project follow the same
global error convention, (e.g., most OpenSSL func-
tions return 0 to indicate error), error speciﬁcations
can be simpliﬁed by providing a global
lower and
upper bound of errors.
the per-function error
spec does not contain any error range, i.e. the fourth
and ﬁfth parameters are empty,
the checker uses
GlobalerrSpec. Otherwise, the function-speciﬁc bounds
override GlobalerrSpec. For instance, OpenSSL func-
tions RAND_bytes and RAND_pseudo_bytes spec-
ify custom lower and upper bounds −1 <= and <=

If

350  25th USENIX Security Symposium 

USENIX Association

6

Listing 2:
for OpenSSL functions

Sample error specifications

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

/* Per-func error spec */
RAND_bytes, 2, int, >=-1, <=0
RAND_pseudo_bytes, 2, int, >=-1, <=0
/* Per-func spec with empty error ranges
(global error ranges will be used)*/
ASN1_INTEGER_set_int64, 2, int
ASN1_INTEGER_set, 1, int
/* Global error spec */
__GLOBAL_ERROR_BOUND__, int, =0, NA
/* Global non-error spec */
__GLOBAL_NOERR_VAL__, int, =1
__GLOBAL_NOERR_VAL__,

ptr, !=NULL

0 respectively, and hence global error bounds are not
valid for them. Finally, GlobalnerrSpec contains non-
error bounds/values for functions with different return
types (see lines 14 and 15 of Listing 2).
For ex-
ample, (cid:31) __GLOBAL_NOERR_VAL__, int, = 1(cid:30) in-
dicates that any function with integer return type re-
turns 1 to indicate an error-free execution. Similarly,
(cid:31)__GLOBAL_NOERR_VAL__, ptr, ! =NULL(cid:30) indi-
cates an error-free execution for the functions returning
pointers will result in the return pointer to be non-null.
Such GlobalnerrSpec speciﬁcations are used to ensure that
the return value of the caller function of FT is pushing
the errors upstream correctly.

The error speciﬁcations for all the functions under test
were created manually. Since, a majority of these func-
tions either follow the per-project global error conven-
tion or, at least, functions inside same modules have the
same error ranges, e.g., all the big number routines in
OpenSSL return 0 on error, the overhead of manual spec
generation is not very signiﬁcant. In fact, it took only one
man-day to generate error specs for all 256 functions that
we have examined. Table 2 shows the number of speci-
ﬁed functions for each library, and the number of unique
speciﬁcations. Except for WolfSSL, where we used more
individualized speciﬁcations, each library contained no
more than 10 unique error speciﬁcations, so that we were
able to generate 256 speciﬁcations out of only 38 unique
constraints.

Table 2: Error speciﬁcation counts

Library
OpenSSL
GnuTLS
mbedTLS
wolfSSL

Total

Functions

Unique Speciﬁcations

109
58
46
43

256

9
3
10
16

38

As the same set of library functions are used by mul-
tiple applications, the same error speciﬁcations can be
reused for all such applications.
In fact, for our test

applications, we focused on only OpenSSL API func-
tions. We also found that fallible functions that return
booleans or pointers, irrespective of the library they be-
long to, mostly indicate errors by returning false and
NULL respectively. For functions returning integer error
codes, we found that the error codes were almost always
represented by a macro or enumerated type that is de-
ﬁned in a header ﬁle and therefore was very easy to ﬁnd.
Functions that use the same enumerated type/macro tend
to follow the same error protocol. We show some sample
error speciﬁcations for OpenSSL API functions in List-
ing 2.

Note that once the error speciﬁcations for a set of API
functions are created manually, testing new applications
using the same API is very easy; the user only needs to
add application-speciﬁc non-error values (i.e. the values
indicating error-free execution) for each new application.
Identifying error paths. For identifying error paths,
as mentioned in Step-I of Section 3, EPEX checker
uses the built-in callback method checkPostCall.
checkPostCall is called once the analyzer core
ﬁnishes tracking each function body. We overrode
checkPostCall so that it looks for the functions
mentioned in the error spec, i.e. checks whether the cur-
rent function’s name, number of arguments, and return
type match the speciﬁcation. In case of a match, Algo-
rithm 2 is called to check whether the function’s return
value satisﬁes the lower and upper bounds of error values
as given in its error spec; if so, the current path is marked
as error path.

Checking error handling. We implemented Step-II
by extending the checkPreStmt callback method for
checking the program state before return statements
and the checkPreCall callback for checking the pro-
gram state before calling exit functions or any program-
speciﬁc error logging functions as speciﬁed in the input
spec. Inside checkPreStmt callback, EPEX checks
whether the symbolic return value satisﬁes the global
non-error spec (see Algorithm 3). A similar check is
performed for exit functions inside checkPreCall.

To check the satisﬁability conditions of Algorithm 2
and Algorithm 3, we use Clang’s built-in constraint
solver.

running it on large projects

Outputs. EPEX can be run on any single source
ﬁle (say,
foo.c) using the command clang -cc1
-analyze -analyzer-checker=EPEx foo.c.
For
like OpenSSL,
mbedTLS, etc. we used Clang’s scan-build utility
such that EPEX can be run as part of the regular build
process.
Scan-build overrides different environment
variables (e.g., CC, CPP) to force the build system (e.g.,
make) to use a special compiler script that compiles
the input source ﬁle and invokes EPEX on it. We pass
the -analyze-header option to the clang analyzer

USENIX Association  

25th USENIX Security Symposium  351

7

core to ensure that the functions deﬁned in any included
header ﬁles are also analyzed.

The output of EPEX contains one line for each ana-
lyzed error path, as shown in Table 3. Each line in the
output has four components: name of the caller function,
call-site of FT, candidate error-handling location (i.e. re-
turn instruction, exit call or error logging), and EPEX’s
diagnosis about whether the error has been handled cor-
rectly or not. As each output line represents an error
path and multiple error paths may pass through the same
call-site, a call-site for a given FT might be repeated in
the output. For example, lines 1 and 2 in Table 3 have
the same call-site (ssl_lib.c:1836) but their error handling
locations are different (ssl_lib.c:1899 and ssl_lib.c:1905
respectively). Note that we implement Step-III as a sep-
arate script and execute it on the output of EPEX before
producing the ﬁnal bug report.

Table 3: Sample EPEx output for OpenSSL function under test:
RAND_pseudo_bytes.

Call-site
ssl_lib.c:1836
ssl_lib.c:1836
d1_srvr.c:1683

Error Handling
Location
ssl_lib.c:1899
ssl_lib.c:1905
d1_srvr.c:1736

Diagnosis
handled
unhandled
maybe_handled

Caller
Function
SSL_CTX_new
SSL_CTX_new
dtls1_send_ne-
wsession_ticket

5 Results

5.1 Study subjects
To check whether errors are handled correctly in differ-
ent functions of popular SSL/TLS libraries as well as ap-
plications using them, we ran EPEX on four libraries:
OpenSSL, GnuTLS, mbedTLS (formerly known as Po-
larSSL), and wolfSSL (formerly known as cyaSSL), and
ﬁve applications that use OpenSSL: cURL, mod_ssl
of the Apache HTTP server, Lynx, Mutt, and Wget (see
Table 4). For the libraries, we primarily focused on the
source ﬁles implementing core functionality (e.g., src, lib
sub-directories, etc.) as opposed to the test ﬁles, as de-
tecting bugs in the test code may not be a high prior-
ity. All the applications but the HTTP server were small
enough to run EPEX on the entire program, although it
eventually only produced results for the source ﬁles that
used the OpenSSL library. For Httpd we only checked
mod_ssl. The second column of Table 4 shows the
modules investigated by EPEX for each tested library.

For each library, we generate a call graph using a tool
named GNU cflow 1. From the call graph, we choose
top functions that are frequently called by other func-
tions within the same library. Note that here we did
not distinguish between internal library functions and

1http://www.gnu.org/software/cﬂow/

library functions exposed to the outer world as APIs.
We further ﬁltered out functions based on their return
types—functions returning integer, boolean, and pointers
are chosen because Clang’s symbolic analysis engine can
currently only handle these types. In addition, we only
selected those functions that can fail and return at least
one error value. For the applications, we tested all the
OpenSSL APIs that the applications are using. We found
such APIs by simply using grep. Further, we only chose
those APIs for which documentations are available, and
the APIs that could return errors as integers, booleans or
pointers. The third column of Table 4 shows the number
of functions tested for a studied program.

Table 4: Study subjects

Projects

Modules

OpenSSL v1.0.1p
GnuTLS v3.3.17.1
mbedTLS v1.3.11
wolfSSL v3.6.0
curl v7.47.0
httpd v2.4.18
lynx v2.8.8
mutt v1.4.2.3
wget v1.17.1
Total

ssl, crypto
src, lib
library
wolfcrypt, src
all
mod_ssl
all
all
all

#Functions
tested
46
50
37
20
17
14
3
3
5

195

#Call
sites
507
877
505
138
49
86
23
9
13

2207

#Error
paths
3171
3507
1621
418
2012
4368
494
5
2409

18005

5.2 General ﬁndings

We evaluated EPEX on 195 unique program-API func-
tion pairs from 2207 call-sites, and covered 18005 er-
ror paths (see Table 4). EPEX found 102 new error-
handling bugs from 4 SSL/TLS libraries and 5 applica-
tions: 48 bugs in OpenSSL, 23 bugs in GnuTLS, 19 bugs
in mbedTLS, and 0 bugs in wolfSSL, 2 in cURL, 7 in
httpd, 1 in Lynx, 2 in Mutt, and 0 in Wget (see Table 5).
We evaluate EPEX’s performance after completion of
Step-II and Step-III separately. Since we are using re-
cent versions of real code, and ﬁnding all potential bugs
in such code is an extremely difﬁcult problem, we do not
have a ground truth for bugs against which to compare
the reports. Also, EPEX is not designed to detect all
types of error handling bugs. For this paper, we deﬁne a
bug to be any error path whose output behavior is identi-
cal to that of a non-error path, e.g., no logging takes place
and the same values as in the non-error paths are propa-
gated upwards through all channels. Thus, for counting
false positives and negatives, we do not consider bugs
due to incomplete handling, for example, where failures
are only logged, but the required cleanup is missing. Ta-
ble 5 presents the detailed result. After Step-II, EPEX
reported 154 bugs in the library code and 29 bugs in the
application code. After a manual investigation, we found
61 of them to be false positives. Step-III reduced this
false positive to 28 out of 130 reported bugs (106 in li-
brary and 24 in application code). Thus, overall, EPEX

352  25th USENIX Security Symposium 

USENIX Association

8

detected bugs with 84% precision in the library code and
50% precision in the application code with an overall
precision of 78%.

In general, measuring false negatives for static analy-
sis tools is non-trivial as it is hard to be conﬁdent about
the number of bugs present in the code at any given point
of time. However, for the sake of completeness, we
checked false negatives by randomly selecting 100 cases
at the end of Step-II, where EPEX conﬁrmed that error
handling was indeed implemented correctly. We did not
ﬁnd any false negatives in any of those examples, i.e. we
did not ﬁnd any bugs that were ﬁltered out at Step-II.
However, after Step-III’s optimization, among the bugs
that did pass Step-II, we found 15 and 5 false negatives
in Library and Application code respectively. Thus, the
overall recall of EPEX was approximately 83%.

Table 5: Evaluation of EPEX

Step II

Step III

Summary

Reported
Bugs

False
+ve

Reported
Bugs

False
+ve

True
Bugs

Prec-
ision

51
41
35
27
154

6
13
5
3
2
29

183

2
15
16
7
40

2
6
2
1
1
12

52

50
25
21
10
106

4
13
3
3
1
24

130

2
1
2
2
16

2
6
2
1
1
12

28

48
23
19
0
90

2
7
1
2
0
12

102

0.96
0.96
0.90
0.80
0.84

0.5
0.53
0.33
0.67
0.00
0.50

0.78

Library
OpenSSL
GnuTLS
mbedTLS
WolfSSL
Total
Application
Curl
Httpd
Lynx
Mutt
Wget
Total

Grand Total

In general, EPEX performs better for libraries than ap-
plications. There are three main reasons behind this: (i)
unlike libraries, applications’ error handling behavior is
heavily dependent on their conﬁguration parameters. For
example, users can conﬁgure the applications to ignore
certain errors. EPEX currently cannot differentiate be-
tween paths that have different values for these conﬁgu-
ration parameters; (ii) Applications are more likely to use
complex data types (e.g., error code is embedded within
an object) for propagating errors than libraries that are
not currently supported by EPEX; and (iii) Applications
prioritize user experience over internal consistency, so
if the error is recoverable, they will attempt to use a fall-
back non-error value instead. However, none of these are
fundamental limitations of our approach. EPEX can be
enhanced to support such cases and improve its accuracy
for applications too.

In the following section, we discuss the nature of the
detected bugs and the vulnerabilities caused by them in
detail with code examples from libraries in Section 5.3
and from applications in Section 5.4. All the described

bugs have been reported to the developers, who, for
almost all cases, have conﬁrmed and agreed that they
should be ﬁxed.

5.3 Bugs in libraries
From the four SSL/TLS libraries that we tested, we de-
scribe seven selected examples. They arise due to various
reasons including ignoring error codes, missing checks
for certain error codes, checking with a wrong value,
and propagating incorrect error values upstream. These
bugs affect different modules of the SSL/TLS implemen-
tations, and at least 42 of them result in critical security
vulnerabilities by completely breaking the security guar-
antees of SSL/TLS, as discussed below.
Incorrect random number generation.
EPEX found
21 instances in OpenSSL where callers of the func-
tion RAND_pseudo_bytes do not implement the er-
ror handling correctly. We provide two such exam-
ples below.
RAND_pseudo_bytes returns cryp-
tographically secure pseudo-random bytes of the de-
sired length. An error-free execution of this func-
tion is extremely important to OpenSSL as the secu-
rity guarantees of all cryptographic primitives imple-
mented in OpenSSL depend on the unpredictability of
the random numbers that RAND_pseudo_bytes re-
turns. The cryptographically secure random numbers,
as returned by RAND_pseudo_bytes, are used for
diverse purposes by different pieces of OpenSSL code,
e.g., creating initialization vectors (IVs), non-repeatable
nonces, cryptographic keys.
In case of a failure,
RAND_pseudo_bytes returns 0 or −1 to indicate any
error that makes the generated random numbers insecure
and unsuitable for cryptographic purposes.

Example 1.

1
2
3
4
5
6

int PEM_ASN1_write_bio(...)
{

int ret = 0;
...
/* Generate a salt */
if (RAND_pseudo_bytes(iv, enc->iv_len) <

0)

goto err;

...
ret = 1;

err:

7
8
9
10
11
12
13
14
Example 2.

}

OPENSSL_cleanse(iv, sizeof(iv));
...
return ret;

int bnrand(...)
{

goto err;

int ret = 0;
...
if (RAND_pseudo_bytes(buf, bytes) == -1)
...
ret = 1;
...
return ret;

err:

}

1
2
3
4
5
6
7
8
9
10
11
12

9

USENIX Association  

25th USENIX Security Symposium  353

two examples of

The above code shows

error handling at different

in-
call-sites of
correct
In Ex-
RAND_pseudo_bytes in OpenSSL code.
ample 1, function PEM_ASN1_write_bio checks
In Example 2, function
only if < 0, but not if = 0.
bnrand only checks for the −1 value but not for the
0 value. bnrand is used by all bignumber routines,
which are in turn used for key generation by many
cryptographic implementations like RSA. These bugs
completely break the security guarantees of any crypto-
graphic implementations (RSA, AES, etc.) and security
protocol
implementations (e.g., SSL/TLS, SMIME,
etc.) in OpenSSL that use such buggy code for random
number generation. An attacker can leverage these
bugs to launch man-in-the-middle attacks on SSL/TLS
connections setup using OpenSSL.

The sources of errors in random number generation
functions are diverse and depend on the underlying ran-
dom number generation mechanism (see Listing 3 in the
Appendix for a sample random number generation im-
plementation in OpenSSL). For example, an error can
occur due to memory allocation failures or module load-
ing errors. Note that some of these failures can be trig-
gered remotely by an attacker through denial-of-service
attacks. Thus, if the errors are not handled correctly, an
attacker can break the security guarantees of different
cryptographic primitives by making them use insecure
random numbers. We have received conﬁrmation from
OpenSSL developers about these issues.
Incorrect cryptography implementations. Here, we ex-
hibit an example from OpenSSL demonstrating an error
handling bug that EPEX found in the implementation of
a cryptographic algorithm.

Insecure SRP keys. EPEX found that the function
SRP_Calc_server_key, which is part of the SRP
(Secure Remote Password) module in OpenSSL, con-
tains an error handling bug while calling BN_mod_exp,
as shown in the code below.

BIGNUM *SRP_Calc_server_key(BIGNUM *A,

BIGNUM *v,
BIGNUM *u, BIGNUM *b, BIGNUM *N)

{

BIGNUM *tmp = NULL, *S = NULL;
BN_CTX *bn_ctx;
...
if ((bn_ctx = BN_CTX_new()) == NULL ||

(tmp = BN_new()) == NULL ||
(S = BN_new()) == NULL)

goto err;

if (!BN_mod_exp(tmp, v, u, N, bn_ctx))

goto err;
...

err:

BN_CTX_free(bn_ctx);
BN_clear_free(tmp);
return S;

1

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

}
The BN_mod_exp function takes four big numbers
(arbitrary-precision integers) tmp, v, u, N, and a context

It then computes v raised to the uth
bn_ctx as input.
power modulo N and stores it in tmp (i.e. tmp = vu%N).
However, BN_mod_exp can fail for different reasons
including memory allocation failures.
It returns 0 to
indicate any such error. The call-site of BN_mod_exp
(line 12), in fact, correctly checks for such an error and
jumps to the error handling code at line 15. The error
handling code frees the resources and returns S (line 18).
However, S is guaranteed to be not NULL at this point
as it has been allocated by calling a BN_new function
at line 9. This leads SRP_Calc_server_key to
return an uninitialized big number S. Thus, the func-
tions upstream will not know about the error returned
by BN_mod_exp, as SRP_Calc_server_key is
supposed to return a NULL pointer in case of an error.
This leads to silent data corruption that can be leveraged
to break the security guarantees of the SRP protocol.

Incorrect X.509 certiﬁcate revocation. Here we cite
two examples from mbedTLS and GnuTLS respectively
showing different types of incorrect error handling bugs
in implementations of two different X509 certiﬁcate re-
vocation mechanisms: CRL (Certiﬁcate Revocation List)
and OCSP (Online Certiﬁcate Status Protocol).

CRL parsing discrepancy. In mbedTLS, EPEX found
that x509_crl_get_version, which retrieves the
version of a X509 certiﬁcate revocation list, has an error
handling bug while calling function asn1_get_int
(line 7 in the code below). Function asn1_get_int
reads an integer from an ASN1 ﬁle. It returns different
negative values to indicate different errors.
In case of
a malformed CRL (Certiﬁcate Revocation List) ﬁle, it
returns POLARSSL_ERR_ASN1_UNEXPECTED_TAG
error value. In case of such an error, line 9-13 treats the
CRL version as 0 (version 1). Thus, mbedTLS parses a
malformed CRL ﬁle as version 1 certiﬁcate. However,
other SSL implementations (e.g., OpenSSL) treat these
errors differently and parse it as a version 2 certiﬁcate.
We are currently discussing the exploitability of this in-
consistency with the developers.

int x509_crl_get_version(unsigned char **p,
const unsigned char

*end,
int *ver )

if((ret = asn1_get_int(p, end, ver))!= 0)
{

POLARSSL_ERR_ASN1_UNEXPECTED_TAG )

}
return(POLARSSL_ERR_X509_INVALID_VERSION +

1
2

3
4
5
6
7
8
9

10
11
12
13
14

15
16

10

{
int ret;

if( ret ==

{

*ver = 0;
return(0);

ret);

}
return( 0 );}

354  25th USENIX Security Symposium 

USENIX Association

Incorrect OCSP timestamps.
GnuTLS function
gnutls_ocsp_resp_get_single is used to read
the timestamp of an Online Certiﬁcate Status Protocol
(OCSP) message along with other information. EPEX
found an error handling bug in it while calling function
asn1_read_value, as shown in line 5 in the follow-
ing code. asn1_read_value reads the value of an
ASN1 tag. It returns an error while failing to read the
tag correctly. gnutls_ocsp_resp_get_single
correctly checks for the error conditions (line 6), but
instead of returning an error value, simply sets the
this_update parameter to −1. However, further up-
stream, in check_ocsp_response, which calls the
function gnutls_ocsp_resp_get_single (line
16), the corresponding variable vtime is not checked
for an error value; only the return value is checked, but
that is a non-error value. Further down the function, at
line 22, vtime is used to check whether the message is
too old. However, in the error path, since vtime is set to
-1 from line 7, the left-hand side of the conditional check
will always be a positive number. Due to a large value of
the variable now (representing current time), the condi-
tional check will always be positive, and result in catego-
rizing all messages to be over the OCSP validity thresh-
old irrespective of their actual timestamp. Depending on
the conﬁguration of GnuTLS, this may result in ignoring
new OCSP responses containing information on recently
revoked certiﬁcates.

1
2

3
4
5

6
7
8
9
10
11
12
13
14
15
16

17
18
19
20
21
22

23
24
25
26

int
gnutls_ocsp_resp_get_single (..., time_t *

this_update)

...
ret = asn1_read_value(resp->basicresp,

name, ttime, &len);

if (ret != ASN1_SUCCESS) {

*this_update = (time_t) (-1);

}
...
return GNUTLS_SUCCESS;

{

}

static int
check_ocsp_response(...)
{ ...

ret = gnutls_ocsp_resp_get_single(...,&

vtime);

if (ret < 0) {

...

}

if (now - vtime >

MAX_OCSP_VALIDITY_SECS) {

...

}
...

}

Incorrect protocol implementations.
Here we show
two examples from OpenSSL where error handling bugs
occur in implementations of two different protocols: Se-
cure/Multipurpose Internet Mail Extensions (S/MIME)
and Datagram Transport Layer Security (DTLS ).

that

the

found

function
OpenSSL
EPEX
does
cms_SignerIdentifier_cert_cmp
not check the return value returned by function
X509_get_serialNumber, as shown in the code
below. This code is part of the OpenSSL code that han-
dles S/MIME v3.1 mail. Here, the error point (see line
6) is at the call site of X509_get_serialNumber,
which returns a pointer to the ASN_INTEGER object
that contains the serial number of the input x509 certiﬁ-
cate. However, in case of a malformed certiﬁcate missing
the serial number, X509_get_serialNumber re-
turns NULL to indicate an error. In this case, the caller
function
cms_SignerIdentifier_cert_cmp
does not check for an error and passes the return value
directly to ASN1_INTEGER_cmp. Thus, the second
argument of ASN1_INTEGER_cmp (y in line number
12) is set to NULL, in the case of an error. At line
16, ASN1_INTEGER_cmp tries to read y−> type and
causes a NULL pointer dereference and results in a
crash. This can be exploited by a remote attacker to
cause a denial of service attack by supplying malformed
X.509 certiﬁcates. This issue was conﬁrmed by the
corresponding developers but they believe that that it
is up to the application programmer to ensure that the
input certiﬁcate is properly initialized.

int cms_SignerIdentifier_cert_cmp(

CMS_SignerIdentifier *sid, X509 *cert)

if (sid->type ==

CMS_SIGNERINFO_ISSUER_SERIAL) {

...
return ASN1_INTEGER_cmp(serialNumber,

X509_get_serialNumber(cert));

}
...
return -1;

1

2
3

4
5
6
7
8
9
10
11
12

13
14
15
16
17
18
19
20

{

{

}

}
int ASN1_INTEGER_cmp(const ASN1_INTEGER *x,

const ASN1_INTEGER *y)

int neg = x->type & V_ASN1_NEG;
/* Compare signs */
if (neg != (y->type & V_ASN1_NEG)) {

...

}
...

Faulty encoding of X.509 certiﬁcates in DTLS. EPEX
found that the function dtls1_add_cert_to_buf
that reads a certiﬁcate from DTLS 2 handshake message
contains an error handling bug while calling i2d_X509
(line 8 in the code below). Function i2d_X509 encodes
the input structure pointed to by x into DER format. It
returns a negative value to indicate an error, otherwise it
returns the length of the encoded data. Here, the caller
code (line 8) does not check for error cases, and thus
gives no indication of whether the read data was valid or
not. In case of an error, this will lead to incorrect results
and silent data corruption.

Faulty parsing of X.509 certiﬁcates in S/MIME.

2Datagram Transport Layer Security: a protocol in SSL/TLS family

USENIX Association  

25th USENIX Security Symposium  355

11

static int dtls1_add_cert_to_buf(BUF_MEM *

buf, unsigned long *l, X509 *x)

int Curl_ossl_random(struct SessionHandle *

data, unsigned char *entropy,

size_t length)

1

2
3
4
5
6
7
8
9
10
11
12

{

}

int n;
unsigned char *p;
...
p = (unsigned char *)&(buf->data[*l]);
l2n3(n, p);
i2d_X509(x, &p);
*l += n + 3;
return 1;

1

2
3
4
5
6
7

{
...

}

5.4 Bugs in applications
Beside libraries, we used EPEX to evaluate error han-
dling implementations in application software that use
SSL/TLS library APIs. We have performed tests on 5
programs that use the OpenSSL library: cURL 3, httpd 4,
Lynx 5, Mutt 6, and Wget 7. Our error speciﬁcation in-
cluded 29 OpenSSL APIs that are used by at least one of
these applications. As the results show in Table 5, even
though EPEX is not as accurate for applications as for li-
braries, and we had to discard 2 alerts because the callers
did not follow the error protocol, it still found 12 real
bugs.

In case of applications, unlike libraries, Step-III of
EPEX was able to compare error behavior across multi-
ple applications and libraries that use the same API. This
allowed us to detect bugs in the cases where an applica-
tion developer has consistently made error handling mis-
takes for an API function as long as other applications
using the same API function are correctly handling the
errors.

In terms of security effects, the bugs that we found
range from causing serious security vulnerabilities to
denial-of-service attacks. We found 2 bugs in cURL ran-
dom number generation modules that can be exploited
to make cURL vulnerable to man-in-the-middle attacks.
We also found 4 bugs in httpd, Mutt, and Lynx that will
cause denial-of-service attacks. The other bugs that we
found mostly lead to resource leakage. We provide one
example of the cURL random number generation bug be-
low.

cURL ignores the return value of the Pseudorandom
In case of an error,
number generator RAND_bytes.
RAND_bytes will return an output buffer with non-
random values. In that case cURL will use it for gen-
erating SSL session keys and other secrets. Note that
a failure in RAND_bytes can be induced by an attacker
by launching a denial of service attack and causing mem-
ory allocation failures, ﬁle descriptor exhaustion, etc.

RAND_bytes(entropy, curlx_uztosi(length));
return 0; /* 0 as in no error */

5.5 Checking for correct error propagation
Besides producing bugs, EPEX also conﬁrms whether a
function call’s error handling code correctly takes care of
all possible errors. Note that EPEX only checks whether
error values are propagated upstream but does not check
whether other error handling tasks (e.g., freeing up all
acquired resources) have been implemented correctly.

The following example shows an instance where
EPEX conﬁrmed that the error codes are correctly prop-
agated by the error handling code. This piece of code is
from GnuTLS 3.3.17.1 and contains the ﬁx for the CVE-
2014-92 vulnerability that we described in the introduc-
tion (Listing 1). EPEX conﬁrmed that the ﬁx indeed cor-
rectly handles the error case.

Besides ﬁxing the bug, the updated version of the
code has also been slightly refactored and reorganized
as shown below. Code in red highlights the bug,
while green shows the ﬁx. The return type of function
check_if_ca has been updated to bool, where re-
turning false (0) indicates an error (see line 1 and 10).
The caller function verify_crt is correctly checking (cid:31)= 1
(i.e. True) at line 17 to handle the error case.

gnutls_assert();
goto fail;

int bool
check_if_ca(...)
{ ...

if (ret < 0) {

}

fail:

...

result = 0;

return result;
}

bool verify_crt(...)
{ ...

if (check_if_ca(...) ==0 != 1) {

result = 0;
goto cleanup;

}
...

cleanup:
...
return result;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

}
We also used EPEX to successfully check the ﬁxes for
other CVEs mentioned in Section 1 (CVE-2015-0208,
CVE-2015-0288, CVE-2015-0285,
and CVE-
-2015-0292).

3http://curl.haxx.se/
4https://httpd.apache.org/
5http://lynx.invisible-island.net/
6http://www.mutt.org/
7https://www.gnu.org/software/wget/wget.html

Imprecision in EPEX Analysis

5.6
The 130 potential bugs reported by EPEX includes 28
false positives and incorrectly excludes 20.
In the li-

356  25th USENIX Security Symposium 

USENIX Association

12

braries, most of the false positives appeared due to the
limitations of underlying Clang symbolic analysis en-
gine. The interprocedural analysis supported by Clang’s
symbolic analysis engine is currently limited to the
functions deﬁned within an input source ﬁle or func-
tions included in the ﬁle through header ﬁles. There-
fore, the symbolic analyzer is not able to gather correct
path conditions and return values for the functions de-
ﬁned in other source ﬁles. For example, in the code
below, EPEX reported error since the return value of
X509_get_serialNumber is not checked at line 5.
However, inside the callee, ASN1_STRING_dup, the
error condition is checked at line 17 and the NULL
value is returned. This return value (serial) is fur-
ther checked at line 6. Since, ASN1_STRING_dup is
implemented in a different ﬁle, EPEX could not infer
that the ASN1_STRING_dup call in line 5 will always
return NULL if X509_get_serialNumber returns
an error. Note that if the pattern of not checking error
for X509_get_serialNumber calls were consistent
across all call-sites, EPEX would not have reported this
false positive due to Step-III in Section 3).

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(...)
{

...
serial = ASN1_INTEGER_dup(

X509_get_serialNumber(cert));

if (!isname || !serial) {

X509V3err(...);
goto err;

}
...

}
ASN1_STRING *ASN1_STRING_dup(

const ASN1_STRING *str)

{

}

ASN1_STRING *ret;
if (!str)

return NULL;

...

Given the false positives due to checks by external
functions, a natural solution would be to have all func-
tions validate their input. While this is a good prac-
tice for library programmers, application programmers
should not depend on functions, whose implementation
they often do not control, to follow this practice. For
debugging purposes, it would appear that the function
receiving the invalid return value is at fault. Moreover,
not all functions can cleanly handle invalid input. Com-
parison functions such as ASN1_INTEGER_cmp only
return non-error values, so the only safe response would
be to terminate the program, which is a drastic action that
can easily be averted by checking the parameters in the
ﬁrst place.

5.7 Performance analysis
EPEX is integrated with the test project’s building proce-
dure through the Clang framework. We ran all our tests
on Linux servers with 4 Intel Xeon 2.67GHz processors
and 100 GB of memory, The following table shows the
performance numbers. EPEX’s execution time is compa-
rable to that of other built-in, simple checkers in Clang
(e.g., division-by-zero) as shown in the table below.

Regular
build

Division-by-zero
in-built checker

wolfSSL
mbedTLS
GnuTLS
OpenSSL

cURL
httpd
Lynx
Mutt
Wget

0.05m
0.67m
1.85m
8.25m
0.18m
0.04m
0.55m
0.10m
0.03m

3.08m
3.72m
13.28m
186.9m
13.96m
4.68m
71.35m
13.03m
5.63m

EPEX
checker

2.68m
2.83m
12.82m
132.33m
12.95m
4.51m
71.73m
13.12m
5.66m

6 Related work

EPEX performed the worst in wolfSSL, mostly due to
confusion arising from compile-time conﬁguration set-
tings affecting the function mp_init. EPEX raised 8
alerts for the function, but after contacting the develop-
ers, we learned that the corresponding functions can be
conﬁgured, at compilation time, to be either fallible or
infallible. All the reported call sites were only compiled
if the functions were conﬁgured to be infallible. There-
fore, our error speciﬁcations should not have marked
these functions as fallible. On the other hand, in the ap-
plications, the most frequent causes are 5 instances of
fallbacks, which are characteristic of applications. Still,
missed checks in external functions are the second most
frequent cause, at 3 cases. The remaining causes are al-
ternative error propagation channels, and deliberate dis-
regard for the error, due to either a conscious choice of
the programmer, or a conﬁguration parameter, as men-
tioned in Section 5.2.

6.1 Automated detection of error handling

bugs

Rubio-González et al. [45, 21] detected incorrect error
handling code in the Linux ﬁle system using a static
control and data-ﬂow analysis. Their technique was de-
signed to detect bugs caused by faulty code that either
overwrite or ignore error values.
In addition to these
two cases, we check whether appropriate error values are
propagated upstream as per global error protocol of the
analyzed program. We use module-speciﬁc error spec-
iﬁcations as opposed to hard coded error values like -
EIO, -ENOMEM, etc. used by Rubio-González et al.
This helps us in reducing the number of false positives
signiﬁcantly; for instance, unlike [45, 21], we do not re-
port a bug when an error value is over-written by another
error value that conforms to the global error protocol.
Our usage of symbolic analysis further minimizes false

USENIX Association  

25th USENIX Security Symposium  357

13

positives as symbolic analysis, unlike the data-ﬂow anal-
ysis used in [45, 21], can distinguish between feasible
and infeasible paths.

Acharya et al. [1] automatically inferred error han-
dling speciﬁcations of APIs by mining static traces of
their run-time behaviors. Then, for a different subject
system, they found several bugs in error handling code
that do not obey the inferred speciﬁcations. The static
traces were generated by MOPS [11] that handles only
control dependencies and minimal data-dependencies.
As observed by Acharya et al., lack of extensive data-
dependency support (e.g., pointer analysis, aliasing, etc.)
introduced imprecision in their results. By contrast, our
symbolic execution engine with extensive memory mod-
eling support minimizes such issues. Further, to iden-
tify error handling code blocks corresponding to an API
function, Acharya et al. leveraged the presence of condi-
tional checks on the API function’s return value and/or
ERRNO ﬂag. They assumed that if such a conditional
check leads to a return or exit call, then it is responsible
for handling the error case. Such assumption may lead to
false positives where conditional checks are performed
on non-error cases. Also, as noted by Acharya et al.,
for functions that can return multiple non-error values,
they cannot distinguish them from error cases. By con-
trast, we create our error speciﬁcations from the program
documentation and thus they do not suffer from such dis-
crepancies.

Lawall et al. [31] used Coccinelle, a program match-
to ﬁnd missing error
ing and transformation engine,
checks in OpenSSL. By contrast, we not only look for
error checks but also ensure that the error is indeed han-
dled correctly. This allows us to ﬁnd a signiﬁcantly larger
class of error handling problems. Also, unlike our ap-
proach, Lawall et al.’s method suffers from an extremely
high false positive rate.

Several other approaches to automatically detect er-
ror/exception handling bugs have been proposed for Java
programs [52, 53, 44, 8, 54]. However, since the er-
ror handling mechanism is quite different in Java than
C (e.g., the try-catch-final construct is not sup-
ported in C), these solutions are not directly applicable
to C code.

Static analysis has been used extensively in the past
to ﬁnd missing checks on security critical objects [48,
57, 49]. However, none of these tools can detect miss-
ing/incorrect error handling checks. Complementary to
our work, and other static approaches, dynamic analy-
sis methods have been developed to discover the practi-
cal effects of error handling bugs, although they do so at
the cost of lower coverage of error paths, as well as un-
known failure modes. Fault injection frameworks such
as LFI bypass the problem of the unlikelihood of er-
rors by injecting failures directly into fallible functions.

LFI includes a module for automatically inferring er-
ror speciﬁcations, although it is not usable in our case,
since static analysis requires explicitly identifying error
and non-error values, and not just differentiate between
them [34].

6.2 Symbolic execution
The idea of symbolic execution was initially proposed by
King et al. [29]. Concolic execution is a recent variant of
symbolic execution where concrete inputs guide the ex-
ecution [19, 10, 47]. Such techniques have been used in
several recent projects for automatically ﬁnding security
bugs [27, 46, 22, 20].

KLEE [9], by Cadar et al., is a symbolic execution
engine that has been successfully used to ﬁnd several
bugs in UNIX coreutils automatically. UC-KLEE [40],
which integrates KLEE and lazy initialization [26], ap-
plies more comprehensive symbolic execution over a
bounded exhaustive execution space to check for code
equivalence; UC-KLEE has also been effective in ﬁnd-
ing bugs in different tools, including itself. Recently,
Ramos et al. applied UC-KLEE to ﬁnd two denial-of-
service vulnerabilities in OpenSSL [41].

SAGE, by Godefroid et al. [20], uses a given set of
inputs as seeds, builds symbolic path conditions by mon-
itoring their execution paths, and systematically negates
these path conditions to explore their neighboring paths,
and generate input for fuzzing. SAGE has been success-
fully used to ﬁnd several bugs (including security bugs)
in different Windows applications like media players and
image processors. SAGE also checks for error handling
bugs, but only errors from user inputs, and not environ-
mental failures, which are unlikely to appear when only
user input is fuzzed.

Ardilla, by Kiezun et al. [27], automates testing of
Web applications for SQL injection and cross-site script-
ing attacks by generating test inputs using dynamic taint
analysis that leverages concolic execution and mutates
the inputs using a library of attack patterns.

Existing symbolic execution tools are not well suited
for ﬁnding error handling bugs for two primary reasons:
(i) The existing symbolic execution tools depend on ob-
vious faulty behaviors like crashes, assertion failures,
etc. for detecting bugs. A large number of error han-
dling bugs are completely silent and do not exhibit any
such behavior. (ii) As the number of paths through any
reasonable sized program is very large, all symbolic ex-
ecution tools can only explore a fraction of those paths.
The effects of most non-silent error handling bugs show
up much further downstream from their source. An off-
the-shelf symbolic execution tool can only detect such
cases if it reaches that point. By contrast, our algorithm
for identifying and exploring error paths enables EPEX

358  25th USENIX Security Symposium 

USENIX Association

14

to detect completely silent and non-silent error handling
bugs at their sources. This makes it easy for the develop-
ers to understand and ﬁx these bugs.

6.3 Security of SSL/TLS implementations
Several security vulnerabilities have been found over the
years in both SSL/TLS implementations and protocol
speciﬁcations [15, 43, 2, 5, 7, 4, 3]. We brieﬂy sum-
marize some of these issues below. A detailed survey of
SSL/TLS vulnerabilities can be found in [13].

Multiple vulnerabilities in certiﬁcation validation im-
plementations, a key part of the SSL/TLS protocol, were
reported by Moxie Marlinspike [38, 37, 36, 35]. Similar
bugs have been recently discovered in the SSL imple-
mentation on Apple iOS [24]. Another certiﬁcate val-
idation bug (“goto fail”) was reported in Mac OS and
iOS [30] due to an extra goto statement in the implemen-
tation of the SSL/TLS handshake protocol. The affected
code did not ensure that the key used to sign the server’s
key exchange matches the key in the certiﬁcate presented
by the server. This ﬂaw made the SSL/TLS implemen-
tations in MacOS and iOS vulnerable to active Man-In-
The-Middle (MITM) attackers. This bug was caused by
unintended overlapping of some parts of a non-error path
and an error path. However, this is not an error handling
bug like the ones we found in this paper.

Hash collisions [50] and certiﬁcate parsing discrep-
ancies between certiﬁcate authorities (CAs) and Web
browsers [25] can trick a CA into issuing a valid certiﬁ-
cate with the wrong subject name or even a valid inter-
mediate CA certiﬁcate. This allows an attacker to launch
a successful MITM attack against any arbitrary SSL/TLS
connection.

Georgiev et al. [18] showed that incorrect usage of
SSL/TLS APIs results in a large number of certiﬁ-
cate validation vulnerabilities in different applications.
Fahl et al. [17] analyzed incorrect SSL/TLS API us-
age for Android applications. Brubaker et al. [6] de-
signed Frankencerts, a mechanism for generating syn-
thetic X.509 certiﬁcates based on a set of publicly avail-
able seed certiﬁcates for testing the certiﬁcate valida-
tion component of SSL/TLS libraries. They performed
differential testing on multiple SSL/TLS libraries using
Frankencerts and found several new security vulnerabil-
ities. Chen et al. [12] improved the coverage and efﬁ-
ciency of Brubaker et al.’s technique by diversifying the
seed certiﬁcate selection process using Markov Chain
Monte Carlo (MCMC) sampling. However, all these
techniques are black-box methods that only focus on the
certiﬁcate validation part of the SSL/TLS implementa-
tions. By contrast, our white-box analysis is tailored to
look for ﬂawed error handling code in any sequential C
code.

Flawed pseudo-random number generation can pro-
duce insecure SSL/TLS keys that can be easily compro-
mised [32, 23]. We have also reported several bugs in-
volving pseudo-random number generator functions in
this paper, although their origins are completely differ-
ent, i.e., unlike [32, 23], they are caused by incorrect
error handling.

7 Future work

Automated inference of error speciﬁcations. One lim-
itation of our current implementation of EPEX is that it
requires the input error speciﬁcations to be created manu-
ally by the user. Automatically generating the error spec-
iﬁcations will signiﬁcantly improve EPEX’s usability.
One possible way to automatically infer the error speci-
ﬁcations is to identify and compare the path constraints
imposed along the error paths (i.e., the paths along which
a function can fail and return errors) across different call-
sites of the same function. However, in order to do so, the
error paths must ﬁrst be automatically identiﬁed. This
leads to a chicken-and-egg problem as the current proto-
type of EPEX uses the input error speciﬁcations to iden-
tify the error paths.

To solve this problem, we plan to leverage different
path features that can distinguish the error paths from
non-error paths. For example, error paths are often more
likely to return constant values than non-error paths [33].
Error paths are also more likely to call functions like exit
(with a non-zero argument) than regular code for early
termination. Further, since errors invalidate the rest of
the computation, the lengths of the error paths (i.e., num-
ber of program statements) might be, on average, shorter
than the non-error paths. An interesting direction for fu-
ture research will be to train a supervised machine learn-
ing algorithm like Support Vector Machines (SVMs) [14]
for identifying error paths using such different path fea-
tures. The supervised machine learning algorithm can
be trained using a small set of error and non-error paths
identiﬁed through manually created error speciﬁcations.
The resulting machine learning model can then be used
to automatically identify different error paths and infer
error speciﬁcations by comparing the corresponding path
constraints.

Automatically generating bug ﬁxes. As error-
handling code is often repetitive and cumbersome to
implement, it might be difﬁcult for developers to keep
up with EPEX and ﬁx all the reported bugs manually.
Moreover, manual ﬁxes introduced by a developer might
also be buggy and thus may introduce new error han-
dling bugs.
In order to avoid such issues, we plan to
automatically generate candidate patches to ﬁx the er-
ror handling bugs reported by EPEX. Several recent
projects [55, 39, 28] have successfully generated patches

USENIX Association  

25th USENIX Security Symposium  359

15

for ﬁxing different types of bugs. Their main approach
is dependent on existing test suites—they ﬁrst generate
candidate patches by modifying existing code and then
validate the patches using existing test cases. While this
generic approach can be applied in our setting, we cannot
use the existing schemes as error handling bugs are, in
general, hard to detect through existing test cases. Also,
these approaches typically focus on bug ﬁxes involving
only one or two lines of code changes. However, the
error handling bugs are not necessarily limited to such
small ﬁxes. Solving these issues will be an interesting
direction for future work.

8 Conclusion

In this paper, we presented EPEX, a new algorithm and a
tool that automatically explores error paths and ﬁnds er-
ror handling bugs in sequential C code. We showed that
EPEX can efﬁciently ﬁnd error handling bugs in differ-
ent open-source SSL/TLS libraries and applications with
few false positives; many of these detected bugs lead to
critical security vulnerabilities. We also demonstrate that
EPEX could also be useful to the developers for check-
ing error handling code.

9 Acknowledgments

We would like to thank Ben Livshits, the shepherd of
this paper, and the anonymous reviewers whose sugges-
tions have improved the presentation of our work. We
would also like to thank David Evans for his feedback
on an earlier draft of this paper. This work is spon-
sored in part by Air Force Ofﬁce of Scientiﬁc Research
(AFOSR) grant FA9550-12-1-0162. The views and con-
clusions contained herein are those of the authors and
should not be interpreted as necessarily representing the
ofﬁcial policies or endorsements, either expressed or im-
plied, of AFOSR.

References
[1] M. Acharya and T. Xie. Mining API Error-Handling Speciﬁca-
tions from Source Code. In International Conference on Funda-
mental Approaches to Software Engineering (FASE), 2009.

[2] N. AlFardan and K. Paterson. Lucky thirteen: Breaking the TLS
and DTLS record protocols. In IEEE Symposium on Security and
Privacy (S&P), 2013.

[3] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Fournet,
M. Kohlweiss, A. Pironti, P. Strub, and J. Zinzindohoue. A messy
state of the union: Taming the composite state machines of TLS.
IEEE Symposium on Security and Privacy (S&P), 2015.

[4] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Pironti, and
P. Strub. Triple handshakes and cookie cutters: Breaking and
ﬁxing authentication over TLS. In IEEE Symposium on Security
and Privacy (S&P), 2014.

[5] D. Bleichenbacher. Chosen ciphertext attacks against protocols
based on the RSA encryption standard PKCS #1. In International
Cryptology Conference (CRYPTO), 1996.

[6] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. Us-
ing frankencerts for automated adversarial testing of certiﬁcate
validation in ssl/tls implementations. In IEEE Symposium on Se-
curity and Privacy (S&P), 2014.

[7] D. Brumley and D. Boneh. Remote timing attacks are practical.

In USENIX Security Symposium, 2003.

[8] R. Buse and W. Weimer. Automatic documentation inference for
exceptions. In International Symposium on Software Testing and
Analysis (ISSTA), 2008.

[9] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and au-
tomatic generation of high-coverage tests for complex systems
programs. In USENIX Symposium on Operating Systems Design
and Implementation (OSDI), 2008.

[10] C. Cadar and D. Engler. Execution generated test cases: How to
make systems code crash itself. In International SPIN Workshop
on Model Checking of Software (SPIN), 2005.

[11] H. Chen and D. Wagner. MOPS: an infrastructure for examining
security properties of software. In ACM Conference on Computer
and Communications Security (CCS), 2002.

[12] Y. Chen and Z. Su. Guided differential testing of certiﬁcate vali-
dation in SSL/TLS implementations. In ACM SIGSOFT Interna-
tional Symposium on the Foundations of Software (FSE), 2015.

[13] J. Clark and P. van Oorschot. SoK: SSL and HTTPS: Revisiting
past challenges and evaluating certiﬁcate trust model enhance-
ments. In IEEE Symposium on Security and Privacy (S&P), 2013.
[14] C. Cortes and V. Vapnik. Support-vector networks. Machine

learning, 20(3):273–297, 1995.

[15] T. Duong and J. Rizzo.

Here come the ⊕ ninjas.
http://nerdoholic.org/uploads/dergln/beast_
part2/ssl_jun21.pdf, 2011.

[16] D. Engler, D. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs
as deviant behavior: A general approach to inferring errors in
systems code.
In Symposium on Operating Systems Principles
(SOSP), 2001.

[17] S. Fahl, M. Harbach, T. Muders, and M. Smith. Why Eve and
Mallory love Android: An analysis of SSl (in)security on An-
droid.
In ACM Conference on Computer and Communications
Security (CCS), 2012.

[18] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov. The most dangerous code in the world: Validating
SSL certiﬁcates in non-browser software. In ACM Conference on
Computer and Communications Security (CCS), 2012.

[19] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed auto-
In ACM SIGPLAN conference on Pro-
mated random testing.
gramming Language Design and Implementation (PLDI), 2005.
[20] P. Godefroid, M. Levin, and D. Molnar. Automated whitebox
fuzz testing. In Network & Distributed System Security Sympo-
sium (NDSS), 2008.

[21] H. Gunawi, C. Rubio-González, A. Arpaci-Dusseau, R. Arpaci-
Dusseau, and B. Liblit. EIO: Error handling is occasionally cor-
rect. In USENIX Conference on File and Storage Technologies
(FAST), 2008.

[22] W. Halfond, S. Anand, and A. Orso. Precise interface identiﬁ-
cation to improve testing and analysis of web applications.
In
International Symposium on Software Testing and Analysis (IS-
STA), 2009.

[23] N. Heninger, Z. Durumeric, E. Wustrow, and A. Halderman. Min-
ing your Ps and Qs: Detection of widespread weak keys in net-
work devices. In USENIX Security Symposium, 2012.

[24] CVE-2011-0228.

http://cve.mitre.org/cgi-bin/

cvename.cgi?name=CVE-2011-0228, 2011.

[25] D. Kaminsky, M. Patterson, and L. Sassaman. PKI layer cake:
New collision attacks against the global X.509 infrastructure. In

360  25th USENIX Security Symposium 

USENIX Association

16

FC, 2010.

[26] S. Khurshid, C. Pasareanu, and W. Visser. Generalized symbolic
execution for model checking and testing. In International Con-
ference on Tools and Algorithms for the Construction and Analy-
sis of Systems (TACAS), 2003.

[27] A. Kiezun, P. Guo, K. Jayaraman, and M. Ernst. Automatic cre-
ation of SQL injection and cross-site scripting attacks. In Inter-
national Conference on Software Engineering (ICSE), 2009.

[28] D. Kim, J. Nam, J. Song, and S. Kim. Automatic patch generation
learned from human-written patches. In International Conference
on Software Engineering (ICSE), 2013.

[29] J. King. Symbolic execution and program testing. Communica-

tions of the ACM, 19(7):385–394, 1976.

[30] A. Langley.

Apple’s SSL/TLS bug.

https://www.

imperialviolet.org/2014/02/22/applebug.
html, 2014.

[31] J. Lawall, B. Laurie, R. Hansen, N. Palix, and G. Muller. Find-
ing error handling bugs in openssl using coccinelle. In European
Dependable Computing Conference (EDCC), 2010.

[32] A. Lenstra, J. Hughes, M. Augier, J. Bos, T. Kleinjung, and
C. Wachter. Ron was wrong, Whit is right. http://eprint.
iacr.org/2012/064, 2012.

[33] P. Marinescu and G. Candea. Efﬁcient testing of recovery code
using fault injection. ACM Transactions on Computer Systems
(TOCS), 29(4), 2011.

[34] P. D. Marinescu, R. Banabic, and G. Candea. An extensible tech-
In USENIX

nique for high-precision testing of recovery code.
Annual Technical Conference, 2010.

[35] M. Marlinspike.

IE SSL vulnerability.

http://www.

thoughtcrime.org/ie-ssl-chain.txt, 2002.

[36] M. Marlinspike. More tricks for defeating SSL in practice. DEF-

CON, 2009.

[37] M. Marlinspike. New tricks for defeating SSL in practice. Black

Hat DC, 2009.

[38] M. Marlinspike. Null preﬁx attacks against SSL/TLS cer-
http://www.thoughtcrime.org/papers/

tiﬁcates.
null-prefix-attacks.pdf, 2009.

[39] Z. Qi, F. Long, S. Achour, and M. Rinard. An analysis of patch
plausibility and correctness for generate-and-validate patch gen-
eration systems. In International Symposium on Software Testing
and Analysis (ISSTA), 2015.

[40] D. Ramos and D. Engler. Practical, low-effort equivalence veri-
ﬁcation of real code. In International Conference on Computer-
Aided Veriﬁcation (CAV), 2011.

[41] D. Ramos and D. Engler. Under-constrained symbolic execution:
correctness checking for real code. In USENIX Security Sympo-
sium, 2015.

[42] Checker developer manual.

http://clang-analyzer.

llvm.org/checker_dev_manual.html.

[43] J. Rizzo and T. Duong. The CRIME attack. In Ekoparty, 2012.
[44] M. Robillard and G. Murphy. Analyzing exception ﬂow in Java
In ACM SIGSOFT International Symposium on the

programs.
Foundations of Software (FSE), 1999.

[45] C. Rubio-González, H. Gunawi, B. Liblit, R. Arpaci-Dusseau,
and A. Arpaci-Dusseau. Error propagation analysis for ﬁle sys-
tems. In ACM SIGPLAN conference on Programming Language
Design and Implementation (PLDI), 2009.

[46] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
In

D. Song. A symbolic execution framework for JavaScript.
IEEE Symposium on Security and Privacy (S&P), 2010.

[47] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit testing
engine for C. In ACM SIGSOFT International Symposium on the
Foundations of Software (FSE), 2005.

[48] S. Son, K. McKinley, and V. Shmatikov. Rolecast: ﬁnding miss-
ing security checks when you do not know what checks are. In

International Conference on Object Oriented Programming, Sys-
tems, Languages and Applications (OOPSLA), 2011.

[49] V. Srivastava, M. Bond, K. McKinley, and V. Shmatikov. A se-
curity policy oracle: Detecting security holes using multiple API
implementations. In ACM SIGPLAN conference on Programming
Language Design and Implementation (PLDI), 2011.

[50] M. Stevens, A. Sotirov, J. Appelbaum, A. Lenstra, D. Molnar,
D. Osvik, and B. Weger. Short chosen-preﬁx collisions for MD5
and the creation of a rogue CA certiﬁcate. In International Cryp-
tology Conference (CRYPTO), 2009.

[51] The Apache Software Foundation. Apache portable runtime: Er-
ror codes. Available at https://apr.apache.org/docs/
apr/1.4/group__apr__errno.html, 2011.

[52] W. Weimer and G. Necula. Finding and preventing run-time er-
ror handling mistakes.
In International Conference on Object
Oriented Programming, Systems, Languages and Applications
(OOPSLA), 2004.

[53] W. Weimer and G. Necula. Mining Temporal Speciﬁcations for
Error Detection.
In International Conference on Tools and Al-
gorithms for the Construction and Analysis of Systems (TACAS),
2005.

[54] W. Weimer and G. Necula. Exceptional situations and program
reliability. ACM Transactions on Programming Languages and
Systems (TOPLAS), 2008.

[55] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest. Automat-
In Interna-

ically ﬁnding patches using genetic programming.
tional Conference on Software Engineering (ICSE), 2009.

[56] D. A. Wheeler.

Sloccount. Available at http://www.

dwheeler.com/sloccount/, 2015.

[57] F. Yamaguchi, C. Wressnegger, H. Gascon, and K. Rieck.
Chucky: exposing missing checks in source code for vulnera-
bility discovery. In ACM Conference on Computer and Commu-
nications Security (CCS), 2013.

A Appendix

Listing 3:
RAND_pseudo_bytes in OpenSSL

Sample implementation of

/* crypto/engine/hw_aep.c */
int aep_rand(unsigned char *buf, int len)
{

...
AEP_RV rv = AEP_R_OK;
AEP_CONNECTION_HNDL hConnection;
rv = aep_get_connection(&hConnection);
if (rv != AEP_R_OK) {

AEPHKerr(AEPHK_F_AEP_RAND,
goto err_nounlock;

AEPHK_R_GET_HANDLE_FAILED);

}
if (len > RAND_BLK_SIZE) {

rv = p_AEP_GenRandom(hConnection, len,

2, buf, NULL);

if (rv != AEP_R_OK) {

AEPHKerr(AEPHK_F_AEP_RAND,
goto err_nounlock;

AEPHK_R_GET_RANDOM_FAILED);

1
2
3
4
5
6
7
8
9
10

11
12
13
14
15

16
17

18
19
20
21
22
23
24
25

17

}
}
...
return 1;

err_nounlock:
return 0;

}

USENIX Association  

25th USENIX Security Symposium  361

Table 6: Tested functions and bug counts

Function
Name
ASN1_INTEGER_set
BN_mod_exp
BN_sub
EC_KEY_up_ref
EC_POINT_cmp
PEM_read_bio_X509
RAND_pseudo_bytes
X509_get_serialNumber
i2a_ASN1_INTEGER
i2d_X509

Total

asn1_read_value
asn1_write_value
gnutls_openpgp_crt_get_subkey_idx
gnutls_openpgp_privkey_get_subkey_idx
gnutls_privkey_get_pk_algorithm
gnutls_x509_crq_get_dn_by_oid
gnutls_x509_crq_get_extension_info
gnutls_x509_crq_get_pk_algorithm
gnutls_x509_crt_get_serial
gnutls_x509_privkey_import
gnutls_x509_privkey_import_pkcs8
record_overhead_rt

Total

aes_setkey_enc
asn1_get_int
asn1_get_tag
md_hmac_starts
md_init_ctx
mpi_ﬁll_random
ssl_handshake

Total

wc_InitRsaKey
wc_ShaHash
mp_init

Total

RAND_bytes
SSL_get_peer_cert_chain
SSL_shutdown

Total

BIO_free
BIO_new
SSL_CTX_new
SSL_CTX_use_certiﬁcate_chain_ﬁle
SSL_get_peer_cert_chain
SSL_get_peer_certiﬁcate
SSL_get_verify_result
SSL_read
SSL_write

Total

SSL_set_fd
SSL_CTX_new

Total

SSL_CTX_new
BIO_new
SSL_shutdown

Total

BIO_new

Total

OpenSSL

GnuTLS

mbedTLS

wolfSSL

cURL

httpd

Lynx

Mutt

Wget

Grand_Total

Bug
Count
4
3
2
1
1
2
20
3
3
9

48

4
3
1
3
3
2
1
2
1
0
1
2

23

0
2
8
2
2
5
0

19

0
0
0

0

2
0
0

2

4
1
1
1
0
0
0
0
0

7

1
0

1

0
1
1

2

0

0
102

False
Positives
0
0
0
0
0
0
1
1
0
0

2

0
0
0
0
1
0
0
0
0
1
0
0

2

1
0
0
0
0
0
1

2

1
1
8

10

0
1
1

2

0
1
0
0
1
1
1
1
1

6

0
2

2

1
0
0

1

1

1
28

18

362  25th USENIX Security Symposium 

USENIX Association

