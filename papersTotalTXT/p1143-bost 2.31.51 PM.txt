Σoφoς – Forward Secure Searchable Encryption

Direction Générale de l’Armement - Maîtrise de l’Information

Raphael Bost

Université de Rennes 1

raphael_bost@alumni.brown.edu

ABSTRACT
Searchable Symmetric Encryption aims at making possible
searching over an encrypted database stored on an untrusted
server while keeping privacy of both the queries and the
data, by allowing some small controlled leakage to the server.
Recent work shows that dynamic schemes – in which the
data is eﬃciently updatable – leaking some information on
updated keywords are subject to devastating adaptative at-
tacks breaking the privacy of the queries. The only way
to thwart this attack is to design forward private schemes
whose update procedure does not leak if a newly inserted
element matches previous search queries.

This work proposes Σoφoς as a forward private SSE scheme
with performance similar to existing less secure schemes, and
that is conceptually simpler (and also more eﬃcient) than
previous forward private constructions. In particular, it only
relies on trapdoor permutations and does not use an ORAM-
like construction. We also explain why Σoφoς is an optimal
point of the security/performance tradeoﬀ for SSE.

Finally, an implementation and evaluation results demon-

strate its practical eﬃciency.

CCS Concepts
•Security and privacy → Privacy-preserving proto-
cols; Security protocols; Management and querying
of encrypted data;

Keywords
Searchable Symmetric Encryption; Forward Privacy; Prov-
able Security; Implementation

1.

INTRODUCTION

Being able to eﬃciently and privately query an encrypted
database stored on an untrusted server is critical for secure
cloud applications. Ideally, we would like to use protocols
leaking absolutely no information to the server. Such solu-
tions can be constructed using powerful techniques such as

Publication rights licensed to ACM. ACM acknowledges that this contribution was
authored or co-authored by an employee, contractor or afﬁliate of a national govern-
ment. As such, the Government retains a nonexclusive, royalty-free right to publish or
reproduce this article, or to allow others to do so, for Government purposes only.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978303

multi-party computation, fully homomorphic encryption, or
oblivious RAM, but, due to the genericity of these, they are
impractical: they are slower than a na¨ıve approach consist-
ing in downloading the entire database and do the search
locally [Nav15].

Searchable Symmetric Encryption (SSE) [SWP00], which
is a class of structured encryption [CK10] for search struc-
tures such as search indexes or search trees, provides a so-
lution to this problem by trading leakage for eﬃciency. This
leakage comes from the use of (often symmetric) determin-
istic encryption that will enable the server to easily ﬁnd
matches between encrypted tokens, without having to run
expensive protocols or computations.

In previous works, leakage ranges from fully revealing the
keyword occurence pattern in each document (including, the
keyword order), as of legacy-compatible constructions such
as CipherCloud [Cip] or skyhigh [sky], to query-revealed oc-
curence patterns, for reversed-index-based schemes derived
from [CGKO06].

Islam et al. [IKK12] and Cash et al. [CGPR15] studied the
real-world consequences of the leakage of SSE schemes and
showed that even small leakage can be leveraged by a passive
attacker to reveal the client’s queries, leading to leakage-
abuse attacks. For larger leakage, the authors of [CGPR15]
show that full plaintext recovery of the encrypted database
is possible.

Their work was improved by the one of Zhang et al. in the
case of dynamic databases, where the attacker can inject new
documents in the database, in [ZKP16]. In this paper, the
authors showed a devastating adaptive attack which reveals
the content of a past query by inserting as few as 10 new
documents. This attack can be run on almost all existing
SSE schemes because the server can learn that the newly
added document matches a previous search query.

This work underlines the need for SSE constructions which
do no leak this information, also called forward private con-
structions [SPS14]. To our knowledge, besides the ORAM-
based ones such as TWORAM [GMP15], the only existing
forward private schemes are by Chang and Mitzenmacher
[CM05], and by Stefanov et al. [SPS14], but both suﬀer from
ineﬃciencies. The former has a large bandwith requirement
from the client to the server for search queries, and a very
large server storage, while the latter uses non trivial ORAM-
related techniques, which induces a large bandwith overhead
on updates, despite supporting eﬃcient deletions.

Until now, no SSE construction oﬀered both the secu-
rity requirements necessary to thwart those leakage-abuse
attacks, and achieved optimal update eﬃciency.

1143Scheme

[CJJ+14]
[BFP16]

[SPS14]

[SPS14]
([BFP16])

[GMP15]

O

min

O(aw)

O(aw + log W )

(cid:111)(cid:17)
(cid:110) aw + log N
(cid:16)
(cid:111)(cid:17)
(cid:16)
(cid:110) aw + log2 N
(cid:101)O(aw log N + log3 N )

nw log3 N

nw log3 N

O

min

Σoφoς
Σoφoς-ε

O(aw)
O(aw)

O(1)
O(1)


















1






Computation

Communication

Search

Update

Search

Update

Client
Storage

Forward
Private

M.A.

Previous works

O(1)

O(nw)

O(1)

O(log W ) O(nw + log W ) O(log W )

O(1)
O(1)

O(log2 N ) O(nw + log N )

O(log N )

O(N α)

O(log2 N ) O(nw + log N )

(cid:101)O(log2 N )

(cid:101)O

(cid:16) aw log N

(cid:17)

+ log3 N
This work

O(nw)
O(nw)

O(log N )

(cid:101)O(log3 N )

O(N α)

O(1)

O(1)
O(1)

O(W log D)

O(W (log D + λ))

Table 1 – Comparison with existing SSE schemes. N is the number of entries (i.e. the number of keyword/document pairs)
in the database, while W is the number of distinct keywords, and D the number of documents. nw is the size of the search
result set for keyword w, and aw is the number of times the queried keyword w was historically added to the database.
In particular, in all works except [SPS14], deletions are not optimally supported: the search is not linear in the number of
matching documents, but in the number of inserted documents matching the query. M.A. stands for ‘Malicious Adversary’.
We omitted the polynomial dependency in the security parameter λ for both computation and communication complexity.

The (cid:101)O notation hides the log log N factors. Update complexities are given per updated document/keyword pair. We only

considered schemes whose server’s storage complexity is optimal (O(N )).

Contributions. We construct a forward private SSE scheme
with optimal search and update complexity, for both com-
putational and communicational complexity, called Σoφoς.2
It has both the security guarantees of forward private con-
structions [SPS14], and the asymptotic eﬃciency of con-
structions with more leakage [CJJ+14]. Our scheme uses
simple cryptographic tools (only pseudo-random functions
and trapdoor permutations, and does not rely on ORAM
ideas), and is very easy to understand. A comparison of
Σoφoς with previous works is given in Table 1.

We give a full proof of security against honest-but-curious
adversaries, and show how it can be easily extended to secu-
rity against malicious adversaries, without server-side mod-
iﬁcations of the construction (Σoφoς-ε).

Finally, we provide an open source implementation of our
scheme, and show that, even on persistent storage, it is very
eﬃcient in practice, for both searches and updates.

2. RELATED WORK

SSE has been introduced by Song et al. [SWP00], with
a solution whose search time is linear in the size of the
database. Chang and Mitzenmacher [CM05] later proposed
a construction whose search time is also linear, but that
achieves forward privacy.

Ten years ago, Curtmola et al. [CGKO06] were the ﬁrst to
formally consider leakage, and designed, in the static setting,
the ﬁrst index-based SSE construction achieving sublinear
search complexity. The ﬁrst dynamic and sublinear scheme

1There is a ﬂaw in the original paper [SPS14], concern-
ing security against malicious adversaries, but it can be
ﬁxed without large modiﬁcations of the original construc-
tion (cf. [BFP16]).
2Σoφoς (pronounce ‘sophos’) stands for Scalable Optimal
FOrward Secure Searchable Encryption. It also refers to the
ancient greek for ‘wise’: we strongly believe that it is wise
to use a forward private SSE scheme.

was introduced by Kamara et al. [KPR12], but was leak-
ing the hashes of keywords contained by the updated doc-
uments. Kamara and Papamanthou [KP13] later improved
this construction, and reduced the leakage at the cost of in-
creased space complexity on the server. Still, this construc-
tion is not forward private.

another line of work presented index based schemes sup-
porting boolean queries [CJJ+13], optimized for very large
databases and dynamism [CJJ+14], or in a three-party set-
ting [JJK+13], some of whose features were also studied
in [PKV+14].

Forward privacy was for the ﬁrst time explicitely consid-
ered by Stefanov et al. in [SPS14]. The authors built in their
paper a dynamic, sublinear scheme achieving forward pri-
vacy.

Veriﬁable SSE schemes (i.e. secure against an active ad-
versary) have been studied by Kurosawa and Ohtaki [KO12],
and eﬃcient and dynamic constructions have been recently
proposed by Bost et al. [BFP16], including a forward private
one derived from [SPS14].

Recently, Cash and Tessaro [CT14] demonstrated a lower
bound on the storage locality of searchable encryption: it is
not possible to achieve both optimal server storage and opti-
mal locality. Their lower bound was shown tight by Asharov
et al. [ANSS16].

SSE was extended by Chase and Kamara [CK10] to arbi-
trarily-structured data, such as graphs, matrices or labeled
data. New applications of structured encryptions arose re-
cently, such as approximate shortest distance queries on an
encrypted graph [MKNK15].

SSE can be constructed from Oblivious RAM [GO96],
either in a black box way, or using speciﬁc ORAM sub-
components, in a grey-box way, as in [GMP15]. Unfortu-
nately, ORAM induces large bandwith overhead, large client
storage and/or, multiple roundtrips. This makes use of ORAM
for SSE unrealistic, as showed in the study by Naveed [Nav15].

1144Islam et al. [IKK12] studied the consequences of leakage
in searchable encryption. Their attacks were improved by
Cash et al. [CGPR15], and lately by Zhang et al. [ZKP16],
who demonstrated the need for forward privacy for SSE.

its state σ, and a search query q, and the server with
input EDB. For single-keyword search schemes (as the
ones considered in this paper), a search query is re-
stricted to a unique keyword w.

3. PRELIMINARIES

In the paper, λ is the security parameter and negl(λ) de-
notes a negligible function in the security parameter. Our
construction uses pseudo-random functions (PRF) and (keyed)
hash functions, for which we use the standard security deﬁ-
nitions [Gol04].

Unless speciﬁed explicitely, the symmetric keys are strings
of λ bits, and the key generation algorithm uniformly sam-
ples a key in {0, 1}λ. We only consider (possibly probabilis-
tic) algorithms and protocols running in time polynomial
in the security parameter λ. In particular, adversaries are
probabilistic polynomial time algorithms.
For a ﬁnite set X, x $← X means that x was uniformly

sampled from X.
3.1 Trapdoor Permutations
A trapdoor permutation (TDP) π is a permutation over
a set D such that, using a public key PK, π can be easily
evaluated, but the inverse π−1 can be eﬃciently computed
only with the secret SK.
More formally, π with the key generation algorithm KeyGen
is a trapdoor permutation if for every adversary A

AdvOWπ,A(λ) ≤ negl(λ)

where

AdvOWπ,A(λ) = Pr[y $← M,(SK, PK) ← KeyGen(1λ),

x ← A(1λ, PK, y) : πPK(x) = y]

SK (πPK(x)) = x

PK (x) (resp. π(−c)
SK ) c times.

(π is one-way) while for every x ∈ D
SK (x)) = x and π−1
SK (.) can be computed in polynomial time.
SK (x))

πPK(π−1
and πPK(.) and π−1
In the paper we also use the notation π(c)
for the iterated application of πPK (resp. π−1
3.2 Symmetric Searchable Encryption
i=1 is a tuple of index/keyword-
set pairs with indi ∈ {0, 1}(cid:96) and Wi ⊆ {0, 1}∗. The set of
keywords of the database DB is W = ∪D
i=1Wi. We set D to
be the number of documents in DB, W = |W| the total num-
i=1 |Wi| to be the number of
document/keyword pairs (we identify documents with their
indices). We denote by DB(w) the set of documents contain-
ing keyword w, i.e. DB(w) = {indi|w ∈ Wi}. N can also be

A database DB = (indi, Wi)D

ber of keywords , and N =(cid:80)D
written as N =(cid:80)

w∈W |DB(w)|.

A dynamic searchable encryption scheme Π = (Setup,
Search, Update) consists of one algorithm and two protocols
between a client and a server:

• Setup(DB) is an algorithm that takes as input a database
DB. It outputs a pair (EDB, K, σ) where K is a secret
key, EDB the encrypted database, and σ the client’s
state.

• Search(K, q, σ; EDB) = (SearchC (K, q, σ), SearchS(EDB))

is a protocol between the client with input the key K,

• Update(K, σ, op, in; EDB) = (UpdateC (K, σ, op, in),
UpdateS(EDB)) is a protocol between the client with
input the key K and state σ, an operation op and an
input in parsed as the index ind and a set W of key-
words, and the server with input EDB. The update
operations are taken from the set {add, del}, meaning,
respectively, the addition and the deletion of a docu-
ment/keyword pair.
3.3 Security of SSE

SSE schemes must achieve two security properties: cor-

rectness and conﬁdentiality.

Correctness. The correctness of an SSE scheme is a basic
property: the search protocol must return the correct result
for every query, except with negligible probability.

Conﬁdentiality. The conﬁdentiality deﬁnition of an SSE
scheme uses the real world versus ideal world formaliza-
tion [CGKO06, KPR12, CJJ+14]. It is parametrized by a
leakage function L = (LStp,LSrch,LUpdt) describing what the
protocol leaks to the adversary, and formalized as a stateful
algorithm. The deﬁnition ensures that the scheme does not
reveal any information beyond the ones that can be inferred
from the leakage function.

More precisely, we deﬁne two games, SSEReal, and SSE-
Ideal, in which the adversary A chooses a database DB,
and is given back EDB generated using Setup(DB) in the
real case, or S(LStp(DB)) in the ideal case. Then, he repeat-
edly performs search and update queries with an input in
and receives the transcripts generated running the Search(q)
(resp. Update(op, in)) protocol in the real game, or the sim-
ulator S(LSrch(q)) (resp. S(LUpdt(op, in))) in the ideal game.
Eventually, A outputs a bit. We say that the scheme is L-
adaptively-secure if for all adversary A, there exists an eﬃ-
cient simulator S such that the adversary A cannot distin-
guish an execution of the real game from an execution of the
ideal game with non-negligible probability.

Common Leakage. Many SSE schemes leak the repeti-
tion of tokens sent by the client to the server, and hence,
the repetition of queried keywords. Similarly to previous
works [CGKO06], when this leakage is limited to search
queries (for example in static schemes), we call it the search
pattern. When repetition of updated keywords also leaks, we
call it the query pattern.
More formally, the leakage function L will keep as state
the query list Q: the list of all queries issued so far, and
whose entries are (i, w) for a search query on keyword w, or
(i, op, in) for an op update query with input in. The integer
i is a timestamp, initially set to 0, and which is incremented
at each query. The search and query patterns, respectively
denoted sp(x) and qp(x), are then deﬁned as

sp(x) = {j : (j, x) ∈ Q} (only matches search queries)
qp(x) = {j : (j, x) ∈ Q or

(j, op, in) ∈ Q and x appears in in}

1145In the paper, we also introduce the notation HistDB(w):
it is the list of documents historically added to DB matching
keyword w, in the order of insertion. In particular, it includes
documents that have been added and later deleted, or even
documents that have been added twice.

Finally, we use the notation Hist(w), the history of key-
word w. It lists all the modiﬁcations made to DB(w) over the
time. It consists in a tuple whose ﬁrst element is DB0(w),
the set of documents indices matching w at setup, and whose
second element is the list UpHist(w) of updates of documents
matching w, called the update history. For example, consider
two documents Dind1 and Dind2 matching w. Suppose that we
ﬁrst added Dind1 at the second update, then Dind2 at the 5-th
update, and ﬁnally that Dind1 got removed during the 14-
th update. Then UpHist(w) = [(2, add, ind1), (5, add, ind2),
(14, del, ind1)]. These can be also formally deﬁned using the
query list.

4. FORWARD PRIVACY
4.1 Deﬁnition

Forward privacy is a strong property of the SSE leakage
function of dynamic SSE schemes. Informally, it means that
an update does not leak any information about the updated
keywords. In particular, the server cannot learn that the up-
dated document matches a keyword we previously queried.
More formally, we give the following deﬁnition of forward
privacy.

Deﬁnition 1. A L-adaptively-secure SSE scheme Σ is for-
ward private if the update leakage function LUpdt can be
written as

LUpdt(op, in) = L(cid:48)

(op,{(indi, µi)})

where {(indi, µi)} is the set of modiﬁed documents paired
with the number µi of modiﬁed keywords for the updated
document indi.

The deﬁnition given here slightly extends the informal def-
inition of forward privacy of Stefanov et al. [SPS14] which
focused only on added documents rather than on updated
(i.e. both added and deleted) documents. They also describe
backward privacy, a property that prevents searches to be
performed over deleted documents.

The only existing schemes supporting both forward and
backward privacy are based on Oblivious RAM, but are
not particularly eﬃcient, while eﬃcient forward private-only
schemes have been designed [CM05, SPS14], but suﬀer from
a big bandwith or storage blowup.
4.2 The Need for Forward Privacy

Islam et al. [IKK12] and Cash et al. [CGPR15] studied
the real-world consequences of the leakage of SSE schemes
and showed that even small leakage can be leveraged by an
attacker to reveal the client’s queries. Their work not only
considered static databases but also dynamic databases, in
a setting where the server could submit new documents to
be added in the database in a way that would help him to
break query privacy. Zhang et al. [ZKP16] improved this ﬁle
injection attack and showed that it can be devastating.

They actually describe both a non-adaptive and an adap-
tive attack. The adaptive attack is very eﬀective but only
applies to schemes that are not forward private. This at-
tack, reveals a previously search keyword w by submitting

log 2T new documents if the adversary has partial knowl-
edge of the database, or using W/T + log T new documents
if he hasn’t. T is the threshold parameter, a public param-
eter used to avoid non adaptative attacks, and that needs
to be kept small to be an eﬃcient counter measure (but not
too small, to avoid a large eﬃciency loss). In [ZKP16], the
authors chose T = 200 for their experiments, and in this
case, the privacy of a query can be broken by an adversary
posting less than 10 new documents.

Even on a functional point of view, forward privacy is
important. Indeed, a forward private scheme allows for an
online build of the encrypted database. In most other SSE
constructions, one must ﬁrst go through an indexing step:
the setup phase needs an inverted index whose construction
takes both time and space. Forward private schemes avoid
this source of ineﬃciency.
4.3 Constraints Induced by Forward Privacy
Unfortunately, forward privacy has various downsides in
terms of eﬃciency. This section explains that dynamic SSE
schemes have to make compromises between storage eﬃ-
ciency, locality, and security.

On Storage. First, let us focus on storage. A desirable
property of dynamic databases is space reclamation upon
entry deletion. For searchable encryption, it implies that,
when a document/keyword pair is removed from the en-
crypted index, the logical location of the pair can be marked
as empty. Now, suppose an adversary successively submits
a search query for a keyword w, and then a delete query for
pair (ind, w). If the Search protocol does not modify the en-
crypted database (almost all existing schemes do not), and
if the scheme reclaims space, the adversary will learn that
the updated keyword was just searched. The previous exam-
ple actually shows that the locations of the encrypted pairs
before and after the search query must be completely unre-
lated for forward private, space-reclaiming scheme, yielding
constructions with security properties close to the ones of re-
sizable ORAM [MMBC15]. In particular, one cannot really
hope for extremely eﬃcient scheme with these properties.

On Locality. In [CT14], Cash and Tessaro studied the prob-
lem of memory accesses locality in SSE. In particular, they
showed that one cannot achieve even minimal locality with-
out increasing the size of the encrypted database beyond
Θ(N ). Their lower bound holds for static schemes, and so
applies for dynamic schemes too, but, to our knowledge, lo-
cality of dynamic SSE has not been speciﬁcally studied.

Here we claim that, for dynamic schemes, locality and
forward-privacy are two irreconciliable notions. First, it is
worth noticing that caring about memory locality makes
sense only if the scheme is already eﬃcient in terms of disk
accesses. For example, if a scheme systematically updates
the encrypted database every time a search is performed
(e.g. the ORAM-based scheme [GMP15]), the rewriting cost
will be much higher than the eﬃciency improvements due to
increased locality. So without loss of generality, we consider
schemes whose Search protocol does not modify a large por-
tion of EDB. In this case, forward privacy implies that, for
an updated keyword w, the location of the newly inserted
tokens is unrelated to the location of already existing tokens
matching w. So, if the whole set DB(w) is not somehow, at
least partially, re-written during the update, no locality op-

1146π−1

SK

πPK

ST0(w)

ST1(w)

π(c−1)

PK

STc(w)

π−1

SK

πPK

STc+1(w)

HKw

HKw

U T0(w)

U T1(w)

···

···

HKw

HKw

U Tc(w)

U Tc+1(w)

Figure 1 – Relations among tokens. Operations in red can only be done by the client, using the secret key SK.

timization is possible for keyword w. Said otherwise, if you
want both forward privacy and locality during search, you
have to do some rather large modiﬁcations of the encrypted
database, either during searches or updates.

Finally, we will in see in the evaluation of our implemen-
tation that non-locality is not a critical performance issue
with modern SSDs.

5. THE Σoφoς CONSTRUCTION

In this section, we construct a forward secure SSE scheme,
whose Search and Update protocols are performed in a single
roundtrip, but at the cost of O(W (log D + log |M|) storage
on the client side. We also ﬁrst consider a scheme that only
supports additions, not deletions. We will then describe how
to turn this basic construction into an SSE constructions
supporting both additions and deletions, with reduced client
storage, and also how to make it secure against malicious
adversaries.
5.1 General ideas

In an inverted index scheme (such as [CGKO06] and de-
rived works), we are usually considering for each keyword
w an indexed list of matching documents (ind0,··· , indnw ).
Every element indc of this list is then encrypted and stored
at a (logical) location derived from w and c. We call this
location U Tc(w). When the client wants to add a document
matching w, he computes a new location U Tnw +1(w), en-
crypts the document index as e, and sends (U Tnw +1(w), e)
to the server (this explains our notation U T , for update to-
ken).

When the client performs a search query on w, he will
issue a search token that will allow the server to recompute
the update tokens, and hence the locations of the entries
matching w. In general, we want the update tokens for a
given w to be unlinkable until a search token ST (w) is is-
sued. In our case, the search token generated by the client
will depend on the number nw of matching entries, and we
want that the search token STc(w) generated for c results
to be unlinkable to the update tokens U Ti(w) for i > c,
i.e. the update tokens that will be issued for keyword w in
the future. In particular, it implies that the server could not
generate STi(w) from STc(w) when i > c.

To do so, we could make the client generate all the search
token using a PRF evaluation F (w, i), and send them to
the server. However this solution is not satisfactory: the
client needs to send O(nw) tokens to the server, which can
be a problem on constrained devices. In this work, we pro-
pose another solution, based on trapdoor permutations: from
STi(w), the server will be able to compute STi−1(w) using

the a public key, but only the client will be able to construct
STi+1(w).

Figure 1 gives the relations among the tokens and formal-
izes our idea for token generation. STi+1(w) is generated
from STi(w) by applying the inverse of a one-way trapdoor
permutation π: only the client will be able to perform this
operation, while the server, given the public key PK will do
the opposite, namely compute from a search token STc(w)
all the tokens STi(w) for 0 ≤ i < c. Finally, the update to-
kens are derived from the search tokens, using a keyed hash
function. In particular, it is crucial that H is pre-image re-
sistant for the security of the scheme. We will actually show
the security of this construction when H is modeled by a
random oracle.

5.2 Basic Construction

Algorithm 1 gives the formal description of our basic for-
ward private scheme, Σoφoς-B. It follows the idea of the
previous section, in particular for token generation. Also,
the only updates Σoφoς-B supports are insertions of new
keyword/document pairs.

In the pseudo code, π is a trapdoor permutation, F is
a PRF, H1 and H2 are keyed hash functions, whose out-
puts are, respectively, µ and (cid:96) bits long. On the client side,
W maps every inserted keyword to its current search token
STc(w) and to a counter c = nw − 1. Every time a new doc-
ument matching w is inserted, W[w] gets ‘incremented’: the
client generates the new search token STc+1(w) = π−1(STc(w))
and stores it in W. If w did not match any documents, a
new ST0(w) is randomly picked and put in W. Finally, the
entries locations, i.e. the update tokens, are derived from
the search tokens by a keyed hash function.

Σoφoς’ setup algorithm does not take a database as input:
as stated in Section 4.2, encryption can be performed online
with a forward private scheme, without loss of security.

Correctness. The correctness of Σoφoς-B is quite straight-
forward. The only issue is collision among the update tokens
U Tc(w), generated from H1 with input (Kw, STc). We can
reduce the correctness to the collision resistance of H1. In
particular, we need to choose µ such that N 2/2µ is negli-
gible in the security parameter, so in practice, we will set
µ = λ + 2 log Nmax, where Nmax is the maximum number of
pairs the database can support.

Complexity. The scheme’s computational complexity is op-
timal: O(nw) for a search query, O(1) for an update. Both
Search and Update are single round, and their performance
will not be more aﬀected by network latency than regular

1147Algorithm 1 Σoφoς-B: Forward private SSE scheme with
large client storage.
Setup()

$← {0, 1}λ

1: KS
2: (SK, PK) ← KeyGen(1λ)
3: W, T ← empty map
4: return ((T, PK), (KS, SK), W)

Client:

Search(w, σ; EDB)
1: Kw ← FKS (w)
2: (STc, c) ← W[w]
3: if (STc, c) = ⊥

return ∅

4:
5: Send (Kw, STc, c) to the server.

Server:

(cid:46) c = nw − 1

8:

6: for i = c to 0 do
7:

U Ti ← H1(Kw, STi)
e ← T[U Ti]
ind ← e ⊕ H2(Kw, STi)
STi−1 ← πPK(STi)

9:
10: Output each ind
11:
12: end for
Update(add, w, ind, σ; EDB)
1: Kw ← F (KS, w)
2: (STc, c) ← W[w]
3: if (STc, c) = ⊥ then
$← M, c ← −1

Client:

ST0
STc+1 ← π−1

4:
5: else
SK (STc)
6:
7: end if
8: W[w] ← (STc+1, c + 1)
9: U Tc+1 ← H1(Kw, STc+1)
10: e ← ind ⊕ H2(Kw, STc+1)
11: Send (U Tc+1, e) to the server.
12: T[U Tc+1] ← e

Server:

insecure protocols.
Bandwith is also (almost) optimal. The Search protocol
uses a single log |M| = poly(λ) bits token per query. The
Update protocol sends a µ + (cid:96) bits token per updated docu-
ment/keyword pair, representing a λ+log Nmax bits increase
compared to the smallest possible update token size of an
unencrypted database.
The client’s storage is O(W (log |M| + log D)): an element
of M is stored for every keyword, with the counter c < D.
5.3 Security

The adaptive security of Σoφoς-B can be proven in the
Random Oracle Model, and relies on the one-wayness of the
TDP π and on the pseudo-randomness of F . We will only
give a sketch of the proof here, and postpone to Appendix A
the full proof.
Theorem 1
LΣ = (LSrch

(Adaptive security of Σoφoς-B). Deﬁne

Σ ,LUpdt

Σ ) as,

LSrch
Σ (w) = (sp(w), Hist(w))

LUpdt
Σ (add, w, ind) = ⊥.
Σoφoς-B is LΣ-adaptively-secure.

Hence, Σoφoς thwarts all the devastating adaptive ﬁle-injection
attacks of [ZKP16] – but not the non-adaptive ones.

The proof works by constructing successive indistinguish-
able hybrids, where H1 and H2 are modeled as random or-
acles, the ﬁrst hybrid being the real-world game, and the
laste the ideal-world game. We ﬁrst replace F by a random
function, i.e. we randomly pick the keys Kw.

In the second hybrid, we will replace all the strings gener-
ated by the random oracles in the Update protocol by ran-
domly chosen strings. The game will then program the ran-
dom oracles during the Search protocol so that the result
produced by the server matches the real results: H1 is set
to map the i-th search token for w to the update token pro-
duced randomly when w was updated for the i-th time. H2
is programmed in a similar manner to produce the right
keystream used to hide the ind values. We show that if the
ﬁrst and second hybrids are not indistinguishable, it means
that the adversary was able to invert the trapdoor permu-
tation without knowing the secret key.

Finally, we construct an hybrid that only needs to know
the repetition of search queries and the history to produce
search tokens indistinguishable from the previous hybrid.
As this hybrid only needs the output of the leakage function
to run, it means that we have a simulator that produces
indistinguishable transcripts from the real security game.
Note that LΣ uses Hist and not DB because the simulator
needs to know exactly when documents matching w were
inserted in the database in order to correctly simulate the
real protocol. In Appendix, Theorem 4 gives a more formal
statement, with an explicit distinguishing advantage.
5.4 Derived Constructions

Deletion Support. Although Σoφoς-B does not support
deletions, this is easy to ﬁx by ‘duplicating’ the data struc-
ture: we will use one instance of Σoφoς-B for insertions,
and the other for deletions. When searching w, the server
will compute and return the diﬀerence between the indices
matching w in both instances.

The leakage stays the same: we can separate the elements
of HistDB(w) in two sublists HistDBadd(w) and HistDBdel(w),
according to their operation (add or del), to build the leakage
functions of each instance of Σoφoς-B. The only diﬀerence
with the original scheme would be that it leaks the operation
op = add or del, but we can use the same map T for both
instances, which would hide the actual operation performed
during the update.

Batch Updates. We can also slightly modify the update
protocol to support batch updates on documents: when we
want to update document with index ind on the keywords
list w, we successively select keywords in w in random order,
and run the original Update protocol with input ind and the
selected keyword.

Again, the leakage function remains identical. We just
have to slightly update the security proof: when the sim-
ulator programs the random oracles on (Kw, STi), instead
of targeting exactly the only token produced at the i-th up-
date on w, it will pick a one of the random tokens produced
during the update that modiﬁed DB(w) for the i-th time.
5.5 Reducing Client-side Storage

We saw that the client’s storage is O(W (log |M|+log D)).

1148This can be a problem on constrained devices, especially
when M is big, which is the case for both RSA and Rabin’s
Squaring trapdoor permutations: M = Z∗
N , where N is, for
a reasonable level of security, a 2048 bits integer.
But there is a workaround to reduce storage to O(W ·
log D) at the expense of additional computations. The idea
is to pseudo-randomly generate ST0(w) from w (or a unique
identiﬁer iw ∈ N of w). When M = Z∗
N , this is quite easy to
do from a PRF G : N → {0, 1}λ+log N by taking ST0(w) ←
G(iw) mod N .

When STc(w) is needed, we recompute it from ST0(w).
However, this will be very computationally expensive if have
to iteratively compute π(−c)
SK c times. For-
tunately, this is not the case for common trapdoor permuta-
tions π, and in particular for RSA: if (p, q, d) and (N, e) are
respectively the secret and the public keys, y = RSA(−i)
SK (x)
can be computed as follows.

SK by iterating π−1

f ← di mod (p − 1)(q − 1)
y ← xf mod N

We can also use the Chinese remainders technique to im-
prove the performances of this computation.

Then, the client has only to store an identiﬁer iw for every
w, together with the counter c. When he needs to, he can
easily recompute the STc(w) from iw and c, with a small
complexity overhead (essentially the cost of a private-key
operation, when RSA is the chosen TDP). The client’s stor-
age reduces to O(W log D) asymptotically (as c < D).

We call this version Σoφoς (without the -B), and it is the
one that we implemented. The proof of security of Σoφoς-B
can easily be ported to Σoφoς:

Theorem 2. Σoφoς is LΣ-adaptively-secure.

5.6 Security against Malicious Adversaries

Theorem 2 states security against passive adversaries only.
However, Σoφoς can easily be turned in a veriﬁable SSE
scheme, as deﬁned by Bost et al. [BFP16]. We can do so by
storing a hash of DB(w) for every w on the client, and during
a search, the stored hash value is checked to match the hash
recomputed from the server’s results. To allow for easy in-
cremental updates, we can use a set hashing function to hash
DB(w), as explained in [BFP16]. The asymptotic complexity
of this veriﬁable version of Σoφoς – that we call Σoφoς-ε3
– and the client’s storage will increase to O(W (log D + λ))
From the collision resistance of the set hash function, we can
show that Σoφoς-ε is secure against malicious adversaries.

Theorem 3. Σoφoς-ε is LΣ-adaptively-secure against ma-

licious adversaries.
5.7 Comparison with Other Constructions

If we limit this scheme to only support modiﬁcation of full
documents (i.e. it is not allowed to add/delete a keyword to a
document already in the database, but we can add or delete
an entire document), our scheme has the same functional-
ities than the SPS scheme [SPS14], whose leakage function
is LSPS, with LSrch
SPS (w) = (sp(w), DB(w), HistDB(w)), and
LUpdt
SPS (op, ind, w) = (op, ind,|w|). LΣ and LSPS might look
incomparable, but actually we can construct LΣ from LSPS
rather easily: we just reconstruct Hist(w) from HistDB(w)

3ε stands for επαληθευω: I verify.

and the timestamps t generated at every update. We asso-
ciate these timestamps to the leaked information (op, ind,|w|),
and for each matching document in HistDB(w), we can re-
trieve the associated update operation, and when it hap-
pened, and hence recompute Hist(w).
This shows that Σoφoς is LSPS-adaptively-secure. We can
similarly show that SPS is LΣ-adaptively-secure by adapt-
ing the proof of [SPS14]. Hence, SPS and Σoφoς have exactly
the same security guarantees. However Σoφoς is much more
eﬃcient in terms of bandwith usage and update complexity.
Namely, SPS’s updates trigger O(log2 N ) work and O(log N )
bandwith usage per update, using standard, yet not trivial
de-amortization techniques. Σoφoς bandwith and computa-
tional overhead for an update is constant.

Also, SPS needs O(N a) client memory for 0 < a < 1 as
working storage to run the oblivious sort algorithm needed
during the updates, while Σoφoς stores O(W log D) on the
client – and we expect W (cid:28) N .

As presented in Table 1, Σoφoς has the same asymp-
totic complexity as the most eﬃcient dynamic SSE schemes.
Moreover, we saw in Section 4.3 that we cannot really hope
for something better in terms of features (space reclama-
tion) or storage locality, for a forward private scheme. This
justiﬁes the optimality claim made higher, in the abstract,
and in Σoφoς’ name itself.

6.

IMPLEMENTATION AND EXPERIMEN-
TAL RESULTS

We implemented Σoφoς in C/C++, using a bit more than
8000 lines of code. For the trapdoor permutation, we used
RSA. Our RSA implementation uses OpenSSL’s BigNum li-
brary. The PRF F and the keyed hash function H are instan-
tiated using HMAC, and we chose Blake2b as the underlying
hash function.

Aside from cryptographic components, gRPC [Goo16] was
chosen for the RPC machinery, and the map T were stored
using RocksDB [Fac16].

W is implemented as a memory-mapped disk-resident –
and hence persistent – hash table (with support of multiple
collisions in buckets, and an overﬂow stash to improve the
data structure’s load).

We ran our experiments on a desktop computer with a
single Intel Core i7 4790K 4.00GHz CPU (with 8 logical
cores), 16GB of RAM, a 250 GB Samsung 850 EVO SSD,
running on OS X.10. Our code is Open Source [Bos16].

Parameters. Cryptographic keys are 128 bits long for sym-
metric primitives, and we chose to use 2048 bits RSA keys,
with a public exponent ﬁxed to 3.

Our system can easily be scaled to support databases with
up to 264 keyword/document pairs, but to avoid unnecessary
overhead for our experiments using much smaller database,
we ﬁxed N ≤ 248, W ≤ 248, and the maximum matching
documents per keyword nmax ≤ 232 . We set µ, the length of
the update tokens, to 128 bits, leading to an incorrectness
probability of 2−32 for the maximum size database. Simi-
larly, on the client side, the keywords are hashed to obtain
the 128 bits identiﬁers iw (cf. Section 5.5).
6.1 Evaluation

We evaluated the performance of Σoφoς using 4 data sets
of increasing size and also the English Wikipedia. The char-

1149)
s

m

(

y
r
t
n
e

i

g
n
h
c
t
a
m

r
e
p

e
m

i
t

h
c
r
a
e
S

0.028

0.026

0.024

0.022

0.02

0.018

0.016

0.014

0.012

0.01

0.008

0.006

Database with 14E5 entries
Database with 14E6 entries
Database with 14E7 entries

10

100

1000

10000

100000

Number of matching documents

Figure 2 – Σoφoς search time per matched document (with standard deviation). Timings do not include the RPC.

Storage size

W
23,356
213,349
2,113,333
4,599,490

N
1.4E6
14E6
140E6
139E6

Client (load)
572 kB (0.91)
4.81 MB (1.00)
64.2 MB (0.64)
128 MB (0.91)

EDB
64.0 MB
512 MB
5.25 GB
5.25 GB

Table 2 – Evaluation databases size. The last database is
the English Wikipedia.

acteristics of the databases are given in Table 2, as well as
the size of the encrypted database, and the size of the client’s
state (i.e. the size of W).

We also report the load of the hash table storing W. It can
be optimized if we know in advance the number of distinct
keywords in the database. This is what we did for the ﬁrst
and second database (but not the third).

Search. Figure 2 presents our measurements for the search
algorithm, on the server side, without accounting for RPC
costs – we focus on the core of the algorithm. The tim-
ings given here are means of the elapsed search time per
found document, taken over between 1000 queries (for small
queries and large queries on large datasets) to 30 queries
(for large queries on small data sets). This allows us to ex-
hibit some real-world side eﬀects in our implementation. We
also give standard deviations for data sets of 14E6 and 14E7
keyword/document pairs.

The ﬁrst thing we can notice in the timings, is that the
larger the result set, the faster the search algorithm (again,
on a per matching document basis). We explain that by the
cost of multi-threading, and by the storage latency: even
if the RSA or hash function computations are fully paral-
lelized, adding an index to the result list is not, and access-

ing the disk induces some wait. Hence, at the beginning of
the search algorithm, RSA operations will not be fully inter-
leaved with disk accesses (like they are for a suﬃciently large
result set), we will pay for the latency induced by mutexes
and storage accesses. Also, in the case of small result sets,
some one-time costly operations (such as creating threads)
are not amortized.

Figure 3 includes the RPCs in the timings, shows that
they are far from being negligible, and also conﬁrms our
previous supposition: sending a matching document index
to the client via RPC cannot be done concurrently for a
given query, and creates a bottleneck if RPC, disk accesses
and RSA computations are not well interleaved.

)
s

m

(

y
r
t
n
e

g
n
i
h
c
t
a
m

r
e
p

e
m

i
t

h
c
r
a
e
S

0.04

0.035

0.03

0.025

0.02

0.015

0.01

0.005

With RPC
Without RPC

10

100

1000

10000

100000

Number of matching documents

Figure 3 – Σoφoς search time per matched document, in-
cluding RPC costs.

1150Update. We report an update throughput of around 4300
keyword/document pairs per second, for both large and small
datasets. This evaluation includes all costs (disk accesses,
RPC). For updates, the bottleneck is clearly the compu-
tation of the new search token used to derive the update
token. In particular, we pay for the fact that private key op-
erations are a lot more expensive than public key operations
(to a factor 30 on our computer).
6.2 Comparison with Existing Implementations

We can try to compare our implementation with the ones
in [CJJ+13], [CJJ+14], and [SPS14], using ﬁgures taken di-
rectly from the original papers. The comparison will be mostly
qualitative as the performance are despite that the evalua-
tion of these papers are measured in extremely diﬀerent en-
vironments. The implementations in [CJJ+13] and [CJJ+14]
run on 8 cores server blades connected to a high-end RAID-
0/RAID-5 HDD-based storage, while [SPS14] performance
is evaluated on an Amazon EC2 cr1.8xlarge instance, with
32 cores, entirely in RAM. Ours runs on a desktop computer,
with a medium-end SSD.

The ﬁrst thing we can notice, is that, despite the use
of costly asymmetric cryptographic primitives, we achieve
higher search throughput with a single basic SSD than the
authors of [CJJ+13] (1E7 matches per second for Σoφoς,
versus 2E4 for large results queries), who use an expensive
SAN system. Even using grouping techniques the perfor-
mances are comparable to ours (cf. [CJJ+14] whose search
algorithm needs approximately 150 ms for a 1E4 documents
match, our implementation only needs 1ms), justifying our
claim of Section 4.3, that locality in SSE is not necessary for
good performances.

This also quite invalidates the reﬂexion of Stefanovet al.
in [SPS14] about the relative cost of RAM vs. Disk: using
a single PCI Express SSD, we can achieve up to 430,000
random reads per seconds [Int] with very low latency, and
this can be further improved using several SSDs in RAID.
For Σoφoς, we claim that, once implemented on such pow-
erful systems (more CPU cores, higher end storage), search
performance will increase accordingly.

However, this cannot really be done for the updates as we
would like (computationally) weak clients to also perform
well when updating the database. This would require an
improvement of our scheme, so as to limit the number of
RSA public key operations the client has to perform during
updates. We leave this for future work.

Given that disk accesses is a bottleneck of our construc-
tion – as well as for the [CJJ+14] construction – it is quite
hard to compare Σoφoς with SPS whose encrypted database
is RAM-resident. We can only conjecture that, once imple-
mented on non-volatile storage, SPS throughput, both for
search and updates, will be comparable to ours. One could
however argue that, in presence of deletions, SPS’s sublinear
search algorithm will imply better performance than Σoφoς
linear one, but that would be the case only if the non-deleted
documents represent a very small fraction of the overall in-
serted documents: Σoφoς makes exactly 2aw − nw storage
accesses, while SPS makes at the very least log2 N
accesses
per non deleted matching document – this being a conserva-
tive lower bound. As storage accesses are the practical bot-
tleneck for both schemes, SPS will perform better only if less
than 0.64% of the inserted documents have not been deleted
if N > 225. Also, as SPS’s search uses binary searches, all

2

theses accesses cannot be fully parallelized unlike in Σoφoς.
Finally, another nice feature of our scheme is that Σoφoς’
server storage is 8 times smaller than the one in [SPS14],
and 2.5 times than the scheme of [CJJ+14], reducing the
ﬁnancial cost of SSE.
Acknowledgements
The author thanks Pierre-Alain Fouque and David Pointcheval
for their help on clarifying the proof of security, and Brice
Minaud and anonymous reviewers for helpful comments.

This work was supported in part by the European Re-
search Council under the European Community’s Seventh
Framework Programme (FP7/2007-2013 Grant Agreement
no. 339563 – CryptoCloud)
7. REFERENCES
[ANSS16] Asharov, G., Naor, M., Segev, G., and Shahaf,

I. Searchable symmetric encryption: Optimal
locality in linear space via two-dimensional
balanced allocations. In: 48th ACM STOC.
ACM Press (2016).
Bost, R., Fouque, P.A., and Pointcheval, D.
Veriﬁable dynamic symmetric searchable
encryption: Optimality and forward security.
Cryptology ePrint Archive, Report 2016/062
(2016). http://eprint.iacr.org/2016/062.
Bost, R. Implementation of Σoφoς (2016).
URL https://gitlab.com/sse/sophos.

[BFP16]

[Bos16]

[CGKO06] Curtmola, R., Garay, J.A., Kamara, S., and

Ostrovsky, R. Searchable symmetric
encryption: improved deﬁnitions and eﬃcient
constructions. In: A. Juels, R.N. Wright, and
S. Vimercati (eds.), ACM CCS 06, pp. 79–88.
ACM Press (Oct. / Nov. 2006).

[CGPR15] Cash, D., Grubbs, P., Perry, J., and

Ristenpart, T. Leakage-abuse attacks against
searchable encryption. In: I. Ray, N. Li, and
C. Kruegel: (eds.), ACM CCS 15, pp. 668–679.
ACM Press (Oct. 2015).
CipherCloud. Cloud data encryption. URL
http://www.ciphercloud.com/technologies/
encryption/.

[Cip]

[CJJ+13] Cash, D., Jarecki, S., Jutla, C.S., Krawczyk,

H., Rosu, M.C., and Steiner, M.
Highly-scalable searchable symmetric
encryption with support for boolean queries.
In: R. Canetti and J.A. Garay (eds.),
CRYPTO 2013, Part I, LNCS, vol. 8042, pp.
353–373. Springer, Heidelberg (Aug. 2013).
[CJJ+14] Cash, D., Jaeger, J., Jarecki, S., Jutla, C.S.,
Krawczyk, H., Rosu, M.C., and Steiner, M.
Dynamic searchable encryption in very-large
databases: Data structures and
implementation. In: NDSS 2014. The Internet
Society (Feb. 2014).
Chase, M. and Kamara, S. Structured
encryption and controlled disclosure. In:
M. Abe (ed.), ASIACRYPT 2010, LNCS, vol.
6477, pp. 577–594. Springer, Heidelberg (Dec.
2010).
Chang, Y.C. and Mitzenmacher, M. Privacy
preserving keyword searches on remote

[CM05]

[CK10]

1151encrypted data. In: J. Ioannidis, A. Keromytis,
and M. Yung (eds.), ACNS 05, LNCS, vol.
3531, pp. 442–455. Springer, Heidelberg (Jun.
2005).
Cash, D. and Tessaro, S. The locality of
searchable symmetric encryption. In: P.Q.
Nguyen and E. Oswald (eds.),
EUROCRYPT 2014, LNCS, vol. 8441, pp.
351–368. Springer, Heidelberg (May 2014).
Facebook, Inc. RocksDB: A Persistent
Key-Value Store for Flash and RAM Storage.
(June 2016). URL http://rocksdb.org.

[CT14]

[Fac16]

[GMP15] Garg, S., Mohassel, P., and Papamanthou, C.

[Int]

[Gol04]

[GO96]

[Goo16]

[IKK12]

TWORAM: Round-optimal oblivious RAM
with applications to searchable encryption.
Cryptology ePrint Archive, Report 2015/1010
(2015). http://eprint.iacr.org/2015/1010.
Goldreich, O. and Ostrovsky, R. Software
protection and simulation on oblivious RAMs.
Journal of the ACM (JACM),
vol. 43(3):(1996), pp. 431–473.
Goldreich, O. Foundations of cryptography.
Cambridge University Press (2004).
Google, Inc. gRPC: A high performance, open
source, general RPC framework that puts
mobile and HTTP/2 ﬁrst. (April 2016). URL
http://www.grpc.io/.
Islam, M.S., Kuzu, M., and Kantarcioglu, M.
Access pattern disclosure on searchable
encryption: Ramiﬁcation, attack and
mitigation. In: NDSS 2012. The Internet
Society (Feb. 2012).
Intel. Intel R(cid:13) SSD 750 Series: Performance
Unleashed. URL http://www.intel.com/
content/www/us/en/solid-state-drives/
solid-state-drives-750-series.html.
Jarecki, S., Jutla, C.S., Krawczyk, H., Rosu,
M.C., and Steiner, M. Outsourced symmetric
private information retrieval. In: A.R. Sadeghi,
V.D. Gligor, and M. Yung (eds.), ACM CCS
13, pp. 875–888. ACM Press (Nov. 2013).
Kurosawa, K. and Ohtaki, Y. UC-secure
searchable symmetric encryption. In: A.D.
Keromytis (ed.), FC 2012, LNCS, vol. 7397,
pp. 285–298. Springer, Heidelberg (Feb. / Mar.
2012).
Kamara, S. and Papamanthou, C. Parallel and
dynamic searchable symmetric encryption. In:
A.R. Sadeghi (ed.), FC 2013, LNCS, vol. 7859,
pp. 258–274. Springer, Heidelberg (Apr. 2013).
[KPR12] Kamara, S., Papamanthou, C., and Roeder, T.
Dynamic searchable symmetric encryption. In:
T. Yu, G. Danezis, and V.D. Gligor (eds.),
ACM CCS 12, pp. 965–976. ACM Press (Oct.
2012).

[JJK+13]

[KO12]

[KP13]

[MKNK15] Meng, X., Kamara, S., Nissim, K., and Kollios,
G. GRECS: Graph encryption for approximate
shortest distance queries. In: I. Ray, N. Li, and
C. Kruegel: (eds.), ACM CCS 15, pp. 504–517.
ACM Press (Oct. 2015).

[MMBC15] Moataz, T., Mayberry, T., Blass, E.O., and

Chan, A.H. Resizable tree-based oblivious

[Nav15]

RAM. In: R. B¨ohme and T. Okamoto (eds.),
FC 2015, LNCS, vol. 8975, pp. 147–167.
Springer, Heidelberg (Jan. 2015).
Naveed, M. The fallacy of composition of
oblivious RAM and searchable encryption.
Cryptology ePrint Archive, Report 2015/668
(2015). http://eprint.iacr.org/2015/668.

[PKV+14] Pappas, V., Krell, F., Vo, B., Kolesnikov, V.,

[sky]

[SPS14]

[SWP00]

[ZKP16]

Malkin, T., Choi, S.G., George, W., Keromytis,
A.D., and Bellovin, S. Blind seer: A scalable
private DBMS. In: 2014 IEEE Symposium on
Security and Privacy, pp. 359–374. IEEE
Computer Society Press (May 2014).
skyhigh. Cloud security and enablement. URL
https://www.skyhighnetworks.com.
Stefanov, E., Papamanthou, C., and Shi, E.
Practical dynamic searchable encryption with
small leakage. In: NDSS 2014. The Internet
Society (Feb. 2014).
Song, D.X., Wagner, D., and Perrig, A.
Practical techniques for searches on encrypted
data. In: 2000 IEEE Symposium on Security
and Privacy, pp. 44–55. IEEE Computer
Society Press (May 2000).
Zhang, Y., Katz, J., and Papamanthou, C. All
your queries are belong to us: The power of
ﬁle-injection attacks on searchable encryption.
Cryptology ePrint Archive, Report 2016/172
(2016). http://eprint.iacr.org/2016/172.

APPENDIX
A. PROOF OF Σoφoς CONFIDENTIALITY
Let us ﬁrst restate precisely the security claim for Σoφoς.

Theorem 4. Let π be a one-way trapdoor permutation,
F a PRF, and H1 and H2 to hash functions modeled as a
random oracle outputting respectively µ and λ bits. Deﬁne
LΣ = (LSrch

Σ ,LUpdt

Σ ) as

LSrch
Σ (w) = (sp(w), Hist(w))

LUpdt
Σ (add, w, ind) = ⊥.

Then Σoφoς-B is LΣ-adaptively-secure.

Proof. We are going to derive several games from the

real world game SSERealΣoφoς

(λ).

A

Game G0. G0 is exactly the real world SSE security game
SSEReal.

P[SSERealΣoφoς

A

(λ) = 1] = P[G0 = 1]

Game G1. Instead of calling F when generating Kw, G1
picks a new random key when it is confronted to a new w,
and stores it in a table Key so it can be reused next time w
is queried. If an adversary is able to distinguish between G0
and G1, we can then build a reduction able to distinguish be-
tween F and a truly random function. More formally, there
exists an eﬃcient adversary B1 such that
P[G0 = 1] − P[G1 = 1] ≤ Advprf

(λ).

F,B1

1152Algorithm 2 Games G2 and (cid:102)G2 Boxed code is included in
(cid:102)G2 only.

Setup()
1: (SK, PK) ← KeyGen(1λ)
2: W, T ← empty map
3: bad ← false
4: return ((T, PK), (KS, SK), W)

Client:

Search(w, σ; EDB)
1: Kw ← Key[w]
2: (ST0, . . . , STc, c) ← W[w]
3: if (ST0, . . . , STc, c) = ⊥
5: (ind0, . . . , indc) ← HistDB(w)

return ∅

4:

order of updates

H1(Kw, STi) ← UT[w, i]

6: for i = 0 to c do
7:
8: end for
9: Send (Kw, STc, c) to the server.

Server:

(cid:46) Ordered from the

10: for i = c to 0 do
11:
12:

U Ti ← H1(Kw, STi)
e ← T[U Ti]
ind ← e ⊕ H2(Kw, STi)
STi−1 ← πPK(STi)

13:
14: Output each ind
15:
16: end for
Update(add, w, ind, σ; EDB)
1: Kw ← Key[w]
2: (ST0, . . . , STc, c) ← W[w]
3: if (ST0, . . . , STc, c) = ⊥ then

Client:

$← M, c ← −1

ST0
STc+1 ← π−1

4:
5: else
6:
7: end if
8: W[w] ← (ST0, . . . , STc+1, c + 1)
9: U Tc+1 ← {0, 1}µ
10: if H1(Kw, STc+1) (cid:54)= ⊥ then

SK (STc)

bad ← true, U Tc+1 ← H1(Kw, STc+1)

Server:

11:
12: end if
13: UT[w, c + 1] ← U Tc+1
14: d ← ind ⊕ H2(Kw, STc+1)
15: Send (U Tc+1, d) to the server.
16: T[U Tc+1] ← e
H1(k, st)
1: v ← H1(k, st)
2: if v = ⊥ then
v $← {0, 1}λ
if ∃w, c s.t st = STc ∈ W[w] then

3:
4:

5:

bad ← true, v ← UT[w, c]

end if
H1(k, st) ← v

6:
7:
8: end if
9: return v

Game G2. In G2, in the Update protocol, instead of call-
ing H1 to generate the update tokens U T , we pick random

strings. Then, during the Search protocol, the random oracle
H1 is programmed so that H1(Kw, STc(w)) = U Tc(w).

an intermediate game (cid:102)G2, by including the additional boxed

Algorithm 2 formally describes G2, and also introduces

instead of recomputing all of them in Search.

the same input by Search’ line 7. Instead of immediately gen-
erating the U T derived from the c-th ST for keyword w from

already appear in H1’s transcript, or, if this is already the
case, sets U Tc+1 to the already chosen value H1[Kw, U Tc+1].

lines. In the pseudo-code, we explicit the calls to the random
oracle H1, and keep track of the transcripts via the table
H1. In particular, we can see that we explicitly program the
RO during Search at line 7. Note that we use the following
convention for the table Key: if an entry is accessed for the
ﬁrst time, it is ﬁrst randomly chosen and then returned. Also

G2 and(cid:102)G2 make some bookkeeping of the search tokens STc,
The point of(cid:102)G2 is to ensure consistency of H1’s transcript:
in (cid:102)G2, H1 is never programmed to two diﬀerent values for
H1, (cid:102)G2 randomly either choses them if (Kw, STc+1) does not
Then,(cid:102)G2 lazily programs the RO when needed by the Search
Because of this, H1’s outputs in (cid:102)G2 and G1 are perfectly
The games (cid:102)G2 and G2 are also perfectly identical unless
between (cid:102)G2 and G2:
P[(cid:102)G2 = 1] − P[G2 = 1] ≤ P[bad is set to true in (cid:102)G2].

protocol (line 7) or by an adversary’s query (line 5 of H1),
so that it’s outputs are consistent with the chosen values of
the U T ’s.

the ﬂag bad is set to true, and we can apply the identical-
until-bad technique to bound the distinguishing advantage

P[(cid:102)G2 = 1] = P[G1 = 1].

indistinguishable, and so are the games:

Intuitively, we can see that, if bad is set to true, we can
break the one-wayness of the TDP. More formally, we are
going to construct a reduction B2 from a distinguisher A
inserting N keyword/document pairs in the database, using
a technique similar to the Schnorr’s signatures proofs. We
note maxw∈W nw = nmax = poly(λ) the maximum number
of documents matching a keyword. B2 will take as input a
public key PK and a challenge y ∈ M, and will ouput x such
that πPK(x) = y.
As for Schnorr’s signatures proofs, B2 ﬁrst guesses the
pair (w∗, c∗) for which bad will be set to true for the ﬁrst
time, by querying H1 on (Kw∗ , STc∗ ) (i.e. by pre-computing
UT[w∗, c∗]), among the N possible pairs. For all keyword w ∈
W \ {w∗}, B2 pre-computes STi(w) as follows:

STnmax (w) $← M
STi(w) ← πPK(STi+1(w)) for 0 ≤ i < nmax

Similarly, for w∗, B2 generates the search tokens from the
challenge y:

∗

) ← y

STc∗−1(w
STi(w

∗

) ← πPK(STi+1(w

∗

)) for 0 ≤ i < c

∗

It is essential to see that the distribution of the search tokens
remains unchanged from game G2. So, to return a pre-image
of y, the reduction B2 will ﬁnd the value x by evaluating
πPK(r) for all (Kw∗ , r) in the RO’s transcript and check if
πPK(r) = y. Hence, for a ﬁxed pair (w∗, c∗), if G2 sets bad

1153to true because of an adversary’s query on (Kw∗ , STc∗ ), B2
is able to invert π without the secret key:
P [bad is set to true by forging UT[w
(λ).
Guessing the pair (w∗, c∗) implies a N loss in the advan-

]] = AdvOWπ,B2

, c

∗

∗

tage of the reduction, and

P[G1 = 1] − P[G2 = 1] = P[(cid:102)G2 = 1] − P[G2 = 1]

≤ N · AdvOWπ,B2

(λ).

Game G3. Game G3 does exactly what game G2 did for
H1, but for H2. The exact same argument can be reused,
giving that there is an adversary B3 such that

P[G2 = 1] − P[G3 = 1] ≤ N · AdvOWπ,B3

(λ).

Note that we can consider that B2 = B3 without loss of
generality: we could have started with H2 instead of H1 and
the reduction would have been the same.

Game G4. In game G4, as deﬁned by Algorithm 3, the game
keeps track of the randomly generated string U T and d dif-
ferently than before, but the transcript output by Search
and Update are stricly identical, and the random oracles are
also programmed identically. In Algorithm 3, we removed
the now useless code for the H1 oracle. Also note that we
got rid of the server’s part is the protocols: these are single
roundtrip protocols and the removed lines do not inﬂuence
the client’s transcript.

We still have to show that G3 and G4 are indistinguish-
able. For Update, this is immediate as we are already out-

Algorithm 3 Game G4.
Setup()
1: (SK, PK) ← KeyGen(1λ)
2: W, T ← empty map
3: u ← 0
4: Updates ← empty map
5: return ((T, PK), (KS, SK), W)

Client:

Search(w, σ; EDB)
1: Kw ← Key[w]
2: ST0 ← W[w]
3: [(u0, ind0), . . . , (uc, indc)] ← Updates[w]
4: if c = 0
5:
6: for i = 0 to c do
7:
8:
9:
10: end for
11: Send (Kw, STc, c) to the server.
Update(add, w, ind, σ; EDB)

return ∅
Program H1 s.t. H1(Kw, STi) ← UT[ui]
Program H2 s.t. H2(Kw, STi) ← e[ui] ⊕ indi
STi+1 ← π−1

SK (STi)

Client:

1: Append (u, ind) to Updates[w]
2: UT[u] $← {0, 1}µ
3: e[u] $← {0, 1}λ
4: Send (UT[u], e[u]) to the server.
5: u ← u + 1

putting fresh random strings for each update in G3. In Search,
G4 generates the search token from ST0 by iterating π−1
SK
instead of using an already computed and stored token. As
for Key, if an entry of W if an entry is accessed for the ﬁrst
time, the game randomly picks it in M.

Finally, instead of directly mapping the pairs (w, i) (a key-
word and the i-th update to this keyword) to the values
picked for UT and e, we use the intermediate table Updates
which implicitly maps (w, i) to the global update count.
Hence,

P[G3 = 1] − P[G4 = 1] = 0.

The Simulator. We can – almost straightforwardly – cut
the code of game G4 in two independent parts: the leak-
age and the simulator. The simulator is described in Algo-
rithm 4, and the leakage function is LΣ. G4 and SSEIdealS,LΣ
are identical games, the only diﬀerence being that, instead of
the keyword w, S uses the counter w = min sp(w) uniquely
mapped from w using the leakage function. Hence,

P[G4 = 1] − P[SSEIdealΣoφoς
A,S,LΣ

(λ) = 1] = 0.

Algorithm 4 Simulator S.
S.Setup()
1: (SK, PK) ← KeyGen(1λ)
2: W, T ← empty map
3: u ← 0
4: return ((T, PK), (KS, SK), W)

Client:

S.Search(sp(w), Hist(w))
1: w ← min sp(x)
2: Kw ← Key[w]
3: ST0 ← W[w]
4: Parse Hist(w) as [(u0, add, ind0), . . . , (uc, add, indc)]
5: if c = 0
6:
7: for i = 0 to c do
8:

return ∅
Program H1 s.t. H1(Kw, STi) ← UT[ui]
Program H2 s.t. H2(Kw, STi) ← e[ui] ⊕ indi
STi+1 ← π−1

SK (STi)

9:
10:
11: end for
12: Send (Kw, STc) to the server.
S.Update()
Client:
1: UT[u] $← {0, 1}µ
2: e[u] $← {0, 1}λ
3: Send (UT[u], e[u]) to the server.
4: u ← u + 1

Conclusion. By combining all the contributions from all
the games, there exists 2 adversaries B1 and B2 such that

P[SSERealΣoφoς

A

(λ) =1] − P[SSEIdealΣoφoς
A,S,LΣ

(λ) = 1]

(λ).
We conclude by stating that π is a one-way function, and
that F is a PRF.

F,B1

(λ) + 2N · AdvOWπ,B2

≤ Advprf

1154