Securing SSL Certiﬁcate Veriﬁcation through Dynamic

Linking

Adam Bates

CISE Dept.

University of Florida

Gainesville, FL

adammbates@uﬂ.edu

Joe Pletcher

CIS Dept.

University of Oregon

Eugene, OR

pletcher@cs.uoregon.edu

Braden Hollembaek

iSEC Partners
Seattle, WA

bhollembaek@isecpartners.com

Dave Tian
CISE Dept.

University of Florida

Gainesville, FL
tian@cise.uﬂ.edu

Tyler Nichols

CIS Dept.

University of Oregon

Eugene, OR

tnichols@cs.uoregon.edu

Kevin R. B. Butler

CISE Dept.

University of Florida

Gainesville, FL
butler@uﬂ.edu

ABSTRACT
Recent discoveries of widespread vulnerabilities in the SSL-
/TLS protocol stack, particular with regard to the veriﬁca-
tion of server certiﬁcates, has left the security of the In-
ternet’s communications in doubt. Newly proposed SSL
trust enhancements address many of these vulnerabilities,
but are slow to be deployed and do not solve the prob-
lem of securing existing software.
In this work, we pro-
vide new mechanisms that oﬀer immediate solutions to ad-
dressing vulnerabilities in legacy code. We introduce Cert-
Shim, a lightweight retroﬁt to SSL implementations that
protects against SSL vulnerabilities,
including those sur-
veyed by Georgiev et. al.
[19], in a manner that is trans-
parent to the application. We demonstrate CertShim’s ex-
tensibility by adapting it to work with Convergence, DANE,
and Client-Based Key Pinning. CertShim imposes just 20
ms overhead for an SSL veriﬁcation call, and hooks the SSL
dependencies of 94% of Ubuntu’s most popular packages
with no changes necessary to existing applications. This
work signiﬁcantly increases system-wide security of SSL com-
munications in non-browser software, while simultaneously
reducing the barriers to evaluating and adopting the myriad
alternative proposals to the certiﬁcate authority system.

Categories and Subject Descriptors
C.2.0.
eral — Security and protection

[Computer-Communication Networks]: Gen-

Keywords
SSL, TLS, HTTPS, public-key certiﬁcates

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660338.

1.

INTRODUCTION

Internet applications have relied for years on the SSL/TLS
libraries for secure end-to-end channels, but a growing body
of literature points to systemic lapses in security procedure
that renders our communications insecure. The heart of
these problems lies with the inability for clients to accurately
authenticate the server when presented with its public-key
certiﬁcate. Certiﬁcate validation has been shown to be in-
correct at all layers of the SSL stack, from improper certiﬁ-
cate handling in libraries [7, 29], to confusion and abuse of
SSL APIs [19, 43], to applications that are broken by design
so that they are easier to use [17]. Moreover, high pro-
ﬁle compromises of prominent Certiﬁcate Authorities (CAs)
have eroded the very foundations of the SSL trust model
[12, 18, 32]. Any one of these lapses gives rise to the threat
of a Man-in-the-Middle (MitM) attack, in which an attacker
is able to intercept and read supposedly-secure SSL traﬃc
in transit to or from a target website.

While a variety of forward-thinking solutions have been
proposed in the literature [10], less attention has been paid
to immediate countermeasures, and ways in which we can
ﬁx the vast amount of legacy software that is vulnerable and
inexorably linked to the CA model. Detecting and report-
ing these vulnerabilities is an inadequate solution; studies of
Android SSL usage have found that up to 76% of vulnera-
bilities persist for over a year [43], even once the developers
have been notiﬁed of conﬁrmed vulnerabilities [17]. In the
presence of aloof and unavailable developers, we must pursue
alternate means of securing our Internet communications.

In this paper, we consider a system-wide approach to
securing negligent SSL code in non-browser software that
simultaneously facilitates the immediate use of CA alter-
natives and other SSL trust enhancements. We present
CertShim, a lightweight retroﬁt to existing popular SSL im-
plementations (OpenSSL, GnuTLS, and partial support for
JSSE) that acts as a shim1 into the validation procedure in
dynamically linked applications. CertShim provides appli-
cation and domain speciﬁc handlers that force correct cer-

1A shim is a library that transparently intercepts an API
and changes its parameters or operations.

394tiﬁcate validation on previously insecure applications. We
demonstrate its practicality by incorporating a variety of
veriﬁcation techniques including traditional CA validation,
Convergence [30], DANE [23], and client-side key pinning
[14, 31, 37, 42], some of which were previously only avail-
able as experimental browser plug-ins. CertShim reduces
the barrier to adopting these systems by making them im-
mediate candidates for system-wide deployment.

While recent studies have made recommendations for the
general improvement of the SSL ecosystem, few have intro-
duced system-wide defenses to SSL vulnerabilities in legacy
software. Fahl et al. modify the Android API to restrict
SSL misuse [17], while Conti et al.
introduce MYTHIS,
a benign MitM proxy for Android that is able to defend
against rogue access point attacks [11]. In contrast to these
works, our platform-wide defense does not require a manu-
facturer update, or even administrator privileges, to be put
to use. We also deliver on the promise of pluggable certiﬁ-
cate veriﬁcation that is left to future work by Fahl et al.,
and go a step further by showing that additional security
assurances can be attained by layering multiple veriﬁcation
modules. CertShim works in desktop and server environ-
ments, which are considerably more complex than Android,
as various SSL implementations need be considered. Fur-
thermore, the solutions for Android experience compatibil-
ity issues with some programs; in contrast, we present a
policy engine that provides application- and domain-speciﬁc
certiﬁcate handling.

We make the following contributions:
• Enforce Safe Defaults on SSL: CertShim hooks
calls to SSL APIs in order to enforce hostname valida-
tion and certiﬁcate validation. As this behavior would
otherwise break applications that pin certiﬁcates or
connect to domains that use self-signed certiﬁcates, we
present a policy engine that enforces safe defaults but
provides unique handlers based on the application and
destination domain.

• Enable CA Alternatives: Existing open source ini-
tiatives may be slow to adopt alternative SSL trust
models, may intentionally choose to stay with the sta-
tus quo of certiﬁcate authorities, or may simply have
gone defunct. CertShim provides modular retroﬁts
that allow existing applications to use modern CA al-
ternatives. CertShim provides a means of taking the
consensus of multiple forms of certiﬁcate validation,
which to our knowledge is the ﬁrst of its kind in the
literature, allowing even stronger guarantees through
ensemble validation.

• Performance Analysis of CertShim: We survey
Ubuntu’s 10,000 most popular packages and ﬁnd that
CertShim supports 94% of the 390 packages that were
found to contain SSL usage. Our benchmarks show
that the use of CertShim adds as little as 20 ms to
an SSL lookup under realistic conditions. We also
perform manual testing to determine that CertShim
transparently secures all of the major SSL library mis-
conﬁgurations and 8 of the 9 data-transport library
vulnerabilities identiﬁed by Georgiev et al.[19].

The remainder of this work is organized as follows: Sec-
tion 2 provides background on SSL, CAs, and the prob-
lems associated with certiﬁcate validation. In Section 3 we

present the design and implementation of CertShim, ana-
lyze its features in Section 4, and evaluate its performance
as well as coverage of real world SSL usage in Section 5.
Limitations of our approach and future work are discussed
in Section 6, and related work is summarized in Section 7.
In Section 8 we conclude.

2. BACKGROUND

The SSL/TLS protocol families are largely responsible for
securing the Internet’s web traﬃc. The original SSL (Secure
Socket Layers) protocols were introduced by Netscape in
1995 to provide conﬁdentiality, integrity, and identity to net-
work communications [22]. While the foundations of SSL’s
solutions to conﬁdentiality and integrity have withstood the
test of time, reliably establishing destination identity in SSL
connections has proven to be a surprisingly diﬃcult prob-
lem. Without identity assurances, users are vulnerable to
the threat of impersonation or Man-in-the-Middle (MitM)
attacks, in which an attacker is able to intercept and read
supposedly-secure SSL traﬃc bound to or from a target
website. We still rely on Netscape’s original solution, the
Certiﬁcate Authority (CA) public key infrastructure, which
requires that domains register with one or more CAs in ex-
change for a signed X.509 certiﬁcate. A client can then
authenticate the server validating its certiﬁcate by using the
issuing CA’s public key; obtaining this public key is a trans-
parent process to the client, as it is likely pre-installed into
their operating system or web browser.

Development Vulnerabilities. Good SSL code, par-
ticularly with regards to certiﬁcate veriﬁcation, is very dif-
ﬁcult to correctly implement. Numerous MitM vulnerabili-
ties have been discovered in certiﬁcate chain validation rou-
tines, such as null preﬁx attacks on Pascal strings [28, 29].
Georgiev et al’s survey of SSL connection authentication ex-
posed pervasive misunderstanding of certiﬁcate veriﬁcation
in SSL API’s in non-browser software, and also drew at-
tention to many popular SSL libraries that are broken by
design [19]. Fahl et al.
interviewed developers to ﬁnd that
apps were often intentionally broken so as to allow for eas-
ier development, or to support self-signed certiﬁcates [17].
Even worse, the tomes of vulnerable SSL code that exist
today that are unlikely to ever be patched. Studies of SSL
vulnerabilities in Android apps have found that up to 76% of
vulnerabilities persist for over a year [43], even once the de-
velopers have been notiﬁed of conﬁrmed vulnerabilities [17].
Even more surprisingly, Brubaker et al. perform automated
testing to uncover dramatic inconsistencies in the validation
routines of the major SSL libraries, some of which gave rise
to exploitable vulnerabilities [7]. Given that not even SSL
library development teams can agree on best practices for
certiﬁcate handling, the situation today is certainly grim.

Trust Vulnerabilities. Orthogonal to these implemen-
tation issues are a number of fundamental and systemic limi-
tations in the CA trust model. CAs are under no obligation
to perform due diligence before issuing a certiﬁcate, and
in fact this lack of veriﬁcation is pervasive in the certiﬁ-
cate ecosystem [45]. This, combined with the myriad recent
serious, high-proﬁle compromises and blunders (e.g., Co-
modo[32], Diginotar[18], TURKTRUST[12]), makes it fair
to ask whether CAs are suﬃciently incentivized to preserve
the security of themselves or their customers. These lapses
are at times met without any serious repercussions [9, 30],
and there is even evidence that CAs work directly against

395customer security by oﬀering wiretap services [21, 39, 41,
42]. These problems are serious enough, but they are ex-
acerbated by a lack of scoping; any CA can verify any cer-
tiﬁcate, meaning that conscientious businesses that certify
with reputable CAs are just as at risk, and software ven-
dors often include potentially untrustworthy CAs in order
to ensure compatibility with Internet services [15].
2.1 CA Alternatives

Proposed CA enhancements and alternatives were sur-
veyed by Clark and van Oorschot [10], who identify families
of proposals based on their underlying fundamental princi-
ples of operation. These alternatives vary widely in terms
of both their advantages and limitations, reﬂecting diﬀer-
ences of opinion on the fundamental problems with the CA
trust model. This work makes use of an important subset
of these security enhancements that require no server side
changes in order to be adopted; primitives such as multipath
probing [3, 30, 47], client-based key pinning [14, 31, 37, 42],
and certiﬁcate revocation lists [13, 26, 33, 38] are eligible for
immediate deployment by individual users, providing tangi-
ble security enhancements to today’s Internet threats. Due
to its relative popularity, we also consider the DANE DNS-
based key pinning system, a trust enhancement that embeds
X.509 certiﬁcates in DNSSEC records [23, 27]. However,
none of these trust enhancements has enjoyed widespread
deployment, in part due to the vast amount of non-browser
software that would need to be modiﬁed in order to enable
their system-wide use.

Key pinning, Convergence, and DANE are exemplar trust
enhancements that we make use of in this work. However,
each suﬀers from inherent design or trust limitations that
impact their applicability in certain scenarios. For exam-
ple, client-based key pinning cannot determine whether a
change in a server’s certiﬁcate is malicious or benign. Re-
cent work by Amann et al. [2, 4] shows that routine changes
to SSL trust relationships are often indistinguishable from
attacks, making this a noteworthy limitation. In contrast,
Convergence can oﬀer insight into the cause of the unex-
pected certiﬁcate by detecting whether the certiﬁcate has
changed globally, or just locally. However, if the new certiﬁ-
cate is the result of a MitM attack near the server, the Con-
vergence notaries will conclude that the change is benign,
resulting in a dangerous false negative. DANE, by checking
the target domain’s TLSA record, could oﬀer a deﬁnitive
answer to whether the change was benign, but DANE is
being incrementally deployed and further bloats the tradi-
tional CA trust model to include the DNS architecture. In
this work, we show that by querying multiple certiﬁcate val-
idation systems it is possible to retain the beneﬁts of each
while mitigating each system’s limitations.

3. DESIGN
3.1 Threat Model & Assumptions

Our system is designed with consideration for an adver-
sary in the network that attempts to launch a MitM attack
against SSL communications; this attack could be launched
from a rogue wireless access point to which the client is con-
necting, or from elsewhere on the Internet, such as some-
where on the network paths between the client and server.
CertShim works under multiple trust models, and we there-
fore consider adversaries of varying strengths. A weak at-

tacker might only possess an untrusted CA certiﬁcate, but
a stronger attacker might possess a valid certiﬁcate from a
trusted CA, or even control parts of the Internet architec-
ture (e.g., network paths, trusted CAs, DNS resolvers). We
discuss the security of various veriﬁcation modules against
these adversaries in Section 3.4. When client-based key pin-
ning is considered, we assume that the Client has had one
opportunity to correctly authenticate the server in the past,
which is necessary for use in Trust on First Use (TOFU)
authentication [5].

We seek to secure client-side non-browser applications that
are benign but potentially defective in their use of SSL. In
particularly, we wish to protect against insecure use of SSL
libraries. Except where otherwise noted, we do not consider
incorrectness within the underlying libraries themselves [7,
20], assuming instead that they are correctly implemented.
This work is motivated by the fact that developers often fail
to ﬁx vulnerable code, so we assume that the applications
will not take active countermeasures to bypass our mecha-
nism. CertShim interposes on popular known SSL libraries;
we do not consider applications that use their own SSL im-
plementations. Doing so would increase the cost and com-
plexity of software development, and in evaluation we found
no evidence that this was a widespread practice. However,
we do anticipate that applications can use many layers of
abstraction/misdirection in calling an SSL API, such as a
cURL wrapper for a scripting language.

3.2 System Goals

We set out to design a mechanism that provided the fol-

lowing system-wide properties:

Override Insecure SSL Usage. Force safe defaults for
certiﬁcate handling (i.e., validation of hostnames and certiﬁ-
cate chains) on all SSL connections, regardless of whether
or not the application makes any attempt to do so. This
encompasses applications that misconﬁgure the SSL API,
applications that use insecure SSL wrappers, and applica-
tions that are broken by design.

Enable SSL Trust Enhancements. In addition to tra-
ditional veriﬁcation, our system should be conﬁgurable to
enable the use of CA alternatives and enhancements. CA
Alternatives are often incapable of correctly authenticating
all Internet domains due to design limitations or incremental
deployment, so we also wish to provide a means of querying
multiple veriﬁcation methods and reconciling their results.
Maximize Compatibility. Due to the great diversity of
SSL usage, existing software will use SSL APIs in ways that
we cannot anticipate, some of which may be perfectly valid
and secure. These constraints could be application-speciﬁc,
such as using a pinned certiﬁcate, or trusting a corporate
CA. Others could be domain-speciﬁc, such as a server on
an unreachable private network, or a server that has not
published a TLSA record [23]. Our mechanism must be able
to coexist with these applications without breaking them.

Maximize Coverage. As applications could conceivably
re-implement SSL from the RFCs, it is impossible to enu-
merate all of the possible SSL libraries. However, we wish to
maximize the coverage of our defensive layer by supporting
the libraries that are most commonly used by SSL applica-
tions in practice.

396// D e t e r m i n e SSL i n i t i a l i z a t i o n type
type = r e s o l v e _ c t x _ t y p e ( ctx )

// Obtain the domain and port
name = l o o k u p _ n a m e ( ctx )
port = l o o k u p _ p o r t ( ctx )

1 int S S L _ g e t _ v e r i f y _ r e s u l t ( SSL * ctx )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

// Call a v a l i d a t i o n Fu n c ti o n
status = 0
if ( C O N F I G _ C E R T _ P I N N I N G )

// Grab the c e r t i f i c a t e f i n g e r p r i n t
sha = e x t r a c t _ c t x _ f i n g e r p r i n t ( ctx )

status += k e y p i n _ v e r i f y ( name , port , sha )

if ( C O N F I G _ C E R T _ A U T H O R I T Y )

status += c a _ v e r if y ( name , port , sha )

if ( C O N F I G _ C O N V E R G E N C E )

status +=

20
21
22
23
24
25
26
27

c o n v e r g e n c e _ v e r i f y ( name , port , sha )

if ( C O N F I G _ D A N E )

status += d a n e _ v e r i f y ( name , port , sha )

// Check the results
if ( resolve ( status ) == OK )

return X 5 0 9 _ V_ O K

else

return X 5 0 9 _ E R R _ I N V A L I D _ C A

shim.c

Figure 2: Pseudocode for CertShim’s dynamically loaded
SSL_get_verify_result function.

values of the instrumented function are consistent with the
original library API. Pseudocode for CertShim’s version of
ssl_get_verify_result() can be found in Figure 2.
In
lines 2-7, the canonical name and port of the certiﬁcate are
recovered.
In lines 9-10, the certiﬁcate ﬁngerprint (SHA1
hash) is extracted from the SSL context. Certiﬁcate valida-
tion functions are called in lines 12-19. Lines 21-25 return
the standard X509 accept or reject values based on whether
or not the certiﬁcate was approved.

Handshake Functions. Hooking the veriﬁcation functions
alone is insuﬃcient to force proper veriﬁcation in vulnera-
ble applications due to the fact that they often go unused
by developers [19]. Therefore, CertShim also targets the
main connection functions of SSL libraries, which represent a
choke point at which we can force certiﬁcate veriﬁcation. We
instrument OpenSSL’s ssl_connect() and ssl_do_hand-
shake() functions and GnuTLS’s gnutls_do_handshake()
function. CertShim ﬁrst calls the original functions from
each respective library, returning its error code if the con-
nection failed on its own (e.g., due to network connectivity
failure). If the call is successful, however, CertShim calls
the veriﬁcation module as described above.
If veriﬁcation
fails, CertShim generates an error that emulates a connec-
tion failure, essentially short-circuiting the SSL connection
and forcing the application to recover (shown in Figure 3).
This system behavior is likely to cause unexpected behav-
ior in some applications; however, as we show in Section 3.4
the behavior of the veriﬁcation module can be conﬁgured to
prevent application breakage.

CertShim’s inclusion of both handshake and veriﬁcation
functions is to ensure that vulnerable SSL code is hooked.
This is necessary because numerous studies have shown that

Figure 1: CertShim interoperates with various SSL li-
braries, replacing their certiﬁcate veriﬁcation functions with
those from proposed CA alternatives.

Function
connect
do handshake
get verify result
handshake
certiﬁcate verify peers2
certiﬁcate verify peers3
CheckIdentity
CheckIdentity
SetEndpointIdentifAlg
connect
gethostbyname
getaddrinfo

Purpose
Initial SSL handshake
Renegotiate handshake
Check veriﬁcation result
SSL handshake
Verify certiﬁcate (deprec.)
Verify certiﬁcate
Verify hostname
Verify hostname
Verify hostname

Location
libssl1.0.0
libssl1.0.0
libssl1.0.0
libgnutls26
libgnutls26
libgnutls26
JDK6
JDK7
JDK7
System call Track hostname, port
System call Track hostname, port
System call Track hostname, port

Table 1: Functions that CertShim overrides/hooks. Multi-
ple hooks are required because libraries have multiple entry
points that trigger certiﬁcate veriﬁcation.

3.3 CertShim

Our system, CertShim, is a dynamically linked shared ob-
ject that performs binary instrumentation in order to layer
additional security onto popular SSL implementations, Open-
SSL and GnuTLS, and includes an additional mechanism
that instruments JSSE’s SSLSocketFactory. Shown in Fig-
ure 1, CertShim works primarily through use of the Linux
dynamic linker’s LD_PRELOAD environment variable. Under
normal circumstances, a function such as ssl_connect()
would resolve to code in libssl.so. However, when Cert-
Shim is enabled, the linker ﬁrst looks at our shared object
before moving to the standard include paths, allowing us
to redeﬁne the behavior of the library’s veriﬁcation function
without modifying speciﬁc executables, as shown in Figure
3. CertShim performs additional certiﬁcate checks and also
calls the original functions such that the security seman-
tics of the original library workﬂow are preserved. If those
additional checks fail, CertShim triggers a connection fail-
ure and also creates a syslog record that includes both an
explanation and a suggested template policy for ﬁxing the
problem. The speciﬁc form of veriﬁcation is modular, and
is discussed at greater length in Section 3.3.2.

3.3.1 Function Hooks
CertShim targets both veriﬁcation functions and hand-
shake functions in SSL libraries as well as system calls that
allow for the recovery of important network context. A list
of the CertShim’s function hooks is included in Table 1.

Veriﬁcation Functions. CertShim instruments OpenSSL’s
ssl_get_verify_result() and GnuTLS’ gnutls_certifi-
cate_verify_peer() to support modular certiﬁcate veriﬁ-
cation. Regardless of which module is enabled, the return

python-aptnetcatcurlmailutilslibssl1.0.0gnutls26CertShimConvergenceDANEPreloaded Shared ObjectSSL ApplicationsSSL Libraries. . .. . .. . .Key PinningPolicy Engine3973.3.2 Veriﬁcation Modules
Currently, CertShim supports 4 certiﬁcate veriﬁcation

methods:

• Traditional CA Veriﬁcation: The module invokes

the underlying native SSL API calls.

• Convergence[30]: The module communicates with
Convergence Notaries via a REST API. Convergences
local cache is implemented as a sqlite3 database, and
the list of trusted notaries and a veriﬁcation threshold
is set via a conﬁguration ﬁle.

• DANE [23]: The module is a thin wrapper around
Lexis’ SWEDE library for TLSA record veriﬁcation
[35]. This serves to demonstrate that existing proto-
types for SSL trust enhancements can be easily adapted
for use with CertShim. With minor modiﬁcations,
this module could be used to deploy Liang et. al.’s
DANE extension for securing CDN connections in non-
browser software [27].

• Client-Based Key Pinning: Implementations cur-
rently exist as Firefox Plug-Ins [37, 42]. Rather than
adapting these utilities, we developed our own trust-
on-ﬁrst-use key pinning module that stores certiﬁcate
ﬁngerprints in an sqlite3 database.

Not only does CertShim facilitate the use of any one of
these modules, it also oﬀers support for certiﬁcate validation
through ensemble voting strategies. For example, all 4 of
the modules can be enabled simultaneously, with a majority
vote determining whether or not the certiﬁcate is approved.
In the event that a veriﬁcation method fails but overall ver-
iﬁcation passes, CertShim prints a notiﬁcation of the fail-
ure to syslog. Because CertShim uses a single veriﬁcation
module across many implementations of SSL, prototyping
clients for new CA alternatives becomes a one-time cost and
interoperability with a variety of SSL libraries is assured.
3.4 Policy Engine

CertShim includes a policy engine that allows users to
easily express complex certiﬁcate veriﬁcation routines that
can be enforced system-wide or tailored to a speciﬁc appli-
cation or domain. Policies are deﬁned by the user in an
Apache-like conﬁguration ﬁle that is dynamically loaded ev-
ery time an application is invoked, allowing for the user to
alter the SSL behavior of all applications on the system at
any time without having to recompile. Figure 4 is an ex-
ample of such a policy deﬁnition ﬁle. The conﬁguration
subsystem of CertShim uses libconfig [1] for parsing the
conﬁguration ﬁle and extracting data.

The structure of the policy ﬁle is easy to understand and
use. A global_policy entry deﬁnes the system-wide be-
havior of CertShim except for cases where a more speciﬁc
policy is present. The engine ﬁnds relevant policy entries by
pattern matching over the cmd and host keys, with priority
being given to host entries. The methods key in each entry
allows for the enabling and disabling of speciﬁc veriﬁcation
modules. The vote key represents the percent of modules
that must return true before CertShim approves the cer-
tiﬁcate. When a key is not set in a speciﬁc entry, it inherits
the value of the global policy. The ordering of the policies
within the conﬁguration ﬁle is irrelevant.

Figure 3: Interaction between a client application using the
SSL_connect() function and CertShim.

negligent developers often fail to consult SSL veriﬁcation
functions [17, 19]. As a consequence, however, CertShim
will redundantly verify certiﬁcates in well-formed SSL code.
The veriﬁcation function hooks are superseded by the hand-
shake hooks in normal usage, but we felt it important to
hook the veriﬁcation functions so that the libraries’ certiﬁ-
cate handling was consistent across diﬀerent parts of the
API. We show in Section 5 that the performance costs of
using CertShim are minimal, and that this redundancy is
a small price to pay for the added coverage assurances.

Network Context. Some alternate certiﬁcate veriﬁcation
methods, such as network probing, require a canonical host-
name and port in order to validate an X509 certiﬁcate. How-
ever, the structures passed into OpenSSL and GnuTLS func-
tions do not reliably contain this information. This is due
to the great variety of ways in which these routines are in-
voked; in some cases, certiﬁcates are veriﬁed without being
aware of the endpoint with which the SSL session is be-
ing established. To recover this information, we instrument
the getaddrinfo(), gethostbyname(), and connect() sys-
tem calls. By recording the parameters passed and returned
from the original functions, we were able to perform reverse
lookups that translated socket ﬁle descriptors to hostnames,
which were then stored in a sqlite3 database that was keyed
from the process id of the calling function. Keying oﬀ the
pid was important to allowing the database to be shared
between processes, preventing ﬁle descriptor collisions.

Client Application: SSL_connect()CertShim: Disable SSL struct callbacksCertShim: Call libssl SSL_connect()CertShim: Call Veriﬁcation ModuleTerminate connection and return errorFatal connectionerrorClient Application: ExecutedELF preloads CertShimCertShim: Init,Load policies, hooksCertShim: Check veriﬁcation result against policyReturn OK on success or connection error on failure398cmd = " / usr / bin / git " ;
vote = 1.00;
methods : {

c e r t _ a u t h o r i t y = false ;
c o n v e r g e n c e

= true ;

= false ;

c e r t _ p i n n i n g
c e r t _ a u t h o r i t y = true ;
c o n v e r g e n c e
dane
vote

= false ;
= false ;
= 1.00;

1 g l o b a l _ p o l i c y : {
2
3
4
5
6
7 };
8
9 c o m m a n d _ p o l i c i e s : ({
10
11
12
13
14
15
};
16 } , {
17
18
19
20
21
22
23
24 }) ;
25
26 h o s t _ p o l i c i e s : ({
27
28
29
30
31
32
33 }) ;

c e r t _ p i n n i n g
c o n v e r g e n c e
dane

};

};

cmd = " / usr / bin / lynx " ;
vote = 0.50;
methods : {

= true ;
= true ;
= true ;

host = " www . t o r p r o j e c t . org " ;
vote = 1.00;
methods : {

c e r t _ a u t h o r i t y = false ;
dane = true ;

conﬁg.cfg

Figure 4: A sample CertShim policy conﬁguration ﬁle

Figure 4 shows an example conﬁguration ﬁle that illus-
trates the granularity and ﬂexibility of the CertShim policy
conﬁguration engine. Here, the global policy is set to force
traditional CA veriﬁcation on all SSL connections. However,
this user connects to a GitLab versioning server that makes
use of a self-signed certiﬁcate, so they created a command
policy entry for git that uses the Convergence module. The
user also wants stronger assurances than traditional CAs
can provide when browsing with Lynx, so they create an
additional command entry that queries all 4 modules and
requires that at least 2 return true. This entry inherits its
cert_authority value from the global policy. Finally, when
connecting to domains that are known to oﬀer DANE sup-
port such as torproject.org, the user adds a host policy
entry that requires DANE validation. Policies that toler-
ate failure in this fashion are useful when using CertShim
as a platform for testing CA alternatives that may not be
entirely stable.

We envision that various stakeholders will share the re-
sponsibility of CertShim policy creation, alleviating the
burden on end users. While some users may wish to deﬁne
their own certiﬁcate management policies, software devel-
opment communities could also release application-speciﬁc
policies, similar to the manner in which selinux policy mod-
ules are included in software packages. Operating system de-
velopment communities that make use of CertShim could
also include a policy of safe defaults in their distribution.

3.5 Java Instrumentation

In the Java architecture, we cannot interpose on SSL li-
braries such as JSSE and BouncyCastle through Linux’s dy-
namic linking.
Instead, we make use of the java.lang.-
instrumentation interface to achieve similar functionality
inside of the JVM. We successfully used this method to pro-
vide CertShim-like functionality by hooking the checkI-
dentity() function in JDK 6’s JSSE, and the checkIden-
tity() and setEndpointIdentificationAlgorihtm function
of JDK 7. Georgiev et al. point to misuse of the low level
JSSE SSLSocketFactory API, which does not perform host-
name veriﬁcation, as one of the biggest SSL vulnerabilities
in Java [19]. While in control of these functions, CertShim
overrides the applications’ conﬁguration in order to force
hostname veriﬁcation. Like our C-based mechanism, our in-
strumentation object can be injected into all Java calls by
setting an environment variable. Java is not yet fully sup-
ported in CertShim, as we have not re-implemented our
policy engine. However, this mechanism demonstrates how
our approach can be generalized to work with Java.

4. ANALYSIS

We now consider the extent to which CertShim meets our
3 primary system goals: override insecure SSL usage, enable
SSL trust enhancements, and maximize compatibility. We
consider the extent to which we achieve maximal coverage
in Section 5.
4.1 Override Insecure SSL Usage

Recent work has uncovered strong evidence that insecure
certiﬁcate handling practices are often a result of developer
confusion and apathy [16, 17, 19]. Rather than wait on de-
velopers, CertShim automatically ﬁxes these vulnerabilities
without requiring developer intervention. Enforcing safe de-
faults for SSL does not even require policy conﬁguration, as
CertShim installs with a global default policy that enforces
CA veriﬁcation. We also include fail-safe protections to the
policy engine, such as the vote key defaulting to 1.00 if left
accidentally unspeciﬁed by the user.

CertShim supports all applications that dynamically link
to OpenSSL and GnuTLS, two of the most popular open
source SSL libraries. In Section 5, we show that this provides
support for 94% of SSL usage in the most popular Ubuntu
packages. Most excitingly, CertShim ﬁxes certiﬁcate veriﬁ-
cation in data-transport libraries that are broken by design,
including urllib/urllib2, httplib, python’s ssl module,
and perl’s fsockopen call. This aspect of CertShim proves
critical, as the survey in Section 5 ﬁnds that such libraries
represent up to 33% of SSL usage in Ubuntu packages.
4.2 Enable SSL Trust Enhancements

In this work, we implement veriﬁcation modules for 3 ex-
emplar CA alternatives, making them immediate candidates
for system-wide deployment. Switching from CA veriﬁca-
tion to an alternative such as Convergence requires a change
of just 2 lines in the CertShim conﬁguration ﬁle. Due to
incremental deployment or design limitations, some CA al-
ternatives are not universally applicable to the entire SSL
ecosystem. For example, not all HTTPS domains have pub-
lished TLSA certiﬁcates for DANE, and other domains will
be inside closed networks that cannot be veriﬁed with Con-
vergence’s multi-path probing. We have further contributed

399to the adoptability of CA alternatives by introducing a pol-
icy engine that allows for application and domain speciﬁc
certiﬁcate handling. With CertShim, it is possible to force
DANE veriﬁcation only on domains that are known to be
supported. CertShim even helps to support traditional CA
veriﬁcation by providing a multi-path probe module that
can be enabled speciﬁcally for applications and domains that
make use of self-signed certiﬁcates.
4.2.1 Consensus Veriﬁcation
CertShim further improves SSL security by providing the
ﬁrst practical means of reconciling the results of multiple
certiﬁcate veriﬁcation handlers. In so doing, it is possible
to overcome practical problems or trust concerns that are
limitations of diﬀerent architectures. To demonstrate the
power of this approach, we present sample policy entries
that represent unique trust and usage models for SSL. For a
detailed explanation of the security properties of these sys-
tems, please refer to the original works. We believe that
the combining of diﬀerent veriﬁcation primitives through
consensus voting represents a promising new direction for
securing SSL.
Distrust the CAs. Convergence was motivated by the goal
of completely removing certiﬁcate authorities from the SSL
trust model. CAs are replaced with notaries, trusted third
parties that are incentivized to be trustworthy agents due
to trust agility, the ability of the user to change who their
trusted notaries at any time. However, multi-path probing
cannot validate all domains. One option would be to com-
bine Convergence with client-based key pinning:

cert_pinning = true;
convergence = true;
vote = 0.50;

This conﬁguration allows for a CA-free trust model. When
Convergence is unable to validate a domain, CertShim would
default to a trust-on-ﬁrst-use model [5]. In the event that a
certiﬁcate is updated, in most cases Convergence would be
able to re-validate the domain, making up for key pinning’s
inability to oﬀer context in the event of a benign anomaly. In
the event of a discrepancy between a cached certiﬁcate and
the certiﬁcate presented by the host, the key pinning mod-
ule would fail to verify the certiﬁcate, requiring the user to
manually decide whether to trust the presented certiﬁcate.
Server-side MitM Defense. Convergence relies on net-
work path diversity in order to validate certiﬁcates. While
this is adequate for detecting local MitM attacks at rogue
access points, if a powerful adversary such as a nation state
can control all paths between the server and the notaries,
Convergence could yield a false negative during an attack.
To account for this possibility, CertShim could tether its
trust to the DNS architecture:

convergence = true;
dane = true;
vote = 1.00;

This policy increases attack complexity by requiring the
attacker to control the DNSSEC resolvers and a valid certiﬁ-
cate from a trusted CA in addition to all network paths to
the server. We note that this policy only works for domains
that oﬀer DANE support. In environments where DNSSEC
is actively being used, the use of Convergence provides a
hedge against DNSSEC server compromises.

4.3 Maximize Compatibility

As the invasiveness of our function hooks increased, so
too did the likelihood that CertShim would break applica-
tions. Developers could not have anticipated our layering
of additional certiﬁcate veriﬁcation methods on top of their
code. Applications may disable certiﬁcate veriﬁcation in or-
der to support self-signed certiﬁcates [17], contact domains
that are not compatible with certain forms of veriﬁcation, or
even have implemented their own security features such as
key pinning. As a result, CertShim’s actions could trigger
unexpected behavior.

These realities motivated the creation of our policy engine,
which oﬀers the ability to completely eliminate compatibility
issues by performing application and domain speciﬁc cer-
tiﬁcate handling. Regardless of the policy in eﬀect for a
given connection, the CertShim hook return values strictly
adhere to the OpenSSL and GnuTLS APIs. This implies
that existing applications are unable to detect the presence
of CertShim while allowing CertShim to remain entirely
method-agnostic. That is, CertShim does not interfere with
the logic built into existing applications since return values
remain true to the OpenSSL and GnuTLS APIs and Cert-
Shim itself holds no opinion on which veriﬁcation methods it
should or should not use; CertShim can even be conﬁgured
to take no action for a given application or domain. Further-
more, the success or failure of alternate veriﬁcation methods
is translated into return codes consistent with OpenSSL and
GnuTLS.

5. EVALUATION

In this section, we evaluate CertShim for both its ability
to support real world SSL usage and the performance costs
it imposes on SSL connections.

5.1 Coverage

Our investigation of CertShim coverage is comprised of
two parts. We ﬁrst perform a small-scale survey in which
we manually test applications and libraries to conﬁrm sup-
port, followed by a large-scale survey in which we conduct
semi-automated source code inspection to estimate Cert-
Shim coverage for a fuller distribution of software.

5.1.1 Manual Testing
Our evaluation of CertShim coverage began with man-
ual testing of popular SSL applications and middleware.
Presently, CertShim is conﬁrmed to support 12 diﬀerent
SSL implementations or wrappers, shown in Table 2. Al-
though it was apparent that the listed SSL scripting wrap-
pers all used OpenSSL/GnuTLS backends, it was necessary
to manually conﬁrm compatibility because the wrappers oc-
casionally made use of the SSL API in unexpected ways.
For example, we discovered that CertShim does not sup-
port php_curl due to the fact that this library statically
links libcurl. Continuing with manual testing, we selected
a handful of common SSL applications to conﬁrm CertShim
support, shown in Table 3. Of these, CertShim successfully
hooked each application except for Firefox, which is due to
the fact that Mozilla uses LibNSS rather than OpenSSL or
GnuTLS. We discuss the broader implications of these cov-
erage gaps in Section 6.

400Program
Success Conﬁrmed With
libcurl
Yes
gnutls26
Yes
libssl1.0.0
Yes
SSLSocketFactory Yes
Yes
perl socket::ssl
No
php curl
Yes
fsockopen
httplib
Yes
Yes
pycurl
Yes
pyOpenSSL
Yes
python ssl
Yes
urllib, urllib2
gnutls-cli
Yes

C program
C program
C program
java program
perl script
php script
php script
python script
python script
python script
python script
python script
CLI execution

Table 2: Libraries and wrappers that were manually con-
ﬁrmed to be supported by CertShim.

5.1.2 Less Dangerous Code?
We next consider CertShim’s safe default features, and
how they protect against the SSL vulnerabilities presented
by Georgiev et al.
[19]. Through manual testing, we con-
ﬁrmed that CertShim would secure the SSL communica-
tions in 100% of the SSL libraries, 89% of the data-transport
libraries, and 71% applications mentioned in this work:

• SSL Libraries. Error-prone aspects of the SSL API
are identiﬁed in OpenSSL, GnuTLS, and JSSE. Cert-
Shim enforces proper certiﬁcate handling for OpenSSL
and GnuTLS, even when the application fails to call
the veriﬁcation function. We provide partial support
to JSSE, which we instrumented to ensure that host-
name veriﬁcation is always performed, regardless of
how the API is invoked.

• Data-transport Libraries. Georgiev et al. discuss 9
data-transport frameworks that wrap the major SSL li-
braries. We provide full support to cURL, php’s fsock-
open, urllib, urllib2, httplib, python ssl, and par-
tial support to the Java libraries Apache HttpClient
and Weberknect. The only library that CertShim
does not support is php_curl due to static linking.

• SSL Applications. We obtained the vulnerable ver-
sions of several of the applications explored, including
Lynx, Apache HttpClient, and Apache Axis. Based on
review of these applications combined with our man-
ual tests, we conclude that CertShim secures the SSL
communications of 12 of the 17 applications mentioned
that could be run on Linux systems. All 5 of the un-
supported applications were payment services that had
a vulnerable php_curl dependency.

These ﬁndings demonstrate the power of the CertShim
methodology. It also serves to show that, so long as the API
remains the same, CertShim can protect against presently
undiscovered vulnerabilities and misconﬁgurations in SSL
APIs and wrapper libraries.
5.1.3 Large-Scale Coverage Survey
On a general computing platform such as Linux, auto-
mated dynamic analysis of SSL proved diﬃcult due to the
great variety of SSL implementations, languages, and usage
scenarios. During manual testing, we found that a thorough
knowledge of an application’s purpose and behaviors was

Program Test Cmd
curl
sslscan
lynx
ncat
fdm
fetchmail
ﬁrefox
mpop
perl
pycurl
pyOpenSSL Socket established SSL session
urllib
w3m
wget
gnutls-cli

Success
Yes
curl https://google.com
sslscan google.com:443
Yes
lynx -dump https://google.com Yes
Yes
ncat –ssl-verify google.com 443
Yes
Checked gmail.com over SSL
Yes
Checked gmail.com over SSL
No
Visited gmail.com (w/o plugin)
Checked gmail.com over SSL
Yes
Yes
Perl’s IO::Socket::SSL
Yes
cUrl established SSL session
Yes
urllib made HTTPS request
Yes
w3m https://google.com -dump Yes
wget https://google.com
Yes
Performed handshake procedure Yes

Table 3: Programs and libraries that were manually tested
to conﬁrm CertShim support

(a) Total Packages Supported (b) Packages supported by SSL

library/wrapper

Figure 5: Estimated CertShim support of SSL usage found
in Ubuntu Popularity Contest.

required in order to trigger SSL connections. As a result,
we were unable to perform large-scale dynamic analysis of
CertShim. Fortunately, based on the supported libraries
shown in Table 2, we were able to use a mix of static analy-
sis and manual inspection in order to arrive at a CertShim
coverage estimate for a large corpus of applications.

As a source for real world SSL usage, we selected the
Ubuntu Popularity Contest [34], a service that tracks the
most commonly installed packages on Ubuntu. Starting with
the top 10,000 packages, we ran apt-rdepends, a tool for re-
cursively ﬁnding library dependencies for a given package,
on each package. Of these packages, we were able to recover
library dependency information for 7,789 packages due to
the fact that some packages were not present in the main
apt repositories for Ubuntu 12.04. From this list we discov-
ered 2,949 packages that had dependencies to known SSL li-
braries (i.e., the packages left out could not have been using
SSL). We then gathered the corresponding source ﬁles us-
ing apt-get source. This methodology yielded 1,809 code-
bases, with the reduction in total packages being accounted
for by the fact that one codebase can be responsible for mul-
tiple packages. With the available source, we proceeded to
check the ﬁles against a list of keywords related to network-
ing, SSL, and HTTPS. After narrowing the ﬁeld to source
packages containing keywords, we manually inspected the
remaining packages to conﬁrm that the package made SSL
connections. As CertShim only partially supports Java,
these packages that were removed from the survey.

401Dependency
urllib/httplib
OpenSSL
GnuTLS
cURL/libcurl
Misc SSL Wrappers
Total Supported
Total Unsupported

Support? Pkg. Count
123
92
51
48
56
370
26

Yes
Yes
Yes
Yes
Yes

Module
OpenSSL w/o CertShim
CertShim Baseline
Convergence Baseline
Key Pinning, First Use
Key Pinning, Revisit
DANE

Real Time

88 ms [ 84, 92]

108 ms [107, 109]
108 ms [107, 110]
130 ms [120, 139]
119 ms [118, 119]

7 sec

Table 4: Details of estimated CertShim support and SSL
usage in the Ubuntu Popularity Contest.

Table 5: Benchmarks for CertShim usage. 95% conﬁdence
intervals are included in brackets.

Because CertShim cannot support static linking, we also
wished to determine if this was a common practice. To do so,
we installed the 395 packages that contained SSL activity,
then ran ldd, a tool that prints shared library dependencies,
against each of the resulting ﬁles that were placed in bin
or lib directories. ldd lists packages that are dynamically
linked, and can also detect static linking. We did not ﬁnd
widespread use of static linking, of 10,707 ﬁles checked by
ldd, we found only 12 that were statically linked.

As illustrated in Figure 5a, we found that CertShim sup-
ported 370 of the 395 packages found to be making SSL
connections, for a coverage ratio of 94%. Our use of the
word “support” can be interpreted as follows – this applica-
tion may make an SSL connection in execution, and if it does
CertShimwill hook it. A stronger assurance about applica-
tion behavior would have required dynamic analysis, which
was not feasible. A summary of our results can be found in
Table 4 and Figure 5b. The miscellaneous SSL wrappers in-
cluded QSSL, Pidgin’s Purple SSL, URLGrabber, Serf, and
Neon; for each, we inspect the source code to conﬁrm that
they wrapped OpenSSL or GnuTLS and used one of Cert-
Shim’s function hooks. The unsupported packages included
previously discovered coverage gaps such as NSS, as well as
other wrappers such as KSSL and QCA, for which we were
unable to conﬁrm support. We note that this coverage result
is an estimate; without dynamic analysis, it was impossible
to deﬁnitively conﬁrm that these applications attempted to
make SSL connections. However, we did conﬁrm that each
of the applications had code paths that made web requests
with SSL-ready libraries.
5.2 Performance

We generated several benchmarks for the baseline perfor-
mance of CertShim, performing tests on a Dell PC run-
ning a Linux 3.5 kernel with 2 GB of RAM and a Pentium
3Ghz dual-core processor. We measured the time it took the
wget utility to retrieve a small, 9 KB ﬁle over HTTPS from
a nearby web server. This call triggers the SSL_get_ver-
ify_result() function, which is supported by CertShim.
The throughput of the connection to the server was approxi-
mately 80 MB per second. The server was using a CA-signed
certiﬁcate, which was validated by wget during the course
of the download. Each of these results were averaged over
500 measurements. When CertShim was not loaded, wget
returned in 88 ms. When CertShim was loaded without a
veriﬁcation module, the operation completed in 108 ms, im-
posing just 20 ms base overhead on OpenSSL. This overhead
is largely due to the CertShim hooks for the connect() and
getaddrinfo() functions, which collect contextual data that
is required by the hooked OpenSSL and GnuTLS functions
and write it to a SQLite database. The policy engine demon-

strated an average run time of just 0.061 ms while parsing
the sample conﬁguration ﬁle and initializing the policies.
When using an 86 kilobyte conﬁguration ﬁle consisting of
392 policies, the policy engine required an average run time
of 3.075 ms. Each average was based on 1,000 iterations.

We then repeated these trials with the diﬀerent veriﬁca-
tion modules enabled. The results are summarized in Table
5. The minimum time required for Convergence veriﬁcation
was 108 ms, corresponding to the case in which the client
already possesses a locally cached copy of the certiﬁcate ﬁn-
gerprint. We benchmarked Key Pinning under two use cases:
veriﬁcation took 130 ms when visiting a domain for the ﬁrst
time, and 119 ms when checking a previously visited domain.
The time required to use the DANE module was 7 seconds.
We attribute this exorbitant cost to the fact that our DANE
measurements used https://www.torproject.org instead
of a local server. Tor has 9 IP addresses associated with
this domain, each of which was sequentially veriﬁed by the
SWEDE library within our module.

Initially, we observed that the base cost of CertShim was
900 ms. Upon further investigation, we realized that this
was due to our SQLite conﬁguration; each attempt to open
a write transaction to the database cost approximately 100
ms. To improve performance, we disabled journaling on
the database. We note that this also disabled protections
against database corruption due to hardware failures or un-
expected interrupts. In a future iteration of CertShim, we
intend to restore these protections while imposing minimal
additional performance cost by implementing an in-memory
database that ﬂushes to disk during idle periods.

6. LIMITATIONS & FUTURE WORK

We now discuss several potential gaps in CertShim’s cov-

erage, as well as possible solutions:

Root Processes. For security reasons, LD_PRELOAD is not
permitted by default for processes running as root; however,
support for root can be provided by symbolically linking a
root-owned copy of CertShim to the /lib directory.

Alternative Libraries. CertShim supports modern ver-
sions of two of the most popular open source SSL libraries,
libssl1.0.0 and gnutls26. There are many other imple-
mentations available, such as PolarSSL and NSS; we have
inspected these libraries and believe that CertShim can be
extended to support them with only modest additional work.
CertShim provides a blueprint for interposing on function
calls in any C-based SSL library. Our approach could be
deployed on Windows’ SChannel library as an AppInit_DLL.
SSL in Java. Linux dynamic linking cannot be used to
interpose on Java libraries. However,
in Section 3.5 we
demonstrate that our approach is applicable in Java through
instrumentation objects.

402Static Linking. As our methodology is based on dynamic
linking, CertShim cannot interpose on statically linked ex-
ecutables. In our evaluation, we encountered one instance
of static linking in PHP’s cURL wrapper. As a stop-gap so-
lution to this problem, we are investigating the use of Conti
et al.’s approach of correlating SSL traﬃc to applications
[11]; if a ﬂow’s network context is not already present in
the CertShim database (Section 3.3.1), CertShim can in-
fer that the ﬂow is from a statically linked application and
warn the user. This limitation could be more fully addressed
via static binary instrumentation through use of tools like
PEBIL [25] and DynInst [6, 8].

Usability. CertShim already has a complete logging sys-
tem, making it easy to develop a graphical user interface
layer and other utilities. We envision a notiﬁcation system
similar to Red Hat’s setroubleshootd daemon, which sim-
pliﬁes selinux usage by alerting users to new AVC log mes-
sages. Because CertShim logs a template policy entry upon
veriﬁcation failure, an audit2allow-like application could be
developed to dramatically simplify policy debugging.

Policy Engine. We intend to extend the policy mechanism
to support pattern matching on command line arguments.
Some applications’ certiﬁcate veriﬁcation behaviors should
change based on these arguments; for example, CertShim
should take no action when wget is invoked with the -no-
check-certificate. We also intend to release additional
veriﬁcation modules.

7. RELATED WORK

A large body of recent work has sought to better un-
derstand and ultimately prevent SSL vulnerabilities in non-
browser software. Georgiev et al. manually survey diﬀerent
layers of the SSL stack, discovering pervasive misconﬁgu-
rations of certiﬁcate validation routines, as well as usage
of SSL libraries that are broken by design [19]. Brubaker
et al. speciﬁcally target SSL libraries, generating 8 million
random permutations of valid X509 certiﬁcates to perform
diﬀerential testing and discover hundreds of certiﬁcate val-
idation discrepancies [7]. Akhawe et al. [2] considered the
issues of TLS errors on the web and notices diﬀerences with
results from OpenSSL. While these studies makes recom-
mendations based on their ﬁndings, there is no mechanism
for retroﬁtting changes into existing applications, which we
make feasible with CertShim.

Large-scale automated dynamic analysis of SSL usage re-
quires knowledge of application semantics in order to trigger
SSL connections, and is therefore diﬃcult on general com-
puting platforms due to the great diversity of languages,
code paths, and SSL implementations; however, recent work
has made use of the constrained interfaces of mobile plat-
forms to perform large scale analysis. SMV-Hunter leverages
knowledge of the X509TrustManager interface and Android
WindowManager to perform user interface automation, trig-
gering SSL connections in hundreds of Android apps to de-
tect MitM vulnerabilities [43]. MalloDroid performs static
analysis to identify deviant SSL usage in thousands of apps,
but manually audited to conﬁrm vulnerabilities [16].

While the above studies oﬀered recommendations for the
general improvement of the SSL ecosystem, such as im-
proved app market testing [16], clarifying SSL APIs [19], or
communicating vulnerabilities to developers [7], they were
unable to introduce system-wide defenses to SSL vulnera-
bilities in legacy software. An exception to this is Fahl et

al’s Rethinking SSL work, in which an Android patch is in-
troduced that dramatically improves app security through
user interface warnings, device-speciﬁc developer options,
and forced certiﬁcate and hostname validation [17]. While
we also introduce a platform-wide defense, our work does
not require a manufacturer update, or even administrator
privileges, to put to use. Additionally, where pluggable cer-
tiﬁcate veriﬁcation is left to future work by Fahl et al., we
introduce four such modules, and the ability to use them
in tandem through policy-speciﬁed consensus votes. Our
tool, CertShim, works in a considerably more complex en-
vironment than the Android platform, where various SSL
implementations need be considered. Both our system and
Fahl et al’s experience compatibility issues with some pro-
grams; however, rather than rely on developers to update
their applications, we provide a policy engine that allows
for application- or domain-speciﬁc certiﬁcate handling.

Rather than re-architecting SSL stacks in the OS, other
work has invasive strategies to protecting SSL that actu-
ally closely mirror the attack behaviors. MYTHIS uses a
local MitM network proxy as an SSL security layer on an-
droid [11]; by anchoring its security in a single-path net-
work probe, MYTHIS detects rogue access points [40], but
not attacks near the server or network interior. Huang et
al. embed ﬂash scripts in browser code that “phone home”
to the server, allowing websites to detect the presence of
forged certiﬁcates [24]. CertShim also behaves similarly to
an attack by hijacking dynamic library calls; however, our
solution is a more general one that permits multiple trust
models and detects wider classes of attacks.

Various proposals in the literature adopt a similar deploy-
ment strategy to CertShim. Provos et al. [36] implement
privilege separation (Privsep), modifying a small portion of
the OpenSSH source code to permit diﬀerent parts of an ap-
plication run at diﬀerent privilege levels. They demonstrate
that this approach allowed for interoperability and negligible
performance costs. Watson et al. [46] present Capsicum, a
capability-based sandboxing mechanism for UNIX, through
the introduction of a library that replaces basic UNIX op-
erations such as fork and exec. They present Capsicum-
compliant versions of several popular utilities (e.g.
tcp-
dump, gzip), and perform microbenchmarking to demon-
strate small overheads on the modiﬁed system calls. The
DNSSEC-Tools project provided Libval, a shim for the DNS
library that facilitated the rapid adoption of DNSSEC [44].
Our work diﬀers from the Libval in that we target multi-
ple SSL implementations used by a greater diversity of pro-
grams, override additional functions in the Linux networking
stack to track SSL ﬂow context, and employ a modular de-
sign that supports multiple veriﬁcation methods.

8. CONCLUSION

This paper has introduced CertShim, a mechanism that
immediately improves the security of Internet communica-
tions by interposing on SSL APIs, and even permits the
retroﬁtting of legacy software to support SSL trust enhance-
ments such as Convergence and DANE. Moreover, we have
presented a practical mechanism for polling the results of
multiple veriﬁcation methods, further promoting the adopt-
ability of CA alternatives by overcoming their usage lim-
itations. We have also shown that 94% of the SSL us-
age in Ubuntu’s most commonly installed packages are sup-
ported by CertShim, and that CertShim secures applica-

403tions against some of the most infamous SSL vulnerabilities
explored in the literature. This work signiﬁcantly increases
system-wide security of SSL communications in non-browser
software, while simultaneously reducing the barriers to eval-
uating and adopting the myriad alternative proposals to the
certiﬁcate authority system.
Acknowledgments
We would like to thank Paul van Oorschot, Jeremy Clark,
Patrick Traynor, and Boyana Norris for their valuable com-
ments and insight. This work is supported in part by the
US National Science Foundation under grant numbers CNS-
1118046 and CNS-1254198. Braden Hollembaek was funded
in part through an NSF REU supplement.
Availability
Source code for CertShim will be made available from our
lab website at http://sensei.ufl.edu.

9. ADDITIONAL AUTHORS

Abdulrahman Alkhelaiﬁ, University of Oregon.

10. REFERENCES
[1] libconﬁg - c/c++ conﬁguration ﬁle library. Available:

http://www.hyperrealm.com/libconfig/.

[2] Akhawe, D., Amann, B., Vallentin, M., and

Sommer, R. Here’s My Cert, So Trust Me, Maybe?
Understanding TLS Errors on the Web. In Proceedings
of the 22nd International World Wide Web Conference
(WWW 2013) (Rio de Janeiro, Brazil, May 2013).

[3] Alicherry, M., and Keromytis, A. D.

Doublecheck: Multi-path veriﬁcation Against
Man-in-the-Middle Attacks. In Computers and
Communications, 2009. ISCC 2009. IEEE Symposium
on (2009), IEEE, pp. 557–563.

[4] Amann, B., Sommer, R., Vallentin, M., and

Hall, S. No Attack Necessary: The Surprising
Dynamics of SSL Trust Relationships. In ACSAC ’13:
Proceedings of the 29th Annual Computer Security
Applications Conference (Dec. 2013).

[5] Arkko, J., and Nikander, P. Weak Authentication:

How to Authenticate Unknown Principals without
Trusted Parties. In Security Protocols,
B. Christianson, B. Crispo, J. Malcolm, and M. Roe,
Eds., vol. 2845 of Lecture Notes in Computer Science.
Springer Berlin Heidelberg, 2004, pp. 5–19.

[6] Bernat, A. R., and Miller, B. P. Anywhere,

Any-time Binary Instrumentation. In Proceedings of
the 10th ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools (New York, NY,
USA, 2011), PASTE ’11, ACM, pp. 9–16.

[7] Brubaker, C., Jana, S., Ray, B., Khurshid, S.,

and Shmatikov, V. Using Frankencerts for
Automated Adversarial Testing of Certiﬁcate
Validation in SSL/TLS Implementations. In
Proceedings of the 2014 IEEE Symposium on Security
and Privacy (San Jose, CA, May 2014).

[8] Buck, B., and Hollingsworth, J. K. An API for

Runtime Code Patching. Int. J. High Perform.
Comput. Appl. 14, 4 (Nov. 2000), 317–329.

[9] Carly, R. Internet Security provider Comodo’s CEO

Named “Entrepreneur of the Year” by Info Security
Products Guide. Available:
http://www.comodo.com/news/press_releases/
2011/02/comodo-CEO-entrepreneur-of-the-Year-
infosecurity-global-excellence-award.html,
February 2011.

[10] Clark, J., and van Oorschot, P. C. SoK: SSL and

HTTPS: Revisiting Past Challenges and Evaluating

Certiﬁcate Trust Model Enhancements. In Proceedings
of the 2013 IEEE Symposium on Security and Privacy
(San Francisco, CA, May 2013).

[11] Conti, M., Dragoni, N., and Gottardo, S.

MITHYS: Mind The Hand You Shake - Protecting
Mobile Devices from SSL Usage Vulnerabilities. In
Security and Trust Management, R. Accorsi and
S. Ranise, Eds., vol. 8203 of Lecture Notes in
Computer Science. Springer Berlin Heidelberg, 2013,
pp. 65–81.

[12] Ducklin, P. The TURKTRUST SSL Certiﬁcate

Fiasco – What Really Happened, and What Happens
Next? Available: http:
//nakedsecurity.sophos.com/2013/01/08/Available:
the-turktrust-ssl-certificate-fiasco-what-
happened-and-what-happens-next/, January 2013.

[13] Eastlake, D., et al. Transport Layer Security

(TLS) Extensions: Extension Deﬁnitions.

[14] Eckersley, P. Sovereign Key Cryptography for

Internet Domains, 2011.

[15] Edge, J. Mozilla and CNNIC. Available:

http://lwn.net/Articles/372386/, February 2010.

[16] Fahl, S., Harbach, M., Muders, T.,

Baumg¨artner, L., Freisleben, B., and Smith, M.
Why Eve and Mallory Love Android: An Analysis of
Android SSL (in)Security. In Proceedings of the 2012
ACM Conference on Computer and Communications
Security (New York, NY, USA, 2012), CCS ’12, ACM,
pp. 50–61.

[20] Gibbs, S. Heartbleed Bug: What Do You Actually

Need to do to Stay Secure? Available:
http://www.theguardian.com/technology/2014/
apr/10/heartbleed-bug-everything-you-need-to-
know-to-stay-secure.

[21] Grigg, I. VeriSign’s Conﬂict of Interest Creates New
Threat. Financial Cryptography 1 (September 2004).
[22] Hickman, K., and Elgamal, T. The SSL Protocol.

Netscape Communications Corp 501 (1995).

[23] Hoffman, P., and Schlyter, J. The DNS-Based

Authentication of Named Entities (DANE) Transport
Layer Security (TLS) Protocol: TLSA. Tech. rep.,
RFC 6698, August, 2012.

[24] Huang, L.-S., Rice, A., Ellingsen, E., and

Jackson, C. Analyzing Forged SSL Certiﬁcates in the
Wild.

[25] Laurenzano, M., Tikir, M., Carrington, L., and

Snavely, A. PEBIL: Eﬃcient static binary
instrumentation for Linux. In Performance Analysis of
Systems Software (ISPASS), 2010 IEEE International
Symposium on (March 2010), pp. 175–183.

[26] Laurie, B., Langley, A., and Kasper, E.

Certiﬁcate Transparency. Available: ietf.
org-Certiﬁcate Transparency (06.01. 2013) (2013).

[27] Liang, J., Jiang, J., Duan, H., Li, K., Wan, T.,

[17] Fahl, S., Harbach, M., Perl, H., Koetter, M.,
and Smith, M. Rethinking SSL Development in an
Appiﬁed World. In Proceedings of the 2013 ACM
SIGSAC Conference on Computer and
Communications Security (New York, NY, USA,
2013), CCS ’13, ACM, pp. 49–60.

[18] Fisher, D. Microsoft Revokes Trust in Five Diginotar

Root Certs. Wired. Available:
http://threatpost.com/microsoft-revokes-trust-
five-diginotar-root-certs-mozilla-drops-trust-
staat-der-nederland-cert, September 2011.

[19] Georgiev, M., Iyengar, S., Jana, S., Anubhai,

R., Boneh, D., and Shmatikov, V. The Most
Dangerous Code in the World: Validating SSL
Certiﬁcates in Non-Browser Software. In Proceedings
of the 2012 ACM conference on Computer and
communications security (Raleigh, NC, USA, 2012),
CCS ’12, ACM, pp. 38–49.

404and Wu, J. When HTTPS Meets CDN: A Case of
Authentication in Delegated Service.

[28] Marlinspike, M. More tricks for defeating SSL in

practice. Black Hat USA (2009).

[29] Marlinspike, M. New tricks for defeating SSL in

practice. BlackHat DC (Feb. 2009).

[30] Marlinspike, M. SSL and the Future of

Authenticity. Black Hat USA (2011).

[31] Marlinspike, M. Trust Assertions for Certiﬁcate

Keys.

[32] Mills, E. Comodo: Web Attack Broader Than

Initially Thought. CNET. Available: http:
//news.cnet.com/8301-27080_3-20048831-245.
html?part=rss&tag=feed&subj=InSecurityComplex,
March 2011.

[33] Myers, M. Revocatoin: Options and challenges. In

Financial Cryptography (1998), Springer, pp. 165–171.

[34] Pennarun, A., Allombert, B., and

Reinholdtsen, P. Ubuntu Popularity Contest.
Available: http://popcon.ubuntu.com/.

[35] Pieter Lexis. SWEDE - A Tool To Create and

Verify TLSA (DANE) Records. Available:
https://github.com/pieterlexis/swede.

[36] Provos, N., Friedl, M., and Honeyman, P.

Preventing Privilege Escalation. In Proceedings of the
12th USENIX Security Symposium (2003),
pp. 231–242.

[37] Psyced.org. Certiﬁcate Patrol. Available:

http://patrol.psyced.org/.

[38] Rivest, R. L. Can We Eliminate Certiﬁcate

Revocation Lists? In Financial Cryptography (1998),
Springer, pp. 178–183.

[39] Sandvik, R. Security Vulnerability Found in

Cyberoam DPI Devices (CVE-2012-3372). Available:
https://blog.torproject.org/blog/security-
vulnerability-found-cyberoam-dpi-devices-cve-

2012-3372, July 2012.

[40] Shetty, S., Song, M., and Ma, L. Rogue Access

Point Detection by Analyzing Network Traﬃc
Characteristics. In Military Communications
Conference, 2007. MILCOM 2007. IEEE (Oct 2007),
pp. 1–7.

[41] Singel, R. Law Enforcement Appliance Subverts SSL.

Available: http://www.wired.com/threatlevel/
2010/03/packet-forensics, March 2010.

[42] Soghoian, C., and Stamm, S. Certiﬁed Lies:

Detecting and Defeating Government Interception
Attacks Against SSL. In Financial Cryptography and
Data Security. Springer, 2012, pp. 250–259.

[43] Sounthiraraj, D., Sahs, J., Greenwood, G., Lin,

Z., and Khan, L. SMV-HUNTER: Large Scale,
Automated Detection of SSL/TLS Man-in-the-Middle
Vulnerabilities in Android Apps. In Proceedings of the
19th Network and Distributed System Security
Symposium. (2014).

[44] SPARTA, Inc. DNSSECTools: DNSSEC Software

Libraries and Tools. Available:
http://www.dnssec-tools.org/.

[45] Vratonjic, N., Freudiger, J., Bindschaedler,

V., and Hubaux, J.-P. The Inconvenient Truth
About Web Certiﬁcates. In Economics of Information
Security and Privacy III, B. Schneier, Ed. Springer
New York, 2013, pp. 79–117.

[46] Watson, R., Anderson, J., Laurie, B., and

Kennaway, K. Capsicum: Practical Capabilities for
UNIX. In Proceedings of the 19th USENIX Security
Symposium (2010).

[47] Wendlandt, D., Andersen, D. G., and Perrig,

A. Perspectives: Improving SSH-style Host
Authentication with Multi-Path Probing. In USENIX
2008 Annual Technical Conference (Boston, MA,
2008), ATC’08, pp. 321–334.

405