2013 IEEE Symposium on Security and Privacy

Efﬁcient Garbling from a Fixed-Key Blockcipher

Mihir Bellare1 Viet Tung Hoang2

Sriram Keelveedhi1

Phillip Rogaway2

1 Dept. of Computer Science and Engineering, University of California, San Diego, USA.

2 Dept. of Computer Science, University of California, Davis, USA.

Email: {mihir, skeelvee}@eng.ucsd.edu
Email: {hoangvt, rogaway}@cs.ucdavis.edu

Abstract—We advocate schemes based on ﬁxed-key AES as
the best route to highly efﬁcient circuit-garbling. We provide
such schemes making only one AES call per garbled-gate
evaluation. On the theoretical side, we justify the security of
these methods in the random-permutation model, where parties
have access to a public random permutation. On the practical
side, we provide the JustGarble system, which implements our
schemes. JustGarble evaluates moderate-sized garbled-circuits
at an amortized cost of 23.2 cycles per gate (7.25 nsec), far
faster than any prior reported results.

Keywords-Garbled circuits; garbling schemes; multiparty
computation; random-permutation model; timing study; Yao’s
protocol.

I. INTRODUCTION

A garbled circuit (GC) is like an ordinary circuit except
that each wire carries a string-valued token instead of the
bit it represents. The idea dates to A. Yao, who explained
the approach in talks about 2-party SFE (secure function
evaluation) in the 1980’s [19, 41, 42]. Long the centerpiece
of multiparty computation (MPC) protocols, GCs now enjoy
diverse applications. Beyond this, some GC-based protocols
have become practical. Beginning with Fairplay [32], a bit
of a cottage industry has emerged to improve the efﬁciency
and practicality of GC-based MPC [2, 7, 9, 10, 12, 17, 22–24,
28, 29, 31, 36, 37]. Such works target the efﬁciency of GCs
themselves, the way in which GCs are used in higher-level
protocols, the software architecture for MPC systems, and
the manner in which a user speciﬁes a desired functionality.
This paper shows how to construct and evaluate GCs
at unprecedented speeds. Our gains come from two main
sources. On the cryptographic side, we describe garbling
schemes that evaluate a gate using a single call to a ﬁxed
permutation, which can be instantiated by ﬁxed-key AES.
On the systems side, we exploit more efﬁcient representa-
tions of circuits.

Many approaches are known to propagate tokens across a
gate. Yao’s original idea was based on a speciﬁc public-key
encryption scheme; the original exposition describes the use
of eight public keys per garbled gate [1, 20]. A more modern
description by Naor, Pinkas, and Sumner [35] suggests token
propagation using two calls to a pseudorandom function.

Lindell and Pinkas [30] proved security for a 2-party proto-
col in which tokens are propagated using the composition of
semantically secure symmetric encryption schemes with an
“elusive” and “efﬁciently veriﬁable” range. Implementation-
oriented work by Lindell, Pinkas, and Smart [31] does token-
propagation based on a single call to a cryptographic hash
function—the customary choice in later MPC systems.

The advent of AES-NI support (AES new instructions) has
made it natural to turn from hash functions to blockciphers
for token propagation, and AES256 was the primitive used
by Kreuter, Shelat, and Shen [29]. But we contend that the
starting point best suited for exploiting AES-NI is not a
blockcipher but a cryptographic permutation, which can be
realized by ﬁxed-key AES: AESc(·) with c a ﬁxed, non-
secret key. An encryption key can be setup and, after, one
has a pipeline into which 128-bit blocks can be fed.

To capitalize on this possibility we seek garbling schemes
in the random-permutation model (RPM) [39], meaning that
all parties, adversary included, can access a single, ﬁxed,
random permutation, as well as its inverse. We aim for high
efﬁciency (a single call to the permutation to evaluate a
garbled gate), proven security, and the ability to incorporate
existing optimizations, including free xor [28] and garbled
row reduction [37].

Our starting point is the recent work of Bellare, Hoang,
and Rogaway (BHR) [5]. Traditionally, circuit garbling was
seen as an MPC-enabling technique, not an actual primitive.
BHR advocates a different point of view, one that sees
garbling schemes as a stand-alone cryptographic object. One
way to build these objects, BHR explain, is to start from
what they term a dual-key cipher (DKC). The present work
shows that suitable DKCs can be built using a single call
to a ﬁxed-key blockcipher. More speciﬁcally, we introduce
a notion of a σ-derived DKC and then prove security
of various (reasonably standard) garbling schemes under
speciﬁed assumptions on the function σ. By instantiating σ
in different RPM-based ways one obtains schemes that meet
both our efﬁciency and security aims. Let us explain our
main contributions in a bit more detail.

1. GARBLING IN THE RPM. We begin by precisely speci-
fying three garbling schemes: Ga, GaX, and GaXR. The ﬁrst

1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.39

478

Eπ(A, B, T, X) =
π(K) ⊕ K ⊕ X, with K ← A ⊕ B ⊕ T
π(K) ⊕ K ⊕ X, with K ← 2A ⊕ 4B ⊕ T
π(K (cid:4) T )[1 :k] ⊕ K ⊕ X, with K ← A ⊕ B
π(K (cid:4) T )[1 :k] ⊕ K ⊕ X, with K ← 2A ⊕ 4B

k/8

16
16
10
10

TE
50.3
52.1
93.7
97.9

A1
A2
A3
A4

Ga

TG
218
221
242
246

SP
64.0
64.0
40.0
40.0

TE
—
23.2
—
34.2

GaX

TG
—
55.6
—
62.7

GaXR

SP
—
11.5
—
7.20

TE
—
23.9
—
35.0

TG
—
56.4
—
63.3

SP
—
8.64
—
5.40

Figure 1. Efﬁciency of permutation-based garbling. Data is from the JustGarble system, garbling a moderate-size circuit (a 36.5K gate AES circuit;
82% xor gates). Columns labeled TE and TG give the time to evaluate and garble using the speciﬁed protocol, measured in cycles per gate (cpg). Multiply
by 0.3124 to get nanoseconds per gate on our test platform. Columns labeled SP give the size of the garbled tables, measured in bytes per gate (bpg).
Column k/8 is the token length, in bytes. This is the length of of A, B, and X. The permutation π is always AESc(·). Insecure possibilities are dashed.

is based on the Garble1 scheme of BHR [5], which, in turn,
closely follows NPS [35]. The scheme include the point-and-
permute technique [38], which hijacks one bit of each token
so that the agent evaluating the GC knows which “row” of
the garbled gate to decrypt. GaX augments Ga with the free-
xor technique [28], wherein XOR gates can be computed by
xoring their incoming token. The savings can be large, as
many circuits are rich in XOR gates, or can be refactored so.
Finally, GaXR augments GaX with garbled row reduction
[37], which reduces the size of a GC by arranging that one
of the four rows of each garbled gate need not be stored:
tokens are selected so as to make this ciphertext a constant.
In each of the three schemes the underlying primitive is
a dual-key cipher (DKC). This is a deterministic function
E : {0, 1}k × {0, 1}k × {0, 1}τ × {0, 1}k → {0, 1}k taking
keys A, B, a tweak T , and a plaintext X, returning a ci-
phertext E(A, B, T, X). All schemes (Ga, GaX, and GaXR)
use at most four calls to E to garble a gate and at most
one call to evaluate a gate. We must efﬁciently and securely
construct the needed DKC.
Our DKC constructions are in the RPM; the DKC has
oracle access to a random permutation π : {0, 1}(cid:3) → {0, 1}(cid:3).
(An important challenge for security is that the adversary
−1.) This is the sole
has access not only to π but also to π
source of cryptographic hardness available. Our implemen-
tations set π = AESc(·) for a ﬁxed key c. Fig. 1 shows
four constructions, with A1/A3 suitable for Ga and A2/A4
suitable for all three schemes. All of our DKC constructions
employ a single call to π. We postpone a description of
what 2A and 4B actually mean except to indicate that these
are simple operations, a couple of shifts or the like, but not
integer multiplication.

To validate the security of our schemes instantiated with
our DKC constructions, a natural ﬁrst thought is to prove
security of the schemes in the random-oracle (RO) model
(ROM) [6] and then show that the constructions of Fig. 1
are indifferentiable from ROs [15, 16, 33]. However, attacks
show that the constructions are not indifferentiable from
ROs. We have preferred them to constructions that are
indifferentiable from ROs because the latter are less efﬁcient.
The performance gains we have achieved must accordingly
be backed up by dedicated proofs.

Rather than provide many ad hoc proofs, we provide a
uniﬁed framework that deﬁnes a class of DKCs we call
σ-derived. All our instantiations fall in this class. We give
conditions on σ sufﬁcient to guarantee the security of Ga,
GaX, and GaXR, all in the RPM. Our results use concrete
security, giving formulas that bound an adversary’s maximal
advantage as a function of the effort it expends.

2. VULNERABILITIES IN EXISTING CONSTRUCTIONS. It is
common in this area to start from a basic, proven scheme,
and then implement an instantiation, enhancement, or variant
that is not itself proven. In particular, while there are proofs
for some schemes that use the free-xor method [14, 28], ours
are the ﬁrst proofs for schemes that simultaneously use both
free xor and garbled row reduction.
Absence of proof can belie presence of error. We consider
EH(A,B,T,X) = H(A[1 : k−1] (cid:3) T )⊕H(B[1 : k−1] (cid:3) T )⊕X
for a cryptographic hash function H. This DKC was
suggested for Fairplay [32], but claimed to work [28]
with free xor [28]. We will later show that this not to be
the case. Note that other authors have gone so far as to
implement MPC using this DKC [37]; the construction has
only been considered undesirable because it is less efﬁcient
than alternatives, not because its security was in doubt. Our
view is that it is not possible to look at a DKC and reliably
ascertain if it will work in a complex security protocol;
assurance here requires proofs.

3. THE JUSTGARBLE SYSTEM. Prior implementation work
has viewed MPC as the goal, with garbling implemented as
a component. Our JustGarble system takes a different view,
divorcing garbling from MPC to deliver a system whose goal
is just optimized garbling. This reﬂects and follows the view
of BHR [5]. JustGarble aims to be a general-purpose tool
for use not only in MPC, but also beyond.

JustGarble implements Ga, GaX, and GaXR with the
DKCs of Fig. 1 and the DKCs’ permutation instantiated
with ﬁxed-key AES. Among the system-level optimizations
and choices in JustGarble, the most prominent is program-
matically realizing the mathematical conventions of BHR
for representing circuits. The combination of faster DKCs
and a simple representation of circuits results in impressive
performance gains over previous implementations.

479

We have carried out a number of timing studies using
JustGarble. The main one on which we report is described
in Fig. 1. We built an AES128 circuit, a standard test case
for this domain, and looked at the time to evaluate the
circuit, TE; the time to garble the circuit, TG; and the size of
the garbled tables of the circuit, SP . Breaking with tradition
for this domain, we prefer to give running times in cycles per
gate (cpg), a measure that’s at least a little more robust than
time per gate or total time. Similarly, we report on circuit
size in units of bytes per gate (bpg).

Fig. 1 highlights the best evaluation time, 23.2 cpg, and
the best garbling time, 55.6 cpg. (As our processor runs at
3.201 GHz, this translates to 7.25 nsec/gate for evaluating
the GC and 17.4 nsec/gate for garbling it.) The smallest
garbled tables are also highlighted, 5.40 bpg. Garbled cir-
cuits themselves, which include more than garbled tables,
are always 8 bpg larger.

As a point of reference, Huang, Evans, Katz, and Malka
(HEKM) evaluate a similar AES circuit in around 2 μsec per
gate [23, Section 7: 0.06 sec, online, about 30K gates]. They
indicate 10 μsec per gate for very large circuits. Kreuter,
Shelat, and Shen (KSS) [29], using a DKC based on AES256
and implemented with AES-NI processor support, report
constructing a 31 Kgate AES-128 circuit in 80 msec, so
2.5 μsec per gate. These times are more than two orders of
magnitude off of what we report. While such a comparison
is in some ways unfair—as we have explained, HKEM
and KSS build systems for MPC, not garbling schemes—
the time discrepancy is vast, and prior MPC work has
routinely maintained that circuit garbling and evaluation are
key components of the total work done (and have thus
been the locus of prior optimizations). We note that the
HEKM and KSS ﬁgures are times spent on garbling and
evaluation alone; they don’t include time spent on, say,
oblivious transfer or network overhead.

We obtain performance gains over previous implementa-
tions even if we drop into JustGarble one of the previously
designed, comparatively slow DKCs. The main reason for
this is our extremely simple representation of garbled circuit.
Gates are not objects that communicate by sending mes-
sages, for example; they are indexes into an array. There
is no queue of gates ready to be evaluated; gates are topo-
logically ordered, so one just evaluates them in numerical
order. We call the representation format we use SCD, for
Simple Circuit Description. Its simplicity helps ensure that
most of the work in garbling a circuit or evaluating a GC is
actual cryptographic work, not overhead related to procedure
invocation, message passing, bookkeeping, or the like.

We emphasize that JustGarble knows nothing of MPC,
oblivious transfer, compiling programs into circuits, or any
of the other tasks associated to making a useful higher-level
protocol. JustGarble is a building block. If offers but two
services: garble a circuit already built by other means, and
evaluate a GC on a garbled input.

II. PRELIMINARIES

We adopt the deﬁnitions of BHR [5] lifted to the random-

permutation model (RPM).
NOTATION. We write Σ for {0, 1}. We routinely ignore
the distinction between strings and more structured objects
encoded by them, implicitly employing simple and ﬁxed
encoding schemes. We write a (cid:2) A to sample a from distri-
bution A. If A is a ﬁnite set, it has the uniform distribution.
CIRCUITS. A circuit, as deﬁned in BHR [5], is a 6-tuple
f = (n, m, q, A, B, G) where n ≥ 2 is the number of inputs,
m ≥ 1 is the number of outputs, q ≥ 1 is the number of
gates, and n + q be the number of wires. We let Inputs =
[1 .. n], Wires = [1 .. n + q], OutputWires = [n + q − m +
1 .. n + q], and Gates = [n + 1 .. n + q]. Then A : Gates →
Wires\OutputWires is a function to identify each gate’s
ﬁrst incoming wire and B : Gates → Wires\OutputWires
is a function to identify each gate’s second incoming wire.
Finally G : Gates × {0, 1}2 → {0, 1} is a function that
determines the functionality of each gate. We require A(g) <
B(g) < g for all g ∈ Gates.

The conventions above embody all of the following. Gates
have two inputs, arbitrary functionality, and arbitrary fan-
out. The wires are numbered 1 to n + q. Every non-input
wire is the outgoing wire of some gate. The ith bit of input is
presented along wire i. The ith bit of output is collected off
wire n + q− m + i. The outgoing wire of each gate serves as
the name of that gate. Output wires may not be input wires
and may not be incoming wires to gates. No output wire may
be twice used in the output. Requiring A(g) < B(g) < g
ensures that the directed graph corresponding to f is acyclic,
and that no wire twice feeds a gate; the numbering of gates
comprises a topological sort.

is probabilistic, while all

SYNTAX. An (RPM-based) garbling scheme is a tuple
of algorithms G = (Gb, En, De, Ev, ev). The ﬁrst algorithm,
Gb,
the rest are deterministic.
Algorithm Gb has access to an oracle, as does Ev, and
we write Gbπ and Evπ to denote these algorithms given
oracle π. Algorithm Gbπ transforms a pair of strings (1k, f )
to a triple of strings (F, e, d). These strings name functions
En(e,·) : Σn → Σ
∗ → Σm ∪ {⊥} and
∗
Evπ(F,·) : Σ
∗×Σ
∗ → Σ
, where n = f.n and m = f.m are
the ﬁrst and second components of f = (n, m, q, A, B, G).
∗ → Σ
String f itself names a function ev(f,·) : Σ
∗
.
We call k, f, F, e, d and π the security parameter, initial cir-
cuit, garbled circuit, token list, decoding data, and random
permutation, respectively.

and De(d,·) : Σ

∗

∗ × Σ

Throughout this work we will only be concerned with
what BHR call projective, circuit-garbling schemes. This
assumption was built into some of the names above, as
when calling F a “garbled circuit” (instead of a “garbled
function”). Function ev will always be the canonical circuit-
evaluation function: ev(f, x) is the m-bit result one gets by

480

Game PrvG,Φ,k,π

proc Garble(f0, f1, x0, x1)
if Φ(f0) (cid:9)= Φ(f1) then return ⊥
if {x0, x1} (cid:9)⊆ Σf0.n then return ⊥
if ev(f0, x0) (cid:9)= ev(f1, x1) then return ⊥
(F, e, d) ← Gbπ(1k, fb); X ← En(e, xb)
return (F, X, d)

Figure 2. Game for deﬁning the prv security of garbling scheme G =
(Gb, En, De, Ev). Initialize() samples b (cid:2) {0, 1} and Finalize(b(cid:2))
returns (b = b(cid:2)).
feeding x ∈ Σn to circuit f = (n, m, q, A, B, G). Dealing
exclusively with projective schemes, e will always encode a
list of strings (e1, . . . , e2n) and En(e, x1x2 ··· xn) (xi ∈ Σ)
will be X = (e1+x1 , e3+x2 , . . . , e2n−1+xn ).
SIDE INFORMATION. We parameterize privacy by a “knob”
that measures what we allow to be revealed. The side-
information function Φ maps f to some information about
it, Φ(f ). Two side-information functions will be of special
interest to us. The ﬁrst, Φtopo, already appeared in BHR.
It maps a circuit f = (n, m, q, A, B, G) to its underlying
topological circuit Φtopo(f ) = (n, m, q, A, B). The second,
Φxor, is new. It maps a circuit f = (n, m, q, A, B, G) to
something that obscures the functionality of each non-XOR
gate. Formally, function Φxor maps f = (n, m, q, A, B, G)
(cid:3)
(cid:3)
to the circuit Φxor(f ) = (n, m, q, A, B, G
g =
(cid:3)
g = AND otherwise.
XOR if Gg = XOR and, arbitrarily, G
SECURITY. Given a garbling scheme G = (Gb, En, De, Ev,
ev), security parameter k ∈ N, side-information function Φ,
, Fig. 2
and length-preserving permutation π : Σ
speciﬁes the game PrvG,Φ,k,π used to deﬁne privacy. For
an adversary A, let
(cid:3) − 1
Advprv.rpm,Φ

A
π (cid:2) Perm : Prv
G,Φ,k,π

(A, k) = 2 Pr

∗ → Σ
∗

) where G

(cid:2)

G

−1 and provided an input of 1k,

be the probability, normalized to [0, 1], that the FINALIZE
procedure of game PrvG,Φ,k,π returns 1 (i.e., the adversary
correctly predicts b) when adversary A, running with oracles
interacts with the
π, π
speciﬁed game, making a single call to Garble. Here Perm
is the set of all length-preserving permutations and a random
sample π from Perm, restricted to strings of length (cid:4) ∈ N,
is a uniformly random permutation on Σ(cid:3).
Informally, we will say that G is prv secure over Φ,
(A, k) is “small” for any
in the RPM,
“reasonable” A and k. Insofar as we are working in the
RPM, we will not need cryptographic assumptions in order
(A, k) is: it will be
to specify just how small Advprv.rpm, Φ
a function of k and the total number of queries, q, it makes
to its π and π

if Advprv.rpm, Φ

−1 oracles.

G

G

We comment that our security deﬁnition allows Gb and
Ev to depend on π but not its inverse. This choice was
made simply because we have no occasion, in schemes, to
−1. On the other hand, it is essential that the adversary
use π
has access to both π and π

−1.

481

IND VERSUS SIM. The deﬁnition above formalizes se-
curity using the indistinguishability (ind) style deﬁnition
of BHR [5]. BHR also give a simulation-style deﬁnition
and show the two equivalent for side-information functions
having a property they called efﬁcient invertibility. We revisit
this equivalence in the RPM. The complicating issue is that
in an idealized model like the RPM there are two possibil-
ities for the simulator, namely to program or not program
the ideal primitive, here the random permutation. Somewhat
curiously, the proofs of BHR [5] show that, for efﬁciently-
invertible side-information functions, both are equivalent
to ind and thus to each other. The side-information func-
tion Φtopo was shown in BHR to be efﬁciently invertible.
We show in Appendix A that Φxor is as well. As a con-
sequence, our ind-based deﬁnition is equivalent to the sim-
based deﬁnition in the strong model where the simulator
does not program the random permutation.

∗

G

(cid:2)

∗ × N → Σ

(A, k) = 2 Pr

ANALOGS. One can easily give a random-oracle model
(ROM) deﬁnition to complement RPM one. Let Func be
with |π(x, (cid:4))| = (cid:4).
the set of all functions π : Σ
Give this a distribution by asserting that a random π (cid:2) Func
(x, (cid:4)) to (cid:4) uniformly random bits. Then let
(cid:3) − 1
A
π (cid:2) Func : Prv
Advprv.rom,Φ
G,Φ,k,π
be the probability, normalized to [0, 1], that the FINALIZE
procedure of game PrvG,Φ,k,π returns 1 when adversary A,
running with oracle π and given input 1k, interacts with the
speciﬁed game, making a single call to Garble. The only
difference between the ROM and RPM deﬁnitions is that in
the RPM setting, the adversary gets the random permutation
and its inverse, while in the ROM setting, it’s a random
function and there’s no inverse to give.

One can analogously give other idealized-model deﬁ-
nitions, the most important being the ideal-cipher model
(ICM). And one can of course give a standard-model deﬁ-
nition, simply by dropping all mention of π and its inverse.

DUAL-KEY CIPHERS. Again following BHR, we will de-
scribe our garbling schemes in terms of a dual-key cipher
(DKC). Now, however, these objects will be provided ora-
∗
, an
cles. Letting Ω be a set of functions π from Σ
(oracle-) DKC is a function E : Ω×Σk×Σk×Στ×Σk → Σk
that associates to π ∈ Ω and A, B ∈ Σk and T ∈ Στ some
permutation Eπ(A, B, T,·) : Σk → Σk.

to Σ

∗

In this paper we won’t need to develop any DKC security
notions: we shall be using the syntax of DKCs only to make
the descriptions of our protocols more clear.

GARBLING SCHEMES GA, GAX, GAXR. The scheme we
call Ga is based on an oracle DKC Eπ : {0, 1}k ×{0, 1}k ×
{0, 1}τ × {0, 1}k → {0, 1}k whose inverse is denoted D.
We associate to E the RPM-model garbling scheme Ga[E]
of Fig. 3. Wires carry k-bit tokens (strings) the last bit of
each is the token’s type.

proc Gbπ(1k, f )
(cid:2)
(n, m, q, A

, B

(cid:2)

, G) ← f

Ga

for i ← 1 to n + q do

t (cid:2){0, 1}
X

(cid:2){0, 1}k−1

0
i

t, X

1
i

(cid:2){0, 1}k−1

t

(cid:2)

proc Gbπ(1k, f )
(cid:2)
(n, m, q, A
, B
R (cid:2){0, 1}k−11
for i ← 1 to n do
(cid:2){0, 1}k−1

t (cid:2){0, 1}
X

0
i

, G) ← f

t, X

1
i

← X

0
i

⊕ R

GaX

, G) ← f

(cid:2)

proc Gbπ(1k, f )
(cid:2)
(n, m, q, A
, B
R (cid:2){0, 1}k−11
for i ← 1 to n do
(cid:2){0, 1}k−1

t (cid:2){0, 1}
X

0
i

GaXR

t, X

1
i

← X

0
i

⊕ R

(cid:2)(g), b ← B

a ← A
for i ← 0 to 1, j ← 0 to 1 do

for g ← n + 1 to n + q do
(cid:2)(g)
a, a ← lsb(A)
b , b ← lsb(B)

A ← X i
B ← X j
P [g, a, b] ← Eπ(A, B, g, X Gg (i,j)

g

)

for g ← n + 1 to n + q do

1
g

0
g

0
a

(cid:2)
g

← XOR
⊕ R

(cid:2)(g), G
← X

0
X
g
else
(cid:2)
G
⊕ R
g
0
X
for i ← 0 to 1, j ← 0 to 1 do
g

a ← A
(cid:2)(g), b ← B
if Gg = XOR then
← X
⊕ X
0
b , X
← AND
(cid:2){0, 1}k, X
A ← X i
B ← X j
P [g, a, b] ← Eπ(A, B, g, X Gg (i,j)

← X
a, a ← lsb(A)
b , b ← lsb(B)

0
g

1
g

g

)

for g ← n + 1 to n + q do

0
a

1
g

0
g

0
g

(cid:2)(g), G
(cid:2)
g
← X

a ← A
(cid:2)(g), b ← B
if Gg = XOR then
⊕ X
← X
0
b , X

← XOR
⊕ R
X
else
for a ← 0 to 1, b ← 0 to 1 do
), A ← X i
), B ← X j
← AND
(cid:2)
g

i ← a ⊕ lsb(X
j ← b ⊕ lsb(X
r ← Gg(i, j), G
if a = 0 and b = 0 then
← Eπ(A, B, T, 0k)
X r
← X r
g
X r
else P [g,a,b]← Eπ(A,B,g,X Gg (i,j)
g

⊕ R

0
a
0
b

a

g

b

g

)

(cid:3)

)

0
n+q

Ga

(cid:2)

(cid:2)

)

1
n

, P )
0
n, X

0
1 , X
lsb(X

, B
1
1 , . . . , X
0
n+q−m+1), . . . , lsb(X

F ← (n, m, q, A
e ← (X
d ← (cid:2)
return (F, e, d)
proc Evπ(F, X)
(n, m, q, A, B, P ) ← F
(X1, . . . , Xn) ← X
for g ← n + 1 to n + q do
a ← A(g), b ← B(g)
a ← lsb(Xa), b ← lsb(Xb)
Xg ← Dπ(Xa, Xb, g, P [g, a, b])

(cid:3)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

)

0
n+q

, P )
1
)
n

, G
0
n, X

0
1 , X
lsb(X

, B
1
1 , . . . , X
0
n+q−m+1), . . . , lsb(X

F ← (n, m, q, A
e ← (X
d ← (cid:2)
return (F, e, d)
proc Evπ(F, X)
(cid:2)
(n, m, q, A
(X1, . . . , Xn) ← X
for g ← n + 1 to n + q do
a ← A(g), b ← B(g)
a ← lsb(Xa), b ← lsb(Xb)
= XOR then Xg ← Xa ⊕ Xb
if G
else Xg ← Dπ(Xa, Xb, g, P [g, a, b])

, P ) ← F

, B

(cid:2)
g

GaX

return (Xn+q−m+1, . . . , Xn+q)
proc En(e, x)
(X
x1 ··· xn ← x
X ← (X x1
return X

Ga, GaX, GaXR
) ← e
)

1 , . . . , X xn
n

1
1 , . . . , X

0
n, X

0
1 , X

1
n

return (Xn+q−m+1, . . . , Xn+q)
proc De(d, Y )
(d1, . . . , dm) ← d
(Y1, . . . , Ym) ← Y
for i ← 1 to m do yi ← lsb(Yi) ⊕ di
return y ← y1 ··· ym

Ga, GaX, GaXR

(cid:3)

GaXR

(cid:2)

(cid:2)

(cid:2)

)

0
n+q

, P )
1
)
n

, G
0
n, X

0
1 , X
lsb(X

, P ) ← F

, B
1
1 , . . . , X
0
n+q−m+1), . . . , lsb(X

F ← (n, m, q, A
e ← (X
d ← (cid:2)
return (F, e, d)
proc Evπ(F, X)
(cid:2)
(n, m, q, A, B, G
(X1, . . . , Xn) ← X
for g ← n + 1 to n + q do
a ← A(g), b ← B(g)
a ← lsb(Xa), b ← lsb(Xb)
(cid:2)
if G
g
elsif a = 0 and b = 0 then
Xg ← Eπ(Xa, Xb, g, 0k)
else Xg ← Dπ(Xa, Xb, g, P [g, a, b])
return (Xn+q−m+1, . . . , Xn+q)
proc ev(f, x)
(n, m, q, A, B, G) ← f
x1 ··· xn ← x
for g ← n + 1 to n + q do
a ← A(g), b ← B(g)
xg ← Gg(xa, xb)
return xn+q−m+1 ··· xn+q

= XOR then Xg ← Xa ⊕ Xb

Ga, GaX, GaXR

Figure 3. Garbling schemes of this paper. Schemes Ga, GaX, and GaXR have the same En, De, and ev procedures, but their own Gb and Ev
procedures For a bit t, let {0, 1}k−1t denote the set of k-bit strings whose last bit is t, and t the complement bit of t.

To garble a circuit, we begin selecting two tokens for each
wire, one of each type. One of these will represent 0—
the token is said to have semantics of 0—while the other
i names the token of
will represent 1. The variable X b
wire i with semantics of b. Thus the token list e will map
x = x1 ··· xn ∈ {0, 1}n to X = (X x1
n ). For each
wire i we select random tokens of opposite type, making
the association between a token’s type and its semantics
random. We then compute q garbled tables, one for each
gate g. Table P [g,·,·] has four rows, row a, b used when

1 , . . . , X xn

the left incoming token is of type a and the right incoming
token is of type b. The token that gets encrypted for this row
is the one for the outgoing-wire with the correct semantics.
Given incoming tokens Xa and Xb we use their types to
determine which row of the garbled table to decrypt. The
description of the decoding data d is a bit vector; the ith
component is the last bit of the token of semantics 0 on the
ith output wire. Garbling scheme GaX augments what we
have described with the free-xor technique. Scheme GaXR
additionally incorporates the row-reduction technique.

482

III. INSTANTIATION OVERVIEW

in response, with regard to garbling in the RPM.

We discuss some of the challenges, and choices we make
The DKC EH (A, B, T, X) = H(A(cid:3)B(cid:3)T )⊕X is a natural
starting point, where H is a hash function. Our constructions
can be seen as realizations of this approach, but based on
a ﬁxed-key blockcipher. Kreuter, Shelat, and Shen [29] had
already considered H(A(cid:3)B(cid:3)T ) = AES256A(cid:4)B(T ) where
|A| =|B| =|T| = 128. Fixed-key AES provides a primitive π
with only a third the number of input bits as AES256.

One possibility is to build H from π in a manner that
will render H indifferentiable from a RO [16, 33]. However,
known constructions with this property will not be as ef-
ﬁcient as we would like. We aim to use a Davies-Meyer
type construction [34, 40], which applies the permutation
only once. Such constructions are not indifferentiable from
ROs [15, 16], necessitating considerable caution.

For simplicity we start by ignoring the tweak and consid-
ering the garbling of one-gate circuits. We present several
natural constructions and show that
they fail. We then
present our constructions, and ﬁnally explain how to in-
corporate tweaks so as to handle circuits with an arbitrary
number of gates.
INSTANTIATING GA. Consider instantiating the DKC of Ga
from a permutation π by Eπ(A, B, T, X) = π(A ⊕ B) ⊕ X.
The resulting scheme can be trivially broken, as follows.
Suppose that we garble an AND gate, as illustrated on the
top-left corner of Fig. 4, and suppose the adversary is given
the garbled table and tokens A and C. First, it opens the
third row to obtain token X. Next, let V be the ciphertext
in the last row. Then the adversary can obtain token D =
−1(V ⊕ X)⊕ A. Likewise, it can obtain token B. Now the
π
adversary can open every row of the garbled table, and all
security is lost.

We can translate the idea to an attack of advantage 1 on
prv security. The adversary asks (f0, f1, 00, 00) to Garble
where f0 is an AND gate and f1 is a gate that always
outputs 0. Following the idea above, the adversary open
every row of the garbled table. If each row encrypts the
same token then it outputs 1; otherwise, it outputs 0.
The attack arises because the adversary can invert
π(A ⊕ D) to get D. To break this invertibility we employ
the Davies-Meyer construction ρ(K) = π(K)⊕K to obtain
the instantiation

Eπ(A, B, T, X) = ρ(A ⊕ B) ⊕ X .

(1)

the adversary is given the garbled table and tokens A and B.
It ﬁrst xors the ciphertexts in the second and third rows
and obtains the string R. It then can open every row of the
garbled table. Now all security is lost.

We can translate the idea to an attack of advantage 1 on
prv security. The adversary queries (f0, f1, 00, 01) where
f0 is an AND gate and f1 is a gate such that f1(a, b) = a
for all a, b ∈ {0, 1}. Following the idea above, the adversary
can open every row of the garbled table, regardless of the
challenge bit. If there are three rows that encrypt the same
token then it outputs 0; otherwise, it outputs 1.

The attack above arises because of a “symmetry” between
tokens of the ﬁrst and second incoming wires, leading to the
use of ρ(A ⊕ B) twice to mask tokens of the output wire.
One possible way to break this symmetry is to apply some
simple operation to the token of the second incoming wire
before using it. For example, consider the instantiation

Eπ(A, B, T, X) = ρ(A ⊕ 2B) ⊕ X,

(2)
where doubling (B (cid:12)→ 2B) is multiplying in GF(2k) by the
group element x = 0k−210. The attack above is thwarted,
because the ciphertext in the third row is ρ(A ⊕ 2B) ⊕ X
while that in the second row is now ρ(A⊕2B⊕3R)⊕X⊕R,
where 3R means multiplying R by the group element x+1 =
0k−211 in GF(2k).

Still, instantiation (2) can be broken as follows. See the
illustration on the top-right corner of Fig. 4. Garble an OR
gate. Suppose the adversary is given the garbled table and
tokens A and B. First it opens the third row to obtain
token X. Let V be the ciphertext in the ﬁrst row. Query
V ⊕ A ⊕ 2B ⊕ X to π
−1, and let K be the answer. Then,
the adversary can obtain R = K ⊕ A⊕ 2B. It can now open
every row of the garbled table, and all security is lost.

We can translate the idea to an attack of advantage 1 on
prv security. The adversary queries (f0, f1, 00, 01) where f0
is an OR gate and f1 is an AND gate. Following the idea
above, the adversary can open every row of the garbled table,
regardless of the challenge bit. Using the decoding data, the
adversary can determine the semantics of the tokens on the
output wire. If there are three rows that encrypt the token
of semantics 1 then it outputs 1; otherwise, it outputs 0.

To thwart the attack above one can apply the multipli-
cation in GF(2k) to the ﬁrst incoming token as well; for
example, we can use the instantiation

Eπ(A, B, T, X) = ρ(2A ⊕ 4B) ⊕ X

(3)

We shall see in Theorem 1 that instantiation (1) indeed
makes Ga secure, once the tweaks are appropriately intro-
duced.
INSTANTIATING GAX. Yet instantiation (1) doesn’t work
for scheme GaX, even if the circuit remains a single gate.
Here is an attack. Again we garble an AND gate. The illus-
tration is given at the bottom-left corner of Fig. 4. Suppose

where 4B means applying the doubling operation to B
twice, that is, multiplying B by the group element x2 =
0k−3100 in GF(2k). The ciphertext in the ﬁrst row will be
π(2A⊕4B⊕2R)⊕2A⊕4B⊕X⊕3R. Since R (cid:2){0, 1}k−11
is secret, the attack fails. We shall see in Theorems 1 and 2
that instantiation (3) indeed makes both Ga and GaX secure,
after the gate-number tweak is appropriately introduced.

483

A αͳ

B αͲ

C αͲ

D αͳ

A αͳ

A ⊕ R

B αͲ

B ⊕ R



π(B 
π(B 
π(A 
π(A 

  ⊕ C 

  ⊕ D 

  ⊕ C 

  ⊕ D 

 ) ⊕ X
 ) ⊕ Y
 ) ⊕ X
 ) ⊕ X

X

Y

ͳ



ʹ

ρ(A 
ρ(A 
ρ(A 
ρ(A 

  ⊕ B 

  ⊕ B 

  ⊕ B 

  ⊕ B 

  ⊕ R

  ⊕ R ) ⊕ X 
 ) ⊕ X 
 ) ⊕ X 
  ⊕ R ) ⊕ X 

X

A αͳ

X ⊕ R

B αͲ

C αͲ

D αͳ

A αͳ

A ⊕ R

B αͲ

B ⊕ R

1

2

  ⊕ ʹB 

  ⊕ ʹB 

  ⊕ X 

X

  ⊕ ʹB 

  ⊕ ʹB 

  ⊕ X 

  ⊕ ʹR

X ⊕ R



  ⊕ R )⊕ A 
  ⊕ ͵R )⊕ A 
 )⊕ A 
  ⊕ ʹR )⊕ A 

  ⊕ ʹB 

  ⊕ ʹB 

  ⊕ X

  ⊕ ʹB 

  ⊕ ʹB 

π(A 
π(A 
π(A 
π(A 

  ⊕ X 

  ⊕ ͵R

͵

ƚƚĂĐŬϰ

E

yKZ

ρ(B 
ρ(B 
ρ(A 
ρ(A 

  ⊕ C 

  ⊕ D 

  ⊕ C 

  ⊕ D 

 ) ⊕ X
 ) ⊕ Y
 ) ⊕ X
 ) ⊕ X

ρ(B 
ρ(B 
ρ(A 
ρ(A 

  ⊕ C 

  ⊕ D 

  ⊕ C 

  ⊕ D 

 ) ⊕ V
 ) ⊕ U
 ) ⊕ U
 ) ⊕ V

5

3

4

X

Y

U

V

Figure 4. Attacks on DKC instantiations. Top-left: Eπ(A, B, T, X) = π(A⊕B)⊕X for scheme Ga. Bottom-left: Eπ(A, B, T, X) = ρ(A⊕B)⊕X for
scheme GaX, with ρ(K) = π(K)⊕K. Top-right: Eπ(A, B, T, X) = ρ(A⊕2B)⊕X for scheme GaX. Bottom-right: Eπ(A, B, T, X) = ρ(A⊕B)⊕X
for scheme Ga. The doubling here is multiplying in GF(2k) by x = 0k−210. In each wire, the top and bottom tokens have semantics 0 and 1 respectively.

THE NEED FOR THE TWEAK. Suppose now that one uses
instantiation (1) for scheme Ga, but in a circuit of multiple
gates. This leads to a new attack. Garble the circuit f illus-
trated at the bottom-right of Fig. 4. Suppose the adversary
is given the garbled tables and tokens A and D. (In the
illustration, only the garbled tables of the ﬁrst two gates are
shown.) It ﬁrst opens the last rows in the ﬁrst two tables to
get tokens X and V . Next, it xors the ciphertexts in the third
rows of the two ﬁrst tables, and then xors the resulting string
with X to get U. Likewise, the adversary can obtain Y . It
now can open every row of the last garbled table, and all
security is lost.

We can translate the idea to an attack of advantage 1 on
prv security, in which the adversary queries (f, f, 01, 11)
to obtain (F, X, d). Following the idea above, regardless of
the challenge bit, the adversary can open every row of the
last garbled table. Using d, the adversary can determine the
semantics of the tokens on the output wire. There is only
one row of the last garbled table that encrypts the token of
semantics 0. The token on wire 3 used as a key for this row
must have semantics 0. The adversary then can determine
the semantics of tokens on wire 3. Now evaluate F on X.
If the token obtained on wire 3 during the evaluation has
semantics 0 then output 0. Otherwise, output 1.

The attack above arises if the circuit contains two gates
that have the same pair of incoming wires. We therefore
introduce the tweak-based variants Eπ(A, B, T, X) = ρ(A⊕
B⊕ T )⊕ X and Eπ(A, B, T, X) = ρ(2A⊕ 4B⊕ T )⊕ X of
instantiations (1) and (3), respectively, with the tweak being
the gate index. We shall see in Theorems 1 and 2 that these
tweak-based instantiations indeed make Ga secure, and the
second one makes GaX secure.

Alternatively, for scheme Ga, one can avoid using tweaks

by demanding that no two gates have the same pair of
incoming wires. However, this condition is not sufﬁcient
when the free-xor trick is used, because one can arrange for
distinct wires to carry the same pair of tokens. For example,
consider the circuit in Fig. 5. Wires 6 and 7 there have the
same pair of tokens. This kind of subtle degeneracy serves
to emphasize the need for proofs.

OTHER WAYS TO DOUBLE. Besides the multiplication in
GF(2k) (named D1 below) doubling may have several other
interpretations, setting 2A to any of the following:

Finite ﬁeld multiply

D1 : (A (cid:13) 1) ⊕ (A[1] · const)
D2 : A (cid:13) 1
Logical left shift
D3 : A (cid:14) 1
Logical right shift
D4 : A ≪ 1
Circular left shift
D5 : A ≫ 1
Circular right shift
D6 : (A[1 :(cid:15)k/2(cid:16)](cid:13) 1)(cid:3) (A[(cid:15)k/2(cid:16)+1 : k](cid:13) 1)
D7 : (A[1 :(cid:15)k/2(cid:16)](cid:14) 1)(cid:3) (A[(cid:15)k/2(cid:16)+1 : k](cid:14) 1) SIMD right

SIMD left

We will later show that all of these methods “work” for the
schemes in this paper, although the security bounds differ
by a constant. In particular, we will identify a sufﬁcient con-
dition for the doubling map and a real number r associated
to it, this number showing up in our bounds. The reason for
attending to these different doubling methods is that “true”
doubling has the best security bound, but its implementation
is a bit slower than alternatives with slightly inferior bounds.

AN INSECURITY ISSUE IN PRIOR WORKS. Besides propos-
ing the free-xor trick, Kolesnikov and Schneider (KS) [28]
propose two instantiations of a DKC, suggesting to set

484

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
A αͳ

1

A ⊕ R

B αͲ

B ⊕ R

C αͲ

C ⊕ R

2

3

A ⊕ B

A ⊕ B ⊕ R

B ⊕ C

B ⊕ C ⊕ R

4

5

A ⊕ C αͳ

A ⊕ C ⊕ R αͲ

7

9

A ⊕ C

Y

Y ⊕ R

H( || T ) ⊕ H( || T ) ⊕ Y 
H( || T ) ⊕ H( || T ) ⊕ Y 

6

A ⊕ C ⊕ R

Y ⊕ R

8

Y

Figure 5. An attack on GaX with DKC E(A, B, T, X) = H(A[1 : k− 1] (cid:3) T )⊕H(B[1 : k− 1] (cid:3) T )⊕X. In each wire, the top token has semantics 0,
the bottom one has semantics 1. The table on the right is the garbled table of gate 8. Gate 9 negates the bit on wire 4, then ORs it with the bit on wire 8.

A,B(X) as either
ET

H(A[1 : k−1] (cid:3) B[1 : k−1] (cid:3) T ) ⊕ X or
(4)
H(A[1 : k−1] (cid:3) T ) ⊕ H(B[1 : k − 1] (cid:3) T ) ⊕ X (5)
where H : {0, 1}∗ → {0, 1}k is a hash function, to be mod-
eled as a random oracle. KS effectively show that GaX, built
on top of instantiation (4), leads to a secure two-party SFE
protocol. They claim that one can use instantiation (5) as
well. Pinkas, Schneider, Smart, and Williams (PSSW) [37]
implement both instantiations; their garbling schemes are
variants of Ga/GaX/GaXR, where each DKC’s tweak is a
nonce instead of the gate index. Subsequent works [22, 23,
27] use only (4) because of efﬁciency issues, but the authors
apparently continue to believe that (5) works ﬁne; see, for
example, [13, p. 5] and [27, p. 7].

We now show that an adversary can completely break
GaX if the DKC is instantiated by (5). Our attack also
applies to the GaX/GaXR variants of PSSW based on (5).
The key idea of the attack is that, as mentioned previously,
when one uses free-xor trick, different wires in the circuit
can be forced to share the same pair of tokens. Observe that
if A = B then instantiation (5) sends the plaintext in the
clear, as H(A[1 : k−1] (cid:3) T )⊕H(B[1 : k− 1] (cid:3) T )⊕X = X.
Suppose that we garble the circuit f in Fig. 5. Wires 6 and 7
have the same pair of tokens. As shown in the garbled table
of gate 8, we send both Y and Y⊕ R in the clear, and there
is no security whatsoever.

To translate the above to an attack of advantage 1 on
prv security, the adversary queries (f, f, 000, 100) to obtain
(F, X, d). Following the idea above, the adversary obtains all
tokens and opens every row of every garbled table. Using d,
it can determine the semantics of the tokens on the output
wire. There is only one row of the garbled table of gate 9 that
encrypts the token of semantics 0. The token on wire 4 used
as a key for this row must have semantics 1. The adversary
therefore can determine the semantics of the tokens on
wire 4. Now evaluate F on X. If the token obtained on
wire 4 has semantics 0 then output 1, otherwise output 0.

IV. SECURITY OF GA, GAX AND GAXR

∗

We will justify the security of our schemes in a common
framework. We deﬁne a class of DKCs that we call σ-
derived. Under various conditions on the map σ, we prove
security for our schemes.
σ-DERIVED DKCS. Let σ : {0, 1}k × {0, 1}k × {0, 1}τ →
{0, 1}(cid:3) be a function. We say that E is σ-derived DKC
if Eπ(A, B, T, X) = (π(K) ⊕ K)[1 : k] ⊕ X for K =
σ(A, B, T ) and the function σ satisﬁes the following two
conditions:
, B ⊕ B
) = σ(A, B, T ) ⊕
, T ⊕ T
(i) σ(A ⊕ A
∗
∗
∗ ∈ {0, 1}k and
∗
∗
∗
∗
) for every A, A
, B, B
, T
, B
σ(A
∗ ∈ {0, 1}τ , and
T, T

(ii) σ(0k, 0k, T ) (cid:9)= 0(cid:3) unless T = 0τ .
The injectivity indicator of σ is a number δ ∈ {0, 1}; it is 0
if and only if σ is tweak-wise injective, that is, σ(A, B, T ) (cid:9)=
∗
. The regularity of σ is the
σ(A
smallest r ∈ Z
(iii) Pr[x (cid:2){0, 1}k : σ(x, 0k, 0τ ) = s] ≤ r/2k and also
Pr[x (cid:2){0, 1}k : σ(0k, x, 0τ ) = s] ≤ r/2k for every
string s ∈ {0, 1}(cid:3).

) whenever T (cid:9)= T
+ such that

, B

The strong regularity of σ is the smallest r ∈ Z
+ such that
(iii) is satisﬁed and
(iv) Pr[x (cid:2){0, 1}k : σ(a·x, b·x, 0τ )⊕x0(cid:3)−k = s] ≤ r/2k
and Pr[x (cid:2){0, 1}k : σ(x, x, 0τ ) = s] ≤ r/2k for
every string s ∈ {0, 1}(cid:3) and every (a, b) ∈ {0, 1}2,
where 0 · x = 0

and 1 · x = x.

|x|

∗

∗

, T

∗

Each of our DKC instantiations is a σ-derived DKC; the
regularity, strong regularity, and injectivity indicator of
its σ are shown in Fig. 6. This claim can be veriﬁed
by a simple but tedious analysis. For example, consider
scheme A2 with the doubling method D2. Its function σ
is σ(A, B, T ) = 2A ⊕ 4B ⊕ T , satisfying both (i) and (ii),
and the injectivity indicator of this σ is 1. The regularity
is 4, because Pr[x (cid:2){0, 1}k : x (cid:13) 1 = s] ≤ 2/2k
and Pr[x (cid:2){0, 1}k : x (cid:13) 2 = s] ≤ 4/2k for every

485

 
 
 
 
DKC

doubling

regularity

strong regularity

injectivity indicator

A2

A3

A1
— D1 D2, D3 D4, D5 D6, D7 — D1 D2, D3 D4, D5 D6, D7
1
1
— 1
1

1
1
— 1
0

16
16

16
16

1
4

4
4

1
4

1

4
4

A4

0

Figure 6. Parameters for DKC instantiations. The strong regularity of A1 and A3 is huge (δ = 2k); the corresponding entries are dashed.

string s ∈ {0, 1}k. To verify that
the strong regular-
ity is also 4, suppose that one wants to show that, say
(x (cid:13) 1) ⊕ x = s] ≤ 4/2k for every
Pr[x (cid:2){0, 1}k :
string s ∈ {0, 1}k. Let x = x1 ··· xk. Note that function
f (x) = (x (cid:13) 1) ⊕ x returns

(x1 ⊕ x2) (cid:3) (x2 ⊕ x3) (cid:3) ··· (cid:3) (xk−1 ⊕ xk) (cid:3) xk,

and thus it is a permutation on {0, 1}k. Since x (cid:2){0, 1}k, it
follows that f (x) is also uniformly distributed over {0, 1}k.
Hence the chance that f (x) = s is at most 1/2k.
SECURITY OF GA. The following says that if E is σ-derived
and its σ has a small regularity, then Ga[E] is prv-secure
over Φtopo.
Theorem 1: Let A be an adversary that outputs circuits
of at most q gates and makes at most Q queries to π
−1. Let E be a σ-derived DKC, where σ : {0, 1}k ×
and π
{0, 1}k × {0, 1}τ → {0, 1}(cid:3), and let r and δ be the
regularity and injectivity indicators of σ, respectively. Then
(A, k) ≤ (6Qq + 15q2)/2(cid:3) + (30rQ +
Advprv.rpm, Φtopo
84rq)/2k + δ(42rQq + 69rq2)/2k.

Ga[E]

GaX[E]

regularity and injectivity indicators of σ, respectively. Then
(A, k) ≤ (6qQ + 15q2)/2(cid:3) + (36rQ +
Advprv.rpm, Φxor
108rq)/2k + δ(48rQq + 84rq2)/2k.
SECURITY OF GAXR. The following says that if E is
σ-derived and its σ has a small strong regularity,
then
GaXR[E] is prv-secure over Φxor. See Appendix D of the
full version [4] for the omitted proof.

Theorem 3: Let A be an adversary that outputs circuits
of at most q gates and makes at most Q queries to π and
−1. Let E be a σ-derived DKC, where σ : {0, 1}k ×
π
{0, 1}k × {0, 1}τ → {0, 1}(cid:3), and let r and δ be the strong
regularity and injectivity indicators of σ, respectively. Then
(A, k) ≤ (10qQ + 20q2)/2(cid:3) + (36rQ +
Advprv.rpm, Φxor
123rq)/2k + δ(48rQq + 94rq2)/2k.
DISCUSSION. The ﬁrst use of the free-xor technique was
justiﬁed in the ROM [28] but some subsequent works have
been able to justify the use of garbling schemes within the
standard model [3, 14]. We have not investigated whether
GaX or GaXR can proven secure in the standard model.

GaXR[E]

In the advantage formula above, we use the injectivity
indicator δ to “safeguard” the term (Qq + q2)/2k. For the
DKC instantiation A3, our implementation uses k = 80,
and in practice, q may go up to 232, say, as in recent
works [23, 29]. The presence of the term (Qq + q2)/2k
for A3 would result in a poor bound. Fortunately, this term
vanishes, because δ = 0 for A3. The advantage for A3 is
about (Qq + q2)/2(cid:3) + (Q + q)/2k, which is satisfactory for
(cid:4) = 128 and k = 80. In the DKC instantiation A1, for
example, δ = 1, but there we’ll use k = (cid:4) = 128, and the
advantage becomes about (Qq +q2)/2(cid:3), which is very good.
To obtain the desirable bound above, the proof for Theo-
rem 1, given in Appendix B, is complex. Without care the
advantage formula for E = A3, for example, might easily
include the term Qq/2k (without the guard of δ), which
results in a poor bound for the choice k = 80.
SECURITY OF GAX.
if E is
σ-derived and its σ has a small strong regularity,
then
GaX[E] is prv-secure over Φxor. See Appendix C of the
full version [4] for the omitted proof.
Theorem 2: Let A be an adversary that outputs circuits
of at most q gates and makes at most Q queries to π and
−1. Let E be a σ-derived DKC, where σ : {0, 1}k ×
π
{0, 1}k × {0, 1}τ → {0, 1}(cid:3), and let r and δ be the strong

The following says that

V. JUSTGARBLE AND ITS PERFORMANCE

We have built a system, JustGarble, to realize the ideas
described so far. The high speeds it achieves come from
use of a ﬁxed-key blockcipher and various implementation
optimizations. We explore these factors here.

ARCHITECTURE.
JustGarble starts with the idea (already
advocated in BHR [5]) that garbling should be decoupled
from MPC, oblivious transfer, and the compilation of pro-
grams into circuits. The separation of concerns facilitates
construction of an efﬁcient
it also necessitates
caution when comparing reported speeds.

tool, but

To facilitate speed and interoperability, JustGarble uses
a circuit representation that is simple and easy to work
with: SCD, for Simple Circuit Description. SCD closely
follows the formulation of circuits from BHR [5] recalled in
Section II. An SCD ﬁle starts with values n, m, q, followed
by arrays A, B, and G. If G is absent the ﬁle represents
a topological circuit. For cross-language and cross-platform
compatibility, values are encoded with MessagePack [18].

JustGarble consists of modules for building circuits, gar-
bling them, and evaluating garbled circuits; see Fig. 7.
The BUILD module can be used to construct circuits,
working at the level of individual gates or collections of
them. Constructed circuits are written to SCD ﬁles. The

486

f

GARBLE (Gb)

P, e, d

BUILD

COMPILER

−

f

P, X

EVALUATE (Ev)

Y

Figure 7. The JustGarble framework. The BUILD module or an external
compiler can be used to generate a circuit f described in the SCD format,
which is provided to the GARBLE module to get garbled tables P , token
list e, and decoding data d. The EVALUATE module takes as input a circuit
topology f−
also described in the SCD format, along with garbled tables
P , and a token list X, and outputs a token list Y .

GARBLE module realizes the Gb algorithm of Ga, GaX,
or GaXR. It can use any of the DKCs speciﬁed in this
paper. GARBLE takes in an SCD-described circuit f =
(n, m, q, A, B, G) and produces the garbled tables P that
comprise the ﬁnal component of the associated garbled
circuit F = (n, m, q, A, B, P ). The EVALUATE module
= (n, m, q, A, B), the
takes in a topological circuit f
garbled tables P needed to complete this, and a garbled
input X. It produces the garbled output Y . JustGarble also
includes simple routines (not shown in Fig. 7) to realize De,
which maps the garbled output Y to the corresponding
output y with the help of d.

−

The garbling module does not use the operating system
to generate the pseudorandom bits needed for tokens; such a
choice would not be cryptographically secure. Instead, pseu-
dorandom bits are also generated by ﬁxed-key AES, now
operating in counter mode. At present, we use a different
AES key than that employed for the random permutation
underlying the selected DKC. We have veriﬁed that it would
also work, cryptographically, to employ the same key for
these conceptually distinct tasks. But there would be a small
quantitative security loss, and the proofs would need to deal
with this complication. With GaX-A2, the measured time
savings from using the same permutation is at most 0.3 cpg.
through
AES-NI [21]. The system is written in C and employs
compiler intrinsics to access SSE4 [25] instructions and 128-
bit registers, which hold and manipulate the tokens.

JustGarble utilizes hardware AES support

JustGarble is entirely open-source and freely available for

download [26].

We did test AES without NI support. As an example,
Ga-A1 garbling and evaluation speeds are about 5.2 times
slower in software (1147 cpg and 263 cpg), while GaX-A2
speeds are about 4.5 times slower (239 cpg and 65.2 cpg).
EXPERIMENTAL METHODOLOGY. We ran our experiments
on an x86-64 Intel Core i7-970 processor clocked at
3.201 GHz with a 12MB L3 cache. Tests were compiled
with gcc version 4.6, optimization level -O3, with support
for SSE4 and AES-NI instructions through the -sse4 and

-maes ﬂags. The tests were run in isolation, with processor
frequency scaling turned off. We used the rdtsc instruction
to count cycles.

We ran tests in batches of 1000 runs each, noting the
median of the times recorded in the runs. This process was
repeated for 1000 batches, and the ﬁnal time reported is the
mean of the batch medians. The cache was warm during the
tests from initial runs. The standard deviation of the batch
medians does not exceed 0.25 cpg in any of the experiments.

AES-CIRCUIT BENCHMARKS. We measure garbling and
evaluation speeds on a circuit computing AES128K (X)
(hereafter simply AES) for a particular key K. This cor-
responds to a GC-based SFE of AES where the ﬁrst party
holds K and prepares a circuit for the second party, who
holds X and wants to compute AESK (X). We choose this
setting because it has been used as a benchmark in prior
work [22, 23, 29, 32], and hence helps compare our system
with existing ones.

We build the AES circuit as described in HEKM [23].
The key is ﬁrst expanded into 1280 bits. Conceptually, this is
done locally by the party holding the key. We use a different
S-box circuit [11] than HEKM, which results in a smaller
AES circuit. This is not signiﬁcant; as we measure speed in
cycles per gate, small differences in circuit size are unlikely
to have a noticeable effect on speed as long as the fraction
of xor gates is little changed. Overall, our AES circuit has
36,480 gates, of which 29,820 (82%) are xor.

The evaluation and garbling speeds of A1, A2, A3, and
A4 are listed in Fig. 1. For A2 we use doubling method
D7; for A4, we use D3. These choices will be explained
shortly. The fastest among our constructions, GaX with A2,
evaluates the AES circuit at 23.2 cpb (7.25 ns/gate) and
garbles it at 55.6 cpg (17.4 ns/gate). Overall, this comes
to 637 μs for garbling the AES circuit and 264 μs for
evaluating it.

Schemes A3 and A4 are a little slower than A1 and
A2. Part of the speed difference may be due to JustGarble
being better optimized for 128-bit tokens. Beyond this, there
are memory-alignment overheads in dealing with 10-byte
tokens: SSE4 instructions can have higher read and write
latencies when data is not 16-byte aligned [25].
The sizes SP we report
in Fig. 1 measure only the
contribution from the garbled tables: SP = |P|/8q. Focusing
on this value is justiﬁable because, in MPC applications, the
other components of the GC, its topology, will be known and
need not be communicated. Regardless, the size of the GC
that JustGarble makes will always be SF = SP + 8 bytes,
as gates are represented as four-byte numbers and we need
to record two of these per gate—one for each of arrays A
and B. Here we ignore the space to store n, m, q.

For the DKC A2, we implement doubling in many ways;
see the deﬁnition for methods D1–D7 in Section III. We ﬁnd
D6 and D7 the fastest, followed by D2 and D3, then D4 and

487

Primitive

E(A, B, T, X) =
π(K) ⊕ K ⊕ X, with K ← 2A ⊕ 4B ⊕ T

Permutation
Blockcipher E(K, T ) ⊕ X, with K ← A||B
Hash function H(K (cid:4) T )[1 :k] ⊕ X, with K ← A||B

Ga

GaX

GaXR

TE
52.1
256
875

TG
221
991
3460

TE
23.2
60.1
161

TG
55.6
172
566

TE
23.9
58.7
160

TG
56.4
171
568

Figure 8. Permutation-based, blockcipher-based, and hash-based garbling. The TE (time to evaluate) and TG (time to garble) values are in mean
cycles per gate (cpg) using the subject AES circuit. The ﬁrst method, A2, is based on a permutation π : {0, 1}k → {0, 1}k. The permutation chosen is
ﬁxed-key AES128. The second method, from KSS [29], uses a blockcipher E : {0, 1}2k × {0, 1}k → {0, 1}k. The selected blockcipher is AES256. The
last method, employed in [23], builds a DKC from a hash H : {0, 1}∗ → {0, 1}k. The hash function chosen is SHA-1.

D5, and ﬁnally D1. The speed of D6 and D7 (SIMD shift) is
due to the availability of a matching SSE4 instruction. The
speed difference between the fastest and slowest doubling
methods is ΔTE ≈ 7 cpg and ΔTG ≈ 11 cpg. We ﬁnd this
signiﬁcant enough to trade a small quantity in the security
bound, which is why we select A2 with D7 doubling. For
the DKC A4, which uses 10-byte tokens, similar experiments
lead us to select the doubling scheme D3.

LARGER CIRCUITS. The size of the garbled table for each
non-xor gate ranges from 30 bytes (GaXR with A3, A4) to
64 bytes (GaX with A1, A2). This means that even circuits
with hundreds of thousands of gates can ﬁt in the processor’s
L3 cache during evaluation. However, if the circuit is too big
to ﬁt entirely in the cache, per-gate garbling and evaluation
times will increase.

To understand the performance of JustGarble on circuits
larger than the cache size, we measured garbling and eval-
uation times of the modular exponentiation (MEXP) (“RSA
circuits”) and edit distance (EDT) circuits of KSS with
various input sizes. We used GaX with A2 (henceforth
GaX-A2); see Fig. 9. The MEXP-(cid:4) circuit takes inputs a
and b and returns ab mod c for c = 180(cid:3)−91. The EDT-m
circuit takes as inputs two m-bit strings and returns their edit
distance as a (lg m)-bit integer. We obtained these circuits
by patching the KSS compiler to produce outputs in SCD
format. The garbling and evaluation times (in cycles per
gate) are higher than the measured values for the AES circuit
due to higher latencies involved in reading data directly from
main memory. However, JustGarble is still several times
faster than KSS report. Taking RSA-32 as an example, KSS
report a garbling time of 4.53 seconds, which translates to
6546 cpg, while JustGarble uses 91.6 cpg, a 70x speedup.
At present, JustGarble cannot handle circuits that are
too big to ﬁt in main memory. An obvious direction for
future work is extending JustGarble with a streaming mode
of operation that can garble and evaluate large circuits by
keeping only a small portion in memory at any given point.

garbles

and

JustGarble

COMPARISONS.
evaluates
moderately-sized circuits about two orders of magnitude
faster than what recent MPC implementations of HKEM
and KSS report [23, 29]. For evaluating an AES circuit,
the best previously-reported ﬁgure comes
from KSS

[29], garbling the circuit
in 80 ms. The fastest among
our own constructions, GaX using A2, does the job in
638 μs. We note that both systems use AES-NI and SSE4
instructions and the free-xor optimization, and that,
in
both cases,
the reported times are for garbling alone,
excluding other operations and network overhead. One
reason JustGarble performs better is that it spends less time
on non-cryptographic operations, by which we mean all
operations other than the DKC computations. Moreover,
using a ﬁxed-key DKC like A2 results in a sizable gain in
performance, in spite of the large percentage of xor gates
(82%) in the AES circuit. We measured the contributions
of both of these factors as below.

JustGarble spends about 23% and 43% of its time on
non-cryptographic operations when GaXR-A2 does garbling
and garbled-circuit evaluation, respectively. In contrast, KSS
measure AES256 (with AES-NI) overhead at 225 cycles
per invocation but report an overall GaXR garbling time of
over 6000 cpg, suggesting that close to 95% of the garbling
time is non-cryptographic overhead. The reduced overhead is
likely connected to our simple representation of circuits, one
consequence of which is the absence of a need to maintain
a queue of ready gates. A downside of this simple circuit
representation is that, unlike HEKM and KSS, JustGarble
cannot handle circuits that do not ﬁt in memory.

To measure the contribution of the DKC itself we imple-
mented within JustGarble the blockcipher-based DKC from
KSS and the hash-function based DKC from HEKM; see
Fig. 8. Let us focus on GaXR, as free-xor and garbled-row
reduction are both employed in the MPC systems of KSS
and HEKM. Comparing the ﬁrst and second rows, the DKC-
attributable speedup we get by using a permutation instead
of a blockcipher is 2.5-fold improvement in evaluation time
and 3-fold improvement in garbling time. Comparing the
ﬁrst and the third rows, the DKC-attributable speedup we
get by using a permutation instead of a cryptographic hash
function is 6.7-fold improvement in evaluation time and 10-
fold improvement in garbling time. One may conclude that
the improved DKCs play a large role in our performance
gains—a factor of about 2.5 to 10—yet more mileage is
obtained through other aspects of JustGarble.

488

Circuit Gates

Xor gates

TE

MEXP-16
MEXP-32
MEXP-64
EDT-255

0.21 M
1.75 M
14.3 M
15.5 M

0.14 M 44.1
1.15 M 45.3
9.31 M 44.6
9.11 M 48.4

TG

91.6
96.3
95.8
101.3

Figure 9. Larger circuits. Evaluation times (TE) and garbling times (TG)
are in median cycles per gate using GaX-A2. The modular exponentiation
(MEXP) and edit distance (EDT) circuits are described in text. Gate counts
are in millions of gates (1M = 1 million gates).

ACKNOWLEDGMENTS

Many thanks to the NSF, who sponsored this work under

CNS 0904380, CNS 1116800, and CNS 1228828/90.

REFERENCES

[1] M. Abadi and J. Feigenbaum. Secure circuit evaluation.

Journal of Cryptology, 2(1):1–12, 1990.

[2] M. Abdalla, X. Boyen, C. Chevalier, and D. Pointcheval.
Distributed public-key cryptography from weak secrets.
In
PKC 2009, volume 5443 of LNCS, pages 139–159. Springer,
Mar. 2009.

[3] B. Applebaum. Garbling XOR gates “for free” in the standard
model. In TCC 2013, volume 7785 of LNCS, pages 162–181,
Springer, 2013.

[4] M. Bellare, V. Hoang, S. Keelveedhi, and P. Rogaway. Efﬁ-
cient garbling from a ﬁxed-key blockcipher. ePrint Archive,
2013. Full version of this paper.

[5] M. Bellare, V. Hoang, and P. Rogaway.

garbled circuits.
Security (CCS’12). ACM, 2012.
Archive, Report 2012/265, May, 2012.

Foundations of
In ACM Computer and Communications
Full version as ePrint

[6] M. Bellare and P. Rogaway. Random oracles are practical: A
paradigm for designing efﬁcient protocols. In ACM CCS 93,
pages 62–73. ACM Press, Nov. 1993

[7] A. Ben-David, N. Nisan, and B. Pinkas. FairplayMP: a system
for secure multi-party computation. In ACM CCS 08, pages
257–266. ACM Press, Oct. 2008.

[8] G. Bertoni, J. Daemen, M. Peeters, and G. Assche. Keccak

speciﬁcations. Submission to NIST, 2009.

[9] P. Bogetoft, D. Christensen, I. Damg˚ard, M. Geisler, T. Jakob-
sen, M. Krøigaard, J. D. Nielsen, J. B. Nielsen, K. Nielsen,
J. Pagter, M. Schwartzbach, and T. Toft. Secure multiparty
computation goes live. In FC 2009, volume 5628 of LNCS,
pages 325–343. Springer, Feb. 2009.

[10] M. Burkhart, M. Strasser, D. Many, and X. Dimitropoulos.
Sepia: privacy-preserving aggregation of multi-domain net-
work events and statistics. In USENIX Security Symposium,
pages 223–240, 2010.

[11] D. Canright. A very compact S-box for AES. Cryptographic
Hardware and Embedded Systems–CHES 2005, pages 441–
455, 2005.

489

[12] S. Choi, K. Hwang, J. Katz, T. Malkin, and D. Rubenstein.
Secure multi-party computation of boolean circuits with ap-
plications to privacy in on-line marketplaces.
In CT-RSA,
pages 416–432, 2012.

[13] S. Choi, J. Katz, R. Kumaresan, and H. Zhou. On the security
of the “free-XOR” technique. Cryptology ePrint Archive,
Report 2011/510, Sep 2011.

[14] S. Choi, J. Katz, R. Kumaresan, and H. Zhou. On the security
of the “free-xor” technique. In TCC 2012, volume 7194 of
LNCS, pages 39–53. Springer, Mar. 2012.

[15] J. Coron, Y. Dodis, C. Malinaud, and P. Puniya. Merkle-
Damg˚ard revisited: how to construct a hash function.
In
CRYPTO 2005, volume 3621 of LNCS, pages 430–448.
Springer, Aug. 2005.

[16] Y. Dodis, T. Ristenpart, and T. Shrimpton. Salvaging Merkle-
Damg˚ard for practical applications.
In EUROCRYPT 2009,
volume 5479 of LNCS, pages 371–388. Springer, Apr. 2009.

[17] Y. Ejgenberg, M. Farbstein, M. Levy, and Y. Lindell. SCAPI:
the secure computation application programming interface.
Cryptology ePrint Archive, Report 2012/629, 2012.

[18] S. Furuhashi. The MessagePack format. http://msgpack.org.

[19] O. Goldreich. Cryptography and cryptographic protocols.

Manuscript, June 9 2001.

[20] O. Goldreich, S. Micali, and A. Wigderson. How to play any
mental game, or a completeness theorem for protocols with
honest majority. In 19th ACM STOC, pages 218–229. ACM
Press, May 1987.

[21] S. Gueron. Advanced encryption standard (AES) instructions

set. Intel Corporation, 25, 2008.

[22] W. Henecka, S. K¨ogl, A. Sadeghi, T. Schneider, and
I. Wehrenberg. TASTY: tool for automating secure two-party
computations. In ACM CCS 10, pages 451–462. ACM Press,
Oct. 2010.

[23] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster secure two-
party computation using garbled circuits. In USENIX Security
Symposium, 2011.

[24] Y. Huang, C. Shen, D. Evans, J. Katz, and A. Shelat. Efﬁcient
secure computation with garbled circuits. In ICISS, volume
7093 of Lecture Notes in Computer Science, pages 28–48.
Springer, 2011.

[25] Intel. Intel SSE4 manual. http://software.intel.com/ﬁle/17971/

[26] JustGarble source. http://cseweb.ucsd.edu/groups/justgarble

[27] K. J¨arvinen, V. Kolesnikov, A. Sadeghi, and T. Schneider. Em-
bedded SFE: Ofﬂoading server and network using hardware
tokens. In FC 2010, volume 6052 of LNCS, pages 207–221.
Springer, Jan. 2010.

Improved garbled circuit:
[28] V. Kolesnikov and T. Schneider.
free XOR gates and applications.
In ICALP 2008, Part II,
volume 5126 of LNCS, pages 486–498. Springer, July 2008.

[29] B. Kreuter, A. Shelat, and C. Shen. Billion-gate secure
computation with malicious adversaries.
In Proceedings of
the 21th USENIX Security Symposium (USENIX 2012), 2012.
Full version as Cryptology ePrint Archive, Report 2012/179.

[30] Y. Lindell and B. Pinkas. A proof of security of Yao’s protocol
for two-party computation. Journal of Cryptology, 22(2):161–
188, Apr. 2009.

[31] Y. Lindell, B. Pinkas, and N. Smart.

Implementing two-
party computation efﬁciently with security against malicious
adversaries. In SCN 08, volume 5229 of LNCS, pages 2–20.
Springer, Sept. 2008.

[32] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay — a
secure two-party computation system. In Proceedings of the
13th conference on USENIX Security Symposium-Volume 13,
pages 20–20. USENIX Association, 2004.

[33] U. Maurer, R. Renner, and C. Holenstein. Indifferentiability,
impossibility results on reductions, and applications to the
random oracle methodology. In TCC 2004, volume 2951 of
LNCS, pages 21–39. Springer, Feb. 2004.

[34] A. Menezes, P. van Oorschot, and S. Vanstone. Handbook of

Applied Cryptography. CRC Press, 1996.

[35] M. Naor, B. Pinkas, and R. Sumner. Privacy preserving
auctions and mechanism design.
In Proceedings of the 1st
ACM conference on Electronic commerce, pages 129–139.
ACM, 1999.

[36] J. Nielsen and C. Orlandi. LEGO for two-party secure
computation. Theory of Cryptography, pages 368–386, 2009.

[37] B. Pinkas, T. Schneider, N. Smart, and S. Williams. Secure
In ASIACRYPT 2009,
two-party computation is practical.
volume 5912 of LNCS, pages 250–267. Springer, Dec. 2009.

[38] P. Rogaway. The round complexity of secure protocols. MIT

Ph.D. Thesis, 1991.

[39] P. Rogaway and J. Steinberger.

Constructing crypto-
graphic hash functions from ﬁxed-key blockciphers.
In
CRYPTO 2008, volume 5157 of LNCS, pages 433–450.
Springer, Aug. 2008.

[40] R. Winternitz. A secure one-way hash function built from
DES. Proceedings of the IEEE Symposium on Information
Security and Privacy, pages 88–90. IEEE Press, 1984.

[41] A. Yao. How to generate and exchange secrets. In Founda-
tions of Computer Science, 27th Annual Symposium on, pages
162–167. IEEE, 1986.

[42] A. Yao. Protocols for secure computations. In Foundations of
Computer Science, 23rd Annual Symposium on, pages 160–
164. IEEE, 1982.

APPENDIX A.

INVERTIBILITY OF Φxor

We recall the notion of efﬁcient invertibility of BHR [5].
Let Φ be a side-information function. An algorithm M is
(cid:3)
called a (Φ, ev)-inverter if on input (φ, y), where φ = Φ(f
)

490

(cid:3)

(cid:3)

(cid:3)

and x ∈ {0, 1}f

(cid:2)

, x

) for some f

.n, it returns
and y = ev(f
an (f, x) satisfying Φ(f ) = φ and ev(f, x) = y. We say that
(Φ, ev) is efﬁciently invertible if there is a polynomial-time
(Φ, ev)-inverter.

Proposition 1: There exists a cubic-time (Φxor, evcirc)-

inverter.

Proof of Proposition 1: We specify a cubic-time
(Φxor, evcirc)-inverter Mxor as follows. Let Gauss(S) be the
algorithm that takes as input a system S of linear equations
in GF(2), uses Gaussian elimination to solve it, and then
lets each free variable be 0. The inverter Mxor gets as input
) and a string y ∈ {0, 1}m, and
(cid:3)
φ = (n, m, q, A, B, G
proceeds as follows.

proc Mxor(φ, y)
(n, m, q, A, B, G
for g ∈ {n + 1, . . . , n + q} do

(cid:2)) ← φ, y1 ··· ym ← y, S ← ∅

= XOR then

a ← A(g), b ← B(g)
(cid:2)
if G
if g ≤ n + q − m then S ← S ∪ {xa ⊕ xb ⊕ xg = 0}
g
else S ← S ∪ {xa ⊕ xb = yg−(n+q−m)}

(x1, . . . , xn+q−m) ← Gauss(S)
for (g, i, j) ∈ {n + 1, . . . , n + q} × {0, 1} × {0, 1} do
= XOR then Gg ← XOR else Gg(i, j) ← xg
(cid:2)
if G
f ← (n, m, q, A, B, G), x ← x1 ··· xn
g
return (f, x)

We then have (f, x) as desired. The system S has q + n− m
variables, and at most q equations. Hence the running time
of Gauss(S) is at most O
, and so is Mxor’s
running time.

(q + n)3

(cid:4)

(cid:5)

APPENDIX B.

PROOF OF THEOREM 1

is,

In our code, a procedure with the keyword “private”
is local to the caller, and thus cannot be invoked by the
adversary. It can be viewed as a function-like macro in
the C/C++ programming language. That
it still has
read/write access to the variables of the caller, even if
these variables are not its parameters. Consider games G0–
G2 in Fig. 10. They share the same code for procedure
Garble, but each has a different implementation of a local
procedure GarbleRow. The adversary A makes queries
to procedures Π and Π−1 to access an ideal permutation
π, which is implemented lazily. Without loss of generality,
assume that q + Q ≤ 2k−2/r; otherwise the theorem is
trivially true.

We reformulate game PrvGa,Φtopo,k,π as game G0. Recall
that in the scheme Ga, each wire i carries tokens X 0
i and X 1
i
with semantics 0 and 1 respectively. If wire i ends up having
value (semantics) vi in the computation v ← ev(fc, xc),
becomes
where c is the challenge bit,
visible to A while X vi
stays invisible. Game G0 makes
this explicit. It picks for each wire i a “visible” token and
an “invisible” one. Each garbled row that can be opened by
visible tokens will be built directly in Garble. To construct

then token X vi
i

i

(cid:2)

(cid:2)

, B

, G) ← fc

proc Garble(f0, f1, x0, x1)
(n, m, q, A
for i ← 1 to n + q do
vi ← ev(fc, xc, i), ti (cid:2){0, 1}, X vi
(cid:2){0, 1}k−1
for g ← n + 1 to n + q, i ← 0 to 1, j ← 0 to 1 do
a ← A
(cid:2)(g)
b , a ← lsb(A), b ← lsb(B), K ← σ(A, B, g)
A ← X i
if i = va and j = vb then P [g, a, b] ← (Π(K) ⊕ K)[1 : k] ⊕ X vg
F ← (n, m, q, A
, P ), X ← (X v1
d ← (cid:2)
)
return (F, X, d)

(cid:2)(g), b ← B
a, B ← X j
(cid:2)

n+q−m+1), . . . , lsb(X

1 , . . . , X vn
n

ti, X vi
i

lsb(X

0
n+q

, B

(cid:3)

)

(cid:2)

0

g

i

(cid:2){0, 1}k−1

ti

else P [g, a, b] ← GarbleRow()

private proc GarbleRow()
S (cid:2){0, 1}(cid:3)
if K ∈ Dom(π) or S ⊕ K ∈ Ran(π) then
←− Use in game G0
, π[K] ← S ⊕ K

bad ← true
S ← Π(K) ⊕ K

Y ← S[1 : k] ⊕ X Gg (i,j)
return Y

g

private proc GarbleRow()
S (cid:2){0, 1}(cid:3), Y ← S[1 : k] ⊕ X Gg (i,j)
BadDom ← BadDom ∪ {K}
BadRan ← BadRan ∪ {K ⊕ S}
return Y

g

−1[v]

Game G0 / Game G1
proc Π(u)
if u (cid:9)∈ Dom(π) then π[u] (cid:2){0, 1}(cid:3)\Ran(π)
return π[u]
proc Π−1(v)
if v (cid:9)∈ Ran(π) then

u (cid:2){0, 1}(cid:3)\Dom(π), π[u] ← v

return π
proc Π(u)
Game G2
if u ∈ BadDom then bad ← true
if u (cid:9)∈ Dom(π) then π[u] (cid:2){0, 1}(cid:3)\Ran(π)
return π[u]
proc Π−1(v)
if v ∈ BadRan then bad ← true
if v (cid:9)∈ Ran(π) then

u (cid:2){0, 1}(cid:3)\Dom(π), π[u] ← v

return π

−1[v]

Figure 10. Games for the proof of Theorem 1. Each set is initialized to be ∅. Initially, procedure Initialize() samples the challenge bit c (cid:2) {0, 1}.

each other garbled row, we invoke the “private” procedure
GarbleRow, which inherits all variables of Garble.

We explain the game chain up until the terminal game.
G0 → G1 : the two games are identical until either game
sets bad. In these games, we sample a uniformly random
string S and want to set π(K) to K ⊕ S. This may cause
−1(K ⊕ S) is already deﬁned,
inconsistency if π(K) or π
triggering bad. In this case, G0 resets S to the consistent
value, but game G1 does nothing. Hence in game G1, a point
v ∈ Ran(π) may have several preimages, and in that case
−1[v] means an arbitrary preimage.
π

We now bound the chance that G1 sets bad. Consider the
ith invocation of GarbleRow. It triggers bad to true if
its string K falls into Dom(π) or S ⊕ K falls into Ran(π),
with S (cid:2){0, 1}(cid:3). Since |Ran(π)| ≤ (Q + q + i − 1), the
latter happens with probability at most (Q + i + q − 1)/2(cid:3).
Let K = σ(A, B, g). We claim that the chance that K ∈
the size of Dom(π) ∩ (cid:6)
Dom(π) is at most 6r/2k + Nir(2δ + 1)/2k, where Ni is
, which
is at most |Dom(π)| ≤ Q + q + i − 1. By the union bound,

σ(x, y, g) | x, y ∈ {0, 1}k

(cid:7)

491

the chance that G1 sets bad is at most

3q(cid:8)

Q + q + i − 1

rNi(2δ + 1)

+

6r
2k +
3rQ + 30rq

.

+

+

2(cid:3)

2k

2k

i=1

2(cid:3)
2k
≤ 3qQ + 7.5q2
δ(9rqQ + 22.5rq2)
If δ = 1 the last inequality is obvious, as Ni ≤ Q + q +
i − 1. For the case δ = 0, note that for each string s there
is at most one value g such that s ∈ {σ(x, y, g) | x, y ∈
{0, 1}k}. Hence when we sum up the numbers Ni, because
the invocations of GarbleRow use each tweak value at
most three times, we count each point in Dom(π) at most
three times, so the sum is at most 3|Dom(π)| ≤ 3(Q + 4q).
We now justify the claim above. Consider the moment
that procedure Garble makes the ith call to GarbleRow.
Let D1 be the set of points in Dom(π) created by adversarial
queries before its querying Garble, and let D2 be the
set of points in Dom(π) created by procedure Garble
so far. Then D1 ∪ D2 = Dom(π). Recall
that K =
σ(A, B, g) = σ(A, 0k, 0τ ) ⊕ σ(0k, B, 0τ ) ⊕ σ(0k, 0k, g).
Because A (cid:2){0, 1}k and r is the regularity of σ, it follows
that Pr[σ(A, 0k, 0τ ) = s] ≤ r/2k for any string s ∈ {0, 1}(cid:3).
Since A is independent of B and all points in D1, the chance
that K ∈ D1 is at most rNi/2k.

∗

∗

∗

∗

∗

∗

∗

∗

, g

, B

= σ(A

, and B

, and B

and B ≡ B
). If A ≡ A
∗
belong to different gates, and thus g (cid:9)= g
∗
) = σ(0k, 0k, g ⊕ g
= σ(A, B, g) ⊕ σ(A, B, g
∗

What remains is to show that Pr[K ∈ D2] ≤ 6r/2k +
∗ ∈ D2. Let
2Nirδ/2k. Consider an arbitrary point K
∗
then K
K
∗
. Hence
and K
) (cid:9)=
K ⊕ K
∗
0(cid:3). Otherwise, wlog, suppose that A[1 : k−1] is independent
. For any string s ∈ {0, 1}(cid:3), as r is
of B, A
the regularity of σ, there are at most r strings x such that
∗
σ(x, 0k, 0τ ) = s. Given B, A
, because each but
the last bit of A is still uniformly random, the conditional
probability that A falls into one of the r strings above is
at most 2r/2k, and thus the conditional probability that
] ≤
σ(A, 0k, 0τ ) = s is at most 2r/2k. Hence Pr[K = K
2r/2k. Moreover, if the injectivity indicator δ = 0 and
] ≤
g (cid:9)= g
∗
] ≤ 2rδ/2k otherwise.
2r/2k if g = g
Summing up, Pr[K ∈ D2] ≤ 6r/2k + 2Nirδ/2k, because
there are most three elements of D2 using the tweak g.
G1 → G2 : in game G1 we write π[K] ← S ⊕ K,
but game G2 omits this step. In addition, we maintain two
sets, BadDom and BadRan, each of which are initialized
to the empty set. Each call to GarbleRow will add K
to BadDom and S ⊕ K to BadRan. The two games are
identical until G2 sets bad, that is, when A happens to query
Π(u) with u ∈ BadDom, or Π−1(v) with v ∈ BadRan.
Since G2 samples S uniformly at random, and doesn’t store
it in π, the output of GarbleRow() is uniformly random,
independent of the token that S masks.

. In other words, Pr[K = K

then K (cid:9)= K

, and Pr[K = K

∗

∗

∗

∗

∗

We now bound the chance that G2 sets bad. Consider an
arbitrary point K ∈ BadDom. It has a corresponding point
K⊕S ∈ BadRan. Let K = σ(A, B, g). Either A or B must
be invisible. Wlog, suppose that A is invisible. Condition on
the output of Garble. Initially, as each but the last bit of
A is still uniformly random and the regularity of σ is r,
the conditional probability that K = s is at most 2r/2k for
any string s ∈ {0, 1}(cid:3). Consider a query u to Π. Each prior
query to Π or Π−1 removes at most one value of K. Since
there are at most q + Q queries to Π and Π−1 (procedure
Garble only queries Π for q rows that can be opened by
visible tokens), the chance that u hits K is at most
≤ 4r/2k,

2r/2k

2r

1 − 2(Q + q)r/2k =

2k − 2r(Q + q)

where the last inequality is due to the assumption Q + q ≤
2k−2/r. By the union bound, the chance that u ∈ BadDom
is at most 12rq/2k. But if the injectivity indicator δ = 0
then there is at most one possible value of g such that u ∈
{σ(x, y, g) | x, y ∈ {0, 1}k}, and, consequently, Pr[u ∈
BadDom] ≤ 12r/2k because each tweak value is used at
most three times in BadDom. Hence in general, Pr[u ∈
BadDom] ≤ 12r(qδ + 1)/2k. Likewise, for each query v to
Π−1, the chance that v ∈ BadRan is at most 12r(qδ+1)/2k.
By the union bound, the chance that game G2 sets bad is

ti

i

(cid:2)

, B

ti, Ii (cid:2){0, 1}k−1

← Vi, X vi
(cid:2)(g),

proc Garble(f0, f1, x0, x1)
(cid:2)) ← Φtopo(f0)
(n, m, q, A
vq+n−m+1 ··· vq+n ← ev(f0, x0)
for i ← 1 to n + q do
ti (cid:2){0, 1}, Vi (cid:2){0, 1}k−1
for i ← n + q − m + 1 to n + q do
← Ii
X vi
for g ← n + 1 to n + q do
i
a ← A
b ← B
(cid:2)(g)
for (A, B) ∈ {Va, Ia} × {Vb, Ib} do
a ← lsb(A), b ← lsb(B), K ← σ(A, B, g)
if A = Va and B = Vb then
Y ← (Π(K) ⊕ K)[1 : k] ⊕ Vg
else Y (cid:2){0, 1}k
P [g, a, b] ← Y
(cid:2)
(cid:2)
, B

, P ), X ← (V1, . . . , Vn)

(cid:3)

n+q−m+1), . . . , lsb(X

0
n+q

)

F ← (n, m, q, A
d ← (cid:2)
return (F, X, d)

lsb(X

0

Figure 11. Rewritten game G2 of the proof of Theorem 1. This game
depends solely on the topological circuit f− = Φtopo(f0) = Φtopo(f1)
and the output v = ev(f0, x0) = ev(f1, x1). Procedures Π and Π−1
lazily implement a random permutation and its inverse, respectively.

at most

12r(Q + q)(qδ + 1)/2k
= (12rQ + 12rq)/2k + δ(12rQq + 12rq

2

)/2k .

The output of game G2 is
ANALYSIS OF GAME G2.
A
2 (k)] = 1/2.
independent of the challenge bit c. Hence Pr[G
−
and the ﬁnal
To justify this, from a topological circuit f
output v = ev(fc, xc), which is independent of c, we can
rewrite the code of procedure Garble of game G2 as
shown in Fig. 11. There, we refer to the visible token of
wire i as Vi, and its invisible counterpart as Ii, omitting
the semantics of these tokens. Each garbled row is an
independent, uniformly random string, except for rows that
can be opened by visible tokens. Summing up,

Advprv.rpm, Φtopo

Ga[E]

(A, k)

0 (k)] − Pr[G
A

A
2 (k)])

+

30rQ + 84rq

2k

+

δ(42rQq + 69rq2)

2k

,

= 2(Pr[G
≤ 6qQ + 15q2

2(cid:3)

concluding the proof.

492

