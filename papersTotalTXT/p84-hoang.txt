Automated Analysis and Synthesis of
Authenticated Encryption Schemes

Viet Tung Hoang
University of Maryland
Georgetown University
tvhoang@umd.edu

Jonathan Katz

University of Maryland
jkatz@cs.umd.edu

Alex J. Malozemoff
University of Maryland
amaloz@cs.umd.edu

ABSTRACT
Authenticated encryption (AE) schemes are symmetric-key
encryption schemes ensuring strong notions of conﬁden-
tiality and integrity. Although various AE schemes are
known, there remains signiﬁcant interest in developing
schemes that are more eﬃcient, meet even stronger secu-
rity notions (e.g., misuse-resistance), or satisfy certain non-
cryptographic properties (e.g., being patent-free).

We present an automated approach for analyzing and syn-
thesizing blockcipher-based AE schemes, signiﬁcantly ex-
tending prior work by Malozemoﬀ et al. (CSF 2014) who syn-
thesize encryption schemes satisfying conﬁdentiality only.
Our main insight is to restrict attention to a certain class of
schemes that is expressive enough to capture several known
constructions yet also admits automated reasoning about
security. We use our approach to generate thousands of
AE schemes with provable security guarantees, both known
(e.g., variants of OCB and CCM) and new. Implementing
two of these new schemes, we ﬁnd their performance com-
petitive with state-of-the-art AE schemes.

1.

INTRODUCTION

Historically, symmetric-key encryption schemes were de-
signed only to ensure conﬁdentiality. With the realization
that practitioners were often (implicitly) assuming that such
schemes also provided some form of integrity, however, re-
searchers began explicit consideration and analysis of en-
cryption schemes additionally satisfying that property [16,
7]. Since then, a tremendous amount of research has focused
on the design of authenticated encryption (AE) schemes en-
suring both conﬁdentiality and integrity.

While a generic construction of an AE scheme based on
any CPA-secure encryption scheme and message authenti-
cation code is possible [7], more eﬃcient AE schemes can
be devised. One example is OCB [25, 23, 17], which is on-
line (i.e., requires only a single pass over the data), prov-
ably secure, and very fast. Unfortunately, due to patent
restrictions, the scheme never gained widespread use. Other

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, CO, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813636.

well-known AE schemes include CCM [10] and GCM [20];
however, these schemes are slower than OCB [17] and have
other disadvantages as well.1 Overall, the problem of de-
signing AE schemes is still of interest, as evidenced by the
ongoing CAESAR competition [9].

In designing eﬃcient AE schemes, one might fail to realize
opportunities to improve eﬃciency. For example, OCB was
ﬁrst introduced in 2001 [25] and its authors have been active
in maintaining and optimizing the scheme, releasing OCB2
in 2004 [23] and OCB3 in 2011 [17]. However, recently, Mine-
matsu [21] showed that a simple change to OCB’s design al-
lows one to use only the forward direction of the underlying
blockcipher, saving chip area in hardware realizations.

In this work, we propose an automated approach for an-
alyzing and synthesizing AE schemes. Our approach builds
on and extends the work of Malozemoﬀ et al. [19], who
explored a similar goal but limited to encryption schemes
achieving conﬁdentiality only. At a high level, as in their
work, we view an encryption scheme as being deﬁned by a
directed acyclic graph in which each node corresponds to
an instruction (e.g., XORing two values) and is associated
with an intermediate n-bit value. The graph deﬁnes how
individual message blocks are processed; messages of arbi-
trary length are encrypted by iterating the computation de-
ﬁned by this graph over all the blocks of the message. (We
actually consider processing two message blocks at a time,
as this allows us to capture more AE schemes within our
framework.) We develop a type system for the nodes of
such graphs, and deﬁne constraints on how nodes can be
typed based on their parents’ types. We then show that
any “well-typed” graph deﬁnes a secure AE scheme. This
allows us to automatically analyze a given scheme by check-
ing whether the graph deﬁning the scheme can be properly
typed. Building on this, we can synthesize schemes by enu-
merating over valid graphs and analyzing each one to see if
it is secure. Through a generic transformation, our work can
handle messages of arbitrary length, whereas the prior work
of Malozemoﬀ et al. is limited to messages whose length is
a multiple of the block length.

Although the high-level structure of our approach is sim-
ilar to that of Malozemoﬀ et al., the technical details diﬀer
greatly due to the added challenge of handling integrity. (In-
deed, this was left as an explicit open question in their work.)
We were unable to directly extend their work to deal with
integrity; instead, we modify their approach and consider

1For example, GCM is fairly complex and has a problematic
security proof [14], whereas CCM is not online and cannot
pre-process associated data.

84a restricted class of encryption schemes for which an auto-
mated analysis of integrity is tractable. Speciﬁcally, we focus
on schemes constructed using tweakable blockciphers [18] in
a particular way2. Several existing AE schemes satisfy our
requirements, indicating that our framework is not overly
restrictive. The abstraction from using a tweakable blockci-
pher also signiﬁcantly reduces the size of the graphs that we
have to enumerate, making the synthesis feasible. Despite
this simpliﬁcation, our graphs are a lot more complex than
those that Malozemoﬀ et al. consider. For example, in the
prior work, it is relatively easy to tell if a scheme is decrypt-
able, as there is only one path from a node representing a
plaintext block to a node representing a ciphertext block. In
our case, this no longer holds—the graphs of schemes like
OTR [21] have multiple paths between such pairs of nodes,
and we have to ﬁnd a nontrivial algorithm to explicitly con-
struct a graph of the encryption scheme, given a graph of
the decryption scheme.

Using our approach, we are able to synthesize thousands
of secure AE schemes, hundreds of which are “optimal” in
the sense that they use only one tweakable blockcipher call
per block, on par with OCB. These schemes are provably
secure, as veriﬁed by our analysis tool, with concrete se-
curity bounds.
In contrast, the prior work of Malozemoﬀ
et al. [19] only gives asymptotic analyses. We also employ
a simple algorithm to ﬁnd fully parallelizable constructions
among the “optimal” schemes, and discover seventeen such
schemes, ﬁve of which use the same number of instructions
as OCB. We implement two of these schemes and ﬁnd that
the running times are comparable to those of OCB. Thus,
these schemes may be of interest to practitioners looking for
eﬃcient, simple, and patent-free AE schemes. Finally, in
the full version [13] of this work, we devise a method for
automatically ﬁnding attacks on schemes that our approach
cannot claim secure, and we ﬁnd that most of those schemes
indeed are susceptible to concrete attacks.

Related work. Recently there has been a growing interest
in applying automated techniques to the analysis and de-
sign of cryptographic primitives. In the public-key setting,
Barthe et al. [4] introduced an approach applicable to RSA-
based encryption schemes. More recently, Tiwari et al. [26]
developed a uniﬁed technique for synthesizing both RSA-
based encryption schemes and modes of operation, among
other cryptographic primitives. Other work has looked at
automated analysis of assumptions in generic groups [5] with
applications to automated synthesis of signature schemes
having certain properties [5, 6]. Finally, Akinyele et al. [1,
2] developed tools for analyzing signature and encryption
schemes to determine when (and how) known secure trans-
formations can be applied.

2. PRELIMINARIES
Notation. Let Z denote the set of all integers, and let N
denote the set of positive integers. Let {0, 1}∗ denote the
set of all binary strings, including the empty string. For a
string M , let |M| denote the length of M . For M ∈ {0, 1}∗
and 1 ≤ i ≤ j ≤ |M|, let M [i] denote the i-th bit of M ,
and M [i, j] the substring of M from the ith to the jth bit,

2Roughly, a tweakable blockcipher accepts a “tweak” in ad-
dition to a key and a regular input; for a ﬁxed key, diﬀerent
tweaks should produce “independent-looking” permutations.
See the following section for a formal deﬁnition.

inclusive. For two strings X and Y , we write XY or X (cid:107) Y
to denote the concatenation of X and Y .
We write x ←$ S to denote uniform sampling of x from
ﬁnite set S. For ﬁnite sets S1, S2, and random variables
X, Y ∈ S1, Z ∈ S2, deﬁne (cid:107)X − Y | Z(cid:107), the statistical
distance between X and Y given Z, as

Pr[Z = z]·(cid:12)(cid:12)(cid:12) Pr[X = v | Z = z]−Pr[Y = v | Z = z]

(cid:88)

(cid:12)(cid:12)(cid:12).

1
2
v∈S1,z∈S2

Games. We use the code-based, game-playing framework
of Bellare and Rogaway [8]. Due to lack of space, we assume
the reader is familiar with this framework.
Tweakable blockciphers [18]. Let n ∈ N. A tweak-
able blockcipher on n-bit strings with tweak space T and
key space K is a map E : K × T × {0, 1}n → {0, 1}n such
that EK (T,·) is a permutation on {0, 1}n for any K ∈ K
and T ∈ T . Let E−1 denote the inverse of E, meaning
K (T, EK (T, x)) = x for K ∈ K, T ∈ T , and x ∈ {0, 1}n.
−1
E
For brevity we sometimes write ET
K (x) for EK (T, x). De-
ﬁne the strong tweakable-PRP advantage of an adversary A
against E as

(cid:12)(cid:12)(cid:12) Pr[K ←$ K : AEK (·,·),E

−1
K (·,·) ⇒ 1]

±(cid:103)prp

E

Adv

(A) =

(cid:12)(cid:12)(cid:12),

− Pr[π ←$ Perm(T , n) : Aπ(·,·),π−1(·,·) ⇒ 1]

where Perm(T , n) is the set of all T -indexed families of per-
mutations on {0, 1}n.
(I.e., Perm(T , n) is the set of all
functions π : T × {0, 1}n → {0, 1}n with the property that
for each T ∈ T , the reduced function π(T,·) is a permuta-
tion on {0, 1}n.) If the adversary is prohibited from making
write Adv(cid:103)prp
queries to the second oracle, we drop the word “strong” and

E (A) instead.

Authenticated encryption. Rather than view encryp-
tion schemes as being randomized or stateful, we follow Ro-
gaway [24] in viewing them as deterministic transformations
that take as input a message along with some associated data
(which need not be kept secret) as well as a user-supplied
nonce. Security is then required to hold as long as the same
nonce is never used twice.
Formally, an authenticated encryption (AE) scheme [7,
16, 22, 24] is a tuple Π = (K,E,D) with key space K, nonce
space N , associated data space A, message space M, and
tag length τ ∈ N. Both algorithms E and D are deter-
ministic. The encryption algorithm E maps an input tuple
(K, N, A, M ) ∈ K×N ×A×M to a ciphertext C ∈ {0, 1}∗.
Decryption D reverses encryption, mapping an input tuple
(K, N, A, C) ∈ K × N × A × {0, 1}∗ to either a message
M ∈ M or a distinguished error symbol ⊥. The correctness
requirement demands that DN,A
K (M )) = M for every
(K, N, A, M ) ∈ K × N × A × M.
We deﬁne the privacy advantage of an adversary A against
Π (A) =

(cid:12)(cid:12)(cid:12)Pr[K ←$ K : AEK (·,·,·) ⇒ 1] − Pr[A$(·,·,·) ⇒ 1]

an AE scheme Π as Advpriv

K (E N,A

(cid:12)(cid:12)(cid:12) ,

where $(·,·,·) is an oracle that, on any input (N, A, M ),
outputs a fresh, uniform (|M| + τ )-bit answer. We require
here that the adversary never uses the same nonce twice as
input to its oracle.
Informally, a scheme satisﬁes privacy
if the privacy advantage of any eﬃcient adversary is small.

85Nonces used by the honest party during encryption need
only be unique3, not uniform.
For authenticity, the adversary is again given access to
an encryption oracle EK (·,·,·), and as before must not use
the same nonce twice. We say that A outputs a forgery
if it outputs (N, A, C) such that DK (N, A, C) (cid:54)= ⊥ and C
was not the result of a prior oracle query EK (N, A, M ) for
some message M . We deﬁne the authenticity advantage of A
Π (A) = Pr[K ←$ K : AEK (·,·,·) outputs a forgery].
as Advauth
Informally, a scheme satisﬁes authenticity if the authenticity
advantage of any eﬃcient adversary is small.

3. AUTOMATED SECURITY ANALYSIS

We now describe our approach to the automated analy-
sis of AE schemes constructed from tweakable blockciphers
following a particular template (cf. Section 3.1). Although
this template does not capture all known AE schemes, it
is expressive enough to include simpliﬁed variants of, e.g.,
OCB [23], XCBC [12], COPA [3], OTR [21], and CCM [10].4
As discussed in the Introduction, we view an encryption
scheme as being deﬁned by a directed acyclic graph in which
each node is associated with an instruction and carries an
n-bit intermediate value. In Section 3.2 we describe a type
system for the nodes of such graphs, and show how to use
these types for reasoning about properties of the intermedi-
ate values that those nodes carry. Then, in Section 3.3, we
show how this reasoning enables us to automatically verify
whether an AE scheme, given by its graph representation,
satisﬁes privacy and authenticity.
3.1 A Template for AE Schemes
Fix associated data space A, and let N = {0, 1}n. Let
T = N × A × Z and let E : K × T × {0, 1}n → {0, 1}n
be a tweakable blockcipher.We consider AE schemes Π[E] =
(K,E,D) that use E as an oracle. The schemes we consider
have message space5 M = ({0, 1}2n)∗ and are built from
algorithms (Enc, Dec, Tag) having the following form:

• EncEK takes as input tweak T = (N, A, v) ∈ T , an ini-
tial state X ∈ {0, 1}2n, and a (double-length) mes-
sage block M ∈ {0, 1}2n. It outputs a (double-length)
ciphertext block C ∈ {0, 1}2n and ﬁnal state Y ∈
{0, 1}2n. This algorithm makes a ﬁxed number of
queries to EK , denoted by Cost(Π), and we require
that the tweak in the ith such query is (N, A, v +i−1).

3The requirement that nonces be unique is necessary, since
repeating (N, A, M ) will repeat the corresponding cipher-
text. For real schemes such as OCB, reusing a nonce is dev-
astating, damaging the privacy and authenticity of not just
past queries, but also future ones. It is the responsibility of
the implementation to ensure that nonces are unique.
4For eﬃciency, the real-world variants are often built di-
rectly from a blockcipher instead of a tweakable one, and em-
ploy a scheme-speciﬁc way to handle fragmentary data. The
real-world CCM is not online due to its treatment of frag-
mentary data, whereas our variant is online. OCB is built
from a tweakable blockcipher, but the tweaks are (N, i) in-
stead of (N, A, i). To handle associated data, OCB employs
an XOR-universal hash (based on a tweakable blockcipher),
and XORs the hash image to the tag.
5Messages of arbitrary length can be handled by naive
padding in the usual way.
In the full version [13] we de-
scribe a more eﬃcient approach for handling messages of
arbitrary length.

EK (N, A, M )
X := 02n; v := 1; M1 · · · M2m := M // |Mi| = n
for i = 1 to m do

// |Cj| = n

T := (N, A, v)
(Y, C2i−1C2i) := EncEK (T, X, M2i−1M2i)
v := v + Cost(Π); X := Y
T := (N, A, 1 − v); V := TagEK (T, X)
return C1 · · · C2m (cid:107) V [1, τ ]
DK (N, A, C)
if |C| (cid:54)≡ τ (mod 2n) then return ⊥
C1 · · · C2m (cid:107) tag := C // |Ci| = n and |tag| = τ
X := 02n; v := 1
for i = 1 to m do

T := (N, A, v)
(Y, M2i−1M2i) := DecEK ,E
v := v + Cost(Π); X := Y

T := (N, A, 1 − v); V := TagEK (T, X)
if tag (cid:54)= V [1, τ ] then return ⊥
else return M1 · · · M2m

−1
K (T, X, C2i−1C2i)

Figure 3.1: Code of an AE scheme Π = (K,E,D)
following our template. The scheme is based on a
tweakable blockcipher E and a triple of deterministic
algorithms (Enc, Dec, Tag).

• DecEK ,E

−1
K “inverts” algorithm Enc in the following
sense: if EncEK (T, X, M ) = (Y, C) then it holds that
DecEK ,E
X ∈ {0, 1}2n, and produces a tag V ∈ {0, 1}n.
makes a single query to EK using tweak T .

• TagEK takes as input tweak T ∈ T and initial state
It

−1
K (T, X, C) = (Y, M ).

The encryption/decryption algorithms (E,D) of Π are then
deﬁned as in Figure 3.1, where we require τ ≤ n. Roughly,
to encrypt a message M = M1M2 ··· M2m using nonce N
and associated data A, set the initial state X = 02n and
set T = (N, A, 1). Then, iteratively process two message
blocks at a time using Enc, each time updating the initial
state and outputting the next two ciphertext blocks. After
processing the entire message, Tag is used to compute a tag
based on the ﬁnal state output by Enc and a designated
tweak that depends on the message length; the (truncated)
tag is appended to the ciphertext.

Graph representation. As in the work of Malozemoﬀ
et al. [19], we represent algorithms Enc, Dec, and Tag as
directed acyclic graphs, where each node is associated with
an instruction and carries an n-bit value. The n-bit value
on each node is determined by applying the instruction at
that node to the values at the parent nodes.
In the next
section we introduce a system for “typing” the nodes of such
graphs; our main theorem states that AE schemes built from
Enc, Dec, and Tag algorithms whose graphs can be correctly
typed are secure.

The main instructions we support are XOR, which com-
putes the XOR of two n-bit strings, and TBC, which invokes
the tweakable blockcipher or its inverse. We also have an
instruction DUP that duplicates a value. Nodes correspond-
ing to input blocks are labeled IN, those corresponding to
output blocks are labeled OUT, those corresponding to the
initial state are labeled INI, and those corresponding to the
ﬁnal state are labeled FIN. These labels, along with their
in-/out-degree, are summarized for convenience next:

86Figure 3.2: The OCB scheme illustrated for a four-
block message M1, . . . , M4, where Σ is the checksum
M1 ⊕ ··· ⊕ M4.

EncEK (T, X, M1, M2)
(N, A, v) := T
X1, X2 := X // |Xi| = n
C1 := EK (T, M1)
T := (N, A, v + 1)
C2 := EK (T, M2)
Y := (X1 ⊕ M1 ⊕ M2) (cid:107) X2
return (Y, C1, C2)

−1
DecEK ,E
K (T, X, C1, C2)
(N, A, v) := T
X1, X2 := X // |Xi| = n
M1 := E−1
k (T, C1)
T := (N, A, v + 1)
M2 := E−1
K (T, C2)
Y := (X1 ⊕ M1 ⊕ M2) (cid:107) X2
return (Y, M1, M2)

TagEK (T, X)
X1, X2 := X; V := EK (T, X1); return V

Figure 3.3: The algorithms (Enc, Dec, Tag) corre-
sponding to OCB. We have Cost(OCB) = 2.

Name

In-deg Out-deg Meaning

IN
INI
FIN
OUT
DUP
XOR
TBC

0
0
1
1
1
2
1

1
1
0
0
2
1
1

Input block
Initial state
Final state
Output block
Duplicate
XOR operation
Tweakable blockcipher

Figure 3.2 illustrates the OCB scheme [23], Figure 3.3
shows the corresponding Enc, Dec, and Tag algorithms, and
Figure 3.4 shows the corresponding graphs. (In OCB, only
the ﬁrst n bits of the state are used, so we treat the state as
an element of {0, 1}n.) Note that Figure 3.4 is informal and
omits information needed to fully specify OCB; see next for
formal details of how graphs are speciﬁed.
Formally, we denote a graph G by a tuple (d, r, F, P, L),
where d ∈ {2, 4} is the total number of IN and INI nodes
(Enc and Dec graphs have d = 4; Tag graphs have d = 2),
and r ∈ N is the total number of nodes. Each node in the
graph is numbered from 1 to r, and we require that if node i
is a parent of node j then i < j. (This ensures that G is
acyclic.) Let Nodes denote the power set of {1, . . . , r}, and
let Inst = {IN, . . . , TBC} be the set of instructions. Then
F : {1, . . . , r} → Inst gives the instruction of each node and
P : {1, . . . , r} → Nodes gives the set of parents for each
node. We require that F (1) = F (2) = INI and F (r) = OUT.
For Enc and Dec graphs, we additionally require that F (3) =
F (4) = IN, F (r − 2) = F (r − 3) = FIN, and F (r − 1) = OUT.
For Enc and Dec graphs, let S ⊂ {1, . . . , r} be the set
of all nodes corresponding to a TBC instruction. Function
L : S → Z speciﬁes, for each such node i, whether the
tweakable blockcipher is computed in the forward direction
(if L(i) ≥ 0) or the reverse direction (if L(i) < 0) at that

Figure 3.4: Graph representations for algorithms
Enc (left), Dec (middle), and Tag (right) of OCB.

−1
K (G, T, Z1, . . . , Zd)

proc EvalEK ,E
(d, r, F, P, L) := G
for i = d + 1 to r do
if F (i) ∈ {DUP, OUT, FIN} then {p} := P (i); Zi := Zp
elseif F (i) = XOR then {p1, p2} := P (i); Zi := Zp1 ⊕ Zp2
else // F (i) = TBC

(cid:96) := L(i); (N, A, v) := T
T ∗ := (N, A, v + |(cid:96)|); {p} := P (i)
if (cid:96) > 0 then Zi := EK (T ∗, Zp) else Zi := E−1

K (T ∗, Zp)

return (Z1, . . . , Zr)

Figure 3.5: Procedure to compute the value Zi of
each node i in a graph G, given input Z1, . . . , Zd and
tweak T .

(Note that L(i) ≥ 0 for Enc graphs.) Moreover,
node.6
|L(i)| determines the tweak at node i; i.e., on input tweak
(N, A, v), the tweak at node i is (N, A, v + |L(i)|).
Let G− = (d, r, F, P ) denote the unlabeled graph corre-
sponding to a graph G. In Section 3.2, we introduce a type
system and show that one can reason about the security of
an AE scheme by evaluating the scheme’s unlabeled graphs.
Fix some graph G, tweakable blockcipher E, and key K.
Given a tweak T and n-bit values for all INI/IN nodes in G,
we can naturally deﬁne an n-bit value Zi associated with
each node i in the graph. We describe this formally as pro-
cedure Eval in Figure 3.5, which shows how to compute Zi
given values Z1, . . . , Zd ∈ {0, 1}n and tweak T .
3.2 A Type System for AE Schemes

Let Types = {$,⊥, 0, 1} be a set of “types” we can assign
to nodes. Intuitively, ‘$’ indicates a node whose output value
is (pseudo)random (when the key K for E is random and
secret), whereas ‘⊥’ indicates a node whose output value is
arbitrary (i.e., potentially controlled by an attacker). Look-
ing ahead, types ‘0’ and ‘1’ will be used to compare values on
the same node in two diﬀerent decryption queries using the
same nonce and associated data; ‘0’ means the correspond-
ing values are the same, and ‘1’ means they are diﬀerent.
In Figure 3.6, we deﬁne a deterministic procedure Map
that takes as input an unlabeled graph G−, pre-assigned
types type1, . . . , typed ∈ Types for all the INI/IN nodes,
and a boolean ﬂag rand, and returns a map R that asso-
ciates each node i with a pair (typei, ctr i) ∈ Types × N.
The procedure Map traverses the graph in topological or-

6While it might be conceptually simpler to use two diﬀerent
−1
instructions for EK and E
K , instead of just a single TBC
instruction with positive/negative labels, our approach is an
optimization that prunes the search space when synthesizing
schemes (cf. Section 4).

M3M1M2C1Σ C2C3tagM4C4τEKN,A,1EKN,A,2EKN,A,3EKN,A,4EKN,A,−4INIINOUTOUTINXORDUPDUPTBCTBCXORFININITBCOUTINIINOUTOUTINXORTBCTBCDUPDUPXORFIN87proc Map(G−, type1, . . . , typed, rand)
(d, r, F, P ) := G−; maxCtr := 0
for i = 1 to d do

if typei = $ then R(i) := ($, 1); maxCtr := 1
else R(i) := (typei, 0)
if F (i) ∈ {FIN, OUT, DUP} then

for i = d + 1 to r do

elseif F (i) = TBC then

{p} := P (i); R(i) := R(p)
{p} := P (i); (x, ctr) := R(p)
if x ∈ {1, $} or (rand = true) then

maxCtr := maxCtr + 1; R(i) := ($, maxCtr)

else // F (i) = XOR

else R(i) := (x, ctr)
{p1, p2} := P (i); (x, ctr) := R(p1); (y, ctr(cid:48)) := R(p2)
// Assume that ctr ≥ ctr(cid:48)
if (x, y) ∈ {(0, 0), (0, 1), (1, 0)} then R(i) := (x ⊕ y, ctr)
elseif x = $ and ctr > ctr(cid:48) then R(i) := ($, ctr)
else R(i) := (⊥, ctr)

return R

Figure 3.6: A procedure for generating a mapping
R : {1, . . . , r} → Types×N for a given unlabeled graph.

der and assigns types to each node of the graph based on
the instruction associated with that node and the types of
its parents. These types are used for probabilistic reason-
ing about the underlying n-bit values on that node; e.g., we
show that if a node has type $ then the n-bit value of that
node is (pseudo)random. The ctr values are used as “times-
tamps” for values output by TBC nodes in order to determine
independence among values of type $. Finally, the rand ﬂag
denotes whether the nonce/associated data are fresh.

For FIN, OUT, and DUP nodes, Map simply propagates the
type of the parent node. For TBC nodes, if the nonce or input
is fresh then the output is (pseudo)random and independent
of any prior random values, and so the node gets type $;
otherwise, we propagate the type of the parent node.

For XOR nodes, we have several cases.

If the two input
nodes x and y are typed typex and typey, respectively, with
(typex, typey) ∈ {(0, 0), (0, 1), (1, 0)}, then we type the XOR
node as typex ⊕ typey. We brieﬂy explain this reasoning.
The fact that typex, typey ∈ {0, 1} means there is a prior
query using the same nonce and associated data. If the two
parents have type 0, indicating that the values computed
at those nodes are equal in the two queries, then clearly
the value computed at the XOR node is also equal in the
two queries, and thus that node gets type 0. On the other
hand, if one parent is typed 0 and the other is typed 1,
then the value computed at the XOR node will be diﬀerent
from the corresponding value in the prior query, and thus
the XOR node is assigned type 1. If (typex, typey) = (1, 1)
then we cannot say anything deﬁnitive and thus Map assigns
type ⊥ to the XOR node. Finally, suppose input node x has
type $. Here we utilize the ctr values. If the ctr value at x
is diﬀerent from the ctr value of y, then the (random) value
of x is independent of the value of y, and hence we assign
the XOR node type $.

In the next two lemmas we show how determining the
types for an unlabeled graph can be used to reason about the
values that one obtains when evaluating the labeled graph.
We ﬁrst show that all values typed $ by Map (when inputs
are typed ⊥ and hence may be under arbitrary control of the
adversary) are indeed random when computed using Eval
and a truly random tweakable permutation.

Lemma 3.1. Let G = (d, r, F, P, L) and let n ≥ 1 be an
integer. Set R := Map(G−,⊥, . . . ,⊥, true). Fix arbitrary
Z1, . . . , Zd ∈ {0, 1}n and T ∈ T , and consider the following
probabilistic experiment:

1. Choose f ←$ Perm(T , n).
2. Run (Z1, . . . , Zr) := Evalf,f−1

(G, T, Z1, . . . , Zd).

Then for any j with R(j) = ($, ctr j), the random variable
Zj is uniform and independent of {Zi | ctr i < ctr j}.

Suppose both claims hold for all i ≺ j.

Proof. First note that for any node i and its parent p,
we have ctr i ≥ ctr p. Thus, there is a topological ordering
s1, . . . , sr of the nodes such that the sequence ctr s1 , . . . , ctr sr
is non-decreasing, and si = i for i ≤ d. Write i ≺ j if
node i precedes node j in this topological order. We prove
by induction (with respect to ≺) that for all j we have
(i) typej ∈ {⊥, $} and (ii) if typej = $ then Zj is uni-
form and independent of {Zi
| ctr i < ctr j}. Note that
these claims are trivially true when j ≤ d, because then
typej = ⊥.
If F (j) ∈
{FIN, OUT, DUP} then let p ≺ j be the parent of j. Since
(typej, ctr j) = (typep, ctr p), the claims follow for j.
If
F (j) = TBC then typej = $, proving claim (i). Since
f ←$ Perm(T , n), and Eval never repeats a tweak in query-
ing f , we see that random variable Zj is uniform and inde-
pendent of {Zi | ctr i < ctr j}, justifying claim (ii). Finally,
say F (j) = XOR. Let i and t be the parents of j, and assume
t ≺ i. Then typet, typei ∈ {⊥, $}, and thus so is typej,
proving claim (i). For claim (ii), note that typej = $ only
if typei = $ and ctr i > ctr t. Since ctr j = ctr i, the claim
follows.

The next lemma proves a similar property for pairs of
queries. Consider the query (Y1, . . . , Yr) := Evalf,f−1
(G, T,
Y1, . . . , Yd) followed by query (Z1, . . . , Zr) := Evalf,f−1
(G, T,
Z1, . . . , Zd), where each Zi is either chosen equal to Yi (and
thus typei = 0), distinct from Yi (and thus typei = 1), or
uniformly (and thus typei = $). We show that for all nodes
j of type $ assigned by Map(G−, type1, . . . , typed, false), the
statistical diﬀerence between Zj and uniform is small, even
conditioned on all the {Yi}.

Lemma 3.2. Let G = (d, r, F, P, L) and let n ≥ 1 be an
integer. Fix arbitrary Y1, . . . , Yr ∈ {0, 1}n and T ∈ T
such that the set S = {f ∈ Perm(T , n) | (Y1, . . . , Yr) =
Evalf,f−1
(G, T, Y1, . . . , Yd)} is non-empty. For each i ≤ d,
choose Zi and typei in one of the following ways: (i) Zi = Yi
and typei = 0, (ii) Zi (cid:54)= Yi and typei = 1, (iii) Zi ←$ {0, 1}n
and typei = $. Let R = Map(G−, type1, . . . , typed, false).
Consider the following probabilistic experiment:

1. Choose f ←$ S.
2. Run (Z1, . . . , Zr) := Evalf,f−1

(G, T, Z1, . . . , Zd).

Then for any j with R(j) = ($, ctr j), the statistical diﬀer-
ence between the random variable Zj and uniform, condi-
tioned on {Zi | ctr i < ctr j} and all the {Yi}, is at most
2 · ctr j/2n.

Proof. As in the previous lemma, there is a topological
ordering s1, . . . , sr of the nodes such that ctr s1 , . . . , ctr sr is
non-decreasing and si = i for i ≤ d. Write i ≺ j if i precedes
j in this topological order. We prove by induction (with

882 are unlabeled graphs of Enc and Tag, respectively.

// Check that output of Tag is random

proc Priv(G−
// G−

1 ; (d2, r2, F2, P2) := G−
2 , ⊥, ⊥, true); (type, ctr) := R(r2)

1 , G−
2 )
1 and G−
01 (d1, r1, F1, P1) := G−
02 R := Map(G−
03 if type (cid:54)= $ then return false
04 R := Map(G−
1 , ⊥, ⊥, ⊥, ⊥, true)
05 (type1, ctr1) := R(r1 − 1); (type2, ctr2) := R(r1)
06 return ((type1 = $) ∧ (type2 = $) ∧ (ctr1 (cid:54)= ctr2))

2

// Check that output blocks of Enc are random and independent

proc Auth(G−
1 and G−
// G−

1 , G−
2 )
2 are unlabeled graphs of Dec and Tag, respectively.
1 ; (d2, r2, F2, P2) := G−
11 (d1, r1, F1, P1) := G−
12 R := Map(G−
2 , ⊥, ⊥, true); (type, ctr) := R(r2)
13 if type (cid:54)= $ then return false

2

// Check that output of Tag is random when the nonce/associated data are fresh

// Check that if there are two executions of Dec with the same initial state
// but diﬀerent input blocks, then the ﬁrst half of the ﬁnal state is random

14 for (x, y) ∈ {(0, 1), (1, 0), (1, 1)} do
15 R := Map(G−
16

1 , 0, 0, x, y, false); (type, ctr) := R(r1 − 3)

if type (cid:54)= $ then return false
// Check that if the ﬁrst half of the initial state input to Dec is random,
// then the ﬁrst half of the ﬁnal state output by Dec is random

17 for x, y, z ∈ {0, 1} do
18 R := Map(G−
19

1 , $, x, y, z, false); (type, ctr) := R(r1 − 3)

if type (cid:54)= $ then return false
// Check that if there are two executions of Tag in which the ﬁrst halves of the
// initial states are diﬀerent, then the resulting tags are random and independent

20 for x ∈ {0, 1} do
21 R := Map(G−
22
23 return true

if type (cid:54)= $ then return false

2 , 1, x, false); (type, ctr) := R(r2)

Figure 3.7: Tests to determine if a scheme Π satisﬁes privacy and authenticity, respectively.

respect to ≺) that for all j: (i) if typej = 0 then Zj = Yj,
(ii) if typej = 1 then Zj (cid:54)= Yj, and (iii) if typej = $ then
the statement of the lemma holds. These claims all trivially
hold when j ≤ d.
Suppose that all three of the claims hold for all i ≺ j. If
F (j) ∈ {FIN, OUT, DUP} then let p ≺ j be the parent of j.
Since (typej, ctr j) = (typep, ctr p), the claims follow easily
If F (j) = XOR, let t, i ≺ j be the parents
in this case.
of j, and assume t ≺ i. Note that typej ∈ {0, 1} only if
typei, typet ∈ {0, 1} and at most one of these values is 1, in
which case the claims all hold. On the other hand, typej = $
only if typei = $ and ctr i > ctr t, in which case the claims
also follow. Finally, if F (j) = TBC then let i be the parent
of j. Let (cid:96) = L(j), and let T = (N, A, v). Then Yj =
f (T ∗, Yp) and Zj = f (T ∗, Zp), where T ∗ = (N, A, v + |(cid:96)|).
Consider the following cases:
Case 1. typei ∈ {0,⊥}. Then (typej, ctr j) = (typei, ctr i)
and the claims follow.
Case 2. typei = 1. Then typej = $ and ctr j ≥ 1. First,
since ctr t ≥ ctr j when t is a descendant of j, we see that
no node t with ctr t < ctr j is a descendant of j. Next,
since Zi (cid:54)= Yi and we use a diﬀerent tweak for each TBC
node, Zj ←$ {0, 1}n\{Yj} is independent of {Yt | t ≤ r} and
{Zt | ctr t < ctr j}.

which occurs except with probability at most (2ctr i + 1)/2n,
then Zj is 2−n-close to uniform (even conditioned on all the
{Yt} values and {Zt | ctr t < ctr j}). Hence, overall, Zj is
(2ctr i + 2)/2n-close to uniform (conditioned on {Yt | t ≤ r}
and {Zt | ctr t < ctr j}) and the statement of the lemma
follows since we have ctr j ≥ ctr i + 1.
3.3 Verifying Privacy and Authenticity

We use Lemmas 3.1 and 3.2 to automatically check if a
candidate AE scheme is secure in the sense of both privacy
and authenticity. Speciﬁcally, Figure 3.7 shows procedures
Priv and Auth to check for privacy and authenticity, respec-
tively, of an AE scheme Π.

Intuitively, for privacy we verify that the tag and all the
ciphertext blocks output by the scheme are random and in-
dependent (namely, have type $ and distinct counter values)
even when the inputs—that is, the message blocks—are con-
trolled by the adversary (namely, have type ⊥). We remark
that the values of ctr assigned to nodes by the map R output
by Map depend on the topological order in which Map tra-
verses the input graph; see Figure 3.8 for an example. Thus,
there are schemes which, depending on the order in which
the graph is traversed, are accepted or (incorrectly) rejected
by Priv (due to the ctr values for the OUT nodes being equal).
This shows that the test is sound but not complete.7

Case 3. typei = $. Then typej = $. By the induction
hypothesis, Zi is (2ctr i/2n)-close to uniform (even condi-
tioned on {Yt | t ≤ r} and {Zt | ctr t < ctr i}). If Zi (cid:54)= Yi,

7In the full version [13] we describe a technique for generat-
ing attacks given a scheme which fails the tests of Figure 3.7.
Looking ahead, we ﬁnd only a handful of schemes which we

89Figure 3.8: Left: A scheme that can be accepted or (incorrectly) rejected by Priv, depending on the topological
ordering of the nodes. Middle left: The corresponding Enc graph. Middle right: The (type, ctr) pairs in each
node of the Enc graph if the left TBC node is visited ﬁrst. The graph is (incorrectly) rejected because the two
OUT nodes both have ctr = 2. Right: The (type, ctr) pairs in each node of the Enc graph if the right TBC is visited
ﬁrst. This time, the graph is accepted because the two OUT nodes have diﬀerent ctr values.

The authenticity check for a scheme (Enc, Dec, Tag) is
more complicated. We now argue informally that if a scheme
passes the checks of algorithm Auth (cf. Figure 3.7), then
the scheme satisﬁes authenticity. To see this, consider a
candidate forgery (N, A, C) output by an adversary. First
suppose there was no prior query (N, A, (cid:63)) to the encryp-
tion oracle. Auth veriﬁes that the Tag algorithm outputs a
random tag when the tweak for the TBC node in Tag was
not used previously; thus, the candidate forgery will be in-
valid except with probability 2−τ . (Recall that τ is the tag
length.) Next, consider the case that there was a prior en-
cryption query (N, A, M ), and let C(cid:48) be the corresponding
ciphertext. Then C (cid:54)= C(cid:48); otherwise (N, A, C) is not a valid
forgery. If C and C(cid:48) only diﬀer in their tags, the candidate
forgery must be invalid because the tag is uniquely deter-
mined by N , A, and the rest of the ciphertext. Otherwise,
consider the ﬁrst pair of blocks in which C and C(cid:48) diﬀer.
Auth veriﬁes that (i) the ﬁrst half of the ﬁnal state produced
by Dec when run on those blocks is random, (ii) Dec has the
property that if the ﬁrst half of its initial state is random,
then the ﬁrst half of the ﬁnal state it outputs is random,
and (iii) Tag has the property that if the ﬁrst half of its
initial state is random, then the tag it outputs is random8.
Taken together, these imply that the tag will be random,
and hence the candidate forgery will be invalid except with
probability 2−τ .

To demonstrate the strength of our approach, consider a
modiﬁed version of the OTR scheme [21]. The original OTR
scheme (cf. Figure 3.9) is secure, which our automated tests
conﬁrm.
If, however, the scheme is changed so that Σ is
computed as the checksum of the odd blocks M1 ⊕ M3 ⊕
··· , rather than the even blocks, then it becomes insecure.
And, indeed, the modiﬁed scheme does not pass our tests.
Namely, on input (0, 0, 1, 0) to Map we ﬁnd that the required
FIN node is typed 1 instead of $.

Proofs of correctness. We now prove that schemes that
pass our tests are secure. We ﬁrst show that if Priv re-
turns true when given the (unlabeled) graphs corresponding
to the Enc and Tag components of some AE scheme, then

can neither prove secure nor ﬁnd concrete attacks for; see
Section 4.
8Although here we are considering just the ﬁrst half of the
ﬁnal/initial state, if one switches to the second half then
one will get the same set of synthesized schemes:
if one
changes the topological ordering in the graphs so that the
ﬁrst FIN/INI node becomes the second one, and vice versa,
then the scheme remains the same.

Figure 3.9: The OTR scheme, illustrated for a four-
block message M1 ··· M4. Here, Σ is the checksum of
the even blocks M2 ⊕ M4.

that scheme satisﬁes privacy when instantiated with a secure
tweakable blockcipher.

−
1 , G

−
2 ) = true, where G

Theorem 3.3. Let Π[E] = (K,E,D) be an AE scheme
−
for which Priv(G
2 are the
unlabeled graphs for algorithms Enc and Tag of Π, respec-
tively. Then for any adversary A, there is an adversary B
E (B). Adversary B has the same
with Advpriv
running time as A and makes at most (Cost(Π) + 1) · σ/2
queries, where σ is the number of message blocks in the
queries of A.

Π[E](A) ≤ Adv(cid:103)prp

−
1 and G

Proof. Adversary B runs A. For each of A’s queries
(N, A, M ), adversary B runs the encryption scheme Π[E]
on (N, A, M ) with each call to EK replaced by a query to
B’s oracle, and returns the ciphertext to A. Finally, B out-
puts the same guess as A. Let Π[π] be the ideal variant
of Π[E], where calls to EK are replaced by corresponding
queries to π, with π ←$ Perm(T , n). It suﬃces to show that
Advpriv

Π[π](A) = 0.

Consider experiments H1–H4 in Figure 3.10. The adver-
sary has oracle access to the encryption scheme of Π[π] in ex-
periment H1, and oracle access to $(·,·,·) in experiment H4.
Experiment H2 is identical to H1, except that we re-sample
π ←$ Perm(T , n) each time we use Enc or Tag. Since a tweak
2 ⇒ true]. In
to π is never repeated, Pr[HA
experiment H3, instead of calling Tagπ(T, X) to get the tag,
we sample the tag at random. Considering lines 02–03 of
−
Priv (and the fact that Priv(G
2 ) = true) in conjunction
with Lemma 3.1 shows that the string V := Tagπ(T, X) is
uniform and so experiments H2 and H3 are identical. Fi-
nally, experiment H4 is identical to H3, except that instead
of calling Encπ(T, X, M2i−1M2i) to get the blocks C2i−1C2i
of the ciphertext, we sample them at random. Consider-

1 ⇒ true] = Pr[HA

−
1 , G

INIINFINOUTINDUPDUPTBCTBCXOROUTXORDUPXOR⊥,0⊥,0⊥,0$,2⊥,0⊥,0⊥,0$,1$,2$,2$,2$,2$,2⊥,0⊥,0⊥,0⊥,0$,2⊥,0⊥,0⊥,0$,2$,1$,1$,1$,2$,1⊥,0M1M2C1C2M3M4C3C4tagτM1M2C1C2M3M4C3C4Σ tagτ90// Experiments H1, H2

// |Mi| = n

proc Encrypt[π](N, A, M )
M1 · · · M2m := M ; X := 02n; v := 1
for i = 1 to m do
T := (N, A, v); π ←$ Perm(T , n)
(Y, C2i−1C2i) := Encπ(T, X, M2i−1M2i)
v := v + Cost(Π); X := Y
π ←$ Perm(T , n); T := (N, A, 1 − v); V := Tagπ(T, X)
return C1 · · · C2m (cid:107) V [1, τ ]

// Experiments H3, H4

// |Mi| = n

proc Encrypt[π](N, A, M )
M1 · · · M2m := M ; X := 02n; v := 1
for i = 1 to m do
T := (N, A, v); π ←$ Perm(T , n)
(Y, C2i−1C2i) := Encπ(T, X, M2i−1M2i)
C2i−1C2i ←$ {0, 1}2n
v := v + Cost(Π); X := Y
T := (N, A, 1 − v); V ←$ {0, 1}n
return C1 · · · C2m (cid:107) V [1, τ ]

Figure 3.10: Experiments H1–H4 in the proof of The-
orem 3.3. Experiments H2 and H4 include the corre-
sponding boxed statements, but H1 and H3 do not.

−
ing lines 04–05 of Priv (and the fact that Priv(G
2 ) =
true) in conjunction with Lemma 3.1 shows that the out-
put blocks of Encπ(T, X, M2i−1M2i) are uniform and in-
dependent (and this is true even conditioned on all prior
ciphertext blocks). Hence H3 and H4 are identical, and
Advpriv

1 ⇒ true] − Pr[HA

4 ⇒ true] = 0.

Π[π](A) = Pr[HA

−
1 , G

±(cid:103)prp

Next, in Theorem 3.4, we show that if Auth in Figure 3.7
returns true when given graphs corresponding to the Dec
and Tag components of some AE scheme, then that scheme
satisﬁes authenticity when instantiated with a secure tweak-
able blockcipher. (Examination of the proof shows that if
−1
algorithm Dec does not use E
K , as in the case of OTR, then
(B) in Theorem 3.4 can be weakened to
the term Adv
E (B).)

Adv(cid:103)prp
Theorem 3.4. Let Π[E] = (K,E,D) be an AE scheme
−
such that Auth(G
2 are the un-
labeled graphs for algorithms Dec and Tag of Π, respectively.
Then for any adversary A, there is an adversary B with
(B),
Advauth
where (cid:96) is the number of blocks in the forgery output by A.
Adversary B has the same running time as A and makes at
most (Cost(Π)+1)·σ/2 queries, where σ is the total number
of message blocks in the queries of A.

Π[E](A) ≤ 2−τ + (cid:96) · (Cost(Π) + 2)/2n + Adv

−
2 ) = true, where G

±(cid:103)prp

−
1 , G

E

E

−
1 , G

Proof. Adversary B runs A. For each of A’s encryp-
tion queries, B runs the encryption scheme of Π[E] but with
each call to EK replaced by a query to B’s ﬁrst oracle, and
returns the ciphertext to A. When A outputs a forgery
(N, A, C), adversary B runs the decryption scheme of Π[E]
−1
on (N, A, C), but with each call to EK /E
K replaced by a
query to B’s oracles. Adversary B returns 1 if A output a
valid forgery, and returns 0 otherwise. Let Π[π] be the ideal
−1
K are replaced by cor-
variant of Π[E], where calls to EK /E
responding queries to π/π−1, with π ←$ Perm(T , n). It suf-
Π[π] (A) ≤ 2−τ + (cid:96)(Cost(Π) + 2)/2n.
ﬁces to show that Advauth
Consider experiments H1–H3 in Figure 3.11. In H1, the
adversary has oracle access to the encryption and decryption

proc Decrypt[π](N, A, C)
if |C| (cid:54)≡ τ (mod 2n) then return ⊥
C1 · · · C2m (cid:107) tag := C // |Ci| = n and |tag| = τ
X := 02n; v := 1
for i = 1 to m do

// Experiments H1, H2

(T, X, C2i−1C2i)

T := (N, A, v)
(Y, M2i−1M2i) := Decπ,π−1
v := v + Cost(Π); X := Y
π ←$ Perm(T , n)
T := (N, A, 1 − v); V := Tagπ(T, X)
if tag (cid:54)= V [1, τ ] then return ⊥
return M1 · · · M2m

proc Decrypt[π](N, A, C)
if |C| (cid:54)≡ τ (mod 2n) then return ⊥
C1 · · · C2m (cid:107) tag := C // |Ci| = n and |tag| = τ
X := 02n; v := 1
for i = 1 to m do

// Experiment H3

T := (N, A, v)
(Y, M2i−1M2i) := Decπ,π−1
v := v + Cost(Π); X := Y

V ←$ {0, 1}n
if tag (cid:54)= V [1, τ ] then return ⊥
return M1 · · · M2m

(T, X, C2i−1C2i)

Figure 3.11: Experiments H1–H3 in the proof of The-
orem 3.4. Experiment H2 includes the correspond-
ing boxed statement, but experiment H1 does not.
Each experiment also has a procedure Encrypt[π],
implementing the encryption algorithm of Π[π], that
is not shown for simplicity.

−
1 , G

schemes of Π[π]. Experiment H2 is identical to H1, except
that when running the decryption algorithm, we re-sample
π ←$ Perm(T , n) before using it in Tag. Experiment H3 is
identical to H2, except that instead of using Tag to generate
the tag, we sample the tag uniformly.
Let (N, A, C) be the forgery output by A. Suppose there
is no encryption query (N, A, M(cid:48)) with |M(cid:48)| = |C| − τ .
Since decryption of the forgery query involves calling Tag
with a tweak that has never been used before, we have
Pr[A forges in H1] = Pr[A forges in H2]. Considering lines
−
12–13 of Auth (and the fact that Auth(G
2 ) = true)
in conjunction with Lemma 3.1 shows that the string
V := Tagπ(T, X) is uniform. Thus Pr[A forges in H2] =
Pr[A forges in H3]. The probability that A can forge in H3
is at most 2−τ . Hence Advauth
Now, suppose that there is an encryption query (N, A, M(cid:48))
such that |M(cid:48)| = |C|−τ . (Note that there can be at most one
such query, since the attacker is not allowed to re-use a nonce
value in two encryption queries.) Let C(cid:48) be the correspond-
ing ciphertext output by this encryption query, and let C =
C1 ··· C2m (cid:107) tag and C(cid:48) = C(cid:48)
j for
every j ≤ 2m then tag and tag(cid:48) must be diﬀerent and thus,
since Tag is deterministic, the forgery is invalid. Otherwise,
take the least index r ≤ m such that C2r−1C2r (cid:54)= C(cid:48)
2r−1C(cid:48)
2r.
Consider experiments P1, . . . , Pm−r+4 in Figure 3.12. In P1,
the adversary has two oracles: Encrypt and Decrypt. The
ﬁrst implements the encryption scheme of Π[π], and the sec-
ond implements the decryption scheme of Π[π] but returns
false if the decrypted value is ⊥ and returns true otherwise.
Let S be the subset of Perm(T , n) such that for any f ∈ S
and query (T, X) that Encrypt[π](N, A, M(cid:48)) makes to π,

Π[π] (A) ≤ 2−τ in this case.

2m (cid:107) tag(cid:48). If Cj = C(cid:48)

1 ··· C(cid:48)

91// Experiments P1, P2

proc Decrypt[π](N, A, C)
if |C| (cid:54)≡ τ (mod 2n) then return ⊥
C1 · · · C2m (cid:107) tag := C // |Ci| = n and |tag| = τ
X := 02n; v := 1
for i = 1 to m do

T := (N, A, v); π ←$ S
(Y, M2i−1M2i) := Decπ,π−1
v := v + Cost(Π); X := Y

(T, X, C2i−1C2i)
T := (N, A, 1 − v); π ←$ S; V := Tagπ(T, X)
if tag (cid:54)= V [1, τ ] then return false
return true

// Experiments P3+j , for 0 ≤ j ≤ m − r + 1

proc Decrypt[π](N, A, C)
if |C| (cid:54)≡ τ (mod 2n) then return ⊥
C1 · · · C2m (cid:107) tag := C // |Ci| = n and |tag| = τ
X := 02n; v := 1
for i = 1 to m do

T := (N, A, v); π ←$ S
(Y, M2i−1M2i) := Decπ,π−1
if r ≤ i ≤ r + j then Y ←$ {0, 1}n
v := v + Cost(Π); X := Y

π ←$ S; V := Tagπ(T, X)
if j = m − r + 1 then V ←$ {0, 1}n
if tag (cid:54)= V [1, τ ] then return false
return true

(T, X, C2i−1C2i)

Figure 3.12: Experiments P1, . . . , P4+m−r in the proof
of Theorem 3.4. Experiment P2 includes the corre-
sponding boxed statement, but P1 does not. Each
experiment also has a procedure Encrypt[π],
im-
plementing the encryption algorithm of Π[π], that
is not shown for simplicity. Here S is the set
of f ∈ Perm(T , n) such that for any query (T, X)
that Encrypt[π](N, A, M(cid:48)) makes to π, it holds that
f (T, X) = π(T, X).

we have f (T, X) = π(T, X). Experiment P2 is identical to
P1, except that in procedure Decrypt, each time we call Dec
or Tag we resample π ←$ S. Since in the forgery query we
do not repeat the tweak of any encryption query other than
(N, A, M(cid:48)), and π and π−1 are called with distinct tweaks,
we have Pr[A forges in P1] = Pr[A forges in P2]. In experi-
ment P3 we sample Y uniformly instead of computing Y :=
Decπ,π−1
(T, X, C2r−1C2r). Considering lines 14–16 of Auth
−
(and the fact that Auth(G
2 ) = true) in conjunction with
Lemma 3.2, we have Pr[A forges in P2]− Pr[A forges in P3]
≤ 2Cost(Π)+2
For j = 1, . . . , m − r, experiment P3+j is identical to
P2+j, except that we sample Y uniformly instead of com-
puting Y := Decπ,π−1
(T, X, C2r+2j−1C2r+2j). Considering
−
lines 17–19 of Auth (and the fact that Auth(G
2 ) =
true) in conjunction with Lemma 3.2, we conclude that
Pr[A forges in P2+j] − Pr[A forges in P3+j] ≤ 2Cost(Π)+2

−
1 , G

−
1 , G

2n

.

.

Experiment Pm−r+4 is identical to Pm−r+3 except that
we sample V uniformly when checking the validity of the
forgery instead of computing V := Tagπ(T, X). Let X(cid:48) be
the state used by Tag in Encrypt[π](N, A, M(cid:48)). If X[1, n] (cid:54)=
X(cid:48)[1, n], which happens with probability at least 1 − 2−n,
then applying Lemma 3.2 to lines 20–22 of procedure Auth,
we have Pr[A forges in Pm−r+3]−Pr[A forges in Pm−r+4] ≤

2n

2

2n . Finally, Pr[A forges in Pm−r+4] ≤ 2−τ . Summing up,
2(m − r + 1)(Cost(Π) + 1) + 3

Advauth

Π[π] (A) ≤ 2
≤ 2

−τ +
−τ +

2n

(cid:96)(Cost(Π) + 2)

2n

.

To summarize, Theorems 3.3 and 3.4 show that if the
graphs induced by a given scheme Π satisfy Priv and Auth
as deﬁned in Figure 3.7, then Π is a secure AE scheme.

4.

IMPLEMENTATION AND RESULTS

We have implemented the Priv and Auth algorithms de-
scribed in Section 3, and used them to synthesize AE
schemes. The code is written in OCaml and available at
https://github.com/amaloz/ae-generator. Our system
has two modules: an analysis module that, given graphs cor-
responding to an AE scheme, veriﬁes whether the scheme is
secure, and a synthesis module that synthesizes AE schemes
by enumerating candidate AE schemes and using the anal-
ysis module to see if they are secure. We describe these
components below, where throughout this section, the term
graph denotes an unlabeled graph.

Analyzer. The analysis module takes as input a representa-
tion (in a stack-based language) of the Dec and Tag graphs;
the stack-based language makes it easy to both convert the
inputs into their respective graphs as well as to synthesize
schemes. We ﬁrst derive a graph for the Enc algorithm given
the graph for the Dec algorithm, as described below. Given
graphs for the Enc, Dec, and Tag algorithms, we can then
run the privacy and authenticity checks described in Fig-
ure 3.7 to check security of the scheme. Our analyzer is
able to verify simpliﬁed variants of OCB [23], XCBC [12],
COPA [3], OTR [21], and CCM [10], among others.

Deriving the Enc graph. We implement an algorithm
Reverse that, given a Dec graph, computes a corresponding
Enc graph if one exists. The basic idea is to swap the IN and
OUT nodes of the input graph (recall that IN and OUT nodes in
the Dec graph denote ciphertext blocks and plaintext blocks,
respectively, whereas IN and OUT nodes in the Enc graph are
ﬂipped), and then selectively reverse the edges to ensure that
each node has correct ingoing/outgoing degrees. Deriving
the Enc graph is thus simple if there is at most one path
from an IN node to an OUT node and these paths do not
cross, as in the case of OCB. However, in other schemes,
such as OTR, each IN node may have multiple paths to
each OUT node. We handle this as described next.
−
1 . In
G1, rename IN nodes as OUT nodes, and OUT nodes as IN
nodes; let G2 be the resulting graph. Reverse then assigns
direction to the edges of G2 such that each node has correct
−
2 is output.
ingoing/outgoing degrees; the resulting graph G
(If no assignment is possible, then the output is ⊥.)

1 , let G1 be the undirected graph of G
−

On input G

To implement this idea eﬃciently, we color each node ei-
ther “red” or “blue”, where red nodes denote nodes that have
already been processed, and blue nodes denote unprocessed
nodes. Starting from G2, we initially color IN and INI nodes
red and all other nodes blue. We repeatedly iterate over the
blue nodes until we reach a ﬁxed point, where in each iter-
ation we assign direction to some edges and re-color some
nodes red. If a ﬁxed point is reached before all nodes have
been colored red, we return ⊥; otherwise, we return G2,

92which represents the reversed graph. If the graph G2 has r
nodes then we have at most r iterations with each iteration
taking O(r) time.

In each iteration, we process each blue node x as follows.
Let ord(x) = 2 if x is an XOR node, and let ord(x) = 1
otherwise. If there are exactly ord(x) red neighbors of x then
(1) for each such neighbor y, assign the direction y → x, and
(2) color x red. Note that in each step we ensure that the
current node x has the correct ingoing degree if we color
it red. We never assign an ingoing edge to x in any other
step. Hence when there are no blue nodes, each node in the
directed graph has the correct ingoing/outgoing degrees.

We prove in the full version [13] that Reverse is sound;
namely, that if running Reverse on a Dec graph produces
an Enc graph, then Dec is a correct decryption algorithm
for Enc.

As a side note, the Reverse algorithm allows us to easily
check if a scheme is inverse-free (i.e., the scheme only uses
the forward direction of the TBC), which is important when
constructing hardware realizations of AE schemes due to the
potential savings in chip space, among other beneﬁts [15, 21].
After running Reverse, we can check if the parent nodes for
all the TBC nodes in the Enc and Dec graph are the same; if
so, the scheme is inverse-free.

Synthesizer. We synthesize schemes as follows. Fixing a
Tag graph, we enumerate all possible Dec graphs of a given
size, pruning out “uninteresting” schemes such as ones with
two (or more) TBC nodes chained together, and feed each pair
of (Dec, Tag) graphs to our analysis module. To generate
the Dec graph, we start from a graph containing just the
IN and INI nodes, and add nodes and their corresponding
edges until the given size bound is reached. If the resulting
graph is “well-formed” (i.e., there are no “dangling” edges
and no loops), we derive the corresponding Enc graph as
discussed above and run the analysis module on the result.
Unfortunately, this approach is prohibitively expensive as
described, especially as the size bound increases. Thus, we
use several optimizations to speed up the process.

Firstly, instead of synthesizing graphs with FIN and OUT
nodes, we replace these with “terminal” nodes. Upon de-
riving a well-formed graph, we replace the “terminal” nodes
with all possible permutations of FIN and OUT nodes and
check security of each. Thus we no longer need to explore
the search space for each FIN and OUT node; instead, we
explore the search space once using a “terminal” node, and
later replace the “terminal” node with all possible combi-
nations of FIN and OUT nodes. Likewise, we can apply this
same idea to INI and IN nodes by introducing a “start” node.
Secondly, we observe that AE schemes like OCB, COPA,
and OTR do not utilize one of the INI nodes in the sense that
they simply output the input value directly. Thus, we can
remove two nodes from the synthesis by only synthesizing
schemes containing one INI and FIN node. The drawback
of this optimization is that it misses schemes such as XCBC
and CCM which do in fact use both INI nodes; however,
it greatly speeds up synthesis. All the results that follow
use this optimization. (It would, of course, be possible to
synthesize schemes without using this optimization.)

Results. Using the optimizations described above, we ran
our synthesizer to ﬁnd AE schemes with Dec and Enc graphs
of sizes between twelve and sixteen (we found no AE schemes
with size less than twelve). Note that our synthesizer does

#

12
13
14
15
16

13 (0)
142 (0)
582 (2)

2826 (54)
3090 (—)

13
0

171
40
66

290

7
0

48 (4)

18

25 (4)

5
0
5
6
1

98 (8)

17

47 sec
4.3 min
24.2 min
2.8 hours
3 hours∗

Unique

“Optimal” WP

SP

Time

Total

6653

Figure 4.1: Synthesis results. The ﬁrst column
shows the number of instructions in the Dec graph
of the given scheme; the second column the number
of secure (and unique) schemes, with the number
in parentheses denoting the number of schemes in
which the security check fails but we cannot auto-
matically ﬁnd a concrete attack; the third column
the number of (secure) schemes that are “optimal”,
i.e., having two TBC nodes per Dec graph; the fourth
column the number of “optimal” weakly paralleliz-
able schemes, with the number in parentheses de-
noting the weakly parallelizable schemes which only
use the forward direction of the TBC; the ﬁfth col-
umn the number of “optimal” strongly parallelizable
schemes; and the ﬁnal column the total synthesis
time, where an asterisk indicates that we halted ex-
ecution after the given time.

not remove duplicate schemes. In addition, there are many
“equivalent” schemes in the sense that one is the same as
another except with the outputs and/or inputs ﬂipped. We
thus developed a heuristic to remove duplicate and “equiv-
alent” schemes as follows. Let F (·,·,·) be the encrypt op-
eration of a given scheme, where the ﬁrst argument is the
INI input (recall we consider the simpliﬁed variant where we
only use one INI node) and the other arguments are the IN
inputs. Choosing arbitrary but ﬁxed inputs X, M1, and M2,
we compute Y (cid:107)C1(cid:107)C2 := F (X, M1, M2) and Y (cid:48)(cid:107)C(cid:48)
2 :=
F (X, M2, M1). We maintain a table of existing ciphertexts;
if any of Y C1C2, Y C2C1, Y (cid:48)C(cid:48)
1 exists in the
table, we discard the scheme as a “duplicate”; otherwise, we
add each of these to the table and continue.

2, or Y (cid:48)C(cid:48)

1(cid:107)C(cid:48)

1C(cid:48)

2C(cid:48)

Figure 4.1 shows the results. The experiments were run
on a commodity laptop; because of the long running time for
synthesizing schemes of size sixteen, we stopped the synthe-
sis after three hours for this size. Due to the large number of
discovered schemes, we developed two algorithms to prune
the result space. The ﬁrst simply ﬁlters out all schemes Π
such that Cost(Π) > c for some integer c. In Figure 4.1 we
set c = 2, thus pruning out all non-“rate-1” schemes; this
removes 95% of the found schemes.

Our second algorithm checks whether a scheme is paral-
lelizable, an important criterion for AE schemes. Note that
we can view the encryption of a message M = M1 ··· M2m as
a single graph constructed from m Enc graphs G1, . . . , Gm,
where the FIN nodes of Gi coincide with the INI nodes of
Gi+1. We can then assign a “depth” to each node in this
graph as follows: (1) The INI nodes in G1 and the IN nodes
in {Gi} get a depth of 0; (2) For each node x, let t be
the maximum depth of x’s parent(s);
if x is a TBC node
then depth(x) = t + 1; otherwise depth(x) = t. (Intuitively,
depth(x) represents the latency, in terms of the number of
TBC calls, of computing the value at node x.) We can use
the same idea to compute a “depth” for decryption.

93Scheme Enc (cycles/byte) Dec (cycles/byte)

OCB

1
2
3

0.7122 ± 0.0072
0.7253 ± 0.0055
0.7116 ± 0.0025
0.8139 ± 0.0121

0.7650 ± 0.0025
0.7485 ± 0.0047
0.7643 ± 0.0023
2.7566 ± 0.0010

Figure 4.3: Performance results of OCB and the
three synthesized schemes in Figure 4.2 (Scheme 1
denotes the top scheme, Scheme 2 the middle
scheme, and Scheme 3 the bottom scheme). We re-
port the time for encryption and decryption when
processing a 4096-bit message with empty associated
data, along with the 95% conﬁdence intervals over
100 runs of each scheme. The experiments were run
on a 4-core 2.90 GHz Intel Core i5-4210H CPU with
TurboBoost disabled.

is strongly parallelizable; for the third scheme, however, de-
cryption cannot be parallelized.) We implemented all three
schemes and compared their performance with that of an
optimized implementation of OCB by Krovetz9 using AES-
NI; see Figure 4.3. (Note that the results in Figure 4.3 are
preliminary timing numbers; the purpose of these experi-
ments is to show that our schemes are competitive with, not
necessarily better than, OCB.) We ﬁnd that the encryption
procedure for all four schemes is comparable. However, the
decryption procedure of the third synthesized scheme is no-
ticeably slower than the others. This is because decryption
for this scheme is not parallelizable; namely, to decrypt ci-
phertext block Ci we need plaintext block Mi−1.

In addition, among the weakly parallelizable schemes, we
found eight schemes which are inverse-free (we found no such
schemes for strongly parallelizable schemes). The schemes
of size fourteen that we found use one fewer XOR instruction
than OTR, the fastest known inverse-free AE scheme we are
aware of.

We also ran our attack generation algorithm over schemes
of size 12–15 and found that the number of schemes where
no attack could be found closely matched the number of
schemes our analysis found secure, thus pointing to the fact
that while our analysis is not sound, it appears to capture
most secure schemes; see the full version [13] for details.

We remark that our tool currently takes a given bound S
and enumerates all schemes in which decryption can be im-
plemented using at most S instructions. In future work one
could consider assigning a cost to diﬀerent instructions (e.g.,
letting DUP have cost 0, and letting TBC have cost some ﬁxed
multiple of XOR) and enumerating all schemes having at most
some given cost.

5. CONCLUSION

In this work, we present a methodology for automatically
proving the security of a large class of authenticated en-
cryption (AE) schemes. Using our approach, we are able to
synthesize thousands of schemes, most of which have never
been studied in the literature. Among these, we discovered
ﬁve new schemes which are as “compact” (in terms of the
number of instructions per message block), as “eﬃcient” (in
terms of the number of blockcipher calls per message block),
and as parallelizable as OCB, with competitive performance.
There are several interesting avenues for future work. Fur-
ther optimizing the synthesis procedure would allow us to
9See http://web.cs.ucdavis.edu/~rogaway/ocb/news.

Figure 4.2: Three of our synthesized schemes of
size twelve,
illustrated for a four-block message
M1, . . . , M4. In the second scheme, Σ is the check-
sum of the even blocks, i.e., Σ = M2 ⊕ M4.

We now deﬁne our notion of parallelizability. We call an
AE scheme Π weakly parallelizable if for any integer m and
any node x in the graph described above we have depth(x) ≤
Cost(Π) for both encryption and decryption. A scheme is
strongly parallelizable if depth(x) ≤ 1.
Intuitively, weakly
parallelizable schemes are ones where the TBC calls can
be parallelized across two-block chunks (but not necessarily
within the processing of a two-block chunk), and strongly
parallelizable schemes are ones where the TBC calls can be
parallelized even within a two-block chunk. As an example,
OTR (cf. Figure 3.9) is weakly parallelizable while OCB (cf.
Figure 3.2) is strongly parallelizable.

We can check these conditions eﬃciently by noting ﬁrst
that we only need to look at the OUT and FIN nodes, since
depth is strictly increasing. Now, suppose we run the analy-
sis on graph Gi. If the depth of the FIN nodes is zero, then
it suﬃces to compute t = max{depth(OUT1), depth(OUT2)}
(where OUT1 and OUT2 are the two OUT nodes) and check
whether t ≤ Cost(Π) or t ≤ 1.
If the FIN nodes have
depth greater than zero (say, c), we need to rerun the
analysis, this time setting the depths of the INI nodes
to c (rather than zero). We can then compute t(cid:48) =
max{depth(OUT1), depth(OUT2)}. If t(cid:48) (cid:54)= t then this implies
that depth grows with m (and thus the scheme is not paral-
lelizable); otherwise we can check whether t(cid:48) ≤ Cost(Π) or
t(cid:48) ≤ 1 to determine whether the scheme is parallelizable.

Looking at the results of Figure 4.1, we found thirteen
secure AE schemes of size twelve, ﬁve of which are strongly
parallelizable. Of these schemes, as far as we know, only
OCB exists in the literature. In Figure 4.2 we show two of
these newly synthesized schemes, along with one which is not
parallelizable. (For all the schemes in the ﬁgure, encryption

M1M2C1C2M3M4C3C4tagτM1M2C1C2M3M4C3C4tagτΣ M1M2C1C2M3M4C3C4tagτ94generate more schemes. Some of these schemes may have ad-
ditional properties of interest, such as misuse-resistance [11];
developing techniques for automatically checking schemes
for these additional properties would be very useful. Taking
a diﬀerent approach, it would be interesting to see if simi-
lar techniques can be applied to more general classes of AE
schemes.

Acknowledgments
We thank Samuel Neves for pointing out that on Haswell
CPUs, TurboBoost must be disabled to measure the timing
accurately. We also thank the anonymous reviewers of CCS
2015 for their suggestion of automatic generation of attacks
on schemes that fail our tests.

Work of Jonathan Katz was done for Exelis under contract
number N00173-11-C-2045 to NRL. Work of Alex J. Mal-
ozemoﬀ was conducted with Government support awarded
by DoD, Air Force Oﬃce of Scientiﬁc Research, National
Defense Science and Engineering Graduate (NDSEG) Fel-
lowship, 32 CFR 168a.

6. REFERENCES
[1] Joseph A. Akinyele, Matthew Green, and Susan

Hohenberger. Using SMT solvers to automate design
tasks for encryption and signature schemes. In ACM
CCS 2013, pages 399–410, November 2013.
[2] Joseph A. Akinyele, Matthew Green, Susan

Hohenberger, and Matthew W. Pagano.
Machine-generated algorithms, proofs and software for
the batch veriﬁcation of digital signature schemes. In
ACM CCS 2012, pages 474–487, October 2012.

[3] Elena Andreeva, Andrey Bogdanov, Atul Luykx, Bart

Mennink, Elmar Tischhauser, and Kan Yasuda.
Parallelizable and authenticated online ciphers. In
Asiacrypt 2013, pages 424–443, December 2013.

[4] Gilles Barthe, Juan Manuel Crespo, Benjamin

Gr´egoire, C´esar Kunz, Yassine Lakhnech, Benedikt
Schmidt, and Santiago Zanella B´eguelin. Fully
automated analysis of padding-based encryption in the
computational model. In ACM CCS 2013, pages
1247–1260, November 2013.

[5] Gilles Barthe, Edvard Fagerholm, Dario Fiore,
John C. Mitchell, Andre Scedrov, and Benedikt
Schmidt. Automated analysis of cryptographic
assumptions in generic group models. In Crypto 2014,
pages 95–112, August 2014.

[6] Gilles Barthe, Edvard Fagerholm, Dario Fiore, Andre

Scedrov, Benedikt Schmidt, and Mehdi Tibouchi.
Strongly-optimal structure preserving signatures from
type II pairings: Synthesis and lower bounds. In
PKC 2015, pages 355–376, March / April 2015.

[7] Mihir Bellare and Chanathip Namprempre.

Authenticated encryption: Relations among notions
and analysis of the generic composition paradigm.
Journal of Cryptology, 21(4):469–491, October 2008.

[8] Mihir Bellare and Phillip Rogaway. The security of

triple encryption and a framework for code-based
game-playing proofs. In Eurocrypt 2006, pages
409–426, May / June 2006.

[9] Dan Bernstein. Cryptographic competitions:

CAESAR call for submissions, ﬁnal (2014.01.27).
http://competitions.cr.yp.to/caesar-call.html.

[10] Morris Dworkin. Recommendations for block cipher

modes of operation: The CCM mode for
authentication and conﬁdentiality. NIST Special
Publication 800-38C, July 2007.

[11] Ewan Fleischmann, Christian Forler, and Stefan

Lucks. McOE: A family of almost foolproof on-line
authenticated encryption schemes. In FSE 2012, pages
196–215, March 2012.

[12] Virgil D. Gligor and Pompiliu Donescu. Fast

encryption and authentication: XCBC encryption and
XECB authentication modes. In FSE 2001, pages
92–108, April 2002.

[13] Viet Tung Hoang, Jonathan Katz, and Alex J.

Malozemoﬀ. Automated analysis and synthesis of
authenticated encryption schemes. Cryptology ePrint
Archive, Report 2015/624, 2015.
https://eprint.iacr.org/2015/624.

[14] Tetsu Iwata, Keisuke Ohashi, and Kazuhiko

Minematsu. Breaking and repairing GCM security
proofs. In Crypto 2012, pages 31–49, August 2012.
[15] Tetsu Iwata and Kan Yasuda. BTM: A single-key,

inverse-cipher-free mode for deterministic
authenticated encryption. In SAC 2009, pages
313–330, August 2009.

[16] Jonathan Katz and Moti Yung. Unforgeable

encryption and chosen ciphertext secure modes of
operation. In FSE 2000, pages 284–299, April 2001.

[17] Ted Krovetz and Phillip Rogaway. The software

performance of authenticated-encryption modes. In
FSE 2011, pages 306–327, February 2011.

[18] Moses Liskov, Ronald L. Rivest, and David Wagner.

Tweakable block ciphers. In Crypto 2002, pages 31–46,
August 2002.

[19] Alex J. Malozemoﬀ, Jonathan Katz, and Matthew D.

Green. Automated analysis and synthesis of
block-cipher modes of operation. In IEEE CSF 2014,
pages 140–152, July 2014.

[20] David A. McGrew and John Viega. The security and

performance of the Galois/counter mode (GCM) of
operation. In Indocrypt 2004, pages 343–355,
December 2004.

[21] Kazuhiko Minematsu. Parallelizable rate-1

authenticated encryption from pseudorandom
functions. In Eurocrypt 2014, pages 275–292, May
2014.

[22] Phillip Rogaway. Authenticated-encryption with

associated-data. In ACM CCS 2002, pages 98–107,
November 2002.

[23] Phillip Rogaway. Eﬃcient instantiations of tweakable

blockciphers and reﬁnements to modes OCB and
PMAC. In Asiacrypt 2004, pages 16–31, December
2004.

[24] Phillip Rogaway. Nonce-based symmetric encryption.

In FSE 2004, pages 348–359, February 2004.

[25] Phillip Rogaway, Mihir Bellare, John Black, and Ted
Krovetz. OCB: A block-cipher mode of operation for
eﬃcient authenticated encryption. In ACM CCS 2001,
pages 196–205, November 2001.

[26] Ashish Tiwari, Adri`a Gasc´on, and Bruno Dutertre.

Program synthesis using dual interpretation. In CADE
2015, August 2015.

95