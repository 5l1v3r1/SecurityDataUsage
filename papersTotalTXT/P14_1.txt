A	  General	  Approach	  for	  Eﬃciently	  

Accelera3ng	  So6ware-­‐based	  Dynamic	  Data	  

Flow	  Tracking	  on	  Commodity	  Hardware	  

Kangkook	  Jee	  	  

Columbia	  University	  

Joint	  work	  with	  

Georgios	  Portokalidis1	  ,	  Vasileios	  Kemerlis1	  ,	  	  

Soumyadeep	  Ghosh2,	  David	  August2,	  Angelos	  Keromy3s1	  

1Columbia	  University,	  2Princeton	  University	  

1	  

Data	  Flow	  Tracking	  (DFT)	  

•  A	  great	  security	  tool	  with	  many	  applica3ons	  

– Tag	  input	  data	  and	  track	  them	  
– So6ware	  exploits,	  Informa3on	  misuse	  or	  leakage	  

malware	  analysis	  …	  

•  Implementa3on	  approaches	  

– Hardware	  assisted:	  Raksha,	  RIFLE	  …	  
– Source	  code	  based:	  GIFT	  …	  
– Binary	  only:	  TaintCheck,	  Dytan,	  Minemu,	  Libd6	  …	  

	  Binary	  only	  DFT:	  Most	  promising,	  but	  too	  slow!	  

2	  

This	  Talk	  Is	  About	  

•  New	  op3miza3on	  approach	  for	  

– Currently	  sub-­‐op3mal	  binary	  only	  DFT	  
– Performance	  gain	  up	  to	  x2.23	  (on	  average	  x1.77)	  
– Real-­‐world	  applica3ons:	  Firefox,	  Chrome	  …	  

•  Segrega3on	  of	  tracking	  logic	  from	  execu3on	  

– Taint	  Flow	  Algebra	  (TFA):	  IR	  for	  DFT	  
– Compiler	  op3miza3on	  +	  DFT	  speciﬁc	  op3miza3on	  

3	  

DFT:	  Basic	  Aspects	  

•  DFT	  is	  characterized	  by	  three	  aspects	  	  

(1)  Data	  Sources:	  program	  or	  memory	  loca3ons	  where	  data	  
of	  interest	  enter	  the	  system	  and	  is	  subsequently	  tagged	  
(2)  Data	  tracking:	  process	  of	  propaga3ng	  data	  tags	  
(3)  Data	  Sinks:	  program	  or	  memory	  loca3ons	  where	  checks	  

according	  to	  the	  program’s	  seman3cs	  

for	  “tagged”	  data	  can	  be	  made	  

Shadow Memory

(1)

Input
File
Network
Keyboard
Source

mov eax,   [ebx]
 

(2)

mov [esi],   eax

Data Tracking

(3)

Output
File
Network

(cid:1)(cid:2)(cid:4)(cid:3)

4	  

DFT	  Opera3on	  

Real Memory

•  Real	  Memory	  =	  Address	  space	  +	  register	  context	  

5	  

DFT	  Opera3on	  

Real Memory

Shadow Memory

•  Real	  Memory	  =	  Address	  space	  +	  register	  context	  
•  Shadow	  memory	  to	  track	  metadata	  update	  	  	  

6	  

DFT	  Opera3on	  

 dst[idx1] = src[idx0];

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

7	  

DFT	  Opera3on	  

 dst[idx1] = src[idx0];

Real Memory

 t(dst[idx1]) = t(src[idx0]);

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  
•  Corresponding	  shadow	  memory	  update	  

8	  

DFT	  Opera3on	  

 dst[idx1] = src[idx0];

mov reg0  ! [src+idx0]

 t(dst[idx1]) = t(src[idx0]);

   mov [dst+idx1] ! reg0

Real Memory

Shadow Memory

•  Original	  opera3on	  translated	  into	  machine	  code	  	  
•  It	  requires	  intermediate	  register	  repository	  (reg0)	  

9	  

DFT	  Opera3on	  

 dst[idx1] = src[idx0];

mov reg0  ! [src+idx0]

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0

 t(dst[idx1]) = t(src[idx0]);

   mov [dst+idx1] ! reg0

Real Memory

Shadow Memory

•  Instruc3on	  level	  instrumenta3on	  to	  implement	  

shadow	  update	  

10	  

DFT	  Opera3on	  

 dst[idx1] = src[idx0];

Real Memory

 t(dst[idx1]) = t(src[idx0]);

Shadow Memory

mov reg0  ! [src+idx0]

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0

   mov [dst+idx1] ! reg0

   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0

•  2	  original	  instruc3ons	  +	  4	  tracking	  instruc3ons	  
•  2	  instrumenta3on	  units	  

11	  

Why	  So	  Slow?	  

•  Framework	  cost	  

– DBI,	  Hypervisor	  instrumenta3on	  

•  DFT	  cost	  

– Accesses	  to	  shadow	  storage	  

•  Naïve	  Implementa3on	  

– No	  understanding	  of	  global	  context	  
– No	  understanding	  of	  DFT	  seman3cs	  

12	  

Our	  Approach	  

•  Applica3on	  speciﬁc	  analysis	  
•  DFT	  speciﬁc	  analysis	  
•  Integrated	  with	  libd)	  

– High	  performance	  DFT	  tool	  	  [VEE	  2012]	  	  
•  1.46x	  ~	  8x	  slowdown	  (over	  na3ve	  execu3on)	  
– Designed	  for	  use	  with	  Pin	  DBI	  framework	  	  
– Open	  source	  

•  hqp://www.cs.columbia.edu/~vpk/research/libd6	  

13	  

Op3mizing	  DFT	  

mov reg0  ! [src+idx0]

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0

   mov [dst+idx1] ! reg0

   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  requires	  head/tail	  instruc3ons	  
•  t(	  )	  :	  shadow	  memory	  access	  cost	  

14	  

Op3mizing	  DFT	  

mov reg0  ! [src+idx0]

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0

   mov [dst+idx1] ! reg0

   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0

•  Re-­‐locatable	  

15	  

Op3mizing	  DFT	  

mov reg0  ! [src+idx0]
mov [dst+idx1] ! reg0

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0

•  Less	  instrumenta3on	  units	  (21)	  

16	  

Op3mizing	  DFT	  

mov reg0  ! [src+idx0]
mov [dst+idx1] ! reg0

   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0

•  Less	  instrumenta3on	  units	  (21)	  
•  Less	  tracking	  instruc3ons	  (42)	  

17	  

Execu3on	  Model	  

•  3	  Components	  

–  Feedback	  loop	  

–  	  Proﬁler,	  Analyzer,	  DFT	  Run3me	  

•  Sta3c/oﬄine	  analysis	  +	  Dynamic	  run3me	  

Optimized data 

tracking

DFT 
Runtime

Analyzer

Unprocessed 
basic blocks

Control ﬂow
information

Basic blocks

Dynamic 
proﬁler

Static 
Proﬁler

18	  

Analyzer	  

•  Taint	  Flow	  Algebra	  

–  Represent	  binary	  analysis	  result	  
–  IR	  tailored	  to	  capture	  DFT	  seman3cs	  
•  Compiler	  op3miza3on	  to	  TFA	  

–  Inner	  (intra)	  basic	  block:	  
–  Outer	  (inter)	  basic	  block:	  	  

	  Dead	  code	  elimina3on,	  Algebraic	  simpliﬁca3on,	  …	  

	  Data	  ﬂow	  analysis	  

•  DFT	  speciﬁc	  considera3ons	  

–  Valid	  loca3on	  for	  each	  instrumenta3on	  unit	  
–  Number	  of	  instrumenta3on	  units	  

19	  

TFA	  Op3miza3on	  

!"#$%&#'()*#'+,
-"#$%&.)/#'0)*#01
2"#+31#'()*#4)5
6"#077#'7)*4)!
5"#1'0#'+,*#89:#;'()<'+,=
>"#1'0#'+,*#89:#;'0)<'+,=
?"#$%&.)/#'0)*#89:#;'7)<'+,=######
@"#9'+9/#01*#01
A"#BC./#4)/?@A4-44

(a) x86 instruction

•  Per	  basic	  block	  analysis	  
•  Gray	  instruc3ons:	  non-­‐tracking	  instruc3ons	  

20	  

TFA	  Op3miza3on	  

!"#$%&#'()*#'+,
-"#$%&.)/#'0)*#01
2"#+31#'()*#4)5
6"#077#'7)*4)!
5"#1'0#'+,*#89:#;'()<'+,=
>"#1'0#'+,*#89:#;'0)<'+,=
?"#$%&.)/#'0)*#89:#;'7)<'+,=######
@"#9'+9/#01*#01
A"#BC./#4)/?@A4-44

!"#$%&!#"'#$()*
+"#$,&!#"'#*&!#-#$,&*
."#
/"#
0"#$()!#"'#$%&!#1#$()*
2"#$()+#"'#$,&!#1#$()!
3"#$,&+#"'#*&!#-#4$5&*6$()+7
8"#
9"#

(a) x86 instruction

(b) TFA transformation

•  Translated	  into	  TFA	  
•  Input	  operands,	  output	  operands	  

21	  

TFA	  Op3miza3on	  

!"#$%&#'()*#'+,
-"#$%&.)/#'0)*#01
2"#+31#'()*#4)5
6"#077#'7)*4)!
5"#1'0#'+,*#89:#;'()<'+,=
>"#1'0#'+,*#89:#;'0)<'+,=
?"#$%&.)/#'0)*#89:#;'7)<'+,=######
@"#9'+9/#01*#01
A"#BC./#4)/?@A4-44

!"#$%&!#"'#$()*
+"#$,&!#"'#*&!#-#$,&*
."#
/"#
0"#$()!#"'#$%&!#1#$()*
2"#$()+#"'#$,&!#1#$()!
3"#$,&+#"'#*&!#-#4$5&*6$()+7
8"#
9"#

!"#$%&!#"'#$()*
+"
,"#
-"#
."#
/"#$()+#"'#*&!#0#$1&*#2$()*
3"#$1&+#"'#*&!#0#4$5&*6$()+7
8"#
9"#

(a) x86 instruction

(b) TFA transformation

(c) TFA optimization

•  Output	  operands	  are	  expressed	  in	  terms	  of	  input	  

operands	  

•  Data	  ﬂow	  analysis	  to	  remove	  irrelevant	  outputs	  

22	  

TFA	  Op3miza3on	  

!"#$%&#'()*#'+,
-"#$%&.)/#'0)*#01
2"#+31#'()*#4)5
6"#077#'7)*4)!
5"#1'0#'+,*#89:#;'()<'+,=
>"#1'0#'+,*#89:#;'0)<'+,=
?"#$%&.)/#'0)*#89:#;'7)<'+,=######
@"#9'+9/#01*#01
A"#BC./#4)/?@A4-44

(a) x86 instruction

|

esi2

&

eax2

&

eax1

&

esi1

[edx0+esi2]

0x1

eax0

0x1

esi0

ecx1

•  DAG	  Representa3on	  
•  Express	  root	  nodes	  in	  terms	  of	  leaf	  nodes	  

DAG Representation

23	  

DFT	  Run3me	  

•  Generate/Inject	  op3mized	  tracking	  code	  to	  

the	  baseline	  DFT	  plavorm	  
– Translate	  op3mized	  TFA	  	  

•  Our	  prototype	  extends	  libd6	  	  
•  Code	  genera3on	  of	  libd6/PIN-­‐aware	  C	  code	  

– A	  func3on	  per	  each	  instrumenta3on	  unit	  
– e.g.,	  Firefox:	  50K	  customized	  func3ons	  	  

24	  

Evalua3on	  

•  Op3miza3on	  schemes	  

•  Inner,	  Outer	  

–  Code	  reduc3on:	  Simple	  dead	  code	  elimina3ons	  
–  Code	  genera3on:	  Op3mized	  tracking	  codes	  
–  TFA	  Scaqer,	  TFA	  Aggrega3on	  

Category	  

Op9miza9on	  
schemes	  

CFG	  
Considera9on	  

TFA	  
Op9miza9on	  

Aggrega9on	  

Code	  reduc3on	  

Inner	  

Code	  
genera3on	  

Outer	  

Scaqer	  

Aggrega3on	  

No	  

Yes	  

Yes	  

Yes	  

No	  

No	  

Yes	  

Yes	  

No	  

No	  

No	  

Yes	  

25	  

Evalua3on:	  SPEC	  CPU2000	  

libdft
Inner
Outer
TFA scatter
TFA aggr

)
d
e
z

i
l

a
m
r
o
N

(
 

n
w
o
d
w
o
S

l

 12

 10.5

 9

 7.5

 6

 4.5

 3

 1.5

 0

crafty

eon

gap

gcc

•  CPU	  intensive	  workloads	  
•  TFA’s	  speedup	  over	  libd6:	  	  on	  average	  1.90x	  (the	  largest	  2.23x)	  
•  ~3x	  slowdown	  over	  the	  na3ve	  execu3on	  

mcf

parserperlbmk twolf

vortex

vpr average

26	  

Evalua3on:	  Server	  applica3ons	  

(a) MySQL

libdft
Inner
Outer
TFA scatter
TFA aggr

)
d
e
z

i
l

a
m
r
o
n
(
 
n
w
o
d
w
o
S

l

 28

 24

 20

 16

 12

 8

 4

ATIS

(b) PHP

libdft
Inner
Outer
TFA scatter
TFA aggr

casing

md5

sha1

average

PHPBench Benchmark

)
d
e
z

i
l

a
m
r
o
n
(
 
n
w
o
d
w
o
S

l

 7

 6

 5

 4

 3

 2

 1

create

•  Mysql’s	  own	  benchmark	  suite	  (sql-­‐bench)	  and	  PHP	  micro	  benchmark	  suite	  

alter

insert
Test suite

(PHPBench)	  
–  Ploqed	  representa3ve	  subsets	  

27	  

Evalua3on:	  Client	  Applica3ons	  

)
d
e
z

i
l

a
m
r
o
n
(
 

n
w
o
d
w
o
S

l

 11

 10

 9

 8

 7

 6

 5

 4

 3

 2

 1

(a) Web site rendering

(b) Javascript

libdft
Inner
Outer
TFA scatter
TFA aggr

libdft
Inner
Outer
TFA scatter
TFA aggr

)
d
e
z

i
l

a
m
r
o
n
(
 

n
w
o
d
w
o
S

l

 18

 15

 12

 9

 6

Gmail

NDSS

Youtube Facebook

firefox

chrome

Web site

Browser

•  Rendering	  measurement	  for	  Alexa’s	  Top	  500	  sites	  and	  NDSS	  2012	  site	  
•  Dromaeo	  (hqp://www.dromaeo.com)	  Javascript	  benchmark	  suite	  

–  For	  Firefox	  web-­‐browser	  

–  For	  Firefox	  and	  Google	  Chrome	  web-­‐browser	  

28	  

Discussion	  

•  TFA	  for	  other	  DFT	  solu3ons	  

–  For	  most	  binary	  DFT	  implementa3ons	  
–  Orthogonal	  to	  exis3ng	  op3miza3on	  schemes	  

e.g.,	  TaintCheck,	  Dytan,	  Minemu	  …	  

e.g.,	  LIFT	  

•  Tools	  with	  memory	  shadowing	  

–  Memcheck	  (Valgrind),	  Dr.	  Memory	  (DynamoRIO)	  

•  Higher	  perspec3ve	  

–  Oﬄine	  analysis	  to	  improve	  expensive	  dynamic	  

monitors	  

29	  

Conclusion	  

•  Current	  binary-­‐only	  DFT	  implementa3ons	  are	  

sub	  op3mal	  
– No	  considera3on	  for	  DFT	  seman3cs	  
– No	  considera3on	  for	  global	  context	  

•  Proposed	  a	  novel	  op3miza3on	  scheme	  that	  

– Combines	  sta3c	  and	  dynamic	  analysis	  
– Segregates	  execu3on	  and	  tracking	  logic	  

•  ~2x	  Speedup	  for	  real-­‐world	  applica3ons	  

30	  

Backup	  slides	  

31	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

t(idx) = TAINT;
t(arr[idx+1]) = t(arr[idx]);

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

mov [idx]  ! recv()

mov reg0  ! [arr+idx]

t(idx) = TAINT;
t(arr[idx+1]) = t(arr[idx]);

   mov [arr+idx+1] ! reg0

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

mov [idx]  ! recv()

 mov t([idx])  ! 1

mov reg0  ! [arr+idx]

t(idx) = TAINT;
t(arr[idx+1]) = t(arr[idx]);

   mov [arr+idx+1] ! reg0

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

t(idx) = TAINT;
t(arr[idx+1]) = t(arr[idx]);

mov [idx]  ! recv()

 mov t([idx])  ! 1

mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

Real Memory

Shadow Memory

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

DFT	  Opera3on	  

idx = recv();
 arr[idx+1] = arr[idx];

t(idx) = TAINT;
t(arr[idx+1]) = t(arr[idx]);

Real Memory

Shadow Memory

mov [idx]  ! recv()

 mov t([idx])  ! 1

mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

 mov reg0  ! [t(reg0)]
mov [t(arr+idx+1)] ! mov reg0

•  Memory	  copy	  statement	  from	  the	  original	  execu3on	  

Op3mizing	  DFT	  

mov [idx]  ! recv()

   mov t([idx])  ! 1

mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  require	  head/tail	  instruc3ons	  
•  t(	  ):	  shadow	  memory	  access	  cost	  

Op3mizing	  DFT	  

mov [idx]  ! recv()

   mov t([idx])  ! 1

mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  require	  head/tail	  instruc3ons	  
•  t(	  ):	  shadow	  memory	  access	  cost	  

Op3mizing	  DFT	  

mov [idx]  ! recv()
mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  require	  head/tail	  instruc3ons	  
•  t(	  ):	  shadow	  memory	  access	  cost	  

Op3mizing	  DFT	  

mov [idx]  ! recv()
mov reg0  ! [arr+idx]

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0

   mov [arr+idx+1] ! reg0

 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  require	  head/tail	  instruc3ons	  
•  t(	  ):	  shadow	  memory	  access	  cost	  

Op3mizing	  DFT	  

mov [idx]  ! recv()
mov reg0  ! [arr+idx]
mov [arr+idx+1] ! reg0

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0
 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Each	  Instrumenta3on	  unit	  require	  head/tail	  instruc3ons	  
•  t(	  ):	  shadow	  memory	  access	  cost	  

Op3mizing	  DFT	  

mov [idx]  ! recv()
mov reg0  ! [arr+idx]
mov [arr+idx+1] ! reg0

 mov reg0  ! [t(arr+idx)]
 mov [t(reg0)] ! reg0
 mov reg0  ! [t(reg0)]
 mov [t(arr+idx+1)] ! mov reg0

•  Less	  instrumenta3on	  units	  (21)	  
•  Less	  tracking	  instruc3ons	  (42)	  

