Improvements to Secure Computation with Penalties

Ranjit Kumaresan

Vinod Vaikuntanathan

Cambridge, Massachusetts

vranjit@mit.edu

Cambridge, Massachusetts

vinodv@mit.edu

MIT

MIT

Prashant Nalini

Vasudevan

MIT

Cambridge, Massachusetts

prashvas@mit.edu

ABSTRACT
Motivated by the impossibility of achieving fairness in secure com-
putation [Cleve, STOC 1986], recent works study a model of fair-
ness in which an adversarial party that aborts on receiving output
is forced to pay a mutually predeﬁned monetary penalty to every
other party that did not receive the output. These works show how
to design protocols for secure computation with penalties that tol-
erate an arbitrary number of corruptions.

In this work, we improve the efﬁciency of protocols for secure
computation with penalties in a hybrid model where parties have
access to the “claim-or-refund” transaction functionality. Our ﬁrst
improvement is for the ladder protocol of Bentov and Kumaresan
(Crypto 2014) where we improve the dependence of the script com-
plexity of the protocol (which corresponds to miner veriﬁcation
load and also space on the blockchain) on the number of parties
from quadratic to linear (and in particular, is completely indepen-
dent of the underlying function). Our second improvement is for
the see-saw protocol of Kumaresan et al. (CCS 2015) where we re-
duce the total number of claim-or-refund transactions and also the
script complexity from quadratic to linear in the number of parties.
We also present a ‘dual-mode’ protocol that offers different guar-
antees depending on the number of corrupt parties: (1) when s <
n/2 parties are corrupt, this protocol guarantees fairness (i.e., ei-
ther all parties get the output or none do), and (2) when t > n/2
parties are corrupt, this protocol guarantees fairness with penalties
(i.e., if the adversary gets the output, then either the honest parties
get output as well or they get compensation via penalizing the ad-
versary). The above protocol works as long as t + s < n, matching
the bound obtained for secure computation protocols in the stan-
dard model (i.e., replacing “fairness with penalties” with “security-
with-abort” (full security except fairness)) by Ishai et al. (SICOMP
2011).
Keywords: Bitcoin, secure computation, fairness.

1.

INTRODUCTION

Protocols for secure multiparty computation [29, 15, 8, 11] allow
a set of mutually distrusting parties to carry out a distributed com-
putation without compromising on privacy of inputs or correctness
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978421

of the end result. Despite being a powerful tool, it is known that se-
cure computation protocols do not provide fairness or guaranteed
output delivery when a majority of the parties are dishonest [12].1
Addressing this deﬁciency is critical if secure computation is to be
widely adopted in practice, especially given the current interest in
practical secure computation. Several workarounds have been pro-
posed in the literature to counter adversaries that may decide to
abort, possibly depending on the outcome of the protocol (see [28,
4, 23, 17]). In this work, we are interested in the workaround pro-
posed in [24, 23, 7] where an adversarial party that aborts on receiv-
ing output is forced to pay a mutually predeﬁned monetary penalty
to every other part that did not receive the output.
In practice,
such mechanisms would be effective if the compensation amount
is rightly deﬁned. While the original works [24, 23, 7] depended
on e-cash systems, recent works [5, 2, 9, 21, 1, 22, 19] have shown
how to use a decentralized digital currency (like Bitcoin) to design
protocols for secure computation in the penalty model.
Our contributions in a nutshell. We present two efﬁciency im-
provements to secure computation with penalties.

• We improve the total size of the transactions (more concretely
“script complexity” deﬁned below) used in secure computa-
tion with penalties for single stage computations. Let f de-
note the function being computed. Prior work by Bentov and
Kumaresan [9] required transactions of total size O(n2|z|)
where n is the number of parties and |z| is the size of the
output of f. We present a protocol that requires transactions
of total size O(nλ) where λ is the security parameter, and is
independent of f. This protocol works in the programmable
random oracle model.

• We improve the number of transactions and the total size of
the transactions used in secure computation with penalties
for multiple stage computations. Prior scheme by Kumare-
san et al. [22] had the number of transactions grow quadrati-
cally in the number of parties n. We present a protocol whose
number of transactions grows linearly in n. In particular, this
implies that the n-party poker protocol (among other appli-
cations) as described in [22] can be implemented using only
linear number of transactions.

Additionally, we present the following qualitative improvement

to secure computation with penalties.

• We present a “dual mode” protocol (alternatively, “best-of-
both-worlds” protocol) that offers different guarantees de-
pending on the number of corrupt parties: (1) when s < n/2
1Fairness guarantees that if one party receives output then all par-
ties receive output. Guaranteed output delivery ensures that an ad-
versary cannot prevent the honest parties from computing the func-
tion.

406parties are corrupt, this protocol guarantees fairness (i.e., ei-
ther all parties get the output or none do), and (2) when
t > n/2 parties are corrupt, this protocol guarantees fair-
ness with penalties (i.e., if the adversary gets the output, then
either the honest parties get output as well or they get com-
pensation via penalizing the adversary). The above protocol
works as long as t + s < n, matching the bound obtained for
secure computation protocols in the standard model (i.e., re-
placing “fairness with penalties” with “security-with-abort”
(full security except fairness)) by [18].

Next, we discuss the model and efﬁciency metrics for secure
computation with penalties. We follow the model used in [9, 21,
22] where parties are assumed to have access to the “claim-or-
refund” transaction functionality (discussed below). This func-
tionality can be implemented in Bitcoin (subject to limitations dis-
cussed below) or in Ethereum.
Claim-or-refund transaction functionality. In [9, 22], protocols
for secure computation with penalties are designed in a hybrid model
where parties have access to an ideal transaction functionality called
the claim-or-refund transaction functionality [9, 6, 26]. This func-
tionality, denoted as F∗
CR, takes care of handling “money/coins”
and allows protocols to be designed independently of the Bitcoin
ecosystem. F∗
CR implements the following functionality: (1) it ac-
cepts a deposit of coins(q), a Boolean circuit φ, and a time-limit
τ from a designated sender S; and (2) waits until time τ to get a
witness w from a designated receiver R such that φ(w) = 1; and
(3) if such a witness was received within time τ transfers coins(q)
to R; (4) else returns coins(q) back to S.

Three features of F∗

CR explain its importance: (1) F∗

CR can be
very efﬁciently implemented in Bitcoin [9, 6, 26] or in Ethereum,
(2) F∗
CR provides an abstraction which makes protocols designed
in the F∗
CR-hybrid model robust to changes in the Bitcoin archi-
tecture, and (3) F∗
CR is “complete” for secure computation with
penalties [9, 22]. Protocols for secure computation with penalties
CR-hybrid model work as long as F∗
designed in the F∗
CR is imple-
mented. Such an implementation need not be tied to Bitcoin, i.e.,
Bank of America, Paypal, etc. could, in principle, support F∗
CR
transactions. Each of the latter provides services by relying on its
own network for providing consistency of its “ledger” and at this
level, the underlying mechanics is not very different from Bitcoin.
Practical relevance of our contributions. Next, we discuss the
cost of secure computation with penalties in the F∗
CR-hybrid model
so that our contributions can be better understood. A protocol for
secure computation with penalties in the F∗
CR-hybrid model typ-
ically involves an sequence of F∗
CR transactions. The following
metrics capture the costs of such a protocol:

• The total number of calls to F∗

CR. This captures the number
of Bitcoin transactions that need to be broadcasted. Recall
that each transaction stays in the blockchain forever.

• The maximum/total size of the Boolean circuits φ employed
in the sequence. We refer to this as the “script complexity”
of the protocol since this goes inside the script of the F∗
CR
Bitcoin transaction. Script complexity captures the load on
the Bitcoin network and the veriﬁcation time for the miners
and SPV nodes. Larger φ also translates to larger scripts
and consequently larger transactions and transmitting them
across the network would also become a bottleneck.2

• The maximum/total amount of deposits (i.e., money) made to
F∗
CR. This captures the amount of collateral that each party
2We denote scripts as circuits (not as RAM programs) and their
size is proportional to their running time.

needs to input during the protocol (and will remain unusable
till the protocol completes). Recall that each honest party
would regain its deposit at the end of the protocol.

• The maximum time-limit τ used in the sequence. This cap-
tures the total time to completion for the protocol. Recall that
each transaction takes roughly 1 hour to be conﬁrmed on the
Bitcoin blockchain.

Our goal is to minimize these costs as much as possible. We refer
to the ﬁrst and second costs as “on-chain” costs since these costs
are shared by the Bitcoin miners and affect the Bitcoin system as
a whole. See also the discussion in [25]. We refer to the third and
the fourth costs as “off-chain” costs since these are costs borne by
the parties running the secure computation protocol. Note that the
above arguments are valid for any other alt-coin as well. Anyway,
in this work, we focus on improving the “on-chain” costs since
we believe these to be the major bottleneck. Our protocols make
heavy use of secure computation protocols but these are done off-
chain (except in our construction for the reactive setting), so their
costs are only shared between the participants and not by the Bit-
coin system. Finally, we note that in the non-reactive case our re-
sults provide a improvement in the script complexity over [9] while
keeping all other parameters equal. On the other hand, in the reac-
tive case, our results improve the script complexity relative to [22]
but perform worse in the total/max deposit expected. While [22]’s
deposits grow linearly in the number of stages of the reactive proto-
col, ours grows quadratically. (Note that the remaining parameters
are equal in both constructions.) Note that this is consistent with
our motivation of relieving the burden on the Bitcoin system and
off-loading more burden on the speciﬁc participants of the secure
computation with penalties protocol.
Important notes and caveats about the model. Our model is es-
sentially the standard model used in secure computation literature
except that we allow working in the F∗
(More
formal description of the model can be found in the next sec-
tion and also in [9].) While this model is Bitcoin-inspired, it is
Bitcoin-independent. Currently, there are several important limita-
tions about implementing F∗
CR in Bitcoin. For instance, the scripts
that can go inside a Bitcoin transaction (speciﬁcally, the value φ
in an F∗
CR transaction) are very limited—not all scripts are cur-
rently supported. There are also ongoing issues about malleability
of transactions and how it affects F∗
CR implementation (see discus-
sion in [3]). Newer and simpler implementations of F∗
CR namely
via OP_CHECKLOCKTIMEVERIFY have been suggested and ac-
cepted. The bottomline is that the Bitcoin code is highly volatile.
This is main reason why we follow the model in [9, 21, 22] and
work in an idealized model (i.e., by abstracting the F∗
CR trans-
action as an ideal functionality) with the hope of providing tech-
niques and results that are resistant to the frequent changes to the
Bitcoin code. Furthermore, since the limitations in the Bitcoin re-
alization are by no means fundamental (as evidenced by Ethereum
that proposes to realize all types of transaction functionalities), our
constructions also have practical value both in the Bitcoin system
and also elsewhere. To summarize, our results on secure com-
putation with penalties work on Bitcoin (or an alt-coin or using
a bank/trusted party) as long as the underlying F∗
CR transactions
are implementable in Bitcoin (or the corresponding alt-coin or a
bank/trusted party). At least one alt-coin, namely Ethereum, sup-
ports programmable contracts with no limitations on scripts and
thus can be used to implement our protocols.
Related work. We discussed the relation between our work and
the works of [9, 22]. The works of [5, 6] construct 2-party lottery
protocols using Bitcoin scripts which essentially implement F∗
CR.

CR-hybrid model.

407Other notable works which are not in the F∗
CR model include the
works of [2, 1, 20, 19, 21]. The works of [20, 19] use a more power-
ful transaction functionality which implements a ledger/blockchain
to implement “smart contracts” and fair secure computation (un-
der the penalties notion). Hawk [20] also provides ﬁnancial pri-
vacy which our protocols do not provide. Ethereum supports pro-
grammable transactions and smart contracts from scratch. We wish
to emphasize that protocols constructed in the F∗
CR-hybrid model
can be easily cast into protocols in any of the above models. Also,
we make an explicit distinction between the off-chain costs and
the on-chain costs which is not always captured in other works.
For instance, in Ethereum, the entire smart contract (or the func-
tion) is put on the blockchain, and in a naïve construction, every
miner is involved in the computation of the function as well as the
state changes associated with executing the contract. These are ex-
actly the type of burdens on the miners that we are trying to relieve
via use of (possibly expensive) off-chain mechanisms (e.g., secure
computation).

2. PRELIMINARIES
A function µ(·) is negligible in λ if for every positive polynomial
p(·) and all sufﬁciently large λ’s it holds that µ(λ) < 1/p(λ). A
probability ensemble X = {X(a, λ)}a∈{0,1}∗,n∈N is an inﬁnite
sequence of random variables indexed by a and λ ∈ N. Two dis-
tribution ensembles X = {X(a, λ)}λ∈N and Y = {Y (a, λ)}λ∈N
c≡ Y
are said to be computationally indistinguishable, denoted X
if for every non-uniform polynomial-time algorithm D there exists
a negligible function µ(·) such that for every a ∈ {0, 1}∗,

|Pr[D(X(a, λ)) = 1] − Pr[D(Y (a, λ)) = 1]| ≤ µ(λ).

All parties are assumed to run in time polynomial in the security
parameter λ. We prove security in the “secure computation with
coins” (SCC) model proposed in [9]. Note that the main difference
from standard deﬁnitions of secure computation [14] is that (1) the
model treats coins as atomic entities that are fungible and cannot
be duplicated, (2) the adversary cannot produce/destroy coins; only
the environment Z has such powers, and (3) the view of Z contains
the distribution of coins.3 Let IDEALf,S,Z (λ, z) denote the output
of environment Z initialized with input z after interacting in the
ideal process with ideal process adversary S and ideal functional-
ity Gf on security parameter λ. Recall that our protocols will be
run in a hybrid model where parties will have access to a (stan-
dard or special) ideal functionality Gg. We denote the output of
Z after interacting in an execution of π in such a model with A by
π,A,Z (λ, z), where z denotes Z’s input. We are now ready
HYBRIDg
to deﬁne what it means for a protocol to SCC realize a functionality.

DEFINITION 1. Let n ∈ N.

Let π be a probabilistic
polynomial-time n-party protocol and let Gf be a probabilistic
polynomial-time n-party ideal functionality. We say that π SCC
realizes Gf with abort in the Gg-hybrid model (where Gg is a
standard or a special ideal functionality) if for every non-uniform
probabilistic polynomial-time adversary A attacking π there ex-
ists a non-uniform probabilistic polynomial-time adversary S for
the ideal model such that for every non-uniform probabilistic

3Note that typically in the simulation, coins are being exchanged
between the ideal functionality, the simulator, and the adversary
that the simulator is simulating. By (1) and (2) above, it follows
that the simulator cannot send coins to the ideal functionality that
it had already sent to the adversary (and vice versa).

• Output phase:

F (cid:63)
f with session identiﬁer sid, security parameter 1λ, penalty amount
q, running with parties P1, . . . , Pn, and adversary S that corrupts
parties {Ps}s∈C proceeds as follows: Let H = [n]\ C, and h = |H|.
Let d be a parameter representing the safety deposit.
• Input phase: Wait to receive a message (input, sid, ssid, r, yr,
coins(d)) from Pr for all r ∈ H. Then wait to receive a message
(input, sid, ssid, {ys}s∈C , coins(hq)) from S.
– Send (return, sid, ssid, coins(d)) to Pr for all r ∈ H.
– Compute (z1, . . . , zn) ← f (y1, . . . , yn).
– Send message (output, sid, ssid, {zs}s∈C ) to S.
– If S returns

send
(output, sid, ssid, zr) to Pr for all r ∈ H, and send
(payback, sid, ssid, coins((h − |Hout|)q)) to S, and send
(extrapay, sid, ssid, coins(q)) to Pr for each r ∈ Hout.
– Else if S returns (abort, sid, ssid), send (penalty, sid, ssid,
coins(q)) to Pr for all r ∈ H.

(continue, sid, ssid, Hout),

then

Figure 1: Secure (non-reactive) computation with penalties F (cid:63)
f .

polynomial-time adversary Z,

{IDEALf,S,Z (λ, z)}λ∈N,z∈{0,1}∗ c≡

{HYBRIDg

π,A,Z (λ, z)}λ∈N,z∈{0,1}∗ .

♦

f according to Deﬁnition 1.

DEFINITION 2. Let π be a protocol and f be a multiparty func-
tion. We say that π securely computes f with penalties if π SCC-
realizes the functionality F (cid:63)
Throughout this paper, we deal only with static adversaries. Also,
unless otherwise stated, we deal with the case where a majority of
parties are dishonest.
2.1 Ideal Functionalities
Secure computation with penalties—non-reactive case. Loosely
speaking, our notion of fair secure computation guarantees:

An honest party never has to pay any penalty.
If a party aborts after learning the output and does not deliver
output to honest parties, then every honest party is compen-
sated.

f

Ideal functionality F (cid:63)
f for the non-reactive case [9, 22, 21, 1].
See Figure 1 for a formal description. In the ﬁrst phase, the func-
f receives inputs for f from all parties. In addition, F (cid:63)
tionality F (cid:63)
allows the ideal world adverary S to deposit some coins which may
be used to compensate honest parties if S aborts after receiving the
outputs. Note that an honest party makes a ﬁxed deposit coins(d)
in the input phase. Then, in the output phase, F (cid:63)
f returns the de-
posit made by honest parties back to them. If insufﬁcient number
of coins are deposited, then S does not obtain the output, yet may
potentially pay penalty to some subset of the honest parties. If S
deposited sufﬁcient number of coins, then it gets a chance to look at
the output and then decide to continue delivering output to all par-
ties, or just abort, in which case all honest parties are compensated
using the penalty deposited by S.
Secure computation with penalties—reactive case. Loosely
speaking, our notion of fair reactive secure computation guaran-
tees:

An honest party never has to pay any penalty.
If a party aborts after the computation has started (even though
it may not learn outputs of all stages of the reactive computa-
tion) and does not deliver output to honest parties, then every
honest party is compensated.

408F (cid:63)
f with session identiﬁer sid, security parameter 1λ, penalty amount
q, running with parties P1, . . . , Pn, and adversary S that corrupts
parties {Ps}s∈C proceeds as follows: Let H = [n] \ C, and h =
|H|. Let d be a parameter representing the safety deposit. Initialize
state0 := NULL and ﬂag := 1. Note that f = (f1, . . . , fρ) is a
reactive function composed of ρ stages.
• Deposit phase: Wait to receive a message (deposit, sid, ssid,
r, coins(d) from Pr for all r ∈ H.
to receive
(deposit, sid, ssid, coins(hq)) from S.

Then wait

• Computation phase: For each (cid:96) = 1, . . . , ρ, do:

(x(cid:96),1, . . . , x(cid:96),n).

– Wait to receive a message (input, sid, ssid, r, x(cid:96),r) from Pr for
all r ∈ H.
– If S sends (abort, sid, ssid, {coins(qr)}r∈H ), send (penalty,
sid, ssid, coins(q + qr)) to Pr for all r ∈ H, set ﬂag := 0,
and terminate phase.
– Else if S sends (input, sid, ssid, {x(cid:96),s}s∈C ), set x(cid:96) =
– Compute (z(cid:96), state(cid:96)) ← f(cid:96)(x(cid:96); state(cid:96)−1), and parse z(cid:96) to ob-
– Send (output, sid, ssid, {zs,(cid:96)}s∈C ) to S.
– If S returns (continue, sid, ssid),
then send (output, sid,
ssid, z(cid:96),r) to Pr for all r ∈ H.
– Else if S sends (abort, sid, ssid, {coins(qr)}r∈H ), send
(penalty, sid, ssid, coins(q + qr)) to Pr for all r ∈ H, set
ﬂag = 0, and terminate phase.

tain (z(cid:96),1, . . . , z(cid:96),n).

Figure 2: Secure (reactive) computation with penalties F∗
f .

Ideal functionality F (cid:63)
f for the reactive case [9, 22, 21, 1]. It is
very similar to the description in Figure 1 except the simulator is
required to produce coins(hq) up front in a deposit stage. Also,
now the computation proceeds in stages, with each stage delivering
output, and aborts after every stage are penalized. See Figure 2 for
a formal description. Note that f = (f1, . . . , fρ) is a reactive func-
tion composed of ρ stages. The variable statei captures the state
of the reactive computation and the variable ﬂag indicates whether
there has been an abort.
Ideal functionality F (cid:63)
CR [9, 6, 26]. This special ideal functionality
has found tremendous application in the design of multiparty fair
secure computation and lottery protocols [9]. We elaborate more on
the deﬁnition of the ideal functionality F∗
CR below. See Figure 3
for a formal description. At a high level, F (cid:63)
CR allows a sender Ps
to conditionally send coins(x) to a receiver Pr. The condition is
formalized as the revelation of a satisfying assignment (i.e., wit-
ness) for a sender-speciﬁed circuit φs,r( · ; z) (i.e., relation) that
may depend on some public input z. Further, there is a “time”
bound, formalized as a round number τ, within which Pr has to
act in order to claim the coins. Note that the satisfying witness is
made public by F (cid:63)
CR. Bitcoin, or alternatively a cryptocurrency
that supports time-locks and scripts, can be used to realize F∗
CR [9,
6, 26]. In the Bitcoin realization of F∗
CR, sending a message with
coins(x) corresponds to broadcasting a transaction to the Bitcoin
network, and waiting according to some time parameter until there
is enough conﬁdence that the transaction will not be reversed. We
denote an F (cid:63)
CR transaction where sender Ps asks receiver Pr for
a witness for a predicate φ in exchange for coins(q) with deadline
round τ by:

Ps

−−−−−−−−−−−−−→

φ

q,τ

Pr

F (cid:63)
CR with session identiﬁer sid, running with parties Ps and
Pr, a parameter 1λ, and adversary S proceeds as follows:
• Deposit phase. Upon receiving the tuple (deposit, sid,
ssid, s, r, φs,r, τ, coins(x)) from Ps, record the message
(deposit, sid, ssid, s, r, φs,r, τ, x) and send it to all par-
ties. Ignore any future deposit messages with the same ssid
from Ps to Pr.
• Claim phase.

In round τ, upon receiving (claim, sid,
ssid, s, r, φs,r, τ, x, w) from Pr, check if (1) a tuple
(deposit, sid, ssid, s, r, φs,r, τ, x) was recorded, and (2) if
φs,r(w) = 1. If both checks pass, send (claim, sid, ssid,
s, r, φs,r, τ, x, w) to all parties, send (claim, sid, ssid, s,
r, φs,r, τ, coins(x)) to Pr, and delete the record (deposit,
sid, ssid, s, r, φs,r, τ, x).

• Refund phase: In round τ + 1, if the record (deposit, sid,
ssid, s, r, φs,r, τ, x) was not deleted, then send (refund,
sid, ssid, s, r, φs,r, τ, coins(x)) to Ps, and delete the
record (deposit, sid, ssid, s, r, φs,r, τ, x).

Figure 3: The special ideal functionality F (cid:63)

CR.

We formally deﬁne script complexity of a protocol consisting of

a sequence of F∗

CR deposits.

DEFINITION 3

(SCRIPT COMPLEXITY [21]). Let Π be a
protocol among n parties P1, . . . , Pn in the F∗
CR-hybrid model.
For circuit φ, let |φ| denote its circuit complexity. For a given ex-
ecution of Π starting from a particular initialization Ω of parties’
inputs and random tapes and distribution of coins, let VΠ,Ω denote
the sum of all |φ| such that some honest party claimed an F∗
CR
transaction by producing a witness for φ during an execution of Π.
Then the script complexity of Π, denoted VΠ, equals maxΩ (VΠ,Ω).
♦

Note: Often while denoting the script complexity of a scheme, we
ignore poly(λ) factors and focus on the dependence on the number
of parties n, the function f, and the round complexity r of an arbi-
trary n-party protocol. This is purely for the sake of clarity and to
better present our improvements. Also, we extensively use the ran-
dom oracle model. We chose to do this (even when standard model
alternatives exist in some cases) for the sake of clarity, consistency,
and to better present our main ideas. Throughout this paper, we
denote the random oracles as Hash and Hash(cid:48). The latter is a pro-
grammable random oracle while the former is non-programmable.
If security under standard assumptions is desired, then Hash can be
replaced by an honest-binding commitment [13, 9, 22]. However,
this substitution might affect some of our theorems (notably, the
one related to compact ladder). Also, we focus on the SCC model
and while our protocols do not require rewinding in the proofs wrt
coins or cryptographic primitivies, there are subtle issues while try-
ing to guarantee universal composability in the programmable ran-
dom oracle model. See [10] for more extensive discussion.
Remark on cash distribution. The works of [2, 1, 22] gave pro-
tocols for secure cash distribution with penalties (SCD) in the two-
party and multiparty settings. Although we do not discuss this in
the paper due to space limitations, we note that the mechanism to
add cash distribution to our reactive protocols is straightforward
and thus, our protocols can be directly upgraded (using a generic
compiler) to handle secure cash distribution with penalties. Since
SCD models stateful reactive functionalities it provides a way to
securely implement smart contracts (as discussed in [22, 20]) in a

409Roof deposits. For each j ∈ [n − 1] simultaneously:

−−−−−−−−−−−−−−−−→

φn

Pj

Pn

(Txn,j)

q,τn

Ladder deposits. For i = n − 1 down to 1 (one-by-one):

Pi+1

−−−−−−−−−−−−−−−−→

φi
i·q,τi

Pi

(Txi)

The ladder mechanism is parameterized by a protocol Init,
predicates φ1, . . . , φn, and procedures Extend and Recon.
Initialization. Parties P1, . . . , Pn run Init with their respec-
tive inputs x1, . . . , xn to obtain respective outputs y1, . . . , yn.
If there is an abort in this step such that some parties did not
obtain their outputs, then all parties terminate and output ⊥.
Roof deposits. For each j ∈ [n − 1] simultaneously:

Figure 4: Deposits in the ladder mechanism [9].

Pj

decentralized setting, and consequently captures a wide variety of
applications such as games, auctions, markets, etc.
Remark. We give the strongest possible theorem statements cor-
responding to our results. That is, we may present constructions
in the random oracle model (for the sake of clarity and to avoid
cumbersome notation) even when there a construction that is based
on one-way functions. However our theorems will be stated as
assuming the existence of one-way functions if that’s indeed the
case. Also, we present the planted ladder mechanism as one that
takes an r-round protocol as a parameter and discuss efﬁciency in
the text as a function of r. Since in order to implement reactive
MPC with penalties it sufﬁces to use a constant-round protocol,
i.e., r = O(1), our theorem statement ignores r when describing
the efﬁciency. Likewise, sometimes we state our theorems as oper-
ating in the FOT-hybrid model (i.e., with ideal oblivious transfer).
Recall that OT implies MPC unconditionally.

3. THE LADDER MECHANISM

Since our efﬁciency improvements come from modifying the
ladder mechanism of [9], we brieﬂy describe this mechanism. Fig-
ure 5 contains a description of the ladder mechanism. Each party
Pi enters the ladder mechanism holding some private input yi. For
the ladder mechanism to be useful to construct a protocol for se-
cure computation with penalties, the predicates {φi}i∈[n] (which
are parameters to the ladder mechanism) need to satisfy the follow-
ing two informal properties:

• Extensibility.

It is possible to satisfy φi+1 (and claim

Txi+1) using yi+1 and a witness that satisﬁes φi.

• Unforgeability.

It is computationally infeasible to satisfy
φi+1 given only {yj}j(cid:54)=i and witnesses to {φj}j<i (in par-
ticular without a witness to φi).

We now proceed to describe the ladder mechanism. The mech-
anism is a sequence of F∗
CR deposits split into two phases. In the
ﬁrst phase, known as the roof deposits, all parties except Pn make
an F∗
CR deposit to Pn for an amount of coins(q) and with predi-
cate φn. If all roof deposits are made, then parties enter the second
phase, known as the ladder deposits. Here ﬁrst Pn makes an F∗
deposit to Pn−1 for an amount of coins((n − 1)q) and with predi-
CR
cate φn−1. Likewise, Pn−1 makes an F∗
CR deposit to Pn−2 for an
amount of coins((n − 2)q) and with predicate φn−2. This contin-
ues all the way down to P2 who makes an F∗
CR deposit to P1 for an
amount of coins(q) and with predicate φ1. The sequence of F∗
CR
deposits in the ladder mechanism are claimed in reverse. First, P1
claims Tx1. Then P2 claims Tx2, and so on until ﬁnally Pn claims
all Txn,j for j (cid:54)= n. This sequence of claims is enabled by the
extensibility property described above. Next, we brieﬂy describe
how aborts are typically handled in the ladder mechanism. If some
party aborts during the roof deposit phase, then parties terminate
immediately (and wait for F∗
CR deposits to be refunded—this is

−−−−−−−−−−−−−−−−→

φn

Pn

(Txn,j)

q,τn

Handling aborts. If a party Pj does not make an F∗
CR deposit
to Pn as above, then each party Pi terminates the protocol and
wait to collect refund from Txn,i (for i (cid:54)= n).
Ladder deposits. For i = n − 1 down to 1 (one-by-one):

−−−−−−−−−−−−−−−−→

Pi+1

φi
i·q,τi

Pi

(Txi)

Handling aborts. If a party Pi+1 does not make an F∗
CR de-
posit to Pi as above, then (1) each party Pj for j ≤ i does
not make its ladder deposit (i.e., Txj−1) and waits to collect
refund from Txn,j (for j (cid:54)= n), and (2) each party Pj for j > i
continues on to the ladder claim phase.
Claims. P1 claims Tx1 using witness α1 = Extend(1,⊥; y1).
For i = 1 to n − 1 (one-by-one), at time τi:

• If Pi claimed Txi, then let αi be the witness satisfying
φi. Pi+1 computes αi+1 ← Extend(i + 1, αi; yi+1).
If i + 1 (cid:54)= n, then Pi+1 claims Txi+1 using witness
αi+1. If i + 1 = n, then Pn claims Txn,j for all j using
witness αn.

• If Pi did not claim Txi, then Pi+1 terminates the proto-
col and waits to collect refund from Txn,i+1 if i + 1 (cid:54)=
n.

Output.
If Txn,j was claimed by Pn for some j, then let
αn be the witness satisfying φn. Each party Pi outputs zi =
Recon(αn; yi) and terminates the protocol. If no Txn,j was
claimed, then each party outputs ⊥.
Figure 5: Protocol framework for the ladder mechanism.

guaranteed by the unforgeability property above), and in particular
do not make any ladder deposits. If some party Pi+1 did not make
its F∗
CR deposit to Pi in the ladder deposit phase, then (1) each Pj
for j ≤ i does not make its ladder deposit, and (2) each Pj (for
j (cid:54)= n) claims Txj iff Pj−1 claimed Txj−1, and (3) Pn claims
Txn,j for all j (cid:54)= n iff Pn−1 claimed Txn−1. We formally present
the framework for the ladder mechanism that we described above
in Figure 5. This framework takes as parameters a protocol Init, a
set of predicates {φi}i∈[rn], and procedures Extend and Recon.
Usefulness for secure computation with penalties. Given the
above, we brieﬂy provide some intuition on why the ladder mecha-
nism is useful for secure computation with penalties. Let i+1 < n.
First, note that Txn,i+1 locks up coins(q) belonging to Pi+1. Now,
if Txi is claimed, then Pi+1 would have lost coins(i · q) to Pi.
However, by the extensibility property, Pi+1 will be able to claim
Txi+1 and obtain coins((i+1)·q) from Pi+2. Claiming Txi+1 will
release the witness for the predicate φi+1 to all other parties. The
main assertion is thus the following: when a party Pi+1 releases
a witness for the predicate φi+1, then at this point it has neither
gained nor lost coins. Now suppose, Pn (either corrupt or honest)

410Protocol Init. Parties P1, . . . , Pn with their MPC inputs
x1, . . . , xn run an MPC protocol that
• computes z ← f (x1, . . . , xn);
• n-out-of-n secret shares z into z1, . . . , zn;
• samples ω1, . . . , ωn at random from {0, 1}λ;
• for j ∈ [n]: computes hj = Hash(zj(cid:107)ωj);
• for i ∈ [n]: outputs yi = zi(cid:107)ωi and {hj}j∈[n] to party

Pi.

Predicates. Note that the predicates have {hj}j∈[n] hard-
coded in them. Deﬁne φi as follows:

φi (β1(cid:107)···(cid:107)βi;{hj}j≤i) =
(Hash(β1) ?= h1)

(cid:94)···(cid:94)

(Hash(βi) ?= hi)
Procedure Extend(i + 1, αi; yi+1): Output αi+1 = αi(cid:107)yi+1.
Procedure Recon(αn; yi): Parse αn as β1(cid:107)···(cid:107)βn. Parse
each βi as z(cid:48)

i. Output(cid:76)

i(cid:107)ω(cid:48)

j∈[n]z(cid:48)
j.

Figure 6: Parameters to the ladder mechanism from [9].

does not reveal a witness to φn, then all the roof deposits Txn,j get
refunded. Thus, the following is true: If

1. Pi+1 released a witness for the predicate φi+1, and

2. Pn did not release a witness for the predicate φn by time τn,

then party Pi+1 would ultimately stand to gain coins(q) at the end
of the protocol.
Bentov-Kumaresan parameters for the ladder mechanism to
get MPC with penalties for a non-reactive function f. Refer
to Figure 6 for a description of the parameters for the ladder mech-
anism used in [9]. The protocol Init is an MPC among the parties
that computes the function output and secret shares among the par-
ties. Then it commits to the shares using additional randomness.
(In the ﬁgure, we used a hash function Hash modeled as a random
oracle. It can safely be replaced by honest-binding commitments
as in [9].) The parties get commitments to all shares and the de-
commitment corresponding to their index. The predicates φii∈[n]
are deﬁned in the following way: φi has {hj}j≤i hard-coded in
it, and requires the hash preimages of these values. Extensibility
is readily guaranteed (as shown in Figure 6), and unforgeability is
guaranteed via the random oracle (alternatively, binding property
of the commitment). Finally, the procedure Recon takes the wit-
ness to φn, i.e., all the shares, and XORs them to obtain the ﬁnal
output. This completes the description of the parameters for the
ladder mechanism of [9] that yields MPC with penalties for a non-
reactive function f. It is easy to see that the script complexity of
the above protocol grows quadratic in n.

4. COMPACT LADDER

In this section, we improve the efﬁciency of secure computation
with penalties in the non-reactive setting. Recall that the ladder
protocol of [9] required script complexity Ω(n2|z|) where |z| is
the size of the output of the non-reactive function. We are going to
improve this to O(nλ), and in particular make it completely inde-
pendent of the function.

Protocol Init. Parties P1, . . . , Pn with their MPC inputs
x1, . . . , xn run an MPC protocol that

• samples random k1, . . . , kn from {0, 1}λ;
• for j ∈ [n]: computes hj = Hash(k1⊕···⊕kj);
• computes e ← f (x1, . . . , xn)⊕Hash(cid:48)(k1⊕···⊕kn);
• for i ∈ [n]: outputs yi = ki, {hj}j∈[n], and e to party

Pi.

Predicates. Note that the predicate φi has hi hard-coded in it.
Deﬁne φi as follows:

φi (αi; hi) = (Hash(αi) ?= hi)

Procedure Extend(i+1, αi; yi+1): Output αi+1 = αi⊕yi+1.
Procedure Recon(αn; yi): Output e⊕Hash(cid:48)(αn).

Figure 7: Compact ladder parameters.

First ideas—using hybrid encryption. A standard technique (also
appearing in [16]) is to use an MPC to encrypt the actual output of
the computation and then to secret share the keys among parties
and allow to reconstruct the encryption key in a fair manner (in our
case with the ladder mechanism). This has the immediate impact
of reducing the script complexity to O(n2λ). In particular, the i-th
predicate φi will have size O(iλ) (ignoring poly(λ) factors). One
caveat is that for our strong security notion, we will need to use
a programmable random oracle in order to achieve equivocation
properties in the simulation proof.4 (In contrast, [16] only consid-
ered standalone security and could do away with semantic security
of the encryption scheme.)
Compact ladder. To further reduce the script complexity to
O(nλ), we have a simple tweak to the parameters of the ladder
mechanism. The main idea to have the size of the i-th predicate φi
be O(λ). To to do this, we run an MPC protocol in Init that gen-
erates secret shares k1, . . . , kn of a key k that is used to encrypt
the output of the computation. The MPC protocol also generates
hash images of the following form: hj = Hash(k1⊕···⊕kj). We
then deﬁne the predicates as φi(αi; hi) = (Hash(αi) ?= hi). That
is, the predicate φ has the value hi hard-coded in it and only takes
a λ-bit input. This is the main idea. A formal description of the
parameters appears in Figure 7.

is O(nλ).

Clearly, the script complexity of the resulting protocol, i.e.,
the sum of the sizes of all predicates,
It remains
to be shown that the predicates satisfy the extensibility as well
as the unforgeability property. Extensibility follows from the
fact that given a witness αi to the predicate φi and the secret
value ki+1, the witness to the predicate φi+1 can be obtained as
αi⊕ki+1. Unforgeabiility follows from the use of the random ora-
cle. More concretely, given the values k1, . . . , ki−1, ki+1, . . . , kn
and the hash values Hash(k1), . . . , Hash(k1⊕···⊕kn),
is
computationally infeasible to ﬁnd a hash preimage of any of
Hash(k1⊕···⊕ki), . . . , Hash(k1⊕···⊕kn) or even distinguish
them from random. In the formal simulation proof we also need to
argue about the timing of various events (e.g., interaction with the
ideal functionality, the adversary, etc.), distribution of coins, and

it

4Alternatives in the standard model include use of non-committing
encryption but here we would not be able to get the desirable efﬁ-
ciency [27].

411equivocation of the ﬁnal output. We state our theorem and provide
a proof sketch below and defer the full proof to the full version.

THEOREM 1. Assuming the existence of a programmable ran-
CR)-hybrid
f for any non-reactive function f. Fur-
CR and has

dom oracle, there exists a protocol in the (FOT,F∗
model that SCC-realizes F∗
thermore, the protocol makes only O(n) calls to F∗
script complexity O(nλ).
Proof sketch. The simulator S invokes the simulator of the MPC
protocol in the initialization phase and generates a random string e
as the encryption, random k1, . . . , kn and distributes hash images
on these values to the adversary A and also gives the value ki to
each corrupt Pi. S also extracts inputs of the corrupt parties in the
previous step. However, it does not directly send these inputs to the
ideal functionality F∗
f since it may also needs to extract and submit
coins(hq) to the ideal functionality (especially in the case when
Pn is corrupt). Acting as F∗
CR, S simulates the deposit phases of
the protocol. Note that some of the deposits might not be made by
A. S emulates the honest parties to A exactly as described in the
protocol (including how they react to deposits that were not made).
When the claim phase starts and it’s the turn of an honest party Pj
to claim Txj, S will use the value k1⊕···⊕kj. It also receives
corrupt parties’ claim witnesses via A. Additionally, during the
claim phase, S will need to produce coins whenever A claims them.
Suppose Pi is corrupt and it produces a valid witness α to claim
Txi. (For the time being, assume i (cid:54)= n; we’ll take care of this case
later.) To simulate this, S needs to produce coins(i · q).
Ideally, we would ask S to get these coins via Txi−1, i.e.,
coins((i − 1)q) and coins(q) from Pi’s roof deposit Txn,i. How-
ever, it is not clear that Txi−1 was even made by Pi. Importantly,
we are able to make the following claim: if Txi−1 was not made
by Pi but Pi can produce valid witnesses to claim Txi, then for
every j < i, party Pj is corrupt. To prove the claim, we appeal to
the unforgeability property of the predicates in the following way.
Note that according to the protocol description, if Txi−1 was not
made, then for j < i an honest party Pj would not make Txj−1.
Since it never made a deposit Txj−1, this in turn means that it
would never reveal a valid witness for Txj (note: honest Pj claims
Txj iff Txj−1 is claimed). Then it follows from the unforgeability
property that without a valid witness for Txj it is computationally
infeasible to provide a valid witness to Txi. Now we are ready
to describe the simulation of the claims Tx1, . . . , Txi (whichever
were made). For transactions Txj with j < i that were claimed,
we simply use corrupt Pj+1’s deposit of coins(jq) to give to cor-
rupt Pj who’s claiming it. For transaction Txi, we use coins(q)
from the roof deposit of each of P1, . . . , Pi. Recall Pi+1 is honest,
and if Pi+1 made deposit Txi it must necessarily hold that all par-
ties (in particular, P1, . . . , Pi) made roof deposits of coins(q) each.
The above strategy takes care of parties that try to claim a deposit
Txi without make the deposit Txi−1. In the rest of the proof, we
assume that every Pi that tries to claim deposit Txi has made the
deposit Txi−1. This case is handled easily: we ask S to get these
coins via Txi−1, i.e., coins((i − 1)q) and coins(q) from Pi’s roof
deposit Txn,i (out of a total of coins(q)). The above strategy works
only for i (cid:54)= n. We ﬁrst complete the discussion assuming Pn is
honest and then discuss the other case later. Suppose Pn is honest.
We have already addressed how to handle coins during the claims.
The only remaining thing to address is when to ask S to contact
F∗
f . Let ic be the largest index such that Pic is corrupt. S will
contact the ideal functionality when Txic is claimed by Pic since it
is clear that A will no longer abort the protocol. S would then get
the actual output z from the ideal functionality, and program Hash(cid:48)
to return z⊕e (where e is the random string S distributed to the

parties initially). Note that this is indistinguishable from the real
execution as long as A did not query on the string k1⊕···⊕kn—
an event that happens with negligible probability. This completes
the simulation when Pn is honest.

When Pn is corrupt, we need to show how to handle claims made
by Pn and also how to handle the interaction with the ideal func-
tionality. Actually, when Txn−1 is deposited by Pn, S will take
coins(hq) out of these coins((n − 1)q) (note: (n − 1) ≥ h) to
deposit to the ideal functionality along with the inputs to the com-
putation (extracted in the very ﬁrst step). S would then get the ac-
tual output from the ideal functionality. Let ih be the largest index
such that Pih is honest. S will actually do the above steps of giving
coins(hq) to F∗
f right before time τih so that it can obtain the ac-
tual output z and program Hash(cid:48) such that Hash(cid:48)(k1⊕···⊕kn) =
e⊕z. This ensures that remaining honest messages are such that the
view of the adversary is indistinguishable from the real execution.
Also, S would ask F∗
f to deliver the output to all honest parties
(because the corrupt parties did not abort the computation at all)
and would get coins(hq) back from the ideal functionality which it
can then use to handle Pn’s claim of Txn,j for all j since it now
has exactly coins((n − 1)q). This completes the simulation when
Pn is honest.

5. PLANTED LADDER MECHANISM

In this section, we improve the efﬁciency of secure computation
with penalties in the reactive setting.
In the reactive setting, we
have to deal with a multi-round protocol and guarantee its com-
pletion or guarantee compensation to all honest parties. Previous
work by Kumaresan et al. [22] showed the “see-saw protocol” for
the reactive setting which is essentially an adaptation of the lad-
der mechanism of [9] but that guarantees that all honest parties are
compensated no matter where the abort happens. However, to do
this, they required Ω(n2) F∗
CR transactions and a script complexity
of Ω(n2T ) where T is the size of the transcript of an n-party se-
cure computation protocol that implements the reactive function f
with security-with-abort. We are going to improve both the script
complexity to O(nT ) and the number of F∗
First ideas—tweaking the ladder mechanism. The main idea be-
hind the improvement is a simple set of tweaks to the ladder mecha-
nism that preserves the structure of the mechanism and yet sufﬁces
for the reactive setting. We ﬁrst provide a rough sketch of the idea,
then discuss the problem with the approach, and then proceed to
give the ﬁx.

CR calls to O(n).

Note that since we have to handle multi-round protocols we let
parties take turns to send messages until the entire protocol is com-
pleted. More concretely, suppose we have an r-round protocol π,
then we essentially have r copies of the original ladder mechanism
of [9]. The k-th such copy (from the bottom) corresponds to the
k-th round messages (there are n of them, one from each party) of
π. It is important to note that in the k-th copy of the ladder mecha-
nism, party Pi+1 makes a deposit of coins((n(k− 1) + i)q). (Note
how when k = 1, this is the same as the ladder mechanism in [9].)
That is, the amount deposited keeps growing across the r copies of
the ladder eventually ending in the last deposit of coins((nr−1)q).
The best way to understand the planted ladder mechanism is
to view the whole deposit sequence as a single ladder mechanism
i ≡ Pi mod n. The
among rn virtual parties P (cid:48)
main observation is that the ladder mechanism already guarantees
compensation to parties who have made their move (i.e., revealed
their share or the next message of the protocol) in case the protocol
is aborted. Thus, if the protocol is aborted after the ﬁrst copy of the
ladder deposits have been claimed (i.e., the ﬁrst round of the pro-

rn, where P (cid:48)

1, . . . , P (cid:48)

412Roof deposits. For each j ∈ [n − 1] simultaneously:

Pj

−−−−−−−−−−−−−−−−−−−−→

n

φrn∧φ(cid:48)

(r+1)·q,τ(r+1)n

Pn

(Txn,j)

Ladder deposits. For i = rn − 1 down to 1 (one-by-one):

Pi+1 mod n

−−−−−−−−−−−−−−−−−→

n

φi∧φ(cid:48)

(n+i)·q,τn+i

Pi mod n (Txn+i)

Underground deposits. For i = n down to 1 (one-by-one):

Pi+1 mod n

−−−−−−−−−−−−−−−−→

i

φ(cid:48)
i·q,τi

Pi

(Txi)

Figure 8: Deposits in the planted ladder mechanism.

tocol has been completed), it follows that each honest party would
be compensated!
In fact, by the time the k-th copy of the lad-
der deposits are claimed, each honest party would have coins(kq)
as compensation in the case the protocol is aborted in this phase.
(Note that each party Pj for j (cid:54)= n would have deposited coins(rq)
as the roof deposit. That is, if the protocol is completed, then no
party gains or loses money.)

The problem with the idea above is that aborts within the ﬁrst
copy of the ladder mechanism will not guarantee compensation to
all honest parties (i.e., not all parties would have gotten coins(q) as
compensation).
Dummy witnesses and underground deposits. To ﬁx this prob-
lem, we use a simple idea: have the ﬁrst copy of the ladder mech-
anism reveal dummy witnesses which are independent of the actual
computation. That is, now there are (r + 1) copies of the ladder
mechanism: the ﬁrst copy is a special set of transactions that we
call “underground” deposits, while the remaining r of them corre-
spond to the actual r-round protocol. The deposits are shown in
Figure 8.

The underground deposits essentially serve to bootstrap the com-
putation. Aborts during the underground claim phase may not com-
pensate all honest parties, but this is not a problem since the mes-
sages corresponding to the actual protocol have not been sent by
anyone. This amounts to aborting the protocol even before it started
and is still a fair protocol since neither the honest parties nor the
adversary obtain any information about the actual protocol. Addi-
tional ideas ensure that the underground deposits will be claimed
before any of the deposits in the r copies of the ladder are claimed.
This ensures that aborts in any of the r copies will result in each
honest party being compensated by the adversary.
A framework for the planted ladder mechanism. We present a
simple framework for the planted ladder mechanism in Figure 9.
Just like the framework for the ladder protocol, this framework
takes as parameters a protocol Init, a set of predicates {φi}i∈[rn],
and procedures Extend and Recon. As before we will crucially rely
on the extensibility and unforgeabilty property of the predicates
{φi}i∈[rn] (and also of the underground predicates {φ(cid:48)
i}i∈[n]). In
the initialization phase, parties run an MPC protocol that sets up
the dummy witnesses k1, . . . , kn and computes the Hash on XORs
of the preﬁxes of the sequence of dummy witnesses. This part
is similar to our compact ladder mechanism. (Again, one can re-
place Hash with an honest-binding commitment as in [22].) Each
party Pi receives the value ki and the images of k1, . . . , kn un-
der Hash. In addition parties run Init which is a parameter of the
planted ladder mechanism. The dummy witnesses deﬁne the un-

n as: φ(cid:48)

1, . . . , φ(cid:48)

n for j ∈ [rn]. The extra predicate φ(cid:48)

derground predicates φ(cid:48)
i (αi; hi) = (Hash(αi) ?= hi). Af-
ter this, parties enter the three deposit phases: Roof, Ladder, and
Underground.
We already mentioned that the predicates for the underground
deposits are φ(cid:48)
n. The predicates for the Roof and Ladder
deposits are φj ∧ φ(cid:48)
n is to
ensure that the underground deposits are claimed before any of the
ladder/roof deposits are claimed. Other than these, there are essen-
tially no differences between the ladder mechanism and the planted
ladder mechanism. One thing to note is that we sometimes interpret
Recon as a protocol (instead of a procedure). This will be relevant
to the dual mode protocol that we describe in the next section.
Intuition. The best way to understand the planted ladder mech-
anism is to view the whole deposit sequence as a single ladder
mechanism among (r +1)n virtual parties P (cid:48)
(r+1)n, where
i ≡ Pi mod n.
P (cid:48)
PROPOSITION 2. Honest parties do not lose money.

1, . . . , P (cid:48)

Proof sketch. This actually follows from the extensibility property
of the predicates {φ(cid:48)
i} and {φi}. More concretely, every time an
honest party’s ladder/underground deposit, say Txj is claimed, the
honest party Pj+1 mod n will always be able to claim Txj+1. Since
claiming Txj+1 gives coins((j + 1)q) to Pj+1 mod n and since
it would have lost only coins(jq) when Pj mod n claimed Txj, it
follows that Pj+1 mod n never loses money during the ladder claim
phase i.e., before time τ(r+1)n−1.

Now suppose there is some Txj+1 which Pj+1 mod n is unable
to claim. Then by the unforgeability property of the predicates
it holds that transactions Txk for k > j + 1 cannot be claimed
by Pk mod n.
In particular, the roof deposit Txn,j+1 cannot be
claimed. On the other hand, if Pj+1 mod n was able to claim
all deposits made to it, then it follows that it would have gained
coins((r + 1)q) during the course of the claims (i.e., coins(q) for
each of the r + 1 stages). This is also the maximum amount that
it can lose during the roof claim by Pn. This therefore means that
honest parties will never lose money.

PROPOSITION 3. Suppose for some i, party Pi mod n is honest
and revealed a witness to the predicate φi during the execution
of the protocol. Then either the protocol is completed (i.e., Pn
reveals a witness to the predicate φrn) or all honest parties get
compensated.
Proof sketch. By the unforgeability property of {φ(cid:48)
i}i∈[n], it fol-
lows that an honest party Pi reveals a witness to φi only if each
honest party Pj revealed kj in the underground claim phase. This
is because for a party to claim the ladder deposit it needs to produce
a witness that satisﬁes φ(cid:48)
n which is possible only if each honest Pj
revealed kj. For the rest of the argument, we assume that all honest
parties revealed the underground dummy witnesses.
Now suppose there is an abort. Let Pi+1 mod n be an honest
party such that (1) all honest parties Pj with j mod n ≤ i mod n
could claim Txj for j < i, but (2) Pi+1 could not claim Txi+1.
From the above it follows that party Pi must be corrupt. Also by
the unforgeability property, we have that Txj for j > i cannot
be claimed by Pj mod n since honest Pi+1 mod n did not reveal its
witness αi+1. In particular, this means that the roof deposits will
be refunded back to all honest parties. Also all deposits Txj made
by honest Pj mod n such that j > i will also be refunded back to
Pj+1. Finally, recall that all honest parties were able to reveal their
dummy witnesses, therefore it must hold that i + 1 > n.

Now let us analyze how much money each honest party pos-
If Pj+1 mod n is honest and

sesses at the end of the protocol.

413The planted ladder mechanism is parameterized by a proto-
col Init, predicates {φi}i∈[rn], procedures Extend and Recon.
Note: In the following: Pi ≡ Pi mod n. Also: n mod n (cid:44) n.
Initialization. Parties P1, . . . , Pn run an MPC protocol that

• samples random k1, . . . , kn from {0, 1}λ;
• for j ∈ [n]: computes hj = Hash(k1⊕···⊕kj);
• for i ∈ [n]: outputs {hj}j∈[n] and ki to Pi.

In addition, parties P1, . . . , Pn run Init with their respective
inputs x1, . . . , xn to obtain respective outputs y1, . . . , yn. If
there is an abort (either in Init or the protocol above) and some
parties did not obtain their outputs, then all parties terminate
and output ⊥. The predicates φ(cid:48)
i have hi hard-coded in them:

(cid:48)
i (αi; hi) = (Hash(αi) ?= hi)

φ

Roof deposits. For each j ∈ [n − 1] simultaneously:

Pj

−−−−−−−−−−−−−−−−−−−−→

n

φrn∧φ(cid:48)

(r+1)·q,τ(r+1)n

Pn

(Txn,j)

Handling aborts. If Pj does not make deposit Txn,j, then each
Pi terminates the protocol and waits to collect refund.
Ladder deposits. For i = rn − 1 down to 1 (one-by-one):

Pi+1

−−−−−−−−−−−−−−−−−→

n

φi∧φ(cid:48)

(n+i)·q,τn+i

Pi

(Txn+i)

Handling aborts. If Pi+1 does not make deposit Txn+i, then
each Pj terminates the protocol and waits to collect refunds.
Underground deposits. For i = n to 1 (one-by-one):

Pi+1

−−−−−−−−−−−−−−−−→

i

φ(cid:48)
i·q,τi

Pi

(Txi)

Handling aborts. If Pi+1 does not make deposit Txi, then (1)
each Pj+1 for j < i does not make deposit Txj and waits to
collect refunds, while (2) each Pj+1 for j ≥ i continues on to
the claim phase.
Underground claims. P1 claims Tx1 using witness α(cid:48)
For i = 1 to n − 1 (one-by-one), at time τi:

1 = k1.

• If Pi claimed Txi, then let α(cid:48)

φ(cid:48)
i. Then Pi+1 claims Txi+1 using witness α(cid:48)

i be the witness satisfying
i⊕ki+1.
• If Pi did not claim Txi, then each Pj+1 terminates the

protocol and waits to collect refunds.

Ladder/roof claims. Let Xi = (xi, ωi, yi) where xi, yi re-
spectively are inputs, outputs of Pi from Init and ωi is Pi’s
private randomness. For i > n, let Xi ≡ Xi mod n. P1 claims
Txn+1 using witness α1 ← Extend(1,⊥, X1) at time τn+i:
• If Pi claimed Txi say using witness αi, then Pi+1 com-
putes αi+1 = Extend(i + 1, αi, Xi+1) If i + 1 (cid:54)= rn,
then Pi+1 claims Txi+1 using witness (αi+1, α(cid:48)
n), else
Pi+1 claims Txn,j for all j using witness (αrn, α(cid:48)
• If Pi did not claim Txi, then Pi+1 terminates the proto-

n).

col and waits to collect refunds.

Output. Parties run protocol Recon to generate output.
Figure 9: Framework for the planted ladder mechanism.

its ladder deposit Txj is claimed, then by the extensibility prop-
erty Pj+1 mod n can claim Txj+1. The amounts in the mecha-
nism are such that at time τj+1, Pj+1 would have an additional
coins((j + 1)q) − coins(jq) = coins(q) for every Txj it claimed,
i.e., an additional coins(q) for every completed round. Since (1)
at least one round was completed (note: i + 1 > n), and (2) all
deposits Txj for j > i were refunded, it follows from above that
each honest party gets at least coins(q) as compensation.

Parameterizing the planted ladder mechanism to get MPC with
penalties for a reactive function f. Let π(cid:48) be an n-party r-round
publicly veriﬁable MPC protocol realizing f with security-with-
abort. Let π(cid:48) be described by next message functions {nmf(cid:48)
j}j∈[rn]
and transcript validation functions {tv(cid:48)
j}j∈[rn]. We would want
to derive the parameters Extend, Recon and the predicates φii∈[n]
from the protocol π(cid:48). The predicates φii∈[n] could be deﬁned in
terms of the transcript validation functions. While extensibility
is readily guaranteed via the next message function, the unforge-
ability property is not always clear (especially with respect to ﬁrst
round messages). However, adding the unforgeability property to
π(cid:48) is possible via a simple transformation.
The idea is to ask parties to sign every message sent as part of
π(cid:48) under their public key. That is, the transcript TTj of the trans-
formed protocol consisting of the ﬁrst j messages would be of the
form (µ1(cid:107)σ1)(cid:107)···(cid:107)(µj(cid:107)σj), where for each i, the value µi is the
message that would have been sent in π(cid:48) and the value σi is a sig-
nature under party Pi mod n’s public key on the message µi. We
denote the transformed protocol as π. It is easy to see that Extend
can be deﬁned in terms of the next message function of π. Like-
wise, Recon may be deﬁned as the procedure by which parties gen-
erate the output in the protocol π. Also, we deﬁne Init as the pro-
tocol in which parties generate fresh public-key/signing-key pairs
and distribute them via a local broadcast channel (i.e., among the n
parties). See Figure 10 for a formal description of the parameters.
Note that we have abstracted away several features of f and fo-
cus on it as one single function for which we need to guarantee pro-
tocol termination. We already gave intuition as to why the planted
ladder mechanism ensures protocol completion as long as the predi-
cates {φi}i∈[n] satisfy both the extensibility and the unforgeability
properties. In the formal simulation proof we also need to argue
about the timing of various events (e.g., interaction with the ideal
functionality, the adversary, etc.), distribution of coins, and equivo-
cation of the ﬁnal output. We state our theorem and provide a proof
sketch below and defer the full proof to the full version.

THEOREM 4. Assume the existence of enhanced trapdoor per-
mutations. Let f be a reactive function that has a constant-round
protocol UC-realizing it with security-with-abort, the size of whose
transcript is T . Then there exists a protocol in the F∗
CR-hybrid
model that SCC-realizes F∗
f which requires only O(n) calls to
F∗
CR and whose script complexity is O(nT ).
Proof sketch. The simulator S acts as F∗
CR and also uses the
simulator Sπ of the constant-round protocol π (after undergoing
the transformation described above). S invokes the simulator of
the MPC protocol in the initialization phase and generates random
k1, . . . , kn and distributes commitments (or hash images) to the
adversary A and also gives the value ki to each corrupt Pi. S then
invokes the simulator of Init and distributes fresh public-keys be-
longing to honest parties and receives the public-keys of the corrupt
parties from A. Then acting as F∗
CR, S emulates the three deposit
phases of the protocol. Note that some of the deposits might not be
made by A. S emulates the honest parties to A exactly as described

414Protocol Init. Parties P1, . . . , Pn each locally run KeyGen of
a digital signature scheme (KeyGen, Sign, Verify) to generate
fresh veriﬁcation-key signing-key pairs. Let (vkj, skj) be the
key pair corresponding to Pj. Each Pj then broadcasts vkj
to all other parties. At the end, each Pj outputs the set of all
public keys {vki}i∈[n] and its private signing key skj.
The parameters Extend, Recon, and {φi}i∈[rn] are deﬁned via
the outputs of Init and a protocol π described below.
Protocol π. Let π(cid:48) be an n-party r-round publicly veri-
ﬁable MPC protocol realizing f (possibly a reactive func-
tion) with security-with-abort. Let π(cid:48) be described by next
message functions {nmf(cid:48)
j}j∈[rn] and transcript validation
functions {tv(cid:48)
:=
(xi, ωi, ({vkj}j∈[n], ski)) where xi, ωi respectively are pri-
vate inputs, randomness of Pi. For i > n, let X(cid:48)
and Xi ≡ Xi mod n. Let π, described by next message
functions {nmf j}j∈[rn] and transcript validation functions
{tvj}j∈[rn], be obtained from π(cid:48) in the following way:
1. nmf j(TTj−1, Xj) parses TTj−1 = (µ1(cid:107)σ1)(cid:107)···(cid:107)(µj−1(cid:107)
j), and

:= (xi, ωi) and Xi
i ≡ X(cid:48)

j(µ1(cid:107)···(cid:107)µj−1, X(cid:48)

σj−1) and computes µj ← nmf(cid:48)
outputs TTj−1(cid:107)µj(cid:107)Sign(µj, skj).

j}j∈[rn]. Let X(cid:48)

i

i mod n

2. tvj(TTj,{vki}i) parses TTj = (µ1(cid:107)σ1)(cid:107)···(cid:107)(µj(cid:107)σj),

j(µ1(cid:107)···(cid:107)µj) ∧(cid:86)

outputs tv(cid:48)

j(cid:48) Verify(vkj(cid:48) mod n, σj(cid:48) ).

Predicates. φi(α) ≡ tvi(α;{vkj}j).
Procedure Extend(i, α; Xi) ≡ nmf i(α, Xi).
Procedure Recon.
output the output of π(cid:48), else output ⊥.

If Txn,j was claimed for some j, then

Figure 10: Parameterizing the planted ladder mechanism to
get MPC with penalties for a reactive function f.

in the protocol (including how they react to deposits that were not
made).
When the claim phase starts and it’s the turn of an honest party
to send out a message in π, S invokes Sπ to generate this message.
It also receives corrupt parties’ messages in π (via A) and feeds
them to Sπ. S essentially uses Sπ to extract inputs of the corrupt
parties. However, it does not directly send these inputs to the ideal
functionality F∗
f since it also needs to extract and submit coins(hq)
to the ideal functionality. Also, S will use Sπ to generate messages
according to the protocol to claim deposits as done by the honest
parties in the real execution (Note: this is where we use the exten-
sibility property indirectly via Sπ). Note that Sπ does not need the
actual output of the execution until the last honest party message
(i.e., it can simulate honest messages until then).
Additionally, during the claim phase, S will need to produce
coins whenever A claims them. Suppose Pi mod n is corrupt and
it produces a valid witness (α, α(cid:48)
(For the time
n) to claim Txi.
being, assume i (cid:54)= (r + 1)n; we’ll take care of this case later.)
To simulate this, S needs to produce coins(i · q).
Ideally, we
would ask S to get these coins via Txi−1, i.e., coins((i − 1)q)
and coins(q) from Pi mod n’s roof deposit Txn,i mod n (out of a
total of coins((r + 1)q)). However, it is not clear that Txi−1 was
even made by Pi mod n. Importantly, we are able to make the fol-
lowing claim: if Txi−1 was not made by Pi mod n but Pi mod n can
produce valid witnesses to claim Txi, then for every j < i, party
Pj mod n is corrupt. Note that the above claim implies that i < n,
since we assume that there is at least one honest party.

To prove the claim, we appeal to the unforgeability property of

the transcript validation function of π in the following way. Note
that according to the protocol description, if Txi−1 was not made,
then for j < i an honest party Pj mod n would not make Txj−1.
Since it never made a deposit Txj−1, this in turn means that it
would never reveal a valid witness for Txj (Note: honest Pj mod n
claims Txj iff Txj−1 is claimed). Then it follows from the un-
forgeability property that without a valid witness for Txj it is com-
putationally infeasible to provide a valid witness to Txi. Now we
are ready to describe the simulation of the claims Tx1, . . . , Txi
(whichever were made). For transactions Txj with j < i that
were claimed, we simply use corrupt Pj+1’s deposit of coins(jq)
to give to corrupt Pj who’s claiming it. For transaction Txi, we
use coins(q) from the roof deposit of each of P1, . . . , Pi. Recall
Pi+1 is honest, and if Pi+1 made deposit Txi it must necessarily
hold that all parties (in particular, P1, . . . , Pi) made roof deposits
of coins((r + 1)q) each. The above strategy takes care of parties
that try to claim a deposit Txi without making the deposit Txi−1.
In the rest of the proof, we assume that every Pi that tries to claim
deposit Txi has made the deposit Txi−1. This case is handled eas-
ily: we ask S to get these coins via Txi−1, i.e., coins((i− 1)q) and
coins(q) from Pi mod n’s roof deposit Txn,i mod n (out of a total of
coins((r + 1)q)). The above strategy works only for i mod n (cid:54)= n.
We ﬁrst complete the discussion assuming Pn is honest and then
discuss the other case later. Suppose Pn is honest. We have al-
ready addressed how to handle coins during the claims. The only
remaining thing to address is when to ask S to contact F∗
f . Let ic
be the largest index such that Pic mod n is corrupt. S will contact
the ideal functionality when Txic is claimed by Pic. In fact, when
Txic−1 is deposited by Pic, S will take coins(hq) out of these
coins((ic−1)q) (note: ic > n > h) to deposit to the ideal function-
ality along with the inputs to the computation (extracted via Sπ). S
would then get the actual output from the ideal functionality, feed
this to Sπ and get the remaining honest messages such that the view
of the adversary is indistinguishable from the real execution. Also,
S would ask F∗
f to deliver the output to all honest parties (because
the corrupt parties did not abort the computation at all) and would
get coins(hq) back from the ideal functionality which it can then
use to handle Pic’s claim of Txic. This completes the simulation
when Pn is honest.

When Pn is corrupt, we need to show how to handle claims made
by Pn and also how to handle the interaction with the ideal func-
tionality. The claims made by Pn are handled easily: if Txi for
i mod n = n is claimed by Pn, then we supply coins(iq) to Pn
by taking it out of coins((i − 1)q) deposited by Pn in Txi−1 and
coins(q) taken out of coins(((r + 1)n − 1)q) deposited by Pn
in Tx(r+1)n−1. Note that while handling ladder claims, a total of
coins(rq) have been removed from coins(((r + 1)n − 1)q) de-
posited by Pn in Tx(r+1)n−1. This leaves coins(((r+1)n−1)q)−
coins(rq) = coins(rnq + nq − q − rq) = coins((r + 1)(n −
1)q). Actually, when Tx(r+1)n−1 is deposited by Pn, S will take
coins(hq) out of these remaining unused coins((r + 1)(n − 1)q)
(note: (r + 1)(n− 1) > h since r > 0) to deposit to the ideal func-
tionality along with the inputs to the computation (extracted via
Sπ). S would then get the actual output from the ideal function-
ality, feed this to Sπ and get the remaining honest messages such
that the view of the adversary is indistinguishable from the real ex-
ecution. Also, S would ask F∗
f to deliver the output to all honest
parties (because the corrupt parties did not abort the computation
at all) and would get coins(hq) back from the ideal functionality
which it can then use to handle Pn’s claim of Txn,j for all j since
it now has exactly coins((r + 1)(n − 1)q)!

The one additional point to note is the equivocation of honest
party’s messages so that the view of the adversary is indistinguish-

415able from the real execution. Let ih be the largest index such that
Pih mod n is honest. S will actually do the above steps of giving
coins(hq) to F∗
f right before time τih so that it can obtain the out-
put and feed this to Sπ to produce the correct view. This completes
the simulation when Pn is honest.

6. DUAL MODE PROTOCOL

We now show an application of our planted ladder mechanism.
This application is motivated by the fact that if s < n/2 parties
are corrupt, then standard secure computation protocols [8, 15] ob-
tain guaranteed output delivery (and, in particular, fairness) and one
does not have to resort to the notion of secure computation with
penalties. Additionally, note that a single corrupt party Pn in the
ladder mechanism can deny the output to all honest parties. Ide-
ally, one would want a “dual mode” protocol (alternatively, “best-
of-both-worlds” protocol) where

1. if s < n/2 parties are corrupt, then the protocol guarantees

fairness; and

2. if t > n/2 parties are corrupt, then the protocol guarantees

fairness under the penalties notion.

Ishai et al. [18] considered a weaker version of the above where
they relaxed the second requirement to obtain a protocol that guar-
antees “security-with-abort” which is the standard security no-
tion for secure computation in the presence of a dishonest major-
ity [14]. They showed (1) a negative result that precludes such
“best-of-both-worlds” protocol when the parameters s, t are such
that s + t ≥ n, and (2) a positive result with an explicit construc-
tion of such a protocol when s + t < n (in fact, their protocol
achieves guaranteed output delivery when at most s parties are cor-
rupt). Clearly, “security-with-abort” is weaker than “security-with-
penalties” since the latter implies the former. Thus, we cannot hope
for positive results in the regime where s + t ≥ n. In this section,
we show that the regime where s + t < n indeed supports a “best-
of-both-worlds” protocol as described above.
Our protocol. Our ﬁrst observation is that restarts are required
in [18] in order to guarantee output delivery, and can be avoided
in our case since we only require fairness. Then to make the script
complexity independent of the complexity of evaluating f, a natural
idea is to follow the template of [9] and to use an off-chain secure
computation protocol and make the on-chain complexity depend
only on the size of the output of f. Our off-chain MPC protocol
actually computes the output and performs a (t + 1)-out-of-n se-
cret sharing of the output. This ensures that at the end of the MPC
protocol, the adversary corrupting t > n/2 parties does not ob-
tain any information about the output. Parties then proceed to run
the planted ladder mechanism using essentially the parameters of
the original ladder mechanism of [9]. (That is, they reveal the se-
cret shares one-by-one in the ladder claim phase after revealing the
dummy witnesses in the underground claim phase.)

We note that it is important to use the planted ladder mechanism
as the ladder mechanism does not guarantee compensation to hon-
est parties that did not reveal their secret share (say, in the event
that the protocol was aborted in the middle). This is especially im-
portant as the adversary requires only one additional secret share in
order to compute the output. On the other hand, the planted ladder
mechanism guarantees that either the protocol is completed or all
honest parties obtain a compensation. That is, either all parties get
the output or all honest parties get compensated. This takes care of
the case when t ≥ n/2 are corrupt as in this case we get fairness
with penalties.

Protocol Init. Parties P1, . . . , Pn with their MPC inputs
x1, . . . , xn run an MPC protocol that
• computes z ← f (x1, . . . , xn);
• (t + 1)-out-of-n secret shares z into z1, . . . , zn;
• samples ω1, . . . , ωn at random from {0, 1}λ;
• for j ∈ [n]: computes hj = Hash(zj(cid:107)ωj);
• for i ∈ [n]: outputs yi = zi(cid:107)ωi and {hj}j∈[n] to party

Pi.

Predicates For i ∈ [n], predicate φi has {hj}j≤i hard-coded:

φi (β1(cid:107)···(cid:107)βi;{hj}j≤i) =
(Hash(β1) ?= h1)

(cid:94)···(cid:94)

(Hash(βi) ?= hi)

Procedure Extend(i, α; yi) ≡ α(cid:107)yi.
Protocol Recon. If each party has already obtained at least
t + 1 shares via the ladder mechanism, then they all recon-
struct the ﬁnal output and terminate the protocol. On the other
hand, suppose less than t + 1 shares were disclosed during the
execution of the ladder mechanism, then each honest party Pi
broadcasts yi. If at least t + 1 shares were broadcasted, then
parties now use these shares to reconstruct the output z, else
they output ⊥.

Figure 11: Parameterizing the planted ladder mechanism to
get the dual mode protocol.

For the case when s < n − t parties are corrupted, we need to
obtain complete fairness. Since there are n − s ≥ t + 1 honest
parties, we simply ask the honest parties to broadcast their shares
at the end of the protocol. Recall that t + 1 shares are sufﬁcient to
reconstruct the secret. Note that an honest party would broadcast
its share only after obtaining a compensation. Therefore, when t >
n/2 parties are corrupt, we obtain fairness with penalties, and when
less than n − t parties are corrupt we obtain complete fairness.
The script complexity of the above protocol would be O(n2|z|)
since we use the mechanism of [9]. Alternatively we could use
the compact ladder mechanism assuming a programmable random
oracle to get a protocol whose script complexity is O(nλ). The
formal protocol is described in Figure 11. (Note that Hash can be
safely replaced by honest-binding commitments as in [9].) Due to
space limitations, the proof of the following theorem is deferred to
the full version.

THEOREM 5. Assume the existence of one-way functions. Let
s, t be such that s < n/2, t ≥ n/2, and s + t < n. Then there
exists a protocol in the (FOT,F∗
CR)-hybrid model that simultane-
ously (1) SCC-realizes F∗
f when t parties are corrupted, and (2)
realizes Ff with complete fairness when s parties are corrupted.
Additionally, the protocol makes only O(n) calls to F∗
CR and the
script complexity of the protocol is O(n2|z|) where |z| denotes the
size of the output of f. (This can be reduced to O(nλ) assuming a
programmable random oracle.)

7. CONCLUSIONS

The results in this paper are motivated by the distinction be-
tween on-chain and off-chain complexity of secure computation
with penalties. Speciﬁcally, we design protocols for secure com-

416putation with penalties which have lower script complexity (i.e.,
on-chain complexity) relative to prior works [9, 22]. Our two main
efﬁciency improvements are: (1) an improvement to the script com-
plexity of secure computaion with penalties in the non-reactive set-
ting from O(n2|z|) to O(nλ) (in particular, making the complexity
independent of the function), and (2) an improvement to the script
complexity (and also number of F∗
CR calls) of secure computation
with penalties in the reactive setting from O(n2T ) to O(nT ). Both
these results provide a quadratic to linear reduction in the depen-
dence on the number of parties n and thus are likely to be useful in
practice. One major open question in this area is to remove/lessen
the dependence of the script complexity in the reactive setting on
T , i.e., the size of the transcript of the MPC protocol realizing the
reactive function.

Another contribution of this work is providing a general frame-
work for the ladder mechanism which in fact makes the protocols
easier to describe. Additionally, we use this framework to design a
protocol that offers “best-of-both-worlds” security in the sense that
it offers (1) complete fairness when up to s (< n/2) parties are cor-
rupted, and (2) fairness with penalties when up to t (> n/2) parties
are corrupted. Our protocol works in the regime where s + t < n
which is essentially the only regime where positive results are pos-
sible [18]. Open questions in this area include a lower bound on
the script complexity and the number of F∗
CR transactions required
to implement secure computation with penalties tolerating t < n
corruptions.

8. REFERENCES

[1] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L.

Mazurek. Fair two-party computations via the bitcoin
deposits. In First Workshop on Bitcoin Research, FC, 2014.
[2] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L.

Mazurek. Secure multiparty computations on bitcoin. In
IEEE Security and Privacy, 2014.

[3] Marcin Andrychowicz, Stefan Dziembowski, Daniel

Malinowski, and Lukasz Mazurek. On the malleability of
bitcoin transactions. In Financial Cryptography Workshops,
pages 1–18, 2015.

[4] N. Asokan, V. Shoup, and M. Waidner. Optimistic protocols

for fair exchange. In ACM CCS, pages 7–17, 1997.

[5] A. Back and I. Bentov. Note on fair coin toss via bitcoin.

http://arxiv.org/abs/1402.3698, 2013.

[6] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to better -

how to make bitcoin a better currency. In FC, 2012.

[7] M. Belenkiy, M. Chase, C. Erway, J. Jannotti, A. Kupcu, A.

Lysyanskaya, and E. Rachlin. Making p2p accountable
without losing privacy. In Proc. of WPES, 2007.

[8] Michael Ben-Or, Shaﬁ Goldwasser, and Avi Wigderson.

Completeness theorems for noncryptographic fault-tolerant
distributed computations. In 20th Annual ACM Symposium
on Theory of Computing, pages 1–10. ACM Press, May
1988.

[9] I. Bentov and R. Kumaresan. How to use bitcoin to design

fair protocols. In Crypto (2), pages 421–439, 2014.

[10] R. Canetti, A. Jain, and A. Scafuro. Practical uc security with

a global random oracle. In CCS, pages 597–608, 2014.

[11] David Chaum, Claude Crépeau, and Ivan Damgård.

Multiparty unconditionally secure protocols. In 20th Annual
ACM Symposium on Theory of Computing. ACM Press, May
1988.

[12] R. Cleve. Limits on the security of coin ﬂips when half the
processors are faulty (extended abstract). In STOC, pages
364–369, 1986.

[13] Juan A. Garay, Jonathan Katz, Ranjit Kumaresan, and

Hong-Sheng Zhou. Adaptively secure broadcast, revisited. In
Cyril Gavoille and Pierre Fraigniaud, editors, 30th ACM

Symposium Annual on Principles of Distributed Computing,
pages 179–186. ACM Press, June 2011.

[14] Oded Goldreich. Foundations of cryptography - vol. 2. 2004.
[15] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to

play any mental game, or a completeness theorem for
protocols with honest majority. In Alfred Aho, editor, 19th
Annual ACM Symposium on Theory of Computing. ACM
Press, 1987.

[16] S. Dov Gordon, Yuval Ishai, Tal Moran, Rafail Ostrovsky,

and Amit Sahai. On complete primitives for fairness. In
Daniele Micciancio, editor, TCC 2010: 7th Theory of
Cryptography Conference, volume 5978 of Lecture Notes in
Computer Science, pages 91–108. Springer, February 2010.
[17] S. Dov Gordon and Jonathan Katz. Partial fairness in secure
two-party computation. In Henri Gilbert, editor, Advances in
Cryptology – EUROCRYPT 2010, volume 6110 of Lecture
Notes in Computer Science, pages 157–176. Springer, May
2010.

[18] Y. Ishai, J. Katz, E. Kushilevitz, Y. Lindell, and E. Petrank.
On achieving the "best of both worlds" in secure multiparty
computation. In SIAM J. Comput. Vol. 40, No. 1, pages
122–141.

[19] A. Kiayias, H-S. Zhou, and V. Zikas. Fair and robust

multi-party computation using a global transaction ledger. In
Eurocrypt, pages 705–734, 2016.

[20] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou.

Hawk: The blockchain model of cryptography and
privacy-preserving smart contracts. In IEEE Security and
Privacy, 2016.

[21] R. Kumaresan and I. Bentov. How to use bitcoin to

incentivize correct computations. In CCS, pages 30–41,
2014.

[22] R. Kumaresan, T. Moran, and I. Bentov. How to use bitcoin

to play decentralized poker. In CCS, 2015.

[23] Alptekin Küpçü and Anna Lysyanskaya. Usable optimistic

fair exchange. In Josef Pieprzyk, editor, Topics in Cryptology
– CT-RSA 2010, volume 5985 of Lecture Notes in Computer
Science, pages 252–267. Springer, March 2010.

[24] Andrew Y. Lindell. Legally-enforceable fairness in secure

two-party computation. In Tal Malkin, editor, Topics in
Cryptology – CT-RSA 2008, volume 4964 of Lecture Notes in
Computer Science, pages 121–137. Springer, April 2008.

[25] L. Luu, J. Teutsch, R. Kulkarni, and P. Saxena. Demystifying

incentives in the consensus computer. In CCS, pages
706–719, 2015.

[26] G. Maxwell. Zero knowledge contingent payment. 2011.

https:
//en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment.
[27] Jesper Buus Nielsen. Separating random oracle proofs from
complexity theoretic proofs: The non-committing encryption
case. In Moti Yung, editor, Advances in Cryptology –
CRYPTO 2002, volume 2442 of Lecture Notes in Computer
Science, pages 111–126. Springer, August 2002.

[28] Benny Pinkas. Fair secure two-party computation. In Eli

Biham, editor, Advances in Cryptology –
EUROCRYPT 2003, volume 2656 of Lecture Notes in
Computer Science, pages 87–105. Springer, May 2003.

[29] Andrew Yao. How to generate and exchange secrets
(extended abstract). In FOCS, pages 162–167, 1986.

Acknowledgements
Research supported in part by NSF Grants CNS-1350619 and CNS-
1414119, Alfred P. Sloan Research Fellowship, Microsoft Faculty
Fellowship, the NEC Corporation, a Steven and Renee Finn Career
Development Chair from MIT, and an MIT Translational Fellow-
ship. This work was also sponsored in part by the Defense Ad-
vanced Research Projects Agency (DARPA) and the U.S. Army
Research Ofﬁce under contracts W911NF-15-C-0226.

417