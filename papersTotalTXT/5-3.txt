Accumulators and U-Prove Revocation(cid:63)

Tolga Acar1, Sherman S.M. Chow2, and Lan Nguyen3

1 Intel Corporation

tolga.acar@intel.com
2 Microsoft Research

lan.duy.nguyen@microsoft.com

3 Department of Information Engineering

Chinese University of Hong Kong

sherman@ie.cuhk.edu.hk

Abstract. This work introduces the most eﬃcient universal accumula-
tor known today. For the ﬁrst time, we have an accumulator which does
not depend on hidden order groups, does not require any exponentia-
tions in the target group associated with the pairing function, and only
requires two pairings to verify a proof-of-knowledge of a witness.
We present implementations of our accumulator and another recent pro-
posal utilizing Groth-Sahai proofs, with performance results. Our im-
plementations are designed with cryptography agility in mind. We then
build a library for revoking anonymous credentials using any accumula-
tors, and integrated it with Microsoft U-Prove, which has a signiﬁcant
contribution to an European Union’s privacy standardization eﬀort. Our
work enables U-Prove revocation without compromising untraceability.

1

Introduction

Accumulator. A cryptographic accumulator allows aggregation of a large set
of elements into one constant-size accumulator value, and proving about whether
an element has been accumulated. Via the proof system, a prover with a witness
can convince a veriﬁer about the truth of a statement, but any adversary cannot
convince a veriﬁer about a false statement. The basic proof is about membership
statement, for proving that an element has been accumulated. An accumulator
is said to be universal if it has another proof system, called non-membership, to
prove that a given element is not accumulated. Moreover, if the costs of updating
the accumulator or witnesses, when elements are added to or deleted from the
accumulator, do not depend on the number of elements aggregated, we say it
is dynamic. Two universal dynamic accumulators have been proposed so far.
One is based on the Strong RSA assumption in hidden order groups [15], which
is derived from a basic (non-universal) accumulator proposed [8]. The other
is based on the Strong Diﬃe-Hellman assumption in prime-order groups with
bilinear map (or pairing) [3] which is derived from a pairing-based non-universal

(cid:63) This is an extended abstract. We thank the help of Benoˆıt Libert and Toru Nakanishi.

2

Tolga Acar, Sherman S.M. Chow, and Lan Nguyen

accumulator proposed [18]. There is another pairing-based dynamic accumulator
[7]; however, it is not universal.

Applications. Accumulators have been used in various applications for dif-
ferent purposes. Two of its major beneﬁts include minimizing the bandwidth
requirement and protecting privacy. With the proliferation of mobile devices,
bandwidth requirement is becoming more crucial. On the other hand, privacy
is a growing concern in various diﬀerent sectors such as healthcare, military, in-
telligence, and mobile devices industry. The emergence of cloud computing also
leads to a diﬀerent balance between trust and anonymity in identity manage-
ment. Some applications of accumulators include space-eﬃcient time-stamping
[4], electronic voting [10], and many privacy-preserving authentication mecha-
nisms which include ad-hoc anonymous authentication [11], (ID-based) ring sig-
natures [11, 18], dynamic k-times anonymous authentication [2], and anonymous
credentials which are revokable [8, 7].

Anonymous Credentials. Using anonymous credentials a user can prove
the possession of some credentials without revealing any other private infor-
mation such as her identity. Applications include direct anonymous attestation
[6], anonymous electronic identity token [9, 16], and implementations such as
U-Prove [16], Idemix [9] and in Java cards [5]. In practice, revocation is indis-
pensable in credential systems, as dispute, compromise, mistake, identity change,
hacking and insecurity could make any credential become invalid before its ex-
piration, especially when they are carried around by mobile devices.

Revocation. Revoking credentials is a notorious issue in cryptography, not
to say anonymous credentials. Consider public key infrastructure, there is a cer-
tiﬁcate revocation list which consists of invalid certiﬁcates, and is time-stamped
and signed by a certiﬁcate authority. Checking if a certiﬁcate is revoked requires
searching the certiﬁcate’s identity in the entire list. For anonymous credential, it
is even more tricky. In particular, the anonymity and the run-time requirements
of honest users should not be aﬀected by revocation of other credentials.

Our contribution. The major contribution of this work is our eﬃciency
improvement of (non-)membership proofs associated with an accumulator, which
brings beneﬁts to many existing applications utilizing accumulator. Our eﬃ-
ciency gain comes from a new design which only requires proving equations in
a base group G1 associated with the curves featuring the pairing function, in-
stead of the standard approach in the literature which proves about some pairing
equations. As a result, not only the number of pairing operations is greatly re-
duced, there is also no exponentiation or other operations in the target group
GT (nor in the other base group G2), which are often ineﬃcient when compared
with the operations in G1. (Exponentiation in GT could be 4 or 5 times more
expensive than that in G1, and exponentiation in G2 could still be 1.5 to 2 times
more expensive.) In particular, our proof systems require less exponentiations
and pairings compared to previous pairing-based schemes [18, 3] which use sym-
metric pairings. It is especially suitable for Barreto-Naehrig pairing curves (BN
curves) [13], arguably one of the most eﬃcient pairing-friendly curves, where
G1’s operations are also very eﬃcient.

Accumulators and U-Prove Revocation

3

2 U-Prove with Revocation using Our New Accumulator

In this section, we show how to use the non-membership proof of our accumulator
to blacklist U-Prove tokens. It will be embedded in the U-Prove presentation
protocol as detailed in U-Prove Crypto Speciﬁcation V1.1 (‘Spec’) [16]. Due to
the lack of spaces, this part is a sketch and should be read in conjunction with the
Spec [16]. The text “[For Revocation]” highlights the additions of revocation
parts to the existing U-Prove protocols.

2.1 Entities

In the original U-Prove Spec, there are Issuer, Prover and Veriﬁer. Issuer issues
each Prover U-Prove tokens that contain Issuer’s certiﬁcation of the Prover’s
attributes. A Prover can prove some of her attributes to a Veriﬁer in a U-Prove
token presentation protocol. Besides these three entities as in Spec, we introduce
Blacklist Authority (BA), who could be the same as or independent from Issuer.
There could be several BAs and several blacklists. Apart from proving Prover’s
attributes, our new token presentation protocol can also prove that the token is
not in any of the blacklists, with full anonymity.

2.2 System Parameters

The generations of the system parameters follows closely as the original Spec,
except that the system parameters for the accumulator will also be included.

Issuer parameters: Deﬁne

IP = (UIDP, desc(Gq), UIDH, (g0, g1, . . . , gn, gt) , (e1, . . . , en) , S))

where UIDH is an identiﬁer of a cryptographically secure hash algorithm.

[For Revocation] Accumulator parameters: Deﬁne

param = (q, G1, G2, GT , e, P1, P2, Ppub, H, K, G1)
δ, K = H δ for a random δ ∈ Zq and G1, H ∈ G1, P2 ∈ G2.

where Ppub = P2

δ2

δ, P1

δk

, . . . , P1

1. One may include vector t = (P1

) for the users to compute
their own witness (to be described). We can have a constant-size public-key
(without the vector t) when the BA computes the witness for each user using
the auxiliary secret value δ.
2. The order of the bilinear groups where e : G1 × G2 → GT should all have
the same prime order q, i.e., the accumulator should be instantiated with
the same prime number q used in Issuer’s parameter.

4

Tolga Acar, Sherman S.M. Chow, and Lan Nguyen

2.3 Issuing U-Prove Token

The protocol for Issuer to issue U-Prove tokens to Provers is the same as in
the original Spec, except that there is a designated attribute xid in the U-Prove
token for revocation purpose.

Generating U-Prove token: A U-Prove token has the same form as in Spec:

(UIDP, h, T I, P I, σ(cid:48)

z, σ(cid:48)

c, σ(cid:48)
r)

where
– The private key is α−1 ∈ Z∗
q.
– The public key h, with a number of attributed xt, x1, . . . , xn embedded, is
– A valid signature from an issuer is given in the form of (σ(cid:48)

h = (g0g1

x1 . . . gid

xid . . . gn

(mod q).

xn gt

xt)α

z, σ(cid:48)

c, σ(cid:48)
r).

2.4 Blacklist

A blacklist is published and managed by a BA. Note that BA has the auxiliary
information to eﬃciently compute the accumulating values. For example, on day
1, three elements xid1 , xid2 , xid3 can be accumulated in V1; then, on day 2, xid2
can be deleted, and xid4 can be added, which results in an updated V2.

[For Revocation] Maintaining Revocation List: BA decides an attribute
xid for revocation. We can have some options here: xid could uniquely identify a
token, a user or an organization. Suppose there are m revocations, BA publishes
the list of {xidi}, and accumulates them by
(cid:81)m

V = P1

i=1 (δ+xidi ).

2.5 Presenting U-Prove Tokens

The diﬀerence with the basic presentation protocol of a valid U-Prove token
is that, now a Prover also needs to prove the knowledge of xid, which is the
attribute used for revocation, is not accumulated in BA’s blacklist.

Input:
1. Ordered indices of disclosed attributes: D ⊂ {1, . . . , n}
2. Ordered indices of undisclosed attributes: U = {1, . . . , n}\D
3. U-Prove token: T = (UIDP, h, T I, P I, σ(cid:48)
4. Messages: m ∈ {0, 1}∗
5. Private key: α−1 ∈ Zq
6. Attribute values: (A1,··· , An) ∈ ({0, 1}∗)n
7. [For Revocation] The current accumulating value: V

c, σ(cid:48)
r)

z, σ(cid:48)

Accumulators and U-Prove Revocation

5

8. [For Revocation] The updated witness: (W, d, Q) where

– d =(cid:81)m
of(cid:81)(z + xidi) by (z + xid), and is non-zero since xid /∈ {xidi}.
((cid:81)m
i=1 (δ+xidi )−d)/(δ+xid)

(mod (δ + xid)) ∈ Zq,

i=1 (δ + xidi )

which can be computed without knowing δ by simple polynomial division

– W = P1
– Q = V W −xid P1

−d.

which is computable by using vector t in param.

Proof Generation:

1. [For Revocation] Prepare for the commitment part of the proof that the

credential is not revoked:
Randomly pick x, u, t1, t2, t3, rx, ru, rt1, rt2 , rt3, rβ1 , rβ2, rβ3, rd, rd(cid:48) ∈ Zq. Set:

Y := QK t1,

X := W H t1,
R := G1
T1 := G1

xH u, A := G1
C := G1
d(cid:48)
Γ := X−rxH rβ1 K rt1 P1
H t3 ,
rβ1 H rβ2 R−rx , T3 := G1
rd(cid:48) H rt3 , T4 := H rβ3 S−rd .

rx H u
−rd ,

t1H t2, S := G1
rt1 H rt2 , T2 := G1

2. [For Revocation] (In the original Spec, a := H(hw0((cid:81)
Compute a := H(hw0 ((cid:81)

3. c := GenerateChallenge(IP,T , a, m, ∅, D,{xi}i∈D) ∈ Zq.
4. [For Revocation] Prepare for the response part for the proof that the

i∈U gwi

i ), H(X, Y, R, S, T1, T2, T3, T4, Γ, param)).

i∈U gwi

i ))).

credential is not revoked, by computing the following:

β1 = t1xid,
β3 = t3d,
su = −cu + ru,
sd = −cd + rd,
st1 = −ct1 + rt1, st2 = −ct2 + rt2, st3 = −ct3 + rt2,
sβ1 = −cβ1 + rβ1 , sβ2 = −cβ2 + rβ2 , sβ3 = −cβ3 + rβ3 .

β2 = t2xid,
sx = −cx + rx,

d(cid:48) = d−1
sd(cid:48) = −cd(cid:48) + rd(cid:48)

5. xt := ComputeXt(IP, T I) ∈ Zq.
6. For each i ∈ {1, . . . , n} , xi := ComputeXi(IP, Ai) ∈ Zq.
7. Generate wo at random from Zq, set r0 := cα−1 + w0
(mod q).
8. For each i ∈ U , generate wi at random from Zq, set ri := −cxi+wi

9. Return the U-proven token proof(cid:0){Ai}i∈D, a, r0,{ri}i∈U

(cid:1).

10. [For Revocation] Also return the non-revoked proof:

(mod q).

(c, su, sx, sd, sd(cid:48), st1, st2 , st3 , sβ1, sβ2 , sβ3 , C, X, Y, R, S) .

Proof Veriﬁcation:
1. Execute VerifyTokenSignature(IP,T ) which veriﬁes (σ(cid:48)
2. xt := ComputeXt(IP, T I).
3. For each i ∈ D, xi := ComputeXi(IP, Ai).
4. Set c := GenerateChallenge(IP,T , a, m, ∅, D,{xi}i∈D).

z, σ(cid:48)

c, σ(cid:48)
r).

6

Tolga Acar, Sherman S.M. Chow, and Lan Nguyen

5. [For Revocation] Execute the following steps for non-membership proof

veriﬁcation:

˜T1 := G1
˜T3 := G1
˜A := G1

sβ1 H sβ2 R−sx ,
st1 H st2 Rc, ˜T2 := G1
−cH sβ3 S−sd ,
sd(cid:48) H st3 Sc, ˜T4 := G1
sx H su C c, ˜Γ := X−sx H sβ1 K st1 P1

−sd (V

−1Y )c.

Verify if e (Y, P2) ?= e(X, Ppub), and if
a = H((g0gxt

hr0(

−c

gxi
i )

(cid:89)

i∈U

(cid:89)

i∈D

t

i ),H(X, Y, R, S, T1, T2, T3, T4, Γ, param)).
gri

3 Crypto-Agile Software Design

Fig. 1: Our Software Design

The design of our accumulator-and-applications system is illustrated in Fig-
ure 1. There is one common application program interface (API) for all accu-
mulators, providing the interface for the operations. Two accumulators, the new
one in this paper (based on Fiat-Shamir transformation [12], denoted as ACN)
and the existing one (based on Groth-Sahai proof [14], denoted as AccuGS) [1],
have been implemented according to the API. They are the ﬁrst implementation
of universal accumulators, and AccuGS provides the only solution for revoking
delegatable anonymous credentials not relying on random oracles.

The API could be used to develop accumulator’s applications. One such ap-
plication is for revoking anonymous credentials. We further implement a revoca-
tion API. A blacklist authority could use it to create a blacklist and accumulate
revoked anonymous credentials, and an user could prove that a credential is
not accumulated in a blacklist. Several anonymous credential systems based on
prime order could use this revocation. We have used it for U-Prove.

This design supports crypto-agility. With a common accumulator API, it is
easy to add other accumulators’ implementations based on diﬀerent assumptions,
to replace an existing implementation with a more eﬃcient or safer one, and to
switch among them with minimum code refactoring. With a single revocation

Accumulators and U-Prove Revocation

7

API and a single accumulator API, we just need a single implementation of
“Revocation using Accumulators”. This reduces redundancy and allows us to
have a painless changes from, say, AccuGS to ACN.

The system is developed in C++ and built into 3 dynamic link libraries
(dll) in Windows. The ﬁrst, accumulator.dll, implements ACN and AccuGS. The
second, RAC.dll, utilizes the ﬁrst library to perform revoking anonymous creden-
tials. The third, UProveRAC.dll, uses the second library to integrate revocation
into U-Prove. UProveRAC.dll consists of all existing UProve API and additional
API functions with revocation capability. The new UProveRAC functions allow
generating revocation parameters and keys, computing and updating witnesses,
and proving and verifying that U-Prove tokens are not revoked.

4 Performance

For a fair comparison, we compare performances of ACN and the only previ-
ous universal accumulator ATSM [3], which derived the membership proof from
Nguyen’s [18] and introduced a new NM proof. We only compare the proof sys-
tems, as other algorithms are very similar. Both the proofs of ACN and ATSM
can be made interactive and do not rely on the random oracle heuristics, or can
be converted into non-interactive version via Fiat-Shamir heuristics [12] which
1 → G(cid:48)
relies on the random oracle. ATSM only uses symmetric pairing G(cid:48)
T ,
whereas ACN works for both symmetric and asymmetric settings G1×G2 → GT .
So ACN could use much more eﬃcient asymmetric pairing groups, such as BN
curves [13]. Indeed, as discussed, operations in G1 are much more eﬃcient than
corresponding operations in G(cid:48)
T . ACN is especially suitable for BN curves,
which features not only one of the most eﬃcient pairing operations, but also very
eﬃcient exponentiation in G1. Even if the pre-computed pairings are ignored,
ACN is still signiﬁcantly more eﬃcient than ATSM. Table 1a compares the num-
bers of exponentiations and pairings between these proof systems.

1 and G(cid:48)

1 × G(cid:48)

Table 1b shows the performance (in milliseconds) of the major functions
in ACN and AccuGS [1], running on a modest machine Intel Core2 2.4 GHz
with 4 GB RAM, 64-bit Win7, using 254-bit BN curves. Again, the underlying
accumulators are the same so we focus in witness operations. Accumulating 40
elements take 3.5 ms, and updating accumulator with 1 element takes 1.71 ms.
Finally, it takes 36.055ms to generate an UProve proof and 73.817ms to verify
it. Those numbers never depend on the blacklist’s size.

References

1. T. Acar and L. Nguyen. Revocation for delegatable anonymous credentials.

PKC 2011 LNCS 6571, p. 423–440.

2. M. H. Au, W. Susilo, Y. Mu, and S. S. M. Chow. Constant-size dynamic k-times

anonymous authentication. IEEE Systems Journal, to appear.

3. M. H. Au, P. P. Tsang, W. Susilo, and Y. Mu. Dynamic universal accumulators
for DDH groups and their application to attribute-based anonymous credential
systems. CT-RSA 2009, LNCS 5473, p. 295–308.

8

Tolga Acar, Sherman S.M. Chow, and Lan Nguyen

Algorithms ACN

E1 e(·,·) E(cid:48)

ATSM
1 Et e(·,·)
19 4 2 (+4)
19 5 2 (+4)
13 3 2 (+3)
13 4 2 (+3)

NMPrf() 21
0
NMVfy() 20
2
MemPrf() 14
0
MemVfy() 13
2
(a) Legend: (E1, E(cid:48)
1, and ET denote
exponentiations in G1, G(cid:48)
1, and GT
resp.; x(+y): x pairings needed, an-
other y of them can be pre-computed)

Operations

ACN AccuGS
Update witness 77.102 78.980
11.882 30.609
18.714 102.978
24.148 117.897
80.635 587.164

NMPrf()
NMVfy()
MemPrf()
MemVfy()

(b) (The updating witness oper-
ation here is for adding 40 and re-
moving 5 elements, i.e., a total of
45 unit updates.)

Table 1: Performance of ACN, ATSM, and AccuGS

4. J. C. Benaloh and M. de Mare. One-way accumulators: A decentralized alternative
to digital signatures (extended abstract). EUROCRYPT ’93, LNCS 765, p. 274–
285.

5. P. Bichsel, J. Camenisch, T. Groß, and V. Shoup. Anonymous credentials on a

standard java card. ACM CCS 2009, p. 600–610.

6. E. F. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. ACM

CCS 2004, p. 132–145.

7. J. Camenisch, M. Kohlweiss, and C. Soriente. An accumulator based on bilinear
maps and eﬃcient revocation for anonymous credentials. PKC 2009, LNCS 5443,
p. 481–500.

8. J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to
eﬃcient revocation of anonymous credentials. CRYPTO 2002, LNCS 2442, p. 61-
76.

9. J. Camenisch and E. Van Herreweghen. Design and implementation of the idemix

anonymous credential system. ACM CCS 2002, p. 21–30.

10. S. S. M. Chow, J. K. Liu, and D. S. Wong. Robust receipt-free election system

with ballot secrecy and veriﬁability. NDSS 2008, p. 81–94.

11. Y. Dodis, A. Kiayias, A. Nicolosi, and V. Shoup. Anonymous identiﬁcation in ad

hoc groups. EUROCRYPT 2004, LNCS 3027, p. 609–626.

12. A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identiﬁcation

and signature problems. CRYPTO ’86, LNCS 263, p. 186–194.

13. C. C. F. P. Geovandro, M. A. S. Jr., M. Naehrig, and P. S. L. M. Barreto. A family
of implementation-friendly BN elliptic curves. Journal of Systems and Software,
84(8):1319–1326, 2011.

14. J. Groth and A. Sahai. Eﬃcient non-interactive proof systems for bilinear groups.

EUROCRYPT 2008, LNCS 4965, p. 415–432.

15. J. Li, N. Li, and R. Xue. Universal accumulators with eﬃcient nonmembership

proofs. ACNS 2007, LNCS 4521, p. 253–269.

16. Microsoft. U-Prove cryptographic speciﬁcation. http://research.microsoft.

com/en-us/projects/u-prove, 2011. (Last Visited on Feb 7th, 2013.)

17. D. Nelson. Crypto-agility requirements for remote authentication dial-in user ser-

vice (RADIUS). RFC 6421 (Informational), Nov. 2011.

18. L. Nguyen. Accumulators from bilinear pairings and applications. CT-RSA 2005,

LNCS 3376, p. 275–292.

