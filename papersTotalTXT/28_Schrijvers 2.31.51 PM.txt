Incentive Compatibility of

Bitcoin Mining Pool Reward Functions

Okke Schrijvers, Joseph Bonneau, Dan Boneh, and Tim Roughgarden

Stanford University

Abstract. In this paper we introduce a game-theoretic model for re-
ward functions in Bitcoin mining pools. Our model consists only of an
unordered history of reported shares and gives participating miners the
strategy choices of either reporting or delaying when they discover a share
or full solution. We deﬁned a precise condition for incentive compatibil-
ity to ensure miners strategy choices optimize the welfare of the pool as
a whole. With this deﬁnition we show that proportional mining rewards
are not incentive compatible in this model. We introduce and analyze a
novel reward function which is incentive compatible in this model. Fi-
nally we show that the popular reward function pay-per-last-N-shares is
also incentive compatible in a more general model.

1

Introduction

By almost any measure, Bitcoin [1] has become the most successful cryptocur-
rency in history. While Bitcoin has evolved into a very complex sociotechnical
system which we will not describe in detail here,1 at its core lies a decentralized
consensus protocol allowing all participants to agree on a common global ledger
of transactions to prevent double-spends and other disallowed behavior. The key
to Bitcoin’s consensus protocol (sometimes more broadly called Nakamoto con-
sensus after its founder) is a group of entities called miners who race to solve a
challenging cryptographic puzzle for the right to append a new block of transac-
tions to Bitcoin’s ledger, the blockchain. A system of incentives encourages these
miners to follow the protocol faithfully in exchange for the ability to earn newly-
minted coins and transaction fees in proportion to the amount of computational
eﬀort they have expended (also called hashing power or mining power).

Finding a single Bitcoin block is very rewarding (today worth at least B25,
over US$6,000), yet it is also very diﬃcult for smaller miners who might ﬁnd a
block on expectation only every few months or even every few years. As a result,
the majority of mining power now consists of miners participate in mining pools
in which they agree to divide rewards from blocks found by any member of the
pool and thus receive a steadier stream of income. Choosing the exact algorithm
used to divide up mining pool rewards (the reward function) however, turns out
to be a challenging incentive design problem.

1 For an academic overview of Bitcoin we refer the reader to [2].

Pools are sometimes controversial in the Bitcoin community as they rep-
resent a form of centralization. Miller et al. proposed a future cryptocurrency
which attempts to prevent their formation [3]. As of today though they are
an indispensable part of Bitcoin as well as many related cryptocurrencies (to
which our work will also apply). Despite this, relatively little work has focused
on the reward functions underlying pools since Rosenfeld’s initial overview of
the space [4]. Several papers have studied the interaction between pools and
found that in some plausible circumstances pools will be incentivized to attack
each other [5,6,7]. Yet the incentives underlying reward functions have not been
rigorously studied.

In this paper we introduce a formal game-theoretical framework to study
these reward functions. We are motivated by a very natural question: if individ-
ual miners are interested in maximizing their expected utility, is their behavior
optimal for the pool as a group? For example, if miners are incentivized to delay
reporting full solutions to the pool, this may lower the pool’s overall rewards and
even make it more vulnerable to external sabotage [5]. We introduce a simpliﬁed
model with only a single mining pool and deﬁne basic properties that a good
reward function should exhibit. Although our model is deliberately simpliﬁed,
we still show somewhat surprisingly that some reward functions used in practice
such as simple proportional payments are not incentive compatible.

We introduce a novel reward function which is incentive compatible within
our model while still maintaining other desirable properties. Our reward function
will remain incentive compatible even in a more complex informational model
(although it may need to be extended if the deﬁnition of incentive compatibility
is extended to include more complicated attacks).

While our model cannot capture all reward functions used in practice, we
consider it an important milestone in analyzing mining pools in Bitcoin and
related systems. We further take the ﬁrst step to analyzing reward functions in
more general informational models by carefully examining the popular pay-per-
last-N-shares reward function, and show that it is incentive compatible. This
indicates that our approach is not limited to the informational assumptions, but
can be more generally applied.

2 Preliminaries

In this paper we look at a simple model in which miners are bound to working
for a particular pool and where their strategic choice is the following: if a miner
ﬁnds a solution to the cryptographic puzzle, when does it report this to the pool.
The pool is run by a pool operator and contains a ﬁxed number n of miners. Each
miner i has a fraction αi of the total mining power. For most of this paper we
i=1 αi = 1, meaning that the pool has all the available mining
power; there are no other pools or solo miners. In Appendix C we look at the
i=1 αi < 1 and show that
while this makes a quantitative diﬀerence, qualitatively our results carry over.

will assume that(cid:80)n
case where the pools total hashing power αP = (cid:80)n

The time it takes for a miner to ﬁnd a share is an exponentially distributed
random variable with parameter αi; hence in expectation it takes time 1/αi to
ﬁnd a share. Each share is also a full solution with probability 1/D.

2.1 Reward Functions and History Transcripts

Miners report their shares and solutions to the pool operator. When a solution
is reported, the operator who collects the block reward from the Bitcoin network
and subsequently divides the reward among the n miners according to a reward
function R. The game then restarts. For the mathematical model we assume no
variability in the block reward or the transaction fees, although the work can be
extended to include this.

The reward function is the only way in which the miners receive any payout
and therefore the reward function completely drives the behavior of miners. A
perfectly equitable reward function would simply give each miner i a fraction
αi
of the reward in proportion to the fraction of the pool’s total mining power
αP
to which that miner contributed.

i=1 with (cid:80)

However, the pool operator does not know the actual αi of each miner. The
challenge in designing a reward function R stems from the necessity of estimating
this based on reported shares and solutions. The operator’s ability to estimate αi
depends on the precise information it has access to. We model this as a history
transcript H. A reward function R : H → [0, 1]n is a function from a history
transcript to an allocation {ai}n
i ai = 1. We use Ri : H → [0, 1] to
denote the function that yields the ith component of R.
In most of this paper we analyze the case of an unordered history transcript:2
H contains for each miner i the total number of shares bi ∈ N that have been
reported in that round.3 Thus, the history transcript is given by a vector b ∈ Nn
that contains for each of the n players the total number of shares that she found
during the round (where the full solution is also counted as a share). We use
vector notation for b, so b1 + b2 means the component-wise addition of b1 and

b2, and ||b||1 =(cid:80)n

i=1 bi is the sum of the components of b.

This model is perhaps the simplest possible4 which enables a mining pool to
function, yet it captures several basic reward function schemes used in practice.
There are also reward functions which require additional information, such as
the order in which shares were reported or reports from previous rounds of
the game. In Section 8 we brieﬂy discuss how to generalize this model and the
challenges with characterizing incentive compatibility for them. However, we
stress that positive results demonstrated incentive compatibility in our simple
model extend to any more complicated model, as the pool operator can always
decline to use additional information in its reward function.

2 In Section 6 we consider a strictly more general informational model, which will be

described there.

3 We adopt the convention that N includes the number 0.
4 A simpler format such as only receiving information about which miner reported a

full solution would only allow a replication of solo mining.

2.2 Miner Strategy

Now that we deﬁned a model and the reward function R, let’s look at how the
choice of R impacts the behavior of miners. The goal of any mining pool is to
earn as many rewards as possible for its members.5 If miners delay in reporting
blocks to the pool, this imposes a risk that an external pool may ﬁnd the block
ﬁrst, undermining the pool’s potential rewards.6 Note that while we are only
modeling a single pool, we build in the assumption that this pool wants to report
solutions as fast as possible to the wider network to avoid getting scooped by
the competition. Thus we will want our reward function to ensure solutions to
be reported and processed as soon as they are found.7

In response to a reward rule R, miners choose a strategy σ(R) which dictates
what a miner does when it ﬁnds a share or full solution. Ideally the strategy
σ(R) is to report any share or solution immediately. However, the pool operator
cannot directly tell miners what to do; rather they should choose an R such that
the miners corresponding strategy σ(R) is to immediately report. Formally, let
t be the time since miner i started mining, let T be the number of rounds that
have been completed at time t, and let bj be the number of shares per player in
round j. Miner i is interested in maximizing their throughput:

(cid:80)T

σ(R) := max

σ

lim
t→∞

j=1 Ri(bj)

t

.

(1)

Here σ impacts the number T of rounds that were completed, as well as the
number of reported shares bj in each round.

2.3 Reward Function Desiderata

We deﬁne three properties which are important for a reward function. The ﬁrst
is a formalization of the intuition above:

Property 1 (Incentive Compatibility). A reward function R is incentive compati-
ble when every miner’s best response strategy σ(R) reports full solutions imme-
diately.

In Section 3 we give a mathematical condition that characterizes Property 1,
and that can easily be veriﬁed for reward functions.

5 In this work we are only considering a pool which follows the default mining strategy
and does not attempt to implement an deviant strategies to earn disproportionately
more rewards than competing pools, such as temporary block withholding [8].

6 Another way of saying this is that a reward function which does not compel partic-
ipants to report solutions immediately is not welfare maximizing, since the selﬁsh
behavior of individuals can hurt the total reward of the group.

7 While we do not consider fees in this paper, note that a pool operator would also

want to optimize throughput if collects a fraction of the reward.

Next, we require that the pool pays miners in proportion to the amount of
work they have performed. Miners form pools to reduce the variance in revenue.
In practice they might accept losing a small fraction f of their expected value
in fees, but we would like miner performing an αi fraction of the work to receive
an αi fraction of the reward.

Property 2 (Proportional Payments). A reward function R provides proportional
payments whenever for each miner i

Eb[Ri(b)] = αi.

Finally, we would like the pool operator to never incur a deﬁcit. That is, the
reward function R should precisely divide the reward among the n miners at the
end of a round. If this is not the case, then either miners may leave some value on
the table, or the pool operator may be liable for more then she received herself.
This latter condition is particularly dangerous, as it leaves the pool exposed to
sabotage attacks [5] in which competing miners purposely withhold full solutions
to damage the pool.

Property 3 (Budget Balanced). A reward function R is (γ, δ)-budget balanced
when for all b:

γ ≤ n(cid:88)

Ri(b) ≤ δ.

i=1

In particular, an (γ, 1)-budget balanced reward function will never pay more
to the miners than the pool operator received. Our goal will be (1, 1)-budget
balanced reward functions which share the reward exactly among the n miners.

2.4 Common examples

Ri(b) = bi/K, where K = ||b||1 = (cid:80)n

Perhaps the most obvious reward function is the proportional reward function:
i=1 bi. That is, the reward is shared
proportional to the number of shares each miner reported. We show that the
proportional rule is not incentive compatible in Section 4.1.

Another reward function is the pay-per-share reward function: Ri(b, s) =
bi/D, where participants are rewarded a ﬁxed amount per share. In Section 4.2
we show that while this method is incentive compatible, it is not budget balanced
(deﬁned in Section 2.3), which means that the pool operator may be liable to
pay out more to miners than she collects from the Bitcoin protocol.

2.5 Ensuring Steady Rewards

Miners are interested in maximizing the total reward they receive per time unit,
but they join pools primarily to achieve a more consistent stream of revenue.
Our goal will be to build a reward function which is as consistent as possible

which satisﬁes the three properties above. It is tempting to isolate one metric,
such as the variance or standard deviation of the distribution of rewards, but we
will discuss in Section 7 why these metrics are probably not the best measures
of consistency in practice and provide diﬀerent simulation results to compare
reward functions.

3

Incentive Compatibility

We stated that for a reward function R to be incentive compatible, it needs to
incentivize miners to report full solutions immediately. In this section we express
that as a condition that can easily be checked for any given reward function.

We do this by looking at the strategic choice that a miner faces when she
ﬁnds a full solution. Either she reports the full solution immediately, or she
decides to delay reporting the solution until d more shares have been found. In
this section we do not take into account the possibility of another miner ﬁnding
and reporting a solution during this delay. In Appendix B we show that this is
virtually without loss of generality.

Consider the situation when at time t, miner i ﬁnds a full solution. At this
point bt shares have been reported to the pool operator (for notational simplicity
we assume that the full solution is already included in bt). The action space of
miner i is d ∈ N (including 0) where the miner waits for d additional shares to
be reported before reporting the full solution. If miner i decides to wait for d
shares before reporting, her expected reward at the end of the delay is:

E(b s.t. ||b||1=d)[Ri(bt + b)] =

Pr(seeing b) · Ri(bt + b)

(cid:88)

b s.t. ||b||1=d

On the other hand, if she decides to report the full solution immediately, she
will receive the reward she was entitled to at that moment and a new round will
start. So she will additionally get d times the expected reward per share. That
is, delaying her report imposes an opportunity cost by not beginning the next
round. So her expected reward in this situation after d more shares is:

Ri(bt) + d · Eb [Ri(b)]
Eb[||b||1]

= Ri(b) + d ·

Eb [Ri(b)]

k=1 k(cid:0)1 − 1
(cid:80)∞

(cid:1)k−1 1

D

D

= Ri(bt) +

· Eb [Ri(b)]

d
D

Reporting the solution immediately will be more proﬁtable than delaying for

d shares if and only if:

Pr(seeing b) · (Ri(bt + b) − Ri(bt)) ≤ d
D

· Eb [Ri(b)]

(2)

(cid:88)

b s.t. ||b||1=d

The miner’s best strategy is to report immediately if this condition holds
for all d ∈ N\{0}. The following lemma states that there exists a d ∈ N\{0} for
which this condition holds if and only if it holds for d = 1. This is a very powerful
statement: to determine the incentive compatibility of a reward function, we only
need to see if it is proﬁtable to delay reporting for a single additional share. In
the following, let ej be the jth standard basis vector that is 0 everywhere except
for the jth component which is 1. Due to space limitations the proofs for all
lemmas appear in Appendix A.

Lemma 1. For a reward function R, a player i has an incentive to report full
solutions immediately, iﬀ the following condition holds for all {αi}n
i=1, bt, D, i:

n(cid:88)

j=1

αj · (Ri(bt + ej) − Ri(bt)) ≤ Eb [Ri(b)]

D

(3)

So to show that a reward function is incentive compatible, we need to show
that condition (3) holds, and conversely when we show that for a reward function
condition (3) is not guaranteed to hold, it cannot be incentive compatible.8

While for incentive compatibility we do not care about miners reporting

shares immediately, this is important in ensuring proportional payments.

Lemma 2. Miners report shares immediately if and only if the reward function
R is monotonically increasing each component. That is: for all i, and b:

Ri(b + ei) > Ri(b).

4

Incentive Compatibility of Existing Methods

Now we will apply our characterization of incentive compatibility to reward
functions which are in use today. In this section we restrict ourselves to reward
functions that can be modeled by our deﬁnition of history transcript as described
in Section 2.

4.1 Proportional Reward Function R(prop)

One of the earliest reward functions that is still in use is the proportional reward
function. The idea is to divide the reward according to the proportion of shares
of a miner compared to all shares that were reported to the pool:

R(prop)

i

(b) =

bi
||b||1

.

8 In Appendix B we show that the possibility of another miner reporting a solution
does not materially change the characterization here and in Appendix C we extend
this to include the possibility of another pool reporting a full solution.

In expectation, the reward per share for each player is αi/D. This approach is
clearly proportional and budget-balanced. Previous work [4] has shown that in
the presence of multiple pools, miners can be incentivized to change pools after
a certain number of shares has been found. In this section we present a new
problem that exists even in the absence of other mining pools and means that
the proportional reward function is not incentive compatible.

Lemma 3. The proportional rule R(prop)

i

(b) = bi
||b||1

is not incentive compatible.

This result shows that the proportional reward function is not incentive com-
patible for a fundamental reason distinct from previous criticism. Even in the
absence of other pools, it does not always compel miners to report solutions
immediately. The intuition behind Lemma 3 is that if a player discovers a full
solution early but has been unlucky and reported a lower number of shares than
they would expect based on their mining power, it is in their incentive to delay
reporting their solution since on expectation their fraction of all reported shares
will go up. We can draw a number of corollaries immediately from Lemma 3:

– If the current ratio of blocks exceeds the expected ratio, then a player i

would report any full solution immediately.

– If the current ratio of blocks is lower than a player’s expected ratio, then

she might hold oﬀ to make up for this discrepancy.

– With fewer shares found, it’s easier for a player to catch up, hence she is

more willing to hold oﬀ reporting.

– After D shares have been found, any player will always report a full solution

immediately, even if she has not found a single share herself.

4.2 Per-Per-Share Reward Function R(pps)

The pay-per-share reward function pays a ﬁxed amount for every share that
is reported. Recall that each share is a full solution with probability 1/D, in
expectation the pool operator sees D shares for every full solution. Therefore
the payout per share is 1/D leading to the following reward function:

R(pps)(b) =

bi
D

.

It’s easy to see that pay-per-share is incentive compatible.

Lemma 4. The pay-per-share rule R(pps)

(b) = bi

D is incentive compatible.

Proof. The left hand side of (3) evaluates to

n(cid:88)

j=1

αj ·(cid:16)
(cid:18) bi + 1 − bi

R(pps)

i

i

(cid:19)

D

= αi ·
αi
D

=

(bt + ej) − R(pps)

i

+ (1 − αi) ·

(cid:17)
(cid:18) bi − bi

(bt)

(cid:19)

D

(cid:104)

Eb

R(pps)

i

D

(cid:105)

(b)

=

αi
D

.

and the right hand side evaluates to

(cid:117)(cid:116)
This result comes at no surprise: with pay-per-share there is no beneﬁt to de-
lay reporting a full solution as you receive a constant payment for every reported
share (or full solution). As discussed before though, it is not budget balanced.

(b) = bi

D is no better than (1/D,∞)-

Proposition 1. The pay-per-share rule R(pps)
budget balanced.

i

i=1 R(pps)

have been reported, then R(pps) pays out(cid:80)n

Proof. On one extreme, if a full solution is reported before any other shares
(b) = 1/D. On the other
extreme there is no bound on how many shares can be found before a full solution
must be obtained. Hence R(pps) cannot be (1/D, C)-budget balanced for any
ﬁnite C. Therefore it is (1/D,∞)-budget balanced.
(cid:117)(cid:116)
In the absence of sabotage attacks, with the pay-per-share rule the pool
operator pays out no more than it takes on on expectation, but keeping the
probability of bankruptcy low requires large reserves for the pool operator [4].
There are several variations that ameliorate the budget balance problem [4, Sec
4], none of them quite satisfactorily.

i

5 A New Incentive Compatible Reward Function

In the last section we saw that two common existing methods which are pos-
sible in our model both lack one of the desiderata for reward functions. The
proportional reward function may incentivize miners to delay reporting of so-
lutions, whereas the pay-per-share function may make the pool operator liable
for more than she receives from the protocol. In this section we demonstrate a
reward function that satisﬁes all three desiderata of reward functions, while still
guaranteeing a steady stream of rewards for all participants.

To satisfy the proportional payments property, it is necessary to estimate
the proportion of work that each miner has done. The only information the
pool operator receives within our informational model is the total number of
shares per miner in the round. When only a few shares have been found in
the round, every additional share may change this estimation quite signiﬁcantly.
When satisfying the budget-balanced property, this must translate into a large
change in the payout. When there is the possibility of a large payout for an extra
share, this may lead to incentive compatibility issues. Note that in practice pay-
per-share reward schemes usually avoid this problem by lowering the payment
amount in these cases. So to give a scheme that meets all three desiderata, we
need to take an additional estimator for αi into account. In the next subsection
we show that we can use the identity of the discoverer of the full solution as this
estimator.

5.1 The IC Reward Function
: Nn × {1, ..., n} → [0, 1], that in addition
We propose the reward function R(ic)
to a count of the shares per miner also includes the identity of the discoverer of
the full solution. In the following let 1{c} be the indicator function that is 1 if
c is true, and 0 otherwise.

i

(cid:19)

||b||1

max{||b||1, D}

(cid:16)

(cid:17)

R(ic)

i

(b, s) =

bi

max{||b||1, D} + 1{i = s} ·

1 −

There are two cases to consider for the reward function. The easiest is when
the total number of reported shares ||b||1 ≥ D. In that case
=
0, hence the reward function is identical to the proportional function. When
||b||1 < D each share receives a ﬁxed reward of 1/D, like in the pay-per-share
function. However, this would leave some money on the table as the total payout
would be ||b||1/D and ||b||1 < D. So the remainder of the reward is given to
the discoverer of the full solution.

max{||b||1,D}

1 −

||b||1

Lemma 5. The reward function R(ic) provides proportional payments.

Proof. We ﬁrst split the expression into the two relevant cases.

(cid:104)

(cid:105)

Eb

R(ic)

i

(b, s)

(cid:104)

(cid:105)

= Pr(||b||1 < D) · Eb

R(ic)
+ Pr(||b||1 ≥ D) · Eb

(b, s) | ||b||1 < D
R(ic)

(b, s) | ||b||1 ≥ D

i

i

(cid:105)

.

We now show that in both cases the expected reward for miner i is αi. When
||b||1 ≥ D the IC rule is no diﬀerent than the proportional rule, hence

Eb

R(ic)

i

(b, s) | ||b||1 ≥ D

= αi.

(cid:18)

(cid:104)

(cid:105)

(cid:104)

(cid:105)

i

(cid:104)
D−1(cid:88)
D−1(cid:88)
D−1(cid:88)

k=1

k=1

Eb

=

=

=

Now for the case where ||b||1 < D:

R(ic)

(b, s) | ||b||1 < D

Pr(||b||1 = k|||b||1 < D) ·

Pr(||b||1 = k|||b||1 < D) ·

Pr(||b||1 = k|||b||1 < D) · αi

(cid:18)E[bi|||b||1 = k]
(cid:18)
(cid:18) αi · k

D

+ αi ·

D

+ Pr(i = s) ·

(cid:19)(cid:19)

1 − k
D

(cid:19)(cid:19)

(cid:18)

1 − k
D

k=1

= αi

Here we used the fact that when a full solution is found, the probability that it
(cid:117)(cid:116)
was discovered by miner j is exactly its power αj.

i

R(ic)

(bt + ej, i) − R(ic)

αj ·(cid:16)
(cid:19)
(cid:18) bi + 1 − bi
(cid:18)||b||1 + 1
+ (1 − αi) ·
− ||b||1

(cid:19)

D

i

D

D

(cid:17)
(cid:18) bi − bi

(bt, i)

D

n(cid:88)

j=1

= αi ·

=

−
αi
D
αi − 1

(cid:19)

(cid:18)

+

(cid:19)

(cid:18)

−

1 − ||b||1

D

(cid:19)

1 − ||b||1 + 1

D

Theorem 1. The reward function R(ic) is incentive compatible.

Proof. By Lemma 5, the right-hand side of condition (3) is αi/D. Now for the
left-hand side; if ||b||1 ≥ D the rule is identical to R(prop), so the left-hand side
is at most αi/D, hence condition (3) holds in this case. So the only case left to
prove is when ||b||1 < D.

D

=
≤ 0
So when ||b||1 < D the miner is expected to lose utility by delaying, and certainly
condition (3) holds. So in all cases condition (3) holds, hence by Lemma 1 R(ic)
(cid:117)(cid:116)
is incentive compatible.

So R(ic) satisﬁes proportional payments and incentive compatibility. Finally,

it is also a (1, 1)-budget balance reward function.

Proposition 2. R(ic) is a (1, 1)-budget balanced reward function.

Proof. When ||b||1 < D the total payout is (cid:80)

D +(cid:80)
= 1. When ||b||1 ≥ D the total payout is(cid:80)

||b||1
D + D−||b||1

i=1

i=1

i=1

bi

D

bi

D + D−||b||1
D
||b||1
bi
||b||1
||b||1

=

=

= 1.(cid:117)(cid:116)

5.2 Providing a Steady Payment Stream

While R(ic) satisﬁes all three desiderata for reward functions, it might be a con-
cern that the reward function pays out a potentially large fraction of the reward
to a single miner. Miners join a pool because they prefer a steady stream of small
payments over periodic large payments. We show here that the majority of the
reward is paid out for shares and not full solutions, and hence that the majority
of the pool’s rewards are redistributed in a steady stream. This ameliorates a
large part of the problem of mining alone, while guaranteeing incentive compat-
ibility. In the Section 7 we give simulation results suggesting that this payment
stream is suﬃciently steady in practice.
Lemma 6. In expectation, a fraction 1 − e−1 ≈ 0.63 of the rewards are given
based on shares under R(ic).

Proof. The fraction of the reward given to the discoverer of the full solution is

Pr(||b||1 = k) ·

1 − k
D

=

·

1
D

1 − 1
D

1 − k
D

D−1(cid:88)

k=1

(cid:18)

(cid:19)

(cid:18)

(cid:19)k−1 ·

(cid:19)

D−1(cid:88)
(cid:18)

k=1

(cid:18)
(cid:19)D

1 − 1
D

=
≤ e−1

payout to shares in expectation is 1 − e−1 ≈ 0.63.

The remainder of the reward is split among the reported shares, hence the
(cid:117)(cid:116)

6

Incentive Compatibility of Pay-Per-Last-N-Shares

In previous sections we have given an overview of incentive compatibility for any
reward function based on access to a history transcript H consisting of a count
of all reported shares. By deriving incentive compatibility at this high level of
abstraction allowed us to easily prove incentive compatibility for any function
within this informational model.

In this section we look at incentive compatibility of a particular reward
function that require a more general
informational model: the Pay-Per-Last-
N -Shares (PPLNS) reward function, that is widely used in practice. We ﬁrst
discuss the required changes in the informational model, and how the PPLNS
function works, and then we show that the function is incentive compatible.

6.1 The PPLNS Reward Function

The PPLNS reward function R(pplns) diﬀers from the reward functions seen so
far in two important ways. Firstly, it maintains a history of reported shares that
spans multiple rounds. So what happens in round T is no longer isolated from
what happens in round T + 1. Secondly, the method takes the order of reported
shares into account in a speciﬁc way: it maintains a sliding window of length
N and divides the reward proportionally over these N shares. So the history
transcript H that R(pplns) uses is s = [st−N , st+1−N , ..., st] (an ordered list of N
elements) and the reward function is:

R(pplns)(s) =

#{sj : sj ∈ s ∧ sj = i}

N

Since the order of reports matter, we say that shares fall into slots. Each slot
states if the report contains either a full solution or a share, and who the miner
was that reported it.

6.2 Incentive Compatibility of PPLNS

We do not have a general condition under which reward functions in this infor-
mational model are incentive compatible, so we argue incentive compatibility di-
rectly. In this section we consider both reporting of shares as well as full solutions.
For each, we consider a binary strategy space: either report the share/solution
immediately, or delay reporting until one more share is found.9

Lemma 7. For the reward function R(pplns); a miner i reports shares immedi-
ately when her mining power αi < 1 − D
N .

In the previous section there were potential beneﬁts, and harms to delaying
the report of a share, but there was no opportunity cost. Since miner i did not
have a full solution, her delay did not cause unnecessary work for all miners in
the pool. For full solutions we have to take the opportunity cost of letting all
miners work on a block for which a full solution is already found into account.
This will guarantee incentive compatibility whenever N > D.

Lemma 8. For the reward function R(pplns); a miner i reports full solutions
immediately when N ≥ D.

7 Simulations

The typical way to compare diﬀerent reward function is to look at the variance
of payout for a single share [4], with a lower variance considered better. However,
the raw variance can be quite misleading for a reward function like R(ic) which
allocates some revenue in a steady stream and some in a lumpy stream, assigning
a variance almost as high as solo mining.

In Figure 1a we plot the time it takes for a miner to gain a given number of
bitcoins with 99% certainty. We run a simulation for a miner i with αi = 0.001,
D = 1, 000, 000. A unit of time corresponds to the expected time it takes for
all miners combined to ﬁnd a full solution (in reality this is about 10 minutes)
and we normalize the reward for ﬁnding a full solution to be B 1 (in reality this
currently about B 25, although it changes over time). The lines indicate for each
of three reward functions how long one has to wait to gain a given amount of B
with 99% probability. First of all, observe that for solo mining the time is about
4500 rounds and it does not increase with time. This is because whether a miner
wants to obtain B 0.001, or B 0.9, they have to ﬁnd a full solution to reach this
target. So the blue line really indicates the time it takes to ﬁnd a full solution.
Even though in expectation this takes 1000 rounds (for αi = 0.001), in 1% of
cases a miner has to wait in excess of 4500 rounds.

It can be seen that the incentive compatible scheme requires somewhat longer
to reach the same target than the proportional scheme. This is because not all
reward is shared according to the reported shares, but is partly distributed over

9 This makes our results slightly less general in this setting than for the reduced

information setting, where the miner could delay for any delay d.

(a) 99th percentile time to earn rewards

(b) CDF of time to earn B 0.1

Fig. 1: Simulation results for our new incentive-compatible reward function.

the discoverers of full solutions. However, no matter what the target is, the
diﬀerence in time required diﬀers no more than a small multiplicative factor.
Finally, note that since it takes longer to reach targets with high probability, the
expected payouts between all three functions is the same.

In Figure 1b we plot the CDF of the time needed to earn B 0.1. With over-
whelming probability R(prop) pays out at least B 0.1 within 150 rounds, and R(ic)
pays out at least B 0.1 within 200 rounds. Solo mining does not ﬁt on this scale
and it wouldn’t be until around round 7,000 before a miner makes at least B 0.1
with overwhelming probability.

Fig. 2: Comparison of the new incentive compatible scheme to PPLNS.

We compare the new incentive compatible scheme to the PPLNS scheme in
Figure 2. Here we can see that the new incentive compatible scheme performs
worse by a small multiplicative factor, the PPLNS scheme performs worse by
a small additive factor. This means that for small Bitcoin targets it would be

faster to use the IC reward function, whereas for larger target the PPLNS reward
function performs better.

From these simulations we can conclude that the trade-oﬀ for using the incen-
tive compatible or PPLNS reward function compared to the proportional reward
function is a modest delay in the time it would take miners to reach a minimal
amount of bitcoin with high probability. In return we get a scheme in which it
is obvious for miners what the most proﬁtable strategy for them is.

8 Conclusions & Open Problems

We set out with a simple question: as a mining pool operator, in the absence of
other mining pools or outside options, which reward functions will incentivize
miners to report full solutions immediately? In this simple model it would be rea-
sonable to assume that miners always have an incentive to report immediately.
However, we show that for proportional rewards, there are situations in which
miners prefer to hold on to a full solution temporarily in order to improve their
payout, harming the entire pool in the process. We also deﬁned a novel reward
function that is incentive compatible in this model (and remains so even in more
powerful models). While this new scheme is not quite as eﬃcient as proportional
rewards in terms of smoothing the miners’ revenue streams, it comes reasonably
close in practice. We have also showed that the PPLNS reward function is in-
centive compatible. For a pool operator there are some tradeoﬀs in deciding to
use our new incentive compatible scheme versus the PPLNS scheme. The latter
requires a certain lead-up time, where the rewards to miners are below their
fraction of the mining power. It also requires pool operators to maintain a more
complex state and the payouts are arguably somewhat less transparent. On the
other hand, our new incentive compatible method sometimes pays out a rather
large amount to the discoverer of the full solution.

We have given a ﬁrst informational model for which we can characterize
incentive compatibility for all reward functions that fall in the model. We’ve also
looked at a particular reward function that falls outside this model, and proved
incentive compatibility from ﬁrst principles. The next enticing question is to see
if we can characterize incentive compatibility in this larger informational model
at a high level, so that we can quickly identify which other reward functions
would be incentive compatible. There are many reward functions in use today
[4] that are not covered by any of our results. For example, the Geometric Method
weights shares diﬀerently according to the order of shares in a round and Slush’s
Method takes the time of reported shares in a round into account. Deﬁning
a common informational model, characterizing incentive compatibility in this
model, and classifying these methods remains an interesting open problem.

We stress that our incentive-compatible reward function will remain so even
in a model with more extensive history transcripts. Our goal was to introduce
the ﬁrst rigorous, although simpliﬁed by omitting notions of time or order of
share reporting, model of Bitcoin mining pools and demonstrate that even this
simple model can lead to non-intuitive results.

References

1. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Consulted,

1(2012):28, 2008.

2. Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A. Kroll,
and Edward W. Felten. Research Perspectives and Challenges for Bitcoin and Cryp-
tocurrencies. In 2015 IEEE Symposium on Security and Privacy, May 2015.

3. Andrew Miller, Elaine Shi, Ahmed Kosba, and Jonathan Katz. Nonoutsourceable

Scratch-Oﬀ Puzzles to Discourage Bitcoin Mining Coalitions (preprint), 2014.

4. Meni Rosenfeld. Analysis of bitcoin pooled mining reward systems. arXiv preprint

arXiv:1112.4980, 2011.

5. Ittay Eyal. The Miner’s Dilemma. In IEEE Symposium on Security and Privacy,

2015.

6. Aron Laszka, Benjamin Johnson, and Jens Grossklags. When Bitcoin Mining Pools
Run Dry: A Game-Theoretic Analysis of the Long-Term Impact of Attacks Between
Mining Pools. In Workshop on Bitcoin Research, 2015.

7. Benjamin Johnson, Aron Laszka, Jens Grossklags, Marie Vasek, and Tyler Moore.
Game-theoretic analysis of DDoS attacks against Bitcoin mining pools. In Workshop
on Bitcoin Research, 2014.

8. Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vulnerable.

In Financial Cryptography, 2014.

A Proofs

A.1 Proof of Lemma 1

For a reward function R, a player i has an incentive to report full solutions
immediately, iﬀ the following condition holds for all {αi}n

i=1, bt, D, i:

αj · (Ri(bt + ej) − Ri(bt)) ≤ Eb [Ri(b)]

D

(4)

n(cid:88)

j=1

Proof. (⇒) This direction is straightforward: when it is beneﬁcial to delay until
1 more share is reported, then there exists a proﬁtable delay (namely d = 1).

(⇐) We need to prove that for all d, the following inequality holds:

Pr(seeing b) · (Ri(bt + b) − Ri(bt)) ≤ d
D

Eb [Ri(b)] .

(cid:88)

b s.t. ||b||1=d

We prove this by induction on d, where the induction hypothesis is equation (2).
For the base case d = 1 the statement follows directly from condition (3). So
consider the case d > 1:

b s.t. ||b||1=d

Pr(seeing b) · (Ri(bt + b) − Ri(bt))

Ri(bt + ej) − Ri(bt)

Pr(seeing ej)

+

Pr(seeing b) · (Ri(bt + ej + b) − Ri(bt + ej))



(cid:88)
(cid:88)

=

ej

≤ 1
D

≤ 1
D

=

d
D

(cid:88)
(cid:88)

b s.t. ||b||1=d−1
Eb [Ri(b)]

(cid:88)

ej

ej

Eb [Ri(b)] +

Eb [Ri(b)]

+

Pr(seeing ej)

Pr(seeing b) · (Ri(bt + ej + b) − Ri(bt + ej))

(cid:88)

b s.t. ||b||1=d−1

Pr(seeing ej)

d − 1
D

Eb [Ri(b)]

where the ﬁrst inequality follows from condition (3), and the second from the
(cid:117)(cid:116)
induction hypothesis.

A.2 Proof of Lemma 2

Miners report shares immediately if and only if the reward function R is mono-
tonically increasing each component. That is: for all i, and b:

Ri(b + ei) > Ri(b).

Proof. Since the order or timing of shares does not matter, for analysis purposes
we can assume the following scheme: as soon as a full solution is reported the pool
operator asks all miners for the shares that they found. If the reward function R
is monotonically increasing then each additional share that i reports increases
her share, hence she will report all shares. Conversely, if R is not monotonically
increasing at some b, then if miner i has bi + 1 shares, and all other miners have
reported shares according to b, then she will not report her last share.

Now consider the original problem: when a miner ﬁnds a share, will she report
it immediately? If she ﬁnds a share and the reward function is monotonically
increasing, then reporting it immediately can only increase her reward, whereas
delaying it may mean that someone else reports the full solution before she
reports her share, in which case she loses the opportunity to report. Thus she
(cid:117)(cid:116)
will report immediately.

A.3 Proof of Lemma 3

The proportional rule R(prop)

i

(b) = bi
||b||1

is not incentive compatible.

Proof. Instantiate (3) for the proportional rule. For the right hand side we have:

(cid:104)

Eb

R(prop)

i

(b, s)

Pr[full solution is found at kth block]

E[bi|k]

k

(cid:19)k−1 1
(cid:19)k−1 1

D

D

1 − 1
D

1 − 1
D

k · αi
k

Now for the left hand side. In the following let k = ||bt||1:

(cid:17)

(bt + ej) − R(prop)

(bt)

i

(cid:18) bi

(cid:19)

k + 1

− bi
k

k=1

∞(cid:88)
∞(cid:88)
∞(cid:88)

k=1

k=1

(cid:18)
(cid:18)

(cid:105)

/D =

=

=

=

1
D

1
D

αi
D
αi
D

n(cid:88)

j=1

αj ·(cid:16)
(cid:18) bi + 1

i

R(prop)

(cid:19)

= αi ·

k + 1

αibi + αi + bi − αibi

+ (1 − αi) ·
− bi
k

(cid:19)

− 1
k

=

=

=

=

=

k + 1
− bi
k

(cid:18) 1

+ bi

k + 1
bi

k(k + 1)

αi + bi
k + 1
αi

k + 1

αi

−
k + 1
αi − bi
k
k + 1

Recall that for an incentive compatible scheme we need:

αi − bi
k
k + 1
αi − bi
k
bi
k

≤ αi
D
≤ αi
≥ αi

k + 1

(cid:18)

D
1 − k + 1
D

(cid:19)

.

This condition is not guaranteed to be satisﬁed. In particular, for every αi > 0
(cid:117)(cid:116)
there exist positive values bi, k, D such that the condition is violated.

A.4 Proof of Lemma 7

For the reward function R(pplns); a miner i reports shares immediately when her
mining power αi < 1 − D
N .

Proof. We directly calculate the expected revenue for delay versus reporting.
When the miner decides to delay reporting a share until one more share/solution
is found, she aims to move the sliding window of slots for which the share is
eligible to receive reward one further into the future. This means that –as long
as no other miner ﬁnds a full solution and reports it– the share is active for N −1
of the same slots, so any reward she receives from full solutions in those slots
she will get regardless of her choice to report immediately versus delaying. On
the upshot, it could be the case that the one additional slot she’s eligible for in
the future yields a full solution. This will happen with probability 1/D (since a
share constitutes a full solution with probability 1/D) and in that case the share
gets an extra payout of 1/N for the delayed share, yielding an expected beneﬁt
for delaying of 1/N D.
However, there is also a risk associated with delaying. With probability 1−αi
a share will be found by a diﬀerent miner, and with probability 1/D it will
constitute a full solution. When this happens, miner i will no longer be able to
report the share as it was discovered for a previous round. The expected value
per share is 1/D (as it’s active for N rounds, in which in expectation N/D full
solutions will be reported for a value of 1/N each) hence the expected harm for
delaying the report is (1 − αi) 1
D2 .
N leads to (1 − αi) · 1
D2 ≥ D

So the miner will report the share immediately iﬀ 1

D2 = 1

N D < (1−αi)· 1

D2 . Plugging
N D so the condition holds, and
(cid:117)(cid:116)

in αi < D
miners report shares immediately.

N · 1

A.5 Proof of Lemma 8

For the reward function R(pplns); a miner i reports full solutions immediately
when N ≥ D.

Proof. In delaying a full solution, the hope is to get another share to report before
the miner reports the full solution. This happens with probability α1 · D−1
D (we
need the share to not be a full solution) and the additional value to this share
would be 1
N compared to it being reported after the full solution. However, while
waiting for a share, with probability 1
D the next share will be a full solution,
either found by miner i, or one of the other miners. Regardless of who ﬁnds
the solution, the previous full solution that miner i was sitting on has become
worthless: either a diﬀerent miner reported the full solution ending the round
and thus making the delayed full solution worthless, or miner i now has 2 full
solutions of which she can report only one. When this happens, she loses the
solution whose expected value is 1/D (as this is counted as a share for future).
1
N and the expected
So the expected upshot for delaying the solution is α1
harm is 1

D−1
D

D2 .

In addition to this, when the miner chooses to delay until one more share
is found, she lets all miners in the pool work on a block for which she already
has a solution. If everyone were to spend that eﬀort on a new block, that work
would in expectation constitute 1/D of the work for a new block, of which in
expectation miner i would receive αi of the reward. Thus, the opportunity cost is
D2 ≤
αi
D . Therefore, a miner will report a full solution immediately iﬀ αi
D which holds whenever N ≥ D.
αi

N − 1

D−1
D

1

B Incentive Compatibility When Other Miners Can Find

a Block Before You Report

In Section 3 we showed that there is a simple condition that precisely charac-
terizes when a reward function R is incentive compatible, under the assumption
that no other miner ﬁnds and reports a full solution during this delay. In reality
a miner does have to take this possibility into account, so in this section we show
exactly how the IC condition changes when we drop this assumption.

If we decide to delay reporting the full solution until one additional share is
found, then with probability 1/D that share will actually be a full solution itself.
Without loss of generality we may assume that this solution will be reported
immediately (otherwise we could simply ignore its eﬀect). Recall that bt is the
number of reported shares per miner including the unreported full solution that
miner i has, and that ej is the vector that has zeros everywhere except its jth
component, where it is 1. So the expected payout for delaying for one round
becomes:

1
D

αjRi(bt − ei + ej) +

D − 1
D

αjRi(bt + ej)

(cid:88)

j

(cid:88)

j

(cid:88)

j

1
D
D − 1
D

(cid:88)

j

+

Thus the condition of incentive compatibility is:

αj (Ri(bt − ei + ej) − Ri(bt))

αj (Ri(bt + ej) − Ri(bt)) ≤ Eb[Ri(b)]

D

For the reward functions that are monotonic increasing in each component
(which by Lemma 2 are precisely the reward functions where miners always
report all shares) this additional term is negative. Therefore, the IC condition
is only easier to satisfy. This means that reward functions that are proven to
be incentive compatible using Lemma 1 are still incentive compatible. However,
one might worry that our proof that the proportional reward function is not in-
centive compatible might break. We show next that the thread of being scooped
actually does not impact the result qualitatively.

B.1 Proportional

For the proportional reward function we can instantiate the left-hand side as
(taking ||bt||1 = k):

(cid:18)

(cid:18) bi
(cid:18)

(cid:19)
(cid:18) bi + 1

− bi
k

k

1
αi
D
D − 1
αi
D
1 − αi

1
D

+

k

+

=

+ (1 − αi)

(cid:19)

− bi
k
αi − bi
k
k + 1

k + 1
D − 1
D

(cid:18) bi − 1

k

+ (1 − αi)

(cid:19)(cid:19)
(cid:18) bi

− bi
k

k + 1

(cid:19)(cid:19)

− bi
k

So the proportional reward function is IC if and only if

1 − αi

k

D − 1
D

αi − bi
k
k + 1

+

1
D

≤ αi
D

.

Again this is not guaranteed to be satisﬁed, in fact the same parameters as last
time, i.e. bi = 2, k = 10, αi = 1/2 and D = 20. So including the possibility of
another miner ﬁnding a full solution does not qualitatively change the incentive
compatibility results, although quantitatively there may be situations where a
miner would choose to delay if she does not fear being scooped, but choose to
report if she does include this possibility.

C Multiple Pools

let(cid:80)n

In the main text we’ve assumed that there are no other pools that compete
for ﬁnding solutions to the cryptographic puzzle. This is reasonable from the
perspective of proving positive results: any incentive compatible scheme should
be incentive compatible regardless of how much mining power other pools have.
However, to convincingly reject the proportional rule as not incentive com-
patible, we should take the eﬀect of other pools into account. In the following
i=1 αi = αP < 1 be the total mining power of the pool, so all other mining
power —of both other pools and solo miners— is 1 − αP . For notational sim-
plicity we do not consider being scooped by a diﬀerent miner in our own pool;
it’s obvious how this can be included by comparing the results to the one in
Appendix B. When we consider to delay reporting a full solution until one more
share is found —either inside or outside the pool— then our expected utility for

doing so is (cid:88)

j

αjRi(bt + ej) + (1 − αP )

(cid:18) 1

D

(cid:19)

· 0 +

D − 1
D

Ri(bt)

.

We don’t really care if some other pool ﬁnds another share. This does not aﬀect
us. But if another pool ﬁnds a full solution and reports it, then our mining pool

misses out on a complete payment that it could have received. So the condition
for incentive compatibility becomes

αj · (Ri(bt + ej) − Ri(bt)) − (1 − αP )

Ri(b)

D

≤ αP

Eb [Ri(bt)]

D

.

n(cid:88)

j=1

Under the assumption that the pool in expectation will collect αP of the
of the pool she is in,
D . The new term on the left-hand side is simply

total reward among pools, and that miner i collects αi
αP
the right-hand side will remain αi
(1 − αP ) bi

kD . The other term on the left-hand side changes slightly:

(bt + ej) − R(prop)

i

(bt)

(cid:17)
(cid:19)

(cid:18) bi

k + 1

− bi
k

n(cid:88)

j=1

αj ·(cid:16)
(cid:18) bi + 1

i

R(prop)

(cid:19)

= αi ·

k + 1

αibi + αi + αP bi − αibi

+ (αP − αi) ·
− bi
k

=

=

αi + αP bi

k + 1

k + 1
− bi
k

.

This cannot be simpliﬁed to the same convenient expression we had in Sec-
tion 3. Combining these terms the condition for incentive compatibility of the
proportional reward function becomes:

αi + αP bi

k + 1

− bi
k

− (1 − αP )

bi
kD

≤ αi
D

and after rewriting this:

αi

k + 1

+ αP bi

(cid:18) 1

kD

(cid:18)

(cid:19)

− bi
k

1 +

1
D

(cid:19)

≤ αi
D

+

1

k + 1

