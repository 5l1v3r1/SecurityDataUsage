Elligator: Elliptic-curve points

indistinguishable from uniform random strings

Daniel J. Bernstein1,4

djb@cr.yp.to

Mike Hamburg2

mhamburg@cryptography.com

Anna Krasnova3

anna@mechanical-mind.org

Tanja Lange4

tanja@hyperelliptic.org

1Department of Computer Science, University of Illinois at Chicago, USA

2Cryptography Research, a division of Rambus, USA

3Privacy & Identity lab, Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands

4Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands

ABSTRACT
Censorship-circumvention tools are in an arms race against
censors. The censors study all traﬃc passing into and out
of their controlled sphere, and try to disable censorship-
circumvention tools without completely shutting down the
Internet. Tools aim to shape their traﬃc patterns to match
unblocked programs, so that simple traﬃc proﬁling cannot
identify the tools within a reasonable number of traces; the
censors respond by deploying ﬁrewalls with increasingly so-
phisticated deep-packet inspection.

Cryptography hides patterns in user data but does not
evade censorship if the censor can recognize patterns in the
cryptography itself. In particular, elliptic-curve cryptogra-
phy often transmits points on known elliptic curves, and
those points are easily distinguishable from uniform random
strings of bits.

This paper introduces high-security high-speed elliptic-
curve systems in which elliptic-curve points are encoded so
as to be indistinguishable from uniform random strings. At
a lower level, this paper introduces a new bijection between
strings and about half of all curve points; this bijection is
applicable to every odd-characteristic elliptic curve with a
point of order 2, except for curves of j-invariant 1728. This
paper also presents guidelines to construct, and two exam-
ples of, secure curves suitable for these encodings.

Categories and Subject Descriptors
E.3 [Data encryption]: Public key cryptosystems

Keywords
Censorship circumvention; elliptic curves; injective maps

1.

INTRODUCTION

Elliptic-curve cryptography (ECC) is arguably the most
important tool in modern public-key cryptography. It pro-
vides public-key encryption, signatures, non-interactive key

Acknowledgments: This work was supported by the National Science Foundation under  grant 
1018836, by the Netherlands Organisation for Scientific Research (NWO)  under grants 
639.073.005 and 040.09.003, by the National Science Council of Taiwan  under NSC 101-2915-
I-001-019, by the European Commission under Contract  ICT-2007-216676 ECRYPT II, and by 
SIDN.nl (http://www.sidn.nl/). Part of  this work was done while Bernstein, Krasnova, and Lange 
visited Academia Sinica;  they wish to thank Bo-Yin Yang for his hospitality. Permanent ID of 
this document:  711e2f8601805e06e5fbb3c5953dd5d1. Date: 2013.08.28.

Permission to make digital or hard copies of part or all of this work for personal or classroom 
use is granted without fee provided that copies are not made or distributed for profit or 
commercial advantage and that copies bear this notice and the full citation on the first page. 
Copyrights for third-party components of this work must be honored. For all other uses, contact 
the Owner/Author.
Copyright is held by the owner/author(s).
CCS'13, Nov 04-08 2013, Berlin, Germany
ACM 978-1-4503-2477-9/13/11.
http://dx.doi.org/10.1145/2508859.2516734.

exchange, and many higher-level security features. It oﬀers
an attractive combination of high security, high speed, and
(often critical for deployment) small space consumption.

However,

for applications in censorship circumvention,
ECC has a security problem. ECC protocols naturally send
elliptic-curve points in the clear as long-term public keys,
ephemeral public keys, ciphertext preﬁxes, challenges, etc.
These points, even in compressed form, are obvious: they
are easy to distinguish from uniform random strings.

There have been some ad-hoc workarounds for this prob-
lem, notably for ElGamal ciphertext preﬁxes, using a curve-
or-twist technique introduced by M¨oller (see below). But
each new ECC-based protocol faces the same problem. Pro-
tocol designers unaware of the issue continue building pro-
tocols that are trivially visible to attackers. Designers re-
quiring keys and ciphertexts to be indistinguishable from
uniform are forced to modify those protocols, hoping that
the modiﬁcations do not compromise other forms of security.
The main goal of this paper is to eliminate this prob-
lem. The solution presented here works for a wide range of
elliptic-curve protocols, essentially every protocol in which
the transmitted curve points are generated at random.
There is no longer any need for, e.g., ad-hoc handling of
ciphertext preﬁxes; this paper’s technique works for all of
the types of elliptic-curve points mentioned above.

1.1 Distinguishers

We use the standard NIST P-256 elliptic curve as an ex-
ample to illustrate the diﬃculties. A public key on the
NIST P-256 elliptic curve is a pair (x, y) of integers sat-
isfying the equation y2 = x3 − 3x + b modulo the prime
2256 − 2224 + 2192 + 296 − 1, where b is a standard constant.
There are at least three obvious ways for an attacker to dis-
tinguish this public key from a uniform random string:

• Least severe: Normally x and y are represented as
integers between 0 and 2256 − 2224 + 2192 + 296 − 2
inclusive, encoded as 256-bit strings. If the attacker
sees a 256-bit string representing an integer larger than
2256 − 2224 + 2192 + 296 − 2 then the attacker knows
that the string is not a valid value of x or of y. If the
attacker sees a user sending a series of (e.g.) 235 256-
bit strings, and the largest string is close to 2256−2224,
then the attacker is reasonably conﬁdent that the user
is sending curve points. See Section 2.6 for details.

One can dismiss this attack as being too slow to be
of interest, but we prefer more robust cryptographic

967primitives that maintain security with heavy use. The
user can cover all integers between 0 and 2256 − 1 by
randomizing the representations of small integers x
and y, but this adds very little security: the attacker
easily collects statistics showing that some integers ap-
pear half as often as others.

A secure solution is to randomly represent x and y as
integers between 0 and, e.g., 2320 − 1. Another secure
solution, with smaller keys, is to switch to an elliptic
curve using a prime much closer to a power of 2, such as
NIST P-224 (prime 2224 − 296 + 1, lower security level)
or Bernstein’s Curve25519 from [6] (prime 2255 − 19).
• More severe: The attacker simply checks the curve
equation. If a 512-bit string has the form (x, y) where
y2 = x3 − 3x + b modulo this prime then the attacker
is conﬁdent that the user is sending a public key.

one (random-looking) bit: the sign in ±√

Many ECC systems save space by compressing y to
x3 − 3x + b.
Some ECC systems save space by eliminating y en-
tirely. The cost for the legitimate user of computing a
square root is almost always outweighed by the beneﬁt
of reducing keys to half size. Both of these mechanisms
have the side eﬀect of stopping this attack.

• Most severe: The attacker checks whether x3 − 3x + b
is a square modulo this prime. This has chance 1/2 of
occurring for a uniform random string, but if it occurs
repeatedly then the attacker is reasonably conﬁdent
that the user is sending public keys.

The third attack is diﬃcult to stop. Our solution requires a
quite drastic change in how curve points are represented as
strings; this representation is the main topic of this paper.
Our solution is not limited to public keys: it also protects
other randomly generated elliptic-curve points, such as the
points appearing in ciphertexts in elliptic-curve versions of
the ElGamal encryption system and points appearing in sig-
nature systems. See Section 2.
1.2 Previous work

Several years ago, in [40], M¨oller proposed a variant of the
ElGamal encryption system that provides indistinguishabil-
ity for ciphertexts as follows:

• Alice’s public key is a pair (aP, a(cid:48)P (cid:48)) where a and a(cid:48)
are secret integers, P is a standard base point on an
elliptic curve E(F2n ) over some binary ﬁeld F2n , and
P (cid:48) is a standard base point on a nontrivial quadratic
twist E(cid:48)(F2n ) of the same curve.

• To encrypt a message m using public key (aP, a(cid:48)P (cid:48)),
Bob chooses a random integer b, chooses randomly be-
tween aP and a(cid:48)P (cid:48), sends the x-coordinate of bP or
bP (cid:48) respectively, hashes b(aP ) or b(a(cid:48)P (cid:48)) respectively
to obtain a secret key, and sends an encryption of m
using this secret key.

• Alice recovers bP or bP (cid:48) from the x-coordinate. Alice
multiplies bP or bP (cid:48) by a or a(cid:48) to obtain abP or a(cid:48)bP (cid:48),
hashes it to obtain the same secret key, and decrypts
the message. M¨oller requires Alice to perform tests to
decide whether the input is on E or on E(cid:48) and to re-
cover the whole point bP or bP (cid:48). We comment that the
“Montgomery ladder” handles both cases together if a(cid:48)
is chosen as a. (For Montgomery-ladder background

see [41], [16], and, for the binary case, [39].) This
eliminates the need for such tests and oﬀers eﬃcient
curve arithmetic.

The idea in M¨oller’s proposal is that each element of F2n is
a valid x-coordinate on E or its twist. The x-coordinate sent
here can therefore be any element of F2n , and in fact the dis-
tribution of the x-coordinates is indistinguishable from the
uniform distribution of n-bit strings. M¨oller slightly adjusts
the choices so that the distribution is exactly uniform.

Young and Yung present in [49] a modiﬁed version of
M¨oller’s twist idea to achieve DDH security in the stan-
dard model. In their version Alice’s public key consists of
M points on each curve; Bob picks one of the curves and
computes shared secrets with all M points on that curve.
The shared key of length M is derived taking just one bit
per DH shared secret.

Our approach encodes points on a single curve as strings
indistinguishable from uniform random strings. This has
several obvious advantages over M¨oller’s system. We ob-
tain indistinguishability not just for ciphertexts but also for
public keys. M¨oller’s system has double-length public keys,
while our public keys have minimal length. M¨oller’s ap-
proach is limited to ElGamal encryption, while our approach
handles a much wider range of ECC systems; see Section 2.
M¨oller needs cryptographic security not just for E but also
for E(cid:48); in our system twist security is not required, although
we still suggest it as a desirable feature (see Section 4). Since
our proposal does not need to work with twists, achieving
solutions in the standard model can be done simply using
the standard methods.
1.3 Application context

M¨oller’s curve-or-twist approach is used in StegoTorus
[47]. StegoTorus is an extension to Tor [19] for censorship
circumvention. It makes Tor traﬃc resemble Skype, general
HTTPS traﬃc, etc. and relies on secure communication with
a StegoTorus server. Establishing a link with this server re-
quires deriving temporary key material using the public key
of the server. This key material is used to encrypt com-
munication of a subsequent ephemeral DH key exchange.
StegoTorus uses M¨oller’s example parameters over F2163 .

For comparison, typical ECC protocols carry out a DH
key exchange in the clear; see, e.g., the ntor example below.
StegoTorus needs to encrypt its key exchange because the
points sent in the key exchange are easily distinguishable
from uniform random data. This encryption adds the outer
M¨oller layer, doubling the space used for the initial commu-
nication. This also slows down the client, slows down the
server, doubles the size of server public keys (one point on
the curve, one point on the twist), and requires implemen-
tations to handle computations on two curves.

We eliminate all of these issues by solving the underlying
problem, namely the point distinguishability. The points
that we send in a DH key exchange are indistinguishable
from uniform random strings. See Sections 2, 3, and 5.

Telex [48] is another censorship-circumvention tool. Telex
messages pose as regular TLS messages to random uncen-
sored sites; the only diﬀerence is that the nonce ﬁeld contains
a cryptographic value instead of a random value. The public
key of the Telex server is a pair of points (aP, aP (cid:48)), with P
on an elliptic curve E(Fq) and P (cid:48) on a nontrivial quadratic
twist. Telex servers use deep-packet inspection on all traﬃc
passing through them and identify Telex messages by check-

968ing whether the nonce ﬁeld interpreted as α||β satisﬁes the
Interpret α as the x-coordinate of a
following conditions.
point R on E or E(cid:48) and compute aR on the appropriate
curve. Identify the message as a Telex message if β matches
a salted hash of aR, and route it according to some other,
encrypted information.

The use of curves in Telex follows M¨oller’s proposal except
for the choice of ﬁnite ﬁeld and the choice of equal secrets.
The proposed parameters have q = 2168 − 28 − 1 so that
the distribution of values in Fq is indistinguishable from
that of length-168 strings. The attempted decryption per-
forms a complete point recovery from x and uses standard
Weierstrass-curve arithmetic to compute the scalar multipli-
cations. We comment again that the “Montgomery ladder”
is more eﬃcient, handling both cases together. We also com-
ment that the system could use somewhat larger ﬁnite ﬁelds,
gaining security, without reducing the 56-bit hash size and
without going beyond the standard TLS 224-bit nonce size:
servers would allow only points R with a ﬁxed number of
implicit trailing zeros, and clients would repeatedly gener-
ate points until meeting that condition.

This paper’s solution to the point-distinguishability prob-
lem would not save bandwidth for Telex connections but
would still simplify implementations, removing any need to
handle the twist, and would reduce public keys to half size,
potentially a useful feature for small clients keeping track of
many diﬀerent Telex servers.

As a third protocol we consider ntor [30], a handshake
protocol proposed for Tor achieving anonymity and one-way
authentication with forward secrecy. This protocol assumes
that Tor relays have public keys on an elliptic curve. The
following is a simpliﬁed version of the ntor protocol, skip-
ping certiﬁcates and saved session states, but presenting
all parts relevant to the choice of curve group and repre-
sentation. To extend a Tor circuit to a relay with pub-
lic key B = bP a client picks a random value x, com-
putes X = xP , and sends X to the server. The server
picks a random y, computes Y = yP , computes two se-
cret keys as k(cid:48)||k = H(yX, bX, B, X, Y ) for some hash func-
tion H, computes tB = MACk(cid:48) (B, X, Y ) (an authentica-
tor under key k(cid:48)), and sends Y ||tB to the client. The
client computes ¯k(cid:48)||¯k = H(xY, xB, B, X, Y ) and veriﬁes that
tB = MAC¯k(cid:48) (B, X, Y ). If the veriﬁcation is successful, the
client is convinced that it is communicating with the correct
server: nobody other than the client and the relay could
compute xB = bX. Both sides can use k = ¯k for transmit-
ting encrypted messages.

Tor currently uses SSL links to superencrypt its traﬃc.
However, one can easily imagine ntor being steganographi-
cally encoded inside a cover channel, with the goal of circum-
venting censorship, on top of the original goals of anonymity,
one-way authentication, and forward secrecy. This raises the
question of how the curve points can be hidden. Using a pair
of points xP, xP (cid:48) in place of X does not work: it is even eas-
ier to distinguish from uniform than a single point. M¨oller’s
curve-or-twist approach, using a pair of points in place of
the server’s long-term key B, also does not work: the client
is free to pick X on the curve or the twist, but the server is
then forced to pick Y on the same curve as X, and this is
something visible to a censor.

Our solution applies straightforwardly to this protocol. It
does not need twists; it ensures that the encodings of points
on a single curve are uniformly distributed. More generally,

our solution can be used to encode as many points as desired
during one session or across sessions.

Our solution is also useful for several earlier applications:
password-authenticated key exchange [13], ID-based encryp-
tion [12], pseudorandom-number generation [35, 36], and
kleptography [49]. Note that [49] includes a treatment of
covert channels and steganography, predating both Stego-
Torus and Telex.

1.4 Mapping strings to elliptic-curve points

Shallue and van de Woestijne at ANTS 2006 [45] gave a
positive answer to the following question in pure algorith-
mic number theory: there is, provably, a (very easy) prob-
abilistic polynomial-time algorithm that, given any elliptic
curve E over any suﬃciently large ﬁnite ﬁeld Fq, constructs
a nonzero element of the group E(Fq); is there, provably, a
deterministic polynomial-time algorithm for the same task?
Shallue and van de Woestijne did more than construct a sin-
gle point: they built a function φ : Fq → E(Fq) such that
each element of E(Fq) has at most C preimages, for a partic-
ular constant C; and they built a deterministic polynomial-
time algorithm that computes φ(t) given q, E, and t. Trying
C + 1 elements of Fq produces a nonzero element of E(Fq).
Some cryptographic protocols rely on hashing strings to
curve points. For example, in the Boneh–Franklin identity-
based encryption scheme [12], public keys are points on
pairing-friendly curves, and a user with identity i has public
key H(i). Boneh and Franklin constructed a suitable func-
tion H for certain supersingular curves. Icart at Crypto 2009
[32] pointed out that the Shallue–van de Woestijne function
φ produced suitable functions H for any elliptic curve, al-
lowing the Boneh–Franklin system to be adapted to much
more eﬃcient non-supersingular (but still pairing-friendly)
curves. Icart and subsequent authors explored various re-
placements φ for the Shallue–van de Woestijne function; see
[32], [15], [26], [25], [20], [27], [23], and [21].

The reader should be wondering why one cannot simply
deﬁne φ(t) by trying consecutive ﬁeld elements x starting
from t (for example, trying x = t, x = t + 1, x = t +
2, etc. in the prime-ﬁeld case) until ﬁnding a curve point
(x, y). The answer for Shallue and van de Woestijne is that
this is not proven to take polynomial time. On the other
hand, there is overwhelming evidence for the conjecture that
this takes polynomial time, and in cryptography there is no
harm in making such a conjecture; cryptography is built on
a foundation of conjectures that are much easier to question,
such as the conjecture that there is no fast ECDL algorithm.
This simple function from Fq to E(Fq) is exactly what is
used in many papers on identity-based cryptography.

The real objection to this algorithm is that it does not take
constant time. In many applications the time leaks secret
information. One can compute the same function for almost
all inputs in constant time by choosing an upper bound C
on the number of consecutive ﬁeld elements required with
very high probability, say C = 100, and then always testing
exactly C values of x; but testing C times for squares turns
out to be a performance bottleneck.
It should be obvious that any of the functions φ men-
tioned above allows a public key φ(t) ∈ E(Fq) to be rep-
resented as an element t ∈ Fq, using a computation of
Q (cid:55)→ {t : φ(t) = Q} to encode a point and a computation of
t (cid:55)→ φ(t) to decode a point. However, this approach raises
several important performance issues for key generation:

969• The usual key-generation method produces a uniform
random curve point by scalar multiplication, but there
is no reason to think that this curve point can be ex-
pressed in the form φ(t).
If it cannot then the user
must try again, generating a new key.

• Even worse, to generate a uniform distribution of el-
ements t ∈ Fq the user must generate a uniform
random curve point Q, compute the number k =
#{t : φ(t) = Q} of preimages of the point, restart with
probability 1 − k/C, and ﬁnally select a uniform ran-
dom preimage of the point.
(This is what statisti-
cians call “rejection sampling”; more advanced sam-
pling methods are inapplicable since there is no way to
generate a uniform random curve point with a speciﬁed
value of k.) The average number of points generated
is then C#E(Fq)/q ≈ C. Applications that need real-
time guarantees must budget for even more than C.
• Each of these C points takes time for not just a compu-
tation of Q but also a computation of {t : φ(t) = Q}.
This is the main bottleneck if φ is slow to invert.

In many protocols, ephemeral ECC keys are generated for
every protocol run, and these computations can easily dom-
inate the overall protocol performance. Of course, even in
protocols where key generation is rare, each use of t incurs
the cost of computing φ(t).

We propose two ways to minimize these performance prob-
lems: Elligator 1 and Elligator 2. Elligator 1 takes an en-
coding function φ that is implicit in the very recent paper
[23] by Fouque, Joux, and Tibouchi. This function, in the
cases we consider, maps {0, 1, 2, 3, . . . , (q − 1)/2} injectively
to E(Fq); see Theorem 4. Since the number of points on E
over Fq is about q we have to try only about 2 points on av-
erage before ﬁnding a point of the form φ(t), and we do not
need to randomize the preimage t. Not every elliptic curve
is suitable for this function, but the curve requirements for
Elligator 1 are compatible with state-of-the-art criteria for
curve security and curve performance.

Fouque, Joux, and Tibouchi suggested that injectivity
would be useful for a naive form of ElGamal encryption
in which a message m is encoded injectively as an elliptic-
curve point and then simply added to abP . We highlight the
new anti-censorship application, namely encoding points as
strings rather than encoding strings as points; we drastically
simplify the deﬁnition of this function, while accelerating its
forward and inverse computation; and we introduce a high-
security high-speed elliptic curve that supports the function.
See Section 4 for the curve, Section 3 for the function, and
Section 2 for the cryptographic applications.

Elligator 2 introduces a new injective map ψ to elliptic
curves. Elligator 2 has similar performance characteristics
to Elligator 1. The main advantage of Elligator 2 is that
it applies to more curves:
in fact, every odd-characteristic
elliptic curve that has a point of order 2, except for curves
of j-invariant 1728. See Section 5 for this new map.

2. ELLIPTIC-CURVE PROTOCOLS

This section presents various elliptic-curve protocols in
which public keys, ciphertexts, etc. are indistinguishable
from uniform random strings. These protocols include all of
the fundamental ECC constructions: static and ephemeral
key exchange, encryption, and signatures.

The prerequisite for all of these protocols is an injective
map ι from a set of strings S ⊆ {0, 1}b to an elliptic-curve
group E(Fq). We require #S to be very close to 2b, so that
a uniform random element of S is indistinguishable from a
uniform random b-bit string; see Section 2.6. We have two
diﬀerent methods to construct ι and S, as mentioned above;
see Sections 3 and 5.
The idea, as explained in Section 1, is for each string τ ∈ S
to represent the curve point ι(τ ), i.e., for the point ι(τ ) to
be encoded as the string τ . A uniform random element of
ι(S), encoded in this way, is indistinguishable from a uni-
form random b-bit string. We do not require ι(S) to be all of
E(Fq); our protocols compensate for this by repeatedly gen-
erating curve points until ﬁnding elements of ι(S). For our
constructions #ι(S) is about (1/2)#E(Fq), requiring only
about 2 repetitions on average, as mentioned in Section 1.

Our primary objective in this section is to illustrate how
easily ι can be used to systematically hide elliptic-curve
points in a wide range of protocols. We do not mean to
suggest that all of these protocols are being used in contexts
where they need to be hidden from censors; but there is no
obvious dividing line between protocols that would be useful
for those contexts and protocols that would not.

Consider, for example, static ECDH public keys. A static
public key might be distributed openly, as part of a crypto-
graphic software package, in which case it does not add any
new risk of censorship; changing the encoding of the public
key does nothing to hide the package from a censor. On
the other hand, if a client already has all necessary crypto-
graphic software, and a server broadcasts a series of static
public keys by encoding those keys inside otherwise inno-
cent web pages or other cover traﬃc, then indistinguishabil-
ity from uniform is exactly the tool needed to defend those
public keys against a censor with an accurate model of the
cover traﬃc. A censored Tor client should be able to see fre-
quent updates of public keys for Tor bridges, for example;
see [1] for a detailed discussion of the speed at which various
governments detect and suppress access to Tor bridges.

2.1 Notation and domain parameters

To simplify the protocol statements we assume that the
elliptic-curve group E(Fq) is cyclic: speciﬁcally, that it is
generated by a standard base point P of order n.
In the
case that n is not prime (for example, n is 4 times a prime
in Section 4) we do not restrict points to a prime-order sub-
group: any proper subgroup is trivially distinguishable from
the full group. For non-cyclic groups the protocols would
have to be modiﬁed to handle multiple generators.
Let H denote a hash function, and let || denote concate-
nation of strings. Symmetric authenticated encryption of a
message M using a secret key k is denoted as c = Enck(m),
decryption as m = Deck(c). A standard security require-
ment for symmetric encryption is that the ciphertexts are
indistinguishable from uniform (see, e.g., [3]); one can, for
example, safely use AES in counter mode. For authentica-
tion there is a split in the literature between authenticators
aiming at the “PRF” property, which guarantees indistin-
guishability, and authenticators aiming merely at the “MAC”
property, which guarantees unforgeability but does not guar-
antee indistinguishability; we require the PRF property. See
[44] for a uniﬁed security notion for authenticated encryp-
tion that guarantees indistinguishability from uniform ran-
dom bit strings.

9702.2 Long-term Difﬁe–Hellman keys

Each user U sets up a public key:
1. U generates a random integer u.
2. U computes PU = uP . If PU /∈ ι(S) then U repeats
3. U publishes ι−1(PU ) = τU and keeps u secret.

from step 1.

The encoding τU of the public key is a string which can be
broadcast; it is indistinguishable from a random string.

Without further communication users Alice and Bob can
compute a shared secret from their public strings τA and
τB. Alice can compute this key as follows and then use it to
authenticate and encrypt a message to Bob:

1. Alice computes ι(τB) = PB.
2. Alice computes k = H(uAPB).
Upon receiving an encrypted message from Alice, Bob can
likewise compute the same shared secret and then decrypt
the message and verify the authenticator:

1. Bob computes ι(τA) = PA.
2. Bob computes k = H(uBPA).

2.3 ElGamal encryption

Assume uB and PB = uBP is a static key pair of Bob and
that Bob has published τB = ι−1(PB). Alice wants to send
Bob a message M . To encrypt the message she performs the
following steps:

If R /∈ ι(S) she

repeats from step 1.

1. She generates a random integer r.
2. She computes the point R = rP .
3. She computes ι−1(R) = τR.
4. She computes PB = ι(τB).
5. She computes the shared key value k = H(rPB).
6. She encrypts message m using key k: c = Enck(m).
7. She sends the tuple (τR, c) as an encryption of m.
To decrypt the received message, Bob:

1. computes ι(τR) = R,
2. computes the same shared key value: k = H(uBR),

and

3. decrypts the message: m = Deck(c).
ElGamal encryption also appears in [23] as an applica-
tion of an injective map between strings and curve points,
but our application is completely diﬀerent from the applica-
tion in [23]. There is a critical diﬀerence in the underlying
encryption methods: we use symmetric cryptography to en-
crypt the message m using a key derived from rPB, whereas
[23] adds rPB to a curve point M that represents m. This
is exactly where [23] uses an injective map, namely to en-
code the string m as a curve point M . Note, however, that
this also (1) prevents [23] from encrypting long messages
and (2) allows malleability, in violation of the basic security
standards for public-key encryption. We instead use the
standard “KEM/DEM” structure to provide secure public-
key encryption, and as a consequence do not need to encode
strings as curve points. We use an injective map for a com-
pletely diﬀerent reason: we encode curve points as strings,
preventing those points from being recognized by censors.
2.4 Short-term Difﬁe–Hellman keys

no authentication, but authentication can be added as a
subsequent layer.

1. Alice and Bob generate short-term keys as follows:

(a) Generate a random integer r.
(b) Compute point R = rP . If R /∈ ι(S) repeat from
2. Alice sends µA = ι−1(RA) to Bob; Bob sends µB =

step 1a.

ι−1(RB) to Alice.

3. Alice decodes RB = ι(µB); Bob decodes RA = ι(µA).
4. Alice computes the shared key value k = H(rARB);

Bob computes the same k as H(rBRA).

2.5 Schnorr signatures
Assume that uB and PB = uBP are respectively private
and public keys of Bob, where PB ∈ ι(S) and Bob has pub-
lished τB = ι−1(PB). To sign a message m, Bob performs
the following steps:

1. Choose a random integer r.
2. Compute R = rP . If R /∈ ι(S), repeat from step 1.
3. Compute τ = ι−1(R).
4. Compute h = H(τ||τB||m).
5. Compute s = r + huB (mod n).
6. The signature is the tuple ψ = (τ, s).
The integer s must be encoded so as to be indistinguish-

able from uniform; see Section 2.6.

To verify the signature (τ, s), Alice performs the following

steps:

1. Compute PB = ι(τB).
2. Compute R = ι(τ ).
3. Compute h = H(τ||τB||m).
4. Compare R + hPB and sP . If they are equal, accept.

Otherwise, reject.

Schnorr’s original signature system actually sent (h, s).
We follow “EdDSA” from [8] in sending an encoding of (R, s);
security is the same, since one can reconstruct (h, s) from
(R, s) and vice versa. The advantage of (R, s) is that it
allows batching, making signature veriﬁcation about twice
as fast, as explained in [8]. Our use of ι makes this signature
indistinguishable from a uniform random string.

We also follow EdDSA in including the public key τB in
the hash. Robert Ransom has pointed out that if the public
key is omitted from the hash then an attacker who does not
know it can calculate it by ﬁrst computing h and then com-
puting (sP − R)/h, and as a consequence can see that two
signatures come from the same public key. Ransom has also
suggested a diﬀerent way of hiding signatures from someone
who does not know τB: namely, encrypting the signatures
with a secret-key cipher keyed by a hash of τB. Of course,
indistinguishability is unachievable against an attacker who
does know τB: the attacker can simply verify the signature.
We encode R as τ both for transmission and for input
to H. We could safely switch to a diﬀerent encoding for
input to H. In particular, we could use the same encoding
used in EdDSA. This would make our signatures compatible
with EdDSA signatures: anyone could convert an EdDSA
signature into a signature of our form and vice versa.
2.6 Detecting differences from uniform

In this protocol, Alice and Bob agree on a shared secret
without using long-term keys. This protocol is important as
a way to provide forward secrecy. Of course, this provides

These protocols transmit uniform random elements of S.
Usually S is not the set of all b-bit strings, so uniform ran-
dom elements of S are not exactly uniform random b-bit

971strings. This is not a security problem if #S is very close to
2b; we now analyze quantitatively what “very close” means.
Consider a channel that normally sends k independent
uniform random b-bit strings. A user modiﬁes the channel
to instead transmit k independent uniform random elements
of S. The censor’s goal is to take action against the modiﬁed
channel without taking action against the original channel.
The obvious strategy for the censor is to take action if and
only if all of the b-bit strings are elements of S. This has no
false negatives, but it produces a false positive whenever k
independent uniform random b-bit strings happen to all be
elements of S. If #S = 2b − δ then a false positive occurs
with probability (#S/2b)k = (1 − δ/2b)k ≈ exp(−kδ/2b).
This strategy maximizes the diﬀerence in action probabil-
ity between the original and modiﬁed channels; hence Sk is
indistinguishable from ({0, 1}b)k when kδ/2b is small.

(cid:8)0, 1, 2, . . . , 2256 − 2224 + 2192 + 296 − 2(cid:9), with b = 256.

Here δ ≈ 2224.
If the censor sees k = 235 sessions then
kδ/2b ≈ 8 so the censor will take action for the original
channel with probability only about exp(−8) ≈ 0.000335.
This may be an acceptable level of collateral damage.
As a second example illustrating the importance of the
ratio kδ/2b, consider a set S of size 2256 − δ where δ ≤ 2160.
This time a censor seeing k ≤ 264 sessions has kδ/2b ≤ 2−32
so the probability is larger than 0.99999999; i.e., the censor
will take action against practically every channel.

Consider,

for example,

the NIST P-256 set S =

The encodings that we consider for elements of E(Fq)
typically have #S = (q + 1)/2. In each of our recommended
examples, #S is between 2b−2b/2 and 2b, so kδ/2b ≤ k/2b/2.
The probability diﬀerence is therefore negligible until k, the
number of strings transmitted, grows to a noticeable fraction
of 2b/2. This cannot be a concern when E(Fq) is chosen
to resist standard discrete-logarithm attacks: those attacks
take time only about 2b/2.

√
We also encode integers modulo n = #E(Fq) as strings
q of q + 1,
in Section 2.5. By Hasse’s theorem, n is within 2
so if q is very close to 2b+1 then n is also forced to be very
close to 2b+1. Note that taking q slightly below 2b+1 does
not force n to be below 2b+1; for n > 2b+1 we still use a
(b + 1)-bit encoding, restarting the protocol in Section 2.5 in
the extremely unlikely case that an integer is 2b+1 or larger.
2.7 Active attacks

Censors can try replacing random-looking strings by other
strings (possibly strings outside S) to see whether this has
any visible eﬀect. Presumably this replacement will disrupt
communication, but protocol designers and implementors
must take care to ensure that this replacement does not
allow the censor to detect communication.

We brieﬂy point out an attack against the password-
authenticated key-exchange protocol of [13]; this attack is
not in the censorship context, but it illustrates both the
value of avoiding twists and the diﬃculty of protecting
against active attacks. In the protocol of [13], Alice sends
an encryption (using a shared password as a secret key) of
either a point on a curve or a point on the twist of the curve;
indistinguishability is important here for the ciphertext to
avoid leaking information. Bob sends back two points, one
on the curve and one on the twist; information is carried
by the point on the same curve used by Alice, while the
other point is random. Our attack is to actively rerandom-
ize one of the two points sent by Bob. If this point is on

the same curve then Alice aborts; if this point is not on the
same curve then Alice does not notice and communication
continues. This information leak allows the attacker to ex-
clude half of all possible passwords, and repeating the attack
allows the attacker to quickly ﬁnd the right password.

3. ELLIGATOR 1: THE INJECTIVE MAP
Section 2 needs an injective map ι from a large set S of
strings to E(Fq). Elligator 1 is one choice of ι; Elligator
2, introduced in Section 5, is another choice of ι. This sec-
tion presents the mathematical details of Elligator 1: the
construction of ι, how to compute ι, how to test whether
a curve point is in the image of ι, and how to invert ι on
curve points in the image. To help the reader visualize the
mathematical structure of ι we include a picture as Figure 1.
We impose certain requirements on q and E for Elligator
1: we consider only primes q; we require q to be congruent to
3 modulo 4; we require E to be a complete Edwards curve;
and we impose an extra algebraic requirement (c = 2/s2 in
Theorem 1) that allows only half of all complete Edwards
curves. Approximately 1/16 of all isomorphism classes of el-
liptic curves over all ﬁnite ﬁelds satisfy these requirements.
(Asymptotically 100% of all ﬁnite ﬁelds, ordered by size, are
prime ﬁelds; 50% of those primes are congruent to 3 mod-
ulo 4; 25% of elliptic curves over those ﬁelds are complete
Edwards curves; 50% of those satisfy the extra algebraic
requirement.) See Section 4 for speciﬁc choices of q and E.
The heart of ι is a function φ : Fq → E(Fq) deﬁned in
Theorem 1 and Deﬁnition 2. This function satisﬁes φ(t) =
φ(−t) for each t ∈ Fq but has no other collisions (see The-
orem 3), so its restriction to {0, 1, 2, . . . , (q − 1)/2} is injec-
tive. Theorem 4 simply deﬁnes S as {0, 1, 2, . . . , (q − 1)/2}
represented in little-endian form as b-bit strings, where
b = (cid:98)log2 q(cid:99), and deﬁnes ι as the corresponding represen-
tation of φ. For indistinguishability we add the requirement
that (q + 1)/2 be extremely close to 2b.

As mentioned in Section 1, this function φ was introduced
by Fouque, Joux, and Tibouchi in [23]. Our main contribu-
tions in this section are a much more concise deﬁnition of
φ; much more direct proofs of the relevant properties of φ;
a simple method to invert φ; and a simple test for whether
a curve point is in the image of φ.
The function −φ has the same useful properties as φ. Our
choice of sign is not the same as the choice in [23]: in the no-
tation below, the ratio is χ(c), i.e., χ(2). This choice of sign
slightly simpliﬁes our formulas for the forward and inverse
maps, although it is not the main simpliﬁcation compared
to [23]. We also comment that φ(t) = −φ(1/t) for t (cid:54)= 0.

Computing ι in a sensible way is almost as fast as tra-
ditional point decompression, not a serious bottleneck com-
pared to scalar multiplication. Inverting ι is slightly slower,
but testing whether a curve point is in the image of ι is very
fast. See Section 3.5 for further performance analysis.
3.1 Squares, square roots, and χ
Fix a prime power q ≡ 3 (mod 4). In deﬁning ι we con-
sider only primes q for simplicity (so that 0, 1, 2, . . . , (q−1)/2
are distinct ﬁeld elements) but our φ theorems also apply to
prime powers.
Deﬁne χ : Fq → Fq by χ(a) = a(q−1)/2. If a is a non-zero
square then χ(a) = 1; if a is a non-square then χ(a) = −1;
if a = 0 then χ(a) = 0. Note that (q − 1)/2 is odd since
q ≡ 3 (mod 4), so χ(−1) = −1, so −1 is not a square. More

972Figure 1: The structure of our encoding function ι−1, a bijection from
a large subset of E(Fq) to a large set S of b-bit strings. The elliptic
curve E is required to be a complete Edwards curve, shown on the
left together with a sample element P = (x, y) of E(Fq). A sample
b-bit output is shown on the right. See Theorems 1, 3, and 4 and
Deﬁnition 2 for further details regarding the function in the middle.

generally, χ(χ(a)) = χ(a). There are several easy ways to
manipulate χ arguments:
for example, χ(ab) = χ(a)χ(b),
χ(1/a) = χ(a) = 1/χ(a) if a (cid:54)= 0, and χ(a2) = 1 if a (cid:54)= 0.
If a is a square then a(q+1)/4 is a square root of a:

its
square is a(q+1)/2 = χ(a)a = a. More precisely, a(q+1)/4 is
the principal square root of a: the unique square root that
is a square. Any square root b of a satisﬁes b = χ(b)a(q+1)/4.
The function χ is called a quadratic character. See [38]

for further background on ﬁnite ﬁelds.
3.2 The map

Theorem 1. Let q be a prime power congruent to 3 mod-
ulo 4. Let s be a nonzero element of Fq with (s2−2)(s2+2) (cid:54)=
0. Deﬁne c = 2/s2. Then c(c − 1)(c + 1) (cid:54)= 0.
Deﬁne r = c + 1/c and d = −(c + 1)2/(c − 1)2. Then
r (cid:54)= 0, and d is not a square.
The following elements of Fq are deﬁned for each t ∈ Fq \
{±1}:

u = (1 − t)/(1 + t),
v = u5 + (r2 − 2)u3 + u,
X = χ(v)u,

Y = (χ(v)v)(q+1)/4χ(v)χ(cid:0)u2 + 1/c2(cid:1),

x = (c − 1)sX(1 + X)/Y,
y = (rX − (1 + X)2)/(rX + (1 + X)2).

Furthermore x2 + y2 = 1 + dx2y2; uvXY x(y + 1) (cid:54)= 0; and
Y 2 = X 5 + (r2 − 2)X 3 + X.

a square, contradiction.
1 − t (cid:54)= 0.

Proof. c(c − 1)(c + 1) (cid:54)= 0: By deﬁnition c = 2/s2
so c (cid:54)= 0. By hypothesis s2 (cid:54)= 2 and s2 (cid:54)= −2 so c (cid:54)= 1 and
c (cid:54)= −1.
r (cid:54)= 0: If r = 0 then c = −1/c so c2 = −1, contradiction.
d is not a square: Otherwise −1 = d(c − 1)2/(c + 1)2 is
u is deﬁned and u (cid:54)= 0: By hypothesis 1 + t (cid:54)= 0 and
v (cid:54)= 0: r2 − 2 = c2 + 1/c2 so v = u(u2 + c2)(u2 + 1/c2). If
v = 0 then there are three possibilities: u = 0, contradiction;
or u2+c2 = 0 so −1 = (u/c)2, contradiction; or u2+1/c2 = 0
so −1 = (uc)2, contradiction.
XY (cid:54)= 0, so x is deﬁned: As above u2 + 1/c2 (cid:54)= 0 so
all factors in X and Y are nonzero.
1 + X (cid:54)= 0, so x (cid:54)= 0: If X = −1 then u = −χ(v)
so v = −χ(v)(1 + r2 − 2 + 1) = −χ(v)r2 so χ(v) = −χ(v),
contradiction.
(X, Y ) satisﬁes Y 2 = X 5 + (r2 − 2)X 3 + X: X =
χ(v)u so X 5 + (r2 − 2)X 3 + X = χ(v)(u5 + (r2 − 2)u3 + u) =

χ(v)v. Also χ(v)v is a square so (χ(v)v)(q+1)/2 = χ(v)v so
Y 2 = χ(v)v.
rX +(1+X)2 (cid:54)= 0, so y is deﬁned: If rX = −(1+X)2
then (r2 + 4r)X 2 = X 4 − 2X 2 + 1 so

Y 2 = X(X 4 + (r2 − 2)X 2 + 1) = X 3(2r2 + 4r)
= rX · X 2(2r + 4) = −(1 + X)2X 2(s + 2/s)2

so −1 is a square, contradiction.
y + 1 (cid:54)= 0: If y = −1 then (rX − (1 + X)2)/(rX + (1 +
X)2) = −1 so rX − (1 + X)2 = −(rX + (1 + X)2) so rX = 0,
contradiction.
x2 + y2 = 1 + dx2y2: First (c− 1)2s2 = (c− 1)2(2/c) =
2(r − 2) so
Y 2(1 − x2) = Y 2 − (c − 1)2s2X 2(1 + X)2

= X 5 + (r2 − 2)X 3 + X − 2(r − 2)X 2(1 + X)2
= X(rX − (1 + X)2)2.

Similarly −d = (c + 2 + 1/c)/(c − 2 + 1/c) = (r + 2)/(r − 2)
so −d(c − 1)2s2 = 2(r + 2) so
Y 2(1 − dx2) = Y 2 − d(c − 1)2s2X 2(1 + X)2

= X 5 + (r2 − 2)X 3 + X + 2(r + 2)X 2(1 + X)2
= X(rX + (1 + X)2)2.

Note that Y 2(1− dx2) (cid:54)= 0, and divide: (1− x2)/(1− dx2) =
(rX − (1 + X)2)2/(rX + (1 + X)2)2 = y2; i.e., x2 + y2 =
1 + dx2y2.

Definition 2. In the situation of Theorem 1, the decod-
ing function for the complete Edwards curve E : x2 + y2 =
1 + dx2y2 is the function φ : Fq → E(Fq) deﬁned as follows:
φ(±1) = (0, 1); if t /∈ {±1} then φ(t) = (x, y).
3.3 Inverting the map

Theorem 3. In the situation of Deﬁnition 2:
1. If t ∈ Fq then the set of preimages of φ(t) under φ is

{t,−t}.

2. φ(Fq) is the set of (x, y) ∈ E(Fq) such that

• y + 1 (cid:54)= 0;
• (1 + ηr)2− 1 is a square, where η =
• if ηr = −2 then x = 2s(c − 1)χ(c)/r.

y − 1
2(y + 1)

; and

3. If (x, y) ∈ φ(Fq) then the following elements ¯X, z, ¯u, ¯t

of Fq are deﬁned and φ(¯t) = (x, y):

¯X = −(1 + ηr) + ((1 + ηr)2 − 1)(q+1)/4,

z = χ(cid:0)(c − 1)s ¯X(1 + ¯X)x( ¯X 2 + 1/c2)(cid:1),

¯u = z ¯X,
¯t = (1 − ¯u)/(1 + ¯u).

Proof. Statement 1 of the theorem has two parts: a for-
ward statement φ(t) = φ(−t), and a reverse statement that
there are no other preimages. Statement 2 also has two
parts: a forward statement that any (x, y) ∈ φ(Fq) satisﬁes
certain conditions, and a reverse statement that any element
of E(Fq) satisfying those conditions is in φ(Fq). We orga-
nize the proof as (A) forward 1; (B) 3, forward 2, and reverse
1; (C) reverse 2.
A. Fix t ∈ Fq. We now show that φ(t) = φ(−t). This is

the forward part of statement 1 in the theorem.

973If t ∈ {±1} then φ(t) = (0, 1) = φ(−t) by deﬁnition.

Assume from now on that t /∈ {±1}.

Deﬁne u, v, X, Y, x, y from t as in Theorem 1. Then φ(t) =
(x, y) by deﬁnition.
Put t(cid:48) = −t, and deﬁne u(cid:48), v(cid:48), X(cid:48), Y (cid:48), x(cid:48), y(cid:48) the same way
from t(cid:48). Then φ(t(cid:48)) = (x(cid:48), y(cid:48)). The proof strategy is to
compare successively u(cid:48) to u, v(cid:48) to v, etc., concluding that
x(cid:48) = x and y(cid:48) = y.

u(cid:48) = (1 − t(cid:48))/(1 + t(cid:48)) = (1 + t)/(1 − t) = 1/u.
u5 + (r2 − 2) 1
v(cid:48) = u(cid:48)5 + (r2 − 2)u(cid:48)3 + u(cid:48) = 1

u , so
v(cid:48)u6 = u + (r2 − 2)u3 + u5 = v; i.e., v(cid:48) = v/u6. Note that
χ(v(cid:48)) = χ(v) since χ(u6) = 1.
X(cid:48) = χ(v(cid:48))u(cid:48) = χ(v)/u = 1/(χ(v)u) = 1/X since χ(v) =

u3 + 1

1/χ(v).
y(cid:48) =

rX(cid:48)−(1+X(cid:48))2
rX(cid:48)+(1+X(cid:48))2 =

Y (cid:48) = (χ(v(cid:48))v(cid:48))(q+1)/4χ(v(cid:48))χ(cid:0)u(cid:48)2 + 1/c2(cid:1). This takes the

rX−(X+1)2
rX+(X+1)2 = y.

X −(1+ 1
r 1
r 1
X +(1+ 1

X )2
X )2

=

(cid:18)

(cid:19)(cid:30) Y

most work; the ﬁrst and third factors each need careful anal-
yses. The second factor is easy: χ(v(cid:48)) = χ(v) as above.
First factor: χ(v(cid:48))v(cid:48) = χ(v)v/u6. Note that the product
χ(u)u3 is a square and is therefore the principal square root
of u6; i.e., (u6)(q+1)/4 = χ(u)u3. Hence (χ(v(cid:48))v(cid:48))(q+1)/4 =
(χ(v)v/u6)(q+1)/4 = (χ(v)v)(q+1)/4χ(u)/u3.
that χ(a) = χ(ab2) for any b (cid:54)= 0. Thus

Third factor: Recall that v = u(u2 + c2)(u2 + 1/c2) and

(cid:48)2 + 1/c2(cid:1) = χ(cid:0)c2u4(u

(cid:48)2 + 1/c2)(u2 + 1/c2)2(cid:1)

= χ(cid:0)u2(c2 + u2)(u2 + 1/c2)2(cid:1)
= χ(cid:0)uv(u2 + 1/c2)(cid:1).

χ(cid:0)u

Now multiply to obtain Y (cid:48) = Y χ(u)χ(uv)/u3 =

(cid:48)

(cid:48)

X 3

1 +

1
X

(1 + X

= (c − 1)s

Y /(χ(v)u)3 = Y /X 3. Finally
x(cid:48) = (c − 1)sX
(cid:48)
)/Y

The deﬁnition of φ has two cases:

= (c − 1)sX(1 + X)/Y = x.

1
X
Hence φ(−t) = (x(cid:48), y(cid:48)) = (x, y) = φ(t) as claimed.
B. Fix t ∈ Fq, and deﬁne (x, y) = φ(t). We show that
¯X, z, ¯u, ¯t in the theorem are deﬁned and that ¯t ∈ {t,−t}, so
φ(¯t) = (x, y); this is statement 3 in the theorem. We also
show the forward part of statement 2: namely, y + 1 (cid:54)= 0;
(1 + ηr)2 − 1 is a square, where η = (y− 1)/(2(y + 1)); and if
ηr = −2 then x = 2s(c− 1)χ(c)/r. We also show the reverse
part of statement 1: there are no preimages of φ(t) other
than t and −t.
if t ∈ {1,−1} then
(x, y) = (0, 1); if t /∈ {1,−1} then u, v, X, Y, x, y are deﬁned
in Theorem 1. Note that in the second case x (cid:54)= 0 by Theo-
rem 1, so in particular t is not a preimage of (0, 1).
In the ﬁrst case y + 1 = 2 (cid:54)= 0; η = 0; (1 + ηr)2 − 1 = 0
is a square; ¯X = −1; z = 0; ¯u = 0; and ¯t = 1 ∈ {t,−t}. As
noted above, 1 and −1 are the only preimages of (0, 1).
What remains is the second case. Here y + 1 (cid:54)= 0 by
Theorem 1. The equation y = (rX − (1 + X)2)/(rX +
(1 + X)2) implies X 2 + (2 + r(y − 1)/(y + 1))X + 1 = 0,
i.e., X 2 + 2(1 + ηr)X + 1 = 0. Note that this forces the
discriminant 4(1 + ηr)2 − 4 to be a square; i.e., (1 + ηr)2 − 1
is a square. Divide by X to see that X + 1/X = −2(1 + ηr).
If ηr = −2 then (X − 1)2 = 0 so X = 1 so u ∈ {±1};
the case u = −1 forces 1 − t = −(1 + t), contradiction, so
u = 1 and t = 0; so v = r2, so Y = (r2)(q+1)/4χ(1 + 1/c2) =
χ(r)rχ(r/c) = rχ(c), so x = 2(c − 1)sχ(c)/r as claimed;
also note for future reference that y = (r − 4)/(r + 4), i.e.,
φ(0) = (2(c − 1)sχ(c)/r, (r − 4)/(r + 4)).

Deﬁne t(cid:48) = −t, and deﬁne u(cid:48), v(cid:48), X(cid:48), Y (cid:48), x(cid:48), y(cid:48) as in Part A
of this proof. Then X(cid:48) = 1/X, so X + X(cid:48) = −2(1 + ηr).
By construction 1+ηr + ¯X is a square root of (1+ηr)2−1;
i.e., ¯X 2 + 2(1 + ηr) ¯X + 1 = 0. Now ( ¯X − X)( ¯X − X(cid:48)) =
¯X 2 − (X + X(cid:48)) ¯X + XX(cid:48) = ¯X 2 + 2(1 + ηr) ¯X + 1 = 0 so
¯X = X or ¯X = X(cid:48). This forces ¯u = u or ¯u = u(cid:48), since the
deﬁnition of z turns out to match χ(v) and χ(v(cid:48)):

¯X = X then (c − 1)s ¯X(1 + ¯X) = xY so

z = χ(cid:0)x2Y (X 2 + 1/c2)(cid:1) = χ(Y )χ(cid:0)X 2 + 1/c2(cid:1). Note
that (χ(v)v)(q+1)/4 is a square and χ(cid:0)u2 + 1/c2(cid:1) =
χ(cid:0)X 2 + 1/c2(cid:1), so χ(Y ) = χ(v)χ(X 2 + 1/c2), so z =

• If

χ(v), so ¯u = χ(v)X = u, so ¯t = t.

• If ¯X = X(cid:48) then similarly z = χ(v(cid:48)), ¯u = u(cid:48), and

¯t = t(cid:48) = −t.

To summarize, ¯t ∈ {t,−t}, so φ(¯t) = (x, y).
The same logic also shows that there are no preimages p
of (x, y) except for t and −t. Indeed, if (x, y) = φ(p) then
substituting p for t in the same proof shows that ¯t ∈ {p,−p},
so p ∈ {¯t,−¯t} = {t,−t}.

C. Fix (x, y) ∈ E(Fq). Assume that y + 1 (cid:54)= 0; that
(1 + ηr)2 − 1 is a square, where η = (y − 1)/(2(y + 1)); and
that if ηr = −2 then x = 2s(c − 1)χ(c)/r. We now show
that (x, y) ∈ φ(Fq). This is the reverse part of statement 2
of the theorem.
If x = 0 then (x, y) = (0,±1) from the curve equation;
but y + 1 (cid:54)= 0, so (x, y) = (0, 1) = φ(1) ∈ φ(Fq) as claimed.
Assume from now on that x (cid:54)= 0.
If y = 1 then x = 0 from the curve equation, contradiction.
Hence y (cid:54)= 1; i.e., η (cid:54)= 0.
Deﬁne X = −(1 + ηr) + ((1 + ηr)2 − 1)(q+1)/4. As above
1+ηr+X is a square root of (1+ηr)2−1, so X 2+2(1+ηr)X+
1 = 0. This quadratic equation has several consequences.
First, X (cid:54)= 0. Second, rX + (1 + X)2 (cid:54)= 0: otherwise sub-
tract to see that (1− 2η)rX = 0, so 1 = 2η, so y− 1 = y + 1,
contradiction. Third, X (cid:54)= −1: otherwise η = 0, contradic-
tion. Fourth, y = (rX − (1 + X)2)/(rX + (1 + X)2).
If X = 1 then y = (r − 4)/(r + 4); also ηr = −2 so by
assumption x = 2s(c − 1)χ(c)/r so (x, y) = φ(0) ∈ φ(Fq).
Assume from now on that X (cid:54)= 1.
(rX + (1 + X)2)2(1 − y2)

Observe that

= (rX + (1 + X)2)2 − (rX − (1 + X)2)2
= 4rX(1 + X)2.

Recall that −d = (r + 2)/(r − 2) and similarly observe that

(rX + (1 + X)2)2(1 − dy2)

= (rX + (1 + X)2)2 +
= (2r/(r − 2))(X 4 + (r2 − 2)X 2 + 1).

r + 2
r − 2

(rX − (1 + X)2)2

Note that 1 − dy2 (cid:54)= 0 since d is not a square. Divide:

x2 =

1 − y2
1 − dy2 =

2(r − 2)X 2(1 + X)2
X 5 + (r2 − 2)X 3 + X

.

Deﬁne Y = (c − 1)sX(1 + X)/x. Then

Y 2 = (c − 1)2s2X 2(1 + X)2/x2
= 2(r − 2)X 2(1 + X)2/x2
= X 5 + (r2 − 2)X 3 + X.

Deﬁne z = χ(cid:0)Y (X 2 + 1/c2)(cid:1). Both Y and X 2 + 1/c2 are

nonzero, so z ∈ {±1}.

974Deﬁne u = zX. Then u ∈ {±X}. Note that u (cid:54)= −1,
since X /∈ {±1}.
Deﬁne v = u5 + (r2 − 2)u3 + u. Then v = z(X 5 +
(r2 − 2)X 3 + X) = zY 2, so χ(v) = χ(z) = z. Hence
X = χ(v)u and Y 2 = χ(v)v.
Furthermore χ(v) =

z = χ(cid:0)Y (X 2 + 1/c2)(cid:1) = χ(cid:0)Y (u2 + 1/c2)(cid:1), so χ(Y ) =
χ(v)χ(cid:0)u2 + 1/c2(cid:1), so Y = (χ(v)v)(q+1)/4χ(v)χ(cid:0)u2 + 1/c2(cid:1).

Finally deﬁne t = (1− u)/(1 + u). Then t /∈ {±1} and u =
(1− t)/(1 + t). The formulas for u, v, X, Y, x, y in Theorem 1
are all satisﬁed, so (x, y) = φ(t) ∈ φ(Fq) as claimed.
3.4 Encoding as strings

{0, 1}b → Fq by σ(τ0, τ1, . . . , τb−1) = (cid:80)

{0, 1, . . . , (q − 1)/2} is a subset of (cid:8)0, 1, . . . , 2b − 1(cid:9); hence

Theorem 4. In the situation of Deﬁnition 2, assume
that q is prime, and deﬁne b = (cid:98)log2 q(cid:99). Deﬁne σ :
i τi2i. Deﬁne
S = σ−1({0, 1, 2, . . . , (q − 1)/2}). Deﬁne ι : S → E(Fq)
as follows: ι(τ ) = φ(σ(τ )). Then #S = (q + 1)/2; ι is an
injective map from S to E(Fq); and ι(S) = φ(Fq).
Proof. First 2b ≤ q so the integers 0, 1, . . . , 2b − 1 are
distinct in Fq; hence σ is injective. Furthermore 2b > q/2 so
each of 0, 1, . . . , (q− 1)/2 has a preimage under σ, and S has
exactly (q + 1)/2 elements.
If ι(τ ) = ι(τ(cid:48)) then φ(σ(τ )) = φ(σ(τ(cid:48))), so σ(τ ) =
±σ(τ(cid:48)) by Theorem 3; but σ(τ ) and σ(τ(cid:48)) are both in
{0, 1, . . . , (q − 1)/2}, so σ(τ ) = σ(τ(cid:48)), so τ = τ(cid:48). Hence ι
is injective.
Each element of ι(S) has the form φ(σ(τ )) and is therefore
in φ(Fq). Conversely, if P ∈ φ(Fq) then P = φ(t) for some
t ∈ Fq, so also P = φ(−t) by Theorem 3. At least one
of t,−t is in {0, 1, . . . , (q − 1)/2}, i.e., in σ(S), so P is in
φ(σ(S)) = ι(S).
3.5 Performance analysis

The deﬁnitions of u, v, X, Y, x, y in Theorem 1 involve di-
visions by 1 + t, c, Y , and rX + (1 + X)2. The reciprocal
of c is trivially precomputed, and the other divisions are
easily replaced by a few multiplications: one simply stores
ﬁeld elements as fractions, i.e., works in projective coordi-
nates. There are several easy ways to reduce the number of
multiplications: for example, factor u5 + (r2 − 2)u3 + u as
u(u2 + c2)(u2 + 1/c2), and reuse u2 + 1/c2 in computing Y .
The main bottlenecks are then the following expo-
nentiations: computing χ(v) (used repeatedly); comput-

ing χ(cid:0)u2 + 1/c2(cid:1); computing (χ(v)v)(q+1)/4, the principal

square root of χ(v)v; and computing a ﬁnal division if the
output (x, y) is needed in aﬃne coordinates instead of pro-
jective coordinates. The only essential exponentiation is for
the square-root computation: the χ computations and divi-
sion can use Euclid’s algorithm (blinded to protect against
timing attacks) rather than exponentiation.

Similar comments apply to inverting φ (or ι). There is
one essential exponentiation, the square-root computation
to obtain ¯X in Theorem 3. There are also two exponentia-
tions that can be replaced by Euclidean computations: one
χ computation to obtain z, and one division to obtain the
ﬁnal output ¯t. Fractions eliminate the initial division by
2(y + 1), but fractions cannot be used for ¯t, since the goal is
to obtain the unique string representing ¯t.
It is easier to test, given (x, y) ∈ Fq × Fq, whether
(x, y) ∈ φ(Fq) (i.e., whether (x, y) ∈ ι(S)) without in-
verting φ. One ﬁrst checks x2 + y2 = 1 + dx2y2 to ver-
ify (x, y) ∈ E(Fq), if this is not already known. Then, by

Theorem 3, (x, y) ∈ φ(Fq) if and only if the following three
conditions are satisﬁed:

• y + 1 (cid:54)= 0;
• (1 + ηr)2 − 1 is a square, where η = (y − 1)/(2(y + 1));

i.e., r(y − 1)(r(y − 1) + 4(y + 1)) is a square;

• if ηr = −2 (equivalently, if r(y − 1) = −4(y + 1)) then

x = 2s(c − 1)χ(c)/r.

This requires a few multiplications and one χ computation.

4. CONSTRUCTION OF A SUITABLE EL-

LIPTIC CURVE FOR ELLIGATOR 1

This section introduces a new high-security high-speed el-
liptic curve, called Curve1174, that supports the injective
map presented in Section 3. In particular, this section spec-
iﬁes Curve1174; presents the criteria that we used to con-
struct Curve1174; and analyzes the extent to which various
previous curves meet the same criteria.

Curve1174 illustrates state-of-the-art criteria for choosing
elliptic curves. It is compatible with Elligator 1, and is also
compatible with the new map Elligator 2 introduced in the
next section. It is even more concisely expressible than the
existing Curve25519 curve.

We do not mean to suggest that users of Curve25519 are
required to switch to Curve1174 to take advantage of this
paper. Curve25519 is fully compatible with Elligator 2.
4.1 The curve
Curve1174 is the Edwards curve x2 + y2 = 1 − 1174x2y2
over the ﬁeld Fq, where q is the prime number 2251 − 9. The
coeﬃcient −1174 is a non-square in Fq, so Curve1174 is a
complete Edwards curve by [9, Theorem 3.3]: the sum of
any two points (x1, y1) and (x2, y2) in Curve1174(Fq) is

(cid:19)

,

(cid:18) x1y2 + y1x2

1 − 1174x1x2y1y2

,

y1y2 − x1x2

1 + 1174x1x2y1y2

with no divisions by 0 and no exceptional cases. The neutral
element of the curve is (0, 1).

To see that we have the desired injective map, note that

q is congruent to 3 modulo 4; deﬁne s as the element

18064941211227179925228040535007972296

48438766985538871240722010849934886421

of Fq (split onto two lines here for readability); deﬁne c =
2/s2; and deﬁne d = −(c + 1)2/(c − 1)2. Then d = −1174.
The Edwards curve in Theorem 1 and Deﬁnition 2, for this
choice of (q, s), is exactly Curve1174.
Curve1174 is birationally equivalent to the Montgomery
curve (4/1175)V 2 = U 3 +(4/1175−2)U 2 +U by [9, Theorem
3.2]. The leading coeﬃcient 4/1175 is a non-square in Fq,
so V 2 = U 3 + (4/1175 − 2)U 2 + U is a nontrivial quadratic
twist of this curve. The Sage computer-algebra system [46]
counts points on this curve in under 10 seconds on a laptop
using the following script:

q=2^251-9
E=EllipticCurve(GF(q),[0,4/1175-2,0,1,0])
print E.trace_of_frobenius()
# output -45330879683285730139092453152713398836

The number of points on the twist is thus q + 1 + t, and
the number of points on Curve1174 is q + 1 − t, where t =
45330879683285730139092453152713398836. These integers

975q + 1 + t, q + 1− t have the form 4p0, 4p1 respectively, where
p0 and p1 are primes close to 2249. Generic methods to
√
compute a discrete logarithm on Curve1174 or its twist take
π2247 ≈ 2124.3 group operations on average.
approximately
The point (U, V ) = (4, 192257776421116702304087124422
05514783403012708409058383774613284963344096) on the
Montgomery curve (4/1175)V 2 = U 3 + (4/1175 − 2)U 2 + U
has order 4p1. The corresponding point on Curve1174 is
(x, y) = (4/V, 3/5).

Curve1174 and its twist do not have any structure al-
lowing fast pairings or other special approaches to com-
puting discrete logarithms. The primes p0 and p1 do not
equal the ﬁeld characteristic q. The order of q modulo
it is (p0 − 1)/2. The order of q modulo
p0 is not small:
it is p1 − 1. The endomorphism ring of
p1 is not small:
Curve1174 has a large discriminant: up to squares this dis-
criminant equals t2−4q, which is divisible once by the prime
161567415114024992333870349255799, so the discriminant
must be a multiple of this prime.

4.2 Design criteria

We consider only prime ﬁelds. Bernstein, citing subﬁeld
attacks from [28] and [18], wrote in [6] that prime ﬁelds “have
the virtue of minimizing the number of security concerns
for elliptic-curve cryptography”; see [22] and [43] for recent
developments of the attack strategy from [18]. Similarly, the
Brainpool standard [14] and NSA’s Suite B standards [37]
require prime ﬁelds. There is general agreement that prime
ﬁelds are the safe, conservative choice for ECC. Prime ﬁelds
also perform very well across a wide range of processors; the
current ECC speed records on high-end Intel processors take
advantage of special Intel support for binary ﬁelds (see [42]),
but most CPUs do not have any comparable support.

We consider only primes q congruent to 3 modulo 4. This
is required for the injective map φ. These primes also have
the well-known beneﬁt of allowing very simple square-root
computations; most other primes allow square-root compu-
tations at similar speed but with more complicated methods.
We consider only complete Edwards curves, i.e., curves
x2 + y2 = 1 + dx2y2 where d is not a square. This is re-
quired for the injective map. About 25% of all elliptic curves
over Fq are expressible as complete Edwards curves, as men-
tioned in [9, Abstract] and experimentally veriﬁed in [7, Sec-
tion 4]. Complete Edwards curves also have the advantages
of being extremely fast and of allowing a single addition for-
mula with no exceptions. Complete Edwards curves are also
expressible as Montgomery curves supporting very fast and
uniform Montgomery-ladder computations.

To protect against generic discrete-logarithm algorithms
we impose the standard requirement of a large prime divid-
ing the number of curve points. This forces q to be even
larger, where the gap accounts for the cofactor: the number
of curve points divided by this prime. To minimize the per-
formance problems of a large q we consider only Edwards
curves with minimal cofactor, namely 4. The number of
curve points is 4 times a prime for slightly below 1% of all
choices of d, for the size of q that we consider below.

We also impose the requirement of “twist security”: a large
prime dividing the number of points on the quadratic twist
of the curve. This prevents “twist attacks” against protocols
that use the “Montgomery ladder” without checking that
incoming points are on the curve; this defense was proposed
by Bernstein in [5, page 23] and [4]. For q ≡ 3 (mod 4)

roughly 1/10000 of all choices of d have the number of points
on the curve and the number of points on the twist each
being 4 times a prime.
We require d to have the form −(c + 1)2/(c − 1)2 with
c = 2/s2. This is required for the injective map, and covers
about half of all non-squares d for q ≡ 3 (mod 4).
For standard performance reasons we take q very close to,
but not above, a power of 2. The primes q ≡ 3 (mod 4)
within 32 of 2e for 200 ≤ e ≤ 300 are 2206 − 5, 2212 − 29,
2226 − 5, 2243 − 9, 2251 − 9, and 2285 − 9. Note that these

ﬁelds ensure that σ−1 covers nearly all of(cid:8)0, 1, . . . , 2b − 1(cid:9)

giving a very close to uniform distribution of the encoding
function. We focus on the last two of these primes as pro-
viding quantitatively safe security levels, and choose 2251−9
as being obviously faster.

Some curve operations involve multiplications by d. To
speed up these multiplications we take the smallest possible
d in absolute value, subject to the other requirements. The
choice d = −1174 for q = 2251 − 9 is smaller than expected.

4.3 Previous curves over prime ﬁelds

There is a long history of speciﬁc elliptic curves being de-
signed to meet various security and performance criteria.
For example, almost ﬁfteen years ago the IEEE P1363 stan-
dard [33, Sections A.9–A.12]

• speciﬁed curves y2 = x3− 3x + b to “provide the fastest

arithmetic on elliptic curves”;

• imposed various further conditions upon these curves,
with the security goal of making discrete logarithms
diﬃcult to compute; and

• speciﬁed a procedure to generate “veriﬁably pseudo-

random” curves meeting these conditions.

NIST’s standard curves P-192, P-224, P-256, P-384, and P-
521 were generated as follows: ﬁve particular prime ﬁelds
were chosen with the goal of maximizing performance; the
IEEE P1363 procedure was used to generate one curve over
each of those ﬁelds.

Subsequent research developed new security and perfor-
mance criteria for curves over prime ﬁelds:
twist secu-
rity, Montgomery compatibility, Edwards compatibility, and
completeness. The NIST curves, unsurprisingly, ﬂunk these
criteria: choosing cofactor 1 for y2 = x3−3x+b is incompat-
ible with both Montgomery and Edwards, and one cannot
expect twist security if it is not demanded in advance. Newer
curves meet all of these criteria: for example, Curve25519
was explicitly designed for twist security and Montgomery
compatibility, and was shown in [9] to also be expressible as
a complete Edwards curve.

These extra criteria do not improve discrete-logarithm se-
curity, but they do improve real-world security. They allow
the simplest implementations to be correct implementations,
whereas for other curves the simplest implementations that
seem to work actually have hidden ﬂaws that compromise
security. See, e.g., [11, Section 4.1], [34], and [24].

We are imposing a new security condition to support cen-
sorship circumvention: namely, an eﬃcient way to encode a
large fraction of all curve points as strings indistinguishable
from uniform random strings. The generality of Elligator 1
makes it easy to imagine how this security condition could
be accidentally met by previously generated curves:

976• The advantages of complete Edwards curves have been

well known for ﬁve years.

• The advantages of Montgomery curves have been well
known for even longer. A random Montgomery curve
has a good chance of being expressible as a complete
Edwards curve; see [7, Section 4].

• All complete Edwards curves over Fq for q ≡ 3
(mod 4) meet the new security condition. Half of these
curves are within the streamlined case expressed by
Theorem 1.

Given the amount of speed optimization of Curve25519 (see
[6], [29], [17], [8], and [10]) and the wide deployment of
Curve25519 in several applications (see, e.g., [2]) one of our
initial goals for this paper was to show that Curve25519
meets this security condition. However, Elligator 1 is clearly
limited to q ≡ 3 (mod 4), while Curve25519 is deﬁned over
Fq with q ≡ 1 (mod 4). We provide two diﬀerent solutions
for this problem: Elligator 2 (see Section 5) and Curve1174.
We would expect serious implementations of Curve1174
to be competitive in speed with Curve25519. Curve1174 has
some small advantages: for example, 2251 − 9 is closer to a
power of 2 than 2255−19 is; 1174 is considerably smaller than
486662; and square roots modulo 2251 − 9 are slightly easier
than square roots modulo 2255 − 19. On the other hand,
Curve25519 also has a small advantage: it is expressible in
“−1-twisted Edwards form”, allowing the speedup explained
in [31]. Obviously applications already using Curve25519
should not switch away from it, but for new applications it
is not clear which curve is better.

5. ELLIGATOR 2: HANDLING GENERIC
CURVES WITH A POINT OF ORDER 2
This section introduces a new injective map ψ to any ellip-
tic curve of the form y2 = x3+Ax2+Bx with AB(A2−4B) (cid:54)=
0 over any odd ﬁnite ﬁeld, i.e., any ﬁnite ﬁeld of odd charac-
teristic. We emphasize that the characteristic is not required
to be 3 modulo 4. This curve shape includes all Montgomery
curves y2 = x3+Ax2+x except y2 = x3+x, and in particular
it includes Curve25519.

Any curve of this form has a point (0, 0) of order 2. Con-
versely, over any odd ﬁnite ﬁeld, almost every elliptic curve
having a point of order 2 can be written in this form. Indeed,
an elliptic curve over an odd ﬁnite ﬁeld can always be written
as y2 = u3 + a2u2 + a4u + a6; a point of order 2 on this curve
must have the form (r, 0) where r3 +a2r2 +a4r+a6 = 0; sub-
stituting u = x + r produces the curve y2 = x3 + Ax2 + Bx
where A = a2 + 3r and B = a4 + 2a2r + 3r2. This curve
must have B(A2 − 4B) (cid:54)= 0 since it is elliptic. The only ex-
ceptional case is A = 0, i.e., curves whose j-invariant equals
1728; this section assumes A (cid:54)= 0.
5.1 Squares
Fix an odd prime power q. As in Section 3.1 we deﬁne
χ : Fq → Fq by χ(a) = a(q−1)/2, and we have χ(a) equal
to 1, −1, or 0 when a is, respectively, a non-zero square, a
non-square, or zero.

The deﬁnition of Elligator 2 is parametrized by a square-
q → Fq such
q means
is com-

(cid:9). Note that a square-root function

√
a2 ∈ {a,−a} for each a ∈ Fq, where F2
√

root function for Fq: a function
that

(cid:8)a2 : a ∈ Fq
pletely described by its image(cid:112)F2

: F2

q.

√

as a square-root function, i.e., take (cid:112)F2
take(cid:112)F2

For q ≡ 3 (mod 4) one can take the principal square root
q, as in Sec-
tion 3.1; but the concept of principal square roots does not
generalize to q ≡ 1 (mod 4). For any odd prime q one can
q = {0, 1, . . . , (q − 1)/2}. Other choices sometimes

q = F2

have computational beneﬁts.
The deﬁnition of Elligator 2 is also parametrized by a non-
square u ∈ Fq. If q ≡ 3 (mod 4) then one can take u = −1.
If q ≡ 5 (mod 8) then one can take u = 2. Finding a non-
square is an easy computation in general since about half
of the elements of Fq are non-squares. For eﬃciency it is
desirable to choose u to be small, or otherwise to choose u
to speed up multiplications by u.
5.2 The map

Theorem 5. Let q be an odd prime power. Let A, B be
elements of Fq such that AB(A2 − 4B) (cid:54)= 0. Let u be a
be a square-root function for Fq.
non-square in Fq. Let
Deﬁne R as the set

(cid:8)r ∈ Fq : 1 + ur2 (cid:54)= 0, A2ur2 (cid:54)= B(1 + ur2)2(cid:9).

√

The following elements of Fq are deﬁned for each nonzero
r ∈ R:

v = −A/(1 + ur2),
 = χ(v3 + Av2 + Bv),
x = v − (1 − )A/2,
y = −

(cid:112)

x3 + Ax2 + Bx.

R = Fq.

Furthermore vxy (cid:54)= 0 and y2 = x3 + Ax2 + Bx.

If q ≡ 1 (mod 4) and A2 − 4B is a non-square in Fq then
Proof. v is deﬁned and v (cid:54)= 0: By hypothesis A (cid:54)= 0
and 1 + ur2 (cid:54)= 0.
v3+Av2+Bv (cid:54)= 0 and  (cid:54)= 0: Note that v+vur2 = −A
so v2 + Av = v(v + A) = v(−vur2). If v2 + Av + B = 0 then
v2ur2 = B so, using the deﬁnition of v, A2ur2 = B(1+ur2)2,
contradicting the deﬁnition of R. Hence v2 + Av + B (cid:54)= 0,
so v3 + Av2 + Bv (cid:54)= 0, so  (cid:54)= 0.
x3 + Ax2 + Bx is a nonzero square and x (cid:54)= 0:
There are two cases. First case:  = 1, i.e., v3 + Av2 + Bv is
a nonzero square. Then x = v so x3 + Ax2 + Bx is a nonzero
square; and x (cid:54)= 0 since v (cid:54)= 0.
Second case:  = −1, i.e., v3 + Av2 + Bv is a non-square.
Then x = −v − A = vur2. All factors v, u, r2 here are
nonzero so x (cid:54)= 0; note also that χ(x) = χ(v)χ(u) = −χ(v).
Furthermore x(x + A) = (−v − A)(−v) = v(v + A) so x2 +
Ax + B = v2 + Av + B so χ(x3 + Ax2 + Bx) = −χ(v3 +
Av2 + Bv) = − = 1 so x3 + Ax2 + Bx is a nonzero square.
y is deﬁned, y2 = x3 + Ax2 + Bx, and y (cid:54)= 0:
√
√
x3 + Ax2 + Bx is a nonzero square so
x3 + Ax2 + Bx is
deﬁned; all factors in y = −
x3 + Ax2 + Bx are nonzero,
and y2 = x3 + Ax2 + Bx.
If q ≡ 1 (mod 4) and A2 − 4B is a non-square
then R = Fq: Fix r ∈ Fq, and write s = ur2. Then
χ(s) ∈ {0,−1} while χ(±1) = 1 so s (cid:54)= ±1. In particular
1 + ur2 (cid:54)= 0.
Suppose that A2s = B(1 + s)2. Subtract 4Bs to obtain
(A2−4B)s = B(1−s)2. Multiply to obtain (A2−4B)A2s2 =
B2(1 + s)2(1 − s)2. By hypothesis χ(A2 − 4B) = −1 so
χ((A2 − 4B)A2s2) ∈ {−1, 0}, while all of B, 1 + s, 1 − s
are nonzero so χ(B2(1 + s)2(1 − s)2) = 1, contradiction.
Consequently A2ur2 (cid:54)= B(1 + ur2)2.

977Definition 6. In the situation of Theorem 5, the de-
coding function for the Weierstrass curve E : y2 =
x3 + Ax2 + Bx is the function ψ : R → E(Fq) deﬁned as
follows: ψ(0) = (0, 0); if r (cid:54)= 0 then ψ(r) = (x, y).

A2 − 4B)/(2uB) to ((−A±√

With more work one can extend the deﬁnition of ψ to
cover elements of Fq outside R. For example, if A2 − 4B
√
is a square then one can map any square roots in Fq of
A2 − 4B)/2, 0).
(A2−2B±A
However, our main interest is in the case R = Fq, and then
this extra work is unnecessary.
5.3 Inverting the map

Theorem 7. In the situation of Deﬁnition 6:
1. If r ∈ R then the set of preimages of ψ(r) under ψ is

{r,−r}.

2. ψ(R) is the set of (x, y) ∈ E(Fq) such that

• x (cid:54)= −A,
• if y = 0 then x = 0, and
• −ux(x + A) is a square in Fq.

3. If (x, y) ∈ ψ(R) then the following element ¯r of R is

deﬁned and ψ(¯r) = (x, y):

(cid:40)(cid:112)−x/((x + A)u)
(cid:112)−(x + A)/(ux)

if y ∈(cid:112)F2
if y /∈(cid:112)F2

q;
q.

¯r =

Proof. 1. If r = 0 then r = −r so ψ(r) = ψ(−r). If
r (cid:54)= 0 then Theorem 5 deﬁnes ψ(r) purely in terms of r2 so
ψ(r) = ψ(−r).
Conversely, assume that ψ(r) = ψ(r(cid:48)); our goal is to show
that r(cid:48) ∈ {r,−r}. If r = 0 then ψ(r) = (0, 0), and otherwise
ψ(r) has nonzero coordinates by Theorem 5; hence r = 0 if
and only if r(cid:48) = 0. The only remaining case is that r (cid:54)= 0
and r(cid:48) (cid:54)= 0.
Then
(x(cid:48), y(cid:48)) = ψ(r(cid:48)) = ψ(r) = (x, y). Furthermore y =
−
is a function. Next x = v−(1−)A/2 and
so (cid:48) =  since
x(cid:48) = (cid:48)v(cid:48)− (1− (cid:48))A/2 so v(cid:48) = v. Finally 1 + ur2 = 1 + u(r(cid:48))2
so r(cid:48) ∈ {r,−r} as claimed.

x3 + Ax2 + Bx and y(cid:48) = −(cid:48)(cid:112)(x(cid:48))3 + A(x(cid:48))2 + B(x(cid:48))

Deﬁne v(cid:48), (cid:48), x(cid:48), y(cid:48)
√

from r(cid:48) as in Theorem 5.

√

2. Fix r ∈ R, and write (x, y) = ψ(r).

If r = 0 then
(x, y) = (0, 0) so x = 0; x (cid:54)= −A; and −ux(x + A) = 0
is a square. If r (cid:54)= 0 then (x, y) is deﬁned in Theorem 5,
and there are two cases. The ﬁrst case is that  = 1; then
x = v (cid:54)= −A since ur2 (cid:54)= 0. The second case is that  = −1;
then x = −v − A (cid:54)= −A since v (cid:54)= 0. In both cases y (cid:54)= 0 by
Theorem 5, and −ux(x+A) = −uv(v+A) = −uv(−vur2) =
u2v2r2, which is a square.
Conversely, assume that (x, y) ∈ E(Fq), that x (cid:54)= −A,
then if y = 0 then x = 0, and that −ux(x + A) is a square.
Our goal is to show that (x, y) ∈ ψ(R). We will in fact show
more: (x, y) = ψ(¯r) where ¯r is deﬁned as in the third part
of the theorem statement.
√

If y = 0 then x = 0 by assumption. Furthermore y =
q and −x/((x + A)u) = 0 so ¯r is deﬁned as 0.
Hence (x, y) = (0, 0) = ψ(0) = ψ(¯r) as claimed.
Assume from now on that y (cid:54)= 0. The curve equation then
implies that x (cid:54)= 0. Now (x + A)u and ux are both nonzero,
and both −x/((x + A)u) and −(x + A)/(ux) are squares, so
¯r is deﬁned and nonzero. We will see below that 1 + u¯r2 (cid:54)= 0

0 ∈ (cid:112)F2

If y ∈(cid:112)F2

and A2u¯r2 (cid:54)= B(1 + u¯r2)2, so ¯r ∈ R. Deﬁne ¯v, ¯, ¯x, ¯y as in
Theorem 5.
q then ¯r2 = −x/((x + A)u) so 1 + u¯r2 = A/(x +
A) so ¯v = −x − A so χ(¯v) = χ(−x − A) = χ(ux) = −χ(x).
Next ¯v2 + A¯v + B = x2 + Ax + B so ¯ = χ(¯v3 + A¯v2 + B¯v) =
−χ(x3 + Ax2 + Bx) = −1. Consequently ¯x = −¯v − A = x
√
and ¯y = −¯
x3 + Ax2 + Bx =
−√
The remaining case is that y
i.e., y =
x3 + Ax2 + Bx. Then ¯r2 = −(x + A)/(ux) so 1 + u¯r2 =
−A/x so ¯v = x. Now ¯v3+A¯v2+B¯v = x3+Ax2+Bx so ¯ = 1.
√
Consequently ¯x = ¯v = x and ¯y = −¯
−√
x3 + Ax2 + Bx =
x3 + Ax2 + Bx = y.
In both cases we have ¯v2 + A¯v + B = x2 + Ax + B (cid:54)= 0 so
A2u¯r2 (cid:54)= B(1 + u¯r2)2.

/∈ (cid:112)F2

x3 + Ax2 + Bx = y.

√

q,

3. Fix (x, y) ∈ ψ(R). We showed above that x (cid:54)= −A;
that if y = 0 then x = 0; and that −ux(x + A) is a square.
We also showed that under these conditions ¯r is deﬁned and
ψ(¯r) = (x, y).
5.4 Encoding as strings

σ : {0, 1}b → Fq by σ(ρ0, ρ1, . . . , ρb−1) = (cid:80)

Theorem 8. In the situation of Deﬁnition 6, assume
that q is prime, that q ≡ 1 (mod 4), and that A2 − 4B
is not a square in Fq. Deﬁne b = (cid:98)log2 q(cid:99). Deﬁne
i ρi2i. Deﬁne
S = σ−1({0, 1, 2, . . . , (q − 1)/2}). Deﬁne ι : S → E(Fq) as
follows: ι(ρ) = ψ(σ(ρ)). Then #S = (q + 1)/2; ι is an
injective map from S to E(Fq); and ι(S) = ψ(Fq).

Proof. Note that R = Fq by Theorem 5; i.e., ψ is de-
ﬁned on all of Fq. The rest of the proof is identical to the
proof of Theorem 4 with φ replaced by ψ, τ replaced by ρ,
Theorem 1 replaced by Theorem 5, and Theorem 3 replaced
by Theorem 7.
5.5 Application of ψ to Curve25519
Curve25519 is the curve y2 = x3 + Ax2 + Bx over Fq with
q = 2255 − 19, A = 486662, and B = 1. Here q ≡ 1 (mod 4)
and A2 − 4B is a non-square in Fq, so R = Fq.

√

√−1(cid:12)(cid:12) otherwise.

a as |b| if b2 = a and as(cid:12)(cid:12)b

We take u = 2. We copy from [8] the following standard
eﬃciently computable square-root function for Fq. Given
a square a ∈ Fq compute b = a(q+3)/8; note that q ≡ 5
(mod 8), so (q + 3)/8 is an integer. Then b4 = a2, i.e., b2 ∈
{a,−a}. Deﬁne
Here |b| means b if b ∈ {0, 1, . . . , (q − 1)/2}, otherwise −b.
Computing ι takes 1 square-root computation, 1 inversion,
1 computation of χ, and a few multiplications. Note that the
inversion and the square-root computation can be combined
into one exponentiation, as in [8]. The computation of χ
can also be combined into the square-root computation as
follows. First compute a power of v3 + Av2 + Bv as above,
obtaining a square root of v3 + Av2 + Bv if v3 + Av2 + Bv
is a square. If the square of this power turns out to match
v3 + Av2 + Bv then  = 1 and x = v. Otherwise  = −1,
x = vur2, and x3 +Ax2 +Bx = ur2(v3 +Av2 +Bv); multiply
the previous power by r and by a precomputed power of u
to obtain a square root of x3 + Ax2 + Bx.
Similar comments apply to computing the inverse map.
Checking for P ∈ ι(S) takes 1 squaring and a computation
of χ to obtain χ((x + A/2)2 − A2/4) = χ(x(x + A)).

This map and its inverse seem simplest to describe in
Weierstrass coordinates, but maps to and from Edwards
form, and other curve shapes, are also easily obtained.

9786. REFERENCES
[1] Appelbaum, J., and Dingledine, R. How governments have tried

to block Tor, 2011. http:
//ftp.ccc.de/congress/28C3/mp4-h264-HQ/28c3-4800-en-how_
governments_have_tried_to_block_tor_h264.mp4.

[2] Apple. iOS security, 2012. http://images.apple.com/iphone/

business/docs/iOS_Security_Oct12.pdf.

[3] Bellare, M., Desai, A., Jokipii, E., and Rogaway, P. A

concrete security treatment of symmetric encryption. In FOCS
(1997), IEEE Computer Society, pp. 394–403.

[4] Bernstein, D. J. Current consensus on ECC, 2001.

https://groups.google.com/forum/message/raw?msg=sci.crypt/
mu_paShEU3w/m491pYxHbtAJ.

[5] Bernstein, D. J. A software implementation of NIST P-224,

2001. http://cr.yp.to/talks.html#2001.10.29.

[6] Bernstein, D. J. Curve25519: New Diﬃe-Hellman speed
records. In Public Key Cryptography (2006), M. Yung,
Y. Dodis, A. Kiayias, and T. Malkin, Eds., vol. 3958 of LNCS,
Springer, pp. 207–228.

[7] Bernstein, D. J., Birkner, P., Joye, M., Lange, T., and Peters,

C. Twisted Edwards curves. In AFRICACRYPT (2008),
S. Vaudenay, Ed., vol. 5023 of LNCS, Springer, pp. 389–405.

[8] Bernstein, D. J., Duif, N., Lange, T., Schwabe, P., and Yang,

B.-Y. High-speed high-security signatures. J. Cryptographic
Engineering 2, 2 (2012), 77–89.

[9] Bernstein, D. J., and Lange, T. Faster addition and doubling
on elliptic curves. In ASIACRYPT (2007), K. Kurosawa, Ed.,
vol. 4833 of LNCS, Springer, pp. 29–50.

[10] Bernstein, D. J., and Schwabe, P. NEON crypto. In CHES

(2012), E. Prouﬀ and P. Schaumont, Eds., vol. 7428 of LNCS,
Springer, pp. 320–339.

[11] Biehl, I., Meyer, B., and M¨uller, V. Diﬀerential fault attacks

on elliptic curve cryptosystems. In CRYPTO (2000),
M. Bellare, Ed., vol. 1880 of LNCS, Springer, pp. 131–146.

[12] Boneh, D., and Franklin, M. K. Identity-based encryption from
the Weil pairing. In CRYPTO (2001), J. Kilian, Ed., vol. 2139
of LNCS, Springer, pp. 213–229.

[13] Boyd, C., Montague, P., and Nguyen, K. Q. Elliptic curve

based password authenticated key exchange protocols. In
ACISP (2001), V. Varadharajan and Y. Mu, Eds., vol. 2119 of
LNCS, Springer, pp. 487–501.

[14] Brainpool. ECC Brainpool standard curves and curve

generation, v. 1.0, 2005.
http://www.ecc-brainpool.org/download/Domain-parameters.pdf.

[15] Brier, E., Coron, J.-S., Icart, T., Madore, D., Randriam, H.,

and Tibouchi, M. Eﬃcient indiﬀerentiable hashing into
ordinary elliptic curves. In CRYPTO (2010), T. Rabin, Ed.,
vol. 6223 of LNCS, Springer, pp. 237–254.

[16] Brier, E., and Joye, M. Weierstraß elliptic curves and

side-channel attacks. In Public Key Cryptography (2002),
D. Naccache and P. Paillier, Eds., vol. 2274 of LNCS, Springer,
pp. 335–345.

[17] Costigan, N., and Schwabe, P. Fast elliptic-curve cryptography

on the Cell Broadband Engine. In AFRICACRYPT (2009),
B. Preneel, Ed., vol. 5580 of LNCS, Springer, pp. 368–385.

[18] Diem, C. The GHS attack in odd characteristic. J. Ramanujan

Mathematical Society 18 (2003), 1–32.

M. Joye, A. Miyaji, and A. Otsuka, Eds., vol. 6487 of LNCS,
Springer, pp. 265–277.

[26] Fouque, P.-A., and Tibouchi, M. Estimating the size of the
image of deterministic hash functions to elliptic curves. In
LATINCRYPT (2010), M. Abdalla and P. S. L. M. Barreto,
Eds., vol. 6212 of LNCS, Springer, pp. 81–91.

[27] Fouque, P.-A., and Tibouchi, M. Indiﬀerentiable hashing to
Barreto-Naehrig curves. In LATINCRYPT (2012), A. Hevia
and G. Neven, Eds., vol. 7533 of LNCS, Springer, pp. 1–17.

[28] Frey, G. How to disguise an elliptic curve (Weil descent), 1998.

http://www.cacr.math.uwaterloo.ca/conferences/1998/ecc98/
slides.html.

[29] Gaudry, P., and Thom´e, E. The mpFq library and

implementing curve-based key exchanges. In SPEED: software
performance enhancement for encryption and decryption
(2007), pp. 49–64.

[30] Goldberg, I., Stebila, D., and Ustaoglu, B. Anonymity and

one-way authentication in key exchange protocols. Des. Codes
Cryptography 67, 2 (2013), 245–269.

[31] Hisil, H., Wong, K. K.-H., Carter, G., and Dawson, E. Twisted
Edwards curves revisited. In ASIACRYPT (2008), J. Pieprzyk,
Ed., vol. 5350 of LNCS, Springer, pp. 326–343.

[32] Icart, T. How to hash into elliptic curves. In CRYPTO (2009),

S. Halevi, Ed., vol. 5677 of LNCS, Springer, pp. 303–316.

[33] Institute of Electrical and Electronics Engineers. P1363
Draft Standard Speciﬁcations for Public Key Cryptography.
IEEE, 1999.

[34] Izu, T., and Takagi, T. Exceptional procedure attack on elliptic

curve cryptosystems. In Public Key Cryptography (2003),
Y. Desmedt, Ed., vol. 2567 of LNCS, Springer, pp. 224–239.

[35] Kaliski Jr., B. S. A pseudo-random bit generator based on

elliptic logarithms. In CRYPTO (1986), A. M. Odlyzko, Ed.,
vol. 263 of LNCS, Springer, pp. 84–103.

[36] Kaliski Jr., B. S. Elliptic Curves and Cryptography: A

Pseudorandom Bit Generator and Other Tools. PhD thesis,
MIT, 1988. MIT/LCS/TR-411.

[37] Law, L. E., and Solinas, J. A. Suite B cryptographic suites for

IPsec, 2011. https://tools.ietf.org/html/rfc6379.

[38] Lidl, R., and Niederreiter, H. Finite Fields. Encyclopedia of

Mathematics and its Applications. Cambridge University Press,
1997.

[39] L´opez, J., and Dahab, R. Fast multiplication on elliptic curves

over GF(2m) without precomputation. In CHES (1999), ¸C.
K. Ko¸c and C. Paar, Eds., vol. 1717 of LNCS, Springer,
pp. 316–327.

[40] M¨oller, B. A public-key encryption scheme with

pseudo-random ciphertexts. In Computer Security—ESORICS
2004, P. Samarati, P. Ryan, D. Gollmann, and R. Molva, Eds.,
vol. 3193 of LNCS. Springer Berlin Heidelberg, 2004,
pp. 335–351.

[41] Montgomery, P. L. Speeding the Pollard and elliptic curve

methods of factorization. Math. Comp. 48, 177 (1987),
243–264.

[42] Oliveira, T., L´opez, J., Aranha, D. F., and

Rodr´ıguez-Henr´ıquez, F. Lambda coordinates for binary
elliptic curves. In CHES (2013), G. Bertoni and J.-S. Coron,
Eds., vol. 8086 of LNCS, Springer, pp. 311–330.

[19] Dingledine, R., Mathewson, N., and Syverson, P. F. Tor: The

[43] Petit, C., and Quisquater, J.-J. On polynomial systems arising

second-generation onion router. In USENIX Security
Symposium (2004), USENIX, pp. 303–320.

[20] Farashahi, R. R. Hashing into Hessian curves. In

AFRICACRYPT (2011), A. Nitaj and D. Pointcheval, Eds.,
vol. 6737 of LNCS, Springer, pp. 278–289.

[21] Farashahi, R. R., Fouque, P.-A., Shparlinski, I., Tibouchi, M.,

and Voloch, J. F. Indiﬀerentiable deterministic hashing to
elliptic and hyperelliptic curves. Math. Comput. 82, 281 (2013).

[22] Faug`ere, J.-C., Perret, L., Petit, C., and Renault, G.

Improving the complexity of index calculus algorithms in
elliptic curves over binary ﬁelds. In EUROCRYPT (2012),
D. Pointcheval and T. Johansson, Eds., vol. 7237 of LNCS,
Springer, pp. 27–44.

[23] Fouque, P.-A., Joux, A., and Tibouchi, M. Injective encodings
to elliptic curves. In ACISP (2013), C. Boyd and L. Simpson,
Eds., vol. 7959 of LNCS, Springer, pp. 203–218.

[24] Fouque, P.-A., Lercier, R., R´eal, D., and Valette, F. Fault

attack on elliptic curve Montgomery ladder implementation. In
FDTC (2008), L. Breveglieri, S. Gueron, I. Koren, D. Naccache,
and J.-P. Seifert, Eds., IEEE Computer Society, pp. 92–98.

[25] Fouque, P.-A., and Tibouchi, M. Deterministic encoding and

hashing to odd hyperelliptic curves. In Pairing (2010),

from a Weil descent. In ASIACRYPT (2012), X. Wang and
K. Sako, Eds., vol. 7658 of LNCS, Springer, pp. 451–466.

[44] Rogaway, P., and Shrimpton, T. A provable-security treatment

of the key-wrap problem. In EUROCRYPT (2006),
S. Vaudenay, Ed., vol. 4004 of LNCS, Springer, pp. 373–390.

[45] Shallue, A., and van de Woestijne, C. Construction of rational

points on elliptic curves over ﬁnite ﬁelds. In ANTS (2006),
F. Hess, S. Pauli, and M. E. Pohst, Eds., vol. 4076 of LNCS,
Springer, pp. 510–524.

[46] Stein, W., et al. Sage Mathematics Software (Version 2.9).
The Sage Development Team, 2013. http://www.sagemath.org.
[47] Weinberg, Z., Wang, J., Yegneswaran, V., Briesemeister, L.,

Cheung, S., Wang, F., and Boneh, D. StegoTorus: a camouﬂage
proxy for the Tor anonymity system. In ACM Conference on
Computer and Communications Security (2012), T. Yu,
G. Danezis, and V. D. Gligor, Eds., ACM, pp. 109–120.

[48] Wustrow, E., Wolchok, S., Goldberg, I., and Halderman,

J. A. Telex: Anticensorship in the network infrastructure. In
USENIX Security Symposium (2011), USENIX Association.

[49] Young, A. L., and Yung, M. Kleptography from standard

assumptions and applications. In SCN (2010), J. A. Garay and
R. D. Prisco, Eds., vol. 6280 of LNCS, Springer, pp. 271–290.

979