OblivP2P: An Oblivious Peer-to-Peer  

Content Sharing System

Yaoqi Jia, National University of Singapore; Tarik Moataz, Colorado State University and 
Telecom Bretagne; Shruti Tople and Prateek Saxena, National University of Singapore

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/jia

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX OBLIVP2P: An Oblivious Peer-to-Peer Content Sharing System

Yaoqi Jia1∗

Tarik Moataz2∗

Shruti Tople1∗

Prateek Saxena1

1National University of Singapore
{jiayaoqi, shruti90, prateeks}@comp.nus.edu.sg

2Colorado State University and Telecom Bretagne

tarik.moataz@colostate.edu

Abstract

Peer-to-peer (P2P) systems are predominantly used to
distribute trust, increase availability and improve perfor-
mance. A number of content-sharing P2P systems, for
ﬁle-sharing applications (e.g., BitTorrent and Storj) and
more recent peer-assisted CDNs (e.g., Akamai Netses-
sion), are ﬁnding wide deployment. A major security
concern with content-sharing P2P systems is the risk of
long-term trafﬁc analysis — a widely accepted challenge
with few known solutions.

In this paper, we propose a new approach to protecting
against persistent, global trafﬁc analysis in P2P content-
sharing systems. Our approach advocates for hiding
data access patterns, making P2P systems oblivious. We
propose OBLIVP2P— a construction for a scalable dis-
tributed ORAM protocol, usable in a real P2P setting.
Our protocol achieves the following results. First, we
show that our construction retains the (linear) scalability
of the original P2P network w.r.t the number of peers.
Second, our experiments simulating about 16,384 peers
on 15 Deterlab nodes can process up to 7 requests of
512KB each per second, suggesting usability in mod-
erately latency-sensitive applications as-is. The bottle-
necks remaining are purely computational (not band-
width). Third, our experiments conﬁrm that in our con-
struction, no centralized infrastructure is a bottleneck —
essentially, ensuring that the network and computational
overheads can be completely ofﬂoaded to the P2P net-
work. Finally, our construction is highly parallelizable,
which implies that remaining computational bottlenecks
can be drastically reduced if OBLIVP2P is deployed on
a network with many real machines.
1

Introduction

Content sharing peer-to-peer (P2P) systems, especially
P2P ﬁle-sharing applications such as BitTorrent [1],
Storj [2] and Freenet [3] are popular among users for

∗Lead authors are alphabetically ordered.

1

sharing ﬁles on the Internet. More recently, peer-assisted
CDNs such as Akamai Netsession [4] and Squirrel [5]
are gaining wide adoption to ofﬂoad web CDN trafﬁc to
clients. The convenient access to various resources at-
tract millions of users to join P2P networks, e.g., BitTor-
rent has over 150 million active users per month [6] and
its ﬁle-sharing service contributes 3.35% of all world-
wide bandwidth [7]. However, the majority of such P2P
applications are susceptible to long-term trafﬁc analy-
sis through global monitoring; especially, analyzing the
pattern of communication between a sender and a re-
ceiver to infer information about the users. For exam-
ple, many copyright enforcement organizations such as
IFPI, RIAA, MPAA, government agencies like NSA and
ISP’s are reported to globally monitor BitTorrent trafﬁc
to identify illegal actors. Monitoring of BitTorrent traf-
ﬁc has shown to reveal the data requested and sent by the
peers in the network [8–10]. Unfortunately, while detect-
ing copyright infringements is useful, the same global
monitoring is applicable to any user of the P2P network,
and can therefore collect benign users’ data. Thus, users
of such P2P systems are at a risk of leaking private infor-
mation such as the resources they upload or download.

To hide their online traces, users today employ anony-
mous networks as a solution to conceal their digital
identities or data access habits. Currently, anonymous
networks include Mix networks [11–13], and Onion
routing/Tor-based systems [14–17], as well as other P2P
anonymity systems [18–23]. Such systems allow the user
to be anonymous, so that the user is unidentiﬁable within
a set of users [24].

Although above solutions provide an anonymity guar-
antee, they are vulnerable to long-term trafﬁc pattern
analysis attacks, which is an important threat for P2P sys-
tems like BitTorrent [25–30]. Researchers have demon-
strated attacks targeting BitTorrent users on top of Tor
that reveal information related to the resources uploaded
or downloaded [31, 32]. Such attacks raise the question
- is anonymizing users the right defense against trafﬁc

USENIX Association  

25th USENIX Security Symposium  945

pattern analysis in P2P content sharing systems?

tributing the communication and computation overhead.

In this paper, we investigate a new approach to solve
the problem of persistent analysis of data communication
patterns. We advocate that data / resource access pattern
hiding is an important and necessary step to thwart leak-
age of users data in P2P systems. To this end, we present
a ﬁrst candidate solution, OBLIVP2P— an oblivious pro-
tocol for peer-to-peer content sharing systems. Hiding
data access patterns or making them oblivious unlinks
user’s identity from her online traces, thereby defending
against long-term trafﬁc monitoring.

1.1 Approach
For hiding data access patterns between a trusted CPU
and an untrusted memory, Goldreich and Ostrovsky pro-
posed the concept of an Oblivious RAM (ORAM) [33].
We envision providing similar obliviousness guarantees
in P2P systems, and therefore select ORAM as a start-
ing point for our solution. To the best of our knowledge,
OBLIVP2P is the ﬁrst work that adapts ORAM to ac-
cesses in a P2P setting. However, directly employing
ORAM to hide access patterns in a P2P system is chal-
lenging. We outline two key challenges in designing an
oblivious and a scalable P2P protocol using ORAM.
Obliviousness. The ﬁrst challenge arises due to the dif-
ference in the setting of a standard ORAM as compared
to a P2P content sharing system. Classical ORAM solu-
tions consists of a single client which securely accesses
an untrusted storage (server), wherein the client is even-
tually the owner and the only user of the data in the mem-
ory. In contrast, P2P systems consist of a set of trusted
trackers managing the network, and multiple data own-
ers (peers) in the network. Each peer acts both as a client
as well as a server in the network i.e., a peer can either
request for a data or respond to other peer’s request with
the data stored on its machine. Hence, adversarial peers
present in the network can see the plaintext and learn the
data requested by other peers, a threat that does not exists
in the traditional ORAM model where only encrypted
data is seen by the servers.
Scalability. The second challenge lies in seeking an
oblivious P2P system that 1) the throughput scales lin-
early with the number of peers in the network, 2) has no
centralized bottleneck and 3) can be parallelized with an
overall acceptable throughput. In standard ORAM solu-
tions, the (possibly distributed) server is responsible for
serving all the data access requests from a client one-by-
one. In contrast, P2P systems operate on a large-scale
with multiple peers (clients) requesting resources from
each other simultaneously without overloading a partic-
ular entity. To retain scalability of P2P systems, it is
necessary to ensure that requests can be served by dis-

Solution Overview. We start with a toy construction
(OBLIVP2P-0) which directly adapts ORAM to a P2P
setting, and then present our main contribution which is
a more efﬁcient solution (OBLIVP2P-1).
Centralized Protocol (OBLIVP2P-0): Our centralized
protocol or OBLIVP2P-0,
is a direct adaptation of
ORAM in a P2P system. The peers in the network
behave both like distributed storage servers as well as
clients. They request a centralized, trusted tracker to ac-
cess a particular resource. The tracker performs all the
ORAM operations to fetch the resource from the net-
work and returns it to the requesting peer. However, this
variant of OBLIVP2P protocol has limited scalability as
it assigns heavy computation to the tracker, making it a
bottleneck.
Distributed Protocol (OBLIVP2P-1): As our main con-
tribution, we present OBLIVP2P-1 which provides both
obliviousness and scalability properties in a tracker-
based P2P system. To attain scalability, the key idea
is to avoid any single entity (say the tracker) as a bot-
tleneck. This requires distributing all the ORAM oper-
ations for fetching and sharing of resources among the
peers in the network, while still maintaining oblivious-
ness guarantees. To realize such a distributed protocol,
our main building block, which we call Oblivious Selec-
tion (OblivSel), is a novel combination of private infor-
mation retrieval with recent advances in ORAM. Obliv-
ious Selection gives us a scalable way to securely dis-
tribute the load of the tracker. Our construction is proven
secure in the honest-but-curious adversary model. Con-
structions and proofs for arbitrarily malicious fraction of
peers is slated for future work.

1.2 System and Results
We provide a prototype implementation of both
OBLIVP2P-0 and OBLIVP2P-1 protocols in Python.
Our source code is available online [34]. We experimen-
tally evaluate our implementation on DeterLab testbed
with 15 servers simulating up to 214 peers in the network.
Our experiments demonstrate that OBLIVP2P-0 is lim-
ited in scalability with the tracker as the main bottleneck.
The throughput for OBLIVP2P-1, in contrast, scales lin-
early with increase in the number of peers in the network.
It attains an overall throughput of 3.19 MBps for a net-
work of 214 peers that corresponds to 7 requests per sec-
ond for a block size of 512 KB. By design, OBLIVP2P-1
is embarrassingly parallelizable over the computational
capacity available in a real P2P network. Further, our
protocol exhibits no bottleneck on a single entity in ex-
periment, thereby conﬁrming that the network and the
computational overhead can be completely ofﬂoaded to

946  25th USENIX Security Symposium 

USENIX Association

2

the P2P network.
Contributions. We summarize our contributions below:
• Problem Formulation. We formulate the problem
of making data access pattern oblivious in P2P sys-
tems. This is a necessary and important step in
building defenses against long-term trafﬁc analysis.
• New Protocols. We propose OBLIVP2P— a ﬁrst
candidate for an oblivious peer-to-peer protocol in
content sharing systems. Our main building block
is a primitive which we refer to as oblivious selec-
tion that makes a novel use of recent advances in
Oblivious RAM combined with private information
retrieval techniques.

• System Implementation & Evaluation. Our pro-
totype implementation is available online [34]. We
experimentally evaluate our protocol to measure the
overall throughput of our system, latency for ac-
cessing resources and the impact of optimizations
on the system throughput.

2 Problem

Many P2P applications are not designed with security in
mind, making them vulnerable to trafﬁc pattern analy-
sis. We consider BitTorrent as our primary case study.
However, the problem we discuss is broadly applica-
ble to other P2P ﬁle sharing systems like Gnutella [35],
Freenet [3] and Storj [2] or peer-assisted CDNs such as
Akamai Netsession [4], Squirrel [5] and APAC [36].

2.1 BitTorrent: A P2P Protocol
The BitTorrent protocol allows sharing of large ﬁles be-
tween users by dividing it into blocks and distributing it
among the peers.
It has a dynamic network, made up
of a number of nodes that join the network and volun-
teer themselves as peers. Each peer holds data blocks in
its local storage and acts both as a client / requester and
server / sender simultaneously. There exists a tracker that
tracks which peers are downloading / uploading which
ﬁle and saves the state of the network.
It keeps in-
formation regarding the position or the IP addresses of
peers holding each resource but does not store any real
data blocks. A peer requests the tracker for a particular
resource and the tracker responds with a set of IP ad-
dresses of peers holding the resource. The requester then
communicates with these IP addresses to download the
blocks of the desired resource. The peers interact with
each other using a P2P protocol1. The requester con-
catenates all the blocks received to construct the entire
resource.

1We want to emphasize that there are other models of P2P networks
without tracker based on DHT that we are not addressing in this work.

2.2 Threat Model

In our threat model, we consider the tracker as a trusted
party and peers as passive honest-but-curious adversaries
i.e., the peers are expected to correctly follow the proto-
col without deviating from it to learn any extra informa-
tion. In P2P systems including CDNs (content delivery
networks) and BitTorrent, passive monitoring is already
a signiﬁcant threat on its own. We consider the following
two types of adversaries:
Global Passive Adversary. Since BitTorrent trafﬁc is
public, there exist tools like Global BitTorrent Moni-
tor [37] or BitStalker [38] that support accurate and ef-
ﬁcient monitoring of BitTorrent. Previous research has
shown that any BitTorrent user can be logged within a
span of 3 hours, revealing his digital identity and the con-
tent downloaded [39]. Further, the adversary can log the
communication history of the network trafﬁc to perform
ofﬂine analysis at a later stage. Hence, we consider it ra-
tional to assume the presence of a global adversary with
the capability to observe long term trafﬁc in the network.
Passive Colluding Peers. Some of the peers in the
P2P network can be controlled by the global adversary.
They can further collude to exchange data with other
adversarial peers in the system. While colluding these
“sybil” peers can share information such as observed /
served requests and the contents stored at their local stor-
age. Their goal is to collectively glean information about
other peers in the network. A formal deﬁnition of passive
colluding peers is as follows:

Deﬁnition 2.1. (Passive Colluding peers) We say that
a peer Pi passively colludes with peer Pj if both peers
share their views without any modiﬁcation, where a view
consists of: a transcript of the sequence of all accesses
made by Pi, a partial or total copy of peer’s private stor-
age, and a transcript of the access pattern induced by
the sequence of accesses. We denote by C (Pi) the set of
colluding peers with Pi.

Note that from the above deﬁnition, we have a sym-
metric relation such that if Pi ∈ C (Pj) for i �= j, then
Pj ∈ C (Pi). It follows that if Pi /∈ C (Pj), then C (Pi) and
C (Pj) are disjoint.
Our protocol tolerates a fraction of c adversarial peers
in the network such that c ∈ O(Nε ), where N is the total
number of peers in the network and ε < 1. Although the
P2P network undergoes churn, we assume the fraction of
adversarial peers c remains within the asymptotic bounds
of O(Nε ). Our choice of the upper bound for c ensures
an exponentially small advantage to the attacker; for an
application that can tolerate higher attacker’s advantage,
a larger malicious fraction can be allowed.

USENIX Association  

25th USENIX Security Symposium  947

3

Insufﬁciency of Existing Approaches

2.3
Existing techniques propose anonymizing users to pre-
vent trafﬁc pattern analysis attacks. However, these so-
lutions are not sufﬁcient to protect against a global adver-
sary with long term access to communication patterns.
Unlinkability Techniques (e.g. Mixnet). Existing
anonymity approaches “unlink” the sender from the re-
ceiver (see survey [40]). Chaum proposed the ﬁrst
anonymous network called mix network [11], which
shufﬂes messages from multiple senders using a chain
of proxy servers and sends them to the receiver. Another
recent system called Riposte guarantees trafﬁc analysis
resistance by unlinking a sender from its message [41].
However, all these systems are prone to attack if an ad-
versary can observe multiple request rounds in the net-
work.

For example, consider that Alice continuously com-
municates with Bob using a mixnet service. A global
adversary observes this communication for a couple of
rounds, and records the recipient set in each round. Let
the senders’ set consists of S1 = {Alice,a,b,c} and S2 =
{a�,b�,Alice,c�}, and the recipients’ set consists of R1 =
{x,y,z,Bob} and R2 = {x�,y�,Bob,z�} for rounds 1 and 2
respectively. The attacker can then infer the link between
sender and receiver by intersecting S1∩S2 = {Alice} and
R1 ∩ R2 = {Bob}. The attacker learns that Alice is com-
municating with Bob, and thus breaks the unlinkability.
This attack is called the intersection, hitting set or sta-
tistical disclosure attack [25, 26]. Overall, one time un-
linkability is not a sufﬁcient level of defense when the
adversary can observe trafﬁc for arbitrary rounds.
Path Non-Correlation (e.g. Onion routing). Another
approach for guaranteeing anonymity is to route the mes-
sage from a path such that the sender and the receiver
cannot be correlated by a subset of passive adversar-
ial nodes. Onion-routing based systems like Tor en-
able anonymous communication by using a sequence of
relays as intermediate nodes (called circuit) to forward
trafﬁc [15, 42]. However, Tor cannot provide sender
anonymity when the attacker can see both the ends of
the communication, or if a global adversary observes the
entire network. Hence, if an attacker controls the entry
and the exit peer then the adversarial peers can determine
the recipient identity with which the initiator peer is com-
municating [27–30]. This is a well-known attack called
the end-to-end correlation attack or trafﬁc conﬁrmation
attack [43, 44].

2.4 Problem Statement
Our goal is to design a P2P protocol that prevents linking
a user to a requested resource using trafﬁc pattern anal-
ysis. Section 2.3 shows how previous anonymity based

solutions are susceptible to attacks in our threat model.
In this work, we address this problem from a new view-
point, by making the communication pattern oblivious
in the network. We advocate that hiding data / resource
access pattern is a necessary and important step in de-
signing trafﬁc pattern analysis resistant P2P systems.

In a P2P system such as BitTorrent, a user accesses a
particular resource by either downloading (Fetch) or up-
loading (Upload) it to the network. We propose to build
an oblivious P2P content sharing protocol (OBLIVP2P)
that hides the data access patterns of users in the net-
work. We formally deﬁne an Oblivious P2P protocol as
follows:
Deﬁnition 2.2. (Oblivious P2P): Let (P1,··· ,Pn) and
T be respectively a set of n peers and a tracker in a
P2P system. We denote by −→xi = (xi,1,··· ,xi,M) a se-
quence of M accesses made by peer Pi such that xi, j =
(opi,j, ﬁdi,j, ﬁlei,j) where opi,j = {Upload, Fetch}, ﬁdi,j is
the ﬁlename being accessed, and ﬁlei,j is the set of blocks
being written in the network if opi,j = Upload.

We denote by A (−→xi ) the access pattern induced by
the access sequence −→xi of peer Pi. The access pattern
is composed of the memory arrays of all peers accessed
while running the sequence −→xi . We say that a P2P is
oblivious if for any two equal-length access sequences
−→xi and −→x j by two peers Pi and Pj such that

• Pj /∈ C (Pi)
• ∀k ∈ [M] : xi,k = Fetch ⇔ x j,k = Fetch ∧ xi,k =
Upload ⇔ x j,k = Upload
• ∀k ∈ [M], |ﬁlei,k| = |ﬁlej,k|
are indistinguishable for all probabilistic poly-time

adversaries except for C (Pi), C (Pj), and tracker T .

Scope. OBLIVP2P guarantees resistance against persis-
tent communication trafﬁc analysis i.e., observing the
path of communication and thereby linking a sender to a
particular resource. OBLIVP2P does not prevent against:

a) Active Tampering: An adversarial peer can tam-
per, alter and deviate from the protocol to learn extra
information. Admittedly,
this can have an impact
on obliviousness, correctness and availability of the
network.
b) Side Channels: An adversary can monitor any peer in
the system to infer its usage’s habits via side channels:
the number of requests,
time of activity, and total
number of uploads. In addition, an adversary can always
infer the total ﬁle size that any peer is downloading or
uploading to the P2P network. Literature shows that
some attacks such as website ﬁngerprinting can be based
on the length of ﬁle requested by peers [45].
c) Orthogonal Attacks: Other attacks in P2P ﬁle sharing

948  25th USENIX Security Symposium 

USENIX Association

4

systems consist of threats such as poisoning of ﬁles by
uploading corrupted, fake or misleading content [46] or
denial of service attacks [47]. However, these attacks do
not focus on learning private information about the peers
and hence are orthogonal to our problem.

Admittedly, our assumption about honest-but-curious
is less than ideal and simpliﬁes analysis. We hope that
our construction spurs future work on tackling the ac-
tive or arbitrary malicious adversaries. Emerging trusted
computing primitives (e.g., Intel SGX [48]) or crypto-
graphic measures [49] are promising directions to inves-
tigate. Lastly, OBLIVP2P should not be confused with
traditional anonymous systems where a user is anony-
mous among a set of users. OBLIVP2P does not guar-
antee sender or receiver anonymity, but hides data access
patterns of the users.
3 Our Approach

As a defense against trafﬁc pattern analysis, we guaran-
tee oblivious access patterns in P2P systems. We con-
sider Oblivious RAM as a starting point.

3.1 Background: Tree-Based ORAM
Oblivious RAM, introduced by Goldreich and Ostro-
vsky [33], is a cryptographic primitive that prevents an
adversary from inferring any information via the mem-
ory access pattern. Tree-based ORAM introduced by Shi
et al. [50] offers a poly-logarithmic overhead which is
further reduced due to improvements suggested in the
follow up works [51–56].
In particular, we use Ring
ORAM, [52], one of the latest improvements for tree-
based ORAM in our protocol. In Ring ORAM, to store
N data blocks, the memory is organized in a (roughly)
logN-height full binary tree, where each node contains
z real blocks and s dummy blocks. Whenever a block is
accessed in the tree, it is associated to a new randomly
selected leaf identiﬁer called, tag. The client stores this
association in a position map PosMap along with a pri-
vate storage (stash). To read and write to the untrusted
memory, the client performs an Access followed by an
Evict operation described at a high level as follows:

• Access(adr): Given address adr, the client fetches
the leaf identiﬁer tag from PosMap. Given tag,
the client downloads one block per every node in
the path P(tag) that starts from the root and ends
with the leaf tag. The client decrypts the retrieved
blocks, and retrieves the desired block. This block
is appended to the stash.

• Evict(A,ν): After A accesses, the client selects a
path P(ν) based on a deterministic reverse lex-
icographic order, downloads the path, decrypts it
and appends it to the stash. The client runs the

(cid:3)(cid:13)(cid:16)(cid:14)(cid:15)(cid:8)(cid:7) (cid:1)(cid:11)(cid:9)(cid:8)(cid:12)(cid:15)

(cid:2)(cid:7)(cid:9)(cid:4)(cid:10)(cid:7)(cid:6)(cid:1)(cid:5)(cid:3)(cid:8)(cid:1)(cid:1)

(cid:1)

(cid:3)(cid:13)(cid:16)(cid:14)(cid:15)(cid:8)(cid:7) (cid:3)(cid:13)(cid:5)(cid:6)(cid:10)(cid:8)(cid:13)

(cid:2)(cid:7)(cid:9)(cid:4)(cid:10)(cid:7)(cid:6)(cid:1)(cid:5)(cid:3)(cid:8)(cid:1)

(cid:4)(cid:12)(cid:15)(cid:13)(cid:16)(cid:14)(cid:15)(cid:8)(cid:7) (cid:2)(cid:8)(cid:13)(cid:17)(cid:8)(cid:13)

path 

(cid:1)
(cid:1)

Node 

Peers 

Peer-to-Peer network 

Figure 1: Mapping of a client / server ORAM model to a P2P system

least common ancestor algorithm to sort the blocks
as in [51]. Finally, the client freshly encrypts the
blocks and writes them back to the nodes in the
path.

The stash is upper bounded by O(logN). The overall
bandwidth may reach � 2.5logN, for N blocks stored. In
Ring ORAM, eviction happens periodically after a con-
trollable parameter A = 2z accesses where z is the num-
ber of blocks in each bucket [52].

3.2 Mapping an ORAM to a P2P setting
We start from a traditional ORAM in a client / server
model where the client is trusted and the server is not,
and simulate it on a tracker / peers setting. In particular,
we consider that the server’s memory is organized in a
tree structure, and we delegate every node in the tree to
a peer. That is, a full binary tree of N leaves is now
distributed among Np = 2N − 1 peers (refer to Figure 1).
In practice, many nodes can be delegated to many peers
based on the storage capacity of each peer.

Contrary to the client / server setting where the client
is the only one who can fetch, modify or add a block,
in P2P, the peers can also request and add new blocks.
In addition, the peers are volatile, i.e, many peers can
join or leave the network. Moreover, from a security per-
spective, the network peers do not trust each other, and
an adversarial peer can always be interested in ﬁnding
out the block being retrieved by other peers. To avoid
this, the tracker instructs the peers in a P2P system to
save encrypted blocks in their local memory (different
from the conventional BitTorrent model). Our construc-
tion ensures that the peer neither has the keys necessary
to decrypt its storage nor can it collude with other adver-
sarial peers to recover it. In this setting, we ﬁrst present a
strawman approach that guarantees our security goal but
is restricted in terms of scalability.

3.3 OBLIVP2P-0 : Centralized Protocol
Almost all ORAM constructions are in a client / server
setting and not designed for a P2P setting. A simple
approach is to map the role of the trusted client in an

USENIX Association  

25th USENIX Security Symposium  949

5

ORAM setting (refer to Figure 1) to the trusted tracker
in a P2P system. The client in ORAM is simulated by
the trusted tracker (storing the position map, private keys
and the stash) and the server by the untrusted peers (stor-
ing the encrypted blocks). With such a mapping from an
ORAM model to a P2P setting, a peer (initiator) can re-
quest for a resource to the tracker. To access a particular
resource, the tracker fetches the blocks from a path in the
tree and decrypts them to get the desired block. It then
returns the requested resource to the initiator peer. This
simple plug-&-play construction satisﬁes all our P2P se-
curity requirements.

In OBLIVP2P-0, the trusted tracker behaves as the
client in traditional ORAM model. Whenever a peer re-
quests a block, the tracker performs all the ORAM ac-
cess work, and then sends the plaintext block to the ini-
tiator. The tracker downloads the path composed of a
logarithmic number of nodes, writes back the path with
a fresh re-encryption before routing the block to the ini-
tiator. As long as the tracker is trusted, this ensures the
obliviousness property of peers’ accesses, as stated by
deﬁnition 2.2.
Upload algorithm. To upload a ﬁle, the peer divides
it into data blocks and sends the blocks to the tracker.
The tracker appends the block to the stash stored locally
while generating new random tags. The tracker updates
accordingly TagMap, and FileMap (refer to Table 1).
Fetch algorithm. To fetch a ﬁle, the peer sends the ﬁle
identiﬁer, as an instance a ﬁlename, to the tracker. The
tracker fetches from the FileMap and TagMap the corre-
sponding blocks and sends requests to the corresponding
peers to retrieve the blocks, following the Ring ORAM
Access protocol. For every retrieved block, the tracker
sends the plaintext block to the requesting peer.
Sync algorithm. The synchronization happens after ev-
ery A� 2z accesses [52] (e.g., nearly 8 accesses) at which
point the tracker evicts the stash.
Tracker as Bottleneck.
In OBLIVP2P-0, the tracker
has to transmit / encrypt a logarithmic number of blocks
on every access. The tracker requires a bandwidth of
O(logN · B) where B is the block size and the computa-
tion cost of O(logN · E) where E is time for encrypting
/ decrypting a block. Moreover, our evaluation in Sec-
tion 5 shows that the eviction step is network-intensive.
In a P2P setting with large number of accesses per sec-
ond, the tracker creates a bottleneck in the network.

3.4 OBLIVP2P-0 Analysis
Our analysis follow from Ring ORAM construction. To
access a block the tracker has to transmit ∼ 2.5logN · B
bits per access. During a block access or eviction, any
peer at any time transmits O(B) bits. The tracker’s main

computational time consists of decrypting and encrypt-
ing the stash. Since the stash has a size of O(logN)
blocks, the tracker does O(logN) blocks encryption/de-
cryption.
In terms of storage, every peer has (z + s)
blocks to store, where z is number of real blocks and s
is a parameter for dummy blocks. From a security per-
spective, it is clear that if there are two sequences veri-
fying the constraints of Deﬁnition 2.2, a malicious peer
monitoring their access pattern cannot infer the retrieved
blocks, since after every access the block is assigned to a
random path in the simulated ORAM.

4 OBLIVP2P-1: Distributed Protocol

In this section, we describe our main contribution,
OBLIVP2P-1 protocol that provides both security and
scalability properties. In designing such a protocol, our
main goal is to avoid any bottleneck on the tracker i.e.,
none of the real blocks should route through the tracker
for performing an access or evict operations of ORAM.
We outline the challenges in achieving this property
while still retaining the obliviousness in the network.

4.1 Challenges

First Attempt. A ﬁrst attempt to reduce tracker’s over-
head is to modify OBLIVP2P-0 such that the heavy com-
putation of fetching the path of a tree and decrypting the
correct block is ofﬂoaded to the initiator peer. On getting
a resource request from a peer, the tracker simply sends
information to the peer that includes the path of the tree
to fetch, the exact position of the requested block and the
key to decrypt it. However, unlike standard ORAM, the
peer in our model is not trusted. Giving away the exact
position of the block to the initiator peer leaks additional
information about the requested resource in our model,
as we explain next.

Recall that in a tree-based ORAM, blocks are dis-
tributed in the tree such that the recently accessed blocks
remain in the top of the tree. In fact, after every evic-
tion the blocks in the path are pushed down as far as
possible from the root of the tree. As an instance, af-
ter N deterministic evictions, all blocks that were never
accessed are (very likely) in the leaves. Conversely, con-
sider that an adversarial peer makes two back-to-back ac-
cesses. In the ﬁrst access, it retrieves a block from the top
of the tree while in the second access it retrieves a block
from a leaf. The adversarial peer (initiator) learns that
the ﬁrst block is a popular resource and is requested be-
fore by other peers while the second resource is a less
frequently requested resource. This is a well known is-
sue in tree-based ORAM, and is recently formulated as
the block history problem [57]. Disclosing the block po-
sition, while hiding the scheme obliviousness requires to

950  25th USENIX Security Symposium 

USENIX Association

6

address the block history challenge in ORAM. Unfortu-
nately, an ORAM hides the block history only if the com-
munication spent to access a block dominates the num-
ber of blocks stored in the entire ORAM. This would
be asymptotically equivalent to downloading the entire
ORAM tree from all the peers. We refer readers to [57]
for more details.
Second Attempt. Our second attempt is a protocol that
selects a block while hiding the block position from the
adversary i.e., to hide which node on the path holds the
requested block. Note that in a tree-based ORAM, dis-
closing the path does not break obliviousness, but leak-
ing which node on the path holds the requested block is
a source of leakage. One trick is to introduce a circuit,
a set of peers from the P2P network, that will simulate
the operations of a mixnet. That is, the peers holding the
path of the tree send their content to the ﬁrst peer in the
circuit, who then applies a random permutation, adds a
new encryption layer, and sends the permuted path to the
second peer and so on. The tracker, who knows all the
permutations, can send the ﬁnal block position (unlinked
from original position) to the initiator, along with the
keys to decrypt the block. The mixing guarantees that the
initiator does not learn the actual position of the block.
We note that mixing used here is for only one accessed
“path”, which is already randomized by ORAM. Hence,
it is not susceptible to intersection attack discussed in
Section 2.3. Finally, the initiator then peels off all layers
of the desired block to output the plaintext block.

However, there is an important caveat remaining in us-
ing this method. Note that the initiator has the keys to
peel off all the layers of encryption and hence it has ac-
cess to the same encrypted block fetched from the path in
the tree. Thus, it can determine which peer’s encrypted
block was ﬁnally selected as the output of the mixnet.
Hence, delegating the keys to the initiator boils down to
giving her the block position. One might think of elimi-
nating this issue by routing the block through the tracker
to peel off all layers, but this will just make the tracker
again a bottleneck.

So far, our attempts have shown limitations, but
pointed out that there is a need to formally deﬁne the
desired property. Considering a tracker, the initiator, and
the peers holding the path, we seek a primitive that given
a set of encrypted blocks, the initiator can get the desired
plaintext block, while no entity can infer the block posi-
tion but the tracker. We refer to this primitive as Oblivi-
ous Selection (OblivSel) and describe it next.

4.2 Oblivious Selection
4.2.1 Deﬁnitions

We deﬁne OblivSel and its properties as follows:

(cid:5)(cid:24)(cid:15)(cid:1)(cid:2)(cid:22)(cid:25)(cid:15)(cid:21)(cid:36)(cid:1)

(cid:5)(cid:24)(cid:15)(cid:1)(cid:2)(cid:22)(cid:25)(cid:15)(cid:21)(cid:37)(cid:1)

(cid:5)(cid:24)(cid:15)(cid:1)(cid:2)(cid:22)(cid:25)(cid:15)(cid:21)(cid:38)(cid:1)

Step 1 

Step 2 

Step 3 

Step 4 

(cid:11)(cid:17)(cid:22)(cid:17)(cid:15)(cid:29)(cid:1)(cid:2)(cid:1)(cid:27)(cid:13)(cid:24)(cid:16)(cid:25)(cid:23)(cid:1)(cid:26)(cid:17)(cid:17)(cid:27)(cid:28)(cid:1)

(cid:3)(cid:25)(cid:23)(cid:26)(cid:30)(cid:29)(cid:17)(cid:1)(cid:13)(cid:24)(cid:1)(cid:5)(cid:24)(cid:15)(cid:27)(cid:32)(cid:26)(cid:29)(cid:17)(cid:16)(cid:1)(cid:11)(cid:19)(cid:13)(cid:27)(cid:17)(cid:1)

(cid:34)(cid:30)(cid:28)(cid:20)(cid:24)(cid:18)(cid:1)(cid:8)(cid:12)(cid:33)(cid:9)(cid:8)(cid:10)(cid:35)(cid:1)

(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:1)

(cid:4)(cid:17)(cid:15)(cid:27)(cid:32)(cid:26)(cid:29)(cid:1)(cid:29)(cid:19)(cid:17)(cid:1)(cid:10)(cid:17)(cid:29)(cid:27)(cid:20)(cid:17)(cid:31)(cid:17)(cid:16)(cid:1)(cid:11)(cid:19)(cid:13)(cid:27)(cid:17)(cid:1)

(cid:34)(cid:30)(cid:28)(cid:20)(cid:24)(cid:18)(cid:1)(cid:11)(cid:7)(cid:33)(cid:9)(cid:10)(cid:6)(cid:35)(cid:1)

(cid:3)(cid:25)(cid:23)(cid:14)(cid:20)(cid:24)(cid:17)(cid:1)(cid:4)(cid:17)(cid:15)(cid:27)(cid:32)(cid:26)(cid:29)(cid:17)(cid:16)(cid:1)(cid:11)(cid:19)(cid:13)(cid:27)(cid:17)(cid:28)(cid:1)

(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:1)
(cid:2)(cid:4)(cid:7)(cid:6)(cid:8)(cid:3)(cid:5)(cid:7)(cid:1)

(cid:4)(cid:17)(cid:15)(cid:1)(cid:2)(cid:22)(cid:25)(cid:15)(cid:21)(cid:38)(cid:1)

Figure 2: Oblivious Selection protocol using IT-PIR and Seed
Homomorphic PRG as base primitives

Deﬁnition 4.1. (Oblivious Selection). OblivSel is a tuple
of two probabilistic algorithms (Gen, Select) such that:
• (�σ ,�r) ← Gen(k, pos): a probabilistic algorithm run
by the tracker,
takes as input a key k and the
block position pos, picks uniformly at random m
peers (P1,··· ,Pm), and outputs (�σ ,�r) where �σ =
{σ1,··· ,σm} and�r = {r1,··· ,rm} such that (σi,ri)
is given to the ith peer Pi.

• Δ← Select(�σ ,�r, Enc(k1, block1),··· , Enc(kL, blockL)):

a probabilistic algorithm run by m peers,
takes
as input �σ, �r, and a set of encrypted blocks
Enc(ki, blocki), for i ∈ [L], and outputs the value Δ.

Deﬁnition 4.2. OblivSel, is correct, if
Pr[∀ pos ∈ [L], k ∈ {0,1}λ , (�σ ,�r) ← Gen(k, pos);
Δ ← Select(�σ ,�r, Enc(k1, block1),··· , Enc(kL, blockL));
Δ = Dec(k, Enc(kpos, blockpos))] = 1

For instance, if (Enc, Dec) is a private key encryption,
OblivSel returns a decrypted block when the key given as
input to the Gen function is the same as the private key
of the block i.e., Δ = blockpos if k = kpos.

Deﬁnition 4.3. (Position Hiding.) We say that OblivSel
is a position hiding protocol if for all probabilistic poly-
nomial time global adversaries, including the initiator
and the m peers, guess the position of the block pos with
a negligible advantage in the implicit security parameter.

4.2.2 OblivSel Overview
The intuition for constructing OblivSel stems from the
fact that the tracker cannot give the position or private
key of the desired block to the peers in the network.

To privately select a block from the path without leak-
ing its position, we propose to use an existing crypto-
graphic primitive, called information-theoretical private

USENIX Association  

25th USENIX Security Symposium  951

7

Structure
FileMap

TagMap

NetMap

PosMap

KeyMap
StashList

Mapping

B ]

$

block address adr to tag

peer id pid to network info

ﬁle id ﬁd to block addresses {adri}i∈[ f
←− [NB]
(cid:31)IP, port(cid:30) ∈ {0,1}128+16
pos ∈ [Np]× [L· z +|stash|]
block address adr to key value k
peers’ identiﬁers {pidi}i∈[|stash|]

←− Zq

$

block address adr to path and bucket position

Purpose

Blocks identiﬁcation
Path identiﬁcation

Network representation

Block exact localization

Input of key block generation

Stash localization

Table 1: Various meta-information contained in the state s, for OBLIVP2P-0 and OBLIVP2P-1. B is the block size in bits, NP the
number of peers, NB number of blocks, L the path length, and z the bucket size.

information retrieval (IT-PIR) [58].
IT-PIR requires
a linear computation proportional to the data size that
makes it expensive to use for real time settings. How-
ever, note that in our setting, we want to obliviously se-
lect a block from a logarithmic number of blocks (i.e., a
path of the tree). Thus, applying IT-PIR over tree-based
ORAM comes with signiﬁcant computational improve-
ment, hence making it practical to use in our protocol.
The high level idea is to apply IT-PIR primitive only on
one path since the obliviousness is already guaranteed by
the underlined tree-based ORAM construction.

Figure 2 shows the steps involved in our OblivSel
primitive. As a ﬁrst step, the tracker randomly samples
m peers from the network. For a bounded number of col-
luding adversarial peers in the system, this sample will
contain at least one honest peer with high probability.
The blocks of the path are fetched by all of the m peers.
Each of the m peers then locally computes an encrypted
share of the desired block using IT-PIR from the set of
input blocks. Note that the tracker must not download
the shares or it will violate our scalability requirement.
On the other hand, we require to decrypt the block with-
out giving away the private key to the network’s peers.
For this purpose, we make use of a second cryptographic
primitive — a seed homomorphic pseudo-random gener-
ator (SH-PRG) [59]. The tracker generates a valid key
share for each of the m peers to be used as seeds to the
PRG function. Each peer decrypts (or unblinds) its en-
crypted share using its own key share such that the com-
bination of decrypted shares results in a valid decryption
of the original encrypted block in the tree. This property
is ensured by SH-PRG and explained in detail in Sec-
tion 4.2.3. Finally, each peer submits its decrypted share
to the initiator peer who combines them to get the desired
plaintext block. The colluding peers cannot recover the
private key or the encrypted block since there is at least
one honest peer who does not disclose its private infor-
mation. This solves the issues raised in our second at-
tempt.
Remark. OblivSel primitive can be used as a black box

Algorithm 1: IT-PIR protocol by Chor et al. [58]
1 (r1,··· ,rm) ← Query(q, L, pos)

• randomly generate m− 1 random vectors such that ri
• compute rm such that for all j ∈ [L]\{pos}, set
k=1 rk, j, otherwise, rm,pos = 1− ∑m−1

rm, j = −∑m−1

k=1 rk, j

$

←− ZL

q

Ri ← Compute(ri, DB)

• parse database such as DB = (block1,··· , blockL)
• compute Ri = ∑L

j=1 ri, jBlockj

blockpos ← Recover(R1,··· , Rm): compute blockpos = ∑m

j=1 Ri

in different settings such as distributed ORAMs to de-
crease the communication overhead. We further show in
Section 4.2.4 that OblivSel is highly parallelizable and
can leverage peers in the network such that the computa-
tion takes constant time.

4.2.3 Base Primitives

Information-theoretic PIR. Information-theoretic pri-
vate information retrieval (IT-PIR) [58] is a crypto-
graphic primitive that performs oblivious read opera-
tions while requiring multiple servers m ≥ 2. In the fol-
lowing, we present the details of one of the ﬁrst con-
structions of IT-PIR by Chor et al. [58] which is se-
cure even when m − 1 among m servers collude pas-
sively, i.e., the servers collude in order to recover the
retrieved block while not altering the protocol. An
IT-PIR is a tuple of possibly randomized algorithms
IT− PIR = (Query, Compute, Recover). Query takes as
an input the block position pos to be retrieved, and out-
puts an IT-PIR query for m servers. Compute runs inde-
pendently by every server, takes as input the correspond-
ing IT-PIR query and outputs a share. Recover takes as
inputs all shares output by all m servers, and outputs the
plaintext block. We give the construction in Algorithm 1.
Seed homomorphic PRG (SH-PRG). A seed homo-
morphic PRG, G, is a pseudo-random generator over al-
gebraic group with the additional property that if given

952  25th USENIX Security Symposium 

USENIX Association

8

Algorithm 2: OblivSel with seed-homomorphic PRG
1 (�σ ,�r) ← Gen(k, pos)

• set�r = (r1,··· ,rm) ← IT− PIR.Query(q, L, pos);
• set �σ = (σ1,··· ,σm), s.t., (σ1,··· ,σm−1)
block ← Select(�σ ,�r, DB) // Every peer Pi

σm = k− ∑m−1

i=1 σi;

$

• compute Esharei ← IT− PIR.Compute(ri, DB);
• set Dsharei = Esharei − G(σi);

←− Sm−1, and

// Initiator
• compute Δ = ∑m

i=1 Dsharei;

G(s1) and G(s2), then G(s1 ⊕ s2) can be computed efﬁ-
ciently. That is, if the seeds are in a group (S,⊕), and
outputs in (G,⊗), then for any s1,s2 ∈ S, G(s1 ⊕ s2) =
G(s1)⊗ G(s2). We refer to [60] for more details.
Decryption / Re-encryption using SH-PRG. Lever-
aging the property of SH-PRG, we explain the
encryption, decryption and re-encryption of a block
in our protocol.
Every block in the tree is en-
crypted as Enc(k1, block) =block + G(k1).
The
decryption of the block can be then represented as
block = Dec(k1, Enc(k1, block)) = block + G(k1)− G(k1)
a
re-encrypting
For
different key k2,
en-
crypted block with a new secret key of the form
k1 − k2
Dec(k1 − k2, Enc(k1, block))
= block + G(k1)− G(k1 − k2) =block + G(k2)
=
Enc(k2, block).

encrypted
tracker decrypts

block with

the
the

such

that,

the

4.2.4 OblivSel Instantiation

In the following, we present an instantiation of OblivSel.
We consider a set of L encrypted blocks. Each block
blocki is a vector of elements in a ﬁnite group G of order
q. For every block, the key is generated at random from
Zq. The tracker has to keep an association between the
block key and its position. An algorithmic description is
given in Algorithm 2.

The tracker runs the Gen algorithm, which takes as
inputs the secret key k with which the block is en-
crypted and the block’s position pos, and outputs a se-
cret shared value of the key, �σ, as well as the IT-PIR
queries,�r. Every peer Pi holds a copy of the L encrypted
blocks and receives a share of the key, σi, as well as its
corresponding query, ri. Next, every peer runs locally
an IT− PIR.Compute on the encrypted blocks and out-
puts a share, Esharei. After getting the encrypted share
Esharei, each peer subtracts the evaluation of the SH-
PRG G on σi from Esharei (Esharei − G(σi)) to get the
decrypted share Dshare. Finally, initiator outputs the
sum of all the Dsharei’s received from the m peers to

get the desired decrypted block. As long as there is one
non-colluding peer among the m peers and G is a secure
PRG, the scheme is position hiding.
Highly Parallelizable. Notice that, in Algorithm 2, each
of the m peers performs scalar multiplications propor-
tional to the number of encrypted input blocks. The
encrypted blocks can be further distributed to different
peers such that each peer performs constant number of
scalar multiplications. Given the availability of enough
peers in the network, OblivSel is extremely parallelizable
and therefore provides a constant time computation.
OblivSel as a building block. OblivSel protocol can
be used as a building block in our second and main
OBLIVP2P-1. For fetching a block, an invocation of
OblivSel is sufﬁcient as it obliviously selects the re-
quested block and returns it in plaintext to the initia-
tor. Additional steps such as re-encrypting the block and
adding it to stash are required to complete the fetch op-
eration. The details of these steps are in Section 4.3.

However, the eviction operation in ORAM poses an
additional challenge. Conceptually, an eviction consists
of block sorting, where the tracker re-orders the blocks
in the path (and the stash). Fortunately, our protocol can
perform eviction by several invocation of OblivSel prim-
itive. Given the new position for each block, the P2P
network can be instructed to invoke OblivSel recursively
to output the new sorted path. The encryption of blocks
has to be refreshed, but this is handled within OblivSel
protocol itself when refreshing the key, using seed ho-
momorphic PRG. We defer the concrete details of per-
forming oblivious eviction to Section 4.3.

4.3 OBLIVP2P-1: Complete Design
In a P2P protocol for a content sharing system the tracker
is responsible for managing the sharing of resources
among the peers in the network. To keep a consistent
global view on the network, the tracker keeps some state
information that we formally deﬁne below:
Deﬁnition 4.4. P2P network’s state consists of: (1) num-
ber of possible network connections per peer, and (2) a
lookup associating a resource to a (set of) peer identiﬁer.
The tracker can store more information in the state de-
pending on the P2P protocol instantiating the network.
We start ﬁrst by formalizing a P2P protocol.
Deﬁnition 4.5. A P2P protocol
four
a
(Setup, Upload, Fetch, Sync)
T , and a set of peers, (P1,··· ,Pn), such that:

is a tuple of
algorithms P2P =
tracker,

interactive)

involving

(possibly

• s� ← Setup(s,{pid}): run by the tracker T , takes as
inputs a state s and a (possibly empty) set of peers
identiﬁers {pid}, and outputs an updated state s�.

USENIX Association  

25th USENIX Security Symposium  953

9

Scheme

OBLIVP2P-0
OBLIVP2P-1

Tracker
bandwidth

(bits)

O(logN · B)
O(cid:31)log3 N(cid:30)

Network

bandwidth (#

blocks)
O(1)
O( logN
N )

Tracker #
encryption
O(logN · E)

−

Network

computational

overhead

−
O( log 4N
N · E )

Network
Storage
overhead

O(1)

O(burst)

Tracker storage

# blocks

O(logN)

−

Table 2: Comparison of OBLIVP2P instantiation per access. B the block size, N the number of blocks in the network, E the overhead of a block
encryption, E a multiplication in elliptic curve group, burst the number of versions

• (cid:31)out, (A�1,··· ,A�m), s�(cid:30)
←
Upload(cid:31)(ﬁd, ﬁle), (A1,··· , Am), s(cid:30):
is an in-
teractive protocol between an initiator peer, a
(possibly randomly selected) set of m ≥ 0 peers,
and a tracker T . The initiator peer has as input a
ﬁle identiﬁer ﬁd, and the ﬁle ﬁle, the peers’ input
is memory array Ai each, while for the tracker its
state s. The initiator’s output is out ∈ {⊥, ﬁle},
the peers output each a modiﬁed local memory A�i,
while the tracker outputs an updated state s�.
• (ﬁle,⊥, s�) ← Fetch(cid:31)ﬁd, (A1,··· , Am), s(cid:30): is an in-
teractive protocol between an initiator peer, a (pos-
sibly randomly selected) set of m ≥ 0 peers, and a
tracker T . The initiator peer has as input a ﬁle
identiﬁer ﬁd, the peers’ input is a memory array Ai
each, while for the tracker its state s. The initia-
tor outputs the retrieved ﬁle ﬁle, each peer gets ⊥,
while the tracker outputs an updated state s.
• (cid:31)(A�1,··· ,A�m), s�(cid:30) ← Sync(cid:31)(A1,··· , Am), s(cid:30): is an
interactive protocol between the tracker and a (pos-
sibly randomly selected) set of m ≥ 0 peers. The
peers’ input is a memory array Ai each, while for
the tracker its state s. The peers output each a (pos-
sibly) modiﬁed memory array A�i, while the tracker
outputs an updated state s�.

Note that a modiﬁcation of a ﬁle already stored in the

network is always considered as uploading a new ﬁle.
Setup Algorithm. In a P2P network, different peers have
different storage capacities and hence we differentiate
between the number of blocks, NB, and the number of
physical peers NP. For this, we fragment the conceptual
ORAM tree into smaller chunks where every peer physi-
cally handles a number of buckets depending on its local
available storage. In addition, to keep a consistent global
view on the network, the tracker keeps some state infor-
mation. In OBLIVP2P-1, the state is composed of differ-
ent meta-information that are independent of the block
size: FileMap, PosMap, TagMap, NetMap, KeyMap,
and StashMap. Table 1 gives more details about the
metadata. The state also contains a counter recording the
last eviction step, and ∼ B
logq points sampled randomly
from a q-order elliptic curve group G to be used for DDH
seed homomorphic PRG, where B is the block size. The
number of points in the generator needs to be equal to
those in the data block. These points are publicly known

Algorithm 3: Fetch(ﬁd, s): OBLIVP2P-1 fetch operation
Input: ﬁle id ﬁd, and state s
Output: ﬁle {block}, and updated state s
// Initiator requests tracker for a file

1 {adr} ←FileMap (ﬁd);

for adr in {adr} do

(tag, pos) ←(cid:31)TagMap(adr), PosMap(adr)(cid:30);
k ← KeyMap(adr);
compute (�σ ,�r) := OblivSel.Gen(k, pos);
set A =(cid:31)stash, P(tag,1),··· , P(tag,L)(cid:30);

// Initiator retrieves the block
compute block := OblivSel.Select(�σ ,�r, A);
// Re-encryption with a new secret
compute k
compute (�σ ,�r) := OblivSel.Gen(k, pos);
append Δ := OblivSel.Select(�σ ,�r, A) to the stash, and update state
s;

←− Zq;

$

2
3
4
5
6

7

8
9
10

11 end

to all peers in the network. The tracker randomly dis-
tributes the stash among the peers and records this infor-
mation in the StashList.
Fetch Algorithm. The Fetch process is triggered when
a peer requests a particular ﬁle. The tracker determines
the block tag and position from its state for all the blocks
composing the ﬁle. The m peers, the tracker, and the
initiator runs OblivSel protocol such that the initiator re-
trieves the desired block. The OblivSel is invoked a sec-
ond time to add a new layer to the retrieved block and
send it to the peer who will hold the stash. The tracker
updates its state, in particular, update KeyMap with the
new key, update the PosMap with the exact position of
the block in the network (in the stash), and TagMap with
the new uniformly sampled tag. We provide an algorith-
mic description of the Fetch process in Algorithm 3.
Sync Algorithm. The Sync in OBLIVP2P-1 consists
of: (1) updating the state of the network, but also, (2)
evicting the stash. The tracker determines the path to be
evicted, tag = ν mod 2L and then fetches the position of
all blocks in the stash and the path, P(tag). The tracker
then generates, based on the least common ancestor al-
gorithm (LCA), a permutation π that maps every block

in A =(cid:31)stash, P(ν mod 2L,1),··· , P(ν mod 2L,L)(cid:30) to
its new position in A�, a new array that will replace the
evicted path and the stash. The block A[π(i)] will be
mapped obliviously to A�[i], for all i ∈ [|stash| + z · L].
The oblivious mapping between A and A� is performed
by invoking OblivSel between the tracker, the peers in

954  25th USENIX Security Symposium 

USENIX Association

10

Algorithm 4: Sync(s): OBLIVP2P-1 sync operation
Input: tracker state s
// Fetch necessary parameters

1 ν ← s;
2 {adr} ←PosMap −1(ν mod 2L);

3
4
5 end

set T = T∪ tag ← TagMap(adr);

for adr in {adr} do
6 set A =(cid:31)stash, P(ν mod 2L,1),··· , P(ν mod 2L,L)(cid:30);
Initialize an array A�, π ← LCA(T,ν);
// tracker generates key shares
for l from 1 to z· L +|stash| do

7

if ∃adr,l = PosMap(adr) then
set k ← KeyMap(adr);
set k�� = k� − k, k� $
←− Zq;
compute (�σl ,�rl ) = OblivSel.Gen(k��,π(l));

set k�� $

←− Zq, compute (�σl ,�rl )= OblivSel.Gen(k��,π(l));

8
9
10

11
12
13

14
15
16 end

17
18
19 end
20

else

end

// Peers generate the new array A�
for j from 1 to z· L +|stash| do

set A�[ j] = OblivSel.Select(�σ j,�r j, A);

for j ∈ [m], send A� j[1,··· ,|stash|] and A� j[|stash| + 1,··· ,L] to peers in
P(ν) and the stash, and update state s;

the path and m peers, |stash| + z· L times. Note that (1)
the blocks in A� are encrypted with a freshly-generated
key, and (2) the mapping is not disclosed to any peers in
the path as long as there is one non-colluding peer. Refer
to Algorithm 4 for more detail about the Sync algorithm.
Upload Algorithm. A peer can request the tracker to add
a ﬁle. For this, the tracker selects uniformly at random a
set of m peers. The peer sends the ﬁle in a form of blocks.
Every block is secret shared such that every peer in the
m peers receives a share. The tracker generates a secret
unique to the block, k. The tracker secret shares k to the
m peers. The peers evaluate a seed-homomorphic PRG
on the received shares and add it to the block share. Fi-
nally, the block is appended to a randomly selected peer
in the network to hold a part of the stash.

4.4 Optimization: Handling Bursts
OBLIVP2P-1 has a functional limitation inherited by
ORAMs. Any access cannot be started unless the pre-
vious one has concluded 2. In our case, the tracker can
handle fetching several blocks before starting the Sync
operation. In our setting, we target increasing the P2P
network throughput while leveraging the network storage
and communication. In order to build a scalable system,
we propose several optimizations.
O1: Replication. In Ring ORAM, A = 3 accesses can
be performed before an eviction is required. To support A
parallel accesses, we replicate every block A times in the
tree. This absorbs the fetching access time and allows A

simultaneous accesses, even for requests to the same re-
source. Additionally, we may replicate every block over
A times on different peers, in case that the peer hold-
ing the block is ofﬂine due to churn, and cannot serve
the block to the other peers. Lastly, the network opera-
tor can deploy multiple trackers to serve peers simulta-
neously, which leads to the throughput of OBLIVP2P-1
proportional to the number of trackers.
O2: Pipelining. While the eviction is highly paralleliz-
able in OBLIVP2P-1, an eviction can take a considerable
amount of time to terminate. If we denote by f the av-
erage number of fetch requests in the P2P network, and
by t the time to perform an eviction, then the system can
handle all the accesses if t < 1
f . However, in practice
t > 1
f and therefore the accesses will be queued and cre-
ates a bottleneck. To address this issue, we create mul-
tiple copies of the buckets that are run with different in-
stances of OBLIVP2P-1 protocol which overlays on the
same network. In the setup phase, every node creates l
copies of its bucket space. Every bucket will be associ-
ated to different versions of OBLIVP2P-1 instantiations.
For example, with replication we can handle A accesses
in parallel on the (same) ith version of the buckets, but
the upcoming accesses will be made on the (i + 1)th ver-
sion. This will absorb the eviction time. To sum up,
having different versions will increase the throughput of
the system to l
f . In order to prevent pipeline stalls, we
need to choose l ≥ t · f in our implementation.
Another aspect (not considered for our implementa-
tion) for further optimizations in our versioning solution
is to distribute the communication overhead of the peers
in the network. In fact, the peers holding blocks at the
higher level of the tree will be accessed more often com-
pared to lower levels. In order to distribute the communi-
cation load on the network peers, peers’ location can be
changed for different versions such that: the peer at the
ith level of the tree in the jth version will be placed at
the (L− i + 1)th level of the tree in the ( j + 1)th version.
O3: Parallelizing Computation across m Peers. The
scalar multiplication in the elliptic curve is expensive
and can easily delay the fetch and sync time. For this,
we consider every peer in the OblivSel as a set of peers.
Whenever there is a need to perform scalar multiplication
over a path, several peers participate in the computation
and only the representative of the set will perform the ag-
gregation. This optimization speeds up the OblivSel to be
proportional to the number of peers’ used to parallelize a
single peer.

5

Implementation and Evaluation

2We do not consider a multi-processor architectures as those con-

sidered in OPRAM literature [56].

Implementation. We implement a prototype of
OBLIVP2P-0 and OBLIVP2P-1 in Python. The im-

USENIX Association  

25th USENIX Security Symposium  955

11

plementation contains 1712 lines of code (LOC) for
OBLIVP2P-0 and 3226 for OBLIVP2P-1 accounting to a
total of 4938 lines measured using CLOC tool [61]. Our
prototype implementation is open source and available
online [34]. As our building block primitives, we im-
plement the Ring ORAM algorithm, IT-PIR construction
and seed-homomorphic PRG. For Ring ORAM, we have
followed the parameters reported by authors [52]. Each
bucket contains z = 4 blocks and s = 5 dummy blocks.
The eviction occurs after every 3 accesses. The blocks
in OBLIVP2P-0 are encrypted using AES-CBC with 256
bit key from the pycrypto library [62]. For implementing
IT-PIR and seed homomorphic PRG in OBLIVP2P-1, we
use the ECC library available in Python [63]. We use the
NIST P-256 elliptic curve as the underlying group.
Experimental Setup. We use the DeterLab network
testbed for our experiments [64]. It consists of 15 servers
running Ubuntu 14.04 with dual Intel(R) Xeon(R) hexa-
core processors running at 2.2 Ghz with 15 MB cache (24
cores each), Intel VT-x support and 24 GB of RAM. The
tracker runs on a single server while each of the remain-
ing servers runs approximately 2400 peers. Every peer
process takes up to 4− 60 MB memory which limits the
maximum network size to 214 peers in our experimental
set up. The tracker is connected to a 128 MBps link and
the peers in each server share a bandwidth link of 128
MBps as well. We simulate the bandwidth link following
the observed BitTorrent trafﬁc rate distribution reported
in [65]. In our experimental setting, multiple peers are
simulated on a single machine hence our reported results
here are conservative. In the real BitTorrent setting, ev-
ery peer has its own separate CPU.
Evaluation Methodology. To evaluate the scalability
and efﬁciency of our system, we perform measurements
for a) the overall throughput of the system b) the la-
tency for Fetch and Sync operations and c) the data
transferred through the tracker for both OBLIVP2P-0
and OBLIVP2P-1. All our results are the average of
50 runs with 95% conﬁdence intervals for each of them.
Along with the experimental results, we plot the theoret-
ical bounds computed based on Table 2. This helps us
to check if our experiments match our theoretical expec-
tations.
In addition, we perform separate experiments
to demonstrate the effect of our optimizations on the
throughput of our OBLIVP2P-1 protocol. For our ex-
periments in this section, we leverage the technical opti-
mization introduced in Section 4.4.

We vary the number of peers in the system from 24 to
214 peers (capacity of our testbed) and extrapolate them
to 221 peers. Note that, when increasing the number of
peers, we implicitly increase the total data size in the en-
tire network which is computed as the number of peers ×
the block size. That is, our P2P network handles a total

data size that spans from 16 KB to 32 GB. For our eval-
uation, we consider each peer holds one ORAM bucket
because of the limited available memory. In reality, ev-
ery peer can hold more buckets. Note that, we linearly
extrapolate our curves to show the expected results for
larger number of peers starting from 215 − 221 (shown
dotted in the Figures) , and therefore larger data size in
the network. Aligned to the chunks in BitTorrent, we
select our blocksize as 128 KB, 512 KB and 1 MB.

5.1 Linear Scalability with Peers
The throughput is an important parameter in designing a
scalable P2P protocol. We deﬁne the throughput, as the
number of bits that the system can serve per second.

From Figure 3a, we observe that the throughput of
OBLIVP2P-0 decreases with the increase in the total
number of peers in the network. For a network size
of 214 peers, the experimental maximum throughput is
0.91 MBps. As we extrapolate to larger network size,
the maximum throughput decreases, e.g., for 221 peers,
the throughput is 0.64 MBps. This shows that as the
network size increases, the tracker starts queuing the re-
quests that will eventually lead to a saturation. However,
for OBLIVP2P-1, the maximum throughput for network
size of 214 is 3.19 MBps and is 3.29 MBps when extrap-
olated to 221 peers. The throughput increases as there
are more peers available in the network to distribute the
computation costs. The throughput shows a similar be-
haviour for blocksize of 128 KB and 1 MB (as shown
in Figure 5). Hence, we expect OBLIVP2P-1 to provide
better throughput in a real setting where more compu-
tational and communication capacity for each peer can
be provisioned. The throughput values for OBLIVP2P-1
are calculated after applying all the 3 optimizations dis-
cussed in Section 4.4. The behaviour of the theoretical
throughput matches our experimental results. The theo-
retical throughput has higher values as it does not capture
the network latency in our test environment.
Result 1. Our results show that the centralized proto-
col is limited in scalability and cannot serve a large net-
work. Whereas, the throughput for OBLIVP2P-1 lin-
early scales (0.15− 3.39 MBps) with increasing number
of peers (25 − 221) in the network.
Result 2. For a block of size 512 KB and 214 peers,
OBLIVP2P-1 serves around 7 requests / second which
can be enhanced with multiple copies of ORAM trees in
the network.
Remark. The throughput may be acceptable to privacy-
conscious users (e.g., whistleblowers), where privacy
concerns outweigh download / upload latencies. As
long as the number of request initiators is small, the
perceived throughput remains competitive with a non-

956  25th USENIX Security Symposium 

USENIX Association

12

(cid:17)
(cid:16)
(cid:15)
(cid:14)
(cid:8)
(cid:13)
(cid:12)
(cid:11)

(cid:10)
(cid:9)
(cid:8)
(cid:5)
(cid:7)
(cid:2)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)

(cid:1)(cid:4)(cid:8)

(cid:1)(cid:7)(cid:4)

(cid:1)(cid:8)

(cid:1)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:5)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:4)(cid:5)(cid:6)

(cid:1)(cid:22)(cid:23)(cid:24)(cid:20)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:28)(cid:23)(cid:30)
(cid:1)(cid:22)(cid:23)(cid:24)(cid:20)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:28)(cid:23)(cid:31)
(cid:32)(cid:33)(cid:23)(cid:24)(cid:20)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:28)(cid:23)(cid:30)
(cid:32)(cid:33)(cid:23)(cid:24)(cid:20)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:28)(cid:23)(cid:31)

(cid:12)
(cid:11)
(cid:10)

(cid:9)
(cid:8)
(cid:7)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)

(cid:1)(cid:6)(cid:9)(cid:10)(cid:3)

(cid:1)(cid:5)(cid:9)(cid:6)(cid:7)

(cid:1)(cid:2)(cid:9)(cid:5)(cid:6)

(cid:1)(cid:8)(cid:2)(cid:5)

(cid:1)(cid:5)(cid:8)(cid:3)

(cid:1)(cid:2)(cid:5)(cid:7)

(cid:1)(cid:3)(cid:6)

(cid:1)(cid:4)(cid:5)

(cid:1)(cid:2)(cid:3)

(cid:20)(cid:21)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:20)(cid:21)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)

(cid:5)(cid:1)

(cid:5)(cid:2)

(cid:5)(cid:3)

(cid:5)(cid:4)(cid:4)

(cid:5)(cid:4)(cid:5)

(cid:5)(cid:4)(cid:1)

(cid:5)(cid:4)(cid:2)

(cid:5)(cid:4)(cid:3)

(cid:5)(cid:6)(cid:4)

(cid:5)(cid:1)

(cid:5)(cid:2)

(cid:5)(cid:3)

(cid:5)(cid:4)(cid:4)

(cid:5)(cid:4)(cid:5)

(cid:5)(cid:4)(cid:1)

(cid:5)(cid:4)(cid:2)

(cid:5)(cid:4)(cid:3)

(cid:5)(cid:6)(cid:4)

(cid:18)(cid:5)(cid:19)(cid:20)(cid:14)(cid:3)(cid:9)(cid:4)(cid:21)(cid:9)(cid:7)(cid:14)(cid:14)(cid:3)(cid:16)

(cid:13)(cid:14)(cid:10)(cid:15)(cid:4)(cid:16)(cid:8)(cid:17)(cid:18)(cid:8)(cid:19)(cid:4)(cid:4)(cid:16)(cid:11)

(cid:10)(cid:11)

(cid:9)
(cid:8)
(cid:7)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)

(cid:1)(cid:9)

(cid:1)(cid:8)

(cid:1)(cid:7)

(cid:1)(cid:6)

(cid:1)(cid:5)

(cid:1)(cid:4)

(cid:1)(cid:3)

(cid:1)(cid:2)

(cid:20)(cid:21)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:20)(cid:21)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:15)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)

(cid:4)(cid:1)

(cid:4)(cid:2)

(cid:4)(cid:3)

(cid:4)(cid:4)(cid:4)

(cid:4)(cid:4)(cid:5)

(cid:4)(cid:4)(cid:1)

(cid:12) (cid:13)(cid:14) (cid:15)(cid:4)(cid:16)(cid:8)(cid:17)(cid:18)(cid:8)(cid:19)(cid:4)(cid:4)(cid:16)(cid:10)

(cid:4)(cid:4)(cid:2)

(cid:4)(cid:4)(cid:3)

(cid:4)(cid:6)(cid:4)

(a) The throughput for OBLIVP2P-1 linearly
scales with the increase in network size.

(b) The latency for fetching a block for
OBLIVP2P-1 reduces up to 213 and then be-
comes constant.

(c) The latency for
sync operation for
OBLIVP2P-1 reduces up to 213 and then be-
comes constant.

Figure 3: Theoretical (Th) and experimental (Ex) comparison of OBLIVP2P-0 and OBLIVP2P-1 parameters for block size of 512 KB

(cid:10)
(cid:9)
(cid:3)
(cid:8)
(cid:7)
(cid:6)

(cid:5)
(cid:4)
(cid:2)
(cid:3)
(cid:2)
(cid:1)

(cid:1)(cid:7)(cid:5)(cid:6)

(cid:1)(cid:6)(cid:8)

(cid:1)(cid:4)(cid:6)

(cid:1)(cid:8)

(cid:1)(cid:4)

(cid:1)(cid:2)(cid:3)(cid:7)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:6)(cid:7)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)

(cid:20)(cid:21)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:20)(cid:21)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:29)
(cid:31)(cid:32)(cid:22)(cid:23)(cid:14)(cid:24)(cid:25)(cid:26)(cid:27)(cid:28)(cid:27)(cid:22)(cid:30)

(cid:12)(cid:22)(cid:23)(cid:24)(cid:25)(cid:9)(cid:26)(cid:12)
(cid:12)(cid:22)(cid:23)(cid:11)(cid:12)

(cid:17)
(cid:16)
(cid:15)
(cid:14)
(cid:8)
(cid:13)
(cid:12)
(cid:11)

(cid:10)
(cid:9)
(cid:8)
(cid:5)
(cid:7)
(cid:2)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)

(cid:1)(cid:4)(cid:8)

(cid:1)(cid:7)(cid:4)

(cid:1)(cid:8)

(cid:1)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:5)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:4)(cid:5)(cid:6)

(cid:1)(cid:2)(cid:14)(cid:4)(cid:3)(cid:14)(cid:8)(cid:21)(cid:29)(cid:27)(cid:20)
(cid:30)(cid:31)(cid:7)(cid:14)(cid:3)(cid:21)(cid:25)(cid:14)(cid:28)(cid:8)(cid:27)(cid:20)

(cid:1)(cid:6)(cid:10)

(cid:1)(cid:9)(cid:6)

(cid:1)(cid:10)

(cid:1)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:7)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:6)(cid:7)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:9)(cid:8)(cid:6)(cid:7)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:2)(cid:4)(cid:5)(cid:2)(cid:6)(cid:7)(cid:8)

(cid:17)
(cid:16)
(cid:15)
(cid:14)
(cid:8)
(cid:13)
(cid:12)
(cid:11)

(cid:10)
(cid:9)
(cid:8)
(cid:5)
(cid:7)
(cid:2)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)

(cid:7)(cid:1)

(cid:7)(cid:2)

(cid:7)(cid:3)

(cid:7)(cid:4)(cid:4)

(cid:7)(cid:4)(cid:5)

(cid:7)(cid:4)(cid:1)

(cid:7)(cid:4)(cid:2)

(cid:7)(cid:4)(cid:3)

(cid:7)(cid:6)(cid:4)

(cid:5)(cid:1)

(cid:5)(cid:2)

(cid:5)(cid:3)

(cid:5)(cid:4)(cid:4)

(cid:5)(cid:4)(cid:5)

(cid:5)(cid:4)(cid:1)

(cid:5)(cid:4)(cid:2)

(cid:5)(cid:4)(cid:3)

(cid:5)(cid:6)(cid:4)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:9)(cid:15)(cid:4)(cid:16)(cid:17)(cid:4)(cid:18)(cid:9)(cid:9)(cid:15)(cid:19)

(cid:18)(cid:5)(cid:19)(cid:20)(cid:14)(cid:3)(cid:9)(cid:4)(cid:21)(cid:9)(cid:7)(cid:14)(cid:14)(cid:3)(cid:16)

(cid:11)(cid:12)

(cid:12)(cid:9)

(cid:12)(cid:7)

(cid:12)(cid:4)

(cid:18)(cid:19)(cid:20)(cid:21)(cid:22)(cid:23)(cid:24)(cid:23)(cid:9)(cid:4)(cid:7)(cid:8)(cid:21)(cid:25)(cid:21)(cid:26)(cid:27)(cid:8)(cid:21)(cid:4)(cid:28)(cid:16)

Figure 4:
The data transferred through
the tracker for OBLIVP2P-0 increases linearly
with the number of peers

Figure 5: The throughput for blocksize 128
KB and 1 MB increases with increase in the
network size.

Figure 6: Impact of optimizations (O1-O3)
on the throughput of OBLIVP2P-1 for 214
peers and blocksize of 512 KB.

oblivious P2P system. Further, the network operator can
deploy multiple trackers to serve peers simultaneously,
which leads to the throughput of OBLIVP2P-1 propor-
tional to the number of trackers.

5.2 Latency Overhead and Breakdown
We deﬁne the latency as the time required to perform one
ORAM operation in our P2P protocol. We measure the
latency for the following operations:
Fetch. Figure 3b shows that the average time for fetch-
ing a block of 512 KB increases for OBLIVP2P-0 with
increase in the size of the network. This is due to the
increased computation and bandwidth overhead at the
tracker. However, for OBLIVP2P-1, the latency initially
reduces with the increasing number of peers (from 25 to
211 ) and then becomes constant after the network is large
enough (around 213) to distribute the computation cost
in the network3. OBLIVP2P-1 has a higher latency for
fetch as compared to OBLIVP2P-0 due to the expensive
computation required for performing scalar multiplica-
tion. The average time for fetching a block of size 512
KB is around 0.31 s for a network size of 214 peers and

3Since a large number of nodes (e.g., over 1000 nodes) share one
physical machine, its limited computation power drastically affects our
result. Therefore, to be more realistic, we use the ideal computing
and decoding/encoding time for each node solely in one physical ma-
chine as the computing time per node, and simulate our experiments
for OBLIVP2P-1.

remains steady with increase in the number of peers.
Sync. We measure the time for performing a sync op-
eration for different network sizes. Figure 3c shows
that the time for performing a sync operation increases
in OBLIVP2P-0 with increase in the number of peers.
Whereas for OBLIVP2P-1, the sync time reduces grad-
ually at ﬁrst and then becomes steady after the network
size reaches 213 peers which is as expected through our
theoretical calculation. OBLIVP2P-1 uses the peers in
the network to distribute the computation load and hence
the sync time tends to be steady for large network sizes.
Data transferred through tracker. Figure 4 shows the
amount of data that is transferred through the tracker per
request. We perform this measurement to show that the
centralized tracker becomes a bottleneck in OBLIVP2P-
0. The amount of data that the tracker has to pro-
cess increases with increase in the number of peers.
At 221 peers, the amount of data is 118 MB (almost)
reaching the bandwidth limit (128 MBps) of the tracker.
Whereas, for OBLIVP2P-1 the amount of data trans-
ferred is around 1 MB for 221 peers. This implies that
the tracker could manage up to 128 copies of ORAM tree
in parallel, which will increase the overall throughput by
128 times.
Result 3. OBLIVP2P has no centralized infrastructure
as a bottleneck, ensuring that communication and com-
putational overhead can be completely ofﬂoaded to the
network.

USENIX Association  

25th USENIX Security Symposium  957

13

5.3 Optimization Measurements

logq logNp).

We perform incremental experiments to quantify the im-
pact of each of the introduced optimizations on the over-
all throughput in Section 4.4, as shown in Figure 6. We
ﬁx the number of peers in the network to be equal to 214
and the block size to 512 KB. We chose our optimization
parameters based on our results in section 5.3. We ﬁx the
number of replicas to be equal to A = 3, i.e., the same
data block is replicated three times. The burst parameter
needs to be in O( B
logq logNp), where Np is the number
of peers, B the block size, and q the elliptic curve group
order. Finally, we ﬁx the number of parallel peers in the
OblivSel.Select algorithm to be in O( B
O1: Replication. Replication enables to perform A =
3 fetch operations in parallel. This implies that the
throughput theoretically increases 3 times when com-
pared to our baseline without any optimizations. Our
experimental results show that we have 2.55 times im-
provement over the baseline, as expected theoretically.
O2: Pipelining. We evaluate the effect of our optimiza-
tion (O2) that absorbs the eviction time by pipelining the
fetch requests to different versions of the ORAM tree in
the P2P network. We show that this optimization, when
coupled to (O1), has theoretically increased the overall
throughput by 23.05 times if compared to the baseline.
Our experiments are aligned to our theoretical results and
show 17.2 times improvement over the baseline with a
burst parameter of 17. Clearly, if the number of versions
increases beyond 17, then OBLIVP2P-1 can handle par-
allel accesses, hence increasing the system throughput.
O3: Parallelizing m peers. We measure the effect of
parallelizing the computation load of m peers by lever-
aging more peers in the network on the overall through-
put of the system. We increase the number of peers to
116 peers that are used to compute the fetch and sync
operations. Our theoretical result shows an improve-
ment of 4398 times over the baseline, when coupled with
(O1) and (O2). Our experiments support this result and
demonstrates 1589 times improvement, the difference is
due to the real network latency are not considered in our
theoretical calculation.
Result 4. OBLIVP2P-1 is subject to several optimiza-
tions due to its highly parallelizable design.

6 OBLIVP2P-1 Analysis

In this section, we present the theoretical analysis on
computation / communication overhead of tracker / peers
and security analysis for OBLIVP2P-1.

6.1 Performance
We report OBLIVP2P-1 computation and communica-
tion overhead for the tracker and the network in Table 2.
In particular, OBLIVP2P-1’s tracker transmits a number
of bits independent of the block size, the tracker does not
perform any computation on the blocksize or store any
block locally.
Tracker overhead. To fetch a block, the tracker invokes
OblivSel twice. While for the eviction, the tracker per-

ﬁcient to ﬁrst analyze OblivSel overhead and than just
conclude for the overall tracker overhead.

forms OblivSel(cid:31)L· z +|stash|(cid:30) times. That is, it is suf-
Within one instance of OblivSel, the tracker computes
an IT− PIR.Query that outputs m vectors for m peers,
each of size L· z +|stash|. Each IT− PIR.Query vector
costs logq(L· z +|stash|) bits, where q is the group or-
der. The tracker also needs to generate shares for the key,
where the shares are in Zq. That is, one OblivSel costs
the tracker O(cid:31)m· logq· (L· z +|stash|)(cid:30).
That is, the tracker has to transmit O(cid:31)m· logq· (L· z +
|stash|)2(cid:30) bits. Considering L,|stash| ∈ O(logN), q the
group order in poly(N), m the number of peers and z the
bucket size as constants, then the tracker needs to send
O(log3 N) bits independently of the block size. That is,
if block ∈ Ω(log3 N), the tracker has a constant commu-
nication work per block. Moreover, the tracker is very
lightweight as it does not perform any heavy computa-
tion such as encryption, decryption of blocks, which per-
mits the tracker to handle frequent accesses.
Peers overhead. Considering the communication be-
tween the peers,
the main communication overhead
comes from block transfer from the peers holding the
path to the selected m peers. The m peers are se-
lected uniformly at random. Each peer receives (z· L +
|stash|) blocks from the peers in the selected path and the
stash. That is, in terms of communication overhead, the
peers sends on average ∑L
N blocks
per peers in the network. Considering z constant and
L,|stash| ∈O(log N), implies that every peer is expected
to transmit O( logN
In terms of computation, the main computational bot-
tleneck consists of the scalar multiplication from the
seed homomorphic PRG. For every OblivSel, every peer
needs to perform (z· L +|stash|)· B
logq scalar multiplica-
B
tions per block. The second term,
logq, represents the
number of points that a block contains. We also have
(z· L +|stash|) instances of OblivSel during the eviction.
That is, the total number of scalar multiplication equals
logq(cid:30). Finally, the amortized com-
O(cid:31)(z· L +|stash|)2 · B
putation over the total number of peers in the network
equals O( log4 N
N ) multiplications per eviction, consider-
ing B ∈ Ω(log3 N) and q ∈ poly(N).

N ) blocks per access.

i=0

z

2i + (z·L+|stash|)

N

+ z

958  25th USENIX Security Symposium 

USENIX Association

14

6.2 Security Analysis
We show that OBLIVP2P-1 is an oblivious P2P as stated
by Deﬁnition 2.2. For this, it is sufﬁcient to show that an
adversary cannot distinguish between a randomly gener-
ated string and the access pattern leaked by any peer’s
real access. This underlines the fact that the access pat-
tern is independent of the address of the requested block.
In our threat model, the adversary can have access to the
content of buckets, monitors the communication between
the peers, and has a total view of the internal state of dis-
honest peers. Buckets’ content is assumed to be trans-
mitted without any additional layer of encryption.

We present our address-tag experiment AT that
captures our security deﬁnition.
Let OBLIVP2P
= (Setup, Upload, Fetch, Sync) represents an oblivi-
ous P2P protocol.
Let E = (Gen, Enc, Dec) be an
IND$− CPA encryption scheme. Let G be a secure
pseudo-random generator. ATOblivP2P
refers to the in-
stantiation of the address-tag experiment by algorithms
OBLIVP2P, E , G , and adversary A . We denote by Col
the event that m peers in the network collude and set
Pr[Col] = δm, by Bδm the Bernoulli distribution, and λ
the security parameter.

A ,E ,G

Since all Xi’s are independent,

In the following, we ﬁx the number of colluding peers
c ∈ O(Nε ), for 0 < ε < 1. We consider every peer in
the network as a random variable distributed based on
a Bernoulli distribution with probability equal to c
N ∈
O(Nε−1). Let us denote by (X1,··· ,Xm) the random
variables of the selected peers for every instantiation of
OblivSel. Note that Pr[Col] = Pr[X1 = 1 AND··· Xm =
then, Pr[Col] =
1].
i=1 Pr[Xi = 1] = ( c
Πm
N )m which im-
plies under our assumptions that δm ∈ O(2logN·m·(ε−1)).
In the following experiment, we only consider the
Fetch algorithm for obliviousness analysis.
In our
model, Upload sequences are indistinguishable by con-
struction assuming that peers uploads blocks that are ran-
domly distributed, and using random key for every block
encryption. The experiment ATOblivP2P
A ,E ,G (λ ,b) consists of:

N )m. That is, δm = ( c

(Fetch, adr,⊥) and sends it to the challenger C

• The adversary A picks one access operation
Bδm←−− {0,1}, if X = 1, then set var =
• If b = 1, pick X
adr , otherwise var = ⊥ and set
π1 ={(cid:31)P(tag,1),··· , P(tag,L)(cid:30), tag ← TagMap[adr],

(cid:31)Enc(q1),··· , Enc(qm)(cid:30),
(q1,··· ,qm) ← IT− PIR.Query(pos),
pos ← PosMap[adr], var}

If b = 0, set π0 = {(cid:31)P1,··· ,PL(cid:30) $
(cid:31)q1,··· ,qm(cid:30) $
←− {0,1}λ×m,⊥}

←− Gz×L,

15

• Adversary A has access to an oracle OOblivP2P that
issues the access patterns for polynomial number of
accesses (while paths are re-encrypted for every re-
quest)

• A outputs b�
• The output of the experiment is 1 if b = b�, other-
A ,E ,G (λ ,b�) = 1, we say that A won

wise 0. If ATOblivP2P
the experiment.

The experiment differentiates between a realistic set-
ting where the adversary can see the access pattern, and
in which a possible colluding setting can happen with
a pre-ﬁxed probability, δm, and an ideal setting where
the adversary receives a random string. We slightly re-
formulate Deﬁnition 2.2 below.
Deﬁnition 6.1. We say that a P2P is oblivious iff for
all PPT adversaries A , there exists a negligible function
negl such that:
Pr[ATOblivP2P

A ,E ,G (λ ,0) = 1] ≤ negl(λ )
If ∀N > 1, and ∀ε < 1, ∃m > 1 s.t.
Theorem 6.1.
2logN·m·(1−ε) ∈ negl(λ ), G is a secure pseudo-random
generator, E is IND$− CPA secure, then OBLIVP2P-1
is an oblivious P2P as in Deﬁnition 6.1.

A ,E ,G (λ ,1) = 1]−Pr[ATOblivP2P

Proof. To prove our theorem, we proceed with a succes-
sion of games as follows:
• Game0 is exactly the same as ATOblivP2P
• Game1 is the same as Game0 except that the blocks
in the buckets P(tag,i) are replaced with random
points from G

A ,E ,G (λ ,1)

• Game2 is the same as Game1 except that the the en-
crypted IT− PIR queries are replaced with random
strings

From games’ description, we have

Pr[Game0 = 1] = Pr[ATOblivP2P

A ,E ,G (λ ,1) =1],

(1)

For Game1, we can build a distinguisher B1 that reduces
security of G to PRG security such that:

Pr[Game0 = 1]− Pr[Game1 = 1] ≤ AdvPRG

B1,G (λ ),

(2)

Similarly for Game1, we can build a distinguisher B2 that
reduces E to IND$− CPA security such that:
Pr[Game1 = 1]− Pr[Game2 = 1] ≤ AdvIND$−CPA
B2,E
We need now to compute Pr[Game2].

(λ ),

(3)

Pr[Game2] =Pr[Col]· Pr[Game2 = 1| Col]+
Pr[Col]· Pr[Game2 = 1| Col]
=δm + (1− δm)

1
N

USENIX Association  

25th USENIX Security Symposium  959

A ,E ,G (λ ,0) =1] = 1

N , since the

On the other side Pr[ATOblivP2P
tag is generated uniformly at random for every access.
Pr[Game2]−Pr[ATOblivP2P
From equations 1, 2, 3, and 4 we obtain:
A ,E ,G (λ ,1)]− Pr[ATOblivP2P
) +Adv IND$−CPA

A ,E ,G (λ ,0) =1] ≤
B2,E

A ,E ,G (λ ,0) = 1] = δm(1−

δm(1−

+ AdvPRG
B1,G .
Since δm ∈ O(2logN·m·(ε−1)), this ends our proof.

1
N

) (4)

Pr[ATOblivP2P

1
N

Quantitatively, if the number of peers in the network
equals 220, number of colluding peers in the network is
c = N 1
2 and m = 12, then δ12 = 2−120. Given the number
of colluding peers and total number of peer, the value of
m can always be adjusted to handle the desired colluding
probability δm. In case of churn, the fraction c can vary
and therefore the length of the circuit m has to be adapted
to the new value. Furthermore, we implicitly assumed so
far that no peer among the m selected leaves in the middle
of the OblivSel process. If that occurs, the entire process
has to abort, re-calculates the number of required peers
m, and perform the OblivSel from scratch.
7 Discussion

Existing approaches. A valid question to investigate is
whether existing solutions such as unlinkability or path
non-correlation techniques can be extended to handle
global adversaries and therefore prevent trafﬁc analysis
at the cost of providing more resources. It is easy to see
that unlinkability techniques (e.g., mixnet) can provide
better security in a P2P network under some assump-
tions. As an instance, assuming the case where a large
number of peers behave as senders and issue requests that
will be mixed by sufﬁcient network peers before being
answered by corresponding receivers’ peers. Also, as-
suming that there is at least one honest peer in the mixing
network, this solution would provide slightly the same
level of security as OBLIVP2P where a global adver-
sary cannot distinguish the senders’ peers access pattern.
However, this solution suffers from two downsides. First,
there is a need to have sufﬁcient number of senders’ peers
on-line in order to prevent intersection attacks. That is,
in order to prevent trafﬁc analysis, the number of senders
represents a security parameter of the system that has
to be maintained throughout the entire run of the sys-
tem. Second, as the receivers’ contents are theirs and are
not encrypted, plus, all peers are considered honest-but-
curious, a global adversary can easily ﬁnd out what con-
tent is being accessed independently of the sender iden-
tity. This therefore does not achieve obliviousness as de-
ﬁned in our work but only a weaker version of it. On

the other hand, path non-correlation techniques concep-
tually cannot prevent against global adversary as we have
detailed in Section 2. To sum up, it is not clear if existing
techniques, even if given enough resources, can provide
similar security insurances as those in OBLIVP2P.
Does better network & computation help? As em-
pirically demonstrated in our evaluation section,
the
throughput of OBLIVP2P is around 3.19 MBps while
considering only one tracker in the network. In a plain-
text version of P2P system such as BitTorrent, the net-
work leverages multiple trackers in order to handle more
queries, and therefore increase the overall throughput. In
OBLIVP2P, if we consider multiple copies of the entire
network, we can also handle multiple trackers, and the
throughput is expected to increase linearly with the num-
ber of trackers. However, as we delegate computation to
the peers in OBLIVP2P, increasing the number of track-
ers beyond a particular threshold might turn out to be
useless as the computation would represent a bottleneck
of the system. As future work, we plan to investigate
the asymptotic and empirical implications of including
multiple trackers in the system. Moreover, it would be
interesting to ﬁnd out the relation between the number
of trackers, number of peers for an ideal throughput of
OBLIVP2P.

8 Related Work

Long-term trafﬁc analysis. Anonymous systems like
mix networks and onion routing are susceptible to long-
term trafﬁc analysis as shown in Section 2. Statis-
tical disclosure attacks proposed by Danezis and en-
hanced by other researchers improve the likelihood of
de-anonymizing users on these systems [66–73]. More-
over, existing trafﬁc analysis attacks on onion routing
based approaches [27–30, 45] can reveal users’ iden-
tities with observing multiple communication rounds.
Other P2P systems like Crowds [19], Tarzan [18], Mor-
phMix [20], AP3 [21], Salsa [22], ShadowWalker [23],
Freenet [3] offer anonymity for users. However, these
systems show limits against global adversary with long-
term trafﬁc analysis capabilities.
Side-Channels. Previous work has shown possible at-
tacks by leveraging side channels such as packet sizes,
number of packets and timing. These side channels leak
users’ private information, e.g., illnesses/medications/-
surgeries, income and investment secrets [74]. An at-
tacker can employ machine learning techniques (e.g.,
Support Vector Machines) on network trafﬁc to identify
the user’s browsing websites [28–30, 45]. However, our
focus in this paper is to only prevent long-term pattern
trafﬁc analysis. The aforementioned side-channels of
trafﬁc analysis are out of scope.

960  25th USENIX Security Symposium 

USENIX Association

16

Multi-servers and parallel ORAM. There have been
works on how to optimize ORAM constructions while
leveraging multiple servers [75–77], multiple CPUs [56,
78], computational servers [53, 54], or distributed under
a weaker threat model [55] . However, none of these re-
cent constructions ﬁt to a P2P setting as is. This is mainly
due to the inherent client / server setting that results on a
single entity bottleneck. The client has to either perform
non-trivial computation or/and transmit several amount
of bits. We brieﬂy discuss these works below.

OblivStore [76], Lu and Ostrovsky [75], and Stefanov
and Shi [77] demonstrate how to decrease the communi-
cation overhead while leveraging multiple ORAM nodes
and servers. However, all these constructions are central-
ized and route the block through the tracker. This leads
to a single entity bottleneck.

Recently, researchers have proposed oblivious parallel
RAM (OPRAM) [56, 78]. This was motivated by cur-
rent multi-cpu architectures that can access the same or
multiple resources in parallel. However, OPRAM does
not decrease the communication overhead making it as
well a single-entity bottleneck. Dachman-Soled et al. in-
troduced oblivious network RAM (ONRAM) [55]. ON-
RAM can reduce the communication overhead between
the client and multiple banks of memory to be constant in
the number of blocks. However, it assumes a weak threat
model, and cannot achieve obliviousness in the case of a
global adversary.

9 Conclusion

We advocate hiding data access patterns as a necessary
step in defenses against long-term trafﬁc pattern analysis
in P2P content sharing systems. To this end, we propose
OBLIVP2P— an oblivious peer-to-peer protocol. Our
evaluation demonstrates that OBLIVP2P is parallelizable
and linearly scalable with increase in number of peers,
without bottleneck on a single entity.
Acknowledgement. We thank the anonymous reviewers of
this paper for their helpful feedback. We also thank Erik-Oliver
Blass, Travis Mayberry, Shweta Shinde and Hung Dang for
useful discussions and feedback on an early version of the pa-
per. This work is supported by the Ministry of Education, Sin-
gapore under under Grant No. R-252-000-560-112. All opin-
ions expressed in this work are solely those of the authors. A
note of thanks to the DeterLab team [64] for enabling access to
the infrastructure.

References
[1] “Bittorrent,” http://www.bittorrent.com/.
[2] “Storj.io,” http://storj.io/.
[3] “Freenet: The free network,” https://freenetproject.org.
[4] “Akamai,” http://www.akamai.com/.

[5] S. Iyer, A. Rowstron, and P. Druschel, “Squirrel: A decentralized

peer-to-peer web cache,” in PODC, 2002.
surge

bittorrent

[6] “Utorrent

&

lion
bittorrent-surges-to-150-million-monthly-users-120109/.

monthly

users,”

to

mil-
https://torrentfreak.com/

150

alto

[7] “Palo
port,”
app-usage-risk-report-visualization/.

networks

application

re-
http://researchcenter.paloaltonetworks.com/

usage & threat

[8] M. Piatek, T. Kohno, and A. Krishnamurthy, “Challenges and di-
rections for monitoring p2p ﬁle sharing networks, or, why my
printer received a dmca takedown notice,” in HotSec, 2008.

[9] G. Siganos, J. M. Pujol, and P. Rodriguez, “Monitoring the bit-

torrent monitors: A bird’s eye view,” in PAM, 2009.

[10] S. Le Blond, C. Zhang, A. Legout, K. Ross, and W. Dabbous, “I
know where you are and what you are sharing: exploiting p2p
communications to invade users’ privacy,” in IMC, 2011.

[11] D. L. Chaum, “Untraceable electronic mail, return addresses, and

digital pseudonyms,” Communications of the ACM, 1981.

[12] G. Danezis, R. Dingledine, and N. Mathewson, “Mixminion: De-
sign of a type iii anonymous remailer protocol,” in IEEE S&P,
2003.

[13] U. M¨oller, L. Cottrell, P. Palfrader, and L. Sassaman, “Mixmaster

protocol-version 2,” 2003.

[14] M. G. Reed, P. F. Syverson, and D. M. Goldschlag, “Anonymous

connections and onion routing,” J-SAC, 1998.

[15] R. Dingledine, N. Mathewson, and P. F. Syverson, “Tor: The

second-generation onion router,” in USENIX Security, 2004.

[16] T. Wang, K. Bauer, C. Forero, and I. Goldberg, “Congestion-

aware path selection for tor,” in FC, 2012.

[17] M. Akhoondi, C. Yu, and H. V. Madhyastha, “Lastor: A low-

latency as-aware tor client,” in IEEE S&P, 2012.

[18] M. J. Freedman and R. Morris, “Tarzan: A peer-to-peer

anonymizing network layer,” in CCS, 2002.

[19] M. K. Reiter and A. D. Rubin, “Crowds: Anonymity for web

transactions,” TISSEC, 1998.

[20] M. Rennhard and B. Plattner, “Introducing morphmix: peer-to-
peer based anonymous internet usage with collusion detection,”
in WPES, 2002.

[21] A. Mislove, G. Oberoi, A. Post, C. Reis, P. Druschel, and D. S.
Wallach, “Ap3: Cooperative, decentralized anonymous commu-
nication,” in SIGOPS European Workshop, 2004.

[22] A. Nambiar and M. Wright, “Salsa: a structured approach to

large-scale anonymity,” in CCS, 2006.

[23] P. Mittal and N. Borisov, “Shadowwalker: peer-to-peer anony-
mous communication using redundant structured topologies,” in
CCS, 2009.

[24] A. Pﬁtzmann and M. Hansen, “Anonymity, unlinkability,
undetectability, unobservability, pseudonymity, and identity
management-a consolidated proposal for terminology,” Version
v0, 2008.

[25] D. Agrawal and D. Kesdogan, “Measuring anonymity: The dis-

closure attack,” IEEE S&P, 2003.

[26] D. Kesdogan and L. Pimenidis, “The hitting set attack on

anonymity protocols.” in IH, 2004.

[27] M. Edman and P. Syverson, “As-awareness in tor path selection,”

in CCS, 2009.

[28] K. P. Dyer, S. E. Coull, T. Ristenpart, and T. Shrimpton, “Peek-a-
boo, i still see you: Why efﬁcient trafﬁc analysis countermeasures
fail,” in IEEE S&P, 2012.

USENIX Association  

25th USENIX Security Symposium  961

17

[29] T. Wang and I. Goldberg, “Improved website ﬁngerprinting on

tor,” in WPES, 2013.

[54] T. Moataz, T. Mayberry, and E.-O. Blass, “Constant Communi-

cation ORAM with Small Blocksize,” in CCS, 2015.

[30] T. Wang, X. Cai, R. Nithyanand, R. Johnson, and I. Goldberg,
“Effective attacks and provable defenses for website ﬁngerprint-
ing,” in USENIX Security, 2014.

[31] “Bittorrent over tor isn’t a good idea,” https://blog.torproject.org/

blog/bittorrent-over-tor-isnt-good-idea.

[32] S. L. Blond, P. Manils, C. Abdelberi, M. A. D. Kaafar, C. Castel-
luccia, A. Legout, and W. Dabbous, “One bad apple spoils the
bunch: exploiting p2p applications to trace and proﬁle tor users,”
arXiv, 2011.

[33] O. Goldreich and R. Ostrovsky, “Software protection and simu-

lation on oblivious rams,” J. ACM, 1996.

[34] “Oblivious peer-to-peer protocol,” https://github.com/jiayaoqijia/

OblivP2P-Code.

[35] “Gnutella,” https://en.wikipedia.org/wiki/Gnutella.
[36] Y. Jia, G. Bai, P. Saxena, and Z. Liang, “Anonymity in peer-
assisted cdns: Inference attacks and mitigation,” in PETS, 2016.
[37] “Scaneye’s global bittorrent monitor,” http://www.cogipas.com/

anonymous-torrenting/torrent-monitoring/.

[38] K. Bauer, D. McCoy, D. Grunwald, and D. Sicker, “Bitstalker:
Accurately and efﬁciently monitoring bittorrent trafﬁc,” in WIFS,
2009.

[39] T. Chothia, M. Cova, C. Novakovic, and C. G. Toro, “The unbear-
able lightness of monitoring: Direct monitoring in bittorrent,” in
SECURECOMM, 2012.

[40] G. Danezis and C. Diaz, “A survey of anonymous communication

channels,” Tech. Rep., 2008.

[41] H. Corrigan-Gibbs, D. Boneh, and D. Mazi`eres, “Riposte: An
anonymous messaging system handling millions of users,” in
IEEE S&P, 2015.

[42] M. Backes, A. Kate, S. Meiser, and E. Mohammadi, “(nothing
else) mator(s): Monitoring the anonymity of tor’s path selection,”
in CCS, 2014.

[43] “Tor

suffers

trafﬁc

//www.techtimes.com/articles/11711/20140802/
tor-suffers-trafﬁc-conﬁrmation-attacks-say-goodbye-to-
anonymity-on-the-web.htm .

conﬁrmation

attack,”

http:

[44] “Trafﬁc conﬁrmation attack,” https://blog.torproject.org/blog/

tor-security-advisory-relay-early-trafﬁc-conﬁrmation-attack.

[45] A. Panchenko, L. Niessen, A. Zinnen, and T. Engel, “Website
ﬁngerprinting in onion routing based anonymization networks,”
in WPES, 2011.

[46] J. Kong, W. Cai, and L. Wang, “The evaluation of index poisoning

in bittorrent,” in ICCSN, 2010.

[47] K. El Defrawy, M. Gjoka, and A. Markopoulou, “Bottorrent:

Misusing bittorrent to launch ddos attacks.” SRUTI, 2007.

[48] “Software Guard Extensions Programming Reference.” software.

intel.com/sites/default/ﬁles/329298-001.pdf, 2013.

[49] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio:

Nearly practical veriﬁable computation,” in IEEE S&P, 2013.

[50] E. Shi, T.-H. Chan, E. Stefanov, and M. Li, “Oblivious RAM with

O(log3(N)) Worst-Case Cost,” in ASIACRYPT, 2011.

[51] E. Stefanov, M. van Dijk, E. Shi, C. Fletcher, L. Ren, X. Yu, and
S. Devadas, “Path ORAM: an extremely simple oblivious RAM
protocol,” in CCS, 2013.

[52] L. Ren, C. Fletcher, A. Kwon, E. Stefanov, E. Shi, M. van Dijk,
and S. Devadas, “Constants Count: Practical Improvements to
Oblivious RAM ,” in USENIX Security, 2014.

[53] S. Devadas, M. van Dijk, C. Fletcher, L. Ren, E. Shi, and
D. Wichs, “Onion ORAM: A Constant Bandwidth Blowup Obliv-
ious RAM,” IACR, 2015.

[55] D. Dachman-Soled, C. Liu, C. Papamanthou, E. Shi, and
U. Vishkin, “Oblivious network RAM and leveraging parallelism
to achieve obliviousness,” in ASIACRYPT, 2015.

[56] E. Boyle, K. Chung, and R. Pass, “Oblivious parallel RAM and

applications,” in TCC, 2016.

[57] D. S. Roche, A. J. Aviv, and S. G. Choi, “A practical oblivi-
ous map data structure with secure deletion and history indepen-
dence,” IACR, 2015.

[58] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan, “Private

information retrieval,” in FOCS, 1995.

[59] D. Boneh, K. Lewi, H. W. Montgomery, and A. Raghunathan,
“Key homomorphic prfs and their applications,” in CRYPTO,
2013.

[60] M. Naor and O. Reingold, “Number-theoretic constructions of

efﬁcient pseudo-random functions,” in FOCS, 1997.

[61] “Cloc,” http://cloc.sourceforge.net/.

[62] “Python cryptography toolkit,” https://pypi.python.org/pypi/

pycrypto.

[63] “Python ecc,” https://github.com/johndoe31415/joeecc.

[64] “Deterlab,” https://www.isi.deterlab.net/index.php3.

[65] A. R. Bharambe, C. Herley, and V. N. Padmanabhan, “Analyz-
ing and improving bittorrent performance,” Microsoft Research,
2005.

[66] G. Danezis, “Statistical disclosure attacks,” in Security and Pri-

vacy in the Age of Uncertainty, 2003.

[67] G. Danezis, C. Diaz, and C. Troncoso, “Two-sided statistical dis-

closure attack,” in PETS, 2007.

[68] G. Danezis and A. Serjantov, “Statistical disclosure or intersec-

tion attacks on anonymity systems,” in IH, 2005.

[69] N. Mathewson and R. Dingledine, “Practical trafﬁc analysis: Ex-

tending and resisting statistical disclosure,” in PETS, 2005.

[70] N. Mallesh and M. Wright, “The reverse statistical disclosure at-

tack,” in IH, 2010.

[71] C. Troncoso, B. Gierlichs, B. Preneel, and I. Verbauwhede, “Per-

fect matching disclosure attacks,” LNCS, 2008.

[72] G. Danezis and C. Troncoso, “Vida: How to use bayesian in-
ference to de-anonymize persistent communications,” in PETS,
2009.

[73] F. P´erez-Gonz´alez and C. Troncoso, “Understanding statistical

disclosure: A least squares approach,” in PETS, 2012.

[74] S. Chen, R. Wang, X. Wang, and K. Zhang, “Side-channel leaks
in web applications: A reality today, a challenge tomorrow,” in
IEEE S&P, 2010.

[75] S. Lu and R. Ostrovsky, “Distributed oblivious RAM for secure

two-party computation,” in TCC, 2013.

[76] E. Stefanov and E. Shi, “Oblivistore: High performance oblivious

distributed cloud data store,” in NDSS, 2013.

[77] ——, “Multi-cloud oblivious storage,” in CCS, 2013.

[78] B. Chen, H. Lin, and S. Tessaro, “Oblivious parallel RAM: im-
proved efﬁciency and generic constructions,” in TCC, 2016.

18

962  25th USENIX Security Symposium 

USENIX Association

