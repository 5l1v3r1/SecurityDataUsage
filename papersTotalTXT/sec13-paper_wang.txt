MetaSymploit: Day-One Defense against  

Script-based Attacks with Security-Enhanced 

 Symbolic Analysis

Ruowen Wang, Peng Ning, Tao Xie, and Quan Chen, North Carolina State University

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4MetaSymploit: Day-One Defense Against Script-based Attacks with

Security-Enhanced Symbolic Analysis

Ruowen Wang, Peng Ning, Tao Xie, Quan Chen

Department of Computer Science
North Carolina State University

Raleigh, NC, USA

{rwang9, pning, qchen10}@ncsu.edu, xie@csc.ncsu.edu

Abstract

A script-based attack framework is a new type of cyber-
attack tool written in scripting languages. It carries var-
ious attack scripts targeting vulnerabilities across differ-
ent systems. It also supports fast development of new at-
tack scripts that can even exploit zero-day vulnerabilities.
Such mechanisms pose a big challenge to the defense
side since traditional malware analysis cannot catch up
with the emerging speed of new attack scripts. In this
paper, we propose MetaSymploit, the ﬁrst system of fast
attack script analysis and automatic signature generation
for a network Intrusion Detection System (IDS). As soon
as a new attack script is developed and distributed, Meta-
Symploit uses security-enhanced symbolic execution to
quickly analyze the script and automatically generate
speciﬁc IDS signatures to defend against all possible at-
tacks launched by this new script from Day One. We im-
plement a prototype of MetaSymploit targeting Metas-
ploit, the most popular penetration framework.
In the
experiments on 45 real attack scripts, MetaSymploit au-
tomatically generates Snort IDS rules as signatures that
effectively detect the attacks launched by the 45 scripts.
Furthermore, the results show that MetaSymploit sub-
stantially complements and improves existing Snort rules
that are manually written by the ofﬁcial Snort team.

1

Introduction

Over the years, with rapid evolution of attacking tech-
niques, script-based attack frameworks have emerged
and become a new threat [2, 3, 6, 39]. A script-based at-
tack framework is an attack-launching platform written
in scripting languages, such as Ruby and Python. Such
framework carries various attack scripts, each of which
exploits one or more vulnerabilities of a speciﬁc applica-
tion across multiple versions. With the high productivity
of using scripting languages, attackers can easily develop
new attack scripts to exploit new vulnerabilities.

To launch an attack, an attacker runs an attack script on
the framework remotely. By probing a vulnerable target
over the network, the attack script dynamically composes
an attack payload, and sends the payload to the target to
exploit the vulnerability. The attack framework also pro-
vides many built-in components with APIs of various at-
tack functionalities to support rapid development of new
attack scripts. Once a zero-day vulnerability is found,
a new attack script can be quickly developed and dis-
tributed in hacking communities, where other attackers
even script kiddies can directly download the new script
to launch attacks exploiting the zero-day vulnerability.

A well-known example of the script-based attack
frameworks is Metasploit [3], the most popular Ruby-
based penetration framework.
It has more than 700
attack scripts targeting various vulnerable applications
on different operating systems (OSes).
It also pro-
vides built-in components for creating new attack scripts.
Metasploit was originally developed for penetration test-
ing using proof-of-concept scripts. But with years of im-
provements, it has become a full-ﬂedged attack frame-
work. Unfortunately, as an open source project, Metas-
ploit can be easily obtained and used by attackers for
illegal purposes. For example, it was reported that the
well-known worm “Conﬁcker” used a payload generated
by Metasploit to spread [5]. A Metasploit attack script
was immediately distributed after a zero-day vulnerabil-
ity was found in Java 7 [32]. A four-year empirical study
shows real malicious network trafﬁc related to Metas-
ploit on a worldwide scale. Moreover, the study shows
that many Metasploit attack scripts are used by attack-
ers almost immediately after the scripts are distributed in
hacking communities [33].

When a new attack script is distributed and captured
by security vendors, the traditional approach to defend
against it is to ﬁrst set up a controlled environment with
a vulnerable application installed. Then security analysts
repeatedly run the script to exploit the environment over
a monitored network, collecting a large number of at-

USENIX Association  

22nd USENIX Security Symposium  65

tack payload samples, and ﬁnally extract common pat-
terns from the samples to generate IDS signatures.

However, with the attack framework, new attack
scripts can be quickly developed and distributed to ex-
ploit the latest vulnerabilities. This poses a great chal-
lenge that the traditional approach can hardly catch up
with the release speed of new attacks, due to the time-
consuming process of setting up test environments and
analyzing attack payload samples.
In our evaluation
(Section 5), we observe that even the latest Snort IDS
rules written by security analysts cannot detect many
Metasploit-based attacks.

In this paper, we propose MetaSymploit, the ﬁrst sys-
tem of fast attack script analysis and automatic IDS sig-
nature generation. As soon as a new attack script is dis-
tributed, MetaSymploit quickly analyzes the attack script
and automatically generates IDS signatures of its attack
payloads, thereby providing defense against new attacks
launched by this script from Day One. Particularly,
MetaSymploit gives the ﬁrst aid to zero-day vulnerabil-
ities whose security patches are not available while the
attack scripts that exploit them are already distributed.

Speciﬁcally, MetaSymploit leverages symbolic execu-
tion while enhancing it with several security features de-
signed for attack script analysis and signature genera-
tion. By treating environment-dependent values as sym-
bolic values, MetaSymploit symbolically executes attack
scripts without interacting with actual environments or
vulnerable applications, thus substantially reducing the
time and cost of the analysis. With path exploration of
symbolic execution, MetaSymploit also explores differ-
ent execution paths in an attack script, exposing different
attack behaviors and payloads that the script produces
under different attack conditions.

To generate signatures of attack payloads, instead of
analyzing large volumes of payload samples, MetaSym-
ploit keeps track of the payload composing process in the
attack script during symbolic execution. MetaSymploit
uses symbolic values to represent variant contents in a
payload (e.g., random paddings), in order to distinguish
constant contents (e.g., vulnerability-trigger bytes) from
variant ones. When the script sends a composed payload
to launch an attack, MetaSymploit captures the payload’s
entire contents, extracts constant contents as patterns and
generates a signature speciﬁc to this payload.

In a case study, we implement a security-enhanced
symbolic execution engine for Ruby, develop MetaSym-
ploit as a practical tool targeting Metasploit, and gener-
ate Snort rules as IDS signatures. Particularly, instead
of heavily modifying the script interpreters, we design
a lightweight symbolic execution engine running on un-
modiﬁed interpreters. This lightweight design can keep
pace with the continuous upgrades of the language syn-
tax and interpreter (e.g., Ruby 1.8/1.9/2.0). Therefore,

our design supports analyzing attack scripts written in
different versions of the scripting language.

We evaluate MetaSymploit using real-world attack
scripts. We assess our automatically generated Snort
rules by launching attacks using 45 real-world Metas-
ploit attack scripts from exploit-db.com, including
one that exploits a zero-day vulnerability in Java 7. Our
rules successfully detect the attack payloads launched by
the 45 scripts. Furthermore, we also compare our rules
with the ofﬁcial Snort rule set written by security ana-
lysts, and have three ﬁndings: (1) the ofﬁcial rule set is
incomplete and 23 of the 45 attack scripts are not cov-
ered by the ofﬁcial rule set; (2) for the scripts covered by
the ofﬁcial rules, our rules share similar but more spe-
ciﬁc patterns with the ofﬁcial ones; (3) our studies also
expose 3 deﬁcient ofﬁcial rules that fail to detect Metas-
ploit attacks. Therefore, MetaSymploit is a helpful com-
plement to improve the completeness and accuracy of ex-
isting IDS signatures to defend against attack scripts.

In summary, we make three major contributions:

1. We point out the security issues of script-based at-
tacks, and propose a scalable approach called Meta-
Symploit that uses security-enhanced symbolic ex-
ecution to automatically analyze attack scripts and
generate IDS signatures for defense.

2. We implement a security-enhanced symbolic execu-
tion engine for Ruby and develop a practical tool for
the popular Metasploit attack framework. Our tool
can generate Snort rules to defend against newly
distributed Metasploit attack scripts from Day One.

3. We demonstrate the effectiveness of MetaSymploit
using recent Metasploit attack scripts in real-world
attack environments, and also show that Meta-
Symploit can complement and improve existing
manually-written IDS signatures.

2 Background

We ﬁrst give the background of how an attack script
works. Generally, when an attack script runs on top of an
attack framework, the script performs four major steps
to launch an attack.
(1) The script probes the version
and runtime environment of the vulnerable target over
the network.
(2) Based on the probing result and the
script’s own hard-coded knowledge base, the script iden-
tiﬁes the speciﬁc vulnerability existing in this target. The
knowledge base is usually a list containing the informa-
tion (e.g., vulnerable return addresses) of all targets that
this script can attack.
(3) Then the script dynamically
composes an attack payload customized for this target.
(4) Finally, the script sends the payload to the target to
exploit the vulnerability.

66  22nd USENIX Security Symposium 

USENIX Association

1 def exploit
connect()
2
preamble = "\x00\x4d\x00\x03\x00\x01"
version = probe_ver()
if version == 5

3

4

5

payload = prep_ark5()

else

payload = prep_ark4()

end
preamble << payload.length
sock.put(preamble) # Required by protocol
sock.get_once()
sock.put(payload) # Send attack payload
sock.get_once()
... # vulnerability triggered

6

7

8

9

10

11

12

13

14

19

20

21

22

23

15
16 end
17 def prep_ark5()
18

payload = shellcode()
payload << rand_alpha(1167 -

payload.length)

payload << "\xe98" + [-1172].pack("V")
payload << "\xeb\xf9"
payload << get_target_ret(5) # Tar_Ver: 5
payload << rand_alpha(4096 -

payload.length)

return payload

24
25 end

Listing 1: The code snippet from a real Metasploit attack script
type77.rb [4] (slightly modiﬁed for better presentation)

Depending on the attack strategy and vulnerability
type, different scripts may have different attack behav-
iors when performing these steps. For example, a brute-
force attack may keep composing and sending payloads
with guessed values until the target is compromised,
while a stealthy attack may carefully clean up the trace
in the target’s log after sending the payload.

Among these steps, composing and sending an attack
payload are the key steps of launching an attack. An at-
tack payload is typically a string of bytes composed with
four elements: (a) special and ﬁxed bytes that can ex-
ploit a speciﬁc vulnerability; (b) an arbitrary shellcode
that attackers choose to execute after the vulnerability is
exploited. The shellcode content is usually variant, espe-
cially when obfuscated; (c) random or special paddings
(e.g., NOP 0x90) that make the payload more robust; (d)
other format bytes required by network protocols.

With the help of the rich libraries of scripting lan-
guages and the built-in components provided by the at-
tack framework, an attack script can call APIs of related
libraries or components to help it perform each step, es-
pecially composing an attack payload.

As an example, Listing 1 shows a Ruby code snip-
pet extracted from a real Metasploit attack script exploit-
ing a vulnerable application called Arkeia.
In the ex-
ample, the script deﬁnes two methods. exploit is the
main method that performs the major steps to launch the
attack. prep ark5 is one of the payload composing
methods. When the script runs on Metasploit, it ﬁrst

alert tcp any any -> any 617 (
msg:"Script: type77 (Win), Target Version: 5,

Behavior: Version Probing, Stack Overflow,
Pattern: JMP to Shellcode with

Vul_Ret_Addr";

content:
"|e9 38 6c fb ff ff eb f9 ad 32 aa 71|";
pcre:"/[.]{1167}\xe9\x38\x6c\xfb\xff\xff\xeb\

xf9\xad\x32\xaa\x71[a-zA-Z]{2917}/";
classtype:shellcode-detect; sid:5000656;)

Listing 2: One Snort rule signature generated for the attack payload
composed by prep ark5.

connects to the target over the network (Line 2), and then
probes the target’s version (Line 4). Here both connect
and probe ver are API methods of a built-in network
protocol component. Based on the version, it calls the
corresponding method to start composing the attack pay-
load speciﬁc to the target (Lines 5-9).

When prep ark5 is called, the payload is ﬁrst as-
signed by the shellcode component, which returns a con-
ﬁgured shellcode (Line 18). Note that the shellcode can
be freely chosen and obfuscated. The shellcode compo-
nent offers several different shellcodes for different pur-
poses. Then the payload is appended (<<) with several
contents (Lines 19-23). rand alpha generates random
alphabet padding to not only extend the payload to the
required size of the network protocol, but also introduce
more randomness for evasion. The concrete bytes repre-
sent some assembly code that will jump to the shellcode
(e.g., “\xeb\xf9” and “\xe9” are two JMP instructions).
pack("V") converts the integer to bytes as the offset
of one JMP. get target ret is another attack frame-
work API that queries the script’s knowledge base (omit-
ted here due to space limit, please refer to [4]) to retrieve
the exploitable return address based on the target ver-
sion, which can hijack the control ﬂow1 (Line 22). After
the payload is composed, the script ﬁrst sends a pream-
ble packet to the target, followed by the attack payload
packet to exploit the vulnerability (Lines 11-13).

Popular attack frameworks provide plenty of built-in
components covering various network protocols, OSes,
and offering different shellcodes and NOP paddings,
which enable attackers to quickly develop new attack
scripts to exploit different targets. Furthermore, ad-
vanced attackers can create even sophisticated attack
scripts, which have multiple execution paths performing
different attack behaviors and payloads. Some of them
may be triggered only under certain attack conditions.

Therefore, the traditional approach that requires both
controlled environments and vulnerable applications is
not scalable for analyzing attack scripts. Since differ-

1In [4],

the exploitable return address actually points to a
POP/POP/RET instruction sequence, which is a typical SEH-based at-
tack to hijack control ﬂow in Windows.

USENIX Association  

22nd USENIX Security Symposium  67

68  22nd USENIX Security Symposium 

USENIX Association

entattackscriptstargetdifferentapplicationsandOSes,itiscostlyandtime-consumingtoobtaineveryapplica-tion(letalonetheexpensivecommercialones)andsetupenvironmentsforeveryOS.Itisevenhardertocre-atedifferentattackconditionstoexposedifferentattackbehaviorsandpayloadsinsophisticatedattackscripts.3MetaSymploitInthissection,weﬁrststatetheproblemandassumptionswefocuson,andthengiveanoverviewofMetaSymploit,followedbythedetailedtechniquesinitstwocoreparts.3.1ProblemStatementandAssumptionsProblemStatement.Wefocusontheproblemcausedbyscript-basedattackframeworksandtheirattackscripts:howtoprovideanautomatedmechanismthatcananalyzeanddefendagainstnewlydistributedattackscripts.Particularly,themechanismshouldbetime-efﬁcientinordertoaddressthesecurityissuescausedbytwomajorfeaturesofattackscripts:alargenumberofscriptswithwide-rangingtargets,andfastdevelopmentanddistributionofnewscriptsthatcanbedirectlyusedtoexploitzero-dayvulnerabilities.Assumptions.Weassumethatbothscript-basedat-tackframeworksandattackscriptsareavailablefromeitherpublicorundergroundhackingcommunities.Assoonasanewattackscriptisdistributed,itcanbeimmediatelycapturedandanalyzed.Wealsoassumethatthescriptinglanguagesusedbyattackframeworksaregeneral-purposeobject-orientedscriptinglanguages,suchasRubyandPython.Inreality,sectools.orglists11mostpopularattacktools[6]inthepubliccom-munity.8ofthemareRuby/Python-basedattackframe-works.Mostofthemareactivelymaintainedwithfre-quentupdatesofnewattackscripts.3.2MetaSymploitOverviewGivenanattackscript,thegoalofMetaSymploitistoquicklyanalyzeﬁne-grainedattackbehaviorsthatthescriptcanperform,andautomaticallygeneratespeciﬁcIDSsignaturesforeveryattackpayloadthatthescriptcancompose,providingafastandeffectivedefenseagainstattackslaunchedbythisscript.Toachievethisgoal,MetaSymploitleveragessymbolicexecutionandenhancesitwithanumberofsecurityfeaturesdesignedforattackscriptsanalysisandsignaturegeneration.Symbolicexecution2isaprogramanalysistechniquethatexecutesprogramswithsymbolicratherthancon-cretevalues.Whenexecutingbranchesrelatedtosym-2Formorebackgroundofsymbolicexecution,pleasereferto[25]Attack ScriptPreprocessor Symbolic Execution TracerNormalized ScriptReturn SolutionPath ConstraintsThird-Party Constraint SolversPayload ParserAttack OutputFine-grained Tracing DumpSuccessful/Failed Attack Paths;Sequence of Multi-Step Attacks;Pre & Post Conditions; Etc.IDS SignatureGeneratorPatterns & Malicious WeightsIDS SignaturesAttack Knowledge BaseSymbolic Class LibraryScript-based Attack FrameworkSymbolic API ExtensionBehavior & Constraint LoggingOutput API HookingConstant Pattern ExtractingPattern Refining & ConsolidatingPattern Context DerivingSymbolic Execution Layer (SymExeLayer)Attack ScriptAttack PayloadsBehavioral API Calls & Attack ConstraintsSignature Generation (SigGen)Extracted PatternsPattern ContextIDS SignaturesSymbolically executedFigure1:MetaSymploitconsistsoftwomajorpartsdrawningrey.(Thearrowsshowtheworkﬂowofanattackscriptanalysis.)bolicvalues,itmaintainsapathconstraintsetandforkstoexploredifferentexecutionpaths.Byusingsym-bolicexecution,MetaSymploithasthreeadvantagestoachievefastanalysisanddefenseagainstattackscripts:(1)analyzingscriptswithoutrequiringactualenviron-mentsorvulnerabletargets,(2)exploringdifferentex-ecutionpathstoexposedifferentattackbehaviors,(3)usingsymbolicvaluestorepresentvariantcontentsinat-tackpayloadstoeasetheextractionofconstantpatterns.Figure1showsthearchitectureofMetaSymploit,whichconsistsoftwomajorparts,thesymbolicexe-cutionlayer(SymExeLayer)andthesignaturegenerator(SigGen).Givenanattackframework,SymExeLayerisbuiltupontheframework.Itreusestheframework’sex-ecutionfacilitywhileextendingtheframeworkinterfacetosupportsymbolicexecutionofattackscripts.Whenascriptissymbolicallyexecuted,SymExeLayercapturesallattackbehaviorsandpayloadsthatthescriptcanper-formandcompose.Afterthesymbolicexecutionisdone,SigGentakesthecapturedresultsasinputs.Itextractsconstantpatternsbyparsingthecontentsoftheattackpayloads.Italsoanalyzestheattackbehaviorstoderivethesemanticcontextsthatdescribetheextractedpatterns.Finally,SigGencombinesthepatternsandthecontextstogenerateIDSsignaturesforthisattackscript.Morespeciﬁcally,threekeytechniquesaredevel-opedtorealizethefunctionalitiesofSymExeLayerandSigGen,respectively.AsshowninFigure1,SymExe-Layerconsistsof(1)SymbolicAPIExtension.ItextendstheAPIsofboththeattackframeworkandthescript-inglanguagetosupportsymbolicvaluesandoperations.Notably,itextendstheAPIsrelatedtoenvironments/tar-gets and variant payload contents to return symbolic val-
ues. (2) Behavioral API & Attack Constraint Logging. It
records critical API calls that represent attack behaviors.
It also logs path constraints of symbolic values related to
environments and targets. Both logs will be used for de-
riving pattern context (described later). (3) Output API
Hooking. It hooks various output APIs that are used to
send attack payloads, in order to capture complete pay-
load contents for extracting constant patterns.

SigGen consists of (1) Constant Pattern Extracting.
By parsing the payload contents, it extracts constant pat-
terns that can represent the payload. Constant patterns
include ﬁxed contents, ﬁxed lengths of contents, and
ﬁxed offsets of the contents in the format. (2) Pattern
Reﬁning and Consolidating.
It reﬁnes patterns by dis-
tinguishing critical patterns from common benign bytes
and trivial patterns. It also avoids generating duplicated
signatures by examining repeated patterns. (3) Pattern
Context Deriving. In order to describe what the extracted
pattern represents, it analyzes the logs of behaviors and
constraints to derive the semantic context of the pattern.
To illustrate the workﬂow of MetaSymploit, we revisit
the script in Listing 1. First, SymExeLayer takes the
script as input and symbolically executes it. The script
calls a number of symbolic-extended APIs, including
probe ver, shellcode and rand alpha. Instead
of returning a concrete number, probe ver assigns
version a symbolic integer representing the target ver-
sion. shellcode and rand alpha return symbolic
strings to represent all possible shellcodes and random
paddings, respectively. Meanwhile, probe ver indi-
cates the probing behavior. SymExeLayer logs it as one
attack behavior. SymExeLayer also logs the path con-
straint version==5 since it indicates that the Line 6
branch is taken only under the attack condition that the
target version is 5. In contrast, when symbolic execution
forks to explore Line 8, SymExeLayer logs the negated
constraint version!=5.

When executing prep ark5, SymExeLayer logs
shellcode, rand alpha, and get target ret,
since these APIs indicate a typical attack behavior of
composing a stack overﬂow payload. Note that because
get target ret is a call with a concrete argument,
SymExeLayer uses the underlying framework to execute
it normally to get the concrete return address value. On
the other hand, SymExeLayer symbolically extends the
<< API to support appending symbolic strings. Finally,
when the composed payload is sent, the hooked output
API sock.put captures the complete payload contents.
SigGen then analyzes the payload contents and the be-
havior & constraint logs to generate signatures. List-
ing 2 shows one Snort rule generated by SigGen. The
content is the byte pattern extracted from the constant
bytes in the payload composed in Lines 20-22. The ﬁrst 8

bytes are two JMP instructions and the last 4 bytes are the
return address. The pcre is a regular expression match-
ing the entire payload packet, including constant bytes
and random paddings. content provides general fast
matching, while pcre provides more precise matching.
The msg shows the pattern context. The target version
is derived from the version==5 constraint. The be-
havior and the meaning of the patterns are derived from
the logged behavioral API calls. The msg gives more in-
sights that guide security analysts to use the signature to
protect vulnerable application of speciﬁc version.

3.3 Symbolic Execution Layer
This section explains more details about the three tech-
niques of SymExeLayer that extend the attack frame-
work to perform symbolic execution and attack logging.

3.3.1 Symbolic API Extension

The key point of performing symbolic execution on at-
tack scripts is to treat all variant values involved in the
attack launching process as symbolic values, so that all
possible attack variations can be covered. Since attack
scripts use APIs to operate variant values, we extend the
variant-related APIs of both the scripting language and
the attack framework with symbolic support.

The variant-related APIs can be further divided into
two categories: direct and indirect. Direct-variant-
related APIs always return variant values. There are two
major types in this category, (1) the APIs probing ex-
ternal environments/targets, (2) the APIs generating ran-
dom payload contents.
In both cases, we replace the
original APIs with our symbolic-extended ones, which
directly return symbolic values when called. As a re-
sult, the ﬁrst type of APIs skips probing the actual en-
vironment/target, such as probe ver in the example.
Such skipping makes MetaSymploit scalable and efﬁ-
cient, since there is no need to prepare different environ-
ments or applications when analyzing different scripts.
For the second type, as the payload content is a string
of bytes, the APIs use symbolic values to represent any
variant bytes, such as shellcode and rand alpha.
Hence, we can clearly distinguish concrete contents from
symbolic contents in one payload.
In addition, every
symbolic value is assigned with a label showing what
it represents based on its related API, such as sym ver,
sym shellcode, and sym rand alpha. Note that
SymExeLayer uses these labels to keep the semantics of
the values, rather than relying on variable names, which
can be freely decided by attackers.

Indirect-variant-related APIs return variant values
only when their arguments are variant values. Such case
typically happens in the operations of some primitive

USENIX Association  

22nd USENIX Security Symposium  69

classes such as String, Integer, and some payload com-
posing operations.
In SymExeLayer, we extend such
APIs by adding the logic of handling symbolic argu-
ments. If the arguments are concrete, the APIs execute
the original logic and return concrete values as normal.
If the arguments are symbolic, the APIs switch to the
symbolic handling logic, which propagates the symbolic
argument in accord with the API functionality, and re-
turns a symbolic expression. In Listing 1, for a concrete
string argument, the symbolic-extended << appends it as
normal. For a symbolic argument, it holds both the orig-
inal string and the new appended symbolic one in order
and returns them as one symbolic string expression.

3.3.2 Behavioral API & Attack Constraint Logging

Since symbolic execution is a general program analysis
technique, in order to provide additional security analy-
sis of attack scripts, for every execution path, we keep
a log recording both critical API calls that reﬂect attack
behaviors and path constraints that represent the attack
condition when exploring each execution path.
Behavioral API Logging. As mentioned in Section 2,
attack scripts use APIs provided by the language library
and the attack framework to launch attacks. In the analy-
sis, it is critical to capture the API calls that perform the
detailed attack behaviors during the launching process.
There are two major types of behavioral APIs, network
protocol APIs and payload-related APIs. By logging the
ﬁrst type, we are able to capture all the interactions be-
tween the attack script and the target. By logging the sec-
ond type, we know exactly how a payload is composed
and keep track of its detailed format and contents.

In practice, given an attack framework, we build a
knowledge base collecting the APIs from the libraries
and components that provide network protocols and
payload-related operations. During execution, SymEx-
eLayer identiﬁes behavioral APIs and logs them while
keeping the API call sequence in the execution path.
Note that we also log the arguments and return values
of the APIs, especially for payload-related APIs, whose
return values may be a part of the payload contents.
Attack Constraint Logging.
In symbolic execution,
path constraints are the set of branch conditions involv-
ing symbolic values in one execution path. When en-
countering a new symbolic branch condition, symbolic
execution consults a constraint solver to decide which
branch(es) is feasible to take, and adds the new branch
constraint into the path constraint set. If both branches
are feasible to take, the execution path forks into two
paths to explore both branches [25].

In attack scripts, we focus on the constraints related to
environments and targets. We regard these constraints as
attack constraints because different symbolic conditions

that they represent typically indicate different attack con-
ditions reﬂecting the probing results of environments or
targets, therefore leading to different execution paths that
compose different payloads in consequence. In the ex-
ample, version==5 ? prep ark5 : prep ark4.

Recall that the APIs that probe external environments
and targets are symbolic-extended. The symbolic return
values of these APIs carry the labels showing what ex-
ternal source they represent. When executing a sym-
bolic branch condition, we check if any symbolic value
with external-source label is involved.
If so, we log
the corresponding constraint.
In the example, when
version==5 is executed, we ﬁnd that sym ver is an
external source, and thus log the constraint.

In summary, this behavior & constraint logging pro-
vides a ﬁne-grained analysis report that saves the time-
consuming work for security analysts. More importantly,
the behaviors and constraints logged in each execution
path can be further parsed to derive the semantic context
for the extracted patterns (discussed in Section 3.4.3).

3.3.3 Output API Hooking

After an attack script ﬁnishes composing an attack pay-
load, the script sends the payload as a network packet to
the target to exploit the vulnerability. This payload send-
ing step is the exact point of launching an attack. In order
to capture the complete content of the attack payload for
pattern extraction, we hook the output APIs that are used
by attack scripts for sending payload.

Starting from the network layer to the application layer
in the OSI model, we keep a list of the output APIs
and their corresponding network protocols from both the
scripting language’s own network library and the built-in
components of the attack framework.

We symbolically extend the output APIs by overrid-
ing their functionality from sending real network packets
to dumping the entire packets locally. By doing so, the
entire network ﬂow sent from the attack script can be
dumped throughout the execution. To keep the semantic
context of each dumped packet, we associate them with
the behavior & constraint log of that execution path, so
that later the payload packets can be identiﬁed and the
extracted patterns can be correlated with the context de-
rived from the log.
In the example script, the hooked
sock.put dumps two packets. With the associated log,
we identify the payload packet for pattern extraction.

Note that as a part of the network protocol APIs, the
output APIs are also behavioral APIs that need to be
logged. In addition, we also include the corresponding
network protocols in the log. Later during signature gen-
eration, the log gives a clear view of which network pro-
tocol is used, and therefore SigGen can apply the correct
packet format when parsing the packet contents.

70  22nd USENIX Security Symposium 

USENIX Association

18: payload=>[<sym_shellcode, len=Sym_Int>]
19: payload=>[<sym_shellcode, len=Sym_Int>,

<sym_rand_alpha, len=(1167-Sym_Int)>]

20-22: # Appending concrete substrings
payload => [<sym_shellcode, len=Sym_Int>,

<sym_rand_alpha, len=(1167-Sym_Int)>,
<"\xe9\x38\x6c\xfb\xff\xff\xeb\xf9
\xad\x32\xaa\x71", 12>]

23: payload => [<sym_shellcode, len=Sym_Int>,

<sym_rand_alpha, len=(1167-Sym_Int)>,
<"\xe9\x38\x6c\xfb\xff\xff\xeb\xf9
\xad\x32\xaa\x71", 12>,
<sym_rand_alpha, 2917>]

Listing 3: The symbolic string form showing the content of payload
when prep ark5 is executed. Sym Int is a symbolic integer
representing the size of the shellcode.

3.4 Signature Generator
Given the dumped payload packets and the logs as inputs,
SigGen includes three techniques to generate signatures.

3.4.1 Constant Pattern Extracting

In order to generate a signature that can detect a payload
packet, it is necessary to extract a set of constant patterns
that always stay the same across different variations of
the payload. Speciﬁcally, there are three constant pat-
terns that can be extracted: ﬁxed-content pattern, ﬁxed-
length pattern and ﬁxed-offset pattern. For ease of ex-
planation, we ﬁrst present the formal form of a dumped
symbolic attack payload.

Recall that an attack payload is a string of bytes con-
taining both concrete contents (e.g., ﬁxed vulnerable re-
turn address) and variant contents (e.g., arbitrary shell-
code, random padding). When a payload is being com-
posed during the symbolic execution of the attack script,
we use symbolic strings to represent variant contents and
use extended APIs to perform symbolic string opera-
tions, while keeping concrete values and operations as
normal. Thus the dumped payload packet is a big sym-
bolic string composed of a sequence of substrings, where
each substring is either a concrete byte string or a sym-
bolic string by itself. Formally, Ssym = (s1s2 . . .s i . . .s n),
where si ∈ {Scon}∪{Ssym}. In addition, we also embed
< sym label,length > in Ssym to keep the semantics and
the possible length of the string, where the length is ei-
ther a concrete or symbolic integer. As an example, List-
ing 3 shows the contents of the payload when being com-
posed in Lines 18-23 of the example script. The ﬁnal
dumped payload is the same as the one in Line 23.
Fixed-content pattern. This pattern has two types, ei-
ther a simple byte string or a regular expression (regex).
When parsing the payload, for each concrete substring,
we extract it as a byte string pattern, such as the 12-byte
string in the payload of Line 23. For each symbolic sub-

string, if it can be matched by a regex, we extract the
regex as a ﬁxed pattern. If no regex is found, we move
on to the next substring.
In practice, we keep a map-
ping between regex-matchable symbolic labels and the
regexes. Currently, we mainly focus on using regexes on
payload paddings to achieve precise matching. For in-
stance, we map the symbolic label sym rand alpha
to a regex pattern [a-zA-Z].
Fixed-length pattern.
In some cases, although the
contents may vary, their lengths stay the same. Such
case typically happens when using padding to meet the
size requirement. To achieve precise matching, SymEx-
eLayer keeps track of the payload length during the
composition. When parsing the payload, we identify
the symbolic substrings with ﬁxed lengths and extract
them as patterns. When executing the example script
in SymExeLayer, we keep updating the payload length.
Later when parsing <sym rand alpha, 2917> in
the dumped payload, we produce a length-quantiﬁed
regex [a-zA-Z]{2917} as shown in Listing 2.
Fixed-offset pattern. Due to the format of some net-
work protocols, some payloads can be located only after
certain offsets of the packets. For instance, some FTP-
based attack packets have regular FTP commands, fol-
lowed with overlong paths as payloads to launch over-
ﬂow attacks. In such cases, since the network protocol
of the output API is logged, by applying the packet for-
mat of the protocol, we extract the offset of the payload,
which is a pattern for precise matching of the payload
location.

3.4.2 Pattern Reﬁning and Consolidating

As MetaSymploit automatically generates signatures in
a large scale, there are two requirements for the qual-
ity of the signatures. First, we should avoid generating
signatures only having patterns of common benign bytes
or patterns of trivial bytes/regexes, which may otherwise
cause false positive. Second, we should avoid generating
duplicated signatures with the same pattern set, which
may cause useless redundancy and confuse the IDS.
First requirement. When a payload is ﬁnally sent
through the output API, common benign bytes are in-
troduced by network protocols as concrete substrings
in the payload packet, including default protocol bytes
(e.g., “Content-Type:text/html”) and delimiter bytes
(e.g., “\r\n”). To identify them, for each protocol, we
keep a list of benign bytes. Based on the packet format,
we examine the concrete substrings to search for the oc-
currences of benign bytes. If found, we strip the benign
part and focus on the rest bytes for pattern extraction.

In addition, it is also important to avoid generating
signatures only using trivial patterns such as too short
byte string or too general regex patterns. Thus, we set a

USENIX Association  

22nd USENIX Security Symposium  71

threshold of minimum byte string length (e.g., >= 10)
and a list of critical regexes (e.g., NOP regex [\x90]*).
Given a set of extracted patterns, we generate signatures
only if we can ﬁnd at least one pattern whose length
is above the threshold or whose regex is critical. Note
that both the threshold and the critical regex list are
adjustable. Security analysts can also deﬁne different
thresholds and lists for different network protocols.
Second Requirement. Recall that SymExeLayer ex-
plores different execution paths in an attack script and
dumps payloads in each path. Sometimes, two paths
may differ only in a branch that is irrelevant to the pay-
load content, thus ﬁnally composing the same payloads.
Furthermore, two attack scripts may also share the same
patterns. To consolidate the same patterns from different
payloads into one signature, we keep a key-value hash
map where each key is a pattern set and each value is a
set of different payloads with the same pattern set. When
a new payload is parsed, if its pattern set already exists in
the hash map, we add this new payload, particularly its
behavior & constraint log into the corresponding value
set. The payloads and the logs in one set are analyzed
together to generate only one signature.

3.4.3 Pattern Context Deriving

Apart from pattern extraction, it is equally important to
provide the context of the patterns. The pattern context
shows the insight into the attack script, such as what at-
tack behavior and attack payload the patterns represent.
It also gives security analysts the guidance on how to use
the patterns, such as which target version and what OS
environment the patterns can be used to protect.

Therefore, we analyze the behavior & constraint log
to derive the pattern context. Since attack behaviors are
captured as behavioral APIs in the log, we derive the
context by translating the behavioral APIs into human-
readable phrases.
Some APIs have straightforward
names, which can be simply translated into the descrip-
tion phrase (or even directly used), such as probe ver
=> Version Probing. Others may not be intuitive.
Particularly, certain behavior cannot be shown from a
single API but a series of API calls. In such case, we
group these API calls together as one behavioral pattern.
When such pattern is found in the log, we translate it
into the matched behavior name, such as shellcode
+ get target ret => Stack Overflow.

Sometimes, sophisticated attack scripts may have un-
precedented behaviors whose APIs do not match any pat-
terns. In such cases, we keep the derivable context while
highlighting underived behavioral APIs in the log to help
security analysts discover new attack behaviors. In fact,
we use this technique in our prototype to collect patterns.
In regard to attack constraints, since the involved sym-

bolic values represent attack conditions of each execu-
tion path, we retrieve the external source names in the
symbolic labels and bind them with the conditions de-
rived from the constraints (e.g., Target Version: 5).

Finally, when both the extracted pattern set and the
derived context are ready, SigGen combines two together
and generates a signature, which can be used to detect the
payloads associated with this speciﬁc pattern set.

4

Implementation

We implement a prototype of MetaSymploit as a practi-
cal analysis tool targeting the Ruby-based attack frame-
work Metasploit. Given a Metasploit attack script,
our tool quickly analyzes it and automatically generates
Snort rules as signatures that can defend against this spe-
ciﬁc script. Particularly, we developed a lightweight
Ruby symbolic execution engine designed for attack
script analysis. Powered by the engine, we build SymEx-
eLayer on top of the launching platform of Metasploit. In
this section, we ﬁrst describe how the engine is designed
and then explain how to adapt the engine for Metasploit.

4.1 A Lightweight Symbolic Execution En-

gine for Ruby

Traditionally, developing a symbolic execution engine
requires heavy modiﬁcation of the interpreter, which
causes great engineering effort since Ruby has multiple
active versions and interpreters (e.g., 1.8/1.9/2.0). How-
ever, we discover a new way to design a lightweight en-
gine without modifying the interpreter. The engine is de-
veloped purely in Ruby (9.3K SLOC) as a loadable pack-
age compatible with multiple versions of Ruby. Thus it
supports analyzing attack scripts written in different ver-
sions. Speciﬁcally, our engine has two modules: (1) a
symbolic library that introduces rich symbolic support
into Ruby; (2) a symbolic execution tracer that performs
symbolic execution based on the actual script execution.

classes

to hold symbolic values

4.1.1 Library of Symbolic Support
The symbolic library realizes the functionality of
The library introduces
Symbolic API Extension.
symbolic
(e.g.,
SymbolicString, SymbolicInteger). To be
transparent to attack scripts, we develop the same APIs
in the symbolic classes as their concrete counterparts. On
the other hand, we also extend indirect-variant-related
APIs in the concrete classes to support handling sym-
bolic arguments, so that concrete and symbolic objects
can operate with each other.

Notably, SymbolicString class plays the key role
To hold the con-

in representing attack payloads.

72  22nd USENIX Security Symposium 

USENIX Association

tents, SymbolicString has an internal ordered array,
where each item is either a concrete substring, or a sym-
bolic substring with the <sym label, length>
embedded. When a SymbolicString API is called,
it ﬁrst checks whether the original concrete operation is
still applicable to the concrete substrings. If so, the API
uses the original logic in String to operate the concrete
substrings. Otherwise, the API treats the contents as
symbolic substrings, and processes the internal string ar-
ray as symbolic expressions. When a symbolic-extended
String API is called with symbolic arguments, it han-
dles concrete and symbolic substrings in the same way
as above and returns a SymbolicString object.

Later when SymExeLayer is integrated with Metas-
ploit, we further include the symbolic-extended APIs of
Metasploit into the symbolic library.

4.1.2 Symbolic Execution Tracer

The symbolic execution tracer transforms normal script
execution into symbolic execution.
It also realizes the
functionality of Behavior & Constraint logging. To this
end, we develop three techniques based on three ad-
vanced language features in Ruby (& Python3).
(1) Fine-grained execution tracing. This technique
traces the symbolic execution line-by-line in an attack
script. It keeps track of every method call. It also ex-
plores different paths when executing branches. We de-
velop it by enhancing a language feature called Debug
tracing function with Control Flow Graph (CFG).

Debug tracing function is a step-by-step execution
tracing facility used for debugging such as Ruby’s
set trace func (Python’s sys.settrace).
It
captures three major events, line, call, return. The line
event shows the number of the current executing line.
The call/return event shows the name of the method be-
ing called/returned. Every time an event happens, Debug
tracing function suspends the execution and calls a reg-
istered callback function for further event analysis.

We develop our callback function using the CFG of the
attack script. Since the CFG holds both the source code
and the control ﬂows, it offers rich semantics for ana-
lyzing the execution details when parsing every event.
When a line event happens, we locate the current line’s
source code in the CFG. Then we retrieve all call sites
in the current line, which will be matched with the fol-
lowing call/return events happening in this line. Partic-
ularly, this tracing mechanism can log behavioral API
calls when they are found in the call sites.

Our callback function also handles branches to explore
different paths. When the line event reaches a symbolic
branch, we evaluate the branch source code and consult

3The techniques can also build an engine to analyze Python-based

attack scripts, since Ruby and Python share many language features.

a constraint solver for both true and false branch con-
straints. If a solution exists, we concretize the symbolic
branch condition to guide the interpreter to the desired
branch (explained next). If both branches can be satis-
ﬁed, we fork the script execution process into two pro-
cesses to trace both branches. Otherwise, if no solution
is returned, we terminate the execution process. Partic-
ularly, if attack constraints are found, the callback func-
tion would perform constraint logging.
(2) Runtime symbolic variable manipulation. This
technique leverages the Runtime context binding lan-
guage feature to manipulate the runtime values of sym-
In particular, it inspects the values of
bolic variables.
attack payloads during composing.
It also concretizes
symbolic branch conditions to guide branch execution.

Runtime context binding can inspect and modify the
runtime states of the script, such as Ruby’s Binding
and Python’s inspect. It provides a context object that
binds the runtime scope of the current traced code. The
callback function can use this object to access all vari-
ables and methods in the scope of the traced code.

The ﬁrst use of context is to inspect the runtime value
of an attack payload when it is being composed. When a
variable is detected to be assigned by payload composing
APIs, the callback uses context to keep track of its value.
The callback then logs the inspected values together with
the payload composing APIs in the behavior log.

The second use of context is to guide symbolic branch
execution. Since the interpreter cannot move forward
with a symbolic condition, when the constraint solver re-
turns a solution, for each symbolic variable in the condi-
tion, we use context to temporarily replace the symbolic
value with the solved concrete value to guide the inter-
preter to the desired branch. Later when the line event
shows that the branch is taken, we recover them back to
their symbolic form. Recall the version==5 in Listing
1. Since version is symbolic value, we temporarily re-
place its value with 5 to explore one branch, and uses a
non-5 value for the other branch.
(3) Dynamic symbolic method wrapping.
In some
cases, the symbolic return values of method calls are not
associated with any variables, thus cannot be manipu-
lated using the second technique. To handle this, we
leverage the Dynamic method overriding language fea-
ture to dynamically wrap the traced method, associate its
return value with a temporary variable for manipulation.
Dynamic method overriding is a common feature in
Ruby and Python that methods can be runtimely over-
ridden and take effect immediately. Using this language
feature, we dynamically create a wrapper method and
override the original method right before the call event.
Meanwhile, we also preserve the original method, and
recover it right after the return event.

A more important use of the wrapping technique is to

USENIX Association  

22nd USENIX Security Symposium  73

concretize symbolic methods in branch conditions. If no
variable holds the symbolic return value of a method call
in a branch condition, to guide symbolic branch execu-
tion, we override the symbolic method with the wrapper
to return a solved concrete value. In practice some con-
straint solvers require the symbolic method calls to be
associated with variables to enable the solving.

Note that both the API extension and the knowledge
base are one-time system conﬁguration. Since Metas-
ploit components and their APIs are relatively stable for
compatibility with various attack scripts, once they are
collected and supported by MetaSymploit, newly dis-
tributed attack scripts that rely on these components can
be directly supported and automatically analyzed.

4.2 Adaptation for Metasploit
To analyze Metasploit attack scripts, we adapt the engine
and the six techniques in both SymExeLayer and SigGen
to work with the APIs provided by Metasploit and its
built-in components.

The current prototype is based on Metasploit version
4.4 (released in Aug 2012). We select the top 10 most
popular built-in components in Metasploit: Tcp, Udp,
Ftp, Http, Imap, Exe, Seh, Omelet, Egghunter,
Brute. The ﬁrst 5 are popular network protocol com-
ponents. The next 4 are used to attack Windows sys-
tems. Exe can generate exe ﬁle payloads. Seh can cre-
ate SEH-based attacks. Both Omelet and Egghunter
can compose staged payloads. The last Brute can cre-
ate bruteforce attacks. These components cover 548 real
attack scripts carried in Metasploit. By examining the
APIs provided by the launching platform and these com-
ponents of Metasploit, we perform three steps to adapt
the engine for SymExeLayer and SigGen.

First,

in the symbolic library, we apply symbolic
API extension to the environment-related APIs such as
tcp.get, ftp.login, http.read response,
and variant-payload-content-related APIs
such as
gen shellcode4.
rand text,
The library also replaces the output APIs such as
ftp.send cmd, http.send request with our
local-dumping APIs. When the script calls these APIs
during symbolic execution, SymExeLayer redirects the
calls to the symbolic-extended APIs.

make nops,

Second, to equip the symbolic execution tracer with
behavior & constraint
logging ability, we build a
knowledge base collecting behavioral APIs such as
http.fingerprint, gen egghunter and keep a
mapping between APIs and their behavior meaning for
pattern context deriving. We also keep a list of symbolic
labels for identifying attack constraints.

Third, based on the standards of the protocols and the
implementation of the built-in components, we add the
packet formats and common benign bytes of the ﬁve net-
work protocols into the knowledge base. For instance,
we develop speciﬁc parsers to parse payloads embedded
in HTTP headers and FTP commands.

4The listed API names are abbreviated due to space limits. Note that
Metasploit uses payload to represent shellcode. We use shellcode as
a more general term to avoid confusion with attack payloads.

5 Evaluation

We conduct our evaluation on an Intel Core i7 Quad
2.4GHz, 8GB memory, Ubuntu 12.10 machine. We run
MetaSymploit based on Metasploit 4.4, using the ofﬁ-
cial Ruby 1.9.3 interpreter. We evaluate our approach
from three perspectives: (1) the percentage of real-world
attack scripts that can be analyzed by MetaSymploit’s
symbolic execution; (2) the effectiveness of our auto-
matically generated signatures to defend against real-
world attacks; (3) the difference between our automat-
ically generated rules and ofﬁcial Snort rules.

5.1 Coverage Testing with Symbolic Exe-

cution Engine

We ﬁrst evaluate whether MetaSymploit can symboli-
cally execute various attack scripts. We use MetaSym-
ploit to analyze all 548 real attack scripts created with
the top 10 popular Metasploit components. As the result
shown in Table 1, 509 scripts (92.88%) are automatically
executed by MetaSymploit in the symbolic mode without
any manual modiﬁcation of the scripts. Different attack
conditions in the scripts are explored. The attack pay-
loads are captured and Snort rules are generated.

In terms of analysis cost, since MetaSymploit reuses
the launching platform of Metasploit on the ofﬁcial Ruby
interpreter, the symbolic execution has almost the same
speed as that Metasploit executes attack scripts nor-
mally (less than one minute on average). In fact, since
the environment-related APIs are symbolic-extended, the
time for real network communication is saved. Further-
more, signatures are generated in less than 10 seconds.

Among the remaining 39 scripts that MetaSymploit
cannot automatically deal with, we encounter ﬁve main
situations that deserve more discussion.
Loop with Symbolic Condition. We ﬁnd that 9 scripts
have conditional loops whose symbolic conditions can-
not be solved by constraint solvers, which may cause in-
ﬁnite looping. As a common problem in classical sym-
bolic execution, some previous approaches proposed us-
ing random concrete values to replace symbolic condi-
tions to execute loops [20]. However, in our case, do-
ing so may affect the precision of the payload contents.
Other approaches such as LESE [35] speciﬁcally handle
loops, which we plan to explore in future work.

74  22nd USENIX Security Symposium 

USENIX Association

Category
Automatically Executed
Symbolic Loop
Non-Symbolic-Extended API Call
Obfuscation & Encryption
Multi-threading
Bug in Scripts
Total Coverage

Num Percentage
509
92.88%
9
1.64%
12
2.19%
13
2.37%
3
0.55%
2
0.37%
Auto 92.88%

Require Manual Modiﬁcation

No

Avg 10 LOC/per script
Avg 3 LOC/per script

Not Supported
Not Supported

2 LOC in each script

All 96.90%

Table 1: The distribution of different situations in the symbolic execution of the 548 Metasploit attack scripts.

Currently, after manual analysis, we ﬁnd that there are
two cases of using the loops: byte-by-byte modifying a
symbolic string whose length is a symbolic integer, and
performing repeated attack steps in a bruteforce attack.
In the ﬁrst case, since the string length is not concrete,
the looping rounds cannot be decided. However, we ﬁnd
no matter how many rounds are, the looping result is still
a symbolic string. Therefore, we replace the loop code
that operates the symbolic string with a new symbolic
string to represent the looping result (10 LOC per script
on average), while propagating the symbolic label and
logging the loop information for further investigation.

In the second case, the Brute component provides
an API that checks whether the target is compromised or
not. It is typically used as a while loop condition. The
loop keeps attacking the target until the API returns that
the target is compromised. Since in our case the API
returns a symbolic value as the target status, to avoid in-
ﬁnite looping, we set a counter with an upper bound in
the extended version of this API, to control the looping
rounds. If there are payloads and logs captured inside the
loop, the differences between each round are analyzed to
identify the constant patterns.
Non-Symbolic-Extended API Call. Due to the time
limitations, other than the top 10 components, we have
not symbolically extended other APIs in Metasploit. We
detect 12 scripts that call the non-extended APIs related
to assembly translating and encoding the payloads. Since
very few APIs are involved, we decide to modify each of
them individually at this time, and extend the entire com-
ponents in future work. To handle these API calls, since
SymbolicString supports payload content process-
ing, when applicable to the concrete substrings, we allow
the APIs to operate on the concrete parts, while prevent-
ing them from using the symbolic substrings, which may
otherwise cause runtime errors. When the API operates
on a pure symbolic string with no concrete substrings, we
replace the API calls by creating new symbolic strings to
represent the results of the API calls (3 LOC per script
on average).
Obfuscation & Encryption. There are 13 cases with
complicated obfuscation and encryption on the payload,
where payload content processing is not feasible. Since
the output of these operations is completely random,

there is no constant pattern that can be extracted from
the obfuscated or encrypted payload. Defending against
obfuscation and encryption is an open question, which is
beyond the scope of signature-based defense.
Multi-threading. Handling multi-threading is an ad-
vanced topic in symbolic execution. Existing research
[37] explored the possibility by extending symbolic ex-
ecution to handle multi-threaded programs. Currently,
due to only 3 cases related to this situation, we plan to
address this issue in future work.
Bug in Scripts.
Interestingly, during the testing, we
also discover 2 scripts with bugs that hang the execu-
tion when the script is generating a speciﬁc assembly
code that jumps to the shellcode. From this result, we
see that our approach is also useful for the purpose of
ﬁnding bugs in attack scripts.

In summary, the percentage of scripts that are auto-
matically handled is 92.88%. If the manually modiﬁed
scripts are included, the percentage reaches 96.90%.

5.2 Effectiveness Validation using Real-

world Attacks

To evaluate whether the automatically generated Snort
rules can effectively detect real attacks, we use Metas-
ploit attack scripts to attack 45 real-world vulnera-
ble applications. These applications are acquired from
exploit-db.com, a popular hacking website collect-
ing attack scripts and free vulnerable applications. In all,
there are 45 free vulnerable applications available in the
website, with 45 corresponding Metasploit scripts. They
include Java 7, Adobe Flash Player 10, Apache servers
2.0, Firefox 3.6, RealPlayer 11, multiple FTP servers
such as Dream FTP, ProFTPD, VLC player 1.1, IRC
servers and some less popular web-based programs.

We ﬁrst use MetaSymploit to analyze the 45 attack
scripts and automatically generate Snort rules. Then we
set up two virtual machines, with one running Metasploit
to simulate the attacker and the other running the vulner-
able application as the vulnerable target. For each script,
we choose two different shellcodes to launch two real
attacks. To expose the entire attack ﬂow, we allow the
attack to compromise the target, and use Snort IDS 2.9.2
with our generated rules to detect attack payloads. Note

USENIX Association  

22nd USENIX Security Symposium  75

76  22nd USENIX Security Symposium 

USENIX Association

thatduetothelimitedavailableversionsoftheapplica-tions,wefocusontherulesoftheattackpayloadsthattargettheapplicationversionsthatweareabletoobtain.TheinitialresultsshowthatexcepttheHTTP-basedones,allattackpayloadpacketswithbothtwotypesofshellcodesarecorrectlydetected.Recallthatourrulesarebasedontheconstantpatternsofthepayload,vari-antpartssuchasshellcodesdonotaffectthedetection.ButforApacheserverattacksandFirefoxattacks,ourrulesfailtocatchtheattackpacketsbecausetheorderofeachHTTPheaderﬁeldisdifferentfromtheoneinourrules.SincetheorderoftheHTTPheaderﬁeldsisnotenforcedbyRFCdeﬁnition,theextractedpatternsfromtheHTTPheadercannotbesimplyputintothesignatureinsequence.Therefore,wefurtherimproveourHTTPparsertohandleeachheaderﬁeldseparately,toenableorder-insensitivepatternmatching.Inthesecondroundoftesting,theHTTP-basedattacksarealsocorrectlyde-tected.AnotherinterestingcaseistheJava7attack.InlateAug2012,twodaysafterazero-dayvulnerabilityinJava7wasdisclosed(CVE2012-4681),aMetasploitattackscriptwasdistributedtargetingthisvulnerability[32].Atthattime,weimmediatelyusedMetaSymploittoana-lyzethisattackscriptandautomaticallygenerateaSnortrulebasedonthemaliciousjarpayloadcomposedbythisscript,andtesteditinourenvironment.Ourrulesuccess-fullydetectedthejarpayload.Admittedly,theremightbeotherwaysdifferentfromthedistributedMetasploitscripttoexploitthevulnerability.Nevertheless,ourruleprovidestheﬁrstaidtothevulnerabilitywithoutavail-ablesecuritypatch,todefendagainstattackerswhodi-rectlyusethiswidely-distributedscripttolaunchattacks.Apartfromtheeffectivenessevaluation,wealsouseourrulesgeneratedfromthe45attackscriptstomonitornormalnetworktrafﬁc,toinvestigatewhetherourruleswouldraisefalsepositivesonbenignpackets.WeruntheSnortwithourrulesinpromiscuousmodetomonitorthetrafﬁcoftwoWindowsmachines(Vista&7)andaUbuntu12.04machine.Thesemachinesareeveryday-usemachinesintheCSdepartment(nopersonaldataisrecorded).Themonitoringisonlinefortwomonths.Nofalsepositiveisraisedonbenignpackets.Suchresultisexpectedsinceourrulescontainmultiplespeciﬁcpat-ternsthatmatchesonlytheMetasploitattackpayloads.AppendixAshowsaruleexampleforoneofthe45scripts.5.3ComparisonwithOfﬁcialSnortRulesTofurtherassessthequalityofthegeneratedrules,wecomparetheMetaSymploitrules(MRs)ofthe45at-tackscriptswiththerecentOfﬁcialSnortrules(ORs),6 4 35 5 3 6 4 11 26 3 0510152025303540Same content(byte pattern)Same pcre(regex pattern)OR pcrematching MRcontentNo sharedpatternInconsistentdetectionresultsMetaSymploit Rules (MRs)Official Rules (ORs)Figure2:Patterncomparisonbetween53MetaSymploitgeneratedrulesand50ofﬁcialSnortrulesfor22Metasploitattackscripts.releasedinNov20125.WeuseCVEnumbercarriedinbothattackscriptsandORstomatcheachother.Theresultissurprisingthatonly22attackscriptshavecor-respondingORs.Therest23arenotevencoveredbyORs.Thisrevealsaseriousissuethatexistingdefenseisstillquiteinsufﬁcientcomparedtothefastspreadingofpublicattackresources.Forthe22ofﬁciallycoveredscripts,thereare53MRsand50ORs.InMetaSymploit,onescriptmayhavemul-tiplerulesdetectingdifferentpayloadsfordifferenttar-getversions.Whereasintheofﬁcialruleset,onevulner-abilitymayalsohavemultiplerulesdetectingdifferentwaysthatexploitit.Bycomparingthepatternsinbothrulesets,wesummarizetheresultinFigure2.Weﬁndthat44MRssharepatternswith21ORs.Speciﬁcally,6MRsand6ORssharethesamecontentbytepat-terns.4MRsand4ORssharethesamepcreregexpat-terns.Notably,35MRshavespeciﬁccontentthatarematchedwith11ORs’generalpcre.Thisisbecausethepcreregexesaregeneralizedbysecurityanalystsbasedonlargevolumesofsamples,whilethecontentbytes(usuallyincludingvulnerablereturnaddresses)aregen-eratedbasedoneveryattackpayloadofthescripts.AnexampleisshowninAppendixA.Althoughinthiscase,theMRsetisasubsetoftheORone,wearguethatasourgoalistodefendagainstspeciﬁcattackscripts,MRsgivemoreinsightoftheattackpayloadswithmorepre-cisematching.Meanwhile,thereare5MRsand26ORswithnopatternshared.Thisisbecausesomevulnera-bilitiescanbeexploitedindifferentways,andtheORshavemorepatternsdeﬁnedbyanalysts,whileMetasploitscriptsusuallychooseonewaytoexploitonevulnerabil-ity.Nevertheless,westillﬁndthat2scriptshave5MRswhosepatternsarenotseeninORs,whichcomplementtheORset.Besides,wealsoloadthe50ORsintoSnorttotestwhethertheycandetectattackslaunchedbythe22at-tackscripts.Interestingly,theresultshowsthatonly17scripts’attackpayloadsaredetected,whilenoalert5snortrules-snapshot-2922.tar.gzonwww.snort.org/snort-rules/is raised for the other 5 scripts. 2 scripts6 are missed
due to the lack of OR patterns as we mentioned above.
The other 3 scripts, which have 3 MRs, are supposed to
be detected by 3 corresponding ORs. After comparing
these rules, we ﬁnd the 3 ORs have some deﬁciencies
that cause this inconsistent detection results. We list the
detailed information of the 3 scripts and the deﬁciencies
of the 3 ORs in Table 2. Note that some deﬁciencies
are actually caused by inaccurate use of Snort rule ﬂags
such as the http uri, flow. We ﬁnd them by compar-
ing these ﬂags with the pattern context (e.g., Behaviors)
in our rules. We have reported these discoveries to the
ofﬁcial Snort team.

In sum, these results show that even the ofﬁcial Snort
rules written by security analysts are incomplete and tend
to be error-prone. MetaSymploit serves as a useful tool
to complement and augment the existing IDS signatures
by improving the completeness and the accuracy.

6 Discussion

Scenarios of using MetaSymploit signatures. As
shown in the comparison (35 MRs vs 11 ORs), due to
different pattern extracting mechanisms, ORs have less
rules with more general patterns, while MRs have more
rules with more speciﬁc patterns. It is possible that as
the number of attack scripts is increasing, more and more
signatures will be generated. If all signatures are loaded
into the IDS, this may slow down the matching speed.

However, we argue that unlike ORs are used for gen-
eral detection, MetaSymploit signatures should be used
in two typical scenarios, which do not require loading
all MRs in an IDS. First, as the goal of MetaSymploit
is to provide quick defense against newly distributed at-
tack scripts, the typical way of using our signatures is to
give ﬁrst aid to the vulnerable application without avail-
able patches to prevent attackers especially script kid-
dies using the new scripts to launch attacks (e.g., the
Java 7 case). When the vulnerability is patched or the
application is upgraded, our signatures can be removed
from the IDS. Second, as the pattern contexts are embed-
ded with the signatures, security analysts only need to
deploy the signatures whose contexts are related to the
protected environment or the protected target version, to
avoid loading irrelevant signatures which may slow down
the matching speed of the IDS.
Limitations. MetaSymploit inherits the limitations of
classical symbolic execution. As we mentioned in Sec-
tion 5.1, our current prototype requires manual analysis
on handling complex symbolic loops. Recent approaches
propose to use bounded iteration [21], search-guiding
heuristics [40] and loop summary [22, 35] to address the

6adobe flash sps.rb, mozilla mchannel.rb

loop issue. In MetaSymploit, different loop cases of at-
tack scripts may require different techniques. For exam-
ple, bounded iteration can be applied to handle loops of
bruteforce attacks. Loop summaries can summarize the
post-loop effect on symbolic payload contents. Search-
guiding heuristics can help target payload-related loops
to avoid getting stuck in irrelevant loops.

Apart from loops, path explosion is a more general
issue related to performance and scalability. Too many
paths in an attack script may prolong the analysis and
delay the defense. In addition, it is possible that differ-
ent paths in a script ﬁnally lead to the same attack pay-
load output. Exploring these paths incurs extra efforts of
pruning redundant payloads. Several techniques such as
equivalent state tracking [9], state merging [26] and path
partitioning [31] have been proposed to mitigate the path
explosion issue. We plan to incorporate these techniques
into MetaSymploit to avoid exploring paths that would
compose redundant payload contents.

The limitations of constraint solvers may also affect
the effectiveness of path exploration. Currently, we use
Gecode/R [1] for solving integer/boolean constraints and
HAMPI [23] for solving string constraints. In case when
encountering complicated constraints (e.g., a non-linear
constraint), the solvers cannot decide which branch to
take. For the sake of completeness, we conservatively ex-
plore both branches, while marking the path constraints
as uncertain in the log, which require more investigation
by security analysts. Due to this fact, we regard our pro-
totype as an assistant tool to reduce the workload of ana-
lysts, so that they only need to focus on complicated ones
when facing large numbers of new attack scripts.

We envision possible attacks directly against Meta-
Symploit’s defense mechanism. As MetaSymploit rules
stick to the patterns in the distributed attack scripts, it
is possible that experienced attackers may modify the
distributed one to create new script variants without re-
leasing them, which may evade the detection of Meta-
Symploit rules. Besides, experienced attackers may
also try to exploit the limitation of symbolic execution
when developing new scripts, such as introducing com-
plex loops, non-linear constraints or even obfuscating the
script code. However, both cases are non-trivial. They
require advanced attack developing techniques, which
are usually time-consuming and slow down the speed of
developing and launching new attacks. In other words,
with MetaSymploit, we raise the bar of the skill level and
the time cost for developing and launching new attacks.

7 Related Work

Signature Generation. There has been a lot of work
on automatic signature generation for malware defense.
From the perspective of attacks, Autograph [24], Poly-

USENIX Association  

22nd USENIX Security Symposium  77

Metasploit Script Name
badblue ext overﬂow.rb

CVE

2005-0595

sascam get.rb

2008-6898

mozilla reduceright.rb

2011-2371

Failure Reason of Ofﬁcial Snort Rules Missing Metasploit Payloads
The http uri ﬂag restricts the pattern searching in one header ﬁeld,
thus missing the Metasploit payload located in the following ﬁelds.
The flow pattern is set to check packets sent to the client while our
pattern context shows the Metasploit payload is sent to the server.
The content byte pattern is wrong since it includes two variant bytes,
which are randomly generated in the Metasploit payload.

Ofﬁcial Rule SID

3816

16715

19713

Table 2: The list of three Metasploit attack scripts which evade the detection from 3 Ofﬁcial Snort Rules

graph [29] and Hamsa [27] automatically generate worm
signatures by extracting invariant contents from the net-
work trafﬁc of worms. Particularly, these approaches are
based on the observation that even polymorphic worms
have invariant contents that can be used as signature pat-
terns. In MetaSymploit, we have the same observation
when analyzing constant and variant payload contents
composed by attack scripts. On the other hand, these ap-
proaches require collecting large amounts of malicious
network trafﬁc to identify invariant contents. However,
this process is usually time-consuming and cannot pro-
vide quick defense against new attacks.
In contrast,
MetaSymploit does not need to collect any network traf-
ﬁc but only attack scripts, thus largely reducing the time
of performing analysis and providing defense.

From the perspective of vulnerabilities, Vigilante [18],
ShieldGen [19] and Bouncer [17] analyze vulnerable ap-
plications and their execution traces to generate signa-
tures to block exploit inputs that can trigger the vul-
nerability. Brumley et al. [10, 11] also provide the
formal deﬁnition of vulnerability-based signatures and
propose constraint-solving-based techniques to gener-
ate such signatures. Elcano [13] and MACE [16] fur-
ther use protocol-level concolic exploration to generate
vulnerability-based signatures. Notably, program anal-
ysis techniques such as symbolic execution play an im-
portant role in these approaches as well as in MetaSym-
ploit. But unlike these approaches, MetaSymploit only
analyzes attack scripts without requiring the presence of
vulnerable applications, thus avoiding the cost of obtain-
ing various vulnerable applications or preparing various
testing environments.
Symbolic Execution. Symbolic execution has been ac-
tively applied for security purposes [36]. BitBlaze [38]
is a binary analysis platform based on symbolic execu-
tion. SAGE [21] uses dynamic symbolic execution to de-
tect vulnerabilities in x86 binaries. EXE [14] and AEG
[8] generate malicious inputs and exploits by symboli-
cally executing vulnerable applications. Moser et al. [28]
explore multiple execution paths for malware analysis.
Since our analysis target, attack script is quite differ-
ent from host-based binary level malware, the techniques
proposed in these approaches such as memory inspec-
tion, system call analysis are not adaptable in our case.

Symbolic execution for scripting languages is still

at early stage, due to the diversity of different kinds
of scripting languages and various purposes of applica-
tions. Most work focuses on the web-based scripting
languages, such as JavaScript [34], PHP [7, 41], and
Ruby on Rails [15] web frameworks. Since these ap-
proaches are speciﬁcally designed for testing web appli-
cations (e.g., ﬁnding XSS and SQL Injection vulnerabil-
ity), they are not applicable for analyzing general attack
scripts and attack frameworks that target various vulner-
able applications on different OS environments.

In particular, little work has been done for the sym-
bolic execution of general-purpose scripting languages,
such as Ruby and Python. PyStick [30] is an automated
testing tool with input generation and invariant detec-
tion for Python. It is different from our purpose of us-
ing symbolic execution for security analysis. Bruni et al.
[12] propose a library-based approach to develop sym-
bolic execution. However, it uses only the dynamic dis-
patching feature, which limits symbolic execution only
in primitive types. This limited functionality is insufﬁ-
cient for practical use.

8 Conclusion

Script-based attack frameworks have become an increas-
ing threat to computer security. In this paper, we have
presented MetaSymploit, the ﬁrst system of automatic at-
tack script analysis and IDS signature generation. Meta-
Symploit leverages security-enhanced symbolic execu-
tion to analyze attack scripts. We have implemented a
prototype targeting the popular attack framework Metas-
ploit. The results have shown the effectiveness of Meta-
Symploit in real-world attacks, and also the practical use
in improving current IDS signatures.

9 Acknowledgements

We would like to thank the conference reviewers and
shepherds for their feedback in ﬁnalizing this paper.
This work is supported by the U.S. Army Research Of-
ﬁce (ARO) under a MURI grant W911NF-09-1-0525,
and also supported in part by an NSA Science of Se-
curity Lablet grant at North Carolina State Univer-

78  22nd USENIX Security Symposium 

USENIX Association

sity, NSF grants CCF-0845272, CCF-0915400, CNS-
0958235, CNS-1160603.

References
[1] Constraint programming in ruby. http://gecoder.rubyforge.org/.
[2] The exploit database. http://www.exploit-db.com.
[3] Metasploit. http://www.metasploit.com.
[4] Arkeia
77

overﬂow (win32).

backup

client

type

http://www.metasploit.com/modules/exploit/windows/arkeia/type77,
visited in Jan 2013.

[5] Conﬁcker worm using metasploit

payload

to

spread.

http://blogs.mcafee.com/mcafee-labs/conﬁcker-worm-using-
metasploit-payload-to-spread, visited in Jan 2013.

[6] Top vulnerability exploit tools. http://sectools.org/tag/sploits, vis-

ited in Jan 2013.

[7] ARTZI, S., KIE, A., DOLBY, J., ERNST, M. D., KIEZUN, A.,
TIP, F., DIG, D., AND PARADKAR, A. Finding Bugs In Dy-
namic Web Applications.
In Proceedings of the 2008 Interna-
tional Symposium on Software Testing and Analysis (ISSTA’08),
pp. 261–272.

[8] AVGERINOS, T., CHA, S. K., LIM, B., HAO, T., AND BRUM-
LEY, D. AEG: Automatic Exploit Generation.
In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’11).

[9] BOONSTOPPEL, P., CADAR, C., AND ENGLER, D. RWset:
Attacking Path Explosion in Constraint-Based Test Generation.
In Proceedings of the 14th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems
(TACAS’08), pp. 351–366.

[10] BRUMLEY, D., NEWSOME, J., AND SONG, D. Towards Au-
tomatic Generation of Vulnerability-Based Signatures.
In Pro-
ceedings of the 2006 IEEE Symposium on Security and Privacy
(S&P’06), pp. 2–16.

[11] BRUMLEY, D., WANG, H., JHA, S., AND SONG, D. Creating
Vulnerability Signatures Using Weakest Preconditions. In Pro-
ceedings of the 20th IEEE Computer Security Foundations Sym-
posium (CSF’07), pp. 311–325.

[12] BRUNI, ALESSANDRO DISNEY, T. A Peer Architecture for
Lightweight Symbolic Execution. Tech. rep., UC Santa Cruz,
2011.

[13] CABALLERO, J., LIANG, Z., POOSANKAM, P., AND SONG,
D. Towards Generating High Coverage Vulnerability-Based Sig-
natures with Protocol-Level Constraint-Guided Exploration.
In
Proceedings of the 12th International Symposium on Recent Ad-
vances in Intrusion Detection (RAID’09), pp. 161–181.

[14] CADAR, C., GANESH, V., AND PAWLOWSKI, P. EXE: Auto-
matically Generating Inputs of Deathh.
In Proceedings of the
13th ACM Conference on Computer and Communications Secu-
rity (CCS’06), pp. 322 – 335.

[15] CHAUDHURI, A., AND FOSTER, J. S. Symbolic Security Anal-
ysis of Ruby-on-Rails Web Applications. In Proceedings of the
17th ACM Conference on Computer and Communications Secu-
rity (CCS’10), pp. 585–594.

[16] CHO, C., BABIC, D., AND POOSANKAM, P. MACE: Model-
inference-Assisted Concolic Exploration for Protocol and Vulner-
ability Discovery. In Proceedings of the 20th USENIX Security
Symposium (2011).

[18] COSTA, M., CROWCROFT, J., AND CASTRO, M. Vigilante:
End-to-End Containment of Internet Worms.
In Proceedings
of the 20th ACM Symposium on Operating Systems Principles
(SOSP’05), pp. 133–147.

[19] CUI, W., PEINADO, M., WANG, H. J., AND LOCASTO, M. E.
ShieldGen: Automatic Data Patch Generation for Unknown Vul-
nerabilities with Informed Probing. Proceedings of the 2007
IEEE Symposium on Security and Privacy (S&P’07), 252–266.

[20] GODEFROID, P., AND KLARLUND, N. DART: Directed Auto-
mated Random Testing. In Proceedings of the 2005 ACM SIG-
PLAN Conference on Programming Language Design and Imple-
mentation (PLDI’05), pp. 213–223.

[21] GODEFROID, P., LEVIN, M. Y., AND BERKELEY, U. C. Au-
tomated Whitebox Fuzz Testing. In Proceedings of Network and
Distributed Systems Security (NDSS’08).

[22] GODEFROID, P., AND LUCHAUP, D. Automatic Partial Loop
Summarization in Dynamic Test Generation. In Proceedings of
the 2011 International Symposium on Software Testing and Anal-
ysis (ISSTA’11), pp. 23–33.

[23] KIEZUN, A., GANESH, V., GUO, P. J., HOOIMEIJER, P., AND
ERNST, M. D. HAMPI: A Solver for String Constraints. In Pro-
ceedings of the 18th International Symposium on Software Test-
ing and Analysis (ISSTA’09), pp. 105–116.

[24] KIM, H., AND KARP, B. Autograph: Toward Automated, Dis-
tributed Worm Signature Detection. In Proceedings of the 13th
USENIX Security Symposium (2004), pp. 271–286.

[25] KING, J. C. Symbolic execution and program testing. Commun.

ACM 19, 7 (1976), 385–394.

[26] KUZNETSOV, V., KINDER, J., BUCUR, S., AND CANDEA, G.
Efﬁcient State Merging in Symbolic Execution. In Proceedings of
the 33rd ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI’12), pp. 193–204.

[27] LI, Z., SANGHI, M., CHAVEZ, B., CHEN, Y., AND KAO,
M. Hamsa: Fast Signature Generation for Zero-day Polymor-
phicWorms with Provable Attack Resilience. In Proceedings of
the 2006 IEEE Symposium on Security and Privacy (S&P’06),
pp. 32–47.

[28] MOSER, A., KRUEGEL, C., AND KIRDA, E. Exploring Multiple
Execution Paths for Malware Analysis.
In Proceedings of the
2007 IEEE Symposium on Security and Privacy (S&P’07), vol. 0,
pp. 231–245.

[29] NEWSOME, J., KARP, B., AND SONG, D. Polygraph: Automat-
ically Generating Signatures for Polymorphic Worms.
In Pro-
ceedings of the 2005 IEEE Symposium on Security and Privacy
(S&P’05), pp. 226–241.

[30] NOTO-MONIZ, A. Software Agitation of a Dynamically Typed

Language. Tech. rep., Worcester Polytechnic Institute, 2012.

[31] QI, D., NGUYEN, H. D., AND ROYCHOUDHURY, A. Path Ex-
ploration based on Symbolic Output. In Proceedings of the 19th
ACM SIGSOFT Symposium on Foundations of Software Engi-
neering (FSE’11), pp. 278–288.

[32] RAGAN, S.

Java zero-day added to blackhole exploit kit and
metasploit. http://www.securityweek.com/java-zero-day-added-
blackhole-exploit-kit-and-metasploit, visited in Aug 2012.

[33] RAMIREZ-SILVA, E., AND DACIER, M. Empirical Study of the
Impact of Metasploit-Related Attacks in 4 Years of Attack Traces.
In Proceedings of the 12th Asian Computing Science Conference
on Advances in Computer Science: Computer and Network Secu-
rity (ASIAN’07), pp. 198–211.

[17] COSTA, M., CASTRO, M., AND ZHOU, L. Bouncer: Secur-
ing Software by Blocking Bad Input. In Proceedings of twenty-
ﬁrst ACM SIGOPS Symposium on Operating Systems Principles
(SOSP’07), pp. 117–130.

[34] SAXENA, P., AKHAWE, D., HANNA, S., MAO, F., MCCA-
MANT, S., AND SONG, D. A Symbolic Execution Framework
for JavaScript. In Proceedings of the 2010 IEEE Symposium on
Security and Privacy (S&P’10), pp. 513–528.

USENIX Association  

22nd USENIX Security Symposium  79

[35] SAXENA, P., POOSANKAM, P., MCCAMANT, S., AND SONG,
D. Loop-Extended Symbolic Execution on Binary Programs. In
Proceedings of the 18th International Symposium on Software
Testing and Analysis (ISSTA’09), pp. 225–236.

[36] SCHWARTZ, E. J., AVGERINOS, T., AND BRUMLEY, D. All
You Ever Wanted to Know about Dynamic Taint Analysis and
Forward Symbolic Execution (but Might Have Been Afraid to
Ask). In Proceedings of the 2010 IEEE Symposium on Security
and Privacy (S&P’10), pp. 317–331.

[37] SEN, K., AND AGHA, G. CUTE and jCUTE: Concolic Unit
Testing and Explicit Path Model-Checking Tools. In Proceedings
of the 18th International Conference on Computer Aided Veriﬁ-
cation (CAV’06), pp. 419–423.

[38] SONG, D., BRUMLEY, D., YIN, H., AND CABALLERO. Bit-
Blaze: A New Approach to Computer Security via Binary Anal-
ysis. In Proceedings of the 4th International Conference on In-
formation Systems Security (ICISS’08), pp. 1–25.

[39] SOPHOSLABS.

Exploring the blackhole

exploit kit.

http://nakedsecurity.sophos.com/exploring-the-blackhole-
exploit-kit, visited in Jan 2013.

[40] XIE, T., TILLMANN, N., DE HALLEUX, J., AND SCHULTE, W.
Fitness-Guided Path Exploration in Dynamic Symbolic Execu-
tion. In IEEE/IFIP International Conference on Dependable Sys-
tems & Networks (DSN’09), pp. 359–368.

[41] XIE, Y., AND AIKEN, A. Static Detection of Security Vul-
nerabilities in Scripting Languages. In Proceedings of the 15th
USENIX Security Symposium (2006), pp. 179–192.

Appendix A Example of Rule Comparison

1 def exploit
2

...
trigger = ’/ldap://localhost/%3fA%3fA%3

fCCCCCCCCCC%3fC%3f%90’

# Sending payload
send_request_raw({

’uri’ => ’/’ + rewrite_path() + trigger +

shellcode(),

’version’ => ’1.0’,
}, 2)

3

4

5

6

7

8

9

...

10
11 end

Listing 4: The code snippet from a Metasploit attack script
apache mod rewrite ldap.rb

alert tcp any any -> any 80 (

msg:"Metasploit apache_mod_rewrite_ldap,
Target:[Apache 1.3/2.0/2.2],
Behavior:[HTTP request with Vul-specific

bytes]";

content:"GET";
content:"/ldap|3A|//localhost/%3fA%3fA%3

fCCCCCCCCCC%3fC%3f%90";

content:"|20|HTTP/1.0|0D 0A|Host|3A 20|";
reference:cve,2006-3747;
sid:5000539; rev:0;)

Listing 5: One MetaSymploit Rule (MR) for an attack payload of
apache mod rewrite ldap.rb.

alert tcp $EXTERNAL_NET any -> $HOME_NET 80 (

msg:"WEB-MISC Apache mod_rewrite buffer

overflow attempt";

content:"GET";
content:"ldap|3A|";
pcre:"/ldap\x3A\x2F\x2F[ˆ\x0A]*(%3f|\x3F)[ˆ\
x0A]*(%3f|\x3F)[ˆ\x0A]*(%3f|\x3F)[ˆ\x0A
]*(%3f|\x3F)/smi";

reference:cve,2006-3747;
sid:11679; rev:5;)

Listing 6: One Ofﬁcial Snort Rule (OR) related to the Metasploit
attack script in Listing 4.

In Appendix A, we give a simple example to illustrate
the comparison between an ofﬁcial Snort rule contain-
ing general patterns with a MetaSymploit rule containing
speciﬁc patterns.

4

of

the

code

shows

Listing

snippet

the
exploit method in the Metasploit attack script
apache mod rewrite ldap.rb.
script
launches the attack by sending an HTTP GET request
packet that contains a special URI byte string to trigger
the vulnerability. Here send request raw is a
Metasploit HTTP output API method that is symbol-
ically extended by MetaSymploit to dump the entire
payload packet.

The

Listing 5 is a MetaSymploit Rule (MR) based on the
attack payload composed by the script. It contains the
constant byte string patterns, especially the vulnerabil-
ity triggering string that can identify the speciﬁc payload
packet. Listing 6 is the corresponding Ofﬁcial Rule (OR)
based on CVE matching. It contains a regular expression
(regex) pattern generalized by security analysts based on
large amounts of samples.

According to the Snort rule manual, a rule can have
multiple content byte string patterns. By default,
given a packet, Snort searches these content patterns
in order. A rule can also have one pcre regex pattern.
Snort searches the entire packet for the pcre pattern.

In the example rules, the ﬁrst content in both rules
share the same pattern “GET”. The second content
of the MR captures the triggering string, which includes
the second content of the OR “ldap|3A|” as a sub-
string. Furthermore, the second content of the MR is
also matched by the general pcre regex of the OR. In
addition, there is another content in the MR that cap-
tures the HTTP protocol version of the packet.

Although both rules can detect the attack payload of
this script, the MR has multiple speciﬁc patterns that
can precisely pinpoint the attacks launched by this script,
thus having very low false-positive rate compared to the
general OR. In practice, the MRs can help identify what
attack scripts are used by attackers, providing a way for
the defense side to proﬁle and obtain more knowledge of
the attacker side.

80  22nd USENIX Security Symposium 

USENIX Association

