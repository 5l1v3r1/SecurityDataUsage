The UNIX Process Identity Crisis: A Standards-Driven

Approach to Setuid

Mark S. Dittmer

Mahesh V. Tripunitara

ECE, University of Waterloo, Canada
{mdittmer,tripunit}@uwaterloo.ca

ABSTRACT
We revisit the setuid family of calls for privilege manage-
ment that is implemented in several widely-used operating
systems. Three of the four commonly used calls in the fam-
ily are standardized by POSIX. We investigate the current
status of setuid, and in the process, challenge some asser-
tions in prior work. We address three sets of questions with
regards to the setuid family.
(1) Is the POSIX standard
indeed broken as prior work suggests? (2) Are implemen-
tations POSIX-compliant as claimed? (3) Are the wrapper
functions that prior work proposes to circumvent issues with
setuid calls correct and usable? Towards (1), we express
the standards in a precise syntax that allows us to assess
whether they are unambiguous, logically consistent descrip-
tions of well-formed functions. We have discovered that two
of the three functions that are standardized ﬁt these cri-
teria, thereby challenging assertions in prior work regarding
the quality of the standard. In cases wherein the standard is
broken, we give a clear characterization, and suggest that the
standard can be ﬁxed easily, but at the cost of backwards-
compatibility. Towards (2), we perform a state-space enu-
meration as in prior work, report on our discoveries, and
discuss the implications of non-conformance and diﬀerences
in implementation. Towards (3), we discuss some issues that
we have discovered with prior wrappers. We then propose
a new suite of wrapper functions which are designed with a
diﬀerent mindset from prior work, and provide both stronger
guarantees with respect to atomicity and a clearer seman-
tics for permanent and temporary changes in process iden-
tity. With a fresh approach, our work is a contribution to a
well-established approach to privilege management.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection; K.6.5
[Management of Computing and Information Sys-
tems]: Security and Protection

 
Permission to make digital or hard copies of all or part of this work for personal 
or  classroom  use  is  granted  without  fee  provided  that  copies  are  not  made  or 
distributed  for  profit  or  commercial  advantage  and  that  copies  bear this  notice 
and the full citation on the first page. Copyrights for components of this work 
owned by others than the author(s) must be honored. Abstracting with credit is 
permitted. To copy otherwise, or republish, to post on servers or to redistribute to 
lists, requires prior specific permission and/or a fee. Request permissions from 
permissions@acm.org. 
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA. 
Copyright is held by the owner/author(s). Publication rights licensed to ACM. 
ACM 978-1-4503-2957-6/14/11…$15.00. 
http://dx.doi.org/10.1145/2660267.2660333.

Table 1: The four functions that comprise the setuid
family, a brief description of each, and whether each
is available on the operating systems we consider.
The functions setuid(), seteuid() and setreuid() are
standardized by POSIX, whereas setresuid() is not.

Name

Purpose

Sets the eﬀective user ID of
the calling process. Leaves
the real and saved IDs un-
changed, unless the caller
is privileged.
Sets the eﬀective user ID
of the calling process.
If
the caller is unprivileged, it
may set the eﬀective to the
real or saved user IDs.
Sets the real and eﬀective
user IDs.
Sets the real, eﬀective and
saved user IDs.

setuid(uid_t i)

seteuid(uid_t e)

setreuid(uid_t r,
uid_t e)

setresuid(uid_t r,
uid_t e,
uid_t s)

OS

1–5

1–5

1–5

2–4

1: Darwin 13.0.0 2: FreeBSD 9.1 3: Linux 3.8.0
4: OpenBSD 5.4 5: OpenIndiana 5.11

General Terms
Security

Keywords
setuid, privilege management, POSIX

1.

INTRODUCTION

Privilege management is an essential security function pro-
vided by modern operating systems. It provides a way to
control access to system resources. An underlying reason
for managing privileges is so the system as a whole achieves
some security property, such as adherence to the principle of
least privilege [14]. Via mechanisms provided for privilege
management, a process may, for example, temporarily raise
its privilege to complete a sensitive task, and then return to
its lower privilege level for its remaining tasks.

The setuid family of functions is a POSIX standard [15],
and is amongst the oldest mechanisms for privilege manage-
ment. It has been part of Unix systems for several decades [17].

1391Figure 1: A compressed setuid() state graph fragment that contrasts Darwin and FreeBSD. The graph
fragment contains all setuid() calls where: (1) the transitions on the two platforms diﬀer, and (2) the
transitions are to and from the three selected states. Nodes are labeled with <real, effective, saved> user
IDs. Edges are labeled with Platform (argument): return_value. The state labeled with both <1, 1, 1> and
<2, 2, 2> is a merger (“compression” — see Section 3) of those two states, which are equivalent. For example,
in the FreeBSD transition from <1, 2, 1>, the actual destination state is <2, 2, 2>.

In systems in which setuid is used, the privilege of a process
is indicated by the user and group identities (IDs) that it
possesses. In this way, privilege management with setuid()-
related functions is a sort of process identity management;
to modify its privileges, a process assumes a diﬀerent user
and/or group identity. There are customarily three user IDs
with which a process is associated: real, eﬀective, and saved.
A history of the evolution of these IDs is provided by Chen
et al. [12]; we provide a brief description here. The real user
ID is the ID of the user that invokes the program that the
process executes. The eﬀective user ID is used by the oper-
ating system for most authorization checks. In many cases,
we expect the eﬀective user ID to be the same as the real
user ID, because access control is based customarily on the
invoker, i.e., the user whose process is attempting access.

However, the eﬀective and the real user IDs may diﬀer in
cases wherein, for example, we want the authorization to be
granted based on the owner of the program rather than the
invoker of the program. This is a common way of controlled
privilege escalation — a process executed by an unprivileged
user is able to perform privileged actions, but only within
the conﬁnes of what a particular program is created to do.
The saved user ID is used, as its name suggests, as scratch
space — to save, for example, a user ID of higher privilege
so the eﬀective user ID may be set to it when needed.

When a process is created and starts to execute a pro-
gram, the real, eﬀective and saved user IDs of the process
are instantiated based on the permission settings of the pro-
gram. These permission settings are stored on disk along
with the program as its meta-data. The permission settings
may indicate, for example, that a process that executes the
program should have, as its initial eﬀective user ID, the ID
of the owner of the program and not the invoker [9].

The purpose of setuid functions is to enable a process to
change its real, eﬀective, and/or saved user IDs. For exam-
ple, if the real and eﬀective user IDs are those of an un-
privileged user, and the saved user ID is that of a privileged

user, then we can invoke a setuid call to set the eﬀective user
ID to the saved user ID, and leave the real and saved user
IDs unchanged. This has the eﬀect of raising the privilege
level of the process. Later, the process can invoke a setuid
function to set the eﬀective user ID to be the same as the
real user ID, and thereby lower its privilege level. Processes
that follow this pattern are often referred to as setuid-root
processes. Processes in the broader class of programs that
invoke setuid functions to switch identities — regardless of
whether one of the identities is privileged – are referred to
as setuid processes.

There are four functions in the setuid family for chang-
ing a user ID; we present these in Table 1. There are other
functions in the extended family, such as those for inspect-
ing the user IDs and manipulating group IDs. Some systems
have additional, implementation-speciﬁc user IDs than just
the three (real, eﬀective, saved) that we discuss. In addition,
some systems implement ﬁne-grained credentials that decou-
ple privileges from user IDs. For example, Linux capabilities
and Solaris privileges allow processes to hold privilege to
perform speciﬁc actions, regardless of the user IDs associated
with the process. Although these additional mechanisms do
play an important role in process identity management we
only consider the setuid family in this paper.

The three functions, setuid(), seteuid() and setreuid()
are standardized by POSIX, although setreuid() is marked
for deprecation. The last function, setresuid(), is non-
standard. Despite that POSIX setuid is a decades-old stan-
dard, setuid implementations diﬀer from system to system.
An example of some setuid() implementation diﬀerences is
given in Figure 1. Each edge in the graph fragment is la-
beled as belonging to either Darwin or FreeBSD. The graph
illustrates how FreeBSD may set all three user IDs (real, ef-
fective, saved) on every successful setuid() call, even if the
eﬀective user ID is unprivileged. Darwin, in contrast, sets
only the eﬀective user ID in the unprivileged case. Also no-
tice that, on Darwin, calls to setuid() that are passed the

1392current eﬀective ID remain in the same state, but sometimes
return 0 and other times -1.

Taken together, setuid implementations across diﬀerent
platforms are fraught with such inconsistencies, some easy
to generalize and some not. For example, seteuid() be-
havior on Darwin and FreeBSD are identical, and the same
is true for setreuid() on Linux and OpenIndiana. How-
ever, the implementation diﬀerences in setreuid() on other
platforms is very diﬃcult to characterize succinctly. As we
discuss in Section 2, this sore spot is not surprising given
several problems with the standard for setreuid().

Our work Our work is broadly about investigating the
current status of setuid, and challenging some of the asser-
tions from prior work, such as those of Chen et al. [12] and
Tsafrir et al. [21]. We pose and answer the following sets of
questions. (1) Is the POSIX standard indeed broken as prior
work suggests? That is, are the relationships described in
the standard unambiguous, and does the standard specify
well-formed functions? (2) Do implementations that claim
to be POSIX-compliant comply with the latest standard?
(3) Do the setuid functions and/or setuid wrappers from
prior work provide programmers with an interface that is
both correct and usable?

Towards (1), we express the standards using quantiﬁer-
free ﬁrst-order logic with an associated semantics. (See Sec-
tion 2 and Tables 4 and 5 in the Appendix. We provide
our complete expression in logic as an addendum to this
paper [18].) We discovered that this exercise is not very
challenging, which suggests that the standard is somewhat
well-written. We recognize that we could have instead en-
coded the standard is some other precise syntax (e.g., func-
tional). This choice is not critical to the work or the ensuing
results.

Towards (2), we use our precise expression of the stan-
dard and state-space enumeration similar to that of Chen
et al. [12] to assess whether ﬁve systems that claim to be
POSIX-compliant adhere to the latest standard (see Sec-
tion 3).

Towards (3), we discuss some issues with setuid wrap-
pers proposed in 2002 [12] and 2008 [21], and extend our
state-space graph to include the functions from 2008 (see
Section 4). These analyses reveal several usability and cor-
rectness problems. We propose a new interface for managing
process identities, establish its correctness, and argue that
it is usable.

Summary of observations We claim several observa-
tions and results that diﬀer from or build upon prior work.
We observe that the notion of appropriate privileges, which
the standard uses to capture implementation diﬀerences be-
tween standard-compliant systems, does not fully do so.
Nevertheless, we have discovered that the standards for the
setuid() and seteuid() are unambiguous function descrip-
tions. Furthermore, we have learned that, with the excep-
tion of FreeBSD, all of the operating systems we have evalu-
ated abide by these two standards. We furthermore provide
a simple explanation for FreeBSD’s deviation from the stan-
dard.

We deduce that the standard for setreuid() is both am-
biguous and logically inconsistent. We precisely identify the
ways in which the standard is broken, oﬀer an interpretation
of the standard that is consistent with most systems under
analysis, and precisely deﬁne the way in which other systems

appear to have implemented the function. We also point out
that POSIX has designated setreuid() for deprecation [15].
We have discovered several usability and correctness issues
with existing process identity management wrappers. Both
wrappers do not perform suﬃcient sanity checks to ensure
that the action implied by the function name is performed
correctly. The wrapper proposed in 2002 also has a condition
in which is fails silently. Finally, the wrapper proposed in
2008 will, by default, crash the process when it gets stuck
in an irreparable state.

Motivation Setuid is well-established both in the POSIX
standard and in implementations, and several of its problems
are well-known. It has even been characterized as “untrust-
worthy” [21]. Furthermore, some systems have implemented
ﬁne-grained privilege management that interacts with setuid
(e.g., Linux Capabilities and Solaris Privileges).

Also, devices that rely on setuid number in the tens or
even hundreds of millions [2]. Such devices include cloud-
computing and e-commerce servers. Furthermore, setuid is
invoked by many tools in UNIX systems, such as mount.
Given the fundamental nature of such setuid-dependent tools,
devices’ reliance on setuid is unlikely to ease in the foresee-
able future.

We have observed also that the behavior of some calls,
such as setuid(), has changed in some systems recently.
For example, setuid(-1) behaves diﬀerently in Linux 3.2
(released early 2012) than in 3.8 (released early 2013). It is
no surprise that work on addressing issues related to setuid
continues (see Jain et al. [16] for a recent example).

Therefore, it is meaningful for us to investigate the status
of setuid with an intent of seeking improvements. The re-
search community in security has exposed a number of issues
with setuid in the past [12, 13, 21]. We ask whether things
have improved with setuid over the past decade or so, par-
ticularly since the work of Chen et al. [12], which discusses
the issues in some depth.

Layout The remainder of the paper is organized as fol-
lows.
In the next section we discuss our precise encoding
of the POSIX standard and an implementation-independent
description of setresuid() (which has not been standard-
ized). We further present analysis that shows which of these
standards and documentation are unambiguous function de-
scriptions. In Section 3, we compare ﬁve setuid implemen-
tations with the standards and documentation, and present
our ﬁndings. In addition, we analyze the usability and cor-
rectness of two process identity management interfaces that
wrap setuid.
In Sections 4 we discuss two alternative in-
terfaces that wrap setuid and present a third based on our
experiments. Section 5 describes related work. Finally, Sec-
tion 6 summarizes conclusions drawn from our experiments
and suggests opportunities for future work.

2. SETUID STANDARD

We have assessed the latest POSIX standard [15] for se-
tuid as to whether it provides unambiguous, logically consis-
tent function descriptions. By unambiguous we mean that
the standard text does not have more than one reasonable
interpretation. By logically consistent we mean that there
are no contradictions. By function description we mean that
the relationships described in the standard deﬁne mathe-
matical functions (i.e., a mapping from each possible input
to exactly one output). The ﬁrst criterion, unambiguity, is

1393somewhat subjective; the other two criteria are objective.
We are in contact with the Austin Group [3], but, as of the
writing of the paper, do not have any conﬁrmation of the
issues, or resolution.

Structure of the standard The text in the standard
for each setuid function has four parts: (1) the name and
signature of the function, (2) a description of function be-
havior, (3) a description of the return value, and (4) a list
of error conditions which may cause the function to fail. We
do not consider other sections, such as rationale and change
history, that discuss the evolution of the standard. The se-
tuid functions standardized by POSIX have three features
in common:

• Return a value of 0 to indicate success;
• Return a value of -1 to indicate failure;
• Fail for one of two reasons:

– The EINVAL error occurs if any function argument

is invalid or out-of-range,

– The EPERM error occurs if the process does not
have permission to set user IDs to the requested
values. This error can only occur when a process
is unprivileged.

How we assessed the standards As the standard is
written in a natural language, interpreting it is inherently a
subjective exercise. Our ﬁrst task was to express the stan-
dard for each function using a precise syntax that lends it-
self to a precise semantics. We have translated the standard
using quantiﬁer-free ﬁrst-order logic, with an associated pre-
cise semantics.

We chose this representation for two reasons: (1) the sen-
tences of the standard describe relations over process uid
states and function inputs, (2) these relations are expressed
in terms of value equality/inequality. Some results from this
exercise are presented in Tables 4 and 5 in the Appendix.
The complete results are provided as an addendum to this
paper [18]. Due to space considerations, we include a seman-
tics description and logical forms for setreuid() (setuid(),
seteuid(), and setresuid() omitted). We point out that
we are not the ﬁrst to translate a standard written in a
natural language to logic. There is work, for example, in
translating standards for communication devices to logic for
the purpose of veriﬁcation [8, 19].

For each setuid function, we have a set of formulas. The
intent is that the formulas are true facts about any invo-
cation of the function. The set of facts for a function to-
gether specify when an invocation of the function succeeds,
and when it fails. We model a process’ state as a three-
tuple of its real, eﬀective, and saved user IDs. We model
setuid function calls as stateful functions that can manipu-
late these three values. Each function has a set of explicit
arguments as deﬁned by the standard. In addition, the stan-
dards contain several implementation-speciﬁc parameters.
The most conspicuous of these parameters is “appropriate
privileges,” which is discussed at length by Chen et al. [12].
We discuss implementation-speciﬁc parameters below, after
we complete this discussion of our translation. Although
these components (state, arguments, and parameters) are

suﬃcient to capture the meaning of statements in the stan-
dards, additional intermediate variables are introduced for
clarity.

We now discuss an example of a passage from the standard
for setuid() and the corresponding translation to our logic.
Prior work [12] points to setuid() as a particularly prob-
lematic function in the setuid family. The example serves
to illustrate the translation process we followed, and to con-
vince the reader that our translation process is sound in that
we have adopted a reasonable interpretation of the standard.

From the standard:

If the process does not have appropriate privi-
leges, but uid is equal to the real user ID or the
saved set-user-ID, setuid() shall set the eﬀective
user ID to uid ; the real user ID and saved set-
user-ID shall remain unchanged.

Our translation:

success nap ↔ (rtn = 0 ∧ new ruid = old ruid ∧

(1)

(2)

new euid = arg uid ∧
new svuid = old svuid)

success nap ← (¬AP ∧ (old ruid = arg uid ∨
old svuid = arg uid))

The prose applies to the case that the process does not
have appropriate privileges. The boolean variable (proposi-
tional atom) success nap indicates a successful call by a pro-
cess that does not have appropriate privileges. Formula (1)
expresses the eﬀect, and serves to deﬁne success nap. For-
mula (2) captures the case that the prose addresses.

Implementation-speciﬁc parameters
It can be argued
that, for application developers, it is ideal that all setuid
functions have well-deﬁned implementation-independent stan-
dards. However, in reality systems developers usually care
more about backwards-compatibility than how reﬁned func-
tion behavior is.
It can be argued, then, that the ideal
of implementation independence is unattainable for POSIX
for two reasons: (1) there are setuid implementation diﬀer-
ences between some of the earliest UNIX systems, and (2)
many moderns systems have moved away from the mindset
of the all-powerful root user, preferring to divide power into
smaller units. An example of this is the notion of capabil-
ities in Linux [6]. In Linux, assigning the root user ID to
the eﬀective user ID of a process activates all capabilities.
However, processes can be given individual capabilities even
when their eﬀective user ID is not root. For example, a pro-
cess may obtain the CAP_SETUID capability, which allows the
user to “make arbitrary manipulations of process UIDs” [6].
POSIX’s way of dealing with this has been to abstract un-
restricted setuid privileges in the phrase “appropriate priv-
ileges.” Prior work has suggested that this abstraction is
a cause of confusion about setuid implementation diﬀer-
ences [12]. Based on our analysis of the standard, appro-
priate privileges is not to blame for this confusion. Indeed,
it is not diﬃcult to give a crisp deﬁnition of appropriate
privileges on most platforms; for example, on Linux, a pro-
cess has appropriate privileges if and only if the process has
CAP_SETUID in its set of eﬀective capabilities.

The notion of appropriate privileges can make the stan-
dard easier to read for the following reason.
If all imple-
mentation dependent behavior is captured by the notion of

1394Table 2: Implementation-dependent parameters in
the POSIX setuid standard, as they are deﬁned in
our logic system in Table 4 in the Appendix.

Name

AP

IsU ID(id)

RuidIsP ermitted(id)

Description

Appropriate privileges.
The value, id, is not a valid user
ID on the system.
Given the current privileges of
the process,
id
is permitted by the system
as real user ID argument for
setreuid().

the value of

appropriate privileges, then the constraints of the standard
+ a deﬁnition of appropriate privileges suﬃce to precisely
deﬁne function behavior. Unfortunately, as we discuss be-
low, appropriate privileges is not the only implementation-
dependent parameter in the setuid standards. A complete
list of such parameters is presented in Table 2.

Special user IDs
It is worth noting that setreuid() and
setresuid() treat an argument value of -1 specially. Infor-
mally, this value indicates, “do not change the correspond-
ing user ID”. Unfortunately, the standards for setuid()
and seteuid() make no mention of how an argument value
of -1 should be treated. By this omission, we presume
that POSIX intends such cases to fall under the purview
of implementation-dependent parameters. We discuss the
security implications of this choice in Section 3.2.
2.1 Unambiguity of the Standards

We now address the ﬁrst of our three properties for the
standard: unambiguity. The setuid() and seteuid() stan-
dards are unambiguous. All references to function argu-
ments and state variables have a clear meaning.

However, the standard is ambiguous for setreuid(). For
example, the standard refers to the real user ID state vari-
able in diﬀerent instances as “new real user ID”, “current real
user ID”, and “real user ID”. It is unclear whether the third
term refers to the state variable at the time the function is
invoked, or upon return. The same issue arises in the use of
the phrase “either the real, eﬀective, or saved user ID.”

Through various iterations of setuid state graph veriﬁca-
tion (see Section 3), we have deduced the meaning of am-
biguous phrases that minimizes the number of systems un-
der test that violate the setreuid() standard. By “real user
ID” the standard appears to intend the current real user ID
(i.e., the real user ID value prior to function invocation).
By “either the real, eﬀective, or saved user ID” the standard
appears to intend the respective current IDs.
2.2 Logical Consistency of the Standards

Our second criterion for assessing the standard is logical

consistency — the absence of contradictions.

The standards for setuid() and seteuid() are logically
consistent, with a caveat that we mention below. The stan-
dards describe the following four broad categories of behav-
ior: (1) function success for a process with appropriate priv-
ileges, (2) function success without appropriate privileges,
(3) function failure due to lack of appropriate privileges,

and (4) function failure due to invalid input arguments. As
such, the class of relations described in the standard can
be contradictory in two ways: some set of input arguments
may entail (1) diﬀerent function behaviors (e.g., the function
both succeeds and fails), and/or (2) some implementation-
dependent parameter is both true and false. In the case of
setuid() and seteuid(), we observe that no two behaviors
overlap, and that no parameter contradictions are entailed.
Therefore, these standards are logically consistent.

The setreuid() standard is logically inconsistent. The
standard explicitly allows processes without appropriate priv-
ileges to set the eﬀective user ID to any one of the current
real, eﬀective, or saved user IDs. However, the EPERM condi-
tion speciﬁes that an attempt by processes without appropri-
ate privileges to set the eﬀective user ID to any value other
than the real or saved user ID is an error. As such, the
standard contains contradictory success/failure conditions
for certain inputs. For example, if <ruid, euid, svuid> =
<0, 1, 2> and we invoke setreuid(0, 1), the main func-
tion description suggests that the call should succeed whereas
the errors section suggests that the call should fail.

Caveat The setuid standards contain phrases that say ex-
plicitly, or via implication, that a process with appropriate
privileges can set user IDs to “any value.” This contradicts
the suggestion in the standard that implementations may
deﬁne any values as invalid — regardless of appropiate priv-
ileges — and return the EINVAL error condition. In light of
this apparent contradiction, our codiﬁcation of the standard
interprets “any value” to mean “any valid user ID value.”
We feel that this interpretation is reasonable, given that it
appears to be consistent with the behavior of implementa-
tions (see also our discussion of two hypotheses for EINVAL
in Section 3).
2.3 Standards as Function Descriptions

Our third criterion is whether the standards specify well-
formed functions, that is, a mapping from every possible
input to a single output.

The standards for setuid() and seteuid() describe well-
formed functions. We observe that the four categories of
behavior described in the previous section cover all possibil-
ities. Furthermore, each category describes precisely what
the function’s return value and the process-state should be
upon return. Therefore, these standards are complete. Taken
together, the standards are indeed function descriptions.

In the case of setreuid(), in addition to the logical incon-
sistencies we mention in the previous section, the standard
does not specify the behavior for all function inputs. For-
mula 3 below is the only one that deﬁnes the behavior of the
saved user ID when the function returns successfully. The
problem is that the formula speciﬁes an “only if” condition,
and not an “if and only if.” That is, the expression evaluates
to ‘true’ even if the expression to the right of the inference
is false. The new saved user ID is not constrained to a single
value when the right-hand side of the formula is false.

(new svuid = new euid) ←(arg ruid (cid:54)= −1 ∨
(arg euid (cid:54)= −1 ∧
arg euid (cid:54)= old ruid))

(3)

2.4 Fixing the standard

Our observations in the three previous section are that the
standards are broken in two ways. One is the ambiguity, con-

1395tradictions, and incompleteness of setreuid(). The other is
the extraneous implementation-dependent parameters out-
side the context of appropriate privileges. There seem to be
two conﬂicting perspectives on whether the standards are
easily ﬁxed.

On one hand, these problems are seemingly easy to ﬁx. We
have already oﬀered an interpretation of ambiguous state-
ments that maximizes compliance of ﬁve modern UNIX-like
systems. Contradictions in setreuid() can be resolved by
adopting one of the two descriptions for a valid arg euid ar-
gument, and its functional description can be completed by
changing the saved user ID requirements to read “if and only
if.” Finally, extraneous implementation-dependent parame-
ters can be dropped by specifying: (1) arg ruid values for
setreuid() in the unprivileged case that are acceptable, and
(2) user IDs that should trigger the EINVAL error condition
for each function.

On the other hand, however, these changes would break
standards compliance for several implementations. At least
three setreuid() implementations (FreeBSD, Linux, and
OpenIndiana), and two setuid() and seteuid() implemen-
tations (Darwin, and OpenIndiana) would no longer comply.
2.5 Setresuid

As we mention in Section 1, POSIX standardizes only
three of the setuid functions that we discuss: setuid(),
seteuid(), and setreuid(). Three of the ﬁve operating
systems we evaluated additionally support setresuid() (see
Table 1 in Section 1). Our study of setresuid() in prior
work [12, 21] and the documentation for it in the three sys-
tems that support it [4, 5, 7] tells us that all of them specify
the same semantics for it with respect to processes with
and without appropriate privileges. That is, even where the
speciﬁcations for the function’s behavior may diﬀer, they do
not diﬀer for success and failure conditions for a process with
appropriate privileges, or for a process without appropriate
privileges. Any diﬀerence is only in what constitutes appro-
priate privileges. We refer to their common speciﬁcation as
the consensus standard for setresuid().

The consensus standard for setresuid() is an unambigu-
ous, logically consistent function description. All terms have
a clear and consistent meaning, the input conditions for each
output behavior are non-overlapping, and every input maps
to an output. We observe that this clarity with setresuid()
has been pointed out by prior work [12, 21], and our investi-
gation in Section 3 veriﬁes that all setresuid() conform to
the consensus standard. Nevertheless, cross-platform appli-
cations cannot rely on setresuid() alone, making our other
analyses crucial to such applications, because, as we men-
tion above, (1) it is not standardized, and (2) not all systems
support it.

3. SETUID IMPLEMENTATIONS

To evaluate setuid standards compliance we performed
a state-space enumeration similar to the one described by
Chen et al. [12] on the ﬁve operating systems that we men-
tion in Table 1. Our procedure systematically explores all
possible user ID states of a process, and the state-transitions
from each state to other states, under certain assumptions.
We assume that, with the exception of uid = -1 – implic-
itly or explicitly cast to uid_t, which we discuss below – all
unprivileged user IDs have the same restrictions placed on
their setuid calls. We further assume that no new user IDs

other than those listed as function arguments are introduced
in the resulting state.

As noted in Table 1, Darwin and OpenIndiana do not
implement setresuid(). As one might expect, they simi-
larly do not implement getresuid(). To look up the saved
user ID on Darwin, our state-space explorer invokes proc_-
pidinfo(), which ﬁlls out a struct containing, among other
things, the current saved user ID of the process. To look up
the same datum on OpenIndiana, the program reads it from
the /proc/[pid]/cred ﬁle.

A point of curiosity during this exercise was how the
EINVAL error is triggered in each system. Before completing
a full state-space enumeration, we manually tested two hy-
potheses in this regard: (1) systems will return EINVAL when
a negative user ID is applied to any setuid function (with the
exception of passing -1 to setreuid() and setresuid()),
and (2) systems will return EINVAL when -1 is passed to
setuid() and seteuid(). Hypothesis (1) proved to be false;
this is not surprising, given the uid_t is unsigned int on all
ﬁve platforms. Hypothesis (2) holds for Linux and OpenIn-
diana, but not for Darwin, FreeBSD, and OpenBSD. In fact,
based on our state-space enumeration it appears that Hy-
pothesis (2) accounts for all instances of EINVAL in the enu-
meration.

The above-mentioned observations led to two key diﬀer-
ences between our state-space exploration and that of Chen
et al. [12] in this context. One is that we have investigated
ﬁve systems, whereas that work investigated three. Also,
Chen et al. [12] do not present ﬁndings regarding transi-
tions between non-root users. We performed the enumer-
ation over eight user IDs:
-1, 0, and 1 through 6. User
IDs -1 (only supported by some systems) and 0 (the super-
user) are treated specially. We include six additional unpriv-
ileged user IDs to cover state transitions such as: (cid:104)1, 2, 3(cid:105) →
setresuid(4, 5, 6) → (cid:104)?, ?, ?(cid:105). Constructing this larger
graph enables us to be conﬁdent that, under our assump-
tions, we have explored all possible states. The output of
the state-space enumeration is a graph, GOS as follows:

U = {−1, 0, 1, 2, 3, 4, 5, 6}
GOS = (cid:104)V, E(cid:105)
V = (cid:104)ruid, euid, svuid(cid:105)
E = (cid:104)function, arguments, return value(cid:105)
function ∈ {setuid(), seteuid(), seteuid(),

setreuid(), setresuid()}

every argument ∈ U

Our assumptions suggest that our graph could be com-
pressed; we could, for example, deem that <1,2,2> = <6,4,4>.
This compression would save space and require that edges
be labeled with a remapping of canonical user IDs. In Figure
1, we show a fragment of a “diﬀerence” graph that we also
generated automatically. The graph fragment shows some of
the diﬀerences between Darwin and FreeBSD for setuid().
3.1 Standards Compliance

Once we constructed setuid state graphs for all ﬁve sys-
tems we reiﬁed the logic of the standards1 as C++ code that

1In the case of setreuid(), the more permissive interpreta-
tion of acceptable arg euid values from the DESCRIPTION
portion of the standard is applied. Naturally, applying the
unmodiﬁed standard in its logically inconsistent state would
fail.

1396Table 3: POSIX setuid standard [15] compliance
for ﬁve modern operating systems. “Yes” indicates
standard compliance, and “No” indicates deviation
from the standard.
System\Function

setreuid()

setuid()

seteuid()

Darwin
FreeBSD

Linux

OpenBSD

OpenIndiana

Yes
No
Yes
Yes
Yes

Yes
Yes
Yes
Yes
Yes

No
Yes
Yes
No
Yes

inspects state transitions for standards compliance, and ran
it against the ﬁve graphs. The results of this experiment are
reported in Table 3. As a follow up experiment, we relaxed
constraints in the standard to better understand the nature
of non-compliant implementations.
Checking for contradictions related to function output
was straightforward: the proposition (success ∧ ¬f ail)
∨ (f ail ∧ ¬success) must hold for all edges.
Checking implementation-dependent parameters was more
nuanced. In the case of ¬IsU ID(.), we observe that if a call
to function, f , with arguments, A, triggers an EINVAL error
in one context, because ∃ a ∈ A . ¬IsU ID(a). Therefore,
if f (A) triggers EINVAL in one context, then it must trigger
EINVAL in any context. To check the consistency of EINVAL,
we maintained a list (cid:104)f, A(cid:105) pairs that trigger the error. Af-
ter visiting the entire graph once, we revisited the graph to
conﬁrm that no such pair triggers the error in one context
but not another. Note that this proves a weak condition
on the full set of function parameters.
It does not prove
which argument value triggers EINVAL, or whether the of-
fending argument is treated inconsistently by the system.
As we discuss below, the identity and consistency of invalid
user IDs becomes self-evident when each system’s instances
of EINVAL are manually inspected.

To check AP (appropriate privileges), we manipulated the
formulas we constructed from the standard to derive facts
that necessarily entail either AP or ¬AP . Then we checked
that ¬(AP ∧ ¬AP ) holds for all edges.
In the case of
setreuid(), where such facts contain the implementation-
dependent condition RuidIsP ermitted(arg ruid), we
checked the somewhat weak condition that ¬(AP ∧ ¬AP )
holds for either RuidIsP ermitted(arg ruid) = (cid:62) or
RuidIsP ermitted(arg ruid) = ⊥ (where (cid:62) and ⊥ indicate
true and false, respectively). The same procedure was
used to check RuidIsP ermitted(arg ruid) with this weak
condition applied to AP .

3.1.1 Results
FreeBSD’s setuid() implementation is out of date.

In
previous revisions of the POSIX standards, POSIX intro-
duced a parameter called _POSIX_SAVED_IDS, which was to
be set to either “deﬁned” or “undeﬁned.” POSIX now man-
dates that implementations follow the behavior for which
_POSIX_SAVED_IDS is deﬁned, but FreeBSD’s setuid() func-
tion implements the _POSIX_SAVED_IDS-undeﬁned case in
the old standard.

Darwin and OpenBSD’s setreuid() implementations vi-
olate the standard for setting the saved user ID. Rather

Figure 2: An example of implementation diﬀerences
for the EINVAL error being potentially problematic.
We expect the setresuid() call in the ﬁgure to cause
the process to downgrade itself to the real user ID.

than following the rule expressed by Formula 3 from Section
2.3, Darwin and OpenBSD follow the rule expressed by For-
mula 4 and Formula 5, respectively. On Darwin, a successful
setreuid() call either leaves the saved user ID unchanged,
or sets it to the previous eﬀective user ID. On OpenBSD,
a successful setreuid() call either leaves the saved user ID
unchanged, or sets it to the new real user ID.

svuid success ↔(new svuid = old svuid ∨

new svuid = old euid)

(4)

svuid success ↔(new svuid = old svuid ∨

new svuid = new ruid)

(5)

We point out that the above two rules are not a complete
description of the behavior of setreuid() on the saved user
ID. The exact rules for Darwin and OpenBSD are consider-
ably more complex. Given that the setreuid() standard
is an incomplete description of a function that has been
marked for deprecation by POSIX, we present the above
two rules in the interest of clarity.
3.2 Security Implications

We now discuss the implications of our ﬁndings to the se-
curity of a system that uses setuid. One issue is that any
setuid program that assumes that a platform complies with
the latest standard, when it does not, may be vulnerable to
attack. This appears to be the case with FreeBSD’s imple-
mentation setuid(), and with Darwin and OpenBSD’s im-
plementations of setreuid() (see Table 3 and Section 3.1.1).
Implementation diﬀerences with respect to when the error
EINVAL is returned are likely also problematic. A speciﬁc
case of this is the mismatched semantics of -1 as an ar-
gument (implicitly or explicitly cast to uid_t) between the
paris of functions setuid() and seteuid(), and setreuid()
and setresuid(). The mismatched semantics can, for ex-
ample, cause a process to reasonably assume that it has
dropped privileges when it has not.

An example is shown in Figure 2. In the ﬁgure, a process
is in the state in which its real, eﬀective, and saved user
IDs are (cid:104)−1, 0, 0(cid:105), each typecast to uid_t. Now, a call to
setresuid() as shown in the ﬁgure does not downgrade the
process to (cid:104)−1,−1,−1(cid:105). One would reasonably expect an
invariant to be respected that when the real user ID of the
process is non-root, and such a call is made, the process is
permanently downgraded to its real user ID.

������������������������������������������������������������������������������������������������������������������������������������������������������������������������������13974. ALTERNATIVE INTERFACES

Prior work [12, 21] has suggested that UNIX process iden-
tity management functions are: (1) often misused, suggest-
ing usability problems; (2) designed to support temporar-
ily dropping/restoring privileges and permanently dropping
privileges. In light of these observations, the prior work pro-
poses two alternative interfaces, one that wraps the setuid
family of functions and one that wraps an extended family
user and group ID management functions. To extend our
analysis of setuid we have analyzed these two wrappers for
usability and correctness. The issues we found motivated
our implementation of a diﬀerent wrapper interface.

Chen et al. [12] provide two versions of their interface; one
for use with systems that support setresuid(), and another
for systems that do not. The issues we discuss manifest
consistently in the former implementation.

Both Chen et al. [12] and Tsafrir et al. [21]’s interfaces
do not perform suﬃcient sanity checks on function argu-
ments. There is no check to ensure that the argument to
drop_priv_perm() (which is used to drop privileges perma-
nently) or drop_priv_temp() (drop privileges temporarily)
cause the process to indeed drop privileges.
In Chen et
al. [12]’s case, if a privileged process invokes one of these
functions with an argument value of -1 or 0, then the privile-
ge-dropping functions return 0 without dropping appropri-
ate privileges. The same probelem arises in Tsafrir et al.
[21]’s privilege-dropping functions for an argument value of
0, tho- ugh a sanity check is performed for a value of -1.

Chen et al. [12]’s functions that rely on setresuid() con-
tain another bug. If a process calls restore_priv(), per-
haps mistakenly, after calling drop_priv_perm(), restore_-
priv() erroneously returns 0, implying that privileges have
been restored.

Tsafrir et al. [21]’s interface also contains a serious usabil-
ity issue. The interface is written to “do its best” to switch
to the requested user identity. When setresuid() is not
available this can entail making two setuid-like function calls
(the same goes for setgid-like functions). Unfortunately, the
second call may fail, leaving the process in a potentially ir-
reversible intermediate state. The interface authors’ way of
dealing with this problem is to call abort() on any system
call failure, crashing the process2. While this approach is
secure, it is also highly unusable.
4.1 Proposed Interface

We propose an alternate interface for user ID manage-
ment. Our interface is similar to Chen et al. [12]’s and
Tsafrir et al. [21]’s insofar as it is designed with the no-
tions of “temporary” and “permanent” identiy changes in
mind. Indeed, our implementation shares some code with
theirs [20]. However, unlike Tsafrir et al. [21]’s interface,
our implementation deals exclusively with user IDs, and not
groups. We leave an extension to properly manage groups as
future work. Our implementation is available for download
[18].

We observe that a setuid-like interface should be usable
for root-setuid processes as well as non-root-setuid processes.
Nevertheless, wrappers from prior work use the language of
dropping and restoring privileges. In light of this observa-

2Tsafrir et al.
[21] provide a C-style #define, LIV-
ING ON THE EDGE, to allow users of the interface to get
a return of -1 instead of crashing, but this does not solve
the intermediate state problem.

tion, our interface comprises the two functions: change_ide-
ntity_permanently(uid) and change_identity_temporar-
ily(uid). This puts the onus on the developer to correctly
select a privileged or unprivileged identity. The function
names do not imply that privileges will be dropped or re-
stored.

The interface is designed to provide the following guaran-
tees: (1) internally consistent success or failure3: return 0
on success, or return -1 and set errno appropriately with-
out changing any user identity state on failure; (2) in the
_permanent case, upon success, set all three user IDs to the
speciﬁed value; (3) in the _temporary case, upon success,
set the eﬀective user IDs to the speciﬁed value and store the
previous eﬀective ID in either the real or saved ID locations.
The greatest challenge in implementing such an interface
is dealing with systems that do not support setresuid().
In such cases, the implementation must rely on potentially
multiple platform-dependent system calls to change identi-
ties. In light of the divergent — sometimes non-standard —
setuid implementations discovered during our experiments,
we chose to implement our interface by making the setuid
call graph directly available to the underlying code.

Our implementation uses a shortest path matrix to eﬃ-
ciently lookup relevant details of the call graph. This ma-
trix can be automatically computed oﬄine for each version
of each operating system where the implementation is to be
deployed. The computation repeatedly invokes Boost’s im-
plementation of Dijkstra’s shortest path algorithm [1], which
outputs a predecessor map for a given starting vertex. The
resulting predecessor maps, one for each choice of source ver-
text, are stored as a shortest path matrix for quickly looking
up the sequence of predecessors to get from any source vertex
to any destination vertex. When a change-identity function
is called, we ﬁrst use the shortest path matrix to determine
the feasibility of the identity change. If the change is feasi-
ble, we employ the matrices to follow the shortest path to
the desired state; if not, we return an error without touching
the process’ current privileges.

Our change-identity algorithms are described in ChangeI-

dentityPermanently, ChangeIdentityTemporarily,
and GoToState below. Note that ChangeIdentityPe-
rmanently and ChangeIdentityTemporarily are analo-
gous to change_identity_permanently(uid) and change_i-
dentity_temporarily(uid), respectively. Also note that
the Path function looks up a shortest path using a predeces-
sor map. Both algorithms have an implicit input parameter,
G, that represents the user ID state graph.

In order to use our user ID state graphs, the actual user
IDs at runtime must be normalized to the IDs in the group
(hence the UIDMap and Normalized* functions). Two
user IDs, 0 and -1, are not normalized. As mentioned in
Section 3, all other users are treated as having interconvert-
ible privileges. As such, our implementation converts each
non-zero-and-non-negative-one “actual ID” to a “normalized
ID” within the range presented in Section 3. When setuid
functions are called, IDs are converted back to their actual

3Our implementation can be compiled with or without
threading support, which wraps interface functions in a basic
locking mechanism to prevent concurrent identity changes
on diﬀerent threads. Naturally, this does not guarantee cor-
rect behavior in multi-threaded environments where setuid
functions are manually invoked, or where interface functions
are invoked within interrupt handlers.

1398values before the functions are invoked (hence the uidMap
parameter for InvokeSetuidFunction).

If a system does not support user ID -1, then any attempt
to lookup a user ID state containing -1 will fail.
In such
cases, our implementation returns the EINVAL error. In this
way, invoking our interface with a user ID of -1 can succeed
only on systems that support setting the ID to -1, and will
fail on all other systems by construction.

ChangeIdentityPermanently(uid, G)

cState ← CurrentUIDs(uid)
uids ← {x ∈ cState} ∪ {uid}
uidMap ← UIDMap(uids)
ncState ← NormalizedState(cState, uidMap)
nUID ← NormalizedUID(uid, uidMap)
ntState ← (cid:104)nUID, nUID, nUID(cid:105)
return GoToState(ncState, ntState, uidMap, G)

1
2
3
4
5
6
7

ChangeIdentityTemporarily(uid, G)

cState ← CurrentUIDs(uid)
uids ← {x ∈ cState} ∪ {uid}
uidMap ← UIDMap(uids)
nUIDSet ← NormalizedUIDSs(uidMap)
ncState ← NormalizedState(cState, uidMap)
nUID ← NormalizedUID(uid, uidMap)
ntStates ← {(cid:104)x, y, z(cid:105) : y = uid ∧ ((x = b ∧ z ∈
ntState ← x : x ∈ ntStates,

6 (cid:104)a, b, c(cid:105) ← ncState
8 {a, b, c}) ∨ (x ∈ {a, b, c} ∧ z = b))}

1
2
3
4
5

7

9

∀y∈ntStates|Path(ncState, x)| ≤ |Path(ncState, y)|

10

return GoToState(ncState, ntState, uidMap, G)

GoToState(ncState, ntState, uidMap, G)

if not StateExists(ntState, G) then

errno ← EINVAL
return −1
errno ← EPERM
return −1

1
2
3

4
5
6

7
8
9
10

if not PathExists(ncState, ntState, G) then

path ← Path(ncState, ntState, G)
foreach functionCall ∈ path do

InvokeSetuidFunction(functionCall, uidMap)

return 0

In ChangeIdentityTemporarily, a state with the short-

est path available path is chosen for the sake of eﬃciency.
The runtime of ChangeIdentityPermanently and Ch-
angeIdentityTemporarily is O(|Vertices(G)|). This is
clear from the following observations: (1) |uidM ap| ≤ 4,
making normalization and normalized ID lookup O(1); (2)
|ntStates| ≤ 5; (3) |path| ≤ |Vertices(G)|, and the same
applies to all shortest paths in G. In practice, shortest paths
of interest — when they exists — contain two edges or fewer.
The worst case is starting in a state with with an unprivi-
leged user ID, and requesting a change to a diﬀerent unpriv-
ileged user ID that appears nowhere in the current user ID
state. When such a change is possbile, it requires one call
to elevate privilege and a second call to set the eﬀective user
ID (and possibly the other IDs) to the requested value.

4.1.1 Resilience to Change
During data collection on diﬀerent machines we observed
that Linux has changed its behavior for user ID -1 at least as
recently as the last three years. Darwin and FreeBSD have a
common BSD ancestry, but FreeBSD supports setresuid()
whereas Darwin does not. Suﬃce it to say that setuid be-
haviors do change.

One of the advantages to our user ID call graph approach
is its resilience to change. The graph can be generated for
any version of any POSIX-compliant kernel, and with virtu-
ally no code changes4, our interface will work properly.

4.1.2 Converting Existing Code
We expect that switching to the proposed interface is
straightforward for developers familiar with their existing
code.
In such instances, developers can readily identify
whether setuid calls constitute attempts to change identity
permanently or temporarily. Unfortunately, automating this
process may prove diﬃcult due to the strange ways in which
setuid invocations are sometimes used (e.g., checking the re-
turn value of setuid() to test whether privileges have been
permanently dropped [11]).

5. RELATED WORK

Setuid has been part of Unix systems for several decades
[17]. Chen et al. [12] provide a concise history of the evolu-
tion of the three user IDs (real, eﬀective and saved) that we
discuss in this paper, and the associated family of functions,
setuid(), seteuid(), setreuid() and setresuid(). Issues
with setuid have been known for a long time. For example,
Bishop [9] discusses how to write a program for which it is
safe to set the setuid bit, so that it runs with the owner’s
user ID as its eﬀective user ID, rather than the invoker’s.

To our knowledge, the work of Chen et al. [12] is the
ﬁrst to systematically study the setuid family, and discuss
problems related to ambiguity in the POSIX standard and
compliant implementations.
It remains the most compre-
hensive study on the topic. That work considers POSIX
1003.1-1988, which, as that work asserts, standardizes the
setuid() call only. Since then, and as of the writing of this
paper, POSIX has standardized seteuid() and setreuid()
as well. Also, the standard for setuid() has not changed in
any substantive way since the publication of that paper.

The work of Tsafrir et al. [21] builds upon the work of
Chen et al. [12]. Speciﬁcally, it points out that the prior
work does not consider the role that supplementary groups
play in an access control decisions. It then provides wrapper-
functions over the setuid calls for a process to, for example,
drop its privileges permanently.

Our work builds upon the work of Chen et al. [12] and
Tsafrir et al. [21]. We compare our data from state-space
enumeration to the data reported by Chen et al. [12]. Also,
we challenge several assertions in those two pieces of work
regarding the quality of the standard, and compliance of
implementations.

Apart from the above pieces of work that deal directly
with setuid, there is broader work related to authorization;
we refer the reader to Bishop [10] for a comprehensive dis-
cussion.

4A #define is used in the generator code to declare which
platforms do not support setresuid(). Naturally, legacy
systems may also require changes to #includes as well.

13996. CONCLUSIONS AND FUTURE WORK
Prior work has suggested that standardized setuid func-
tions are broken, and that the non-standard setresuid()
has superior (i.e., more straightforward) semantics. Our in-
vestigation has revealed problems with both the standard it-
self and standard compliance. The standards for setuid()
and seteuid() are, for the most part well written. The
standard for setreuid() is ambiguous, logically inconsis-
tent, and incomplete as a description of a well-formed func-
tion. Given that the standard requires “appropriate privi-
leges” (or an abstraction like it) to allow for some ﬂexibility,
we conclude that the biggest overall problem with how the
standards are written is that this abstraction does not en-
tirely encapsulate implementation-deﬁned parameters of the
setuid family of functions. These issues can be ﬁxed with
straightforward changes to the standard, but such changes
would make at least ﬁve current function implementations
non-compliant.

With respect to standards compliance, FreeBSD has not
updated its setuid() implementation to abide by the lat-
est standard, and Darwin and OpenBSD do not abide by
the prescription for setreuid() saved user ID behavior.
Also, Darwin, FreeBSD, and OpenIndiana do not treat -1
as an invalid ID, leading to problematic diﬀerences between
setuid() and seteuid(), and setreuid() and setresuid().

In terms of usability, missing implementations for

setresuid() on Darwin and OpenIndiana complicates the
construction of an interoperable interface for process identity
management. Through our evaluation of two such interfaces
we conﬁrm that building something that is both usable and
correct on top of setuid is not straightforward. Neverthe-
less, preliminary testing of our new interface suggests such
an interface is possible to construct when platform-speciﬁc
behaviors are integrated into the implementation in a con-
sistent manner.

Our investigation suggests several directions for future
work. Our current implementation does not use a com-
pressed graph, which could, if implementeed, reduce space
requirements. Also, we intend to investigate an extension
of our state graph-based approach to additionally manage
group IDs. Finally, our interface could employ platform-
speciﬁc credential management systems, speciﬁcally Linux
capabilities and Solaris privileges when state graph lookup
suggests the requested identity change is infeasible. These
research directions may serve to further unify the fragmented
interface for POSIX process identity management.

Acknowledgement
We thank our shepherd, Dr. Stephen Checkoway, and the
anonymous reviewers for their helpful comments.

7. REFERENCES
[1] dijkstra shortest paths.

http://www.boost.org/doc/libs/1_55_0/libs/
graph/doc/dijkstra_shortest_paths.html. boost
C++ libraries. Last accessed: Aug. 14, 2014.

[2] LiCo - The New LinuxCounter Project.

http://linuxcounter.net/. Last accessed: Nov. 12,
2013.

[3] The Austin Common Standards Revision Group.

http://www.opengroup.org/austin/. Last accessed:
Aug. 14, 2014.

[4] getresgid, getresuid, setresgid, setresuid – get or set
real, eﬀective and saved user or group ID. FreeBSD
System Calls Manual, Apr. 2001.

[5] setresuid, setresgid - set real, eﬀective and saved user
or group ID. Linux Programmer’s Manual, July 2007.

[6] Capabilities - overview of Linux capabilities. Linux

Programmer’s Manual, Aug. 2009.

[7] getresgid, getresuid, setresgid, setresuid - get or set

real, eﬀective and saved user or group ID. OpenBSD
Programmer’s Manual, Aug. 2013.

[8] A. N. M. Abdullah, B. Akbarpour, and S. Tahar.
Error Analysis and Veriﬁcation of an IEEE 802.11
OFDM Modem using Theorem Proving. In
Proceedings of the First Workshop on Formal Methods
for Wireless Systems (FMWS 2008), pages 3–30, 2009.

[9] M. Bishop. How to write a setuid program. USENIX

;login:, 12(1), Jan. 1987.

[10] M. Bishop. Computer Security — Art and Science.

Addison-Wesley, 2003.

[11] CERT. POS37-C. Ensure that privilege relinquishment

is successful. https://www.securecoding.cert.org/
confluence/display/seccode/POS37-C.+Ensure+
that+privilege+relinquishment+is+successful,
June 2013.

[12] H. Chen, D. Wagner, and D. Dean. Setuid

Demystiﬁed. In Proceedings of the 11th USENIX
Security Symposium, pages 171–190, Aug. 2002.

[13] D. Dean and A. J. Hu. Fixing Races for Fun and

Proﬁt: How to Use access(2). In Proceedings of the
13th USENIX Security Symposium, pages 195–206,
Aug. 2004.

[14] J. H. Saltzer and M. D. Schroeder. The Protection of
Information in Computer Systems. Proceedings of the
IEEE, 63(9):1278–1308, September 1975.

[15] IEEE and The Open Group. POSIX.1-2008, 2013.

Available from http:
//pubs.opengroup.org/onlinepubs/9699919799/.

[16] B. Jain, C.-C. Tsai, J. John, and D. E. Porter.
Practical Techniques to Obviate Setuid-to-root
Binaries. In Proceedings of the Ninth European
Conference on Computer Systems, EuroSys’14, pages
8:1–8:14, New York, NY, USA, 2014. ACM.

[17] D. M. Ritchie. Protection of data ﬁle contents. US

Patent 4135240, Jan. 1979.

[18] M. S. Dittmer and M. V. Tripunitara.

unix-process-identity. https:
//github.com/mdittmer/unix-process-identity,
2014.

[19] A. Souari, S. Tahar, and A. Gawanmeh. Formal error

analysis and veriﬁcation of a frequency domain
equalizer. In IEEE 10th International New Circuits
and Systems Conference (NEWCAS), pages 189–192,
2012.

[20] D. Tsafrir, D. D. Silva, and D. Wagner. Change

Process Identity. Available from https:
//code.google.com/p/change-process-identity/.
Last accessed May 2014.

[21] D. Tsafrir, D. D. Silva, and D. Wagner. The Murky
Issue of Changing Process Identity: Revising ”Setuid
Demystiﬁed”. USENIX ;login:, 33(3), June 2008.

1400APPENDIX
See our addendum [18] for a complete listing.

Table 4: Semantic deﬁnitions of syntactic elements in our ﬁrst-order logic formulas.

Syntactic Element(s) Element Type

Semantics

0

−1

arg ruid

arg euid

old ruid

old euid

old svuid

new ruid

new euid

new svuid

rtn

AP

Integer constant

Integer constant

The number 0; either the root/superuser UID or a function return vaule
that indicates success (depending on the context).

The number -1; a function return value that indicates failure or a “do
not change UID” input argument value.

Integer Variable (Int.
Var.)

The ﬁrst input argument to setreuid().

Int. Var.

Int. Var.

Int. Var.

Int. Var.

Int. Var.

Int. Var.

Int. Var.

Int. Var.

The second input argument to setreuid().

The real UID of the process before function invocation.

The eﬀective UID of the process before function invocation.

The saved UID of the process before function invocation.

The real UID of the process directly following function invocation.

The eﬀective UID of the process directly following function invocation.

The saved UID of the process directly following function invocation.

The return value of the invoked function.

Boolean
(Bool. Var.)

Variable

An implementation-dependent parameter. True if and only if the pro-
cess has appropriate privileges.

success

f ail

ruid success

Bool. Var.

Bool. Var.

Bool. Var.

euid success

Bool. Var.

svuid success

Bool. Var.

arg euid success

Bool. Var.

arg euid is valid

Bool. Var.

arg euid is invalid

Bool. Var.

einval

eperm
= (cid:54)=

Bool. Var.

Bool. Var.

Binary Predicates

RuidIsP ermitted(.)

Unary Predicate

Indicates whether or not the function succeeded with no errors.

Indicates whether or not the function failed due to an error.

Indicates correct behavior of the real UID ror setreuid() function
success.

Indicates correct behavior of the eﬀective UID for setreuid() function
success.

Indicates correct behavior of the saved UID for setreuid() function
success.

Relates arg euid is valid (see below) with AP and the case that the
euid argument is −1.
Indicates that the arg euid argument passed to setreuid() is permis-
sible for a process without appropriate privileges.

Indicates that the arg euid argument passed to setreuid() is not per-
missible for a process without appropriate privileges.

Indicates that an EINVAL error occurs in a call to setreuid().

Indicates that an EPERM error occurs in a call to setreuid().

True if and only if the value on the left and right are equal, or not equal
(respectively).

True if and only if its integer argument is a real UID that is “permitted
by the implementation”.

IsU ID(.)
¬ ∧ ∨ → ↔

Unary Predicate

True if and only if its integer argument is a valid UID in the system.

Boolean Connectives The Boolean connectives: negation, and, or, impliciation, equivalence

(respectively).

1401Table 5: Function deﬁnition for setreuid() from POSIX 1003.1 Base Speciﬁcation Issue 7 [15], and its
interpretation in ﬁrst-order logic. Some input argument names are changed for clarity, and formula numbers
are referenced in parentheses to indicate the passage(s) from which we derived a particular formula.

setreuid(arg ruid, arg euid)

DESCRIPTION
The setreuid() function shall set the real and
eﬀective user IDs of the current process to the
values speciﬁed by the arg ruid and arg euid
arguments. If arg ruid or arg euid is -1, the
corresponding eﬀective or real user ID of the
current process shall be left unchanged (9, 10).
A process with appropriate privileges can set
either ID to any value (17). An unprivileged
process can only set the eﬀective user ID if the
old euid argument is equal to either the real,
eﬀective, or saved user ID of the process (12,
13).
If the real user ID is being set (arg ruid is not
-1), or the eﬀective user ID is being set to a
value not equal to the real user ID, then the
saved set-user-ID of the current process shall
be set equal to the new eﬀective user ID (11).
It is unspeciﬁed whether a process without ap-
propriate privileges is permitted to change the
real user ID to match the current eﬀective user
ID or saved set-user-ID of the process.
RETURN VALUE
Upon successful completion, 0 shall be re-
turned (7). Otherwise, -1 shall be returned
and errno set to indicate the error (6, 8).
ERRORS
The setreuid() function shall fail if:
the arg ruid or
[EINVAL] The value of
arg euid argument is invalid or out-of-range
(15, 17, 18).
[EPERM] The current process does not have
appropriate privileges, and either an attempt
was made to change the eﬀective user ID to a
value other than the real user ID or the saved
set-user-ID or an attempt was made to change
the real user ID to a value not permitted by
the implementation (14, 16, 18).

(success ∧ ¬f ail) ∨ (f ail ∧ ¬success)

success ↔

f ail ↔

ruid success ↔

rtn = 0 ∧ ruid success ∧ euid success
∧ svuid success ∧ arg euid success

rtn = −1 ∧ new ruid = old ruid ∧
new euid = old euid ∧ new svuid = old svuid
(arg ruid = −1 ∧ new ruid = old ruid)
∨ (arg ruid (cid:54)= −1 ∧ new ruid = arg ruid)

euid success ↔ (arg euid = −1 ∧ new euid = old euid)

∨ (arg euid (cid:54)= −1 ∧ new euid = arg euid)

svuid success ↔

(new svuid = arg euid) ←
(arg ruid (cid:54)= −1 ∨
(arg euid (cid:54)= −1 ∧ arg euid (cid:54)= old ruid))

arg euid success ↔

arg euid is valid ←
(¬AP ∧ arg euid (cid:54)= −1)

(6)

(7)

(8)

(9)

(10)

(11)

(12)

arg euid is valid ↔ arg euid = old ruid ∨ arg euid = old euid (13)

∨ arg euid = old svuid

arg euid is invalid ↔ ¬(arg euid = −1 ∨ arg euid = old ruid (14)

∨ arg euid = old svuid)

einval ↔

¬((arg ruid = −1 ∨ IsU ID(arg ruid))
∧ (arg euid = −1 ∨ IsU ID(arg euid)))

(15)

eperm ↔ ¬AP ∧

(arg euid is invalid ∨ ¬RuidIsP ermitted(arg ruid))

(16)

AP → (success ∨ einval)
(eperm ∨ einval) ↔ f ail

(17)

(18)

1402