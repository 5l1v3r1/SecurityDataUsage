A Unilateral-to-Mutual Authentication Compiler for Key
Exchange (with Applications to Client Authentication in

TLS 1.3) ∗

†

Hugo Krawczyk
IBM Research

ABSTRACT
We study the question of how to build “compilers” that
transform a unilaterally authenticated (UA) key-exchange
protocol into a mutually-authenticated (MA) one. We present
a simple and eﬃcient compiler and characterize the UA pro-
tocols that the compiler upgrades to the MA model, showing
this to include a large and important class of UA protocols.
The question, while natural, has not been studied widely.
Our work is motivated in part by the ongoing work on the
design of TLS 1.3, speciﬁcally the design of the client au-
thentication mechanisms including the challenging case of
post-handshake authentication. Our approach supports the
analysis of these mechanisms in a general and modular way,
in particular aided by the notion of “functional security” that
we introduce as a generalization of key exchange models and
which may be of independent interest.

1.

INTRODUCTION

A natural question in the area of key-exchange (KE) pro-
tocols is how to transform a given KE protocol that is se-
cure in the unilateral-authentication (UA) setting (where
only one of the parties authenticates and the other remains
anonymous) into a secure mutual-authentication (MA) pro-
tocol. Somewhat surprisingly this question has not received
much attention in the complexity-based KE literature, in
part since much of the work in this area has focused on the
mutual authentication case. In practice, however, the most
widely used KE protocol, TLS, is centered around unilateral
(server-only) authentication, with optional upgrade to mu-
tual authentication. Namely, one starts from a core protocol
where only the server authenticates and then extends it with
an optional mechanism for client authentication.

In this work we investigate the above question in the con-
text of complexity-theoretic models of KE, striving for re-
sults that are general as well as practically relevant to real-

∗Full version (includes proofs): eprint.iacr.org/2016/711
†Email: hugo@ee.technion.ac.il.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’16, October 24–28, 2016, Vienna, Austria.
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978325

world protocols, in particular to the ongoing work on the
design of TLS 1.3 [33] which provides particular motiva-
tion for this work. We think of this problem as developing
compilers that extend secure unilateral key-exchange proto-
cols into secure mutual key-exchange protocols. We focus
on signature-based compilers, namely the case in which the
second party to authenticate - which we refer to as the client
- uses a digital signature as the means for public-key for au-
thentication (even though our approach can potentially be
extended to other forms of authentication).

The SIGMAC Compiler. Our compiler is simple: To
upgrade a unilateral protocol Π1 into a mutually authenti-
cated Π2, upon completion of Π1 the client sends a single
message comprised of: (i) the client’s signature on a por-
tion of the Π1’s transcript; and (ii) a MAC value computed
on the client and server’s identities with a MAC key com-
puted by Π1. The intuition of the design is simple too: First
note that anyone can sign the transcript, hence just a sig-
nature by the client on the transcript is not suﬃcient. Just
MACing the identities is clearly not suﬃcient either since
any party that participated in the unilateral protocol can
compute the MAC on any identities. Yet the combination
of signature and MAC ensures a binding between an iden-
tity and the knowledge of a key (computed in the unilateral
protocol). We call the compiler SIGMAC for SIGnature and
MAc Compiler, and also since it is reminiscent of the SIGMA
protocol [24].

While intuitively appealing, proving the compiler, namely,
showing that it can upgrade a secure unilateral protocol into
a secure mutual one turns out to be non-trivial, in particu-
lar regarding what information needs to be covered by the
signature. One can show examples, even in natural and
practical settings, where even signing the whole transcript
is not enough to ensure client authentication. Fortunately,
we show that the compiler works for important classes of
protocols, including any protocol that derives its session key
from a Diﬃe-Hellman exchange. A core issue is to character-
ize what needs to be included under the signature. For this,
we ﬁnd a general suﬃcient condition (through a notion we
call transport replication security, abbreviated as “treplica-
tion security”) that if satisﬁed by a unilateral KE protocol
Π, then applying the SIGMAC compiler to Π results in a
provably secure mutually authenticated KE protocol. We
then show extensive classes of unilateral protocols to pos-
sess this property, including KE mechanisms used in TLS
1.3.

By characterizing the minimal amount of information to
be included under the client’s signature, we achieve more

1438general results that not only apply to a wider class of pro-
tocols but also allow to remove from the signature any in-
formation that the client may not want to sign with a non-
repudiable signature. In particular, signing the server’s iden-
tity leaves a transferable proof that the client communicated
with the speciﬁc server. While full deniability of commu-
nication is hard to achieve against a malicious server [32],
an explicit signature on the server’s identity fails deniabil-
ity even with a passive (or “honest-but-curious”) server. We
show that signing the server’s identity can be safely omitted.
On the other hand, we stress that if the protocol contains
speciﬁc information that needs explicit authentication, e.g.,
the negotiation of security properties, these can and must
be included under the signature even if these elements are
not essential for the correct functioning of SIGMAC.

Finally, we comment on the use of a MAC function in
the SIGMAC compiler. The essential observation (see Sec-
tion 3.1) is that even if the client’s signature covers both
server’s and client’s identities, omitting the MAC - in par-
ticular, the MACed client identity - voids the ability of the
compiler to produce a mutually authenticated protocol. As
we note below, the use of a MAC function ﬁts particularly
well with TLS and its Finished message.

TLS 1.3: Application and Motivation. While the
main results in this paper are of general applicability and in-
tended to generically lift unilateral authentication protocols
into mutual authentication ones, one timely motivation and
application of this work is the analysis of TLS 1.3 [33]. The
TLS key exchange (or handshake) protocol in the current
and prior versions is built as a server-only authentication
protocol with optional extension to client authentication.
This approach calls exactly for a unilateral-to-mutual com-
piler as studied here.
In particular, the speciﬁc SIGMAC
compiler captures the type of mechanism used in TLS which
is based on the combination of a signature and a MAC (the
latter referred to as the client’s Finished message in TLS).
A challenging aspect of the new TLS 1.3 design is that
the protocol allows for post-handshake client authentication,
namely, a setting where a session key, authenticated by the
server only, is used to protect TLS data (record layer) and
only later is the client authentication extension applied. This
raises the question of what’s the value of this late authen-
tication; can the exchanged data be considered as mutually
authenticated upon this late client authentication? Fortu-
nately, our compiler approach turns out to be particularly
useful for analyzing this setting. It allows us to show that
upon client authentication and successful veriﬁcation by the
server, the data exchanged and protected up to this point
(as well as subsequent data) enjoys mutual authentication
security in the sense of “secure channels”. That is, it is guar-
anteed that only the parties that passed authentication (the
named server and client) are those generating the informa-
tion and being able to decrypt it. Of course, the server
obtains this assurance for past data only a-posteriori, i.e.,
only after verifying client authentication. Other questions
our methodology helps addressing regard the eﬀect of late
authentication on keys derived prior to the authentication
(e.g., a “resumption key”) or the validity of using a session
key to encrypt the very messages that carry client authen-
tication (see Section 6).1

1An immediate conclusion from these results is that it is not
necessary to introduce a dedicated key for encrypting post-

In all, our results are relevant to the analysis of client au-
thentication for the PFS modes of TLS 1.3, namely, 1-RTT
and PSK, and for PSK without PFS (hence, also for re-
sumption mode). This includes the cases of post-handshake
authentication and the use of the session key (or application
key) for encrypting the client authentication message.

An important tool for analyzing the above complex ques-
tions is our “functional” generalization of the key exchange
model from [9] which may be of independent interest.
It
provides an abstraction that frees the analysis from spe-
ciﬁc model and functionality details while at the same time
adding generality. For example, one can use this abstraction
to reason about whether a session key used to protect key
exchange messages may still be secure for another purpose
(say, to derive other keys) or whether a late client authen-
tication implies authentication of keys derived prior to the
authentication (e.g., a resumption key in TLS 1.3).
Final note: Familiarity with TLS 1.3 is not essential for un-
derstanding the results in this paper that, while applicable
and motivated by the TLS 1.3 design, are more general and
emphasize the conceptual aspects rather than the details of
a speciﬁc protocol. Even in the context of the ongoing speci-
ﬁcation of TLS 1.3, generality is a beneﬁt for informing basic
aspects of the design (such as the complex issues related to
late client authentication). At the same time, we stress that
a full analysis of TLS 1.3 is well beyond the scope of this
work.

Related Work. The literature on key-exchange protocols
is extensive with many diﬀerent models and many analyzed
protocols. Yet, the number of papers dealing with unilat-
eral authentication is relatively small. In particular, the ba-
sic earlier models, such as those of Bellare-Rogaway [1] and
Canetti-Krawczyk (CK) [9], do not treat it. One exception
is the work by Shoup [34] that deals with “anonymous pro-
tocols” explicitly. Halevi and Krawczyk [17] treat unilateral
security in the context of password protocols. Our treat-
ment is based on the CK model which we specialize to the
unilateral case with minimal changes following the approach
of [26, 25]. More recently, and motivated by the increased
interest in analyzing TLS, several papers study unilateral
authentication. Particularly, the works of Maurer et. al [29]
and Goldberg et al. [16] center on this model but do not deal
with the question of building generic transformations from
unilateral to mutual authentication.

Several works have presented authentication compilers for
unauthenticated key-exchange protocols including [2, 9] and
[19]. Authenticators from [2, 9] can be applied to upgrade
unilateral authentication (UA) to mutual authentication (MA)
but since authenticators are applied separately to each UA
protocol message they result in added (and possibly inter-
leaved) interaction, hence necessitating of changes in the UA
part of the protocol (rather than acting as an extension).
The compilers from [19] are intended to lift unauthenticated
protocols to mutually authenticated ones, but a closer look
reveals that they do not achieve this goal except if identi-
ties are somehow included under their signatures and MACs.
Even if ﬁxed, applying such compilers to a UA protocol is
“overkill” (in terms of communication and complexity, e.g.,
the compilers from [19] add 3-6 ﬂows to the protocol) and

handshake messages, a design choice being contemplated by
the TLS working group. Avoiding such dedicated key has
the major advantage of dispensing with cumbersome mech-
anisms involving trial decryption and the like.

1439applying “half” compiler (in one direction only) does not nec-
essarily work. For example, the SIGMA protocol from [24]
shows that if each party signs the transcript (but not the
identities) and also applies a MAC on its own identity then
the protocol is secure. However, if we used the same tech-
nique for one party only to upgrade a UA protocol to MA
we would end with an insecure protocol (see Section 3.1).
The recent work of Kohlweiss et al. [23] analyzes a UA-to-
MA transformation based on client passwords. We leave for
future work the analysis of other compilers (e.g., one where
both parties sign part of the transcript and only MAC their
own identity as in [24] or a variant of SIGMAC where the
client’s signature is replaced with KEM-based authentica-
tion).

Analyses of TLS that address unilateral authentication
include [30, 26, 21, 5, 22, 6, 3] and work directly relevant
to TLS 1.3 [28, 14, 12, 23, 25, 13, 11]. Of particular rel-
evance to the present paper is the work of Cremers et al.
[11] who present a detailed formal analysis of TLS 1.3 (draft
10) using the Tamarin prover.
It includes a formulation
of delayed client authentication whose analysis uncovered a
surprising attack on an early TLS 1.3 version of this mech-
anism which we use as a motivating example in Section 3.1.
Additional work related to post-authentication in diﬀerent
protocol settings is the design of “channel binding” proto-
cols whose track record of repeated breaks illustrates the
misleading intuition behind many of these techniques - see
Bhargavan et al. [7, 4]. It will be interesting to apply the
treplication-security notion as a formal basis for studying
channel binding and related notions. Finally, we point out
that our “functional” approach from Section 6.1 bears re-
semblance to Shoup’s model [34] and to the “suitable for”
notion from [8].

2. THE UA AND MA KE MODELS

This section presents an abridged description of the Canetti-

Krawczyk security model for key-exchange protocols [9, 10]
which serves as the basis for the formal security treatment
in this paper. Please consult [9] for complete details.
2.1 Mutual Authentication (MA) KE Model

We start by presenting the original CK model for mutual
authenticated KE, and then specialize this model to the case
of unilateral authentication. For the purpose of this paper
we will refer to this model as MA (for mutual authentication)
and diﬀerentiate it from the unilateral authentication model
denoted UA.

A key-exchange (KE) protocol is run in a network of in-
terconnected parties (all of which, including adversaries, are
modeled as probabilistic polynomial-time machines) where
each party can be activated to run an instance of the pro-
tocol called a session. Within a session a party can be ac-
tivated to initiate the session or to respond to an incoming
message. As a result of these activations, and according
to the speciﬁcation of the protocol, the party creates and
maintains a session state, generates outgoing messages, and
eventually completes the session by outputting a session key
sk and erasing the session state. A session may not com-
plete (e.g., if authentication fails) in which case it is aborted
without generating a session key (output sk =⊥). A KE
session is associated with its owner (the party at which the
session exists), a peer (the party with which the session key
is intended to be established), and a session identiﬁer, de-

noted sid. A KE protocol deﬁnes the contents of sid, typi-
cally including nonces and other transcript information. We
name sessions by their owner and sid, and if the session peer
is identiﬁed then also by the peer identity. For example,
(S, sid) for a session at party S or (S, C, sid) if the peer to
the session is identiﬁed as C. It is assumed (and enforced
by the protocol) that any two sessions at the same (honest)
party have diﬀerent identiﬁers.

Credentials. We consider the public key setting where
parties possess public keys of their choice and parties can
verify the authentic binding between identities and public
keys, be it either a certiﬁcation authority (CA) or other
means such as out-of-band distribution. We also consider
the “pre-shared key setting” where pairs of parties share a
secret symmetric key that they use for authentication.

The attacker, denoted A, is an ac-
Attacker model.
tive “man-in-the-middle” adversary with full control of the
communication links between parties. A can intercept and
modify messages sent over these links, it can delay or pre-
vent their delivery, inject its own messages, interleave mes-
sages from diﬀerent sessions, etc. (Formally, it is A to whom
parties hand their outgoing messages for delivery.) A also
schedules all session activations and session-message deliv-
ery.
the attacker is allowed access to secret
information via the following attacks:

In addition,

• A Reveal query can be performed against an individ-
ual session after completion and the result is that the
attacker learns the corresponding session key sk.

• A Corrupt against a party means that the attacker
learns the long-term secret of that party; in addition,
from the moment a party is corrupted all its actions
may be controlled by the attacker. Non-corrupted par-
ties are referred to as uncorrupted or honest.

For simplicity, in the current presentation we do not consider
the CK StateReveal query.

Basic security (mutual authentication).
To deﬁne
security, we establish a notion of matching deﬁned via session
identiﬁers. If session (C, S, sid) completes at party C, then
session (S, C, sid), if it exists at S and completes, is said to be
matching to (C, S, sid) (note the correspondence of peers and
equality of sid and that only complete session have matching
sessions).

Sessions against which any one of the attacks Reveal or
Corrupt is performed (including sessions compromised via
party corruption) are called exposed. A session is called fresh
if it is complete and not exposed, and its matching session
(if it exists) is also not exposed.
The security of session keys generated in fresh sessions is
captured via the inability of the attacker A to distinguish
the session key of a test session, chosen by A among all
fresh sessions in the protocol, from a random value. This is
captured via a Test query. This query may only be asked
once during the security game. It sets K0 := sk (or random
if sk =⊥) as the real session key, and sets K1 ←r {0, 1}λ.
Then, it picks b ←r {0, 1} and returns Kb. The attacker
can continue with the regular actions against the protocol
also after the Test query; at the end of its run A outputs a
bit b(cid:48), which is meant as a guess for the value of b.
attackers A running against π it holds:

A key-exchange protocol π is secure if for polynomial-time

1440SIGMAC applied to UA protocol Π1 uses the following components:

• A key derivation function KDF applied to session keys output by Π1 for producing two keys Ka and Ks (this can be as
simple as computing Ka = fK (0) and Ks = fK (1) where f is a PRF, or any other derivation of mutually pseudorandom
values Ka, Ks).

• A signature algorithm and a MAC algorithm (with the usual chosen message security requirements for both).
• A value sid∗ deﬁned for each session in Π1 and consisting of the concatenation of the session id sid and a subset of

transcript information, called a transcript core, speciﬁcally deﬁned for each protocol Π1 (see Section 4).

• Identities and keys for clients: Clients are anonymous in Π1, but in Π2 they have identities and signature keys whose

public keys other parties can obtain and validate. Servers have same identities and keys as in Π1.

MA protocol Π2 is deﬁned identically to Π1 except for the following extension:

• When a client C completes a session (C, S, sid) in Π1 with peer S and outputs a session key K, it performs the following
operations in Π2.
It derives keys Ka and Ks from K using KDF; sends a message, denoted CSM, consisting of a
signature on the value sid∗ and a MAC value, MACKa (C, S), on the identities C and S; it erases Ka and completes
session (C, S, sid) in Π2 with session key Ks.
• When a server S would establish a session (S, sid) with session key K according to Π1, in Π2 it does not complete the
session but computes K and keeps it in the session’s state. When a CSM message (allegedly) from client C is delivered
to a session (S, sid), S checks that a key K was previously computed for this session and if so it derives keys Ka and Ks
form K using KDF. It then checks that the incoming signature is valid (under the public key of C) and that it covers
the appropriate value sid∗ (including the session id sid). Finally, it veriﬁes that the MAC computed with key Ka covers
the client identity C and its own identity S. If all checks succeed, S completes session (S, C, sid) with session key Ks.

Figure 1: The SIGMAC Compiler.

1. If two uncorrupted parties complete matching sessions
in a run of protocol π under attacker A then they out-
put the same key (except for a negligible probability).

2. The probability that A wins the Test experiment, namely,

it outputs a correct guess b = b(cid:48) is at most 1/2 plus a
negligible fraction.2

We note that this model is general enough to capture pro-
tocols with implicit or explicit authentication and with and
without key conﬁrmation (or liveness). This is important
since it makes our results more general, showing that our
compiler applies to a UA protocol with any of the above
characteristics.

A key-exchange protocol is said to achieve perfect forward
secrecy (PFS) if it satisﬁes the above deﬁnition when relaxing
the notion of fresh sessions to allow a Corrupt query against
the owner of the session but only upon completion of the
session.
2.2 Unilateral Authentication (UA) KE Model
The model as described above is intended to capture pro-
tocols where both peers authenticate to each other. Here
we specialize this model to the case of unilateral authenti-
cation (UA), namely, when only one party authenticates to
its peer (but the second party remains “anonymous”). The
treatment is similar to [25].

The unilateral setting is best described by client-server
terminology. We denote by C, S the client-server parties
to the protocol as well as their identities, and refer to the
authenticating party as the server. In the public key setting
servers have public keys and in the case of a server and client
sharing a symmetric key (the pre-shared key setting) we
assume that the client associates the key to a server identity
but not (necessarily) the other way. Sessions at a client are
denoted as triples (C, S, sid) as in the regular MA model but

2We use asymptotic, polynomial-time, terminology through-
out the paper as it simpliﬁes presentation. Moving to a con-
crete security setting is mostly straightforward.

sessions at servers do not have a named peer hence they are
denoted (S, sid).

The essential characteristic of the UA model is that only
(fresh) client sessions are allowed as test sessions.3 Thus,
matching is deﬁned only for client sessions, namely, if session
(C, S, sid) exists and completes, and session (S, sid) exists
and completes then (S, sid) is called a matching session to
(C, S, sid).

3. THE SIGMAC COMPILER

We present our signature-based compiler that we call SIG-
MAC and which augments a UA-secure protocol Π1 into a
MA-secure protocol Π2. Roughly, protocol Π2 is obtained
via the SIGMAC compiler by adding to Π1 a single message
sent from client C to server S upon completion of a session in
Π1, where the message, denoted CSM (for “client sign-and-
mac”), comprises a signature of C and a MAC (with a key
derived from Π1’s session key). The signature is applied to
a value sid∗ deﬁned for Π1 while the MAC is applied on the
identities of C and S. The compiler is presented in Figure 1.
We stress that the value sid∗ plays an essential role in the
security of SIGMAC and its requirements are presented in
detail in Section 4 via the notions of a transcript core and
treplication security. We simplify some of our treatment
by assuming that the session identiﬁers sid in protocol Π1
include unique random nonces contributed by C and S.

Another simpliﬁcation in our treatment is that we assume
that the signature keys used by clients for the SIGMAC
signature are not used for other purposes or as part of pro-
tocol Π1. This limitation is not essential as long as diﬀerent
uses are properly insulated via domain separation or similar
methods.

3Restricting test sessions to client sessions only reﬂects the
fact that there is no requirement on the security of session
keys at a server as these may have the attacker as the uniden-
tiﬁed peer. One could allow to also test server sessions that
have a matching fresh client session, but this would be equiv-
alent to our simpler deﬁnition.

1441More generally, we require that no two sessions at a party
will have the same sid (except for negligible probability);
also, we assume that sid∗ includes a fresh session-speciﬁc
value from S (needed, in particular, against replay attacks).
Note on preserving the session key from Π1. The above spec-
iﬁcation of SIGMAC deﬁnes the keys Ka, Ks used by Π2 as
derived from the session key K output by Π1. Alternatively,
one can specify that Π1 outputs Ka, Ks, where Ks serves as
the session key in both Π1 and Π2 while Ka is only used in
Π2 as a MAC key. We chose the former approach as it allows
us to keep Π1 unmodiﬁed and is somewhat more convenient
in the formal treatment. On the other hand, if one requires
that Π1 and Π2 use the exact same session key, one needs
to accommodate the generation of key Ka already as part
of Π1 (this would be the case in TLS 1.3).
Note on (not) signing the server’s identity.
If one wants
to provide some deniability against a passive adversary as
discussed in the introduction, one should avoid entering the
identity of S into the signature (i.e., into sid∗).
On (hashing) the identities included under SIGMAC’s
MAC. The identities C and S included under the MAC
computation in SIGMAC can have diﬀerent forms, e.g., a
subject name in a public key certiﬁcate, a whole certiﬁcate,
an email address, etc. However, we note that an identity
of a party X can be replaced, for the sake of including it
under the SIGMAC MAC, by H(X) if H is a collision re-
sistant function (this is similar to the use of hash functions
for generating inputs to digital signatures). Moreover, hash-
ing X with additional information is also acceptable as long
as the parsing of the input to the hash function is deﬁned
as to uniquely determine the identity included in the hash.
Such hashing of identities is used in many protocols includ-
ing TLS. As a subtle example, resumption mode of TLS 1.3,
replaces the server’s identity included in the client’s Finished
message (that implements the SIGMAC’s MAC functional-
ity) with a unique value, resumption_context, computed as
a hash of the server’s identity and carried from a prior ex-
change between this client and server. For this to be secure
one has to assume that the function used to compute re-
sumption_context is collision resistant. In the case of TLS
1.3 this function is based on HKDF-Expand which can be
shown to be collision resistant if the underlying hash is col-
lision resistant. We stress that it is imperative in all uses of
hashed identities that the output from the hash function not
be truncated in a way that weakens the collision resistance
property.
3.1 Rationale and examples

As explained in the introduction, the intuition behind
SIGMAC is that the matching of the same client identity
as the signer as well as under the MAC creates the needed
binding between the client and the session key. Adding
the server’s identity to the MAC is needed to prevent UKS
attacks (see below), namely, ensuring the server that the
client’s view of the peer is correct. Alternatively, one can
include the server’s identity under the signature which raises
some privacy issues as discussed earlier.

The actual considerations in analyzing the compiler are
more subtle particularly with respect to what needs to be
covered by the signature. In some cases, even covering the
whole transcript is insuﬃcient to ensure mutual authenti-
cation via SIGMAC while in other cases covering part of
the transcript is enough. We strive to identify the essential

parts of a transcript that need to be signed (this adds to the
generality of the compiler and to our understanding of this
mechanism, and can help achieving some level of deniabil-
ity).

We illustrate some of the subtleties through some impor-
tant examples serving as motivation for the notion of tran-
script replication attacks introduced in the next section and
central to our analysis (and with direct implications to the
security of client authentication in TLS 1.3).

MACing the server identity S. We show a UA proto-
col that when upgraded to MA via SIGMAC but without
including the server’s identity under the client’s MAC, re-
sults in a MA protocol that is open to a UKS attack (the
necessity of including C under the MAC is more obvious
since anyone can sign the transcript hence such a signature
has no binding to the UA run). The UA protocol is a simple
server-authenticated DH exchange where the client sends a
DH value gx to which the server responds with gy and a sig-
nature on gx and gy. The session key K is derived from gxy.
If we extend this to a MA protocol via SIGMAC but remov-
ing S from the MAC, namely, C sends M ACKa (C) and its
signature on both gx and gy (whose concatenation deﬁnes
sid), the resultant protocol is open to a UKS attack as fol-
lows. A malicious server S(cid:48) relays gy to C but signs it with
its own signature. When C responds with M ACKa (C), S(cid:48)
sends this message to S. In this case Ks is computed by both
C and S. But while S has C as the peer to the exchange, C
has S(cid:48) as the peer, hence resulting in a UKS attack.

Pre-shared key protocols and why sometimes even
signing the whole transcript is not enough. We show
an example of a UA protocol where applying the SIGMAC
compiler with the entire transcript under the client’s signa-
ture does not result in a MA-secure protocol. For this we
consider a UA-secure protocol Π1 where the client uses as
the server’s credentials the server’s identity and a symmetric
pre-shared key (PSK). We assume that this key, that might
have been previously shared by C with S through another
UA key exchange protocol, has been authenticated only by
S (as in the resumption mode of TLS 1.3). We deﬁne Π1 as
an implicitly-authenticated protocol where the parties just
exchange nonces (which form the whole transcript) and the
session key is derived by applying a PRF keyed with PSK
to the nonces. It is not hard to show that Π1 with sid set
to the concatenation of the nonces is UA-secure. Now, con-
sider the protocol Π2 resulting from applying SIGMAC to
Π1 where we set the transcript core included in sid∗ to the
entire transcript. Let S(cid:48) be an attacker that has a shared
key with C and one with S (the two keys may be random
and independent) and interacts as a MitM between C and
S, acting as the server with C and as a client with S. S(cid:48)
simply relays without modiﬁcation the nonces chosen by C
and S. In addition, S(cid:48) forwards C’s signature on sid∗ to S
but replaces the MAC generated by C with a MAC com-
puted by S(cid:48) on identities (C, S) using a MAC key derived
from the PSK that S(cid:48) shares with S. As a result S ends its
session with peer C but with a session key that is known
to S(cid:48)! Note that if we add explicit authentication to Π1 by
sending a MAC from the server to client (using a key derived
from the PSK) but this MAC is not included in sid∗ then
the above attack works as well. Moreover, as we will see in
Section 4.2, in some cases even including the server’s MAC
under the signature is still not enough to provide MA secu-

1442rity (in particular, this indicates that the source of problem
was not in the implicit authentication nature of Π1).

Interestingly, this attack scenario was discovered by the
Tamarin team [11] in their formal analysis of an early draft
of TLS 1.3, showing that this is not just an hypothetical
concern but something that can arise in practice.

SIGMAC security for DH-based protocols (and some
more subtleties). An important and extensive class of
protocols where SIGMAC can be applied to lift a protocol
from UA to MA are protocols that provide forward secrecy
by deriving the session key from a DH value gxy, where
gx, gy are exchanged between C and S and gy is authen-
ticated by S. We show in Section 4.1 that deﬁning sid∗ to
include both values gx, gy is suﬃcient for SIGMAC to ensure
MA security.

As yet another interesting subtlety regarding SIGMAC,
we can show that without including gy under the client’s
signature, MA-security is not guaranteed (this is somewhat
counter-intuitive as one could expect that signing the client’s
message, with some freshness information from the server,
would suﬃce). For this we consider a simple UA protocol,
namely, a DH exchange between C and S where the server
signs the whole transcript. If gy is not included under the
client’s signature, an attacker S(cid:48) can change gy to g2y lead-
ing C to compute its MAC using a key derived from g2xy
while S derives the veriﬁcation key from gxy. Using ideas
similar to the example used in [26] to show the necessity of
the PRF-ODH assumption in the analysis of TLS 1.2, one
can build a KDF and MAC so that the MAC computed on
(chosen) values C and S(cid:48) with a key derived from g2xy re-
sults in the same MAC tag as when computed on values C
and S with key derived from gxy. Also, the session key com-
puted through the KDF is the same when derived from gxy
and g2xy. This results in a UKS attack where both C and S
compute the same session key but while S binds it to peer
C, C binds it to peer S(cid:48) (which signed g2y). While clearly
requiring contrived MAC and KDF functions, this argument
shows that if one does not include gy in sid∗, the SIGMAC
compiler cannot be proved to work without assuming addi-
tional properties of the KDF and MAC functions.

4. TRANSCRIPT-REPLICATION (TREPLI-

CATION) SECURITY

As shown in Section 3.1, the information that needs to
be signed by the client in the SIGMAC compiler, namely
sid∗, plays an essential role in the security of the compiler.
The value sid∗ is comprised of the session id sid and a sub-
set of transcript elements as deﬁned next via the notion of
treplication security.

Definition 1

(Treplication security). We say that

a UA protocol Π is secure against transcript replication (trepli-
cation) attacks with respect to a transcript subset τ (called
a transcript core)4 if any eﬃcient UA-attacker S(cid:48) against Π
has only negligible probability to win the Test experiment on
a fresh session (S, sid) for which there is a session (C, S(cid:48), sid)
with same session identiﬁer sid and same transcript core τ
as (S, sid), and where C is a honest client.

4That is, we view the protocol transcript as an ordered set of
(possibly optional) elements and deﬁne the transcript core
as a speciﬁed subset or projection.

Note that while S(cid:48) is given the same capabilities of a UA at-
tacker and the same indistinguishability Test, the conditions
for the choice of the test session are very diﬀerent than in the
regular UA model (in particular, this is a server’s session,
not a client’s one). Essentially, the requirement is that if S(cid:48)
acts as a man-in-the-middle between honest parties C and S
but cannot change or choose the session id sid and transcript
core τ sent between C and S, then S’ cannot learn informa-
tion on the session key computed by S. This requirement
is incomparable to UA security, namely, it is not implied by
nor it implies UA security.

The importance of the treplication security notion is demon-

strated by Theorem 3 where we show that joint UA and
treplication security suﬃces for the successful use of the SIG-
MAC compiler. Here we prove some important classes of
UA protocols to be treplication-secure (with respect to spe-
ciﬁc deﬁned transcript cores), hence upgradeable to mutual
authentication via SIGMAC. These protocols include those
discussed in Section 3.1 and those with direct application
to TLS 1.3 client authentication (particularly to the PFS
modes of the protocol as well as the non-PFS PSK mode
which also functions as session resumption).
4.1 Treplication security of DH Protocols

In Section 3.1 we showed some of the subtleties arising in
proving treplication security of DH protocols. Here we show
how such security can be achieved. We consider three cases:
(i) plain DH where gxy is only used to derive the session
key; (ii) in addition to deriving the session key from gxy,
additional keys used during the key exchange protocol itself
are derived from gxy - however, we assume that the session
key is secure (indistinguishable from uniform) even if these
additional keys are provided to the attacker; (iii) the expo-
nent x (and/or y) is used for additional computation (not
just for computing gxy). We note that case (i), while be-
ing the simplest and more natural, is generally insuﬃcient
for addressing real-world protocols. Case (ii) is directly rele-
vant to TLS 1.3 in its 1-RTT mode and in the pre-shared key
mode with PFS (the additional gxy-derived keys are used for
handshake traﬃc protection). Case (iii) would show up in a
protocol like QUIC [27], or a similar extension to TLS 1.3,
where two DH keys involving gx are derived: an ephemeral
gxy as well as a key gxs that combines gx with a public key
gs of the server.

Lemma 2. Let Π be a UA-secure Diﬃe-Hellman protocol
of the above types over a group G. Then, under the DDH
assumption on G, Π is treplication-secure if one deﬁnes the
transcript core τ to include the session identiﬁer sid of Π as
well as the two DH values gx and gy.
4.2 Treplication security of PSK Protocols

Here we consider pre-shared key (PSK) key-exchange pro-
tocols, namely, protocols where the parties use as their cre-
dentials a symmetric key they previously shared by some
method (e.g., out-of-band or a previous key exchange exe-
cution). We are interested in protocols that are UA-secure,
hence we assume the shared key to have been authenticated
only by the server (TLS 1.3 resumption presents such a case).
PSK protocols that oﬀer forward secrecy (i.e., derive their
session key through a DH exchange) are treplication-secure
under the conditions demonstrated earlier. Thus, here we fo-
cus on UA PSK protocols without forward secrecy and inves-
tigate under which conditions they are treplication-secure.

1443We’ve seen in Section 3.1 that the basic implicitly-authenticated
PSK protocol where the parties exchange nonces and derive
a session key from their PSK and nonces (without further
authentication) cannot be made treplication-secure even if
the full transcript (the nonces in this case) is included in sid∗.
Thus we consider an extension of this protocol that is UA-
secure with explicit authentication where S sends a MAC
computed on the nonces with a MAC key derived from the
PSK (this MAC would correspond to the server’s Finished
message in TLS). For the moment we restrict the transcript
to only include the random nonces of C and S, denoted
nC , nS, and the server’s MAC. We refer to this protocol as
Basic-UA-PSK and deﬁne the whole transcript as the tran-
script core τ .

Interestingly, this protocol is not treplication-secure for
generic MAC functions. However, we can prove its security
under a mild assumption on MAC security. Please see full
version for the full treatment of treplication security of PSK
protocols.
4.3 One-pass (0-RTT) Protocols

TLS 1.3 supports a so-called 0-RTT handshake consisting
of a one-pass authenticated key-exchange protocol where au-
thentication is carried through the use of a pre-shared key
that client and server exchange in a previous regular hand-
shake, typically with server-only authentication. In partic-
ular, this mode is used to instantiate session resumption
in TLS 1.3. The 0-RTT handshake essentially consists of
the client sending a key identiﬁer (that allows the server
to identify or compute the pre-shared key K) and a nonce.
The session key (used to immediately encrypt client’s data)
is derived from a combination of the key K and the client’s
nonce. Note that there is no server’s nonce assumed in the
protocol which opens this mode to replay attacks. Here we
discuss how client authentication could be added to such a
mode, although TLS 1.3 does not currently support client
authentication for 0-RTT.

We ﬁrst note that one-pass protocols can be framed in the
CK model through an adaptation as presented in [18], and
the above nonce-based protocol can be proven to be UA-
secure in this model. Thus, we can apply SIGMAC to this
protocol MAC-ing the identities of C and S (in the case of
TLS 1.3, the MAC would be implemented via the client’s
Finished message that is part of the 0-RTT exchange) and
signing the client’s nonce (which acts as sid). Note, however,
that SIGMAC assumes a server’s nonce which is not present
here but this requirement can be relaxed if one accepts re-
play attacks in the model (as in [18]). More fundamentally,
the above one-pass protocol is not treplication secure for rea-
sons similar to (and more straightforward than) the inter-
active PSK case discussed in Section 3.1. Speciﬁcally, the
attacker S(cid:48) would establish separate pre-shared keys with
both C and S (with S(cid:48) acting as server and client, respec-
tively) and later run a 0-RTT handshake with both parties,
relaying the client-chosen nonce to S. Clearly, S(cid:48) learns the
key computed by S as it knows the pre-shared key used
by S, hence breaking treplication security.5 Unfortunately,
and in contrast to the interactive PSK case treated earlier,
this treplication insecurity cannot be ﬁxed without includ-
ing the server’s identity (or a value derived from it, such

5The attack is possible even if a nonce by S is involved and
may even work if the key identiﬁer is part of the transcript
core as long as S(cid:48) can choose the same key identiﬁer as S.

as resumption_context discussed before) in the transcript
core. Thus, client authentication for 0-RTT would need to
include the server’s identity (and nonce) under the client’s
signature. Fortunately, in the next section we show that
when the server’s identity is signed by C, SIGMAC ensures
MA security even if the base UA protocol is not treplication
secure.

5. PROOF OF THE SIGMAC COMPILER

We prove the security of the SIGMAC compiler deﬁned in
Section 3 for treplication-secure protocols. We assume the
MAC and signature functions used in SIGMAC to be secure
in the standard chosen-message unforgeability sense.

Theorem 3. Let Π1 be a secure unilaterally authenticated
KE protocol that is also treplication-secure with transcript
core τ and set sid∗ to the concatenation of the session id
sid and τ . Then protocol Π2 resulting from the application
of the SIGMAC compiler with this sid∗ is a secure mutually
authenticated KE protocol.

Before proving the theorem we recall some of the adver-
sarial actions in each model and how they diﬀer in the case
of Π1 and Π2.

• Party activation for session initiation and message re-
ceiving/sending: This is same in Π1 and Π2 except for
the CSM message sent by C upon receiving the last
message from S (in case C sends the last message in
Π1 then CSM is sent immediately after this last mes-
sage).

• Party corruption: In both cases this includes reveal-
ing to the attacker all secret material of the corrupted
party (and subsequent full control of that party by the
attacker). Note that in the case of Π2, client corrup-
tion includes revealing the signing key of C.

• Reveal queries: This can be applied to any completed
session (other than the test session) at a honest party
and returns the session key (note that the timing of
completion for S may be diﬀerent in Π1 and Π2).

• Session tests:

In Π1 session tests are only allowed
against (C, S, sid) while in Π2 they are also allowed
against (S, C, sid).
5.1 The simulator
For the proof of Theorem 3 we specify a simulator that
given an MA-attacker A2 against protocol Π2 it deﬁnes a
UA-attacker A1 against Π1 such that if Π2 wins a test ses-
sion in Π2 so does A1 in Π1. The simulator SIM acts as
the challenger (i.e., the orchestrator of the protocol run) for
a given MA-attacker A2 against protocol Π2 and uses A2
actions to implement the UA-attacker A1 against Π1. We
think of the parties running Π1 as real parties, with their
own secret keys, and those running Π2 as simulated by SIM
with the same keys as in Π1 except for clients’ signature keys
(that exist in Π2 but not in Π1). The latter are chosen by
SIM for honest clients in Π2 while public keys for corrupted
parties are chosen by the attacker.

SIM implements the CSM message in Π2 as follows. Upon
completion of a session (C, S, sid) by a client C in Π1, SIM
invokes A1 to run a reveal query on that session to obtain

1444the corresponding session key K. From it, SIM derives keys
Ka and Ks, and uses Ka and the signature key of C to com-
pute the CSM message that it hands to A2. Completion of
sessions by honest parties in Π2 is decided by SIM. In the
case of a client, a session is completed if and only if the cor-
responding session completes in Π1. Completion of a session
(S, C, sid) at a honest server in Π2 depends on receiving a
valid CSM message, namely with a valid signature on sid∗
and the MAC under Ka. If this message is not originated
with a honest client (e.g., it is sent by a corrupted client)
then SIM veriﬁes it by invoking A1 to reveal the correspond-
ing completed server’s session (S, sid) in Π1 and deriving Ka
from it. The validity of this action follows from Lemma 4
(c).
The actions of A1 as decided by SIM mostly mimic those
of A2 with some important diﬀerences in the handling of the
corrupt, reveal and test queries that we specify next. After
each action we argue informally the validity of the action
(showing that the attackers’ actions and views are consistent
with the protocol and the attack model). The formal proof
of validity follows from Lemma 4 below. Throughout, we
say that keys Ka, Ks in a session in Π2 are consistent with a
session key K in Π1 if Ka, Ks are derived from K using the
KDF function.

1. When A2 corrupts a party, SIM invokes A1 to do the
same. A2 receives the secret information from this
party as received by A1 and, in the case of clients, it
receives from SIM the party’s signature key.

2. When A2 reveals a session (C, S, sid) at honest client
C in Π2, SIM invokes A1 to reveal (C, S, sid) in Π1;
A1 is handed the session key K from Π1 while A2 is
handed the derived session key Ks from Π2.

• Validity (Lemma 4 (b)): We use the fact that
these two sessions exist and complete together
and have consistent keys.

3. When A2 reveals a session (S, C, sid) at honest server
S in Π2, SIM invokes A1 to reveal session (S, sid) in
Π1; A1 is handed session key K while A2 is handed
the derived key Ks.

• Validity (Lemma 4 (c)): We use the fact that if S
is honest and session (S, C, sid) completes in Π2
then session (S, sid) exists and completed in Π1,
and the two sessions have consistent keys.

4. The processing of the Test query and test sessions is
handled by SIM as follows. At the onset of the protocol
run, SIM selects a random session, called the guess ses-
sion, from all sessions to be created during the run of
protocol Π2 under A2 (this assumes an a-priori bound
on the number of sessions to be created by A2).
If
at any point, A2 issues an action that disqualiﬁes the
guess session as a test session, SIM instructs A1 to
output a random bit b and aborts. The guess session
may be at a client or server:

(a) If the session is at a client, call it (C, S, sid), then
as soon as A2 delivers the last incoming message
to this session (from server S), SIM invokes A1
to deliver this last message (which, if the guess
session is correct, results in C completing) and to
issue a Test query on (C, S, sid) in Π1.

(b) If the session is at a server, call it (S, C, sid), then
as soon as A2 delivers the last message from S
to session (C, S, sid), SIM invokes A1 to deliver
this last message and to issue a Test query on
(C, S, sid) in Π1.

In both cases SIM learns from A1 the value of the
real-or-random key K returned by the Test query in
Π1. SIM derives from K keys Ka and Ks and uses
Ka to compute the outgoing CSM message from C in
Π2 and for checking the validity of a CSM message
delivered by A2 to session (S, C, sid). When A2 issues
a Test query against the guess session (at C or S), SIM
provides Ks as the answer to that query.

• Validity: We will show that the test sessions in-
voked by A1 are valid test sessions under A1’s
run and that Ks is real if K is real and (pseudo)
random otherwise. See Lemma 4 (f).

5. When A2 stops its run with an output bit b, SIM in-

structs A1 to stop with the same bit.

• We need to show that A1 wins whenever A2 wins,
hence proving that the advantage of A2 against
Π2 is bounded (up to a polynomial factor induced
by the probability of a correct test session guess)
by the advantage of A1 against Π1.

5.2 Validity of SIM’s actions
The proof of Theorem 3 uses the following properties of
the simulator’s actions and those induced on attacker A1,
in particular showing the validity of these actions in the
corresponding models.

Lemma 4. The following properties hold based on the sim-

ulation actions.
(a) Π1 and Π2 as run under A1 and A2, respectively, have
the same set of parties, including the same honest and
same corrupted parties.

(b) If C is honest, then when a session (C, S, sid) com-
pletes in Π2, a session (C, S, sid) exists and has com-
pleted in Π1; in particular, the two sessions have con-
sistent session keys.

(c) If S is honest, if a session (S, C, sid) completes in Π2
then session (S, sid) exists and has completed in Π1;
in particular, the two sessions have consistent session
keys.

(d) If (C, S, sid) is a valid test session chosen by A2 in
Π2 then, except for negligible probability, (C, S, sid) is
fresh in Π1 and (by part (b)) the two sessions have
consistent session keys.

(e) Assuming Π1 is treplication-secure, if session (S, C, sid)
is a valid test session chosen by A2 in Π2, then, ex-
cept for negligible probability, session (C, S, sid) exists,
completes and is fresh in Π1 and both sessions have
consistent session keys.

(f ) If the test session chosen by A2 in Π2 is a valid test
session and SIM guessed this session correctly then,
except for negligible probability, the test session chosen

1445by SIM is a valid test session under A1’s run, and if
the key K returned to A1 is real (resp. random) then
Ks is real (resp. pseudo-random).

The next two lemmas, needed to complete the proof of
Lemma 4 (parts (d) and (e)) and Theorem 3, show, respec-
tively, the need to include the identities C and S under the
CSM MAC.

Lemma 5. If C and S are honest, session (C, S, sid) is
complete and unrevealed in Π1, and session (S, sid) is com-
plete in Π1, then in Π2 either S does not complete session
sid or, if it does, it completes it as (S, C, sid) (except for a
negligible probability).

Lemma 6. If Π1 is treplication-secure and (S, C, sid) is
fresh in Π2 then, except for negligible probability, (C, S, sid)
exists and completes in Π2.
5.3 Proof of Theorem 3

Consider simulation executions where SIM does not abort
(i.e., SIM guesses correctly the test session) and in which the
negligible probability events from the proofs of Lemmas 5
and 6 do not happen.
In this case, Lemma 4 shows the
validity of the actions of both adversaries, A1 and A2, as
set by the simulator actions, and their consistency with the
UA and MA models, respectively. In particular, the views of
A1 and A2 under the simulated games are exactly as those
of a real run of protocols Π1 and Π2, respectively. Thus,
the winning probability of A2 is the same as in a real run of
protocol Π2 and by Lemma 4 (part f) A1 wins its test session
whenever A2 does. We conclude that the winning advantage
of A2 is upper bounded by that of A1. In all, we have that
if m is an upper bound on the number of sessions initiated
by A2, then the winning advantage of A2 against Π2 is at
most m times the winning advantage of A1 against Π1 plus
a negligible fraction. Hence, if any UA-attacker A1 against
Π1 has only negligible advantage, then so is the case for any
MA-attacker A2 against Π2. This completes the proof of
MA-security of the compiled protocol Π2.

Note on security quantiﬁcation. The proofs of Lem-
mas 5 and 6 show events where the selection of a test session
for A1 fails due to some adversarial action. The lemmas
show these events to have negligible probability. An exam-
ination of the proof shows this probability to be at most
2 · (n · sig + mac + kdf ) + U A + tr + nc where the  val-
ues denote the security of various elements in the protocol:
the unforgeability of the signature and MAC schemes used
in SIGMAC, the pseudorandomness of the KDF, the UA-
security of protocol Π1, and the treplication security of Π1
(these bounds represent the attackers’ advantage for a given
time bound); nc bounds the probability of nonce collision
among honest clients and n bounds the number of clients
(the latter is needed in the client’s signature-forging reduc-
tion for which one needs to guess the client in the test session
in order to embed the attacked signature key). The above
expression is further multiplied by factor m (denoting an
upper bound on the number of sessions established by ad-
versary A2 running against Π2) to account for the probabil-
ity 1/m that SIM does not abort its run, namely, it guesses
correctly the session that A2 will choose as its test session.6
6This may result in a m·n factor multiplying sig but in this
case one can set m to be the maximal number of sessions

Streamlining the reduction. The above bound contains
the additive term m · U A where U A bounds the advan-
It is likely
tage of the UA-attacker against protocol Π1.
that the bound U A resulting from the analysis of a partic-
ular protocol Π1 already contains a factor of m equal to the
number of sessions, in which case m · U A contains a factor
m2. The following analysis strategy avoids this unnecessary
squared degradation. We consider a “semi-adaptive” adver-
sarial model, for both the UA and MA settings, where the
attacker has to declare its choice of test session as soon as
the session is initiated. In this setting, SIM does not need
to guess A2’s test session but it rather learns the session
when A2 initiates (and declares) it. At this point, SIM in-
structs the semi-adaptive A1 to declare the choice of the
corresponding test session in Π1. Everything else stays the
same as in the current simulation and proof except that here
the reduction is between semi-adaptive UA and MA attack-
ers without incurring the loss of the m factor. This factor
only comes once through a generic reduction from a regular
(adaptive) attacker to a semi-adaptive one. In this generic
reduction the regular attacker acts semi-adaptive by choos-
ing the test session at random among all m sessions and
declaring it upon initiation - hence incurring a (one-time) m
factor advantage degradation.

Note on signing S and C.
Inspection of the proof of
Lemma 6 shows that if the server’s identity S is included
under sid∗, i.e., signed by the client, then there is no need to
include that identity under the MAC or to resort to trepli-
cation security. Yet, our results show that if signing this
identity is omitted (for privacy reasons or simply because
the identity is not part of the signed transcript - as in the
resumption mode of TLS 1.3) its inclusion under the MAC
is suﬃcient. As for the client’s identity, we note that includ-
ing this identity under the client’s signature but not under
a MAC would fail to provide MA security.

6. POST-HANDSHAKE AND ENCRYPTED

AUTHENTICATION

In this section we adapt the analysis of the SIGMAC com-
piler to some speciﬁc settings arising in the ongoing speciﬁ-
cation of TLS 1.3 [33]. We also introduce the functional CK
model which may be of independent interest.

The SIGMAC compiler as analyzed in previous sections
can be readily applied in the context of TLS 1.3 in the case
that the client sends its authentication message (the signa-
ture and Finished message, or CSM in our terminology7)
in the third handshake ﬂight, i.e., immediately upon ver-
iﬁcation of server authentication. However, TLS 1.3 also
includes some cases where the SIGMAC analysis from Sec-
tion 5 does not apply directly. We identify three such cases.
The ﬁrst considers the fact that TLS 1.3 always encrypts
the CSM message for reasons of identity protection. In the
regular handshake case, the encryption key, or “handshake
transport key (HTK)”, is derived from the same interme-
diate key from which Ka and Ks are derived, and by the
properties of the key derivation function HTK is (compu-
tationally) independent from Ka and Ks. Extending the

established by a single client rather than representing the
total number of sessions.
7We take the liberty of referring to the signature and MAC
combination used in TLS 1.3 as “the CSM message”.

1446SIGMAC proof for this case is immediate: the simulator de-
rives the HTK key from the UA session key K, as it does
with Ka and Ks, and uses it to encrypt/decrypt the CSM
message. Due to the independence of HTK from Ka and
Ks, the proof holds with minor adjustments.

In the second case the CSM message is also encrypted but
in this case the encryption uses the same key Ks that the
protocol outputs as the session key. This immediately vi-
olates key indistinguishability since by the time the client
establishes the session key (which is when the key can be
tested for indistinguishability), this key has been used al-
ready. We show (Section 6.2) how to adapt the analysis of
SIGMAC to this case, at the cost of reducing the security
guarantee. Rather than ensuring generic security of Ks (as
induced by the regular indistinguishability property of key-
exchange protocols), we show that Ks can be used as a key
to an authenticated encryption scheme for implementing se-
cure channels. Our analysis is general and can be applied
to diﬀerent modelings of secure channels (e.g.
[20, 15]) as
well as to other applications of the session key8 as long as
the security of such application is not voided by the use of
Ks for encrypting CSM. Our formalization introduces the
notion of functional tests (Section 6.1) that abstracts out
details of applications and implementations.

The third case is the so called “post-handshake client au-
thentication”. Here, the client authenticates with a CSM
message but only after the server and client have already
exchanged application data (i.e., record layer communica-
tion in the TLS context) protected with the session key
Ks. The encrypted data exchange starts after the parties
compute the session key but before the client authenticates.
This raises questions about the notion of security that can
be claimed and the level of protection provided to the ex-
changed data (to which we will refer as pre-authentication
data). One can see that since the handshake protocol with-
out client authentication provides unilateral authentication,
then the data gets the assurance of unilateral authentica-
tion (server authentication in the case of TLS). However,
the SIGMAC analysis from previous sections showing that
the CSM message upgrades the protocol to MA security does
not hold anymore once the session key Ks is used to protect
data before CSM is delivered and veriﬁed. Yet, we are able
to show (Section 6.3) that the CSM message does provide
mutual authentication of the exchanged data but only in
the sense of secure channels, and only after the CSM mes-
sage is veriﬁed by the server. Namely, the parties get the
guarantee (delayed for the server) that only the named party
that passed authentication can authenticate and decrypt the
exchanged information (including data sent before client au-
thentication). Here too, our treatment via functional tests
adds generality and allows us to abstract the details of the
secure channels modeling and implementation.

Finally, combining the last two cases one obtains secure
channels security for the case (also in TLS 1.3) where in ad-
dition to the exchange of pre-authentication data, the post-
handshake CSM message itself is encrypted with the session
key (Section 6.3.1).

8In the case of TLS 1.3, such applications may include the
derivation/update of keys or the issuing of resumption keys
via a New Session Ticket Message. Here the session key
can be the application key or other keys computed in the
protocol such as the exporter master secret.

Fortunately, we can address all these scenarios with sim-
ple adaptations of the analysis of the SIGMAC compiler. We
do so in the following subsections.
6.1 Functional Queries and Functional Tests
Since our goal is to show that the above authentication
variants are suﬃcient to ensure “secure channels” function-
ality, it is worth recalling how such functionality is modeled.
Take as example the ACCE model of Jager et al. [20] that
has been used to prove security of several variants of TLS
1.2. Such model extends the usual key exchange security
formalism with the ability of the attacker to run Encrypt
and Decrypt queries on messages of its choice where the
session key (or keys derived from it) serves as the authenti-
cated encryption key. In addition, to capture the inability
of the attacker to subvert the desired secure channels func-
tionality, the attacker is tested through a dedicated game
that replaces the standard indistinguishability test of key
exchange models. In the ACCE model this test is adapted
from the treatment of stateful authenticated encryption by
Paterson et al. [31]. Other secure channels models diﬀer in
their details and scope but they follow a similar approach.
To increase generality and simplicity, our treatment ab-
stracts out the details of implementation of secure channels,
framing the above model ingredients in an abstract way.
That is, we extend the capabilities of a key exchange at-
tacker with the ability to query abstract “functional queries”
on session keys and we replace the usual indistinguishability
test with an abstract “functional test” that is run on a session
chosen by the attacker (the “test session”) and where the in-
put to the test is the test session key. The only condition on
such a test is that if one replaces the input session key with a
random independent key, then the advantage of the attacker
in winning the test is negligible. The ACCE model is an in-
stantiation of this abstract framework where the functional
queries represent the Encrypt/Decrypt queries and the ses-
sion key experiment is modeled as a stateful authenticated
encryption test (note that this test has the required property
from a functional test, namely, if the authenticated encryp-
tion scheme is keyed with a random value then the attacker
has negligible advantage in winning the ACCE game). This
abstraction frees our analysis from dealing with speciﬁc de-
tails and models while at the same time adding generality.
For example, one can use this abstraction to reason about
whether a session key used to protect key exchange messages
may still be secure for another purpose (say, to derive other
keys) or whether a late client authentication implies authen-
tication of keys derived prior to the authentication (e.g., a
resumption key in TLS 1.3).

Functional family F . Let F be a parametrized family of
(possibly randomized) functions that accept a single input to
which we refer as a session key. Given a parameter p and a
session key k, fp denotes a member of F and fp(k) denotes
an output distribution (or, more commonly, it denotes a
speciﬁc value sampled from that distribution).

Functional queries and tests. We present a modiﬁcation
of the CK model of key exchange security [9] (which we
recalled in Section 2). The only changes to the model are as
follows (we refer by AF to the attacker in this setting):

• We add a new adversarial query type, called a func-
tional query FQuery, associated to a functional family

1447F . AF can issue FQuery against any session eligible
for a Reveal query and also against the test session. In
it, AF provides a session identiﬁer, a parameter p and
gets back fp(k) where fp is an element of F and k is
the session key of the named session.

• We change the test session experiment: A test session
can be chosen under the same rules as in the CK model
but the regular indistinguishability-based Test query is
replaced with a functional test FTest. This can be an
arbitrary test taking the form of an interactive game
between a challenger and attacker AF , where the chal-
lenger’s input is the test session key and a random bit
b, and the output of AF is a bit b(cid:48). We say that AF
wins if b = b(cid:48). The only condition on a functional test
is that if one replaces the input to the challenger with
a random independent key then the advantage of AF
in winning the game is negligible.

We allow the functional queries to use a shared state (for-
mally accommodated through the parameter p that can be
seen as a generalized second input to the function) and also
allow the functional test to share such state. This adds gen-
erality to our treatment and is needed, in particular, for the
formalization of stateful authenticated encryption as used in
the deﬁnition of ACCE security.

Functional CK model. The security deﬁnition in this
functional model remains the same as in the original CK
model (end of Section 2.1) except that the notion of winning
for the attacker changes from the indistinguishability Test
experiment to a given functional test FTest. We will refer to
this notion as Functional CK security and we will denote the
MA and UA variants by F-MA and F-UA (as in the regular
CK model of Section 2, the main diﬀerence between UA and
MA is that only clients have a deﬁned peer and only client
sessions can be chosen as test sessions).

Remark: For sessions other than the test session, the func-
tional queries seem redundant as the attacker can always
query these sessions via a SK reveal query and compute
the functional query by itself. However, note that informa-
tion learned via functional queries on a session can help the
attacker choose that session as the test session (running a
reveal query on a session would disqualify that session for
testing). Moreover, quantifying security via the number of
functional queries in an attack (e.g., number of encrypt and
decrypt queries) can be an important measure. On the other
hand, one may simplify the model by assuming that the at-
tacker chooses its test session at random (at the cost of a
number-of-sessions factor loss in the attacker’s advantage)
in which case functional queries are not needed, except for
the test session and as part of deﬁning a functional test.

Remark: We note that the above formalism via a bit-
guessing game can be generalized. First, one can replace
such a game with any experiment (not necessarily bit-guessing)
where the winning probability of AF on a run over a random
independent key is negligible. Second, it would be enough
to require that the diﬀerence between the success of the at-
tacker on a run over the real session key be negligibly higher
than on a run over a random key (even if the latter case
is not in itself negligible). Finally, note that the functional
approach can be applied to other key exchange models such
as the Bellare-Rogaway [1]; a notion similar to functional

queries was considered by Shoup [34]. One may also be able
to use the ”suitable for” notion from Brzuska et al. [8] as a
replacement for our functional tests. The two notions dif-
fer in their approaches but have a motivation in common,
namely, replacing pure key indistinguishability with more
limited functionalities where the use of the session key dur-
ing the KE process does not void the security of the task at
hand.

Secure channels via functional security. As discussed
above, we are interested in freeing our results from the spe-
ciﬁc details of a secure channels model or its implementa-
tion. The idea is that any such formalism can be framed
via the above functional model. Speciﬁcally, when referring
to secure channels we will deﬁne two abstract functional
queries, Encrypt and Decrypt, and will assume a given func-
tional test. Encrypt and Decrypt will have the regular func-
tionality of encrypting and decrypting messages but their
implementation can take diﬀerent forms (e.g., they can be
deﬁned via general authenticated encryption or with a more
speciﬁc scheme, they can be stateless or stateful, apply to
full messages or fragments, etc.). The functional test can
also take diﬀerent forms, e.g. [20, 15]. For example, [20] de-
ﬁnes its model, ACCE security, through a semantic security
game that mimics the game used to deﬁne the security of the
underlying (stateful) authenticated encryption scheme [31]
and relies on the fact that no attacker can win the latter
game if the key in use is fresh and random. Our formalism
can represent such a model by instantiating the functional
test via this particular ACCE game.
6.2 SIGMAC with encrypted CSM

We consider a variant of the SIGMAC compiler in which
the CSM message is encrypted with the session key Ks from
the same session to which the CSM message belongs. We
show that any application whose security can be deﬁned via
a functional test as in Section 6.1, and where the encryption
and decryption of CSM are included in the functional queries
of the model, enjoys mutual authentication in the sense of
F-MA. As an application, instantiating our abstract formal-
ism with a secure channels model (e.g., [20, 15]), we get that
the session key validated via SIGMAC with encrypted CSM
implements secure channels with mutual authentication (it
is assumed that the secure channels mechanism enforces do-
main separation between the encryption of CSM and encryp-
tion of application data, for example as the ACCE model
does via stateful encryption).
(cid:48) be a protocol resulting from applying SIGMAC
with encrypted CSM to a UA-secure Π1 protocol. (It is pos-
sible to include further information under this encryption
such as the client’s identity or certiﬁcate to protect it from
eavesdroppers.) The encryption of CSM is generated by the
client and the corresponding decryption and veriﬁcation is
performed by the receiving server. We prove this modiﬁed
compiler following the original proof of Theorem 3 but we
replace the regular indistinguishability-based security test
with a functional test as deﬁned in Section 6.1; we also as-
sume Encrypt and Decrypt operations as part of the allowed
functional queries9. We prove:

Let Π2

9Note that the attacker does not provide the message CSM
for encryption, but rather the functional query is deﬁned as
the application of Encrypt to the value CSM generated by
the client and possibly unknown to the attacker.

1448Lemma 7. The SIGMAC compiler with message CSM en-
crypted under session key Ks and applied to a treplication-
secure UA-secure protocol (under the conditions of Theo-
rem 3) results in a F-MA-secure protocol where the session
indistinguishability test is replaced with a functional test (de-
ﬁned by the protocol) and the Encrypt and Decrypt operations
applied to CSM are considered as valid functional queries on
session key Ks.

Application to ACCE security. As previously stated
our functional security model allows us to frame secure chan-
nel formalisms. One speciﬁc instance is the ACCE model
from [20] that has been successfully applied to the analy-
sis of TLS protocols (but see the reﬁned deﬁnitions of [15]).
We omit the ACCE details here and informally claim the
following corollary. Please consult [20] for the model (in-
cluding a deﬁnition of pre-accept and post-accept phases),
the deﬁnition of the Encrypt and Decrypt operations (that
we represent as functional queries), and their security game
that instantiates our functional test.

Corollary 8

(informal). Let Π be a protocol result-
ing from the application of the SIGMAC compiler with en-
crypted CSM to a treplication-secure UA-secure protocol, and
let Encrypt and Decrypt denote a stateful encryption scheme
as considered by the ACCE model [20]. Consider protocol Π(cid:48)
that runs Π in the pre-accept phase of ACCE and uses the
resultant session key as the key for the Encrypt and Decrypt
operations in the post-accept phase as well as for the encryp-
tion of CSM 10. Then, Π(cid:48) is secure according to the (mutual
authentication) ACCE model.
6.3 Security under post-handshake authenti-

cation

Here we address the third case discussed in this section’s
introduction, namely, where data protected under the ses-
sion key is exchanged between server and client after the
server computed the session key but before the client sends
the CSM message. This case, known as “post-handshake
client authentication” in the context of TLS 1.3, requires
a weakening of the security guarantees as the early use of
the session key voids key indistinguishability. Clearly, since
the protocol is UA-secure even without the CSM message
then the data exchanged prior to the sending of CSM is
UA-secure. But what notion of security can one claim once
the client authenticates? Fortunately, using a simple adap-
tation of the proof of the SIGMAC compiler to the present
setting, we are able to show that the data exchanged before
the sending of CSM (as well as later data) can be considered
to be protected by mutually authenticated secure channels,
with the assurance for the server delayed until it veriﬁes the
client’s CSM message. We frame this result in our more
general functional setting (Section 6.1).

Let Π2 be a protocol resulting from applying SIGMAC
to a UA-secure protocol Π1, namely, Π2 consists of running
Π1 and adding to it the CSM message from client to server
with a deﬁned sid∗ value. Let Π2
(cid:48) be a modiﬁcation of Π2
where between the last message of Π1 and the CSM message
from the client, data (referred to as pre-authentication data)

10It is assumed that the Encrypt state is initialized and used
ﬁrst for encrypting the CSM message and then applied to
messages exchanged in the post-accept phase.

is exchanged encrypted under the session key Ks generated
at the end of the Π1 run. We frame this protocol in our
functional setting by modeling the encryption and decryp-
tion operations applied to the pre-authentication data with
abstract Encrypt and Decrypt functional queries.

We say that a functional test is consistent with a set of
functional queries if the advantage of any adversary to win
the test with a random key remains negligible even when
allowed to issue functional queries from this set.

Lemma 9. Given a treplication-secure UA protocol Π1 (i.e.,

one that satisﬁes the conditions of Theorem 3), Protocol Π2
as deﬁned above is F-MA-secure with respect to any func-
tional test consistent with the Encrypt and Decrypt functional
queries deﬁned by the protocol.

(cid:48)

Application to ACCE security. A corollary of this
lemma is that if we instantiate the functional test with a se-
curity experiment for a given “secure channels” model then
we obtain that the encrypted pre-authentication data at-
tains the same protection as guaranteed by the secure chan-
nels model. Illustrating this in the ACCE model [20] needs
some adjustment since ACCE separates key exchange (pre-
accept phase) and encrypted message exchange (post-accept
phase) while in our case these two are interleaved. What
we are really interested in is the security of the encrypted
message exchange protocol. To capture the latter form of
security we could model the pre-accept phase with an (ide-
alized) trusted distribution of pairwise session keys between
honest parties. If a post-accept message exchange protocol
has the property that when coupled with the idealized key
exchange results in an ACCE secure protocol then we say
that the message exchange protocol is post-accept ACCE se-
cure. In this setting, what the above lemma says is that the
(cid:48) is post-
encrypted pre-authentication data in protocol Π2
accept ACCE secure. (Note that the ACCE model is deﬁned
with mutual authentication which is ensured here, although
the assurance for the server is delayed until it veriﬁes the
client’s CSM message.) We omit a more formal treatment
here.
6.3.1

Security under post-handshake authentication
with encrypted CSM.

One can extend the result from Lemma 9 to the case where
in addition to the encryption of pre-authentication data,
the CSM message itself is encrypted as in Section 6.2 (this
corresponds to the TLS 1.3 speciﬁcation). The simulation
combines the simulators from the proofs of Lemma 7 and
Lemma 9 using the key Ks to encrypt both pre-authentication
data and the CSM message. Note that the encrypted CSM
is delivered only after the encryption of pre-authentication
data, hence in a stateful encryption its ciphertext will de-
pend on the presence of prior encryptions (TLS 1.3’s en-
cryption is stateful in that it uses a sequence number as the
per-record nonce). The simulation will also deliver the en-
crypted CSM at this time, hence it will encrypt it correctly
(a crucial point is that there is no need to send CSM out of
order in the simulation).

1449Acknowledgments.
This paper has beneﬁted enormously from collaboration with
Eric Rescorla and Hoeteck Wee on the ongoing design of TLS
1.3, and from enlightening inputs from Bj¨orn Tackmann,
Douglas Stebila, Felix G¨unther, Karthik Bhargavan, Kenny
Paterson, Markulf Kohlweiss and many of the other partic-
ipants in the TRON workshop and the TLS working group.
Special thanks to Bj¨orn, Douglas, Eric and the anonymous
reviewers for their excellent and detailed comments.

References
[1] M. Bellare and P. Rogaway. Entity authentication and key
distribution.
In D. R. Stinson, editor, CRYPTO, volume
773 of Lecture Notes in Computer Science, pages 232–249.
Springer, 1993. ISBN 3-540-57766-1.

[2] M. Bellare, R. Canetti, and H. Krawczyk. A modular ap-
proach to the design and analysis of authentication and
key exchange protocols (extended abstract). In 30th ACM
STOC, pages 419–428. ACM Press, May 1998.

[3] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Four-
net, M. Kohlweiss, A. Pironti, P. Strub, and J. K. Zinzindo-
houe. A messy state of the union: Taming the composite
state machines of TLS.
In IEEE Symposium on Security
and Privacy, 2015.

[4] K. Bhargavan and G. Leurent. Transcript collision attacks:
Breaking authentication in tls, IKE and SSH.
In 23nd
Annual Network and Distributed System Security Sympo-
sium, NDSS 2016, San Diego, California, USA, Febru-
ary 21-24, 2016. The Internet Society, 2016. URL http:
//www.internetsociety.org/events/ndss-symposium-2016.

[5] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and
P.-Y. Strub. Implementing TLS with veriﬁed cryptographic
security. In IEEE Symposium on Security and Privacy, 2013.
URL http://mitls.rocq.inria.fr/.

[6] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Pironti,
and P. Strub. Triple handshakes and cookie cutters: Break-
ing and ﬁxing authentication over TLS. In 2014 IEEE Sym-
posium on Security and Privacy, SP, pages 98–113, 2014.

[7] K. Bhargavan, A. Delignat-Lavaud, and A. Pironti. Veriﬁed
contributive channel bindings for compound authentication.
In NDSS, 2015.

[8] C. Brzuska, M. Fischlin, N. P. Smart, B. Warinschi, and S. C.
Williams. Less is more: relaxed yet composable security
notions for key exchange. Int. J. Inf. Sec., 12(4):267–297,
2013. Cryptology ePrint Archive, Report 2012/242.

[9] R. Canetti and H. Krawczyk. Analysis of key-exchange pro-
tocols and their use for building secure channels. In EURO-
CRYPT, pages 453–474, 2001. See also Cryptology ePrint
Archive, Report 2001/040.

[10] R. Canetti and H. Krawczyk. Universally composable no-
tions of key exchange and secure channels. In EUROCRYPT,
pages 337–351, 2002. See also Cryptology ePrint Archive,
Report 2002/059.

[11] C. Cremers, M. Horvat, S. Scott, and T. van der Merwe.
Automated veriﬁcation of TLS 1.3: 0-RTT, resumption and
delayed authentication. In IEEE S&P 2016., 2016.

[12] B. Dowling, M. Fischlin, F. G¨unther, and D. Stebila. A
cryptographic analysis of the TLS 1.3 handshake protocol
candidates.
In ACM CCS, 2015. Also, Cryptology ePrint
Archive, Report 2015/914.

[13] B. Dowling, M. Fischlin, F. G¨unther, and D. Stebila. A
cryptographic analysis of the TLS 1.3 draft-10 full and pre-
shared key handshake protocol. Cryptology ePrint Archive,
Report 2016/081, 2016.

[14] M. Fischlin and F. G¨unther. Multi-stage key exchange and

the case of Google’s QUIC protocol. In ACM CCS, 2014.

[15] M. Fischlin, F. G¨unther, G. A. Marson, and K. G. Pater-
son. Data is a stream: Security of stream-based channels. In
R. Gennaro and M. J. B. Robshaw, editors, CRYPTO 2015,
Part II, volume 9216 of LNCS, pages 545–564. Springer, Hei-
delberg, Aug. 2015. .

[16] I. Goldberg, D. Stebila, and B. Ustaoglu. Anonymity and
one-way authentication in key exchange protocols. Des.
Codes Cryptography, 67(2):245–269, 2013.
. URL http:
//dx.doi.org/10.1007/s10623-011-9604-z.

[17] S. Halevi and H. Krawczyk. Public-key cryptography and
password protocols. ACM Transactions on Information and
System Security, 2(3):230–268, Aug. 1999.

[18] S. Halevi and H. Krawczyk. One-pass HMQV and asymmet-

ric key-wrapping. In PKC 2011, pages 317–334, 2011.

[19] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. Generic
compilers for authenticated key exchange. In M. Abe, editor,
ASIACRYPT 2010, volume 6477 of LNCS, pages 232–249.
Springer, Heidelberg, Dec. 2010.

[20] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the
security of TLS-DHE in the standard model. In CRYPTO,
pages 273–293, 2012. Also Cryptology ePrint Archive, Re-
port 2011/219.

[21] F. Kohlar, S. Sch¨age, and J. Schwenk. On the security of
TLS-DH and TLS-RSA in the standard model. Cryptology
ePrint Archive, Report 2013/367, 2013. http://eprint.iacr.
org/.

[22] M. Kohlweiss, U. Maurer, C. Onete, B. Tackmann, and
(De-)constructing TLS. Cryptology ePrint

D. Venturi.
Archive, Report 2014/020, 2014. revised Apr 2015.

[23] M. Kohlweiss, U. Maurer, C. Onete, B. Tackmann, and
D. Venturi. (de-)constructing TLS 1.3. In Progress in Cryp-
tology - INDOCRYPT 2015 - 16th International Conference
on Cryptology in India, Bangalore, India, December 6-9,
2015, Proceedings, pages 85–102, 2015.

[24] H. Krawczyk. SIGMA: The “SIGn-and-MAc” approach to
authenticated Diﬃe-Hellman and its use in the IKE proto-
cols. In CRYPTO, pages 400–425, 2003.

[25] H. Krawczyk and H. Wee. The OPTLS protocol and TLS

1.3. In EuroS&P, 2016.

[26] H. Krawczyk, K. G. Paterson, and H. Wee. On the security
of the TLS protocol: A systematic analysis.
In CRYPTO
(1), pages 429–448, 2013. Also, Cryptology ePrint Archive,
Report 2013/339.

[27] A. Langley and W.-T. Chang. QUIC crypto, 2013. URL

http://tinyurl.com/lrrjyjs.

[28] R. Lychev, S. Jero, A. Boldyreva, and C. Nita-Rotaru. How
secure and quick is QUIC? Provable security and perfor-
mance analyses. In IEEE Symposium on Security and Pri-
vacy, pages 214–231, 2015.

[29] U. Maurer, B. Tackmann, and S. Coretti. Key exchange
with unilateral authentication: Composable security deﬁni-
tion and modular protocol design. IACR Cryptology ePrint
Archive, 2013:555, 2013. URL http://eprint.iacr.org/2013/
555.

[30] P. Morrissey, N. P. Smart, and B. Warinschi. A modular
In ASI-

security analysis of the TLS handshake protocol.
ACRYPT, pages 55–73, 2008.

[31] K. G. Paterson, T. Ristenpart, and T. Shrimpton. Tag size
does matter: Attacks and proofs for the TLS record protocol.
In ASIACRYPT, pages 372–389, 2011.

[32] M. D. Raimondo, R. Gennaro, and H. Krawczyk. Deniable

authentication and key exchange. In ACM CCS, 2006.

[33] E. Rescorla. The transport layer security (TLS) protocol
version 1.3 (draft 13), Dec. 2015. URL https://tools.ietf.
org/html/draft-ietf-tls-tls13-13.

[34] V. Shoup. On formal models for secure key exchange. Cryp-

tology ePrint Archive, Report 1999/012, 1999.

1450