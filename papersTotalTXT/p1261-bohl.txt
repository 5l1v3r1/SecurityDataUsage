Deduction Soundness: Prove One, Get Five for Free

Florian Böhl

KIT

Karlsruhe, Germany
boehl@kit.edu

Véronique Cortier

LORIA - CNRS
Nancy, France

cortier@loria.fr

Bogdan Warinschi
University of Bristol

Bristol, United Kingdom

bogdan@cs.bris.ac.uk

ABSTRACT
Most computational soundness theorems deal with a limited
number of primitives, thereby limiting their applicability.
The notion of deduction soundness of Cortier and Warinschi
(CCS’11) aims to facilitate soundness theorems for richer
frameworks via composition results: deduction soundness
can be extended, generically, with asymmetric encryption
and public data structures. Unfortunately, that paper also
hints at rather serious limitations regarding further compo-
sition results: composability with digital signatures seems
to be precluded.

In this paper we provide techniques for bypassing the per-
ceived limitations of deduction soundness and demonstrate
that it enjoys vastly improved composition properties. More
precisely, we show that a deduction sound implementation
can be modularly extended with all of the ﬁve basic crypto-
graphic primitives (symmetric/asymmetric encryption, mes-
sage authentication codes, digital signatures, and hash func-
tions). We thus obtain the ﬁrst soundness framework that
allows for the joint use of multiple instances of all of the
basic primitives.

In addition, we show how to overcome an important re-
striction of the bare deduction soundness framework which
forbids sending encrypted secret keys. In turn, this prevents
its use for the analysis of a large class of interesting proto-
cols (e.g. key exchange protocols). We allow for more liberal
uses of keys as long as they are hidden in a sense that we
also deﬁne. All primitives typically used to send secret data
(symmetric/asymmetric encryption) satisfy our requirement
which we also show to be preserved under composition.

Categories and Subject Descriptors
F.0 [Theory of Computation]: General

Keywords
Computational soundness; Composability

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on theﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516711 .

1.

INTRODUCTION

Two main approaches have been developed for the anal-
ysis of security protocols. Symbolic models abstract away
the cryptographic primitives, allowing to reason at a logical
level, often in an automated way. Security proofs are there-
fore easier and often conducted by tools. In contrast, cryp-
tographic models oﬀer higher security guarantees, down to
the bitstring level. Security proofs are usually done by hand
and proceed by reduction, down to the security assumptions
(such as the computational hardness of computing a discrete
log).

Starting with the seminal work of Abadi and Rogaway [1],
many results study under which assumptions it is possible
to show that symbolic models are actually sound w.r.t. to
cryptographic models. For example, the symbolic represen-
tation of symmetric encryption consists simply of two fol-
lowing deduction rules.

k m

enc(k, m)

enc(k, m) k

m

An attacker can encrypt or decrypt only if he has the cor-
responding key. Given an encryption scheme, does it hold
that all attacker’s computations are reﬂected by these rules?
Surprisingly, the answer is yes, provided that the encryption
scheme satisﬁes some standard security requirements [2, 9]
(here IND-CCA). Such soundness theorems have been es-
tablished for active attackers for basically all standard cryp-
tographic primitives: symmetric encryption [2, 9], asymmet-
ric encryption [3, 12, 14], signatures [3, 17, 12], MACs [4],
hashes [17, 10, 16] (consult [11] for a more comprehensive
list).

However, these past results usually consider the primitives
in isolation or, in the best case, treat at most two primitives
at a time. Soundness proofs are complex, and including mul-
tiple primitives in the analysis easily leads to unmanageable
proofs. A way to bring the complexity under control is to de-
velop soundness results that are compositional. A ﬁrst step
in this direction is the work of Cortier and Warinschi [13].
They propose a notion of soundness which can be extended,
in a generic way in several ways, most notably with asym-
metric encryption: if a deduction system is sound for some
primitive (in the sense that they deﬁne) then extending the
deduction system with the usual deduction rules for asym-
metric encryption is a sound abstraction for combined uses
of the primitive and asymmetric encryption. Below, we refer
to this notion as deduction soundness.

The central idea that allows for composability is that de-
duction soundness considers the use of the primitives in the

1261presence of functions chosen adversarially from the class of
transparent functions. These are publicly computable and
eﬃciently invertible functions. Typical functions that are
transparent are the constructors of public data structures
like concatenation, lists, etc.
It is then obvious that de-
duction soundness in this sense implies soundness for the
use of primitive in the presence of other constructs that are
naturally transparent (e.g. public data structures). Less ob-
vious is that deduction soundness for a primitive also implies
soundness when the primitive is used together with asym-
metric encryption. In addition to this result (which is the
main technical contribution of [13]) that paper also shows
that deduction soundness implies that security of proto-
cols in symbolic models yields security in the computational
models, for a wide class of protocols.

Compositionality for the notion introduced in [13] is how-
ever limited, and the authors present rather compelling ev-
idence that the notion may not compose primitives other
than encryption. The problem is that deduction soundness
does not seem to preclude implementations that leak partial
information about their inputs. In turn, this leak of infor-
mation may impact the security of other primitives that one
may want to include later.

More concretely, assume that one has established sound-
ness of a deduction system that covers hash, but for an
implementation of the hash function that reveals half of
its input: h(m1(cid:2)m2) = m1(cid:2)g(m2) where g is a standard
If g is a “good” hash function then so is
hash function.
h. Now consider a signature scheme which duplicates sig-
(cid:2)
natures: sign(k, m) = sign
is
some standard signature scheme.
It is easy to see that if
(cid:2)
sign
(k, m) is a secure signature scheme, then so is sign(k, m).
Yet, given h(sign(k, m)) an adversary can easily compute
sign(k, m) without breaking the signature scheme nor the
hash: the hash function leaks suﬃcient information to be
able to recover the underlying signature.

(cid:2)
(k, m) where sign

(k, m)(cid:2)sign

(cid:2)

Our contributions.
In this paper we provide new insights
into the notion of deduction soundness. Despite the intu-
ition outlined above, we prove that the compositionality
properties of deduction soundness [13] reach further than
previously understood. For example, we prove that to any
deduction sound implementation of a set of primitives, one
can add signatures, as long as the implementation for the
signature satisﬁes a standard notion of security. This theo-
rem refutes the counterexample above and provides evidence
that deduction soundness is a more powerful (and demand-
ing) security notion than previously understood. In particu-
lar, a corollary of the theorem is that there are no deduction
sound abstractions for implementations that are “too leaky”
(as the hash function from the counterexample).

The new level of understanding facilitates further compo-
sitionality proofs for deduction soundness: to any deduction
sound system one can add any of the (remaining) standard
cryptographic primitives:
symmetric encryption, message
authentication codes, and hash functions while preserving
deduction soundness. The theorems hold under standard
security assumptions for the implementation of encryption
and MACs and require random oracles for adding hash func-
tions. As a consequence, we obtain the ﬁrst soundness result
that encompasses all standard primitives: symmetric and
asymmetric encryption, signatures, MACs, and hashes. In
addition, our composition results allow for a settings where
multiple schemes (that implement the same primitive) are

used simultaneously, provided that each implementation ful-
ﬁlls our assumptions. Moreover, composition provides a
stronger result: whenever deduction soundness is shown for
some particular primitive, our result ensures that all stan-
dard primitives can be added for free, without any further
proof.

The importance of composition cannot be overempha-
sized: obtaining such general results without being able to
study each primitive separately would be unmanageable.

Our compositionality results hold under several restric-
tions most of which are quite common in soundness proofs,
e.g. adversaries can corrupt keys only statically. Less stan-
dard is that we demand for secret keys to be used only for
the cryptographic task for which they are intended. Quite
reasonable most of the time, the restriction does not allow,
for example, for the adversary to see encryptions of sym-
metric keys under public keys. The restriction is related
If f is a primitive
to the signature-hash counterexample.
with a deduction sound system that leaks some information
about its input and Enc is a secure encryption scheme it is
not clear that (f (k), Enck(m)) hides m. Unfortunately, the
technique that we used to bypass the signature-hash coun-
terexample does not seem to apply here. At a high level, the
diﬃculty is that in a potential reduction to the security of
the encryption scheme, we are not be able to simulate f (k)
consistently.

One way to relax the restriction is to employ encryption
schemes that are secure even when some (or even most) of
the encryption key leaks [15, 18]. Current instantiations for
such schemes are highly ineﬃcient and we prefer the follow-
ing alternative solution which, essentially, allows for other
uses of symmetric keys, as long as these uses do not reveal
information about the keys.
In a bit more detail, we say
that a function is forgetful for some argument if the func-
tion hides (computationally) all of the information about
that input. The notion is a generalization for the secu-
rity of encryption schemes: these can be regarded as for-
getful with respect to their plaintext. We then show that a
forgetful deduction sound implementation can be extended
with symmetric encryption under more relaxed restrictions:
soundness is preserved if encryption keys are used for en-
cryption, or appear only in forgetful positions of other func-
tions from the implementation we are extending. Finally,
we show that, in addition to soundness, forgetfulness is pre-
served as well. Hence we can ﬂexibly and add several layers
of asymmetric/symmetric key encryption such that the keys
of each layer may appear in any forgetful position of under-
lying layers. We feel that this allows us to capture almost
every hierarchical encryption mechanism in practical proto-
cols.

Full version. Due to lack of space the formal justiﬁcations
for our results are not contained in this extended abstract.
For the beneﬁt of reviewers the full version of the paper is
online [8].

2. THE SYMBOLIC MODEL

Our abstract models for the symbolic world—called sym-
bolic models—consist of term algebras deﬁned on a typed
ﬁrst-order signature.
Speciﬁcally we have a set of data types T with a subtype
relation (≤) which we require to be a preorder. We assume

1262that T always contains a base type (cid:4) such that every other
type τ ∈ T is a subtype of (cid:4) (τ ≤ (cid:4)).
The signature Σ is a set of function symbols together with
arities of the form ar(f ) = τ1 × . . . × τn → τ , n ≥ 0 for
τi, τ ∈ T . We refer to τ as the type of f and require τ (cid:8)=
(cid:4) for all f except for garbage of basetype g(cid:3). Function
symbols with n = 0 arguments are called constants. We
distinguish deterministic function symbols, e.g., for pairs,
and randomized function symbols, e.g., for encryption.
For all symbolic models we ﬁx an inﬁnite set of typed vari-
ables {x, y . . .} and an inﬁnite set of labels labels = labelsH∪
labelsA for inﬁnite, disjoint sets of honest labels (labelsH)
and adversarial labels (labelsA). Since labels are used to
specify randomness, distinguishing honest and adversarial
labels (randomness) is important.

The set of terms of type τ is deﬁned inductively by

t

::=
|
|
|

term of type τ
x
variable x of type τ
application of deterministic f ∈ Σ
f (t1, . . . , tn)
f l(t1, . . . , tn) application of randomized f ∈ Σ

(cid:2)
i with τ

where for the last two cases, we further require that each ti is
i ≤ τi for ar(f ) = τ1×. . .×τn →
(cid:2)
a term of some type τ
τ and for the last case that l ∈ labels. The set of terms is
denoted by Terms(Σ,T ,≤) and is the union over all sets of
terms of type τ for all τ ∈ T . For ease of notation we often
write Terms(Σ) for the same set of terms, and refer to general
terms as t = f l(t1, . . . , tn) even if f could be a deterministic
function symbol which doesn’t carry a label.
Intuitively, for nonces, we use randomized constants. For
example, assume that n ∈ Σ is a constant. Then usual
nonces can be represented by nr1 , nr2 , . . . where r1, r2 ∈
labels are labels. Labels in labelsH will be used when the
function has been applied by an honest agent (thus the
randomness has been honestly generated) whereas labels in
labelsA will be used when the randomness has been gener-
ated by the adversary. Often when the label for a function
symbol is clear from the context (e.g. when there is only one
label that suits a particular function symbol) we may omit
this label.
We require Σ to contain randomized constants gτ of type
τ for any τ ∈ T that will be used for representing garbage
of type τ . Garbage will typically be the terms associated
to bit-strings produced by the adversary which cannot be
parsed as a meaningful term (yet). If garbage can at some
point be parsed as the application of a deterministic function
symbol, the label is dropped.
Substitutions are written σ = {x1 = t1, . . . , xn = tn} with
domain dom(σ) = {x1, . . . , xn}. We only consider well-typed
substitutions, that is substitutions σ = {x1 = t1, . . . , xn =
tn} for which ti is of a subtype of xi. The application of a
substitution σ to a term t is written σ(t) = tσ.

Function symbols in Σ are intended to model crypto-
graphic primitives, including generation of random data like
e.g. nonces or keys. Identities will typically be represented
by constants (deterministic function symbols without argu-
ments). The symbolic model is equipped with a deduction
relation (cid:10)⊆ 2Terms×Terms that models the information avail-
able to a symbolic adversary. T (cid:10) t means that a formal
adversary can build t out of T , where t is a term and T a
set of terms. We say that t is deducible from T . Deduction
relations are typically deﬁned through deduction systems.

t1

tn

···
t

∈ D then T (cid:10)D tσ.

t1

Definition 1. A deduction system D is a set of rules
such that t1, . . . , tn, t ∈ Terms(Σ,T ,≤). The de-
···
duction relation (cid:10)D⊆ 2Terms × Terms associated to D is the
t
smallest relation satisfying:

tn

• T (cid:10)D t for any t ∈ T ⊆ Terms(Σ,T ,≤)
• If T (cid:10)D t1σ, . . .T (cid:10)D tnσ for some substitution σ and

τ

We may omit the subscript D in (cid:10)D when it is clear from
the context. For all deduction systems D in this paper we
for all garbage symbols gτ ∈ Σ and l ∈ labelsA.
require gl
From now on we denote a symbolic model M as a tuple
(T ,≤, Σ,D) where T is the set of data types, ≤ the subtype
relation, Σ signature and D the deduction system. For all
symbolic models deﬁned in this paper we omit the garbage
symbols and the corresponding reduction rules for the sake
of brevity.

IMPLEMENTATION

3.
An implementation I of a symbolic model is a family of
tuples (Mη, [[·]]η, len η, openη, validη)η for η ∈ N. We usually
omit the security parameter and just write (M, [[·]], len, open,
valid) for an implementation.

{0,1}∗

M is a Turing Machine which provides concrete algorithms
working on bit-strings for the function symbols in the signa-
ture. [[·]] : T → 2
is a function that maps each type to
a set of bitstrings. len : Terms → N computes the length of a
term if interpreted as a bitstring. With open the implemen-
tation provides an algorithm to interpret bitstrings as terms.
valid is a predicate which states whether a concrete use of
the implementation is valid. For example, a correct use of an
implementation might exclude the creation of key cycles or
dynamic corruption of keys from the valid use cases. More
precisely we require the following from an implementation:
We assume a non-empty set of bitstrings [[τ ]] ⊆ {0, 1}η for
each type τ ∈ T . For the base type (cid:4), we assume [[(cid:4)]] =
{0, 1}∗
(cid:2) ∈ T with τ ≤ τ
(cid:2)
]] = ∅ otherwise (i.e., if
we require [[τ ]] (cid:2) [[τ
τ (cid:8)≤ τ
). We write [[T ]] for ∪τ∈T \{(cid:3)}[[τ ]]. Later, we often
(cid:2)
make use of a function (cid:14)c1, . . . , cn, τ(cid:15) that takes a list of
bitstrings c1, . . . , cn and a type τ and encodes c1, . . . , cn as a
(cid:2) ∈ [[τ ]]. We assume that this encoding is bijective,
bitstring c
(cid:2)
i.e., we can uniquely parse c

as (cid:14)c1, . . . , cn, τ(cid:15) again.

and for any pair of types τ, τ

]] and [[τ ]] ∩ [[τ

(cid:2)

(cid:2)

We require the Turing Machine M itself to be determinis-
tic. However, each time it is run, it is provided with a ran-
dom tape R. More speciﬁcally, we require for each f ∈ Σ
with ar(f ) = τ1 × . . . × τn → τ that is not a garbage sym-
bol that for input f M calculates a function (M f ) with
domain [[τ1]] × ··· × [[τn]] × {0, 1}∗
and range [[τ ]]. The run-
time of M and (M f ) has to be polynomial in the length
of its input. Intuitively, to generate a bitstring for a term
t = f l(t1, . . . , tn) we apply (M f ) to the bitstrings generated
for the arguments ti and some randomness (which might not
be used for deterministic function symbols). We call the re-
sulting bitstring computational interpretation of t. The ran-
domness is provided by the generate function introduced in
Section 3.

Interpretations. In cryptographic applications functions
are often randomized and the same random coins may occur
in diﬀerent places within the same term. This is the case
for instance when the same nonce occurs twice in the same

1263generateM,R(t, L):

if for some c ∈ dom(L) we have L[[c]] = t then

return c

else

for i ∈ {1, . . . , n} let (ci, L) := generateM,R(ti, L)
let r := R(t)
let c := (M f )(c1, . . . , cn; r)
let L(c) :=f l(c1, . . . , cn)) (l ∈ labelsH)
return (c, L)

Figure 1: The generate function (t is of the form
f l(t1, . . . , tn) (with possibly n = 0 and no label l for
deterministic function symbols f )).

. By dom(L) ⊆ 2

term. We use a (partially deﬁned) mapping L : {0, 1}∗ →
HTerm from bit-strings to hybrid terms to record this in-
formation. A hybrid term is either a garbage term or
f l(c1, . . . , cn) where f ∈ Σ is a function symbol of arity
n applied to bit-strings ci ∈ {0, 1}∗
{0,1}∗
we denote the domain of L, i.e. the set of bit-strings for
which L is deﬁned. The mapping L induces an interpre-
tation of bit-strings as terms. We deﬁne the interpreta-
tion of bitstring c ∈ dom(L) with respect to a mapping L
as L[[c]] := f l(L[[c1]], . . . , L[[cn]]) if L(c) = f l(c1, . . . , cn)
and L[[c]] := L(c) ifL (c) is a garbage term. We say that
a mapping L is complete, if for all (c, f l(c1, . . . , cn)) ∈ L
c1, . . . , cn ∈ dom(L). Note that L[[c]] is only deﬁned if L is
complete.

Generating function. Given a mapping L we deﬁne a
generating function that associates a concrete semantics for
terms (given the terms already interpreted in L).
The generation function uses a random tape R as a source
of randomness for M when generating the concrete interpre-
tation of terms. We assume that there is an algorithm R(t)
which maps a term t to a bitstring r ∈ {0, 1}η that should
be used as the randomness when t is generated. Even chang-
(cid:2)
ing only one label in t leads to a changed term t
for which
diﬀerent randomness will be used. Figure 1 deﬁnes the gen-
erate function given a closed term t = f l(t1, . . . , tn) and a
mapping L.

Note that generateM,R(t, L) not only returns a bit-string c
associated to t but also updates L (to remember, for exam-
ple, the value associated to t). Note also that generateM,R
depends on M and the random tape R. When needed, we
explicitly show this dependency, but in general we avoid
If a mapping L is complete, then for
it for readability.
(cid:2)
) :=generate (t, L), L
(c, L
is complete. Furthermore, the
generate function requires that, for given inputs t, L, the
:= f l(t1, . . . , tn) ∈ st(t) where
(cid:2)
following holds: For all t
l ∈ labelsA we ﬁnd a c ∈ dom(L) s.t. L[[c]] = t
and t doesn’t
contain garbage symbols carrying honest labels. This guar-
antees that all bitstrings introduced by the generate function
correspond to the application of non-garbage function sym-
bols carrying honest labels.

(cid:2)

(cid:2)

Parsing function. Conversely, we require the implemen-
tation to deﬁne a function parse to convert bit-string into
terms. The function takes a bit-string c and a mapping L
as input and returns a term t and an extended mapping L.
For parsing functions we require the concrete structure in
Figure 2 (where open : {0, 1}∗ × libs → {0, 1}∗ × HTerm a

parse(c, L):

if c ∈ dom(L) then
return (L[[c]], L)
let Lh := {(c, f l(. . .)) ∈ L : l ∈ labelsH}
let L :=

else

(cid:4)

(cid:6)

let G :=
do

(cid:2)(cid:3)
(cid:5)
(c,·)∈L open(c, Lh)
(c, gl(c)(cid:3) )
(cid:5)
let L := (L \ G) ∪
let G :=
while G (cid:8)= ∅
return (L[[c]], L)

(l(c) ∈ labelsA)
(cid:2)(cid:3)
(c, gl(c)(cid:3) ) : (c

(cid:4)

(c,·)∈G open(c, Lh)
, f (. . . , c, . . .)) ∈ L and c (cid:8)∈ dom(L)
(cid:2)

(cid:6)

Figure 2: The parsing function.

function that on call open(c, L) parses the bitstring c in pres-
ence of the library L and returns its hybrid interpretation).

The exact deﬁnition of parse is left unspeciﬁed, as it de-
pends on the particular behavior of open which is provided
by a concrete implementation. We require this structure for
the parsing function to provide a concrete context in which
the open function of diﬀerent implementations can be com-
posed. Note that the open function is only allowed to use
honestly generated bitstrings when dealing with a term. We
will furthermore only use open functions later that ignore
“foreign” bitstrings in the given library, i.e., bitstrings that
are of a data type that is not part of the implementation
open belongs to. Due to these properties the composition
of open functions is commutative. This is important for our
composition theorems later. Furthermore, we think that it
meets the intuition that the composition of diﬀerent imple-
mentations should be commutative.

Good implementation. Until now we have not restricted
the behavior of implementations in any way. However, there
are some properties we will need to hold for every implemen-
tation. We describe these properties in this section and say
that a good implementation is one that satisﬁes all of them.
We stipulate that a good implementation is length regu-
lar, i.e., len(f l(t1, . . . , tn)) := |(M f )(c1, . . . , cn; r)| depends
only on the length of the arguments ci (which are the com-
putational interpretations of the symbolic arguments ti).

We now explain what it means for an implementation
to be collision free. A collision occurs if during a call of
generateM,R(t, L) an execution of M yields a bitstring c that
is already in the domain of L. Since the library L has to be
well-deﬁned, we can either overwrite the old value L(c) with
the new one or discard the new value. Both variants are
problematic:

Overwriting changes the behavior of parse (i.e., bitstrings
may now be parsed diﬀerently). This might have severe
consequences. Imagine that the overwritten bitstring was an
honestly signed message. Now this signature looks like the
signature of a diﬀerent message symbolically; possibly like a
forgery. Note that this would not be a weakness of signatures
but of the fact that collisions can be found for bitstrings
corresponding to the signed terms. Discarding means that
a bitstring c generated for a term t might not be parsed as

1264t later which might wrongfully prevent the adversary from
winning the soundness game.

Hence we will always require our implementations to be
collision free. Details can be found in the full version of this
paper [8].

When we compose implementations later we will need that
their open functions do not interfere. Intuitively, each open
function should stick to opening the bitstrings it is respon-
sible for (i.e., that are of types belonging to the same im-
plementation the open function belongs to). We say that
an open function is type safe if it satisﬁes (i) open(c, L) =
(c, gl(cid:3)) for l ∈ labelsA if c (cid:8)∈ [[T ]] and (ii) open(c, L) =
open(c, L|[[T ]]) where L|[[T ]] := {(c, h) ∈ L : ∃τ ∈ T \ {(cid:4)}:
c ∈ [[τ ]]}. Since we need to simulate parsing later, we require
parse(c, L) (based onopen) to run in polynomial time in the
size of the library.

For technical reasons we have to stipulate some general
properties for the valid predicate, e.g., a polynomial runtime,
to get a good implementation. These details are omitted
here and can be found in [8].

4. TRANSPARENT FUNCTIONS

Typical primitives that are usually considered in sound-
ness results include encryption, signatures, hash functions,
etc.. Intuitively, such functions are eﬃciently invertible, and
the type of their output can be eﬃciently determined. An
example for such functions are data structures (i.e., pairs,
lists, XML documents, etc.). Following the ideas of [13], we
deﬁne and study soundness in presence of transparent func-
tions like these.
In this section we deﬁne the notion of a
transparent symbolic model and the corresponding transpar-
ent implementation.
A transparent symbolic model Mtran = (Ttran, ≤tran, Σtran,
Dtran) is a symbolic model where the deduction system is de-
ﬁned as follows (the label is omitted for deterministic func-
⎫⎪⎬
tion symbols):
⎪⎭

f l(tn,...,tn) l ∈ labelsA, f ∈ Σtran
t1 ··· tn

1 ≤ i ≤ n, l ∈ labels, f ∈ Σtran

Dtran =

⎧⎪⎨
⎪⎩

l(t1,...,tn)

f

ti

Formally, a transparent implementation of a transpar-
ent symbolic model M = (T ,≤, Σ,D) is an implementa-
tion (and thus adhering to the requirements from Figure 3)
Itran = (Mtran, [[·]], len, opentran, validtran) where opentran and

validtran are deﬁned explicitly below. We require two ad-
ditional modes of operation, func and proj, for the Tur-
ing Machine Mtran such that for all f ∈ Σ with ar(f ) =
τ1 × . . . × τn → τ

(Mtran func) : {0, 1}∗ → Σ ∪ {⊥}
(Mtran proj f i) : {0, 1}∗ → {0, 1}∗ ∪ {⊥}
and we have for any ci ∈ [[τi]], 1 ≤ i ≤ n, r ∈ {0, 1}η

(Mtran func)((Mtran f )(c1, . . . , cn; r)) = f
(Mtran proj f i)((Mtran f )(c1, . . . , cn; r)) = ci

Furthermore, we require (Mtran func)(c) = ⊥ for all c (cid:8)∈ [[T ]].
As expected, Mtran is required to run in polynomial time in
η for this modes of operation as well.

For transparent implementations we explicitly deﬁne the
open function opentran as in Figure 3. Note that a transpar-
ent implementation is automatically type safe: Property (i)

opentran(c, L):

if c ∈ [[T ]] ∩ dom(L) then
else if (Mtran func)(c) = ⊥ then

return (c, L(c))
ﬁnd unique τ ∈ T s.t. c ∈ [[τ ]] and
(cid:2) ∈ T with [[τ
(cid:2)
) (l(c) ∈ labelsA)

c (cid:8)∈ [[τ

]] for all τ

(cid:2)

]] (cid:2) [[τ ]]

else

τ

return (c, gl(c)
let f := (Mtran func)(c) (ar(f ) = τ1 × ··· × τn → τ )
if (Mtran proj f i)(c) = ⊥ for some i ∈ {1, . . . , n} then

else

τ

) (l(c) ∈ labelsA)
return (c, gl(c)
for i ∈ {1, . . . , n} do
let (cid:14)ci := (Mtran proj f i)((cid:14)c)
return (c, f l(c)(c1, . . . , cn)) (l(c) ∈ labelsA)

Figure 3: Parsing algorithm for a transparent im-
plementation.

is required above and property (ii) holds since it only uses
L for bitstrings of type T .

We deﬁne validtran(T) = true for all traces T, i.e., the use

of transparent functions is not restricted in any way.

5. COMPOSITION

:= T1 ∪ T2, ≤(cid:2)

:=≤1 ∪ ≤2, Σ

models and their corresponding implementations.

We deﬁne the composition of M(cid:2)

We next explain how to generically compose two symbolic
Let M1 = (T1,≤1, Σ1,D1) and M2 = (T2,≤2, Σ2,D2)
be symbolic models and I1 = (M1, [[·]]1, len 1, open1, valid1)
and I2 = (M2, [[·]]2, len 2, open2, valid2) implementations of
M1 and M2 respectively. We say that that (M1,I1) and
(M2,I2) are compatible if M1 and M2 as well as I1 and I2
meet the requirements for compositions of symbolic models
and implementations stated below respectively.
= M1 ∪ M2 of M1
and M2 if (i) Σ1 ∩ Σ2 = {g(cid:3)} and (ii ) T1 ∩ T2 = {(cid:4)} and
then have T (cid:2)
:= Σ1 ∪ Σ2 and
D(cid:2)
:= D1 ∪ D2.
The corresponding implementations I1 = (M1, [[·]]1, len 1,
open1, valid1) and I2 = (M2, [[·]]2, len 2, open2, valid2) can be
composed if (i) for all types τ1 ∈ T1 \ {(cid:4)}, τ2 ∈ T2 \ {(cid:4)} we
have [[τ1]] ∩ [[τ2]] = ∅ and (ii) the composition of I1 and I2
(as deﬁned below) is a collision-free implementation of M(cid:2)
.
We then deﬁne the composition I(cid:2)
f ) returns (M1 f ) for f ∈ Σ1
and (M2 f ) if f ∈ Σ2. This is non-ambiguous due to (i).1
Similarly, for all τ ∈ T1 we set [[τ ]]
:= [[τ ]]1 and analo-
gously for τ ∈ T2. Note that [[(cid:4)]] = [[(cid:4)]]1 = [[(cid:4)]]2 = {0, 1}∗
.
Since implementations are required to be length regular we
can also compose the length functions len 1 and len 2 in a
straightforward way to get len

= I1 ∪ I2 as follows:

The Turing machine (M

(cid:2)

(cid:2)

(cid:2)

(cid:2)

.

To compose the open functions we deﬁne

(open1 ◦ open2)(c, L):

let (c, t) := open1(c, L)
if t = gl(cid:3) for some l ∈ labelsA then

return open2(c, L)

1Here we assume that the membership problem is eﬃciently
decidable (since M
has to run in polynomial time). This can
be achieve w.l.o.g. with a suitable encoding for the function
symbols.

(cid:2)

1265else

return (c, t)

(cid:2)

:= open1◦open2. Furthermore we set
(T) := valid1(T)∧ valid2(T) where ∧ is the conjunction.
is a good implementation of the com-

(cid:2)

and consequently open
valid
posed symbolic model M(cid:2)

Checking that I(cid:2)

is a straightforward task.

6. DEDUCTION SOUNDNESS

In this section we recall the notion of deduction soundness
of an implementation with respect to a symbolic model [13].
Informally, the deﬁnition considers an adversary that plays
the following game against a challenger. The challenger
maintains a mapping L between bitstrings and hybrid terms,
as deﬁned in Section 3. Recall that the such mappings are
used to both generate bitstring interpretations for terms,
and also to parse bitstrings as terms (Figures 1,2). Roughly,
the adversary is allowed to request to see the interpretation
of arbitrary terms, and also to see the result of the parsing
function applied to arbitrary bitstrings. Throughout the ex-
ecution the queries that the adversary makes need to satisfy
a predicate valid (which is a parameter of the implementa-
tion). The goal of the adversary is to issue a parse request
such that the result is a term, that is not deducible from
the terms that he had queried in his generate requests: this
illustrates the idea that the adversary, although operating
with bitstrings, is restricting to only performing Dolev-Yao
operations on the bit-strings that it receives.

The details of the game are in Figure 4. Our deﬁnition
departs from the one of [13] in a few technical aspects. First,
we introduce a query init which is used to “initialize” the
execution by, for example, generating (and corrupting) keys.
The introduction of this query allows for a clearer separation
between the phases where keys are created and where they
are used, and allows to simplify and clarify what are valid
interactions between the adversary and the game.

Secondly, we also allow the adversary to issue sgenerate re-
quests: these are generate requests except that the resulting
bitstring is not returned to the adversary. These requests
are a technical necessity that help in later simulations, and
only strengthen the adversary.
Deduction soundness of an implementation I with respect
to a symbolic model M for an implementation is deﬁned by
considering an adversary who plays the game sketched above
against an implementation that mixes I with transparent
functions provided by the adversary. To ensure uniform be-
havior on behalf of the adversary , we introduce a notion of
parametrized transparent functions/models.

Parametrization. A parametrized transparent symbolic
model Mtran(ν) maps a bitstring ν (the parameter) to a
transparent symbolic model. Analogously, a parametrized
transparent implementation Itran(ν) of Mtran maps a bit-
string ν (the parameters) to a transparent implementation
ν where the length of ν is polynomial in the security pa-
rameter. We say that a parameter ν is good if Itran(ν) is a
transparent implementation of Mtran(ν) and meets the re-
quirements of a good implementation (i.e., type-safe, . . . )
from Section 3.
Deduction soundness of an I with respect to M holds
if the adversary cannot win the deduction soundness game
that involves implementation I∪Itran(ν) for M∪Mtran(ν) for
arbitrary transparent models/implementations Mtran,Itran,
and for any parameter ν provided by the adversary.

DSM(ν),I(ν),A(η):

let S := ∅
(set of requested terms)
let L := ∅
(library)
let T := ∅
(trace of queries)
R ← {0, 1}∗
(random tape)
Receive parameter ν from A

on request “init T, H” do

add “init T ” to T
if valid(T) then
let S := S ∪ T
let C := ∅
for each t ∈ T do

(list of replies)

let (c, L) := generateM,R(t, L)
let C := C ∪ {c}

let (c, L) := generateM,R(t, L)

for each t ∈ H do
send C to A
return 0 (A is invalid)

else

on request “sgenerate t” do

if valid(T+“sgenerate t”) then

let (c, L) := generateM,R(t, L)

on request “generate t” do

add “generate t” to T
if valid(T) then
let S := S ∪ {t}
let (c, L) := generateM,R(t, L)
send c to A
return 0 (A is invalid)

else

on request “parse c” do

let (t, L) := parse(c, L)
if S (cid:10)D t then
send t to A
return 1 (A produced non-Dolev-Yao term)

else

Figure 4: Game deﬁning deduction soundness.
Whenever generateM,R(t, L) is called, the require-
ments for t are checked (i.e., all subterms of t with
adversarial labels must already be in L and t does
not contain garbage symbols with honest labels) and
0 is returned if the check fails (i.e., the A is consid-
ered to be invalid).

Definition 2

(Deduction soundness). Let M be a
symbolic model and I be an implementation of M. We say
that I is a deduction sound implementation of M if for
all parametrized transparent symbolic models Mtran(ν) and
for all parametrized transparent implementations Itran(ν) of
Mtran such that (Mtran,Itran) is compatible with (M,I) we
have that

(cid:15)

P

DSM∪Mtran(ν),I∪Itran(ν),A(η) = 1

(cid:16)

1266is negligible for all probabilistic polynomial time (p.p.t.) ad-
versaries A sending only good parameters ν where DS is the
deduction soundness game deﬁned in Figure 4.

7. COMPOSITION THEOREMS

The notion of deduction soundness enjoys the nice prop-
erty of being easily extendable: if an implementation is de-
duction sound for a given symbolic model, it is possible to
add other primitives, one by one, without having to prove
deduction soundness from scratch for the resulting set of
primitives.

In this section we state a couple of composition theorems
that can be used to enrich any deduction sound implemen-
tation with additional primitives. First, we quickly restate
the main composition theorem for public data types from
[13].

Theorem 1. Let M be a symbolic model and I a deduc-
tion sound implementation of M. Furthermore, let Mtran
be a transparent symbolic model and Itran a transparent im-
plementation of Mtran. If (M,I) and and (Mtran,Itran) are
compatible, then I ∪ Itran is a deduction sound implementa-
tion of M ∪ Mtran.
7.1 Signatures

In this section we show that any deduction sound imple-
mentation can be extended by a signature scheme. More
precisely, composition works if we require a strong EUF-
CMA secure signature scheme and enforce static corruption.
The result is again a deduction sound implementation.
We ﬁrst deﬁne the symbolic model (TSIG,≤SIG, ΣSIG,DSIG)
for signatures. The signature ΣSIG features the following
function symbols:
SIG × (cid:4) → τ sig
The randomized function sk of arity τ sk
SIG returns a signing
key. The deterministic function vk of arity τ sk
SIG de-
SIG
rives a veriﬁcation key from a signing key. The randomized
× (cid:4) → τ sig
signing function sig has arity τ sk
SIG and, given a
signing key and a message of type (cid:4), represents a signature
SIG
of that message. To complete the formal deﬁnition we set
the types

SIG → τ vk

→ τ vk

sk : τ sk
SIG

sig : τ sk

vk : τ sk

SIG

SIG

TSIG := {(cid:4), τ sk

SIG, τ vk

SIG, τ sig
SIG

}

All introduced types are direct subtypes of the base type
(cid:4) (this deﬁnes ≤SIG). The deduction system captures the
security of signatures

⎧⎪⎪⎨
⎪⎪⎩

DSIG :=

l()

sk

vk (sk l()) ,

sig

ˆl(sk
l(),m)
m

,

l() m

sk

sig la (sk l(),m)

⎫⎪⎪⎬
⎪⎪⎭

These rules are valid for arbitrary labels l, ˆl ∈ labels and
adversarial labels la ∈ labelsA. Read from top left to bottom
right, the rules capture the intuition that the adversary can
derive veriﬁcation keys from signing keys, that signatures
reveal the message that was signed and that the adversary
can use known signing keys to deduce signatures under those
keys. Although the veriﬁcation key is going to be part of
the computational implementation of a signatures, we don’t
need a rule sig
where adversary knows all veriﬁcation keys.

since we enforce static corruption

ˆl(sk
vk (sk l)

l(),m)

openSIG(c, L)

if c ∈ [[TSIG]] ∩ dom(L) then
return (c, L(c))
else if c = (cid:14)sk , τ sk
return (c, gl(c)
τ sk
else if c = (cid:14)vk , τ vk
SIG

(cid:15) then
SIG
)
(cid:15) then

if ˆsk ∈ dom(L) s.t. ˆsk = (cid:14)vk , sk , τ sk

SIG

(cid:15) then

SIG

return (c, vk ( ˆsk ))

else

return (c, gl(c)
τ vk
SIG

)
else if c = (cid:14)σ, m, vk , τ sig

(cid:15) then
(cid:15), vk ( ˆsk )) ∈ L

SIG

if ((cid:14)vk , τ vk

SIG

and SIG.Vfy(vk , σ, m) = true then
return (c, sig l(c)( ˆsk , m))

else

return (c, gl(c)
τ sig
SIG

)

else

return (c, gl(c)(cid:3) )

Figure 5: Open function for signatures.

We now give a concrete implementation ISIG for signa-
tures. The implementation uses some strongly EUF-CMA
secure signature scheme (SIG.KeyGen, SIG.Sig, SIG.Vfy). As
usual, here SIG.KeyGen is a generation algorithm for key
pairs, SIG.Sig is an signing algorithm and SIG.Vfy is a ver-
iﬁcation algorithm. Note that SIG.Sig is an algorithm that
takes three inputs: the signing key, the message to be signed
and the randomness that is used for signing.2 The com-
putable interpretations of sk , vk , sig are as follows:

• (MSIG sk )(r): Let (vk , sk ) :=SIG.KeyGen (1η, r). Re-

turn (cid:14)vk , sk , τ sk

(cid:15).

SIG

• (MSIG vk )( ˆsk : Parse ˆsk as (cid:14)vk , sk , τ sk
• (MSIG sig)( ˆsk , m; r): Parse ˆsk as (cid:14)vk , sk , τ sk
(cid:15).
SIG.Sig(sk , m, r) and return (cid:14)σ, m, vk , τ sig

(cid:15). Return (cid:14)vk , τ vk
(cid:15). Let σ :=

SIG

SIG

SIG

SIG

(cid:15).

Intuitively, the validSIG predicate guarantees static corrup-
tion of signing keys and that veriﬁcation and signing keys
are only used for signing and veriﬁcation.

Theorem 2. Let M be a symbolic model and I be de-
duction sound implementation of M.
If (MSIG,ISIG) and
(M,I) are compatible, then I ∪ ISIG is a deduction sound
implementation of M ∪ MSIG.

We brieﬂy describe the intuition behind the proof. Let
A be an adversary playing the deduction soundness game.
Assume that A queries “parse c” and c is parsed as a non-
ˆl(sk l(), m)
DY term t that contains a signature sig := sig
and S (cid:8)(cid:10) sig (where S is the list of terms generated for A in
the deduction soundness game). We distinguish two possible
ways the adversary could potentially have learned sig:
If sig was previously generated for A (i.e., sig ∈ st(S)
and ˆl ∈ labelsH), we say that A reconstructed sig. Since
2Since the message m is of basetype, we require a scheme
with message space {0, 1}∗

.

1267signatures and transparent functions do not introduce func-
tion symbols that allow for signatures as input such that
the signature is not derivable from the constructed term, A
must have broken the deduction soundness of I in this case.
Hence, using A, we can construct a successful adversary B
on the deduction soundness of I. B simulates signatures
using transparent functions.
If sig was not previously generated for A (i.e., ˆl ∈ labelsA),
we say that A forged sig. In this case A can be used to break
the strong EUF-CMA security of the signature scheme.
Since reconstructions and forgeries can only occur with
negligible probability the composed implementation I ∪ISIG
is a deduction sound implementation of M ∪ MSIG.
7.2 Secret key encryption

In this section we deﬁne a symbolic model MSKE for se-
cret key encryption and a corresponding implementation
ISKE based on a secure authenticated encryption scheme
(SKE.KeyGen, SKE.Enc, SKE.Dec) [6]. We show that compo-
sition of MSKE and ISKE with any symbolic model M com-
prising a deduction sound implementation I preserves this
property for the resulting implementation, i.e., I ∪ ISKE is a
deduction sound implementation of M ∪ MSKE.
We ﬁrst deﬁne the symbolic model (TSKE,≤SKE, ΣSKE,DSKE)
for secret key encryption. The signature ΣSKE features the
function symbols
kx : τ kx
SKE

× (cid:4) → τ ciphertext

Ex : τ kx
SKE

for x ∈ {h, c}. 3 The randomized functions kh and kc re-
turn honest or corrupted keys respectively. The randomized
function Ex has arity τ kx
and represents
SKE
a ciphertext under the given key. To complete the formal
deﬁnition we set

× (cid:4) → τ ciphertext

SKE

SKE

TSKE := {(cid:4), τ kx

SKE, τ ciphertext

SKE

}

All introduced types are direct subtypes of the base type
(cid:4) (this deﬁnes ≤SKE). The deduction system captures the
security of secret key encryption

⎧⎪⎪⎨
⎪⎪⎩

DSKE :=

⎫⎪⎪⎬
⎪⎪⎭

l
x() m
k
la
x (k l

x(),m) ,

E

la
h

E

(k

l
h(),m)
m

ˆl
c(k

E

,

l
c(),m)
m

These rules are valid for arbitrary labels l, ˆl ∈ labels and
adversarial labels la ∈ labelsA. Read from top left to bot-
tom right, the rules capture the intuition that the adver-
sary can use any honestly generated key to encrypt some
term m, that the adversary knows the message contained
in any adversarial encryption and that the adversary knows
the message contained in any encryption under a corrupted
key.
We now give a concrete implementation ISKE for secret key
encryption. The implementation uses some IND-CCA se-
cure
scheme
(SKE.KeyGen, SKE.Enc, SKE.Dec).
As usual, here
SKE.KeyGen is a generation algorithm for key pairs, SKE.Enc
is an encryption algorithm and SKE.Dec is a decryption al-
gorithm. Note that SKE.Enc is an algorithm that takes
3Note that we distinguish encryptions under honest keys
from encryptions under corrupted keys on the level of func-
tion symbols. We need this to deﬁne forgetful positions later
(Section 8). E.g., a message encrypted with a corrupted key
cannot be hidden.

authenticated

encryption

secret

key

three inputs: the key, the message to be encrypted and the
randomness that is used for encryption.4
The computable interpretations of, kx and Ex (for x ∈
{h, c}) are as follows:

• (MSKE kx)(r): Let k := SKE.KeyGen(1η, r). Return

(cid:14)k, τ kx

SKE

(cid:15)

• (MSKE Ex)(ˆk, m)(r): Parse ˆk as (cid:14)k, τ kx
(cid:15)
SKE.Enc(k, m, r) and return (cid:14)c, τ ciphertext

SKE

SKE

(cid:15). Let c :=

Intuitively, the validSKE predicate guarantees that all keys
that may be used by the adversary later are generated dur-
ing initialization (i.e., with the init query). We only allow
static corruption of keys, i.e., the adversary has to decide
which keys are honest and which are corrupted at this stage.
Keys may only be used for encryption and decryption. This
implicitly prevents key cycles.

Theorem 3. Let M be a symbolic model and I a de-
duction sound implementation of M. If (MSKE,ISKE) and
(M,I) are compatible, then I ∪ ISKE is a deduction sound
implementation of M ∪ MSKE.
7.3 Macs

In this section we show that any deduction sound imple-
mentation can be extended by a mac scheme. More precisely,
we require a strongly EUF-CMA secure mac scheme [5].
We ﬁrst deﬁne the symbolic model (TMAC,≤MAC, ΣMAC,DMAC)
for macs. The signature ΣMAC features the function symbols

k : τ k

MAC

mac : τ k

MAC × (cid:4) → τ mac

MAC

for x ∈ {c, h}. The randomized function symbol k of arity
τ k
MAC represents keys. The randomized function symbol mac
of arity τ k
MAC represents the mac of a message.
To complete the formal deﬁnition we set the types

× (cid:4) → τ mac

MAC

TMAC := {(cid:4), τ k

MAC}
MAC, τ mac

All introduced types are direct subtypes of the base type
(cid:4) (this deﬁnes ≤MAC). The deduction system captures the
security of macs
DMAC :=

l() m

l(),m)

(cid:5)

(cid:6)

mac

k

,

macla (k l(),m)

ˆl(k
m

These rules are valid for arbitrary labels l, ˆl ∈ labels and
adversarial labels la ∈ labelsA. The rules are backed up
by the requirement that macs reveal the message that was
signed and the intuition that the adversary can use known
keys to deduce macs under those keys.
We now give a concrete implementation IMAC for macs.
The implementation uses some strongly EUF-CMA secure
mac scheme (MAC.KeyGen, MAC.Mac, MAC.Vfy). As usual,
here MAC.KeyGen is a generation algorithm for key pairs,
MAC.Mac computes a mac and MAC.Vfy is a veriﬁcation
algorithm. Note that MAC.Mac is an algorithm that takes
three inputs: the key, the message to be authenticated and
the randomness that is used for computing the mac.

The computable interpretations of k and mac are as fol-

lows:

• (MMAC k )(r): Let k := MAC.Mac(1η, r). Return (cid:14)k, τ k
MAC
4Since the message m is of basetype, we require a scheme
with message space {0, 1}∗

.

(cid:15).

1268• (MMAC sig)(ˆk, m; r): Parse ˆk as (cid:14)k, τ k
MAC.Mac(k, m, r) and return (cid:14)σ, m, τ mac

MAC

(cid:15). Let σ :=
(cid:15).

MAC

Analogously to validSKE, the predicate validMAC guarantees

static corruption and the dedicated use of keys.

Theorem 4. Let M be a symbolic model and I be deduc-
tion sound implementation of M. If (MMAC,IMAC) and(M,I)
are compatible, then I ∪ IMAC is a deduction sound imple-
mentation of M ∪ MMAC.
7.4 Public key encryption
In this section we deﬁne a symbolic model MPKE for public
key encryption and a corresponding implementation IPKE
based on an IND-CCA secure public key encryption scheme.
Theorem 5 then restates the result from [13] that adding
public key encryption to a deduction sound implementation
preserves deduction soundness.
We brieﬂy introduce the symbolic model (TPKE, ≤PKE,
ΣPKE, DPKE) for public key encryption. The signature ΣPKE
features the function symbols
→ τ ekx

× (cid:4) → τ ciphertext
dk x : τ dkx
PKE
for x ∈ {h, c}. The deduction system captures the security
of public key encryption

encx : τ ekx
PKE

ek x : τ dkx
PKE

PKE

PKE

⎧⎪⎪⎨
⎪⎪⎩

DPKE :=

l
x() m

ek
la
x (ek l

x(),m) ,

enc

⎫⎪⎪⎬
⎪⎪⎭

enc

la
h

l
h(),m)

(ek
m

,

enc

l
c(),m)

ˆl
c(ek
m

These rules are valid for arbitrary labels l, ˆl ∈ labels and ad-
versarial labels la ∈ labelsA. Read from top left to bottom
right, the rules capture the intuition that the adversary can
use any honestly generated key to encrypt some term m, the
adversary knows the message contained in any adversarial
encryption and the adversary knows the message contained
in any encryption under a corrupted key. The implementa-
tion IPKE is deﬁned in a straightforward way analogously to
the primitives already discussed and is based on an arbitrary
IND-CCA encryption scheme [19].

Theorem 5. Let M be a symbolic model and I a de-
duction sound implementation of M. If (MPKE,IPKE) and
(M,I) are compatible, then I ∪ IPKE is a deduction sound
implementation of M ∪ MPKE.
7.5 Hash functions

In this section we deal with the composition of deduction
sound implementations of arbitrary primitives with hash
functions. We consider hash functions implemented as ran-
dom oracles [7]: in this setting calls to the hash function are
implemented by calls to a random function which can only
be accessed in a black-box way. We model this idea directly
in our framework. In the symbolic model model we consider
a symbolic function that is randomized and which is imple-
mented by a randomized function. We recover the intuition
that hash functions are deterministic by restricting the calls
that an adversary can make: for each term t, the adversary
can only call the hash function with the honest label l(t).
The symbolic model for hash functions is rather standard.
It is given by the tuple (THASH,≤HASH, ΣHASH,DHASH) where

THASH := {(cid:4), τHASH}

and τHASH ≤HASH (cid:4). The signature ΣHASH contains only a
randomized function H : (cid:4) → τHASH characterized by the
deduction rule:

(cid:5)

(cid:6)

DHASH :=

m

H l(m)

where l ∈ labelsH.

The implementation IHASH for hash functions is via a ran-
domized function: when called, the function simply returns
a random value, and we will require that it does so consis-
tently; Concretely (MHASH H )(m; r) returns (cid:14)r, τHASH(cid:15).

The open function for hash functions is described in Figure 6.

If the bitstring to be opened was not the result of a generate
call, then it returns garbage of types either τHASH or (cid:4), de-
pending on what c encodes. Otherwise, it will return the
entry in L that corresponds to c: by the requirements posed
by validHASH below this will be H l(t)(m) for some bitstring
m with L[[m]] = t.

A useful observation is that by the description above, the
library L will never contain an entry of the form (c, H l(m))
for some adversarial label l ∈ labelsA; moreover, if (c, H l(m))
is in L, thenl = l(t) for some t, and L[[m]] = t.
The validHASH predicate. For simplicity we require that no
hash is present in init requests (our results easily extend to
the case where this restriction is not present). In addition we
use the predicate validHASH to enforce deterministic behavior
of our hash implementation. We require that for any term t,
all occurrences of H(t) in generate and sgenerate requests use
the same label. Concretely, we demand that for any term t,
ˆl(t) are labeled with the honest
all generate requests for H
label ˆl = l(t). The choice of label is not important: we
could alternatively request that if H l1 (t) and H l2 (t) occur
in a generate requests, then l1 = l2.

Theorem 6. Let I be a deduction sound implementation
of M. If (MHASH,IHASH) and (M,I) are compatible, then
I∪IHASH is a deduction sound implementation of M∪MHASH
in the random oracle model.

The intuition behind this proof is simple: collisions due
to tagging occur only with probability given by the birthday
bound (so with negligible probability). Given an adversary
that wins the deduction soundness game for the composed
libraries, we construct an adversary that breaks deduction
soundness of (M,I, validI). This latter adversary simulates
the hash function via a randomized transparent function
with no arguments: a generate H l(t)(t) call will be imple-
mented by a generate call to f l(t)(). Due to validHASH the
knowledge set S does not contain any occurrence of H with a
dishonest label, hence the only ”useful” deduction soundness
rule which allows the adversary to learn/manipulate terms
with dishonest labels are not applicable (we can cut them
out of any deduction).

8. FORGETFULNESS

All the theorems from Section 7 have one important draw-
back: key material cannot be sent around as the valid predi-
cates forbid keys from being used in non-key positions. This
takes the analysis of a large class of practical protocols (e.g,
many key exchange protocols) outside the scope of our re-
sults. The problem is that deduction soundness does not
guarantee that no information about non-DY terms is leaked
by the computational implementation. E.g., we could think

1269of a deterministic function symbol f that takes arguments
n
of type nonce with only the rule
f (nl()) . An implementa-
tion of f could leak half of the bits of its input and still
be sound. However, to send key material around, we need
to rely on the fact that information theoretically nothing is
leaked about the suitable positions for keys.

l()

To solve this problem, we introduce forgetful symbolic
models and implementations. A forgetful symbolic model
features function symbols with positions that are marked as
being forgetful. The corresponding implementation has to
guarantee, that no information about the arguments at these
positions will be leaked (except their length). Before we for-
malize these concepts we extend the framework developed
earlier in the paper with several technical details.

To allow the handling of forgetful positions, extend the
deﬁnition for hybrid terms with function symbols carrying
an honest label in the library. Let f be a function symbol
of arity ar(f ) = τ1 × . . . × τn → τ . Then a hybrid term of
f may be f l(a1, . . . , an) where each ai is either a bitstring
from [[τi]] or a term of typeτ i for forgetful positions i. For
normal positions ai must be a bitstring from [[τi]] as usual.
The deﬁnitions for the completeness of a library L and L[[c]]
are changed accordingly.

Forgetful symbolic models and implementations. We
say that a symbolic model M is a forgetful symbolic model if
arguments of a function symbol may be marked as forgetful.
In order to formalize forgetful implementations, the compu-
tational counterpart of forgetful positions, we introduce the
notion of an oblivious implementation.

Definition 3

(oblivious implementation). Let M
be a forgetful symbolic model. I = (M , [[·]], len, open, valid)
is an oblivious implementation of M if I is an implemen-
tation of M with a slightly changed signature: For each
function symbol f ∈ Σ with arity ar(f ) = τ1 × . . . × τn → τ
the signature of (M f ) is θ(τ1)×···×θ (τn)×{0, 1}η → [[τ ]]
where θ(τi) = N if the ith argument of f is forgetful and [[τi]]
otherwise.

Intuitively, oblivious implementations for all forgetful posi-
tions, take as input natural numbers; these will be the length
of the actual inputs on the forgetful positions.

As indicated above, a forgetful implementation is one
which is indistinguishable from an oblivious implementation.
To formally deﬁne the notion we introduce a distinguishing

game FINbM(ν),I(ν),I(ν),A(η) where an adversary A tries to

distinguish between the case when he interacts with the real
implementation, or with an alternative implementation that
is oblivious with respect to all of the forgetful arguments.
We say that an implementation is forgetful, if there exists an
oblivious implementation such that no adversary succeeds
in this task. Due to lack of space the formal deﬁnition of
FIN is in the Appendix.

Definition 4

(forgetful implementation). We say
that an implementation I = (M, [[·]], len, open, valid) is a
forgetful implementation of a forgetful symbolic model M
if there is an oblivious implementation I = (M , [[·]], len,
open, valid) such that for all for all parametrized trans-
parent symbolic models Mtran(ν) and for all parametrized
transparent implementations Itran(ν) of Mtran(ν) such that

(M(ν),Itran(ν)) compatible with (M,I) we have that
0M∪Mtran(ν),I∪Itran(ν),I∪Itran(ν),A(η) = 1]
1M∪Mtran(ν),I∪Itran(ν),I∪Itran(ν),A(η) = 1]

Prob[FIN
−Prob[FIN

is negligible for every p.p.t. adversary A.

The intuition that encryption schemes are forgetful with
respect to their plaintexts is captured by the lemma below.
Consider the forgetful symbolic model MPKE as the symbolic
symbolic model MPKE from Section 7.4 where we mark the
message m for honest encryptions ench(ek , m) as forgetful.
Lemma 1. IPKE from Section 7.4 is a forgetful implemen-

tation of MPKE.

Sending keys around. To be able to consider the case
when symmetric keys are sent encrypted we introduce an
extension of the model for symmetric key encryption of
Section 7.2. The extension is that the validity predicate
(which controls the valid queries by the adversary) can now
depend on a signature Σ that contains functions with forget-
ful positions. The new validity predicate allows for standard
generation of keys for symmetric encryption (with the same
restrictions as those in Section 7.2), but in addition it also
allows for generate requests that contain occurrences of sym-
metric keys under functions from signature Σ, as long as the
occurrences are on forgetful positions. For concreteness, let
validSKE[Σ] be the predicate obtained from valid as described
above.

The composition theorem that we prove in this case is that
any deduction sound implementation of Σ that is forgetful
can be extended with symmetric key encryption. We em-
phasize that the added value over the results of Section 7.2
is that the validity predicate is more relaxed, and allows for
keys to occur in non-key positions. We therefore prove the
following theorem.

Theorem 7. Let M be a forgetful symbolic model and I
be a forgetful deduction sound implementation of M. Let
Σ be the signature of M, and let validSKE[Σ] be the validity
predicate for ISKE. If (MSKE,ISKE) and (M,I) are compati-
ble and the valid predicate of I does not depend on function
symbols from ΣSKE, then I ∪ ISKE is a deduction sound im-
plementation of M ∪ MSKE.
As an application of the above theorem we have the follow-
ing. Since the implementation for public key encryption IPKE
from Section 7.4 is a forgetful deduction sound implementa-
tion for the forgetful symbolic model MPKE (by Lemma 1),
(MPKE,IPKE) can be composed with (MSKE,ISKE). The va-
lidity predicate for the resulting composition allows for ad-
˜l
versary queries of the form “generate enc
h())”. In-
tuitively, this corresponds to sending around symmetric keys
encrypted under asymmetric keys in a protocol.

ˆl
h(ek l

h(), k

Next, we show that the composition of a forgetful de-
duction sound implementation with a secret-key encryption
preserves forgetfulness (Theorem 8). Let MSKE be the for-
getful symbolic model based on MSKE when we mark the
message m for honestly generated encryptions under honest
h(), m) as a forgetful position and let ISKE[Σ] be
keys E
an implementation of MSKE. Then the following holds:

ˆl
h(k l

Theorem 8. Let M be a forgetful symbolic model and I
be a forgetful deduction sound implementation of M. Let

1270Σ be the signature of M and validSKE[Σ] be the predicate for
(MSKE,ISKE).
If (MSKE,ISKE) and (M,I) are compatible
then I ∪ ISKE is a forgetful implementation of M ∪ MSKE

Since Theorems 7 and 8 hold for the particular case when
(M,I) = (MSKE,ISKE), by successive applications we obtain
a framework in which we include, incrementally, multiple
encryption schemes. In the resulting framework symmetric
keys can be encrypted under other symmetric keys in a hi-
erarchical fashion. The hierarchy is imposed by the order
in which schemes are added (the keys of the latter can be
encrypted under the keys of the former, but not the other
way around).

A related important observation is that it seems diﬃcult
to consider more ﬂexible predicates that allow for the occur-
rence of keys on arbitrary forgetful positions.

The reason is that if we do not make the predicate for the
symmetric encryption scheme depend on the signature of
the model to which we add symmetric encryption, it would
be impossible to detect the occurrence of encryption cycles.
For instance, assume that Σ contains a function symbol f
with a forgetful second position. Do the terms f
h())
and E
) contain a key cycle? We cannot tell without
(cid:2)
knowing the implementation of f and t

˜l
h(k l

h(), t

(cid:2)

(cid:2)

ˆl(t

, k l

.

9. ACKNOWLEDGEMENTS

The research leading to these results has received fund-
ing from the European Research Council under the Euro-
pean Union’s Seventh Framework Programme (FP7/2007-
2013) / ERC grant agreement number 258865 (ERC ProSe-
cure project). This work was additionally supported in part
by ERC Advanced Grant ERC-2010-AdG-267188-CRIPTO.
Florian B¨ohl was supported by MWK grant “MoSeS”.

10. REFERENCES
[1] M. Abadi and P. Rogaway. Reconciling two views of

cryptography (the computational soundness of formal
encryption). In Proc. 1st IFIP International
Conference on Theoretical Computer Science
(IFIP–TCS’00), volume 1872 of LNCS, pages 3–22,
2000.

[2] M. Backes and B. Pﬁtzmann. Symmetric encryption in

a simulatable Dolev-Yao style cryptographic library.
In Proc. 17th IEEE Computer Science Foundations
Workshop (CSFW’04), pages 204–218, 2004.

[3] M. Backes, B. Pﬁtzmann, and M. Waidner. A
composable cryptographic library with nested
operations (extended abstract). In Proc. of 10th ACM
Conference on Computer and Communications
Security (CCS’05), pages 220 – 230, 2003.

[4] M. Backes, B. Pﬁtzmann, and M. Waidner. Symmetric

authentication within simulatable cryptographic
library. In Proc. 8th European Symposium on Research
in Computer Security (ESORICS’03), Lecture Notes
in Computer Science, pages 271–290, 2003.

[5] M. Bellare, O. Goldreich, and A. Mityagin. The power

of veriﬁcation queries in message authentication and
authenticated encryption. IACR Cryptology ePrint
Archive, 2004:309, 2004.

[6] M. Bellare and C. Namprempre. Authenticated

encryption: Relations among notions and analysis of

the generic composition paradigm. J. Cryptology,
21(4):469–491, 2008.

[7] M. Bellare and P. Rogaway. Random oracles are

practical: A paradigm for designing eﬃcient protocols.
In D. E. Denning, R. Pyle, R. Ganesan, R. S. Sandhu,
and V. Ashby, editors, ACM Conference on Computer
and Communications Security, pages 62–73. ACM,
1993.

[8] F. B¨ohl, V. Cortier, and B. Warinschi. Deduction
soundness: Prove one, get ﬁve for free. Cryptology
ePrint Archive, Report 2013/457, 2013. Full version of
this paper. http://eprint.iacr.org/.

[9] H. Comon-Lundh and V. Cortier. Computational

soundness of observational equivalence. In Proceedings
of the 15th ACM Conference on Computer and
Communications Security (CCS’08), Alexandria,
Virginia, USA, Oct. 2008. ACM Press.

[10] V. Cortier, S. Kremer, R. K¨usters, and B. Warinschi.

Computationally sound symbolic secrecy in the
presence of hash functions. In Proceedings of the 26th
Conference on Fundations of Software Technology and
Theoretical Computer Science (FSTTCS’06), volume
4337 of LNCS, pages 176–187, Kolkata, India, 2006.
Springer.

[11] V. Cortier, S. Kremer, and B. Warinschi. A survey of

symbolic methods in computational analysis of
cryptographic systems. J. Autom. Reasoning,
46(3-4):225–259, 2011.

[12] V. Cortier and B. Warinschi. Computationally sound,
automated proofs for security protocols. In European
Symposium on Programming (ESOP’05), volume 3444
of LNCS, pages 157–171, Edinburgh, UK, 2005.
Springer.

[13] V. Cortier and B. Warinschi. A composable

computational soundness notion. In 18th ACM
Conference on Computer and Communications
Security (CCS’11), pages 63–74, Chicago, USA,
October 2011. ACM.

[14] A. Datta, A. Derek, J. C. Mitchell, V. Shmatikov, and

M. Turuani. Probabilistic Polynomial-time Semantics
for a Protocol Security Logic. In Proc. of 32nd
International Colloquium on Automata, Languages
and Programming, ICALP, volume 3580 of LNCS,
pages 16–29. Springer, 2005. Lisboa, Portugal.

[15] Y. Dodis, S. Goldwasser, Y. T. Kalai, C. Peikert, and

V. Vaikuntanathan. Public-key encryption schemes
with auxiliary inputs. In D. Micciancio, editor, TCC,
volume 5978 of Lecture Notes in Computer Science,
pages 361–381. Springer, 2010.

[16] F. D. Garcia and P. van Rossum. Sound and complete
computational interpretation of symbolic hashes in the
standard model. Theoretical Computer Science,
394:112–133, 2008.

[17] R. Janvier, Y. Lakhnech, and L. Mazar´e. Completing

the picture: Soundness of formal encryption in the
presence of active adversaries. In European Symposium
on Programming (ESOP’05), volume 3444 of LNCS,
pages 172–185. Springer, 2005.

[18] M. Naor and G. Segev. Public-key cryptosystems

resilient to key leakage. SIAM J. Comput.,
41(4):772–814, 2012.

1271[19] C. Rackoﬀ and D. R. Simon. Non-interactive

zero-knowledge proof of knowledge and chosen
ciphertext attack. In J. Feigenbaum, editor, CRYPTO,
volume 576 of Lecture Notes in Computer Science,
pages 433–444. Springer, 1991.

APPENDIX

openHASH(c, L)

if c ∈ [[THASH]] ∩ dom(L) then
else if c = (cid:14)h, τHASH(cid:15) then

return (c, L(c))

else

return (c, gl(c)

τHASH )

return (c, gl(c)(cid:3) )

FINbM(ν),I(ν),I(ν),A(η):

let S := ∅
let L := ∅
let T := ∅
R ← {0, 1}∗

(set of requested terms)
(library)
(trace of queries)
(random tape)

if b = 0 then

let generate := generateFIN

M ,R

else

let generate := generateM,R
Receive parameter ν from A

Figure 6: Open function for hash functions.

on request “init T, H” do

openSKE(c, L)

if c ∈ [[TSKE]] ∩ dom(L) then
return (c, L(c))
else if c = (cid:14)k, τ kx
return (c, gl(c)
τ kx
SKE

(cid:15) then
)

SKE

else if c = (cid:14)c

(cid:2)

SKE
for each (ˆk, k h

(cid:15) then
x ()) ∈ L do
(cid:15)

, τ ciphertext
parse ˆk as (cid:14)k, τ kx
let m := SKE.Dec(k, c
if m (cid:8)= ⊥ then

SKE

(cid:2)

)

return (c, E l(c)

(ˆk, m))

return (c, gl(c)

τ ciphertext
SKE

x
)

else

return (c, gl(c)(cid:3) )

Figure 7: Open function for secret key encryption.

generateFIN

M,R(t, L):

if for some c ∈ dom(L) we have L[[c]] = t then

else

return c
for i ∈ {1, n} do

if i is a forgetful argument then

let ci := len(ti)
let ai := ti

else

let (ci, L) :=generate M,R(ti, L)
let ai := ci

let r := R(t)
let c := (M f )(c1, . . . , cn; r)
let L(c) :=f l(a1, . . . , an)) (l ∈ labelsH)
return (c, L)

add “init T ” to T
if valid(T) then
let S := S ∪ T
let C := ∅
for each t ∈ T do

(list of replies)

let (c, L) := generate(t, L)
let C := C ∪ {c}

let (c, L) := generate(t, L)

for each t ∈ H do
send C to A
return 0 (A is invalid)

else

on request “sgenerate t” do

if valid(T+“sgenerate t”) then
let (c, L) := generate(t, L)

on request “generate t” do

add “generate t” to T
if valid(T) then
let S := S ∪ {t}
let (c, L) := generate(t, L)
send c to A
return 0 (A is invalid)

else

on request “parse c” do

let (t, L) := parse(c, L)
if S (cid:10)D t then
send t to A
return 1 (A produced non-Dolev-Yao term)

else

(cid:2)
on request “guess b

(cid:2)
if b = b

then

” do
return 1 (A wins)
return 0 (A looses)

else

Figure 8: The generate function for an oblivious im-
plementation (t is of the form f l(t1, . . . , tn) (with pos-
sibly n = 0 and no label l for deterministic function
symbols f )). The requirements for the input t are
those of the normal generate function.

Figure 9: Indistinguishability game for forgetful im-
plementations.

1272