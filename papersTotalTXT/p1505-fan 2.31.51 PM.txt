Attacking OpenSSL Implementation of ECDSA with a Few

Signatures

State Key Laboratory of

Luoyang University of Foreign

School of Computer Science

Wenbo Wang

Qingfeng Cheng

Shuqin Fan

Cryptology

P.O. Box 5159

Beijing, 100878, P.R.China

fansq@sklc.org

Languages

Luoyang, Henan, P.R.China

&

State Key Laboratory of

Cryptology

P.O. Box 5159

and Technology
Xidian University

Xi’an, Shanxi, P.R.China

&

Luoyang University of Foreign

Languages

Beijing, 100878,P.R.China
wangwenbo0305@-

Luoyang, Henan, P.R.China
qingfengc2008@sina.com

sina.com

ABSTRACT
In this work, we give a lattice attack on the ECDSA imple-
mentation in the latest version of OpenSSL, which imple-
ment the scalar multiplication by windowed Non-Adjacent
Form method. We propose a totally di(cid:11)erent but more ef-
(cid:12)cient method of extracting and utilizing information from
the side-channel results, remarkably improving the previous
attacks. First, we develop a new e(cid:14)cient method, which can
extract almost all information from the side-channel results,
obtaining 105.8 bits of information per signature on average
for 256-bit ECDSA. Then in order to make the utmost of our
extracted information, we translate the problem of recover-
ing secret key to the Extended Hidden Number Problem,
which can be solved by lattice reduction algorithms. Final-
ly, we introduce the methods of elimination, merging, most
signi(cid:12)cant digit recovering and enumeration to improve the
attack. Our attack is mounted to the secp256k1 curve, and
the result shows that only 4 signatures would be enough to
recover the secret key if the Flush+Reload attack is im-
plemented perfectly without any error,which is much better
than the best known result needing at least 13 signatures.

CCS Concepts
•Security and privacy → Digital signatures; Crypt-
analysis and other attacks; Side-channel analysis and
countermeasures;

Keywords
ECDSA; OpenSSL; lattice attack; windowed Non-Adjacent
Form; Extended Hidden Number Problem; Flush+Reload
attack

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c⃝ 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978400

1.

INTRODUCTION

The Elliptic Curve Digital Signature Algorithm (ECDSA)
[14] which was (cid:12)rst proposed by Scott Vanstone [27] in 1992,
is the most popular signature scheme due to its small key
size and high security. It was included in many standards,
including the ISO standard, the ANSI standard, the IEEE
standard, and FIPS, etc. ECDSA has been widely used in
many cases, such as the Austrian Citizen Card { Austrian e-
ID [11], the Apple’s CommonCrypto framework (as included
in iOS versions 7.1.2 through 8.3), OpenSSL[1], etc. The
Bitcoin [19], a decentralized electronic currency system, also
relies on ECDSA to authenticate transactions.

The mathematical basis for the security of ECDSA is the
computational intractability of the elliptic curve discrete log-
arithm problem (ECDLP). However, most real-world cryp-
tographic vulnerabilities do not stem from a weakness in
the hardness assumption, but rather from implementations
issues such as side-channel attacks, software bugs or design
(cid:13)aws.

One of the most popular software implementations of ECD-
SA is the OpenSSL [1] implementation. As a commonly used
open-source cryptographic library, OpenSSL has been wide-
ly used to implement Secure Sockets Layer (SSL) protocol
and Transport Layer Security (TLS) protocol, as well as
OpenPGP and other cryptographic standards. In the lat-
est version of OpenSSL (version 1.0.2h, published in May 3,
2016), the scalar multiplication in ECDSA is implemented
using the windowed non-adjacent form (wNAF) algorithm
[16, 7, 24] by default.

After the seminal work of side-channel attack by Kocher
et al. [15], more recent works [22, 2, 4, 25, 5, 30, 13] focus
on cache side-channel attacks on software implementations.
In 2013, Yarom and Falkner [29] proposed a new method of
cache side-channel attack, the Flush+Reload attack.
It
targets the Last Level Cache (LLC) so that the attack can
be mounted between di(cid:11)erent cores. The Flush+Reload
attack can be used to observe the execution of ECDSA in
OpenSSL, being able to get the sequence of point additions
and doubling (denoted as the double-and-add chain) used
to executes the scalar multiplication, which can be further
utilized to recover the ECDSA secret key. In fact, a small
leakage of information on the scalar (the ephemeral key k) in

1505each signature can be combined to obtain the entire secret
key.

Generally speaking, there are mainly three aspects that
may a(cid:11)ect the attacks on ECDSA implementation: the (cid:12)rst
one is the implementation of scalar multiplication, which in-
cludes the method of wNAF representation, the double-and-
add method, the sliding-window method, etc.; the second
one is the method of side-channel attack determining what
information can be achieved; the third one is the way of ex-
tracting and utilizing the achieved information. Take the
Flush+Reload attack for example. If the double-and-add
method is used, then obtaining the double-and-add chain
using the Flush+Reload attack means that the scalar it-
self can be fully recovered; if the sliding-window method is
used, then according to [10], the secret key can be easily
broken since the double-and-add chain helps to directly de-
termine some discrete bits of the ephemeral key. For the
wNAF representation, as it converts a scalar into a chain of
signed digit, it is not easy to obtain direct information on
the bits of the scalar from the double-and-add chain due to
the existence of negative digits.

In this paper, we focus on the ECDSA implementation
of OpenSSL using the wNAF representation, assuming that
the Flush+Reload attack is used to obtain the double-and-
add chain of the scalar multiplication. Then here comes the
question:

Question: How can we take the utmost of the double-
and-add chain in order to extract the information of the
ephemeral key as much as possible? How should we fully
utilize the extracted knowledge so that we can recover the
ECDSA secret key using as few signatures as possible?

Analysis: Though it is not easy to obtain direct informa-
tion of the ephemeral key with the wNAF method, several
works give the methods of extracting and utilizing infor-
mation from the double-and-add chain. In 2014, Benger et
al. extracted several least signi(cid:12)cant bits (LSBs) from the
double-and-add chain [3]. But the number of bits extracted
from each signature is very small, only average number of 2
bits (
sults in more than 200 signatures needed to recover a 256-bit
secret key.

∑∞
i=1 i/2i ≈ 2) information can be obtained, which re-

In 2015, van de Pol et al. derived a more e(cid:11)ective way
of exacting information from the double-and-add chain [26].
As they stated that, it is able to extract average 47.6 bits per
signature, recovering the secret key of the secp256k1 curve
with 13 signatures, assuming a perfect Flush+Reload at-
tack without error. Their method of extracting information
relies on the property of some special curves, i.e., the order
q of the base point is a pseudo-Mersenne prime, which can
be expressed as 2n − ε, where |ε| < 2p, p ≈ n/2. They can
extract information from consecutive non-zero digits whose
positions are between p+1 and n, which cover about a half of
the double-and-add chain. While according to the ECDSA s-
tandards, such curves with order q being a pseudo-Mersenne
prime is just a small proportion of all the curves. In the rec-
ommended curves of FIPS [8], there are other curves whose
order q is a generalized Mersenne prime that cannot be
expressed as a pseudo-Mersenne prime, in which case the
method of [26] does not work.

Both the above works utilize the extracted information
to recover the secret key by a popular lattice method. As
in [12, 20, 21, 18], they (cid:12)rst use the extracted information
to compute triples, each deriving a Hidden Number Prob-

lem (HNP) instance, then the secret key can be recovered
by solving the HNP, which can be further converted to the
closest vector problem (CVP) in a suitable lattice. How-
ever, as the author stated, the triples used in [26] are not
independent, which contradicts the basic requirement of [21]
that the triples are taken uniformly and independently from
a distribution that satis(cid:12)es some conditions. The existence
of correlated triples may lead to an error solution, which
may decrease the success probability.

Our Answer: We will give a better answer to the above
question in this work. Using our new method of extracting
information from the double-and-add chain, we are able to
obtain as much as 105.8 bits of information per signature
for 256-bit ECDSA on average. We believe that our method
extract almost all the available information of the double-
and-add chain. Moreover, by using the Extended Hidden
Number Problem (EHNP) instead of HNP, it seems that we
are able to fully utilize our extracted information.

Contribution. In this paper, we attack the ECDSA al-
gorithm implemented by OpenSSL using the wNAF repre-
sentation with the help of the Flush+Reload cache side-
channel attack. We probe into the wNAF representation
of the ephemeral key k, developing a totally new way of
extracting information from the result of a perfect double-
and-add chain. Unlike the previous methods of extracting
information from partial double-and-add chain, we take ad-
vantage of all positions of digits. We are able to extract
as much information as possible, obtaining on average 105.8
bits per signature for 256-bit ECDSA, being 2 times more
than that in [26]. This naturally leads to the fact that the
number of signatures needed to recover the ECDSA secret
key is remarkably reduced. In order to make the utmost of
the information we extract, we translate the problem of se-
cret key recovery to the EHNP (instead of the HNP) which
can be converted to the approximate shortest vector prob-
lem (SVP). Our attack has the following advantages: it does
not rely on the property of any special elliptic curve, so the
attack can be mounted to all types of curves; each signa-
ture is used only once to construct an EHNP instance, thus
avoiding the problem of not being independent; all position-
s of the double-and-add chain are utilized instead of just
a proportion of it. We further introduce the methods of
elimination, merging, most signi(cid:12)cant digit recovering and
enumeration to substantially increase the success probability
of secret key recovery.

We mount our attack to the secp256k1 curve in this pa-
per { actually it can be applied to all types of curves. The
results shows that if the Flush+Reload attack is imple-
mented perfectly without any error, 4 signatures would be
enough to recover secret key with probability being about
8%, 5 signatures with probability being about 37.5%, 6 sig-
natures with probability being about 90%, and 7 signatures
with probability being about 94%. While considering of the
possibility of not conducting a perfect Flush+Reload at-
tack, whose probability is about 42.3% [26], the actual num-
ber of signatures needed to obtain 4, 5, 6 and 7 signatures
is separately 7, 9, 11 and 13.
In theory, it is possible to recover the 256-bit ECDSA se-
cret key with 3 signatures (3 × 105.8 > 256). Due to the
limited capabilities of computation and lattice reduction al-
gorithms, the best result we can get is that 4 signatures are
enough to recover the secret key. Comparisons of our attack
with the attack of [3] and [26] are presented in Table 1. As

1506Table 1: Comparison of our results and the results
of [3] and [26]

(Nsig denotes number of signatures assuming perfect

Flush+Reload attack results are obtained; p denotes the
success probability; Nsig/p denotes the ratio of the number

of signatures and the success probability)

[3]

[26]*

Attack Nsig
200
460
13
4
5
6
7

ours*

p

Nsig/p
3.5% 5714.28
92%
54%
8%

900
24.07

50

37.5%
90%
94%

13.33
6.67
7.45

(*Note: Assuming perfect Flush+Reload attack results

are obtained)

we can see that, both the number of signatures we need to
recover a 256-bit ECDSA secret key and the ratio of the
number of signatures and the success probability of our at-
tack is much smaller, which indicates that our attack is far
more e(cid:14)cient.
Roadmap. The rest of the paper is organized as follows:
In Section 2, we brie(cid:13)y introduce the background of ECD-
SA, OpenSSL implementation using wNAF and the Flush+
Reload side-channel attack, the EHNP is also introduced
as it is the basis of our attack. Then in Section 3, our lattice
attack method is introduced based on the EHNP and the w-
NAF representation, with knowledge of perfect side-channel
attack results. We further introduce some improvements to
our attack, including the methods of elimination, merging,
MSD recovering and enumeration.
In Section 4, the con-
crete experiment results are stated, concerning the success
probability and consuming time.
2. PRELIMINARIES

In this section we describe the basic knowledge of ECD-
SA and its implementation in OpenSSL using the wNAF
representation, as well as the Flush+Reload attack. The
EHNP is also introduced for it is an important tool of our
attack.
2.1 The Elliptic Curve Digital Signature Al-

gorithm

The Elliptic Curve Digital Signature Algorithm (ECDSA)
[14] is the elliptic curve analogue of the Digital Signature
Algorithm (DSA) [8], adapting one step of the DSA from the
multiplicative group of a (cid:12)nite (cid:12)eld to the group of points
on an elliptic curve.
Let E be an elliptic curve de(cid:12)ned over a (cid:12)nite (cid:12)eld Fp
where p is prime and G ∈ E be a (cid:12)xed point of a large prime
order q. Both G and q are publicly known. The secret key
of a signer is an integer 0 < α < q, and the public key is
the point Q = αG. Given a hash function H, the ECDSA
signature of a message m is computed as follows:

1. Randomly choose an ephemeral key 0 < k < q.
2. Compute the point (x, y) = kG, and let r ≡ x mod q;

Algorithm 1: Conversion to wNAF
Input: Scalar k and window size w
Output: k in the wNAF: e0, e1, e2, . . . ev

if k mod 2 = 1 then

ei = k mod 2w+1
if ei > 2w then
ei = ei − 2w+1

1: i = 0
2: while k > 0 do
3:
4:
5:
6:
7:
8:
9:
10:
end if
11:
k = k/2
12:
13:
i = i + 1
14: end while

end if
k = k − ei

ei = 0

else

The pair (r, s) is the ECDSA signature of the message m.
Given the knowledge of the ephemeral key k and all the
known information of (s, r, m), the secret key can be easily
recovered by

−1(s · k − H(m)) mod q .

α = r

(1)
2.2 The Windowed Non-Adjacent Form Rep-

resentation

Let us (cid:12)rst describe the implementation of scalar multi-

plication with windowed Non-Adjacent Form (wNAF).

In OpenSSL, if scalar multiplication kG is to be computed,
a window size w is (cid:12)rstly chosen (for curve secp256k1, w =
3), after which precomputation and storage of the points
{±G,±3G, . . . ,±(2w − 1)G} is executed. Then the scalar k
is converted to the Non-Adjacent Form (NAF), represented
by a sequence of digits ei, where ei ∈ {0,±1,±3, . . . ,±(2w−
1)}. Every non-zero element is followed by at least w ze-
ro values. Algorithm 1 introduces the concrete method for
∑
converting a scalar into its Non-Adjacent Form. We denote
those non-zero digits among {ei} as {ki}l
i=1, where l is the
number of non-zero digits. Denote the position of each ki as
i=1 ki · 2(cid:21)i .
λi, then the scalar k can be rewritten as k =
We call kl the most signi(cid:12)cant digit (MSD) and kl−1
the second MSD. After converting k to the wNAF repre-
sentation, the scalar multiplication kG is executed as the
Algorithm 2 describes.
In the actual OpenSSL execution,
instead of computing kG, it adds q or 2q to the ephemeral

key to make sure that k is ⌊log2 q⌋ + 1 bit long. This method

can resist the Brumley and Tuveri remote timing attack [5].
In most cases, the multiplication is done as (k + q)G.

l

Note that OpenSSL uses the modi(cid:12)ed wNAF representa-
tion instead of the generalized one as stated in Algorithm
1 to avoid length expansion in some cases and to make ex-
ponentiation more e(cid:14)cient. The representation of modi(cid:12)ed
wNAF is very similar to the wNAF. Each non-zero coe(cid:14)-
cient is followed by at least w zero coe(cid:14)cients, except for the
most signi(cid:12)cant digit which is allowed to violate this condi-
tion in some cases. As the use of modi(cid:12)ed wNAF a(cid:11)ects the
attack results little, we only consider the case of the wNAF
for simpli(cid:12)cation.

if r = 0, then go back to the (cid:12)rst step.

3. Compute s = k

−1 (H(m) + r · α) mod q; if s = 0, then

go back to the (cid:12)rst step.

1507Algorithm 2: OpenSSL implementation of

kG using wNAF

Input: Scalar k in the wNAF e0, e1, . . . , ev and

precomputed points
{±G,±3G, . . . ,±(2w − 1)G}

Output: kG

1: Q = G
2: for i = v, v − 1, . . . , 0 do
3:
4:
5:
6:
7: end for

Q = 2 · Q
if ei ̸= 0 then
Q = Q + eiG

end if

2.3 The Flush+Reload Attack on wNAF Rep-

resentation

According to Algorithm 2, if the if-then block is ran into,
digit ei is non-zero, and vice versa. So if we are able to
detect whether the if-then block is executed or not during
each loop of for-do, we can determine whether ei is zero or
not. The Flush+Reload attack is just a perfect tool for
doing this.

The Flush+Reload attack was (cid:12)rst proposed by Yarom
and Falkner [29]. Unlike most of the other side-channel at-
tacks that target the L1 cache level [4, 25, 30] or the branch
prediction bu(cid:11)er [2], it targets LLC, which is shared be-
tween cores, thus making it possible to mount the attack
between di(cid:11)erent cores. Using the Flush+Reload attack,
Yarom and Falkner snooped on the square-and-multiply ex-
ponentiation in the GnuPG implementation of RSA and be-
ing able to recover the RSA secret key [29]. They also use
the Flush+Reload attack to recover 95% of the ephemer-
al key of ECDSA which is implemented by OpenSSL over
characteristic two (cid:12)elds using the Montgomery ladder for
scalar multiplication [28], which means that only one sig-
nature would be enough to fully recover the ECDSA secret
key.

The Flush+Reload attack can be used to obtain the
double-and-add chain of the OpenSSL implementation of kG
using wNAF. It uses a spy program to monitor cache hit-
s/misses so that we can determine whether the program has
ran into the if-then block of Algorithm 2. Denote \A" for
an add operation in the if-then block, and \D" for a double
operation. Under the assumption of a perfect side-channel,
we may obtain a double-and-add chain of information like
this (assume that the window size w = 3, and the sequence
is written from the higher index to the lower index):

\ADDDADDDDDDAD . . . . . . DDDADD"

In fact, a double operation is done every time before the
if-then block is executed, so there is a \D" right before each
\A", but we omit these \D"s for simpli(cid:12)cation.

From the wNAF representation rule introduced in Section
2.2, though we can decide a digit is zero or not according
to the double-and-add chain of a scalar multiplication, it is
impossible to determine the sign of the non-zero digit.
If
the non-zero digit is negative, there exists carries into the
next bits. So it is not easy to get direct information on the
value of bits from the double-and-add chain in most cases
but some positions of non-zero digits.

2.4 The Extended Hidden Number Problem

The Extended Hidden Number Problem (EHNP) intro-
duced in [10] is originally used to recover the secret key
of a DSA signature, given some discrete leaked bits of the
ephemeral key.

Let N be a prime number. Given u congruences

li∑

βix +

j=1

ai;jki;j ≡ ci mod N, 1 ≤ i ≤ u ,

where ki;j and x are unknown variables satisfying 0 ≤ ki;j ≤
2"i;j and 0 < x < N , βi, ai;j, ci, li and εi;j are all known.
The EHNP is to (cid:12)nd the unknown x (the hidden number)
which satis(cid:12)es the conditions above.

For the OpenSSL implementation of DSA signature with
the method of sliding window exponentiation algorithm (on-
ly available for OpenSSL versions up to 0.9.7g), using the
\squaring-and-multiplication" chain observed from the side-
channel attack, it is able to get many discrete bits of the
ephemeral key directly. Then the problem of recovering the
secret key can be transformed to the EHNP, which can be
further converted to the approximate SVP in some suitable
lattice.

3. ATTACKING ECDSA

As introduced in Section 2.3, it is commonly di(cid:14)cult to
extract information directly from the double-and-add chain.
In this section, we propose a totally new way of deriving
information from the double-and-add chain, being able to
extract on average 105.8 bits of the ephemeral key per signa-
ture for ECDSA with 256-bit secret key. After that, we give
an e(cid:14)cient way of utilizing the gained information, trans-
lating the problem of recovering ECDSA secret key to the
EHNP, which can be further transformed to the problem of
solving approximate SVP in some lattice using the lattice
reduction algorithms.

Assuming we get the entire double-and-add chain of the
scalar multiplication without error after a perfect Flush+
Reload attack. Suppose in the double-and-add chain, there
∑
are l number of \A"s, whose positions are separately λi (1 6
i 6 l) counted from the lower index. Then we have k =
i=1 ki2(cid:21)i , where ki ∈ {±1,±3, . . . ,±(2w − 1)} is unknown
and its position in the wNAF representation {ej}v
j=1 of k is
just λi.

l

3.1 Extracting Information
Since the i-th non-zero digit ki of the ephemeral key is
always an odd number, we can rewrite it as ki = 1 + 2 · k
′
i,
where −2w−1 6 k
i 6 2w−1 − 1. Let di = k
i + 2w−1, then
′
′
0 6 di 6 2w − 1. So the ephemeral key k can be rewritten
l∑
as

l∑
(1 + 2 · k

i) · 2(cid:21)i
′

(2)

k =

i=1

ki · 2(cid:21)i =
l∑
i=1 2(cid:21)i −∑

= k +

i=1

i=1

di · 2(cid:21)i+1 ,

l

i=1 2(cid:21)i+w.

∑

where k =

l

1508It is known that there are approximately (⌊log2 q⌋+1)/(w+
2) − 1 = 50.4 non-zero digits in a double-and-add chain of a
257-bit1nonce k + q when w = 3.
From Equation (2), since 0 6 di 6 2w − 1, there are
approximately 50.4w = 151.2 bits being unknown, which
means we have on average (⌊log2 q⌋+1)−50.4w = 105.8 bits
information. In theory, three signatures would be enough to
recover the 256-bit secret key, as 3 × 105.8 = 317.4 > 256.
What’s needed to be added is that our method of extract-
ing information does not rely on any special property of
elliptic curves, we can extract on average 105.8 bits of infor-
mation per signature for any type of 256-bit elliptic curve.

3.2 Basic Attack

From Equation (1) we have αr − sk + H(m) ≡ 0 mod q.
Substituting k by Equation (2), we can get that there exists
an h ∈ Z such that

αr − l∑

(2(cid:21)j +1 · s)dj −(

j=1

)

sk − H(m)

The values of 0 < α < q, 0 6 dj 6 2w − 1 and h are

unknown, and others are known.
Suppose we successfully get u signature pairs (ri, si) of
message mi (1 6 i 6 u) using the same secret key α. From
Equation (3) we have the following u equations:



j=1

αr1 − l1∑
αri − li∑
αru − lu∑

j=1

j=1

······

(2(cid:21)1;j +1 · s1)d1;j −(
(2(cid:21)i;j +1 · si)di;j −(
(2(cid:21)u;j +1 · su)du;j −(
∑

······

)
s1k1 − H(m1)
)

siki − H(mi)

)
suku − H(mu)

+ h1q = 0

+ hiq = 0

+ huq = 0

(4)
where li is the number of non-zero digits of the i-th ephemer-
al key, λi;j is the position of the j-th non-zero digit ki;j of
li
j=1 2(cid:21)i;j +w and
the i-th ephemeral key, ki =
di;j = (ki;j − 1)/2 + 2w−1. The values of α, di;j and hi are
unknown.

j=1 2(cid:21)i;j −∑

li

We denote this EHNP instance as ECDSA-EHNP, which
can be converted to an approximate SVP using the method
introduced in [10]. For 1 6 i 6 u and 1 6 j 6 li, let
βi = siki − H(mi) mod q, ρi;j = 2(cid:21)i;j +1 · si mod q, and
µi;j be the value that 0 6 di;j 6 2(cid:22)i;j −1, which equals to w.
We use Equation (4) to construct a lattice L spanned by the
matrix M de(cid:12)ned by Equation (5), where δ is a parameter
with a proper value.

1As introduced previously, in the actual OpenSSL execution
of ECDSA, (k + q)G is done in most cases, we assume the
wNAF method is applied with (k + q)G. And the double-

and-add chain is obtained from a scalar of ⌊log2 q⌋ + 1 =

256 + 1 = 257 bits of a 256-bit ECDSA

+ hq = 0 .

(3)

Choice of δ.

(

In the lattice L = L(M ), there exists a vector

=

u
i=1 li.

,··· ,

du;1
2(cid:22)u;1

d1;l1
2(cid:22)1;l1

du;lu
2(cid:22)u;lu

δ − δ
2

δ − δ
2
,··· ,

d1;1
2(cid:22)1;1
δ − δ
2

δ − δ
2
,− δ
2

0,··· , 0,
α
q
δ − δ
∑
2

⃗w = (h1,··· , hu, α, d1;1,··· , d1;l1 ,··· , du;1,··· , du;lu ,−1) · M
,··· ,

)
,··· ,
∈ L
whose Euclidean norm satis(cid:12)es that ∥ ⃗w∥ 6 (cid:14)
T =
Note that there is another vector that is quite short, say
⃗v = (−r1,··· ,−ru, q, 0,··· , 0)·M = (0,··· , 0, δ, 0,··· , 0) ∈
∑
L, which is likely to be the (cid:12)rst vector of the reduced lattice
basis.
The lattice determinant is |L| = qu−1 · δT +2/2U +1, where
U =
i;jµi;j, and the dimension of L is n = T + u + 2. As
we can see, if the value of δ is appropriately chosen, vector
⃗w is very likely to be a short vector of L. So we can use the
lattice reduction algorithm like LLL [17] or BKZ [23] to get
the vector ⃗w, thus recovering the secret key α.

T + 2, where

√

2

As we state above, we need to set the value of δ appropri-
ately. A natural question is how to choose δ so that we can
recover the secrete key.

Actually, the value of δ is to adjust the target vector ⃗w
to be a short vector concerning the lattice M so that the
lattice reduction algorithm can (cid:12)nd it. Thus on one hand,
we need the target vector ⃗w to be short, while on the other
hand, the target vector can not be too short to be achieved
by the lattice reduction algorithm such as LLL and BKZ.

First, we need to ensure the target vector ⃗w to be rel-
atively short. Consider the Gaussian heuristic to estimate
the shortest vector in lattice, we have

√

λ1(L) ≈ GH(L) ≈

|L|1=n .

n
2πe

So if the ratio ∥ ⃗w∥/GH(L) is relatively small, ⃗w may be

relatively short.

While in the actual experiments, we need to adjust the
value of δ so that ⃗w is within the ability of the lattice reduc-
tion algorithm. In [9], Gamma and Nguyen gave a picture of
the actual behavior of lattice reduction algorithms by exper-
iments. For example, the length of the (cid:12)rst vector output
by the reduction algorithm BKZ with blocksize 20 is ap-
proximately (1.0128)n|L|1=n. So we choose the value of δ
such that the length of target vector ∥ ⃗w∥ ≈ (1.0128)n|L|1=n
and make a little adjustment to it to increase the success
probability if we use BKZ-20.
Note that if the dimension of the lattice is very low(6 70),
we need not to consider the ability of the lattice reduction
algorithm, since it behaves just like a SVP solver [9].
3.3 Analysis of the Basic Attack

Assume our attack is applied to the curve secp256k1.
According to Section 3.1, we can obtain on average 105.8 bits
of information per signature. So in theory, three signatures
would be enough to recover the 256-bit secret key.

We mount the attack with signatures being 3 to 7 sepa-
rately using the BKZ-20 algorithm, but the results turn out
to be very disappointing. Neither three signatures nor four
signatures can succeed. For (cid:12)ve signatures, we only succeed
once among 100 times of attacks, i.e., the success probability

1509q
ru

δ/q

δ/2(cid:22)1;1

q

r1
ρ1;1
...
ρ1;l1



. . .

. . .

. . .

β1

. . .

M =

ρu;1
...
ρu;lu
βu



(5)

. . .

δ/2(cid:22)1;l1

. . .

δ/2(cid:22)u;1

. . .

δ/2(cid:22)u;lu

δ/2

δ/2

. . .

δ/2

. . .

δ/2

. . .

δ/2

δ/2

4.

IMPROVEMENTS

⃗w

=

,

is 1%. When the attack is mounted to six and seven signa-
tures, the dimension of the lattice becomes too large for the
lattice reduction algorithm to execute, let alone obtain the
right solution. As there are average 50.4 non-zero digits on
average in the wNAF representation of each k, the dimen-
sion of the lattice is 50.4u + u + 2 = 51.4u + 2, which means
that, for u = 3, 4, 5, 6, . . . , the dimension of the lattice is
separately 157, 208, 259, 311, . . . . For u > 6, the dimension
is larger than 300, which makes it relatively hard for the
LLL algorithm or the BKZ algorithm to (cid:12)nd a short vector,
meanwhile it takes a relatively long time to execute a lattice
reduction algorithm.

We seek for solutions to make the lattice reduction algo-
rithm easier to (cid:12)nd the target vector and to increase the
success probability. One direct way is to reduce the lattice
dimension.
In order to do this, we use the method of e-
limination and merging to reduce the number of unknown
variables.

Furthermore, we carefully exploit the double-and-add chain
to recover the MSD and determine whether the second MSD
is positive or negative in some cases, which can be used to
not only decrease the dimension of lattice, but also increase
the determinant of the lattice. At last, we enumerate the
MSDs which can not be recovered, so we can further de-
crease the dimension, thus improve the success probability
with the sacri(cid:12)ce of a little more time.
In most of our improvements, we can decrease the ratio
∥ ⃗w∥/GH(L) so that the key recovery can be made easier.

4.1 Reducing Lattice Dimension

There are mainly two ways to reduce the dimension of
the lattice. The (cid:12)rst one is the method of elimination, and
the second one is to reduce the number of non-zero digits of
ephemeral key k, which we name as the method of merging.

4.1.1 Elimination
As observed from Equation (4), the secret key α can be
eliminated to establish a set of new equations, thus reducing
the lattice dimension of L.
Denote the i-th equation in simultaneous Equations (4)
as Ei. For 2 6 i 6 u, we compute r1Ei − riE1 and get the

following equations:

l1∑
(2(cid:21)1;j +1s1ri)d1;j − li∑

(2(cid:21)i;j +1sir1)di;j − γi + tiq = 0,

j=1

j=1

where γi = r1(siki − H(mi)) − ri(s1k1 − H(m1)) mod q.
0 6 d1;j, di;j 6 2(cid:22)i;j − 1 and ti are unknown. Let τj;i =
2(cid:21)1;j +1s1ri mod q (1 6 j 6 l1) and σi;j = −2(cid:21)i;j +1sir1
mod q (1 6 j 6 li). As before, we can construct a lattice
′
L
, which is de-
(cid:12)ned by Equation (6), where δ is again a parameter with an
appropriate value.

) spanned by the basis matrix M

= L(M

′

′

′
In lattice L
′

′

= L(M

u
i=1 li.

√

2

,··· ,

du;1
2(cid:22)u;1

T + 1, where
′

), there exists a vector

(
= (t2,··· , tu, d1;1,··· , d1;l1 ,··· , du;1,··· , du;lu ,−1) · M
′
0,··· , 0,
δ − δ
2
··· ,
du;lu
∑
2(cid:22)u;lu

.
Its Euclidean norm satis(cid:12)es that ∥ ⃗w
T =

)
,··· ,
d1;l1
2(cid:22)1;l1
∈ L
′

d1;1
2(cid:22)1;1
δ − δ
2

δ − δ
2
,− δ
2

δ − δ
2

′∥ 6 (cid:14)

′
The dimension of lattice L

) is n

= L(M

= T + u, 2
′
dimensions less than that of L, while the determinant of L
′| = qu−1· δT +1/2U +1, 1/δ times of that of lattice L.
being |L
Since δ is always a very small number, the method of elim-
ination reduces the dimension of the lattice and the length
of the target vector, meanwhile increase the determinant of
the lattice. As a result, the ratio of ∥ ⃗w∥/GH(L) is reduced,
which makes it easier for the lattice reduction algorithms to
(cid:12)nd the vector ⃗w
. On the other hand, the reduction of the
lattice dimension leads to a more e(cid:14)cient execution of the
lattice reduction algorithm.
Note that, unlike the case of the basic attack that exists
a very short vector ⃗v = (0,··· , 0, δ, 0,··· , 0), there is no
′
after the elimination, so the
similar vector in the lattice L
target vector ⃗w′ is likely to be the (cid:12)rst vector of a reduced
lattice basis.
4.1.2 Merging
The method of merging aims to reduce the number of
non-zero digits l of each ephemeral key k in Equation (2),
meanwhile keeping the number of unknown bits as small
In the language of lattice, it correspondingly
as possible.
′
reduces the dimension of lattice L or L
and keeping the
determinant as large as possible.

′

′

1510q

τ1;2
...
τl1;2
σ2;1
...
σ2;l2



. . .

. . .

. . .

. . .

γ2

. . .

q

τ1;u
...
τl1;u

σu;1
...
σu;lu
γu

′

M

=

δ/2(cid:22)1;1

. . .

δ/2(cid:22)1;l1

δ/2(cid:22)2;1

. . .

δ/2(cid:22)2;l2

. . .

δ/2(cid:22)u;1

. . .

δ/2

. . .

δ/2

δ/2

. . .

δ/2

. . .

δ/2

. . .

δ/2

δ/2

δ/2(cid:22)u;lu



(6)

The core idea is to merge two or more consecutive non-
zero digits as one new non-zero digit. The distance of two
adjacent non-zero digits in the wNAF form of k can be com-
puted as λi+1 − λi, where λi+1 − λi > w + 1 (1 6 i 6 l − 1).
From Section 3.1, di has a one-to-one correspondence with
the non-zero digit ki, the merging of digit di is equivalent to
the merging of ki, so we only consider the merging of digit
di. The position of di is de(cid:12)ned to be the same with that of
ki.

Theorem 1. For h > 1, suppose h + 1 consecutive digits
′
i. Then we have 0 6
di, ..., di+h are merged as a new digit d
i 6 2(cid:22)i − 1, where µi = λi+h − λi + w is de(cid:12)ned as the
′
d
window size of d

′
i.

Proof. Suppose that h + 1 consecutive digits are merged
i = di + 2(cid:21)i+1−(cid:21)i di+1 + 2(cid:21)i+2−(cid:21)i di+2 + ··· +
′
as one, i.e., d
2(cid:21)i+h−(cid:21)i di+h .

We can easily obtain the following inequalities:



0 6 di 6 2w − 1

0 6 2(cid:21)i+1−(cid:21)i di+1 6 2(cid:21)i+1−(cid:21)i+w − 2(cid:21)i+1−(cid:21)i
0 6 2(cid:21)i+2−(cid:21)i di+2 6 2(cid:21)i+2−(cid:21)i+w − 2(cid:21)i+2−(cid:21)i

······

0 6 2(cid:21)i+h−(cid:21)i di+h 6 2(cid:21)i+h−(cid:21)i+w − 2(cid:21)i+h−(cid:21)i

′
i 6 2(cid:21)i+h−(cid:21)i+w +
Adding the above inequalities gives 0 6 d
(2(cid:21)i+h−1−(cid:21)i+w − 2(cid:21)i+h−(cid:21)i ) + ··· + (2w − 2(cid:21)i+1−(cid:21)i ) − 1 6
2(cid:21)i+h−(cid:21)i+w − 1. This (cid:12)nishes the proof.

h

∑
Theorem 1 indicates that if h + 1 consecutive digits di, ...,
di+h are merged, the unknown bits increase from (h + 1)w
to λi+h − λi + w. It is easy to check that λi+h − λi + w =
j=1(λi+j − λi+j−1) > h(w + 1) + w and the equality
w +
holds if only if for all 1 6 j 6 h, λi+j − λi+j−1 = w + 1.
Heuristically, from Equation (4) and (5), the smaller the
number of unknown bits is, the larger the determinant of
corresponding lattice is, and the easier we can recover the
secret key. So those consecutive non-zero digits such that
the distance of each adjacent two non-zero digits is w + 1
are preferred to be merged.
In this case, the number of

unknown bits increase from (h + 1)w to (h + 1)w + h. 2 In
other word, the number of non-zero digits is decreased by
h at the cost of h-bit information loss, which equivalently
means the number of non-zero digits is decreased by 1 at
the cost of 1-bit information loss. This is the best we can
achieve.

From the above analysis, we propose a strategy of merg-
ing, in which only the consecutive non-zero digits such that
the distance of each two adjacent non-zero digits is w + 1
are merged. The concrete method of merging is introduced
in Algorithm 3. By this strategy, we can reduce the number
of non-zero digits to about a half meanwhile keep the num-
ber of unknown bits as small as possible. Here we give an
illustrative example.

We generate a 257-bit ephemeral key k using OpenSSL
(w = 3), and get its wNAF form like this (we only list the
positions of non-zero digits):

3 7 12 18 22 28 34 39 43 48 52 56 64 69

73 77 82 88 92 96 100 106 112 117 122 126

131 135 139 144 150 154 161 165 169 173 177

181 185 189 194 198 202 207 214 219 226 233

238 244 248 252 257

We do the merging as follows:

18 22

12
28
3bits
3bits
88 92 96 100

7bits

3 7
7bits
82
3bits
144
3bits
194 198 202

150 154

15bits

7bits

11bits

34
3bits
106
3bits

39 43

48 52 56

7bits
112
3bits

117
3bits

11bits
122 126

69 73 77

64
3bits
131 135 139

11bits

7bits

11bits

161 165 169 173 177 181 185 189

207
3bits

214
3bits

219
3bits

226
3bits

31bits
233
3bits

238
3bits

244 248 252

11bits

257
3bits

2In fact, there are h bits among the (h + 1)w + h unknown
bits being known, but we just do not know how to utilize it.

1511Algorithm 3: the Merging algorithm

Input: the double-and-add chain of the scalar multiplication of k, denoted

as SeqAD, whose length is n

Output: the merged double-and-add chain of the scalar multiplication of k,

denoted as SeqM er

numD = 0
if SeqAD[i] = \A" then
SeqM er[i] = SeqAD[i]
i + +
while SeqAD[i] ̸= \A" do

numD + +
SeqM er[i] = SeqAD[i]

1: i = 0
2: while i < n do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:

i + +

end while
if numD = w then

SeqM er[i] = \D" (cid:30)(cid:30) merge the \A" of the chain if there are

end if

else

14:
15:
16:
17:
18:
19: end while

SeqM er[i] =\D"
i + +
end if

Below is the positions of the merged non-zero digits and

the corresponding window size.

48

34
3bits
144
7bits

39
7bits
150
7bits

69

64
3bits

11bits
161
31bits

11bits
207
3bits

194
11bits

88

82
3bits
214
3bits

15bits
219
3bits

106
3bits
226
3bits

18
7bits
122
7bits
244
11bits

28
3bits
131
11bits
257
3bits

3

12
7bits
3bits
112
117
3bits
3bits
238
233
3bits
3bits
′

′

, d

Let l

∑

i · 2(cid:21)
′
′
l
i=1 d

be the number of non-zero digits after merging and
′
′
for 1 6 i 6 l
i be the new merged digit, λ
i be the position
′
i (which is also the location of the new merged non-zero
of d
′
i+1,
digit). From Equation (2) we have k = k +
i 6 2(cid:22)i − 1, µi is the current window size of
′
where 0 6 d
′
d
i. As stated in Section 3.1, the average number of non-zero
digits in Equation (2) is 50.4. Roughly speaking, in half
of the cases, the distance between two consecutive non-zero
digits is w + 1, which means the number of non-zero digits
after merging is about half of that before merging. We pick
800 random ephemeral keys for test (the secp256k1 curve).
The results show that the average number of non-zero digits
after merging is 26.52 per signature, correspondingly the
lattice dimension is reduced to 26.52u + u + 2 = 27.52u +
2. Comparisons of the lattice dimensions before and after
merging are listed in Table 2.
4.2 Recovering the MSDs

Intuitively, the more information of the ephemeral key k
we have, the higher success probability of recovering the se-
cret key will be. We seek for extracting more information
from the double-and-add chain. We (cid:12)nd that in some cas-
es, the MSD of k and the sign of the second MSD can be
recovered.

w \D" before it, the merging is
done by replacing \A" with \D"

Table 2: Dimension comparisons before and after
merging

Number of
signatures

Lattice dimension
of the basic method

Lattice dimension

after merging

4
5
6
7

208
259
311
362

113
140
168
195

As observed that, the length of the double-and-add chain
of a scalar (denoted as LAD) does not always equal to the
length of the binary string of the scalar (denoted as L0).
Indeed, there exist three cases that LAD < L0, LAD > L0
and LAD = L0. When LAD > L0 or LAD = L0, the MSD of
k and the sign of the second MSD can be recovered. As can
be easily seen that λl = LAD − 1 and 2L0−1 6 k 6 2L0 − 1.
We (cid:12)rst introduce a lemma.
Lemma 1. For integer m satisfying 1 6 m 6 l − 1, we

have

| m∑

ki · 2(cid:21)i| < 2(cid:21)m+1−1.

(7)

i=1

i.e., |∑
In fact, |∑

Proof. From the fact that the non-zero digit ki satis(cid:12)es
−2w < ki < 2w (1 6 i 6 l) and λj+1 − λj > w + 1 (1 6
j 6 l − 1) we can easily prove Inequality (7) by induction.
For m = 1, it is easily check |k1 · 2(cid:21)1| < 2w+(cid:21)1 6 2(cid:21)2−1.
Assume Inequality (7) holds for any 1 6 m − 1 6 l − 2,
i=1 ki · 2(cid:21)i| < 2(cid:21)m−1, we prove it also holds for
m−1
i=1 ki · 2(cid:21)i|
m−1
m.
6 (2w − 1)· 2(cid:21)m + 2(cid:21)m−1 < 2w+(cid:21)m 6 2(cid:21)m+1−1. This (cid:12)nishes
the proof.

i=1 ki · 2(cid:21)i| = |km · 2(cid:21)m +

∑

m

1512From Lemma 1, we can easily get kl > 0. Since if kl < 0,
k < kl · 2(cid:21)l + 2(cid:21)l−1 = (1 + 2kl)2(cid:21)l−1<0, which is obviously
a contradiction.

We have the following propositions.

Proposition 1. If LAD > L0, then kl−1 is negative and

the MSD of k is 1.

∑

∑

Proof. The condition that LAD > L0 indicates that k 6
2(cid:21)l − 1. On the other hand, k can be rewritten as k =
kl·2(cid:21)l +
i=1 ki·2(cid:21)i . If kl ̸= 1, then kl > 3. From Lemma 1,
l−1
we have k > 3 · 2(cid:21)l +
i=1 ki · 2(cid:21)i > 3 · 2(cid:21)l − 2(cid:21)l−1 > 2(cid:21)l ,
l−1
which contradict the fact k 6 2(cid:21)l − 1. So we must have
∑
kl = 1.
It remains to prove that kl−1 is negative. Suppose kl−1 >
1 is positive. Rewrite k = 2(cid:21)l + kl−1 · 2(cid:21)l−1 +
i=1 ki · 2(cid:21)i ,
l−2
we can easily get that k > 2(cid:21)l + 2(cid:21)l−1 − 2(cid:21)l−1−1 > 2(cid:21)l by
Lemma 1, which contradict the fact k 6 2(cid:21)l − 1 again. So
we have kl−1 is negative. This (cid:12)nishes the proof.

When LAD = L0, we can also determine the value of MSD

and the sign of the second of MSD.

Proposition 2. If LAD = L0, then kl−1 is positive and

the MSD of k is 1.3

∑

Proof. The condition that LAD = L0 indicates that
∑
2(cid:21)l 6 k 6 2(cid:21)l+1 − 1.
̸= 1, then kl > 3. We have k = kl · 2(cid:21)l +
Suppose kl
i=1 ki·2(cid:21)i > 2(cid:21)l+1 +(2(cid:21)l −2(cid:21)l−1) >
i=1 ki·2(cid:21)i > 3·2(cid:21)l +
l−1
l−1
∑
2(cid:21)l+1, where the second inequality holds by Lemma 1, which
contradicts the fact k 6 2(cid:21)l+1 − 1. So we must have kl = 1.
Next we prove that kl−1 is positive. Suppose kl−1 6 −1
i=1 ki · 2(cid:21)i <
is negative. Then k = 2(cid:21)l + kl−1 · 2(cid:21)l−1 +
l−2
2(cid:21)l − 2(cid:21)l−1 + 2(cid:21)l−1−1 < 2(cid:21)l , where the (cid:12)rst inequality holds
by Lemma 1, which contradicts the fact k > 2(cid:21)l . So we have
kl−1 is positive. This (cid:12)nishes the proof.

In order to have an intuitive understanding of Proposi-

tion 1 and Proposition 2, we give two examples:

Example 1: wNAF representations of scalar when LAD >
L0, w = 3

497 =⇒ 1
=⇒ A
=⇒

0 0
D D
1 1

0 0 -1
D D A
1 1 1

0 0 0 1 wNAF form
D D D A \AD"chain
0 0 0 1 binary string

Example 2: wNAF representations of scalar when LAD =

L0, w = 3

610 =⇒ 1
=⇒ A
=⇒ 1

0
D
0

0 0 3
D D A
0 1 1

0 0 0 1 0 wNAF form
D D D A D \AD" chain
0 0 0 1 0 binary string

From Example 1, we can see that if LAD > L0, then kl = 1
and kl−1 = −1 < 0, while in Example 2, it is LAD = L0 with
kl = 1 and kl−1 = 3 > 0.
According to Proposition 1 and Proposition 2, if LAD >
L0, we can determine the exact value of MSD and whether
3In this proposition we only consider the wNAF representa-
tion. While in the modi(cid:12)ed wNAF representation, if kl = 1,
kl−1 < 0, and λl−λl−1 = w+1, the position of kl is modi(cid:12)ed
from λl to λl − 1 to make LAD = L0. If this case happens,
the distance between kl and kl−1 is w, which can be easily
detected. So if we (cid:12)nd that LAD = L0, but λl − λl−1 = w,
then kl = 1 and kl−1 < 0.

the digit kl−1 is positive or not. We give a statistical re-
sult, which states that there are 597 signatures that satisfy
LAD > L0 among randomly chosen 1000 signatures. In an-
other word, for about 59.7% signatures, we can recover the
MSD of the ephemeral key k and the sign of kl−1.

Assuming for some ephemeral key k, we have kl = 1 and

Next we will show how we will use the results of Proposi-
tion 1 and Proposition 2 to improve the lattice attack. We
only take the case of LAD = L0 as an example, the case of
LAD > L0 can be dealt with similarly so we will omit for
simplicity.
∑
1 6 kl−1 6 2w − 1. Then we have k =
j=1 kj · 2(cid:21)j =
j=1 kj · 2(cid:21)j . Let kj = 2(dj − 2w−1) + 1,
2(cid:21)l + kl−1 · 2(cid:21)l−1 +
l−2
where 1 6 j 6 l − 2, 0 6 dj 6 2w − 1. Let kl−1 = 1 + 2kl−1,
l−2∑
where 0 6 kl−1 < 2w−1. So we further have
k = kl−1 · 2(cid:21)l−1+1 +

dj · 2(cid:21)j +1 + (2(cid:21)l−1 + 2(cid:21)l +

l−2∑

∑

l

2(cid:21)j

− l−2∑

j=1

j=1

2w+(cid:21)j ) .

j=1

It is easy to see that when we use the above representation
of k to build the lattice, the dimension can be reduced by 1
each time. Meanwhile, since the unknown kl−1 is in the in-
terval [0, 2w−1), so the window size of kl−1 is decreased from
w to w−1. Even when the (l−1)-th non-zero digit is merged
after using the method of merging, say being merged to a
′
′
l′ is decreased by 1 if we
l′ , the window size of d
new digit d
determine the sign of kl−1 beforehand. The decrease of the
window size will increase the determinant of lattice, which
means that the ratio of ∥ ⃗w∥/GH(L) is decreased. By this
method, we can remarkably increase the success probability
of secret key recovery.
4.3 Enumeration of the MSD

In this subsection, we further investigate the possible val-
ues of MSD for the remaining 40.3% signatures satisfying
LAD < L0, so that we can use enumeration to increase suc-
cess probability with the cost of a little more time.

Proposition 3. If LAD < L0, then

2L0−LAD < kl < 2L0−LAD+1.
∑

Proof. Rewrite k as k = kl · 2(cid:21)l +

i=1 ki · 2(cid:21)i , where
l−1
λl = LAD − 1. From Lemma 1, we have kl · 2(cid:21)l − 2(cid:21)l−1 <
k < kl · 2(cid:21)l + 2(cid:21)l−1, which means that (2kl − 1)2LAD−2 <
k < (2kl + 1)2LAD−2. Since 2L0−1 6 k 6 2L0 − 1, there must
be (2kl + 1)2LAD−2 > 2L0−1 and (2kl − 1)2LAD−2 < 2L0 −
1, which will separately give that kl > 2L0−LAD and kl <
2L0−LAD+1 since kl is an odd. This (cid:12)nishes the proof.

From Proposition 3, if LAD < L0, the number of all the
possible cases of the MSD is 2L0−LAD−1, which is no greater
than 2w−2 since L0 − LAD 6 w − 1. So we can enumerate
all the possible values of MSD if the number of signatures
are small.
If L0 − LAD = 1, we can determine
kl = 3; if L0 − LAD = 2, the only possible values of MSD
are kl = 5, 7. According to our statistical results on the
secp256k1 curve, about 45% among all the cases of LAD <

Suppose w = 3.

1513L0 satis(cid:12)es that L0 − LAD = 1, while the remaining satis(cid:12)es
L0 − LAD = 2. The average time of using the enumeration
method is prolonged by 20:403×0:55u ≈ 1.167u times, where
u is the number of signatures used to recover the secret key.
If u = 4, 5 and 6, the time of using enumeration is separately
prolonged by about 1.849, 2.156 and 2.514 times.

As we can see that, the use of enumeration can decrease
the number of non-zero digits of k, thus reducing the di-
mension of the corresponding lattice with just a little cost
of time.

5. EXPERIMENT RESULTS

We applied our attack to the secp256k1 curve, whose
window size is w = 3. All executions were performed on
an Intel Core i7-3770 CPU running at 3.40GHz in single
thread. We use the BKZ algorithms with blocksize 20 and
25 implemented in the NTL library to solve the SVP in-
stances. All of our codes are written in C++. As stated
above, our attack is applied on the basic assumption that a
perfect double-and-add chain of the ephemeral key k can be
obtained. As the success probability of the original method
in Section 3.2 is too low, we only give the experiment re-
sults using the improved methods. Given the number of
signatures u = 4, 5, 6, 7, various combinations of improved
attack methods, and di(cid:11)erent lattice reduction algorithms,
we execute 200 experiments each time to recover the secret
key, with the success probability computed by the ratio of
the number of success attacks and 200. We list the results
of attacks in Table 3. As we can see, only 4 signatures are
enough to recover the secret key, while using 5 signatures
we can succeed with probability of 37.5%, using 6 signa-
tures with probability of 90% and using 7 signatures with
probability of 94%.

According to [26],

it is quite easy to identify 581 full
double-and-add chain among 1000 random Flush+Reload
attack results, containing only 4 error chains. So it is pos-
sible to get a perfect double-and-add chain with probability
being about 57.7%. As we can succeed recovering the secret
key with 4, 5, 6 and 7 signatures with perfect double-and-
add chain, the actual number of signatures we need is about
7, 9, 11 and 13. Note that the success probability using 4
signatures is not high enough, we believe that if our attack
use other powerful reduction algorithm, like the BKZ 2.0
algorithm [6], the success probability will be increased.

Our attack can be applied to other curves implemented
by wNAF method like the secp521r1 curve, and can also
be extended to any cryptographic implementation using the
wNAF representation, like DSA, SM2, etc.

6. CONCLUSIONS

In this paper, we demonstrated that ECDSA implemented
by OpenSSL using the wNAF representation can be broken
using the lattice attack with the help of the Flush+Reload
attack. We develop a new e(cid:14)cient method of extracting and
utilizing side-channel information to mount a lattice attack
to ECDSA. After that, the methods of elimination, merging,
MSD recovering and enumeration are used to remarkably
increase the success probability of key recovery. Our attack
is mounted to the secp256k1 curve in experiments. It is
shown that given results of perfect Flush+Reload attack,
4 signatures would be enough to recover the secret key.

7. ACKNOWLEDGEMENTS

This work is supported by the National Basic Research

Program of China (973 Program) granted No. 2013CB338003.
The authors would like to thank the anonymous reviewers
for their valuable comments and suggestions.

8. REFERENCES
[1] The openssl project. OpenSSL { cryptography and

SSL/TLS toolkit. http://www.openssl.org.

[2] O. Acii(cid:24)cmez, (cid:24)C. K. Ko(cid:24)c, and J.-P. Seifert. On the

power of simple branch prediction analysis. In
Proceedings of the 2nd ACM Symposium on
Information, Computer and Communications Security,
ASIACCS 2007, pages 312{320, New York, NY, USA,
2007. ACM.

[3] N. Benger, J. van de Pol, N. P. Smart, and Y. Yarom.
\Ooh aah. . . ,just a little bit": A small amount of side
channel can go a long way. In L. Batina and
M. Robshaw, editors, Cryptographic Hardware and
Embedded System { CHES 2014, volume 8731 of
Lecture Notes in Computer Science, pages 75{92.
Springer Berlin Heidelberg, 2014.

[4] B. B. Brumley and R. M. Hakala. Cache-timing

template attacks. In M. Matsui, editor, Advances in
Cryptology { ASIACRYPT 2009, volume 5912 of
Lecture Notes in Computer Science, pages 667{684.
Springer Berlin Heidelberg, 2009.

[5] B. B. Brumley and N. Tuveri. Remote timing attacks

are still practical. In V. Atluri and C. Diaz, editors,
Computer Security { ESORICS 2011: 16th European
Symposium on Research in Computer Security,
Leuven, Belgium, September 12-14, 2011. Proceedings,
pages 355{371. Springer Berlin Heidelberg, 2011.

[6] Y. Chen and P. Nguyen. BKZ2.0: better lattice
security estimates. In Advances in Cryptology {
ASIACRYPT 2011, volume 7073 of Lecture Notes in
Computer Science, pages 1{20. Springer Berlin
Heidelberg, 2011.

[7] H. Cohen, A. Miyaji, and T. Ono. E(cid:14)cient elliptic
curve exponentiation. In Advances in Cryptology {
Proceedings of ICICS 1997, volume 1334 of Lecture
Notes in Computer Science, pages 282{290. Springer
Berlin Heidelberg, 1997.

[8] P. FIPS. 186-4 digital signature standard (DSS).

National Institude of Standards and Technology
(NIST), 2013.

[9] N. Gama and P. Q. Nguyen. Predicting lattice

reduction. In N. Smart, editor, Advances in Cryptology
{ EUROCRYPT 2008: 27th Annual International
Conference on the Theory and Application of
Cryptographic Techniques, Istanbul, Turkey, April
13-17, 2008. Proceedings, pages 31{51. Springer Berlin
Heidelberg, Berlin, Heidelberg, 2008.

[10] M. Hlav(cid:19)a(cid:20)c and T. Rosa. Extended hidden problem
and its cryptanalytic applications. In E. Biham and
A. M. Youssef, editors, Selected areas in Cryptography,
volume 4356 of Lecture Notes in Computer Science,
pages 114{133. Springer Berlin Heidelberg, 2007.

[11] A. Hollosi, G. Karlinger, T. Rossler, M. Centner, and

et al. Die (cid:127)osterreichische b(cid:127)urgerkarte, 2008.

[12] N. Howgrave-Grahm and N. P. Smart. Lattice attacks

1514Table 3: Experiment Results (A. MSD recovering; B. Enumeration; C. Merging and Elimination)
denotes the success probability of the attack, \time" denotes the average time the algorithm cost)

(\p"

Number of Reduction
Signatures Algorithm

method

p(%)

time(min)

7

6

5

4

BKZ-20

BKZ-25

BKZ-20

BKZ-25

BKZ-20

BKZ-25

BKZ-25

A+C

A+C

A+C

C

C

C

C

A+C

A+B+C

24
62
68
94
22
28
51
35
61
90
1
4.5
4
17
A+B+C 37.5
1.5
8

A+B+C

A+B+C

C

C

A+C

A+C

A+C

34.5
28.9
238.8
226
18
9.48
43.18
103.2

80

193.58

18

12.17

36

41.73
102.6
40.9
88.8

on digital signature schemes. Designs, Codes and
Cryptography, 23:283{290, 2001.

known nonces. Designs, Codes and Cryptography,
30:201{217, 2003.

[13] G. Irazoqui, M. S. Inci, T. Eisenbarth, and B. Sunar.

[22] D. Page. Theoretical use of cache memory as a

Lucky 13 strikes back. In Proceedings of the 10th ACM
Symposium on Information, Computer and
Communications Security, ASIA CCS ’15, pages
85{96, New York, NY, USA, 2015. ACM.

[14] D. Johnson, A. Menezes, and S. A. Vanstone. The

elliptic curve digital signature algorithm (ECDSA).
International Journal of Information Security,
1:36{63, 2001.

cryptanalytic side-channel. IACR Cryptology ePrint
Archive, 2002:169, 2002.

[23] C.-P. Schnorr and M. Euchner. Lattice basis

reduction: improved practical algorithms and solving
subset sum problems. In Fundamentals of
Computation Theory { FCT 1991, volume 529 of
Lecture Notes in Computer Science, pages 68{85.
Springer Berlin Heidelberg, 1991.

[15] P. C. Kocher, J. Ja(cid:11), and B. Jun. Di(cid:11)erential power

[24] J. Solinas. E(cid:14)cient arithmetic on Koblitz curves.

analysis. In M. Wiener, editor, Advances in Cryptology
{ CRYPTO 1999, volume 1666 of Lecture Notes in
Computer Science, pages 388{397. Springer Berlin
Heidelberg, 1999.

[16] K. Koyama and Y. Tsuruoka. Speeding up elliptic

curve cryptosystems using a signed binary windows
method. In Advances in Cryptology - CRYPTO 1992,
volume 740 of Lecture Notes in Computer Science,
pages 345{357. Springer Berlin Heidelberg, 1992.

[17] A. K. Lenstra, H. W. Lenstra, and L. Lov(cid:19)asz.

Factoring polynomials with rational coe(cid:14)cients.
Mathematische Annalen, 261(4):515{534, 1982.

[18] M. Liu and P. Q. Nguyen. Solving BDD by

enumeration: An update. In E. Dawson, editor, Topics
in Cryptology { CT-RSA 2013: The Cryptographers’
Track at the RSA Conference 2013, San Francisco,CA,
USA, February 25-March 1, 2013. Proceedings, volume
7779 of Lecture Notes in Computer Science, pages
293{309. Springer Berlin Heidelberg, 2013.

[19] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash

system, 2008.

[20] P. Q. Nguyen and I. Shparlinski. The insecurity of the

digital signature algorithm with partially known
nonces. Journal of Cryptology, 15:151{176, 2002.

[21] P. Q. Nguyen and I. Shparlinski. The insecurity of the
elliptic curve digital signature algorithm with partially

Design, Codes and Cryptography, 19(2):195{249, 2000.

[25] E. Tromer, D. A. Osvik, and A. Shamir. E(cid:14)cient

cache attacks on AES, and countermeasures. Journal
of Cryptology, 23(1):37{71, 2010.

[26] J. van de Pol, N. P. Smart, and Y. Yarom. Just a little
bit more. In K. Nyberg, editor, Topics in Cryptology {
CT-RSA 2015, volume 9048 of Lecture Notes in
Computer Science, pages 3{21. Springer International
Publishing, 2015.

[27] S. Vanstone. Responses to NIST’s proposal.

Communications of the ACM, 35:50{52, 1992.

[28] Y. Yarom and N. Benger. Recovering OpenSSL
ECDSA nonces using the Flush+Reload cache
side-channel attack. IACR Cryptology ePrint Archive,
2014:140, 2014.

[29] Y. Yarom and K. Falkner. Flush+Reload: a high

resolution, low noise, L3 cache side-channel attack. In
23rd USENIX Security Symposium (USENIX Security
2014), pages 719{732, San Diego, CA, Aug. 2014.
USENIX Association.

[30] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart.

Cross-VM side channels and their use to extract
private keys. In Proceedings of the 2012 ACM
Conference on Computer and Communications
Security, CCS 2012, pages 305{316, New York, NY,
USA, 2012. ACM.

1515