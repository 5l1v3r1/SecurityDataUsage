Aligot: Cryptographic Function Identiﬁcation in

Obfuscated Binary Programs

Joan Calvet

Université de Lorraine, LORIA

Nancy, France

joan.calvet@loria.fr

José M. Fernandez
École Polytechnique
Montréal, Canada

jose.fernandez@polymtl.ca

Jean-Yves Marion

Université de Lorraine, LORIA

Nancy, France

jean-yves.marion@loria.fr

ABSTRACT
Analyzing cryptographic implementations has important ap-
plications, especially for malware analysis where they are
an integral part both of the malware payload and the un-
packing code that decrypts this payload. These implemen-
tations are often based on well-known cryptographic func-
tions, whose description is publicly available. While po-
tentially very useful for malware analysis, the identiﬁcation
of such cryptographic primitives is made diﬃcult by the
fact that they are usually obfuscated. Current state-of-the-
art identiﬁcation tools are ineﬀective due to the absence of
easily identiﬁable static features in obfuscated code. How-
ever, these implementations still maintain the input-output
(I/O) relationship of the original function.
In this paper,
we present a tool that leverages this fact to identify crypto-
graphic functions in obfuscated programs, by retrieving their
I/O parameters in an implementation-independent fashion,
and comparing them with those of known cryptographic
functions. In experimental evaluation, we successfully iden-
tiﬁed the cryptographic functions TEA, RC4, AES and MD5
both in synthetic examples protected by a commercial-grade
packer (AsProtect), and in several obfuscated malware sam-
ples (Sality, Waledac, Storm Worm and SilentBanker). In
addition, our tool was able to recognize basic operations
done in asymmetric ciphers such as RSA.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—In-
vasive software; Cryptographic controls

Keywords
Binary Program Analysis, Malware, Cryptography

1.

INTRODUCTION

Malicious software (malware) employs cryptography for
many purposes, including hiding its network communica-
tions [6, 7, 26] and protecting its payload [5, 36, 22]. This

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

use of cryptography is often combined with code obfuscation
in order to thwart reverse engineering eﬀorts by analysts and
potentially avoid detection by security products. Obfusca-
tion techniques in malware have become increasingly preva-
lent in the last few years, in particular due to the increased
availability and use of obfuscating code packers by malware
authors [21].

Analyzing and identifying the use of crypto functions is of
a primary interest for several reasons. First, it can allow ac-
cess to the decrypted malware core before it gets executed,
which in turn provides key insight on the intentions of those
creating and deploying the malware. Second, cryptographic
code constitutes a feature that can be used to improve mal-
ware classiﬁcation, an important step towards the identiﬁca-
tion of tools, methods and potentially groups or individuals
behind particular malware attacks. Finally, an in-depth un-
derstanding of the decryption process and the identiﬁcation
of critical input parameters, such as the decryption key, can
help in the development of static unpackers [27], i.e. auto-
matic methods for extracting the core logic of packed pro-
grams without executing them. These tools allow analysts
to write signatures on malware core features, often shared
among variants, and can be easily deployed on end-user com-
puters since they are lightweight.

As is the case with many binary program analysis tasks,
cryptographic implementation reverse engineering is chal-
lenging, notably due to the complexity of the machine lan-
guage and the lack of high-level structure. In practice, these
implementations are often based on well-known cryptographic
functions, whose description is publicly available. This opens
the road for an alternative to cumbersome line-by-line anal-
the search for signs indicating which cryptographic
ysis:
function was implemented.
Identifying this function does
not directly provide cryptographic parameters, but it makes
ﬁnding them much easier.

Most existing tools for cryptographic function identiﬁca-
tion in binary programs, like KANAL [33], DRACA [15] or
Signsrch [4], are based on the recognition of code features by
static analysis, such as speciﬁc constant values or machine
language instructions, that are usually present in normal im-
plementations of the recognized primitives. However, these
tools are mostly ineﬀective on obfuscated programs, which
have been made purposely hard to analyze and therefore
hide static signs that could betray the presence of known
cryptographic functions. Hence simple static-analysis iden-
tiﬁcation of cryptographic functions is not suitable for such
programs.

169In contrast to this approach, we propose here a method
and a tool called Aligot for identifying cryptographic func-
tions and retrieving their parameters, in a manner that is
essentially independent of the actual implementation. Our
solution leverages the particular input-output (I/O) rela-
tionship of cryptographic functions. Indeed if F1 is a cryp-
tographic function such that F1(K, C) = C(cid:48), with K a key,
C an encrypted text and C(cid:48) a decrypted text, then it is
very unlikely that another cryptographic function F2 veri-
ﬁes F2(K, C) = C(cid:48). In other words, the pair ((K, C), C(cid:48))
identiﬁes F1 with overwhelming probability.

Consequently, if we observe during a particular execution
of a program P that the values K and C are used to produce
the value C(cid:48), then we can conclude that P implements F1
during this particular execution. Of course, not all execution
paths of P may implement F1, but identifying which poten-
tial paths are relevant is a separate reverse-engineering prob-
lem, albeit one that is handled with success by most skillful
malware reverse engineers. Henceforth, we therefore restrict
ourselves on the problem of identifying cryptographic func-
tions along a given (chosen) execution path. In a nutshell,
our method consists of (1) the retrieval of I/O parameters
of possible cryptographic code during its execution, and (2)
the comparison of the observed I/O relationship with those
of known cryptographic functions.

Aligot was built and tested against other crypto detection
tools with obfuscated implementations of the TEA, RC4,
AES, MD5 and RSA cryptographic functions. The test
cases included home-made obfuscated programs (for bench-
marking purposes), programs obfuscated with a commercial
packer (AsProtect), and existing malware (Storm, Silent-
Banker, Sality, Waledac). Aligot performed signiﬁcantly
better than all the other tools on all tested cryptographic
functions and samples (synthetic and malware).
We describe in §2 the previous work on cryptographic
function analysis in binary programs. We provide an overview
of our method in §3, and the detailed steps in §4 to 8. In §9
we report on our experimental evaluation of the method. We
discuss the viability and limitations of our overall approach
and conclude in §10 and 11.

2. RELATED WORK

The problem of analyzing cryptographic code and extract-
ing its parameters in binary programs has been previously
studied for diﬀerent motivations. Within the context of
Computer Forensics analysis, Halderman et al.
[11] used
particular properties of DES, AES and RSA to retrieve cryp-
tographic parameters in the presence of bit-ﬂipping errors.
Maartmann-Moe et al. [19] extended this technique to the
Serpent and Twoﬁsh ciphers. As these methods rely on such
algorithm speciﬁc characteristics, they unfortunately require
an in-depth study of each cipher.

As far as we know, Noe Lutz [18] was the ﬁrst to ex-
plore generic cryptographic code detection using dynamic
analysis. Lutz uses three indicators to recognize crypto-
graphic code in execution traces: (1) presence of loops, (2) a
high ratio of bitwise arithmetic instructions and (3) entropy
change in the data manipulated by the code. In subsequent
work, Wang et al.
[6] used sim-
ilar observations to automatically retrieve decrypted data
from encrypted communications. Several assumptions made
in these works are not applicable to obfuscated programs.
In particular arithmetic instructions are commonly used in

[32] and Caballero et al.

junk code, making them an unreliable indicator of the pres-
ence of cryptographic code. Finally, none of these techniques
aim to the precise identiﬁcation of the cryptographic func-
tions implemented.

Gr¨obert et al. [10] proposed in 2010 a work on crypto-
graphic function identiﬁcation. They deﬁne in particular
several criteria to extract cryptographic parameters from
execution traces and use I/O relationship comparison with
known cryptographic functions. Parameters are identiﬁed
thanks to the spatial proximity in the execution trace of
instructions accessing their location in memory. In the pres-
ence of junk code, such a notion of proximity would be
diﬃcult to apply, because instructions responsible to ac-
cess a same parameter can then be at a very variable dis-
tance. Moreover, candidate cryptographic parameters are
extracted based on their size and therefore variable-length
parameter functions like RC4 are hard to recognize. Zhao et
al. also used I/O relationship to identify cryptographic func-
tions [37]. Again, they made several assumptions on their
programs, e.g. the ratio of exclusive-ors in cryptographic
code or the use of certain types of functions, that are rarely
satisﬁed in obfuscated programs.

Consequently, while their work opened the path to cryp-
tographic identiﬁcation based on I/O relationship compari-
son, it does not address identiﬁcation within obfuscated pro-
grams. Implementing this identiﬁcation is indeed far from
trivial in such an environment. First, obfuscated programs
lack abstractions that allow us to easily consider candidate
parts of the code for identiﬁcation. Second, obfuscation
techniques tend to strongly increase the number of data ac-
cesses made by a program and therefore precise retrieval of
cryptographic parameters becomes quite challenging.

3. SOLUTION OVERVIEW

A single I/O pair is enough to identify most cryptographic
functions. We use this observation to identify them in ob-
fuscated programs with the following three-step process:

1. Gather execution trace of the targeted program.
Our identiﬁcation technique needs the exact values
manipulated by a program during an execution. Dy-
namic analysis is therefore particularly suitable and ex-
ecution traces thus constitute our problem input. We
will deﬁne execution traces formally in §4.

2. Extract cryptographic code with I/O param-
eters from execution traces. We use a speciﬁc
deﬁnition of loops to build an abstraction suitable for
cryptographic code detection in obfuscated programs.
Secondly, we analyze data ﬂow between loops in or-
der to group those participating in the same cryp-
tographic implementation, as there exists multi-loop
cryptographic functions (e.g. RC4 [34]). We obtain
a loop data ﬂow model of the possible cryptographic
code, from which we then extract I/O values. The
complete building process from an execution trace to
a set of loop data ﬂows will be explained in §5 and 6.

3. Comparison with known cryptographic func-
tions. Each extracted loop data ﬂow is compared with
a set of cryptographic reference implementations.
If
one of these implementations produces the same out-
put than the loop data ﬂow when executed on the same
inputs, then we can conclude that they both implement

170the same cryptographic function. Despite its appar-
ent simplicity, such comparison phase is non-trivial,
because of the diﬀerence of abstraction between high-
level reference implementations on one side, and ex-
ecution traces on the other. This last step will be
explained in §8.

4. EXECUTION TRACE GATHERING

In this work, we focus exclusively on the Windows/x86
platform. Among all tracing tools available in such environ-
ment, we chose Pin, the dynamic binary instrumentation
framework supported by Intel [17], mainly because of its
ease of use and its ability to deal with self-modifying code,
a common technique in obfuscated programs. While we will
not describe the tracer implementation, we do need to intro-
duce a formal notion of execution traces as a basis for the
rest of the reasoning about loops. An execution trace rep-
resents intuitively a series of operations done by a program
during a run on a system. At each step, we collect what we
call a dynamic instruction. A dynamic instruction D is a
tuple composed of:

• a memory address A[D],
• a machine instruction I[D] executed at A[D],
• two sets of memory addresses read and written RA[D]

and WA[D] by I[D],

• two sets of registers read and written RR[D] and WR[D]

by I[D].

An execution trace T is a ﬁnite sequence D1; . . . ; Dn of
dynamic instructions.
In the remainder of the paper, we
will denote as X 86 the set of machine instructions and as
T RACE the set of execution traces. Moreover, given T ∈
T RACE, T/Ins is deﬁned as the machine instruction se-
quence, that is T/Ins = I1; . . . ; In if ∀k ∈ [1, n],I[Dk] = Ik.
In practice we also gather the exact values for each data
access made by a dynamic instruction (in memory or regis-
ters), but for the sake of simplicity we do not mention them
in the formal trace notion.

5. LOOP EXTRACTION

When analyzing binary programs, one can usually divide
code into functions. But this function notion is only a heuris-
tic based on compiler idiosyncrasies (calling convention, pro-
logue and epilogue code, etc.), making it unreliable in obfus-
cated programs that do not maintain them. This is why we
built a speciﬁc abstraction for cryptographic code in obfus-
cated programs based on loops. We will ﬁrst motivate this
choice, we will then present some existing loop deﬁnitions,
and ﬁnally give our deﬁnition and describe the associated
recognition algorithm.
5.1 Motivation and Related Work

As noted by Noe Lutz in his thesis, “loops are a recur-
ring feature in decryption algorithms” [18]. Indeed crypto-
graphic functions usually apply the same treatment on a set
of data in an iterative fashion, making loops a very frequent
structure in their implementations. It is within these loops
that the core cryptographic operations happen and that the
cryptographic I/O parameters are manipulated. Hence, they
constitute a good starting point for our abstraction.

On the other hand, loops are present in many diﬀerent
types of algorithms, not only cryptographic ones. Thus, we
need a reﬁned loop notion focused on cryptographic code.
For example Fig. 1(a) presents an obfuscation technique
named control-ﬂow ﬂattening —in pseudo-C language for
the sake of clarity— seen in the Mebroot malware family
[31, 9]. A sequential code is transformed into a loop that
implements a part of the original code at each iteration.
Thus, a diﬀerent logic is executed each time the back-edge
is taken: should it be considered as a loop in our crypto-
graphic context?

Secondly, Fig. 1(b) presents a classic compiler optimiza-
tion technique called unrolling that can also be used as a
means of obfuscation. A three-instruction sequence is re-
peated three times without any back-edge: should it be con-
sidered as a loop in our cryptographic context?

(a) Control-ﬂow Flatten-
ing

(b) Unrolling

Figure 1: Control-ﬂow graph of loop edge cases

Several loop deﬁnitions for binary programs have been
proposed in the literature. Three of them are of particular
interest in the context of this work:

1. Natural loops This is the usual deﬁnition in static
program analysis. Back-edges are deﬁned on the pro-
gram’s control-ﬂow graph (CFG) as edges between a
node and one of its dominant [3]. Thus, a loop is iden-
tiﬁed by one back-edge, and an application of this deﬁ-
nition on their CFG would consider Fig. 1(a) as a loop,
but not Fig. 1(b).

2. Address-centric loops Another approach, especially
built for dynamic analysis is that of [28]. A loop is
identiﬁed by a speciﬁc memory address, named target
address, where a set of backward branch instructions
jump.
In other words, several back-edges can corre-
spond to the same loop, which is then identiﬁed by
the target address. Nevertheless, this deﬁnition would
also consider Fig. 1(a) as a loop, but not Fig. 1(b).

3. Instruction-centric loops Kobayashi deﬁnes loops
on execution traces as the repetition of a machine in-
struction sequence [14]. For example, let T be a six in-
struction execution trace such that T/Ins = I1; I2; I3;
I1; I2; I3, then T is a loop iterating two times with
I1; I2; I3 as body. With this simple deﬁnition, Fig.
1(a) would not be considered as a loop, whereas Fig.
1(b) would be.

case 18:  ...c = 24  ...switch(c)case 24:  ...c = 6  ...case 6:  ...c = 180x00 inc eax0x01 inc ebx0x02 mov [ebx], eax0x03 inc eax0x04 inc ebx0x05 mov [ebx], eax0x06 inc eax0x07 inc ebx0x08 mov [ebx], eax1715.2 Simple Loop Deﬁnition

We focus on loops because cryptographic code usually use
them to apply a same treatment on I/O parameters. Follow-
ing this idea, Fig. 1(a) should not be considered as a loop
—as a diﬀerent logic is executed at each “iteration”— and
on the contrary Fig. 1(b) should be. Therefore, we choose
the Kobayashi approach as our starting point: we identify a
loop by a repeated machine instruction sequence, called its
body. Thus, the body of the Fig. 1(b) loop is made of the
three instructions inc eax, inc ebx and mov [ebx],eax.

A same loop can be run several times during an execu-
tion, each time with a diﬀerent number of body repetitions.
We call a particular run an instance of the loop. We also
consider that the last iteration might be incomplete: a loop
instance does not necessarily terminate at the exact end of
its body.
We deﬁne this loop instance notion with formal language
theory on the machine instruction alphabet X 86. For a word
α ∈ X 86∗ (i.e. α corresponds to a sequence of x86 instruc-
tions), we denote the set of preﬁxes of α by P ref (α), that is
β ∈ P ref (α) if ∃γ ∈ X 86∗, α = βγ. We denote as α ∈ X 86+
when α ∈ X 86∗ and |α| ≥ 1.

Definition 1. The language SLOOP of simple loop in-

stances is deﬁned as all traces L ∈ T RACE such that:
L/Ins ∈ {αn.β|α ∈ X 86+, n ≥ 2, β ∈ P ref (α)}

Thus, a simple loop instance is deﬁned by at least two rep-
etitions of a machine instruction sequence, called its body
and represented by α. This deﬁnition is actually more gen-
eral than Kobayashi’s, who limited a loop body to contain
the same machine instruction only once.
In other words,
there is no instruction (cid:96) ∈ X 86 such that α = u(cid:96)u(cid:48)(cid:96)u(cid:48)(cid:48) in
Kobayashi’s work.
5.3 Nested Loop Deﬁnition

For our purposes, we also need to consider nested loops.
Fig. 2(a) presents a common situation. Block B constitutes
the body of an inner loop that does not iterate the same
number of times for each outer loop iteration (cf. Fig. 2(b)).
Consequently, if we directly apply Deﬁnition 1 on the execu-
tion trace, the outer loop would not be recognized as a loop.
Nevertheless, it is still consistent with our loop principle: a
same treatment applied repeatedly.

We introduce a set LID of loop identiﬁers, and we will use
the letter X as a loop identiﬁer in the rest of the paper. For
example the execution trace in Fig. 2(b) can be rewritten as
AXCAXC with X ∈ LID the loop identiﬁer for the inner
loop B. The next application of Deﬁnition 1 will then be
able to detect the outer loop with AXC as body.
We denote as T RACELID the set of execution traces

where loop identiﬁers can replace dynamic instructions.

Definition 2. The language LOOP of loop instances is

deﬁned as all traces L ∈ T RACELID such that:

L/Ins ∈ {αn.β|α ∈ (X 86 ∪ LID)+, n ≥ 2, β ∈ P ref (α)}
Let L ∈ LOOP, we denote BODY [L] ∈ (X 86∪LID)+ the

body of the loop instance L, i.e. α in Deﬁnition 2.
5.4 Loop Instance Detection Algorithm
The loop detection algorithm is based on the recogni-
tion of the language {αn.β|α ∈ (X 86 ∪ LID)+, n ≥ 2, β ∈
P ref (α)}, which is context-sensitive and in particular not
context-free [13]. We built a single pass algorithm for loop
instance detection, working in O(m2) operations, with m
the execution trace size. We present the complete algorithm
pseudo-code in Appendix B and, for the sake of brevity, we
give here only an overview of how it works with an example.
The LOOP recognition algorithm processes machine in-
structions from the execution trace one after the other, and
stores them at the end of a list-like structure, named history.
A common situation is then the one describes in Fig. 3(a):
instructions I1, I2, I1, I3 have been recorded into the his-
tory and the currently processed machine instruction is I1.
Therefore this instruction appears twice in the history.

L1

L2

(a) Algorithm state

(b) Loop instances after I1
processing

Figure 3: Loop detection example: step one

Each occurrence of I1 in the history corresponds to a pos-
sible loop instance beginning.
In the ﬁrst case, the body
would be α = I1; I2; I1; I3, whereas in the second one it
would be α = I1; I3. Thus, the algorithm creates two loop
instances, named respectively L1 and L2, each of them with
a cursor on the next instruction expected, I2 for L1 and I3
for L2 (cf. Fig. 3(b)).

(a) CFG

(b) Execution trace

Figure 2: Simpliﬁed nested loop example

(a) Algorithm state

L2

(b) Loop instances
after I3 processing

It actually suﬃces to abstract each loop instance and ap-
ply Deﬁnition 1 recursively to solve this problem. Each time
a loop instance is detected, we replace its code by a loop
identiﬁer in the execution trace. This identiﬁer represents
the loop associated with the instance. In other words, we re-
place each instance of a same loop with the same identiﬁer.

Figure 4: Loop detection example: step two

I1 is then appended to the history. Now assume I3 is the
next machine instruction in the trace, the current situation
is described in Fig. 4(a). L1 is then discarded, as it was not

ABCA B B B C A B B CB loop instance 1B loop instance 2I1I2I1I3...    I1     ...GrowthHistoryTraceI1I2I1I3I1I3I1I2I1I3I1...    I3   ...HistoryTraceI1I3172expecting this instruction. On the other hand, the L2 cursor
is incremented and returns on the ﬁrst instruction:
it just
made a turn (cf. Fig. 4(b)). At this point we have seen ex-
actly two iterations for L2, that is I1; I3; I1; I3, and therefore
we consider it as a conﬁrmed loop instance. Thus, we re-
place its code in the history by its associated loop identiﬁer
X ∈ LID, as described in Fig. 5.

Figure 5: Loop detection example: step three
Suppose the next machine instruction is I4. Then L2,
which was waiting for I1, is removed from running loop in-
stances and registered. The replacement of its code with its
loop identiﬁer X will allow the detection of an outer loop, in-
dependently of the number of iterations of L2 for each outer
loop iteration, as explained in §5.3.

6. LOOP INPUT-OUTPUT PARAMETERS
Loops allow possible cryptographic code extraction from
execution traces, but our ﬁnal objective is to collect cryp-
tographic parameters. We present in this section a loop in-
stance parameter notion and an algorithm to extract these
parameters from execution traces. Then we will exhibit a
simple example in order to make the understanding easier.
6.1 Deﬁnition

Loop instance parameters are low-level counterparts of
high-level implementation parameters (called high-level pa-
rameters in the rest of the paper). Bytes read or written in
the execution trace constitute our starting point and, for a
loop instance L, we deﬁne its parameters by combining the
three following necessary conditions:

1. Bytes belonging to the same parameter of L are either
adjacent in memory, or in the same register at the same
time. This condition alone would tend to group multi-
ple high-level parameters in the same parameter of L.
Indeed diﬀerent high-level parameters can be adjacent
in memory, as it is often the case in the stack. Such
over-approximation would strongly complicate the ﬁ-
nal comparison phase; this is the reason we introduce
the following condition.

2. Bytes belonging to the same parameter of L are ma-
nipulated in the same manner (read or written) by the
same instruction in BODY [L]. Indeed a particular in-
struction in BODY [L] can manipulate diﬀerent bytes
at each iteration but these data tend to have the same
role (in particular because of our strict loop deﬁnition).
3. Finally, bytes belonging to an input parameter of L
have been read without having been previously written
by code within L, whereas bytes belonging to an output
parameter of L have been written by code in L.

In order to gather these parameters, we deﬁne concrete
variables as simple byte arrays starting at a particular mem-
ory address.
If a concrete variable starts at the address

Figure 6: Assembly program implementing one-time
pad cipher. KEY, ENCRYPTEDTEXT and SIZETODECRYPT are
constants resolved by the assembler, the ﬁrst two
are memory addresses pointing to parameter values,
whereas the last one contains their size.

0x400000 and contains four bytes, we denote it as 0x400000:4.
Moreover, we also consider registers as concrete variables,
whose addresses are register names, like eax:4 or bx:2. The
value contained in a concrete variable can change during the
execution. A parameter is then deﬁned as a concrete vari-
able with a ﬁxed value. For the sake of brevity, we now give
only an overview of the parameter gathering algorithm.
6.2 Algorithm Overview

The algorithm groups bytes into concrete variables by us-
ing the ﬁrst two necessary conditions. Then, we divide con-
crete variables into two groups, input and output param-
eters, by applying the third condition (the same concrete
variable can be in both groups).

In a second step, the algorithm associates a ﬁxed value to
each previously deﬁned concrete variables. As explained in
§4, our tracer engine collects values for each data access. We
use the two following rules to set parameter values: (1) the
ﬁrst time an input parameter is read provides its value, and
(2) the last time an output parameter is written provides its
value.
Finally, for each loop instance L, the algorithm returns:
INM (L) and INR(L) containing input parameters in mem-
ory and registers respectively, and OU TM (L) and OU TR(L)
containing output parameters. The need for this distinction
between memory and registers will become apparent in §7.
The algorithm takes O(m) steps, with m the execution trace
size.
6.3 Example

In order to facilitate understanding of the previous deﬁ-
nitions, we present here a simple artiﬁcial example. Fig. 6
presents an assembly language implementation of the one-
time pad cipher [25], that is the application of a bitwise
XOR operation between an input text and a key of the same
length. We assembled this code into a program P that
uses it with an 8-byte key 0xDEADBEEFDEADBEEF, in order
to decrypt the 8-byte text 0xCAFEBABECAFEBABE. To iden-
tify the cryptographic function in P with the approach pre-
sented in this paper, we would need to collect the two in-
put values along with the associated output result, namely

I1I2X...    I4     ...HistoryTrace; Prologue LEA EAX,[KEY]            LEA EBX,[ENCRYPTEDTEXT]  PUSH SIZETODECRYPT       MOV ECX, 0               ; counter; Core treatmentLOOP:     MOV EDX,[EAX+ECX]   ; read 4 bytes from the key     XOR [EBX+ECX], EDX  ; apply XOR operation     ADD ECX,4           ; increment counter     CMP ECX,[ESP]       ; is it finished ?     JNZ LOOP; EpilogueADD ESP,4                ; rewind the stackRETN1730x1453045114530451. Therefore we gathered the execution
trace of P with our tracer engine and applied the previous
deﬁnitions on it. One loop instance was detected, whose in-
structions are presented in Table 1. Loop parameters were
extracted by the previously described algorithm and we rep-
resent them in a parameter graph shown in Fig. 7.

Figure 7: Parameter graph for P. Orange nodes are
input-parameters, whereas blue ones are output pa-
rameters. Their values are noted under the line.

Cryptographic parameters have been successfully retrieved:
402000:8 and 402008:8 as inputs, and 402000:8 as output.
On the other hand, we also collected parameters with values
linked to this particular implementation: (i) eax:4, ebx:4,
esp:4 containing memory addresses, (ii) ecx:4, containing a
counter value, (iii) 12FFC0:4, corresponding to a local vari-
able initialized before the loop (SIZETODECRYPT), and (iv)
edx:4, an intermediate storage. This will be taken into con-
sideration in §8 for the comparison phase.

7. LOOP DATA FLOW

Until now we considered that each possible cryptographic
implementation contains a single loop. Nevertheless, crypto-
graphic functions can actually be composed of several non-
nested loops, such as RC4 [34]. Consequently, the loop ab-
straction alone is not enough to capture them completely.
In order to tackle this, we used data ﬂow to group loop in-
stances participating in the same cryptographic implemen-
tation. In this section we will describe the data ﬂow con-
struction algorithm leading to our ﬁnal model and then we
will deﬁne the associated parameters.
7.1 Loop Data Flow Construction
We deﬁne the data ﬂow between loop instances in a simi-
lar way to def-use chains [3]: two loop instances L1 and L2
are connected if L1 produces an output parameter used by
L2 as an input parameter. For the sake of simplicity, we con-
sider only memory parameters, because register parameters
would require a precise taint tracking inside sequential code
between loop instances. Indeed, our assumption is that all
treatments on inputs and outputs in memory are processed
through loops.
Suppose that {L1, . . . ,Ln} is the set of loop instances
extracted from T ∈ T RACE. We deﬁne a binary rela-
tion  between loop instances such that ∀(i, j) ∈ [1, n]2,
Li Lj if (i) Li started before Lj in T , and (ii) OU TM (Li)∩
INM (Lj) (cid:54)= ∅. Next, we deﬁne the loop data ﬂow graph G
as ({L1, . . . ,Ln}, ). G is an acyclic graph, which may have
several connected components G1, . . . ,Gm, each of them with
possibly several roots and leafs. For a connected component
Gk we denote, respectively, by ROOT [Gk] and LEAF [Gk]
the sets of root and leaf loop instances.

Each of these connected components represents an ab-
straction that is akin to functions in common binary pro-

grams. Thus, each Gk is a candidate cryptographic function
implementation that will then be tested against known im-
plementations. A standard graph algorithm is used to re-
construct the loop data ﬂow graph, by testing the binary
relation  for each pair of detected loops Li and Lj, and to
detect its connected components. In the remainder of this
paper, the connected components of a loop data ﬂow graph
will simply be called loop data ﬂows.

In the case of composition between diﬀerent cryptographic
functions, that is, a function output used as input for an-
other function, they will be grouped into the same loop data
ﬂow. A solution to this is to consider every possible sub-
graph in the loop data ﬂow graph. For example, suppose
that G is the loop data ﬂow graph ({L1,L2,L3}, ), such
that L1  L2 and L2  L3, then we test during the compar-
ison phase not only the connected component {L1,L2,L3},
but also {L1,L2}, {L2,L3}, and ﬁnally each loop instance
alone. Thus, we will be able to identify cryptographic func-
tions used in combination with others.
7.2 Loop Data Flow Input-Output Parameters
Loop data ﬂows constitute our model for cryptographic
implementations and our ﬁnal objective is the extraction of
cryptographic parameters. We deﬁne loop data ﬂow param-
eters as memory loop instance parameters not used in the
internal data ﬂow, i.e. in loop instance grouping. Regarding
register parameters, we take input registers of the root loop
instances and output registers of the leaf ones, for the sake
of simplicity.

Definition 3. Let Gk = ({L1, . . . ,Ln}, ) be a loop data

ﬂow. Its input parameters INGk are deﬁned as

OU TM (Lj)

INR(Lr)

1≤i≤n

(cid:91)
(cid:91)

(cid:16)
INM (Li) − (cid:91)
(cid:16)
OU TM (Li) − (cid:91)

Lj Li

(cid:17)
(cid:91)
(cid:17) (cid:91)

Lr∈ROOT [Gk]

and its output parameters OU TGk are deﬁned as

1≤i≤n

LiLj

Ll∈LEAF [Gk]

INM (Lj)

OU TR(Ll)

The values of these parameters have been collected dur-
ing loop instance parameter extraction. Thus, we now have
a model to extract possible cryptographic implementations
from execution traces and collect their parameters. We can
now identify cryptographic functions.

8. COMPARISON PHASE

The ﬁnal step for our identiﬁcation technique is the com-
parison of loop data ﬂows with cryptographic reference im-
plementations. We consider two diﬀerent kinds of inputs:

• For each extracted loop data ﬂow Gk, we have the val-

ues of each parameter in INGk and OU TGk .

• For each common cryptographic function F, we have
a source code for a reference implementation PF . In
particular, a prototype describes its high-level parame-
ters, e.g. whether they are of a ﬁxed or variable-length.

The objective of the comparison algorithm is to check if
the relationship between values in INGk and OU TGk is also
maintained by PF . If so, it would imply that the code from
which Gk was constructed implements F. In other words, the
actual output values of PF must match the output values

174Table 1: Loop instance code in the execution trace of P. Each set of adjacent bytes manipulated by an
instruction is noted as a concrete variable.

I[Di]

mov edx, dword ptr [eax+ecx]
xor dword ptr [ebx+ecx], edx

add ecx, 0x4

WA[Di]

RR[Di]

eax:4 ecx:4

WR[Di]
edx:4

402008:4

ebx:4 ecx:4 edx:4

ecx:4

ecx:4

A[Di]
401011
401014
401017
40101a
40101d
401011
401014
401017
40101a
40101d

Di

RA[Di]
402000:4
402008:4

cmp ecx, dword ptr [esp]

12ffc0:4

esp:4 ecx:4

jnz 0x401011

mov edx, dword ptr [eax+ecx]
xor dword ptr [ebx+ecx], edx

402004:4
40200c:4

eax:4 ecx:4

edx:4

40200c:4

ebx:4 ecx:4 edx:4

add ecx, 0x4

ecx:4

ecx:4

cmp ecx, dword ptr [esp]

12ffc0:4

esp:4 ecx:4

jnz 0x401011

in OU TGk when PF is executed on the input values from
INGk .
In this section we will ﬁrst explain the hurdles we
encountered during the comparison phase design, and then
we will describe the actual comparison algorithm.
8.1 Difﬁculties

We use publicly available source codes as reference imple-
mentations. Consequently, there is a diﬀerence in the level
of abstraction between the parameters extracted from exe-
cution traces and the ones deﬁned in high-level source code.

Parameter type. Because what we extract with loop data
ﬂows are low-level parameters, i.e. contiguous memory
addresses and registers, it is not necessarily obvious
how to cast them back into the high-level types of the
function reference implementation. Indeed, this could
lead to artiﬁcial mismatches in the comparison, where
the same value has been represented diﬀerently. This
is why we choose reference implementations with pa-
rameters at the lowest possible level of abstraction,
namely raw values.

Parameter order. High-level implementations declare their

parameters in a speciﬁc order, but loop data ﬂow pa-
rameters are not ordered. Consequently, we have to
test all possible orders.

Parameter fragmentation. The same high-level parame-
ter can be divided in several loop data ﬂow parameters,
e.g. when it is passed by registers but can not ﬁt in
only one of them. Therefore, loop data ﬂow parameter
values have to be combined to build the high-level pa-
rameter value. In other words, the mapping between
loop data ﬂow parameters and their high-level coun-
terparts is not 1-to-1, but n-to-1.

Parameter number. Loop data ﬂow parameters not only
capture cryptographic parameters but also implementation-
dependent ones, as shown in the §6.3 example. Thus,
some loop data ﬂow parameters will not have a match-
ing high-level parameter.

8.2 Comparison Algorithm
ﬂow Gk with the following steps:

The comparison algorithm tries to identify a loop data

1. Generation of all possible I/O values Values in
INGk are combined by appending them to each other.

We generate all combinations of all possible lengths.
The same thing is done for output values in OU TGk .
For example, in §6.3 we generated as input parameters
5 values of length 4, 22 values of length 8 (all pairs
of 4-byte values in both order, plus the two 8-byte
values), etc. In practice the number of actual values
generated can be strongly reduced if the analyst elim-
inates obvious implementation-dependent parameters,
e.g. memory addresses.

2. Input parameter mapping. For each cryptographic
reference implementation PF , the algorithm selects for
each high-level parameter its possible values among
the ones generated in the previous step. In particular,
for ﬁxed-length parameters, only values with correct
length are chosen.

3. Comparison. The program PF is executed on each
possible combinations of its selected input values. If,
at some point, the values produced are in the set of the
possible output values generated in step 1, then it is a
success. If this is not the case, the algorithm iterates
until all combinations have been tested.

9. EVALUATION

We built a tool set, named Aligot, that implements the
whole identiﬁcation process, as described in Fig. 8. The
tool is made of approximately 2000 lines of Python, plus 600
lines of C++ for the tracer engine. The set of cryptographic
reference implementations has been built with the PyCrypto
package [16].

Figure 8: Aligot architecture

In order to evaluate Aligot, we used the following algo-
rithms: the Tiny Encryption Algorithm (TEA) [35], the RC4
algorithm [34], the Advanced Encryption Standard (AES) [8]
and the MD5 algorithm [23]. In addition, we explored the
identiﬁcation of modular multiplication in RSA [24]. For

BinaryProgramTracerExecutionTraceLoop Data FlowConstructionI/OParametersComparisonResultsReferenceImplementations175Table 2: Detection results for various synthetic and malware samples. The name of the identiﬁed function
is written and  indicates that no functions have been identiﬁed. Programs with ∗ are malware samples
protected with their own custom packer. Programs with † are sample programs packed with the commercial
packer AsProtect. The Sal column actually accounts for the (identical) results for the four Sality samples
Sal1, Sal2, Sal3 and Sal4.

Aligot

B1
TEA

B2
TEA

Storm∗
RTEA

SBank∗
RTEA

B3
RC4

Sal∗
RC4

B4
AES

†

B5
AES MD5 MD5

B6

B7

†

†

B8

Wal∗
AES, MOD
MUL
MD5



CryptoSearcher TEA
Draca
TEA
Findcrypt2
H&C Detector
Kerckhoﬀs
PEiD KANAL
Signsrch
SnDCryptoS

TEA
TEA

TEA







































TEA



TEA



TEA
TEA



































AES


AES




AES
AES
AES

















MD5
MD5
MD4
MD5



MD5



MD5



SHA-1



SHA-1









































each of these algorithms, we compared Aligot with currently
available cryptographic identiﬁcation tools on both synthetic
examples and malware samples.
9.1 Tiny Encryption Algorithm

TEA is an 8-byte block cipher using a 16-byte key and is
built as a 64-round Feistel network [35]. One of its partic-
ularities is the use of a constant value named delta, that is
ﬁxed at 0x9E3779B9 in its standard speciﬁcation.

9.1.1 Detection Evaluation on Synthetic Examples
First, we veriﬁed the correctness of our identiﬁcation pro-
cess: we created 2 synthetic examples based on the source
code published in the original TEA paper [35]. In each of
these synthetic examples, we simply called once the TEA
decryption function on the key 0xDEADBEE1...DEADBEE4 (16
bytes) and the encrypted text 0xCAFEBABECAFEBABE (8 bytes).
We then obtained the three following binary programs:

• B1: original TEA source code compiled with the Mi-
crosoft Visual Studio Compiler (MSVC) without any
optimization (/Od option).

• B2: same as B1, except that we replaced the standard
initialization of the delta value in assembly language
(mov reg, delta) with an lightly obfuscated version
using two instructions (add reg, delta/2). Conse-
quently, the algorithm semantics is preserved but delta
is no longer statically visible.

The detection results are presented in Table 2. We can

interpret these results in the following manner:

• B1 allows to calibrate the evaluation. Tools failing to
detect this classic implementation should not be con-
sidered as relevant, because they probably have no
means to detect TEA. Nevertheless, we still mention
their results for the sake of completeness.

• B2 is identiﬁed as a TEA implementation only by Aligot.
We can then conclude that other tools base their de-
tection solely on the static visibility of delta.

9.1.2 Detection Evaluation on Malware Samples
We investigated two malware families, called Storm Worm
and SilentBanker, that were publicly referenced as using
TEA [5, 22].
In both cases, the cryptographic implemen-
tation is part of the binary protection layers, that is, obfus-
cated code protecting the core logic. We collected one sam-
ple for each malware family, respectively Storm and SBank.
The detection results are presented in Table 2.

Storm Worm. No TEA implementations were identiﬁed in
the Storm Worm sample by Aligot. It means that, for each
extracted loop data ﬂow, its observed I/O relationship is not
reproducible with a TEA reference implementation, accord-
ing to our tool.

To conﬁrm this, we isolated the part of the Storm Worm
sample described as a TEA implementation by public sources
[5] and analyzed it in-depth: (i) the code is a 8-byte block-
cipher with a 16-byte key, exactly like TEA, (ii) the constant
value delta is used during the decryption process, and (iii)
arithmetic operations are similar to the ones used in TEA.
Nevertheless, we found a diﬀerence. Fig. 9(a) presents in
pseudo-C a code line from the Storm Worm cryptographic
implementation, whereas Fig. 9(b) shows the equivalent code
line in the original TEA source code. In the malware version
parenthesis are around exclusive-ors, whereas in the orig-
inal code they are around additions. Hence the malware
evaluates the expression in a diﬀerent order than TEA and
therefore produces diﬀerent results.

z− = (y << 4) + (k[2] ⊕ y) + (sum ⊕ (y >> 5)) + k[3]

(a) Storm Worm

z− = ((y << 4) + k[2]) ⊕ (y + sum) ⊕ ((y >> 5) + k[3])

(b) TEA

Figure 9: Comparison between implementations

We believe malware authors simply made a “copy/paste”
from existing code containing this error. In fact, we found
the same assembly code on a Russian website [30]. There-
fore, we named this new cryptographic function “Russian-

176TEA”. We conﬁrmed this observation by creating a refer-
ence implementation for the Russian-TEA function. Aligot
then successfully identiﬁed the code in Storm Worm as a
Russian-TEA implementation, as indicated in Table 2.

Silent Banker. Strangely enough, Aligot found no TEA im-
plementations in the SilentBanker sample either. However,
Aligot automatically identiﬁed a Russian-TEA implemen-
tation in it, something that we completely ignored before
running Aligot. After manual investigation, we conﬁrmed
that indeed the two malware families made the exact same
mistake. As a side note, SilentBanker was believed to have
been created in Russia [29]. Moreover, other tools identiﬁed
SilentBanker as containing a TEA implementation, because
the delta constant is statically visible in this case.

In summary, Aligot successfully identiﬁed that, despite

appearances, Storm Worm was not implementing TEA. More-
over, after adding a reference implementation for this new
cryptographic function (Russian-TEA), Aligot automatically
identiﬁed the same function in SilentBanker, whereas other
tools wrongly identiﬁed it as TEA.
9.2 RC4

The RC4 algorithm is a stream cipher using a variable-
length key [34]. A pseudo-random stream of bits is generated
with the key, then an XOR operation is done with the input
text in order to decrypt or encrypt it.

9.2.1 Detection Evaluation on Synthetic Example
Similarly as for TEA, we ﬁrst veriﬁed the correctness of
our identiﬁcation process. We created a synthetic example
by compiling a reference RC4 source code [34] with MSVC
without any optimization, that we denote as B3 in Table 2.
The detection result is presented in Table 2. Aligot is
the only tool able to identify this binary as RC4 implemen-
tation. Indeed this cryptographic function lacks particular
static signs (such as ﬁxed values), making it quite diﬃcult
to recognize with classic tools.

9.2.2 Detection Evaluation on Malware Samples
We investigated a malware family, named Sality, that was
publicly referenced as using RC4 in its protection layers [36].
We collected four Sality samples on the Internet: Sal1, Sal2,
Sal3 and Sal4. The detection results are presented in Table
2 in the column Sal, as they are the same for the four sam-
ples. Again, Aligot is the only tool able to identify an RC4
implementation in all binary programs.

As with the previous malware samples, the cryptographic
implementation is part of the protection layers and is heav-
ily obfuscated. Moreover, Sality samples contain a variety
of obfuscation techniques. In order to demonstrate this, we
provide in Table 4 a structural comparison between RC4
implementations in all binary programs, based on the num-
ber of basic blocks (BB) of the CFG and the average num-
ber of instructions per BB (this comparison concerns only
parts of each program recognized as RC4 implementations
by Aligot).

Moreover, thanks to the parameter graphs extracted from
each Sality RC4 implementation, we were able to identify
a pattern in the way the malware uses its cryptographic
parameters (two of these graphs are presented in Appendix
A). Each cryptographic parameter (key, input and output
text) is at the same oﬀset from the beginning of the ﬁle in

Table 4: Comparison between RC4 implementations
identiﬁed by Aligot, where NBB is the number of
Basic Blocks and IPBB is the average number of
instructions per Basic Block.

Sal1

9
40

Sal2
17
25

Sal3

4
97

Sal4
14
29

B3
18
7

NBB
IPBB

each sample, even though their values are diﬀerent. This
information is valuable to build a static unpacker for Sality,
as it gives a generic path to access cryptographic parameters.
9.3 AES

The AES algorithm is a 16-byte block cipher with a key
of either 128, 256 or 512 bits [8].
It processes input data
through a substitution-permutation network where each it-
eration (round) employs a round key derived from the in-
put key. Unlike in the simpler TEA and RC4 algorithms,
the ﬁrst and the last of these rounds are done outside the
main loop of AES, as they are functionally diﬀerent than
the other inner rounds. Consequently, when a comparison
with an AES reference implementation is made with Aligot,
only the I/O relationship for the inner rounds, i.e. the ones
inside a loop, will be veriﬁed, not for the parameters of the
AES algorithm in its entirety.

9.3.1 Detection Evaluation on Synthetic Example
We compiled a reference source code with the OpenSSL
library [12] without any optimization, where we simply en-
crypt a particular input text with AES-128, giving us the
program B4. As described in Table 2, most of the tools,
including Aligot, are able to identify such a program. Nev-
ertheless, Aligot is the only one able to infer the actual key
size, thanks to its knowledge of the parameters (in this case
the round keys).

9.3.2 Detection Evaluation on Obfuscated Programs
To show the resistance of our tool against obfuscation
techniques, we tested it on the two following binary pro-
grams: 1) the program B5, which is the result of the appli-
cation of the commercial packer AsProtect [1] on B4, and
2) W al, which is a sample of the Waledac malware fam-
ily, which was already known to use AES for encrypting its
Command and Control traﬃc [7].

In both cases, Aligot is the only tool to successfully iden-

tify AES-128.
9.4 MD5

The MD5 algorithm is a cryptographic hash function that
produces a 128-bit hash value [23]. The input message is
broken up into chunks of 512-bit that are then processed in
an iterative fashion. This core iterative behavior oﬀers an
opportunity for Aligot to identify this algorithm.

9.4.1 Detection Evaluation on Synthetic Example
Similarly as for AES, we compiled a reference source code
from the OpenSSL library [12] without any optimization,
where we simply hash a particular input text, giving us the
program B6. As presented in Table 2, most of the tools,
including Aligot, are successful in identifying MD5.

177Table 3: Aligot performance. LDF stands for “Loop Data Flow”, DI for “Dynamic Instruction”

Trace size (DI)

Tracing (min)
LDF construction
Comparison (min)
Total time

Storm SBank
3.5M

3M

Sal2

Sal3

Sal1
4.1M 1M 4.8M 4.2M

Sal4 W al
20k

4
4hr
30

3
6hr
30

2

10hr

3

4,5hr

6,5hr

10hr

1
4hr
3
4hr

2

2

1

10hr

15hr

40mn

4

4

10

10hr

15hr

51mn

9.4.2 Detection Evaluation on Obfuscated Programs
The obfuscated test cases were: 1) the program B7, pro-
duced using AsProtect on B6, and 2) W al, the same sample
of the Waledac family that uses MD5 in its payload to com-
pute unique ID for each bot.

Again, Aligot is the only tool to successfully identify MD5,

as described in Table 2.
9.5 RSA

The RSA algorithm [24] is an asymmetric cipher whose
security is based on the hardness of factoring large integers.
The two operations used for encryption and decryption are
modular exponentiation and modular multiplication. Modu-
lar exponentiation is typically implemented as a loop where
each iteration consists of either one multiplication or one
squaring and a multiplication, depending on the bit of the
exponent being referenced. This creates an outer loop pat-
tern that is not directly detectable with Aligot because the
trace generated does not belong to the LOOP language of
Deﬁnition 2. Nonetheless, the inner modular multiplication
loops are detectable and can serve as the basis for detection
of RSA or similar algorithms.
We built a synthetic example of an RSA encryption, de-
noted as B8, using the PolarSSL library [2] and also pro-
tected it with AsProtect. Since this library, as most RSA im-
plementations, uses the optimized Montgomery algorithm [20]
for modular multiplication, we added a reference implemen-
tation of this algorithm to the database, i.e. a sample non-
obfuscated program performing Montgomery multiplication
also constructed using Polar SSL. One of the problems with
RSA (and of other public-key algorithms) is the multiplic-
ity of possible parameter encoding (in this case large inte-
gers). Since Aligot retrieves parameters in the execution
trace in their low-level encoded form (i.e. representation in
memory), this might not match the high-level representation
of I/O parameters of the reference implementations (pro-
grammed in high-level languages). To deal with this, care
has to be taken to decode parameters before using them
with high-level implementations. As there is a relatively
small number of possible encoding used in practice, adding
decoding routines for each of them remains realistic. In this
case, we added a decoding routine for PolarSSL big numbers.
With this precaution, Aligot successfully identiﬁes the pres-
ence of modular multiplication operation (denoted as “MOD
MULT” in Table 2) in the obfuscated code of B8, while none
of the other tools are able to do so.
9.6 Further Results

Since compiler parametrization can signiﬁcantly changed
the structure of compiled code, we decided to test Aligot
and the other tools with samples compiled using various
space and speed optimization options. The performance of

Aligot was unaﬀected by these options, while some of the
other tools did lose their ability to identify the correspond-
ing crypto algorithm.

Furthermore, we considered the possibility that certain
implementations of crypto algorithms using ﬁxed constants,
might use diﬀerent values of these constants (without aﬀect-
ing their security) in order to avoid detection. In order to
explore this possibility, we tested Aligot against TEA im-
plementations with modiﬁed delta constant values. Thanks
to the use of a parametrized reference implementation TEA,
where the delta constant becomes an input parameter, Aligot
was still able to detect these modiﬁed TEA implementations.
All other tools failed to do so, which seems to conﬁrm that
their detection of TEA is based solely on recognition of the
standard delta constant value.
Finally, and as discussed at the end of §7.1, we also tested
Aligot against sample code where several crypto functions
were combined, e.g. Double TEA (two TEA applications in
a row), or a combination of one-time pad and RC4. As
expected, this was successfully detected by Aligot.
9.7 Performance

Table 3 presents our performance results for detection
on malware samples on a common end-user computer; the
performance for synthetic samples is comparatively much
quicker (in all cases under 20 min) and not shown. These
results should be considered as purely indicative, as Aligot
was built in ﬁrst place to prove the feasibility of the ap-
proach, and not to be a particularly eﬃcient tool. As can
be seen in Table 3 larger trace sizes do not always translate
into longer processing times (e.g Sality samples Sal3 and
Sal4). Indeed, the longest task is loop detection, and while
we gave a worst-case complexity estimate for it as a func-
tion of trace size in §5.4, in practice its performance also
strongly depends on the number of loops. If loops are rare
(according to our deﬁnition), then history size grows and
performance decreases. Regarding the comparison phase,
its performance depends in practice on the number of loop
data ﬂows extracted and their actual number of parameters.

10. LIMITATIONS

First of all, and like any other dynamic analysis tool,
Aligot is only able to identify code that is actually executed
at run time. Identifying which potential paths are relevant
for analysis and should be “fed” to such a tool is a separate
research problem. Nonetheless, in practice and for most mal-
ware samples, this can be handled with success by a skillful
malware analyst.

Second, Aligot’s identiﬁcation ability is limited to those
functions for which we possess a reference implementation.
Nevertheless, the design of the tool allows the analyst to

178to attribution of malware activities to particular groups or
individuals.

One of the limitations of our work, is the inability of the
current loop model to detect a full implementation of RSA,
due to the conditional behavior of the modular exponentia-
tion loop. While it is possible to modify the loop language to
include such conditional iterations, care has to be taken to
avoid including “artiﬁcial” loop constructions, such as those
generated by the control-ﬂow ﬂattening techniques discussed
in §5. Given the relatively simple conditional structure of
RSA (only two possible choices), it would be possible to
slightly modify to the loop language to include it, while ex-
cluding undesirable loop-like code.
As mentioned in §10, Aligot is only able to recognize
crypto that is known and for which a reference implementa-
tion has been constructed. In principle, this would prevent
the detection of “home-made” or other unknown crypto used
by malware authors in their code. However, our experience
with Russian TEA is inspiring: with some manual work we
were able to detect an unknown crypto algorithm (albeit, an
incorrect implementation of a known one). This suggests an
automated approach by which an unknown algorithm could
be detected, as long as an implementation for it has been
included into the reference database. The idea would be
to create an “import” tool able to extract reference imple-
mentations from unknown obfuscated binary samples, for
example from large databases of captured malware. By us-
ing the loop detection algorithm of Aligot, this tool could
reconstruct the binary code implementing the loops of in-
terest (possibly implementing crypto functions) that could
then be included into a reference implementation database.
A streamlined version of Aligot could then be used to ﬁnd
possible matches in this large database. Since the detection
process presented in this paper can be extended to any type
of functions maintaining a particular I/O relationship (e.g.
compression functions), this could provide the basis for a
new and promising methods of malware classiﬁcation.

Availability. To encourage follow-up research, we have made
available (1) the complete code for Aligot, (2) the set of bi-
naries used for experimental evaluation in this paper, and
(3) the version information and links for the other tools at
http://code.google.com/p/aligot/.

12. ACKNOWLEDGEMENTS

We would like to thank Pierre-Marc Bureau from ESET,
as well as Pierre Brun-Murol and Nicolas Falli`ere for their
help and insightful comments during this research project.

easily add new functions to the database, as it was demon-
strated for RTEA (as discussed in §9.1).

Despite the experimental results presented in this paper,
we are not claiming that our loop data ﬂow model captures
every possible cryptographic function obfuscated implemen-
tation. Indeed, computer program analysis is inherently un-
decidable, as stated by Rice’s theorem [13], and this theoret-
ical impossibility is particularly relevant in the adversarial
game of obfuscation.
In our case, malware authors could
simply implement cryptographic functions with loops that
do not correspond to our deﬁnition.
In response to this
move, we could deﬁne and use a more inclusive loop model.
Another counter-measure for malware writers could be to
encode their parameters in such a way it does not corre-
spond to standard encodings used by our high-level refer-
ence implementations. Such a technique could be bypassed
by adding speciﬁc decoding procedures in front of our ref-
erence functions, as exhibited in §9.5. While accepting that
no perfect solution exists, a clear deﬁnition of the analysis
context can lead to answers for speciﬁc cases.

11. CONCLUSIONS AND FUTURE WORK
In this paper, we presented a method for cryptographic
function identiﬁcation and parameter extraction in obfus-
cated programs. To this end, we introduced loop data ﬂows
as a substitute for higher-level abstractions in obfuscated
code. Based on this abstraction, we extracted input and
output parameters and compared them with those of known
cryptographic functions. We built the Aligot tool and tested
it against synthetic obfuscated programs and actual malware
samples containing known cryptographic functions, such as
the Tiny Encryption Algorithm (TEA), RC4, MD5, AES
and RSA.

The main result is that Aligot performs signiﬁcantly bet-
ter than all previous tools, which is not surprising since they
were not really designed for analysis of obfuscated code.
It is important to underline that while most other tools
are defeated by simple techniques, like changes in compiler
options and hiding of easily recognizable features, Aligot’s
ability remains the same. Aligot is also the only tool that
is able to detect these crypto functions on samples packed
with a commercial-grade code protector (AsProtect) and in
mildly obfuscated malware such as Storm, Silent Banker and
Waledac. Furthermore, Aligot is even able to perform ade-
quately in the presence of important changes in code struc-
ture due to severe obfuscation, such as the case of the Sality
malware.

Most importantly, even though we experimented with a
relatively small set of samples and cryptographic functions,
we were able to ﬁnd encouraging evidence of the usefulness
of cryptography identiﬁcation in obfuscated malware. In the
case of Sality, for example, using Aligot we were able to iden-
tify an invariant feature in each of the four samples exam-
ined (ﬁxed oﬀset of cryptographic parameters) that could be
used to automatically access the protected code (i.e. used by
static unpackers). Most surprisingly, we were able to detect
that the Storm Worm and Silent Banker binaries shared the
same error in the implementation of the TEA cryptographic
function. This is a strong indicator that malware authors
were either the same or were using the same code base. This
supports our proposition that analysis of cryptographic code
in malware could provide important information leading up

17913. REFERENCES
[1] AsProtect packer.

http://www.aspack.com/asprotect.html.

[2] Polar SSL library Web site. http://polarssl.org.
[3] A. Aho, J. Ullman, and S. Biswas. Principles of

Compiler Design. Addison-Wesley, 1977.

[4] L. Auriemma. Signsrch tool.

http://aluigi.altervista.org/mytoolz.htm.
[5] F. Boldewin. Peacomm.c Cracking the nutshell.

http://www.reconstructer.org/papers/Peacomm.
C-Crackingthenutshell.zip.

[6] J. Caballero, P. Poosankam, C. Kreibich, and D. Song.

Dispatcher: Enabling active botnet inﬁltration using
automatic protocol reverse-engineering. In Proc. 16th
ACM Conf. on Computer and Communications
Security (CCS), pages 621–634, 2009.

[7] J. Calvet, C. Davis, and P. Bureau. Malware authors
don’t learn, and that’s good! In Proc. 4th Int. Conf.
on Malicious and Unwanted Software (MALWARE),
pages 88–97. IEEE, 2009.

[8] J. Daemen and V. Rijmen. The design of Rijndael:

AES–the advanced encryption standard.
Springer-Verlag, 2002.

[9] N. Falli`ere. Reversing Trojan.Mebroot’s Obfuscation.

In Reverse Engineering Conference (REcon), 2010.

[10] F. Gr¨obert, C. Willems, and T. Holz. Automated

identiﬁcation of cryptographic primitives in binary
programs. In Proc. Recent Advances in Intrusion
Detection (RAID), pages 41–60. Springer, 2011.

[11] J. Halderman, S. Schoen, N. Heninger, W. Clarkson,
W. Paul, J. Calandrino, A. Feldman, J. Appelbaum,
and E. Felten. Lest we remember: cold-boot attacks
on encryption keys. Comm. of the ACM, 52(5):91–98,
2009.

[12] S. Henson et al. OpenSSL library.

http://openssl.org.

[13] J. Hopcroft, R. Motwani, and J. Ullman. Introduction

to automata theory, languages, and computation.
Addison-Wesley, 2007.

[14] M. Kobayashi. Dynamic characteristics of loops. IEEE

Trans. on Computers, 100(2):125–132, 1984.

[15] I. O. Levin. Draft crypto analyzer (draca).

http://www.literatecode.com/draca.

[16] D. Litzenberger. PyCrypto - The python cryptography

toolkit, 2011.

[17] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,

G. Lowney, S. Wallace, V. Reddi, and K. Hazelwood.
Pin: building customized program analysis tools with
dynamic instrumentation. ACM SIGPLAN Notices,
40:190–200, 2005.

[18] N. Lutz. Towards revealing attacker’s intent by

automatically decrypting network traﬃc. Master’s
thesis, ETH Z¨urich, Switzerland, 2008.

[19] C. Maartmann-Moe, S. Thorkildsen, and A. Arnes.
The persistence of memory: Forensic identiﬁcation
and extraction of cryptographic keys. Digital
Investigation, 6:S132–S140, 2009.

[20] P. Montgomery. Modular multiplication without trial

division. Mathematics of Computation,
44(170):519–521, 1985.

[21] M. Morgenstern and H. Pilz. Useful and useless

statistics about viruses and anti-virus programs. In
Proc. CARO Workshop, 2010.

[22] L. O Murchu. Trojan.silentbanker decryption.

http://www.symantec.com/connect/blogs/
trojansilentbanker-decryption.

[23] R. Rivest. RFC 1321: The MD5 message-digest
algorithm. Internet Activities Board, 143, 1992.

[24] R. Rivest, A. Shamir, and L. Adleman. A method for

obtaining digital signatures and public-key
cryptosystems. Comm. of the ACM, 21(2):120–126,
1978.

[25] C. E. Shannon. Communication theory of secrecy

systems. Bell System Technical Journal,
28(4):656–715, 1949.

[26] N. Stewart. Inside the storm: Protocols and

encryption of the Storm botnet. In Black Hat
Technical Security Conference, 2008.

[27] S. Trilling. Project Green Bay - Calling a Blitz on

Packers. In CIO Digest: Strategies and Analysis from
Symantec, 2008.

[28] J. Tubella and A. Gonz´alez. Control speculation in

multithreaded processors through dynamic loop
detection. In Proc. 4th Int. Symp. on
High-Performance Computer Architecture, pages
14–23. IEEE, 1998.

[29] VeriSign. Silentbanker analysis.

http://www.verisign.com/static/043671.pdf.

[30] Russian TEA assembly code.

http://www.xakep.ru/post/22086/default.asp.

[31] C. Wang, J. Hill, J. Knight, and J. Davidson. Software

tamper resistance: Obstructing static analysis of
programs. Technical Report CS-2000-12, University of
Virginia, 2000.

[32] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace.

ReFormat: Automatic reverse engineering of
encrypted messages. In Proc. ESORICS, pages
200–215, 2009.

[33] PEiD Krypto Analyzer (kanal).

http://www.peid.info.

[34] RC4 source code. http://cypherpunks.venona.com/

date/1994/09/msg00304.html.

[35] D. Wheeler and R. Needham. TEA, a tiny encryption

algorithm. In Proc. Fast Software Encryption, pages
363–366. Springer, 1995.

[36] V. Zakorzhevsky. A new version of Sality at large.

http://www.securelist.com/en/blog/180/A_new_
version_of_Sality_at_large.

[37] R. Zhao, D. Gu, J. Li, and R. Yu. Detection and

analysis of cryptographic data inside software.
Information Security, pages 182–196, 2011.

180APPENDIX
A. LOOP INSTANCE DETECTION

ALGORITHM

We used the following data structures to implement the

algorithm:

• History: list-like structure storing machine instructions
already seen along with loop IDs. In the pseudo-code
the History variable is named H.

• LoopInstance: structure containing information related

to a loop instance.

• RunningLoops: set of running loops; each of these items
is a stack representing a loop nesting: the head con-
tains the LoopInstance of the most nested loop, whereas
the rest of the stack contains the higher loops. In the
pseudo-code the RunningLoops variable is named RL.

The main procedure pseudo-code is given in Algorithm
1, whereas the core logic of the loop detection is contained
in the recursive procedure M atch() given in Algorithm 2.
Some operations are described directly in natural language
to ease the understanding and some details are hidden for
the same reason.
The algorithm is build on a simple rule: a machine instruc-
tion is either part of a conﬁrmed loop instance or a possible
beginning for such instances, but not both at the same time.
This dichotomy is expressed in the main procedure: for each
instruction the for-loop checks if a conﬁrmed instance waits
for it and if so — Match() procedure returns 1 — the others
instances are not tested and the instruction is not consid-
ered as a possible loop beginning. On the other hand, if no
conﬁrmed loop instance waits for the instruction, then the
second part of the main procedure checks if it could be a
loop beginning. During this process the history stores ma-
chine instructions that have not been (yet) proved to be part
of a conﬁrmed loop.

Algorithm 1 Loop Instance Detection Main Procedure
Require: T

T RACEx86, H : History, RL :

:

RunningLoops

1: for i = 1 to Length(T ) do
2:
3:
4:

Conf irmedInstanceW aitsF orM e ← 0
for StackOf Loops in RL do

if Match(StackOf Loops, I[Di], History) = 1
then

Conf irmedInstanceW aitsF orM e ← 1
Break

end if
end for
if Conf irmedInstanceW aitsF orM e = 0 then

Append(H, I[Di])
if there exists others I[Di] occurrences in H then

Create associated loop instances
Add them to RL

5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
end if
16: end for

end if

B. PARAMETER GRAPHS

Algorithm 2 Loop Instance Detection Match Procedure
Require: StackOf Loops : Stack(LoopInstance), Ij : X 86,

H : History

1: if StackOf Loops is empty then
return 0 {Base case: failure}
2:
3: end if
4: currentInstance ← Head(StackOf Loops) {Get the

most nested loop}

Increment currentInstance.cursor
Create new instance I for the loop X
Push(StackOf Loops, I)
return Match(StackOf Loops,Ij,H)

5: if currentInstance.cursor points to a loop ID X then
6:
7:
8:
9:
10: else
11:
12:
13:

Increment currentInstance.cursor
if currentInstance iterates for the second time
then

if currentInstance.cursor points to Ij then

Remove currentInstance instructions from H
currentInstance.conf irmed ← 1
Append(H, currentInstance.ID)

end if
if currentInstance.conf irmed = 1 then

return 1 {Success}
return 0 {Failure}

else

end if

14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32: end if

else

else

end if

end if

if currentInstance.conf irmed = 1 then

Pop(StackOf Loops)
return Match(StackOf Loops,Ij,H)

Discard StackOf Loops
return 0 {Failure}

181(a) Sal1 parameter graph for the part recognized as RC4 by Aligot: 542000:11 is the key, 542116:65258 the input text
and 542116:65258 the output text.

(b) Sal2 parameter graph for the part recognized as RC4 by Aligot: 410000:8 is the key, 410116:57066 the
input text and 410116:57066 is the output text.

Figure 10: Parameter graphs. Only the ﬁrst 8 bytes of parameter values are displayed. Every cryptographic
parameter starts at the same oﬀset from the ﬁle beginning (0x542000 for Sal1 and 0x410000 for Sal2).

182