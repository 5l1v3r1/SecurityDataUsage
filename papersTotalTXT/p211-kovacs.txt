Relational Abstract Interpretation for the Veriﬁcation of

2-Hypersafety Properties

Máté Kovács

Technische Universität
München, Germany

kovacsm@in.tum.de

Helmut Seidl

Technische Universität
München, Germany
seidl@in.tum.de

Bernd Finkbeiner

Universität des Saarlandes,

Germany

ﬁnkbeiner@cs.uni-sb.de

ABSTRACT
Information ﬂow properties of programs can be formalized
as hyperproperties specifying the relation of multiple execu-
tions.
In this paper, we therefore introduce a framework
for proving 2-hypersafety properties by means of abstract
interpretation. The main idea is to apply abstract interpre-
tation on the self-compositions of the control ﬂow graphs of
programs. As a result, our method is inherently capable of
analyzing relational properties of even dissimilar programs.
Constructing self-compositions of control ﬂow graphs is
nontrivial. Therefore, we present an algorithm for construct-
ing quality self-compositions driven by a tree distance mea-
sure between the abstract syntax trees of subprograms. Fi-
nally, we demonstrate the applicability of the approach by
proving intricate information ﬂow properties of programs
written in a simple language for tree manipulation motivated
by the Web Services Business Process Execution Language.

Categories and Subject Descriptors
F.3.1 [Logics and Meanings of Programs]: Specifying
and Verifying and Reasoning about Programs—Mechanical
veriﬁcation

Keywords
abstract interpretation; hyperproperties;
control; semi-structured data

information ﬂow

1.

INTRODUCTION

Abstract interpretation [12] is a well established approach
for proving safety properties of programs. However, an in-
teresting class of properties, namely information ﬂow prop-
erties, are best formalized not as safety properties, but as
safety hyperproperties [10]. Safety hyperproperties are not
invariants maintained by individual runs of systems but are
properties of multiple runs.

In [10] it has been observed that the veriﬁcation of k-
hypersafety properties can be reduced to the veriﬁcation of

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516721.

ordinary safety properties of the k-fold self-composition of
the program.
In this paper we apply this idea to control
ﬂow graphs (CFG), and present a method for proving 2-
hypersafety properties. We apply the general approach for
proving noninterference of programs written in an XML ma-
nipulating language.

Listing 1: A BPEL fragment updating the health
status of patients based on the variable test
< if name =" If " >

< condition > <![ CDATA [ $test < 0.5]] >
</ condition >

< assign name =" E v a l G o o d " >

< copy > < from >" good " </ from >

<to > $pList / p a t i e n t R e c o r d [ id = $ p a t i e n t I d ]

/ health / text ()

</ to > </ copy >

</ assign >

< else >

< assign name =" E v a l P o o r " >

< copy > < from >" poor " </ from >

<to > $pList / p a t i e n t R e c o r d [ id = $ p a t i e n t I d ]

/ health / text ()

</ to > </ copy >

</ assign >

</ else >

</ if >

Noninterference means that two executions are indistin-
guishable based on public observations if their initial states
only diﬀer in secret data [19]. Consider, e.g., the code frag-
ment in Listing 1 written in the Web Services Business Pro-
cess Execution Language [3] (BPEL). The fragment is meant
to update the health status of patients stored in the data
structure of variable pList. The actual patient is identiﬁed
by the value in the variable patientId, while the update
depends on the value of test. Our goal is to prove that the
value of test only interferes with the health status in the
description of the patient, but neither with his name nor
with the size of the data structure etc. It is challenging, be-
cause data manipulation is carried out in diﬀerent branches
depending on the secret. By comparing two executions cor-
responding to the two branches, we notice, however, that
only the health status of the patient with the given id can
be diﬀerent in the results, while all public data remain equal.
In this paper we show a method to prove properties like this
automatically using static analysis.

We regard the execution of a program as the sequence of
assignments and condition evaluations that take place dur-
ing the computation. We take advantage of the fact that
inserting skip instructions into arbitrary places of an ex-

211ecution does not change the result. Therefore, diﬀerent
alignments of a pair of executions can be achieved by the
insertion of skip instructions. Knowing an initial abstract
value describing the potential set of pairs of initial states,
we are interested in computing the ﬁnal abstract value de-
scribing the possible set of pairs of states that can result
from any pairs of executions. For that we require a rela-
tional abstract domain describing pairs of concrete states,
together with abstract transformers for pairs of instructions
set in alignment within the two executions. The abstract ef-
fect of a given pair of executions w.r.t. a ﬁxed alignment of
instructions is obtained by applying the composition of the
occurring transformers to the initial abstract value. Since
the abstract eﬀect of any alignment results in a safe over-
approximation of the desired outcome, we can approximate
it by the greatest lower bound over all alignments. In order
to obtain a safe approximation for all pairs of executions
reaching a given pair of program points, we then take the
least upper bound of the values provided for each pair of
executions individually. We refer to this value as the merge
over all twin computations (MTC) solution, and consider it
as the ideal solution of the analysis problem.

In general, it might be diﬃcult to compute the MTC so-
lution directly. Instead, we propose to select one promising
static alignment of instructions for each pair of executions
resulting in a self-composition of the CFG of the program.
Here, the key problem is to ﬁnd decent self-compositions of
CFGs, which is nontrivial. Therefore, we present an algo-
rithm to construct them recursively based on the abstract
syntax trees of programs. In order to achieve maximal preci-
sion, the structural similarities of two subprograms are taken
into account using a tree distance measure during the con-
struction. Once a particular self-composition of the CFG
is ready, an over-approximation of the MTC solution is ob-
tained as a solution to a constraint system formulated based
on the self-composition.

Our goal is to apply the general approach described above
to verify the security of web service orchestrations imple-
mented e.g., in BPEL. Web service orchestrations may im-
plement workﬂows within organizations having access to sen-
sitive data, while communicating with external partners over
the Internet. Therefore, the security of these processes and
the information they maintain should be granted. On the
other hand, the central concept of the web service technolo-
gies is that data is stored in XML documents. Accordingly,
the BPEL language is optimized for XML manipulation us-
ing XPath [8] expressions and XSLT [22] transformations.
The extra challenge here is that information ﬂow policies
may not only refer to values of variables but to parts of the
documents stored in variables too. Accordingly, informa-
tion ﬂow policies are composed in terms of public views of
document trees specifying the potential positions of secrets.
Therefore, we introduce an abstract domain based on regu-
lar sets of public views of documents together with abstract
transformers modeling operations on document trees using
Horn clauses. During the analysis implications are generated
to specify the relations of abstract values corresponding to
the nodes of the self-composition of the CFG. These impli-
cations fall into a special category, which can be solved e.g.,
using H1-normalization [31, 37].

In order to simplify the presentation and concentrate on
the key issues of information ﬂow, we restricted ourselves to
a minimalistic “assembly” language for tree manipulation.

To summarize, this paper has the following contributions:
• We introduce the ideal solution of the analysis problem
of pairs of executions of a program, and propose to
overapproximate it by applying abstract interpretation
on a particular self-composition of the corresponding
CFG.

• A concrete algorithm for the construction of self-com-
positions of CFGs is proposed, which is driven by a
tree distance measure in order to take into account
the similarities of subprograms.

• We demonstrate the applicability of the general frame-
work using a complex abstract domain for semi-struc-
tured data. Based on the self-composition, a transla-
tion is proposed into Horn clauses, which can be solved,
e.g., by means of H1-normalization [31, 37].

• The approach is evaluated on case studies found in the

literature [2, 5, 16].

The rest of the paper is structured as follows. In Section
2 the theoretical framework is elaborated. In Section 3 we
show a method to construct the necessary self-compositions
of CFGs based on structured programs, while in Section 4 we
instantiate our approach for the case of a tree-manipulating
programming language.
In Section 5 we validate the pre-
sented analysis using practical experiments on case studies
found in the literature. In Section 6 we relate our work to
others, and in Section 7 we conclude.

2. MERGE OVER ALL TWIN COMPUTA-

TIONS

In this section we establish the formal groundwork for
proving 2-hypersafety properties using relational abstract
interpretation.

We deﬁne the semantics of programs by means of control-
ﬂow graphs (CFG). A CFG is a tuple G = (N, E, nin , nﬁ )
consisting of a set of nodes N including the unique initial
and ﬁnal nodes nin and nﬁ , and a set of directed and labeled
edges E. Members of the set E are of the form (n1, f, n2),
where the nodes n1 and n2 are the initial and ﬁnal nodes
of the edge and the label is f . Labels f of edges represent

state transformers(cid:74)f(cid:75) : S (cid:57) S, i.e., partial mappings on the
skip with(cid:74)skip(cid:75)s = s for all s ∈ S. A run or execution of
the individual labels: (cid:74)π(cid:75)s0 =(cid:74)f1...fn(cid:75)s0 =(cid:74)fn(cid:75)◦...◦(cid:74)f1(cid:75)s0.

a program is deﬁned by a path from the initial node to the
ﬁnal node. The eﬀect of the sequence of labels π = f1...fn
of edges in a run is given by the composition of the eﬀects of

set of states S. We presume the existence of a special label

In the rest, we denote the set of sequences of labels of paths
from node n1 to node n2 by n1 ; n2.

Properties we aim to verify in this paper are deﬁned below:

Definition 1. We deﬁne a 2-hypersafety property by an
initial and a ﬁnal relation of program states ρin , ρﬁ ⊆ S × S.
A program given by CFG G = (N, E, nin , nﬁ ) satisﬁes the
2-hypersafety property speciﬁed by ρin and ρﬁ , if for all pairs
of initial states (s0, t0) ∈ ρin and all pairs of ﬁnal states s =
π1, π2 ∈ nin ; nﬁ , it holds that (s, t) ∈ ρﬁ .

(cid:74)π1(cid:75)s0 and t = (cid:74)π2(cid:75)t0 reachable by arbitrary computations

212When applying abstract interpretation to this problem, we
may choose a Cartesian abstraction of pairs of states. This
means that each program state in the pairs is abstracted sep-
arately. Let us brieﬂy argue why this approach may often
return unsatisfactory results. Consider, e.g., the program
p =if h>5 then l:=l+2 else l:=l+2, with integer variables h
and l. Assume that ρin and ρﬁ consist of all pairs of states
where the values of variable l are equal. Since the precise
initial values for l are unknown, the ﬁnal values for l will
also be unknown, implying that their equality cannot be in-
ferred. Therefore, better results can be obtained by using
a relational abstraction of pairs of program states. A rela-
tional abstraction of pairs of program states may record the
fact that the variables l in the two program states tracked
in parallel are equal, and that this equality is preserved by
all possible pairs of program executions.
In general, let (D,(cid:118)) be a complete lattice forming a Ga-
lois connection (P(S×S), α, γ, D) with the powerset of pairs
of states P(S × S), where α : P(S × S) → D is an abstrac-
tion function and γ : D → P(S × S) is a concretization
function. The only requirement for abstract transformers

(cid:74)f, g(cid:75)(cid:93) of pairs of labels (f, g) (otherwise called twin steps)

is that they must satisfy the following property:

γ((cid:74)f, g(cid:75)(cid:93)d) ⊇ { (s(cid:48), t(cid:48)) | ∃(s, t) ∈ γ(d) :
(cid:74)f(cid:75)s = s(cid:48) ∧(cid:74)g(cid:75)t = t(cid:48)

}

(1)

Given two sequences1, π1 and π2, the set of all possible

alignments A(π1, π2) is recursively deﬁned by:

A(ε, ε)
A(ε, gπ)

= ε ∪ {(skip, skip)ω | ω ∈ A(ε, ε)}
= {(skip, g)ω | ω ∈ A(ε, π)}∪
= {(f, skip)ω | ω ∈ A(π, ε)}∪
A(f π, ε)
A(f π1, gπ2) = {(f, g)ω | ω ∈ A(π1, π2)}∪

{(skip, skip)ω | ω ∈ A(ε, gπ)}
{(skip, skip)ω | ω ∈ A(f π, ε)}
{(skip, g)ω | ω ∈ A(f π1, π2)}∪
{(f, skip)ω | ω ∈ A(π1, gπ2)}∪
{(skip, skip)ω | ω ∈ A(f π1, gπ2)}

(2)

According to (2), an alignment of two sequences of labels of
a CFG, π1 and π2, is a sequence of twin steps ω represent-
ing both of the original runs. The insertion of skip labels

does not change the result of a run. Therefore, if(cid:74)π1(cid:75)s0 =
s, (cid:74)π2(cid:75)t0 = t, ω ∈ A(π1, π2) and ω = (f1, g1)...(fn, gn),
then we can write that (s, t) = (cid:74)ω(cid:75)(s0, t0) = (cid:74)(f1, g1)...
(fn, gn)(cid:75)(s0, t0) = (cid:74)fn, gn(cid:75) ◦ ... ◦(cid:74)f1, g1(cid:75)(s0, t0), where for
each i, (si, ti) = (cid:74)fi, gi(cid:75)(si−1, ti−1) if si = (cid:74)fi(cid:75)si−1 and
ti =(cid:74)gi(cid:75)ti−1 so that s = sn and t = tn.
d = (cid:108)
ω∈A(π1,π2)(cid:74)ω(cid:75)(cid:93)d0

Given two runs π1, π2 and an abstract value d0, we are
interested in the most precise abstract value d that can be
computed using the abstract semantics of twin steps:

Since there can be multiple pairs of paths executed on the
members of the concretization of an initial abstract value,
we obtain a sound overapproximation for the abstract value
at any pair of nodes by computing the least upper bound
of the abstract eﬀects for all possible pairs of paths of the
CFG reaching these nodes.

1In this paper we apply the alignment construction to se-
quences of labels of CFGs, and in later sections to programs,
i.e., sequences of commands as well.

Definition 2. Given a CFG G = (N, E, nin , nﬁ ) and the
initial abstract value d0, the merge over all twin computa-
tions solution is deﬁned by:

(cid:71)

π1∈nin ;nﬁ
π2∈nin ;nﬁ

(cid:108)
ω∈A(π1,π2)(cid:74)ω(cid:75)(cid:93)d0

MTC(G, d0) =

The MTC solution can be considered as the extension of
the meet over all paths (MOP) solution of Kam and Ullman
[21] to pairs of paths on the CFG.

Theorem 1. Consider a pair of sequences of labels π1, π2
∈ nin ; nﬁ on the CFG G = (N, E, nin , nﬁ ), and states
γ(d0). In this case d (cid:119) MTC(G, d0) implies (s, t) ∈ γ(d).

s0, s, t0, t ∈ S, where s = (cid:74)π1(cid:75)s0, t = (cid:74)π2(cid:75)t0 and (s0, t0) ∈

The proof can be found in [23].

According to Theorem 1, the MTC solution is an abstrac-
tion of all possible pairs of states resulting from any pair of
executions of the program. This result can be used to infer
how relations of initial states are translated into relations
of ﬁnal states and thus prove 2-hypersafety properties. In
general it might be diﬃcult, though, to compute the MTC
solution directly. A perhaps less precise, but still sound solu-
tion is obtained by restricting the set of alignments A(π1, π2)
for which the greatest lower bound is computed in the MTC
solution. In particular, we may even ﬁx a single alignment
for each pair of paths. Such a ﬁxed alignment can be ob-
tained by constructing a self-composition GG of the CFG
G. For later use, we deﬁne more generally, when is a graph
a composition of two CFGs.

in , nH

in ; n(cid:48)

ﬁ and πH ∈ nH

ﬁ ), GH = (N(cid:48), E(cid:48), n(cid:48)

Definition 3. Given the CFGs G = (N G, EG, nG
in , n(cid:48)

in , nG
ﬁ )
and H = (N H , EH , nH
ﬁ ) is a
composition of G and H, if each edge in E(cid:48) has a label (f, g)
where f and g are labels of G and H, respectively, or skip,
and furthermore for all πG ∈ nG
in ; nH
in ; nG
ﬁ so that ωπG,πH ∈ A(πG, πH ).
there is an ωπG,πH ∈ n(cid:48)
ﬁ
According to Deﬁnition 3, a CFG GG is considered to be
a self-composition of G, if for all pairs of paths on G there
is a path on GG so that the latter is an alignment of the
former two paths. Note that due to the insertion of skip
operations, a self-composition may be quite diﬀerent from
the Cartesian product of the two graphs, where every two
aligned paths have exactly the same length.

Theorem 2. Given the CFG G = (N, E, nin , nﬁ ) and a
ﬁ ), the following

self-composition of it GG = (N(cid:48), E(cid:48), n(cid:48)

in , n(cid:48)

holds for all d0: (cid:71)

(cid:74)ω(cid:75)(cid:93)d0 (cid:119) MTC(G, d0)

ω∈n(cid:48)

in

;n(cid:48)

ﬁ

For the proof, please, refer to [23].

By Theorem 2, any solution of the analysis problem [21]
corresponding to the self composition GG of G is a safe
overapproximation of MTC(G, d0).

Proving a 2-hypersafety property by means of our meth-
ods succeeds in two steps. First, a self-composition GG of
the CFG is constructed. The graph GG gives rise to a con-
straint system over a suitable relational abstract domain,
which describes how relations of states are transformed by
pairs of edges. A solution to this constraint system then pro-
vides the analysis result. Accordingly, the two key practical

213problems consist in ﬁnding a decent self-composition and
a decent abstract domain, which achieve reasonable preci-
sion at an acceptable price. Note that diﬀerent analysis
results can be obtained if diﬀerent self-compositions are cho-
sen. Theorem 2 guarantees that all results are sound, and
therefore allow to increase the precision of the analysis.
3. SELF-COMPOSITIONS OF CONTROL

FLOW GRAPHS

sen, we assume that abstract transformers(cid:74)f, f(cid:48)(cid:75)(cid:93) for pairs

When an appropriate alignment of computations is cho-
of identical or similar actions f, f(cid:48) are more precise than ab-
stract transformers for arbitrary pairs. Therefore, the goal
is to maximize the number of edges labeled (f, f(cid:48)) in a self-
composition of a CFG. If the program in question has been
speciﬁed by means of a structured programming language,
a quality self-composition can be obtained by means of syn-
tactically matching abstract syntax trees (ASTs) of program
fragments.

c2cfg(if b { ptt} else {pff}, nin , nﬁ ):

nin

¬b

nff
in

b

ntt
in

p2cfg(ptt, ntt

in , nﬁ )

p2cfg(pff, nff

in , nﬁ )

nﬁ

c2cfg(while b {p}, nin , nﬁ ):

nin

¬b

b

ntt
in

nﬁ

p2cfg(p, ntt

in , nin )

Figure 1: CFGs corresponding to branching con-
structs

In order to illustrate the approach, assume that programs
are generated by the nonterminal p of the grammar below:

(program)
(command)

p ::= c; | c;p
c

::= skip | x := e | while b {p} |

if b {ptt} else {pff}

(3)

The grammar (3) deﬁnes a structured programming lan-
guage, where the state of execution and the syntax of expres-
sions e and b will be instantiated for our tree-manipulating
language in Section 4.

CFGs of programs are constructed by two mutually re-
cursive functions “program to CFG” (p2cfg) and “command
to CFG” (c2cfg). The CFG corresponding to the program p
can be obtained by means of the function p2cfg(p, nin , nﬁ ),
where the initial and ﬁnal nodes of the resulting graph are
nin and nﬁ , respectively. In case p = c1;...;cm, then m − 1
fresh nodes are instantiated, and c2cfg(ci, ni−1, ni) is called
for each i to construct the CFG fragment corresponding to
the command ci so that n0 = nin and nm = nﬁ . c2cfg(skip,
ni, ni+1) = (ni, skip, ni+1) and c2cfg(x:=e, ni, ni+1) = (ni,
x:=e, ni+1), furthermore, the CFG fragments corresponding
to branching constructs are shown in Figure 1.

A self-composition of the CFG corresponding to a pro-
gram can be constructed by two mutually recursive functions

“pair of programs to CFG” (pp2cfg) and “pair of commands
to CFG” (pc2cfg). The function pp2cfg(p1, p2, nin , nﬁ ) can
also be called for two diﬀerent programs, p1 and p2, in order
to align the two alternatives in a conditional. The function
makes use of a distance measure for trees as introduced, e.g.,
in [34]. The evaluation of pp2cfg(p1, p2, nin , nﬁ ) proceeds in
two steps:

Step 1: Computing a Best Alignment of Two Programs.

Here, we adapt the deﬁnition of sets of alignments (2)
to two sequences of commands. An optimal alignment of
two sequences of commands, c1;...;ck and d1;...;dl, with
respect to a tree distance measure td is the sequence of pairs
of commands ωopt, where the distances td(cωopt
) of
i
the ASTs of the aligned pairs of commands (cωopt
, dωopt
)
is minimal. Formally, an optimal alignment ωopt of p1 =
c1;...;ck and p2 = d1;...;dl is deﬁned as:

, dωopt

i

i

i

(cid:88)

ωopt = arg min
ω∈A(p1,p2)

1≤i≤|ω|

td(ω[i].1, ω[i].2)

(4)

In (4), ω[i] stands for the pair of commands number i in the
sequence ω, and ω[i].1 and ω[i].2 denote the ﬁrst and second
components of the pair respectively. In our implementation
we use the Robust Tree Edit Distance described in [32] as
tree distance measure.

Step 2: Computing the Compositions of CFGs of Pairs
of Commands.

If the alignment is ready, the compositions of the CFGs
corresponding to the aligned pairs of commands need to
be constructed. Assume that the chosen alignment of the
two programs is ω = (c1, d1)...(ck, dk). In this case we in-
stantiate a fresh node for each 1 ≤ i ≤ k − 1, and call
pc2cfg(ci, di, ni−1, ni) so that n0 = nin and nk = nﬁ .

Now we discuss how the subgraphs corresponding to pairs
of commands are constructed. First, the roots of the ab-
stract syntax trees corresponding to the commands are com-
pared. The roots of the ASTs corresponding to c and d are
considered composable in the following cases:

• c = d = x := e or c = d = skip, i.e., in case of assign-
ments the commands need to be identical including the
variable on the left and the expression on the right.

• c = if b1 {p1

{p2

ff}.

tt} else {p1

ff} and d = if b2 {p2

tt} else

• c = while b1 {p1} and d = while b2 {p2}.

In case the roots of the ASTs of the commands c and d
are not composable, then we put them in sequence. This is
achieved by means of two additional functions. The func-
tion skip1(G) replaces each label f of the edges of the graph
G with (skip, f ), and similarly, skip2(G) replaces these la-
bels with (f, skip). In order to compute pc2cfg(c, d, nin , nﬁ )
in this case, we instantiate a fresh node n(cid:48) and compute
skip2(c2cfg(c, nin , n(cid:48))) and skip1(c2cfg(d, n(cid:48), nﬁ )).

It remains to consider a pair of commands c and d where
the roots of the corresponding ASTs are composable. If they
are not branching constructs, then pc2cfg(c, d, nin , nﬁ ) =
(nin , (c, d), nﬁ ).

Now consider a pair of branching constructs. The corre-
sponding self-compositions are illustrated in Figure 2. Here,

214The resulting CFG of pc2cfg(p1, p2, nin , nﬁ ), where p1 = if b1 { p1

ff}, and p2 = if b2 { p2

tt} else {p2

ff}:

(b1,¬b2)

nin

tt} else {p1
(¬b1, b2)

ntt,tt

in

(b1, b2)

(¬b1,¬b2)

nff,ff

in

ntt,ff

in

pp2cfg(p1

tt, p2

tt, ntt,tt

in

, nﬁ ) pp2cfg(p1

ff, p2

ff, nff,ff

nff,tt

in

, nﬁ )

in
pp2cfg(p1

ff, p2

tt, nff,tt

in

, nﬁ )

pp2cfg(p1

tt, p2

ff, ntt,ff

in

, nﬁ )

nﬁ

The resulting CFG of pc2cfg(while b1 { p1}, while b2 { p2}, nin , nﬁ ):

(b1, b2)

(b1,¬b2)

ntt,tt

in

ntt,ff

in

nin
(¬b1,¬b2)

pp2cfg(p1, p2, ntt,tt

in

, nin )

skip2(p2cfg(p1, ntt,ff

in

, n(cid:48)))

n(cid:48)

nﬁ

(¬b1, b2)

nff,tt

in

skip1(p2cfg(p2, nff,tt

in

(b1, skip)
n(cid:48)(cid:48)

, n(cid:48)(cid:48)))

(¬b1, skip)

(skip, b2)

(skip,¬b2)

Figure 2: The compositions of CFGs corresponding to branching constructs

the idea is to compose the CFGs of the bodies of the branch-
ing constructs according to all possible valuations of the con-
ditional expressions, and then connect them with edges so
that they become compositions of the branching constructs
according to Deﬁnition 3. In particular, the composition of
two loops results in three. One loop handles the case when
the bodies are executed simultaneously, the other two exe-
cute the body of only one original loop. This way we handle
the situation, when the two original loops execute a diﬀerent
number of times.

Note that the functions pp2cfg and pc2cfg are mutually
recursive. Accordingly, subprograms at each level of the
ASTs are aligned separately.

The following theorem states the correctness of the con-

struction of self-compositions of CFGs introduced above.

Theorem 3. Consider a program p together with its CFG
G constructed by the function p2cfg(p, nin , nﬁ ). In this case,
the resulting CFG of the function pp2cfg(p, p, n(cid:48)
ﬁ ) is a
self-composition of G according to Deﬁnition 3.

in , n(cid:48)

The proof is by induction on the abstract syntax tree of p.
Please, refer to [23] for the details.

4. PROVING NONINTERFERENCE

In this section we show how to apply the developments of
Sections 2 and 3 in order to verify information ﬂow proper-
ties of tree-manipulating programs. In Section 4.1 the pro-
gramming language (3) is instantiated with an expression
language optimized for tree manipulation, and in Section
4.2 an abstract interpretation is introduced. In Section 4.3 a
case study is presented, where we model the BPEL fragment
of Listing 1 with a program implemented in our language,
and prove an information ﬂow property on it.
4.1 A Language for Tree Manipulation

XML documents are unranked ordered trees, where there
is no bound on the number of children of nodes. For the

patientRecord

id

name

health

’123’ ’J.Doe’

’good’

...

patientRecord

id

’123’

name

’J.Doe’

health

’good’

#

patientRecord

...

id

’144’

name

’R.Miles’

health

’poor’

#

Figure 3: A document tree describing a patient
(top), and the corresponding binary representation
as member of a list (bottom)

sake of simplicity, here we represent tree-shaped data using
binary trees by means of the ﬁrst-child-next-sibling (FCNS)
encoding [11]. Figure 3 illustrates an unranked tree-shaped
record corresponding to a patient in a database on the top,
and on the bottom its binary representation as a member of
a list. As Figure 3 shows, the FCNS encoding maps the ﬁrst
child of a node in an unranked tree to its ﬁrst child, and its
sibling to the right to its second child. The set of binary
trees over the alphabet Σ2 of symbols for binary nodes and
Σ0 for nullary nodes is denoted by TΣ2,Σ0 . Binary nodes la-
beled with the elements of Σ2 model XML tags, while nullary
nodes labeled with the elements of Σ0 model textual enti-
ties of XML documents. Therefore, we identify the latter by
putting their values between ’ characters. One can think of
the labels of nullary nodes as untyped values represented as
strings. The extra label # ∈ Σ0 denotes the empty forest.

215(tree expressions)

e

(Boolean expressions)

b

::= # | x | x/1 | x/2 |

σ2(x, y) |
λt(x1, x2, ...)
::= top(x)=σ |

λb(x1, x2, ...)

(5)

Otherwise, if x is a leaf, they result in the error state (cid:32) .

In (5), the expression language of the programming lan-
guage of (3) is deﬁned. Tree expressions e evaluate to new
tree-shaped values based on already existing ones, and Bool-
ean expressions b compute Boolean values. The values of
x/1 and x/2 are the ﬁrst and second subtrees of the value
stored in x, respectively, given that the root of x is binary.
The result of σ2(x,y) is a tree having root labeled σ2 ∈ Σ2
with the content of x as its ﬁrst and the content of y as
its second child. In order to allow for arbitrary computa-
tions, we have introduced the interpreted functions λt and
λb returning textual (otherwise called basic) and Boolean
values respectively.
In the following examples we will use
inﬁx operators like less or equal to =< or equivalence = as
instances for interpreted function symbols with the intuitive
semantics.

s(x) has root labeled with σ
s(x) has root labeled with σ(cid:48) (cid:54)= σ

(cid:74)top(x)=σ(cid:75)s = s if σ ∈ Σ2 ∪ {#} and
(cid:74)¬top(x)=σ(cid:75)s = s if σ ∈ Σ2 ∪ {#} and
(cid:74)λb(x1,x2,...)(cid:75)s = s if(cid:74)λb(cid:75)(s(x1), s(x2), ...) holds
(cid:74)x:=y(cid:75)s = s[x (cid:55)→ s(y)]
(cid:74)x:=#(cid:75)s = s[x (cid:55)→ #]
s[x (cid:55)→ t1]
(cid:74)x:=σ2(x1,x2)(cid:75)s = s[x (cid:55)→ σ2(s(x1), s(x2))]
s[x (cid:55)→ t2]
(cid:32)
(cid:32)
(cid:74)f(cid:75)(cid:32) =(cid:32) for all edges f

(cid:74)x:=y/1(cid:75)s =
(cid:74)x:=y/2(cid:75)s =
(cid:74)x:=λt(x1,x2,...)(cid:75)s = s[x (cid:55)→(cid:74)λt(cid:75)(s(x1), s(x2), ...)] or(cid:32)

if s(y) = σ2(t1,t2) for some
label σ2, and trees t1 and t2
otherwise
if s(y) = σ2(t1,t2) for some
label σ2, and trees t1 and t2
otherwise

Figure 4: State transformers of edges

The semantics of a program is given by means of the cor-
responding CFG according to Section 2. Here, a program

state s is a mapping (Var → TΣ2,Σ0 ) ∪ {(cid:32)} from the set
of variables to binary trees, or the error state(cid:32). The state
and s(x) = v. In particular, we deﬁne(cid:74)f(cid:75)(cid:32) =(cid:32) for all edges.

transformers of edges are deﬁned in Figure 4, where s[x (cid:55)→ v]
denotes a state with each variable y (cid:54)= x having value s(y),

4.2 Proving Noninterference Using Relational

Abstract Interpretation

By the speciﬁcation of information ﬂow policies [15] we
distinguish between two secrecy levels, namely public or low
(L) and secret or high (H). The meaning is that the prin-
cipals not entitled to learn information classiﬁed H, should
not be able to make inferences on them based on observing
data classiﬁed L. We are only concerned with termination
insensitive noninterference, i.e., we neglect the amount of

secret that can be learned by observing the non-termination
of executions. A program is deemed secure only if for all
pairs of states s0 and t0 the following holds. If the public
parts of s0 and t0 are equal, i.e., s0|L = t0|L, then for all
pairs of executions starting at the initial node of the CFG
of the program in states s0 and t0, and reaching the ﬁnal
node in states s and t, respectively, the public parts of the
two resulting states are equal as well, i.e., s|L = t|L.
In order to verify an information ﬂow policy, our analysis
maintains abstract states d : Var → P(TΣ2,{#,bv ,(cid:63)}), which
are mappings from variables to sets of trees possibly con-
taining occurrences of dedicated leaves bv and (cid:63). A pair of
states (s, t) is in the concretization2 (s, t) ∈ γ(d) of d, if for
all variables x, (s(x), t(x)) ∈ γ(d(x)) holds. A pair of trees
τ1, τ2 is in the concretization of a set Λ of abstract trees, if Λ
contains a tree τ such that both τ1 and τ2 can be obtained
from τ by replacing the occurrences of bv with identical basic
values, and the occurrences of (cid:63) with any, possibly diﬀerent
subtrees. Consider, e.g., the language Λ = {a((cid:63),bv), b(bv ,(cid:63)
)}. Then (τ1, τ2) ∈ γ(Λ) for τ1 = a(’Top secret!’,’42’),
and τ2 = a(’Top secret, too!’, ’42’). Accordingly, if
(τ1, τ2) ∈ γ(Λ), then the elements of Λ can be considered
as potential public views of the trees τ1 and τ2, where the
occurrences of (cid:63) identify the positions of secrets. A pub-
lic view is a piece of relational information on two trees in
the sense that it determines their common upper part and
the locations of potential secrets. Therefore, an information
ﬂow policy that can be veriﬁed by our method needs to be
given in the form of a set of public views for each variable
in the initial abstract value of the analysis. Abstract values
do not record precise information on basic values. Leaves
labeled bv only mark the positions of basic values having
secrecy level L.

In order to deal with program errors as well, we extend
this basic approach by recording in the abstract state for a
program point not only public views of variables, but ad-

ditionally provide Boolean values B(cid:32) and B(cid:63). If B(cid:32) holds,
then ((cid:32),(cid:32)) can also be a member of the concretization. If
concrete states may be(cid:32) meaning that the occurrence of an

B(cid:63) holds, then either of the two components of a pair of

error may depend on the secret.

Given an initial abstract value d0 describing the set of
public views of pairs of potential initial states, we are in-
terested in computing the sets of potential public views for
every pair of jointly reachable program points. In our anal-
ysis, sets of public views for variables x occurring at a node
n are described by means of unary predicates varx,n, which
are deﬁned by means of Horn clauses. Formally, τ ∈ d(x)
at node n if varx,n(τ ) holds. The values of B(cid:32) and B(cid:63) at

node n are represented by means of the nullary predicates
public_errorn and secret_errorn respectively.

There are two kinds of Horn clauses. A ﬁrst group is used
for specifying the information ﬂow policy in terms of a set
of initial public views for each variable at the initial node
nin . A second group describes how the views at diﬀerent
program points are related to each other. These clauses are
obtained from the self-composition of the CFG.

For our analysis, we assume that information ﬂow policies
are deﬁned by regular sets of public views, and thus can be
described by ﬁnite tree automata. We will not deﬁne ﬁnite

2 We overload the notation γ by applying it to the con-
cretization of abstract states as well as to the concretization
of abstract sets of trees.

216tree automata here, but note that their languages can be
deﬁned by means of clauses of the form:

p(σ0). or p(σ2(X1,X2)) ⇐ p1(X1),p2(X2).

Above, p, p1 and p2 are unary predicates corresponding to
the states of the automaton, and σ0 and σ2 are nullary and
binary constructors respectively.

qPlist(patientRecord)

qId(id)

qPlist(patientRecord)

qBV(bv )

qName(name)

...

qPlist(#)

qBV(bv )

qHealth(health)

qStar((cid:63)) qEmpty(#)

Figure 5: A run of the automaton speciﬁed in (6)
accepting the public view of a list of records like that
on the bottom of Figure 3 with state qPlist

In our running example, the health status of patients in
the list of records seen in Figure 3 is conﬁdential. Thus, the
information ﬂow policy, the set of public views of all possible
databases is given by the predicate qPlist deﬁned by the
implications in (6):
qPlist(patientRecord(L,R)) ⇐ qId(L),qPlist(R).

qPlist(#).

qId(id(L,R)) ⇐ qBV(L),qName(R).

qName(name(L,R)) ⇐ qBV(L),qHealth(R).
qHealth(health(L,R)) ⇐ qStar(L),qEmpty(R).

(6)

qBV(bv ). qStar( (cid:63) ). qEmpty(#).

As Figure 5 illustrates, a list accepted by the predicate
qPlist is either a tree with root labeled patientRecord hav-
ing a ﬁrst child accepted by qId and a second child accepted
by qPlist, or it is a nullary node with label #. The other
predicates can be understood similarly.
In particular, the
predicate qHealth accepts only trees, the ﬁrst child of which
is a leaf labeled (cid:63) specifying that the corresponding value is
conﬁdential. Supposing that the variable pList contains the
database in the initial state of our program, the correspond-
ing information for the initial node nin and for this variable
is deﬁned by: varpList,nin (X) ⇐ qPlist(X).
formers(cid:74)f, g(cid:75)(cid:93) of edges (n, (f, g), n(cid:48)) are formalized by means

In the following, we describe how the abstract state trans-

of Horn clauses. In order to do so we need that the set of
binary elements Σ2 potentially occurring in the program is
ﬁnite and a priori known. This information can be extracted,
e.g., from the interface descriptions of web services. Recall
that due to our alignment procedure edges either refer to
assignments or to Boolean expressions, but never to both.
4.2.1 Assignments as Horn Clauses
First, we discuss the case of assignments, i.e., transformers
If no
error occurs, then x and y are updated, the values of other
variables remain unchanged. Error propagation is discussed
later in Section 4.2.3. Accordingly, for all variables z (cid:54)= x
and z (cid:54)= y the following clauses are deﬁned, which propagate
their values unmodiﬁed:

of the form (cid:74)x:=e1(x1, . . . , xn), y:=e2(y1, . . . , ym)(cid:75)(cid:93).

varz,n(cid:48) (X) ⇐ varz,n(X).

Values of variables on the left hand sides of the assignments
are deﬁned by the following clauses.

• For edges with label (x:=#, x:=#) we have varx,n(cid:48) (#)
⇐ vary,n(_) for all variables y occurring in the pro-
gram, where ’_’ denotes an anonymous logic variable.
The implication is required to ensure that # is added
to the predicate varx,n(cid:48) only if n may be reachable.
We consider a node n as unreachable, if there is no
variable x and tree τ so that varx,n(τ ) holds.

• For edges with (x:=y, x:=y) we have: varx,n(cid:48) (X) ⇐

vary,n(X).

• For edges with (x:=σ2(y,z), x:=σ2(y,z)) we have:

varx,n(cid:48) (σ2(L,R)) ⇐ vary,n(L),varz,n(R).

• For edges with (x:=y/1, x:=y/1) we have varx,n(cid:48) (L)
⇐ vary,n(σ2(L,_)) for all σ2 ∈ Σ2. As an example,
let us suppose that the abstract value of variable pList
at node n is a model of the predicate qPlist accord-
ing to implications in (6). Using the command id :=
pList/1 we can assign the head of the list into vari-
able id. The implication deﬁning the abstract value
of variable id after the assignment is varid,n(cid:48) (L) ⇐
varpList,n(patientRecord(L,_)). However, during the
analysis the label of the root of the tree in a variable
needs to be treated as unknown. Therefore, the im-
plication is repeated for all possible binary alphabet
elements σ2 ∈ Σ2.
An error is caused by an expression of the form x/1,
if the content of x does not have children, i.e., it is a
leaf. Therefore, in addition the following is deﬁned:

public_errorn(cid:48) ⇐ vary,n(#).
public_errorn(cid:48) ⇐ vary,n(bv ).
secret_errorn(cid:48) ⇐ vary,n( (cid:63) ).

(7)

• For edges with (x:=y/2, x:=y/2) we have varx,n(cid:48) (R) ⇐
vary,n(σ2(_,R)) for all σ2 ∈ Σ2. The implications
handling errors are identical to those in (7).

• By edges with (f, f ) where f = x:=λt(x1, . . . ,xk), it
needs to be examined whether the arguments of the
function λt contain secret. The implications below are
used for the purpose, where the second and third lines
are deﬁned for all σ2 ∈ Σ2:

secret( (cid:63) ).

secret(σ2(L,_)) ⇐ secret(L).
secret(σ2(_,R)) ⇐ secret(R).
Concerning the resulting value of x we have:
varx,n(cid:48) (bv ) ⇐ varx1,n(_),varx2,n(_),
varx,n(cid:48) ( (cid:63) ) ⇐ varxi,n(X),secret(X),

. . . ,varxk,n(_).

varx1,n(_), . . . ,
varxk,n(_).

(8)

(9)

According to implication (8), the value of x at node n(cid:48)
will potentially be bv if all of the arguments x1, ..., xk of
λt are deﬁned. Furthermore, according to implication
(9), if any of the input variables depends on the secret,
then the resulting abstract value will also contain (cid:63).
There is an implication of the form (9) deﬁned for all
arguments xi of λt.

217• By edges of the form (x:=e(x1, . . . , xk), skip) and

(skip, x:=e(x1, . . . , xk)) we have:

varx,n(cid:48) ( (cid:63) ) ⇐ varx1,n(_), . . . ,varxk,n(_).

If the eﬀect of an edge consists of an assignment and a
skip command, then in the resulting abstract state
the value of the variable on the left hand side be-
comes (cid:63) indicating that its value might be diﬀerent
in the corresponding two concrete states. This hap-
pens independently of the values of arguments of ex-
pressions on the right hand side.
If the expression
is of the form x/1 or x/2, then we have in addition
secret_errorn(cid:48) ⇐ varx,n(_) in order to indicate that
an error may occur only in one member of the pair of
corresponding concrete states.

4.2.2 Boolean Expressions as Horn Clauses
Now we discuss abstract transformers with Boolean ex-
pressions.
In our implementation we treat two branching
constructs composable only if their conditional expressions
are syntactically equivalent in addition to the conditions dis-
cussed in Section 3.

• By edges labeled (b, b), (b, skip) or (skip, b), where
b = λb(x1, x2, . . . , xk), the values of all variables y
occurring in the program are propagated the following
way:
vary,n(cid:48) (X) ⇐ vary,n(X),varx1,n(_), . . . ,varxk,n(_).
In other words, it is checked whether the input vari-
ables of the conditional expression have been deﬁned,
in order to ensure that the node n is reachable. The
actual values of variables are propagated without mod-
iﬁcation.

• In case the label of the root of a tree is tested using an
edge having label of the form (top(x)=σ, top(x)=σ),
then the following clauses are deﬁned to propagate the
values of variables y (cid:54)= x if σ ∈ Σ2:
vary,n(cid:48) (X) ⇐ vary,n(X),
vary,n(cid:48) (X) ⇐ vary,n(X),varx,n( (cid:63) ).

varx,n(σ(_,_)).

(10)

The value of the variable x is propagated as well:

varx,n(cid:48) (σ(L,R)) ⇐ varx,n(σ(L,R)).
varx,n(cid:48) (σ( (cid:63) , (cid:63) )) ⇐ varx,n( (cid:63) ).

(11)

(12)

If σ = # then σ(X,Y ) is exchanged with # (10), (11)
and (12).

• For edges with (top(x)=σ, skip) or (skip, top(x)=σ)
(10) and (11) need to be repeated, and in addition
varx,n(cid:48) ( (cid:63) ) ⇐ varx,n( (cid:63) ) deﬁned.

• By edges with (¬top(x)=σ,¬top(x)=σ), (¬top(x)=σ,
skip) or (skip,¬top(x)=σ), the values of the variables
are propagated only in the case, when the root of the
value of x is labeled with some δ (cid:54)= σ. Therefore, the
following implication is deﬁned for all variables y other
than x and for all alphabet elements δ ∈ Σ2 \ {σ}:

vary,n(cid:48) (X) ⇐ vary,n(X),varx,n(δ(_,_)).

(13)

In order to handle the value of x as well, the following
implication is deﬁned for all δ ∈ Σ2 \ {σ}:
varx,n(cid:48) (δ(L,R)) ⇐ varx,n(δ(L,R)).

(14)

Additionally, we need to deﬁne (13) and (14) so that
δ(X,Y ) is replaced by (cid:63), and if σ (cid:54)= # then by # too.
• In case the two components of the label of an edge are
the negations of each other, e.g., (¬b(x1, x2, ..., xk),
b(x1, x2, ..., xk)), then the values of variables need to
be propagated only in the case, when at least one
of the variables in the argument depends on the se-
cret. Assuming that b is a function, the simultaneous
execution of the two steps cannot take place other-
wise. Accordingly, the following is deﬁned for all vari-
ables y occurring in the program and for all variables
xi ∈ {x1, ..., xk}:

vary,n(cid:48) (X) ⇐ vary,n(X),varxi,n(Xi),

secret(Xi).

(15)

4.2.3 Propagating the Error
Finally, in order to propagate the error state, for all edges

we deﬁne:

public_errorn(cid:48) ⇐ public_errorn.
secret_errorn(cid:48) ⇐ secret_errorn.

4.2.4 Discussion

(f, g) as deﬁned by Horn clauses is a correct abstract trans-
former, i.e., it satisﬁes the conditions of (1). In other words,

Theorem 4. The abstract transformer (cid:74)f, g(cid:75)(cid:93) for a pair
if (cid:74)f(cid:75)(s0) = s and (cid:74)g(cid:75)t0 = t where (s0, t0) ∈ γ(d0) and
(cid:74)f, g(cid:75)(cid:93)d0 = d, then (s, t) ∈ γ(d) holds.

Proof. The statement follows by a comparison of the
concrete transformers in Section 4.1 and the implications
deﬁned for pairs of labels of edges.

Because of Theorem 4, the least solution of the set of
Horn clauses deﬁned for a program over-approximates the
MTC solution. Therefore, for example, noninterference for
a particular output variable x holds at program exit nﬁ , if
the predicate varx,nﬁ does not accept trees containing (cid:63).

Algorithmically, therefore, the analysis boils down to com-
puting (or approximating) the model of the set of Horn
clauses deﬁned for the program. The head of each clause
possibly generated by our analysis is of one of the forms

h ::= p | p(X) | p(σ0) | p(σ2(X1,X2)),

where X1, X2 are distinct. Therefore, all of them belong to
the class of Horn clauses H1 [31, 37]. Finite sets of clauses
of this class are known to have least models consisting of
regular sets. Moreover, ﬁnite automata characterizing these
regular sets can be eﬀectively computed.
4.3 Case Study

Let us come back to our running example, the routine
manipulating the hospital database, which processes the list
of records of patients. An implementation of the BPEL code
of Listing 1 in our tree-manipulating core language is given
by Listing 2:

218Listing 2: A routine updating the health status of
patients based on blood tests. Subroutines are syn-
tactic sugar, and they are inlined before analysis
or execution. Some analysis results are displayed
in comments, where nodes of the self-composition
of the corresponding CFG are identiﬁed by pairs of
numbers of lines in the code.
s u b r o u t i n e query {

found := ’ff ’;
while found = ’ff ’ {

// var found,(3,3) (bv ).

id := pList /1; // var id,(5,5) ( X ) ⇐ qId ( X ).
idVal := id /1; // var idVal,(6,6) ( X ) ⇐ qBV ( X ).
found := ’tt ’ // var found,(8,8) ( X ) ⇐ qBV ( X ).
name := id /2; // var name,(9,9) ( X ) ⇐ qName ( X ).

if idVal = p a t i e n t I d {

nameVal := name /1;

pList := pList /2;

// var nameVal,(11,11) ( X ) ⇐ qBV ( X ).
// var pList,(3,3) ( X ) ⇐ qPlist ( X ).

} else {

p L i s t R e v := p a t i e n t R e c o r d ( id , p L i s t R e v );

// var pListRev,(16,16) ( X ) ⇐ qPlist ( X ).
// var pList,(3,3) ( X ) ⇐ qPlist ( X ).

pList := pList /2;

5

10

15

}}}
s u b r o u t i n e restore {

20 health := health ( healthVal , empty );

name := name ( nameVal , health );

id := id ( idVal , name );

// var name,(23,23) ( X ) ⇐ qName ( X ).
// var id,(25,25) ( X ) ⇐ qId ( X ).
// var pList,(27,27) ( X ) ⇐ qPlist ( X ).

25 pList := p a t i e n t R e c o r d ( id , pList );

while top ( p L i s t R e v ) = p a t i e n t R e c o r d {

id := p L i s t R e v /1;

// var id,(30,30) ( X ) ⇐ qId ( X ).

30

pList := p a t i e n t R e c o r d ( id , pList );
p L i s t R e v := p L i s t R e v /2;

// var pListRev,(27,27) ( X ) ⇐ qPlist ( X ).

}}
// Entry point:

35 empty := #;

p L i s t R e v := empty ;
if test = < ’0.5 ’ {

// var empty,(36,36) (#).
// var pListRev,(37,37) (#).

call query ;
h e a l t h V a l

:= ’ good ’; // var healthVal,(40,44) ((cid:63)).

40 call restore ;

} else {

call query ;
h e a l t h V a l
call restore ;

:= ’ poor ’; // var healthVal,(40,44) ((cid:63)).

45 }

Subroutines, which are not part of the core language, can be
considered as abbreviations. Their deﬁnitions are meant to
be inlined at their call sites before execution or analysis. In
the initial state the variable pList contains the database, a
list of records in the form of a binary tree as illustrated in
Figure 3. The result of the blood test is in variable test and
the patient’s identiﬁer to whom the test belongs is provided
in patientId. The updated list is again stored in the vari-
able pList at the end of the execution. The entry point of
the program is at line 35. At line 37, a branch is selected
based on the blood test. In both branches, the record of the
patient is searched for in the database, and the correspond-
ing health status is updated. Finally, the list representing
the database is restored. The database is queried in a loop

running as long as the record for the patient with identiﬁer
patientId is not found. If the actual record at the head of
the list in variable pList is not the one we are looking for,
then it is appended to the list in pListRev, which stores a
preﬁx of the list of pList in reverse order. On the other
hand, if the head of pList is the record we seek, then the
name of the patient is stored in the variable nameVal. The
restoration of the database succeeds in two steps. First, be-
ginning with line 20 the binary tree representing the record
of the actual patient is reconstructed, and appended to the
database in pList at line 25. In the second step, the records
stored in pListRev are appended to pList using the loop at
line 27.

In the self-composition of the CFG corresponding to the
program at Listing 2 after subroutines have been inlined, the
query and restore routines of the two branches of the if
construct at line 37 are aligned with each other. Therefore,
the self-composition simulates the simultaneous query and
database restoration in both branches. Listing 2 illustrates
the result of the analysis on selected places with predicates of
the form varx,(l1,l2) in comments, where x is the variable the
value of which the predicate describes, and (l1, l2) identiﬁes
a node in the self-composition corresponding to the pair of
nodes l1 and l2 of the original CFG of the program. For the
sake of clarity, the identiﬁers of the initial nodes of subgraphs
(e.g., those in Figure 1) corresponding to commands coincide
with the line numbers of the commands in the program text.

The initial values of variables are given by:
varpList,(35,35)(X) ⇐ qPlist(X).

vartest,(35,35)( (cid:63) ).

varpatientId,(35,35)(bv ).

(16)

Accordingly, after executing the instruction at line 4, the
content of the variable id will be overapproximated by the
set accepted by the predicate qId. The reason is that the
ﬁrst child of a tree accepted by predicate qPlist is accepted
by predicate qId according to the implications in (6). The
sets abstracting the values of variables at any pair of pro-
gram points can be established with a similar reasoning. In
particular, the abstract value of variable healthVal at the
node corresponding to lines 40 and 44 is (cid:63), indicating that
it carries conﬁdential information.

The result of the analysis reveals that the ﬁnal abstract
value of the variable pList equals to the initial one deﬁned
by the predicate qPlist in (16). In other words, the secret
remains in the variable test and in the health status of the
records in the list, but does not interfere with other values.

5. PRACTICAL EXPERIMENTS

We have implemented a prototype to carry out the analy-
sis described in this paper. We have implemented the func-
tion pp2cfg(p1, p2, nin , nﬁ ) in OCaml, where the Robust Tree
Edit Distance algorithm [32] is used to compute the distance
between the ASTs of commands. The set of Horn clauses
generated from the self-compositions of CFGs is solved using
the H1 solver of [31]. We have carried out the analysis on
four examples. a) Blood Test. This program is our exam-
ple described in Section 4. b) Joining Tables. This pro-
gram implements the join of two tables as published in [16]
and in [5]. c) Bayes Classiﬁer. This program is an imple-
mentation of the second example in [16], which demonstrates
how to prove the noninterference of a data-mining algorithm,
the Naive Bayes classiﬁer. d) Medical Records. This ex-

219Experiment
Joining Tables
Blood Test
Medical Records
Bayes Classiﬁer

# of lines
26
86
97
133

|G|
45
136
163
241

|GG| # of implications
3510
237
1102
23971
22532
859
1561
89720

running time
2.791 sec
11.152 sec
11.794 sec
44.470 sec

peak memory usage
19.17 MiB
26.71 MiB
21.82 MiB
89.85 MiB

Table 1: Summary of the runtime behavior of the analysis

ample implements the benchmark of [2], with four diﬀerent
operations on patient data.

For all four examples, our algorithm succeeded to infer
noninterference automatically. Table 1 summarizes some
quantitative details of our experiments. The experiments
have been carried out in a 32 bit virtual machine on a lap-
top having a 2 GHz Intel R(cid:13) CoreTM i7 processor. To each
experiment we list the following information: a) Number of
lines of the code without comment and empty lines. b) Size
of the CFG |G| as the sum of the number of nodes and
number of edges. c) Size of the self-composition of the CFG
|GG|. d) Number of implications generated. e) The com-
plete running time of the analysis including the construction
of the self-composition of the CFG, and the computation of
models of predicates.
f) The peak memory consumption
during the veriﬁcation process involving the computation of
the self-composition of the CFG and models of predicates.
For all examples, the self-composition increases the size of
the CFG by a factor signiﬁcantly less then 10. The number
of Horn clauses, on the other hand, does not only depend on
the size of the corresponding self-composed graph, but ad-
ditionally also on the number of variables to be tracked. As
expected, the running times typically grow with the number
of generated clauses.

6. RELATED WORK

This paper relies on the observation [7, 10, 14] that the
veriﬁcation of k-hypersafety properties of programs can be
reduced to the veriﬁcation of safety properties on the k-fold
self-compositions of the programs.

Several authors have used self-compositions of programs
for the analysis of hyperproperties, i.e., [7,14,30,35]. In [35] a
type-system based transformation is presented to construct
the self-composition. The self-composition of branching con-
structs results in one branching construct with the same
condition expression.
In [30] the same idea is applied for
object-oriented languages. Diﬀerently from our approach,
these solutions cannot take advantage of similarities in the
code of diﬀerent branches. Their motivation is to apply al-
ready existing techniques of proving safety properties for the
purpose of proving hypersafety properties.

Barthe et al. [5] oﬀer a variety of possibly conditional
rewritings of the original program to achieve appropriate
alignments. Such conditions may enforce, e.g., that two
loops are iterated equally often. These conditions later must
be discarded by the theorem prover or remain and then re-
strict the admissible input values. Furthermore, no algo-
rithm or heuristics is provided how these rules should be
applied. In our solution no extra conditions are imposed. In-
stead, skip instructions are inserted where needed. In case
the conditions of two diﬀerent loops are equal, we are still
able to infer equal numbers of iterations and thus achieve a
perfect alignment. In [6] notions of compositions of CFGs
similar to ours are applied for proving relational properties

of potentially dissimilar programs with the help of theorem
provers. However, no algorithm is provided for the construc-
tion of the self-compositions. Furthermore, similarly to [6],
our approach can also to deal with dissimilar programs, this
capability is taken advantage of when diﬀerent branches of
a branching construct are analyzed.

While our method is based on self-compositions of control
ﬂow graphs, other people apply type systems for the veriﬁ-
cation of noninterference properties, e.g., [9, 27, 28, 36]. An
other alternative is to use program dependency graphs [20].
Generally, though, the above solutions consider the program
counter to have a security level implying that all data pos-
sibly manipulated in secret-dependent branches are secret.
Accordingly, they would have diﬃculties with our running
example, the data-base of patients.

In [18] a non-relational abstract interpretation has been
presented, where the security of programs is investigated
depending on the observational capabilities of attackers. If
the public input values are handled as constants in the initial
state, then no information leaks to public variables in the
ﬁnal state, if the property that the attackers can observe can
be proved to be constant. A similar idea is applied in the
runtime information ﬂow monitor described in [24], where
constant propagation is used to compute public values for
the ﬁnal states of branching constructs. A diﬀerent way of
applying abstract interpretation for proving the information
ﬂow security of programs is presented in [39] and in [4],
where the security labels [15] are treated as abstractions
of values, and a consistent labeling is computed according
to the abstract semantics. The approaches of [4, 15, 18, 24,
39] do not consider self-compositions of the programs, and
therefore cannot take advantage of similarities in diﬀerent
branches of branching constructs.

Abstract interpretation of tree-manipulating programs is
described, e.g., in [25], where Møller et al. summarize their
experiences using XML Graphs as an abstract domain. Our
analysis is similar to that, in the sense that the trees gen-
erated by the grammars or automata correspond to public
views. Each public view, though, represents a relational
piece of information, namely, the common part of two tree-
structured values.

There are also papers focusing on proving hyperproperties
of programs manipulating complex data structures. In [24,
33] runtime monitors have been introduced for the enforce-
ment of information ﬂow properties on programs manipu-
lating tree-structured data. In [5, 6, 29] the authors present
potentially interactive approaches using theorem provers,
which are also capable of dealing with our examples.
In
contrast to these techniques, our static analysis based on
abstract interpretation is fully automatic.

Since XML is a standard format for hierarchically orga-
nizing and communicating data, security here is a major
concern. Several authors therefore, have investigated how
to enforce access control policies on XML documents by

220computing “user views”, i.e., fragments of the documents
accessible for certain users [1, 13, 17, 26]. These approaches
however, do not consider self-compositions. Still, it remains
for future work to clarify the precise relationship between
our methods for verifying noninterference and such enforce-
ment of access control.

7. CONCLUSION AND FUTURE WORK

We have presented a general approach for analyzing 2-
hypersafety properties using relational abstract interpreta-
tion on self-compositions of control ﬂow graphs. Properties
like that naturally occur in information ﬂow security analy-
ses. Our approach is based on appropriate self-compositions
of control ﬂow graphs. Here, we presented an algorithm to
construct quality self-compositions, which is completely de-
terministic and well tailored for the application of relational
abstract interpretation. In particular, our solution uses the
Robust Tree Edit Distance [32] measure in order to align
similar program fragments with each other. We have ap-
plied the approach to analyze information ﬂow properties of
programs manipulating semi-structured data.

As the general idea of self-compositions of CFGs is inde-
pendent of the programming language and semantics, our
framework can be applied to other programming languages
as well. Our results open many directions for further re-
search, e.g.: a) In our analysis, diﬀerent program variables
are treated separately. Extra precision, perhaps may be ob-
tained by using predicates that relate the contents of diﬀer-
ent variables in states. The resulting clauses then may no
longer be members of the class H1. Still, one may apply a
Horn clause based approach, but use a ﬁrst order theorem
prover such as, e.g., SPASS [38] as a back-end, instead of an
H1 solver. b) The language we have considered in this paper
does not support procedure calls. It still remains an open
question how the Horn clause formulation of the analysis
can be optimally extended also to recursive procedures.

Acknowledgments
This work was partially supported by the German Research
Foundation (DFG) under the project SpAGAT in the prior-
ity program 1496 “Reliably Secure Software Systems – RS3”.

8. REFERENCES
[1] R. Abassi, F. Jacquemard, M. Rusinowitch, and S. G.

El Fatmi. XML access control: from XACML to
annotated schemas. In Second International
Conference on Communications and Networking
(ComNet), pages 1–8, Tozeur, Tunisie, 2010. IEEE
Computer Society Press.

[2] R. Accorsi and A. Lehmann. Automatic information

ﬂow analysis of business process models. In A. P.
Barros, A. Gal, and E. Kindler, editors, Business
Process Management - 10th International Conference,
BPM 2012, volume 7481 of Lecture Notes in Computer
Science, pages 172–187. Springer, 2012.

[3] A. Alves, A. Arkin, S. Askary, C. Barreto, B. Bloch,

F. Curbera, M. Ford, Y. Goland, A. Gu´ızar,
N. Kartha, C. K. Liu, R. Khalaf, D. Koenig,
M. Marin, V. Mehta, S. Thatte, D. Rijn, P. Yendluri,
and A. Yiu. Web services business process execution
language version 2.0 (OASIS standard). WS-BPEL

TC OASIS, http://docs.oasis-open.org/wsbpel/2.
0/wsbpel-v2.0.html, 2007.

[4] R. Barbuti, C. Bernardeschi, and N. D. Francesco.

Checking security of Java bytecode by abstract
interpretation. In Proceedings of the 2002 ACM
Symposium on Applied Computing (SAC), pages
229–236. ACM, 2002.

[5] G. Barthe, J. M. Crespo, and C. Kunz. Relational

veriﬁcation using product programs. In M. Butler and
W. Schulte, editors, 17th International Symposium on
Formal Methods (FM 2011), volume 6664 of Lecture
Notes in Computer Science, pages 200–214. Springer,
2011.

[6] G. Barthe, J. M. Crespo, and C. Kunz. Beyond

2-safety: Asymmetric product programs for relational
program veriﬁcation. In S. N. Art¨emov and A. Nerode,
editors, Logical Foundations of Computer Science,
International Symposium, LFCS 2013, volume 7734 of
Lecture Notes in Computer Science, pages 29–43.
Springer, 2013.

[7] G. Barthe, P. R. D’Argenio, and T. Rezk. Secure

information ﬂow by self-composition. In 17th IEEE
Computer Security Foundations Workshop, (CSFW-17
2004), pages 100–114. IEEE Computer Society, 2004.

[8] A. Berglund, S. Boag, D. Chamberlin, M. F.

Fern´andez, M. Kay, J. Robie, and J. Sim´eon. XML
path language (XPath) 2.0 (second edition). World
Wide Web Consortium, Recommendation
REC-xpath20-20101214, 14 December 2010.

[9] N. Broberg and D. Sands. Paralocks: role-based

information ﬂow control and beyond. In M. V.
Hermenegildo and J. Palsberg, editors, Proceedings of
the 37th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL 2010,
pages 431–444. ACM, 2010.

[10] M. R. Clarkson and F. B. Schneider. Hyperproperties.
Journal of Computer Security, 18(6):1157–1210, 2010.

[11] H. Comon, M. Dauchet, R. Gilleron, C. L¨oding,

F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi.
Tree automata techniques and applications. Available
on: http://www.grappa.univ-lille3.fr/tata, 2007.
release October, 12th 2007.

[12] P. Cousot and R. Cousot. Abstract interpretation: A

uniﬁed lattice model for static analysis of programs by
construction or approximation of ﬁxpoints. In R. M.
Graham, M. A. Harrison, and R. Sethi, editors,
Conference Record of the Fourth ACM Symposium on
Principles of Programming Languages (POPL), pages
238–252. ACM, 1977.

[13] E. Damiani, S. D. C. di Vimercati, S. Paraboschi, and

P. Samarati. A ﬁne-grained access control system for
XML documents. ACM Trans. Inf. Syst. Secur.,
5(2):169–202, 2002.

[14] ´A. Darvas, R. H¨ahnle, and D. Sands. A theorem

proving approach to analysis of secure information
ﬂow. In D. Hutter and M. Ullmann, editors, Security
in Pervasive Computing, Second International
Conference, SPC 2005, volume 3450 of Lecture Notes
in Computer Science, pages 193–209. Springer, 2005.
[15] D. E. Denning. A lattice model of secure information

ﬂow. Commun. ACM, 19(5):236–243, 1976.

221[16] G. Dufay, A. P. Felty, and S. Matwin. Privacy-sensitive
information ﬂow with JML. In R. Nieuwenhuis, editor,
CADE-20, 20th International Conference on
Automated Deduction, volume 3632 of Lecture Notes
in Computer Science, pages 116–130. Springer, 2005.
[17] I. Fundulaki and M. Marx. Specifying access control

policies for XML documents with XPath. In T. Jaeger
and E. Ferrari, editors, SACMAT 2004, 9th ACM
Symposium on Access Control Models and
Technologies, pages 61–69. ACM, 2004.

[18] R. Giacobazzi and I. Mastroeni. Abstract

non-interference: parameterizing non-interference by
abstract interpretation. In N. D. Jones and X. Leroy,
editors, Proceedings of the 31st ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, POPL 2004, pages 186–197.
ACM, 2004.

[19] J. A. Goguen and J. Meseguer. Security policies and

[29] A. Nanevski, A. Banerjee, and D. Garg. Veriﬁcation of

information ﬂow and access control policies with
dependent types. In IEEE Symposium on Security and
Privacy, pages 165–179. IEEE Computer Society,
2011.

[30] D. A. Naumann. From coupling relations to mated

invariants for checking information ﬂow. In
D. Gollmann, J. Meier, and A. Sabelfeld, editors,
ESORICS 2006, 11th European Symposium on
Research in Computer Security, volume 4189 of
Lecture Notes in Computer Science, pages 279–296.
Springer, 2006.

[31] F. Nielson, H. R. Nielson, and H. Seidl. Normalizable
Horn clauses, strongly recognizable relations, and Spi.
In M. V. Hermenegildo and G. Puebla, editors, Static
Analysis, 9th International Symposium, SAS 2002,
volume 2477 of Lecture Notes in Computer Science,
pages 20–35. Springer, 2002.

security models. In IEEE Symposium on Security and
Privacy, pages 11–20, 1982.

[32] M. Pawlik and N. Augsten. RTED: A robust algorithm
for the tree edit distance. PVLDB, 5(4):334–345, 2011.

[20] C. Hammer and G. Snelting. Flow-sensitive,

[33] A. Russo, A. Sabelfeld, and A. Chudnov. Tracking

context-sensitive, and object-sensitive information ﬂow
control based on program dependence graphs. Int. J.
Inf. Sec., 8(6):399–422, 2009.

[21] J. B. Kam and J. D. Ullman. Monotone data ﬂow

analysis frameworks. Acta Informatica, 7(3):305–317,
September 1977.

[22] M. Kay. XSL transformations (XSLT) version 2.0.

World Wide Web Consortium, Recommendation
REC-xslt20-20070123, 23 January 2007.

[23] M. Kov´acs. Relational abstract interpretation for the

veriﬁcation of 2-hypersafety properties (proofs).
Technical Report TUM-I1340, Technische Universit¨at
M¨unchen, Institut f¨ur Informatik, Aug. 2013.

[24] M. Kov´acs and H. Seidl. Runtime enforcement of

information ﬂow security in tree manipulating
processes. In G. Barthe, B. Livshits, and
R. Scandariato, editors, Engineering Secure Software
and Systems - 4th International Symposium, ESSoS
2012, volume 7159 of Lecture Notes in Computer
Science, pages 46–59. Springer, 2012.

information ﬂow in dynamic tree structures. In
M. Backes and P. Ning, editors, ESORICS 2009, 14th
European Symposium on Research in Computer
Security, volume 5789 of Lecture Notes in Computer
Science, pages 86–103. Springer, 2009.

[34] K.-C. Tai. The tree-to-tree correction problem.

Journal of the ACM, 26(3):422–433, 1979.

[35] T. Terauchi and A. Aiken. Secure information ﬂow as

a safety problem. In C. Hankin and I. Siveroni,
editors, Static Analysis, 12th International
Symposium, SAS 2005, volume 3672 of Lecture Notes
in Computer Science, pages 352–367. Springer, 2005.
[36] D. M. Volpano, C. E. Irvine, and G. Smith. A sound

type system for secure ﬂow analysis. Journal of
Computer Security, 4(2/3):167–188, 1996.

[37] C. Weidenbach. Towards an automatic analysis of

security protocols in ﬁrst-order logic. In H. Ganzinger,
editor, CADE-16, 16th International Conference on
Automated Deduction, volume 1632 of Lecture Notes
in Computer Science, pages 314–328. Springer, 1999.

[25] A. Møller and M. I. Schwartzbach. XML graphs in

[38] C. Weidenbach, D. Dimova, A. Fietzke, R. Kumar,

program analysis. Sci. Comput. Program.,
76(6):492–515, 2011.

[26] M. Murata, A. Tozawa, M. Kudo, and S. Hada. XML
access control using static analysis. ACM Trans. Inf.
Syst. Secur., 9(3):292–324, 2006.

[27] A. C. Myers. JFlow: Practical mostly-static

information ﬂow control. In A. W. Appel and
A. Aiken, editors, POPL ’99, Proceedings of the 26th
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, pages 228–241. ACM, 1999.
[28] A. C. Myers and B. Liskov. A decentralized model for
information ﬂow control. In SOSP ’97: Proceedings of
the Sixteenth ACM Symposium on Operating Systems
Principles, pages 129–142, New York, NY, USA, 1997.
ACM Press.

M. Suda, and P. Wischnewski. SPASS version 3.5. In
R. A. Schmidt, editor, CADE-22, 22nd International
Conference on Automated Deduction, volume 5663 of
Lecture Notes in Computer Science, pages 140–145.
Springer, 2009.

[39] M. Zanotti. Security typings by abstract

interpretation. In M. V. Hermenegildo and G. Puebla,
editors, Static Analysis, 9th International Symposium,
SAS 2002, volume 2477 of Lecture Notes in Computer
Science, pages 360–375. Springer, 2002.

222