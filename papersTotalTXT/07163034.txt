2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Riposte: An Anonymous Messaging System

Handling Millions of Users

Henry Corrigan-Gibbs, Dan Boneh, and David Mazières

Stanford University

Abstract—This paper presents Riposte, a new system for
anonymous broadcast messaging. Riposte is the ﬁrst such system,
to our knowledge, that simultaneously protects against trafﬁc-
analysis attacks, prevents anonymous denial-of-service by mali-
cious clients, and scales to million-user anonymity sets. To achieve
these properties, Riposte makes novel use of techniques used in
systems for private information retrieval and secure multi-party
computation. For latency-tolerant workloads with many more
readers than writers (e.g. Twitter, Wikileaks), we demonstrate
that a three-server Riposte cluster can build an anonymity set of
2,895,216 users in 32 hours.
Index Terms—anonymity; messaging; privacy; private infor-

mation retrieval;

I. INTRODUCTION

In a world of ubiquitous network surveillance [6], [34], [35],
[39], [62], prospective whistleblowers face a daunting task.
Consider, for example, a government employee who wants to
anonymously leak evidence of waste, fraud, or incompetence
to the public. The whistleblower could email an investigative
reporter directly, but post hoc analysis of email server logs
could easily reveal the tipster’s identity. The whistleblower
could contact a reporter via Tor [27] or another low-latency
anonymizing proxy [31], [53], [59], [71], but this would leave
the leaker vulnerable to trafﬁc-analysis attacks [4], [60], [61].
The whistleblower could instead use an anonymous messaging
system that protects against trafﬁc analysis attacks [14], [38],
[77], but these systems typically only support relatively small
anonymity sets (tens of thousands of users, at most). Protecting
whistleblowers in the digital age requires anonymous messag-
ing systems that provide strong security guarantees, but that
also scale to very large network sizes.

In this paper, we present a new system that attempts to
make trafﬁc-analysis-resistant anonymous broadcast messag-
ing practical at Internet scale. Our system, called Riposte,
allows a large number of clients to anonymously post messages
to a shared “bulletin board,” maintained by a small set of
minimally trusted servers. (As few as three non-colluding
servers are sufﬁcient). Whistleblowers could use Riposte as a
platform for anonymously publishing Tweet- or email-length
messages and could combine it with standard public-key
encryption to build point-to-point private messaging channels.
While there is an extensive literature on anonymity sys-
tems [22], [28], Riposte offers a combination of security and
scalability properties unachievable with current designs. To
the best of our knowledge, Riposte is the only anonymous
messaging system that simultaneously:

1) protects against trafﬁc analysis attacks,

© 2015, Henry Corrigan-Gibbs. Under license to IEEE.
© 2015, Henry Corrigan-Gibbs. Under license to IEEE.
DOI 10.1109/SP.2015.27
DOI 10.1109/SP.2015.27

321
321

2) prevents malicious clients from anonymously executing

denial-of-service attacks, and

3) scales to anonymity set sizes of millions of users, for

certain latency-tolerant applications.

We achieve these three properties in Riposte by adapting three
different techniques from the cryptography and privacy litera-
ture. First, we defeat trafﬁc-analysis attacks and protect against
malicious servers by using a protocol, inspired by client/server
DC-nets [14], [77], in which every participating client sends
a ﬁxed-length secret-shared message to the system’s servers
in every time epoch. Second, we achieve efﬁcient disruption
resistance by using a secure multi-party protocol to quickly
detect and exclude malformed client requests [29], [41], [78].
Third, we achieve scalability by leveraging a speciﬁc technique
developed in the context of private information retrieval (PIR)
to minimize the number of bits each client must upload to
each server in every time epoch. The tool we use is called a
distributed point function [16], [37]. The novel synthesis of
these techniques leads to a system that is efﬁcient (in terms
of bandwidth and computation) and practical, even for large
anonymity sets.

Our particular use of private information retrieval (PIR)
protocols is unusual: PIR systems [17] allow a client
to
efﬁciently read a row from a database, maintained collectively
at a set of servers, without revealing to the servers which row
it is reading. Riposte achieves scalable anonymous messaging
by running a private information retrieval protocol in reverse:
with reverse PIR, a Riposte client can efﬁciently write into a
database maintained at the set of servers without revealing to
the servers which row it has written [67].

As we discuss later on, a large Riposte deployment could
form the basis for an anonymous Twitter service. Users would
“tweet” by using Riposte to anonymously write into a database
containing all clients’ tweets for a particular time period. In
addition, by having read-only users submit “empty” writes to
the system, the effective anonymity set can be much larger
than the number of writers, with little impact on system
performance.

Messaging in Riposte proceeds in regular time epochs (e.g.,
each time epoch could be one hour long). To post a message,
the client generates a write request, cryptographically splits it
into many shares, and sends one share to each of the Riposte
servers. A coalition of servers smaller than a certain threshold
cannot learn anything about the client’s message or write
location given its subset of the shares.

The Riposte servers collect write requests until the end of
the time epoch, at which time they publish the aggregation
of the write requests they received during the epoch. From
this information, anyone can recover the set of posts uploaded
during the epoch, but the system reveals no information about
who posted which message. The identity of the entire set of
clients who posted during the interval is known, but no one
can link a client to a post. (Thus, each time epoch must be
long enough to ensure that a large number of honest clients
are able to participate in each epoch.)

In this paper, we describe two Riposte variants, which
offer slightly different security properties. The ﬁrst variant
scales to very large network sizes (millions of clients) but
requires three servers such that no two of these servers collude.
The second variant is more computationally expensive, but
provides security even when all but one of the s > 1 servers
are malicious. Both variants maintain their security properties
when network links are actively adversarial, when all but two
of the clients are actively malicious, and when the servers are
actively malicious (subject to the non-collusion requirement
above).

The three-server variant uses a computationally inexpensive
multi-party protocol to detect and exclude malformed client
requests. (Figure 1 depicts this protocol at a high-level.) The
s-server variant uses client-produced zero-knowledge proofs
to guarantee the well-formedness of client requests.

Unlike Tor [27] and other low-latency anonymity sys-
tems [38], [48], [53], [71], Riposte protects against active
trafﬁc analysis attacks by a global network adversary. Prior
systems have offered trafﬁc-analysis-resistance only at the cost
of scalability:

• Mix-net-based systems [15] require large zero-knowledge
proofs of correctness to provide privacy in the face of
active attacks by malicious servers [2], [5], [32], [45],
[65].

• DC-nets-based systems require clients to transfer data
linear in the size of the anonymity set [14], [77] and rely
on expensive zero-knowledge proofs to protect against
malicious clients [20], [44].

We discuss these systems and other prior work in Section VII.

Experiments. To demonstrate the practicality of Riposte for
anonymous broadcast messaging (i.e., anonymous whistle-
blowing or microblogging), we implemented and evaluated the
complete three-server variant of the system. When the servers
maintain a database table large enough to ﬁt 65,536 160-byte
Tweets, the system can process 32.8 client write requests per
second. In Section VI-C, we discuss how to use a table of this
size as the basis for very large anonymity sets in read-heavy
applications. When using a larger 377 MB database table (over
2.3 million 160-byte Tweets), a Riposte cluster can process 1.4
client write requests per second.

Writing into a 377 MB table requires each client to upload
less than 1 MB of data to the servers. In contrast, a two-server
DC-net-based system would require each client to upload more
than 750 MB of data. More generally, to process a Riposte

322322

client request for a table of size L, clients and servers perform
only O(

√
L) bytes of data transfer.

The servers’ AES-NI encryption throughput limits the rate
at which Riposte can process client requests at large table
sizes. Thus, the system’s capacity to handle client write request
scales with the number of available CPU cores. A large
Riposte deployment could shard the database table across k
machines to achieve a near-k-fold speedup.

We tested the system with anonymity set sizes of up
to 2,895,216 clients, with a read-heavy latency-tolerant mi-
croblogging workload. To our knowledge, this is the largest
anonymity set ever constructed in a system defending against
trafﬁc analysis attacks. Prior DC-net-based systems scaled to
5,120 clients [77] and prior veriﬁable-shufﬂe-based systems
scaled to 100,000 clients [5]. In contrast, Riposte scales to
millions of clients for certain applications.
Contributions. This paper contributes:

• two new bandwidth-efﬁcient and trafﬁc-analysis-resistant
anonymous messaging protocols, obtained by running
private information retrieval protocols “in reverse” (Sec-
tions III and IV),

• a fast method for excluding malformed client requests

(Section V),

• a method to recover from transmission collisions in DC-

net-style anonymity systems,
of

• experimental

protocols with
anonymity set sizes of up to 2,895,216 users (Section VI).

evaluation

these

In Section II, we introduce our goals, threat model, and
security deﬁnitions. Section III presents the high-level system
architecture. Section IV and Section V detail our techniques
for achieving bandwidth efﬁciency and disruption resistance
in Riposte. We evaluate the performance of the system in
Section VI, survey related work in Section VII, and conclude
in Section VIII.

II. GOALS AND PROBLEM STATEMENT

In this section, we summarize the high-level goals of the
Riposte system and present our threat model and security
deﬁnitions.

A. System Goals

Riposte implements an anonymous bulletin board using a
primitive we call a write-private database scheme. Riposte
enables clients to write into a shared database, collectively
maintained at a small set of servers, without revealing to the
servers the location or contents of the write. Conceptually, the
database table is just a long ﬁxed-length bitstring divided into
ﬁxed-length rows.

To write into the database, a client generates a write request.
The write request encodes the message to be written and the
row index at which the client wants to write. (A single client
write request modiﬁes a single database row at a time.) Using
cryptographic techniques, the client splits its write request into
a number of shares and the client sends one share to each of the
servers. By construction of the shares, no coalition of servers

(a) A client submits one share of
its write request
the
two database servers. If the database
has length L, each share has length
O(

to each of

√

L).

(b) The database servers gener-
ate blinded “audit request” mes-
sages derived from their shares
of the write request.

(c) The audit server uses the
audit request messages to
validate the client’s request
and returns an “OK” or “In-
valid” bit
to the database
servers.

(d) The servers apply the write
request to their local database
state. The XOR of the servers’
states contains the clients mes-
sage at the given row.

Fig. 1: The process of handling a single client write request. The servers run this process once per client in each time epoch.

smaller than a particular pre-speciﬁed threshold can learn the
contents of a single client’s write request. While the cluster of
servers must remain online for the duration of a protocol run,
a client need only stay online for long enough to upload its
write request to the servers. As soon as the servers receive a
write request, they can apply it to to their local state.

The Riposte cluster divides time into a series of epochs.
During each time epoch, servers collect many write requests
from clients. When the servers agree that the epoch has ended,
they combine their shares of the database to reveal the clients’
plaintext messages. A particular client’s anonymity set consists
of all of the honest clients who submitted write requests to the
servers during the time epoch. Thus, if 50,000 distinct honest
clients submitted write requests during a particular time epoch,
each honest client is perfectly anonymous amongst this set of
50,000 clients.

The epoch could be measured in time (e.g., 4 hours), in
a number of write requests (e.g., accumulate 10,000 write
requests before ending the epoch), or by some more com-
plicated condition (e.g., wait for a write request signed from
each of these 150 users identiﬁed by a pre-deﬁned list of public
keys). The deﬁnition of what constitutes an epoch is crucial
for security, since a client’s anonymity set is only as large as
the number of honest clients who submit write requests in the
same epoch [73].

When using Riposte as a platform for anonymous mi-
croblogging, the rows would be long enough to ﬁt a Tweet
(140 bytes) and the number of rows would be some multiple
of the number of anticipated users. To anonymously Tweet, a
client would use the write-private database scheme to write its
message into a random row of the database. After many clients
have written to the database, the servers can reveal the clients’
plaintext Tweets. The write-privacy of the database scheme
prevents eavesdroppers, malicious clients, and coalitions of
malicious servers (smaller than a particular threshold) from
learning which client posted which message.

B. Threat Model

Clients in our system are completely untrusted: they may
submit maliciously formed write requests to the system and
may collude with servers or with arbitrarily many other clients
to try to break the security properties of the system.

Servers in our system are trusted for availability. The
failure—whether malicious or benign—of any one server ren-
ders the database state unrecoverable but does not compromise
the anonymity of the clients. To protect against benign failures,
server maintainers could implement a single “logical” Riposte
server with a cluster of many physical servers running a
standard state-machine-replication protocol [54], [66].

For each of the cryptographic instantiations of Riposte,
there is a threshold parameter t that deﬁnes the number
of malicious servers that the system can tolerate while still
maintaining its security properties. We make no assumptions
about the behavior of malicious servers—they can misbehave
by publishing their secret keys, by colluding with coalitions
of up to t malicious servers and arbitrarily many clients, or
by mounting any other sort of attack against the system.

The threshold t depends on the particular cryptographic
primitives in use. For our most secure scheme, all but one of
the servers can collude without compromising client privacy
(t = |Servers| − 1). For our most efﬁcient scheme, no two
servers can collude (t = 1).

C. Security Goals

The Riposte system implements a write-private and
disruption-resistant database scheme. We describe the correct-
ness and security properties for such a scheme here.
Deﬁnition 1 (Correctness). The scheme is correct if, when all
servers execute the protocol faithfully, the plaintext state of
the database revealed at the end of a protocol run is equal
to the result of applying each valid client write requests to an
empty database (i.e., a database of all zeros).

Since we rely on all servers for availability, correctness need

only hold when all servers run the protocol correctly.

To be useful as an anonymous bulletin board, the database
scheme must be write-private and disruption resistant. We
deﬁne these security properties here.
(s, t)-Write Privacy. Intuitively, the system provides (s, t)-
write-privacy if an adversary’s advantage at guessing which
honest client wrote into a particular row of the database
is negligibly better than random guessing, even when the
adversary controls all but two clients and up to t out of s

323323

servers (where t is a parameter of the scheme). We deﬁne
this property in terms of a privacy game, given in full in
Appendix A.
Deﬁnition 2 ((s, t)-Write Privacy). We say that the protocol
provides (s, t)-write privacy if the adversary’s advantage in
the security game of Appendix A is negligible in the (implicit)
security parameter.

Riposte provides a very robust sort of privacy: the adversary
can select the messages that the honest clients will send and
can send maliciously formed messages that depend on the
honest clients’ messages. Even then, the adversary still cannot
guess which client uploaded which message.
Disruption resistance. The system is disruption resistant if
an adversary who controls n clients can write into at most
n database rows during a single time epoch. A system that
lacks disruption resistance might be susceptible to denial-of-
service attacks: a malicious client could corrupt every row in
the database with a single write request. Even worse, the write
privacy of the system might prevent the servers from learning
which client was the disruptor. Preventing such attacks is a
major focus of prior anonymous messaging schemes [14], [38],
[44], [75], [77]. Under our threat model, we trust all servers
for availability of the system (though not for privacy). Thus,
our deﬁnition of disruption resistance concerns itself only with
clients attempting to disrupt the system—we do not try to
prevent servers from corrupting the database state.

We formally deﬁne disruption resistance using the following
game, played between a challenger and an adversary. In this
game, the challenger plays the role of all of the servers and
the adversary plays the role of all clients.

1) The adversary sends n write requests to the challenger
(where n is less than or equal to the number of rows in
the database).

2) The challenger runs the protocol for a single time epoch,
playing the role of the servers. The challenger then com-
bines the servers’ database shares to reveal the plaintext
output.

The adversary wins the game if the plaintext output contains

more than n non-zero rows.
Deﬁnition 3 (Disruption Resistance). We say that the protocol
is disruption resistant if the probability that the adversary
wins the game above is negligible in the (implicit) security
parameter.

D. Intersection Attacks

Riposte makes it infeasible for an adversary to determine
which client posted which message within a particular time
epoch. If an adversary can observe trafﬁc patterns across many
epochs, as the set of online clients changes, the adversary can
make statistical inferences about which client is sending which
stream of messages [24], [51], [56]. These “intersection” or
“statistical disclosure” attacks affect many anonymity systems
and defending against them is an important, albeit orthogonal,
problem [56], [76]. Even so,
intersection attacks typically

become more difﬁcult to mount as the size of the anonymity
set increases, so Riposte’s support for very large anonymity
sets makes it less vulnerable to these attacks than are many
prior systems.

III. SYSTEM ARCHITECTURE

As described in the prior section, a Riposte deployment
consists of a small number of servers, who maintain the
database state, and a large number of clients. To write into the
database, a client splits its write request using secret sharing
techniques and sends a single share to each of the servers.
Each server updates its database state using the client’s share.
After collecting write requests from many clients, the servers
combine their shares to reveal the plaintexts represented by the
write requests. The security requirement is that no coalition
of t servers can learn which client wrote into which row of
the database.

A. A First-Attempt Construction: Toy Protocol

As a starting point, we sketch a simple “straw man” con-
struction that demonstrates the techniques behind our scheme.
This ﬁrst-attempt protocol shares some design features with
anonymous communication schemes based on client/server
DC-nets [14], [77].

In the simple scheme, we have two servers, A and B, and
each server stores an L-bit bitstring, initialized to all zeros. We
assume for now that the servers do not collude—i.e., that one
of the two servers is honest. The bitstrings represent shares of
the database state and each “row” of the database is a single
bit.

Consider a client who wants to write a “1” into row (cid:2) of
the database. To do so, the client generates a random L-bit
bitstring r. The client sends r to server A and r⊕ e(cid:2) to server
B, where e(cid:2) is an L-bit vector of zeros with a one at index (cid:2)
and ⊕ denotes bitwise XOR. Upon receiving the write request
from the client, each server XORs the received string into its
share of the database.

After processing n write requests, the database state at

server A will be:

dA = r1 ⊕ ··· ⊕ rn

and the database at server B will be:

dB = (e(cid:2)1 ⊕ ··· ⊕ e(cid:2)n ) ⊕ (r1 ⊕ ··· ⊕ rn)

= (e(cid:2)1 ⊕ ··· ⊕ e(cid:2)n ) ⊕ dA

At the end of the time epoch, the servers can reveal the
plaintext database by combining their local states dA and dB.
The construction generalizes to ﬁelds larger than F2. For
example, each “row” of the database could be a k-bit bitstring
instead of a single bit. To prevent impersonation, network-
tampering, and replay attacks, we use authenticated and en-
crypted channels with per-message nonces bound to the time
epoch identiﬁer.

This protocol satisﬁes the write-privacy property as long as
the two servers do not collude (assuming that the clients and

324324

servers deploy the replay attack defenses mentioned above).
Indeed, server A can information theoretically simulate its
view of a run of the protocol given only e(cid:2)1 ⊕ ··· ⊕ e(cid:2)n as
input. A similar argument shows that the protocol is write-
private with respect to server B as well.

This ﬁrst-attempt protocol has two major limitations. The
ﬁrst limitation is that it is not bandwidth-efﬁcient. If millions
of clients want to use the system in each time epoch, then the
database must be at least millions of bits in length. To ﬂip a
single bit in the database then, each client must send millions
of bits to each database, in the form of a write request.

The second limitation is that it is not disruption resistant:
a malicious client can corrupt
the entire database with a
single malformed request. To do so, the malicious client picks
random L-bit bitstrings r and r(cid:2), sends r to server A, and sends
r(cid:2) (instead of r⊕e(cid:2)) to server B. Thus, a single malicious client
can efﬁciently and anonymously deny service to all honest
clients.

Improving bandwidth efﬁciency and adding disruption re-
sistance are the two core contributions of this work, and we
return to them in Sections IV and V.
B. Collisions

Putting aside the issues of bandwidth efﬁciency and disrup-
tion resistance for the moment, we now discuss the issue of
colliding writes to the shared database. If clients write into
random locations in the database, there is some chance that
one client’s write request will overwrite a previous client’s
message. If client A writes message mA into location (cid:2), client
B might later write message mB into the same location (cid:2). In
this case, row (cid:2) will contain mA ⊕ mB, and the contents of
row (cid:2) will be unrecoverable.

To address this issue, we set the size of the database table
to be large enough to accommodate the expected number
of write requests for a given “success rate.” For example,
the servers can choose a table size that
is large enough
to accommodate 210 write requests such that 95% of write
requests will not be involved in a collision (in expectation).
Under these parameters, 5% of the write requests will fail and
those clients will have to resubmit their write requests in a
future time epoch.

We can determine the appropriate table size by solving
a simple “balls and bins” problem. If we throw m balls
independently and uniformly at random into n bins, how many
bins contain exactly one ball? Here, the m balls represent
the write requests and the n bins represent the rows of the
database.

Let Bij be the probability that ball i falls into bin j. For
be the event that exactly

all i and j, Pr[Bij] = 1/n. Let O(1)
(cid:4)
one ball falls into bin i. Then
1 − 1
m
n
n

O(1)

(cid:2)

(cid:3)

Pr

=

i

i

(cid:5)m−1

Expanding using the binomial theorem and ignoring low order
(cid:2)
terms we obtain

(cid:3)

(cid:6) m

(cid:7)3

Pr

O(1)

i

≈ m
n

−

(cid:6) m

(cid:7)2

n

+

1
2

n

325325

(cid:6) m

(cid:7)2

n

where the approximation ignores terms of order (m/n)4 and
o(1/n). Then n· Pr[O(1)
] is the expected number of bins with
exactly one ball which is the expected number of messages
successfully received. Dividing this quantity by m gives the
expected success rate so that:

i

E[SuccessRate] =

n
m Pr[O(1)

i

] ≈ 1 − m

n +

1
2

So, if we want an expected success rate of 95% then we need
n ≈ 19.5m. For example, with m = 210 writers, we would
use a table of size n ≈ 20, 000.
Handling collisions. We can shrink the table size n by coding
the writes so that we can recover from collisions. We show
how to handle two-way collisions. That is, when at most two
clients write to the same location in the database. Let us
assume that the messages being written to the database are
elements in some ﬁeld F of odd characteristic (say F = Fp
where p = 264 − 59). We replace the XOR operation used in
the basic scheme by addition in F.

To recover from a two-way collision we will need to double
the size of each cell in the database, but the overall number
of cells n will shrink by more than a factor of two.
When a client A wants to write the message mA ∈ F to
location (cid:2) in the database the client will actually write the
A) ∈ F2 into that location. Clearly if no collision
pair (mA, m2
occurs at location (cid:2) then recovering mA at the end of the epoch
is trivial: simply drop the second coordinate (it is easy to test
that no collision occurred because the second coordinate is a
square of the ﬁrst). Now, suppose a collision occurs with some
B) ∈ F2
client B who also added her own message (mB, m2
to the same location (cid:2) (and no other client writes to location
(cid:2)). Then at the end of the epoch the published values are

S1 = mA+mB (mod p)

and S2 = m2

A+m2

B (mod p)

From these values it is quite easy to recover both mA and mB
by observing that

2S2 − S2

1 = (mA − mB)

2

(mod p)

from which we obtain mA − mB by taking a square root
modulo p (it does not matter which of the two square roots we
use—they both lead to the same result). Since S1 = mA +mB
is also given it is now easy to recover both mA and mB.

Now that we can recover from two-way collisions we can
shrink the number of cells n in the table. Let O(2)
be the
event that exactly two balls fell into bin i. Then the expected
number of received messages is

i

i

i

i

]

m
2

1
n2

] =

(1)

] + 2n Pr[O(2)
n Pr[O(1)
(cid:9)
(cid:8)
(cid:8)
1 − 1

(cid:9)m−2. As before, dividing the

where Pr[O(2)
expected number of received messages (1) by m, expanding
using the binomial theorem, and ignoring low order terms
gives the expected success rate as:
E[SuccessRate] ≈ 1 − 1
2

(cid:6) m

(cid:6) m

(cid:7)2

(cid:7)3

1
3

+

n

n

n

So, if we want an expected success rate of 95% we need a table
with n ≈ 2.7m cells. This is a far smaller table than before,
when we could not handle collisions. In that case we needed
n ≈ 19.5m which results in much bigger tables, despite each
cell being half as big. Shrinking the table reduces the storage
and computational burden on the servers.

This two-way collision handling technique generalizes to
handle k-way collisions for k > 2. To handle k-way collisions,
we increase the size of each cell by a factor of k and have each
i ) ∈ Fk to its chosen cell. A k-
client i write (mi, m2
collision gives k equations in k variables that can be efﬁciently
solved to recover all k messages, as long as the characteristic
of F is greater than k. Using k > 2 further reduces the table
size as the desired success rate approaches one.

i , . . . , mk

The collision handling method described in this section
will also improve performance of our full system, which we
describe in the next section.
Adversarial collisions. The analysis above assumes that
clients behave honestly. Adversarial clients, however, need
not write into random rows of the database—i.e., all m balls
might not be thrown independently and uniformly at random.
A coalition of clients might, for example, try to increase the
probability of collisions by writing into the database using
some malicious strategy.

By symmetry of writes we can assume that all ˆm adversarial
clients write to the database before the honest clients do. Now
a message from an honest client is properly received at the end
of an epoch if it avoids all the cells ﬁlled by the malicious
clients. We can therefore carry out the honest client analysis
above assuming the database contain n − ˆm cells instead of
n cells. In other words, given a bound ˆm on the number of
malicious clients we can calculate the required table size n. In
practice, if too many collisions are detected at the end of an
epoch the servers can adaptively double the size of the table
so that the next epoch has fewer collisions.

C. Forward Security

Even the ﬁrst-attempt scheme sketched in Section III-A
provides forward security in the event that all of the servers’
secret keys are compromised [13]. To be precise: an adversary
could compromise the state and secret keys of all servers
after the servers have processed n write requests from honest
clients, but before the time epoch has ended. Even in this
case, the adversary will be unable to determine which of the
n clients submitted which of the n plaintext messages with a
non-negligible advantage over random guessing. (We assume
here that clients and servers communicate using encrypted
channels which themselves have forward secrecy [50].)
This forward security property means that clients need not
trust that S − t servers stay honest forever—just that they
are honest at the moment when the client submits its upload
request. Being able to weaken the trust assumption about the
servers in this way might be valuable in hostile environments,
in which an adversary could compromise a server at any time
without warning.

Mix-nets do not have this property, since servers must
accumulate a set of onion-encrypted messages before shufﬂing
and decrypting them [15]. If an adversary always controls the
ﬁrst mix server and if it can compromise the rest of the mix
servers after accumulating a set of ciphertexts, the adversary
can de-anonymize all of the system’s users. DC-net-based
systems that use “blame” protocols to retroactively discover
disruptors have a similar weakness [19], [77].

The full Riposte protocol maintains this forward security

property.

IV. IMPROVING BANDWIDTH EFFICIENCY WITH

DISTRIBUTED POINT FUNCTIONS

This section describes how application of private informa-
tion retrieval techniques can improve the bandwidth efﬁciency
of the ﬁrst-attempt protocol.
Notation. The symbol F denotes an arbitrary ﬁnite ﬁeld, ZL is
the ring of integers modulo L. We use e(cid:2) ∈ FL to represent a
vector that is zero everywhere except at index (cid:2) ∈ ZL, where
it has value “1.” Thus, for m ∈ F, the vector m · e(cid:2) ∈ FL is
the vector whose value is zero everywhere except at index (cid:2),
where it has value m. For a ﬁnite set S, the notation x ←R S
indicates that the value of x is sampled independently and
uniformly at random from S. The element v[i] is the value of
a vector v at index i. We index vectors starting at zero.

A. Deﬁnitions

The bandwidth inefﬁciency of the protocol sketched above
comes from the fact that the client must send an L-bit vector
to each server to ﬂip a single bit in the logical database. To
reduce this O(L) bandwidth overhead, we apply techniques
inspired by private information retrieval protocols [16], [17],
[37].

The problem of private information retrieval (PIR) is es-
sentially the converse of the problem we are interested in
here. In PIR, the client must read a bit from a replicated
database without revealing to the servers the index being read.
In our setting, the client must write a bit into a replicated
database without revealing to the servers the index being
written. Ostrovsky and Shoup ﬁrst made this connection in
the context of a “private information storage” protocol [67].
PIR schemes allow the client to split its query to the servers
into shares such that (1) a subset of the shares does not leak
information about the index of interest, and (2) the length of
the query shares is much less than the length of the database.
The core building block of many PIR schemes, which we adopt
for our purposes, is a distributed point function. Although
Gilboa and Ishai [37] deﬁned distributed point functions as a
primitive only recently, many prior PIR schemes make implicit
use the primitive [16], [17]. Our deﬁnition of a distributed
point function follows that of Gilboa and Ishai, except that we
generalize the deﬁnition to allow for more than two servers.

First, we deﬁne a (non-distributed) point function.

Deﬁnition 4 (Point Function). Fix a positive integer L and a
ﬁnite ﬁeld F. For all (cid:2) ∈ ZL and m ∈ F, the point function

326326

P(cid:2),m : ZL → F is the function such that P(cid:2),m((cid:2)) = m and
P(cid:2),m((cid:2)(cid:2)

) = 0 for all (cid:2) (cid:8)= (cid:2)(cid:2).

That is, the point function P(cid:2),m has the value 0 when
evaluated at any input not equal to (cid:2) and it has the value
m when evaluated at (cid:2). For example, if L = 5 and F = F2,
the point function P3,1 takes on the values (0, 0, 0, 1, 0) when
evaluated on the values (0, 1, 2, 3, 4) (note that we index
vectors from zero).

An (s, t)-distributed point function provides a way to dis-
tribute a point function P(cid:2),m amongst s servers such that no
coalition of at most t servers learns anything about (cid:2) or m
given their t shares of the function.
Deﬁnition 5 (Distributed Point Function (DPF)). Fix a positive
integer L and a ﬁnite ﬁeld F. An (s, t)-distributed point
function consists of a pair of possibly randomized algorithms
that implement the following functionalities:
• Gen((cid:2), m) → (k0, . . . , ks−1). Given an integer (cid:2) ∈ ZL
and value m ∈ F, output a list of s keys.
) → m(cid:2). Given a key k generated using Gen,
• Eval(k, (cid:2)(cid:2)
and an index (cid:2)(cid:2) ∈ ZL, return a value m(cid:2) ∈ F.

We deﬁne correctness and privacy for a distributed point

function as follows:

• Correctness. For a collection of s keys generated using
Gen((cid:2), m), the sum of the outputs of these keys (gen-
erated using Eval) must equal the point function P(cid:2),m.
More formally, for all (cid:2), (cid:2)(cid:2) ∈ ZL and m ∈ F:

Pr[(k0, . . . , ks−1) ← Gen((cid:2), m) :
s−1
i=0 Eval(ki, (cid:2)(cid:2)
Σ

) = P(cid:2),m((cid:2)(cid:2)

)] = 1

where the probability is taken over the randomness of the
Gen algorithm.
• Privacy. Let S be any subset of {0, . . . , s− 1} such that
|S| ≤ t. Then for any (cid:2) ∈ ZL and m ∈ F, let DS,(cid:2),m
denote the distribution of keys {(ki) | i ∈ S} induced by
(k0, . . . , ks−1) ← Gen((cid:2), m). We say that an (s, t)-DPF
maintains privacy if there exists a p.p.t. algorithm Sim
such that the following distributions are computationally
indistinguishable:

DS,(cid:2),m ≈c Sim(S)

That is, any subset of at most t keys leaks no information
about (cid:2) or m. (We can also strengthen this deﬁnition to
require statistical or perfect indistinguishability.)

Toy Construction. To make this deﬁnition concrete, we ﬁrst
construct a trivial information-theoretically secure (s, s − 1)-
distributed point function with length-L keys. As above, we
ﬁx a length L and a ﬁnite ﬁeld F.
• Gen((cid:2), m) → (k0, . . . , ks−1). Generate random vectors
k0, . . . , ks−2 ∈ FL. Set ks−1 = m · e(cid:2) − Σ
) → m(cid:2). Interpret k as a vector in FL. Return
• Eval(k, (cid:2)(cid:2)
the value of the vector k at index (cid:2)(cid:2).

s−2
i=0 ki.

The correctness property of this construction follows imme-
diately. Privacy is maintained because the distribution of any
collection of s − 1 keys is independent of (cid:2) and m.

This toy construction uses length-L keys to distribute a point
function with domain ZL. Later in this section we describe
DPF constructions which use much shorter keys.

B. Applying Distributed Point Functions for Bandwidth Efﬁ-
ciency

We can now use DPFs to improve the efﬁciency of the write-
private database scheme introduced in Section III-A. We show
that the existence of an (s, t)-DPF with keys of length |k|
(along with standard cryptographic assumptions) implies the
existence of write-private database scheme using s servers that
maintains anonymity in the presence of t malicious servers,
such that write requests have length s|k|. Any DPF construc-
tion with short keys thus immediately implies a bandwidth-
efﬁcient write-private database scheme.

The construction is a generalization of the one presented in
Section III-A. We now assume that there are s servers such
that no more than t of them collude. Each of the s servers
maintains a vector in FL as their database state, for some
ﬁxed ﬁnite ﬁeld F and integer L. Each “row” in the database
is now an element of F and the database has L rows.
When the client wants to write a message m ∈ F into
location (cid:2) ∈ ZL in the database, the client uses an (s, t)-
distributed point function to generate a set of s DPF keys:

(k0, . . . , ks−1) ← Gen((cid:2), m)

) for (cid:2)(cid:2)

) = Eval(ki, (cid:2)(cid:2)

The client then sends one of the keys to each of the servers.
Each server i can then expand the key into a vector v ∈ FL
= 0, . . . , L − 1.
by computing v((cid:2)(cid:2)
The server then adds this vector v into its database state,
using addition in FL. At
the end of the time epoch, all
servers combine their database states to reveal the set of client-
submitted messages.
Correctness. The correctness of this construction follows
directly from the correctness of the DPF. For each of the n
write requests submitted by the clients, denote the j-th key in
the i-th request as ki,j, denote the write location as (cid:2)i, and
the message being written as mi. When the servers combine
their databases at the end of the epoch, the contents of the
ﬁnal database at row (cid:2) will be:

n−1(cid:10)

s−1(cid:10)

d(cid:2) =

Eval(ki,j, (cid:2)) =

n−1(cid:10)

P(cid:2)i,mi ((cid:2)) ∈ F

i=0

j=0

i=0

In words: as desired, the combined database contains the sum
of n point functions—one for each of the write requests.
Anonymity. The anonymity of this construction follows di-
rectly from the privacy property of the DPF. Given the
plaintext database state d (as deﬁned above), any coalition of t
servers can simulate its view of the protocol. By deﬁnition of
DPF privacy, there exists a simulator Sim, which simulates the
distribution of any subset of t DPF keys generated using Gen.
The coalition of servers can use this simulator to simulate each

327327

of the n write requests it sees during a run of the protocol.
Thus, the servers can simulate their view of a protocol run
and cannot win the anonymity game with non-negligible
advantage.
Efﬁciency. A client in this scheme sends |k| bits to each server
(where k is a DPF key), so the bandwidth efﬁciency of the
scheme depends on the efﬁciency of the DPF. As we will show
later in this section, |k| can be much smaller than the length
of the database.

C. A Two-Server Scheme Tolerating One Malicious Server

√

Having established that DPFs with short keys lead to
bandwidth-efﬁcient write-private database schemes, we now
present one such DPF construction. This construction is a
simpliﬁcation of computational PIR scheme of Chor and
Gilboa [16].

When Eval(k, (cid:2)(cid:2)

This is a (2, 1)-DPF with keys of length O(

L) operating
on a domain of size L. This DPF yields a two-server write-
√
private database scheme tolerating one malicious server such
that writing into a database of size L requires sending O(
L)
bits to each server. Gilboa and Ishai [37] construct a (2, 1)-
DPF with even shorter keys (|k| = polylog(L)), but
the
construction presented here is efﬁcient enough for the database
sizes we use in practice. Although the DPF construction
works over any ﬁeld, we describe it here using the binary
ﬁeld F = F2k (the ﬁeld of k-bit bitstrings) to simplify the
exposition.
) is run on every integer (cid:2)(cid:2) ∈ {0, . . . , L −
1}, its output is a vector of L ﬁeld elements. The DPF key
construction conceptually works by representing this a vector
of L ﬁeld elements as an x × y matrix, such that xy ≥ L.
The trick that makes the construction work is that the size
of the keys needs only to grow with the size of the sides of
this matrix rather than its area. The DPF keys that Gen((cid:2), m)
outputs give an efﬁcient way to construct two matrices MA
and MB that differ only at one cell (cid:2) = ((cid:2)x, (cid:2)y) ∈ Zx × Zy
(Figure 2).
Fix a binary ﬁnite ﬁeld F = F2k, a DPF domain size L,
and integers x and y such that xy ≥ L. (Later in this section,
we describe how to choose x and y to minimize the key size.)
The construction requires a pseudo-random generator (PRG) G
that stretches seeds from some space S into length-y vectors of
elements of F [47]. So the signature of the PRG is G : S → Fy.
In practice, an implementation might use AES-128 in counter
mode as the pseudo-random generator [64].
The algorithms comprising the DPF are:
• Gen((cid:2), m) → (kA, kB). Compute integers (cid:2)x ∈ Zx and
(cid:2)y ∈ Zy such that (cid:2) = (cid:2)xy + (cid:2)y. Sample a random bit-
vector bA ←R {0, 1}x, a random vector of PRG seeds
sA ←R Sx, and a single random PRG seed s∗
←R S.

(cid:2)x

328328

Given bA and sA, we deﬁne bB and sB as:

bA = (b0, . . . , b(cid:2)x
bB = (b0, . . . , ¯b(cid:2)x
sA = (s0, . . . , s(cid:2)x
sB = (s0, . . . , s∗

(cid:2)x

, . . . , bx−1)
, . . . , bx−1)
, . . . , sx−1)
, . . . , sx−1)

(cid:2)x ).

That is, the vectors bA and bB (similarly sA and sB)
differ only at index (cid:2)x.
Let m · e(cid:2)y be the vector in Fy of all zeros except that it
has value m at index (cid:2)y. Deﬁne v ← m· e(cid:2)y + G(s(cid:2)x ) +
G(s∗
The output DPF keys are:
kA = (bA, sA, v)
) → m(cid:2). Interpret k as a tuple (b, s, v). To
• Eval(k, (cid:2)(cid:2)
evaluate the PRF at index (cid:2)(cid:2), ﬁrst write (cid:2)(cid:2) as an ((cid:2)(cid:2)
x, (cid:2)(cid:2)
y)
y ∈ Zy, and (cid:2)(cid:2)
x ∈ Zx, (cid:2)(cid:2)
tuple such that (cid:2)(cid:2)
xy + (cid:2)(cid:2)
= (cid:2)(cid:2)
y. Use
the PRG G to stretch the (cid:2)(cid:2)
x-th seed of s into a length-y
x]). Return m(cid:2) ← (g[(cid:2)(cid:2)
vector: g ← G(s[(cid:2)(cid:2)
x]v[(cid:2)(cid:2)
y] + b[(cid:2)(cid:2)
y]).
Figure 2 graphically depicts how Eval stretches the keys

kB = (bB, sB, v)

into a table of x × y ﬁeld elements.
Correctness. We prove correctness of the scheme in Ap-
pendix B.
Privacy. The privacy property requires that there exists an
efﬁcient simulator that, on input “A” or “B,” outputs samples
from a distribution that is computationally indistinguishable
from the distribution of DPF keys kA or kB.
The simulator Sim simulates each component of the DPF
key as follows: It samples b ←R {0, 1}x, s ←R Sx, and
v ←R Fy. The simulator returns (b, s, v).

We must now argue that the simulator’s output distribution
is computationally indistinguishable from that
induced by
the distribution of a single output of Gen. Since the b and
s vectors outputted by Gen are random, the simulation is
perfect. The v vector outputted by Gen is computationally
indistinguishable from random, since it is padded with the
output of the PRG seeded with a seed unknown to the holder of
the key. An efﬁcient algorithm to distinguish the simulated v
vector from random can then also distinguish the PRG output
from random.
Key Size. A key for this DPF scheme consists of: a vector
in {0, 1}x, a vector in Sx, and a vector in Fy. Let α be the
number of bits required to represent an element of S and let
β be the number of bits required to represent an element of
F. The total length of a key is then:

|k| = (1 + α)x + βy

For ﬁxed spaces S and F, we can ﬁnd the optimal choices of
x and y to minimize the key length. To do so, we solve:

xy ≥ L
(cid:11)

((1 + α)x + βy)

subject to

min
x,y

and conclude that the optimal values of x and y are:
β

√

√
L and

x = c

y =

1
c

L where

c =

.

1 + α

Fig. 2: Left: We represent the output of Eval as an x × y matrix of ﬁeld elements. Left-center: Construction of the v vector
used in the DPF keys. Right: using the v, s, and b vectors, Eval expands each of the two keys into an x × y matrix of ﬁeld
elements. These two matrices sum to zero everywhere except at ((cid:2)x, (cid:2)y) = (3, 4), where they sum to m.

The key size is then O(

√
L).

When using a database table of one million rows in length
(L = 220), a row length of 1 KB per row (F = F28192), and a
PRG seed size of 128 bits (using AES-128, for example) the
keys will be roughly 263 KB in length. For these parameters,
the keys for the naïve construction (Section III-A) would be
1 GB in length. Application of efﬁcient DPFs thus yields a
4,000× bandwidth savings in this case.
Computational Efﬁciency. A second beneﬁt of this scheme
is that both the Gen and Eval routines are computationally
efﬁcient, since they just require performing ﬁnite ﬁeld addi-
tions (i.e., XOR for binary ﬁelds) and PRG operations (i.e.,
computations of the AES function). The construction requires
no public-key primitives.
D. An s-Server Scheme Tolerating s − 1 Malicious Servers
√
The (2, 1)-DPF scheme described above achieved a key
L) bits using only symmetric-key primitives. The
size of O(
limitation of that construction is that it only maintains privacy
when a single key is compromised. In the context of a write-
private database scheme, this means that the construction can
only maintain anonymity in the presence of a single mali-
cious server. It would be much better to have a write-private
database scheme with s servers that maintains anonymity in
the presence of s−1 malicious servers. To achieve this stronger
security notion, we need a bandwidth-efﬁcient (s, s − 1)-
distributed point function.
In this section, we construct an (s, s − 1)-DPF where each
key has size O(
L). We do so at the cost of requiring more
expensive public-key cryptographic operations, instead of the
symmetric-key operations used in the prior DPF. While the
(2, 1)-DPF construction above directly follows the work of
Chor and Gilboa [16], this (s, s−1)-DPF construction is novel,
as far as we know.

√

This construction uses a seed-homomorphic pseudorandom
generator [3], [10], [63], to split the key for the pseudo-
random generator G across a collection of s DPF keys.
Deﬁnition
seed-
homomorphic PRG is a pseudo-random generator G
mapping seeds in a group (S,⊕) to outputs in a group (G,⊗)

(Seed-Homomorphic

PRG). A

6

with the additional property that for any s0, s1 ∈ S:

G(s0 ⊕ s1) = G(s0) ⊗ G(s1)

It is possible to construct a simple seed-homomorphic PRG
from the decision Difﬁe-Hellman (DDH) assumption [10],
[63]. The public parameters for the scheme are list of y
generators chosen at random from an order-q group G, in
which the DDH problem is hard [9]. For example, if G is
an elliptic curve group [57], then the public parameters will
be y points (P0, . . . , Py−1) ∈ Gy. The seed space is Zq and
the generator outputs vectors in Gy. On input s ∈ Zq, the
generator outputs (sP0, . . . , sPy−1). The generator is seed-
homomorphic because, for any s0, s1 ∈ Zq, and for all
i ∈ {1, . . . , y}: s0Pi + s1Pi = (s0 + s1)Pi.

As in the prior DPF construction, we ﬁx a DPF domain size
L, and integers x and y such that xy ≥ L. The construction
requires a seed-homomorphic PRG G : S (cid:12)→ Gy, for some
group G of prime order q.

For consistency with the prior DPF construction, we will
write the group operation in G using additive notation. Thus,
the group operation applied component-wise to vectors u, v ∈
Gy results in the vector (u + v) ∈ Gy. Since G has order q,
qA = 0 for all A ∈ G.

The algorithms comprising the (s, s − 1)-DPF are:
• Gen((cid:2), m) → (k0, . . . , ks−1). Compute integers (cid:2)x ∈ Zx
and (cid:2)y ∈ Zy such that (cid:2) = (cid:2)xy + (cid:2)y. Sample random
integer-valued vectors b0, . . . , bs−2 ←R (Zq)x, random
vectors of PRG seeds s0, . . . , ss−2 ←R Sx, and a single
random PRG seed s∗ ←R S.
Select bs−1 ∈ (Zq)x such that Σ
s−1
k=0bk = e(cid:2)x (mod q)
and select ss−1 ∈ Sx such that Σ
k=0sk = s∗ · e(cid:2)x ∈ Gx.
s−1
Deﬁne v ← m · e(cid:2)y
The DPF key for server i ∈ {0, . . . , s − 1} is ki =
(bi, si, v).
) → m(cid:2). Interpret k as a tuple (b, s, v). To
• Eval(k, (cid:2)(cid:2)
evaluate the PRF at index (cid:2)(cid:2), ﬁrst write (cid:2)(cid:2) as an ((cid:2)(cid:2)
x, (cid:2)(cid:2)
y)
x ∈ Zx, (cid:2)(cid:2)
y ∈ Zy, and (cid:2)(cid:2)
= (cid:2)(cid:2)
tuple such that (cid:2)(cid:2)
xy + (cid:2)(cid:2)
y. Use
the PRG G to stretch the (cid:2)(cid:2)
x-th seed of s into a length-y
x]). Return m(cid:2) ← (g[(cid:2)(cid:2)
vector: g ← G(s[(cid:2)(cid:2)
y] + b[(cid:2)(cid:2)
x]v[(cid:2)(cid:2)
y]).
We omit correctness and privacy proofs, since they follow
exactly the same structure as those used to prove security of

− G(s∗

).

329329

our prior DPF construction. The only difference is that correct-
ness here relies on the fact that G is a seed-homomorphic PRG,
rather than a conventional PRG. As in the DPF construction
of Section IV-C, the keys here are of length O(

√
L).

Computational Efﬁciency. The main computational cost of
this DPF construction comes from the use of the seed-
homomorphic PRG G. Unlike a conventional PRG, which
can be implemented using AES or another fast block cipher
in counter mode, known constructions of seed-homomorphic
PRGs require algebraic groups [63] or lattice-based cryptog-
raphy [3], [10].
When instantiating the (s, s− 1)-DPF with the DDH-based
PRG construction in elliptic curve groups, each call to the
DPF Eval routine requires an expensive elliptic curve scalar
multiplication. Since elliptic curve operations are, per byte,
orders of magnitude slower than AES operations, this (s, s −
1)-DPF will be orders of magnitude slower than the (2, 1)-
DPF. Security against an arbitrary number of malicious servers
comes at the cost of computational efﬁciency, at least for these
DPF constructions.

With DPFs, we can now construct a bandwidth-efﬁcient
tolerates one malicious
write-private database scheme that
server (ﬁrst construction) or s − 1 out of s malicious servers
(second construction).

V. PREVENTING DISRUPTORS

The ﬁrst-attempt construction of our write-private database
scheme (Section III-A) had two limitations: (1) client write
requests were very large and (2) malicious clients could cor-
rupt the database state by sending malformed write requests.
We addressed the ﬁrst of these two challenges in Section IV.
In this section, we address the second challenge.

A client write request in our protocol just consists of a
collection of s DPF keys. The client sends one key to each of
the s servers. The servers must collectively decide whether the
collection of s keys is a valid output of the DPF Gen routine,
without revealing any information about the keys themselves.
One way to view the servers’ task here is as a secure multi-
party computation [41], [78]. Each server i’s private input is
its DPF key ki. The output of the protocol is a single bit,
which determines if the s keys (k0, . . . , ks−1) are a well-
formed collection of DPF keys.

Since we already rely on servers for availability (Sec-
tion II-B), we need not protect against servers maliciously
trying to manipulate the output of the multi-party protocol.
Such manipulation could only result in corrupting the database
(if a malicious server accepts a write request that it should have
rejected) or denying service to an honest client (if a malicious
server rejects a write request that it should have accepted).
Since both attacks are tantamount to denial of service, we
need not consider them.

We do care, in contrast, about protecting client privacy
against malicious servers. A malicious server participating in
the protocol should not gain any additional information about

the private inputs of other parties, no matter how it deviates
from the protocol speciﬁcation.

We construct two protocols for checking the validity of
client write requests. The ﬁrst protocol is computationally
inexpensive, but requires introducing a third non-colluding
party to the two-server scheme. The second protocol requires
relatively expensive zero-knowledge proofs [30], [42], [43],
[70], but it maintains security when all but one of s servers is
malicious. Both of these protocols must satisfy the standard
notions of soundness, completeness, and zero-knowledge [12].

A. Three-Party Protocol

Our ﬁrst protocol for detecting malformed write requests
works with the (2, 1)-DPF scheme presented in Section IV-C.
The protocol uses only hashing and ﬁnite ﬁeld additions,
so it is computationally inexpensive. The downside is that
it requires introducing a third audit server, which must not
collude with either of the other two servers.

We ﬁrst develop a three-party protocol called AlmostEqual
that we use as a subroutine to implement the full write request
validation protocol. The AlmostEqual protocol takes place
between three parties: server A, server B, and an audit server.
Server A’s private input is a vector vA ∈ Fn and server B’s
private input is a vector vB ∈ Fn. The audit server has no
private input. The output of the AlmostEqual protocol is “1”
bit if vA and vB differ at exactly one index and is “0” bit
otherwise. As with classical secure multi-party computations,
the goal of the protocol is to accurately compute the output
without leaking any extraneous information about the players’
private inputs [29], [41], [78]. We use AlmostEqual in such
a way that, whenever the client’s write request is properly
formed and whenever no two servers collude, the output of the
protocol will be “1.” Thus, we need only prove the protocol
secure in the case when the output is “1.”

We denote an instance of

the three-party protocol as
AlmostEqual(vA, vB), where the arguments denote the two
secret inputs of party A and party B. The protocol proceeds
as follows:

1) Servers A and B use a coin-ﬂipping protocol [8] to
sample n hash functions h0, . . . , hn−1 from a family
of pairwise independent hash functions H [55] having
domain F. The servers also agree upon a random “shift”
value f ∈ Zn.
the values mi ← hi(vA[i])
for every index i ∈ {0, . . . , n − 1} and sends
(mf , mf +1, . . . , mn−1, m0, . . . , mf−1) to the auditor.

2) Server A computes

3) Server B repeats Step 2 with vB.
4) The audit server returns “1” to servers A and B if and
only if the vectors it receives from the two servers are
equal at every index except one. The auditor returns “0”
otherwise.

We include proofs of soundness, correctness, and zero-

knowledge for this construction in Appendix C.

The keys for the (2, 1)-DPF construction have the form

kA = (bA, sA, v)

kB = (bB, sB, v).

330330

In a correctly formed pair of keys, the b and s vectors differ
at a single index (cid:2)x, and the v vector is equal to v = e(cid:2)y,m +
G(sA[(cid:2)x]) + G(sB[(cid:2)x]).
To determine whether a pair of keys is correct, server A
constructs a test vector tA such that tA[i] = bA[i](cid:13)sA[i]
for i ∈ {0, . . . , x − 1}. (where (cid:13) denotes concatenation).
Server B constructs a test vector tB in the same way and
the two servers, along with the auditor run the protocol
AlmostEqual(tA, tB). If the output of this protocol is “1,”
then the servers conclude that their b and s vectors differ
at a single index, though the protocol does not reveal to the
servers which index this is. Otherwise, the servers reject the
write request.

Next, the servers must verify that the v vector is well-
formed. To do so, the servers compute another pair of test
vectors:

G(sA[i])

uB = v +

G(sB[i]).

x−1(cid:10)

uA =

i=0

x−1(cid:10)

i=0

The servers run AlmostEqual(uA, uB) and accept the write
request as valid if it returns “1.”

We prove security of this construction in the full version of

this paper.

An important implementation note is that if m = 0—
that is, if the client writes the string of all zeros into the
database—then the u vectors will not differ at any index and
this information is leaked to the auditor. The protocol only
provides security if the vectors differ at exactly one index. To
avoid this information leakage, client requests must be deﬁned
such that m (cid:8)= 0 in every write request. To achieve this, clients
could deﬁne some special non-zero value to indicate “zero” or
could use a padding scheme to ensure that zero values occur
with negligible probability.

As a practical matter, the audit server needs to be able to
match up the portions of write requests coming from server
A with those coming from server B. Riposte achieves this as
follows: When the client sends its upload request to server
A, the client includes a cryptographic hash of the request it
sent to server B (and vice versa). Both servers can use these
hashes to derive a common nonce for the request. When the
servers send audit requests to the audit server, they include
the nonce for the write request in question. The audit server
can use the nonce to match every audit request from server A
with the corresponding request from server B.

√
This three-party protocol is very efﬁcient—it only requires
O(
L) commu-
L) applications of a hash function and O(
nication from the servers to the auditor. The auditor only
performs a simple string comparison, so it needs minimal
computational and storage capabilities.
B. Zero Knowledge Techniques

√

Our second technique for detecting disruptors makes use of

non-interactive zero-knowledge proofs [11], [43], [70].

We apply zero-knowledge techniques to allow clients to
prove the well-formedness of their write requests. This tech-
nique works in combination with the (s, s− 1)-DPF presented

in Section IV-D and maintains client write-privacy when all
but one of s servers is dishonest.
The keys for the (s, s−1)-DPF scheme are tuples (bi, si, v)
such that:
s−1(cid:10)

s−1(cid:10)

si = s∗ · e(cid:2)x

v = m · e(cid:2)y − G(s∗

)

bi = e(cid:2)x

i=0

i=0

To prove that its write request was correctly formed, we
have the client perform zero-knowledge proofs over collections
of Pedersen commitments [68]. The public parameters for
the Pedersen commitment scheme consist of a group G of
prime order q and two generators P and Q of G such that
no one knows the discrete logarithm logQ P . A Pedersen
commitment to a message m ∈ Zq with randomness r ∈ Zq
is C(m, r) = (mP + rQ) ∈ G (writing the group operation
additively). Pedersen commitments are homomorphic, in that
given commitments to m0 and m1, it is possible to compute
a commitment to m0 + m1:

C(m0, r0) + C(m1, r1) = C(m0 + m1, r0 + r1)

Here, we assume that the (s, s− 1)-DPF is instantiated with
the DDH-based PRG introduced in Section IV-D and that the
group G used for the Pedersen commitments is the same order-
q group used in the PRG construction.

To execute the proof, the client ﬁrst generates Pedersen
commitments to elements of each of the s DPF keys. Then
each server i can verify that the client computed the com-
mitment to the i-th DPF key elements correctly. The servers
use the homomorphic property of Pedersen commitments to
generate commitments to the sum of the elements of the DPF
keys. Finally, the client proves in zero knowledge that these
sums have the correct values.

The protocols proceed as follows:
1) The client generates vectors of Pedersen commitments Bi
and Si committing to each element of bi and si. client
sends the B and S vectors to every server.

2) To server i, the client sends the opening of the commit-
ments Bi and Si. Each server i veriﬁes that Bi and Si
are valid commitments to the bi and si vectors in the
DPF key. If this check fails at some server i, server i
notiﬁes the other servers and all servers reject the write
request.

3) Using the homomorphic property of the commitments,
each server can compute vectors of commitments Bsum
and Ssum to the vectors Σ

s−1
i=0 bi and Σ

s−1
i=0 si.

4) Using a non-interactive zero-knowledge proof, the client
proves to the servers that Bsum and Ssum are commitments
to zero everywhere except at a single (secret) index (cid:2)x,
and that Bsum[(cid:2)x] is a commitment to one.1 This proof
uses standard witness hiding techniques for discrete-
logarithm-based zero knowledge proofs [11], [21]. If the
proof is valid, the servers continue to check the v vector.

1 Technically, this is a zero-knowledge proof of knowledge which proves

that the client knows an opening of the commitments to the stated values.

331331

This ﬁrst protocol convinces each server that the b and s
components of the DPF keys are well formed. Next, the servers
check the v component:

1) For each server i, the client sums up the seed values si it
s−1
j=0si[j]. The client then generates

sent to server i: σi = Σ
the output of G(σk) and blinds it:

Gi = (σiP1 + r1Q, σiP2 + r2Q, . . . ).

2) The client sends the G values to all servers and the client

sends the opening of Gi to each server i.

3) Each server veriﬁes that the openings are correct, and all
servers reject the write request if this check fails at any
server.

4) Using the homomorphic property of Pedersen commit-
ments, every server can compute a vector of commitments
s−1
i=0 Gi)+v. If v is well formed, then the Gsum
Gsum = (Σ
vector contain commitments to zero at every index except
one (at which it will contain a commitment to the client’s
message m).

5) The client uses a non-interactive zero-knowledge proof
to convince the servers that the vector of commitments
Gsum contains commitments to zero at all indexes except
one. If the proof is valid, the servers accept the write
request.

We prove in the full version of this paper that this protocol
satisﬁes the standard notions of soundness, completeness, and
zero-knowledge [12].

VI. EXPERIMENTAL EVALUATION

To demonstrate that Riposte is a practical platform for
trafﬁc-analysis-resistant anonymous messaging, we imple-
mented two variants of the system. The ﬁrst variant uses the
two-server distributed point function (Section IV-C) and uses
the three-party protocol (Section V-A) to prevent malicious
clients from corrupting the database. This variant is relatively
fast, since it relies primarily on symmetric-key primitives, but
requires that no two of the three servers collude. Our results for
the ﬁrst variant include the cost of identifying and excluding
malicious clients.
The second variant uses the s-server distributed point func-
tion (Section IV-D). This variant protects against s− 1 collud-
ing servers, but relies on expensive public-key operations. We
have not implemented the zero-knowledge proofs necessary to
prevent disruptors for the s-server protocol (Section V-B), so
the performance numbers represent only an upper bound on
the system throughput.

We wrote the prototype in the Go programming language
and have published the source code online at https://bitbucket.
org/henrycg/riposte/. We used the DeterLab network testbed
for our experiments [58]. All of the experiments used com-
modity servers running Ubuntu 14.04 with four-core AES-NI-
enabled Intel E3-1260L CPUs and 16 GB of RAM.

Our experimental network topology used between two and
ten servers (depending on the protocol variant in use) and
eight client nodes. In each of these experiments, the eight
client machines used many threads of execution to submit

 1000

 100

 10

)
c
e
s
/
s
t
s
e
u
q
e
r
 
t
n
e

t
u
p
h
g
u
o
r
h
T

i
l

c
(

 1

10 

Actual throughput
Maximum TLS throughput
Maximum AES throughput

100 
Database table size (# of 160-byte rows)

100k

10k

1M

1k

10M

Fig. 3: As the database table size grows, the throughput of
our system approaches the maximum possible given the AES
throughput of our servers.

write requests to the servers as quickly as possible. In all
experiments, the server nodes connected to a common switch
via 100 Mbps links, the clients nodes connected to a common
switch via 1 Gbps links, and the client and server switches
connected via a 1 Gbps link. The round-trip network latency
between each pair of nodes was 20 ms. We chose this network
topology to limit the bandwidth between the servers to that of
a fast WAN, but to leave client bandwidth unlimited so that
the small number of client machines could saturate the servers
with write requests.

Error bars in the charts indicate the standard deviation of

the throughput measurements.
A. Three-Server Protocol

A three-server Riposte cluster consists of two database
servers and one audit server. The system maintains its security
properties as long as no two of these three servers collude. We
have fully implemented the three-server protocol, including the
audit protocol (Section V-A), so the throughput numbers listed
here include the cost of detecting and rejecting malicious write
requests.

The prototype used AES-128 in counter mode as the
pseudo-random generator, Poly1305 as the keyed hash func-
tion used in the audit protocol [7], and TLS for link encryption.
Figure 3 shows how many client write requests our Riposte
cluster can service per second as the number of 160-byte rows
in the database table grows. For a database table of 64 rows,
the system handles 751.5 write requests per second. At a table
size of 65,536 rows, the system handles 32.8 requests per
second. At a table size of 1,048,576 rows, the system handles
2.86 requests per second.

We chose the row length of 160 bytes because it was the
smallest multiple of 32 bytes large enough to to contain a
140-byte Tweet. Throughput of the system depends only the
total size of the table (number of rows × row length), so
larger row lengths might be preferable for other applications.
For example, an anonymous email system using Riposte with
4096-byte rows could handle 2.86 requests per second at a
table size of 40,960 rows.

An upper bound on the performance of the system is the
speed of the pseudo-random generator used to stretch out the

332332

)
c
e
s
/
s
t
s
e
u
q
e
r
 
t
n
e

t
u
p
h
g
u
o
r
h
T

i
l

c
(

 50
 40
 30
 20
 10
 0

 0.0001

 0.01

 1

 100

 10000

Database table width-height ratio

Fig. 4: Use of bandwidth-efﬁcient DPFs gives a 32× speed-up
over the naïve constructions, in which a client’s request is as
large as the database.

10GB

1GB

100MB

10MB

1MB

100kB

10kB

1kB

)
s
e
t
y
b
(
 
r
e
f
s
n
a
r
t
 

t

a
a
D

100 B

10 

No DPF
Server - Recv
Server - Send
Audit - Recv
Audit - Send

1k

1M

10M 100M

100 
Database table size (# of 160-byte rows)

100k

10k

Fig. 5: The total client and server data transfer scales sub-
linearly with the size of the database.

DPF keys to the length of the database table. The dashed
line in Figure 3 indicates this upper bound (605 MB/s), as
determined using an AES benchmark written in Go. That line
indicates the maximum possible throughput we could hope to
achieve without aggressive optimization (e.g., writing portions
of the code in assembly) or more powerful machines. Migrat-
ing the performance-critical portions of our implementation
from Go to C (using OpenSSL) might increase the throughput
by a factor of as much as 6×, since openssl speed reports
AES throughput of 3.9 GB/s, compared with the 605 MB/s we
obtain with Go’s crypto library. At very small table sizes, the
speed at which the server can set up TLS connections with the
clients limits the overall throughput to roughly 900 requests
per second.

Figure 4 demonstrates how the request throughput varies as
the width of the table changes, while the number of bytes in
the table is held constant at 10 MB. This ﬁgure demonstrates
√
the performance advantage of using a bandwidth-efﬁcient
O(
L) DPF (Section IV) over the naïve DPF (Section III-A).
Using a DPF with optimal table size yields a throughput of
38.4 requests per second. The extreme left and right ends
of the ﬁgure indicate the performance yielded by the naïve
construction, in which making a write request involves sending
a (1 × L)-dimension vector to each server. At the far right
extreme of the table, performance drops to 0.05 requests per
second, so DPFs yield a 768× speed-up.

333333

Figure 5 indicates the total number of bytes transferred by
one of the database servers and by the audit server while
processing a single client write request. The dashed line at
the top of the chart indicates the number of bytes a client
would need to send for a single write request if we did not
use bandwidth-efﬁcient DPFs (i.e., the dashed line indicates
the size of the database table). As the ﬁgure demonstrates,
the total data transfer in a Riposte cluster scales sub-linearly
with the database size. When the database table is 2.5 GB in
size, the database server transfers only a total of 1.23 MB to
process a write request.

B. s-Server Protocol

In some deployment scenarios, having strong protection
against server compromise may be more important than perfor-
mance or scalability. In these cases, the s-server Riposte pro-
tocol provides the same basic functionality as the three-server
protocol described above, except that it maintains privacy even
if s − 1 out of s servers collude or deviate arbitrarily from
the protocol speciﬁcation. We implemented the basic s-server
protocol but have not yet implemented the zero-knowledge
proofs necessary to prevent malicious clients from corrupting
the database state (Section V-B). These performance ﬁgures
thus represent an upper bound on the s-server protocol’s
performance. Adding the zero-knowledge proofs would require
L) elliptic curve operations per server in
an additional Θ(
an L-row database. The computational cost of the proofs
would almost certainly be dwarfed by the Θ(L) elliptic curve
operations required to update the state of the database table.
The experiments use the DDH-based seed-homomorphic
pseudo-random generator described in Section IV-D and they
use the NIST P-256 elliptic curve as the underlying algebraic
group. The table row size is ﬁxed at 160 bytes.

√

Figure 6 demonstrates the performance of an eight-server
Riposte cluster as the table size increases. At a table size of
1,024 rows, the cluster can process one request every 3.44
seconds. The limiting factor is the rate at which the servers
can evaluate the DDH-based pseudo-random generator (PRG),
since computing each 32-byte block of PRG output requires a
costly elliptic curve scalar multiplication. The dashed line in
the ﬁgure indicates the maximum throughput obtainable using
Go’s implementation of P-256 on our servers, which in turn
dictates the maximum cluster throughput. Processing a single
request with a table size of one million rows would take nearly
one hour with this construction, compared to 0.3 seconds in
the AES-based three-server protocol.

Figure 7 shows how the throughput of the Riposte cluster
changes as the number of servers varies. Since the workload
is heavily CPU-bound, the throughput only decreases slightly
as the number of servers increases from two to ten.

C. Discussion: Whistleblowing and Microblogging with
Million-User Anonymity Sets

Whistleblowers, political activists, or others discussing sen-
sitive or controversial issues might beneﬁt from an anonymous
microblogging service. A whistleblower, for example, might

Actual throughput
Maximum EC throughput

 100

 10

 1

 0.1

)
c
e
s
/
s
t
s
e
u
q
e
r
 
t
n
e

t
u
p
h
g
u
o
r
h
T

i
l

c
(

 0.01

10 

100 

1k

10k

Database table size (# of 160-byte rows)

Fig. 6: Throughput of an eight-server Riposte cluster using the
(8, 7)-distributed point function.

)
c
e
s
/
s
t
s
e
u
q
e
r
 
t

t
u
p
h
g
u
o
r
h
T

n
e

i
l

c
(

 9
 8
 7
 6
 5
 4
 3
 2
 1

16-row table
64-row table

2 

3 

4 

5 

6 

7 

8 

9 

10 

Number of servers

Fig. 7: Throughput of Riposte clusters using two different
database table sizes as the number of servers varies.

want to anonymously blog about an instance of bureaucratic
corruption in her organization. The utility of such a system
depends on the size of the anonymity set it would provide:
if a whistleblower is only anonymous amongst a group of
ten people, it would be easy for the whistleblower’s employer
to retaliate against everyone in the anonymity set. Mounting
this “punish-them-all” attack does not require breaking the
anonymity system itself, since the anonymity set is public.
As the anonymity set size grows, however,
the feasibility
of the “punish-them-all” attack quickly tends to zero. At an
anonymity set size of 1,000,000 clients, mounting an “punish-
them-all” attack would be prohibitively expensive in most
situations.

Riposte can handle such large anonymity sets as long as (1)
clients are willing to tolerate hours of messaging latency, and
(2) only a small fraction of clients writes into the database in
each time epoch. Both of these requirements are satisﬁed in the
whistleblowing scenario. First, whistleblowers might not care
if the system delays their posts by a few hours. Second, the
vast majority of users of a microblogging service (especially
in the whistleblowing context) are more likely to read posts
than write them. To get very large anonymity sets, maintainers
of an anonymous microblogging service could take advantage
of the large set of “read-only” users to provide anonymity for
the relatively small number of “read-write” users.

334334

The client application for such a microblogging service
would enable read-write users to generate and submit Riposte
write requests to a Riposte cluster running the microblogging
service. However, the client application would also allow read-
only users to submit an “empty” write request to the Riposte
cluster that would always write a random message into the
ﬁrst row of the Riposte database. From the perspective of the
servers, a read-only client would be indistinguishable from a
read-write client. By leveraging read-only users in this way,
we can increase the size of the anonymity set without needing
to increase the size of the database table.

To demonstrate that Riposte can support very large
anonymity set sizes—albeit with high latency—we conﬁgured
a cluster of Riposte servers with a 65,536-row database table
and left it running for 32 hours. In that period, the system
processed a total of 2,895,216 write requests at an average
rate of 25.19 requests per second. (To our knowledge, this is
the largest anonymity set ever constructed in a system that
offers protection against trafﬁc analysis attacks.) Using the
techniques in Section III-B, a table of this size could handle
0.3% of users writing at a collision rate of under 5%. Thus, to
get an anonymity set of roughly 1,000,000 users with a three-
server Riposte cluster and a database table of size 65, 536, the
time epoch must be at least 11 hours long.

As of 2013, Twitter reported an average throughput of
5,700 140-byte Tweets per second [52]. That is equivalent
roughly 5,000 of our 160-byte messages per second. At a table
size of one million messages, our Riposte cluster’s end-to-
end throughput is 2.86 write requests per second (Figure 3).
To handle the same volume of Tweets as Twitter does with
anonymity set sizes on the order of hundreds of thousands
of clients, we would need to increase the computing power
of our cluster by “only” a factor of ≈1,750.2 Since we are
using only three servers now, we would need roughly 5,250
servers (split into three non-colluding data centers) to handle
the same volume of trafﬁc as Twitter. Furthermore, since the
audit server is just doing string comparisons, the system would
likely need many fewer audit servers than database servers, so
the total number of servers required might be closer to 4, 000.

VII. RELATED WORK

Anonymity systems fall into one of two general categories:
systems that provide low-latency communication and those
that protect against trafﬁc analysis attacks by a global network
adversary.

Aqua [53], Crowds [71], LAP [48], ShadowWalker [59],
Tarzan [31], and Tor [27] belong to the ﬁrst category of
systems: they provide an anonymous proxy for real-time Web
browsing, but they do not protect against an adversary who
controls the network, many of the clients, and some of the
nodes on a victim’s path through the network. Even providing
a formal deﬁnition of anonymity for low-latency systems is

2 We assume here that scaling the number of machines by a factor of k
increases our throughput by a factor of k. This assumption is reasonable given
our workload, since the processing of write requests is an embarrassingly
parallel task.

challenging [49] and such deﬁnitions typically do not capture
the need to protect against timing attacks.

Even so, it would be possible to combine Tor (or another
low-latency anonymizing proxy) and Riposte to build a “best
of both” anonymity system: clients would submit their write
requests to the Riposte servers via the Tor network. In this
conﬁguration, even if all of the Riposte servers colluded, they
could not learn which user wrote which message without also
breaking the anonymity of the Tor network.

David Chaum’s “cascade” mix networks were one of the
ﬁrst systems devised with the speciﬁc goal of defending
against trafﬁc-analysis attacks [15]. Since then, there have
been a number of mix-net-style systems proposed, many of
which explicitly weaken their protections against a near omni-
present adversary [74] to improve prospects for practical
usability (i.e., for email
trafﬁc) [23]. In contrast, Riposte
attempts to provide very strong anonymity guarantees at the
price of usability for interactive applications.

E-voting systems (also called “veriﬁable shufﬂes”) achieve
the sort of privacy properties that Riposte offers, and some sys-
tems even provide stronger voting-speciﬁc guarantees (receipt-
freeness, proportionality, etc.), though most e-voting systems
cannot provide the forward security property that Riposte
offers (Section III-C) [1], [18], [32], [45], [46], [65], [69].

In a typical e-voting system, voters submit their encrypted
ballots to a few trustees, who collectively shufﬂe and decrypt
them. While it is possible to repurpose e-voting systems for
anonymous messaging, they typically require expensive zero-
knowledge proofs or are inefﬁcient when message sizes are
large. Mix-nets that do not use zero-knowledge proofs of
correctness typically do not provide privacy in the face of
active attacks by a subset of the mix servers.

For example, the veriﬁable shufﬂe protocol of Bayer and
Groth [5] is one of the most efﬁcient in the literature. Their
shufﬂe implementation, when used with an anonymity set
of size N, requires 16N group exponentiations per server
and data transfer O(N ). In addition, messages must be small
enough to be encoded in single group elements (a few hundred
√
bytes at most). In contrast, our protocol requires O(L) AES
operations and data transfer O(
L), where L is the size of
the database table. When messages are short and when the
writer/reader ratio is high, the Bayer-Groth mix may be faster
than our system. In contrast, when messages are long and when
the writer/reader ratio is low (i.e., L (cid:14) O(N )), our system is
faster.

Chaum’s Dining Cryptographers network (DC-net) is an
information-theoretically secure anonymous broadcast chan-
nel [14]. A DC-net provides the same strong anonymity
properties as Riposte does, but it requires every user of a DC-
net to participate in every run of the protocol. As the number
of users grows, this quickly becomes impractical.

The Dissent [77] system introduced the idea of using par-
tially trusted servers to make DC-nets practical in distributed
networks. Dissent requires weaker trust assumptions than our
three-server protocol does but
it requires clients to send
O(L) bits to each server per time epoch (compared with

√
L)). Also, excluding a single disruptor in a 1,000-
our O(
client deployment takes over an hour. In contrast, Riposte
can excludes disruptors as fast as it processes write requests
(tens to hundreds per second, depending on the database size).
Recent work [20] uses zero-knowledge techniques to speed up
disruption resistance in Dissent (building on ideas of Golle and
Juels [44]). Unfortunately, these techniques limit the system’s
end to end-throughput end-to-end throughput
to 30 KB/s,
compared with Riposte’s 450+ MB/s.

Herbivore scales DC-nets by dividing users into many small
anonymity sets [38]. Riposte creates a single large anonymity
set, and thus enables every client to be anonymous amongst
the entire set of honest clients.

Our DPF constructions make extensive use of prior work on
private information retrieval (PIR) [16], [17], [33], [37]. Re-
cent work demonstrates that it is possible to make theoretical
PIR fast enough for practical use [25], [26], [40].

Gertner et al. [36] consider symmetric PIR protocols, in
which the servers prevent dishonest clients from learning about
more than a single row of the database per query. The problem
that Gertner et al. consider is, in a way, the dual of the problem
we address in Section V, though their techniques do not appear
to apply directly in our setting.

Ostrovsky and Shoup ﬁrst proposed using PIR protocol as
the basis for writing into a database shared across a set of
servers [67]. However, Ostrovsky and Shoup considered only
the case of a single honest client, who uses the untrusted
database servers for private storage. Since many mutually
distrustful clients use a single Riposte cluster, our protocol
must also handle malicious clients.

Pynchon Gate [72] builds a private point-to-point mes-
saging system from mix-nets and PIR. Clients anonymously
upload messages to email servers using a traditional mix-
net and download messages from the email servers using a
PIR protocol. Riposte could replace the mix-nets used in the
Pynchon Gate system: clients could anonymously write their
messages into the database using Riposte and could privately
read incoming messages using PIR.

VIII. CONCLUSION AND OPEN QUESTIONS

We have presented Riposte, a new system for anonymous
messaging. To the best of our knowledge, Riposte is the ﬁrst
system that simultaneously (1) thwarts trafﬁc analysis attacks,
(2) prevents malicious clients from anonymously disrupting
the system, and (3) enables million-client anonymity set sizes.
We achieve these goals through novel application of pri-
vate information retrieval and secure multiparty computation
techniques. We have demonstrated Riposte’s practicality by
implementing it and evaluating it with anonymity sets of
over two million nodes. This work leaves open a number of
questions for future work, including:
• Does there exist an (s, s− 1)-DPF construction for s > 2
that uses only symmetric-key operations?
• Are there efﬁcient techniques (i.e., using no public-key
primitives) for achieving disruption resistance without the
need for a non-colluding audit server?

335335

• Are there DPF constructions that enable processing write
requests in amortized time o(L), for a length-L database?
With the design and implementation of Riposte, we have
demonstrated that cryptographic techniques can make trafﬁc-
analysis-resistant anonymous microblogging and whistleblow-
ing more practical at Internet scale.

Acknowledgements

We would like to thank Joe Zimmerman and David Wu
for helpful discussions about distributed point functions. We
would like to thank Stephen Schwab and the staff of DeterLab
for giving us access their excellent network testbed. This
work was supported by NSF, an IARPA project provided
via DoI/NBC, a grant from ONR, an NDSEG fellowship,
and by a Google faculty scholarship. Opinions, ﬁndings and
conclusions or recommendations expressed in this material are
those of the author(s) and do not necessarily reﬂect the views
of DARPA or IARPA.

REFERENCES

[1] B. Adida, “Helios: Web-based open-audit voting.” in USENIX Security

[2] B. Adida and D. Wikström, “How to shufﬂe in public,” in Theory of

Symposium, vol. 17, 2008.

Cryptography, 2007.

[3] A. Banerjee and C. Peikert, “New and improved key-homomorphic

pseudorandom functions,” in CRYPTO, 2014.

[4] K. Bauer, D. McCoy, D. Grunwald, T. Kohno, and D. Sicker, “Low-

resource routing attacks against Tor,” in WPES. ACM, 2007.

[5] S. Bayer and J. Groth, “Efﬁcient zero-knowledge argument for correct-

ness of a shufﬂe,” in EUROCRYPT, 2012.

[6] K. Bennhold, “In Britain, guidelines for spying on lawyers and clients,”

New York Times, p. A6, 7 Nov. 2014.

[7] D. J. Bernstein, “The Poly1305-AES message-authentication code,” in

Fast Software Encryption, 2005.

[8] M. Blum, “Coin ﬂipping by telephone a protocol for solving impossible

problems,” ACM SIGACT News, vol. 15, no. 1, pp. 23–27, 1983.

[9] D. Boneh, “The decision Difﬁe-Hellman problem,” in Algorithmic
Number Theory, ser. Lecture Notes in Computer Science, J. P. Buhler,
Ed. Springer, 1998, vol. 1423, pp. 48–63.

[10] D. Boneh, K. Lewi, H. Montgomery, and A. Raghunathan, “Key

homomorphic PRFs and their applications,” in CRYPTO, 2013.

[11] J. Camenisch and M. Stadler, “Proof systems for general statements
about discrete logarithms,” Dept. of Computer Science, ETH Zurich,
Tech. Rep. 260, Mar. 1997.

[12] J. L. Camenisch, “Group signature schemes and payment systems based
on the discrete logarithm problem,” Ph.D. dissertation, Swiss Federal
Institute of Technology Zürich (ETH Zürich), 1998.

[13] R. Canetti, S. Halevi, and J. Katz, “A forward-secure public-key encryp-

tion scheme,” in EUROCRYPT, 2003.

[14] D. Chaum, “The Dining Cryptographers problem: Unconditional sender
and recipient untraceability,” Journal of Cryptology, pp. 65–75, Jan.
1988.

[15] D. L. Chaum, “Untraceable electronic mail, return addresses, and digital
pseudonyms,” Communications of the ACM, vol. 24, no. 2, pp. 84–90,
1981.

[16] B. Chor and N. Gilboa, “Computationally private information retrieval,”

in STOC. ACM, 1997.

[17] B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan, “Private informa-
tion retrieval,” Journal of the ACM, vol. 45, no. 6, pp. 965–981, 1998.
[18] M. R. Clarkson, S. Chong, and A. C. Myers, “Civitas: A secure voting

system,” Cornell University, Tech. Rep. TR 2007-2081, May 2007.

[19] H. Corrigan-Gibbs and B. Ford, “Dissent: Accountable anonymous

group messaging,” in CCS. ACM, October 2010.

[20] H. Corrigan-Gibbs, D. I. Wolinsky, and B. Ford, “Proactively account-
able anonymous messaging in Verdict,” in USENIX Security Symposium,
2013.

336336

[21] R. Cramer, I. Damgård, and B. Schoenmakers, “Proofs of partial knowl-
edge and simpliﬁed design of witness hiding protocols,” in CRYPTO,
1994.

[22] G. Danezis and C. Diaz, “A survey of anonymous communication
channels,” Technical Report MSR-TR-2008-35, Microsoft Research,
Tech. Rep., 2008.

[23] G. Danezis, R. Dingledine, and N. Mathewson, “Mixminion: Design of a
IEEE,

type III anonymous remailer protocol,” in Security and Privacy.
2003.

[24] G. Danezis and A. Serjantov, “Statistical disclosure or intersection
attacks on anonymity systems,” in Information Hiding Workshop, May
2004.

[25] D. Demmler, A. Herzberg, and T. Schneider, “RAID-PIR: Practical

multi-server PIR,” in WPES, 2014.

[26] C. Devet and I. Goldberg, “The best of both worlds: Combining
information-theoretic and computational pir for communication efﬁ-
ciency,” in PETS, July 2014.

[27] R. Dingledine, N. Mathewson, and P. Syverson, “Tor: The second-
generation onion router,” in USENIX Security Symposium, Aug. 2004.
[28] M. Edman and B. Yener, “On anonymity in an electronic society:
A survey of anonymous communication systems,” ACM Computing
Surveys, vol. 42, no. 1, p. 5, 2009.

[29] R. Fagin, M. Naor, and P. Winkler, “Comparing information without
leaking it,” Communications of the ACM, vol. 39, no. 5, pp. 77–85,
1996.

[30] U. Feige, A. Fiat, and A. Shamir, “Zero-knowledge proofs of identity,”

Journal of Cryptology, vol. 1, no. 2, pp. 77–94, 1988.

[31] M. J. Freedman and R. Morris, “Tarzan: A peer-to-peer anonymizing

network layer,” in CCS. ACM, 2002.

[32] J. Furukawa, “Efﬁcient, veriﬁable shufﬂe decryption and its requirement

of unlinkability,” in PKC, 2004.

[33] W. Gasarch, “A survey on private information retrieval,” in Bulletin of

the EATCS, 2004.

[34] B. Gellman and A. Soltani, “NSA inﬁltrates links to Yahoo, Google data
centers worldwide, Snowden documents say,” Washington Post, Oct. 30
2013.

[35] B. Gellman, J. Tate, and A. Soltani, “In NSA-intercepted data, those not
targeted far outnumber the foreigners who are,” Washington Post, 5 Jul.
2014.

[36] Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin, “Protecting data

privacy in private information retrieval schemes,” in STOC, 1998.

[37] N. Gilboa and Y. Ishai, “Distributed point functions and their applica-

tions,” in EUROCRYPT, 2014.

[38] S. Goel, M. Robson, M. Polte, and E. Sirer, “Herbivore: A scalable and
efﬁcient protocol for anonymous communication,” Cornell University,
Tech. Rep., 2003.

[39] V. Goel, “Government push for Yahoo’s user data set stage for broad

surveillance,” New York Times, p. B3, 7 Sept. 2014.

[40] I. Goldberg, “Improving the robustness of private information retrieval,”

in Security and Privacy.

IEEE, 2007.

[41] O. Goldreich, S. Micali, and A. Wigderson, “How to play any mental

game,” in STOC. ACM, 1987.

[42] ——, “Proofs that yield nothing but their validity or all languages in
NP have zero-knowledge proof systems,” Journal of the ACM, vol. 38,
no. 3, pp. 690–728, 1991.

[43] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge complexity
of interactive proof systems,” SIAM Journal on computing, vol. 18, no. 1,
pp. 186–208, 1989.

[44] P. Golle and A. Juels, “Dining cryptographers revisited,” in EURO-

CRYPT, 2004.

2007.

[45] J. Groth, “A veriﬁable secret shufﬂe of homomorphic encryptions,”

Journal of Cryptology, vol. 23, no. 4, pp. 546–579, 2010.

[46] J. Groth and S. Lu, “Veriﬁable shufﬂe of large size ciphertexts,” in PKC,

[47] J. Håstad, R. Impagliazzo, L. A. Levin, and M. Luby, “A pseudorandom
generator from any one-way function,” SIAM Journal on Computing,
vol. 28, no. 4, pp. 1364–1396, 1999.

[48] H.-C. Hsiao, T.-J. Kim, A. Perrig, A. Yamada, S. C. Nelson, M. Gruteser,
and W. Meng, “LAP: Lightweight anonymity and privacy,” in Security
and Privacy.
Johnson,

[49] A.

analysis

IEEE, May 2012.
“Design
protocols,” Ph.D.

and

of

anonymous-
dissertation, Yale University,

efﬁcient

communication
Dec. 2009.

[50] C. Kaufman, P. Hoffman, Y. Nir, P. Eronen, and K. T, “RFC7296:

Internet key exchange protocol version 2 (IKEv2),” Oct. 2014.

[51] D. Kedogan, D. Agrawal, and S. Penz, “Limits of anonymity in open

environments,” in Information Hiding, 2003.

[52] R. Krikorian, “New Tweets per second record, and how!” https://blog.

twitter.com/2013/new-tweets-per-second-record-and-how, Aug. 2013.

[53] S. Le Blond, D. Choffnes, W. Zhou, P. Druschel, H. Ballani, and P. Fran-
cis, “Towards efﬁcient trafﬁc-analysis resistant anonymity networks,” in
SIGCOMM. ACM, 2013.

[54] B. Liskov and J. Cowling, “Viewstamped replication revisited,” MIT

CSAIL, Tech. Rep. MIT-CSAIL-TR-2012-021, Jul. 2013.

[55] M. G. Luby, M. Luby, and A. Wigderson, Pairwise independence and

derandomization. Now Publishers Inc, 2006.

[56] N. Mathewson and R. Dingledine, “Practical trafﬁc analysis: Extending
and resisting statistical disclosure,” in Privacy Enhancing Technologies,
2005.

[57] V. S. Miller, “Use of elliptic curves in cryptography,” in CRYPTO, 1986.
[58] J. Mirkovic and T. Benzel, “Teaching cybersecurity with DeterLab,”

Security & Privacy, vol. 10, no. 1, 2012.

[59] P. Mittal and N. Borisov, “ShadowWalker: Peer-to-peer anonymous
communication using redundant structured topologies,” in CCS. ACM,
November 2009.

[60] S. J. Murdoch and G. Danezis, “Low-cost trafﬁc analysis of Tor,” in

Security and Privacy.

IEEE, 2005.

[61] S. J. Murdoch and P. Zieli´nski, “Sampled trafﬁc analysis by Internet-

exchange-level adversaries,” in PETS, June 2007.

[62] E. Nakashima and B. Gellman, “Court gave NSA broad leeway in

surveillance, documents show,” Washington Post, 30 Jun. 2014.

[63] M. Naor, B. Pinkas, and O. Reingold, “Distributed pseudo-random

functions and KDCs,” in EUROCRYPT, 1999.

[64] National Institute of Standards and Technology, “Speciﬁcation for the
advanced encryption standard (AES),” Federal Information Processing
Standards Publication 197, Nov. 2001.

[65] C. A. Neff, “A veriﬁable secret shufﬂe and its application to e-voting,”

in CCS. ACM, 2001.

[66] D. Ongaro and J. Ousterhout, “In search of an understandable consensus

algorithm,” in ATC. USENIX, Jun. 2014.

[67] R. Ostrovsky and V. Shoup, “Private information storage,” in STOC,

1997.

[68] T. P. Pedersen, “Non-interactive and information-theoretic secure veriﬁ-

able secret sharing,” in CRYPTO, 1992.

[69] M. O. Rabin and R. L. Rivest, “Efﬁcient end to end veriﬁable electronic
voting employing split value representations,” in EVOTE 2014, Aug.
2014.

[70] C. Rackoff and D. R. Simon, “Non-interactive zero-knowledge proof of

knowledge and chosen ciphertext attack,” in CRYPTO, 1992.

[71] M. K. Reiter and A. D. Rubin, “Crowds: Anonymity for Web transac-
tions,” ACM Transactions on Information and System Security, vol. 1,
no. 1, pp. 66–92, 1998.

[72] L. Sassaman, B. Cohen, and N. Mathewson, “The Pynchon gate: A
secure method of pseudonymous mail retrieval,” in WPES, November
2005.

[73] A. Serjantov, R. Dingledine, and P. Syverson, “From a trickle to a ﬂood:

Active attacks on several mix types,” in Information Hiding, 2003.

[74] P. Syverson, “Why i’m not an entropist,” in Security Protocols XVII,

2013.

[75] M. Waidner and B. Pﬁtzmann, “The Dining Cryptographers in the disco:
Unconditional sender and recipient untraceability with computationally
secure serviceability,” in EUROCRYPT, Apr. 1989.

[76] D. Wolinsky, E. Syta, and B. Ford, “Hang with your buddies to resist

intersection attacks,” in CCS, November 2013.

[77] D. I. Wolinsky, H. Corrigan-Gibbs, A. Johnson, and B. Ford, “Dissent
in numbers: Making strong anonymity scale,” in 10th OSDI. USENIX,
Oct. 2012.

[78] A. C. Yao, “Protocols for secure computations,” in FOCS.

IEEE, 1982.

APPENDIX

A. Deﬁnition of Write Privacy

An (s, t)-write-private database scheme consists of the

following three (possibly randomized) algorithms:

337337

Write((cid:2), m) → (w(0), . . . , w(s−1)). Clients use the Write
functionality to generate the write request queries sent to
the s servers. The Write function takes as input a message
m (from some ﬁnite message space) and an integer (cid:2) and
produces a set of s write requests—one per server.
Update(σ, w) → σ(cid:2). Servers use the Update functionality to
process incoming write requests. The Update function
takes as input a server’s internal state σ, a write request
w, and outputs the updated state of the server σ(cid:2).
Reveal(σ0, . . . , σs−1) → D. At the end of the time epoch,
servers use the Reveal functionality to recover the contents
of the database. The Reveal function takes as input the
set of states from each of the s servers and produces the
plaintext database contents D.

We deﬁne the write-privacy property using the following
security game, played between the adversary (who statically
corrupts up to t servers and all but
two clients) and a
challenger.

1) In the ﬁrst step, the adversary performs the following
actions:
• The adversary selects a subset As ⊆ {0, . . . , s − 1}
|As| ≤ t. The set As
of the servers, such that
represents the set of adversarial servers. Let the set
Hs = {0, . . . , s − 1} \ As represent the set of honest
servers.
• The adversary selects a set of clients Hc ⊆ {0, . . . , n−
1}, such that |Hc| ≥ 2, representing the set of honest
clients. The adversary selects one message-location
pair per honest client:

M = {(i, mi, (cid:2)i) | i ∈ Hc}

The adversary sends As and M to the challenger.

2) In the second step, the challenger responds to the adver-
sary:
• For each (i, mi, (cid:2)i) ∈ M, the challenger generates a
write request:
(w(0)

) ← Write((cid:2)i, mi)

, . . . , w(s−1)

i

i

The set of shares of the ith write request revealed to
i }j∈AS .
the malicious servers is Wi = {w(j)
In the next steps of the game,
the challenger will
randomly reorder the honest clients’ write requests.
The challenger should learn nothing about which client
wrote what, despite all the information at its disposal.
• The challenger then samples a random permutation π
over {0, . . . ,|Hc| − 1}. The challenger sends the fol-
lowing set of write requests to the adversary, permuted
according to π:

(cid:16)Wπ(0), Wπ(1), . . . , Wπ(|Hc|−1)(cid:17)

3) For each client i in {0, . . . , n − 1} \ Hc, the adversary
computes a write request (w(0)
) (possibly
according to some malicious strategy) and sends the set
of these write requests to the challenger.

, . . . , w(s−1)

i

i

4) • For each server j ∈ Hs,

the challenger computes
the server’s ﬁnal state σj by running the Update
functionality on each of the n client write requests in
order. Let S = {(j, σj) | j ∈ Hs} be the set of states
of the honest servers.
• The challenger samples a bit b ←R {0, 1}. If b = 0,
the challenger send (S, π) to the adversary. Otherwise,
the challenger samples a fresh permutation π∗ on Hc
and sets (S, π∗

) to the adversary.

5) The adversary makes a guess b(cid:2) for the value of b.
The adversary wins the game if b = b(cid:2). We deﬁne the
adversary’s advantage as | Pr[b = b(cid:2)
] − 1/2|. The scheme
maintains (s, t)-write privacy if no efﬁcient adversary wins the
game with non-negligible advantage (in the implicit security
parameter).

B. Correctness Proof for (2, 1)-DPF

This appendix proves correctness of the distributed point
construction of Section IV-C. For the scheme to be correct, it
must be that, for (kA, kB) ← Gen((cid:2), m), for all (cid:2)(cid:2) ∈ ZL:

Eval(kA, (cid:2)(cid:2)

) + Eval(kB, (cid:2)(cid:2)

) = P(cid:2),m((cid:2)(cid:2)

).

Let ((cid:2)x, (cid:2)y) be the tuple in Zx × Zy representing location (cid:2)
x, (cid:2)(cid:2)
and let ((cid:2)(cid:2)
y) be the tuple representing (cid:2)(cid:2). Let:
A ← Eval(kA, (cid:2)(cid:2)
m(cid:2)

B ← Eval(kB, (cid:2)(cid:2)
m(cid:2)

).

)

x, the seeds sA[(cid:2)(cid:2)

We use a case analysis to show that the left-hand side of the
equation above equals P(cid:2),m for all (cid:2)(cid:2):
x. When (cid:2)x (cid:8)= (cid:2)(cid:2)
Case I: (cid:2)x (cid:8)= (cid:2)(cid:2)
x] and sB[(cid:2)(cid:2)
x]
are equal, so gA = gB. Similarly bA[(cid:2)(cid:2)
x] = bB[(cid:2)(cid:2)
x]. The
A will be gA[(cid:2)(cid:2)
y], The output m(cid:2)
output m(cid:2)
x]v[(cid:2)(cid:2)
y] + bA[(cid:2)(cid:2)
B
will be identical to m(cid:2)
A. Since the ﬁeld is a binary ﬁeld,
adding a value to itself results in the zero element, so the
sum m(cid:2)
sA[(cid:2)(cid:2)
bA[(cid:2)(cid:2)
gB[(cid:2)(cid:2)
applies when bA[(cid:2)(cid:2)

B will be zero as desired.
x and (cid:2)y (cid:8)= (cid:2)(cid:2)
x, the seeds
x] are not equal, so gA (cid:8)= gB. Similarly
x]. When (cid:2)y (cid:8)= (cid:2)(cid:2)
y] +
x] = 0 (an analogous argument

x] and sB[(cid:2)(cid:2)
x] (cid:8)= bB[(cid:2)(cid:2)
y]. Assume bA[(cid:2)(cid:2)

A + m(cid:2)
Case II: (cid:2)x = (cid:2)(cid:2)

y. When (cid:2)x = (cid:2)(cid:2)

y] = gA[(cid:2)(cid:2)

x] = 1), then:

y, v[(cid:2)(cid:2)

m(cid:2)
A + m(cid:2)

B = gA[(cid:2)(cid:2)
x and (cid:2)y = (cid:2)(cid:2)

B will then be:
y] + gB[(cid:2)(cid:2)
y. This is the same as Case II,
y, so the sum

y] = m when (cid:2)y = (cid:2)(cid:2)

x] + v[(cid:2)(cid:2)

y] = 0.

Case III: (cid:2)x = (cid:2)(cid:2)

except that (m · e(cid:2)y )[(cid:2)(cid:2)
m(cid:2)
A + m(cid:2)

B = m, as desired.

v[(cid:2)(cid:2)
The sum m(cid:2)

y] = (m · e(cid:2)x )[(cid:2)(cid:2)
A + m(cid:2)

y] + gA[(cid:2)(cid:2)

y] + gB[(cid:2)(cid:2)
y].

everywhere. In this case, the test vectors that servers A and
B send to the audit server will be equal everywhere and the
audit server will always output “0.”

Next, consider the case when the v vectors differ at k + 1
positions, where k > 0. The soundness error k is equal to
the probability that, for every index i(cid:2) where the vectors are
unequal (except one), there is a hash collision. Since the prob-
ability of many hash collisions is bounded by the probability
of a single hash collision, k ≤ 1. The probability, 1, of a
single collision we know from the properties of a pairwise-
independent hash function family, where each member of the
family has range R:

1 = Pr[hi ←R H : hi(vA[i]) = hi(vB[i])] ≤ 1|R|2

The overall soundness error is then at most  ≤ 1/|R|. Since
|R| (the output space of the hash function) is exponentially
large in the security parameter, this probability is negligible.

Completeness. If the vectors vA and vB differ in exactly one
position, the audit server must output “1” with overwhelming
probability. Since the audit server only outputs “1” if exactly
one element of the test vectors is equal, whenever there is at
least one collision in the hash function, the protocol will return
an incorrect result. The probability of this event happening is
negligible, however, as long as the length of the vectors is
polynomial in the security parameter.

Zero Knowledge. The zero-knowledge property need only
hold when the vectors differ at exactly one index. In this case,
servers A and B receive a single bit from the audit server (a
“1”), so the simulation is trivial for the database servers. Thus,
we only need to prove that the zero-knowledge property holds
for the audit server.

Whenever the vectors differ at exactly one position the audit
server can also simulate its view of the protocol. The audit
server simulator runs by picking length-n vectors of random
elements elements in the range of the pairwise hash function
family H subject to the constraint that the vectors are equal
at a random index i(cid:2) ∈ Zn. The simulator outputs the two
vectors as the vectors received from servers A and B.
The simulation is valid because H is a pairwise-independent
hash function family. Let H be a family of hash function hi :
D → R Then for all x, y ∈ D, by deﬁnition of pairwise
independence:

Pr[h ←R H : h(x) = h(y)] ≤ 1
R

C. Proofs for the AlmostEqual Protocol

This appendix proves security of the AlmostEqual protocol

of Section V-A.
Soundness. We compute the probability that an honest audit
server will output “1” when the vectors are not equal at exactly
one index. First, consider the case when the v vectors are equal

This property implies that the two vectors sent to the audit
server leak no information about the v vectors, since an honest
client’s v vector will be independent of the choice of hash
function h, and so every every element of the vectors sent
to the audit servers takes on every value in R with equal
probability. As in the real protocol, the simulated vectors are
equal at one random index.

338338

