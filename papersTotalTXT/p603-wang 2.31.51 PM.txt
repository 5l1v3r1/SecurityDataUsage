On the Security and Usability of Segment-based
Visual Cryptographic Authentication Protocols

Tianhao Wang, Huangyi Ge, Omar Chowdhury, Hemanta K. Maji, Ninghui Li

Department of Computer Science

{tianhaowang, geh, ochowdhu}@purdue.edu, {hmaji, ninghui}@cs.purdue.edu

Purdue University

West Lafayette, IN, USA

ABSTRACT
Visual cryptography has been applied to design human com-
putable authentication protocols.
In such a protocol, the
user and the server share a secret key in the form of an im-
age printed on a transparent medium, which the user super-
imposes on server-generated image challenges, and visually
decodes a response code from the image. An example of
such protocols is PassWindow, an award-winning commercial
product. We study the security and usability of segment-
based visual cryptographic authentication protocols (SVAPs),
which include PassWindow as a particular case. In an SVAP,
the images consist of segments and are thus structured. Our
overall ﬁndings are negative. We introduce two attacks that
together can break all SVAPs we considered in the paper.
Moreover, our attacks exploit fundamental weaknesses of
SVAPs that appear diﬃcult to ﬁx. We have also evaluated
the usability of diﬀerent SVAPs and found that the protocol
that oﬀers the best security has the poorest usability.

Keywords
Visual Cryptography; User Authentication; Attack

1.

INTRODUCTION

Authentication protocols allow a user to identify herself to
a centralized server while ensuring that no adversary, with-
out possession of the secret, can impersonate her. Human-
computable authentication protocols rely on human’s cogni-
tive capability (and, often memory) to carry out the authen-
tication process. These protocols do not rely on the trust-
worthiness of the user’s computing device and hence hold the
promise of providing moderately secure and usable second-
factor authentication mechanisms. However, most human-
computable authentication protocols are either tough to use
or very insecure.

The concept of visual cryptography (VC) [26, 27] oﬀers
the potential of designing such human-computable, second-
factor authentication protocols. VC is a more human intelli-
gible principle of cryptographic protocol design that involves

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978417

no end-user cryptographic computations and has, subse-
quently, inspired a wide array of cryptographic applications
[30, 20, 5, 14]. A typical VC-based human-computable au-
thentication protocol may proceed as follows. The user and
the server share a secret key in the form of an image printed
on a transparent key card, e.g., a special credit card with a
transparent portion. One authentication session consists of
one or more rounds. In each round, an image of challenge
frame is shown to the user on a display (e.g., a phone or a
computer); then the user overlays her key card on top of the
challenge frame to obtain a new superimposed image, inter-
prets the image visually and replies back with a response.

Since VC-based protocols use an image card, it can store
a high-entropy key that the user does not need to remember;
this opens up the possibility of designing a secure and usable
scheme. A prominent representative example of such pro-
tocols is PassWindow [28, 4], a commercial product available
from a startup company, which won the Wall Street Journal
Asian Innovation Awards [33]. The design of PassWindow re-
lies on the visual decoding of digits represented in 7-segment
LED-style and is signiﬁcantly more user-friendly than other
human-computable cryptographic authentication proposals
in the research literature.

In this paper, we study the security and usability of
segment-based visual cryptographic authentication protocols
(SVAPs), which includes PassWindow as a particular case. In
SVAPs, the images are segment-based and structured. More
speciﬁcally, each frame of image consists of segments such
that a group of adjacent segments can be used to display a
symbol from some pre-deﬁned set, e.g., digits or letters. We
call each such group which can display symbols a position.
The security expectation from SVAPs is that an eavesdrop-
ping attacker (e.g., a malware on the client device) who in-
tercepts the challenge-response pairs belonging to multiple
authentication sessions cannot impersonate the user. Our
overall ﬁndings are negative. We introduce two classes
of attacks that together can break all SVAPs we consider.
While some designs (such as having the response computed
from multiple displayed digits) can slightly improve security,
they hurt usability. Furthermore, our attacks are applicable
so long as the images are segment-based and symbol-based.

Contributions. To conduct a systematic study of SVAPs,
we introduce a framework and a security deﬁnition for them.
Our security deﬁnition is inspired by [25]: An attack algo-
rithm ((cid:96), p)-breaks an SVAP if it can successfully respond to a
new challenge with probability p on average after observing
a transcript of (cid:96) successful authentication sessions.

We generalize PassWindow to the class of uni-symbol SVAPs,

603in which each challenge frame can yield at most one symbol
(e.g., a digit for PassWindow). The security of uni-symbol
SVAPs relies on the assumption that an adversary is uncer-
tain which position in the frame displays a response symbol.
However, through experiences of breaking and ﬁxing Pass-
Window and similar protocols, we gained the following key in-
sight: Knowing that only one symbol s ∈ Σ is displayed in a
frame yields the deﬁnite information that no other symbol in
Σ is displayed at any position of the frame. This information
can be exploited to reduce the plausible key universe with-
out any expensive searching, and applies to all uni-symbol
SVAPs.

We develop Search, an attack targeting uni-symbol SVAPs.
Search hinges on the following three key ideas. (1) Given a
transcript of challenge-response pairs, we can use the above
insight to eliminate keys that are inconsistent with the ob-
served transcript. (2) We can perform a bounded search to
exploit non-deﬁnite information leaked through challenge-
response pairs. After the key universe is reduced signiﬁ-
cantly by exploiting deﬁnite information, such a search be-
comes highly eﬀective. (3) It is not necessary to recover the
key fully for the purpose of computing a correct response to
challenges. We ﬁnd that, while PassWindow has been found
to oﬀer strong security in previous studies [28, 1], and such
analysis results have been accepted at face value [11], Search
is extremely eﬀective against our reconstruction of PassWin-
dow, as well as other uni-symbol SVAPs we have developed.
To summarize, uni-symbol SVAPs’ fundamental weakness is
that each challenge frame encodes at most one symbol.

To overcome this fundamental weakness of uni-symbol
SVAP, we design multi-symbol SVAPs where each challenge
frame displays more than one symbol, and the user applies
a transformation on the symbols to obtain the response of
that frame. Given a frame that encodes two digits d1 and d2,
we considered two ways to generate the response code: (a)
(d1 + d2) mod 10 (hashing based double-digit SVAP, in short,
HDD) and (b) either d1 or d2 is acceptable (either of double-
digit SVAP, in short, EDD). We also investigated a general-
ization of HDD to three digits which we identify as hashing
based triple digit SVAP (HTD). EDD and HTD leaks no deﬁnite
information, and Search is totally ineﬀective against them.
We introduce the SolveLP attack that works for both uni-
and multi- symbol SVAPs. This attack encodes the imperson-
ation attack as a constraint satisfaction problem, where each
variable encodes whether the key contains a particular pat-
tern in a given position. However, oﬀ-the-shelf solvers are
found to be ineﬀective at solving the resulting constraints.
We thus developed an algorithm for solving them, exploiting
the linear programming relaxation technique. That is, in-
stead of assigning binary values to the variables, we consider
a relaxation that assigns fractional values to them, and in-
terpret a larger value as more likely to be 1 (cf., the random-
ized rounding technique [29]). We further apply the iterative
multiplicative update technique to solve the resulting linear
programming problem. Our experimental evaluation shows
that all the newly introduced multi-symbol SVAPs are sus-
ceptible to this attack, although they do oﬀer higher security
than uni-symbol SVAPs.

Our security analysis exposes a fundamental limitation of
SVAPs, that is, one can attain a compact representation of
the partial knowledge about the key based on each position
independently. SolveLP takes advantage of the compact rep-
resentation by treating whether a speciﬁc pattern appears in

Figure 1: An example of key, challenge and com-
bined frames for an SVAP authentication round.

Figure 2: Visual representation of PassWindow’s Σ.

a given position of the key as a variable to be solved. Any
authentication protocol whose human-computable transfor-
mation for deriving the response code from the displayed
symbols is expressible as constraints is vulnerable to this
attack.

Finally, we also carried out a user study on Amazon Me-
chanical Turk service to evaluate the usability of some of the
concrete SVAPs we have analyzed for security. Some repre-
sentative notable ﬁndings of our usability analysis are as
follows.
(1) EDD performs the best based on completion
time and accuracy. However, EDD is very insecure against
SolveLP. (2) The computation required for HDD and HTD im-
poses signiﬁcant cognitive overhead for the users, and HTD,
which is the most secure protocol, has signiﬁcantly worse us-
ability than other protocols. (3) HDD oﬀers stronger security
than PassWindow with similar usability. (4) For EDD, conven-
tional wisdom indicates that the chance of the left digit get-
ting picked in higher, au contraire, our study demonstrates
that the probability of the user picking the left or the right
digit is roughly equal.
Roadmap. The paper is organized as follows. We present
our framework, the adversarial model we consider, and the
security deﬁnition for SVAPs in Section 2. Section 3 describes
the concrete uni- and multi-symbol SVAPs we analyze in this
paper.
In Sections 4 and 5, we present the Search and
SolveLP attack strategies, respectively. Sections 6 and 7
present the experimental results concerning the SVAP secu-
rity and usability, respectively. We discuss related work in
Section 8 and conclude with Section 9.

2. A FRAMEWORK FOR SVAPS

In visual cryptographic authentication protocols, the user
and the server share a secret key in the form of an image
printed on a transparent key card, which the user superim-
poses on server-generated challenge images, interprets the
resulting image visually, and replies back with appropriate
responses.
In this paper, we focus on Segment-based Vi-
sual Authentication Protocols (in short, SVAPs), where each
frame of (key or challenge) image consists of segments and
is structured so that a group of adjacent segments can en-
code a symbol. See Figure 1 for an example of the visual
key/secret, challenge, and the result of superimposing the
key on top of the challenge.

In this section, we ﬁrst give a general framework for SVAPs,
then give the adversarial model and the security deﬁnition
for SVAPs. We use PassWindow as an example to illustrate the
framework.
2.1 The Framework
SVAP Primitives. Each SVAP is based on a Visual Primi-

keychallengewhat user sees604Figure 3: Example of visual component of an SVAP

Figure 4: An example key and challenge-response.
The response should be the sequence 8596, encoded
in frames 4, 5, 6, 7.

tive, which is speciﬁed by a tuple (cid:104)Σ, image, code(cid:105). Σ gives
the set of all symbols used in the SVAP; it can be a set of
digits, a set of letters, or some other set of symbols. The
function image maps a bitstring to a segment-based image;
each segment is turned on (or opaque) if and only if its cor-
responding bit is ‘1’. For example, Figure 3 shows how a
21-bit string is visualized as an image with three 7-segment
groups. The function code maps a bitstring to a multisets
over Σ; e.g., code of the bitstring in Figure 3 yields {2, 2}.
In SVAPs, the images are created by mapping each bit to
a segment; and a group of adjacent segments may display
a symbol. We call each such group where a symbol can be
displayed a position. Multiple positions may overlap with
each other. The number of positions is considered a security
parameter of an SVAP. Note that overlaying one transparent
image on top of the other corresponds to the bit-by-bit ‘or’
operation of the bitstrings.
In PassWindow, Σ = {P, 0, 2, 3, . . . , 9}, and their visual rep-
resentation is given in Figure 2. The letter “P” is used to
warn users about the upcoming symbols. The digit “1” is not
used because it is shown when just 2 out of the 7 segments
are on, and this can leak a signiﬁcant amount of information
and also imposes restrictions on the set of valid challenges
and keys.
SVAPs. An SVAP AV is a tuple (cid:104)PV, α, λ, keyGen,
challengeGen, response(cid:105) in which PV states the SVAP primitive
the protocol is based on, α denotes the number of rounds,
i.e., the number of challenge frames that are shown to the
user during an authentication session, λ denotes the security
parameter, and the other components are explained below.

The function keyGen : 1λ → {0, 1}p(λ) takes as input the
security parameter λ and generates a secret key x of length
p(λ). For PassWindow, the security parameter λ speciﬁes the
number of positions that a digit can be shown. Moreover,
two adjacent positions share a common vertical line. Thus,
a frame of λ positions consist of p(λ) = 5λ + 2 segments.
Figure 4 gives us an example of PassWindow with λ = 8.
The function challengeGen takes as input a key x, and re-
turns a sequence of α challenges frames y = (cid:104)y1, y2, . . . , yα(cid:105).
Challenges are represented in bitstrings.

The function response deﬁnes what are considered as valid
responses when given a key x and a challenge y. Any
response r in the set of valid responses will be accepted.
In Figure 4, the response function will return the response
r = 8596.
SVAP Authentication Process. An SVAP is used in the
following way. There are two stakeholders, namely, the
server (denoted by Server) and the user who wants to au-
thenticate herself to Server (denoted by User). The inter-
action proceeds as follows.
[Initialization.]

• Server chooses an SVAP.

[User registration. (Over a secure channel.)]

• User sends name u to Server.
• Server generates a secret visual key x using the keyGen

function, x $← keyGen(1λ).

• Server stores (cid:104)u, x(cid:105) and sends the image image(x)

(likely in the form of a transparency) to User.

[User authentication.]

• User sends name u to Server.
• Server looks up (cid:104)u, x(cid:105), generates challenge frames
y $← challengeGen(x), and sends the following chal-
lenge frames image(y1),. . . , image(yα) to User.
• User overlays the key transparency on top of each of
the challenge images, identiﬁes the symbols di’s, com-
putes the response r, and sends r to Server.
• Server accepts the user’s response and successfully
completes the authentication process if and only if
r ∈ response(x, y).

2.2 Threat Model and Security Deﬁnition

We consider an eavesdropping adversary who can eaves-
drop on the communications between User and Server, i.e.,
recording the challenges, the responses sent by the user, and
the result of whether the responses are correct or not. In
this paper, we limit ourselves to an eavesdropping adversary
because an eavesdropping adversary is suﬃcient for breaking
the security of the concrete SVAPs we discuss here. The ob-
jective of the attacker is to successfully impersonate a user,
by correctly answering the challenges in one session, without
possessing the secret key. We adapt the security deﬁnition
from [25] as follows.

Definition 1

(((cid:96), p)-break). We say that an algo-
rithm ((cid:96), p)-breaks an SVAP if and only if when given (cid:96) match-
ing challenge-response pairs and an additional challenge, the
algorithm’s response to the additional challenge is accepted
with probability p on average.

no digitdigit: 2digit: 2123456710111011234567001101012345671011101keychallengewhat user seesframe 3: Pframe 4: 8frame 5: 5frame 6: 9frame 7: 6position 2......605If an SVAP is (0, p) breakable, then an adversary without
eavesdropping ability can impersonate a user with proba-
bility p on average in one attempt. When p is above some
acceptable threshold, this implies that the protocol is ex-
tremely insecure.

3. DESIGN OF SVAPS

We now present two classes of concrete SVAPs which we
call the uni-symbol SVAPs and multi-symbol SVAPs. We as-
sume seven-segment LED-style images for displaying digits
are used, as in PassWindow.

3.1 Uni-Symbol SVAPs

In this class of protocols, each frame shows at most one
symbol. We categorize these protocols along three design
dimensions.

3.1.1 Design Dimensions

1. Noisy Frames or Not. In PassWindow, each authen-
tication session consists of α = 15 frames; however, only
4 of them displays a digit, and the 4-digit sequence is the
response. These 15 frames are displayed in an animation
where each frame displays for around 2 seconds. The an-
imated image loops back to the ﬁrst challenge frame after
the last frame is displayed. A frame encoding the symbol
P alerts the users that the next 4 frames encode the digits.
The other 10 frames do not display any digit and are known
as noisy frames.

We call this design the NSD (for Noisy-frame Single
Digit) scheme, and the other design that does not use noisy
frames and simply shows 4 digit-encoding frames with the
response being the corresponding 4-digit sequence the BSD
(for Basic Single Digit) scheme. In BSD, the 4 challenge
frames can be shown one by one, with each new frame dis-
played after another digit is entered. This way, users can
respond at their pace.

The use of noisy frames aims at increasing the uncertainty
for the adversary regarding which frames encode which sym-
bols. It comes at the usability cost of increasing the time
it takes to complete an authentication session and is likely
to introduce some stress since users need to decode visually
under time pressure. In Section 6 we shall show that using
noisy frames decreases the level of security since the noisy
frames leak additional information.

2. Key and Challenge Generation Algorithms. We
consider two kinds of generation algorithms.
In the ﬁrst
kind, keys and challenges are generated by randomly decid-
ing whether each segment should be turned on or oﬀ. In the
next kind, keys and challenges are generated by randomly
selecting a 7-segment pattern for each position.
In both
cases, additional checks are needed to ensure that the key
does not already encode a digit, and the challenges when
overlaid with the key, resulting in acceptable images (e.g.,
not encoding two digits in one frame). In this paper, unless
explicitly mentioned, the protocols use a random pattern-
based algorithms.

3. Shared Edges or Separate Columns. In PassWin-
dow, the two adjacent 7-segment positions share a common
vertical edge; we call this design Shared Edges (SE, see See
Figure 4). The alternative design is not to use shared edges

(see Figure 1). In this paper, unless explicitly mentioned,
the protocols do not use shared edges.

As will be shown in the experiment (Section 6), we will
show these three choices’ inﬂuence on security one by one.
Here we describe ﬁve concrete schemes. They each diﬀer
from its previous one in one dimension. The ﬁrst two use
noisy frames, and the latter three do not.
3.1.2 Protocols

1.
[NSD(7%+SE)] Noisy-frame Single Digit ran-
domly displaying 7% Shared Edges. The ﬁrst proto-
col we want to evaluate is PassWindow. NSD (7%+SE) mimics
PassWindow by using 15 frames with 10 noisy frames. It uses
random segment generation algorithms (which produce key
and challenge with a density close to the PassWindow exam-
ples that are publicly available [4, 1]), noisy frames, and
shared edges. Speciﬁcally, the generation algorithms are as
follows:
keyGen. Segments are turned on randomly with a probability
of 25%; further check ensures that no position in the key
displays any symbol.
challengeGen. One ﬁrst chooses a random symbol σ from Σ,
then randomly selects a position p in the challenge frame and
then turns segments in position p on so that σ is displayed in
position p when combined with the key. For the other non-
encoding positions, the segments are turned on randomly
such that the challenge frame has a density of about 7%.
Further sanity checks ensure that no other position encodes
a symbol when overlaid with the key.

[NSD(20%+SE)] Noisy-frame Single Digit ran-
2.
domly displaying 20% Shared Edges. This protocol is
motivated by the observation (from experiments) that chal-
lenge frames in NSD (7%+SE) have limited entropy since the
position on the challenge frame with the most number of
segments turned on is almost certainly the one encoding the
digit. To mitigate this, NSD (20%+SE) displays 20% segments
on the challenge frame.

3. [BSD(20%+SE)] Basic Single Digit randomly dis-
playing 20% Shared Edges. This protocol diﬀers from
NSD (20%+SE) in that it does not use any noisy frame. There-
fore α = 4.

4. [BSD(20%)] Basic Single Digit randomly display-
ing 20% non-shared edges. This protocol diﬀers from
BSD (20%+SE)in that no shared edge is used.

5.
[BSD] Basic Single Digit randomly displaying
valid patterns. BSD diﬀers from BSD (20%)in that the gen-
eration algorithms are based on randomly choosing a pat-
tern, as follows:
keyGen. A valid key pattern is any seven-segment pattern
such that it has between 1 and 6 segments that are turned
on, and it does not display any digit. For each position of
the key, randomly choose a valid key pattern.
challengeGen. A challenge is generated using the following
steps: (1) Randomly choose 4 symbols and 4 patterns such
that each pattern is compatible with at least 3 of the chosen
symbols. A challenge pattern is compatible with a symbol
if there exists a valid key pattern that displays the symbol
when overlaid with the challenge. This step aims to ensure
that even if the symbol is known, there are at least 3 possi-
bilities for its position. (2) Place these 4 patterns randomly
in 4 positions of the frame such that only one position dis-

606plays a symbol when combined with the key. The segments
in all other positions of the challenge frame are oﬀ. This step
is intended to minimize the amount of information leakage,
and will be explained later.
3.2 Multi-Symbol SVAPs

Section 6 demonstrates a fundamental weakness of uni-
symbol SVAPs. The information that a frame displays a par-
ticular symbol entails that all other symbols are not dis-
played at any position. To defeat attacks exploiting this
insight, we introduce multi-symbol SVAPs, where each chal-
lenge frame can generate more than one digit.

We give three concrete protocols, they all use the same
keyGen as in BSD, which is more secure than ones based on
random segments.

1.
[HDD] Hashing-based Double Digit. In HDD, each
challenge frame generates two digits d1 and d2. The corre-
sponding response is the one’s digit of the sum of d1 and d2,
which can be viewed as a simple human computable hashing
function: (d1 + d2) mod 10. This scheme makes it more dif-
ﬁcult to rule out which digit is not displayed when knowing
the response digit. However, because 1 is never displayed,
this protocol still leaks some deterministic information. For
example, if 9 is the response digit, then 8 cannot be displayed
since it would require an 1 to result in 9.
challengeGen. Randomly choose 2 − 9 positions in the chal-
lenge frame and randomly choose the same number of valid
patterns to show in those positions in the following way: (a)
every digit in Σ is compatible with at least 2 patterns; (b)
when combined with the key only 2 of the challenge positions
display digits.

2. [HTD] Hashing-based Triple Digit. HTD eliminates
deterministic leakage of HDD by having each frame display
three digits d1, d2, and d3. The response is the one’s digit
of the sum of d1, d2, and d3, that is: (d1 + d2 + d3) mod 10.
This scheme requires more computation than other schemes,
which may lead to worse usability. The challengeGen for HTD
is similar to HDD, except that each frame in HTD displays 3
digits instead of 2.

3.
[EDD] Either of Double Digit. EDD prevents the
deterministic leakage of BSD without resorting to arithmetic.
A challenge frame superimposed by the visual key induces
two digits d1 and d2; however, instead of responding with
d1 + d2 mod 10, one is asked to respond with either d1 or
d2. This reduces the entropy of each frame by one bit, but
when observing one digit being the response code, any other
digit could still be displayed.

4. BREAKING UNI-SYMBOL SVAPS

We now present Search, an attack against single-symbol
SVAPs. For ease of description, we assume that each posi-
tion that can display a symbol which consists of 7 segments.
The attack equally applies to other settings. The attack
is based on the idea that after observing each successful
authentication session, one can eliminate the keys that are
incompatible with the transcript.

Definition 2

(Compatibility). Given an SVAP AV =
(cid:104)PV, α, λ, keyGen, challengeGen, response(cid:105), and a transcript
of (cid:96) successful authentications, (cid:104)Y = (cid:104)y1, . . . , y(cid:96)(cid:105), R =
(cid:104)r, . . . , r(cid:96)(cid:105)(cid:105), we say that a key x is compatible with the

if and only if ∀i ∈ {1, . . . , (cid:96)}, ri ∈

transcript (Y, R),
response(x, yi).
4.1 Key Universe Representation

One straightforward way to exploit compatibility is to ex-
plicitly maintain the set of all keys that are compatible with
the transcript seen so far. This requires maintaining one
bit for each possible key (whether it is compatible with the
transcript), and is infeasible as the resulting state size will
be linear in the size of the key space (e.g., for NSD (7%+SE),
this is approximately 25λ+2, which is 277 when λ = 15).

Thus the ﬁrst major challenge to exploit compatibility
is to decide how to represent the knowledge about the set
of plausible keys. A natural approach is to maintain for
each segment, whether it must be “on”, must be “oﬀ”, or
is uncertain. Using 2 bits for each segment, this requires
2 × (5λ + 2) bits for NSD (7%+SE), which is 144 bits when
λ = 15. However, this fails to capture information regarding
the inter-relationship among segments. Suppose that from
a challenge/response pair, one can conclude that one of two
segments must be oﬀ (since otherwise it can be decoded into
a diﬀerent response); however, when one maintains informa-
tion about segment independently, one can only record that
this information.

Our solution exploits the structured and segmented nature
of SVAPs. We maintain information regarding each position
consisting of 7 segments. For a 7-segment position, there are
128 patterns, and we use one bit for each pattern, indicat-
ing whether this pattern is plausible in this position. This
requires a total space of 128λ bits, which is 1920 bits when
λ = 15.
More speciﬁcally, we maintain the global plausible pat-
tern set K = (cid:104)Π1, Π2, . . . , Πλ(cid:105), where Πi : {0, 1}7 → {0, 1}
gives the set of compatible patterns in the i’th position.
The downside of K, of course, is that such a representa-
tion loses inter-position information (e.g., if this position
takes this pattern, then another position cannot be that
pattern). However, such information is still preserved in the
transcript, and can be dynamically exploited by searching,
as we explain below.
4.2 Deterministic Reduction of Key Universe
The critical step in breaking an SVAP using searching is to
reduce the global plausible pattern set K = (cid:104)Π1, Π2, . . . , Πλ(cid:105);
this requires deﬁnite knowledge regarding each position.
This led us to discover a fundamental weakness of uni-
symbol SVAPs: Every challenge-response pair leaks deter-
ministic information. For example, knowing that a frame
encodes the digit 4 means that one knows for certain that
none of the other digits is encoded in any position, even if
one does not know where 4 occurs. Thus, using the challenge
pattern at each position, one could reduce the Πi’s.

Because of such information leakage, the random pattern
challenge generation algorithm we introduced for BSD uses
empty positions in the challenge whenever possible. A few
positions must be non-empty, to provide some uncertainty
as to where a response digit is displayed. However, each
new challenge pattern that appears in a position enables
one to eliminate key patterns that when combined with the
challenge pattern would display digits not in the response.
4.3 Search Trees

While the deterministic information can help prune the

607global plausible pattern set K, combining that with search-
ing can help further reﬁne K. The key challenge is to limit
the total space consumed by the search trees to be below
the available resources.

Conceptually, we construct one search tree for each ses-
sion. For each session, there are a number of choices. For
example, for protocols that use noisy frames, the ﬁrst choice
is which frame is the ﬁrst frame that encodes a symbol. In
addition, for each such frame, there is a choice on which
position displays a symbol. In each node n, we store Kn, a
set of plausible keys consistent with choices made to reach
that node. The root node uses the global plausible pattern
set K. Each node starts with the set from its parent, and
uses the current choice made to create the current node to
eliminate keys that are incompatible with this choice. For
example, against NSD schemes, once we have made a choice
about which one among the α = 15 frames displays P , we
know which symbol (if any) each frame encodes; this can
be used to reduce Kn. If a node has Kn = (cid:104)Πn
λ(cid:105)
2 , . . . , Πn
i = ∅, we know the current
such that one of its component Πn
choice is inconsistent with the transcript, as no key pattern
can be used on the i’th position; thus the node can be re-
moved from the tree.

1 , Πn

We construct a tree by maintaining a queue of the frontier
nodes to be expanded. To avoid exhaust the memory, we
will expand a tree only when its frontier consists of no more
than N nodes, where N is set to 1000 in our experiments.
Whenever we expand a node (i.e., making another guess),
we simultaneously add all the children nodes into the search
tree. We know that one of the node in the frontier must be
the correct one; however, we do not know which one it is.
Let F be the forest consisting of all trees. For each tree
T ∈ F , we use leaves(T ) to denote all the leaf nodes of T .
Whether they are fully expanded or not, we observe that the
following equality must hold.

∀T∈F ,∀i∈[1..λ], Πi =

Πn
i

(1)

(cid:91)

n∈leaves(T )

We use the above relation to prune K as follows. Given a tree
T , if Πi contains a pattern not in any leaf node of T , then this
pattern can be removed from Πi. Furthermore, whenever
Πi is reduced, if another tree’s frontier node includes any
pattern not in Πi, then that pattern should be removed.
If any node’s Πi becomes empty, then this node should be
removed, which may cause Πi(cid:48) for some i(cid:48) to be updated.
This process computes a ﬁxpoint that satisﬁes Eq. (1).

We also note that two trees can be combined, by having
a cartesian product of their sets of leaf nodes. The product
of two nodes result in a node with their corresponding Πi’s
intersected.
4.4 Combining Reduction with Searching

Our attack strategy is to combine deterministic reduction
with searching in an integrated fashion. When given (cid:96) > 1
pairs of challenge/response, we ﬁrst reduce K using deter-
ministic information, and then create a search tree for each
authentication session. We iteratively perform the following
until no change is made to any tree or K. (1) Use Eq. (1)
to prune K and the search trees as much as possible. (2)
Expand any search tree if it is not fully expanded and it has
no more than N = 1000 leaf nodes. (3) If there exist two
fully expanded trees in F such that the product of the sizes
of their leaf sets is no more than N(cid:48) = 10000, merge the

two trees by computing the cartesian product of their sets
of leaf nodes. The algorithmic description of search over one
session is shown in Algorithm 1.
4.5 Guessing the Response

The attack strategy described so far is about how to re-
duce K; we now discuss how to respond to a challenge frame.
The basic strategy is for each symbol, ﬁnd whether there
exists a plausible key in K that results in the symbol when
overlaid with the challenge frame. For challenges generated
by random segment based algorithms, however, a more ef-
fective response-guessing strategy is possible. For each chal-
lenge frame, order the symbols that are compatible with K
by the number of segments that need to be added to form
them, and guess the one that requires the fewest number
of additional segments based on decreasing probability. The
intuition is that the symbol(s) that can be formed by adding
the least number of segments are the most likely responses.
It turns out that using this guessing strategy alone, without
any searching, one can guess the response for NSD (7%+SE)
with probability around 0.1. That is, this guessing attack
can (0, 0.1)-break NSD (7%+SE) (as shown in Figure 5(c)).
Note that such heuristic does not work for random-pattern
based challenge generation algorithms.
4.6 Effectiveness of Noisy Frames

The usage of noisy frames that do not encode any digit
might appear to improve security, as it prevents adversary
from knowing for certain which frame corresponds to which
digit. This, however, is not the case. First, as each session
has only 4 digits, even if one does not know which frame en-
codes which digit, one can still exploit the information that
none of the other 5 digits are shown on any of the α = 15
frames to reduce the plausible key space. This, by itself, may
already leak more information when compared with the case
of using just 4 frames as in BSD. With noisy frames, for each
position, one has more than 15×5 = 75 challenge-digit pairs
to eliminate plausible key patterns. With just 4 frames, one
has 4 × 8 = 32 pairs. Second, one can search through each
of the α = 15 possibilities, and compute the set of plausi-
ble keys for each possibility, and remove key patterns that
are incompatible with any possibility. Note that after one
makes the guess, the noisy frames leak additional informa-
tion because they cannot encode any digit.

5. ATTACKING MULTI-SYMBOL SVAPS

Search is not eﬀective against multi-symbol SVAPs as they
reveal signiﬁcantly less amount of deterministic information.
Without such deterministic information, the key reduction
step of Search is not eﬀective. Without reducing the plau-
sible key space, using the search trees is unable to make
progress.
In this section, we present SolveLP, a class of
attacks that model the problem as a pseudo-boolean satis-
faction problem.
5.1 Constraint Formulation

The key is denoted by x, a challenge frame is denoted by
y, and the response is denoted by r. We use x[p] and y[p]
to denote the key pattern and challenge pattern in position
p of x and y, respectively. We use [λ] = [1 . . . λ] to denote
the set of positions in a challenge frame or key. We use PK

608to denote the set of valid key patterns and PC to denote the
set of valid challenge patterns.

Variables In our pseudo-boolean constraint formulation,
the constraints are over the following 0 − 1 variables.
Xp,k = 1 if and only if x[p] = k, for p ∈ [λ] and k ∈ PK .
There are λ ∗ |PK| such variables. These variables encode
the key we want to attack, and are the variables that we
want to solve. To make it easier to explain the constraints,
we also introduce the following macro variables that can be
expressed using Xp,k’s.

Yp,c,s, where p ∈ [λ], c ∈ PC , and s ∈ Σ.

Yp,c,s = 1 if and only if for the key we want to attack, using
c as the challenge pattern in position p, displays the symbol
s; it can be expressed as follows:

(cid:88)

Yp,c,s =

Xp,k

(2)

k∈compatible(c,s)

where compatible(c, s) is the set of all valid key patterns in
PK that display s when overlaid with c.
Universal Constraints. These constraints are applicable
to all protocols. The following requires that each position of
the key takes only one key pattern.

∀p ∈ [λ],

Xp,k = 1

(3)

(cid:88)

k∈PK

Note that the above represents λ constraints, one for each
position. These constraints are conjuncted with the con-
straints below for encoding information revealed in each
challenge/response pair.
EDD Speciﬁc Constraints. For EDD we have the following
constraints for each challenge frame y and response r.

• The challenge y generates exactly two digits:

(cid:88)

(cid:88)

p∈[λ]

s∈Σ

Yp,y[p],s = 2

(4)

This says that knowing the patterns on each position
in the challenge, the total number of digits that are
displayed is exactly 2. Recall that Yp,y[p],s should be
expanded according to Eq. (2).
• The challenge y generates r:

Yp,y[p],r ≥ 1

(5)

(cid:88)

p∈[λ]

Note that the ≤ 2 part is implied by Eq.(4).

HDD Speciﬁc Constraints. For HDD we have the following
two constraints for each challenge frame y and response r.
The ﬁrst of which states that the response corresponding
to frame y is r. This constraint is the disjunction of two
disjunctions, one corresponding to the case that two diﬀerent
digits r1 and r2 are displayed, and the other corresponding
to the case that the same digit is displayed twice.

(cid:95)
(cid:95)

r1(cid:54)=r2∈Σ∧(r1+r2) mod 10=r

(cid:95)

r1∈Σ∧(r1+r1) mod 10=r



(cid:1) = 2

(cid:88)
(cid:88)

p∈[λ]

p∈[λ]

(cid:0)Yp,y[p],r1 + Yp,y[p],r2


 = 2

Yp,y[p],r1

The second constraint captures the deterministic informa-
tion revealed by HDD, that is, as 1 /∈ Σ, a challenge frame
cannot encode a digit d such that (d + 1) mod 10 = r. Note
this does not apply to HTD.

(cid:88)

(cid:88)

Xp,k = 0

(6)

p∈[λ]

k∈compatible(y[p],(r−1) mod 10)

HTD Speciﬁc Constraints.
The constraints for HTD in-
clude only the ﬁrst constraint for HDD, and can be obtained
by natural extension. We omit the details.
5.2 Linear Programming Relaxation
After obtaining the constraints for multiple challenge-
response pairs (cid:104)(y1, r1) . . . (yn, rn)(cid:105), one can attempt to use
any oﬀ-the-shelf SMT, SAT, or pseudo-boolean solver to
solve for the variables of the form Xp,k. Such an assign-
ment of the Xp,k variables will give us one plausible key
which is compatible with the given challenge-response pairs
(yi, ri). However, in experiments we have found that all the
constraint solvers we have tried fail to scale for λ ≥ 10.

To meet this challenge, we apply the linear programming
relaxation technique to solving the 0-1 constraint satisfac-
tion problem. That is, instead of assigning binary values to
the variables, we assign fractional values to them, and inter-
pret a larger value as more likely to be 1. We further apply
the idea of multiplicative updates to solve the resulting lin-
ear programming problem.

Our usage of the multiplicative update method can be
roughly viewed as interpreting a fractional value assigned to
a variable Xp,k as the probability of x[p] = k. Initially, all
the probabilities are uniform, i.e., for all p, k, Xp,k = 1|PK| .
However, the initial values of Xp,k may not respect the con-
straints from challenge-response pairs, which consequently
means we have to update the values of Xp,k. We update the
variable values in a multiplicative fashion. For instance, if
we have a constraint Xi +Xj = t, and currently Xi +Xj = s,
we update the the values in the following way: Xi ← Xi
t
and Xj ← Xj
s
t
s . If the constraint is inequality, we will only
update the values (taking the RHS of the inequality as the
target) when the inequality does not hold. As Xp,k can
appear in diﬀerent constraints, updating Xp,k values to sat-
isfy one constraint may end up violating another constraint.
Hence, we loop through all constraints until the values of the
variables converge (if the cumulative change of the variables
is below a small threshold, we use 0.01 in experiments), or
a loop threshold (100 in experiments) is reached.
5.3 Attacking EDD

To attack EDD, one has a set of linear constraints that are
logically and’ed together. We thus can readily apply the
above multiplicative update methods. When given the chal-
lenge frame y, we enumerate all possible response r, encode
y and r using assuming r is the response, and just use this
summation (LHS of Eq. (5)) as the weight corresponding
to r. The response with highest weight is chosen to be the
guess.
5.4 Attacking HDD and HTD

For HDD and HTD, because of the uncertainty of which pairs
of digits are displayed, the constraint for each frame con-
sists of a disjunction, which cannot be directly handled by

609the multiplicative update approach. We now explain our
approach for HDD, which can be easily generalized to HTD.
To attack HDD, we have to combine guessing which pairs are
displayed with solving the system of constraints.
Given a pair (cid:104)y, r(cid:105), we enumerate through all possible dig-
its r1, r2 ∈ Σ such that r1 + r2 = r, and compute
vy(r1, r2) = max

Yl,y[l],⊥,

Yi,y[i],r1 × Yj,y[j],r2 × (cid:89)
Xl,k −(cid:80)

s∈Σ Yl,y[l],s. This esti-
mates the probability that r1 and r2 are displayed. We then
use the pair with the highest value as the weight for this
frame.

k∈PK

where Yl,y[l],⊥ = (cid:80)

i,j∈[λ] : i(cid:54)=j

l(cid:54)=i,j

We compute the weight for all frames in the transcript,
and start with the frame with highest weight. The two digits
that produces this weight are assumed to be shown in this
frame, and encoded as a constraint. We then update the
variables using all constraints, and guess the next frame.

We do this until we’ve guessed 2/3 of all frames. We leave
1/3 frames unguessed because it is more probable to make
wrong guesses in the last few frames (as guesses are made
in the descending order of conﬁdence), and one wrong guess
would make the ﬁnal guessing inaccurate. This 1/3 ratio is
our initial heuristic choice.
In the experiments, we found
that using a ratio of 1/4 performs slightly better, and a
ratio of 1/2 is slightly worse. We did not attempt to further
optimize this ratio. When the transcript is updated, the
above computation will be repeated.

When given the challenge frame, we compute the score
for each response r, which is the sum of vy(r1, r2) such that
(r1 + r2) mod 10 = r, and choose r with the highest score.

6. EXPERIMENTAL EVALUATION

In this section, we report experimental results concerning
the security analysis of SVAPs under the two attacks: Search
and SolveLP.
6.1 The Search Attack
Experimental setting. All the reported results here
are averaged over 10, 000 runs. For each run, we gener-
ate a key and 20 sessions (100 for HDD) of simulated chal-
lenge/response.

Starting from the ﬁrst session, for each session we do the
following (1) generate a challenge/response pair (y, r); (2)
without r, use K, the current global set of plausible keys, to
guess a response to y, output whether the guess is correct;
(3) compute the set of compatible responses, and output the
size of this set; (4) output the size of plausible keys in K;
(5) add (y, r) to the transcript, and update K.

We aggregate the output from step (2) of 10, 000 runs into
the probabilities of making a correct guess after using the
1
transcript of a certain number of sessions. We use log2
p
when plotting the graphs. This can be viewed estimating
the min-entropies of the guesses. We perform steps (3) and
(4) to generate data that enable us to better understand
the relationship between sizes of plausible keys, numbers of
compatible responses, and ﬁrst-guess success probability.

We attack the protocols presented in Section 3.1, i.e.,
NSD (7%+SE), NSD (20%+SE), BSD (20%+SE), BSD (20%), and
BSD. We also attack HDD (α =3), as a comparison of the ef-
fectiveness between Search and SolveLP. The Search attack
is completely ineﬀective against EDD and HTD. We present re-

sults for two security parameters, λ = 15 and λ = 30. Larger
λ values hurt usability.

Eﬀectiveness of the attack. Figure 5 shows the results of
applying Search against the above protocols. From Figure 5,
we can observe the following results.

First, from Figures 5(b) and 5(c), we can observe that
Search can (4, 0.25)-break BSD (20%). This means that af-
ter 4 sessions, a guess with succeed with probability 0.24.
However, at this point, the number of plausible keys in K is
roughly 220. The same trend can be seen for other protocols
as well. This suggests that it is possible to carry out an
impersonation attack even though a large amount of uncer-
tainty regarding the key remains.

Second, from Figures 5(a) and 5(c), we can see that ex-
cept for BSD, the level of security indicated by min-entropy
is signiﬁcantly lower than that indicated by the number of
possible responses. This indicates two things. First, the
number of possible responses is not always an accurate indi-
cator of security. Second, random segment-based challenge
generation algorithms are vulnerable to our guessing attacks
based on the number of segments needed to display a digit.
Third, NSD (7%+SE) (i.e., our attempt to duplicate Pass-
Window) is extremely insecure. Even a stateless adversary,
not having access to any response, can succeed in the ﬁrst
guess with probabilities 10.7% and 8.2% for λ = 15 and 30,
respectively. After intercepting only 3 challenge/response
pairs, the success probabilities increase to 66.9% and 26.2%,
respectively.

Fourth, while NSD (20%+SE) oﬀers a slightly better secu-
rity than NSD (7%+SE) when the attacker has 0 or 1 chal-
lenge/response pair, its security degrades to the same level
as NSD (7%+SE) with 2 or more intercepted sessions; this
is because by using denser segments on non-encoding po-
sitions, it also leaks more information regarding the key in
each session.

Fifth, using noisy frames is a bad idea. This is because
the noisy frames actually provide more deterministic infor-
mation such as which digits are not shown. Removing noisy
frames improves the level of security signiﬁcantly.

Sixth, using shared edges between adjacent positions or
not has almost no noticeable impact on the level of security.
Seventh, all the uni-symbol SVAP variants we identiﬁed are
very insecure. For λ = 15, Search is able to (8, 0.25)-break
all of them, i.e., after observing 8 challenge-response pairs,
an adversary can successfully impersonate a user with prob-
ability 0.25. For λ = 30, Search can (12, 0.09)-break all
uni-symbol SVAP protocols.
Finally, Search can (20, 2−9.84) break HDD with λ = 15,
indicating that HDD may be considered to be acceptable if
this is the best attack we have.
6.2 The SolveLP Attack
Experimental setting. The experimental setting is simi-
lar to that of the previous attack; however, we report only
the min-entropy. For this attack, instead of reporting the
cardinality of the set of plausible keys and responses, we
only make a guess and thus report only the success proba-
bility of the guess. In this experiment, we evaluate the eﬀect
of applying SolveLP on EDD, HDD, HTD, and BSD.
Eﬀectiveness of the attack. Figure 6 illustrates the Min-
Entropy of our attack against EDD, HDD, and HTD. We present
results for security parameters λ = 15 and λ = 30. We now
highlight some of our ﬁndings.

610(a) #plausible keys (λ = 15)

(b) #possible responses (λ = 15)

(c) Min-Entropy of attack (λ = 15)

(d) #plausible keys (λ = 30)

(e) #possible responses (λ = 30)

(f) Min-Entropy of attack (λ = 30)

Figure 5: Eﬀect of the Search attack. The X-axes correspond to (cid:96), the number of authentication sessions for which
the adversary has intercepted the transcripts. The Y-axes in the subﬁgures 5(a) and 5(d)) correspond to the number
of candidate keys. The Y-axes in the subﬁgures 5(b) and 5(e) correspond to the number of plausible responses. The
Y-axes in the subﬁgures 5(c) and 5(f )) correspond to the inverse of the probability that the ﬁrst guess succeeds. The
values in Y-axes are in Log Scale (Base 2).

First, EDD performs the worst under the attack, even worse
than BSD. This is because there are two, instead of one, cor-
rect responses for each frame. SolveLP can (4, 0.25)-break
both BSD and EDD.

Second, SolveLP is more eﬀective than Search on both
BSD and HDD. For example, when λ = 15, SolveLP can
(4, 0.25)-break and (8, 0.25)-break BSD and HDD, respectively,
whereas Search can (8, 0.25)-break and (8, 2−9.97)-break BSD
and HDD, respectively.

Third, increasing the key length also increases the secu-
rity of the protocol (see Figure 6). However, increasing the
key length to achieve an acceptable level of security yields
deployment and usability challenges (e.g., the key card size).
Finally, all the multi-symbol SVAP protocols are (10, 0.25)-
breakable for λ = 15, and (20, 0.125)-breakable when λ =
30. The results directly exhibit the potency of the SolveLP
against the multi-symbol SVAP protocols and let us draw
the conclusion that the concrete SVAPs we have considered
are insecure in general. Designing protocols that are usable
and secure at the same time is a fascinating future research
direction.
Security of diﬀerent protocols. Table 1 presents the
levels of security of diﬀerent schemes in another way.
If
we view min-entropy of 3 as a point at which we declare a
protocol to be broken, Table 1 shows how many sessions a
protocol can withstand under an eavesdropping attack.
Eﬃciency of the attacks. Now we report the running
time of our attacks. We measured the wall clock time it
takes (i.e., using the Linux time utility) to generate and
guess 20 sessions using key length 15. All experiments were
carried out on a 3.40GHz Intel(R) Core(TM) i7-3770 CPU
running GNU/Linux with 16GB RAM.

For Search, it takes less than a second to run an attack
instance. SolveLP takes less than 0.98 minute to run a single
instance of EDD whereas it takes 1.08 and 1.10 minutes for
HDD and HTD, respectively. Also, we implemented the attacks
in python, and we did not aim at optimizing the attack.
The reported times here are just representative examples
demonstrating the feasibility of the attacks in real life.

Note that employing SolveLP using pseudo-boolean, SAT,
or SMT solvers are not feasible in practice. To the best of our
knowledge, the best free solvers for our form of constraints
are MiniCard [2, 3] (for EDD), and MiniSat+ [3] (for HDD
and HTD). Unfortunately, none of the solvers are eﬃcient,
especially when the key length is long (e.g., 15). Speciﬁcally,
for EDD, it takes MiniCard around 10 minutes to make a guess
for one instance, and much longer for HDD.

7. USABILITY EVALUATION

We have conducted a human subject study to evaluate the
usability of several SVAPs. Our study was vetted by our in-
stitution’s IRB and was given an exemption on the grounds
that it is based on survey procedures, and individual partic-
ipants cannot be identiﬁed from the study.
7.1 Study Design
Protocols Studied. We studied the usability of the fol-
lowing protocols: NSD (7%+SE), EDD, HDD, and HTD. For pre-
sentation purposes, we use the alias ASD for NSD (7%+SE).
For each of the protocols, we displayed the superimposed
image (i.e., the key combined with the challenge frame) on
a browser, and let the participants respond according to the
protocol’s authentication requirement. We measured each

 0 20 40 60 80 100 0 2 4 6 8 10 12 14 16 18 20 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20 0 50 100 150 200 0 2 4 6 8 10 12 14 16 18 20 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20NSD(7%+RS)NSD(20%+RS)BSD(20%+RS)BSD(20%)BSDHDD611(a) Min-Entropy (λ = 15)

(b) Min-Entropy (λ = 30)

Figure 6: The X-axes in the curves correspond to (cid:96), the number of authentication sessions for which the adversary has
intercepted the transcripts. The Y-axes in the subﬁgures 6(a) and 6(b)) correspond to the inverse of the probability
that the ﬁrst guess succeeds. The values in Y-axes are in Log Scale (Base 2).

λ
15
30

NSD (20%+SE)

BSD (20%+SE)

(2.9, 0.8)
(4.3, 1.1)

(3.7, 1.5)
(7.3, 3.1)

Search

BSD (20%)
(3.8, 1.9)
(7.1, 3.6)

BSD

HDD

BSD

EDD

HDD

HTD

(7.7, 1.4)
(13.1, 2.3)

(43.6, 4.7)
(83.3, 7.5)

(3.2, 0.9)
(5.7, 1.1)

(2.5, 1.1)
(4.5, 1.4)

(6.7, 1.7)
(13.1, 1.6)

(11.4, 3.6)
(16.0, 2.9)

SolveLP

Table 1: A value in a cell is of the form (s, k) in which s denotes the average number of sessions for an attack
to have min-entropy ≤ 3, i.e., the ﬁrst guess succeeds with probability ≥ 1
8 . The value k denotes the standard
deviation of s.

user’s accuracy and average completion time of each proto-
col authentication session. An authentication session of EDD,
HDD, and HTD consists of four frames (i.e., α = 4), whereas
an authentication session of ASD is an animation of ﬁfteen
frames among which only four frames display digits which
constitute the desired 4-digit response (i.e., α = 15). For
EDD, HDD, and HTD, we choose α to be 4 so that the response
lengths of these protocols are consistent with ASD.

We also noticed the existence of a few 7-segment LED
patterns which closely resemble the 7-segment LED patterns
representing digits, but are not valid digit-representing pat-
terns. We call these patterns confusing patterns (CP). See
Figure 7(a) and Figure 7(b) for these CP and their valid
counterparts. During the training session, we drew users’
attention to those CP to prevent them from getting con-
fused. Meanwhile, we also evaluated the inﬂuence of CP on
authentication, by considering protocol variants which never
display these confusing patterns. We identify the protocol
variants which exclude CP with a trailing ‘-’ in their name,
e.g., ASD-, EDD-, HDD-, HTD-.
Evaluation Process. We ran our user study through Ama-
zon’s Mechanical Turk (MTurk). Each study participant
is randomly assigned a speciﬁc protocol to use and we re-
quire the participant to complete ﬁve authentication sessions
of that protocol. We evaluated the accuracy rate and the
completion time of each participant. Before the evaluation
phase, there is a training phase explaining the protocol’s
authentication requirement.

For ASD and ASD-, the study web page displays an ani-
mation of 15 images, with each image lasting two seconds.
Participants are can enter the four response digits at any
time and then click a button to submit. For the other pro-
tocols, the page displays a static image (a single frame), and
the participants need to input the response for that frame
in order to proceed to the next frame.

The training phase contains a single authentication session

with explanations describing the requirement of the task.
The authentication session used is similar to the ones used
in the real study.
7.2 User Study Result Analysis

For each of the eight protocols (ASD, EDD, HDD, HTD, ASD-,
EDD-, HDD-, HTD-), we recruited ﬁfty participants on MTurk.
The participants’ ages range from 18 to over 50, with about
80% between 23 and 40. Roughly, 80% of the participants
hold bachelor’s or master’s degree. Male participants make
up around 60% of all participants. The distributions are
similar for all the eight groups.

Figure 8 gives the accuracy and completion time of dif-
ferent protocols. We now highlight some of our interesting
ﬁndings below.
Accuracy. In terms of accuracy, EDD performs better than
ASD (t = 1.361, p = 0.177), HDD (t = 1.925, p = 0.057), and
HTD (t = 3.096, p = 0.003) 1. EDD is followed by ASD, which is
slightly better than HDD. HTD is the worst, with accuracy be-
low 80%. This ordering is expected. The diﬀerences among
these three, however, are not statistically signiﬁcant.
Completion time. EDD is also the clear winner in terms
of completion time (t signiﬁcant at p < 10−8), taking an
average of less than 20 seconds per session. EDD is followed
by ASD and HDD, each taking an average of around 40 sec-
onds. Given the animated nature of ASD, taking an average
of around 40 seconds appears reasonable. If a participant
fails to identify a digit, she has to wait for the loop to re-
turn to the same frame again. With an animation loop of
30 seconds, users who did not succeed in the ﬁrst time could
take close to 60 seconds. It is a bit surprising that HDD takes
as long as ASD. This is due to a combination of the need to

1t and p are values used in the t-test to indicate whether a
result is statistically signiﬁcant; t denotes how many stan-
dard deviations, and p is the probability; larger t and smaller
p mean higher signiﬁcance.

 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20 0 2 4 6 8 10 12 0 2 4 6 8 10 12 14 16 18 20BSDHDDHTDEDD612(a) Confusing Patterns

(b) Valid Patterns

Figure 7: Confusing Patterns and their correspond-
ing Valid Patterns

recognize two digits and to do the extra arithmetic step. HTD
takes the longest, with around 50 seconds per authentication
session.
Does practice make perfect? From ﬁgure 9(a), we can
see that, in most cases, the completion time decreases as
the evaluation proceeds. The completion time of the last
session is less than the ﬁrst one in all protocols (t signiﬁcant
at p < .02). However, in terms of accuracy (Figure 9(b)), it
appears that for EDD and ASD, the accuracy improves. For
HDD and HTD, the accuracy rates change more erratically.
In particular, in the last session of HTD, the accuracy rate
drops by a large value. One possible reason is that partic-
ipants lost their patience at the last authentication session
after performing twenty or so additions of three single-digit
numbers.
Overall Assessment. Our results suggest that HDD oﬀers
similar usability as ASD, but with higher security. However,
the level of security oﬀered by HDD is still far from satisfac-
tory. While HTD oﬀers some security enhancement over HDD,
this comes with signiﬁcant usability cost.
How “Random” is EDD? Among all the participants as-
signed to EDD or its variant, only a small amount (2%) of
participants always choose either the left or the right digit
displayed in a frame consistently. Roughly, half of the par-
ticipants (i.e., 44%) randomly choose between the left and
right digits. They choose the left digit roughly with proba-
bility 0.4 to 0.6. The distribution of the probability a partici-
pant chooses the left digit is similar to a normal distribution.
This ﬁnding is interesting due to the fact that it contradicts
the belief that the probability of the left digit being picked
is higher.
Inﬂuence of confusing patterns. We evaluated the inﬂu-
ence of the confusing patterns (CP) on usability. As shown
in Figure 8, removing CP helps increase the users’ accuracy
for EDD (t = 2.982, p = 0.004), and at the same time, decrease
the completion time for HDD (t = −1.649, p = 0.1) and EDD
(t = −2.152, p = 0.03). For the rest of the protocols, the
impact of removing CP in the context of accuracy or com-
pletion time is not substantial.

8. RELATED WORK
Human Identiﬁcation Protocols.
The ﬁrst theoreti-
cal foundation of human identiﬁcation protocol (HIP) dates
back to the work by Matsumoto and Imai [23]. However,
their scheme was broken by Wang et al. [34].

Hopper and Blum [18] proposed to use a NP-hard “learn-
ing parity with noisy” (LPN) problem. Users can compute
inner product of a secret bit-string and a challenge bit-string
and uses the result to authenticate herself. Weinshall [35]
proposed Cognitive Authentication Scheme (CAS) that uti-
lizes human memory and cognition to diﬀerentiate two sets
of images. However, this scheme is later broken by Golle
and Wagner [17]. They used a SAT solver and recovered the

Figure 8: Accuracy and Completion Time of Diﬀer-
ent Protocols.

(a) Completion Time

(b) Accuracy

Figure 9: Completion time (in second) and accuracy
throughout the ﬁve sessions.

secret after intercepting challenge-response pairs of tens of
sessions.

Bai et al. proposed Predicated-based Authentication Ser-
vice (PAS) [8] in which the user and the server agree on a
predicate. During authentication, the server provides the
arguments as challenges and the user applies the predicate
to obtain the response. One year later, Li et al. [21] took
advantage of intersection attack to break this scheme.

Rosener et al. proposed GridCode [32] as a layer for obfus-
cating passcodes, but it was broken by Molloy and Li [24].
They were able to recover the victim’s password and addi-
tional secret after intercepting a small number of challenge-
response pairs.

Human Computable Machine Unbreakable (HCMU ) hash
schemes [10, 9] have been proposed for generating textual
passwords [10, 9]. Since they do not use any external mem-
ory aid (such as a key card in SVAPs), such schemes are harder
to design and to use. For example, the scheme in [10] re-
quires a human user to memorize a random mapping from
letters to digits, a random permutation of the digits, and to
perform single digit mod 10 additions.

Yan et al. [36] studied the inherent complexities of de-
signing authentication mechanisms that do not rely on the
underlying computing device. They consider those human-
computable authentication protocols that depend on the hu-
man users’ memory and cognitive capacity. They provide
two general classes of attacks that can circumvent these au-
thentication mechanisms. They also provide design princi-
ples for leakage-resilient password systems and described a
framework for measuring the cognitive overload of a proto-
col. Their framework and attacks are not directly applicable

ASD/ASD-HDD/HDD-HTD/HTD-EDD/EDD-0.00.20.40.60.81.0Accuracy0102030405060Time(s)Accuracyw/CPAccuracyw/oCPTimew/CPTimew/oCP 0 20 40 60 1 2 3 4 5 0.7 0.8 0.9 1 1 2 3 4 5ASDHDDHTDEDD613to SVAPs as SVAPs allow the use of a key card, which can store
a high-entropy secret.
Visual Cryptography (VC). Visual cryptography (VC ),
introduced by Naor and Shamir [26, 27], can be viewed as
an instance of human computable cryptography where de-
coding a ciphertext takes advantage of the visual channel
of a human user.
In this model, the ciphertext and the
secret key are printed images and revealing the plaintext
requires superimposing the two printed images (correspond-
ing to the ciphertext and the key) which user can visually
observe. Note that individually any of the printed images
(ciphertext or key) is indistinguishable from a random noise.
Ateniese et al. [6] and Lu et al. [22] considered VC-based
sharing scheme in a graph setting in which a secret image is
associated with each edge of the graph. The problem is to
generate shares for each vertex of the graph such that when
the shares of two distinct vertices v1 and v2 are combined, it
exposes the secret image corresponding to the edge (v1, v2).
Ateniese et al. [7] then proposed extended VC schemes that
allow the shares to be meaningful ﬁgures in order to avoid
suspicion and censorship. Rijmen and Preneel [31] ﬁrst pro-
posed a VC scheme to use diﬀerent colors other than black
and white. The same idea was later improved by Hou et
al. [19]. Chavan et al. [15] proposed hierarchical VC (HVC),
that can be used to derive more on-demand shares. Abboud
et al. [5] proposed to combine steganography and VC, but
their scheme requires the human computation to be more
involved.

Chang and Hu [13] proposed to use VC to distribute shares
of a copyright among its stakeholders. Watermark schemes
based on VC have also been proposed [20, 16]. VC can also
be used to generate voting receipts [14] that enjoy veriﬁabil-
ity and coercion resistance.
VC-based authentication. Noar and Pinkas [25] pro-
posed the ﬁrst framework for VC-based authentication and
identiﬁcation. Their Visual Identiﬁcation problem is simi-
lar to what we call Visual Authentication Mechanism. The
security notion we use for SVAPs in our paper is based on
the one in [25].
In the scheme they propose in [25], the
key consists of a number of squares, each is painted with
one of 10 colors. A challenge selects d squares, and the re-
sponse is the sequence of colors for the d squares, sent in
some predeﬁned order. Borchert’s note [12] discussed the
idea of segment-based VC which can be viewed as a spe-
cial case of SVAPs. However, in these schemes from each
challenge/response pair, an adversary can trivially recover a
portion of the key used in the pair.
9. CONCLUSIONS

In this paper, we presented an abstract framework for
designing SVAPs. We discussed two classes of protocols: uni-
symbol SVAPs and multi-symbol SVAPs. Then, we came up
with two attacks Search and SolveLP against them. Finally,
we carried out a user study to evaluate the usability of some
of the protocols.

Our overall ﬁndings are negative; our attacks can break
all the protocols we have developed including a commer-
cial protocol. This points to the following two fundamental
weaknesses of SVAPs. First, there is not enough entropy in
the secret key. Second, SVAPs are highly structured; they
do not eﬀectively enlarge the search space of the attack.
Therefore, it remains an open problem to design a secure
yet usable protocol based on visual cryptography.

10. ACKNOWLEDGMENTS

This material

is based upon work supported by the
National Science Foundation under Grant No.
1314688.
Hemanta K. Maji’s research is supported by CNS-1566499.
We thank Matthew Walker for providing some insights
and details of the PassWindow scheme. We also thank the
anonymous reviewers for their valuable suggestions.
11. REFERENCES
[1] An evaluation of hypothetical attacks against the

passwindow authentication method.
http://passwindow.com/evaluation of hypothetical
attacks against passwindow.pdf.

[2] Minicard. https://github.com/liﬃton/minicard.
[3] Minisat+. http://minisat.se/MiniSat+.html.
[4] Passwindow. http://www.passwindow.com.
[5] G. Abboud, J. Marean, and R. V. Yampolskiy.

Steganography and visual cryptography in computer
forensics. In Systematic Approaches to Digital Forensic
Engineering (SADFE), 2010 Fifth IEEE International
Workshop on, pages 25–32. IEEE, 2010.

[6] G. Ateniese, C. Blundo, A. D. Santis, and D. R.
Stinson. Visual cryptography for general access
structures. Information and Computation, 129(2):86 –
106, 1996.

[7] G. Ateniese, C. Blundo, A. D. Santis, and D. R.

Stinson. Extended capabilities for visual cryptography.
Theor. Comput. Sci., 250(1-2):143–161, 2001.

[8] X. Bai, W. Gu, S. Chellappan, X. Wang, D. Xuan,

and B. Ma. Pas: predicate-based authentication
services against powerful passive adversaries. In
Computer Security Applications Conference, 2008.,
pages 433–442. IEEE, 2008.

[9] J. Blocki, M. Blum, and A. Datta. Human computable

passwords. CoRR, abs/1404.0024, 2014.
http://arxiv.org/abs/1404.0024.

[10] M. Blum. Mental cryptography and good passwords.

http://www.scilogs.com/hlf/
mental-cryptography-and-good-passwords/.

[11] J. Bonneau, C. Herley, P. C. Van Oorschot, and

F. Stajano. The quest to replace passwords: A
framework for comparative evaluation of web
authentication schemes. In Security and Privacy IEEE
Symposium on, pages 553–567. IEEE, 2012.

[12] B. Borchert. Segment-based visual cryptography.

Technical Report WSI-2007-04, Universit¨at T¨ubingen,
2007.

[13] C.-C. Chang and H. Wu. A copyright protection
scheme of images based on visual cryptography.
Imaging science journal, 49(3):141–150, 2001.

[14] D. Chaum. Secret-ballot receipts: True voter-veriﬁable

elections. IEEE security & privacy, 2(1):38–47, 2004.
[15] P. V. Chavan, D. Atique, D. Malik, et al. Design and

implementation of hierarchical visual cryptography
with expansion less shares. arXiv preprint
arXiv:1402.2745, 2014.

[16] W. Chuen-Ching, T. Shen-Chuan, and

Y. Chong-Shou. Repeating image watermarking
technique by the visual cryptography. IEICE
Transactions on Fundamentals of Electronics,
Communications and Computer Sciences,
83(8):1589–1598, 2000.

614Remove from Πi patterns that when overlaid with yj,k, the k’th challenge frame of the j’th session, results
in a symbol that does not appear in rj , the observed response code for that session.

T ← []; T .enqueue(newNode(K, [c1, c2, . . . , ct])); F.add(T )
for T ∈ F do

while T not fully expanded AND T .size() ≤ 1000 do

Algorithm 1 Search
Input: Transcript of (cid:96) successful authentication sessions: Y = (cid:104)y1, . . . , y(cid:96)(cid:105), R =(cid:104)r1, . . . , r(cid:96)(cid:105).
Output: Global plausible pattern set K.
1: Initialize K = (cid:104)Π1, Π2, . . . , Πλ(cid:105) such that each Πi includes all patterns that can be generated by keyGen
2: for j ∈ [1 . . . (cid:96)], k ∈ [1 . . . α], i ∈ [1 . . . λ] do
3:
4:
5: F ← []
6: for j ∈ [1 . . . (cid:96)] do
7:
8: while Making progress do
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:

while there exist two trees Ti, Tj ∈ F that are fully expanded and Ti.size()×Tj .size()<10000 do
for T ∈ F do

Remove from Πi any pattern that does not appear in the Πi component of any node in T .
for node n = (K(cid:48) = (cid:104)Πn

(K(cid:48), choices) ← T.dequeue()
ch ← choices.dequeue()
for b ∈ {all possibility of ch} do

Remove from K(cid:48) patterns that are inconsistent with the choice b.
if Π(cid:48)

i (cid:54)= ∅ for each Π(cid:48)
T .enqueue(newNode(K(cid:48), choices)

i ∈ K(cid:48) then

F.remove(Ti); F.remove(Tj ); T ← Ti × Tj ; F.add(T );

Update each Πn

i to remove any pattern not in Πi; if Πn

1 , Πn

2 , . . . , Πn

λ(cid:105),) ∈ T do

(cid:46) [c1, c2, . . . , ct] are all the choices for j’th session

(cid:46) Expand search trees.

(cid:46) dequeue() returns ﬁrst node in T that has non-empty choices
(cid:46) The ﬁrst element in choices is removed from choices and assigned to ch

(cid:46) Merge two trees.

(cid:46) Fixpoint update.

return K

i = ∅ for some i, remove the node from T

[17] P. Golle and D. Wagner. Cryptanalysis of a cognitive
authentication scheme. In Security and Privacy, 2007.
SP’07. IEEE Symposium on, pages 66–70. IEEE, 2007.

[28] S. Nettle, S. O’Neil, and P. Lock. Passwindow: A new

solution to providing second factor authentication.
VEST Corporation, 2009.

[18] N. J. Hopper and M. Blum. Secure human

[29] P. Raghavan and C. D. Tompson. Randomized

identiﬁcation protocols. In Advances in
cryptology—ASIACRYPT, pages 52–66. Springer,
2001.

rounding: A technique for provably good algorithms
and algorithmic proofs. Combinatorica, 7(4):365–374,
Dec. 1987.

[19] Y.-C. Hou. Visual cryptography for color images.

[30] P. Revenkar, A. Anjum, and W. Gandhare. Secure iris

Pattern Recognition, 36(7):1619–1629, 2003.
[20] Y.-C. Hou and P.-M. Chen. An asymmetric

watermarking scheme based on visual cryptography.
In Signal Processing Proceedings, 2000. WCCC-ICSP
2000. 5th International Conference on, volume 2,
pages 992–995. IEEE, 2000.

[21] S. Li, H. J. Asghar, J. Pieprzyk, A.-R. Sadeghi,

R. Schmitz, and H. Wang. On the security of pas
(predicate-based authentication service). In Computer
Security Applications Conference, 2009., pages
209–218. IEEE, 2009.

[22] S. Lu, D. Manchala, and R. Ostrovsky. Visual

cryptography on graphs. Journal of Combinatorial
Optimization, 21(1):47–66, 2009.

[23] T. Matsumoto and H. Imai. Human identiﬁcation

through insecure channel. In Advances in Cryptology
—EUROCRYPT, pages 409–421. Springer, 1991.

[24] I. Molloy and N. Li. Attack on the gridcode one-time
password. In Proceedings of the 6th ACM Symposium
on Information, Computer and Communications
Security, pages 306–315. ACM, 2011.

[25] M. Naor and B. Pinkas. Visual authentication and

identiﬁcation. In Advances in Cryptology—CRYPTO,
pages 322–336. Springer, 1997.

[26] M. Naor and A. Shamir. Visual cryptography. In

Advances in Cryptology-EUROCRYPT’94, pages 1–12.
Springer, 1995.

[27] M. Naor and A. Shamir. Visual cryptography ii:

Improving the contrast via the cover base. In Security
protocols, pages 197–202. Springer, 1997.

authentication using visual cryptography. arXiv
preprint arXiv:1004.1748, 2010.

[31] V. Rijmen and B. Preneel. Eﬃcient colour visual

encryption or shared colors of benetton. rump session
of EUROCRYPT, 96, 1996.

[32] D. K. Rosener, W. O. Brown, and E. L. Reuss. User

authentication system and method, Mar. 31 2008. US
Patent App. 12/060,031.

[33] J. WAGSTAFF. A new way to outwit internet

fraudsters. Wall Street Journal 11 July. 2010.

[34] C.-H. Wang, T. Hwang, and J.-J. Tsai. On the

matsumoto and imai’s human identiﬁcation scheme. In
Advances in Cryptology —EUROCRYPT’95, pages
382–392. Springer, 1995.

[35] D. Weinshall. Cognitive authentication schemes safe

against spyware. In Security and Privacy, 2006 IEEE
Symposium on, pages 6–pp. IEEE, 2006.

[36] Q. Yan, J. Han, Y. Li, and R. H. Deng. On limitations

of designing leakage-resilient password systems:
Attacks, principles and usability. In Proceedings of the
Network and Distributed System Security Symposium
(NDSS), San Diego, CA, February 2012.

APPENDIX
A. THE SEARCH ALGORITHM

Algorithm 1 gives the algorithm to reduce K, the set of
plausible key patterns, when given a transcript, as described
in Sections 4.2, 4.3, and 4.4.

615