CHEX: Statically Vetting Android Apps for

Component Hijacking Vulnerabilities

Long Lu†
†College of Computing, Georgia Institute of Technology

Zhichun Li‡

Zhenyu Wu‡ Wenke Lee† Guofei Jiang‡

{long, wenke}@cc.gatech.edu

{zhichun, adamwu, gfj}@nec-labs.com

‡NEC Labs America, Inc.

ABSTRACT
An enormous number of apps have been developed for Android
in recent years, making it one of the most popular mobile operat-
ing systems. However, the quality of the booming apps can be a
concern [4]. Poorly engineered apps may contain security vulner-
abilities that can severally undermine users’ security and privacy.
In this paper, we study a general category of vulnerabilities found
in Android apps, namely the component hijacking vulnerabilities.
Several types of previously reported app vulnerabilities, such as
permission leakage, unauthorized data access, intent spooﬁng, and
etc., belong to this category.

We propose CHEX, a static analysis method to automatically
vet Android apps for component hijacking vulnerabilities. Mod-
eling these vulnerabilities from a data-ﬂow analysis perspective,
CHEX analyzes Android apps and detects possible hijack-enabling
ﬂows by conducting low-overhead reachability tests on customized
system dependence graphs. To tackle analysis challenges imposed
by Android’s special programming paradigm, we employ a novel
technique to discover component entry points in their completeness
and introduce app splitting to model the asynchronous executions
of multiple entry points in an app.

We prototyped CHEX based on Dalysis, a generic static analysis
framework that we built to support many types of analysis on An-
droid app bytecode. We evaluated CHEX with 5,486 real Android
apps and found 254 potential component hijacking vulnerabilities.
The median execution time of CHEX on an app is 37.02 seconds,
which is fast enough to be used in very high volume app vetting
and testing scenarios.

Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veriﬁcation—
Validation; D.2.5 [Software Engineering]: Testing and Debug-
ging—Code inspections and walk-throughs

General Terms
Security

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Keywords
Static analysis, app splitting, component hijacking vulnerability

1.

INTRODUCTION

Android has gained tremendous popularity in recently years,
with over 100 million activations globally [22]. Part of the success
should be attributed to Android’s easy-to-join application develop-
ment community. More than 400k apps are available in the ofﬁcial
Android Market, yielding 10 billion accumulative installations by
the end of 2011 [3]. Alternative markets also play a big role in
hosting and distributing a large number of apps. Most apps were
developed and released in the last three years.

As large numbers of new apps, including newly updated ver-
sions, are constantly submitted to app markets and become in-
stantly available for users, we believe it is critical to provide a scal-
able vulnerability ﬁltering system for app market operators. Before
apps are released, the system quickly vets the apps for potential
security vulnerabilities and provides warning messages to help the
developers generate ﬁxes. Apparently, such systems should scale
well in face of a high input volume and have reasonably low false
positive rates to be useful. Therefore, we advocate a static analysis
based approach, as opposed to dynamic ones, for its complete code
coverage and scalability.

In this paper, we propose CHEX1, a static app vetting tool for
component hijacking vulnerabilities. Such vulnerabilities are found
in apps that implement access control improperly on external re-
quests or accidentally leak private data or privileges. In general,
these vulnerabilities are exploited to carry out unauthorized read
or write operations on sensitive resources. Therefore, we trans-
form the detection problem into an equivalent data-ﬂow problem
that seeks to identify the existence of hijack-enabling ﬂows in apps.
Component hijacking vulnerabilities include, but are not limited to,
several previously reported vulnerabilities, such as permission re-
delegation and leakage [20, 21], intent spooﬁng [10], and private
data leakage (e.g. login credentials).

Our work makes three folds of contributions. First, we designed
a sound method that automatically discovers all types of app en-
try points at a low false rate, whereas previous works primarily
use simple domain knowledge and only ﬁnds the common entry
point types. Second, in order to efﬁciently model interleaved exe-
cutions of multiple entry points and track data-ﬂows crossing them,
we propose the concept of app splitting, which generates and per-
mutes data-ﬂow summaries of each split2. The existence of hijack-

1CHEX stands for Component Hijacking Examiner.
2A term we deﬁned to describe a fragment of code reachable from
a single entry point

229app can easily take advantage of (or hijack) the Enumerator
Service and consequently gain access to user’s contacts without
the required permission. Recent works [11, 20, 21, 27] reported at-
tacks similar to this particular example, all of which derive from the
classic confused deputy attack [23] and aim at escalating privileges
of attacking apps in the context of Android’s permission system.
Note that, although permission-protected resources (e.g. contacts,
geo-location, and etc.) are obvious targets, component hijacking is
by no means limited to these confused deputy attacks that bypass
the permission checks. In fact, if carelessly exposed, data or invok-
able interfaces that are only intended for app’s internal use (thus
not permission-protected) can also become targets of component
hijacking attacks. In this case, where no explicit permission is in-
volved, the attacking app seeks to tamper or steal private data of a
vulnerable app that does not enforce access control or input valida-
tion properly. For instance, in Figure 1, the security-critical infor-
mation stored in the app internal database can be tampered through
the Setting Update Receiver in an SQL-injection fashion.
Complicated cases exist, where an attacker can leverage a chain
of vulnerable components to steal private data, modify critical set-
tings, or perform privileged actions, by simply issuing crafted re-
quests as a regular app.

Several topics related to component hijacking were studied by
recent works. ComDroid [10] checks app metadata and API usages
for publicly exported components. Such components, if granted di-
rect or indirect access to sensitive resources, may become launch-
ing points for hijacks. Grace et al. [21] analyzed factory stock apps
to identify permission leakage, a threat that also spurred studies on
its runtime mitigations [8, 12, 20]. While these works are effective
in archiving their own goals, they target at the vulnerabilities that
only represent a subset of component hijacking (i.e. hijacks seek-
ing to access non-permission-protected sensitive resources are not
covered). Plus, these works do not intend to provide any in-depth
detection method suited for scalable app vetting. Our work aims to
bridge this gap.

It is noteworthy that component hijacking vulnerability is not
caused by any insecurity intrinsic to Android framework. In fact,
Android does provide a set of mechanisms to secure app compo-
nents and their interactions. Instead, similar to other security vul-
nerabilities in software, component hijacking stems from issues
that are hard to avoid in reality, such as undertrained developers,
lacks of proper app quality assurance, and usability issues of ex-
isting security mechanisms. We expect component hijacking vul-
nerability to emerge rapidly in terms of popularity and severity. As
the user population of Android constantly grows, more and more
developers are migrating to this platform, often with inadequate ex-
perience or knowledge on its security mechanisms. In addition, the
current app distribution model offers a convenient way for amateur
developers to release their apps to a wide range of users. With these
factors adding up, the odds becomes high for a regular Android user
to install apps that insecurely handle external requests and thus are
subject to component hijacking. Attackers who are now struggling
with crafting new exploiting techniques on Android would not eas-
ily let this new attacking vector pass by.

Apps with component hijacking vulnerabilities are generally not
malicious on their own, but can be coerced by attacking apps to
conduct malicious activities. Defensive efforts may focus on either
ﬁnding the vulnerabilities in benign apps, or detecting correspond-
ing exploits from suspicious apps. Our work follows the ﬁrst ap-
proach for the more distinguishable and less volatile nature of the

Figure 1: An app vulnerable to component hijacking

enabling data-ﬂows is checked by means of a reachability analysis
on customized system dependence graphs [25] that capture the vari-
able dependencies globally. Finally, we built CHEX, an in-depth
and scalable static app vetting tool for component hijacking vul-
nerabilities. We exercised CHEX with 5,486 popular free Android
apps collected from both the Ofﬁcial Android Market and alterna-
tive Android markets. The median execution time of CHEX on an
app is 37.02 seconds, which is fast enough to be used in very high
volume app vetting and testing scenarios. Among all tested apps,
254 were found to have hijack-enabling ﬂows. Our manual val-
idation on all these suspicious apps shows a true positive rate of
81%. We also conducted detailed case studies on the vulnerable
apps we uncovered, providing practical insight into the vulnerabil-
ity and possible exploits. CHEX is based on Dalysis, our static anal-
ysis framework that directly consumes off-the-shelf Android apps
in bytecode form and supports various types of program analysis
tasks.

The rest of the paper is organized as follows. We study the com-
ponent hijacking problem and present our analysis method in Sec-
tion 2 and 3, followed by the implementation and evaluation of
CHEX and Dalysis in Section 4 and 5. In Section 6, we discuss lim-
itations of our work and possible workarounds. We survey related
work in Section 7 and conclude the paper in Section 8.

2. COMPONENT HIJACKING PROBLEM
Android framework dictates a component-based approach to
app design, for ﬂexible interoperability among apps and efﬁ-
cient app lifecycle management.
In this approach, app develop-
ers organize their code into individual application components [6]
(i.e. Activities, Services, and etc.). Each component ful-
ﬁlls a logically independent task and can serve requests from other
components in the same app, the framework, or another app if the
component is publicly available (or is exported, in Android termi-
nology). For example, an instant messaging app may need a con-
tact enumerator (i.e. collecting all contacts on the device) to suggest
friends for the user. Instead of implementing its own, the app can
leverage an existing contact enumerator component exported by a
contact manager app.

However, the capability of reusing a component under its con-
taining app’s identity can lead to serious security threats, when the
component is security-critical but not well protected. To generalize
threats of this kind, we introduce the concept of component hijack-
ing, describing a class of attacks that seek to gain unauthorized
access to protected or private resources through exported compo-
nents in vulnerable apps. As shown in Figure 1, if the contact man-
ager app fails to deny requests from unauthorized apps, a malicious

Contact Manager AppSetting Update ReceiverEnumerator ServiceContactProviderNetwork InterfacePermission-protectedResources                       Read_Contacts                             InternetPermissions:Receiving external requestsAppFrameworkValueVoIP_PreﬁxKeyfalseIs_App_Lisenced"1234".........App internal DB(non-permission-protected)230subject being detected, than that of the second one. Without loss of
generality, we deﬁne component hijacking attacks as follows:

DEFINITION 1. An unauthorized app, issuing requests to one

or more public components in a vulnerable app, seeks to:

G1 : READ sensitive data out of the app; or
G2 : WRITE to critical data region inside the app; or
G3 : perform a combination of G1 and G2.

Based on this deﬁnition, to determine if a given component (or
set) is vulnerable to hijacking is equivalent to ﬁnding feasible data
ﬂows that can enable any of the three goals above without going
through any security checkpoint. We refer to these ﬂows as hijack-
enabling ﬂows hereafter.
In a simple example, the Emulator
Service in Figure 1 is vulnerable if a hijack-enabling ﬂow exists
that fulﬁlls G1: the ﬂow propagates the contact list into an object to
be returned to the requestor, serving as a data sink from which the
requestor (or attacking app) can read data directly. In a more com-
plex scenario, the data sink may not seem immediately accessible
to the requester (e.g. sending contact to an URL, as shown in Fig-
ure 1). However, if the component contains a hijack-enabling ﬂow
that writes requester-supplied input into certain output-controlling
data (e.g. the destination URL), requestors can still indirectly read
the contact information by redirecting the output and achieve G3.
Component hijacking is also possible on a chain of components,
when the hijack-enabling ﬂows span across component boundaries.
Deﬁning component hijacking from a data ﬂow perspective al-
lows us to transform the vulnerability detection problem into an
equivalent data ﬂow analysis problem. A different but related topic
is data leakage detection [15, 24], which looks for individual data
ﬂows that indicate sensitive data being propagated out of certain
containment scope. Note that apps sending out sensitive data are
not necessarily exploitable nor harmful (e.g. an app sends users’
GPS information to remote servers for location-based services).
Therefore, data leakage detection only reports outbound sensitive
data ﬂows without clarifying their security implications. In con-
trast, component hijacking vulnerability is always exploitable and
undermines user’s privacy. On the other hand, techniques for iden-
tifying component hijacking vulnerability can be applied to ﬁnding
data leaks, but not vice versa. Because ﬁnding data leaks are essen-
tially identifying special hijack-enabling ﬂow that enable G1 with
all data sinks supposed to be accessible by attackers.

Component hijacking gives attackers the freedom to surrepti-
tiously perform privileged actions and access private data. In our
threat model, successful hijacks require users to willingly install
the attacking app on their devices. To create a user population of
decent size, attackers can resort to many illicit techniques that pro-
mote their apps in the market and lure users. Given component
hijacking apps often requesting little to no permissions, users, even
vigilant ones, tend to trust them easily. Although attackers cannot
control, but only hope for, the availability of vulnerable apps on
users’ devices, the reality has been working towards attacker’s fa-
vor due to the large number of under-trained Android developers
and an overall lack of app quality assurance. Therefore, as a de-
fensive effort, we designed CHEX to assist apps developers, testers,
and market operators in ﬁltering out apps vulnerable to component
hijacking attacks before they reach end user devices. We chose
to target CHEX on non-malicious apps, which constitute the ma-
jority of exploitation targets, so that we can safely assume a non-
adversarial application scenario (e.g. heavy obfuscations and anti-
analysis techniques are out of our concern) and solely focus on de-
signing the detection and analysis method.

3. DETECTION AND ANALYSIS METHOD
CHEX follows a static program analysis approach, featuring a
novel data-ﬂow analyzer specially designed to accommodate An-
droid’s special app programming paradigms. Static analysis makes
sense for vetting benign apps in that, the anti-analysis techniques
that are commonly used in adversarial scenarios are out of scope,
and the advantages of static analysis, such as its completeness and
bounded time complexity, are well suited to addressing the vulner-
ability discovery problem.

Existing data-ﬂow analysis and modeling methods are not imme-
diately applicable to Andriod apps due to Android’s special event-
driven programming paradigm. Our ﬂow- and context-sensitive an-
alyzer, incorporated with a number of analysis techniques and mod-
els that we devised for Android apps, can efﬁciently discover data
ﬂows of interest within the entire app. Its underlying ﬂow extrac-
tion mechanism is separated from the high level policies that deﬁne
interesting ﬂows. As a result, our data-ﬂow analysis method can
be applied to other applications than vulnerability discovery. Our
method also offers the ﬂexibility to choose if the Android frame-
work code3 needs to be included or simply modeled during the
analysis, depending on speciﬁc usage scenarios. In this paper, we
model the framework code for reasons discussed in Section 3.2.

Next, we present a concrete example to illustrate component hi-
jacking vulnerabilities, as well as typical challenges associated with
performing data-ﬂow analysis on Android apps.
3.1 A component hijacking example

Our example is a hypothetical Android app that aggregates the
popular location-based services and provides a one-stop solution
for users. Figure 2 shows a critical Service component of the
app. Upon requested by particular Intents, this component ob-
tains user’s location information and synchronizes it with a remote
server. Despite that the component is intended for the app’s in-
ternal use only, its developer carelessly left it open to other apps.
This mistake is not uncommon partly because Android by de-
fault publicly exports components that register to accept particular
Intents. Here, we demonstrate two possible component hijack-
ing attacks on this example app and highlight the challenges asso-
ciated with analyzing the code. The vulnerabilities in this example
app are similar to those that we found in the real apps and reported
in Section 5.2.

In Figure 2, Method onBind (Ln. 5) is invoked by the frame-
work whenever a requester component connects to the Service.
Android programming paradigm dictates that apps organize their
logic into components of different kinds, whose life-cycles are
managed by the framework in an event-driven manner. Each com-
ponent implicitly or explicitly registers event handlers (e.g. Ln. 5,
10, and 32). These handlers serve as the entry points through
which the framework starts or activates the component when han-
dled events happen. Apps, even average-sized ones, can have a
large amount of entry points of diverse object types and appear-
ances, which posed the ﬁrst challenge to our analysis:

C1 : Reliably discovering all types of entry points (or event

handlers) in their completeness.

Method onBind returns to the requester component an object
that implements the IBinder interface (Ln. 6) — a common
pattern to achieve inter-component communications in Android
apps. The requester component can then send messages for the
3Android framework consists of the Dalvik runtime and Android
system libraries. We refer to it as the framework hereafter. Note
that apps (including system apps) are not part of the framework.

231to the variable that controls the URL to be contacted (i.e. realizing
G2).

Sometimes it takes multiple individual data-ﬂows, loosely con-
nected or partially overlapped, to enable one of the three goals de-
scribed in Deﬁnition 1. In our example, two individual data-ﬂows
together allow the attacking app to read the location information
(i.e. by forcing the vulnerable component to retrieve and send the
location information to a speciﬁed URL): one ﬂow carrying loca-
tion data obtained on Ln. 15 to the HTTP Post on Ln. 36 and the
other carrying requester-supplied URL on Ln. 19 to the same HTTP
Post operation. To detect such hijack-enabling ﬂows , a data-ﬂow
analyzer needs to tackle the challenge of:

C3 : Assessing the collective side-effects of individual

data-ﬂows and identifying converged ﬂows of interest.

For optimized responsiveness, Android apps always perform
blocking operations within the doInBackGround method in
AsyncTask4, such as network-send (Ln. 30). The message
handler prepares the network-send parameter with the requester-
supplied URL (Ln. 20). Once execute on the next line is called,
the framework starts doInBackGround (Ln. 32) in a new thread,
introducing another entry point to the component. Code that is
reachable from each entry point is a segment of the entire com-
ponent code. These segments can be statically determined via
reachability analysis. We refer to them as splits (deﬁned shortly).
Although executing in separate contexts, splits are by no means
isolated and in fact can relate to each other through inter-split
data-ﬂows. Heap and global variables used in different split can
form these ﬂows. Note that there exist two hijack-enabling ﬂows
that originate from the split started by handleMessage and
reach to the split started by doInBackground:
(i) the heap
variable currLoc assigned with the location data (Ln. 15) and
used as the HTTP Post content (Ln. 34), and (ii) the local array
sendParams containing the URL (Ln. 20), implicitly passed to
params on Ln. 32 by the framework as an entry point parameter,
and used for the HTTP Post (Ln. 34). Therefore, our analyzer
needs to be capable of:

C4 : Tracking data ﬂows across splits and components.
In summary, this example demonstrates that a component is vul-
nerable to hijacks when it is exported to the public without lim-
iting its interfaces to intended users.
It also shows that using
hijack-enabling data-ﬂows to model the vulnerability is general
and straightforward. A program analyzer aiming at detecting these
ﬂows faces four major challenges imposed by the unique Android
programming paradigms (C1, C2) or by the complications of the
data-ﬂows (C3, C4). Next, we introduce our approach to conduct-
ing data-ﬂow analysis on Android apps, with vulnerability detec-
tion as an application. We propose analysis methods and models
that overcome the challenges discussed above. They are expected
to be useful to other types of app analysis as well.
3.2 Analysis methods and models

The reason why we chose to model the framework, instead of
including all its code into the analysis scope, is because of the
complexity of analyzing the framework code and the simplicity of
modeling its external data-ﬂow behavior. Due to the framework’s
extensive use of reﬂections, mixed use of programming languages,
and overwhelming code size, including the framework code into
the analysis scope incurs a signiﬁcant amount of overhead and in-
troduces certain extent of inaccuracy to the analysis. Therefore,
4A convenient threading construct provided by the framework.

Figure 2: Vulnerable component example

Service to handle via the object. It is the framework that deliv-
ers the message and invokes handleMessage as an entry point
(Ln. 10) when an incoming message arrives. Since the invocations
of different entry points in an app can be asynchronous, we faced
the second challenge:

C2 : Soundly modeling the asynchronous invocations of entry

points for analysis.

Once connected to the example Service, an attacking app
can exploit at least two separate component hijacking vulnerabil-
ities to obtain the device location and perform network commu-
nications respectively, neither incurring any permission violations
or user interactions. Speciﬁcally, the attacking app can send a
MSG_UPDATE_LOCATION message, followed by a MSG_SYNC_
LOCATION message, to coerce the message handler to ﬁrst re-
trieve the device location (Ln. 15) and then send the data to a
URL of the attacker’s choice (Ln. 21). Alternatively, using a sin-
gle MSG_SYNC_LOCATION message, the attacking app is able to
make connections to arbitrary URL he supplies in the message.
Based on Deﬁnition 1, these two particular cases of component
hijacking are enabled by data-ﬂows that respectively allow the at-
tacker to (i) read the location data (i.e. realizing G1), and (ii) write

1publicclassSyncLocSrvextendsService{2LocationcurrLoc;3finalMessengermMessenger=newMessenger(newReqHandler());45publicIBinderonBind(Intentintent){6returnmMessenger.getBinder();7}89privateclassReqHandlerextendsHandler{10publicvoidhandleMessage(Messagemsg){11...12switch(msg.what){13caseMSG_UPDATE_LOCATION:14//getGPSlocation15currLoc=lm.getLastKnownLocation(PROVIDER);16break;17caseMSG_SYNC_LOCATION:18//syncGPSwithspecifiedURL19Stringurl=msg.getData().getString("url");20String[]sendParams=newString[]{url};21newSendToNetwork().execute(sendParams);22break;23...24default:25...26}27}28}2930privateclassSendToNetworkextendsAsyncTask<String,String,String>{31//runinaseparatethread32protectedStringdoInBackground(String[]params){33HttpClienthc=newDefaultHttpClient();34HttpPostpst=newHttpPost(params[0]));//URL35pst.setEntity(newStringEntity("gps:"+currLoc));36HttpResponseresp=hc.execute(pst);37returnresp.toString();38}39}40...41}Listing1:VulnerablecomponentexampleC2:Soundlymodelingtheasynchronousinvocationsofentrypointsforanalysis.OnceconnectedtotheexampleService,anattackingappcanexploitatleasttwoseparatehijackingvulnerabilitiestoobtainthedevicelocationandperformnetworkcommuni-cationsrespectively,withoutrequiringanypermissionsoruserinteractions.AMSG_UPDATE_LOCATIONfollowedbyaMSG_SYNC_LOCATIONmessagefromanattackercancoercethemessagehandlertoﬁrstretrievethedevicelocation(Ln.15)andthensendthedatatoaURLoftheattacker’schoice(Ln.21).Alternatively,withasingleMSG_SYNC_LOCATION,anattackerisabletomakearbitraryconnectionstoanyURLhesuppliedinthemessage.BasedonDeﬁnition1,thesetwoparticularcasesofcomponenthijackingareasso-ciatewithhijack-enablingﬂowsthatrespectivelyallowtheattackerto(i)readthelocationdata(i.e.realizingG1),and(ii)writetothevariablethatcontrolstheURLtobecon-tacted(i.e.realizingG2).Ingeneral,hijack-enablingﬂowsoftenconsistofmulti-pleindividualdata-ﬂowsthatareeitherlooselyconnectedorpartiallyoverlapped.TheycollectivelyenableoneofthethreegoalsdescribedinDeﬁnition1.Inourexample,twoin-dividualdata-ﬂows–onecarryinglocationdataobtainedonLn.15totheHTTPPostonLn.36andtheothercarryingrequester-suppliedURLonLn.19tothesameHTTPPostoperation–formthehijack-enablingﬂowsthattogetheral-lowanattackertoreadthelocationdata.Thecapabilityofdetectingsuchhijack-enablingﬂowshingesonnotonlyanaccuratedata-ﬂowtracker,butmoreimportantly,anana-lyzerthattacklesthechallengeof:C3:Assessingthecollectiveside-e↵ectsofindividualdata-ﬂowstoidentifyconvergedﬂowsofinterest.Duetotheasynchronousinvocationsofentrypointswithunknowncall-sites,trackingdata-ﬂowsarenotasstraight-forwardinAndroidappsasintraditionalprograms.Codethatisreachablefromeachentrypointisasubsetoftheen-tirecomponentcodeandcanbestaticallydetermined.Werefertothesesubsetsassplits(deﬁnedshortly).However,splits,thoughrepresentingseparateexecutioncontexts,arebynomeansisolatedandinfactcanrelatetoeachotherwithinter-splitdata-ﬂowsthatareenabledbyheaporglobalvariables,orcreatedbytheframework.Intheexample,toimprovetheappresponsiveness,thenetworkrelatedoper-ationissettoexecuteasanAsyncTask(i.e.aconvenientthreadingconstructprovidedbytheframework).OnLn.21,handleMessagepreparestheparameterforSendToNetworktaskwiththerequester-suppliedURLandthenleavesitfortheframeworktostartdoInBackGround(Ln.32)inanewthreadwiththeparameter–essentiallyintroducinganotherentrypointtothecomponent.Notethatthereexisttwohijack-enablingﬂowsthatcrosstheboundarybetweenthesplitsstartedbyhandleMessageanddoInBackground:(i)theheapvariablecurrLocassignedwiththelocationdata(Ln.15)andusedastheHTTPPostcontent(Ln.34),and(ii)thelocalarraysendParamscontainingtheURL(Ln.20),implicitlypassedtoparamsonLn.32bytheframework,andusedfortheHTTPPost(Ln.34).Similarly,hijack-enablingﬂowscanhappenacrosscomponentstoo.Therefore,ouranalyzerneedstobecapableof:C4:Trackingdataﬂowsacrosssplitsandcomponents.Insummary,theexampledemonstratesthatacomponentisvulnerabletohijackswhenitisexportedtothepub-licwithoutassuringtoonlyacceptrequestsfromintendedusers.Italsoshowsthatusinghijack-enablingdata-ﬂowstomodelthevulnerabilityisgeneralandstraightforward,butaprogramanalyzeraimingatdetectingthoseﬂowsfacesfourmajorchallengesimposedbytheuniqueAndroidpro-grammingparadigms(C1,C2)orbythecomplicationsofthedata-ﬂows(C3,C4).Next,weintroduceourapproachtoconductingdata-ﬂowanalysisonAndroidapps,withvul-nerabilitydetectionasanapplication.Weproposeanalysismethodsandmodelsthatovercomethechallengesdiscussedaboveandareexpectedtobeusefultootherapplicationsaswell.3.2AnalysismethodsandmodelsThereasonwhywechosetoexcludetheframeworkoutoftheanalysisscope,andwebelievemostdata-ﬂowanalysisofappsshoulddothesame,isbecauseofthecomplexityofanalyzingtheframeworkcodeandthesimplicityofmodel-ingitsexternaldata-ﬂowbehavior.Theoretically,whentheframeworkcodeisincluded,theanalysisscopecontainstheentireprogramcodethatcanbeexecutedwithintheapp’s4232Algorithm 1 Entry points discovery

Mf ← {Uncalled framework methods overridden by app}
Ma ← {App methods overriding framework}
E ← {Listeners in Manifest; Basic component handlers}
repeat

G ← BuildCallGraph(E)
for all ma ∈ Ma ∧ ma overrides mf ∈ Mf do

if ma’s constructor ∈ G then

E ← E ∪ {ma}

end if
end for

until E reaches a ﬁxed point
output E as entry point set

analysis that only require a partial knowledge on the framework’s
external behavior, such as data-ﬂow analysis, should model rather
than diving into the framework, to avoid unnecessary performance
overhead and inaccuracy. In addition to modeling the framework
in terms of its data-ﬂow behavior, our analysis requires type in-
formation of framework-deﬁned classes (the app-level classes are
derived from these types). We will show in Section 4 that, such
information can be easily extracted from the framework, which the
analyzer uses to build the complete class hierarchy.

Entry point discovery: As the ﬁrst step to deal with the multi-
entry-point nature of apps and tackle C1, we designed an algorithm
that discovers entry points in app code at a very low false rate, with-
out requiring analyzing the framework code. To avoid ambiguity,
we use the following deﬁnition of entry points in this paper:

DEFINITION 2. App entry points are the methods that are de-
ﬁned by the app and intended to be called only by the framework.
Entry points in an app can be large in amount, often with a great
variety in their object types. For instance, each UI elements in
an app can deﬁne multiple event listeners to be called at different
moments as particular events happen. Similarly, each component
can implement handlers to get notiﬁed about its life-cycle changes.
Therefore, we avoided any manual efforts that use expert knowl-
edge to generate sets of possible entry points, due to its error prun-
ing nature and no guarantee for completeness.

Since the entry point methods are supposed to be called by the
framework, the latter then requires the prior knowledge about these
methods.
In fact, there are only two ways for an app to deﬁne
entry points that can be recognized by the framework: either via
explicitly stating them in the manifest ﬁle, or implicitly overriding
methods or implementing interfaces that are originally declared by
the framework as app entry points. Those deﬁned using the ﬁrst
option can be determined by parsing the manifest. To ﬁnd the
rest, our algorithm ﬁrst generates the set of uncalled methods in the
app that override their counterparts declared in the framework, and
then excludes methods that are unreachable even by the framework
(i.e. dead methods). Telling apart entry points from dead methods
that override the framework, despite neither is called by the app, is
based on two facts unique to entry points: (i) the containing class of
any entry point always have at least one instantiated object (since
app entry points are non-static methods), and (ii) there should be
no app-level invocation on the original method that the entry point
overrides or on any decedents of the original method in the class
hierarchy. In contrast, dead methods that override the framework
mostly cannot satisfy both conditions.

Our entry point discovery method, as formulated in Algorithm 1,

follows an iterative procedure until a ﬁxed point is reached for the
entry point set E. Method set Mf and Ma are generated by a sim-
ple scan of the class hierarchy and all call sites in the app code.
E is initialized to include entry points declared in manifest ﬁles
and basic component-life-cycle handlers deﬁned in the code. Com-
pared with other entry points, the component-life-cycle handlers
have very few types and are the only entry points whose containing
class is created by the framework (i.e. calls to their constructors are
invisible at the app level). During each iteration, a new call graph
G is built based on the already discovered entry points in E. Due
to the new entry points added in the last iteration, the new G may
contain previously unreachable methods and classes instantiations.
A method ma ∈ Ma is added to E as a new entry point when ma
overrides a framework method or interface mf ∈ Mf and ma’s
containing class is instantiated in G. We build the call graph us-
ing the entire E, rather than just using the newly discovered entry
points in the previous iteration, so that the point-to analysis sup-
porting the call graph builder can be as complete and accurate as
possible. The algorithm terminates when E stops growing and con-
tains all possible entry points. Very rare false positives can happen
only when framework-declared methods are never called in the app
while they are already overwritten by instantiated classes and made
for app use.

App code splitting: Once all entry points are discovered, we model
their asynchronous invocations and addresses C2 with a novel tech-
nique named app code splitting. We deﬁne the concept of splits as
follows:

DEFINITION 3. A split is a subset of the app code that is reach-

able from a particular entry point method.

From a static analysis perspective, app executions can be viewed
as a collection of splits executing in all feasible orders, possibly
interleaved. The idea of modeling app execution in terms of splits
may seem challenging at the ﬁrst glance. However, constrains im-
posed by the framework and our focus on data-ﬂow analysis signif-
icantly simplify the realization of the idea. In fact, most splits in an
app can only be executed in a sequential order (i.e. not interleav-
ing each other), because the framework invokes the majority of app
entry points in the main thread of an app. The mere exceptions are
entry points of concurrency constructs, such as threads. Since our
goal is to perform security vulnerability detection, concurrency-
incurred data-ﬂows are usually not a concern in this context due to
their extreme unreliability to be reproduced or exploited. There-
fore, we can safely approximate the app execution as sequen-
tial permutations of splits that are feasible under framework con-
straints.

Under this app splitting model, our data-ﬂow analysis ﬁrst com-
putes the split data-ﬂow summary (SDS) for each split in the app. It
then starts the permutation process and, for each possible sequence
of splits, generates permutation data-ﬂow summary (PDS) by link-
ing the SDS of each split in the sequence. As the permutation pro-
ceeds, each PDS is checked for interesting data-ﬂows speciﬁed by
pre-deﬁned policies. Eventually, all possible data-ﬂows can happen
in the app are enumerated.

Figure 3 shows two SDS marked by dashed boxes. They are
generated based on the two entry points, handleMessage and
doInBackground, in our example discussed in Section 3.1. An
SDS consists of intra-split data-ﬂows whose end nodes represent:
(i) heap variables5 entering or exiting the split scope (depicted by

5Variables with a global scope, as opposed to local variables.

233information or requester’s input. We also deﬁne three general
sinks to mark end points of interesting-ﬂows that are to make data
publicly accessible (Tag_PublicSink), make data accessible
to speciﬁed entities (Tag_SpecifiedSink), or write data into
critical data regions (Tag_CriticalSink). With these tags de-
ﬁned, we can easily convert Deﬁnition 1 into three simple policies
to capture hijack-enabling ﬂows:

{Tag_SensSrc ; Tag_PublicSink}

P1 :
P2 : {Tag_InputSrc ; Tag_CriticalSink 1
Tag_SensSrc ; Tag_SpecifiedSink}
P3 : {Tag_InputSrc ; Tag_CriticalSink}

These policies are checked on every newly generated PDS as the
split permutation continues. As for the example discussed in Sec-
tion 3.1, our analyzer can detect the hijack-enabling ﬂows, satisfy-
ing P2 and P3, from a PDS that links the SDS of handleMessage
with that of doInBackGround, as shown in Figure 3.

The PDS generation is carried out by two basic operations –
link and unlink an SDS. The link operation adds a new SDS into a
PDS if inter-split data-ﬂows exist from the latter to the former. It
draws data-ﬂow edges (e.g. the two thick edges in Figure 3) from
leaf nodes in the PDS to those reachable root nodes in the new
SDS. For Android apps, the only two channels through which data
can ﬂow across splits are: heap variables sharing the same loca-
tion key tuple, and framework API pairs that transit data among
splits. We introduce a pair of special tags, Tag_TransSink and
Tag_TransSrc, to model these API pairs. The link operation
can reject the SDS if no edge can be drawn and the SDS does not
contain ﬂows starting with any pre-deﬁned source. A rejection sug-
gests that the new SDS has no effect on any potential propagation
of interesting-ﬂows in the current PDS, and thus, there is no need
to add it. Unlink operation simply reverts the last link operation.

Intuitively iterating through all split permutations can be a pro-
hibitively expensive operation for apps with a large number of en-
try points. We leverage on the continuity of data-ﬂows across splits
to carry out a simple but effective search pruning. The depth-ﬁrst
search only appends an SDS to the current permutation if it is ac-
cepted by the link operation and then continues iterating along that
path. As shown in Section 5, this pruning greatly reduces the search
space and time overhead of the permutation process. The permu-
tation also considers a few constraints on the launch order of splits
that handle life-cycle events of basic components (e.g. entry points
relating to component initialization and termination are called in
ﬁxed orders).

Finally, C4 is addressed, because all interesting-ﬂows in an app,
both intra-split and inter-split ones, are constructed during the split
permutation process. Our app splitting technique enables a data-
ﬂow analysis that is more efﬁcient and better accommodates the
event-driven nature of Android apps, than the conventional meth-
ods, which synthesize a main function explicitly invoking event
handlers. App splitting creates a divide-and-conquer theme. The
sub-problems (i.e. constructing intra-split data-ﬂows and SDS) are
signiﬁcantly easier and smaller in scale than the original problem
(i.e. constructing data-ﬂows for an entire app, as faced in the con-
ventional methods). The merge process (i.e. permuting splits) can
be very fast, as shown in Section 5. Moreover, due the mutual inde-
pendence among SDS, they can be built in parallel and cached for
reuse (e.g. SDS for common libraries can be built once and reused
when analyzing all apps that make use of them) to further improve
the performance.

Figure 3: Linked-SDS for the running example

octagons); or (ii) pre-deﬁned sources or sinks (depicted by rectan-
gles). We omitted intermediate nodes in the SDS in Figure 3 to ease
illustration. In essence, an SDS only contains data-ﬂows within a
split that may contribute to connecting a source to a sink (may re-
sides in another split). We refer to these data-ﬂows as interesting-
ﬂows hereafter. The upper SDS in Figure 3 has two isolated data-
ﬂows: the one on the left propagates the location data (a sensitive
source, tagged as Tag_SensSrc) to a heap variable currLoc,
and the one on the right carries the requester’s input (tagged as
Tag_InputSrc) to a transit sink; The lower SDS captures the
convergence of a heap variable and a transit source at a sink associ-
ated with two tags (Tag_DataSink and Tag_CriticalSink,
explained shortly). We compute SDS via a context- and ﬁeld-
sensitive data dependence analysis, identifying interesting-ﬂows in
the current split. As Figure 3 shows, heap variables are represented
by their heap location key, which is a three-tuple in the form of
(f ield, allocSite, method), indicating the f ield whose contain-
ing object was allocated at allocSite in method (f ield of any ar-
ray object is null). Pre-deﬁned sources and sinks (data entry or
exit points of the analysis’s interest) are represented by a four-tuple,
(method, paramIndex, tag, callSite), indicating that a parame-
ter of a method called at callSite is a source or sink depending on
the tag. Note that in Figure 3 the line numbers of allocSites and
callSites that are not shown in Figure 2 are substituted by capital
letters (e.g. Ln.X).

Our analysis method allows for a fairly ﬂexible way of deﬁning
and extending tags associated with sources and sinks. Tags are used
to differentiate sources and sinks with different semantic meanings
given by the analyzer users based on their speciﬁc usage scenarios.
Policies that specify interesting-ﬂows can be deﬁned based on the
tags associated with their end nodes:

P := Fint 1 [Fint | ∅]n, Fint

:= [T ag] ; [T ag],
where 1 deﬁnes a join relationship exists between two interesting-
ﬂows (i.e. two ﬂows, or their extensions, intersect or converge with
each other), and ; deﬁnes an interesting ﬂow with two end nodes
of speciﬁed tags. By supporting customizable tags and the join
relationship in deﬁning interesting-ﬂows, our analyzer provides a
means of expressing the side-effects of converged ﬂows on a se-
mantic level, which solves C3.

For component hijacking vulnerability detection, we deﬁne two
general source tags, Tag_SensSrc and Tag_InputSrc, to
mark the start points of interesting-ﬂows that propagate sensitive

SDS: handleMessage(getLastKnownLocation, -1, Tag_SensSrc, Ln.15)(handleMessage, 1, Tag_InputSrc, Ln.N)(SendToNetwork.execute, 1, Tag_TransSink, Ln.21)SDS: doInBackground(currLoc, Ln.X, <init>)(doInBackground,(1, Tag_TransSrc, Ln.M)(HttpClient.execute,1, Tag_DataSink^Tag_CriticalSink, Ln.36)(currLoc, Ln.X, <init>)2344.

IMPLEMENTATION OF DALYSIS AND
CHEX

We built a generic Android app analysis framework named Dal-
ysis, which stands for Dalvik bytecode analysis. As suggested by
its name, Dalysis directly works on off-the-shelf app packages (or
Dalvik bytecode) without requiring source code access or any de-
compilation assistance. Previous app analysis efforts that relied
on decompiled source code have two major drawbacks — heavy
performance overhead and incomplete code coverage. As reported
by Enck et al. [16], the state of the art technique to decompile
an app, on average, takes about 27 minutes and leaves 5.56% of
the source code failed to be recovered. Conducting analysis at the
dalvik bytecode level overcomes these issues. In addition, unlike
x86 binary code, bytecode retains sufﬁcient program information
from the high level language and does not have any parsing ambi-
guity, thus serves as an ideal analysis subject.

To our best knowledge, Dalysis is the ﬁrst generic analysis
framework that operates on Dalvik bytecode and intended to sup-
port multiple types of program analysis tasks. Next, we introduce
the internals of Dalysis that can facilitate the understanding of the
implementation of CHEX, our component hijacking analyzer built
based on Dalysis. We leave out the low-level system building de-
tails as they are out of the scope of this paper.
4.1 Dalysis framework

The front end of Dalysis consumes an Android app package
(.apk) at a time.
It retrieves package information from meta-
data ﬁles and translates the Dalvik bytecode into an intermediate
representation (IR), based on which the back end analyzers carry
out their tasks. The front end starts the IR generation process by
parsing the input bytecode ﬁle. Dalysis employs an open source
Dalvik bytecode parser named DexLib, part of a well-known dis-
assembler for Android apps [2]. DexLib provides useful inter-
faces to programmatically read embedded data, type information,
and Dalvik instructions from a bytecode ﬁle. Dalysis allows differ-
ent analysis to choose either include the entire Android framework
code or model its external behaviors, which is achieved by linking
two different versions of the runtime library into the analysis scope.
The front end constructs the class hierarchy, performs an semanti-
cal IR translation from Dalvik and Java bytecode (Android frame-
work libraries are compiled into java bytecode), and then hands
over the IR to backend analyzers.

We adopted our IR from the WALA project [5], a popular static
analysis framework for Java, for two reasons: the semantic prox-
imity between Dalvik bytecode and the IR and a wide selection of
basic analyzers developed for the IR by the WALA community. The
translation process is mostly straightforward, since both instruction
sets follow the register-machine model and retain a similar amount
of information from the same high level language (i.e. Java).
However, a handful of instructions that are unique to Dalvik vir-
tual machine require special handling during the translation pro-
cess. For example, the filled-new-array instruction allo-
cates and initializes an array in one step; And the move-result
instruction retrieves the result of the previous call from the spe-
cial result-register. Following the semantic translation is
the ﬁnal task for the front end – static single assignment (SSA)
conversion. The conversion performs an abstract interpretation on
each method, wherein the deﬁne-use chain is determined for each
Dalvik register as well as its mapping to the local variable on Java
level. New instructions are generated, as a side effect incurred by
the ﬂow function of the abstract interpretation. As a result of vari-
able renaming (i.e. a register model conversion), newly generated

Figure 4: CHEX workﬂow

instructions operate on a conceptual register model with unlimited
registers, each of which can only be assigned once as required by
SSA form. Meet operations happen at basic block boundaries.
As a result, φ variables are generated to merge two or more val-
ues that may ﬂow into a same variable in the current basic block
from predecessors in the control ﬂow graph. Converting the IR into
SSA form can simplify various types of program analysis, espe-
cially data-ﬂow related ones, such as deﬁnition reachability test,
constant propagation and etc. In fact, many existing analyzers for
WALA assume an SSA IR.

The back end of Dalysis hosts a variety of analyzers and provides
them the interfaces to access the IR, the class hierarchy, and other
useful information. Some basic analyzers released by WALA, such
as the point-to analysis and the call graph builders, are included
in Dalysis. These building-block analyzers can be found useful
by many advanced analyzers. Dalysis itself is not speciﬁc to any
particular ﬂavor of app analysis — it is designed to be a generic
framework that can enable as many types of analysis as possible on
Android apps. For example, CHEX demonstrates how we imple-
mented the data-ﬂow analysis methods, introduced in Section 3.2,
by using the Dalysis framework.

Dalysis is implemented in Java with 15,897 lines of source code,
excluding 3rd party libraries. The building process took us a signif-
icant amount of efforts due to a lack of similar work and reusable
code. But most efforts were spent on tackling engineering related
issues or implementing existing algorithms from the programming
language community, therefore we do not intend to claim these ef-
forts as contributions in this paper. We also omit the implementa-
tion details of Dalysis that should be oblivious to analyzer design-
ers, which is out of the scope of this paper.

4.2 CHEX: Component hijacking examiner

CHEX realizes our data-ﬂow analysis methods and models dis-
cussed in Section 3.2.
It detects hijack-enabling ﬂows based on
policies P1-3, with a set of 180 sources and sinks that match the
tags deﬁned by these two policies. This set was constructed semi-
automatically to cover a relatively wide range of hijack-enabling
ﬂows that affect the sensitive resources managed by the system
(i.e. protected by Android permissions and accessed uniformly
across apps). Parts of the sensitive sources (Tag_SensSrc) were
selected based on the API-to-permission mapping provided by [19].
This set is adequate for our testing and evaluation purpose, but it is
not meant to be complete. In fact, it can be extended with source
and sinks speciﬁc to individual apps, so that CHEX can capture
hijack-enabling ﬂows in app’s semantics.

As shown in Figure 4, entry point discovery starts at ﬁrst.

It
queries Dalysis front-end for information necessary to the ini-

APKSDSSDSPDSHijack-enablingFlow RecordsEntry PointDiscovery1SDSGeneration2Split Permutation & PDS Generation34235tialization process, such as event listeners deﬁned in manifest
and method overloading relationships (shown in Algorithm 1).
CHEX makes multiple different uses of the call graph builder from
WALA, which can be conﬁgured to have different degrees of context
sensitivity. For each iteration in the entry point discovery process,
we generate a context-insensitive call graph, for the least perfor-
mance overhead and the unnecessity of context sensitivity in this
scenario (i.e. we use the call graph only to conservatively estimate
if a method was called or a class was instantiated before).

For each discovered entry point, or more speciﬁcally, the split
started by that entry point, CHEX builds an SDS to summarize
its data-ﬂow behaviors that may contribute to forming any hijack-
enabling ﬂow (Step 2 in Figure 4). Building SDS is a computation
heavy step in the entire analysis because it is where all intra-split
data-ﬂows are constructed directly by analyzing the IR. In compar-
ison, in a later step, the permuter generates inter-split ﬂows and
PDS based on simple rules determining the connectivity between
two intra-split ﬂows.

Conventional data-ﬂow analysis approaches solve data-ﬂow equa-
tions through an iterative process. This process is expected to
reach a ﬁx-point after limited iterations of basic-block state changes
made by transfer functions. However, for the purpose of build-
ing SDS, we can safely avoid this procedure and still be able to
check interesting-ﬂows, thanks to the SSA IR and our abstraction of
the ﬂow checking problem. Speciﬁcally, the SSA conversion car-
ried out by the front end has already conducted a basic data-ﬂow
analysis and saved information (e.g. variable use-deﬁne chains and
etc.) that can greatly facilitate the construction of system depen-
dence graphs. Inspired by the way of utilizing system dependence
graphs in the classic program slicing algorithm [25], we convert the
problem of checking interesting data-ﬂows into an equivalent graph
reachability test problem. We test the connectivity of source-sink
pairs on customized system dependence graphs that only have data-
dependence edges (referred as data-dependence graph, or DDG).
A source-sink pair that is connected on a DDG indicates the exis-
tence of a data-ﬂow from the source to the sink. Compared with the
conventional approaches, this abstraction offers us a better leverage
on the existing IR and avoids unnecessary analysis work, yet still
achieving the same goal.

DDG is constructed in a similar way as system dependence graph
is in [25], but without generating control-dependence edges. Each
node in DDG represents either a normal SSA statement or an ar-
tiﬁcial statement to model inter-procedure parameter passage. An
edge is drawn from node S1 to node S2 only when the variable de-
ﬁned by S1 is directly used by S2. Intra-procedural edges between
scalar variables are drawn with the help of local use-deﬁne chains
implied from the SSA IR. Identifying inter-procedural dependen-
cies among heap variables requires a call graph with a proper de-
gree of context sensitivity and an inter-procedural deﬁnition reach-
ability analysis. We chose a 0-1-CFA call graph builder with the
call-string context sensitivity (i.e. using the calling string to
identify a particular node in the call graph), for its sufﬁcient ac-
curacy and acceptable performance overhead. With the call graph,
regular parameter and return passing edges can be added between
the corresponding callers and callees. The deﬁnition reachability
analysis provides information about (transitive) heap variable ac-
cesses in a method, which is needed to create heap related nodes
and draw edges between them (inter-procedural heap variable ac-
cesses are modeled as artiﬁcial parameters or returns).

Before used for the interesting-ﬂow discovery, a DDG needs to
go through an edge inﬂation process, as a way to model data depen-

dencies that are still missing. Missing edges are resulted from out-
of-scope code (i.e. methods deﬁned outside of the analysis scope).
Thus we need to model the external data-ﬂow behavior of such
code. The modeling can be easily done by means of adding arti-
ﬁcial edges into the DDG, bases on two simple rules: (i) for meth-
ods with returns, the return value is dependent on all parameters
(i.e. drawing edges from each ParameterCaller node to the
ReturnCaller node); and (ii) for return-less methods, the ﬁrst
parameter (i.e. this* for non-static methods) is dependent on all
other parameters, if any (i.e. drawing edges to the deﬁne node of
the ﬁrst parameter from other ParameterCaller). Exceptions
to these rules do exist, but only very few happen frequently enough
that we need to specially handle, such as several methods of strings
and collection types.

With the DDG is generated, searching for interesting ﬂows be-
comes intuitive. CHEX ﬁrst picks two sets of nodes from the
graph, Sstart and Send, where Sstart contains pre-deﬁned sources
(i.e. start points of inter-split ﬂows), and Send contains pre-deﬁned
sinks (i.e. end points of inter-split ﬂows). CHEX then constructs the
SDS as it traverses the DDG – a ﬂow is added to the SDS if it starts
from a node in Sstart and ends with a node in Send. The result-
ing SDS serves as a gadget for the permuter to compute PDS (Step
3 in Figure 4). Although the SDS building process is the most
computation-intensive step during the entire analysis, the prob-
lem size is already greatly reduced, comparing with conducting
the similar analysis on the whole app without app splitting. Tasks
performed during the SDS construction, such as point-to analysis,
generally scale poorly as the app size increases. Therefore, divid-
ing the app into smaller but self-contained splits can help with the
performance, and alleviates the scalability issue for large apps. In
addition, due to their independence, SDS constructions for differ-
ent splits can be carried out in parallel in performance-critical and
computing-resource-rich scenarios, to further reduce the overhead.
The split permuter always starts a new sequence with a split
from an exported component, a constraint to reﬂect the causal re-
lationship between external requests and potential hijack-enabling
ﬂows. The permutation is implemented as a regular depth-ﬁrst-
search with pruning and conﬁgurable search space. For example,
the maximum DFS depth speciﬁes the maximum number of splits a
feasible hijack-enabling ﬂow can span through, a practical trade-off
between performance and completeness. As the permutation pro-
ceeds, interesting ﬂows in the current PDS are matched with poli-
cies P1-P3 for hijack-enabling ﬂows. Node tags and the ; relation
can be simply checked on individual interesting ﬂows. As for the 1
relationship, we test if two interesting ﬂows merge into a new vari-
able or join at a same method call site. Discovered hijack-enabling
ﬂows are recorded (Step 4 in Figure 4) with detailed information,
such as the corresponding paths in PDS, the split sequence, and the
policy they satisfy. Such information can assist app developers or
security researchers to verify and ﬁx vulnerabilities.

CHEX consists of 5,945 lines of Java code. When linked with the
dependencies in Dalysis, it can be built into a standalone program
and deployed to vet real-world apps, as we did when evaluating it.

5. EVALUATIONS AND EXPERIMENTS

We carried out an in-depth evaluation on CHEX in terms of its
performance and accuracy.
In addition, our large-scale empiri-
cal experiment revealed interesting facts about vulnerable Android
apps, which are expected to contribute to a community awareness

236(a) Instruction Count vs. Time

(b) Entry Point Count vs. Time

(c) SDS Count vs. Time
Figure 5: Execution Time Characteristics of CHEX

(d) SDS Node Count vs. Time

of real-world component hijacking vulnerabilities and caveats of
analyzing them.

5.1 System evaluation

We exercised CHEX with a large set of real-world apps, Spop,
containing about 5,486 free popular apps we collected in late 2011.
Spop consists of around 3,486 apps from the ofﬁcial Android mar-
ket and 2,000 from alternative markets. The experiments were con-
ducted on a cluster of three computers, each equipped with an Intel
Core i7-970 CPU and 12GB of RAM. During the experiments, we
launch concurrent CHEX instances on 64-bit JVM with a maximum
heap space of 4GB. To optimize the throughput, we limit the pro-
cessing time of each app within 5 minutes.
Performance: We instrumented CHEX to measure its execution
time while it examining apps in Spop. The median processing time
for an app is 37.02 seconds with the interquartile range (IQR) of
161.87 seconds, which suggests that CHEX can quickly vet a large
amount of apps for component hijacking vulnerabilities. 22% apps
needed more than 5 minutes to be analyzed thus timed out in our
experiments. In practice, with more computing resources available,
a more generous time-out value should be used.

We found that CHEX’s execution time varies signiﬁcantly across
different apps. As a result, we studied the impact of four app-
speciﬁc factors that may affect CHEX’s execution time the most
(see Figure 5). Although these factors are in a strong correlation
with the execution time, no single factor dominates it (i.e. none
poses major bottleneck to the performance). Furthermore, we de-
composed the execution time into three parts, corresponding to the
three analysis phases each app goes through, as shown in Figure 6).
In general, SDS construction (or split permutation) causes the ma-
jority of the time overhead, whereas entry point discovery and DFS
generation often ﬁnish fast.
Some ﬁndings acquired during the evaluation also prove that the
app analysis challenges we tackled in this work (C1− C4) are very
common to encounter when analyzing real apps. On average, we
found 50.37 entry points of 44 unique class types in an app. More-
over, the number of entry points is not directly related to the app
size. Apps implementing complex user interfaces or requiring fre-
quent user interactions (e.g. games) tend to have more entry points
than others. About 99.70% of apps contain inter-split data ﬂows,

Figure 6: Performance Decomposition

which strongly indicates the necessity of analyzing such ﬂows the
contexts created by different entry points.

Accuracy: Among the 5,486 apps in Spop, CHEX ﬂagged 254 as
potentially vulnerable to component hijacking attacks. Due to the
lack of a ground truth, we manually veriﬁed all the ﬂagged apps by
checking if the discovered hijack-enabling ﬂows are indeed feasi-
ble and exploitable by attackers. This veriﬁcation process largely
replied on human expert knowledge with the assistance of well-
known Android app disassemblers and decompilers.
In the end,
we identiﬁed 48 ﬂagged apps as false positives, which yields a true
positive rate above 81%. The main causes for the false positives
are infeasible split permutations and apps’ complicated input vali-
dations that CHEX cannot understand. Although the false positive
rate is acceptable in a vulnerability ﬁltering scenario, we argue that
the ﬁrst cause can be minimized by incorporating Android domain
knowledge into the permutation pruning logic, while the second
cause is a difﬁcult but orthogonal issue to this work (i.e. checking
the quality of program’s input validation).
5.2 Case studies

Our manual veriﬁcation process also helped us gain practical in-
sights into the component hijacking vulnerabilities. All 206 apps
that are conﬁrmed as vulnerable can be roughly categorized into
ﬁve classes, as shown in the ﬁrst column of Table 1. It clearly shows
that, in addition to vulnerabilities exploited by confused deputy at-
tacks on the Android permission system, other vulnerability classes
also fall into the scope of component hijacking and can be detected
by CHEX. The second column refers to Deﬁnition 1 and indicates
the hijacking type for each vulnerability class. To improve the com-
munity’s awareness and understanding of component hijacking, we
selected at least one app from each class and conducted the fol-
lowing case studies. We hide part of the app package names as a
precaution to not leak undisclosed vulnerability information.

Case A1 in the data theft class resembles the example app we
used in Figure 2. One of its components obtains the GPS location
and saves it to a global variable. Another component initializes
a URL parameter using a string provided by an arbitrary app via
Intent, and sends the GPS information to the URL. An attacker thus
can steal the sensitive location information by sending a crafted
Intent to the second component, causing the GPS location to be
sent to the attacker controlled server.

Apps can also leak their private, permission-protected capabili-
ties through public components, as previously reported. Case B1
has a public component that takes a string from another app’s In-
tent and uses it as a URL for Internet connection. Likewise, a
public component of case B2 uses a string from an Intent as the
host name for socket connections. These vulnerable apps essen-
tially give out the Internet permission to all other apps who may

050010001500050150250Instruction count (K)Time (secs)++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++050100150200050150250Entry Point CountTime (secs)0100200300400050150250SDS countTime (secs)0200040006000800010000050150250SDS Node countTime (secs)05001000150020002500050100150200250300App idTime (secs)SDS timeEntrypoint timeDFS time237Table 1: Detected vulnerability class and case-studied apps

not have it. For example, a malicious app can exploit these apps to
transmit information to an arbitrary Internet server, or even launch
network attacks against a victim server. We have observed Inter-
net capability leakages in both Activity and Service components of
vulnerable apps. In the cases of Activity components, the exploited
components can be forced to display speciﬁed remote content to
the user; Whereas exploits on vulnerable Service components can
be carried out more stealthily, because Service components exe-
cute in the background (in this case, communicating with attacker
controlled servers) without interacting with users.

Intent proxy is another class of vulnerabilities that can be ex-
ploited in a fashion similar to capability leak. Case C1 accepts an
input Intent (X) that embeds another Intent (Y ). It then starts a
new Activity per Y ’s request using its own identity. More speciﬁ-
cally, in the OnResume() function of C1, the Intent Y is retrieved
from the Bundle object through the key “intent”. Next, Intent Y is
directly passed to startActivity without checking any prop-
erties of Intent Y . With this proxy, an attacking app can hide its
identity and start activities, even those protected by permissions
that C1 has but the attacking app does not.

Android heavily relies on internal SQL database to organize sys-
tem and app data, such as contacts and app private information.
Apps can interact with its database using APIs that take SQL state-
ments as arguments. Case D1 passes an input string from an Intent
directly into a raw SQL query, which allows attackers to inject SQL
statements to manipulate the database or even cause system com-
prises. In addition, we have also uncovered more subtle SQL injec-
tion vulnerabilities in many apps, which use parameterized query
instead of raw query, but in a non-parametric form. In particular,
the vulnerable apps construct the selection clause of a query by di-
rectly inserting unescaped strings from Intent, instead of passing
them in a parameter array. Such practices allows the attackers to
inject an arbitrary condition into the selection clause, and derail the
execution of the query, causing unexpected behaviors of the victim
app. Besides SQL injections, a similar but more harmful vulner-
ability, as in Case D2, is the shell command injection, where app
issues Linux shell commands using unchecked input strings.

The last class, data tampering, leads to private or critical data be-
ing overwritten by attackers. Case E1 is a game that reports user’s
score to a remote server for ranking purposes. However, the report-
ing component is made public and reports arbitrary scores speciﬁed
by a requestor, which creates an easy way for cheating the game’s
online scoreboard. We also observed a more security-critical case
where the payment URL of an online shopping app can be modiﬁed
by attackers. The extent of damage by this type of vulnerability is
highly dependent on the function of individual apps, as well as the
robustness of client-server interactions of the apps.

6. DISCUSSIONS

As the evaluation shows, CHEX do have false positives. How-
ever, they can be reduced by addressing two limitations of our cur-
rent prototype. First, our prototype does not leverage on much do-
main knowledge about the partial orders in which Android com-
ponents and their entry points can run or interleave. This design
choice was made because PDS construction enforces the data-ﬂow
continuity between splits, which sorts out the majority of infeasi-
ble split permutations but not all. In addition, building such do-
main knowledge, possibly time-consuming and error-prune, is out
of this work’s scope. We argue that when adopted in practice,
CHEX can always incorporate new constraints into the split per-
meation, which not only reduce the false positive rate but also im-
prove the performance. Second, our current prototype is unable
to recognize false hijack-enabling ﬂows that are sanitized by com-
plicated logic (e.g. regular expression matching and etc.), because
it by itself is an open research problem. On the other hand, we
observe that the majority of apps rely on simple framework APIs
(e.g. checkCallingPermission) and constant string match-
ing to carry out effective input validation, which are already han-
dled by CHEX.

The fact that CHEX only checks data-ﬂows to detect vulnerabil-
ities may cause false negatives. Rare vulnerable components may
exist that enable hijacking attacks without explicit data-ﬂows. In
these cases, date dependencies are essentially encoded into control
dependencies and thus sources and sinks are no longer connected
via data-ﬂows. We could selectively track control dependence for
certain sources (e.g. Tag_InputSrc) in our SDS, so that implicit
intra-split data-ﬂows can be considered during analysis. On the
other hand, control dependency analysis can also easily bring false
positives. The study of this trade-off is out of the scope of this
paper.

7. RELATED WORK

Event-driven (callback-based) programming is widely used in
implementing graphical user interface (GUI) and web systems. To
statically analyze GUI systems, previous work [30, 31] leverage
on domain knowledge to identify and to conﬁgure the entry point
(callback) methods. In web systems, event handler functions are
easy to identify given the uniform ways to deﬁne them. However,
in Android, the large number of entry point types makes it difﬁcult
to identify them completely—previous work relied on speciﬁc do-
main knowledge to detect common component entry points without
guarantee for completeness [21]. We devise a heuristic-based ap-
proach to discover all possible entry points to the apps with low
false positives. To model the execution of multiple entry points,
previous work [30, 31] employ a synthetic main function to mimic

Vulnerability Class Hijacking Type Case-Studied Vulnerable App Data Theft G1/G3 (Read Write) [Case A1] de.cellular.xxx: Sending GPS data to URL speciﬁed by input string Capability Leak G2 (Write) [Case B1] com.appspot.xxx: Input string used as URL for Internet connection [Case B2] com.gmail.xxx: Input string used as hostname for socket connection Intent Proxy G1/G2 (Read Write) [Case C1] com.outﬁt7.xxx: Object embedded in input used to start Activity Code Injection G2 (Write) [Case D1] com.utagoe.xxx: Input string used for raw SQL query statement [Case D2] cn.myprivate.xxx: Input string used as shell command Data tampering G2 (Write) [Case E1] com.akbur.xxx: Input string submitted to server as game score    238the event loop dispatcher in GUI systems. We introduce SDS to
summarize intra-split data-ﬂows and permute the splits to model
their asynchronous invocations and derive the inter-split data-ﬂow
behaviors. Comparing with [30, 31], we divided the global data-
ﬂow analysis problem into much smaller but self-contained sub-
problems, which improves the performance and scalability.

Static analysis and model checking have a history in assisting
vulnerability discoveries [9, 18, 26, 28]. For web systems, Jo-
vanovic et al. designed Pixy [26] to detect input validation ﬂaws
in server side scripts written in PHP through an inter-procedural
context-sensitive data ﬂow analysis. A similar study has been car-
ried for cross site scripting vulnerabilities [33]. Bandhakavi et al.
applied a context-sensitive and ﬂow-sensitive static analysis for an-
alyzing the security vulnerabilities of Firefox plugins written in
JavaScripts [7]. For Java programs, Livshits et al. designed a dat-
alog language to describe the security policies that direct vulnera-
bility detection [28]. Tripp et al. built an industrial strength static
taint analysis tool [32]. Comparing with the aforementioned ef-
forts, we focused on detecting component hijacking vulnerabilities
in Android apps. We ﬁrst tackled general challenges faced by static
app analyzers due to Android’s special programming paradigm, and
then proposed a data-ﬂow-based detection approach.

Security mechanism based on information ﬂows, such as JIF [29],
HiStar [34] and Asbestos [13], are also related in that our work de-
ﬁne and detect component hijacking by means of data-ﬂow poli-
cies, despite that we do not enforce the policies in runtime.

Mobile security issues have gained much attention recently. Mal-
ware are not strangers for both the ofﬁcial Android market and
alternative ones [36]. Research efforts were made on detect-
ing repackaged apps [35] or apps with known malicious behav-
ior [21, 37]. Recently Google also launched its malware ﬁltering
engine [1]. Information leakage is another major security threat for
mobile devices. Kirin [17] detects apps whose permissions might
indicate potential leakage. TaintDroid [15] leverages dynamic taint
analysis to detect information leakage at runtime. PiOS [14] ad-
dressed the same problem using static analysis for iPhone app.
In general, information leakage detection reveals the potential out
bound propagation of sensitive information, which might be benign
in many cases. Instead, component hijacking detection captures the
information leakages resulted from an exploitation (i.e. sensitive
data theft), in addition to other hijacking types.

Enck et al. introduced Ded [16] to convert Dalvik bytecode back
to Java bytecode, and then used existing decompilers to obtain the
source code of the apps for analysis. Our Dalysis framework di-
rectly converts Dalvik byte code to an SSA IR and enables var-
ious types of static analysis. Unlike the decompilation process,
our IR conversion is sound (e.g. no heuristics or failures) and costs
much less time. We model the Android framework and its special
program paradigm rather than coarsely treating apps as traditional
Java programs. As a result, our analysis is more tailored for An-
droid apps and thus has better precision.

Android mediates access to protected resources using a permis-
sion system. However, its effectiveness hinges on app developers
correctly implementing it. Chin et al. showed that apps may be
exploitable when servicing external intents [10]. They built Com-
Droid to identify publicly exported components and warn devel-
opers about the potential threats. For this purpose, it is sufﬁcient
for ComDroid to only check app metadata and speciﬁc API usages,
rather than performing an in-depth program analysis as CHEX does.
As a result, warned public components are not necessarily ex-
ploitable or harmful (i.e. the openness can be by design or the com-

ponent is not security critical). On the other hand, Android permis-
sion system is subject to several instances of the classic confused
deputy attack [23]. As demonstrated by [11, 20, 21, 27], an un-
privileged malicious app can access permission-protected resources
through privileged agents (or app components) that do not properly
enforce permission checks. Recently proposed runtime mitigations
either reduce the agent’s effective permissions to that of the origi-
nal requestor [20] or inspect the IPC chains for implicit permission
escalations [8, 12]. While these runtime solutions are effective at
protecting end users adopting them, scalable detection methods for
the problematic agents in question (i.e. hijack-able components)
are still important to have in order to prevent vulnerable apps from
reaching the vast users in the ﬁrst place. Grace et al. [21] employed
an intra-procedural path-sensitive static analysis to discover per-
mission leaks speciﬁc to stock apps from multiple device vendors.
In comparison, CHEX targets at a more general vulnerability in all
types of Android apps and performs inter-procedural analysis with
high degrees of sensitivity. Thanks to our novel entry point discov-
ery and app-splitting techniques, CHEX is capable of accommodat-
ing Android’s special programming paradigm and ﬁnding complex
hijack-enabling ﬂows.
It is also noteworthy that the component
hijacking attacks we address includes but is not limited to attacks
targeting at permission-protected resources.
8. CONCLUSIONS

In conclusion, we deﬁned and studied the component hijacking
problem, a general category of vulnerabilities found in Android
apps. By modeling the vulnerabilities from a data-ﬂow perspec-
tive, we designed a static analyzer, CHEX, to detect hijack-enabling
data-ﬂows in a large volume of apps. In doing so, we introduced
our method to automatically discover entry points in Android app,
as well as the novel analysis technique, app splitting, as an efﬁcient
and accurate way to model executions of multiple entry points and
facilitate global data-ﬂow analysis. We also built the Dalysis frame-
work to support various types of static analysis directly performed
on Android bytecode. CHEX prototype was implemented based on
Dalysis and was evaluated with 5,486 real-world apps. The empir-
ical experiment demonstrated a satisfactory scalability and perfor-
mance of our analysis method, as well as provided an insight into
the real-world vulnerable apps we detected.

9. ACKNOLEDGEMENT

The authors would like to thank the anonymous reviewers for
helpful comments on earlier versions of the paper. We thank
Ahmad-Reza Sadeghi for the thoughtful feedback that guided the
paper’s ﬁnal revisions. Wenke Lee and Long Lu were partially
supported by the National Science Foundation under grant no.
0831300, the Department of Homeland Security under contract no.
FA8750-08-2-0141, the Ofﬁce of Naval Research under grants no.
N000140710907 and no. N000140911042. Any opinions, ﬁndings,
and conclusions or recommendations expressed in this material are
those of the authors and do not necessarily reﬂect the views of the
National Science Foundation, the Department of Homeland Secu-
rity, or the Ofﬁce of Naval Research.

10. REFERENCES
[1] Android and security.

http://googlemobile.blogspot.com/2012/
02/android-and-security.html.

[2] Baksmali: a disassembler for Android’s dex format.

http://code.google.com/p/smali/.

239[3] Google’s 10 billion android app downloads.

www.wired.com/gadgetlab/2011/12/
10-billion-apps-detailed/.

[4] Quality of Android market apps is pathetically low.

http://www.huffingtonpost.com/2011/06/
20/android-market-quality_n_880478.html.

[5] WALA: T.J. Watson libraries for analysis.
http://wala.sourceforge.netl.

[6] Android application components.

http://developer.android.com/guide/
topics/fundamentals.html#Components, 2012.
[7] BANDHAKAVI, S., KING, S. T., MADHUSUDAN, P., AND

WINSLETT, M. Vex: vetting browser extensions for security
vulnerabilities. In Proceedings of the 19th USENIX Security
Symposium (2010).

[8] BUGIEL, S., DAVI, L., DMITRIENKO, A., FISCHER, T.,

AND SADEGHI, A.-R. Xmandroid: A new android evolution
to mitigate privilege escalation attacks. Tech. Rep.
TR-2011-04, Technische Universitat Darmstadt, 2011.

[9] CHEN, H., AND WAGNER, D. Mops: an infrastructure for

examining security properties of software. In Proceedings of
the 9th ACM CCS (2002).

[10] CHIN, E., FELT, A. P., GREENWOOD, K., AND WAGNER,

D. Analyzing inter-application communication in android. In
Proceedings of the 9th MobiSys (2011).

[11] DAVI, L., DMITRIENKO, A., SADEGHI, A.-R., AND

WINANDY, M. Privilege escalation attacks on android. In
Proceedings of the 13th ISC (2010).

[12] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND
WALLACH, D. S. Quire: Lightweight provenance for smart
phone operating systems. In Proceedings of the 20th
USENIX Security Symposium (2011).

[13] EFSTATHOPOULOS, P., KROHN, M., VANDEBOGART, S.,

FREY, C., ZIEGLER, D., KOHLER, E., MAZIÈRES, D.,
KAASHOEK, F., AND MORRIS, R. Labels and event
processes in the asbestos operating system. In Proceedings of
the 20th ACM SOSP (2005).

[14] EGELE, M., KRUEGEL, C., KIRDA, E., AND VIGNA, G.

Pios: Detecting privacy leaks in ios applications. In
Proceedings of the 19th NDSS (2011).

[15] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,

J., MCDANIEL, P., AND SHETH, A. N. Taintdroid: an
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In Proceedings of the 9th
USENIX OSDI (2010).

[16] ENCK, W., OCTEAU, D., MCDANIEL, P., AND

CHAUDHURI, S. A study of android application security. In
Proceedings of the 20th USENIX Security Symposium
(2011).

[17] ENCK, W., ONGTANG, M., AND MCDANIEL, P. On
lightweight mobile phone application certiﬁcation. In
Proceedings of the 16th ACM CCS (2009).

[18] FELMETSGER, V., CAVEDON, L., KRUEGEL, C., AND

VIGNA, G. Toward automated detection of logic
vulnerabilities in web applications. In Proceedings of the
19th USENIX Security Symposium (2010).

[19] FELT, A. P., CHIN, E., HANNA, S., SONG, D., AND

WAGNER, D. Android permissions demystiﬁed. In
Proceedings of the 18th ACM CCS (2011).

[20] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S.,

AND CHIN, E. Permission re-delegation: attacks and
defenses. In Proceedings of the 20th USENIX Security
Symposium (2011).

[21] GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X.

Systematic detection of capability leaks in stock Android
smartphones. In Proceedings of the 19th NDSS (2012).

[22] GUNDOTRA, V., AND BARRA, H. Android: Momentum,

mobile and more at Google I/O.
http://www.google.com/events/io/2011/.

[23] HARDY, N. The confused deputy: (or why capabilities might

have been invented). SIGOPS Oper. Syst. Rev. 22, 4 (1988),
36–38.

[24] HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND
WETHERALL, D. These aren’t the droids you’re looking for:
retroﬁtting android to protect data from imperious
applications. In Proceedings of the 18th ACM CCS (2011).

[25] HORWITZ, S., REPS, T., AND BINKLEY, D. Interprocedural

slicing using dependence graphs. SIGPLAN Not. 23, 7
(1988), 35–46.

[26] JOVANOVIC, N., KRUEGEL, C., AND KIRDA, E. Pixy: A

static analysis tool for detecting web application
vulnerabilities (short paper). In Proceedings of the IEEE
S&P’06 (2006).

[27] LINEBERRY, A., RICHARDSON, D. L., AND WYATT, T.

These aren’t permissions you’re looking for. In Proceedings
of the Blackhat’10 (2010).

[28] LIVSHITS, V. B., AND LAM, M. S. Finding security

vulnerabilities in java applications with static analysis. In
Proceedings of the 14th USENIX Security Symposium
(2005).

[29] MYERS, A. C. Jﬂow: practical mostly-static information

ﬂow control. In Proceedings of the 26th ACM POPL (1999).

[30] STAIGER, S. Reverse engineering of graphical user

interfaces using static analyses. In Proceedings of the 14th
IEEE WCRE (2007).

[31] STAIGER, S. Static analysis of programs with graphical user

interface. In Proceedings of the 11th IEEE CSMR (2007).
[32] TRIPP, O., PISTOIA, M., FINK, S. J., SRIDHARAN, M.,
AND WEISMAN, O. TAJ: effective taint analysis of web
applications. In Proceedings of the ACM PLDI ’09 (2009).

[33] WASSERMANN, G., AND SU, Z. Static detection of

cross-site scripting vulnerabilities. In Proceedings of the 30th
ACM ICSE (2008).

[34] ZELDOVICH, N., BOYD-WICKIZER, S., KOHLER, E., AND
MAZIÈRES, D. Making information ﬂow explicit in histar. In
Proceedings of the 7th USENIX OSDI (2006).

[35] ZHOU, W., ZHOU, Y., JIANG, X., AND NING, P.

DroidMOSS: Detecting repackaged smartphone applications
in third-party android. In Proceedings of ACM CODASPY’12
(2012).

[36] ZHOU, Y., AND JIANG, X. Dissecting android malware:

Characterization and evolution. In Proceedings of the IEEE
Symposium on S&P’12 (2012).

[37] ZHOU, Y., WANG, Z., ZHOU, W., AND JIANG, X. Hey,

you, get off of my market: Detecting malicious apps in
ofﬁcial and alternative android markets. In Proceedings of
the 20th NDSS (2012).

240