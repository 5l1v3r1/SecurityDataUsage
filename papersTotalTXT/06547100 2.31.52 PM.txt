2013 IEEE Symposium on Security and Privacy

Towards practical reactive security audit using

extended static checkers

Julien Vanegue
Bloomberg L.P.

New York, NY, USA

jvanegue@bloomberg.net

Shuvendu K. Lahiri
Microsoft Research
Redmond, WA, USA

shuvendu@microsoft.com

Abstract—This paper describes our experience of performing
reactive security audit of known security vulnerabilities in core op-
erating system and browser COM components, using an extended
static checker HAVOC-LITE. We describe the extensions made
to the tool to be applicable on such large C++ components, along
with our experience of using an extended static checker in the
large. We argue that the use of such checkers as a conﬁgurable
static analysis in the hands of security auditors can be an effective
tool for ﬁnding variations of known vulnerabilities. The effort has
led to ﬁnding and ﬁxing around 70 previously unknown security
vulnerabilities in over 10 millions lines operating system and
browser code.

Keywords-security audit; program veriﬁcation; static analysis;

extended static checkers

I. INTRODUCTION

Ensuring security of software has become of paramount im-
portance to the software industry. Every software development
group, representing either a small team of developers or an
entire company, mandates extensive testing and analysis to
safeguard against security breaches. However, security ﬂaws
will remain a part of life, at
in the case of legacy
applications that cannot be redesigned from scratch. In such
cases, effective defense mechanisms are required to mitigate
the impact of security vulnerabilities. In particular, ﬁnding all
possible variants of a known security vulnerability can go
a long way in safeguarding the known attack surface of a
software system.

least

The Microsoft Security Response Center (MSRC) identiﬁes,
monitors, resolves, and responds to security incidents and Mi-
crosoft software security vulnerabilities. The following quote
summarizes some of the activities that the team performs in
conjunction with product teams to mitigate future occurrences
of known vulnerabilities that merit security bulletins:1

”...The MSRC engineering team investigates the
surrounding code and design and searches for other
variants of that threat that could affect customers.”

This is an expensive and arduous process that involves a mix
of manual testing, fuzzing and a large amount of manual
security audit. Such audits need to be responsive and timely in
order to prevent attackers from crafting similar attacks in the
near future. We deﬁne the term reactive security audit as this

1http://www.microsoft.com/security/msrc/whatwedo/updatecycle.aspx

process of performing effective audit for variants of known
vulnerabilities, over a large code base. Although the current
practices are effective, they leave a lot to be desired in terms
of scalability and conﬁdence obtained after the reviews.

In this work, we explore the use of extended static checking
tools towards improving the productivity of auditors perform-
ing reactive security audit, and increasing the conﬁdence of the
audit2. Extended static checking tools (such as ESC/Java [1],
HAVOC [2]) offer a potential to develop conﬁgurable static
analysis tools with high coverage guarantees. These tools
provide the user the ability to write contracts (speciﬁcations
of procedures) in the form of preconditions, postconditions,
assertions and discharge them using modern Satisﬁability
Modulo Theories (SMT) solvers [3]. The semantics of the
source language is precisely deﬁned once by the tool (and does
not vary by the property being checked), and the assumptions
are well documented. Many such tools are also equipped
with simple yet robust user-guided contract inference tools
(such as Houdini [4]) to reduce the manual overhead of
writing simple intermediate contracts. Unlike full functional
correctness veriﬁers (such as VCC [5]), they make pragmatic
assumptions to reduce the complexity of proofs, and provide
a lot more automation in the form of inference. Although the
use of extended static checkers had been proposed for ensuring
security a decade back [6], not much success has been reported
in practical usage. Our conjecture is that the absence of a
usable, robust and scalable tool for the space of core operating
system and browser implementations has been one of the main
causes for the lack of adoption.

In this paper, we present a case study of using an extended
static checker HAVOC-LITE3 for checking variants of security
vulnerabilities in Microsoft Windows and Internet Explorer.
We document the challenges encountered in deploying the pre-
vious version of the tool (henceforth called HAVOC) and the
extensions needed to apply the tool in a realistic setting. The
extensions include modeling most common C++ language fea-
tures used typically in such applications, scaling the contract
inference to be applicable to modules with several hundred
thousand procedures, and early annotation validation. We then

2The work was done when the ﬁrst author was employed at Microsoft.
3HAVOC-LITE is the new version of HAVOC [2] developed to meet the

needs of this deployment.

1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.12

33

typedef

s t r u c t

s t r u c t

tagVARIANT {
tagVARIANT {

VARTYPE v t ;
union {

. . .
SAFEARRAY ∗ p a r r a y ;
BYTE ∗ pbVal ;
. . .
PVOID b y r e f ;
. . .

} ;

} ;

} VARIANT ;
bool

t1good ( ) {

VARIANT v ;
v . v t = VT ARRAY;
v . p a r r a y = 0 ;
return true ;

bool

t 1 b a d ( ) {

VARIANT v ;
v . v t = VT ARRAY;
v . pbVal = 0 ;
return true ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50

present our experience of security engineers using the tool on
several properties devised as a response to several existing
vulnerabilities. Over the course of one year, the effort led to
discovering and ﬁxing around 70 previously unknown security
vulnerabilities in over 10 million lines of production code. We
discuss the effort involved in modeling, performing inference
of annotations and dealing with false alarms encountered along
the way. We conclude that in spite of the current limitations,
such a tool can be (and already is) quite cost-effective in
complementing existing efforts based on fuzzing and manual
audit. We conjecture that it can improve the productivity of
security auditors who invest in implementing ad-hoc tools to
aid their manual audit.

The rest of the paper is organized as follows:
1) In Section II, we present an overview of our approach
using two simpliﬁed examples. The examples illustrate
some of the challenges posed when analyzing low-level
systems code, a brief summary of the modeling effort,
dealing with object-oriented features and the use of
annotation inference.

2) In Section III, we provide a brief description of the
existing tool HAVOC that has been applied to large
Windows modules to ﬁnd errors. In Section IV, we
describe the main shortcomings of HAVOC that limited
its application for our problem domain. We describe
the design of HAVOC-LITE that includes modeling an
expressive subset of C++ features, scaling the annotation
inference by using a two-level algorithm that avoids
memory blowup for large modules, along with other
features required for making the tool robust and usable
in the hands of security auditors.

3) In Section V, we describe the effort of applying
HAVOC-LITE on the core OS and browser compo-
nents. We discuss the properties that were modeled as
variants of existing security vulnerabilities, candidate
annotations required for inferring intermediate annota-
tions, and some representative errors. We show the need
for various pragmatic decisions (such as dealing with
unsound modiﬁes clause) to trade off soundness for cost-
effectiveness of the analysis. We highlight the effort
required in devising the inference to reduce false alarms
and the payoff over the different properties.

4) In Section VI, we discuss other related static analysis

tools, and ﬁnally conclude in Section VII.

II. MOTIVATING EXAMPLES

In this section, we introduce two concrete examples con-
taining commonly found programming style in C++ and COM
(Component Object Model [7]) applications. These examples
can only be precisely analyzed if the semantics of bit-level
manipulations are properly modeled,
the common object-
oriented and interface-oriented programming are well handled
by the extended static checker.

34

}

}

}

bool

t2good ( ) {

VARIANT v ;
v . v t = VT BYREF | VT UI1 ;
f u n c u s e v f i e l d (&v ) ;
return true ;

}
void f u n c u s e v f i e l d (VARIANT ∗v ) {
}

v−>pbVal = 0 ;

bool

t2good2 ( ) {

VARIANT v ;
f u n c s e t v t (&v ) ;
v . pbVal = 0 ;
return true ;

}
void f u n c s e t v t (VARIANT ∗v ) {

v−>v t = VT BYREF ;
v−>v t
|= VT UI1 ;

Fig. 1. Example of analysis requiring inter-procedural bit-level reasoning

A. Example 1: Inter-procedural and bit-precise reasoning

The ﬁrst example shows a generic container data structure
called a VARIANT and commonly used in C++/COM applica-
tions. This structure contains a special ﬁeld vt and a union of
data attributes. The value of the vt ﬁeld indicates the union
ﬁeld that is correctly initialized. Failure to check the value
of the vt ﬁeld can lead to using the wrong union ﬁeld and
therefore may use a pointer ﬁeld with an invalid integer value.
Such mistake is likely to lead to a security vulnerability (such
as in functions t1bad). The check for the vt ﬁeld and the

use of the associated union ﬁeld are often done in separate
functions (such as in t2good and t2good2). Therefore,
constraints must be adequately propagated inter-procedurally
to avoid false positives from static analysis warnings. In
addition, since the vt attribute is a bit ﬁeld, bit-level program
semantics needs to be supported by the static checker. Finally,
a user needs to be able to document the desired property
by checking each dereference of the set of ﬁelds (such as
pbarray, pbVal) under consideration. Such features are
supported by HAVOC-LITE and was used to ﬁnd multiple
security vulnerabilities in a critical browser component.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

# i n c l u d e <windows . h>
# i n c l u d e "havoc.h"
/∗ F i e l d i n s t r u m e n t a t i o n s ∗ /
r e q u i r e s ( v−>v t == VT ARRAY)
i n s t r u m e n t w r i t e p r e ( v−>p a r r a y )

void

i n s t r u m e n t w r i t e a r r a y (VARIANT ∗v ) ;

r e q u i r e s ( v−>v t == (VT BYREF| VT UI1 ) )
i n s t r u m e n t w r i t e p r e ( v−>pbVal )

i n s t r u m e n t w r i t e p b v a l (VARIANT ∗v ) ;
void
/∗ Func i n s t r u m e n t a t i o n s w i t h c a n d i d a t e s ∗ /
c a n d r e q u i r e s ( v−>v t == (VT BYREF| VT UI1 ) )
c a n d r e q u i r e s ( v−>v t == VT ARRAY)
c a n d e n s u r e s ( v−>v t == (VT BYREF| VT UI1 ) )
c a n d e n s u r e s ( v−>v t == VT ARRAY)
i n s t r u m e n t u n i v e r s a l
i n s t r u m e n t u n i v e r s a l

t y p e ( v )
i n c l u d e ( "*" )

i n s t r u m e n t c a n d v a r i a n t (VARIANT ∗v ) ;

void

Fig. 2. Annotations for the ﬁrst example.

Figure 2 shows the annotations written by the user to
create a checker for this property. There are two parts to the
annotations: (a) devising the property and (b) creating an inter-
procedural inference.

are

reads

The

“Field

instrumentations”

the method can be arbitrary except

instrumentations
to particular
provided to insert an assertion at
the instrumentation provided using
ﬁelds. For example,
name
__instrument_write_array method
the preﬁx
of
__instrument_)
to the
ﬁeld parray in the structure VARIANT is preceded
by (“write_pre”) an assertion that
the vt ﬁeld in
the structure equals the value VT_ARRAY. There is a
similar check before writes to the pbVal ﬁeld using the
instrumentation __instrument_write_pbVal. These
two instrumentations allow the user to document the property
to be checked.

every write

speciﬁes

(the

for

that

We now look at how the user can conﬁgure the inter-
procedural annotation inference. The “Func instrumentations”
are used to write annotations on a set of methods, instead

35

a

takes

that
instrumented.

any method
is

that
VARIANT *

of
listing each individual method. The instrumentation
primitive
__instrument_universal_type
speciﬁes
parameter
of
type
ﬁlter
__instrument_universal_include can
used
to restrict
the instrumentation to only methods whose
names match a particular pattern — in this case, the wild-
card pattern “*” matches any method. The annotations in
__cand_requires and __cand_ensures are candidate
preconditions and postconditions. These candidates are fed to
the inter-procedural annotation inference engine that infers
a subset of them as annotations that actually hold on every
context.

The
be

When the user runs HAVOC-LITE with the property and
candidate annotations, the tool infers two annotations: The
func_use_vfield has a precondition

__requires(v->vt == (VT_BYREF | VT_UI1))

and the method func_set_vt has a postcondition

__ensures(v->vt == (VT_BYREF | VT_UI1))

These additional annotations allow the tool to only complain
about the method t1bad, which corresponds to the only true
error. Although for this simple example, it is easier to simply
write the two additional annotations, it is immensely useful
when dealing with modules with several
thousand deeply
nested procedures.

B. Example 2: Object-oriented reasoning

A second example involves the IUnknown interface class
which is responsible for all the reference counting mechanisms
necessary to maintain object consistency in COM applications.
In this example, the class method A::Action performs a call
to QueryInterface which is in charge of retrieving an
instance of the interface given an input interface identiﬁer.
Such a call performs an implicit call
to AddRef which
increases the reference counter for this interface. Success of
this call (when the return status is S_OK) leads to calling
method WebAction which performs the expected operation
on class B. Failure to retrieve the interface methods leads
to early termination, where the IUnknown interface pointer
is released using a call to method ReleaseInterface,
which is in charge of decrementing the reference count for
this interface (provided the interface pointer is non-NULL).

A security vulnerability exists in this example due to the
lack of NULL initialization of the IWebIface pointer, which
leads to corrupting the reference counter of an unknown
location in the program in case the call to QueryInterface
is not successful. Such example requires an accurate object-
oriented awareness from the static checker. We later show how
HAVOC-LITE was used to uncover multiple similar security
vulnerabilities in a critical browser component.

To model this property, the user can introduce a ghost
ﬁeld Queried in every object — the ghost ﬁeld tracks
whether an object has been created by a successful call to
QueryInterface. The value of the ghost ﬁeld for an object

{

B ( ) { } ;
HRESULT Q u e r y I n t e r f a c e ( IID id , void ∗∗p ) ;
ULONG
ULONG
HRESULT WebAction ( ) ;

AddRef ( ) ;
R e l e a s e ( ) ;

( i )

i−>R e l e a s e ( ) ;

} ;
void R e l e a s e I n t e r f a c e ( IUnknown ∗ i ) {
}
i n t main ( i n t ac , char ∗∗ av ) {
A ∗ a = new A ( ) ;
B ∗b = a−>Lookup ( ) ;
a−>A c t i o n ( b ) ;
return ( 0 ) ;

i f

} ;
c l a s s B : p u b l i c IWebIface ,

p u b l i c IUnknown

c l a s s A {
A( ) { } ;
HRESULT A c t i o n ( ) ;
∗Lookup ( ) ;
B

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 HRESULT A : : A c t i o n (B ∗b ) {
26
27
28
29
30
31
32
33 Cleanup :
34
35
36

R e l e a s e I n t e r f a c e (w ) ;
return ( r ) ;

HRESULT r = S FAIL ;
IWebIface ∗w;
i f
( b == NULL)
goto Cleanup ;
r = b−>Q u e r y I n t e r f a c e ( IID WebIface , &w ) ;
i f
r = b−>WebAction ( ) ;

( r == S OK)

}

}

Fig. 3. Example of analysis requiring precise object-oriented semantics

x is written as __resource(‘‘Queried’’, x). One
can write a precondition for the Release methods of B and
any of its derived classes:

#define QUERIED(x)

__resource(‘‘Queried’’, x) == 1

\
\

__requires(QUERIED(this))
ULONG B::Release();

to indicate that the receiver object of the method Release has
to be created by an earlier call to QueryInterface. This
is in turn modeled by writing the following postcondition for
the method:

__ensures(__return != S_OK || QUERIED(*p))
HRESULT B::QueryInterace(IID id, void **p);
where __return denotes the return value of the procedure.

Finally, one needs to infer annotations such as:

__requires(i == NULL || QUERIED(i))
void ReleaseIface(IUnknown *i);
which can be done with the help of the ﬁrst populating can-
didate annotations on all methods that consume a IUnknown

as an argument (we do not show the instrumentation here),
and then performing inter-procedural annotation inference.

III. BACKGROUND: HAVOC

In this section, we provide a background on HAVOC. We
describe HAVOC-LITE along with the extensions created for
this paper in Section IV.

HAVOC can be best thought of as an extended static checker
for C programs, in the spirit of ESC/Java [8]. It provides an (a)
extensible property checker with the aid of an annotation/con-
tract language, (b) a procedure modular veriﬁer that provides
an accurate depiction of C semantics, (c) an user-guided inter-
procedural annotation inference engine, along with (d) various
instrumentation primitives. Figure 4 shows the overall usage
model of HAVOC (and also of HAVOC-LITE) in the hands
of a user. We describe each of the components brieﬂy in the
next few subsections. More details about these features can be
found in an earlier work [2].

Candidate 

annots 
template 

Source 
code 

Property 

+  

Manual 
annots 

Inferred 
annots 

Warning 
review 

Houdini 
inference 

Concrete program  
     semantics 

Modular 
checker 

Refine 
annots? 

Fig. 4. HAVOC and HAVOC-LITE ﬂow.

A. Contract language

A user can document contracts about the code using an
annotation language. An annotation is an assertion over the
state of the program. There are four classes of assertions (i)
assertions __assert (e), (ii) assumptions __assume (e),
(iii) preconditions __requires (e) and (iv) postconditions
__ensures (e). Here e refers to a side-effect-free C expres-
sion that evaluates to a scalar or pointer value — in other
words, e cannot be a structure value. For example, one can
write __ensures (*x == y->f) to indicate that on exit
from a procedure the value obtained by dereferencing the
variable x is identical to the value stored in a ﬁeld f inside
the structure pointed to by y. In addition to assertions, a user
can specify a __modifies clause that speciﬁes which part
of the heap is modiﬁed by a procedure. For the purpose of

36

Locs
Expr

Command

l
e

c

::= ∗e | e → f
::= x | n | l | &l | e1 op e2 | e1 ⊕n e2
::= skip | c1; c2 | x := e | l := e | if e then c | while e do c
|

f (e, . . . , e)

= x
= n
= Memf [E(e) + Offset(f )]
= Memτ [E(e)]

E(x)
E(n)
E(e → f )
E(∗(e : τ ))
E(&e → f ) = E(e) + Offset(f )
E(& ∗ e)
E(e1 op e2) = E(e1) op E(e2)
E(e1 ⊕n e2) = E(e1) + n ∗ E(e2)

= E(e)

C(skip)
C(c1; c2)
C(x := e)
C(l := e)
C(if e then c)
C(while e do c) = while (E(e)) do C(c)
C(f (e1, . . . , ek))

= skip
= C(c1); C(c2)
= x := E(e);
= E(l) := E(e);
= if (E(e)) C(c)

= call f (E(e1), . . . , E(ek))

Fig. 5. A simpliﬁed subset of C, and translation from C into BoogiePL. E() maps a C expression into BoogiePL expression and C() maps a C statement
into a BoogiePL statement.

this paper, we ignore discussion on loop invariants, which are
also supported in HAVOC.

In addition to the expressions in scope, a user can refer
to the return variable by using the symbol __return in a
postcondition, refer to the value of an expression at entry
to a procedure using __old () in a postcondition. For ex-
ample, __ensures (__return == __old (*x) + 1)
signiﬁes that the value of return variable is one more than the
value stored in *x at the entry to the procedure. The user can
also refer to the state of ghost ﬁelds that augment the state
of the program using a keyword __resource4. The scalar
expression __resource (s, e) where s is a string and e is
a side-effect pointer/scalar expression, refers to the value of a
ghost ﬁeld named “s” inside the structure pointed to by e; i.e.
the value of e->s. The user can modify such ghost ﬁelds in
the program.

The annotation language, along with the presence of ghost
ﬁelds allows user to encode various interesting properties of
the program. Section II provides a few examples of such
properties. Several more examples of properties can be found
in earlier works [2].

HAVOC provides a sufﬁciently accurate memory model
for C programs that provides meaning to constructs such as
pointer arithmetic, casts, yet supports common disambigua-
tion required for scalable reasoning of high level properties.
Figure 5 provides a simpliﬁed subset of C (for illustration
purposes) without nested structures and addresses of variables.
Figure 5 also provides the translation of this subset into an
intermediate veriﬁcation language BoogiePL [9]. BoogiePL
is a simple procedural language, where the set of variables
are restricted to Booleans, integers and arrays over them. The
operator C() maps a C statement to the equivalent BoogiePL
statement in a straightforward manner. In addition, the lan-
guage has support for assertions, assumptions, preconditions
and postconditions — the HAVOC annotations map directly
to them.

4Ghost variables are also supported as a degenerate case of ghost ﬁelds.

The operator E() maps a C expression (present in either a
statement or an annotation) into a BoogiePL expression. The
heap is split into a ﬁnite number of arrays (named Memf [] or
Memτ []), one per scalar ﬁeld or pointer ﬁeld (f) or pointer
type (τ). Dereferencing a pointer is modeled as indexing into
the appropriate array with a suitable offset — the operator
Offset(f ) provides the offset of the ﬁeld f inside its parent
structure. The heap splitting assumes ﬁeld safety [10] that
allows exploiting the types and ﬁelds in the program to get dis-
ambiguation. Under ﬁeld safety, it is (optimistically) assumed
that &x → f can never alias with &y → g for distinct ﬁeld
names f and g. Further, addresses of a ﬁeld &x → f does not
alias with the address & ∗ e. Although HAVOC has an option
to not assume ﬁeld safety, the annotation overhead increases
several fold even for simple examples. In our experience, we
have seldom found this optimistic assumption to limit our
ability to ﬁnd violations of security properties described in
this paper.

B. Modular veriﬁer

An annotated BoogiePL program is checked for correctness
one procedure at a time by the Boogie program veriﬁer. The
veriﬁer uses veriﬁcation condition generation (translation of
the program into a logical formula with near linear size) [11]
and automated theorem proving (namely Satisﬁability Mod-
ulo Theories solvers [3]) to check the satisﬁability of the
formula. HAVOC lifts an intraprocedural counterexample at
the BoogiePL level to display over the C source code. In
our experience, the ability of Boogie to generate a compact
veriﬁcation for the theorem prover is key to the scalability of
HAVOC compared to tools that employ symbolic execution
based path enumeration. The theorem prover can internally
perform complex reasoning to prune parts of a procedure (with
often several thousand paths) that are not relevant towards
proving an assertion.

37

C. User-guided inference

HAVOC uses a variant of

the Houdini algorithm to
inference of procedure annota-
perform inter-procedural
tions
[4]. A user can write a set of candidate pre-
conditions (__cand_requires (e)) and postconditions
(__cand_ensures (e)) in addition to the usual annotations.
The Houdini algorithm performs an inter-procedural greatest
ﬁx-point analysis to retain the (unique) maximum subset of
these candidates that can be proved modularly by the program
veriﬁer, while assuming the non-candidate annotations. The
ﬁx-point proceeds by maintaining a worklist of procedures
to be checked. At each step, a procedure p is checked using
the modular veriﬁer. Any candidate annotation that cannot be
proved is removed from the list of annotations. Depending on
the nature of the removed candidate, either the callers of p (for
candidate postcondtiions), or the callee q (whose candidate
preconditions are removed) are added to the worklist,
in
addition to p. The process is repeated until the worklist is
empty. The simple algorithm terminates in at most n ∗ c
iterations, where n is the total number of procedures in the
module, and c is the total number of candidate annotations.In
practice, it runs almost linear in c, thus guaranteeing a quick
turnaround.

D. Instrumentations

Finally, various syntax-based instrumentation facilities are
provided to avoid manually writing annotations on large code-
bases. For example, an user can instrument all procedures
whose names match a regular expression with a postcondition
on globals, or instrument all procedures that take a parameter
x of type τ∗ by a precondition parameterized by x. Moreover,
these annotations can include candidate annotations as well
— this is crucial to performing the annotation inference. In
addition to procedure annotations, the user can also instrument
reads and writes to speciﬁc ﬁelds, types or globals to insert
an assertion or assumption before or after the source line (as
illustrated in Section II).

IV. HAVOC-LITE

Although HAVOC had earlier been applied to large Win-
dows source modules [2], we found it lacking in terms of us-
ability and applicability for the code bases under investigation.
The principal limitations that we addressed and describe in
this section are: (i) need for modeling common C++ language
constructs, (ii) augmenting the instrumentation mechanisms
to exploit C++ class structure, (iii) scaling the annotation
inference to modules containing hundreds of thousands of
procedures, and several other usability concerns such as the
need to modify source code to insert annotations. In the
process of making the tool more robust, we dropped support
for some of the earlier features in HAVOC (hence the name
HAVOC-LITE) such as checking type-safety of C programs,
using ﬁne-grained modiﬁes clauses, dealing with linked list
invariants and checking for complex modiﬁes clauses in can-
didate annotations described in earlier works [12].

c l a s s D {
p u b l i c :

i n t a , b ;
v i r t u a l void f ( ){}

} ;
c l a s s A : p u b l i c D {
p u b l i c :

i n t c ;
A ( ) ;
void f ( ) ;

} ;
c l a s s B : p u b l i c D {
p u b l i c :

i n t d ;
B ( ) ;
void f ( ) ;
void h ( ) ;

} ;
c l a s s C : p u b l i c A, p u b l i c B {
p u b l i c :

i n t e ;
C ( ) ;
void f ( ) ;

e n s u r e s

} ;
. . .
/∗ p o s t c o n d i t i o n ∗ /
void C : : f ( ){ e ++;}
. . .
i n t main ( ) {
C∗ pc = new C ( ) ;
B ∗pb = (B∗) pc ;
D ∗pd = (D∗) pb ;
pc−>e = 4 ;
pb−>a = 6 ;
pc−>h ( ) ;
pd−>f ( ) ;

}

( t h i s −>e > o l d ( t h i s −>e ) )

/∗ a l l o c a t i o n ∗ /
/∗ dynamic c a s t ∗ /
/∗ dynamic c a s t ∗ /
/∗ f i e l d a c c e s s ∗ /
/∗ base

f i e l d a c c e s s ∗ /

/∗ method c a l l
/∗ v i r t u a l method c a l l ∗ /

∗ /

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40

Fig. 6. A simple C++ example.

A. Modeling C++ language constructs

By far, the most signiﬁcant shortcoming of HAVOC was
inability to deal with most C++ constructs. In this section,
we brieﬂy describe some of the changes required to handle
the most common C++ features used commonly in the COM
components. We illustrate the translation of C++ to BoogiePL
program with the aid of a simple example in Figure 6 and the
translated BoogiePL program in Figure 7.

To handle instance methods, we make the receiver object
explicit by exposing the this pointer. The BoogiePL transla-
tion of the procedure C::f takes this as an argument, and
updates the ﬁeld array Mem_e that represents the ﬁeld e in the
class. We use the function Offset_f_C to denote the offset
of a ﬁeld f in a class C. Further, the annotation expressions
can refer to this in assertions, as shown for this method.

Constructor calls are modeled by ﬁrst allocating a con-
tiguous buffer with the size of the class by invoking the
special method __HV_malloc. The mutable variable alloc

38

f u n c t i o n Delta D A ( x ) {x+0}
. . .
f u n c t i o n Delta B C ( x ) {x+12}
. . .
f u n c t i o n O f f s e t e C ( x ) {x+24}
. . .
v a r
a l l o c :
const Base :
const DT:

i n t ;
[ i n t ] i n t ;
[ i n t ] i n t ;

/∗ p o i n t e r
t o t h e
/∗ dynamic t y p e ∗ /

s t a r t o f an o b j e c t ∗ /

a l l o c
( new == o l d ( a l l o c ) )
( a l l o c > o l d ( a l l o c ) + n )
( f o r a l l u \ i n [ new , new+n ) . Base ( u ) = new )
(DT( new ) == t y p e )

e n s u r e s
e n s u r e s
e n s u r e s
e n s u r e s
p r o c e d u r e HV malloc ( n ,

r e t u r n s new ;

/∗ s e t

t y p e )

t h e dyn t y p e ∗ /

( Mem e [ O f f s e t e C ( t h i s ) > o l d ( Mem e [ O f f s e t e C ( t h i s ) ] ) ) )
e n s u r e s
p r o c e d u r e C : : f ( t h i s ){Mem e [ O f f s e t s e t e C ( t h i s ) ] + + ;} /∗ e x p l i c i t
p r o c e d u r e main ( ) {

‘ ‘ t h i s ’ ’ ∗ /

1
2
3
4
5
6
7
8
9
10
11 m o d i f i e s
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40

}

}

pc = HV malloc ( 2 8 , C ) ;
c a l l C : : c t o r ( pc ) ;

pb = ( pc == 0 ? 0 : Delta B C ( pc ) ) ;
pd = ( pb == 0 ? 0 : Delta D B ( pb ) ) ;

Mem d[ O f f s e t e C ( pc ) ] = 4 ;
Mem d[ O f f s e t a D ( Delta D B ( ( pb ) ) ) ] = 6 ;

c a l l B : : h ( Delta B C ( pc ) ) ;
/∗ v i r t u a l method c a l l ∗ /
b a s e = Base ( pd ) ;
switch (DT( b a s e ) ) {

case A:
case B :
case C :
d e f a u l t :

c a l l A : : f ( b a s e ) ; break ;
c a l l B : : f ( b a s e ) ; break ;
c a l l C : : f ( b a s e ) ; break ;
c a l l D : : f ( b a s e ) ; break ;

c a l l ∗ /

f i e l d s o f 4 b y t e s ∗ /

/∗ 7 i n t e g e r
/∗ c o n s t r u c t o r
/∗ c a s t ∗ /
/∗ c a s t ∗ /
/∗ f i e l d a c c e s s ∗ /
/∗ f i e l d a c c e s s o f base c l a s s ∗ /
/∗ method c a l l ∗ /
/∗ o b t a i n t h e

s t a r t o f o b j e c t ∗ /

Fig. 7. The BoogiePL (cleaned up) for the C++ example.

monotonically increases to ensure that the buffer allocated is
fresh.5 The constant map Base tracks the base of the buffer
for any pointer in the buffer, and the constant map DT maps
the base of the buffer to its dynamic type (the type used during
allocation). The constraints are enforced by the speciﬁcation of
the procedure __HV_malloc speciﬁed using the
ensures
annotations. The newly allocated object is then passed to the
constructor of the class.

Dynamic casts is modeled by a conditional assignment that
checks if the right hand side (RHS) of the assignment is null
or not. In case, the RHS is non-null, it assigns the pointer
shifted by the offset of the base class in the derived type.
The functions Delta_A_B model the offset of a base class
A inside a derived class B.

Field access is modeled similar to C programs as before,
except for accessing ﬁelds inside base classes. To access ﬁelds
in a (transitive) base class (such as the ﬁeld a deﬁned within
the base class D from within B), we ﬁrst add the offset of

5We currently do not model deallocation.

the base classes in the access path from the derived class
(Delta_D_B for this example).

Non-virtual method calls are handled similar to C, except
the addition of the this parameter. Similar to ﬁeld access,
calling a method in one of (transitive) base classes requires
the addition of the offsets of the base classes in the access
path. Virtual method calls require looking up the dynamic
type (stored in DT) of the start of the object into a temporary
variable base and performing a case split on the possible set
of runtime types. For each dynamic type, the corresponding
virtual method is invoked (assuming for simplicity the method
is deﬁned in each derived class). In each of the cases, the
pointer passed as the this parameter is the start of the
object stored in the map Base during allocation. Currently,
we assume a separate analysis to compute the set of potential
target types that is fed into HAVOC-LITE as an input.

In addition, HAVOC-LITE also handles operator overload-
ing, simple forms of templates (both parameterized by types
or values) and other C++ features commonly encountered in

39

COM. Although the modeling is far from being considered
complete for C++, it allows us to get substantial coverage of
many C++ code-bases using COM.

B. Instrumentations

The instrumentation mechanism in HAVOC was extended
to support some object-oriented constructs. These include (a)
instrumenting all instance methods declared in a given class,
and (b) instrumenting an instance method in all classes.

The ﬁrst feature is useful for annotating class invariants,
by instrumenting all instance methods in a class with a pre-
condition and postcondition. In addition, the user can remove
the constructors and destructors from the set by using a set of
patterns that are excluded. For example,

__requires(x->f != null)
__ensures (y->f != null)
__instrument_universal_exclude(‘‘A$dtor’’)
__instrument_universal_exclude(‘‘A$ctor’’)
__instrument_universal_include(‘‘A$*’’)
__instrument_universal_type(x)
void __instrument_class_inv(A *x);

instruments all methods in the class A (denoted by the
_include pattern) except
the constructor and destructor
(denoted by the _exclude patterns) require and ensure that
a ﬁeld f is non-null for the receiver (“this”) object. Instance
methods that take additional objects of type A or static methods
that take an object of type A have to be manually excluded
though.

The second feature is often useful for getting the effect of
annotation inheritance, where annotation on a virtual method
is inherited by the overriding methods of all derived classes.
All instance methods with the name foo can be speciﬁed
with the pattern ‘‘*$foo’’. However, we currently do not
provide any support for checking that derived classes only
weaken preconditions and strengthen postconditions — it is
left to the user to enforce.

C. Inference

HAVOC used the Houdini algorithm [4] to choose inductive
invariants from a set of candidates. Although the inference was
successful in scaling to modules with several hundred to a few
thousand procedures [2], it did not scale to the modules that
had several hundred thousand procedures measuring several
million lines of code. In this section, we discuss the improve-
ments made to make the inference scalable to these modules.
1) Persisting fewer Boogie ﬁles: The approach in HAVOC
generated a single BoogiePL ﬁle on disk containing the
deﬁnition of all the procedures, and then invoked the Houdini
procedure inside Boogie. However, creating a Boogie ﬁle with
almost a million procedure did not scale as HAVOC crashed
due to memory blowup during the generation of the Boogie
ﬁle, and Boogie could not load such a ﬁle and perform VC
generation. Instead, we ﬁrst changed the ﬂow to generate a
Boogie ﬁle per procedure, and fed Boogie a list of Boogie
ﬁles. This avoided the memory blowup in HAVOC, but still
caused Boogie to take a long time.

40

Our ﬁrst observation is that for the purpose of Houdini
inference, one can safely ﬁlter procedures that do not have
any (a) candidate assertions inside the body of the procedure,
(b) does not have any candidate postconditions, (c) does not
have (immediate) callees that have a candidate precondition.
This is because analyzing such procedure will always return
“veriﬁed” as there are no assertions to check. This simple
optimization allowed us to reduce the number of Boogie ﬁles
used during the inference by at least 2 orders of magnitude,
when the annotations were sparse.

2) Two-level Houdini algorithm: In spite of the dramatic
reduction in the number of procedures being analyzed during
Houdini, we were still left with several tens of thousand of
procedures to analyze, and maintaining all the procedures (and
their VCs) in memory during Houdini exceeded memory. To
alleviate it, we designed a two-level Houdini algorithm that
uses a cache to only pass a small set of procedures to the
Houdini procedure.

Given a set of procedures P with candidate annotations C

and a cache size n, the algorithm operates as follows.

1) It ﬁrst initializes a work list W with all the procedures

in P .
2) At each stage, it removes a set S of n procedures from
W (or all procedures if |W| ≤ n) and invokes Houdini
on S.
tions R ⊆ C after analyzing S.

3) Houdini removes a (possibly empty) subset of annota-
4) For each removed candidate c ∈ R, we update the
worklist as follows: (a) if c is a precondition of a
method p (cid:8)∈ S, then we add p to W , and (b) if c is
a postcondition of a method p then we add any of its
caller q that is not present in S.
5) At the same time, C is updated to C \ R by removing

the candidates removed by Houdini.

6) The method is repeated until W is empty.

It is not difﬁcult to show that when W is empty, then the set
of candidates in C can be proved modularly.

The size of the cache inﬂuences the overall runtime as
the larger the cache, the more chance the (inner) Houdini
algorithm gets to perform optimizations, and thus the outer
loop converges faster. On the other hand, making the cache
large increases the memory consumption for Houdini. We have
observed that the memory requirement is really a function of
the size of the procedures instead of the number of procedures.
For a given problem where the size of the largest procedure
is k, it is useful to set n so that n ∗ k does not exceed the
memory alloted to the process. For most of our experiments,
n is set between 20 and 100.

3) Candidates on roots and leaves: It is well-known that
if the set of candidate preconditions on root procedures (that
have no callees) or the set of candidate postconditions on leaf
procedures (that have no body) are inconsistent, then Houdini
can infer annotations that may not hold. Previously, the users
of HAVOC manually ensured that the root procedures have no
candidate preconditions and leaf procedures have no candidate
postconditions. This was an expensive process as determining

the roots can be tricky when certain procedures are targets
of function pointers. To simplify matters, HAVOC-LITE ﬁrst
removes candidate preconditions from the root and candidate
postconditions from the leaves of the call graph presented to
it for annotation inference. This substantially improves the
usability of the inference for the user.

D. Other

In addition to the above enhancements, a number of other
usability issues were addressed. First, we added a mechanism
to insert annotations completely non-intrusively — i.e. the
source tree did not have to be modiﬁed. Annotations were
ﬁrst compiled with type and procedure declarations and then
linked with the deﬁnitions later. This greatly improved the
adoption in teams that did not want to modify the source
code, even to include an annotation header ﬁle. The separate
compilation of the annotation ﬁle also allowed us to correct
annotation parse errors quicker. HAVOC-LITE also added bit-
vector support by interpreting the scalars and pointers as ﬁxed-
size bit-vectors, and using the theory of bit-vectors inside SMT
solver Z3. Earlier implementation in HAVOC used unbounded
integers and could not model the bitwise operations accurately.
Finally, the user can associate custom strings and identiﬁers
for warning messages that are displayed on assertion failures
— this allowed easier triaging of warnings when multiple
properties were checked in a single run.

V. EVALUATION

In this section, we go through the evaluation of the capabil-
ities of HAVOC-LITE to detect variations of known software
problems that are commonly reported in Microsoft products.
Security holes belonging to these vulnerability classes, when
reported by independent security researchers, give rise to
security bulletins and general distribution release of ﬁxes.
Such bulletins are very costly for software vendors and users,
in particular for businesses with hundreds or thousands of
computers, whose activity is interrupted while the update
is performed. As such, each bulletin must ensure that
it
covers not only the originally reported security problem, but
variations of the problem that may be more easily identiﬁed by
third party researchers after the bulletin is published. Extended
static checking helps software vendors increase coverage of
such reactive analysis.

A. Checked properties

We have evaluated the tool on the large scale on multiple
heterogeneous properties across multiple products written in C
and C++, summarized in Figure 8. The properties were derived
by studying a set of security vulnerabilities reported in a set of
recent MSRC bulletins ( [13], [14], [15], [16], [17], [18], [19],
[20]). We avoid relating the properties to speciﬁc MSRC cases
to avoid disclosing any conﬁdential information not available
in the bulletins.

Some of the properties we describe in this table are in fact
a family of properties. For example, zero-sized allocations is

an umbrella denomination for calls to dynamic memory allo-
cation APIs such as the user-mode malloc, the kernel-mode
ExAllocatePool, dynamic array allocations via the new
operator, or object constructors taking an integer parameter
that is used to allocate an internal buffer used within this class
object.

Other interesting properties come from expected contracts of
special VARIANT object (recall the example from Section II).
The type names have been changed to avoid unintended
consequences of releasing such information. Such data struc-
tures holding run-time type information can be the source of
multiple security vulnerabilities if they are initialized or used
incorrectly.

Another interesting property (“Interface reference count-
ing”) arises from the need to enforce the usage of interfaces
in object-oriented programs. An interface can be seen as a
structure that holds a ﬁxed list of function pointers. Interfaces
are usually reference counted and released once their expected
life time has been reached. Our introductory example in
the overview section was taken from this class of security
vulnerabilities affecting object-oriented software.

The property of library path qualiﬁcation captures the intent
that no binary dependence should be loaded from an unknown
location under the threat of loading untrusted code (potentially
from a remote location if the path is in the UNC format
such as “\\remote\machine\untrusted.dll”). On the other
hand, a preceding call to a trusted path-retrieving API such
as GetSystemDirectory acts as a sanitizer, as it provides
a proof that such path is preﬁxed by a string of the form
“c : \windows\system32”.
B. Results

The result of checking those properties over the course
of a year is presented in Figure 9. We identiﬁed around 70
vulnerabilities in critical software components using a build
server equipped with 48 cores and 96GB of RAM to perform
this analysis. While the big number of cores signiﬁcantly
speeds up the intra-procedural analysis, the inter-procedural
does not currently beneﬁt from it due to the sequential im-
plementation. The “Check” time is the time to only check the
annotations intra-procedurally, including inferred annotations
if any. The “Inference” time is the time taken to perform the
inter-procedural annotation inference. We also report a few
other vulnerabilities for other properties later in this section
— we did not perform a thorough evaluation of times etc. for
these properties.

Each analyzed property corresponds to a class of security
vulnerability previously discovered and ﬁxed in the analyzed
code base via general distribution release of security bulletins.
We only applied a particular property checking to the code
bases that were affected by the property — this explains the
difference in code size for each experiment. While some of the
properties (e.g. Library path qualiﬁcation) affected all user-
mode code bases, others (such as the DOM property) only
affects the core browser engine. Other generic COM properties
such as the VARIANT initialization and type safety checking

41

Properties
Zero-sized allocations
Empty array construction
VARIANT initialization
VARIANT type safety
Interface reference counting
Library path validation
DOM information disclosure DOM accessors only returns success on successful completion.

Description
Dynamic memory allocations should never be of size 0.
There is always at least one element in new[] allocated arrays.
VARIANT structures should never be used without initialization.
VARIANT union ﬁelds should never be referenced without proper ﬁeld type value.
Interfaces should never be released without prior reference or initialization.
Dependencies modules should never be loaded without fully qualiﬁed path.

Fig. 8. Checked security properties

Properties

LOC

Procnum Bugs Check

Zero-sized allocations
Empty array constructor
VARIANT initialization
VARIANT type safety
Interface reference counting
Library path qualiﬁcation
DOM information disclosure

2.8M 58K
1.2M 3.1K
6.5M 196K
6.5M 196K
2M
11.2K
20M Millions
2.5M Hundreds

9
0
5
8
4
35
2

Fig. 9. Summary of results.

time
3h14
26m
5h03
5h03
2h26
5d
1h42

Inference
time
3h22
6m13
11h40
11h40
20h
N/A
N/A

and the interface reference counting were ran on a set of large
user-mode code bases making heavy use of such features. Two
properties affecting the VARIANT structures were checked
together on the same code-base, hence the check time and
inference time are the same for both.

Note that inference information is not available for two
properties:
the library path qualiﬁcation acted on tens of
millions of lines of code, a size for which inference is not
able to scale due to the sequential implementation. Likewise,
the DOM information disclosure property only affected class
accessors of the form CBrowserObj::get_attr totalizing
only a few hundred methods to check in just 8 different classes
for which the manual warning review process was fast enough
without inference.

In addition to the properties described in Figure 8, we
also uncovered security critical bugs from other checks. We
describe a couple of them next.

1) We also applied HAVOC (earlier version) to check
user-kernel pointer probing on the Windows application
APIs — to ensure that user-mode pointer should always
be validated by speciﬁc Probe* APIs before being
dereferenced in the kernel [20]. The effort on around
300KLOC revealed another 7 bugs that were ﬁxed.
These bugs are counted towards the 70 bugs that we
report.

2) We also discovered a set of errors during the translation
from C source ﬁles to the well-typed BoogiePL lan-
guage. One of the checked kernel driver was using the
following mechanism at multiple locations:
void fctelm() { (...) }
int syscall(int num) {

return ((*fctptrs[num])());

}
where syscall is a kernel entry-point returning an

integer error code to the unprivileged user, and fctelm
is a void-returning function, which is part of a function
pointer array fctptrs whose elements were supposed
to return an integer. Such unsafe function pointer ele-
ments in the array were possible at compilation time due
to the use of unsafe function pointer casts. Such defect
can result in information disclosure security vulnerabil-
ities since the return value (on the Pentium architecture,
held in the eax register) is uninitialized in the fctelm
function and used for another purpose (for example,
holding the pointer to sensitive kernel data structures).
We discovered around 30+ bugs in the driver that were
ﬁxed. These are in addition to the 70 bugs that were
found as variants of existing vulnerabilities.

C. Inter-procedural annotation inference

Inference is a useful technique to improve the checker’s
result when properties depend on the caller function context
and the results of callee functions.

Figure 10 shows the difference in number of false positives
when the user-guided annotation inference was used. Inter-
procedural analysis brings improvements in precision and
lessen the amount of false positives, but the impact varies by
the property. We found that for most sparse properties (such
as the API related properties where only small numbers of
checks are performed compared to the program size), the
number of warnings diminishes by 10% to 45% depending on
the checked property. A simple example of inference used to
check the zero allocation property used generated candidate
contracts of the form:

__cand_requires(param != 0)
__cand_ensures(__return != 0)

42

Properties

Zero-sized allocations
Empty array constructor
VARIANT initialization
VARIANT type safety
Interface reference counting
DOM information disclosure
Library path qualiﬁcation

Warnings Warnings
Warnings with inference
71
45
216
83
746
82
280

50
35
117
68
672 (3)
N/A
N/A

Improvement Candidates

29%
22%
45%
18%
10%
N/A
N/A

75162
4024
100924
100924
234K
N/A
N/A

Inferred
candidates
42160
446
770
770
1671
N/A
N/A

Fig. 10. Results of running annotation inference. “Candidates” denotes the number of candidate annotations and “Inferred candidates” is the number of
annotations that were inferred to hold.

int fct(int param) { ... }

D. Use of unsound modiﬁes clauses

for every function accepting integer parameters and integer
return values. Therefore, enforced preconditions of the form:

__requires(size != 0)
void* ExAllocatePool(unsigned int size);

can be checked with knowledge of the inferred (persisted)
constraints at function boundaries. In this case, the burden of
writing the candidate annotations before the checking phase
is performed is very small and provides a good payoff in
diminishing the number of false positives. We have applied this
methodology to multiple properties as indicated in Figure 10.
Properties such as “interface reference counting” are ones
for which inference is the most useful as the number of
pointers to be tracked within the target modules is generally
quite large. Such pointers can also sometimes passed between
modules, which limit the ability of inference to ﬁlter out
false positives. This is reﬂected in the false positive ratio of
Figure 10. In general, our experiments support the fact that
while inference does not sufﬁce to reach a perfect analysis
result, its use allow diminishing the burden of warning reviews
in an appreciable way for security auditors.

Annotation inference works best when the set of interme-
diate annotations can be concisely expressed using candidate
annotations that can be added with simple instrumentations. A
user starts with the property under check, inspects the warnings
from the checking and then devises a small set of candidates.
Annotation inference is performed and the new set of warnings
are noted and new candidates are added. The process remains
cost-effective up to a couple of iterations, beyond which the
auditor preferred to manually inspect the false alarms.

Cases where inference fails to diminish the number of
false positives include functions with aliasing between pointer
parameters for which no annotation can be synthesized without
introducing more complex conditional constraints. In other
cases, the annotations need to talk about type-states of deeply
nested ﬁelds of parameters, or global variables. While such
conditions can be encoded with modest manual effort for indi-
vidual functions, such a scheme will likely generate too many
candidate annotations for the modules under consideration.

In addition to using inference, we also performed an
evaluation with the use of modifies clauses, where extra
assumptions were added telling that the state of the heap did
not change when function calls are performed. This is an
unsound assumption but has the advantage of bringing down
the number of false positives drastically. For example, when
checking the interface reference counting property, enabling
this option brought the warning number down from 672 (after
using inter-procedural
inference) to 3, of which all were
valid vulnerabilities. We employed this unsound mechanism
for this particular property for two reasons: (1) the set of
alarms even after inference was very large, and (2) a random
sampling of the warnings revealed that state updates of the
interface pointers in callees was responsible for the false
alarms. No extra annotations were explicitly necessary for such
assumptions, as HAVOC-LITE provides an option through
the conﬁguration ﬁle. A similar decrease in warning numbers
is witnessed on other properties though this option is only
deemed necessary when the initial set of (false positive) alerts
is large enough to justify losing soundness.

E. Cost-effectiveness and warnings review

The cost-effectiveness of using an extended static checker
varies depending on each property. We found that security
properties related to API calls are generally sparse; only a few
calls are instrumented with assertions or candidates compared
to the total number of lines of code and procedures of the
analyzed modules. Checking ﬁeld dereference also came with
a reasonable return on investment as long as the number
of ﬁelds that were checked for dereferences remained small
enough. We found that
the number of false positives for
sparse properties (such as library path qualiﬁcation, zero-sized
allocations, VARIANT initialization or VARIANT type-safety)
was acceptable as we consistently found new vulnerabilities in
the reported warning list. Other denser properties (such as the
previous attempt of user kernel pointer probing) were harder
to check with only 5-10% of real vulnerabilities among the
total list of warnings. We explain this by the need to have
every single pointer dereference be instrumented, representing
tens of thousands of dereferences on medium sized modules.
Another interesting metric to measure the success of such
tool comes from the engineer feedback. We found that, on

43

average, a security expert can review between 25 and 50
warnings per day. For some properties involving very deep
inference and for which a function containing an alert has a
large number of callees, we found that it can take one to four
hours to review a single warning. This can also happen in case
of very complex control ﬂow that arises within or between
multiple components. Such cases often involve indirect call
sites via function pointers or virtual methods, including call-
backs that sometimes cross a domain boundary (i.e. user-mode
call-backs). For such instances of warnings, the help of a de-
bugger is often necessary to understand whether the discovered
vulnerable context is feasible, and more importantly, can be
controlled by the user. A bug may be benign from the security
perspective, if the variable values that can trigger the unsafe
behavior are not under the control of the user (for example,
the variables can be under control of a trusted third party
components on which the analysis was not performed).

Overall, we found that the use of HAVOC-LITE was cost-
effective compared to pure manual code review. A similar
analysis done purely in a manual fashion would have required
weeks if not months of work. The ability of static analysis to
focus on crucial control locations and speciﬁc data manipula-
tions was fundamental in this exercise. The ability to perform
inter-procedural inference brought down the warning number
consistently, saving hours of warning review to the analyst.

F. Found vulnerabilities

We now give a few examples of vulnerabilities that we were
able to identify using extended static checking, starting with
the interface reference counting vulnerability class.

1) Interface reference counting: The ﬁrst example (Fig-
ure 11) of found and ﬁxed vulnerability relates to the ref-
erence counting property of interfaces. The COM model
makes heavy use of interface pointers, in particular in object-
oriented projects like the browser where deep levels of in-
heritance are used and objects in different hierarchies share
some features. Those features are therefore implemented in
interfaces that classes can inherit without having to derive
from another class. The IUnknown interface serves as a
base interface for all other interface and class types (such
as CBrowserElement in this example) by implementing
three core methods called QueryInterface, AddRef and
Release. A call to QueryInterface accepts an interface
identiﬁer and returns an array of function pointers that repre-
sents the implementation of the desired interface. If no such
interface is available in the base object, QueryInterface
will return an error. Otherwise, it will return status code S_OK.
Note that QueryInterface also performs a call to AddRef
on the base class if the query is successful, so that the class
is not freed while the program still holds a reference onto
one of its interface. A critical safety property of such model
states that any pointer on a COM interface written to via a
call to QueryInterface should be released by a call to
ReleaseInterface after usage, except when the call to
QueryInterface failed (in that case, there is nothing to
release). The ReleaseInterface API is simply a wrapper

44

to the Release method that adds a wrapping check that
ensures that the interface pointer is not NULL (in that case,
the function is simply a NO OP).

HRESULT
IUnknown ∗
i f

h r ;
pUnk ;

( ! pElem ) {
h r = E INVALIDARG ;
goto End ;

}
h r = pElem−>Q u e r y I n t e r f a c e ( IID ExpectedType ,

1 CSomeElement : : add ( CBrowserElement ∗pElem ){
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 End :
17
18

}
h r = AddOption ( pElem , pElem−>s t r , FALSE ) ;
return ( S e t E r r o r I n f o ( h r ) ) ;

R e l e a s e I n t e r f a c e ( pUnk ) ;
i f

(S OK != h r ) {
h r = E INVALIDARG ;
goto End ;

( void ∗∗) &pUnk ) ;

}

Fig. 11. A real interface reference counting vulnerability (obfuscated)

In this example, this mechanism is used to guarantee that
a given browser element pElem is of the intended type.
However, the interface is never used as the looked up content is
automatically discarded via the call to ReleaseInterface
and the element is simply passed to method AddOption for
storage. A vulnerability exists when the QueryInterface
method fails and ReleaseInterface is still being called.
This is due to (1) the pUnk pointer being uninitialized
and (2) the return check being placed after the call
to
ReleaseInterface. The combination of those two bad
coding practices leads to a security vulnerability due to calling
method Release on an initialized interface pointer that will
later trigger in the form of a use-after-free vulnerabilities.
In order to exploit this ﬂaw for untrusted code execution,
an attacker would need to control the content of the stack
and make the stack offset used by local variable pUnk
coincides with the stack offset used by another reference-
counted class in a previous stack context (for example, in
a function previously called and already returned from, that
held a local variable at
just before
the call to CSomeElement::add was performed). Such
security exploits have already been demonstrated by industry
researchers.

the same stack offset

2) VARIANT type confusion: The second vulnerability class
(Figure 12) that we present
in this article is related to
the VARIANT data structure. The VARIANT data structure
is used in COM applications to transfer data items across
generic interfaces. A generic container for arrays of VARIANT
structures used in such COM programs is the DISPPARAMS
structure. This container type is used, among others, by the
IDispatch::Invoke interface method. A vulnerable spe-
cialization of this method is shown below. The CBrowserOp
class derives from IDispatch and overloads its Invoke
method. This derived method then assumes that
the ﬁrst

( ! dParams

| |

! dParams−>r g v a r g | |

! dParams−>r g v a r g [ 0 ] . p d i s p V a l ) {

switch ( d i s p I d ) {

case DISPID ONPROCESSINGCOMPLETE :

i f
return E INVALIDARG ;
}
e l s e {
IUnknown ∗pUnk = dParams−>r g v a r g [ 0 ] . p d i s p V a l ;
I N e e d e d I n t e r f a c e ∗ pRes = NULL;
HRESULT h r = pUnk−>Q u e r y I n t e r f a c e ( IID N e e d e d I f a c e ,
i f

1 STDMETHODIMP CBrowserOp : : Invoke ( DISPID d i s p I d , DISPPARAMS ∗ dParams )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

( h r == S OK) {
P e r f o r m A c t i o n ( pRes , dParams ) ;
R e l e a s e I n t e r f a c e ( pRes ) ;

break ;
d e f a u l t : return DISP E MEMBERNOTFOUND;

}
return S OK ;

{

}

}

}

( void ∗∗) &pRes ) ;

Fig. 12. A real VARIANT type confusion vulnerability (obfuscated)

VARIANT array element is an IUnknown interface pointer
(which is the base interface for all COM classes and COM
interfaces) and looks up the desired interface (using a call to
QueryInterface) needed to perform the effective COM
operation. The rest of the VARIANT array elements is then
passed to this newly looked-up interface. On success, the
action is performed and the interface is properly released.

The safety of VARIANT manipulation relies on test-
the contained pointer
ing its vt ﬁeld to make sure that
the interface is expect-
corresponds to a data type that
ing and able to treat. Failure to perform such check can
be devastating for the security of code, especially if the
input parameters are user-controlled. This method fails to
perform such check before calling QueryInterface on
the IUnknown pointer pUnk. If the ﬁrst VARIANT struc-
ture ﬁeld dParams→rgvarg[0].pdispVal were to con-
tain another
interface, a different method than
QueryInterface would be called. An attacker could redi-
rect execution onto an instruction pointer of its choice, leading
to a likely exploitable memory corruption in the program.
The appropriate ﬁx for this vulnerability is to extend the
conditional predicate to insert a test vt == VT_UNKNOWN
|| vt == VT_DISPATCH to make sure that the VARIANT
structure holds the appropriate interface pointer into which
the QueryInterface method is implemented, and returns
E_INVALIDARG if this is not the case.

type of

VI. RELATED WORK

Extended static checking was pioneered for Java by the
work of ESC/Java [1] as a means to use program veriﬁcation
methods to provide high coverage of user deﬁned assertions.
It has since then been applied to other languages such as
Spec# for C# [21], and HAVOC for C [2]. Unlike these
tools, HAVOC-LITE provides a rich set of instrumentation and

inference capabilities to reduce the manual burden for large
modules. HAVOC-LITE provides support for most common
C++ features used in legacy applications.

Software model checkers such as SLAM [22] offer auto-
matic annotation inference based on predicate abstraction for
sparse type-state properties. However, these approaches are not
known to scale to modules greater than 100KLOC, thus cannot
be applied to most of the modules in this work. Since these
tools strive for complete automation, their architecture does
not provide mechanisms for users to conﬁgure the analysis
by providing the set of candidates as HAVOC-LITE provides.
Saturn [23] provides precise intra-procedural analysis using
SAT solvers, and uses procedure summaries over a set of
ﬁxed vocabulary. The tool developer provides appropriate
summaries for various properties such as memory leaks, and is
not easily conﬁgurable. Saturn has been used to check speciﬁc
security properties such as validation of user-land pointers
passed to the kernel [24]; however, this required the careful
conﬁguration of the Saturn checker that cannot be expected of
an average security expert. Chen et al. [25] apply the model
checker MOPS to check similar type-state properties on a
million lines of code. However, the properties are restricted
to ﬁnite state machines and its harder for the users to describe
type-state properties on ﬁelds of objects.

Hackett et al. [26] provide a checker for buffer overruns
in legacy applications using a combination of buffer length
annotation and a set of custom rules to check these annota-
tions. The checker uses a custom constraint solver (not modern
SMT solvers) using a few simple rules. However, they provide
useful heuristics to infer buffer annotations (relating buffers to
their lengths) that signiﬁcantly reduces the annotation effort.
However, the technique cannot be readily extended to the
properties we discuss in this work and therefore not a good
match for security auditors.

45

Theorem provers have recently been quite successful in
dynamic test generation tools such as DART [27], EXE [28]
and SAGE [29]. These techniques leverage existing tests to
create path constraints that can be negated to obtain tests for
alternate paths. These techniques have revealed several bugs
in large applications (in integration testing) or small libraries
(in unit testing). However, these approaches are oblivious of
the property being checked and aim at providing higher path
coverage. These techniques do not use procedure summaries
(such as those provided by our candidate annotations) and
therefore cannot provide coverage guarantees on the entire
attack surface. Since these techniques are primarily based on
testing, they suffer from few false alarms. On the other hand,
they require setting up complex harnesses and have difﬁculty
being exhaustive for deep components. Besides, several of the
security properties (e.g. double free) do not lead to crashes
and are consequently harder to detect by testing based tools.
Recent work on Automated Exploit Generation [30] attempts
both vulnerability checking and input crafting in order to ﬁnd a
code defect and force execution to be redirected on malicious
code. Such an approach has been focused on basic security
properties such as buffer overﬂow induced by insecure APIs
like strcpy . Such combination of SMT solvers and dynamic
test generation is an interesting approach guaranteeing that
identiﬁed vulnerabilities are real and does not require warning
triage. Improvements in performance and expressiveness (such
as extending preconditioned symbolic execution [31]) will al-
low more properties to be checked. However, such framework
provides very limited conﬁgurability for a security auditor and
does not guarantee as much coverage as an extended static
checker.

Security properties such as the VARIANT type consis-
tency [32] and the reference counting invariants [33] have pre-
viously been studied for COM programs and web browsers via
run-time monitoring and unit testing. However, no systematic
program analysis was performed to the extent of this work.
As such, no guarantee of coverage could be made based upon
concrete executions of the program under scrutiny. HAVOC-
LITE provides security auditors with extended security audit
abilities and allow focusing on code locations where such
security properties could not be proved. As such, extended
static checking provides a much stronger guarantee that no
instance of such vulnerability has been left behind.

VII. CONCLUSIONS

Extended static checking is a good complement to fuzz
testing and other data-ﬂow based static analysis techniques. In
particular, the inter-procedural inference is a key component
in diminishing the number of false positives (sometimes up
to 45%) to an acceptable level for security experts to review.
Nonetheless, the cost associated to running the inference is still
high. Our goal is to extend the two-level Houdini algorithm to
a distributed version that can invoke multiple versions of the
inner Houdini algorithm in parallel. HAVOC-LITE currently
does not weigh warning conﬁdence and users have to go
through the entire list of alerts to have a faithful understanding

46

of the results — performing warning prioritization is an
important next step for HAVOC-LITE.

ACKNOWLEDGMENTS

We would like to thank the anonymous reviewers and our
shepherd Patrick McDaniel for improving the presentation of
the paper. We are grateful to Mark Wodrich and Ali Rahbar
from the MSRC team for their help in deploying the tool, and
to Shaz Qadeer for his help in porting the tool to the latest
build environment in Windows.

REFERENCES

[1] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and
R. Stata, “Extended static checking for Java,” in Programming Language
Design and Implementation (PLDI’02), 2002, pp. 234–245.

[2] T. Ball, B. Hackett, S. K. Lahiri, S. Qadeer, and J. Vanegue, “Towards
scalable modular checking of user-deﬁned properties,” in Veriﬁed Soft-
ware: Theories, Tools, Experiments (VSTTE ’10), vol. LNCS 6217, 2010,
pp. 1–24.

[3] Satisﬁability Modulo Theories Library (SMT-LIB), “Available at

http://goedel.cs.uiowa.edu/smtlib/.”

[4] C. Flanagan and K. R. M. Leino, “Houdini, an annotation assistant
for ESC/Java,” in International Symposium of Formal Methods Europe
(FME ’01), 2001, pp. 500–517.

[5] M. Dahlweid, M. Moskal, T. Santen, S. Tobies, and W. Schulte, “Vcc:
Contract-based modular veriﬁcation of concurrent c,” in International
Conference on Software Engineering, (ICSE ’09), Companion Volume,
2009, pp. 429–430.

[6] B. Chess, “Improving computer security using extended static checking,”

in IEEE Symposium on Security and Privacy, 2002, pp. 160–.

[7] Component

Object

Model

(COM),

“Available

at

http://www.microsoft.com/com/default.mspx.”

[8] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and
R. Stata, “Extended static checking for Java,” in Programming Language
Design and Implementation (PLDI’02), 2002, pp. 234–245.

[9] R. DeLine and K. R. M. Leino, “BoogiePL: A typed procedural language
for checking object-oriented programs,” Microsoft Research, Tech. Rep.
MSR-TR-2005-70, 2005.

[10] J. Condit, B. Hackett, S. K. Lahiri, and S. Qadeer, “Unifying type
checking and property checking for low-level code,” in Principles of
Programming Languages (POPL ’09), 2009, pp. 302–314.

[11] M. Barnett and K. R. M. Leino, “Weakest-precondition of unstructured
programs.” in Program Analysis For Software Tools and Engineering
(PASTE ’05), 2005, pp. 82–87.

[12] S. K. Lahiri, S. Qadeer, and Z. Rakamaric, “Static and precise detection
of concurrency errors in systems code using smt solvers,” in Computer
Aided Veriﬁcation (CAV ’09), vol. LNCS 5643, 2009, pp. 509–524.
bulletin ms10-054

-
[Online]. Available: http://technet.microsoft.com/en-

[13] MSRC MS10-054,

“Microsoft

security

critical,” 2010.
us/security/bulletin/MS10-054

[14] MSRC MS11-092,

critical,” 2011.
us/security/bulletin/MS11-092

[15] MSRC MS09-034,

critical,” 2009.
us/security/bulletin/MS09-034

“Microsoft

-
[Online]. Available: http://technet.microsoft.com/en-

bulletin ms11-092

security

“Microsoft

-
[Online]. Available: http://technet.microsoft.com/en-

bulletin ms09-034

security

[16] MSRC MS11-093,

-
important,” 2011. [Online]. Available: http://technet.microsoft.com/en-
us/security/bulletin/MS11-093

bulletin ms11-093

“Microsoft

security

[17] MSRC MS11-018,

“Microsoft

-
[Online]. Available: http://technet.microsoft.com/en-

bulletin ms11-018

security

[20] MSRC MS08-066,

-
important,” 2008. [Online]. Available: http://technet.microsoft.com/en-
us/security/bulletin/MS08-066

bulletin ms08-066

“Microsoft

security

critical,” 2011.
us/security/bulletin/MS11-018

[18] MSRC MS12-074,

critical,” 2012.
us/security/bulletin/MS12-074

[19] MSRC MS11-050,

critical,” 2011.
us/security/bulletin/MS11-050

“Microsoft

-
[Online]. Available: http://technet.microsoft.com/en-

bulletin ms12-074

security

“Microsoft

-
[Online]. Available: http://technet.microsoft.com/en-

bulletin ms11-050

security

[21] M. Barnett, K. R. M. Leino, and W. Schulte, “The Spec# programming
system: An overview.” in Construction and Analysis of Safe, Secure and
Interoperable Smart Devices (CASSIS ’05), 2005, pp. 49–69.

[22] T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani, “Automatic
predicate abstraction of C programs,” in Programming Language Design
and Implementation (PLDI ’01), 2001, pp. 203–213.

[23] A. Aiken, S. Bugrara, I. Dillig, T. Dillig, B. Hackett, and P. Hawkins,
“An overview of the Saturn project,” in Workshop on Program Analysis
for Software Tools and Engineering (PASTE ’07), 2007, pp. 43–48.

Blackhat USA brieﬁngs, 2009.

[33] S. Chen, H. Chen, and M. Caballero, “Residue objects: a challenge to
web browser security,” in Proceedings of the 5th European conference
on Computer systems, ser. EuroSys ’10. ACM, 2010, pp. 279–292.

[24] S. Bugrara and A. Aiken, “Verifying the safety of user pointer derefer-
ences,” in IEEE Symposium on Security and Privacy, 2008, pp. 325–338.
[25] H. Chen, D. Dean, and D. Wagner, “Model checking one million lines of
c code,” in Proceedings of the Network and Distributed System Security
Symposium (NDSS’04), 2004.

[26] B. Hackett, M. Das, D. Wang, and Z. Yang, “Modular checking for
buffer overﬂows in the large,” in International Conference on Software
Engineering (ICSE ’06), 2006, pp. 232–241.

[27] P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated
random testing.” in Programming Language Design and Implementation
(PLDI ’05). ACM, 2005, pp. 213–223.

[28] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
“Exe: automatically generating inputs of death,” in ACM Conference on
Computer and Communications Security, 2006, pp. 322–335.

[29] P. Godefroid, M. Y. Levin, and D. A. Molnar, “Sage: whitebox fuzzing
for security testing,” Commun. ACM, vol. 55, no. 3, pp. 40–44, 2012.
[30] H. B. L. T. Avgerinos Thanassis, Cha Sang Kil and B. David, “Aeg:
Automatic exploit generation,” ser. Network and Distributed System
Security Symposium, 2011.

[31] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
mayhem on binary code,” in Proceedings of the 2012 IEEE Symposium
on Security and Privacy, ser. SP ’12. Washington, DC, USA:
IEEE Computer Society, 2012, pp. 380–394.
[Online]. Available:
http://dx.doi.org/10.1109/SP.2012.31

[32] M. Dowd, R. Smith, and D. Dewey, “Attacking interoperability,” ser.

47

