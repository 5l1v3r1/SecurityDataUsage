Practical Issues with TLS Client Certiﬁcate

Authentication

Software Technology and Applications Competence Center, Estonia

Arnis Parsovs

University of Tartu, Estonia

arnis@ut.ee

Abstract—The most widely used secure Internet communication
standard TLS (Transport Layer Security) has an optional client
certiﬁcate authentication feature that in theory has signiﬁcant
security advantages over HTML form-based password authenti-
cation. In this paper we discuss practical security and usability
issues related to TLS client certiﬁcate authentication stemming
from the server-side and browser implementations. In particular,
we analyze Apache’s mod_ssl implementation on the server
side and the most popular browsers – Mozilla Firefox, Google
Chrome and Microsoft Internet Explorer on the client side. We
complement our paper with a measurement study performed in
Estonia where TLS client certiﬁcate authentication is widely used.
We present our recommendations to improve the security and
usability of TLS client certiﬁcate authentication.

I.

INTRODUCTION

Use of the TLS protocol is a standard way to secure an
Internet connection between a client’s browser and HTTP
web servers. Most commonly, TLS is used to authenticate the
server, in order to assure the client that the communication is
being performed with a legitimate party and that the secrecy
and the integrity of all data exchanged between the client
and the server is ensured. To authenticate oneself to the
server, the client usually has to submit some identiﬁcation data
(such as a username) and secret information that is shared
between the client and the server (such as a password) over an
already established server-authenticated secure channel. There
are various ways in which this process can fail, ending up with
the client disclosing his shared secret to an attacker rather
than to a legitimate server. As a consequence, the attacker
can access the victim’s account on a legitimate server, obtain
the victim’s private information stored on the server, and
perform actions on the server with the privileges of the victim.
The attacker can obtain a shared secret in various ways, for
example: by phishing attacks; by compromising another web
service where the victim might have reused the same secret; by
tricking the victim into sending the secret over a channel that
is not protected by TLS; by compromising a trusted certiﬁcate
authority (CA), or by, in any other way, fraudulently obtaining
the certiﬁcate of a legitimate server signed by a trusted CA and
then using it in a man-in-the-middle (MITM) attack.

Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1)Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:17)(cid:20)(cid:23)

Active security research is being conducted to improve
password security, educate users on how to resist phishing
attacks, and to ﬁx CA trust issues [1], [2]. However, the attacks
mentioned above can be prevented or their impact can be
greatly reduced by using TLS client certiﬁcate authentication
(CCA), since the TLS CCA on the TLS protocol level protects
the client’s account on a legitimate server from a MITM
attacker even in the case of a very powerful attacker who has
obtained a valid certiﬁcate signed by a trusted CA and who
thus is able to impersonate the legitimate server. We believe
that TLS CCA has great potential for improving Internet
security, and therefore in this paper we discuss current issues
with TLS CCA and provide solutions that will improve the
security of TLS CCA and enable its usage on a larger scale.

With this paper, we make the following contributions:
• We provide the ﬁrst systematic analysis of previously
known and less known issues that are related to deploy-
ing TLS CCA in practice.

• We present a detailed report of a measurement study in
which the TLS CCA deployments of 87 Estonian service
providers are analyzed.

• We give a list of recommendations on how to solve the
problems identiﬁed to improve and facilitate the use of
TLS CCA.

The rest of the paper is organized as follows. Section II
provides a description of the TLS protocol
in a server-
authenticated and client-authenticated setting, and gives a brief
security analysis of the protocol. Section III discusses TLS
CCA-related issues. Section IV analyzes the measurement
study of Estonian service providers who provide the TLS CCA
option. Our recommendations for both the client and server
side are provided in Section V. The related work is discussed
in Section VI. Section VII concludes the paper.

II. TLS OVERVIEW

The TLS protocol and its predecessor, SSL (Secure Sockets
Layer), have several versions. In this paper, when referring to
the TLS protocol we mean the most widely supported TLS
version 1.0 [3]. The description given here applies also to the
latest protocol versions 1.1 and 1.2 since they do not introduce
any changes related to TLS CCA. Previous versions SSL 2.0
and SSL 3.0 differ only by their behavior when the client does
not want to perform CCA (no_certificate alert message
is sent instead of an empty client Certificate message).

A. Server-authenticated TLS Handshake

Fig. 1 shows protocol messages exchanged between a client
and server during TLS protocol negotiation (for simplicity, we
cover only RSA key exchange mechanism). Before encrypted
and integrity protected application data can be exchanged, the
TLS handshake has to be completed to negotiate commonly
supported cipher suites and other protocol parameters.

A TLS connection is initiated by the client’s ClientHello
message, which contains a list of cipher suites that
the
client supports and the client’s randomness which is unpre-
dictable for every TLS connection. The server replies with
the ServerHello message, which contains the server’s
randomness and one cipher suite selected from the client’s
ClientHello message. This cipher suite will be used for the
TLS session key exchange, encryption and integrity protection.
Then, in the Certificate message the server provides one
or more X.509 certiﬁcates that should be used by the client
to build the certiﬁcate chain. The ﬁrst certiﬁcate given in the
server’s Certificate message is assumed to be the server’s
certiﬁcate to which a corresponding private key is in the
server’s possession. The server ﬁnishes its round by sending
a ServerHelloDone message. In turn, the client generates
a random value – the pre-master secret which should be used
by both parties to derive symmetric keys used for the chosen
cipher suite – and encrypts it with the server’s public key
obtained from the server’s certiﬁcate. The encrypted pre-master
secret is sent to the server in the ClientKeyExchange
message. Then the client sends a ChangeCipherSpec mes-
sage which signals to the other party that all further messages
coming from the client will be protected by the negotiated
cipher suite and symmetric keys. The last handshake message
Finished is sent already encrypted and contains a hash
of all previous messages exchanged between the client and
the server. The server compares the decrypted hash with the
hash of all previous handshake messages. The client performs
a similar veriﬁcation with the server’s Finished message
and the exchange of encrypted application data can now be
performed.

Since the client encrypts the pre-master secret with the
public key of the server, only the server which possesses
the corresponding private key can decrypt the content of the
ClientKeyExchange message and thus obtain symmetric
keys which are used to protect further communication. In
general, TLS is secure against passive and active network
attacks as long as the client uses a public key that really
belongs to the server he is willing to communicate with.
In practice, public-key infrastructure (PKI) is used to verify
the authenticity of the public key provided in the server’s
Certificate message.

B. Client-authenticated TLS Handshake

In the client-authenticated TLS handshake the server ad-
ditionally requests
the client’s certiﬁcate by sending a
CertificateRequest message. This message contains a
list of distinguished names (DNs) of CAs that the server trusts.
This list may be used by the client to choose an appropriate
certiﬁcate that should be sent to the server in the client’s
Certificate message. The client’s Certificate mes-
sage, similarly to the server’s Certificate message, may
contain several certiﬁcates that may be used by the server to
build the certiﬁcate chain up to the CA that the server trusts.
If a client does not have a certiﬁcate or does not want to

ClientHello

ServerHello, Certiﬁcate, CertiﬁcateRequest, ServerHelloDone

Certiﬁcate, ClientKeyExchange, CertiﬁcateVerify

Client

[ChangeCipherSpec], Finished

[ChangeCipherSpec], Finished

Application Data

Server

Fig. 1: TLS handshake involving CCA and using RSA as key
exchange mechanism. The messages related to optional client
certiﬁcate authentication are emboldened.

perform CCA, the client can send an empty Certificate
message and then the server can decide whether to complete
the handshake without the client’s certiﬁcate.

The proof that the client has access to the private key that
corresponds to the public key in the client’s certiﬁcate is
given by calculating the hash of all the previous handshake
messages exchanged between the client and the server so far
and signing it with the client’s private key. This signature
is sent in the client’s CertificateVerify message. The
CertificateVerify message is omitted if the client has
sent an empty Certificate message.

The main advantage of TLS CCA compared to authentica-
tion methods in which a shared secret is disclosed to the server,
is that in the TLS CCA process a client proves to the server
that he has access to the private key, but the private key itself
is never disclosed to the server.

As can be seen, the signature given using the client’s private
key is bound to the client’s and the server’s randomness, the
server’s certiﬁcate and the encrypted pre-master secret sent by
the client. This means that even an attacker that has obtained
the signature in a MITM attack, cannot reuse the signature
in any other TLS handshake either with the legitimate server
or any other server. As a result, in cases where TLS CCA
is used, the attacker cannot impersonate the victim to the
legitimate server even if the attacker is able to impersonate
the legitimate server. A server impersonation attack is still
a problem if the attacker’s goal is to obtain sensitive data
from the user and not from the server, for example, in a
scenario where a user submits sensitive data to the server right
away, without being able to detect the impersonation attack in
another way (e.g., by visually noticing that the authenticated
environment provided by the attacker does not fully replicate
the personalized environment of the legitimate server).

Therefore, we see that, at least in theory, TLS CCA is
secure even against a very powerful attacker that is able to
successfully impersonate the legitimate server.

C. Renegotiation

The TLS server at any time can send the client a
HelloRequest message, thereby requesting the client to
initiate a new TLS handshake. In the renegotiation process the
messages of the new handshake are cryptographically protected
by the cipher suite negotiated in the previous handshake.
The practical use of renegotiation could be, for example, to
negotiate a stronger cipher suite or to perform CCA if the
client at the application level wants to access server resources
that must be protected by such security measures according to
the server’s local security policy.

2

The client can also initiate renegotiation by sending a
ClientHello message at any time, but there is no practical
reason for the client
therefore client-initiated
renegotiations are usually disabled by the servers.
D. Session Resumption

to do that;

The TLS session resumption feature allows an abbreviated
TLS handshake to be performed by skipping the key agreement
phase. The client can resume a TLS session by specifying
a session identiﬁer in the ClientHello message from the
TLS session negotiated previously. If the TLS server is willing
to resume the session, the server will reply with the same
session identiﬁer in the ServerHello message, otherwise a
new session identiﬁer will be included and a full handshake
will be performed. The abbreviated handshake saves time by
avoiding one round-trip across the network, plus one private
key operation on the server side (and one on the client side
if CCA has to be performed). Note that instead of storing the
session state on the server side, the TLS extension [4], which
is becoming widely supported, allows it to be stored encrypted
on the client side.

Session resumption is especially important when the private
key used for CCA is stored in a cryptographic token such as
a smart card. If session resumption is not used, the smart card
would have to perform a signing operation on every HTTP
request that initiates a new TLS connection. That would add
a signiﬁcant delay to the TLS handshake process and would
rapidly use up the private key use limit that is often enforced
by smart cards.

Note that the effectiveness of the TLS session resumption
also depends on the particular browser used and browsing
characteristics. For example, if the user navigates to another
page before a page has been fully loaded, the current TLS
session might be aborted and therefore would become non-
resumable.

III. PRACTICAL ISSUES

In this section we will summarize already known problems
and describe some new ones we have discovered. We follow
the convention that the issues described here, except when
explicitly described as our ﬁndings, are publicly known or have
been identiﬁed by others.

To enable TLS CCA on the server side, most service
providers use an Apache HTTP server with the module
mod_ssl [5], which relies on OpenSSL library to implement
TLS functionality. In this section we will analyze server side
issues considering only Apache mod_ssl and in particular
legacy branch 2.2 (version 2.2.22), which is currently shipped
with most operating systems. All CCA-related aspects de-
scribed here also apply to the latest stable branch 2.4 (with the
exception of client certiﬁcate revocation checking). Analysis of
less popular TLS CCA implementations such as IIS, Oracle-
AS, BigIP and Nginx we leave for future work.

On the client side we will analyze TLS CCA support as
implemented in the three most popular browsers – Mozilla
Firefox version 19.0 on Linux and Windows 7, Google Chrome
version 25.0 on Linux and Windows 7, and Microsoft Internet
Explorer (IE) version 9.0 on Windows 7.
A. Apache mod_ssl Conﬁguration

There are several mod_ssl conﬁguration directives that
help to conﬁgure CCA on the server side. However, we
found that the ofﬁcial mod_ssl documentation might give

an incorrect understanding of the behavior these directives
introduce; therefore, we will give a brief but clear description
here.

SSLVerifyClient is the main conﬁguration directive
regulating TLS CCA. This directive can be speciﬁed in a
server-wide context or per-directory context. When speciﬁed
in a server wide context, the setting applies to the initial TLS
handshake. If speciﬁed in a directory context, the server will
request TLS renegotiation after receiving an HTTP request for
resources in that directory. If the renegotiation is successful,
the request will be processed and the response will be sent
back over the renegotiated session.

require CCA, and thus

therefore the server will not

The default value none of SSLVerifyClient does
not require CCA;
include a
CertificateRequest message in the TLS handshake.
The value require will
the
CertificateRequest message will be included in the
handshake. If the client does not provide any certiﬁcate in
the client’s Certificate message or mod_ssl fails to
verify the certiﬁcate provided, the TLS handshake will be
aborted and a fatal TLS alert message will be sent to the
client. The value optional is the same as require, but
an empty client’s Certificate message will be tolerated.
The last possible value optional_no_ca is the same as
optional, but in addition it allows a client’s certiﬁcate to be
submitted that does not chain up to the CA trusted by the server
(because of a bug in OpenSSL [6] not yet valid or expired
non-self-signed client certiﬁcates will also be accepted). The
value optional_no_ca can be used to perform certiﬁcate
veriﬁcation at an application level or to implement PKI-less
public-key authentication that uses X.509 certiﬁcates as a
public-key transport (see Section III-J).

The SSLCACertificateFile directive speciﬁes a loca-
tion where self-signed root CA certiﬁcates trusted by the server
and their intermediate CA certiﬁcates are located.

The SSLVerifyDepth directive sets a limit for the length
that a certiﬁcate chain built in veriﬁcation process may have.
The SSLCADNRequestFile directive speciﬁes a location
of certiﬁcates which will be used to build a list of DNs that will
be sent in the server’s CertificateRequest handshake
message. If this directive is not set, the DNs of certiﬁcates in
SSLCACertificateFile will be used for this purpose.

After a successful TLS handshake, the mod_ssl will set
environment variables that can be used by the server-side
application to perform further authorization based on the
data from CCA. For example, variable SSL_CLIENT_CERT
will contain the PEM-encoded client certiﬁcate, and variable
SSL_CLIENT_VERIFY will contain the value:
• NONE: if the client certiﬁcate was not provided.
• SUCCESS:
• GENEROUS:

if client certiﬁcate veriﬁcation using the
SSLCACertificateFile trust store was successful.
to
certiﬁcate
optional_no_ca
did not
chain up to the CA speciﬁed in the
(because
SSLCACertificateFile
of mod_ssl bug [7] and [8] this is not always the
case).

if SSLVerifyClient is

client

store

trust

and

the

set

• FAILED:reason: contrary to the ofﬁcial documenta-

tion this value is not used.

3

B. Veriﬁcation

Certiﬁcate veriﬁcation is performed by OpenSSL using the
veriﬁcation algorithm described in [9]. Certiﬁcates speciﬁed in
SSLCACertificateFile are loaded into OpenSSL trust
store. It is important to emphasize here that for a successful
veriﬁcation the client certiﬁcate chain must not only build up
to a certiﬁcate found in the trust store, but this certiﬁcate
must also be self-signed. In addition, note that OpenSSL will
use extra certiﬁcates provided in the client’s Certificate
message in building the certiﬁcate chain. As a result, the
conﬁguration options provided by mod_ssl are not sufﬁcient
to implement CCA securely in an advanced public-key infras-
tructure setting without performing additional veriﬁcation at
the application level.

For instance, the Estonian CA “AS Sertiﬁtseerimiskeskus”
(SK) has a root certiﬁcate and several intermediate CA cer-
tiﬁcates, but only one particular intermediate CA issues au-
thentication certiﬁcates for natural persons that are loaded into
an Estonian ID card (a smart card storing corresponding RSA
keys). A straightforward approach, as instructed by SK [10], to
put into SSLCACertificateFile the SK root certiﬁcate
and the certiﬁcate of an intermediate CA issuing ID card
authentication certiﬁcates, will actually not guarantee that
in the case of successful authentication the accepted client
certiﬁcate will be signed by that particular intermediate CA.
The veriﬁcation process will also be successful in the case
where a client certiﬁcate is issued by SK root CA directly or
by any other intermediate CA issued by the SK root CA.

This can be exploited in practice by, for example, compro-
mising some other intermediate CA that is used for other pur-
poses (e.g., testing) and therefore has weaker protection, or by
fraudulently obtaining a certiﬁcate from another intermediate
CA that is meant to be used in a different context and thereby
has a lower assurance level and less stringent requirements for
identity veriﬁcation in the registration process. Finally, it might
hold that intermediate CAs are operated by mutually hostile
parties.

It is not trivial to perform certiﬁcate chain post-veriﬁcation at
application level. The mod_ssl exports the client certiﬁcate
in the SSL_CLIENT_CERT environment variable and extra
certiﬁcates provided in the client’s Certificate message in
the SSL_CLIENT_CERT_CHAIN_n variables (not preserved
on session resumption), but the chain used in the veriﬁcation
process is not exported.

Most TLS CCA deployments in practice use require or
optional values for the SSLVerifyClient conﬁguration
directive, and as we have found from private discussion with
service providers,
the only veriﬁcation step performed at
the application level is to check whether the commonName
attribute of the subject DN in the client certiﬁcate contains
the name and personal identity code of the natural person
in the expected form (mod_ssl provides subject DN in
the environment variable SSL_CLIENT_S_DN or it can be
extracted from the client certiﬁcate using, for example, the
function openssl_x509_parse()1 available in PHP). If
this check succeeds, the person is assumed to be authenticated
and the server-side application continues with the authorization
using the extracted personal identity code.

1http://www.php.net/manual/en/function.openssl-x509-parse.php

C. Reconnaissance

We found that all mod_ssl and OpenSSL client certiﬁ-
cate veriﬁcation checks are done before the client has sent
his CertificateVerify message proving that he is in
possession of a corresponding private key. This allows the
enumeration of the server’s trust settings by using certiﬁcates
which may be easily obtained by the attacker. For example,
an attacker could send an arbitrary certiﬁcate in the client’s
Certificate message and observe whether the server
aborts the handshake by sending an alert message before
receiving the client’s CertificateVerify message. If
the server does not abort the connection, the attacker can
conclude that the certiﬁcate in question is indeed located in
the server’s SSLCACertificateFile trust store (unless
SSLVerifyClient is set
to optional_no_ca). Note
that the server’s trust settings in the form of DNs of the
CAs located in the server’s trust store are also disclosed
in the CertificateRequest message, if not explicitly
overridden by the SSLCADNRequestFile directive.

The value of SSLVerifyClient can be similarly deter-
mined, for instance, by sending an arbitrary self-signed client
certiﬁcate in a TLS CCA handshake. If the handshake suc-
ceeds, the SSLVerifyClient is set to optional_no_ca.
Otherwise, an empty Certificate message can be sent to
distinguish between optional and require.

However, we have discovered that an attacker can also
the attacker
determine the SSLVerifyDepth value if
has any root certiﬁcate that
is located in the server’s
SSLCACertificateFile trust store. In order to do that
an attacker has to send a fake certiﬁcate chain in the client’s
Certificate message, that chains up to any root certiﬁ-
cate in the server’s SSLCACertificateFile trust store.
Certiﬁcates in the fake chain have to contain the correct
issuer description so that the certiﬁcate chain building al-
gorithm in OpenSSL succeeds; however, the signatures on
the certiﬁcates must be invalid. If the SSLVerifyDepth
has been exceeded, the server will abort the handshake by
sending a certificate_unknown alert message. How-
ever, if the SSLVerifyDepth was not exceeded, OpenSSL
will continue with signature veriﬁcation on the certiﬁcate
chain, which will
fail and the TLS handshake will be
aborted with a decryption_failed alert message. If the
SSLVerifyClient option optional_no_ca is used, the
attacker can send a fake chain that chains up to any attacker’s
chosen self-signed root CA certiﬁcate that
is included in
the attacker’s Certificate message. In this case, if the
SSLVerifyDepth has been exceeded the handshake will
fail with an unknown_ca alert message.

D. Privacy of Client’s Certiﬁcate

As can be seen in Fig. 1, the client’s Certificate mes-
sage is sent before encryption has been applied; therefore, the
content of a client’s certiﬁcate is available to passive network
attackers. Certiﬁcates issued by CAs to natural persons usually
contain at least the name and personal identity code of a per-
son. Even if a certiﬁcate does not include any personal data, the
public key in the certiﬁcate can be used by a passive network
attacker to track the client. A TLS extension [11] has been
proposed for standardization to the IETF Network Working
Group that allows a client certiﬁcate to be encrypted in the
initial TLS handshake by moving the client’s Certificate
message after the client’s ChangeCipherSpec message.

4

Another proposed TLS extension [12] provides opportunistic
encryption for the whole TLS handshake. However,
these
extensions have not yet been standardized and even if they
had, it would take years for them to be widely deployed and
supported.

A practical workaround that can be used to protect the
client certiﬁcate is for a server to request the client certiﬁ-
cate on renegotiation. This way, the client’s Certificate
message will be encrypted by the cipher suite negotiated
by the previous TLS negotiation. As stated before, this can
be conﬁgured by specifying mod_ssl conﬁguration direc-
tive SSLVerifyClient in the Apache directory context.
However,
the renegotiation has a negative impact on per-
formance, since an additional handshake is performed when
renegotiating. The performance can be improved if the TLS
session resumption is enabled by both a client and a server.
Unfortunately, recent versions of mod_ssl do not support
resumption of TLS sessions that have been established on
renegotiation [13].

We have observed that none of the browsers analyzed warn
the user about the privacy leak if the TLS server requests CCA
on initial TLS negotiation.
E. Denial-of-service Attack Vectors

The TLS CCA enabled mod_ssl faces additional denial-
of-service (DoS) attack vectors. On the server-side OpenSSL
has to perform ASN.1 parsing on arbitrary certiﬁcates that
are provided in the client’s Certificate message. The
signatures on a built chain have to be veriﬁed and the client’s
signature of handshake messages provided in the client’s
CertificateVerify message must also be veriﬁed. Pars-
ing of ASN.1 structures is not a trivial task and OpenSSL
has had security vulnerabilities that can be exploited if ASN.1
parsing is performed on untrusted data [14]. Recently a DoS
attack tool2 has been released which exploits computational
asymmetry in a server-authenticated TLS handshake.

message is larger than 100 kilobytes;

But what impact might the TLS CCA have on a server? We
found that there are several limitations enforced by OpenSSL:
• the handshake will fail if the client’s Certificate
• the handshake will fail if the CertificateVerify
message is larger than 512 bytes, which means that the
maximum length of the RSA modulus that the client’s
public key can have is 4096 bits.

• chain building will stop when its depth exceeds 100;
• the signatures of the certiﬁcate chain will not be veriﬁed
if the chain is larger than the depth conﬁgured by the
mod_ssl SSLVerifyDepth directive;

In addition to the above, signature veriﬁcation will not be
performed and will fail if the modulus of the RSA public key
is larger than 16384 bits or if the public exponent for a RSA
public key whose modulus is larger than 3072 bits is larger
than 64 bits. Our experiment shows that with an “Intel Core
2 Duo U7700@1.33GHz” processor, 26 RSA veriﬁcations per
second can be performed with a public key having a 16384-
bit modulus and the maximum allowed 64-bit public exponent,
and only 20 RSA veriﬁcations per second with a public key
having a 3072-bit modulus and a 3072-bit public exponent.

Since the signatures on a certiﬁcate chain are veriﬁed starting
from the root CA certiﬁcate down to the client certiﬁcate, an

2http://www.thc.org/thc-ssl-dos/

5

attacker would need to have a certiﬁcate in a certiﬁcate chain
whose public key had these characteristics and was signed
by a CA that chained up to a root CA located in server’s
SSLCACertificateFile trust store, which is unlikely to
happen. Unfortunately, if the SSLClientVerify is set to
optional_no_ca,
the attacker can provide an arbitrary
certiﬁcate chain in the Certificate message and signatures
will be veriﬁed by OpenSSL as long as the chain does not
exceed the depth limit conﬁgured by SSLVerifyDepth. The
default conﬁguration value for SSLVerifyDepth is 1, which
would result in OpenSSL performing two signature veriﬁcation
operations per handshake – one to verify the signature on the
certiﬁcate chain and another to verify the signature given in the
CertificateVerify message. The worst case scenario,
where SSLClientVerify is set to optional_no_ca and
SSLVerifyDepth is set to 100, would allow an attacker to
send a certiﬁcate chain in a Certificate message contain-
ing 75 certiﬁcates (whose public keys have a 3072-bit modulus
and a 3072-bit public exponent) reaching almost 100KB of the
maximum allowed for a Certificate message size, and
would force a server that had the processor described above
to spend four seconds of wall time processing the handshake.
Another DoS attack vector exists if the server requests
TLS CCA on renegotiation after receiving an HTTP request.
The problem in this scenario is that
the request body of
an HTTP request has to be buffered by the server before
renegotiation is performed and the request body can be pro-
cessed or discarded by the target resource [15]. To prevent
possible memory exhaustion by a DoS attack, mod_ssl
provides conﬁguration directive SSLRenegBufferSize,
which limits the request body size that may be buffered
by the server (the default value is 256KB). If the client
sends a larger request body,
the server will return error
413 Request Entity Too Large. This creates a prob-
lem if the server must support
large POST requests. The
workaround that can be used by the client is to include a header
ﬁeld Expect: 100-continue in the request header sent
to the server, sending the request body only after the TLS CCA
has been performed and the server has responded with status
code 100 Continue [15]. Unfortunately, this mechanism is
not used by browsers [16] and therefore servers that require
TLS CCA on renegotiation and must support large POST
requests will have to set SSLRenegBufferSize to a large
value, thereby providing a DoS attack vector.

F. Freshness of the Client’s Proof

In a CCA process the client proves to the server that he has
access to the private key that corresponds to the public key
in the client’s certiﬁcate. This is done by signing a message
digest of previously exchanged TLS handshake messages and
providing a signature in the client’s CertificateVerify
message. For a server-side application it is crucial to determine
the freshness of this proof. For example, the server’s security
policy might require that before some authenticated action can
be performed, the client must prove that he has had recent
access to his smart card. We have found that there is no
environment variable provided by mod_ssl that could be used
to reliably determine the freshness of the proof given in the
TLS CCA process. From the protocol description we see that
the client cannot compute a signature before the server has
sent its ServerHello message which contains the server’s
randomness and therefore cannot be predicted by the client,

while the contents of all further messages up to the client’s
CertificateVerify message can be predicted by the
client. Therefore, the freshness of a client’s possession of the
private key could be determined by the timestamp indicating
the moment when the server sent its ServerHello message.
We found that even if TLS session resumption is not enabled,
the time of the HTTP request cannot be reliably used by the
server-side application to calculate the freshness of the client’s
proof of possession. The assumption does not hold that the
TLS connection will timeout if the CertificateVerify
message is not provided soon enough after the ServerHello
message. OpenSSL itself does not enforce a timeout, but
Apache has a default timeout set to 300 seconds, conﬁgurable
by the TimeOut directive. However, this timeout counter will
be reset whenever new data is added to the read or write buffer.
By using TLS fragmentation and sending empty TLS message
fragments the TLS connection can be kept open for an unlim-
ited amount of time before sending a CertificateVerify
message.

After the DoS attack tool Slowloris [17] was released (the
tool tries to open many connections to the target server and
keep them open as long as possible),
the Apache HTTP
server starting from version 2.2.15 includes the module
mod_reqtimeout [18] that
imposes restrictions on the
minimum transfer speed and the time a client is allowed to stay
connected. Debian GNU/Linux and most software distribu-
tions based on Debian ship Apache with mod_reqtimeout
enabled by default. The default conﬁguration will force the
connection to be terminated if the client’s HTTP request header
is not received within 40 seconds. However, the total time for
receiving an HTTP request body is not enforced as long as
the ﬁrst byte of the request body is received in the ﬁrst 10
seconds and then the minimum data transfer rate of 500 bytes
per second is maintained [19]. Since the TLS renegotiation
process is part of the request body receiving process [18], the
renegotiation handshake can be kept open for an unlimited
amount of time as long as the data rate of 500 bytes per
second is maintained. In practice, one TLS record containing
an AES encrypted empty handshake message that is padded
to the maximum allowed length will have a size of 277 bytes;
therefore two such TLS records must be sent in a second to
maintain the required data rate of 500 bytes per second.

As a result, many servers requiring TLS CCA might not
put a time constraint on an attacker for obtaining a signature
once the data to be signed is known. This can be exploited, for
example, in the Estonian ID card case if the victim provides a
padding oracle to the attacker. Since forging a signature using
a padding oracle attack requires thousands of oracle calls to the
ID card, the attacker can obtain forged signature only several
hours after the data to be signed is known [20]. We see that
this limitation might not be a problem, and therefore a padding
oracle attack can be practically exploited to perform CCA on
behalf of the victim if the attacker has access to such an oracle.
Even if a server-side application could obtain the time the
client performed CCA, we face another problem. Server-side
scripting engines do not provide function calls that could
be used to communicate to the underlying mod_ssl that a
particular TLS session should be cleared in order to request
client certiﬁcate re-authentication, and as will be discussed
further, browsers also do not provide API, which could be
used to force a TLS session deletion from the client side.

6

G. Certiﬁcate Revocation Checking

At mod_ssl level client certiﬁcate revocation checking
can be performed using a certiﬁcate revocation list (CRL).
The SSLCARevocationFile directive speciﬁes a location
where CRLs used for certiﬁcate chain revocation checking
are located. Only direct CRLs are supported and only these
certiﬁcates will be checked for which CRLs are provided.
When CRL ﬁles are updated, the Apache process must be
gracefully restarted (using signal USR1) in order to reload
CRLs. The TLS CCA handshake will fail if an outdated CRL is
speciﬁed i.e., if nextUpdate is in the past. However, there
is no check of whether thisUpdate is not in the future,
and therefore outdated CRLs used by servers with a backward
system time will not be detected.

In mod_ssl version 2.4, the revocation checks can also be
performed using the Online Certiﬁcate Status Protocol (OCSP).

H. CCA Audit Trail

HTML form-based password authentication provides a ﬂex-
ible way to record authentication success and failures at
application level. However, in the case of mod_ssl, the CCA
failure resulting from any reason will end with a TLS hand-
shake failure without reaching the application level. Therefore
CCA auditing must be done at the mod_ssl level.

In order to fully beneﬁt from the auditing process,

Unfortunately, the logging provided by mod_ssl is not
sufﬁcient. When using the LogLevel value error, only
general CCA success and failure messages are logged. When
LogLevel is set to value debug, which provides the maxi-
mum verbosity level, the subject DN of the certiﬁcate and the
packets received by OpenSSL are also dumped into the log
ﬁle; however, if the CCA is performed on renegotiation, the
packets of the handshake dumped are in an encrypted form.
the
full TLS CCA handshake should be logged in a decrypted
form. This would allow investigation of the precise reasons
for authentication failure, and in a case of successful CCA,
the handshake messages could be used by a server as proof
that the server was interacting with a client who possessed the
private key corresponding to the client’s certiﬁcate. The proof
would even give an indication about the time period, since
the randomness in the ClientHello and ServerHello
messages contains the timestamp of the client and server and
the server’s Certificate message contains the validity
period of the certiﬁcate.

I. CCA Support in Browsers

When a server requests the CCA, the browser has to ask
the user whether to perform CCA and which certiﬁcate should
be used for that. The client certiﬁcate selection windows as
implemented by browsers can be seen in Fig. 2. The Chrome
browser has a different selection window in Linux and Win-
dows, since in Linux it uses the NSS library to implement TLS
while on Windows it uses SChannel and Windows certiﬁcate
management facilities.

As can be seen, the client certiﬁcate selection windows
provide different levels of detail. Chrome uses the address
from the address bar to indicate the CCA requesting party,
while Firefox shows information from the server’s certiﬁcate.
Unfortunately, the IE in its client certiﬁcate selection window
does not even try to inform which party is requesting CCA.

(a) Firefox under Linux

(b) Chrome under Linux

(c) IE under Windows 7

(d) Chrome under Windows 7

Fig. 2: Client certiﬁcate selection windows

The list of certiﬁcates in the selection window is ﬁltered
according to the list of CA DNs provided in the server’s
CertificateRequest message. If a server sends an empty
list of DNs, the browser offers to select any client certiﬁcate
that
the user has. Certiﬁcates whose purpose speciﬁed in
the certiﬁcate extensions is not consistent with CCA are not
listed in the certiﬁcate selection window. In addition, IE and
Chrome will not list client certiﬁcates that are not yet valid or
have expired. If the user has no suitable client certiﬁcates for
authentication the certiﬁcate selection window is not shown
and an empty client Certificate handshake message is
sent.

The Firefox certiﬁcate selection window has an additional
option “Remember this decision” which is enabled by de-
fault. In practice, browsing with this option disabled would
signiﬁcantly degrade the user experience, since the user would
be asked to select the certiﬁcate again whenever a new TLS
session was established with the server. IE and Chrome do
not even support disabling this option and automatically cache
certiﬁcate choice for a particular server until
the browser
has been restarted or the user has manually cleared the TLS
cache [21] (in Firefox: “Tools” – “Clear Recent History” –
“Active Logins”, in IE: “Tools” – “Internet Options” – “Con-
tent” – “Clear SSL state”, in Chrome not implemented [22]).
However, the caching of the client certiﬁcate choice creates
another usability and security issue. If the user has selected
the wrong certiﬁcate and wants to authenticate with a different
one or wants to prevent the browser from performing further
CCA with the server (e.g., after logout), the user has to restart
the browser or manually clear the TLS cache, disturbing all
connections in the current browsing session.

7

Firefox

exposes

a

JavaScript

non-standard

function
window.crypto.logout() [23] which clears the TLS
session cache and certiﬁcate choice for the server in whose
browser security domain the function is called. This function
can be used by server-side applications to provide true logout
functionality and the possibility for the user to re-authenticate
with a different client certiﬁcate.

Unfortunately, similar

functionality is not provided by
Chrome [24]. However, Chrome clears the client certiﬁcate
choice if the TLS CCA handshake is not successful, thereby
preventing deadlock if the user has chosen the wrong client
certiﬁcate and it is being refused by the server at the TLS
handshake level (Firefox and IE do not prevent deadlock
in this situation). To implement CCA logout functionality
in Chrome, the behavior described above can be used as a
workaround. For example, by conﬁguring on the server side
and then requesting in the browser a speciﬁc server resource
that will fail the TLS CCA handshake if requested:
<Directory /var/www/handshake_fail/>
SSLVerifyClient require
SSLVerifyDepth 0
</Directory>

IE,

In the case of

the IE speciﬁc JavaScript

func-
tion document.execCommand() with the parameter
"ClearAuthenticationCache" can be used. However,
it should not be used by responsible web sites, since when
called, not only will the TLS session and client certiﬁcate
choice be deleted, but also all session information including
HTTP cookies and authentication, and not only for the site
that called it but all sites in the current browser session [25].
In our opinion the behavior provided by this function creates
a security issue itself.

Fig. 3: Chrome TLS CCA UI improvements proposed [26]

The lack of a standard JavaScript API that could be called by
web sites to clear the client certiﬁcate choice and TLS session
cache, prevents web sites using TLS CCA from exercising
login and logout functionality as currently available when
HTML form-based password authentication is used.

An alternative solution is to implement the logout functional-
ity in a browser’s user interface (UI). The suggested UI would
show in the browser address bar the client certiﬁcate that has
been used for TLS CCA to the server and would allow the
client certiﬁcate choice to be changed (see Fig. 3) [26].

Unfortunately, we ﬁnd little value in these UI improvements,
since this functionality will not be available in cases where
TLS CCA is used only in the authentication phase or when
TLS CCA is performed by a separate server, since in these
cases, an authenticated web session will be bound to the HTTP
cookie and not to the client certiﬁcate (see Section IV-B4).

Another signiﬁcant usability issue in the multiple client
certiﬁcate use scenario is that the client certiﬁcate selection
windows of the browsers provide client certiﬁcates sorted by
ﬁxed rules and not by their use frequency.

J. Client Certiﬁcate Enrollment

In Estonia, client certiﬁcates are distributed to residents by
including them in their ID card, which is a mandatory identity
document in the form of a smart card. The ID card contains a
public-key certiﬁcate signed by the state-supported CA and the
corresponding RSA key pair that can be used for TLS CCA.
However, it is a wrong assumption that TLS CCA requires
the use of PKI and CAs. A client certiﬁcate that is issued by
a trusted CA is required only in cases where the client has no
account on a server and where the server would be required to
know the user’s government issued identity for opening such
an account. Most service providers only care about a user’s
identity established after the registration process. Therefore,
in the process of account registration or after that, any service
provider can register a client’s certiﬁcate, and this can be used
to authenticate the user thereafter. The server can register the
client certiﬁcate by performing TLS CCA with a certiﬁcate
chosen by the user, or if the user does not have or does not
want to use an existing certiﬁcate, the server can request the
user’s browser to perform key pair generation and certiﬁcate
enrollment using the HTML5 <keygen> element supported
by both Chrome and Firefox. If the user has a cryptographic
token (e.g., a smart card) and a proper PKCS#11 module
loaded into the browser, the RSA key pair can be generated
and the certiﬁcate loaded right into the token. In IE, similar
functionality exists using CertEnroll ActiveX control [27].
Using a client certiﬁcate just as a transport for a public key that

is bound to the user’s account does not beneﬁt from centralized
certiﬁcate revocation and replacement, but password-based
authentication does not have these beneﬁts either.

Compared to password authentication, CCA has a client
certiﬁcate portability problem. Client certiﬁcates loaded into
cryptographic tokens are portable; however, modern mobile
devices that are increasingly used for browsing do not have
interfaces for cryptographic tokens, or if they have, the use of
external hardware with mobile devices is rather inconvenient.
Certiﬁcates and their corresponding private keys which are
stored in a browser can be manually exported and imported
in other devices. Unfortunately, Firefox Sync3 – a secure
browser synchronization feature in Firefox, does not pro-
vide synchronization of client certiﬁcates. As an alternative,
password authentication could be used to authenticate to a
service provider in order to obtain a new device-speciﬁc client
certiﬁcate.

K. Security Against Server Impersonation

Recent incidents involving the compromise of trusted CAs
DigiNotar [28] and Comodo [29] and reported misbehavior
of the CAs Trustwave [30] and TURKTRUST [31] show that
MITM attacks using fraudulent certiﬁcates issued by trusted
CAs are very realistic. Even if an attacker is not powerful
enough to obtain a certiﬁcate issued by a trusted CA, he can
perform a MITM attack using a self-generated certiﬁcate and
if the victim clicks through browser security warnings, can
achieve successful impersonation of the legitimate server.

As was stated before,

if the TLS CCA is used, even
a very powerful attacker that can successfully imperson-
ate a legitimate server, cannot reuse the proof given in a
CertificateVerify message to impersonate a victim to
the legitimate server. Unfortunately, such an attacker can still
compromise the client’s account on the legitimate server by
exploiting the design features of modern web browsers, in
particular, the same-origin policy [32] which will not iso-
late client-side scripts that are served over an impersonated
TLS connection to the attacker and client authenticated TLS
connection to the legitimate server. As a result, such an
attacker will be able to execute a cross-site scripting attack
in the context of the legitimate server which is enough to
retrieve information available to the victim’s browser and to
execute actions chosen by the attacker [33]. While the cross-
site scripting exploitation brings additional complexity to the
MITM attack, an attack like this cannot be excluded in highly
targeted attacks.

Note that

this complicated cross-site scripting attack is
required only if the legitimate server requires TLS CCA also
after the authentication phase. If the legitimate server binds the
authenticated session only to an HTTP cookie, the attacker can
impersonate the client by obtaining the HTTP cookie, which
will be disclosed by the victim’s browser’s same-origin policy
sending it over the impersonated TLS connection.

In order to prevent these attacks, a browser’s same-origin
policy should be changed to isolate content that is served
over connections that are authenticated with different server
certiﬁcates. We encourage browser developers to implement
support for a strong locked same-origin-policy, as described
in [33] and enable web sites to opt-in, just as it is possible
to opt-in for the HTTP Strict Transport Security policy [34].

3https://www.mozilla.org/mobile/sync/

8

TABLE I: TLS CCA as deployed by the service providers
running Apache mod_ssl.

Spare

Request

Depth

Timeout

Privacy

Resume

Bind

Validity

0
5
2
4
0
0

4
0
0
0
0

0
4
0
0
5
0
0
105
0
31
2
0
0
2
1
0
31
7
73
9

0
0

0
2
0

0
2
0
0
1
2
3
0
0
0
2
0
1
0
9
1

2
0
0
0
0
0
0
0
0
0
2
0
0

optional
optional
optional
require
require
optional

optional
require
optional
require
require

optional
require
require
optional
require
optional
require
optional
require
require
optional
optional
optional
require
require
require
require
require
require
optional

require
require

require
require
require

optional
require
require
require
optional
require
require
require
require
optional
require
require
require
require
optional
optional

require
optional
require
require
require
optional
require
require
optional
optional
require
require
require

3
2
2
3
5
3

3
2
2
2
2

6
2
3
2
2
3
2
6
10
3
2
2
3
2
2
2
2
2
2
3

3
2

2
3
3

2
3
9
3
2
2
3
2
2
2
3
2
3
2
3
3

3
2
2
2
3
3
3
3
2
3
2
2
2

–
–
–
–
–

40 sec

–
–
–*
–

9 hour

–
–
–
–
–*
–
–*
–
–*
–
–
–
–*
–
–
–*
–
–
–
–

–
–

⇡30 min
⇡15 min

–

⇡15 min

9 hour

⇡30 min

–
–
–
–

–*

–*
–*
–
–
–*
–
–
–

–
–

–
–

–
–
–*
–

9 hour

20 sec

9 hour
40 sec
9 hour

–
–
–
+
–
–

–
+
+
+
–

+
+
+
+
+
–
+
+
+
+
+
+
+
+
+
+
+
+
+
+

+
+

+
+
+

+
+
+
–
+
–
+
–
+
+
+
+
+
+
+
–

+
–
–
–
–
+
+
–
–
+
+
+
+

+
+
+
–
+
+

+
–
–
–
+

–
–
–
–
–
+
–
–
–
–
–
–
–
–
–
–
–
–
+
–

–
–

–
–
–

–
–
–
+
–
+
–
–
–
–
–
–
–
–
–
+

–
+
+
+
+
–
–
+
+
–
–
–
–

+
+
+
–*
?
?

OCSP
OCSP
OCSP
OCSP

?
?

–
?
–

?

OCSP 2007

+
?
–
–
–

–
–
–
–
–
–
–
–
?
?
–
–
–
–
–
–
–
–
–
–

–
–

–
?
?

–
–
–
+
–
+
–
?
?
–
–
–
–
–
–
–

–
–
–
+
–
?
–
–
–
–
?
–
–

OCSP 2007

OCSP

CRL
OCSP
OCSP
OCSP
OCSP
OCSP

CRL

CRL
CRL

CRL
OCSP
CRL
OCSP

CRL

–

CRL

CRL
OCSP

OCSP
OCSP
CRL

CRL

OCSP
CRL

CRL
CRL
OCSP

CRL

CRL
OCSP
CRL

–

?
?

–

–

?

–

–

–
–

–

–

?

–
?
–
–

CRL 2007

CRL 2007

OCSP
OCSP

Service provider
Banking:

citadele.ee
krediidipank.ee
seb.ee
tbb.ee
unicreditbank.ee
versobank.com

Education:
e-ope.ee
eek.ee
ekool.eu
emu.ee
tlu.ee

Government:

ariregister.rik.ee
digidoc.sk.ee
e-register.ee
e-toimik.ee
eesti.ee
emta.ee
epa.ee
ettevotjaportaal.rik.ee
kala.envir.ee
kassa.ﬁn.ee
kinnistuportaal.rik.ee
kinnistusraamat.rik.ee
paberivaba.ark.ee
pensionikeskus.ee
politsei.ee
pria.ee
riigihanked.riik.ee
sk.ee
stat.ee
tootukassa.ee

Health:
arst.ee
medicum.ee

Insurance:
ergo.ee
iizi.ee
mandatumlife.ee

Utility:

arhivaar.ee
arvekeskus.ee
e-seif.ee
eestiloto.ee
elisa.ee
energia.ee
eparkimine.ee
g4s.ee
gaas.ee
korteriyhistu.net
parkimine.ee
pilet.ee
stv.ee
tallinn.ee
tele2.ee
zone.ee

apollo.ee
auto24.ee
credit24.ee
era.ee
hinnavaatlus.ee
justask.ee
laen.ee
openid.ee
osta.ee
ox.ee
partnerkaart.ee
rahvakogu.ee
skaart.ee

Other:

The availability of a strong locked same-origin-policy would
also bring a practical security value to Extended Validation
(EV) server certiﬁcates, since an attacker who has fraudulently
obtained a low-assurance Domain Validation (DV) certiﬁcate
would not be able to hijack an EV authenticated connection
to the legitimate server [35].

Note that an opt-in for a strong locked same-origin-policy
will not help against attackers who are capable of imperson-
ating TLS servers, if the web site imports or exports content
from/to other origins [36].

IV. ESTONIAN MEASUREMENT STUDY

A. Background

Every Estonian citizen who has reached 15 years of age must
obtain a state-issued ID card in the form of a smart card that
contains two public-key certiﬁcates and corresponding RSA
key pairs. One can be used for TLS CCA and another for
qualiﬁed digital signatures. This has led to the high popularity
of TLS CCA in Estonia, where every major service provider
has implemented a TLS CCA option for authentication when
using their e-services. We analyzed 87 public Estonian web
sites (all that we were aware of) which provide a TLS CCA
option.

The goal of the measurement study was to ﬁnd out how TLS
CCA is deployed in practice and how the issues described in
this paper are handled in real world TLS CCA deployments.
All service providers were tested using a black-box method;
therefore, the results we obtained might have other explana-
tions than the ones provided here.

The tests were performed in the time period between March
5, 2013 and April 19, 2013. The service providers and testing
results related to mod_ssl deployments are provided in
Table I. While this paper’s focus is on Apache mod_ssl TLS
CCA implementation, we also performed common tests on
other CCA implementations as shown in Table II. Our guesses
about the server software used are provided in the column
“Server”.
B. Evaluation and Results

The testing methodology and results are discussed below.
1) Spare CAs: The certiﬁcates that are included in an
Estonian ID card are issued by SK intermediate CA ESTEID-
SK 2007. Since the SK root CA certiﬁcate will expire soon, the
certiﬁcates issued after July 2011 are issued by intermediate
CA ESTEID-SK 2011 that itself is issued by the new root CA
of SK. Therefore, the server-side trust store should have four
certiﬁcates conﬁgured – two SK root CA certiﬁcates and two
corresponding intermediate CA certiﬁcates.

We have analyzed a list of CA DNs provided in the server’s
CertificateRequest message to detect spare (possibly
superﬂuous) and missing certiﬁcates in the server’s trust store.
The list of spare certiﬁcates has been pruned by removing
certiﬁcates that have been issued by these two SK root CAs,
since the presence of intermediate certiﬁcates in the trust store
does not affect trust settings, as described in Section III-B.

The positive number in the column “Spare” most likely
indicates a server misconﬁguration and may allow an attacker
to impersonate a user if the attacker is able to obtain the client
certiﬁcate that contains the user’s personal data and is signed
by any of the spare CAs or their subordinate CAs.

Some of

these misconﬁgurations can be explained by
a bad undocumented mod_ssl practice,
since certiﬁ-
cates in the SSLCACertificateFile are also used

TABLE II: TLS CCA as deployed by the service providers
running other TLS server software.

Service provider
Banking:

danskebank.ee
lhv.ee
nordea.ee
swedbank.ee

Education:

ehis.ee
etis.ee
ttu.ee
ut.ee

Government:

eas.ee
Health:

digilugu.ee
digiregistratuur.ee

Insurance:

compensalife.eu
kindlustus.ee

Utility:

arved.ee
dormitorium.ee
elektrum.ee
elering.ee
elion.ee
emt.ee
imatraelekter.ee
kyla.ee
tallinnavesi.ee

Server

BigIP
IIS/6.0
?
BigIP

Oracle-AS
IIS/7.5
Oracle-AS
Oracle-AS

IIS/7.5

BigIP
IIS/6.0

IIS/6.0
IIS/7.0

?
IIS/7.x
Nginx
Jetty?
Tomcat?
BigIP
IIS/6.0
IIS/6.0
IIS/7.5

Spare

Request

Timeout

Privacy

Resume

Bind

Validity

0
24
6
0

10
6
14
0

13

0
27

21
5

1
9
0
1
0
0
25
20
7

optional any
optional any
require
optional any*

optional
optional any*
optional
optional

optional any*

optional any
optional any

optional any*
optional any*

optional
optional any*
optional any
require
optional any
optional any
optional any*
optional any
optional any*

1 min
6 min
1 min
1 hour

5 min
2 min
5 min
5 min

2 min

10 sec
5 min

5 min
2 min

2 min
1 min

–

–

1 min
10 sec
6 min
6 min
2 min

–
+
–
–

–
+
–
–

+

–
+

+
+

+
+
–
–
–
–
+
+
+

+
+
+
+

+
+
+
+

+

–
+

+
–

+
–
–
+
+
–
+
+
–

+
+
–*
+

–
–
–
–

–

–
–

?
–

–
–
–
+
–
–
–
–
–

OCSP
OCSP
OCSP
OCSP

CRL

?

?

CRL 2007

OCSP

OCSP
OCSP

?

CRL

OCSP
CRL
OCSP
OCSP

–

OCSP
CRL
CRL
CRL

9

least

to build the server’s certiﬁcate chain provided in the
server’s Certificate message. We have found several
mod_ssl tutorials on the Internet
in which readers are
the server’s cer-
instructed to place CA certiﬁcates of
tiﬁcate into the SSLCACertificateFile rather
than
SSLCertificateChainFile. Our observations conﬁrm
this narrative, since most of the spare CAs are ones that have
also issued a server’s certiﬁcate.

2) Missing CAs: The absence of SK root CA DNs or an
empty list of DNs in a server’s CertificateRequest
message will not create a problem. However, the presence
of root CA DNs without intermediate DNs will make TLS
CCA fail if the certiﬁcate store in the user’s browser does
not have these intermediate certiﬁcates installed. The service
providers e-ope.ee, justask.ee, ox.ee and all service
providers using Microsoft Internet Information Services (IIS)
were found to be missing one or both intermediate CA DNs
in their CertificateRequest message.

The service providers g4s.ee, justask.ee, ox.ee and
ut.ee were found to be missing the new root CA certiﬁcate
of SK in their trust store, thereby denying the possibility of
using TLS CCA with client certiﬁcates issued after July 2011.
3) Veriﬁcation Depth: The veriﬁcation depth value set by
mod_ssl SSLVerifyDepth directive (column “Depth”
in Table I) was enumerated using the method described
in Section III-C. As was explained in Section III-B,
the
mod_ssl does not allow limiting intermediate CA certiﬁcates
the valid client certiﬁcate chain may have. However,
that
at
the length of the chain can be limited using the
SSLVerifyDepth conﬁguration directive. The correct value
for the Estonian ID card certiﬁcate chain is 2, since in addition
to the end entity certiﬁcate the chain contains intermediate and
root CA certiﬁcates. However, as can be seen in Table I, almost
half of the service providers have extended their veriﬁcation
depth constraint. Although it does not create an immediate
threat, the depth constraint of 2 can prevent attacks in certain
cases, for example, if the CA mistakenly enables CA trust
bits in the end entity certiﬁcate and does not have path
length constraints in CA certiﬁcates as was the case in the
TURKTRUST incident [31].

4) CCA Bound Sessions: The column “Bind” tells whether
the service provider requires the presence of a CCA TLS con-
nection only at the login phase or also after the user has been
authenticated and is performing actions in the authenticated
environment.

We see that only a few service providers (mostly banks)
require a CCA connection also after the authenticated HTTP
session has been established. The lack of CCA bound sessions
can be explained by the additional complexity of web design
that is entailed if the support for password authentication must
also be provided. Instead of setting up two URL locations for
CCA and non-CCA authenticated users, the service providers
set a CCA URL to which the user is redirected only at the login
phase, but after an authenticated HTTP session is established
(by use of an HTTP cookie) the browser is redirected back
to the common server path where CCA is not required. This
type of federated authentication approach has more security
risks, since the authenticated session is protected only by an
HTTP cookie which might be stolen by an attacker capable of
impersonating the server, or leaked in another way (e.g., via a
cross-site scripting attack). In contrast, TLS key material from
a client certiﬁcate authenticated TLS session may be obtained

10

test

by the attacker only if the attacker is able to compromise one
of the endpoints.

It is interesting to note that while the service providers
tbb.ee and nordea.ee also required a TLS CCA con-
nection after the login phase, the application did not verify
whether the client certiﬁcate presented was of the same person
that was presented at the login phase.

In some service provider web sites we did not have an
account;
if the authenticated
session was bound to the CCA or not. For these service
providers the rows are marked with a question mark.

therefore, we could not

5) Privacy of Client’s Certiﬁcate: The column “Privacy”
shows whether the service provider protects the privacy of
a client certiﬁcate by requesting CCA on renegotiation or
whether the CCA is performed on initial TLS negotiation and
the client certiﬁcate is sent to the server over an unencrypted
channel.

We see that one third of all service providers do not protect
the privacy of client certiﬁcates. This can be explained by the
mod_ssl documentation that does not warn about the conse-
quences of conﬁguring the SSLVerifyClient directive in
a server-wide context.

Another explanation could be that renegotiation has been
disabled on the server side as a temporary ﬁx when the TLS
renegotiation vulnerability (CVE-2009-3555) was discovered,
and was left disabled even after the TLS renegotiation in-
dication extension [37], which ﬁxes the vulnerability, was
standardized and implemented in browsers.

6) CCA Session Resumption: The column “Resume” indi-
cates whether the server supports TLS session resumption
of client certiﬁcate authenticated sessions. We see that
in
mod_ssl deployments the CCA sessions that have been
established on initial negotiation do support resumption, while
all deployments (except stat.ee) that require CCA on
renegotiation do not support resumption for these sessions.
This can be the result of the mod_ssl bug described in
Section III-D.

While most of the service providers fail to resume CCA
the support for CCA session resumption is only
sessions,
important for those service providers who serve the content
over a TLS CCA connection after the login phase.

deployments

7) CCA request:

the
For
mod_ssl
column “Request” shows
the value conﬁgured by the
SSLVerifyClient directive. As described in Section III-A
the value require will result in a failed TLS handshake if,
for whatever reason, the veriﬁcation of the client certiﬁcate
fails. Some service providers use the value optional that
will allow the service provider to provide a personalized
HTTP response if the client has no client certiﬁcate. In all
other cases the handshake will fail with an error message
provided by the browser.

With non-mod_ssl deployments (Table II) the situation
is different. Most of them at the TLS handshake level will
tolerate the absence of a client certiﬁcate and the presence of
any client certiﬁcate as long as the client can prove possession
of the corresponding private key (marked as optional_any;
optional and require mimics mod_ssl behavior). If the
client provides an invalid certiﬁcate, the HTTP error message
is returned by the web server or by the application.

We

have

observed

compensalife.eu,
etis.ee,

imatraelekter.ee,

that

service
dormitorium.ee,

the

providers
eas.ee,
kindlustus.ee

and tallinnavesi.ee (all using IIS) allow successful
authentication with a qualiﬁed digital signature certiﬁcate
whose key usage is
inconsistent with TLS CCA (the
certiﬁcate key usage extension has only nonRepudiation
bit asserted). Apparently this certiﬁcate veriﬁcation step is
missed by the IIS server and therefore must be performed by
the application. We have informed Microsoft about the ﬂaw.
The service provider swedbank.ee was found to miss
not only certiﬁcate key usage veriﬁcation, but also signature
veriﬁcation on a client certiﬁcate received. The ﬂaw allowed
successful login to any user account if the user ID of the person
was known. The service provider has been informed about this
ﬂaw and it has already been ﬁxed.

8) CCA Handshake Timeout Enforcement: The column
“Timeout” shows for how long the handshake can be kept
open after the server has sent the ServerHello message,
but before the client has sent the CertificateVerify
message. In the case of service providers marked “–”, we were
able to keep the connection open for more than 12 hours. The
service providers marked with “*” had mod_reqtimeout
enabled, but since the CCA was requested on renegotiation,
we could still keep the connection open using the method
described in Section III-F.

To measure timeout for non-mod_ssl deployments which
did not support empty TLS record fragments (Oracle-AS,
danskebank.ee, nordea.ee) and TLS record fragmen-
tation (IIS 6.0), we appended the client’s Certificate
message with dummy certiﬁcates to enlarge the handshake and
sent TLS records split into 1 byte TCP packets, one per second.
9) Client Certiﬁcate Revocation Checking: The validity of
authentication certiﬁcates issued by SK can be checked using
CRLs, which are issued every 12 hours or by using the SK
paid validity service provided using OCSP.

To test whether the service provider performs revocation
checks for client certiﬁcates issued under both SK intermediate
CAs, we used two client certiﬁcates issued to one of the
authors of this study – ID card certiﬁcate issued by SK
intermediate CA ESTEID 2007 and Digi-ID4 certiﬁcate issued
by SK intermediate CA ESTEID 2011.

If access was denied immediately after the certiﬁcate was
revoked, we concluded that OCSP was being used. If the
access was denied only after the serial number of the revoked
certiﬁcate appeared on CRL, we concluded that CRL was
being used. If we could successfully authenticate even after
nextUpdate speciﬁed in the previous CRL was reached,
we concluded that no revocation checks had been performed
(marked as “–”).

For some service provider web sites we did not have an
account; therefore, we could not test whether the revocation
checks were performed at the application level after login. In
these cases the rows are marked with a question mark.

We observed a strange behavior in the case of the service
providers pensionikeskus.ee and emu.ee. When our
ID card certiﬁcate was revoked,
the access using Digi-ID
certiﬁcate was also denied by the service provider. We suspect
that these service providers use LDAP instead of OCSP for
certiﬁcate revocation checking. According to the ESTEID
Certiﬁcation Policy [38], the SK LDAP directory contains

4Estonian residents may also obtain a Digi-ID smart card. The only
difference to an ID card is that it cannot be used for physical identiﬁcation and
the organizationName attribute of subject DN in Digi-ID authentication
certiﬁcate contains “ESTEID (Digi-ID)” instead of “ESTEID”.

11

only valid unexpired certiﬁcates; therefore LDAP can be used
to check certiﬁcate status. However, these service providers
apparently use a ﬁxed organizationName ﬁeld in the
LDAP search query to check the existence of any ID card
authentication certiﬁcate in LDAP issued to the person, without
comparing the certiﬁcate in LDAP with the client certiﬁcate
received. In fact, it is likely that more service providers marked
“OCSP” use LDAP for revocation checking.

The use of LDAP for revocation checking in addition to CRL
and OCSP has a security advantage, since not only can the
serial number of the certiﬁcate be veriﬁed, but the whole cer-
tiﬁcate. This allows the detection of fraudulent certiﬁcates that
have been issued with the serial numbers of legitimate ones, as
seen in the DigiNotar compromise [28]. However, since the SK
LDAP trafﬁc is not cryptographically protected [39], it cannot
be trusted since an attacker might be able to perform a MITM
attack between the service provider and SK LDAP.

in the case of

When testing handshake timeout enforcement, we observed
that
the service providers apollo.ee,
energia.ee, laen.ee, osta.ee and tlu.ee the TCP
connection was closed shortly before the time speciﬁed in
nextUpdate of CRLs was reached. Apparently these service
providers use a non-graceful Apache restart after updating
CRLs.

10) Other Observations: We did not observe any service
provider using window.crypto.logout() to implement
CCA logout functionality.

The service provider seb.ee was the only one that, after
we logged out and tried to login, was able to detect that the
TLS CCA session established on the previous login was being
used. However, the service provider was still not able to clear
the TLS session on the server side and asked the user to restart
his browser in order to re-authenticate.

ehis.ee,

It was observed that TLS implementations of

the
service
g4s.ee,
hinnavaatlus.ee, iizi.ee, nordea.ee, ox.ee,
parkimine.ee, tbb.ee and ttu.ee did not support
the TLS renegotiation indication extension [37] that ﬁxes the
TLS renegotiation vulnerability (CVE-2009-3555).

elion.ee,

providers

V. OUR RECOMMENDATIONS

A. For Service Providers

are

no

in

For service providers deploying TLS CCA with the current

spare CA certiﬁcates

SSLCACertificateFile.

options available, we suggest they ensure that:
• There
the
• The CA certiﬁcates that are direct issuers of client cer-
tiﬁcates are speciﬁed in the SSLCADNRequestFile.
• Additional checks are performed at the application level
to verify that
the client certiﬁcate is issued by the
intermediate CA intended (at least the issuer name of
client certiﬁcate should be veriﬁed).
• The SSLVerifyDepth constraint is conﬁgured to the
• The SSLVerifyClient directive is speciﬁed in a
directory context
in order to perform TLS CCA on
renegotiation, thereby preserving the privacy of the client
certiﬁcate.
• An Apache module such as mod_reqtimeout is cor-
• Client certiﬁcate revocation checks are performed and if
LDAP is used, the full content of the client certiﬁcate is
compared to the one found in the LDAP directory.

rectly used to enforce the CCA handshake timeout.

minimal value required.

• To implement the CCA logout functionality, the Firefox
speciﬁc window.crypto.logout() function and
the Chrome workaround described in Section III-I are
used.

• Until decent TLS CCA audit functionality is available in
mod_ssl, the cipher suites providing perfect forward
secrecy are disabled (unless forward secrecy is more
important than availability of an audit trail) and a packet
capture of TLS trafﬁc is saved.

• In the case of highly sensitive services the authenticated
session is bound to TLS CCA (although this has a
negative performance impact due to the mod_ssl bug
described in Section III-D).

Meanwhile, we encourage service providers all over the world
to implement a PKI-less TLS CCA option as described in
Section III-J.

B. For mod_ssl Developers

As a relatively simple improvement, the mod_ssl bugs [7],
[8] and [13] should be ﬁxed, and other undocumented issues
pointed out through this paper should be reﬂected in the ofﬁcial
mod_ssl documentation [5].

Next, we suggest a mod_ssl redesign that would provide
a ﬂexible yet simple and secure conﬁguration for most TLS
CCA use cases. We suggest three conﬁguration values for the
SSLVerifyClient conﬁguration directive:
• none - CCA is not required (current none behavior)
• require_success - require successful CCA or TLS
• require_any - optionally request any client certiﬁ-
The environment variable SSL_CLIENT_VERIFY_RESULT
should be set based on the veriﬁcation result – NONE,
SUCCESS or FAILED:reason (the veriﬁcation must fail on
the ﬁrst error to reduce DoS attack vectors).

handshake fails (current require behavior)

cate.

In addition, the certiﬁcate chain building process should
succeed when any certiﬁcate loaded in the trust store is
reached. This will allow enforcement of veriﬁcation using
a speciﬁc intermediate CA certiﬁcate and authorization of
speciﬁc client certiﬁcates by storing them directly in the trust
store.

The SSLVerifyClient value require_success is
useful for closed deployments where no HTTP requests should
be processed for unauthenticated clients. On the other hand, the
value require_any gives the opportunity for an application
to provide a personalized error message in the case of CCA
failure, and at the same time allows client certiﬁcates to be
used just as a transport for the public key whose authenticity
is established by an out-of-band mechanism (PKI-less CCA).
In order to enable TLS CCA re-authentication, we recom-
mend that a special response header (e.g., X-TLS-Reset) is
introduced, which, if set by a server-side application, would
force mod_ssl to delete an associated TLS session after
returning the response.

Finally, the application level should have access to both
the timestamp that speciﬁes the freshness of the proof given
in the TLS CCA process, and to the certiﬁcate chain used
in the veriﬁcation process. The logging of decrypted TLS
handshake messages as described in Section III-H should also
be implemented.

C. For Browser Vendors

The browser vendors analyzed in this study can relatively

easily improve the security and usability of TLS CCA by:
informs about
• Showing a warning message that

the
privacy leak if the client certiﬁcate is requested on initial
negotiation.

CCA handshake fails (applies to Firefox and IE).

• Clearing the cached client certiﬁcate choice if the TLS
• Using the Expect: 100-continue mechanism
• Making the client certiﬁcate used for the CCA to the
server on the previous occasion the default certiﬁcate
choice in the client certiﬁcate selection window.

when sending large HTTP POST requests over TLS.

A bigger challenge, however, is to standardize the JavaScript

API. This could be used separately to:
• delete the TLS session cache from the client side, thereby
providing support for client certiﬁcate re-authentication
in the background (as an alternative to the server-side
X-TLS-Reset mechanism proposed);

thereby providing TLS CCA logout functionality.

• forget client certiﬁcate choice cached by the browser,
In addition, we encourage extension of the HTTP Strict
Transport Security policy [34] mechanism with opt-in for
strong locked same-origin-policy.

VI. RELATED WORK

Ristic, in his SSL Labs research effort [40] sets out TLS
deployment best practices, gives a TLS server rating guide,
and performs an Internet TLS survey that analyzes TLS server
deployments on the Internet. However, his work does not cover
aspects of TLS CCA.

Hess et al. in [41] describe the TLS protocol-related limita-
tions of CCA. While the issues listed there can be a limitation
in speciﬁc use scenarios, they are not a stumbling block for
everyday TLS CCA use. Some limitations enumerated in that
study, such as client certiﬁcate disclosure, can be easily solved
by renegotiation as described in this paper.

Dietz et al. in their work [42] give a list of reasons why
TLS CCA does not work in today’s web. In our opinion, all
the issues listed there (with the exception of the portability
issue) could be solved if the recommendations provided in
this paper were implemented.

Fahl et al. in [43] and Georgiev et al. in [44] perform a
large-scale study researching how TLS server certiﬁcates are
veriﬁed in non-browser software. By contrast, we focus on how
certiﬁcate veriﬁcation is performed in server-side software to
authenticate a client.

VII. CONCLUSION

In this paper we have described several issues related to TLS
CCA use in practice and have provided a list of solutions that
can be implemented at an application level without requiring
changes to the TLS protocol. While this study has shown that
there is a room for improving TLS CCA implementations,
the Estonian example shows that the problem of establishing
a secure user identity on the Internet has a solution, and
more importantly the solution works in practice. We hope that
the suggestions for improvements provided in this paper ﬁnd
support in the respective communities, thereby leading to the
spread of TLS CCA use on a much larger scale.

12

ACKNOWLEDGEMENT

We would like to thank Dominique Unruh, Peter Gutmann,
Ivan Ristic, Tiit Pikma, Martin Paljak (CERT-EE) and the
anonymous reviewers for their feedback on this paper.

This research was supported by the European Regional
Development Fund through the Estonian Center of Excellence
in Computer Science, EXCS, Estonian National Electoral
Committee and Estonian Doctoral School in Information and
Communication Technology, IKTDK.

REFERENCES

[1] D. Wendlandt, D. G. Andersen, and A. Perrig, “Perspectives: improving
SSH-style host authentication with multi-path probing,” in USENIX
2008 Annual Technical Conference on Annual Technical Conference,
ser. ATC’08. Berkeley, CA, USA: USENIX Association, 2008, pp.
321–334.

[2] B. Laurie, A. Langley, and E. Kasper, “Certiﬁcate Transparency,” RFC
draft, Internet Engineering Task Force, Apr. 2013, http://tools.ietf.org/
html/draft-laurie-pki-sunlight-12.

[5]

[4]

[3] T. Dierks and C. Allen, “The TLS Protocol Version 1.0,” RFC 2246
(Proposed Standard), Internet Engineering Task Force, Jan. 1999, http:
//www.ietf.org/rfc/rfc2246.txt.
J. Salowey, H. Zhou, P. Eronen, and H. Tschofenig, “Transport Layer
Security (TLS) Session Resumption without Server-Side State,” RFC
5077 (Proposed Standard), Internet Engineering Task Force, Jan. 2008,
http://www.ietf.org/rfc/rfc5077.txt.
“Apache mod ssl module,” http://httpd.apache.org/docs/2.2/mod/mod
ssl.html.
“Bug 2768:
openssl.org/Ticket/Display.html?id=2768.
“Bug
SSL CLIENT VERIFY,”
bug.cgi?id=53193.
“Bug 45054: SSLVerifyClient optional no ca is broken,” https://issues.
apache.org/bugzilla/show bug.cgi?id=45054.
“OpenSSL Verify Operation,” Aug. 2013, http://www.openssl.org/docs/
apps/verify.html.

wrong
https://issues.apache.org/bugzilla/show

internal verify() hides errors from callbacks,” http://rt.

SSLVerifyClient

optional no ca

53193:

[6]

[7]

[8]

[9]

[10] AS Sertiﬁtseerimiskeskus, “Conﬁguring Apache web server to sup-
port ID-card certiﬁcates. v1.03,” http://www.id.ee/public/Conﬁguring
Apache web server to support ID.pdf.

[11] A. Langley, “Transport Layer Security (TLS) Encrypted Client Certiﬁ-
cates,” Internet Draft, Oct. 2011, http://tools.ietf.org/html/draft-agl-tls-
encryptedclientcerts-00.

[13]

[12] M. Ray, “Transport Layer Security (TLS) Encrypted Handshake Exten-
sion,” Internet Draft, May 2012, http://tools.ietf.org/html/draft-ray-tls-
encrypted-handshake-00.
“Bug 47055: SSLVerifyClient + Directory doesn’t use cache sessions,”
https://issues.apache.org/bugzilla/show bug.cgi?id=47055.
“ASN.1 Denial of Service Attacks (CVE-2006-2937, CVE-2006-
2940),” http://www.openssl.org/news/secadv 20060928.txt.
“Bug 12355: POST incompatible with renegotiate https: connection,”
https://issues.apache.org/bugzilla/show bug.cgi?id=12355#c31.
“Bug 803673: Investigate using Expect: 100-continue for Metrics Data
Ping,” https://bugzilla.mozilla.org/show bug.cgi?id=803673.

[14]

[15]

[16]

[17] R. Hansen, “Slowloris - the low bandwidth, yet greedy and poisonous

HTTP client,” http://ha.ckers.org/slowloris/.
“Apache mod reqtimeout module,” http://httpd.apache.org/docs/2.2/
mod/mod reqtimeout.html.

[18]

[19] The Debian Project, “Apache module mod reqtimeout default conﬁg-
uration ﬁle. Version 2.2.22-13.” http://sources.debian.net/data/main/a/
apache2/2.2.22-13/debian/conﬁg-dir/mods-available/reqtimeout.conf.

[20] R. Bardou, R. Focardi, Y. Kawamoto, L. Simionato, G. Steel, and J.-K.
Tsay, “Efﬁcient Padding Oracle Attacks on Cryptographic Hardware,”
INRIA, Rapport de recherche RR-7944, Apr. 2012. [Online]. Available:
http://hal.inria.fr/hal-00691958

[21] Mozilla, “Personal Security Manager: Client certiﬁcate prompt,” Oct.

2011, https://wiki.mozilla.org/PSM:CertPrompt.

13

[22]

“Issue 90454: Feature: Add the ability to purge the SSL session
cache for a browsing session,” http://code.google.com/p/chromium/
issues/detail?id=90454.

[23] Mozilla, “JavaScript crypto object,” Jan. 2012, https://developer.mozilla.

org/en/docs/JavaScript crypto.
“Issue 90676: window.crypto.logout() and login() don’t work,” http://
code.google.com/p/chromium/issues/detail?id=90676.

[24]

[25] E. Lawrence, “Understanding Session Lifetime,” http://blogs.msdn.

com/b/ieinternals/archive/2010/04/05/understanding-browser-session-
lifetime.aspx.
“Issue 29784: User Interface Improvement for Client Certiﬁcate Usage,”
http://code.google.com/p/chromium/issues/detail?id=29784.

[26]

[27] A. C. Magencio, “How to create a certiﬁcate request with CertEnroll,”
Jan. 2009, http://blogs.msdn.com/b/alejacma/archive/2009/01/28/how-
to-create-a-certiﬁcate-request-with-certenroll-javascript.aspx.

[28] Fox-IT BV, “Report of the investigation into the DigiNotar Certiﬁcate
Authority breach,” Aug. 2012, http://www.rijksoverheid.nl/documenten-
en-publicaties/rapporten/2012/08/13/black-tulip-update.html.

[29] Comodo, “Report of Incident,” Mar. 2011, https://www.comodo.com/

Comodo-Fraud-Incident-2011-03-23.html.

[30] Trustwave, “Clarifying The Trustwave CA Policy Update,” Feb. 2012,
http://blog.spiderlabs.com/2012/02/clarifying-the-trustwave-ca-policy-
update.html.

[31] TURKTRUST, “Public announcements concerning the security ad-
visory,” Feb. 2013, http://turktrust.com.tr/en/kamuoyu-aciklamasi-en.
html.

[32] M. Zalewski, The Tangled Web: A Guide to Securing Modern Web
Applications, 1st ed. San Francisco, CA, USA: No Starch Press, 2011.
[33] C. Karlof, U. Shankar, J. D. Tygar, and D. Wagner, “Dynamic pharming
attacks and locked same-origin policies for web browsers,” in Proceed-
ings of the 14th ACM conference on Computer and communications
security, ser. CCS ’07. New York, NY, USA: ACM, 2007, pp. 58–71.
J. Hodges, C. Jackson, and A. Barth, “HTTP Strict Transport Security
(HSTS),” RFC 6797 (Proposed Standard), Internet Engineering Task
Force, Nov. 2012, http://www.ietf.org/rfc/rfc6797.txt.

[34]

[35] A. Satirov and M. Zusman, “Breaking the security myths of
extended validation SSL certiﬁcates,” 2009, http://www.blackhat.
com/presentations/bh-usa-09/ZUSMAN/BHUSA09-Zusman-
AttackExtSSL-SLIDES.pdf.

[36] C. Jackson and A. Barth, “Beware of Finer-Grained Origins,” in In
Web 2.0 Security and Privacy (W2SP 2008), 2008. [Online]. Available:
http://seclab.stanford.edu/websec/origins/fgo.pdf

[37] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, “Transport Layer
Security (TLS) Renegotiation Indication Extension,” RFC 5746 (Pro-
posed Standard), Internet Engineering Task Force, Feb. 2010, http:
//tools.ietf.org/html/rfc5746.

[38] AS Sertiﬁtseerimiskeskus, “ESTEID Card Certiﬁcation Policy, Version
3.3,” https://sk.ee/upload/ﬁles/SK-CP-ESTEID-20120901v3 3 en.pdf.
[39] AS Sertiﬁtseerimiskeskus, “LDAP ldap.sk.ee technical description.”
Nov. 2013, https://sk.ee/en/repository/ldap/ldap-kataloogi-kasutamine/.
I. Ristic, “SSL Labs Projects,” https://www.ssllabs.com/projects/index.
html.

[40]

[41] A. Hess, J. Jacobson, H. Mills, R. Wamsley, K. E. Seamons, and
B. Smith, “Advanced Client/Server Authentication in TLS,” in Pro-
ceedings of the Network and Distributed System Security Symposium
(NDSS), 2002.

[42] M. Dietz, A. Czeskis, D. Balfanz, and D. S. Wallach, “Origin-bound
certiﬁcates: a fresh approach to strong client authentication for the web,”
in Proceedings of the 21st USENIX conference on Security symposium,
2012, pp. 16–16.

[43] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B. Freisleben, and
M. Smith, “Why Eve and Mallory Love Android: An Analysis of
Android SSL (in)Security,” in Proceedings of the 2012 ACM Conference
on Computer and Communications Security, 2012, pp. 50–61.

[44] M. Georgiev, S.

Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov, “The most dangerous code in the world: validating SSL
certiﬁcates in non-browser software,” in Proceedings of the 2012 ACM
Conference on Computer and Communications Security, 2012, pp. 38–
49.

