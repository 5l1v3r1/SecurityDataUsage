Automated Synthesis of Privacy-Preserving Distributed Applications

Michael Backes

Saarland University and MPI-SWS

Germany

backes@mpi-sws.org

Matteo Maffei

Saarland University

Germany

Kim Pecina

Saarland University

Germany

maffei@cs.uni-saarland.de

pecina@cs.uni-saarland.de

Abstract

1. Introduction

We introduce a framework for the automated synthesis of
security-sensitive distributed applications. The central idea
is to provide the programmer with a high-level declarative
language for specifying the system and the intended secu-
rity properties, abstracting away from any cryptographic
details. A compiler takes as input such high-level speciﬁca-
tions and automatically produces the corresponding crypto-
graphic implementations (i.e., cryptographic library, cryp-
tographic protocols, and F# source code).

In this work, we focus on two important, and seem-
ingly contradictory, security properties, namely, authoriza-
tion and privacy. On the one hand, the access to sensitive
resources should be granted only to authorized users; on the
other hand, these users would like to share as little personal
information as possible with third parties. These opposing
goals make it challenging to enforce privacy-aware autho-
rization policies in a distributed setting.

The high-level declarative language builds on Eviden-
tial DKAL, a logic for authorization polices of decentral-
ized systems, which we extend to reason about privacy poli-
cies. Speciﬁcally, the traditional says modality from au-
thorization logics is accompanied by existential quantiﬁca-
tion in order to express the secrecy of sensitive information.
The cryptographic realization of privacy-aware authoriza-
tion policies is obtained by a powerful combination of dig-
ital signatures and zero-knowledge proofs. This approach
is general and can be seen as a privacy-enabling plugin for
existing authorization languages and proof-carrying autho-
rization architectures.

We proved that the implementations output by the com-
piler enforce the intended authorization policies and we
conducted an experimental evaluation to demonstrate the
feasibility of our approach.

One of the central challenges in the development of dis-
tributed systems is the design of cryptographic protocols
that meet the desired functional requirements and enforce
the intended security properties. There is a common under-
standing that basic security properties such as secrecy and
authentication can easily be enforced via encryption and
digital signatures, respectively. Modern applications, how-
ever, exhibit more sophisticated and heterogeneous security
requirements: for example, social networks, e-health sys-
tems, and reviewing systems must fulﬁll sophisticated ac-
cess control, privacy, and anonymity constraints. Devising
a cryptographic infrastructure for the enforcement of these
properties is challenging and highly error-prone for secu-
rity experts, and even prohibitive for regular programmers,
which do not have the required background and expertise
in cryptography. Currently, many popular applications rely
on trusted third parties to collect and process sensitive in-
formation (e.g., conference reviewing systems like Easy-
chair or social networks like Facebook). The presence of
trusted parties simpliﬁes the system design but gives rise to
a number of privacy concerns related to the deliberate or
accidental disclosure of sensitive information. Other appli-
cations are fully decentralized but employ ad-hoc crypto-
graphic protocols that are not always ﬂawless and, due to
their diversity, break any form of interoperability.

We believe that the design of security-sensitive dis-
tributed applications should be driven by rigorous, for-
mally certiﬁed, and possibly automated, techniques, as op-
posed to best practices and informal guidelines. Speciﬁ-
cally, developers should be given the possibility to specify
the functional behavior of the system and the intended se-
curity properties using convenient, security-oriented, pro-
gramming abstractions that conceal cryptographic details.
A compiler should automatically turn user-provided, high-
level system descriptions into executable cryptographic im-
plementations.
Ideally, these implementations should be
open-ended and interoperable, i.e., it should be possible to
extend the system with new functionalities and to share in-

formation among different, independently developed, appli-
cations.
This work introduces such a framework, focusing on two
important, and seemingly contradictory, security proper-
ties, namely, authorization and privacy. Authorization is
a key ingredient in virtually any security infrastructure.
The fundamental idea is to let the resource provider de-
ﬁne a security policy that constraints the operations on sen-
sitive resources and to let a reference monitor ﬁlter ac-
cess requests in a way that an operation is allowed only
if the requester has sufﬁcient permissions according to
the security policy. For instance, let us consider a sim-
ple university management system in which, at the end
of each semester, students are given a certiﬁcate of the
form Uni says Stud(id , program, grd ), reporting their id,
the program they are enrolled in, and their grades. Such
a certiﬁcate is typically implemented as a digital signa-
ture of the form sig(Stud(id , program, grd ))Uni,
issued
by the university administration on (a bit string encoding
of) the predicate Stud(id , program, grd ). The system un-
der consideration is open-ended in that the student certiﬁ-
cate may be employed in a number of different services:
scholarship assignment, discounted museum entrances, ac-
cess to university buildings (as in the Grey system [17]
for device-enabled authorization), and so on. For instance,
the policy for scholarship assignments may be of the form
∀x, y, z. Uni says Stud(x, y, z) ∧ average(z) ≥ X ⇒
GetScholarship(x), where X is the minimum average grade
that is required to get the scholarship. Systems and au-
thorization policies of this form can be conveniently de-
scribed in a variety of logic-based authorization languages,
such as DCC [3, 2], Aura [43], PCML5 [9], and Evidential
DKAL [7].

The combination of authorization and privacy, however,
is challenging, even more so in the context of open-ended
applications, in which it is not known in advance how sen-
sitive information is used by other applications (for in-
stance, the university does not necessarily know all services
that make usage of student credentials). Let us consider,
for instance, the entrance to university buildings: students
might not want their movements within the university to be
tracked. Let us suppose that one of the authorization poli-
cies ruling the entrance to the computer science laboratory
is of the form

∀x, y.

Uni says Stud(x, cs, y) ∧ x says Acc(lab)
⇒ OkAcc(lab)

(1)

Ideally, students would like to prove to be enrolled in the
computer science program, without disclosing their iden-
tity. From a logical point of view, we propose to cap-
ture privacy constraints via existential quantiﬁcation, i.e.,
privacy-relevant values are hidden by existentially quanti-

ﬁed variables. For instance, students can provide the fol-
lowing piece of information:

∃x, y. Uni says Stud(x, cs, y) ∧ x says Acc(lab)

(2)

This logical characterization of privacy and authorization is
simple and elegant, but providing a faithful cryptographic
evidence thereof turns out to be quite challenging: digi-
tal signatures do not offer any sort of privacy and standard
cryptographic solutions like encryptions and MACs are not
suitable for open-ended applications. This is the reason why
existing authorization languages do not allow for such a us-
age of existential quantiﬁcation and fall short of support-
ing privacy properties. We present a general and automated
procedure to implement privacy-aware authorization poli-
cies by means of a powerful combination of digital signa-
tures and zero-knowledge proofs.1 The idea is to use signa-
tures to justify the validity of logical formulas, as previously
shown, and zero-knowledge proofs of knowledge of such
signatures to justify the validity of variants of these formu-
las – variants in which the sensitive arguments are existen-
tially quantiﬁed. The unique properties of zero-knowledge
proofs assure the veriﬁer of the validity of these formulas,
without revealing any sensitive data that the prover wishes
to keep secret. For instance, the cryptographic realization
of the formula (2) is a zero-knowledge proof of knowledge
of two signatures of the form sig(Stud(x, cs, y))Uni and
sig(Acc(lab))x, for some student x and grades y that are
not revealed to the veriﬁer. This approach is ﬂexible and,
depending on what information is kept secret, can be used to
express a variety of privacy properties, such as data secrecy
and user anonymity. Furthermore, this approach is well
suited for open-ended applications, since each party can
prove any statement of which she knows a cryptographic
evidence and, while doing so, autonomously hide any infor-
mation considered sensitive for the speciﬁc application.
Our contributions. To summarize, this work presents:

• a generally applicable and efﬁcient cryptographic
implementation of privacy-aware authorization poli-
cies, which builds on automorphic signatures [5]
and the Groth-Sahai zero-knowledge proof
sys-
tem [40] (cf. § 2);

• a high-level, declarative language for distributed sys-
tems, which extends Evidential DKAL [7] to deal with
privacy properties (cf. § 3);

1 A zero-knowledge proof combines two seemingly contradictory prop-
erties. First, it is a proof of a statement that cannot be forged, i.e., infea-
sible, to produce a zero-knowledge proof of a wrong statement. Second, a
zero-knowledge proof does not reveal any information besides the bare fact
that the statement is valid [39]. A non-interactive zero-knowledge proof is
a zero-knowledge protocol consisting of one message sent by the prover
to the veriﬁer. A zero-knowledge proof of knowledge additionally ensures
that the prover knows the witnesses to the given statement.

• a compiler that turns high-level descriptions into ex-
ecutable implementations, comprising cryptographic
libraries, cryptographic protocols, and F# source
code (cf. § 4);

• a correctness result, which ensures that the implemen-
tations output by the compiler enforce the authoriza-
tion policies speciﬁed by the user (cf. § 5);

• two case studies, consisting of a distributed reviewing
system and a distributed social network, which demon-
strate the possibility to specify relatively complex de-
centralized systems in a simple and elegant manner,
without requiring any cryptographic expertise on the
part of the users (cf. § 6);

• and an experimental evaluation, which demonstrates

the feasibility of our approach (cf. § 7).

Due to space constraints, we postpone the proofs, the details
of the cryptographic realization, and further case studies to
the long version, which is available online [12].

Related Work. The seminal works by Abadi et al. [44, 4]
on access control in distributed systems paved the way for
the development of a number of authorization logics and
languages [32, 19, 43, 38, 29, 9]. In the literature it is well-
known that logical formulas based on a says modality can be
implemented in a distributed setting via digital signatures,
but the problem of ensuring the privacy of data employed in
authorization proofs has not been tackled thus far. A notice-
able exception is AuraConf [54], a conﬁdentiality extension
of the Aura [43] programming language based on public-
key encryption and a monadic constructor.
In AuraConf,
the programmer has to specify the intended recipient of each
data and the compiler is in charge of encrypting such data
with the appropriate public key. In our approach, the pro-
grammer does not need to know in advance all the intended
usages and recipients of the digital signatures issued in the
protocol run, which is crucial to deal with open-ended sys-
tems. In fact, principals can use received signatures to con-
struct arbitrary authorization proofs, using zero-knowledge
proofs to selectively hide sensitive data.

Digital signatures and zero-knowledge schemes proved
to be salient tools for achieving ﬁne-grained anonymity
properties in a number of applications, such as trusted com-
puting [26], digital credentials [20], trust protocols [47, 10],
and social networks [13]. The relationship between privacy-
preserving cryptographic constructions and authorization
logics, however, has been investigated only partially and
in specialized settings. For instance, Li et al. [45] devel-
oped a framework for Automated Trust Negotiation using
anonymous credentials, which is tailored to RT, a family
of Trust-management languages [46]. Frikken et al. used

a combination of hidden credentials, homomorphic encryp-
tion, and oblivious transfer to enforce access control poli-
cies while keeping both policies and credentials secret [37].
Our framework is not tailored to a speciﬁc language and can
be seen as a generally applicable privacy-preserving plu-
gin for authorization logics: in the long version, we report
on a privacy-oriented extension of the Proof Carrying Au-
thorization framework [8, 18] and we envision the usage
of our framework within several other authorization lan-
guages, such as Aura [43], PCML5 [9], F∗ [52], and Sec-
Pal [19]. Some preliminary ideas on privacy-aware proof-
carrying authorization were anticipated in a position paper
by Maffei and Pecina [48].

Backes et al. have recently presented G2C [14], a
goal-driven speciﬁcation language for distributed applica-
tions. This language supports secrecy, access control, and
anonymity, which are enforced by means of broadcast en-
cryption and group signatures. Similarly to our approach,
G2C conceals cryptographic details and lets a compiler gen-
erate the cryptographic implementation. G2C, however,
does not support open-ended applications (i.e., it is not pos-
sible to extend the system in order to provide new function-
alities without generating the whole protocol from scratch).
Furthermore, the G2C compiler yields cryptographic proto-
cols as opposed to executable implementations and it does
not provide security by construction guarantees.

The proof of correctness for our compiler builds on the
type theory for zero-knowledge proofs by Backes et al. [11]
and, in particular, on their compiler from zero-knowledge
statements to symbolic cryptographic libraries. These li-
braries model the ideal behavior of cryptographic schemes
using standard language constructs and are thus suitable for
veriﬁcation but cannot be used for deployment. Our com-
piler, instead, converts a DKAL derivation of the intended
protocol run into an executable implementation, which in-
cludes concrete, executable cryptographic libraries. Devis-
ing an efﬁcient, yet expressive and ﬂexible cryptographic
realization of privacy-aware authorization proofs is one of
the challenges faced in this work.

Recently, Meiklejohn et al. [49] and Almeida et al. [6]
have independently presented two compilers for zero-
knowledge proofs, which take as input a speciﬁcation
of the cryptographic statement to be proved. The cryp-
tographic realization of such speciﬁcations is based on
Σ-protocols [30]. Our compiler builds on the Groth-Sahai
zero-knowledge proof scheme [40], which is based on
pairing-based cryptography and is, in general, more efﬁ-
cient and more expressive. Furthermore, our compiler pro-
vides a higher level of abstraction, since it takes as input
logical formulas as opposed to cryptographic statements.

Table 1 Cryptographic evidence of authorization formulas.

:= versig(us, uA, F ) | E
:= ap | S1 ∧ S2 | S1 ∨ S2 | ∃x. S (statements)

(atomic predicates)

ap
S

(cid:40)

[M ] =

vk A says F if versig(M, vk A, F )
[S]zk

if verzk(M, S)

[S]zk =



uk says F
[S1]zk ∧ [S2]zk
[S1]zk ∨ [S2]zk
∃x. [S(cid:48)]zk

if S = versig(us, uk, F )
if S = S1 ∧ S2
if S = S1 ∨ S2
if S = ∃x. S(cid:48)

2. Privacy-aware Evidential Authorization

This section gives an intuitive overview of our frame-
work (§ 2.1), establishes the binding between authoriza-
tion formulas and cryptographic messages (§ 2.2), de-
scribes the class of statements that can be proved in zero-
knowledge (§ 2.3), and characterizes which of them provide
meaningful security guarantees (§ 2.4).

2.1. Overview

Let us consider the example discussed in § 1. The stu-
dent’s goal is to provide evidence of the validity of the pred-
icate OkAcc(lab). The validity of this predicate is ruled
by the authorization policy (1) and the minimal amount of
information the student has to reveal is captured by for-
mula (2). The key insight is that the student does not need
to reveal her identity nor her grades, since they do not occur
in the predicate OkAcc(lab) and can thus be existentially
quantiﬁed. The student has two signatures at her disposal,
namely, sig(Stud(vkid , cs, grd ))Uni and sig(Acc(lab))id.
Our idea is to let the student create a proof of the follow-
ing statement:

2.2. Mapping Cryptographic Messages to Logical

Formulas

Here and throughout

this paper, we let M range
over cryptographic messages (digital signatures and zero-
knowledge proofs), a, b, m over names (i.e., bit strings),
x, y, z over variables, u over names and variables, F over
authorization formulas,2 and E over quadratic equations
in Zn [40], which are used to express arithmetic proper-
ties (e.g., average(z) ≥ X from § 1). The predicate
versig(sig, vk, m) denotes the successful veriﬁcation of sig-
nature sig on message m with veriﬁcation key vk, and the
predicate verzk(ZK, S) denotes the successful veriﬁcation
of the zero-knowledge proof ZK for statement S.

Predicates of the form versig(us, uk, F ) and quadratic
equations in Zn form the class of atomic predicates, which
are ranged over by ap (cf. Table 1). Zero-knowledge state-
ments, ranged over by S, are built on atomic predicates us-
ing conjunction, disjunction, and existential quantiﬁcation.
The function [·] : M (cid:55)→ F establishes the logical in-
terpretation of cryptographic messages. The logical inter-
pretation of a signature on (the bit-string encoding of) the
predicate F , veriﬁable with key vk A, is vk A says F . The
logical interpretation of a zero-knowledge proof is similarly
deﬁned by induction on the structure of the statement.

∃x1, x2, xid , xgrd .

versig(x1, vkUni , Stud(xid , cs, xgrd ))
∧ versig(x2, xid , Acc(lab))

This statement says that there exist two signatures x1 and
x2, a veriﬁcation key xid (which constitutes the student’s
id), and grades xgrd such that (i ) x1 is a signature on the
predicate Stud(xid , cs, xgrd ) that can be successfully ver-
iﬁed with the university administration’s veriﬁcation key
vkUni and (ii ) x2 is a signature on the predicate Acc(lab)
that can be successfully veriﬁed with the student’s veriﬁ-
cation key xid. Since we use zero-knowledge proofs of
knowledge, the above statement actually implies that the
prover knows the signatures and the veriﬁcation key. Upon
reception and veriﬁcation of this proof, the veriﬁer can
safely derive the logical formula (2), which in turn allows
OkAcc(lab) to be derived as previously described.

(3)

2.3. Construction of Zero-Knowledge Proofs

The deduction system in Table 2 characterizes what kind
of statements a principal can prove in zero-knowledge start-
ing from a database Γ of signatures and zero-knowledge
proofs at her disposal. Intuitively, these statements may re-
gard properties of digital signatures, as formalized by the
judgment Γ (cid:96)S S, or be obtained by combining the state-
ments of existing zero-knowledge proofs, as formalized by
the judgment Γ (cid:96)ZK S.
The statements proved by the judgment Γ (cid:96)S S are ob-
tained by combining statements of the form versig(s, vk , F )
(I-S-VER) in conjunctive (I-S-∧) and disjunctive (I-S-∨-1

2Our framework is independent of the underlying authorization logic:
we just assume the presence of conjunction, disjunction, and existential
quantiﬁcation operators.

Table 2 Zero-knowledge deduction system.

I-S-VER
M ∈ Γ

versig(M, vk , F )

Γ (cid:96)S versig(M, vk , F )

I-ZK-S
Γ (cid:96)S S
Γ (cid:96)ZK S

I-ZK-VER
M ∈ Γ

verzk(M, S)
Γ (cid:96)ZK S

S well-formed

I-ZK-∃
Γ (cid:96)ZK S{u/x}
Γ (cid:96)ZK ∃x. S

I-ZK-∧

Γ (cid:96)ZK ∃(cid:101)x. S1

Γ (cid:96)ZK ∃(cid:101)y. S2
Γ (cid:96)ZK ∃(cid:101)x,(cid:101)y. S1 ∧ S2

(cid:101)x ∩(cid:101)y = ∅

I-S-∧
Γ (cid:96)S S1

Γ (cid:96)S S2

Γ (cid:96)S S1 ∧ S2

Γ (cid:96)S S1

I-S-∨-1
Γ (cid:96)S S1 ∨ S2

Γ (cid:96)S S2

I-S-∨-2
Γ (cid:96)S S1 ∨ S2

E-ZK-∧-1

Γ (cid:96)ZK ∃(cid:101)x. S1 ∧ S2
Γ (cid:96)ZK ∃(cid:101)x. S1

E-ZK-∧-2

Γ (cid:96)ZK ∃(cid:101)x. S1 ∧ S2
Γ (cid:96)ZK ∃(cid:101)x. S2

and I-S-∨-2) form. Notice that logical conjunctions reveal
more information than each of the two individual conjuncts,
while logical disjunctions reveal less information in that it is
not possible to determine which of the two disjuncts holds
true.
The statements proved by the judgment Γ (cid:96)ZK S build
on the aforementioned statements (I-ZK-S) and on the
statements of the zero-knowledge proofs in Γ (I-ZK-VER).
Such statements can be reﬁned by existential quantiﬁca-
tion (I-ZK-∃) and conjunction elimination (E-ZK-∧-1 and
E-ZK-∧-2) to hide information. It is also possible to com-
bine the statements of two zero-knowledge proofs in con-
junctive form (I-ZK-∧).
Notice that logical disjunctions are introduced by judg-
ment Γ (cid:96)S S and not by judgment Γ (cid:96)ZK S, since we are
not aware of efﬁcient cryptographic constructions that allow
the prover to create a zero-knowledge proof of S ∨ S(cid:48) from
a zero-knowledge proof of S.
Example
the
us
example
=
sig(Stud(vkid , cs, grd ))Uni, M2 = sig(Acc(lab))id,
versig(M1, vkUni , Stud(vkid , cs, grd )),
V1
V2 = versig(M2, vkid , Acc(lab)), and Γ = M1, M2.
The creation of the zero-knowledge proof of statement (3)
is speciﬁed in Table 3.
Example 2. It is worth to mention that I-ZK-∃ may also
be used to hide equality relations among secret values:
for instance, one can derive ∃x, y. A says p(x, y) from
∃x. A says p(x, x).

1.
Let
from §

again
let M1

consider

2.1.

We

=

2.4. Validity of Zero-Knowledge Statements

It is interesting to observe that not all zero-knowledge
statements are meaningful. For instance, suppose that a
principal receives a zero-knowledge proof of the following
statement:

∃ys, yI . versig(ys, yI , Stud(vkid , cs, grd ))

(4)

We would be tempted to let
this principal entail
∃yI . yI says Stud(vkid , cs, grd ). This zero-knowledge
proof, however, does not reveal the identity of the person
issuing the signature, nor is there any evidence that this
person is a principal of the system.
In fact, this zero-
knowledge proof might have been constructed by an at-
tacker, using a fresh key-pair and, therefore, the formula
∃yI . yI says Stud(vkid , cs, grd ) is not necessarily entailed
by the formulas proved by the principals of the system. No-
tice that we assume that the principals of the system are
honest, i.e., they issue signatures to witness the validity of
the corresponding logical predicates. We cannot, of course,
assume the same for the attacker.

We stipulate that principals only sign veriﬁcation keys
that belong to principals of the system (as opposed to at-
tacker’s keys).3 We call these keys trustworthy. Checking
whether a veriﬁcation key that occurs in a zero-knowledge
proof is trustworthy is subtle. The idea is that a key is con-
sidered trustworthy if either it is revealed by the proof and
known to belong to a principal of the system, or, recursively,
it is endorsed by a trustworthy key. For instance, the state-
ment (4) does not guarantee that the existentially quantiﬁed
veriﬁcation key yI is trustworthy. Conversely, the veriﬁ-
cation key xid that is existentially quantiﬁed in the state-
ment (3) is signed by Uni and, therefore, is trustworthy.
Hence, this statement justiﬁes formula (2).

In other words, a statement is well-formed if it ensures
that all veriﬁcation keys are trustworthy. Despite the sim-
plicity of this intuition, the formal deﬁnition has to take into
account a number of complications, including the presence
of logical disjunctions in the statement. For instance, the
statement ∃ys, yI . versig(ys, yI , F ) ∨ versig(ys, vkUni , F )
is not well-formed, since we do not know which of the two
disjuncts holds true. The idea is to transform a statement

3We assume a public-key infrastructure that binds public keys to their
owner in a publicly-veriﬁable manner. Such a PKI may be centralized
(e.g., Verisign) or decentralized (e.g., Webs of Trust). In the example from
§ 2.1, the university serves as a (centralized) PKI.

Table 3 Deduction of the zero-knoweldge proof for Example 1.

V1

M1 ∈ Γ

Γ (cid:96)S V1
Γ (cid:96)ZK V1

TZK :=

M2 ∈ Γ

I-S-VER
I-ZK-S
Γ (cid:96)ZK V1 ∧ V2

Γ (cid:96)S V2
Γ (cid:96)ZK V2

V2

I-S-VER
I-ZK-S

I-ZK-∧

Γ (cid:96)ZK ∃x1, x2, xid , xgrd . versig(x1, vkUni , Stud(xid , cs, xgrd )) ∧ versig(x2, xid , Acc(lab))

I-ZK-∃ (X4)

Table 4 Veriﬁcation rules.

VER-SIG
M ∈ Γ

versig(M, vk A, F )

Γ (cid:96) vk A says F

VER-ZK
M ∈ Γ

verzk(M, S)
Γ (cid:96) [S]zk

S well-formed

in disjunctive form and then to check that all keys in each
sequence of conjunctions are registered. We formalize the
notion of trustworthiness for keys below. Here and through-

out this paper, we write(cid:101)u to denote the sequence u1, . . . , u(cid:96)
thy in a monomial M =(cid:86)m

for some (cid:96).
Deﬁnition 1 (Trustworthiness of keys). A key u is trustwor-
i=1 api iff one of the following

conditions holds:

• u = vk is registered
• there exists apj = versig(us, uk, F ) such that u is a
variable occurring free in F and uk is trustworthy in
M

in disjunctive form iff S = ∃(cid:101)x. (cid:87)m
(cid:86)n

Deﬁnition 2 (Disjunctive form). We say a statement S is
i=1 Mi, where Mi =

j=1 apj.
It is clear that each statement can be rewritten in disjunc-
tive form. In the following, we assume a disjunctive normal
form4 for each statement S, written as dnf (S).
Deﬁnition 3 (Well-formedness of statements). A mono-
i=1 api is well-formed iff for every api =
versig(us, uk, F ), uk is trustworthy in M.
i=1 Mi is well-
formed if each Mi is well-formed.

mial M = (cid:86)m
A statement S such that dnf (S) = ∃(cid:101)x.(cid:87)m

We are now ready to characterize the logical formu-
las that are justiﬁed by the digital signatures and zero-
knowledge proofs in Γ, as formalized in Table 4. The rules

4The disjunctive normal form can be obtained, for instance, by lexico-

graphical order.

are self-explanatory: we just point out that the statements
of zero-knowledge proofs are required to be well-formed.

3. Speciﬁcation Language: Privacy-aware Evi-

dential DKAL

The Distributed Knowledge Authorization Language
(DKAL) [41, 42] is a logic-based language for modeling
and analyzing decentralized polices. A distinctive feature of
DKAL is the possibility to explicitly describe the exchange
of information among principals. Recently, Blass et al. in-
troduced Evidential DKAL [7], an extension of DKAL in
which the formulas exchanged by principals are justiﬁed by
digital signatures, which allows for more expressive logical
derivations.
In this section, we extend Evidential DKAL
with existential quantiﬁcation, in order to express privacy
constraints, and with zero-knowledge proofs, in order to
justify logical formulas in which sensitive values are exis-
tentially quantiﬁed.

3.1. Overview of Evidential DKAL

Authorization languages such as PCA or SecPAL [19]
often rely on fragments of ﬁrst-order or higher-order logic
to describe and enforce authorization policies. The logic
underlying DKAL, called infon logic, is fundamentally dif-
ferent: instead of dealing with the validity of statements,
this logic focuses on the notion of information. A state-
ment represents a piece of information, as opposed to a truth
value, that a speciﬁc principal has obtained, and access con-
trol is decided by deriving certain information, as opposed
to proving a formula valid.

Table 5 reports some fundamental rules of Evidential
DKAL. Here and throughout this paper, we let Γ denote a
set of pieces of information, i.e., logical formulas and cryp-
tographic messages. ENSUE says that if A knows Γ, then
A knows also the information derivable from Γ. The initial
knowledge of principal A is given in terms of knowledge
assertions of the form A : F , which can be seen as axioms
in the system. Rule P-A says that given the knowledge as-
sertion A : F , A knows F . For easing the presentation,
we deviate from the original presentation [7], which does

Table 5 Selection of rules from Evidential DKAL.

Table 6 Core Rules of Privacy-aware Evidential DKAL.

ENSUE
A knows Γ
Γ (cid:96) F

A knows F

COMM-J

P-A

A : F

P-S

A : vkA says F

versig(M, vk A, F )

A knows F

A knows M

P-ZK
A knows Γ

Γ (cid:96)ZK S
A knows M

verzk(M, S)

if FB then B sends F to p

if FA then A receives F

(cid:48) from q

B knows FB η
p η = A

B knows M

q θ = B

[M ] = F

A knows FA θ
θ = F

F

(cid:48)

A knows M

not precisely specify how principals acquire the knowledge
of signatures. We introduce rule P-S to express that given
the knowledge assertion A : A says F , A can produce a
self-generated signature M on F .
Example 3. Let us consider the example from § 2.1. The
generation of student certiﬁcates is modeled by knowledge
assertions of the form

Uni : vkUni says Stud(vkid , cs, grd )

(5)

One can derive Uni knows Stud(vkid , cs, grd ) by P-A and
Uni knows M by P-S, where M is a signature issued by
Uni on Stud(vkid , cs, grd ).

The communication rule COMM-J describes the ex-
change of cryptographic messages that justify (i.e., pro-
vide evidence of) a certain statement. This rule is used
to synchronize a communication assertion of the form
if FB then B sends F to p with a communication asser-
tion of the form if FA then A receives F (cid:48) from q. In or-
der to ﬁre this rule, B must know FAη and A must know
FBθ, for some substitutions η and θ mapping variables5
to messages in the knowledge of A and B, respectively.
Furthermore, conditional guards may be omitted, obtaining
communication assertions of the form A sends F to B and
A receives F from B. In order to ﬁre COMM-J, we addi-
tionally require the sender and the receiver to coincide on
both sides, i.e., p η = A and q θ = B. Finally, B must
know a cryptographic evidence M for the statement F sent
to A and the statement F (cid:48) expected from A has to be uniﬁ-
able with F by substitution θ. Once COMM-J is ﬁred, A
knows the cryptographic evidence M of F .
Example 4. The issue of student certiﬁcates can be speci-
ﬁed via the following assertions:

Uni sends vkUni says Stud(vkid , cs, grd ) to id
id receives vkUni says Stud(vkid , cs, y) from Uni
5The variables occurring in communication assertions are implicitly

(6)
(7)

universally quantiﬁed.

COMM-A

if FB then ? sends F to p

if FA then A receives F

(cid:48) from ?

B knows FB η
p η = A

B knows M
[M ] = F

A knows FA θ
(cid:48)
θ = F

F

A knows M

The intended communication protocols is modeled by the
DKAL derivation below (for the sake of readability, we omit
some trivial hypotheses and use the abbreviations deﬁned in
Example 1):

(5)

V1

TC := (6)

(7)

Uni knows M1

id knows M1

P-S

COMM-J

We ﬁnally derive id knows vkUni says Stud(vkid , cs, grd )
as follows:

TS := TC

V1

M1 (cid:96) vkUni says Stud(vkid , cs, grd )
id knows vkUni says Stud(vkid , cs, grd )

VER-SIG
ENSUE

3.2. Privacy-Aware Evidential DKAL

Evidential DKAL does not feature any mechanism to en-
force the privacy of sensitive information. We solve this
problem by integrating our zero-knowledge deduction sys-
tem and by reﬁning the syntax of statements in order to sup-
port existential quantiﬁcation.

Formally, we extend evidential DKAL with the rules
from Table 2, Table 4, and Table 6. P-ZK bridges between
DKAL and the zero-knowledge deduction system, bringing
the zero-knowledge proofs derived by A into A’s knowl-
edge. COMM-A is a variant of COMM-J that is introduced
for modeling anonymous communication: In this variant,
the identity of the sender is replaced by the special symbol
‘?’ and is not known to the receiver.

Example 5. We describe the anonymous entrance
to the laboratory by means of
the following asser-
tions, where AS denotes the access control system:

id : vkid says Acc(lab)

(8)

? sends (2) to AS (9)

AS receives (2) from ? (10)

Table 7 Derivation tree modeling the communication protocol from Example 5

TC

(8)
V2
id knows M2
id knows M1, M2

P-S

MSG-∪

(9)

(10)

TA :=

id knows MZK

AS knows MZK

verzk(MZK, (3))

TZK

P-ZK

COMM-A

The communication protocol is modeled by the derivation
tree displayed in Table 7.

The student creates the zero-knowledge proof of state-
ment (3) using the signature M1 received from the uni-
versity and the signature M2 from the knowledge asser-
tion (8) as witnesses. Using ENSUE, we can eventu-
ally derive AS knows ∃x, y. Uni says Stud(x, cs, y) ∧
x says Acc(lab).

4. Compiler

We developed a compiler C[·] : Tdkal → CF# that takes as
input the Privacy-aware Evidential DKAL derivation cap-
turing the intended system behavior and produces the F#
executable code for each of the principals in the system. In
this section, we overview the algorithm and state the sound-
ness results.
Intuitively, the compiler builds on a translation function
T : Rdkal → CF# from DKAL rules to F# code. Each
rule of the zero-knowledge deduction system (cf. Table 2)
is translated into a sequence of calls to functions of the
zero-knowledge library. Communication rules (namely,
COMM-J and COMM-A) are translated by extending the
current code of the sender and the receiver with the out-
put and input of the cryptographic message, respectively. In
order to protect the secrecy of exchanged information, the
communication is always encrypted with the public key of
the receiver. The code of the receiver is further extended to
verify the signature or the zero-knowledge proof received
from the network.

The compiler produces the code of each principal by
scanning the DKAL derivation top-down (i.e., from the out-
ermost hypotheses until the thesis) and, for each rule R, by
appending the code T (R) to the current code for the corre-
sponding principal.
Example 6. Let us describe the compiler in more detail by
illustrating the code produced by translating the TA deriva-
tion tree from Example 5 (cf. Table 8). The compiler gener-
ates three functions, one for each role (i.e., university, stu-
dent, and access control system). These functions are meant
to be integrated in the code of the respective application and

are consequently parameterized by a number of values, in-
cluding the cryptographic keys of the running principal, the
ones of the intended communication partners, network ad-
dresses, and so on. On the right-hand side of each line of
code, we indicate the rule application (i.e., the rule name
and the derivation tree) that has been processed by the com-
piler. For the moment, we invite the reader to ignore the
annotations between square brackets, which play a role in
the formalization of the correctness result (cf. § 5) but do
not have any computational signiﬁcance.

The TA tree is scanned top-down. The ﬁrst rule that
is processed is the application of P-S in TC, which intro-
duces the signature issued by the university on the predi-
cate Stud(vkid , cs, grd ) into the derivation tree: this rule is
translated into a call to the signature creation function in
the university’s code. The next rule is COMM-J from TC,
which describes the transmission of the student’s certiﬁcate:
the signature is ﬁrst encrypted with the recipient’s encryp-
tion key and then sent to the address of the recipient, who
receives the message, decrypts the ciphertext, and ﬁnally
veriﬁes the signature. The application of P-S in TA leads to
a call to the signature creation function in the student’s code.
The rules in TZK model the creation of the zero-knowledge
proof and are translated into a sequence of calls to the corre-
sponding functions in the zero-knowledge library. Finally,
the application of COMM-A in TA models the transmission
of the zero-knowledge proof and is translated similarly to
COMM-J.

5. Formal Veriﬁcation

We verify the correctness of our compiler using the se-
curity type system for F# developed by Bengtson et al. [21]
and recently extended by Backes et al. in order to support
zero-knowledge proofs [11]. The semantics of F# is for-
malized using RCF, a concurrent lambda calculus that has
successfully been used to encode and verify the security of
F# protocol implementations [22]. Authorization policies
are expressed in code by means of annotations: assumptions
introduce new hypotheses (i.e., formulas that are assumed to

Table 8 Source code for the running example

(cid:27) TC

(P-S)

[[ assume FUni ; ]]
let s = sig skUni

(pickle Stud(vkid , cs, grd )) in

let msg = enc ekid s in
let c = connect ad in
send c msg

TC

(COMM-J)

(cid:27)

AccSys(dkAS , vkUni , vkid , ad , cs, lab) (cid:44)

let c = listen ad in
let msg = recv c in
let xzk = dec dkAS msg in
let x = unpickle (verzk(3) xzk) in
[[ assert (2) ]] ;



TC

(COMM-A)

where FUni = vkUni says Stud(vkid , cs, grd )

Fid = vkid says Acc(lab)

hold) and assertions6 declare formulas that are expected to
logically follow from the previously introduced hypotheses.
Deﬁnition 4 (Safety [21]). A program P is safe if and only
if, in all executions of P , all assertions are entailed by the
current assumptions.

In general, we are interested in the safety of programs
that are executed in parallel with the attacker. The attacker
is modeled as some arbitrary (untyped) expression that has
access to the functions exported by the program. The idea
is to let the attacker create arbitrary parallel instances of the
protocol roles and to let him send and receive messages on
the network channels. If the attacker cannot break the safety
property, then the program is robustly safe. In the following,
we write P Q to denote the application of program P to
program Q (i.e., P can access the functions exported by Q).
Deﬁnition 5 (Formal threat model [21]). A program A is
an attacker if and only if A contains no occurrence of assert
and each type annotation within A is unit.

A program P is robustly safe if and only if the applica-

tion A P is safe for all attackers A.

The compiler automatically generates assumptions and
assertions that capture the logical formulas that are intro-
duced and derived in the DKAL derivation, respectively. In
particular, the translation of a knowledge assertion of the
form A : F (rules P-A and P-S) introduces an assumption
of the form assume F into A’s code. The translation of any
other rule with a thesis of the form A knows F (e.g., EN-
SUE) or A knows M (e.g., COMM-J) introduces an assertion

6RCF assertions are not to be confused with DKAL assertions.

Uni(skUni , ekid , vkUni , vkid , ad , cs, grd ) (cid:44)

Stud(skid , dkid , ekAS , vkUni , vkid , ad id , ad AS , cs, lab) (cid:44)



(COMM-J)

TC

let c = listen ad in
let msg = recv c in
let s = dec dkid msg in
let x = unpickle(versig vkUni s) in
match x with Stud(vkid , cs, grd ) ⇒
[[ assert FUni ]] ;
[[ assume Fid ]] ;
let s(cid:48) = sig skid (pickle Acc(lab)) in

(cid:9) TA(P-S)
let x = createzk-s s vkUni in (cid:9) TZK(I-ZK-S)
let x(cid:48) = createzk-s s vkid in (cid:9) TZK(I-ZK-S)
let xzk = createzk-∧ x x(cid:48) in (cid:9) TZK(I-ZK-∧)
let yzk = createzk-∃ (3) xzk in (cid:9) TZK(I-ZK-∃)
[[ assert( (2) ) ]] ; (cid:9) TA(P-ZK)
(cid:27)

let msg = enc ekAS yzk in
let c = connect ad AS in
send c msg

TA

(COMM-A)

of the form assert F in A’s code, where F is the logical in-
terpretation of M (i.e., [M ] = F ), thereby ensuring that the
formula F is indeed derivable at run-time.

and

therefore

the

compiler

says Stud(vkid , cs, grd )

The P-S rule in TC introduces

Example 7. Let us consider
the annotations in Ta-
the for-
ble 8.
in the DKAL
mula vkUni
derivation
inserts
assume vkUni says Stud(vkid , cs, grd ) into the university’s
code. The COMM-J rule in TC models the transmission
of the information vkUni says Stud(vkid , cs, grd ) from the
university to the student. Consequently, the compiler inserts
assert vkUni says Stud(vkid , cs, grd ) into the student’s
code after the signature veriﬁcation, which ensures that
vkUni says Stud(vkid , cs, grd ) is indeed derivable from the
current assumptions at run-time.

For veriﬁcation purposes, F# programs are linked to
a symbolic cryptographic library, comprising functions
for public-key encryption, digital signatures, and zero-
knowledge proofs. This library models the ideal behavior
of cryptographic primitives using standard language con-
structs. We programmed the symbolic zero-knowledge li-
brary making usage of the tool developed by Backes et
al. [11], which takes as input a zero-knowledge statement
and produces methods for the construction and veriﬁca-
tion of the corresponding zero-knowledge proof. For pro-
tocols based on digital signatures and public-key encryp-
tion, safety carries over to programs linked to concrete
cryptographic libraries [15, 36]. Preliminary results for the
computational soundness of symbolic abstractions of zero-
knowledge proofs have been proved in [16]. The sound-

ness of the type system ensures that well-typed programs
are safe.
Theorem 1 (Safety by typing [21]). If ∅ (cid:96) P : U, then P
is safe.

For verifying the security of the F# code that is gener-
ated by our compiler, it is in principle enough to run the
type-checker. This compilation validation approach has the
advantage of smoothly supporting optimizations of the re-
sult of the compilation and of the compiler itself. Never-
theless, we additionally prove that all programs output by
the compiler are well-typed. This security by construction
approach has the advantage of making the type-checking of
the result of the compilation unnecessary, unless the code is
modiﬁed, and gives stronger guarantees about the correct-
ness of the compiler.
Theorem 2 (Soundness of the compilation). For all logical
derivations T ∈ Tdkal, there exists a type U such that ∅ (cid:96)
C[T ] : U.

Our main theorem states that well-typed programs that
use the cryptographic library and the functions produced by
the compiler are safe. In the following, we write IC[T ] to
denote the typed interface of the library produced by the
compiler and P · C[T ] to denote the program obtained by
linking P to such a library.
Theorem 3 (Robust safety of the compilation). If IC[T ] (cid:96)
P : U, then P · C[T ] is robustly safe.

6. Case studies

In this section, we utilize our framework to specify a dis-
tributed reviewing system and a distributed social network.
Given these logical speciﬁcations, the compiler automati-
cally produces the corresponding cryptographic implemen-
tations. The goal is to demonstrate the possibility to specify
relatively complex decentralized systems in a simple and
elegant manner, without requiring any cryptographic exper-
tise on the part of the users.

6.1. Distributed Reviewing System

Current reviewing systems (e.g., Easychair and EDAS)
are designed around a trusted party that serves as custo-
dian of a huge amount of data about the submission and
reviewing behavior of thousands of researchers, aggregated
across multiple conferences. The deliberate or accidental
disclosure of such information is a recognized privacy prob-
lem [51]. In this section, we design a decentralized review-
ing system that offers strong privacy guarantees.

The ﬁrst functionality that a reviewing system should of-
fer is paper assignment. This functionality is realized by

the following protocol (for the sake of readability, we de-
pict the protocol and omit the corresponding knowledge and
communication assertions):

Chair

COMM-J

Chair says RevAssign(id,paper )

The authorization policy for reviews is as follows:

∀xid , yp, zrev .

Chair says RevAssign(xid , yp)
∧ xid says Rev(yp, zrev ) ⇒ Rev(yp, zrev )

id

(11)

Ideally, reviewers should upload the minimal amount of
information required to show that the review was submitted
by an authorized reviewer. This can be achieved as follows:

Chair o

∃xid .

Chair says RevAssign(xid , paper )
∧ xid says Rev(paper , rev )

COMM-A

id

The information transmitted to the PC chair does not reveal
the identity of the reviewer, which may be desirable, for in-
stance, if the paper’s author is a colleague of the PC chair
or the reviewer does not want to reveal her identity to the
whole PC. The long version of this paper reports the com-
plete formalization and describes additional features, such
as the management of rebuttals.

6.2. Distributed Social Network

The users of social networks have to face a surprisingly
vast range of privacy issues. Well-understood problems,
such as the centralized management and sharing of per-
sonal information, are accompanied by novel threats: for
example, the Italian police is reported to have stipulated
agreements with Facebook to get unfettered access to user
proﬁles [35] and, in other countries, people that used so-
cial networks to organize protest activities were subject of
repercussions, censorship, and coercion [34, 50, 1, 55, 28].
We used our framework to design a distributed social net-
work that provides access control and, at the same time, user
anonymity. This social network is close in spirit to the one
that was recently developed by Backes et al. [13]. The cryp-
tographic implementation that we obtain by compilation,
however, is substantially different, being based on pairing-
based zero-knowledge protocols as opposed to traditional
Σ-protocols [30], arguably simpler, and open-ended. Users
may establish social relations as follows:

A

COMM-J

B says FriendReq(A)

A says Friend(B)

COMM-J

B

The predicate B says FriendReq(A) represents a friendship
request from B to A (social relations are unidirectional);
the predicate A says Friend(B ) represents the correspond-
ing friendship conﬁrmation. B can use this information to

/
/
o
o
o
/
/
engage in a number of activities. Suppose, for instance, that
the access to A’s wall is limited to friends: B can anony-
mously post messages on A’s wall by existentially quanti-
fying his identity, as shown below:

COMM-A

B

∃x. A says Friend(x) ∧ x says Wallpost(m)

A o
We additionally provide a method for downloading re-
sources anonymously. Realizing this functionality is chal-
lenging since B does not want to reveal her identity to A,
who has to know, however, to whom to send the response.
We solve this problem by introducing into our framework
the notion of anonymous identiﬁers, which are locally gen-
erated and distributed to other principals, who can then use
them as intended recipients in communication assertions.
Anonymous identiﬁers are cryptographically implemented
by fresh public keys and can be realized at the network layer
via rendezvouz-points [33]. Suppose B is interested in a
picture that can only be seen by A’s friends. Similarly to
the previous protocol, B can prove to be a friend without
revealing his identity and, in addition, give A a fresh anony-
mous identiﬁer B 1, which she can use as intended recipient
in the following communication assertion, as shown below:

A

COMM-J

∃x. A says Friend(x)

∧ x says getResource(B1, pic-id)

COMM-A

B

Resource(pic)

The long version gives a formal account of anonymous
identiﬁers and illustrates other interesting features of the
social network, such as friend-of-a-friend relationships and
pseudonyms.

7. Implementation and Experimental Evalua-

tion

We conducted an experimental evaluation to demonstrate
the feasibility of our approach. This section overviews the
cryptographic setup (§ 7.1) and discusses the experimental
results (§ 7.2).

7.1. Cryptographic Setup

Devising a cryptographic realization for our logical
framework turned out to be quite challenging. The cryp-
tographic scheme has to be efﬁcient and, at the same time,
ﬂexible enough to support the different usages of existential
quantiﬁcation, namely, the hiding of predicate arguments,
principal identities, and equality relations among secret val-
ues (cf. Example 2).

Σ-protocols constitute a particularly efﬁcient and widely
deployed class of zero-knowledge protocols. Existing so-
lutions, however, are not ﬂexible enough to implement ar-
bitrary existential quantiﬁcation: for instance, existentially

quantifying veriﬁcation keys that are both signed and used
to verify signatures (e.g., the key vk id in statement (3)) is
impractically slow [10].

A general solution to this problem was discovered only
recently by Abe et al. [5], who introduced the notion of
automorphic signatures. The distinctive feature of this
signature scheme is that veriﬁcation keys lie in the mes-
sage space. Since messages and signatures consist of ele-
ments of a bilinear group and verication is done by evalu-
ating a set of pairing-product equations, automorphic sig-
natures make a perfect counterpart to the powerful zero-
knowledge proof system by Groth and Sahai [40], which
supports a large class of statements over bilinear groups.
Our cryptographic implementation builds on a combination
of these two cryptographic schemes. An other advantage
of the Groth-Sahai scheme over Σ-protocols is the possibil-
ity (i ) to re-randomize proofs without knowing their wit-
nesses [20] and (ii ) to existentially quantify information in
existing proofs. We exploit the ﬁrst property to hide the
equality relations among secret values, while the second
property is crucial for open-ended applications. We imple-
mented the cryptographic library in Java and we relied on
the jPBC library [31] for the computation of mathematical
operations. A detailed description of our cryptographic im-
plementation is reported in the long version.

7.2. Experimental evaluation

We conducted our experimental evaluation on a standard
notebook with a 2.5 GHz dual-core processor7 and 8 GB of
main memory. We measured the time required to create and
verify various proofs and studied how these are inﬂuenced
by the length of the security parameter, the size of the state-
ment, and the number of existentially quantiﬁed values. In
our experiments, the elliptic curves are such that the key
length equals twice the security parameter [53], e.g., we use
160 bit keys to obtain a security parameter of 80 bits.

As illustrated in Figure 1, time and size grow linearly
in the size of the statement, although increasing the num-
ber of conjuncts (and disjuncts) is more expensive than in-
creasing the number of predicate arguments. The reason lies
buried within the automorphic signature scheme for vectors
of messages. Intuitively, setting up such a vector is compu-
tationally more expensive than ﬁlling it with elements [5].
An exact analysis shows that adding one argument to a pred-
icate costs roughly 5 seconds of proof generation time for a
security parameter of 80 bits, while a zero-knowledge proof
of a statement composed of one predicate with four argu-
ments is computationally as expensive as a zero-knowledge
proof for a statement composed of two predicates with one
argument each.

7The full model description is “Intel Core i5-2520M”

o
o
o
/
/
The graphs in Figure 2, Figure 3, Figure 4, and Figure 5
(cf. Appendix A) depict the results obtained for some of
the proofs illustrated in this paper for various security pa-
rameters. Time and size grow linearly in the length of the
security parameter. The results for a security parameter of
80 bits vary from 31 seconds for anonymously posting mes-
sages on a friend’s wall up to 41 seconds for anonymously
accessing a university lab. The reason for the small time
and size differences is that the zero-knowledge statements
are structurally very similar: they all comprise two signa-
ture veriﬁcations and the number of predicate arguments is
only marginally different.

As previously discussed, existential quantiﬁcation is
very expensive in Σ-protocols [10] and the protocols them-
selves change depending on which and how many values
are existentially quantiﬁed. The Groth-Sahai proof system
combined with our encoding of predicates, instead, allows
for a very efﬁcient and arbitrary existential quantiﬁcation.
As a matter of fact, existential quantiﬁcation comes at no
costs at all in our implementation, as illustrated in Figure 6
(cf. Appendix A). Actually, the more information is exis-
tentially quantiﬁed, the shorter the zero-knowledge proof
is. This is explained by the fact that we implement existen-
tial quantiﬁcation by deleting certain information (speciﬁ-
cally, the opening information for the corresponding com-
mitment) from the proof and the performed computations
are always the same.

We remark that our proof-of-concept implementation is
not optimized in any way. In particular, we do not yet ex-
ploit readily available optimizations such as the multi-core
architecture of today’s processors and batch veriﬁcation
techniques [24]. As the computations are largely indepen-
dent, multi-core architectures yields a great performance
gain. Batch veriﬁcation techniques signiﬁcantly speed up
the veriﬁcation process; the veriﬁcation performance gains
can be well above 50% [24]. We are working on the inte-
gration of such optimizations in our implementation.

8. Conclusion and Future Work

Ensuring the privacy of sensitive data is crucial for the
widespread deployment of authorization infrastructures. In
this paper, we show how to enforce privacy-aware eviden-
tial authorization using a powerful and efﬁcient combina-
tion of digital signatures and zero-knowledge proofs. We
developed a high-level declarative language that lets the
user conveniently specify the system and the desired secu-
rity properties, and a compiler that automatically produces
executable cryptographic implementations. Although we
studied the theoretical properties of our framework in the
context of Evidential DKAL, our cryptographic construc-
tion is language-independent and generally applicable: in
the long version, we report on a privacy-oriented extension

of the Proof Carrying Authorization framework [8, 18] and
we envision the usage of our framework in several other
authorization languages, such as Aura [43], PCML5 [9],
F∗ [52], and SecPal [19].

We are currently implementing our framework on top
of JXTA and JGroups, two open-source development plat-
forms for distributed systems. These platforms provide
high-level communication primitives that conceal the net-
work layer and allow the designer to focus on the functional
behavior of the system; our framework provides security-
oriented data abstractions that hide the cryptographic layer
as well.

We have formally proved that the implementations pro-
duced by the compiler enforce the intended authoriza-
tion policies. Local privacy properties expressed via exis-
tential quantiﬁcation are directly guaranteed by the zero-
knowledge property of the employed proofs. Global pri-
vacy properties, such as strong secrecy and anonymity, are
harder to enforce by construction, since they are not closed
by composition and depend on the system as a whole. They
can, however, be veriﬁed directly on the protocols produced
by the compiler using off-the-shelf cryptographic protocol
veriﬁers (e.g., ProVerif [23]). As a future work, it would be
interesting to develop techniques to quantitatively measure
global privacy properties (e.g., in terms of information ﬂow,
k-anonymity, etc.).

Finally, we intend to extend our framework in a number
of directions. For example, we would like to develop prim-
itives to share and process distributed data structures, yet
preserving the privacy of sensitive information; this could
be achieved by a combination of homomorphic encryptions
and secure multiparty computations. It would also be inter-
esting to offer support for other security properties, such as
linear authorization policies [25] and trust properties [27].
Acknowledgments
This work was partially supported by the initiative for excel-
lence and the Emmy Noether program of the German fed-
eral government.

References

[1] C. Abadi.

Foreign Policy,

2010.

Iran, Facebook, and the Limits of On-
http:

line Activism.
//www.foreignpolicy.com/articles/2010/
02/12/irans_failed_facebook_revolution.

[2] M. Abadi. Access Control in a Core Calculus of Depen-

dency. SIGPLAN Notices, 41:263–273, 2006.

[3] M. Abadi, A. Banerjee, N. Heintze, and J. G. Riecke. A
Core Calculus of Dependency. In Proc. Symposium on Prin-
ciples of Programming Languages (POPL’99), pages 147–
160. ACM Press, 1999.

[4] M. Abadi, M. Burrows, B. Lampson, and G. Plotkin. A
Calculus for Access Control in Distributed Systems. ACM

Transactions on Programming Languages and Systems,
15:706–734, September 1993.

[5] M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and
M. Ohkubo. Structure-Preserving Signatures and Commit-
ments to Group Elements. In Proc. Advances in Cryptology
(CRYPTO’10), volume 6223 of Lecture Notes in Computer
Science, pages 209–236. Springer-Verlag, 2010.

[6] J. B. Almeida, E. Bangerter, M. Barbosa, S. Krenn, A.-
R. Sadeghi, and T. Schneider. A Certifying Compiler for
Zero-Knowledge Proofs of Knowledge Based on Sigma-
Protocols. In ESORICS’10, pages 151–167, 2010.

[7] M. M. Andreas Blass, Yuri Gurevich and I. Neeman. Evi-
dential Authorization. The Future of Software Engineering,
pages 77–99, 2011.

[8] A. W. Appel and E. W. Felten. Proof-Carrying Authenti-
cation. In Proc. ACM Conference on Computer and Com-
munications Security (CCS’99), pages 52–62. ACM Press,
1999.

[9] K. Avijit, A. Datta, and R. Harper. Distributed Programming
In Proc. ACM SIGPLAN
with Distributed Authorization.
workshop on Types in language design and implementation
(TLDI’10), pages 27–38. ACM Press, 2010.

[10] M. Backes, S. Lorenz, M. Maffei, and K. Pecina. Anony-
In Proc. Privacy Enhancing Tech-
mous Webs of Trust.
nologies Symposium (PETS’10), volume 6205 of Lecture
Notes in Computer Science, pages 130–148. Springer-
Verlag, 2010.

[11] M. Backes, M. Maffei, and C. Hrit¸cu. Union and In-
tersection Types for Secure Protocol Implementations.
In
Proc. Conference on Theory of Security and Applications
(TOSCA’11), Lecture Notes in Computer Science. Springer-
Verlag, 2011.

[12] M. Backes, M. Maffei, and K. Pecina. Automated Synthesis
of Secure Distributed Application. Long version available at
http://lbs.cs.uni-saarland.de/asosda.

[13] M. Backes, M. Maffei, and K. Pecina. A Security API for
In Proc. Network and Dis-

Distributed Social Networks.
tributed System Security Symposium (NDSS’11), 2011.

[14] M. Backes, M. Maffei, K. Pecina, and R. M. Reischuk.
G2C: Cryptographic Protocols from Goal-Driven Speciﬁca-
tions. In Proc. Conference on Theory of Security and Appli-
cations (TOSCA’11), Lecture Notes in Computer Science,
Saarbr¨ucken, Germany, 2011. Springer-Verlag.

[15] M. Backes, M. Maffei, and D. Unruh. Computationally
Sound Veriﬁcation of Source Code. In CCS ’10, pages 387–
398. ACM, 2010.

[16] M. Backes and D. Unruh. Computational Soundness of
Symbolic Zero-Knowledge Proofs Against Active Attack-
ers. In CSF’08, pages 255–269. IEEE, 2008.

[17] L. Bauer, S. Garriss, J. M. McCune, M. K. Reiter, J. Rouse,
and P. Rutenbar. Device-Enabled Authorization in the
In Proc. Information Security Conference
Grey System.
(ISC’05), Lecture Notes in Computer Science, pages 431–
445. Springer-Verlag, 2005.

[18] L. Bauer, M. Schneider, E. Felten, and A. Appel. Access
Control on the Web Using Proof-Carrying Authorization. In
Proc. DARPA Conference on Information Survivability Con-
ference and Exposition (DISCEX’03), volume 2, pages 117–
119, 2003.

[19] M. Y. Becker, C. Fournet, and A. D. Gordon. Design and
Semantics of a Decentralized Authorization Language.
In
Proc. IEEE Symposium on Computer Security Foundations
(CSF’07), pages 3–15. IEEE Computer Society Press, 2007.
[20] M. Belenkiy, J. Camenisch, M. Chase, M. Kohlweiss,
A. Lysyanskaya, and H. Shacham. Randomizable Proofs and
Delegatable Anonymous Credentials. In Proc. Advances in
Cryptology (CRYPTO’09), volume 5677 of Lecture Notes in
Computer Science, pages 108–125. Springer-Verlag, 2009.
[21] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Maffeis. Reﬁnement Types for Secure Implementations.
In Proc. IEEE Symposium on Computer Security Founda-
tions (CSF’08), pages 17–32, 2008.

[22] K. Bhargavan, C. Fournet, and A. Gordon. Modular Veriﬁ-
cation of Security Protocol Code by Typing. ACM SIGPLAN
Notices, 45(1):445–456, 2010.

[23] B. Blanchet, M. Abadi, and C. Fournet. Automated Ceriﬁca-
tion of Selected Equivalences for Security Protocols. Jour-
nal of Logic and Algebraic Programming, 75(1):3–51, 2008.
[24] O. Blazy, G. Fuchsbauer, M. Izabach`ene, A. Jambert,
H. Sibert, and D. Vergnaud. Batch Groth-Sahai. In Proc.
International Conference on Applied Cryptography and Net-
work Security (ACNS’10), volume 6123 of Lecture Notes in
Computer Science, pages 218–235. Springer-Verlag, 2010.
[25] K. D. Bowers, L. Bauer, D. Garg, F. Pfenning, and M. K.
Reiter. Consumable Credentials in Linear-Logic-Based
Access-Control Systems. In Proc. Network and Distributed
System Security Symposium (NDSS’07). Internet Society,
2007.

[26] E. Brickell, J. Camenisch, and L. Chen. Direct Anonymous
Attestation. In CCS’04, pages 132–145. ACM Press, 2004.
[27] G. Caronni. Walking the Web of Trust. In Proc. IEEE In-
ternational Workshops on Enabling Technologies: Infras-
tructure for Collaborative Enterprises (WETICE’00), pages
153–158. IEEE Computer Society Press, 2000.

[28] H. Carter. England Riots: Pair Jailed for Four Years for Us-
ing Facebook to Incite Disorder. Guardian, 2011. http:
//www.guardian.co.uk/uk/2011/aug/16/
uk-riots-four-years-disorder-facebook.

[29] A. Chaudhuri and D. Garg.

PCAL: Language Support
for Proof-Carrying Authorization Systems. In Proc. Euro-
pean Symposium on Research in Computer Security (ES-
ORICS’09), Lecture Notes in Computer Science, pages 184–
199. Springer-Verlag, 2009.

[30] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of
Partial Knowledge and Simpliﬁed Design of Witness Hiding
Protocols. In Proc. Advances in Cryptology (CRYPTO’94),
volume 839 of Lecture Notes in Computer Science, pages
174–187. Springer-Verlag, 1994.

[31] A. De Caro.

jPBC Library. http://libeccio.dia.

unisa.it/projects/jpbc/download.html.

[32] J. DeTreville. Binder, a Logic-Based Security Language.
In Proc. IEEE Symposium on Security & Privacy (S&P’02),
pages 105–113. IEEE Computer Society Press, 2002.

[33] R. Dingledine, N. Mathewson, and P. F. Syverson. Tor: The
Second-Generation Onion Router. In Proc. USENIX Secu-
rity Symposium (USENIX’04), pages 303–320. USENIX As-
sociation, 2004.

[50] E. Morozov.

Foreign Policy:

National Public Radio,
Facebook Police.
http://www.npr.org/templates/story/
story.php?storyId=106535773.

Iran’s Terrifying
2009.

[51] M. D. Ryan. Cloud computing privacy concerns on our

doorstep. Communications of the ACM, 54:36–38, 2011.

[52] N. Swamy, J. Chen, C. Fournet, K. Bharagavan, and J. Yang.
Security Programming with Reﬁnement Types and Mobile
Proofs. Technical Report MSR-TR-2010-149, Microsoft
Research, 2010.
[53] The National

and Technol-
Recommendataion for Key Management –
ogy.
NIST SP, 800–57, 2011.
Part 1: General (Revised).
http://csrc.nist.gov/groups/ST/toolkit/
key_management.html.

Institute of Standards

[54] J. A. Vaughan. A Conﬁdentiality Extension to the Aura Pro-
In Proc. ACM SIGPLAN workshop
gramming Language.
on Types in language design and implementation (TLDI’11).
ACM Press, 2011.

[55] D. Wolman.

Cairo Activists Use

to Rattle Regime.
http://www.wired.com/techbiz/startups/
magazine/16-11/ff_facebookegypt.

WIRED Magazine,

Facebook
2008.

[34] F. Fassihi.

Iranian Crackdown Goes Global. The Wall
http://online.wsj.com/

Street Journal, 2009.
article/SB125978649644673331.html.

La Polizia

[35] G. Florian.
L’Espresso,
repubblica.it/dettaglio/<div>
la-polizia-ci-spia-su-facebook<div>
/2137277.

su Facebook.
http://espresso.

ci Spia

2010.

[36] C. Fournet. Cryptographic Soundness for Program Veriﬁca-

tion by Typechecking. Unpublished draft, 2011.

[37] K. Frikken, M. Atallah, and J. Li. Attribute-Based Access
Control with Hidden Policies and Hidden Credentials. IEEE
Transactions on Computers, 55(10):1259 –1270, 2006.

[38] D. Garg and F. Pfenning. A Proof-Carrying File System.
In Proc. IEEE Symposium on Security & Privacy (S&P’10),
pages 349–364. IEEE Computer Society Press, 2010.

[39] O. Goldreich, S. Micali, and A. Wigderson. Proofs that yield
nothing but their validity or all languages in NP have zero-
knowledge proof systems. JACM, 38(3):690–728, 1991.

[40] J. Groth and A. Sahai. Efﬁcient Non-interactive Proof Sys-
tems for Bilinear Groups. In Proc. Advances in Cryptology
(EUROCRYPT’08), volume 4965 of Lecture Notes in Com-
puter Science, pages 415–432. Springer-Verlag, 2008.

[41] Y. Gurevich and I. Neeman. DKAL: Distributed-Knowledge

Authorization Language. In CSF’08. IEEE, 2008.

[42] Y. Gurevich and I. Neeman. DKAL 2 – A Simpliﬁed and Im-
proved Authorization Language. Microsoft Research Tech-
nical Report, 2009.

[43] L. Jia, J. A. Vaughan, K. Mazurak, J. Zhao, L. Zarko,
J. Schorr, and S. Zdancewic. AURA: A Programming Lan-
guage for Authorization and Audit. ACM SIGPLAN Notices,
43(9):27–38, 2008.

[44] B. Lampson, M. Abadi, M. Burrows, and E. Wobber.
Authentication in Distributed Systems: Theory and Prac-
tice. ACM Transactions on Computer Systems, 10:265–310,
November 1992.

[45] J. Li, N. Li, and W. H. Winsborough. Automated trust ne-
gotiation using cryptographic credentials. In Proceedings of
the 12th ACM conference on Computer and communications
security, CCS’05, pages 46–57. ACM Press, 2005.

[46] N. Li, J. C. Mitchell, and W. H. Winsborough. Design of a
Role-Based Trust-Management Framework. In Proc. IEEE
Symposium on Security & Privacy (S&P’02), pages 114–
130. IEEE, 2002.

[47] L. Lu, J. Han, Y. Liu, L. Hu, J.-P. Huai, L. Ni, and J. Ma.
Pseudo Trust: Zero-Knowledge Authentication in Anony-
mous P2Ps. IEEE Trans. on Parallel Distributed Systems,
19(10):1325–1337, 2008.

[48] M. Maffei and K. Pecina. Position Paper: Privacy-Aware
In Proc. ACM SIGPLAN
Proof-Carrying Authorization.
Workshop on Programming Languages and Analysis for Se-
curity (PLAS’11), 2011.

[49] S. Meiklejohn, C. C. Erway, A. K¨upc¸ ¨u, T. Hinkle, and
A. Lysyanskaya. ZKPDL: A Language-Based System for
Efﬁcient Zero-Knowledge Proofs and Electronic Cash.
In
Proc. USENIX Security Symposium (USENIX’10), pages
193–206, 2010.

A. Experimental results

s
n
i

e
m

i
t
n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

80

60

40

20

0

n conjuncted 1-argument predicates

One predicate with n arguments

150

100

50

s
n
i

e
m

i
t

n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

300

200

100

B
k
n
i

e
z
i
s

f
o
o
r
P

1

2

3

4

0

1

n

2

3

4

n

0

1

2

3

4

n

Figure 1. Comparison of the experimental evaluation of zero-knowledge proofs for predicates with
various argument lengths against the conjunction of zero-knowledge proofs for predicates with only
one argument. The security parameter is ﬁxed to 80 bits.

s

n
i

e
m

i
t

n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

400

300

200

100

800

600

400

200

s

n
i

e
m

i
t
n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

0

80

128
Security parameter

256

0

80

128
Security parameter

256

B
k
n
i

e
z
i
s

f
o
o
r
P

500

400

300

200

100

0

80

128
Security parameter

256

Figure 2. Experimental evaluation on the zero-knowledge proof corresponding to formula (3) (a com-
puter science student requesting access to a lab) for various security parameters.

400

300

200

100

s

n
i

e
m

i
t

n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

800

600

400

200

s

n
i

e
m

i
t

n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

0

80

128
Security parameter

256

0

80

128
Security parameter

256

B
k
n
i

e
z
i
s

f
o
o
r
P

500

400

300

200

100

0

80

128
Security parameter

256

Figure 3. Experimental evaluation on the zero-knowledge proof sent by the reviewer in the example
in § 6.1 for various security parameters.

300

200

100

s
n
i

e
m

i
t
n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

600

400

200

s
n
i

e
m

i
t

n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

400

300

200

100

B
k
n
i

e
z
i
s

f
o
o
r
P

0

80

128
Security parameter

256

0

80

128
Security parameter

256

0

80

128
Security parameter

256

Figure 4. Experimental evaluation on the zero-knowledge proof for posting a message on a friend’s
wall from § 6.2 for various security parameters.

400

300

200

100

s

n
i

e
m

i
t

n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

600

400

200

s
n
i

e
m

i
t

n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

B
k
n
i

e
z
i
s

f
o
o
r
P

400

300

200

100

0

80

128
Security parameter

256

0

80

128
Security parameter

256

0

80

128
Security parameter

256

Figure 5. Experimental evaluation on the zero-knowledge proof for retrieving a resource from a friend
from § 6.2 for various security parameters.

s

n
i

e
m

i
t
n
o
i
t
a
r
e
n
e
g

f
o
o
r
P

80

60

40

20

0

s

n
i

e
m

i
t

n
o
i
t
a
c
ﬁ

i
r
e
v

f
o
o
r
P

80

60

40

20

0

0

1

2

3

4

5

# of existentially quantiﬁed names

0

1

2

3

4

5

# of existentially quantiﬁed names

B
k

n
i

e
z
i
s

f
o
o
r
P

180

179.5

179

178.5

178

177.5

0

1

2

3

4

5

# of existentially quantiﬁed names

Figure 6. Experimental evaluation on the computational and spacial impact of existential quantiﬁca-
tion for a predicate with 5 arguments and ﬁxed security parameter of 80 bits.

