Twice the Bits, Twice the Trouble:

Vulnerabilities Induced by Migrating to 64-Bit Platforms

Christian Wressnegger, Fabian Yamaguchi, Alwin Maier, and Konrad Rieck

Institute of System Security

TU Braunschweig

Abstract
Subtle ﬂaws in integer computations are a prime source for
exploitable vulnerabilities in system code. Unfortunately,
even code shown to be secure on one platform can be vul-
nerable on another, making the migration of code a notable
security challenge. In this paper, we provide the ﬁrst study
on how code that works as expected on 32-bit platforms can
become vulnerable on 64-bit platforms. To this end, we sys-
tematically review the eﬀects of data model changes between
platforms. We ﬁnd that the larger width of integer types
and the increased amount of addressable memory introduce
previously non-existent vulnerabilities that often lie dormant
in program code. We empirically evaluate the prevalence
of these ﬂaws on the source code of Debian stable (“Jessie”)
and 200 popular open-source projects hosted on GitHub.
Moreover, we discuss 64-bit migration vulnerabilities that
have been discovered as part of our study, including vulnera-
bilities in Chromium, the Boost C++ Libraries, libarchive,
the Linux Kernel, and zlib.

Keywords
Software security; Data models; Integer-based vulnerabilities

1.

INTRODUCTION

64-bit CPU architectures have become the main platform
for server and desktop systems. While 64-bit computing has
been used in research systems for almost four decades, it
took until 2003 for the underlying architectures to reach the
mass market. Since then, all major operating systems have
been ported to support 64-bit architectures, including Linux,
Windows and OS X. Software running on these systems
beneﬁts from a huge address space that enables operating
with Gigabytes of memory and provides the basis for memory-
demanding computations.

The migration of software from one to another platform
may seem like a straight-forward task and, after over 10
years, one might expect that technical obstacles introduced
by 64-bit data models have long been resolved. However,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978403

this migration is far more involved than it seems, as it in-
duces several subtle diﬀerences in the resulting code. For
example, the LP64 data model seemingly aﬀects a few in-
teger types only, yet these changes unleash an avalanche
of new type aliases (typedef) and signedness issues, which
developers and even security experts are not aware of. As a
result, 64-bit issues are rather the rule than the exception in
migrated code and there exist several examples of vulnerabil-
ities solely induced by migration, such as CVE-2005-1513 in
qmail, CVE-2007-1884 in PHP, CVE-2013-0211 in libarchive
and CVE-2014-9495 in libpng.

In this paper, we provide the ﬁrst systematic study of these
64-bit migration vulnerabilities. To this end, we analyze com-
mon 64-bit data models for C/C++ and identify insecure
programming patterns, when porting code from 32-bit archi-
tectures. We determine two interdependent sources for such
vulnerabilities: (a) the changed integer widths and (b) the
very large address space that allows to allocate massive
amounts of memory. For each of these sources, we analyze
the underlying root causes and pinpoint necessary condi-
tions for their occurrence, thereby providing insights into
migration vulnerabilities as well as a reference for developers.
Although there exists a large body of work on integer-based
ﬂaws [e.g., 2, 6, 9, 24, 30, 34, 42, 43, 45], to the best of our
knowledge, this is the ﬁrst study that investigates vulnera-
bilities induced only by 64-bit migration.

To assess the presence of migration ﬂaws in practice, we
conduct an empirical analysis and search for 64-bit issues
in the source code of 200 GitHub projects and all packages
from Debian stable (“Jessie”) marked as Required, Important
or Standard. We ﬁnd that integer truncations and signedness
issues induced by 64-bit migration are abundant in both
datasets. For example, the unsigned type size_t alone, which
has a width of 64 bit under LP64, is truncated to 32-bit types
in 78% of all Debian packages. Although the vast majority
of these issues are not necessarily vulnerabilities, the sheer
amount indicates that developers are unaware of the subtle
changes resulting from migrating code to LP64.

Finally, we exemplify the security risk of 64-bit migration
by presenting case studies on vulnerabilities that have been
discovered as part of our study. For each of the identiﬁed
classes of 64-bit issues, we present a corresponding vulnera-
bility in a high-quality software project, including Google’s
Chromium, the GNU C Library, the Linux Kernel and the
Boost C++ Libraries. Our analysis reveals that migration
vulnerabilities are a widespread problem that is technically
diﬃcult to solve and requires signiﬁcant attention during
software development and auditing.

541Let us, as one example of a real vulnerability, consider the
following simpliﬁed excerpt of a ﬂaw discovered during our
study in zlib version 1.2.8 (see Section 5 for more details):

1

2

3

int len = attacker_controlled();
char *buffer = malloc((unsigned) len);
memcpy(buffer, src, len);

This code is perfectly secure on all 32-bit platforms, as
the variable len is implicitly cast to size_t in line 2 and 3
when passed to malloc and memcpy. However, if the code is
compiled using the LP64 data model, line 2 and 3 produce
diﬀerent results, where a 64-bit sign extension is performed
in line 3. An attacker controlling the variable len can thus
overﬂow the buﬀer by providing a negative number. For
instance, −1 is converted to 0x00000000ffffffff in line 2 and
0xffffffffffffffff in line 3, resulting in a buﬀer overﬂow.

In summary we make the following contributions:
• 64-bit migration vulnerabilities. We systemati-
cally study and deﬁne vulnerabilities induced by mi-
grating C/C++ program code to 64-bit data models.
• Empirical study. We present an extensive study that
highlights the prevalence of 64-bit issues in mature,
well-tested software such as Debian stable.

• Practical case-studies. We discuss 64-bit vulnera-
bilities, discovered by us based on this systemization, in
high-quality software for all presented classes of ﬂaws.

The rest of this paper is organized as follows: We review
integer-related issues in Section 2 and systematically deﬁne
64-bit migration vulnerabilities in Section 3. An empirical
study and case studies on these vulnerabilities are then pre-
sented in Section 4 and Section 5, respectively. We discuss
countermeasures in Section 6 and related work in Section 7.
Section 8 concludes the paper.

2. SECURITY OF INTEGER TYPES

Many software vulnerabilities are rooted in subtleties of
correctly processing integers, in particular, if these integers
determine the size of memory buﬀers or locations in mem-
ory. Leveraging these ﬂaws, an attacker can trigger buﬀer
overﬂows, write to selected memory locations or even exe-
cute arbitrary code. In this section we provide background
information on the security of integers in C/C++ and focus
on the eﬀect the data model has on the existence of vul-
nerabilities. We begin by providing information on integers
(Section 2.1), and continue to discuss the most prominent
data models implementing them. Finally, we describe the
resulting common classes of integer-related vulnerabilities
(Section 2.3).
2.1

Integer Types in C

Conversions between integer types provide the basis for
integer-related vulnerabilities, in particular, for those that
result when porting code to 64-bit architectures. The C stan-
dard deﬁnes ﬁve base types for these integers, namely, char,
short, int, long, and long long [18, Sec. 6.2.5].

Each of these integer types exists in two variants: an un-
signed type to store positive numbers and a corresponding
signed type that can also hold negative numbers. Moreover,
each type is associated with a unique natural number known

as its conversion rank. While the C standard does not explic-
itly deﬁne these ranks, it speciﬁes an ordering among them.
Consequently, we deﬁne the following platform-independent
properties for each integer type T :

• Signedness. We denote the signedness of an integer
type T by S(T ) ∈ {0, 1}, where S(T ) = 0 corresponds
to unsigned and S(T ) = 1 to signed types.

• Conversion rank. We denote the rank of an integer
type T by R(T ) ∈ N, where R(char) < R(short) <
R(int) < R(long) < R(long long).

The conversion rank orders integers by size, but does not
specify the exact number of bits occupied by the diﬀerent
types. This gap is ﬁlled by the platform-dependent data
model, which associates each type T with a concrete width
W (T ) ∈ {1, 2, 4, 8}. Just like the rank, the width of the
signed and unsigned versions of a basic data type are required
to be equal. In combination with the integer’s signedness,
the width of an integer speciﬁes the range I of numbers that
it can represent:

(cid:40)

I(T ) =

[0, 28·W (T ) − 1]
if S(T ) = 0
[−28·W (T )−1, 28·W (T )−1 − 1] otherwise

Identifying sources of vulnerabilities as code is ported to
a 64-bit data model ultimately requires the integer width
to be taken into account. However, it should be noted that
the width of a data type with lower rank must always be
lower or equal to that of types with higher rank. That
is, for any two types T1 and T2 with R(T1) < R(T1) holds
W (T1) ≤ W (T2). This observation is of great value for
systematically identifying problems when code is ported to
64-bit platforms (Section 3).
2.2 Data Models

A data model deﬁnes the width of integer types for a
speciﬁc platform. Table 1 provides an overview of common
data models used in the present and past [40], exemplary
operating systems using them, as well as the number of bytes
assigned to each type. For all models, the width of pointers
and the size_t type correspond to the architectures’ register
size, e.g., IP16 and LLP64 specify the size of pointers as
2 byte and 8 byte, respectively.

The motivation behind the diﬀerent deﬁnitions of basic
integer types lies in preserving their relations as good as
possible when migrating code between data models. Due
to our focus on the transition from 32 bit to 64-bit, ILP32
serves as a reference point in this paper, as it is used on
most 32-bit architectures. That is, we assume that a given
program works as intended for ILP32 and focus on diﬀerences
when compiling the same program using a 64-bit data model.
If we compare ILP32 to LLP64 and LP64, as used by
64-bit Windows and most 64-bit Unix systems, respectively,
we see that the type int is 32-bit wide for all three data
models. While for ILP32 this means that int and pointers
have the same width, on the 64-bit data models int is only
half as wide as the pointer type. The same holds true for
the type long on LLP64. As a consequence, on both 64-bit
data models an int variable can no longer be used to address
the full range of memory. While there also exist other 64-bit
data models, such as ILP64 and SILP64, these are only used
on few platforms and, moreover, use the same width for
int, long and pointers, which renders migrating code less
problematic.

542data model

IP16

IP16L32

LP32

ILP32

data type

(PDP-11 Unix)

(Win16)

(Win32, Linux)

LLP64
(Win64)

LP64
(Linux)

ILP64
(HAL)

SILP64

(UNICOS)

pointer/size_t

short
int
long
long long

2
-
2
-
-

2
2
2
4
-

4
2
2
4
8

4
2
4
4
8

8
2
4
4
8

8
2
4
8
8

8
2
8
8
8

8
8
8
8
8

Table 1: Widths of basic integer types in bytes for diﬀerent data models and operating systems [21, 27].

2.3 Integer-Related Vulnerabilities

Several vulnerabilities are rooted in subtle ﬂaws as inte-
gers are processed to calculate the size of buﬀers, oﬀsets
in memory, or amounts of memory to copy from one lo-
cation to another [see 9, 20]. Three common sources for
these integer-related vulnerabilities exist: truncations, under-
ﬂows/overﬂows, and signedness issues [6]. In the following,
we illustrate each of these ﬂaws by example where we assume
an ILP32, LP64, or LLP64 data model. Moreover, we provide
working deﬁnitions for each type of ﬂaw, which we make use
of in the rest of the paper.
2.3.1 Integer Truncations
For an arbitrary assignment x = e, where x is a variable
of type (cid:104)x(cid:105), and e is an expression of type (cid:104)e(cid:105), a truncation
occurs when W ((cid:104)x(cid:105)) < W ((cid:104)e(cid:105)), that is, the width of the
target variable x is smaller than that of the expression e it
is asked to store. Neither rank nor signedness of the integers
tell us whether a truncation occurs. Instead, the existence
of truncations is entirely dependent on the width of integers,
and therefore, on the data model. However, we know that the
width of (cid:104)x(cid:105) can only be smaller than that of (cid:104)e(cid:105), if the rank
R((cid:104)x(cid:105)) is smaller than the rank R((cid:104)e(cid:105)) and therefore, we can
focus on these cases when examining possible truncations. It
is important to note that x may be an implicit variable not
directly visible in the code, for instance, when e is directly
assigned to a function parameter or used in a condition.

1

2

3

4

unsigned int x = attacker_controlled();
unsigned short y = x;
char *buffer = malloc(y);
memcpy(buffer, src, x);

Figure 1: Integer truncation → buﬀer overﬂow.

Figure 1 shows an example of an integer truncation that
leads to a buﬀer overﬂow. An attacker-controlled value
is read and stored in the integer x of type unsigned int
(line 1). Subsequently, x is assigned to the variable y of type
unsigned short (line 2). Finally, a buﬀer of size y is allocated
(line 3), and x bytes are copied into this buﬀer (line 4). The
problem with this code is that for all three data models,
integers of type int are wider than integers of type short,
and therefore, the value of x is truncated before it is assigned
to y by discarding leading bits until the width of y is met. In
eﬀect, if the attacker chooses a suﬃciently large integer, e.g.,
x = 0xffffffff, the amount of data copied into the buﬀer is
larger than its allocated size 0x0000ffff.
2.3.2 Integer Overﬂows
For an arbitrary expression e1 ◦ e2, an integer overﬂow
or underﬂow occurs if the result obtained by evaluating the

expression e1◦e2 does not fall into the range I((cid:104)e1 ◦ e2(cid:105)). The
existence of overﬂows therefore depends on the arithmetic
operation ◦ as well as all the results obtained by evaluating
the sub-expressions e1 and e2.

1

2

3

unsigned int x = attacker_controlled();
char *buffer = malloc(x + CONST);
memcpy(buffer, src, x);

Figure 2: Integer overﬂow → buﬀer overﬂow.

Figure 2 illustrates a buﬀer overﬂow that is triggered by
an integer overﬂow. Similar to the previous example, the
attacker controls a variable named x, which is of type un-
signed int. A buﬀer of size x plus a constant is subsequently
allocated, and x bytes are copied into the buﬀer. Unfortu-
nately, the value obtained by adding a constant to x may
be outside the range of the type unsigned int, for instance,
0xffffffff + 0x100. In eﬀect, the addition wraps around,
resulting in a buﬀer size smaller than x, 0x000000ff. A sub-
sequent copy operation then writes 0xffffffff bytes into the
too small buﬀer.
2.3.3
Finally, for an arbitrary assignment x = e, a change in
signedness only occurs when S((cid:104)x(cid:105)) (cid:54)= S((cid:104)e(cid:105)), that is, the
signedness of the variable x and the expression e are diﬀerent
and W ((cid:104)x(cid:105)) ≥ W ((cid:104)e(cid:105)). A change in signedness primarily
depends on the signedness of the variables in e, but also on
whether or not a signed target variable x is able to store all
possible values of the unsigned version of the expression e.
If the target type is narrower than that of the expression,
we are dealing with a truncation. In case S((cid:104)e(cid:105)) = 1 and
W ((cid:104)x(cid:105)) > W ((cid:104)e(cid:105)) additionally a sign-extension occurs, that
is, the most signiﬁcant bit of the narrower type is propagated
to ﬁll the larger width of the target variable.

Integer Signedness Issues

1

2

3

short x = attacker_controlled();
char *buffer = malloc((unsigned short) x);
memcpy(buffer, src, x);

Figure 3: Sign-extension → buﬀer overﬂow.

Figure 3 reconsiders the example given in the introduction,
illustrating a buﬀer overﬂow that is caused by a change of
signedness and a sign-extension due to upcasting to a larger
unsigned type (unsigned short to size_t). The example is
however modiﬁed to work on all three considered platforms.
An attacker controlling the variable x of type short can
overﬂow the buﬀer by providing a negative number, for
instance -1, which is converted to 0x0000ffff in line 2 and
due to a sign extension to 0xffffffff in line 3.

543source type

int

unsigned int

long

dest type

int
unsigned int
long
unsigned long
ssize_t
size_t/pointer
long long

4

E

E E

E

unsigned long
4 (→ 8)

ssize_t

size_t/pointer
4 → 8

long long

8

Table 2: Assignments using basic types on ILP32 (left circle), LLP64 (middle circle) and LP64 (right circle):

(cid:35) denotes no problem, (cid:32) a change in signedness, possibly with sign extension (E) and (cid:32) marks a truncation.

In addition to this common type of vulnerabilities, we con-
sider another integer ﬂaw that has received little attention so
far: For a comparison e1 ∼ e2 of the two expressions e1 and
e2 of type (cid:104)e1(cid:105) and (cid:104)e2(cid:105), an integer signedness issue occurs
when the comparison is signed where it should be unsigned
and an integer from the comparison is converted to an un-
signed type after evaluating the expressions, or vice versa.
Signedness issues of this kind depend on all properties of the
compared types (cid:104)e1(cid:105) and (cid:104)e2(cid:105), that is, sign, rank, and width.

1

2

3

4

5

int x = attacker_controlled();
unsigned short BUF_SIZE = 10;
if(x >= BUF_SIZE)

return;

memcpy(buffer, src, x);

Figure 4: Signed comparison → buﬀer overﬂow.

Figure 4 shows an example of an integer signedness issue
when comparing variables of diﬀerent signedness resulting in
a buﬀer overﬂow. In this example, the attacker-controlled
variable x is of type int, and it is compared to a buﬀer size
stored in a variable of type unsigned short to avoid buﬀer
overﬂows. x bytes are subsequently copied into the buﬀer.
Unfortunately, the comparison is signed, and therefore, if
an attacker chooses a negative number for x, the check is
by-passed, and the negative number is converted into the
unsigned type size_t as it is passed to memcpy as a third
argument.

3. 64-BIT MIGRATION VULNERABILITIES
Integer-related ﬂaws have been studied in great detail in
the past and several methods for analysis, detection and
mitigation have been proposed [e.g., 6, 9, 30, 42, 45]. All of
these approaches, however, consider defects directly created
by the developer, such as incorrect type casts. By contrast,
we focus on ﬂaws that are introduced by migrating code to
a 64-bit data model and are non-existent on the originating
data model. These defects are introduced indirectly and are
hard to spot by the developer without anticipating a later
migration.

In the following, we characterize diﬀerent vulnerabilities
that emerge when compiling code for a 64-bit data model
that securely runs on 32-bit platforms. These vulnerabilities
can be categorized by two generic sources of defects: changes
in the width of integers (Section 3.1) and the larger address
space available on 64-bit systems (Section 3.2). For a speciﬁc
data model M , we denote the width of an integer type T by
WM (T ) and the range by IM (T ).

3.1 Effects of Integer Width Changes

All types of integers available on 32-bit platforms also exist
in 64-bit data models, however, their width may diﬀer (see
Section 2.2). These changes introduce previously non-existent
truncations and sign extensions in assignments. Surprisingly,
the migration to 64 bit may even ﬂip the signedness of
comparisons and render checks for buﬀer overﬂows ineﬀective.
In the following, we discuss each of these problems in detail.
3.1.1 New Truncations
As discussed in Section 2.3, a truncation occurs when an
expression is assigned to a type narrower than that of the ex-
pression itself. Table 2 provides an overview of integer issues
caused by assignments, broken down by basic integer types.
For each of the three prevalent data models, truncations are

marked by a ﬁlled circle ((cid:32)). Particularly noteworthy are

those assignments that behave diﬀerently between ILP32
and LLP64 or LP64, such as conversions from size_t to un-
signed int or long to int. In these cases, new truncations
occur that are speciﬁc to the migration process from 32-bit
to 64-bit data models.

In addition to these simple truncation, the migration of
the data model additionally introduces two vulnerability
patterns related to the handling of pointers.

Incorrect pointer diﬀerences. The length of a memory region
can be determined by subtracting pointers, returning an inte-
ger of type ptrdiff_t, which has the same width as a pointer.
Unfortunately, it is common practice to store such diﬀerences
in a variable of type int. This is unproblematic on all 32-bit
platforms, since WILP32(int) = WILP32(ptrdiff_t), but fatal
on LP64 and LLP64, where WM (int) < WM (ptrdiff_t) for
M ∈ {LP64, LLP64}, which means that the diﬀerence is
truncated to 32 bit and thus may cause loss of information.
Figure 5 shows an exemplary vulnerability of this type.
Compiling the code produces no warnings, yet on 64-bit plat-
forms, line 5 introduces an integer truncation. The example
shows a typical pattern for processing an input string str
line-by-line and determining a line’s length by the diﬀerence
of end and start pointers. If one input line exceeds 4 Gigabyte
in length, the variable len only stores the truncated length
as it is only 32 bit. For instance, if MAX_LINE_SIZE = 100 and
eol - str = 0x1000000ff, len is truncated to 0x000000ff and
ﬁnally triggers a buﬀer overﬂow in line 8.

Unfortunately, vulnerabilities of this type are supported by
the design of standard library functions, such as fgets, fseek
and snprintf, which receive or return size information as
type int and long. The common idiom of using variables of
type int to iterate over buﬀers further adds to this problem
(see Section 3.2.1).

544right operand

int

unsigned int

long

4

left operand

int
unsigned int
long
unsigned long
ssize_t
size_t/pointer
long long

unsigned long
4 (→ 8)

ssize_t

size_t/pointer
4 → 8

long long

8

Table 3: Comparisons using basic integer types on ILP32 (left circle), LLP64 (middle circle) and
LP64 (right circle):

an unsigned comparison.

denotes a signed and

1

2

3

4

5

6

7

8

char buf[MAX_LINE_SIZE];
char *eol = strchr(str, ’\n’);
*eol = ’\0’;

unsigned int len = eol - str;
if(len >= MAX_LINE_SIZE)

return -1;

strcpy(buf, str);

Figure 5: Example of a 64-bit migration vulnerabil-
ity caused by incorrect pointer diﬀerences.

Casting pointers to integers. Closely related are casts from
pointers to integers. While this programming pattern is
generally discouraged, casting pointers to int is unproblem-
atic on all 32-bit platforms, as pointers and integers have
the same size, that is WILP32(int) = WILP32(pointer). In
contrast, on LP64 and LLP64 this practice leads to latent
pointer truncations [see 29] as WM (int) < WM (pointer) for
M ∈ {LP64, LLP64}. These truncations are latent in the
sense that they go unnoticed as long as the pointers refer
to locations within the ﬁrst 4 Gigabyte of the address space.
For these pointers, a truncation does not change their value
as only preceding zeros are removed. Attackers, however,
may purposely increase the amount of memory allocated by
the program to ensure that pointers outside this safe range
are created. Still, these vulnerabilities are rather rare and a
successful exploitation is rendered diﬃcult by address space
layout randomization (ASLR) [5].

3.1.2 New Signedness Issues
Two types of integer signedness issues arise as code is
ported from 32-bit to 64-bit platforms. First, sign extensions
may occur as signed integers are converted to unsigned types
that have become wider than their ILP32 equivalents. Second,
the signedness of comparisons potentially changes, rendering
checks to protect from buﬀer overﬂows ineﬀective.

Sign extensions. When converting from one signed type to
another wider signed type, a sign extension is performed
for value preservation. Converting a signed type to a wider
unsigned type follows the same principle, but the resulting
value is eventually interpreted as unsigned integer. In eﬀect,
negative numbers are converted into large positive numbers,
a possible source for vulnerabilities. The latter case can be
formalized as follows: Let M1 be a 64-bit data model and
M2 be the 32-bit reference data model. For the assignment
x = e, sign extensions with successive unsigned interpretation
is performed in M1, but not in M2 if 0 = S((cid:104)x(cid:105)) (cid:54)= S((cid:104)e(cid:105)) = 1
and WM1 ((cid:104)x(cid:105)) > WM1 ((cid:104)e(cid:105)) = WM2 ((cid:104)x(cid:105)) = WM2 ((cid:104)e(cid:105)).

Table 2 indicates signedness errors in assignments as gray
circles ( ), where sign extensions are additionally marked ( E ).
For the LLP64 data model, new sign extensions occur for
conversions from int and long to size_t and for LP64 from
int to unsigned long and size_t.

From a security perspective, conversions to the size_t type
appear to be especially fruitful when looking for vulnerabili-
ties. The example of the zlib vulnerability presented in the
introduction illustrates this issue in a real-world scenario (see
Section 5 for further details).

Signedness of comparisons. Checks to ensure that a buﬀer
does not overﬂow are only eﬀective if they correctly account
for the signedness of the integers involved. Typically, this
means that all integers should be converted to unsigned types
prior to comparison. In many cases, explicit conversions can
be omitted on 32-bit systems as integer conversion rules
ensure that the comparisons will be performed unsigned.
This, however, is not guaranteed on 64-bit platforms anymore,
bringing forth comparisons that change their signedness when
being ported. Those cases can be formally summarized as
follows: Let M1 be a 64-bit data model and M2 be the
32-bit reference data model. Then, a comparison a ∼ b,
where (without loss of generality) 0 = S((cid:104)a(cid:105)) (cid:54)= S((cid:104)b(cid:105)) = 1
is unsigned in M2, but signed in M1 if R((cid:104)b(cid:105)) > R((cid:104)a(cid:105)) and
max IM2 ((cid:104)a(cid:105)) /∈ IM2 ((cid:104)b(cid:105)) and max IM1 ((cid:104)a(cid:105)) ∈ IM1 ((cid:104)b(cid:105)), that
is signed type (cid:104)b(cid:105) can not hold the maximum value of the
unsigned type (cid:104)a(cid:105).

Table 3 provides an overview of the signedness of com-
parisons for basic integer types and diﬀerent data models.
Unsigned comparisons are marked as ﬁlled circles ( ) while
signed comparisons are indicated by empty circles ( ). Of
particular interest are those cases where the indicators change
between 32-bit and 64-bit data models. For instance, a com-
parison involving long and unsigned int is unsigned on both,
ILP32 and LLP64, but signed on the LP64 data model.

Figure 6 presents a corresponding vulnerability. An attacker-

controlled value is ﬁrst stored in a long integer named len on
line 2, and then checked to ensure it does not exceed the buﬀer
size BUF_SIZE on line 4. Finally, len bytes are copied into
the buﬀer. As in the previous example, compiling this code
produces no warnings. Moreover, the comparison between
len and BUF_SIZE is unsigned on 32-bit data models. This is
the case because long and unsigned int have the same width
and therefore long cannot hold the full range of unsigned int.
Consequently, len gets reinterpreted as unsigned value to con-
duct the comparison. For instance, given len = -1 the com-
parison is performed unsigned as 0xffffffff > 0x00000080.
Although a reinterpretation of the value occurs, the result
still matches the developer’s expectations.

5451

2

3

4

5

6

const unsigned int BUF_SIZE = 128;
long len = attacker_controlled();

if(len > BUF_SIZE)

return;

memcpy(buffer, src, len);

Figure 6: A check to avoid buﬀer overﬂows on 32-bit
systems that is ineﬀective on LP64 platforms.

In contrast, on LP64 the type long is 8 bytes wide, while
an unsigned int is only 4 bytes wide. Therefore, a variable of
type long can hold the full range of an unsigned int, and a
signed comparison is performed. This is problematic, as the
check in line 4 can be bypassed by supplying a negative value,
for instance -1, for len. When copying data on line 6, this
value is sign-extended and interpreted as unsigned integer,
0xffffffffffffffff, resulting in a buﬀer overﬂow.
3.2 Effects of a Larger Address Space

In addition to ﬂaws that result from changes in integer
widths, code running on 64-bit platforms has to be able
to deal with larger amounts of memory as the size of the
address space has increased from 4 Gigabytes to several
hundreds of Terabytes. In eﬀect, the developer can no longer
assume that buﬀers larger than 4 Gigabytes cannot exist
in memory. As a result, additional integer truncations and
overﬂows emerge, which do exist on 32-bit data model in
the ﬁrst place, but cannot be triggered on the corresponding
platforms in practice.
3.2.1 Dormant Integer Overﬂows
A security-relevant integer overﬂow cannot be detected
by reasoning about the types of variables alone. Instead,
the range in which these variables operate also needs to be
considered. A larger address space allows (a) larger objects
to be created and (b) a larger number of objects to be used.
Thus, code that performs arithmetic operations on the sizes
or number of objects with variables narrower than that of
pointers become candidates for integer overﬂows on 64-bit
platforms.

1

2

3

4

5

6

7

unsigned int i;
size_t len = attacker_controlled();
char *buf = malloc(len);

for(i = 0; i < len; i++) {

*buf++ = get_next_byte();

}

Figure 7: Buﬀer overﬂow resulting from an integer
overﬂow due to larger strings on 64-bit platforms.

Figure 7 provides an example of an integer overﬂow result-
ing from large objects, which also does not trigger a compiler
warning. For LP64 and LLP64, the type unsigned int is nar-
rower than size_t, that is, WM (unsigned int) < WM (size_t),
M ∈ {LP64, LLP64}. If the attacker-controlled value len is
larger than UINT_MAX (len > max IM ((cid:104)i(cid:105))), the loop-variable
i can never attain a value greater or equal to len as it would
ﬁrst overﬂow and eventually result in a loop that endlessly
copies data into the buﬀer. Platforms using ILP32, however,
are not aﬀected since len ≤ max IILP32((cid:104)i(cid:105))—in other words,
the loop terminates before i overﬂows.

Vulnerabilities resulting from the large number of objects
are typically tied to reference counters with a type smaller

than the pointer size. We provide examples of previously un-
known vulnerabilities in the Boost C++ Libraries, Chromium
and the GNU Standard C++ from this class in Section 5.
3.2.2 Dormant Signedness Issues
In addition to truncations, signedness issues may also lie
dormant in existing code and become exploitable as the
size of the address space grows. A common occurrence of
such dormant signedness issues is the practice of assigning
the return value of strlen to a variable of type int. For
strings longer than INT_MAX, this results in a negative length.
However, on 32-bit platforms, exploiting this type of ﬂaw is
deemed unrealistic due to the restricted amount of memory
available [20, Chp. 18 pp. 494]. On 64-bit platforms, however,
strings of this size can be easily allocated by a single process,
making it possible to trigger these dormant signedness issues.

1

2

3

4

5

6

char buffer[128];
int len = strlen(attacker_str);

if(len >= 128)

return;

memcpy(buffer, attacker_str , len);

Figure 8: Buﬀer overﬂow caused by the common
pattern of assigning the result of strlen to an int.

Figure 8 shows a corresponding vulnerability. The length
of the attacker-controlled string is determined using strlen
and is assigned to a variable of type int. If the attacker
controlled input is of length l, where max IM ((cid:104)len(cid:105)) < l <
max IM (unsigned int), the return value stored in len is mis-
takenly interpreted as a negative number and consequently
the check in line 4 is rendered ineﬀective. As len is subse-
quently passed to memcpy, it is sign-extended and interpreted
as unsigned int, causing a buﬀer overﬂow in line 6.
3.2.3 Unexpected Behavior of Library Functions
Several standard C library functions have been originally
designed with 32-bit data models in mind and thus become
vulnerable to truncations, overﬂows or signedness issues.
Although some of these functions have been adapted to
64-bit data models, developers are often not aware of the
changed functionality.

String formatting. Functions for printing strings, such as
fprintf, snprintf and vsnprintf have been designed with
the assumption that strings cannot be longer than INT_MAX.
While this assumption is reasonable on 32-bit platforms,
it does not hold true for 64-bit data models. Let us, as
an example, consider snprintf, which writes a string to a
buﬀer s according to a format string fmt.

int snprintf(char *s,

size_t n, const char *fmt, ...)

The function copies at most n bytes and returns the number
of bytes that would have been written. On 64-bit platforms
the expanded format string, however, may be larger than
INT_MAX, making it impossible to return its size as an int. In
this case the C99 standard demands that snprintf returns a
ﬁxed value of −1 [18, Sec. 7.19.6]. In practice, this can result
in vulnerabilities when programmers directly make use of the
return value to shift pointers. Figure 9 exemplarily shows
a vulnerable implementation of a log function that writes
messages to a global buﬀer of BUF_LEN + 1 bytes in size.

546Debian stable

Average per package

Category # packages -Wconversion -Wsign-conversion -Wsign-compare -Wfloat-conversion

Required
Important
Standard

*

53
56
89

198

576 (334)
738 (437)
913 (510)

773 (442)

1009 (216)
976 (269)
993 (279)

993 (259)

18 (2)
33 (1)
28 (1)

27 (1)

5 (1)
10 (0)
3 (1)

5 (1)

Table 4: Number of implicit type conversions per package on 64 bit. The ﬁrst value denotes all warnings
raised, the value in brackets the amount that is exclusive to 64 bit and that does not occur on 32-bit systems.

1

2

3

4

5

6

7

8

9

10

11

12

int pos = 0;
char buf[BUF_LEN +1];

int log(char *str) {

int n = snprintf(buf +pos, BUF_LEN -pos, "%s", str);

if(n > BUF_LEN -pos) {

pos = BUF_LEN;
return -1;

}
return (pos += n);

}

Figure 9: Stack-corruption vulnerability on 64-bit
systems due to unexpected behavior of snprintf.

1

2

3

4

5

6

7

8

9

10

11

12

int i;
char *buf;

FILE* const f = fopen(filename, "r");
fseek(f, 0, SEEK_END);
const long size = ftell(f);

buf = malloc(size / 2 + 1);

fseek(f, 0, SEEK_SET);
for (; fscanf(f, "%02x", &i) != EOF; buf++)

*buf = i;

Figure 10: Buﬀer overﬂow for ﬁles larger than
UINT_MAX caused by unexpected return value of ftell.
The log function returns −1 once the return value of
snprintf has exceeded the overall size of the buﬀer (line 7–9).
Specifying an input string longer than INT_MAX, which is easily
possible on 64-bit platforms, results in snprintf returning
−1 on line 5—irrespective of the maximal number of bytes
allowed to write. This bypasses the check on line 7 and
subtracts from the index variable pos, causing it to underﬂow.
A subsequent call to log then corrupts the stack memory.

File processing. Similar to the printf family of functions, the
standard C library functions for processing ﬁles, such as ftell,
fseek and fgetpos, are not designed to deal with the eﬀects
of 64-bit integer numbers, in this case, ﬁles larger than 4
Gigabyte. This problem is well known and is addressed by the
introduction of 64-bit aware counterparts, ftello, ftello64
or __ftelli64. However, our empirical study shows that
ftell still is widely used instead of the better alternatives
(Section 4). Furthermore, the function ftell exhibits an
undocumented behavior when confronted with large ﬁles. It
is speciﬁed to return the current position of a ﬁle pointer as
value of type long, which is 32 bit wide on platforms using
the LLP64 data model. While the C99 standard speciﬁes a
return value of −1 for failures [18, Sec. 7.19.3], the Microsoft
Visual C++ Runtime Library’s implementation returns 0 if
the current position exceeds LONG_MAX (0xffffffff), which
gives rise to security problems.

Figure 10 shows an exemplary vulnerability in a piece
of code that reads a ﬁle of hexadecimal values encoded in
textual form (e.g., 30 31 32 ...) and stores it as decoded bytes
in a buﬀer buf. To this end, the code ﬁrst determines the
ﬁle’s size by seeking to its end and obtaining the ﬁle position
using ftell (line 4–6). Finally, the byte values are written
to the buﬀer by iteratively calling fscanf until EOF is reached
(lines 10–12). On Microsoft Windows 64-bit a vulnerability
can be triggered using ﬁles larger than 4 Gigabytes, as the
call to ftell returns zero and only one byte is allocated for
the buﬀer (line 8). In eﬀect, the copy loop corrupts the heap
by writing the complete ﬁle to memory not allocated by the
process.

4. EMPIRICAL STUDY

We proceed to analyze how wide-spread 64-bit migration
issues are in today’s software. To this end, we conduct two
empirical experiments. First, we assess the prevalence of
problematic type conversions in general, considering all im-
plicit conversions that may alter a value during assignments
or in expressions (Section 4.1). Second, based on the obser-
vations made in the previous section we reﬁne our search
and automatically look for programming patterns that are
characteristic for 64-bit migration ﬂaws (Section 4.2).
4.1 Implicit Type Conversions

In this experiment we study how often type conversions
potentially go wrong. To this end, we inspect all 198 source
packages from Debian stable (“Jessie”, release 8.2) tagged
as either Required, Important or Standard and are written
in the C/C++ programming languages. We compile each
package on Debian 32-bit and Debian 64-bit and inspect all
warnings raised.

On request, GCC, LLVM’s clang, and other compilers
emit warnings when an assignment, arithmetic operation or
a comparison is applied to operands of incompatible integer
types and an implicit conversion is required. Frequently,
these compiler ﬂags are however not used due to the sheer
amount of warnings potentially raised in practice [25]. As a
matter of fact, we ﬁnd that none of the 198 Debian packages
uses one of these ﬂags. For our study we hence explicitly
add: -Wconversion for width conversion, -Wsign-conversion
for changes in signedness, -Wsign-compare for comparisons
of signed and unsigned types and -Wfloat-conversion for
conversion that involve a loss in ﬂoating point precision [11].
Table 4 summarizes the results. We list the total count
of warnings of each conversion type raised by the compiler
on the 64-bit system per package and especially highlight
warnings that have emerged from the migration process. We
ﬁnd that the vast majority of warnings are width and sign
conversions with 442 and 259 warnings per package, respec-

547source type

unsigned

signed

Total

destination type

size_t

unsigned long

uintptr_t

ssize_t

long

intptr_t

ptrdiff_t

*

int
unsigned int
int32_t
uint32_t
Total

10,181
10,989
55
302
21,527

4,188
2,857
42
231
7,318

0
0
0
0
0

3,294
91
0
0
3,385

12,114
1,339
32
120
13,605

24
0
0
0
24

6
0
0
0
6

29,807
15,276
129
653
45,865

Table 5: Number of width conversions in Debian stable, critical to the migration of code from ILP32 to LP64.

Code-base

P1: atol

P2: memcpy

P3: loops

P4: strlen

P5a: snprintf P5b: ftell

Debian Jessie
GitHub

21.49% (133)
18.66% (25)

7.76% (2,536)
15.19% (2,918)

8.47% (1,264)
12.56% (658)

13.85% (7,595)
22.54% (3,572)

27.55% (762)
34.79% (502)

64.74% (628)
85.05% (182)

Average

20.98% (158)

10.51% (5,454)

9.53% (1,922)

15.80% (11,167)

30.03% (1,264)

68.41% (810)

Table 6: Number of speciﬁc patterns for 64-bit migration issues in source packages of Debian stable
(“Jessie”, release 8.2) and 200 popular C/C++ projects hosted on GitHub, relative to their absolute usage.

tively. These warnings are exclusive to 64 bit and do not
occur on 32-bit platforms. By contrast, sign comparisons
only slightly increase due to the 64-bit migration. However,
in line with the examples given in Section 3.1.2 migration
vulnerabilities often occur on 64-bit platforms due to com-
parisons that remain signed rather than being implicitly
converted to unsigned. Hence, the amount of warnings per
package resolved in comparison to a 32-bit platform has to
be taken into account as well, such that in total 15% of the
warnings can be considered critical.

Finally, we look at implicit type conversion caused by the
migration process from 32-bit to 64-bit platforms in more de-
tail. Table 5 shows the absolute number of warnings for basic
types that are 4 bytes wide for Debian 32 bit (ILP32), but
are 8 bytes wide one Debian 64 bit (LP64), hence represent-
ing reasonable suspects for 64-bit migration vulnerabilities.
In total we record more than 45,000 warnings of this kind,
suggesting a huge potential for misuse. Especially, the con-
version from size_t to int and vice versa appears to be
problematic in practice, spawning over 21,000 warnings in
core packages of Debian stable.
4.2 Patterns of 64-bit Migration Issues

Of course, not all implicit type conversions indicate a bug
or even a vulnerability. We hence narrow down this vast
amount of suspect locations by speciﬁcally looking for code
patterns that may cause unintended operations on 64-bit
platforms. To this end, we make use of techniques from
control-ﬂow and data-ﬂow analysis to model speciﬁc patterns
of 64-bit migration issues.
In particular, we characterize
patterns from the 5 categories presented in Section 3 on
the basis of practical examples and count the occurrences
of these in two code bases: we again consider the packages
from Debian stable described in the previous section and
additionally examine the 200 (at the time of writing) most
popular C/C++ projects on GitHub.

P1. New truncations. As an example for a truncation that
exclusively happens on 64-bit systems we consider the
faulty use of the standard library function atol. We
count all occurrences of atol and relate these to those
invocations that assign the return value to a variable
of type int rather than long. In Section 5.1 we discuss
a real-world vulnerability based on such a truncation.

P2. New signedness issues. When used in the context of
memory operations, signedness issues may cause severe
security ﬂaws. For this class, we focus on unexpected
sign-extensions in combination with the memory copy
operation memcpy as discussed in Section 3.1.2. We count
all invocations of memcpy that use a signed variable of
type int to specify the amount of data to copy and
compare these to the overall number of calls to memcpy.

P3. Dormant integer overﬂows. Integers may under or over-
ﬂow in various situations. For this pattern we choose a
rather strict scenario, in which a loop is iterating over
code based on 64-bit related data. In particular, we
count for loops that use a loop-variable of type size_t
and relate these to the subset of loop that additionally
increment or decrement a variable of type (unsigned)
int in their loop body.

P4. Dormant signedness issues. For this class, we take up
the example of the incorrect usage of the strlen func-
tion presented earlier. To this end, we count the calls
to strlen that do not use a string literal as parameter
and put these in relation to occurrences that assign the
return value of strlen to (unsigned) int. Left values of
other types are not considered as problematic in this
example and count for the reference quantity.

P5. Unexpected behavior of library functions. Finally, we
inspect two examples of library functions that behave
diﬀerently than a) developers might expect or b) the
C99 standard speciﬁcation. First, we count occurrences
of snprintf that make use of their return value and
put these in relation to occurrences that use the return
value but do not check its validity. Second, we count the
calls to ftell in relation to the absolute usage of ftell*
functions (ftell, ftello, ftell64 and _ftelli64).

The presented patterns do not provide a complete list of
64-bit migration ﬂaws, but should convey a feeling for the
prevalence of such ﬂaws by example. Surprisingly, these
trivial patterns already point out a large number of potential
issues. Table 6 summarizes our ﬁndings. 21% of all calls to
function atol are assigned to a variable of type int instead
of long, causing a truncation on 64-bit systems (P1). Also,
developers frequently pass signed integers of type int to

548function parameters deﬁned as size_t. In case of the memcpy
function and its parameter for specifying the number of bytes
to copy, roughly 10% of the calls are used incorrectly, allowing
for the malicious use of implicit sign-extensions (P2). Our
pattern modeling integer overﬂows induced by simple for
loops reveals that 9.5% increment an int variable although
the loop-counter is speciﬁed as size_t (P3). 15% of all calls
to strlen are falsely assigned to a variable of type int rather
than size_t (P4). Finally, the snprintf and ftell functions
are incorrectly used in 30% and 70% of all cases, respectively
(P5a & P5b).

In summary we observe that projects included in Debian
appear to exhibit less such patterns for 64-bit migration
ﬂaws than the projects retrieved from GitHub—the absolute
number however suggests a signiﬁcant potential for misuse.

5. CASE STUDIES

Finally, we discuss 64-bit migration vulnerabilities from
all categories described in Section 3 in practice. We build
general patterns for the control-ﬂow and data-ﬂow of such
issues, look for these in popular code bases to identify poten-
tially vulnerable program code and manually inspect these.
This eﬀort has resulted in 6 previously unknown vulnerabili-
ties1 in high-quality software such as Chromium, the Linux
kernel and zlib. Additionally, we complement our study with
two vulnerabilities disclosed in the past.

In this context, we highlight the two main sources of 64-bit
migration ﬂaws: 1) changes in integer widths, and 2) the
increased amount of memory available on 64-bit systems.
Table 7 summarizes our ﬁndings with respect to these two
categories.

Case Study

PHP
libarchive
zlib
libarchive
Chromium
GNU C Library
Linux Kernel
Boost C++ Libraries

CVE-2007-1884
CVE-2013-0211
new
new
new
new
new
new

Width Change Mem

×
×
×

×
×
×
×
×
×

Table 7: Vulnerabilities discussed in this section.

5.1 New Truncations

To begin with, we brieﬂy describe two vulnerabilities re-
lated to new truncations caused by the migration from 32 bit
to 64-bit systems. In particular, we examine a vulnerability
from 2007 in PHP as well as a vulnerability in the Linux
Kernel discovered as part of our research.

PHP. Esser [10] describes a vulnerability that allows code
execution in versions of PHP earlier than 4.4.5 and 5.2.1
(CVE-2007-1884). The vulnerability results from an inte-
ger truncation not present on 32-bit systems. While PHP ’s
php_sprintf_getnumber function, a function used by all printf
variants for parsing format strings, returns integers of type
long, its result is stored in variables of type int when pro-
cessing argument numbers, width and precision. On systems
using ILP32 and even LLP64 (Windows) this is not an issue

as both types are of the same width. However, for LP64,
long is eight bytes wide, introducing a truncation that can
be exploited for arbitrary code execution by specifying a
precision of INT_MAX characters.

Linux kernel. The Linux kernel comes with its own imple-
mentation of C standard library functions, e.g., for string
manipulation. In contrast to corresponding implementations
in the GNU C Library, the implementation of the Linux
Kernel version 4.6 and before does not check for overly large
inputs passed to the snprintf function. In particular, the
function subtracts one pointer from another, yielding a value
of type ptrdiff_t, but returns it as 32 bit wide integer. On
64-bit systems ptrdiff_t is 64 bit wide such that the return
value is truncated for large inputs. This matches the example
given in Section 3.1.1 exactly.
5.2 New Signedness Issues

To demonstrate the practicability of signedness issues on
64-bit systems, we again inspect a vulnerability discovered
by us in zlib and one in libarchive reported in 2013. The ﬁrst
involves a sign-extension and the second, a sign-comparison
issue as described in Section 3.1.2.

Sign-extension issue in zlib. This vulnerability resides in
version 1.2.8 of zlib and is triggered by the gzprintf function,
which is used to write a formatted string into a buﬀer, with a
size previously speciﬁed using the library function gzbuffer.
Unfortunately, the function is not ﬁt to process inputs larger
than INT_MAX bytes. While at initialization the target size is
speciﬁed as unsigned int, the gzvprintf function internally
casts this value to int. Later on this value is used as second
parameter to the vsnprintf function which is deﬁned as
size_t and speciﬁes the number of bytes to write into the
buﬀer at most. On LP64 and LLP64, size_t is twice as wide as
int such that a sign extension is performed and the conversion
yields a large unsigned value, allowing to overﬂow the buﬀer.

Sign-comparison issue in libarchive. Yamaguchi [39] discov-
ered a vulnerability in the archive_write_zip_data function
of libarchive version 3.1.2 and below (CVE-2013-0211). This
function is used as a callback for writing zip archives and
receives the destination buﬀer and its size as arguments. Be-
fore data is written, the implementation checks, whether the
speciﬁed buﬀer exceeds the maximum number of bytes that
may be written to the zip archive. In this context, the size is
explicitly casted from size_t to int64_t, a conversion that has
been unproblematic on 32 bit systems (INT64_MAX > SIZE_MAX)
but changes signs on 64 bit platforms as size_t and int64_t
are of the same width. Later on, the UINT_MAX bytes of the
provided input are deﬂated to the output archive, irrespective
of the maximally allowed number of bytes.
5.3 Dormant Integer Overﬂows

We proceed to give examples for integer overﬂows that
already exist on 32-bit data models, but can only be trig-
gered on 64-bit platforms due to the increased size of the
address space. We have discovered vulnerabilities of this
kind in a function of the GNU C Library, the shared pointer
implementations of the Boost C++ Libraries, Chromium,
and the GNU Standard C++ Library.

1All discovered vulnerabilities have responsibly been dis-
closed to the vendors of the aﬀected software projects.

GNU C Library. The wcswidth function as speciﬁed by the
“X/Open Portability Guide” [17] and implemented by version

5492.23 of the GNU C Library contains an integer overﬂow. This
function counts the number of columns needed to represent
a wide-character string. This counter, however, is internally
deﬁned as a variable of type int, in accordance with the
functions return value. As the input string might be larger
than INT_MAX on 64-bit systems, processing the complete
string overﬂows the counter. With a string longer than
UINT_MAX the return value wraps around to a positive number
again, such that using this value for memory allocations
inevitable results in a buﬀer overﬂow.

C++ shared pointers. Shared pointers are containers for
raw pointers that keep track of the ownership of these and
manage the number of references. If all references are de-
stroyed, the last instance takes care of also destroying the
hosted raw pointer. Unfortunately, the implementations as
distributed with version 1.60 of the Boost C++ Libraries
(boost::shared_ptr<T>) as well as those of Chromium version
52.0 and the GNU Standard C++ Libraries that come with
GCC version 6.1.0 suﬀer from a ﬂaw: The reference counter
is implemented as an integer of type int. Consequently, on
64-bit systems, an attacker may create lots of shared pointers
such that the internal counter overﬂows until it contains a
value of 1 again. The next shared pointer that is subsequently
destroyed then also destroys the shared raw pointer, leaving
UINT_MAX instances behind pointing to a freed location. This
results in a use-after-free vulnerability that can be exploited
by attackers for arbitrary code execution.
5.4 Dormant Signedness Issues

Finally we examine a vulnerability we discovered in libarchive

version 3.2.0, which contains a signedness issues that, on a
32-bit system, could not be triggered as of the limited address
space, but are exploitable on 64 bit.

This vulnerability in the processing of iso9660 containers
rests on checks for the maximally allowed length of Joliet
identiﬁers. In the course of these checks, the length of the
name which is stored as size_t is explicitly casted to int,
very much like the example given in Section 3.2.2. It is hence
possible to provide a string just long enough to change the
signedness of the integer to bypass this check. Allocating
as much memory, however, has only become possible with
64-bit systems. libarchive maintains UTF-16 and multi-byte
versions of the names and therefore, allocates at least 3×
more memory as theoretically needed for merely bypassing
the check.

6. DISCUSSION

Ideally, ﬂaws induced by the migration from 32-bit to 64-
bit platforms are addressed by thorough code audits that
speciﬁcally focus on problematic type conversions and related
code patterns. However, more than 10 years after 64-bit pro-
cessors have reached the mass market, we have shown that
vulnerabilities resulting from the migration process still are
a major issue. We thus discuss strategies to cope with this
lasting issue in software security. We diﬀerentiate counter-
measures based on the two root causes of 64-bit migration
vulnerabilities: 1) the vast amount of memory addressable
by a single process and 2) the change in width of integral
integer types and resulting conversion problems.

Memory monitoring. As discussed in Section 3.2, 64-bit mi-
gration ﬂaws are often triggered by large amounts of memory

allocated by a single process. Consequently, such vulnera-
bilities can be coped with by tightly monitoring the usage
of memory. Bernstein, for instance, even argues that the
vulnerabilities in qmail discovered by Guninski [13] are not
relevant at all because “nobody gives gigabytes of memory to
each qmail-smtpd process, so there is no problem with qmail’s
assumption that allocated array lengths ﬁt comfortably into
32 bits” [3]. While this does not hide the fact that qmail is
vulnerable in this particular scenario, there is some truth
to pointing out alternatives to limit a process’ usage of re-
sources such as softlimit from daemontools [4], ulimit [23]
or cgroup [14].

These mechanisms are rather strict with respect to enforc-
ing limitations and refuse to provide more memory or even
kill the process (SIGKILL) if hard limits are reached. The use
of memory warnings, that are raised at runtime whenever
a process uses more than the granted amount of memory
might be an alternative option: Instead of refusing any more
memory or terminating the process, a signal (e.g., SIGUSR1)
is sent to the process, which then decides whether or not this
usage is legitimate or not. This follows the basic rationale
that, although a process in principle might consume large
amounts of memory (e.g., audio/video editing, image pro-
cessing, scientiﬁc computing), its legitimacy depends on the
task at hand and thus, is best judged by the process itself.
However, it is questionable whether a process under attack
still is trustworthy enough to make this decision.

Improved error reporting. As demonstrated in Section 4.1
even well-reviewed code from mature projects contains a
multitude of type-conversion warnings. C/C++ projects
from Debian stable tagged as Required, Important or Standard
spawn 1,798 warnings related to diﬀerent kinds of conversions
on average, 703 of which are exclusive to the migration to 64-
bit platforms. Whether or not these express actual ﬂaws or
even security issues is unclear. It, however, appears that those
that actually are security ﬂaws, get lost in the sheer amount
of warnings. Presumably for this exact reason, none of the
inspected Debian packages makes use of the -Wconversion
ﬂag and in doing so, turns a blind eye on these issues.

Factoring out the functionality of GCC’s -Wconversion ﬂag
that concerns data types that have changed in size due to
migration to 64-bit platforms to a separate ﬂag as deployed in
IBM’s XL compiler [16], for instance, is a valuable ﬁrst step.
Such an additional ﬂag can then be issued individually or
automatically set on specifying -Wconversion to preserve the
current functionality of the compiler. Although, this already
reduces the amount of warnings by 60%, the absolute number
of warnings in complex software projects might still be too
large to be handled at once.

Making use of data that arise from program analysis al-
ready employed by compilers, can be used to restrict warnings
to more speciﬁc situations, as for instance, the lack of some
sort of check on values for which a conversion warning is
issued. In case of the examined Debian packages this would
reduce the number of warnings by additional 95% to merely
30 instances. However, such analyses come at a computa-
tional cost that often does not ﬁt the requirements of a
performance-oriented compiler framework.

In conclusion the most eﬀective strategy against 64-bit mi-
gration issues, and vulnerabilities arising thereof, is to raise
awareness for this particular aspect of software security and
avoid implicit conversion in the ﬁrst place.

5507. RELATED WORK

The discovery and prevention of integer-related vulner-
abilities is a long-standing topic in computer security. In
this section, we provide an overview of past research on
integer-related vulnerabilities, including previous work on
vulnerabilities related to 64-bit platforms, and more ad-hoc
guides for safely porting code to 64-bit platforms published
outside of academia.

Integer-related vulnerabilities. Many researchers have dealt
with integer-related defects and vulnerabilities in the past,
where eﬀorts have been made to both identify and prevent
these ﬂaws. On the one hand, methods that operate on
source code or intermediate program representations have
been proposed, both based purely on static analysis [2, 24, 43],
and dynamic approaches that rely on checks at runtime [6,
8, 9, 34, 35, 38, 44]. On the other hand, methods to identify
these ﬂaws in binary executables have been presented, again,
both via static analysis [12, 42, 45], and in combination with
dynamic approaches [7, 30, 36].

Another strain of research aims to address the root causes
of integer-related vulnerabilities by designing libraries for
safe integer operations, e.g., SafeInt [22] and IntSafe [15].
Moreover, dialects of the C programming language that
provide additional annotations or introduce new concepts
to prevent security ﬂaws have been proposed [19, 31, 32].
While these approaches cover many diﬀerent integer-related
ﬂaws, only few provide a general view on the prevalence of
such ﬂaws [e.g., 6, 9, 34, 43] and none so far, speciﬁcally
address integer ﬂaws that arise from the migration to 64-bit
platforms—a gap we attempt to close with this work.

64-bit migration guides. Several informal guides for porting
software to 64-bit architectures are available to date. Several
of these focus entirely on correct pointer to integer conver-
sions, the most obvious problem introduced by the new data
model [37]. Moreover, large software vendors such as IBM,
Oracle (Sun), and Apple have released guides for porting
of code from ILP32 to LP64 that discuss generic problems,
including eﬀects on type conversions, on memory layout (e.g.,
the alignment of data types) and on missing function proto-
types [1, 26, 33]. However, none of these guides provide a
discussion of the security implications these problems have as
well as discusses how exploitable vulnerabilities can emerge
from the migration to 64-bit systems.

Tools for identifying 64-bit vulnerabilities. Tools to identify
some vulnerabilities related to 64-bit systems have been devel-
oped. In particular, the Viva64 static analyzer (part of PVS-
Studio) employs a set of rules for the discovery of certain 64-
bit vulnerabilities [41]. Moreover, Medeiros and Correia [28]
propose a tool to detect 64-bit migration vulnerabilities.
Their method is based on a combination of type checking
and taint tracking to pinpoint integer manipulation issues
involving tainted data. The authors report that all ﬁndings
in their empirical evaluation are false positives, though.

8. CONCLUSIONS

Migrating software to diﬀerent platforms is a notable chal-
lenge for software security. Due to the use of diﬀerent data
models, assumptions about widths of integer types made for
one platform do not necessarily hold true for another. In this
paper, we systematically categorize and deﬁne vulnerabilities

made possible by the migration process to 64-bit platforms.
We show that more than 10 years after 64-bit architectures
have reached the mass market, implicit conversion of types
that have changed due to the diﬀerent data models still
are prevalent in mature and well-tested software. We ﬁnd
that on average, C/C++ projects from Debian stable tagged
as Required, Important or Standard spawn 1,798 warnings
concerning type conversions, 703 of which are exclusive to
64-bit systems. For example, to a large extend developers
appear to unjustiﬁably treat the unsigned type size_t and
(unsigned) int as equal, leading to 21,527 warnings in total,
which creates a large potential for security ﬂaws. Moreover,
we look out for particular patterns of 64-bit migration ﬂaws
to reﬁne our ﬁndings on implicit type conversions. For in-
stance, 10% of all invocations to the memcpy function in the
inspected Debian and GitHub projects, are called with a
signed value of 32-bit in size rather than the 64 bit wide
size_t as parameter for the number of bytes to copy.

Finally, we make use of this systematization and the expe-
rience thus gained to uncover 6 previously unknown vulnera-
bilities in popular software projects, such as the Linux kernel,
Chromium, the Boost C++ Libraries and the compression
libraries libarchive and zlib—all of which have emerged from
the migration from 32-bit to 64-bit platforms.

Acknowledgments
The authors gratefully acknowledge funding from the Ger-
man Federal Ministry of Education and Research (BMBF)
under the projects APT-Sweeper (FKZ 16KIS0307) and
INDI (FKZ 16KIS0154K) as well as the German Research
Foundation (DFG) under project DEVIL (RI 2469/1-1).

References
[1] H. S. Adiga. Porting linux applications to 64-bit sys-
tems. http://www.ibm.com/developerworks/linux/library/l-
port64/index.html, 2006.

[2] K. Ashcraft and D. Engler. Using programmer-written com-
piler extensions to catch security holes. In Proc. of IEEE
Symposium on Security and Privacy, pages 143–159, 2002.

[3] D. J. Bernstein. The qmail security guarantee. https://cr.yp.

to/qmail/guarantee.html, visited August 2016.

[4] D. J. Bernstein. The softlimit program. http://cr.yp.to/

daemontools/softlimit.html, visited August 2016.

[5] S. Bhatkar, D. C. DuVarney, , and R. Sekar. Address ob-
fuscation: an eﬃcient approach to combat a broad range
of memory error exploits.
In Proc. of USENIX Security
Symposium, 2003.

[6] D. Brumley, T. Chiueh, R. Johnson, H. Lin, and D. X. Song.
RICH: Automatically protecting against integer-based vul-
nerabilities.
In Proc. of Network and Distributed System
Security Symposium (NDSS), 2007.

[7] P. Chen, Y. Wang, Z. Xin, B. Mao, and L. Xie. BRICK:
A binary tool for run-time detecting and locating integer-
based vulnerability. In Proc. of International Conference on
Availability, Reliability and Security, pages 208–215, 2009.

[8] R. Chinchani, A. Iyer, B. Jayaraman, and S. Upadhyaya.
ARCHERR: Runtime environment driven program safety.
In Proc. of European Symposium on Research in Computer
Security (ESORICS), pages 385–406, 2004.

551[9] W. Dietz, P. Li, J. Regehr, and V. Adve. Understanding inte-
ger overﬂow in C/C++. In Proc. of International Conference
on Software Engineering(ICSE), pages 760–770, 2012.

[30] D. Molnar, X. C. Li, and D. Wagner. Dynamic test generation
to ﬁnd integer bugs in x86 binary linux programs. In Proc.
of USENIX Security Symposium, pages 67–82, 2009.

[10] S. Esser. PHP printf() family 64 bit casting vulnerabili-
ties. http://www.php-security.org/MOPB/MOPB-38-2007.
html, 2007.

[11] Free Software Foundation, Inc. Warning options - using the
gnu compiler collection (gcc). https://gcc.gnu.org/onlinedocs/
gcc/Warning-Options.html, visited August 2016.

[12] P. Godefroid, M. Y. Levin, and D. Molnar. Active property
In Proc. of ACM International Conference on

checking.
Embedded Software (EMSOFT), pages 207–216, 2008.

[13] G. Guninski. 64 bit qmail fun. http://www.guninski.com/

where do you want billg to go today 4.html, 2005.

[14] T. Heo. Control group v2. https://www.kernel.org/doc/

Documentation/cgroup-v2.txt, 2015.

[15] M. Howard. Safe integer arithmetic in c. http://blogs.msdn.

com/b/michael howard/archive/2006/02/02/523392.aspx,
visited August 2016.

[16] IBM Corp. XL C/C++: Optimization and programming

guide. Technical report, IBM Corp., 2012.

[17] IEEE and The Open Group. The open group base speciﬁca-
tions issue 7. Technical Report IEEE Std 1003.1, IEEE and
The Open Group, 2013.

[18] ISO. The ANSI C standard (C99). Technical Report WG14

N1124, ISO/IEC, 1999.

[19] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney,
and Y. Wang. Cyclone: A safe dialect of C. In Proc. of
USENIX Annual Technical Conference (ATC), pages 275–
288, 2002.

[20] J. Koziol, D. Litchﬁeld, D. Aitel, C. Anley, S. Eren, N. Mehta,
and R. Hassell. The Shellcoder’s Handbook: Discovering and
Exploiting Security Holes. John Wiley & Sons, 2004.

[21] T. Lauer. Porting to Win32TM: A Guide to Making Your
Applications Ready for the 32-Bit Future of WindowsTM.
Springer, 1996.

[31] G. C. Necula, S. McPeak, and W. Weimer. CCured: Type-
safe retroﬁtting of legacy code. In Proc. of ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Lan-
guages (POPL), pages 128–139, 2002.

[32] G. C. Necula, J. Condit, M. Harren, S. McPeak, and
W. Weimer. CCured: Type-safe retroﬁtting of legacy soft-
ware. ACM Transactions on Programming Languages and
Systems (TOPLAS), 27(3):477–526, 2005.

[33] Oracle. Guidelines for converting to LP64. https://docs.oracle.

com/cd/E18752 01/html/816-5138/convert-19.html, 2005.

[34] M. Pomonis, T. Petsios, K. Jee, M. Polychronakis, and A. D.
Keromytis. IntFlow: Improving the accuracy of arithmetic
error detection using information ﬂow tracking. In Proc. of
Annual Computer Security Applications Conference (AC-
SAC), pages 416–425, 2014.

[35] R. E. Rodrigues, V. H. S. Campos, and F. M. Q. Pereira. A
fast and low-overhead technique to secure programs against
integer overﬂows. In Proc. of International Symposium on
Code Generation and Optimization (CGO), pages 1–11, 2013.

[36] S. Sidiroglou-Douskos, E. Lahtinen, N. Rittenhouse, P. Piselli,
F. Long, D. Kim, and M. Rinard. Targeted automatic inte-
ger overﬂow discovery using goal-directed conditional branch
enforcement. In Proc. of the International Conference on
Architectural Support for Programming Languages and Oper-
ating Systems (ASPLOS), pages 473–486, 2015.

[37] Software Engineering Institute, CERT Division. Con-
to pointer.

verting a pointer
https://www.securecoding.cert.org/conﬂuence/display/
c/INT36-C.+Converting+a+pointer+to+integer+or+
integer+to+pointer, 2016.

to integer or

integer

[38] H. Sun, X. Zhang, C. Su, and Q. Zeng. Eﬃcient dynamic
tracking technique for detecting integer-overﬂow-to-buﬀer-
overﬂow vulnerability. In Proc. of ACM Symposium on In-
formation, Computer and Communications Security (ASI-
ACCS), pages 483–494, 2015.

[22] D. LeBlanc. Safeint. https://safeint.codeplex.com, visited

[39] The MITRE Corporation. CVE-2013-0211. http://cve.mitre.

August 2016.

org/cgi-bin/cvename.cgi?name=CVE-2013-0211, 2013.

[23] Linux Programmer’s Manual. ulimit - get and set user lim-
its. http://man7.org/linux/man-pages/man3/ulimit.3.html,
visited August 2016.

[24] F. Long, S. Sidiroglou-Douskos, D. Kim, and M. Rinhard.
Sound input ﬁlter generation for integer overﬂow errors. In
Proc. of ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages (POPL), pages 439–452, 2014.

[25] M. L´opez-Ib´a˜nez and I. L. Taylor. The new Wconversion
option. https://gcc.gnu.org/wiki/NewWconversion, visited
August 2016.

[26] Mac Developer Library.

Making code 64-bit clean.
https://developer.apple.com/library/mac/documentation/
Darwin/Conceptual/64bitPorting/MakingCode64-
BitClean/MakingCode64-BitClean.html, 2012.

[27] J. R. Mashey. The long road to 64 bits. ACM Queue Maga-

zine, 4(8):24–35, 1996.

[28] I. Medeiros and M. Correia. Finding vulnerabilities in software
ported from 32 to 64-bit CPUs.
In Proc. of Conference
on Dependable Systems and Networks (DSN), 2009. (fast
abstract).

[29] Microsoft Security Research and Defense Blog. Software
defense: mitigating common exploitation techniques. http:
//blogs.technet.com/b/srd/archive/2013/12/11/software-
defense-mitigating-common-exploitation-techniques.aspx,
2013.

[40] The Open Group. 64-bit and data size neutrality. http:

//www.unix.org/version2/whatsnew/lp64 wp.html, 2000.

[41] Viva64. Detect 64-bit portability issues. http://www.viva64.

com/en/viva64-tool/, visitied February 2016.

[42] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Automati-
cally detecting integer overﬂow vulnerability in x86 binary
using symbolic execution. In Proc. of Network and Distributed
System Security Symposium (NDSS), 2009.

[43] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek.
Improving integer security for systems with KINT. In Proc.
of USENIX Symposium on Operating Systems Design and
Implementation (OSDI), pages 163–177, 2012.

[44] C. Zhang, T. Wang, T. Wei, Y. Chen, and W. Zou. IntPatch:
Automatically ﬁx integer-overﬂow-to-buﬀer-overﬂow vulner-
ability at compile-time. In Proc. of European Symposium
on Research in Computer Security (ESORICS), pages 71–86,
2010.

[45] Y. Zhang, X. Sun, Y. Deng, L. Cheng, S. Zeng, Y. Fu, and
D. Feng. Improving accuracy of static integer overﬂow de-
tection in binary. In Proc. of International Symposium on
Research in Attacks, Intrusions and Defenses (RAID), pages
247–269, 2015.

552