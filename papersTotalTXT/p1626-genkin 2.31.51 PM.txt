ECDSA Key Extraction from Mobile Devices
via Nonintrusive Physical Side Channels ∗

Daniel Genkin

Technion and

Tel Aviv University

danielg3@cs.technion.ac.il

Lev Pachmanov
Tel Aviv University
levp@tau.ac.il

Itamar Pipman
Tel Aviv University

itamarpi@tau.ac.il

Eran Tromer
Tel Aviv University
tromer@tau.ac.il

ABSTRACT
We show that elliptic-curve cryptography implementations
on mobile devices are vulnerable to electromagnetic and
power side-channel attacks. We demonstrate full extraction
of ECDSA secret signing keys from OpenSSL and CoreBit-
coin running on iOS devices, and partial key leakage from
OpenSSL running on Android and from iOS’s Common-
Crypto. These non-intrusive attacks use a simple magnetic
probe placed in proximity to the device, or a power probe
on the phone’s USB cable. They use a bandwidth of merely
a few hundred kHz, and can be performed cheaply using an
audio card and an improvised magnetic probe.

1
Introduction
1.1 Overview
Side channel analysis, exploiting unintentional and abstraction-
defying information leakage from physical computation de-
vices, has been used to break numerous cryptographic imple-
mentations (see [9,40,42] and the references therein). While
traditional side channel research has mainly focused on small
embedded devices such as smartcards, RFID tags, FPGAs
and microcontrollers, recent works also study the vulnera-
bility of complex PC-class computers (laptop, desktop and
server) to physical key-extraction attacks [29–32, 59].

In this paper we study vulnerability to side-channel key
extraction in another class of complex devices: mobile de-
vices (smartphones and tablet computers). This prospect
is already supported by some recent results. Using invasive
access to the device, it is possible to acquire electromagnetic
and power measurements with very high ﬁdelity in terms of
bandwidth, noise and spatial locality. Such invasive access

∗The authors thank Noam Nissan for programming and lab

support during the course of this research.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
CCS’16 October 24-28, 2016, Vienna, Austria
© 2016 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-4139-4/16/10.
DOI: http://dx.doi.org/10.1145/2976749.2978353

Yuval Yarom

The University of Adelaide and
yval@cs.adelaide.edu.au

Data61, CSIRO

has been used for key extraction attacks on intentionally-
naive RSA implementations [33, 45]. A non-invasive attack
was shown by Kenworthy and Rohatgi [4,38] on BouncyCas-
tle’s RSA implementation running on a smartphone. All of
these attacks used expensive lab-grade equipment, such as
oscilloscopes, for their measurements.

This paper focuses, instead, on the Elliptic Curve Digital
Signature Algorithm (ECDSA) [46], a very popular signa-
ture scheme that is especially pertinent and critical in mo-
bile devices due to its use in mobile payment apps such as
Bitcoin wallets and Apple Pay. Attacking ECDSA raises
new challenges:
• ECDSA signatures are computed faster than RSA, and
thus the attacker gets less physical information at a given
sampling rate. Increasing the sampling rate increases costs
and runs into frequency-limited physical eﬀects.

• More fundamentally, ECDSA signatures are randomized.
When attacking deterministic operations, such as RSA de-
cryption, attackers can rely on triggering numerous identi-
cal decryptions and then aggregating their recorded traces
in order to improve signal-to-noise ratio and cope with
transient events such as interrupts. But with ECDSA,
one has to make deductions from individual traces that
are noisy and frequently interrupted.

We raise the following questions:

1. How vulnerable are implementations of ECDSA, running

on mobile phones, to physical side channel attacks?

2. Are these vulnerabilities common across diﬀerent imple-

mentations and across diﬀerent phone models?

3. What physical channels can be used for the attacks?
4. How expensive are such attacks, both in terms of com-
plexity and in terms of ﬁnancial outlay? Can they be
conducted with concealed, portable equipment? Do they
require high-grade lab equipment or can they be imple-
mented using cheap, over-the-shelf equipment?

A concurrent and independent work of Belgarric et al. [14]
provides a valuable insight on some of these questions, demon-
strating full key extraction from BouncyCastle’s ECDSA im-
plementation on a phone. That attack used an electromag-
netic probe placed invasively inside the open case of a phone.
It relied on triggering measurement via the USB interface,
and (even though essentially relying on low-frequency sig-

1626Library
OpenSSL

OpenSSL

Version
1.0.x
1.1.x
1.0.x
1.1.x
7.1.2–8.3

Common-
Crypto
CoreBitcoin Commit

81762ae3

Platform Result
Android

iOS

iOS

iOS

Scalar dependent
leakage (Section 3.3).
Key extraction
(Section 3.2).
Scalar dependent
leakage (Section 3.3).
Key extraction
(Section 3.3).

Table 1: Summary of our attack results.

nals) used an expensive oscilloscope. This leaves unexplored
much of the space posed by the aforementioned questions.
1.2 Our Results
In this paper we demonstrate the ﬁrst side channel attack
on Elliptic Curve Cryptography (ECC) running on a smart-
phone which simultaneously achieves the following:

1. Real-World Implementations. We attacked the ECDSA
implementation of OpenSSL running on iOS devices (iPhone
and iPad) as well as Android devices.
In particular,
we attacked the CoreBitcoin library, based on OpenSSL,
which is used by popular Bitcoin wallets on iOS devices.
We also attacked the built-in ECDSA implementation of
iOS’s CommonCrypto library.

2. Non-Invasive. The demonstrated attacks are non inva-
sive and can be conducted by merely placing a magnetic
probe in the proximity of the device, or using a power
tap on its USB charging cable. The attack does not re-
quire opening the device’s case and does not utilize any
software or hardware in order to trigger the measuring
equipment. See Figures 1 and 9.1

3. Cheap EM and Power Analysis. Our attack uti-
lizes physical emanations (electromagnetic or power) at
frequencies below 200 kHz, which is well below the GHz-
scale processor clock speed. Consequentially, our attack
can acquire secret-key information using cheap, compact
and readily available equipment, such as sound cards and
improvised probes.

In some cases (e.g., CoreBitcoin on iPhone devices), we
demonstrated full key extraction. It was impractical to do so
for all combinations of target software, target hardware and
acquisition hardware, but for numerous such combinations
we found clear leakage of key material suggesting feasibility
of full key extraction, as discussed in Sections 3 and 4. See
Table 1 for a summary of our results.

We achieve the above using new techniques for enhancing
the measured side-channel signal in the presence of noise
generated by the device’s internal components. While typ-
ical techniques for overcoming measurement noise involve
averaging the signal obtained from several secret-key oper-
ations, this is not applicable to ECDSA since the nonce is
generated afresh for every signature.
Instead, we present
techniques for enhancing the signal present in a single trace,
without relying on additional information from other traces.

1While we do not require any speciﬁc triggering software,
the attack does require the target to repeatedly perform
ECDSA signing operations. Several such scenarios exist,
see Section 1.3.

1.3 Targeted Software and Hardware
Hardware. We target mobile devices such as tablets and
phones. We measured numerous devices of various models.
Many devices exhibit key-dependent leakage (see Figure 3).
All the devices were in their default conﬁguration and we did
not disable any background services and notiﬁcations. WiFi
was on and connected and bluetooth was oﬀ. All phones
were without a simcard installed.2
In the sequel, unless
stated otherwise, the experiments were performed on Apple
iPhone 3GS which exhibited a particularly clear signal.
Software. We target popular ECDSA implementations
running on various mobile devices. More speciﬁcally, we
target the following implementations:

1. The ECDSA implementation of OpenSSL (v1.0.1m), a
ubiquitous cryptographic library, running on iOS and An-
droid devices.3
The underlying Elliptic Curve (EC)
scalar multiplication algorithm is wNAF with w = 3.

2. The built-in ECDSA implementation of Apple’s Com-
monCrypto library, which is a part of iOS. We targeted
iOS versions 7.1.2 through 8.3, whose underlying EC mul-
tiplication algorithm is wNAF with w = 1.

3. CoreBitcoin [2], a popular cryptographic library for iOS
used by many Bitcoin clients (including ArcBit, BitStore,
BitWallet, Mycelium and Yellet). CoreBitcoin imple-
ments deterministic ECDSA [52], using OpenSSL for the
underlying EC multiplication.

Attack Scenario. Our attacks require side-channel mea-
surements while the victim performs multiple ECDSA sign-
ing operations. Signing multiple messages under the same
key is common when the key is ﬁxed by a public key in-
frastructure or a PGP “web of trust”. It is also necessary
for Bitcoin micropayment channels [3,56], which allow mak-
ing lightweight out-of-blockchain automated payments for
an ongoing service. Since each such micropayment requires
an ECDSA signature this will cause frequent and automated
signatures under the same key.
Disclosure and Status. Practicing responsible disclosure,
we have worked with the vendors of all targeted software to
convey our ﬁndings and coordinate response, prior to public
disclosure. See Appendix A for the current status of targeted
software, including newer versions.
1.4 Related Work
Physical Attacks on ECC on Small Devices. For
small devices (smartcards, RFID tags, FPGAs and micro-
controllers), side-channel attacks have been demonstrated
on numerous cryptographic implementations, using various
channels, and in particular the EM channel starting with [6,
28, 54]. See [9, 40, 42] and the references therein. In partic-
ular, physical key-extraction attacks were shown on many
ECC implementations on small devices, starting with Coron [24];
see the surveys [25, 26] and the references therein. How-
ever these techniques either utilize subtle physical eﬀects

2The phones are SIM-locked to a foreign carrier and we do
not have the appropriate sim cards.
3We used OpenSSL compiled with its default options.
In particular, the “enable-ec_nistp_64_gcc_128” option,
which enables a constant-time implementation for some
curves [37], is disabled by default and works only on 64-
bit x86 (32-bit processors are unsupported, and the built-in
tests fail on 64-bit ARM).

1627(a) Top view. The target (top right) is measured by the improvised
probe (taped to the underside of a glass table). The signal is captured
by a Tracker Pre sound card connected to a laptop (under the table).

(b) Improvised probe (view from under the glass
table).

Figure 1: Mounting a cheap EM attack on an iPhone 4 using an improvised EM probe.

which are only visible at bandwidths comparable to the de-
vice’s clock rate, attack naive implementations (such as the
double-and-sometimes-add algorithm), or utilize a chosen ci-
phertext in order to deduce additional information about the
algorithm’s secret internal state.

All of the above approaches have signiﬁcant drawbacks
in the case of a non-naive implementation of ECDSA run-
ning on a high-speed smartphone. Non-invasively recording
clock-rate signals from a smartphone running a multi GHz-
scale CPU is diﬃcult, often requiring expensive, cumber-
some, and delicate lab equipment. Chosen-input attacks are
usually inapplicable to signature schemes, since the inputs
are processed through a cryptographic hash function.
Key-Extraction Side-Channel Attacks on Phones.
High bandwidth electromagnetic attacks (sampling at clock-
rate speeds) on symmetric ciphers were demonstrated by
Aboulkassimi et al. [5] on Java-based feature-phones. At-
tacks at clock-rate frequencies on public key cryptography
were also recently demonstrated by Goller and Sigl [33] on
Android smartphones running a naive square-and-sometimes-
multiply RSA, with the phone’s shielding plate often re-
moved. Lower-frequency attacks on smartphones executing
naive implementations of square-and-sometimes-multiply RSA
as well as double-and-sometimes-add ECC were also demon-
strated by [45] with the phone battery cover opened, bat-
tery removed and the probe positioned directly over the
leaky component. A non-invasive low-frequency attack was
demonstrated by Kenworthy and Rohatgi [38] against naive
square-and-sometimes-multiply RSA. These attacks were also
later extended to RSA windowed exponentiation as used in
BouncyCastle [4]. Finally, measuring at clock-rate frequen-
cies, the work of Kenworthy and Rohatgi [38] also presented
an attack on a naive and self-written double-and-sometimes-
add ECC, which is known to have side-channel weakness.

Belgarric et al. [14], in a concurrent and independent work
(as acknowledged by them [15]), presented an invasive low-
frequency attack on the ECDSA implementation of Android’s
BouncyCastle library, running on a smartphone, using a

magnetic probe placed inside the (opened) phone. It used
a bandwidth of 50 kHz, measured by an oscilloscope. The
oscilloscope was triggered, via a self-written triggering soft-
ware installed on the phone. The software sends a trigger
signal via phone’s USB port (connected to oscilloscope’s trig-
gering port) and then immediately invokes the BouncyCastle
signing function. The acquisition and analysis of the signal
were done by manual observation of the double and add
operations in the (hundreds of) traces.

Software side-channel attacks, utilizing cache contentions,
were demonstrated on ARM devices, showing partial extrac-
tion of an AES key [41]. These require attacker’s code to
run on the device.

Key Extraction Attacks on ARM Development Boards.
In recent works, DPA-style attacks were demonstrated on
ARM-type devices. Balasch et al. [13] demonstrated a clock-
rate attack on AES running on a BeagleBone Black ARM
development board. A similar attack on the same device
at much lower frequencies was demonstrated by Galea et
al. [27]. While these results demonstrate the possibility of
attacking symmetric key encryption running on complex de-
vices, both attacks were highly invasive with the probe phys-
ically glued to the leaky component. The task of demon-
strating a non-invasive attack on symmetric key encryption
running on a real smartphone remains open.

Key-Extraction Side-Channel Attacks on PCs. Phys-
ical key-extraction side-channels were exploited for extract-
ing keys from RSA, ElGamal and ECDH implementations,
using the acoustic, chassis-potential and electromagnetic chan-
nels [29–32]. Software key extraction attacks were demon-
strated using timing diﬀerences [20,21], and cache contention
[17, 49, 50] and applied to ECDSA [8, 16, 19, 51].

16282 Cryptanalysis
2.1 Preliminaries
ECDSA. We start by describing the Elliptic-Curve Digital
Signature Algorithm scheme (ECDSA). Given a generator G
of an elliptic curve group of order n, key generation consists
of selecting a random integer 1 ≤ d ≤ n − 1 and computing
Q = [d]G. (Here and onward, we use additive group nota-
tion, and [d]G denotes scalar-by-point multiplication.) The
(secret) signing key is d and the (public) veriﬁcation key is
Q. Signing of a message m is done as follows: hash m un-
der a designated hash function and convert the ﬁrst (cid:100)log2 n(cid:101)
bits of the digest into an integer z; generate a random nonce
1 ≤ k ≤ n − 1; compute the curve point (x, y) = [k]G us-
ing a scalar-by-point multiplication; compute r = x mod n
and s = k−1(z + r · d) mod n; output the signature (r, s).
(In case r = 0 or s = 0, repeat the signature operation us-
ing a fresh random k.) Verifying a signature (r, s) on m is
done by computing z as above, computing w = s−1 mod n,
u1 = zw mod n, u2 = rw mod n, (x, y) = [u1]G + [u2]Q and
then checking that x ≡ r (mod n).
Low s-value ECDSA. ECDSA signatures are malleable
in the sense that given a message m and a signature pair
(r, s), it is possible to generate an additional valid signature
for m (r(cid:48), s(cid:48)) (cid:54)= (r, s) by setting r(cid:48) = r and s(cid:48) = −s mod n.
This property is problematic for Bitcoin clients which use the
hashing of (r, s) in order to identify matching signatures [10,
58]. A common solution to the above problem used by many
Bitcoin clients is to require that s ≤ n/2. That is, in the
case that the signing process (described above) generates a
pair (r, s) where s > n/2 for some message m, the signature
routine outputs (r,−s mod n) as the signature of m [58].
In the sequel, for an integer a, we denote by |a|
Notation.
is absolute value, by (cid:98)a(cid:99)n the result of reducing a modulo n
into the range [0,··· , n−1] and by |a|n the result of reducing
a modulo n into the range [−n/2,··· , n/2).
2.2 Scalar-by-Point Multiplication
The main operation performed during a ECDSA signing is
the elliptic curve scalar-by-point multiplication. The w-ary
non-adjacent form (wNAF) method (Algorithm 1) is one of
the commonly-used algorithms for implementing scalar-by-
point multiplication. wNAF is used for multiplication in
curves over prime size ﬁelds, including many of the NIST
P-curves and the Bitcoin curve secp256k1, in several crypto-
graphic libraries, such as OpenSSL, CoreBitcoin, Apple’s
CommonCrypto and BouncyCastle. The algorithm is so
named for representing the scalar k using the wNAF rep-
resentation which we now discuss.

The non adjacent form [55] is a generalization of the bi-
nary representation of integers, allowing for three possible
digits, -1, 0, and 1, referred to as NAF digits, and requiring
that every pair of non-zero digits is separated by at least
one zero digit. For example, the 4-digit NAF representa-
tion of 7 is (1,0,0,−1) compared to its binary representation
(0,1,1,1). The main advantage of using a NAF represen-
tation is that it reduces the expected number of non-zero
digits from about 1/2 for the binary representation to about
1/3. Since every non zero digit in the representation of k
leads to a point addition operation, representing k in NAF
form reduces the number of point addition operations per-
formed during the scalar-by-point multiplication operation.

Algorithm 1 wNAF scalar-by-point multiplication opera-
tion (simpliﬁed).
Input: A positive scalar k and an elliptic-curve point P,
where kg−1 ··· k0 is the wNAF representation of k, that
i=0 2i · ki, ki ∈ {−2w + 1,··· ,2w − 1}, ki is odd
or zero, and kg−1 (cid:54)= 0.

is k =(cid:80)g−1

Output: [k]P.
1: procedure point_mul(k, P)
Q1 ← P ; Q−1 ← [−1]P
2:
for i ← 1 to 2w−1 − 1 do
3:
Q2i+1 ← Q2i−1 + [2]P
4:
Q−2i−1 ← [−1]Q2i+1
5:
6:
7:
8:
9:
10:
11:

A ← Qkh−1
for i ← g − 2 to 0 do
A ← [2]A
if ki (cid:54)= 0 then
A ← A + Qki

return A

The wNAF representation generalizes this by allowing odd
digits from {−2w + 1,··· ,2w − 1} as well as zero digits.

2.3 Attack Algorithm
Let DA-sequence denote the sequence of double and add
operations performed in lines 8 and 10 of Algorithm 1. No-
tice that by observing the DA-sequence performed by Algo-
rithm 1 it is possible to deduce all the locations of the non-
zero valued wNAF digits of the nonce k. However, since the
DA-sequence only discloses the positions of the non-zero dig-
its but not their values, recovering the DA-sequence alone is
not enough for achieving key extraction.

Cryptanalytic Approach. Nguyen and Shparlinski [48]
describe a theoretical attack for combining partial informa-
tion on the bits of multiple nonces in order to recover the
secret key d. Benger et al. [16] later apply the attack to
the DA-sequences of OpenSSL’s implementation of ECDSA,
as leaked through a cache channel on a PC. In this section
we extend these techniques for handling low s-value ECDSA
commonly used by Bitcoin clients.

In our approach, following [16, 18, 48, 51], the partial in-
formation collected from each (suitable) signing operation
is summarized in a matrix. The secret value is then ex-
tracted by solving the Closest Vector Problem (CVP) on
the corresponding lattice, i.e., by ﬁnding an integer linear
combination of the matrix rows that is close a to a target
vector. Details follow.

Closest Vector Problem. An input of a CVP consists of
a matrix (lattice basis) B and a target vector u. The output
is an integer vector x such that the (cid:96)2-norm of the vector
xB−u is minimal, i.e., the lattice vector xB is the closest to
u. While the CVP problem is believed hard in general and
the best algorithms are exponential in the dimension of B
(in the worst case), many heuristic CVP solvers exists [47].
In this work, we utilize the fplll solver [7] running on a PC
(3.4 GHz, 6 cores, 64 GB of RAM).

Attacking Low s-value ECDSA. Let d be an ECDSA
signing key and G be a generator of an elliptic curve of
order n. Assume we have a dataset of m ECDSA signatures
where for each signature i we are given the hashed message
zi and the signature (ri, si), where si is the low s-value, i.e.

1629s ≤ n/2. First, we notice that for all i it holds that
zi + d · ri ≡ siki
(mod n) or zi + d · ri ≡ −siki

(mod n).

(1)
Notice that, without knowing ki, we do not know which of
the above cases holds. (This depends on whether k−1(z +
r · d) mod n is larger than n/2 or not.)

Assume that, for each signature i in this dataset, we have
learned (through side-channel leakage) that the li least sig-
niﬁcant wNAF digits of ki are zero. We ﬁrst note that this
also implies that the li least signiﬁcant bits of ki are zeros
or, equivalently, that ki = 2li · bi for some bi ≤ n/2li . Ex-
panding and rearranging Equation 1 we obtain that for all i
it holds that
· 2−li + d · ri · s
zi · s
−1
· 2−li + d · ri · s
zi · s
i
−1
i
(2)
Next, deﬁne ti = (cid:98)ri · s
· 2−li(cid:99)n
−1
and νi = |dti − ui|n. From Equation 2 we have that either
i
νi ≡ bi (mod n) or that νi ≡ −bi (mod n). Finally, since
bi ≤ n/2li ≤ n/2 and |νi| ≤ n/2, we obtain:

· 2−li ≡ bi
· 2−li ≡ −bi
· 2−li(cid:99)n, ui = (cid:98)zi · s

(mod n).

(mod n)

or

−1
i
−1
i

−1
i

|νi| = bi ≤ n/2li .

(3)
Notice that |νi| is smaller by a factor of 2li−1 than a random
element in Zn. Utilizing this fact, following the approach
of [16, 48], we now convert our dataset into a closest vector
lattice problem.
CVP Attack. Consider the lattice L(B) over Rm+1 gen-
erated by the rows of the following matrix:



B =

2l1 · n

2l1 · t1

. . .
···

2lm · n
2l1 · tm 1

 .

Deﬁne the vector u = (2l1 · u1,··· , 2lm · um,0). Notice that
both the matrix B and the vector u can be computed from
the public information zi, si and the leakage li for 1 ≤ i ≤ m.
We now claim that the solution to the closest vector problem
deﬁned by L(B) and u reveals the secret key d.
integers
(λ1,··· , λm) such that for the vectors x = (λ1,··· , λm, d)
and y = (2l1 · ν1,··· ,2lm · νm, d) we have xB − u = y. Next,
notice that the (cid:96)2-norm of y is about n·√
determinant of L(B) is 2m+(cid:80) li · nm. Thus, we obtain that
d + 1 whereas the

Indeed, Equation 3 implies the existence of

the lattice vector xB is heuristically closest to the vector u.
By solving the CVP problem on inputs (B, u) we obtain the
vector x the last entry of which reveals the key d.

3 Signal Analysis
3.1 Experimental Setup
To measure the EM leakage from the smartphone, we used
a Langer LF-R 400 near ﬁeld probe (a 25mm loop probe,
100 kHz–50 MHz). We ampliﬁed the signal measured by the
probe using a (customized) Mini-Circuits ZPUL-30P ampli-
ﬁer, providing 40 dB of gain. The output of the ampliﬁer
was then low-pass ﬁltered at 5 MHz.

For digitizing the analog signal, we used one of two in-
struments. For the best robustness during initial charac-
terization, as described below in this subsection, we used
a National Instruments PCI-6115 data acquisition device,

Figure 2:
EM measurement (0.5 sec, 0–225 kHz)
of four scalar-by-point multiplication operations us-
ing the NIST P-521 curve executed on an iPhone
3GS smartphone. The scalar was set to be either a
random 521-digit number or the 521-digit number
obtained by repeating the pattern written to the
right. In all cases, the same curve point was used to
perform the multiplication.

sampling at 10 Msample/sec with 12 bits of ADC resolution.
For key extraction, described in Section 3.2, we used an
Ettus N200 software deﬁned radio device, with its LFRX
daughterboard, sampling at 1 Msample/sec.

Note that in terms of bandwidth, the above is an overkill
for our attacks, which exploit signals up to 200 kHz. Thus,
similarly to [29], we can replace the probe and data acquisi-
tion device with much cheaper equipment, such as a sound
card; this is discussed in Section 4.
Scalar-Dependent Leakage. Conﬁrming the existence
of scalar-dependent leakage from OpenSSL’s scalar-by-point
multiplication function, Figure 2 shows a spectrogram of the
EM leakage obtained during four distinct signature opera-
tions, using the same point P and four diﬀerent values of the
scalar k. Notice that all of the four scalars can be easily dis-
tinguished by changes in vertical line pattern in their spec-
tral signature. Such nonce-dependent leakage was observed
on many target phones, of various models and manufactures
(see Figure 3). This hints at the relationship between the
time behavior of the observed leakage signal and the secret
bits of the scalar k.
Triggering. In all the key-extraction attacks presented be-
low, we simulated a completely passive attacker which does
not interact with the target device. In particular (as men-
tioned in Section 1.2) we did not use any software-based or
hardware-based triggering of the measurement setup (un-
like [15]). Instead, we sampled continuously and relied on
our signal processing to locate the leakage from the signing
operation within the measurement trace (see details below).
In order to conveniently attack multiple cryptographic li-
braries (with diﬀerent API interfaces and running on diﬀer-
ent mobile operating systems), for each attacked library we
wrote a small program that calls the ECDSA operation, and
invoked it over the network.
3.2 Attacking OpenSSL ECDSA
Signal Acquisition. We recorded the leakage of 5000
OpenSSL ECDSA signatures executed on an iPhone 3GS.
For all of the recorded signatures, we used the secp256k1
curve with the same randomly-generated secret key. We
measured the iPhone’s electromagnetic emanations during
the signing operations using the setup described in Sec-
tion 3.1 (with the Ettus N200 sampling at 1 Msample/sec).

1630(a) Apple iPad Mini 2
(0 − 400 kHz, 0.2 msec).

(b) Apple iPad 3rd Generation
(0 − 200 kHz, 0.3 msec).

(c) Apple iPhone 4s
(0 − 175 kHz, 0.3 msec).

(d) Apple iPhone 5s
(0 − 200 kHz, 0.2 msec).

(e) Apple iPod Touch 4th Generation
(0 − 200 kHz, 0.2 msec).

(f) Sony Ericsson Xperia X10
(250 − 500 kHz, 0.8 msec).

Figure 3: EM measurement of four scalar-by-point multiplication operations using the NIST P-521 curve
executed on various mobile devices. In each subﬁgure, the ﬁrst multiplication used a random 521-digit scalar
while the remaining three used the same repetitive 521-digit numbers used in Figure 2 (in the same order).
Similarly to Figure 2, the same curve point was used to perform the multiplication.

We then stored the recorded traces, as well as the signed
message produced by the ECDSA signing, for oﬄine signal
processing and cryptanalysis.

Examining Raw Traces. After digitizing, we applied a
Finite Impulse Response (FIR) low-pass ﬁlter to suppress
noise outside the 0–125 kHz band. The resulting signal can
be seen in Figure 5 (top). Evidently, even after suppressing
high frequency noise, one still cannot easily determine the
locations of point addition and point doubling operations. In
addition, the signal is periodically corrupted by strong dis-
turbances caused by the operating system timer interrupts.
Previous works ( [29–31]) have mitigated the problem of low
SNR and signal distortion by repeating each measurement
several times and combining the results into a single clear
aggregate trace. However, this is inapplicable to ECDSA:
each signing operation uses a diﬀerent nonce k, so the corre-
sponding scalar-by-point multiplications [k]G results in dif-
ferent DA-sequences that cannot be directly combined.

Locating Signing Operations.
In order to successfully
execute our attack, we need to ﬁnd the exact points in time
where each signing operation ends. Unlike the concurrent
work of [14] which assumes that these exact time points are
leaked via the USB port, we assume the attacker has no
leakage of such information and tackle the problem during
our signal processing steps. For this purpose we utilize a dis-
tinct trace pattern occurring at the very end of each signing.
This pattern is a natural product of the executed code (it
is not an artiﬁcial trigger), but is very similar across dif-
ferent signing operations, for given software and hardware.

After performing signal denoising (described next) we apply
correlation-based detection to identify all instances where
this distinct pattern occurs. We thus obtain the end points
for most signing operations. We ignored some traces that
ended in distorted patterns that did not correlate well.
Denoising Signal Traces. As mentioned above, an
average-based denoising approach is not applicable to
ECDSA since each signing operation uses a diﬀerent nonce
k. Instead, to increase the SNR of our traces, we add a pre-
processing step (following the FIR ﬁlter) that performs Sin-
gular Spectrum Analysis (SSA). SSA can be used for blind
source separation and denoising of single traces [34]. In the
context of side channels, SSA was used in [53] to increase
the success probability of various DPA-style attacks target-
ing embedded devices. The aim of the SSA procedure is to
into several distinct
components, each with its own physical properties. The al-
gorithm consists of three stages (see [34] for further details).
Step 1: Embedding. First, a window length 2 < L < N/2 is
chosen and used to construct a trajectory matrix of the input
. The trajectory matrix is comprised of K
“lagged” copies of the series and is deﬁned as follows (where
Ai are column vectors and K

decompose a given time series(cid:8)ai

= N − L + 1):
.

time series(cid:8)ai

(cid:9)N

(cid:9)N

i=1

i=1

A =(cid:0) A1 A2

(cid:1) =

. . . AK



a1
a2
a2
a3
...
...
aL aL+1

. . .
. . .
. . .
. . .

aK
aK+1

...
aN

 .

1631Figure 4: Our lab-grade setup attacking a Sony-Ericsson Xperia x10 phone. Left to right: analysis laptop,
power supply, ZPUL 30P ampliﬁer (gray box), Ettus N200 (white box), and phone being attacked using the
Langer LF-R 400 probe (blue).

n

n

λi

, where d is the

A = USVT =(cid:80)d

vectors Vi can be given by Vi = AT Ui√
lowest eigenvalue such that λd > 0. The SVD of a ma-
trix thus allows us to represent it as a sum of matrices:
λiXi. The matri-
√
ces Xi are called projection matrices, and their contributions
λi (which are
to the original matrix A are proportional to
also called the singular values of A).

T =(cid:80)d

λiUiVi

√

√

i=1

i=1

i=1

n=1

n=1

n=1

(cid:9)N

Step 3: Reconstruction. Each matrix Xi can now be trans-
by averag-
ing over the entries in its anti-diagonal. This process is also
called diagonal averaging or Hankelazation [35]. Overall we

(cid:9)N
formed back into a length N time series(cid:8)xi
obtain a decomposition of the original time series(cid:8)an
(cid:9)N
(cid:8)xi
into a sum of d series: (cid:8)an
(cid:9)N
= (cid:80)d
suitable subset of m ≤ d series from within the set(cid:8)xi
(cid:9)d

n=1
. A de-
noised time series can now be reconstructed by choosing a
.

i=1
SSA Parameter Choice. The quality of the decomposi-
tion and denoising is highly dependent on the window size L
and the choice of subset m. Empirically, we have found that
good results are obtained when L is chosen to be shorter
than both the double and the add operations. At a sam-
pling rate of 1M samples per second, the length of double
and add operations was 50 and 250 samples, respectively.
We thus chose L to be 10 samples long. The reconstruc-
tion subset m was also chosen empirically. We found that a
good result is achieved when one uses the components cor-
responding to the third, fourth and ﬁfth highest singular
values for reconstruction (regarding the rest of the compo-
nents as noise). It is worth noting that SSA is often used
in the literature to expose hidden periodic trends in noisy
signals. In these cases it is recommended [34, 39] to choose
L to be relatively large (larger than the longest suspected
hidden period). However, in our case the DA sequence has
no intrinsic periodicity, and larger L values seemed to be
less suited for denoising.

n

Figure 5 depicts a signal trace after undergoing the SSA
procedure. The double and add sequence can now be

Figure 5: A recorded trace after ﬁltering out high
frequency noise (top), and the same trace after ad-
ditionally applying SSA (bottom). Note the timer
interrupt disturbing the measurement signal.

Notice A is also a Hankle matrix since all entries on its
anti-diagonal are identical, i.e. for all 2 (cid:54) i + j (cid:54) N + 1 and
1 (cid:54) n (cid:54) N we get Aij = an if i + j = n + 1.
Step 2: Singular Value Decomposition. After obtaining the
trajectory matrix, it is decomposed using a Singular Value
Decomposition (SVD). An SVD of a matrix A is a well
known decomposition and is deﬁned by (for an L by K ma-
trix with L < K):

A =USVT =

 U1···

UL

T

√
λ1
...
0

0
. . .
0

0 ···
0
0 ···
√
0
λL 0 ···

0

0
0



 V T

...
V T
K

1

 ,

where λi are the eigenvalues of AAT in descending order
and Ui are their corresponding eigenvectors. The vectors
Vi are the eigenvectors of AT A. For 1 (cid:54) i (cid:54) d, the

1632clearly seen. Note that the SSA procedure did not get rid
of the interrupt induced disturbances, but since we only re-
quire a small number of double operations taken from the
end of the trace, this is usually not an issue. On the rare
occasions where an interrupt was detected at the very end of
the trace, the corresponding recording was simply discarded.
Locating Addition Operations In Time. Examining
the denoised trace, we can now attempt to extract the DA-
sequence. For this purpose we turn to the time-frequency
domain. The middle of Figure 6 depicts the spectrogram of a
denoised trace, where the frequency band containing most of
the energy of addition operations becomes especially clear
(see Figure 6 (middle)). Summing over the spectrogram’s
energy we receive a trace marking the locations of addition
operations in time . In order to increase the detection ac-
curacy, we enhance this trace by multiplying it with its own
derivative with respect to time. This way we are able to
enhance high amplitude peaks that also rise sharply, and
attenuate other peaks. Further smoothing produces the sig-
nal depicted in Figure 6 (bottom), where the peaks marking
the locations of add operations can be detected with high
ﬁdelity.
Extracting the Partial DA-Sequence. Having found a
way to detect addition operations with suﬃcient ﬁdelity, we
can now attempt to locate the position of the very last ad-
dition operation in the signal. We do so by ﬁrst ﬁnding the
point in each trace where the signing operation ends. This
point can be reliably found in many traces since the sig-
nal pattern that immediately follows the signing operation
is consistently similar across many traces. We can use this
pattern as a template to reliably locate it in other traces us-
ing correlation, discarding traces that do not correlate well
with the chosen template. By measuring the distance be-
tween the estimated template location in each trace and
the very last addition operation detected in the signature
(found using the methods described in the previous subsec-
tion), we can determine the number of double operations
that occurred at the very end of each signing operation, thus
acquiring the DA information necessary for key extraction.
Signal Analysis Performance. Applying our attack to
a randomly-generated ECDSA secp256k1 OpenSSL key, we
measured the EM emanations during 5000 signatures on
an Apple iPhone 3GS smartphone, each signature lasting
0.1 sec. Applying our signal processing to the 5000 traces
we collected, we were able to detect the end time of the
signing operation in 1278 traces. Out of these, 114 traces
were identiﬁed as having their DA-sequence terminate with
at least three elliptic curve double operations; 3 of these
were false positives (as discovered in retrospect; the attack
code did not use this information).
Lattice Reduction and Key Extraction. Using the
above 114 traces, we randomly selected 85 traces (this num-
ber was set empirically, to obtain high success probability in
the next step) and applied the lattice attack of [16] using the
fplll [7] implementation of the BKZ algorithm with block size
β = 30. Unfortunately, whenever the selected traces hap-
pen to include some of 3 erroneous ones, the BKZ algorithm
fails to recover the signing key, causing the key-extraction
attempt to fail. Therefore, we repeated the procedure of
randomly selecting 85 traces and applying the lattice attack
30 times. Since each lattice reduction attempt does not de-
pend on others, we performed these repetitions in a parallel
manner on separate cores. Across the 30 parallel attempts,

Figure 6:
(top) A denoised trace with add opera-
tions marked. (middle) Zoomed-in view of the spec-
trogram of the trace. The energy of add operations
is clearly visible. (bottom) Energy as a function of
time of the visible part of the spectrogram (after en-
hancement and smoothing). Peaks approximate the
location of add operations.

the secret key was successfully recovered in 2. The signal
processing and lattice reductions took two hours on a desk-
top PC (3.4 GHz, 6 cores, 64 GB RAM), leading to complete
extraction of the ECDSA signing key. Notice that all the 30
repetitions of the lattice reduction step were done oﬄine
on the same data base of analog traces. Thus, even a single
successful lattice reduction leads to a successful key-recovery
attack.
3.3 Other ECSDA Implementations
Attacking OpenSSL on Android Devices.
Key-
dependent leakage, similar to Figure 2, was also observed
on various Android phones. See Figure 3. We thus conjec-
ture that similar attacks can be mounted on these devices
as well. Demonstrating the feasibility of such a result on an
Android device, Figure 7 shows the extraction of a sequence
of elliptic curve double and add operations from a Sony-
Ericsson Xperia X10 smartphone. The signal in the ﬁgure
is the result of digital FM demodulation and ﬁltering.
Attacking CoreBitcoin. Demonstrating the possibility
of Bitcoin theft via side-channel from iOS devices, we have
mounted a successful key extraction attack on CoreBitcoin’s
low s-value ECDSA implementation running on iOS. We
recorded the leakage of 5000 ECDSA secp256k1 signatures
executed on an Apple iPhone 3GS smartphone. Out of these
5000 traces, 1940 were discarded due to measurement noise.
Out of the remaining 3060 traces, 110 were identiﬁed as hav-
ing their DA sequence terminate in at least four elliptic curve
double operations with one of these being a false positive
(again, discovered in retrospect). Next, we randomly chose
85 out of the 110 available traces and applied the lattice at-
tack described in Section 2.3. Repeating the attack 20 times
(each time choosing a random subset containing 85 traces)
resulted in a successful key extraction in 4 out of the 20 at-
tempts. Similar to Section 3.2, all the 20 repetitions of the

1633Figure 7: Sequence of double and add operations
extracted during a secp256k1 scalar by point mul-
tiplication operation executed on an Sony-Ericsson
Xperia X10 smartphone. In this experiment we re-
placed the wNAF representation of k with the 256-
digit string obtained by repeating the pattern 10100.

Figure 8:
EM measurement (0.2 sec, 0–250 kHz)
of four scalar-by-point multiplication operations us-
ing the NIST P-521 curve executed on an iPhone
3GS smartphone running Apple’s CommonCrypto
library. As in Figure 2, the scalar was set to be ei-
ther a random 521-digit number or a the 521-digit
number obtained by repeating the pattern written
to the right. In all cases, the same curve point was
used to perform the multiplication.

lattice reduction step were done oﬄine on the same data
base of analog traces. Thus, even a single successful lattice
reduction leads to a successful key-recovery attack.
Attacking Apple’s CommonCrypto ECDSA Imple-
mentation. The ECDSA implementation of Apple’s Com-
monCrypto library performs the elliptic curve scalar-by-
point multiplication operation using Algorithm 1 with w =
1. Figure 8 shows scalar-dependent leakage, similar to Fig-
ure 2, obtained by measuring an iPhone 3GS when invoking
the elliptic curve multiplication operation as implemented
in Apple’s CommonCrypto library.

4 Cheap Attacks

While the results of Section 3 clearly demonstrate the possi-
bility of key extraction via the electromagnetic channel using
expensive lab equipment, the low bandwidth nature of our
attacks allows for key extraction using a much cheaper ex-
perimental setup via both the electromagnetic channel and
the power channel.
EM Probe. For the EM channel we improvised a probe by
scavenging a coil from a Qi wireless charging receiver module
($2 on eBay). See Figure 1.

Figure 9: Mounting a cheap power analysis attack
on an iPhone 4 through its charging port. This setup
includes a portable battery (bottom, left), a power
monitoring probe (bottom, middle) and an iPhone 4
(bottom, right). The power probe is then connected
to the Tracker Pre sound card (top, middle) and the
attacker’s laptop (top, left).

Power Probe. To monitor the phone’s current draw, we
built a simple USB pass-through adapter, with a 0.33Ω re-
sistance in series with the ground line. We then connected
the phone to a portable USB battery pack through the pass-
through adapter, and measured the voltage over the resistor;
see Figure 9.
Digitizer. We connected the improvised EM and power
probes into the microphone input of a Creative Tracker Pre
sound card ($50, eBay). This card acts both as an ampliﬁer
(60dB gain) and as a digitizer (192 Ksample/sec).4
Attack Scenario. Small loops of wire acting as EM probes
can be easily concealed inside various objects (such as table-
tops, phone cases (especially those containing an extra bat-
tery), or even food items [29]). See Figure 1. Monitoring the
phone’s power consumption can be easily done by augment-
ing an aftermarket charger, external battery or battery case
with the requisite equipment. In this context, phone cases
which contain an additional battery (and therefore are con-
nected to the phone’s charging port) are especially danger-
ous since these can be augmented to monitor both channels
simultaneously, thus obtaining a potentially cleaner signal.
We leave this for future work.
Scalar-Dependent Leakage. We measured the EM leak-
age of an iPhone 4 using our improvised EM probe connected
to the Tracker Pre sound card and concealed beneath a glass
tabletop (see Figure 10). Similarly to Figure 3, Figure 10
(right) presents a spectrogram of ﬁve distinct signature op-
erations, using the same point P and ﬁve diﬀerent values of
the scalar k. Notice that even though the equipment used
to generate Figure 10 is much simpler (and cheaper) than
the lab-grade equipment used in Figure 3, the ﬁve diﬀerent

4 Alternatively, one could use an inexpensive USB oscillo-
scope. However, these are optimized for bandwidth (at the
expense of SNR), and would require an additional ampliﬁer.
Sound cards typically oﬀer higher SNR and a built-in am-
pliﬁer, and while their bandwidth is much lower, it suﬃces
for our attacks.

1634scalars can be easily distinguished from their spectral signa-
ture. Similar results were obtained using the power probe
as well (see Figure 10 (left)).
Extracting the DA-Sequence. After observing the scalar
dependent leakage using our improvised probes and the
Tracker Pre sound card, we proceeded to extract the DA-
sequence which is required for our attack. Applying our
signal processing techniques on an iPhone 3GS running
OpenSSL secp256k1 signature operations, Figure 11 depicts
the results of extracting the DA-sequence using EM leakage
from a single signature. Notice that the individual double
and add operations can clearly be seen. Repeating this pro-
cess for about 5000 signatures should result in a complete
key recovery.

5 Conclusions

In this paper we have demonstrated that despite its speed
and randomization, ECDSA signatures on mobile devices
are vulnerable to physical key extraction attacks. Moreover,
the attacks can be mounted cheaply and non-intrusively.
Our attack exploits the diﬀerences between point addition
and point doubling to recover the DA-sequence. Two ap-
proaches can be used to protect an implementation from
side-channels. The value of the nonce can be decoupled
from the DA-sequence using blinding. Alternatively, the im-
plementation can be modiﬁed to always use the same DA-
sequence, irrespective of the value of the nonce.
Nonce Splitting. Clavier and Joye [23] suggest expressing
the nonce k as k = k1 + k2, where k1 is random and then
compute [k1]G + [k2]G using a multi-exponentiation algo-
rithm [43]. However, this approach leaks the least signiﬁcant
bits of k1 and k2, as well as long, overlapping sequences of
repeating bits in k1 and k2. Splitting the nonce more, i.e.,
expressing k = k1 + k2 + k3 + ··· , such that all the terms
but one are chosen at random, can reduce the probability
of overlaps. However, this approach still leaks the least sig-
niﬁcant bit of k and as [12] show, leaks of one bit can be
exploitable.
Nonce Blinding. Coron [24] suggests blinding the nonce
by choosing a random c and calculating [k]G + [cn]G where
n is the group order. Ciet and Joye [22] note that for groups
of order close to a power of two, this still leaks information
about the high bits of k, and Van de Pol et al. [51] show how
to exploit such leaks. Combining the two approaches, i.e.,

calculating(cid:80)[ki]G for random ki’s and c such that(cid:80) ki =

k + cn, protects from both types of leaks.
Constant-time Implementations. Constant-time im-
plementations mitigate many side-channel leaks by ensur-
ing a ﬁxed execution path that does not depend on secret
data, to prevent timing attacks [21]. Additionally, a con-
stant memory access pattern is desired to avoid cache-based
attacks [17, 49, 50], as well as cache-induced diﬀerences in
timing and electromagnetic behavior. For, EC scalar-by-
point multiplication, the scalar can be represented in a reg-
ular way such that the DA-sequence does not depend on the
nonce [36, 44]; Moller [44] notes that these encodings may
leak information when a point is added to itself, yet with
a random scalar, as is the case in ECDSA, the probabil-
ity of this leak is negligible. A constant-time implementa-
tion for some elliptic curves, on some 64-bit platforms, is
included in OpenSSL [37]. For Bitcoin’s secp256k1 curve,
the libsecp256k1 [57] implementation oﬀers a constant-time,

constant-memory-access implementation of ECDSA signing.
Future Work. While this work clearly demonstrates the
vulnerability of multiple implementations of ECDSA signa-
tures running on mobile devices to cheap low-bandwidth key
extraction attacks, much works remains to be done. The
vulnerability of other ECDSA implementations, as well as
general cryptographic code running on mobile devices has re-
ceived much research attention. Improving the signal qual-
ity, thereby increasing the attack range and reducing the
number of required signatures is an intriguing open prob-
lem. To that end, we note that the more advanced lattice
techniques of [8, 51] are of potential use in order to reduce
the number of signatures. However, our signal is too cor-
rupted (due to interrupts) making these techniques inappli-
cable without signiﬁcant improvements in signal processing
techniques.

Acknowledgments

Daniel Genkin, Lev Pachmanov, Itamar Pipman and Eran
Tromer are members of the Check Point Institute for Infor-
mation Security. This work was done in part while Eran
Tromer was visiting the Simons Institute for the Theory of
Computing, supported by the Simons Foundation and by the
DIMACS/Simons Collaboration in Cryptography through
NSF grant #CNS-1523467.

This work was supported by the Blavatnik Interdisci-
plinary Cyber Research Center; by a Google Faculty Re-
search Award; by the Israeli Centers of Research Excellence
I-CORE program (center 4/11); by the Leona M. & Harry
B. Helmsley Charitable Trust; and by NATO’s Public Diplo-
macy Division in the Framework of ”Science for Peace”.

6 References

[1] Bitcoin Core. URL:

https://bitcoin.org/en/bitcoin-core/.

[2] CoreBitcoin Library. URL:

https://github.com/oleganza/CoreBitcoin.

[3] Working with micropayment channels. URL: https:
//bitcoinj.github.io/working-with-micropayments.

[4] SPA/SEMA vulnerabilities of popular RSA-CRT

sliding window implementations, 2012. presented at
CHES 2012 rump session. URL: https://www.cosic.
esat.kuleuven.be/ches2012/ches rump/rs5.pdf.

[5] D. Aboulkassimi, M. Agoyan, L. Freund, J. Fournier,

B. Robisson, and A. Tria. Electromagnetic analysis
(EMA) of software AES on Java mobile phones. In
WIFS 2011, pages 1–6. IEEE, 2011.

[6] D. Agrawal, B. Archambeault, J. R. Rao, and

P. Rohatgi. The EM side-channel(s). In CHES 2002,
pages 29–45. Springer, 2002.

[7] M. Albrecht, S. Bai, D. Cad´e, X. Pujol, and D. Stehl´e.

fplll-4.0, a ﬂoating-point LLL implementation. URL:
http://perso.ens-lyon.fr/damien.stehle.

[8] T. Allan, B. B. Brumley, K. E. Falkner, J. van de Pol,

and Y. Yarom. Amplifying side channels through
performance degradation. Cryptology ePrint Archive,
Report 2015/1141, 2015. http://ia.cr/2015/1141.

1635Figure 10: Power (left) and EM (right) measurement (0.2 sec, 0–96 kHz) of ﬁve scalar-by-point multiplication
operations using the NIST P-521 curve executed on an iPhone 4 smartphone running OpenSSL. As in Figure 2,
the scalar was set to be either a random 521-digit number or a the 521-digit number obtained by repeating
the pattern written to the right. In all cases, the same curve point was used to perform the multiplication.

[16] N. Benger, J. van de Pol, N. P. Smart, and Y. Yarom.
”Ooh aah... just a little bit” : A small amount of side
channel can go a long way. In CHES 2014, pages
75–92, 2014.

[17] D. J. Bernstein. Cache-timing attacks on AES.

http://cr.yp.to/papers.html#cachetiming, 2005.

[18] D. Boneh and R. Venkatesan. Hardness of computing

the most signiﬁcant bits of secret keys in
Diﬃe-Hellman and related schemes. In CRYPTO
1996, pages 129–142, Santa Barbara, CA, US, Aug.
1996.

[19] B. B. Brumley and R. M. Hakala. Cache-timing

template attacks. In ASIACRYPT 2009, volume 5912
of Lecture Notes in Computer Science, pages 667–684.
Springer, 2009.

[20] B. B. Brumley and N. Tuveri. Remote timing attacks
are still practical. In ESORICS 2011, pages 355–371.
Springer, 2011.

[21] D. Brumley and D. Boneh. Remote timing attacks are

practical. Computer Networks, 48(5):701–716, 2005.
[22] M. Ciet and M. Joye. (virtually) free randomization
techniques for elliptic curve cryptography. In ICICS
2003, pages 348–359. Springer, 2003.

[23] C. Clavier and M. Joye. Universal exponentiation

algorithm. In CHES 2001, pages 300–308. Springer,
2001.

[24] J. Coron. Resistance against diﬀerential power

analysis for elliptic curve cryptosystems. In CHES
2002, pages 292–302, 1999.

[25] J. Fan, X. Guo, E. D. Mulder, P. Schaumont,

B. Preneel, and I. Verbauwhede. State-of-the-art of
secure ECC implementations: A survey on known
side-channel attacks and countermeasures. In HOST
2010, pages 76–87, 2010.

[26] J. Fan and I. Verbauwhede. An updated survey on

secure ECC implementations: Attacks,
countermeasures and cost. In Cryptography and
Security: From Theory to Applications - Essays
Dedicated to Jean-Jacques Quisquater on the Occasion
of His 65th Birthday, pages 265–282, 2012.

[27] J. L. Galea, E. D. Mulder, D. Page, and M. Tunstall.
Soc it to EM: electromagnetic side-channel attacks on

Figure 11: Extracted DA-sequence obtained from
iPhone 3GS during an OpenSSL secp256k1 signature.
The leakage was measured using the Tracker Pre
sound card and the improvised EM probe. The dou-
ble and add operations can clearly be seen.

[9] R. J. Anderson. Security Engineering — A Guide to
Building Dependable Distributed Systems (2nd ed.).
Wiley, 2008.

[10] M. Andrychowicz, S. Dziembowski, D. Malinowski,

and L. Mazurek. On the malleability of Bitcoin
transactions. In FC 2015, pages 1–18, 2015.

[11] Apple Inc. Cryptographic libraries. URL:

https://developer.apple.com/cryptography/.

[12] D. F. Aranha, P.-A. Fouque, B. G´erard, J.-G.

Kammerer, M. Tibouchi, and J.-C. Zapalowicz.
GLV/GLS decomposition, power analysis, and attacks
on ECDSA signatures with single-bit nonce bias. In
ASIACRYPT 2014, Part I, pages 262–281. Springer,
2014.

[13] J. Balasch, B. Gierlichs, O. Reparaz, and

I. Verbauwhede. DPA, bitslicing and masking at 1
GHz. In CHES 2015, pages 599–619. Springer, 2015.

[14] P. Belgarric, P.-A. Fouque, G. Macario-Rat, and

M. Tibouchi. Side-channel analysis of Weierstrass and
Koblitz curve ECDSA on Android smartphones. In
CT-RSA 2016. Springer, 2016. To Appear.

[15] P. Belgarric, P.-A. Fouque, G. Macario-Rat, and

M. Tibouchi. Side-channel analysis of Weierstrass and
Koblitz curve ECDSA on Android smartphones.
Cryptology ePrint Archive, Report 2016/231, 2016.
http://ia.cr/2016/231.

1636a complex system-on-chip. In CHES 2015, pages
620–640. Springer, 2015.

[28] K. Gandolﬁ, C. Mourtel, and F. Olivier.

Electromagnetic analysis: concrete results. In CHES
2001, pages 251–261. Springer, 2001.

[29] D. Genkin, L. Pachmanov, I. Pipman, and E. Tromer.

Stealing keys from PCs using a radio: Cheap
electromagnetic attacks on windowed exponentiation.
In CHES 2015, pages 207–228, 2015. Extended
version: Cryptology ePrint Archive, Report 2015/170.
[30] D. Genkin, L. Pachmanov, I. Pipman, and E. Tromer.

ECDH key-extraction via low-bandwidth
electromagnetic attacks on PCs. In CT-RSA 2016,
pages 219–235, 2016.

[31] D. Genkin, I. Pipman, and E. Tromer. Get your hands

oﬀ my laptop: Physical side-channel key-extraction
attacks on PCs. In CHES 2014, pages 242–260.
Springer, 2014. Extended version: Cryptology ePrint
Archive, Report 2014/626.

[32] D. Genkin, A. Shamir, and E. Tromer. RSA key

extraction via low-bandwidth acoustic cryptanalysis.
In CRYPTO 2014, pages 444–461 (vol. 1). Springer,
2014. Extended version: Cryptology ePrint Archive,
Report 2013/857.

[33] G. Goller and G. Sigl. Side channel attacks on

smartphones and embedded devices using standard
radio equipment. In COSADE 2015, pages 255–270.
Springer, 2015.

[34] N. Golyandina and A. Zhigljavsky. Singular Spectrum

Analysis for Time Series. Springer, 2013.

[35] H. Hassani. Singular spectrum analysis: Methodology
and comparison. J. of Data Science, (5):239–257, 2007.

[36] M. Joye and M. Tunstall. Exponent recoding and

regular exponentiation algorithms. In
AFRICACRYPT 2009, pages 334–349. Springer, 2009.

[37] E. K¨asper. Fast elliptic curve cryptography in

OpenSSL. In FC 2011, pages 27–39. Springer, 2012.

[38] G. Kenworthy and P. Rohatgi. Mobile device security:

The case for side channel resistance. In MoST 2012,
2012.

[39] M. A. R. Khan and D. Poskitt. Window Length

Selection and Signal-Noise Separation and
Reconstruction in Singular Spectrum Analysis.
Monash Econometrics and Business Statistics Working
Papers 23/11, Monash University, Department of
Econometrics and Business Statistics, 2011. URL:
https://ideas.repec.org/p/msh/ebswps/2011-23.html.

[40] P. Kocher, J. Jaﬀe, B. Jun, and P. Rohatgi.

Introduction to diﬀerential power analysis. Journal of
Cryptographic Engineering, 1(1):5–27, 2011.

[41] M. Lipp, D. Gruss, R. Spreitzer, and S. Mangard.
ARMageddon: Last-level cache attacks on mobile
devices. CoRR, abs/1511.04897, 2015.
http://arxiv.org/abs/1511.04897.

[42] S. Mangard, E. Oswald, and T. Popp. Power Analysis

Attacks — Revealing the Secrets of Smart Cards.
Springer, 2007.

[43] B. M¨oller. Algorithms for multi-exponentiation. In

SCA 2001, pages 165–180. Springer, 2001.

[44] B. M¨oller. Securing elliptic curve point multiplication

against side-channel attacks. In ISC 2001, pages

324–334. Springer, 2001.

[45] Y. Nakano, Y. Souissi, R. Nguyen, L. Sauvage,

J. Danger, S. Guilley, S. Kiyomoto, and Y. Miyake. A
pre-processing composition for secret key recovery on
Android smartphone. In WISTP 2014, pages 76–91.
Springer, 2014.

[46] National Institute of Standards and Technology.

Digital Signature Standard (DSS), 2013.

[47] P. Q. Nguyen. Lattice reduction algorithms: Theory
and practice. In Eurocrypt 2011, pages 2–6, Tallinn,
Estonia, May 2011.

[48] P. Q. Nguyen and I. Shparlinski. The insecurity of the
elliptic curve digital signature algorithm with partially
known nonces. Des. Codes Cryptography,
30(2):201–217, 2003.

[49] D. A. Osvik, A. Shamir, and E. Tromer. Cache attacks

and countermeasures: The case of AES. In CT-RSA
2006, pages 1–20. Springer, 2006.

[50] C. Percival. Cache missing for fun and proﬁt.

Presented at BSDCan. http://www.daemonology.net/
hyperthreading-considered-harmful, 2005.

[51] J. van de Pol, N. P. Smart, and Y. Yarom. Just a little

bit more. In CT-RSA 2015, pages 3–21, 2015.

[52] T. Pornin. Deterministic usage of the digital signature

algorithm (DSA) and elliptic curve digital signature
algorithm (ECDSA). RFC 6979, 2013.

[53] S. M. D. Pozo and F. Standaert. Blind source

separation from single measurements using singular
spectrum analysis. In CHES 2015, pages 42–59.
Springer, 2015.

[54] J.-J. Quisquater and D. Samyde. Electromagnetic

analysis (EMA): Measures and counter-measures for
smart cards. In E-smart 2001, pages 200–210, 2001.
[55] G. W. Reitwiesner. Binary arithmetic. Advances in

Computers, 1:231–308, 1960.

[56] C. Smith. What are micropayments and how does

Bitcoin enable them?, 2015. URL:
https://coincenter.org/2015/06/
what-are-micropayments-and-how-does-bitcoin-enable-them/.

[57] P. Wuille. libsecp256k1. URL:

https://github.com/bitcoin/secp256k1.

[58] P. Wuille. Dealing with malleability, 2014. URL:

https://github.com/bitcoin/bips/blob/master/
bip-0062.mediawiki.

[59] A. Zajic and M. Prvulovic. Experimental

demonstration of electromagnetic information leakage
from modern processor-memory systems. EMC 2014,
56(4):885–893, 2014.

APPENDIX
A Current Status of Targeted Software

This appendix reviews the vulnerability status of the tar-
geted software, at the time of writing. See also Table 1.
OpenSSL 1.0.x branch. We have conducted most of our
experiments on OpenSSL version 1.0.1m which was the lat-
est version at the time of conducting this research. For ARM
processors, all curves over prime ﬁelds in the current versions
of OpenSSL (1.0.1r and 1.0.2f) use the same underlying el-

1637liptic curve implementation and thus appear vulnerable to
attacks; while we did not attempt key extraction, scalar-
dependent leakage (similar to Figure 2) was empirically ob-
served from these OpenSSL versions as well. Upon contact-
ing OpenSSL we were notiﬁed that “hardware side-channel
attacks are not in OpenSSL’s threat model”, so no updates
are planned to OpenSSL 1.0.x to mitigate our attacks. Note
that OpenSSL 1.0.2 will be supported until the year 2020,
OpenSSL 1.1.x branch. OpenSSL 1.1.0 pre-release 3 in-
cludes an ARM-speciﬁc constant-time implementations of
the NIST P-256 curve, which is unlikely to be vulnerable
to similar attacks. All other curves over prime ﬁelds, in-
cluding the secp256k1 curve, still use the vulnerable wNAF
implementation.
iOS 7.1.2–8.3 CommonCrypto. The ECDSA imple-
mentation in the CommonCrypto framework of iOS 7.1.2 ap-
pears vulnerable, since it exhibits scalar-dependent leakage
(see Section 3.3). Reverse-engineering the code in iOS 8.3
reveals that it uses the same vulnerable implementation
(wNAF with w = 1).

In response.

iOS 9.x CommonCrypto. Starting with iOS 9, Com-
monCrypto uses a new EC implementation, including side-
channel mitigation techniques such as operand-independent
control ﬂow and Montgomery-ladder multiplication.5 Our
current attacks are not applicable to this new EC imple-
mentation, and we have no evidence that it is vulnerable.
CoreBitcoin. CoreBitcoin [2] (not to be confused with
Bitcoin core, below) is currently vulnerable, as discussed
in Section 3.3.
the CoreBitcoin developers
expressed their intention to switch to the libsecp256k1 li-
brary [57] in the future. This library oﬀers a constant-time,
constant-memory-access implementation of ECDSA signing,
and we have no evidence that it is vulnerable.
Bitcoin Core. The Bitcoin core code [1] (not to be con-
fused with the CoreBitcoin, above) has already transitioned
to the libsecp256k1 library [57] for ECDSA signing, start-
ing from version v0.10.0 (released in February 2015).6 This
library oﬀers a constant-time, constant-memory-access im-
plementation of ECDSA signing, and we have no evidence
that it is vulnerable.

5The relevant code is in the corecrypto library version
337 [11]. The Apple Product Security conﬁrmed that this
is, essentially, the implementation in all iOS 9.x versions, as
well as OS X 10.11, and that 77% of the iOS installations
are iOS 9.x, as of February 2016.
6 Bitcoin Git commit fda3fed18a added support for lib-
secp256k1 ECDSA signing, and commit dffb8f81b8 re-
moved support for OpenSSL ECDSA signing.

1638