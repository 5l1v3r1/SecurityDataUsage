Static Detection of Second-Order Vulnerabilities  

in Web Applications

Johannes Dahse and Thorsten Holz, Ruhr-University Bochum

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/dahse

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXStatic Detection of Second-Order Vulnerabilities in Web Applications

Johannes Dahse

Horst G¨ortz Institute for IT-Security (HGI)

Ruhr-University Bochum, Germany

Thorsten Holz

Horst G¨ortz Institute for IT-Security (HGI)

Ruhr-University Bochum, Germany

johannes. dahse@ rub. de

thorsten. holz@ rub. de

Abstract
Web applications evolved in the last decades from sim-
ple scripts to multi-functional applications. Such com-
plex web applications are prone to different types of se-
curity vulnerabilities that lead to data leakage or a com-
promise of the underlying web server. So called second-
order vulnerabilities occur when an attack payload is ﬁrst
stored by the application on the web server and then later
on used in a security-critical operation.

In this paper, we introduce the ﬁrst automated static
code analysis approach to detect second-order vulnera-
bilities and related multi-step exploits in web applica-
tions. By analyzing reads and writes to memory loca-
tions of the web server, we are able to identify unsani-
tized data ﬂows by connecting input and output points of
data in persistent data stores such as databases or ses-
sion data. As a result, we identiﬁed 159 second-order
vulnerabilities in six popular web applications such as
the conference management systems HotCRP and Open-
Conf. Moreover, the analysis of web applications eval-
uated in related work revealed that we are able to detect
several critical vulnerabilities previously missed.

1

Introduction

Web applications are the driving force behind the modern
Web since they enable all the services with which users
interact. Often, such applications handle large amounts
of (potentially sensitive) data such as text messages, in-
formation about users, or login credentials that need to
be stored persistently on the underlying web server. Fur-
ther, sessions are used to temporarily store data about a
user interacting with the web application during multi-
step processes. All of this data can potentially be abused
by an attacker to cause harm. Many different kinds of at-
tacks against web applications such as Cross-Site Script-
ing (XSS) or SQL injection (SQLi) attacks are known and
common injection ﬂaws are well understood. Such at-
tacks can be prevented by sanitizing user input and many
approaches to address this problem were presented in the
last few years (e.g., [2, 8, 15, 21, 22, 24, 27, 29]).

One common assumption underlying many detection
and prevention approaches is that data that is already
stored on the server is safe. However, an adversary might
be able to bypass the defenses via so called second-order
vulnerabilities if she manages to ﬁrst abuse the web ap-
plication to store the attack payload on the web server,
and then later on use this payload in a security-critical
operation. Such vulnerabilities are often overlooked, but
they can have a severe impact in practice. For exam-
ple, XSS attacks that target the application’s users are
worse if the payload is stored in a shared resource and
distributed to all users. Furthermore, within multi-step
exploits a vulnerability can be escalated to a more severe
vulnerability. Thus, detecting second-order vulnerabili-
ties is crucial to improve the security of web applications.

Detecting Second-Order Vulnerabilities To prevent
such attacks, the source code of a given web application
is assessed before it is deployed on a web server. This
can be done either via dynamic or static analysis. There
are several dynamic approaches to detect second-order
XSS attacks via fuzzing [14, 19]. Generally speaking,
such approaches try to inject random strings to all pos-
sible POST request parameters in a black-box approach.
In a second step, the analysis tools determine if the ran-
dom string is printed by the application again without an-
other submission, indicating that it was stored on the web
server. However, the detection accuracy for second-order
vulnerabilities is either unsatisfying or such vulnerabili-
ties are missed completely [4, 7, 13, 23]. Artzi et. al. [1]
presented a dynamic code analysis tool that considers
persistent data in sessions, but their approach misses
other frequently used data stores such as databases or
ﬁles. Furthermore, one general drawback of dynamic ap-
proaches is the typically low code coverage.

Static code analysis is a commonly used technique to
ﬁnd security weaknesses in source code. Taint analysis
and similar code analysis techniques are used to study the
data ﬂow of untrusted (also called tainted) data into criti-
cal operations of the application. However, web applica-
tions can also store untrusted data to external resources
and later on access and reuse it, a problem that is over-

USENIX Association  

23rd USENIX Security Symposium  989

1

looked in existing approaches. Since the data ﬂow is de-
ferred and can be split among different ﬁles and func-
tions of the application, second-order vulnerabilities are
difﬁcult to detect when analyzing the source code stati-
cally. Furthermore, static code analysis has no access to
the external resources used by the application and does
not know the data that is stored in these.

We are not aware of any plain static code analysis im-
plementation handling second-order vulnerabilities. The
main problem is to decide whether data fetched from per-
sistent stores is tainted or not. Assuming all data to be
tainted would lead to a high number of false positives,
while a conservative analysis might miss vulnerabilities.

Our Approach In this paper, we introduce a reﬁned
type of taint analysis. During our data ﬂow analysis, we
collect all locations in persistent stores that are written to
and can be controlled (tainted) by an adversary. If data
is read from a persistent data store, the decision if the
data is tainted or not is delayed to the end of the anal-
ysis. Eventually, when all taintable writings to persis-
tent stores are known, the delayed decisions are made
to detect second-order vulnerabilities. The intricacies of
identifying the exact location within the persistent store
the data is written to is approached with string analy-
sis. Furthermore, sanitization through database lookups
or checks for existing ﬁle names are recognized.

We implemented our approach in a prototype for static
PHP code analysis since PHP is the most popular server-
side scripting language on the Web with an increasing
market share of 81.8% [28]. Note that our approach can
be generalized to static code analysis of other languages
by applying the techniques introduced in this paper to
the data ﬂow analysis of another language. We evalu-
ated our approach by analyzing six popular real-world
applications, including OpenConf, HotCRP, and osCom-
merce. Overall, we detected and reported 159 previ-
ously unknown second-order vulnerabilities such as re-
mote command execution vulnerabilities in osCommerce
and OpenConf. We also analyzed three web applications
that were used during the evaluation of prior work in
this area and found that previous work missed several
second-order vulnerabilities, indicating that existing ap-
proaches do not handle such vulnerabilities correctly.
In summary, we make the following three contributions:
(cid:127) We are the ﬁrst to propose an automated approach to
statically analyze second-order data ﬂows through
databases, ﬁle names, and session variables using
string analysis. This enables us to detect second-
order and multi-step exploitation vulnerabilities in
web applications.

(cid:127) We study the problem of second-order sanitization,
a crucial step to lower the number of potential false
positives and negatives.

(cid:127) We built a prototype of the proposed approach and
evaluate second-order data ﬂows of six real-world
web applications. As a result, we detect 159 previ-
ously unknown vulnerabilities ranging from XSS to
remote code execution attacks.

2 Technical Background

In this section, we introduce the nature of second-order
vulnerabilities and multi-step exploits. First, we examine
data ﬂow through persistent data stores and the difﬁcul-
ties of analyzing such ﬂows statically. We then present
two second-order vulnerabilities as motivating examples.

2.1 Persistent Data Stores
We deﬁne persistent data stores (PDS) as memory loca-
tions that are used by an application to store data. This
data is available after the incoming request was parsed
and can be accessed later on by the same application to
reuse the data. The term persistent refers to the fact that
data is stored on the web server’s hard drive, although it
can be frequently deleted or updated. Note that this deﬁ-
nition also includes session data since information about
a user’s session is stored on the server and can be reused
by an adversary. We now introduce three commonly used
PDS by web applications.

2.1.1 Databases
Databases are the most popular form of PDS found in
today’s web applications. A database server typically
maintains several databases that consist of multiple ta-
bles. A table is structured in columns that have a speciﬁc
data type and length associated with them. Stored data is
accessed via SQL queries that allow to ﬁlter, sort, or in-
tersect data on retrieval. In PHP, an API for database in-
teraction is bundled as a PHP extension that provides sev-
eral built-in functions for the database connection, and
the query and access of data.

In contrast to other PDS, writing and reading to a
memory location is performed via the same built-in
query function. SQL has different syntactical forms of
writing data to a table. Listing 1 shows three different
ways to perform the same query.

1 // specified write
2 INSERT INTO users (id,name,pass) VALUES (1, admin , foo )
3 INSERT INTO users SET id = 1, name =
foo
4 // unspecified write
5 INSERT INTO users VALUES (1, admin , foo )

admin , pass =

Listing 1: Writing to the database table users in SQL.

While the ﬁrst two queries explicitly deﬁne the col-
umn names, the third query does not. We refer to the
ﬁrst type as speciﬁed write and to the second type as un-
speciﬁed write. Both types convey a difﬁculty for static

990  23rd USENIX Security Symposium 

USENIX Association

2

analysis of the query: a speciﬁed write reveals the col-
umn names where data is written to, but does not reveal
if there are any other columns in the table that are ﬁlled
with default values. This hinders the reconstruction of
table structures when analyzing SQL queries of an ap-
plication statically. An unspeciﬁed write tells us exactly
how many columns exist, but does not reveal its names.
When the columns are accessed later on by name, it is
unclear which column was ﬁlled with which value. The
same applies for read operations. A speciﬁed read re-
veals the accessed column names in a ﬁeld list, whereas
an unspeciﬁed read, indicated by an asterisk character,
selects all available columns without naming them.

In PHP, the queried data is stored as a result resource.
There are different ways to fetch the data from the result
resource with built-in functions, as shown in Listing 2.

row = mysql_fetch_row( res);

1 // numeric fetch
2
3 // associative fetch
4
5
Listing 2: Fetching data from a database result resource.

row = mysql_fetch_assoc( res);
row = mysql_fetch_object( res);

echo

row[1];

echo
echo

row["name"];
row->name;

Basically, numeric and associative fetch operations ex-
ist. The ﬁrst method stores the data in a numerically in-
dexed array where the index refers to the order of the
selected columns. The associative fetch stores the data
in an array indexed by column name. It is also possible
to store the data in an object where the property names
equals the column names. The key difference is that
the associative fetch reveals the accessed column names
while the numeric fetch does not.

All different combinations of writing, reading, and ac-
cessing data can occur within a web application. In cer-
tain combinations, it is not clear which columns are ac-
cessed without knowledge about the database schema.
For example, when data is written unspeciﬁed and
fetched associatively. In practice, however, we are often
able to reconstruct the database schema from the source
code (see Section 3.4.1 for details).

In PHP, the

2.1.2 Session Data
A common way of dealing with the state-less HTTP pro-
tocol are sessions.
SESSION array pro-
vides an abstract way of handling session data that is
stored within ﬁles (default) or databases. A session value
is associated with an alphanumerical key that represents
SESSION array
the memory location. Note that the
needs to be treated like any other superglobal array in
PHP and it can be accessed in any context of the applica-
tion. As any other array, it can be accessed and modiﬁed
dynamically, inter-procedurally, and it can have multiple
SESSION array and the depre-
key names. Besides the
cated HTTP SESSION VARS array, the built-in functions
session register() and session decode() can be
used to set session data.

2.1.3 File Names
A common source for vulnerabilities is an unsanitized
ﬁle name. Developers often overlook that the ﬁle name
of an uploaded ﬁle can contain malicious characters and
thus can be used as a PDS for an attack payload. For
example, Unix ﬁle systems allow any special characters
in ﬁle names, except for the slash and the null byte [12].
NTFS allows characters such as the single quote that can
be used for exploitation [20]. For detecting second-order
vulnerabilities, we need to determine paths where ﬁles
with arbitrary names are located. The analysis of a ﬁle
upload reveals to which path a ﬁle is written to and if the
ﬁle is named as speciﬁed by the user. In PHP, a ﬁle that
is submitted via a multi-part POST request is stored in
a temporary directory with a temporary ﬁle name. The
temporary and original ﬁle name is accessible in the su-
perglobal
FILES array. Furthermore, built-in functions
such as rename() and copy() can be used by an ap-
plication to rename a ﬁle on the server. Note that also
directory names can be used as PDS, for example when
created with the built-in function mkdir().

2.1.4 Excluded PDS
There are less popular PDS that we do not include in
our analysis. For example, data can be retrieved from a
CGI environment variable, a conﬁguration ﬁle, or from
an external resource such as an FTP or SMTP server [5].
However, these PDS are used rarely in practice and de-
cisions can only be made with preconﬁgured whitelists.
We only consider PDS that are tainted by the application
itself and not through a different channel. Analyzing the
data ﬂow through ﬁle content will be an interesting addi-
tion in the future. Here, the challenge is to determine to
what part of a given ﬁle data is written to and from what
part of the ﬁle data is read from because the structure of
the data within the ﬁle is unknown.

Note that data stored via PHP’s built-in functions
ini set() or putenv() only exists for the duration of
the current request. At the end of the request, the envi-
ronment is restored to its original state. Thus, they do not
hold to our deﬁnition of a PDS.

2.2 Second-Order Vulnerabilities
A taint-style vulnerability occurs if data controlled by an
attacker is used in a security-critical operation.
In the
data ﬂow model, this corresponds to tainted data literally
ﬂowing into a sensitive sink within one possible data ﬂow
of the application. We classify a second-order vulnera-
bility as a taint-style vulnerability where the data ﬂows
through one or more PDS. Here, the attack payload is
ﬁrst stored in a PDS and later retrieved and used in a sen-
sitive sink. Thus, two distinct data ﬂows require analysis:
(i) source to PDS and (ii) PDS to sink.

USENIX Association  

23rd USENIX Security Symposium  991

3

In the following, we introduce two motivating exam-
ples with a payload stored in a PDS. In general, every
combination of a source, sensitive sink, and a PDS is pos-
sible. Depending on the application’s design, the ﬂow of
malicious data occurs within a single or multiple attack
requests (e.g., when different requests for writing and
reading are necessary). Finally, we introduce multi-step
exploits as a subclass of second-order vulnerabilities.

2.2.1 Persistent Cross-Site Scripting
Cross-Site Scripting (XSS) [16] is the most common se-
curity vulnerability in web applications [22]. It occurs
when user input is reﬂected to the HTML result of the ap-
plication in an unsanitized way. It is then possible to in-
ject arbitrary HTML markup into the response page that
is rendered by the client’s browser. An attacker can abuse
this behavior by embedding malicious code into the re-
sponse that for example locally defaces the web site or
steals cookie information.

We speak of Persistent Cross-Site Scripting if the at-
tacker’s payload is stored in a PDS ﬁrst, read by the ap-
plication again, and printed to the response page. In con-
trast to non-persistent (reﬂected) XSS, the attacker does
not have to craft a suspicious link and send it to a victim.
Instead, all users of the application that visit the affected
page are attacked automatically, making the vulnerability
more severe. Furthermore, a persistent XSS vulnerability
can be abused to spread an XSS worm [18, 26].

Listing 3 depicts an example of a persistent XSS vul-
nerability. The simpliﬁed code allows to submit a new
comment which is stored in the table comments to-
gether with the name of the author.
If no new com-
ment is submitted, it lists all previously submitted com-
ments that are fetched from the database. While the com-
ment itself is sanitized in line 7 by the built-in function
htmlentities() that encodes HTML control charac-
ters, the author’s name is not sanitized in line 6 and thus
affected by XSS. Note that if the source code is analyzed
top-down, it is unknown at the point of the SELECT query
if malicious data can be inserted into the table comments
by an adversary.

}

:

.

row) {

// list comments

comment[ author ] .

foreach(mysql_fetch_row( res) as

comment = mysql_fetch_array( row);

res = mysql_query("SELECT author,text FROM comments");

echo
htmlentities( comment[ text ]) . "<br />";

1 if(empty( _POST[ submit ])) {
2
3
4
5
6
7
8
9 }
10 else {
11
12
13
14
15
16 }
Listing 3: Example for second-order XSS vulnerability.

author = addslashes( _POST[ name ]);
text = addslashes( _POST[ comment ]);

mysql_query("INSERT INTO comments (author, text)

// add comment

text )");

VALUES (

author ,

2.2.2 Second-Order SQL Injection
A SQL injection (SQLi) [9] vulnerability occurs when
a web application dynamically generates a SQL query
with unsanitized user input. Here, an attacker can po-
tentially inject her own SQL syntax to arbitrarily modify
the query. Depending on the environment, the attacker
can potentially extract sensitive data from the database,
modify data, or compromise the web server.

In Listing 4, user supplied credentials are checked
in line 6.
If the credentials are valid, the session key
loggedin is set to true and the user-supplied user name
is saved into the session key user.
In case the user-
supplied data is invalid, the failed login attempt is logged
to the database with the help of the user-deﬁned log()
function. Here, a second-order SQLi occurs:
if an at-
tacker registers with a malicious user name, this name is
written to the session key user and on a second failed
login attempt used in the logging SQL query.

user =

error ,

VALUES (

_SESSION[ user ];

mysql_query("INSERT INTO logs (error, user)
user )");

1 function log( error) {
2
3
4
5 }
6 if(validAuth( _POST[ user ],
7
8
9 }
10 else {
11
12 }
Listing 4: Example for second-order SQLi vulnerability.

_SESSION[ loggedIn ] = true;
_SESSION[ user ]

log( Failed login attempt );

_POST[ pass ]) {

_POST[ user ];

=

2.2.3 Multi-Step Exploitation
Within a second-order vulnerability, the ﬁrst order (e. g.,
safe writing of user input into the database or a ﬁle path)
is not a vulnerability by itself. However, unsafe writing
can lead to other vulnerabilities. We deﬁne a multi-step
exploit as the exploitation of a vulnerability in the second
order that requires the exploitation of an unsafe writing
in the ﬁrst order. Thus, a multi-step exploit is a subclass
of a second-order vulnerability and it can drastically raise
the severity of the ﬁrst vulnerability.

Since we only consider databases, sessions, and ﬁle
names as PDS in our analysis, the following vulnerabili-
ties are relevant:

(cid:127) SQLi: A SQLi in an INSERT or UPDATE statement
leads to a full compromise of all columns in the
speciﬁed table. Furthermore, a SQLi in a SELECT
query allows arbitrary data to be returned.

(cid:127) Path traversal: A path traversal vulnerability al-
lows to change the current directory of a ﬁle opera-
tion to another location. Arbitrary ﬁle names can be
created in arbitrary locations if a path traversal vul-
nerability affects the renaming or creation of ﬁles.
(cid:127) Arbitrary ﬁle write: An arbitrary ﬁle write vulnera-
bility can modify or create a new session ﬁle, lead-
ing to the compromise of all session values.

992  23rd USENIX Security Symposium 

USENIX Association

4

3 Detecting Second-Order Vulnerabilities

In the following, we describe our approach to auto-
matically detect second-order vulnerabilities via static
code analysis. For this purpose, we extended our pro-
totype RIPS [6] that uses block summaries [30]. In this
section, we ﬁrst brieﬂy review the used data ﬂow and
taint analysis approach of RIPS (Sections 3.1 and 3.2).
Afterwards, we explain our novel additions for detect-
ing second-order vulnerabilities and multi-step exploits
(Sections 3.3–3.5).

(cid:127) ArrayDimTree represents a newly declared ar-
ray or the assignment of data to one array key
( array[k] = data).
It is organized in a tree
structure. The array keys are represented by array
edges that point to the assigned data symbol. The
ArrayDimTree symbol provides methods to add or
fetch symbols by a dimension that is compared to
the tree’s edges.

(cid:127) ValueConcat represents the concatenation of two
or more data symbols ( a. b). Two consecutive
Value symbols are merged to one Value symbol.

3.1 Data Flow Analysis
RIPS leverages a context-sensitive,
intra- and inter-
procedural data ﬂow analysis. We use basic block, func-
tion, and ﬁle summaries [30] for efﬁcient, backwards-
directed data ﬂow analysis [6]. First, for each PHP ﬁle’s
code, a control ﬂow graph (CFG) consisting of con-
nected basic blocks is generated. Deﬁnitions of func-
tions, classes, and methods within the code are extracted.
Then, every CFG is analyzed top-down by simulating the
connected basic blocks one by one. A block edge that
links two connected basic blocks is simulated as well to
identify data sanitization.

During the simulation of one basic block, all assigned
data is transformed into data symbols that we will intro-
duce later. The ﬂow of the data is inferred from these
symbols and summarized in a block summary [30] that
maps data locations to assigned data. The return results
and side-effects (e.g., data assignment or sanitization) of
called built-in functions are determined by a precise sim-
ulation of over 900 unique functions.

If a user-deﬁned function is called within a basic
block, its CFG is generated and all basic blocks are sim-
ulated. Based on these block’s summaries, the data ﬂow
within the function is determined by analyzing return
statements in a similar way to taint analysis (see Sec-
tion 3.2). The results are stored in a function summary.
This summary is used for each call of the user-deﬁned
function, while return values, global variables, and pa-
rameters are adjusted to the callee’s arguments and envi-
ronment context-sensitively. When all basic blocks of a
ﬁle’s CFG are simulated, a ﬁle summary is generated in a
similar way to functions that is used during ﬁle inclusion.
Data and its access within the application’s code is

modeled by so called data symbols [6]:

(cid:127) Value represents a static "string", integer, ﬂoat,
or a resolved CONSTANT’s value. Deﬁned constant
values are stored in the environment.

(cid:127) Variable represents a variable by its name.
(cid:127) ArrayDimFetch represents the access of an ar-
ray ( array[k]) and extends the Variable sym-
bol with a dimension (k). The dimension lists the
fetched array keys in form of data symbols.

5

(cid:127) Multiple is a container for several data symbols. It
is used, for example, when a function returns differ-
ent values depending on the control ﬂow or PHP’s
ternary operator is used ( c ?

a :

b).

During data ﬂow analysis, one or more sanitiza-
tion tags can be added to a data symbol, for exam-
ple if sanitization is applied by built-in functions such
as addslashes() or htmlentities(). Each sanitiza-
tion tag represents one context, for example, a single-
quoted SQL value or a double-quoted HTML attribute.
A symbol can be sanitized against one context, but
be vulnerable to another. The tags are removed again
when built-in functions such as stripslashes() or
html entity decode() are called. Furthermore, infor-
mation about encoding is added to every data symbol.

3.2 Context-Sensitive Taint Analysis
The goal is to create a vulnerability report, whenever a
tainted data symbol δ ﬂows into a sensitive sink. Our
implementation is performed with 355 sensitive built-
in functions of PHP. If a call to a sink is encountered
during block simulation, its relevant arguments are an-
alyzed. First, the argument is transformed into a data
symbol. If the symbol was deﬁned within the same basic
block, it is inferred from the block summary. Then, the
symbol is looked up in the block summary of every pre-
vious basic block that is linked with a block edge to the
current basic block. If the lookup in the block summary
succeeds, the inferred symbol is fetched. The dimension
of an ArrayDimFetch symbol is carried until a map-
ping ArrayDimTree symbol is found. The backwards-
directed symbol lookup continues for each linked basic
block and stops if a symbol of type Value is inferred or
the beginning of the CFG is reached. At this point, all
resolved symbols are converted to strings in order to per-
form context-sensitive string analysis [6]. The symbols
Value and Boolean are converted to their representative
string values. Data symbols of sources are mapped to a
Taint ID (TID) that is used as string representation.

Next, each string is analyzed. The location of the TIDs
within the markup is determined to precisely detect the
context. For complex markup languages such as HTML

USENIX Association  

23rd USENIX Security Symposium  993

or SQL, a markup parser is used. With the help of the
sanitization tags and encoding information of the linked
data symbol, we check if the symbol is sanitized cor-
rectly according to its context.
If a TID is found that
belongs to an unsanitized source regarding the current
context, a vulnerability report is generated. Unsanitized
parameters or global variables are added to the function’s
summary as sensitive parameter or global. These are an-
alyzed in the context of each function call.

3.3 Array Handling
By manually analyzing the code of the most popular PHP
applications [28], we empirically found that a common
way to write data into a database is by using arrays. An
example is shown in Listing 5. In line 9 and 10, the ar-
ray’s key deﬁnes the table’s column and the array’s value
stores the data to write. The separated array values are
joined to a string again by using the built-in function
implode() (lines 2/3). Based on this observation, we re-
designed the handling of arrays by adding new data sym-
bols. As a side effect, the handling of fetched database
results in form of an array and the handling of the super-
global

SESSION array is signiﬁcantly improved.

array) {

array);
mysql_query("INSERT INTO { table}

(". fields.") VALUES ( ". values." )");

fields = implode(",", array_keys( array));
values = implode(" , ",

1 function insert( table,
2
3
4
5
6 }
7
8
9
10
11 );
12 insert("users",
13 // INSERT INTO users (name,pass) VALUES ( X ,

"name" => addslashes( _POST[ name ]),
"pass" => md5( _POST[ pass ]),

new_user = array(

new_user);

123abc... )

Listing 5: Using arrays to write data to a database.

Furthermore, we

We model the popular built-in function implode() by
adding the data symbol ArrayJoin. With the help of this
symbol, it is possible to keep track of the delimiter that
is used to join strings.
If the symbol is inferred to an
ArrayDimTree symbol, a ValueConcat symbol is cre-
ated that joins all symbols of the ArrayDimTree symbol
with the stored delimiter symbol.
introduce

new symbol
ArrayKey.
It is used when the key of an array is ex-
plicitly accessed, such as in the loop foreach( array
as key => value).
It is handled similar to the
Variable symbol and is associated with the array’s
name.
If the ArrayKey symbol is inferred into an
ArrayDimTree symbol during data ﬂow or taint analy-
sis, a Multiple symbol containing all edges’ symbols
is returned. Built-in functions, such as array keys()
and array search(), return all or parts of the available
keys in an array and can be modeled more precisely with
the ArrayKey symbol.

the

Figure 1: Data ﬂow model of a conventional (a) and a
second-order (b, c) vulnerability.

3.4 PDS-centric Taint Analysis
We now introduce our novel approach to detect second-
order vulnerabilities. The data ﬂow is illustrated in Fig-
ure 1 (b). Contrarily to a conventional taint-style vulner-
ability as shown in Figure 1 (a), a source ﬂows into a
PDS before it ﬂows from the PDS into a sensitive sink.
We model the data that is read from a PDS by new data
symbols δ∗ that hold information about their origin.

During code analysis, taintable PDS are identiﬁed.
They are stored together with the minimum set of applied
sanitization and encoding tags of the tainting data sym-
bol δ . If one of the new data symbols δ∗ is encountered
unsanitized during the taint analysis of a sensitive sink, a
vulnerability report is created if its originating PDS was
identiﬁed as taintable.

If the PDS is not known as taintable, a temporary vul-
nerability report is created, as shown in Figure 1 (c). The
report is connected to the data symbol δ∗. At the end
of the code analysis, we decide if the data symbol origi-
nates from a taintable PDS by comparing its origin to all
collected taintable PDS.

In the following, we introduce the analysis of writings
to different PDS. Furthermore, our new data symbols δ∗
are introduced that model the reading and access of data
that is stored in PDS.

3.4.1 Databases

Modeling the data ﬂow through databases is a complex
task, mainly due to the large API that is available for
databases and the usage of a query language. First, our
prototype tries to obtain as much knowledge of the SQL
schema as possible. Then we try to reconstruct all SQL
queries during SQL injection analysis of 110 built-in
query functions. Finally, the type of operation is deter-
mined, as well as the targeted table and column names.
The access of data is modeled by new data symbols.

994  23rd USENIX Security Symposium 

USENIX Association

6

Preparation During the initialization of our tool, we
collect all ﬁles with a .sql extension. All available
CREATE TABLE instructions within these ﬁles are parsed
so that we can reconstruct the database schema, includ-
ing all table and column names as well as column types
and length.
If no schema ﬁle is found, each PHP ﬁle
in the project is searched via regular expression. The
knowledge of the database schema improves precision
when data is read in an unspeciﬁed way, or when data is
sanitized by the column type or length.
Writing A write operation to a database is detected
if the SQL parser identiﬁes an INSERT, UPDATE, or
REPLACE statement. By tokenizing the SQL query, we
determine the targeted table’s name, all speciﬁed column
names, and their corresponding input values. In case of
an unspeciﬁed write, the parser makes use of the database
schema. If an input value of a column contains a TID
(see Section 3.2), the affected column and table name is
marked as taintable together with the linked source sym-
bol and its sanitization tags.
Reading
If the SQL parser encounters a SELECT state-
ment, we try to determine all selected column and ta-
ble names. Multiple table names can occur if tables
are joined or unioned. Alias names within the query
are mapped and resolved.
In case of uncertainty, the
parser makes use of the database schema. Finally, a new
ResourceDB symbol is mapped to the analyzed query
function as return value. This symbol holds information
about all selected column names in a numerical hash map
and its corresponding table names.
Access
In PHP, database result resources are trans-
formed into arrays by built-in fetch functions (refer to
Listing 2). We ignore the mode of access and let 89 con-
ﬁgured fetch functions return a Variable symbol with
the name of the resource. When an ArrayDimFetch
symbol accesses the result of these fetch functions, it is
inferred to the corresponding ResourceDB symbol. In
this case, the carried dimension of the ArrayDimFetch
symbol is evaluated against the available column names
in the ResourceDB symbol. If the asterisk character is
contained in the column list and the dimension is numer-
ical, the database schema is used to ﬁnd the correct col-
umn name. Otherwise, if the dimension equals a column
name in the ﬁeld list, a new DataDB symbol is returned
that states which column of which table is accessed.
Sanitization Certain implicit sanitization is considered
when dealing with SQL. If a column is compared to a
static value within a WHERE clause in a SELECT state-
ment, the return value for this column is sanitized.
In
this case, the static value is saved within the ResourceDB
symbol and mapped to the column as return value. Fur-
thermore, a sanitization tag for the used quote type is
removed when data is updated or inserted to the database
because one level of escaping is lost during writing.

3.4.2 Session Keys
The analysis of session variables does not require a com-
plex markup parser or new data symbol. Instead, session
data is handled similar to other global arrays. Taintable
session keys are stored during the analysis phase.
Writing
If data is assigned to a Variable or
ArrayDimFetch symbol during block simulation and
SESSION, the assigned data is
the symbol’s name is
analyzed via taint analysis.
If the assigned data is
its resolved source symbol is stored into an
tainted,
ArrayDimTree symbol in the environment,
together
with the dimension of the
SESSION symbol. This way,
an ArrayDimTree is built with all taintable dimensions
of the session array that link to the tainted source sym-
bols and their corresponding sanitization tags.
Reading The access to session data is modeled by
ArrayDimFetch symbols with the name
SESSION and
requires no modiﬁcation. During taint analysis inside a
user-deﬁned function, session variables are handled as
global variables. They are added to the function sum-
mary and they are inspected for each function call in a
context-sensitive way. This avoids premature decisions
about the taint status inside a function if the session key
is overwritten before the function is called. Just as for a
DataDB symbol, a temporary vulnerability report is cre-
ated if a

SESSION variable taints a sensitive sink.

3.4.3 File Names
To detect taintable ﬁle names, we collect ﬁle paths a user
can write to. For this purpose, new data symbols model
directory resources and their accesses. Whenever a path
is reconstructed only partially, we use the same approach
as in ﬁle inclusion analysis. Here, a regular expression
is created and mapped to all available paths that were
detected when loading the application ﬁles.
Writing To detect a ﬁle name manipulation with user
input, we analyze 27 built-in functions such as copy(),
rename(), and file put contents(). Additionally,
ﬁle uploads with move uploaded file() are analyzed.
Note that at the same time these built-in functions are
sensitive sinks and generate vulnerability reports such as
an arbitrary ﬁle upload vulnerability. The path argument
is analyzed by conventional context-sensitive string anal-
ysis.
If the path is tainted, we store it with its preﬁx
as taintable. When no preﬁx is present, the ﬁle path of
the currently analyzed ﬁle is taken. Additionally, if the
source is not sanitized against path traversal attacks, all
paths are assumed as taintable and a ﬂag is set during
analysis accordingly.
Reading We handle three different ways of opening a
directory with PHP’s built-in functions. First, we model
the built-in function scandir() that returns an array,
listing all ﬁles and directories within a speciﬁed path.

USENIX Association  

23rd USENIX Security Symposium  995

7

Second, we model the built-in function glob() that also
returns an array that lists all ﬁles and directories speci-
ﬁed by a pattern. We transform the pattern into a regular
expression by substituting the pattern characters * and
? into regular expression equivalents. Third, we model
the built-in function opendir() which returns a direc-
tory handle. For all mentioned built-in functions, we re-
construct the opened path by string analysis and return a
ResourceDir symbol that stores the path’s name.
Access The returned result of scandir() and glob()
is accessed by an array key. Since we do not know nei-
ther the amount nor the order of ﬁles in a directory, we
return a DataPath symbol whenever a ResourceDir
symbol is inferred from an ArrayDimFetch symbol, re-
gardless of its dimension. For this purpose, we let the
built-in function readdir() that is supposed to read an
entry of a directory handle return an ArrayDimFetch
symbol with an arbitrary dimension and the name of the
directory handle.
It is inferred to a DataPath symbol
when the trace of the ArrayDimFetch symbol results in
a ResourceDir symbol.
Sanitization In order to model sanitization that checks
if a given string is a valid ﬁle name, 11 built-in functions
such as file exists and is file() are simulated. We
modiﬁed the sanitization check in a way that these func-
tions only sanitize if there is no taintable ﬁle path found.
For this purpose, a ﬂag is set during taint analysis if san-
itization of a source by ﬁle name is detected. The ﬂag
issues only a temporary vulnerability report that is re-
vised at the end of the analysis regarding the ability to
taint a ﬁle path.

3.4.4 Multi-Step Exploits
In order to detect multi-step exploits, we store all ta-
ble names of all writing SQL queries that are affected
by SQLi. Furthermore, we set a ﬂag during the analy-
sis process if an arbitrary ﬁle write or arbitrary ﬁle re-
name vulnerability is detected. At the end of the analysis,
when the taint decision is made for data that comes from
a PDS, multi-step exploit reports are added to the initial
vulnerability. This is done for all vulnerabilities that rely
on a DataDB symbol that is not tainted through second-
order but which table name is affected by SQLi. Also,
a multi-step exploit is reported if a DataDir symbol oc-
curs and the ﬂag for a ﬁle rename vulnerability was set.
All session data is treated as tainted if an arbitrary ﬁle
write vulnerability was detected. Additionally, any local
ﬁle inclusion vulnerability is extended to a remote code
execution if a ﬁle write or upload feature is detected.

Moreover, a SQLi vulnerability within a SELECT
query returns a DataDB symbol with a taint ﬂag. This
ﬂag indicates that all accessed columns are taintable by
modifying the SELECT query during an attack. Thus, all
columns of the DataDB symbol are taintable.

Inter-procedural PDS Analysis

3.5
We optimized the inter-procedural analysis to reﬁne our
string analysis results. Function summaries offer a high
performance but they are also inﬂexible for functions
with dynamic behavior. Thus, they can weaken the static
reconstruction of dynamically created strings.

3.5.1 Multiple Parameter Trace
As we illustrated in Listing 5, modern applications of-
ten deﬁne wrapper functions for PDS access where more
than one parameter is used within one sensitive sink. In
this case, the approach of storing each parameter together
with its preﬁxed and postﬁxed markup, and the corre-
sponding vulnerability type as sensitive parameter in the
function summary, is error-prone. When a call to this
function occurs, the approach swaps the parameter sym-
bol with the argument of the function call and traces it for
user input. While this approach works ﬁne for vulnera-
bility detection, it leads to imprecision when it comes to
string reconstruction. Because each argument is traced
separately but both are used in the same sink, the result
of one trace is missing in the result of the other trace. In
Listing 5, for example, the table name is missing in the
reconstructed query while the data is reconstructed from
the new user array.

To circumvent this problem, we reﬁned this approach
for sinks that execute SQL queries or open ﬁle paths
within a user-deﬁned function. If multiple parameters or
global variables are involved, all symbols are combined
to one ValueConcat symbol. Then this symbol is stored
in the function summary and analyzed for each function
call. This way, each parameter is traced within one anal-
ysis and all results are present at the same time.

3.5.2 Mapping Returned Resources
Working with function summaries is very efﬁcient when
it comes to performance because each function only re-
quires a single analysis on the ﬁrst call. For every other
call, the function summary is reused. However, a user-
deﬁned function might return a resource that has dif-
ferent properties for each call. For example, a SELECT
query that embeds the parameter of an user-deﬁned func-
tion as the table name returns a different ResourceDB
symbol for every call, depending on the function’s ar-
gument. If the resource is returned by the user-deﬁned
function, its symbol’s properties change for every differ-
ent function call.

As a solution, we add empty ResourceDB symbols
to the function summary’s set of return values for user-
deﬁned functions with dynamic SQL queries. Once the
sensitive parameters are analyzed and the queries are re-
constructed, a copy of these symbols is updated with the
table and column information and used as returned data.

996  23rd USENIX Security Symposium 

USENIX Association

8

4 Evaluation

For evaluating our approach, we selected six real-world
web applications. We chose the conference management
systems OpenConf 5.30 and HotCRP 2.61 for their pop-
ularity in the academic ﬁeld and osCommerce 2.3.3.4 for
its large size. Furthermore, we evaluated the follow-up
versions of the most prominent software used in related
work [3, 11, 30, 31]: NewsPro 1.1.5, MyBloggie 2.1.4,
and Scarf 2007-02-27.

A second-order vulnerability consists of two data
ﬂows: tainting the PDS and tainting the sensitive sink.
We evaluated our prototype for both steps and present the
true positives (TP) and false positives (FP) in this section.
In addition, we discuss the root cause for false negatives
(FN) and outline the limitations of our approach.

4.1 PDS Usage and Coverage
To obtain an overview of the usage of PDS in web appli-
cations, we manually evaluated the total amount of dif-
ferent memory locations. Note that these numbers do not
reﬂect how often one memory location is used at run-
time. Then, we evaluated the ability to taint these mem-
ory locations by an application’s user and compared it
to the detection rate of our prototype. A PDS is deﬁned
as taintable if it can contain at least one of the follow-
ing characters submitted by an application user: \<>’".
In total, we manually identiﬁed 841 PDS of which 23%
are taintable. Our prototype successfully detected 71%
of the taintable PDS with a false discovery rate of 6%.

4.1.1 Databases
Our implementation successfully recovered the database
schema for all tested applications during the initializa-
tion phase. For evaluation, we categorized all avail-
able columns in the application’s database schema by de-
clared data type. Only columns with a string type, such
as VARCHAR or TEXT, are of interest because they can
store tainted data. As shown in Table 1, we found that
on average about half of the columns are not taintable
due to numeric data types such as INT and DATE.

Table 1: Column types in selected applications.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total

50
29
18
8
7
4
116

Tables Columns Num String
138
75
81
25
15
14
45%

193
142
48
18
22
10
55%

331
217
129
43
37
24
781

We then carefully fuzzed a local instance of each
application manually with common attack payloads in
order to determine which columns of type string are
taintable. Furthermore, we observed which columns
were reported by our prototype implementation as
taintable when the schema is available and when not. The
results are compared in Table 2. Among the columns
with a string type, 53% are taintable. As a result, only
24% of all available columns are not sanitized by the ap-
plication or the columns’ data type.

Table 2: Taintable columns in selected applications.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total

Taintable
63
43
47
12
10
9
184

Schema
TP
FP
4
55
1
27
16
1
0
12
1
10
9
0

No schema
TP
FP
37
55
3
27
16
4
0
12
3
10
9
0
70% 5% 70% 27%

For the rather old and simple applications, all taintable
columns were detected by our prototype. The modern
and large applications often use loops to construct dy-
namic SQL queries where reconstruction is error-prone.
Overall, we detected 70% of all taintable columns. When
the database schema is known, 5% of our reports are FP.
The root cause is path-sensitive sanitization of data that
is written to the database—a sanitization that our current
prototype is not able to detect yet. The false discovery
rate is higher if the database schema of an application is
not found. In this case, a static analysis tool cannot rea-
son about data types within the database and may ﬂag
columns of numeric data type as taintable.

4.1.2 Sessions
To obtain a ground truth for our evaluation, we again
manually assessed the applications’ code for all accessed
keys of the superglobal
SESSION array. Dynamic keys
were reconstructed and keys in multi-dimensional arrays
were counted multiple times. Then, we manually exam-
ined which session keys are taintable by the application’s
user and compared this to the analysis result generated by
our prototype implementation. As shown in Table 3, we
found that only 12% of the 52 identiﬁed session keys are
taintable within our selected applications.

Our prototype correctly detected all taintable session
keys. One FP occurred because the sanitized email ad-
dress of a user is written to the session after it is fetched
from the database. This FP is based on the previously
introduced FP in identifying taintable columns. A cus-
tom session management in osCommerce led to exclu-
sion from our evaluation.

USENIX Association  

23rd USENIX Security Symposium  997

9

Table 3: Taintable session keys in selected applications.

Software
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total

Keys Taintable
2
2
1
0
1

TP
2
1
1
0
1

FP
0
0
0
1
0
12% 83% 16%

29
14
2
4
3
52

4.1.3 File Names
To evaluate the features that allow an application’s user
to alter a ﬁle name, we again manually assessed each
application for ﬁle upload, ﬁle creation, and ﬁle rename
features and counted the different target paths to obtain
a ground truth. Next, we counted the collected taintable
path names reported by our prototype. The results are
shown in Table 4.

Table 4: Taintable paths in selected applications.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total

Paths Taintable
2
0
0
0
1
2

TP
2
0
0
0
1
2

FP
0
0
1
0
0
0
63% 100% 16%

2
1
1
1
1
2
8

We found at least one feature in each of the applica-
tion’s source code to create a new ﬁle. However, half of
the applications sanitize the name of the ﬁle before cre-
ating it. Our prototype detected all taintable path names.
One FP occurred for OpenConf, where uploaded ﬁles are
sanitized in a path-sensitive way.

Interestingly, a ﬁle upload in Scarf

is based on a
second-order data ﬂow. The name of the uploaded ﬁle is
speciﬁed separately and stored as a conﬁguration value
in the database before it is read from the database again
and the ﬁle is copied. Because no sanitization is applied,
an administrator is able to copy any ﬁle to any location of
the server’s ﬁle system which leads to remote code exe-
cution. This critical vulnerability was missed in previous
work that also used this application for evaluating their
approach [3, 31].

false discovery rate of 21% (see Table 5 for details).
In summary, 97% of the valid reports are persistent
XSS vulnerabilities where the payload is stored in the
database. Five persistent XSS vulnerabilities are caused
by session data or ﬁle names. This is closely related to
the fact that 94% of all taintable PDS we identiﬁed are
columns in database tables (see Section 4.1) and sensi-
tive sinks such as echo are one of PHP’s most prominent
built-in features [10].

Table 5: Evaluation results for selected applications.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total
Average

Files
570
74
121
23
19
58
865
144

LOC
66 381
40 339
20 404
5 077
1 686
9 485
143 372
23 895

FP
TP
29
97
1
1
4
16
1
7
8
37
0
1
159
43
79% 21%

FN
6
0
0
0
3
0
9

Our evaluation revealed that second-order vulnerabil-
ities are highly critical. Next to persistent XSS and ﬁle
vulnerabilities, we detected various remote code exe-
cution vulnerabilities in osCommerce, OpenConf, and
NewsPro. In the following, we introduce two selected
vulnerabilities to illustrate the complexity and severity
of real-world second-order vulnerabilities. It is evident
that these vulnerabilities could only be detected with our
novel approach of analyzing second-order data ﬂows.

4.2.1 Second-Order LFI to RCE in OpenConf
OpenConf
is a well-known conference management
software used by many (academic) conferences. Our
prototype found a second-order local ﬁle inclusion vul-
nerability in the user-deﬁned printHeader function that
leads to remote command execution. The relevant parts
of the affected ﬁle include.php is shown in Listing 6.

function="0") {

GLOBALS[ OC_configAR ][ OC_headerFile ];

require_once

GLOBALS[ pfx ] .

1 function printHeader( what,
2
3
4 }
5
6
7
8 while ( l = mysql_fetch_assoc( r)) {
9
10 }
11 printHeader();

OC_configAR[ l[ setting ]] =

r = mysql_query("SELECT

setting ,

value ,

parse

FROM

" . OCC_TABLE_CONFIG . " ");

l[ value ];

4.2 Second-Order Vulnerabilities
We evaluated the ability of our prototype to detect
second-order vulnerabilities. Reports of ﬁrst-order vul-
nerabilities are ignored for now. Our prototype reported
a total of 159 valid second-order vulnerabilities with a

Listing 6: Simpliﬁed include.php of OpenConf.

When looking at the code, it does not reveal any vul-
nerability. Whenever the code is included, settings are
loaded from the database and the user-deﬁned function
printHeader() is called. This function includes a con-
ﬁgured header ﬁle and prints some HTML.

998  23rd USENIX Security Symposium 

USENIX Association

10

value = " . safeSQLstr(trim( value)) . "

setting = " . safeSQLstr( setting) ."

";

value) {

" . OCC_TABLE_CONFIG . "

q = "UPDATE

SET
WHERE

return(ocsql_query( q));

1 function updateConfigSetting( setting,
2
3
4
5
6 }
7
8 foreach (array_keys( _POST) as
9
10
11
12 }

if (preg_match("/^OC_[\w-]+ /",

updateConfigSetting( p,

p) {

}

p)) {
_POST[ p]);

getTemplate = mysql_query("SELECT name,template
FROM

unp_template

template

LIMIT 1");

while ( temp = mysql_fetch_array( getTemplate)) {
temp[ template ];

DB;

global

templatecache,

1 function unp_printTemplate( template) {
2
3
4
5
6
7
8
9 }
10 eval(
11

templatecache[ template] =

headlines_displaybit = "

WHERE name=

.

}
return addslashes( templatecache[ template]);

unp_printTemplate( headlines_displaybit ). "; );

Listing 7:
OpenConf.

Simpliﬁed code to change settings in

However, as shown in Listing 7, it is possible for a
privileged chair user to change any conﬁguration setting.
The conﬁguration page does not specify an input ﬁeld to
change the headerFile setting. Nonetheless, by adding
the key OC headerFile to a manipulated HTTP POST
request, the setting is changed. The loop over the sub-
mitted keys of the
POST array in Listing 7, line 8, as
well as the loop over the OC configAR in Listing 6,
line 9, shows once again how important it is to track the
taint status of PHP’s array keys precisely.

A chair member can now include any local ﬁle of the
system to the output. Additionally, because the software
allows to upload PDF ﬁles to the server, our prototype
added a multi-step exploit report. Indeed, if a PDF ﬁle
containing PHP code is uploaded to the server and the
headerFile setting is pointed to that PDF, arbitrary PHP
code is executed. Moreover, our tool reported a SQL
injection vulnerability that is accessible to unprivileged
users. This allows any visitor to extract the chair’s pass-
word hash (salted SHA1) from the database.

4.2.2 Second-Order RCE in NewsPro

Utopia NewsPro is a blogging software and was used in
previous work for evaluation [29–31]. Our prototype re-
ported a second-order code execution vulnerability in the
administrator interface. Here, a user is able to alter the
template ﬁles of the blog. The simpliﬁed code is shown
in Listing 8.

1
2
3
4

tempid = (int) _POST[ tempid ];
template = mysql_real_escape_string( _POST[ template ]);
updateTemplate = mysql_query("UPDATE

unp_template

SET template=

template

WHERE id=

tempid ");

Listing 8: Simpliﬁed code to change the template in
NewsPro.

Listing 9:
vulnerability in NewsPro.

Simpliﬁed Remote Code Execution

At the call-site,

the fetched template is evaluated
with PHP’s eval operator that executes PHP code
(line 10). The template’s code is escaped (line 8),
however, the double-quoted value of the evaluated vari-
able headlines displaybit allows to execute arbi-
trary PHP code using curly syntax. By adding the code
{ {system(id)}} to a template, the system command
id is executed. Note that related work missed to detect
this vulnerability, which is also present in prior versions.

4.3 Multi-Step Exploits

Our prototype reported two arbitrary ﬁle upload vulner-
abilities and 14 SQL injection vulnerabilities. Because
these vulnerabilities affect a storage operation, the stored
data can be manipulated during multi-step exploitation.
Our prototype found 14 valid multi-step exploits and a
single FP as shown in Table 6.

Table 6: Reported multi-step exploits in selected appli-
cations.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total
Average

SQLi

File
TP
1
0
0
0
1
0
2

Multi-Step
FP
TP
3
0
1
0
0
1
0
9
1
0
0
0
14
1
100% 71% 29% 93% 7%

TP
3
1
4
6
1
5
20

FP
0
7
1
0
0
0
8

The template code is read from the database in various
places of the source code with help of the user-deﬁned
function unp printTemplate() (see Listing 9). First,
this function writes the template’s code to a cache array
(line 6) and then returns it from this array again. The
example demonstrates the importance of inter-procedural
analysis and array handling.

All detected multi-step exploits consist of two steps
and no third-order vulnerabilities were detected within
our selected applications. In the following, we examine
two multi-step exploits in osCommerce that lead to re-
mote command execution to illustrate that these vulnera-
bilities can only be detected with our novel approach of
analyzing multi-step exploits.

USENIX Association  

23rd USENIX Security Symposium  999

11

4.3.1 Multi-Step RCE in osCommerce
OsCommerce is a popular e-commerce software. For
one of three reported SQLi vulnerabilities in osCom-
merce, our prototype additionally reported a multi-step
remote code execution exploit. The SQLi is located in
the backup tool of the administrator interface and shown
in Listing 10. Here, a SQL ﬁle is uploaded to restore a
database backup. Since the name of the uploaded ﬁle
is later used unsanitized in a SQL query, an attacker
is able to insert any data into the configuration ta-
ble by uploading a SQL ﬁle with a crafted name. This
enables another, more severe vulnerability:
the table
configuration stores a configuration value and a
configuration title for each setting. Furthermore, a
use function can be speciﬁed optionally to deploy the
conﬁguration’s value.

sql_file->filename;

sql_file = new upload( sql_file );
read_from =

1
2
3 tep_db_query("insert into " . TABLE_CONFIGURATION .
4
5
6

read_from . " ,
0 , null, now(),

Last Database Restore ,

" values (null,

Last database restore file ,

" .
6 ,

,

)");

DB_RESTORE ,

Listing 10: Simpliﬁed code of the backup.php ﬁle in
osCommerce shows a SQLi through a ﬁle name.

When the list of conﬁguration values is loaded
from the database,
the function name speciﬁed
in the use function column is called with the
configuration value as argument (see Listing 11,
line 5). An attacker can abuse the SQLi to insert
an arbitrary PHP function’s name, such as system, to
the column use function and insert an arbitrary argu-
ment, such as id, to the column configuration value.
When loading the conﬁguration list, the speciﬁed func-
tion is fetched and called with the speciﬁed argument that
executes the system command id.

1

conf_query = tep_db_query("select configuration_id,

configuration_title, configuration_value,
use_function from " . TABLE_CONFIGURATION . " where
configuration_group_id =

" . (int) gID . " ");

if (tep_not_null( configuration[ use_function ])) {

2 while ( configuration = tep_db_fetch_array( conf_query)) {
3
4
5
6

use_function =
cfgValue = call_user_func( use_function,

configuration[ configuration_value ]);

configuration[ use_function ];

Listing 11: Simpliﬁed code of the conﬁguration.php ﬁle
in osCommerce demonstrates a multi-step RCE.

4.3.2 Sanitization Bypass in osCommerce
Another multi-step RCE exploit was reported in osCom-
merce that involves a sanitization bypass. The previously
mentioned backup tool of the administrator interface al-
lows to specify a local ZIP ﬁle that is unpacked via the
system command unzip. Here, the target ﬁle name is
speciﬁed as an argument in the command line if the spec-
iﬁed ﬁle name exists on the ﬁle system. The simpliﬁed
code is shown in Listing 12.

1 if (file_exists(DIR_FS_BACKUP .
2
3

restore_file = DIR_FS_BACKUP .

exec(LOCAL_EXE_UNZIP .

.

HTTP_GET_VARS[ file ])) {
HTTP_GET_VARS[ file ];

restore_file .

-d

.

DIR_FS_BACKUP);

4 }

Listing 12: A dynamically constructed system command
in osCommerce includes the name of an existing ﬁle.

An attacker can bypass this check by abusing one of
the ﬁle upload functionalities in osCommerce. By up-
loading a ﬁle with the name ;id;.zip and afterwards spec-
ifying this ﬁle as backup ﬁle, the command id is exe-
cuted. The semicolons within the ﬁle name terminate the
previous unzip command and introduce a new command.

4.4 False Positives
Our prototype generated 43 false second-order vulnera-
bility reports, leading to a false discovery rate of 21% for
our selected applications. All false positives are based
on the fact that our prototype is not able to detect path-
sensitive sanitization. Thus, persistent XSS was reported
in Scarf and HotCRP that are based on email addresses
stored in the database. Our prototype erroneously iden-
tiﬁed these columns as taintable (see Section 4.1.1). The
same error applies to a paper format in OpenConf which
leads to four false positives. A user-deﬁned sanitiza-
tion function using path-sensitive sanitization based on
its argument lead to 29 false persistent XSS reports in os-
Commerce. A false multi-step exploit was reported in
HotCRP caused by a false SQLi report. By performing a
path-sensitive sanitization analysis, these false positives
can be addressed in the future.

4.5 False Negatives
Evaluating false negatives is an error-prone task because
the actual number of vulnerabilities is unknown. Further-
more, no CVE entries are public regarding second-order
vulnerabilities in our selected applications. However, it
is possible to test for false negatives that stem from in-
sufﬁcient detection of taintable PDS. By pre-conﬁguring
our implementation with the taintable PDS we identi-
ﬁed manually, we can compare the amount of detected
second-order vulnerabilities with the number of reports
when PDS are analyzed automatically.

As a result, only six previously missed persistent XSS
in osCommerce were reported. Additionally, another
taintable session key in OpenConf was reported, al-
though the key does not lead to a vulnerability. Fur-
thermore, we manually inspected the source code of the
applications and observed that our SQL parser needs im-
provement. Three false negatives occurred in Scarf be-
cause our parser does not handle SQL string functions
such as concat(). More complex SQL instructions
might lead to further false negatives but are used rarely.

1000  23rd USENIX Security Symposium 

USENIX Association

12

4.6 Performance
We evaluated our prototype with the implementation
of our approach to detect second-order vulnerabilities
(+SO) and without it (-SO). Our testing environment was
equipped with an Intel i7-2600 CPU with 3.4 GHz and
16 GB of memory. The amount of memory consump-
tion (M, in megabytes), scan time (T, in seconds), and
second-order vulnerability reports (R) for our selected
applications are given in Table 7.

Table 7: Performance results for selected applications.

Software
osCommerce
HotCRP
OpenConf
NewsPro
Scarf
MyBloggie
Total
Average

+SO Analysis

-SO Analysis
M[mb] T[s] M[mb] T[s]
213
345
47
3
14
11
633
106

834
752
528
50
39
87
2290
382

134
186
33
1
1
7
362
60

846
775
523
50
40
87
2321
387

R
129
3
21
17
46
1
217
36

While the memory consumption does not increase sig-
niﬁcantly by adding second-order analysis, the average
scan time increases by 40%. Note, however, that this in-
cludes 217 processed vulnerability reports the prototype
would have missed without the additional second-order
analysis. Furthermore, we believe that a total scan time
of less than 11 minutes for our selected applications is
still reasonable.

5 Related Work

Web applications are widely used in the modern Web and
as a result, security analysis of such applications has at-
tracted a considerable amount of research. We now re-
view related work in this area and discuss how our ap-
proach differs from previous approaches.

Dynamic Analysis There are many different dynamic
approaches to perform a security analysis of a given web
application. For example, Apollo [1] leverages symbolic
and concrete execution techniques in combination with
explicit-state model checking to perform persistent state
analysis for session variables in PHP. Sekar proposes
syntax- and taint-aware policies that can accurately de-
tect and/or block most injection attacks [23]. However,
such approaches are typically limited to simple types of
taint-style vulnerabilities.

There are also dynamic approaches to detect second-
order vulnerabilities. For example, McAllister et al.

present a blackbox scanner capable of detecting persis-
tent XSS [19]. Ardilla [14] aims at detecting both SQL
injection and XSS vulnerabilities by generating sample
inputs, symbolically tracking taint information through
execution (including through database accesses), and au-
tomatically generating concrete exploits. The typical
drawbacks of such dynamic approaches are the limited
test coverage and the missing ability to crawl a given
site “deep” enough. This insight is conﬁrmed by Doup´e
et al., who tested eleven black-box dynamic vulnerability
scanners and found that whole classes of vulnerabilities
are not well-understood and cannot be detected by the
state-of-the-art scanners [7].

Static Analysis We perform static analysis of PHP
code and use the concept of block summaries as proposed
by Xie and Aiken [30] and later on reﬁned by Dahse
and Holz [6]. Our analysis tool extends these ideas and
we improved the modeling of the language. More pre-
cisely, we introduce more data symbols (e.g., to analyze
array accesses in a more precise way) and enhance the
analysis of built-in functions such that we can perform
a taint analysis for persistent data stores. Furthermore,
we optimized the inter-procedural analysis to reﬁne our
string analysis results. This enables us to analyze the two
distinct data ﬂows that lead to second-order vulnerabili-
ties: (i) source to PDS and (ii) PDS to sink. As a result,
we are able to detect vulnerabilities missed by these ap-
proaches. Pixy [11] and Saner [2] are other static code
analysis tools for web applications, but both do not rec-
ognize second-order vulnerabilities.

There are static analysis approaches that target other
classes of security vulnerabilities. For example, Safer-
PHP [25] attempts to ﬁnd semantic attacks (e.g., denial
of service attacks due to inﬁnite loops caused by mali-
cious inputs, or unauthorized database operations due to
missing security checks) within web applications. Role-
Cast [24] identiﬁes security-critical variables and ap-
plies role-speciﬁc variable consistency analysis to iden-
tify missing security checks, while Phantm [17] detects
type errors in PHP code. Such kinds of software defects
are out of scope for our analysis.

Static Second-Order Analysis The work closest re-
lated to our approach is MiMoSA [3]. It is an extension
of Pixy [11] to detect multi-module data ﬂow and work
ﬂow vulnerabilities. The data ﬂow through databases is
modeled, however, it uses a dynamic approach for the
reconstruction of SQL queries. Moreover, it focuses on
the detection of the work ﬂow of an application and does
not handle neither other types of PDS nor multi-step ex-
ploits. In comparison, only three data ﬂow vulnerabilities
were detected in Scarf, whereas our approach detected 37
second-order vulnerabilities and one multi-step exploit.

USENIX Association  

23rd USENIX Security Symposium  1001

13

Zheng and Zhang proposed an approach to detect
atomicity violations in web applications regarding exter-
nal resources [31], which can be seen as being closely
related to second-order vulnerabilities since such con-
currency errors are a pre-condition for second-order ex-
ploits. They perform a context- and path-sensitive inter-
procedural static analysis to automatically detect atom-
icity violations on shared external resources. The tools
NewsPro and Scarf are included into their evaluation, but
the authors did not ﬁnd any of the second-order vulnera-
bilities detected by our approach. As such, our approach
outperformed prior work on static detection of second-
order vulnerabilities.

6 Conclusion and Future Work

In this paper, we demonstrated that it is possible to stat-
ically model the data ﬂow through persistent data stores
by collecting all storage writings and readings. At the
end of the analysis, we can determine if data read from
a persistent store can be controlled by an attacker and
if this leads to a security vulnerability. Our prototype
implementation demonstrated that this is an overlooked
problem in practice: we identiﬁed more than 150 vulner-
abilities in six popular web applications and showed that
prior work in this area did not detect these software de-
fects. From a broader perspective, our approach can be
broken down to the problem of statically reconstructing
all strings that can be generated at runtime by the appli-
cation and thus, is limited by the halting problem.

Future work includes modeling the data ﬂow when
prepared statements are used, supporting more SQL fea-
tures, and analyzing data ﬂow through ﬁle content. Also,
path-sensitive sanitization and aliasing should be ana-
lyzed more precisely [32].

References
[1] ARTZI, S., KIEZUN, A., DOLBY, J., TIP, F., DIG, D., PARAD-
KAR, A., AND ERNST, M. D. Finding Bugs in Web Applica-
tions Using Dynamic Test Generation and Explicit-State Model
Checking. IEEE Trans. Softw. Eng. 36, 4 (2010).

[2] BALZAROTTI, D., COVA, M., FELMETSGER, V., JOVANOVIC,
N., KIRDA, E., KRUEGEL, C., AND VIGNA, G. Saner: Com-
posing Static and Dynamic Analysis to Validate Sanitization in
Web Applications. In IEEE Symposium on Security and Privacy
(2008).

[3] BALZAROTTI, D., COVA, M., FELMETSGER, V. V., AND VI-
GNA, G. Multi-Module Vulnerability Analysis of Web-based
Applications.
In ACM Conference on Computer and Commu-
nications Security (CCS) (2007).

[4] BAU, J., BURSZTEIN, E., GUPTA, D., AND MITCHELL, J. State
of the Art: Automated Black-Box Web Application Vulnerability
Testing. In IEEE Symposium on Security and Privacy (2010).

[5] BOJINOV, H., BURSZTEIN, E., AND BONEH, D. XCS: Cross
Channel Scripting and Its Impact on Web Applications. In ACM

Conference on Computer and Communications Security (CCS)
(2009).

[6] DAHSE, J., AND HOLZ, T. Simulation of Built-in PHP Features
for Precise Static Code Analysis. In Symposium on Network and
Distributed System Security (NDSS) (2014).

[7] DOUP ´E, A., COVA, M., AND VIGNA, G. Why Johnny Can’t
Pentest: An Analysis of Black-box Web Vulnerability Scanners.
In Detection of Intrusions and Malware, and Vulnerability As-
sessment (DIMVA) (2010).

[8] GUNDY, M. V., AND CHEN, H. Noncespaces: Using Random-
ization to Enforce Information Flow Tracking and Thwart Cross-
Site Scripting Attacks. In Symposium on Network and Distributed
System Security (NDSS) (2009).

[9] HALFOND, W. G., VIEGAS, J., AND ORSO, A. A Classiﬁcation
of SQL Injection Attacks and Countermeasures. In Proceedings
of the IEEE International Symposium on Secure Software Engi-
neering (2006).

[10] HILLS, M., KLINT, P., VINJU, J., AND HILLS, M. An Empirical
In International Symposium on

Study of PHP Feature Usage.
Software Testing and Analysis (ISSTA) (2013).

[11] JOVANOVIC, N., KRUEGEL, C., AND KIRDA, E. Static Analy-
sis for Detecting Taint-style Vulnerabilities in Web Applications.
Journal of Computer Security 18, 5 (08 2010).

[12] KERNIGHAN, B. W., AND PIKE, R. The Practice of Program-

ming. In Addison-Wesley, Inc (1999).

[13] KHOURY, N., ZAVARSKY, P., LINDSKOG, D., AND RUHL, R.
Testing and Assessing Web Vulnerability Scanners for Persis-
tent SQL Injection Attacks.
In Proceedings of the First In-
ternational Workshop on Security and Privacy Preserving in e-
Societies (2011), SeceS ’11, pp. 12–18.

[14] KIEYZUN, A., GUO, P. J., JAYARAMAN, K., AND ERNST,
M. D. Automatic Creation of SQL Injection and Cross-site
Scripting Attacks. In International Conference on Software En-
gineering (ICSE) (2009).

[15] KIRDA, E., KRUEGEL, C., VIGNA, G., AND JOVANOVIC, N.
Noxes: A Client-side Solution for Mitigating Cross-site Script-
ing Attacks. In ACM Symposium On Applied Computing (SAC)
(2006).

[16] KLEIN, A. Cross-Site Scripting Explained. Sanctum White Paper

(2002).

[17] KNEUSS, E., SUTER, P., AND KUNCAK, V. Phantm: PHP An-
alyzer for Type Mismatch. In ACM SIGSOFT Symposium on the
Foundations of Software Engineering (FSE) (2010).

[18] LIVSHITS, B., AND CUI, W. Spectator: Detection and Contain-
ment of JavaScript Worms. In USENIX Annual Technical Con-
ference (2008).

[19] MCALLISTER, S., KIRDA, E., AND KRUEGEL, C. Leveraging
User Interactions for In-Depth Testing of Web Applications. In
Symposium on Recent Advances in Intrusion Detection (RAID)
(2008).

[20] MICROSOFT DEVELOPER NETWORK LIBRARY. Naming Files,
http://msdn.microsoft.com/

Paths, and Namespaces.
en-us/library/aa365247(VS.85), as of February 2014.

[21] NADJI, Y., SAXENA, P., AND SONG, D. Document Structure
Integrity: A Robust Basis for Cross-site Scripting Defense.
In
Symposium on Network and Distributed System Security (NDSS)
(2009).

1002  23rd USENIX Security Symposium 

USENIX Association

14

[22] SCHOLTE, T., ROBERTSON, W., BALZAROTTI, D., AND
KIRDA, E. An Empirical Analysis of Input Validation Mecha-
nisms in Web Applications and Languages. In ACM Symposium
On Applied Computing (SAC) (2012).

[23] SEKAR, R. An Efﬁcient Black-Box Technique for Defeating Web
Application Attacks. In Symposium on Network and Distributed
System Security (NDSS) (2009).

[24] SON, S., MCKINLEY, K. S., AND SHMATIKOV, V. RoleCast:
Finding Missing Security Checks when You Do Not Know What
Checks Are. In ACM SIGPLAN Conference on Object-Oriented
Programming Systems, Languages, and Applications (OOPSLA)
(2011).

[25] SON, S., AND SHMATIKOV, V. SAFERPHP: Finding Seman-
tic Vulnerabilities in PHP Applications.
In ACM SIGPLAN
Workshop on Programming Languages and Analysis for Security
(PLAS) (2011).

[26] SUN, F., XU, L., AND SU, Z. Client-side Detection of XSS
Worms by Monitoring Payload Propagation. In European Sym-
posium on Research in Computer Security (ESORICS) (2009).

[27] VOGT, P., NENTWICH, F., JOVANOVIC, N., KIRDA, E.,
KR ¨UGEL, C., AND VIGNA, G. Cross Site Scripting Prevention
with Dynamic Data Tainting and Static Analysis. In Symposium
on Network and Distributed System Security (NDSS) (2007).

[28] W3TECHS. World Wide Web Technology Surveys. http://

w3techs.com/, as of February 2014.

[29] WASSERMAN, G., AND SU, Z. Static Detection of Cross-Site
In International Conference on Soft-

Scripting Vulnerabilities.
ware Engineering (ICSE) (2008).

[30] XIE, Y., AND AIKEN, A. Static Detection of Security Vulnera-
bilities in Scripting Languages. In USENIX Security Symposium
(2006).

[31] ZHENG, Y., AND ZHANG, X. Static Detection of Resource Con-
tention Problems in Server-side Scripts. In International Confer-
ence on Software Engineering (ICSE) (2012), pp. 584–594.

[32] ZHENG, Y., ZHANG, X., AND GANESH, V. Z3-str: A Z3-based
String Solver for Web Application Analysis. In Proceedings of
the 2013 9th Joint Meeting on Foundations of Software Engineer-
ing (2013), ESEC/FSE 2013, pp. 114–124.

USENIX Association  

23rd USENIX Security Symposium  1003

15

