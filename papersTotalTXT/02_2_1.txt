A Trusted Safety Veriﬁer
for Process Controller Code

Stephen McLaughlin, Saman Zonouz⇤, Devin Pohly, Patrick McDaniel

Pennsylvania State University, ⇤University of Miami

{smclaugh, djpohly, mcdaniel}@cse.psu.edu, ⇤s.zonouz@miami.edu

Abstract—Attackers can leverage security vulnerabilities in
control systems to make physical processes behave unsafely.
Currently, the safe behavior of a control system relies on a
Trusted Computing Base (TCB) of commodity machines, ﬁre-
walls, networks, and embedded systems. These large TCBs, often
containing known vulnerabilities, expose many attack vectors
which can impact process safety. In this paper, we present the
Trusted Safety Veriﬁer (TSV), a minimal TCB for the veriﬁcation
of safety-critical code executed on programmable controllers. No
controller code is allowed to be executed before it passes physical
safety checks by TSV. If a safety violation is found, TSV provides
a demonstrative test case to system operators. TSV works by ﬁrst
translating assembly-level controller code into an intermediate
language, ILIL. ILIL allows us to check code containing more
instructions and features than previous controller code safety
veriﬁcation techniques. TSV efﬁciently mixes symbolic execution
and model checking by transforming an ILIL program into
temporal execution graph that lumps together safety-
a novel
equivalent controller states. We implemented TSV on a Raspberry
Pi computer as a bump-in-the-wire that intercepts all controller-
bound code. Our evaluation shows that it can test a variety of
programs for common safety properties in an average of less than
three minutes, and under six minutes in the worst case—a small
one-time addition to the process engineering life cycle.

I.

INTRODUCTION

Control systems used in the power grid, industrial au-
tomation, and transportation are fundamental parts of modern
society. Due to their strategic importance and large attack
surfaces, they are becoming attractive targets for attacks lead-
ing to physical damage [16], [29]. Most recently,
it was
revealed that the Stuxnet malware uploaded malicious code to
Programmable Logic Controllers (PLCs) to physically damage
the centrifuges they controlled [11]. A recent study found that
PLC honeypots experienced not only port scanning, but also
attempts at modifying control system speciﬁc protocols and
access to system diagnostics [34]. These vulnerable Internet-
connected controllers are exposed by computer search engines
such as Shodan [1]. This has led to efforts for securing critical
infrastructure based on control systems [17], [31]. Recent
research has demonstrated that attacks against PLCs can be
partially automated [18]. This makes the protection of PLCs

Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1) Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:17)(cid:21)(cid:20)

from malicious code injection of paramount importance.

Past efforts to ensure control system safety have focused on
securing the control system’s Trusted Computing Base (TCB),
the set of hardware and software that must function properly
to ensure safe behavior. Unfortunately, such approaches are
insufﬁcient as software patches are often applied only months
after release [26], and new vulnerabilities are discovered on
a regular basis [4], [23]. Instead, we focus on signiﬁcantly
reducing the TCB size by verifying the safety of control
code immediately before it is executed on the PLC. For our
purposes, a safety property is any temporal property that can
be stated in linear temporal logic. This allows TSV to protect
against malicious behaviors beyond those handled by existing
failsafe mechanisms, such as captive key interlocks. Existing
safety veriﬁcation methods for PLCs suffer from two main
limitations. (i.) Those based on model checking experience the
state explosion problem when dealing with numerical inputs.
(ii.) Previous techniques fail to check code using common PLC
features such as master control relays and non-volatile data
storage (See Section VII).

In this paper, we present the Trusted Safety Veriﬁer (TSV).
TSV reduces the Trusted Computing Base (TCB) for safe
process execution from the entire control system down to the
protected PLC and a single embedded computer administered
through a narrow interface. TSV is deployed as a bump-in-
the-wire that sits between the control system network and the
PLC. All code to be executed on the PLC is ﬁrst checked
against a set of safety properties deﬁned by process engineers.
Examples of safety properties include bounds on numerical
device parameters, e.g., maximum drive velocity and accelera-
tion, and safety interlocks, which ensure physically conﬂicting
events do not occur.

This paper makes the following contributions.
• We introduce TSV as by far the most minimal TCB
proposed to maintain control system safety properties.
Our tool can check a much larger variety of PLC code
•
than any previous safety analysis tool. (See Table I in
Section VII.)
TSV is the ﬁrst binary analysis tool to verify temporal
properties, including for programs that take numerical
inputs.

•

• We fully implement TSV and demonstrate its per-
formance in checking a variety of properties against
different control systems.

TSV works in a number of steps. First, an assembly-level
is translated

PLC program, called an instruction list (IL),

into the Instruction List Intermediate Language (ILIL). ILIL,
which we based on the Vine intermediate language [30],
makes all instruction side-effects explicit, thus maintaining all
information ﬂows between system registers and memory. In
the second step, the ILIL program is symbolically executed
(mixed with concrete executions when values are known) to
produce a symbolic scan cycle, representing all executions
of the code by the PLC. Thus, all inputs which produce an
equivalent symbolic output are lumped together. Third, the
symbolic scan cycle is used to construct a novel Temporal
Execution Graph, (TEG) which represents multiple repeated
executions of the controller code. Finally, the TEG is checked
against a set of safety properties speciﬁed in linear temporal
logic. If any check fails, a counterexample and the offending
instructions are provided to the system operator.

TSV Safety properties are the same as those used by
process engineers in designing the control system. To maintain
the integrity of TSV’s platform, new safety rules should
be updated by a physically present operator with a special
programming device. Given that this only needs to occur when
the physical safety requirements of plant machinery change,
this measure is far less burdensome than some proposed by
large industrial security standards [20].

We implemented a working prototype of TSV on a Rasp-
berry PI embedded computer to check code for Siemens PLCs,
the most widely deployed in the world [28]. We evaluated
TSV on six case studies representing a diverse set of PLC
and control system functionality. These case studies consist of
speciﬁcations and code that is runnable on several of the most
popular PLC architectures. Our implementation can check
for typical safety properties like range violations and safety
interlocks in a few minutes. If a safety check fails, a useful
counterexample and the offending instructions are produced.
By using an intermediate language for our analysis, TSV can
be extended in the future to handle check code for other
proprietary PLC architectures. Because our prototype checks
assembly-level code, it effectively checks any PLC program
written in higher-level or graphical languages like relay ladder
logic, function block diagram, and structured text.

This paper is organized as follows. Section II gives an
introduction to PLCs and lays out our assumed threat model.
Section III gives an overview of TSV’s architecture and use.
Section IV and Section V explain the symbolic execution and
model checking engines in detail. Section VI describes our
prototype implementation and evaluation results. Section VII
covers the related work in control system safety and security,
and Section VIII concludes.

II. BACKGROUND AND THREAT MODEL

A. Programmable Logic Controllers

A Programmable Logic Controller (PLC) is a digital, multi-
input multi-output computer used for real-time automation of
physical machinery. They are used in virtually every control
application from assembly lines to nuclear power plants. The
PLC sits in a tight closed loop with the physical system
it controls. Many times per second, the PLC reads sensor
measurements, calculates the necessary change to the system,
and sends commands to physical machinery to make the

changes. The PLC uses a modiﬁable software program to
perform the second step.

A PLC’s program is executed continuously as long as the
PLC is running. Each execution of the program is called a scan
cycle, and typically lasts several milliseconds. On each scan
cycle, three steps occur. (i.) The sensor inputs are buffered
into the input memory (I). (ii.) The PLC program is executed
to perform calculations based on the input memory and state
from the previous scan cycle. (iii.) The result of the PLC
program is buffered in the output memory (Q), from where it
is transmitted to the plant machinery. In addition to the sensor
and machine interfaces, PLCs have a separate programming
interface, e.g., Ethernet or RS-232 for uploading of new code
and data by process engineers and plant operators. TSV’s job
is to efﬁciently check any code coming over this interface for
safety properties speciﬁc to the plant machinery.

In addition to the typical features found in most instruction
set architectures PLCs employ a number of special features that
TSV must handle.

•

•

Function Blocks. PLCs execute code in discrete
segments called function blocks with ﬁxed entry and
exit points. Each function block has a local memory
that only it can address. This is different from stack
memory in that each function block’s local memory
exists in the same absolute address space, i.e., not
relative to a stack pointer.
Timers. PLCs support hardware timers that evaluate
to a Boolean value. A timer starts when its input
experiences an edge transition. Once the timer has
reached a preset time, its own output goes from low
to high.
Counters. A counter is a value in PLC memory that is
incremented each time a speciﬁed instruction causes
a value to go from low to high. This is useful for
counting events like the number of times an input wire
receives a high signal.
• Master Control Relays. A Master Control Relay
(MCR) deﬁnes a section of PLC code which behaves
differently depending on the value of a speciﬁc input
wire. If the MCR input is false, the code executes
normally. If it is true, certain instructions will output
a zero value. This is done to halt any machinery in
case of an emergency condition.
Data Blocks. PLCs retrieve conﬁguration information
about the physical process from blocks of persistent
storage called data blocks (DBs). Each DB has a
unique integer used to qualify any addresses to its
data. A special kind of DB, called an instance DB
is also used to pass parameters to function blocks.
Edge Detection. Certain PLC instructions will only
execute after a speciﬁc memory value goes from low
to high. This requires the CPU to check for low to
high transitions before any such instruction executes.

•

•

•

B. Threat Model

In modern control system networks, a security ﬂaw in
almost any component can be leveraged to upload malicious
code to a PLC. A clear example of this was the Stuxnet virus,
which used many potential vectors, including the program

2

development environment, to propagate to a PLC-connected
computer [11]. TSV’s aim is to reduce the amount of control
system infrastructure needed to guarantee safe behavior of
PLC-controlled processes to a single embedded computer and
the PLC itself.

It must be possible to notify plant operators when a safety
violation is found in some PLC-bound code. If there is a
rootkit present on a PLC connected computer, then notiﬁca-
tions from TSV may be suppressed at the receiver. To handle
this, we assume that there is some narrow, secure interface
for notiﬁcations. A common way of implementing this in a
control environment could be by way of an analog alarm,
similar to those sounded when a piece of physical machinery
malfunctions. Upon hearing the alarm, plant operators could
directly download the safety counterexample, e.g., via serial
port. In an emergency situation where immediate PLC access
is needed, a physical switch in the plant could be employed
to bypass TSV, similar to the emergency stop buttons on most
heavy machinery.

We also must assume that the interface for uploading safety
properties to TSV is secured. For example, a simple ﬁle format
could be read from a USB key directly by TSV. While the use
of an air-gap may seem to mitigate the advantage of a network
connected PLC, safety properties require modiﬁcation far less
frequently than PLC code. Compared to the large numbers of
requirements in existing industrial security regulations [20],
this is a small additional overhead. We note that TSV is not
secure against a privileged insider with physical access to the
plant ﬂoor.

TSV cannot defend against false data injection attacks,
in which a PLC is given forged sensor data. Additional
defenses already exist for such attacks based on improved state
estimators [5], [27]. Additionally, TSV cannot defend against
PLC ﬁrmware exploitation, in which case the veriﬁed control
logic can be completely bypassed by the compromised PLC.

III. SYSTEM OVERVIEW

Figure 1 shows TSV’s architecture. TSV sits as a bump-
in-the-wire between system operators and the PLC. Any piece
of PLC-bound code is intercepted and checked for safety
properties, previously supplied by process engineers. To test
safety properties written in temporal logic, TSV uses model
checking for part of the veriﬁcation. Model checking suffers
from state space explosion on numerical inputs. For example,
if a PLC program has a single conditional branch depending
on an integer value, the model checker will explore all of the
possibilities, i.e., 232 states. To prevent state space explosion,
TSV ﬁrst performs a symbolic execution of the program to
lump together all inputs that produce the same symbolic output.
The resulting state machine is many orders of magnitude
smaller than the naive approach.

Symbolic execution of the PLC code occurs in two main
steps. First,
the PLC code is lifted into an intermediate
language designed to make the analysis more generic and
explicit. The lifted program is then symbolically executed to
generate a mapping from path predicates to symbolic outputs.
This mapping contains all possible executions of a single scan

PLC Code (IL)

Safety Speciﬁcation

TSV

Instruction Lifting

ILIL Code

Symbolic Execution
Symbolic Scan Cycle
Graph Generation

Temporal Execution Graph

Counterexample

)
l
i

a
F
(

Formal Veriﬁcation

(Pass)

PLC Code

PLC

Fig. 1. TSV Architecture.

cycle1, hence, we refer to it as a symbolic scan cycle. Once
the symbolic scan cycle is calculated, TSV’s model checking
component is invoked. The symbolic scan cycle is an important
step, as it prevents intra-scan cycle property violations from
being rejected by TSV. In other words, if the PLC’s variables
temporarily violate a safety property at some point during
the scan cycle, but the property is not violated when control
signals are sent to physical machinery, then TSV will not reject
the control program. This is an important distinction from
the existing work combining symbolic execution and formal
veriﬁcation.

The formal veriﬁcation component takes a set of temporal
properties, consisting of atomic propositions combined with
temporal qualiﬁers, and veriﬁes they are maintained by a
state-based model of the PLC code. We call this model, the
Temporal Execution Graph (TEG). The TEG is a state machine
in which each state transition represents a single scan cycle.
Each state in the TEG contains the state and output variables
of the PLC program, and a set of Boolean variables for
the atomic propositions. Each Boolean represents whether the
safety property is true or false in that state. If any path is
reachable in which a property is false, then a safety violation
is raised.

The TEG is constructed as follows. An initial state is cho-
sen in which all state and output variables are zero. Recalling
that the symbolic scan cycle maps path predicates to symbolic
values for PLC variables including the output variables, a new
state is generated for each path predicate with its PLC variables
updated according to the corresponding symbolic output. For
each of these newly created states, several more states are
generated with different valuates of the atomic propositions.
The process then repeats on each new state. See Section V-B
for a detailed description of TEG creation.

IV. PLC CODE ANALYSIS

TSV veriﬁes safety properties of PLC code using a com-
bination of symbolic execution and model checking. Tradi-
tional model checking, which explores states exhaustively,

1In practice, it contains all executions that are reachable by scan cycle’s

hard deadline. See Section IV-B.

3

prog ::= inst⇤fun⇤
fun ::= ident(var){inst⇤}
inst ::= cjmp e,e,e | jmp e | label ident | ident := e

e ::= load(ident,addr) | store(ident,addr, int) | e binop e

| call ident(var=e) | ret | assert e
| unop e | var | val | (e)

(And signed versions.)

binop ::= +, ,⇤, /, mod,&,&&, <<, . . .
unop ::=   (Negate),⇠ (Bitwise),! (Boolean)
var ::= ident (: t)
val ::= mem | addr | int (: t)
mem ::= {addr 7! int, addr 7! int, . . .}
addr ::= [int :: int :: . . .]

t ::= reg1 t . . . reg64 t | mem t(int) | addr t

:= 0;
:= 1;

0. // Initialize PLC state.
1. mem := {} : mem_t(1);
2. I
3. Q
4. RLO := 1 : reg1_t;
5. FC
:= 0 : reg1_t;
6. STA := 0 : reg1_t;
7. ...
8.
9. // A I 0.5

// Main memory.
// Input memory qualifier.
// Output memory qualifier.
// Boolean accumulator.
// System status registers.

10. STA := load(mem, [I::0::0::0::5]);
11. cjmp FC == 0 : reg1_t,L1,L2;
12. label L1;
13. RLO := STA;
14. label L2;
15. RLO := RLO && STA;
16. FC
:= 1 : reg1_t;
17. ...
18.
19. // = Q 0.1
20. STA := RLO;
21. mem := store(mem, [Q::0::0::0::1], RLO);
22. FC
23. ...

:= 0 : reg1_t;

// Side effects.

// Side effects.

Fig. 2. Simpliﬁed ILIL Grammar.

Fig. 3.

ILIL Code example (IL in Comments).

suffers from state space explosion when checking programs
with numerical inputs. To reduce the state space, a symbolic
execution of the program is performed ﬁrst to lump together
all inputs that lead to the same symbolic output. The result is a
mapping from path predicates to symbolic outputs. In addition
to the features described in Section II, our analysis addresses
a number of other novel issues.

•

Lack of High-level Languages. PLCs have tradition-
ally been programmed either in assembly language or
in graphical circuit languages like relay ladder logic.
The graphical languages are mere sugar used to make
the assembly appear like a circuit, and they add no
additional semantic information. We are thus forced
to do binary or assembly-level analysis.

• Hierarchical Addresses. PLC addresses are not just
integer values. They are preﬁxed by an architecturally
ﬁxed number of namespace qualiﬁers. When analyzing
indirect addressing, we must not only consider byte
address pointers, but also indirect references to differ-
ent namespace qualiﬁers.

• Multi-indexed Memory. While most hardware mem-
ories only support a single size of memory access,
e.g., byte or word addressing, some PLC memories
can be addressed at the word-, byte-, and bit-level.
This should not be confused with loading different
sized registers from a byte address. Multi-indexed
memory complicates the dynamic taint analysis needs
for mixed execution.

Symbolic execution of IL programs happens in two stages.
First,
the IL program is lifted into the ILIL intermediate
languages for PLC code. Second, a mixed symbolic and
concrete execution of the ILIL program is done to generate
path predicates that feed into the model checking steps.

A. Instruction List Intermediate Language

Directly analyzing an IL program would be prohibitively
difﬁcult. IL syntax and semantics vary widely by vendor, and

IL instructions have side effects that can obscure certain con-
trol ﬂows. For these reasons, we introduce the IL Intermediate
Language (ILIL) as a basis for our analysis. ILIL is based on
the Vine Intermediate Language [30] (Hereafter, Vine) used
for binary code analysis. We extend Vine to handle several
PLC-speciﬁc features described below. A simpliﬁed grammar
for ILIL is shown in Figure 2. Vine features such as casts and
memory endianness are omitted for space sake. The full ILIL
semantics are in Appendix B.

An ILIL program is a set of top-level instructions followed
by function deﬁnitions. This may seem strange for a binary
analysis, but there are two reasons for the distinction. First,
PLC code begins execution in an Organization Block (OB),
akin to the entries in an operating system’s interrupt vector.
OBs are implemented in top-level code. Second, on some
architectures, OBs make additional calls to function blocks.
For each function call, additional ILIL code is generated to
handle the parameter passing.

ILIL uses the two basic Vine types registers and memories.
A single register variable is used to represent each CPU register
in a particular PLC architecture. They are implemented as
bit vectors of size 1, 8, 16, 32, and 64 bits. Memories are
implemented differently than in Vine. ILIL Memories are
mappings from hierarchical addresses (See next paragraph.) to
integers. Memory loads return the integer for a given address.
Memory stores return a new copy of the memory with the
speciﬁed location modiﬁed.

In addition to registers and memories, ILIL adds a third
type, addresses. In Vine, memories are mappings from integers
to integers. This is reasonable as most architectures use 32- or
64-bit address registers. This is not sufﬁcient for PLCs which
use hierarchical addresses. A hierarchical address has several
namespace qualiﬁers before the actual byte or bit address. For
example, in Siemens PLCs, addresses have a single namespace
qualiﬁer called a memory area. In Allen Bradley, there are
three: rack, group, and slot. ILIL addresses are essentially
integer lists where the leftmost n entries represent
the n
namespace qualiﬁers. We also extend the memory type to
include n. Thus, the ILIL statement:

4

mem := {} : mem_t(1);

initializes an empty memory with a single namespace qualiﬁer.
In some cases, all or part of an address will be stored in
memory. To handle loads and stores of hierarchical addresses,
we extend the Vine cast expression to convert addresses to
byte sequences. Note that the number of namespace qualiﬁers
preﬁxing an address is architecturally ﬁxed, so the number of
types is ﬁnite.

ILIL instructions have no side effects, making all control
ﬂows explicit. As an example, Figure 3 shows the lifted version
of the IL instructions:

A I
= Q

0.5
0.1

;; And input bit 5
;; Store at output bit 1

First, the machine state is conﬁgured to have a single main
memory and two memory areas for input and output. Part of
the deﬁnition of the system status word is also shown. The
And instruction consists of three parts. The operand is loaded
from memory, combined with an accumulator, and one or more
status words are updated. The address [I::0::0::0::5] is
read, “memory area I, dword 0, word 0, byte 0, bit 5.” This
convention of listing offsets of different sizes allows us to
canonically address multi-indexed memories.

The PLC features from Section II-A, as well as several
other issues, are handled by IL to ILIL translation as follows.

Timers. For each timer, an unused memory address is allo-
cated. During symbolic execution, an attempt to check the
timer value at this address will generate a fresh symbol. In
the model checking step, this symbol will be nondeterministic,
i.e., it will cause both paths to be explored if used in a branch
condition. A similar approach was used by SABOT [18],
though our semantics are more ﬂexible in allowing for the
case where the timer value changes within a scan cycle, not
just between them.

Counters. Counters are implemented in a straightforward
manner. For each counter, a memory word is allocated to
handle the current value. ILIL instructions are added to check
if the counter’s condition has transitioned from low to high
each time a counter instruction is executed. Once the counter
reaches a preset value, attempts to access its address in the
counter memory area will return the concrete value true.

Master Control Relays. When an MCR section is reached, a
conditional branch is generated depending on the MCR status
bit. The false branch contains the original code, and the true
branch contains code that modiﬁes instruction results. While
the semantics differ by architecture, typically numerical and
Boolean instructions all output 0 or false when the MCR is
active.

Data Blocks. Data blocks are implemented using the hier-
archical address type. When a program opens a data block, a
namespace qualiﬁer is created with the index of that data block,
e.g., DB3. When an access is made into the datablock, the ad-
dress is prepended with the qualiﬁer, e.g.,, [DB3::20::1] for
word 41. Each data block is populated with any conﬁguration
data blocks accompanying the PLC code.

Edge Detection. For each bit of memory that is checked for a
low-to-high edge transition, ILIL code is generated to monitor
that bit across scan cycles. If an edge is detected, a separate
bit address is set to true. This address is then checked before
any dependent instructions are executed.

Flow-sensitive Optimizations. During instruction lifting, ad-
ditional control ﬂows are added to the program. For example,
after an integer addition, an overﬂow check is added, setting
several status registers to either 0 or 1. To prevent additional
control ﬂows from leading to path explosion, we only include
such checks when a subsequent instruction has an explicit data
dependency on the result. For example, if two additions are
done in a row followed by a jump that checks an overﬂow
status ﬂag, only the overﬂow check of the second addition
will be included in the lifted code.

Memory Tags. PLCs use strings, sometimes called tags,
as human-readable labels on memory locations. A group of
tags may be referenced by a single name. This leads to a
complicated issue with function block parameter passing. If the
name of a tag group is passed to a function, the PLC performs
a pass-by-value of all tags in the group. As we would like to
expose such execution semantics to our analysis, ILIL code
is generated to do a pass-by-value of each tagged memory
location in the group.

B. ILIL Symbolic Execution

TSV symbolically executes an ILIL program to produce
a mapping from path predicates to symbolic outputs. This
mapping, called the symbolic scan cycle, describes all possible
executions of a single PLC scan cycle. Fresh symbols are
allocated the ﬁrst time a previously unwritten memory location
is accessed. Thus,
then a
new symbol I 0 0 0 2 will be generated and used each
subsequent time that same location is read.

if a sensor input I0.2 is read,

Symbolic execution follows all possible paths through a
single scan cycle of the program. An SMT solver is used to
ensure only feasible paths are followed. Loops are followed
for a constant number of iterations. Because PLC scan cycles
are terminated at a hard deadline, this number of iterations
can be set high enough to ensure TSV explores all iterations
that are reachable by the deadline. PLCs allow function calls
by indirect reference, e.g., call FB [MD 0] where the function
block number is stored in MD 0. Fortunately, if MD 0 contains a
symbolic value, there is only a small number of possible func-
tions it could resolve to, making the jump successor problem
more tractable. Symbolic execution must handle two additional
challenges, register type inference and mixed execution.
Register Type Inference. Typically, binary analysis is done
on bit vectors using the register sizes of the target architecture.
This is sufﬁcient for PLC analysis, except in the common
case of real-valued computations. While bit vectors will not
work here, we would still like to make some safety assertions
about real-valued PLC outputs. TSV relies on opcodes to infer
which symbols are real-valued. Initially, all symbols start as
uninitialized. The ﬁrst time an instruction is executed on that
symbol, or a variable that symbol propagated to, it is assigned
either real or bit vector, depending on the opcode. This has the

5

minor limitation that if both a real-valued and non-real-valued
instruction are executed on the same symbol, the symbolic
machine gets stuck. This is however, not common. A symbol’s
type can be changed only by a cast instruction in the original
IL code.
Mixed Execution. PLC programs make heavy use of constants
as process parameters. Thus, many instructions can be executed
on concrete operands instead of symbolically. Like previous
tools, such as Rudder [30], TSV performs a mixed symbolic
and concrete execution. An expression produces a concrete re-
sult iff all its variables are concrete. This requires dynamically
tracking whether each register and memory word is concrete
or symbolic. There is a complication here for multi-indexed
memories, which can be accessed at the word-, byte-, or bit-
level. To handle this, TSV tracks each bit of memory as either
symbolic or concrete. Initially, all memory is concrete, and
typical taint propagation rules are used to track symbolic bits.
We add an additional rule to allows a bit to become concrete
again. If a sequential string of symbolic bits are overwritten
by a equal or longer string of concrete bits, then the whole
string becomes concrete.

V. MODEL CHECKING

Because PLCs use stateful variables, that retain their val-
ues across the scan cycles, analysis of a single scan cycle
is not sufﬁcient to check all temporal safety properties. In
this section, we describe our technique of model checking a
temporal execution graph for paths on which safety properties
are violated. The results of symbolic execution are used to
ﬁrst construct the TEG to model the state transitions occurring
over a scan cycle. Each node of the TEG is then productized
with valuations of the atomic proposition in the linear temporal
logic (LTL) safety property. Finally, the symbolic variables are
removed from each state to produce an abstract graph, which is
fed to the model checker. Before exploring this process in more
detail, we brieﬂy review LTL as used for safety speciﬁcations.

A. Linear Temporal Logic

To formulate control system security requirements, TSV
makes use of the linear temporal logic formalism [2], [25].
Let us deﬁne A to be a ﬁnite set of atomic logical propositions
about the system {b1,b2,··· ,b|A|}, e.g., relay R1 is open.
and S = 2A a ﬁnite alphabet composed of the abovementioned
propositions. Every element of the alphabet is a possibly empty
set of propositions from A, and is denoted by ai, e.g., ai =
b1,b4,b9.

The set of linear temporal logic-based safety requirements

is inductively deﬁned by the grammar

j ::= true | b | ¬j | j_ j | j U j | X j,

(1)
where ¬ and _ denote negation and logical OR operators.
ji U j j denotes “the LTL expression ji remains true until j j
becomes true,” and X j j reads “j j must be true in the next
step (execution state)”. TSV also makes use of the following
redundant notations: j ^ y instead of ¬(¬j _ ¬y), j ! y
instead of ¬j_ y, F j (Eventually) instead of true U j, and
G j (Globally) instead of ¬(true U ¬j). For example, consider
a trafﬁc light system with Boolean variables g1 and g2 that

activate green lights for intersecting streets when true. The
property that both lights are never green at the same time has
two atomic propositions: a ⌘ g1 = true, and b ⌘ g2 = true. The
global LTL property is then stated G ¬a _ ¬b.
B. Temporal Execution Graph

Each state in the execution graph stores the symbolic
value of each stateful PLC variable. It is noteworthy that
TSV performs intermediate variable elimination during the
temporal execution graph generation to make sure that values
of the symbolic variables are terms over only constants and
time-indexed input variables corresponding to PLC input wires
scanned during some PLC input-output scan in the past, i.e.,
there is no intermediate variable involved in the symbolic val-
ues of the variables. To clarify, consider a symbolic execution
output entity with the assignment statements O := X + 2 and
X := I + X where O and I are output and input variables,
respectively. All variables are initialized to 0 before the ﬁrst
scan cycle. After the ﬁrst scan cycle the variables will have
values: O   I0 + 2 and X   I0, where I0 denotes the input
variable scanned before the ﬁrst PLC execution iteration.
Similarly, the second scan will result in O   I0 + I1 + 4 and
X   I0 + I1. The ﬁnal expression for O no longer contains X.
The state transitions of the temporal execution graph indi-
cate the feasible paths between scan cycles. Each transition is
labeled by the path predicate from one entry in the symbolic
scan cycle. A transition is added from a source to destination
state iff the path predicate can be satisﬁed given the symbolic
values of PLC variables in the source state. For instance, if the
source state has PLC variables2 O   I0 +I1 +4, X1   I0 +I2,
and X2   I0 + I1, given the path predicate X1   X2, then a
transition is added because the path predicate is satisﬁable
under the symbolic values at the source state and the input
values, i.e., I2   I1.
C. Speciﬁcation-Based Model Reﬁnement

To check temporal properties, a model checker needs
to know the truth value of each atomic proposition of the
given LTL requirement in each state. The addition of these
truth values to the TEG is called model reﬁnement that is
described separately here for presentation clarity; however,
the model reﬁnement occurs concurrently during the TEG
generation (Section V-D). The motivation for this step is that
it is impossible to pick a single truth value for an atomic
proposition containing symbolically valued PLC variables. In
such cases, each state in the TEG is replicated to a set of
states for all feasible truth values of the atomic propositions
in those states. TSV accordingly updates each replica’s path
predicate, which captures the input variable conditions for the
execution to get to that state, based on the assigned concrete
Boolean atomic proposition values. In particular, TSV labels
each replica with a conjunctive predicate composed of the
state’s original predicate P and the predicate representing the
concrete atomic proposition values assigned to the replica.
For instance, in the case of a single atomic proposition a,
the two state replicas will be assigned P&a and P&!a as
their predicates. Figure 4 shows a more illustrative example

2Note that sub-indices and super-indices represent different variables and

scan cycle numbers, respectively.

6

PLC$IL$(pseudo-code):$
if#(10#<#input)#
########input#/=#2;#
output#=#input#+#6;#

Abstract$TEG$Graph$

IL@to@ILIL##
Transla<on#

ILIL$Program:$
…#
input#/=#2;#
…#

Symbolic#
execu<on#

Temporal$Execu9on$Graph$(TEG)$

10<input#

output!input/2+6#

output!input+6#

LTL_SPEC:#G#!a#
a:=#(output>12)#

10<input<=12#

12<input#

input<=6#

6<input<=10#

a=0$

a=1$

a=0$

a=1$

#

n
o
<
c
a
r
t
s
b
A

Reﬁned$TEG$Graph$

10<input#

input<=12#

Input<=6#

output!input/2+6;##

a=0$

output!input/2+6;##

a=1$

output!input+6;##

a=0$

output!input+6;#

#a=1$

Fig. 4. Example TEG generation for checking of an LTL property.

where the original IL code assigns the output variable value
depending on the input variable value. After the IL-to-ILIL
conversion, TSV employs the generated TEG graph (for a
single scan cycle) along with the given safety requirement
to determine concrete atomic proposition values. In particular,
each node in the TEG becomes two nodes in the Reﬁned Graph
to model both valuations of proposition a. Consequently, TSV
further abstracts the reﬁned TEG graph to only include the
information that is sufﬁcient for the formal veriﬁcation phase
(Section V-E).

D. TEG Generation Algorithm

This section describes in details the procedure for TEG
generation (Algorithm 1)3. The main inputs to the algorithm
are i) symbolic scan cycle set ssc, i.e., symbolic execution
outputs that are mappings from path predicates to symbolic
PLC variable values; ii) the safety speciﬁcation of the under-
lying physical system j, and iii) the termination deadline g
for the TEG generation algorithm. TSV parses the given LTL
safety formula to get the corresponding atomic propositions4
(Line 1). The TEG generation algorithm starts with initializing
the TEG state space W by creating an initial state s where all
of the PLC variables/predicates are reset to zero/true (Lines
2-7) that happens when the PLC loads the controller code for
the ﬁrst time.

the initial state s;

Regarding the TEG state notion, each state includes three
types of information: i) spredicate denotes the logical predicate
as the result of symbolic execution of branch/jump instructions
that has been accumulated in the current state through the
state transition sequence starting at
ii)
svar values indicates the symbolic variable values that have been
initiated in the current state; and iii) sprop values represents the
concrete Boolean value vector for the atomic propositions in
the current state. For the initial state5, given the reset concrete
variable/predicate values,
the concrete values for the LTL
atomic propositions A are calculated and stored in sprop values
(Line 6); however, for other states storing symbolic values,
TSV takes a different approach to assign concrete atomic
proposition values as discussed below. The TEG state space

3A concrete example for the symbolic execution and formal veriﬁcation of
a given controller program is described in Appendix A.
4Note that “ ” denotes an assignment.
5It
the function GenTEG takes a Boolean argument
initial GenTEG call that denotes whether this is the ﬁrst call in the recur-
sion chain. Due to presentation simplicity, the variable is not listed in the
algorithm’s input list explicitly.

is assumed that

Algorithm 1: GenTEG

9 foreach Path predicate p 2 ssc do

: The Symbolic scan cycle ssc
: The LTL safety speciﬁcation j
: The TEG generation deadline g

Input
Input
Input
Output: The generated temporal execution graph TEG
1 A   get atomic propositions(j)
2 s   create initial state()
3 if initial GenTEG call then
4
5
6

spredicate   inilialize predicate(True)
svar values   inilialize PLC variables(False)
sprop values  
concretize atomic propositions(svars values, A)
Ws   s
We   /0
symbolic values   ssc [p]
foreach a 2 2A do
t   spredicate V predicate(a, A) V p
if ¬satisﬁable(t) then
s0   create state()
[s0predicate,s0prop values]   [t,a]
s0var values  
update(svar values,symbolic values)
s00   ﬁnd equivalent state(W,s0)
if s00 6= NULL then
else

delete(s0)

continue

s00   s0

Ws   Ws [ {s00}
We   We [ {(s ! s00)}
if g < elapsed time then

return

GenTEG(ssc,j,s00)

7
8

10
11
12
13
14

15
16
17

18
19
20

21
22

23
24
25
26

27

Ws and set of transitions We are also initialized to the initial
state s and empty set, respectively, during the initial function
call (Line 7-8).

Following the algorithm, a transition is then added for each
(path predicate, symbolic output values) mapping in the sym-
bolic scan cycle ssc (Line 9) that is satisﬁable given the vari-
able values in the initial state s. The algorithm goes through

7

a nested loop (Line 11) to be able to assign concrete Boolean
values for each atomic proposition on every generated TEG
state (Section V-C). TSV produces the conjunctive predicate t
using i) the accumulated state predicate; ii) the path predicate
p from ssc; and iii) the concrete atomic proposition vector a
(Line 12). The satisﬁability check is performed in Line 13 that,
if satisﬁable, allows TSV to create the corresponding state s0
(Lines 15-17) and transition, and update TEG (Lines 23-24).
The update function (Line 17) creates the symbolic variable
values for the new state s0. It takes the symbolic variable
values in the source state svar values, that captures the PLC’s
current memory state, as well as the symbolic values from
the corresponding program control path in ssc (Line 10).
Consequently, the update function performs the intermediate
variable elimination step (Section V-B) to get rid of interme-
diate variables in the ssc symbolic values, and stores the result
in the new state’s symbolic variable values s0var values.

There is a case in which the state will not be added even
when the path predicate is satisﬁed. If the TEG already con-
tains a state with PLC variables equivalent to the destination
state (Line 18), then a transition is added back to the existing
state, and the new destination is discarded (Line 20). Two states
are considered equivalent if their PLC variables have equal
symbolic values. This step enables TSV to avoid unnecessary
state space size increase, and hence improves the formal
veriﬁcation efﬁciency. It is noteworthy that to decrease the
false negative rates of the state equivalence checking function,
TSV checks for equality after simplifying the symbolic values.
For instance, TSV will mark the X1   I0
k and
X2   4 · I0
k + 2 as equal after the simpliﬁcation of those
expressions’ abstract syntax trees.

k + 2 + 3 · I0

Finally, TSV calls the TEG generation function GenTEG
recursively to explore next possible states starting the recently
explored state s00. The recursive graph generation procedure
returns under two conditions. First, the procedure returns if
all of the states are created and the graph is completely
generated. This is the ideal return condition as the complete
graph will result in accurate model checking results with a
counterexample. Second, the procedure returns of the explored
depth, i.e., the number PLC input-output scans, exceeds a
predeﬁned bound value (Line 25). This results in a partially
generated temporal execution graph that is later used for formal
model checking. The bounded graph generation is a suitable
solution when the size of the program is large and complete
graph generation is too costly.

To summarize, TSV strives for minimality of model state
space through three approaches. (i.) Symbolic execution lumps
as many concrete input values (and hence, scan cycles) to-
gether as possible. (ii.) In the reﬁnement step, a truth value for
a proposition is only added if it is feasible transitioning from
the previous state. (iii.) As a measure of last resort, TSV will
perform bounded model generation when the TEG’s diameter
becomes too large.

E. Malicious Code Discovery

TSV uses the abstract TEG to perform LTL-based model
checking [8] that either allows the code to run on the PLC

after passing all checks, or returns a counterexample to sys-
tem operators in the event that a violation is found. More
speciﬁcally, the model checker veriﬁes whether the reﬁned
temporal execution graph contains any paths in which a
temporal property fails to hold. Given a temporal predicate f ,
TSV negates f 6 and generates a tableau T(¬ f ). The tableau
is a state-based automaton that satisﬁes every sequence of
words that satisfy ¬ f . Here, a word is an truth assignment to
all atomic propositions in f . TSV then computes the product
automaton P of T and the TEG. If an accepting path is found
in P, then the values of atomic propositions along that path
form a counterexample for the temporal property f .

The counterexample can be used to locate the offending
lines of code or control ﬂows in the original PLC program. In
the event of malicious code injection, this could shed light on
the attackers motives, and if a safety violation occurred due to
an error, operators can take corrective actions. We demonstrate
this functionality in Section VI-C.

VI. EVALUATION

We now wish to investigate TSV’s efﬁcacy in checking
typical safety properties against a representative set of PLC
programs. In particular, we designed a set of experiments
to verify whether TSV can be useful in real-world practical
scenarios by answering the following questions empirically:
How accurately do the employed model checking techniques
in TSV verify whether a given PLC code is compliant with the
requirements? How efﬁciently does TSV complete the formal
veriﬁcation steps for an uploaded PLC code? How well can
TSV scale up for complex security requirements? We start
by describing the experimentation control system case studies,
and then proceed to examine these questions.

A. Implementation

We implemented TSV on a Raspberry Pi embedded com-
puter running Linux kernel 3.2.27. The IL7 lifting is imple-
mented in 2,933 lines of C++ code, the symbolic execution in
11,724 lines of C++ code, and the TEG generation in 3,194
lines of C++ code. In addition, TSV uses the Z3 theorem
prover [9] both for checking path feasibility during symbolic
execution, and for simplifying symbolic variable values during
TEG construction. NuSMV is used for model checking of the
reﬁned TEG [12]. In the case of a safety violation, Z3 is used
to ﬁnd a concrete input for the path predicate corresponding
to the offending output.

B. Control System Case Studies

To make sure that TSV can be used for practical safety
veriﬁcation of real-world infrastructures, we deployed TSV
on several real-world Siemens PLC programs for different

6In our implementations, before the logic negation, the given LTL formula
is ﬁrst reduced to the corresponding computation tree logic formula [3]. We
ﬁnd the details outside the scope of this paper and the interested reader is
referred to [8].

7To support other programming languages, a new source code lifter needs
to be developed to generate the ILIL code. However, due to the syntactical
similarities between most of existing PLC programming languages, the lifter
may not be needed to be developed from scratch.

8

Desktop$Computer$
Raspberry$Pi$

industrial control system settings. Our examples are runnable
on several of the most popular PLC architectures8.

0.1$

0.01$

%
)
s
d
n
o
c
e
s
(
%
e
m
T

i

0.001$

!
s
d
n
a
s
u
o
h
T

!
)
s
d
n
o
c
e
s
(
!
e
m
T

i

!

10000$
1000$
100$
10$
1$
0.1$
0.01$
0.001$

%

%

e
z
i
S
e
c
a
p
S
e
t
a
t
S

%

1000"

100"

10"

1"

1"

1$

0.1$

0.01$

%
)
s
d
n
o
c
e
s
(
%
e
m
T

i

0.001$

1$

2$

3$

4$

5$

6$

7$

8$

9$

10$

11$

12$

13$

14$

Bounded%Model%Genera4on%Depth%
(d) Model Translation

100$

10$

1$

0.1$

Desktop$Computer$
Raspberry$Pi$

&

&

i

e
m
T
g
n
i
k
c
e
h
C

&
l

&
)
s
d
n
o
c
e
s
(

e
d
o
M

0.01$

0.001$

1$

2$

3$

4$

5$

6$

7$

8$

9$

10$

11$

12$

13$

14$

Bounded&Model&Genera8on&Depth&

(e) Symbolic Model Checking

Fig. 5. Performance Analysis of the Trafﬁc Light Control System.

1$

2$

3$

4$

5$

6$

7$

8$

9$

10$

Bounded%Model%Genera4on%Depth%

(a) Initial Model Creation

Desktop$Computer$
Raspberry$Pi$

1$

2$

3$

4$

5$

10$
Bounded!Model!Genera5on!Depth!

6$

7$

8$

9$

11$

12$

13$

14$

11$

12$

13$

14$

(b) Temporal Execution Graph Generation

10000"

Desktop"Computer"
Raspberry"Pi"

2"

3"

4"

5"

6"

7"

8"

9"

10"

11"

12"

13"

14"

Bounded%Model%Genera3on%Depth%
(c) Temporal Execution Graph Cardinality

Desktop$Computer$
Raspberry$Pi$

•

•

•

•

•

•

PID controller. (Proportional Integral Derivative) The
most common type of controller for real-valued states.
A PID controller attempts to minimize the error be-
tween the actual state, e.g., the temperature in a room,
and a desired state. This is done by adjusting a con-
trolled quantity, e.g., heating element, by a weighted
sum of the error, and its integral and derivative.

•

Safety requirement: (i.) The controlled quantity
may not exceed a constant value.

Trafﬁc light. Trafﬁc lights at a four way intersection
are governed by Boolean output signals, with a single
Boolean value for each color and direction. Light
changes are timer-based.

•

Safety requirements:
(i.) Orthogonal green
lights should not be ON simultaneously, i.e.,
G¬(g1^g2) where Boolean variable gi denotes
the i-th green light. (ii.) A red light should
always be proceeded by a yellow light.

Assembly way. Items are moved down an assembly
line by a belt. A light barrier detects when an item
has arrived at an assembly station, and an arm moves
to hold the item in place. A part is then assembled
with the item, and the barrier removed. The process
repeats further down the line.

•

Safety requirements: (i.) No arm can come
down until the belt stops moving. (ii.) The belt
should not move while the arm is down.

Stacker. A series of items are loaded onto a platform
by a conveyor belt. Once a light barrier detects that the
platform is full, the items are combined by a melter,
and the resulting product is pushed onto a lift and
lowered for removal.

•

Safety requirements: (i.) The product should
never be pushed out while the melter is work-
ing. (ii.) No more items should be loaded once
the platform is full.

Sorter. A conveyor belt passes packages by a barcode
scanner. Depending on the scanned code, one of three
arms extends to push the package into an appropriate
bin.
•

Safety requirements: (i.) No more than one arm
should extend at each time instant. (ii.) An
arm extends only after the barcode scanning
is complete.

Rail Interlocking. As opposed to the other programs,
which drive the actions of a system, a railway inter-
locking checks that a sequence of engineer commands
will not cause conﬂicting routes between two or more
trains.

8Speciﬁcally, the Instruction List samples run on Siemens and Rockwell

PLCs accounting for 50% of PLC market share [28].

9

S0

<a:1 b:1>

True

S1

<a:1 b:1>

True

S2

<a:1 b:1>

True

S3

<a:1 b:1>

~((~ X41) && X43 && (~X44)) 

~((~ X41) && X43 && (~X44)) 

~((~ X41) && X49 && (~X44)) 

S4

<a:1 b:0>

S5

<a:0 b:1>

S6

<a:1 b:1>

Fig. 6. Generated Temporal Execution Graph (model checking bound = 4).

•

Safety requirements: (i.) There should never be
conﬂicting routes. (ii.) No inputs are read after
the checking procedure starts execution.

C. Example Safety Violation

To demonstrate the full usage of TSV, we show the
steps that occur when attempting to upload code containing
a safety violation. For this example, we modiﬁed the trafﬁc
light controller to switch both directions to green after cycling
through the correct states once. Speciﬁcally, we appended the
following code to the trafﬁc light program.

... original program ...

RESET
A M 0.5
JC ATTACK
JMP END
ATTACK:
SET
= Q 0.0
= Q 0.3
END: NOP

;; Reset logic accumulator.
;; Check for trigger state.
;; Jump to attack code (if triggered).
;; Skip attack code.

;; Set first green light.
;; Set second green light.

The malicious program was analyzed by TSV against an
interlock property prohibiting both lights from being simul-
taneously green. The model checker produced the concrete
counterexample:

Cycle

1
2

1
f

2
f

Timer
3
4
f
f

5
f

6
t
f

This states that a violation was detected on the scan cycle
where light timers 1-5 are false, and timer 6 switches from
true to false. The next step is to identify the line of code
where the violation occured. First, the ILIL interpreter preloads
the concrete counterexample values for each timer variable.
Next, the ILIL version of the program is instrumented with an
assertion of the violated property after each line:

assert load(mem, [Q::0::0::0::0]) == 0 : reg1_t ||

load(mem, [Q::0::0::0::3]) == 0 : reg1_t;

This simply states that at least one of the output memory loca-
tions for green lights must be off. The instrumented program
is then executed with the concrete timer values. The assertion
fails exactly after the line that stores 1 in [Q::0::0::0::3].
If the operator so desired, an execution trace of instructions

and memory values leading up to this point could also be
produced. Even if the original IL program is obfuscated, the
ability to execute on a concrete counterexample will quickly
point system operators to the offending instruction.

The example above veriﬁes the state invariants for a simple
safety requirement only for presentation clarity. However, as
discussed later, TSV veriﬁed our case study PLC programs for
more complex temporal safety requirements (Section VI-B)
using the execution history information across input-output
scan cycles that was encoded in the generated TEG graph.

D. Performance

We measured the run times for individual TSV components
while checking the safety properties for each test case. Figure 5
shows the results for a sample use case (the trafﬁc light control
system) for up to 14 steps during bounded model generation.
This allows for exploration of control systems with up to 14
consecutive unique state outputs. This is signiﬁcantly more
than Stuxnet’s malicious code, which used a state machine with
three unique outputs to manipulate centrifuge speed [11]9. One
could imagine an attack that evades detection by counting to
15 before violating a safety property. In this case, any control
logic capable of producing a non-repeating chain of more than
14 unique outputs could also be rejected. This bound could
be set higher if required for the legitimate plant functionality.
The results are shown for running TSV on a desktop computer
with a 3.4 GHz processor and Raspberry Pi with a 700 MHz
processor.

The initial processing of the symbolic scan cycle is shown
in Figure 5(a). For all cases,
this step requires less than
22ms. Once TSV creates the initial PLC program models,
it starts building the temporal execution graph, which is the
main source of overhead. Figure 5(b) shows how long TSV
needs to complete the graph generation phase. The majority
of time in this phase is spent performing recursive exploration
of the TEG to set concrete values for atomic propositions.
A complete graph generation for 14 input-output scans takes
2 and 17 minutes on a desktop computer and Raspberry
Pi respectively. However, as expected, trimming the analysis
horizon limit to 10 reduces the graph generation time re-
quirement signiﬁcantly—down to < 10 seconds on a desktop
computer and 1 minute on Raspberry Pi. Figure 5(c) shows
the corresponding state space sizes for the generated graphs.

9We are currently working with several parties to obtain a disassembled

copy of Stuxnet’s PLC code.

10

%
)
s
d
n
o
c
e
s
(
%
e
m
T

i

100$

10$

1$

0.1$

0.01$

0.001$

IL'to'ILIL$Transla0on$

Symbolic$Execu0on$

Ini0al$Model$Crea0on$

Temporal$Execu0on$
Graph$Genera0on$

Model$Transla0on$

Symbolic$Model$Checking$

PLC%Program%Analysis%and%Formal%Veriﬁca9on%Steps%

Traﬃc$Light$

Assembly$Way$

Stacker$

Sorter$

Train$

PID$

Traﬃc"Light"

Assembly"Way"

Stacker"

Sorter"

Train"

PID"

'
s
e
t
a
t
S
'
f
o
'
r
e
b
m
u
N

1000"

100"

10"

1"

State"Space"Size"

PLC'Program'Analysis'and'Formal'Veriﬁca<on'Steps'

Fig. 7. Time Requirements for All Case Studies on Raspberry Pi.

The reported numbers, only 4K states for a full 14 horizon
analysis, proves the effectiveness of the usage of symbolic
execution at reducing the state space size.

the input values affect

Figure 6 shows a sample generated execution graph for
the Assembly Way case study with a model checking bound
of 4. The safety requirement included two atomic propositions
a and b. Thus, each state is assigned with a pair of concrete
atomic propositions, and the state transitions are labeled with
the path predicates as Boolean expressions in inﬁx order. For
readability purposes, we did not include the symbolic variables
and their values in each state. The atomic propositions are
both true regardless of the input values in states S0, S1,
S2, and S3. However,
the atomic
propositions starting in state S3. Out of S3’s four possible
children, |{a,b}|2 = 4, three have been created. Only the path
condition for ha : 0 b : 0i was not satisﬁable.
TSV runs the symbolic model checking engine on the re-
ﬁned and atomic proposition-level abstract temporal execution
graph. Figure 5(d) shows the run times to translate the abstract
TEG into the model checker’s syntax, which is not a signiﬁcant
source of overhead. Figure 5(e) shows the time requirement
results for the symbolic model veriﬁcation that takes no more
than 10 and 90 seconds, on the desktop and Raspberry Pi
respectively. In summation, the total average overheads of less
than three minutes for checking with bound 10 are within
reason for an analysis that is only executed once when new
code is uploaded. Of course, in the case of malicious code
uploading, this bound does not affect productivity, as safety
checks are done independently of plant execution under the
previous, legitimate code.

We ran the same experiments for all of our case studies.
Figure 7 shows how much each analysis step contributes to
veriﬁcation for each case study on the Raspberry Pi with
bound 6. Requirements for each step vary due to different
factors. The costliest test case for symbolic execution was the
AssemblyWay, which explored the most feasible paths. The
single costliest operation was construction of the TEG for the
train interlocking. This was caused by checking the feasibility
of very large path predicates in the symbolic scan cycle.
Despite the variance between use cases, it is clear that the
net overhead is within reasonable bounds for all case studies.
Figure 8 shows the state space cardinality for the generated
temporal execution graphs for the case studies. It is noteworthy
that there is not a direct correlation between the state space
size and the overall analysis time requirement, e.g., the Train
case study results in the smallest state space and yet requires

Fig. 8. State Space Size for All Case Studies on Raspberry Pi.

the largest amount of time to ﬁnish the overall analysis.

E. Scalability

it

that

is crucial

To make sure that TSV can be used for real-world PLC
code veriﬁcations,
it can handle safety
properties of realistic sizes, i.e., number of atomic propo-
sitions, efﬁciently. To that end, we investigated typical and
frequently-used linear temporal logic-based software speciﬁ-
cation formula10 [10], where the largest predicate includes
5 atomic propositions. Figure 9 shows the results of our
experiments with TSV that can handle requirement predicates
with 9 atomic propositions within approximately 2 minutes
on average. It is noteworthy that handling additional safety
properties only requires rerunning the atomic proposition value
concretization on the temporal execution graph. Consequently,
the time requirement to process every new security predicate is
often negligible because the execution graph generation is the
dominant factor in TSV’s overall performance overhead (see
Section VI-D).

VII. RELATED WORK

We now review several previous approaches to safety
veriﬁcation of PLC software. The set of approaches reviewed
here represent the most applicable in terms of ability to run
directly on PLC code without requiring engineers to author an
additional high-level system model. As shown in Table I, our
approach can check more features than any previous approach
to PLC analysis. Existing tools for binary analysis of general
purpose programs are omitted as they do not handle PLC
architectural traits like multi-indexed memories.

10http://patterns.projects.cis.ksu.edu/documentation/patterns/ltl.shtml.

11

TABLE I.

COMPARISON OF ANALYZED FEATURES WITH RELATED WORK. RELATED APPROACHES ARE ABBREVIATED: SAT=SAT SOLVING,

THM=THEOREM PROVING, MOD=MODEL CHECKING

Approach

SAT
SAT
Thm
Thm
Mod
Mod

-

Park et al. [22]
Groote et al. [14]
Homer [15]
Biha [21]
SABOT [18]
Canet et al. [6]
TSV

X
X
X
X
X
X
X

Logic
Boolean
Enum

Branching
Blocks
Function
Cond.
MCR

Numeric

X
X
X
X

X
X

X

X
X
X
X

X

X

Logic
Timers
Nested
X
X
X
X

X

Detection
Edge

Blocks
Data

Counters

Pointers

X

X

X

X

tems, distributed control systems, and PLCs. Such guidelines
are also used in the energy industry [20], [32]. It has, however,
been argued that compliance with these standards can lead to
a false sense of security [24], [33].

There have also been efforts to build novel security mech-
anisms for control systems. Mohan et al. [19] introduced a
monitor that dynamically checks the safety of plant behavior.
A similar approach using model based intrusion detection was
proposed in [7]. Goble [13] introduce mathematical analysis
techniques to evaluate various aspects, such as safety and
reliability, of a given control system including the PLC devices
quantitatively. However, the proposed solution focuses mainly
on accidental failures and does not investigate intentionally
malicious actions.

Compared with existing binary analysis tools, TSV is more
apt for verifying temporal properties. For example, platforms
such as BitBlaze [30], are aimed mainly at comparing binary
programs, identifying malicious behavior, and exploit genera-
tion. Additionally, compared with the existing work combining
symbolic execution and model checking to reduce state space
explosion, TSV is the only solution enabling binary-level
analysis.

PLC vendors themselves have included some rudimentary
security measures into their solutions. Based on market data by
Schwartz et al. [28], we studied the security measures used by
PLCs accounting for 74% of market share. This included PLCs
from Siemens (31%), Rockwell (22%), Mitsubishi Electric
(13%), and Schneider Electric (8%). We found that all four
vendors use only password authorization,
typically with a
single privilege level. Furthermore, password authentication
measure can be disabled in all four systems. Additionally,
certain Siemens systems use client-side authentication. This
allows the attacker to completely bypass authentication by
implementing his own client for uploading malicious code.

VIII. CONCLUSIONS

In this paper, we presented TSV, a trusted veriﬁcation
platform for programmable logic controllers, that allows last
step security veriﬁcation of the control commands right before
they affect the physical system. TSV achieves a reasonable
efﬁciency via using a new hybrid symbolic execution-enable
model checking algorithm. We implemented a real-world pro-
totype of the TSV framework on an independent Raspberry PI
chip with minimal attack surface. Our evaluation results shows

Fig. 9. Scalability Analysis for Various Predicates

The most basic approaches are those using SAT-based
model checking. Park et al. [22] handle only Boolean logic.
This had the advantage of being able to analyze larger
sequence-based control systems, but is only narrowly appli-
cable. Groote et al. [14] employs a similar technique, but
is able to handle timers by modeling the exact wall clock
execution time. This assumes that the approximate time taken
for each scan cycle is known, and fails if scan cycle times
vary too greatly depending on input. An improved handling
of timers can be found in SABOT [18], which models their
termination as a nondeterministic Boolean value. Additionally,
TSV’s improvements over SABOT allow for virtually all PLC
programs to be analyzed, as opposed to exclusively Boolean
variables and timers, which SABOT is limited to.

implement numerical

The two theorem proving based approaches [15], [21]
handle numerical instructions, but not do not implement rules
for overﬂow checks or mixed bit vector and integer arithmetic.
The model checking approach used by Canet et al. [6], uses
the same modeling as TSV for conditional branches, but does
not
instructions, which lead to state
space explosion. Our use of symbolic execution eliminates
this explosion problem. TSV’s ability to handle more PLC
features (in most cases all available features) than previous
work is thanks to the use of ILIL, which reduces side effects
that would otherwise require many high-level modeling rules
into a small set of low-level primitives.

We now review some representative past efforts at securing
control systems. Stouffer et al. [31] present a series of NIST
guideline security architectures for the industrial control sys-
tems that cover supervisory control and data acquisition sys-

12

0.001 0.01 0.1 1 10 100 1000 1 2 3 4 5 6 7 8 9  Time (seconds) Predicate Size (# atomic propositions) Temporal Execution Graph Generation Symbolic Model Verification that TSV can be deployed as a bump-in-the-wire portable
device for efﬁcient and practical veriﬁcation of the control
programs before they are uploaded to programmable logic
controllers.

ACKNOWLEDGEMENTS

This material is based upon work supported by the Ofﬁce
of Naval Research under Award Number N00014-12-1-0462,
and Advanced Research Projects Agency-Energy under Award
Number 20130028603. The authors would like to thank Tim
Yardley for his constructive comments and technical help with
the project.

REFERENCES
[1] Shodan. http://www.shodanhq.net, 2013.
[2] Andreas Bauer, Martin Leucker, and Christian Schallhart. Runtime
ACM Transactions on Software

Veriﬁcation for LTL and TLTL.
Engineering and Methodology, 20(4):14:1–14:64, 2011.

[3] Mordechai Ben-Ari. Mathematical logic for computer science. Springer,

2012.

[4] Dillon Beresford. Exploiting Siemens Simatic S7 PLCs. In Black Hat

USA, 2011.

[5] Rakesh B. Bobba, Katherine M. Rogers, Qiyan Wang, Himanshu
Khurana, Klara Nahrstedt, and Thomas J. Overbye. Detecting false
data injection attacks on dc state estimation.
In Proceedings of the
First Workshop on Secure Control Systems (SCS), 2010.

[6] G. Canet, S. Coufﬁn, J.-J. Lesage, A. Petit, and P. Schnoebelen. Towards
the Automatic Veriﬁcation of PLC Programs Written in Instruction List.
In IEEE International Conference on Systems, Man, and Cybernetics,
volume 4, pages 2449–2454, 2000.

[7] Steve Cheung, Bruno Dutertre, Martin Fong, Ulf Lindqvist, Keith
Skinner, and Alfonso Valdes. Using Model-based Intrusion Detection
for SCADA Networks. In Proceedings of the SCADA Security Scientiﬁc
Symposium, 2007.

[8] E. Clarke, O. Grumberg, and K. Hamaguchi. Another Look at LTL
In Formal Methods in System Design, pages 415–

Model Checking.
427. Springer-Verlag, 1994.

[9] Leonardo De Moura and Nikolaj Bjørner. Z3: An Efﬁcient SMT Solver.
In Tools and Algorithms for the Construction and Analysis of Systems,
pages 337–340. Springer, 2008.

[10] Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. Patterns
in Property Speciﬁcations for Finite-State Veriﬁcation. In Proceedings
of the 21st international conference on Software engineering (ICSE),
pages 411–420. ACM, 1999.

[11] Nicolas Falliere, Liam O. Murchu, and Eric Chien. W32.Stuxnet
Dossier. Technical report, Symantic Security Response, October 2010.
[12] Orlando Ferrante, Luca Benvenuti, Leonardo Mangeruca, Christos
Sofronis, and Alberto Ferrari. Parallel NuSMV: a NuSMV Extension for
the Veriﬁcation of Complex Embedded Systems. In Computer Safety,
Reliability, and Security, pages 409–416. Springer, 2012.

[13] William M Goble. Control Systems Safety Evaluation and Reliability.

International Society of Automation, 2010.
J.F. Groote, S.F.M. van Vlijmen, and J.W.C. Koorn.
The Safety
Guaranteeing System at Station Hoorn-Kersenboogerd. In Tenth Annual
Conference on Systems Integrity, Software Safety and Process Security,
pages 57–68, June 1995.

[14]

[15] Ralf Huuck. Semantics and Analysis of Instruction List Programs.

Electronic Notes in Theoretical Computer Science, 115:3–18, 2005.
John Leyden. Polish Teen Derails Tram after Hacking Train Network.
http://www.theregister.co.uk/2008/01/11/tram hack/, 2008.

[16]

[17] Patrick McDaniel and Stephen McLaughlin.

Security and Privacy
IEEE Security and Privacy, 7:75–77,

Challenges in the Smart Grid.
2009.

[18] Stephen McLaughlin and Patrick McDaniel. SABOT: speciﬁcation-
based payload generation for programmable logic controllers.
In
Proceedings of the 2012 ACM conference on Computer and commu-
nications security, pages 439–449, New York, NY, USA, 2012.

13

[19] Sibin Mohan, Stanley Bak, Emiliano Betti, Heechul Yun, Lui Sha,
and Marco Caccamo. S3A: Secure System Simplex Architecture for
Enhanced Security of Cyber-Physical Systems. http://arxiv.org, 2012.
[20] National Energy Regulatory Comission. NERC CIP 002 1 - Critical

Cyber Asset Identiﬁcation, 2006.

[21] Sidi Ould Biha. A Formal Semantics of PLC Programs in Coq.

In
IEEE 35th Annual Computer Software and Applications Conference
(COMPSAC), pages 118–127. IEEE, 2011.

[22] Taeshin Park and Paul I Barton. Formal Veriﬁcation of Sequence
Controllers. Computers & Chemical Engineering, 23(11):1783–1793,
2000.

[23] Dale G. Peterson. Project Basecamp at S4. http://www.digitalbond.

com/2012/01/19/project-basecamp-at-s4/, January 2012.

[24] Ludovic Pi`etre-Cambac´ed`es, Marc Trischler, and G¨oran N. Ericsson.
Cybersecurity Myths on Power Control Systems: 21 Misconceptions
and False Beliefs. IEEE Transactions on Power Delivery, 2011.

[26]

[25] Amir Pnueli. The Temporal Logic of Programs. In Proceedings of the
18th Annual Symposium on Foundations of Computer Science, pages
46–57. IEEE Computer Society, 1977.
Jonathan Pollet. Electricity for Free? The Dirty Underbelly of SCADA
and Smart Meters. In Proceedings of Black Hat USA 2010, July 2010.
[27] Henrik Sandberg, Andr´e Teixeira, and Karl H. Johansson. On security
indices for state estimators in power networks. In Proceedings of the
First Workshop on Secure Control Systems (SCS), 2010.

[28] Moses D Schwartz, John Mulder, Jason Trent, and William D Atkins.
Control System Devices: Architectures and Supply Channels Overview.
Jill Slay and Michael Miller. Lessons Learned from the Maroochy Water
Breach.
In Critical Infrastructure Protection, pages 73–82. Springer,
2007.

[29]

[30] Dawn Song, David Brumley, Heng Yin,

Ivan
Jager, Min Gyung Kang, Zhenkai Liang, James Newsome, Pongsin
Poosankam, and Prateek Saxena. BitBlaze: A New Approach to Com-
puter Security via Binary Analysis.
In Information systems security,
pages 1–25. Springer, 2008.

Juan Caballero,

[31] Keith Stouffer, Joe Falco, and Karen Scarfone. Guide to Industrial
Control Systems (ICS) Security. NIST Special Publication, 800:82,
2008.

[32] U.S. Department of Energy Ofﬁce of Electricity Delivery and Energy
Reliability. A Summary of Control System Security Standards Activities
in the Energy Sector, October 2005.
Joe Weiss. Are the NERC CIPS making the grid less reliable. Control
Global, 2009.

[33]

[34] Kyle Wilhoit. Who’s Really Attacking Your ICS Equipment. Trend

Micro, 2013.

A. Example Property Check

APPENDIX

In this section, we provide a simple property check in-
volving TSV’s main four steps executed over the trafﬁc light
controller code. For the code, and intermediate artifacts: ILIL
code, symbolic scan cycle, and TEG, are all too long to ﬁt in
the space provided, so we provide illustrative examples from
each.

The trafﬁc light control program manipulates a set of
Boolean variables, Q 0.0 - Q 0.5 representing the six lights
facing two opposing directions. This is done in two steps. First,
a set of internal state variables, denoted by M 0.x, track which
state the system is in. The duration of each system state is
dictated by a timer T x. Second, each light is turned on only
if one or more state variables tell it to. As an example of
the ﬁrst step, the following statement checks whether a light
needs to change from red to green based on a timer expiring.
(The “check not ﬁrst run” instruction makes sure that the PLC
was not just turned on.) The lines marked “bookkeeping” are
needed to decompile the program into a graphical language.

A(
O
O
ON
)
AN
=
A
BLD
=
A
L
SD

T
M
M

6
0.0
0.6

;; Check red light timer.
;; Check already green.
;; Check not first run.

1

20.0
20.0

0.0
20.0

T
L
L
102
M
L
S5T#10S
T

1

;; Check green light timer.
;; Bookkeeping.
;; Bookkeeping.
;; Bookkeeping.
;; Set green light state.
;; Bookkeeping.
;; 10 second timer.
;; Start green light timer.

The green light itself is then activated by the statement:

A
=

M
Q

0.0
0.2

;; Check for green state.
;; Activate green light.

The lifted version of above two lines of code is as follows.

0.0

// (9) AND M
STA := cast(low, reg1_t, load(mem, [M::0::0::0::0]));
RLO := RLO && STA;
FC := 1 : reg1_t;
OR := 0 : reg1_t;

0.2

// (10) ST Q
OR := 0 : reg1_t;
STA := RLO;
FC := 0 : reg1_t;
mem := store(mem, [Q::0::0::0::2], RLO);

The resulting symbolic scan cycle constraint for the green light
is as follows.

// The green output variable.
(declare-const Q_0_0_0_2 Bool)

// The state variable.
(declare-const M_0_0_0_0 Bool)

[M_0_0_0_0] -> (and (or (or T_6 M_0_0_0_0)

(not M_0_0_0_6)) (not T_1))

[Q_0_0_0_2] -> (M_0_0_0_0)

Consequently, TSV made use of the produced symbolic
scan cycle to generate its corresponding temporal execution
graph with 24 states that is partially shown in Figure 10. Here,
we also show how the usage of symbolic state matching to
avoid creation of equivalent states helps TSV to save the TEG
memory requirement and consequently improve the overall
TSV performance. Figure 11 illustrates the generated TEG
graph with 12 states partially for the same controller program
while the symbolic state matching engine was on. As shown,
several states in Figure 10 have been lumped together in
Figure 11 as the result of being equivalent. Because of such
state lumpings, there are several states with more than one
incoming transitions. The generated TEG graphs with larger
model generation bounds resulted in the same growth pattern
of 4 states per depth11, i.e., the graph size grows linearly for
this particular case with the model generation bound because
of condition-free controller program.

Finally, TSV employed the generated TEG graph (Fig-
ure 11) to verify whether the safety requirement holds if

11For presentation clarity, we did not include the generated TEG graph with

larger model generation bounds here.

Fig. 10. Partial TEG without Symbolic State Matching

Fig. 11. Partial TEG with Symbolic State Matching

the abovementioned controller program runs on a PLC. The
following shows the model checking results to check whether
both of the green lights can be on at the same time, i.e.,
G ¬ (¬a & ¬b) where a := (Q 0 0 0 2 = 0) and b :=
(Q 0 0 0 5 = 0).

G !(a & b)

-- specification
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
-> State = S0 <-

is false

b = TRUE
a = TRUE

-> State: S1 <-

14

...S3<a:0 b:0>S4<a:0 b:0>S9<a:1 b:0>S14<a:0 b:1>S19<a:1 b:1>S5<a:0 b:0>S6<a:1 b:0>S7<a:0 b:1>S8<a:1 b:1>S10<a:0 b:0>S11<a:1 b:0>S12<a:0 b:1>S13<a:1 b:1>S15<a:0 b:0>S16<a:1 b:0>S17<a:0 b:1>S18<a:1 b:1>S20<a:0 b:0>S21<a:1 b:0>S22<a:0 b:1>S23<a:1 b:1>...S3<a:0 b:0>S4<a:0 b:0>S9<a:1 b:0>S10<a:0 b:1>S11<a:1 b:1>S5<a:0 b:0>S6<a:1 b:0>S7<a:0 b:1>S8<a:1 b:1>-> State: S2 <-
-> State: S3 <-

b = FALSE
a = FALSE

-> State: S10 <-

b = TRUE

-> State: 18 <-

a = TRUE

State trace: S0 S1 S2 S3 S10 S8

The model checking engine comes up with a counterexample
for the code that shows the state sequence in TEG that causes
the violation of the given safety requirement.

B. ILIL Semantics

The operational semantics of ILIL extend those of the
Vine intermediate language to include function blocks, scoped
variable resolution, hierarchical addresses, loads and stores to
multi-indexed memories, and casts of hierarchical addresses.
Contexts. The ILIL machine state consists of the following
contexts.

S - The function call stack.
•
L - Label to instruction number mapping.
•
• P - Instruction pointer to instruction mapping.
• F - Function name to entry point mapping.
•
•
•
•

D - The global variable context.
` - The local variable context.
p - The instruction pointer.
G - The type context.

Overview. The operational consist of instructions and expres-
sions. The consequence of each instruction is of the form
S,D, `, p,i
,! S0,D0, `0, p0,i0, meaning the call stack, global
and local variable contexts, instruction pointer, and current
instruction are transformed from the left hand side to the right
hand side after execution of the instruction i. Similarly, The
consequence of each expression is of the form D, ` ` e + v,
meaning that under the global and local variable contexts, the
expression e evaluates to the value v.

S = ·

Operational semantics of instructions:
D0 = D[x   v] P ` p + 1 : i

D ` e + v
S,D, `, p, x :=e ,! S,D0, `, p + 1,i
` ` e + v
S,D, `, p, x :=e ,! S,D, `0, p + 1,i

`0 = `[x   v] P ` p + 1 : i

S 6= ·

assign–g

assign–l

S0 = S;(`, p + 1)

D, ` ` e + v F ` f : p0 P ` p0 : i

call

S,D, `, p, call f (x e) ,! S0,D,{x : v}, p0,i
ret

P ` p0 : i

S;(`0, p0),D, `, p, ret ,! S,D, `0, p0,i
D, ` ` e + v
L ` v : p0 P ` p0 : i
S,D, `, p, jmp e ,! S,D, `, p0,i

jmp

D, ` ` e1 + 1

D, ` ` e1 + 0

D, ` ` e2 + v

L ` v : p0 P ` p0 : i

S,D, `, p, cjmp e1,e2,e3 ,! S,D, `, p0,i

D, ` ` e3 + v

L ` v : p0 P ` p0 : i

S,D, `, p, cjmp e1,e2,e3 ,! S,D, `, p0,i
S,D, `, p, label s ,! S,D, `, p + 1,i label

P ` p + 1 : i

cjmp–t

cjmp–f

15

D, ` ` e + 1 P ` p + 1 : i

S,D, `, p, assert e

,! S,D, `, p + 1,i assert–t

D, ` ` e + 0

S,D, `, p, assert e

,! •,•,{“err” : “e”},•,•

Operational semantics of expressions:
size(v2) = m
n = # bytes treg

D, ` ` e2 + v2

D, ` ` e1 + v1
G ` v1 : mem t(tendian,m)
v = v1[v2 . . .v2 + n]

in tendian order

D, ` ` load(e1,e2,treg) + v

assert–f

load–bytes

D, ` ` e1 + v1
G ` v1 : mem t(tendian,m)

D, ` ` e2 + v2
v = v1[v2]

size(v2) = m + 1
treg = reg1 t

D, ` ` load(e1,e2,treg) + v

load–bit

D, ` ` e1 + v1 D, ` ` e2 + v2 D, ` ` e3 + v3
G ` v1 : mem t(tendian,m)

v = v1[v2 . . .v2 + n   v3]

n = # bytes
in tendian order

treg

size(v2) = m

D, ` ` store(e1,e2,e3,treg) + v

store–bytes

D, ` ` e1 + v1 D, ` ` e2 + v2 D, ` ` e3 + v3 size(v2) = m + 1

treg = reg1 t

G ` v1 : mem t(tendian,m)

v = v1[v2   v3]

D, ` ` store(e1,e2,e3,treg) + v

D, ` ` e1 + v1

D0 = D[x   v1]

D0, ` ` e2 + v

D, ` ` let x = e1 in e2 end + v

store–bit

let

D, ` ` e1 + v1

v = v1 ⇧b v2

D, ` ` e2 + v2
D, ` ` e1 ⇧b e2 + v
D, ` ` ⇧u e1 + v
v = higher treg bits of v1

v = ⇧u v1

uop

D, ` ` e1 + v1

bop

D, ` ` e + v1

D, ` ` e + v1

D, ` ` e + v1

D, ` ` cast(high,treg,e) + v

v = lower treg bits of v1

D, ` ` e + v1

D, ` ` cast(low,treg,e) + v

v = v1 sign-extended to treg bits

cast–u

cast–l

D, ` ` cast(signed,treg,e) + v

v = v1 zero extended to treg bits

D, ` ` cast(unsigned,treg,e) + v
D, ` ` e + v1
v = pack(v1)
D, ` ` cast(ptr, addr t,e) + v
D, ` ` e + v1
v = unpack(v1)
D, ` ` cast(addr, reg32 t,e) + v cast–addr

cast–ptr

cast–s

cast–u

` ` x : v
` ` x + v var–local
D ` x : v
D, ` ` x + v
D, ` ` v + v value

x 62 `

var

