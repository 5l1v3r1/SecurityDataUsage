2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Secure Sampling of Public Parameters
for Succinct Zero Knowledge Proofs

Eli Ben-Sasson§, Alessandro Chiesa∗, Matthew Green†, Eran Tromer¶, Madars Virza‡

∗ETH Z¨urich, alessandro.chiesa@inf.ethz.ch
†Johns Hopkins University, mgreen@cs.jhu.edu

‡MIT, madars@mit.edu

§Technion, eli@cs.technion.ac.il

¶Tel Aviv University, tromer@cs.tau.ac.il

are

applications. However,

zero-knowledge
cryptographic

Abstract—Non-interactive
a powerful

proofs
tool, with
(NIZKs)
succinct
numerous potential
NIZKs (e.g., zk-SNARK schemes) necessitate a trusted
party to generate and publish some public parameters, to
be used by all provers and veriﬁers. This party is trusted
to correctly run a probabilistic algorithm (speciﬁed by
the the proof system) that outputs the public parameters,
and publish them, without leaking any other information
(such as the internal randomness used by the algorithm);
violating either requirement may allow malicious parties
to produce convincing “proofs” of false statements. This
trust requirement poses a serious impediment to deploying
NIZKs in many applications, because a party that is
trusted by all users of the envisioned system may simply
not exist.

In this work, we show how public parameters for a class
of NIZKs can be generated by a multi-party protocol, such
that if at least one of the parties is honest, then the result
is secure (in both aforementioned senses) and can be subse-
quently used for generating and verifying numerous proofs
without any further trust. We design and implement such a
protocol, tailored to efﬁciently support the state-of-the-art
NIZK constructions with short and easy-to-verify proofs
(Parno et al. IEEE S&P ’13; Ben-Sasson et al. USENIX
Sec ’14; Danezis et al. ASIACRYPT ’14). Applications
of our system include generating public parameters for
systems such as Zerocash (Ben-Sasson et al. IEEE S&P ’13)
and the scalable zero-knowledge proof system of (Ben-
Sasson et al. CRYPTO ’14).

I. INTRODUCTION

In recent years individuals and enterprises have begun
to migrate large quantities of internal data to outside
providers. This trend raises concerns about the integrity
and conﬁdentiality of computations conducted on this
data. Consider, for example, the following simple illus-
trative scenario. A server owns a private database x,
and a client wishes to learn y := F (x) for a public
function F ; a commitment cm to x is known publicly.
For example, x may be a database containing genetic
data, and F may be a machine-learning algorithm that
uses the genetic data to compute a classiﬁer y. On the
one hand, the client seeks integrity of computation: he

© 2015, Eli Ben-Sasson. Under license to IEEE.
© 2015, Eli Ben-Sasson. Under license to IEEE.
DOI 10.1109/SP.2015.25
DOI 10.1109/SP.2015.25

287
287

wants to ensure that the server reports the correct output
y (e.g., because the classiﬁer y will be used for critical
medical decisions). On the other hand, the server seeks
conﬁdentiality of his own input: he is willing to disclose
y to the client, but no additional information about x
beyond y (e.g., because the genetic data x may contain
sensitive personal information).
Zero-knowledge proofs. Achieving the combination
of the above security requirements seems paradoxical:
the client does not have the input x, and the server
is not willing to share it. Yet, cryptography offers a
powerful tool that is able to do just that: zero-knowledge
proofs [1], [2]. The server, acting as the prover, attempts
to convince the client, acting as the veriﬁer, that the
following NP statement is true: “there is ˜x such that
y = F (˜x) and ˜x is a decommitment of cm”. Indeed:
(a) the proof system’s soundness property addresses the
client’s integrity concern, because it guarantees that, if
the NP statement is false, the prover cannot convince
the veriﬁer (with high probability);1 and (b) the proof
system’s zero-knowledge property addresses the server’s
conﬁdentiality concern, because it guarantees that, if the
NP statement is true, the prover can convince the veriﬁer
without leaking any information about x (beyond what
is leaked by y).
Non-interactivity. While zero-knowledge proofs can
address the above simple scenario, they also apply more
broadly, including to scenarios that involve many parties
who do not trust each other or are not all simultaneously
online. In such cases, it is desirable to use non-interactive
zero-knowledge proofs (NIZKs), where the proof consists
of a single message π that can be veriﬁed by anyone.
For example, such a proof π can be stored for later use,
or it can be veriﬁed by multiple parties without requiring

1Sometimes a property stronger than soundness is required: proof
of knowledge [1], [3], which guarantees that, whenever the veriﬁer is
convinced, not only can he deduce that a witness exists, but also that
the prover knows one such witness.

the prover to separately interact with each of these.

Unfortunately, NIZKs do not exist for languages
outside BPP (even when soundness is relaxed to hold
only computationally) [4]. But, if a trusted party is
available for a one-time setup phase, then, under suitable
hardness assumptions, NIZKs exist for all languages in
NP [5]–[7]. During the setup phase, the trusted party
runs a probabilistic polynomial-time generator algorithm
G (prescribed by the proof system) and publishes its
output pp, called the public parameters; afterwards, the
trusted party is no longer needed, and anyone can use pp
to produce proofs or to verify them. Soundness of the
NIZK depends on this trusted setup: if pp is not correctly
generated, or if secret internal randomness used within
G is revealed, then it may be feasible to convince the
veriﬁer that false NP statements are true. Compromised
soundness can have catastrophic implications, because an
attacker may be able to cause signiﬁcant damage without
being detected.
The problem of parameter generation.
If no trusted
party is available, how should the public parameters pp be
generated? Without some trustworthy method to generate
public parameters, deploying practical systems that rely
on NIZKs (e.g., Zerocash [8]) seems very challenging.
One approach is to look for, in Nature or Society, a
publicly-observable distribution that equals (or is close
to) pp’s distribution. For example, if G merely outputs
a random binary string of a certain length,2 it may be
possible, via suitable measurements and post-processing
of, e.g., data about sun spots or the stock market, to
extract bits that are close to random. (See [9], [10] for
work in this direction, and [11] for a NIST prototype
using quantum randomness sources). However, if G
follows a more complex probabilistic strategy, then there
may be no stochastic process in Nature or Society that
yields a distribution close to pp’s.

An attractive alternative approach to address the

problem of parameter generation is the following:
construct a multi-party protocol for securely generating

the public parameters pp.

The setup phase will then involve a large set of parties
running the multi-party protocol for generating pp, and
for soundness of the NIZK to hold it will sufﬁce that
only a few (ideally, even just one) of these parties are
honest. Clearly, this is a weaker and more realistic trust
assumption then placing ultimate trust in any single party.
Several works have explored this approach for the pa-
rameter distributions of various cryptographic primitives

2NIZKs for which G outputs a random binary string are said to be

in the common random string model.

288288

and, more generally, one can invoke secure multi-party
computation [12], [13] to obtain a feasibility result. Yet,
as discussed in Section II, prior works do not yield
satisfactory efﬁciency in our setting, which we now
introduce.

A. Our focus

The problem of parameter generation has garnered recent
attention due to the development of new and powerful
NIZKs that enable verifying general computation via
proofs that are succinct, i.e., short and easy to verify [14].
The new proofs are known as zero-knowledge succinct
arguments of knowledge (zk-SNARKs) [15]–[17], and
have already found practical applications, e.g., to building
decentralized electronic cash [8]. Most zk-SNARKs
require an involved parameter generation, often with
complexity proportional to the size of the computation
being proved; addressing this parameter generation is
the focus of our work. Concretely, we obtain efﬁcient
multi-party protocols for securely sampling the public
parameters required by zk-SNARKs, as we now explain.
zk-SNARK constructions. There are many zk-SNARK
constructions, with different properties in efﬁciency
and supported languages. In preprocessing zk-SNARKs,
the complexity of sampling public parameters grows
with the size of the computation being proved [17]–
[31]; in fully-succinct zk-SNARKs, that complexity is
independent of computation size [14], [16], [32]–[40].
Working prototypes have been achieved for preprocessing
zk-SNARKs [21], [22], [25], [27], [30] and fully-succinct
ones [39]. Several works have also explored various
applications of zk-SNARKs [8], [41]–[44].
Public parameters of zk-SNARKs. Despite the afore-
mentioned multitude of constructions, Bitansky et al.
[17] showed that essentially all known preprocessing
zk-SNARK constructions can be “explained” as the
combination of a linear interactive proof (LIP) and
a cryptographic encoding that only supports linear
homomorphisms. This yields a uniﬁed view of parameter
generation across preprocessing zk-SNARKs (that are
not fully succinct). Namely, given an NP relation R, the
generator G adheres to the following computation pattern
when producing public parameters for R:
(i) derive
from R a certain circuit C (essentially, C is the multi-
output circuit that computes the LIP’s veriﬁer’s message);
(ii) evaluate C at a random input; (iii) output the encoding
of the evaluation. In other words, public parameters of
preprocessing zk-SNARKs are the encodings of random
evaluations of certain circuits.
The sampling problem. Concretely, for a prime r,
the circuit C is deﬁned over the size-r ﬁeld Fr and

the encoding of α ∈ Fr is α · G, where G generates
an order-r group G. Moreover, G is a duplex-pairing
group (i.e., G is a subgroup of some G1 × G2 equipped
with a pairing). This discussion motivates the following
multi-party sampling problem:
Let r be a prime, G = (cid:3)G(cid:4) an order-r group, n a
positive integer, and C : Fm
r an Fr-arithmetic
r
circuit. Construct an n-party protocol for securely
sampling pp := C((cid:4)α) · G for random (cid:4)α ∈ Fm.
We thus seek a multi-party protocol such that, even when
all but one of the n parties are malicious, the protocol’s
output is pp sampled from the correct distribution and,
moreover, the n parties, and any others observing the
protocol’s execution, learn nothing beyond pp itself. We
study this problem, and the special case of generating
public parameters for preprocessing zk-SNARKs.

→ Fh

In fact, as the purpose of the multi-party protocol in the
aforementioned application is to convince the systems’
users, which are bystanders to the protocol execution, we
make explicit a transcript veriﬁer, which is an algorithm
that anyone can use to ensure correct execution of the
protocol by examining the broadcast messages.

B. Our contributions

We design, build, and evaluate a multi-party protocol
for securely sampling encodings of random evaluations
of certain circuits. The resulting system enables us, in
particular, to sample the public parameters for a class of
preprocessing zk-SNARKs that includes [21], [25], [31];
we integrated our system with libsnark [45], a C++
zk-SNARK library, to facilitate this application. In more
detail, we present the following two main contributions.

(1) Secure sampling for a class of circuits. We design,
build, and evaluate a multi-party protocol that securely
samples values of the form C((cid:4)α) · G for a random
(cid:4)α, provided that C belongs to a certain circuit class
CS. Roughly, CS comprises the F-arithmetic circuits
C : Fm → Fh for which: (i) the output of each (addition
or multiplication) gate is an output of the circuit; (ii) the
inputs of each addition gate are outputs of the circuit;
(iii) the two inputs of each multiplication gate are,
respectively, a circuit output and a circuit input. (See
Figure 1a for an example of a circuit in CS.)

The multi-party protocol is based on standard cryp-
tographic assumptions, and runs atop a synchronous
network with an authenticated broadcast channel and

a common random string.3 The computation proceeds
in rounds and, at each round, the protocol’s schedule
determines which parties act; a party acts by broadcasting
a message to all others.
When n parties participate, our protocol is secure
against up to n − 1 malicious parties. If even one of
the parties is honest, and assuming the protocol reaches
completion, then the protocol’s output is a sample from
the designated distribution and no other information
leaks.4 Each party runs in time Oλ(size(C)), where
Oλ(·) hides a ﬁxed polynomial in the security parameter
λ. The number of rounds is n · depthS(C) + O(1) and
the number of broadcast messages is O(n · depthS(C)).
Here, depthS(C) denotes the S-depth of C (introduced
later), which is at most the standard circuit depth of C,
but sometimes much smaller, as is (crucially) the case
for the zk-SNARK application discussed below.

While the above results hold for any group G, our
code implementation is specialized to the case when G is
duplex-pairing because, for this case, several additional
optimizations are possible. For this special case, we
additionally rely on random oracles so as to beneﬁt from
the Fiat–Shamir heuristic [47].

Compared to previous results in secure multi-party
computation protocols, our specialized construction
scales up to larger number of parties without incurring
a high round complexity; see Section II.
(2) Application to zk-SNARKs. Our system can
securely sample public parameters of a zk-SNARK,
whenever the generator can be cast as sampling the
encoding of the random evaluation of a circuit in the
class CS. While the class CS appears restrictive, we ob-
serve that several known constructions of preprocessing
zk-SNARK have such a generator.

To facilitate this application to zk-SNARKs, we
(i) integrated our system with libsnark [45], and
(ii) applied our system to generating public parameters for
two speciﬁc zk-SNARK constructions: that of [21], [25]
(supporting arithmetic relations) and that of [31] (sup-
porting boolean relations). We also extended libsnark
with an implementation of [31]’s zk-SNARK, augment-
ing its existing implementation based on [21], [25].

Given an arithmetic circuit D, our code constructs
a related circuit CPGHR in CS, such that the encoding

3A broadcast channel can also be thought of as an append-only
public logbook and can be implemented in practice, e.g., via Bitcoin’s
puzzle-based block-chain protocol [46]; authentication can be achieved,
e.g., via digital signatures supported by a public-key infrastructure.
A common random string can, e.g., be implemented via a public
randomness source with high entropy (or even coin-tossing protocols).
4A malicious party may prevent the protocol from completing, by
acting incorrectly or by delaying prescribed broadcasts. However, the
culprit can be readily identiﬁed.

289289

of a random evaluation of CPGHR corresponds to public
parameters for [21], [25]’s zk-SNARK when proving
satisﬁability of D. If D has Nw wires and Ng gates, then
((cid:6)log2 Ng(cid:7) + 1) + 38
CPGHR has size 11Nw + 2
and S-depth 3. Similarly, given a boolean circuit D,
our code constructs a related circuit CDFGK in CS for
[31]’s zk-SNARK; if D has Nw wires and Ng gates, then
((cid:6)log2 Ng(cid:7) + 1) + 10
CDFGK has size 2Nw + 2
and S-depth 2.

(cid:2)log2 Ng(cid:3)

(cid:2)log2 Ng(cid:3)

We evaluate the concrete costs of our protocol when
used to generate the public parameters, needed by the
aforementioned zk-SNARK, in order to prove satisﬁabil-
ity of speciﬁc circuits D in the following applications.
• Our system can securely generate the public parameters
for Zerocash [8], a decentralized anonymous payment
system extending Bitcoin. Letting D be the circuit that
implements the NP relation used in Zerocash: CPGHR
has size 138,467,206 and S-depth 3; in our multi-party
protocol, the number of rounds is 3n + 3 and each
party works for 14,124 s.

• Our system can securely generate the public parameters
needed for the scalable zk-SNARK of [39], which
proves correct execution of programs on a 32-bit RISC
architecture. Letting D be the circuit used in [39]:
CPGHR has size 8,027,609 and S-depth 6; in our multi-
party protocol, the number of rounds is 6n + 6 and
each party works for 4,048 s. (In [39] there are two
required circuits; here and later we specify, for each
complexity measure, the sum of the two costs.)

In both of cases above, the S-depth is extremely small
(less than 10), but the standard depth of the same circuit
exceeds many hundreds of thousands. The fact that our
sampling protocol’s round complexity is efﬁcient in S-
depth allows for scaling to larger number of parties.

C. Summary of challenges and techniques

We describe at a high level the challenges that arise, as
well as the techniques that we employed to address them,
for each of our two main contributions.

→ Fh

1) Secure sampling for a class of circuits
Let r be a prime, G = (cid:3)G(cid:4) an order-r group, n a positive
integer, and C : Fm
r an Fr-arithmetic circuit.
We seek an n-party protocol for sampling C((cid:4)α) · G,
r
for a random (cid:4)α, that is secure against up to n − 1
malicious parties. We may compromise on functionality
by restricting C to belong to a circuit class CS, provided
that,
in return, we gain improved efﬁciency (since,
ultimately, we want to implement the protocol and use
it to generate zk-SNARK public parameters).

n

(cid:2)

The ideal functionality. The ﬁrst step is to choose
the ideal functionality fC,G to be implemented by the
multi-party protocol. A reasonable candidate is the
following: on input (cid:4)σ := ((cid:4)σ1, . . . , (cid:4)σn) where (cid:4)σi =
(σi,1, . . . , σi,m) ∈ Fm
r is party i’s input, fC,G ﬁrst com-
i=1 σi,j for j = 1, . . . , m; then fC,G sets
putes αj :=
(cid:4)α := (α1, . . . , αm) and computes (cid:4)P := C((cid:4)α)·G; ﬁnally,
fC,G outputs (cid:4)P. Indeed, if at least one party honestly
provides an input consisting of random ﬁeld elements,
fC,G outputs the encoding of a random evaluation of C.5
Potential approaches. A typical next step is to write
a boolean circuit that evaluates fC,G, and then invoke
an (off-the-shelf or tailored) multi-party protocol for
securely evaluating the circuit. However, the conversion
to a boolean is circuit is expensive, because computing
C((cid:4)α)·G involves (i) the evaluation of the Fr-arithmetic
circuit C, and (ii) h scalar multiplications over the group
G. For example, the number of boolean gates required
to compute C((cid:4)α) alone is ≥ log2 r times larger than the
number of Fr-arithmetic gates for the same task, because
each addition and multiplication in Fr is expanded into
a boolean sub-circuit of size ≥ log2 r. Similarly, each
scalar multiplication over G expands into a boolean sub-
circuit of size ≥ log2 q · log2 r. In sum, the conversion
incurs a blowup of up to ﬁve orders of magnitude
in the number of gates to securely evaluate, because
log2 q, log2 r ≥ 250 (for, e.g., 128 bits of security).
So perhaps we could instead express the computation
via an arithmetic circuit, and use a multi-party protocol
for arithmetic circuits. However, over what ﬁeld should
the arithmetic circuit be deﬁned? While the circuit C is
deﬁned over the ﬁeld Fr, the group G may not be; indeed,
for the application considered in this paper (sampling
of public parameters for zk-SNARKs), the group G is
deﬁned over a prime ﬁeld Fq that is different from
Fr. If we express the computation as an Fr-arithmetic
circuit then, while evaluating C may be efﬁcient, scalar
multiplications over G are not. Conversely, if we express
the computation as an Fq-arithmetic circuit, while scalar
multiplications over G may be efﬁcient, evaluating C is
not. Either way, we again incur the overheads associated
to mismatch of ﬁeld characteristic.

In addition to the above considerations, known multi-
party protocols that are secure against malicious majori-
ties either (i) have round complexity that scales linearly
with circuit depth, or (ii) rely on heavy cryptographic
tools that are unlikely to yield efﬁcient implementations
in the near future. The applications that we consider

5fC,G also checks that none of the parties’ inputs contains a zero.
Forbidding zeros biases the output distribution, but only negligibly,
since r is chosen large enough for discrete log to be hard in Z∗
r.

290290

involve circuit depths exceeding hundreds of thousands,
so that such works do not seem applicable (see Section II
for discussion and citations).
Our approach. Our approach avoids the overheads
due to mismatch in ﬁeld characteristic, and also has low
round complexity.

We observe that, for particular zk-SNARK construc-
tions (including [21], [25], [31]) the circuit C can (as
discussed in Section I-C2), be written to have a special
form so as to lie in the circuit class CS. We restrict our
attention to implementing fC,G for C ∈ CS.
For such circuits, we design a protocol where parties
jointly homomorphically evaluate the circuit C (avoiding,
in particular, ﬁrst computing (cid:4)β := C((cid:4)α) and then (cid:4)β · G).
First, all parties ﬁrst commit to their shares. Then, for
each multiplication gate, since one of the two gate’s
inputs is also an input to the circuit, every party can, in
sequence, contribute, and prove correct contribution of,
his input share. Additions are done locally (as in many
other multi-party protocols.

A naive realization of the above strategy yields an
enormous number of rounds: n times C’s depth. In
contrast, we show that, via a careful scheduling of when
each party contributes his own share, we can reduce the
number of rounds to only n times C’s S-depth, where S-
depth is a much milder notion of depth (deﬁned later). In
the zk-SNARK application that we consider, depth(C)
grows with size(C) while depthS(C) is a small constant.
We realize the above approach by splitting the con-
struction in two steps. First, we reduce the problem of
sampling the encoding of a random evaluation of C to the
problem of jointly evaluating a related circuit ˜C. Second,
we build a multi-party protocol for securely evaluating
˜C. These two steps simplify providing a formal proof of
security, as well as building a prototype implementation
of the protocol. Section I-D summarizes our construction.
Our implementation is specialized to when G is a
duplex-pairing group, in which case the NIZKs used by
parties can be implemented very efﬁciently via Schnorr
proofs and the Fiat–Shamir heuristic [47].

2) Application to zk-SNARKs

We wish to apply our system to generating public
parameters for two speciﬁc zk-SNARK constructions:
that of [21], [25] and that of [31]. This requires a
procedure for transforming the NP relation (represented
as an instance D of arithmetic or boolean satisﬁability)
given as input to generator, into a corresponding circuit
C ∈ CS such that C((cid:4)α) · G for a random (cid:4)α equals the
distribution of public parameters output by the generator.

Constructing such a circuit C, subject to the restric-
tions of CS (needed for applying our sampling protocol),
is not straightforward for either of the aforementioned
zk-SNARKs. One issue that arises, in both cases, is how
to construct a sub-circuit that, given an input τ ∈ Fr,
evaluates all Lagrange interpolating polynomials at τ;
indeed, the standard linear-size circuit for this operation
involves division gates, which our protocol does not
handle (and are thus not included in CS). Instead of
relying on the standard circuit, we rely on a suitable
FFT-like sub-circuit that avoids the division gates.

D. Construction summary

We summarize our construction of an n-party protocol
for sampling pp := C((cid:4)α) · G, for a random (cid:4)α, that is
secure against up to n − 1 malicious parties. Recall that
we focus on circuits in the class CS, which consists
of circuits C : Fm → Fh for which:
(i) the output of
each (addition or multiplication) gate is an output of the
circuit; (ii) the inputs of each addition gate are outputs
of the circuit; (iii) the two inputs of each multiplication
gate are, respectively, a circuit output and a circuit input.
See Figure 1a for an example of a circuit in CS.

We ﬁrst introduce some ideas for the artiﬁcial special
case of a single party executing the protocol; we then
explain how these ideas can be extend to multiple parties.
A special case. Suppose that a single party wishes
to generate pp in a veriﬁable way: the party outputs a
transcript tr, from which pp can be deduced, such that
anyone can establish validity of the transcript. Informally,
we seek a veriﬁer V and simulator S that satisfy:
(1) syntactical correctness: if V (tr) = 1, there is (cid:4)α ∈ Fm
such that pp = C((cid:4)α) · G; and (2) zero knowledge: tr
reveals no information beyond pp in the sense that S(pp)
is indistinguishable from tr. (At this stage we do not yet
ensure that (cid:4)α is uniformly drawn and unknown.)

The straightforward approach to achieve the above is
to set tr := (pp, π) where π is a NIZK proof (in the
common random string model) for the NP statement
“there exists (cid:4)α such that pp = C((cid:4)α) · G”, and then to let
V be the NIZK veriﬁer and S be the NIZK simulator.
We observe that, since C is in CS, the NP state-
ment above can be “factored” into a collection of sub-
statements so that the proof π can be constructed as the
concatenation of a NIZK sub-proof πg for each gate g
in C. Essentially, for each gate g taken in topological
order: if g is a multiplication gate, then we know that the
encoding P of one of the two inputs has already been
computed (and proved correct) so that, if γ ∈ F denotes
the other input and R the encoded output, the party can
generate a NIZK proof that R = γ ·P; if instead g is an

291291

ܽ

ܾ

ܿ

5

 

 

 

 

 

 














ܽ

ܾ

ܿ



݀

	
݁

5

 

 

 

4

 

3

 

1

 

 

 

 

 

 







	




(a) Example of a circuit in CS.

(b) Example of a circuit in CE.

Fig. 1: Examples of a circuit in CS and one in CE; in the latter case, the inputs of the circuit are partitioned into
slots. The red contour lines denote (traditional) circuit depth, while blue contour lines denote S-depth and E-depth.

addition gate, the group structure of G enables anyone
to evaluate g so that no NIZK proof is needed.
Extending to multiple parties. Now suppose that there
are n > 1 participating parties. Denote by tr the transcript
of all broadcast messages. We seek a veriﬁer V and
simulator S that satisfy variants of the above properties:
(1) distributional correctness: if at least one party is
honest and V (tr) = 1, pp equals C((cid:4)α) · G for a random
(cid:4)α; and (2) zero knowledge: if at least one party is honest
and V (tr) = 1, tr reveals no information beyond pp in
the sense that S(pp) is indistinguishable from tr.

Ideally, we would still set tr := (pp, π) where π
is a NIZK proof for the NP statement “there exists
(cid:4)α such that pp = C((cid:4)α) · G”. However, now there is
no single party that knows the witness (cid:4)α. Each party
holds a multiplicative share of every coordinate of (cid:4)α:
party i holds (cid:4)σi = (σi,1, . . . , σi,m) ∈ Fm
(cid:2)
r and αj equals
n
i=1 σi,j.
Nevertheless, we show that it is still possible to factor
the NP statement into a collection of sub-statements,
each one involving a contribution of one share, that,
when carefully scheduled, allow the n parties to jointly
assemble π by producing suitable sub-proofs. More
generally, our construction has two steps. First, we
transform the circuit C in CS into a new circuit ˜C in a
new circuit class CE; second, we construct a multi-party
protocol for securely evaluating any circuit in CE. More
details follow.
The circuit class CE differs from CS in two ways.
First, the inputs of a circuit ˜C ∈ CE are partitioned into
slots; we write ˜C : Fm1×···×Fmn → Fh to express that
the ﬁrst m1 inputs are in the ﬁrst slot, the next m2 in the
second, and so on; the integers m1, . . . , mn are part of
˜C’s description. Second, the restriction on the possible
inputs of multiplication gates is relaxed to account for
input slots. CE poses the following restrictions on ˜C
(with difference from CS emphasized): (i) the output of

292292

each (addition or multiplication) gate is an output of the
circuit; (ii) the inputs of each addition gate are outputs
of the circuit; (iii) the two inputs of each multiplication
gate are, respectively, a circuit output and either a circuit
input, or a circuit output computable from inputs from a
single slot. Figure 1b is an example of a circuit in CE.
The transformation from C ∈ CS to ˜C ∈ CE is as
follows. The m inputs of C are multiplicatively shared
among n parties to obtain n·m inputs for ˜C; the slot i of
˜C contains the m shares of party i. Each multiplication
gate in C is mapped to O(n) multiplication gates in
˜C tasked with assembling all the relevant shares; each
addition gate in C is mapped to a corresponding addition
gate in ˜C. A crucial feature of the transformation is depth
efﬁciency (see below).

The multi-party protocol for circuits in CE is a
generalization of the one that we described above for
a single party. Essentially, the class CE ensures that at
each multiplication gate there is one party that knows the
“local” witness for producing a NIZK proof of correct
evaluation of the gate. Thus, the protocol proceeds in
rounds, and at each round every party proves correct
evaluation of any gate ready to be processed (and so on
until no more gates need to be processed).
Depth matters. The round complexity of securely
evaluating ˜C ∈ CE is depthE( ˜C) + O(1), where
depthE( ˜C) is the E-depth and (roughly) corresponds
to the maximum number of gate-ownership alternations
along any input-to-output path; ownership refers to which
party provides the input share to a gate. (See Figure 1b
for a comparison of depth and E-depth for an example in
CE.) Intuitively, while going down a path in the circuit,
every change in gate ownership means that a party needs
to wait on another one to process the previous gate,
thereby costing an extra round.

Therefore, it is crucial that the transformation from
C to ˜C is efﬁcient in terms of E-depth of ˜C. By

carefully combining the sub-circuits in ˜C, we ensure
that depthE( ˜C) = n · depthS(C), where depthS(C) is
the S-depth of C and denotes the maximum number of
alternations between addition and multiplication gates
along any input-to-output path. (Figure 1a compares
depth and S-depth for an example in CS.)

II. PRIOR WORK

Secure generation of parameters. Generating public
parameters for NIZKs has been studied before, partic-
ularly in the setting where parameters merely consist
of a random string. For example, [9], [10], [48] study
various aspects of this problem. There are also other
cryptographic primitives that require a set of public
parameters to be known to every party in the system,
and various works have explored distributed generation
of such parameters for various distributions [49]–[51].
Secure multi-party computation. The area of secure
multi-party computation has seen rapid recent progress,
both in terms of theoretical results and concrete imple-
mentations. Yet, the existing generic implementations do
not support, or inefﬁciently support, the setting that we
consider: many parties, dishonest majority, and evaluation
of a circuit with large (standard) circuit depth.

For example, many implementations consider the case
of two parties [52], where they achieve outstanding
efﬁciency [53], [54], and can process billions of boolean
gates while spending only tens of CPU cycles on each.
Most of the approaches in this setting are based on Yao’s
seminal work on garbled circuits [55], [56].

Some implementations consider the case of arbitrary
number of parties, but they suffer from other limitations.
For example, [57] consider adversaries that are honest
but curious. Other protocols [13], [58] consider mali-
cious adversaries but require an honest majority. There
are known constant-round MPC protocols for a fully-
malicious, dishonest majority [59], [60], but these require
expensive ZK proofs and have not been implemented.
When requiring security against dishonest majorities
(with at least one honest party), implementations have a
round complexity that depends linearly on the depth of
the circuit being computed [61]–[65]. The applications
that we consider in this paper involve circuit depths that
exceed hundreds of thousands, resulting in large round
complexities; such round complexities are at best very
expensive when considering network latencies on the
Internet and at worst prohibitive if one of the participating
parties uses an air gap as a precaution. While theoretical
results do achieve sublinear round complexity [66], [67],
they rely on “heavy artillery” such as fully-homomorphic
encryption and program obfuscation, unlikely to yield

efﬁcient implementations in the near future.

III. DEFINITIONS

A. Basic notation

We denote by λ the security parameter; f = Oλ(g)
means that there exists c > 0 such that f = O(λcg). The
power set of a set S is denoted 2S. Vectors are denoted
by arrow-equipped letters (e.g., (cid:4)a); their entries carry an
index but not the arrow (e.g., a1, a2). Concatenation of
vectors (and scalars) is denoted by the operator ◦.
Implicit inputs. To simplify notation, the input 1λ is
implicit to all cryptographic algorithms; similarly, we do
not make explicit adversaries’ auxiliary inputs.
Distributions. We write {y | x1 ← D1 ; x2 ←
D2 ; . . .}E to denote the distribution over y obtained
by conditioning on the event E and sampling x1 from
D1, x2 from D2, and so on, and then computing
(cid:4),
y := y(x1, x2, . . . ). Given two distributions D and D
(cid:4) to denote that the statistical distance
negl
we write D
= D
(cid:4) is negligible in the security parameter
between D and D
λ. A distribution D is efﬁciently sampleable if there
exists a probabilistic polynomial-time algorithm A whose
output follows the distribution D.
Groups. We denote by G a group, and consider only
groups that are cyclic and have a prime order r. Group
elements are denoted with calligraphic letters (such as
P,Q). We write G = (cid:3)G(cid:4) to denote that the element
G generates G, and use additive notation for group
arithmetic. Hence, P + Q denotes addition of the two
elements P and Q; a · P denotes scalar multiplication
of P by the scalar a ∈ Z; and O := 0 · P denotes the
identity element. Since r · P = O, we can equivalently
think of a scalar a as belonging to the ﬁeld of size r.
Given a vector (cid:4)a = (a1, . . . , an), we use (cid:4)a · P as a
shorthand for the vector (a1 · P, . . . , an · P).
Fields. We denote by F a ﬁeld, and by Fn the ﬁeld
of size n; we consider only ﬁelds of prime order. Field
elements are denoted with Greek letters (such as α, β, γ).

B. Commitments

A commitment scheme is a pair COMM = (COMM.Gen,
COMM.Ver) with the following syntax.
• COMM.Gen(x) → (cm, cr): On input data x, the
commitment generator COMM.Gen probabilistically
samples a commitment cm of x and corresponding
commitment randomness cr.
• COMM.Ver(x, cm, cr) → b: On input data x, com-
mitment cm, and commitment randomness cr, the
commitment veriﬁer COMM.Ver outputs b = 1 if

293293

cm is a valid commitment of x with respect to the
randomness cr.

The scheme COMM satisﬁes the standard completeness,
(computational) binding, and (statistical) hiding proper-
ties. We do not assume that cm hides |x|.
C. Non-interactive zero-knowledge proofs of knowledge

A non-interactive zero-knowledge proof of knowledge
(NIZK) for an NP relation R in the common random
string model is a tuple NIZKR = (NIZKR.P, NIZKR.V,
NIZKR.E, NIZKR.S) with the following syntax.
• NIZKR.P(crs, x, w) → π: On input common random
string crs, instance x, and witness w, the prover
NIZKR.P outputs a non-interactive proof π for the
statement “there is w such that (x, w) ∈ R”.
• NIZKR.V(crs, x, π) → b: On input common ran-
dom string crs, instance x, and proof π, the veriﬁer
NIZKR.V outputs b = 1 if π is a convincing proof for
the statement “there is w such that (x, w) ∈ R”.
Above, crs is a random string of Oλ(1) bits (the exact
length is prescribed by NIZKR). The remaining two
components are each pairs of algorithms, as follows.
• NIZKR.E1 → (crsext, trapext):
The extractor’s
generator NIZKR.E1 samples a string crsext (indis-
tinguishable from crs) and corresponding trapdoor
trapext. NIZKR.E2(crsext, trapext, x, π) → w: On
input crsext, trapext, instance x, and proof π, the
extractor NIZKR.E2 outputs a witness w for the
instance x.
• NIZKR.S1 → (crssim, trapsim): The simulator’s
generator NIZKR.S1 samples a string crssim (indis-
tinguishable from crs) and corresponding trapdoor
trapsim. NIZKR.S2(crssim, trapsim, x) → π: On
input crssim, trapsim, and instance x (for which
∃ w s.t. (x, w) ∈ R), the simulator NIZKR.S2 outputs
π that is indistinguishable from an “honest” proof.

NIZKR satisﬁes the standard completeness, (computa-
tional, adaptive) proof-of-knowledge, and (statistical,
adaptive, multi-theorem) zero-knowledge properties.

D. Arithmetic circuits

We consider arithmetic, rather than boolean, circuits.
Given a ﬁeld F, an F-arithmetic circuit C takes as input
elements in F, and its gates output elements in F. We
write C : Fm → Fh if C takes m inputs and produces h
outputs.
Wires, inputs, gates, and size. We denote by wires(C)
and gates(C) the wires and gates of C; also, we denote
by inputs(C) and outputs(C) the subsets of wires(C)
consisting of C’s input and output wires. We denote by
#wires(C), #gates(C),#inputs(C), and #outputs(C)

294294

(cid:3)

the cardinalities of wires(C), gates(C), inputs(C), and
outputs(C) respectively. The size of C is size(C) :=
#inputs(C) + #gates(C).
Gate types. A gate g of C is an addition gate
gadd, of the form α0 +
j=1 αjwj, or a (2-input)
multiplication gate gmul, of the form αwLwR. For addition
gates, inputs(gadd) := {w1, . . . , wd} are the input wires
and coeﬀs(gadd) := (α0, . . . , αd) are the coefﬁcients.
For multiplication gates, L-input(gmul) := wL is the
left input, R-input(gmul) := wR is the right input, and
coeﬀs(gmul) := (α) is the coefﬁcient. For both gate types,
output(g) := w is the output wire; also, gw is the gate
for which w = output(gw). We deﬁne type(g) to be
add for addition gates, and mul for multiplication gates;
constant gates (implicit in ﬁgures) are a special case of
addition gates.
Further notions for circuits with partitioned domains.
We also consider F-arithmetic circuits C for which the
m inputs of the circuits are partitioned into n disjoint
slots; in such a case, we write C : Fm1 × ··· × Fmn →
Fh to express that the ﬁrst m1 inputs belong to the
ﬁrst slot, the next m2 to the second, and so on; the
integers m1, . . . , mn are then also part of C’s description.
For i = 1, . . . , n: we denote by inputs(C, i) the input
wires that belong to the i-th slot, and by gates(C, i) the
gates that take as input an input wire in inputs(C, i);
the notations #inputs(C, i) and #gates(C, i) denote the
cardinalities of these sets; and we deﬁne size(C, i) :=
#inputs(C, i) + #gates(C, i). For every w ∈ inputs(C),
input-slot(C, w) is w’s slot number, i.e., the index i such
that w ∈ inputs(C, i).

d

Finally, to assist in stating the deﬁnition of E-depth
(see below), we introduce the dependency set ds(w) of
a wire w; roughly, it denotes the subset of {1, . . . , n}
denoting which slots individually carry enough infor-
mation (in terms of inputs) to compute the value of w.
The formal deﬁnition of ds(w) is quite technical, and is
Figure 2.
Two classes of circuits. We consider the following two
circuit classes CS and CE.
• CS is the class of F-arithmetic circuits C : Fm →
Fh for which every gate g in gates(C) is such that:
(i) output(g) ∈ outputs(C); (ii) if type(g) = add,
then inputs(g)∩ inputs(C) = ∅; and (iii) if type(g) =
mul, then L-input(g) (cid:14)∈ inputs(C) and R-input(g) ∈
inputs(C).
• CE is the class of F-arithmetic circuits C : Fm1 ×···×
Fmn → Fh for which every gate g in gates(C) is such
(i) output(g) ∈ outputs(C); (ii) if type(g) =
that:
add, then inputs(g) ∩ inputs(C) = ∅; and (iii) if
type(g) = mul, then L-input(g) (cid:14)∈ inputs(C) and, for

every w, w
and w

(cid:4) ∈ inputs(C), if R-input(g) depends on w

(cid:4) then input-slot(C, w) = input-slot(C, w

).

(cid:4)

is depthS(C)

Notions of depth. For circuits in CS and CE, we use
alternative notions of depth, called S-depth and E-depth;
both S-depth and E-depth are bounded from above by
(traditional) circuit depth, but are sometimes much less.
• The S-depth of C in CS
:=
maxw∈outputs(C) depthS(w) and depthS(w) is deﬁned
there, bw ∈ {0, 1} equals 1 if and
in Figure 2;
only if either |inputs(gw)| ≥ 2 or |inputs(gw)| =
1 ∧ coeﬀs(g)[0] (cid:14)= 0
• The E-depth of C in CE

:=
maxw∈outputs(C) depthE(w) and depthE(w) is deﬁned
∈ {0, 1} equals 1 if
in Figure 2;
and only if ds(L-input(gw)) ∩ ds(R-input(gw)) = ∅
and depthE(L-input(gw)) ≤ depthE(R-input(gw)),
∈ {0, 1} equals 1 if and only if
(cid:4)
and bmul

is depthE(C)

there, badd

w

w

(cid:2)∈inputs(gw) ds(w

w

(cid:4)

) = ∅.

E. Pairings and duplex-pairing groups

Pairings.
Let G1 and G2 be cyclic groups of a
prime order r. Let G1 be a generator of G1,
i.e.,
G1 = {αG1}α∈Fr, and let G2 be a generator for G2.
A pairing is an efﬁcient map e : G1 × G2 → GT , where
GT is also a cyclic group of order r (which, unlike other
groups, we write in multiplicative notation), satisfying
the following properties.
• BILINEARITY. For every pair of nonzero elements
α, β ∈ Fr, it holds that e(αG1, βG2) = e(G1,G2)αβ.
• NON-DEGENERACY. e(G1,G2) (cid:14)= 1
Duplex-pairing groups. A group G of prime order
r is duplex pairing if there are order-r groups G1 and
(i) there is a pairing e : G1 × G2 → GT
G2 such that
for some target group GT , and (ii) there is a generator
G1 of G1 and G2 of G2 such that G is isomorphic to
{(α · G1, α · G2)| α ∈ Fr} ⊆ G1 × G2.

F. Secure multi-party computation

We specialize deﬁnitions of secure multi-party compu-
tation [12], [13] to our setting, by considering parties’
inputs that are ﬁeld elements rather than bit strings,
by considering families of functionalities rather than a
single functionality, and making explicit the notion of a
(transcript) veriﬁer. These deﬁnitions provide background
and notation for this paper (and closely follow the
treatment in [68]). We assume familiarity with simulation-
based security deﬁnitions; for more, see [68].

1) Multi-party broadcast protocols

We consider multi-party protocols that run over a
synchronous network with an authenticated broadcast
channel. Namely, the computation proceeds in rounds
and, at each round, the protocol’s schedule determines
which parties act; a party acts by broadcasting a message
to all other parties. The broadcast channel is authenticated
in that all parties always know who sent a particular
message (regardless of what an adversary may do).
Moreover, we assume that parties have access to a
common random string crs; to simplify notation, we
do not make crs an explicit input. We now introduce
some notations and notions for later discussions.
Honest execution.
Given a positive integer n,
an n-party broadcast protocol
is a tuple Π =
(i) S : N → 2
{1,...,n} is the
(S, Σ1, . . . , Σn) where:
deterministic polynomial-time schedule function; and
(ii) for i = 1, . . . , n, Σi
is the (possibly stateful)
probabilistic polynomial-time strategy of party i.

round

complexity

is ROUND(Π)

The execution of Π on an input (cid:4)x = (x1, . . . , xn),
denoted [[Π, (cid:4)x]], works as follows. Set t := 1. While
(i) for each i ∈ S(t) in any order, party i
S(t) (cid:14)= ∅:
runs Σi, on input (xi, t) and with oracle access to the
history of messages broadcast so far, and broadcasts the
resulting output message msgt,i and, then, (ii) t := t + 1.
The transcript of [[Π, (cid:4)x]], denoted tr, is the sequence of
triples (t, i, msgt,i) ordered by msgt,i’s broadcast time.
The output of [[Π, (cid:4)x]], denoted out, is the last message
in the transcript. Since Π’s strategies are probabilistic,
the transcript and output of [[Π, (cid:4)x]] are random variables.
The
:=
mint∈N{t| S(t + 1) = ∅}. For
i = 1, . . . , n,
(cid:3)
the time complexity of party i is TIME(Π, i)
:=
where
TIME(Σi, t) is Σi(·, t)’s time complexity.
Adversarial execution.
Let A be a probabilistic
polynomial-time algorithm and J a subset of {1, . . . , n}.
We denote by [[Π, (cid:4)x]]A,J the execution [[Π, (cid:4)x]] modiﬁed
so that A controls parties in J, i.e., A knows the private
states of parties in J, may alter the strategies of parties in
J, and may wait, in each round, to ﬁrst see the messages
broadcast by parties not
in J and, only after that,
instruct parties in J to send their messages. (In particular,
[[Π, (cid:4)x]]A,∅ = [[Π, (cid:4)x]].) We denote by REALΠ,A,J ((cid:4)x) the
concatenation of the output of [[Π, (cid:4)x]]A,J and the view
of A in [[Π, (cid:4)x]]A,J.

t∈[ROUND(Π)] s.t. i∈S(t) TIME(Σi, t)

2) Ideal functionalities

While Section III-F1 describes the real-world execution
of a protocol Π on an input (cid:4)x, here we describe the

295295

Fig. 2: Deﬁnitions of dependency set, S-depth, and E-depth; see Section III-D.

ideal-world execution of a function f on an input (cid:4)x:
each party i privately sends his input xi to a trusted
party, who broadcasts f ((cid:4)x).
Adversarial execution.
Let S be a probabilistic
polynomial-time algorithm and J a subset of {1, . . . , n}.
The ideal-world execution of f on (cid:4)x when S controls
parties in J differs from the above one as follows: S
may substitute the inputs of parties in J with other
same-length inputs. We denote by IDEALf,S,J ((cid:4)x) the
concatenation of the value broadcast by the trusted party
and the output of S in the ideal-world execution of f
on (cid:4)x when S controls parties in J.

→ Fh

3) Secure sampling broadcast protocols
Let r be a prime, G = (cid:3)G(cid:4) an order-r group, n a positive
integer, and C : Fm
r an Fr-arithmetic circuit. A
r
secure sampling broadcast protocol with n parties for
C over G is a tuple ΠS = (Π, V, S), where Π is an n-
party broadcast protocol, and V (the veriﬁer) and S (the
simulator) are probabilistic polynomial-time algorithms,
that satisﬁes the following.
For every probabilistic polynomial-time algorithm
A (the adversary) and subset J of {1, . . . , n} (the
corrupted parties) with |J| < n, these two distributions
are negligibly close:⎧⎪⎨

⎪⎩REALΠ,A,J ((cid:4)σ)

⎧⎪⎨
⎪⎩IDEALf S

negl
=

C,G ,S(A,J),J ((cid:4)σ)

(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)

r

...

⎫⎪⎬
(cid:4)σ1 ← Fm
⎪⎭
(cid:4)σn ← Fm
⎫⎪⎬
(cid:4)σ1 ← Fm
⎪⎭ .
(cid:4)σn ← Fm

V =1

...

r

r

r

(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)

Above, (cid:4)σ denotes ((cid:4)σ1, . . . , (cid:4)σn); V = 1 denotes con-
that V , on input
the tran-
ditioning on the event
C,G denotes
[[Π, (cid:4)x]]A,J, outputs 1; and f S
script of
the deterministic function such that f S
C,G(σ)
:=
C((

i=1 σi,m)) · G.

n
i=1 σi,1, . . . ,

(cid:2)

(cid:2)

n

Next, we extend the above deﬁnition to variable
number of parties and restricted circuit classes. Let r
be a prime, G = (cid:3)G(cid:4) a group of order r, and C a class
of Fr-arithmetic circuits. A secure sampling broadcast
protocol for C over G is a tuple ΠS = (Π, V, S) such
→ Fh
that, for every positive integer n and circuit C : Fm
r
r
in C, (Πn,C, Vn,C, Sn,C) is a secure sampling broadcast
protocol with n parties for C over G.

r

r

r

r

,

(cid:13)

→ Fh

×···× Fmn

× ··· × Fmn

4) Secure evaluation broadcast protocols
Let r be a prime, G = (cid:3)G(cid:4) an order-r group, n a positive
integer, and C : Fm1
r an Fr-arithmetic
circuit. A secure evaluation broadcast protocol with
n parties for C over G is a tuple ΠE = (Π, V, S),
where Π is an n-party broadcast protocol and V, S are
probabilistic polynomial-time algorithms, that satisﬁes
the following.
For every probabilistic polynomial-time algorithm A,
subset J of {1, . . . , n} with |J| < n, and input (cid:4)σ =
((cid:4)σ1, . . . , (cid:4)σn) in Fm1
{REALΠ,A,J ((cid:4)σ)}
Above, V = 1 denotes the event that V , on input the
transcript of [[Π, (cid:4)x]]A,J, outputs 1, and f E
C,G denotes the
C,G((cid:4)σ) := C((cid:4)σ) · G.
deterministic function such that f E
As before, we extend the above deﬁnition to variable
number of parties and restricted circuit classes. Let r be
a prime, G = (cid:3)G(cid:4) a group of order r, and C a class of
Fr-arithmetic circuits. A secure evaluation broadcast
protocol for C over G is a tuple ΠE = (Π, V, S) such
×
that, for every positive integer n and circuit C : Fm1
··· × Fmn
r in C, (Πn,C, Vn,C, Sn,C) is a secure
evaluation broadcast protocol with n parties for C over
G.

C,G ,S(A,J),J ((cid:4)σ)

IDEALf E

→ Fh

negl
=

(cid:14)

V =1

.

r

r

IV. SECURE SAMPLING FOR A CLASS OF CIRCUITS
Our main construction is a multi-party protocol for
securely sampling values of the form C((cid:4)α) · G for a

296296

random (cid:4)α, provided that C belongs to the class CS. We
use two cryptographic ingredients: commitment schemes
(see Section III-B) and NIZKs (see Section III-C); both
rely on a common random string, available in our setting
(see Section III-F1).

Theorem IV.1. Assume the existence of commitment
schemes and NIZKs. Let r be a prime and G a group of
order r. There is a secure sampling broadcast protocol
ΠS = (Π, V, S) for CS over G such that, for every
positive integer n and circuit C in CS,
• ROUND(Πn,C) = n · depthS(C) + 3.
• for i = 1, . . . , n, TIME(Πn,C, i) = Oλ(size(C)).
• Vn,C runs in time Oλ(n · size(C)).
• Sn,C runs in time Oλ(n · size(C)).
Our implementation and evaluation target the case
when G is a duplex-pairing group. This special case
allows for additional optimizations (when further relying
on random oracles), as discussed in Section V.
Proof strategy. We construct the protocol of Theo-
rem IV.1 in two steps. The ﬁrst step (Lemma IV.2) is
a reduction from the problem of constructing secure
sampling broadcast protocols to the problem of construct-
ing secure evaluation broadcast protocols. The second
step (Lemma IV.3) is a construction of such a secure
evaluation broadcast protocol.

Lemma IV.2 (Sampling-to-evaluation reduction). Let
r be a prime and G a group of order r. There exist
polynomial-time transformations T1 and T2 for which
the following holds.
• For every positive integer n and circuit C in CS:
(i) ˜C := T1(n, C) is a circuit in CE; (ii) for every
secure evaluation broadcast protocol ΠE with n parties
for ˜C over G, ΠS := T2(ΠE) is a secure sampling
broadcast protocol with n parties for C over G.
• T1 builds a new circuit ˜C is not much larger than C:
– depthE( ˜C) = n · depthS(C);
– size( ˜C) = O(n · size(C)); and
– size( ˜C, i) = O(size(C)) for i = 1, . . . , n.
• T2 increases the protocol’s round complexity by 1, and
preserves all time complexities up to Oλ(1) factors.
Lemma IV.3 (Evaluation protocol). Assume the existence
of commitment schemes and NIZKs. Let r be a prime
and G a group of order r. There is a secure evaluation
broadcast protocol ΠE = (Π, V, S) for CE over G such
that, for every positive integer n and circuit C in CE:
• ROUND(Πn,C) = depthE(C) + 2;
• TIME(Πn,C, i) = Oλ(size(C, i)) for i = 1, . . . , n;
• Vn,C and Sn,C run in time Oλ(size(C)).

297297

A. Sketch of the sampling-to-evaluation reduction

We sketch the proof of Lemma IV.2. At a high level, the
two transformations T1 and T2 work as follows.
• The circuit transformation T1, given the number of par-
ties n and a circuit C in CS, outputs a circuit ˜C ∈ CE
that computes C’s output, along with other auxiliary
values, by suitably combining n multiplicative shares
of C’s input.

• The protocol transformation T2, given a secure eval-
uation protocol ΠE for ˜C, outputs a secure sampling
protocol ΠS for C by:
(i) generating random shares
for all inputs, to ensure uniform sampling; (ii) ex-
tending the protocol by one last round, to obtain a
correctly-formatted output; (iii) extending the veriﬁer,
to account for the additional round in the transcript;
and (iv) extending the simulator, to account for the
different ideal functionality, whose output excludes the
aforementioned auxiliary values (which, hence, must
be simulated).

Most of the effort goes into constructing ˜C and the
simulator of ΠS. We thus brieﬂy discuss these two.
The circuit ˜C. The circuit ˜C must compute C’s output
from n multiplicative shares of C’s input (chosen at
random). If this were the only requirement, then we
could simply set ˜C equal to the circuit that, given as
input n shares (cid:4)α(1), . . . , (cid:4)α(n) ∈ Fm, ﬁrst combines the
m ) ∈ Fm and
shares into (cid:4)α := (
then computes C((cid:4)α). Unfortunately, such a circuit is not
in the class CE, and thus we cannot invoke Lemma IV.3
to securely evaluate ˜C (and do not know how to
obtain an efﬁcient protocol that does). The difﬁculty
thus lies in constructing a circuit ˜C that computes the
same function (perhaps with some additional, though
simulatable, outputs) and that, moreover, is in CE.

j=1 α(j)

1 , . . . ,

n

j=1 α(j)

(cid:2)

(cid:2)

n

We thus take an alternative approach, which leverages
the fact that C lies in the class CS. Intuitively, instead of
combining shares at the beginning, ˜C combines shares
“on the ﬂy”, as the circuit is computed, as we now
describe.

First consider the simple case where C has no non-
trivial addition gates, i.e., all gates are either multiplica-
tion gates or addition gates that output a constant. Our
reduction then outputs a circuit ˜C that contains n copies
of C as a sub-circuit (one for each party) such that
the #inputs(C) inputs of each copy are assigned to a
separate input slot of ˜C; corresponding outputs of each
copy are then multiplied together, thereby combining the
shares, via O(n · #outputs(C)) auxiliary multiplication
gates. See Figure 3a for an example.

More generally, of course, C may include addition
gates and, in such a case, the reduction is more complex,

10

ܽ ܾ

ܿ

 

 



ܽଵ ܾଵ ܿଵ

1

10
 

ܶଵ

 

 

 

 

 

 


ܽଶ ܾଶ
 

ܿଶ

 

 

5

ܽ

 

 

 

ܾ

ܿ

 

݀

 



5 ܽଵܾଵܿଵ݀ଵ

1

ܽଶܾଶ


ܿଶ݀ଶ

 

 

 

ܶଵ

 

 

 

 

 

1

 

 

 

 

 

(a) Example where C has only multiplication gates.

(b) Example where C has both addition and multiplication gates.
Fig. 3: Two examples of a circuit C in CS and the corresponding circuit ˜C := T1(C, n) in CE for n = 2 parties.
The blue arrows in C denote the output wires of C; the blue arrows in ˜C denote the output wires of ˜C that compute
outputs of C (while the remaining output wires carry partial computations).

because merely individually evaluating n copies of C
and then combining corresponding outputs does not
compute the correct function. The reason is not surprising:
while multiplicative sharing of inputs commutes with
multiplication, it does not commute with addition, and
thus it is hard to obtain multiplicative shares of the result
of an addition. To circumvent this problem, we break the
circuit down into components “separated” by additions,
and apply the above idea separately to each. In-between
components, before each addition, we combine shares.
In somewhat more detail, our construction works as
follows. For each multiplication gate gmul of C, we add
to ˜C a sub-circuit, consisting of O(n) multiplication
gates, that combines a value computed so far with all
the shares of gmul’s right input (which is, by deﬁnition
of CS, an input of C). For each addition gate gadd of C,
we add one addition gate to ˜C that combines the values
computed so far. Crucially, each of these sub-circuits, as
well as their combination, lies in CE. See Figure 3b.

A notable efﬁciency feature of our reduction is that
it ensures that the E-depth of ˜C, which determines the
number of rounds required to securely evaluate ˜C, is
“small”: it is bounded above by n times the S-depth
of C. Indeed, there are multiple ways to combine the
aforementioned sub-circuits, but many such ways yield
much worse efﬁciency, e.g., E-depth that is as worse as
n times the (standard) depth of C. Since the circuits
C that we encounter in this paper’s application have a
small S-depth, this feature is critical.
The simulator in ΠS. The construction of ˜C must
not only respect syntactic and efﬁciency requirements
(e.g., lie in CE, not have more than n · size(C) gates,
and so on), but must also be secure, in the sense that
the ideal functionality implemented by the evaluation
protocol ΠE for ˜C actually gives rise (with some simple
changes) to a sampling protocol ΠS that implements the
ideal functionality of C. Since our construction of ˜C

introduces additional, spurious outputs, the simulator in
ΠS must be able to reproduce the view of the adversary
when only having access to C’s output (rather than ˜C’s
output). Intuitively, this requires showing that partial
computations that carry information about a subset of
the parties’ shares do not leak additional information
beyond the outputs that incorporate every party’s share.
For an arbitrary circuit in CE such an argument cannot
be carried out. However, for the particular circuit ˜C that
is constructed from C we show that it is possible to
“back compute” the circuit: given the output of C, the
simulator can complete it into an output of ˜C by sampling
an assignment to the remaining (spurious) output wires
of ˜C, such that the simulated output is indistinguishable
from an evaluation of ˜C. This is done by taking each sub-
circuit in ˜C and computing backwards from its output.

B. Sketch of the evaluation protocol

We sketch the proof of Lemma IV.3. The evaluation
protocol ΠE = (Π, V, S) for C ∈ CE works as follows.
• In the ﬁrst round (t = 1), each party i individually
commits to each one of his own private inputs,
i.e., each party i commits to the values assigned to
wires in inputs(C, i), and proves, in zero knowledge,
knowledge of the committed values (using relation
RA of Figure 4).

• In each one of the subsequent depthE(C) rounds (t =
2, . . . , depthE(C)+1), each party i determines if there
are any gates g in gates(C) such that
(i) the E-depth
of output(g) equals the round number minus 1 (i.e,
t − 1), and (ii) if type(g) = mul then R-input(g)
depends only on inputs in inputs(C, i). If so, then party
i individually evaluates each such gate (in topological
order) and broadcasts the result, along with a zero-
knowledge proof that the evaluation was correct (using
relation RB of Figure 4). In this way, the parties prove
correct evaluation of all gates of C, ﬁrst processing

298298

all gates whose outputs have E-depth 1, then all those
whose outputs have E-depth 2, and so on.

• After depthE(C) such rounds,

in the last round
(t = depthE(C) + 2), party 1 consults the broadcast
messages so to gather, and broadcast in a single
message, the encoding of the value of every output
of C. The purpose of this last round is to construct
a syntactically well-formed output of the protocol;
tasking party 1 to do so is an arbitrary choice.

Since the circuit C belongs to the circuit class CE, by
deﬁnition of CE, whenever a party i is supposed to prove
correct evaluation of a gate g:
(i) if g is an addition
gate, then encodings for g’s inputs have been broadcast
in previous rounds, and (ii) if g is a multiplication gate,
an encoding for g’s left input has been broadcast in
previous rounds (or computed by i in this round) and i
knows the value for its right input. In either case, party
i can compute an encoding for g’s output, and knows a
witness to the NP statement that attests to this encoding’s
correctness. Moreover, note that, again since C belongs
to CE, every gate’s output wire is also an output wire of
C, so that broadcasting encodings of every gate’s output
does not leak information beyond what is leaked by the
output of the ideal functionality, C((cid:4)σ) · G.

The transcript of broadcast messages can be checked
by a veriﬁer V , by ensuring that input commitments carry
valid proofs and, for each gate, that the party responsible
for that gate has produced valid proofs for its evaluation
(based on suitable prior values); this ensures that the
circuit has been evaluated on the parties’ private inputs.
Moreover, the transcript can be generated by a simulator
S, having access to the encoding of the circuit’s output,
by simulating each proof of correct evaluation.

V. OPTIMIZATIONS FOR DUPLEX-PAIRING GROUPS
The use of NIZKs in Theorem IV.1 is “light”: the
sampling protocol uses NIZKs for two relations, denoted
RA and RB and deﬁned in Figure 4, that involve only
arithmetic in G and invocations of the commitment
veriﬁer COMM.Ver. While the theorem holds for any
choice of prime-order group G, we obtain a particularly-
efﬁcient instantiation when G is a duplex-pairing group
of order r; our implementation and evaluation target
this special case, which occurs, e.g., in the setting of
public-parameter generation for zk-SNARKs.
Strategy. The sampling protocol of Theorem IV.1 is
obtained in two steps: a reduction from sampling to
evaluation (Lemma IV.2), and an evaluation protocol
(Lemma IV.3). The reduction is efﬁcient, so we focus on
optimizing the evaluation protocol, by suitably instanti-
ating the commitment scheme and NIZKs for RA and
RB. This instantiation relies on random oracles.

299299

Choice of commitment scheme. We instantiate the
commitment scheme COMM with Pedersen commit-
ments [49]. Let P and Q be two generators of G,
for which there is no known linear relation (if G is
an elliptic curve group then such P and Q can be
found by applying point decompression to two random
strings, or heuristically, to SHA256(0) and SHA256(1)).
A Pedersen commitment cm for a value x is obtained
by letting cr be a random element of Fr and computing
cm := x · P + cr · Q.
Choice of NIZK for the relation RA. To prove knowl-
edge of a committed value x encoded in a commitment
cm, we use an adapted version of Schnorr’s protocol
[69] for zero-knowledge proof-of-knowledge of discrete
logarithm. In the interactive version of the protocol, the
prover ﬁrst chooses random α and β in Fr and produces
R = α·P +β·Q. The veriﬁer responds with a uniformly
sampled element c of Fr, to which ﬁnal prover message
is u := α + c · x, v := β + c · cr. The veriﬁer accepts iff
u · P + v · Q = R + c · cm. The protocol is made non-
interactive by applying Fiat–Shamir heuristic [47] (in
our concrete implementation, using SHA256 hashing).
Choice of NIZK for the relation RB. We ﬁnd that
in our implementation we only need a special case of
the relation RB. For this special case what needs to be
proved are the following two kinds of statements:
1) that a multiplicative relationship holds between a
committed to value and two elements of G: (P, α,
R, 0, c) ∈ RB ⇔ R := ασ · P, where σ is equal to
a value committed to in the commitment cm; and
2) that a multiplicative relationship holds between three
elements of G: (P, α,R, 1, c) ∈ RB ⇔ R := ασ·P,
where σ := logG c.

When G is a duplex pairing group, the proof for a
statement of the second kind is empty as anyone can
verify the statement by checking e(αP, c) = e(R,G).
To efﬁciently prove the statements of the ﬁrst kind,
we slightly modify the construction of Lemma IV.3.
We insert an additional round after the ﬁrst round
(in which all parties commit to their inputs). In this
additional round each party, for each of its inputs
x samples a random generator P of G, computes
R := x · P and outputs (P,R). Moreover, the party
outputs a NIZK proof-of-knowledge that the implicitly
deﬁned ˆx := logP R is indeed consistent with the
corresponding commitment cm, i.e. cm for x decommits
to logP R. Call the corresponding relation Raux. Note
that, publishing such encodings (P, x · P) of inputs x
does not break conﬁdentiality: a pair (Q, x·Q) (for some
Q) is necessarily output every time an input x is used
in a multiplication gate. By a hybrid argument, having

The NP relation RA. An instance-witness pair (x, w) is in
RA if and only if COMM.Ver(σ, cm, cr) = 1, when parsing
x as a commitment cm and w as a tuple (σ, cr) for which
σ ∈ Fr and cr is commitment randomness.
The NP relation RB. An instance-witness pair (x, w) is in
RB if and only if all the following checks pass.
1) Parse x as tuple (R,P, α, b, c) and w as a tuple (σ, cr).
2) Check that the G-element R equals the G-element ασ · P.
3) If b = 0, check that COMM.Ver(σ, c, cr) = 1; if b = 1,
check that the G-element c equals the G-element σ ·G (and
ignore cr).

Fig. 4: Description of the two NP relations RA and RB.

polynomially many such pairs is as helpful as having
just one. Equipped with such encodings checking RB
can be done just via pairing evaluations.

Finally, a NIZK proof for relation Raux is obtained by
combining the Σ-protocol for knowledge of a Pedersen
commitment, and Schnorr’s Σ-protocol for knowledge
of discrete logarithm in equality composition [70]. As
above, we make the resulting Σ-protocol non-interactive
by applying Fiat–Shamir heuristic.

VI. IMPLEMENTATION

→ Fh

Our system. We built a system that implements our
constructions. Given a prime r, an order-r duplex-
pairing group G = (cid:3)G(cid:4), and an Fr-arithmetic circuit
r in the class CS, our system provides a
C : Fm
multi-party protocol for securely sampling C((cid:4)α) · G for
r
random (cid:4)α in Fm
r . Speciﬁcally, the system implements the
constructions underlying Section IV’s theorems, in the
case when G is a duplex-pairing group. (As discussed
in Section V, if G is duplex-pairing, one can instantiate
commitment schemes and NIZKs very efﬁciently.)
Application to zk-SNARKs via integration with
libsnark.
The parameter generator of many
zk-SNARK constructions works as follows: evaluate
a certain circuit C at a random input (cid:4)α, and then
output pp := C((cid:4)α) · G as the proof system’s public
parameters. (See discussion in Section I-A.) Thus, our
system can be used to securely sample public parameters
of a zk-SNARK, provided that the circuit used in its
generator belongs to the circuit class CS. To facilitate
this application, we have integrated our code with
libsnark [45], a C++ library for zk-SNARKs. (In
particular, pp can be used directly by libsnark.)
Two zk-SNARK constructions. We worked out cir-
cuits for parameter generation for two (preprocessing)
zk-SNARK constructions: the one of [21], [25] and the
one of [31]. The ﬁrst zk-SNARK “natively” supports
proving satisﬁability of arithmetic circuits, while the

second zk-SNARK that of boolean circuits.
Speciﬁcally, we wrote code that lays out a circuit
CPGHR ∈ CS that can be used to generate public
parameters for [21], [25]’s zk-SNARK; likewise for
laying out a circuit CDFGK ∈ CS for [31]’s zk-SNARK.
We have invoked our system on both and demonstrated
the secure sampling of respective public parameters.

A critical issue is that CPGHR and CDFGK have size
quasilinear in the circuit whose satisﬁability is being
proved. A naive implementation of the computation
pattern of the zk-SNARK’s generator results in circuits
that are not in CS; conversely, a naive implementation
in CS results in circuits of quadratic size. Via careful
design, quasilinear-size circuits in CS can be obtained.

VII. EVALUATION

We describe the evaluation of our system, which
provides a multi-party protocol for securely sampling
C((cid:4)α) · G, where (cid:4)α is random, for circuits C that belong
to the circuit class CS (see Section VI).
Setup. We evaluated our system on a desktop PC with
a 3.40 GHz Intel Core i7-4770 CPU and 16 GB of
RAM available. All experiments are in single-thread
mode (though our code also supports multiple-thread
mode). When invoking functionality from libsnark
(with which our code is integrated), we selected the
build option CURVE=BN128, which means that group
arithmetic is conducted over a certain Barreto–Naehrig
curve [71] at 128 bits of security.
Costs for the general case. Our system’s efﬁciency
only depends on the size and S-depth of the circuit C
in CS, and also n (the number of participating parties).
In Figure 6 we report approximate costs for several
complexity measures: the number of rounds, each party’s
time complexity, the number of broadcast messages, the
transcript size, and the transcript veriﬁcation time.
Costs for two zk-SNARK constructions. When ap-
plying our system to generate public parameters for a
zk-SNARK, the circuit C is designed so that C((cid:4)α) · G
(for random (cid:4)α) equals the zk-SNARK’s generator output
distribution. This distribution depends on the particular
NP relation given as input to the generator; thus, the
circuit C also depends on this NP relation. Moreover,
different zk-SNARK constructions “natively” support
different classes of NP relations.

In order to shed light on our system’s efﬁciency when
applied to generate zk-SNARK public parameters, we
report the size and S-depth of the circuit C as a function
of the input NP relation, relative to two zk-SNARK
constructions.
• The zk-SNARK [31]. This zk-SNARK supports

300300

(cid:2)log2 Ng(cid:3)

boolean circuit satisﬁability: the generator receives as
input a boolean circuit D, and outputs public parame-
ters for proving D’s satisﬁability. If D has Nw wires
and Ng gates, our code outputs a corresponding circuit
((cid:6)log2 Ng(cid:7) +
C := CDFGK with size 2Nw + 2
1) + 10 and S-depth 2.
• The zk-SNARK of [21], [25]. This zk-SNARK supports
arithmetic circuit satisﬁability: the generator receives
as input an arithmetic circuit D, and outputs public
parameters for proving D’s satisﬁability. If D has Nw
wires and Ng gates, our code outputs a circuit C :=
((cid:6)log2 Ng(cid:7)+1)+38
CPGHR with size 11Nw +2
and S-depth 3.

(cid:2)log2 Ng(cid:3)

These costs are summarized in Figure 5 .
Costs for two concrete examples. We report costs for
the following concrete choices of a circuit C := CPGHR.
• Example #1: the circuit C targets Zerocash [8].
Namely, C((cid:4)α) · G (for random (cid:4)α) equals the output
distribution of the generator of the preprocessing
zk-SNARK on which Zerocash is based.
• Example #2:
the circuit C targets the scalable
zk-SNARK of [39]. Namely, C((cid:4)α) · G (for random
(cid:4)α) equals the output distribution of the generator used
to set up the scalable zk-SNARK.

Figure 5 reports the size and S-depth of C for these two
examples, and Figure 6 reports the corresponding costs.

VIII. CONCLUSION

it

Like time and space, trust is also a costly resource.
To facilitate the deployment of NIZKs and, in particular,
zk-SNARKs in various applications,
is not only
important to minimize the time and space requirements of
proving and veriﬁcation, but also the trust requirements of
parameter generation. The system that we have presented
in this paper can be used to reduce the trust requirements
of parameter generation for a class of zk-SNARKs: the
system provides a multi-party broadcast protocol in
which only one honest party, out of n participating ones,
is required to securely sample the public parameters.
Integration of our system with libsnark greatly
facilitates this application. As a demonstration, we have
used our system for securely sampling public parameters
for the zk-SNARKs of [21], [25], [31].
ACKNOWLEDGMENTS

We thank Bryan Parno and the anonymous referees
for numerous comments on an earlier draft that greatly
improved the clarity of this paper.

This work was supported by: The Air Force Research
Laboratory (AFRL) under contract FA8750-11-2-0211;
the Broadcom Foundation and Tel Aviv University
the Center for Science of
Authentication Initiative;

301301

Information (CSoI), an NSF Science and Technology
Center, under grant agreement CCF-0939370; the Check
Point Institute for Information Security; the U.S. Defense
Advanced Research Projects Agency (DARPA) and the
Air Force Research Laboratory (AFRL) under contract
FA8750-11-2-0211; the European Community’s Seventh
Framework Programme (FP7/2007-2013) under grant
agreement number 240258; the Israeli Centers of Re-
search Excellence I-CORE program (center 4/11); the
Israeli Ministry of Science and Technology; the Leona
M. & Harry B. Helmsley Charitable Trust; MIT Ofﬁce
of the Provost; The National Science Foundation under
award EFRI-1441209; and the Ofﬁce of Naval Research
under contract N00014-11-1-0470.
APPENDIX A

EXAMPLES OF CIRCUITS UNDERLYING GENERATORS
As discussed in Section I-A, the generator G of es-
sentially all known (preprocessing) zk-SNARK construc-
tions follows the same computation pattern. To generate
the public parameters pp for a given NP relation R, G
→ Fh
ﬁrst constructs an Fr-arithmetic circuit C : Fm
r
r
(which is somehow related to R), then samples (cid:4)α in
r at random, and ﬁnally outputs pp := C((cid:4)α) · G
Fm
(where G generates a certain group of order r). Different
zk-SNARK constructions differ in (i) which NP relations
R are “natively” supported, and (ii) how the circuit C
is obtained from R.

Below, we give two examples of how the generator
of a known zk-SNARK construction can be cast in the
above paradigm and, moreover, the resulting circuit C
lies in the class CS. Throughout, we denote by F[z] the
≤d[z]
ring of univariate polynomials over F, and by F
the subring of polynomials of degree ≤ d.
A. Example for a QAP-based zk-SNARK

× Fh

the generator of

We describe how to cast
[21]’s
zk-SNARK as computing the encoding of a random
evaluation of a circuit C that lies in CS. More precisely,
we consider [25]’s zk-SNARK, which modiﬁes [21]’s.
Supported NP relations. This zk-SNARK supports
arithmetic circuit satisﬁability, i.e., relations of the form
r : D((cid:4)x, (cid:4)w) = 0(cid:5)} where
RD = {((cid:4)x, (cid:4)w) ∈ Fn
D : Fn
r
QAPs. The construction is based on quadratic arith-
metic programs (QAP) [20]: a QAP of size m and degree
d over F is a tuple ( (cid:4)A, (cid:4)B, (cid:4)C, Z), where (cid:4)A, (cid:4)B, (cid:4)C are
≤d−1[z],
three vectors, each of m + 1 polynomials in F
and Z ∈ F[z] has degree exactly d. As shown in [20],
each relation RD can be reduced to a certain relation
R
( (cid:6)A, (cid:6)B, (cid:6)C,Z), which captures “QAP satisﬁability”, by

r is an Fr-arithmetic circuit.

→ F(cid:5)

r

× Fh

r

zk-SNARK

Circuit satisﬁability of D when D is

Danezis et al. [31]
Parno et al. [21], Ben-Sasson et al. [25]
Ben-Sasson et al. [8]
Ben-Sasson et al. [39]

a Nw-wire Ng-gate boolean circuit
a Nw-wire Ng-gate arithmetic circuit
Example #1’s arithmetic circuit
Example #2’s arithmetic circuit

2Nw + 2
11Nw + 2

(cid:3)log2 Ng(cid:4)
(cid:3)log2 Ng(cid:4)

Circuit C in CS
size(C)
((cid:3)log2
((cid:3)log2

Ng(cid:4) + 1) + 10
Ng(cid:4) + 1) + 38
138,467,206
8,027,609

depthS(C)
2

3

3

6

Fig. 5: Size and S-depth of the circuit C in CS obtained from D, for various choices of D.

Complexity measure

number of rounds
each party’s time complexity
number of broadcast messages
transcript size
transcript veriﬁcation time

general case
n · depthS(C) + 3
0.035 · size(C) ms
n · (depthS(C) + 3)
0.072 · n · size(C) kB
1.03 · n · size(C) ms

Cost for

Example #1
3n + 3
14,124 s
6n
12,877 · n MB
196,208 · n s

Example #2
6n + 6
4,048 s
6n
906 · n MB
50,945 · n s

Fig. 6: Our system’s costs for the general case, Example #1, and Example #2; n is the number of parties.

r

× Fh

→ F(cid:5)

r, the generator does:

computing ( (cid:4)A, (cid:4)B, (cid:4)C, Z) := GetQAP(D) for a suitable
function GetQAP; if D has Nw wires and Ng gates, then
the resulting QAP has size m = Nw and degree d ≈ Ng.
The parameter generator. On input an Fr-arithmetic
circuit D : Fn
r
1) Compute ( (cid:4)A, (cid:4)B, (cid:4)C, Z) := GetQAP(D), and denote
by m and d the QAP’s size and degree; then construct
→ Fd+7m+n+22
an Fr-arithmetic circuit C : F8
r
such that C(τ, ρA, ρB, αA, αB, αC, β, γ) computes the
following outputs:
(cid:2)
1, τ, . . . , τ d,
A0(τ )ρA, . . . , Am(τ )ρA, Z(τ )ρA,
A0(τ )ρAαA, . . . , Am(τ )ρAαA, Z(τ )ρAαA,
B0(τ )ρB, . . . , Bm(τ )ρB, Z(τ )ρB,
B0(τ )ρBαB, . . . , Bm(τ )ρBαB, Z(τ )ρBαB,
C0(τ )ρAρB, . . . , Cm(τ )ρAρB, Z(τ )ρAρB,
C0(τ )ρAρBαC, . . . , Cm(τ )ρAρBαC, Z(τ )ρAρBαC,
(A0(τ )ρA + B0(τ )ρB + C0(τ )ρAρB)β, . . . ,
(Am(τ )ρA + Bm(τ )ρB + Cm(τ )ρAρB)β,
(Z(τ )ρA + Z(τ )ρB + Z(τ )ρAρB)β,

r

(cid:3)

αA, αB, αC, γ, γβ, Z(τ )ρAρB, A0(τ )ρA, . . . , An(τ )ρA

.

2) Sample (cid:4)α in F8
r at random.
3) Compute pp := C((cid:4)α) · G.
4) Output pp.6

B. Example for a SSP-based zk-SNARK

i.e.,

Supported NP relations. This zk-SNARK supports
relations RD =
boolean circuit satisﬁability,
{((cid:4)x, (cid:4)w) ∈ {0, 1}n × {0, 1}h : D((cid:4)x, (cid:4)w) = 0(cid:5)} where
D : {0, 1}n × {0, 1}h → {0, 1}(cid:5) is a boolean circuit.
SSPs.
The construction is based on square span
programs (SSP) [31]: a SSP of size m and degree d
over F is a tuple ( (cid:4)A, Z), where (cid:4)A is a vector of m + 1
≤d−1[z] and Z ∈ F[z] has degree
polynomials in F
exactly d. As shown in [31], each relation RD can
be reduced to a certain relation R
( (cid:6)A,Z), which captures
“SSP satisﬁability”, by computing ( (cid:4)A, Z) := GetSSP(D)
for a suitable function GetSSP; if D has Nw wires and
Ng gates, then the resulting SSP has size m = Nw and
degree d ≈ Nw + Ng.
The parameter generator. On input a boolean cir-
cuit D : {0, 1}n × {0, 1}h → {0, 1}(cid:5), the generator
does the following.
1) Compute ( (cid:4)A, (cid:4)B, (cid:4)C, Z) := GetSSP(D), and denote
by m and d the SSP’s size and degree; then construct
→ Fd+2m+n+9
an Fr-arithmetic circuit C : F3
such
r
that C(τ, β, γ) computes the following outputs:

r

(cid:2)
1, τ, . . . , τ d,
A0(τ ), . . . , Am(τ ), Z(τ ),
(cid:3)
A0(τ )β, . . . , Am(τ )β, Z(τ )β,
γ, γβ, Z(τ ), A0(τ ), . . . , An(τ )

.

We explain how the generator of [31]’s zk-SNARK can
be cast as computing the encoding of a random evaluation
of a certain circuit C that lies in CS.

2) Sample (cid:4)α in F3
r at random.
3) Compute pp := C((cid:4)α) · G.
4) Output pp.7

6The ﬁrst d + 7m + 15 elements in pp form the proving key pk,

while the remaining n + 7 form the veriﬁcation key vk.

7The ﬁrst d + 2m + 5 elements in pp form the proving key pk,

while the remaining n + 4 form the veriﬁcation key vk.

302302

REFERENCES

[1] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge
complexity of interactive proof systems,” SIAM J. Comp., 1989.
[2] O. Goldreich, S. Micali, and A. Wigderson, “Proofs that yield
nothing but their validity or all languages in NP have zero-
knowledge proof systems,” JACM, 1991.

[3] M. Bellare and O. Goldreich, “On deﬁning proofs of knowledge,”

in CRYPTO ’92, 1993.

[4] O. Goldreich and Y. Oren, “Deﬁnitions and properties of zero-

knowledge proof systems,” Journal of Cryptology, 1994.

[5] M. Blum, P. Feldman, and S. Micali, “Non-interactive zero-

knowledge and its applications,” in STOC ’88, 1988.

[6] M. Blum, A. De Santis, S. Micali, and G. Persiano, “Non-

interactive zero-knowledge,” SIAM J. Comp., 1991.

[7] U. Feige, D. Lapidot, and A. Shamir, “Multiple noninteractive
zero knowledge proofs under general assumptions,” SIAM J.
Comp., 1999.

[8] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers,
E. Tromer, and M. Virza, “Zerocash: Decentralized anonymous
payments from Bitcoin,” in SP ’14, 2014.

[9] R. Canetti, R. Pass, and A. Shelat, “Cryptography from sunspots:
How to use an imperfect reference string,” in FOCS ’07, 2007.
[10] J. Clark and U. Hengartner, “On the use of ﬁnancial data as a

random beacon,” in EVT/WOTE ’10, 2010.

[11] National Institute of Standards and Technology. (2014) NIST
randomness beacon. [Online]. Available: http://www.nist.gov/itl/
csd/ct/nist beacon.cfm

[12] O. Goldreich, S. Micali, and A. Wigderson, “How to play any
mental game or a completeness theorem for protocols with honest
majority,” in STOC ’87, 1987.

[13] M. Ben-Or, S. Goldwasser, and A. Wigderson, “Completeness
theorems for non-cryptographic fault-tolerant distributed compu-
tation (extended abstract),” in STOC ’88, 1988.

[14] S. Micali, “Computationally sound proofs,” SIAM J. Comp., 2000.
[15] C. Gentry and D. Wichs, “Separating succinct non-interactive
arguments from all falsiﬁable assumptions,” in STOC ’11, 2011.
[16] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, “From ex-
tractable collision resistance to succinct non-interactive arguments
of knowledge, and back again,” in ITCS ’12, 2012.

[17] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth,
“Succinct non-interactive arguments via linear interactive proofs,”
in TCC ’13, 2013.

[18] J. Groth, “Short pairing-based non-interactive zero-knowledge

arguments,” in ASIACRYPT ’10, 2010.

[19] H. Lipmaa, “Progression-free sets and sublinear pairing-based
non-interactive zero-knowledge arguments,” in TCC ’12, 2012.
[20] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, “Quadratic
span programs and succinct NIZKs without PCPs,” in EURO-
CRYPT ’13, 2013.

[21] B. Parno, C. Gentry, J. Howell, and M. Raykova, “Pinocchio:

Nearly practical veriﬁable computation,” in SP ’13, 2013.

[22] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza,
“SNARKs for C: Verifying program executions succinctly and in
zero knowledge,” in CRYPTO ’13, 2013.

[23] H. Lipmaa, “Succinct non-interactive zero knowledge arguments
from span programs and linear error-correcting codes,” in
ASIACRYPT ’13, 2013.

[24] P. Fauzi, H. Lipmaa, and B. Zhang, “Efﬁcient modular NIZK

arguments from shift and product,” in CANS ’13, 2013.

[25] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct
non-interactive zero knowledge for a von Neumann architecture,”
in Security ’14, 2014, extended version at http://eprint.iacr.org/
2013/879.

[26] H. Lipmaa, “Efﬁcient NIZK arguments via parallel veriﬁcation

of Beneˇs networks,” in SCN ’14, 2014.

[27] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed,
E. Shi, and N. Triandopoulos, “TRUESET: Faster veriﬁable set
computations,” in Security ’14, 2014.

[28] M. Backes, D. Fiore, and R. M. Reischuk, “Nearly practical and
privacy-preserving proofs on authenticated data,” ePrint 2014/617,
2014.

303303

[29] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Wal-
ﬁsh, “Efﬁcient RAM and control ﬂow in veriﬁable outsourced
computation,” ePrint 2014/674, 2014.

[30] Y. Zhang, C. Papamanthou, and J. Katz, “Alitheia: Towards

practical veriﬁable graph processing,” in CCS ’14, 2014.

[31] G. Danezis, C. Fournet, J. Groth, and M. Kohlweiss, “Square
span programs with applications to succinct NIZK arguments,”
in ASIACRYPT ’14, 2014.

[32] P. Valiant, “Incrementally veriﬁable computation or proofs of

knowledge imply time/space efﬁciency,” in TCC ’08, 2008.

[33] T. Mie, “Polylogarithmic two-round argument systems,” Journal

of Mathematical Cryptology, 2008.

[34] G. Di Crescenzo and H. Lipmaa, “Succinct NP proofs from an

extractability assumption,” in CiE ’08, 2008.

[35] I. Damg˚ard, S. Faust, and C. Hazay, “Secure two-party computa-

tion with low communication,” in TCC ’12, 2012.

[36] S. Goldwasser, H. Lin, and A. Rubinstein, “Delegation of
computation without rejection problem from designated veriﬁer
CS-proofs,” ePrint 2011/456, 2011.

[37] N. Bitansky and A. Chiesa, “Succinct arguments from multi-
prover interactive proofs and their efﬁciency beneﬁts,” in
CRYPTO ’12, 2012.

[38] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, “Recursive
composition and bootstrapping for SNARKs and proof-carrying
data,” in STOC ’13, 2013.

[39] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Scalable
zero knowledge via cycles of elliptic curves,” in CRYPTO ’14,
2014, extended version at http://eprint.iacr.org/2014/595.

[40] N. Bitansky, R. Canetti, A. Chiesa, S. Goldwasser, H. Lin,
A. Rubinstein, and E. Tromer, “The hunting of the SNARK,”
ePrint 2014/580, 2014.

[41] M. Chase, M. Kohlweiss, A. Lysyanskaya, and S. Meiklejohn,
“Succinct malleable NIZKs and an application to compact shufﬂes,”
in TCC ’13, 2013.

[42] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and
M. Walﬁsh, “Verifying computations with state,” in SOSP ’13,
2013.

[43] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno, “Pinocchio
Coin: building Zerocoin from a succinct pairing-based proof
system,” in PETShop ’13, 2013.

[44] M. Fredrikson and B. Livshits, “Zø: An optimizing distributing

zero-knowledge compiler,” in Security ’14, 2014.

[45] SCIPR Lab.

libsnark: a C++ library for zkSNARK proofs.

[Online]. Available: https://github.com/scipr-lab/libsnark

[46] S. Nakamoto, “Bitcoin: a peer-to-peer electronic cash system,”

2009. [Online]. Available: http://www.bitcoin.org/bitcoin.pdf

[47] A. Fiat and A. Shamir, “How to prove yourself: practical solutions
to identiﬁcation and signature problems,” in CRYPTO ’87, 1987.
[48] J. Groth and R. Ostrovsky, “Cryptography in the multi-string

model,” in CRYPTO ’07, 2007.

[49] T. P. Pedersen, “Non-interactive and information-theoretic secure

veriﬁable secret sharing,” in CRYPTO ’91, 1992.

[50] J. F. Canny and S. Sorkin, “Practical large-scale distributed key

generation,” in EUROCRYPT ’04, 2004.

[51] J. Katz, A. Kiayias, H.-S. Zhou, and V. Zikas, “Distributing the
setup in universally composable multi-party computation,” in
PODC ’14, 2014.

[52] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay — a

secure two-party computation system,” in SSYM ’04, 2004.

[53] a. shelat and C.-h. Shen, “Fast two-party secure computation

with minimal assumptions,” in CCS ’13, 2013.

[54] M. Bellare, V. T. Hoang, S. Keelveedhi, and P. Rogaway,
“Efﬁcient garbling from a ﬁxed-key blockcipher,” in SP ’13,
2013.

[55] A. C.-C. Yao, “How to generate and exchange secrets,” in

SFCS ’86, 1986.

[56] Y. Lindell and B. Pinkas, “A proof of security of Yao’s protocol

for two-party computation,” Journal of Cryptology, 2009.

[57] A. Ben-David, N. Nisan, and B. Pinkas, “FairplayMP: a system

for secure multi-party computation,” in CCS ’08, 2008.

[58] I. Damg˚ard, M. Geisler, M. Krøigaard, and J. B. Nielsen, “Asyn-
chronous multiparty computation: Theory and implementation,”

in PKC ’09, 2009.

[59] J. Katz, R. Ostrovsky, and A. Smith, “Round efﬁciency of
multi-party computation with a dishonest majority,” in EURO-
CRYPT ’03. Springer-Verlag, 2003.

[60] R. Pass, “Bounded-concurrent secure multi-party computation

with a dishonest majority,” in STOC ’04. ACM, 2004.

[61] C. Orlandi, “Is multiparty computation any good in practice?” in

ICASSP ’11, 2011.

[62] I. Damg˚ard, M. Keller, E. Larraia, V. Pastro, P. Scholl, and N. P.
Smart, “Practical covertly secure MPC for dishonest majority -
Or: Breaking the SPDZ limits,” in ESORICS ’13, 2013.

[63] I. Damg˚ard, R. Lauritsen, and T. Toft, “An empirical study
and some improvements of the MiniMac protocol for secure
computation,” in SCN ’14, 2014.

[64] R. Bendlin, I. Damg˚ard, C. Orlandi, and S. Zakarias, “Semi-
homomorphic encryption and multiparty computation,” in EU-
ROCRYPT ’11, 2011.

[65] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias, “Multi-
party computation from somewhat homomorphic encryption,” in
CRYPTO ’12, 2012.

[66] G. Asharov, A. Jain, A. L´opez-Alt, E. Tromer, V. Vaikun-
tanathan, and D. Wichs, “Multiparty computation with low
communication, computation and interaction via threshold fhe,”
in EUROCRYPT ’12, 2012.

[67] S. Garg, C. Gentry, S. Halevi, and M. Raykova, “Two-round
secure MPC from indistinguishability obfuscation,” in TCC ’14,
2014.

[68] G. Asharov and Y. Lindell, “A full proof of the BGW protocol
for perfectly-secure multiparty computation,” ePrint 2011/136,
2011.

[69] C. P. Schnorr, “Efﬁcient signature generation by smart cards,”

[70] D. Chaum and T. P. Pedersen, “Wallet databases with observers,”

Journal of Cryptology, 1991.

in CRYPTO ’92, 1992.

[71] P. S. L. M. Barreto and M. Naehrig, “Pairing-friendly elliptic

curves of prime order,” in SAC’05, 2006.

304304

