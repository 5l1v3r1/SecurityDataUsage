Designing Privacy-preserving Smart

Meters with Low-cost Microcontrollers

Andres Molina-Markham, George Danezis†,
Kevin Fu, Prashant Shenoy, and David Irwin

University of Massachusetts Amherst

†Microsoft Research Cambridge

Abstract. Smart meters that track ﬁne-grained electricity usage and
implement sophisticated usage-based billing policies, e.g., based on time-
of-use, are a key component of recent smart grid initiatives that aim to
increase the electric grid’s eﬃciency. A key impediment to widespread
smart meter deployment is that ﬁne-grained usage data indirectly reveals
detailed information about consumer behavior, such as when occupants
are home, when they have guests or their eating and sleeping patterns.
Recent research proposes cryptographic solutions that enable sophisti-
cated billing policies without leaking information. However, prior re-
search does not measure the performance constraints of real-world smart
meters, which use cheap ultra-low-power microcontrollers to lower de-
ployment costs. In this paper, we explore the feasibility of designing
privacy-preserving smart meters using low-cost microcontrollers and pro-
vide a general methodology for estimating design costs. We show that
it is feasible to produce certiﬁed meter readings for use in billing pro-
tocols relying on Zero-Knowledge Proofs with microcontrollers such as
those inside currently deployed smart meters. Our prototype meter is
capable of producing these readings every 10 seconds using a $3.30USD
MSP430 microcontroller, while less powerful microcontrollers deployed
in today’s smart meters are capable of producing readings every 28 sec-
onds. In addition to our results, our goal is to provide smart meter de-
signers with a general methodology for selecting an appropriate balance
between platform performance, power consumption, and monetary cost
that accommodates privacy-preserving billing protocols.

1

Introduction

The goal of recent smart grid initiatives is to increase the electric grid’s eﬃciency
by reducing both its monetary and environmental cost. One way to increase eﬃ-
ciency is to alter electricity demand by either shifting some of it to oﬀ-peak hours
or better aligning it with intermittent renewable generation. Since directly con-
trolling the grid’s electricity consumption, e.g., by forcibly disconnecting loads,
is infeasible, smart grids focus on incentivizing consumers to change their own
consumption patterns by altering the price of electricity to accurately reﬂect
generation costs and aggregate demand.

A variety of billing policies that properly incentivize consumers are available
to utilities. For instance, time-of-use (TOU) pricing alters the price for electricity

($/kWh) based on the time of day, with peak daytime rates more expensive than
oﬀ-peak nighttime rates. Utilities implicitly assume that TOU pricing requires
them to know not only how much electricity consumers use each month, but also
when they use it. Unfortunately, prior research demonstrates that ﬁne-grained
usage data indirectly reveals sensitive private information about a consumer’s
activity patterns, e.g., when they are home, when they have guests, their eating
and sleeping patterns, etc. [21]. Vast collections of ﬁne-grained electricity data for
many buildings over long periods of time raise both legal and economic concerns.
To address these issues, researchers have proposed a variety of privacy-preserving
billing protocols that prevent utilities from linking ﬁne-grained usage patterns
to individual households, but still allow them to implement sophisticated billing
policies. The solutions draw on common cryptographic techniques, including
commitment schemes, digital signatures and Zero-Knowledge Proofs (ZKP).

A key impediment to the widespread adoption of privacy-preserving billing
protocols is the computational and memory constraints of smart meters, which,
due to cost, size, and power considerations, typically use embedded microcon-
trollers. Prior work does not measure these resource constraints, and, thus, im-
plicitly assumes that meters are capable of executing protocols in a reasonable
amount of time. In this paper, we explore the economic feasibility of implement-
ing the cryptographic techniques required for privacy-preserving smart metering,
and propose a general methodology for evaluating the cost of a solution. We take
into account current smart meter deployments and look at the hardware tech-
nologies utilities are adopting over both the short- and long-term. Our focus is
on implementing cryptographic techniques on smart meters such as those pro-
posed by Rial et al. [25], Molina-Markham et al. [21], Kursawe et al. [18] and
Jawurek et al. [17]. However, our methodology also applies to estimating the cost
of similar metering systems that require privacy, including natural gas, water,
and toll roads, such as the one proposed by Balasch et al. [2]. We summarize our
contributions below:
Implementation. We implement a privacy-friendly smart meter using low-cost
microcontrollers from both the MSP430 and ARM families. We present the ﬁrst
experimental results that actually measure the performance of a Camenisch-
Lysyanskaya (CL) based scheme using elliptic curves in constrained environ-
ments. Previous work [25] discusses and estimates, but does not include imple-
mentation results. The most comparable realization of a CL based scheme uses
a Java Card [5] and does not include an elliptic curve version.
Cost Evaluation. We outline a cost evaluation strategy for implementing privacy-
preserving smart meters that accounts for the special characteristics of low-cost
microcontrollers and industry trends. In particular, we list a set of system vari-
ables that designers may modify to balance security, privacy, and cost. We are the
ﬁrst to discuss the issues surrounding ultra-low-power implementations, which
in some applications may make the diﬀerence between a meter that requires a
battery replacement every few years versus every few days.
Feasibility Analysis. We present evidence to support the hypothesis that ZKP
billing protocols are feasible on current deployments of smart meters and cost ef-

fective on deployments over both the short- and long-term. Because some smart
meters can be remotely updated, it is plausible that a deployment may be im-
plemented in one of these updates. In the long-term, our experimental results
may help system designers to assess the performance and cost beneﬁts of uti-
lizing elliptic curve primitives. Our analysis takes into account the evolution
of the storage and computational capabilities of low-cost microcontrollers and
contrasts it to the evolution of personal computer processors.

2 Cryptographic Building Blocks

This work builds on protocols for privacy-preserving calculations of time-of-use
based bills for smart electricity metering. In that setting a customer ﬁtted with a
smart meter proves to a utility provider the amount to be paid for their electricity
consumption within a speciﬁc time period, without revealing any details about
their ﬁne-grained consumption. The bill is calculated on the basis of detailed
readings, every half hour or ﬁfteen minutes, that are each billed according to
the dynamic price of electricity at that time, or a pre-deﬁned but time variable
tariﬀ scheme. These protocols are applicable when consumers do not trust the
utility with their detailed electricity usage information, and the utility does not
rely on consumers to honestly report their usage. Our work focuses on eﬃcient
implementations of the meter components on diﬀerent families of processors
necessary to support those protocols.

2.1 Commitment Schemes & Zero-Knowledge Proofs

Commitment schemes are cryptographic primitives that enable a party to create
the digital equivalent of an envelope for a secret. Commitments support two
important properties: hiding protects the secrecy of the committed message,
and binding ensures it can only be opened to the committed message.

Pedersen commitments [23] are information-theoretically hiding, and binding
under the discrete logarithm assumption. They rely on a set of global parameters,
namely a group G of prime order p with generators g and h. Under that scheme
a commitment C to message r ∈ Zp is computed as C = grho where o is an
opening nonce chosen uniformly at random in Zp. Opening a commitment C
involves disclosing the values r and o to a veriﬁer. In addition to opening the
commitment, eﬃcient protocols exist for a prover to convince a veriﬁer that they
know the committed value without disclosing it.

Fujisaki-Okamoto commitments [13] are similar to Pedersen commitments,
except that they make use of a group of composite, hidden order instead of a
group of prime order. They allow the committed value to be any integer, includ-
ing negative integers. We can use Pedersen or Fujisaki-Okamoto commitments
depending on whether the meter needs to encode negative values or not.

For the purposes of time-of-use billing, the meter periodically commits to me-
ter readings. Those commitments are signed and the customer can use the signa-
ture to prove functions of the bill to a veriﬁer. Diﬀerent signature schemes may be

used to achieve diﬀerent security properties. A standard signature scheme, such
as DSA, can be used to ensure the integrity of any further statement proved on
the basis of the meter readings. On the downside, it is not possible to eliminate
covert channels that may allow a dishonest meter to signal some information
back to the utility veriﬁer. When meters are not trusted for privacy, a signature
scheme such as Camenisch-Lysyanskaya (CL) signatures [7] can be used to sign
readings individually.

CL-signatures allow a requesting party to obtain a digital signature on a
commitment from an authorized signer. In particular, Camenisch and Lysyan-
skaya [7] provide eﬃcient protocols for computing a signature on a commitment
message, as well as for constructing zero-knowledge proofs of knowledge of a
signature on a committed or encrypted message. Note that there are two dig-
ital signature schemes attributed to Camenisch and Lysyanskaya; their earlier
scheme [6] relies on the Strong RSA assumption, while the later scheme relies
on a discrete-logarithm-based assumption (the LRSW assumption) [20]. CL-
signatures [7] can be implemented using elliptic curve groups, as long as we have
an eﬃcient bilinear map that is non-degenerate. We describe the key genera-
tion function, the signing function and the signature veriﬁcation function for
CL-signatures using the notation in [26]:

1. CLKeyGen(1k). Given a security parameter k, and the number of block
messages to sign n, the signer generates the ﬁrst part of their public key:
(p, G, H, g, h, e), such that there is a mapping e : G × G → H, which is
bilinear, non-degenerate and eﬃcient to compute. The signer then chooses
the following parameters for their private key: x, y, z1, . . . , zn ∈R Zp. Next,
the signer uses these parameters to compute X = gx, Y = gy and Zi = gzi for
all i ∈ [1, n]. The public key is pubkey = (p, G, H, g, h, e, X, Y,{Zi},{Wi}),
and the secret key is the public key concatenated with (x, y,{zi}).
2. CLSign((x, y,{zi}),{mi}). To sign n blocks {mi}, the signer ﬁrst chooses
a ∈R G, and computes b = ay. The signer then computes Ai = azi and Bi =
i=2 Axymi
.
The signature is sig = (a,{Ai}, b,{Bi}, σ).
3. CLV erif ySign(pubkey,{mi}, sig). The veriﬁer performs the following com-
putations and outputs accept if the following equalities hold: e(a, Y ) =
e(g, b); e(a, Zi) = e(g, Ai),∀i ∈ [1, n]; e(Ai, Y ) = e(g, Bi),∀i ∈ [1, n]; and

(Ai)y for all i ∈ [2, n]. Finally, the signer computes σ = ax+xym1(cid:81)n
e(g, σ) = e(X, a) · e(X, b)m1 ·(cid:81)n

i

i=2 e(X, Bi)mi.

ZKPs make use of commitments and CL-signatures to prove to a third party
an aggregate function of the committed readings without revealing the enclosed
readings. The full billing protocol proposed by Rial et. al. [25] decomposes a bill’s
proof of correctness into a small set of ZKPs – eﬀectively proving the correctness
of a commitment to the price component of each period of consumption sepa-
rately before aggregating them and disclosing the ﬁnal bill. All proofs in their
scheme are non-interactive by using the well known Fiat-Shamir heuristic [12].

2.2 A Smart Metering Billing Protocol

Our study focuses on the eﬃcient implementation of the meter cryptographic
components for the Rial and Danezis [25] privacy preserving smart metering
protocols. Proposals by [17] can be adapted to use the same meter components.

Fig. 1. Architecture of the privacy-preserving smart metering system. A smart meter,
in addition to its metrologic unit, has a microcontroller capable of encrypting and
certifying its readings. The meter also has a wireless transceiver used to send encrypted
readings to the consumer’s device. The consumer uses the information from the meter
for consumption planning, and in the computation of bills and corresponding proofs.

We illustrate the protocol with an example that includes three principals, as
depicted in Figure 1: the smart meter, the prover, and the veriﬁer. The smart
meter ﬁrst measures and certiﬁes consumer electricity readings, and then com-
municates them to the prover using a secure channel. The prover, a consumer-
owned device, computes a bill along with a non-interactive ZKP that ensures
the bill’s validity. The prover sends the bill and the proof to the utility company,
which veriﬁes the bill’s correctness before accepting it. Below, we describe in
detail the computations the meter has to perform, and provide a brief outline of
the protocols between the prover and the veriﬁer.
Smart Meter Computations. To support privacy protocols, smart meters
need to perform the following computations: sensing and measuring electric-
ity usage, deriving session keys, certifying and encrypting readings, and ﬁnally
transmitting readings to the consumer.
Sensing and measuring electricity. The meter’s primary function is sensing and
measuring electricity usage. Thus, other computations must not interfere with
this fundamental task. We denote ∆t as the measurement interval, such that
duration between meter readings ti+1 − ti = ∆t.
Deriving session keys. The protocol encrypts readings using a symmetric en-
cryption algorithm before passing them to the user. To ensure the encrypted
reading’s secrecy, each reading is encrypted with a distinct session key. For ev-
ery ti the meter encrypts reading ri using key Ki = H0(K, ti), where H0 is a
secure hash function and K is a master symmetric key known by the consumer.

On-sitePrivacy-Preserving MeterConsumer DeviceOff-site   Metrology•Obtain readingsReading Certification•Derive Keys•Encrypt Readings•Compute Commitments•Create Batch Signature•Transmit Encrypted ReadingsCommitment Reconstruction•Derive Keys•Decrypt Readings•Reconstruct CommitmentsBill Computation•Compute Bill•Compute ProofUtility Provider's ServerBill Verification•Verify Bill•Verify Proof     Accept BillAdditionally, the meter derives from the master key an opening value for the
commitment oi = H1(K, ti) where H1 is a hash function.
Certiﬁcation and encryption. After deriving Ki and oi, the meter both encrypts
the reading ri using Ki and computes a commitment ci for the reading. More
formally, the meter generates an encrypted reading Eri = E(Ki, ri) using a
symmetric encryption algorithm, and a commitment ci = gri · hoi using globally
known constants g, h, and their group. The protocol also requires the meter to
generate cryptographic signatures for each commitment ci. To reduce the nec-
essary computations, the protocol computes batch signatures Sigj for multiple
commitments ci, ci+1, . . . , ci+k.
Network transmission. After the meter encrypts readings and computes batches
of signatures, it transmits the batches to the consumer’s device (the prover)
via the local network. More formally, for each batch j, the meter transmits the
following tuples to the consumer: {{ti}j,{Eri}j, Sigj}. The commitments need
not be transmitted, which keeps the overheads of the protocol low.
Consumer Prover Computations. The prover computes the bill’s payment
and its corresponding proof of correctness. First, the prover derives the session
keys Ki = H0(K, ti) on the basis of times ti and the master key K; decrypts
the readings ri from Eri = E(Ki, ri), and derives the opening values from each
commitment as oi = H1(K, ti). Then all commitments to readings can be recon-
structed as ci = gri · hoi using the public parameters of the commitment scheme
and the recovered readings and openings. Finally, a batch of commitments are
accepted as authentic after checking the signature Sigj. This ensures that the
received encrypted readings have not been tampered with. After the readings
and their signed commitments are available, an arbitrary billing function can
be applied to each reading (or aggregates of readings) to establish the ﬁnal bill.
The prover calculates a ZKP of correctness and provides it to the veriﬁer.
Summary. The details of those computations, and families of functions that
can be practically proved and veriﬁed in zero-knowledge are provided in [25]
along with the detailed security proofs for the protocol. To summarize, ﬁne-
grained meter readings are only available to the consumer, while simultaneously
allowing the consumer to self-calculate their bill and ensuring the utility that the
consumer has not manipulated or under-reported the payment. Thus, the utility
has a guarantee over each bill’s authenticity, and the consumer has a guarantee
over their data’s privacy. To resolve disputes, the meter may optionally store
readings and decryption keys to permit audits by a trusted third party.

3

Implementation on Low-Cost Microcontrollers

In this section we describe a few diﬀerent implementations of the cryptographic
primitives discussed in Section 2 that would be required to run on a smart
meter. We start by pointing out that the computational capabilities of low-cost
and ultra-low-power microcontrollers have not developed at the same pace as
high-performance microprocessors employed in servers and personal computers.
System designers should, therefore, use diﬀerent means to evaluate the economic

feasibility of a cryptographic solution in the low-cost spectrum of embedded
devices. We present the set of design variables that we control in our various
implementations with the purpose of illustrating their eﬀects on performances
and costs in subsequent sections.

3.1 Computing Capabilities of Low-Cost Microcontrollers

Moore’s law predicted that the number of transistors placed in an integrated
circuit would double approximately every two years. This prediction, however,
does not directly address two issues that are pertinent to microcontrollers. First,
the production costs associated with maintaining this trend have not remained
constant. Second, with the addition of more transistors, the problem of eﬃcient
power management has signiﬁcantly increased [11]. As a consequence, microcon-
trollers that are often constrained by production costs and power budgets have
not increased their computational capabilities at the same rate as microproces-
sors for servers and personal computers. In Figure 2 we illustrate this by showing
the evolution in processing capabilities across diﬀerent technologies.

Fig. 2. While it is diﬃcult to compare the performances of microprocessors using mil-
lions of instructions per second, this graph provides a visual representation of perfor-
mance improvements as seen across a few popular architectures. The trends in micro-
processors targeting desktop computers and servers, as well as the performance im-
provements observed in ARM application microprocessors have followed exponential
curves. However, the performance improvements observed in embedded ARM micro-
processors and MSP430 microcontrollers have followed linear curves [1, 8, 16].

2010197019751980198519901995200020053500050010001500200025003000YearMIPSIntelARMARMMSP4304 MIPS25 MIPSIntelMulticoreApplicationEmbedded3.2 Design Variables

In this section, we enumerate a set of design variables that we consider in our im-
plementations with the purpose of illustrating their eﬀect on various properties
of the system. As we show, some of these design variables correspond to features,
such as qualitative privacy or security guarantees, e.g. properties of a trust or
security model. Other design variables correspond to quantitative properties, for
example computation performance, storage and communication requirements.
The design variables that we consider in our implementation are in one of two
categories, system variables or crypto variables. System variables include the
selection of an MCU platform and a multitasking approach. Crypto variables
include the selection of a digital signature scheme, and the selection of cryp-
tographic primitives that rely on large integer multiplicative groups or elliptic
curve cryptography. We should note that a complete analysis of the economic
feasibility of a metering solution should also include a variety of economic vari-
ables, for example, the costs of implementation, deployment, maintenance and
customer support. These economic variables are not considered explicitly in this
work. We assume that if a solution can be implemented using microcontrollers,
such as those in currently deployed meters, and those meters support software
updates, then the solution is economically feasible given that it does not require
a complete change in infrastructure. For example, rather than forcing millions
of deployments, utility companies could oﬀer concerned customers the option to
request a meter update that implements the privacy features mentioned here.

3.3 Anatomy of a Smart Meter

In order to provide context for our discussion, we describe the generic anatomy of
a smart meter. Figure 3 shows the schematics of a smart meter. In general, they
are equipped with an analog front end, which is part of the metrologic unit used
to convert the data coming from the load sensors and preprocess the measure-
ments before they are passed to the microcontroller unit. The microcontroller
unit handles this stream of data as well as the general functionality of storing the
data in ﬂash memory, and driving an LCD screen. More modern microcontrollers
replace the analog front end with an integrated embedded signal processor. Cur-
rent deployments of smart meters use microcontrollers that run at clock speeds
ranging from 8-25 MHz and have storage ranging from 32-256 KB [14].

3.4 Implementation Details

We implement the algorithms Commit, CLSign and DSA, using both large in-
teger multiplicative groups and elliptic curve cryptography. We also implement
the symmetric key derivation algorithm DeriveAESKeys to encrypt readings
with AES for on-site wireless transmission. We integrate these algorithms to pro-
duce certiﬁed readings, as discussed in Section 2. In our experiments, we use the
libraries bnlib [24] and Miracl [27] to perform integer or elliptic curve arithmetic,
together with one of the following Real-Time Operating Systems: FreeRTOS [4],

SYS/BIOS [30] and MicroC/OS-III [19]. We write the rest of the implementa-
tion in C, with some minimal amount of assembly code. We describe the par-
ticular details of the ECC implementation in Section 3.5. We focus primarily
on the MSP430 family of microcontrollers with a 16-bit RISC architecture. The
motivation behind this focus is that current deployments already include mi-
crocontrollers in this family. We use the evaluation board MSP-EXP430F5438,
in combination with the microcontrollers MSP430BT5190 and MSP430F5438A.
The board includes an LCD screen and connectors for radio components. We also
use the radio stack CC2567-PAN1327. Both microcontrollers are from the same
family (MSP430x5xx). Shared characteristics include the availability of a hard-
ware multiplier supporting 32-bit operations, size of ﬂash (256 KB), frequency
(25 MHz), and power consumption (∼ 230 µA/MHz in active mode). The man-
ufacturers designed the MSP430BT5190 for use with the radio stack; however,
the MSP430F5438A has a larger RAM (16 KB). In our evaluation, we compare
a few ARM microcontrollers and processors. For this we use readily available
ARM ports for all the libraries mentioned above. We compile our code and the
libraries using IAR Embedded Workbench for ARM version 6.30 [15]. The most
signiﬁcant diﬀerence is that the word size for the multi-precision arithmetic is 32
instead of 16, which we use in the MSP430 implementations. The other micro-
controller board we use is the TI Stellaris Evaluation Board EKB-UCOS3-EVM.
The ARM processors we measure are capable of running full Linux distributions;
nevertheless, we perform the measurements using IAR Workbench as well.

3.5 Elliptic Curve Cryptography Details

The full ZKP based billing protocol requires the selection of various building
blocks, such as commitment schemes and signatures. The security of these build-
ing blocks may depend on either the strong RSA (SRSA) assumption [6], or on
the discrete logarithm (LRSW) assumption [7]. One important side-eﬀect of
the selection of these building blocks is that in order for the SRSA assump-
tion to hold, the cryptographic operations need to be performed over multi-

Fig. 3. Main components of a smart meter. On the left we illustrate a simple meter
with a single microcontroller unit (MCU) that controls the metrologic unit, storage and
communication interfaces. On the right we show a smart meter that replaces the analog
front end with an embedded signal processor (ESP) and has an additional application
processor that controls communication, OS, power monitoring, and analytics.

MCULCD DisplayMemoryClockAnalogFrontendsensorsensorloadI InV In3VCommMCULCD DisplayESPsensorsensorloadI InV In3VCommMemoryClockApplicationProcessorplicative groups of integers with large moduli (1,024 to 2,048 bits in length).
However, by leveraging modern Elliptic Curve Cryptography, the designer can
use building blocks that rely on the discrete logarithm assumption employing
considerably smaller key sizes. Therefore, for the ECC based commitments and
ECDSA implementations, we use the NIST curves P-192 and P-224 [9]. For the
ECC versions of the CL Signatures, we use the pairing-friendly elliptic curves
E(F2379) : y2 + y = x3 + x + 1 and E(Fp) : y2 = x3 + Ax + B with a 512-bit
prime p as presented in [29].

The criteria for choosing curve parameters for ECDSA and the commitment
scheme that we used are well known. However, choosing appropriate parameters
for pairing-based cryptography is still an active area of research. That is, to use
an elliptic curve implementation for CL-signatures, we require an appropriate
bilinear map e : G × G → H that is non-degenerate and easy to compute. There
is no unique way to obtain this map using elliptic curve groups G, H. While
most protocols, such as signatures and identity based encryption protocols, are
designed using a type-1 pairing, it is often possible to use a type-3 pairing. The
latter are typically more eﬃcient in practice. In other words, protocols often
assume the existence of a pairing e : G × G → H (type-1). However, in some
cases the designer can implement a protocol that assumes the existence of a
pairing e : G1 × G2 → H with G1 (cid:54)= G2 such that there is no isomorphism
ψ : G2 → G1 (type-3). We choose to implement type-1 pairings on a super-
singular curve deﬁned over GF (2m) using the ηT pairing [3] and on a super-
singular curve deﬁned over GF (p) using a modiﬁed Tate pairing [28]. In order
for the curves to provide an adequate security guarantee, the size of the key must
be large enough so that the corresponding dilogarithm problem in H is hard. For
the purposes of the particular billing protocol described in this paper, we note
that a smart meter needs to compute signatures and not necessarily verify them.
Therefore, we want to make operations on the curve as cheap as possible, even
if that means computing more expensive parings on the consumer’s device. For
more details on pairings, we refer the reader to Devegili et al. [10].

4 Experimental Evaluation

In this section, we evaluate the impact of choosing each of the design variables
overviewed in Section 3. We ﬁrst describe the impact of choosing a family of mi-
crocontrollers on overall computing performance. Next, we discuss the impact of
choosing an approach for multitasking on the RAM requirements and total cost
size. Finally, we discuss the impact of choosing various cryptographic primitives.

4.1 Impact of Platform Selection

We implemented the cryptographic operations Commit and CLSign using mi-
crocontrollers from two of the most popular families, speciﬁcally, a microcon-
troller MSP430F5438A with 256 KB ﬂash, 16 KB RAM and a microcontroller
Stellaris LM3S9B92 (ARM Cortex M) with 256 KB ﬂash, 96 KB SRAM; and

two ARM application microprocessors OMAP3 (ARM Cortex A8) and OMAP4
(ARM Cortex A9) capable of running full Linux operating systems. These two
microprocessors are commonly used in smart phones. The performances of these
operations on these platforms are summarized in Table 1.

4.2 Impact of Multitasking Approach

Meters need to be able to interrupt cryptographic computations periodically
to perform measurements, logging and communication. One way of handling
multitasking is with the use of an RTOS. Another way is the modeling of an ap-
plication using a ﬁnite state machine and the implementation of it using timers
and interrupts. Generally, the footprint of an RTOS is larger than the footprint
of a state machine approach. We explore the following three RTOS in our work:
FreeRTOS, SYS\BIOS and µC-OSIII. Our conﬁgurations for each of the RTOS
use 4 KB, 16 KB and 12 KB of code size respectively. The ﬁnite state machine
requires approximately 2 KB of code. RTOS have the capability of managing
memory; some by reserving particular regions of the stack for diﬀerent appli-
cations, and some by allowing for the use of dynamic memory allocation even
with multiple heaps, such as SYS\BIOS. It is typically not a trivial engineering
exercise to ﬁt each cryptographic algorithm in RAM. We should also note that
the system designer should probably base the decision of whether or not to use
an RTOS on the necessity of additional required functionality, such as occasional
tasks like secure updates, secure audits, key exchange and key revocation, etc.

Table 1. Running time of commitments and signatures across multiple platforms. The
tasks are run exclusively and uninterrupted on each of the platforms. The signatures
are performed on 16 bytes of data. DSA uses a 1,024-bit prime p, a 160-bit prime q, and
SHA-256. The timing does not include the generation of randomness, which depends
on the source. Prices are in USD (Sept., 2011).

MSP430F5438A LM3S9B92 Cortex-A8 Cortex-A9

Operating Freq
Operating Power

Family Price Range

25 MHz

80 MHz

720 MHz

330 - 690 µW 333 - 524 mW 0.4 W
$41 - $46

$0.25 - $9

$1 - $8

1 GHz
1.9 W
+$50

Commitments - Key Size 1,024 bits

Avg. Running Time

19.56 s

0.82 s

51 ms

36 ms

DSA Signatures - Key Size 1,024 bits

Avg. Running Time

2.71 s

0.13 s

8 ms

6 ms

CL Signatures - Key Size 1,024 bits

Avg. Running Time

43.1 s

2.3 s

150 ms

81 ms

4.3 Impact of ECC Utilization

In this subsection, we evaluate the impact of using elliptic curve cryptography
instead of cryptography relying on large integer multiplicative groups. The code
sizes of the bnlib [24] and Miracl [27] libraries and their RAM requirements
depend on the features that are included. In our experimental setting using a
microcontroller MSP430F5438A, the code size of Miracl was 23 KB and the
code size of bnlib was 18 KB. The performance of bnlib and Miracl on non-ECC
arithmetic is comparable. In our experiments, the running times of the same
operation using either library diﬀered by less than 5% of the total computation
time of the operation. The RAM footprint for various functions is summarized
in Table 2. As we can see, given a security level, ECC cryptographic primitives
utilize RAM more eﬃciently. Similarly, Table 2 shows that given a microcon-
troller and a security level, an improvement in performance of about one order
of magnitud can be achieved by using elliptic curve primitives.

4.4 Impact of Signature Scheme Selection

Table 2 shows running times for performing a CLSign algorithm with four read-
ings. We highlight in particular the beneﬁt of using an elliptic curve based library.
If a designer uses elliptic curves, he or she can reduce a monthly batch signature
with 1,440 readings (one reading every half hour) from 15.6 hours to 2.5 hours.
If the designer assumes a diﬀerent trust level in which zero-knowledge is not re-
quired, signatures are less expensive. On an MSP430F5438A at 25 MHz, signing
a 16-byte message using regular DSA with a 1,024-bit prime p, a 160-bit prime q,
and SHA-256 takes 2.71 seconds excluding the generation of randomness, which
depends on the source. Signing a 16-byte message using ECDSA using a curve
in GF (p) for a 192-bit prime and SHA-256 takes 3.78 seconds excluding the gen-
eration of randomness. DSA signatures scale better than CL-signatures because
the only overhead for a larger message would be the cost of the hash, which for
the computations above is less than 0.01% of the computation.

5 Feasibility & Costs in Real-World Deployments

We now discuss a strategy for estimating the cost of deploying privacy preserving
smart meters according to the system variables that we discussed in Section 3.

5.1 Cost Estimation Strategy

Step 1: Determine the performance and power requirements. The ﬁrst
step is to determine the acceptable levels of general computational performance
and the power requirements of the meter. Depending on the speciﬁc application,
meter readings may need to be certiﬁed with a frequency of seconds, minutes
or hours. Also, the meter may need to operate on a battery. Thus, using an
ultra-low-power microcontroller may be the diﬀerence between replacing the

Table 2. On the left we show the running time of commitments (single reading) and
signatures (4 reading batches) on an MSP430F5438A at 25 MHz. These times are
obtained when the algorithms are running exclusively and uninterrupted. We use Miracl
for the elliptic curve versions as described in Section 3. The key sizes are in bits. On
the right we show the RAM utilization for the various algorithms we implement on an
MSP430F5438A all using the Miracl library. The measurements do not include RAM
utilization by an RTOS, a radio stack or I/O.

Commit
Commit

ECC Commit
ECC Commit

CLSign
CLSign

Algorithm Key Size Library Time
bnlib
19.9 sec
bnlib 303.0 sec
5.6 sec
miracl
8.3 sec
miracl
bnlib
41.2 sec
bnlib 313.8 sec
miracl
miracl
miracl

1,024
2,048
192
224
1,024
2,048
379
512
128

ECC CLSign
ECC CLSign
AES Key Gen

6.7 sec
35.6 sec
0.1 sec

Commit
Commit
CLSign
CLSign

Algorithm Key Size RAM
5.8 KB
10.2 KB
6.3 KB
11.3 KB
2.2 KB
2.5 KB
3.1 KB
3.6 KB
2 KB

ECC Commit
ECC Commit
ECC CLSign
ECC CLSign
AES Key Gen

1,024
2,048
1,024
2,048
192
224
379
512
128

battery every few years or every few days. For example, the performance shown
in Table 1 may make the LM3S9B92 MCU look very attractive for its ratio of
cost/performance. However, the power consumption is roughly three orders of
magnitude greater than the MSP430 MCU. Mobile processors are still far from
being ultra-low power, although their computational and storage capabilities are
increasing faster than those of the MCUs.
Step 2: Determine the code and RAM requirements. Once the perfor-
mance and power requirements are met by a family of microcontrollers, it is then
necessary for the designer to estimate the code size and RAM requirements for
the implementation of the reading certiﬁcation functions in a meter, taking into
account whether multitasking needs to be supported.

5.2 Economic Feasibility

The results in Section 4 support the hypothesis that privacy-preserving billing
protocols based on ZKP are economically feasible. We note that existing smart
meters that have the ability to be remotely updated rely on microcontrollers
similar to those we use in our implementation. Furthermore, if a microcontroller
in the MSP430 family is used, it is possible to generate commitments and CL-
signatures every 10 seconds when running at 25 MHz or every 28 seconds when
running at a more conservative 8 MHz. Thus, a remote update that enables
meters with privacy preserving functionality appears feasible.

Other metering applications may require that readings be certiﬁed at a ﬁner
granularity, for example every one or two seconds. This would require higher
computational performance and larger storage than is currently available on
low-cost ultra-low-power microcontrollers. For this reason, while obtaining cer-
tiﬁed readings at ﬁne granularities is technologically feasible, it is to this date

a feature that may incur a greater cost. Finally, in some circumstances, billing
transactions may be required to take milliseconds. In that case, only high-end
mobile processors could provide the required performance, and thus the cost of
that application would be high based on current technological trends.

While in our analysis we did not cover all manufacturers of low cost MCUs,
other leading manufacturers have similar oﬀerings. For example Atmel also has
AVR ultra low power microcontrollers, and various ARM based MCUs compara-
ble to those discussed here. Microchip has the PIC microcontroller line with 8-,
16- and 32-bit MCUs. We did not consider 8-bit microcontrollers because they
are perhaps too constrained for the kind of crypto application described here.

5.3 Best Utilization of Resources

The measurements in Section 4 show that the best security/cost ratio can be
achieved by using ECC primitives. If current MCUs are targeted, maximizing the
use of RAM can be achieved via ECC. Looking toward the future, performance
will most likely regain importance due to the increasing economic feasibility of
Ferroelectric RAM (FRAM), a kind of memory that enables high-performance
on ultra-low power microcontrollers, with a uniﬁed memory model. Texas In-
struments has started to ship MCUs with 16 KB of FRAM ($1.20 USD), and
they are already producing chips with 4 MB of FRAM [22].

6 Conclusion

Our evidence supports the notion that ZKP-based billing protocols are econom-
ically feasible. We show that evaluating the cost of a cryptographic solution
in an embedded system such as a smart meter depends ﬁrst on the family of
microcontrollers used, then on the storage and RAM requirements, and ﬁnally
on additional features such as communication and user interface. Our empirical
analyses show that with the use of Elliptic Curve Cryptography, it is possible to
reduce the RAM requirements by about 50% and obtain performance improve-
ments of one order of magnitude, thus obtaining a better performance/cost ratio.

Acknowledgments. This material is supported by a Sloan Research Fellow-
ship, the NSF under CNS-0136228, CNS-136650, CNS-1143655, CNS-0916577,
CNS-0855128 and a gift from Cisco. Any opinions, ﬁndings, and conclusions ex-
pressed in this material are those of the authors and do not necessarily reﬂect
the views of the NSF.

References

1. ARM: ARM Company Milestones (2011), http://www.arm.com/about/company-

proﬁle/milestones.php

2. Balasch, J., Rial, A., Troncoso, C., Geuens, C., Preneel, B., Verbauwhede, I.:

PrETP: Privacy-Preserving Electronic Toll Pricing. In: USENIX Security (2010)

3. Barreto, P., Galbraith, S., ´O’h´Eigeartaigh, C., Scott, M.: Eﬃcient Pairing Com-
putation on Supersingular Abelian Varieties. Designs, Codes and Cryptography
(2007)

4. Barry, R.: FreeRTOS-a free RTOS for small embedded real time systems (2006)
5. Bichsel, P., Camenisch, J., Groß, T., Shoup, V.: Anonymous Credentials on a
Standard Java Card. In: Proceedings of the 16th ACM Conference on Computer
and Communications Security (2009)

6. Camenisch, J., Lysyanskaya, A.: A Signature Scheme with Eﬃcient Protocols. In:

Security in Communication Networks (2003)

7. Camenisch, J., Lysyanskaya, A.: Signature Schemes and Anonymous Credentials

from Bilinear Maps. In: Advances in Cryptology (2004)

8. Chen, J.: MSP430 Overview and Key Applications (2008)
9. Daley, W.: Digital Signature Standard (DSS). Tech. rep., DTIC (2000)

10. Devegili, A., Scott, M., Dahab, R.: Implementing Cryptographic Pairings over

Barreto-Naehrig Curves. In: Pairing-Based Cryptography (2007)

11. Dreslinski, R., Wieckowski, M., Blaauw, D., Sylvester, D., Mudge, T.: Near-
Threshold Computing: Reclaiming Moore’s Law Through Energy Eﬃcient Inte-
grated Circuits. Proceedings of the IEEE (2010)

12. Fiat, A., Shamir, A.: How To Prove Yourself: Practical Solutions to Identiﬁcation

and Signature Problems. In: Advances in Cryptology (1987)

13. Fujisaki, E., Okamoto, T.: Statistical Zero Knowledge Protocols to Prove Modular

Polynomial Relations. In: Advances in Cryptology (1997)
14. Gas, P., Company, E.: PG & E: Full Installation Schedule
15. IAR Systems: IAR Embedded Workbench (2011), http://www.iar.com/ewarm
16. Intel: Corporate Timeline (2011), http://www.intel.com/about/companyinfo/mu-

seum/archives/timeline.htm

17. Jawurek, M., Johns, M., Kerschbaum, F.: Plug-in Privacy for Smart Metering

Billing. In: Privacy Enhancing Technologies (2011)

18. Kursawe, K., Danezis, G., Kohlweiss, M.: Privacy-friendly Aggregation for the

Smart-grid. In: Privacy Enhancing Technologies (2011)

19. Labrosse, J.: MicroC/OS-III: The Real-Time Kernel. Micriµm Press (2010)
20. Lysyanskaya, A., Rivest, R., Sahai, A., Wolf, S.: Pseudonym Systems. In: Selected

Areas in Cryptography (2000)

21. Molina-Markham, A., Shenoy, P., Fu, K., Cecchet, E., Irwin, D.: Private Memoirs of
a Smart Meter. In: Proceedings of the 2nd ACM Workshop on Embedded Sensing
Systems for Energy-Eﬃciency in Building (2010)

22. Pearson, J., Moise, T.: The Advantages of FRAM-Based Smart ICs for Next Gen-

eration Government Electronic IDs (2007)

23. Pedersen, T.: Non-Interactive and Information-Theoretic Secure Veriﬁable Secret

Sharing. In: Advances in Cryptology (1992)

24. Plumb, C., Zimmermann, P.: bnlib: Extended Precision Integer Math Library
25. Rial, A., Danezis, G.: Privacy-Preserving Smart Metering. In: Workshop on Privacy

in the Electronic Society (2011)

26. Rosenberg, B.: Handbook of Financial Cryptography and Security. Chapman &

Hall/CRC (2010)

27. Scott, M.: MIRACL Multiprecision Integer and Rational Arithmetic C Library
28. Scott, M.: Implementing Cryptographic Pairings. In: Pairing-Based Cryptography

(2007)

29. Scott, M., Costigan, N., Abdulwahab, W.: Implementing Cryptographic Pairings

on Smartcards. In: Cryptographic Hardware and Embedded Systems (2006)

30. Texas Instruments: SYS/BIOS Real-Time Operating System (2011)

