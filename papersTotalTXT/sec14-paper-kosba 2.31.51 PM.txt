TrueSeT: Faster Veriﬁable Set Computations

Ahmed E. Kosba, University of Maryland; Dimitrios Papadopoulos, Boston University; 

Charalampos Papamanthou, Mahmoud F. Sayed, and Elaine Shi, University of Maryland; 

Nikos Triandopoulos, RSA Laboratories and Boston University

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/kosba

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXTRUESET: Faster Veriﬁable Set Computations∗

Ahmed E. Kosba† §

akosba@cs.umd.edu
Mahmoud F. Sayed† §
mfayoub@cs.umd.edu

Dimitrios Papadopoulos¶

dipapado@bu.edu
Elaine Shi† §

elaine@cs.umd.edu

Charalampos Papamanthou‡ §

cpap@umd.edu

Nikos Triandopoulos(cid:27) ¶

nikolaos.triandopoulos@rsa.com

Abstract

1

Introduction

Veriﬁable computation (VC) enables thin clients to efﬁ-
ciently verify the computational results produced by a
powerful server. Although VC was initially considered to
be mainly of theoretical interest, over the last two years
impressive progress has been made on implementing VC.
Speciﬁcally, we now have open-source implementations
of VC systems that handle all classes of computations
expressed either as circuits or in the RAM model. Despite
this very encouraging progress, new enhancements in the
design and implementation of VC protocols are required
to achieve truly practical VC for real-world applications.
In this work, we show that for functions that can be ex-
pressed efﬁciently in terms of set operations (e.g., a subset
of SQL queries) VC can be enhanced to become drasti-
cally more practical: We present the design and prototype
implementation of a novel VC scheme that achieves or-
ders of magnitude speed-up in comparison with the state
of the art. Speciﬁcally, we build and evaluate TRUESET,
a system that can veriﬁably compute any polynomial-time
function expressed as a circuit consisting of “set gates”
such as union, intersection, difference and set cardinality.
Moreover, TRUESET supports hybrid circuits consisting
of both set gates and traditional arithmetic gates. There-
fore, it does not lose any of the expressiveness of previous
schemes—this also allows the user to choose the most
efﬁcient way to represent different parts of a computation.
By expressing set computations as polynomial operations
and introducing a novel Quadratic Polynomial Program
technique, our experiments show that TRUESET achieves
prover performance speed-up ranging from 30x to 150x
and up to 97% evaluation key size reduction compared to
the state-of-the-art.

∗This research was funded in part by NSF under grant numbers CNS-
1314857, CNS-1012798 and CNS-1012910 and by a Google Faculty
Research Award. The views and conclusions contained herein are those
of the authors and do not represent funding agencies.
†Computer Science Dept., University of Maryland.
‡Electrical & Computer Engineering Dept., University of Maryland.
§U. Maryland Institute for Advanced Computer Studies (UMIACS).
¶Computer Science Dept., Boston University.
(cid:26)RSA Laboratories.

Veriﬁable Computation (VC) is a cryptographic protocol
that allows a client to outsource expensive computation
tasks to a worker (e.g., a cloud server), such that the client
can verify the result of the computation in less time than
that required to perform the computation itself. Cryp-
tographic approaches for VC [5, 6, 7, 12, 13, 14, 21]
are attractive in that they require no special trusted hard-
ware or software on the server, and can ensure security
against arbitrarily malicious server behavior, including
software/hardware bugs, misconﬁgurations, malicious in-
siders, and physical attacks.

Due to its various applications such as secure cloud
computing, the research community has recently made
impressive progress on Veriﬁable Computation, both on
the theoretical and practical fronts. In particular, several
recent works [2, 3, 9, 23, 25, 26, 29] have implemented
Veriﬁable Computation for general computation tasks,
and demonstrated promising evidence of its efﬁciency.
Despite this encouraging progress, performance improve-
ment of orders of magnitude is still required (especially
on the time that the server takes to compute the proof) for
cryptographic VC to become truly practical.

Existing systems for Veriﬁable Computation are built
to accommodate any language in NP: Speciﬁcally, func-
tions/programs are represented as either circuits (Boolean
or arithmetic) or sets of constraints and cryptographic
operations are run on these representations. While such
an approach allows us to express any polynomial-time
computation, it is often not the most efﬁcient way to repre-
sent common computation tasks encountered in practice.
For example, Parno et al. [23] point out that the behavior
of their construction deteriorates abruptly for function-
alities that have “bad” arithmetic circuit representation
and Braun et al. [9] recognize that their scheme is not
quite ready for practical use, restricting their evaluations
to “smaller scales than would occur in real applications.”
In order to reduce the practical cost of Veriﬁable Com-
putation, we design and build TRUESET. TRUESET is an
efﬁcient and provably secure VC system that specializes
in handling set-centric computation tasks. It allows us to

USENIX Association  

23rd USENIX Security Symposium  765

model computation as a set circuit—a circuit consisting
of a combination of set operators (such as intersection,
union, difference and sum), instead of just arithmetic op-
erations (such as addition and multiplication in a ﬁnite
ﬁeld). For computation tasks that can be naturally ex-
pressed in terms of set operations (e.g., a subset of SQL
database queries), our experimental results suggest orders-
of-magnitude performance improvement in comparison
with existing VC systems such as Pinocchio [23]. We
now present TRUESET’s main contributions:
Expressiveness. TRUESET retains the expressiveness of
existing VC systems, in that it can support arbitrary com-
putation tasks. Fundamentally, since our set circuit can
support intersection, union, and set difference gates, the
set of logic is complete1. Additionally, in Section 4.4, we
show that TRUESET can be extended to support circuits
that have a mixture of arithmetic gates and set gates. We
achieve this by introducing a “split gate” (which, on input
a set, outputs the individual elements) and a “merge gate”
(which has the opposite function of the split gate).
Input-speciﬁc running time. One important reason why
TRUESET signiﬁcantly outperforms existing VC systems
in practice is that it achieves input-speciﬁc running time
for proof computation and key generation. Input-speciﬁc
running time means that the running time of the prover is
proportional to the size of the current input.

Achieving input-speciﬁc running time is not possible
when set operations are expressed in terms of Boolean
or arithmetic circuits, where one must account for worst-
case set sizes when building the circuit: For example, in
the case of intersection, the worst case size of the output is
the minimum size of the two sets; in the case of union, the
worst case size of the output is the sum of their sizes. Note
that this applies not only to the set that comprises the ﬁnal
outcome of the computation, but to every intermediate set
generated during the computation. As a result, existing
approaches based on Boolean or arithmetic circuits incur a
large blowup in terms of circuit size when used to express
set operations. In this sense, TRUESET also achieves
asymptotic performance gains for set-centric computation
workloads in comparison with previous approaches.

TRUESET achieves input-speciﬁc running time by en-
coding a set of cardinality c as a polynomial of degree
c (such an encoding was also used in previous works,
e.g., [18, 22]), and a set circuit as a circuit on polyno-
mials, where every wire is a polynomial, and every gate
performs polynomial addition or multiplication. As a re-
sult, per-gate computation time for the prover (including
the time for performing the computation and the time for

1Any function computable by Boolean circuits can be computed by
a set circuit: If one encodes the empty set as 0 and a ﬁxed singleton set
{s} as 1, a union expresses the OR gate, an intersection expresses the
AND gate and a set difference from {s} expresses the NOT gate.

SELECT COUNT(UNIVERSITY.id)

FROM UNIVERSITY JOIN CS

ON UNIVERSITY.id = CS.id

Figure 1: An example of a JOIN SQL query (between tables
UNIVERSITY and CS) that can be efﬁciently supported by
TRUESET. TRUESET will implement JOIN with an intersection
gate and COUNT with a cardinality gate.

producing the proof) is (quasi-)linear in the degree of the
polynomial (i.e., cardinality of the actual set), and not
proportional to the worst-case degree of the polynomial.
Finally, as in other VC systems, verifying in TRUESET
requires work proportional to the size of inputs/outputs,
but not in the running time of the computation.
Implementation and evaluation. We implemented
TRUESET and documented its efﬁciency comparing it
with a veriﬁable protocol that compiles a set circuit into
an arithmetic circuit and then uses Pinocchio [23] on
the produced circuit. In TRUESET the prover’s running
time is reduced by approximately 30x for all set sizes
of 64 elements or more. In particular, for a single in-
tersection/union gate over 2 sets of 256 elements each,
TRUESET improves the prover cost by nearly 150x. We
also show that, while other systems [23] cannot—in a
reasonable amount of time—execute over larger inputs,
TRUESET can scale to large sets, e.g., sets with cardinality
of approximately 8000 (213), efﬁciently accommodating
instances that are about 30x larger than previous systems.
Finally, TRUESET greatly reduces the evaluation key size,
a reduction that can reach 97% for some operations.
Applications. TRUESET is developed to serve various in-
formation retrieval applications that use set operations as a
building block. For example, consider an SQL query that
performs a JOIN over two tables and then computes MAX
or SUM over the result of the join operation. TRUESET
can model the join operation as an intersection and then
use the split gate to perform the maximum or the summa-
tion/cardinality operation over the output of the join—see
Figure 1. Other queries that TRUESET could model are
advanced keyword search queries containing complicated
ﬁlters that can be expressed as arbitrary combinations of
set operations (union, intersection, difference) over an
underlying data set. Finally, the computation of similarity
measurements for datasets often employs set operations.
One of the most popular measurements of this type, is the
Jaccard index [17] which is computed for two sets, as the
ratio of the cardinalities of their intersection and union, a
computation that can be easily compiled with TRUESET.
Technical highlight. Our core technical construction is
inspired by the recent quadratic span and arithmetic pro-
grams [14], which were used to implement VC for any

766  23rd USENIX Security Symposium 

USENIX Association

Boolean or arithmetic circuit. Since our internal repre-
sentation is a polynomial circuit (as mentioned earlier),
we invent quadratic polynomial programs (QPP). During
the prover’s computation, polynomials on the wires of the
circuit are evaluated at a random point s—however, this
takes place in the exponent of a bilinear group, in a way
that the server does not learn s. Evaluating the polynomial
at the point s in effect reduces the polynomial to a value—
therefore one can now think of the polynomial circuit
as a normal arithmetic circuit whose wires encode plain
values. In this way, we can apply techniques resembling
quadratic arithmetic programs. While the intuition may
be summarized as above, designing the actual algebraic
construction and formally proving its security is nonethe-
less challenging, and requires a non-trivial transformation
of quadratic arithmetic programs.

1.1 Related Work
There exists a large amount of theoretical work on VC:
Micali [21] presented a scheme that can accommodate
proofs for any language in NP. A more efﬁcient approach
is based on succinct non-interactive arguments of knowl-
edge (SNARKs) [5, 6, 7, 14]. For the case of polynomial-
time computable functions, protocols based on fully-
homomorphic encryption [12, 13] and attribute-based en-
cryption [24] have also been proposed. In general, the
above schemes employ heavy cryptographic primitives
and therefore are not very practical.

Recent works [2, 3, 9, 23, 25, 26, 29] have made im-
pressive progress toward implementations of some of
the above schemes, showing practicality for particular
functionalities. Unfortunately, the server’s cost for proof
computation remains too high to be considered for wide
deployment in real-world applications.

The problem of verifying a circuit of set operations
was ﬁrst addressed in a recent work by Canetti et al. [10].
Their proofs are of size linear to the size of the circuit,
without however requiring a preprocessing phase for each
circuit. In comparison, our proofs are of constant size,
once such a preprocessing step has been run.

Papamanthou et al. [22] presented a scheme that pro-
vides veriﬁability for a single set operation. However,
more general set operations can be accommodated by se-
quentially using their approach, since all intermediate set
outputs are necessary for veriﬁcation. This would lead to
increased communication complexity.

A related scheme appears in the work of Chung et
al. [11]. As this scheme uses Turing machines for the
underlying computation model, the prover has inherently
high complexity. Another work that combines veriﬁable
computation with outsourcing of storage is [1], where a
protocol for streaming datasets is proposed but the sup-
ported functionalities are quadratic polynomials only.

2 Deﬁnitions

In this section we provide necessary deﬁnitions and ter-
minology that will be useful in the rest of the paper.
Circuits of sets and polynomials. TRUESET uses the
same computation abstraction as the one used in the VC
scheme by Parno et al. [23]: a circuit. However, instead
of ﬁeld elements, the circuit wires now carry sets, and,
instead of arithmetic multiplication and addition gates,
our circuit has three types of gates: intersection, union
and difference. For the sake of presentation, the sets we
are considering are simple sets, though our construction
can be extended to support multisets as well. We therefore
begin by deﬁning a set circuit:

Deﬁnition 1 (Set circuit C) A set circuit C is a circuit
that has gates that implement set union, set intersection
or set difference over sets that have elements in a ﬁeld F.
A set circuit is a tool that provides a clean abstrac-
tion of the computational steps necessary to perform a
set operation. This structured representation will allow
us to naturally encode a set operation into a number of
execution conditions that are met when it is performed
correctly. We stress that it is merely a theoretical abstrac-
tion and does not affect the way in which the computation
is performed; the computing party can use its choice of
efﬁcient native libraries and architectures. In compari-
son, previous works that use arithmetic circuits to encode
more general computations, require the construction (or
simulation) and evaluation of such a circuit, an approach
that introduces an additional source of overhead.

As mentioned in the introduction, our main technique is
based on mapping any set circuit C to a circuit F of poly-
nomial operations, i.e., to a circuit that carries univariate
polynomials on its wires and has polynomial multiplica-
tion and polynomial addition gates. We now deﬁne the
polynomial circuit F:
Deﬁnition 2 (Polynomial circuit F) A polynomial cir-
cuit F in a ﬁeld F is a circuit that has gates that im-
plement univariate polynomial addition and univariate
polynomial multiplication over F. We denote with d the
number of multiplication gates of F and with N the num-
ber of input and output wires of F. The input and output
wires are indexed 1, . . . , N. The rest of the wires2 are
indexed N + 1, . . . , m.

SNARKs. TRUESET’s main building block is a primitive
called succinct non-interactive argument of knowledge
(SNARK) [14]. A SNARK allows a client to commit to

2These wires include free wires (which are inputs only to multiplica-
tion gates) and the outputs of the internal multiplication gates (whose
outputs are not outputs of the circuit). The set of these wires is denoted
with Im and has size at most 3d.

USENIX Association  

23rd USENIX Security Symposium  767

a computation circuit C and then have a prover provide
succinct cryptographic proofs that there exists an assign-
ment on the wires w (which is called witness) such that
the input-output pair x = (I,O) is valid.
As opposed to veriﬁable computation [24], a SNARK
allows a prover to specify some wires of the input I as part
of the witness w (this is useful when proving membership
in an NP language, where the prover must prove witness
existence). For this reason, SNARKs are more powerful
than VC and therefore for the rest of the paper, we will
show how to construct a SNARK for hierarchical set
operations. In the full version of our paper [20], we
show how to use the SNARK construction to provide
a VC scheme as well as a VC scheme for outsourced
sets, where the server not only performs the computation,
but also stores the sets for the client. We now give the
SNARK deﬁnition, adjusted from [14].

Deﬁnition 3 (SNARK scheme) A SNARK scheme con-
sists of three probabilistic polynomial time (PPT) algo-
rithms (KeyGen, Prove, Verify) deﬁned as follows.
1. (pk, sk) ← KeyGen(1k, C). The key generation al-
gorithm takes as input the security parameter k and
a computation circuit C; it outputs a public key pk,
and a secret key sk.

2. π ← Prove(pk, x, w): The prover algorithm takes
as input the public key pk, an input-output pair x =
(I,O), a valid witness w and it outputs a proof π.
3. {0, 1} ← Verify(sk, x, π): Given the key sk, a state-
ment x and a proof π, the veriﬁcation algorithm
outputs 0 or 1.

We say that a SNARK is publicly-veriﬁable if sk = pk. In
this case, proofs can be veriﬁed by anyone with pk. Oth-
erwise, we call it a secretly-veriﬁable SNARK, in which
case only the party with sk can verify.

There are various properties that a SNARK should
satisfy. The most important one is soundness. Namely,
no PPT adversary should be able to output a verifying
proof π for an input-output pair x = (I,O) that is not
consistent with C. All the other properties of SNARKs
are described formally in Appendix 6.2.

3 A SNARK for Polynomial Circuits

In their recent seminal work, Gennaro et al. [14] showed
how to compactly encode computations as quadratic pro-
grams, in order to derive very efﬁcient SNARKs. Specif-
ically, they show how to convert any arithmetic circuit
into a comparably-sized Quadratic Arithmetic Program
(QAP), and any Boolean circuit into a comparably-sized
Quadratic Span Program (QSP).

In this section we describe our SNARK construction
for polynomial circuits. The construction is a modiﬁca-
tion of the optimized construction for arithmetic circuits
that was presented by Parno et al. [23] (Protocol 2) and
which is based on the original work of Gennaro et al. [14].
Our extension accounts for univariate polynomials on the
wires, instead of just arithmetic values. We therefore need
to deﬁne a quadratic polynomial program:

Deﬁnition 4 (Quadratic Polynomial Program (QPP))
A QPP Q for a polynomial circuit F contains three
sets of polynomials V = {vk(x)},W = {wk(x)},Y =
{yk(x)} for k = 1, . . . , m and a target polynomial τ (x).
We say that Q computes F if: c1(z), c2(z), . . . , cN (z) is
a valid assignment of F’s inputs and outputs iff there
exist polynomials cN +1(z), . . . , cm(z) such that τ (x)
divides p(x, z) where

p(x, z) = (cid:31) m(cid:30)k=1
− (cid:31) m(cid:30)k=1

ck(z)vk(x)(cid:29)(cid:31) m(cid:30)k=1
ck(z)yk(x)(cid:29) .

ck(z)wk(x)(cid:29)

(3.1)

We deﬁne the degree of Q to equal the degree of τ (x).
The main difference of the above quadratic program with
the one presented in [23] is the fact that we introduce
another variable z in the polynomial p(x, z) representing
the program (hence we need to account for bivariate poly-
nomials, instead of univariate), which is going to account
for the polynomials on the wires of the circuit.
Constructing a QPP. We now show how to construct
a QPP Q for a polynomial circuit. The polynomials in
V,W,Y and the polynomial τ (x) are computed as fol-
lows. Let r1, r2, . . . , rd be random elements in F. First,
set τ (x) = (x− r1)(x− r2) . . . (x− rd) and compute the
polynomial vk(x) such that vk(ri) = 1 iff wire k is the
left input of multiplication gate i, otherwise vk(ri) = 0.
Similarly, wk(ri) = 1 iff wire k is the right input of mul-
tiplication gate i, otherwise wk(ri) = 0 and yk(ri) = 1
iff wire k is the output of multiplication gate i, otherwise
yk(ri) = 0. For example, consider the circuit of Figure 2
that has ﬁve inputs and one output and its wires are num-
bered as shown in the ﬁgure (gates take the index of the
their output wire). Then τ (x) = (x− r6)(x− r7). For vk
we require that vk(r6) = 0 except for v2(r6) = 1, since
the second wire is the only left input for the sixth gate,
and vk(r7) = 0 except for v1(r7) and v6(r7) which are 1,
since the ﬁrst and sixth wire contribute as left inputs to
gate 7. Right input polynomials wk are computed simi-
larly and output polynomials yk are computed such that
y6(r6) = y7(r7) = 1; all other cases are set to 0.

To see why the above QPP computes F, let us fo-
cus on a single multiplication gate g, with k1 being its

768  23rd USENIX Security Symposium 

USENIX Association

c1(z)

c2(z) c3(z)

c4(z) c5(z)

3.1

Intuition of Construction

×

+

c6(z)

+

×

c7(z)

Figure 2: A sample polynomial circuit.

output wire and k2 and k3 be its left and right input
wires respectively. Due to the divisibility requirement, it
holds p(ri, z) = 0 for i = 1, . . . , d, hence Equation 3.1
will give ((cid:31)m
k=1 ck(z)wk(rg)) =
((cid:31)m
k=1 ck(z)yk(rg)). Now, from the way the polyno-
mials vk, wk, yk were deﬁned above, most terms are 0
and what remains is ck2 (z)vk2 (rg) · ck3 (z)wk3 (rg) =
ck1 (z)yk1 (rg) or else ck2 (z) · ck3 (z) =c k1 (z), which is
the deﬁnition of a multiplication gate. More formally:

k=1 ck(z)vk(rg))((cid:31)m

Lemma 1 The above QPP Q computes F.
Proof: (⇒) Suppose c1(z), c2(z), . . . , cN (z) are correct
assignments of the input and output wires but there do
not exist polynomials cN +1(z), . . . , cm(z) such that τ (x)
divides p(x, z). Then there is at least one multiplication
gate r with left input x, right input y and output o, such
that p(r, z) (cid:27)= 0. Let p be the path of multiplication gates
that contains r starting from an input polynomial ci(z) to
an output polynomial cj(z), where i, j ≤ N. Since ci(z)
and cj(z) are correct assignments, there must exist poly-
nomials cx(z) and cy(z) such that cx(z)cy(z) =c o(z).
Since r has a single left input, a single right input and
a single output it holds vx(r) = 1 and vi(r) = 0 for all
i (cid:27)= x. Similarly, wy(r) = 1 and wi(r) = 0 for all i (cid:27)= y
and yo(r) = 1 and yi(r) = 0 for all i (cid:27)= o. Therefore
p(r, z) (cid:27)= 0 implies that for all polynomials cx(z), cy(z),
co(z), it is cx(z)cy(z) (cid:27)= co(z), a contradiction.
(⇐) Suppose τ (x) divides p(x, z). Then p(r, z) = 0
for all multiplication gates r. By the deﬁnition of vi(x),
wi(x), yi(x), the c1(z), c2(z), . . . , cm(z) are correct as-
signments on the circuit wires.

We next give an efﬁcient SNARK construction for poly-
nomial circuits based on the above QPP. Recall that a
polynomial circuit F has d multiplication gates and m
wires, the wires 1, . . . , N occupy inputs and outputs and
set Im = {N + 1, . . . , m} represents the internal wires,
where |Im| ≤ 3d. Also, we denote with ni the degree of
polynomial on wire i and we set n to be an upper bound
on the degrees of the polynomials on F’s wires.

The SNARK construction that we present works as fol-
lows. First, the key generation algorithm KeyGen pro-
duces a “commitment” to the polynomial circuit F by
outputting elements that relate to the internal set of wires
Im of the QPP Q = (V,W,Y, τ (x)) as the public key.
These elements encode bivariate polynomials in the ex-
ponent, evaluated at randomly chosen points t and s, to
accommodate for the fact that circuit F encodes opera-
tions over univariate polynomials and not just arithmetic
values (as is the case with [14]).

As was described in the previous section, for the prover
to prove that an assignment c1(z), c2(z), . . . , cN (z) of
polynomials on input/output wires is valid, it sufﬁces
to prove there exist polynomials cN +1(z), . . . , cm(z)
corresponding to assignments on the internal wires,
such that the polynomial p(x, z) from Relation 3.1
has roots r1, r2, . . . , rd.
To prove this, the prover
ﬁrst “solves” the circuit and computes the polynomials
c1(z), c2(z), . . . , cm(z) that correspond to the correct as-
signments on the wires. Then he uses these polynomials
and the public evaluation key (i.e., the circuit “commit-
ment”) to compute the following three types of terms
(which comprise the actual proof). The detailed computa-
tion of these values is described in Section 3.2.

• Extractability terms. These terms declare three
polynomials in the exponent, namely polynomials
(cid:31)m
k=N +1 ck(z)vk(x), (cid:31)m
k=N +1 ck(z)wk(x), and
(cid:31)m
k=N +1 ck(z)yk(x). These polynomials corre-
spond to the internal wires since the veriﬁer can
ﬁll in the parts for the input and output wires.

The above terms are engineered to allow extractabil-
ity using a knowledge assumption.
In particu-
lar, given these terms, there exists a polynomial-
time extractor that can, with overwhelming proba-
bility, recover the assignment cN +1(z), . . . , cm(z)
on internal wires. This proves the existence of
cN +1(z), . . . , cm(z).

• Consistency check terms. Extraction is done sep-
arately for terms related to the three polynomials
(cid:31)m
k=N +1 ck(z)vk(x), (cid:31)m
k=N +1 ck(z)wk(x), and
(cid:31)m
k=N +1 ck(z)yk(x). We therefore require a set of
consistency check terms to ensure that the extracted
cN +1(z), . . . , cm(z) polynomials are consistent for
the above V, W, and Y terms—otherwise, the same
wire can have ambiguous assignments.

• Divisibility check term. Finally, the divisibility
check term is to ensure that the above divisibil-
ity check corresponding to relation p(x, z) =

USENIX Association  

23rd USENIX Security Symposium  769

h(x, z)τ (x), holds for the polynomial

ck(z)wk(x)(cid:29)

(cid:31) m(cid:30)k=1
− (cid:31) m(cid:30)k=1

ck(z)vk(x)(cid:29)(cid:31) m(cid:30)k=1
ck(z)yk(x)(cid:29)

declared earlier by the extractability terms.

3.2 Concrete Construction
We now give the algorithms of our SNARK construction,
(following Deﬁnition 3). In comparison with the QSP
and QAP constructions [14, 23], one difﬁculty arises in
our setting when working with polynomials on wires. In
essence, to express a polynomial ck(z) on a wire in our
construction, we evaluate the polynomial at a committed
point z = t. In existing QSP and QAP constructions,
the prover knows the cleartext value on each wire when
constructing the proof. However, in our setting, the prover
does not know what t is, and hence cannot directly evalu-
ate the polynomials ck(z)’s on each wire. In fact, security
would be broken if the prover knew the value of the poly-
nomials at z = t.

To overcome this problem, we have to include more el-
ements in the evaluation key which will contain exponent
powers of the variable t (see the evaluation key below).
In this way, the prover will be able to evaluate ck(t) in
the exponent, without ever learning the value t. We now
give the algorithms:
(pk, sk) ← KeyGen(F, 1k): Let F be a polynomial cir-
cuit. Build the corresponding QPP Q = (V,W,Y, τ (x))
as above. Let e be a non-trivial bilinear map e : G×G →
GT , and let g be a generator of G. G and GT have prime
order p. Pick s, t, rv, rw, αv, αw, αy, β, γ from Zp and
set ry = rvrw and gv = grv, gw = grw and gy = gry.
The public evaluation key EKF is
1. {gtivk(s)
2. {gtiαvvk(s)
3. {gtiβ·vk(s)
4. {gtisj
The veriﬁcation key VKF consists of the values

}(i,j)∈[2n]×[d].

}(i,k)∈[n]×Im.

}(i,k)∈[n]×Im.

}(i,k)∈[n]×Im.

, gtiαwwk(s)

, gtiαyyk(s)

gtiβ·wk(s)

gtiβ·yk(s)

, gtiwk(s)

, gtiyk(s)

w

w

w

y

y

v

v

v

y

g, gαv , gαw , gαy , gγ, gβγgt(s)

y

and the set {gtivk(s)
}(i,k)∈[n]×[N ].
Note VKF and EKF are the public key pk of the SNARK.
Our SNARK is publicly veriﬁable, hence sk = pk.

, gtiwk(s)

, gtiyk(s)

w

y

v

π ← Prove(pk, x, w): The input x contains input poly-
nomials u and output polynomials y and the witness w
(which contains assignments of polynomials on the inter-
nal wires). Let ck(z) be the polynomials on the circuit’s
wires such that y = F(u, w). Let h(x, z) be the poly-
nomial such that p(x, z) = h(x, z) · τ (x). The proof is
computed as follows:

1. (Extractability terms) gvm(s,t)

v

, gwm(s,t)

, gym(s,t)

y

,

gαvvm(s,t)
v

, gαwwm(s,t)

w

, gαyym(s,t)

y

2. (Consistency check term)

gβ·vm(s,t)
v

gβ·wm(s,t)
w

gβ·ym(s,t)
y

.

w
.

3. (Divisibility check term) gh(s,t), where

(a) vm(x, z) =(cid:28)k∈Im
(b) wm(x, z) =(cid:28)k∈Im
(c) ym(x, z) = (cid:28)k∈Im
gβ·vm(s,t)
v
lic key terms {gtiβ·vk(s)
{0, 1} ← Verify(pk, x, π): Parse the proof π as
1. γv, γw, γy, κv, κw, κy.

ck(z)vk(x);
ck(z)wk(x); and
ck(z)yk(x). Note that the term
can be computed from pub-
}(i,k)∈[n]×Im.

gβ·wm(s,t)
w

gtiβ·yk(s)

gtiβ·vk(s)

gβ·ym(s,t)
y

w

y

v

2. Λ.

3. γh.

First, verify all three α terms: e(γv, gαv ) ?= e(κv, g) ∧
e(γw, gαw ) ?= e(κw, g) ∧ e(γy, gαy ) ?= e(κy, g). Then
verify the divisibility requirement:

e(λv · γv, λw · γw)/e(λy · γy, g) ?= e(γh, gτ (s)),
where λv = g(cid:31)k∈[N ] ck(t)vk(s), λw = g(cid:31)k∈[N ] ck(t)wk(s),
λy = g(cid:31)k∈[N ] ck(t)yk(s). Finally verify the β term:

e(γv · γw · γy, gβγ) ?= e(Λ, gγ).

3.3 Asymptotic Complexity and Security
In this section we analyze the asymptotic complexity of
our SNARK construction for polynomial circuits. We
also state the security of our scheme.

KeyGen: It is easy to see that the computation time of

KeyGen is O(n|Im| + nd + nN ) = O(dn).
Prove: Let T be the time required to compute the poly-
nomials ci(z) for i = 1, . . . , m and let ni be the degree
of the polynomial ci(z) for i = 1, . . . , m. The compu-
tation of each gci(z)vi(x) (similarly for gci(z)wi(x) and
gci(z)yi(x)) for i ∈ Im takes O(ni) time (speciﬁcally,
7 ·(cid:28) ni exponentiations are required to compute all the

770  23rd USENIX Security Symposium 

USENIX Association

proof), since one operation per coefﬁcient of ci(z) is re-
quired. Then multiplication of |Im| terms is required.
Therefore the total time required is

O(cid:31)T + (cid:30)i∈Im

ni + |Im|(cid:29) = O (T + dν) ,

where ν = maxi=1,...,m{ni} is the maximum degree
of the polynomials over the wires and since |Im| ≤
3d. To compute p(x, z), ﬁrst the degree d polynomials
vi(x), wi(x), yi(x) for i = 1, ..., m are parsed in time
O(dm). Then p(x, z) is computed according to Equa-
tion 1; each summation term is computed in time O(dν)
with naive bivariate polynomial multiplication and then
they are summed for total complexity of O(mdν). For
the division, note that p(x, z) has maximum degree in z
equal to 2ν and maximum degree in x equal to 2d. To
do the division, we apply “the change of variable trick”.
We set z = x2×(2d)+1 and therefore turn p(x, z) into
a polynomial of one variable x, namely the polynomial
p(x, x2×(2d)+1). Therefore the dividend now has maxi-
mum degree 2ν(4d + 1) + 2d while the divisor has still
degree d. By using FFT, we can do such division in
O(dν log(dν)) time. Therefore the total time for Prove is
O (T + dν log(dν) +mdν ).

Verify: The computation of each element gci(z)vi(x)
(resp. for gci(z)wi(x) and gci(z)yi(x)) for i = 1, . . . , N
takes O(ni) time, since one operation per coefﬁcient of
ci(z) is required. Then multiplication of N terms is re-

quired. Hence, the total time required is O((cid:28)i∈[N ] ni),

proportional to the size of the input and output.

We now have the following result. The involved as-
sumptions can be found in Appendix 6.1 and we provide
its proof of security in the full version of our paper [20].

Theorem 1 (Security of the SNARK for F) Let F be
a polynomial circuit with d multiplication gates. Let n be
an upper bound on the degrees of the polynomials on the
wires of F and let q = 4d + 4. The construction above is
a SNARK under the 2(n + 1)q-PKE, the (n + 1)q-PDH
and the 2(n + 1)q-SDH assumptions.

4 Efﬁcient SNARKs for Set Circuits

In this section, we show how to use the SNARK construc-
tion for polynomial circuits from the previous section to
build a SNARK for set circuits.

We ﬁrst deﬁne a mapping from sets to polynomials (see
Deﬁnition 5– such representation was also used in prior
work, e.g., the work of Kissner and Song [18]). Then we
express the correctness of the operations between two sets
as constraints between the polynomials produced from
this mapping (e.g., see Lemma 2). For a set operation to

be correct, these constraints must be satisﬁed simultane-
ously. To capture that, we represent all these constraints
with a circuit with loops, where a wire can participate in
more than one constraint (see Figure 3).

4.1 Expressing Sets with Polynomials
We ﬁrst show how to represent sets and set operations
with polynomials and polynomial operations. This repre-
sentation is key for achieving input-speciﬁc time, since
we can represent a set with a polynomial evaluated at a
random point (regardless of its cardinality). Given a set,
we deﬁne its characteristic polynomial.

Deﬁnition 5 (Characteristic polynomial) Let A be a
set of elements {a1, a2, . . . , an} in F. We deﬁne its char-
acteristic polynomial as A(z) = (z + a1) . . . (z + an).
We now show the relations between set operations and
polynomial operations. Note that similar relations were
used by Papamanthou et al. [22] in prior work.

Lemma 2 (Intersection constraints) Let A, B and I be
three sets of elements in F. Then I = A ∩ B iff there exist
polynomials α(z), β(z), γ(z) and δ(z) such that

1. α(z)A(z) +β (z)B(z) = I(z).

2. γ(z)I(z) = A(z).

3. δ(z)I(z) = B(z).

Proof:
(⇒) If I = A ∩ B, it follows that (i) the great
common divisor of polynomials A(z) and B(z) is I(z),
therefore, by B´ezout’s identity, there exist polynomials
α(z) and β(z) such that (i) α(z)A(z) + β(z)B(z) =
I(z); (ii) I(z) divides A(z) and B(z), therefore there exist
polynomials γ(z) and δ(z) such that γ(z)I(z) =A (z)
and δ(z)I(z) = B(z).

(⇐) Let A, B and I be sets. Suppose there exist poly-
nomials α(z), β(z), γ(z) and δ(z) such that (1), (2) and
(3) are true. By replacing (2) and (3) into (1), we get that
α(z) and β(z) do not have any common factor, therefore
I(z) is the greatest common divisor of A(z) and B(z) and
therefore A ∩ B = I.
Corollary 1 (Union constraints) Let A, B and U be
three sets of elements in F. Then U = A ∪ B iff ∃ polyno-
mials i(z), α(z), β(z), γ(z) and δ(z) such that

1. α(z)A(z) +β (z)B(z) = i(z).

2. γ(z)i(z) = A(z).

3. δ(z)i(z) = B(z).

4. δ(z)A(z) = U(z).

USENIX Association  

23rd USENIX Security Symposium  771

A

B

I = A ∩ B

A(z)

B(z)

α(z)

β(z)

× ×

×

×

+

A

B

U = A U B

A(z)

α(z)

β(z)

B(z)

× ×

A

B

A(z)

α(z)

β(z)

B(z)

× ×

×

D = A − B

×

×

×

×

×

I

γ(z)

I(z)

(a)

δ(z)

U

γ(z)

+

i(z)

(b)

U(z)

δ(z)

D

γ(z)

δ(z)

D(z)

+

i(z)

(c)

Figure 3: Set circuits for intersection (a), union (b) and difference (c) expressed as polynomial circuits with loops using Lemma 2,
Corollary 1 and Corollary 2.

Corollary 2 (Difference constraints) Let A, B and D
be three sets of elements in F. Then D = A − B iff ∃
polynomials i(z), α(z), β(z), γ(z) and δ(z) such that

1. α(z)A(z) +β (z)B(z) = i(z).

2. D(z)i(z) = A(z).

3. δ(z)i(z) = B(z).

4.2 From Set to Polynomial Circuits

Polynomial circuits with loops. To compile a set circuit
into a circuit on polynomials, we need to check that the
constraints in Lemma 2 and Corollaries 1 and 2 simultane-
ously satisfy for all intersection, union, and set difference
gates respectively. Doing this in a straightforward manner
seems to require implementing a Boolean AND gate us-
ing polynomial algebra, which introduces an unnecessary
representation overhead.

We use a simple idea to avoid this issue, by introduc-
ing polynomial circuits with loops. This means that the
circuit’s wires, following the direction of evaluation, can
contain loops, as shown in Figure 3. When a circuit con-
tains loops, we require that there exist an assignment for
the wires such that every gate’s inputs and output are con-
sistent. It is not hard to see that we can build a QPP for a
polynomial circuit with loops.
From set circuits to polynomial circuits. Suppose we
have a set circuit C, as in Deﬁnition 1. We can compile C
into a polynomial circuit with loops F as follows:
1. Replace every intersection gate gI with the circuit
of Figure 3(a), which implements the constraints in
Lemma 2. Note that 6 additional wires per intersec-
tion gate are introduced during this compilation, 4
of which are free wires. Also, for each intersection
gate, 4 polynomial multiplication gates are added.
2. Replace every union gate gU of C with the circuit of
Figure 3(b), which implements the set of constraints
in Corollary 1. Note that 7 additional wires per
union gate are introduced during this compilation, 3

of which are free wires. Also, for each union gate, 5
polynomial multiplication gates are added.

3. Replace every difference gate gD of C with the cir-
cuit of Figure 3(c), which implements the set of
constraints in Corollary 2. Note that 7 additional
wires per union gate are introduced during this com-
pilation, 3 of which are free wires. Also, for each
difference gate, 5 polynomial multiplication gates
are added.

4.3 Asymptotic Complexity and Security
Let C be a set circuit with d gates (out of which d1 are
intersection gates and d2 are union and difference gates)
and N inputs and outputs. After compiling C into an
polynomial circuit with loops, we end up with a circuit F
with 4d1 + 5d2 multiplication gates since each intersec-
tion introduces 4 multiplication gates and each union or
difference introduces 5 multiplication gates.

Therefore, a SNARK for set circuits with d = d1 + d2
gates can be derived from a SNARK for polynomial cir-
cuits with 4d1 + 5d2 multiplication gates. Note that the
complexity of Prove for the SNARK for set circuits is
O(dν log2 ν log log ν) because the prover runs the ex-
tended Euclidean algorithm to compute the polynomials
on the free wires, which takes O(t log2 t log log t) time,
for t-degree polynomials as inputs.
Theorem 2 (Security of the SNARK for C) Let C be a
set circuit that has d total gates and N total inputs and
outputs. Let n be an upper bound on the cardinalities of
the sets on the wires of C and let q = 16d1 + 20d2 + 4,
where d1 is the number of intersection gates and d2 is
the number of union and difference gates (d = d1 + d2).
The construction above is a SNARK for the set circuit
C under the 2(n + 1)q-PKE, the (n + 1)q-PDH and the
2(n + 1)q-SDH assumptions.

We note here that there do exist known SNARK con-
structions for languages in NP that have excellent asymp-
totic behavior and are input-speciﬁc, e.g., the work of
Bitansky et al. [6], based on recursive proof composition.

772  23rd USENIX Security Symposium 

USENIX Association

Therefore, in theory, our SNARK asymptotics are the
same with the ones by Bitansky et al. [6] (when applied
to the case of set operations). However, the concrete over-
head of such techniques remains high; in fact, for most
functionalities it is hard to deduce the involved constants.
In comparison, with our approach, we can always deduce
an upper bound on the number of necessary operations
involved. We give a tight complexity analysis of our
approach in the full version of our paper [20].

4.4 Handling More Expressive Circuits
As discussed in the introduction, by moving from QAPs to
QPPs our scheme is not losing anything in expressiveness.
So far we explicitly discussed the design of efﬁcient set
circuits that only consist of set gates. Ideally, we want
to be able to efﬁciently accommodate “hybrid” circuits
that consist both of set and arithmetic operations in an
optimally tailored approach.

In this section we show how, by constructing a split
gate (and a merge gate) that upon input a set A outputs
its elements ai, we gain some “backwards compatibility”
with respect to QAPs. In particular, this allows us to com-
pute on the set elements themselves, e.g., performing MAX
or COUNT. Also, using techniques described by Parno et
al. [23], one can go one step below in the representation
hierarchy and represent ai’s in binary form which yields,
for example, more efﬁcient comparison operations.

Hence we produce a complete toolkit that a delegating
client can use for a general purpose computation, in a
way that allows it both to be more efﬁcient for the part
corresponding to set operations and at the same time per-
form arithmetic and bit operations optimally, choosing
different levels of abstraction for different parts of the
circuit.
Zero-degree assertion gate. Arithmetic values can be
naturally interpreted as zero-degree polynomials. Since
we want to securely accommodate both polynomials and
arithmetic values in our circuit, we need to construct
a gate that will constrain the values of some wires to
arithmetic values. For example, we need to assure that
the outputs of a split gate are indeed numbers (and not
higher degree polynomials).

Lemma 3 (Zero-degree constraints) Let p(z) be a uni-
variate polynomial in F[z]. The degree of p(z) is 0 iff ∃
polynomial q(z) in F[z] such that p(z)q(z) = 1.
Proof: (⇒) Every zero-degree polynomial q(z) ∈ F[z]
also belongs in F. Since every element in F has an inverse,
the claim follows. (⇐) Assume now that p(z)q(z) = 1.
Since polynomial 1 is of degree 0, p(z)q(z) must also
be of degree 0. By polynomial multiplication, we know
that p(z)q(z) has degree deg(p(z)) + deg(q(z)). Hence
deg(p(z)) = deg(q(z)) = 0.

A

SPLIT

A(z)

×

+

+

+

+

a

b

c d

a a-1

z

z

b b-1

×

×

c c-1

z

d d-1

×

×

z

1

Figure 4:
Implementation of a split gate for the set A =
{a, b, c, d}. The elements z and 1 on the wires are hard-coded
in the circuit during setup. All other polynomials on the wires
are computed by the prover.

This simple gate consists of a multiplication gate be-
tween polynomial p(z) and an auxiliary input q(z) com-
puted by the server and the output is set to the (hard-
coded) polynomial 1. If the input is indeed a zero-degree
polynomial, by the above Lemma, q(z) is easily com-
putable by the server (an inverse computation in F).
Split gate. A split gate, depicted in Figure 4, operates
as follows. On input a wire with value A(z), it outputs
n wires with the individual elements ai. First, each of
the wires carrying ai is connected to a degree-zero as-
sertion gate. This will make sure that these wires carry
arithmetic values. Second, each of these wires is used as
an input to an addition gate, with the other input being
the degree-one polynomial z. Then the outputs of all the
addition gates are multiplied together and the output of
the multiplication is connected to the wire carrying A(z).
Split gate with variable number of outputs.
In the
above we assumed that the split gate has a ﬁxed number
of outputs, n. However, the number of outputs can vary.
To accommodate this, we assume that n is an upper bound
on the number of outputs of a split gate. Now, for each
of the n output wires, we introduce an indicator variable
νi (picked by the prover) such that if νi = 1, this output
wire is occupied and carries an arithmetic value, other-
wise νi = 0. Then, in the split gate of Figure 4, instead of
(cid:31)n
i=1(z + ai) we compute(cid:31)n
i=1[νi(z + ai) + (1 − νi)].
Note here that an additional restriction we need to impose
is that νi ∈ {0, 1}. Fortunately this can be checked very
easily by adding one self-multiplication gate and a loop
wire for each value that enforces the condition νi · νi = νi
that clearly holds iff νi = 0 or 1.
Cardinality gate. One immediate side-effect of our con-
struction for split gates with variable number of outputs,
is that it indicates a way to construct another very impor-
tant type of gate, namely a cardinality gate. Imagine for
example a computation where the requested output is not
a set but only its cardinality (e.g., a COUNT SQL-query
or the Jaccard similarity index). A cardinality gate is im-
plemented exactly like a split gate, however it only has a

USENIX Association  

23rd USENIX Security Symposium  773

single output wire that is computed as(cid:31)i νi, using n − 1

addition gates over the νi wires.
Merge gate. Finally, the merge gate upon input n wires
carrying numerical values ai, outputs a single wire that
carries them as a set (i.e., its characteristic polynomial).
The construction is similar to that of the split gate, only
in reverse order. First input wires are tested to verify they
are of degree 0, with n zero-degree assertion gates. Then,
these wires are used as input for union gates, taken in
pairs, in an iterative manner (imagine a binary tree of
unions with n leaves and the output set at the root).

5 Evaluation

We now present the evaluation of TRUESET comparing
its performance with Pinocchio [23], which is the state-of-
the-art general VC scheme (already reducing computation
time by orders-of-magnitude when compared with pre-
vious implementations). We also considered alternative
candidates for comparison such as Pantry [9] which is
specialized for stateful computations. Pantry is theoret-
ically more efﬁcient than Pinocchio, as it can support a
RAM-based O(n)-time algorithm for computing set inter-
section (i.e., when the input sets are sorted), instead of the
circuit-based O(n log2 n) or O(n2) algorithms that Pinoc-
chio supports. However, evaluation showed that Pantry
requires considerable proof construction time, even for
simple memory-based operations (e.g., 92 seconds for a
single veriﬁable put operation in a memory of 8192 ad-
dresses), hence we chose to compare only with Pinocchio.
In our experiments, we analyze the performance of
TRUESET both for the case of a single set operation and
multiple set operations. We begin by presenting the details
of our implementation and the evaluation environment
and then we present the performance results.

Implementation

5.1
We built TRUESET by extending Pinocchio’s C++ imple-
mentation so that it can handle set circuits, with the special
set gates that we propose. However, since the original
implementation of Pinocchio used efﬁcient libraries for
pairing-based cryptography and ﬁeld manipulation that
are not available for public use (internal to Microsoft), the
ﬁrst step was to replace those libraries with available free
libraries that have similar characteristics. In particular, we
used the Number Theory Library (NTL) [27] along with
the GNU Multi-Precision (GMP) library [15] for polyno-
mial arithmetic, in addition to an efﬁcient free library for
ate-pairing over Barreto-Naehrig curves [4], in which the
underlying BN curve is y2 = x3 + 2 over a 254-bit prime
ﬁeld Fp that maintains a 126 bit-level of security. As in
Pinocchio, the size of the cryptographic proof produced

by our implementation is typically equal to 288 bytes in
all experiments regardless of the input or circuit sizes.

TRUESET’s executable receives an input ﬁle describing
a set circuit that contains one or more of the set gates
described earlier. The executable compiles the circuit
to a QPP in two stages. In the ﬁrst stage, the set gates
are transformed into their equivalent representation using
polynomial multiplication and addition gates, as in Fig-
ures 3 and 4, and then the QPP is formed directly in the
second stage by generating the roots, and calculating the
V , W and Y polynomials.

Optimizations. For a fair comparison, we employ the
same optimizations used for reducing the exponentiation
overhead in Pinocchio’s implementation. Concerning
polynomial arithmetic, Pinocchio’s implementation uses
an FFT approach to reduce the polynomial multiplication
costs. In our implementation, we use the NTL library,
which already provides an efﬁcient solution for polyno-
mial arithmetic based on FFT [28].

In addition to the above, the following optimizations
were found to be very useful when the number of set gates
is high, or when the set split gate is being used.
1) For key generation, we reduce the generated key size
by considering the maximum polynomial degree that can
appear on each wire, instead of assuming a global upper
bound on the polynomial degree for all wires (as described
in previous sections). This can be calculated by assuming
a maximum cardinality of the sets on the input wires, and
then iterating over the circuit wires to set the maximum
degree per wire in the worst case, e.g. the sum of the
worst case cardinalities of the input sets for the output of
a union gate, and the smaller for intersections.
2) The NTL library does not provide direct support for bi-
variate polynomial operations, needed to calculate h(x, z)
through division of p(x, z) by τ (x). Hence, instead of
doing a naive O(n2) polynomial division, we apply the
change-of-variable trick discussed in Section 3.3 to trans-
form bivariate polynomials into univariate ones that can
be handled efﬁciently with NTL FFT operations.
3) Finally, calculation of the coefﬁcients of the charac-
teristic polynomial corresponding to the output is done
by the prover and not by the veriﬁer. The veriﬁer then
veriﬁes that the set elements of the output (i.e., the roots
of the characteristic polynomials) match the polynomial
(expressed in coefﬁcients) returned by the server. This can
be efﬁciently done through a randomized check—see al-
gorithm certify() from [22]. We specify that this slightly
increases the communication bandwidth (the server effec-
tively sends the output set twice, in two different encod-
ings) but we consider this an acceptable overhead (This
can be avoided by having the client perform the interpola-
tion himself, increasing the veriﬁcation time). It can also
be noted that the input polynomial coefﬁcients computa-

774  23rd USENIX Security Symposium 

USENIX Association

tion can be outsourced similarly to the server side, if the
client does not have them computed already.

5.2 Experiments Setup
We now provide a comparison between TRUESET’s ap-
proach and Pinocchio’s approach based for set operations.
For a fair comparison, we considered two different ways
to construct the arithmetic circuits used by Pinocchio to
verify the set operations:

• Pairwise comparison-based, which is the naive ap-
proach for performing set operations. This requires
O(n2) equality comparisons.

• Sorting network-based, in which the input sets are
merged and sorted ﬁrst using and odd-even merge-
sort network [19]. Then a check for duplicate con-
secutive elements is applied to include/remove re-
peated elements, according to the query being exe-
cuted. This requires O(n log2 n) comparator gates,
and O(n) equality gates.

Although the second approach is asymptotically more
efﬁcient, when translated to Pinocchio’s circuits it results
in numerous multiplication gates. This is due to the k-bits
split gates needed to perform comparison operations, re-
sulting into great overhead in the key generation and proof
computation stages. For a k-bit possible input value, this
split gate needs k multiplication constraints to constrain
each bit wire to be either 0 or 1. (It should be noted that
these gates translate a wire into its bit-level representation
and they should not be confused with the split gates we
introduce in this paper, which output the elements of a set
as separate arithmetical values). On the other hand, the
pairwise approach uses zero-equality gates to check for
equality of elements. Each equality gate translates into
only two multiplication gates, requiring only two roots.
For fairness purposes, different Pinocchio circuits were
produced for each different input set cardinality we exper-
iment with, as each wire in Pinocchio’s circuits represents
a single element. On the other hand, TRUESET can use
the same circuit for different input cardinalities.

We consider two Pinocchio circuit implementations:
• MS Pinocchio: This is the executable built using

efﬁcient Microsoft internal libraries.

• NTL-ZM Pinocchio: This is a Pinocchio version
built using exactly the same free libraries we used
for our TRUESET implementation. This will help
ensure having a fair comparison.

The experiments were conducted on a Lenovo IdeaPad
Y580 Laptop. The executable used a single core of a
2.3 GHz Intel Core i7 with 8 GB of RAM. For the input

sets, disjoint sets containing elements in F were assumed.
For running time statistics, ten runs were collected for
each data point, and the 95% conﬁdence interval was
calculated. Due to the scale of the ﬁgures, the conﬁdence
interval of the execution times (i.e., error bars) was too
low to be visualized.

5.3 Single-Gate Circuit
In this subsection, we compare TRUESET and Pinocchio’s
protocols based on the veriﬁcation of a single union op-
eration that accepts two input sets of equal cardinalities.
We study both the time overhead and the key sizes with
respect to different input set cardinalities. Note that, ex-
periments for higher input cardinalities in Pinocchio’s
case incur great memory overhead due to the large circuit
size, therefore we were unable to even perform Pinoc-
chio’s for large input sizes.

Figure 5 shows the comparison between TRUESET’s
approach and Pinocchio’s pairwise and sorting network
approaches, versus the cardinality of each input set. The
results show clearly that TRUESET outperforms both ap-
proaches in the key generation and proof computation
stages by orders of magnitude, while maintaining the
same veriﬁcation time. Speciﬁcally, TRUESET outper-
forms Pinocchio in the prover’s running time by 150x
when the input set cardinality is 28. This saving hap-
pens in both polynomial computations and exponentia-
tion operations, as shown in Figure 5 (c). We also note
that Pinocchio’s pairwise comparison approach outper-
forms the sorting network approach due to the expensive
split gates needed for comparisons in the sorting-network
circuits, as discussed above, which results into a large
constant affecting the performance at small cardinalities.
Considering evaluation and veriﬁcation key sizes, Fig-
ure 5 also shows a comparison between TRUESET and
Pinocchio under both the pairwise and sorting networks
approaches. The ﬁgures demonstrate that TRUESET
yields much smaller evaluation keys due to the more com-
pact wire representation it employs (a single wire for a
set as opposed to a wire per element), e.g., at an input set
cardinality of 28, the saving is about 98%. It can also be
noticed that the keys generated in Pinocchio using sort-
ing networks are much larger than the ones generated in
pairwise circuits, due to the use of the split gates. On the
other hand, TRUESET and Pinocchio almost maintain the
same veriﬁcation key sizes, as the veriﬁcation key mainly
depends on the number of input elements in addition to
the number of output elements in the worst case. (The
veriﬁcation key in TRUESET is negligibly more than the
veriﬁcation key of Pinocchio, due to an additional value
that is needed to be veriﬁed per each input or output set.
This is because an n-element set is represented by an
n-degree polynomial which requires n + 1 coefﬁcients.)

USENIX Association  

23rd USENIX Security Symposium  775

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
r
e
n
e
G
y
e
K

 

60

50

40

30

20

10

0

TrueSet
NTL-ZM Pinocchio (pairwise)
NTL-ZM Pinocchio (sorting network)
MS Pinocchio (pairwise)
MS Pinocchio (sorting network)

1.5

1

0.5

0

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

Input Set Cardinality

2²

2³

2⁴

2⁵

)
c
e
s
(
 
e
m
T
 
f
o
o
r
P

i

200

150

100

50

0

TrueSet
NTL-ZM Pinocchio (pairwise)
NTL-ZM Pinocchio (sorting network)
MS Pinocchio (pairwise)
MS Pinocchio (sorting network)

3

2

1

0

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

Input Set Cardinality

2²

2³

2⁴

2⁵

(a) Key Generation

(b) Proof Computation

)
c
e
s
(
 
e
m
T

i

120

100

80

60

40

20

0

Poly. Operations - Trueset

Exponentiation - Trueset

Poly. Operations - Pinocchio

Exponentiation - Pinocchio

0.4

0.2

0

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

2²

2³

2⁴

2⁵

Input Set Cardinality

(c) Proof Computation (Detailed)

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
c
i
f
i
r
e
V

3

2

1

0

TrueSet
NTL-ZM Pinocchio (pairwise)
NTL-ZM Pinocchio (sorting network)
MS Pinocchio (pairwise)
MS Pinocchio (sorting network)

0.15

0.1

0.05

0

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

Input Set Cardinality

(d) Veriﬁcation

2²

2³

2⁴

2⁵

2⁶

2⁷

2⁸

)
B
M

(
 
e
z
i

S

 

 

y
e
K
n
o
i
t
a
u
a
v
E

l

200

150

100

50

0

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

3
2
1
0

Input Set Cardinality
(e) Evaluation Key Size

TrueSet

Pinocchio (pairwise)

Pinocchio (sorting network)

0.02

0.01

0

2²

2³

2⁴

2⁵

TrueSet

Pinocchio (pairwise)

Pinocchio (sorting network)

)
B
M

(
 
e
z
i

S

 

 

y
e
K
n
o
i
t
a
c
i
f
i
r
e
V

3

2

1

0

2²

2³

2⁴

2⁵

2² 2³ 2⁴ 2⁵ 2⁶ 2⁷ 2⁸ 2⁹ 2¹⁰ 2¹¹ 2¹² 2¹³

Input Set Cardinality

(f) Veriﬁcation Key Size

Figure 5: Comparison between TRUESET and Pinocchio for the case of a single union gate. In the horizontal axis, we show the
cardinality of each input set in logarithmic scale. (Note: Each time data point is the average of ten runs. The error bars were too
small to be visualized). Subﬁgures (a), (b) and (d) show the comparison in terms of the key generation, proof computation and
veriﬁcation times, while (c) shows TRUESET’s prover’s time in more detail compared to Pinocchio’s prover in the case of pairwise
comparison. Subﬁgures (e) and (f) show the compressed evaluation and veriﬁcation key sizes (The cryptographic proof for all
instances is 288 bytes).

A

B

C

D

E

F

G H

5.4 Multiple-Gate Circuit

U

U

U

U

-

∩

U

Out = ((A U B) - (C U D)) U ((E U F)∩(G U H)) 

Figure 6: The multiple-gate circuit used for evaluation.

We now compare TRUESET and Pinocchio’s performance
for a complex set circuit consisting of multiple set op-
erations, illustrated in Figure 6. The circuit takes eight
input sets of equal cardinalities, and outputs one set. We
compare both the prover’s overhead and the key sizes with
respect to different input set cardinalities, but this time
we consider only Pinocchio circuits based on pairwise
comparisons, as the sorting network approach has much
larger overhead for computation times and key sizes as
shown in the previous subsection.

Figure 7 shows a comparison between TRUESET’s
approach and Pinocchio’s approach. The results again

776  23rd USENIX Security Symposium 

USENIX Association

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
r
e
n
e
G
y
e
K

 

50

40

30

20

10

0

TrueSet
NTL-ZM Pinocchio
MS Pinocchio

10

5

0

2²

2³

2⁴

2⁵

2⁶

2⁷

2⁸

2⁹

2¹⁰

2²

2³

2⁴

Input Set Cardinality

(a) Key Generation

)
c
e
s
(
 
e
m
T
 
f
o
o
r
P

i

)
c
e
s
(
 
e
m
T
 
f
o
o
r
P

i

200

150

100

50

0

2²

2³

TrueSet
NTL-ZM Pinocchio
MS Pinocchio

15
10
5
0

2⁹ 2¹⁰

2²

2³

2⁴

2⁴

2⁵

2⁶

2⁸
Input Set Cardinality 

2⁷

(b) Proof Computation

Poly. Operations - Trueset

Exponentiation - Trueset

Poly. Operations - Pinocchio

Exponentiation - Pinocchio

6

4

2

0

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
c
i
f
i
r
e
V

1.2

1

0.8

0.6

0.4

0.2

0

2⁵

2⁶

2⁴
2⁸
Input Set Cardinality

2⁷

2⁹ 2¹⁰

2²

2³

2⁴

2²

2³

2⁵

2⁶

2⁸
2⁴
Input Set Cardinality

2⁷

TrueSet
NTL-ZM Pinocchio
MS Pinocchio

0.1

0.05

0

2⁹ 2¹⁰

2²

2³

2⁴

2⁵

2⁶

(c) Proof Computation (Detailed)

(d) Veriﬁcation

)
c
e
s
(
 
e
m
T

i

100

75

50

25

0

2²

2³

100

)
B
M

(
 
e
z
i

S

 

 

y
e
K
n
o
i
t
a
u
a
v
E

l

50

0

2²

2³

2⁴

2⁵

2⁶

2⁷

2⁸

2⁹ 2¹⁰

6
4
2
0

2²

Input Set Cardinality
(e) Evaluation Key Size

TrueSet

Pinocchio

)
B
M

(
 
e
z
i
S

 

 

y
e
K
n
o
i
t
a
c
i
f
i
r
e
V

2

1

0

2³

2⁴

2²

2³

2⁴

2⁵

2⁶

2⁷

2⁸

2⁹ 2¹⁰

Input Set Cardinality

TrueSet

Pinocchio

0.04

0.02

0

2²

2³

2⁴

2⁵

(f) Veriﬁcation Key Size

Figure 7: Comparison between TRUESET and Pinocchio in the case of the multiple-gate circuit shown in Fig. 6, assuming the
pair-wise comparison circuit for Pinocchio. In the horizontal axis, we show the cardinality of each input set in logarithmic scale.
Subﬁgures (a), (b) and (d) show the comparison in terms of the key generation, proof computation and veriﬁcation time, while (c)
shows TRUESET’s prover’s time in more detail compared to Pinocchio’s prover time. Subﬁgures (e) and (f) show the compressed
evaluation and veriﬁcation key sizes (The cryptographic proof for all instances is 288 bytes).

conﬁrm that TRUESET greatly outperforms Pinocchio’s
elapsed time for key generation and proof computation,
while maintaining the same veriﬁcation time. In partic-
ular, for input set cardinality of 26, TRUESET’s prover
has a speedup of more than 50x. In terms of key sizes,
the ﬁgure conﬁrms the observation that the evaluation key
used by TRUESET is tiny compared to that of Pinocchio,
e.g., 97% smaller when the input cardinality is 26.

5.5 Cardinality and Sum of Set Elements
Here, we evaluate TRUESET when a split gate is used
to calculate the cardinality and sum for the output set of
Figure 6. We compare that with Pinocchio’s performance
for the same functions. One important parameter that
has to be deﬁned for the split gate ﬁrst is the maximum

cardinality of the set it can support. This is needed for
translating the split gate to the appropriate number of
multiplication gates needed for veriﬁcation. For example,
a split gate added to the output of the circuit in Figure 6,
will have to account for 4n set elements in the worst case,
if n is the upper bound on the input set cardinalities.

Table 1 presents a comparison between TRUESET and
Pinocchio in terms of the elapsed times in the three stages
and the evaluation/veriﬁcation key sizes, when the input
set cardinality is 64. As the table shows, TRUESET can
provide better performance in terms of the key generation
and proof computation times (4x better proof computation
time), in addition to a much smaller public evaluation key.
It can be noted that, while there deﬁnitely exists a large
improvement over Pinocchio, it is not as large as the one

USENIX Association  

23rd USENIX Security Symposium  777

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
r
e
n
e
G
y
e
K

 

45
40
35
30
25
20
15
10
5
0

Single-gate
Multi-gate
Multi-gate with Split

0

100

200

Input Set Cardinality

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
t
u
p
m
o
C
 
f
o
o
r
P

140

120

100

80

60

40

20

0

Single-gate
Multi-gate
Multi-gate with Split

0

100

200

Input Set Cardinality

 

i

)
c
e
s
(
 
e
m
T
n
o
i
t
a
c
i
f
i
r
e
V

0.3

0.25

0.2

0.15

0.1

0.05

0

0

Single-gate
Multi-gate
Multi-gate with Split

100

200

Input Set Cardinality

Figure 8: Summary of TRUESET performance under all circuits in linear scale.

Key Generation (sec)

Proof Computation (sec)

Veriﬁcation (sec)

Evaluation Key (MB)
Veriﬁcation Key (KB)

TRUESET MS Pinocchio

13.07
32.45
0.065
12.7
49.65

43.03
174.99
0.074
72.45
48.6

NTL-ZM
Pinocchio

47.39
137.79
0.066
72.45
48.6

Table 1: Comparison between TRUESET and Pinocchio on a
circuit that computes the cardinality and the sum of the output
set in the circuit in Figure 6, at input set cardinality of 64.

exhibited for the previous single-gate and multiple-gate
circuits. Overall, we found the split gate to be costlier
than set gates since the multiplication gates introduced
by the split gate increase proportionally with the number
of the set elements it can support, whereas set gates are
“oblivious” to the number of elements.

5.6 Discussion of Results
The evaluation of TRUESET for single-gate and multiple-
gate circuits showed huge improvement for both key gen-
eration and proof computation time over Pinocchio. For
example, for the single union case with 28-element input
sets, a speed-up of 150x was obtained for the prover’s
time, while providing more than 98% saving in the eval-
uation key size. For a multiple-gate circuit comprised
of seven set gates with eight input sets, each of 26 ele-
ments, a prover speed-up of more than 50x, and key size
reduction of 97% were obtained.

As can be qualitatively inferred by our plots, these
improvements in performance allow us to accommodate
problem instances that are several times larger than what
was considered achievable by previous works. TRUESET
achieves the performance behavior that Pinocchio exhibits
for sets of a few dozen elements, for sets that scale up
to approximately 8000 elements, handling circuits with
nearly 30x larger I/O size. Figure 8 summarizes the be-
havior of TRUESET for all circuits we experimented with,
illustrating its performance for the three stages in linear
scale. In all cases, the running time increases approxi-
mately linearly in the input size. The cost increases more

abruptly when a split gate is introduced due to the added
complexity discussed above. Improving the performance
of the split gate is one possible direction for future work.
Remarks. We discuss here a few points related to the
performance of our scheme.
Performance on Arithmetic Circuits. The presented eval-
uation covered the case of set circuits only, in which
our construction outperformed arithmetic circuits veriﬁed
using Pinocchio. Our construction can support typical
arithmetic circuits as well, by assuming that the maximum
polynomial degree on each wire is 0. In this case, our con-
struction will reduce to Pinocchio’s, however due to the
bivariate polynomial operations, there will be more over-
head in accommodating arithmetic circuits. For example,
for an arithmetic circuit handling the multiplication of
two 50x50 32-bit element matrices, the prover’s time with
TRUESET increased by 10% compared to Pinocchio.
Outsourced Sets. In the above, we assumed that the client
possesses the input sets. However, it is common practice
in cloud computing, to not only delegate computations
but storage as well. In this case, the client initially out-
sources the sets to the server and then proceeds to issue
set operation queries over them. This introduces the need
for an additional mechanism to ensure the authenticity of
the set elements used by the server. The full version of
our paper [20] describes a modiﬁed protocol that handles
this case using Merkle tree proofs.
Supporting multisets. Finally, it should be noted that
the comparisons with Pinocchio above assumed proper
sets only. In a setting that accommodates multiset op-
erations (i.e., sets that allow repetition in elements), we
expect TRUESET’s performance to be much better, as it
can naturally handle multiset cases without adding any
modiﬁcations. On the other hand, Pinocchio multiset
circuits are going to become more complex due to the
added complexity of taking repetitions into account. For
example, in intersection gates, it will not be enough to
only check that two element are equal, but it will also be
necessary to make sure that the matched element was not
encountered before, introducing additional overhead.

778  23rd USENIX Security Symposium 

USENIX Association

Acknowledgments

We would like to thank David Evans and the anonymous
reviewers for their invaluable comments and feedback.

References

[1] M. Backes, D. Fiore, and R. M. Reischuk. Veriﬁable
delegation of computation on outsourced data. In
CCS, pages 863–874, 2013.

[2] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer,
and M. Virza. SNARKs for C: Verifying program
executions succinctly and in zero knowledge. In
CRYPTO (2), pages 90–108, 2013.

[3] E. Ben-Sasson, A. Chiesa, E. Tromer and M. Virza.
Succinct Non-Interactive Zero Knowledge for a
von Neumann Architecture. Cryptology ePrint
Archive, Report 2013/879, 2013.
http://
eprint.iacr.org/.

[4] J.-L. Beuchat, J. E. Gonz´alez-D´ıaz, S. Mitsunari,
E. Okamoto, F. Rodr´ıguez-Henr´ıquez, and T. Teruya.
High-speed software implementation of the optimal
ate pairing over Barreto–Naehrig curves. In Pairing,
pages 21–39. Springer, 2010.

[5] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.
From extractable collision resistance to succinct non-
interactive arguments of knowledge, and back again.
In ITCS, pages 326–349, 2012.

[6] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.
Recursive composition and bootstrapping for
SNARKS and proof-carrying data. In STOC, pages
111–120, 2013.

[7] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and
O. Paneth. Succinct non-interactive arguments via
linear interactive proofs. In TCC, pages 315–333,
2013.

[8] D. Boneh and X. Boyen. Short signatures without
random oracles and the SDH assumption in bilinear
groups. J. Cryptology, 21(2), pages 149–177, 2008.

[9] B. Braun, A. J. Feldman, Z. Ren, S. T. V. Setty, A. J.
Blumberg, and M. Walﬁsh. Verifying computations
with state. In SOSP, pages 341–357, 2013.

[10] R. Canetti, O. Paneth, D. Papadopoulos, and
N. Triandopoulos. Veriﬁable set operations over out-
sourced databases. In PKC, pages 113–130, 2014.

[11] K.-M. Chung, Y. T. Kalai, F.-H. Liu, and R. Raz.
Memory delegation. In CRYPTO, pages 151–168,
2011.

[12] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan. Im-
proved delegation of computation using fully homo-
morphic encryption. In CRYPTO, pages 483–501,
2010.

[13] R. Gennaro, C. Gentry, and B. Parno. Non-
interactive veriﬁable computing: Outsourcing com-
putation to untrusted workers. In CRYPTO, pages
465–482, 2010.

[14] R. Gennaro, C. Gentry, B. Parno, and M. Raykova.
Quadratic span programs and succinct NIZKs with-
out PCPs. In EUROCRYPT, pages 626–645, 2013.

[15] T. Granlund and the GMP development team”.
GMP: The GNU Multiple Precision Arithmetic
Library, 2006. Available at http://gmplib.
org/.

[16] J. Groth. Short pairing-based non-interactive zero-
knowledge arguments. In ASIACRYPT, pages 321–
340, 2010.

[17] P. Jaccard. Etude comparative de la distribution
ﬂorale dans une portion des Alpes et du Jura. Impr.
Corbaz, 1901.

[18] L. Kissner and D. X. Song. Privacy-preserving set

operations. In CRYPTO, pages 241–257, 2005.

[19] D. E. Knuth. The art of computer programming.

Pearson Education, 2005.

[20] A. E. Kosba, D. Papadopoulos, C. Papamanthou,
M. F. Sayed, E. Shi, and N. Triandopoulos. TRUE-
SET: Nearly practical veriﬁable set computations.
Cryptology ePrint Archive, Report 2014/160, 2014.
http://eprint.iacr.org/2014/160.

[21] S. Micali. Computationally sound proofs. SIAM J.

Comput., 30(4):1253–1298, 2000.

[22] C. Papamanthou, R. Tamassia, and N. Triandopou-
los. Optimal veriﬁcation of operations on dynamic
sets. In CRYPTO, pages 91–110, 2011.

[23] B. Parno, J. Howell, C. Gentry, and M. Raykova.
Pinocchio: Nearly practical veriﬁable computation.
In IEEE Symposium on Security and Privacy, pages
238–252, 2013.

[24] B. Parno, M. Raykova, and V. Vaikuntanathan. How
to delegate and verify in public: Veriﬁable computa-
tion from attribute-based encryption. In TCC, pages
422–439, 2012.

[25] S. T. V. Setty, B. Braun, V. Vu, A. J. Blumberg,
B. Parno, and M. Walﬁsh. Resolving the conﬂict
between generality and plausibility in veriﬁed com-
putation. In EuroSys, pages 71–84, 2013.

USENIX Association  

23rd USENIX Security Symposium  779

[26] S. T. V. Setty, R. McPherson, A. J. Blumberg, and
M. Walﬁsh. Making argument systems for out-
sourced computation practical (sometimes).
In
NDSS, 2012.

[27] V. Shoup. NTL: Number theory library. Available

at http://www.shoup.net/ntl/.

[28] V. Shoup. A new polynomial factorization algo-
rithm and its implementation. Journal of Symbolic
Computation, 20(4), pages 363–397, 1995.

[29] V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Wal-
ﬁsh. A hybrid architecture for interactive veriﬁable
computation. In IEEE Symposium on Security and
Privacy, pages 223–237, 2013.

6 Appendix

6.1 Computational Assumptions
Assumption 1 (q-PDH assumption [16]) The q-power
Difﬁe-Hellman (q-PDH) assumption holds for G if for
all PPT A the following probability is negligible in k:

(p, G, GT , e, g) ← G(1k); s ← Z∗p;
G ←(cid:28)g, gs, . . . , gsq
, . . . , gs2q(cid:27) ;
σ ← (p, G, GT , e, G);
y ← A(σ) : y = gsq+1

, gsq+2

Assumption 2 (q-PKE assumption [16]) The q-power
knowledge of exponent assumption holds for G if for all
PPT A there exists a non-uniform PPT extractor χA such
that the following probability is negligible in k:

(p, G, GT , e, g) ← G(1k);{α, s} ← Z∗p;
G ←(cid:23)g, gs, . . . , gsq
, gα, gαs, . . . , gαsq(cid:22) ;
σ ← (p, G, GT , e, G);
(c, ˆc; a0, a1, . . . , aq) ← (A||χA)(σ, z) :
ˆc = cα ∧ c (cid:24)= g(cid:31)q
i=0 aisi

for any auxiliary information z ∈ {0, 1}poly(k) that
is generated independently of α. Note that (y; z) ←
(A||χA)(x) signiﬁes that on input x, A outputs y, and
that χA, given the same input x and A’s random tape,
produces z.

Assumption 3 (q-SDH assumption [8]) The
q-strong
Difﬁe-Hellman (q-SDH) assumption holds for G if for all
PPT A the following probability is negligible in k:
(p, G, GT , e, g) ← G(1k);{s} ←Z ∗p;
σ ← (p, G, GT , e, G =(cid:23)g, gs, . . . , gsq(cid:22));
(y, c) ← A(σ) : y = e(g, g)

s+c .

1

Pr

 .

Pr

Pr

6.2 Succinct Non-Interactive Arguments of

Knowledge (SNARKs)
Deﬁnition 6 (SNARK) Algorithms
(KeyGen, Prove, Verify) give a succinct non-interactive
argument of knowledge (SNARK) for an NP language L
with corresponding NP relation RL if:
Completeness: For all x ∈ L with witness w ∈ RL(x),

the following probability is negligible in k:

(cid:19)

following probability is negligible in k:

Pr(cid:21)Verify(sk, x, π) = 0(cid:20)(cid:20)(cid:20)(cid:20)
(pk, sk) ← KeyGen(1k),
π ← Prove(pk, x, w)
Adaptive soundness: For any PPT algorithm A, the
Pr(cid:21) Verify(sk, x, π) = 1
(x, π) ← A(1k, pk)
Succinctness: The length of a proof is given by |π| =

∧ (x /∈ L)

(pk, sk) ← KeyGen(1k),

(cid:20)(cid:20)(cid:20)(cid:20)

poly(k)poly log(|x| + |w|).

Extractability: For any poly-size prover Prv, there ex-
ists an extractor Extract such that for any statement
x, auxiliary information µ, the following holds:

(cid:19)

Pr


Pr
Pr

(pk, sk) ← KeyGen(1k)
π ← Prv(pk, x, µ)
Verify(sk, x, π) = 1

∧

w ← Extract(pk, sk, x, π)

w /∈ RL(x)

= negl(k) .



Zero-knowledge: There exists a simulator Sim, such
that for any PPT adversary A, the following holds:

pk ← KeyGen(1k); (x, w) ← A(pk);
π ← Prove(pk, x, w) : (x, w) ∈ RL

and A(π) = 1

(cid:22)

(pk, state) ← Sim(1k); (x, w) ← A(pk);
π ← Sim(pk, x, state) : (x, w) ∈ RL

and A(π) = 1 .





We say that a SNARK is publicly veriﬁable if sk = pk.
In this case, proofs can be veriﬁed by anyone with pk.
Otherwise, we call it a secretly-veriﬁable SNARK, in
which case only the party with sk can verify.

.



,



780  23rd USENIX Security Symposium 

USENIX Association

