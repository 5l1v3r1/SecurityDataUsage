Order-Revealing Encryption: New Constructions,

Applications, and Lower Bounds∗

Kevin Lewi

Stanford University

klewi@cs.stanford.edu

David J. Wu

Stanford University

dwu4@cs.stanford.edu

ABSTRACT
In the last few years, there has been signiﬁcant interest in de-
veloping methods to search over encrypted data. In the case
of range queries, a simple solution is to encrypt the contents
of the database using an order-preserving encryption (OPE)
scheme (i.e., an encryption scheme that supports compar-
isons over encrypted values). However, Naveed et al. (CCS
2015) recently showed that OPE-encrypted databases are
extremely vulnerable to “inference attacks.”

In this work, we consider a related primitive called order-
revealing encryption (ORE), which is a generalization of
OPE that allows for stronger security. We begin by con-
structing a new ORE scheme for small message spaces which
achieves the “best-possible” notion of security for ORE. Next,
we introduce a “domain-extension” technique and apply it to
our small-message-space ORE. While our domain-extension
technique does incur a loss in security, the resulting ORE
scheme we obtain is more secure than all existing (state-
less and non-interactive) OPE and ORE schemes which are
practical. All of our constructions rely only on symmetric
primitives. As part of our analysis, we also give a tight lower
bound for OPE and show that no eﬃcient OPE scheme can
satisfy best-possible security if the message space contains
just three messages. Thus, achieving strong notions of secu-
rity for even small message spaces requires moving beyond
OPE.

Finally, we examine the properties of our new ORE scheme
and show how to use it to construct an eﬃcient range query
protocol that is robust against the inference attacks of Naveed
et al. We also give a full implementation of our new ORE
scheme, and show that not only is our scheme more secure
than existing OPE schemes, it is also faster: encrypting a
32-bit integer requires just 55 microseconds, which is more
than 65 times faster than existing OPE schemes.

∗The full version of this paper [43] with complete proofs is

available at http://eprint.iacr.org/2016/612.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978376

1.

INTRODUCTION

Today, large corporations and governments collect and
store more personal information about us than ever before.
And as high-proﬁle data breaches on companies and organi-
zations (such as Anthem [1], eBay [39], and the U.S. Voter
Database [26]) become startlingly common, it is imperative
that we develop practical means for securing our personal
data in the cloud.

One way to mitigate the damage caused by a database
breach is to encrypt the data before storing it in the cloud.
This, however, comes at the price of functionality: once data
is encrypted, it is more diﬃcult to execute searches over
the data without ﬁrst decrypting the data. As a result,
security researchers have turned to developing methods that
both protect the contents of the database, as well as support
eﬃcient operations, such as search, over the encrypted data.

Property-preserving encryption. One way to support
searching over an encrypted database is through property-
preserving encryption (PPE) [9, 48, 21]. A PPE scheme is
an encryption scheme where the ciphertexts reveal a par-
ticular property on their underlying plaintexts. Examples
include deterministic encryption, where the ciphertexts re-
veal equality between messages, and order-preserving en-
cryption (OPE) [2, 9], where the ciphertexts reveal the or-
dering of messages. Deterministic and order-preserving en-
cryption schemes have been used in CryptDB [51], and also
commercially by SkyHigh Networks, CipherCloud, Google
Encrypted BigQuery, and others. One of the main appeals
of PPE for encrypting relational databases is that they are
lightweight, and hence, can be deployed with minimal changes
to existing databases. For instance, in an OPE scheme, the
ciphertexts themselves are numeric and the order of the ci-
phertexts precisely coincides with the order of the plaintexts.
Thus, searching over a column encrypted using OPE is iden-
tical to searching over an unencrypted column.

Limitations of PPE and OPE. While PPE, and in partic-
ular, OPE, provides a practical solution for searching on en-
crypted data, these schemes also leak signiﬁcant amounts of
information about their underlying plaintexts. For instance,
Boldyreva et al. [10] showed that a single OPE ciphertext
leaks half of the most signiﬁcant bits of its underlying plain-
text!

More recently, Naveed et al. [46] described a series of in-
ference attacks on relational databases encrypted using de-
terministic and order-preserving encryption schemes. They
show that, given just a data dump of an encrypted database
along with auxiliary information from a public database, an

1167attacker can successfully recover nearly all of the underlying
plaintext values from their respective ciphertexts.

Our goals. Motivated by the limited security of existing
OPE schemes and the emerging threat of inference attacks
on databases encrypted using PPE, our goal in this work
is to construct a practical property-preserving encryption
for comparisons that achieves stronger security guarantees
compared to existing OPE schemes while at the same time
providing robustness against oﬄine inference attacks, such
as those considered by Naveed et al.

Order-revealing encryption. To address the limitations
of OPE, we rely on a closely-related, but more ﬂexible, no-
tion called order-revealing encryption (ORE) [12, 22].
In
this work, we focus exclusively on non-interactive and state-
less schemes—these are the only schemes we know of that
are deployed on a large scale. We survey the work on alter-
native solutions in Section 8.

In an OPE scheme, both the plaintext and ciphertext
spaces must be numeric and well-ordered. Moreover, the
ciphertexts themselves preserve the order of the underlying
plaintexts. While this property makes OPE suitable for per-
forming range queries on encrypted data, it also limits the
achievable security of OPE schemes. In their original work,
Boldyreva et al. [9] introduced the notion of “best-possible”
semantic security for OPE, which states that the cipher-
texts do not leak any information beyond the ordering of the
plaintexts. Unfortunately, in the same work and a follow-
up work [10], they show that any OPE scheme with best-
possible security must have ciphertexts whose length grows
exponentially in the length of the plaintexts. Popa et al. [50]
further extended this lower bound to apply to stateful, in-
teractive OPE schemes. These lower bounds rule out any
hope of constructing eﬃcient OPE schemes for large message
spaces. As a compromise, Boldyreva et al. [9] introduced a
weaker notion of security (POPF-CCA) for OPE schemes,
but it is diﬃcult to quantify the leakage of schemes which
are POPF-CCA secure.

Recently, Boneh et al. [12] introduced the notion of ORE,
which does not place any restrictions on the structure of
the ciphertext space. An ORE scheme simply requires that
there exists a publicly computable function that compares
two ciphertexts. By relaxing the constraint on the ciphertext
space, the Boneh et al. scheme is the ﬁrst (non-interactive
and stateless) scheme to achieve best-possible semantic se-
curity. However, their construction relies on multilinear
maps [14, 27, 23], and is extremely far from being practi-
cally viable. More recently, Chenette et al. [22] introduced
a new security model for ORE that explicitly models the
information leakage of an ORE scheme. They also give the
ﬁrst eﬃciently-implementable ORE scheme. However their
scheme also reveals the index of the ﬁrst bit that diﬀers be-
tween two encrypted values.
1.1 The Left/Right Framework for ORE

Before describing our main contributions, we ﬁrst high-
light the “left/right” framework for order-revealing encryp-
tion that we use in this work. Our notions are adapted from
similar deﬁnitions for multi-input functional encryption [33,
12], where the encryption function operates on diﬀerent “in-
put slots.” In a multi-input functional encryption scheme (of
which ORE is a special case), information about plaintexts
is only revealed when one has a ciphertext for every slot.

We now describe how this notion of encrypting to diﬀer-
ent input slots applies to order-revealing encryption. In a
vanilla ORE scheme, there is a single encryption algorithm
that takes a message and outputs a ciphertext. The compar-
ison algorithm then takes two ciphertexts and outputs the
comparison relation on the two underlying messages. In the
left/right framework, we modify this interface and decom-
pose the encryption function into two separate functions: a
“left” encryption function and a “right” encryption function.
Each of these encryption functions takes a message and the
secret key, and outputs either a “left” or a “right” cipher-
text, respectively. Next, instead of taking two ciphertexts,
the comparison function takes a left ciphertext and a right
ciphertext, and outputs the comparison relation between the
two underlying messages (encrypted by the left and right ci-
phertexts). We note that any ORE scheme in the left/right
framework can be converted to an ORE scheme in the usual
sense by simply having the ORE encryption function output
both the left and right ciphertexts for a given message.

This left/right notion is a strict generalization of the usual
notion of order-revealing encryption, and thus, can be used
to strengthen the security guarantees provided by an ORE
scheme. In particular, a key advantage of working in this
framework is that we can now deﬁne additional security re-
quirements on collections of left or right ciphertexts taken in
isolation. For example, in both of the ORE constructions we
introduce in this work (Sections 3 and 4), a collection of right
ciphertexts taken individually is semantically secure—that
is, no information about the underlying plaintexts (includ-
ing their order relations) is revealed given only a collection
of right ciphertexts. In Section 5, we describe precisely how
semantic security of the right ciphertexts can be leveraged to
obtain a range query protocol that is robust against oﬄine
inference attacks. We also note that the schemes presented
in this work are the ﬁrst practical ORE constructions in the
left/right framework where one side (the right ciphertexts)
achieves semantic security.

Finally, we note that the left/right framework extends nat-
urally to property-preserving encryption schemes, and thus,
opens up many new avenues of developing more secure cryp-
tographic primitives for searching on encrypted data.
1.2 Our Contributions

In this work, we describe a new ORE scheme that achieves
stronger security compared to existing practical OPE and
ORE schemes, as well as a method to leverage our new ORE
scheme to eﬃciently perform range queries while providing
robustness against inference attacks. We now highlight our
main contributions.

An eﬃcient small-domain ORE. We begin by giving the
ﬁrst construction of a practical, small-domain ORE scheme
with best-possible semantic security that only relies on pseu-
dorandom functions (PRFs).1 The restriction to “small” do-
mains is due to the fact that the ciphertext length in our
scheme grows linearly in the size of the plaintext space.
All existing constructions of ORE that achieve best-possible
security in the small-domain setting rely on pairings [42],
general-purpose functional encryption [3, 16], or multilinear
maps [12], and thus, are not yet practical. Our particular

1We prove security in the random oracle model, but it is possible
to replace the random oracle with a PRF to show security under
a slightly weaker indistinguishability-based notion of security.

1168construction is inspired by the “brute-force” construction of
functional encryption by Boneh et al. [13, §4.1]. They show
that functional encryption with respect to a “small” (i.e.,
polynomially-sized) class of functions can be constructed us-
ing only symmetric primitives. We adapt these methods to
show how best-possible ORE (and more generally, functional
encryption) can be eﬃciently constructed from symmetric
primitives when the message space is small. Our construc-
tion is described in Section 3.

Domain extension for ORE. Of course, a small-domain
ORE by itself is not very useful for range queries. Our sec-
ond contribution is a recasting of the Chenette et al. [22]
ORE construction as a general technique of constructing a
large-domain ORE from a small-domain ORE. The trans-
formation is not perfect and incurs some leakage. Applying
this domain-extension technique to our new small-domain
ORE, we obtain an ORE scheme whose leakage proﬁle is
signiﬁcantly better than that of the Chenette et al. con-
struction. In particular, our new ORE scheme operates on
blocks (where a block is a sequence of bits) and the addi-
tional leakage in our scheme is the position of the ﬁrst block
in which two messages diﬀer. For instance, if blocks are byte-
sized (8 bits), then our ORE scheme only reveals the index
of the ﬁrst byte that diﬀers between the two messages (and
nothing more). In contrast, the Chenette et al. construction
always reveals the index of the ﬁrst bit that diﬀers.2 Thus,
our new ORE construction provides signiﬁcantly stronger
security, at the cost of somewhat longer ciphertexts.

Encrypted range queries. While our new ORE scheme
can almost3 be used as a drop-in replacement for OPE to
enable searching over an encrypted database, the scheme
remains susceptible to an oﬄine inference attack. To carry
out their inference attacks, Naveed et al. [46] rely on the fact
that OPE-encrypted ciphertexts enable equality tests and
comparisons (by design). In our setting, we take advantage
of the special structure of the ciphertexts in our ORE scheme
to obtain a way of supporting range queries on encrypted
data while protecting against oﬄine inference attacks.

Our range query protocol critically relies on the fact that
our ORE scheme is a left/right ORE scheme (Section 1.1).
More precisely, a ciphertext ct in our ORE scheme natu-
rally decomposes into a left component ctL and a right com-
ponent ctR. To compare two ciphertexts, the comparison
function only requires the left component of one cipher-
text and the right component of the other. More impor-
tantly, the right components have the property that they
are semantically-secure encryptions of their messages. To
build an encrypted database system with robustness against
range queries, the database server only stores the “right”
ciphertexts (in sorted order). To perform a range query,
the client provides the “left” ciphertexts corresponding to
its range. The server can respond to the range query as
usual since comparisons are possible between left and right
ciphertexts. Robustness against oﬄine inference attacks is
ensured since the database dump only contains the right ci-
phertexts stored on the server, which are semantically-secure

2While Chenette et al. also describe a multi-bit generalization
of their scheme, the generalized version leaks more information,
namely the diﬀerence of the values in the ﬁrst diﬀering block. In
our construction, only the index and nothing else is revealed.
3We say “almost,” since using ORE in place of OPE would require
writing a custom comparator for database elements.

encryptions of their underlying messages. We describe our
method in greater detail in Section 5.

New lower bounds for OPE. The core building block
in our new ORE construction is a small-domain ORE with
best-possible security. This raises the natural question of
whether we could construct a small-domain OPE that also
achieves best-possible security. Previously, Boldyreva et al. [9,
10] and Popa et al. [50] gave lower bounds that ruled out
schemes where the ciphertext space is subexponential in the
size of the plaintext space. But when the plaintext has size
poly(λ) for a security parameter λ, there could conceivably
exist an eﬃcient OPE scheme with best-possible security.
In this work, we show that this is in fact impossible. Us-
ing a very diﬀerent set of techniques compared to [9, 10,
50], we show (Section 6) that no eﬃcient (stateless and
non-interactive) OPE scheme can satisfy best-possible secu-
rity, even when the message space contains only 3 elements!
Thus, to achieve strong security even in the small-domain
setting, it is necessary to consider relaxations of OPE, such
as ORE.

Experimental evaluation. Finally, we implement and
compare our new ORE scheme to the ORE scheme by Ch-
enette et al. [22] and the OPE scheme by Boldyreva et al. [9].
For typical parameters, our new ORE scheme is over 65
times faster than the Boldyreva et al.
scheme, but has
longer ciphertexts. For example, when working with byte-
size blocks, encrypting a 32-bit integer requires just 55 µs
and produces a ciphertext that is 224 bytes. Typically, range
queries are not performed over extremely long ﬁelds, so the
extra space overhead of our scheme is not unreasonable.
Given the superior security conferred by our scheme (in both
the online and oﬄine settings), and faster throughputs, our
ORE scheme is a very compelling replacement for existing
OPE schemes.

Applying ORE. To conclude, we make a cautionary note
that because of the leakage associated with any ORE scheme,
the primitive is not always suitable for applications that de-
mand a high level of security. Our hope, however, is that
by giving precise, concrete characterization of the leakage
proﬁle of our construction (in both the online and oﬄine
settings when used to support encrypted database queries),
practitioners are able to make better-informed decisions on
the suitability of our construction for a speciﬁc application.

2. PRELIMINARIES
For n ∈ N, we write [n] to denote the set of integers
{1, . . . , n}.
If P is a predicate on x, we write 1(P(x)) to
denote the indicator function for P: that is, 1(P(x)) = 1 if
and only if P(x) = 1, and 0 otherwise. For a distribution D,
we write x ← D to denote a draw from D. For a ﬁnite set
r←− S to denote a uniformly random draw from
S, we write x
S. In this work, we write λ to denote a security parameter.
We say a function f (λ) is negligible in λ if f = o(1/λc) for
all c ∈ N. We write negl(λ) to denote a negligible function
in λ and poly(λ) to denote a polynomial in λ. We say that
an event occurs with negligible probability if the probability
of the event occurring is negl(λ). For two bit strings x, y,
we write x(cid:107)y to denote the concatenation of x and y.
We also review the standard deﬁnition of pseudorandom
functions (PRFs) [31]. A function F : K×X → Y is a secure
PRF if no eﬃcient adversary can distinguish (except perhaps

1169with negligible probability) the outputs (on arbitrary points
chosen adaptively by the adversary) of F (k,·) for a randomly
r←− K from that of a truly random function f (·)
chosen k
from X to Y. Similarly, a function F : K × X → X is a
secure pseudorandom permutation (PRP) if for all k ∈ K,
F (k,·) is a permutation on X and no eﬃcient adversary can
distinguish the outputs of F (k,·) where k
r←− K from the
outputs of π(·) where π is a random permutation on X .
2.1 Order-Revealing Encryption

An order-revealing encryption (ORE) scheme [12, 22] is
a tuple of three algorithms Π = (ORE.Setup, ORE.Encrypt,
ORE.Compare) deﬁned over a well-ordered domain D with
the following properties:
• ORE.Setup(1λ) → sk: On input a security parameter λ,
the setup algorithm outputs a secret key sk.
• ORE.Encrypt(sk, m) → ct: On input a secret key sk and
a message m ∈ D, the encryption algorithm outputs a
ciphertext ct.
• ORE.Compare(ct1, ct2) → b: On input two ciphertexts
ct1, ct2, the compare algorithm outputs a bit b ∈ {0, 1}.

Correctness. We say an ORE scheme over a well-ordered
domain D is correct if for sk ← ORE.Setup(1λ) and all mes-
sages m1, m2 ∈ D,
Pr[ORE.Compare(ct1, ct2) = 1(m1 < m2)] = 1 − negl(λ).
(ORE Decryption). Our above schema
Remark 2.1
for ORE does not include a decryption function, but as noted
by Chenette et al. [22, Remark 2.3], this is without loss of
generality. In particular, we can construct a decryption algo-
rithm ORE.Decrypt using the ORE.Encrypt and ORE.Compare
algorithms (by performing a binary search).

Security. The “best-possible” notion of security for order-
revealing encryption is the notion of indistinguishability un-
der an ordered chosen plaintext attack (IND-OCPA) intro-
duced by Boldyreva et al. [9]. The IND-OCPA notion of se-
curity is a generalization of semantic security [34], and states
that no eﬃcient adversary can distinguish between the en-
cryptions of any two sequences of messages, provided that
the ordering of the messages in the two sequences is identi-
cal. We give the formal deﬁnition in the full version [43].

Due to the apparent diﬃculty in constructing eﬃcient
schemes that satisfy IND-OCPA security, Chenette et al. [22]
introduced a weaker simulation-based notion of security for
ORE schemes that allows for some leakage beyond just the
ordering of the plaintexts. We recall their deﬁnition here.

Definition 2.2

(ORE with Leakage [22]). Let Π be
an ORE scheme—that is, Π = (ORE.Setup, ORE.Encrypt,
ORE.Compare), and let A = (A1, . . . ,Aq) be an adversary
for some q = poly(λ). Let S = (S0,S1, . . . ,Sq) be a sim-
ulator, and let L(·) be a leakage function. We deﬁne the
experiments REALoreA (λ) and SIMoreA,S,L(λ) in Figure 1. We
say that Π is a secure ORE scheme with leakage function
L(·) if for all polynomial-size adversaries A = (A1, . . . ,Aq),
there exists a polynomial-size simulator S = (S0,S1, . . . ,Sq)
such that the outputs of the two distributions REALoreA (λ)
and SIMoreA,S,L(λ) are computationally indistinguishable.

Remark 2.3

(Best-Possible Security). The strongest

notion of simulation-security is security with respect to the

leakage function that only reveals the ordering of the plain-
texts. This is the minimal leakage possible from an order-
revealing encryption scheme. In particular, we deﬁne Lcmp
as follows:
Lcmp(m1, . . . , mt) = {(i, j, cmp(mi, mj) | 1 ≤ i < j ≤ t)} ,
where cmp(mi, mj) is the comparison function that outputs −1
if mi < mj, 0 if mi = mj and 1 if mi > mj.

3. ORE FOR SMALL DOMAINS

The order-revealing encryption in [22] reveals a signiﬁcant
amount of information, namely, the index of the ﬁrst bit
position that diﬀers between two encrypted plaintexts. In
this work, we show how to construct an ORE scheme that
only leaks the ﬁrst block that diﬀers, where a block is a
collection of one or more bits. For instance, we can construct
an ORE scheme that only reveals the ﬁrst byte that diﬀers
between two encrypted plaintexts, and nothing more.

The starting point for our construction is a “small-domain”
ORE scheme with best-possible simulation security. The
limitation is that the length of the ciphertexts in our ORE
scheme grows linearly with the size of the message space,
hence the restriction to small (polynomially-sized) domains.
We show in Section 4 how to extend our small-domain ORE
to obtain an order-revealing encryption scheme over large
domains (i.e., exponentially-sized) that leaks strictly less in-
formation compared to the scheme by Chenette et al. [22].
As described in Section 1.1, we give our ORE construc-
tion in the left/right framework where we decompose the
ORE.Encrypt function into two functions: ORE.EncryptL and
ORE.EncryptR. We refer to them as the “left encryption” and
“right encryption” functions, respectively. Our particular
construction has the property that only “left ciphertexts” can
be compared with “right ciphertexts.” Note that this is with-
out loss of generality and we can recover the usual notion of
ORE by simply deﬁning the output of ORE.Encrypt(sk, m)
to be the tuple (ORE.EncryptL(sk, m), ORE.EncryptR(sk, m)).

3.1 Small-Domain ORE Construction

We begin with a high-level overview of our construction.
Our scheme is deﬁned with respect to a plaintext space
[N ] where N = poly(λ). First, we associate each element
x ∈ [N ] in the domain with an encryption key kx. A (right)
ciphertext for a value y ∈ [N ] consists of N encryptions of
the comparison output cmp(x, y) between y and every el-
ement x ∈ [N ] in the domain, where the value cmp(x, y)
is encrypted under kx. The left encryption of a value x is
simply the encryption key kx. Given kx and an encryp-
tion of cmp(x, y) under kx, the evaluator can decrypt and
learn the comparison bit cmp(x, y). The values of the other
comparison bits are hidden by semantic security of the en-
cryption scheme. Note, however, that we still need a way
for the evaluator to determine which of the N ciphertexts is
encrypted under kx without learning the value of x. To en-
sure this, we sample a random permutation π on the domain
[N ] during setup. The components in the right ciphertexts
are then permuted according to π and the left encryption
of x includes the permuted position π(x). Given π(x), the
evaluator learns which component in the right ciphertext to
decrypt, but learns nothing about x. Finally, to show sim-

1170REALoreA (λ):

1. sk ← ORE.Setup(1λ)
2. (m1, stA) ← A1(1λ)
3. c1 ← ORE.Encrypt(sk, m1)
4. for 2 ≤ i ≤ q:

(a) (mi, stA) ← Ai(stA, c1, . . . , ci−1)
(b) ci ← ORE.Encrypt(sk, mi)

SIMoreA,S,L(λ):

1. stS ← S0(1λ)
2. (m1, stA) ← A1(1λ)
3. (c1, stS ) ← S1(stS ,L(m1))
4. for 2 ≤ i ≤ q:

(a) (mi, stA) ← Ai(stA, c1, . . . , ci−1)
(b) (ci, stS ) ← Si(stS ,L(m1, . . . , mi))

5. output (c1, . . . , cq) and stA

5. output (c1, . . . , cq) and stA

Figure 1: Real and ideal experiments for ORE with leakage (Deﬁnition 2.2).

ulation security, we require a “non-committing” encryption
scheme, and for this, we rely on a random oracle [6].4

Construction. Let [N ] be the message space. Let F :
{0, 1}λ×{0, 1}λ → {0, 1}λ be a secure PRF and H : {0, 1}λ×
{0, 1}λ → Z3 be a hash function (modeled as a random ora-
cle in the security proof). Let cmp be the comparison func-
tion from Remark 2.3. Our ORE scheme Π(s)
ore is deﬁned as
follows:
• ORE.Setup(1λ). The setup algorithm samples a PRF key
r←− {0, 1}λ for F , and a uniformly random permutation
• ORE.EncryptL(sk, x). Write sk as (k, π). The left en-
cryption algorithm computes and returns the tuple ctL =
(F (k, π(x)), π(x)).
• ORE.EncryptR(sk, y). Write sk as (k, π). First, the right
r←− {0, 1}λ.

k
π : [N ] → [N ]. The secret key sk is the pair (k, π).

encryption algorithm samples a random nonce r
Then, for each i ∈ [N ], it computes the value

vi = cmp(π

−1(i), y) + H(F (k, i), r)

(mod 3).

Finally, it outputs the ciphertext ctR = (r, v1, v2 . . . , vN ).
• ORE.Compare(ctL, ctR). The compare algorithm ﬁrst parses

(cid:48)

ctL = (k

, h) and ctR = (r, v1, v2, . . . , vN ),
and then outputs the result vh − H(k(cid:48), r) (mod 3).

(cid:48)

, ct(y)

Correctness. Let sk = (k, π) ← ORE.Setup(1λ), and take
any x, y ∈ [N ]. Let ct(x)
L = (k(cid:48), h) ← ORE.EncryptL(sk, x)
R = (r, v1, . . . , vN ) ← ORE.EncryptR(sk, y), Then,
and and ct(y)
setting z = ORE.Compare(ct(x)
z = vh − H(k
= cmp(π
= cmp(π
= cmp(x, y) ∈ Z3,
Note that cmp(x, y) provides the same amount of informa-
tion as 1(x < y) and 1(y < x), so correctness follows.

−1(h), y) + H(F (k, h), r) − H(k
−1(π(x)), y) + H(F (k, π(x)), r) − H(F (k, π(x)), r)

R ), we have

, r)

, r)

(cid:48)

L

Space usage. Before we give our formal security analy-
sis, we ﬁrst characterize the length of the ciphertexts in our
ORE scheme for a message space of size N . The left cipher-
texts ctL in our scheme consists of a PRF key and an index,
which are λ + (cid:100)log N(cid:101) bits long. The right ciphertexts ctR
consists of a nonce, together with N elements in Z3, which
4We believe we can replace the random oracle with a PRF if we
aim to prove an indistinguishability notion of security for our
construction. For simplicity of presentation in this paper, we
work with a simulation-based deﬁnition and prove security in
the random oracle model.

can be represented using λ + (cid:100)N log2 3(cid:101) bits. Thus, a com-
plete ciphertext consists of 2λ + (cid:100)log N(cid:101) + (cid:100)N log2 3(cid:101) bits.
However, as we note in the following remark, it is possible to
obtain shorter ciphertexts if we allow the comparison algo-
rithm to take the full ciphertext (ctL, ctR) as opposed to only
the left half of the ﬁrst ciphertext and the right half of the
second ciphertext. Thus, when using the construction as a
pure ORE scheme, we can obtain shorter ciphertexts. When
leveraging our ORE scheme to build a range query system
(Section 5), we will exploit the fact that comparisons can be
performed given just the left component of one ciphertext
and the right component of the other.

L

Remark 3.1

(Shorter Ciphertexts). For a domain
of size N , the right ciphertexts in our ORE construction
contain N elements of Z3. Suppose instead we replaced
the comparison function cmp with a function cmp(cid:48) where
cmp(cid:48)(x, y) = 1 if x ≤ y and 0 otherwise. Then, a left encryp-
tion ct(x)
of y can be used
to compute cmp(cid:48)(x, y), or equivalently, whether x ≤ y. If
, ct(x)

the comparison algorithm takes as input ct(x) =(cid:0)ct(x)
and ct(y) =(cid:0)ct(y)

(cid:1)
(cid:1), then it can compute both cmp(cid:48)(x, y)

of x and a right encryption ct(y)

and cmp(cid:48)(y, x). This means that given ct(x) and ct(y), the
comparison algorithm can still determine if x < y, x = y, or
x > y. With this modiﬁcation, the right ciphertexts in our
scheme have length N rather than (cid:100)N log2 3(cid:101).

L , ct(y)

R

R

R

L

In the full version [43], we also show how our construction
above can be extended to support more general function-
alities (beyond just comparisons) over polynomial-sized do-
mains. We now state our main security theorem, but defer
the formal proof to the full version.

Theorem 3.2. The ORE scheme Π(s)

ore is secure with the
best-possible leakage function Lcmp from Remark 2.3 assum-
ing that F is a secure PRF and H is modeled as a random
oracle.

4. DOMAIN EXTENSION FOR ORE

Although our small-domain ORE construction from Sec-
tion 3 achieves the strongest possible notion of security for
ORE, it is limited to polynomially-sized message spaces. In
this section, we show how to construct an eﬃcient ORE
scheme for large domains which achieves provably stronger
security guarantees than all existing eﬃcient ORE construc-
tions for large domains. Our construction can be viewed as a
composition of our small-domain ORE construction together
with the ORE scheme by Chenette et al. [22].

Intuitively, we can view the techniques used in the Ch-
enette et al. construction as a domain-extension mechanism

1171for ORE. In particular, their construction can be viewed as
a general transformation that takes as input a k-bit ORE
scheme and outputs an kn-bit ORE scheme, with ciphertext
expansion that grows linearly in n and a slight reduction in
security (that degrades with n). Under this lens, the Ch-
enette et al. construction can be viewed as taking a 1-bit
ORE scheme (with best-possible security) and extending it
to an n-bit ORE scheme. In this work, we apply this general
domain-extension technique to our small-domain ORE from
Section 3, and show how we can start with a d-bit ORE and
extend it to a dn-bit ORE. By varying the parameters n
and d, we obtain a performance-security tradeoﬀ. At a high
level, our composed construction implements encryption via
several parallel (preﬁx-dependent) instances of the small-
domain ORE scheme Π(s)
ore from Section 3, one for each block
of the plaintext. Using the techniques of Chenette et al. [22],
a blinding factor is derived from the preﬁx of each block and
used to mask the Π(s)
ore ciphertexts for that block. We give
the precise leakage of our construction in Theorem 4.1.
Construction. Fix a security parameter λ ∈ N, a message
space size N > 0, and integers d, n > 0 such that dn ≥ N .
Let F : {0, 1}λ×[N ] → {0, 1}λ be a secure PRF on variable-
length inputs,5 H : {0, 1}λ×{0, 1}λ → Z3 be a hash function
(modeled as a random oracle), and π : {0, 1}λ × [d] → [d]
be a secure PRP. For a d-ary string x = x1x2 ··· xn, let
x|i = x1x2 ··· xi denote the d-ary string representing the
ﬁrst i digits of x (i.e., the length-i preﬁx of x), and let x|0
be the empty preﬁx. We deﬁne our ORE scheme Πore =
(ORE.Setup, ORE.EncryptL, ORE.EncryptR, ORE.Compare) as
follows.
• ORE.Setup(1λ). The setup algorithm samples PRF keys
r←− {0, 1}λ. The master secret key is sk = (k1, k2).
• ORE.EncryptL(sk, x). Let sk = (k1, k2). For each i ∈ [n],
the left encryption algorithm ﬁrst computes the quantity
˜x = π(F (k2, x|i−1), xi) and then sets ui = (F (k1, x|i−1(cid:107)˜x), ˜x).
It returns the ciphertext ctL = (u1, . . . , un).

• ORE.EncryptR(sk, y). Let sk = (k1, k2). First, the right en-
r←− {0, 1}λ.
cryption algorithm uniformly samples a nonce r
Then, for each i ∈ [n] and j ∈ [d], it ﬁrst sets j∗ =
π−1(F (k2, y|i−1), j), it computes

k1, k2

zi,j = cmp(j

∗

, yi) + H(F (k1, y|i−1(cid:107)j), r)

(mod 3).

It then deﬁnes the tuple vi = (zi,1, . . . , zi,d) and outputs
the ciphertext ctR = (r, v1, v2 . . . , vn).
• ORE.Compare(ctL, ctR). The compare algorithm ﬁrst parses

ctL = (u1, . . . , un) and ctR = (r, v1, v2, . . . , vn),

where for each i ∈ [n], we write ui = (k(cid:48)
i, hi) and vi =
(zi,1, . . . , zi,d). Then, let (cid:96) be the smallest index i for
which zi,hi − H(k(cid:48)
i, r) (cid:54)= 0 (mod 3). If no such (cid:96) exists,
output 0. Otherwise, output z(cid:96),h(cid:96) − H(k(cid:48)

(cid:96), r) (mod 3).

Correctness. Correctness follows similarly to that for the
small-domain ORE in Section 3. We give the full argument
in the full version [43].

Security. Before stating our security theorem, we ﬁrst spec-
ify our leakage function L(d)
blk. Each ciphertext block in our
5The Chenette et al. ORE construction also used a PRF on
variable-length inputs. We refer to their construction [22, §3]
for one possible way of constructing a PRF on variable-length
inputs from a standard PRF.

ORE scheme is essentially a ciphertext for the underlying
small-domain ORE, and the comparison operation proceeds
block-by-block.
Intuitively then, since our small-domain
ORE scheme leaks nothing except the ordering (Theorem 3.2),
the additional leakage of our new ORE scheme is the index
of the ﬁrst block that diﬀers between two ciphertexts.
In
particular, for messages x = x1x2 ··· xn and y = y1y2 ··· yn
written in base d, we deﬁne the ﬁrst diﬀering block function
diﬀ (x, y) to be the ﬁrst index i ∈ [n] such that xj = yj
ind(d)
for all j < i and xi (cid:54)= yi. If x = y, we deﬁne ind(d)
diﬀ (x, y) to
be n + 1. Then, our leakage function L(d)
blk for our extended
ORE scheme is given by
L(d)
blk(m1, . . . , mt) = {(i, j, blk(mi, mj)) | 1 ≤ i < j ≤ t} ,
where blk(mi, mj) = (cmp(mi, mj), ind(d)
diﬀ (mi, mj)). In gen-
eral, we refer to the parameter d as the arity (or base) of the
plaintext space, which grows exponentially in the length (in
bits) of the block. We now state our main security theorem.
Theorem 4.1. The ORE scheme Πore is secure with leak-
age function Lblk assuming that F is a secure PRF and H
is modeled as a random oracle.

The proof of Theorem 4.1 can be viewed as a composition
of the security proof for our underlying small-domain ORE
(Theorem 3.2) and the security proof of the Chenette et al.
scheme [22, Theorem 3.2]. We give the proof in the full
version.

Space usage. Ciphertexts in our new ORE scheme con-
sist essentially of n ciphertexts for our small-domain ORE
scheme (with domain size d). More concretely, a left cipher-
text in our new scheme consists of n(λ + (cid:100)log d(cid:101)) bits and
a right ciphertext consists of λ + n(cid:100)d log2 3(cid:101) bits. Since the
size of the plaintext space N satisﬁes N ≤ dn, ciphertext
size in our new ORE scheme grow as O((λ + d) logd N ).
Non-uniform block sizes. In practice, some bits of the
plaintext may be more sensitive than others. Leaking infor-
mation about these bits is less desirable than leaking infor-
mation about less sensitive bits. To accommodate the diﬀer-
ent sensitivities, we can use diﬀerent input bases (e.g., use
larger blocks for more sensitive bits) for the diﬀerent blocks
of the ciphertext. The leakage in the resulting scheme is
still the index of the ﬁrst (variable-sized) block that diﬀers
between two messages. Correctness is unchanged.

5. ENCRYPTED RANGE QUERIES

In this section, we formally deﬁne the properties of a
client-server protocol for range queries over an encrypted
database. In our model, a client stores an encrypted database
on the server. The client can update the database (e.g., by
adding or removing records) and issue range queries against
the database. In a range query, the client speciﬁes a numeric
interval and the server responds by returning all ciphertexts
whose underlying messages fall within that interval.

Although our deﬁnitions are stated in terms of numeric in-
tervals, our methods are broadly applicable to more general
settings—in particular, to any well-ordered domain such as
English names. For example, when the database consists of
encrypted alphanumeric strings, range queries can be used
for both exact-keyword as well as preﬁxed-based search.

Our security deﬁnitions are adapted from existing deﬁ-
nitions for searchable symmetric encryption (SSE) [24, 20].

1172We survey some of the work on SSE in Section 8. In our def-
initions we consider both the online and oﬄine settings. In
the online setting, the adversary sits on the server and sees
both the encrypted database as well as the client’s queries,
while in the oﬄine setting, the adversary just obtains a
dump of the server’s encrypted database. By showing that
in the oﬄine setting, the server’s encrypted database pro-
vides semantic security, we can argue that our new range
query scheme provides robustness against the kinds of of-
ﬂine inference attacks considered by Naveed et al. [46].

After formally deﬁning the security requirements for a
range query protocol, we give a construction based on our
ORE scheme Πore from Section 4. Our protocol not only
satisﬁes our security properties, but also has several addi-
tional appealing properties such as sublinear query time (in
the size of the database) and optimal round complexity.

Our proposed protocol is easily extensible to the multi-
client setting where many clients are interacting with the
server. Each authorized client is simply given the secret key
needed to query and update the database.

5.1 Range Query Schemes

We begin with a formal deﬁnition of a range query scheme,
followed by our notions of online and oﬄine security. We
describe a range query scheme in terms of a set of algo-
rithms, where each algorithm is a single-round protocol be-
tween the client and the server. In each protocol, the client
is always stateless, but the server is stateful—in particular,
the server’s state represents the information stored on the
server needed to eﬃciently respond to the client’s queries,
including the encrypted database itself.

Initially, the client runs a setup procedure that takes as
input a plaintext database D of values and outputs a se-
cret key sk and some token t representing the encrypted
database. The token t is given to the server, and the server
outputs some initial state st. Then, for each query (range
query, insert query, delete query), the client uses the secret
key sk to derive a token t representing its query, and sends
t to the server. This token contains a masked version of the
client’s input for the query. On input a query token t, the
server processes the query and updates its internal state. In
a range query, the server also returns a response r, which
the client uses to learn the answer to the range query.
More formally, let D ∈ [N ]M represent a (possibly empty)
database consisting of M ≥ 0 values, each in the range [N ].
A range query scheme Πrq = (RQ.Setup, RQ.Range, RQ.Insert,
RQ.Delete) consists of a tuple of algorithms deﬁned as fol-
lows:
• RQ.Setup(1λ, D) → (t, st). The setup algorithm between

the client and server proceeds as follows:
– Client(1λ, D) → (sk, t). The client, on input the secu-
rity parameter λ and database D, produces a key sk
which is kept secret, and a token t which is sent to the
server.
– Server(t) → st. The server takes as input the token t

and outputs an initial state st.

• RQ.Range(sk, q, st) → (t, st(cid:48)). The range query algorithm

between the client and server proceeds as follows:
– Client(sk, q = (x, y)) → t. The client, on input the
secret key sk and a query q for the range [x, y], produces
a token t which is sent to the server.
– Server(st, t) → (st(cid:48), r). The server takes as input its cur-

rent state st and the token t and produces an updated
state st(cid:48), along with a response r, which is sent to the
client.
– Client(sk, r) → S. The client, on input the secret key sk
and the response r from the server, obtains a subset S of
entries which represent the answer to the range query.
• RQ.Insert(sk, q, st) → (t, st(cid:48)). The insert algorithm be-

tween the client and server proceeds as follows:
– Client(sk, q = x) → t. The client, on input the secret
key sk and a query q representing an insertion of the
value x, produces a token t which is sent to the server.
– Server(st, t) → (st(cid:48), r). The server takes as input its cur-
rent state st and the token t and produces an updated
state st(cid:48).

• RQ.Delete(sk, q, st) → (t, st(cid:48)). The delete algorithm be-

tween the client and server proceeds as follows:
– Client(sk, q = x) → t. The client, on input the secret
key sk and a query q representing a deletion of the value
x, produces a token t which is sent to the server.
– Server(st, t) → (st(cid:48), r). The server takes as input its cur-
rent state st and the token t and produces an updated
state st(cid:48).

We now deﬁne the correctness and security properties of a
range query scheme. At a high level, we say that a range
query scheme is correct if for all range queries (x, y) the
client makes, it obtains the set of entries in the database
D (taking into account any insertion and deletion queries
occurring before the range query) that lie in the interval
[x, y].

Correctness. Fix a security parameter λ, positive inte-
gers x, y, N, M where x ≤ y ∈ [N ], a database D ∈ [N ]M
and a sequence of (cid:96) insertion, deletion, and range queries
q1, . . . , q(cid:96)−1. Let q(cid:96) = (x, y) be a range query. Let (st(cid:96), r) ←
Server(st(cid:96)−1, Client(sk, q(cid:96))) and S ← Client(sk, r), where st(cid:96)−1
is the server’s state after processing queries q1, . . . , q(cid:96)−1. Let
D0 = D, D1, . . . , D(cid:96) be the eﬀective database elements af-
ter each query—that is, for all i ∈ [(cid:96)], Di = Di−1 if qi
is a range query, Di = Di−1 ∪ {x} if qi−1 is an insertion
query for x, and Di = Di−1 \ {x} if qi−1 is a deletion
query for x. We say a range query scheme Πrq = (RQ.Setup,
RQ.Range, RQ.Insert, RQ.Delete) is correct if for all security
parameters λ, integers N, M, x, y, databases D ∈ [N ]M and
sequence of queries q1, . . . , q(cid:96), we have that the client’s re-
sponse S satisﬁes S = D(cid:96) ∩ [x, y].
Security. Our ﬁrst notion of security is online security,
which models the information revealed to a malicious server
in the range query protocol. Here, the adversary sees both
the contents of the server’s state (i.e., the encrypted database)
as well as the client’s queries. We give a simulation-based
deﬁnition with respect to a concrete leakage function that
operates over the plaintext values in the database and the
queries. Our deﬁnition is adapted from the standard paradigm
used to deﬁne security in searchable symmetric encryption
schemes [24, 20].

Definition 5.1

(Online Security). For all databases
D and sequences of (cid:96) queries q1, . . . , q(cid:96), deﬁne the sequence
of states st0, . . . , st(cid:96) and tokens t0, . . . , t(cid:96) where (t0, st0) ←
RQ.Setup(1λ, D), and for each i ∈ [(cid:96)], (ti, sti) is the output
of the ith query on input sk, qi, and sti−1. A range query
scheme is online secure with respect to a leakage function L

1173if for every eﬃcient adversary A, there exists a simulator S
where

(cid:12)(cid:12) Pr[A(1λ, st0, . . . ,st(cid:96), t0, . . . , t(cid:96)) = 1] −

Pr[S(1λ,L(D, q1, . . . , q(cid:96))) = 1](cid:12)(cid:12) = negl(λ).

We also deﬁne an “oﬄine” notion of security for a range
query scheme. The oﬄine setting models scenarios where
the adversary obtains a dump of the contents of the server
(i.e., the server’s state), but does not observe any queries
made by the client. Against oﬄine adversaries, we require
the much stronger property that the only thing leaked by
the encrypted database is the size of the encrypted database.
This is the best-possible leakage.

Definition 5.2

(Offline Security). For all databases

D and sequences of (cid:96) queries q1, . . . , q(cid:96), deﬁne the sequence
of states st0, . . . , st(cid:96) and tokens t0, . . . , t(cid:96) as in Deﬁnition 5.1
Let |st(cid:96)| be the bit-length of st(cid:96). A range query scheme is of-
ﬂine secure if for all eﬃcient adversaries A, there exists an
eﬃcient simulator S where

(cid:12)(cid:12)(cid:12)Pr[A(1λ, st(cid:96)) = 1] − Pr[S(1λ,|st(cid:96)|) = 1]

(cid:12)(cid:12)(cid:12) = negl(λ).

The importance of oﬄine security. Although oﬄine se-
curity is strictly weaker than online security, it captures the
real-world scenario where an attacker breaks into a server
and exﬁltrates any data the server has stored on disk. While
companies are often able to detect and protect against active
online corruption of their servers, the question remains what
happens after the fact when the attacker has also exﬁltrated
the database for oﬄine analysis. Of course, the ideal solu-
tion to this problem is an encrypted database system that
provides strong online security guarantees. However, exist-
ing systems with strong online security typically require re-
designing the database management system and implement-
ing elaborate cryptographic protocols for querying [17, 25],
or leverage heavy, less practical tools such as fully homo-
morphic encryption [29] or oblivious RAMs [32]. On the ﬂip
side, an OPE-based solution yields a scheme that does not
provide oﬄine security in our model; this is one reason why
OPE and other PPE-based encrypted database schemes are
vulnerable to inference attacks. This is true even if we use
an (interactive) OPE scheme with best-possible security; the
ability to directly compare ciphertexts is suﬃcient to carry
out the inference attacks. Thus, there is an interesting inter-
mediate ground where we build systems that achieve decent
online security, while still providing strong oﬄine security
guarantees to be robust against inference attacks.
5.2 An Efﬁcient Range Query Scheme

We now describe how to build an eﬃcient range query
scheme using our ORE construction from Section 4. At a
high level, the server’s encrypted database consists of right
ciphertexts for each value, stored in sorted order. The to-
kens t for each query consist of a left encryption of the query
value. This allows the server to use the ORE comparison
algorithm to perform binary search over the encrypted ci-
phertexts in the database. Thus, the server is able to an-
swer queries eﬃciently and maintain the database in sorted
order (during updates). To answer a range query, the server
performs binary search to ﬁnd the lower and upper bound-
aries in the encrypted database corresponding to its query

and returns all ciphertexts lying within those bounds. The
client then decrypts the ciphertexts to learn the response.

More formally, we deﬁne our range query scheme Πrq =
(RQ.Setup, RQ.Range, RQ.Insert, RQ.Delete) as follows:
• RQ.Setup(1λ, D) → (t, st). The setup algorithm between

the client and server proceeds as follows:
– Client(1λ, D) → (sk, t). The client, on input the secu-
rity parameter λ and database D, generates a secret
key sk ← ORE.Setup(1λ). Then, the client sorts the
database D, and for each sequential element xi ∈ D,
the client computes cti ← ORE.EncryptR(sk, xi), and
sends the token t = (ct1, . . . , ctM ) to the server.

– Server(t) → st. The server simply sets st = t.

• RQ.Range(sk, q, st) → (t, st(cid:48)). The range query algorithm

between the client and server proceeds as follows:
– Client(sk, q = (x, y)) → t. The client, on input the se-
cret key sk and a query representing a range query for
the range [x, y], produces the token t = (ORE.EncryptL(sk, x),
ORE.EncryptL(sk, y)) which is sent to the server.
– Server(st, t) → (st(cid:48), r). The server takes as input its
current state st = (ct1, . . . , ctM(cid:48) ) for some integer M(cid:48),
and the token t = (ctx, cty). Using ORE.Compare, it
performs a binary search to ﬁnd the ciphertexts in st
that are “at least” ctx and “at most” cty. Let r be the set
of ciphertexts lying in this interval. The server outputs
the response r and an updated state st(cid:48) = st.
– Client(sk, r) → S. The client, on input the secret key
sk and the response r = (ct1, . . . , ctm) for some integer
m, outputs the tuple S = (ORE.Decrypt(sk, ct1), . . . ,
ORE.Decrypt(sk, ctm)). (Recall from Remark 2.1 that
any ORE scheme can be augmented with a decryption
algorithm.)

• RQ.Insert(sk, q, st) → (t, st(cid:48)). The insert algorithm be-

tween the client and server proceeds as follows:
– Client(sk, q = x) → t. The client, on input the se-
cret key sk and a query representing an insertion of
the value x, produces a token t = (ORE.EncryptL(sk, x),
ORE.EncryptR(sk, x)) which is sent to the server.
– Server(st, t) → (st(cid:48), r). The server takes as input its
current state st and the token t = (ct1, ct2). Using
ORE.Compare(ct1,·), it performs a binary search over
the contents of its database st to ﬁnd the index at which
to insert the new value. The server inserts ct2 at that
position and outputs the updated database st(cid:48).
• RQ.Delete(sk, q, st) → (t, st(cid:48)). The delete algorithm be-

tween the client and server proceeds as follows:
– Client(sk, q = x) → t. The client, on input the secret
key sk and a query representing a deletion of the value x,
produces a token t = (ORE.EncryptL(sk, x), ORE.EncryptR(
sk, x)) which is sent to the server.

– Server(st, t) → (st(cid:48), r). The server takes as input its
current state st and the token t = (ct1, ct2). Using
ORE.Compare(ct1,·), it performs a binary search over
the contents of its database st to ﬁnd the indices of the
elements in st equal to ct1. It removes the entries at the
matching indices and outputs the updated database st(cid:48).

Correctness. By correctness of the ORE scheme, the state
st maintained by the server after each query is a (sorted) list
of right encryptions (under sk) of the values in the database
D after the corresponding insertions and deletions. Thus,

1174the response r returned by the server to the client in a range
query for the range [x, y] is precisely the subset of ciphertexts
whose plaintext values fall in the range [x, y]. Correctness
follows by correctness of ORE decryption (which in turn
follows from correctness of the ORE scheme).

Additional properties. In addition to the core security
and correctness properties that we want from a symmet-
ric range query scheme, we also note several useful proper-
ties that our construction Πrq achieves for handling eﬃcient
range queries in our client-server model.
• Stateless client and single-round protocols. The
client does not need to maintain state between queries,
and each query is a single round trip between the client
and the server. Our protocol achieves optimal round com-
plexity.
• Short query tokens. The size of each query token t
is asymptotically optimal. They are approximately the
same length as the inputs used to generate the query, and
independent of the size of the database.
• Fast responses. The running time of the server’s algo-
rithms is sublinear (logarithmic) in the total number of
elements in the database.

In the full version [43], we also describe how our techniques
can be extended to databases with multiple columns.

Online security. Here, we give a informal characterization
of the online leakage of our range query scheme. In the full
version [43], we give a complete and formal speciﬁcation of
the scheme’s leakage.
In our description below, we refer to the leakage func-
tion L(d)
blk(m1, m2) as the “ORE leakage” between two equal-
length values m1 and m2.
Informally, the “ORE leakage”
in our setting is the ordering of m1 and m2 and the index
of the ﬁrst diﬀering digit in the d-ary representation of m1
and m2. Our range query leakage function Lrq then takes
as input the database D = (d1, . . . , dM ), and a sequence of
(cid:96) queries q1, . . . , q(cid:96) and outputs:
• For each i ∈ [M ] and j ∈ [(cid:96)], the ORE leakage between
each database value di and query qj. For a range query
of the form q = (x, y), this includes the ORE leakage
between both pairs (di, x) and (di, y) for i ∈ [M ].
• For each query qi, and each insertion or deletion query
q(cid:48)
j, the ORE leakage between qi and q(cid:48)
j. Similarly, for
a range query of the form qi = (xi, yi), this include the
j) and (yi, q(cid:48)
ORE leakage between both pairs (xi, q(cid:48)
j).

Roughly speaking, our range query scheme reveals the or-
dering and the index of the ﬁrst diﬀering digit between every
query and every message in the database. We also leak some
information between range queries and insertion/deletion
queries. We formalize these notions in the full version.

Oﬄine security. Oﬄine security (Deﬁnition 5.2) of our
range query scheme Πrq follows directly from the fact that
the encrypted database stored on the server only contains a
collection of right ciphertexts, which are simulatable given
just the size of the collection (that is, the right ciphertexts
are semantically secure encryptions of their values). We give
the formal proof in the full version [43].

Robustness against oﬄine inference attacks. Oﬄine
security for our protocol implies that the contents of the
server’s database are always semantically secure. Conse-

quently, ciphertext-only inference attacks, such as those stud-
ied by Naveed et al. [46], do not directly apply.
In their model [46, §4.2], an attacker is able to obtain ac-
cess to the “steady state” of an encrypted database, which
describes the database in a state that includes all auxiliary
information that is needed to perform encrypted searches
eﬃciently.
In our scheme, no such auxiliary information
is needed on top of the ORE scheme, and yet we are still
able to achieve oﬄine security. In contrast, in other existing
PPE-based schemes, comparisons are enabled by a underly-
ing layer of OPE encryption, which is vulnerable to inference
attacks. Thus, even though these schemes can be modiﬁed
to satisfy our notion of oﬄine security, their “steady-state”
representation is in the form of OPE ciphertexts which are
vulnerable to inference attacks. Our scheme achieves robust-
ness against these ciphertext-only inference attacks because
our steady-state representation is precisely our oﬄine rep-
resentation. Finally, we note that we can always add addi-
tional layers of encryption (e.g., onion encryption [51]) with-
out compromising the security of our range query scheme,
which can serve as a useful countermeasure against general
adversaries.

6.

IMPOSSIBILITY RESULT FOR OPE

In the full version of this paper [43], we give matching up-
per and lower bounds for stateless OPE schemes that satisfy
the notion of best-possible semantic security. Our results
strengthen the lower bound given by Boldyreva et al. [9,
10], and can be stated informally as follows:

Theorem 6.1

(Informal). There are no eﬃcient order-
preserving encryption schemes that satisfy best-possible se-
curity on a message space containing at least 3 elements.

Our lower bound shows that even in the small-domain set-
ting, strong security is only possible with ORE, and not
OPE.

7. EXPERIMENTAL EVALUATION

To assess the practicality of our order-revealing encryp-
tion scheme from Section 4, we give a full implementation
of our scheme and measure its performance on a wide range
of parameter settings. We then compare the performance
against the Boldyreva et al. [9] OPE scheme and the Ch-
enette et al. [22] ORE scheme. In our implementation, we
use the technique from Remark 3.1 to shrink the ciphertexts.

Instantiating primitives. Our implementation is entirely
written in C. We operate at 128-bits of security (λ = 128).
We instantiate the PRF with AES-128. To construct a PRP
on 2d-bit domains (for d < 128), we use a 3-round Feistel
network using a PRF on d-bit inputs [44].
In our experi-
ments, we only consider d < 128, and thus, can instantiate
the PRF using AES (where the d-bit input is padded to
128-bits). For the random oracle, we consider two candi-
date constructions. In the ﬁrst, we use SHA-256, a standard
cryptographic hash function commonly modeled as a ran-
dom oracle.

For our second instantiation of the random oracle, we use
an AES-based construction. This allows us to leverage the
AES-NI instruction set for hardware-accelerated evaluation
of AES. Recall from Section 4 that our construction requires
a random oracle mapping from a domain {0, 1}2λ = {0, 1}256

1175to Z2 (after applying the modiﬁcation from Remark 3.1). On
an input (k, x) ∈ {0, 1}128 ×{0, 1}128, we take the output of
the random oracle to be the least signiﬁcant bit of AES(k, x).
Certainly, if we model AES as an ideal cipher, then this con-
struction implements a random oracle. We note that mod-
eling AES as an idealized object such as a random permuta-
tion or an ideal cipher has been used in many other recent
works such as constructing eﬃcient garbling schemes [5] or
the Simpira family of permutations [36].

In our implementation, we use the OpenSSL [55] imple-
mentations of AES and SHA-256 as well as the GMP [35]
library for big integer arithmetic. Our full implementation
contains approximately 750 lines of code. For our imple-
mentation of Boldyreva et al.’s OPE scheme, we use the
C++ implementation from CryptDB [51],6 and for our im-
plementation of Chenette et al.’s ORE scheme, we use the
C implementation FastORE.7 In our benchmarks, we sub-
stitute AES for HMAC as the underlying PRF used in the
FastORE library. We believe this provides a more balanced
comparison of the performance tradeoﬀs between the Ch-
enette et al. scheme and our new ORE scheme.

Benchmarks and evaluation. We run all of our exper-
iments on a laptop running Ubuntu 14.04 with a 2.3 GHz
Intel Core i7 CPU (Haswell microarchitecture) and 16 GB
of RAM. Although our encryption algorithm is easily paral-
lelizable, we do not leverage parallelism in our benchmarks.
The processor supports the AES-NI instruction set, hence
our decision to base as many primitives as possible on AES.
Our micro-benchmarks for encrypting and comparing 32-bit
integers are summarized in Table 1. In Figure 2, we com-
pare the cost of encryption for the diﬀerent schemes across
diﬀerent-sized message spaces.

From Table 1, the time needed to compare two ORE ci-
phertexts is similar to the time needed to compare two in-
tegers (in the OPE setting). Thus, while it is the case that
deploying ORE in encrypted database systems would re-
quire implementing a custom comparator in the database
management system, in practice, this incurs a very small
computational overhead.

Compared to OPE, our new ORE scheme is signiﬁcantly
faster. For instance, when processing byte-size blocks, en-
crypting a single 32-bit value requires just over 50 µs of
computation and is over 65 times faster compared to vanilla
OPE. Even our SHA-256-based implementation is about 10x
faster compared to OPE. Moreover, as shown in [22, Re-
mark 2.6 and §4], an ORE scheme which leaks the ﬁrst
bit that diﬀers between two encrypted messages is prov-
ably more secure than any OPE scheme which behaves like
a truly random order-preserving function. Since our new
ORE scheme leaks strictly less information than the Ch-
enette et al. scheme, we conclude that our new ORE scheme
is both more secure and faster compared to OPE schemes.
Of course, when compared to the bit-by-bit construction
of [22], our new ORE scheme is much slower. However, in
exchange, our new ORE scheme confers stronger security as
well as lends itself nicely towards a range query system that
provides robustness against inference attacks.

One of the main limitations of our new ORE scheme is
the increase in the ciphertext size. Both OPE and the Ch-
enette et al. ORE schemes are able to achieve ciphertexts

6https://github.com/CryptDB/cryptdb
7https://github.com/kevinlewi/fastore

10,000

1,000

100

10

1

)
s
µ
(

i

e
m
T
n
o
i
t
p
y
r
c
n
E

0

16

32

48

64

Bit Length of Message Space

Boldyreva et al.

Chenette et al.

Our scheme (SHA)

Our scheme (AES)

Figure 2: Performance comparison between our
ORE scheme (Section 4) and existing OPE and ORE
schemes. We use a ﬁxed base representation d = 8
for our ORE scheme in these experiments. The two
variants of our scheme, labeled SHA and AES, re-
fer to how we instantiate the random oracle in our
construction.

where the overhead is an additive or (small) multiplicative
factor in the length of the messages. In our setting, because
our main construction relies critically on a small-domain
ORE scheme that oﬀers best-possible security, and the ex-
isting small-domain ORE scheme have ciphertexts that grow
linearly in the size of the message space, the size of the ci-
phertexts in our composed scheme grows quickly in the block
size. Nonetheless, when encrypting byte-by-byte, encrypting
a 32-bit integer requires just 224 bytes, which is quite mod-
est for many practical applications. An interesting direction
for future work is to construct a more compact small-domain
ORE with best-possible security. Such a construction can be
extended to a large-domain ORE with shorter ciphertexts by
applying our techniques from Section 4.

8. RELATED WORK

In this section, we survey some of the literature on order-
revealing and order-preserving encryption, as well as the ex-
isting work on searching over encrypted data.

OPE and ORE. The concept of order-preserving encryp-
tion was ﬁrst introduced by Agrawal et al. [2], who explored
the application of OPE for performing encrypted database
queries. The ﬁrst explicit OPE construction was formalized
in the seminal work of Boldyreva et al. [9], and has sub-
sequently been expanded on in a multitude of works [10,
48, 50, 54, 41, 40, 45, 52, 8]. Some of these works [10, 54]
have focused on exploring the security properties of order-
preserving encryption. Others [50, 41, 40, 52, 8] have consid-
ered stateful or interactive OPE solutions which avoid both
the lower bounds in [9, 10, 50] as well as our strengthened
lower bound from Section 6. However, synchronizing state
and coordinating multi-round interactions in distributed,
large-scale execution environments is often diﬃcult, and con-
sequently, nearly all existing OPE deployments (e.g., Sky-
High Networks, CipherCloud) use stateless variants of OPE
for sorting and ﬁltering on encrypted data. Numerous ad
hoc OPE schemes [7, 38] have also been proposed in recent
years, but they often lack a formal security analysis.

1176Scheme

Boldyreva et al. OPE [9]

Chenette et al. ORE [22]

Our ORE scheme (RO: SHA-256)

Our ORE scheme (RO: AES)

d

–

1

4
8
12

4
8
12

Encrypt Compare

|ct| Leakage

3601.82 µs

0.36 µs

8 bytes

(Hard to quantify)

2.06 µs

0.48 µs

8 bytes First bit that diﬀers

54.48 µs
361.04 µs
4370.64 µs

16.50 µs
54.87 µs
721.37 µs

0.38 µs
0.98 µs
3.20 µs

0.31 µs
0.63 µs
2.61 µs

192 bytes
224 bytes
1612 bytes

192 bytes
224 bytes
1612 bytes

First block of d-bits that diﬀers

First block of d-bits that diﬀers

Table 1: Performance comparison between our ORE scheme from Section 4 and existing OPE and ORE
schemes. We consider two variants of our scheme: one where the random oracle is instantiated using an
AES-based construction and one where the random oracle is instantiated with SHA-256. We describe these
two instantiations in greater detail in Section 7. In these benchmarks, we use a 32-bit plaintext space, and
measure the time needed to encrypt a (randomly chosen) message and the time needed to compare two
ciphertexts. The parameter d is the block size (in bits) in our ORE scheme. Our micro-benchmarks are
averaged over 50–107 iterations (the precise number is adjusted based on the approximate runtime of the
algorithm).

The notion of order-revealing encryption was ﬁrst intro-
duced by Boneh et al. [12], who gave a construction from
multilinear maps that satisﬁes best-possible security. More
generally, ORE is a special case of multi-input functional
encryption (MIFE) [33]. To date, the only constructions
of general-purpose MIFE rely on heavy primitives such as
indistinguishability obfuscation [4, 28] and are far too inef-
ﬁcient to deploy. Chenette et al. [22] recently proposed an
eﬃcient ORE scheme, which we improve upon and general-
ize in our work. In the small-domain setting, it is possible to
construct ORE from either symmetric or public-key encryp-
tion [3, 16] or bilinear maps [42], but these constructions are
far less eﬃcient compared to our small-domain ORE from
Section 3, which just relies on PRFs.

Searching on encrypted data. Numerous techniques,
such as searchable symmetric encryption (SSE) [53, 24, 20],
property-preserving encryption (PPE) [9, 48, 21], fully ho-
momorphic encryption (FHE) [29], hidden vector encryp-
tion [15], oblivious RAMs (ORAM) [32], and others have
been proposed for tackling the general problem of searching
and querying on encrypted data. While tools such as FHE or
ORAM can be used for searching on encrypted data [11, 57],
these methods are prohibitively expensive for nearly all real-
world deployments. On the more practical side, numerous
SSE schemes [53, 30, 19, 24, 20, 37, 47] have been proposed
in the last 15 years, but these past works are limited to exact
keyword searches, and generally do not handle the eﬃcient
computation of complex queries (such as range queries) over
encrypted data. More recently, several works [18, 17, 49, 25]
describe constructions of SSE schemes that are able to han-
dle more expressive queries. We survey these works below.
Cash et al. [18] give the ﬁrst SSE scheme that supports
Boolean queries (in time sublinear in the size of the database)
with a small amount of leakage and security from the de-
cisional Diﬃe-Hellman (DDH) assumption. Subsequently,
Cash et al. [17] extend the construction to allow for up-
dates to the encrypted database as well as support multi-
ple, potentially dishonest clients. Handling updates requires
the client to maintain a small amount of state (or requires
additional rounds of communication and leads to increased
leakage). Boolean queries alone, however, do not suﬃce for
range queries, so in another follow-up work, Faber et al. [25]

show how the Cash et al. SSE scheme can be leveraged for
range queries. Their resulting construction leaks some addi-
tional information about the database contents, namely the
number of values that fall into certain subintervals within
the requested range. Moreover, due to the use of univer-
sal covers, the size of the server’s response set to a range
query may be up to 66% larger than the size of the true re-
sponse set. We do not know of any existing SSE scheme that
can eﬃciently support range queries with optimal (minimal)
leakage.

Concurrent to the work of Cash et al., Pappas et al. [49]
introduce BlindSeer, a private database management system
that can support a wide-range of queries in sublinear time
over an encrypted database. Their construction leverages
generic two-party computation tools such as Yao’s garbled
circuits [56], and their construction provides security in the
semi-honest model.

Comparison to our techniques. To conclude, we high-
light some of the key diﬀerences between existing SSE meth-
ods and our ORE-based construction for implementing range
queries over an encrypted database:
• Like other PPE-based constructions, our ORE-based con-
struction integrates well with existing database manage-
ment systems—we just need to implement a custom com-
parator. With SSE, we would have to deploy a new, and
oftentimes, complex database management system. This
lacks legacy compatibility, which is a barrier to deploy-
ment in existing systems. Our approach provides a fast,
simple, and direct solution for supporting range queries
on encrypted data without requiring signiﬁcant infrastruc-
tural changes.
• We explicitly model and analyze the leakage of our range
query protocol assuming adaptive updates to the database.
• Our construction only requires symmetric primitives and
does not require more expensive primitives such as public-
key cryptography or oblivious transfer.

Acknowledgments
We thank Dan Boneh, Mark Zhandry, and Joe Zimmerman
for insightful discussions about this work. We thank the
members of the 2015 Stanford Theory Retreat for initiat-

1177ing our study of new OPE lower bounds. This work was
supported by the NSF, DARPA, the Simons foundation, a
grant from ONR, and an NSF Graduate Research Fellow-
ship. Opinions, ﬁndings and conclusions or recommenda-
tions expressed in this material are those of the author(s)
and do not necessarily reﬂect the views of DARPA.

9. REFERENCES

[1] R. Abelson and J. Creswell. Data breach at anthem may

forecast a trend. The New York Times, 2015.

[2] R. Agrawal, J. Kiernan, R. Srikant, and Y. Xu.

Order-preserving encryption for numeric data. In ACM
SIGMOD, 2004.

[3] P. Ananth and A. Jain. Indistinguishability obfuscation from

compact functional encryption. In CRYPTO, 2015.

[4] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai,

S. P. Vadhan, and K. Yang. On the (im)possibility of
obfuscating programs. J. ACM, 2012.

[5] M. Bellare, V. T. Hoang, S. Keelveedhi, and P. Rogaway.

Eﬃcient garbling from a ﬁxed-key blockcipher. In IEEE SP,
2013.

[6] M. Bellare and P. Rogaway. Random oracles are practical: A

paradigm for designing eﬃcient protocols. In CCS, 1993.

[7] C. Binnig, S. Hildenbrand, and F. F¨arber. Dictionary-based

order-preserving string compression for main memory column
stores. In ACM SIGMOD, 2009.

[8] T. Boelter, R. Poddar, and R. A. Popa. A secure one-roundtrip

index for range queries. Cryptology ePrint Archive, Report
2016/568, 2016.

[9] A. Boldyreva, N. Chenette, Y. Lee, and A. O’Neill.

Order-preserving symmetric encryption. In EUROCRYPT,
2009.

[10] A. Boldyreva, N. Chenette, and A. O’Neill. Order-preserving

encryption revisited: Improved security analysis and alternative
solutions. In CRYPTO, 2011.

[11] D. Boneh, C. Gentry, S. Halevi, F. Wang, and D. J. Wu.

Private database queries using somewhat homomorphic
encryption. In ACNS, 2013.

[12] D. Boneh, K. Lewi, M. Raykova, A. Sahai, M. Zhandry, and

J. Zimmerman. Semantically secure order-revealing encryption:
Multi-input functional encryption without obfuscation. In
EUROCRYPT, 2015.

[13] D. Boneh, A. Sahai, and B. Waters. Functional encryption:

Deﬁnitions and challenges. In TCC, 2011.

[14] D. Boneh and A. Silverberg. Applications of multilinear forms

to cryptography. Contemporary Mathematics, 2003.

[15] D. Boneh and B. Waters. Conjunctive, subset, and range

queries on encrypted data. In TCC, 2007.

[16] Z. Brakerski, I. Komargodski, and G. Segev. From single-input
to multi-input functional encryption in the private-key setting.
IACR Cryptology ePrint Archive, 2015.

[17] D. Cash, J. Jaeger, S. Jarecki, C. S. Jutla, H. Krawczyk,

M. Rosu, and M. Steiner. Dynamic searchable encryption in
very-large databases: Data structures and implementation. In
NDSS, 2014.

[18] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M. Rosu, and
M. Steiner. Highly-scalable searchable symmetric encryption
with support for boolean queries. In CRYPTO, 2013.

[19] Y. Chang and M. Mitzenmacher. Privacy preserving keyword

[27] S. Garg, C. Gentry, and S. Halevi. Candidate multilinear maps

from ideal lattices. In EUROCRYPT, 2013.

[28] S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai, and
B. Waters. Candidate indistinguishability obfuscation and
functional encryption for all circuits. In FOCS, 2013.

[29] C. Gentry. Fully homomorphic encryption using ideal lattices.

In STOC, 2009.

[30] E. Goh. Secure indexes. IACR Cryptology ePrint Archive,

2003.

[31] O. Goldreich, S. Goldwasser, and S. Micali. How to construct

random functions. J. ACM, 1986.

[32] O. Goldreich and R. Ostrovsky. Software protection and

simulation on oblivious rams. J. ACM, 1996.

[33] S. Goldwasser, S. D. Gordon, V. Goyal, A. Jain, J. Katz,

F. Liu, A. Sahai, E. Shi, and H. Zhou. Multi-input functional
encryption. In EUROCRYPT, 2014.

[34] S. Goldwasser and S. Micali. Probabilistic encryption. J.

Comput. Syst. Sci., 1984.

[35] T. Granlund and the GMP development team. GNU MP: The

GNU Multiple Precision Arithmetic Library.
http://gmplib.org/, 2012.

[36] S. Gueron and N. Mouha. Simpira v2: A family of eﬃcient

permutations using the AES round function. IACR Cryptology
ePrint Archive, 2016.

[37] S. Jarecki, C. S. Jutla, H. Krawczyk, M. Rosu, and M. Steiner.

Outsourced symmetric private information retrieval. In ACM
CCS, 2013.

[38] H. Kadhem, T. Amagasa, and H. Kitagawa. A secure and
eﬃcient order preserving encryption scheme for relational
databases. In KMIS, 2010.

[39] G. Kelly. ebay suﬀers massive security breach, all users must

change their passwords. Forbes, 2014.

[40] F. Kerschbaum. Frequency-hiding order-preserving encryption.

In ACM CCS, 2015.

[41] F. Kerschbaum and A. Schr¨opfer. Optimal average-complexity

ideal-security order-preserving encryption. In ACM CCS, 2014.

[42] S. Kim, K. Lewi, A. Mandal, H. W. Montgomery, A. Roy, and

D. J. Wu. Function-hiding inner product encryption is
practical. IACR Cryptology ePrint Archive, 2016.

[43] K. Lewi and D. J. Wu. Order-revealing encryption: New

constructions, applications, and lower bounds. IACR
Cryptology ePrint Archive, 2016:612, 2016.

[44] M. Luby and C. Rackoﬀ. How to construct pseudorandom

permutations from pseudorandom functions. SIAM J.
Comput., 1988.

[45] C. Mavroforakis, N. Chenette, A. O’Neill, G. Kollios, and

R. Canetti. Modular order-preserving encryption, revisited. In
ACM SIGMOD, 2015.

[46] M. Naveed, S. Kamara, and C. V. Wright. Inference attacks on
property-preserving encrypted databases. In ACM CCS, 2015.

[47] M. Naveed, M. Prabhakaran, and C. A. Gunter. Dynamic

searchable encryption via blind storage. In IEEE SP, 2014.

[48] O. Pandey and Y. Rouselakis. Property preserving symmetric

encryption. In EUROCRYPT, 2012.

[49] V. Pappas, F. Krell, B. Vo, V. Kolesnikov, T. Malkin, S. G.

Choi, W. George, A. D. Keromytis, and S. Bellovin. Blind seer:
A scalable private DBMS. In IEEE SP, 2014.

[50] R. A. Popa, F. H. Li, and N. Zeldovich. An ideal-security

protocol for order-preserving encoding. In IEEE SP, 2013.

[51] R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and

H. Balakrishnan. Cryptdb: protecting conﬁdentiality with
encrypted query processing. In ACM SOSP, 2011.

searches on remote encrypted data. In ACNS, 2005.

[52] D. S. Roche, D. Apon, S. G. Choi, and A. Yerukhimovich.

[20] M. Chase and S. Kamara. Structured encryption and controlled

disclosure. In ASIACRYPT, pages 577–594, 2010.

POPE: partial order-preserving encoding. IACR Cryptology
ePrint Archive, 2015.

[21] S. Chatterjee and M. P. L. Das. Property preserving symmetric

[53] D. X. Song, D. Wagner, and A. Perrig. Practical techniques for

encryption revisited. In ASIACRYPT, 2015.

[22] N. Chenette, K. Lewi, S. A. Weis, and D. J. Wu. Practical

order-revealing encryption with limited leakage. In FSE, 2016.

[23] J. Coron, T. Lepoint, and M. Tibouchi. Practical multilinear

maps over the integers. In CRYPTO, 2013.

[24] R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky.

Searchable symmetric encryption: improved deﬁnitions and
eﬃcient constructions. In ACM CCS, 2006.

[25] S. Faber, S. Jarecki, H. Krawczyk, Q. Nguyen, M. Rosu, and

M. Steiner. Rich queries on encrypted data: Beyond exact
matches. In ESORICS, 2015.

[26] J. Finkle and D. Volz. Database of 191 million u.s. voters

exposed on internet: researcher. Reuters, 2015.

searches on encrypted data. In IEEE SP, 2000.

[54] I. Teranishi, M. Yung, and T. Malkin. Order-preserving

encryption secure beyond one-wayness. In ASIACRYPT, 2014.

[55] The OpenSSL Project. OpenSSL: The open source toolkit for

SSL/TLS. www.openssl.org, 2003.

[56] A. C. Yao. Protocols for secure computations (extended

abstract). In FOCS, 1982.

[57] M. Yasuda, T. Shimoyama, J. Kogure, K. Yokoyama, and

T. Koshiba. Secure pattern matching using somewhat
homomorphic encryption. In CCSW, 2013.

1178