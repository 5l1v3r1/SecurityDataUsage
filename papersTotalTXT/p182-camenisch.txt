Optimal Distributed Password Veriﬁcation

Jan Camenisch

IBM Research – Zurich
jca@zurich.ibm.com

Anja Lehmann

IBM Research – Zurich
anj@zurich.ibm.com

Gregory Neven

IBM Research – Zurich
nev@zurich.ibm.com

ABSTRACT
We present a highly eﬃcient cryptographic protocol to pro-
tect user passwords against server compromise by distribut-
ing the capability to verify passwords over multiple servers.
Password veriﬁcation is a single-round protocol and requires
from each server only one exponentiation in a prime-order
group. In spite of its simplicity, our scheme boasts security
against dynamic and transient corruptions, meaning that
servers can be corrupted at any time and can recover from
corruption by going through a non-interactive key refresh
procedure. The users’ passwords remain secure against of-
ﬂine dictionary attacks as long as not all servers are cor-
rupted within the same time period between refreshes. The
only currently known scheme to achieve such strong security
guarantees incurs the considerable cost of several hundred
exponentiations per server. We prove our scheme secure
in the universal composability model, which is well-known
to oﬀer important beneﬁts for password-based primitives,
under the gap one-more Diﬃe-Hellman assumption in the
random-oracle model. Server initialization and refresh must
take place in a trusted execution environment.
Initializa-
tion additionally requires a secure message to each server,
but the refresh procedure is non-interactive. We show that
these requirements are easily met in practice by providing
an example deployment architecture.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Cryptographic control;
D.4.6 [Security and Protection]: Access controls; D.4.6
[Security and Protection]: Authentication

Keywords
Password veriﬁcation, proactive security, UC security.

1.

INTRODUCTION

In spite of all their shortcomings in terms of security and
usability, passwords are still the predominant method of on-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813722 .

line user authentication. One of the main threats currently
posed to password security is server compromise. More than
one billion personal data records were reported stolen in
2014 alone [16]; most of these records included user pass-
words. With more personal and ﬁnancial data moving into
the cloud, a further increase in breaches targeting usernames
and passwords is expected for 2015 [14].

Even when properly salted and hashed, the low entropy
in human-memorizable passwords is no match for the brute
force of modern hardware: already in 2012, a rig of 25 GPUs
could test up to 350 billion guesses per second in an of-
ﬂine dictionary attack. More complicated password hash
functions [20, 24] can provide some relief, but at a linear
rate at best: the computational eﬀort to verify passwords
for an honest server increases by the same factor as for the
attacker—while the latter is probably better equipped with
dedicated password-cracking hardware.

The problem of oﬄine dictionary attacks when a server
is compromised is inherent whenever that single server can
test the correctness of passwords. A natural solution, ﬁrst
proposed by Ford and Kaliski [15], is therefore to split up
the capability to verify passwords over two or more servers,
so that security is preserved as long as less than a thresh-
old of them are hacked. This has been the central idea be-
hind several threshold password-authenticated key exchange
(TPAKE) [17, 22, 2, 12, 25, 21] and threshold password-
authenticated secret sharing (TPASS) [3, 10, 9, 18, 6] pro-
tocols as well as behind the RSA product Distributed Cre-
dential Protection (DCP) [13].

Resistance against server compromise is one thing, but
knowing how to recover from it is another. Without secure
recovery, all one can do in case of a detected breach is to
re-initialize all servers and request all users to reset their
passwords—which is probably exactly what one wanted to
avoid by deploying the scheme. In cryptographic literature,
recovery from compromise is known as proactive security
or security against transient corruptions. Of the aforemen-
tioned threshold password-authenticated protocols, only Ca-
menisch et al. [6] describe a recovery procedure and prove
their protocol secure against transient corruptions. Di Rai-
mondo and Gennaro [12] mention the possibility to refresh
shares and the RSA DCP product description [13] mentions
a re-randomization feature, but neither provides details or
a security proof. Proactive security in the protocol of Ca-
menisch et al. [6] unfortunately comes at a considerable cost:
“a few hundred exponentiations” per server may be within
practical reach for occasional data retrieval, but not for high-
volume password veriﬁcation.

182Our contribution.

We present two simple and extremely eﬃcient proactively
secure distributed password veriﬁcation protocols, allowing a
login server LS and a number of back-end servers S1, . . . ,Sn
to jointly determine the correctness of a user’s password,
while ruling out oﬄine dictionary attacks unless all servers
are corrupted during the same time period. A corrupt LS
only sees the passwords of user accounts that are created
or logged into during the corruption. No passwords, pass-
word hashes, or any other oﬄine-attackable information is
leaked for accounts that are inactive during the corruption.
We think this is a reasonable compromise for not requiring
user-side software, as it provides adequate protection against
“smash-and-grab” attacks and short-term corruptions.

Login, i.e., password veriﬁcation, is a single-round proto-
col requiring just one exponentiation in a prime-order group
on each server (two for LS), which is essentially optimal
unless schemes without public-key operations can be found.
The recovery and key refresh procedure is non-interactive
and only involves a couple of additions and pseudo-random
function evaluations per server, making it more than eﬃcient
enough to perform it preventively on a regular basis instead
of just after a detected breach. Our ﬁrst construction works
in any prime-order group, including elliptic curves, and in-
volves a three-round account creation (password setup) pro-
tocol with three exponentiations per server (six for LS). Our
second construction is based on elliptic curves with bilinear
maps and also oﬀers single-round account creation with one
exponentiation per back-end server and one exponentiation
and one pairing computation for LS. Both our protocols as-
sume that the key refresh procedure has access to a special
backup tape that is not connected during normal operation.
In practice, this can be achieved by using smart cards or by
making use of properties of modern cloud platforms, as we
will explain.

Given their extreme eﬃciency, it is all the more surpris-
ing that we managed to prove our constructions secure under
a very strong universally composable (UC) [5] notion with
transient corruptions. Parties can be dynamically corrupted
at any point in the protocol, even between communication
rounds. Transiently corrupted parties leak their full state,
but not the content of their backup tape, to the adversary
and remain corrupted until the next key refresh. Perma-
nently corrupted parties additionally leak the backup tape
and cannot be recovered.

As was argued before [21, 10, 9, 6], universal composabil-
ity oﬀers important advantages over traditional game-based
deﬁnitions in the particular case of password-based proto-
cols. Namely, UC notions leave the choice of passwords
to the environment, so that arbitrary distributions and de-
pendencies between passwords are correctly modeled. This
is crucial to guarantee security in real-life settings where
users make typos when entering their passwords, share pass-
words, or use the same password for diﬀerent accounts—
none of which are covered by currently known game-based
notions. Also, it is very unclear whether protocols can be se-
curely composed with the non-negligible attack probabilities
that game-based deﬁnitions tend to employ. We prove our
constructions secure in the random-oracle model under the
(gap) one-more Diﬃe-Hellman assumption that was previ-
ously used to prove security for blind signature [4], oblivious
transfer [11], TPASS protocols [18], and set intersection pro-
tocols [19].

We achieved this rare combination of strong security and
high eﬃciency by careful proof techniques in the random-
oracle model, as well as through some of compromises in
security that are very reasonable for practical use, but save
on cryptographic machinery in the protocol design. First,
we assume that the initialization of all servers takes place in
a trusted environment where all servers are honest. During
initialization, we assume that LS can transmit one secure
message to each back-end server Si. This secure initializa-
tion is not hard to achieve in practice, as we explain in Sec-
tion 6. Server refresh, i.e., whereby a server can recover from
a transient corruption, does not require any interaction with
other servers.
Second, the back-end servers S1, . . . ,Sn do not learn which
user is logging in or whether the password was correct. This
deﬁnitely limits their ability to throttle failed login attempts,
but since LS can apply clever throttle algorithms based on
user id and login results, the natural throttling of back-end
servers just by requiring network communication should suf-
ﬁce to fend oﬀ attacks. Finally, we do not cover robust-
ness: an adversary can make LS “err on the safe side” and
conclude that the password was false while in fact it was
correct—but not the other way around. This could be ﬁxed
by adding the same zero-knowledge or pairing veriﬁcation
as during account registration. This would have a major
impact on eﬃciency, however, so we prefer to accept this
rather benign attack in the model.

As a technical contribution, our scheme employs a novel
technique to obtain proactive security that may be of inde-
pendent interest.
In a nutshell, we start oﬀ from a basic
scheme that is secure under dynamic but non-transient cor-
ruptions. The basic scheme is secure under the gap one-more
Diﬃe-Hellman assumption, but the security proof requires
guessing one server at the beginning of the game that will
not get corrupted during the game. This guessing induces a
tightness loss in the reduction equal to the number of servers.
While that loss could still be tolerated, things get worse
when moving this scheme into a proactive setting. Here one
would have to guess an uncorrupted server at the beginning
of each epoch, so that the tightness loss blows up exponen-
tially in the number of epochs. An easy but unsatisfying
solution could be to restrict the scheme to a logarithmic
number of epochs, or to only model semi-static corruptions
where the adversary has to announce all servers that it wants
to corrupt at the beginning of each epoch. Instead, we mod-
ify the scheme to apply random-oracle-generated blinding
factors to all protocol messages, so that protocol messages
do not commit servers to their keys, without ruining the
overall functioning of the protocol.
In the simulation, we
can therefore choose a server’s keys only at the moment that
it is corrupted and carefully program the random oracle to
ensure consistency of previous protocol messages, without
having to guess anything upfront.

Related work.

Our constructions are closely related to the prime-order-
group and bilinear-map instantiations of TPASS by Jarecki
et al.’s [18] (which they call “PPSS”). In their construc-
tion, each server has a key for a veriﬁable oblivious pseudo-
random function (V-OPRF). For each server, the user en-
crypts a share of his secret under a key that is the evaluation
of the VOPRF of that server on his password. The scheme
supports thresholds as well as robustness thanks to the ver-

183iﬁability of the V-OPRF. In principle, our protocol could be
seen as a variant where all servers jointly evaluate a single,
distributed V-OPRF, rather than a separate one each, and
where servers can update their key shares for the V-OPRF.
This is not a straightforward change, however, and doesn’t
work for any V-OPRF in general. Moreover, whereas their
protocol requires LS to perform t V-OPRF veriﬁcations (i.e.,
zero-knowledge proofs or pairings) during login, our protocol
doesn’t need any at all, which has a tremendous impact on
eﬃciency. Even during account creation, our protocol only
involves a single veriﬁcation. Finally, we prove our proto-
col secure in the UC framework, as opposed to their game-
based model, which oﬀers important security improvements
as mentioned earlier.

2. PRELIMINARIES
Let κ ∈ N be a security parameter. A polynomial-time
algorithm A is an algorithm that takes κ as an implicit input
and that has running time bounded by a polynomial in κ. A
function ν(κ) is said to be negligible if for every polynomial
p(κ) there exists a κ(cid:48) ∈ N s.t. ν(κ) < 1/p(κ) for all κ > κ(cid:48).
For concrete security, one could typically use κ = 128.

Gap One-More Difﬁe-Hellman.

G each time it is called.
put a group element h ∈ G, returns hx.

Let G be a multiplicative group of prime order q > 22κ
with generator g. The gap one-more Diﬃe-Hellman assump-
tion for G says that no polynomial-time adversary A has a
non-negligible advantage of winning the following game. On
input (g, X) where X ← gx for x ←R Zq , the adversary is
given access to the following oracles:
• A target oracle T that returns a random target point t ←R
• A computational Diﬃe-Hellman oracle CDH that, on in-
• A decisional Diﬃe-Hellman oracle DDH that, on input
group elements h, z, returns 1 if z = hx and returns 0
otherwise.
Eventually, A outputs a list of tuples ((t1, z1), . . . , (tn, zn)).
It wins the game if t1, . . . , tn are diﬀerent target points gen-
for all i = 1, . . . , n, and A made less
erated by T, zi = tx
i
than n queries to its CDH oracle. The adversary’s advantage
(κ) is deﬁned as the probability that A wins the
Advgomcdh
game.
Let G1, G2, Gt be multiplicative groups of prime order
q > 22κ with generators g1, g2, gt, respectively, and with
an eﬃciently computable pairing function e : G1 × G2 → Gt
that is a non-trivial bilinear map, i.e., for all a ∈ G1, b ∈ G2,
and x, y ∈ Zq , e(ax, by) = e(a, b)xy, and e(g1, g2) = gt.
The one-more Diﬃe-Hellman assumption for (G1, G2) is
deﬁned analogously to the game above, but now A is given
(g1, g2, X = gx
2 ) as input and the T and CDH oracles gener-
ate, respectively raise to the x, elements of G1. There is no
DDH oracle, but depending on the type of curve, DDH may
be easy via the pairing function.

A,G

The one-more DH [4, 11, 18] and the gap one-more DH [18]
were used to prove the security of protocols, as well as non-
adaptive variants [19]. Cheon [8] presented an attack on the
(gap) one-more Diﬃe-Hellman assumptions that reduces the
complexity of recovering x from O(
√
and gxd
reduced by a factor O(
attack by increasing the group order with log d bits.

is given to the adversary. That is, the security is
d), so it is prudent to prevent this

q) to O((cid:112)q/d) if d|p−1

√

1. Upon input (SEND, sid, S, R, m) from S, send (SENT, sid, S,
R, |m|)) to A, generate a private delayed output (SENT, sid,
S, m) to R and halt.
2. Upon receiving (CORRUPT, sid, P) from A, where P ∈ {S, R},
disclose m to A. Next, if the adversary provides a value m(cid:48),
and P = S, and no output has been yet written to R, then
output (SENT, sid, S, m(cid:48)) to R and halt.

Figure 1: The functionality Fsmt.

is to choose shares s2, . . . , sn ←R G and set s1 ← 1/(cid:81)n
of one because(cid:81)n
Pi computes its share of unity si ← (cid:81)n
j=1,j(cid:54)=i s∆i,j{i,j} = (cid:81)n
(cid:81)n
that (cid:81)n

Combinatorial Secret Sharing.
A straightforward way to create n-out-of-n secret shares
of the unity element in a group G among parties P1, . . . ,Pn
i=2 si.
Each party Pi is given secret share si; they are correct shares
i=1 si = 1. An alternative way to compute
the same shares is by choosing s{i,j} ←R G for all 1 ≤ i <
j ≤ n and handing (s{i,j})n
j=1,j(cid:54)=i to Pi for i = 1, . . . , n. Note
that each share s{i,j} is known to parties Pi and Pj. Party
(cid:81)n
j=1,j(cid:54)=i s∆i,j{i,j}, where
∆i,j = 1 if i < j or ∆i,j = −1 otherwise. One can easily see
j=i+1 s{i,j} ·
−1{i,j} = 1. This construction is particularly interesting be-
s
cause it oﬀers a practical way to non-interactively generate
arbitrarily many shares of unity by letting s{i,j} be gener-
ated pseudorandomly from a seed that is known to parties
Pi and Pj only.

i=1 si = (cid:81)n

i=1

i=1

Secure Message Transmission.
The ideal functionality for secure message transmission
Fsmt depicted in Figure 1 allows a sender S to send a private
and integrity-protected message to a receiver R. It is the
special case of Canetti’s [5] functionality for leakage function
l (m) = |m|

Pseudo-Random Generators.
A pseudo-random generator (PRG) is a function PRG :
D → R where no polynomial-time adversary can distinguish
the output of PRG on a random input from a truly random
string. The advantage AdvprA,PRG(κ) of an adversary A is

deﬁned as(cid:12)(cid:12) Pr[1 = A(y) : x ←R D, y ← PRG(x)] − Pr[1 =
A(y) : y ←R R](cid:12)(cid:12).

Message Authentication Codes.
A message authentication code (MAC) is a function MAC :
K × {0, 1}∗ → T that on input a key µ and a message
m ∈ {0, 1}∗ returns a tag τ . We say that MAC is unforgeable
against chosen-message attack if all polynomial-time adver-
saries A have negligible advantage AdvufcmaA,MAC(κ) deﬁned as
Pr[τ = MAC(µ, m) ∧ m (cid:54)∈ Q : µ ←R K ; (m, τ ) ←R
AMAC(µ,·)], where Q is the set of messages that A submitted
to its MAC(µ,·) oracle.

3. SECURITY DEFINITION

In this section we now formally deﬁne our distributed
password veriﬁcation scheme by describing its ideal func-
tionality in the universal composability (UC) framework [5].
Roughly, a protocol is said to securely realize an ideal func-
tionality F if an environment E cannot distinguish whether
it is interacting with the real protocol π and a real adver-
sary A, or with F and a simulator SIM. We denote the

184probability that E outputs 1 in both worlds as RealπE,A(κ)
and IdealF

E,SIM(κ), respectively.

First, let’s brieﬂy recall the goal of our distributed pass-
word veriﬁcation system, before we present our ideal func-
tionality. In our system, a login server LS is the main ac-
cess point where users provide their username uid and pass-
word pwd. Once a user has created an account for such a
username-password combination with the LS, he can subse-
quently login by providing the correct username and pass-
word again. Thus, the login server must be able to verify
whether a password attempt pwd(cid:48) matches the stored pass-
word pwd or not. Our goal is to provide that functionality
without introducing a single point of failure that, when cor-
rupted, leaks all passwords to the adversary or allows oﬄine
attacks against them. Therefore, LS is assisted by n servers
S1, . . . ,Sn running in the back-end. Those servers have to
actively contribute to allow the veriﬁcation of a password
veriﬁcation and thus can refuse whenever they notice sus-
picious activity that might be aimed at an online password
guessing attack. Note that password changes are not explic-
itly modeled; these can always be implemented by perform-
ing a login under the old password followed by an account
creation with the new password (if necessary for a new user-
name, e.g., containing an increased index).

To model a realistic setting, we consider active and adap-
tive corruptions, allowing the adversary to take control of
any initially honest party at any time. We distinguish be-
tween transient and permanent corruptions. Transiently
corrupted parties do not leak the contents of their backup
tape and can recover from an attack by going through a
refresh procedure. In a permanent corruption, the backup
tape is leaked to the adversary, and there is no way to re-
cover, meaning that the server is corrupted for all future
epochs. As long as the adversary does not corrupt all servers
LS,S1, . . . ,Sn in the same epoch, our distributed password
veriﬁcation scheme protects the stored passwords, meaning
that the adversary neither learns the passwords nor is able
to perform oﬄine attacks on them.
3.1 Ideal Functionality

The detailed description of our ideal functionality Fdpv is
given in Figure 2. When describing our functionality, we
use the following writing conventions to reduce repetitive
notation:
• The functionality ignores all inputs other than INIT un-
til the instance is active. Once the instance is active, it
ignores further calls to INIT.
• For all interfaces (except INIT), the ideal functionality
only considers the ﬁrst input for each ssid and for each
originating party P. Subsequent inputs to the same in-
terface for the same ssid coming from the same party P
are ignored.
• At each invocation, the functionality checks that sid =
(LS,S1, . . . ,Sn, sid(cid:48)) for server identities LS,S1, . . . ,Sn,
and sid(cid:48) ∈ {0, 1}∗. Also, whenever we say that the func-
tionality receives input from or provides output to LS or
Si, we mean LS or Si as speciﬁed in the sid .
• When we say that the functionality “looks up a record”, we
implicitly understand that if the record is not found, F.
ignores the input and returns control to the environment.
• We assume that the session identiﬁer sid and sub-session
identiﬁers ssid given as input to our functionality are glob-

ally unique, and that honest parties drop any inputs with
(sub)session identiﬁers that are not locally unique.

We now also describe the behavior of the main interfaces
in a somewhat informal manner to clarify the security prop-
erties that our functionality provides.

Account Creation.
The creation of a new account for username uid and pass-
word pwd is initiated by the login server LS and requires
the active approval of all n back-end servers S1, . . .Sn (if
LS is honest). Several account creation (and login) sessions
can be run in parallel; a unique sub-session identiﬁer ssid is
input to all create and login related interfaces and identiﬁes
the respective sub-session.

2: The CREATE interface allows the login server to trigger the
creation of a new user record (setup, ssid , uid , pwd, proceed ,
ﬁnished ). The two ﬂags, proceed and ﬁnished , reﬂect the
status of the record and are both initially set to 0.

3: The PROCEED interface can be invoked by the back-end
servers Si to signal their willingness to continue an account
creation (or login) session, identiﬁed by the given ssid . Only
if all n servers have given the ok to proceed, the setup
(or login) account associated with ssid gets activated for
ﬁnalization, which is modeled by setting proceed ← 1.
Awaiting explicit approval of all servers gives each server
the opportunity to throttle or block a session if they detect
some suspicious behaviour, which is crucial to prevent oﬄine
attacks against the password.

If the login server is corrupt, an activated account creation
(or login) session also increases the global guesses counter,
giving the adversary one more password guess (via the in-
terface PWDGUESS ).

4: The CREATEOK interface can be invoked by the adversary
to allow completion of the setup account for ssid , which
is realized by setting ﬁnished ← 1. However, if the login
server is honest, the adversary can only complete records
for those ssid ’s to which all servers have already agreed to
proceed. This restriction does not hold for a corrupt login
server though, as in the real world, the corrupt LS could
always create as many (bogus) user records as he wants.
Whenever the LS gets honest again, the login will most
likely fail for such bogus records though. This is modeled
accordingly in our RESULT interface where the adversary can
always make the veriﬁcation fail for such forged accounts.

Login.
To verify whether a provided username-password combi-
nation uid , pwd(cid:48) is correct, the login server LS can initiate
a login request. Then, if all servers agree to proceed (us-
ing the 3.PROCEED interface), the adversary can instruct the
ideal functionality to inform the LS whether the provided
password attempt pwd(cid:48) matches the setup password pwd
stored for uid . Again, each login sub-session is identiﬁed via
a unique ssid(cid:48).
5: The LOGIN interface is invoked by the LS on input ssid(cid:48),
uid , pwd(cid:48) and triggers the creation of a new login record
(login, ssid(cid:48), uid , pwd(cid:48), proceed(cid:48)) with proceed ← 0.
6: The RESULT interface allows the adversary to instruct
Fdpv to release the result of the password veriﬁcation to the

1851. Initialization.

On input (INIT, sid) from login server LS:
• Record this instance as active, set guesses ← 0 and create
• Send (INIT, sid) to A.

a record (corrupt, TC, PC) with TC, PC ← ∅.

2. Account Creation Request.

On input (CREATE, sid, ssid, uid, pwd) from login server LS:
• If LS is honest, and a setup record for uid exists, then
ignore this input.
• Create a new record (setup, ssid, uid, pwd, proceed, ﬁnished)
with proceed ← 0 and ﬁnished ← 0.
• Send (CREATE, sid, ssid, uid) to A.

3. Server Proceed (used in account creation and login).

On input (PROCEED, sid, ssid) from a server Si:
• Look up setup or login record for ssid.
• If PROCEED messages from all n servers S1, . . . , Sn have
been received for ssid, update the login or setup record
for ssid by setting proceed ← 1, and if LS is corrupt, set
guesses ← guesses + 1.

• Send (PROCEED, sid, ssid, Si) to A.

4. Creation Result.

On input (CREATEOK, sid, ssid) from A:
• Look up setup record (setup, ssid, uid, pwd, proceed,
• If the LS is honest, only proceed if proceed = 1.
• Update the record by setting ﬁnished ← 1 and output

ﬁnished) for ssid.

(CREATEOK, sid, ssid) to LS.

5. Login Request.

On input (LOGIN, sid, ssid(cid:48), uid, pwd(cid:48)) from LS:
• Create a new record (login, ssid(cid:48), uid, pwd(cid:48), proceed(cid:48)) with

proceed(cid:48) ← 0. and send (LOGIN, sid, ssid(cid:48), uid) to A.

6. Login Result.

On input (RESULT, sid, ssid(cid:48), fail) from adversary A:
• Look up login record (login, ssid(cid:48), uid, pwd(cid:48), proceed(cid:48))
record
for
(setup, ssid, uid, pwd, proceed, ﬁnished) for uid. Ignore this
input if proceed(cid:48) = 0 or ﬁnished = 0.

corresponding

ssid(cid:48)

setup

and

the

• If pwd (cid:54)= pwd(cid:48), or if fail = 1 and at least one server from
S1, . . . , Sn is corrupt or proceed = 0, then set pwdok ← 0.
Else, set pwdok ← 1.

• If LS is corrupt, set guesses ← guesses − 1.
• Delete the login record for ssid(cid:48) and send a delayed output

(RESULT, sid, ssid(cid:48), pwdok ) to LS.

7. SSID Timeout.

On input (TIMEOUT, sid, ssid) from LS:
• If a login record for ssid exists, delete the record.
• If a setup record (setup, ssid, uid, pwd, proceed, ﬁnished)
for ssid and with ﬁnished = 0 exists, then delete the record.

8. Server Corruption.

On input (CORRUPT, sid, S, mode) from A, where S ∈ {LS,
S1, . . . , Sn} and mode ∈ {trans, perm}:
• Look up record (corrupt, TC, PC).
• If mode = trans, update the record with TC ← TC∪{S}.
• If mode = perm, update the record with PC ← PC ∪ {S}.
• If TC ∪ PC = {LS, S1, . . . , Sn} then set guesses ← ∞.
• If S = LS, then assemble L ← {(ssid i, uid i, pwdi)} for
all ongoing sessions, i.e., extract the passwords from all
setup records (setup, ssid i, uid i, pwdi, proceed i, ﬁnished i)
with ﬁnished i = 0 and all
stored login records
(login, ssid i, uid ,pwdi, proceed i). If S (cid:54)= LS, set L ← ∅.

• Send (CORRUPT, sid, L) to A.

9. Server Refresh.

date the record to (corrupt, ∅, PC).

On input (REFRESH, sid) from LS:
• Look up the corruption record (corrupt, TC, PC) and up-
• Delete all setup records with ﬁnished = 0 and all login
• Send (REFRESH, sid, S) to A.

records.

10. Password Guessing.

up

the

setup

proceed, ﬁnished) with ﬁnished = 1.

On input of (PWDGUESS, sid, uid, pwd∗) from adversary A:
• Look
• If guesses = 0 set pwdok ← ⊥.
• Else, set guesses ← guesses − 1 and, if pwd∗ = pwd, set
pwdok ← 1 , otherwise set pwdok ← 0.
• Send (PWDGUESS, sid, uid, pwdok ) to A.

(setup, ssid, uid, pwd,

record

Figure 2: Ideal Functionality Fdpv with sid = (LS,S1, . . . ,Sn, sid(cid:48)).

login server LS. The adversary can do so only for those login
sessions for which all servers already gave the ok to proceed,
i.e., the login record for ssid(cid:48) contains proceed(cid:48) = 1 (set via
the 3.PROCEED interface). Note that here the check whether
proceed(cid:48) = 1 is also required for a corrupt LS, as otherwise a
corrupt login server could oﬄine attack the user passwords.

If all servers agreed to proceed, the ideal functionality then
looks up the corresponding setup record (setup, ssid , uid ,
pwd, proceed , 1) for uid and sets the veriﬁcation result to
pwdok ← 1 if the password match, i.e., pwd = pwd(cid:48), and
pwdok ← 0 otherwise. If at least one back-end server Si ∈
{S1, . . . ,Sn} is corrupt, or the account was created by a
corrupt LS, then A can enforce a negative result pwdok ← 0,
by passing fail = 1 as extra input. However, the adversary
can only turn a successful result into a failed one, but not
vice versa, i.e., he cannot make a mismatch of the passwords
look like a match.
Further, if the login result is delivered to a corrupt LS, then
the global guesses counter is decreased. Recall that guesses
gets increased in the PROCEED interface when LS is corrupt
and all servers want to proceed with ssid(cid:48). Thus, for lo-
gin, the adversary can basically choose whether it wants to

use that “guess” to complete the login request, or to per-
form a password guess at an arbitrary user account via the
PWDGUESS interface. Note that for the latter, the LS can
already be honest again (if a refresh took place), i.e., that
the adversary can keep the password guess for a later time.

Finally, when a login session is completed, the correspond-
ing login record is deleted. This is important for corrup-
tion, because an adversary who corrupts the LS learns the
passwords of all ongoing (or interrupted) setup and login
sessions.

Time Out.
7: The TIMEOUT interface allows the login server to termi-
nate ongoing account creation or login sessions. The ideal
functionality then deletes the login or setup record for the
speciﬁed ssid . For setup accounts this is only possible for
incomplete records, i.e., where ﬁnished = 0. This models
the desired ability of a real world LS to abandon sessions
when it hasn’t received all server responses in an appropri-
ate time, e.g., if a server refuses to proceed, or the response
got intercepted by the adversary.

186(Un)Corruption & Password Guessing.

Our functionality supports adaptive and transient as well
as permanent corruptions. The environment can, at any
time, decide to corrupt any initially honest server LS or Si
and specify the corruption type. In a transient corruption,
the party remains corrupted until the next refresh of that
server. Parties that are permanently corrupted cannot be
recovered and remain corrupted until the end of the game.
As long as not all parties are corrupted at the same time
(regardless of whether they are transiently or permanently
corrupted), the adversary has only very limited power for
attacking the stored passwords, which is modeled by the
password guessing interface. Note that we do not follow the
standard UC corruption model which, upon corruption of a
party, gives all past in- and outputs to the adversary. This is
clearly not desirable in the given context of protecting bulk
user passwords that are processed by the login server. Thus,
we aim at stronger security guarantees, despite adaptive cor-
ruptions, which is modeled by the following interfaces.

8: The CORRUPT interface allows the adversary to transiently
(mode = trans) or permanently (mode = perm) corrupt any
party S ∈ {LS,S1, . . . ,Sn}. If S = LS, i.e., the adversary
decided to corrupt the login server, it learns the passwords
of all ongoing setup and login sessions. When all parties
are corrupted at the same time, the adversary is still not
given the stored passwords. Instead, the functionality sets
guesses ← ∞, which gives the adversary unlimited access to
the PWDGUESS interface described below.

9: By invoking the REFRESH interface, all transiently cor-
rupted servers become honest again. From then on, inputs
and outputs of non-permanently-corrupted servers go to the
environment, instead of to the adversary (until a server is
corrupted again). Once the adversary has corrupted all par-
ties at the same time, however, the unlimited capabilities
for oﬄine attacks remain. Further, the functionality deletes
all records of incomplete setup or login sessions.

10: The PWDGUESS interface is the only possibility of the
adversary to attack the stored user passwords. The access
to this interface is limited by the guesses counter. As long
as not all parties got corrupted at the same time, guesses
is only increased when a corrupt login server started a new
setup or login session, and all servers agreed to proceed. For
each such session, the adversary gets one more guess against
a password for a uid of his choice.

is G(uid , pwd, H(uid , pwd)K ), where K = (cid:80)n
LS can compute v ← (cid:81)n

4. OUR FIRST CONSTRUCTION
The basic idea of the protocol is so simple that it can ac-
tually be explained in a couple of lines. Each server Si ∈
{LS = S0,S1, . . . ,Sn} has its own secret exponent Ki. The
“password hash” stored by LS for user uid and password pwd
i=0 Ki mod q
and G and H are hash functions. To compute this value,
LS chooses a random nonce N ←R Zq and sends u ←
H(uid , pwd)N to Si, who responds with vi ← uKi so that
= H(uid , pwd)K . This
computation is performed at account creation and again at
each login to check that the recomputed value matches the
stored hash. To refresh their keys, all servers add a pseudo-
randomly and non-interactively generated share of zero to
their Ki so that the individual keys are independent of those

i=0 v1/N

i

in the previous epoch, but their sum K = (cid:80)n

remains constant.

i=0 Ki mod q

i

There are two problems that slightly complicate the pro-
tocol, however. First, to obtain proactive security for ar-
bitrarily many epochs, it is crucial that previous protocol
messages do not commit a server Si to its secret key Ki.
Non-committing encryption [7] doesn’t help, because the ad-
versary could corrupt LS and decrypt the elements vi that
commit Si to its key Ki. Instead, we apply a clever com-
bination of blinding factors to each protocol message that
preserve the overall result of the protocol, but that avoid
honest servers from having to commit to their keys.
Second, a corrupt server Si may misbehave and use a
(cid:54)= Ki during its computation of vi.
diﬀerent exponent K (cid:48)
This isn’t much of a problem if it happens during login:
at most, it could make an honest LS erroneously conclude
that a correct password was incorrect, but our functional-
ity explicitly tolerates such “true negatives”. A server us-
ing a diﬀerent exponent during account creation is more
problematic, however. While there doesn’t seem to be an
obvious attack, the reduction to the gap one-more Diﬃe-
Hellman problem ceases to go through. Normally, the re-
duction works by inserting CDH target points as responses
to H(·) queries and observing the adversary’s G(·) queries
for CDH solutions H(uid , pwd)K . When LS stores a pass-
word hash G(uid , pwd, H(uid , pwd)K(cid:48)
) for K (cid:48) (cid:54)= K , however,
the reduction can no longer extract H(uid , pwd)K when the
adversary guesses the password.
To prevent this, LS must verify at account creation that
the obtained value v is indeed H(uid , pwd)K . In our second
construction, the LS can do so using a pairing computa-
In our ﬁrst protocol, we let the servers engage in a
tion.
distributed interactive zero-knowledge protocol allowing LS
to check that the “overall” exponent K was correct, but with-
out committing servers to their individual exponents Ki.

4.1 Scheme
Let G be a multiplicative group of prime order q > 22κ
with generator g. Let H : {0, 1}∗×{0, 1}∗ → G, G : {0, 1}∗×
{0, 1}∗ × G → {0, 1}2κ, C : Zq → {0, 1}2κ, B0 : {0, 1}κ ×
N → G, B1 : {0, 1}κ × N → G, B2 : {0, 1}κ × N → G, and
B3 : {0, 1}κ ×N → Zq be hash functions modeled as random
oracles. Let PRG : {0, 1}κ → {0, 1}κ × Zq ×{0, 1}κ ×{0, 1}κ
be a pseudo-random generator and MAC : {0, 1}κ×{0, 1}∗ →
T be a message authentication code.

Initialization takes place in a secure environment where
all parties are uncorrupted and can communicate securely
over a secure message transmission functionality Fsmt. Dur-
ing initialization and refresh, each party additionally has
read/write access to a backup tape backup. As the backup
tape is not used during account creation and login, it is eas-
ier to protect by disconnecting it during regular operation.
The diﬀerence between a transient and a permanent corrup-
tion in the real world is that, in a transient corruption, the
adversary is given control of that party and its current state
information, but not its backup tape. In a permanent cor-
ruption, the adversary is additionally given the content of
the backup tape. Rather than assuming that parties revert
to a ﬁxed default state when recovering from corruption, as
done in previous works [1], we assume that a party refreshes
by starting from a clean copy of its code and deriving its new
state information from its backup tape and its last state be-

187fore refresh (which may have been tampered with by the
adversary).
Once initialization is ﬁnished, the servers LS,S1, . . . ,Sn
communicate over an untrusted network, where messages
can be arbitrarily observed, modiﬁed, and delayed by the
adversary, but all messages are integrity-protected with a
MAC. Our protocol provides LS with a shared MAC key
µ{0,i} with each server Si, i = 1, . . . , n. Whenever the de-
scription below says that “LS sends m to Si”, it actually
means that LS computes τ ← MAC(µ{0,i}, (m,LS)) and
sends (m, τ ) to Si. Whenever it says that “Si receives m
from LS”,
it actually means that Si receives (m, τ ) and
checks that τ = MAC(µ{0,i}, (m,LS)), ignoring the message
m if that is not the case. The communication in the other
direction from server Si back to LS is protected in the same
way with the same MAC key µ{0,i}.
In the protocol below, the state information of each server
Si ∈ {LS = S0,S1, . . . ,Sn} contains a list of blinding seeds
s{i,j} for j = 1, . . . , n, j (cid:54)= i that are used to generate random
shares of the unity element in G or of zero in Zq using the
combinatorial secret sharing scheme recalled in the prelimi-
naries. All servers S1, . . . ,Sn maintain an associative array
USED to keep track of previously used subsession identiﬁers
ssid . In each account creation or login session, the servers
derive fresh shares βi,0, . . . , βi,3 of unity or zero using the
random oracles B0, . . . , B3 applied to s{i,j} and ssid , and
use these shares as blinding factors for their protocol mes-
i=0 βi,3 =
0 mod q. More precisely, Si’s blinding factors are computed
j=0,j(cid:54)=i Bk(s{i,j}, ssid )∆i,j for k = 0, 1, 2 and as
j=0,j(cid:54)=i ∆i,jB3(s{i,j}, ssid ) mod q, where ∆i,j = 1

i=0 βi,k = 1 for k = 0, 1, 2 and (cid:80)n

sages so that (cid:81)n
as βi,k ←(cid:81)n
βi,3 ←(cid:80)n

if i < j and ∆i,j = −1 otherwise.
Initialization. During initialization, all servers are uncor-
rupted and can communicate through the secure message
transmission functionality Fsmt.
1. LS: The LS generates and distributes master keys mk{i,j}
for all servers in the system. It also generates a secret key
K for a joint public key L.
It uses the master keys to
compute the initial key share K0 of K for LS, as well as
its initial blinding seeds s{0,j}. The key share and blind-
ing seeds are kept in the initial state of LS, the master
keys mk{0,j} are written to the backup tape.
• On input (INIT, sid ), check that sid = (LS,S1, . . . ,
Sn, sid(cid:48)) for his own identity LS and server identities
S1, . . . ,Sn.
• For all 0 ≤ i < j ≤ n, choose a master key mk{i,j} ←R
{0, 1}κ. The master key mk{i,j} will be known only to
servers Si and Sj, so that each pair of servers {i, j} ⊆
{0, . . . , n} will have a common master key that is un-
known to the other servers.
Si by providing input
(mk{i,j})n
µ{0,j}) ← PRG(mk{0,j}).

• For i = 1, . . . , n, securely send (mk{i,j})n
j=0,j(cid:54)=i) to Fsmt for i = 1, . . . , n.

• For all j = 1, . . . , n, compute (mk(cid:48)
{0,j}, δ{0,j}, s{0,j},
• Choose K ←R Zq and set L ← gK . Compute K0 ←
• Initialize BUSY , USED 0, and the password hash ta-
ble PH as empty associative arrays and store st 0 =
(K0, (s{0,j})n
j=1, L, PH , BUSY , USED 0) as
initial state and store backup0 ← (K0, (mk(cid:48)
j=1, L,
PH ) on the backup tape.

j=0,j(cid:54)=i to server
(SEND, (LS,Si, sid ),LS,Si,

K +(cid:80)n

j=1 δ{0,j} mod q.

j=1, (µ{0,j})n

{0,j})n

Si:

−−−−−−−−−→

u, ch

vi ← uKi · βi,0
ri ←R Zq
R1,i ← gri · βi,1
←−−−−−−−−− R2,i ← uri · βi,2
vi, R1,i, R2,i
−−−−−−−−−→ Check C(c) = ch
si←−−−−−−−−− si ← Kic + ri + βi,3 mod q

c

LS:
N ←R Zq
u ← H(uid, pwd)N
c ←R Zq , ch ← C(c)
v0 ← uK0 · β0,0
r0 ←R Zq
R1,0 ← gr0 · β0,1
R2,0 ← ur0 · β0,2
s0 ← K0c + r0

v ←(cid:81)n
R1 ←(cid:81)n
s ←(cid:80)n

+ β0,3 mod q
i=0 v1/N

i=0 R1,i, R2 ←(cid:81)n

i

i=0 si mod q

i=0 R2,i

If gs = LcR1 and us = vN cR2 then PH [uid] ← G(uid, pwd, v)

Figure 4: The account creation protocol. All com-
munication between LS and Si is integrity-protected
with a MAC key µ{0,i}. See the text for more infor-
mation on the blinding factors βi,k.

2. Si: Each server stores the received master keys mk{i,j}

in backup memory and derives the initial state for Si.
• Upon input (SENT, (LS,Si, sid ),LS, (mk{i,j})n
from Fsmt, for all j = 0, . . . , n, j (cid:54)= i, compute (mk(cid:48)
δ{i,j}, s{i,j}, µ{i,j}) ← PRG(mk{i,j}).

• Compute the initial key share as Ki ← (cid:80)n

j=0,j(cid:54)=i ∆i,j
• Initialize USED i as an empty associative array and
j=0,j(cid:54)=i, µ{0,i}, USED i) as ini-
j=0,j(cid:54)=i)

δ{i,j} mod q, where ∆i,j is as deﬁned above.
store st i ← (Ki, (s{i,j})n
tial state and store backupi ← (Ki, (mk(cid:48)
on the backup tape.

j=0,j(cid:54)=i)
{i,j},

{i,j})n

Account creation. To create an account for user uid with
password pwd, the LS runs the following protocol with all
n servers S1, . . . ,Sn:
1. LS: The LS sends a blinded password hash and a chal-
lenge hash to all servers.
• On input (CREATE, sid , ssid , uid , pwd), check whether
PH [uid ], BUSY [uid ] or USED 0[ssid ] is already deﬁned.
If so, abort. Else, set and store BUSY [uid ] ← 1 and
USED 0[ssid ] ← 1. (Note that we already assumed that
servers check that ssid is locally unique, but since it is
crucial for the security of our protocol, we make these
checks explicit here.)
• Generate a random nonce N ←R Zq and a random
challenge c ←R Zq . Compute u ← H(uid , pwd)N and
ch ← C(c).

• Send (ssid , u, ch) to all servers for i = 1, . . . , n.
• Store (uid , pwd, N , u, c) associated with ssid .

2. Si: Each server sends a blinded response using its secret
key share and the blinded ﬁrst move of a zero-knowledge
proof.
• On input (PROCEED, sid , ssid ) from the environment and
after having received (ssid , u, ch) from LS, check that
USED i[ssid ] is undeﬁned. If not, abort.
set and store USED i[ssid ] ← 1.

• Compute vi ← uKi ·(cid:81)n
• Compute R1,i ← gri ·(cid:81)n
R2,i ← uri ·(cid:81)n

j=0,j(cid:54)=iB1(s{i,j}, ssid )∆i,j and
B2(s{i,j}, ssid )∆i,j where ri ←R Zq .

j=0,j(cid:54)=i B0(s{i,j}, ssid )∆i,j and

j=0
j(cid:54)=i

188(mk(cid:48)

LS:
For 0 ≤ i < j ≤ n do mk{i,j} ←R {0, 1}κ
For j = 1, . . . , n do
{0,j}, δ{0,j}, s{0,j}, µ{0,j}) ← PRG(mk{0,j})
K ←R Zq , L ← gK , PH , BUSY , USED 0 ← empty
backup0 ← (K0, (mk(cid:48)
st 0 ← (K0, (s{0,j})n

K0 ← K +(cid:80)n

{0,j})n
j=1, (µ{0,j})n

j=1 δ{0,j} mod q

j=1, L, PH )

j=1, L, PH , BUSY , USED 0)

(mk{i,j})n
j=0,j(cid:54)=i
−−−−−−−−−−−−−→

Si:

{i,j}, δ{i,j}, s{i,j}, µ{i,j}) ← PRG(mk{i,j})

(mk(cid:48)

Ki ←(cid:80)n

For j = 0, . . . , n, j (cid:54)= i do
USED i ← empty
backupi ← (Ki, (mk(cid:48)
st i ← (Ki, (s{i,j})n

j=0,j(cid:54)=i ∆i,j δ{i,j} mod q
j=0,j(cid:54)=i)

{i,j})n

j=0,j(cid:54)=i, µ{0,i}, USED i)

Figure 3: The initialization protocol. All communication takes place via Fsmt.

• Respond by sending (ssid , vi, R1,i, R2,i) to LS.
• Store (ri, ch) associated with ssid .

i=1).

mod q.

3. LS: The LS sends the challenge for the zero-knowledge
proof.
• After having received (ssid , vi, R1,i, R2,i) from servers
S1, . . . ,Sn, retrieve (uid , pwd, N , u, c) associated with
ssid . Abort if it doesn’t exist.
• Update the information stored with ssid to (uid , pwd,
• Send (ssid , c) to all servers S1, . . . ,Sn.

N , u, c, (vi, R1,i, R2,i)n

mation associated to ssid .

sociated with ssid . Abort if it doesn’t exist.

4. Si: Each server checks the challenge hash from the pre-
vious round and sends the blinded last move of a zero-
knowledge proof.
• When receiving (ssid , c) from LS, retrieve (ri, ch) as-
• If C(c) (cid:54)= ch, abort.

• Compute si ← Kic + ri +(cid:80)n

j=0,j(cid:54)=i ∆i,jB3(s{i,j}, ssid )
• Respond by sending (ssid , si) to LS. Remove all infor-
5. LS: The LS veriﬁes aggregated server responses through
the zero-knowledge proof and computes ﬁnal password
hash.
• After having received (ssid , si) from all servers S1, . . . ,
i=1) stored

Sn, retrieve (uid , pwd, N , u, c, (vi, R1,i, R2,i)n
for ssid . Abort if it doesn’t exist.

• Compute v0 ← uK0 ·(cid:81)n
r0 ←R Zq , compute R1,0 ← gr0 ·(cid:81)n
and R2,0 ← ur0 ·(cid:81)n
s0 ← K0c + r0 +(cid:80)n
, R1 ← (cid:81)n
• Compute v ← (cid:81)n
i=0 R2,i, and s ←(cid:80)n
(cid:81)n

j=1 B0(s{0,j}, ssid ). Choose
j=1 B1(s{0,j}, ssid )
j=1 B2(s{0,j}, ssid ). Also compute
j=1 ∆i,jB3(s{0,j}, ssid ) mod q.
i=0 v1/N

i=0 R1,i, R2 ←
• Verify that gs = LcR1 and us = vN cR2; if not, set
BUSY [uid ] to undeﬁned in the state information and
abort.
• Store PH [uid ] ← G(uid , pwd, v) as the password hash
• Remove all information associated to ssid .

for uid and output (CREATEOK, sid , ssid ).

i
i=0 si mod q.

Login request. The login protocol is a simpliﬁed version
of account creation, without zero-knowledge proof.
1. LS: The LS sends a blinded password hash to all servers.
• Upon input (LOGIN, sid , ssid , uid , pwd(cid:48)), ﬁrst check that
PH [uid ] is deﬁned and USED 0[ssid ] is not deﬁned.
Abort otherwise.

• Set and store USED 0[ssid ] ← 1.
• Generate a random nonce N ←R Zq and compute u ←
H(uid , pwd(cid:48))N . Send (ssid , u) to all servers S1, . . . ,Sn.

LS:
N ←R Zq
u ← H(uid, pwd(cid:48))N
v0 ← uK0 · β0,0
i=0 v1/N

v ←(cid:81)n

i

Si:

u

−−−−−−−−−→
vi←−−−−−−−−−

vi ← uKi · βi,0

If PH [uid] = G(uid, pwd(cid:48), v) then accept else reject

Figure 5: The login protocol. All communication be-
tween LS and Si is integrity-protected with a MAC
key µ{0,i}. See the text for more information on the
blinding factors βi,k.

• Store (uid , pwd(cid:48), N , u) associated with ssid .

2. Si: Each server sends a blinded response using its secret
key share.
• On input (PROCEED, sid , ssid ) from the environment and
after receiving (ssid , u) from LS, ﬁrst check whether
USED i[ssid ] = 1. If so, abort.
set and store USED i[ssid ] ← 1.

• Compute vi ← uKi ·(cid:81)n

j=0,j(cid:54)=i B0(s{i,j}, ssid )∆i,j and

• Respond by sending (ssid , vi) to LS.

3. LS: The LS veriﬁes the re-computed ﬁnal password hash

• Compute v0 ← uK0 ·(cid:81)n
(cid:81)n

against the stored password.
• After having received (ssid , vi) from all servers S1, . . . ,
Sn, retrieve (uid , pwd(cid:48), N , u) associated to ssid . Abort
if it doesn’t exist.
j=1 B0(s{i,j}, ssid )∆i,j ) and v ←
• If PH [uid ] = G(uid , pwd(cid:48), v), then set pwdok ← 1, else
• Output (RESULT, sid , ssid , pwdok ) and delete the stored

i=0 v1/N
.
pwdok ← 0.
tuple (uid , pwd(cid:48), N , u) for ssid .

i

Timeout. The LS interrupts a creation or login protocol.

LS:
• Upon input (TIMEOUT, sid , ssid ), retrieve record (uid ,
• If ssid is an unﬁnished account creation, set BUSY [uid ]
to undeﬁned and delete all information stored for ssid .
• If ssid is an unﬁnished login, then delete all information

pwd, . . .) for ssid .

stored for ssid .

Refresh. Refresh is a non-interactive process where each
server has access to its backup memory. We assume that all
servers synchronize to refresh simultaneously, e.g., by per-
forming refreshes at regular time intervals, or by agreeing
on the timing through out-of-band communication.

189(mk(cid:48)

j=0,j(cid:54)=i, L, PH )

i ← Ki +(cid:80)n

{i,j}, δ{i,j}, s{i,j}, µ{i,j}) ← PRG(mk{i,j})

Si: ∈ {LS = S0, S1, . . . , Sn}
Let backupi = (Ki, (mk{i,j})n
For j = 0, . . . , n, j (cid:54)= i do
K (cid:48)
PH (cid:48) ← PH
Let PH (cid:48)(cid:48) be as in st 0
For all uid where PH [uid] = ⊥ and PH (cid:48)(cid:48)[uid] (cid:54)= ⊥ do

j=0,j(cid:54)=i δ{i,j} mod q

i , (mk(cid:48)

PH (cid:48)[uid] ← PH (cid:48)(cid:48)[uid]
i ← (K (cid:48)
{i,j})n
, BUSY ← empty
i , (s{i,j})n

backup(cid:48)
USED i
i ← (K (cid:48)
st(cid:48)
L, PH (cid:48), BUSY , USED i)

j=0,j(cid:54)=i , L, PH (cid:48) )

j=0,j(cid:54)=i, µ{0,i}

(µ{0,j})n

j=1 ,

Figure 6: The refresh protocol. Items in dark gray
apply to Si = S0 = LS only, items in light gray apply
to Si (cid:54)= S0 only.

{i,j})n

j=0,j(cid:54)=i).

1. Si ∈ {LS = S0,S1, . . . ,Sn}: Based on the backup backupi
and the current state st i, Si computes its new state st(cid:48)
i.
• If Si = LS, on input (REFRESH, sid ) recover the backup
j=1, L, PH ) and obtain
• If Si ∈ {S1, . . . ,Sn}, recover the backup backupi = (Ki,
• For all j = 0, . . . , n, j (cid:54)= i compute (mk(cid:48)

tape backup0 = (K0, (mk{0,j})n
the password hashes PH (cid:48)(cid:48) from st 0.
(mk(cid:48)
{i,j}, δ{i,j},
s{i,j}, µ{i,j}) ← PRG(mk{i,j}) and compute the new
key share K (cid:48)
• If Si = LS, ﬁrst set PH (cid:48) ← PH . For all uid that were
newly created during the past epoch, set PH (cid:48)[uid ] ←
j=1, L, PH (cid:48))
PH (cid:48)(cid:48)[uid ]. Store backup(cid:48)
and set the new state st(cid:48)
j=1, (µ{0,j})n
j=1,
L, PH (cid:48), BUSY , USED 0).
i ←
• If Si ∈ {S1, . . . ,Sn}, store the new backup backup(cid:48)
i ←
j=0,j(cid:54)=i) and set the new state to st(cid:48)
(K (cid:48)
(K (cid:48)

i ← Ki +(cid:80)n

0, (mk(cid:48)
0, (s{0,j})n

0 ← (K (cid:48)
0 ← (K (cid:48)

j=0,j(cid:54)=i δ{i,j} mod q.

j=0,j(cid:54)=i, µ{0,i}, USED i).

{0,j})n

{i,j})n

i , (mk(cid:48)
i , (s{i,j})n
4.2 Security

The security properties of our ﬁrst construction are sum-

marized in the following theorem.

Theorem 4.1. If the gap one-more Diﬃe-Hellman assump-
tion holds in G, PRG is a secure pseudo-random genera-
tor, and MAC is an unforgeable MAC, then the protocol
π of Section 4 securely implements the functionality F in
the (Fsmt,Fro)-hybrid model. For any polynomial-time al-
gorithms E,A, there exist polynomial-time algorithms SIM
and B,B1,B2 such that

(cid:12)(cid:12)(cid:12) ≤ nen2 · AdvprB1,PRG(κ)

(cid:12)(cid:12)(cid:12)RealπE,A(κ) − Ideal

F
E,SIM

+ Advgomcdh

B,G

(κ) + nen · Advufcma

B2,MAC(κ)

+

7(qro + nqc + ql)2

22κ

+

2n2ne(qro + n2ne)

2κ

.,

where n, ne, qro, qc, ql are the number of back-end servers,
epochs, random-oracle queries, account creation sessions,
and login sessions, respectively.

As mentioned earlier, the Cheon attack [8] on the (gap)
one-more Diﬃe-Hellman assumption potentially reduces se-

√

d) if the adversary is given gxd
.
curity with a factor O(
For our construction, we have that d ≤ qc + ql, so it would
be advisable to use a group order q that is log(qc + ql) bits
longer than usual to compensate for the attack.
Due to space limitations, we only sketch the simulator
SIM for the above theorem and the reduction from the
gap one-more Diﬃe-Hellman problem.

Simulator

4.2.1
The simulator interacts as adversary with the functional-
ity F and internally runs simulated versions “LS”,“S1”, . . . ,
“Sn” of all honest servers against the real-world adversary
A, who also plays the role of all corrupt servers.

Initialization.

K = (cid:80)n

The initialization procedure takes place in a trusted envi-
ronment and hence is completely under control of the sim-
ulator SIM. It generates the initial keys so that it knows
i=0 Ki mod q and sets L ← gK . Rather than gen-
erating blinding seeds s{i,j} and MAC keys µi through the
pseudo-random generator PRG, SIM chooses them truly at
random. Values are assigned consistently across machines,
though, in the sense that if diﬀerent machines Si,Sj use the
same master key mk{i,j} to derive a value, then the same
random value will be assigned in both cases. The simulation
is aborted whenever an honest login server “LS” receives a
network message for which the MAC tag veriﬁes correctly
under µi but that was never sent by “Si” and vice versa.

Random Oracles.

SIM simulates random oracles B0, . . . , B3, C by return-
ing random values from the appropriate ranges, storing the
values in tables for consistency.
It responds to random-
oracle queries H(uid , pwd) so that it knows the discrete log-
arithm of all responses, i.e., choosing HTL[uid , pwd] ←R
Zq and returning HT[uid , pwd] ← gHTL[uid,pwd]. Random-
oracle queries G(uid , pwd, v) are answered with the help of
the PWDGUESS interface; we provide details in a moment. The
simulator aborts when a collision is detected between out-
puts of C, H, or G.

Account creation.
The simulator executes simulated versions of all honest
back-end servers “S1”, . . . ,“Sn” by following the real proto-
col after receiving (PROCEED, sid , ssid ,Si) from F. It can do
so because it knows all of the relevant secrets K1, . . . , Kn
and s{i,j}. If LS is corrupt and A delivers (ssid , u) to an
honest server “Si” for a new ssid , then SIM sends (CREATE,
sid , ssid , uid = ⊥, pwd = ⊥) to F on behalf of LS and
(PROCEED, sid , ssid ) on behalf of all corrupt servers Si ∈ C.
To simulate the honest “LS”, however, it must perform
an honest-looking protocol without knowing the actual pass-
word. When SIM receives (CREATE, sid , ssid , uid ) from F,
SIM uses u ← gN in the ﬁrst round. If at the end of the
i=0 vi (cid:54)=
−c
i = R2,
i=0 vi = uK , then it it assigns a random value as pass-
word hash PH [uid ] ←R {0, 1}2κ and sends (CREATEOK, ssid ,
sid , uid ) to F.
To make sure that the password hash looks correct when
LS gets corrupted, it answers A’s queries G(uid , pwd, v) as
follows. If v (cid:54)= H(uid , pwd)K , then it simply returns a ran-

protocol gsL−c = R1 and us(cid:81)n
uK , then SIM aborts. If gsL−c = R1, us(cid:81)n
and(cid:81)n

i = R2 but(cid:81)n

i=0 v

i=0 v

−c

190If v = H(uid , pwd)K , then SIM decreases a
dom value.
counter guesses that mirrors the counter maintained by F,
i.e., it is initially zero, is increased each time the last honest
server in a subsession ssid receives (PROCEED, sid , ssid ,Si),
and is set to inﬁnity when all servers get corrupted in the
same epoch. If guesses < 0, then SIM aborts the simula-
tion and gives up; we will later show how this event gives
rise to solving the gap one-more Diﬃe-Hellman problem. If
guesses ≥ 0, it sends (PWDGUESS, sid , uid , pwd) to F to ob-
tain a response (PWDGUESS, sid , uid , pwdok ). If pwdok = 1,
then it returns PH [uid ] as hash output, else it returns a
random value.

whether (cid:81)n

exponent K in (cid:81)n

Login.
Login protocols for a corrupt LS are simulated similarly
as account creations above: SIM sends (LOGIN, sid , ssid ,
uid = ⊥, pwd = ⊥) to F whenever the ﬁrst honest server
“Si” receives a message for a protocol ssid , and otherwise
runs the honest code of Si.
Login protocols with an honest LS are simulated diﬀer-
ently depending on whether the account for uid was created
when LS was honest or corrupt. In the ﬁrst case, the value
PH [uid ] may not be assigned to any output G(uid , pwd, v)
yet, but we are sure that at the time of account creation,
the corrupt servers (if any) behaved “honestly overall”, in the
sense that they did not aﬀect the computation of the overall
i=0 vi = uK , because the zero-knowledge
proof was veriﬁed by the honest “LS”. Since there is no such
proof during login, real-world corrupted servers can use a
diﬀerent overall exponent K (cid:48), causing LS to conclude that
the password was false even though it was correct. The sim-
ulator forces the same outcome in the ideal world by setting
the fail ﬂag in the RESULT interface. Namely, it lets “LS”
use u ← gN and, after having received all values vi, checks
i=0 vi = uK . If so, it sets fail ← 0, otherwise it
sets fail ← 1.
In the second case, the password hash PH [uid ] was stored
by a corrupt LS.
If there is no registered output G(uid ,
pwd, v) = PH [uid ], then for a successful login to take place,
A must “predict” an output of G, which can happen only
with negligible probability. In this case, “LS” runs the pro-
tocol using u ← gN but always sets fail ← 1 at the end. If
there is one (and only one, as SIM aborts on collisions) out-
put G(uid , pwd, v) = PH [uid ], then we still cannot be sure
that v = H(uid , pwd)K . The corrupt LS could for exam-
ple have stored PH [uid ] = G(uid , pwd, v) = H(uid , pwd)K(cid:48)
for K (cid:48) (cid:54)= K , and during login, corrupt servers Si could bias
the overall exponent to K (cid:48) again, causing the honest LS to
recompute v(cid:48) = v and conclude that login succeeded. For
any other overall exponent, however, login must fail, even
if the correct password was used. The simulator therefore
lets “LS” perform the honest protocol with the correct pass-
word pwd, which it knows from the entry in GT, and checks
whether the recomputed value is equal to v. If not, it sets
fail ← 1, otherwise it sets fail ← 0.

Corruption.
When A transiently corrupts a back-end server Si, SIM
can hand over the full state of Si as it knows all the secret
keys and subsession states. When it corrupts LS, SIM
knows the long-term state st 0 = (K (cid:48)
j=1,
L, PH (cid:48), BUSY , USED 0), but does not necessarily know the
state of ongoing subsessions that contain the password pwd

j=1, (µ{0,j})n

0, (s{0,j})n

and the nonce N such that u = H(uid , pwd)N . It obtains the
actual passwords for all ongoing protocols (CORRUPT, sid , L)
from F. It can then compute simulated nonces N(cid:48) for the
correct password using the discrete logarithms of H(uid , pwd)
stored in HTL.
When A permanently corrupts a server Si ∈ {LS = S0,
S1, . . . ,Sn}, it additionally chooses master keys mk{i,j} ←R
{0, 1}κ for j = 0, . . . , n, j (cid:54)= i, to simulate the contents of
the backup tape backupi.

Refresh.
When the environment instructs all (non-permanently-
corrupted) servers to refresh, the simulator SIM computes
(mk{i,j}, δ{i,j}, s{i,j}, µ{i,j}) ← PRG(mk{i,j}) for all servers
i = 0, . . . , n and all permanently corrupted servers Sj ∈
PC, where mk{i,j} are the values given to A as part of the
backup tape when Sj was permanently corrupted. For all
other servers Sj (cid:54)∈ PC, SIM chooses random values for
δ{i,j}, s{i,j}, µ{i,j}. It otherwise computes the new state of
Si as in the real protocol.
For all new entries uid that were added to the ﬁnal state
PH (cid:48) of a corrupt LS but were not yet deﬁned at the begin-
ning of the epoch, SIM checks whether there exists an out-
put G(uid , pwd, v) = PH (cid:48)[uid ], setting pwd ← ⊥ if not. The
simulator registers a new account for each such uid by send-
ing (CREATE, sid , ssid , uid , pwd) and (CREATEOK, sid , ssid ) to
F for a fresh ssid .
4.2.2 Reduction from Gap One-More DH
Suppose we are given an adversary A and an environment
E that cause the event guesses < 0 to occur, where guesses
is initially zero, is decreased at each random-oracle query
G(uid , pwd, v) with v = H(uid , pwd)K , is increased for each
protocol session ssid where all honest servers participate,
and is set to inﬁnity when all servers are corrupted in the
same epoch. We show how such E,A give rise to a solver B
for the gap one-more Diﬃe-Hellman problem.
Algorithm B is given input (g, X) and has access to oracles
T, CDH, and DDH. It sets L ← X, thereby implicitly set-
i=0 Ki = x, and answers random-oracle queries
H(uid , pwd) with target points generated by its T oracle.
It only ﬁxes values of the individual Ki and blinding seeds
s{i,j} at the moment that Si gets corrupted, however, avoid-
ing that B has to guess a server that will remain uncorrupted
in the next epoch. Note that B never needs to simulate val-
ues for Ki for all servers within the same epoch, because
then the event guesses < 0 cannot occur.

ting K =(cid:80)n

Account creation.
When E instructs an honest LS to create an account uid
with password pwd, B ﬁrst LS honestly perform step 1 of the
real protocol, but it lets all honest servers Si choose random
values for vi, Ri,1, Ri,2, si. These are correctly distributed
because, if at least one of S1, . . . ,Sn is honest, then at least
one of the blinding factors Bk(s{i,j}, ssid ) remains unknown
to A, and if all S1, . . . ,Sn are corrupt, then v0, R0,1, R0,2
remains internal to the honest LS anyway. Only when Si
later gets corrupted will we program the random oracles Bk
so that these responses make sense. The LS cannot verify
the zero-knowledge proof as usual, but, because it previously
assigned values to the secrets Ki and s{i,j} of corrupt servers
Si ∈ C = PC ∪ TC, it can check whether they behaved
“honestly overall”, meaning, in a way that would have made

191the zero-knowledge proof work out if the honest Si would
have responded correctly. If so, then LS accepts the creation
but stores a random string in PH [uid ].
When A later makes a query G(uid , pwd(cid:48), v(cid:48)) with v(cid:48) =
H(uid , pwd(cid:48))x, which B can test using its DDH oracle, then B
decreases guesses and adds (H(uid , pwd(cid:48)), v(cid:48)) to a set Sol of
CDH solutions. If pwd(cid:48) is the password pwd used at creation
for uid , then B responds with PH [uid ], otherwise it returns
a random string.
If a corrupt LS initiates an account creation, then the
honest servers Si ∈ C = {LS,S1, . . . ,Sn} \ C must behave
“honestly overall” to ensure that LS computes the correct
value v = H(uid , pwd)K and a correct zero-knowledge proof
if it chooses to follow the protocol honestly. They do so by
returning random values vi, except for the last honest server
to respond Sl, where B increases guesses and uses one query
to its CDH oracle to compute a response vl so that

(cid:89)

Si∈C

(cid:89)
(cid:89)

Si∈C

uκi
i

uκi
i

n(cid:89)
(cid:89)

Sj =1,j(cid:54)=i

vi =

B(s{i,j}, ssid )∆i,j

=

B(s{i,j}, ssid )∆i,j

Si∈C

Sj∈C

for some random exponents κi ∈ Zq so that (cid:80)
(cid:80)
Si∈C κi +
Si∈C Ki = x mod q, where ui is the value for u that Si
received in subsession ssid . It simulates the zero-knowledge
proof for honest Si in a similar way, choosing random values
for R1,i, R2,i, si except for the last server, where B uses a
simulated zero-knowledge proof using the challenge ci that
it can look up from a response C(ci) = ch i.

Login.
When E instructs the honest LS to perform a login with
password pwd(cid:48) for account uid that was created by an honest
LS with password pwd, B lets LS run the honest protocol
with uid , pwd(cid:48), but lets honest Si return random values vi.
At the end, LS checks whether the corrupt servers behaved
honestly overall as deﬁned earlier. If so, and pwd(cid:48) = pwd,
then LS outputs pwdok = 1, else it outputs pwdok = 0. The
LS proceeds similarly for accounts uid created by a corrupt
LS if there exists no output G(uid , pwd, v) = PH [uid ], or
if such output exists but pwd (cid:54)= pwd(cid:48). At the end of the
protocol, however, it always outputs pwdok = 0.
For an account created by a corrupt LS with an existing
entry G(uid , pwd, v) = PH [uid ] with pwd = pwd(cid:48), things
are slightly more complicated because, as explained for the
simulator above, we cannot be sure that v = H(uid , pwd)K ,
yet login may still succeed if corrupt servers Si ∈ C apply
the same bias to the overall exponent during login as during
account creation. The LS detects whether a real protocol
would have reconstructed v(cid:48) = v by checking whether

n(cid:89)
(cid:18) (cid:89)

i=0

(cid:18) (cid:89)

vi · (cid:89)
vi · ux−(cid:80)Si∈C Ki (cid:89)
(cid:89)

Si∈C

Si∈C

=

v1/N
i

vi

v =

=

(cid:19) 1

N

Si∈C

Si∈C

Sj∈C

(cid:19) 1

N

B(s{i,j}, ssid )∆i,j

Note that here too, B will make one CDH oracle query to
compute the last honest server’s response for each ssid .

·(cid:81)n

Corruption and refresh.
If A corrupts all servers during the same epoch, guesses
gets set to inﬁnity, so B can abort without aﬀecting its suc-
cess probability. When A transiently corrupts Si, B chooses
a random key Ki and random blinding seeds (s{i,j})n
j=0,j(cid:54)=i,
and programs the entries Bk(s{i,j}, ssid ) of all previous sub-
sessions ssid so that the previous responses make sense,
j=0,j(cid:54)=i B0(s{i,j}, ssid ). As A
i.e., so that vi = uKi
i
cannot corrupt all servers, there is at least one seed s{i,j}
that is unknown to A, so that B can program the entries
B0(s{i,j}, ssid ) to satisfy the above equation.
It proceeds
similarly for the values R1,i, R2,i, si in account creation pro-
tocols. For ongoing account creation protocols, B addi-
tionally chooses ri ←R Zq and programs B1, B2 so that
gs(cid:48)
i =
vci
=
i
j=0,j(cid:54)=i ∆i,jB3(s{i,j}, ssid ) mod q, so that it can hand
ri to A as part of the state of Si.
When A permanently corrupts Si, then B additionally
chooses random master keys mk{i,j} for all j = 0, . . . , n,
j (cid:54)= i, to simulate the backup tape of Si. When a non-
permanently-corrupted server Si is refreshed, B takes back
control of Si and forgets all previously chosen values for Ki
and s{i,j}.

(cid:81)n
j=0,j(cid:54)=i B1(s{i,j}, ssid )−∆i,j and us(cid:48)
s(cid:48)

(cid:81)n
j=0,j(cid:54)=i B2(s{i,j}, ssid )−∆i,j , where

si −(cid:80)n

i = gciKi · R1,i

· R2,i

i

i

CDH solutions.

When the event guesses < 0 occurs, B just added one
more CDH solution to Sol than the number of times that
it invoked its CDH oracle. Indeed, B only invokes the CDH
oracle only once for each account creation or login protocol
with a corrupt LS where all honest servers participate. The
counter guesses is increased immediately before B invokes
its CDH oracle and is only decreased when a valid CDH
solution is detected in a G(·) query. Therefore, B wins its
game by returning Sol .

5. CONSTRUCTION WITH PAIRINGS

We now present an even more eﬃcient scheme based on
pairings.
It is almost identical to the discrete-logarithm
scheme, except that the interactive zero-knowledge proof is
replaced by a pairing computation by LS.

Let G1, G2, Gt be multiplicative groups of prime order
q with generators g1, g2, gt, respectively, and an eﬃciently
computable pairing function e : G1 × G2 → Gt. Let H :
{0, 1}∗×{0, 1}∗ → G1, G : {0, 1}∗×{0, 1}∗×G1 → {0, 1}2κ,
and B0 : {0, 1}κ × N → G1 be hash functions modeled as
random oracles.
Initialization, login, timeout, and refresh are identical to
the discrete-logarithm scheme, except that L ← gK
2 and
that group operations during login take place in G1. Ac-
count creation is considerably simpler, as the two-round
zero-knowledge protocol is now replaced with a pairing com-
putation, as depicted in Figure 7.

which B can test using its DDH oracle. If so, then LS out-
puts pwdok = 1, otherwise it outputs pwdok = 0.
Login protocols with a corrupt LS are simulated similarly
as account creation, but without the zero-knowledge proof.

Account creation. To create an account for user uid with
password pwd, the LS runs the following protocol with all
n servers S1, . . . ,Sn:
1. LS: The LS sends a blinded password hash to all servers.

192LS:
N ←R Zq
u ← H(uid, pwd(cid:48))N
v0 ← uK0 · β0,0
i=0 v1/N

v ←(cid:81)n

i

Si:

u

−−−−−−−−−→
v←−−−−−−−−−

vi ← uKi · βi,0

6

Si

?
S (0)

i

If e(v, g2) = e(H(uid, pwd), L)
Then PH [uid] ← G(uid, pwd, v)

¯Si



6

6

?
?
S (j)
. . . S (j−1)
Cloud Platform

i

i

6

. . .

Internet

Demilitarized Zone

Figure 7: The account creation protocol for the
pairing-based scheme.

Figure 8: The diﬀerent components of server Si.

• On input (CREATE, sid , ssid , uid , pwd), check if PH [uid ],
If so,

BUSY [uid ] or USED 0[ssid ] is already deﬁned.
abort.

• Set BUSY [uid ] ← 1 and USED 0[ssid ] ← 1.
• Compute u ← H(uid , pwd)N and send (ssid , epoch 0, u)
• Store (uid , pwd, N , u) associated with ssid .

to all servers Si for i = 1, . . . , n.

2. Si: Each server sends a blinded response using its secret
key share.
• On input (PROCEED, sid , ssid ) from the environment,
and after having received (ssid , epoch 0, u) from LS,
check whether USED i[ssid ] = 1 or epoch 0 (cid:54)= epoch i.
If so, abort.
USED[ssid ] ← 1.

• Compute vi ← uKi ·(cid:81)n

j=0,j(cid:54)=i B(s{i,j}, ssid )∆i,j and set

• Respond by sending (ssid , vi) to LS.

3. LS: The LS veriﬁes the server contributions and com-
putes ﬁnal password hash.
• After having received (ssid , vi) from Si for all i = 1, . . . ,
n, retrieve (uid , pwd, N , u) stored for ssid . Abort if it
doesn’t exist.
j=1 B(s{0,j}, ssid )∆0,j and v ←

• Compute v0 ← uK0 ·(cid:81)n
(cid:81)n

BUSY [uid ] to undeﬁned and abort.

• Verify that e(v, g2) = e(H(uid , pwd), L);
if not, set
• Store PH [uid ] ← G(uid , pwd, v) as the password hash
• Remove all information associated to ssid .

for uid and output (CREATEOK, sid , ssid ).

i=0 v1/N

i

.

Theorem 5.1. If the one-more Diﬃe-Hellman assumption
holds in (G1, G2), then the protocol π in Section 5 securely
realizes the functionality F in the (Fsmt,Fro)-hybrid model.

6. DEPLOYMENT OF OUR SCHEME

As discussed, our scheme requires the initialization to be
run in a trusted execution environment and, to warrant the
diﬀerence between transient and permanent corruptions, re-
quires the backup tape to be better protected from attacks
than normal state information.

The initialization could be run on a single trusted machine
who then distributes the keys to the other servers, e.g., by
smart cards which then can also act as backup tapes. A bet-
ter alternative seems to make use of cloud platforms which
will make it also easier to recover from corruption by starting
a fresh virtual machine. We discuss this in the following.

The features of modern cloud computing platforms such as
Openstack [23] can be nicely exploited to realize proactive
security for protocols. Such platforms oﬀer strong separa-
tion between the virtual machines that are exposed to the

Internet, and are thus subject to attacks, and the cloud man-
agement interfaces that run in a protected, de-militarized
zone. New virtual machines can be created on the ﬂy from
images, machines can be shut down, and the routing of traf-
ﬁc to machines be dynamically conﬁgured. The platforms
also virtualize the storage for the virtual machines, i.e., they
oﬀer diﬀerent kinds of abstraction of hard-disks such as ﬁle
system, block store, object store, etc. The management of
all of this is typically a manual process via a web interface
in the de-militarized zone, but can easily be automated with
scripts, which is how it should be done for our protocol.

i

i

i

i

,S (j)

, . . . ,S (j−1)

The main idea to implement our scheme in this setting
is that each server is realized with its own cloud platform
(cf. Figure 8). Thus, each server Si (and analogously LS)
consists of a cloud platform, a number of virtual machines
S (0)
, . . . that are run on the cloud platform
on a (physical) machine ¯Si. The cloud platform is usually
a single physical machine or a cluster of them. The virtual
machines are exposed to the internet while the cloud plat-
form and ¯Si are run in the de-militarized zone, i.e., in a
protected environment.

For each epoch j, a fresh virtual machine S (j)

is started on
the cloud platform. These virtual machines run the account
creation and the login protocols and access their states from
the virtual storage provided by the cloud platform.
The machine ¯Si controls the cloud platform, maintains
the images for the virtual machines S (j)
, and prepares the
state (storage) that is given to each S (j)
in order for them
to run the account creation and the login request protocols.
Indeed, ¯Si needs to be connected only to the cloud soft-
ware platform and in practice such connections are typically
physically isolated. To prepare the state for the S (j)
’s, the
machine ¯Si runs the initialization protocol, which requires
LS to securely send a message to each of the Si’s. As this is
a one-time event that will be part of setting up the overall
system, this communication can for instance be realized by
writing the messages to a physical medium such as a USB
drive and distribute it by courier. In fact, the master keys
could even be written on paper and entered manually, as
each server in our protocol receives only n·κ bits, amounting
to about 18n alphanumeric (7-bit) characters for practical
scenarios with κ = 128. The master keys for Si are stored in
backup memory that is available to ¯Si but not to any of the
instances S (j)
. During refresh, ¯Si derives the initial state for
S (j)
for the next epoch from the master keys and updates
the master keys in the backup memory.

i

i

i

i

i

7.

IMPLEMENTATION

To demonstrate the practical feasibility and test the per-
formance of our protocols, we created a prototype imple-

193Table 1: Performance ﬁgures of our ﬁrst protocol
over the NIST P-256 elliptic curve.

# dedicated cores
S3

S2

n LS
2
1
1
4
8
1
16
1
16
1
16
2
3
16

S1
2
4
8
8
16
16
16

throughput
(logins/s) mean
94
71
53
90
50
59
53

delay (ms)
99%
155
111
79
153
86
94
85

40
80
157
214
310
293
285

16
16

16

mentation in Java. We implemented our ﬁrst construction
(without pairings) over the NIST P-256 elliptic curve using
SHA-256 as a hash function. All elliptic-curve operations are
performed using the Bouncy Castle cryptographic library.
We expect that performance can be considerably improved
by using other libraries or implementation languages.

We tested our implementation on a commercial cloud in-
frastructure for diﬀerent numbers of dedicated 2.9 GHz com-
puting cores for each server. Selected performance numbers
for login protocols, the most relevant operation, are sum-
marized in Table 1. Roughly, our prototype implementa-
tion handles about 20 logins per second and per server core
dedicated to the LS. The mean computation and commu-
nication delay incurred from the moment that LS receives
the request until it reaches a decision is always below 100
milliseconds, with a 99 percentile well below 200 ms, small
enough to not be noticeable to the user.
Since the LS performs two exponentiations in each login
protocol, versus only one for each Si, each Si takes slightly
more than half of the computational resources of the LS.
It would therefore make sense to assign more computational
power to the LS than to each Si. Because all servers Si
operate in parallel, increasing the number of servers n has
only a minor impact on the throughput and delays.

Acknowledgements
This work was supported by the European Commission’s
Seventh Framework Programme under the PERCY grant
(agreement #321310) and the FutureID project (agreement
#318424). We are very grateful to Daniel Kovacs and Franz-
Stefan Preiss for their work on the prototype implemen-
tation and performance testing, as well as for their valu-
able feedback. We would also like to thank Marc B¨utikofer,
Robin K¨unzler, Christoph Lucas, and Adrian Schneider for
their feedback and implementing our protocol at Ergon.

8. REFERENCES
[1] J. F. Almansa, I. Damg˚ard, J. B. Nielsen. Simpliﬁed
threshold RSA with adaptive and proactive security.
EUROCRYPT 2006.

[2] J. Brainard, A. Juels, B. S. Kaliski Jr., Michael

Szydlo. A new two-server approach for authentication
with short secrets. USENIX Security Symposium 2003.

[3] A. Bagherzandi, S. Jarecki, N. Saxena, Y. Lu.

Password-protected secret sharing. ACM CCS 2011.

[4] A. Boldyreva. Threshold signatures, multisignatures

and blind signatures based on the
gap-Diﬃe-Hellman-group signature scheme.
PKC 2003.

[5] Ran Canetti. Universally composable security: A new

paradigm for cryptographic protocols. FOCS 2001.
Full version on Cryptology ePrint Archive, Report
2000/067, 2000.

[6] J. Camenisch, R. R. Enderlein, G. Neven. Two-server

password-authenticated secret sharing UC-secure
against transient corruptions. PKC 2015.

[7] R. Canetti, U. Feige, O. Goldreich, M. Naor.

Adaptively secure multi-party computation. 28th
ACM STOC 1996.

[8] J. H. Cheon. Security analysis of the strong

Diﬃe-Hellman problem. EUROCRYPT 2006.

[9] J. Camenisch, A. Lehmann, A. Lysyanskaya, G.

Neven. Memento: How to reconstruct your secrets
from a single password in a hostile environment.
CRYPTO 2014, Part II.

[10] J. Camenisch, A. Lysyanskaya, G. Neven. Practical

yet universally composable two-server
password-authenticated secret sharing. ACM CCS
2012.

[11] C.-K. Chu, W.-G. Tzeng. Eﬃcient k-out-of-n oblivious

transfer schemes with adaptive and non-adaptive
queries. PKC 2005.

[12] M. Di Raimondo, R. Gennaro. Provably secure

threshold password-authenticated key exchange.
EUROCRYPT 2003.

[13] EMC Corporation. RSA distributed credential

protection. http://www.emc.com/security/
rsa-distributed-credential-protection.htm.

[14] Experian. 2015 Second annual data breach industry

forecast, 2015.

[15] W. Ford, B. S. Kaliski Jr. Server-assisted generation of

a strong secret from a password. WETICE 2000.

[16] Gemalto. 2014 Year of mega breaches & identity theft:

Findings from the 2014 breach level index, 2015.

[17] D. P. Jablon. Password authentication using multiple

servers. CT-RSA 2001.

[18] S. Jarecki, A. Kiayias, H. Krawczyk. Round-optimal

password-protected secret sharing and T-PAKE in the
password-only model. ASIACRYPT 2014, Part II.
[19] S. Jarecki, X. Liu. Fast secure computation of set

intersection. SCN 2010.

[20] B. Kaliski. PKCS #5: Password-based cryptography

speciﬁcation. IETF RFC 2898, 2000.

[21] J. Katz, P. D. MacKenzie, G. Taban, V. D. Gligor.

Two-server password-only authenticated key exchange.
ACNS 05.

[22] P. D. MacKenzie, T. Shrimpton, M. Jakobsson.

Threshold password-authenticated key exchange.
CRYPTO 2002.

[23] Openstack website. www.openstack.org.
[24] N. Provos, D. Mazi`eres. A future-adaptable password

scheme. USENIX Annual Technical Conference,
FREENIX Track, 1999.

[25] M. Szydlo, B. S. Kaliski Jr. Proofs for two-server

password authentication. CT-RSA 2005.

194