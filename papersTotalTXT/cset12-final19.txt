Towards a Framework for Evaluating BGP Security

Olaf Maennel†
Randy Bush?

Debbie Perouli§
Iain Phillips†
Rob Austein‡ Askar Jaboldinov†

†Loughborough University, UK
‡Dragon Research Labs, USA

?Internet Initiative Japan
§Purdue University, USA

Abstract

Security and performance evaluation of Internet pro-
tocols can be greatly aided by emulation in realistic de-
ployment scenarios. We describe our implementation of
such methods which uses high-level abstractions to bring
simplicity into a virtualized test-lab.

We argue that current test-labs have not adequately
captured those challenges, partly because their design is
too static. To achieve more ﬂexibility and to allow the
experimenter to easily deploy many alternative scena-
rios we need abstractions that allow auto-conﬁguration
and auto-deployment of real router and server code in a
multi-AS infrastructure. We need to be able to generate
scenarios for multi-party players in a fully isolated emu-
lated test-lab and deploy the network using virtualized
routers, switches, and servers.

In this paper, our abstractions are speciﬁcally de-
signed to evaluate the BGP security framework currently
being documented by the IETF SIDR working group.
We capture the relevant aspects of the SIDR security pro-
posals, and allow experimenters to evaluate the technol-
ogy in topologies of real router and server code. We be-
lieve such methods are also useful for teaching newcom-
ers and operators, as it allows them to gain experience
in a sand-box before deployment. It allows security ex-
perts to set up controlled experiments at various levels of
complexity, and concentrate on discovering weaknesses,
instead of having to spend time on tedious conﬁguration
tasks. Finally, it allows router vendors and implementers
to test their code and to perform scalability evaluation.

1 Introduction
The Border Gateway Protocol (BGP) [1] was not de-
signed with any concern for security and is therefore
quite vulnerable to attacks such as mis-originations of
preﬁxes (known as “route hijacks”), protocol attacks,
and accidental misconﬁguration [2–4]. Efforts have
been made to secure BGP [5, 6], with the IETF Secure
Inter-Domain Routing (SIDR) working group proposing
several new standards [7].
Initial implementations of
these standards are available [8] and are being deployed.
However, before a proposed security framework can be
widely deployed, it would be good if an evaluation of

the architecture, implementation, and operational impli-
cations could be performed. If there are problems in the
proposed protocols, the IETF and vendors would want
to correct them before widespread deployment. In this
paper we are interested in the question:

How can we determine if these BGP security
protocols are ready for large-scale, Internet-
wide, deployment?

The complexity of both the proposed BGP security solu-
tions, as well as the expected deployment scale, suggest
that simple protocol compliance tests are not sufﬁcient:
operational deployment and scalability tests are critical.
Furthermore, system soundness during migration and in
day-to-day operations needs to be demonstrated.

This problem has to be addressed using multiple meth-
ods, including formal veriﬁcation, simulation, emula-
tion, small-scale and real-world test-labs. The value
of large real-world test-beds has been widely recog-
nized [9, 10], but none of them sufﬁciently captures the
realism required with respect to a comprehensive BGP
security evaluation.
In fact, the underlying fundamen-
tal problem with test-lab proposals is that each security
evaluation poses different demands on the characteris-
tics of the test-lab. With respect to the evaluation of
the RPKI [11] it turned out to be easier to start from
scratch [12] than to use any of the existing test-labs.
Test-labs need to be ﬂexible and adjust quickly to the
demands of the evaluation task.

For this reason, we argue that it is important to focus
on high-level abstractions that allow auto-generation of
experimental topologies. We believe that virtualization
combined with abstractions will help with complex pro-
tocol and system evaluations.

We would stress that we do not mean that existing ap-
proaches are heading in the wrong direction. We just be-
lieve they can be augmented with additional test-lab test-
ing techniques that provide more ﬂexibility using auto-
conﬁguration. With respect to the SIDR proposals in par-
ticular, we also consider the problem of complex BGP
policy interactions [13,14], and the ability to experiment
with migration issues [15]. We want to empower secu-
rity experts with the ability to create more realistic attack
scenarios, e.g., [16].

1.1 Challenges

The challenge is to provide a testing methodology that
allows security experts, router vendors, and Internet Ser-
vice Providers (ISPs) to explore the system and proto-
cols at a realistic scale. Such a toolkit needs to run real
vendor code and infrastructure software that is used in
the Network Operation Centers (NOCs).

To allow the repeated running of many different exper-
iments in a fast and ﬂexible manner, a fully functional
and fully isolated emulated network should be automati-
cally deployed and explored. This leads to the need for
auto-generation of large parts of the BGP security com-
ponents as well as the network infrastructure. We need
abstractions to model multi-ISP topologies and reason-
able defaults to generate the detailed device (router and
server) conﬁgurations. These abstractions provide the
ability to create networks of various levels of complex-
ity, with minimum speciﬁcation effort.

Unfortunately, today it is not trivial to create and
conﬁgure a test-lab with several thousand nodes in-
volving interactions of multiple Autonomous Systems
(ASes)—even if that test-lab is run as a set of virtual
machines (VM) on a compute cluster. The problem
is that many separate but coordinated device conﬁgura-
tions need to be created—a time consuming, repetitive
and error prone task.

1.2 Approach

Our work extends abstractions in AutoNetkit [17], a con-
ﬁguration generation tool for complex network emula-
tions. One of the key aspects is providing reasonable de-
faults whenever the user is not speciﬁc. For example, IP
addresses are automatically allocated. The correspond-
ing conﬁguration entries will be created for each VM
according to the speciﬁed platform.

We aim at recreating semi-realistic behavior, which is
relevant for the security evaluation of the proposed SIDR
architectures. For our methodology we auto-generate
what we anticipate good players would do. We do not
aim to create attacks, or what evil guys might be doing.
We leave this to security experts who use our tool to fa-
cilitate a lab setup. However, we believe there is value in
bootstrapping the initial deployment process with semi-
realistic conﬁgurations.

We call such a static, generated setup a scenario. An
virtual topology is deployed and the related protocols,
like those involved in routing and rpki, propagate in-
formation in the network.
In contrast to a scenario,
an event is manually triggered. For instance, an event
could be the revocation of a certiﬁcate. An experimenter,
then, can design the (periodic) automated measurements
which collect the desired data into log ﬁles.

Figure 1: Example input based on our abstractions.

2 Methodology
Our goal is to enable easy set-up; therefore our toolkit
has only four phases: (1) download the tool and accom-
panying semi-conﬁgured Linux images, e.g., the RPKI
software [8]; (2) specify the abstractions (Sec. 2.2); (3)
compile to conﬁgurations and deploy VMs (Sec. 2.3);
(4) run experiments.
2.1 An example
Fig. 1 shows a complete conﬁguration example, that
speciﬁes, conﬁgures and deploys a multi-AS topology.
Only one conﬁguration ﬁle, one that details access to
our compute-server, is omitted. Node properties in the
graphml input are used to specify properties such as in
which AS the node is or if it is an RPKI server (i.e.
runs rpkid, the CA daemon speaking the Up/Down Pro-
tocol with other RPKI servers), etc. In this example, rN
(where N = 1..6) denotes a router; rpki-X an RPKI server;
and cacheM (where M = 1..4) a cache server.

Each node of the topology becomes either a Juno-
sphere virtual router or a server running on a Linux vir-
tual machine. Every machine has a pre-installed image
and receives its conﬁguration (databases and scripts) at
boot time. An 89 router network (not shown) compiled
in less than a minute and deployed on Junosphere in
roughly 17 minutes using 136.8GB memory. If a user
wishes to host two servers, e.g. a cache and a rpki, in
the same virtual machine, then the user will draw a sin-
gle node. The functionality of the node will be evident
not only from the node properties but also from the links
adjacent to it.
2.2 Abstractions
The proposal to secure BGP consists of certiﬁcation au-
thorities (CAs) which create and publish X.509 certiﬁ-
cates, ROAs, etc, and relying parties which fetch, vali-
date, and use the products of the CAs [11]. Publication

is composed of the RPKI certiﬁcation hierarchy, a publi-
cation repository and a backend within each ISP which
signs end-entity (EE) certiﬁcates and creates Route Ori-
gin Authorizations (ROAs). The veriﬁcation side con-
sists of an external cache-server that crawls the publica-
tion repositories via a tool called rcynic [8], cryptograph-
ically validates the data, and communicates to a router
via the rtr-protocol [18]. The routers perform either ori-
gin validation [19] or BGPSEC [20].

In our abstractions we strive towards simplicity, but
we also need to capture the relevant structures of the
SIDR framework: (1) a test-lab topology which we ex-
press in a graphml ﬁle employing node properties; (2)
publication side, including the RPKI CA (Certiﬁcation
Authority) a hierarchy of publication servers produc-
ing ROAs; (3) a validation side of relying party cache
servers, including the rtr-protocol; and (4) BGP conﬁgu-
rations on routers.
2.2.1 Topology speciﬁcation
For the test-lab topology speciﬁcation we aim at roughly
the same level of abstraction that one would use when
drawing on a whiteboard. The graphml format allows
the user to describe node properties. None of those prop-
erties are mandatory, for example asn speciﬁes the AS
number, but if omitted all nodes would be in one AS
(AS1). A node in the graph can either represent a router
or a Linux VM, the default being a router.

Most of the discussion in the following sections con-
cerns link properties. If the value of the property physi-
cal is true (default value) on a link, then there is a physi-
cal connection between the nodes connected. Otherwise,
the link speciﬁes one or more logical relationships be-
tween the nodes. In Fig. 1, physical links are drawn as
solid lines, while all the others are represented as dotted
lines.
2.2.2 Publication side
RPKI certiﬁcation hierarchy: The RPKI X.509 cer-
tiﬁcate hierarchy deﬁnes how the RPKI CA servers ex-
change data via the Up/Down, AKA Provisioning, Pro-
tocol [11]. To set this up, cryptographic identities and
keys are exchanged to establish the relationship between
parent and child. This relationship hierarchy follows the
address space allocation hierarchy, e.g., IANA gives ad-
dress space to ARIN, ARIN to ISPs, ISPs to customers.
The compilation phase performs this rather complex set-
up exchange. The hierarchy is speciﬁed through the link
property certiﬁed_by. This property can be conﬁgured
on a directed edge between two rpki nodes. For example,
in Fig. 1, both AS2 and AS3 get address space from the
same RIR (Regional Internet Registry) and they are cer-
tiﬁed by it. AS3 is also a customer of AS2 and receives a
certiﬁcate from the later as well.

ROAs: The RPKI exchanges and publishes certiﬁcates
which attest to the ownership of address space. Those
certiﬁcates do not specify who will be allowed to an-
nounce a particular address block. It is up to the certi-
ﬁed owner to specify by what Autonomous System (AS)
this block may be announced. This is done using a ROA,
which associates a preﬁx with an authorized originating
AS number. To publish ROAs, EE-certiﬁcates are gen-
erated, and these sign ROAs. As resources are automati-
cally allocated, by default we generate and publish valid
ROAs for all preﬁxes in the model. However, a node
might use the node property roa to specify deviations
from this rule. If the node property roa is set to false
that means that no ROAs are generated or published, if it
contains a number it generates the speciﬁed, potentially
invalid, ROA.
Publication hierarchy: The third, independent, RPKI
entity publishes ROAs. It is the choice of the network op-
erators to specify whether to self-publish (run their own
pubd or rootd) or delegate. The default option in our
system is to self-publish. This means that the certiﬁca-
tion engine and the publication site are collocated in the
same rpki node. The edge property publishes_in is used
to denote that an AS wishes another AS to publish its
ROAs. For example, if the link (rpki-cust2, rpki-RIR) in
Fig. 1 has the publishes_in property set, then AS3 does
not maintain its own publication point, but delegates it to
AS1. If this property is not set in the (rpki-isp1, rpki-RIR)
link, which is the default case, then AS2 self-publishes.
2.2.3 Veriﬁcation side
The previous section described how the RPKI publishes
the cryptographically veriﬁable information. The task of
obtaining those ROAs for veriﬁcation is done by relying
party tools, e.g., by rcynic [8].
Cache server/rcynic: Rcynic collects the relevant
ROA information from repositories. Suppose that a cer-
tiﬁcate B is issued and signed by the parent’s certiﬁcate
A. This parent certiﬁcate contains a Subject Information
Access (SIA), which is a URI (Uniform Resource Identi-
ﬁer) pointing to the publication point of certiﬁcate B. All
certiﬁcates are linked in this way. The Authority Infor-
mation Access (AIA) is the reverse and links certiﬁcate
B with the parent’s certiﬁcate A. The tool, rcynic, starts
with a preconﬁgured Trust Anchor Locator (TAL) and
then recursively descends through the repositories using
the SIAs. By default, a cache node runs rcynic and the
publication repository search starts from the rpki-root.

If the user wishes, though, it is possible to conﬁgure
a cache to download and verify the data from a custom
location, e.g. another cache server. This is denoted by
setting the pulls_from property value to true on a cache-
to-cache directed link. In Fig. 1, cache3 receives infor-

mation from cache2 and then validates it. The protocol
used in this case is not rcynic but rsync. Similarly for
the (cache2, cache1) link. Note that there is no link de-
parting from cache1, which means that it executes the
default action with rcynic.
rtr-protocol: The rtr-protocol [18] denotes a server-
router relationship in which the router pulls veriﬁed in-
formation from one or more cache servers. The link
property pulls_from is used again to denote this rela-
tionship. If pulls_from is set on a server-to-server link,
then is captures an rsync exchange as noted in the previ-
ous paragraph. However, if it is set on a router-to-server
link, then it marks an rtr-protocol exchange. For exam-
ple, router r5 is pulling information from cache4.
2.2.4 BGP policies
Origin validation [19] can be supported by using a state-
ment such as ( if rpki=invalid reject ). This creates
a route-map/policy-option statement to drop BGP an-
nouncements that have been marked as invalid by the
router’s origin validation matching rules.
2.3 Implementation
For the initial RPKI key exchange we use a modiﬁed
yamltest script [8]. Our tool can deploy to Junosphere,
GNS3 and RPKI Linux VMs running on large scale in-
frastructures such as StarBED [21]. All Linux VMs are
conﬁgured using two disk images, (1) a modiﬁed instal-
lation with all required software and (2) an image with
conﬁguration ﬁles, which is created during the compi-
lation phase. We focus on integrating real router vendor
code as this allows us to experiment with real router code
and we are therefore able to evaluate BGPSEC [20] im-
plementations as vendors make them available.

We note that a virtualization hypervisor will distort
time-dependent characteristics. Experiments requiring
strict timing (of the order of seconds or less) or high-
throughput cannot be tested in a realistic way. However,
for the scaling and security measurements currently con-
templated by vendors and operators, this should not be
an issue. We believe that our approach is valid when the
required accuracy of time measurements is in the order
of minutes. Comparing different implementations of the
same protocol or monitoring the propagation of cache
updates in large-scale deployments are the kinds of ex-
periments we are targeting.

3 Conclusion
In this paper we propose an abstract representation that
allows us to experiment with the SIDR proposals to se-
cure BGP. This abstraction is necessary to bring conﬁg-
uration simplicity to controlled test-labs and thence to
evaluate complex protocol and system interactions. In

future work, we will explore the strengths and weak-
nesses of such auto-generated, ﬂexible test-labs with se-
curity experts.
Acknowledgments
We like to thank Joel Obstfeld, our shepherd Ron Os-
trenga, and the anonymous reviewers for their feedback.
This work is partially funded by a gift from Cisco grant
#2011-89493.
References
[1] Y. Rekhter, T. Li, and S. Hares, “A Border Gateway Protocol 4

(BGP-4),” 2006, RFC 4271.

[2] K. Butler, T. R. Farley, P. McDaniel, and J. Rexford, “A Survey
of BGP Security Issues and Solutions,” Proceedings of the IEEE,
vol. 98, no. 1, pp. 100–122, January 2010.

[3] G. Huston, M. Rossi, and G. Armitage, “Securing BGP - A Liter-
ature Survey,” Communications Surveys Tutorials, IEEE, vol. 13,
no. 2, pp. 199 –222, 2011.

[4] D. Wetherall, R. Mahajan, and T. Anderson, “Understanding

BGP misconﬁgurations,” in Proc. ACM SIGCOMM, 2002.

[5] S. Kent, C. Lynn, and K. Seo, “Secure Border Gateway Protocol
(S-BGP),” IEEE Journal on Selected Areas in Communications,
vol. 18, no. 4, pp. 582 –592, 2000.

[6] R. White, “Securing BGP through secure origin BGP (soBGP),”
Business communication review, vol. 33, no. 5, pp. 47–53, 2003.
[7] IETF Working Group, “Secure Inter-Domain Routing (sidr).”

[Online]. Available: http://datatracker.ietf.org/wg/sidr/

[8] Rob Austein, Dragon Research Lab.

https://trac.rpki.net/

[Online]. Available:

[9] J. Mirkovic, T. Benzel, T. Faber, R. Braden, J. Wroclawski, and
S. Schwab, “The DETER project: Advancing the science of cy-
ber security experimentation and test,” in IEEE Technologies for
Homeland Security, nov. 2010, pp. 1 –7.

[10] C. Elliott and A. Falk, “An update on the GENI project,” SIG-

COMM Comput. Commun. Rev., vol. 39, no. 3, June 2009.

[11] M. Lepinski and S. Kent, “An Infrastructure to Support Secure

Internet Routing,” 2012, RFC 6480.

[12] R. Bush, R. Austein, S. Bellovin, and M. Elkins, “The RPKI &

Origin Validation,” NANOG 52, 2011, slide 54.

[13] T. Grifﬁn and G. Huston, “BGP Wedgies,” 2005, rFC 4264.
[14] D. McPerson, V. Gill, D. Walton, and A. Retana, “Border Gate-
way Protocol (BGP) Persistent Route Oscillation Condition,”
2002, RFC 3345.

[15] L. Vanbever, S. Vissicchio, C. Pelsser, P. Francois, and
O. Bonaventure, “Lossless Migrations of Link-State IGPs,”
IEEE/ACM Transactions on Networking, 2012, (To appear).

[16] A. Kapela and A. Pilosov, “Stealing the Internet - A Routed,
Wide-area, Man in the Middle Attack,” 2008. [Online]. Available:
http://defcon.org/html/defcon-16/dc-16-speakers.html#Kapela

[17] H. Nguyen, M. Roughan, S. Knight, N. Falkner, R. Bush, and
O. Maennel, “How to build complex, large-scale emulated net-
works,” in TridentCom, Berlin, Germany, May 2010.

[18] R. Bush and R. Austein, “The RPKI/Router Protocol,” 2012,

draft-ietf-sidr-rpki-rtr-26.

[19] G. Huston and G. Michaelson, “Validation of Route Origination
Using the Resource Certiﬁcate Public Key Infrastructure (PKI)
and Route Origin Authorizations (ROAs),” 2012, RFC 6483.

[20] M. Lepinski and S. Turner, “An Overview of BGPSEC,” 2011,

draft-ietf-sidr-bgpsec-overview-01.

[21] “StarBED Project,” http://www.starbed.org/.

