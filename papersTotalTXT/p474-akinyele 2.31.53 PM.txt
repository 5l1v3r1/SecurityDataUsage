Machine-Generated Algorithms, Proofs and Software for

the Batch Veriﬁcation of Digital Signature Schemes

Joseph A. Akinyele
Johns Hopkins University
akinyelj@cs.jhu.edu

Baltimore, MD, USA

Susan Hohenberger
Johns Hopkins University
Baltimore, MD, USA
susan@cs.jhu.edu

ABSTRACT
As devices everywhere increasingly communicate with each
other, many security applications will require low-bandwidth
signatures that can be processed quickly. Pairing-based sig-
natures can be very short, but are often costly to verify.
Fortunately, they also tend to have eﬃcient batch veriﬁca-
tion algorithms. Finding these batching algorithms by hand,
however, can be tedious and error prone.

We address this by presenting AutoBatch, an automated
tool for generating batch veriﬁcation code in either Python
or C++ from a high level representation of a signature scheme.
AutoBatch outputs both software and, for transparency, a
LaTeX ﬁle describing the batching algorithm and arguing
that it preserves the unforgeability of the original scheme.

We tested AutoBatch on over a dozen pairing-based schemes
to demonstrate that a computer could ﬁnd competitive batch-
ing solutions in a reasonable amount of time.
Indeed, it
proved highly competitive. In particular, it found an algo-
rithm that is signiﬁcantly faster than a batching algorithm
from Eurocrypt 2010. Another novel contribution is that it
handles cross-scheme batching, where it searches for a com-
mon algebraic structure between two distinct schemes and
attempts to batch them together. We describe other features
and performance details herein.

AutoBatch is a useful tool for cryptographic designers and
implementors, and to our knowledge, it is the ﬁrst attempt
to outsource to machines the design, proof writing and im-
plementation of signature batch veriﬁcation schemes.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Cryptographic controls,
Authentication, Access controls, Veriﬁcation

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Matthew Green

Johns Hopkins University
mgreen@cs.jhu.edu

Baltimore, MD, USA

Matthew W. Pagano
Johns Hopkins University
mpagano@cs.jhu.edu

Baltimore, MD, USA

Keywords
Digital Signatures, Pairing-Based Cryptography, Batch Ver-
iﬁcation, Automation, Cryptographic Compilers

1.

INTRODUCTION

We anticipate a future where computers are everywhere
as an integrated part of our surroundings, continuously ex-
changing messages, e.g., sensor networks, smartphones, ve-
hicular communications. For these systems to work prop-
erly, messages must carry some form of authentication, and
yet the system requirements on this authentication are par-
ticularly demanding. Applications such as vehicular commu-
nications [21, 57], where cars communicate with each other
and the highway infrastructure to report on road conditions,
traﬃc congestion, etc., require both that signatures be short
(due to the limited spectrum available) and that many mes-
sages from diﬀerent sources can be processed quickly.

Pairing-based signatures are attractive due to their small
size, but they often carry a costly veriﬁcation procedure.
Fortunately, these schemes also lend themselves well to batch
veriﬁcation, where valuable time is saved by processing many
messages at once. E.g., Boneh, Lynn and Shacham [13] pre-
sented a 160-bit signature together with a batching algo-
rithm over signatures by the same signer, where veriﬁcation
time could be reduced from 47.6ms to 2.28ms per signature
in a batch of 200 [26] — a 95% savings!

To prepare for a future of ubiquitous messaging, we would
like batching algorithms for as many pairing-based schemes
as possible. Designing batch veriﬁcation algorithms by hand,
however, is challenging. First, it can be tedious. It requires
knowledge of many batching rules and exploration of a po-
tentially huge space of algebraic manipulations in the hunt
for a good candidate algorithm. Second, it can be error
prone. In Section 1.3, we discuss both the success and failure
of the past ﬁfteen years in batching digital signatures. The
clear lesson is that mistakes are common and that even when
generic methods for batching have been suggested, they have
often been misapplied (e.g., a critical step is forgotten.) This
paper demonstrates that it is feasible for humans to turn
over some of the design, proof writing and implementation
work in batch veriﬁcation to machines.

4741.1 Our Contributions

We present AutoBatch, an automated tool that trans-
forms a high-level description of a signature scheme1 into
an optimized batch veriﬁcation program in either Python
or C++. The algorithm behind AutoBatch searches for a
batching algorithm by repeatedly applying a combination of
novel and existing batching techniques. Because some loops
or other inﬁnite paths could occur, AutoBatch prunes its
search using a set of carefully designed heuristics. The ﬁ-
nal code also includes logic for altering the behavior of the
batching algorithm based on its input size or past input.

To our knowledge, this is the ﬁrst attempt to automati-
cally identify when certain batching techniques are applica-
ble and to apply them in a secure manner. Importantly, the
way in which we combine these techniques and optimizations
preserves the unforgeability of the original scheme. Speciﬁ-
cally, with all but a negligible probability, the batch veriﬁer
will accept a batch S of signatures if and only if every s ∈ S
would have been accepted by the individual veriﬁcation al-
gorithm. AutoBatch also produces a machine-generated La-
TeX ﬁle that speciﬁes each technique applied and the argu-
ment for why security holds.

AutoBatch was tested on several pairing-based schemes.
It produced the ﬁrst batching algorithms, to our knowledge,
for the Camenisch-Lysyanskaya [18], Hohenberger-Waters [33]
and Waters dual-system [63] signatures. It also discovered
a signiﬁcantly faster algorithm for batching the proofs of
the veriﬁable random functions in [34]. Moreover, Auto-
Batch is able to handle batches with more than one type
of signature. Indeed, we found that the Hess [32] and Cha-
Cheon [22] identity-based signatures can be processed twice
as fast when batched together compared to sorting by type
and batching within the type. The capability to do cross-
scheme batching is a novel contribution of this paper, and
we feel could be of great value for applications, such as mail
servers, which may encounter many signature types at once.
AutoBatch is a tool with many applications for both ex-
isting and future signature schemes. It helps enable the se-
cure, but rapid processing of authenticated messages, which
we believe will be of increasing importance in a wide-variety
of future security applications.
1.2 Overview of Our Approach

We present a detailed explanation of AutoBatch in §3. In
this section and in Figure 1 we provide a brief overview of
the techniques. At a high level, AutoBatch is designed to an-
alyze a scheme, extract the signature veriﬁcation equation,
and derive working code for a batch veriﬁer. This involves
three distinct components:

1. (Optional) A Code Parser, which retrieves the veri-
ﬁcation equation and variable types from some exist-
ing scheme implementation. This process naturally as-
sumes that the scheme has been implemented within
certain constraints, which we discuss later in the paper.
Given such an implementation, the Parser obtains the
signature veriﬁcation equation and encodes it into an
intermediate representation called Scheme Description
Language (SDL).

2. A Batcher, which takes as input an SDL ﬁle describing
a signature veriﬁcation equation. It searches through
1Optionally, one can start with an existing implementation,
from which AutoBatch will extract a representation.

a series of rules, which may be applied repeatedly, to
optimize the equation and thus derive a new equation
for a batch veriﬁer. The output of this equation is
second SDL ﬁle containing the individual and batch
equations, along with an analysis of the batcher’s es-
timated running time. For transparency, the Batcher
optionally outputs a human-readable ﬁle written in La-
TeX describing the batching algorithm and containing
a security proof that it maintains the unforgeability of
the original scheme.

3. A Code Generator, which takes the output of Batcher
and generates working source code to implement the
batch veriﬁer. The user can choose either Python or
C++ as the output language; either building on the
MIRACL library [56]. Beyond simply implementing
the veriﬁcation equation, the Generator adds a series of
additional components, including group element mem-
bership checks, a recursive divide-and-conquer process
to handle batches that contain invalid signatures, and
additional logic to identify cases where individual ver-
iﬁcation is likely to outperform batching.

There are two usage scenarios for AutoBatch. The most
common may be that a user begins with a hand-coded SDL
ﬁle and feeds this directly into the Batcher. Since SDL ﬁles
are human-readable ASCII-based ﬁles containing a mathe-
matical representation of the scheme, some developers may
prefer to implement new schemes directly in this language,
which is agnostic to the programming language of the ﬁnal
implementation.

As a second scenario, if the user already has a working
implementation of the scheme in Charm/Python [1], then
she can save time. This program can be given to the Code
Parser, which will extract the necessary information from
the code to generate an SDL ﬁle. Charm [1] is a Python-
based prototyping framework created by Akinyele, Green
and Rubin that provides infrastructure for developing ad-
vanced cryptographic schemes. There is already a library of
pairing-based signatures publicly available in Charm/Python,
so we provide this as a second interface option to our tool.
1.3 Related Work

Computer-aided security is a goal of high importance. Re-
cently, the best paper award at CRYPTO 2011 was given to
Barthe, Gr´egoire, Heraud and Zanella B´eguelin [8] for their
invention of EasyCrypt, an automated tool for generating
security proofs of cryptographic system from proof sketches.
The reader is referred there for a summary of eﬀorts to au-
tomate the veriﬁcation of cryptographic security proofs.

In 1989, batch cryptography was introduced by Fiat [27]
for a variant of RSA. In 1994, an interactive batch veriﬁer
for DSA presented in an early version of [52] was broken
by Lim and Lee [41].
In 1995 Laih and Yen proposed a
new method for batch veriﬁcation of DSA and RSA signa-
tures [38], but the RSA batch veriﬁer was broken ﬁve years
later by Boyd and Pavlovski [15]. In 1998, two batch veriﬁ-
cation techniques were presented for DSA and RSA [29, 30]
but both were later broken [15, 35, 36]. The same year,
Bellare, Garay and Rabin took the ﬁrst systematic look
at batch veriﬁcation [9] and presented three generic meth-
ods for batching modular exponentiations, one of which is
called the small exponents test. Unfortunately,
in 2000,
Boyd and Pavlovski [15] published attacks against various
batching schemes which were using the small exponents test

475Figure 1: The ﬂow of AutoBatch. The input is a signature scheme comprised of key generation, signing
and veriﬁcation algorithms, represented in the domain-speciﬁc SDL language. The scheme is processed by a
Batcher, which applies the techniques and optimizations from Section 3 to produce a new SDL ﬁle containing
a batch veriﬁcation algorithm. Optionally, the Batcher outputs a proof of security (as a PDF written in
LaTeX) that explains, line by line, each technique applied and its security justiﬁcation. Finally, the Code
Generator produces executable C++ or Python code implementing both the resulting batch veriﬁer, and
the original (unbatched) veriﬁcation algorithm. An optional component, the Parsing Engine, allows for the
automatic derivation of SDL inputs based on existing scheme implementations.

incorrectly. In 2003-2004, several batch veriﬁcation schemes
based on bilinear maps (a.k.a., pairings) were proposed [22,
64,66,67] but all were later broken by Cao, Lin and Xue [20].
In 2006, a method was given for identifying invalid signa-
tures in RSA-type batches [40], but it was also ﬂawed [61].
It is natural to ask what the source of the errors were
in these papers.
In several cases, the mathematics of the
scheme were simply unsound and the proof of security was
either missing or lacking in rigor. However, there were two
other common problems. One was that the paper claimed in
English to be doing batch veriﬁcation, but the security deﬁ-
nition provided in the paper was insuﬃcient to establish this
guarantee. Most commonly this matched the strictly weaker
screening guarantee; see [17] for more. A second problem
was more insidious: the security deﬁnition and proof were
“correct”, but the scheme was still subject to a practical
attack because the authors started the proof by explicitly
assuming that elements of the signature were members of
certain algebraic groups and this was not a reasonable as-
sumption to make in practice. Boyd and Pavlovski [15] pro-
vide numerous examples of this case.

AutoBatch addresses these common pitfalls. It uses one
security deﬁnition (in Section 2.1) and provides a proof of
security for every algorithm it outputs relative to this def-
inition (in Section 3.2), where no assumptions about the
algebraic structure of the input are made and therefore any
necessary tests are explicitly performed by the algorithm.

In addition to the batching work above, we mention a few
more. Shacham and Boneh presented a modiﬁed version of
Fiat’s batch veriﬁer for RSA to improve the eﬃciency of
SSL handshakes on a busy server [58]. Boneh, Lynn and
Shacham provided a single-signer batch veriﬁer for BLS sig-
natures [13]. Camenisch, Hohenberger and Pedersen [17]
gave multiple-signer batch veriﬁers for Waters identity-based
signatures [62] and a novel construction. Ferrara, Green,
Hohenberger, and Pedersen outlined techniques for batching
pairing-based signatures and showed how to batch group and
ring signatures [26]. Blazy, Fuchsbauer, Izabach´ene, Jam-
bert, Sibert and Vergnaud [10] applied batch veriﬁcation
techniques to the Groth-Sahai zero-knowledge proof system

as well as group signatures and anonymous credential sys-
tems relying on them, obtaining signiﬁcant savings.

Law and Matt describe methods for identifying invalid

signatures in a batch [39, 47, 48].

Lastly, there have been several research eﬀorts toward
automatically generating cryptographic protocols and ex-
ecutable code. This compiler-like approach has been ap-
plied to cryptographic applications such as security proto-
cols [37,42,43,54,60], optimizations to software implementa-
tions involving elliptic-curve cryptography [7] and bilinear-
map functions [53], secure two-party computation [31,45,46],
and zero-knowledge proofs [2, 4, 5, 19, 49].

2. BACKGROUND

A digital signature scheme is comprised of the usual prob-
abilistic polynomial-time algorithms (Gen, Sign, Verify). We
recall the basics of signatures, as well as the identity-based,
privacy-preserving and veriﬁable random function variants.

Definition 2.1

(A Digital Signature). A digital sig-
nature scheme is a tuple of probabilistic polynomial-time al-
gorithms (Gen, Sign, Verify) as:

1. Gen(1λ) → (pk , sk ): the key generation algorithm takes
as input the security parameter 1λ and outputs a pair
of keys (pk , sk ).

2. Sign(sk , m) → σ: the signing algorithm takes as input
a secret key sk and a message m from the message
space and outputs a signature σ.

3. Verify(pk , m, σ) → {0, 1}:

the veriﬁcation algorithm
takes as input a public key pk , a message m and a
purported signature σ, and outputs a bit indicating the
validity of the signature.

A scheme is correct if for all Gen(1(cid:96)) → (pk , sk ), the algo-
rithm Verify(pk , m, Sign(sk , m)) = 1.

A scheme is deﬁned to be unforgeable as follows [28]: Let
Gen(1(cid:96)) → (pk , sk ). Suppose (m, σ) is output by a p.p.t.
adversary with access to a signing oracle Osk (·) and input

Parsing EngineSignature Scheme in PythonSDL rep of Signature SchemeBatcherSDL rep of Batch VeriﬁerCode GeneratorIndividual Loop Python/C++ CodeBatching Python/C++ CodeProof of Security476pk . Then the probability that m was not queried to Osk (·)
and yet Verify(pk , m, σ) = 1 is negligible in (cid:96).

In this work, we explore three variants:

1. Identity-Based Signatures [59]: Gen is executed
by a master authority who publishes pk and uses sk
to generate signing keys for users according to their
public identity string, e.g., email address. To verify a
signature on a given message, one only needs the pk of
the master authority and the public identity string of
the purported signer.

2. Privacy Signatures: Group [24] and ring [55] signa-
tures are associated with a group of users, where ver-
iﬁcation shows that at least one member of the group
signed the message, but it is diﬃcult to tell whom.

3. Veriﬁable Random Functions [50]: A VRF is a
pseudo-random function, where the computing party
publishes a public key pk and then can oﬀer a short
non-interactive proof that the function was correctly
evaluated for a given input. This proof can be viewed
as a signature by the computing party on the input to
the pseudo-random function.

2.1 Batch Veriﬁcation

Our security focus here is not directly on unforgeabil-
ity [28]. Rather we are interested in designing batch veriﬁca-
tion algorithms that accept a set of signatures if and only if
each signature would have been accepted by its veriﬁcation
algorithm individually. Thus, if a scheme is unforgeable,
then our batching algorithm will preserve this property.

Speciﬁcally, we consider the case where we want to quickly
verify a set of signatures on possibly diﬀerent messages by
possibly diﬀerent signers. The input is {(t1, m1, σ1), . . . ,
(tn, mn, σn)}, where ti speciﬁes the veriﬁcation key against
which σi is purported to be a signature on message mi. It is
important to understand that here one or more signers may
be maliciously colluding against the batch veriﬁer.

We recall the deﬁnition of Bellare, Garay and Rabin [9]

as extended in [17] to deal with multiple signers.

Definition 2.2

(Batch Verification of Signatures).

Let (cid:96) be the security parameter. Suppose (Gen, Sign, Verify) is
a signature scheme, k, n ∈ poly((cid:96)), and (pk 1, sk 1), . . . , (pk k,
sk k) are generated independently according to Gen(1(cid:96)). Let
P K = {pk 1, . . . , pk k}. We call probabilistic Batch a batch
veriﬁcation algorithm when the following conditions hold:

• If pk ti ∈ P K and Verify(pk ti

, mi, σi) = 1 for all i ∈
[1, n], then Batch((pk t1 , m1, σ1), . . . , (pk tn , mn, σn)) =
1.

• If pk ti ∈ P K for all i ∈ [1, n] and Verify(pk tj

, mj, σj) =
0 for some j ∈ [1, n], then Batch((pk t1 , m1, σ1), . . . ,
(pk tn , mn, σn)) = 0 except with probability negligible
in (cid:96), taken over the randomness of Batch.

The above deﬁnition can be generalized beyond signatures
to apply to any keyed scheme with a veriﬁcation algorithm.
This includes zero-knowledge proofs, veriﬁable random func-
tions, and variants of regular signatures, such as identity-
based, attribute-based, ring, group, aggregate, etc. The
above deﬁnition requires that signing keys be generated hon-
estly. In practice, users could register their keys and prove
some necessary properties of the keys at registration time [6].

2.2 Algebraic Setting
Bilinear (a.k.a., Pairing) Groups. Let BSetup be an
algorithm that, on input the security parameter 1(cid:96), outputs
the parameters for a bilinear map (also called a pairing) as
(q, g, h, G1, G2, GT , e), where G1, G2 and GT are groups of
prime order q ∈ Θ(2(cid:96)). The eﬃcient mapping e : G1 ×G2 →
GT is both: (bilinear) for all g ∈ G1, h ∈ G2 and a, b ← Zq,
e(ga, hb) = e(g, h)ab; and (non-degenerate) if g generates G1
and h generates G2, then e(g, h) (cid:54)= 1. See [17] or Section 4

for more. The above bilinear map is called asymmetric and
our implementations use this highly eﬃcient setting. We
optionally could consider symmetric maps where G1 = G2.

Testing Membership in Bilinear Groups. When batch-
ing, it is critical to test that the elements of each signa-
ture are members of the appropriate algebraic group. Boyd
and Pavlovski [15] demonstrated eﬃcient attacks on batch-
ing algorithms for DSA signature veriﬁcation which omitted
a subgroup membership test.

In this paper, we must test membership in bilinear groups.
We require that elements of purported signatures are mem-

bers of G1 and not, say, members of E(Fp)\G1. Determining

whether some data represents a point on a curve is easy. The
question is whether it is in the correct subgroup. If the order
of G1 is a prime q, one option is to verify that an element y
is in G1 by checking that yq mod q = 1 [17]. Although this
costs an extra modular exponentiation per group element,
this will largely be dwarfed by the savings from reducing the
total pairings, as experimentally veriﬁed ﬁrst by Ferrara et
al. [26] and conﬁrmed by our tests.

3. THE AUTOBATCH TOOLCHAIN

In this section we summarize the techniques used by Au-
toBatch to programmatically generate batch veriﬁers from
standard signature schemes. A high level abstraction was
provided in Figure 1. The main stages are as follows.

1. Derive the scheme’s SDL representation. The Au-
toBatch toolchain begins with an SDL representation of a
signature scheme. While SDL is not a full programming
language, it provides suﬃcient ﬂexibility to represent most
pairing-based signature schemes.
A detailed description
of SDL and some examples can be found in the full version
of this work. For developers who already have an existing
Charm/Python implementation, we also provide a Parsing
Engine that can optionally derive an SDL representation di-
rectly from this Python code.2

2. Apply batching techniques and optimize the veri-
ﬁcation equation. We ﬁrst apply a set of techniques de-
signed to convert the SDL signature veriﬁcation equation
into a batch veriﬁer. These techniques optimize the ver-
iﬁcation equation by combining pairing equations and re-
arranging the components to minimize the number of ex-
pensive operations. To prevent known attacks, we apply the
small exponents test of Bellare, Garay and Rabin [9], and

2We developed this capability for two reasons. First, there
is already a library of pairing-based signatures available in
Charm/Python (in fact, the number of Charm implementa-
tions is greater than all other settings combined). Secondly,
we believe that there is value in providing multiple interfaces
to our tools, particularly interfaces that work with real im-
plementations.

477Figure 2: The Boneh-Lynn-Shacham (BLS) signature scheme [13] at various stages in the AutoBatch
toolchain. At the left, an initial Charm-Python implementation of the scheme.
In the center, an SDL
representation of the same scheme, programmatically extracted by the Parsing Engine. At right, a fragment
of the resulting batch veriﬁer generated after applying the Batcher and Code Generator.

optimize the resulting equation to ensure that all signature
elements are in the group with the smallest representation
(typically, G1). The output of this phase is a modiﬁed SDL
ﬁle, and (optionally) a human-readable proof that the re-
sulting equation is a batch veriﬁer.

3. Evaluate the capabilities of the batch veriﬁer. Given
the optimized batching equation produced in the previous
step, we estimate the performance of the veriﬁer under var-
ious conditions. This is done by counting the operations in
the veriﬁer, and deriving a runtime estimate based on the
expected cost of each mathematical operation (e.g., pairing,
exponentiation, multiplication). The cost of each operation
is determined via a set of diagnostic tests conducted when
the library is initialized.3

4. Generate code for the resulting batch veriﬁer. Fi-
nally, we translate the resulting SDL ﬁle into a working
batch veriﬁer. This veriﬁer can be implemented in either
C++ (using the MIRACL library [56] for curve operations)
or in Python based on the Charm framework. It implements
the SDL-speciﬁed batch veriﬁcation equation as well as the
individual veriﬁcation equation. Based on the calculations
of the previous step, the generated code embeds logic to au-
tomatically determine which veriﬁer is most appropriate for
a given dataset (individual or batch). Additionally, the gen-
erated code embeds a recursive divide-and-conquer strategy
to handle cases where batch veriﬁcation fails due to invalid
signatures. Two fragments of generated code (Python and
C++) are shown in Figure 2.

We will now describe each of the above steps in detail.
3.1 Batching and Optimization

Given an SDL ﬁle containing the veriﬁcation equation and
variable types, the Batcher applies a series of optimizations
to the veriﬁcation equation in order to derive an eﬃcient

3Obviously these experiments are very speciﬁc to the ma-
chine and curve parameters on which they are run. Our
implementation re-runs these experiments whenever the li-
brary is initialized with a given set of parameters.

batch veriﬁer. Many of these techniques were ﬁrst explored
in previous works [17, 26]. However, the intended audience
of those works is humans performing manual batching of sig-
natures. Hence, they are in many cases somewhat less ‘gen-
eral’ than the techniques we describe here.4 Furthermore,
unlike previous works we are able to programmatically iden-
tify when these techniques are applicable, and apply them
to the veriﬁcation equation in a consistent way.

The Batcher assumes that the input will be a collection of
η signatures, possibly on diﬀerent messages and public keys
(or identities). To construct a batch veriﬁer, Batcher ﬁrst
validates the type information in SDL input ﬁle and con-
verts the veriﬁcation equation into a tree structure. During
this phase, it informs users if there are type mismatches or
if the typing information is incomplete in SDL. Next, the
batcher traverses the tree, applying various operations at
various nodes in the veriﬁcation equation. We now list those
techniques.

Technique 0: Consolidate the veriﬁcation equation. Many
pairing-based signature schemes actually require the veriﬁer
to check more than one pairing equation. During the ﬁrst
phase of the batching process, the batcher applies the small
exponents test from [9] to combine these equations into a
single veriﬁcation equation.5

Technique 1: Combine equations. Assume we are given η
signature instances that can be veriﬁed using the consoli-
dated equation from the previous step. We now combine all
instances into one equation by applying the Combination
Step of [26], which employs as a subroutine the small ex-
ponents test. This results in a single veriﬁcation equation.
The correctness of the resulting equation requires that all

4For example: techniques 2 and 3 of [17] each combine a
series of logical operations that are more widely applicable
and easily managed by splitting them into more granular
sub-techniques.
5For example, consider two veriﬁcation conditions e(a, b) =
e(c, d) and e(a, c) = e(g, h). These can be veriﬁed simulta-
neously by selecting random δ1, δ2 and evaluating the single
equation e(a, b)δ1 e(c, d)−δ1 e(a, c)δ2 e(g, h)−δ2 = 1.

class BLS(PKSig):   def __init__(self):       global group       group = PairingGroup(MNT160)           def keygen(self):       g = group.random(G2)        x = group.random(ZR)       g_x = g ** x       pkd = { 'pk':g_x, 'g':g }       skd = { 'x':x }       return (pkd, skd)     def sign(self, x, M):      h = group.hash(M, G1)      sig = h ** x      return sig          def verify(self, pkd, sig, M):    h = group.hash(M, G1)    if pair(h, pkd['pk']) == pair(sig, pkd['g']):       return True      return False SDL…# 1 Choose deltas for small exponents test       delta = [ SmallExp(t) for z in range(0, N) ]# 2 Initialize dot products      dotA_prod = dotB_prod = 1# 3 Precompute dot products that can be #    cached between runs of divide / conquer for z in range(0, N):      # 4 group membership checks      # … variables calculated over sigs…# 5 batch veriﬁcation check if pair(dotA_prod , pk) == pair(dotB_prod, g):     return Trueelse:   # 6 divide / conquer (recurse on ﬁrst half)    verSigsRecursive( grp, dotA_cache,         dotB_cache, start = i, stop = N / 2 )    # recurse on second half    verSigsRecursive( grp, dotA_cache,         dotB_cache, start = N/2+1, stop = N )...Python ...# 1 Choose deltas for small exponents test         for (int z = 0; z < N; z++)              SmallExp(t, delta[z]);# 2 Initialize dot products        G1 dotA_cache[N], dotB_cache[N], h;        string M;# 3 Precompute cacheable dot products         for (int z = 0; z < N; z++)            {            M = message[z];            HASH(h, M);            grp_exp(dotA[z], h, delta[z]);            grp_exp(dotB[z], sig[z], delta[z]);            }# 5 Batch Veriﬁcation Checkif ( pair( dotA_prod , pk ) ==         pair( dotB_prod , g ) )  { … }# 6 Divide and conquer ﬁrst half  verSigsRecursive(pk, sig, message, grp,         0, N, delta, dotA_cache, dotB_cache);...ORname := blsN := 100 BEGIN :: types  M := str;   h := G1;   sig := G1  g := G2;   pk := G2END :: types constant := g;       public := pksignature := sig;   message := h BEGIN :: precompute  h := H(M, G1)END :: precomputeBEGIN :: func:sign  input := list{sk, M}  sig := h ^ sk  output := sigEND :: func:signverify := {e(h, pk) == e(sig, g)}Charm/PythonBatch VeriﬁerC++ 478elements be in the correct subgroup, i.e., that group mem-
bership has already been checked. AutoBatch ensures that
this check will be explicitly conducted in the ﬁnal batch ver-
iﬁer program.

Technique 2: Move exponents into the pairing. When a pair-
ing of the form e(gi, hi)δi appears, move the exponent δi into
e(). Since elements of G1 and G2 are usually smaller than
elements of GT , this gives a noticeable speedup when com-
puting the exponentiation.

Replace e(gi, hi)δi with e(gδi

i , hi)

Wherever possible, we move the exponent into the group
with the lowest exponentiation cost. We identify this group
based on a series of operation microbenchmarks that run
automatically at code initialization.6

Technique 3: Move dot products into the pairing. When a
i=1 e(ai, g) with a constant ﬁrst or sec-
ond element appears, move the dot product inside to reduce
the number of pairings from η to 1.

pairing of the form(cid:81)η

Replace

η(cid:89)i=1

e(ai, g) with e(

ai, g)

η(cid:89)i=1

Technique 4: Optimize the Waters Hash. A variety of bi-
linear signature schemes employ a hash function by Wa-
ters [62], which can be generalized [23, 51]. Assume the
identity is a k-bit string V = v1v2 . . . vz where each vi is a
i=1 uvi
i .
When batching η equations containing the Waters hash,
vi j
).
i
This can be rewritten to make the number of pairings inde-
pendent of the number of equations one wants to batch.

short string. The hash function is evaluated as u(cid:48)(cid:81)m
one often encounters terms of the form(cid:81)η
j=1 e(gj,(cid:81)z
η(cid:89)j=1
z(cid:89)i=1

η(cid:89)j=1

z(cid:89)i=1

gj

vi j , ui)

Replace

vi j
i

u

) with

i=1 u

e(gj,

e(

Technique 5: Distribute dot products. When a dot product is
applied to two or more pairings, distribute the dot product
to each pairing to allow application of other techniques such
as techniques 3 or 4. For example:

Replace

η(cid:89)i=1

(e(ai, gi)·e(bi, hi)) with

η(cid:89)i=1

e(ai, gi)·

η(cid:89)i=1

e(bi, hi)

Technique 6: Combine pairings with common elements. When
two or more pairings share a common ﬁrst or second element,
they can be combined. For example:

Replace e(a, g) · e(b, g) with e(ab, g)

Technique 7: Move known exponents outside pairing and
precompute pairings. In some cases it may be necessary to
move exponents outside of a pairing. For example, when
6For many common elliptic curves, this is the G1 base group.
However, in some curves the groups G1 and G2 have similar
operation costs; this may give us some ﬂexibility in modify-
ing the equation.

(cid:81)η

i=1 e(gai , hbi ) appears, move the exponents outside of pair-
ing. When multiple such exponents appear, we can pre-
compute the sum of ai · bi for all η and exponentiate once in
GT .

Replace

e(gai , hbi ) with e(g, h)

i(ai·bi)

(cid:80)

η(cid:89)i=1

Technique 8: Precompute constant pairings. When pairings
have a constant ﬁrst and second element, we can simply
remove these from the equation and pre-compute them once
at the beginning of veriﬁcation (equivalent to making them
a public parameter). We refer to this as Technique 8.

Technique 9: Split pairings. In some rare cases it can be use-
ful to apply Technique 3 in reverse: splitting a single pair-
ing into two or more pairings. This temporarily increases
the number of pairings in the veriﬁcation equation, but may
be necessary in order to apply subsequent techniques. For
example, this optimization is necessary so that we can ap-
ply the Waters hash optimization (Technique 4) to the ring
signature of Boyen [16].

Discussion: Several of the above techniques are quite sim-
ple, in that they perform optimizations that would seem
“obvious” to an experienced cryptographer. However, many
optimizations (e.g., Technique 8) could have been applied in
published algorithm descriptions, and yet were not. More-
over, it is a computer and not a human that is performing
the search for us, so an important contribution of this work
is providing a detailed list of which optimizations we tell the
computer to try out and in which order, and verifying that
such an approach can ﬁnd competitive solutions in a rea-
sonable amount of time. This is nontrivial: we discovered
that many orderings lead to “dead ends”, where the optimal
solution is not discovered. We now describe our approach to
ﬁnding the order of techniques.

Technique Search Algorithm: The challenge in automat-
ing the batching process is to identify the order in which
techniques should be applied to a given veriﬁer. This is
surprisingly diﬃcult, as there are many possible orderings,
many of which require several (possibly repeated) invoca-
tions of speciﬁc techniques. Due to space considerations, we
leave a complete discussion to the full version, and provide
only a brief description of our approach.

The naive approach to this problem is simply to try all
possible combinations up to a certain limit, then identify the
best resulting veriﬁer based on an estimate of total running
time. Although this approach is feasible for simple schemes,
it is quite ineﬃcient for schemes that require the application
of several techniques. Moreover, there is the separate diﬃ-
culty of determining when the algorithm should halt, as the
application of one technique will sometimes produce a new
equation that is amenable to further optimization, and this
process can continue for several operations.

Our approach is to “prune the tree” by utilizing a ﬁnite
state transition function that constrains the transitions be-
tween techniques. This function examines the history of
techniques already applied and determines which techniques
can be applied to the current state. Our search algorithm
begins with techniques 0, 1 or 2, then employs a breadth-
ﬁrst search to identify multiple candidate paths that form a
batch veriﬁer.

To prevent inﬁnite loops in the search, the state function

479lation allows it to determine the “crossover point”, i.e., the
batch size where batch veriﬁcation becomes more eﬃcient
than individual veriﬁcation.

Security Analysis. We have two points to make regard-
ing the security of AutoBatch. First, we argue that the al-
gorithm used by AutoBatch to produce a batch veriﬁcation
equation unconditionally satisﬁes Security Deﬁnition 2.2. That
is, the batch veriﬁcation equation will hold if and only if each
of the individual signatures would have passed the individual
veriﬁcation test (up to a negligible error probability).7

Theorem 3.1

(Security of AutoBatch). Let an Au-
toBatch algorithm be generalized as any algorithm that trans-
forms an individual pairing-based signature veriﬁcation test
into a pairing-based batch veriﬁcation equation as follows:

1. Check the group membership of all input elements, and
if no errors, apply Techniques 0 and 1 to the individual
veriﬁcation equation(s) using security parameter λ to
obtain a single equation X.

2. Loops until done on: Apply any of Techniques 2-9 to

X to obtain equation X(cid:48) and set X := X(cid:48).

Then all AutoBatch algorithms unconditionally satisfy Def-
inition 2.2, where the probability of accepting an invalid batch
is at most 2−λ.

Proof. We analyze this proof in two parts. First, after Step
1 (the application of Techniques 0 and 1), there will be one
batch equation X and it will satisfy the security require-
ments of Deﬁnition 2.2 with error probability 2−λ. These
two techniques combine a set of equations into a single equa-
tion using the Small Exponents Test with security parameter
λ. Ferrara et al. [26, Theorem 3.2] prove that this equation
will verify if and only if all individual equations verify, ex-
cept with probability at most 2−λ. By default in AutoBatch,
we set λ = 80.

Next, given a single arbitrary, pairing-based equation X,
we apply one of Techniques 2-9. For each Technique 2-9, we
argue that the output equation X(cid:48) holds if and only if the
input equation X holds; that is, the equations are identi-
cal up to algebraic manipulations. If this is true, the ﬁnal
batch equation output by AutoBatch satisﬁes Deﬁnition 2.2
with the same error probability as the equation output after
Techniques 0 and 1 were applied, completing the theorem.
It remains to argue that for each Technique 2-9, it is in-
deed the case that the input and output equations are iden-
tical, up to algebraic manipulations. Techniques 2, 3, 4, 6,
7 and 9 follow relatively straightforwardly from the bilin-
earity of the groups. As an example, consider Technique 6

which claims that e(a, g) · e(b, g) = e(ab, g), for all a, b ∈ G1
and g ∈ G2. Let b = ak for some k ∈ Zp. Then we have
e(a, g) · e(ak, g) as the LHS, which is e(a, g) · e(a, g)k by
the bilinearity, which is e(a, g)k+1 by multiplication in GT .
The RHS is similarly e(aak, g) = e(ak+1, g) = e(a, g)k+1.
Technique 5 requires only associativity in GT . Technique 8
pre-computes and caches some values instead of repeatedly
2
computing them on the ﬂy.

7The security of the underlying signature scheme depends on
a computational assumption, but the batcher uncondition-
ally maintains whatever security is oﬀered by the scheme.

Figure 3: A fragment of the machine-generated se-
curity proof of a single-signer batch veriﬁer for the
Camenisch-Lysyanskaya (CL) signature scheme [18].
An earlier portion of the proof asserted that a group
membership test would be done prior to checking
the ﬁnal equation.

disallows the application of certain techniques that might
potentially undo optimizations. For example, Technique 9
performs a reverse split on pairings to allow further opti-
mizations; this might aﬀect technique 6, which combines
pairings that have common elements. Certain combinations
of techniques 9 and 6 lead to an inﬁnite cycle that combines
and splits the same pairings. Thus, the state function only
allows a transition from Technique 6 to 9 to occur once on
a given path.

The search algorithm terminates when none of the tech-
niques can be applied to the current state. It then selects
the path from the candidate paths that provides the highest
cost savings. While our approach does not guarantee the
optimal batch equation, in practice we rediscover all exist-
ing lower bounds on batch veriﬁcation performance, and in
some cases we improve on results developed by humans.
3.2 Security and Machine-Aided Analysis

Eﬃciency Analysis. Once the Batcher has produced a
ﬁnal equation for the batch veriﬁer, it counts the number of
operations required as a function of the batch size. These
operations include point operations, pairings, hashes, as well
as random element generation. It then combines this opera-
tion count with a database of average operation times that
were measured at library initialization. The resulting calcu-

2ProofProof.Viaaseriesofsteps,wewillshowthatifCLisasecuresignaturescheme,thenBatchVerifyisasecurebatchveriﬁer.Webeginwiththeoriginalveriﬁcationequation.e(Y,a)?=e(g,b)ande(X,a)·e(X,b)m?=e(g,c)Step1:Consolidatetheveriﬁcationequations(tech.0),mergepairingswithcommonﬁrstorsecondelement(tech.6),andapplythesmallexponentstest,usingexponents 1,... ⌘2⇥1,2 ⇤foreachequation:e(g,b·c 1) 1,2·e(Y,a)  1?=e(X,a) 2·e(X,b)m· 2Step2:Combine⌘signatures(tech.1),movetheexponent(s)inpairing(tech.2):⌘Yz=1e(g,(bz·cz 1) 1,2,z)·e(Y,az  1,z)?=⌘Yz=1e(X,az 2,z)·e(X,bzmz· 2,z)Step3:Mergepairingswithcommonﬁrstorsecondelement(tech.6):⌘Yz=1e(g,(bz·cz 1) 1,2,z)·e(Y,az  1,z)?=⌘Yz=1e(X,az 2,z·bzmz· 2,z)Step4:Movedotproductsinsidepairingstoreducefrom⌘to1(tech.3):⌘Yz=1e(g,(bz·cz 1) 1,2,z)·e(Y,az  1,z)?=e(X,⌘Yz=1az 2,z·bzmz· 2,z)Step5:Distributedotproducts(tech.5)::⌘Yz=1e(g,(bz·cz 1) 1,2,z)·⌘Yz=1e(Y,az  1,z)?=e(X,⌘Yz=1az 2,z·bzmz· 2,z)Step6:Movedotproductsinsidepairingstoreducefrom⌘to1(tech.3):e(g,⌘Yz=1(bz·cz 1) 1,2,z)·e(Y,⌘Yz=1az  1,z)?=e(X,⌘Yz=1az 2,z·bzmz· 2,z)Steps1and2formtheCombinationStepin[21],whichwasproventoresultinasecurebatchveriﬁerin[21,Theorem3.2].Weobservethattheremainingstepsaremerelyreorganizingtermswithinthesameequation.Hence,theﬁnalveriﬁcationequation(??)isalsobatchveriﬁerforCL.2480Process
Batcher
Codegen
Total

BLS
42.0
124.3
166.3

CHP
70.1
171.7
241.8

CL
127.4
152.2
279.6

122.7
242.3
365.0

HW-diﬀ Waters09 Waters05 ChCh/Hess CYH Boyen
230.3
321.2
551.5

1169.1
291.2
1460.3

529.4
361.6
891.0

186.9
162.0
348.9

76.7
242.8
319.5

BBS VRF
209.4
302.0
251.2
315.1
617.1
460.6

Figure 4: Time in milliseconds required by the Batcher and Code Generator to process a variety of signa-
ture schemes (averaged over 100 test runs). Batcher time includes search time for the technique ordering,
generating the proof and estimating cross over point between individual and batch veriﬁcation. The running
times are a product of the complexity of each scheme as well as the number of unique paths uncovered by
our search algorithm. In all cases, the standard deviation in the results were within ±3% of the average.

To oﬀer transparency on how AutoBatch derived any given
batch veriﬁer, Batcher produces both an SDL ﬁle and, op-
tionally, a human-readable proof of security for the resulting
batch veriﬁer. This proof is a LaTeX ﬁle that includes the
individual and batch veriﬁcation equations, with an enu-
meration of the various steps used to convert the former
into the latter. Thus, while Theorem 3.1 already argues that
this proof is valid, this provides a means for independently
verifying the security of any given batching equation. Inter-
estingly, the ﬁrst proof for the batch veriﬁcation of the HW
signatures [33] was produced automatically by AutoBatch.
We show a fragment of this human-readable proof of secu-

rity for the Boneh-Lynn-Shacham (BLS) signature scheme [13]
in Figure 3. Human-readable proofs of security for some
of the other schemes against which we evaluated AutoBatch
are given in the full version of this work.

The security analysis provided in this section applies to
the mathematics only. AutoBatch goes on to convert this
mathematical batching equation into code, which could po-
tentially introduce software errors. However, our hope is
that the deliberate process by which AutoBatch generates
code would actually help reduce software errors by system-
atically including steps, such as the group membership test,
which could easily be accidentally omitted by a human im-
plementor.
3.3 Code Generation

The output of the Batcher is a batch veriﬁcation equation
encoded in SDL. This ﬁle deﬁnes all of the datatypes for the
signature, message and public key (or identity and public
parameters in the case of an identity-based signature). The
Code Generator converts this SDL representation into use-
able Python or C++ source code that can operate on real
batch inputs.

The Code Generator translates the individual and batch
veriﬁcation equations into C++ or Python code, and wraps
them with the following additional logic components:

1. Group membership tests. For each element in the
signature (and optionally the public key, if the user re-
quests)8 the membership of the group is tested using
an exponentiation. Section 2.2 discusses the impor-
tance and details of this test.

2. Pre-computation. Several values often will be re-
used within a veriﬁcation equation. When this hap-
pens, the batch veriﬁer can pre-compute certain re-
sults once, rather than needlessly compute them sev-
eral times.

8In many applications we can assume that the public keys
are trusted, thus we can omit group membership testing on
these values.

3. Technique selection. For relatively small batch sizes,
it may be more eﬃcient to bypass the batch veriﬁer
and simply verify the signatures using the individual
veriﬁcation function. For this reason, our Code Gen-
erator generates this function as well (the output of
the Batcher contains both functions), and adds logic
to programmatically choose between batch and indi-
vidual veriﬁcation when the batch size is below a cer-
tain threshold automatically determined in the Anal-
ysis phase.

4. Invalid signature detection. To handle the pres-
ence of invalid signatures in a batch, our batch veriﬁer
code includes a recursive divide-and-conquer strategy
to recover from a batching failure (see e.g,. [26] for a
discussion of this). On failure, this veriﬁer divides the
signature collection into two halves and recurses by re-
peating veriﬁcation on each half until all of the invalid
signatures have been identiﬁed.

The Code Generator consists of two “back-end” modules,
which produce Charm/Python and C++/MIRACL repre-
sentations of the batch veriﬁers. It would be relatively easy
to extend this module to add support for additional lan-
guages and settings.
3.4 Code Parsing

While SDL is the primary input language for our batcher,
we also support batching from a pre-existing implementa-
tion of a signature scheme. To facilitate this, we provide
a Code Parsing engine that interprets signature schemes
written in a high level language, derives their veriﬁcation
equation and data types, and produces a resulting SDL
ﬁle. While our techniques should work with various lan-
guages (provided that the signature implementation is some-
what constrained), our prototype implementation is based
on Charm/Python. This means we can take advantage of
a relatively large library of pre-existing Charm implemen-
tations. Additionally, in this setting we are assisted by the
Python interpreter, which grants programatic access to the
Python Abstract Syntax Tree via the compiler.ast module.
While Charm implementations are relatively constrained
in terms of their structure, a challenging aspect of code pars-
ing is identifying the type of each variable. We stress that
this problem is not unique to Python:
indeed, many stan-
dard libraries (such as the the C-based Stanford Pairing-
Based Crypto library [44]) employ abstract data types to
represent group elements. Interpreting code written using
these languages will also require techniques similar to the
ones we use.

Code parsing consists of the following stages. First, we
parse the entire signature scheme ﬁle to identify the AST
node of the signature verify() method, and then identify the

481equality comparisons in this function that are fundamen-
tally responsible for the signature veriﬁcation process. We
next build a map of variable names, types, structure, and
operations. For each assignment, we check the properties
of that assignment using a further set of heuristics. If we
determine that a given assignment is relevant, we extract
certain information about it, such as the type of the vari-
ables. We obtain this information by applying known rules
to infer type. For example, we know that certain hash calls
indicate an element of G1, a pairing indicates an element in
GT , random element generation calls typically indicate the
type of element being generated, and so on.9

IMPLEMENTATION & PERFORMANCE

4.
4.1 Experimental Setup

To evaluate the performance of our techniques we im-
plemented them as part of the Charm prototyping frame-
work [1]. Charm is a Python-based cryptographic proto-
typing framework, and provides native support for bilinear-
map based cryptography and other useful primitives, e.g.,
hashing and serialization. We used a version of Charm that
implements all bilinear group operations using the C-based
MIRACL library [56].10 The necessary MIRACL calls are
accessed from within our Python code via the C module
interface.

To determine the performance of our system in isolation,
we ﬁrst conducted a number of experiments on various com-
ponents of our code. First, we used the code parsing compo-
nent to convert several Python signature implementations
into our intermediate “SDL” representation. Next, we ap-
plied our batcher to the SDL result in order to obtain an
optimized equation for a batch veriﬁer. We then applied our
code generator to convert this representation into a func-
tioning batch veriﬁer program, which we applied to various
test data sets.

Hardware conﬁguration. For consistent results we ran all
of our experiments on a single hardware platform: a 2 x
2.66 GHz 6-Core Intel Xeon Macintosh Pro running MacOS
version 10.7.3 with 12GB of RAM. We ran all of our tests
within a single thread, and thus used resources from only a
single core of the Intel processor. We instantiated all of our
cryptographic implementations using a 160-bit MNT elliptic
curve provided with MIRACL.

A note on the library. We chose MIRACL because it is ma-
ture and well supported. However, some research libraries
like RELIC [3] provide alternative pairing implementations
that may outperform MIRACL in speciﬁc settings. We note
that our results will apply to any implementation where
there is a substantial diﬀerence between group operation and
pairing times. In our experiments with RELIC using a pro-
vided 256-bit Barreto-Naehrig curve, we observed a 6-to-1
diﬀerential between pairings and operations in G1. This in-
dicates that our main results should hold in this setting, and
will in fact improve (in that we can process a higher number

9We believe that this approach may also be useful
in
the future for static checking and formal veriﬁcation of
dynamically-typed cryptographic implementations.
10The version of Charm we used (0.42) can be found in the
Charm github repository at www.charm-crypto.com. It uses
MIRACL 5.5.4 for bilinear group operations.

of signatures). We will provide details on this alternative
implementation in the full version of this work.
4.2 Signature Schemes used as Test Cases

We ran our experiments using two sets of test cases. The
ﬁrst set was comprised of a variety of existing schemes, in-
cluding regular, identity-based, ring, group signatures and
veriﬁable random functions.

The results are summarized in Figure 5. In all cases, the
batching algorithm output by AutoBatch either matched the
prior best known result or outperformed it. In particular,
AutoBatch realized a batching algorithm for the VRF in
[34] that takes only two-thirds the time of the one provided
in [34]. Actually, when we double-checked this result by
hand, we realized that the veriﬁcation of equation 2 could
be further optimized to only (cid:96) − 1 pairings by unrolling a
constant-size loop and combining the individual veriﬁcation
equations checked at each iteration. Moreover, a portion of
the unrolled loop with the g2 term could be combined with
the corresponding term in the combined equations 1,3,4 for a
total pairing count of only (cid:96)+3 pairings to batch an arbitrary
number of VRF proofs for (cid:96)-bit inputs. We deem automatic
loop unrolling as a future technique that we will incorporate
into AutoBatch as it searches for optimal solutions.

Also of note, in test case 10, we simulated a scenario where
a batch contains a mix of two diﬀerent types of signatures.
In this case, the batch consisted of both ChCh [22] signatures
and Hess [32] signatures in a randomized order. Instead of
sorting the signatures into two groups and batching them in-
dividually, AutoBatch automatically looked for the common
algebraic structure between the two distinct schemes and ap-
plied the batching techniques described in Section 3.1. As
a generalized example, if two signature schemes both use
the same generator g, where the ﬁrst signature scheme uses
e(A, g) in its veriﬁcation equation and the second signature
scheme uses e(B, g) in its veriﬁcation equation, then Auto-
Batch will apply Technique 6 to obtain e(A · B, g) in the
combined veriﬁcation equation (as well as apply the small
exponents test). In the case of the ChCh [22] and Hess [32]
batch, this cut the total number of pairings in half. To the
best of our knowledge, this is the ﬁrst documented result for
cross-scheme signature batch veriﬁcation.

For the Hohenberger-Waters signatures [33], we assume
that each public key includes the precomputed values as sug-
gested in [33, Section 4.2]. For the case of diﬀerent signers,
we assume that the base group elements g, u, v, d, w, z, h are
chosen by a trusted third party and shared by all users. The
Waters09 scheme is derived from the Waters Dual-System
IBE of [63] using the technique described by Naor [12].

To make AutoBatch as robust as possible, we also tested it
on a second set of fabricated pairing-product equations that
we designed by hand to trigger many diﬀerent orderings on
the techniques.
4.3 Microbenchmarks

To evaluate the eﬃciency of AutoBatch, we implemented
several pairing-based signature schemes in Charm. We ran
AutoBatch to extract an SDL-based intermediate represen-
tation of the scheme’s veriﬁcation equation, an optimized
batch veriﬁer for the scheme and Python code for imple-
menting the batch veriﬁer. We measured the processing time
for each of the above steps. Our timings, averaged over 100
runs, are presented in Figure 4.

482Scheme

Type Model Ind-Verify By Hand

1. Boyen-Lynn-Shacham (BLS) [14] (same signer)
2. Camenisch-Hohenberger-Pedersen (CHP) [17] (same period)
3. Camenisch-Lysyanskaya (CL) [18] (same signer)
4. Hohenberger-Waters (HW) [33] (same signer)
5. Hohenberger-Waters (HW) [33] (diﬀ signers)
6. Waters09 [63] (same signer)
7. Hess [32]
8. Cha-Cheon (ChCh) [22]
9. Waters05 [62]
10. ChCh [22] and Hess [32] together
11. Chow-Yiu-Hui (CYH) [25]
12. Boyen [16] (same ring)
13. Boneh-Boyen-Shacham (BBS) [11]
14. VRF eq. 1,3,4 [34] (same signer)
15. VRF eq. 2 [34] (same signer)

RO
S
RO
S
P
S
P
S
P
S
P
S
RO
I
RO
I
I
P
M RO
RO
IR
P
R
G
RO
P
V
V
P

4
2

(cid:96)η + (cid:96)

3(cid:96) + 1

5η
5η

2((cid:96) − 1)η

2
4

3(cid:96) − 3

Batch-Verify Ref
[14]
[17]
none
none
none
none
[26]
[39]
[17]

2
3
5η
2η
2η
9η
2
2

z + 3

2η
3η
5η
2η
2η
9η
2η
2η
3η
2η
2η

By AutoBatch
Batch-Verify

2
3
3
4
4
13
2
2

Techniques

1,2,3

1,2,3,5,3

0,6,1,2,6,3,5,3

1,2,3,7

1,2,3,9,5,3
1,2,9,5,3,7,6

1,2,3
1,2,3,2

z + 3

2
2

1,2,3,9,7,5,3,4,6
0,1,2,3,5,3,2,6

1,2,3,2

3(cid:96) + 1

1,2,9,4,6,9,5,3

2
4

2(cid:96) − 2

1,2,6,6,5,3
0,6,1,2,3,2
1,2,3,5,3,6

[26, 39]

[26]
[26]
[26]
[34]
[34]

Figure 5: Digital Signature Schemes used as test cases in AutoBatch. For types, S stands for regular signature,
I stands for identity-based, M stands for a batch that contains a mix of two diﬀerent types of signatures,
R stands for ring, G stands for group and V stands for veriﬁable random function. For models, RO stands
for random oracle and P stands for plain. Let (cid:96) be either the size of the ring or the number of bits in the
VRF input. Let z be a security parameter that can be set to 5 in practice. To approximate veriﬁcation
performance, we count the total number of pairings needed to process η valid signatures. Unless otherwise
noted, the inputs are from diﬀerent signers. The ﬁnal column indicates the order of the techniques from
Section 3 that AutoBatch recognized as applicable and applied to obtain the resulting batch veriﬁer. The
rows in bold are the schemes where AutoBatch discovered new or improved algorithms.

To obtain our microbenchmarks, we ran AutoBatch on
several exemplary pairing-based schemes as listed in Fig-
ure 5. We then experimented with these schemes at diﬀerent
batch sizes, in order to evaluate their raw performance. The
results are presented in Figure 6.

Each graph shows the average per-signature veriﬁcation
time for a batch of η signatures, for η ranging from 1 to 100.
We conducted these tests by ﬁrst generating a collection
of η keypairs and random messages,11 then computing a
valid signature over each message. We fed each collection
to the batch veriﬁer. ID-based signatures were handled in
a similar manner, although we substitute random identities
in place of keys. For the Boyen ring signature, we generated
a group of three signing keys to construct our ring. In each
case, we averaged our results over 100 experimental runs
and computed veriﬁcation time per signature by dividing the
total batching time by the number of signatures batched.

4.4 Batch Veriﬁcation in Practice

Prior works considered the implication of invalid signa-
tures in a batch, e.g., [26, 39, 47, 48, 65]. Mainly, these works
estimated raw signature veriﬁcation times under various con-
ditions. To evaluate how signature batching might work in
real life, we constructed a simulation to determine the re-
silience of our techniques to various denial of service attacks
launched by an adversary.

Basic Model. For this experiment, we simulated a server
that veriﬁes incoming signed messages read from a network
connection. This might be a reasonable model for a busy
server-side TLS endpoint using client authentication or for
a vehicle-to-vehicle communications base station.

Our server is designed to process as many signatures as

11We used 100-byte random strings for each message. In the
case of the stateful HW signature, we batched only signa-
tures with the same counter value.

possible, and is limited only by its computational resources.12
Signatures are drawn oﬀ of the “wire” and grouped into
batches, with each batch size representing the expected num-
ber of signatures that can be veriﬁed in one second. Initially
this number is simply a guess, which is adjusted upwards
or downwards based on the time required to verify each
batch.13 This approach can lead to some transient errors
(batches that require signiﬁcantly more or less than one sec-
ond to evaluate) when the initial guess is wrong, or when
conditions change. In normal usage, however, this approach
converges on an appropriate batch size within 1-2 seconds.
4.4.1 Basic DoS Attacks
A major concern when using a batch veriﬁer is the pos-
sibility of service denial or degradation, resulting from the
presence of some invalid signatures in the batch. As de-
scribed in §3, each of our batch veriﬁers incorporates a recur-
sive divide-and-conquer strategy for identifying these invalid
signatures. This recursion comes at a price; the presence of
even a small number of invalid signatures can seriously de-
grade the performance of a batch veriﬁer.

To measure this, we simulated an adversary who injects
invalid signatures into the input stream. Under the assump-
tion that these signatures are well-mixed with the remaining
valid signatures,14 we measured the veriﬁer’s throughput.
Our adversary injects no invalid signatures for the ﬁrst sev-
eral seconds of the experiment, then gradually ramps up its
output until the number of invalid signatures received by the
veriﬁer approaches 50%.

A switch to individual veriﬁcation. Our experiments indi-

12This models a server that delays, drops or redirects the
signatures that it cannot handle (e.g., via load balancing).
13The adjustment is handled in a relatively naive way: the
server simply computes the next batch size by extrapolating
based on its time to compute the previous batch.
14In practice, this is not a strong assumption, as a server can
simply randomize the order of the signatures it receives.

483Figure 6: Signature scheme microbenchmarks for Waters09 [63], HW [33] and CL [18] public-key signatures
(same signer), the VRF [34] (with block size of 8), combined veriﬁcation of ChCh+Hess IBS [22,32], and Boyen
ring signature (3 signer ring) [16]. Per-signature times were computed by dividing total batch veriﬁcation
time by the number of signatures veriﬁed. All trials were conducted with 100 iterations. Variation in running
time between trials of the same signature size were minimal for each scheme. Note that in one HW case, all
signatures are formulated by the same signer (as for certiﬁcate generation). All other schemes are without
such restrictions. Individual veriﬁcation times are included for comparison.

cate that batch veriﬁcation performance exceeds that of in-
dividual veriﬁcation even in the presence of a relatively large
fraction of invalid signatures. However, at a certain point
the batch veriﬁer inevitably begins to underperform individ-
ual veriﬁcation.15 To address this, we implemented a “coun-
termeasure” in our batch veriﬁer to automatically switch to
individual veriﬁcation whenever it detects the presence of a
signiﬁcant fraction of invalid signatures.

Analysis of results. We tested the batch veriﬁer on the
single-signer BLS scheme with and without the individual-
veriﬁcation countermeasure. See Figure 7. Throughput is
quite sensitive to even small numbers of invalid signatures
in the input stream. Yet, when comparing batch veriﬁca-
tion to individual veriﬁcation throughput, even under a sig-
niﬁcant attack batch veriﬁcation dramatically outperforms
individual veriﬁcation (up to approximately 15% ratio of
invalid signatures). Similarly, the switch to individual ver-
iﬁcation is a useful countermeasure for attacks that exceed
approximately 20% invalid signatures. While these thresh-
old switches do not thwart DoS attacks, they do provide
some mitigation of the potential damage.

5. CONCLUSION

The batch veriﬁcation of pairing-based signatures is a great
ﬁt for applications where short signatures are a design re-

15The reason for this is easy to explain: since our batch ver-
iﬁer handles invalid signatures via a divide-and-conquer ap-
proach (cutting the signature batch into halves, and recurs-
ing on each half), at a certain point the number of “extra”
operations exceeds those required for individual veriﬁcation.

quirement and yet high veriﬁcation throughput is required,
such as car-to-car communications [21,57]. This work demon-
strates for the ﬁrst time that the design of these batching
algorithms can be eﬃciently and securely automated.

The next step is to tackle the automated design of more
complex functionalities, where it may be infeasible to repli-
cate a theorem like Theorem 3.1 arguing that automated
design process unconditionally preserves security.
In this
case, one might instead focus on having the design tool also
output a proof sketch that could be fed into and veriﬁed by
EasyCrypt [8] or a similar proof checking tool. Indeed, what
are the natural settings where the creativity of the design
process can be feasibly replaced by an extensive computer-
ized search (perhaps with smart pruning)? Can the “proof
sketches” needed for veriﬁcation by EasyCrypt be generated
automatically for these designs? These are exciting ques-
tions which could fundamentally change cryptography.

On the implementation of AutoBatch, future work could
be more resilient to DoS and related attacks by implement-
ing alternative techniques for recognizing invalid signatures
in a batch, e.g., [39, 47, 48, 65]. We are continuously on
the lookout for more eﬃcient means of computing in bilin-
ear groups. Future versions of AutoBatch will support the
RELIC toolkit [3] and MIRACL’s API for computing “mul-
tipairings” (eﬃcient products of multiple bilinear pairings).
It would be interesting to understand how these and future
inclusions may impact performance.

Acknowledgments
Joseph A. Akinyele and Matthew W. Pagano are supported
in part by NSF CNS-1010928 and HHS 90TR0003/01.

 0 20 40 60 80 100 120 20 40 60 80 100ms per signatureNumber of signaturesMNT160WATERS09 (batched)WATERS09 (individual) 0 5 10 15 20 25 20 40 60 80 100ms per signatureNumber of signaturesMNT160HW-Single (batched)HW-Multiple (batched)HW (individual) 0 10 20 30 40 50 20 40 60 80 100ms per signatureNumber of signaturesMNT160CL (batched)CL (individual) 0 20 40 60 80 100 120 140 160 20 40 60 80 100ms per signatureNumber of signaturesMNT160VRF (batched)VRF (individual) 0 5 10 15 20 25 30 35 40 45 20 40 60 80 100ms per signatureNumber of signaturesMNT160CHCHHESS (batched)CHCHHESS (individual) 0 10 20 30 40 50 60 70 80 20 40 60 80 100ms per signatureNumber of signaturesMNT160BOYEN (ring=3)BOYEN (ring=3)484Figure 7: Simulated service denial attacks against a batch veriﬁer (BLS signatures, single signer). The grey
line (right scale) shows the fraction of invalid signatures in the stream. Batcher throughput is measured in
signatures per second (left scale). The broken line depicts a standard batch veriﬁer. The black line is a batch
veriﬁer that automatically switches to individual veriﬁcation when batching becomes suboptimal.

Matthew Green is supported in part by the Defense Ad-
vanced Research Projects Agency (DARPA) and the Air
Force Research Laboratory (AFRL) under contract FA8750-
11-2-0211, the Oﬃce of Naval Research contract N00014-11-
1-0470, NSF grant CNS-1010928 and HHS 90TR0003/01.

Susan Hohenberger is supported in part by NSF CNS-
1154035, the Oﬃce of Naval Research under contract N00014-
11-1-0470, DARPA and the Air Force Research Laboratory
(AFRL) under contract FA8750-11-2-0211, DARPA contract
N11AP20006 and a Microsoft Faculty Fellowship.

Applying to all authors, the contents and views expressed
are solely those of the authors and do not reﬂect the oﬃcial
policy, position or views of the Department of Defense, the
HHS or the U.S. Government.

6. REFERENCES
[1] Akinyele, J. A., Green, M., and Rubin, A.

Charm: A framework for rapidly prototyping
cryptosystems. Cryptology ePrint Archive, Report
2011/617, 2011. http://eprint.iacr.org/.

[2] Almeida, J. B., Bangerter, E., Barbosa, M.,

Krenn, S., Sadeghi, A.-R., and Schneider, T. A
certifying compiler for zero-knowledge proofs of
knowledge based on σ-protocols. In Proceedings of the
15th European conference on Research in computer
security (Berlin, Heidelberg, 2010), ESORICS’10,
Springer-Verlag, pp. 151–167.

[3] Aranha, D. F., and Gouvˆea, C. P. L. RELIC is an

Eﬃcient LIbrary for Cryptography.
http://code.google.com/p/relic-toolkit/.

[4] Backes, M., Maffei, M., and Unruh, D.

Zero-knowledge in the applied pi-calculus and
automated veriﬁcation of the direct anonymous
attestation protocol. In Proceedings of the 2008 IEEE
Symposium on Security and Privacy (Washington,
DC, USA, 2008), SP ’08, IEEE Computer Society,
pp. 202–215.

[5] Bangerter, E., Briner, T., Henecka, W., Krenn,

S., Sadeghi, A.-R., and Schneider, T. Automatic
generation of sigma-protocols. In Proceedings of the
6th European conference on Public key infrastructures,

services and applications (Berlin, Heidelberg, 2010),
EuroPKI’09, Springer-Verlag, pp. 67–82.

[6] Barak, B., Canetti, R., Nielsen, J. B., and Pass,

R. Universally composable protocols with relaxed
set-up assumptions. In FOCS (2004), IEEE Computer
Society, pp. 186–195.

[7] Barbosa, M., Moss, A., and Page, D. Compiler

assisted elliptic curve cryptography. In Proceedings of
the 2007 OTM confederated international conference
on On the move to meaningful internet systems:
CoopIS, DOA, ODBASE, GADA, and IS - Volume
Part II (Berlin, Heidelberg, 2007), OTM’07,
Springer-Verlag, pp. 1785–1802.

[8] Barthe, G., Gr´egoire, B., Heraud, S., and

B´eguelin, S. Z. Computer-aided security proofs for
the working cryptographer. In CRYPTO (2011),
pp. 71–90.

[9] Bellare, M., Garay, J. A., and Rabin, T. Fast
batch veriﬁcation for modular exponentiation and
digital signatures. In EUROCRYPT ’98 (1998),
vol. 1403 of LNCS, Springer, pp. 236–250.

[10] Blazy, O., Fuchsbauer, G., Izabach`ene, M.,

Jambert, A., Sibert, H., and Vergnaud, D. Batch
groth-sahai. In ACNS ’10 (2010), Springer,
pp. 218–235.

[11] Boneh, D., Boyen, X., and Shacham, H. Short

group signatures. In CRYPTO ’04 (2004), vol. 3152 of
LNCS, pp. 45–55.

[12] Boneh, D., and Franklin, M. K. Identity-based

encryption from the Weil pairing. In CRYPTO (2001),
pp. 213–229.

[13] Boneh, D., Lynn, B., and Shacham, H. Short

signatures from the Weil pairing. In ASIACRYPT ’01
(2001), vol. 2248 of LNCS, pp. 514–532.

[14] Boneh, D., Lynn, B., and Shacham, H. Short

signatures from the Weil pairing. Journal of
Cryptology 17(4) (2004), 297–319.

[15] Boyd, C., and Pavlovski, C. Attacking and

repairing batch veriﬁcation schemes. In Advances in

 0 100 200 300 400 500 600 700 800 0 10000 20000 30000 40000 50000 60000 70000 0 0.1 0.2 0.3 0.4 0.5Signatures / secInvalid Signatures as Fraction of TotalCumulative Time (ms)AutoBatch Performance During DoS AttackBatch + Individual VerifierBatch-Only VerifierInvalid Signatures as Fraction of Total485Cryptology – ASIACRYPT ’00 (2000), vol. 1976,
pp. 58–71.

[16] Boyen, X. Mesh signatures: How to leak a secret

with unwitting and unwilling participants. In
EUROCRYPT (2007), vol. 4515, pp. 210–227.

[17] Camenisch, J., Hohenberger, S., and Pedersen,

M. Ø. Batch veriﬁcation of short signatures. In
EUROCRYPT ’07 (2007), vol. 4515 of LNCS,
Springer, pp. 246–263. Full version at
http://eprint.iacr.org/2007/172.

[18] Camenisch, J., and Lysyanskaya, A. Signature
schemes and anonymous credentials from bilinear
maps. In CRYPTO ’04 (2004), vol. 3152 of LNCS,
Springer, pp. 56–72.

[19] Camenisch, J., Rohe, M., and Sadeghi, A.

Sokrates - a compiler framework for zero- knowledge
protocols. In Proceedings of the Western European
Workshop on Research in Cryptology (2005),
WEWoRC 2005.

[20] Cao, T., Lin, D., and Xue, R. Security analysis of

some batch verifying signatures from pairings.
International Journal of Network Security 3, 2 (2006),
138–143.

[21] Car 2 Car. Communication consortium.

http://car-to-car.org.

[22] Cha, J. C., and Cheon, J. H. An identity-based

signature from gap Diﬃe-Hellman groups. In PKC ’03
(2003), vol. 2567 of LNCS, Springer, pp. 18–30.

[23] Chatterjee, S., and Sarkar, P. HIBE with short

public parameters without random oracle. In
ASIACRYPT ’06 (2006), vol. 4284 of LNCS,
pp. 145–160.

[24] Chaum, D., and van Heyst, E. Group signatures. In

EUROCRYPT (1991), pp. 257–265.

[25] Chow, S. S. M., Yiu, S.-M., and Hui, L. C.
Eﬃcient identity based ring signature. In ACNS
(2005), vol. 3531 of LNCS, pp. 499–512.

[26] Ferrara, A. L., Green, M., Hohenberger, S.,

and Pedersen, M. Ø. Practical short signature
batch veriﬁcation. In CT-RSA (2009), vol. 5473 of
LNCS, pp. 309–324.

[27] Fiat, A. Batch RSA. In Advances in Cryptology –

CRYPTO ’89 (1989), vol. 435, pp. 175–185.

[28] Goldwasser, S., Micali, S., and Rivest, R. L. A

digital signature scheme secure against adaptive
chosen-message attacks. SIAM J. Computing 17(2)
(1988).

[29] Harn, L. Batch verifying multiple DSA digital

signatures. Electronics Letters 34(9) (1998), 870–871.

[30] Harn, L. Batch verifying multiple RSA digital

signatures. Electronics Letters 34(12) (1998),
1219–1220.

[31] Henecka, W., K ¨ogl, S., Sadeghi, A.-R.,

Schneider, T., and Wehrenberg, I. Tasty: tool for
automating secure two-party computations. In
Proceedings of the 17th ACM conference on Computer
and communications security (New York, NY, USA,
2010), CCS ’10, ACM, pp. 451–462.

[32] Hess, F. Eﬃcient identity based signature schemes
based on pairings. In Selected Areas in Cryptography
(2002), vol. 2595 of LNCS, Springer, pp. 310–324.

[33] Hohenberger, S., and Waters, B. Realizing

hash-and-sign signatures under standard assumptions.
In EUROCRYPT (2009), pp. 333–350.

[34] Hohenberger, S., and Waters, B. Constructing

veriﬁable random functions with large input spaces. In
EUROCRYPT (2010), pp. 656–672.

[35] Hwang, M.-S., Lee, C.-C., and Tang, Y.-L. Two
simple batch verifying multiple digital signatures. In
3rd Information and Communications Security
(ICICS) (2001), pp. 233–237.

[36] Hwang, M.-S., Lin, I.-C., and Hwang, K.-F.

Cryptanalysis of the batch verifying multiple RSA
digital signatures. Informatica, Lithuanian Academy
of Sciences 11, 1 (2000), 15–19.

[37] Kiyomoto, S., Ota, H., and Tanaka, T. A security

protocol compiler generating c source codes. In
Proceedings of the 2008 International Conference on
Information Security and Assurance (isa 2008)
(Washington, DC, USA, 2008), ISA ’08, IEEE
Computer Society, pp. 20–25.

[38] Laih, C.-S., and Yen, S.-M. Improved digital
signature suitable for batch veriﬁcation. IEEE
Transactions on Computers 44, 7 (1995), 957–959.

[39] Law, L., and Matt, B. J. Finding invalid signatures
in pairing-based batches. In Cryptography and Coding
(2007), vol. 4887 of LNCS, pp. 34–53.

[40] Lee, S., Cho, S., Choi, J., and Cho, Y. Eﬃcient
identiﬁcation of bad signatures in RSA-type batch
signature. IEICE Transactions on Fundamentals of
Electronics, Communications and Computer Sciences
E89-A, 1 (2006), 74–80.

[41] Lim, C., and Lee, P. Security of interactive DSA

batch veriﬁcation. In Electronics Letters (1994),
vol. 30(19), pp. 1592–1593.

[42] Lowe, G. Casper: a compiler for the analysis of
security protocols. J. Comput. Secur. 6, 1-2 (Jan.
1998), 53–84.

[43] Lucks, S., Schmoigl, N., and Tatli, E. I. Issues on

designing a cryptographic compiler. In WEWoRC
(2005), pp. 109–122.

[44] Lynn, B. The Stanford Pairing Based Crypto Library.

Available from http://crypto.stanford.edu/pbc.
[45] MacKenzie, P., Oprea, A., and Reiter, M. K.

Automatic generation of two-party computations. In
Proceedings of the 10th ACM conference on Computer
and communications security (New York, NY, USA,
2003), CCS ’03, ACM, pp. 210–219.

[46] Malkhi, D., Nisan, N., Pinkas, B., and Sella, Y.
Fairplay – a secure two-party computation system. In
Proceedings of the 13th conference on USENIX
Security Symposium - Volume 13 (Berkeley, CA, USA,
2004), SSYM’04, USENIX Association, pp. 20–20.

[47] Matt, B. J. Identiﬁcation of multiple invalid

signatures in pairing-based batched signatures. In
Public Key Cryptography (2009), pp. 337–356.
[48] Matt, B. J. Identiﬁcation of multiple invalid

pairing-based signatures in constrained batches. In
Pairing (2010), pp. 78–95.

[49] Meiklejohn, S., Erway, C. C., K¨up¸c¨u, A., Hinkle,

T., and Lysyanskaya, A. Zkpdl: a language-based
system for eﬃcient zero-knowledge proofs and

486electronic cash. In Proceedings of the 19th USENIX
conference on Security (Berkeley, CA, USA, 2010),
USENIX Security’10, USENIX Association, pp. 13–13.

[50] Micali, S., Rabin, M. O., and Vadhan, S. P.

Veriﬁable random functions. In FOCS (1999),
pp. 120–130.

[51] Naccache, D. Secure and practical identity-based

encryption, 2005. Cryptology ePrint Archive: Report
2005/369.

[52] Naccache, D., M’Ra¨ıhi, D., Vaudenay, S., and
Raphaeli, D. Can DSA be improved? complexity
trade-oﬀs with the digital signature standard. In
Advances in Cryptology – EUROCRYPT ’94 (1994),
vol. 950, pp. 77–85.

[53] Perez, L. J. D., and Scott, M. Designing a code

generator for pairing based cryptographic functions. In
Proceedings of the 4th international conference on
Pairing-based cryptography (Berlin, Heidelberg, 2010),
Pairing’10, Springer-Verlag, pp. 207–224.

[54] Pozza, D., Sisto, R., and Durante, L. Spi2java:

Automatic cryptographic protocol java code
generation from spi calculus. In Proceedings of the
18th International Conference on Advanced
Information Networking and Applications - Volume 2
(Washington, DC, USA, 2004), AINA ’04, IEEE
Computer Society, pp. 400–.

[55] Rivest, R. L., Shamir, A., and Tauman, Y. How

to leak a secret. In ASIACRYPT (2001), pp. 552–565.

[56] Scott, M. Multiprecision Integer and Rational

Arithmetic C/C++ Library (MIRACL), Oct. 2007.
Published by Shamus Software Ltd.,
http://www.shamus.ie/.

[57] SeVeCom. Security on the road.

http://www.sevecom.org.

[58] Shacham, H., and Boneh, D. Improving SSL

handshake performance via batching. In
Cryptographer’s Track at RSA Conference ’01 (2001),
vol. 2020, pp. 28–43.

[59] Shamir, A. Identity-based cryptosystems and

signature schemes. In CRYPTO (1984), pp. 47–53.
[60] Song, D. X., Perrig, A., and Phan, D. Agvi -

automatic generation, veriﬁcation, and
implementation of security protocols. In Proceedings of
the 13th International Conference on Computer Aided
Veriﬁcation (London, UK, UK, 2001), CAV ’01,
Springer-Verlag, pp. 241–245.

[61] Stanek, M. Attacking LCCC batch veriﬁcation of
RSA signatures, 2006. Cryptology ePrint Archive:
Report 2006/111.

[62] Waters, B. Eﬃcient identity-based encryption

without random oracles. In EUROCRYPT ’05 (2005),
vol. 3494 of LNCS, Springer, pp. 320–329.

[63] Waters, B. Dual System Encryption: Realizing Fully
Secure IBE and HIBE under Simple Assumptions. In
CRYPTO (2009), pp. 619–636.

[64] Yoon, H., Cheon, J. H., and Kim, Y. Batch
veriﬁcations with ID-based signatures. In ICISC
(2004), Lecture Notes in Computer Science,
pp. 233–248.

[65] Zaverucha, G. M., and Stinson, D. R. Group

testing and batch veriﬁcation. In Proceedings of the
4th international conference on Information theoretic
security (Berlin, Heidelberg, 2010), ICITS’09,
Springer-Verlag, pp. 140–157.

[66] Zhang, F., and Kim, K. Eﬃcient ID-based blind

signature and proxy signature from bilinear pairings.
In 8th Information Security and Privacy, Australasian
Conference (ACISP) (2003), vol. 2727, pp. 312–323.

[67] Zhang, F., Safavi-Naini, R., and Susilo, W.

Eﬃcient veriﬁably encrypted signature and partially
blind signature from bilinear pairings. In Progress in
Cryptology – INDOCRYPT ’03 (2003), vol. 2904,
pp. 191–204.

487