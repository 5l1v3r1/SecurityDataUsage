following. In any IC, each logic gate is one of a set of gate-
types, for example, XOR, NAND or NOR. A camouﬂaged
gate is one whose gate-type cannot be determined by reverse
engineering. That is, from the standpoint of an attacker that
carries out reverse engineering, the gate may be any one of
the possible gate-types. When inputs are applied, however, a
camouﬂaged gate still performs the function as intended by
the designer, for example, XOR, to produce the correct output.
Rajendran et al. [20] provide an excellent description as to how
a gate can be camouﬂaged in practice.

IC camouﬂaging technology has been adopted commer-
cially, for example by Inﬁneon [1], a major semiconductor
vendor of embedded computing devices for mobility and secu-
rity applications. The technology seems particularly attractive
in the context of small ICs, e.g., those with only a few 100’s or
1000’s of gates, which are common in modern embedded and
mobile devices. It appears that even for such small ICs, with
only a small fraction of the gates camouﬂaged, the security
attained is very high — we discuss this more below and in
Section II.

Figure 1 shows an example from prior work [20] of a net-
list with three logic gates, two of which are camouﬂaged. An
attacker who wishes to decamouﬂage a circuit, i.e., determine
the Boolean functionality (or identity) of the camouﬂaged
gates, does so by applying input patterns and generating the
corresponding output pattern. An input pattern is a bit-string
that assigns a boolean value to each input pin of a circuit. The
attacker then analyzes these pairs of input-output patterns to
determine the identities of camouﬂaged gates. We call a set
of input patterns that is sufﬁcient to decamouﬂage a circuit a
discriminating set of inputs for that camouﬂaged circuit. (See
Section III-A for a more precise deﬁnition.)

The application of each new input pattern comes at a cost
to the attacker. This is because applying an input pattern and
observing its output pattern takes some time. The attacker’s
objective, therefore, is to exercise the camouﬂaged circuit with
as few distinct input patterns as possible. That is, he seeks a
discriminating set of minimum size. On the other hand, the
defender seeks to ensure that the size of every discriminating
set is large.

To do so, a defender camouﬂages as many gates as she can.
However, camouﬂaged gates use more area, consume more
power and are slower than gates that are not camouﬂaged. That
is, camouﬂaging comes at a cost to the defender. This sets up
a cost-security trade-off from the perspective of the defender,
i.e., the defender can obtain greater security at the expense
of increased circuit area, delay and power. However, ICs in
the embedded computing domain are particularly sensitive
to cost, particularly the chip footprint (or area) and power
consumption.

One of the main contributions of prior work [20] is that
this cost-security trade-off can be made to heavily favor the
defender by choosing the gates to be camouﬂaged judiciously.
For instance, given an attacker that can exercise a billion
inputs a second and a benchmark circuit of more than 2400
gates,
there exists a set of only 63 gates (only 2.6% of
the gates in the circuit) that if camouﬂaged, would take the
attacker “several thousands of years” to identify [20]. The work
proposes techniques to discover such small sets of gates so the

cost of camouﬂaging is low, but the difﬁculty for the attacker
is exponential
in the number of camouﬂaged gates. Their
results suggest that if applied carefully, IC camouﬂaging can
be an effective defense mechanism against reverse engineering
attacks.

Our work We re-examine the assertions of prior work [20],
[25] for realistic benchmark circuits. For those circuits, such
work suggests that by camouﬂaging only a small, appropriately
selected, set of gates, “. . . the attacker is forced to do brute
force,” which, as we mention above, for an attacker that is able
to exercise the circuit with a billion input patterns a second,
translates to “several thousands of years” [20].

Counter to such results, we have discovered that with
the same number of gates chosen in the same manner as
that work proposes for camouﬂaging, an attacker can ﬁnd a
correct completion (i.e., decamouﬂage the circuit) in only a
few minutes, and not thousands of years. We have devised
and implemented a new attack procedure for this, which is the
focus of our paper.

Underlying our work is a fresh, complexity-theoretic mind-
set to the problem of IC decamouﬂaging. This mindset, in
turn, suggests the attack procedure that we have designed
and implemented. We examine problems that underlie two
basic questions: (1) Is a given set of input patterns, I, a
discriminating set for a camouﬂaged circuit C? (2) If so, what
is a correct assignment of boolean functionalities (or identities)
for each camouﬂaged gate in C? By iteratively calling a solver
for the problem that corresponds to (1), we are able to obtain a
discriminating input set. We then call a solver for the problem
that corresponds to (2) to decamouﬂage C. As we discuss in
Section III, each call to a solver for problem (1) either returns a
new input pattern, or determines that the current set is sufﬁcient
to decamouﬂage the circuit.

Our solvers for the two problems above are based on the
observation that the decision version of problem (1) is in co-
NP, and that of problem (2) is in NP. NP is the class of
decision problems that can be solved efﬁciently using a non-
deterministic Turing machine; a decision problem is in co-NP
if its complement is in NP [2]. (We in fact show, in addition,
that the two problems are complete for their respective classes
— see Section III.) Thus, there exist efﬁcient reductions from
the complement of problem (1) and from problem (2) to CNF-
SAT, the problem of determining whether a boolean formula
in conjunctive normal form is satisﬁable. Via the reductions,
therefore, we can leverage off-the-shelf SAT solvers such as
Minisat [11].

Contributions We make a number of novel contributions
that shed new light on the (in)effectiveness of the IC camou-
ﬂaging techniques from prior work.

• We express the underlying problems an attacker solves
to decamouﬂage a camouﬂaged circuit precisely and
characterize their computational complexity. We es-
tablish that the problems are in co-NP and in NP,
respectively. In this context, we introduce the notion
of a discriminating set of input patterns that serves as
a sound measure of what an attacker must determine
to be successful. We also identify that these problems

2

Based on this counter-example, we conclude that the as-
sertion in prior work that an attacker has to resort to a brute
force attack if all the camouﬂaged gates are picked using the
largest-clique technique is too conservative.

In the next section we propose a new IC decamouﬂaging
attack based on a complexity-theoretic characterization of
the IC decamouﬂaging problem. We show that by using our
attack procedure, the attacker can decamouﬂage circuits within
minutes that would otherwise take an impractically long time
using brute force.

III.

IC DECAMOUFLAGING: OUR ATTACK

We now describe our attack. We ﬁrst adopt some termi-
nology for ease of exposition. We refer to the original circuit
before camouﬂaging as C. We emphasize that C is available
to the attacker as a black-box only. That is, the only thing an
attacker can do with C is to apply input patterns, and observe
the corresponding output patterns. We refer to the camouﬂaged
version of C as C. The circuit C has n input bits, m output
bits and k camouﬂaged gates. For instance, in Figure 1, the
circuit has n = 4 input bits, m = 1 output bits and k = 2
camouﬂaged gates.

Let L be the set of all possible gate types. For example,
for the circuit in Figure 1, L = {XOR, NAND, NOR}. Let X
be a function X: [1, k] −→ L. That is, if we arbitrarily assign
the indices 1, . . . , k to the k camouﬂaged gates, the function
X maps each camouﬂaged gate to one of the allowed gate
types. We call X a completion of C, and denote the completed
circuit as CX. Note that CX does not necessarily have the same
functionality as C. In Deﬁnition 1 below, we deﬁne a correct
completion. But before that, we need to introduce some more
terminology.

An input pattern i is an n bit boolean vector that assigns
a boolean value to each input pin. The set of all possible
input patterns is denoted as I = {0, 1}n. Any subset I ⊆ I
is referred to as a set of input patterns. C(i) represents the
m bit output of the black-box circuit for input pattern i.
Correspondingly, CX (i) represents the m bit output of the
camouﬂaged circuit C completed with X.

A correct completion of the camouﬂaged circuit C is now

deﬁned as follows.
Deﬁnition 1. [Correct Completion1] A completion X is re-
ferred to as a correct completion if and only if:

∀i ∈ I, CX (i) = C(i)

That is, a correct completion is an assignment of gates to all
the camouﬂaged gates such that the resultant circuit produces
the same output for every input, as the black-box camouﬂaged
circuit. The goal of the attacker is to ﬁnd a correct completion.
Note that our deﬁnition above accounts for the possibility that
there can be more than one correct completion. If an attacker
is able to arrive at any one correct completion, then he has
successfully accomplished his goal which is to reverse engineer
the (Boolean functionality of the) camouﬂaged circuit.

1We refer to a completion that is not correct as an incorrect completion.

A. Discriminating Set of Input Patterns

We now characterize the notion of a discriminating set of
input patterns, and the computational complexity of deciding
whether a given set of input patterns is discriminating. Before
we do so in Deﬁnition 3 below, we deﬁne what we call the
Set of Candidate Completions for a set of inputs I.
Deﬁnition 2. [Set of Candidate Completions] The set of
candidate completions, P(I), for a set of input patterns I
comprises those completions that have the same output as the
black-box circuit for all inputs in I. That is,

P(I) = {X | ∀i ∈ I, CX (i) = C(i)}.

Given I, a member of the set of candidate completions for
it, X ∈ P(I), necessarily agrees with the black-box circuit
only on the inputs in I. As a correct completion must agree
with the black-box camouﬂaged circuit on all inputs, P(I)
certainly contains all correct completions, and perhaps some
incorrect completions. And this is the case for every I ⊆ I.
We express this via the following lemma, which is in turn used
to prove Theorem 1 below.
Lemma 1. Given a camouﬂaged circuit C, any I ⊆ I, and
the set of candidate completions, P(I) for it. P(I) contains
all correct completions of C.

Proof: A correct completion agrees with the camouﬂaged
circuit on all inputs. Therefore, it agrees with the camouﬂaged
circuit on every subset I of all inputs.

for

In Figure 3,

instance, when I consists of only
one input pattern ‘0000,’ the set P(I) consists of 4 can-
didate completions. These include the correct completion
(G1=NAND, G2=NOR) but also three other incorrect com-
pletions (G1=NAND, G2=NAND; G1=NOR, G2=NAND; and
G1=NOR, G2=NOR). However, when I consists of all 4 input
patterns indicated in Figure 3, P(I) consists of only one
completion, which is the correct completion. Such a set of
input patterns that distinguishes the correct completion(s) from
all incorrect completions is referred to as a discriminating set
of inputs patterns, or simply a discriminating set. We deﬁne it
as follows.
Deﬁnition 3. [Discriminating Set] A set of input patterns I ⊆
I is discriminating for a camouﬂaged circuit C if

∀X1, X2 ∈ P(I) and ∀i ∈ I,

CX1 (i) = CX2(i)

(1)

Intuition
The intuition behind our characterization of a
discriminating set I is the following. Suppose we have two
completions X1, X2 that are both in the set of candidate
completions P(I). Then, we deem I to be a discriminating
set if the fact that CX1 agrees with CX2 on all inputs in I
implies that CX1 and CX2 agree on all possible inputs.

We can now establish that given P(I) for I that is discrim-
inating, every member of P(I) must be a correct completion.
This is exactly the value of the notion of a discriminating set
— it distinguishes a correct completion from an incorrect one.
Theorem 1. Given I ⊆ I that is a discriminating set, suppose
P(I) = {X1, . . . , Xn}. Then, all of X1, . . . , Xn are correct
completions of C.

5

Proof: Assume otherwise, for the purpose of contra-
diction. Then at least one of X1, . . . , Xn is not a correct
completion. That is, for some X ∈ P(I), there exists an input
in the set of all inputs, i ∈ I, such that CX (i) (cid:54)= C(i). But
as I is discriminating, we know that CX1, . . . , CXn agree on
all inputs, i.e., all i ∈ I. Therefore, none of X1, . . . , Xn is a
correct completion. But this contradicts Lemma 1.

Of course, the set of all inputs, I, is discriminating. But the
question that is most relevant to us is whether there is some
I ⊂ I that is discriminating for a given camouﬂaged circuit.
In particular, an attacker seeks an I that is small because this
allows him to reverse engineer the camouﬂaged circuit quickly
— empirically, we ﬁnd that our attack procedure indeeds
succeeds in doing so.

Attack methodology Our attack methodology is to ﬁrst
identify such a discriminating set of inputs, and then use it
to correctly complete the camouﬂaged circuit. Towards this,
we ﬁrst characterize the problem of determining if a given set
of input patterns, I, is discriminating.
Deﬁnition 4. We deﬁne DISC-SET-DEC to be the following
decision problem. Given the following three inputs: (i) a
camouﬂaged circuit C, (ii) I, a set of input patterns, and (iii)
the set of outputs obtained from applying input patterns in I to
the black-box circuit, i.e., C(I) = {C(i1), . . . ,C(in)}, where
I = {i1, . . . , in}. Is I a discriminating set for C?
Theorem 2. DISC-SET-DEC is in co-NP.

Proof: We prove the above by showing that the comple-
ment of DISC-SET-DEC, which we call NOT-DISC-SET-DEC, is in
NP. NOT-DISC-SET-DEC is the problem, given the same inputs,
of determining whether I is not a discriminating set of input
patterns. A problem is in NP if it has an efﬁciently sized proof
(a certiﬁcate) for every true instance of the problem that can
be veriﬁed efﬁciently [2]. “Efﬁcient,” in this context, means
polynomial in the size of the inputs. For NOT-DISC-SET-DEC,
such a certiﬁcate consists of two distinct completions X1 and
X2, and a new input pattern i(cid:48) (cid:54)∈ I such that the following two
conditions hold. First,

CX1 (i) = CX2 (i) = C(i) ∀i ∈ I,

Second,

CX1(i(cid:48)) (cid:54)= CX2 (i(cid:48)).

X1 and X2 are both in the set of candidate completions, P(I),
but do not agree with each other on the input i(cid:48). The existence
of such a certiﬁcate establishes that I is not a discriminating
set, because Equation (1) in Deﬁnition 3 is not satisﬁed. Such
a certiﬁcate is linear in the size of the input, because each of
X1, X2, i(cid:48) can be encoded with size at worst the size of C.
Verifying the certiﬁcate can also be done in time polynomial
in the input. All we do is check: (1) that each of X1, X2 is
a completion of C, which is linear-time in the size of C, (2)
that CX1 (i) = CX2(i) for all i ∈ I, which can be done in
time linear in the size of C for each i, for a total time of
O(|C| · |I|), and (3) that CX1(i) (cid:54)= CX2(i), which can be
done in time linear in the size of C.

A consequence of Theorem 2 is that NOT-DISC-SET-DEC
can be efﬁciently reduced to a problem that is complete for

the complexity class NP, such as CNF-SAT. A SAT solver
can then be used to generate a certiﬁcate for NOT-DISC-SET-
DEC, which also serves as a counter-example for the orginal
problem DISC-SET-DEC. As we discuss below, the certiﬁcate is
useful in constructing a discriminating input set I for C.
Theorem 3. DISC-SET-DEC is co-NP-complete.

The proof is in the appendix, and establishes that NOT-DISC-
SET-DEC is NP-complete. Then, by deﬁnition, its complement
DISC-SET-DEC is co-NP-complete [2]. Theorem 3 is not neces-
sary for there to exist an efﬁcient reduction to SAT; Theorem
2 alone sufﬁces. However, it does suggest that seeking an
efﬁcient algorithm for DISC-SET-DEC would be naive given the
customary assumption that P (cid:54)= NP. Even though a SAT
solver cannot fully address the intractability that is inherent
in DISC-SET-DEC, it has been observed that such solvers can
be surprisingly effective for large classes of input instances,
particularly those that arise in practice. Thus, it makes sense
for us to reduce NOT-DISC-SET-DEC to SAT, and use a SAT
solver.

B. Determining a Correct Completion

Assuming that the attacker is able to ﬁnd a discriminating
set of input patterns I, the problem that remains for him is to
ﬁnd a correct completion of the camouﬂaged circuit C. The
following decision problem captures this.
Deﬁnition 5. We deﬁne COMPLETION-DEC to be the following
decision problem. Given the following three inputs: (i) a
camouﬂaged circuit C, (ii) I, a set of input patterns, and
(iii) the output patterns obtained from applying input patterns
in I on the black-box circuit, i.e., C(I). Does there exist a
completion X such that ∀i ∈ I, CX (i) = C(i)?

One may ask why we care to pose COMPLETION-DEC, given
that the only instances of it of interest to us are those in which
the camouﬂaged circuit C that we input has a correct comple-
tion, i.e., those in which the answer to the decision problem
is always ‘yes.’ We address this question after characterizing
the the computational complexity of COMPLETION-DEC below.
Theorem 4. COMPLETION-DEC is in NP.

Proof: We need to show that for every true instance,
there exists an efﬁciently sized certiﬁcate that can be veriﬁed
efﬁciently. Such a certiﬁcate is simply a completion X such
that the completed circuit, CX, agrees with the black-box
circuit C on all inputs in I. We ﬁrst observe that the size of
X is linear in the size of C because it is linear in the number
of gates in C. To verify X, we check: (1) that X is indeed a
completion of C, which can be done in time linear in the size
of C, and, (2) that CX (i) = C(i) for all i ∈ I, which can be
done in time O(|C| · |I|).

Since COMPLETION-DEC is in NP, a solver for COMPLETION-
DEC is able to construct and provide a certiﬁcate,
i.e., a
completion X as discussed above. Therefore, when the input to
the solver is a discriminating set of inputs, it provides exactly
what we want: a correct completion.
Theorem 5. COMPLETION-DEC is NP-complete.

6

The proof is in the appendix. As with DISC-SET-DEC, a
consequence of the above theorem is that it is also unlikely
that we will ﬁnd an efﬁcient algorithm for COMPLETION-DEC,
and reduction to SAT is well-motivated.

C. Constructing a Discriminating Set

As we point out in the previous section, given a solver
for COMPLETION-DEC and a discriminating set of inputs I for a
camouﬂaged circuit C, we can determine a correct completion
for C. The only issue that remains is the identiﬁcation of such
a discriminating set I.

We do this using a process akin to guided reﬁnement [14].
That is, we iterate as follows given access to a solver for NOT-
DISC-SET-DEC. We begin with inputs (cid:104)C, I, O(cid:105) with I = O = ∅
to the solver. If the solver says that that input is true, this means
that ∅ is not discriminating for C.

The solver also returns a certiﬁcate, (cid:104)X1, X2, i(cid:48)(cid:105), as we
discuss in the Proof for Theorem 2. In such a certiﬁcate, i(cid:48) ∈ I
is an input for which two distinct completions for C differ in
their outputs. We add i(cid:48) to I, i.e., set I ← I ∪ {i(cid:48)}, and
O ← O ∪{C(i(cid:48))}, and again invoke the solver with the inputs
(cid:104)C, I, O(cid:105).

That is, we “reﬁne” our search for a discriminating set by
“guiding” it by adding i(cid:48) to I in the input to the solver. We
repeat this till the solver says that the instance is no longer
true. From the deﬁnition of NOT-DISC-SET-DEC, such an I to
which the above procedure converges is a discriminating set
of inputs for C.

D. The Attack

Now, we can compose the solvers for NOT-DISC-SET-DEC,
and COMPLETION-DEC to get a correct completion for C. The
composition is that we ﬁrst determine a discriminating set I
by repeatedly calling NOT-DISC-SET-DEC as we discuss in the
previous section, and then provide that as input along with C
and C(I) to the solver for COMPLETION-DEC. This algorithm is
expressed in the following pseudo-code.

I ← ∅
while true do

(cid:104)X1, X2, i(cid:48)(cid:105) ← N (C, I,C(I))
if (cid:104)X1, X2, i(cid:48)(cid:105) (cid:54)=  then
else

I ← I ∪ {i(cid:48)}

break

end if

end while
return M (C, I,C(I))

Alg. 1: IC Decamouﬂaging. N is a solver for NOT-DISC-SET-
DEC, and M is a solver for COMPLETION-DEC, each of which
outputs a certiﬁcate if the input instance is true, and the special
symbol  otherwise.

In the above pseudo-code, N is a solver for NOT-DISC-SET-
DEC, and M is a solver for COMPLETION-DEC. We assume that
N outputs a certiﬁcate (cid:104)X1, X2, i(cid:48)(cid:105) as we discuss in Section
III-A if the input instance is true, and the special symbol 

7

otherwise. We assume that M outputs a certiﬁcate if it is given
as input a true instance of COMPLETION-DEC.

To construct the solver N, we efﬁciently reduce NOT-DISC-
SET-DEC to CNF-SAT, determining whether a boolean formula
in conjunctive normal form is satisﬁable. CNF-SAT is known
to be NP-complete [12], and therefore we know that such
a reduction exists. As we mention in the previous section,
solvers, such as Minisat [11], exist for CNF-SAT that are
efﬁcient for large classes of input instances.

Such a solver returns not only whether an input instance
is true or false, but if it is true, it returns a certiﬁcate for it.
We can use our reduction to easily map a certiﬁcate returned
by Minisat to a certiﬁcate for NOT-DISC-SET-DEC.

To construct the solver M, we similarly efﬁciently reduce
COMPLETION-DEC to CNF-SAT, and leverage a solver for CNF-SAT
such as Minisat. We discuss our reductions from NOT-DISC-SET-
DEC and COMPLETION-DEC to CNF-SAT below, in Section III-E.

Attacker’s Effort
In each iteration of Algorithm 1, the
attacker exercises the black-box with a new input pattern, and
calls the solver N once for each such input pattern. In other
words, if |I| = D is the size of the discriminating set of input
patterns found by Algorithm 1, the attacker would have applied
exactly D input patterns to the black-box circuit and called the
solver for N, D+1 times. In addition, the attacker has to make
one call to the solver for M. If the circuit is sequential, the
attacker also sets the ﬂip-ﬂops in the IC

E. Reductions to CNF-SAT

As we mention in the previous section, because both NOT-
DISC-SET-DEC and COMPLETION-DEC are in NP,
there exist
efﬁcient (polynomial-time) reductions from each of those
problems to CNF-SAT. In this section, we discuss our reductions
from those problems to CNF-SAT.

Our approach is to ﬁrst reduce each to CIRCUIT-SAT, the
problem of determining whether a boolean circuit is satisﬁable.
CIRCUIT-SAT is also known to be NP-complete [12]. We then
employ a well-known efﬁcient reduction from CIRCUIT-SAT to
CNF-SAT [28]. A reduction r from problem A to B, in this
context, maps instances of A to instances of B, and has the
properties that it is efﬁciently-computable, and an instance a
of A is true if and only if the instance r(a) of B is true.

We ﬁrst discuss our reduction from NOT-DISC-SET-DEC to
CIRCUIT-SAT. For clarity, we assume that each camouﬂaged gate
has only one of two identities. That is, a completion X can be
seen as a bit-vector x1, . . . , xk where the camouﬂaged circuit
C has k camouﬂaged gates.

Note that there is nothing fundamental about this assump-
tion. That is, even if a gate is allowed to have one l identities,
where l is a constant, our reduction is sound with only minor
changes, and remains efﬁcient. Speciﬁcally, each xi above,
rather than being a bit, becomes a bit string xi = y1 . . . ylog2(l).
The boolean circuit that is the output of our reduction to
CIRCUIT-SAT has 2k + n inputs, where n is the number of
inputs to C. We label these inputs x11, x12, . . ., x1k, x21,
. . ., x2k, i1, . . ., in. Conceptually, if X1 = (cid:104)x11, . . . , x1k(cid:105),
X2 = (cid:104)x21, . . . , x2k(cid:105) and i(cid:48) = (cid:104)i1, . . . , in(cid:105), then (cid:104)X1, X2, i(cid:48)(cid:105)

TABLE I.
BENCHMARK CHARACTERISTICS, AND THE NUMBER OF
CAMOUFLAGED GATES PER CIRCUIT USED TO COMPARE OUR ATTACK
AGAINST THE BRUTE FORCE ATTACK FROM PRIOR WORK [20]. THE

NUMBER OF CAMOUFLAGED GATES IS CHOSEN TO BE THE SAME AS IN THE

PRIOR WORK.

B’mark
c432
s298
s400
s444
s713
c5315
c7552
s5378
s9234
s38584

Inputs

36
3
3
3
35
178
207
35
19
38

Outputs

7
6
6
6
23
123
108
49
22
304

Gates
160
133
164
181
393
2406
3512
2779
5597
19234

Camouﬂaged

10
6
7
7
9
63
65
56
79
128

TABLE II.
TIME TO DECAMOUFLAGE USING OUR ATTACK AND BRUTE
FORCE ATTACK ON SMALL BENCHMARK CIRCUITS CAMOUFLAGED USING

LARGEST CLIQUE.

B’mark
c432
s298
s400
s444
s713

Our Attack

0.42 s
0.13 s
0.14 s
0.2 s
0.79 s

Brute Force [20]

59 µs
729 ns
2 µs
2 µs
19 µs

Fig. 5.
Time to decamouﬂage (in seconds) using our attack on large
benchmark circuits camouﬂaged using (a) the largest-clique technique, and
(b) random selection of camouﬂaged gates (average, max, min). Also shown
is the estimated time it would take (in years) for a brute force attack to succeed
when largest-clique camouﬂaging is used.

In addition to the ISCAS benchmark circuits (although with
the exception of s38584), prior work [20] has camouﬂaged
certain controller modules from the openSPARC core. How-
ever, canonical gate-level netlists for these are not available.
the s38584 benchmark has 1.5× more gates
Nonetheless,
than the largest openSPARC controller module that has been
considered by prior work.

Our Attack Vs. Brute Force Attack Our ﬁrst goal is to
demonstrate that our attack procedure effectively decamou-
ﬂages circuits that are camouﬂaged using the largest clique
technique. The existing claim is that to decamouﬂage these
circuits, a brute force attack is necessary, and the time com-
plexity of the brute force attack is exponential in the number
of camouﬂaged gates [20].

In this experiment, we camouﬂaged the same number of
gates as in prior work. These numbers are shown in the last
column of Table I. We chose the gates to be camouﬂaged using
both largest clique and random camouﬂaging. We discuss our
results ﬁrst for the small benchmark circuits, and then for the
larger benchmarks.

For the ﬁve small benchmark circuits, even brute force
attacks take within one second to succeed. Thus, results on
these benchmarks are not very meaningful, but we nonetheless
note that, our attacks are also in the sub-second range. It is
worthwhile to note that for c432, we additionally performed
an experiment in which we camouﬂaged all 160 gates, and
were still successfully able to decamouﬂage the circuit using
our attack. This suggests that no matter how gates in c432 are
selected for camouﬂaging, it can always be decamouﬂaged by
our attack.

Fig. 6.
Number of discriminating inputs for large benchmark circuits
camouﬂaged using (a) the largest clique technique, and (b) random selection
of camouﬂaged gates (average, max, min).

•

•

Our attack is always able to successfully decamouﬂage
circuits regardless of whether largest clique or random
camouﬂaging is used. In all instances, our attack suc-
ceeded in less than 2500 seconds (about 40 minutes).
This is in stark contrast to the estimates for a brute
force attack, which range from 1010 to 1041 years.
In addition, the largest clique camouﬂaging technique
seems to offer no more security than random camou-
ﬂaging from the standpoint of our attack. For two of
the ﬁve benchmarks (c7552 and c38584), the average
time to decamouﬂage randomly camouﬂaged circuits
is greater than the time taken when largest clique
camouﬂaging is used.

Figure 5 shows the time taken to decamouﬂage the ﬁve
large benchmark circuits using our attack and the estimates of
how long a brute force attack would take as reported in prior
work [20]. Several observations can be made:

Why are we so successful?
The success of our attack can
be explained via Figure 6, which plots the size of the discrim-
inating set of input patterns, i.e., the number of inputs that we
had to apply to the black-box circuits, in our attack. Across

9

0500100015002000250030003500c5315c7552s5378s9234s38584OurattackonthelargestcliquetechniqueOurattackonrandomlycamouflagedgates(average)BruteforceattackTimetodecamouﬂage(seconds)> 1013 years> 1014  years> 1010  years> 1021  years> 1041  years010203040506070c5315c7552s5378s9234s38584LargestcliqueRandomlycamouflagedgates(average)Number of discriminating inputsto escape the intractability that is inherent in DISC-SET-DEC and
COMPLETION-DEC.

Sequential Circuits with Partial or No Scan Chains Our
attack procedure assumes the target chip is equipped with a
scan chain which allows the user to set and observe memory
elements within the IC. If the target IC does not have a full
scan design, i.e., the chip contains ﬂip-ﬂops that are not part of
the scan chain, it is unreasonable to expect that the attacker can
easily control all internal signals signals of the circuit — this
is known to be even more difﬁcult for circuits with memory
elements than it is for combinational circuits. Hence, our attack
procedure would need to be altered accordingly. We describe
below one way of doing this and leave an investigation as to
the effectiveness of the technique as a topic for future work.
We assume the all ﬂip-ﬂops in the chip that are not
connected into chains have the capability to be forced to a
certain state, set or reset, which is not necessarily the same
for all ﬂip-ﬂops. The attacker starts by unrolling the sequential
circuit one time, i.e., he removes ﬂip-ﬂops in the circuit that
are not connected into a chain and adds, for each removed
ﬂip-ﬂop, an input wire that drives each of the gates that were
driven by the output of the removed ﬂip-ﬂop.

The attacker then follows Algorithm 1 to determine a
discriminating set for the 1-time unrolled circuit, but now
he (1) forces the NOT-DISC-SET-DEC solver to return an input
pattern that assigns either 0 or 1 (depending on whether the
respective ﬂip-ﬂop has the capability to be forced into a
reset/set state) to the present-state lines of the unrolled circuit
(this can be done in the implementation by simply clearing
the corresponding CNF-SAT variables), and (2) he constrains
candidate completions for a discriminating set to agree with
each other on the next state (as well as output).

When the solver returns with a certiﬁcate, the attacker
applies the primary-input part of the returned input pattern to
the chip and observes the circuit output. Note that the attacker
does not need to worry about setting any ﬂip-ﬂops that are
not connected into chains. Whichever discriminating set the
attacker gets at the algorithm’s termination, he is guaranteed
that every candidate completion for it agrees with the black-
box — on both output and next-state behavior — when ﬂip-
ﬂops are initially in the set or reset state. Beginning with this
discriminating set as input to the NOT-DISC-SET-DEC solver, the
attacker then unrolls the circuit twice and follows the attack
procedure again to get a discriminating input set for the 2-
unrolled circuit.

The attacker repeats this d times, where d is the diameter
of the circuit’s FSM, after which he arrives at a discriminating
set for the original circuit. He then uses this discriminating set
to generate a correct completion that agrees with the black-box
on all inputs and intitial memory states. If the attacker does not
know d for certain, but can estimate it, based on knowledge
of circuit’s function or familiarity with hardware, then he can
decide to stop after that many steps with some conﬁdence that
he has reverse engineered the circuit.

VI. RELATED WORK

Several techniques exist to probe the inner structure of
an IC in order to determine its functionality. These include

scanning electron microscopy (SEM) based imaging [15] and
the physical delayering that companies like Chipworks and
Degate perform [7], [10]. Torrance et al. [27] provide an
excellent overview of these techniques.

To protect against such attacks, several IP protection mech-
anisms have been proposed based on the same basic idea —
to physically implement digital gates in a way so they look
indistinguishable to a reverse engineer regardless of their true
functionality. These mechanisms include the use of doped
implants, channel stops and incomplete vias to prevent an
attacker from determining that two transistors are connected,
or alternatively to lead an attacker to believe two transistors
are connected when they are not [3], [9]. Our decamouﬂaging
attack would work, in principle, for any of these camouﬂaging
techniques.

Similar to IC camouﬂaging, recent work [4], [17] proposes
to insert programmable logic blocks (similar to those used
in ﬁeld programmable gate arrays or FPGAs) to hide part
of the design intent. As opposed to a camouﬂaged gate, a
programmable logic block can implement any k-input function.
As we have discussed in Section V, the ability to implement
any k-input Boolean function increases the difﬁculty of IC
decamouﬂaging, but also comes at signiﬁcantly increased cost.
With a similar intent to protect IP, key-based obfuscation
techniques have been proposed. These techniques augment a
circuit with an additional set of inputs (key bits) and ensure
that the the circuit outputs correct values only when the correct
key is applied [19], [22]. In theory, our decamouﬂaging attack
can be used to defeat key based obfuscation as well, given
access to input-output pairs from a functional circuit. In fact,
a camouﬂaged gate can be thought of as a compound logic
gate with one or more key bits as input that determine its
functionality. This can be observed in Figure 4, where the
input to the 2:1 MUX serves as a key bit. Nonetheless, we do
not address key-based circuit obfuscation in this work.

While IC camouﬂaging is meant to obfuscate the design
intent for an attacker in the ﬁeld (i.e., after the IC has been
shipped out), there have also been recent attempts to obfuscate
the circuit netlist in the context of a malicious entity in an
IC foundry (fabrication facility). This can accomplished via
split manufacturing [13], [21], i.e., fabricating only a part of
the IC in an insecure foundry. Here, the attacker makes use
of structural properties of the circuit to reverse engineer the
missing gates and wires, instead of the functional properties
as is done for IC decamouﬂaging.

In an entirely different problem domain, there has been
work also on oracle-guided program synthesis [14]. That
work optimizes implementations of bit-manipulating programs
by iteratively applying an SMT solver to ﬁnd a candidate
implementation that agrees with a reference implementation
on a given set of inputs, queries an oracle to determine if
the candidate is equivalent to the reference, and if not, uses
a counter-example from the oracle to reﬁne the candidate
implementation. An important difference is that
that work
assumes access to an equivalence-checking oracle, whereas we
do not.

We note that there has been some recent work on “reverse
engineering” digital circuit netlists [16], [24], but reverse
engineering is used in a very different context here. The goal

12

of this work is to abstract a ﬂattened netlist of gates into a set
of interconnected modules (such as adders, comparators and
so on), which is very different from our work.

VII. CONCLUSION

We have strongly refuted claims in recent work [20] regard-
ing the effectiveness of a technique proposed in that work for
IC camouﬂaging. Speciﬁcally, that work appears to establish
that by camouﬂaging only a small set of gates chosen judi-
ciously, an attacker is forced to undertake “several thousands of
years” of work. In contrast, we have constructed an attack that
shows that it takes the attacker only a few minutes given very
modest computing resources. In constructing the attack, we
have provided several additional insights into IC camouﬂaging
as a security mechanism. We have introduced the notion of a
discriminating set of inputs that soundly captures an attacker’s
difﬁculty. Our empirical assessment using the same realistic
benchmark circuits that prior work has used shows that the
discriminating sets are surprisingly small, thereby providing
insight into why our attack is so effective. Underlying our
attack procedure is a fresh, complexity-theoretic mindset, that
has allowed us to intuit the computational complexity of two
underlying problems for which an attacker needs solvers. We
have shown how the solvers can be constructed via reductions
to SAT, and the use of an off-the-shelf SAT solver. In addition,
we have provided insights into the (in)effectiveness of IC
camouﬂaging as a security mechanism. Our work serves as
a strong caution to IC designers in this regard.

As future work, we plan to pursue several

threads of
research. As mentioned in Section VI, there are other IC ob-
fuscation techniques proposed in literature besides camouﬂag-
ing. These include key-based and programmable logic based
obfuscation. We believe that our attack can be generalized to
these settings as well, allowing us to investigate the security
of these alternate techniques. At the same time, we would
like to explore the problem of ﬁnding the minimum sized
discriminating input set, both from a complexity-theoretic
and practical stand-point. Finally, we are interested in further
exploring the potential defense mechanisms to protect against
our attack that we discussed in Section V.

REFERENCES

[1]

I. T. AG, “Semiconductor & system solutions - inﬁneon technologies,”
August 2014. [Online]. Available: http://www.inﬁneon.com/

[2] S. Arora and B. Barak, Computational Complexity: A Modern
Approach. Cambridge University Press, 2009. [Online]. Available:
http://books.google.ca/books?id=nGvI7cOuOOQC
J. P. Baukus, L. W. Chow, and W. M. Clark Jr, “Digital circuit with
transistor geometry and channel stops providing camouﬂage against
reverse engineering,” Jul. 21 1998, uS Patent 5,783,846.

[3]

[4] A. Baumgarten, A. Tyagi, and J. Zambreno, “Preventing IC piracy using
reconﬁgurable logic barriers,” IEEE Design and Test of Computers,
vol. 27, no. 1, pp. 66–75, 2010.

[5] F. Brglez, “Neutral netlist of ten combinational benchmark circuits and
a target translator in FORTRAN,” in Special session on ATPG and
fault simulation, Proc. IEEE International Symposium on Circuits and
Systems, June 1985, 1985, pp. 663–698.

[6] F. Brglez, D. Bryan, and K. Kozminski, “Combinational proﬁles of
sequential benchmark circuits,” in Circuits and Systems, 1989., IEEE
International Symposium on.

IEEE, 1989, pp. 1929–1934.

[7] Chipworks,

“Reverse

Engineering

Software,”

http://www.

chipworks.com/en/technical-competitive-analysis/resources/
reerse-engineering-software, last accessed May 2014.

[8] ——,

“Inside

the Apple

Lightning

Cable,”

http://www.

chipworks.com/en/technical-competitive-analysis/resources/blog/
inside-the-apple-lightning-cable/, Oct. 2012.

[9] L.-W. Chow, J. P. Baukus, and W. M. Clark Jr, “Integrated circuits
protected against reverse engineering and method for fabricating the
same using vias without metal terminations,” Sep. 14 2004, uS Patent
6,791,191.

[10] Degate, “Reverse engineering integrated circuits with degate,” http://

www.degate.org/documentation/, last accessed May 2014.

[11] N. E´en and N. S¨orensson, “An Extensible SAT-solver,” in Theory
and Applications of Satisﬁability Testing, ser. Lecture Notes in
Computer Science, E. Giunchiglia and A. Tacchella, Eds. Springer
Berlin Heidelberg, 2004, vol. 2919, pp. 502–518. [Online]. Available:
http://dx.doi.org/10.1007/978-3-540-24605-3 37

[12] M. R. Garey and D. S. Johnson, Computers and Intractability; A Guide
New York, NY, USA: W. H.

to the Theory of NP-Completeness.
Freeman & Co., 1990.

[13] F. Imeson, A. Emtenan, S. Garg, and M. Tripunitara, “Securing Com-
puter Hardware Using 3D Integrated Circuit (IC) Technology and Split
Manufacturing for Obfuscation,” in Presented as part of
the 22nd
USENIX Security Symposium. USENIX, 2013, pp. 495–510.

[14] S. Jha, S. Gulwani, S. A. Seshia, and A. Tiwari, “Oracle-guided
component-based program synthesis,” in Software Engineering, 2010
ACM/IEEE 32nd International Conference on, vol. 1.
IEEE, 2010, pp.
215–224.

[15] W. T. Lee, “Engineering a device for electron-beam probing,” Design

& Test of Computers, IEEE, vol. 6, no. 3, pp. 36–42, 1989.

[16] W. Li, A. Gascon, P. Subramanyan, W. Y. Tan, A. Tiwari, S. Malik,
N. Shankar, and S. A. Seshia, “WordRev: Finding word-level structures
in a sea of bit-level gates,” in Hardware-Oriented Security and Trust
(HOST), 2013 IEEE International Symposium on.
IEEE, 2013, pp.
67–74.

[17] B. Liu and B. Wang, “Embedded reconﬁgurable logic for ASIC design
obfuscation against supply chain attacks,” in Proceedings of the confer-
ence on Design, Automation & Test in Europe. European Design and
Automation Association, 2014, p. 243.

[18] D. Mitchell, B. Selman, and H. Levesque, “Hard and easy distributions

[19]

[20]

[21]

[22]

of SAT problems,” in AAAI, vol. 92. Citeseer, 1992, pp. 459–465.
J. Rajendran, Y. Pino, O. Sinanoglu, and R. Karri, “Security analysis
of logic obfuscation,” in Proceedings of
the 49th Annual Design
Automation Conference. ACM, 2012, pp. 83–89.
J. Rajendran, M. Sam, O. Sinanoglu, and R. Karri, “Security Analysis
of Integrated Circuit Camouﬂaging,” in Proceedings of the 2013 ACM
SIGSAC Conference on Computer and Communications Security, ser.
CCS ’13. New York, NY, USA: ACM, 2013, pp. 709–720. [Online].
Available: http://doi.acm.org/10.1145/2508859.2516656
J. Rajendran, O. Sinanoglu, and R. Karri, “Is split manufacturing
secure?” in Design, Automation & Test
in Europe Conference &
Exhibition (DATE), 2013.
J. A. Roy, F. Koushanfar, and I. L. Markov, “EPIC: Ending piracy
of integrated circuits,” in Proceedings of the conference on Design,
automation and test in Europe. ACM, 2008, pp. 1069–1074.

IEEE, 2013, pp. 1259–1264.

[23] SEMI, “Innovation is at Risk: Losses of up to $4 Billion Annually due
to IP Infringement,” http://www.semi.org/en/Issues/IntellectualProperty/
ssLINK/P043785, last accessed May 2014.

[24] P. Subramanyan, N. Tsiskaridze, K. Pasricha, D. Reisman, A. Susnea,
and S. Malik, “Reverse engineering digital circuits using functional
analysis,” in Proceedings of the Conference on Design, Automation and
Test in Europe. EDA Consortium, 2013, pp. 1277–1280.

[25] SypherMedia, “Syphermedia library circuit camouﬂage technology,”

http://www.smi.tv/solutions.htm, last accessed May 2014.

[26] R. Torrance,

“The

state-of-the-art

in Semiconductor Reverse
Engineering at Chipworks,” http://www.chesworkshop.org/ches2009/
presentations/12\ Invited\ Talk\ III/CHES2009\ torrance.pdf,
last
accessed July 2014.

[27] R. Torrance and D. James, “The state-of-the-art in IC reverse engineer-
ing,” in Cryptographic Hardware and Embedded Systems-CHES 2009.
Springer, 2009, pp. 363–381.

[28] G. Tseitin, “On the Complexity of Derivation in Propositional Calculus,”
in Automation of Reasoning, ser. Symbolic Computation, J. Siekmann

13

will cause φ to output 1 if applied at φ’s inputs. Whatever
that pattern is, we can always ﬁnd a completion in which this
pattern is applied at φ’s inputs when 0 is applied to C (we
simply make gates corresponding to TRUE variables NANDs
and those corresponding to FALSE variables NORs). Hence,
(cid:104)C,{(0, 1}(cid:105) will also be a true instance of COMPLETION-DEC.

and G. Wrightson, Eds. Springer Berlin Heidelberg, 1983, pp. 466–483.
[Online]. Available: http://dx.doi.org/10.1007/978-3-642-81955-1 28

APPENDIX

As a formal language, NOT-DISC-SET-DEC can be written as
follows: NOT-DISC-SET-DEC = {(cid:104)C, IO(cid:105) : C is a camouﬂaged
circuit, and IO is not a discriminating set for C}. Now let φ be
an instance of SAT, i.e. φ is a Boolean formula to be checked
for satisﬁability. We can consider φ as a Boolean circuit with
a single output node in which every other node has a fan-out
of 1. Add a camouﬂaged gate g that can implement one of
{NAND,NOR,XNOR} functions and use the output of φ to
drive both of g’s inputs (the true function of g is irrelevant
to the reduction). Call the new circuit C. We show that φ is
satisﬁable if and only if (cid:104)C,{}(cid:105) ∈ NOT-DISC-SET-DEC; i.e., if
and only if the empty set is not a discriminating set for C.
Note that for the empty set, the set of candidate completions
for C consists of all three possible completions (which we get
by mapping g to one of its three possible functions).

Assume φ is satisﬁable, i.e. φ ∈ SAT. By deﬁnition, a
satisfying assignment for φ sets the output of the formula to
1. Assume such a pattern is applied to C. As the output of φ
drives both of g’s inputs, g will output 0 if its true identity is
NAND and 1 if its true identify is XNOR. As we have two
distinct completions in the candidate set that produce different
outputs for the same input pattern, the empty set cannot be a
discriminating set for C, and hence (cid:104)C,{}(cid:105) ∈ NOT-DISC-SET-
DEC.

Now assume φ is (cid:104)C,{}(cid:105) ∈ NOT-DISC-SET-DEC. This means
that there exists an input pattern for which two of the three
possible completions produce different outputs. This pattern
cannot set φ’s output to 0, as all three possible completions
output 1 when φ’s output to 0. Thus, the input pattern must
set φ’s output to 1, which means φ is satisﬁable.

COMPLETION-DEC can also be written as a formal language.
COMPLETION-DEC = {(cid:104)C, IO(cid:105) : C is a camouﬂaged circuit, IO
is a set of input-output pattern pairs for some circuit that has
the same number of inputs and outputs as C, and there exists a
completion X of C such that ∀(i, o) ∈ IO, CX (i) = o}. Let φ
be an instance of SAT. We consider φ as a Boolean circuit. For
each variable (input wire) in φ, we add a camouﬂaged gate that
can implement one of {NAND,NOR} functions and use the
output of the gate to drive the input wire (the true functions of
these camouﬂaged gates are, again, irrelevant to the reduction).
We also create a new input wire and and drive the inputs of
each of the added camouﬂaged gates using the wire and its
negation. Call the new circuit C. Note that C has one input
and one output. We show that φ is satisﬁable if and only if
(cid:104)C,{(0, 1}(cid:105) ∈ COMPLETION-DEC, i.e. if and only if a completion
exits for C that produces an output of 1 when 0 is applied
at the input. First, note that the camouﬂaged gates’ outputs
are completely determined by their true functions (a NAND
gate will output 1 and a NOR gate will output 0 regardless of
what input is applied to the circuit). Now assume (cid:104)C,{0, 1}(cid:105) ∈
COMPLETION-DEC. By deﬁnition, then, a completion exists that
produces 1 when 0 is applied as input. In this completion, if
we look at the outputs of the once-camouﬂaged gates, they
give us an input pattern which when applied to φ, causes
it to output 1, i.e., a satisfying assignment for φ. Similarly,
assume a satisfying assignment exits for φ. This assignment

14

