Polyglots: Crossing Origins by Crossing Formats

Jonas Magazinius
Chalmers University of

Technology

Gothenburg, Sweden

jonas.magazinius@chalmers.se

Billy K. Rios
Cylance, Inc.

Irvine, CA, USA

Andrei Sabelfeld
Chalmers University of

Technology

Gothenburg, Sweden

andrei@chalmers.se

ABSTRACT
In a heterogeneous system like the web, information is ex-
changed between components in versatile formats. A new
breed of attacks is on the rise that exploit the mismatch
between the expected and provided content. This paper
focuses on the root cause of a large class of attacks: poly-
glots. A polyglot is a program that is valid in multiple pro-
gramming languages. Polyglots allow multiple interpreta-
tion of the content, providing a new space of attack vec-
tors. We characterize what constitutes a dangerous format
in the web setting and identify particularly dangerous for-
mats, with PDF as the prime example. We demonstrate
that polyglot-based attacks on the web open up for insecure
communication across Internet origins. The paper presents
novel attack vectors that inﬁltrate the trusted origin by syn-
tax injection across multiple languages and by content smug-
gling of malicious payload that appears formatted as benign
content. The attacks lead to both cross-domain leakage and
cross-site request forgery. We perform a systematic study
of PDF-based injection and content smuggling attacks. We
evaluate the current practice in client/server content ﬁlter-
ing and PDF readers for polyglot-based attacks, and report
on vulnerabilities in the top 100 Alexa web sites. We identify
ﬁve web sites to be vulnerable to syntax injection attacks.
Further, we have found two major enterprise cloud storage
services to be susceptible to content smuggling attacks. Our
recommendations for protective measures on server side, in
browsers, and in content interpreters (in particular, PDF
readers) show how to mitigate the attacks.

Categories and Subject Descriptors
K.6.5 [Security and Protection]: Unauthorized access

Keywords
Web Security; Polyglot; Injection; Cross-domain

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516685.

1.

INTRODUCTION

Web application security is concerned with protecting in-
formation as it is manipulated by web applications. This
is an important area because “attacks against web applica-
tions constitute more than 60% of the total attack attempts
observed on the Internet” [11].

Internet origins at stake.

The diﬀerent trust domains correspond to diﬀerent In-
ternet origins. A major goal for web application security
is preventing undesired communication across origins. With
the goal of separating information from the diﬀerent origins,
today’s browsers enforce the same-origin policy (SOP). SOP
only allows access between two documents if they share the
origin. In addition, a document can only directly communi-
cate with the server from which it originates.

Classical cross-domain attacks.

There are several classes of cross-domain attacks that cir-
cumvent SOP. The OWASP top 10 list [10] places both injec-
tion and cross-site scripting (XSS) attacks among the three
top security risks for web applications. A classical XSS at-
tack injects a malicious script in the context of a trusted
origin. This opens up opportunities for leaking sensitive in-
formation that users might have in the context of the trusted
origin such as cookies, personal information, and session to-
kens.

XSS attacks are relatively well understood by researchers
and developers [17]. Known defenses include various ﬂavors
of sanitization on server side and the content security pol-
icy [12] (CSP) on client side. Sanitization is often performed
by the server to ﬁlter possibly malicious input data before it
is used in the generated web pages. Content security policy
puts requirement on the structure of the document and the
origins of the scripts that are included by web pages.

Crossing origins by crossing formats.

This paper focuses on a new breed of attacks and its root
cause: polyglots. A polyglot is a program that is valid in
multiple programming languages.
In a heterogeneous sys-
tem like the web, information is exchanged between compo-
nents in versatile formats. This gives rise to attacks that
exploit the mismatch between the expected and provided
content. Polyglots allow multiple interpretation of the con-
tent, providing a new space of attack vectors. An attacker
can use a malicious polyglot to inﬁltrate a vulnerable origin.
Once inﬁltrated, the polyglot is embedded from within the
attacker’s web site, such that the browser is coerced to inter-

753pret the polyglot in an unexpected context, e.g., a plug-in.
According to the SOP, content loaded in a plug-in is con-
sidered to belong to the origin from which the content was
requested. Thus, the polyglot is allowed to communicate
with the vulnerable origin. A victim, authenticated in the
vulnerable origin, who visits the attacker’s web site will trig-
ger the malicious polyglot. This allows the polyglot to abuse
the credentials of the victim in its communication with the
vulnerable service. The scenario is explained in detail in
Section 2.3, where we present novel attack vectors that are
based on (i) syntax injection that operate across multiple
languages and on (ii) content smuggling that supply ma-
licious payload that appears formatted as benign content.
The attacks lead to both cross-domain leakage and cross-
site request forgery.

The existing defense mechanisms fall short to prevent these
attacks from achieving cross-domain communication. On
the server side, sanitization is speciﬁc to the target language
of the web application. Sanitizing unexpected formats is
typically not considered. On the client side, CSP has no ef-
fect unless the content is interpreted as HTML. This opens
up opportunities for attacks that are based on other formats.
The ﬁrst steps in exploiting formats in the context of the
web have been taken by researchers. Two noteworthy ex-
amples are GIFAR [4] and cross-origin CSS attacks [7] (Sec-
tion 6 discusses further related work). GIFAR is based on
polyglots that combine the GIF and JAR (Java archive)
formats. The former is used as benign and the latter as
malicious to bypass SOP. Cross-origin CSS attacks inject
fragments of CSS code into an existing web page to extract
information from the existing web page.

Generalizing polyglot attacks.

The paper is the ﬁrst to present a generalized description
of polyglot attacks. We identify the necessary ingredients
for polyglot attacks. We characterize what constitutes a
dangerous format in the web setting and identify particularly
dangerous formats, with PDF as the prime example. We
demonstrate that polyglot-based attacks on the web open
up for insecure communication across Internet origins.

PDF polyglots.

Having identiﬁed PDF as a particularly dangerous format,
we perform a novel in-depth study of PDF-based injection
and content smuggling attacks. Our ﬁndings expose new
attack vectors, which we demonstrate both conceptually and
by proof-of-concept web pages.

Evaluation and mitigation.

We evaluate the current practice in client/server content
ﬁltering and PDF readers for polyglot-based attacks, and
report on vulnerabilities in the top 100 Alexa web sites. Un-
fortunately, several major web sites do not protect against
polyglot attacks. Five out of the top 100 Alexa web sites
are vulnerable to syntax injection attacks. In addition, we
have found two major enterprise cloud storage services to be
susceptible to content smuggling attacks. Our recommenda-
tions for protective measures on server side, in browsers, and
in content interpreters (such as PDF readers) show how to
mitigate the attacks.

Overview.

The paper is organized as follows. Section 2 explains the
concept of crossing origins by crossing formats, identiﬁes
necessary ingredients, and provides attack scenarios. Sec-
tion 3 focuses on the PDF format and describes concrete
vulnerabilities and attacks. Section 4 evaluates the current
practice in client/server content ﬁltering and PDF readers
and report on vulnerabilities in the top 100 Alexa web sites.
Section 5 suggests mitigation for servers, clients, and PDF
readers. Section 6 discusses the related work. Section 7
concludes and outlines future work.

2. CROSSING ORIGINS AND FORMATS

This section describes how formats can be crossed and
how that can be abused to cross origins by circumventing
the same-origin policy. We describe cross-origin information
leaks, generalize the problem of crossing formats to polyglots,
and present the characteristics of a malicious polyglot. From
that we derive two attack vectors and show how previous
work on the subject relate to these vectors.
2.1 Crossing origins

By crossing origins we mean being able to request and
access content across domains, which is normally restricted
under the same-origin policy. Recall that SOP only allows
two documents accessing each others’ content and resources
if they share the origin. Similarly, a document can only di-
rectly communicate with the server from which it originates.
This is not to be confused with cross-origin resource sharing
(CORS) [16], which is an intentional relaxation of SOP.

While there are exceptions to this policy, e.g., images,
scripts, and style sheets are allowed to be included as re-
sources across origins, access to these resources is restricted
to prevent information leaks. As an example, the includ-
ing document is prevented from accessing the image data of
images loaded across origins.

Not all elements are as carefully restricted from informa-
tion leaks as images. Scripts loaded across origins become
part of the document and inherit the origin of the includ-
ing document, which allows the script to communicate with
the server from which the document originates. Such scripts
are also able to interact with the document, e.g. by adding
nodes, which in turn require new content to be requested.
Since these requests are not restricted by the SOP, this cre-
ates a side channel that permits cross-origin information
leakage. At the same time, the including document is pre-
vented from inspecting the source of the script and can only
observe the public side-eﬀects that the script produce as it
is executed.

Other examples of problematic elements include the object
and embed tags. These tags allow inclusion of resources that
may require a plug-in to run. The plug-in is selected based
on the MIME-type of the content, but because the server
delivering the content might not be able to determine its
format, the tags allow a developer to set the type attribute
to guide the browser in which plug-in to run. When the type
attribute is used, the corresponding plug-in is run regardless
of the MIME-type provided by the server. In the event that
the provided MIME-type do not match that for which the
plug-in is designed, e.g., text/html for a PDF plug-in, it is up
to the plug-in to respond to the content it is served. Known
methods of handling MIME-types, such as content-sniﬃng,
are eﬀective in this situation, but they have to be employed

754by each and every plug-in. Most plug-ins will disregard the
MIME-type of the content and attempt to parse it. As with
images, the content handled by the plug-in is executed in the
origin it was served from. This implies that the containing
page is restricted from directly accessing the content handled
by the plug-in, and that the content can communicate freely
with the origin it was loaded from. However, a number of
plug-ins provide an API for interaction between the plug-
in and the document. The browsers are forced to rely on
the plug-ins to employ correct security measures. Section 4
shows that even state-of-the-art plug-ins fail to properly do
so, emphasizing the importance of the issue.

2.2 Crossing formats

A polyglot is perhaps most commonly known as a per-
son who speaks several languages. However, the term is
widely used in several scientiﬁc ﬁelds. In computer science,
a polyglot is a program that is valid in multiple programming
languages. In this paper we use a broader deﬁnition of a pro-
gramming language, not limited to code meant for compila-
tion to machine code or scripting languages, but extended
to any format that requires interpretation before rendering.
A polyglot is composed by combining syntax from two dif-
ferent formats A and B. It leverages various syntactic lan-
guage constructs that are either common between the for-
mats; or constructs that are language speciﬁc but carrying
diﬀerent meaning in each language. To maintain validity
across languages, one must ensure that constructs speciﬁc
to A are not interpreted in the format of B, and vice versa.
This is often accomplished by hiding the language speciﬁc
constructs, in segments interpreted as comments or plain
text of the other format.

Certain languages are particularly suitable for creating
polyglots. These languages either have a lot of constructs
in common with other languages, such as the C language,
or are error tolerant in that the parser ignores that which it
cannot interpret, such as HTML. The latter allows for ample
opportunity to hide any code speciﬁc to format A, as long
as there is no overlap with the syntax of format B.

A malicious polyglot of two formats, A and B, where A
is benign in nature and B contains a malicious payload, is
composed as A||B. he benign format, A, is a widely accepted
format with limited capabilities, but with the opportunity
of hiding arbitrary data, e.g. an image with comment ﬁelds.
The malicious format, B, has additional capabilities, e.g.,
execute scripts or send requests. This kind of polyglot can
be used for malicious purposes when there is a diﬀerence be-
tween the assumed run-time context, and the actual context
it is executed in. In the assumed context A||B is interpreted
as the benign format, A. In the actual context, however,
A||B is coerced to be interpreted as the malicious format,
B, containing the payload.

Even if a veriﬁcation process exists, it will verify that the
content is valid in the assumed context. Due to the nature of
the polyglot, the content is veriﬁed as valid and benign, but
subsequently, in the actual context, the malicious content is
executed.

Coercing content to be interpreted as a diﬀerent type can
be accommodated in the context of the web. If the content
is loaded using an img tag it will be interpreted as an im-
age, if a script tag is used it will be interpreted as a script.
Certain tags, e.g., the object tag and embed tag, even let the
developer decide which type to interpret the content as. To

prevent abuse, the browsers employ content-type sniﬃng for
certain content-types, a practice which has historically led
to security issues, as illustrated below.

Barth et al. [3] deﬁne chameleon documents as a benign
ﬁle type crossbred with malicious HTML content. The at-
tack targets the content-sniﬃng algorithm used in the browser
and the document is crafted in such a way that the browser
will detect the content type as HTML. The paper proceeds
to describe how an attacker can create a chameleon doc-
ument, that is valid PostScript, but will be identiﬁed as
HTML. This issue allows exploitation when there is a mis-
match between a web site’s content validation ﬁlter and the
browser’s content-sniﬃng algorithm.

In literature we ﬁnd, apart from chameleons, other names
for similar, related concepts. Brandis [4] refer to GIFAR
attacks, based on one of the early instances of attacks based
on GIF images that are also valid JAR ﬁles. Sundareswaran
et al. [14, 13] discuss GIFAR-related attacks as a form of
content repurposing attack. In this paper the term content
smuggling is used as it best represents how a polyglot can
inﬁltrate an origin.

While these articles document known instances of poly-
glot attacks, the attack method has not been generalized
until this paper. Under our generalization, previous work
corresponds to instances. For example, we show that GIFAR
attacks describe a form of content smuggling, Section 2.3.2,
and cross-origin CSS attacks [7] describe a form of syntax
injection attacks, Section 2.3.1. The added value of our pa-
per is a generalized view on polyglot attacks and focus on
new instances of polyglots that involve the PDF format.

Two attacker-centric components require special atten-
tion; the inﬁltration of an origin, i.e. the attack vector, and
the exploitation of an inﬁltrated origin, i.e. the payload.
2.3 Attack vectors

The general pattern of a polyglot attack is described in
the following scenario, illustrated in Figure 1. The target of
the attack is the web site vulnerable.com. It has been inﬁl-
trated by an attacker to serve a malicious polyglot within its
sensitive origin (1). The content is served by vulnerable.com
as the benign format, e.g., an image, harmless to users of the
web site. The victim in this scenario is an authenticated user
of vulnerable.com. At some point, while still authenticated
to vulnerable.com, the unsuspecting victim visits the attack-
ers web site attacker.com (2). Upon visiting attacker.com,
the web site uses a plug-in to embed the polyglot from vul-
nerable.com as the malicious format (3). This is achieved
by setting the type attribute to the MIME-type of the cor-
responding plug-in, which will override the MIME-type sup-
plied by vulnerable.com. When loaded in the plug-in the
malicious polyglot is executed in the vulnerable.com origin
(4), as described in Section 2.1. The impact depends on the
payload and the capabilities of the malicious format.

This paper describes two vectors for inﬁltrating an origin,
either via syntax injection, or content smuggling. In the case
of syntax injection, existing content is manipulated to be-
come a polyglot, whereas with content smuggling, a polyglot
is used to evade content ﬁlters. The vectors are described
below with more detailed scenarios.

Syntax injection

2.3.1
In a cross-site scripting attack user input is used to com-
pose an HTML document. Fragments of HTML syntax in

755Figure 1: Overview of the scenario

Figure 2: Syntax injection scenario

the input alters the semantic of the document to execute at-
tacker supplied script code. Similarly, in a syntax injection
attack the vulnerable target will compose an HTML docu-
ment from attacker controlled input containing syntax of a
foreign format. The resulting document is a polyglot which
is benign when viewed as the HTML, but malicious when
viewed as the injected format. While the web site serves the
content as HTML, it is in the hands of the attacker to decide
how it is interpreted when embedded in the attackers web
page. Examples of such services include social networks,
search engines, i.e., nearly any dynamic web site driven by
user interaction. The targeted service is assumed to employ
server-side cross-site scripting sanitization. For the attack to
be successful, the input must bypass this sanitization. The
sanitization ﬁlter will remove or encode problematic char-
acters in the input related to HTML-syntax. The injected
format will pose as a new context, unknown to the ﬁlter.
Chances are that the injected format will pass the ﬁlter un-
noticed.

Previous work documents an instance of a polyglot at-
tack based on syntax injection, though not phrased in those
terms. Huang et al. [7] describe a cross-origin cascading
style-sheet (CSS) attack. This attack injects fragments of
CSS syntax in a HTML document, thereby making it a
HTML/CSS polyglot. The error-tolerant parsing of style
sheets allow the polyglot to parsed as valid CSS. The ca-
pabilities of CSS provide trivial cross-origin leakage. The
paper proposes a defense technique which has been adopted
by all major browsers, which implies that the attacks out-
lined in their paper are now ineﬀective. Instead, Section 3
will show practical attacks based on other formats.

Scenario.

The scenario, illustrated in Figure 2, describes how the at-
tack proceeds from the inﬁltration of the origin to the com-
promise of the victim. Again, the victim is an authenticated
user of vulnerable.com that unsuspectingly visits the attack-
ers malicious web site, attacker.com (1). The attacker.com
web site uses a plug-in to embed a web page with vulnerable
input parameters from vulnerable.com (2). In the parame-
ters of the request the attacker injects the syntax of the
malicious format (3). The response from vulnerable.com is
a polyglot served as the benign content type (4), but the at-
tacker’s page coerces the content to be interpreted as the ma-
licious content type by the plug-in. The malicious payload is

executed in the origin of vulnerable.com and can leverage the
credentials of the victim to further exploit the vulnerability.

2.3.2 Content smuggling
The vulnerable target of a content smuggling attack, lets
users upload ﬁles that are subsequently served under the
origin of the service. Examples of such potentially vulnera-
ble services are cloud storage services, image databases, so-
cial networks, conference management systems or job broker
services. Such a service accepts a limited set of benign ﬁle-
formats, and the ﬁles are run through a ﬁlter to verify that
they belong to this set, e.g.
images or documents, before
being served to the end user. The ﬁlter will verify the ﬁle
under the assumption that it conforms strictly to one for-
mat. By submitting a polyglot to such a service, an attacker
can evade the ﬁlter as the polyglot does conform to the be-
nign format. If the polyglot is publicly accessible, it can be
embedded in the attackers page. Since the attacker is in
control over which format the polyglot is interpreted as, it
is embedded as the malicious format and thereby the service
is vulnerable to a content smuggling attack.

The GIFAR attack is a polyglot attack based on content
smuggling. In this attack a benign GIF-image and a mali-
cious JAR-ﬁle is combined to create a GIF/JAR polyglot.
By submitting the combined GIFAR to a service, the at-
tacker can execute a Java applet under the origin of the
targeted service. The Java runtime has been updated to
prevent this kind of abuse.
Instead, Section 3 will show
practical attacks based on other formats.

Scenario.

The content smuggling scenario proceeds as illustrated in
Figure 3. Similarly to the previous scenarios, the victim
is an authenticated user of a targeted vulnerable web site,
vulnerable.com. To give more context to the scenario, vul-
nerable.com can be a cloud storage service. The target is
inﬁltrated by the attacker (1), who uploads a polyglot to
the web site. The polyglot is veriﬁed to be benign under the
assumption that it belongs an allowed ﬁle type. While still
authenticated to vulnerable.com, the victim visits the attack-
ers web site, attacker.com (2). The attacker.com site embeds
the polyglot from vulnerable.com (3), which is served as the
benign type, but coerced to be interpreted as the malicious
content type by the plug-in (4). The malicious format of the

756Listing 1: Sample PDF ﬁle

%PDF−1.4
1 0 o b j
<< /Type / C a t a l o g

/ O u t l i n e s 2 0 R
/ Pages 3 0 R

>>
endobj
2 0 o b j
<< /Type O u t l i n e s

/Count 0

>>
endobj
3 0 o b j
<< /Type / Pages

/ Kids
/Count 1

[ 4 0 R]

>>
endobj
4 0 o b j
<< /Type / Page

/ Parent 3 0 R
/MediaBox [ 0 0 612 7 9 2 ]
/ Contents 5 0 R
/ R e s o u r c e s << / P r o c S e t 6 0 R >>

>>
endobj
5 0 o b j << / Length 35 >>
stream

. . . Page−marking o p e r a t o r s . . .

endstream
endobj
6 0 o b j

[ /PDF]

endobj
x r e f
0 7
0000000000 65535 f
0000000009 00000 n
0000000074 00000 n
0000000120 00000 n
0000000179 00000 n
0000000300 00000 n
0000000384 00000 n
t r a i l e r
<< / S i z e 7

/ Root 1 0 R

>>
s t a r t x r e f
408
%%EOF

3.1 Portable Document Format

The Portable Document Format (PDF) is a widely used
document format capable of displaying text, rendering graph-
ics, scripting, animation and other dynamic content. It is
a container format in the sense that it allows embedding of
ﬁles and resources.

According to the PDF speciﬁcation [8] a PDF ﬁle is com-
posed of a header, several objects, a cross-reference section
and a trailer. Listing 1 shows a sample of how a PDF ﬁle is
structured and its elements. Supposedly, it is also a minimal
PDF ﬁle according to the speciﬁcation.

Figure 3: Content smuggling scenario

embedded polyglot is activated and a possible payload is to
extract all the ﬁles stored in the victims account.
2.4 Payloads

The consequences of exploiting an inﬁltrated origin de-
pend on the capabilities of the format used. These con-
sequences span from abusing the credentials of the victim
to forge requests to the vulnerable web site, to extracting
sensitive information about the victim that is stored on the
vulnerable web site.

Cross-site request forgery.

If the format has the capability of issuing requests, in
particular POST requests within the boundaries of the SOP,
that includes the victims credentials,then the attacker can
mount a cross-site request forgery (CSRF) attack. Web sites
protect against these attacks by generating a token with each
response that has to be included in the subsequent request.
However, if the format also have the capability of reading
the response of the issued request, it can extract the token
and thereby circumvent the CSRF protection.

Cross-origin information leakage.

Additionally, if the format allows communication with the
origin of the attacker, then the attacker can extract sensitive
user information and leak it across origins. If the format is
not restricted by the SOP, it can communicate directly with
the attackers server. Otherwise, if the format can interact
with the document that embeds the polyglot, the communi-
cation could be tunneled through this channel.

3. VULNERABILITIES AND ATTACKS

In this section we give concrete examples of the attacks de-
scribed in Section 2, using the PDF format as the running
example. We begin by detailing how the design decision
made in the PDF-standard make it highly suitable for cre-
ating malicious polyglots. Throughout this section Adobe
Reader is the assumed target. A comparison between read-
ers can be found in Section 4.

The reader is invited to visit the test page [1] for prac-
tical demonstration of the attacks from this section. These
attacks show that the vulnerabilities we focus on are ex-
ploitable in practice.

7573.1.1 Header
The header consists of the string ”%PDF-” followed by
a version number. The version is denoted by a major and
a minor version number of the form ”M.m”. Because the
version can be speciﬁed elsewhere, the version number is
not required to be part of the header.
3.1.2 Objects
Objects can be direct or indirect, the diﬀerence being that
an indirect object has labels which are used for referring to
the object from another object. Object labels are numbered
and begin with the string ”N n obj”, where ”N” is the object
number and ”n” is the revision number. Similarly object
references are of the form ”N n R”. The label is optionally
ended with the keyword ”endobj”.

There are eight basic types of basic objects; booleans,
integers, strings, names, arrays, dictionaries, streams and
the null object. For the intents and purposes of this article,
we will focus on the string, dictionary, name and stream
objects.

String objects.

There are two types of strings; literal and hexadecimal.
Literal strings are enclosed by the ”(” and ”)” characters.
Any character can occur in a literal string, even parentheses
if they are balanced, e.g. a matching closing parenthesis
for every opened parenthesis. In hexadecimal strings each
character is represented by its corresponding hexadecimal
value, enclosed by the ”<” and ”>” characters.

Dictionary objects.

Dictionary objects are a name-value map delimited by the
”<<” and ”>>” tokens. The names are name objects and
the values are objects of any type. Name objects begin with
the ”/” character, followed by a string of non-whitespace
characters. Each dictionary has a type, either speciﬁed by
the ”/Type” name or inferred from the context in which it
occurs. The type declares which kind of element the dictio-
nary is describing, e.g. a page or an annotation. Dictionaries
form the structure of the document by connecting objects
through references, e.g. relating a page to its contents. A
special type of dictionary describes actions. Actions are trig-
gered when a certain event occur, such as a ﬁle is opened or
a page is displayed, and the action dictionary specify how
it is handled. Actions can be used to, among other things,
go to a speciﬁc page, play a sound, execute JavaScript or
launch a command.

Stream objects.

A stream is an unlimited sequence of bytes. A stream
object is indirect and consists of a dictionary, describing the
stream, and the associated stream delimited by the ”stream”
and ”endstream” keywords. According to the speciﬁcation,
the stream dictionary shall contain a Length name to specify
the length of the stream. In practice this can be omitted as
long as the delimiting keywords are in place. PDF supports
encoding of streams, in which case the dictionary describe
which ﬁlters are required to decode the stream.
3.1.3 Cross-reference
The cross-reference section is a record of the location of
indirect objects within a ﬁle. The location is speciﬁed as
the byte oﬀset from the beginning of the ﬁle. The cross-

reference section is opened with the ”xref” keyword, followed
by one record for each indirect object. The cross-reference
section will be reconstructed if missing and can therefore be
omitted.

3.1.4 Trailer
The trailer is composed of a trailer dictionary, a pointer
to the cross-reference section and an end-of-ﬁle marker. The
trailer dictionary is introduced by the ”trailer” keyword.
Root is in practice the only mandatory name in the trailer
dictionary, referencing the root of the document structure.
The ”startxref” keyword is followed by the number of bytes
from the beginning of the ﬁle to the ﬁrst cross-reference sec-
tion. As with the cross-reference section, it can be omitted.
The string ”%%EOF” marks the end-of-ﬁle, but can be omit-
ted.
3.2 PDF-based polyglots

Several design choices in the PDF speciﬁcation make the
format particularly suitable for making polyglots. One such
design choice is the error tolerant parser. This is in part
motivated by another design choice namely PDF being a
container format. This implies that a PDF ﬁle can, by de-
sign, contain foreign syntax that could interfere with the
syntax of the ﬁle. Another motivation is that PDF ﬁles
are designed to be both forward- and backward-compatible.
Readers implementing an older version of the speciﬁcation
do not recognize new features and behave as if they were
not present in the ﬁle. The implementation notes of the
speciﬁcation describes some exceptions to the requirements
of the speciﬁcation, such as the header can occur anywhere
within the ﬁrst 1024 bytes of the ﬁle. This ﬂexibility gives
plenty of room for combining with syntax of another format.
The speciﬁcation declares many components to be required
in a PDF ﬁle, but as can be seen in Section 3.1, in practice
several components can be omitted [15]. The code in List-
ing 2 shows the minimal syntax required for a malformed,
but valid PDF ﬁle.

Listing 2: Minimal PDF ﬁle

%PDF−
t r a i l e r <</Root<</Pages<<>>>>>>

Furthermore the PDF format is of particular interest to us
because of its many capabilities. Some examples include ex-
ecuting JavaScript, launching commands, and issuing HTTP
requests. The HTTP requests are restricted to the origin of
the PDF ﬁle, and will include any cookies associated with
that origin. Adobe Reader also includes a Flash runtime to
play embedded Flash ﬁles on systems that do not have the
Flash runtime installed.

When a PDF document is embedded in a web page, the
corresponding plug-in is executed to render the content. Re-
call from Section 2.1 that the plug-in is selected based on
the MIME-type, either supplied by the server or in the type
attribute with preference for the later. Also recall that the
browser rely on the plug-in to handle the situation when the
MIME-type supplied by the server is inconsistent with the
MIME-type of the plug-in. In the case of the Adobe Reader
plug-in, it disregards the MIME-type supplied by the server
and will attempt to interpret any content as PDF. Listing 3
shows how arbitrary content can be rendered as PDF for-
mat.

758Listing 3: HTML for embedding PDF content

<embed type =”a p p l i c a t i o n / pdf ”
s r c =”v u l n e r a b l e . com/? i n p u t=%PDF. . . ” >

In recent versions of Adobe Reader certain measures have
been taken to prevent creating PDF-based polyglots.
In
accordance with our recommendations, Adobe Reader has
made the parsing more strict by attempting to match the
ﬁrst bytes of the ﬁle against a set of known signatures. If
a match is found, the parser will abort loading of the doc-
ument. However, this does not fully defend against PDF-
based polyglot attacks. The problem of this approach is
that there are a number of ﬁle formats that lack a reliable
signature, e.g., HTML. Also, for this approach to be reli-
able, the signature must match the signature enforced by
other interpreters of the format. A notable counterexample
is the signature used for the JPG format. While the signa-
ture is correct according to the speciﬁcation of the format,
several JPG interpreters will allow slightly malformed sig-
natures. Such a malformed signature will bypass the check
in Adobe Reader and still be rendered correctly in a viewer.
This opens up for PDF-based polyglot attacks.
3.3 PDF attacks

As explained in Section 2.3 there are two vectors for poly-
glot attacks; syntax injection and content smuggling. PDF
is a suitable format for both vectors as it is both a text based
format with error tolerant parsing, and has widespread ac-
ceptance as a document format, often preferred over other
document formats.
3.3.1 Syntax injection
As the scenario details in Section 2.3.1, the attacker in
a syntax injection attack manipulates a vulnerable service
to include PDF syntax in existing content, e.g. HTML-
documents. The PDF syntax is typically injected through
user input used by the vulnerable service in the composition
of documents. An example of a suitable fragment to inject
is shown in Listing 4. The resulting content is subsequently
embedded in the attackers page as PDF, as exempliﬁed in
Listing 3. As mentioned in Section 3.2, the embedded PDF
can issue requests to the origin it came from, carrying the
cookies associated with that origin. These requests allow for
the extraction of sensitive user data that can either be com-
municated back to the attacker, or be leveraged in further
attacks.

Thus far, exploitation of vulnerable services have been
discussed, excluding the speciﬁc conditions under which a
service is vulnerable. In order to exploit the vulnerability,
the injected syntax must pass through any existing ﬁlters
unchanged or at least with its semantics preserved. If user
input in an HTML-document is not sanitized, any syntax
would be unchanged and the service is vulnerable to less so-
phisticated attacks, e.g. cross-site scripting, therefore san-
itized user input is of greater concern. Based on the PDF
samples in Listings 2 and 4, we can derive the set of to-
kens required to build a PDF. Assuming that alpha-numeric
characters pass through a sanitization ﬁlter unmodiﬁed, the
set of tokens is {%, <<, >>, /}. As can be noted, there is
a small but signiﬁcant overlap with the tokens of HTML,
which implies that many web sites protected against cross-
site scripting attacks are also protected against PDF-based
polyglot attacks. One of the problems of ﬁltering input for
inclusion in a web page are the many contexts in which the

input can be included. A problem made even more complex
by the diversity of languages the page contains. Language
incompatibilities force context dependent ﬁltering, where
the same input is treated diﬀerently based on the context
in which it is included. In certain contexts angle brackets
are often left untouched by ﬁlters.

HTML comments.

No HTML enclosed in comments, ”<–” and ”–>”, will be
rendered, and therefore ﬁlters consider this context safe. To
prevent input from escaping the comment by injecting an
end comment token, certain ﬁlters remove any occurrences
of ”–>”, but leave the rest of the input untouched. HTML
comments are meaningless to PDF, and the result is a valid
HTML/PDF polyglot.

JavaScript strings.

In an in-line JavaScript context, user input is often in-
cluded in the shape of a JavaScript string, delimited by sin-
gle or double quotes. In this context only a few characters
require encoding, as they can break the string context. Nat-
urally, any single or double quotes need escaping, as well as
any carriage return or line feed characters. In the spirit of
making minimal changes to the input, certain web sites only
escape these characters. This is suﬃcient to prevent cross-
site scripting attacks, but fail to protect against PDF-based
polyglot attacks.

Note that not only in-line JavaScript falls short in this re-
gard. JavaScript object notation (JSON) is used in modern
web sites as a data transport. This is particularly common
in web sites that provide an API to interact with the of-
fered services. JSON encoded information suﬀer the same
problem as in-line JavaScript, thereby extending the attack
surface further.
3.3.2 Content smuggling
Due to the nature of the PDF, it can without much eﬀort
be combined with just about any other format. This pro-
vides ample opportunity to create malicious polyglots where
PDF is either the benign or the malicious format. Conse-
quently, this signiﬁcantly expands the attack surface, mak-
ing it important to take measures to protect against these
attacks.

PDF as the benign format.

Services like job brokers commonly let the user upload a
CV in the form of a PDF-ﬁle. Before such PDF-ﬁles are
published to recruiters, they are veriﬁed to not contain any
malicious payload. Such a veriﬁcation only extends to the
PDF format itself. An attacker can produce a PDF that
is valid and benign, but also a polyglot hiding another ma-
licious format, such as Flash. As described in the content
smuggling scenario in Section 2.3.2, the uploaded PDF ﬁle
is then embedded on the attacker’s web site, but now as the
malicious format. Using social engineering, the attacker can
persuade the victim to visit the web site.

Creating a PDF/Flash polyglot is no major challenge. A
proof-of-concept can easily be created by storing the PDF
source code as a static string variable in the malicious Flash
source code. When compiling Flash, the output is com-
pressed by default to save space, thereby obfuscating the
PDF source code. However, tools exist that decompress the
Flash ﬁles, which restores the plain PDF code.

759PDF as the malicious format.

In the content smuggling scenario in Section 2.3.2, the
attacker uploads the PDF polyglot to a vulnerable content
hosting service. A server-side veriﬁcation process will base
its veriﬁcation on the benign formats it expects to receive.
The polyglot is designed to verify correctly as the benign for-
mat, and the veriﬁcation is likely to miss the malicious PDF
components, as it is unaware of the alternate interpretation
of the content.

Given the extensive capabilities of the PDF format, ex-
ploiting a content smuggling vulnerability with a PDF-based
polyglot attack, can be done without much eﬀort. To pre-
vent the attack, the veriﬁcation process have to actively
search for and remove PDF speciﬁc syntax. The impact
of exploitation depends on the payload used in the attack.
3.4 PDF payloads

As discussed in Section 2.4, there are two approaches to
exploiting these vulnerabilities; cross-site request forgery,
and cross-origin information leakage. Both of these require
extracting information from the vulnerable service, which is
something that can be achieved using the capabilities of the
PDF format.

In order to extract information and leak across origins,
a communication channel is established. PDF documents
provide multiple ways of generating HTTP requests; many
of which allow cross-origin communication, but are, out of
security concerns, only one-way in the sense that the PDF
document will never see the result. Therefore, the focus is
directed towards two methods that allow bidirectional com-
munication; XML external entities, and embedded Flash.
Since the document will retain the origin from which it was
served, all requests issued from the document will include
any cookies associated with the target origin.

XML External Entities.

The PDF JavaScript API includes a method to parse XML
documents, called XMLData.parse. The XML document be-
ing processed may in turn rely on external entities, required
for the parsing of the document, which the XML parser will
request. The request is bound to the origin of the docu-
ment, and the response is included in the XML document.
The source code of the XML document reﬂects this response
and can be retrieved at a later point, resulting in a bidirec-
tional communication channel. As the response is included
in the XML, the result has to be well-formed XML. This
puts a restriction on the content that can be requested us-
ing this method. Considering that HTML pages are rarely
well-formed this method may be too restricted in practice.
Listing 4 contains an example PDF document that uses
XML external entities. The one-way method getURL is used
to communicate the information back to the attacker. Given
the compact size of the example, it is useful for the syntax
injection scenario in Section 2.3.1, which require injection of
small syntax fragments.

As of version 10.1.5, in accordance with our recommen-
dations, XML external entities has been removed. Thereby
the risks of leakage of sensitive information is signiﬁcantly
reduced.

Embedded Flash.

By embedding a Flash ﬁle in the PDF document the ca-
pabilities of the format can be extended even further. The

Flash runtime supports bidirectional communication in ac-
cordance with SOP. The embedded Flash inherits the origin
of the PDF document, thus it can request and read any doc-
ument from the originating server. Unlike the XML method,
there are no restrictions on what content can be requested,
thus making it the most versatile of the available communi-
cation methods. The only drawback using this approach is
the signiﬁcant increase in terms of ﬁle size. Even the com-
pact Flash code in Listing 5 will result in a 6 kB Flash ﬁle.
This suggests that this method might be better suited for
the content smuggling scenario in Section 2.3.2, rather than
the syntax injection scenario.

Cross-origin communication in Flash adheres to the same-
origin policy. However, this is not a restriction, since Flash
also supports cross-origin communication via cross-origin re-
source sharing. Using CORS, a web server can relax the SOP
to allow access to speciﬁed content. An attacker can set an
allow-all cross-origin policy, such as in Listing 6, that open
up for two way communication.

Listing 4: PDF using XML for communication

%PDF−
1 0 obj<<>>stream
xml = ’ <!DOCTYPE f o o [ <!ENTITY x ’ +

’SYSTEM ”’+URL+’”>]>< f oo>&x; </ f o o > ’;

var doc = XMLData . p a r s e ( xml ) ;
getURL ( ’ a t t a c k e r . com/? s e c r e t =’+

doc . saveXML ( ) )

endstream
t r a i l e r <</Root

<</Pages<<>>

/ OpenAction
<</S/ J a v a S c r i p t /JS 1 0 R>>

>>

>>

Listing 5: Flash code for communication

package {
import
import
p u b l i c

f l a s h . n e t . ∗ ;
f l a s h . d i s p l a y . S p r i t e ;
c l a s s S e c r e t e x t e n d s S p r i t e {

var u : S t r i n g ;
var
var
p u b l i c f u n c t i o n S e c r e t ( ) {

r : URLRequest ;
l : URLLoader ;

u = ’ v u l n e r a b l e . com/ s e c r e t ’ ;
r = new URLRequest ( u ) ;
l = new URLLoader ( r ) ;

l . a d d E v e n t L i s t e n e r ( ’ complete ’ ,

f u n c t i o n ( ) : v o i d {

u = ’ a t t a c k e r . com / ? ’ + r . data ;
r = new URLRequest ( u ) ;
l = new URLLoader ( r ) ;

} ) ;

}}}

Listing 6: Allow-all crossdomain.xml

<c r o s s−domain−p o l i c y >
</ c r o s s−domain−p o l i c y >

<a l l o w−a c c e s s−from domain =”∗” />

7604. EVALUATION

This section details the evaluation performed to investi-
gate the prevalence of the vulnerabilities from Section 3. The
evaluation covers various instances of aﬀected components,
such as browsers and PDF interpreters, content sanitization
ﬁlter, and a study of the Alexa top 100 web sites.
4.1 Instances

To better understand how this problem presents itself, a
comparison of browser and reader instances is presented. We
compare all major browsers and two of the most common
readers.
4.1.1 Readers
Section 3 focuses on the Adobe PDF Reader as the at-
tack surface, due to its standing as the most commonly used
reader. To give a comparison, the Google Chrome built-in
PDF reader was selected as it is the default reader to users
of the browser.

As mentioned in Section 2, the browser rely on the reader
plug-in to implement correct security measures, in order to
prevent cross-domain leakage. Unlike Adobe Reader, the
Chrome browser built-in PDF reader refuses to render con-
tent that was served with an inappropriate MIME-type if
the content is delivered across origins. This eﬀectively pre-
vents the attacks in Section 3.
If the Chrome browser is
conﬁgured to use the Adobe Reader plug-in, it will behave
the same as in other browsers and the content will be inter-
preted as PDF.
4.1.2 Browsers
The behavior of cross-domain embedding of PDF resources
is studied in the major browsers, i.e., Firefox, Safari, Opera,
Google Chrome and Internet Explorer. The study shows
that all major browsers are susceptible to the attacks out-
lined in Section 3, with some minor diﬀerences detailed be-
low and summarized in Table 1. In Table 1, ”Yes” for the
columns ”object” and ”embed” indicates that the correspond-
ing tag can be used to embed a PDF document, and for the
column ”Adobe is default” it indicates that Adobe Reader is
commonly the default PDF reader.

Firefox, Safari and Opera.

The browsers, Firefox, Safari and Opera, are all suscep-
tible to the attacks outlined as per Section 3, without any
restrictions or modiﬁcations.

Google Chrome.

Google’s browser, Chrome, has built-in support for dis-
playing PDF documents. The built-in PDF reader is used
by default by the browser, unless it has been explicitly dis-
abled by the user. Certain complex PDF documents can
not be handled by the built-in reader. The built-in reader
will then prompt the user to open the document in Adobe
Reader. As previously noted in Section 4.1.1, the built-in
reader is not vulnerable to attacks. Hence, Chrome is only
susceptible when the Adobe Reader plug-in is used to render
the document.

Internet Explorer.

Microsoft’s browser, Internet Explorer, is susceptible to
the attacks. However, it seems to only support embedding
of PDF documents using the embed tag. This is not a major

object

embed Adobe is default

Firefox
Chrome
Safari
Opera
Internet Explorer

Yes
Yes
Yes
Yes
No

Yes
Yes
Yes
Yes
Yes

Yes
No
Yes
Yes
Yes

Table 1: Comparison of browsers

obstacle in exploiting the vulnerability, as the embed and
object tags are interchangeable in this respect.
4.2 Alexa top 100

We have conducted two studies to evaluate the prevalence
of the problem on popular sites, covering the Alexa top 100
web sites. Because of their dominance on the web, these web
sites are also the most exposed to security threats. The ﬁrst
study covers PDF-based polyglot attacks using syntax in-
jection as the inﬁltration method; the second covers content
smuggling. We refrain from mentioning names of individual
web sites to prevent exploitation before the issues have been
properly dealt with. We are in contact with the maintainers
of the web sites to help mitigate the vulnerabilities.

Syntax injection.

The study is based on supplying the web sites with the
benign minimal PDF in Listing 2, and examining the corre-
sponding responses to this input. The sample contains the
essential keywords and tokens required to perform a syntax
injection based polyglot attack. If these tokens pass through
unaltered, the web site is considered vulnerable. The pro-
cess has been conducted manually and only input parame-
ters on publicly accessible pages, those that do not require
authentication, were tested. Considering that most inputs
are available only to authenticated users, the results sug-
gests that more web sites are likely vulnerable in input that
do require authentication.

The conclusion is that nine web sites out of the hundred
apply insuﬃcient content ﬁltering with respect to the PDF
format. Out of the nine found to be vulnerable; ﬁve were
susceptible to PDF based polyglot attacks, and four applied
insuﬃcient content ﬁltering, but the input was reﬂected in
a way that prevented exploitation, e.g. the header appeared
after 1024 bytes.

Three of the ﬁve vulnerable web sites could also be de-
termined to be vulnerable to traditional XSS attacks in the
same input parameters. The remaining two web sites found
susceptible only to polyglot attacks and not XSS attacks are
of particular interest since they employ proper measures to
protect against XSS attacks, and yet fall short in defeating
this new breed of attacks.

1. The ﬁrst web site reﬂected user input in an inline
JavaScript context, inside a string. To prevent cross-
site scripting in this context, the following measures
were taken: the JavaScript string delimiters and the
backslash character were properly escaped, and the
string ”</script>” was removed. These measures are
suﬃcient to protect against XSS attacks, but do not
prevent an attacker from injecting valid PDF syntax.

2. The second web site reﬂected the user input in an
HTML-comment context. The only measure taken

761to prevent XSS attacks in this context was removing
any occurrence of the character sequence ”–>”. Again,
while successfully preventing XSS attacks, this mea-
sure is ineﬀective in preventing an attacker from in-
jecting PDF syntax.

Content smuggling.

Further, a smaller study was conducted, not covering the
full Alexa top 100, but targeting popular cloud storage ser-
vices. This study is based on polyglot content being up-
loaded to the service and subsequently analyzed to deter-
mine which origin it was served under. We have found two
major enterprise cloud storage services to be susceptible to
attacks. Both services make an eﬀort to follow current best
practices, see Section 5.2.1, but fail to cover certain scenarios
for content upload.

The ﬁrst service serves almost all uploaded content from
a sandboxed origin; the exception being the user’s avatar
image that are served under the sensitive origin. An attacker
could upload a specially crafted avatar image that, when
embedded as PDF on the attackers web site, can access and
modify the contents of the victim’s cloud storage.

The second service lets the user publish a public link to an
HTML representation of the content. The content is served
under the sensitive origin and is therefore carefully processed
to prevent generation of malicious HTML, but fails to take
other formats into account. A specially crafted ﬁle will result
in the generation of valid PDF syntax that, when embedded
as PDF on the attackers web site, can access and modify the
contents of the victim’s cloud storage.

We are currently advising both service providers to help

mitigate these vulnerabilities.

5. MITIGATION

This section gives advice on various mitigation approaches
available for each of the aﬀected components, both server-
side and client-side. We provide one general mitigation ap-
proach that covers a signiﬁcant segment of the potential at-
tack vectors, and provide speciﬁc mitigation suggestions for
aﬀected components.

Although some of the mitigation suggestions below are
already in place (e.g., the Chrome builtin PDF reader), the
state of the art is far from being satisfactory. As our paper
demonstrates, the polyglot attacks are a real threat. It is
the paper’s main value to bring attention to polyglot attacks
and the importance of mitigation against them.
5.1 General approach

It should be noted that preventing polyglots, and thereby
polyglot attacks, in the general case is a complex task, as
one would need to take all potentially malicious formats in
to account. Mitigating instances of polyglot attacks based
on particular formats are signiﬁcantly more straightforward.
Our approach is not attempting to prevent polyglots as such,
but provide details about the context in which the content
will be interpreted, such that an informed decision can be
made on whether rendering the content constitutes a secu-
rity risk or not.

The relation between web server and the browser is central
in a web environment, but there is no common agreement on
the type of content communicated between server and client.
As mentioned in Section 2.1, in each response the web server

sends a header representing its view on the type of content
delivered, however, the browser is free to ignore the provided
type and can even be instructed to do so. Often the browser
knows precisely the context in which the content will be
rendered and the types suitable for these contexts. As an
example, when content is loaded in an object tag with a type
attribute, as is the case throughout the paper, the browser
already has exact knowledge as to which types the requested
content can be interpreted as in this context. A natural
defense technique is to send the expected types along with
the request. The web server then compares the expected
types to the assumed type and react accordingly, e.g., if the
assumed type is HTML and the expected type is PDF, an
error can be sent back to the client. On the client side,
the browser veriﬁes the type in the response matches any
of the expected types, possibly alerting the user if there
is a mismatch. This mutual agreement between client and
server can help mitigate both syntax injection and content
smuggling. Furthermore, this approach can be implemented
in the web server itself, as opposed to a web application,
since the web server makes the ﬁnal decision on the supplied
content-type.

The expected type is useful also to a web application that
performs content ﬁltering on the ﬂy. At the point when
the content is being requested, it only requires veriﬁcation
against the expected type.

There are limitations to this technique; If a context has
multiple possible types, e.g., an img tag, a polyglot between
two of the types can evade detection. The speciﬁc cases
where this situation occurs in an exploitable way are rare,
and further work can help in determining and mitigating
such vulnerabilities.
5.2 Speciﬁc approaches

Apart from the general approach described above, there
are mitigation approaches that are speciﬁc to each of the
components involved. These are recommended to be used
until general approaches for mitigating polyglot attacks are
widely adopted.

Server-side mitigation

5.2.1
As a content provider on the Internet today there are pre-
cautions that one can take to mitigate this class of vulner-
abilities. Which precautions to take depend on the kind
of services provided. The mitigation recommendations for
syntax injection apply to all services that generate content
based on user input, and the content smuggling recommen-
dations apply to services that serve user-supplied ﬁles.

Syntax injection.

Preventing syntax injection on the server-side poses severe
challenges. Even server-side ﬁltering of HTML syntax to
prevent cross-side scripting attacks has proved diﬃcult due
to the many contexts in which JavaScript can be introduced.
Filtering all potentially harmful tokens from all formats in
which a document may be interpreted is hardly possible.

To prevent attacks based on a speciﬁc format, e.g., a
PDF-based syntax injection attack, the task is simpler. As
discussed in Section 3.3.1, the token-set identiﬁed in Sec-
tion 3.3.1, are essential to create valid PDF syntax. Filter-
ing user input to remove or encode these characters eﬀec-
tively mitigates the vulnerability. Luckily, because of the
signiﬁcant overlap with the token-set of HTML, many of

762the contexts where user input can occur are already being
protected. Special attention is required in contexts are not
traditionally ﬁltered for HTML tokens, e.g. JSON.

Content smuggling.

The current best-practice recommendation on hosting user-
supplied content is to serve the content from a sandboxed
origin that is completely separate, as per SOP, and isolated
from the sensitive services. These best-practices, provided
by Google [18], successfully prevents content smuggling at-
tacks as the restrictions of the SOP prevents the content
from accessing any sensitive resources in the origin of the
web service.

These recommendations come with a caveat to be taken
into consideration. Some user supplied content is only meant
to be accessible to certain authenticated users, e.g. photos
that are only shared with friends. In that case, the service
needs to transfer the credentials required to authenticate the
user from the sensitive origin to the sandboxed origin, with-
out actually revealing the credentials used in the sensitive
origin. Revealing the credentials, e.g. using the same cook-
ies on both origins, defeats the purpose of the sandbox ori-
gin entirely. Currently there is no uniform solution to this
problem. Some common solutions are encountered: using
the hashed credentials of the sensitive origin; or generating
public, but obscured, links that are later shared manually.

5.2.2 Browser
Traditionally, browser vendors have allowed the browser
to override the MIME-type provided by the server for com-
patibility reasons. This is a compromise to deal with the
situation that the server is confused as to what kind of con-
tent it is serving. This compromise has repeatedly shown
to lead to security issues. The aﬀected browser vendors can
help mitigate this problem by limiting the ways content can
be coerced to be interpreted as a particular format.

In the case of PDF-based polyglots, and other polyglots
that require a plugin, the browser can intervene when there
is a mismatch between the content-type provided by the
server and the type attribute of the object tag. The vulner-
ability can be mitigated by acknowledging that there is a
potential security issue in interpreting the supplied content
in the requested format and alerting the user to this threat.
An intuitive approach would be to for the browsers to
employ similar content-sniﬃng for content rendered in plug-
ins, as is already done with content native to the browser.
However, this intuition fails to take into account that the
very reason for using plug-ins is that the format is unknown
to the browser. One may argue that the browser is as con-
fused as the originating server as to the actual format of the
content, and that the issue would be best resolved by the
corresponding plug-in.

5.2.3 Interpreter / Plugin
As a general rule of thumb, the interpreter must at the
very least alert the user if the served content-type diﬀers
from the expected. A preferred alternative is to not attempt
to interpret the content at all. This holds true especially
when the served content-type is well known and radically
diﬀerent from that which the interpreter is designed for.

As for the PDF ﬁle format, the underlying design deci-
sions have led to the current parsing being very relaxed. As
discussed in Section 3.2 the PDF format is a container for-

mat; designed to embed syntax from other ﬁles. Even when
parsing strictly according to the speciﬁcation, it is a simple
task to create a PDF-based polyglot. Making the parsing
more strict and enforcing many of the speciﬁed requirements
will make it harder to create polyglots, reducing the attack
surface.
In accordance with this recommendation, Adobe
has taken the ﬁrst steps to prevent PDF-based polyglots.
Recent versions of the reader compares the ﬁrst bytes of the
document against a set of known ﬁle signatures. While this
is a step in the right direction, this kind of black listing has
its drawbacks. The diﬃculty is that a number of ﬁle formats
that lack a reliable signatures, e.g., HTML.

A diﬀerent approach is restricting capabilities of the for-
mat, sticking to the essential features. The more capable the
format is, the more likely it is to introduce security ﬂaws. In
the latest version of their reader Adobe has made progress
also in this respect by restricting the possibilities for bidi-
rectional communication.

6. RELATED WORK

Recall that the added value of our paper is a generalized
account of polyglot attacks and focus on new instances of
polyglots that involve the PDF format. We brieﬂy report
on related instances of polyglot attacks.

Backes et al. [2] explore the power of the PostScript lan-
guage. PostScript allows executable content and access to
sensitive information from the environment such as the user
id. This work demonstrates how to compromise reviewer
anonymity in a peer-reviewing process by maliciously craft-
ing a PostScript document.

As discussed in Section 2, GIFAR [4] is based on polyglots
that combine the GIF and JAR (Java archive) formats. The
former is used as benign and the latter as malicious to by-
pass SOP. The Java virtual machine vendors have since then
mitigated these attacks by patching the virtual machine to
be more conservative on the format of the executed ﬁles.

PDFAR [5] polyglots combine the PDF and JAR formats,
where PDF serves as benign and JAR serves as malicious.
Such a polyglot is possible due to the liberty of the require-
ments on the headers of PDF ﬁles. Mitigation against GI-
FAR attacks in the Java virtual machine eﬀectively applies
to PDFAR attacks.

Nagra [9] demonstrates GIF/JavaScript polyglots by the
same ﬁle being interpreted as a script and as an image and
informally discuses possible security implications.

Barth et al. [3] investigate the security implications of
content sniﬃng by browsers. They present content-sniﬃng
XSS attacks by crossbreeding HTML with other formats like
PostScript. They show attacks on real systems like HotCRP,
where an uploaded document in the PostScript format is
interpreted as malicious HTML by the browser. They also
propose a content-sniﬃng algorithm that helps defending
against this class of attacks while maintaining compatibility.
Sundareswaran and Squicciarini [14, 13] discuss image re-
purposing for GIFAR attacks. They present the AntiGifar
tool for client-side protection. AntiGifar models the benign
behavior of a user by a control-ﬂow graph and detects possi-
ble anomalies when the interactions of the user and browser
with the web site deviate from the control-ﬂow model.

As mentioned in Section 2, Huang et al. [7] study an
HTML/CSS attack. This attack injects fragments of CSS
syntax in a HTML document, thereby making it a HTM-
L/CSS polyglot. The error-tolerant parsing of style sheets

763allow the polyglot to parsed as valid CSS. The capabilities
of CSS provide trivial cross-origin leakage. As discussed ear-
lier, the paper’s defense technique has been adopted by all
major browsers, which implies that the attacks outlined in
their paper are now ineﬀective.

Wolf’s OMG WTF PDF presentation [15] is one of the
inspirations for our work. The presentation explores the
liberty of the PDF format. In addition, it highlights that
PDF interpreters often disregard the speciﬁcation demands.
This is particularly relevant as it allows crossbreeding PDF
with such formats as ZIP and EXE.

Heiderich et al. [6] explore the Scalable Vector Graphics
(SVG) format. They discover attacks that allow SVG ﬁles,
embedded via the img tag, to run arbitrary JavaScript. One
of the attack vectors involves an SVG/HTML polyglot that
behaves diﬀerently depending on the context in which it is
accessed. When included in the img tag, the ﬁle is inter-
preted as SVG, whereas when it is accessed directly it is
interpreted as malicious HTML.

7. CONCLUSIONS

We have put a spotlight on a new breed of attacks that
smuggle malicious payload formatted as benign content. We
have identiﬁed polyglots as the root cause for this class of
attacks. In a systematic study, we have characterized the
necessary ingredients for polyglot-based attacks on the web
and arrive at the PDF format to be particularly dangerous.
Our empirical studies in the web setting conﬁrm vulnera-
bilities in the current content ﬁlters both in the server side
and in browsers, as well as in the PDF interpreters. These
vulnerabilities open up for insecure communication across
Internet origins and allow attacking web sites from the top
100 Alexa list.

To mitigate the attacks, we suggest general measures against

polyglot-based attacks. These measures are a combination
of protection on the server side, in browsers, and in content
interpreters such as PDF readers.

The aﬀected vendors have been made aware of the vulner-
abilities. These vendors include Adobe (notiﬁed instantly af-
ter discovering the security implications of polyglot PDFs)
and the major browser vendors. We have also contacted the
vulnerable web sites from the top 100 Alexa list. Following
responsible disclosure, we refrain from providing the names
of the vulnerable web sites.

Future work includes identiﬁcation of further formats vul-
nerable to polyglot-based attacks. Versatile media content
formats such as the Windows Media Video format are of
particular concern because of their potential for executing
scripts.

Further investigation of the PDF format might lead to
enhanced possibilities to bypass content ﬁlters by alternative
character sets.

Acknowledgments
This work was funded by the European Community under
the ProSecuToR and WebSand projects and the Swedish
research agencies SSF and VR.

8. REFERENCES
[1] Demo page for crossing origins by crossing formats.

http://internot.noads.biz, August 2013.

[2] M. Backes, M. Durmuth, and D. Unruh. Information

ﬂow in the peer-reviewing process. In Proc. IEEE
Symp. on Security and Privacy, pages 187–191, May
2007.

[3] A. Barth, J. Caballero, and D. Song. Secure content
sniﬃng for web browsers, or how to stop papers from
reviewing themselves. In Proc. IEEE Symp. on
Security and Privacy, pages 360–371, May 2009.
[4] R. Brandis. Exploring Below the Surface of the
GIFAR Iceberg. An EWA Australia Information
Security Whitepaper. Electronic Warfare
Associates-Australia, February 2009.

[5] N. Dhanjani, B. Hardin, and B. Rios. Hacking: The

Next Generation. O’Reilly Media, August 2009.

[6] M. Heiderich, T. Frosch, M. Jensen, and T. Holz.
Crouching tiger - hidden payload: security risks of
scalable vectors graphics. In ACM Conference on
Computer and Communications Security, pages
239–250, October 2011.

[7] L.-S. Huang, Z. Weinberg, C. Evans, and C. Jackson.
Protecting browsers from cross-origin css attacks. In
ACM Conference on Computer and Communications
Security, pages 619–629, October 2010.

[8] Adobe Systems Incorporated. ISO 32000-1:2008

Document management - Portable document format,
2008.

[9] J. Nagra. GIF/Javascript Polyglots. http:

//www.thinkfu.com/blog/gifjavascript-polyglots,
February 2009.

[10] Open Web Application Security Project (OWASP).

OWASP Top 10 2013.
https://www.owasp.org/index.php/Top_10_2013,
2013.

[11] SANS (SysAdmin, Audit, Network, Security)

Institute. The top cyber security risks.
http://www.sans.org, September 2009.

[12] B. Sterne and A. Barth. Content Security Policy 1.0

(W3C Candidate Recommendation).
http://www.w3.org/TR/CSP, November 2012.

[13] S. Sundareswaran and A. Squicciarini. DeCore:

Detecting Content Repurposing Attacks on Clients’
Systems. In Proc. International Conference on
Security and Privacy in Communication Networks
(SecureComm), pages 199–216. Springer-Verlag,
September 2010.

[14] S. Sundareswaran and A. Squicciarini. Image

repurposing for gifar-based attacks. In Collaboration,
Electronic messaging, Anti-Abuse and Spam
Conference, July 2010.

[15] J. Wolf. OMG WTF PDF. Presentation at the Chaos

Computer Congress, December 2010.

[16] World Wide Web Consortium. Cross-Origin Resource

Sharing.
http://www.w3.org/TR/2012/WD-cors-20120403/,
April 2012.

[17] XSSed Team. XSS Attacks Information.

http://www.xssed.com, 2012.

[18] M. Zalewski. Content hosting for the modern web.

http://googleonlinesecurity.blogspot.se/2012/
08/content-hosting-for-modern-web.html, August
2012.

764