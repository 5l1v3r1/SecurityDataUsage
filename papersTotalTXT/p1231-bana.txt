Computationally Complete Symbolic Attacker and Key

Exchange

Gergei Bana∗

INRIA, Paris, France

bana@math.upenn.edu

Graduate School of Systems and Information Engineering, University of Tsukuba

Koji Hasebe†

Tsukuba, Japan

hasebe@iit.tsukuba.ac.jp

Mitsuhiro Okada‡

Department of Philosophy, Keio University, Tokyo, Japan

mitsu@abelard.ﬂet.keio.ac.jp

ABSTRACT
Recently, Bana and Comon-Lundh [7] introduced the notion of
computationally complete symbolic attacker to deliver uncondi-
tional computational soundness to symbolic protocol veriﬁcation.
First we explain the relationship between their technique and Fit-
ting’s embedding of classical logic into S4 [23]. Then, based on
predicates for “key usability”, we provide an axiomatic system in
their framework to handle secure encryption when keys are allowed
to be sent. We examine both IND-CCA2 and KDM-CCA2 encryp-
tions, both symmetric and asymmetric situations. For unforgeabil-
ity, we consider INT-CTXT encryptions. This technique does not
require the usual limitations of computational soundness such as
the absence of dynamic corruption, the absence of key-cycles or
unambiguous parsing of bit strings. In particular, if a key-cycle pos-
sibly corrupts CCA2 encryption, our technique delivers an attack.
If it does not endanger security, the security proof goes through.
We illustrate how our notions can be applied in protocol proofs.

Categories and Subject Descriptors
C.2.2 [Computer CommunicationNetworks]: Network Protocols
–Protocol Veriﬁcation

∗Partially supported by the ANR project ProSe ANR-2010-
VERS-004-01 and FCT project ComFormCrypt PTDC/EIA-
CCO/113033/2009. The work completed while this author was at
MSR-INRIA.
†Partially supported by JSPS KAKENHI Grant Number 24700022
‡Partially supported by Grant-in-Aid for Scientiﬁc Research
(MEXT-JSPS) #23120002 and #30224025, as well as by Program
for the Strategic Research Foundation (MEXT-Shigaku Zaidan)

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for proﬁt or commercial advantage and that copies bear
this notice and the full citation on the ﬁrst page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior speciﬁc permission and/or a fee. Request
permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516710

Keywords
Security Protocols; Computational Soundness
1.

INTRODUCTION

Approaches to computationally sound automated veriﬁcation of
security protocols can be divided into two groups. Works in one
[3, 20, 4, 17, 24] deﬁne symbolic adversaries, and soundness theo-
rems state that under certain circumstances, if there is no successful
symbolic attack, then there is no successful computational attack
either. The other group aims to work directly in the computational
model [21, 14, 9, 10, 8]. In this latter case, computational sound-
ness means that the properties on which symbolic manipulations
are conditioned hold computationally.

The ﬁrst group, where a symbolic attacker is deﬁned, gives hope
that already existing automated tools may be adopted for compu-
tationally sound veriﬁcation, but these soundness theorems require
large sets of assumptions. A number of assumptions, as well as
reasons why they are not realistic are discussed in [18]. Such as-
sumptions are, for example, that bit strings can be unambiguously
parsed into symbolic terms, or, that no key cycles occur, or, that all
keys are honestly generated, or, that there is no dynamic corruption.
Recently, Backes et al. in [2] showed a way to avoid some of these
problems such as key-cycles and badly generated keys, but for the
computational implementation of the encryption, they needed to
require a very strong notion called PROG-KDM security. More-
over, they still used an entire page to list all the further necessary
conditions (such as unambiguous parsing) limiting the computa-
tional implementation that they needed for soundness. But PROG-
KDM security and the other conditions are necessary only to re-
ceive computational guarantees for their symbolic analysis even if
computational security of the analyzed protocol holds without these
requirements. Their strong conditions are imposed on the compu-
tational implementation not for the security of the protocol, but for
the soundness of the analysis.

Recently, Bana and Comon-Lundh (BC) presented in [7] a new
kind of symbolic attacker. They called it computationally com-
plete symbolic adversary, as it is capable of doing everything that
a computational adversary is capable of. They observed that the
discrepancy between symbolic and computational proofs emerges
from the following fact: While the usual computational security
assumptions on the primitives (such as IND-CCA2 security of the
encryption) deﬁne what the adversary cannot violate (and the secu-

1231rity of the protocol is derived from the security of the primitives),
symbolic adversaries are deﬁned by listing all the adversarial ca-
pabilities (Dolev-Yao rules). Hence, to adjust the viewpoint of the
symbolic analysis to that of the computational, instead of listing ev-
ery kind of moves a symbolic adversary is allowed to do, Bana and
Comon-Lundh list a few rules (axioms) that the symbolic adversary
is not allowed to violate. Anything that does not contradict these
axioms is allowed for the adversary. Hence, a successful symbolic
attack in their case means that the violation of the security prop-
erty of the protocol is consistent with the axioms. The axioms that
are introduced must be computationally sound with respect to the
computational interpretation they deﬁned. Their general soundness
result is the following: Suppose that the computational implemen-
tation satisﬁes a set of axioms. If there is a successful PPT attacker
for which the number of sessions it exploits does not increase in-
deﬁnitely as the security parameter increases (there is a bound, but
it can be arbitrarily high), then there is also a successful symbolic
adversary complying with the set of axioms.

The difference between the original Dolev-Yao (DY) technique
and that of BC can be best understood from the following pictures.
In the DY technique, as more and more rules are added, the sym-
bolic adversarial capabilities are increasing, the symbolic adversary
covers more and more of the computational capabilities. However,
no-one has been able to come up with rules that properly cover all
possible computational capabilities. As Figure 1 shows, there are
always some computational capabilities that are not covered by the
DY ones. All computational soundness results that use the DY

symbolic adversaries in the end have to impose some signiﬁcant
limitations on the computational implementation.

In the BC approach, without axioms, the symbolic adversary is
allowed to do anything. As axioms are added, the symbolic adver-
sary’s capabilities are decreasing. Their main theorem is that if the

In [5], Bana et al.

axioms are computationally sound, the symbolic adversarial capa-
bilities cover all of the computational adversarial capabilities that
use bounded number of sessions. This is illustrated in Figure 2.
Clearly, if the symbolic adversary is too strong, security of proto-
cols cannot be proven. Therefore, the aim is to create a library of
axioms that are sound and are sufﬁcient to prove actual protocols.
introduced several modular, computation-
ally sound axioms, and veriﬁed secrecy and authentication of the
Needham-Schroeder-Lowe protocol to illustrate that the technique
can indeed be used to verify actual protocols. However, as Backes
et al. have pointed out in [2], the axioms in [5] were not suitable
when decryption keys were sent around in the course of the pro-
tocol (under encryptions for example, in a key distribution). The
current work aims to address this problem.

Before we describe this current work in detail, it is worth ask-
ing ourselves, does it really make sense to develop a new technique
when such tools as CryptoVerif and EasyCrypt exist? However,
EasyCrypt at its current stage is more for proving properties about
primitives, such as CCA2 security from hardness assumptions; it
is not suitable for more complex protocols. CryptoVerif is a very

powerful tool for protocol analysis, but if it fails to prove a proto-
col, other than its developer, it is difﬁcult for a user to know what
to do. The aim of the BC technique is to construct a relatively sim-
ple, intuitive system. If we remove the explanations, the axioms
in this paper are just a few lines, perhaps half a page, and most of
them are trivial. The BC technique is still lightweight compared to
CryptoVerif or EasyCrypt. BC does not use explicit probabilities,
neither game reductions. Proofs are readable to human, convenient
for human interaction if automated. NSL and the and the symmet-
ric Needham-Schroeder protocols were proven by hand, without
any assumption on parsing unambiguity. Available other proofs of
the NSL protocol including the one with CryptoVerif all assume
unambiguous parsing. The NSL proof with this technique reduces
to 2-3 pages with unambiguous parsing. For an initial decidability
result, see Comon et al. [19].

1.1 Our Work

In this paper we tackle the problem of key exchange, but along
the way we also present various other improvements on the orig-
inal work of Bana and Comon-Lundh. In their original work [7],
the general soundness theorem worked only for certain kinds of
ﬁrst-order formulas, and the non-negligible subsets of the compu-
tational execution had to satisfy a certain computability property.
Later, in the online version of their paper [6] they presented im-
proved computational semantics for the disjunction and existential
quantiﬁcation, and with that they could make the general sound-
ness proof work for any ﬁrst-order formula. But they still needed
the computability condition on the non-negligible subsets (not an
important limitation though, but not pretty). In this work, we re-
move this limitation with a trick in the soundness proof.

Bana and Comon-Lundh proved their general soundness theorem
directly from their deﬁnitions. This involved showing that although
computational semantics of their compound formulas are not de-
ﬁned as usual in Tarskian semantics, ﬁrst-order deduction rules and
axioms are valid with respect to their semantics too. As it turns
out, this actually follows from Fitting’s theorem of embedding ﬁrst-
order logic into ﬁrst-order S4 [23]. After introducing the basics, we
detail this relationship in the current work, and show how the BC
general soundness theorem follows from Fitting’s theorem.

In order to tackle key exchange, the necessary element to incor-
porate in the framework is key usability, an idea introduced in [22]
for a different framework. This notion is meant to express whether
a properly generated key, at a certain point of the protocol execu-
tion, is still usable for secure encryption or whether it has been
compromised. If a decryption key (or just a key in the symmetric
case) is sent in the clear, the encryption key associated to it cannot
be used for secure encryption any more. Or, a key that was sent in
a key cycle, may also have lost its capability to encrypt securely if
the encryption scheme is only IND-CCA2 secure. More generally,
keys can also be compromised in more subtle, non-trace fashion.

For overall consistency of notation, instead of key usability we
introduce the opposite, namely key compromise as a predicate. We
deﬁne key compromise predicates both for symmetric and asym-
metric encryptions, both for IND-CCA2 [12] and KDM-CCA2 [1,
15] cases, and also for INT-CTXT [13] unforgeability. There is
an essential difference from the way key usability was deﬁned in
[22], we explain that at our deﬁnition. (Furthermore, the axioms
in [22] were introduced to work for the Difﬁe-Hellmann key ex-
change, they are not helpful with other protocols.)

Further essential innovations of this paper are predicates repre-
senting adversarial derivability (computability) with oracle access.
This makes the axioms simpler than just using derivability as in
[5]. Depending on whether IND-CCA2 or KDM-CCA2 oracles are

(cid:34)(cid:69)(cid:69)(cid:1)(cid:46)(cid:80)(cid:83)(cid:70)(cid:37)(cid:58)(cid:1)(cid:51)(cid:86)(cid:77)(cid:70)(cid:84)(cid:36)(cid:80)(cid:78)(cid:81)(cid:86)(cid:85)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:66)(cid:77)(cid:34)(cid:84)(cid:84)(cid:86)(cid:78)(cid:81)(cid:85)(cid:74)(cid:80)(cid:79)(cid:84)(cid:34)(cid:83)(cid:70)(cid:1)(cid:34)(cid:69)(cid:75)(cid:86)(cid:84)(cid:85)(cid:70)(cid:69)(cid:85)(cid:80)(cid:1)(cid:52)(cid:90)(cid:78)(cid:67)(cid:80)(cid:77)(cid:74)(cid:68)(cid:39)(cid:80)(cid:83)(cid:78)(cid:86)(cid:77)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:36)(cid:80)(cid:78)(cid:81)(cid:86)(cid:85)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:66)(cid:77)(cid:1)(cid:34)(cid:85)(cid:85)(cid:66)(cid:68)(cid:76)(cid:70)(cid:83)(cid:37)(cid:80)(cid:77)(cid:70)(cid:87)(cid:14)(cid:58)(cid:66)(cid:80)(cid:1)(cid:34)(cid:85)(cid:85)(cid:66)(cid:68)(cid:76)(cid:70)(cid:83)(cid:39)(cid:74)(cid:72)(cid:86)(cid:83)(cid:70)(cid:1)(cid:18)(cid:34)(cid:69)(cid:69)(cid:36)(cid:80)(cid:78)(cid:81)(cid:86)(cid:85)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:66)(cid:77)(cid:77)(cid:90)(cid:52)(cid:80)(cid:86)(cid:79)(cid:69)(cid:1)(cid:34)(cid:89)(cid:74)(cid:80)(cid:78)(cid:84)(cid:34)(cid:69)(cid:69)(cid:1)(cid:46)(cid:80)(cid:83)(cid:70)(cid:36)(cid:80)(cid:78)(cid:81)(cid:86)(cid:85)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:66)(cid:77)(cid:77)(cid:90)(cid:52)(cid:80)(cid:86)(cid:79)(cid:69)(cid:1)(cid:34)(cid:89)(cid:74)(cid:80)(cid:78)(cid:84)(cid:36)(cid:80)(cid:78)(cid:81)(cid:86)(cid:85)(cid:66)(cid:85)(cid:74)(cid:80)(cid:79)(cid:66)(cid:77)(cid:1)(cid:34)(cid:85)(cid:85)(cid:66)(cid:68)(cid:76)(cid:70)(cid:83)(cid:35)(cid:66)(cid:79)(cid:66)(cid:14)(cid:36)(cid:80)(cid:78)(cid:80)(cid:79)(cid:1)(cid:34)(cid:85)(cid:85)(cid:66)(cid:68)(cid:76)(cid:70)(cid:83)(cid:39)(cid:74)(cid:72)(cid:86)(cid:83)(cid:70)(cid:1)(cid:19)1232used, and on whether the encryption is symmetric or asymmetric,
we deﬁne four such derivability with oracle access predicates.

We introduce axioms and show that they are computationally
sound. The axioms are suitable for (but not limited to) inductive
reasoning: if something is uncompromised up-to a point, then cer-
tain newly sent messages do not destroy this property. They are
also entirely modular: Introducing further primitives will not de-
stroy the soundness of these axioms, they do not have to be proved
again.
If we want to prove a protocol that uses further primi-
tives such as signatures besides encryption, then we only have to
introduce new axioms for the new primitives. For encryption, the
current axioms can still be used unchanged. Hence, a library of ax-
ioms can be gradually developed by adding more and more axioms.
A nice feature of our new predicates for key usability and deriv-
ability with oracles is that we only have a single axiom requiring
CCA2 security of the encryption: the axiom stating that fresh keys
are uncompromised (with respect to CCA2 security). The rest of
the axioms, such as the one expressing that encryption with un-
compromised key hides the plaintext, or the one expressing non-
malleability are immediate consequences of the computational se-
mantics of the derivability and key-compromise predicates.

We emphasize that we introduce axioms for KDM-CCA2 secu-
rity to be able to analyze protocols for which KDM security is com-
putationally necessary: Unlike [2], in our case, for those protocols
that do not require KDM security for their computational sound-
ness, the use of our IND-CCA2 axioms is sufﬁcient.

After presenting the axioms and their soundness proofs, we look
at three simple examples in Section 11 to illustrate how the axioms
work with special focus on comparing how the IND-CCA2 and the
KDM-CCA2 axioms are applied to key cycles. We show security
in a case when there are no key cycles, then we present a case when
there is a key cycle and the IND-CCA2 axioms provide an attack
while KDM-CCA2 axioms still prove security. Finally we show a
case when there is a key cycle, but as it is under another encryption
it does not danger security even in the IND-CCA2 case and the
security proof goes through. We also show that the axioms in [5]
without key compromise are not sufﬁcient to treat these examples.
Finally, we present the result of our proof of the Amended Sym-
metric Needham-Schroeder Protocol. This protocol ﬁrst distributes
a session key, and then uses the distributed key to share a secret.
Using the IND-CCA2 and INT-CTXT axioms, we proved that the
key is securely distributed, that the shared nonce remains secret,
and that agreement and authentication hold. It is posted online at
the ﬁrst author’s homepage.

The technique of [7] and also this work allows to avoid all re-
strictions mentioned before on the computational world. Once a
protocol is proven secure in our symbolic model with respect to a
set of axioms, then all properties that the computational implemen-
tation has to satisfy for computational security are included in the
axioms. Any number of bad keys are allowed to be generated by the
adversary; any number of corrupted, uncorrupted, or dynamically
corrupted parties can be present. As for parsing of bit strings into
terms, previous soundness results relied on unambiguous parsing.
Within this framework, there is no need for such an assumption. We
do not even need the condition that encryptions, pairing are length
regular (i.e. encryption, pairing of inputs that have the same length
output bit strings of the same length).

As long as indistinguishability properties are not concerned, the
only signiﬁcant restriction remains that the technique is not capable
to detect computational attacks for which the PPT attacker needs
the number of sessions to grow indeﬁnitely as the security param-
eter increases. (It is the general soundness theorem that requires
bounded number of sessions, not the axioms.) However, the usual

Dolev-Yao technique is not capable of doing this either. (ProVerif
for example is unbounded only in the sense that it works for ar-
bitrary number of sessions, but still, if an attack is found, that,
and the corresponding computational attack uses a given number
of sessions independently of the security parameter.) Nevertheless,
it would still be nice to have conditions under which the absence of
successful symbolic BC adversaries means that there are no compu-
tational attacks even if unbounded number of sessions are allowed.
For example, if only CCA2 encryptions and pairings are used to
construct messages, we believe that this statement holds. Analysis
of this is left for future work.

The contributions of this paper include (i) relating the BC tech-
nique to Fitting’s embedding, (ii) syntax and computational seman-
tics of key compromise and derivability with oracle access, (iii) a
library of axioms for symmetric and asymmetric IND-CCA2 and
KDM-CCA2 encryptions and INT-CTXT encryptions as well, (iv)
soundness result of the axioms, (v) short examples to illustrate how
the axioms are used with an emphasis on key-cycles, (vi) summary
of the veriﬁcation of the symmetric Needham-Schroeder protocol
with this tool as a proof of concept. (The NSL proof in [5] can also
be done with the current set of axioms the same way as it was done
there, with minor modiﬁcations only.)

The paper is organized as follows: In Section 2, we give the in-
tuitive description of our new predicates. In Section 3, we present
our ﬁrst-order language, which is an extension of that of BC. We
then summarize in Sections 4 and 5 how Bana and Comon treated
the symbolic and computational executions in [7], deﬁne compu-
tational semantics, and present the general soundness theorem. In
Section 6, we show how the BC technique is related to Fitting’s em-
bedding of classical logic in S4, and show how the general sound-
ness result of Bana and Comon-Lundh follows from Fitting’s theo-
rem. Section 7 is devoted to the semantics of the new derivability
predicates with oracles and their axioms, and Section 8 is the same
for key usability. In Section 9 we discuss congruence of the equal-
ity predicate. In Section 10 we state and prove our soundness theo-
rem for the axioms. In Section 11, we show a few simple examples
of how inconsistency of certain formulas with the axioms can be
proven. Finally, in Section 12, we state the result of the veriﬁcation
of the amended symmetric NS protocol with our tool.

We thank Pedro Adão, Bruno Blanchet, Rohit Chadha and Hu-

bert Comon for helpful suggestions and valuable discussions.

2. DERIVABILITY, KEY COMPROMISE

The most important new aspect of the symbolic execution in [7]
was to replace the DY technique’s ﬁxed deﬁnition of what the sym-
bolic adversary can deduce, x1, ..., xn (cid:96) y, with a derivability
predicate1 x1, ..., xn  y for which the symbolic semantics is not
ﬁxed. Namely, while in the DY technique, x1, ..., xn (cid:96) y meant
that using only the DY rules y can be computed from x1, ..., xn, in
the BC case x1, ..., xn y is given some unﬁxed symbolic interpre-
tation in an abstract model M for which they only require to satisfy
some (computationally sound) axioms. That is, the axioms express
what the symbolic adversary cannot violate. They do imply that
from DY deducibility, satisfaction of the derivability predicate fol-
lows, for example, {y}K , K  y. But in the BC system these rules
are not what the adversary can at most do, but what it can certainly
at least do (in other words, the adversary is not allowed to be unable
to do it). The idea is that symbolic interpretation of x1, ..., xn  y
1Note, that in [7] Bana and Comon-Lundh denoted this predicate
as x1, ..., xn (cid:96) y although (cid:96) is usually reserved for denoting de-
ducibility in a proof system. We ﬁnd that somewhat confusing, so
we use the notation x1, ..., xn  y to emphasize that we do not
mean some speciﬁc deducibility by it, it is a predicate.

1233should be at least as powerful as computability of y from x1, ..., xn
by some probabilistic polynomial time algorithm, and so the only
limitations that we want to put on symbolic satisfaction of  are
limitations that are derived from computational computability.

One of the major innovations we propose here is that axioms be-
come simpler if we allow the use of some oracles for the adversary.
For example, considering IND-CCA2 public key encryption, it is
better to introduce a new derivability predicate, x1, ..., xn aic2 y
with the computational semantics meaning that the interpretation of
y can be derived from the interpretation of x1, ..., xn by a PPT ad-
versary with the help of decryption oracles that decrypt everything
that are not results of encryptions on the left hand side. Similarly,
for the symmetric case, we can introduce x1, ..., xn sic2 y mean-
ing that y can be derived from x1, ..., xn with the help of decryp-
tion oracles and encryption oracles. That is, the algorithm trying
to compute y from the x1, ..., xn is allowed to submit strings to
the oracles for encryption and also for decryption. The decryption
oracle decrypts as long as the submitted string is not an encryp-
tion from x1, ..., xn or an encryption produced by the encryption
oracle. The encryption oracles here are needed, because the adver-
sary cannot himself do encryptions (he does not know the key), and
for this reason the IND-CCA2 deﬁnition for symmetric encryption
allows the submission to the encryption oracle multiple times. In
fact, for uniformity, we allow it for the public case too, as IND-
CCA2 is equivalent for the case of multiple submissions to encryp-
tion oracles [11]. Similarly, we will also deﬁne derivation with
oracle accessibility for KDM-CCA2 encryptions, which is some-
what more tricky. But encryption oracles using which keys? The
answer is, keys honestly generated by the agents during the execu-
tion. We will use the notation Ofor such derivability with O being
either aic2, sic2, akc2, skc2 or nothing, depending on whether we
want asymmetric or symmetric IND-CCA2 oracles, or asymmetric
or symmetric KDM-CCA2 oracles, or no oracles. (O is Fraktur O.)
Our next innovation is key usability for the case when keys are
sent around. More precisely, to match the notation of derivability,
we consider key compromise, which is the negation of key usabil-
ity. We use the notation x1, ..., xn (cid:73)O K, where O again indexes
whether we are talking about IND-CCA2, KDM-CCA2, symmetric
or asymmetric encryption (there is always some oracle here). The
intuitive meaning is that if x1, ..., xn are given to the adversary with
access to the given oracles, then K becomes compromised, encryp-
tion with K is not secure against the adversary any more. For ex-
ample, K, x2 (cid:73)OK. Or, {K}K(cid:48) , K(cid:48) (cid:73)OK. Or, if x1, ..., xn OK,
then x1, ..., xn (cid:73)O K. But, presumably, if x1 is just the ﬁrst half
of K, then x1 (cid:73)O K may still hold, while x1 OK does not. That
is, while x1, ..., xn OK clearly implies x1, ..., xn (cid:73)OK, the other
way is not necessarily true. Nevertheless the two properties, as we
will see, behave very similarly, so we chose similar notation for
them. We also consider key usability for INT-CTXT unforgeabil-
ity.

3. LANGUAGE

The core of the framework used in this paper was introduced by
Bana and Comon-Lundh in [7]. Along with our new innovations,
we present a brief summary of the original system of Bana and
Comon-Lundh as well.
3.1 Terms, Predicates, Formulas
Terms are built out of a set of function symbols F that contains
an unbounded set of names N and an unbounded set of handles
H. Names and handles are constants (zero-arity function symbols).
We use names to denote items honestly generated by agents, while
handles denote inputs of the adversary. Let X be an unbounded set

of variables. A ground term is without variables.
Let P be a set of predicate symbols over terms. We assume here
that P contains the binary predicate = and is used as t1 = t2 and
the following families of of (n + 1)-ary predicates meaning various
sorts of derivability:

t for derivability of the rhs from the lhs with

access to IND-CCA2 oracles in asymmetric case

• t1, ..., tnnt for derivability of the rhs from the lhs
• t1, ..., tn aic2
• t1, ..., tn sic2
• t1, ..., tn akc2
• t1, ..., tn skc2

access to KDM-CCA2 oracles in asymmetric case

access to IND-CCA2 oracles in symmetric case

access to KDM-CCA2 oracles in symmetric case

n

n

n

n

t for derivability of the rhs from the lhs with

t for derivability of the rhs from the lhs with

t for derivability of the rhs from the lhs with

and the following key compromise predicates:

• t1, ..., tn (cid:73)aic2
• t1, ..., tn (cid:73)sic2
• t1, ..., tn (cid:73)akc2

n K meaning the lhs compromises (with oracle

access) secure asymmetric IND-CCA2 encryption with K

n K meaning the lhs compromises (with oracle

access) secure symmetric IND-CCA2 encryption with K

n K meaning the lhs compromises (with ora-
cle access) secure asymmetric KDM-CCA2 encryption with
K• t1, ..., tn (cid:73)skc2
n K meaning the lhs compromises (with or-
acle access) secure symmetric KDM-CCA2 encryption with
K• t1, ..., tn (cid:73)ic
access) INT-CTXT unforgeability of encryptions with K.
We always drop the index n: t1, ..., tn Ot and t1, ..., tn (cid:73)OK.

n K meaning the lhs compromises (with oracle

4. SYMBOLIC EXECUTION

In case of the Dolev-Yao adversary, derivability predicates would
have ﬁxed interpretations. For example,  holds in case of a DY
adversary, if the right-hand side can be computed from the left-hand
side with the DY rules. However, for the symbolic execution, the
BC technique allows any interpretation of the predicates (including
=) that does not contradict some axioms (introduced later).
Accordingly, let M be any ﬁrst-order structure that interprets the
function and predicate symbols of the logic. We denote by DM the
domain of interpretation, and by OM, (cid:73)OM and =M the relations
on DM interpreting O, (cid:73)O, and = respectively. Given an assign-
ment σ of elements in DM to the free variables of term t, we write
[[t]]σM for the interpretation of tσ in M ([[_]]σM is the unique exten-
sion of σ into a homomorphism of F-algebras). For any ﬁrst-order
formula θ, for any ﬁrst-order structure M over the functions F and
predicates P, and any assignment σ of the free variables of θ in
the domain of M, the satisfaction relation M, σ |= θ is deﬁned as
usual in ﬁrst-order logic from the satisfaction of predicates.
4.1 Protocols

Bana and Comon-Lundh set up their technique to be convenient

for constraint-solving methods as in [16].

Let Q be a set of control states (not necessarily ﬁnite). A proto-

col is a recursive set of tuples

((q, n), (q

(cid:48)

, n, n(cid:48)),(cid:104)x1, ..., xm(cid:105) , x, ψ, s)

where q, q(cid:48) ∈ Q, x1, ..., xm, x are variables (into which agents read
messages from the adversary), n, n(cid:48) are disjoint ﬁnite sequences of
names (corresponding to honestly generated items such as keys,
nonces). ψ is some formula corresponding to agent checks on
incoming messages. For example, ψ can be a formula such as

1234dec(x, k) = n, checking whether the input decrypts to a previ-
ously generated nonce n. ψ is over the variables {x1, ..., xm, x},
the names n, the function symbols F without the rest of the names
and handles, and some subset of the predicate symbols P. Finally,
s is the output message, when the transition succeeds. s is built
from the variables {x1, ..., xm, x}, the names n, n(cid:48), and the func-
tion symbols F without the rest of the names and handles.
4.2 Execution of a Protocol and Attacks
In applied π-calculus, frames are sequences of terms with name
binders: a frame φ can be written νn.(cid:104)p1 (cid:55)→ t1, ..., pn (cid:55)→ tn(cid:105)
where p1, ...pn are place holders that do not occur in t1, ..., tn and
n is a sequence of names, but we think of a frame simply as a list
of terms (cid:104)t1, ..., tn(cid:105) representing the messages that agents have sent
over the network, that is, messages that the adversary has seen. The
names, variables of φ are the names, variables of t1, ..., tn.

(randomly) generated so far, n1, ..., nk

A symbolic state of the network consists of:
• a control state q ∈ Q together with a sequence of names
• a sequence of constants called handles h1, ..., hn (recording
• a ground frame φ (the agents outputs)
• a set of closed formulas Θ (all conditions that must be satis-

the attacker’s inputs)

ﬁed in order to reach the state).

A symbolic transition sequence of a protocol Π is a sequence
((q0, n0),∅, φ0,∅) → ... → ((qm, nm),(cid:104)h1, ..., hm(cid:105) , φm, Θm)
if, for every m − 1 ≥ i ≥ 0, there is a transition rule

((qi, αi), (qi+1, αi+1),(cid:104)x1, ..., xi(cid:105) , x, ψ, s)

such that n = αi+1 \ αi, φi+1 = (φi, sσi+1), ni+1 = (ni, n),
Θi+1 = Θi ∪ {φi  hi+1, ψσi+1} where σi+1 = {x1 (cid:55)→ h1, ...,
xi (cid:55)→ hi, x (cid:55)→ hi+1}. If necessary, some renaming of the sequence
αi+1 ensures the freshness of the names n: n ∩ ni = ∅.
Given an interpretation M, a transition sequence of Π
((q0, n0),∅, φ0,∅) → ... → ((qm, nm),(cid:104)h1, ..., hm(cid:105) , φm, Θm)
is valid w.r.t. M if, for every m − 1 ≥ i ≥ 0, M |= Θi+1.

Examples of symbolic executions can be found in [7] and [5].

4.3 Symbolic Satisfaction of Formulas

M modeled, among others, the predicate t1, ..., tn  t. In execu-
tions we also consider a predicate that we write as ˆφ, t1, ..., tn  t.
This is also an n + 1-arity predicate. ˆφ is just a symbol, not an
argument, and it represents the frame containing the messages that
protocol agents sent out, that is, the information available from the
protocol to the adversary. We also use a number of different con-
straints: Handle(h) means h is a handle, RanGen(x) means that x
was honestly, randomly generated (i.e. appears in the n of the con-
trol state); x (cid:118) ˆφ means that x is a subterm of a message sent out by
an agent (i.e. listed in the frame φ), x (cid:118) (cid:126)x means x is subterm of (cid:126)x.
dK (cid:118)d ˆφ means dK occurs somewhere other than in a decryption
position dec( , dK) in φ, and dK (cid:118)d (cid:126)x is analogous (dK may also
occur in a decryption position in (cid:126)x, but it has to occur elsewhere
too)2. Similarly, let K (cid:118)ed ˆφ mean that symmetric key K occurs
somewhere other than in an encryption or decryption position (as
{|_|}K or sdec( , K)) in φ, and K (cid:118)ed (cid:126)x is analogous (K may also
2In this paper, we will use the notation {x}R
eK and dec(y, dK) for
both symmetric and asymmetric encryptions with random input R,
where in the symmetric case, eK = dK = K. We use {|x|}R
K and
sdec(y, K) for symmetric encryption and decryption only.

occur in encryption or decryption position in (cid:126)x, but it has to occur
elsewhere too). Let us introduce the following abbreviations:

• x (cid:118) ˆφ, (cid:126)x ≡ x (cid:118) ˆφ ∨ x (cid:118) (cid:126)x
• fresh(x; ˆφ, (cid:126)x) ≡ RanGen(x) ∧ x (cid:54)(cid:118) ˆφ, (cid:126)x
• keyfresh(K; ˆφ, (cid:126)x) for asymmetric key:

• keyfresh(K; ˆφ, (cid:126)x) for symmetric key:

keyfresh(K; ˆφ, (cid:126)x) ≡ RanGen(K) ∧ dK (cid:54)(cid:118)d ˆφ, (cid:126)x
keyfresh(K; ˆφ, (cid:126)x) ≡ RanGen(K) ∧ K (cid:54)(cid:118)ed ˆφ, (cid:126)x
• x (cid:52) ˆφ, (cid:126)x ≡ ∀h(h (cid:118) x ∧ Handle(h) → ˆφ, (cid:126)x  h)

(cid:126)x (cid:52) ˆφ, (cid:126)y ≡ (cid:87)

(cid:52) ˆφ, (cid:126)y ∧ xp2

(cid:52) ˆφ, (cid:126)y, xp1 ∧ ...

p(xp1

∧ xpn

(cid:52) ˆφ, (cid:126)y, xp1 , ..., xpn−1 )

Where p runs through all permutations of 1, ..., n. Further, for sym-
metric encryption we also require for x (cid:52) ˆφ, (cid:126)x that if any R is a
random input of an encryption in ˆφ, (cid:126)x, x then the only way it can
appear in x is within that same encryption.
If M is a ﬁrst-order model, satisfaction of predicates and con-
straints in a symbolic execution (denoted by |s= ) is deﬁned recur-
sively: Let n = (n1, ..., nk) be a list of names and φ = (cid:104)t1, ..., tm(cid:105)
a list of closed terms. Let σ be a substitution of free variables of
the rhs of |s= with elements in the domain of M.

• Satisfactions of predicates by M, σ, n, φ (depends on M):

– M, σ, n, φ|s= t = t(cid:48) if M, σ |= t = t(cid:48)
– M, σ, n, φ|s= ˆφ, s1, ..., sn Ot
if M, σ |= t1, ..., tm, s1, ..., sn Ot.
– M, σ, n, φ|s= ˆφ, s1, ..., sn (cid:73)Ot
if M, σ |= t1, ..., tm, s1, ..., sn (cid:73)Ot.

• Satisfactions of constraints by M, σ, n, φ are independent of

M and σ so we deﬁne them as satisfaction by n, φ:

– Handle(h) for h closed term:
n, φ|s= Handle(h) if h∈H.
– RanGen(s) for s closed term:
n, φ|s= RanGen(s) if s ∈ N
and M, σ |= s = n1 ∨ ... ∨ s = nk.
– t (cid:118) ˆφ, where t is closed term:
n, φ|s= t (cid:118) ˆφ if t is a subterm of some ti
– t (cid:118) s1, ..., sn, where s1, ..., sn, t are closed terms:
n, φ|s= t(cid:118) s1, ..., sn if t is a subterm of some si

• Satisfaction of any FOL formula by M, σ, n, φ:

– θ1∧θ2, θ1∨θ2, and ¬θ are interpreted as usual in FOL.
– If x is not under a constraint in θ, interpretations of ∀xθ

– If x occurs under a constraint in θ, then

and ∃xθ are deﬁned as usual in FOL.
∗ M, σ, n, φ|s= ∀xθ iff for every ground term t,

M, σ, n, φ|s= θ{x (cid:55)→ t}

∗ M, σ, n, φ|s= ∃xθ iff there is a ground term t,

M, σ, n, φ|s= θ{x (cid:55)→ t}

• Satisfaction at step m:
M, σ, ((q, n),(cid:104)h1, ..., hm(cid:105) , φm, Θ)|s= θ
iff M, σ, n, φm |s= θ.

We say there is a successful symbolic attack against the security
property θ (a ﬁrst-order formula) of the protocol if there is a model
M and state of an execution ((q, n),(cid:104)h1, ..., hm(cid:105) , φm, Θ) such
that M, ((q, n),(cid:104)h1, ..., hm(cid:105) , φm, Θ)|s= ¬θ holds, and moreover,
M, ((q, n),(cid:104)h1, ..., hm(cid:105) , φm, Θ) also satisﬁes the computation-
ally sound axioms that we introduce in the rest of the paper. This

1235is the same as saying that there is a successful symbolic attack if at
a certain point of some symbolic execution, the axioms, the agent
checks and the negation of the security property are all consistent.

5. COMPUTATIONAL EXECUTION

We now summarize the computational semantics. Short proofs
of Theorems 5.2 and 5.3 are in the Section 6 using Fitting’s embed-
ding of classical logic into S4 [23].
5.1 Computational Execution

Following Bana and Comon, we consider a family of computa-
tional algebras, parametrized by a security parameter η, in which
each function symbol is interpreted as a polynomially computable
function on bit strings (that may return an error message). Given
a sample τ of names, every ground term t can be interpreted as
a bit string [[t]]τ in such a way that [[_]]τ is a homomorphism of
F-algebras (a name n is interpreted as a bit string τ (n)). More
generally, if σ is an assignment of the variables of t to bit strings,
[[t]]σ
τ is the (unique) extension of τ (on names) and σ (on variables)
as a homomorphism of F-algebras.

Given a set of transition rules, a computational state consists of
• a symbolic state s (that is itself a tuple ((q, n), h, φ, Θ))
• a sequence of bit strings (cid:104)b1, ..., bm(cid:105) (attacker outputs)
• a sequence (cid:104)b(cid:48)
m(cid:105) of bit strings (agents’ outputs)
• the conﬁguration γ of the attacker.

1, ..., b(cid:48)

Given a PPT interactive Turing machine Mc and a sample τ, a
sequence of transitions

0, γ0) → ... → (sm,(cid:104)b1, ..., bm(cid:105) ,(cid:10)b

(cid:48)
1, ..., b
is (computationally) valid with respect to Mc and τ if

(cid:11) , γm)

(s0,∅, (cid:126)b(cid:48)

(cid:48)
m

i+1

M γ(cid:48)

• s0 → ··· → sm is a transition sequence of the protocol
• for all i = 0, ..., m − 1, si = ((qi, ni), hi, φi, Θi), φi+1 =
• for every i = 0, ..., m − 1, there is a conﬁguration γ(cid:48)
M γi+1 and γ(cid:48)

(φi, ui), [[ui]]τ = b(cid:48)
i of the
machine Mc such that γi (cid:96)∗
i is in a
sending state, the sending tape containing bi+1, γi+1 is in a
receiving state, the receiving tape containing b(cid:48)
• for all i = 0, ..., m−1, the bit strings τ, {h1 (cid:55)→ b1, ..., hi+1 (cid:55)→
bi+1} satisfy all agent checks listed in Θi+1.
M means what the machine (in whatever model it is deﬁned)

Here (cid:96)∗
can compute via a sequence of computational steps.
5.2 Computational satisfaction of formulas

i (cid:96)∗

i+1

We recall the computational interpretation of the original predi-
cates, = and  here and the semantics of compound formulas. The
difference between our presentation here and that of [6] is that we
do not assume any computability condition on non-negligible sets
any more, as we apply a trick in the soundness proof that makes it
unnecessary. Interpretations of the new predicates are presented in
later sections.

Let (Ω0, Σ0, p0) be the probability space of inﬁnite fair coin
tosses, Ω0 the the set of inﬁnite bit strings, Σ0 the measurable sets
generated by ﬁxing ﬁnitely many outcomes, and p0 the probability
measure assigning the probabilities to the sets of Σ0. For a ﬁnite bit
string b ∈ {0, 1}∗ of length n, let ¯b ⊂ Ω0 denote the set of inﬁnite
bit strings for which the initial n bits are exactly b. Let Σf be the
set generated by ﬁnite unions intersections, and subtractions of sets
of the form ¯b (including Ω). Σ0 is the σ-closure of Σf .
Let Mc be an interactive PPT Turing machine with a special
challenge control state qch. We may regard this machine as an at-
tacker, who moves to the state qch when he thinks that he is ready to

break the security property. As usual, the machine takes the secu-
rity parameter 1η as an initial input. Mc interacts with the protocol
agents, which are also assumed to be interactive PPT Turing ma-
chines, and they respond to the calls of the adversary. Since once η
is ﬁxed, such an execution is probabilistic, and for each security pa-
rameter η, we denote underlying probability space by (Ωη, Ση, pη),
which is just a copy of the (Ω0, Σ0, p0) above. We denote the el-
ements of Ωη by ωη. (Actually, the adversary’s random string and
the agent random strings are separate, but as there are ﬁnitely many
of them, they can be thought to be on a single string) Each ωη is
one particular random string. Let Ω = (Ωη)η∈N. Let τ (ωη) be the
assignment of all ﬁxed bit string evaluations τ (n) of names given
for ωη. For a given n name, we just use simply n(ωη) for the bit
string τ (ωη)(n).
By a non-negligible set of coins S, we mean S = (Sη)η∈N,
where for all η ∈ N, Sη ∈ Ση
f , and pη(Sη) is non-negligible func-
tion of η. For S1 = (Sη
2 )η∈N non-negligible
sets of coins, we use the notation S1 ⊆ S2 if for all η ∈ N, Sη
1 ⊆
Sη
2 . In what follows, S is any such non-negligible set of coins. The
domain of interpretation D(S) = D is the same for all S: PPT
algorithms that take as input η, read from the random tape ωη, and
output a bit string. (As ωη is inﬁnite coin tosses, the algorithms of
course do not read it all, they terminate in polynomial time.)

1 )η∈N and S2 = (Sη

We recall the interpretations of = and  from [7]: Let σ be a
sequence of PPT machines (e.g. one for each free variable xi of θ):
Ax1 , ...,Axn ∈ D. For example, and Ax can be the evaluation of
any name (in which case Ax(η, ωη) = n(ωη), or any value for a
handle computed by the adversary, or some more complex object.
Let σ(ωη) denote the assignments x1 (cid:55)→ Ax1 (η, ωη), ..., xn (cid:55)→
Axn (η, ωη). If st(η, ωη) is a statement, then for any ﬁxed S =
(Sη)η∈N, instead of “for all η ∈ N and all ωη ∈ Sη, st(η, ωη)”,
we simply write “for all ω ∈ S, st(ω)”.

τ (ω) = [[t2]]σ(ω)
τ (ω).

• For the equality predicate, Mc, Π, S, σ |c= t1 = t2 iff there
is a subset S(cid:48) ⊆ S such that S \ S(cid:48) is negligible, and for all
ω ∈ S(cid:48), [[t1]]σ(ω)

τ (ω), [[t1]]σ(ω)

τ (ω), ..., [[tn]]σ(ω)

• For the derivability predicate, Mc, Π, S, σ |c= ˆφ, t1, ..., tn t
if for all non-negligible S(cid:48) ⊆ S, there is a non-negligible
S(cid:48)(cid:48) ⊆ S(cid:48) and a PPT Turing machine A such that for all ω ∈
S(cid:48)(cid:48), A([[φm(ω)]]σ(ω)
τ (ω), a(ω), r(ω)) =
τ (ω) where m(ω) is the step at which Mc reached the
[[t]]σ(ω)
challenge state, a(ω) stands for the protocol adversary’s out-
put and r(ω) is some fresh input from the random tape.
• If P is a constraint, (cid:126)t are closed terms then Mc, Π, S, σ |=
P ((cid:126)t) iff there is S(cid:48) ⊆ S such that, S\S(cid:48) is negligible, and for
all ω ∈ S(cid:48), the unique valid computation of Π with respect
to Mc, τ (ω) yields a state (((q, n), h, φ, Θ), b, b(cid:48), γ) in the
control state qch such that n, φ|s= P ((cid:126)t).

About the fresh r(ω), note we assumed for any non-negligible set
S that Sη ⊆ Ση
0, so there can always be fresh
random bits generated inside S.

f and not Sη ⊆ Ση

Satisfaction of compound formulas are deﬁned the following way.
• Mc, Π, S, σ |c= θ1 ∧ θ2
• Mc, Π, S, σ |c= θ1 ∨ θ2 iff for any S(cid:48) ⊆ S non-negligible,

iff Mc, Π, S, σ |c= θ1 and Mc, Π, S, σ |c= θ2.
there is a S(cid:48)(cid:48) ⊆ S(cid:48) non-negligible such that
either Mc, Π, S(cid:48)(cid:48), σ |c= θ1 or Mc, Π, S(cid:48)(cid:48), σ |c= θ2.
Mc, Π, S(cid:48), σ |c= θ1 implies Mc, Π, S(cid:48), σ |c= θ2

• Mc, Π, S, σ |c= θ1 → θ2 iff for all S(cid:48) ⊆ S non-negligible,
• Mc, Π, S, σ |c= ¬θ iff for all S(cid:48) ⊆ S non-negligible,

1236Mc, Π, S(cid:48), σ |(cid:54) c= θ
• Mc, Π, S, σ |c= ∃x.θ iff for any S(cid:48) ⊆ S non-negligible, there
is a S(cid:48)(cid:48) ⊆ S(cid:48) non-negligible and a PT machine Ax such that
Mc, Π, S(cid:48)(cid:48), σ,Ax |c= θ
• Mc, Π, S, σ |c= ∀x.θ iff for any probabilistic polynomial time
machine Ax, Mc, Π, S, σ,Ax |c= θ
• If x is a constrained variable, the interpretation of ∃x.θ is
analogous to the symbolic case: M, Π, S, σ |c= ∃x.θ if and
only if for every non-negligible S(cid:48) ⊆ S there is a non-
negligible S(cid:48)(cid:48) ⊆ S(cid:48) and a ground term t, such that the satis-
faction M, Π, S(cid:48)(cid:48), σ |c= θ{x (cid:55)→ t} holds.
• If x is a constrained variable, the interpretation of ∀x.θ is
analogous to the symbolic case: M, Π, S, σ |c= ∀x.θ if and
only if for every ground term t, the satisfaction M, Π, S, σ |c=
θ{x (cid:55)→ t} holds.

Mc, Π|c= θ iff Mc, Π, Ω|c= θ and Π|c= θ if Mc, Π|c= θ for every
Mc and qch.

Given a protocol Π, we say that there is a successful computa-
tional attack against the security property θ (a ﬁrst-order formula)
of the protocol if there is a an attacker Mc and a non-negligible set
of coins S such that Mc, Π, S |c= ¬θ (which is the same as Π|(cid:54) c= θ).
Despite that semantics of the compound formulas is not as usual
in ﬁrst-order logic, we prove in Section 6 that as a consequence of
Fitting’s embedding [23] of classical logic into S4, the following
theorems hold.

THEOREM 5.1

(FITTING’S EMBEDDING). With the above se-

mantics, ﬁrst-order deduction rules are sound.

THEOREM 5.2

(TRACE MAPPING). Let Π be a protocol, s1 →
... → sm be a symbolic transition sequence of Π and Mc be a
probabilistic polynomial time interactive Turing machine. If there
is a non-negligible set of coins S such that, for any ω ∈ S, there is a
sequence of transitions (s0, (cid:126)b0, (cid:126)b(cid:48)
m, γm)
that is computationally valid w.r.t. Mc, τ (ω) and γm is in the chal-
lenge state qch, then for any set of FOL formulas Φ, Mc, Π, S |c= Φ
implies there is a symbolic model M such that s0 → ··· → sm is
a valid symbolic execution w.r.t. M and M, sm |s= Φ.

0, γ0) → ··· → (sm, (cid:126)bm, (cid:126)b(cid:48)

THEOREM 5.3

(GENERAL SOUNDNESS). If there is a suc-
cessful computational attack such that the number of sessions of
honest agents are bounded in the security parameter, then there is
also a successful symbolic attack.
5.3 Axioms for Equality and Derivability

We recall the core axioms presented in [5]. As usual, unquan-
tiﬁed variables are universally quantiﬁed. Unless noted otherwise,
they are always sound.

Equality is a Congruence:
• x = x, and the substitutability (congruence) property of

equal terms holds for = and .

Core Axioms for the Derivability Predicate:
• Self derivability: ˆφ, (cid:126)x, x  x
• Increasing capabilities: ˆφ, (cid:126)x  y −→ ˆφ, (cid:126)x, x  y
• Commutativity: If (cid:126)x(cid:48) is a permutation of (cid:126)x, then
ˆφ, (cid:126)x  y −→ ˆφ, (cid:126)x(cid:48)  y
• Transitivity of derivability:
ˆφ, (cid:126)x  (cid:126)y ∧ ˆφ, (cid:126)x, (cid:126)y  (cid:126)z −→ ˆφ, (cid:126)x  (cid:126)z
• Functions are derivable: ˆφ, (cid:126)x  f ((cid:126)x)

This axiom is sound as long as functions are interpreted as
PT computable algorithms.

Axioms for Freshly Generated Items:
• No telepathy: fresh(x; ˆφ) −→ ˆφ (cid:54) x

• Fresh items do not help to compute:

This axiom is sound as long as RanGen() items are generated
so that they can only be guessed with negligible probability.
A more general version is also possible as
fresh(x; ˆφ, (cid:126)x) ∧ (cid:126)x (cid:52) ˆφ −→ ˆφ, (cid:126)x (cid:54) x
fresh(x; ˆφ, (cid:126)x, y) ∧ (cid:126)x, y (cid:52) ˆφ ∧ ˆφ, (cid:126)x, x  y −→ ˆφ, (cid:126)x  y
Equations for the ﬁxed function symbols: For example, for
symmetric encryption sdec({|x|}R
K , K) = x, and for pairing,
π1 ((cid:104)x, y(cid:105)) = x; π2 ((cid:104)x, y(cid:105)) = y. Function of error is error
f (...,⊥, ...) = ⊥, etc.

6. THE FITTING CONNECTION

The trace mapping and the general soundness theorems for ar-
bitrary ﬁrst-order formulas were proven directly from their deﬁni-
tions by an elaborate argument in [6]. We have realized however,
that they are rather easy consequences of Fitting’s embedding of
ﬁrst-order logic into ﬁrst-order S4 [23]. The non-Tarskian compu-
tational semantics of ﬁrst-order formulas that naturally arouse in
the BC technique turns out to be a special kind of Kripke seman-
tics of ﬁrst-order S4 composed with Fitting’s embedding of FOL
into ﬁrst-order S4. We detail this connection here, and show how
trace mapping and general soundness follow from Fitting’s theo-
rem. This section assumes basic familiarity with S4 modal logic
and its ﬁrst-order extension as well as Kripke semantics.
For any ﬁrst-order formula θ, consider the Fitting transformation
θ (cid:55)→ θ∗, where θ∗ is a formula of ﬁrst-order S4, and is deﬁned
recursively as follows:

• For any atomic formula θ, let θ∗ ≡ 23θ.
• (¬θ)∗ ≡ 2¬θ∗
1 → θ∗
• (θ1 → θ2)∗ ≡ 2(θ∗
2 )
• (θ1 ∧ θ2)∗ ≡ (θ∗
1 ∧ θ∗
2 )
• (θ1 ∨ θ2)∗ ≡ 23(θ∗
1 ∨ θ∗
2 )
• (∀xθ)∗ ≡ ∀xθ∗
• (∃xθ)∗ ≡ 23∃xθ∗

Fitting in [23] put 23 everywhere and noted that it is redundant in
front of the conjunction. It is also easy to check that if the Barcan
formula and its converse (∀x2θ ↔ 2∀xθ) are assumed (that is,
when the domain does not change from possible world to possible
world in the Kripke structure), then 23 is also redundant in front of
the universal quantiﬁcation (as θ∗ ↔ 23θ∗ holds in our deﬁnitions
for all θ). In our computational situation the domain is unchanged
as we show below. So in this paper we assume the Barcan formula
and its converse.
Fitting’s theorem says that any formula θ is derivable in ﬁrst-
order logic if and only if θ∗ it is derivable in S4 with the Barcan
formulas. (Without the Barcan formulas, (∀xθ)∗ ≡ 23∀xθ∗ has
to be written above).
Observe that if we think of non-negligible sets as possible worlds,
and the subset relation as accessibility (that is, if S(cid:48) is accessible
from S iff S(cid:48) ⊆ S), then we can deﬁne a computational Kripke
semantics: For our predicates, consider the S4 satisfaction relation
Mc, Π, S, σ |s4= that we deﬁne almost the same way as the BC com-
putational satisfaction |c= of Section 5.2 is deﬁned, except that we
drop the "for all non-negligible S(cid:48) ⊆ S, there is a non-negligible
S(cid:48)(cid:48) ⊆ S(cid:48)" phrase, and replace S(cid:48)(cid:48) with S in the remaining of the
deﬁnition. For example, the satisfaction of derivability becomes:
• For the derivability predicate, Mc, Π, S, σ |s4= ˆφ, t1, ..., tn t
if there is a PPT Turing machine A such that for all ω ∈ S,

1237τ (ω), [[t1]]σ(ω)

τ (ω), ..., [[tn]]σ(ω)

A([[φm(ω)]]σ(ω)
τ (ω), a(ω), r(ω))=[[t]]σ(ω)
where m(ω) is the step at which Mc reached the challenge
state, a(ω) stands for the protocol adversary’s output and
r(ω) is some fresh input from the random string.

τ (ω)

For an arbitrary θ ﬁrst-order S4 formula, Mc, Π, S, σ |s4= 2θ is de-
ﬁned to hold if and only if Mc, Π, S(cid:48), σ |s4= θ holds for all non-
negligible S(cid:48) ⊆ S, and Mc, Π, S, σ |s4= 3θ is deﬁned to hold if and
only if Mc, Π, S(cid:48), σ |s4= θ holds for some non-negligible S(cid:48) ⊆ S.
Taking θ to be ˆφ, t1, ..., tn  t, and applying 23 to the above deﬁ-
nition of S4 satisfaction, we receive the computational satisfaction
of Bana and Comon-Lundh. That is, Mc, Π, S, σ |c= ˆφ, t1, ..., tn t
if and only if Mc, Π, S, σ |s4= 23 ˆφ, t1, ..., tn  t.
Note also that for the equality predicate and for the constraints,
"for all non-negligible S(cid:48) ⊆ S, there is a non-negligible S(cid:48)(cid:48) ⊆ S(cid:48)"
can be freely inserted in the deﬁnition, as the resulting deﬁnition is
equivalent with the original: for example, if for all non-negligible
S(cid:48) ⊆ S, there is a non-negligible S(cid:48)(cid:48) ⊆ S(cid:48) such that [[t1]]σ(ω)
τ (ω) =
τ (ω) holds on S(cid:48)(cid:48), then it also holds up to negligible probabil-
[[t2]]σ(ω)
ity on S, because if there were a non-negligible subset S(cid:48) ⊆ S on
τ (ω) were true, then this S(cid:48) would not have
which [[t1]]σ(ω)
some non-negligible subset S(cid:48)(cid:48) on which they are equal, a contra-
diction. So BC could have deﬁned satisfaction of equality as

τ (ω) (cid:54)= [[t2]]σ(ω)

• For the equality predicate, Mc, Π, S, σ |c= t1 = t2 iff for
all non-negligible S(cid:48) ⊆ S, there is a non-negligible subset
S(cid:48)(cid:48) ⊆ S(cid:48) such that for all ω ∈ S(cid:48)(cid:48), [[t1]]σ(ω)

τ (ω) = [[t2]]σ(ω)
τ (ω).

That is, Mc, Π, S, σ |c= t1 = t2 iff Mc, Π, S, σ |s4= 23t1 = t2.
The same is true for constraints. Hence we have this for all atomic
formulas. |s4= for compound formulas is deﬁned as usual in Kripke
semantics. For example, Mc, Π, S, σ |s4= θ1 ∨ θ2 if and only if
Mc, Π, S, σ |s4= θ1 or Mc, Π, S, σ |s4= θ2.

Comparing the deﬁnition of |c= in Section 5.2 for compound
formulas with Fitting’s embedding, for any ﬁrst-order formula θ,

Mc, Π, S, σ |c= θ ⇐⇒ Mc, Π, S, σ |s4= θ

∗

.

For a set of ﬁrst-order formulas Φ, let Φ∗ mean the set that we get
by applying the Fitting transformation to all formulas in Φ. Since
with |s4= , our computational semantics is a special kind of Kripke
semantics, Fitting’s theorem implies that if Mc, Π, S, σ |s4= Φ∗ holds
and if Φ (cid:96)FOL θ, then Mc, Π, S, σ |s4= θ∗. So we also have that if
Mc, Π, S, σ |c= Φ holds and if Φ (cid:96)FOL θ, then Mc, Π, S, σ |c= θ.
This is exactly Theorem 5.1.

The Barcan formula and its converse hold, as the domain D does

not depend on the non-negligible sets.
For Theorem 5.2, note that it is assumed in the theorem that for
all ω ∈ S the computational execution has the same length m and
the symbolic part of their traces, si agree. Remember that the sym-
bolic states have the transition conditions Θi in them. So at the
challenge state, we have Mc, Π, S |c= Θm ∧ Φ. Note that since on
the traces, si agree, the terms that are in the frame also agree for
all trace ω ∈ S. Therefore, ˆφ in the formulas of θm and Φ can be
replaced by the list of terms in the frames. Let θ(cid:48)
m and Φ(cid:48) denote
the formulas we receive this way. Then, Mc, Π, S |c= Θ(cid:48)
m ∧ Φ(cid:48).
This is the same as Mc, Π, S |s4= (Θ(cid:48)
m ∧ Φ(cid:48))∗, that, by Fitting’s the-
m ∧
orem means that Θ(cid:48)
Φ(cid:48))∗ is S4 satisﬁable). Hence there is a symbolic model M with

m ∧ Φ(cid:48) is ﬁrst-order satisﬁable (because (Θ(cid:48)

m∧Φ(cid:48). As Θ(cid:48)

M|s= Θ(cid:48)
m and Φ(cid:48) have no frames in them, it is easy to
see from the symbolic satisfaction that M, sm |s= Θ(cid:48)
m ∧ Φ(cid:48) is also
satisﬁed as satisfaction does not depend on the state. Finally, as in
sm, the frames contain exactly the terms with which we replaced
ˆφ, we can now write them back and receive M, sm |s= Θm ∧ Φ.
Which also means that Θm and Φ are ﬁrst-order consistent.

Finally, for proving Theorem 5.3, consider the following. If there
is a computational attack, that is, if the negation of the security for-
mula θs is computationally satisﬁed by some Mc, Π, S, then, as
long as only bounded number (in the security parameter) of ses-
sions are allowed, the maximum number of different (with respect
to ω) symbolic transitions s1 → ··· → sm does not depend on
the security parameter. Therefore, S can be split (up to negligible
probability) into a ﬁxed number of non-negligible subsets on each
of which s1 → ··· → sm is independent of ω. Pick one, call it S(cid:48).
Then Mc, Π, S(cid:48) computationally satisﬁes ¬θs as well as all com-
putationally sound axioms (denote the set by ΦA), and Θm also:
Mc, Π, S(cid:48) |c= Θm ∧ ΦA ∧ θs. Hence, By Theorem 5.2 there is
a symbolic model M such that M, sm |s= Θm ∧ ΦA ∧ θs, which
exactly means that there is a symbolic attack.

Note, although by Fitting’s theorem, the ﬁrst-order deduction
rules are computationally sound, it is not possible in the current
formulation to deduce security properties from the axioms only by
ﬁrst-order deduction rules and nothing else. The BC technique has
no formulas expressing the transition system, no formulas saying
the agents follow the protocol roles. Explicit time and some axiom
for induction would also be needed as in [8]. These are taken care
by the symbolic execution.

7. DERIVABILITY WITH ORACLES

Syntax of various types of derivability with oracles was intro-
duced in Section 3. Here we deﬁne their computational semantics
and list a number of axioms that are computational sound.
7.1 Computational Semantics of Derivability

with Oracles

Let Osic2 be the following oracle: It ﬁrst takes a list of honestly
generated keys K and some additional list C of ciphertexts. The or-
acle can be called for encryption by submitting a string to encrypt
along with the encrypting key’s place number in K. The oracle hon-
estly generates the desired encryption, returns the result and adds it
to the list C. The oracle can also be called for a decryption again
with specifying the key and providing a ciphertext. If the ciphertext
is not one of those in C, the oracle outputs the decryption. Let Oskc2
take K and C as above, but also τ (L) assignment of bit strings to
a ﬁnite set of name symbols L. The oracle accepts descriptions of
functions of the names L, the ciphers C and the keys K, into which
he substitutes the corresponding bit strings, computes the function
and then encrypts the result with the speciﬁed key and adds it to
C. Decryption works as for Osic2. Let Oaic2 and Oakc2 be the analo-
gous notions for public key encryption. PPT algorithms with oracle
access will be written as AOO, BOO.

τ (ω), it outputs the bit string [[x]]σ(ω)

The meaning of the deﬁnition is that Mc, Π, S, σ |s4= ˆφ, (cid:126)x Ox
holds if there is a PPT algorithm AOO that, for ω ∈ S, receiving
the bit strings [[ ˆφ, (cid:126)x]]σ(ω)
τ (ω). In the
computation AOO can request encryption and decryption oracles
corresponding to the honest keys, but it will only receive a decryp-
tion if the submitted bit string is not a bit string corresponding to
an encryption in ˆφ, (cid:126)x or a bit string received from the encryption
oracle. Outside S, nothing is required.

1238DEFINITION 7.1. Semantics of Derivability with Oracles: Let
Mc, Π, S, σ be as before. Let a(ωη) denote the protocol adversary
output as it reaches the challenge state on the random input ωη,
and let m(ωη) denote the number of moves till then. We write
Mc, Π, S, σ |s4= ˆφ, (cid:126)x Ox iff there is a PPT Turing machine AOO
such that for all ω ∈ S,

AOO(cid:0)[[φm(ω)]]σ(ω)

τ (ω), a(ω), r(ω)(cid:1) = [[x]]σ(ω)

τ (ω)

τ (ω), [[(cid:126)x]]σ(ω)

where r(ω) is some fresh (not used for the computation of ˆφ, (cid:126)x, x)
random input from the random string. On each ω, if the tuple
(((q, n), h, φ, Θ), b, b(cid:48), γ) denotes the state yielded by the unique
valid computation of Π with respect to Mc and τ (ω), then the or-
acles receive in K all keys (bit strings) corresponding to the keys
in n, and in C all strings of the form [[{z}R
τ (ω) with R and K
names in n, and n, φ|s= {z}R
eK (cid:118) ˆφ, (cid:126)x. In τ (L), the KDM oracles
receive all assignments of names in ¯n to bit strings, except (in the
symmetric case), for those that occur as random inputs R to the
encryptions in C. We shorten this as

eK ]]σ(ω)

Mc, Π, S, σ ||= AOO

( ˆφ, (cid:126)x) = x,

implicitly assuming the algorithm has access to the protocol adver-
sary’s knowledge and to random bits. Let
Mc, Π, S, σ |c= ˆφ, (cid:126)x Ox iff Mc, Π, S, σ |s4= 23( ˆφ, (cid:126)x Ox).
In the KDM case, the submitted functions may depend on randomly
generated items that differ from the secret keys but are not accessi-
ble to the protocol adversary. For example, it is allowed to depend
on a secret nonce. This is necessary for receiving nice axioms for
the KDM case, and we explain the reason at the axioms. Still, as-
suming the usual KDM security is enough to prove that an unsent
key is uncompromised with such oracle access. The reason is that
when a KDM attack is constructed from the protocol attack, the
KDM attacker has access to the items generated by honest agents
except for the secret keys and the random inputs to the encryptions.
7.2 Axioms for Derivability with Oracles

The following axioms (except for the second and last entry of
the core axioms for derivability predicates) are very similar to the
ones in Section 5.3, and are just as trivial. The second entry of the
core axioms for derivability predicates with oracles is also trivially
computationally sound.

Core Axioms for the Derivability Predicate with Oracles.
• Let SameEnc((cid:126)x; (cid:126)y) be the constraint that there is a one-to-
one correspondence between the honest encryption terms of
(cid:126)x and (cid:126)y such that the corresponding encryption terms are
equal (with respect to the equality predicate). Then
SameEnc((cid:126)x; (cid:126)y) ∧ (cid:126)x, x = (cid:126)y, y −→ ( ˆφ, (cid:126)x Ox ↔ ˆφ, (cid:126)y Oy).
• More oracles help more: If the oracles of O are more power-
ful than the oracles of O(cid:48), then ˆφ, (cid:126)x O(cid:48)
In particular, ˆφ, (cid:126)x  x −→ ˆφ, (cid:126)x Ox and
ˆφ, (cid:126)x aic2 x → ˆφ, (cid:126)x akc2 x and ˆφ, (cid:126)x sic2 x → ˆφ, (cid:126)x skc2 x

x −→ ˆφ, (cid:126)x Ox.

• Increasing capabilities: ˆφ, (cid:126)x Oy −→ ˆφ, (cid:126)x, x Oy
• Commutativity: If (cid:126)x(cid:48) is a permutation of (cid:126)x, then
ˆφ, (cid:126)x Oy −→ ˆφ, (cid:126)x(cid:48) Oy
• Transitivity: ˆφ, (cid:126)x O(cid:126)y ∧ ˆφ, (cid:126)x, (cid:126)y O(cid:126)z −→ ˆφ, (cid:126)x O(cid:126)z
• Decryption Oracles help:

RanGen(K) ∧ ˆφ, (cid:126)x Oy
∧ ∀xR(y = {x}R
−→ ˆφ, (cid:126)x Odec(y, dK).

eK → {x}R

eK (cid:54)(cid:118) ˆφ, (cid:126)x)

This expresses that if y is computable and is not an encryp-
tion in ˆφ, (cid:126)x, then dec(y, dK) is also computable from the
same items as the decryption oracle can be called. We do not
have to require that y is none of the encryptions done by the
oracles, because if they were, then the decryption is known
to the submitter. Again, this follows purely from the deﬁni-
tion of O, CCA2 security of the encryption is not required.
This axiom together with the transitivity axiom easily imply

RanGen(K) ∧ ˆφ, (cid:126)x Oy ∧ ˆφ, (cid:126)x, dec(y, dK) Oz
∧ ∀xR(y = {x}R

eK (cid:54)(cid:118) ˆφ, (cid:126)x) −→ ˆφ, (cid:126)x Oz.

eK → {x}R

This replaces the non-malleability axiom of [5] for the deriv-
ability predicate. With tiny modiﬁcations, it is possible to
rewrite the NSL proof presented in [5] for using the Opred-
icate and this simpler axiom instead of the  predicate with
the non-malleability axiom there.

Axioms for Freshly Generated Items. These axioms are sound
• No telepathy: fresh(x; ˆφ, (cid:126)x) ∧ (cid:126)x (cid:52) ˆφ −→ ˆφ, (cid:126)x (cid:54)Ox

for the same reason as the corresponding ones for  were:

(implies no-telepathy axiom without oracles). This is sound
as long as RanGen() means generation with negligible guess-
ing probability only.
fresh(x; ˆφ, (cid:126)x, y) ∧
• Fresh items do not help to compute:
(cid:126)x, y (cid:52) ˆφ ∧ ˆφ, (cid:126)x, x Oy −→ ˆφ, (cid:126)x Oy

ˆφ, (cid:126)x, x Ox is implied by the more oracles help more axiom and the
self-derivability axiom of derivability predicate. Also, ˆφ, (cid:126)xOf ((cid:126)x).

8. KEY USABILITY

Semantics of IND-CCA2 Key Compromise

Syntax of various types of key usability was introduced in Sec-
tion 3. Here we deﬁne their computational semantics and list a
number of axioms that are computational sound.
8.1 IND-CCA2 and KDM-CCA2 cases
8.1.1
The idea of key usability is that a key has been uncompromised,
that is, it can be used for safe encryption. To match the computabil-
ity predicate, we deﬁne the negation of it, key compromise. The
intuitive meaning of ˆφ, (cid:126)x (cid:73)O K is that ˆφ, (cid:126)x compromises the key
(with oracles) and it cannot be used for safe encryption any more.
The ﬁrst thought here would be to deﬁne the compromise so that
from ˆφ, (cid:126)x, an x can be computed such that the encryption of x and
of 0|x| are computationally distinguishable. However, the major
difﬁculty here (and the major difference from [22]) is that we have
to deﬁne our notion for any S. Computational distinguishability on
an arbitrary set has no meaning: even in the usual CCA2 game with
CCA2 secure encryption, there can be non-negligible sets of coins
deﬁned on which the CCA2 attacker returns 1 if the real bit string
is encrypted, while 1 with probability 1/2 if the 0’s are encrypted;
it is very easy to ﬁnd sets like this.
What we came up with is a notion of observational inequiva-
lence: encryptions of x and 0|x| have to be observationally inequiv-
alent on S, where PPT algorithms with oracle access provide the
contexts and equality on S provides the equivalence.

DEFINITION 8.1

(KEY COMPROMISE). The deﬁne the rela-
tion Mc, Π, S, σ |s4= ˆφ, (cid:126)x (cid:73)OK to hold if either Mc, Π, S, σ |s4= (cid:126)x (cid:54)(cid:52)
ˆφ ∨ ¬RanGen(K), or there are R, PPT algorithms AOO
21 , AOO
22 ,
and AOO

(in the IND case) or x (in the KDM case) such that:

1

In the the IND case

12391

( ˆφ, (cid:126)x) and

terpretations of ˆφ, (cid:126)x, AOO

• R is generated honestly, statistically independently of the in-
• Either Mc, Π, S, σ ||=
21 ( ˆφ, (cid:126)x,{AOO
( ˆφ, (cid:126)x)}R
( ˆφ, (cid:126)x)}R
AOO
eK )
and for some (hence for all) R(cid:48) fresh random input generated
inside S, Mc, Π, S, σ ||=

22 ( ˆφ, (cid:126)x,{AOO

eK ) = AOO

1

1

1

|AOO

|AOO

( ˆφ,(cid:126)x)|}R(cid:48)

22 ( ˆφ, (cid:126)x,{0

eK ) (cid:54)= AOO

21 ( ˆφ, (cid:126)x,{0
AOO
• Or Mc, Π, S, σ ||=
21 ( ˆφ, (cid:126)x,{AOO
AOO
( ˆφ, (cid:126)x)}R
eK )
and for some (hence for all) R(cid:48) fresh random input generated
inside S, Mc, Π, S, σ ||=

22 ( ˆφ, (cid:126)x,{AOO

eK ) (cid:54)= AOO

( ˆφ, (cid:126)x)}R

( ˆφ,(cid:126)x)|}R(cid:48)
eK )

1

1

1

1

1

|AOO

|AOO

( ˆφ,(cid:126)x)|}R(cid:48)

( ˆφ,(cid:126)x)|}R(cid:48)
eK )

22 ( ˆφ, (cid:126)x,{0

eK ) = AOO

AOO
21 ( ˆφ, (cid:126)x,{0
In the KDM case
• R is generated honestly, statistically independently of the in-
• Either Mc, Π, S, σ ||=
AOO
21 ( ˆφ, (cid:126)x,{x}R

terpretations of ˆφ, (cid:126)x, x, and Mc, Π, S, σ |c= x (cid:52) ˆφ, (cid:126)x and

22 ( ˆφ, (cid:126)x,{x}R

eK ) = AOO

eK )

and for some (hence for all) R(cid:48) fresh random input generated
inside S, Mc, Π, S, σ ||=

AOO
21 ( ˆφ, (cid:126)x,{0
• Or Mc, Π, S, σ ||=

|x|}R(cid:48)

eK ) (cid:54)= AOO

22 ( ˆφ, (cid:126)x,{0

|x|}R(cid:48)
eK )

AOO
21 ( ˆφ, (cid:126)x,{x}R

eK ) (cid:54)= AOO

22 ( ˆφ, (cid:126)x,{x}R

eK )

and for some (hence for all) R(cid:48) fresh random input generated
inside S, Mc, Π, S, σ ||=
|x|}R(cid:48)

AOO
21 ( ˆφ, (cid:126)x,{0

eK ) = AOO

22 ( ˆφ, (cid:126)x,{0

|x|}R(cid:48)
eK )

Let Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)Ox iff Mc, Π, S, σ |s4= 23( ˆφ, (cid:126)x (cid:73)Ox).

Recall from Section 6 that 23 means "there is a non-negligible
S(cid:48) ⊆ S such that for all S(cid:48)(cid:48)..." Also note that as we required our
non-negligible sets to be in Σf , it is always possible to toss fresh
coins inside the non-negligible sets.
Note that while R does not have to be generated inside S, R(cid:48)
does. In particular, S may actually depend on R, which is essential
for the usability of the axioms, because the non-negligible sets on
which we need to apply the axioms may depend on values of an
encryption, and hence values of R. On the other hand, S is not al-
lowed to depend on R(cid:48), which is essential for proving that a freshly
generated key is not compromised.

Note, in the KDM case, x does not have to be computed from
ˆφ, (cid:126)x, it could be a secret nonce. This corresponds to the fact that in
the semantics of Oin the KDM case (as we noted after the deﬁni-
tion) we allowed the functions submitted to the oracles to depend
on such items not known to the protocol adversary.
8.1.2 Axioms for CCA2 Key Compromise
We now present the axioms for key compromise. First the core

axioms for which soundness does not need CCA2 security.

Core Axioms for the Key Compromise Predicate.
• Let SameEnc((cid:126)x; (cid:126)y) be the constraint as before. Then

SameEnc((cid:126)x; (cid:126)y) ∧ (cid:126)x, x = (cid:126)y, y −→ ( ˆφ, (cid:126)x (cid:73)Ox ↔ ˆφ, (cid:126)y (cid:73)Oy).

• Derivability implies compromise: ˆφ,(cid:126)x OK−→ ˆφ,(cid:126)x (cid:73)OK

If K is computable for the adversary, then it is compromised.
Note, this axiom and the self derivability axiom (from 7.2)
imply that ˆφ, (cid:126)x, K (cid:73)OK
ˆφ, (cid:126)x (cid:73)OK −→ ˆφ, (cid:126)x, x (cid:73)OK
ˆφ, (cid:126)x (cid:73)OK −→ ˆφ, (cid:126)x(cid:48) (cid:73)OK

• Increasing capabilities for key compromise:
• Commutativity: If (cid:126)x(cid:48) is a permutation of (cid:126)x, then
• Transitivity: ˆφ, (cid:126)x O(cid:126)y ∧ ˆφ, (cid:126)x, (cid:126)y (cid:73)OK −→ ˆφ, (cid:126)x (cid:73)OK

The intuitive reason is very clear: (cid:126)y just contains extra infor-
mation, that can be computed from ˆφ, (cid:126)x, so it is not actually
needed in the compromise. This, and the functions are deriv-
able axiom imply ˆφ, (cid:126)x, f ((cid:126)x) (cid:73)O K −→ ˆφ, (cid:126)x (cid:73)O K. With
the increasing capabilities axiom, we get ˆφ, f ((cid:126)x) (cid:73)OK −→
ˆφ, (cid:126)x (cid:73)OK. We refer to these as function application.

• Uncompromised keys securely encrypt:

– If O is either aic2 or sic2, then

RanGen(K) ∧ fresh(R; ˆφ, (cid:126)x, x, y, K)
eK Oy

∧ (cid:126)x, x, y (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
−→ ˆφ, (cid:126)x, x (cid:73)OK ∨ ˆφ, (cid:126)x Oy

This formula means that if the key is uncompromised,
that is, ˆφ, (cid:126)x, x(cid:54)(cid:73)OK, then {x}R
eK cannot help in de-
riving y. In other words, if it is possible to derive y
with {x}R
eK, then it is also possible to derive it without
{x}R
eK. The freshness and random generation condi-
tions ensure that {x}R
eK is indeed a good encryption
eK or {N}eK
(e.g. {N}N
eK are not good), and also that
y cannot depend on {x}R
eK is not
good). Moreover, (cid:126)x, x, y (cid:52) ˆφ ensures that handles in
these terms are given values the adversary can compute
(otherwise e.g.
taken x = h, the handle h cannot be
dK if dK was never sent, and it cannot be R either).
This formula is completely analogous to the secrecy ax-
iom in [5] but dK (cid:118) ˆφ, (cid:126)x, x there is replaced now with
ˆφ, (cid:126)x, x (cid:73)aic2 K as we can now allow dK to appear
inside a secure encryption for example.

eK (e.g. y = {x}R

– If O is either akc2 or skc2, then

RanGen(K) ∧ fresh(R; ˆφ, (cid:126)x, x, y, K)
eK Oy

∧ (cid:126)x, x, y (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
−→ ˆφ, (cid:126)x (cid:73)OK ∨ ˆφ, (cid:126)x Oy

The difference here from the axiom for IND-CCA2 se-
curity is that in ˆφ, (cid:126)x (cid:73)O K now there is no x. This
corresponds to the fact that the encrypted message x is
allowed to contain the decryption key, or it may leak it
somehow together with ˆφ, (cid:126)x. For more, see Section 11.
It may be surprising however, that these core axioms do not
require any security of the encryption. It is purely a conse-
quence of the deﬁnition of key compromise and derivability
predicates. (The axiom that requires CCA2 security is the
fresh keys are uncompromised axiom later.)
Here we want to allow x to be any secret thing, such as a
nonce, so only x (cid:52) ˆφ was assumed. That is why in the KDM
deﬁnition of key compromise we needed to allow functions
depending on such secret items to be submitted to the en-
cryption oracles in the semantics of Oand (cid:73)O.
• Encryptions with uncompromised keys do not compromise:

1240– IND-CCA2 case. If O is either aic2 or sic2, then
) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K
RanGen(K) ∧ RanGen(K

(cid:48)

(cid:48)

)

eK(cid:48) (cid:73)OK

(cid:48) ∨ ˆφ, (cid:126)x (cid:73)OK

∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
−→ ˆφ, (cid:126)x, x (cid:73)OK
That is, if ˆφ, (cid:126)x,{x}R
eK(cid:48) compromised K, then either K
is already compromised without {x}R
eK(cid:48), or K(cid:48) was al-
ready compromised by ˆφ, (cid:126)x, x. Note that this includes
x, the encrypted term. This means that x itself (with
ˆφ, (cid:126)x) should not compromise K(cid:48) if we want {x}R
eK(cid:48) to
be safe. This is the generalization of that key cycles
may compromise CCA2 encryption. In Section 11 we
will see how this axiom deals with key cycles.
– KDM-CCA2 case. If O is akc2 or skc2, then
RanGen(K) ∧ RanGen(K

) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K

)

(cid:48)

(cid:48)

∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
−→ ˆφ, (cid:126)x (cid:73)OK

(cid:48) ∨ ˆφ, (cid:126)x (cid:73)OK

eK(cid:48) (cid:73)OK

This is basically the same as the previous one, except
again that ˆφ, (cid:126)x (cid:73) K(cid:48) does not contain x.

Again, soundness of these axioms follow directly from the
deﬁnition of key usability, and it does not depend on what
encryption is used.
In the above formulas, K and K(cid:48) could be allowed to encrypt
different kinds of encryptions, not necessarily the same, we
just did not want to overload our formulas.

• Axioms for Freshly Generated Items.

– Fresh keys are not compromised: The intuition of this
axiom is that if K is fresh, then it can be used for secure
encryption: keyfresh(K; ˆφ, (cid:126)x)∧ (cid:126)x (cid:52) ˆφ −→ ˆφ, (cid:126)x(cid:54)(cid:73)OK
This axiom is sound if the encryption for which K is
generated is CCA2 secure. Depending on which O is
in the axiom, the encryption needs to have the corre-
sponding level of security. This is the only axiom where
the security of the encryption is necessary. The reader
may wonder that proving the KDM case, what happens
to the variables not known to the protocol adversary in
the submitted functions as the standard KDM encryp-
tion oracle only ﬁlls in the gaps of keys, not other un-
known items. However, in a KDM attack created by
the failure of the axiom, the attacker simulates the pro-
tocol, and all honestly generated items except for the
keys and random inputs to the encryptions in question
are available to him.

– Fresh items do not compromise: they were generated
independently and as they have not been sent out, they
have not had a chance to compromise other items:
fresh(x; ˆφ, (cid:126)x, y)∧ (cid:126)x, y (cid:52) ˆφ∧ ˆφ, (cid:126)x, x (cid:73)Oy → ˆφ, (cid:126)x (cid:73)Oy

And on S, the output of AOsic2
( ˆφ, (cid:126)x) is not equal any of the outputs
of the encryption oracles, and it is not any of the bit strings corre-
sponding to the honest encryptions in ˆφ, (cid:126)x. Let
Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)ic x iff Mc, Π, S, σ |s4= 23( ˆφ, (cid:126)x (cid:73)ic x).
The reason for using oracle Osic2 is that the deﬁnition of INT-CTXT
security [13] allows the use of encryption and decryption oracles.
8.2.2 Axioms for Unforgeability Key Compromise

• Let SameEnc((cid:126)x; (cid:126)y) be the constraint as before. Then

SameEnc((cid:126)x; (cid:126)y) ∧ (cid:126)x,x = (cid:126)y,y−→ ( ˆφ, (cid:126)x (cid:73)ic x ↔ ˆφ, (cid:126)y (cid:73)ic y).
• Derivability implies compromise: ˆφ, (cid:126)x  K −→ ˆφ, (cid:126)x (cid:73)ic K
• Increasing capabilities for key compromise:
• Commutativity: If (cid:126)x(cid:48) is a permutation of (cid:126)x, then
• Transitivity: ˆφ, (cid:126)x  (cid:126)y ∧ ˆφ, (cid:126)x, (cid:126)y (cid:73)ic K −→ ˆφ, (cid:126)x (cid:73)ic K
• Encryption with uncompromised key cannot be faked:

ˆφ, (cid:126)x (cid:73)ic K −→ ˆφ, (cid:126)x, x (cid:73)ic K
ˆφ, (cid:126)x (cid:73)ic K −→ ˆφ, (cid:126)x(cid:48) (cid:73)ic K.

eK → {x}R

RanGen(K) ∧ ˆφ, (cid:126)x  y ∧ dec(y, dK) (cid:54)= ⊥
eK (cid:54)(cid:118) ˆφ, (cid:126)x) −→ ˆφ, (cid:126)x (cid:73)ic K
∧ ∀xR(y = {x}R
This means the adversary cannot compute a y which decrypts
to something meaningful. This is exactly what we need from
the INT-CTXT property, namely, that the encryption cannot
be faked. Again, soundness of this axiom does not need INT-
CTXT encryption, it is immediate from our semantics.

• Encryptions with uncompromised keys do not compromise:

– For the IND case, we have
RanGen(K) ∧ RanGen(K

(cid:48)

) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K

∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{|x|}R
−→ ˆφ, (cid:126)x, x (cid:73)sic2 K
– For the KDM case, we have
RanGen(K) ∧ RanGen(K

(cid:48)

K(cid:48) (cid:73)ic K
(cid:48) ∨ ˆφ, (cid:126)x (cid:73)ic K

) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K

(cid:48)

)

(cid:48)

)

∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{|x|}R
−→ ˆφ, (cid:126)x (cid:73)skc2 K

K(cid:48) (cid:73)ic K
(cid:48) ∨ ˆφ, (cid:126)x (cid:73)ic K

Soundness of these follow from the compromise deﬁnitions.
• Fresh keys are not INT-CTXT compromised if encryption is

INT-CTXT secure:

– keyfresh(K; ˆφ) −→ ˆφ(cid:54)(cid:73)ic K. The intuition of this
axiom is that if the encryption is INT-CTXT secure and
if K is fresh, then the adversary cannot fake encryp-
tions with this key.

• Fresh items do not compromise: fresh(x; ˆφ, (cid:126)x, K) ∧ (cid:126)x (cid:52)

ˆφ ∧ ˆφ, (cid:126)x, x (cid:73)ic K −→ ˆφ, (cid:126)x (cid:73)ic K

8.2 Unforgeability
8.2.1 Semantics of Unforgeability

DEFINITION 8.2. We deﬁne INT-CTXT compromise as: We say
that Mc, Π, S, σ |s4= ˆφ, (cid:126)x (cid:73)ic K, if and only if Mc, Π, S, σ |s4=
(cid:126)x (cid:54)(cid:52) ˆφ ∨ ¬RanGen(K), or there is a PPT algorithm AOsic2, with

Mc,Π, S, σ ||= sdec(AOsic2

( ˆφ, (cid:126)x), K) (cid:54)= ⊥

9. ON CONGRUENCE OF EQUALITY

Note that the semantics of the equality predicate = is not de-
ﬁned as identity in the domain. In fact, on the left-hand sides of the
predicates Oand (cid:73)O, equal terms cannot be freely substituted. This
might cause problems with decidability, the result in [19] heavily
builds on the fact that  is invariant under substitution with re-
spect to equal terms. There is, however a solution if we observe
that CCA2 security implies that encryptions cannot be faked: for
CCA2 secure encryption schemes, we can deﬁne the semantics of

1241ˆφ, (cid:126)x Ox such that only those ciphers are not decrypted by the de-
cryption oracles that are necessary for the computation of [[ ˆφ, (cid:126)x]].
Here, when we say an encryption is necessary, we mean the encryp-
tion cannot be omitted and the number of encryptions reduced by
this in the process computing [[ ˆφ, (cid:126)x]]. The reason we did not deﬁne
our predicates this way is that we did not want the well-deﬁnedness
of our predicates depend on whether the encryption satisﬁes CCA2
security. But if the encryption does satisfy CCA2 security, then O
and (cid:73)Ocan be deﬁned in the above way and all axioms that we have
listed are also valid for those new deﬁnitions, and on the top of it,
= would be a congruence relation.

The symmetric Needham-Schroeder protocol proof as well as
the NSL proof work either way, and we believe this issue does not
make a big difference in protocol proofs in general. But for au-
tomation, the two deﬁnitions might make a big difference.

10. SOUNDNESS OF AXIOMS

THEOREM 10.1

(SOUNDNESS). With the computational in-
terpretations of derivability and key compromise predicates, the ax-
ioms are computationally sound. For the "fresh keys are not com-
promised", it is necessary that the implementation of the encryp-
tion satisﬁes the corresponding (symmetric or asymmetric, IND or
KDM-CCA2 security, or INT-CTXT unforgeability). Soundness of
the other axioms do not require that. Furthermore, the no-telepathy
axiom requires that freshly generated items are guessable only with
negligible probability.

Note, unlike for general soundness (Theorem 5.3), here the num-
ber of sessions in the computational execution does not have to be
bounded in the security parameter.

We detail the proofs in the IND case, the KDM case is sketched,

details will be included in the long version.

PROOF. As the soundness proofs of the axioms for derivability
with oracles are essentially the same as the soundness proofs below,
we skip that and focus on key compromise.

• Substitutability of equal terms: The reason is that according
to the deﬁnition of key compromise, compromise of the item
on the right hand side of (cid:73)Oonly depends on the bit string that
is associated to the term there, and not on the structure of the
term. This is in contrast with the left hand side. The notion
that anything can be submitted to the decryption oracle that
is not an encryption on the left clearly depends on the term
structure on the left, so we have to make sure that in (cid:126)x and (cid:126)y
the same encryption values occur.
• Derivability implies compromise: Soundness of this axiom
is rather trivial, but we write it out for clarity. In order to
show that in any protocol execution and n.n. set S, we have
Mc, Π, S |c= ∀(cid:126)xK( ˆφ, (cid:126)xOK −→ ˆφ, (cid:126)x (cid:73)OK), by the com-
putational semantics we have to show that for any evaluation
σ of the variables, and for any S(cid:48) ⊆ S non-negligible set,
Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x OK implies Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x (cid:73)O
K. So suppose Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x OK holds. To show
Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x (cid:73)O K, let us take any S(cid:48)(cid:48) ⊆ S(cid:48). By
Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x OK, there is a S(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48) and an algo-
rithm BOO such that Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||= BOO
( ˆφ, (cid:126)x) = K. In
the IND deﬁnition of key compromise, we can chose AOO
in the key compromise deﬁnition simply to be a random bit
string r(ω) of length η. AOO
can take the key and decrypt
its third input. AOO
can be chosen to be identically 0η. If

21

1

22

21

and AOO

the third input is the encryption of r(ω) then r(ω) is received
after the decryption, so the output of AOO
22 differ
overwhelmingly. On the other hand, if it is the encryption
0|r(ω)|, then the outputs of AOO
21 and AOO
22 always agree. So
by the deﬁnition of key compromise, Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x (cid:73)O
K holds as there is such an S(cid:48)(cid:48)(cid:48) for all S(cid:48)(cid:48).
• Increasing capabilities for key compromise: If ˆφ, (cid:126)x (cid:73)O K,
there are AOO
, R, etc in the deﬁnition of key compromise.
The same items are good for ˆφ, (cid:126)x, x(cid:48) (cid:73)OK, ignoring x(cid:48).
• Commutativity: Trivial, the deﬁnition of key compromise is
invariant under the change of the order of the list (cid:126)x.
• Transitivity: For any S, assuming Mc, Π, S, σ |c= ˆφ, (cid:126)x O
(cid:126)y and Mc, Π, S, σ |c= ˆφ, (cid:126)x, (cid:126)y (cid:73)O K, we have to show that
Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)O K. Take an arbitrary S(cid:48) ⊆ S. By
Mc, Π, S, σ |c= ˆφ, (cid:126)x O(cid:126)y, there is a S(cid:48)(cid:48) ⊆ S(cid:48) and an AOO
algorithm such that Mc, Π, S(cid:48)(cid:48), σ ||= AOO
( ˆφ, (cid:126)x) = (cid:126)y. By
Mc, Π, S, σ |c= ˆφ, (cid:126)x, (cid:126)y (cid:73)O K, there is a S(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48) such that
for this S(cid:48)(cid:48)(cid:48), the conditions in the deﬁnition of key compro-
mise (in place of S(cid:48)(cid:48)) hold. Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||= AOO
( ˆφ, (cid:126)x) =
(cid:126)y. So in the key compromise deﬁnition applied to the satis-
faction Mc, Π, S, σ |c= ˆφ, (cid:126)x, (cid:126)y (cid:73)O K, the algorithms AOO
,
AOO
can run AOO as a subroutine to compute
(cid:126)y, so they do not need it as an input. Since there is such a
S(cid:48)(cid:48)(cid:48) ⊆ S(cid:48) for all S(cid:48) ⊆ S, we have Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)OK.

• Secrecy of CCA2 encryption: For the IND case, we have

and AOO

21

22

1

1

RanGen(K) ∧ fresh(R; ˆφ, (cid:126)x, x, y, K)
eK Oy

∧ (cid:126)x, x, y (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
−→ ˆφ, (cid:126)x, x (cid:73)OK ∨ ˆφ, (cid:126)x Oy

where O is either aic2 or sic2. Soundness of this follows
easily from our deﬁnition of key compromise and derivabil-
ity with oracle access. Note that CCA2 security of the en-
cryption is not needed in the following argument. We move
ˆφ, (cid:126)x Oy to the premise, it becomes ˆφ, (cid:126)x (cid:54)Oy. Let us denote
by θ the premise received this way. We have to show that for
any σ evaluation of free variables and S non-negligible set,
if Mc, Π, S, σ |c= θ, then Mc, Π, S, σ |c= ˆφ, (cid:126)x, x (cid:73)O K. So
suppose Mc, Π, S, σ |c= θ. For Mc, Π, S, σ |c= ˆφ, (cid:126)x, x (cid:73)OK,
take any non-negligible set S(cid:48) ⊆ S. As Mc, Π, S, σ |c= θ im-
plies that Mc, Π, S(cid:48), σ |c= ˆφ, (cid:126)x,{x}R
eK Oy by the semantics
of compound formulas (one conjunct in θ is ˆφ, (cid:126)x,{x}R
eK O
y, and the property is preserved under taking subsets), for
such an S(cid:48), by the deﬁnition of derivability, there is a non-
negligible subset S(cid:48)(cid:48) ⊆ S(cid:48) and an algorithm AOO such that
Mc, Π, S(cid:48)(cid:48), σ ||= AOO
eK ) = y. Let BOO be
the algorithm that takes ˆφ, (cid:126)x, x as input, submits x to its
encryption oracle to receive {x}R(cid:48)
eK, and then applies AOO
on ( ˆφ, (cid:126)x,{x}R(cid:48)
eK ). As this was y with non-negligible prob-
ability for R, it is also y with non-negligible probability for
R(cid:48), because y does not depend on either of them, and be-
cause the random inputs of the algorithms are required to be
fresh. Hence R(cid:48) is just as good an independent item as R
was. So there is a S(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48) such that Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||=
eK ) = y, and by the deﬁnition of BOO, we
AOO
also have Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||= BOO
( ˆφ, (cid:126)x, x) = y. Therefore,
Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||= AOO
eK ) = BOO
( ˆφ, (cid:126)x, x) =
y. Now observe, that since x was PPT generated, for any
non-negligible S, there must be a length function (cid:96)(η) such

( ˆφ, (cid:126)x,{x}R(cid:48)

( ˆφ, (cid:126)x,{x}R(cid:48)

( ˆφ, (cid:126)x,{x}R

1242(cid:48)(cid:48)(cid:48)

( ˆφ, (cid:126)x, x),

eK ) (cid:54)= BOO

eK ) = BOO

( ˆφ, (cid:126)x,{0(cid:96)}R(cid:48)(cid:48)

( ˆφ, (cid:126)x,{0|x|}R(cid:48)(cid:48)

( ˆφ, (cid:126)x,{x}R
( ˆφ, (cid:126)x,{0

eK ) = BOO
|x|}R(cid:48)(cid:48)

, σ ||= AOO
, σ ||= AOO
(cid:48)(cid:48)(cid:48)

that the probability that |x| = (cid:96)(η) is non-negligible on S.
This, means that AOO
( ˆφ, (cid:126)x, x) =
y cannot hold on any non-negligible subset of S(cid:48)(cid:48)(cid:48), because
if it did, then AOO
eK ) = y would also hold non-
negligible in S(cid:48)(cid:48)(cid:48) contradicting Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:54)Oy. So,
Mc, Π, S
( ˆφ, (cid:126)x, x), but
Mc, Π, S
which means Mc, Π, S, σ |c= ˆφ, (cid:126)x, x (cid:73)OK.
The argument for the KDM case is completely analogous,
except that we have Mc, Π, S(cid:48)(cid:48), σ |c= ˆφ, (cid:126)x(cid:54)(cid:73)OK there. Note,
that in the axiom for the KDM case, we only require about
x that (cid:126)x, x (cid:52) ˆφ; but the BOO in IND case above, had x as
an input which it then submits to the encryption oracle. The
analogous BOO in the KDM case is not allowed to use x as
an input. Instead, in the deﬁnition of key usability for the
KDM case we allowed the algorithms to use the encryptions
functions of items depending on the names generated that far.
Hence (cid:126)x, x (cid:52) ˆφ can be submitted to the oracle in the form of
such a function. and that is what BOO is also allowed to use.
x can be one of the elements in (cid:126)y.
• Next, we have to show that encryptions with uncompromised
keys do not compromise. Note again in the proof below that
we do not need CCA2 security of the encryption, we only
need the deﬁnition of key compromise. Instead of the origi-
nal formula, we show the following in the IND-CCA2 case:

RanGen(K) ∧ RanGen(K
) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K
(cid:48)
∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{x}R
eK(cid:48) (cid:73)OK ∧ ˆφ, (cid:126)x, x(cid:54)(cid:73)OK
(cid:48)
−→ ˆφ, (cid:126)x (cid:73)OK.

(cid:48)

)

We have to show that for all S non-negligible sets and σ
evaluations of variables, if Mc, Π, S, σ satisﬁes the premise,
then it satisﬁes the conclusion as well. So let us suppose it
satisﬁes the premise. We want to conclude Mc, Π, S, σ |c=
ˆφ, (cid:126)x (cid:73)O K. Following the deﬁnition of key compromise,
take any subset S(cid:48) ⊆ S. By the deﬁnition of key compro-
mise applied to Mc, Π, S, σ |c= ˆφ, (cid:126)x,{x}R
eK(cid:48) (cid:73)OK, there are
S(cid:48)(cid:48) ⊆ S(cid:48), R(cid:48), R1 AOO
and AOO
such that, taking
the ﬁrst possibility,

, AOO

21

22

1

Equation 2, we get that there is an R(cid:48)(cid:48), a subset S(cid:48)(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48)(cid:48)
just by restricting R(cid:48)(cid:48), such that
|AOO

( ˆφ,(cid:126)x,{0|x|}R(cid:48)(cid:48)

|x|}R(cid:48)(cid:48)

AOO
21 ( ˆφ, (cid:126)x,{0
(cid:54)= AOO

22 ( ˆφ, (cid:126)x,{0

eK(cid:48) ,{0
|x|}R(cid:48)(cid:48)

eK(cid:48) ,{0

1

|AOO

( ˆφ,(cid:126)x,{0|x|}R(cid:48)(cid:48)

eK(cid:48) )|}R(cid:48)

eK ))
eK(cid:48) )|}R(cid:48)

(4)

1

1

1

3

1

1

3

3

42

eK ))

|AOO

|AOO

such that on S(cid:48)(cid:48)(cid:48)(cid:48)(cid:48),
( ˆφ, (cid:126)x)}R1
eK ) =AOO

eK )),
still for all R(cid:48). Again, there is a length function (cid:96)(η) such that
the probability that |x| = (cid:96)(η) is non-negligible on S(cid:48)(cid:48)(cid:48)(cid:48). Let
the subset of S(cid:48)(cid:48)(cid:48)(cid:48) on which they are equal be S(cid:48)(cid:48)(cid:48)(cid:48)(cid:48). Since 0(cid:96)
is easily computable, we get that there are algorithms AOO
,
AOO
41 and AOO
AOO
41 ( ˆφ, (cid:126)x,{AOO
but
41 ( ˆφ, (cid:126)x,{0
AOO
eK )).
This exactly means that Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)O K. If we
switch = and (cid:54)=, we receive the proof of the other case of
key compromise.
Here too, the KDM case is proven entirely analogously.

42 ( ˆφ, (cid:126)x,{AOO

eK )(cid:54)=AOO

42 ( ˆφ, (cid:126)x,{0

( ˆφ, (cid:126)x)}R1

( ˆφ,(cid:126)x)|}R(cid:48)

( ˆφ,(cid:126)x)|}R(cid:48)

• Fresh keys are not compromised: It is here where IND-CCA2
(or KDM-CCA2) security of the encryption is used. We de-
ﬁne our CCA2 attacker against the CCA2 oracle that allows
multiple submissions for encryptions, which is equivalent
with the original deﬁnition [11]. Let us consider the IND-
CCA2 case. What we have to prove is that if Mc, Π, S, σ
satisﬁes freshness of key K, then Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)OK
leads to a CCA2 attack to the encryption. Let Mc, Π, S, σ |c=
ˆφ, (cid:126)x (cid:73)O K hold. That is, for every S(cid:48) ⊆ S, there are
S(cid:48)(cid:48) ⊆ S(cid:48), etc. such that (consider the ﬁrst case),
( ˆφ, (cid:126)x)}R
eK ) on S

21 ( ˆφ, (cid:126)x,{AOO
AOO
( ˆφ, (cid:126)x)}R

AOO
22 ( ˆφ, (cid:126)x,{AOO

eK ) =
(cid:48)(cid:48) and

(5)

1

1

|AOO
21 ( ˆφ, (cid:126)x,{0
AOO
AOO
22 ( ˆφ, (cid:126)x,{0

1

( ˆφ,(cid:126)x)|}R(cid:48)

eK ) (cid:54)=
( ˆφ,(cid:126)x)|}R(cid:48)
eK )

1

|AOO

(6)

on S(cid:48)(cid:48). Note that keyfresh(K; ˆφ, (cid:126)x) ∧ (cid:126)x (cid:52) ˆφ means the de-
cryption key or any function of it was never used in ˆφ, (cid:126)x.
What the CCA2 attacker has to do is to simulate the protocol
execution such that

AOO
21 ( ˆφ, (cid:126)x,{x}R
= AOO

22 ( ˆφ, (cid:126)x,{x}R

eK(cid:48) ,{AOO

1

( ˆφ, (cid:126)x,{x}R

eK(cid:48) )}R1

eK(cid:48) ,{AOO

1

( ˆφ, (cid:126)x,{x}R

eK ))
eK(cid:48) )}R1

eK ))

on S(cid:48)(cid:48), but
AOO
21 ( ˆφ, (cid:126)x,{x}R
(cid:54)= AOO

22 ( ˆφ, (cid:126)x,{x}R

eK(cid:48) ,{0

|AOO

1

( ˆφ,(cid:126)x,{x}R

eK(cid:48) )|}R(cid:48)

eK(cid:48) ,{0

|AOO

1

( ˆφ,(cid:126)x,{x}R

1

eK ))
eK(cid:48) )|}R(cid:48)

1

eK ))

(1)

(2)

on S(cid:48)(cid:48). By Mc, Π, S(cid:48)(cid:48), σ|c= ˆφ, (cid:126)x, x(cid:54)(cid:73)OK(cid:48), from Equation 1,
we have that there is an R(cid:48), and a subset (by restricting R(cid:48))
S(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48) such that on S(cid:48)(cid:48)(cid:48),
AOO
21 ( ˆφ, (cid:126)x,{0
= AOO

( ˆφ, (cid:126)x,{0
eK )).
Equation 2 still holds on S(cid:48)(cid:48)(cid:48) and for all R(cid:48)
1 and R(cid:48)
are independent. By Mc, Π, S(cid:48)(cid:48)(cid:48), σ |c= ˆφ, (cid:126)x, x(cid:54)(cid:73)OK(cid:48), from

eK(cid:48) )}R1
|x|}R(cid:48)
1, as R(cid:48)

eK(cid:48) ,{AOO
|x|}R(cid:48)

22 ( ˆφ, (cid:126)x,{0

eK(cid:48) ,{AOO

eK(cid:48) )}R1

( ˆφ, (cid:126)x,{0

eK )) (3)

|x|}R(cid:48)

|x|}R(cid:48)

1

1

– except for K, the CCA2 attacker generates all keys
– encryptions (except for that of AOO

( ˆφ, (cid:126)x)) with K are
done by submitting two identical requests to the en-
cryption oracle

– the attacker keeps a table recording which encryption

1

belongs to which plaintext

– decryptions of ciphertexts provided by the encryption

oracle are done by looking it up in the table

– decryptions of strings not provided by the oracle are

– when the challenge state is reached, the interpretations

done by submitting to the decryption oracle
of (cid:126)x and AOO

( ˆφ, (cid:126)x) are computed

1

1

( ˆφ, (cid:126)x) is submitted to the encryption oracle along
with a string of 0’s of the same length. Let c0 denote the
encryption that is received from the oracle. Note that
the adversary does not know if this is the encryption of
AOO

( ˆφ, (cid:126)x) or of the 0’s.

1

– AOO

– apply AOO

21 and AOO

22

to ˆφ, (cid:126)x, c0.

1243– because of (5) and (6) on S(cid:48)(cid:48), if the correct bit string
was encrypted, the two computations are equal, and if
the 0’s were encrypted, the two are different.

However, the attacker does not necessarily know when he is
inside S(cid:48)(cid:48) and when outside. Outside S(cid:48)(cid:48) the attacker can-
not be sure that equality means the correct encryption was
encrypted. To overcome this problem, we ﬁnish the above
CCA2 attack the following way. Let µ(η) be a function (in
the security parameter) of natural numbers.
– the adversary submits pairs of 0|AOO

( ˆφ,(cid:126)x)| for encryp-
tion µ times. Let ci denote (i = 1, ..., µ) the encryp-
tions received back from the oracle. Note that these en-
cryptions are known to be encryptions of 0|AOO
( ˆφ,(cid:126)x)|

1

1

– applies AOO
– CASE 1: if AOO

21 and AOO

22 on all of ˆφ, (cid:126)x, ci

21 ( ˆφ, (cid:126)x, c0) = AOO

22 ( ˆφ, (cid:126)x, c0) but

AOO
21 ( ˆφ, (cid:126)x, ci) (cid:54)= AOO
22 ( ˆφ, (cid:126)x, ci) for all i = 1, ..., µ,
then the CCA2 attacker outputs 1, meaning that his
guess is that the oracle encrypted the correct bit string.
– CASE 2: otherwise, the adversary tosses a coin and

outputs the result.

1

1

( ˆφ, (cid:126)x)}R

( ˆφ, (cid:126)x)}R

21 ( ˆφ, (cid:126)x,{AOO
eK ) but where AOO

We can think of the probability space of the CCA2 attack as
{0, 1} × Ωη, where {0, 1} represents the internal bit of the
oracles. Even if the internal bit is 0, the simulation of the
protocol execution can be done according to the above rules.
Let Sµ ⊆ Ω be the set where AOO
eK ) =
21 ( ˆφ, (cid:126)x, ci) (cid:54)=
22 ( ˆφ, (cid:126)x,{AOO
AOO
AOO
22 ( ˆφ, (cid:126)x, ci) for all i = 1, ..., µ, (that is, CASE 1 hap-
pens when the real plaintext is encrypted in the CCA2 at-
tack). Note that Sµ depends on the function µ, but still,
S(cid:48)(cid:48) ⊆ Sµ, so Sµ is also non-negligible. Suppose, the in-
ternal bit of the oracle is 1. Then, on Sµ, according to our
setup of the CCA2 attacker, he outputs 1, giving the correct
guess. That is, denoting by ACCA2 the CCA2 attacker as de-
scribed above, the output of ACCA2 is 1 on {1} × Sµ. On
{1} × (Ω \ Sµ), ACCA2 tosses a coin, so the probabilities
there balance out. Consider now {0} × Ω. Here the internal
bit of the oracles is 0, that is they encrypt the 0’s, that is, here
c0 is the encryption of 0’s. If the probability on {0}× Ω that
AOO
21 ( ˆφ, (cid:126)x, c0)) = AOO
22 ( ˆφ, (cid:126)x, c0)) holds is negligible, then
we are done, because on {0} × Ω too a coin is tossed, so the
advantage of the adversary is 1/2 · Prob{{1} × Sµ}, which
is non-negligible. So let us assume now that the probability
that AOO
22 ( ˆφ, (cid:126)x, c0)) holds is not negli-
gible on {0} × Ω. But the other ci are also just encryptions
of 0’s, so AOO
22 ( ˆφ, (cid:126)x, ci)) holds with the
same probability for all i on {0} × Ω. For each ﬁxed η, the
higher µ(η) we chose, the higher the probability is that one
AOO
21 ( ˆφ, (cid:126)x, ci)) = AOO
22 ( ˆφ, (cid:126)x, ci)) holds for at least one i.
In fact, this probability can be made arbitrarily close to 1 by
increasing µ(η). If it is close enough to 1, then the proba-
bility of making an error (other than the case when a coin
is tossed) on {0} × Ω becomes smaller than the probability
of {1} × Sµ, and hence the error probability cannot cancel
out the winning probability. Since the probability of hitting
the same encryption with the 0’s was assumed to be non-
negligible, it is sufﬁcient to have a polynomial µ(η) to en-
sure that the probability of having at least one hit is closer
to 1 than the non-negligible probability of {1} × Sµ. In this
case, the win on {1} × Sµ when the internal bit is 1 can-

21 ( ˆφ, (cid:126)x, c0)) = AOO

21 ( ˆφ, (cid:126)x, ci)) = AOO

1

not be cancelled by the loss elsewhere, so the CCA2 attacker
wins. Note, if ˆφ, (cid:126)x contains the decryption key outside S, the
attack can simply terminate there and output a random bit.
The proof for KDM-CCA2 is exactly analogous. The only
difference is, that instead of AOO
( ˆφ, (cid:126)x), there is an x there,
but the oracles accept the functions to be submitted. When it
comes to computing the encryptions of x, the KDM encryp-
tion oracle is requested. It is not directly x that is submitted,
but a description of a function of the keys instead. Since the
KDM adversary is simulating the protocol, all items except
for the secret keys and the random inputs to the encryptions
in the symmetric case are available to him.
• Fresh items do not compromise: The idea is exactly the same
as in case of the derivability predicate. A fresh item can just
as well be created by the adversary, it cannot help him.

We now turn to the case of INT-CTXT key compromise.
Proofs of the ﬁrst six axioms and the last one are entirely identi-
cal to the proofs for CCA2 key compromise. The soundness of the
“encryptions with uncompromised keys do not compromise" axiom
is also analogous: We again show the following:

RanGen(K) ∧ RanGen(K

) ∧ fresh(R; ˆφ, (cid:126)x, x, K, K
(cid:48)
(cid:48)
)
∧ (cid:126)x, x (cid:52) ˆφ ∧ ˆφ, (cid:126)x,{|x|}R
K(cid:48) (cid:73)ic K ∧ ˆφ, (cid:126)x, x(cid:54)(cid:73)sic2K
−→ ˆφ, (cid:126)x (cid:73)ic K

(cid:48)

( ˆφ, (cid:126)x, {|x|}R
K(cid:48) ) = {|z|}R(cid:48)

K(cid:48) ), K) (cid:54)= ⊥
K → {|z|}R(cid:48)

Again, we have to show that for all S non-negligible sets and σ
evaluations of variables, if Mc, Π, S, σ satisﬁes the premise, then
it satisﬁes the conclusion as well. So let us suppose it satisﬁes the
premise. We want to show Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)ic K. Following
the deﬁnition of key compromise, take any subset S(cid:48) ⊆ S. By the
deﬁnition of key compromise, Mc, Π, S, σ |c= ˆφ, (cid:126)x,{|x|}R
K(cid:48) (cid:73)ic K
implies there is a S(cid:48)(cid:48) ⊆ S, and a PT algorithm AOsic2, such that
Mc, Π, S(cid:48)(cid:48), σ ||= sdec(AOsic2
∧ ∀zR(cid:48)(AOsic2
( ˆφ, (cid:126)x, {|x|}R
and on S(cid:48)(cid:48), AOsic2
( ˆφ, (cid:126)x, ,{|x|}R
K(cid:48) ) is not equal any of the outputs of
the encryption oracles. Now, we also have that Mc, Π, S(cid:48)(cid:48), σ |c=
ˆφ, (cid:126)x, x(cid:54)(cid:73)sic2K(cid:48) from the satisfaction of the premise. This gives us
that there is some S(cid:48)(cid:48)(cid:48) non-negligible subset of S(cid:48)(cid:48) such that
Mc, Π, S(cid:48)(cid:48)(cid:48), σ ||= sdec(AOsic2
∀zR(cid:48)(AOsic2
( ˆφ, (cid:126)x, {|0|x||}R
and on S(cid:48)(cid:48), AOsic2
K(cid:48) ) is not equal any of the outputs
of the encryption oracles. Again, as the length of x can be guessed,
there is a non-negligible S(cid:48)(cid:48)(cid:48)(cid:48) ⊆ S(cid:48)(cid:48)(cid:48) and a BOsic2 such that

K (cid:54)(cid:118) ˆφ, (cid:126)x, {|0|x||}R
K(cid:48) )

K (cid:54)(cid:118) ˆφ, (cid:126)x, {|x|}R
K(cid:48) )

( ˆφ, (cid:126)x, ,{|0|x||}R

K(cid:48) ), K) (cid:54)= ⊥ ∧

K(cid:48) ) = {|z|}R(cid:48)

K → {|z|}R(cid:48)

( ˆφ, (cid:126)x, {|0|x||}R

Mc, Π, S
∧ ∀zR
(cid:48)

(cid:48)(cid:48)(cid:48)(cid:48)
(BOsic2

, σ ||= sdec(BOsic2
( ˆφ, (cid:126)x) = {|z|}R(cid:48)

( ˆφ, (cid:126)x), K) (cid:54)= ⊥
K → {|z|}R(cid:48)

K (cid:54)(cid:118) ˆφ, (cid:126)x)

and on S(cid:48)(cid:48)(cid:48)(cid:48), BOsic2
( ˆφ, (cid:126)x) is not equal any of the outputs of the en-
cryption oracles. And that exactly means Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)ic
K. Again, the KDM case is entirely analogous.
axiom is immediate from the semantics of (cid:73)ic. If
Mc, Π, S, σ |c= RanGen(K) ∧ ˆφ, (cid:126)x  y ∧ dec(y, dK) (cid:54)= ⊥

Proof of the uncompromised key’s encryption cannot be faked

∧ ∀xR(y = {x}R

eK → {x}R

eK (cid:54)(cid:118) ˆφ, (cid:126)x)

Then for all S(cid:48) ⊆ S, there is a S(cid:48)(cid:48) ⊆ S(cid:48) and an algorithm A such
that Mc, Π, S(cid:48)(cid:48), σ ||= A( ˆφ, (cid:126)x) = y. Furthermore, the last conjunct

1244means that the output of the algorithm is not any of the encryptions
in ˆφ, (cid:126)x, and the third conjunct means the decryption does not fail.
This is exactly means that Mc, Π, S, σ |c= ˆφ, (cid:126)x (cid:73)ic K.

The only remaining axiom is the fresh keys are not compromised
axiom for the INT-CTXT case. But that is rather easy. Suppose, the
encryption is INT-CTXT secure. Mc, Π, S, σ |c= ˆφ (cid:73)ic K means
there is a S(cid:48)(cid:48) ⊆ S, and a PT algorithm AOsic2, such that
Mc, Π, S

, σ ||= sdec(AOsic2

( ˆφ), K) (cid:54)= ⊥

(cid:48)(cid:48)

(cid:48)

(AOsic2

( ˆφ) = {|z|}R(cid:48)

K (cid:54)(cid:118) ˆφ)
∧ ∀zR
and on S(cid:48)(cid:48), AOsic2
( ˆφ) is not equal any of the outputs of the encryp-
tion oracles. But that exactly means that there is a non-negligible
set (namely S(cid:48)(cid:48)), on which AOsic2 can produce a ciphertext, contra-
dicting the INT-CTXT property.

K → {|z|}R(cid:48)

11. SIMPLE EXAMPLES

Now let us see on a few simple examples how inconsistency can
be shown with the above axioms. In [5], the authors presented some
of the most basic examples, therefore the ones we analyze here are
a little more complex, all are related to sending keys around. We
use symmetric encryption in these examples.

EXAMPLE 11.1. Suppose the ﬁrst messages in a frame are

φ3 ≡ (cid:104)(A, B),{|K|}R1

KAB

,{|h2, N|}R2
K (cid:105),

K

K

with names KKABN R1R2, and where the symmetric encryption
is IND- (or KDM-) CCA2 secure. We want to show that φ3  N is
inconsistent with the axioms, that is, N remains secret. Let now O
denote either sic2 or skc2. Suppose φ3  N holds. Then we have
φ3 ON by the more oracles help more axiom. That is the same
as φ2,{|h2, N|}R2
ON. By the no-telepathy axiom, φ2 (cid:54)ON as
fresh(N ; φ2) holds (which follows directly from the deﬁnition of
the freshness constraint, not from axioms). By the ‘uncompro-
mised key securely encrypts’ axiom for CCA2 symmetric case,
with the roles (cid:126)x ≡ (cid:104)(cid:105), x ≡ (cid:104)h2, N(cid:105), y ≡ N, since we assumed
φ2,{|h2, N|}R2
ON, we also have that either φ2 ON (already
ruled out) or (depending on O) φ2, h2, N (cid:73)sic2 K or φ2 (cid:73)skc2 K .
In the IND-CCA2 case, by the ‘fresh items do not compromise’
axiom, we then have φ2, h2 (cid:73)sic2 K as N does not appear in
φ2. Since the handle is always derived from the frame, φ2  h2
holds, hence φ2 sic2 h2 and by the transitivity axiom applied for
φ2, h2 (cid:73)sic2 K and φ2 sic2 h2, we have φ2 (cid:73)sic2 K, just as we
had in the KDM case earlier. But that is the same as (now for both
IND and KDM cases) φ1,{|K|}R1
(cid:73)O K. By the ‘encryptions
with uncompromised keys do not compromise’ axiom, with roles
K(cid:48) ≡ KAB, (cid:126)x ≡ (cid:104)(cid:105) and x ≡ K, we have that either φ1 (cid:73)O K,
or φ1, K (cid:73)sic2 KAB or φ1 (cid:73)skc2 KAB. However, φ1 (cid:54)(cid:73)OK be-
cause of the ‘fresh keys are not compromised’ axiom, and the same
is true for φ1 (cid:54)(cid:73)OKAB. So for the KDM case we have a contra-
diction and we are done. For the IND case, again by the ‘fresh
items do not compromise’ axiom, φ1, K (cid:73)sic2 KAB together with
fresh(K; φ1, KAB) implies φ1 (cid:73)sic2 KAB, hence again we ar-
rived at a contradiction.

KAB

It may seem to the reader that the axioms provided in [5] (that
is, without key compromise) could also be sufﬁcient to prove that
φ3  N is inconsistent with the axioms there by removing items
from φ3 in a different order from what we just did in Example 11.1.
Namely, the idea would be to proceed the following way: given
φ3  N, ﬁrst remove the ﬁrst encryption (by the secrecy axiom as
KAB was never sent out), and receive (cid:104)(A, B),{|h2, N|}R2
K (cid:105)  N.
Then remove the second encryption (by secrecy as K is not in

KAB

the frame any more after removing the ﬁrst encryption) receiving
(A, B)  N contradicting the no-telepathy axiom. However, ap-
plication of the secrecy axiom in [5] (and also in this paper) to
(cid:104)(A, B),{|h2, N|}R2
K (cid:105)  N requires h2 (cid:52) (A, B), which means
(A, B)h2, but that does not hold, because h2 was computed from
(cid:104)(A, B),{|K|}R1
(cid:105). Secrecy axiom can only be used if the frame
contains all necessary information for the computation of handles
in the plaintext. It is in fact possible to show that φ3  N is consis-
tent with the axioms of [5]. Although those axioms are inconsistent
with h2  K, they do allow h2 to carry partial information about K
sufﬁcient to compromise the second encryption. Without the han-
dle h2 in the second encryption, the axioms of [5] are sufﬁcient to
prove inconsistency, but except for initial ones, protocol messages
are normally responses to agent inputs and contain handles.

EXAMPLE 11.2. Now suppose
φ3 ≡ (cid:104)(A, B),{|K|}R1

KAB

K (cid:105)
,{|KAB, h2, N|}R2

KAB

, receive φ1,{|K|}R1

and let us try to show that φ3 ON contradicts the axioms. Note that
there is a key cycle in this example, K and KAB encrypt each other.
So assume φ3 ON. For IND-CCA2 security, from the ‘uncompro-
mised key securely encrypts’ axiom we get φ2, KAB, h2, N (cid:73)sic2
K if we follow the same steps as we did in Example 11.1. Then
the same way as before, we can remove h2 and N, and since φ2 ≡
φ1,{|K|}R1
, KAB (cid:73)sic2 K. But this does
not lead to a contradiction! According to the equational theory,
K = sdec({|K|}R1
, KAB), and by the ‘functions are computable’
axiom, we get φ1,{|K|}R1
, KAB sic2 K. So we always have
φ1,{|K|}R1
, KAB (cid:73)sic2 K too by the ‘derivability implies com-
promise’ axiom, there is no contradiction. However, if we have
KDM security, then just as in the previous example, using the ‘un-
compromised key securely encrypts’ axiom, φ3 skc2 N immedi-
ately leads to φ2 (cid:73)skc2 K, and the rest of the derivation is the
same as in the previous example. So in this case, while φ3 sic2 N
is consistent with the axioms, φ3 skc2 N is inconsistent.

KAB

KAB

KAB

KAB

EXAMPLE 11.3. With names KK(cid:48)KABN R1R2R3, consider

φ3 = (cid:104)(A, B),{|K|}R1

KAB

,{|{|KAB|}R2

K(cid:48) , h2, N|}R3
K (cid:105).

K and KAB are still in cycles, but they do not disturb each other
because of K(cid:48). Again, assuming IND-CCA2 security, from φ3sic2
N ﬁrst φ2,{|KAB|}R2
K(cid:48) , h2, N (cid:73)sic2 K is derived using the ‘un-
compromised key securely encrypts’ axiom as in Example 11.1. As
in Example 11.1, h2 and N are removed: φ2,{|KAB|}R2
K(cid:48) (cid:73)sic2 K.
At this point, the ‘encryptions with uncompromised keys do not
compromise’ axiom implies that either φ2(cid:73)sic2K or φ2,KAB (cid:73)sic2
K(cid:48). In the former case, we are back at the situation of Example
11.1 and we arrive at a contradiction. In the latter case, by function
(encryption) application on φ1,{|K|}R1
, KAB (cid:73)sic2 K(cid:48), we get
φ1, K, KAB, R1 (cid:73)sic2 K(cid:48). By ‘the fresh items do not compro-
mise’ axiom, K, KAB, R1 can be removed receiving φ1 (cid:73)sic2 K(cid:48)
contradicting the ‘fresh keys are uncompromised’ axiom.

KAB

12. THE SYMMETRIC

NEEDHAM-SCHROEDER PROTOCOL
With the axioms that we presented, we have proven the amended

symmetric Needham-Schroeder protocol:

1. A → B : A
2. B → A : {A, N1}KBT
3. A → T : (cid:104)A, B, N2, {A, N1}KBT (cid:105)
4. T → A : {N2, B, K, {K, N1, A}KBT }KAT
5. A → B : {K, N1, A}KBT

12456. B → A : {N3}K
7. A → B : {N3 − 1}K

This protocol ﬁrst has a key distribution part, and then the dis-
tributed key is used to securely encrypt a nonce. We showed that
no symbolic (hence computational) attacker succeeds the follow-
ing way (motivated by [25]). Using IND-CCA2 and INT-CTXT
axioms, we ﬁrst showed by an inductive technique that the key
K from the trusted party meant for honest A and B are never
corrupted (corruption is inconsistent with the axioms and agent
checks). Then, again with an inductive technique we showed that
N3 is never leaked. Finally, agreement and authentication were
shown. Besides the presented axioms, we also needed that adding
1 and subtracting 1 are inverses of each other, and x − 1 (cid:54)= x.
We needed an additional property, namely, that applying the ﬁrst
projection of a pairing on an honestly generated nonce cannot re-
sult the nonce itself with more than negligible probability. Triples,
quadruples were constructed out of pairs. The detailed proof is
available online at the ﬁrst author’s homepage. We assumed that
A is running the initiator role in all his sessions, and B is running
the responder’s role. There is only one trusted party. They all are
allowed to run any number of multiple parallel sessions with honest
and corrupted agents.

On a note about dynamic corruption, the proof works even if the
protocol allows the release of the key K at a later time. Secrecy
can still be proven until that point, authentication that was carried
out earlier can still be veriﬁed.

13. CONCLUSIONS

In this paper we further expanded the framework proposed by
Bana and Comon-Lundh [7] for computationally complete sym-
bolic adversary. We have shown how key exchange can be han-
dled. Proofs with this technique are computationally sound with-
out the need of any further assumptions such as no bad keys, etc.
that are assumed in other literature. We presented a modular set of
axioms that are computationally sound for implementations using
IND-CCA2, KDM-CCA2 and INT-CTXT secure encryptions re-
spectively. We illustrated their power via simple examples and the
veriﬁcation of an entire protocol.

We are investigating extensions of the general soundness theo-
rem in order to account for unbounded number of sessions and also
to be able to handle indistinguishability properties. More impor-
tantly, we are also researching automation.

14. REFERENCES
[1] P. Adão, G. Bana, J. Herzog, and A. Scedrov. Soundness and

completeness of formal encryption: the cases of key-cycles
and partial information leakage. Journal of Computer
Security, 17(5):737–797, 2009.

[2] M. Backes, A. Malik, and D. Unruh. Computational

soundness without protocol restrictions. In CCS’12, pages
699–711. ACM, 2012.

[3] M. Backes, B. Pﬁtzmann, and M. Waidner. A composable
cryptographic library with nested operations. In CCS’03,
pages 220–230. ACM, 2003.

[4] M. Backes, B. Pﬁtzmann, and M. Waidner. The reactive

simulatability (rsim) framework for asynchronous systems.
Information and Computation, 205(12):1685–1720, 2007.

[5] G. Bana, P. Adão, and H. Sakurada. Computationally
Comlete Symbolic Attacker in Action. In FSTTCS’12,
LIPIcs, pages 546–560. Schloss Dagstuhl, 2012.

[6] G. Bana and H. Comon-Lundh. Towards unconditional

soundness: Computationally complete symbolic attacker.

Available at IACR ePrint Archive, Report 2012/019.

[7] G. Bana and H. Comon-Lundh. Towards unconditional

soundness: Computationally complete symbolic attacker. In
POST’12, LNCS, pages 189–208. Springer, 2012.

[8] G. Bana, K. Hasebe, and M. Okada. Computational

semantics for ﬁrst-order logical analysis of cryptographic
protocols. In Formal to Practical Security, volume 5458 of
LNCS, pages 33–58. Springer, 2009.

[9] G. Barthe, B. Grégoire, and S. Zanella Béguelin. Formal

certiﬁcation of code-based cryptographic proofs. In
POPL’09, pages 90–101. ACM, 2009.

[10] G. Barthe, B. Grégoire, and S. Zanella Béguelin. Formal

certiﬁcation of code-based cryptographic proofs. In POPL,
pages 90–101. ACM, 2009.

[11] M. Bellare, A. Boldyreva, and S. Micali. Public-key

encryption in a multi-user setting. In EUROCRYPT’00,
pages 258–274. Springer, 2000.

[12] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway.

Relations among notions of security for public-key
encryption schemes. In CRYPTO’98, LNCS. Springer, 1998.
[13] M. Bellare and Ch. Namprempre. Authenticated encryption:

Relations among notions and analysis of the generic
composition paradigm. J. Cryptology, 21(4):469–491, 2008.

[14] B. Blanchet. A computationally sound mechanized prover
for security protocols. IEEE Transactions on Dependable
and Secure Computing, 5(4):193–207, 2008.

[15] J. Camenisch, N. Chandran, and V. Shoup. A public key
encryption scheme secure against key dependent chosen
plaintext and adaptive chosen ciphertext attacks. In
EUROCRYPT’09, LNCS, pages 351–368. Springer, 2009.
[16] H. Comon, C. Marché, and R. Treinen, editors. Constraints

in Computational Logics: Theory and Applications,
International Summer School, CCS’99, LNCS, 2001.

[17] H. Comon-Lundh and V. Cortier. Computational soundness

of observational equivalence. In CCS’08, pages 109–118.
ACM, 2008.

[18] H. Comon-Lundh and V. Cortier. How to prove security of

communication protocols? A discussion on the soundness of
formal models w.r.t. computational ones. In STACS’11,
LIPIcs, pages 29–44. Schloss Dagstuhl, March 2011.
[19] H. Comon-Lundh, V. Cortier, and G. Scerri. Tractable

inference systems: an extension with a deducibility
predicate. In CADE’13, LNAI. Springer, 2013.

[20] V. Cortier and B. Warinschi. Computationally sound,

automated proofs for security protocols. In ESOP’05, LNCS,
pages 157–171, 2005.

[21] A. Datta, A. Derek, J. C. Mitchell, V. Shmatikov, and

M. Turuani. Probabilistic polynomial-time semantics for a
protocol security logic. In ICALP’05, LNCS, pages 16–29.
Springer, 2005.

[22] A. Datta, A. Derek, J. C. Mitchell, and B. Warinschi.

Computationally sound compositional logic for key exchange
protocols. In CSFW ’06, pages 321–334. IEEE, 2006.

[23] Melvin Fitting. An embedding of classical logic in s4. The

Journal of Symbolic Logic, 35(4):529–534, 1970.

[24] R. Küsters and M. Tuengerthal. Computational soundness for

key exchange protocols with symmetric encryption. In
CCS’09, pages 91–100. ACM, 2009.

[25] F. J. Thayer, J. C. Herzog, and J. D. Guttman. Strand spaces:

Proving security protocols correct. Journal of Computer
Security, 7(1):191–230, 1999.

1246