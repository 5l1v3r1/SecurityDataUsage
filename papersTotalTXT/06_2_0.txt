Comparing Mobile Privacy Protection through Cross-Platform Applications

Jin Han(cid:3), Qiang Yany, Debin Gaoy,

(cid:3)Cryptography and Security Department

Institute for Infocomm Research
fhanj, jyzhoug@i2r.a-star.edu.sg

Jianying Zhou(cid:3), Robert Dengy
ySchool of Information Systems
Singapore Management University

fqiang.yan.2008, robertdeng, dbgaog@smu.edu.sg

Abstract—With the rapid growth of the mobile market, secu-
rity of mobile platforms is receiving increasing attention from
both research community as well as the public. In this paper,
we make the ﬁrst attempt to establish a baseline for security
comparison between the two most popular mobile platforms.
We investigate applications that run on both Android and
iOS and examine the difference in the usage of their security
sensitive APIs (SS-APIs). Our analysis over 2,600 applications
shows that iOS applications consistently access more SS-APIs
than their counterparts on Android. The additional privileges
gained on iOS are often associated with accessing private
resources such as device ID, camera, and users’ contacts.

A possible explanation for this difference in SS-API usage
is that privileges obtained by an application on the current
iOS platform are invisible to end users. Our analysis shows
that: 1) third-party libraries (speciﬁcally advertising and an-
alytic libraries) on iOS invoke more SS-APIs than those on
Android; 2) Android application developers avoid requesting
unnecessary privileges which will be shown in the permission
list during application installation. Considering the fact that
an Android application may gain additional privileges with
privilege-escalation attacks and iOS provides a more restricted
privilege set accessible by third-party applications, our results
do not necessarily imply that Android provides better privacy
protection than iOS. However, our evidence suggests that
Apple’s application vetting process may not be as effective
as Android’s privilege notiﬁcation mechanism, particularly in
protecting sensitive resources from third-party applications.

I. INTRODUCTION

The current intensive competition among mobile plat-
forms has sparked a heated debate on which platform has
a better architecture for security and privacy protection.
Discussions usually focus on Google’s Android and Apple’s
iOS, which are the top two players in terms of user base [1],
[2]. Some claim that Android is better since it makes the
complete permission list visible to users and it takes an
open-source approach [2]. Some argue that iOS is better
because 1) Apple screens all applications before releasing
them to the iTunes App Store (aka. Apple’s vetting process);
2) Apple has complete control of its hardware so that OS
patches and security ﬁxes are more smoothly applied on all
devices; and 3) the open-source nature of Android makes
it an easier target of attacks than iOS [1]. Others [3], [4]
suggest that the two platforms achieve comparable security
but in different ways. These different voices clearly raise
the need for establishing a baseline for security comparison
among different mobile platforms. Unlike most prior efforts

in comparing the abstract and general practices towards
security [1], [2], [3], [4], we make the ﬁrst attempt
to
establish such a baseline by analyzing the security-sensitive
API usage on cross-platform applications.

A cross-platform application is an application that runs on
multiple mobile platforms, e.g., the Facebook application has
both an Android and an iOS version with almost identical
functionality. We ﬁrst try to identify these cross-platform
applications by crawling information on both Google Play
and iTunes App Store. Our web crawler collects information
of more than 300,000 Android applications and 400,000 iOS
applications. Several data mining techniques are adopted to
match the applications released for the two platforms. We
ﬁnd that 12.2% of the applications on Google Play have a
replica on iTunes Store. Among them, we select the most
popular 1,300 pairs to further analyze their security-sensitive
API usage.

A security-sensitive API (SS-API) is a public API pro-
vided for third-party applications that may have access to
private user data or control over certain device components
(e.g., Bluetooth and camera). In order to analyze the similar-
ities and differences of the SS-API usage, the ﬁrst challenge
is to develop an SS-API mapping between Android an iOS.
Based on the permission concept on Android and the existing
Android API-to-permission mapping provided by Felt et
al. [5], we group the SS-APIs on iOS into 20 different
API types and map them to the corresponding Android SS-
APIs. Our analysis produces a list of SS-API types that
are both supported by Android and iOS. With such API
mappings available, we statically analyze the cross-platform
applications (Android Dalvik binaries and iOS Objective-C
executables).

By analyzing the 1,300 pairs of cross-platform applica-
tions, which are sampled from the most popular applications,
we show that 73% of them on iOS access additional SS-
APIs, compared to their replicas on Android. The addi-
tional SS-APIs invoked are mostly for accessing sensitive
resources such as device ID, camera, user contacts, and
calendar, which may cause privacy breaches or security risks
without being noticed. We further investigate the underlying
reasons by separately analyzing third-party libraries and
applications’ own code. Our results show that the commonly
used third-party libraries on iOS, especially the advertising
and analytic libraries access more SS-APIs compared to

the corresponding libraries on Android. Similar results are
observed from the applications’ own code. Further analysis
shows that a likely explanation of such differences is that
sensitive resources can be accessed more stealthily on the
current iOS platform, compared to Android where all the
privileges required by an application have to be shown to the
end user during installation. We also discover, and conﬁrm
with the Android application developers, that SS-APIs may
be intentionally avoided if the same functionality can be
implemented by non-security sensitive APIs. These results
suggest that Apple’s vetting process may not be as effective
as that most users think, particularly in protecting users’
private data from third-party applications. This problem
might also have been realized by Apple Inc., as the newly
released iOS 6 has added privilege notiﬁcations for accessing
user contacts, calendar, photos, and reminders.

The contributions of this paper are as follows:
(cid:15) We establish the ﬁrst baseline for comparing the secu-
rity architectures of different mobile platforms by ex-
amining security-sensitive API usage of cross-platform
applications. This baseline provides a more compre-
hensive understanding on how the platform difference
inﬂuences the privacy protection against
third-party
applications.

(cid:15) We investigate the SS-APIs of iOS platform and their
relations to Android SS-APIs, which complement the
existing knowledge on the security architecture of con-
temporary mobile platforms. Our analysis reveals the
SS-API types that are supported by both Android and
iOS.

(cid:15) We implement static analysis tools for both Android
and iOS applications and apply these tools on popu-
lar cross-platform applications. Our results show sig-
niﬁcant difference in the SS-API usage for Android
and iOS third-party applications. The detailed analysis
shows a strong correlation between such usage differ-
ence and the lack of an explicit privilege-list mecha-
nism on iOS, which may imply that Apple’s vetting
process is not as effective as expected in restricting
SS-API usage by application developers.

II. BACKGROUND AND OVERVIEW

A. Security Model: Android vs. iOS

Mobile security is very different from desktop PC security
– the security goal of mobile operating systems is to make
the platforms inherently secure rather than to force users
to rely upon third-party security solutions. Thus, various
security mechanisms are adopted and enabled as default on
current mobile operating systems. The security features used
by Android and iOS are listed in Table I.

Privilege Notiﬁcation: On Android, an application has
to explicitly declare the privileges it requires. A user will be
presented with these privileges when installing an applica-
tion so that he can choose not to proceed if he is unwilling

SECURITY MODEL COMPARISON: ANDROID VS. IOS

Table I

Security Feature
Privilege Notiﬁcation
Approval/Vetting Process
Digital Signing
Binary Encryption
Sandboxing
Data Encryption
Damage Control
Address Space Layout Randomization

Android

Yes
Partial
Yes

Since v4.1

Yes
Yes
Yes

iOS
Partial
Yes
Yes
Yes
Yes
Yes
Yes

Since v4.0

Since v4.3

to grant the corresponding privileges. On iOS, however, all
third-party applications are treated “equally” in the sense
that they are given the same set of privileges as default.
Until iOS 5, the only privileges which require users’ explicit
acknowledgement are for accessing location information and
for sending push notiﬁcations.

Approval/Vetting Process: Approval from Apple is
needed before an application is distributed via the iTunes
Store. Apple screens each uploaded application to check
whether it contains malicious code or violates Apple’s priva-
cy policy before releasing it on the iTunes Store. This vetting
process is not well-documented, and there have been cases
where malicious applications passed the vetting process but
had to be removed later from the iTunes Store [6]. On
the Android platform, Bouncer [7] is recently revealed by
Android team which provides automated scanning of Google
Play for potentially malicious software. However, Bouncer
does not require developers to go through an application
approval process. It performs a set of analysis on the
applications that are already released on Google Play.

Signing and Encryption: On both platforms, every ap-
plication is digitally signed with a certiﬁcate. The difference
is that Android applications are signed by developers and
iOS applications are signed by Apple. Furthermore, signing
on Android is mainly used in the sandbox for resource
sharing – applications that are signed by the same private
key can be assigned with the same process ID on Android.
In addition to signing,
iOS application binaries are al-
so partially-encrypted to mitigate unauthorized distribution.
Each application downloaded from the iTunes Store has
to be decrypted ﬁrst in memory before launching. Starting
from Android 4.1, all paid applications on Google Play
are encrypted with a device-speciﬁc key before they are
delivered and stored on an Android device.

Other features:

iOS uses a sandboxing policy and
Android uses UNIX UIDs to separate each individual ap-
plication. Both platforms provide the service of encrypting
users’ conﬁdential data, which could also be remotely erased
once the device is lost. In addition, both platforms have
kill switches in the hands of Google/Apple which can
be used to remove malicious applications from the users’

phones remotely. This feature limits the potential damage
of a malicious application by preventing it from spreading
widely. Finally, starting from Android 4.0 and iOS 4.3, both
platforms provide address space layout randomization to
help protect the systems and applications from exploitation
due to memory vulnerabilities.

From the general comparison we can see that both plat-
forms employ a number of common defense mechanisms,
but also have their own distinct features. Android’s privilege
notiﬁcation has some security advantage, but it pushes the
most important security checking work to its end users who
might not have expertise in security and may not even read
or understand those privileges listed during application in-
stallation [8]. On iOS, the approval process provides certain
degree of defense against malicious applications. However,
its capability is limited and can be bypassed sometimes [6].
Thus, a systematic comparison of the applications on these
two platforms is needed to fully understand the effectiveness
of these two different security architectures.

B. Comparison Framework Overview

To perform a fair comparison on security and privacy
provided by Android and iOS, we focus on comparing
the cross-platform applications on these two platforms. The
overview of our comparison framework is given in Figure 1,
and the rest of this paper is organized according to the
ﬂow of this comparison framework. Section III provides
the statistics of the cross-platform third-party applications
on both Android and iOS. Section IV then analyzes all
types of SS-APIs on Android and compares them with those
on iOS platform. The design and implementation of our
static analysis tools are presented in Section V. With the
SS-API mapping and static analysis tools on both Android
and iOS, we then perform our static analysis on the 1,300
pairs of applications selected, and the results are presented
and discussed in Section VI and Section VII. Finally, we
summarize related work in Section VIII and conclude the
paper in Section IX.

III. CROSS-PLATFORM APPLICATIONS

A. Preliminary Data Collection

In order to ﬁnd out what are the applications that exist on
both Android and iOS, we need to compare their detailed
information such as application name, developing company,
application description, etc. The application product pages
from Google Play and iTunes App Store do provide such
information, although public APIs of obtaining this infor-
mation do not exist. Thus, we build web crawlers for both
Google Play and iTunes Store, and collect detailed appli-
cation information for 312,171 Android applications and
478,819 iOS applications from April to May in 2012, which
are further analyzed to identify cross-platform applications.

Figure 1. Overview of the comparison framework.

B. Identifying Cross-platform Applications

We consider two applications (one on Android and the
other on iOS) to be two versions of the same cross-platform
application if they have the same set of functionality. For
example, both Android and iOS has a Facebook application
that provides the same functionality.

To be able to handle the large number of candidate cross-
platform applications, we ﬁrst develop an automatic tool to
ﬁnd the most likely candidates by comparing their names,
developer information, and the application descriptions (re-
fer to Appendix A for detailed discussion on the automatic
process). These candidates are categorized into ﬁve non-
overlapping sets according to the degree of similarity in
the three attributes, and we randomly select some candi-
date applications from each set and manually analyze the
functionality of them for veriﬁcation.

An interesting output of this analysis is that it enables us
to estimate the total number of cross-platform applications
on Android and iOS. Using the true positive rates obtained
from our manual veriﬁcation, we ﬁnd that 12:2% (about one
in eight) applications on Android have a replica application
on iOS.

C. Stratiﬁed Sampling

To minimize the propagation of errors from the identiﬁca-
tion of cross-platform application into subsequent analysis,
we focus our static analysis of cross-platform application
on the candidate set
that contains application pairs that
have exactly the same name and developer information as
well as a high degree of similarity in the descriptions.
This set provides a total number of 20,171 cross-platform
applications. The distribution of these applications among
different categories is given in Figure 2, which is compared

(Java reflection resolving, content providers, inheritance...)(App cracking, disassembling, _objc_msgSendresolving...)with the distribution of all applications on Android and iOS
in the entire data set collected. As shown in Figure 2, cross-
platform applications are more likely to appear in “Business”
and “Games” categories, and are less likely to appear in
“Books” or “Utilities”.

We choose to focus our work on Android 4.0 and iOS
5.0 which were both ofﬁcially released in October 2011.
Given the 122 application permissions supported on Android
4.0 [9], we ﬁrst ﬁnd out what is the exact privilege obtained
in each permission by examining the functionality of all
APIs related to this permission according to the mapping
of Android permission to API1 provided by [5]. We then
carefully investigate both online advisories and ofﬂine iOS
documentations on Xcode2 to ﬁnd out whether each privilege
available on Android is supported, and how it is supported
on the iOS platform. The overview of the analysis result is
given in Table II.

Table II

A CLASSIFICATION OF ANDROID APPLICATION PRIVILEGES
SS-API types

Group of Privileges

#*

Does not actually exist in Android

Already deprecated in Android, or no
Android API corresponds to it.

Reserved by Android system

Only for OEMs, not granted to third-
party apps. i.e., these privileges can only
be used by apps signed with system keys.

7

42

SET PREFERRED
APPLICATIONS
BRICK

DELETE CACHE
FILES
WRITE SECURE
SETTINGS

Figure 2. The distribution of the cross-platform apps vs. the distribution
of all third-party apps on Android and iOS.

Among these 20,171 cross-platform applications, we s-
elect 1,300 pairs (2,600 applications) to perform detailed
static analysis on the application executables. To improve
the representativeness of this sample set, we perform a
stratiﬁed sampling according to the category distribution of
these cross-platform applications. We then pick the most
popular free applications within each category. During the
sampling, we also exclude applications that only work on
tablets (e.g., iPad and Google Tablet) so that our analysis
could focus on applications that are mainly developed for
smartphones. Finally, we manually checked all the chosen
pairs of applications to ensure that
they are real cross-
platform applications. The results of the static analysis on
these selected applications will be presented in Section VI.

IV. COMPARING APPLICATION PRIVILEGES

To compare the security architecture of Android and iOS,
one of the most important comparison perspectives is to
ﬁnd out
the similarity and difference on restricting the
privileges for the third-party applications running on these
platforms. However, it is not clear how such privileges can
be compared as they might be of different granularity on
the two platforms, and a mapping of them between the two
platforms is not present in the literature. To make things
more complicated, although Google provides a comprehen-
sive list of application permissions for Android [9], there
is no ofﬁcial documentation specifying what privileges are
allowed for third-party applications on iOS – this is one of
the iOS mysteries to be revealed in our work.

Not supported on iOS

CHANGE
Either iOS does not have such device e.g.,
NETWORK STATE
removable storage; or iOS does not allow
MODIFY AUDIO
third-party apps to have such privilege.
SETTINGS
Both supported by iOS and Android
BLUETOOTH
Third-party apps have these privileges on
READ CONTACTS
iOS as default.
RECORD AUDIO
* This column lists the number of SS-API types [9] in each privilege group.

20

51

Although the term “permission” used on Android platform
is concise, it also implies that there is access control in the
architecture, which iOS barely has3. Thus, in the rest of the
paper, we use SS-API type to refer to a group of SS-APIs
that require the same privilege to access certain private data
or sensitive service. The name and scope for most of the SS-
API types follow the ofﬁcial Android permission list [9] with
three exceptions which will be explained in Section IV-C.
As shown in Table II, among all the Android SS-API type-
s, three of them (PERSISTENT ACTIVITY, RESTART PACKAGES
and SET PREFERRED APPLICATIONS) have deprecated, and
four of them (such as BRICK) do not really exist in Android,
as there are no API calls, content providers or intents in

1The mapping provided by [5] focuses on Android 2.2. We extend the
mapping by adding the 10 additional permissions supported on Android
4.0 with a similar method introduced in [5].

2Xcode is a suite of tools from Apple for developing software for Mac OS
X and iOS. It provides iOS API documentations for registered developers.
See http://developer.apple.com/xcode/.

3Security entitlements are introduced for iOS applications from iOS 5,
which are semantically similar to permissions. However, according to the
latest ofﬁcial document [10], the accessible entitlements for third-party iOS
developers only control iCloud storage and push notiﬁcation. Though ﬁne-
grained entitlements are available on OS X to control access of private data
such as address book and pictures, a third-party iOS application does not
need such entitlements to access these data.

Books&ReferenceBusinessEducationEntertainmentFinanceShopping&FoodGamesHealth&FitnessLifestyleMedicalMusicTravel&NavigationNewsPhoto&VideoProductivitySocialSportsUtilitiesWeatherOthers0%4%8%12%16%20%Cross-platformappsAllappsoniOSAllappsonAndroidAndroid related to these SS-API types [5]. The rest of the
SS-API types are then divided into three groups according
to our ﬁndings4.

A. Privileges reserved for Android system applications

The openness concept of Android and its online documen-
tations may have given a misleading understanding to users
and developers that a third-party Android application can
obtain any privilege. However, this is not true – many SS-
APIs are only provided for original equipment manufacturers
(OEMs), and are not granted to third-party applications.
Examples of these API types include DELETE CACHE FILES,
INSTALL LOCATION PROVIDER, FACTORY TEST, etc.

Since there are no ofﬁcial documentations specifying
which privileges are reserved for OEMs on Android, we
identify this list of SS-API types by analyzing the protection
level
tags in the frameworks/base/core/res/AndroidManifest.xml
ﬁle, as API types reserved for system applications are
labeled as android:protectionLevel=“signatureOrSystem” or an-
droid:protectionLevel=“signature” in this ﬁrmware conﬁguration
ﬁle. In order to validate this list, a testing application is
developed which tries to access all SS-APIs on Android, then
those SS-API types that are denied to this application are
recorded. Finally, 42 SS-API types are found to be reserved
for system applications on Android, which are not granted
to third-party applications unless users explicitly give them
the root privilege.

B. Privileges not supported on iOS

Among the rest of SS-API types which can be used
by Android third-party applications, we are interested in
ﬁnding out how many of them are also supported by iOS.
Surprisingly, our analysis result shows that more than 2/3
of these SS-API types are not supported on iOS. The
reasons are either because iOS does not have corresponding
functionality/device, or iOS just does not allow third-party
applications to have such privileges. Examples of SS-API
types which are not supported on iOS are given in Table III.
It is interesting to notice that iOS does not allow some
SS-API types to applications due to non-security reasons.
Although it is not ofﬁcially documented, APIs for changing
global settings that would affect the user experience (UX)
are usually disallowed by Apple, and that is one of the
reasons why there are still many people who jailbreak
their iPhones. Examples of such SS-API types include
MODIFY AUDIO SETTINGS, SET TIME ZONE, SET WALLPAPER,
WRITE SETTINGS, etc. Although this would limit the capabil-
ity of third-party applications, it is still reasonable from the

4The four groups of privileges listed in Table III are exclusive with
each other. There could be more reﬁned categorization in each group.
E.g., privileges that are reserved by Android system can be further divided
according to whether these privileges are supported on iOS. However, we
do not further divide each group in Table III, as the focus of this paper is
the privileges that are allowed to third-party applications and supported on
both Android and iOS, which is the last row in the table.

EXAMPLES OF UNSUPPORTED SS-API TYPES ON IOS

Table III

Reason (1) iOS does not have corresponding functionality/device:
SS-API type

MOUNT FORMAT
FILESYSTEMS

NFC

systems

Description
formatting
Allows
for
ﬁle
removable storage.
Allows applications
to perform I/O oper-
ations over NFC.

iOS Explanation
There is no removable
storage for iPhone,
i-
Pad, or iPod Touch.
Current iOS devices in-
cluding iPhone 5 still
do not have NFC chip.

Reason (2) iOS does not allow it to third-party applications:
SS-API type
KILL BACKGROUND
PROCESSES

Description
Allows an application to kill background
processes.
Allows an application to monitor, modify,
or abort outgoing calls.
Allows an application to monitor, record or
process incoming SMS messages.

PROCESS OUTGOING
CALLS

RECEIVE SMS

UX perspective. For example, it could be a disaster if you are
waiting for an important call, but a third-party application
mutes the sound globally without your awareness.

C. Privileges supported by both Android and iOS

The last group of privileges in Table II contains the SS-
API types supported on both Android and iOS. A compre-
hensive list of these SS-API types is given in Table IV.
Note that although there are only 20 SS-API types both
supported on Android and iOS, these SS-APIs cover the
access rights to the most common resources/services, includ-
ing user calendar, contacts, Bluetooth, Wi-Fi state, camera,
vibrator, etc. As shown in Table IV, due to the API difference
on Android and iOS, the name and scope of three SS-
API types have been changed compared to corresponding
Android permissions [9].

The ﬁrst reﬁned SS-API type is ACCESS LOCATION. On
Android, there are two permissions correspond to the priv-
ilege of accessing the location information, which are AC-
CESS COARSE LOCATION and ACCESS FINE LOCATION. There
are 20+ API calls related to these two permissions on
Android, but all of them only require either of the two
permissions. Similar as Android,
iOS devices employ a
number of different techniques for obtaining information
about the current geographical location, including GPS, cell
tower triangulation and most inaccurate Wi-Fi connections.
However, which mechanism is actually used by iOS to detect
the location information is transparent to the application
and the system will automatically use the most accurate
solution that
is available. Thus, for an iOS application
which invokes the location-related API calls (e.g., CLLoca-
tionManager.startUpdatingLocation), it actually requires both AC-
CESS COARSE LOCATION and ACCESS FINE LOCATION privi-
leges. Therefore, we create the ACCESS LOCATION SS-API
type as a common privilege between Android and iOS, in
order to perform a fair comparison.

SS-API TYPES SUPPORTED ON BOTH ANDROID AND IOS

Table IV

SS-API Type

Abbr. Description & Explanation

static analysis on both platforms in this section, and more
technical details are given in Appendix B.

type

to access

the
corresponds

location info.
Allows
This
to both AC-
CESS COARSE LOCATION and AC-
CESS FINE LOCATION in [9].
Allows to access information about net-
works. This SS-API type corresponds to
both ACCESS NETWORK STATE and
ACCESS WIFI STATE in [9].
Allows to collect battery statistics.
Allows to connect to bluetooth devices.
To discover and pair bluetooth devices.
Allows to initiate a phone call.

ACCESS LOCATION

LOC

ACCESS NETWORK
INFO

ANI

CWS

BATTERY STATS
BAT
BLUETOOTH
BLU
BLUETOOTH ADMIN BTA
PHO
CALL PHONE
CAMERA
CAM Allows to access the camera device.
CHANGE WIFI
MULTICAST STATE
FLASHLIGHT
INTERNET
READ CALENDAR
READ CONTACTS
READ DEVICE ID
RECORD AUDIO
SEND SMS
USE SIP
VIBRATE
WAKE LOCK
WRITE CALENDAR
WRITE CONTACTS

Allows applications to enter Wi-Fi Multi-
cast mode.
Allows access to the ﬂashlight.
Allows to open network sockets.
Allows to read the user’s calendar data.
Allows to read the user’s contacts data.
Allows to read the device ID.
Allows an application to record audio.
Allows to send SMS messages.
Allows an application to use SIP service.
Allows the access to the vibrator.
To disable auto-lock or screen-dimming.
Allows to write the user’s calendar data.
Allows to write the user’s contacts data.

FLA
INT
CAL
CON
RDI
RAU
SMS
SIP
VIB
WAK
CAL
CON

Similarly, Android provides APIs for checking the status
(e.g., availability or connectivity) of different network types
(e.g., WiFi or 3G). However, iOS APIs do not distinguish
the different network types when checking the reachability
of a given host or IP address. Thus, ACCESS NETWORK STATE
and ACCESS WIFI STATE are combined into a single SS-API
type – ACCESS NETWORK INFO to mitigate the bias when
comparing the SS-API usage on these two platforms.

The last reﬁned SS-API type is READ DEVICE ID. On
Android, the scope of READ PHONE STATE permission corre-
sponds to at least 18 Android API calls, which can be used
to read the device ID, phone number, SIM serial number
and some other information. However, on iOS, only device
ID is allowed to read since iOS 4.0. Other information is
forbidden to be accessed by third-party applications due to
security reasons. Thus, we create the READ DEVICE ID type
which only includes the SS-APIs on both platforms that
access the device ID. By obtaining the list of SS-API types
both supported on Android and iOS, we are now able to
analyze the usage differences of these SS-APIs in cross-
platform applications.

V. STATIC ANALYSIS TOOLS

To compare the SS-API usage for third-party applications
on Android and iOS, we build static analysis tools for both
Android applications (Dalvik bytecode) and iOS applications
(Objective-C executables). We explain the work ﬂow of the

A. Android Static Analysis Tool

list of SS-API types that

As introduced in Section II, each Android application
provides a list of privileges that is shown to the user during
installation, which is recorded in the AndroidManifest.xml in
each application package ﬁle. However,
the
this application actually
exact
accesses – many third-party applications are overprivileged
by requesting a superset of privileges [5]. Thus, the ultimate
goal of our Android static analysis tool
is to output a
minimum set of SS-API types that are accessed by the given
application. The work ﬂow of our Android tool is shown in
Figure 3.

this is not

Figure 3. The work ﬂow of our Android static analysis tool.

tool

As shown in Figure 3, for each Android application,
we ﬁrst obtain the corresponding Dalvik executable
(DEX), which is then disassembled into a set of .ddx
ﬁles using the Dedexer
[11]. With the extended
Android API call
to permission mapping [5], our tool
then performs multiple iterations on parsing and analyzing
the disassembled ﬁles to produce a candidate list of
SS-API types that this application accesses. However, this
candidate list is not a minimum set due to the ambiguity
in the Android API-to-permission mapping, which is
caused by Android’s permission validation mechanism. For
example,
android.app.ActivityManager.killBackgroundProcesses
API
or
KILL BACKGROUND PROCESSES – i.e., either permission
is sufﬁcient for the application to invoke this API call. In
order to further determine the exact privilege needed and
output a minimum set of SS-API types, our tool then takes
the intersection of the candidate list and the claimed list of
SS-API types (parsed from AndroidManifest.xml). The output
set of SS-API types is then used to compare with the set of
SS-API types used by the replica application on iOS.

RESTART PACKAGES

requires

either

call

There are several technical challenges in analyzing the
disassembled applications. On Android, SS-API calls may
be invoked with different class names due to inheritance.
By analyzing class information in the disassembled ﬁles,
our tool rebuilds the class hierarchy so that it can recognize
the API calls invoked from the applications’ own classes,
which are inherited from API classes. API calls may also be
invoked through Java reﬂection. Our tool performs backward
slicing [12] to resolve the method name and class name
actually invoked in each reﬂection instance – it traverses the
code backwards, resolving all instructions that inﬂuence the
method variable and class variable used in corresponding
reﬂection. We also apply speciﬁc heuristics to resolve inter-
procedural or inter-classes reﬂections. Although it is not
possible to completely resolve all reﬂections statically [13],
fortunately Android applications rarely use reﬂections ac-
cording to our observations, as reported in Appendix B.
Finally, SS-APIs may be accessed through content providers
and intents on Android. Our tool adopts the same mecha-
nisms as Stowaway [5] to recognize the invocation of content
providers and intents in the applications.

B. iOS Static Analysis Tool

Compared to Android, static analysis on iOS platform is
more challenging, as iOS is a closed-source architecture.
Apple tries to control all software executed on iOS devices
(iPhone, iPad and iPod Touch), which has several effects.
First of all, the only way for a non-jailbroken iOS device to
install third-party applications is through iTunes App Store.
When an application is downloaded via iTunes Store, it will
be encrypted and digitally signed by Apple. The decryption
key for the application is added to the device’s secure key
chain, so that each time this application is launched, it can
be decrypted and then start to run on the iOS device.

It is not possible to directly perform static analysis on
encrypted application binaries. Thus, before analyzing each
application downloaded from iTunes Store, we need to
obtain the decrypted application binary, which can only
be achieved on a jailbroken iOS device. Jailbreaking gives
us the capability to install the GNU Debugger, the Mach-
O disassembler oTool and also the OpenSSH server on
the device. These development tools enable us to crack
any installed application on the device. After obtaining the
decrypted iOS application binary, we utilize IDA Pro. [14]
to disassemble the binary to obtain assembly instructions.

However, IDA itself is only able to mark a very small por-
tion of Objective-C methods, especially when the symbols
are stripped in the binary. The underlying reason is that iOS
binaries are allowed to interchangeably use two instruction
sets, ARM and THUMB, which have different instruction
sizes and alignments. Without knowing the starting point of
a method, IDA may treat a code fragment as a data entry by

mistake. Thus, our analysis tool extracts metadata5 from the
application binary to guide IDA’s disassembling process.

After disassembling all methods in IDA, the next step
is to resolve all the API calls in the assembly instructions,
where the key step is to handle the objc msgSend function.
In an Objective-C executable, all accesses to a method or
attribute of an Objective-C object at runtime utilize this
objc msgSend function, which is used to send messages to an
instance of class in memory [15]. To statically determine the
corresponding API call for each observed objc msgSend, we
adopt the backward slicing and forward constant propagation
proposed by [16] in our iOS static analysis tool. The work
ﬂow of our iOS static analysis tool is illustrated in Figure 4.

Figure 4. The work ﬂow of our iOS static analysis tool.

The last step of our static analysis tool

is to output
the set of SS-API types used in an iOS application. The
access to most SS-API types can be directly recognized
through corresponding API classes and methods, for exam-
ple, user contacts are operated through ABPerson and ABAd-
dressBook related APIs. However, some SS-API types like
CALL PHONE and SEND SMS require further analysis of the
parameter value. For example, given an API call [[UIApplica-
tion sharedApplication] openURL:[NSURL URLWithString:[NSString
stringWithFormat:@“tel:123-456-7890”]]],
this will only launch
the phone dialer when the string parameter starts with “tel:”
preﬁx. The SS-API type SEND SMS, however, has two forms
of realizing the SMS functionality – the SMS sending view
can be triggered by openURL with “sms:” preﬁx; an applica-
tion can also call API such as MFMessageComposeViewCon-
troller.setMessageComposeDelegate to send SMS messages. We
carefully handle each of the cases for every resolved API call
and corresponding parameter values in order to detect such
SS-API invocations.

VI. COMPARISON ANALYSIS RESULTS

We applied our static analysis tools to the 1,300 pairs
of selected cross-platform applications (downloaded in June
2012), the basic statistics of these applications are given in
Table V. The direct outputs of our analysis tools are the

5These metadata extracted include the class names, the instance method
list, the class method list, the instance variable list, the property list and
the protocols that classes conform to. For each method, the method name,
method signature string, and the start address of the method body are
collected to guide IDA disassembling process.

lists of SS-API types accessed by these applications. By
obtaining such lists, we are then able to compare the SS-
API usage for each pair of cross-platform applications.

STATISTICS OF DOWNLOADED CROSS-PLATFORM APPLICATIONS

Table V

Parameters
Number of apps
App size range (.apk & .ipa)
Total size of apps
App executable ﬁle size range
(.dex & Objective-C binary)
Total size of executable ﬁles

Android apps
11KB(cid:24)47MB

1,300

7.42 GB

3KB(cid:24)6.2MB

iOS apps

1,300

106KB(cid:24)366MB

14.5 GB

25KB(cid:24)39.5MB

1.10 GB

5.03 GB

A. Comparisons on both-supported SS-API types

Our ﬁrst comparison focuses on the 20 SS-API types that
are both supported on Android and iOS. We are interested
in ﬁnding out how differently these SS-API types are used
on the two platforms for cross-platform applications. Our
results show that the total amount of SS-API types 6 that
are used by 1,300 Android applications is 4,582, which
indicates that each Android application uses 3.5 SS-API
types on average. In comparison, the corresponding 1,300
iOS applications access a total amount of 7,739 SS-API
types, which has on average 5.9 types per iOS application.
948 (73%) of the applications on iOS access additional SS-
API types compared to its Android version.

Among the 20 different SS-API types, some of them
are accessed almost equally by the applications on both
platforms. For example,
INTERNET is required by 1,247
Android applications, and 1,253 iOS applications. However,
some other SS-API types are used much more often by iOS
applications compared to Android applications. The top 10
SS-API types that are accessed more often on iOS compared
to Android are listed in Table VI.

To obtain a detailed understanding of the results provided
in Table VI, we look into typical applications in each SS-
API type. We ﬁnd out that famous applications such as
Twitter and XECurrency [17] do not access READ DEVICE ID
APIs on Android. However, on their corresponding iOS
version, we observe 5 locations in Twitter’s code and 6
locations in XECurrency’s code which read the device ID.
Another typical instance is the famous free game “Words
With Friends” [18] application. Compared to its Android
version, the additional SS-API types accessed by its iOS
version include (but are not limited to):

(cid:15) BATTERY STATS, as API call UIDevice.setBatteryMoni-

toringEnabled is observed;

(cid:15) CALL PHONE, as UIApplication.openURL with “tel:” param-
eter is observed in IMAdView.placeCallTo and two other
locations;

(cid:15) CAMERA, as UIImagePickerController.setSourceType with

argument value 0x1 (which is UIImagePickerCo-
ntrollerSourceTypeCamera) is observed in MobclixRich-
MediaWebAdView.takePhotoAndReturnToWebview;

(cid:15) FLASHLIGHT, as AVCaptureDevice.setTorchMode is ob-

served in MobclixRichMediaWebAdView.turnFlashlight-
OnWithSuccess; etc.

More interestingly, we also check the most popular game
application Angry Birds, although it does not belong to the
1,300 sampling set as it is not free on iOS. The result
shows that compared to its Android version, Angry Birds
on iOS additionally reads the user contacts data, as API
call ABAddressBookGetPersonWithRecordID and ABAddressBook-
CopyArrayOfAllPeople are observed in the code section of
CCPrivateSession.getArrayOfAddressBookEmailAddresses-
NamesAndContactIDs and four other locations7.

As shown in Table VI, our ﬁndings in the comparisons
on the 20 SS-API types both supported on Android and iOS
show that iOS third-party applications turn to access more
often to some devices (such as camera and vibration) and
are more likely to access sensitive data such as device ID,
user contacts and calendar. Thus, our next step of analysis
is to ﬁnd out the underlying reason why such phenomenon
exists. As one may notice from the examples given above,
some of these APIs are actually invoked by the third-party
libraries used in these applications (such as IMAdView and
MobclixRichMediaWebAdView classes in the WordsWithFriends
application). Thus, our next step is to analyze the SS-API
usage of the third-party libraries on both platforms.

B. SS-API Usage of Third-party Libraries

In order to analyze the SS-API usage of third-party
libraries, ﬁrst of all, we need to identify all
the third-
party libraries within each application. As there are no clear
boundaries that an included library or package in a given
application is written by the application developer or belongs
to a third-party library, we ﬁrst process the whole application
set to calculate the number of different package names (on
Android) or class names (on iOS). Then the packages or
classes that appear in more than 10 applications (and at
least belong to two different companies) are automatically
collected. We then manually check this list to identify the
third-party libraries, which include advertisement libraries,
analytic libraries or just third-party development libraries.
Some of the packages or classes are combined because
they belong to the same third-party library. Finally, we

6The set of SS-API types used by an application contains no duplicates,
which indicates that the maximum number of SS-API types used by each
application is 20. When calculating the total amount of SS-API types for
1300 applications, we simply sum the number of SS-API types used by
each application.

7The API calls which access user contacts have been observed in all
previous versions of Angry Birds including version 2.1.0, which was
released in March 2012. However, from Angry Birds version 2.2.0 (released
in August 2012), these API calls have been removed from this game, which
is probably due to the privacy changes of the newly released iOS 6.

SS-API TYPES WITH GREATEST DISPARITY THAT ARE ACCESSED BY THE APPLICATIONS ON ANDROID AND IOS.

Table VI

SS-API type

READ DEVICE ID
CAMERA
VIBRATE
ACCESS NETWORK INFO
READ CONTACTS
SEND SMS
WRITE CONTACTS
ACCESS LOCATION
RECORD AUDIO
READ CALENDAR

Number of
Android apps

Number of
iOS apps

510
172
374
885
151
29
86
553
37
35

925
601
522
1065
388
264
297
728
177
174

Only on
iOS1
469
435
290
269
256
248
219
217
155
141

Only on
Android

On both
platforms

54
6
142
89
19
13
8
42
15
2

456
166
232
796
132
16
78
511
22
33

Lib / App
Ratio2

60% / 64%
38% / 73%
62% / 46%
15% / 96%
52% / 75%
49% / 68%
51% / 80%
48% / 67%
35% / 99%
35% / 67%

Exclusive Lib / App

Ratio3

36% / 40%
27% / 62%
54% / 38%
4% / 86%
25% / 48%
32% / 51%
20% / 49%
33% / 53%
1% / 65%
33% / 65%

1 The number of cross-platform apps which access the corresponding SS-API type only in its iOS version, but not in its Android version. The value of this

column equals to the difference between “Number of iOS apps” and “On both platforms”.

2 A break-down for the sources of SS-API types: Lib – from third-party libs; App – from the app’s own code. The base of the ratio is column “Only on iOS”.
3 The ratio of applications in column “Only on iOS”, where the corresponding SS-API type is exclusively caused by third-party libraries or apps’ own code.

identiﬁed 79 third-party libraries on Android and 72 third-
party libraries on iOS that are commonly used. The 8 most
commonly used advertising and analytic libraries on Android
are listed in Table VII, and the 8 most common libraries on
iOS are listed in Table VIII.

these two tables clearly indicate that libraries on iOS turn
to access more SS-API types compared to Android third-
party libraries. Thus, the SS-API usage difference for those
cross-platform applications is indeed partially caused by the
difference of third-party libraries.

Table VII

App Ratio

MOST COMMON ADVERTISING/ANALYTIC LIBRARIES ON ANDROID
Library Name
com/google/ads
com/ﬂurry/android
com/google/android/apps/analytics
com/tapjoy
com/millennialmedia/android
com/admob/android/ads
com/adwhirl
com/mobclix/android/sdk
* The abbreviations of these SS-API types are given in Table IV.

SS-API types*
ANI, INT
LOC, INT
ANI
INT, RDI
ANI, INT, RDI
LOC, INT
LOC, INT
LOC, ANI, INT, RDI

21.7%
19.1%
12.5%
7.9%
7.3%
4.4%
3.8%
3.2%

MOST COMMON ADVERTISING/ANALYTIC LIBRARIES ON IOS

Table VIII

Library Name
Flurry
GoogleAds
Google Analytics
Millennial Media

TapJoy
AdMob
AdWhirl
Mobclix

App Ratio

19.9%
15.9%
9.8%
9.3%

9.1%
7.2%
6.9%
3.7%

SS-API types*
LOC, INT, RDI
ANI, INT, RDI, SMS, VIB, WAK
INT
LOC, ANI, CAM, INT, CON,
RDI, VIB
ANI, INT, RDI
LOC, INT, CON, RDI
LOC, ANI, INT, RDI
LOC, ANI, BAT, CAM, FLA, INT,
CAL, CON, RDI, SMS, VIB

* The abbreviations of these SS-API types are given in Table IV.

By tracking the code regions of these libraries, our static
analysis tools are able to determine the origin of the SS-API
calls in each application. We can then identify the types of
SS-APIs used in each third-party library on both platforms,
which are shown in Table VII and Table VIII. The data from

To quantify the inﬂuence of the third-party libraries on the
SS-API usage difference between the two versions of cross-
platform applications, for each SS-API type, we ﬁrst identify
those applications which access the corresponding SS-API
type only on its iOS version, but not on Android version
(which is the “Only on iOS” column in Table VI). For
each of these applications, we then track the origins in the
code which access the corresponding SS-APIs – either from
the third-party libraries used in the application, or from the
application’s own code. The results are shown in the last two
columns in Table VI. The two ratios in the “Lib/App Ratio”
column represent the percentage of the applications that: (a)
the third-party libraries used in the application access the
corresponding SS-API type; (b) the application’s own code
access the corresponding SS-API type. As can be seen from
the table, the sum of these two ratios is more than 100%.
This is because in some applications, SS-APIs belong to the
same type are used both in the application’s own code and
in the third-party libraries. Thus, the last column in Table VI
is given, which shows the percentage of applications, where
the corresponding SS-API type is only used by the third-
party libraries or application’s own code.

From the results shown in Table VI, we can see that the
third-party libraries do have certain impacts on the difference
of the SS-API usage for cross-platform applications. For
example, 54% applications which use additional VIBRATE
APIs on iOS is purely because of the third-party libraries
used in these applications. And from Table VIII we can ﬁnd
the exact source – libraries such as GoogleAds, Millennial
Media and Mobclix all use VIBRATE APIs. Thus, any ap-
plication which includes these libraries will in turn use this

SS-API type. Similar links can be drawn from Table VI and
Table VIII for other SS-API types such as READ DEVICE ID
and READ CONTACTS.

Comparing the data in Table VII and Table VIII, the
results show that the most commonly used third-party li-
braries, especially advertisement and analytic libraries on
iOS, access much more SS-APIs compared to the libraries on
Android. A likely explanation of this phenomenon could be
because on iOS, the SS-APIs can be accessed more stealthily
compared to on Android, where applications need to list out
the types of SS-APIs they need to access during installation.
The privileges to use these SS-APIs on iOS are granted to
third-party applications as default without users’ awareness,
which gives certain freedom for advertisement and analytic
libraries to access user data and sensitive resources.

To conﬁrm our ﬁndings on the third-party iOS libraries,
we further check each library listed in Table VIII to see
whether it is an open-source library. For the open-source
libraries (e.g., AdWhirl [19]), we manually look into their
source code and conﬁrm all SS-API types that are accessed.
For the closed-source library Flurry, we also ﬁnd evidences
that this library collects the device ID in its ofﬁcial doc-
umentation [20], which mentioned “Because Apple allows
the collection of UDID for the purpose of advertising, we
continue to collect this data as the Flurry SDK includes
AppCircle, Flurry’s mobile advertising solution.”

From the data given in the last column in Table VI,
one can observe that third-party libraries only contribute a
portion of the difference of the SS-API usage for cross-
platform applications; the other part of the difference is
caused by the application’s own code. By removing the SS-
API types that are exclusively caused by third-party libraries,
our static analysis tools manage to output the lists of SS-
API types that are caused by the applications’ own code
on both platforms. The comparison result shows that 3,851
SS-API types are used by 1,300 Android applications in
their own code, while iOS applications use 6,393 – there is
still a signiﬁcant difference for the SS-API usage on the two
platforms. This difference leads us to investigate further into
applications’ code logic to ﬁnd out the underlying reasons.

C. Microanalysis on Application Code Logic

In order to perform a manual analysis on the code logic of
the cross-platform applications, it will be ideal to have full
access to the application source code. However, applications
which are open-source on both platforms are very rare,
given the fact that iOS platform has very little open-source
applications. Nevertheless, we manage to ﬁnd 8 applications
that are open-source on both platforms8. We retrieve the
source code of these applications and analyze the underlying
reasons of their SS-API usage differences. The detailed API

8These 8 open-source applications are WordPress, Mixare, MobileOrg,
andRoc/iRoc, Mp3tunes, ZXing(Barcodes), DiceShaker and MobileSynth.

information collected from closed-source applications is also
utilized to assist
the analysis. According to our manual
inspection, there are at least two factors that have strong
correlations with the SS-API usage differences between iOS
and Android applications.

1) Coding difference: The most natural reason which may
be expected is the implementation difference between the
two versions of cross-platform applications. For example,
ACCESS NETWORK INFO APIs are only used by the iOS ver-
sion of WordPress, but not by its Android version. In its iOS
version, several API calls in WPReachability class are invoked,
which are used to test the reachability to the WordPress
hosts. However, for the Android version of WordPress, there
is no code for testing any reachability. For example, when
posting a blog to the server, the code of Android WordPress
simply checks the return value of the posting function to
see whether the connection is successful or failed. But on
iOS, many Objective-C classes in the WordPress code will
actively check the reachability beforehand, and notify the
users if the network is not reachable. Such implementation
difference leads to the SS-API usage difference that Word-
Press on iOS uses the additional ACCESS NETWORK INFO
APIs compared to its Android version. Similar evidence can
be found in the source code of MobileOrg application.

Such coding difference is also the main reason causing the
difference in using the CAMERA SS-APIs. Taking the popular
applications such as eBuddyMessenger and SmackIt, in their
iOS versions, the user proﬁle photo in the setting can either
be chosen from the pictures stored on device, or by directly
taking the photo with the device’s camera. However, their
Android versions do not provide such photo taking option.
Note that such implementation difference does not only exist
in the applications’ own code, but also for the same third-
party libraries on two platforms. For example, CAMERA SS-
APIs are used by OpenFeint library on iOS, but not by
its Android version, which is caused by the same reason
mentioned above.

2) Intentional avoidance: On the other hand, we also ﬁnd
evidences that even the functionality of the two versions of
cross-platform application are the same, some SS-APIs are
intentionally avoided to be used on Android. We use open-
source application WordPress to explain this phenomenon.
Compared to its Android version, WordPress on iOS uses
the additional READ DEVICE ID APIs. In the WordPress iOS
code, runStats method of WordPressAppDelegate reads the uuid,
os version, app version, language, device model, and then sends
them to http://api.wordpress.org/iphoneapp/update-check/1.0/
to
check whether this application needs to be updated. On the
Android platform, the code of WordPress performs the same
functionality – in the wpAndroid class, uploadStats method tries
to retrieve the same set of data and sends these data back
to WordPress server to check for update. However, there is
one major difference for the WordPress code on Android
compared to the code on iOS. In its iOS code, the uuid is

retrieved by directly calling UIDevice.uniqueIdentiﬁer, which
returns the device unique ID. In contrast, for its Android
version, the uuid used is a random ID which is unique, but
not the real device ID. It is a unique ID that is randomly
generated and stored as the ﬁrst record in WordPress’s own
SQLite database on the Android device. Thus, the different
way of obtaining uuid is the reason that WordPress on iOS
uses the additional READ DEVICE ID SS-API type.

The special way of obtaining the uuid in the Android
version of WordPress makes us speculate that the program-
mers intentionally try to avoid using the READ DEVICE ID
APIs on Android. This is further conﬁrmed by consulting
one of the WordPress developers, who gives the explanation
as: “a random id is better than the device id because it
doesn’t require that permission which reads quite poorly as
‘read phone state and identity’ ”. Thus, the reason that the
developers do not try to avoid using the device ID on iOS
is because of the same reason mentioned in Section VI-B
– on Android, an application needs to show the list of SS-
API types it needs to access to the user during installation;
while on iOS, no such notiﬁcation is given to the user.
We suspect that this may also be the main reason which
causes the difference in accessing SS-API types such as
READ CONTACTS and READ CALENDAR. But unfortunately,
due to the limited access to applications’ source code, we are
not able to get the ground-truth evidence for these SS-API
types, as what has been done for the READ DEVICE ID.

D. The Usage of SS-API Types Unsupported on iOS

Previous analyses focus on the 20 SS-API types that are
both supported on Android and iOS, without taking into
account of the additional 51 SS-API types that are only
supported on Android platform. Thus, the last step of our
analysis is to ﬁnd out how frequently these SS-APIs are
used by those Android applications, and what are usage
characteristics of these SS-APIs.

Taking into account of the 51 SS-API types, our results
show that the 1,300 Android applications use 1,230 SS-API
types in total which are unsupported on iOS. As shown in
Table IX, the most frequently accessed SS-API type that is
unsupported on iOS is WRITE EXTERNAL STORAGE, which is
used by more than half of the Android applications. This can
be explained from the nature of Android devices. Different
from iOS devices which have 8GBytes to 64GBytes of
internal storage, Android devices usually have less internal
storage. Thus, all Android devices support external storage
such as microSD card. As a result, Android applications
which want
to store their application data usually need
to utilize WRITE EXTERNAL STORAGE APIs to write to the
microSD card, in order to save the internal storage space.

Except WRITE EXTERNAL STORAGE, the remaining 50 SS-
API types that are not supported on iOS are used infre-
quently (only 468 in total, which is 0.36 per application on
average). Such a result shows that the 20 SS-API types both

THE USAGE OF SS-API TYPES UNSUPPORTED ON IOS (TOP 8)

Table IX

SS-API types unsupported on iOS
WRITE EXTERNAL STORAGE
GET ACCOUNTS
RECEIVE BOOT COMPLETED
GET TASKS
CHANGE WIFI STATE
READ LOGS
RECEIVE SMS
READ HISTORY BOOKMARKS

# of Android Apps

762
133
55
45
44
15
13
11

supported on iOS and Android are the most commonly used
SS-APIs for third-party applications. Note that although the
SS-API types only supported on Android are not commonly
used in popular Android applications, they may bring serious
security breaches when utilized by malicious applications.
For example, the READ LOGS privilege, which allows a third-
party application to “read the low-level system log ﬁles” can
be utilized to read many other sensitive data such as SMS,
contacts and location information as demonstrated in [21].
On the other hand, iOS also has its own speciﬁc SS-APIs
that do not exist on Android. For example, two services,
iCloud storage and push notiﬁcation, which are controlled by
entitlements are speciﬁc to the iOS platform. However, since
the focus of this paper is on the SS-API types supported
on both platforms, investigating the SS-APIs that are only
supported on iOS is left as future work.

VII. DISCUSSION AND LIMITATIONS

We remark that our comparison analysis framework is
still in its preliminary stage. One limitation of the current
framework is the completeness of iOS SS-APIs. Although
we tried our best to search for all the related API calls on iOS
that lead to a corresponding SS-API type, it is very difﬁcult
to test the thoroughness of the obtained SS-API set. We
may still miss some API calls that belong to certain SS-API
types. However, this limitation only indicates that the list of
SS-API types for a given iOS application produced by our
static analysis tool is a lower bound on the actual list of SS-
API types this application uses. Even the number of SS-API
types used by iOS applications might be underestimated, it
is still much larger than the number of SS-API types used
by Android applications. Thus, this limitation will not affect
the conclusion drawn from our analysis.

Another limitation that has not been addressed during the
analysis is the dead code issue – though some SS-APIs exist
in the application binaries, they may not be executed during
run-time. Detecting unreachable code statically involves
performing complex control ﬂow analysis to locate the code
regions that will never be executed, which has not been
adopted in our static analysis tools. However, even some
SS-API calls in the binaries will not be executed, they may
still bring potential security risks (e.g., they can be utilized

by return-to-libc or return-oriented programming [22], [23]
to launch attacks).

An important assumption is used in our analysis when
comparing iOS version and Android version of the cross-
platform applications. We assume these two versions should
ask for similar privileges and should have similar func-
tionality. There could be cases that
the developers ﬁrst
implemented a full-functioned version on one platform and
are just in the process of integrating new functionality into
the version on the other platform. However, we believe
that this assumption holds when it is considered in a large
scale context. But as the whole analysis process is not
fully automated (the application downloading and cracking
is a half-manual process), and also due to the relatively
slow speed for iOS application analysis (which takes several
minutes to several hours for each application depending on
the complexity of the binary), we limit our current analysis
to those 2,600 applications instead of the entire set of
cross-platform applications. In addition, as a complement
to the comparisons conducted on free applications, we also
perform the analysis on 200 popular paid applications.
The results are given in Appendix C, which are consistent
with our main ﬁndings on free applications. Note that our
sampling towards popular applications (both free and paid)
may introduce bias if the results are used as an estimation on
the whole third-party applications. However, due to limited
resources, this work focuses on popular applications, which
have more impact on the privacy of end-users.

In order to examine the accuracy of our ﬁndings, ground
truth needs to be obtained for every application tested,
which is an impossible task without the application’s source
code. However, we tried our best to discover the under-
lying ground truth by investigating the visible differences
on closed-source applications and libraries; by obtaining
and examining the source code of available open-source
applications; and by consulting some application developers
on our ﬁndings. Although it is not possible to verify the
result of every cross-platform application, we believe that
the statistical difference in our ﬁndings has revealed the
tendency of iOS third-party applications which turn to access
more SS-APIs compared to applications on Android.

The immediate implication of such ﬁndings is that user-
s on iOS may have higher risks of privacy leakage in
comparison to Android. However, the occurrence of the
actual privacy leakage for a particular user depends on many
factors, including which applications this user installs, and
whether the applications or libraries send the private data out
at runtime. Thus, our ﬁndings do not necessarily imply that
Android has a better privacy protection compared to iOS,
given the fact that iOS restricts certain privileges to third-
party applications (as shown in Section IV) and also previ-
ous research works [24], [25] have shown that third-party
applications on Android could gain additional privileges by
launching privilege-escalation attacks. However, our ﬁndings

have shown a strong correlation between the SS-API usage
difference and the lack of an explicit privilege-list mech-
anism on iOS, which implies that Apple’s vetting process
may not be as effective as Android’s privilege notiﬁcation
mechanism, particularly in the aspect of restricting SS-API
usage by application developers.

VIII. RELATED WORK

Previous studies focus on either Android or iOS platform
alone. Enck et al. [26] examine Android security policies
and some of the developer pitfalls. They further investigate
the source code of a thousand Android applications [27],
which reveals a number of interesting ﬁndings for Android
application security, some of which are also conﬁrmed
by our results on Android. A large-scale evaluation for
Android applications is performed by Zhou et al. [28], which
reveals hundreds of malicious Android applications. Yan and
Yin [29] provide analysis tools to reconstruct the OS and
Dalvik semantics for malware analysis.

From the attacker’s perspective, Felt et al. [24] demon-
strate that a less privileged Android application is able
to perform a privileged task through another third-party
application with higher privilege. A similar privilege es-
calation attack which is implemented with return-oriented
programming is introduced by Davi et al. [23]. The defense
mechanism for such privilege escalation attack is proposed
by Bugiel et al. [25].

There are also a number of research works focusing on
analyzing and improving the Android permission model.
Barrera et al. [30] present a methodology for the empirical
analysis of permission-based security models, and apply
it to Android permission model. In addition, Ongtang et
al. [31] present a ﬁne-grained access control policy infras-
tructure for protecting applications on Android. Hornyack
et al. [32] also present two privacy controls to protect user
data from exﬁltration by permission-hungry applications.
Grace et al. [33] systematically analyze several Android
smartphone images and found they do not properly enforce
the Android permission model. Xu et al. [34] propose a user-
level sandbox to enforce ﬂexible permission control without
modifying the Android OS. Shekhar et al. [35] and Pearce
et al. [36] provide speciﬁc techniques to separate permission
usage of advertising libraries and hosting applications.

Felt et al. [5] study Android applications to determine
whether Android developers follow least privilege with their
permission requests. They developed a static analysis tool
Stowaway that detects overprivilege in Android applications.
They also create an Android API-to-permission mapping
using dynamic testing, and this mapping is used as one of
the inputs in our Android static analysis tool. This mapping
could also be used in the permission check tool introduced
by Vidas et al. [37], which aids developers in specifying a
minimum set of permissions required for a given Android
application with source code.

In comparison to the literature on Android,

TaintDroid developed by Enck et al. [38] provides a
system-wide dynamic taint tracking for Android, which can
be used to monitor the realtime behavior of third-party
Android applications. On the other hand, static analysis
tools such as ScanDroid [39] and ComDroid [40] are also
developed to identify Android application vulnerabilities,
with additional consideration on action-based vulnerabilities.
there are
relatively less studies on iOS platform. Seriot [41] demon-
strated that any applications downloaded from iTunes Store
can access a signiﬁcant quantity of personal data. Egele
et al. [16] study the privacy threats that third-party iOS
applications pose to users. They present a static analysis tool
that analyzes programs for possible sensitive information
leakage. Our iOS static analysis tool adopts a similar mech-
anism in resolving objc msgSend as their tool, but with a
different emphasis on resolving the API calls and parameters
that are related to SS-APIs.

To our best knowledge, there is no literature to date that
systematically compares the application security of Android
and iOS platforms. This paper is the ﬁrst work that estab-
lishes the baseline of examining the massive cross-platform
applications to compare the effect of security mechanism
utilized by Android and iOS, which reveals interesting
behavioral differences for the third-party applications on
these two platforms. We notice that a recent work by
Pearce et al. [36] also identiﬁes the overprivileging problem
caused by advertising libraries on Android platform. Our
work further discovers this problem on iOS platform and
ﬁnds that an iOS application tends to use more SS-APIs
compared to its Android counterpart even after excluding
SS-API invocations by advertising libraries, which has not
been investigated in existing works.

IX. CONCLUSION

In this paper, we made the ﬁrst attempt towards system-
atically comparing mobile application security on diverse
mobile platforms. In particular, the two most popular mobile
platforms, Android and iOS, are chosen to investigate how
the platform difference inﬂuences third-party applications in
terms of privacy protection. As a prerequisite, we investigat-
ed the security-sensitive API (SS-API) types supported on
iOS and their relations to Android application privileges,
which were previously unclear. We then built our static
analysis tools to perform massive static analysis for cross-
platform applications on their SS-API usage.

Our analysis showed that applications on iOS tend to use
more SS-APIs compared to their counterparts on Android,
and are more likely to access sensitive resources that may
cause privacy breaches or security risks without being no-
ticed. Further investigation revealed a strong correlation be-
tween such difference and the lack of application privilege-
list on the current iOS platform. Such results may imply
that Apple’s vetting process is not as effective as Android’s

explicit privilege list mechanism in restricting the privilege
usage by third-party application developers.

REFERENCES
[1] “Trend Micro: Android much

[2] “Why

than
iPhone,”
http:
//www.electronista.com/articles/11/01/11/trend.micro.warns.
android.inherently.vulnerable/.

electronista News,

less
January

secure
2011.

Android

App

Security

Better
PCWorld News. August

Is

the

iPhone,”

for
http://www.pcworld.com/businesscenter/article/202758/why
android app security is better than for the iphone.html.
security different but matched,”

c-
NET News, July 2010. http://news.cnet.com/8301-27080
3-20009362-245.html.

iPhone

Than
2010.

[3] “Android,

[4] “Smartphone Security Smackdown: iPhone vs. Android,” In-
formationWeek, July 2011. http://www.informationweek.com/
news/security/mobile/231000953.

[5] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner,
the
“Android permissions demystiﬁed,” in Proceedings of
18th ACM conference on Computer and communications
security, 2011, pp. 627–638.

[6] C. Sorrel,

“Apple Approves, Pulls Flashlight App
2010.

with Hidden Tethering Mode,” Wired.
http://www.wired.com/gadgetlab/2010/07/apple-approves-
pulls-ﬂashlight-app-with-hidden-tethering-mode.

July,

[7] H. Lockheimer, “Android and Security,” Google Mobile
Blog, Feb 02, 2012. http://googlemobile.blogspot.com/2012/
02/android-and-security.html.

[8] A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wag-
ner, “Android permissions: User attention, comprehension,
and behavior,” in Proceedings of the Symposium on Usable
Privacy and Security (SOUPS), 2012.

[9] Android API level 14, Manifest.permission, http://developer.

android.com/reference/android/Manifest.permission.html.

[10] “Apple, Entitlement Key Reference,” http://developer.apple.

com/library/mac/#documentation/Miscellaneous/Reference/
EntitlementKeyReference/Chapters/AboutEntitlements.html.

[11] G. Paller, Dedexer, http://dedexer.sourceforge.net/.
[12] M. Weiser, “Program slicing,” in Proceedings of

the 5th

international conference on Software engineering, 1981.

[13] J. Sawin and A. Rountev, “Improving static resolution of
dynamic class loading in java using dynamically gathered
environment information,” Automated Software Engineering,
vol. 16, pp. 357–381, June 2009.

[14] “IDApro, a multi-processor disassembler and debugger,” Hex-

Rays, http://www.hex-rays.com/products/ida/index.shtml.

[15] Nemo, “The Objective-C Runtime: Understanding and Abus-
ing,” phrack, Volume 4, Issue 66, http://www.phrack.org/
issues.html?issue=66&id=4.

[16] M. Egele, C. Kruegel, E. Kirda, and G. Vigna, “PiOS:
Detecting Privacy Leaks in iOS Applications,” in Proceedings
of the Network and Distributed System Security Symposium
(NDSS), San Diego, CA, February 2011.

[17] XE

[18] Words With

Currency

http://itunes.apple.com/app/
xe-currency/id315241195, XE Currency on Android: https:
//play.google.com/store/apps/details?id=com.xe.currency.

iOS:

on

Friends

http:
//itunes.apple.com/app/words-with-friends-free/id321916506,
Android version: https://play.google.com/store/apps/details?
id=com.zynga.words.

version:

Free,

iOS

[19] AdWhirl Developer’s Resources, https://www.adwhirl.com/

home/dev.

[20] Flurry Product Updates, http://blog.ﬂurry.com/updates/bid/
33715/New-Flurry-SDK-Available-for-iPhone-OS-4-0-iOS.
[21] A. Lineberry, D. L. Richardson, and T. Wyatt, These Are Not
the Permissions You Are Looking For, Def Con 18 Hacking
Conference, 2010.

[22] H. Shacham, “The geometry of innocent ﬂesh on the bone:
return-into-libc without function calls (on the x86),” in Pro-
ceedings of
the 14th ACM conference on Computer and
communications security, 2007, pp. 552–561.

[23] L. Davi, A. Dmitrienko, A.-R. Sadeghi, and M. Winandy,
“Privilege escalation attacks on android,” in Proceedings of
the 13th international conference on Information security,
2011, pp. 346–360.

[24] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin,
“Permission re-delegation: attacks and defenses,” in Proceed-
ings of the 20th USENIX conference on Security, 2011.

[25] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi,
and B. Shastry, “Towards taming privilege-escalation attacks
on android,” in 19th Annual Network & Distributed System
Security Symposium, Feb 2012.

[26] W. Enck, M. Ongtang, and P. McDaniel, “Understanding

android security,” IEEE Security and Privacy, 2009.

[27] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri, “A study
of android application security,” in Proceedings of the 20th
USENIX Security Symposium, 2011.

[28] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, you,
get off of my market: Detecting malicious apps in ofﬁcial
and alternative android markets,” in 19th Annual Network &
Distributed System Security Symposium (NDSS), Feb 2012.
[29] L.-K. Yan and H. Yin, “Droidscope: Seamlessly reconstruct-
ing the os and dalvik semantic views for dynamic android
malware analysis,” in Proceedings of the 21st USENIX Secu-
rity Symposium, 2012.

[30] D. Barrera, H. G. u. c. Kayacik, P. C. van Oorschot,
and A. Somayaji, “A methodology for empirical analysis
of permission-based security models and its application to
android,” in Proceedings of the 17th ACM conference on
Computer and communications security, 2010, pp. 73–84.

[31] M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel,
“Semantically rich application-centric security in android,” in
Proceedings of the Annual Computer Security Applications
Conference, 2009, pp. 340–349.

[32] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wether-
all, “These aren’t the droids you’re looking for: retroﬁtting
android to protect data from imperious applications,” in
Proceedings of the 18th ACM conference on computer and
communications security, 2011, pp. 639–652.

[33] M. Grace, Y. Zhou, Z. Wang, and X. Jiang, “Systematic detec-
tion of capability leaks in stock android smartphones,” in 19th
Annual Network & Distributed System Security Symposium,
Feb 2012.

[34] R. Xu, H. Saidi, and R. Anderson, “Aurasium: Practical policy
enforcement for android applications,” in Proceedings of the
21st USENIX Security Symposium, 2012.

[35] S. Shekhar, M. Dietz, and D. S. Wallach, “Adsplit: Separating
smartphone advertising from applications,” in Proceedings of
the 21st USENIX Security Symposium, 2012.

[36] P. Pearce, A. P. Felt, G. Nunez, and D. Wagner, “Addroid:
Privilege separation for applications and advertisers in an-
droid,” in Proceedings of 7th ACM Symposium on Informa-
tion, Computer and Communications Security, 2012.

[37] T. Vidas, N. Christin, and L. Cranor., “Curbing Android
permission creep,” in Proceedings of the Web 2.0 Security
and Privacy 2011 workshop, May 2011.

[38] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. M-
cDaniel, and A. N. Sheth, “Taintdroid: an information-ﬂow
tracking system for realtime privacy monitoring on smart-
phones,” in Proceedings of the 9th USENIX conference on
operating systems design and implementation, 2010.

[39] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “Scandroid:
Automated security certiﬁcation of android applications.”
University of Maryland, Tech. Rep., 2009.

[40] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyz-
ing inter-application communication in android,” in Proceed-
ings of the 9th international conference on Mobile systems,
applications, and services, 2011, pp. 239–252.

[41] N. Seriot, “iPhone Privacy,” BlackHat Technical Security
Conference DC, 2010, http://seriot.ch/resources/talks papers/
iPhonePrivacy.pdf.

[42] G. Salton, A. Wong, and C. S. Yang, “A vector space
model for automatic indexing,” Communications of the ACM,
vol. 18, pp. 613–620, November 1975.

[43] V. Levenshtein, “Binary Codes Capable of Correcting Dele-
tions, Insertions and Reversals,” Soviet Physics Doklady,
vol. 10, p. 707, 1966.

APPENDIX A.

t

(cid:2)

∑

t
i=1 w2
i;1

√∑

CROSS-PLATFORM APPLICATIONS IN CANDIDATE SETS
As shown in Table X, the conditions of selecting appli-
cations in each candidate set depend on the similarity of
three attributes: application name, developing company and
application description. We use Vector Space Model [42],
one of the classical models in information retrieval, to com-
pare the descriptions. The similarity between two application
descriptions is calculated using:

√∑
i=1 wi;1 (cid:2) wi;2

d2
d2j =

(cid:0)!
d1 and

(cid:0)!
d1 (cid:1) (cid:0)!
j(cid:0)!
d1j (cid:2) j(cid:0)!
sim(d1; d2) =
(cid:0)!
where
d2 denote the descriptions of two applications
(one on Android, and the other one on iOS), after removing
stop words, pure numbers and HTML tags (such as <br>,
<p>) from the descriptions. wi;j is the weighting for the ith
term in description dj which is assigned with the frequency
of the term. The threshold for the high/low similarity score
is set to 0:45 by manual tuning to obtain a good trade-off
between the number of false positives and false negatives.
The similarity of the application names (as used in the
rule of candidate set CS4) is measured with Levenshtein
Distance [43], as names are usually short string which
contains only a few characters. One example for the cross-
platform applications with similar names is ActDroid on
Android and ActPhone on iOS – their name distance is 4
and their description similarity is 0.56.

t
i=1 w2
i;2

We apply the corresponding rules to the entire application
data set collected, and the number of application pairs in
each candidate set is shown in Table X. The percentage
shown in the table is calculated based on the total number
of Android applications collected, which is 312,171. After
obtaining those candidate sets, we then randomly choose 60
application pairs in each set to perform a manual validation –

App Candidate Set

CANDIDATE SETS FOR CROSS-PLATFORM APPLICATIONS: CONDITIONS AND STATISTICAL RESULTS
Percentage

Unique App Pairs

Table X

Conditions*
same appName, same Company, high similarity Description
same appName, same Company, low similarity Description
same appName, diff Company, high similarity Description
similar appName, same Company, high similarity Description
same appName, diff Company, low similarity Description

20,171
2,230
8,870
10,837
14,046

6:46%

0:71%

2:84%

3:47%

4:50%

True Positive Rate

t 100%
> 98:3%

83:3%

68:3%

6:67%

* The high/low similarity threshold for Description is set to 0.45, and the edit distance threshold for similar appName is set to (cid:20) 5.

CS1
CS2
CS3
CS4
CS5

we manually read the descriptions of these two applications,
examine their companies, icons and screenshots to judge
whether they are actually cross-platform applications. Dur-
ing our manual veriﬁcation, no false positives are found in
the CS1 set, but one false positive is found in the CS2 set
which is caused by parsing error of non-unicode characters.
∑
The results presented in Table X enable us to estimate the
total amount of cross-platform applications exist on both An-
i PercentCSi(cid:2)TPRCSi,
droid and iOS. Applying formula
where i 2 f1; 2; :::5g, and TPRCSi
is the true positive
rate of the corresponding candidate set, we get the result
12:2%. This indicates that, among those existing third-party
applications on Android, approximately 1/8 of them have a
replica application provided for iOS.
APPENDIX B.

API RESOLVING RATE OF ANALYSIS TOOLS

On the Android platform, Java reﬂection is found to
be commonly used [5], which is also conﬁrmed by our
observation. Among the 1,300 Android applications being
tested, we found that 951 (73%) use Java reﬂections to
make API calls. However, the absolute number of reﬂections
invoked is only 9,943, which means each application only
make 7.6 reﬂection calls on average. This is a small amount
(0.07%) compared to 10,778 API calls made by each ap-
plication on average. Among all the reﬂections observed,
our Android static analysis tool is able to resolve 7,859
(79%) reﬂections. This indicates that out of thousands of
API calls issued per application, only 1.6 API calls are
not resolved on average. Our tool failed to resolve the
reﬂection call if the method name or class name is not
generated statically. For example, some reﬂections invoke
java.lang.Class.getDeclaredMethods with no parameters which
simply return an array of methods, and then according to
some dynamic rules, the code will pick one of the methods
to invoke. Cases like this are very difﬁcult to be resolved in
a static manner [13], which is one of the limitations in our
current implementation.

When applying our static analysis tool

to the 1,300
iOS applications, we ﬁnd that on average, 16.63% of the
instructions in each application belong to C/C++ code and
83.12% instructions belong to Objective-C code; while the
rest 0.25% are dummy instructions or the instructions that

our tool is unable to interpret. Our tool is able to capture all
the invocations for the API calls that are invoked through
C/C++ functions; while for the API calls in the disassembled
Objective-C code, our tool is able to resolve 89.7% of the
objc msgSend encountered. There are at least two cases
where a given objc msgSend cannot be resolved. 1) The
corresponding class instance is passed from the runtime as
an argument of a callback function. 2) The class instance is
retrieved from a collection object such as an array that can
hold any types of objects. Such a limitation also exists in
other static analysis tools on iOS platform [16]. Although
not all objc msgSend methods are able to be resolved, it only
has quite limited inﬂuence in our experiments. The reason
is that a number of API invocations for the same SS-API
type are usually observed in an application, so that missing
a small portion of API calls will not make our tool overlook
the corresponding SS-API type in most cases.

APPENDIX C.

ANALYSIS RESULTS OF PAID APPLICATIONS

We performed the analysis on the most popular 100 pairs
of paid cross-platform applications. For the 20 different SS-
API types that are both supported on iOS and Android, the
results show that the 100 paid applications on Android use a
total amount of 297 SS-API types; while the corresponding
100 paid applications on iOS use 508 SS-API types. 79 of
the iOS applications use additional SS-API types compared
to its Android version. These results are consistent with our
main ﬁndings on popular free applications. Although paid
applications contain less advertising libraries, our results
show that the applications’ own code contributes more to
the difference in the SS-API usage, as shown in Table XI.

TOP 5 SS-API TYPES THAT ARE ACCESSED DIFFERENTLY BY PAID

Table XI

apps

APPLICATIONS.
iOS
Android
apps
51
79
68
35
79

9
41
38
12
56

Only
iOS
41
40
38
32
26

Exclusive

Lib/App Ratio

14% / 64%
12% / 53%
0% / 100%
63% / 32%
2% / 97%

SS-API type

CAMERA
READ DEVICE ID
WAKE LOCK
ACCESS LOCATION
ACCESS NETWORK INFO

