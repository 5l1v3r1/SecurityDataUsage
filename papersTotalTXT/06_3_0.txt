On Implementing Deniable Storage Encryption for Mobile Devices

Adam Skillen and Mohammad Mannan

Concordia Institute for Information Systems Engineering

Concordia University, Montreal, Canada
{a skil, mmannan}@ciise.concordia.ca

Abstract

Data conﬁdentiality can be effectively preserved through
encryption.
In certain situations, this is inadequate, as
users may be coerced into disclosing their decryption keys.
In this case, the data must be hidden so that its very exis-
tence can be denied. Steganographic techniques and deni-
able encryption algorithms have been devised to address
this speciﬁc problem. Given the recent proliferation of
smartphones and tablets, we examine the feasibility and ef-
ﬁcacy of deniable storage encryption for mobile devices.
We evaluate existing, and discover new, challenges that can
compromise plausibly deniable encryption (PDE) in a mo-
bile environment. To address these obstacles, we design a
system called Mobiﬂage that enables PDE on mobile de-
vices by hiding encrypted volumes within random data on
a device’s external storage. We leverage lessons learned
from known issues in deniable encryption in the desktop
environment, and design new countermeasures for threats
speciﬁc to mobile systems. Key features of Mobiﬂage in-
clude: deniable ﬁle systems with limited impact on through-
put; efﬁcient storage use with no data expansion; and re-
striction/prevention of known sources of leakage and dis-
closure. We provide a proof-of-concept implementation for
the Android OS to assess the feasibility and performance of
Mobiﬂage. We also compile a list of best practices users
should follow to restrict other known forms of leakage and
collusion that may compromise deniability.

1 Introduction and Motivation

Smartphones and other mobile computing devices are
being widely adopted globally. For instance, according to a
comScore report [7], there are more than 119 million smart-
phone users in the USA alone, as of Nov. 2012. With this
increased use, the amount of personal/corporate data stored
in mobile devices has also increased. Due to the sensitive
nature of (some of) this data, all major mobile OS man-
ufacturers now include some level of storage encryption.

Some vendors use ﬁle based encryption, such as Apple’s
iOS, while others implement “full disk encryption” (FDE).
Google introduced FDE in Android 3.0 (for tablets only);
FDE is now available for all Android 4.x devices, including
tablets and smartphones.

While Android FDE is a step forward, it lacks deniable
encryption—a critical feature in some situations, e.g., when
users want to provide a decoy key in a plausible manner,
if they are coerced to give up decryption keys. Plausibly
deniable encryption (PDE) was ﬁrst explored by Canetti et
al. [6] for parties communicating over a network. As it ap-
plies to storage encryption, PDE can be simpliﬁed as fol-
lows: different reasonable and innocuous plaintexts may be
output from a given ciphertext, when decrypted under dif-
ferent decoy keys. The original plaintext can be recovered
by decrypting with the true key. In the event that a cipher-
text is intercepted, and the user is coerced into revealing the
key, she may instead provide a decoy key to reveal a plau-
sible and benign decoy message. The Rubberhose ﬁlesys-
tem for Linux (developed by Assange et al. [3]) is the ﬁrst
known instance of a PDE-enabled storage system.

Some real-world scenarios may mandate the use of PDE-
enabled storage—e.g., a professional/citizen journalist, or
human rights worker operating in a region of conﬂict or op-
pression. In a recent incident [45], an individual risked his
life to smuggle his phone’s micro SD card, containing ev-
idence of atrocities, across international borders by stitch-
ing the card beneath his skin. Mobile phones have been
extensively used to capture and publish many images and
videos of recent popular revolutions and civil disobedience.
When a repressive regime disables network connectivity in
its jurisdiction, PDE-enabled storage on mobile devices can
provide a viable alternative for data exﬁltration. With the
ubiquity of smartphones, we postulate that PDE would be
an attractive or even a necessary feature for mobile devices.
Note, however, that PDE is only a technical measure to pre-
vent a user from being punished if caught with contentious
material; an adversary can always wipe/conﬁscate the de-
vice itself if such material is suspected to exist.

Several existing solutions support full disk encryption
with plausible deniability in regular desktop operating sys-
tems. Possibly the most widely used such tool is True-
Crypt [46]. To our knowledge, no such solutions exist for
any mainstream mobile OSes, although PDE support is ap-
parently more important for these systems, as mobile de-
vices are more widely used and portable than laptops or
desktops. Also, porting desktop PDE solutions to mobile
devices is not straightforward due to the tight coupling be-
tween hardware and software components, and intricacies
of the system boot procedure. For example, in Android,
the framework must be partially loaded to use the soft key-
board for collecting decoy/true passwords; and the True-
Crypt bootloader is only designed to chainload Windows.

We introduce Mobiﬂage, a PDE-enabled storage encryp-
tion system for the Android OS. It includes countermea-
sures for known attacks against desktop PDE implementa-
tions (e.g., [10]). We also explore challenges more speciﬁc
to using PDE systems in a mobile environment, including:
collusion of cellphone carriers with an adversary; the use
of ﬂash-based storage as opposed to traditional magnetic
disks; and ﬁle systems such as Ext4 (as used in Android)
that are not so favorable to PDE. Mobiﬂage addresses sev-
eral of these challenges. However, to effectively offer de-
niability, Mobiﬂage must be widely deployed, e.g., adopted
in the mainstream Android OS. As such, we implement our
Mobiﬂage prototype to be compatible with Android 4.x.

Our contributions include:

1. We explore sources of leakage inherent to mobile de-
vices that may compromise deniable storage encryp-
tion. Several of these leakage vectors have not been
analyzed for existing desktop PDE solutions.

2. We present the Mobiﬂage PDE scheme based on hid-
den encrypted volumes—the ﬁrst such scheme for mo-
bile systems to the best of our knowledge.

3. We provide a proof-of-concept implementation of
Mobiﬂage for Android 4.x (Ice Cream Sandwich and
Jelly Bean). We incorporated our changes into 4.x
and maintained the default full disk encryption sys-
tem. During the normal operation of Mobiﬂage (i.e.,
when the user is not using hidden volumes), there are
no noticeable differences to compromise the existence
of hidden volumes.

4. We address several challenges speciﬁc to Android. For
example, to avoid PDE-unfriendly features of the Ext4
ﬁle system (as used for the Android userdata partition),
we implement our hidden volumes (userdata and exter-
nal) within the FAT32-based external partition.

5. We analyze the performance impact of our implemen-
tation during initialization and for data-intensive ap-
plications. In a Nexus S device, our implementation

appears to perform almost as efﬁciently as the default
Android 4.x encryption for the applications we tested.
However, the Mobiﬂage setup phase takes more time
than Android FDE, due to a two-pass wipe of the ex-
ternal storage (our Nexus S required almost twice as
long; exact timing will depend on the size and type of
external storage).

The remainder of this paper is organized as follows. Sec-
tion 2 presents our threat model and assumptions. In Sec-
tion 3, we describe design choices of Mobiﬂage deniable
disk encryption system for mobile devices. In Section 4, we
discuss the implementation of Mobiﬂage for Android. In
Section 5, we list several measures that must be observed to
maintain deniability in a mobile environment. Section 6 de-
scribes sources of leakage and attacks that may compromise
deniability on a mobile device. We analyze security im-
plications and performance of our implementation in Sec-
tions 7 and 8 respectively. Section 9 discusses related work
and Section 10 concludes.

2 Threat Model and Assumptions

In this section, we discuss Mobiﬂage’s threat model and
operational assumptions, and few legal aspects of using
PDE in general. The major concern with maintaining plau-
sible deniability is whether the system will provide some
indication of the existence of any hidden data. Mobiﬂage’s
threat model and assumptions are mostly based on past
work on desktop PDE solutions (cf. TrueCrypt [46]); we
also include threats more speciﬁc to mobile devices.

Threat model and operational assumptions.

1. Mobiﬂage must be merged with the default Android
code stream, or a widely used custom ﬁrmware based
on Android (e.g., CyanogenMod1) to ensure that many
devices are capable of using PDE. Then an adversary
will be unable to make assumptions about the presence
of hidden volumes based on the availability of software
support. We do not require a large user base to employ
PDE; it is sufﬁcient that the capability is widespread,
so the availability of PDE will not be a red ﬂag. Simi-
lar to TrueCrypt [46], all installations of Mobiﬂage in-
clude PDE capabilities. There are no identifying tech-
nical differences between the default and PDE encryp-
tion modes. However, when more users enable default
encryption, they help to obscure those that use PDE.

2. Mobiﬂage currently requires a physical or emulated
FAT32 SD card. Devices, such as the Nexus S, which
use an internal eMMC partition as opposed to a re-
movable SD card are supported. Some devices, such

1http://www.cyanogenmod.org/

as the Galaxy Nexus, have neither physical nor em-
ulated external storage.
Instead, they use the me-
dia transfer protocol (MTP) and share a single Ext4-
formatted partition for the (internal) app storage and
(external) user accessible storage. These devices are
not currently supported; possible solutions are outlined
in Section 6.3.

3. The adversary has the encrypted device and full knowl-
edge of Mobiﬂage’s design, but lacks the PDE key
(and the corresponding password). The offset of Mob-
iﬂage’s hidden volume is dependent on the PDE pass-
word, and is therefore also unknown to the adversary.
4. The adversary has some means of coercing the user
to reveal their encryption keys and passwords (e.g.,
unlock-screen secret), but will not continue to punish
the user once it becomes futile (e.g., the adversary is
convinced that he has obtained the true key, or the as-
surance that no such key actually exists). To success-
fully provide deniability in Mobiﬂage, the user is ex-
pected to refrain from disclosing the true key.

5. The adversary can access the user device’s internal and
external storage, and can have root-level access to the
device after capturing it. The adversary can then ma-
nipulate disk sectors, including encryption/decryption
under any decoy keys learned from the user; this can
compromise deniability (e.g., the “copy-and-paste” at-
tack [18]). Mobiﬂage addresses these issues.

6. The adversary model of desktop FDE usually includes
the ability to periodically access or snapshot the en-
crypted physical storage (cf. [10, 1]). However, this as-
sumption is unlikely for mobile devices and has there-
fore been relaxed (as the adversary will have access to
the storage media only after apprehending the user).

7. In addition to the Dolev-Yao network attacker
model [33, 13], we also assume that the adversary has
some way of colluding with the wireless carrier or ISP
(e.g., a state-run carrier, or subpoena power over the
provider). Adversaries can collect network/service ac-
tivity logs from these carriers to reveal the use of a
PDE mode on suspected devices. This assumption sig-
niﬁcantly strengthens the attacker model, nonetheless,
is quite realistic (see e.g., [11]).

8. We assume the mobile OS, kernel, and bootloader are
malware-free, and while in the PDE mode, the user
does not use any adversary controlled apps to avoid
leaking information via those apps; i.e., in the PDE
mode, the user is expected to use only trusted apps.
The device ﬁrmware and baseband OS are also trusted.
Control over the baseband OS may allow an adver-
sary to monitor calls and intercept network trafﬁc [50],
which may be used to reveal the PDE mode. Mobile
malware, and deﬁning/verifying trusted code are inde-
pendent problems, and are out of scope here.

9. We assume the adversary cannot capture the user de-
vice while in the PDE mode; otherwise, user data can
be trivially retrieved if the device is unlocked. We re-
quire the user to follow certain guidelines, e.g., not us-
ing Mobiﬂage’s PDE-mode for regular use; other pre-
cautions are discussed in Section 5. Following these
guidelines may require non-trivial effort, but is re-
quired for maintaining deniability in our threat model.

Legal aspects. Some countries require mandatory disclo-
sure of encryption keys in certain cases. Failure to do so
may lead to imprisonment and/or other legal actions; several
such incidents occurred in the recent past (e.g., [43, 44]).
Cryptography can be used for both legal and illegal pur-
poses and governments around the globe are trying to ﬁg-
ure out how to balance laws against criminal use and user
privacy. As such, laws related to key disclosure are still
in ﬂux, and vary widely among countries/jurisdictions; see
e.g., Koops [30].

Some of our recommendations, such as spooﬁng the
IMEI or using an anonymous/“burner” SIM card, may be
illegal in certain regions. Local laws should be consulted
before following such steps. Mobiﬂage is proposed here not
to encourage breaking laws; we want to technically enable
users to beneﬁt from PDE, but leave it to the user’s discre-
tion how they will react to certain laws. Our hope is that
Mobiﬂage will be predominantly used for good purposes;
e.g., human rights activists in repressive regimes.

3 Mobiﬂage Design

In this section, we detail our design and explain certain
choices we made. User steps for Mobiﬂage are also pro-
vided. Parts of the design are Android speciﬁc, as we use
Android for our prototype implementation; however, we
believe certain aspects can be abstracted to other systems.
Challenges to port the current design into other OSes need
further investigation (e.g., Apple iOS does not use FDE, and
the ﬁle system and storage layout are also different).

3.1 Overview and Modes of Operation

We implement Mobiﬂage by hiding volumes in empty
space on a mobile device’s external (SD or eMMC) stor-
age partition. We ﬁrst ﬁll the storage with random noise,
to conceal the existence of additional encrypted volumes.
We create two adjacent volumes: a userdata volume for ap-
plications and settings, and a larger auxiliary volume for
accumulating documents, photos, etc. The exact location of
the hidden volumes on the external storage is derived from
the user’s deniable password. We store all hidden volumes
in the external storage, due to certain ﬁle system limitations
discussed in Section 6.3.

We deﬁne the following modes of operation for Mobi-
ﬂage. (a) Standard mode is used for day-to-day operation of
the device. It provides storage encryption without deniabil-
ity. The user will supply their decoy password at boot time
to enter the standard mode. In this mode, the storage me-
dia is mounted in the default way (i.e., the same conﬁgura-
tion as a device without Mobiﬂage). We use the terms “de-
coy” and “outer” interchangeably when referring to pass-
words, keys, and volumes in the standard mode. (b) PDE
mode is used only when the user needs to gather/store data,
the existence of which may need to be denied when co-
erced. The user will supply their true password during
system boot to activate the PDE mode; we mount the hid-
den volumes onto the ﬁle-system mount-points where the
physical storage would normally be mounted (e.g., /data,
/mnt/sdcard). We use the terms “true”, “hidden” and
“deniable” interchangeably when referring to passwords,
keys, and volumes in the PDE mode.

3.2 Steganography vs. Hidden Volumes

There are currently two main types of PDE sys-
tems for use with FDE: steganographic ﬁle systems (e.g.,
StegFS [1, 32]) and hidden volumes (e.g., TrueCrypt [46]
and FreeOTFE [17]). Steganographic ﬁle systems’ known
drawbacks include: inefﬁcient use of disk space, possible
data loss, and increased IO operations. These limitations
are unacceptable in a mobile environment, for reasons such
as performance sensibility, and relatively limited storage
space.
(For more background on these systems, see Ap-
pendix A.) Consequently, we choose to use hidden volumes
for Mobiﬂage. This implies: no altered ﬁle system drivers
are required; IO is as efﬁcient as a standard encrypted vol-
ume; and the chance of data loss is mitigated, although not
completely eliminated. Most deniable ﬁle systems are lossy
by nature. Hidden volumes mitigate this risk by placing
all deniable ﬁles toward the end of the storage device. As-
suming the user knows how much space is available for the
deniable volume, they can refrain from ﬁlling the outer vol-
ume past the point at which the hidden volumes begin.

3.3 Storage Layout

The entire disk is encrypted with a decoy key and for-
matted for regular use; we call this the outer volume. Then
additional ﬁle systems are created at different offsets within
the disk and encrypted with different keys; these are re-
ferred to as hidden volumes. To prevent leakage, Mob-
iﬂage must never mount hidden volumes alongside outer
volumes. Thus, we create corresponding hidden volumes,
or RAM disks, for each mutable system mount point (e.g.,
/userdata, /cache, /mnt/sdcard).

Some hidden volumes may be decoys, but at least one
hidden volume will contain the actual sensitive data and
be encrypted with the true key. Since the outer volume
is ﬁlled with random noise before formatting, there are no
distinguishing characteristics between empty outer-volume
blocks and hidden volume blocks. When the outer vol-
ume (or a hidden decoy volume) is mounted, it does not re-
veal the presence or location of any other hidden volumes.
All hidden volumes are camouﬂaged amongst the random
noise. The disk can be thought of as the concatenation of
encrypted volumes, each with a different key:

EK 1(V ol1)||EK 2(V ol2)||...||EK n(V oln)

Here, EK (·) represents a symmetric encryption function
with key K and || represents concatenation.

When the disk is decrypted with a given key, the other
volumes will appear to be uniformly random data. When
the user is coerced, she can provide the outer volume key
and claim that no other volumes exist:

DK 1(V ol1||V ol2||...||V oln) = V ol1||Rand

Here, DK(·) represents the symmetric decryption function
with key K (corresponding to EK(·)) and Rand represents
data that cannot be distinguished from random bits. There-
fore, a forensic analysis of the decrypted outer volume will
not indicate the existence of hidden volumes. However,
some statistical deviations may be used to distinguish the
random data from the cipher output; see Section 6.1. Also,
the adversary may not trust the user to have disclosed all
volume keys and continue to coerce her for additional keys.
At this time, the user can provide decoy keys for other hid-
den volumes and insist that all the volumes have been ex-
posed. Revealing the existence of any hidden volume may
either help or hinder the user, depending on the situation;
see Section 7, item (e).

Each decrypted volume will appear to consume all re-
maining disk space on the device. For this reason it is pos-
sible to destroy the data in the hidden volumes by writing
to the currently mounted volume past the volume boundary.
This is unavoidable since a visible limit on the mounted vol-
ume would indicate the presence of hidden volumes.

3.4 Offset Calculation

The offset to a hidden volume is generated as follows:

oﬀset = 0.75 × vlen − (H(pwd||salt) mod (0.25 × vlen))

Here, H is a PBKDF2 iterated hash function [26], vlen
is the number of 512-byte sectors on the logical block stor-
age device, pwd is the true password, and salt is a random
salt value for PBKDF2. The salt value used here is the same

as for the outer volume key derivation (i.e., stored in the en-
cryption footer). Thus, we avoid introducing an additional
ﬁeld in the default encryption footer that may indicate the
presence of hidden volumes. The generated offset is greater
than one half and less than three quarters of the disk; i.e.,
the hidden volume’s size is between 25-50% of the total
disk size (assuming only one hidden volume is used). We
choose this offset as a balance between the hidden and outer
sizes: the outer volume will be used more often, the hidden
volume is used only when necessary. To avoid overwriting
hidden ﬁles while the outer volume is mounted, we recom-
mend the user never ﬁlls their outer volume beyond 50%.

Deriving the offset in the above manner allows us to
avoid storing it anywhere on the disk, which is important for
deniability. For comparison, TrueCrypt uses a secondary
volume header to store the hidden offset, encryption key
and other parameters; all the header ﬁelds are either random
or encrypted, i.e., indistinguishable from the encrypted vol-
ume data. In contrast, Android uses volume footers contain-
ing plaintext ﬁelds, similar to the Linux uniﬁed key setup
(LUKS [18, 19]) header. Introducing a new ﬁeld to store the
offset would reveal the use of Mobiﬂage PDE, so we choose
to derive the offset from the password instead. Other sys-
tems, e.g., FreeOTFE, mandate users to remember the off-
set; prompting the user for the offset at boot time may also
be a red ﬂag for the adversary. The obvious downside of a
password-derived offset is that the user has no input on the
size of the hidden volumes. One possible method to accom-
modate user choice is discussed in Section 4.4, item (2).

3.5 User Steps

Here, we describe how users may interact with Mobi-

ﬂage, including initialization and use.

Users must ﬁrst enable device encryption with PDE (e.g.,
through settings GUI). Mobiﬂage’s initialization phase
erases existing data on the external storage (SD card); this
data should be backed-up before initiating Mobiﬂage. How-
ever, users can choose to preserve the outer volume’s user-
data partition within the internal storage; this partition may
be encrypted in-place or initialized with random data (de-
pending on user choice). Assuming a single hidden volume
is used, the user then enters the decoy and true passwords,
for the outer and hidden volumes respectively. Mobiﬂage
then creates the hidden volumes, performs in-place encryp-
tion of the internal storage (if chosen) and reboots when
complete. Unlike Android FDE, Mobiﬂage must initialize
the external storage with random data for deniability. This
makes Mobiﬂage slower than the default Android FDE ini-
tialization (see Section 8). However, the initialization step
will likely be performed only occasionally.

For normal day-to-day use (e.g., phone calls, web brows-
ing), the user enters the decoy password during pre-boot

authentication to activate the standard mode. All data saved
to the device in this mode will be encrypted but not hid-
den. It is important for the user to regularly use the device
in this mode, to create a digital paper trail and usage time-
line which may come under scrutiny during an investiga-
tion. The user gains plausibility by showing that the device
is frequently used in this mode; i.e., she can demonstrate
apparent compliance with the adversary’s orders.

When the user requires the added protection of deniable
storage, they will reboot their device and provide their deni-
able password when prompted. In the PDE mode, they can
transfer documents from another device, or take photos and
videos. Note that app/system logs in this mode are hidden
or discarded; however, there is still a possibility of leakage
through network interfaces. Section 5 provides a list of pre-
cautions the user should take to mitigate such risks.

After storing or transferring ﬁles to the deniable storage,
the user should immediately reboot into the standard mode.
The ﬁles are hidden as long as the device is either off, or
booted in the standard mode.
If the user is apprehended
with the device in the PDE mode, deniability is lost. Even
if the user shuts the device off shortly before being appre-
hended, there is a possibility that the adversary can obtain
the key from data remanence in the RAM (e.g., the cold-
boot attack [20]).

If the user is apprehended with her device, she can sup-
ply a decoy password, and claim that no hidden volumes ex-
ist. The adversary can examine the storage but will not ﬁnd
any record of the hidden ﬁles, apps, or activities. Depend-
ing on the situation, the user can provide additional decoy
passwords, when faced with continued coercion. A rational
adversary may not punish the user if they have no reason to
believe that (further) hidden data exists on the device. As-
suming the user can overcome any coercion the adversary
attempts, and does not reveal the true key, the adversary
will have no evidence of the hidden data.

4 Mobiﬂage Implementation

developed

and

on

We

tested Mobiﬂage

a
Google/Samsung Nexus S phone using the 4.0 (ICS)
and 4.1 (JB) Android source code. The addition of PDE
functionality to the Android volume mounting daemon
(vold) required less than one thousand additional lines of
code, and subtle changes to the default kernel conﬁgura-
tion. We also discuss current limitations of Mobiﬂage. In
addition to the Nexus S, we also tested the portability of
our prototype to a Motorola Xoom.

Figure 1: Android FDE footer (note that the cipher speciﬁcation ﬁeld is stored in clear text)

4.1 Changes to Android FDE

We ﬁrst provide a brief introduction to Android FDE, as
Mobiﬂage has been implemented by enhancing this scheme.
We then discuss the changes we introduced.

The Android encryption layer is implemented in the log-
ical volume manager (LVM) device-mapper crypto target:
dm-crypt [12]. Encryption takes place below the ﬁle system
and is hence transparent to the OS and applications. The
AES cipher is used in the CBC mode with a 128-bit key.
ESSIV is used to generate unpredictable IVs to prevent wa-
termarking attacks (Fruhwirth [18]; see also Section 6.1). A
randomly chosen master volume key is encrypted with the
same cipher by a key derived from 2000 iterations of the
PBKDF2 [26] digest of the user’s screen-unlock password
and a salt value. To enable encryption, the user must choose
either an unlock password or PIN (i.e., pattern and “Face
Unlock” secrets may not be used). The cipher speciﬁcation,
encrypted master key and salt are stored in a footer located
in the last 16KB of the userdata partition; see Figure 1 for
an example Android encryption footer.

When the device is booted and fails to ﬁnd a valid Ext4
ﬁle system on the userdata partition, the user is prompted
for their password. The master key is decrypted from their
password-derived key. Storage read/write operations are
passed through the device mapper crypto target, so encryp-
tion/decryption is performed on-the-ﬂy for any IO access.
If a valid Ext4 ﬁle system is then found in the dm-crypt tar-
get, it is mounted and the system continues to boot as usual.
Otherwise, the user is asked to re-enter their password. By
default, removable SD cards are not encrypted; however,
emulated external storage (i.e., a physical eMMC partition,
mounted at /mnt/sdcard) is encrypted.

We made three important changes to the default Android
encryption scheme that are necessary to defend deniabil-
ity: (a) we use the XTS-AES cipher instead of CBC-AES;
(b) we enable encryption of removable storage; and (c) we
wipe the SD card with random data. XTS-AES is chosen
as a precaution against copy-and-paste and malleability at-
tacks (see Section 6.1 for details). We use a 512-bit key
(256-bit for AES and 256-bit for XEX tweak). This gives
the cipher additional strength over the 128-bit Android key-

length, but more importantly makes the key exactly one disk
sector in size for easy alignment of hidden volumes. Note
that, although the 256-bit random key strengthens AES, the
overall security of the system defaults to the strength of the
password used to protect the volume key. The xts and
gf128mul kernel crypto modules were compiled for our
development devices, to enable the XTS mode. These mod-
ules are available in the Linux kernel since version 2.6.24.
Android encryption can be performed in-place (i.e.,
reading each sector, encrypting it, and writing it back to
the disk), or by ﬁrst formatting the storage media. We per-
form the wipe operation on the SD card even when the user
enables in-place encryption. We enhance the wipe opera-
tion to ﬁll the ﬂash media with random data to address data
remanence issues and to hide the PDE volumes (see Sec-
tion 6.2 for details). These changes are necessary even when
encrypting without PDE, to make the default encryption in-
discernible from PDE. Our changes should not negatively
affect the security of Android FDE.

4.2 Partitions and File(cid:173)system Support

Here we describe the Android storage layout and ﬁle
systems, as well as the Mobiﬂage storage structure used to
implement PDE.

Device storage partitions. The exact storage layout of
a mobile device is manufacturer/device speciﬁc; Table 1
shows volumes typically found. Android 4.x has two par-
titions that store user data: the internal Ext4 userdata par-
tition and the (emulated or physical) external FAT32 parti-
tion. The userdata partition stores apps and settings, while
the external partition stores documents, downloads, photos,
etc. We create both a hidden userdata partition and a hidden
external partition for use in the PDE mode. This allows the
user to store hidden ﬁles as well as install hidden apps. The
OS and kernel are stored on read-only volumes, and can be
safely shared between the two modes. This also simpliﬁes
system updates, since updating the kernel/OS in the stan-
dard mode will be reﬂected in the PDE mode. Over-the-air
system updates make use of the /cache partition, which is
not persistent in the PDE mode, so updates must always take
place from the standard mode. The default ﬁle system for

Volume name
Boot
Recovery
System

Cache

Device log
Userdata

External

Mount point

N/A
N/A
/system

/cache

/devlog
/data
/mnt/sdcard or
/storage/sdcard0

Mode
N/A
N/A
RO

RW

Description

Bootloader and kernel image
Recovery tools and backup kernel
OS binaries, Dalvik VM, etc.
Temporary space for OS and apps
(e.g., OTA updates and downloaded .apk packages)

RW Persistent system logs
RW Apps and settings

RW App and user data (e.g., photos, maps, music)

Table 1: Typical volumes on common Android devices (RO: read-only; RW: read-write; N/A: not applicable)

the internal userdata partition is Ext4. For reasons outlined
in Section 6.3, we cannot reliably hide a volume within an
Ext4 ﬁle system. Instead, we store the hidden volumes in
the FAT32 formatted external partition.

The FAT32 ﬁle system is much less complex than Ext4.
FAT32 stores the allocation tables and all meta-data at the
beginning of a disk. The remaining space is uninterrupted
data blocks—i.e., no FAT backups or meta-data exist in fur-
ther areas of the disk. Writing a hidden partition to an un-
used area of a FAT32 ﬁle system will not create any notice-
able discrepancies, as would be visible in Ext4. We create a
hidden Ext4 partition to store apps and settings, and a hid-
den FAT32 partition to store ﬁles such as photos and videos;
see Figure 2. To prevent leakage into the outer volumes,
when the hidden volumes are mounted, we use tmpfs2 RAM
disks for /cache and /devlog. We also discuss persis-
tent cache and device log partitions in Section 7, item (c).

Mobiﬂage on-disk structure. Our prototype currently sup-
ports the creation of only one hidden volume offset (i.e., no
additional decoy hidden volumes). The outer userdata and
external volumes are ﬁrst encrypted through the dm-crypt
target. The footer, containing only the outer volume key
(encrypted with the decoy-password derived key) and other
default ﬁelds, is written to the disk in the usual manner. Be-
fore encrypting the outer external volume, it is ﬁrst ﬁlled
with random data produced with the XTS-AES cipher un-
der two random, discardable keys (see Section 6.1). This is
not performed by Android FDE, which may lead to data re-
manence attacks via the ﬂash wear-leveling mechanism as
discussed in Section 6.2.

We then generate an offset from the true password as
described in Section 3.4. A randomly generated hidden vol-
ume key is then encrypted with a key derived from the true
password. The encrypted hidden volume key is stored in the
external partition at the derived offset. The hidden volumes
immediately follow the key on the disk, and the volumes
are encrypted by creating new dm-crypt mappings with the
hidden key. The hidden userdata volume is 256MB and the
hidden external volume consumes the remaining space. We
choose 256MB for the userdata partition assuming this will

2http://www.kernel.org/doc/Documentation/ﬁlesystems/tmpfs.txt

be sufﬁcient for the installation of several hidden apps (e.g.,
custom browser, secure VoIP and texting apps). This size
may be user conﬁgurable (e.g., up to a maximum of 25%
of the hidden space). However, the bulk of the user data
is stored in the external storage (e.g., photos, downloads,
maps), warranting a larger size.

To assess the portability of Mobiﬂage on other hardware
proﬁles, we tested our prototype on a Motorola Xoom. The
Xoom uses the shared internal/external MTP paradigm, but
also contains an SD card slot. The shared MTP storage is
treated as the primary external storage, and all external app
data is stored at this location (essentially ignoring the SD
card). We altered Mobiﬂage by embedding the location of
the SD card block special ﬁle, to create and mount the hid-
den partitions. In this particular conﬁguration, it is perhaps
a better idea to create a single hidden Ext4 partition, since
it will house all internal and external data, and the SD card
is inaccessible to installed apps (i.e., 256MB will be insuf-
ﬁcient for MTP devices). Other subtle tweaks may be nec-
essary to support Mobiﬂage on different hardware proﬁles.

4.3 User Interface and Pre(cid:173)boot Authentication

The default Android encryption mechanism can be en-
abled through the settings GUI. This prompts the user for
their screen-unlock password, which is used to derive the
volume encryption key. The system then shuts down non-
essential services and starts encrypting the internal storage
in-place. A user with root privileges can also use the vdc
command-line tool (e.g., from a PC to which the Android
device is connected) to enable encryption either in-place
or with data wipe, as follows: “vdc cryptfs enablecrypto
<inplace|wipe> <pwd>.” In this case, pwd can be any
password (i.e., independent of the screen-unlock password).
the user can activate Mobiﬂage PDE us-
ing vdc as follows: “vdc cryptfs pde <inplace|wipe>
<outer pwd> <hidden pwd>.” Note that, the default An-
droid shell, sh, does not maintain history between sessions
(i.e., command history cannot be retrieved from a captured
Android device). In-place encryption is used only for the
internal storage. We wipe the SD card to reliably ﬁll the
physical media with random noise. On ﬂash media, it is

Currently,

Figure 2: Mobiﬂage SD card PDE layout

apparently sufﬁcient to completely ﬁll the logical address
space twice, as noted by Wei et al. [49]. Since internal
storage does not house any hidden volumes, we forgo the
random wipe and encrypt in-place. This allows the user to
preserve their apps and settings in the standard mode and
creates a fresh install (i.e., factory reset) in the PDE mode.
We plan to incorporate the PDE options into the settings
GUI in a future version of Mobiﬂage.

When the device is booted up, the system will attempt
to mount the userdata volume. If a valid Ext4 ﬁle system
is not found, the user is prompted for a password, assum-
ing storage encryption is in use. The system then attempts
to mount the volume with the stored key (decrypted with
the password-derived key). If it fails, instead of asking the
user to try again, it will calculate the volume offset from the
supplied password. The external storage sector found at this
offset is decrypted with the PBKDF2 derived key. Using the
result as a volume key, the system will attempt to mount a
volume beginning at the next external storage sector after
the offset. If a valid Ext4 ﬁle system is found at this loca-
tion, it is mounted. After mounting the hidden userdata and
external volumes, the boot procedure continues as usual. If
a hidden ﬁle system cannot be found at the derived offset,
the system will prompt the user to try again, just as it would
if PDE were not enabled.

4.4 Limitations

Limitations of our current Mobiﬂage design and proto-

type include the following:

1. Mobiﬂage currently requires a separate physical
FAT32 storage partition (SD or eMMC). Devices that
use MTP and share a single partition for internal and
external storage are not currently supported. We dis-
cuss the problems inherent to Ext4, and provide sug-
gestions for other ﬁle systems (e.g., HFS+, Ext2/3) in
Section 6.3.

2. Users currently cannot set the desired size of a hidden
volume; the size is derived from a user’s password to
avoid the need to store the offset on the device. An ex-

pected size may be satisﬁed as follows (not currently
implemented). We can ask users for the desired size
and iterate the hash function until an offset close to the
requested size is found. For example, we can perform
20 additional hash iterations and report the closest size
available with the supplied password. The user could
then choose to either accept the approximate size or
enter a new password and try again. Storing the itera-
tion count is not needed. At boot time, the system will
perform consecutive iterations until a valid ﬁle system
is found, or a maximum count is reached (cf. [4]). This
would slow down the boot process somewhat while
searching for the correct offset.

3. Currently, we support only one hidden volume offset.
Creating additional (decoy) hidden volumes will re-
quire a collision prevention mechanism to derive off-
sets. A method, such as the iteration count mentioned
above, can be used to ensure enough space is left be-
tween hidden offsets (e.g., 1.5GB). This increases the
chance of corrupting hidden data. Each hidden volume
would appear to consume the remaining SD card stor-
age, but the address space would overlap with other
hidden volumes. We discuss the implications of multi-
ple hidden volumes in Section 7, item (e).

4. Transferring data between outer and hidden volumes
may be necessary on occasion; e.g., if time does not
permit switching between modes before taking an op-
portunistic photo. We do not offer any safe mechanism
for such transfers at present. Mounting both volumes
simultaneously is a straightforward solution, but may
compromise deniability (e.g., usage log data of a hid-
den ﬁle may be visible on the decoy volume). The user
can transfer sensitive ﬁles to a PC as an intermediary,
then transfer the ﬁles to the PDE storage. In this case,
data remanence in the outer volume is an issue. An-
other possibility is to keep a RAM disk mounted in
the standard mode for storing such opportunistic ﬁles
(and then copy to the PDE storage via a PC). However,
some apps, such as the camera app, do not offer an
option to choose where ﬁles are saved.

5 Precautions against Colluding Carriers

In this section, we discuss threats from a colluding wire-
less carrier, and list a number of precautions that may help
maintain deniability in the presence of such a carrier.

Mobile devices are often connected to a cellphone net-
work. It is likely that the wireless carrier maintains activ-
ity records, with identifying information and timestamps,
of devices interfacing with the network. These records can
demonstrate that the device is online and communicating at
a given time. The use of the PDE mode is likely to cause dis-
crepancies between the carrier’s logs and the device’s stan-
dard mode (outer volume) logs. For example, if the carrier
has records of a phone call at a given time, that occurred
when the device was booted in the PDE mode, the device
will not have a record of the call in the standard mode. In
certain situations, an adversary may be able to collude with
the carrier (e.g., a state-based carrier), or compel the carrier
to disclose user records (e.g., by court orders). If the user
has provided the adversary with the decoy password, the ad-
versary may ﬁnd discrepancies between the device logs and
the carrier’s logs. This would give the adversary reason to
believe that the user has not been completely forthcoming.
They may then continue to coerce the user for any additional
passwords or keys.

To restrict the above threats, we provide a list of user
practices that must be adhered to when booted in the PDE
mode; some of these practices may be onerous to the user.
This list shows pitfalls of using PDE systems in practice;
however, it is not meant to be comprehensive.

1. When using the device in the PDE mode, it should
be left in “Airplane mode” (i.e., antennae off), and
the SIM card should be removed. This may prevent
the wireless carrier from identifying the device/user in
their activity logs.

2. A secondary anonymous SIM card should be used, and
the phone’s identifying information spoofed, if con-
necting to a mobile network while in the PDE mode
(e.g., IMEI spooﬁng and software MAC address spoof-
ing). This will restrict any carrier or ISP from directly
identifying a suspected device.

3. We strongly discourage the use of mobile data net-
works in favor of public WiFi hot-spots or Internet
pass-through/tethering from a PC. Identifying network
trafﬁc information (e.g., destination IP address) should
be spoofed or obscured with a tool such as Tor3 or a
trusted (e.g., employer controlled) VPN when using
any type of network connection. This may also restrict
an ISP or carrier from correlating the user’s behavior
(e.g., if the user is known to frequent a certain ﬁle host-
ing service, or news agency).

3Tor on Android: https://www.torproject.org/docs/android.html.en

4. When using the PDE mode, any web services (e.g.,
email, social networking) should not be used unless
a secondary account is created under a pseudonym
and is only used in the PDE mode. This will prevent
any collusion between the adversary and web service
providers with which the user is known to have an ac-
count. This includes the device registration account
(e.g., Google or iTunes). It is also recommended that
auto-backup features (e.g., iCloud or Google Drive)
are disabled in the PDE mode.

6 Sources of Compromise

We examine three leakage vectors that may compromise
deniability of a PDE scheme on mobile devices: known
issues in crypto-systems and software implementations of
desktop PDE schemes, as well as issues speciﬁc to current
mobile storage systems. Below we discuss these challenges
and how they are addressed in Mobiﬂage.

6.1 Leakage from Crypto Primitives

Crypto primitives used in a PDE implementation must
be chosen carefully. Below we discuss issues related to ran-
dom data generation and encryption modes.

PRNG. A fundamental requirement for PDE schemes im-
plemented with hidden volumes is that the whole disk must
appear to contain cryptographically secure random data.
For this requirement, the cipher output must be indistin-
guishable from random bits (cf. IND$-CPA [40]). However,
certain statistical deviations between cipher and PRNG out-
put may exist (see e.g., [16, pp. 137–161]). To sidestep
any potential statistical inconsistencies, we draw random-
ness from the same distribution as the ciphertext space by
using the encryption function itself as the PRNG (in a two
pass random-wipe, each pass with a new random key). Un-
der statistical analysis, empty sectors in an outer volume
will appear the same as the sectors in a hidden volume,
when either encrypted or decrypted with a decoy key. For
comparison, TrueCrypt uses a built-in PRNG to ﬁll empty
volume space, with the assumption that the cipher output
will be indiscernible from their PRNG output.

Encryption modes. Encryption of data at rest has different
considerations than the traditional communication encryp-
tion model. For example, to enable random-access, FDE
implementations treat each disk sector as an autonomous
unit and assign sector-speciﬁc IVs for chaining modes such
as CBC. These IVs are long-term and must be easily de-
rived from or stored in the local system. When FDE is im-
plemented with a CBC-mode cipher, information leakage
about the plaintext disk content may occur without knowl-
edge of the encryption key or cipher used (see e.g., [18]).

Tweakable block cipher modes (e.g., LRW and XTS) have
been designed speciﬁcally for disk encryption to prevent
attacks such as watermarking, malleability, and copy-and-
paste. These attacks are particularly important for PDE, as
they may be used to identify hidden volumes without recov-
ering any hidden plaintexts.

The default Android FDE uses CBC. We choose to
move away from the Android default and instead, use XTS-
AES [23, 34] to prevent known attacks against CBC. XTS-
AES is a code book mode (i.e., no block chaining) and uses
a secondary “tweak” key to make unpredictable use of the
disk sector index. XTS-AES is not an authenticated mode,
and as such is considered malleable [23]. However, unlike
CBC, XTS is not malleable at a bit granularity: a modiﬁed
ciphertext block will decrypt to a random plaintext block,
preventing an attacker from making a predictable change.
The absence of authentication tags also allows for a copy-
and-paste attack (i.e., successful decryption of sectors that
have been moved from other disk locations). Using CBC
with random IVs will garble only the ﬁrst block, but suc-
cessfully decrypt all subsequent blocks in the moved sector.
XTS-AES does not rely on block chaining, and uses the
tweak to entangle plaintext/ciphertext block pairs with their
disk sector location. As such, all blocks in a moved sector
will decrypt to random plaintext. A watermark attack relies
on predictable IVs, and is mounted by convincing the user
to encrypt and store a ﬁle that has been speciﬁcally crafted
to effectively zero out the IVs. The watermark manifests
itself as identical ciphertext blocks at the beginning of con-
secutive disk sectors. The attacker can then examine the en-
crypted storage and locate the watermark. Both XTS-AES
(Mobiﬂage) and CBC with ESSIV (Android FDE), effec-
tively prevent watermarking attacks.

6.2 Leakage from Flash(cid:173)storage

In this section, we provide an overview of ﬂash storage
technologies typically found in mobile devices. We also
discuss ﬂash leakage vectors that affect PDE and, to some
extent, FDE.

Overview of ﬂash storage. Mobile devices generally use
NAND-based ﬂash storage. Flash memory is not divided
into sectors in the same way as magnetic disks. Write oper-
ations take place on a page level (e.g., 4KB page) and can
only change information in one direction (e.g., changing 1
to 0, but not the inverse). Thus, write operations can only
take place on an empty page. An erase operation takes place
on a group of several pages, called an erase block (e.g., 128
pages per block). Flash memory cells have a ﬁnite number
of program/erase cycles before becoming damaged and un-
usable. Therefore, ﬂash memory is often used with a wear-
leveling mechanism to prevent the same cell from being re-
peatedly written. In effect, logical block addresses (LBAs)

on the disk are mapped to different physical memory pages
for each write operation. Thus, storage on ﬂash memory is
not a linear arrangement as in traditional magnetic disks.

When a logical disk region is overwritten, it is usually
simply remapped to an empty page without erasing the orig-
inal page. This can continue until there are no empty pages,
at which time unmapped pages in erase blocks are consoli-
dated by the garbage collector, and empty erase blocks are
wiped. Otherwise, the erase blocks must be completely
wiped and rewritten to change a single page. This requires
reading the entire erase block into cache, modifying the af-
fected page, wiping the erase block, and ﬁnally writing the
block back to the media.

Generally, two types of ﬂash media are used in Android
devices. Older Android devices use the memory technology
device (MTD) for internal storage. An MTD is analogous to
a block or character device, speciﬁcally designed for ﬂash
memory idiosyncrasies. To emulate a block device on an
MTD, a software ﬂash translation layer (FTL) is used. The
FTL enables the use of a standard block ﬁle system (e.g.,
Ext4, FAT32) on top of the raw ﬂash media. Newer An-
droid devices use embedded multi media card (eMMC) for
internal storage and secure digital (SD) for external storage.
eMMC combines the ﬂash memory and hardware controller
in one package. SD has a dedicated controller and remov-
able storage. Both technologies are presented to the system
as block devices. The FTL for eMMC and SD storage is
implemented in ﬁrmware on the controller as opposed to a
software FTL as used by MTD.

Wear-leveling issues. Flash memory does not have the
same data remanence issues as seen in magnetic stor-
age. However, the wear-leveling mechanism may leave old
copies, or fragments of ﬁles in unmapped pages on the ﬂash
disk. When making changes to hidden ﬁles it is possible
that (encrypted) fragments of the original ﬁle will still exist
in unmapped pages. This would provide an adversary with
a partial time-line, or partial snapshots, of changes made to
the disk. If the adversary can demonstrate that the regions
affected do not coincide with disk activity in the outer vol-
ume, they can conclude existence of hidden volumes.

The software FTL used by the Linux MTD driver
(mtdblock) is simplistic and does not use a wear-leveling
mechanism.4 Some ﬁle systems (e.g., YAFFS2) are de-
signed to work directly with the raw ﬂash memory instead
of using an FTL. Such ﬁle systems may implement their
own wear-leveling mechanisms. This was the default tech-
nology for devices prior to Android 3.0, but has largely been
replaced by eMMC storage. The SD [41] and eMMC [25]
speciﬁcations do not address wear-leveling requirements, so
it is up to the manufacturers to decide if and how to imple-
ment wear-leveling in hardware FTLs.

4The MTD subsystem for Linux: http://www.linux-mtd.infradead.org/

faq/general.html

Mobiﬂage stores all hidden volumes on the SD card.
Therefore, exploiting the unmapped, wear-leveling pages
would require bypassing the hardware controller and read-
ing the raw ﬂash memory, as opposed to acquiring a logical
image (e.g., as produced with the dd tool). The adversary
would need to read the physical to logical block allocation
map and reconstruct the physical layout of the disk. Exist-
ing studies of raw ﬂash performed by Wei et al. [49] have
focused on writing speciﬁc strings to the media through
the hardware controller FTL, then bypassing the controller
to search for those strings in the raw physical ﬂash. It is
unknown how successful an adversary may be in demon-
strating that a given unused page was part of a hidden vol-
ume and hence compromising deniability. Further work is
needed to measure the extent to which unmapped/obsolete
pages can be correlated to LBAs.

Mobile forensic tools that focus on logical data acqui-
sition (e.g., viaExtract,5 Paraben6) cannot mount this at-
tack. Physical acquisition mechanisms exist for MTD stor-
age (see e.g., Hoog [22, pp. 266–284]); however, they tend
to be costly, time consuming, and generally destroy the mo-
bile device.

Wear-leveling has implications for both non-deniable
and deniable encryption schemes.
If a disk is encrypted
in-place, plaintext fragments that existed before encryption
may still remain accessible. Wei et al. [49] show that most
ﬂash media contains between 6-25% more storage than ad-
vertised to the system. The additional storage is used by
the wear-leveling mechanism. For this reason, Wei et al.
suggest that the entire address space of a ﬂash disk should
be overwritten twice with random data, to ensure all erase
blocks have been affected, before encrypting the device.
Their ﬁndings show that in most cases, this is sufﬁcient to
ensure that every physical page on the device is overwritten.
Therefore, Mobiﬂage performs a two-pass wipe, before en-
cryption of the external partition, to avoid leaving any plain-
text fragments on the media, and to ensure the continuity of
random data, which is crucial for PDE. Currently, the de-
fault Android FDE does not take this precaution into con-
sideration, and the wipe operation is performed by simply
re-formatting the ﬁle system.

A recent proposal by Reardon et al. [38] explores se-
cure deletion for ﬂash memory. All ﬁle system data is en-
crypted with per-block keys. To securely delete a ﬁle sys-
tem block, the associated key is wiped from the physical
ﬂash with an ERASE command. The data blocks are ren-
dered un-readable, hence data remanence is not an issue.
Currently, their implementation only works with MTD stor-
age, and would need to be integrated into the SD/eMMC
hardware controller FTL to afford secure deletion to these
devices [38].

5https://viaforensics.com
6http://www.paraben-forensics.com

Special “discard” operation. The discard operation can be
issued from a ﬁle system to the ﬂash hardware controller.
This command informs the host controller that a certain
LBA is no longer storing ﬁle system data and can be wiped
at any time. When all LBAs in an erase block are discarded,
the controller’s garbage collector will erase the block in
the background. Discard effectively speeds up write access
time, as an empty block can be directly written to without a
read-modify-erase-write cycle. The ERASE command (or
the TRIM command for ATA controllers) takes place on the
physical layer, and when used, will zero out regions of the
physical ﬂash media, not visible to the logical ﬁle system.
Thus, the adversary may recognize the physical blocks that
are actually used to store ﬁle data. If the adversary knows
the decoy key, he may correlate physical blocks and LBAs
to discover which blocks are used by the hidden volume. As
a security consideration, the dm-crypt mapper does not for-
ward discard commands [5], hence ensuring the continuity
of random data on the underlying physical storage.

6.3 Leakage from File(cid:173)system and OS

The default ﬁle system for the internal storage in An-
droid 4.x devices is Ext4. Ext4 introduced several new
features including extents, uninitialized block groups, and
ﬂexible block groups [28]. The ﬂexible block group (ﬂex
group) feature allows a block group’s meta-data e.g., in-
ode/block bitmaps and inode table, to be located anywhere
on the disk, instead of at the beginning of each individual
block group, as in earlier Ext ﬁle systems. The default setup
is to store the meta-data for 16 consecutive block groups in
the ﬁrst block group of each ﬂex group. This would make
it possible to hide ﬁles inside an empty ﬂex group without
overwriting any meta data for that group. However, as Ext4
places backup superblocks and group descriptor tables in
some block groups within each ﬂex group, any hidden data
stored in a ﬂex group could overwrite these structures.

Additionally, the absence of backup superblocks and
group descriptor tables would be suspicious and give the
adversary reason to assume that data has been hidden in
these ﬂex groups. The locations of the backup structures
and ﬁle data would need to be known when creating hid-
den volumes. Furthermore, when creating directories in
the root of an Ext4 ﬁle system, the directories are placed
in the most vacant block group available on the disk [27].
This effectively spreads directories, and the data contained
within, across the entire disk. Standard volumes, unaware
of the hidden volume location, will likely collide with hid-
den data regardless of where it is placed in an Ext4 ﬁle sys-
tem. Therefore, we cannot reliably hide data within an Ext4
volume (without upstream changes in Ext4, e.g., by making
directory spread optional).

One way to overcome the Ext4 backup superblock prob-
lem is to indicate those regions of the disk as damaged or
“bad blocks” when creating the hidden volume. The hidden
ﬁle system would then avoid writing data to those locations.
When the outer volume is mounted there would be no indi-
cation of tampering nor reason for suspicion. Unfortunately,
due to the Ext4 directory spread, this would not be a feasi-
ble solution for Android MTP devices without removable
storage. However, this method may be used to implement
PDE in other ﬁle systems such as NTFS, HFS+ and Ext2/3
that employ a sequential write policy (i.e., they do not use
a directory spread mechanism as in Ext4). Another par-
tial solution is to logically partition the internal storage to
include a FAT32 volume. In the standard mode, this vol-
ume would be mounted to the SD card mount point, instead
of using MTP. This partition would house the hidden vol-
umes mounted in the PDE mode. MTP would be sacriﬁced
in favor of the older USB mass storage functionality when
connected to a PC.

Most work in deniable disk encryption investigates data
or existence leakage of hidden ﬁles into temporary ﬁles,
swap space, or OS logs (see e.g., [10]). For example, a word
processor that performs auto-save functions to a central lo-
cation may have backups and fragments of ﬁles edited from
a hidden volume. If such backups are present, and no evi-
dence of the ﬁles are found on the disk, then the adversary
can assume the existence of hidden ﬁles and demand the
true decryption key. We explain in Section 7 (item (c)) that
log ﬁles, swap space, and temporary storage are effectively
isolated between the two modes of Mobiﬂage.

7 Security Analysis

In this section, we evaluate Mobiﬂage against known at-

tacks and weaknesses.

(a) Password guessing. We rely on the user to choose
strong passwords to protect their encryption keys. The cur-
rent Android encryption pre-boot authentication times-out
for 30 seconds after ten failed password attempts. The time-
out will slow an online guessing attack, but it may still be
feasible, especially when weak passwords are used.

An ofﬂine dictionary attack is also possible on an image
of the device’s storage. The adversary does not know the
password to derive the offset, but the salt is found in the
Android encryption footer. The salt is used with PBKDF2,
and is a precaution against pre-generated dictionaries and
rainbow tables. The salt cannot be stored at the hidden off-
set as it is used in the offset calculation. Using the same
salt value for both modes enables the adversary to compute
one dictionary of candidate keys (after learning the salt), to
crack passwords for both modes. Exacerbating the problem
is Android’s low PBKDF2 iteration count. On a single core
of an Intel i7-2600, at 2000 iterations, we were able to cal-

culate 513.37 ± 1.93 keys per second using the OpenSSL
1.0.1 library. Custom hardware (e.g., FPGA/GPU arrays)
and adapted hash implementations (e.g., [48]) can make of-
ﬂine guessing even more efﬁcient.

We tested different hash iteration counts in PBKDF2 and
found that 200,000 iterations is apparently a fair compro-
mise between security and login delay. On the Intel i7-2600,
at 200,000 iterations, we were able to calculate 5.21 ± 0.01
keys per second (i.e., guessing attack becomes 100 times
slower). On our Nexus S (1GHz Exynos-3 Cortex-A8) de-
velopment phone, it required an additional 0.67 ± 0.01 sec-
onds to calculate a single key. Our Motorola Xoom (1GHz
Tegra-T20 Cortex-A9) required an additional 0.41 ± 0.001
seconds and an HTC EVO3D (1.2GHz MTM8660 Scor-
pion) required an additional 0.70 ± 0.01 seconds. This
would slow down the boot procedure by approximately two
seconds; note that, booting into the PDE mode requires
three invocations of PBKDF2: to test the key in the footer,
to calculate the offset, and to decrypt the hidden volume
key. Possible computational and memory-wise expensive
replacements for PBKDF2 (e.g., [31, 37]) can also be used
to mitigate custom hardware attacks. In the end, we require
users to choose a strong password resilient to guessing.

(b) Cipher issues. An implementation ﬂaw can expose
FDE ciphers to a theoretical watermarking attack that has
been documented for software such as LUKS [9]. The is-
sue occurs when the disk is sufﬁciently large and the size
of the disk sector index (n) is small. For example, if n is
a 32-bit integer, and there are more than 232 512-byte sec-
tors on the disk, the value of n will eventually roll-over and
repeat itself. If the adversary can create a special ﬁle with
duplicate plaintext blocks at correct locations and convince
the user to store the ﬁle in their hidden volume, then the ad-
versary can demonstrate the existence of a hidden volume.
In the given example, the duplicate plaintext blocks would
need to be repeated at 2TB intervals. The adversary will not
know what the corresponding ciphertext blocks will be, but
ﬁnding identical ciphertexts spaced at the correct distance
would be strong evidence. This is an implementation issue,
and not an issue with the cipher algorithm itself. The prob-
lem occurs for all FDE ciphers, including XTS and CBC-
ESSIV, that use a sector index smaller than the total number
of disk sectors. To mitigate this problem, a longer integer
(e.g., 64-bit) is commonly used for the sector index. We use
the 64-bit sector index available in dm-crypt which will not
roll over until 8192 Exabytes.

(c) Software issues. Mobiﬂage seems to effectively iso-
late the outer and hidden volumes. Apps and ﬁles installed
in the hidden volumes leave no traces in the outer volume.
Android does not use dedicated swap space. When the OS
needs more RAM for the foreground app, it does not page
entire regions of memory to the disk. Instead, it unloads
background apps after copying a small state to the userdata

partition. For example, the web browser may copy the cur-
rent URLs of open tabs to disk when unloading, instead of
the entire rendered page. When the browser is loaded again,
the URL is reloaded. Leakage into swap space and pag-
ing ﬁles was shown to be an issue for desktop PDE imple-
mentations by Czeskis et al. [10]. As the outer and hidden
userdata partitions are isolated from one another in Mobi-
ﬂage, we do not take any speciﬁc measures against leakage
through memory paging.

The Android Framework is stored in the /system parti-
tion which is mounted read-only. The Linux kernel is stored
in a read-only boot partition which is not mounted onto the
OS ﬁle system. Leakage through these immutable partitions
is also unlikely.

Android logs are stored in a RAM buffer, and application
logs are stored in the userdata partition. Leakage is also un-
likely through logs as the userdata partitions are isolated and
RAM is cleared when the device is powered off. Some de-
vices keep persistent logs at /devlog, for troubleshooting
between boots. To prevent leakage through these logs, we
mount a tmpfs RAM disk to this mount point when booting
into the PDE mode. The logs will remain persistent between
standard mode boots, but no PDE mode logs are kept.

Android devices typically have a persistent cache parti-
tion used for temporary storage. For example, the Google
Play store will download application packages to this parti-
tion before installing them on the userdata volume. To pre-
vent leakage through the cache partition, we mount a tmpfs
RAM disk to /cache in the PDE mode; this partition takes
32MB of RAM. An alternative to tmpfs, without sacriﬁc-
ing RAM, is to mount the volume through dm-crypt with a
randomly generated one-time key. The key is discarded on
reboot, effectively destroying the data on the partition.

(d) Partial storage snapshots. If the adversary has inter-
mittent or regular access to the disk, they may be able to
detect modiﬁcations to different regions of the disk. If a de-
coy key has already been divulged, the adversary may sur-
mise the existence of hidden data by correlating ﬁle system
activities to the changing disk regions. We exclude this pos-
sibility assuming the adversary will have access only after
acquiring the device from the user, and does not have past
snapshots of the storage. If the user is aware that the stor-
age has been imaged (e.g., at a border crossing), they should
re-initialize Mobiﬂage to alter every sector on the disk.

(e) Practical security of multiple hidden volumes. There
is some debate over the effectiveness of multiple hidden vol-
umes [15]. Whether or not the user gains any advantage is
deﬁned by the scenario. If the user cannot be held indef-
initely, and cannot be punished on the suspicion of PDE
data alone, she may feign compliance by relinquishing de-
coy keys. This may be advantageous to the user as, in the
absence of indisputable evidence, she will eventually be re-
leased. In other scenarios, revealing the existence of one

Cipher-spec

Unencrypted

AES-CBC-ESSIV

(Android 4.x)

AES-XTS-Plain64

(Mobiﬂage)

Key-
length
(bits)
N/A

Speed
(KB/s)
Nexus S
5880±260

Speed
(KB/s)
Xoom

4767±238

128

5559±76

4168±186

512

5288±69

3929±146

Table 2: Read/write performance comparison

hidden volume may cause the adversary to suspect the ex-
istence of additional hidden volumes. If they can hold the
user indeﬁnitely, then they can continue to demand keys. It
may in fact hinder the user to reveal any hidden volumes in
this situation. However, irrespective of multiple hidden vol-
umes, the adversary can keep punishing a suspect up until
the true password is revealed. This is an inherent limitation
of PDE schemes and may be alleviated (to some extent) by
using a special password to make the hidden data perma-
nently inaccessible (cf. [15]).

8 Performance Evaluation

To understand the performance impact on the regular use
of a device, we run several tests on our prototype implemen-
tation of Mobiﬂage. This section summarizes our ﬁndings.
We use Mobiﬂage on Nexus S and Motorola Xoom de-
velopment devices by reading from and writing to the SD
card. The command-line tool cp is used to duplicate ﬁles
on the SD card. We run 20 trials on four ﬁles between 50MB
and 200MB. We evaluate the performance on unencrypted
storage, under the default Android encryption, and the Mob-
iﬂage scheme. Table 2 summarizes our results.

Note that, removable SD storage (as in the Xoom) is ap-
parently much slower than eMMC storage (as in the Nexus
S), for all cases. Compared to the unencrypted case, on our
Nexus S, Mobiﬂage reduces IO throughput by almost 10%;
in contrast, Android FDE reduces the throughput by 5.5%.
On the Motorola Xoom, Mobiﬂage reduces throughput by
17.6% and Android FDE by 12.6%. Mobiﬂage seems to de-
crease throughput by roughly 5% over Android FDE. How-
ever, the decreased IO throughput is negligible for regular
apps and should not hinder the use of the device. For ex-
ample, a standard deﬁnition 30fps video ﬁle may have a
combined audio/video bit-rate of 192 KBps. High deﬁni-
tion video (e.g., Netﬂix) is generally below 1024 KBps. The
reduced speed of Mobiﬂage (3929 KBps) will still provide
adequate buffering to ensure that jitter will not be an issue in
these video apps. Note that Blu-ray has a maximum bitrate
of 5000 KBps and may cause playback issues, if it is not
ﬁrst re-encoded. The observed decrease in throughput may

be attributed to the chosen cipher: XTS requires two AES
operations per block; and AES-256 uses fourteen rounds of
operations while AES-128 uses ten.

Android apps are ﬁrst loaded into RAM and do not run
directly off the disk. Mobiﬂage should not affect run time
performance of apps. The increase in app load time should
also be practically negligible; as of Sept. 2012, the aver-
age Android app size is about 6MB [24], although the size
of certain apps (e.g., gaming) is increasing rapidly. Some
hardware, such as the camera, may use direct memory ac-
cess (DMA) and may be affected: instead of writing directly
to the disk, the camera data is processed by the CPU when
passing through the dm-crypt layer. We tested the camera
on our Nexus S device while in the Mobiﬂage PDE mode,
and did not notice any performance impact.

The required time to encrypt the device is increased on
account of the two pass random wipe. The exact time will
depend on the size of the external storage partition. Android
FDE encrypts external eMMC partitions in-place. As such,
Mobiﬂage will take twice as long to encrypt these partitions.
Removable SD cards are not encrypted by Android FDE, so
we cannot provide a static comparison. Our Nexus S has
only 1GB internal, and 15GB eMMC external storage. Af-
ter three initializations, we found that on average the default
Android FDE required one hour and ﬁve minutes, and Mob-
iﬂage required just under two hours. The Motorola Xoom
required one hour and ﬁfteen minutes on average for the
default Android FDE to encrypt the 32GB internal storage.
Encrypting with Mobiﬂage required an additional 73 min-
utes when used with a 8GB SanDisk SD card.

Power consumption will likely be increased for disk ac-
tivity. This problem is inherent to all FDE, and is not unique
to Mobiﬂage. Background processes that have high IO
activity should be disabled, or IO should be buffered and
batched to reduce power consumption.

9 Related Work

In this section, we discuss deniable encryption imple-
mentations related to Mobiﬂage, and provide an overview of
available data encryption support as built into major desktop
and mobile OSes. For details on deniable-storage proposals,
see Appendix A. Several new ciphers, or enhancements to
existing ciphers, have been proposed to create PDE schemes
(e.g., [6, 35, 14, 29]). However, most of these proposals
strive to enable PDE in network communications, and are
not directly applicable to storage encryption.

All major desktop OSes now offer storage encryption
with FDE support (e.g., Windows BitLocker, Mac OS X Fil-
eVault, and Linux eCryptfs). FDE uses ciphers to encrypt
entire storage devices or partitions thereof. Encryption is
performed on small units, such as sectors or clusters, to al-
low random access to the disk. FDE subsystems typically

exist at or below the ﬁle system layer and provide trans-
parent functionality to the user. FDE schemes generally
focus on providing strong conﬁdentiality, making efﬁcient
use of the storage media (i.e., no excessive data expansion),
and being relatively fast (i.e., no signiﬁcant decrease in IO
throughput). PDE adds another layer of secrecy over FDE.

Most mobile OSes also offer data encryption (but no
PDE). BlackBerry devices use a password derived key to
encrypt an internal storage AES key, and an ECC private
key [39]. When a device is locked, the storage and ECC
keys are wiped from RAM. Any messages received while
the device is locked are encrypted with the ECC public key,
and decrypted after unlock. Removable storage can also be
encrypted. Per-ﬁle keys are generated and wrapped with a
password derived key, and/or a key stored in the internal
storage. iOS devices use a UID (device unique identiﬁer)
derived key to encrypt ﬁle system meta-data, effectively ty-
ing the encrypted storage to a particular device [2]. Per-ﬁle
keys are stored in this meta-data and used to encrypt ﬁle
contents. File keys can be wrapped with a UID derived key,
or a UID and password derived key, depending on the sit-
uation (e.g., if the ﬁle must be opened while the device is
locked, only a UID key is used). Unlike the transparency
afforded by FDE, app developers must explicitly call the
encryption API to protect app data [47]. The advantage of
ﬁle based encryption over FDE is that the device is actually
encrypted when the screen is locked (i.e., keys are wiped
from RAM). Older Android 2.3 (Gingerbread) devices can
make use of third party software (e.g., WhisperCore [51]) to
encrypt the device storage. WhisperCore enhances the raw
ﬂash ﬁle system, YAFFS2, which has been superseded on
current Android devices in favor of the Ext4 ﬁle system.

Disk encryption software such as TrueCrypt [46] and
FreeOTFE [17] use hidden volumes for plausible deniabil-
ity. TrueCrypt offers encryption under several ciphers in-
cluding AES, TwoFish, Serpent, and cascades of these ci-
phers in the XTS mode. On Windows systems, TrueCrypt
can encrypt the OS system partition. A special boot loader
is used to obtain the user’s password and decrypt the disk
before the OS is loaded. On Linux systems, similar func-
tionality can be achieved using an early user-space RAM
disk. This is not a straightforward solution for Android de-
vices since the soft keyboard mechanism required to obtain
the password is part of the OS framework and not immedi-
ately available on boot. A custom bootloader, implementing
a soft keyboard, would be needed to capture the password
(cf. [42]). The dm-crypt volume could then be mounted be-
fore loading the Android framework. We choose instead to
work with the existing Android technique of partially load-
ing the framework to access the built-in keyboard.

TrueCrypt volumes contain a header at the very begin-
ning of a volume. All ﬁelds in the header are either ran-
dom data (e.g., salt) or are encrypted, giving the appearance

of uniform random data for the entire volume. Unlike An-
droid FDE, the cipher speciﬁcation is not stored. Therefore,
when a TrueCrypt volume is loaded, all supported ciphers
and cascades of ciphers, are tried until a certain block in the
header decrypts to the ASCII string “TRUE”. The header
key is derived from the user’s passphrase using PBKDF2.
If the header key successfully decrypts the ASCII string,
then it is used to decrypt the master volume key, which is
chosen at random during the volume’s creation.

A secondary header, adjacent to the primary header, is
used when a hidden volume exists. The secondary header
contains the same ﬁelds as the primary header, along with
the offset to the hidden partition. When mounting a True-
Crypt volume, the hidden header is tested before the pri-
mary header. To combat leakage, when using hidden vol-
umes, TrueCrypt recommends the use of a hidden OS. The
hidden OS is currently only an option for the Windows im-
plementation. When encrypting a system volume for use
with PDE, TrueCrypt creates a second partition and copies
the currently installed OS to the hidden volume within. The
user should only mount hidden volumes when booted into a
hidden OS, to ensure that any OS/application-speciﬁc leak-
age stays within a deniable volume (e.g., logs, page ﬁle,
hibernation ﬁle). When booted into a hidden OS, all un-
encrypted volumes and non-hidden encrypted volumes are
mounted read-only. The alternative to a hidden OS for
Linux, is to use a live CD when mounting hidden volumes.
A hidden OS is not necessary in Mobiﬂage since the system
volume on an Android device is mounted read-only, and we
attach hidden volumes, or RAM disks, to all mutable vol-
ume mount-points to prevent leakage.

There is a recent effort to port TrueCrypt to Android [8].
The current version (Dec. 2012) provides a command-line
utility to create and mount TrueCrypt volume-container
ﬁles (for rooted devices with LVM and FUSE kernel sup-
port). Hidden volumes are possible within these container
ﬁles; but FDE/pre-boot authentication is not currently sup-
ported. Several leakage vectors also remain unaddressed
(e.g., through ﬁle system structures, software logs, and net-
work interfaces).

Other Linux deniable implementations, such as Rubber-
hoseFS [3], and Magikfs,7 employ techniques similar to
StegFS for hiding data in ﬁle system free space; see Ap-
pendix A. Several of these projects are no longer main-
tained and existing implementations are also mostly incom-
patible with the modern Linux OS. The presence of special-
ized ﬁle system drivers designed to hide data would be a red
ﬂag to an adversary.

7Magikfs http://magikfs.sourceforge.net/

10 Concluding Remarks

Mobile devices are increasingly being used for captur-
ing and spreading images of popular uprisings and civil
disobedience. To keep such records hidden from authori-
ties, deniable storage encryption may offer a viable techni-
cal solution. Such PDE-enabled storage systems exist for
mainstream desktop/laptop operating systems. With Mobi-
ﬂage, we explore design and implementation challenges of
PDE for mobile devices, which may be more useful to reg-
ular users and human rights activists. Mobiﬂage’s design
is partly based on the lessons learned from known attacks
and weaknesses of desktop PDE solutions. We also con-
sider unique challenges in the mobile environment (such as
ISP or wireless carrier collusion with the adversary). To ad-
dress some of these challenges, we need the user to comply
with certain requirements. We compiled a list of rules the
user must follow to prevent leakage of information that may
weaken deniability. Even if users follow all these guide-
lines, we do not claim that Mobiﬂage’s design is completely
safe against any leaks (cf. [10]). We want to avoid giving
any false sense of security. We present Mobiﬂage here to
encourage further investigation of PDE-enabled mobile sys-
tems. Source code of our prototype implementation is avail-
able on request.

Acknowledgements

We are grateful to our shepherds William Enck and Thomas
Ristenpart, and anonymous NDSS2013 reviewers for their
insightful suggestions and advice. We also appreciate the
helpful feedback from Jeremy Clark and David Barrera. We
thank members of the Concordia’s Computer Security Lab
for their enthusiastic discussion on this topic. The second
author is supported in part by an NSERC Discovery Grant
and Concordia University Start-up Program.

References

[1] R. Anderson, R. Needham, and A. Shamir. The stegano-
graphic ﬁle system. In International Workshop on Informa-
tion Hiding (IH’98), Portland, Oregon, USA, 1998.

[2] Apple.

iOS security. Technical document (May 2012).

http://images.apple.com/ipad/business/docs/iOS Security
May12.pdf.

[3] J. Assange, R.-P. Weinmann, and S. Dreyfus. Rubberhose:
Cryptographically deniable transparent disk encryption sys-
tem. Project website: http://marutukku.org/.

[4] X. Boyen. Halting password puzzles: Hard-to-break en-
cryption from human-memorable keys. In USENIX Security
Symposium, Boston, MA, USA, 2007.

[5] M. Broz and A. G. Kergon.

dm-crypt:

option-
Patch documentation
https://github.com/torvalds/linux/commit/

ally support discard requests.
(Aug.
772ae5f54d69c38a5e3c4352c5fdbdaff141af21.

2011).

[6] R. Canetti, C. Dwork, M. Naor, and R. Ostrovsky. Deniable
encryption. In CRYPTO’97, Santa Barbara, CA, USA, 1997.
[7] comScore. comScore reports September 2012 U.S. mobile

subscriber market share. Press release (Nov. 2, 2012).

[8] Cryptonite. EncFS and TrueCrypt on Android. Open-source

project (2012). https://code.google.com/p/cryptonite/.

[9] cryptsetup. Setup virtual encryption devices under dm-crypt
Linux. Online document (July 2012). https://code.google.
com/p/cryptsetup/wiki/FrequentlyAskedQuestions.

[10] A. Czeskis, D. J. S. Hilaire, K. Koscher, S. D. Gribble,
T. Kohno, and B. Schneier. Defeating encrypted and de-
niable ﬁle systems: TrueCrypt v5.1a and the case of the tat-
tling OS and applications.
In USENIX Workshop on Hot
Topics in Security (HotSec’08), San Jose, CA, USA, 2008.

[11] Dailymail.co.uk. Government spy programme will monitor
every phone call, text and email... and details will be kept
for up to a year. News article (Feb. 20, 2012).

[12] DMCrypt. dm-crypt: Linux kernel device mapper crypto
target. Online document (July 2012). https://code.google.
com/p/cryptsetup/wiki/DMCrypt.

[13] D. Dolev and A. C. Yao. On the security of public key proto-
cols. IEEE Transactions on Information Theory, 29(2):198–
208, Mar. 1983.

[14] M. D¨urmuth and D. Freeman. Deniable encryption with neg-
ligible detection probability: An interactive construction. In
Eurocrypt, Tallinn, Estonia, 2011.

[15] EKR. Protecting your encrypted data in the face of coercion.
Blog post (Feb. 11, 2012). http://www.educatedguesswork.
org/2012/02/protecting your encrypted data.html.

[16] N. Ferguson, B. Schneier, and T. Kohno. Cryptography En-
gineering: Design Principles and Practical Applications.
Wiley Publishing, Mar. 2010.

[17] FreeOTFE. FreeOTFE - Free disk encryption software for
PCs and PDAs. Version 5.21 (Nov. 2012). http://www.
freeotfe.org/.

[18] C. Fruhwirth. New methods in hard disk encryption. Tech-
nical report, Vienna University of Technology (July 2005).
http://clemens.endorphin.org/nmihde/nmihde-A4-ds.pdf.

[19] C. Fruhwirth. TKS1 – an anti-forensic, two level, and it-
erated key setup scheme. Online manuscript (july 2004).
http://clemens.endorphin.org/TKS1-draft.pdf.

[20] J. A. Halderman, S. D. Schoen, N. Heninger, W. Clarkson,
W. Paul, J. A. Calandrino, A. J. Feldman, J. Appelbaum,
and E. W. Felten. Lest we remember: Cold boot attacks on
encryption keys. In USENIX Security Symposium, San Jose,
CA, USA, 2008.

[21] J. Han, M. Pan, D. Gao, and H. Pang. A multi-user stegano-
graphic ﬁle system on untrusted shared storage. In Annual
Computer Security Applications Conference (ACSAC’10),
Orlando, Florida, USA, 2010.

[22] A. Hoog. Android Forensics: Investigation, Analysis, and
Mobile Security for Google Android. Syngress (Elsevier),
June 2011.

[23] IEEE Computer Society. IEEE standard for cryptographic
protection of data on block-oriented storage devices. IEEE
Std 1619-2007 (Apr. 2008).

[24] ITProPortal. Android and iOS app sizes rise dramatically.
News article (Oct. 18, 2012). http://www.itproportal.com/
2012/10/18/android-and-ios-app-sizes-rise-dramatically/.

[25] JEDEC. eMMC card product std v4.41 (JESD84-A441).
Technical speciﬁcation (Mar. 2010). http://www.jedec.org/
sites/default/ﬁles/docs/JESD84-A441.pdf.

[26] B. Kaliski. PKCS #5: Password-based cryptography speci-
ﬁcation, version 2.0, Sept. 2000. RFC 2898 (informational).
[27] kernel.org. Ext4 disk layout. Online document (July 2012).

https://ext4.wiki.kernel.org/index.php/Ext4 Disk Layout.

[28] kernel.org. Ext4 speciﬁcation. Online document (July
http://kernel.org/doc/Documentation/ﬁlesystems/

2012).
ext4.txt.

[29] M. Klonowski, P. Kubiak, and M. Kutyowski. Practical de-
niable encryption. In Theory and Practice of Computer Sci-
ence (SOFSEM’08), Novy Smokovec, Slovakia, 2008.

[30] B.-J. Koops. Crypto law survey: Overview per country. On-
line document (version 26.0, July 2010). http://rechten.uvt.
nl/koops/cryptolaw/cls2.htm.

[31] H. Krawczyk. Cryptographic extraction and key derivation:
In CRYPTO’10, Santa Barbara, CA,

The HKDF scheme.
USA, 2010. Also published as RFC 5869.

[32] A. D. McDonald and M. G. Kuhn. StegFS: A steganographic
ﬁle system for Linux. In International Workshop on Infor-
mation Hiding (IH’99), Dresden, Germany, 2000.

[33] R. M. Needham and M. D. Schroeder. Using encryption for
authentication in large networks of computers. Communica-
tions of the ACM, 21(12):993–999, 1978.

[34] NIST. Recommendation for block cipher modes of oper-
ation: The XTS-AES mode for conﬁdentiality on storage
devices. NIST Special Publication 800-38E (Jan. 2010).

[35] A. ONeill, C. Peikert, and B. Waters. Bi-deniable public-key
encryption. In CRYPTO’11, Santa Barbara, CA, USA, 2011.
[36] H. Pang, K. lee Tan, and X. Zhou. StegFS: A steganographic
ﬁle system. In International Conference on Data Engineer-
ing (ICDE’02), San Jose, CA, USA, 2002.

[37] C. Percival. Stronger key derivation via sequential memory-
hard functions. In BSD Conference (BSDCan’09), Ottawa,
Canada, 2009.

[38] J. Reardon, S. Capkun, and D. Basin. Data node encrypted
ﬁle system: Efﬁcient secure deletion for ﬂash memory. In
USENIX Security Symposium, Bellevue, WA, USA, 2012.

[39] RIM. Blackberry enterprise server 5.0.2–security techni-
cal overview. Technical document (Mar. 2011). http://docs.
blackberry.com/en/admin/deliverables/16648/.

[40] P. Rogaway. Nonce-based symmetric encryption. In Work-
shop on Fast Software Encryption (FSE’04), volume 3017
of LNCS, pages 348–358, Delhi, India, 2004.

[41] SD Card Association. Physical layer simpliﬁed speciﬁcation
ver3.01. Technical speciﬁcation (May 2010). https://www.
sdcard.org/downloads/pls/simpliﬁed specs/.

[42] TeamWin. TeamWin recovery project (TWRP). Version

2.3.1 http://teamw.in/project/twrp2.

[43] TheRegister.co.uk. UK jails schizophrenic for refusal to
decrypt ﬁles. News article (Nov. 24, 2009). http://www.
theregister.co.uk/2009/11/24/ripa jﬂ/.

[44] TheRegister.co.uk. Youth jailed for not handing over en-
cryption password. News article (Oct. 6, 2010). http://www.
theregister.co.uk/2010/10/06/jail password ripa/.

[45] Toronto Star. How a Syrian refugee risked his life to bear
witness to atrocities. News article (Mar. 14, 2012). http://
www.thestar.com/news/world/article/1145824.

[46] TrueCrypt. Free open source on-the-ﬂy disk encryption soft-

ware. Version 7.1a (July 2012). http://www.truecrypt.org/.

[47] K. Wadner.

iOS security.

Technical document (July
2011). http://www.sans.org/reading room/whitepapers/pda/
security-implications-ios 33724.

[48] B. Wallace. Transferable state attack on iterated hashing
functions. Tech. document (July 2012). http://ﬁrebwall.com.
[49] M. Wei, L. M. Grupp, F. E. Spada, and S. Swanson. Reliably
erasing data from ﬂash-based solid state drives. In USENIX
File and Storage Technologies (FAST’11), San Jose, CA,
USA, 2011.

[50] R.-P. Weinmann. Baseband attacks: Remote exploitation of
memory corruptions in cellular protocol stacks. In USENIX
Workshop on Offensive Technologies (WOOT’12), Bellevue,
WA, USA, 2012.

[51] WhisperSystems. WhisperCore: Device and data protection
for Android. Beta version (0.5.5). http://whispersys.com/
whispercore.html.

[52] X. Zhou, H. Pang, and K.-L. Tan. Hiding data accesses in
steganographic ﬁle system. In International Conference on
Data Engineering (ICDE’03), Bangalore, India, 2003.

A Deniable Storage Encryption Proposals

File encryption schemes with PDE support, called
steganographic ﬁle systems, have been ﬁrst proposed by
Anderson et al. [1]. One of their solutions uses a series
of cover ﬁles initially ﬁlled with random data, and assumes
the attacker has no knowledge of the plaintext content of a
ﬁle. The hidden ﬁles are embedded by modifying and XOR-
ing a linear combination of some cover ﬁles. The password
and ﬁle name are used to determine which cover ﬁles are
used. This solution requires storing a large number of cover
ﬁles (e.g., 1000); also, these ﬁles must be relatively large
to accommodate ﬁles of arbitrary length. The second solu-
tion [1] is built on existing block ciphers. The disk is ini-
tially ﬁlled with random data. Files are then stored at disk
block addresses derived from the ﬁle name and password
(e.g., using a hash function). The ﬁles are encrypted with a
key derived in a similar manner. An adversary would not be
able to distinguish between empty blocks and blocks con-
taining hidden ﬁles. However, as discussed [1], the prob-
ability of ﬁle blocks colliding increases as disk blocks are
ﬁlled. As a mitigation, writing each block to several disk
locations has been suggested. However, high storage and
IO overhead of these solutions make them less suitable for
performance-sensitive mobile devices.

StegFS [32] is an Ext2 based ﬁle system inspired by the
second approach of Anderson et al. [1]. It uses several se-
curity levels (up to 15), each with a separate password. Its
deniability relies on how many levels of hidden ﬁles are

present, not on denying the fact that hidden ﬁles exist. An
external block allocation table (stored in the non-deniable
disk space) with entries for each disk block is used. When
a given security level is closed, there is no way to prevent
overwriting that level’s blocks, so redundant blocks are used
to mitigate collisions. The existence of the modiﬁed Ext2
driver, and the external block table, would indicate that PDE
is in use. The project website8 explains that only 6% of the
storage space can actually be used for ﬁle storage, as the
rest is used for meta-data and collision avoidance. Also, as
hidden and regular ﬁles are present on the same ﬁle system,
data leakage may occur when security levels are open.

Other StegFS-based systems improve efﬁciency and re-
liability of the original implementation. Pang et al. [36]
design a system where blocks used by hidden ﬁles are in
fact marked as occupied in the block bitmap. This allevi-
ates reliability issues and IO inefﬁciencies, as storing mul-
tiple copies of a block is not required. Hidden ﬁles do not
have a directory record in the standard inode table. Since
the blocks are marked as used, but not referenced in a di-
rectory entry, the adversary can conjecture that hidden ﬁles
exist. The adversary can also estimate the amount of disk
space utilized by hidden ﬁles. Three mechanisms are used
to frustrate such estimation. Some empty or “abandoned”
blocks are marked as used even though they do not con-
tain hidden data. When a new hidden ﬁle is created, several
blocks are allocated that are not actually ﬁlled with ﬁle data.
Dummy hidden ﬁles are created and periodically updated
in the background to prevent snapshot analysis from deter-
mining the exact blocks used by hidden ﬁles. These mech-
anisms make it more difﬁcult to determine which blocks
actually store hidden data, but are not disk space efﬁcient.

Further work [52] expands the above idea by adding
dummy transactions to obscure hidden ﬁles in net-
work/cloud storage. This improves reliability and IO efﬁ-
ciency, but disk space utilization for dummy ﬁles and aban-
doned blocks remains a concern, especially for resource
constrained mobile devices. Also, strong deniability can-
not be offered as the adversary is aware that hidden ﬁles
exist. Deniability is a result of an adversary being unable to
determine how much space is used by hidden ﬁles.

The dummy-relocatable steganographic (DRSteg [21])
ﬁle system is proposed for use in multi-user environments.
DRSteg adds dynamic updating to dummy ﬁles to prevent
snapshot analysis. When coerced, a user can provide some
of their hidden ﬁle passwords and blame the additional hid-
den storage on dummy ﬁles and other users’ hidden ﬁles.
However, the adversary is still aware that hidden ﬁles exist.

8StegFS https://albinoloverats.net/projects/stegfs

