2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy

Key Conﬁrmation in Key Exchange:

A Formal Treatment and Implications for TLS 1.3

Marc Fischlin

Felix Günther

Cryptoplexity, Technische Universität Darmstadt

Darmstadt, Germany

Benedikt Schmidt

IMDEA Software Institute

Madrid, Spain

Bogdan Warinschi
University of Bristol

Bristol, UK

marc.ﬁschlin@cryptoplexity.de, guenther@cs.tu-darmstadt.de

benedikt.schmidt@imdea.org

csxbw@bristol.ac.uk

Abstract—Key exchange protocols allow two parties at remote
locations to compute a shared secret key. The common security
notions for such protocols are secrecy and authenticity, but
many widely deployed protocols and standards name another
property, called key conﬁrmation, as a major design goal. This
property should guarantee that a party in the key exchange
protocol is assured that another party also holds the shared
key. Remarkably, while secrecy and authenticity deﬁnitions have
been studied extensively, key conﬁrmation has been treated rather
informally so far.

In this work, we provide the ﬁrst rigorous formalization of
key conﬁrmation, leveraging the game-based security framework
well-established for secrecy and authentication notions for key
exchange. We deﬁne two ﬂavors of key conﬁrmation, full and
almost-full key conﬁrmation, taking into account the inevitable
asymmetry of
to the
transmission of the ﬁnal protocol message. These notions capture
the strongest level of key conﬁrmation reasonably expectable for
the two communication partners of the key exchange.

the parties with respect

the roles of

We demonstrate the beneﬁts of having precise security deﬁni-
tions for key-conﬁrmation by applying them to the next version
of the Transport Layer Security (TLS) protocol, version 1.3,
currently developed by the Internet Engineering Task Force
(IETF). Our analysis shows that the full handshake as speciﬁed
in the TLS 1.3 draft draft-ietf-tls-tls13-10 achieves
desirable notions of key conﬁrmation for both clients and servers.
While key conﬁrmation is generally understood and in the
TLS 1.3 draft described as being obtained from the Finished
messages exchanged,
interestingly we can show that the full
TLS 1.3 handshake provides key conﬁrmation even without those
messages, shedding a formal
light on the security properties
different handshake messages entail.

We further demonstrate the usefulness of rigorous deﬁnition
by revisiting a folklore approach to establish key conﬁrmation
(as discussed for example in SP 800-56A of NIST). We provide a
formalization as a generic protocol transformation and show that
the resulting protocols enjoy strong key conﬁrmation guarantees,
thus conﬁrming its beneﬁcial use in both theoretical and practical
protocol designs.

I. INTRODUCTION

Key exchange is one of most widely deployed cryptographic
protocols to date, bootstrapping conﬁdential and authenticated
data exchange in virtually any secure communication protocol.
The most basic security properties are key secrecy and entity
authentication: the former property guarantees that no other
party learns information about
the key whereas the later
ensures that the key is shared with the intended partner. The
seminal work of Bellare and Rogaway [4] provided rigorous

2375-1207/16 $31.00 © 2016 IEEE
© 2016, Marc Fischlin. Under license to IEEE.
DOI 10.1109/SP.2016.34
DOI 10.1109/SP.2016.34

452
452

security deﬁnitions for these two notions and thus grounded
the design and analysis of such protocols on solid foundations.
The huge body of follow-up work reﬁned, extended, and ap-
plied their results. These include extensions to the asymmetric
setting [8], more reﬁned attacker models [14], dealing with
different variants of entity authentication [28], etc. There is
also a large body of work, e.g., [22], [24], [7], [5], [18],
applying and extending these results to real-world security
protocols such as TLS [17] or SSH [32].

A. Key Conﬁrmation

An intuitively desirable security property that has so far
escaped a rigorous treatment is key conﬁrmation: the idea that
when a party accepts locally a key, it has the guarantee that
some other party has precisely the same key. The property
is often mentioned in scientiﬁc papers on the subject of
key exchange [3], [23], [25] but the typical reference for a
deﬁnition is the “Handbook of Applied Cryptography” [27,
Deﬁnition 12.7] which describes key conﬁrmation as the
property

“whereby one party is assured that a second
(possibly unidentiﬁed) party actually has possession
of a particular secret key.”

Other references include the reﬁnement proposed by Blake-
Wilson and Menezes [9], [10] who further distinguish between
explicit key conﬁrmation, where one party is assured that the
other party holds the key, and implicit key conﬁrmation, where
the other party can compute the key.

One may speculate that the reason for a lack of rigorous
deﬁnitions is that absence of key conﬁrmation does not seem to
open parties to attacks: a party may send messages encrypted
with an (unconﬁrmed) key which no-one can decrypt. This
may be a waste of resources but not an obvious security
risk. Another possibility is that it might seem “clear” when a
protocol has key conﬁrmation, so a formal deﬁnition appears
to be an overkill. For example, protocols like TLS 1.2 [17]
and EMV [20] utilize the derived key during the execution
of the protocol, so receiving a a message encrypted with the
shared key provides key-conﬁrmation assurances.

This level of informal understanding is also reﬂected by
other folklore protocol transformations that can boost a se-
cure key exchange protocol to also provide key conﬁrmation

guarantees. A popular proposal (which we refer to as “refresh-
then-MAC”) is to extend a key exchange protocol as follows:
use the established key ﬁrst to derive two additional keys; the
ﬁrst will be set as the session key whereas the latter will be
used to compute a message authentication code (MAC) value
over the transcript of the protocol so far. Exchanging valid
MACs should then guarantee that parties have also locally
computed the associated session key.

The status of key conﬁrmation as an important security
property is still unclear. On the one hand, some practition-
ers seem to be convinced that key conﬁrmation messages
(messages that use the key derived to ensure that the parties
have agreed on the same key) do improve authentication1, yet
others struggle to understand the beneﬁts that key conﬁrmation
messages bring to protocols2. Nevertheless, many security
protocol speciﬁcations name key conﬁrmation as an explicit
goal to achieve, including, e.g., the recommendations for key
establishment schemes by NIST [2], [1], [21], or the draft
speciﬁcations for the next TLS version 1.3 [29].

This paper is motivated by the observation that any serious
discussion of this issue is moot in the absence of clear security
deﬁnitions and that such deﬁnitions should also ground design
decisions and security analysis which nowadays simply rely on
the type of lore outlined above. To support the argument, note
that the recommendation of NIST concerning key conﬁrmation
in [2], [1] basically follows the informal deﬁnition above,
ignoring that one of the protocol participants must accept ﬁrst
and thus gets a different strength of conﬁrmation guarantee
than the one accepting last.

B. Our Results

SECURITY DEFINITIONS. We propose security deﬁnitions (in
Section III) that aim to capture the established intuition behind
key conﬁrmation. First, we note that we do not attempt to
distinguish between explicit and implicit key conﬁrmation:
distinct computational interpretation to “has the key” and “can
compute the key” seem difﬁcult to provide. This follows the
line of reasoning by Blake-Wilson and Menezes [9] who argue
that “for all practical purposes, the assurances [of implicit and
explicit key conﬁrmation] are in fact the same,” especially
since one cannot guarantee that a party forgets a key between
its derivation and its ﬁrst time usage.

Second, it is clear that key conﬁrmation guarantees are
asymmetric: the party that receives the last message obtains the
stronger guarantees; such guarantees do not hold for the party
that sends the last message since the message can be dropped
by an adversary. Accordingly, we distinguish between full
key conﬁrmation and almost-full key conﬁrmation. The former
property guarantees that when a party accepts a key, there
exists some other party that has already accepted precisely
that key. The latter property ensures that when a party accepts

1Adam Langley publicly proclaimed at

the Real World Cryptography
Workshop (RWC) 2014: “Key-conﬁrmation messages are here to stay.” [26]
2See the discussion on the TLS mailing list [31] on removing the conﬁr-

mation message from the design of TLS.

a key, there is some session which, if it accepts, then it accepts
the same key. Formalizing sound key conﬁrmation notions
turns out to be more challenging than one might expect given
the common informal understanding: As we explain later in the
paper, although we rely on compelling intuition, the deﬁnitions
need to be carefully crafted to avoid some potential pitfalls
which we outline.

A prime feature of our deﬁnitions is modularity. Following
Blake-Wilson and Menezes [9] as well as NIST [2], [1], we
chose to disentangle key conﬁrmation from the other security
concerns speciﬁc to key exchange. In particular, our notion
only ensures that there exists some party that accepted the
same key: the notion does not guarantee that it is the expected
communication partner. However, the desired property follows
by combining key conﬁrmation and implicit key authentication
(i.e., classical key secrecy with mutually authenticating par-
ties [4]): a protocol with both these properties has explicit key
authentication. Informally, key conﬁrmation can be interpreted
as guaranteeing the lower bound that “at
least one other
(unspeciﬁed) party holds the key” whereas implicit key au-
thentication ensures the upper bound that “at most one (namely
the expected) party holds the key.” Together, the notions entail
explicit key authentication: “exactly the expected party holds
the key.” Note that the deﬁnitional modularity also allows us
to “swap” the key conﬁrmation steps and property in and out,
depending on the protocol’s security requirements (as in the
recommendations of NIST), and to independently argue about
this additional security feature.

the

security
APPLICATION TO TLS. We use the rigorous
that we develop to shed light on the key-
models
recent TLS 1.3 draft
conﬁrmation properties of
draft-ietf-tls-tls13-10 [29] (short: draft-10) in
Section IV. As in previous TLS versions, TLS 1.3 draft-10
leverages Finished messages essentially consisting of a mes-
sage authentication code (MAC) computed over the transcript
of the key exchange and sent both by the client and the server.
It is hence not surprising that our analysis conﬁrms that (the
full, (EC)DHE handshake of) TLS 1.3 indeed achieves the
strongest expectable key conﬁrmation guarantees, i.e., full key
conﬁrmation for the server (which accepts after the client)
and almost-full key conﬁrmation for the client (which accepts
ﬁrst).

Perhaps surprisingly, we show that key conﬁrmation does
not (necessarily) rely on the Finished messages exchanged,
but can actually be shown to hold even in a shortened variant
of the full draft-10 handshake which omits these mes-
sages. This becomes possible due to the CertificateVerify
messages sent in the full draft-10 handshake, which are
essentially an online signature under the parties’ long-term
secret signing keys over (the hash of) all messages exchanged
(i.e., the transcript or “session hash”, as denoted in TLS 1.3).
This result deepens the understanding of the far-reaching
security guarantees achievable with the session hash con-
cept (originally introduced to counter the triple handshake
attack [6]
in TLS 1.2) and online signatures. While it

453453

might at ﬁrst glance seem to open up a discussion of
whether Finished messages become obsolete in presence
of CertificateVerify messages already establishing key
conﬁrmation, we remark that TLS 1.3 draft-10 provi-
sions further, abbreviated handshake variants which omit the
CertificateVerify messages for performance reasons and
fully rely on the Finished messages for key conﬁrmation as
well as authentication.

GENERIC CONSTRUCTION. As explained above, one idea used
to obtain key conﬁrmation deployed in existing protocols is to
somehow explicitly involve the key in the operations of the
key-exchange protocol. This message plays a double role: on
the one hand the MAC “ties” together the messages that belong
to one session. On the other hand, the message is sent over
the channel that is being established, or in other words, it is
encrypted with the session key: receiving this message would
therefore show that the other party already holds the key.

It is by now well-known that unmitigated use of the session
key (for either encrypting or MAC-ing) immediately destroys
key secrecy, and better transformations have been proposed
and used in protocol design. For example, Chen and Kudla
study the impact that such a transformation has on a particular
protocol, but still need to rely on intuition to conclude that the
resulting protocol satisﬁes key conﬁrmation [15]. With precise
deﬁnitions in place, we are in a position where these proposals
can be accurately analyzed.

We deploy our rigorous notions to analyze the popular
“refresh-then-MAC” transformation (also recommended by
NIST [2], [21]) and conﬁrm that the intuition behind the
construction is indeed correct: when applied to a key-exchange
protocol that ensures key secrecy the transformation yields
a protocol which, in addition, also satisﬁes key conﬁrmation
(and preserves (implicit) authentication). Interestingly, as a by-
product of our formalism, we can now also show that the
simpler version where one sends some additionally derived
key material in clear, without computing a MAC, would serve
the same purpose and already provide key conﬁrmation.

II. KEY EXCHANGE PROTOCOLS AND THEIR SECURITY
In this section we deﬁne key exchange protocols and
their security, following essentially the approach of Bellare
and Rogaway [4]. We recall the basic security properties of
key secrecy, i.e., that session keys look random, and Match
security as deﬁned in [13], [12], which guarantees soundness
of session partnering (e.g., that a successful session has a
unique partner session).

In the model we will

introduce the notion of a key-
conﬁrmation identiﬁer kcid, pivotal for our formalization
of almost-full key conﬁrmation. Essentially, once set,
the
identiﬁer kcid ensures that the party will eventually derive
the same key as any other party with that identiﬁer, even
though the party has not accepted and the session identiﬁer
sid has not been set yet. In other words, one may interpret
the setting of the key-conﬁrmation identiﬁer as stating that,
upon receiving the partner’s conﬁrmation message, a session

will have enough information to compute the (same) key. We
elaborate on the choices for setting key-conﬁrmation identiﬁers
in a protocol further when introducing the notion of almost-
full key conﬁrmation that relies on them.

A. Protocol Syntax
We consider two-party protocols where participating parties
belong to either a set of clients C or a set of servers S. Each set
has associated a long-term key generation algorithm KGclient
resp. KGserver (one of these algorithms can be trivial, for the
case when a set of parties does not have long term keys). We
let I = C ∪ S denote the set of all identities in the system.
Our focus is on key exchange protocols which are deﬁned
by an (interactive) program Π that parties execute locally.
the program maintains a state st =
Between invocations,
(crypt, status, role, id, pid, sid, kcid, key), where the different
components are as follows:
• crypt ∈ {0, 1}∗ is some protocol-speciﬁc state, e.g.,
secret Difﬁe-Hellman values. It will be set to the par-
ticipants cryptographic keys upon initialization.
• status ∈ {accept, reject,⊥} is a variable that indicates
the status of the key-exchange phase. Initially, status =⊥
and may change to accept in accepted executions, or
reject in runs in which the party rejects. We assume
that once the status has been set to accept or reject,
the value does not change anymore and the adversary
immediately learns the value of status.
• role ∈ {client, server} is the role of the participant.
If id ∈ C then role = client and if id ∈ S then role =
server.
• id ∈ I is the identity of the party that “owns” this session.
• pid is a partner identiﬁer which is assigned a value in
I ∪ {⊥,∗} once, where initially pid = ⊥. We use ∗ to
indicate an unspeciﬁed identity for the case when that
party does not have long term keys, and use pid = i for
some i ∈ I, otherwise3.
• sid ∈ {0, 1}∗ ∪ {⊥} is a session identiﬁer, initialized
to ⊥ and then set upon changing to accepting status
status = accept. Once it is set to some string, sid cannot
be changed anymore. We assume throughout the paper
that session identiﬁers are public in the sense that they
are determined by the incoming and outgoing messages
for that sessions.
• kcid ∈ {0, 1}∗ ∪ {⊥} is a so-called key-conﬁrmation
identiﬁer, initialized to ⊥ and usually set at some point
during the execution.
• key ∈ {0, 1}∗ ∪ {⊥} is the key locally derived in this
session, also called session key. Here, key may consist of
multiple elements, e.g., one key for encryption and one
key for authentication. Initially the session key is set to
⊥. We assume that a key is set upon changing to the
accepting status status = accept.

3We work therefore in the post-speciﬁed peer setting where, as is the case
of TLS, the owner of a potentially partnered session is determined on the ﬂy.
The pre-speciﬁed peer setting can be easily obtained by demanding that pid
is set as soon as a session starts its execution.

454454

Formally, the program Π is a function which takes a state
(cid:3)
st as above, an input message m, and returns a new state st
and a message m(cid:3). Given some state st and a message m we
(cid:3), m(cid:3)) ← Π(st, m) for one step in the execution of
write (st
(cid:3)
the protocol that processes message m to yield a new state st
and an answer m(cid:3).
B. Security Model

We ﬁrst describe the execution model in which the adversary

interacts with the participants, all running protocol Π.
EXECUTION MODEL. Initially, all parties i ∈ I generate long-
term keys by running either KGclient or KGserver, depending
on their role.4 They store the secret keys ski for further use,
and the adversary gets to learn the public keys pki of all
participants i ∈ I.
As usual, we assume that the adversary A controls the
communication network. The adversary runs an execution of
multiple instances of protocol Π, starting a new session of
party i ∈ I by calling a NewSession oracle for i. This
immediately creates a globally unique administrative label (cid:2),
and a freshly initialized state st for the party. We denote the
individual components of that session by (cid:2).crypt, (cid:2).status,
(cid:2).role etc. Note that this sets (cid:2).id = i and (cid:2).role accordingly,
and all other components are initialized as described above.
The adversary can now interact with this new session Π(cid:2)
i
of the protocol Π via the label (cid:2). We note that different
options are possible for how the intended peer of the session
is speciﬁed. The adversary can specify (cid:2).pid upon session
creation (yielding the pre-speciﬁed peer setting) or leave it
undeﬁned (yielding the post-speciﬁed peer setting).

(cid:3), and returns m(cid:3)

The adversary may deliver messages to sessions using
queries of the form Send((cid:2), m), where (cid:2) is a session label (of
a session which has been initialized before), and m is an ar-
(cid:3), m(cid:3)) ← Π((cid:2).st, m),
bitrary message. The session executes (st
sets the local session state to st
to the
adversary. We assume that the adversary also learns if the
session changes its status (cid:2).status to accept or reject.
The adversary A may corrupt the long-term key of user
i by issuing a query Corrupt(i). The key ski is returned to
the adversary and identity i is added to an initially empty set
Corr of corrupt parties. From now on, the adversary cannot
call oracles related to that party anymore. We call parties in
Corr corrupt, whereas all parties still in I \ Corr are called
honest. We deﬁne the set CorrCl of corrupted clients and the
set CorrSv of corrupted servers as the intersections of Corr
with C and S.

The adversary may learn the session key via query
RevealKey((cid:2)). This returns the session key (cid:2).key to the ad-
versary where, potentially, the key key is still undetermined
yet and equal to ⊥.

Finally, for capturing key secrecy we give the oracle access
to a Test oracle. This oracle is initialized with a secret bit
b ←${0, 1}. Upon querying the oracle with some label (cid:2) it

4Note that we allow, e.g., that client long-term keys are empty or remain

unused to model that clients may not possess long-term secret keys.

455455

returns ⊥ to the adversary if (cid:2).status (cid:7)= accept; otherwise it
returns (cid:2).key if b = 0, or a fresh random key chosen from some
distribution according to the protocol speciﬁcation if b = 1.
The task of the adversary is to determine b. We assume for
simplicity that the adversary can query the Test oracle only
once. This can be extended to the case of multiple queries and
security follows from a hybrid argument for public session
identiﬁers (with some careful consistency stipulations).
PARTNERING. A crucial ingredient for capturing security of
key exchange protocols is the notion of partnering. Roughly
speaking, partnering formalizes which sessions of the protocol
intend to communicate with each other. This notion is neces-
sary to identify trivial attacks in which the adversary reveals
a session key of the intended partner of a tested session. We
follow the paradigm of [3] and deﬁne partnering via session
identiﬁers sid, set by each party in the course of the protocol,
when the status changes to accept.

We now say that two distinct sessions (oracles) in an execu-
tion are partnered if their local session identiﬁer variables have
the same value (different from ⊥). Formally, we use a predi-
cate Partners which has as input two sessions labels (cid:2) and (cid:2)(cid:3)
and evaluates to true if and only if (cid:2).sid = (cid:2)(cid:3).sid (cid:7)= ⊥∧(cid:2) (cid:7)= (cid:2)(cid:3).
Def inition 2.1 (Partnered sessions): Two sessions with
labels (cid:2), (cid:2)(cid:3) are partnered in an execution if Partners((cid:2), (cid:2)(cid:3)) =
true.

Note that, since session identiﬁers can be set only once, two
sessions which are partnered in an execution always remain
partnered.
FRESHNESS. We need to exclude trivial attacks in which the
adversary tests the key of a session and reveals the key of a
partnered session. Since we will later demand that identical
session identiﬁers imply identical keys, the partnered session
will hold the same key and the adversary could easily dis-
tinguish the tested key from random. To identify the sessions
where testing is still admissible we use the freshness predicate
Fresh((cid:2)). This predicate is evaluated at the end of the execution
and yields true if and only if all of the following conditions
hold:

1) (cid:2).status = accept, i.e., the test session has accepted at

if Fresh((cid:2)) = true.

Note that the way we deﬁne the freshness property indicates
that we are not concerned with forward secrecy. That is, no
matter when the party of the session (or a partner) has been

some point.

test session during the execution.

2) The adversary has not issued a query RevealKey((cid:2)) to the
3) (cid:2).id /∈ Corr, i.e., the owner of the test session has not
been corrupted in the execution.
4) For any (cid:2)(cid:3) such that Partners((cid:2), (cid:2)(cid:3)) = true the adversary
has not issued a query RevealKey((cid:2)(cid:3)); no partner of the
tested session has been asked to reveal the session key.
5) (cid:2).pid /∈ Corr and (cid:2).pid (cid:7)= ∗, i.e., the session has not
been partnered with a party (potentially) controlled by
the adversary.

Def inition 2.2 (Freshness): A session with label (cid:2) is fresh

corrupted, it is assumed that this endangers the security of
the session key, even for sessions which have already been
completed.

AUTHENTICATION. Authentication guarantees the identity of
the partner for some session. We consider both one-way
and mutual authentication which we deﬁne formally using
the asymmetric predicate auth((cid:2), (cid:2)(cid:3)). Informally, the predicate
says that session (cid:2) authenticates the owner of session (cid:2)(cid:3) (as
its intended partner). Formally, we deﬁne auth((cid:2), (cid:2)(cid:3)) = true
if and only if (cid:2).pid (cid:7)= ∗ and (cid:2).pid = (cid:2)(cid:3).id. The former
basically demands that some authentication took place and
the latter requires that it points to the intended partner. Mutual
authentication is then expressed as mauth((cid:2), (cid:2)(cid:3)) = auth((cid:2), (cid:2)(cid:3))∧
auth((cid:2)(cid:3), (cid:2)).

We furthermore say a protocol is unilaterally or mutually
authentication if any partnered sessions correctly authenticate
the server resp. both sides. Note that we however do not
formalize (implicit) authentication as a distinguished security
experiment, but follow the common approach to encapsulate
implicit authentication within key secrecy.
Def inition 2.3 ((Implicit) Authentication): A session (cid:2) uni-
laterally authenticates a partnered session (cid:2)(cid:3) if auth((cid:2), (cid:2)(cid:3)) =
true. The sessions (cid:2), (cid:2)(cid:3) authenticate mutually if mauth((cid:2), (cid:2)(cid:3)) =
true.
A key exchange protocol Π provides unilateral resp. mutual
authentication if for all partnered sessions (cid:2), (cid:2)(cid:3) with (cid:2).role =
client and (cid:2)(cid:3).role = server it holds that auth((cid:2), (cid:2)(cid:3)) = true
resp. mauth((cid:2), (cid:2)(cid:3)) = true.

Notice that our notion of freshness above is general enough
to deal with the interplay between authentication and key
secrecy, in that it immediately captures the case of unilateral
authentication when the partner is anonymous (which we
model by setting pid = ∗).

As explained earlier, our model seamlessly treats pre- and

post-speciﬁed partners.

C. Traditional Security Properties

Before we move on to key conﬁrmation, which is the
security notion that is the focus of this work, we recall two
notions, crucial for the security of key exchange protocols.
One is key secrecy, which basically requires that (fresh)
keys look random and are only available to the (implicitly)
authenticated partners; the other one is called Match security
in [13] and, as a counter balance ensuring soundness of
session partnering, captures for example functional properties
such as that partnered sessions derive the same keys, and
security properties such as quasi uniqueness of pairs of session
identiﬁers.

KEY SECRECY. Key secrecy demands that any efﬁcient ad-
versary cannot do signiﬁcantly better than guessing in distin-
guishing actual keys (of fresh sessions) from random.
Def inition 2.4 (Key secrecy): A key exchange protocol Π
provides key secrecy if for any PPT adversary A there exists

a negligible function negl(n) such that
≤ 1
2

Π,A (n) = 1

Expscrcy

Pr

(cid:2)

(cid:3)

+ negl(n)

for the key secrecy experiment in Figure 1.
Match SECURITY. Next we deﬁne Match security. For this we
use a symmetric predicate samekey((cid:2), (cid:2)(cid:3)) which is set to true
if and only if (cid:2).key = (cid:2)(cid:3).key.

Deﬁne the predicate Match which returns true if and only
if all of the following conditions holds.
1) For all sessions (cid:2), (cid:2)(cid:3) with Partners((cid:2), (cid:2)(cid:3)) = true, it holds
that samekey((cid:2), (cid:2)(cid:3)) = true, i.e., partnered sessions derive
the same key.
2) For all sessions (cid:2), (cid:2)(cid:3), (cid:2)(cid:3)(cid:3) with Partners((cid:2), (cid:2)(cid:3)) = true and
Partners((cid:2), (cid:2)(cid:3)(cid:3)) = true, it holds that (cid:2)(cid:3) = (cid:2)(cid:3)(cid:3), i.e., there is
at most one partnered session for each session.
3) For all sessions (cid:2), (cid:2)(cid:3) with Partners((cid:2), (cid:2)(cid:3)) = true, it holds
that (cid:2).role (cid:7)= (cid:2)(cid:3).role, i.e., two partnered sessions adopt the
client-server relationship.
4) For all (cid:2), (cid:2)(cid:3) with Partners((cid:2), (cid:2)(cid:3)) = true, it holds that
auth((cid:2), (cid:2)(cid:3)) or (cid:2).pid = ∗, i.e., the partnered session has the
intended owner (where (cid:2).pid = ∗ allows for an arbitrary
owner).5

The adversary’s attack on Match-security is now similar
to the one against key secrecy, only this time the Test
oracle disappears from the setting, and the experiment ﬁnally
evaluates the predicate Match on the resulting execution state.
The adversary wins if the predicate evaluates to false, implying
that the adversary has managed to create a state which violates
the Match-security properties. Since we use a similar structure
for our key conﬁrmation experiments, where only a different
predicate is evaluated, it is convenient to deﬁne the experiment
generically with an abstract predicate Pred and plug in the
corresponding predicate for the security notion in question.
Def inition 2.5 (Match security): A key exchange protocol
Π provides Match security if for any PPT adversary A there
exists a negligible function negl(n) such that
≤ negl(n)
in Figure 2 with the

(cid:3)
Π,A(n) = 1

for the generic security experiment
predicate set to Pred = Match.

ExpPred

Pr

(cid:2)

III. DEFINING KEY CONFIRMATION

In this section we discuss and develop our notions for key
conﬁrmation. Per the discussion in the introduction we do not
distinguish between explicit and implicit key conﬁrmation.

We design two security notions which capture strong forms
of key conﬁrmation, one that corresponds to the guarantees of
the party that receives the last message in the protocol, and
a second one for the party that sends this last message. We
give logical formulas that directly capture the basic intuition
behind key conﬁrmation and then turn the formulas into their

5The difference to unilaterally or mutually authenticated protocols is that
we generally allow for (cid:2).pid = ∗ here. This is to require soundness of the
pid set; authentication requirements follow from Deﬁnition 2.3.

456456

if i ∈ C then (ski, pki) ← KGclient(1n) ﬁ
if i ∈ S then (ski, pki) ← KGserver(1n) ﬁ

Π,A (n)

Experiment Expscrcy
foreach i ∈ I do
1 :
2 :
3 :
4 : endforeach
b ←${0, 1}
5 :
6 : pks ← {(i, pki) | i ∈ I }
7 :
8 :

(cid:2) ← ANewSession(·),Send(·,·),Test(b,·),Corrupt(·),RevealKey(·)(1n
b
return (b = b
// where (cid:2)test only Test-query

(cid:2) ∧ Fresh((cid:2)test))
Figure 1: Key Secrecy Experiment.

, pks)

associated security notions. As we explain, care needs to be
taken to rule out superﬁcially correct, but in fact misleading
deﬁnitions.

A. Full Key Conﬁrmation

First, we treat the simpler case of full key conﬁrmation.
These are the guarantees obtained by the party that receives
the last message of the protocol: the protocol ensures full
key conﬁrmation (for that party) if, when it receives this last
message (and therefore accepts the locally derived key), it has
the guarantee that there is a (partnered) session of the protocol
that has accepted precisely the same key.

Since a protocol cannot achieve the full conﬁrmation prop-
erty for all sessions simultaneously—in each pair of sessions
one party has to ﬁnish ﬁrst—it is convenient to restrict the
sessions under considerations to some subset. Since a session
is fully described by its label (cid:2), including for example the
identity of the party running the session, we usually identify
the sessions according to their label (cid:2) which should belong to
some set L. Slightly overloading notation (but extending our
predicate-based notions in the previous sections in a natural
way) we write for example L((cid:2)) = [(cid:2).id /∈ Corr] to identify an
honest party’s session (cid:2). Analogously, we conveniently reuse
the identity sets C for client and S for server session labels
by deﬁning C((cid:2)) = [(cid:2).role = client] resp. S((cid:2)) = [(cid:2).role =
server].
In the deﬁnition below of the full key conﬁrmation predicate
we abstractly speak of subsets L and L(cid:3) of labels. The
predicate stipulates that for each accepting session with a label
(cid:2) from L, where the partner is neither corrupt nor unauthen-
ticated (in which case the adversary could impersonate the
partner), there exists another session with a label (cid:2)(cid:3) from L(cid:3)
such that this session also accepts the same key. Note that
we do not demand that the session (cid:2)(cid:3) is actually held by the
intended partner speciﬁed by (cid:2).pid (which is captured as a
distinct modular property within Match security), but only
that it is partnered according to the session identiﬁers. This
conveniently allows combining (full) key conﬁrmation with
other sid-based security notions, e.g., to achieve authentica-
tion and partnering properties when coupled with (implicit)

if i ∈ C then (ski, pki) ← KGC(1n) ﬁ
if i ∈ S then (ski, pki) ← KGS (1n) ﬁ

Experiment ExpPred
Π,A(n)
foreach i ∈ I do
1 :
2 :
3 :
4 : endforeach
5 : pks ← {(i, pki) | i ∈ I }
6 : ANewSession(·),Send(·,·),Corrupt(·),RevealKey(·)(1n
7 :
8 :
Figure 2: Generic security experiment for predicate
Pred, capturing in dependence of Pred the notions of
Match security and all versions of key conﬁrmation.

, pks)
b ← Pred // evaluate predicate Pred on execution state
return b

authentication resp. Match security or to achieve explicit key
authentication when linked with key secrecy.6

As a ﬁnal

technical remark, key conﬁrmation can only
be expected for sessions that communicate with a distinct,
uncorrupted party, as we cannot reason about an adversarially
controlled session deriving certain values or holding the same
key. This is reﬂected in both the deﬁnitions of full and almost-
full key conﬁrmation by demanding that (cid:2).pid /∈ Corr ∪ {∗}.
Def inition 3.1 (Full key conﬁrmation predicate): The pred-
icate FullConf(L,L(cid:3)) that deﬁnes full key conﬁrmation is the
following:

[(cid:2).status = accept ∧ (cid:2).pid /∈ Corr ∪ {∗}]

∀(cid:2) ∈ L ::
=⇒ [∃(cid:2)(cid:3) ∈ L(cid:3) :: ((cid:2)(cid:3).status = accept

∧ Partners((cid:2), (cid:2)(cid:3)) ∧ samekey((cid:2), (cid:2)(cid:3)))].

Note that Partners((cid:2), (cid:2)(cid:3)) ensures that l (cid:7)= l(cid:3).
A protocol offers full key conﬁrmation if no efﬁcient
adversary can make the predicate false, except with negligible
probability.
Def inition 3.2 (Full key conﬁrmation): A key exchange
protocol Π provides full (L,L(cid:3))-key conﬁrmation if for any
PPT adversary A there exists a negligible function negl (n)
such that

(cid:2)

(cid:3)
Π,A(n) = 1

Pr

ExpPred

≤ negl(n)
in Figure 2 with the

for the generic security experiment
predicate set to Pred = FullConf(L,L(cid:3)).

Note that the notion above implicitly captures the time-
critical aspect that some other session already holds the same
key at the point in time when a party accepts. Whereas the
predicate FullConf is evaluated on the ﬁnal execution state,
thus not allowing to distinguish between sessions (cid:2) for which
the paired session (cid:2)(cid:3) existed before or only after session (cid:2)
accepted, the quantiﬁcation over all adversaries A rules out
the case that there has not been such a session (cid:2)(cid:3) before. That
is, assume that (any of the possibly multiple paired sessions)

6Consulting once more the “Handbook of Applied Cryptography” [27],
the authors there also treat the properties separately, and deﬁne explicit key
authentication as the combination of key conﬁrmation with (implicit) key
authentication (where the latter comprises authenticity and key secrecy).

457457

(cid:2)(cid:3) only accepted after (cid:2) in an execution of some adversary
A. Then one can imagine a pruned version of the adversary
which stops immediately after (cid:2) has accepted, say, simply by
picking a random stop point in the execution. If A triggers
the event that any paired session (cid:2)(cid:3) existed only afterwards
with non-negligible probability, then the pruned version of A
would break full key conﬁrmation as above.

B. Almost-Full Key Conﬁrmation

We now turn to the guarantees that key conﬁrmation can
offer to the party that sends the last message in a protocol,
and which therefore has no guarantee that its intended partner
accepts (since the adversary may simply drop the message).

A FALSE START. To understand the subtleties involved in
designing a deﬁnition for this case, we ﬁrst explore a possible
notion which, although intuitively appealing, has important
shortcomings.

Intuitively, the best guarantee for the party that sends the
last message (and accepts) is that there is some other session
which, if it eventually accepts, will have accepted the same
key. This intuition is captured by the following formula:
∀(cid:2) ∈ L ::
[(cid:2).status = accept ∧ (cid:2).pid /∈ Corr ∪ {∗}] =⇒
[∃(cid:2)(cid:3) ∈ L(cid:3) :: ((cid:2)(cid:3).status = accept =⇒ samekey((cid:2), (cid:2)(cid:3)))] .
It turns out that this notion is too weak. The problem is that
the predicate is satisﬁed whenever there is some session (cid:2)(cid:3) that
has not accepted. To understand why this is the case, consider
the negation of the above predicate (which an adversary that
attempts to break the property must ensure it evaluates to true).
∃(cid:2) ∈ L :: (cid:2).status = accept ∧ (cid:2).pid /∈ Corr ∪ {∗}
∧

(cid:4)
(cid:2)(cid:3).status = accept ∧ samekey((cid:2), (cid:2)(cid:3))

∀(cid:2)(cid:3) ∈ L(cid:3) ::

(cid:5)(cid:3)

(cid:2)

.

Note that to make the predicate true, the adversary has to
ensure that all sessions accept and as soon as a single session
(cid:2)(cid:3) rejects, the formula cannot be satisﬁed anymore and the
adversary loses. This is clearly too restrictive since at least for
sessions unrelated to (cid:2), the adversary should not be required
to make them accept. To ﬁx the deﬁnition, we have to take
additional information into account to characterize sessions
that will compute the same key as (cid:2).
THE RIGHT DEFINITION. We deﬁne the notion of almost-
full key conﬁrmation based on sessions which are waiting
to receive the ﬁnal message. Note that these are sessions
which still lack some information to express the full session
identiﬁers and thus revert to key-conﬁrmation identiﬁers for
a weaker type of partnering. Almost-full key conﬁrmation
then ensures that the identiﬁed session holding the same key-
conﬁrmation identiﬁer indeed accepts with the same key (if
it eventually accepts at all). This essentially captures the
previous, fallen short intuition of having another session that,
if it eventually accepts, derives the same key, but restricts this
requirement to sessions agreeing on the same key-conﬁrmation
identiﬁer.

Def inition 3.3 (Almost-full key conﬁrmation predicate):
The predicate AlmostConf(L,L(cid:3)) that deﬁnes almost-full key
conﬁrmation is the following:
∀(cid:2) ∈ L ::
[∃(cid:2)(cid:3) ∈ L(cid:3) :: ((cid:2).kcid = (cid:2)(cid:3).kcid

[(cid:2).status = accept ∧ (cid:2).pid /∈ Corr ∪ {∗}] =⇒

∧ ((cid:2)(cid:3).status = accept =⇒ samekey((cid:2), (cid:2)(cid:3))))].

KEY-CONFIRMATION IDENTIFIER BINDING. So far, key-
conﬁrmation identiﬁers, on which the deﬁnition of the almost-
full key conﬁrmation predicate are based upon, are not bound
to the actual session identiﬁers or to keys. In order to give them
practical meaning, we need to establish links to the notion of
partnering as well as the derived keys.

First, it is natural to require that whenever two sessions
are partnered, they in particular agree on the key-conﬁrmation
identiﬁer.7 More importantly, key-conﬁrmation identiﬁers are
supposed to capture the idea that, whenever two sessions
accept and hold the same key-conﬁrmation identiﬁer, they also
derive the same key. We formalize these concepts by deﬁning
the predicate KCIDbind which returns true if and only if all
of the following conditions holds.
1) For all sessions (cid:2), (cid:2)(cid:3) with Partners((cid:2), (cid:2)(cid:3)) = true, it holds
that (cid:2).kcid = (cid:2)(cid:3).kcid, i.e., partnered sessions agree on the
same key-conﬁrmation identiﬁer.
2) For all sessions (cid:2), (cid:2)(cid:3) with (cid:2).kcid = (cid:2)(cid:3).kcid and (cid:2).status =
(cid:2)(cid:3).status = accept, it holds that samekey((cid:2), (cid:2)(cid:3)) = true,
i.e., sessions with the same key-conﬁrmation identiﬁer,
upon acceptance, will derive the same key.

Def inition 3.4 (Key-conﬁrmation identiﬁer binding): A
key exchange protocol Π provides key-conﬁrmation identiﬁer
binding if for any PPT adversary A there exists a negligible
function negl(n) such that

(cid:2)

(cid:3)
Π,A(n) = 1

Pr

ExpPred

≤ negl(n)
in Figure 2 with the

for the generic security experiment
predicate set to Pred = KCIDbind.
DEFINING ALMOST-FULL KEY CONFIRMATION. We are now
ready to deﬁne almost-full key conﬁrmation.
Def inition 3.5 (Almost-full key conﬁrmation): A key ex-
change protocol Π provides almost-full (L,L(cid:3))-key conﬁrma-
tion if it satisﬁes key-conﬁrmation identiﬁer binding and for
any PPT adversary A there exists a negligible function negl(n)
such that

(cid:2)

(cid:3)
Π,A(n) = 1

Pr

ExpPred

≤ negl(n)
in Figure 2 with the

for the generic security experiment
predicate set to Pred = AlmostConf(L,L(cid:3)).

To elaborate why this formalization of almost-full key
let us ﬁrst again

conﬁrmation captures the right property,

7We note that, beyond this connection, we do not require any particular
properties (e.g., concerning authentication) from session identiﬁers in the
context of key conﬁrmation. These aspects are modularly captured within
Match security and the deﬁnition of (implicit) authentication.

458458

consider the negation of the predicate AlmostConf (i.e., the
formula the adversary needs to make evaluate to true):
∃(cid:2) ∈ L :: (cid:2).status = accept ∧ (cid:2).pid /∈ Corr ∪ {∗}
∧ [∀(cid:2)(cid:3) ∈ L(cid:3) :: (cid:2).kcid (cid:7)= (cid:2)(cid:3).kcid

∨ ((cid:2)(cid:3).status = accept ∧ samekey((cid:2), (cid:2)(cid:3)))].

First of all note that the part (cid:2).kcid (cid:7)= (cid:2)(cid:3).kcid formalizes
that a protocol cannot choose to have unique key-conﬁrmation
identiﬁers per session, e.g., by setting the identiﬁer to some
local random value. This is so as this would trivially mean
that for any session (cid:2) ∈ L that an adversary initiates, all
other sessions (cid:2)(cid:3) ∈ L(cid:3) have non-matching key-conﬁrmation
identiﬁers, so the adversary immediately wins.
When a protocol instead lets every session (cid:2) ∈ L accept
with a kcid that matches the one of some session (cid:2)(cid:3) ∈ L(cid:3), this
allows the adversary to focus on such matching sessions. In
contrast to the initial false-start formalization, the adversary
can in particular let sessions reject that do not hold the same
key-conﬁrmation identiﬁer as (cid:2).

Finally, a trivial way to achieve almost-full key conﬁrmation
is for a protocol to set kcid to the same (e.g., empty) value
for every session. Note that key-conﬁrmation identiﬁer binding
then in turn requires that every session accepts with the same
key. Although this rightly appears to be unreasonable (as it
contradicts key secrecy), it is consistent from the perspective of
key conﬁrmation: If every session derives the same key, every
session is trivially assured that, if there is another accepting
session, it will hold the same key.
CHOOSING A KEY-CONFIRMATION IDENTIFIER. A natural
question arising from the deﬁnition of almost-full key con-
ﬁrmation is how to set the key-conﬁrmation identiﬁers for a
speciﬁc protocol. As for the regular session identiﬁers and
their use within the freshness condition for deﬁning key
secrecy, there is an interplay between the security notion (key
secrecy resp. almost-full key conﬁrmation) and the soundness
requirements for the identiﬁers (Match security resp. key-
conﬁrmation identiﬁer binding).
On the one hand, to achieve almost-full key conﬁrmation,
a protocol has to couple up any accepting session (in L)
with a session (in L(cid:3)) holding the same key-conﬁrmation
identiﬁer kcid. As already discussed, this in particular prevents
using a unique kcid value per session. On the other hand,
choosing the same key-conﬁrmation identiﬁer (e.g., an empty
kcid) for every session, by key-conﬁrmation identiﬁer binding,
implies that every session must derive the same key. As this in
particular contradicts key secrecy, it is also not a viable option
for any reasonable key exchange protocol.

Therefore a protocol needs to balance out the choice for
setting key-conﬁrmation identiﬁers between these two ex-
tremes. From a practical point of view, the key-conﬁrmation
identiﬁer would intuitively comprise as much of the session
identiﬁer such that, together with the last protocol message,
it fully determines the derived key. In some cases, even the
actual key might already be computable (and hence serve as
a “trivial” key-conﬁrmation identiﬁer) before the last message

is received. The generic transformation based on an additional
exchange of MACs given in Section V is such an example.
In many practical protocols (that intuitively achieve almost-
full key conﬁrmation), however,
the last message(s) will
substantially contribute to the key and, hence, only partial
information is available when setting (and hence captured in)
the key-conﬁrmation identiﬁer. This is, for example, the case
in TLS 1.3 (cf. Section IV for our detailed analysis), where
the key is derived from a hash over all messages, including
the client’s last messages CCRT and CCV. Therefore, when the
client in TLS 1.3 accepts, the server does not know these
messages yet and cannot have set kcid based on the key.
Instead, we need to leverage the already exchanged part of
the session identiﬁer as key-conﬁrmation identiﬁer, which then
ﬁxes a unique key together with the client’s last messages. This
motivates why we chose to capture “agreement on the same
key up to receipt of the last message” using a generic identiﬁer
string rather than relying on a particular protocol value or a
partial communication transcript.

C. Relationship

(cid:2)(cid:3).kcid) and
accept =⇒ samekey((cid:2), (cid:2)(cid:3))).

We now take a look at the relationship between full and
almost-full key conﬁrmation and see why the former implies
the latter (given key-conﬁrmation identiﬁer binding).
Theorem 3.6: Let Π be key exchange protocol that provides
full (L,L(cid:3))-key conﬁrmation as well as key-conﬁrmation
identiﬁer binding. Then Π also provides almost-full (L,L(cid:3))-
key conﬁrmation.
Proof: We need to show that, for any session (cid:2) ∈ L
that accepts ((cid:2).status = accept) with a distinct, uncorrupted
partner ((cid:2).pid /∈ Corr ∪ {∗}), there exists a session (cid:2)(cid:3) ∈ L(cid:3)
which
(a) shares the same key-conﬁrmation identiﬁer ((cid:2).kcid =
(b) on acceptance derives the same key ((cid:2)(cid:3).status =
First, observe that by full (L,L(cid:3))-key conﬁrmation, for
any such session (cid:2) ∈ L there exists a session (cid:2)(cid:3) ∈ L(cid:3)
that accepted ((cid:2)(cid:3).status = accept),
is partnered with (cid:2)
(Partners((cid:2), (cid:2)(cid:3))), and holds the same key (samekey((cid:2), (cid:2)(cid:3))).
Due to key-conﬁrmation identiﬁer binding, (cid:2)(cid:3) then also shares
the same key-conﬁrmation identiﬁer (i.e., (cid:2).kcid = (cid:2)(cid:3).kcid),
satisfying (a). Furthermore (again by key-conﬁrmation iden-
tiﬁer binding), when (cid:2)(cid:3) accepts, we have additionally that
(cid:2).status = (cid:2)(cid:3).status = accept, and so samekey((cid:2), (cid:2)(cid:3)) holds,
satisfying (b).
MATCH SECURITY VS. KEY CONFIRMATION. On a more
distant relation, let us note that Match security and key conﬁr-
mation (both full and almost-full) are independent notions (i.e.,
a protocol can provide either one without providing the other
one). On the one hand, setting sid = kcid to be a unique string
per session trivially lets the protocol satisfy Match security,
but renders full and almost-full key conﬁrmation unachievable.
On the other hand, having all sessions use the same (arbitrary)
identiﬁers sid and kcid and derive the same key key trivially

459459

satisﬁes full and almost-full key conﬁrmation, but violates
Match security (due to more than two sessions being partnered
with each other).

Match security thus rather constitutes a counterpart to the
freshness conditions used for key secrecy than being related
to key conﬁrmation.

D. Conﬁrmation guarantees for unauthenticated peers

Informal deﬁnitions of key conﬁrmation usually demand
that another, even possibly unidentiﬁed party holds the same
key (e.g.,
the “Handbook of Applied Cryptography” [27,
Deﬁnition 12.7]). Note that our notions of full and almost-full
key conﬁrmation originally guarantee that for sessions which
communicate with an identiﬁed (and uncorrupted) partner
((cid:2).pid /∈ Corr∪{∗}) there is another session which (eventually)
holds the same key.

The extension of our notions to unauthenticated peers turn
out to hold trivially by correctness(-like) properties. For this,
ﬁrst note that key conﬁrmation guarantees for sessions with
unauthenticated peers can only be provided if the actual
communication partner is indeed honest. This is so since no
conﬁrmation model can ensure that an adversarially-controlled
session derives a session key at some point.
In the case of full key conﬁrmation, any extension to
unauthenticated peers (i.e., dropping the prerequisite (cid:2).pid /∈
Corr ∪ {∗} for the session (cid:2) in question) would hence need
to condition on the existence of a partnered (honest) session
to the session (cid:2), e.g., adding the requirement ∃(cid:2)(cid:3)(cid:3) ∈ L(cid:3)
::
Partners((cid:2), (cid:2)(cid:3)(cid:3)) to the full key conﬁrmation predicate. But then
any (correct) key exchange protocol provides this kind of
“unauthenticated” full key-conﬁrmation anyway: Correctness
demands that partnered sessions (i.e., with the adversary only
passively relaying messages) derive the same key. This means
that such a session (cid:2)(cid:3)(cid:3) already serves as a partnered session
holding the same key according to our original deﬁnition.

In the case of almost-full key conﬁrmation, guarantees for
unauthenticated peers would again need to be conditioned on
an existing session sharing the same key conﬁrmation identiﬁer
(e.g., swapping in the requirement ∃(cid:2)(cid:3)(cid:3) ∈ L(cid:3)
(cid:2).kcid =
(cid:2)(cid:3)(cid:3).kcid for (cid:2).pid /∈ Corr ∪ {∗}). But then again, the natural
requirement of key-conﬁrmation identiﬁer binding (being part
of the almost-full key conﬁrmation property) already satisﬁes
almost-full key-conﬁrmation for such cases trivially: It ensures
that two sessions sharing the same key-conﬁrmation identiﬁer,
upon acceptance, will derive the same key. Thus, session (cid:2)(cid:3)(cid:3)
again serves as the desired partnered session according to out
current notion.

::

In conclusion, obtaining no advantage from deﬁnitions
encompassing unauthenticated peers, we focus on the key
conﬁrmation guarantees attainable when communicating with
an authenticated partner.

IV. KEY CONFIRMATION IN TLS 1.3 DRAFT-10

In this

section, we investigate the key conﬁrmation
properties provided by the currently developed next ver-
sion of the Transport Layer Security protocol (TLS 1.3).

the recent TLS 1.3 draft
More precisely, we consider
draft-ietf-tls-tls13-10 [29] (short: draft-10) and
its full (EC)DHE handshake. We remark that we do not
analyze key secrecy or Match security for draft-10, which is
beyond the scope of this work, but focus on key conﬁrmation.
Key secrecy for TLS 1.3 draft-10 and earlier draft versions
has been recently studied by Dowling et al. [18], [19]. We
furthermore do not treat the other handshake modes speci-
ﬁed in draft-10 for resumption (PSK/PSK-(EC)DHE) and
zero round-trip time (0-RTT) [29, Section 6.2] or extensions
added in later drafts like post-handshake client authentication
(draft-11 [30]).

Figure 3 depicts the TLS 1.3 draft-10 full (EC)DHE
handshake including the essential steps of the Difﬁe–Hellman-
based key derivation.8 We sometimes use abbreviated message
names (ClientHello = CH, ClientKeyShare = CKS, and so
on).

As in previous versions, TLS 1.3 in draft-10 employs
Finished messages (sent both by the client and the server),
which are essentially MAC values computed over the (hashed)
transcript (excluding the Finished messages), the so-called
“session hash”, in order to “provide[] key conﬁrmation” [29,
p. 31]. Importantly, in contrast to previous TLS versions, the
MAC key employed is not the derived session key, but a
separate ﬁnished_secret derived through a key derivation func-
tion from one of the secret Difﬁe–Hellman values established
within the key exchange. In that sense, draft-10 essentially
follows the popular paradigm we discuss in Section V to
exchange MACs over the transcript (or the session identiﬁers)
in order to achieve key conﬁrmation.

A. Key Conﬁrmation without Finished Messages

Interestingly, we can however actually show that already
a shortened variant of the draft-10 handshake without the
ClientFinished and ServerFinished messages (which we
denote as draft-10-nf) provides the same strongest form of
key conﬁrmation one can expect. That is, in the mutually
authenticating handshake the server is assured that the client
already accepted with the same key at the time the server
accepts while the client is assured that, if the server later
accepts, it will do so with the same key. In contrast, in the
unilaterally authenticating handshake—as expected—only the
client is guaranteed (full) key conﬁrmation.9 We will ﬁrst
elaborate in detail how to prove key conﬁrmation for the
shortened draft-10-nf handshake and then demonstrate in
Section IV-B how this result can easily be adapted to the actual
draft-10 handshake.

More formally, we show that the mutually authenticating
draft-10-nf handshake (short: draft-10-nf-m) achieves full

8In TLS 1.3 draft-10, handshake messages from EncryptedExtensions
on are sent encrypted under a separately derived handshake trafﬁc key
(independent of the ﬁnal session key). We disregard this handshake encryption
in our analysis as it does not affect the key conﬁrmation guarantees for the
ﬁnal session key we are interested in here.

9Observe that, for unilateral authentication, in contrast to draft-10 the
server sends the last protocol message in the shortened draft-10-nf variant
due to the omitted ﬁnished messages.

460460

Client
rc ← {0, 1}256
X ← g

x

ClientHello : rc
ClientKeyShare : X

Server

y

y

†

, SS = ES

rs ← {0, 1}256
Y ← g
ES ← X
xES ← HKDF.Extract(0, ES)
xSS ← HKDF.Extract(0, SS)
SCV ← Sign(skS, H(CH|| . . .||CR))
ﬁnished_secret ← HKDF.Expand(xSS,
SF ← HMAC(ﬁnished_secret,
kcid ← CH|| . . .||SCV

“finished secret”||H(CH|| . . .||SCV))
“server finished”||H(CH|| . . .||SCV))

x

†

, SS = ES

kcid ← CH|| . . .||SCV
ES ← Y
compute xES, xSS
compute ﬁnished_secret
verify SCV
check SF
CCV ← Sign(skC , H(CH|| . . .||CCRT))
CF ← HMAC(ﬁnished_secret,

“client finished”||H(CH|| . . .||CCV))

ServerHello : rs
ServerKeyShare : Y
∗
EncryptedExtensions
∗

ServerConfiguration
ServerCertificate : pkS
CertificateRequest

ServerCertificateVerify

ServerFinished

ClientCertificate : pkC
ClientCertificateVerify

ClientFinished

verify CCV
check CF

mES ← HKDF.Expand(xES, “expanded ephemeral secret”||H(CH|| . . .||SCV))

mSS ← HKDF.Expand(xSS, “expanded static secret”||H(CH|| . . .||SCV))

key ← HKDF.Expand(M S, “application data key expansion”||H(CH|| . . .||CCV))

M S ← HKDF.Extract(mSS, mES)

sid ← CH|| . . .||CCV

Figure 3: The TLS 1.3 draft-10 full (EC)DHE handshake protocol with Difﬁe–Hellman-based key derivation. Messages
ServerCertificate and ServerCertificateVerify are sent both for unilateral and mutual authentication, messages
CertificateRequest, ClientCertificate, and ClientCertificateVerify are only sent for mutual authentication.
Starred messages are situation-dependent and not always sent. In the computations, we abbreviate message names as
ClientHello = CH, ClientKeyShare = CKS, etc. Enumerations for session-hash values of messages exchanged (like
H(CH|| . . .||CCV)) always exclude the Finished messages. Without client authentication, the server may derive the session key
already after sending ServerFinished.
In the shortened draft-10-nf we deﬁne and analyze, the ServerFinished and ClientFinished messages are omitted.
† TLS 1.3 draft-10 allows handshake variants where the client announces knowledge of a cached server conﬁguration in
which case xSS is derived differently. We do not capture this variant in our analysis and hence omit it here for the ease of
presentation.

461461

(S,C)-key conﬁrmation and almost-full (C,S)-key conﬁr-
mation and that the unilaterally authenticating draft-10-nf
handshake (draft-10-nf-u) provides full (C,S)-key conﬁr-
mation. While we analyze both authentication variants of the
handshake separately, we remark that both results also hold
when handshakes are allowed to run with mutual and with
unilateral concurrently in our model, as the message ﬂow is
unique for each authentication variant which allows to tell the
according sessions apart.

a

is

on

the

our

For

over

both

variants

signature

handshake

ClientCertificateVerify

proofs
resp.
rely
exchanged, which
ServerCertificateVerify message
resp.
essentially
intuitively be
almost-complete transcript and can, hence,
seen as a signature-based analogue of
the MAC-based
transform discussed in Section V. We deﬁne the key-
conﬁrmation identiﬁers
to
kcid = ClientHello|| . . .||ServerCertificateVerify
by the server on sending its ServerCertificateVerify
message and by the client on receiving that message.

in draft-10-nf to be

complete

the

set

Theorem 4.1: The TLS 1.3 draft-10-nf-m handshake for
mutual authentication without ﬁnished messages satisﬁes full
(S,C)-key conﬁrmation and almost-full (C,S)-key conﬁrma-
tion. Formally, for any efﬁcient adversary A against full
(S,C)-key conﬁrmation resp. almost-full (C,S)-key conﬁrma-
tion there exist efﬁcient algorithms B1, B2 such that

(cid:2)

(cid:3)
ExpPred
draft-10-nf-m,A(n) = 1
s · 2−|nonce| + AdvCOLL
H,B1

Pr
≤ n2

+ nu · AdvEUF-CMA

Sig,B2

,

for Pred = FullConf(S,C) resp. Pred = AlmostConf(C,S),
where nu is the maximum number of participating parties, ns
is the maximum number of sessions, and |nonce| = 256 is the
bit-length of the nonces.

session,

for a server

Proof: We show that,

the
ClientCertificateVerify message of an honest client
sufﬁces as assurance that this client has accepted with the same
key when the server session accepts. In turn, for a client ses-
sion, the ServerCertificateVerify message of an honest
server ensures that this server agrees on the key-conﬁrmation
identiﬁer kcid and will, if it accepts, derive the same key. To
this extend we modify the original ExpPred
draft-10-nf-m,A(n) ex-
periment in three steps, showing that the advantage difference
of adversary A can each time be bounded by the advantage of
breaking the security of TLS 1.3 components, ﬁnally reaching
an experiment where the advantage of A is 0.
modiﬁed

experiment
First,
ExpPred
draft-10-nf-m,A(n) which is as before, except it aborts (and
outputs 0) if, during the execution, any two honest sessions
choose the same nonce (rc or rs). The probability that the
s · 2−|nonce|
experiment aborts can be bounded from above by n2
where ns is the maximum number of sessions and |nonce| is

consider

the

we

(cid:2)

the nonces’ bit-length. Therefore,

(cid:2)

(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred

(cid:3)
draft-10-nf-m,A(n) = 1

(cid:2)

ExpPred

(cid:2)

Pr
≤ Pr

+ n2

s · 2−|nonce|.

(cid:2)(cid:2)

Second, we switch to ExpPred

draft-10-nf-m,A(n) in which we
also abort if, during the execution, any two honest sessions
compute the same hash value for two different
inputs to
the hash function H. We can bound the probability that this
experiment aborts for this reason by the advantage AdvCOLL
H,B1
of an adversary B1 against
the collision resistance of H.
For this purpose, B1 simply simulates ExpPred
draft-10-nf-m,A(n)
for A on its own and outputs the two colliding inputs when
they occur during the simulation, perfectly simulating the
experiment up to this point and always winning when the
modiﬁed experiment aborts. Hence we have that

(cid:2)(cid:2)

(cid:2)

(cid:2)

(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred

(cid:3)
draft-10-nf-m,A(n) = 1

(cid:2)(cid:2)

ExpPred

(cid:2)

Pr
≤ Pr

+ AdvCOLL
H,B1

.

(cid:2)(cid:2)(cid:2)

Sig,B2

Third, we consider ExpPred

draft-10-nf-m,A(n), which, in addi-
tion, aborts whenever a simulated server resp. client ses-
sion obtains, within the ClientCertificateVerify resp.
ServerCertificateVerify message, a valid signature (un-
der the public key of some non-corrupted client resp. server i ∈
I) which was not output by any honest client resp. server
session. Again, we can bound the probability of this abort by
of an adversary B2 against the ex-
the advantage AdvEUF-CMA
istential unforgeability of the deployed signature scheme Sig,
simulating the experiment for A as follows. Initially, B2
randomly chooses a party i among the at most nu parties,
∗
with it, and generates
associating the challenge public key pk
the long-term key for all other parties i ∈ I \ {i}. During
the simulation, B2 then uses it signing oracle whenever a
signature needs to be computed under the secret key of i.
When a simulated session obtains a valid signature that no
other honest session has output, B2 aborts the experiment and
outputs that signature as its forgery. If B2 correctly guessed
the (non-corrupted) identity i under whose public key pk
the
obtained signature veriﬁes, this is a valid forgery and B2 wins,
thus

∗

(cid:2)

(cid:2)(cid:2)

(cid:3)
draft-10-nf-m,A(n) = 1
ExpPred

(cid:3)
draft-10-nf-m,A(n) = 1

(cid:2)(cid:2)(cid:2)

ExpPred

(cid:2)

Pr
≤ Pr

+ AdvEUF-CMA

Sig,B2

.

Finally, we can now separately argue along the lines
of the predicates Pred = FullConf(S,C) resp. Pred =
AlmostConf(C,S) as well as Pred = KCIDbind (which is
required as part of almost-full key conﬁrmation):
• For Pred = FullConf(S,C), observe that each accept-
ing server session with a non-corrupted partner obtains,
within the ClientCertificateVerify message, a valid
signature generated by an honest client over the hash of
the transcript ClientHello|| . . .||ClientCertificate,

462462

which exactly relates to that transcript as no hash colli-
sions occurred. Hence, in particular, for each such server
session that accepts there exists a client session that al-
ready accepted, shares the same transcript, and, therefore,
in particular also holds the same session identiﬁer and
derives the same session key.
• For Pred = AlmostConf(C,S), note that the signature
sent within ServerCertificateVerify is computed
over (the non-colliding hash of) the transcript up to
the ServerCertificate message which, along with
the ServerCertificateVerify message itself forms
the key-conﬁrmation identiﬁer kcid. Therefore, for any
accepting client session (cid:2), there exists an honest server
session (cid:2)(cid:3) sharing the same kcid.
Furthermore, no second honest client will
send a
ClientCertificateVerify message with a signa-
ture over a (hash of a)
transcript containing the
same kcid contents due to unique nonces. Also,
no server obtains a forged signature and no hash
session (cid:2)(cid:3) will
collision occurs. Thus
the server
only accept when receiving this
session’s
client
ClientCertificateVerify message. As the values
signed within ClientCertificateVerify together
with ClientCertificateVerify uniquely determine
the key derivation, session (cid:2)(cid:3) will, if at all, accept with
the same session key.

• For Pred = KCIDbind, the ﬁrst condition that equal ses-
sion identiﬁers imply equal key-conﬁrmation identiﬁers
follows immediately from deﬁning kcid to be a preﬁx of
sid.
The second condition is satisﬁed for the same reasons that
make sessions holding the same kcid in the AlmostConf
predicate derive the same key. Again, kcid contains
the transcript up to the ServerCertificateVerify
message, which is signed by the client within its
ClientCertificateVerify message that no second
honest client will generate (and which can, at this point,
neither be forged nor be derived due to colliding nonces
or hashes). Therefore, if a client accepts (as the ﬁrst
of two sessions sharing the same kcid), it outputs the
only ClientCertificateVerify message server ses-
sion will accept. As ClientCertificateVerify ﬁxes
the complete transcript which fully determines the derived
keys, both sessions will necessarily derive the same key
as required.
FullConf(S,C),
In
other
AlmostConf(C,S),
satisﬁed
always
in ExpPred
(cid:2)

(being
is
(cid:3)
draft-10-nf-m,A(n) = 1

draft-10-nf-m,A(n) and thus

resp. KCIDbind)

ExpPred

words,

Pred

= 0.

Pr

(cid:2)(cid:2)(cid:2)

(cid:2)(cid:2)(cid:2)

Theorem 4.2: The TLS 1.3 draft-10-nf-u handshake for
unilateral authentication without ﬁnished messages satisﬁes
full (C,S)-key conﬁrmation. Formally, for any efﬁcient adver-

463463

sary A against full (C,S)-key conﬁrmation there exist efﬁcient
algorithms B1, B2 such that

(cid:2)

ExpFullConf(C,S)

(cid:3)
draft-10-nf-u,A(n) = 1
Pr
≤ AdvCOLL
+ nu · AdvEUF-CMA
H,B1
Sig,B2

,

where nu is the maximum number of participating parties.

inputs by AdvCOLL
H,B1

Proof: We show that, for unilateral authentication, the
ServerCertificateVerify message obtained by a client
session ensures that the sending server session has already
accepted with the same session key.

Again, we ﬁrst modify the original ExpFullConf(C,S)

draft-10-nf-u,A(n)
experiment
in two steps similar to those in the proof of
Theorem 4.1. First, we identically bound the probability
that
two honest sessions compute a colliding hash value
for an efﬁcient re-
for two different
duction B1. We then ensure that no client session obtains
a ServerCertificateVerify message containing a valid
signature under an honest server’s public key which was
not generated by any honest session (recall that there is no
ClientCertificateVerify message sent as the client does
not authenticate). Similarly to the proof of Theorem 4.1 we
can bound the probability that this happens by the advan-
of an adversary B2, again using its signing
tage AdvEUF-CMA
oracle for the challenged client identity.
Due to these modiﬁcations, we are now assured of uncon-
ditional full (C,S)-key conﬁrmation: the signature sent within
ServerCertificateVerify together with that message itself
fully determines the key derivation and, hence, whenever a
client accepts, the (honest) server session sending sending the
ServerCertificateVerify message already accepted with
the same session identiﬁer and session key.

Sig,B2

B. Key Conﬁrmation with Finished Messages

Coming back to the original TLS 1.3 draft-10 handshake,
it
is easy to see that
the proof in Theorem 4.1 for key
conﬁrmation under mutual authentication in draft-10-nf
immediately carries over to the draft-10 handshake with
mutual authentication (short: draft-10-m). For
re-
call that the ServerFinished and ClientFinished mes-
sage do not
the key derivation, which means
they can essentially be
an “arbitrary bit-
string” attached to the ServerCertificateVerify resp.
ClientCertificateVerify messages. Hence, we can apply
the identical proof to the draft-10 mutually authenticating
handshake to establish the same key conﬁrmation properties.

treated as

enter

this,

Theorem 4.3: The TLS 1.3 draft-10-m handshake for mu-
tual authentication with ﬁnished messages satisﬁes full (S,C)-
key conﬁrmation and almost-full (C,S)-key conﬁrmation. For-
mally, for any efﬁcient adversary A against full (S,C)-key
conﬁrmation resp. almost-full (C,S)-key conﬁrmation there
exist efﬁcient algorithms B1, B2 such that

(cid:2)

(cid:3)
ExpPred
draft-10-m,A(n) = 1
s · 2−|nonce| + AdvCOLL
H,B1

Pr
≤ n2

+ nu · AdvEUF-CMA

Sig,B2

,

for Pred = FullConf(S,C) resp. Pred = AlmostConf(C,S),
where nu is the maximum number of participating parties, ns
is the maximum number of sessions, and |nonce| = 256 is the
bit-length of the nonces.

Interestingly, when it comes to unilateral authentication,
the ClientFinished messages sent as the single additional
message from the client
to the server changes the order
in which the session key is accepted (the client accepting
ﬁrst here) and, hence, necessarily renders full (C,S)-key
conﬁrmation (as for draft-10-nf-u) unachievable. We can
however show that clients indeed still enjoy almost-full (C,S)-
key conﬁrmation for the unilaterally authenticating draft-10
handshake (draft-10-u).

Theorem 4.4: The TLS 1.3 draft-10-u handshake for uni-
lateral authentication with ﬁnished messages satisﬁes almost-
full (C,S)-key conﬁrmation. Formally, for any efﬁcient adver-
sary A against almost-full (C,S)-key conﬁrmation there exist
efﬁcient algorithms B1, B2 such that
ExpAlmostConf(C,S)

(cid:3)

(cid:2)

Pr
draft-10-u,A
≤ AdvCOLL
H,B1

(n) = 1
+ nu · AdvEUF-CMA

Sig,B2

,

where nu is the maximum number of participating parties.

Proof: We show that the ServerCertificateVerify
message obtained from an honest server ensures this server
agrees on kcid and will, on acceptance, derive the same key.
After excluding hash collisions and signature forgeries
within ServerCertificateVerify again as in the proof
of Theorem 4.2, the (unforged) ServerCertificateVerify
message, computed over (the non-colliding hash of) the tran-
script, ensures the sending server agrees on the same key-
conﬁrmation identiﬁer kcid.

the

kcid

kcid
key10:

Furthermore,

the
derived

value
observe

deter-
uniquely
=
that
mines
ClientHello|| . . .||ServerCertificateVerify
contains
all messages affecting the key derivation as messages
ClientCertificate and ClientCertificateVerify are
not sent and ServerFinished as well as ClientFinished
are not included in the session hashes. Therefore, any two
(accepting) sessions agreeing on the same kcid will derive
the same session key and hence AlmostConf(C,S) as well
KCIDbind are satisﬁed (note that still kcid is a preﬁx of sid).

To summarize, our analysis shows that key conﬁrmation in
the full handshake of the latest draft-10 of TLS 1.3 is already
established through the exchanged CertificateVerify mes-
sages and, hence, the Finished messages included for that
purpose are somewhat redundant. This unveils a potential
misconception that MACs over the transcript (in form of the
Finished messages) are always necessary to achieve key
conﬁrmation.

10This in particular renders requiring unique nonces unnecessary in this

case.

464464

Admittedly, there are however further (non-full) handshake
modes provisioned in draft-10, particularly for key ex-
changes based on a cached server conﬁguration or achieving
zero round-trip time [29, Sections 6.2.2 and 6.2.3]. These
variants do not necessarily exchange CertificateVerify
messages and, hence, rely on the Finished messages to pro-
vide both authentication as well as key conﬁrmation. For the
sake of a uniform protocol design, it therefore seems advisable
to keep Finished messages also in the full handshake, even
though their main purpose, key conﬁrmation, can as well be
achieved through the CertificateVerify messages only.

V. GENERIC TRANSFORM

We next show that the popular transformation of exchanging
MACs over the session identiﬁers at the end of a key exchange
protocol, as for instance advised in [2], [1], actually provides
the strongest form of key conﬁrmation one can expect. Here, a
key-refreshing step should be carried out for generating fresh
MAC keys (one for the client and one for the server) as well
as a separate, new session key via a key derivation function
KDF. In the remainder of the section we assume that the client
always goes last in a protocol Π and the server therefore sends
the ﬁrst MAC in the conclusive transfers.

Below we assume that KDF acts as a secure pseudorandom
generator, i.e., that its output for a random input key key
is indistinguishable from random, and that its output can be
formatted to be used as a session key and MAC keys.
The MAC scheme M = (KGen, MAC, Vf) should be key-
only unforgeable in the sense that the adversary cannot output
a message m∗ with a valid MAC, without even being allowed
to see a MAC for another message. This in particular implies
that for key conﬁrmation, as performed in our transformation
through independent keys for client and for server, it sufﬁces
to output parts of the refreshed key to conﬁrm that one holds
the (refreshed) key part. If both parties use the same key for
message authentication then one needs a one-time unforgeable
MAC scheme, though. We touch this issue at the end of the
section when discussing alternative approaches.

Theorem 5.1: Let KDF be a secure pseudorandom gener-
ator and (KGen, MAC, Vf) be a key-only unforgeable MAC
scheme. If a key exchange protocol Π has Match security
and key secrecy, then the transformation ΠMAC in Figure 4
preserves these properties, and moreover satisﬁes full (S,C)-
key conﬁrmation and almost-full (C,S)-key conﬁrmation. The
protocol ΠMAC also provides the same authentication property
as Π.

Proof: We ﬁrst note that any security property of ΠMAC
deﬁned via the generic experiment in Figure 2 (for one of
our predicates Pred in question), involving some adversary
A, can be perfectly simulated by an adversary A(cid:3) playing
the generic experiment (for Pred) against Π. Adversary A(cid:3)
runs a black-box simulation of A. For this, it always makes
a RevealKey query for any session that accepts (in Π) and
simulates the ﬁnal steps of ΠMAC with the derived key, and
otherwise relays all oracle queries of A in ΠMAC to its oracles.

Client

Server

Protocol Π

output
key key
identiﬁer sid
identiﬁer pid

output
key key
identiﬁer sid
identiﬁer pid

· · ·

s

c

τ

τ

Figure 4: Transformed protocol ΠMAC.

(cid:2) = sid
(cid:2)
, key

set
kcid
c
(key
MAC, key
s ← MAC(key
s
MAC, sid)
τ

s

MAC) = KDF(key)

abort if τ

c invalid

(cid:2)

output
key key
identiﬁer sid
identiﬁer pid

(cid:2) = sid
(cid:2) = pid

(cid:2) = sid
(cid:2)
, key

set
kcid
c
(key
MAC, key
c ← MAC(key
c
MAC, sid)
τ

s

MAC) = KDF(key)

abort if τ

s invalid

(cid:2)

output
key key
identiﬁer sid
identiﬁer pid

(cid:2) = sid
(cid:2) = pid

Since the simulation is perfect we can view any simulated
run of A as a concrete execution of its experiment against
ΠMAC. Furthermore, since for the predicates we consider here
the RevealKey queries of A(cid:3) are irrelevant to the outcome, it
follows that any concrete simulated execution of A satisfying
the predicate in the corresponding experiment against ΠMAC
also yields the result true in the experiment of A(cid:3) against Π.
Match SECURITY. To show Match security of ΠMAC consider
an arbitrary ﬁxed execution of A, simulated through A(cid:3). For
that particular execution, note that partnering in ΠMAC implies
partnering in Π, because if two sessions in ΠMAC have accepted
(cid:3) = sid, then this is also
and hold the same session identiﬁer sid
true for Π. Then violation of any of the four Match-security
properties in ΠMAC entails a corresponding violation for Π:

1) Partnered sessions cannot hold distinct keys: As explained
above, if two sessions are partnered for ΠMAC then they
are also partnered for Π. If they hold distinct keys in
ΠMAC, then they also must so in Π, because key derivation
is deterministic and they would otherwise also obtain the
same key in ΠMAC.

2) Three or more sessions share the same session identiﬁer:
Since identiﬁers are identical in both settings, this follows
straightforwardly.

3) Two partnered sessions do not adopt the client-server
relationship: Again, since this does not change in ΠMAC
this again follows easily.

4) A partnered session assumes to talk to a different party:
Since partnering carries over and (cid:2).id and (cid:2).pid coincide
in Π and ΠMAC for all sessions (cid:2), this cannot happen.

Hence, Match security of ΠMAC follows from the Match

465465

security of Π.

(cid:3)

(cid:3)

AUTHENTICATION. Violation of the authentication property
(cid:7)= ∗
in ΠMAC means that an honest session (cid:2) outputs (cid:2).pid
but such that the partnered session (cid:2)(cid:3) has a different identiﬁer
(cid:2)(cid:3).id
. Such a violation must occur for both unilateral and
(cid:3) = pid is
mutual authentication. Since the value of pid
identical in Π and ΠMAC it follows that the mismatch must
already appear in Π. Hence, we can construct an adversary A(cid:3)
for Π using an adversary A against ΠMAC like in the previous
case.

KEY SECRECY. Next we show key secrecy of the derived
protocol ΠMAC. To this end we ﬁrst “normalize” any attacker
AMAC against ΠMAC. The ﬁrst modiﬁcation refers to the fact
that we let AMAC lose if there are sessions with identical ses-
sion identiﬁers but different keys. It follows from the Match-
security that we only decrease AMAC’s success probability
negligibly, but from now on we can assume consistent keys in
the sense that, if the public session identiﬁers match, then so
do the session keys.
The next step is to assume that AMAC “is fresh” in the sense
that it never violates the freshness predicate Fresh. This can be
accomplished by letting AMAC stop and return 0 immediately
before it would violate the freshness condition, e.g., revealing a
session key of a partner of the tested session. Such cases can be
easily checked with the help of the public session identiﬁers.
Since the adversary would lose when refuting freshness this
modiﬁcation cannot decrease the adversary’s success probabil-
(cid:3)
ity. The freshness condition ensures that we can conveniently
re-write the secrecy condition that Pr
(n) = 1

Expscrcy

(cid:2)

ΠMAC,AMAC

(cid:3)(cid:6)(cid:6)(cid:6)

(n) = 1

Expscrcy-lr,1

ΠMAC,AMAC

2 as demanding that

(cid:2)

Expscrcy-lr,0

is negligibly close to 1

(cid:3)
(n) = 1

(cid:6)(cid:6)(cid:6)Pr
is negligible, where Expscrcy-lr,b
Expscrcy

ΠMAC,AMAC

− Pr

(cid:2)

ΠMAC,AMAC

2) by a factor 1

(n) with the Test oracle’s bit b ﬁxed.

(n) is the experiment
ΠMAC,AMAC
The third change is to assume that AMAC, before the actual
experiment begins, outputs an index t such that it will test
the t-th completed session with label (cid:2)t, and that there will
be no partnered session accepting before the tested session.
If (cid:2)t would not satisfy this we can assume that AMAC loses
the game. This modiﬁcation can only decrease the adversary’s
advantage (over 1
ns for the maximal number ns
of sessions. To see this deﬁne another adversary which initially
picks t at random from {1, 2, . . . , ns} and the runs a black-box
simulation of AMAC, checking via the public session identiﬁers
that the choice satisﬁes the required properties. Note that this
new adversary still “is fresh” if AMAC is.
Now assume that there exists a normalized PPT adversary
AMAC for the protocol ΠMAC such that
the distinguishing
probability above is non-negligible. Then we can deﬁne the
following adversary A against the original protocol Π. Ini-
tially, AMAC outputs its test session number t. Then A runs
a black-box simulation of AMAC, using its external oracles to
simulate the Send interaction of AMAC with the core part Π of
the protocol ΠMAC. Once this core part is completed, adversary
A ﬁrst fetches the session key key of Π. There are three cases
for that:

key,

such
a
c
MAC, key

• For sessions accepting before the t-th session, as well as
for sessions accepting later, but which are not partnered
with session (cid:2)t adversary A makes Reveal request to get
the session key.
• For the t-th session adversary A calls the Test oracle to
get the key.
• For any session partnered with (cid:2)t, which completes after
the test session, adversary A uses the key it has obtained
through the Test query.
adversary A computes
Given
MAC) ← KDF(key) and continues the
(cid:3), key
(key
execution internally in the simulation, with the help of
these keys. For the other queries, Test and Reveal of AMAC,
adversary A proceeds correspondingly, fetching the key key
with the corresponding query (if A does not hold it already),
MAC) ← KDF(key) and returning
computing (key
. Any Corrupt query is simply relayed. Eventually, A
key
outputs AMAC’s guess b(cid:3).
Consider for the moment the case that the Test oracle’s
bit in A’s attack is b = 0, such that the oracle returns the
actual session key key to A in the Test query. In this case the
above simulation for the normalized adversary AMAC perfectly
mimics an attack on ΠMAC of this adversary. The reason is that
identical session identiﬁers guarantee identical keys, such that
A consistently uses the right keys when identifying partners
of the tested session via session identiﬁers. Furthermore, A
only makes additional Reveal queries (on top of the ones that
AMAC makes) to sessions unpartnered to the test session, since

c
MAC, key

(cid:3), key

key

(cid:3)

s

s

(cid:3)

(cid:3), key

c
MAC, key

c
MAC, key

s
MAC) as input.

by assumption about AMAC there are no partnered sessions to
the t-th one before that session has completed. It follows that
A never violates freshness with the extra queries, and thus “is
fresh”, too.
The more challenging case is that A’s Test oracle uses
b = 1 and returns an independent key key. Then A as above
derived via the key derivation function KDF
returns a key key
from key, whereas the original experiment would return a
(cid:3)
instead. We next show that, given b = 1,
random key key
the difference is negligible by the pseudorandomness of KDF.
Suppose that, instead of using KDF(key) for independent and
random key key—recall that we ﬁx b = 1—our adversary
A would use a random tuple (key
s
MAC) and
run the identical experiment as above, only using this tuple
now. Then the output of A cannot change signiﬁcantly, or
else we straightforwardly obtain a distinguisher against KDF
which receives either KDF(key) for random key, or a random
(cid:3), key
(key
Next, change A’s simulation by letting it pick an indepen-
(cid:3)(cid:3)
dent key
. This does not change the
output distribution, but it enables us to revert to the pseudo-
MAC) ← KDF(key) again, by
random values (key
having A replace key
in the ﬁrst com-
MAC) ←
c
ponent. If the pseudorandomness of (key
MAC, key
KDF(key) would change the output distribution signiﬁcantly,
then we would again obtain a successful distinguisher against
the pseudorandomness of KDF. The ﬁnal hop is to use the
actual session key key of protocol Π, instead of a random
MAC) ← KDF(key). The
key key to derive (key
closeness here follows from the security of the original pro-
tocol Π, implying that this cannot alter A’s output behavior
signiﬁcantly, or else we easily obtain a successful adversary
against the key secrecy of Π. In this ﬁnal game, however, the
simulation (for ﬁxed bit b = 1) is perfectly indistinguishable
from AMAC’s attack on ΠMAC for b = 1, since AMAC now
obtains an independent random key key
for the Test query
session, and genuine keys are used elsewhere, also in the
additional conﬁrmation steps of ΠMAC in the tested session.
(cid:3)

(cid:3)(cid:3)
by a random value key
(cid:3), key

(cid:3)
In summary, we obtain that

instead of the random key

(cid:3), key
(cid:3)

c
MAC, key

c
MAC, key

(cid:3), key

(cid:2)

(cid:2)

(cid:3)(cid:3)

(cid:3)

s

s

s

Pr

Expscrcy-lr,0

Π,A

(n) = 1

= Pr

Expscrcy-lr,0

ΠMAC,AMAC

(cid:2)

(cid:3)
for the case b = 0, and that
(n) = 1

Expscrcy-lr,1

(cid:6)(cid:6)(cid:6)Pr

Π,A

(cid:2)

− Pr

Expscrcy-lr,1

ΠMAC,AMAC

(n) = 1

(cid:3)(cid:6)(cid:6)(cid:6)

(n) = 1

is negligible for b = 1, by the key secrecy of Π and
the pseudorandomness of KDF. Using the freshness of our
adversaries we conclude that AMAC’s advantage (over 1
2) must
be negligible by the key secrecy of Π.
KEY CONFIRMATION. We ﬁrst show that
the transformed
protocol achieves full (S,C)-key conﬁrmation. Note that this
time we cannot assume that the original protocol Π has this
property.
has non-negligible probabil-
ity for Pred equal to the full (S,C)-key conﬁrmation pred-
icate, i.e., the predicate evaluates to false in the ﬁnal state.

(cid:3)
Π,A(n) = 1

Assume Pr

ExpPred

(cid:2)

466466

Then there exists a server session (cid:2) that has accepted and
(cid:2).pid /∈ Corr ∪ {∗}, but there is no (partnered) client session
that has accepted with the same key as (cid:2). Since we can always
abort the adversary against key conﬁrmation if some server
session without partner accepts, we can assume that there
is no further oracle query after (cid:2) accepts, and that the key
of (cid:2) is therefore not revealed and that both (cid:2).pid and (cid:2).id
are not corrupted (note, if (cid:2).id would have been a corrupt
server session before, it would have not accepted anymore).
Furthermore, (cid:2) has no partnered session since such a session
would have the same key because of Match security (except
with negligible probability).

(cid:3), key

c
MAC, key

To proceed, we guess the server session (cid:2) for which full key
conﬁrmation is violated by picking its index randomly among
the at most ns many sessions. In the ﬁrst game hop, we use key
secrecy of the original protocol Π to replace the key key for
(cid:2) by a random key. Since there is no partnered session, key is
not required by any other session. The simulation is analogous
to the proof of key secrecy for ΠMAC. In the second game
s
hop, we apply KDF security to make (key
MAC)
random for (cid:2). Finally, we construct a MAC forger B as follows.
The forger B black-box simulates A, guesses (cid:2), and returns the
MAC τ c received in session (cid:2) together with the “message” sid
as a forgery. The winning probability is non-negligible since
the MAC must be valid for (cid:2) in order to accept, and the random
c
MAC is used for the ﬁrst time to verify the validity of
key key
the MAC.
Next, we show that ΠMAC provides almost-full (C,S)-key
conﬁrmation. For this we ﬁrst note that key-conﬁrmation iden-
tiﬁer binding holds trivially, since the extended protocol sets
(cid:3) = sid such that partnered sessions with the same
kcid
(cid:3)
session identiﬁer sid
also have identical key-conﬁrmation
identiﬁers. Furthermore, Match security of the underlying
(cid:3) = sid also
protocol implies that sessions with the same kcid
hold the same key if they eventually accept. Hence, predicate
KCIDbind is satisﬁed, except with negligible probability.

(cid:3) = sid

ExpPred

Assume next that Pr

has non-negligible
probability for Pred equal to the almost-full (C,S)-key con-
ﬁrmation predicate, i.e., the predicate evaluates to false in the
ﬁnal state. Then there exists a client session (cid:2) that has accepted
and (cid:2).pid /∈ Corr ∪ {∗}, but there
with session identiﬁer sid
is no server session that has set its key-conﬁrmation identiﬁer
(cid:3)
to sid

, or if it has, then it has accepted a different key.

(cid:3)

(cid:2)

(cid:3)
Π,A(n) = 1

(cid:3)

To proceed, we guess the client session (cid:2) for which almost-
full key conﬁrmation as above is violated. In the ﬁrst game
hop, we use key secrecy of the original protocol Π to replace
the key key for (cid:2) by a random key. Since there is no partnered
(cid:3) = sid and
(completed) session in ΠMAC with the same kcid
, key is not required by any other session.
the same key key
The simulation is now analogous to the proof of key secrecy
for ΠMAC. In the second game hop, we once more apply KDF
s
MAC) random for (cid:2). Finally,
security to make (key
we construct a MAC forger B as follows. The forger B black-
box simulates A, guesses (cid:2), and returns the MAC τ s and sid
as a forgery. The winning probability is non-negligible since

c
MAC, key

(cid:3), key

467467

the MAC must be valid for (cid:2) to accept, and the random key
s
MAC is used for the ﬁrst time to check the validity of the
key
the MAC.

We note that

there are several variations to the above
instantiation which, if done properly, can all be shown to be
secure:

• One variation, followed, e.g., by NIST [2], is to generate
only a single MAC key and let the client and server
prepend a distinct key word in front of the “message” sid
for the computation, e.g., “client”||sid and “server”||sid.
Here the MAC would require to be one-time unforgeable,
though.

• Another variant—which can be combined with the pre-
vious approach—is to use strongly unforgeable MACs
(where it is also infeasible to create a new MAC for
the same message), e.g., deterministic MACs where ver-
(cid:3) =
iﬁcation is done via re-computation, and deﬁne sid
(sid, τ s, τ c).

• A third variant is to include the session identiﬁer sid
in the key derivation, KDF(key, sid). For public session
identiﬁers and strong key derivation functions this cannot
harm the security. On the other hand, the basic security
properties of the underlying protocol Π already tie session
identiﬁers to session keys strongly, such that further
linking through KDF seems unnecessary.

• If the session identiﬁer is already strongly tied to the
session keys, it is also possible to remove sid from the
input of the MACs. This variant together with a single
MAC key and “client”/“server” labels is used in HMQV-
C [23], the 3-message variant of the HMQV protocol.

VI. CONCLUSION

Key conﬁrmation is a widely targeted functional property
in cryptographic key exchange protocols, but has received
only very limited formal treatment so far. Our work provides
the ﬁrst extensive formalization of key conﬁrmation through
according security deﬁnitions in the game-based modeling
tradition. A particular strength of our notions for key con-
ﬁrmation is their deﬁnitional modularity: they can easily be
plugged together with more traditional notions like key secrecy
to obtain combined security guarantees.

On the practical side, our analysis of the current TLS 1.3
draft-10 full handshake validates that it achieves the design
goal of providing key conﬁrmation. As a potentially surprising
technical result, key conﬁrmation in the full handshake how-
ever does not require the exchange Finished dedicated to this
purpose in the speciﬁcation, but can readily be established
from the exchanged CertificateVerify messages. While
this result cannot serve as an argument for dropping the
Finished messages due to their use in further handshake
variants, it casts light on the cryptographic strengths of various
handshake messages in general and the session hash and online
signatures concepts integrated into TLS 1.3 in particular.

Our generic transform on the theoretical side validates the
wide-spread concept of achieving key conﬁrmation through
exchanged MACs over the protocol
transcript, which not

only formalizes a folklore approach but more importantly can
serve as a veriﬁed blueprint for future key exchange protocol
designs.

In future work we plan to investigate the extension of our
approach to the (extended) Canetti–Krawczyk model for key
exchange and the interplay between key conﬁrmation and for-
ward secrecy. For example, it might be possible to generalize
the results obtained for the security strengthening compilers
introduced in [16] and [11] to other methods providing key
conﬁrmation.

ACKNOWLEDGMENTS

We thank the anonymous reviewers for valuable comments.
Marc Fischlin is supported by the Heisenberg grant Fi 940/3-2
of the German Research Foundation (DFG). This work was
done in part while Marc Fischlin was visiting the Simons
Institute for the Theory of Computing, supported by the Si-
mons Foundation and by the DIMACS/Simons Collaboration
in Cryptography through NSF grant #CNS-1523467. Benedikt
Schmidt is supported by ONR grant N00014-15-1-2750 and
the European Commission’s Seventh Framework Programme
Marie Curie Cofund Action AMAROUT II (grant no. 291803).
This work has also been co-funded by the DFG as part of
project S4 within the CRC 1119 CROSSING, the European
Union Seventh Framework Programme (FP7/2007-2013) grant
agreement 609611 (PRACTICE), and ERC Advanced Grant
ERC-2010AdG-267188-CRIPTO.

REFERENCES

[1] E. Barker, L. Chen, A. Regenscheid, and M. Smid. SP 800-56B. Rec-
ommendation for Pair-Wise Key Establishment Schemes Using Integer
Factorization Cryptography. NIST Special Publication, National Institute
of Standards & Technology, Aug. 2009.

[2] E. Barker, L. Chen, A. Roginsky, and M. Smid. SP 800-56A r2. Rec-
ommendation for Pair-Wise Key Establishment Schemes Using Discrete
Logarithm Cryptography. NIST Special Publication, National Institute
of Standards & Technology, May 2013.

[3] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated key exchange
secure against dictionary attacks.
In B. Preneel, editor, Advances in
Cryptology – EUROCRYPT 2000, volume 1807 of Lecture Notes in
Computer Science, pages 139–155. Springer, Heidelberg, May 2000.

[4] M. Bellare and P. Rogaway. Entity authentication and key distribution.
In D. R. Stinson, editor, Advances in Cryptology – CRYPTO’93, volume
773 of Lecture Notes in Computer Science, pages 232–249. Springer,
Heidelberg, Aug. 1994.

[5] F. Bergsma, B. Dowling, F. Kohlar, J. Schwenk, and D. Stebila. Multi-
ciphersuite security of the secure shell (SSH) protocol. In G.-J. Ahn,
M. Yung, and N. Li, editors, ACM CCS 14: 21st Conference on
Computer and Communications Security, pages 369–381. ACM Press,
Nov. 2014.

[6] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Pironti, and P.-
Y. Strub. Triple handshakes and cookie cutters: Breaking and ﬁxing
authentication over TLS.
In 2014 IEEE Symposium on Security and
Privacy, pages 98–113. IEEE Computer Society Press, May 2014.

[7] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and P.-Y. Strub.
Implementing TLS with veriﬁed cryptographic security. In 2013 IEEE
Symposium on Security and Privacy, pages 445–459. IEEE Computer
Society Press, May 2013.

[8] S. Blake-Wilson, D. Johnson, and A. Menezes. Key agreement protocols
and their security analysis.
In M. Darnell, editor, Crytography and
Coding, volume 1355 of Lecture Notes in Computer Science, pages 30–
45. Springer Berlin Heidelberg, 1997.

468468

[9] S. Blake-Wilson and A. Menezes. Authenticated Difﬁe-Hellman key
agreement protocols (invited talk).
In S. E. Tavares and H. Meijer,
editors, SAC 1998: 5th Annual International Workshop on Selected Areas
in Cryptography, volume 1556 of Lecture Notes in Computer Science,
pages 339–361. Springer, Heidelberg, Aug. 1999.

[10] S. Blake-Wilson and A. Menezes. Unknown key-share attacks on the
station-to-station (STS) protocol.
In H. Imai and Y. Zheng, editors,
PKC’99: 2nd International Workshop on Theory and Practice in Public
Key Cryptography, volume 1560 of Lecture Notes in Computer Science,
pages 154–170. Springer, Heidelberg, Mar. 1999.

[11] C. Boyd and J. Nieto. On forward secrecy in one-round key exchange.
In L. Chen, editor, Cryptography and Coding, volume 7089 of Lecture
Notes in Computer Science, pages 451–468. Springer Berlin Heidelberg,
2011.

[12] C. Brzuska.

On the Foundations of Key Exchange.

PhD the-
sis, Technische Universität Darmstadt, Darmstadt, Germany, 2013.
http://tuprints.ulb.tu-darmstadt.de/3414/.

[13] C. Brzuska, M. Fischlin, B. Warinschi, and S. C. Williams. Composabil-
ity of Bellare-Rogaway key exchange protocols. In Y. Chen, G. Danezis,
and V. Shmatikov, editors, ACM CCS 11: 18th Conference on Computer
and Communications Security, pages 51–62. ACM Press, Oct. 2011.

[14] R. Canetti and H. Krawczyk. Analysis of key-exchange protocols and
their use for building secure channels. In B. Pﬁtzmann, editor, Advances
in Cryptology – EUROCRYPT 2001, volume 2045 of Lecture Notes in
Computer Science, pages 453–474. Springer, Heidelberg, May 2001.

[15] L. Chen and C. Kudla.

Identity based authenticated key agreement
protocols from pairings. In 16th IEEE Computer Security Foundations
Workshop (CSFW-16 2003), pages 219–233. IEEE Computer Society,
June 2003.

[16] C. J. F. Cremers and M. Feltz. Beyond eCK: Perfect forward secrecy
In S. Foresti,
under actor compromise and ephemeral-key reveal.
M. Yung, and F. Martinelli, editors, ESORICS 2012: 17th European
Symposium on Research in Computer Security, volume 7459 of Lecture
Notes in Computer Science, pages 734–751. Springer, Heidelberg, Sept.
2012.

[17] T. Dierks and E. Rescorla. The Transport Layer Security (TLS) Protocol
Version 1.2. RFC 5246 (Proposed Standard), Aug. 2008. Updated by
RFCs 5746, 5878, 6176.

[18] B. Dowling, M. Fischlin, F. Günther, and D. Stebila. A cryptographic
analysis of the TLS 1.3 handshake protocol candidates.
In I. Ray,
N. Li, and C. Kruegel:, editors, ACM CCS 15: 22nd Conference on
Computer and Communications Security, pages 1197–1210. ACM Press,
Oct. 2015.

[19] B. Dowling, M. Fischlin, F. Günther, and D. Stebila. A crypto-
graphic analysis of the TLS 1.3 draft-10 full and pre-shared key
handshake protocol. Cryptology ePrint Archive, Report 2016/081, 2016.
http://eprint.iacr.org/2016/081.

[20] EMVCo LLC.

EMV ECC key

establishment

protocols.

http://www.emvco.com/speciﬁcations.aspx?id=243, 2012.

[21] K. Hoeper and L. Chen.

SP 800-120. Recommendation for EAP
Methods Used in Wireless Network Access Authentication. NIST
Special Publication, National Institute of Standards & Technology, Sept.
2009.

[22] T. Jager, F. Kohlar, S. Schäge, and J. Schwenk. On the security of TLS-
DHE in the standard model. In R. Safavi-Naini and R. Canetti, editors,
Advances in Cryptology – CRYPTO 2012, volume 7417 of Lecture Notes
in Computer Science, pages 273–293. Springer, Heidelberg, Aug. 2012.
[23] H. Krawczyk. HMQV: A high-performance secure Difﬁe-Hellman
protocol. In V. Shoup, editor, Advances in Cryptology – CRYPTO 2005,
volume 3621 of Lecture Notes in Computer Science, pages 546–566.
Springer, Heidelberg, Aug. 2005.

[24] H. Krawczyk, K. G. Paterson, and H. Wee. On the security of the TLS
protocol: A systematic analysis. In R. Canetti and J. A. Garay, editors,
Advances in Cryptology – CRYPTO 2013, Part I, volume 8042 of Lecture
Notes in Computer Science, pages 429–448. Springer, Heidelberg, Aug.
2013.

[25] B. A. LaMacchia, K. E. Lauter, and A. Mityagin. Stronger security of
authenticated key exchange.
In Provable Security, First International
Conference, ProvSec 2007, volume 4784 of Lecture Notes in Computer
Science, pages 1–16. Springer, Nov. 2007.

[26] A. Langley. Comment at the Real World Crypto (RWC) Workshop, New

York, Jan. 2014.

[27] A. J. Menezes, S. A. Vanstone, and P. C. V. Oorschot. Handbook of

Applied Cryptography. CRC Press, 1996.

[28] P. Morrissey, N. P. Smart, and B. Warinschi. The TLS handshake
protocol: A modular analysis. Journal of Cryptology, 23(2):187–223,
Apr. 2010.

[29] E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3
– draft-ietf-tls-tls13-10. https://tools.ietf.org/html/draft-ietf-tls-tls13-10,
Oct. 2015.

[30] E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3
– draft-ietf-tls-tls13-11. https://tools.ietf.org/html/draft-ietf-tls-tls13-11,
Dec. 2015.

[31] TLS Mailing List. Subject: Kill Finished (and other tricks for hard-
ware). https://www.ietf.org/mail-archive/web/tls/current/msg12162.html,
Apr. 2014.

[32] T. Ylonen and C. Lonvick. The Secure Shell (SSH) Protocol Architec-

ture. RFC 4251 (Proposed Standard), Jan. 2006.

469469

