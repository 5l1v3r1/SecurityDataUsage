Beyond Disk Imaging for Preserving User State in Network Testbeds

Jelena Mirkovic, Abdulla Alwabel and Ted Faber

USC Information Sciences Institute
{sunshine, alwabel, faber}@isi.edu

Abstract

Many network testbeds today allow users to create their
own disk images as a way of saving experimental state
between allocations. We examine the effect of this prac-
tice on testbed operations. We ﬁnd that disk imaging
is very popular among both research and class users.
Excessive disk image creation makes OS upgrades and
patches time-demanding, leading over time to experi-
ments that use old and vulnerable images. Since older
images are not supported on new testbed hardware this
hurts users by reducing their chance of successful re-
source allocation. Finally, disk images are usually large
requiring excessive storage space on testbeds.

We then propose and evaluate three alternatives to disk
imaging. We ﬁnd that each approach signiﬁcantly re-
duces storage requirements, and produces a list of OS im-
age customizations that may help testbed users upgrade
their images to newer OS versions. While this would
still be a very manual process, we believe our results
show promise and identify need for further research in
this area.

1 Motivation

Network testbeds, such as Emulab [14], DeterLab [3]
and Schooner [2], apply time-sharing of their resources
between multiple users. This means that users acquire
some amount of physical resources from the testbed for
their exclusive use, and relinquish them when they antic-
ipate they will not need them for a few hours. The testbed
saves experiment deﬁnition consisting of node topology,
node names, OS and node type choices, etc. so that a user
can recreate the experiment later. Testbeds provide a set
of base OS images that users can load on their experi-
mental machines. An OS image is a block level image
of the ﬁlesystem on a node, as described in [5]. Base
images usually involve several Linux ﬂavors, such as Fe-
dora Core, Red Hat and CentOS, and some Windows ﬂa-
vors, such as Windows XP. Images contain some basic

1

set of utilities and software that is needed by majority of
users.

Often, users install additional software and OS mod-
ules during experimentation and may generate or down-
load data on experimental nodes as well. This user-
created state is removed from nodes when the experiment
returns its resources to the testbed, and must either be ex-
plicitly saved by a user or recreated from scratch when
the user resumes experimentation.

One way to recreate user state is to place this burden
on users, who must set up desired state either manually
or by scripting installation instructions and running them
whenever they experiment. This is a signiﬁcant burden
for users, not only in the time needed to create scripts,
but also in time and bandwidth cost added to experiment
creation, if software to be installed and data to be placed
on nodes must be fetched from remote sites.

Another possible solution is letting users hold on to the
testbed resources until they complete experimentation.
This is obviously undesirable for testbed operations, be-
cause it ties resources during user-idle times, when they
could be used by others.

In fact, testbeds motivate users to release resources
whenever possible, by measuring node idle time and
reclaiming experiments that have been idle for several
hours. Owners of long-running experiments that opt out
from this policy are manually contacted by testbed oper-
ations staff to urge them to release resources if they do
not need them. To help users preserve state they created,
network testbeds enable users to create custom OS im-
ages of their nodes, store them on the testbed, and use
them on a future resource allocation.

This paper is the ﬁrst that investigates the impact of
this policy on network testbed operation and on user ex-
perience. We obtain and analyze custom OS images and
their use records from the DeterLab testbed [3]. Custom
images offer signiﬁcant utility to users, in that they cap-
ture changes made to the operating system, or at a very
low level on the disks. We acknowledge these advan-

tages, but note signiﬁcant problems in disk image imple-
mentation and use practice.

We ﬁnd that custom images continue to be used for
an extended period of time after base image creation.
As testbed software and hardware evolve, many of the
base images used to create custom images become un-
supported. This means that testbed staff does not patch
these images and does not ensure that they support any
new testbed functionalities, because staff time is limited.
It also means that old base images are not ported to any
new hardware, mostly because they lack driver support.
Users that continue to use custom images created off of
these old base images reduce their chances of successful
resource allocation, because their experiments can only
be hosted by a portion of the testbed’s resources. This
leads to dissatisﬁed users who do not understand that
their difﬁculties are direct consequences of their actions,
creates a bad reputation for the testbed and increases the
number of support requests for the staff.

Another undesirable attribute of custom images in
general, is that these are rarely patched for vulnerabili-
ties. In case of testbeds that allow external trafﬁc to ex-
periments, like Emulab [14], this increases the chance
of experimental machines being subverted by outside at-
tackers and misused. While closed testbeds like Deter-
Lab [3] do not run this risk, their staff occasionally dis-
covers problems in base images and patches them. These
patches do not propagate to custom images created off of
these base images. For example, in March 2012 Deter-
Lab staff has discovered and patched a race condition in
its Ubuntu 10.04 image. The race condition made ma-
chines running this image unable to complete their boot
process, and the entire resource allocation attempt would
fail. The patch was advertised on DeterLab’s Web page
[3], clearly visible to all users. In three months, only 8
out of 32 custom images created from Ubuntu 10.04 base
have been patched.

Yet another undesirable outcome of allowing users to
create custom images is proliferation of these and signif-
icant storage they require. We ﬁnd that almost half of
testbed projects create custom images on DeterLab. In
April 2012, these images occupied 340 GB of testbed
storage — one third of the total shared disk space — of-
ten times leading to severe space shortage, affecting all
testbed users.

We hypothesize that the main reason why users do
not update or upgrade custom images is that they lack
a detailed list of modiﬁcations they have made. Exper-
imentation often occurs over weeks and months, evolv-
ing from an idea to a set of conﬁgurations, installations
and scripts. Many customizations may be done manu-
ally over a long time period, and the image created this
way may be used for months and years after. It would
be very difﬁcult for humans to recall the customizations

they made and their order after such a long time.

In this paper we propose and evaluate three alterna-
tives to disk imaging for preservation of user-created
state:

1. DiffBase: Storing ﬁles that are added or modiﬁed
from the base image, and storing the list of ﬁles
deleted from the image

2. DiffCustom: DiffBase approach, extended to detect
similar images within the same project. For this
group of images, only one needs to be saved using
DiffBase approach, while others can be preserved
by storing differences between them and the ﬁrst
image.

3. AppStore: Detecting common application installa-
tions within custom images and storing just the ap-
plication conﬁguration ﬁles. The rest of the image
is stored using either DiffBase or DiffCustom ap-
proach.

Each of the proposed approaches would, to an extent,
solve the image upgrade problem because it enumerates
the customizations found in the image, making it easier
for users to recall how and why they were made. It would
further reduce storage requirements for images to only
19-25% of the current state.

2 Related Work

Other researchers have looked at tracking ﬁle system
changes, though our goals of space saving and controlled
updates are unusual. Of particular interest are disk imag-
ing in the virtual machines such as VMware [13] or
QEMU [15], and ﬁlesystem checkpointing, in the Em-
ulab system [14], versioning ﬁlesystems, and ﬁlesystem
checkpointing systems.

VMware [13], QEMU [15], and other virtual machine
systems use ﬁlesystem level diffs to create snapshots.
Each snapshot is a map of the blocks changed from a
base image. These diff chains are similar to our pro-
posed system in that they preserve differences between
the base and the custom image, but these are preserved at
the block level while we operate at the ﬁle level. Block-
level diffs cannot be used to update or upgrade an image,
and they do not provide a space-efﬁcient upgrade path for
new hardware, while ﬁle-level diffs can achieve all this.
Further, block-level diffs can indicate larger than actual
changes, if existing ﬁle’s contents are merely shifted in
the ﬁlesystem. Our system would record this as a ﬁle
move, while the block-level system would regard it as a
ﬁle change, resulting in a bigger state.

Emulab [14] has produced a system that allows users
to checkpoint their ongoing experiments, including ﬁle

2

system state [4, 10]. The system they use to capture
ﬁlesystem state is conceptually similar to our method of
capturing and overlaying ﬁlesystem diffs. They are con-
cerned more with runtime speed than storage efﬁciency.
Accordingly, they use copy-on-write-based branching to
record differences from a base or ”golden” disk image at
run time. The system modiﬁes the Xen virtual machine
to capture these changes at the disk block level [10].

Because we want to capture the semantics of modiﬁca-
tions to the ﬁles in base disk image in order to simplify
updates to the users’ derived images, a block level ap-
proach is not attractive. We are also willing to pay the
cost of off-line analysis to achieve better disk space sav-
ings.

Other ﬁlesystem implementations have captured up-
date semantics at the ﬁle level, primarily to provide a
fully versioned ﬁle system. The ext2cow system [8] be-
gan as an attempt to capture the evolution of the ﬁle sys-
tem contents to ensure and enforce compliance with data
retention and security regulations. It has become a gen-
eral versioning system in which users can explicitly refer
to ﬁle system contents on a particular date. The Elephant
[12] ﬁle system tracks similar information, allowing the
user to specify data retention policies per-ﬁle.

These systems provide new semantics – per-ﬁle-
versioning across an entire ﬁlesystem – and are willing
to pay for it in disk space. Each of them modiﬁes the
traditional ﬁle system semantics to write modiﬁcations
to new blocks, and keep the old blocks unchanged and
indexed to a version of the ﬁle. While we would take
advantage of such versioned ﬁle systems if they were in
use, we do not depend on collecting such data.

Several systems provide block-level snapshots of a
mounted ﬁle system. These include FreeBSD [7], Plan 9
[9], WAFL [6], zFS [11] and others. These retain blocks
in the snapshots, indexed to the snapshot points, and
store modiﬁcations in new blocks. Unlike ﬁle-versioning
ﬁle systems, information about which ﬁles have been
changed is only indirectly retained. These systems are
less concerned with saving space and would not produce
useful information for users who wish to upgrade their
custom images.

3 Disk Image Usage on DeterLab

We now provide some supporting evidence about the fre-
quency and the characteristics of disk image use on the
DeterLab testbed [3]. Speciﬁcally, we wanted to know
how prevalent is use of disk images in experiments, who
uses them, for how long, and what portion of the testbed
supports each given image.

Unfortunately,

information needed to answer these
questions is not readily preserved by the Emulab soft-
ware, and must be inferred by piecing together various

data sources, and ﬁxing inconsistencies. In our study we
use two information sources:

1. DB: DeterLab’s database holding information about
all existing disk images at the present, such as their
creation time, the owner and the OS type and ver-
sion number of the base image used to create them.
We note that the last two pieces of information are
ﬁlled manually by users and thus may be incorrect.
We attempt to correct them in Section 4. A user may
delete an old image from the database when it is no
longer needed. This action also deletes the image
from the disk and we lose all information about its
origin and contents.

2. USE: DeterLab’s activity logs specifying topolo-
gies and testbed state for each attempted resource
allocation. From these logs we can mine informa-
tion about how often and how long images are used
(mined from experiment topology data), and what
portion of the testbed nodes supports any given im-
age (mined from testbed state data). The USE data
source contains information about use patterns for
both the present and the deleted images.

We ﬁrst classify all images into three classes: USE-
DEL, DBUSE and DBNOUSE. Figure 1 illustrates re-
lationships of these image classes and their sizes. If an
image has been created, used and then deleted it would
not appear in our ﬁrst data source but it would appear in
the second. There are 483 such images (USEDEL). We
can calculate their usage statistics and coverage, but we
cannot match them with the base image nor do we know
when they were created. In that case we will assume that
such image was created at the time of its ﬁrst use in the
activity logs. If an image has been created and deleted
but never used we will not see it in any of our sources.
For images that have not been deleted we have com-
plete information, whether they are used or not. There
are 148 images that were created but never used (DB-
NOUSE), and 497 images that were created, used and
are still present in the database (DBUSE). This subset of
645 images (DBUSE+DBNOUSE) will be analyzed fur-
ther in Section 4. We analyze 1128 images that belong
to the VISIBLE set (DBUSE+DBNOUSE+USEDEL) in
this Section. In the Figure 1 the numbers in circles repre-
sent the count of images in each category that have never
been used. Total of 148 out of 645 images present in the
DB data source, or 22%, have never been used. Deleting
just these would reduce the storage requirement to 78%
of the current one.

We ﬁrst investigate how prevalent is image creation.
On Emulab-like testbeds such as DeterLab [3], Emu-
lab [14], Schooner [2] and numerous others [1], senior
researchers and teachers create projects, that junior re-

3

class projects created 124 images. Internal projects cre-
ated many more – 255 images, but most of these are cre-
ated as base images for consumption by all users. We
could not ﬁnd an owner for 11 images. Figure 2 shows
the number of images created per a research or a class
project. While averages are 10 for research projects and
7 for class projects, detailed analysis reveals that image
creation activity is heavily dominated by a few projects.
We ﬁnd that most projects create a few images — 21%
create only 1 and 50% create less than 5 — but some cre-
ate up to 52 images! More numerous the project images
are, there is a higher chance that most of them are lying
unused and that they are not being patched.

We next investigated how often disk images were used
and for how long. There were 74,645 resource alloca-
tions on DeterLab between 2004 and 2012. Out of these
74,633 used a base image and 10,811 used a custom im-
age. 1 Thus 14.4% of allocations use a custom image. If
we calculate an age of an image from its base’s creation
date, we ﬁnd that 12,231 allocations used an image from
our ANALYZED set (see Figure 1 and Section 4 for ex-
planation of this set) and 5,767 of those, or 47%, used an
image older than one year. Older images are more likely
to have vulnerabilities, and more likely to be unsupported
by new testbed hardware.

We next investigated if custom image creation and use
get more or less popular over time. Figure 3 shows the
number of custom images created per year, indicating
that image popularity is growing over time. To inves-
tigate use trends, we placed each custom image used in a
year into a category based on what percentage of Deter-
Lab’s PCs that exist in a given year support this image.
Figure 4 shows the number of custom images in use each
year that are supported on less than 50% of DeterLab’s

1It is possible for an allocation to use both base and custom images

for different physical nodes.

Figure 2: Images created per project (only for research
and class projects that created at least one image).

Figure 1: Image classes and their sizes. Numbers in cir-
cles denote count of unused images, while numbers out-
side the circles show counts of used images.

searchers and students join. Usually experiments and im-
ages can be shared easily within a project, but with great
difﬁculty across projects. We thus analyze image use at
the project granularity. We say that a project is active
if it has ever requested testbed resources. An inactive
project cannot create an image. On DeterLab there are
219 projects that were ever active. We classify them by
their purpose into either research, class or internal (lead
by DeterLab’s operation staff). There are 161 research
projects, 43 class projects and 11 internal projects. There
were 4 projects we could not classify, because they were
deleted. Out of all active projects, 104 have created those
1128 images, which is 47%.

We next wanted to associate each image with the
project that created it, so we can analyze image creation
activity per project. DeterLab’s database holds informa-
tion about image owners for those images that have not
been deleted. To detect owners for deleted but used im-
ages (USEDEL), we use the fact that an image created
by a project can only be used by this project. This ac-
cess control rule is enforced by Emulab testbeds. The
only exception to this are base images created by testbed
staff that can be used by anyone. We then classify im-
ages used by multiple projects as base images and as-
sign images used by only one project to that project. Out
of 104 projects that created images, 77 were research
projects (48% of all research projects), 19 were class
projects (44% of all class projects), 6 were internal, and
2 we could not classify, because the projects and their
descriptions were deleted from the database. Thus we
can say that image creation is a popular activity among
both research and class testbed users, with almost half of
projects creating at least one image.

Research projects created total of 735 images, and

4

ANALYZED=506NOIMG=39CORRUPT=62ORPHANS=38USEDEL=483DBNOUSE=81+21+26+20 = 148DBUSE=425+18+18+36 = 49781212620425183618VISIBLE=1128 0 10 20 30 40 50 60 0 10 20 30 40 50 60 70 80 90 100Images createdProjects4.1 DiffBase
Our DiffBase approach compares a customized image,
ﬁle by ﬁle, with its base during disk image creation, and
stores the differences instead of storing the entire custom
image. Files that are deleted from the base image are
stored in a list. Files that are added to or modiﬁed from
the base image are stored in their entirety. For sparse
ﬁles, where most of the ﬁle is empty, we store the ﬁle
size and the identiﬁers and contents only for those ﬁle
blocks that contain data. Similarly, we detect and store
information about hard and soft links that helps us recre-
ate them on OS load.

Figure 5: Storage needs when using DiffBase approach,
compared the with current system, which saves the entire
image.

To evaluate the savings of this approach we simulated
the DiffBase approach on all the custom images on Deter-
Lab. We started with the DB set (DBUSE+DBNOUSE),
as deﬁned in Section 3 and ﬁrst attempted to locate and
OS load each image. We discovered that 62 images were
corrupted and would not load (CORRUPT set in Figure
1), 39 images were deleted from the ﬁle system but their
records were present in the database (NOIMG set), and
38 images were orphans (ORPHAN set) – they claimed
to be created from a base image that did not exist in the
database at the time of our analysis. Removing all these
classes left us with 506 images in the ANALYZED set.
Among them were 33 base images and 473 custom im-
ages. All the image classes and their sizes are illustrated
in Figure 1; dashed circles denote the number of images
that were not used by anyone.

We ﬁrst attempted to pair a custom image with its base,
using the data recorded in DeterLab’s database. How-
ever, this data is entered manually by users and may be
incorrect, leading to large differences between the base
and the custom image. We manually veriﬁed that this is
a case for several images, by mounting them and identi-
fying the OS type and version by executing uname -a,
looking at the ﬁle system type, and checking /etc di-

Figure 3: Custom images created per year.

PCs, on 50-80%, on 80-90% and on more than 90% of
DeterLab’s PCs. We note that the number of custom im-
ages in use is increasing. Further, there is a signiﬁcant
number of custom images in use each year that are only
supported on a fraction of the testbed. For example, in
2011 there were 15 images supported on less than a half
of the testbed PCs.

4 Alternatives to disk imaging

In this Section, we propose three alternatives to disk
imaging for preserving user state in network testbeds.
While our ideas are general enough to work on any net-
work testbed, the implementation and measurement de-
tails we lay out here are speciﬁc to testbeds running Em-
ulab [14] software.

Figure 4: Custom images in use per year, broken down
into categories based on what portion of DeterLab’s PC
pool supports them.

5

 0 50 100 150 200 25020042005200620072008200920102011Custom images createdYear 0 10 20 30 40 5020042005200620072008200920102011Images usedYear< 50%50-80%80-90> 90% 0 20 40 60 80 100 120 140 160 18001-1011-2021-3031-4041-5051-6061-7071-8081-90Image countPercent of an image that must be savedrectory for release information. Often, this returned a
different OS version, and sometimes even a different OS
type than the one speciﬁed in the database. To overcome
this issue we compared each custom image against all
base images and paired them with the one that had the
most similarity (and thus the smallest difference). This
analysis occasionally associates two images that are not
directly related, because both the base image and the cus-
tom image can be updated. If a base image is patched
to remove a large software package, an image derived
from the base (that still contains the package) may appear
to have been derived from a different base image that
contains that package. We have noted some such false
correlations in our analysis, but they are uncommon. In
real deployment, the Emulab software keeps information
about the images loaded on all experimental nodes, and
could accurately identify the base for each custom image
that is being created, thus this issue would not arise.

Figure 5 shows on the y-axis the count of the custom
images, for which only the percentage speciﬁed on the
x-axis needs to be saved, using DiffBase approach. For
example, there were nine images that were identical to
the base images and need not be saved. Also, there were
123 images or 26% of all custom images that had less
than 10% difference from a base image. Overall, apply-
ing DiffBase approach would reduce the size currently
used for disk image storage on DeterLab from 340 GB to
87 GB, or to 25%.

We now describe how our custom images would be
loaded onto experimental nodes, and evaluate potential
delays that are introduced by our changes to the OS load
process. Currently, the OS load ﬁrst loads the MFS onto
each experimental node, and then invokes Frisbee [5] to
copy the desired custom or base image to the node from
the testbed repository. The duration of MFS load is ﬁxed,
but the duration of copying the image over grows linearly
with the image size. Since copying occurs over the net-
work shared with other experiments, there is a potential
for large variability if other experiments are loading im-
ages at the same time. The current system then boots
the image on the experimental node. The duration of
that operation depends on the image’s complexity.
In
each of our alternatives to disk imaging, the new sys-
tem would copy and load the base image onto the ex-
perimental node, restore preserved user state by copying
some ﬁles and/or installing packages, and then reboot the
node.

Figure 6 illustrates the OS load in the current and the
proposed system. While all our solutions should lead to
space saving, they might prolong the OS load process
because of added state copy and reboot time.

We next evaluated the delay the DiffBase approach
adds to the OS load time on selected 12 custom im-
ages, created from the Ubuntu 10.04 base image. We

Figure 6: OS loading process in the current and the pro-
posed system.

ﬁrst loaded each custom OS on a separate experimental
machine, and recorded the time to complete this opera-
tion – this is time T1 in Figure 6. We took care to se-
lect the machines of the same hardware type, since we
have noticed that the time to Frisbee an image over the
testbed network depends on the hardware type. We then
applied the DiffBase approach to identify and store dif-
ferences between each custom image and its base. We
next loaded the base OS on each of the 12 experimental
machines, copied over a zip ﬁle containing the ﬁles that
were saved using the DiffBase approach, unzipped them
there and copied them to their proper directories. We fur-
ther deleted the ﬁles that were identiﬁed for deletion by
the DiffBase approach and restored soft and hard links,
and sparse ﬁles. Finally, we rebooted each experimen-
tal node. We recorded each of the base-OS-load, restore
and reboot times separately. Their sum represents time
T2 from Figure 6. This time will depend on the size
of the base image (Frisbee copy), the size of the Diff-
Base state, and the complexity of the base image. Table
1 shows the images we tested ordered by their size, the
sizes of DiffBase state, and the means and standard devi-
ations for T 1 and T 2 extracted from 10 runs of the above
experiment. Figure 7 shows the T 1 and T 2 times. All
images booted successfully. For small images, time to
load the image using DiffBase approach is comparable to
the OS load time in the current system. For large images
we tested (images 9-12) DiffBase approach surprisingly
results in a smaller OS load time! This is because the
size of each large custom image in our set is about 50%
larger than the size of its base image plus the size of its
DiffBase state. Since time to Frisbee an image dominates
our measurements, a larger custom image leads to much
larger OS load time in the current system.

6

MFS loadFrisbee OS imageBoot custom OS Boot base OS Restore ﬁles / packagesRebootf (image_size)f (image_complexity)f (image_complexity)f (image_complexity)timef (state_size)T1T2CURRENTPROPOSEDfCustom approach. For example, there were ten images
that need not be saved at all because they are identical
to either a base image or another custom image. Also,
there were 164 images, or 35% of custom images in our
ANALYZED dataset, that had less than 10% difference
from either a base image or another custom image. Over-
all, applying DiffCustom approach would reduce the size
currently used for disk image storage on DeterLab from
340 GB to 75 GB, or to 22%.

Figure 7: Time to OS load with the current and the Diff-
Base approach.

While DiffBase approach has its obvious advantages
in space saving, there are certain limitations. Because
DiffBase captures ﬁle contents, it cannot support research
that requires saving state inside the ﬁle system but out-
side ﬁles. For example, studies of incompletely erased
ﬁles or corrupted free lists would be compromised by the
DiffBase approach. We note that the standard Emulab
approach to disk imaging [5] also parses the ﬁle system
to some extent and might compromise these studies.

4.2 DiffCustom
Our DiffCustom approach compares a custom image with
another custom image from the same project, following
our hypothesis that users create a series of related cus-
tom images as they explore options during their experi-
mentation. For a group of similar custom images within
the project, only one needs to be saved using DiffBase
approach, while others can be preserved by storing dif-
ferences between them and the ﬁrst image.

To evaluate the savings of this approach, we simulated
the DiffCustom approach on the ANALYZED dataset.
For projects that create multiple custom images, we per-
formed a pairwise image comparison within the project,
and recorded the image pairs that are the most similar, as
well as the size of the state that would need to be saved
for them.

There were 124 custom images, where the owner
project created at least one other custom image. For 16
of those, DiffBase generated a smaller state than DiffCus-
tom indicating that they are branched off a different base
image than the rest of their project’s custom images. The
remaining 108 images would beneﬁt from the DiffCus-
tom approach.

Figure 8 shows on the y-axis the count of the cus-
tom images, for which only the percentage of the im-
age speciﬁed on the x-axis needs to be saved using Dif-

Figure 8: Storage needs when using DiffCustom ap-
proach, compared the with current system, which saves
the entire image.

4.3 AppStore
While the DiffBase and DiffCustom approaches result in
signiﬁcant space savings, they produce large lists of ﬁles
to be saved – commonly in hundreds or thousands. While
such a list may help a user remember which customiza-
tions they performed on the base image, and thus facili-
tate upgrading an image to a newer OS version, this pro-
cess would still be highly manual, tedious and lengthy.
Our AppStore approach has a potential to address this
shortcoming. This approach examines each ﬁle identiﬁed
for saving by DiffBase approach, to detect if it belongs to
an application installation we can recognize. Files that
pass this check need not be saved by DiffBase approach,
but can instead be installed from some central testbed
repository upon each OS load. We would need to store
the application conﬁguration ﬁles though, so that we can
preserve any customizations the user did to the applica-
tion. The AppStore approach has a potential to both re-
duce the storage space requirement further, and to enable
users to upgrade their custom images to a newer version
of an operating system. The upgrade could be done by
starting with a newer OS version, and by automatically
installing packages identiﬁed by the AppStore. The re-
maining ﬁles, stored by DiffBase approach, would still
need to be examined by a user, so that they could be up-
graded or moved directly to the new image.

7

 160 180 200 220 240 260 280 300 320 340 0 2 4 6 8 10 12Time to OS load (s)Image IDCurrent (T1)DiffBase (T2) 0 20 40 60 80 100 120 140 160 18001-1011-2021-3031-4041-5051-6061-7071-8081-90Image countPercent of an image that must be savedImage #

Imgsize (MB) Diffsize (MB)

base

1
2
3
4
5
6
7
8
9
10
11
12

357
357
357
358
360
420
465
489
516
1,034
1,035
1,034
1,035

55
55
55
200
63
100
135
267
465
465
465
465

T 1mean (s)

168
184
178
183
186
196
210
208
222
320
314
316
316

T 1stdev(s)

5.14
7.21
8.66
5.4
8.36
8.81
11.39
11.9
29.2
9.08
5.28
14.22
7.73

T 2mean (s)

T 2stdev(s)

180
191
190
191
190
198
204
240
241
241
238
231

5.23
6.52
6.19
5.97
6.22
6.52
7.25
8.94
7.48
8.29
7.20
6.27

Table 1: Times for restoring user state using DiffBase approach.

To estimate potential savings and applicability of the
AppStore approach, we analyzed a sample of Deter-
Lab’s custom images containing 51 images created from
Ubuntu 8.04 and 20 images created from Ubuntu 10.04.
DeterLab currently mirrors repositories for these base
images, although only selected packages are mirrored.
For this selected set of custom images, we sampled ﬁle
names from their DiffBase state. Sampling was done due
to time constraints and it leads to underestimate of po-
tential savings from the AppStore approach. Using the
apt-file utility, we check each sampled ﬁle name to
see if this ﬁle were part of a standard package. If so, we
retrieve the list of all ﬁles in the package from the repos-
itory, and remove those ﬁles from the image’s DiffBase
state, if present.

Figure 9 illustrates potential savings by the AppStore
method. It shows the count of custom images from the
sample on the y-axis, for which only the percentage of
their DiffBase state speciﬁed on the x-axis needs to be
saved. We note signiﬁcant savings for Ubuntu 10.04-
based images and lower savings for Ubuntu 8.04-based
images. This discrepancy occurs because DeterLab’s lo-
cal repository contains only a subset of available pack-
ages, and the size of this subset is much smaller for
Ubuntu 8.04 than for Ubuntu 10.04. Overall, we project
that only 70-80% of DiffBase state would need to be
saved for those images that support package manage-
ment. Thus, AppStore would potentially further reduce
the size currently used for disk image storage on Deter-
Lab from 340 GB to 65 GB, or to 19%.

Figure 9: Storage needs when using AppStore approach,
compared with the DiffBase approach.

ages that may have vulnerabilities, and are not supported
on new testbed hardware.
It also leads to signiﬁcant
use of sparse and shared storage space. We have pro-
posed three alternatives to disk imaging. Each alternative
would signiﬁcantly reduce storage space requirements,
and may help users upgrade their custom OS images to
newer OS versions. While this paper offers strong evi-
dence of space saving, we have only sketched potential
solutions for custom image upgrade. Our future work
will further investigate how to automate the upgrade pro-
cess.

References

5 Conclusions and Future Work

[1] Other Emulab Testbeds.

Disk imaging is extensively used in DeterLab, and likely
in other network testbeds, for user state preservation. We
ﬁnd that such practice leads to extended use of old im-

https://users.emulab.net/trac/emulab/
wiki/OtherEmulabs.

[2] Schooner WAIL (Wisconsin Advanced Internet

8

 0 2 4 6 8 10 12 14 16 1831-4041-5051-6061-7071-8081-9091-100Image countPercent of a DiffBase state that must be savedUbuntu 8.04Ubuntu 10.04Laboratory).
http://www.schooner.wail.wisc.edu.

[3] R. Bajcsy, T. Benzel, et al. Cyber Defense

Technology Networking and Evaluation.
Communications of the ACM, 47(3):58–61, 2004.

[4] Anton Burtsev, Prashanth Radhakrishnan, Mike

Hibler, and Jay Lepreau. Transparent checkpoints
of closed distributed systems in Emulab. In
Proceedings of the 4th ACM European conference
on Computer systems, EuroSys ’09, pages
173–186, 2009.

[5] Mike Hibler, Leigh Stoller, Jay Lepreau, Robert

Ricci, and Chad Barb. Fast Scalable Disk Imaging
with Frisbee. In Proceedings of the USENIX
Annual Technical Conference, 2003.

[6] Dave Hitz, James Lau, and Michael Malcolm. File
system design for an NFS ﬁle server appliance. In
Proceedings of the USENIX Technical Conference,
1994.

[7] Marshall Kirk McKusick and Gregory R. Ganger.

Soft updates: a technique for eliminating most
synchronous writes in the fast ﬁlesystem. In
Proceedings of the USENIX Annual Technical
Conference, 1999.

[8] Zachary Peterson and Randal Burns. Ext3cow: a

time-shifting ﬁle system for regulatory
compliance. ACM Transactions on Storage,
1(2):190–212, 2005.

[9] Rob Pike, David L. Presotto, Sean Dorward, Bob
Flandrena, Ken Thompson, and Howard Trickey.
Plan 9. Computing Systems, 8(2):221–254, 1995.

[10] Prashanth Radhakrishnan. Stateful-Swapping in

the Emulab Network Testbed. Master’s thesis,
School of Computing University of Utah, 2003.

[11] Ohad Rodeh and Avi Teperman. zFS: A Scalable

Distributed File System Using Object Disks. In
Proceedings of NASA Goddard Conference on
Mass Storage Systems and Technologies (MSS’03),
2003.

[12] Douglas J. Santry, Michael J. Feeley, Norman C.

Hutchinson, and Alistair C. Veitch. Elephant: The
File System that Never Forgets. In Proceedings of
the The Seventh Workshop on Hot Topics in
Operating Systems (HOTOS), 1999.

[13] VMware. Understanding virtual machine

snapshots in VMware ESXi and ESX.
http://kb.vmware.com/selfservice/
microsites/search.do?language=en_
US&cmd=displayKC&externalId=1015180.

[14] Brian White, Jay Lepreau, Leigh Stoller, Robert
Ricci, Shashi Guruprasad, Mac Newbold, Mike
Hibler, Chad Barb, and Abhijeet Joglekar. An
Integrated Experimental Environment for
Distributed Systems and Networks. In
Proceedings of the Fifth Symposium on Operating
Systems Design and Implementation (OSDI),
pages 255–270, Boston, MA, December 2002.

[15] Wikibooks. QEMU/Images.

http://en.wikibooks.org/wiki/QEMU/
Images#Copy_on_write.

9

