2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Forward Secure Asynchronous Messaging from

Puncturable Encryption

Matthew D. Green and Ian Miers

Department of Computer Science

The Johns Hopkins University

Baltimore, USA

[mgreen,imiers]@cs.jhu.edu

Abstract—In this paper we investigate new mechanisms for
achieving forward secure encryption in store and forward mes-
saging systems such as email and SMS. In a forward secure
encryption scheme, a user periodically updates her secret key
so that past messages remain conﬁdential in the event that her
key is compromised. A primary contribution of our work is to
introduce a new form of encryption that we name puncturable
encryption. Using a puncturable encryption scheme, recipients
may repeatedly update their decryption keys to revoke decryption
capability for selected messages, recipients or time periods. Most
importantly, this update process does not require the recipients
to communicate with or distribute new key material to senders.
We show how to combine puncturable encryption with the
forward-secure public key encryption proposal of Canetti et al. to
achieve practical forward-secure messaging with low overhead.
We implement our schemes and provide experimental evidence
that the new constructions are practical.
I. INTRODUCTION

Asynchronous messaging services such as email and SMS
have become indispensable for personal and business com-
munications. In recent years, several messaging services have
begun to support end-to-end encryption in order to protect
content transmitted over insecure communications channels.
In this paper we address a speciﬁc drawback of many such en-
cryption schemes: they often fail to ensure the conﬁdentiality
of past messages in the event that a user’s key is compromised.
The necessary property, known as forward secrecy, is vital to
protecting user conﬁdentiality. This is particularly important
for messaging systems that use decentralized or cloud-based
delivery systems that may preserve older messages for indef-
inite periods of time.

While it is relatively simple to add forward secrecy to
interactive protocols such as TLS [23] or OTR [15], it is
far more challenging to achieve in asynchronous “store-and-
forward” messaging such as encrypted email, SMS, or in mes-
saging systems that offer delivery to ofﬂine users (e.g., Apple
iMessage and Google Hangouts). Indeed, none of the three
most popular encryption protocols for asynchronous messag-
ing, Apple iMessage [21], OpenPGP [17] and S/MIME [36],
provide a forward secrecy mechanism.

Addressing this problem is not trivial. Asynchronous mes-
saging systems do not mandate that senders and recipients be
online simultaneously, nor do they enforce two-way interaction
between parties. Messages may be delayed for substantial
periods due to delivery failures and connectivity issues, and

some extensions, such as “greylisting” for spam prevention in
email [28] and anonymous remailers/mixnets [22], intention-
ally introduce large delays in delivery.

Existing proposals for adding forward security to encrypted
email [39], [8], [40] add increased complexity and new points
of failure. They often require highly-available network in-
frastructure to distribute fresh key material to senders [39],
or force changes to client interaction, such as requiring an
initial message exchange prior to secure communications [33].
Beyond the added cost, such mechanisms are expensive to
scale and may fail against active attackers. As a concrete
example of these challenges, the TextSecure protocol used by
WhatsApp1 [4] implements an extremely ﬁne-grained forward
secrecy mechanism in which the client uploads hundreds of
ephemeral keys to an online server that in turn distributes them
to senders [32]. Not only are storage costs substantial, but an
attacker can easily exhaust a given recipient’s pre-key supply,
which causes the mechanism to fail open.

In Eurocrypt 2003, Canetti, Halevi and Katz [18] proposed
an alternative approach that does not require changes to
the key distribution model. Their proposal deﬁnes a forward
secure public key encryption scheme (FS-PKE) in which users
may publish a short, unchanging public key via existing
key distribution infrastructure. The novel element of FS-PKE
is an efﬁcient update procedure by which a user’s secret
key can, at time period T , be altered to revoke decryption
capability for any ciphertext encrypted during time period
< T . In principle, this can be used to achieve forward
T
security in existing messaging systems, under the relatively
mild requirement
that parties share (loosely) synchronized
clocks.

(cid:2)

Unfortunately FS-PKE has not been widely adopted. In part
this is because little work has been conducted to establish the
concrete performance characteristics of such a system. More
problematically, the Canetti et al. key update procedure is a
relatively blunt instrument: in removing decryption capability
for a given time period, a user necessarily loses access to
all messages sent during prior time periods. Thus the scheme
cannot provide ﬁne-grained deletion of messages, e.g., remov-
ing access to individual messages or messages from a single

1TextSecure is the encryption protocol used by the WhatsApp communica-

tion network, which has over 600 million users worldwide.

© 2015, Matthew D. Green. Under license to IEEE.
© 2015, Matthew D. Green. Under license to IEEE.
DOI 10.1109/SP.2015.26
DOI 10.1109/SP.2015.26

305
305

sender. The practical consequence is that an implementation
that aims to preserve user experience must by either risk
updating the key before all messages have arrived – or it
must leave some messages exposed until the receiver can be
certain that it is safe to wind the key forward. When one
factors in clock drift and delivery latency, the result may be a
period ranging from hours to weeks during which data remains
vulnerable.

Our contributions. In this work we systematically explore
the problem of providing forward secrecy in asynchronous
messaging systems. Our overall goal is to develop public key
encryption that allows for ﬁne-grained revocation of decryp-
tion capability only for speciﬁc messages, while minimizing
cost and storage requirements. As with the Canetti et al.
approach, our goal is to use short, unchanging public keys.
Unlike previous solutions, we require that the secret key update
procedure remove access at the level of individual ciphertexts
or message senders, while retaining the ability to decrypt all
other messages.

To achieve this goal, we employ two new ingredients. First,
we introduce a a new form of public-key encryption that sup-
ports revocation of individual messages. We refer to this new
encryption scheme as puncturable encryption. The primitive
can be thought of as a form of tag-based encryption [31] which
adds an efﬁcient Puncture algorithm that, on input the current
secret key SK and a tag t ∈ {0, 1}∗, outputs a new secret key
SK(cid:2)
that will decrypt all ciphertexts not encrypted under tag t.
Secret keys in this scheme can be repeatedly and sequentially
punctured at many different points, replicating the experience
of normal message deletion.

Second, we show how to merge puncturable encryption into
a variant of Canetti et al. FS-PKE, modiﬁed to allow ﬁne-
grained revocation of speciﬁc time intervals without revoking
all previous intervals. By combining these approaches into a
uniﬁed scheme, we show how to implement practical forward-
secure public key encryption under reasonable workloads.
More speciﬁcally, our contributions are as follows:

1) We deﬁne puncturable encryption, propose security deﬁ-
nitions for the primitive, and offer an efﬁcient construc-
tion secure under well-studied assumptions in bilinear
groups. Our construction is based on a non-monotonic
Attribute Based Encryption (ABE) scheme due to Ostro-
vsky, Sahai and Waters [35], modiﬁed to realize a new
key update functionality. After n puncture operations,
our construction features O(1) public key, ciphertext size
and encryption cost, and O(n) secret key storage and
decryption cost.

2) To improve efﬁciency, we show how to compose punc-
turable encryption with an optimized FS-PKE construc-
tion due to Boneh et al. [12] that allows for revocation
of individual time periods. This combination realizes the
“best of both worlds”, allowing a user to instantly delete
selected messages with precision, while dramatically
reducing decryption cost over puncturable encryption

total
alone. The advantage of this approach is that
decryption and key storage cost now grow linearly only
in the maximum number of messages received within
a given time period, and only logarithmically in the
number of time periods.
Interestingly, our results show that composing these
schemes is not simply a matter of running both in
parallel, but requires that they be carefully combined
such that the resulting keys provide collusion resistance
against an adversary who seeks to recombine keys from
different time periods.

3) Finally, we provide a software implementation of
the combined scheme both as a standalone library
libforwardsec and describe how to integrate it with
tools such as Gnu Privacy Guard [5]. We then use
the new tools to conduct experiments evaluating the
overhead of deploying puncturable and forward security
encryption under various simulated usage scenarios.

Outline of this paper. The rest of this paper is structured
as follows. In the remainder of this section we discuss the
intuition behind our constructions. In §II and §III we provide
background and formal deﬁnitions for the puncturable encryp-
tion primitive and in §IV present our main construction. In §V
we show how to combine puncturable encryption efﬁciently
with FS-PKE. In §VI, §VII, §VIII and §IX we describe the
implementation and evaluation of our proposals. In §X we
discuss other applications of these proposals. Finally, in §XI
we discuss related work.

A. Encryption Model

We now brieﬂy explain the framework we use to describe
encryption in asynchronous messaging systems. An asyn-
chronous messaging network consists of a set of senders and a
set of recipients, all interacting via an insecure channel. For the
purposes of this work we will assume that senders have some
means to obtain a single authentic public encryption key for
each recipient they wish to communicate with. Instantiations
of this model include the existing OpenPGP infrastructure, as
well as systems like Apple iMessage [17], [21].

Conversations can be broken down into two types of mes-
sage: initial messages between a sender and recipient, and
optional
interactive messages. In an asynchronous system,
each conversation consists of at least one initial message,
optionally followed by an interactive exchange between the
communicating parties. In this work we are primarily con-
cerned with the forward secrecy of initial messages, since the
forward secrecy of subsequent interactions may be achieved
by using an interactive “ratcheting” protocol such as OTR [15]
or TextSecure/Axolotl [32].

The approach we propose in this work is to attach to each
initial message a unique identiﬁer, or “tag”, generated by the
encrypting party. Upon receiving this message, the receiving
party may – at its discretion – revoke decryption capability
for the received message via a secret key update. Since our

306306

puncturable encryption constructions support tags in the space
{0, 1}∗, the sender can use any unique string for the message
identiﬁer. Example tags might include a GUID (which we
use in our experiments), or alternatively a concatenation of
sender ID and a monotonically-increasing message counter.
On receipt of a message, the recipient can securely revoke
decryption capability for only that message by “puncturing”
the secret key on that
tag. Our puncturable constructions
also support employing multiple tags per message. In this
case,
the unique message ID may be supplemented with
additional meta-data such as the sender ID. This approach
allows receivers to revoke entire classes of message (e.g., all
messages from a given sender).

There are two limitations of our approach: (1) the cost of
decrypting a message with a given key increases linearly in the
number of punctures in that key and (2) an active attacker may
block messages from reaching the recipient, thus preventing
the recipient from revoking access to these messages. To
address these concerns, in Section V we propose to combined
puncturable encryption with forward secure encryption. In this
approach, the sender simultaneously encrypts each message
with both a time period and a unique message identiﬁer. The
receiver may instantly perform both ﬁne-grained revocation of
the messages it receives, but also possesses a coarse-grained
update mechanism to revoke messages older than a certain
time period in the past. We refer to the time period for which
the recipient can decrypt as the “decryption window”. This
dual approach is roughly analogous to the ﬁne- and coarse-
grained revocation approach used in TextSecure [32], but does
not require distribution of pre-keys to the sender. Crucially for
efﬁciency, decryption time for a message arriving in interval
T is linearly only in the punctures done for interval T, not the
total number of punctures.

In Section IX we discuss choices for parameters such as
message ID format, time period interval length, and the size
of decryption windows.

B. Intuition: Puncturable Encryption

To explain the intuition behind our constructions, let us ﬁrst
address some trivial solutions. We consider schemes in which
an encryptor attaches a “tag” such as a message identiﬁer
(or time period identiﬁer) to each message sent to a given
receiver. The goal of the system is to allow the receiver
to selectively revoke the ability to decrypt speciﬁc tags. In
systems with only a polynomially number of time periods
(or “tags”) T , it is simple to realize (inefﬁcient) puncturable
encryption by generating a unique PKE keypair corresponding
to each “tag” a sender might encrypt under. Puncturing the
key is simply a matter of deleting the corresponding secret.
One can improve upon the O(|T |) public key size of this
construction using identity-based encryption to produce O(1)
sized public parameters for use as the public key, deriving IBE
decryption keys for all tags t ∈ T , and destroying the master
secret.

Unfortunately these simple approaches have secret key stor-
age that is linear in the total number of allowable tags, not the

current number of punctured tags. Not only is this inefﬁcient, it
limits the maximum number of possible tags (or time periods)
to be at most polynomial in the security parameter. This clearly
rules out exponentially-sized tag spaces, for example, strings
such as sender addresses or unique message identiﬁers. A
smaller tag space raises the possibility of tag collisions, where
multiple messages from different senders are given the same
tag, and thus the second message cannot be decrypted.

To address these issues, we take a different approach. Rather
than deleting elements from an existing decryption key, we
desire a structure that allows us to add new restrictions on what
the key can decrypt. The logical building block for our con-
struction is a form of attribute-based encryption scheme that
supports non-monotonic access formulas. In such schemes,
decryption keys may comprise boolean formula containing
both positive and negated attributes, e.g., “NOT t”.

In and of itself non-monotic ABE is not sufﬁcient

to
construct puncturable encryption, since we must also support
the ability to add negations to an existing decryption key. A
critical observation here is that by formulating a key containing
only negations, some constructions can be modiﬁed to support
the creation of new negations within an existing key.

Our concrete proposal begins with an NM-ABE construc-
tion due to Ostrovsky, Sahai and Waters [35], which we
conﬁgure as a form of tag-based encryption supporting a ﬁxed
number d of tags per ciphertext. To generate a key pair, a
user ﬁrst produces parameters for an instance of the ABE
scheme, publishes the public parameters as her public key PK,
derives a decryption key from the master secret key MSK, and
destroys the master secret MSK.

At all times subsequent to initial key generation, the recipi-
ent’s secret key is an ABE decryption key embedding a policy
consisting of only negated attributes. To puncture a key at an
additional point t, the recipient updates her existing secret key
to derive a new key that also embeds the negation of t. This
is possible in the Ostrovsky et al. scheme due to the structure
of these negated key components. Speciﬁcally, within each
negated key component, Ostrovsky et al. embed one secret
share λ of the master secret α. Due to the nature of this
scheme, it is possible to re-share the value λ from any given
(cid:2) and mauling the original key
key component, by generating λ
component to embed the share λ − λ
(cid:2). Simultaneously, one
may create a new negated key component embedding share
(cid:2), and bound to the newly punctured tag t. This provides
λ
our puncture algorithm, which can be operated an arbitrary
number of times.

Combining Puncturable Encryption with FS-PKE. As men-
tioned above, to ensure forward secrecy under active attack
and allow for more efﬁcient decryption, we need to combine
Puncturable Encryption with FS-PKE.

The na¨ıve approach to combining the two schemes is simply
to operate FS-PKE in parallel with puncturable encryption,

307307

encrypting every plaintext across both systems.2 However this
approach is problematic. There is no obvious mechanism
for reducing the complexity of a punctured secret key after
winding the FS-PKE key forward – i.e., for removing NOT
gates. To solve this problem, during time period T we might
instead retain a copy of the initial unpunctured secret key for
use in time period T + 1. Unfortunately this poses a new
challenge: if an attacker compromises the recipient’s computer,
she will be able to combine this unpunctured secret key with
the FS-PKE secret key for time period T , and thus access
messages that should be inaccessible.

Our solution to this problem is to cryptographically bind
the secret keys for the FS-PKE scheme with those for the
punctured encryption scheme. Thus an attacker who obtains
the secrets for time period T and T + 1 cannot recombine
any portions of the key to obtain access to messages deleted
during the earlier time period. In §V we show how to achieve
this combination using an efﬁcient FS-PKE derived from
a Hierarchical Identity-Based Encryption scheme of Boneh,
Boyen and Goh [12]. Given a maximum number of punctured
tags n, and a maximum number L of time periods,
the
combined scheme gives O(1) sized ciphertexts and public key,
and O(log(L) + n) secret key storage and decryption cost.
More importantly, we implement this scheme and show that
its actual costs are quite practical.

II. BACKGROUND

Notation. Throughout this paper we will use the following
notation. Let negl (·) represent a negligible function. Let M
represent the set of valid plaintexts for a scheme, and let T
represent the set of valid tags.
A. Bilinear Maps
Let G and GT be two multiplicative cyclic groups of prime
order p. Let g be a generator of G and e : G × G → GT be
a bilinear map with the properties:
1) Bilinearity: for all u, v ∈ G and a, b ∈ Zp, we have
2) Non-degeneracy: e(g, g) (cid:4)= 1.
We say that G is a bilinear group if the group operation in
G and the bilinear map e : G × G → GT are both efﬁciently
computable. In practice, we may also deﬁne bilinear groups
in the asymmetric setting, where a bilinear map is deﬁned as
e : G1 × G2 → GT for G1 (cid:4)= G2 and there is no efﬁcient
isomorphism γ : G1 → G2. We will describe our schemes in
the symmetric setting, and in §VI will discuss the process of
translating to the asymmetric setting.

e(ua, vb) = e(u, v)ab.

The schemes we present

in this work are provably se-
cure under the Decisional Bilinear Difﬁe-Hellman Inversion
(DBDHI) (see e.g., [12]) and the Decisional Bilinear Difﬁe-
Hellman assumption (DBDH) [11] in bilinear groups. For
reasons of space we will omit a deﬁnition of these assumptions
here, and refer the reader to the cited works.

2This encryption would be combined: example, a user might split a message
M using a 2-of-2 secret sharing and encrypt each share under one of the two
schemes.

308308

III. DEFINITIONS

In this section we provide the syntax and security deﬁnitions

for puncturable encryption.
A. Puncturable Encryption

algorithms
PPKE.Puncture) with the following syntax:

A puncturable encryption scheme is a tuple of probabilistic
(PPKE.KeyGen, PPKE.Encrypt, PPKE.Decrypt,
PPKE.KeyGen(1k, d) → (PK, SK0). On input a security
parameter k, and a maximum number of tags per cipher-
text d, output a public key PK and an initial secret key
SK0.
PPKE.Encrypt(PK, M, t1, . . . , td) → CT. On input a
public key PK, a plaintext M and a list of tags t1, . . . , td,
output the ciphertext CT.
PPKE.Puncture(PK, SKi−1, t) → SKi. On input a
secret key SKi−1 and a tag t, output a new secret key SKi
that can decrypt any ciphertext SK(cid:2)
can decrypt, except
for ciphertexts encrypted with t.
PPKE.Decrypt(PK, SKi, CT, t1, . . . , td) → {M}∪{⊥}.
On input a secret key SKi and a ciphertext CT, output a
plaintext M, or ⊥ if decryption fails.

We now deﬁne correctness and security for puncturable en-
cryption.
B. Correctness

∗
input (k, M, n, d, t1, . . . , tn, t
1, . . . , t

Correctness is deﬁned by the following experiment. On
1) Compute (PK, SK0) ← PPKE.KeyGen(1k, d)
2) If n > 0 then for i = 1, . . . , n compute SKi =

∗
d):

PPKE.Puncture(SKi−1, ti).

∗
3) Set CT = PPKE.Encrypt(PK, M, t
1, . . . , t

∗
d).

The scheme is correct if for all sufﬁciently large k; d > 0, n ≥
0 both polynomial in k; t1, . . . , tn ∈ T , t
d ∈ T \
∗
{t1, . . . , tn}, M ∈ M it holds that
∗
PPKE.Decrypt(SKn, CT, t
1, . . . , t

∗
d) = M

∗
1, . . . , t

with probability 1 − negl (k) taken over the random coins of
the experiment.
Remark. We allow for a negligible correctness error due to
the fact that in our constructions, it is desirable for size of the
secret key to be independent of the length of the tag strings.
In practice this implies some negligible probability that two
different tags will collide.
C. Security

Security for puncturable encryption is deﬁned by the IND-
PUN-ATK game, which we present in Figure 1. This game
incorporates both CPA and CCA variants. Intuitively, this is
similar to the indistinguishability deﬁnition for public key
encryption but adds the following new oracles.
On input any tag t ∈ T , the Puncture oracle updates
the secret key to revoke tag t. The adversary may query this

, d) and gives PK to the adversary.

Setup. On input a security parameter k and a maximum number of tags d, the challenger initializes two empty sets P, C and a counter
n = 0. It runs (PK, SK0) ← PPKE.KeyGen(1k
Phase 1. Proceeding adaptively, the adversary can repeatedly issue any of the following queries:
• Puncture(t): The challenger increments n, computes SKn ← PPKE.Puncture(SKn−1, t) and adds t to the set P .
• Corrupt(): The ﬁrst time the adversary issues this query, the challenger returns the most recent secret key SKn to the adversary and
If ATK = CCA the challenger computes M ←

sets C ← P . All subsequent queries return ⊥.
PPKE.Decrypt(SKn, CT, t1, . . . , td) and returns M to the adversary.

If ATK = CPA the challenger

• Decrypt(CT, t1, . . . , td):

returns ⊥.

d ∈ T . If the adversary has previously issued a
∗
d} ∩ C = ∅, the challenger rejects the challenge. Otherwise the challenger samples a random bit b, and
∗

∗
1, . . . , t

∗
1, . . . , t

Challenge. The adversary submits two messages m0, m1 ∈ M along with tags t
Corrupt query and {t
returns CT∗ ← PPKE.Encrypt(PK, Mb, t
Phase 2. This phase is identical to Phase 1 with the following restrictions:
• Corrupt() returns ⊥ if {t
• Decrypt(CT, t1, . . . , td) returns ⊥ if (CT, t1, . . . , td) = (CT∗
Guess. The adversary outputs a guess b
. The adversary wins if b = b

∗
d) to the adversary.

∗
1, . . . , t
(cid:3)

d} ∩ P = ∅.
∗

∗
1, . . . , t

∗
1, . . . , t

∗
d).

, t

(cid:3)

.

Fig. 1.

IND-PUN-ATK security game for puncturable encryption, with ATK ∈ {CPA, CCA}.

oracle repeatedly throughout the game, each time producing a
new secret key. The Corrupt oracle provides the adversary
with the most recent state of the secret key held by the
challenger. The adversary may challenge on a pair of messages
to the restriction that
and chosen tags t
the adversary cannot corrupt the secret key unless she has
∗
previously punctured at least one of the tags t
d. This
restriction prevents attacks in which the adversary may trivially
decrypt the challenge ciphertext.

∗
d, subject

∗
1, . . . , t

∗
1, . . . , t

The CCA variant of

the game also adds a decryp-
tion oracle. The adversary may call
this oracle at any
point on input (CT, t1, . . . , td) with the sole restriction that
(CT, t1, . . . , td) (cid:4)= (CT∗
∗
d), i.e., that she does not
query on the challenge ciphertext and tags. More formally:

∗
, t
1, . . . , t

Deﬁnition 3.1 (Security for puncturable encryption): A
puncturable encryption scheme is IND-PUN-ATK secure for
ATK ∈ {CPA, CCA} if for all p.p.t. adversaries A and for
sufﬁciently large k, it holds that A’s advantage in the IND-
PUN-ATK game is bounded by 1/2 + negl (k).

IV. CONSTRUCTIONS

We now present constructions that achieve, respectively,
CPA-secure and CCA-secure puncturable encryption under
reasonable assumptions in bilinear groups.

A. A CPA-secure construction

Figure 2 presents a CPA-secure construction of Puncturable
Encryption based on an Attribute-Based Encryption scheme
of Ostrovsky, Sahai and Waters (OSW) [35]. As discussed
earlier, the basic construction is an adaptation of the OSW
scheme, with the addition of a Puncture algorithm that, on
input a secret key SK and tag t outputs SK(cid:2)
with an additional
component for the negation of tag t. Our key observation
is that individual secret key components can be “re-shared”
using only public parameters. This process is described in the
Puncture algorithm.

309309

For space reasons we omit a proof of correctness and move
directly to our main security theorem for the security of the
CPA construction.

Theorem 4.1: The puncturable encryption scheme of Fig-
ure 2 is IND-PUN-CPA secure in the random oracle model
if the Decisional Bilinear Difﬁe-Hellman (DBDH) assumption
holds in G, GT .
The proof of Theorem 4.1 draws extensively from the proof
of [35], adding mainly the additional details of simulating the
Puncture algorithm. We sketch this proof in the full version
of this paper.of the full v.
B. CCA security

The puncturable encryption scheme presented in Figure 2
provides only CPA security. We now describe how to modify
this scheme to achieve CCA security. Our approach uses the
Fujasaki-Okamoto transform [24] which is commonly used to
efﬁciently transform a CPA-Secure scheme into a CCA-secure
one.

Let M(cid:2) ∈ {0, 1}(cid:2) be a plaintext

: GT × M(cid:2) × T d → Zp and H2

space and let
: GT →
H1
{0, 1}(cid:2) be two independent hash functions. Given the
CPA-secure puncturable encryption scheme (PPKE.KeyGen,
PPKE.Encrypt, PPKE.Decrypt, PPKE.Puncture) from Fig-
ure 2 where PPKE.Encrypt uses random element s ∈ Zp, we
deﬁne a modiﬁed scheme (PPKE.KeyGen, PPKE.Encrypt(cid:2)
,
PPKE.Decrypt(cid:2)
and
PPKE.Decrypt(cid:2)
PPKE.Encrypt(cid:2)(PK, M, t1, . . . , td). First select a random
element Σ ∈ GT , compute s ← H1(Σ, M, (t1, . . . , td))
and compute CT(cid:2) ← PPKE.Encrypt(PK, Σ, t1, . . . , td)
using s as the encryption randomness. Now output CT =
(CT(cid:2)

, PPKE.Puncture) where PPKE.Encrypt(cid:2)
are deﬁned as follows:

, H2(Σ) ⊕ M ).

PPKE.Decrypt(SKi, CT, t1, . . . , td).
parse CT as

(CT(cid:2)

and

, S)

First
compute Σ(cid:2) ←

PPKE.Keygen(1k

order p, a generator g and a hash function H : {0, 1}∗ → Zp. Chooses random exponents α, β ∈ Zp and set g1 = g
Finally sample r ∈ Zp and a degree-d polynomial q(·) subject to the constraint that q(0) = β. Deﬁne V (x) = g
distinguished tag not used during normal operation, output:

, d). On input a security parameter k and number of tags associated with a ciphertext d, choose a group G of prime
β.
q(x). Letting t0 be a

α, g2 = g

The parameters g2, g

q(1)

, . . . , g

PK = g, g1, g2, g

q(1)

, . . . , g

q(d) SK0 = [(sk

(3)
0 = g
q(d) allow any party to compute V (·) by interpolating in the exponent.

0 = V (H(t0))r

(1)
α+r
0 = g
2

, sk

, sk

(2)

r

, sk

(4) = t0)]

PPKE.Encrypt(PK, M, t1, . . . , td) On input the public parameters PK, a message M to encrypt and a set of tags t1, . . . , td ∈ {0, 1}∗\{t0}.

Sample a random s from Zp and output

(cid:2)

CT =

(1) = M · e(g1, g2)s
ct

, ct

(2) = g

s

, ct

(3,1) = V (H(t1))s

, . . . , ct

(3,d) = V (H(td))s

(cid:3)

along with the tags (t1, . . . , td).

PPKE.Puncture(PK, SKi−1, t) On input an existing secret key SKi−1 and a tag t ∈ {0, 1}∗ \ {t0}. First parse SKi−1 as
(cid:3)
and r0, r1 at random from Zp and compute:
· g

[sk0, sk1, . . . , ski−1] and further parses sk0 as (sk

(3)
0 , t0). Next sample λ

r0−λ(cid:2)

r0 , t0

(cid:3)
0 =

, sk

(3)
0

(cid:3)

sk

2

(cid:2)
(cid:2)

(2)
0 , sk

(1)
0 , sk
· g
(1)
sk
0
λ(cid:2)+r1
, V (H(t))r1 , g

(2)
0

g
2

· V (H(t0))r0 , sk
r1 , t

(cid:3)

ski =

It outputs the new key SKi = [sk

(cid:3)
0, sk1, . . . , ski−1, ski].

PPKE.Decrypt(SKi, CT, t1, . . . , td) On input a private key SKi, a ciphertext CT and a set of tags t1, . . . , td associated with the ciphertext.

Parse the ciphertext CT as (ct
, ct
(cid:4)d
(1)
For j = 0, . . . , i parse ski as (sk
i

k=1(ωk · q(H(tk))) = q(0) = β. Finally compute

, . . . , ct
(4)
, sk
i

, ct
(2)
i

(3)
i

, sk

, sk

(2)

(3,1)

(1)

(3,d)) and parse SKi as [sk0, sk1, . . . , ski].
). Next compute a set of coefﬁcients ω1, . . . , ωd, ω∗ such that (ω∗·q(H(sk

(4)
i

)))+

and output M = ct

(1)

/

(cid:5)i
j=0 Zj.

Zj =

(cid:2)

e

(3)
sk
j

,

(1)
e(sk
j

(2))
(cid:3)
, ct
(cid:5)d
· e(sk
k=1(ct(3,k))ωj

(2)
j

, ct(2))ω∗

Fig. 2. A CPA-secure puncturable PKE scheme based on the ABE construction of Ostrovsky, Sahai, and Waters [35].

PPKE.Decrypt(SKi, CT(cid:2)
compute M
(cid:2) ← H1(Σ, M
(cid:2)
s
(cid:2)
randomness,
s
PPKE.Encrypt(PK, Σ(cid:2)
return ⊥. Otherwise return M

, t1, . . . , td).
(cid:2) ← S ⊕ H2(Σ)
and
, (t1, . . . , td)).
Finally,
compute CT(cid:2)(cid:2)
, t1, . . . , td) and if CT(cid:2)

the

as

Next
compute
using
←
(cid:4)= CT(cid:2)(cid:2)

(cid:2).
puncturable

encryption

scheme

Theorem 4.2: The

, PPKE.Decrypt(cid:2)

(PPKE.KeyGen, PPKE.Encrypt(cid:2)
PPKE.Puncture) is IND-PUN-CCA secure in the random
oracle model
the Decisional Bilinear Difﬁe-Hellman
(DBDH) assumption holds in G, GT .
The proof of Theorem 4.2 follows the well understood struc-
ture described by Fujaki-Okamoto [24]. For space reasons we
leave it to the full version of this work.

if

,

V. PUNCTURABLE FORWARD SECURE PKE

While puncturable encryption provides ﬁne-grained control
over a recipient’s ability to decrypt ciphertexts, the secret key
size grows proportionally to the number of revoked ciphertexts

310310

tags. This can become unwieldy after a large number of
punctures.

In this section we show how to mitigate this issue by com-
bining puncturable encryption with a forward-secure public
key encryption scheme [18] based on an efﬁcient Hierarchical
Identity Based Encryption (HIBE) Scheme. In the modiﬁed
construction, senders encrypt under a time period T and a
list of tags (t1, . . . , td). Receivers may puncture their keys
within the current time period (or most recent n time periods),
eventually using the forward secure scheme to provide coarse-
grained security by winding the key forward. Crucially, in
winding the key forward they may eliminate the overhead of
storing the punctured key components for past time periods. In
this proposal, the total size of the key and cost of decryption
are linear in the number of punctures in only the current time
period(s), and logarithmic in the total number of time periods.
Intuitively, the security deﬁnition for this hybrid scheme
is similar to the one for puncturable encryption, with the
adversary gaining the additional capability to advance to the

PFSE.Keygen(1k

p. Sample random α, β ∈ Zp and g3, h1, . . . , h(cid:6) ∈ G, and set g1 = g
be a distinguished tag not used during normal operation. We will implicitly deﬁne PK = (PKP P KE, PKP F SE) where:

, d, (cid:6)). On input a security parameter k, the number of tags per ciphertext d and a tree depth (cid:6), ﬁrst select G, GT of order
β. Select a hash function H : {0, 1} → Zp and let t0

, g2 = g

α

PKP P KE = (g, g1, g2, g

q(1)

, . . . , g

q(d)), PKP F SE = (g, g1, g2, g3, h1, . . . , h(cid:6))

Now sample r1, r2, r3 ∈ Zp and sample α1, α2 ∈ Zp with the restriction that α1 + α2 = α. Using α1 as the master secret key for the
HIBE scheme, compute HIBE keys corresponding to identities “0” and ”1” (i.e. the identities to the left and right of the tree root).

hskL = BBG.Keygen(PKP F SE, α1, 0), hskR = BBG.Keygen(PKP F SE, α1, 1)

Next, compute the initial PPKE share of the key using master key α2 and distinguished tag t0:

Set D0 = (0,{hskL, hskR}, ppkesk∅). This initial tuple will be used as a “seed” to obtain the secret key for the ﬁrst time period, as
follows:

1∅, D1) ← PFSE.NextInterval(D0)

(tsk

ppkesk∅ = [(g

α2+r3
2

, V (H(t0))r3 , g

r3 , t0)]

Output PK and the initial secret key SK = (tsk

1∅, D1).

PFSE.Encrypt(PK, M, Tcur, t1, . . . , td). On input PK, a message M, a time period Tcur, a set of tags t1, . . . , td ∈ {0, 1}∗ \ t0, sample

s ∈ Zp and compute a HIBE identity T1, . . . , Tk = IndexToPath(Tcur, (cid:6)). Now compute:

(1) = e(g1, g2)s · M, ct

(2) = g

ct

s

, ct

(3,1) = V (H(t1))s

, . . . , ct

(3,d) = V (H(td))s

, ct

(4) =

Output ct = (ct

(1)

(2)

, ct

, ct

(3,1)

, . . . , ct

(3,d)

, ct

(4)) along with Tcur, (t1, . . . , td).

(cid:2)

1 ··· h
h

T1

Tk

k · g3

(cid:3)s

PFSE.Puncture(PK, SK, t). On input the current secret key SK, parse SK = (tsk

i
T, Di) where T represents the set of punctures in the

current time period. Further parse tsk

i
T as (hski, ppkeskT) and compute:
ppkeskT∪{t} ← PPKE.Puncture(PKP P KE, ppkeskT, t)

Output tsk

i
T∪{t} = (hski, ppkeskT∪{t}).

PFSE.NextInterval(Di). Parse Di as (i, HSKs, ppkesk∅) and extract the HIBE key hskP corresponding to time period i from HSKs and

derive its left and right keys as follows:

Compute a new HSKs(cid:3)
D(cid:3) = (i + 1, HSKs(cid:3)

, ppkesk∅).

hskL = BBG.Keygen(hskP, 0),

hskR = BBG.Keygen(hskP, 1)

including the two new keys but without the parent (i.e. HSKs(cid:3) = (HSKs \ hskP) ∪ {hskL, hskR}) and set

i∅ = (hsk

(cid:3)
i, ppkesk

(cid:3)
∅) the key for decrypting messages for time interval i by binding together the HIBE key hskP
(3)
0 , t0),

Second, derive tsk
for interval i with randomized version of the P-PKE key ppkesk∅. Parse hskP as (a0, . . .) and ppkesk∅ as (sk
sample γ ∈ G, r ∈ Zp at random and compute
P = (a0 · g
(cid:3)
(cid:3)
∅ = (sk

· V (H(t0))r

γ
2 , . . .)
· g

−γ+r
2

(1)
0 , sk

(2)
0 , sk

ppkesk

, t0)

· g

hsk

, sk

, sk

(2)
0

(1)
0

(3)
0

r

Output (tsk

i∅, D(cid:3)).

PFSE.Decrypt(tsk

i
T, ct, t1, . . . , td). Parse tsk

i
T as (hski, ppkeskT) and ct as (ct

A ← PPKE.Decrypt(ppkeskT, (1, ct

(2)

, ct

(3,1)

(4))
, . . .), t1, . . . , td) , B ← HIBE.Decrypt(hski, (1, ct

, ct

, ct

, ct

(3,d)

(3,1)

(1)

(2)

(2)

(4)))

, ct

,··· , ct

Output M = ct(1)
A·B .

Fig. 3. Puncturable Forward Secure Encryption from puncturable encryption and Hierarchical Identity Based Encryption.

311311

secret key to the next time period, and to challenge on an
unpunctured key proved it precedes the corrupted interval. We
present the full deﬁnition in Appendix B.
FS-PKE and HIBE. The FS-PKE construction of Canetti et al.
uses a HIBE scheme as a building block. First, a maximum
number of time periods L is chosen, then a tree depth (cid:5) =
(cid:10)log(L + 2)(cid:11) is calculated, and each time period 1, . . . ,L is
mapped to one node of a binary tree hierarchy of identities
using an in-order traversal.3 Each node of the tree corresponds
to a HIBE secret key. When a time interval is complete, HIBE
keys for the left and right subtrees are derived using the key
for current epoch, which is then deleted.

We can implement the HIBE scheme using any selective-
ID secure HIBE. In principle, we could even dual-purpose
the Ostrovsky et al. NM-ABE scheme from our puncturable
encryption construction to build a HIBE, using the key delega-
tion approach proposed by Goyal et al. [26]. However, such a
construction (and indeed many practical HIBE schemes) would
have ciphertext sizes and decryption times that are linear in
the identity length, and hence logarithmic in the number of
intervals. In contrast, Boneh, Boyen and Goh [12] proposed
an efﬁcient construction that features constant-size ciphertexts
and decryption times and, interestingly, keys that decrease in
size linearly as the identity string grows.
Intuitively,
Combining FS-PKE and Puncturable encryption.
our approach in combining the two schemes is to associate
with each time interval T a pair of secret keys (AT , BT ) where
AT represents the key material for the FS-PKE at time T and
BT represents the puncturable encryption key material. The
element BT initially begins with no tags punctured, and will
be updated with each subsequent call to Puncture. Prior to
any punctures occurring, however, we also derive and store a
second pair of keys (AT +1, BT +1) for the next time period
where AT +1 represents the FS-PKE key for time period T +1,
and BT +1 is the empty puncturable encryption component.
Critically, each pair (Ai, Bi) must be bound together, such
that (1) both are required in order to decrypt a ciphertext, and
(2) an attacker who obtains (AT , BT ), (AT +1, BT +1) cannot
recombine the keys in new combinations.

The process of updating a key from time period T to time
period T + 1 is therefore a matter of discarding the pair
(AT , BT ) and using the pair (AT +1, BT +1) to derive another
bound pair (AT +2, BT +2) for the time period T +2.4 The user
applies subsequent puncture operations to BT +1. This process
may be repeated until the ﬁnal time period.

As is typical of many IBE/ABE schemes, the HIBE scheme
of [12] makes use of a master secret α and a public parameter
g1 = gα. The puncturable encryption scheme of §IV also uses
a similar construction. Thus our approach is to initially share
a single master secret key α as α1, α2 where α = α1 +α2. We
use α1 as the master secret for the HIBE scheme, and α2 as

3This description places the ﬁrst time period at the node to the left of the

root of the tree.

4The user need not immediately discard the previous key and may, if she
chooses, retain keys for many time periods. This allows users to “hold the
door open” for any late-arriving ciphertexts.

the secret for the puncturable encryption. At each subsequent
time period, we can take the fresh keys for time period T + 1
and produce a new pair of keys for time period T + 2 by
dynamically updating the sharing of the secret α. Crucially, for
both [12] and our scheme, α is embedded as a multiplicative
factor of the form gα. As a result this re-sharing can be
computed on any set of derived keys, even after the master
secret α has been destroyed.

scheme

Syntactically,

the
PPKE.KeyGen, PPKE.Encrypt, PPKE.Puncture,
existing
PPKE.Decrypt algorithms with the hierarchical key derivation
mechanism of a HIBE scheme. Thus PFSE is a tuple of 6
algorithms(PFSE.KeyGen, , PFSE.Encrypt, PFSE.Puncture,
PFSE.Decrypt, PFSE.NextInterval) where

combines

a

hybrid

SK n+1 ← PFSE.NextInterval(SK n)

returns the derived key for the next
interval by invoking
the HIBE scheme’s key derivation function. We present our
construction in Figure 3.

Theorem 5.1: The scheme of Figure 3 is secure in the sense
of Deﬁnition in ﬁgure C.1 in the random oracle model if
the Decisional Bilinear Difﬁe-Hellman Inversion ((cid:5)-DBDHI)
assumption holds in G, GT .
We sketch a proof of Theorem 5.1 in the full version of this
paper.

A. CCA Security

As in construction of §IV-B, we can apply the Fujisaki-
Okamoto transform [24] to the scheme of Figure 2 to obtain
a CCA-secure construction. The details of this approach are
nearly identical to those given in §IV-B, with the following
small modiﬁcations. First, the hash function H1 now has the
proﬁle H1 : GT × M(cid:2) × Tcur × T d → Zp. Second, each of
the modiﬁed encryption and decryption algorithms each take
as input the time period Tcur as well as a list of tags, and
feed these values into H1. All of the remaining details are as
in §IV-B. We leave a formal proof for the full version of this
paper.

VI. IMPLEMENTATION

In this section, we present our implementation of punc-
turable forward secure encryption, with all technical details
needed for implementation.

A. Symmetric to Asymmetric Conversion
While our scheme is presented in the “symmetric” pairing
setting, where the bilinear map e is deﬁned as e : G×G → GT ,
in practice the most practical settings for pairing implementa-
tions use asymmetric bilinear groups G1, G2, GT where e is
deﬁned by e : G1 × G2 → GT . In many of these settings,
there exists no efﬁciently computable isomorphism between
the groups G1, G2.

The setting we employ for our implementation uses 256-
bit Barreto-Naehrig curves [9]. Since the resulting bilinear
groups are asymmetric, we must
transform our presented

312312

Key size((cid:5) = max ID length, l = ID length)

puncturable encryption

PK (2 + d) × |G1| + (2 + d) × |G2|
+(3 + (cid:5)) × |G1| + (3 + (cid:5)) × |G2|
SK (3 × |G2| + |Zp|) × punctures +(2 + (cid:5) − k) × |G1| + ((cid:5) − k) × |G2|
CT

|GT| + (d + 2) × |G1|)

+ HIBE overhead

+|Gt| + 2 × |G1|
TABLE I

- overlap
−2 × |G1|

N/A

−(|GT| + |G1|)

Example l = 30(no punctures)
normal
4.02 kB
14.02 kB
0.5 kB

CRS
0.42 kB
14.02 kB
0.5 kB

split

1.66 kB
16.24
0.5 kB

KEY SIZES FOR P-PKE, HIBE [13], AND THE COMBINED PFSE SCHEME. BECAUSE OF REDUNDANCIES IN THE TWO SCHEMES (E.G. THE GROUP

GENERATOR g), THERE IS SOME OVERLAP WE SAVE IN THE COMBINED SCHEME.

schemes into the asymmetric setting. There are many ways
to perform this transformation, and efﬁciency must be taken
into account when choosing one. This is because in the BN
setting, elements in G1 are on the order of 256 bits in our
case while elements in G2 are on the order of 1024 bits. As a
result, selecting group assignments involves tradeoffs. In effect
there are three different goals we can optimize for:

def IntervalKeys(pk,sk,i):

path = indexToPath(i,L)#L=max tree depth
if len(path) != L:# then not a leaf node

lkey= hibe.keygen(pk,sk[i],path+[0])
rkey= hibe.keygen(pk,sk[i],path+[1])
return ((lkey,pathToIndex(path+[0),L),
(rkey,pathToIndex(path+[1],L))

Listing 1. Key Derivation for Update

1) Ciphertext size. We attempt to put as many elements in

the ciphertext in G1 ﬁrst.

2) Public key size. We attempt

elements into G1 ﬁrst.

3) Secret key size. We attempt

elements into G1 ﬁrst.

to put

the public key

to put

the secret key

For our implementation, we chose to optimize for minimal
ciphertext size. This seems appropriate, as secret key storage
does not appear to be a signiﬁcant problem except on highly
constrained devices. We performed our group assignment
using the Autogroup tool [6], which employs an SMT solver
to optimize for appropriate assignments.

B. Polynomials, evaluation, and recovery coefﬁcients

Our descriptions in Figures 2 and 3 omit several impor-
tant steps needed to implement the scheme. Speciﬁcally, our
implementation must (1) select the random polynomial q(x)
such that q(0) = β, (2) compute V (x) without knowledge
of the polynomial coefﬁcients, and (3) compute the recovery
coefﬁcients ω0 ··· ωd, ω
∗ for decryption. While these details
are not technically novel, we present them in Appendix A for
completeness.

C. Mapping time intervals to a HIBE scheme

D. Sterile keys

An elegant feature of the HIBE scheme of Boneh et. al
is that HIBE keys can be sterilized by deleting a few extra
elements. These keys can still be used to decrypt messages
associated with some identity, but they cannot be used to derive
new keys for child intervals.

The ability to sterilize keys gives an important freedom: in
PFSE interval sizes can be as short as we want. If we expect
latent messages to arrive, we can simply keep a sterilized
version of that interval around. This gives us the ability to keep
a decryption window around which still maintains forward
secrecy. Absent this, intervals could not be kept along and
the size of an interval would determine how much latency the
scheme can tolerate. This is not desirable as larger intervals
will incur more punctures and hence longer decryption times.
We leverage this in our implementation.

E. Software

Our implementation is approximately 4,000 lines of C++
including a C++ wrapper around the RELIC pairing library [7],
and extensive unit tests. Serialization is provided by the C++
Cereal [42] serialization library wrapping RELIC’s serializa-
tion routines for elliptic curve points. To improve performance,
we parallelize decryption using OpenMP [34] to parallelize
computation of Zj in the puncturable decryption routines.

VII. EXTENSIONS AND OPTIMIZATIONS

A. Outsourced decryption

In [19], Canetti et. al. detail how to construct a forward
secure encryption system from a HIBE scheme by mapping
time intervals onto a binary tree using an pre-order traversal
and maintaining a stack of keys. Although we use the same
pre-order traversal mapping, we use a different algorithm
which requires only a dictionary and the ability to convert
an index into the tree to a location in the tree and vice-versa.
This leads to a simple and natural structure of a secret key as a
map from an interval to the key for that interval and we found
it easier to work with. The algorithm is deﬁned in Listing 1.

One potential concern with our scheme is the cost of de-
crypting, especially on constrained devices such as embedded
systems and mobile phones. These concerns may be mitigated
if a cloud provider is available to provide computational assis-
tance. For example, there are well known techniques [27], [20]
for securely and privately outsourcing pairing computation and
ABE decryption to a third party (e.g. a cloud-based server).
Since pairings are the dominant cost in the decryption process,
and since decryption can be parallelized, this could allow
for a substantial reduction in on-device decryption cost. One

313313

application of such a scheme would be to implement forward
secure encryption within projects such as Google’s End-to-
End [2], using Google’s servers to perform pairing operations.

B. Outsourced key storage and updating

Key sizes in puncturable encryption can grow fairly large
(e.g., 900 kB for 1 message a second with up to 1000 seconds
of latency). However, not all of this material needs to be kept in
secure storage. Instead, the keys themselves can be encrypted
and stored in untrusted storage, provided that the decrypter
can securely store a short symmetric key, and that this key
can be erased and overwritten with a new key during updates.
This ensures that old keys cannot be recovered.

C. Size of public keys

When implementing puncturable forward secure encryp-
tionusing symmetric pairings, the HIBE public key contains
(cid:5) random group elements. These constitute the bulk of the
public key material in puncturable forward secure encryption.
To reduce the size of the public key, these elements could
be selected using an appropriate hash function, and used as a
global constant (formally, a CRS). Alternatively, the same set
of (cid:5) elements can be generated globally and shared across all
public keys.

Although transforming the scheme into the asymmetric
setting makes the scheme for faster and ciphertexts smaller, it
makes the situation worse in two ways. First, a corresponding
set of (cid:5) elements must exist in both groups. This doubles the
size of the public key. Second, because each corresponding
element must have the same discrete log (respect
to the
generator of each group), they cannot be generatedusng a hash
function. To generate each pair of elements, it is necessary to
pick a random exponent and raise the generator in each group
to that power. This requires trusted setup. In the asymmetric
setting, this leaves us with a 4.2 kB public key as seen in table
I. There are three options for reducing the size of these keys:
1) Move the elements in G2 into the secret key. We call

this the split approach. It increases public key size.

2) Assume trusted set up and generate them as a common

parameters.

1, gr

3) have each user participate in generating the parameters.
The third option holds some potential. A naive approach is to
have all users generate gr
2 for each component, prove they
are each raised to the same base. and simply take the product
of each. It’s possible to optimize this so that the common
parameters are progressively updated as users register and we
need not require all users participate in a single setup protocol
at the start.

D. Decryption window

Many forward secrecy applications require the ability to
maintain decryption capability for some number of time inter-
vals in the past. In our scheme it is possible to store multiple
keys. For example, a recipient may retain keys that allow
for decryption of messages received during the past n time
periods. Moreover, with the ability to sterilize keys, these

keys can be altered into a form that does not allow for the
creation of keys for subsequent time periods. Thus a recipient
can selectively “knock out” the keys for speciﬁc time periods,
and/or puncture speciﬁc message identiﬁers within those time
periods, while retaining the keys for previous time periods.
The size of the window is an application choice balancing 1)
the need to decrypt latent messages 2) the cost of increased
key storage and 3) the risk that an attack might intentionally
delay a target message until after they compromise the system
and extract keys needed to decrypt it .

VIII. RECOMMENDED USAGE

Given all of these ingredients, we now have a system that
can be used to implement forward secrecy in asynchronous
messaging networks. The overall approach we propose is as
follows. Each recipient generates a public key for a the hybrid
P-PKE scheme, and delivers these keys via the key server.
Each party now maintains an open decryption window allow-
ing that party to receive messages with timestamps > (p− n)
where p is the current time period and n is the number of time
intervals in the decryption window.

In practice, the recipient may implement this by retaining
the keys corresponding to the n most recent time periods,
using the optimization for retaining keys described in §VII-D.
When a new message arrives marked with time period T , the
recipient identiﬁes the time period key corresponding to T .
If that key is still available, it uses the key to decrypt the
message. Next, the recipient may puncture the corresponding
key with the message’s unique identiﬁer. At the same time, the
recipient’s software derives and sterilizes keys as appropriate
(this can either be done on the receipt, one per time interval, or
in some batched aggregated process, depending on processing
and power requirements.) Periodically, the client eliminates
old time period keys that are no longer within the decryption
window.

IX. PERFORMANCE EVALUATION

We provide two types of experiments: microbenchmarks
demonstrating performance of our hybrid (PFSE) scheme
and simulated results illustrating the cost of the schemes in
example usage scenarios.

A. Microbenchmarks

We conduct our experiments against three devices:
• A Desktop Intel Core i7-3770K CPU @ 3.5 GHz with 32

GB of RAM running Ubuntu 14.04

• A 2013 Macbook air with an Intel Core i7-4650U CPU

@ 1.7 GHz with 8GB of RAM running OSX 10.9.5

• An Android phone with a Qualcomm Snapdragon 801
SoC (a Kriat 400 ARM CPU) @ 2.5 GHz with 3GB of
RAM running Cyanogen-mod 11.

All experiments resulted from conducting 50 timing samples
on a tree of depth (cid:5) = 31 with ciphertexts supporting only
d = 1 tags. We implemented the CCA-secure variant of the
scheme described in §V-A. For these experiments less than
50 kB of memory was used with all keys stored in memory.

314314

)
s
m

(

e

m
T

i

300

250

200

150

100

50

0

0

NextInterval() performance vs. current interval

Decrypt time vs. punctures

x86 Desktop
x86 ultrabook
ARM

)
s
m

(

e

m
T

i

x86 Desktop multi-threaded
x86 Desktop single-threaded
x86 ultrabook
ARM

2000

1500

1000

500

5

10

15

Interval

20

25

30

35

0

0

20

40

60

80

100

Punctures

Fig. 4. Performance of PFSE (50 repetitions). Left, the cost of computing the next interval key as intervals advance. As later intervals have shorter HIBE
secret keys, this decreases. Right, the cost of decrypting a ciphertext given the number of punctures in a key. Since P-PKE secret keys get larger as they are
punctured, this increases.

While the goal of this section is to investigate the perfor-
mance of our hybrid scheme, our micro benchmarks illustrate
the performance of operations related to the two underlying
cryptographic components – forward-secure PKE and punc-
turable encryption. Recall that the puncturable encryption key
generation, encryption, and “puncture” operations all perform
independently of the current number of punctures previously
applied to a secret key. Even when combined with a HIBE
scheme to form a PFSE scheme, the cost of these operations
remains constant. They do, however, gain a dependency on
the total number of allowable time periods. Table II presents
microbenchmarks for these operations.

While PFSE.NextInterval is similarly independent of the
number of punctures n, it does depend linearly on the length
of the current interval key. As keys in the HIBE scheme
decrease in size as the identity gets longer (i.e.
the key
for the ﬁrst interval is the longest), the process of deriving
the next key gets faster. PFSE.Decrypt runs in time O(n)
independent of the ID length, the current interval, or even
the total number of intervals. However, it does depend on the
number of punctures. See Figure 4 for results showing the
performance of interval updates and decryption. 5 We note that
since decryption depends on number of punctures × number of
tags, Figure 4 also shows the effect of decryption with d ≥ 1
tags.

B. PFSE under real world conditions

There are two performance metrics we are concerned with:
the size of the secret keys and the amount of time we expect
to spend perform cryptographic operations necessary to read
messages. Performance of PFSE under real world conditions
is determined by 4 parameters:

1) The distribution of message arrivals. For our simula-
tions, we assume for simplicity that message arrivals are
modeled as a Poisson process with distribution λ. This

5Due to an implementation quirk, Keygen handles deriving both the children
of root and the grand-children. NextInterval therefore starts at interval three,
hence the discontinuity in the above graph.

315315

Keygen
Encrypt
Decrypt

(x86)Desktop
196.6 ± 1.7 ms
5.49 ± 0.1 ms
13.82 ± 0.01 ms
15.6 ± 0.1 ms
9.8 ± 0.1 ms

883.2 ± 56.3 ms
22 ± 0.9 ms
55.5 ± 1.3 ms
68.4 ± 1.6 ms
42.2 ± 0.7 ms
Puncture (subsequent)
MICRO-BENCHMARKS FOR PFSE WITH 232 − 2 INTERVALS AND d = 1
TAGS PER MESSAGE. THIS INDEPENDENT OF THE STATE OF THE KEY.

(x86)Ultrabook
368.4 ± 13.9 ms
9.9 ± 1.3 ms
24.8 ± 2.4 ms
28.8 ± 2.5 ms
18.3 ± 2.2 ms

Puncture (Initial)

ARM

TABLE II

assumption clearly does not accurately model bursty
communication like chat/SMS where there are many
replies – however, for such mechanisms one can use
a symmetric key ratchet to achieve forward security. As
the message rate increases, we expect performance to
decrease.

2) The duration of each time interval. The HIBE portion
of our scheme maps messages into time intervals for
which a speciﬁc key is needed to decrypt all messages
in that interval. The length of those intervals affects both
the size of keys (since for shorter intervals, we need
a deeper tree to span the same amount of time), the
number of expected punctures (for a ﬁxed message rate,
longer intervals mean more messages per interval and
hence more punctures) and effort required to derive keys.
3) Number of intervals The maximum depth of the HIBE
scheme limits the total number of intervals PFSE sup-
ports. It also effects the performance of HIBE key
derivation.

4) The “window” of time in which we can decrypt
latent messages (all messages prior to this window
are permanently inaccessible). Window size affects the
amount of key material that needs to be stored. We
expect that the window size in deployed applications
will be determined by considerations such as message
delivery latency. Latency itself, assuming that it is inde-
pendent per message does not effect performance.

Because the message rate is determined by the type of
trafﬁc (e.g. email, sms, etc), and window size only effects
key storage, the only two means an application has to tune its
performance is through the selection of the interval size and
the total number of supported intervals. Combined, these two
parameters determine how long a key lasts before it needs to be
replaced. In practice, we expect that the amount of time before
a key is replaced will be determined by outside requirements.
In that case, application developers face a trade off: a key with
many short intervals or few long ones.

1) Simulating real world usage: To explore PFSE perfor-
mance under a variety of conditions, we deﬁne a simulation
parameterized by the three parameters given above. Our simu-
lation uses the data in desktop performance numbers in Figure
4 as a raw input to estimate the computational cost that will be
incurred using the cryptography. Results are shown in Figure 5
for the effect of interval size. We set experiments to run for a
ﬁxed amount of time (100,000 seconds) and choose parameters
so that each public key covers 1 year worth of intervals (i.e.
the key with 1 millisecond long intervals has 1000 times as
many intervals as the key with 1 second long intervals.).

We subdivide our results into (1) the time spent deriving
HIBE keys, (2) the time spent puncturing keys, and (3) the
time spent decrypting ciphertexts. A the decrease in efﬁciency
for P-PKE is expected as intervals get
larger (since we
have more punctures per interval and thus more time spent
decrypting). However, surprisingly, we notice a sharp increase
in time spent deriving keys as intervals get smaller.

The cause of this extra computation is partly due to an
increase in tree depth, as intervals get smaller. Primarily,
however, the effect is simply one of spacing: as the interval
size decreases, the distance (i.e., number of intervals) between
messages goes up. As a result, the number of keys we need to
derive increases logarithmically, and because key derivation
for each key depends linearly on its depth in the tree, the
total amount of work needed increases polylogarithmically as
intervals get shorter.

Given these results, how much storage do we expect? Table
III shows the maximum private key sizes measured given
various message rates. These are taken with a setup similar
to the simulated experiments described above but (1) run
against the real software with a window size of 1,000 seconds
with it aggressively deleting keys immediately once they were
outside the window and (2) with each interval getting E[x]
messages per interval (i.e. the expected number of messages
per interval) rather than a random X messages per interval
where X has a Poisson distribution. To ensure accuracy, the
experiment simulates 2000 seconds worth of trafﬁc.

2) Recommended parameter choice and expected perfor-
mance: The experiments in Figure 5 suggest that the optimal
interval size occurs at the point where the recipient receives 1
message per interval.

The exact point of the trade of may very depending on
processor type and the relative efﬁciency of pairings used
in decryption, and point multiplication used primarily in key
derivation. Fine-grained tests on the current implementation

optimal interval length / message rate
0.001
0.010
0.100
1.000

size(kB)
10.56
55.15
214.10
890.44

EXPECTED MAX KEYSIZE FOR OPTIMAL INTERVAL SIZE (I.E 1 MESSAGE
PER INTERVAL EXPECTED). WINDOW OF 1,000 SECONDS. KEYS SIZED TO

TABLE III

SPAN 1 YEAR.

conﬁrm that 1 message per second is, at least on the test
desktop system, a local optimum. Based on our tests, we
believe we can deal with message rates of 1 a second and
expect decryption times per message of 20 ms and with
99.99% probability, less than 100 ms.

is well

For one message per interval, it takes on average 50 ms
to derive the next key on a desktop. Thus our total expected
time to decrypt a message, assuming we naively only derive
keys when we get a message6,
less than 200 ms.
Mobile benchmarks suggest a 4x increase in computational
cost, increasing the decryption time to under 800 ms. Since
the dominant cost of this is key derivation, which we expect
to be batched and handled independent of message decryption,
the actual expected time to decrypt a message on our ARM
processor will be 55 ms, and with 99.99% probability, less
than 500 ms.

X. APPLICATIONS

In this section we discuss two applications and extensions

of puncturable encryption within existing systems.

A. Secure deletion

While the applications we considered in this paper are
all limited to messaging protocols, our techniques may be
applicable to other types of data storage as well. Where
the standard approach to eliminating sensitive information is
simply to delete local copies, secure deletion of ﬁles in cloud
based storage can be potentially more challenging.

For ﬁles written and read by a single user, secure deletion
can be accomplished trivially by encrypting each ﬁle with a
unique key and deleting this key when necessary. However,
systems with many writers and at
least one reader (e.g.
ﬁle sharing, shared passwords in online password managers7,
and SecureDrop8 [41]), often require the use of public keys.
Unfortunately, in this setting there is no clear way to delete a
speciﬁc ﬁle without deleting the whole private key and losing
access to all of the data.

With puncturable encryption, however, we can simple tag
the data as appropriate and puncture on the tag to delete the
ﬁle. There are several interesting options for use as tags:

6Unless the real message distribution has very low variance, this isn’t
recommended: A long gap for messages will effectively deffer key derivation
costs until a message arrives. Instead, keys should be derived once per interval
or in some batch process.

7Such a feature is provided by the cloud based password manager Lastpass.
8A system for securely communicating with journalists.

316316

Fig. 5. Total time spent decrypting out of 100,000 seconds on a x86 Desktop. Note, x-axis is log scale and tree depth was adjusted so that the key spanned
1 year.

Subject tags. Messages can be tagged with a subject identiﬁer.
Once the subject has come to a close (e.g., “selecting a
Vice Presidential candidate”), all messages pertaining to the
discussion can be deleted.
Classiﬁcation tags. Messages can be tagged with their classiﬁ-
cation level (e.g. secret, top secret, etc). Negation can either be
done globally (e.g. in the case of loosing security clearance), or
per time interval to ensure sensitive information is not stored
for long periods of time.
Author. Messages/ﬁles from a given user can be deleted. For
example, a lawyer upon terminating their relation ship with a
client, or on the death of the client could securely delete all
work pertaining to the client to ensure conﬁdentiality.

For data retention, none of these techniques need be applied
to the only copy of the data. Instead, copies can be made to
more secure archival system and negation used only to ensure
that keys used on a daily basis no longer have access.

B. Integration with Legacy Applications

tools

for

Cryptographic

secure messaging,

such as
GnuPG [5] are integrated into many pieces of software.
Even if developers wish to adopt forward security techniques
this, many encryption user interfaces are already designed
to interoperate with these legacy tools. Ideally, one could
bypass client software entirely and merely modify deployed
encryption tools such as GnuPG to use libforwardsec
without changing the API of the existing library. We detail
how to do this for simple forward security where message
tags are random.

Key generation and decryption can be handling opaquely
by the library by merely updating existing internal calls. For
forward security, tags can be selected randomly by the library
and so need not be speciﬁed in a call to encrypt. Public keys
for the forward secure system may be included as a new form
of subkey within existing OpenPGP keys, or they may be
treated as an auxiliary component that the tool can retrieve
from some external server. or, provided network access is
acceptable, from a key server. In the case of the later, if the

317317

P-PKE key is signed by the legacy key, then the library can
provided opportunistic forward secure encryption even when
the sender is not aware the recipient supports it and only has
the recipients legacy key.

The legacy model does not, however, provide an obvious
solution to actually puncturing keys. The tool could automat-
ically puncture for speciﬁc messages each time it is asked
to decrypt a message. Alternatively we could modify GnuPG
with an additional command of the form --update-key
that on input either a time period T or tag t will update the
current state of the secret key.

XI. RELATED WORK

There are several types of related work we list in this

section.
Delegation for Attribute Based Encryption. Delegable or hi-
erarchical Attributed Based Encryption [30], [43], [37], allows
a user to modify a key embedding a given access policy into a
key embedding a more restrictive one. Our puncture procedure
can be considered a variant of delegation. Some work [37] has
been done on ciphertext delegation, where an untrusted party
can update a ciphertext to be accessible only under a more
restricted policy. To the best of our knowledge, however, no
scheme supports updating keys to add a negation (e.g. not tag
0xDEADBEEF) with only knowledge of that single key and
not the master key.
Revocable IBE. Another body of work [10], [37], [44] is on
revocable Identity Based Encryption. In this setting, a trusted
third party issues identities and then through some mechanism
(typically either directly updating users keys or posting some
public update information) updates only the keys of non-
revoked users. This setting does not deal with compromise
of the trusted authority and thus can’t be used for forward
secure encryption.
In addition to the proposals
Forward security for messaging.
listed earlier in this paper, there are several additional propos-
als for forward secure messaging that have seen deployment,
such TextSecure and Pond [1], [3]. All of these schemes

either rely on generating many keys, or, more frequently, using
interactive forward secure protocols.
Puncturable PRFs. . Puncturable PRFs , dating back to 1984
[25] have received recent attention [14], [16], [29] for use with
indistinguishability obfuscation[38]. They allow a PRF key to
be punctured so that the PRF can no longer be evaluated on a
speciﬁc point. Indeed puncturable encryption is intentionally
named in a similar vein. However the two are distinct. While
puncturable PRFs can be used to create puncturable symmetric
key encryption in the obvious way,9 it’s not immediately clear
how to use them for public key encryption. Moreover, all
existing constructions are either selectively secure 10 or require
indistinguishability obfuscation for instantiation.

XII. CONCLUSION

In this work we proposed puncturable encryption, a new
primitive that allows users to control which ciphertexts their
keys may decrypt. By combining this primitive with an efﬁ-
cient FS-PKE scheme, we showed that the two schemes can be
used in practice in real messaging systems. This work leaves
several open question. One major question is whether punc-
turable encryption can be realized from alternative building
blocks besides Attribute-Based Encryption. In particular, it
is interesting to consider whether puncturable encryption can
be constructed from elliptic curve groups that do not support
pairings. A second set of questions deals with ways to improve
the efﬁciency of this scheme and make it more practical for
deployment, including speciﬁc techniques for outsourcing the
decryption of forward secure ciphertexts.

Acknowledgements. This work was supported by: The Air
Force Research Laboratory (AFRL) under contract FA8750-
11-2-0211;
the U.S. Defense Advanced Research Projects
Agency (DARPA) and the Air Force Research Laboratory
(AFRL) under contract FA8750-11-2-0211; The National Sci-
ence Foundation under award EFRI-1441209; and the Ofﬁce
of Naval Research under contract N00014-11-1-0470.

REFERENCES

[1] Forward secrecy for asynchronous messages. https://whispersystems.

org/blog/asynchronous-security/. Accessed: 2014-11-13.

[2] Google End-To-End.

Available

at

https://code.google.com/p/

[3] Pond. https://github.com/WhisperSystems/TextSecure/wiki/ProtocolV2.

end-to-end/.

Accessed: 2014-11-13.

[4] Textsecure.

https://github.com/WhisperSystems/TextSecure/wiki/

ProtocolV2. Accessed: 2014-11-13.

[5] The GNU Privacy Guard. https://www.gnupg.org/.
[6] Joseph A Akinyele, Matthew Green, and Susan Hohenberger. Using
SMT solvers to automate design tasks for encryption and signature
schemes.
In Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security, pages 399–410. ACM, 2013.

9Though perhaps there is no obvious reason to do symmetric puncturable

encryption at all given fast symmetric key ratcheting.

10Like the Boneh et. al HIBE scheme, this can be converted to full security
via complexity leveraging at the cost of an exponential loss in security.
However, for puncturable encryption from prfs, this is exponential in the tag
space for messages (i.e. we loose at least 80 bits of security). For PFSE,
on the other hand, it is at worst exponential in the tree depth for the HIBE
component (i.e. we loose 32 bits if we support 232 time intervals).

[7] D. F. Aranha and C. P. L. Gouvˆea. RELIC is an Efﬁcient LIbrary for

Cryptography. http://code.google.com/p/relic-toolkit/.

[8] Adam Back and Ben Laurie. Forward Secrecy Extensions for OpenPGP.
Available at https://tools.ietf.org/html/draft-brown-pgp-pfs-01, August
2000.

[9] Paulo S.L.M. Barreto and Michael Naehrig. Pairing-Friendly Elliptic
Curves of Prime Order, volume 3897, pages 319–331. Springer Berlin
Heidelberg, 2006.

[10] Alexandra Boldyreva, Vipul Goyal, and Virendra Kumar. Identity-based
encryption with efﬁcient revocation. In Proceedings of the 15th ACM
conference on Computer and communications security, pages 417–426.
ACM, 2008.

[11] Dan Boneh and Xavier Boyen. Efﬁcient selective-ID secure Identity-
Based Encryption without random oracles. In EUROCRYPT, pages 223–
238, 2004.

[12] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based
In Advances in Cryptology–

encryption with constant size ciphertext.
EUROCRYPT 2005, pages 440–456. Springer, 2005.

[13] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based
encryption with constant size ciphertext. In EUROCRYPT, pages 440–
456, 2005.

[14] Dan Boneh and Brent Waters. Constrained pseudorandom functions and
their applications. In Advances in Cryptology-ASIACRYPT 2013, pages
280–300. Springer, 2013.

[15] Nikita Borisov, Ian Goldberg, and Eric Brewer. Off-the-record com-
munication, or, why not to use pgp. In Proceedings of the 2004 ACM
Workshop on Privacy in the Electronic Society, WPES ’04, pages 77–84,
New York, NY, USA, 2004. ACM.

[16] Elette Boyle, Shaﬁ Goldwasser, and Ioana Ivan. Functional signatures
and pseudorandom functions. In Public-Key Cryptography–PKC 2014,
pages 501–519. Springer, 2014.

[17] J. Callas, L. Donnerhacke, H. Finney, D. Shaw, and R. Thayer. OpenPGP
Message Format. RFC 4880 (Proposed Standard), November 2007.
Updated by RFC 5581.

[18] Ran Canetti, Shai Halevi, and Jonathan Katz. A forward-secure public-

key encryption scheme. In EUROCRYPT ’03, pages 255–271, 2003.

[19] Ran Canetti, Hugo Krawczyk, and Jesper Buus Nielsen. Relaxing

chosen-ciphertext security. In CRYPTO, pages 565–582, 2003.

[20] Benoˆıt Chevallier-Mames, Jean-S´ebastien Coron, Noel McCullagh,
David Naccache, and Michael Scott. Secure delegation of elliptic-curve
pairing. In CARDIS, pages 24–35, 2010.

[21] Apple Computer.

iOS Security. Available at https://www.apple.com/

privacy/docs/iOS Security Guide Oct 2014.pdf, 2014 October.

[22] George Danezis, Roger Dingledine, and Nick Mathewson. Mixminion:
Design of a Type III Anonymous Remailer Protocol. In Proceedings of
the 2003 IEEE Symposium on Security and Privacy, SP ’03, Washington,
DC, USA, 2003. IEEE Computer Society.

[23] T. Dierks and E. Rescorla. The Transport Layer Security (TLS) Protocol
Version 1.2. RFC 5246 (Proposed Standard), August 2008. Updated by
RFCs 5746, 5878, 6176.

[24] Eiichiro Fujisaki and Tatsuaki Okamoto. Secure integration of asymmet-
ric and symmetric encryption schemes. In CRYPTO ’99, volume 1666,
pages 537–554, 1999.

[25] Oded Goldreich, Shaﬁ Goldwasser, and Silvio Micali. How to construct
random functions. Journal of the ACM (JACM), 33(4):792–807, 1986.
[26] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-
based encryption for ﬁne-grained access control of encrypted data. In
ACM Conference on Computer and Communications Security, pages
89–98, 2006.

[27] Matthew Green, Susan Hohenberger, and Brent Waters. Outsourcing the
decryption of abe ciphertexts. In USENIX Security Symposium, page 3,
2011.

[28] Evan Harris. The Next Step in the Spam Control War: Greylisting.
Available at http://projects.puremagic.com/greylisting/whitepaper.html,
2003.

[29] Aggelos Kiayias, Stavros Papadopoulos, Nikos Triandopoulos, and
Thomas Zacharias. Delegatable pseudorandom functions and applica-
tions. In Proceedings of the 2013 ACM SIGSAC conference on Computer
& communications security, pages 669–684. ACM, 2013.

[30] Allison Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima,
and Brent Waters. Fully secure functional encryption: Attribute-based
encryption and (hierarchical) inner product encryption. In Advances in
Cryptology–EUROCRYPT 2010, pages 62–91. Springer, 2010.

318318

Using the Lagrange form of a polynomial, sampling a
random degree d polynomial q(x) = β consists of sam-
pling d random values r1, . . . , rd from Zp, setting points
(1, r1), (2, r2)··· , (d, rd) and setting the ﬁnal point as (0, β)
to ensure q(0) = β.
Lagrange interpolation does not directly yield a deﬁnition
of V (x) as we have only the public values gq(0),··· , gq(d) to
work with. However, we can easily compute V (x) as:

V (x) = g

q(x) = g

(cid:2)d

j=0 yj l(x,j,xc) =

d(cid:3)

i=0

q(i))l(x,j,xc)

(g

where l(x, j, xc) is deﬁned as above. This makes use only of
the public values gq(0),··· , gq(d).
Although we deﬁned Langrange interpolation for a sequen-
tial set of x coordinates,x0 = 1, x2 = 1,··· , it works for
arbitrary points. The condition for the recovery coefﬁcient—
ﬁnd ω0,··· ωd, ω∗ such that
d(cid:2)

(ω∗ · q(H(sk

(4)
i

))) +

(ωk · q(H(tk))) = q(0) = β

q(x)

k=1
—is effectively asking for
the coefﬁcients necessary to
compute
at 0 given points on the polynomial
(t0, q(t0)),··· (td, q(td)). Since we only need the recovery
coefﬁcients, we merely need th Legrange basies and thus
do not need the y cordinates at all. As a result, we can
compute ωi = l(ti, i, [t0,··· , td, sk(4)]) and ω∗ = l(sk(4), d+
1, [t0,··· , td, sk(4)]).

[31] Philip MacKenzie, Michael K. Reiter, and Ke Yang. Alternatives to
non-malleability: Deﬁnitions, constructions, and applications. In Moni
Naor, editor, TCC ’04, volume 2951, pages 171–190. Springer, 2004.

[32] Moxie Marlinspike.

Forward Secrecy for Asynchronous Messages.
https://whispersystems.org/blog/asynchronous-security/,

Available
at
August 2013.

[33] M. Myers, R. Ankney, A. Malpani, S. Galperin, and C. Adams. X.509
Internet Public Key Infrastructure Online Certiﬁcate Status Protocol -
OCSP. RFC 2560 (Proposed Standard), June 1999. Obsoleted by RFC
6960, updated by RFC 6277.

[34] OpenMP Architecture Review Board. OpenMP application program

interface.

[35] Rafail Ostrovsky, Amit Sahai, and Brent Waters. Attribute-based
In ACM CCS ’07,

encryption with non-monotonic access structures.
pages 195–203, 2007.

[36] B. Ramsdell and S. Turner. Secure/Multipurpose Internet Mail Ex-
tensions (S/MIME) Version 3.2 Message Speciﬁcation. RFC 5751
(Proposed Standard), January 2010.

[37] Amit Sahai, Hakan Seyalioglu, and Brent Waters. Dynamic credentials
and ciphertext delegation for attribute-based encryption. In Advances in
Cryptology–CRYPTO 2012, pages 199–217. Springer, 2012.

[38] Amit Sahai and Brent Waters. How to use indistinguishability obfusca-
tion: Deniable encryption, and more. In Proceedings of the 46th Annual
ACM Symposium on Theory of Computing, pages 475–484. ACM, 2014.
In
13th Annual Computer Security Applications Conference, pages 232–
238. ACM Press, 1997.

[39] B. Schneier and C. Hall. An improved e-mail security protocol.

[40] Hung-Min Sun, Bin-Tsan Hsieh, and Hsin-Jia Hwang. Secure e-mail
protocols providing perfect forward secrecy. Communications Letters,
IEEE, 9(1):58–60, Jan 2005.

[41] Aaron Swartz and Kevin Poulsen.
[42] Randolph Voorhies and Shane Grant.

cereal - A C++11 library for

serialization. http://uscilab.github.io/cereal/index.html.

[43] Guojun Wang, Qin Liu, and Jie Wu. Hierarchical attribute-based
encryption for ﬁne-grained access control in cloud storage services. In
Proceedings of the 17th ACM conference on Computer and communi-
cations security, pages 735–737. ACM, 2010.

[44] Shucheng Yu, Cong Wang, Kui Ren, and Wenjing Lou. Attribute based
data sharing with attribute revocation. In Proceedings of the 5th ACM
Symposium on Information, Computer and Communications Security,
pages 261–270. ACM, 2010.

POLYNOMIAL SELECTION AND INTERPOLATION

APPENDIX A

Our descriptions in Figures 2 and 3 omit several steps
needed to implement
the scheme. Speciﬁcally, our imple-
mentation must (1) select the random polynomial q(x) such
that q(0) = β, (2) compute V (x) without knowledge of
the polynomial coefﬁcients, and (3) compute the recovery
coefﬁcients ω0 ··· ωd, ω
these
details below for completeness.
Recall that a polynomial of degree d is uniquely deﬁned by a
set of points (x0, y0), (x1, y1)··· (xd+1, yd+1). The Lagrange
form of the polynomial allows the computation of a point x
on the polynomial using only d + 1 points as follows:

∗ for decryption. We present

q(x) = L(x, xc, yc) =

d(cid:2)

(yc[i] · l(x, j, xc))

where xc = [x0,··· , xd+1] and yc = [y0,··· , yd+1] and the
Lagrange basis polynomial l(··· )is

j=0

l(x, j, xc) =

(cid:3)

0≤<m<d

m(cid:5)=j

x − xc[m]
xc[j] − xc[m]

In our case the arithmetic above is in Zp.

319319

APPENDIX B

HIBE CONSTRUCTION OF BONEH ET. AL

BBG.Setup(G, (cid:6), α). To produce parameters for a HIBE scheme at most depth l given secret α, select a random generator ˆg ∈ G and set

ˆg1 = ˆg

ˆα. Next pick random elements ˆg2, ˆg3,

h1 ··· ˆ
ˆ

h(cid:6) ∈ G and output :
h1,··· ,
ˆ

M P K = (ˆg, ˆg1, ˆg2, ˆg3,

ˆ
h(cid:6)); M SK = ˆg2

ˆα

BBG.Keygen( ˆ

skID|k−1, suﬃx). To generate a a private key ˆ

master secret key, sample a random r ← Zp and output:
1 ··· ˆ
h

ˆ
skID|k =

ˆα · (ˆ
h

ˆg2

(cid:2)

I1

Ik

k · ˆg3)r

r
, ˆg

,

r

k,··· ,

ˆ
h

ˆ
h

r
l

(cid:3)

= (a0, a1, bk,··· , bl)

skID|k for an identity ID||suf ix = (I1,··· , Ik) of length k ≤ (cid:6), using the

To derive a key incrementally given the parent key ˆ
k · (ˆ

skID|k−1, sample a random t ∈ Zp and output:
k+1,··· , b(cid:6) · ˆ
hl
BBG.Encrypt( ˆPK, ID, M). To encrypt a message M ∈ GT under ID, pick a random s ∈ Zp and output:

k · ˆg3)t

ˆ
skID|k =

1 ··· ˆ
h

, a1·, ˆg

a0 · b

, bk+1

(cid:2)

ˆ
h

Ik

Ik

(cid:3)

h

I1

t

t

t

(cid:2)

ˆCT =

e(ˆg1, ˆg2)s · M, ˆg

s

, (ˆ
h

I1

1 ··· ˆ
h

Ik

k · ˆg

3)s

(cid:3)

BBG.Decrypt( ˆ

skID,

ˆCT) To decrypt a ciphertext ˆCT = (A, B, C) output:

M = e(a1, C)/e(B, a0)

Fig. B.1. The HIBE construction of Boneh, Boyen and Goh [12].

APPENDIX C

IND-PFSE-ATK GAME FOR PFSE

If ATK = CPA the challenger

, d, (cid:6)) and gives PK to the adversary.

PFSE.Decrypt(SK n, CT, t1, . . . , td) and returns M to the adversary.

Setup. On input a security parameter k, a maximum number of tags d, and a number of intervals (cid:6) the challenger initializes two empty
sets P, C and counter n = 0, ex = 0. It runs (PK, SK) ← PFSE.KeyGen(1k
Phase 1. Proceeding adaptively, the adversary can repeatedly issue any of the following queries:
• Puncture(t): The challenger computes SKn+1 ← PFSE.Puncture(SKn, t) and adds t to the set P .
• Corrupt(): The challenger returns the most recent secret key SKn to the adversary, sets C ← P and sets ex = b.
• Decrypt(CT, t1, . . . , td):
• NextInterval(): The challenger sets P = ∅, increments n and computes SK n+1 ← PFSE.NextInterval(SK n, n + 1)
Challenge. The adversary submits two messages m0, m1 ∈ M along with tags t
∗
1, . . . , t
has previously issued a Corrupt query and {t
samples a random bit b, and returns CT∗ ← PFSE.Encrypt(PK, Mb, i, t
∗
∗
d) to the adversary.
1, . . . , t
Phase 2. This phase is identical to Phase 1 with the following restrictions:
• Corrupt() returns ⊥ if {t
• Decrypt(CT, t1, . . . , td) returns ⊥ if (CT, t1, . . . , td) = (CT∗
(cid:3)
Guess. The adversary outputs a guess b
. The adversary wins if b = b
IND-PFSE-ATK security game for PFSE, with ATK ∈ {CPA, CCA}.

d ∈ T and an interval 0 ≤ i ≤ (cid:6). If the adversary
∗
d}∩ C = ∅ or ex ≤ i, the challenger rejects the challenge. Otherwise the challenger
∗

If ATK = CCA the challenger computes M ←

d} ∩ P = ∅ ∨ n ≤ i.
∗

∗
1, . . . , t
(cid:3)

returns ⊥.

∗
1, . . . , t

∗
1, . . . , t

Fig. C.1.

∗
d).

, t

.

320320

