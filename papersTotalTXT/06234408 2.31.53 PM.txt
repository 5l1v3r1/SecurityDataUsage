2012 IEEE Symposium on Security and Privacy

Distance Hijacking Attacks on Distance Bounding Protocols

Cas Cremers
ETH Zurich

Kasper B. Rasmussen

University of California, Irvine

Benedikt Schmidt

ETH Zurich

Srdjan ˇCapkun
ETH Zurich

Information Security group

Computer Science Dept.

Zurich, Switzerland
cas.cremers@inf.ethz.ch

Irvine, California

kbrasmus@ics.uci.edu

Information Security group

Systems Security group

Zurich, Switzerland
benschmi@inf.ethz.ch

Zurich, Switzerland
capkuns@inf.ethz.ch

Abstract—After several years of theoretical research on
distance bounding protocols, the ﬁrst implementations of such
protocols have recently started to appear. These protocols are
typically analyzed with respect to three types of attacks, which
are historically known as Distance Fraud, Maﬁa Fraud, and
Terrorist Fraud.

We deﬁne and analyze a fourth main type of attack on
distance bounding protocols, called Distance Hijacking. This
type of attack poses a serious threat in many practical scenarios.
We show that many proposed distance bounding protocols are
vulnerable to Distance Hijacking, and we propose solutions to
make these protocols resilient to this type of attack.

We show that verifying distance bounding protocols using
existing informal and formal frameworks does not guarantee
the absence of Distance Hijacking attacks. We extend a formal
framework for reasoning about distance bounding protocols to
include overshadowing attacks. We use the resulting framework
to prove the absence of all of the found attacks for protocols
to which our countermeasures have been applied.

Keywords-Distance bounding, location veriﬁcation, position
veriﬁcation, attacks, hijacking, multi-prover environment, for-
mal model, formal veriﬁcation

I. INTRODUCTION

By using distance bounding protocols, a device (the
veriﬁer) can securely obtain an upper bound on its distance
to another device (the prover). A number of distance
bounding protocols were proposed in recent years [2], [4],
[5], [12], [14], [15], [19]–[21], [23], [24], [27]–[29]. The
proposed protocols differ in terms of the performance and
security guarantees that they provide. So far, several distance-
bounding protocols were implemented, some using digital
processing and short symbols [9], [16], whereas others rely on
analog processing and use signal streams (operating similarly
to radar systems) [23].

The security of distance-bounding protocols was so far
mainly evaluated by analyzing their resilience to three types
of attacks. For historical reasons, these are known as Distance
Fraud, Maﬁa Fraud and Terrorist Fraud. In Distance Fraud
attacks, a sole dishonest prover convinces the veriﬁer that
he is at a different distance than he really is. In Maﬁa Fraud
attacks, the prover is honest, but an attacker tries to modify
the distance that the veriﬁer establishes by interfering with
their communication. In Terrorist Fraud attacks, the dishonest
prover colludes with another attacker that is closer to the

© 2012, Cas Cremers. Under license to IEEE.
DOI 10.1109/SP.2012.17

113

veriﬁer, to convince the veriﬁer of a wrong distance to
the prover. So far, it was assumed that distance bounding
protocols that are resilient against these three attack types
can be considered secure.

However, we show that many of these protocols, irrespec-
tive of their physical-layer implementation, and including
the classical Brands and Chaum protocol [4] and the recent
CRCS protocol [23], are vulnerable to attacks when used
in environments with multiple provers. We coin this type of
attack Distance Hijacking. In Distance Hijacking attacks, a
dishonest prover convinces the veriﬁer that it is at a different
distance than it actually is, by exploiting the presence of an
honest prover. For example, one of the ways in which the
dishonest prover can achieve this is by hijacking the distance
measurement phase of a distance bounding protocol from
an honest (closer or further) prover. This type of attack can
pose a serious threat in many practical scenarios.

Conceptually, Distance Hijacking can be placed between
Distance Fraud and Terrorist Fraud. Unlike Terrorist Fraud,
in which a dishonest prover colludes with another attacker,
Distance Hijacking involves a dishonest prover interacting
with other honest provers. Unlike Distance Fraud attacks,
which involve only a dishonest prover and a veriﬁer, Distance
Hijacking attacks additionally involve other honest provers.
These differences have signiﬁcant consequences. For example,
the countermeasures proposed against Terrorist Fraud rely
on the assumption that dishonest provers are not willing
to share their keying material with other attackers. Such
countermeasures will therefore not deter the dishonest provers
from executing Distance Hijacking attacks that do not involve
other attackers. Furthermore, Distance Hijacking can occur
even in situations where Terrorist Fraud is not a concern.
In fact, as we will show, protocols that are resilient against
the three classical attack types may still be vulnerable to
Distance Hijacking.

We deﬁne an exhaustive classiﬁcation for attacks on
distance bounding protocols that includes Distance Hijacking.
Our classiﬁcation naturally leads to minor reformulations of
previously known attack types. Instead of using the traditional
attack names for our new deﬁnitions, we propose names that
are more descriptive and less generic.

We perform a case study of existing protocols. All distance

bounding protocols that were proposed in the last years
roughly fall into two categories: those based on the Brands
and Chaum protocol, and those based on the Hancke and
Kuhn protocol. We show that all proposed protocols that
followed the structure proposed by Brands and Chaum are
vulnerable to Distance Hijacking. Protocols that followed the
structure proposed by Hancke and Kuhn are less vulnerable
to this type of attack. We propose two classes of effective
and generic countermeasures that make Brands and Chaum
and related protocols secure against Distance Hijacking in
the above scenario. Our countermeasures are inexpensive:
the protocols can be repaired without introducing additional
messages or cryptographic operations.

Remarkably, none of the existing frameworks for analyzing
distance bounding protocols (e. g., [1], [3], [10], [18], [25])
guarantees the absence of our Distance Hijacking attacks,
even if some instances of Distance Hijacking can be detected
using some of those frameworks. We extend the formal
framework of Basin et al. [3] to capture all known types of
Distance Hijacking attacks and use the resulting framework
to analyze several protocols. The new framework enables us
to model bit-level manipulations of messages by considering
overshadowing parts of a message [22], as well as ﬂipping
some bits of a message. We use our framework to formally
prove for speciﬁc protocols that our ﬁxes indeed prevent the
found attacks.

We show that all distance bounding protocols, including
those based on the Hancke and Kuhn protocol, may be
vulnerable to Distance Hijacking if run alongside another
distance bounding protocol. This can occur if more than one
distance bounding protocol is used in the same environment,
i. e., a multi-protocol environment. In particular, some pro-
tocols, when run by an honest prover, enable a dishonest
prover (running, e. g., a Hancke and Kuhn protocol) to hijack
the distance of the honest prover. Such attacks can be seen
as a variant of the Chosen Protocol Attack [13]. However,
unlike Chosen Protocol attacks, our attacks do not require the
protocols to share any cryptographic material. We discuss
designs of distance bounding protocols that enable such
attacks and show how to mitigate these attacks.

Contributions: First, we identify Distance Hijacking
as a threat for distance bounding protocols that are run in
multi-prover environments, whose absence is not guaranteed
by existing frameworks. Second, we show that prominent
distance bounding protocols are vulnerable to Distance
Hijacking and propose countermeasures. Third, we extend a
formal framework for reasoning about Distance Bounding
protocols to model overshadowing attacks and use the result-
ing framework to prove correctness of our countermeasures
for speciﬁc protocols. Fourth, we address the security of
distance bounding protocols in multi-protocol environments
and propose mitigating measures. Finally, we generalize
Distance Hijacking to Location Hijacking, and show that it is
possible to hijack locations at which no other provers reside.

We proceed as follows. In Section II we provide background
on distance bounding protocols. In Section III we introduce
Distance Hijacking attacks and analyze the resilience of
existing distance bounding protocols against these attacks. We
relate the attacks to the classical attack types and provide an
exhaustive classiﬁcation. In Section IV we show how distance
bounding protocols can be made resilient against Distance
Hijacking. In Section V we present an extended formal
framework and analyze a set of protocols. In Section VI
we analyze the resilience of distance bounding protocols
to Distance Hijacking in multi-protocol environments. We
introduce the notion of Location Hijacking in Section VII,
present the related work in Section VIII, and conclude in
Section IX.

II. BACKGROUND

The goal of a distance bounding protocol is to enable a
veriﬁer to establish an upper bound on its physical distance to
a prover. As a running example, we consider the basic Brands
and Chaum protocol with signatures [4, p. 7], depicted in
Figure 1. In the protocol, the prover P randomly generates
(denoted by ∈R ) a bit string m1, . . . , mk, and sends a
commit of this value to the veriﬁer V . Thus, although the bit
string is not revealed yet, V will be able to check whether
P indeed committed to this particular string when V learns
the string later. The veriﬁer then generates his own random
bit string α1, . . . , αk, and initiates the so-called rapid bit
exchange. In this exchange, bits are sent one-by-one, and
the prover has to respond as quickly as possible with the
exclusive-or (⊕) of the challenge bit string α and his own
bit string. In the end, the veriﬁer will derive an upper bound
on the distance to the prover from the response times. Notice
that the prover can delay messages at will, making himself
appear farther away, but he cannot respond faster than what
is dictated by the time-of-ﬂight of the messages. After this
phase, P concatenates the bits as c, and sends to V a means to
open the commit he sent earlier, as well as the concatenation
c signed with his signature key. Upon receiving this ﬁnal
message, V veriﬁes that the commit previously sent by P
indeed matches with the response (by computing mi =
αi ⊕ βi and opening the commit), concatenates the bits he
has observed, and compares them to the received signature
using the public key of P .

Because the goal of a distance bounding protocol is to
provide a guarantee for the veriﬁer V , V will never participate
in an attack since that would mean V would be attacking
itself. The attacker can of course pretend to be another veriﬁer
V (cid:2), and abuse his location to attack the real veriﬁer V .

As stated in the introduction,

three different classes
of attacks are traditionally considered in the analysis of
distance bounding protocols: Distance Fraud, Maﬁa Fraud
and Terrorist Fraud. All attacks that fall into one of these
three classes have a similar goal, namely to make the veriﬁer
believe that the prover P is physically closer to the veriﬁer

114

msc Signature-based Brands and Chaum protocol

Prover

P

m ∈R {0, 1}k

Veriﬁer

V

commit (m)

α ∈R {0, 1}k

Rapid bit exchange for i = 1 to k

αi

βi

βi ← αi ⊕ mi

c ← α1|β1| · · · |αk|βk

(open commit), sign(c)

Verify commit

c ← α1|β1| · · · |αk|βk

verify sign(c)

Figure 1. Signature-based Brands and Chaum protocol.

V than it really is. The main difference between these attacks
is in the parties that carry out the attack, and their mutual
relationships.

Maﬁa Fraud attacks, also called relay attacks, were ﬁrst
described by Desmedt [8]. In this type of attack, both
the prover P and veriﬁer V are honest, and the attack is
performed by an external attacker A. The attacker attempts
to shorten the distance measured between the honest prover
and the veriﬁer. In Maﬁa Fraud attacks, the physical distance
between the attacker and the veriﬁer is typically small in
order for the attacker to be able to shorten the distance.

In a Distance Fraud attack, a dishonest prover P will
try to shorten the distance measured by the veriﬁer V . This
type of attack is executed by the dishonest prover P alone,
without collusion with other (external) parties. An example
of a Distance Fraud attack occurs if the protocol allows the
prover to send his reply before receiving the challenge. This
enables the prover to reply too early, thereby shortening the
distance measured by the veriﬁer.

The third class of attacks is Terrorist Fraud attacks [8]. In
this type of attack, a dishonest prover P collaborates with
an external attacker A to convince the veriﬁer V that he
is closer than he really is. All countermeasures to Terrorist
Fraud make the assumption that the dishonest prover P is
unwilling to reveal his long-term (private or secret) key to
the attacker A that he collaborates with. Possible reasons
for this unwillingness are impersonation, i. e., the external
attacker can later use the key to impersonate the dishonest
prover, and traceability, i. e., the key may later be used to
implicate the dishonest prover in performing a Terrorist Fraud
attack. Furthermore, from the perspective of the veriﬁer, it is

impossible to distinguish between the external attacker and
the prover if the attacker knows the long term key of the
prover.

III. DISTANCE HIJACKING

In this section we deﬁne a fourth class that has until
now been overlooked in the design of distance bounding
protocols, Distance Hijacking attacks. We relate this class
of attacks to the three classical attack types on distance
bounding protocols, and propose an exhaustive classiﬁcation
of attacks on distance bounding protocols.

A. Distance Hijacking attacks

We say that a prover P is honest if and only if all of P ’s

actions conform to the protocol speciﬁcation.
Deﬁnition 1. A Distance Hijacking attack is an attack in
which a dishonest prover P exploits one or more honest par-
ties P1, . . . , Pn to provide a veriﬁer V with false information
about the distance between P and V .

A protocol is then said to be vulnerable to Distance
Hijacking if it allows P to perform a successful Distance
Hijacking attack. We observe that these attacks do not exclude
the involvement of other attackers with whom the dishonest
prover is colluding or the involvement of other honest veriﬁers
that might enable the execution of the attack.

In the context of distance bounding protocols, the infor-
mation about the distance is the upper bound; hence attacks
involve convincing V that P is closer than it actually is. In
a typical Distance Hijacking attack on a distance bounding
protocol, a dishonest prover P convinces a veriﬁer V that
P has executed a distance measurement phase (e. g., a rapid
bit exchange) with V , whereas this phase has been really
executed by an honest prover P (cid:2). This is done without the
cooperation of the honest prover P (cid:2). Often this type of attack
can be carried out by allowing the honest prover to complete
the distance bounding protocol as he normally would, and
then by replacing all messages that contain signatures or
MACs, with messages signed (or MAC’ed) by the attacker.
Example 1 (Distance hijacking attack on signature-based
Brands and Chaum). Figure 2 depicts a basic Distance
Hijacking attack on the signature-based Brands and Chaum
from Figure 1.
In the attack, V thinks he is communicating with P , where
P is dishonest. When an honest prover P (cid:2) tries to prove his
distance, P initially allows the protocol to proceed as normal
between P (cid:2) and V , waiting until the ﬁnal signature is sent
by P (cid:2). Note that before this point, V has no cryptographic
evidence that the messages it received were indeed sent by
P (cid:2). When P (cid:2) sends the signature, P jams the message and
re-signs the content c with his own signature key, and sends
the result to V . V will successfully verify the commit as well
as the signature, and will falsely conclude that P has also
sent the previous message. Thus, V assumes that P is within

115

msc Attack on basic signature-based Brands and Chaum

Dishonest prover

Honest prover

P

P (cid:2)

Veriﬁer

V

m ∈R {0, 1}k

commit (m)

α ∈R {0, 1}k

Rapid bit exchange for i = 1 to k

αi

βi = αi ⊕ mi

c ← α1|β1| · · · |αk|βk

(open commit), sign P (cid:2) (c)

(open commit), sign P (c)

Verify commit

c ← α1|β1| · · · |αk|βk

verify sign P (c)

Figure 2. Distance Hijacking attack on basic signature-based Brands and
Chaum. sign P and sign P (cid:2) denote the signatures with the signature keys
of P and P (cid:2), respectively.

the distance computed from the distance bounding phase,
even though in reality, this phase was performed by P (cid:2).

We next show an example scenario in which Distance

Hijacking attacks pose a threat.
Example 2 (Real-world scenario). Consider the scenario
depicted in Figure 3, in which several people work in a secure
facility. In the facility is a mainframe containing sensitive
information. The mainframe can be accessed wirelessly by
all authorized personnel, in order to facilitate easy access
by multiple people at the same time. As an added security
mechanism, in case an employee loses his smartcard with his
private key, the mainframe can only be accessed by people
inside the building. This is veriﬁed every time an employee
logs in to the system, by running a distance bounding protocol
between a station in the building (acting as the veriﬁer) and
the employees terminal (acting as the prover).

Assume that an attacker has managed to get hold of an
employee smartcard but is unable to physically access the
building. He is instead located in a van in the parking lot
where he has a powerful antenna capable of communicating
with the wireless terminal inside the building. However in
order to log in to the system the attacker needs to prove that
he is inside the building by running a distance bounding
protocol.

If the distance bounding protocol in use is vulnerable to
distance hijacking, the attacker can exploit the presence of
the smartcard of another (non-collaborating and unaware)
employee inside the building to execute a Distance Hijacking
attack. The mainframe security system now believes that the

Figure 3. Real-world scenario for Distance Hijacking. P has a (stolen)
smartcard. However, he cannot enter the secure facility and he does not
have any collaborators inside the facility. In a Distance Hijacking attack, P
exploits the presence of an honest P (cid:2) to convince V that P is within the
secure facility.

attacker is in the building with a valid private key, and he
is granted wireless access.

As straightforward as this type of attack may seem, a sur-
prising number of distance bounding protocols are vulnerable
to Distance Hijacking, as we will show in Section III-E. In
Section VI we discuss more complex Distance Hijacking
attacks, where several different distance bounding protocols
are used in the same environment.

B. Relation to historical attack types

We ﬁrst relate Distance Hijacking to the three attack
types that are traditionally considered for distance bounding
protocols.

As stated in the introduction, conceptually speaking,
Distance Hijacking can be placed between Distance Fraud
and Terrorist Fraud. One could thus consider extending the
deﬁnition of either Distance Fraud or Terrorist Fraud to
also include Distance Hijacking attacks. However, given
that previous analyses and countermeasures do not exclude
such attacks, the consequence would be that many protocols
would be incorrectly labeled as being resistant against the
(new deﬁnitions of) Distance Fraud or Terrorist Fraud, or
that existing countermeasures are insufﬁcient. We therefore
choose to introduce Distance Hijacking as a separate type
of attack.

We show why the existing three attack types do not cover
Distance Hijacking. In Maﬁa Fraud attacks the prover is
honest. Distance Fraud attacks are deﬁned as attacks by a
lone dishonest prover. These two types are therefore clearly
different from Distance Hijacking, which involves at least a
dishonest prover and another honest party.

To illustrate the difference between Distance Hijacking and
the attack type that is conceptually closest, Terrorist Fraud,
we consider again the scenario from Example 2. Recall that
in Terrorist Fraud, the dishonest prover collaborates with
another (closer) attacker. In the scenario from the example,
there are two main reasons why the absence of Terrorist Fraud
attacks does not guarantee the absence of Distance Hijacking

116

Figure 4. Classiﬁcation of attacks on distance bounding protocols, in which a veriﬁer computes an incorrect distance bound for a prover.

attacks. First, we observe that Terrorist Fraud is not possible
in this scenario, because the attacker does not have another
attacker inside the building that is willing to cooperate with
him. Hence the designers of the system could consider using
a protocol such as signature-based Brands and Chaum, on
which Distance Hijacking may still be possible. Second, the
common countermeasure to Terrorist Fraud is to force the
attacker to reveal his long term key to his accomplice, based
on the assumption that this will deter the attacker. However,
in the scenario from Example 2 this assumption does not
hold: the attacker has no problem with leaking the (stolen)
long term key. Additionally, even if he does transmit the
key, it will be to the (unmodiﬁed) smartcard of an honest
employee. The employee’s smartcard will typically not detect
this key, and will even delete the received data after the
session ends. Hence guaranteeing the absence of Terrorist
Fraud attacks, either by assumption or by countermeasure,
does not guarantee the absence of Distance Hijacking.

C. Attack classiﬁcation

The traditional attack types Maﬁa Fraud, Distance Fraud,
and Terrorist Fraud, are deﬁned independent of each other and
usually in incompatible ways. This makes it hard to determine
whether all possible attacks on distance bounding protocols
are covered by these types, even if we include Distance
Hijacking attacks. We propose to remedy this situation by
deriving attack type deﬁnitions that cover all possible attacks
by construction. Intuitively, we perform a sequence of case
distinctions based on three attributes of attacks on distance
bounding protocols: whether the prover is honest, whether
the prover is the only party involved in attacking the veriﬁer,
and if not, whether one of the other involved parties is honest.
By considering these three attributes we arrive at deﬁnitions
for four attack types.

We introduce some additional terminology. The goal of a
distance bounding protocol is to compute a correct distance
bound. More precisely, we say that the veriﬁer V computes
the correct distance bound d on P , if P or his identifying
key1 is indeed within the (computed or expected) distance d.
We make two assumptions on distance-bounding protocols.
First, in the absence of attackers, the veriﬁer computes the

1In our context, P is identiﬁed by his key. If others know P ’s key, they

cannot be distinguished from P .

correct distance bound. Second, we assume that the protocols
guarantee weak authentication of P (i. e., aliveness [17]).

Using the above terminology and assumptions, we provide
an exhaustive classiﬁcation of attacks on distance bounding
protocols attacks in which the veriﬁer computes an incorrect
distance bound for the prover, represented in Figure 4.
Assume that V does not compute the correct distance bound
d for P . Thus, neither P nor his identifying key is within
the distance d. Because of our ﬁrst protocol assumption, this
must be caused by an attacker.

We distinguish two main cases. If P is honest, then P is
not the attacker, and therefore an external attacker is changing
the distance. We call this type of attack External Distance
Fraud.
Deﬁnition 2. An External Distance Fraud attack is an
attack in which an attacker provides a veriﬁer V with false
information about the distance between an honest prover P
and V .

In the second case, if P is not honest, then we distinguish
again between two cases. First, if only P is involved in the
attack, he must be the attacker, trying to change his own
distance. We call this type of attack Lone Distance Fraud.
Deﬁnition 3. A Lone Distance Fraud attack is an attack
in which a lone prover P provides a veriﬁer V with false
information about the distance between P and V .

If other parties are involved, we make a ﬁnal distinction.
If all of the other parties are dishonest or collaborating, the
attack is called an Assisted Distance Fraud attack.
Deﬁnition 4. An Assisted Distance Fraud attack is an attack
in which a prover P is assisted by one or more other parties,
none of which are honest, to provide a veriﬁer V with false
information about the distance between P and V .

Alternatively, if one of the other parties involved in the
attack is honest, we call the attack a Distance Hijacking
attack, as in Deﬁnition 1.

In constructing the above classiﬁcation, we have tried to
stay close to the historical attack types. In fact, three of our
attack types are variants of the historical types. However, we
have tried to provide them with more descriptive and less
generic names. In particular, our deﬁnition of Lone Distance
Fraud closely resembles the classical notion of Distance

117

Fraud. Our deﬁnition of External Distance Fraud resembles
that of Maﬁa Fraud, and our deﬁnition of Assisted Distance
Fraud includes Terrorist Fraud attacks.

It is worth pointing out that although P refers to a speciﬁc
identity, or rather the identity of a party holding a speciﬁc key,
this classiﬁcation is also valid in the context of anonymous
distance bounding protocols [30]. In anonymous distance
bounding, the only guarantee provided to the veriﬁer is that
someone is within a speciﬁc distance, as opposed to P is
within a speciﬁc distance. In order to ﬁt anonymous distance
bounding protocols into this model, we say that all provers
in anonymous distance bounding share the same key (which
could be public) and, in the decision points in Figure 4, “the
prover” must be replaced by “the closest prover”.
D. Multi-prover environments

The main requirement for Distance Hijacking is that there
are other parties in the environment, which can be exploited
by a dishonest prover. We call environments in which multiple
provers may occur multi-prover environments. We give two
concrete examples of such environments.

Multiple provers, single veriﬁer: One such a scenario
occurs when a veriﬁer accepts proofs from multiple provers,
as depicted in Figure 5. For example, this may occur in RFID
distance bounding where a reader may accept multiple tags. In
this case, Distance Hijacking occurs when a dishonest prover
P hijacks the distance from P (cid:2) to V and instead convinces
V that P is at this distance, thereby falsely “shortening” the
distance between P and V .

Note that

in the above example,

the veriﬁers accept
protocol sessions from multiple provers. Below we show
that this is not required for the attacks.
Multiple provers, multiple veriﬁers: Consider an envi-
ronment with multiple provers P, P (cid:2), . . . and corresponding
veriﬁers, VP , VP (cid:2) , . . ., where veriﬁer VP only accepts proofs-
of-distance from prover P and veriﬁer VP (cid:2) only from prover
P (cid:2). Even in this scenario, a prover P can hijack a session
from a prover P (cid:2) to a veriﬁer VP (cid:2) to make VP falsely believe
that P is at distance dist(P (cid:2), VP ). This type of scenario is
depicted in Figure 6. P (cid:2) assumes that he is proving his
distance to VP (cid:2), but instead, the fast response of P (cid:2)
is
accepted by VP , who assumes that it was sent by P .
Note that for the attack to work, neither P and VP
nor P and P (cid:2) need to be physically close. Instead, the
communication between P (cid:2) and VP (cid:2) can be enabled by the
attacker who created a relay between them whereas P can
communicate to P (cid:2) using a high power transceiver and a
high gain antenna. This second scenario may even occur
across domains: the only requirement is that the distance
measurement (e. g., rapid bit exchange) phases used in both
domains are to some extent compatible.
E. Analysis of Existing Distance Bounding Protocols

We have analyzed several protocols and found numerous
new attacks that fall into the class of Distance Hijacking

118

Figure 5.
Scenario in which
V accepts protocol sessions from
multiple provers, here P and P (cid:2),
where Distance Hijacking may be
a threat.

Figure 6.
Scenario with mul-
tiple prover/veriﬁer pairs, where
Vx only accepts sessions from
x. Even in this case, Distance
Hijacking may be possible.

attacks. We give an overview of the protocols analyzed
in Table I. The vast majority of the attacks we ﬁnd are
new. To the best of our knowledge, only two such attacks
were previously reported in the literature. The attack on a
simpliﬁed version of “Brands and Chaum (signature)” is
described in [25]. The attack on a member of the protocol
family proposed by Meadows et al., in particular for the
instance with F (NV , NP , P ) = (cid:4)NV , NP⊕P(cid:5), is described
in [3]. All other attacks in the table are new.

In our analysis we used the following system and attacker
model. We assume that the attacker controls the network
and may eavesdrop, intercept, inject, and block messages.
We do not pose any restrictions on the number or locations
of devices that the attacker holds; the attacker can control
several dishonest provers as well as other wireless devices.
Entities are identiﬁed by their keys; entities that hold the
same keys cannot be distinguished.

In this paper, we describe two attacks from the table
in detail. We already described the attack on the basic
Brands and Chaum protocol with signatures in Example 1.
We describe an attack on the Kuhn, Luecken, Tippenhauer
protocol in Example 4.

In general, it seems that protocols that closely follow the
original Brands and Chaum protocols do not offer protection
against Distance Hijacking. In contrast, protocols that derive
from the Hancke and Kuhn protocol, which explicitly uses
the key shared between agents in the distance bounding
phase, protect against Distance Hijacking in single-protocol
environments. However, as we explain in Section VI, all
protocols, including the ones derived from the Hancke and
Kuhn protocol, are vulnerable to Distance Hijacking in
speciﬁc multi-protocol environments.

We note that for many of the attacks in the table, it
is required that the veriﬁer V is not “disturbed” by P ’s
messages. As a concrete example, consider the attack in
Figure 2. If V would receive and parse P ’s ﬁnal signed
message, V might abort the protocol, in which case the
attack fails. There are several practical scenarios in which
the attacks are directly possible. For example, assume that
the signed message is sent through standard WiFi channels,
and P assumes that he is responding to some other veriﬁer

No.

Protocol

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

Brands and Chaum (Fiat-Shamir) [4, p. 351]
Brands and Chaum (Schnorr) [4, p. 353]
Brands and Chaum (signature) [4, p. 350]
Bussard and Bagga [5]
CRCS [23]
Hancke and Kuhn [12]
Hitomi [20]
KA2 [15]
Kuhn, Luecken, Tippenhauer [16]
MAD [29]
Meadows et al. for F (. . .) = (cid:2)NV , NP ⊕ P(cid:4) [18]
Munilla and Peinado [19]
Noise resilient MAD [27]
Poulidor [28]
Reid et al. [24]
Swiss-Knife [14]
Tree [2]
WSBC+DB [21, p. 50]
WSBC+DB Noent [21, p. 51]

Discovered
attack
Yes
Yes
Yes
No
Yes
No
No
No
Yes
Yes
Yes
No
Yes
No
No
No
No
Yes
Yes

DISCOVERED DISTANCE HIJACKING ATTACKS ON EXISTING PROTOCOLS

(SINGLE PROTOCOL ENVIRONMENT).

Table I

V2. In this case, P sends the message addressed to V2, and
V ’s hardware may already ﬁlter out the message before it
arrives at the protocol level. Alternatively, the attacker can
jam-and-eavesdrop the signals sent by P (except for P ’s fast
response). Jamming seems to be possible on all protocols in
the table except for MAD, which explicitly requires jamming
detection, upon which the protocol aborts.

IV. PROTECTING AGAINST DISTANCE HIJACKING

We have seen that many protocols are vulnerable to
Distance Hijacking, and we now show how to repair them.
Without loss of generality, any distance bounding protocol
can be divided into three phases as depicted in Figure 7: the
setup phase, where nonces and commitments are exchanged;
the distance measurement phase, where the physical distance
is measured, often using rapid bit exchange; and the ﬁnalizing
phase that often includes a proof of identity. The only phase
that is required to be non-empty is the distance measurement
phase. The distance measurement phase follows the following
schema: the veriﬁer sends out a fresh challenge, to which the
prover responds with some value; this process may be split
into several rounds. The distance measurement is derived
from the measured response time, which means that the
prover must reply immediately. It is therefore infeasible to
use cryptographic functions (such as encryption or signatures)
in the computation of the response in this phase.

In a typical Distance Hijacking attack, a dishonest prover
exploits another prover’s response in the distance measure-
ment phase. Thus, although the dishonest prover has few
restrictions, because he does not have to follow the protocol
and can construct his own messages as he chooses, he can
only exploit honest provers as far as the protocol allows him

119

msc Phases

Prover

P

Veriﬁer

V

Setup phase

Distance measurement phase

Challenge

Response

Time measurement

Finalizing phase

Figure 7.
Phases in distance bounding protocols: Setup, distance
measurement, and ﬁnalizing. The setup and ﬁnalizing phases may be empty.

to. Therefore, in the ﬁxes we propose, we ensure that the
distance measurement response of an honest prover cannot
be abused by others in their communication with the veriﬁer.
Before we proceed to solutions, we provide more intuition
by showing why two seemingly straightforward ﬁxes to the
basic Brands and Chaum protocol fail.
Example 3 (Flawed ﬁx: Xor identity). A ﬁrst ﬂawed ﬁx is
to include the prover’s identity in the response messages
by sending challenge ⊕ NP ⊕ P. The problem with this
solution is that the identity of an attacker P (cid:2) might only
differ in a few bits from P . Then challenge ⊕ NP ⊕ P
agrees with challenge ⊕ NP ⊕ P
(cid:2) on all other bits and
the adversary only has to guess the remaining few bits in
challenge ⊕ NP ⊕ P
(cid:2) and overshadow them in P ’s response.
After learning challenge and NP, the dishonest prover can
check if his guesses were right and send the ﬁnal signature.
If the Hamming distance between P and P (cid:2) is k, then the
attacker has to guess k bits and his success probability is
therefore ( 1
Example 4 (Flawed ﬁx: secure channels). A second ﬁx is
to perform the setup and ﬁnalizing phases over some secure
channel, e. g., by using SSL/TLS, mutually authenticated
using client and server certiﬁcates. A protocol along these
lines is described in [16]. Because an attacker now cannot
eavesdrop (or change) the contents of the communication,
it might seem that any hijacking is thwarted. However, as
depicted in Figure 8, such protocols are still vulnerable to
Distance Hijacking. In the attack, P claims to be a veriﬁer
when communicating with P (cid:2), and P claims to be a prover
when communicating with V . Thus, P (cid:2) assumes that he
is proving his distance to P , and therefore transmits his
commit over the secure channel to P . P simply forwards
this commit to V . Because the distance measurement phase
is not protected by the secure channel, P (cid:2) will respond to
V ’s challenge. Afterwards, P (cid:2) will ﬁnalize his part over the
secure channel with P . P re-signs this information and sends
it to V over the secure channel.

2 )k.

msc Attack on Brands and Chaum variant with secure channels

Dishonest prover

P

Honest prover

P (cid:2)

Veriﬁer

V

Generate β

commit (β)

commit (β)

Distance measurement phase

Generate α

α

α ⊕ β

sign P (cid:2)(V, α, β)

sign P (V, α, β)

Figure 8. Attack on Brands and Chaum variant where setup and ﬁnalization
use a secure channel. We use dashed arrows to denote transmission over a
secure channel. P (cid:2) assumes that P is a veriﬁer.

As shown by the examples, it is not trivial to make proto-
cols resilient against Distance Hijacking. The solution is to
make the prover’s messages during the distance measurement
phase distinguishable from those of other provers, such that
a veriﬁer will not mistake the response of one prover (say,
P (cid:2)) for the response of another (say, P ). We discuss two
possible solutions: explicit linking and implicit linking.

Solution family 1: Explicit linking: The ﬁrst solution, ex-
plicit linking, ensures that the response from different provers
is distinguishable by explicitly including identity information
in the response, combined with integrity protection. Example
instances of explicit linking are the following, where we
assume that NP is a nonce generated by the prover which
he commits to in the setup phase.

• challenge ⊕ h(P, NP ), where h is a hash function.
• challenge ⊕ sign P (NP ).
• challenge ⊕ MAC k(P,V )(P, NP ), where k(P, V ) is a

symmetric shared key between P and V .
Solution family 2: Implicit linking: The second solution
type, implicit linking, does not make the responses of different
provers distinguishable on their own. Rather, it relies on the
fact that honest provers do not reveal some secret, typically
their own nonce NP, before the distance measurement phase
has been completed. Thus, before this phase, only the prover
who generated NP knows the secret and can use it to
construct messages. In protocols that commit to a (temporary)
secret in the setup phase, the prover can include his identity
in the commit, hence sending commit(P, NP ) before the
distance measurement phase. Until the prover P releases this
nonce during or after his response, other (dishonest) provers
cannot commit to NP with their own identity. Thus, the
veriﬁer can check that the claimed identity for the distance
measurement phase corresponds to the commit he received
during the setup phase.

V. FORMAL ANALYSIS

Previous formal models capture Distance Hijacking to
an insufﬁcient extent. Speciﬁcally,
they do not capture
overshadowing parts of a message (see [22]), e. g., by sending
bits using a stronger signal. Several of our Distance Hijacking
attacks involve such overshadowing. To capture these attacks,
we extend the formal framework of Basin et al. [3] to
allow the attacker to perform message manipulation on the
wireless channel by overshadowing parts of a message, as
well as ﬂipping some bits of a message. The resulting new
framework allows to formally prove the absence all of the
previously described Distance Hijacking attacks. A complete
Isabelle/HOL formalization of all deﬁnitions and proofs in
this section is available in [26].

In Section V-A, we recall the basic model from [3] and

we present its extension in Section V-B.
A. Basic model

Agents and Environment: We assume that there are
countably inﬁnite disjoint sets Honest and Dishonest of
honest and dishonest agents. We deﬁne the set of all agents as
Agent = Honest∪ Dishonest. We use A, B, P , V for agents.
We associate a location locA ∈ R
3 to each agent. Based
on the location, we deﬁne the line-of-sight communication
distance between two agents A and B as

cdistLoS(A, B) =

|locA − locB|

c

(cid:2)

where c denotes the speed of light. This distance constitutes
a lower bound on the time required for a signal to travel
from A to B derived from the locations of both agents.

Messages: We assume that there is a countably inﬁnite
set Const of constants. We assume that there are countably
inﬁnite disjoint sets NonceA for each agent A and deﬁne
A∈Agent NonceA. We assume that there is a count-
Nonce =
ably inﬁnite set Key of keys that is partitioned into keys for
symmetric encryption and asymmetric encryption/signatures.
We assume that there is an inverse operator ·−1 on Key that is
the identity on symmetric keys. The set of syntactic messages
SMsg is deﬁned by the grammar
::= atom | (cid:4)M, M(cid:2)(cid:5) | h(M ) | {M}k | M ⊕ M(cid:2) | 0
M, M(cid:2)
where atom ∈ Agent ∪ Const ∪ Key ∪ Nonce is an atomic
message, and the remaining cases denote pairing, hashing,
encryption with k ∈ Key, exclusive-or, and the all-zero
message. We write signA(M ) as a shorthand for {M}sk(A).
We deﬁne the set Msg of messages as SMsg/=E, where
=E is the equational theory generated by the set of equations

E = {M ⊕ 0 =M, M ⊕ M = 0,

(M ⊕ M(cid:2)
M ⊕ M(cid:2)

) ⊕ M(cid:2)(cid:2)
= M(cid:2) ⊕ M}.

= M ⊕ (M(cid:2) ⊕ M(cid:2)(cid:2)

),

In the following, we abuse notation and write M to denote
=E M} ∈

the corresponding equivalence class {M(cid:2) | M(cid:2)
Msg.

120

M ∈ IKA

M ∈ DMA(tr)

(t, RecvA(M )) ∈ tr
M ∈ DMA(tr)

M ∈ DMA(tr) M(cid:2) ∈ DMA(tr)

M ⊕ M(cid:2) ∈ DMA(tr)

M ∈ DMA(tr) M(cid:2) ∈ DMA(tr)

(cid:4)M, M(cid:2)(cid:5) ∈ DMA(tr)

M ∈ DMA(tr) k ∈ DMA(tr)

{M}k ∈ DMA(tr)

M ∈ DMA(tr)
h(M ) ∈ DMA(tr)
(cid:4)M1, M2(cid:5) ∈ DMA(tr)

Mi ∈ DMA(tr)

 ∈ TR

NIL

tr ∈ TR I ∈ Dishonest M ∈ DMI (tr)

tr · (t, SendI (M )[]) ∈ TRP
tr ∈ TR (t(cid:2), SendA(M )[L]) ∈ tr

t ≥ t(cid:2)
+ cdistLoS(A, B)
tr · (t, RecvB(M )) ∈ TRP

INTR

BASICNET

Figure 10. Rules for network and attacker from the basic model.

{M}k ∈ DMA(tr) k−1 ∈ DMA(tr)

M ∈ DMA(tr)

Figure 9. Rules deﬁning DMA(tr).

tr ∈ TR

Events and Traces: The set of events is deﬁned as
] | RecvA(M ) | ClaimA(M ).
EV ::= SendA(M )[M∗

For Send, A denotes the agent executing the send, M the
sent message, and M∗ is a sequence of messages denoting
local state information associated with the event. For Recv, A
denotes the agent executing the receive and M the received
message. For Claim, A denotes the agent making the claim
and M the claim itself. A trace tr is a sequence of timed
events (t, EV ) with t ∈ R.
Initial knowledge: To model initial key distributions,
we deﬁne the functions pk : Agent → Key, sk : Agent → Key,
and K : Agent × Agent → Key that denote the public, secret,
and shared keys of agents with the expected properties, e. g.,
−1 = sk(A) and K(A, B) =K( B, A). We deﬁne the
pk(A)
initial knowledge of an agent A as

IKA = Agent ∪ Const ∪ NonceA ∪ {0}

∪ {sk(A)} ∪ {pk(B) | B ∈ Agent}
∪ {K(A, B) | B ∈ Agent}.

Message deduction: Let A be an agent and let tr be
a trace. Then the set DMA(tr) of deducible messages is
the least set closed under the rules in Figure 9. The rules
model message manipulations under the perfect cryptography
assumption, and are all considered modulo E.

Network and Attacker: The set of possible traces TR for
the basic model is deﬁned as the least set closed under the
START-rule, the attacker rule INTR, and the basic network
rule BASICNET2 given in Figure 10 and the rules formalizing
the analyzed protocol. For an example of protocol rules, see
Figure 12. All rules have the implicit side condition that
timestamps are monotonous, i. e., the timestamp of a newly

2Note that this rule is called NET in [3].

∀ X ∈ components(M ).

∃ t(cid:2) A L M(cid:2) Y ∈ components(M(cid:2)

)[L]) ∈ tr

(t(cid:2), SendA(M(cid:2)
∧ X ⊕ Y ∈ LHW
∧ t ≥ t(cid:2)

+ cdistLoS(A, B)

tr · (t, RecvB(M )) ∈ TRP

).

EXTNET

Figure 11. The new network rule for the extended model.

added event cannot be smaller than the maximal timestamp
in the trace. The INTR rule allows dishonest agents to send
arbitrary deducible messages. The BASICNET rule formalizes
that if there is a message M that has been sent by an agent
A, then B can receive the message at time t if t ≥ t(cid:2)
+
cdistLoS(A, B).

Given a set of traces of a protocol for a model, we can

deﬁne when a protocol is secure.
Deﬁnition 5. A distance bounding protocol is secure if all
claims (V, P, dist) that occur in traces of the protocol are
valid, i. e., they agree with locV and locP . Here, we account
for the fact that we allow dishonest nodes to share key
material and therefore identify all dishonest agents, i. e., a
claim (V, P, dist) for dishonest P is valid if there is some
dishonest P (cid:2) such that dist is an upper bound on the distance
between V and P (cid:2).
B. Extended model

The network rule BASICNET from [3] does not account
for message manipulation on the wireless channel. As a
result, several attacks from the previous sections (e. g., the
attack in Example 3) cannot be reproduced in the basic
model. We deﬁne our extended model by replacing the
network rule BASICNET by a new rule EXTNET, shown
in Figure 11, that allows for a more ﬁne-grained model of
message manipulation.

We start from the observation that the BASICNET rule
does not account for the ability of an attacker to overshadow
parts of a message. Overshadowing can be used to replace

121

components in pairs with known messages or to transform
an (unknown) message M into an (unknown) message M(cid:2)
if M and M(cid:2) differ only in a few bits.

In the context of a model where signals traverse distances,
as required for modeling distance bounding protocols, an
attacker that is far from a receiver (e. g., the veriﬁer) may
want to use overshadowing to modify the message M of a
sender (e. g., the prover) that is close to the intended recipient
into a message M(cid:2). Let t be the time at which the sender
sends the message M. Because the attacker is further away,
the attacker needs to send the overshadowing bits (M ⊕ M(cid:2))
at time t(cid:2), where t(cid:2) < t, to ensure that they arrive at the
same time at the receiver. If the attacker knows the (parts of
the) message that he wants the recipient to receive, this is
straightforward. However, if the attacker does not know the
message M yet at time t(cid:2) and requires the message M to
compute M(cid:2), he needs to guess the positions where M and
M(cid:2) differ, then guess the bits of M(cid:2) on these positions, and
ﬁnally overshadow M on these positions with the guessed
bits. We assume that guessing many of the bits of M correctly
can only be done with negligible probability. Subsequently,
the attacker can transform M into M(cid:2) with non-negligible
probability if and only if the Hamming distance between M
and M(cid:2) is small.

To account for these manipulations, we require two
deﬁnitions. First, the components of a message M are deﬁned
as components(M ) = components(M1) ∪ components(M2)
if M = (cid:4)M1, M2(cid:5) and components(M ) = {M} otherwise.
Second, the set LHW of messages that may have a low
Hamming weight is deﬁned as

L, L(cid:2)

::= latom | L ⊕ L(cid:2) | 0

where latom = Agent ∪ Const. This excludes nonces, keys,
hashes, encryptions, and the exclusive-or of such messages
since the probability that these have a low Hamming weight
can be assumed to be negligible, unless such a message
cancels itself out. We do not include pairs of low Hamming
weight messages since we already allow the attacker to
modify components of pairs individually.

Our new network rule EXTNET is shown in Figure 11.
According to the rule, an agent B can receive a message M
if for all components X of M, there is a corresponding send
event (with compatible timestamp) of a message M(cid:2) such
that M(cid:2) has a component Y with a low Hamming distance
to X, i. e., the Hamming weight of X ⊕ Y is low.
Example 5. We assume that the attacker does not know
NV and NP. To overshadow NP with NI in the message
(cid:4)NV , NP(cid:5) sent by an honest P , the attacker has to send
NI (early enough) such that both sends together result in a
receive of (cid:4)NV , NI(cid:5).
In Example 3, the attacker overshadows some bits to
transform the (unknown) message NV ⊕ NP ⊕ P into the
(unknown) message NV ⊕ NP ⊕ P (cid:2). In our model, the

tr ∈ TR P ∈ Honest

NP ∈ (NonceP \ subterms(tr))

tr · (t, SendP (h(NP ))[P1, NP ]) ∈ TR

PROVCOM

tr ∈ TR V ∈ Honest
(t, RecvV (COM )) ∈ tr

NV ∈ (NonceV \ subterms(tr))

tr · (t, SendV (NV )[V1, COM , NV ]) ∈ TR

VERCHAL

tr ∈ TR P ∈ Honest
(t, RecvP (NV )) ∈ tr
tr · (t, SendP (NV ⊕ N P )[P2, NP , NV ]) ∈ TR

(t, SendP (X)[P1, NP ]) ∈ tr

PROVRESP

tr ∈ TR P ∈ Honest

(t, SendP (X)[P2, NP , NV ]) ∈ tr

tr · (t, SendP (signP (NV , NP , P ))[]) ∈ TR

PROVAUTH

tr ∈ TR V ∈ Honest

(tchal , SendV (NV )[V1, h(NP ), NV ]) ∈ tr
(tauth , RecvV (signP (NV , NP , P ))) ∈ tr

(tresp, RecvV (NV ⊕ NP )) ∈ tr

tr · (t, ClaimV (V, P, (tresp − tchal ) ∗ c/2)) ∈ TR

VERRESP

Figure 12. Formalization of the Brands-Chaum Protocol.

attacker does not have to perform any action since (NV ⊕
) ⊕ (NV ⊕ NP ⊕ P ) =P ⊕ P (cid:2) ∈ LHW. This
NP ⊕ P (cid:2)
captures the intuition that allowing the attacker to ﬂip some
bits of unknown messages is equivalent to allowing for some
bit-errors introduced by the wireless channel.

The set of possible traces TR for our extended model is
deﬁned as the least set closed under the START-rule, the
attacker rule INTR, the extended network rule EXTNET, and
the rules formalizing the analyzed protocol.

Protocol Formalization: We formalize the original
signature-based version of the Brands-Chaum by the rules
in Figure 12. Pi and Vi are constants used in the local
state of the veriﬁer and prover in step i. The rules ensure
that the previous steps have been executed, the required
messages have been received, and nonces are freshly chosen
(not subterm of the trace tr). The ﬁnal rule VERRESP uses
the times when the challenge was sent and the time when the
reply was received to compute an upper bound on the distance
between P and V . We refer the reader to [3] to further details
on modeling protocols in this kind of framework.

Case studies: We have analyzed the Brands-Chaum
protocol and its various ﬁxes in our extended framework. For
example, we have proven that if we modify Brands-Chaum
to include explicit linking, the Distance Hijacking attack is
no longer possible. Note that for proving the correctness of
the version with implicit linking, we need the assumption

122

they
that veriﬁers cannot receive the bits/message that
sent themselves, e. g., because different channels are used.
Without this assumption, Brands-Chaum is vulnerable to
Distance Fraud attacks (by reﬂection or using low Hamming
weight overshadowing). As another example, our extended
framework also reveals that modifying the response to
NV ⊕ NP ⊕ P is not secure since the attack from Example 3
is captured. Note that in the basic framework from [3], which
did not account for message manipulation on the wireless
channel, this attack was not captured and a security proof
was possible. This clearly shows the effect of the adversary’s
additional powers in our extended model.

For a complete description of our case studies and their

formalization we refer the reader to [26].

VI. MULTI-PROTOCOL ENVIRONMENTS

So far, we discussed Distance Hijacking attacks in single-
protocol environments, where both dishonest and honest
prover run the same distance bounding protocol. However, it
is possible that veriﬁer-prover pairs execute different ranging
and distance bounding protocols, for example when they
belong to different domains. We call such environments
multi-protocol environments.

Distance Hijacking in Multi-protocol Environments: In
what follows we show that there are plausible multi-protocol
environments in which protocols that are resilient to Distance
Hijacking in single-protocol environments become vulnerable
again to Distance Hijacking.

We deﬁne a multi-protocol environment MPE as a set
of triplets, where a triplet (A, B, R) denotes that agent A
may execute the protocol role R (e. g., the prover role of
the Brands and Chaum protocol) when communicating with
B, and where at least two different protocols are contained
in the set. We say that a distance bounding protocol DB is
vulnerable to a Distance Hijacking Attack in a multi-protocol
environment MPE if a dishonest prover P can perform a
successful Distance Hijacking attack against a veriﬁer V
running DB in the veriﬁer role in that environment (and
hence (V, P, DB (veriﬁer)) ∈ MPE ).

It is easy to see that, given any distance bounding protocol,
a multi-protocol environment can be constructed in which this
protocol will be vulnerable to Distance Hijacking attacks. For
example, all distance bounding protocols will be vulnerable
to Distance Hijacking if run in the same environment with
a protocol that uses a similar distance measurement phase,
but that gives a dishonest prover full control over the way
the response bits are computed by the honest prover. This
is not such an unlikely scenario, since it is plausible that in
the same environment in which a veriﬁer and a dishonest
prover run e. g., Hancke and Kuhn, an honest prover runs
an insecure ranging protocol that supports the same type
of distance measurement phase as the Hancke and Kuhn
protocol. This insecure ranging protocol could easily allow
a dishonest prover to set the bits that the honest prover

msc Distance bounding protocol

Prover

P

Veriﬁer

V

NP 0, NP 1 ∈R {0, 1}(cid:2)

V, {NP 0, NP 1, V }kvp

NV ∈R {0, 1}(cid:2)

Rapid bit exchange for i = 1 to l

if N i

V = 0,Ri = N i

P 0

if N i

V = 1,Ri = N i

P 1

N i
V

Ri

Verify that received Ri’s

correspond to NP 0 and NP 1

Figure 13. A Distance Bounding Protocol that enables Distance Hijacking
on Hancke-Kuhn protocol in multi-protocol environments.

uses in the distance measurement phase (e. g., for debugging
purposes). It might also be that this insecure ranging protocol
is simply enabled as a feature for non-critical applications
and therefore coexists with the Hancke and Kuhn protocol
on the devices (and thus shares the same hardware / distance
measurement implementation with the Hancke and Kuhn
protocol). This means that no multi-prover distance bounding
protocol deployments can be guaranteed to be secure unless
additional measures are in place.

In the above example we used an insecure protocol. How-
ever, similar attacks are possible using only protocols that
are secure in single-protocol environments. We show this on
an example of the Hancke-Kuhn distance bounding protocol
from [12]. We construct a multi-protocol environment in
which the veriﬁer runs the Hancke-Kuhn protocol, and the
honest provers support a minor variation of the Hancke-
Kuhn protocol that is secure against Distance Hijacking
in a single-protocol environment. This protocol, shown in
Figure 13, differs from the Hancke and Kuhn protocol in
that the prover does not compute the values of registers NP 0
and NP 1 but that these are computed by the veriﬁer and
sent (conﬁdentially) to the prover. This protocol modiﬁcation
would make sense if one would, e. g., assume that the prover
does not have a good random number generator (e. g., an
RFID tag).

A Distance Hijacking attack in this environment works as
follows. A dishonest prover P initiates the original Hancke
and Kuhn protocol with the veriﬁer V , and derives shared

123

register values with V (for details see Hancke and Kuhn
protocol [12]). P then acts as a veriﬁer and initiates the
modiﬁed Hancke and Kuhn protocol from Figure 13 with the
honest prover P (cid:2). P then provides the register values to P (cid:2)
as speciﬁed in the modiﬁed protocol. V and P (cid:2) then execute
a rapid bit exchange and V believes that this exchange was
executed by P .

Observe that the attack does not require the two protocols
to share the same long-term keys: V veriﬁes the use of the
key as prescribed by the Hancke and Kuhn protocol, which
was provided by P , and remains unknown to P (cid:2). However,
the attack strictly requires V and P (cid:2) to use similar hardware
for the fast response phase.

Similarly, a modiﬁed version of the Brands and Chaum
protocol can be constructed that, if run next to the Hancke and
Kuhn protocol, would also enable a Distance Hijacking attack
against the Hancke and Kuhn protocol. This phenomenon
is similar to the Chosen Protocol attack in cryptographic
protocol analysis. We relate the two concepts in Section VIII.
Protecting against Distance Hijacking in Multi-Protocol
Environments: Previously, we proposed countermeasures that
prevent Distance Hijacking in single-protocol environments.
We now discuss some approaches that can mitigate such
attacks in multi-protocol environments.

For multi-protocol environments the obvious solution is to
try to ensure that all protocols in an environment use different
(incompatible) hardware for their distance measurement
phase. This is analoguous to the concepts of tagging or
disjoint encryption for classical cryptographic protocols. Thus,
attacks in multi-protocol environments can be prevented by
better regulation in distance bounding protocol deployment
and construction. Minor application-speciﬁc modiﬁcations to
the distance measurement phase (e. g., including application-
speciﬁc dummy bits) would already prevent a number
of attacks. Similarly, manufacturer-speciﬁc or deployment
speciﬁc hardware modiﬁcations would also protect against
multi-protocol attacks; this can, however, be expensive.

There are a number of scenarios in which such deploy-
ment and regulatory protection measures cannot be used.
Application-speciﬁc modiﬁcations of the distance measure-
ment phase are particularly difﬁcult to implement; given the
tight timing constraints in the distance measurement phase,
this phase will be processed in hardware. It is also likely
that only a few implementations of the distance measurement
phase will emerge in the future, limiting available application-
speciﬁc modiﬁcations of this phase. This ﬁnally means that
most distance bounding protocols will likely use the same
implementation of the distance measurement phase.

Accounting for these scenarios, we propose an alternative
solution that makes use of “prover honeypots”. Recall that to
execute a Distance Hijacking attack, a dishonest prover either
needs to be able to successfully claim to have executed a
distance measurement phase that was executed by an honest
prover, or needs to make an honest prover execute a distance

measurement phase using speciﬁc bits. The prevention of
the false distance measurement claim naturally extends from
single- to multi-protocol environments — this type of attack
can be prevented by using protocols that are resilient to
Distance Hijacking in single-protocol environments. However,
as we have shown, protocols that are resilient to Distance
Hijacking in single-protocol environments cannot prevent
attacks in a multi-protocol environment where an honest
prover is made to execute a distance measurement phase
using the bits provided by a dishonest prover. We aim to
detect such attacks by the use of prover honeypots.

Our solution works as follows. The veriﬁer ﬁrst sets up a
number of virtual or real honeypot provers which are either
physical or virtual devices that are placed in the vicinity of
the veriﬁer. These honeypot provers are created either by the
veriﬁer or by the devices that the veriﬁer trusts and controls.
To other provers, honeypot provers claim either their true
or false locations/identities, and they support a broad set of
ranging and distance bounding protocols. The idea behind
this setting is that when a dishonest prover mounts a Distance
Hijacking attack, it chooses one of the honeypot provers to
abuse in his attack. Besides setting up honeypot provers, the
veriﬁer also limits its operation to speciﬁc distance bounding
protocols: it executes only distance bounding protocols that
force a dishonest prover to reveal (most of the bits of) its
secret key (that it shares with the veriﬁer) to the honest prover
if he wants to execute a Distance Hijacking attack. This is
commonly the case for protocols that are resilient against
Terrorist Fraud. Thus, if a dishonest prover exploits one of
the honeypots in a Distance Hijacking attack, the (majority
of the) bits of the key that it shares with the veriﬁer will
be revealed to the honeypot prover. For the case in which
the prover wants to be certain about the success of Distance
Hijacking, all of the bits of his key will be revealed to the
honeypot. In order to check if a Distance Hijacking attack
was executed, the veriﬁer, after the execution of a distance
bounding protocol with a given prover, simply needs to ask
his honeypot provers to send him the bits that they used in
any recent distance measurement phase. If those bits allow
the reconstruction of the (majority of the bits of the) key that
the veriﬁer shares with the prover [14], the veriﬁer concludes
that the prover attempted to execute a Distance Hijacking
attack.

VII. LOCATION HIJACKING

In this section we generalize Distance Hijacking to
Location Hijacking. We consider the problem of location
veriﬁcation, or position veriﬁcation, in which a set of veriﬁers
establishes the location of a prover, even though this prover
may act dishonestly, i. e., the prover can pretend to be at
another location than he really is. The objective of a location
veriﬁcation protocol is to ensure that the location of the
prover is reliably determined. Such protocols often build
on distance bounding protocols. A prover repeatedly uses a

124

a number of veriﬁers. The prover aggregates the challenges
and broadcasts his response to all veriﬁers. This many-to-
one challenge response then constitutes one round of the
underlying distance bounding protocol, which in this case
is Brands and Chaum’s original suggestion [4]. The authors
present a proof that their scheme is optimal in the sense that
it achieves the “maximal security” any location veriﬁcation
schemes based solely on time-of-ﬂight can provide.

Despite the proof, this scheme is vulnerable to Location
Hijacking (Figure 14). The proof in [6] establishes that a
prover must be at the claimed location (within some accuracy)
in order to correctly reply to the challenges. The proof
however, does not address the authentication of the node at the
claimed location but instead leaves that up to the underlying
distance bounding protocol. Since the underlying distance
bounding protocol is vulnerable to Distance Hijacking, the
location veriﬁcation protocol inherits this vulnerability. In
this case it is possible that another distance bounding protocol
could be used instead of Brands and Chaum, in order to
achieve a secure scheme, but this example shows that even
recent location veriﬁcation schemes with proofs of optimal
security, can be vulnerable to Location Hijacking.

VIII. RELATED WORK

Distance bounding for RFID tags: Avoine et al. present
in [1] a framework for analyzing RFID distance bounding
protocols. They give deﬁnitions for the three main attack
types, and also deﬁne Impersonation Fraud, in which “a
lonely prover purports to be another one” [1, p. 5], i. e., a
violation of weak authentication. They consider these four
types of attack with respect to black-box and white-box
provers, yielding a total of eight security notions. None of
their models covers Distance Hijacking attacks.

D¨urholz et al. propose in [10] the ﬁrst computational
formal framework for proving properties of RFID distance
bounding protocols that are based on shared symmetric keys.
Their framework considers an attacker that interacts only
with a single prover (the tag) and single veriﬁer (the reader).
Consequently, proving that an RFID protocol is secure in
their framework does not guarantee the absence of Distance
Hijacking attacks.

Formal models for distance bounding: Meadows et al.
developed a formal methodology to prove properties of
distance bounding protocols [18]. Because the methodology
is not particularly suited for dealing with dishonest provers,
they did not consider scenarios that would allow them to
detect Distance Hijacking attacks.

The ﬁrst two formal approaches for distance bounding
protocols that have considered multi-prover scenarios and
dishonest provers are Malladi et al. [25] and Basin et al.
[3]. Malladi et al. propose a tool-supported framework for
analyzing distance bounding protocols, and model a variant
of the ﬁrst signature-based protocol by Brands and Chaum.
They analyze this protocol in several scenarios and ﬁnd an

Figure 14.
Location Veriﬁcation
and Location Hijacking: P hijacks
the location of P (cid:2), for example by
hijacking the distance bounding pro-
tocol instances of P (cid:2) with respect to
the veriﬁers.

Figure 15.
Location Hijacking to
empty location: When asked to prove
his location to the veriﬁers, P hijacks
P1’s distance for V1, P2’s distance
for V2, and P3’s distance for V3. The
veriﬁers conclude that P is at the
location indicated by the arrow.

distance bounding protocol to prove his proximity to a set of
veriﬁers. Based on the combined information, the veriﬁers
are able to verify the location of the prover.

This process is depicted in Figure 14. The circles represent
the measured distances by the veriﬁers V1, V2, V3, and they
conclude that P (cid:2) must be located in the intersection. If a
dishonest prover P can hijack distance bounding sessions of
a party P (cid:2), he can pretend to be at the location where P (cid:2)
resides, regardless of his actual location. This constitutes a
Location Hijacking attack: a dishonest prover can hijack the
location of P (cid:2).
Deﬁnition 6. Location Hijacking attack. A Location Hi-
jacking attack is an attack in which a dishonest prover P
exploits one or more honest parties P1, . . . , Pn to provide a
set of veriﬁers V1, . . . , Vk with false information about the
location of P (either absolute or relative to the location of
the veriﬁers).

The threat of hijacking is magniﬁed in the context of
location veriﬁcation, because multiple distance bounding
results are combined. For example, consider the setup in
Figure 15, in which three honest provers P1, P2, and P3 are
within range of the veriﬁers. As before, a dishonest prover can
perform Distance Hijacking attacks on the distance bounding
phases, thereby hijacking the location of P1, P2, or P3 as he
chooses. However, he can also combine Distance Hijacking
attacks with respect to multiple honest provers: this allows
him to make his location appear to be at any intersection
of the distances of a set of honest provers. For example, in
Figure 15, he can convince the veriﬁers that he is located
at the position indicated by the arrow, by combining the
distance bounding phases of the honest provers, even though
nobody is present at this location.

Case Study of Location Hijacking: To emphasize that
Location Hijacking is indeed a relevant problem, even on
recent protocols, we give a brief case study of a recent
protocol by Chiang et al. [6] that is vulnerable to Location
Hijacking. In this protocol a prover sends out a location
claim, after which he receives simultaneous challenges from

125

attack that falls into our class. In their “farther adversary”
scenario, the attacker is farther from the veriﬁer than the
reported distance. This suggests that the “farther adversary”
scenario covers both Distance Fraud and Distance Hijacking.
However, this observation is not consistent with Malladi
et al.’s statement that including the identity in the signature
makes the protocol secure in the “farther adversary” scenario.
From our analysis it is clear that the resulting protocol will
still be vulnerable to Distance Hijacking.

Basin et al. proposed in [3] the basic framework that we
have used here as a starting point for our extended model.
Basin et al. analyze a family of distance bounding protocols
proposed by Meadows et al. in [18] and ﬁnd an attack that
falls into our class of Distance Hijacking attacks, which
they refer to as an “impersonation attack”. They prove that
a concatenation-based version of the protocol is secure in
their framework. This protocol is not secure in our extended
framework, as the protocol is still vulnerable to a Distance
Hijacking attack that uses overshadowing.

Chosen Protocol attack: The multi-protocol Distance
Hijacking attack described in Section VI resembles the
Chosen Protocol (or Multi-Protocol) attack in cryptographic
protocol analysis, which was introduced by Kelsey, Schneier,
and Wagner [13]. They describe how, given any secure
cryptographic protocol, a second protocol can be constructed
(“chosen”) that is also secure, but when both are executed
in parallel, an attacker can use the second protocol to attack
the ﬁrst. Chosen Protocol attacks are an instance of Multi-
Protocol attacks [7]. In a traditional (Dolev-Yao style) setting,
Multi-Protocol attacks require that both protocols use the
same key infrastructure, in which case many protocols are
vulnerable [7]. Ensuring that the protocols use different keys
prevents the problem [11], which is often guaranteed in
practice. The practical threat of multi-protocol attacks in the
Dolev-Yao setting is therefore limited.

In contrast, our multi-protocol Distance Hijacking attacks
do not require that keys are shared among protocols. Rather,
the distance measurement phase must be regarded as a
security primitive, and care must be taken when security
primitives are shared among protocols. If not, unexpected
interactions can occur, as witnessed by our attacks. In practice,
multi-protocol Distance Hijacking poses a more signiﬁcant
threat
than Chosen Protocol attacks, because it can be
expected that only a few different hardware components
for distance measurement will be manufactured, which may
be used by a large number of different protocols.

IX. CONCLUSIONS

In many practical scenarios, including scenarios in which
Terrorist Fraud attacks are not a concern, Distance Hijacking
attacks can pose a serious threat. Surprisingly, until now, this
type of attack was not considered in the analysis of proposed
distance bounding protocols.

In fact, our analysis shows that many distance bounding
protocols cannot be safely used in scenarios with multiple
provers. Fortunately, it seems that adapting the protocols to be
resilient against these attacks is possible in single-protocol en-
vironments without imposing a signiﬁcant overhead. Similar
observations can be made for location veriﬁcation protocols
with respect to Location Hijacking attacks.

We introduced an extended framework to reason about
distance bounding protocols in a symbolic way, which at
the same time incorporates bit-level message manipulations
by the attacker. The results of this hybrid approach have
thus far been promising. The framework enables us to detect
more attacks than previous frameworks, including Distance
Hijacking attacks, and also allows us to prove the absence
of the attacks we found.

We proposed an exhaustive classiﬁcation of attacks on
distance bounding protocols. In this context, we also proposed
new names and deﬁnitions for the three classical attack types.
Our new attack names are less generic and more descriptive
than the previous names. We hope that
the exhaustive
classiﬁcation has a positive effect on the systematic analysis
of threats against distance bounding protocols.

It is clear that secure functioning in a context with multiple
provers is a desirable feature, giving an edge to those
protocols that are resilient against Distance Hijacking attacks.
It seems therefore prudent to analyze new proposals for
distance bounding protocols for their vulnerability to Distance
Hijacking.

REFERENCES

[1] G. Avoine, M. A. Bing¨ol, S. Kardas¸, C. Lauradoux, and
B. Martin. A Framework for Analyzing RFID Distance
Bounding Protocols. Journal of Computer Security – Special
Issue on RFID System Security, 2010.

[2] G. Avoine and A. Tchamkerten. An efﬁcient distance bounding
RFID authentication protocol: Balancing false-acceptance
rate and memory requirement. In Proceedings of the 12th
International Conference on Information Security, ISC ’09,
pages 250–261. Springer, 2009.

[3] D. Basin, S. ˇCapkun, P. Schaller, and B. Schmidt. Let’s
get physical: Models and methods for real-world security
protocols. In Proceedings of the 22nd International Conference
on Theorem Proving in Higher Order Logics, TPHOLs ’09,
pages 1–22. Springer, 2009.

[4] S. Brands and D. Chaum. Distance-bounding protocols. In
Advances in Cryptology - EUROCRYPT ’93, volume 765 of
LNCS, pages 344–359. Springer, 1994.

[5] L. Bussard and W. Bagga. Distance-bounding proof of
knowledge to avoid real-time attacks. In Security and Privacy
in the Age of Ubiquitous Computing, volume 181 of IFIP
Advances in Information and Communication Technology,
pages 223–238. Springer Boston, 2005.

126

[19] J. Munilla and A. Peinado. Distance bounding protocols
for RFID enhanced by using void-challenges and analysis in
noisy channels. Wirel. Commun. Mob. Comput., 8:1227–1232,
November 2008.

[20] P. Peris-Lopez, J. C. H. Castro, J. M. Est´evez-Tapiador, and
J. C. A. van der Lubbe. Shedding some light on RFID distance
bounding protocols and terrorist attacks. CoRR, abs/0906.4618,
2009.

[21] P. Peris-Lopez, J. Hernandez-Castro, J. Tapiador, E. Palomar,
and J. van der Lubbe. Cryptographic puzzles and distance-
bounding protocols: Practical tools for RFID security. In RFID,
2010 IEEE International Conference on, pages 45–52, 2010.

[22] C. P¨opper, N. O. Tippenhauer, B. Danev, and S. ˇCapkun.
Investigation of signal and message manipulations on the
wireless channel.
In ESORICS 2011 - 16th European
Symposium on Research in Computer Security. Proceedings,
volume 6879 of LNCS, pages 40–59. Springer, 2011.

[23] K. B. Rasmussen and S. ˇCapkun. Realization of RF distance
bounding. In USENIX Security 2010: Proceedings of the 19th
USENIX Security Symposium. USENIX, 2010.

[24] J. Reid, J. M. G. Nieto, T. Tang, and B. Senadji. Detecting
In Proceedings
relay attacks with timing-based protocols.
of the 2nd ACM symposium on Information, computer and
communications security, ASIACCS ’07, pages 204–213.
ACM, 2007.

[25] B. B. S. Malladi and K. Kothapalli. Automatic analysis of
In Foundations of Computer
Informal

distance bounding protocols.
Security. Afﬁliated to LICS09, August 2009.
proceedings.

[26] B. Schmidt. Isabelle/HOL sources for the extended framework,
models, and proofs. Available online at http://www.infsec.ethz.
ch/research/software#protoveriphy.

[27] D. Singel´ee and B. Preneel. Distance bounding in noisy
environments. In Proceedings of the 4th European conference
on Security and privacy in ad-hoc and sensor networks,
ESAS’07, pages 101–115. Springer, 2007.

[28] R. Trujillo-Rasua, B. Martin, and G. Avoine. The Poulidor
distance-bounding protocol.
the 6th
international conference on Radio frequency identiﬁcation:
security and privacy issues, RFIDSec’10, pages 239–257.
Springer, 2010.

In Proceedings of

[29] S. ˇCapkun, L. Butty´an, and J.-P. Hubaux. SECTOR: secure
tracking of node encounters in multi-hop wireless networks.
In Proceedings of the 1st ACM workshop on Security of ad
hoc and sensor networks, SASN ’03, pages 21–32. ACM,
2003.

[30] S. ˇCapkun and M. ˇCagalj. Integrity regions: authentication
through presence in wireless networks. In ACM workshop on
Wireless security, pages 1–10. ACM, 2006.

[6] J. T. Chiang, J. J. Haas, and Y.-C. Hu. Secure and precise
location veriﬁcation using distance bounding and simultaneous
multilateration. In Proceedings of the second ACM conference
on Wireless network security, WiSec ’09, pages 181–192.
ACM, 2009.

[7] C. Cremers. Feasibility of multi-protocol attacks. In Proc. of
The First International Conference on Availability, Reliability
and Security (ARES), pages 287–294, Vienna, Austria, April
2006. IEEE Computer Society.

[8] Y. Desmedt. Major security problems with the ‘unforgeable’
(Feige)-Fiat-Shamir proofs of identity and how to overcome
them.
In Proceedings of the 6th worldwide congress on
computer and communications security and protection (Se-
curiCom), pages 147–159, March 1988.

[9] S. Drimer and S. J. Murdoch. Keep your enemies close:
Distance bounding against smartcard relay attacks. In USENIX
Security 2007: Proceedings of the 19th USENIX Security
Symposium, 2007.

[10] U. Duerholz, M. Fischlin, M. Kasper, and C. Onete. A formal
approach to distance-bounding RFID protocols. In Information
Security Conference (ISC) 2011, LNCS, 2011. To appear.

[11] J. Guttman and F. Thayer. Protocol independence through
disjoint encryption. In Proc. 13th IEEE Computer Security
Foundations Workshop (CSFW), pages 24–34. IEEE Computer
Society, 2000.

[12] G. Hancke and M. Kuhn. An RFID distance bounding protocol.
In Proc. of IEEE/CreatNet SecureComm, pages 67–73, 2005.

[13] J. Kelsey, B. Schneier, and D. Wagner. Protocol interactions
and the chosen protocol attack. In Proc. 5th International
Workshop on Security Protocols, volume 1361 of LNCS, pages
91–104. Springer, 1997.

[14] C. Kim, G. Avoine, F. Koeune, F.-X. Standaert, and O. Pereira.
The Swiss-Knife RFID distance bounding protocol.
In
Information Security and Cryptology ICISC 2008, volume
5461 of Lecture Notes in Computer Science, pages 98–115.
Springer, 2009.

[15] C. H. Kim and G. Avoine. RFID distance bounding protocol
with mixed challenges to prevent relay attacks. In Proceedings
of the 8th International Conference on Cryptology and Network
Security, CANS ’09, pages 119–133. Springer, 2009.

[16] M. Kuhn, H. Luecken, and N. O. Tippenhauer. UWB impulse
radio based distance bounding. In Proceedings of the Workshop
on Positioning, Navigation and Communication (WPNC),
2010.

[17] G. Lowe. A hierarchy of authentication speciﬁcations.

In
Proc. 10th IEEE Computer Security Foundations Workshop
(CSFW), pages 31–44. IEEE, 1997.

[18] C. Meadows, R. Poovendran, D. Pavlovic, L. Chang, and
P. Syverson. Distance bounding protocols: Authentication
logic analysis and collusion attacks. In Secure Localization
and Time Synchronization for Wireless Sensor and Ad Hoc
Networks, volume 30 of Advances in Information Security,
pages 279–298. Springer US, 2007.

127

