Boxify: Full-fledged App Sandboxing  

for Stock Android

Michael Backes, Saarland University and Max Planck Institute for  

Software Systems (MPI-SWS); Sven Bugiel, Christian Hammer, Oliver Schranz,  

and Philipp von Styp-Rekowsky, Saarland University

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/backes

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXBoxify: Full-ﬂedged App Sandboxing for Stock Android

Michael Backes

CISPA, Saarland University & MPI-SWS

backes@cs.uni-saarland.de

Sven Bugiel

CISPA, Saarland University
bugiel@cs.uni-saarland.de

Christian Hammer

CISPA, Saarland University
hammer@cs.uni-saarland.de

Oliver Schranz

CISPA, Saarland University
schranz@cs.uni-saarland.de

Philipp von Styp-Rekowsky

CISPA, Saarland University

styp-rekowsky@cs.uni-saarland.de

Abstract

We present the ﬁrst concept for full-ﬂedged app
sandboxing on stock Android. Our approach is based
on application virtualization and process-based priv-
ilege separation to securely encapsulate untrusted
apps in an isolated environment. In contrast to all
related work on stock Android, we eliminate the ne-
cessity to modify the code of monitored apps, and
thereby overcome existing legal concerns and deploy-
ment problems that rewriting-based approaches have
been facing. We realize our concept as a regular An-
droid app called Boxify that can be deployed without
ﬁrmware modiﬁcations or root privileges. A system-
atic evaluation of Boxify demonstrates its capability
to enforce established security policies without incur-
ring a signiﬁcant runtime performance overhead.

1 Introduction
Security research of the past ﬁve years has shown that
the privacy of smartphone users—and in particular of
Android OS users, due to Android’s popularity and
open-source mindset—is jeopardized by a number
of diﬀerent threats. Those include increasingly so-
phisticated malware and spyware [63, 39, 62], overly
curious libraries [25, 32], but also developer negli-
gence and absence of fail-safe defaults in the Android
SDK [33, 29]. To remedy this situation, the develop-
ment of new ways to protect the end-users’ privacy
has been an active topic of Android security research
during the last years.
Status quo of deploying Android security ex-
tensions. From a deployment perspective, the pro-
posed solutions followed two major directions: The
majority of the solutions [26, 44, 45, 16, 21, 64, 52, 56]
extended the UID-centered security architecture of
Android.
In contrast, a number of solutions [38,
59, 23, 49, 22, 15] promote inlined reference moni-

toring (IRM) [28] as an alternative approach that
integrates security policy enforcement directly into
Android’s application layer, i.e., the apps’ code.

However, this dichotomy is unsatisfactory for end-
users: While OS security extensions provide stronger
security guarantees and are preferable in the long run,
they require extensive modiﬁcations to the operating
system and Android application framework. Since
the proposed solutions are rarely adopted [54, 53] by
Google or the device vendors, users have to resort to
customized aftermarket ﬁrmware [4, 6] if they wish
to deploy new security extensions on their devices.
However, installing a ﬁrmware forms a technological
barrier for most users. In addition, fragmentation of
the Android ecosystem [46] and vendor customiza-
tions impede the provisioning of custom-built ROMs
for all possible device conﬁgurations in the wild.

In contrast, solutions that rely on inlined reference
monitoring avoid this deployment problem by mov-
ing the reference monitor to the application layer
and allowing users to install security extensions in
the form of apps. However, the currently available
solutions provide only insuﬃcient app sandboxing
functionality [36] as the reference monitor and the
untrusted application share the same process space.
Hence, they lack the strong isolation that would
ensure tamper-protection and non-bypassability of
the reference monitor. Moreover, inlining reference
monitors requires modiﬁcation and hence re-signing
of applications, which violates Android’s signature-
based same-origin model and puts these solutions
into a legal gray area.

The sweet spot. The envisioned app sandboxing
solution provides immediate strong privacy protec-
tion against rogue applications. It would combine the
security guarantees of OS security extensions with
the deployability of IRM solutions, while simultane-
ously avoiding their respective drawbacks. Eﬀectively,

USENIX Association  

24th USENIX Security Symposium  691

such a solution would provide an OS-isolated refer-
ence monitor that can be deployed entirely as an
app on stock Android without modiﬁcations to the
ﬁrmware or code of the monitored applications.
Our contributions.
In this paper we present a
novel concept for Android app sandboxing based on
app virtualization, which provides tamper-protected
reference monitoring without ﬁrmware alterations,
root privileges or modiﬁcations of apps. The key idea
of our approach is to encapsulate untrusted apps in a
restricted execution environment within the context
of another, trusted sandbox application. To establish
a restricted execution environment, we leverage An-
droid’s “isolated process” feature, which allows apps
to totally de-privilege selected components—a fea-
ture that has so far received little attention beyond
the web browser. By loading untrusted apps into a
de-privileged, isolated process, we shift the problem
of sandboxing the untrusted apps from revoking their
privileges to granting their I/O operations whenever
the policy explicitly allows them. The I/O opera-
tions in question are syscalls (to access the ﬁle system,
network sockets, bluetooth, and other low-level re-
sources) and the Binder IPC kernel module (to access
the application framework). We introduce a novel
app virtualization environment that proxies all syscall
and Binder channels of isolated apps. By intercepting
any interaction between the app and the system (i.e.,
kernel and app framework), our solution is able to en-
force established and new privacy-protecting policies.
Additionally, it is carefully crafted to be transparent
to the encapsulated app in order to keep the app
agnostic about the sandbox and retain compatibility
to the regular Android execution environment. By
executing the untrusted code as a de-privileged pro-
cess with a UID that diﬀers from the sandbox app’s
UID, the kernel securely and automatically isolates
at process-level the reference monitor implemented
by the sandbox app from the untrusted processes.
Technically, we build on techniques that were found
successful in related work (e.g., libc hooking [59])
while introducing new techniques such as Binder IPC
redirection through ServiceManager hooking. We re-
alize our concept as a regular app called Boxify that
can be deployed on stock Android. To the best of our
knowledge, Boxify is the ﬁrst solution to introduce
application virtualization to stock Android.
In summary, we make the following contributions:

1. We present a novel concept for application virtual-
ization on Android that leverages the security pro-
vided by isolated processes to securely encapsulate
untrusted apps in a completely de-privileged exe-
cution environment within the context of a regular

Android app. To retain compatibility of isolated
apps with the standard Android app runtime, we
solved the key technical challenge of designing and
implementing an eﬃcient app virtualization layer.
2. We realize our concept as an app called Boxify,
which is the ﬁrst solution that ports app virtual-
ization to the Android OS. Boxify is deployable
as a regular app on stock Android (no ﬁrmware
modiﬁcation and no root privileges required) and
avoids the need to modify sandboxed apps.

3. We systematically evaluate the eﬃcacy and eﬃ-
ciency of Boxify from diﬀerent angles including
its security guarantees, diﬀerent use-cases, perfor-
mance penalty, and Android API version depen-
dence across multiple Android OS versions.

The remainder of this paper is structured as follows.
In §2, we provide necessary technical background
information on Android. We deﬁne our objectives
and discuss related work in §3. In §4, we present our
Boxify design and implementation, which we evaluate
in §5. We conclude the paper in §6.

2 Background on Android OS
Android OS is an open-source software stack (see Fig-
ure 1) for mobile devices consisting of a Linux ker-
nel, the Android application framework, and system
apps. The application framework together with the
pre-installed system apps implement the Android
application API. The software stack can be extended
with third-party apps, e.g., from Google Play.
Android Security Model. On Android, each ap-
plication runs in a separate, simple sandboxed envi-
ronment that isolates data and code execution from
other apps. In contrast to traditional desktop operat-
ing systems where applications run with the privileges
of the invoking user, Android assigns a unique Linux
user ID (UID) to every application at installation
time. Based on this UID, the components of the
Android software stack enforce access control rules
that govern the app sandboxing. To understand the
placement of the enforcement points, one has to con-
sider how an app can interact with other apps (and
processes) in the system:

Like any other Linux process, an app process uses
syscalls to the Linux kernel to access low-level re-
sources, such as ﬁles. The kernel enforces discre-
tionary access control (DAC) on such syscalls based
on the UID of the application process. For instance,
each application has a private directory that is not
accessible by other applications and DAC ensures

692  24th USENIX Security Symposium 

USENIX Association

Application Framework

Service / System App
(Platform Permissions)

App (UIDApp)

Components

Native Libs

Binder IPC

Syscall

Binder IPC Module
Linux Kernel

Syscall API
(DAC + MAC)

Figure 1: High-level view of interaction between apps,
application framework, and Linux kernel on Android.

that applications cannot access other apps’ private
directories. Since Android version 4.3 this discre-
tionary access control is complemented with SELinux
mandatory access control (MAC) to harden the sys-
tem against low-level privilege escalation attacks and
to reinforce this UID-based compartmentalization.
The primary channel for inter-application com-
munication is Binder Inter-Process Communica-
tion (IPC). It is the fundamental building block for
a number of more abstract inter-app communica-
tion protocols, most importantly Inter-Component
Communication (ICC) [27] among apps and the ap-
plication framework. For sandboxing applications at
the ICC level, each application UID is associated with
a set of platform permissions, which are checked at
runtime by reference monitors in the system services
and system apps that constitute the app framework
(e.g. LocationService). These reference monitors
rely on the Binder kernel module to provide the UID
of IPC senders to the IPC receivers.

In general, both enforcement points are imple-
mented callee-sided in the framework and kernel,
and hence agnostic to the exact call-site within the
app process. This means that enforcement applies
equally to all code executing in a process under the
app’s UID, i.e., to both Java and native code.

Additionally, Android veriﬁes the integrity of ap-
plication packages during installation based on their
developer signature. The corresponding developer
certiﬁcate is afterwards used to enforce a same-origin
policy for application updates, i.e., newer app ver-
sions must be signed with the same signing key as
the already installed application.
Isolated Process. The Isolated Process, introduced
in Android version 4.1, is a security feature that has
received little attention so far. It allows an app de-
veloper to request that certain service components
within her app should run in a special process that
is isolated from the rest of the system and has no
permissions of its own [2]. The isolated process mech-
anism follows the concept of privilege separation [48],
which allows parts of an application to run at dif-
ferent levels of privilege. It is intended to provide

an additional layer of protection around code that
processes content from untrusted sources and is likely
to have security holes. Currently, this feature is pri-
marily geared towards web browsers [35] and is most
prominently used in the Chrome browser to contain
the impact of bugs in the complex rendering code.
An isolated process has far fewer privileges than a
regular app process. An isolated process runs under
a separate Linux user ID that is randomly assigned
on process startup and diﬀers from any existing UID.
Consequently, the isolated process has no access to
the private app directory of the application. More
precisely, the process’ ﬁlesystem interaction is lim-
ited to reading/writing world readable/writable ﬁles.
Moreover, the isolated process’ access to the An-
droid middleware is severely restricted. The isolated
process runs with no permissions, regardless of the
permissions declared in the manifest of the appli-
cation. More importantly, the isolated process is
forbidden to perform any of the core Android IPC
functions: Sending Intents, starting Activities, bind-
ing to Services or accessing Content Providers. Only
the core middleware services that are essential to
running the service component are accessible to the
isolated process. This eﬀectively bars the process
from any communication with other apps. The only
way to interact with the isolated process from other
application components is through the Service API
(binding and starting). Further, the transient UID of
an isolated process does not belong to any privileged
system groups and the kernel prevents the process
from using low-level device features such as network
communication, bluetooth or external storage. As
of Android v4.3, SELinux reinforces this isolation
through a dedicated process type. With all these
restrictions in place, code running in an isolated pro-
cess has only minimal access to the system, making
it the most restrictive runtime environment Android
has to oﬀer.

3 Requirements Analysis and Exist-

ing Solutions

We ﬁrst brieﬂy formulate our objectives (see §3.1)
and afterwards discuss corresponding related work
(see §3.2 and Table 1).

3.1 Objectives and Threat Model
In this paper, we aim to combine the security beneﬁts
of OS extensions with the deployability beneﬁts of
application layer solutions. We identify the following
objectives:

USENIX Association  

24th USENIX Security Symposium  693

O1 No ﬁrmware modiﬁcation: The

solution
does not rely on or require customized Android
ﬁrmware,
such as extensions to Android’s
middleware, kernel or the default conﬁguration
ﬁles (e.g., policy ﬁles), and is able to run on
stock Android versions. This also excludes
availability of root privileges, since root can only
be acquired through a ﬁrmware modiﬁcation
on newer Android versions due to increasingly
stringent SELinux policies.

O2 No app modiﬁcation: The solution does not
rely on or require any modiﬁcations of monitored
apps’ code, such as rewriting existing code.

O3 Robust reference monitor: The

solution
provides a robust reference monitor. This
encompasses:
1) the presence of a strong
security boundary, such as a process boundary,
between the reference monitor and untrusted
code; and 2) the monitor cannot be bypassed,
e.g., using a code representation that is not
monitored, such as native code.

O4 Secure isolation of untrusted code: This

objective encompasses fail-safe defaults and
complete mediation by the reference monitors.
The solution provides a reference monitor that
mediates all interaction between the untrusted
code and the Android system, or,
in case
no complete mediation can be established,
enforces fail-safe defaults that isolate the app
on non-mediated channels in order to prevent
untrusted code from escalating its privileges.

Threat model. We assume that the Android OS is
trusted, including the Linux kernel and the Android
application framework. This includes the assumption
that an application cannot compromise the integrity
of the kernel or application framework at runtime.
If the kernel or application framework were com-
promised, no security guarantees could be upheld.
Protecting the kernel and framework integrity is an
orthogonal research direction for which diﬀerent ap-
proaches already exist, such as trusted computing,
code hardening, or control ﬂow integrity.

Furthermore, we assume that untrusted third-party
applications have full control over their process and
the associated memory address space. Hence the
attacker can modify its app’s code at runtime, e.g.,
using native code or Java’s reﬂection interface.

3.2 Existing Solutions
We systematically analyze prior solutions on app
sandboxing.

Application Framework

Service / System App
Service / System App
(Platform Permissions)

App (UIDApp)

Components

Native Libs

Binder IPC

Syscall

Binder IPC Module
Linux Kernel

Syscall API
Syscall API
(DAC + MAC)

New Reference Monitor added

Figure 2: Instrumentation points for operating sys-
tem security extensions.

p
p
a

.

p
e
S

M
R
I

.
t
x
e

S
O

y
f
i
x
o
B

Objectives
O1: No system modiﬁcation
O2: No application modiﬁcation
O3: Robust reference monitor
   
O4: Secure isolation of untrusted code    

   

   

= applies; = does not apply.

Table 1: Comparison of deployment options for An-
droid security extensions based on desired objectives.

3.2.1 Android Security Extensions
Many improvements to Android’s security model
have been proposed in the literature, addressing a
variety of shortcomings in protecting the end-user’s
privacy. In terms of deployment options, we can dis-
tinguish between solutions that extend the Android
OS and solutions that operate at the application
layer only.
Operating system extensions. The vast major-
ity of proposals from the literature (e.g. [26, 44, 45,
16, 21, 58]) statically enhance Android’s application
framework and Linux kernel with additional refer-
ence monitors and policy decision points (see Fig-
ure 2). The proposed security models include, for
instance, context-aware policies [21], app developer
policies [45], or Chinese wall policies [16]. More re-
cent approaches [52, 43, 56] avoid static changes to
the OS by dynamically instrumenting core system
services (like Binder and Zygote) or the Android
bootup scripts in order to interpose [47] untrusted
apps’ syscalls and IPC. Since in all approaches the
reference monitors are part of the application frame-
work and kernel, there inherently exists a strong
security boundary between the reference monitor
and untrusted code (O3: ). Moreover, this en-
tails that these reference monitors are by design part
of the callee-side of all interaction of the untrusted
app’s process with the system and cannot be by-

694  24th USENIX Security Symposium 

USENIX Association

Application Framework

Service / System App
(Platform Permissions)

App (UIDApp)

Components
Components

Native Libs
Native Libs

App Framework
Service / System App
(Platform Permissions)

Dr. Android

Ref. Monitor

Zero-Perm App (UIDApp)
Native Libs

Mr. Hide

Binder IPC

Syscall

Binder IPC

Syscall

Binder IPC Module
Linux Kernel

Syscall API
(DAC + MAC)

Rewritten / Reference Monitor added

Binder Module

Linux Kernel

Syscall API
(DAC + MAC)

Rewritten / Reference Monitor added

Figure 3: Instrumentation points for application code
rewriting and inlining reference monitors.

passed (O4: ). On the downside, these solutions
require modiﬁcation of the Android OS (image) or
root privileges to be deployed (O1: ; O2: ).

Additionally, a number of solutions exist that par-
ticularly target higher-security deployments [17, 51,
40, 13], such as government and enterprise. Commer-
cial products exist that implement these solutions
in the form of tailored mobile platforms (e.g., Black-
phone1, GreenHills2, or Cryptophone3). These prod-
ucts target specialized user groups with high security
requirements—not the average consumer—and are
thus deployed on a rather small scale.
Application layer solutions. At the application
layer, the situation for third-party security extensions
is bleak. Android’s UID-based sandboxing mecha-
nism strictly isolates diﬀerent apps installed on the
same device. Android applications run with normal
user privileges and cannot elevate to root in order to
observe the behavior of other apps, e.g., like classical
trace or anti-virus programs on desktop operating
systems [31]. Also, Android does not oﬀer any APIs
that would allow one app to monitor or restrict the
actions of another app at runtime. Only static infor-
mation about other apps on the device is available via
the Android API, i.e., application metadata, such as
the package name or signing certiﬁcate, and the com-
piled application code and resources.Consequently,
most commercially available security solutions are
limited to detecting potentially malicious apps, e.g.
by comparing metadata with predeﬁned blacklists
or by checking the application code for known mal-
ware signatures, but they lack the ability to observe
or inﬂuence the runtime behavior of other applica-
tions. As a result, their eﬀectiveness is, at best,
debatable [50, 62].

Few proposals in the academic literature [38, 59,
23, 49, 15] focus on application layer only solutions
(see Figure 3). Existing systems mostly focus on
access control by interposing security-sensitive APIs

1https://blackphone.ch
2http://www.ghs.com/mobile/
3http://esdcryptophone.com

Figure 4: Dr. Android and Mr. Hide approach [38].

to redirect the control ﬂow to an additionally in-
lined reference monitor within the app (e.g., Aura-
sium [59], I-ARM-Droid [23], RetroSkeleton [22],
AppGuard [15]). DroidForce [49] additionally pre-
processes target apps with static data ﬂow analysis
to identify strategic policy enforcement points and
to redirect policy decision making to a separate app.
All these systems are based on rewriting the appli-
cation code to inline reference monitors or redirect
control ﬂows, which works without modiﬁcations
to the ﬁrmware and is thus suitable for large-scale
deployment (O1: ; O2: ). However, app rewrit-
ing causes security problems and also a couple of
practical deployment problems. First, inlining the
reference monitor within the process of the untrusted
app itself might be suitable for “benign-but-buggy”
apps; however, apps that actively try to circumvent
the monitor will succeed as there exists no strong
security boundary between the app and the moni-
tor. In essence, this boils down to an arms race be-
tween hooking security critical functions and ﬁnding
new ways to compromise or bypass the monitor [36],
where currently native code gives the attacker the
advantage (O3: ; O4: ). Moreover, re-writing ap-
plication code requires re-signing of the app, which
breaks Android’s signature-based same origin policy
and additionally raises legal concerns about illicit
tampering with foreign code. Lastly, re-written apps
have to be reinstalled. This is not technically possi-
ble for pre-installed system apps; other apps have to
be uninstalled in order to install a fresh, rewritten
version, thereby incurring data loss.
Separate app. Dr. Android and Mr. Hide [38] (see
Figure 4) is a variant of inlined reference monitoring
(O1: ; O2: ) that improves upon the security of
the reference monitor by moving it out of the un-
trusted app and into a separate app. This establishes
a strong security boundary between the untrusted
app and the reference monitor as they run in separate
processes with diﬀerent UIDs (O3: ). Additionally,
it revokes all Android platform permissions from the
untrusted app and applies code rewriting techniques
to replace well-known security-sensitive Android API
calls in the monitored app with calls to the separate

USENIX Association  

24th USENIX Security Symposium  695

reference monitor app that acts as a proxy to the
application framework. The beneﬁt of this design is
that in contrast to inlined monitoring, the untrusted,
zero-permission app cannot gain additional permis-
sions by tampering with the inlined/rewritten code.
However, this enforcement only addresses the plat-
form permissions. The untrusted app process still
has a number of Linux privileges (such as access to
the Binder interface or ﬁle system), and it has been
shown that even a zero-permission app is still capa-
ble of escalating its privileges and violate the user’s
privacy [30, 33, 19, 18, 60, 42, 11, 12] (O4: ).

3.2.2 Sandboxing on traditional OSes
Restricting the access rights of untrusted applications
has a longstanding tradition in desktop and server
operating systems. Few solutions set up user-mode
only sandboxes without relying on operating system
functionality by making strong assumptions about
the interface between the target code and the sys-
tem (e.g., absence of programming language facilities
to make syscalls or direct memory manipulation).
Among the most notable user-space solutions are na-
tive client [61] to sandbox native code within browser
extensions and the Java virtual machine [5] to sand-
box untrusted Java applications.

Other solutions, which loosen the assumptions
about the target interface to the system rely on op-
erating system security features to establish process
sandboxes. For instance, Janus [31], one of the ear-
lier approaches, introduced an OS-supported sandbox
for untrusted applications on Solaris 2.4, which was
based on syscall monitoring and interception to re-
strict the untrusted process’ access to the underlying
operating system. The monitor was implemented as
a separate process with necessary privileges to moni-
tor and restrict other processes via the /proc kernel
interface. Modern browsers like Chromium [9, 3, 8]
employ diﬀerent sandboxing OS facilities (e.g, sec-
comp mode) to mitigate the threat of web-based
attacks against clients by restricting the access of
untrusted code.
App virtualization.
Sandboxing also plays a
role in more recent application virtualization solu-
tions [34, 10, 20, 41], where applications are trans-
parently encapsulated into execution environments
that replace (parts of) the environment with emu-
lation layers that abstract the underlying OS and
interpose all interaction between the app and the
OS. App virtualization is currently primarily used to
enable self-contained, OS-agnostic software, but also
provides security beneﬁts by restricting the interface
and view the encapsulated app has of the system.

App Framework
Service / System App
Process
(Platform Permissions)
boundaries

Boxify

Process
boundaries

Isolated App A

(Target)
Shim

Isolated App B

(Target)
Shim

Broker (Reference Monitor)

Binder IPC

Syscall

Binder Module

Linux Kernel

Syscall API
(DAC + MAC)

Figure 5: Architecture overview of Boxify.

Similarly to these traditional sandboxes and in
particular to app virtualization, Boxify forms a user-
mode sandbox that builds on top of existing operating
system facilities of Android. Thereby, it establishes
app sandboxes that encapsulate Android apps with-
out the need to modify the OS and without the need
to make any assumptions about the apps’ code.

4 Boxify Architecture
We present the Boxify design and implementation.

4.1 Design Overview
The key idea of Boxify is to securely sandbox Android
apps, while avoiding any modiﬁcation of the OS and
untrusted apps. Boxify accomplishes this by dynami-
cally loading and executing the untrusted app in one
of its own processes. The untrusted application is
not executed by the Android system itself, but runs
completely encapsulated within the runtime environ-
ment that Boxify provides and that can be installed
as a regular app on stock Android (see Figure 5).
This approach eliminates the need to modify the
code of the untrusted application and works without
altering the underlying OS (O1: ; O2: ). It thus
constitutes the ﬁrst solution that ports the concept
of app virtualization to the stock Android OS.

The primary challenge for traditional application
sandboxing solutions is to completely mediate and
monitor all I/O between the sandboxed app and the
system in order to restrict the untrusted code’s priv-
ileges. The key insight for our Boxify approach is to
leverage the security provided by isolated processes
in order to isolate the untrusted code running within
the context of Boxify by executing it in a completely
de-privileged process that has no platform permis-
sions, no access to the Android middleware, nor the
ability to make persistent changes to the ﬁle system.
However, Android apps are tightly integrated
within the application framework, e.g., for lifecycle

696  24th USENIX Security Symposium 

USENIX Association

management and inter-component communication.
With the restrictions of an isolated process in place,
encapsulated apps are rendered dysfunctional. Thus,
the key challenge for Boxify essentially shifts from
constraining the capabilities of the untrusted app
to now gradually permitting I/O operations in a
controlled manner in order to securely re-integrate
the isolated app into the software stack. To this
end, Boxify creates two primary entities that run at
diﬀerent levels of privilege: A privileged controller
process known as the Broker and one or more isolated
processes called the Target (see Figure 5).

The Broker is the main Boxify application process
and acts as a mandatory proxy for all I/O operations
of the Target that require privileges beyond the ones
of the isolated process. Thus, if the encapsulated app
bypasses the Broker, it is limited to the extremely con-
ﬁned privilege set of its isolated process environment
(fail-safe defaults; O4: ). As a consequence, the
Broker is an ideal control-ﬂow location in our Boxify
design to implement a reference monitor for any priv-
ileged interaction between a Target and the system.
Any syscalls and Android API calls from the Target
that are forwarded to the Broker are evaluated against
a security policy. Only policy-enabled calls are then
executed by the Broker and their results returned to
the Target process. To protect the Broker (and hence
reference monitor) from malicious app code, it runs
in a separate process under a diﬀerent UID than the
isolated processes. This establishes a strong secu-
rity boundary between the reference monitor and the
untrusted code (O3: ). To transparently forward
the syscalls and Android API calls from the Target
across the process boundary to the Broker, Boxify
uses Android’s Binder IPC mechanism. Finally, the
Broker’s responsibilities also include managing the
application lifecycle of the Target and relaying ICC
between a Target and other (Target) components.

The Target hosts all untrusted code that will run
inside the sandbox. It consists of a shim that is able
to dynamically load other Android applications and
execute them. For the encapsulated app to interact
with the system, it sets up interceptors that interpose
system and middlware API calls. The interceptors do
not form a security boundary but establish a compat-
ibility layer when the code inside the sandbox needs
to perform otherwise restricted I/O by forwarding
the calls to the Broker. All resources that the Target
process uses have to be acquired by the Broker and
their handles duplicated into the Target process.

By encapsulating untrusted apps and interposing
all their (privileged) I/O operations, Boxify is able to
eﬀectively enforce security- and privacy-protecting
policies. Based on syscall interposition, Boxify has

Shim code

e
c

i

x
o
b
d
n
a
S

v
r
e
S

l

e
n
n
a
h
C

 
l

o
r
t
n
o
C

Target (Isolated Process)

Untrusted App Code

Binder IPC Interceptor Syscall Interceptor

Binder IPC

Syscall

Broker

Figure 6: Components of a Target process.

ﬁne-grained control over network and ﬁlesystem op-
erations. Intercepting Binder IPC enables the en-
forcement of security policies that were so far only
achievable for OS extensions, but at application layer
only.

Moreover, with this architecture, Boxify can pro-
vide a number of interesting novel features. Boxify
is capable of monitoring multiple (untrusted) apps
at the same time. By creating a number of Target
processes, multiple apps can run in parallel yet se-
curely isolated in a single instance of Boxify. Since
the Broker fully controls all inter-component commu-
nication between the sandboxed apps, it is able to
not only separate diﬀerent apps from one another but
also to allow controlled collaboration between them.
Further, Boxify has the ability to execute apps that
are not regularly installed on the phone: Since Boxify
executes other apps by dynamically loading their
code into one of its own processes and handles all the
interaction between the sandboxed application and
the OS, there is no need to register the untrusted app
with the Android system. Hence, applications can
be installed into, updated, or removed from Boxify
without involving the PackageInstaller or having
system privileges. A potential application of these
features are application containers (e.g., enterprise
app domain, see §5.4).

4.2 Target
The Target process contains four main entities
(see Figure 6): The SandboxService (1) provides the
Broker with a basic interface for starting and termi-
nating apps in the sandbox. It is also responsible for
setting up the interceptors for Binder IPC (2) and
syscalls (3), which transparently forward calls issued
by the untrusted application to the Broker.
1) SandboxService. Isolated processes on Android
are realized as speciﬁcally tagged Service compo-
nents (see §2). In Boxify each Target is implemented
as such a tagged SandboxService component of the
Boxify app. When a new Target should be spawned, a
new, dedicated SandboxService is spawned. The Sand-

USENIX Association  

24th USENIX Security Symposium  697

boxService provides an IPC interface that enables the
Broker to communicate with the isolated process and
to call two basic lifecycle operations for the Target:
prepare and terminate. The Broker invokes the
prepare function to initialize the sandbox environ-
ment for the execution of a hosted app. As part
of this preparation, the Broker and Target exchange
important conﬁguration information for correct op-
eration of the Target, such as app meta-information
and Binder IPC handles that allow bi-directional IPC
between Broker and Target. The terminate function
shuts down the application running in the sandbox
and terminates the Target process.

The biggest technical challenge at this point was
“How to execute another third-party application within
the running isolated service process?” Naïvely, one
could consider, for instance, a warm-restart of the app
process with the new application code using the exec
syscall. However, we discovered that the most elegant
and reliable solution is to have the Broker initially im-
itate the ActivityManager by instructing the Target
process to load (i.e., bind) another application to its
process and afterwards to relay any lifecycle events
between the actual application framework and the
newly loaded application in the Target process. The
bind operation is supported by the standard Android
application framework and used during normal app
startup. The exact procedure is illustrated in Fig-
ure 7. The Broker ﬁrst creates a new SandboxService
process ( 1 ), which executes with the privileges of an
isolated process. This step actually involves multiple
messages between the Broker process, the Target pro-
cess and the system server, which we omitted here for
the sake of readability. As a result, the Broker process
receives a Binder handle to communicate with the
newly spawned SandboxService. Next, the Broker uses
this handle to instruct the SandboxService to prepare
the loading of a sandboxed app ( 2 ) by setting up
the Binder IPC interceptor and syscall interceptor
(using the meta-information given as parameters of
the prepare call). The SandboxService returns the
Binder handle to its ApplicationThread to the Bro-
ker. The application thread is the main thread of a
process containing an Android runtime and is used
by the ActivityManager to issue commands to An-
droid application processes. At this point, the Broker
emulates the behavior of the ActivityManager ( 3 )
by instructing the ApplicationThread of the Target
with the bindApplication call to load the target app
into its Android runtime and start its execution. By
default, it would be the ActivityManagerService
as part of the application framework that uses this
call to instruct newly forked and specialized Zygote
processes to load and execute an application that

System Server

Broker

Target

1

bindService()

System creates isolated process

and starts SandboxService

Binder SandboxService

2

SandboxService.prepare()

IPC & Syscall

interceptions are set up

Binder ApplicationThread

3

ApplicationThread.bindApplication()

Untrusted application

is started

6

ApplicationThread.

scheduleLaunchActivity()

Activity is started

Create Mapping

Broker Activity <-> Target Activity

4

ActivityManager.startActivity()

System allocates Activity

resources

5

ApplicationThread.

scheduleLaunchActivity()

Resolve Mapping

Broker Activity <-> Target Activity

 

e
s
a
h
P
p
u
t
r
a
t
S

 

e
s
a
h
P
y
t
i
v
i
t
c
A
h
c
n
u
a
L

 

Figure 7: Process to load an app into a Target process
and to launch one its Activities.

should be started. After this step, the sandboxed
app is executing.

As an example how a sandboxed app can be used,
we brieﬂy explain how an Activity component of
the sandboxed app can be launched, e.g., as result
of clicking its entry in a launcher. As explained
in §4.3, the Virtualization Layer creates a mapping
from generic Boxify components to Target compo-
nents.
In this case, it maps the Activity compo-
nent of Target to an Activity component of Boxify.
The Broker requests the Activity launch from the
ActivityManager in the SystemServer ( 4 ), which
allocates the required resources. After allocation,
it schedules the launch of the Activity component
by signaling the ApplicationThread of the targeted
app ( 5 ), which in this case is the Boxify app. Thus,
the Virtualization Layer resolves the targeted Activity
component and relays the signal to the corresponding
Target process ( 6 ).

2) Binder IPC Interceptor. Android applications
use the Binder IPC mechanism to communicate with
the (remote) components of other applications, in-
cluding the application framework services and apps.
In order to interact via Binder IPC with a remote
component, apps must ﬁrst acquire a Binder han-
dle that connects them to the desired component.

698  24th USENIX Security Symposium 

USENIX Association

To retrieve a Binder handle, applications query the
ServiceManager, a central service registry, that al-
lows clients to lookup system services by their com-
mon names. The ServiceManager is the core mech-
anism to bootstrap the communication of an ap-
plication with the Android application framework.
Binder handles to non-system services, such as ser-
vices provided by other apps, can be acquired from
the core framework services, most prominently the
ActivityManager.

Boxify leverages this choke point in the Binder
IPC interaction to eﬃciently intercept calls to the
framework in order to redirect them to the Bro-
ker. To this end, Boxify replaces references to the
ServiceManager handle in the memory of the Target
process with references to the Binder handle of the
Broker (as provided in the prepare function). These
references are constrained to a few places and can be
reliably modiﬁed using the Java Reﬂection API and
native code. Consequently, all calls directed to the
ServiceManager are redirected to the Broker pro-
cess instead, which can then manipulate the returned
Binder objects in such a way that any subsequent in-
teractions with requested services are also redirected
to the Broker. Furthermore, references to a few core
system services, such as the ActivityManager and
PackageManager, that are passed by default to new
Android app runtimes, need to be replaced as well.
By modifying only a small number of Binder handles,
Boxify intercepts all Binder IPC communication. The
technique is completely agnostic of the concrete inter-
face of the redirected service and can be universally
applied to all Binder interactions.
3) Syscall Interceptor. For system call inter-
ception, we rely on a technique called libc hook-
ing (used, for instance, also in [59]). Applications
use Android’s implementation of the Standard C
library Bionic libc to initiate system calls. With
libc hooking, we eﬃcently intercept calls to libc
functions and redirect these calls to a service client
running in the Target process. This client forwards
the function calls via IPC to a custom service compo-
nent running in the Broker. Due to space constraints,
we refer to [7] for a detailed technical explanation of
libc hooking.

In contrast to the IPC interception, which redirects
all IPC communication to the Broker, the syscall in-
terception is much more selective about which calls
are forwarded: We do not redirect syscalls that would
be anyway granted to an isolated process, because
there is no security beneﬁt from hooking these func-
tions: a malicious app could simply remove the hook
and would still succeed with the call. This exception
applies to calls to read world-readable ﬁles and to

Process boundaries

Target A

Target B

API
Layer

Core Logic

Layer

B
R
O
K
E
R

Virtualization

Layer

IPC Receiver

Syscall Recv

Srv Stub
(AMS)

Service

PEP

...

...

Srv Stub
(Location)

Service

PEP

Core

Services

Syscall

PEP

Policy
Module

Component Broker

Binder IPC

Syscall

Figure 8: Architecture of the Broker.

most system calls that operate purely on ﬁle descrip-
tors (e.g. read, write). Naturally, by omitting the
indirection via our Broker, these exempted calls per-
form with native performance. However, Boxify still
hooks calls that are security-critical and that are not
permitted for isolated processes, such as system calls
to perform ﬁle system operations (e.g. open, mkdir,
unlink) and network I/O (socket, getaddrinfo). For
a few calls, such as ﬁle operations, whose success
depends on the given parameter, the syscall intercep-
tion is parameter-sensitive in its decision whether or
not to forward this operation to the Broker.

4.3 Broker
The Broker is the main application process of Boxify
and is thus not subject to the restrictions imposed by
the isolated process. It holds all platform permissions
assigned to the Boxify app and can normally interact
with the Android middleware. The Broker acts as
a mandatory proxy for all interactions between the
Target processes and the Android system and thus
embodies the reference monitor of Boxify. These
interactions are bi-directional: On the one hand, the
untrusted app running in the Target process issues
IPC and syscalls to the system; on the other hand,
the Android middleware initiates IPC calls to Target
(e.g., basic lifecycle operations) and the Broker has
to dispatch these events to the correct Target.

The Broker is organized into three main layers
(see Figure 8): The API Layer (4) abstracts from the
concrete characteristics of the Android-internal IPC
interfaces to provide compatibility across diﬀerent
Android versions. It bridges the semantic gap be-
tween the raw IPC transactions forwarded by the
Target and the application framework semantics of
the Core Logic Layer (5), which implements the funda-
mental mechanics of the virtual runtime environment
that Boxify provides. All interaction with the system
happens through the Virtualization Layer (6), which
translates between the virtual environment inside of

USENIX Association  

24th USENIX Security Symposium  699

Boxify and the Android system on the outside. In the
following, we will look at every layer in more detail.
4) API Layer. The API Layer is responsible for
receiving and unwrapping the redirected syscall pa-
rameters from the Syscall Interceptor in the Target
and relaying them to the Core Logic Layer for monitor-
ing and execution. More importantly, it transforms
the raw Binder IPC parcels received from the IPC
Interceptor into a representation agnostic of the An-
droid version.

In order to (eﬃciently) sandbox applications at
the Binder IPC boundary, Boxify must semantically
interpret the intercepted Binder parcels. However,
intercepted parcels are in a raw representation that
consists only of native types that the kernel mod-
ule supports and the sender marshalled all higher-
level objects (e.g., Java classes) to this representa-
tion. This impedes an eﬃcient sandboxing. To solve
this problem, Boxify leverages the default Android
toolchain for implementing Binder-based RPC pro-
tocols: To ensure that sender and receiver can actu-
ally communicate with each other, the receiver must
know how to unmarshal the raw parcel data (exactly
like Boxify). Android supports the developers in
this process through the Android Interface Deﬁnition
Language (AIDL), which allows deﬁnitions of Binder
interfaces very similar to Java interfaces, including
the names and signatures of remotely callable func-
tions. The Android SDK toolchain generates the
required boilerplate marshalling code from AIDL def-
initions both for the receiver (Stub) and the sender
(Proxy). For system services, these Stubs are auto-
matically generated during system build and Boxify
uses the generated Stubs (which ship with Android
OS and are conveniently accessible to third-party
application) to unmarshal the raw Binder IPC parcel
back to their application framework semantic (i.e.,
Java objects, etc). In essence, this allows us to gen-
erate the API layer of the Broker in an almost fully-
automatic way for each Android version on which
Boxify is deployed. Since Boxify is in full control of
the Binder handles of the encapsulated app (i.e., calls
to the ServiceManager, ActivityManager, etc.), it
can eﬃciently determine which Binder handle of the
app addresses which system service and hence which
Stub must be used to correctly unmarshal the raw
Binder parcel intercepted from each handle.

However, the exact structure of the unmarshalled
data and the functions (name and signature) depend
entirely on the AIDL ﬁle. Since the system service
interfaces describe the internal Android API, these
interfaces change frequently between Android ver-
sions. Hence Boxify would have to implement each
possible version of a Stub for every available Android

version. Since this Stub implementation, in contrast
to the marshalling logic, can not be automated, this
complicates eﬃcient sandboxing of apps across multi-
ple Android versions. Consequently, it is desirable to
transform the unmarshalled IPC data into a version-
agnostic representation and then implement each
Stub once and for all for this version. To accomplish
this in Boxify, we borrow ideas from Google’s pro-
prietary SafeParcel class: In contrast to the regular
Binder parcel, the SafeParcel carries structural in-
formation about the data stored in it, which allows
the receiver of an IPC request to selectively read
parts of the payload without knowing its exact struc-
ture. We achieve the same result by transforming
the version-dependent parcel into a version-agnostic
key-value store (where keys are the parameter names
of methods declared in the interface deﬁnitions) and
adapting the Core Logic Layer and Stub implementa-
tions to work with these version-agnostic data stores.
Thus, while the API layer is version-dependent and
automatically generated for each Android version,
the remaining layers of Broker are version-agnostic
and implemented only once.
5) Core Logic Layer. The Core Logic Layer pro-
vides essential functionality required to run apps on
Android by replicating a small subset of the func-
tionality that Android’s core system services pro-
vide. Most prominently, this layer provides a mini-
mal implementation of the PackageManager, which
manages the packages installed into the Boxify en-
vironment. Every call to a system service that is
not emulated by the Core Logic Layer is passed on
to the Virtualization Layer and thus to the underly-
ing Android system. Other system services, such
as the LocationManager, which are not necessarily
required, can be instantiated at this layer as well,
in case encapsulated apps are supposed to use the
local, Boxify service implementation instead of the
pristine Android service (e.g., servicing sandboxed
apps with fake location data [64]). Hence, this layer
decides whether an Android API call is emulated
using a replicated service or forwarded to the sys-
tem (through the Virtualization Layer). This layer is
therefore responsible for managing the IPC communi-
cation between diﬀerent sandboxed apps (abstractly
like an “ICC switch”).

Furthermore, the Core Logic Layer implements the
policy enforcement points (PEP) for Binder IPC ser-
vices and syscalls. Because the API Layer already
bridges the semantic gap between kernel-level IPC
and Android application framework semantics, this
removes the burden for dealing with low-level seman-
tics in the IPC PEPs. We emulate the integration of
enforcement points into pristine Android services by

700  24th USENIX Security Symposium 

USENIX Association

integrating these points into our mandatory service
proxies. This allows us to instantiate security models
from the area of OS security extensions (see §3.2), but
at the application layer. One default security model
that Boxify provides is the permission enforcement
and same origin model of Android. For instance, the
replicated ActivityManager will enforce permissions
on calls between components of two sandboxed apps.
We present further security models from related work
on OS security extensions that we integrated at this
layer in §5.4 and for future work we consider a pro-
grammable interface for extending Core Logic Layer
security in the spirit of ASM [37] and ASF [14]. For
calls that are not protected by a permission, the Bro-
ker can also choose to enable direct communication
between the target app and the requested Android
system service. This can improve performance for
non-critical services such as the SurfaceFlinger (for
GUI updates) at the cost of losing the ability to me-
diate calls to these services.

The syscall PEP enforces system call policies in the
spirit of [47] with respect to network and ﬁlesystem
operations.
Its responsibilities are twofold: First,
it functions as a transparent compatibility layer by
emulating the ﬁle-system structure of the Android
data partition (e.g., chroot of sandboxed apps by
emulating a home directory for each sandboxed app4
within the home directory of the Boxify app). Second,
it emulates the access control of the Linux kernel, i.e.,
compartmentalization of sandboxed apps by ensuring
that they cannot access private ﬁles of other apps
as well as enforcing permissions (e.g., preventing a
sandboxed app without Internet permission from
creating a network socket).
6) Virtualization Layer. The sandbox environ-
ment must support communication between sand-
boxed apps and the Android application framework,
because certain system resources cannot be eﬃciently
emulated (e.g., SurfaceFlinger for GUI) or not em-
ulated at all (e.g., hardware resources like the cam-
era). However, the sandbox must be transparent to
the Target and all interaction with the application
framework must appear as in a regular app. At the
same time, the sandbox must be completely opaque
to the application framework and sandboxed apps
must be hidden from the framework; otherwise, this
leads to inconsistencies that the framework considers
as runtime (security) exceptions.

In Boxify, the Virtualization Layer is responsible
for translating the bi-directional communication be-
tween the Android application framework and the
4Recall that sandboxed apps are not installed in the system
but only in the Boxify environment, and hence do not have a
native home directory.

Target. It achieves the required semi-transparent com-
munication with a technique that can be abstractly
described as “ICC Network Address Translator”: On
outgoing calls from Target to framework, it ensures
that all ICC appears as coming from the Boxify app
instead of the sandboxed app. As described earlier,
all Binder handles of a Target are substituted with
handles of the Broker, which relays the calls to the
system. During relay of calls, the Virtualization Layer
manipulates the call arguments to hide components
of sandboxed apps by substituting the component
identiﬁers with identiﬁers of components of the Box-
ify app. On incoming calls from the framework, the
Virtualization Layer substitutes the addressed Boxify
component with the actually addressed component
of the sandboxed app and dispatches the call. In
order to correctly substitute addressed components,
the Virtualization Layer maintains a mapping between
Target and Boxify component names, or in case the
Target component is not addressed by a name but a
Binder handle that was given prior to the framework,
the mapping is between the released Binder handle
and its owning Target component.

A concrete example where this technique is applied
is requesting the launch of a Target Activity compo-
nent from the application framework (see Figure 7).
The Virtualization Layer substitutes the Activity com-
ponent with a generic Activity component of Boxify
if a call to the ActivityManager occurs. When the
service calls back for scheduling the Activity launch,
the Virtualization Layer dispatches the scheduling call
to the corresponding Target Activity component.

Lastly, we hook the application runtime of Boxify’s
Broker process (using a technique similar to [55]) in
order to gain control over the processing of incoming
Binder parcels. This enables the Broker to distinguish
between parcels addressed to Boxify itself and those
that need to be forwarded to the Target processes.

4.4 System Integration
Lastly, we discuss some aspects of integrating sand-
boxed apps into the default application framework.
Launcher. Since sandboxed apps have to be started
through Boxify (and are not regularly installed on
the system), they cannot be directly launched from
the default launcher. A straightforward solution is
to provide a custom launcher with Boxify in form
of a dedicated Activity. Alternatively, Boxify could
register as a launcher app and then run the default
launcher (or any launcher app of the user’s choice)
in the sandbox, presenting the union of the regularly
installed apps and apps installed in the sandbox envi-
ronment; or Boxify launcher widgets could be placed

USENIX Association  

24th USENIX Security Symposium  701

Native

Table 2: Microbenchmarks Middleware (200 runs)
API Call
Overhead
1.24ms (1.2%)
Open Camera
0.92 ms (12.0%)
Query Contacts
1.02 ms (1.5%)
Insert Contacts
0.95 ms (0.9%)
Delete Contacts
0.75 ms (0.6%)
Create Socket

on Boxify
104.48 ms
8.55 ms
67.51 ms
76.81 ms
121.58 ms

103.24 ms
7.63 ms
66.49 ms
75.86 ms
120.83 ms

on the regular home screen to launch sandboxed apps
from there.
App stores. Particularly smooth is the integration
of Boxify with app store applications, such as the
Google Play Store. Since no special permissions are
required to install apps into the sandbox, we can
simply run the store apps provided by Google, ven-
dors, and third-parties in Boxify to install new apps
there. For example, clicking install in the sandboxed
Play Store App will directly install the new app into
Boxify. Furthermore, Play Store (and vendor stores)
even take care of automatically updating all apps
installed in Boxify, a feature that IRM systems have
to manually re-implement.
Statically registered resources. Some resources
of apps are statically registered in the system dur-
ing app installation. Since sandboxed apps are not
regularly installed, the system is unaware of their
resources. This concerns in particular Activity com-
ponents that can receive Intents for, e.g., content
sharing, or package resources like icons. However,
some resources like Broadcast Receiver components
can be dynamically registered at runtime and Boxify
uses this as a workaround to dynamically register
the Receivers declared statically in the Manifests of
sandboxed apps.

5 Evaluation
We discuss the prototypical implementation of Boxify
in terms of performance impact, security guarantees,
and app robustness, and present concrete use-cases
of Boxify. Our prototype comprises 11,901 lines of
Java code, of which 4,242 LoC are automatically
generated (API Layer), and 3,550 lines of additional
C/C++ code. All tests described in the following
were performed on an LG Nexus 5 running Android
4.4.4, which is currently the most widely used version
in the Android ecosystem.

5.1 Performance Impact
To evaluate the performance impact of Boxify on
monitored apps, we compare the results of common

Table 3: Microbenchmarks Syscalls (15k runs)

Libc Func.
create
open
remove
mkdir
rmdir

Native
47.2 µs
9.5 µs
49.5 µs
88.4 µs
71.2 µs

on Boxify Overhead
115.2 µs
162.4 µs
122.7 µs
113.2 µs
110.1 µs
159.6 µs
111.0 µs
199.4 µs
180.7 µs
109.5 µs

Table 4: Benchmark Tools (10 runs)

Tool
CF Bench v1.3
Geekbench v3.3.1
PassMark v1.0.4
Quadrant v2.1.1

Native

16082 Pts
1649 Pts
3674 Pts
7820 Pts

on Boxify
15376 Pts
1621 Pts
3497 Pts
7532 Pts

Loss
4.3%
1.6%
4.8%
3.6%

benchmark apps and of custom micro-benchmarks
for encapsulated and native execution of apps.

Table 2 and Table 3 present the results of our micro-
benchmarks for common Android API calls and for
syscall performance. Intercepting calls to the appli-
cation framework imposes an overhead around 1%,
with the exception of the very fast Query Contacts
(12%). For syscalls, we measured the performance of
calls that request ﬁle descriptors for ﬁle I/O in pri-
vate app directories (or external storage) and that are
proxied by the Broker. We observe a constant perfor-

mance overhead of≈ 100µs, which corresponds to the

required time of the additional IPC round trip for the
communication with the Broker on our test platform.
However, the syscall benchmarks depict a worst-case
estimation: The overall performance impact on apps
is much lower, since high-frequent follow up opera-
tions on acquired ﬁle descriptors (e.g., read/write)
need not to be intercepted and therefore run with
native speed. We measured the overall performance
penalty by excecuting several benchmarking apps on
top of Boxify, which show an acceptable performance
degradation of 1.6%–4.8% (see Table 4).

5.2 Runtime Robustness
To assess the robustness of encapsulated apps, we
executed 1079 of the most popular, free apps from
Google Play (retrieved in August 2014) on top of
Boxify. For each sandboxed app we used the mon-
keyrunner tool5 to exercise the app’s functionality by
injecting 500 random UI events. From the 1079 apps,
93 (8.6%) experienced a crash during testing. Man-
ual investigation of the dysfunctional apps revealed

5http://developer.android.com/tools/help/

monkeyrunner_concepts.html

702  24th USENIX Security Symposium 

USENIX Association

Table 5: Android versions supported by Boxify.
Version
5.1
Supported

5.0

4.1

4.2

4.3

4.4





< 4.1

†




: supported; : not supported





†: no isolated proccess

that most errors were caused by apps executing ex-
otic syscalls or rarely used Android APIs which are
not covered by Boxify yet and thus fail due to the
lack of privileges of the Target process (fail-safe de-
faults). This leads to a slightly lower robustness than
reported for related work (e.g., [59, 15]) where by-
passed hooks do not cause the untrusted app to crash
but instead silently circumvent the reference monitor.
The remaining issues were due to unusual applica-
tion logic that relies on certain OS features (e.g., the
process information pseudo-ﬁlesystem proc), which
the current prototype of Boxify does not yet support.
However, all of these are technical and not concep-
tual shortcomings of the current implementation of
Boxify.

5.3 Portability
Table 5 summarizes the Android versions currently
supported by our prototypical Boxify implementa-
tion. Our prototype supports all Android versions
4.1 through 5.1 and can be deployed on nine out of
ten devices in the Android ecosystem [1]. Android
versions prior to 4.1 are not supported due to the
lack of the isolated process feature.

5.4 Use-cases
Boxify allows the instantiation of diﬀerent security
models from the literature on Android security ex-
tensions. In the following, we present two selected
use-cases on ﬁne-grained permission control and do-
main isolation that have received attention before in
the security community.
Fine-Grained Permission Control.
The
TISSA [64] OS extension empowers users to ﬂexi-
bly control in a ﬁne-grained manner which personal
information will be accessible to applications. We
reimplemented the TISSA functionality as an exten-
sion to the Core Logic Layer of the Boxify Broker.
To this end, we instrumented the mandatory prox-
ies for core system services (e.g. LocationManager,
TelephonyService) so that they can return a ﬁl-
tered or mock data set based on the user’s privacy
settings. Users can dynamically adjust their privacy
preferences through a management Activity added

to Boxify. In total, the TISSA functionality required
additional 351 lines of Java code to Core Logic Layer.
Domain Isolation. Particularly for enterprise de-
ployments, container solutions have been brought
forward to separate business apps from other (un-
trusted) apps [56, 17, 53].

We implemented a domain isolation solution based
on Boxify by installing business apps into the sand-
box environment. The Broker provides its own ver-
sion of the PackageManager to directly deliver inter-
component communication to sandboxed applications
without involving the regular PackageManager, en-
abling controlled collaboration between enterprise
apps while at the same time isolating and hiding
them from non-enterprise apps and the OS.

To separate the enterprise data from the user’s
private data, we exploit that the Broker is able to
run separate instances of system services (e.g., Con-
tacts, Calendar) within the sandbox. Our custom
ActivityManager proxy now selectively and trans-
parently redirects ContentProvider accesses by en-
terprise apps to the sandboxed counterparts of those
providers.

Alternatively, the above described domain isolation
concept was used to implement a privacy mode for
end users, where untrusted apps are installed into
a Boxify environment with empty (or faked) system
ContentProviders. Thus, users can test untrusted
apps in a safe environment without risking harm to
their mobile device or private data. The domain
isolation extension required 986 additional lines of
code in the Core Logic Layer of Boxify.

5.5 Security Discussion
Our solution builds on isolated processes as funda-
mental security primitive. An isolated process is the
most restrictive execution environment that stock
Android currently has to oﬀer, and it provides Boxify
with better security guarantees than closest related
work [38].
In what follows, we identify diﬀerent
security shortcomings and discuss potential future se-
curity primitives of stock Android that would beneﬁt
Boxify and defensively programmed apps in general.
Privilege escalation. A malicious app could by-
pass the syscall and IPC interceptors, for instance,
by statically linking libc. For IPC, this does not
lead to a privilege escalation, since the application
framework apps and services will refuse to cooperate
with an isolated process. However, the kernel is un-
aware of the concept of an “isolated process” and will
enforce access control on syscalls according to the
process’ UID. Although the transient UIDs of isolated

USENIX Association  

24th USENIX Security Symposium  703

processes are very restricted in their ﬁlesystem access
(i.e., only world readable/writable ﬁles), a malicious
process has the entire kernel API as an attack vector
and might escalate its privileges through a root or
kernel exploit. In this sense, Boxify is not more secure
than existing approaches that rely on the assumption
that the stock Android kernel is hardened against
root and kernel exploits.

To remedy this situation, additional layers of se-
curity could be provided by the underlying kernel
to further restrict untrusted processes. This is com-
mon practice on other operating systems, e.g., on
modern Linux distributions, where Chromium—the
primary user of isolated process on Android—uses
the seccomp-bpf facility to selectively disable syscalls
of renderer processes and we expect this facility to
become available on future Android versions with
newer kernels. Similarly, common program tracing
facilities could be made available in order to interpose
syscalls more securely and eﬃciently [31, 47, 52].

Violating Least-Privilege Principle. The Broker
must hold the union set of all permissions required
by the apps hosted by Boxify in order to successfully
proxy calls to the Android API. Since it is hard to
predict a reasonable set of permissions beforehand,
this means that the Broker usually holds all available
permissions. This contradicts the principle of least
privilege and makes the Broker an attractive target
for the encapsulated app to increase its permission
set. A very elegant solution to this problem would be
a Broker that drops all unnecessary permissions. This
resembles the privilege separation pattern [48, 57]
of established Linux services like ssh, which drop
privileges of sub-processes based on setting their
UIDs, capabilities, or transitioning them to seccomp
mode. Unfortunately, Android does not (yet) provide
a way toselectively drop permissions at runtime.

Red Pill. Even though Boxify is designed to be
invisible to the sandboxed app, it cannot exclude
that the untrusted app gathers information about
its execution environment that allow the app to de-
duce that it is sandboxed (e.g., checking its runtime
UID or permissions). A malicious app can use this
knowledge to change its runtime behavior when being
sandboxed and thus hide its true intentions or refuse
to run in a sandboxed environment. Prevention of
this information leak is an arms race that a resolute
attacker will typically win. However, while this might
lead to refused functionality, it cannot be used to
escalate the app’s privileges.

6 Conclusion
We presented the ﬁrst application virtualization so-
lution for the stock Android OS. By building on
isolated processes to restrict privileges of untrusted
apps and introducing a novel app virtualization envi-
ronment, we combine the strong security guarantees
of OS security extensions with the deployability of
application layer solutions. We implemented our so-
lution as a regular Android app called Boxify and
demonstrated its capability to enforce established se-
curity policies without incurring signiﬁcant runtime
performance overhead.

Availability and Future Work. We will make
the Boxify source code freely available. Beyond the
immediate privacy beneﬁts for the end-user presented
in this paper (see §5.4), Boxify oﬀers all the security
advantages of traditional sandboxing techniques and
is thus of independent interest for future Android
security research. As future work, we are currently
investigating diﬀerent application domains of Box-
ify, such as application-layer only taint-tracking for
sandboxed apps [24], programmable security APIs in
the spirit of ASM [37]/ASF [14] to facilitate the ex-
tensibility of Boxify, as well as Boxify-based malware
analysis tools.

References
[1] Android developer dashboard.
android.com/about/dashboards/.
06/20/15.

https://developer.
visited:

Last

[2] Android developer’s guide. http://developer.android.

com/guide/index.html. Last visited: 02/19/15.

[3] Chromium: Linux sandboxing. https://code.google.
com/p/chromium/wiki/LinuxSandboxing. Last visited:
02/10/15.

[4] Cyanogenmod. http://www.cyanogenmod.org.
[5] Java SE Documentation:

Security Speciﬁcation.

http://docs.oracle.com/javase/7/docs/technotes/
guides/security/spec/security-specTOC.fm.html.
Last visited: 02/10/15.

[6] OmniROM.

02/19/15.

http://omnirom.org.

Last visited:

[7] Redirecting functions in shared elf libraries.

http:
//www.codeproject.com/Articles/70302/Redirecting-
functions-in-shared-ELF-libraries.

[8] The Chromium Projects:

OSX Sandboxing De-
sign.
http://dev.chromium.org/developers/design-
documents/sandbox/osx-sandboxing-design. Last vis-
ited: 02/10/15.

[9] The Chromium Projects:

http://www.chromium.org/developers/design-
documents/sandbox. Last visited: 02/10/15.

Sandbox

(Windows).

[10] Wine: Run Windows applications on Linux, BSD, Solaris
and Mac OS X. https://www.winehq.org. Last visited:
02/13/15.

704  24th USENIX Security Symposium 

USENIX Association

[11] Zero-Permission Android Applications.

https:
//www.leviathansecurity.com/blog/zero-permission-
android-applications/. Last visited: 02/11/15.

[12] Zero-Permission Android Applications

(Part

http://www.leviathansecurity.com/blog/zero-
permission-android-applications-part-2/.
visited: 02/11/15.

2).

Last

[13] Andrus, J., Dall, C., Hof, A. V., Laadan, O., and
Nieh, J. Cells: A virtual mobile smartphone architecture.
In Proc. 23rd ACM Symposium on Operating Systems
Principles (SOSP’11) (2011), ACM.

[14] Backes, M., Bugiel, S., Gerling, S., and von Styp-
Rekowsky, P. Android Security Framework: Extensible
multi-layered access control on Android. In Proc. 30th
Annual Computer Security Applications Conference (AC-
SAC’14) (2014), ACM.

[15] Backes, M., Gerling, S., Hammer, C., Maffei, M.,
and von Styp-Rekowsky, P. Appguard - enforcing user
requirements on Android apps. In Proc. 19th Interna-
tional Conference on Tools and Algorithms for the Con-
struction and Analysis of Systems (TACAS’13) (2013),
Springer.

[16] Bugiel, S., Davi, L., Dmitrienko, A., Fischer, T.,
Sadeghi, A.-R., and Shastry, B. Towards Taming
Privilege-Escalation Attacks on Android. In Proc. 19th
Annual Network and Distributed System Security Sym-
posium (NDSS’12) (2012), The Internet Society.

[17] Bugiel, S., Davi, L., Dmitrienko, A., Heuser, S.,
Sadeghi, A.-R., and Shastry, B. Practical and
lightweight domain isolation on Android. In Proc. 1st
ACM Workshop on Security and Privacy in Smartphones
and Mobile Devices (SPSM’11) (2011), ACM.

[18] Cai, L., and Chen, H. Touchlogger: inferring keystrokes
on touch screen from smartphone motion. In Proc. 6th
USENIX conference on Hot topics in security (HotSec’11)
(2011), USENIX Association.

[19] Chen, Q. A., Qian, Z., and Mao, Z. M. Peeking into
Your App without Actually Seeing It: UI State Inference
and Novel Android Attacks. In Proc. 23rd USENIX Secu-
rity Symposium (SEC’14) (2014), USENIX Association.
http://www.citrix.com/

[20] Citrix.

Xenapp.

products/xenapp/how-it-works/application-
virtualization.html. Last visited: 02/13/15.

[21] Conti, M., Nguyen, V. T. N., and Crispo, B. CRePE:
Context-Related Policy Enforcement for Android. In Proc.
13th International Conference on Information Security
(ISC’10) (2010).

[22] Davis, B., and Chen, H. Retroskeleton: Retroﬁtting
android apps. In Proc. 11th Annual International Con-
ference on Mobile Systems, Applications, and Services
(MobiSys’13) (2013), ACM.

[23] Davis, B., Sanders, B., Khodaverdian, A., and Chen,
H. I-ARM-Droid: A Rewriting Framework for In-App
Reference Monitors for Android Applications. In Proc.
Mobile Security Technologies 2012 (MoST’12) (2012),
IEEE Computer Society.

[24] Enck, W., Gilbert, P., Chun, B.-G., Cox, L. P., Jung,
J., McDaniel, P., and Sheth, A. N. Taintdroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In Proc. 9th USENIX Sym-
posium on Operating Systems Design and Implementa-
tion (OSDI 2010) (2010), pp. 393–407.

[25] Enck, W., Octeau, D., McDaniel, P., and Chaudhuri,
S. A Study of Android Application Security. In Proc. 20th
USENIX Security Symposium (SEC’11) (2011), USENIX
Association.

[26] Enck, W., Ongtang, M., and McDaniel, P. On
In
lightweight mobile phone application certiﬁcation.
Proc. 16th ACM Conference on Computer and Commu-
nication Security (CCS’09) (2009), ACM.

[27] Enck, W., Ongtang, M., and McDaniel, P. Under-
standing android security. IEEE Security and Privacy 7,
1 (2009), 50–57.

[28] Erlingsson, Ú. The Inlined Reference Monitor Approach
to Security Policy Enforcement. PhD thesis, Cornell
University, January 2004.

[29] Fahl, S., Harbach, M., Muders, T., Smith, M.,
Baumgärtner, L., and Freisleben, B. Why Eve and
Mallory love Android: An analysis of Android SSL (in)
security. In Proc. 19th ACM Conference on Computer
and Communication Security (CCS’12) (2012), ACM.

[30] Felt, A. P., Wang, H. J., Moshchuk, A., Hanna, S.,
and Chin, E. Permission re-delegation: Attacks and
defenses. In Proc. 20th USENIX Security Symposium
(SEC’11) (2011), USENIX Association.

[31] Goldberg, I., Wagner, D., Thomas, R., and Brewer,
E. A. A secure environment for untrusted helper applica-
tions conﬁning the wily hacker. In Proc. 6th Conference
on USENIX Security Symposium, Focusing on Appli-
cations of Cryptography (SSYM’96) (1996), USENIX
Association.

[32] Grace, M., Zhou, W., Jiang, X., and Sadeghi, A.-R.
Unsafe exposure analysis of mobile in-app advertisements.
In Proc. 5th ACM conference on Security and Privacy
in Wireless and Mobile Networks (WISEC’12) (2012),
ACM.

[33] Grace, M. C., Zhou, Y., Wang, Z., and Jiang, X.
Systematic detection of capability leaks in stock android
smartphones. In Proc. 19th Annual Network and Dis-
tributed System Security Symposium (NDSS’12) (2012),
The Internet Society.

[34] Guo, P. J., and Engler, D. Cde: Using system call inter-
position to automatically create portable software pack-
ages. In Proc. 2011 USENIX Conference on USENIX
Annual Technical Conference (USENIXATC’11) (2011),
USENIX Association.

Isolatedprocess

[35] Hackborn, D.

introducing
in JellyBean.

Android Developer Group:
tag
https://groups.

Advantage
of
within Services
google.com/forum/?fromgroups=#!topic/android-
developers/pk45eUFmKcM, 2012. Last visited: 02/19/15.
[36] Hao, H., Singh, V., and Du, W. On the Eﬀectiveness
of API-level Access Control Using Bytecode Rewriting in
Android. In Proc. 8th ACM Symposium on Information,
Computer and Communication Security (ASIACCS’13)
(2013), ACM.

[37] Heuser, S., Nadkarni, A., Enck, W., and Sadeghi,
A.-R. ASM: A Programmable Interface for Extending
Android Security. In Proc. 23rd USENIX Security Sym-
posium (SEC’14) (2014), USENIX Association.

[38] Jeon, J., Micinski, K. K., Vaughan, J. A., Fogel, A.,
Reddy, N., Foster, J. S., and Millstein, T. Dr. An-
droid and Mr. Hide: Fine-grained Permissions in Android
Applications.
In Proc. 2nd ACM Workshop on Secu-
rity and Privacy in Smartphones and Mobile Devices
(SPSM’12) (2012), ACM.

USENIX Association  

24th USENIX Security Symposium  705

[39] Kaspersky Lab, and INTERPOL. Mobile cyber-threats.

http://securelist.com/analysis/publications/
66978/mobile-cyber-threats-a-joint-study-by-
kaspersky-lab-and-interpol/, 2014.
02/19/15.

Last visited:

[40] Lange, M., Liebergeld, S., Lackorzynski, A., Warg,
A., and Peter, M. L4android: A generic operating
system framework for secure smartphones. In Proc. 1st
ACM Workshop on Security and Privacy in Smartphones
and Mobile Devices (SPSM’11) (2011), ACM.

[41] Microsoft. Application Virtualization (App-V). http:

//www.microsoft.com/en-us/windows/enterprise/
products-and-technologies/mdop/app-v.aspx.
visited: 02/13/15.

Last

backdoors without

[42] Moulu, A. Android OEM’s applications (in)security
and
http:
//www.quarkslab.com/dl/Android-OEM-applications-
insecurity-and-backdoors-without-permission.pdf.
Last visited: 02/19/15.

permission.

[43] Mulliner, C., Oberheide, J., Robertson, W., and
Kirda, E. PatchDroid: Scalable Third-party Security
Patches for Android Devices.
In Proc. 29th Annual
Computer Security Applications Conference (ACSAC’13)
(2013), ACM.

[44] Nauman, M., Khan, S., and Zhang, X. Apex: Ex-
tending android permission model and enforcement with
user-deﬁned runtime constraints. In Proc. 5th ACM Sym-
posium on Information, Computer and Communication
Security (ASIACCS’10) (2010), ACM.

[45] Ongtang, M., McLaughlin, S. E., Enck, W., and
McDaniel, P. Semantically Rich Application-Centric
Security in Android. In Proc. 25th Annual Computer
Security Applications Conference (ACSAC’09) (2009),
ACM.

[46] Open Signal.

ized (July 2013).
fragmentation-2013/. Last visited: 02/06/2015.

Android Fragmentation Visual-
http://opensignal.com/reports/

[47] Provos, N. Improving host security with system call
policies. In Proc. 12th Conference on USENIX Security
Symposium - Volume 12 (SSYM’03) (2003), USENIX
Association.

[48] Provos, N., Friedl, M., and Honeyman, P. Prevent-
ing privilege escalation. In Proc. 12th Conference on
USENIX Security Symposium - Volume 12 (SSYM’03)
(2003), USENIX Association.

[49] Rasthofer, S., Arzt, S., Lovat, E., and Bodden,
E. DroidForce: Enforcing Complex, Data-Centric,
System-Wide Policies in Android. In Proc. 9th Interna-
tional Conference on Availability, Reliability and Security
(ARES’14) (2014), IEEE Computer Society.

[50] Rastogi, V., Chen, Y., and Jiang, X. DroidChameleon:
Evaluating Android Anti-malware Against Transforma-
tion Attacks. In Proc. 8th ACM Symposium on Infor-
mation, Computer and Communication Security (ASI-
ACCS’13) (2013), ACM.

[51] Russello, G., Conti, M., Crispo, B., and Fernandes,
E. MOSES: supporting operation modes on smartphones.
In Proc. 17th ACM Symposium on Access Control Models
and Technologies (SACMAT’12) (2012), ACM.

[52] Russello, G., Jimenez, A. B., Naderi, H., and van der
Mark, W. FireDroid: Hardening Security in Almost-
stock Android. In Proc. 29th Annual Computer Security
Applications Conference (ACSAC’13) (2013), ACM.

samsung KNOX.

[53] Samsung Electronics. White paper: An overview
http://www.samsung.com/se/

of
business-images/resource/2013/samsung-knox-an-
overview/%7B3%7D/Samsung_KNOX_whitepaper-0-0-
0.pdf, 2013. Last visited: 02/19/15.

[54] Smalley, S., and Craig, R. Security Enhanced (SE) An-
droid: Bringing Flexible MAC to Android. In Proc. 20th
Annual Network and Distributed System Security Sym-
posium (NDSS’13) (2013), The Internet Society.

[55] von Styp-Rekowsky, P., Gerling, S., Backes, M.,
and Hammer, C. Idea: Callee-site rewriting of sealed
system libraries. In Proc. 5th International Symposium
on Engineering Secure Software and Systems (ESSoS’13)
(2013), Springer.

[56] Wangy, X., Sun, K., and Jing, Y. W. J. DeepDroid:
Dynamically Enforcing Enterprise Policy on Android De-
vices. In Proc. 22nd Annual Network and Distributed
System Security Symposium (NDSS’15) (2015), The In-
ternet Society.

[57] Watson, R. N. M., Anderson, J., Laurie, B., and
Kennaway, K. Capsicum: Practical capabilities for unix.
In Proc. 19th USENIX Security Symposium (SEC’10)
(2010), USENIX Association.

[58] Wu, C., Zhou, Y., Patel, K., Liang, Z., and Jiang,
X. Airbag: Boosting smartphone resistance to malware
infection. In Proc. 21st Annual Network and Distributed
System Security Symposium (NDSS’14) (2014), The In-
ternet Society.

[59] Xu, R., Saïdi, H., and Anderson, R. Aurasium –
Practical Policy Enforcement for Android Applications.
In Proc. 21st USENIX Security Symposium (SEC’12)
(2012), USENIX Association.

[60] Xu, Z., Bai, K., and Zhu, S. Taplogger: inferring user in-
puts on smartphone touchscreens using on-board motion
sensors. In Proc. 5th ACM conference on Security and
Privacy in Wireless and Mobile Networks (WISEC’12)
(2012), ACM.

[61] Yee, B., Sehr, D., Dardyk, G., Chen, J. B., Muth, R.,
Ormandy, T., Okasaka, S., Narula, N., and Fulla-
gar, N. Native client: A sandbox for portable, untrusted
x86 native code. In Proc. 30th IEEE Symposium on Se-
curity and Privacy (Oakland’09) (2009), IEEE Computer
Society.

[62] Zhou, Y., and Jiang, X. Dissecting Android malware:
Characterization and evolution.
In Proc. 33rd IEEE
Symposium on Security and Privacy (Oakland’12) (2012),
IEEE Computer Society.

[63] Zhou, Y., Wang, Z., Zhou, W., and Jiang, X. Hey,
You, Get Oﬀ of My Market: Detecting Malicious Apps
in Oﬃcial and Alternative Android Markets. In Proc.
19th Annual Network and Distributed System Security
Symposium (NDSS’12) (2012), The Internet Society.

[64] Zhou, Y., Zhang, X., Jiang, X., and Freeh, V. Tam-
ing information-stealing smartphone applications (on
Android).
In Proc. 4th International Conference on
Trust and Trustworthy Computing (TRUST’11) (2011),
Springer.

706  24th USENIX Security Symposium 

USENIX Association

