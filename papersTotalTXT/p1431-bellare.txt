Mass-surveillance without the State: Strongly
Undetectable Algorithm-Substitution Attacks

Mihir Bellare

Department of Computer
Science and Engineering,
University of California San

Diego

Joseph Jaeger

Department of Computer
Science and Engineering,
University of California San

Diego

Daniel Kane

Department of Computer
Science and Engineering,
University of California San

Diego

ABSTRACT
We present new algorithm-substitution attacks (ASAs) on
symmetric encryption that improve over prior ones in two
ways. First, while prior attacks only broke a sub-class of
randomized schemes having a property called coin injec-
tivity, our attacks break all randomized schemes. Second,
while prior attacks are stateful, ours are stateless, achiev-
ing a notion of strong undetectability that we formalize.
Together this shows that ASAs are an even more danger-
ous and powerful mass surveillance method than previously
thought. Our work serves to increase awareness about what
is possible with ASAs and to spur the search for deterrents
and counter-measures.

1.

INTRODUCTION

The Snowden revelations have exposed a pervasive pro-
gram of mass surveillance, one of whose potential mecha-
nisms is an algorithm substitution attack (ASA) [19, 20, 3].
In the context of symmetric encryption which is our focus,
your encryption code (which implements the prescribed en-
cryption algorithm of the scheme) is replaced by big-brother
created malware that aims to undetectably exﬁltrate your
key through ciphertexts [3].

In this paper we present a new ASA on symmetric encryp-
tion that improves over the prior one of BPR [3] in two ways.
First, while the prior ASA only broke a sub-class of random-
ized schemes having a property called coin injectivity, ours
breaks all randomized schemes. Second, while the prior ASA
was stateful, ours is stateless, achieving a stronger notion of
undetectability that we motivate and formalize. Together
this shows that ASAs are even more dangerous and power-
ful than previously thought.
ASAs. Alice expects that her encryption code is implement-
ing the encryption algorithm SE.Enc prescribed by her cho-
sen symmetric encryption scheme SE. In an ASA [3], the
code of SE.Enc has been replaced by big-brother designed

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813681.

malware A.Enc. When Alice calls her encryption routine,
giving it key KSE and message m to encrypt, it is A.Enc that
runs, producing a ciphertext c based not only on the given
inputs but also on another, hardwired key we denote KA.
Colluding with A.Enc is an accomplice A.Ext who knows KA
and will pick up c by eavesdropping on the channel. A.Enc
aims to produce c in such a way that A.Ext can violate pri-
vacy of Alice’s communications, the most eﬀective (from the
point of view of big brother) attack being one that recovers
KSE from c.

One’s ﬁrst reaction may be that a successful ASA is trivial.
For example, let the subverted code A.Enc, given KA, KSE, m,
set ciphertext c equal to the encryption key KSE. BPR [3]
argue that this is attack is unattractive to big brother be-
cause it is detectable. Anyone (in particular the decrypter),
obtaining c, will see that something is not right. BPR [3]
put forth the goal of an ASA as being to violate privacy
while remaining undetectable.
Undetectability. To rigorously explore ASAs, BPR [3]
provide a formalization of undetectability. Their viewpoint
is that the detecter is the decrypter. It thus knows KSE and
can check that a ciphertext decrypts to an intended message.
But it can do other checks as well. The deﬁnition models
detecter D as an adversary given input KSE and access to
an encryption oracle Enc that, given a message m, returns
ciphertext c computed either via SE.Enc on inputs KSE, m
or via A.Enc on inputs KA, KSE, m. Undetectability requires
that no eﬃcient D should be able to tell which.
The BPR attack. The question that emerges is whether
it is possible to mount a successful but undetectable ASA.
BPR [3] address this in depth when SE.Enc is randomized.
(Here and henceforth, a randomized scheme means a state-
less scheme with non-trivial entropy in the ciphertexts. See
Section 4 for a formal deﬁnition. A deterministic scheme,
which has no entropy in the ciphertexts, does not qualify!)
Randomized schemes are the most basic and common, mak-
ing this question important. Their strongest result is repre-
sented by their biased ciphertext attack. We will ﬁrst explain
the attack and then discuss our work.
Let us view SE.Enc as a deterministic function of KSE, m
and coins r, producing a ciphertext as c ← SE.Enc(KSE, m; r).
In the true encryption process, r is chosen at random. In the
biased ciphertext attack of BPR [3], A.Enc also produces c
as SE.Enc(KSE, m; r) but picks r, not uniformly at random,
but at random from a subset S of the set of all possible coins,
where S is deﬁned as the set of r so that a PRF F under

1431KA, when applied to input c = SE.Enc(KSE, m; r), returns
the ﬁrst bit KSE[1] of KSE. This allows A.Ext, given KA, c,
to retrieve KSE[1] = F(KA, c). The process is repeated to
exﬁltrate KSE bit by bit.

The diﬃculty is assessing undetectability. The ciphertext
c produced by A.Enc is not distributed the same way as one
produced by the true encryption process. Can a detection
adversary D tell? This question turns out to be surprisingly
diﬃcult. BPR [3] provide a partial answer. Calling a scheme
SE coin injective if the mapping r (cid:55)→ SE.Enc(KSE, m; r) is
injective for all KSE, m, they use a combinatorial analysis [3,
Lemma 1] to prove undetectability in this case. Based on
this they move away from randomized, stateless schemes to
obtain security via deterministic, stateful ones.
Shortcomings of prior work. The biased ciphertext at-
tack has two shortcomings. Both are noted in BPR [3] and
left as open problems which we will resolve.

The ﬁrst shortcoming is that the attack only applies to
coin injective schemes. The basic question left un-answered
here is, does there exist an ASA-secure randomized scheme,
or are all randomized schemes subject to attack?

The second shortcoming is that in the biased ciphertext
ASA, the subverted encryption algorithm A.Enc is stateful,
maintaining state σ across invocations. (The state in this
case is an integer representing either which bit of the key
A.Enc is trying to exﬁltrate or taking a special value to in-
dicate that exﬁltration is complete and encryption should
be be done as usual.) This renders the attack detectable in
practice in simple ways. For example, a state reset, as can
happen with a reboot or cloning to create a virtual machine,
leads, in their attack, to detection. However, this is not cap-
tured by their deﬁnition of detectability, under which they
prove their attack undetectable (for coin injective schemes).
BPR [3] recognize this and comment that a stateless attack
would be better, but that they do not know how to make
their attack stateless.
Contributions in brief. We contribute (1) new deﬁnitions
(2) new attacks and (3) new analyses. The deﬁnitions are
for strong undetectability (which captures the above issues
and can only be met by stateless schemes) and key recovery
security, the latter reﬂecting the need to formalize not just
security goals but attack goals. The attack is a new ASA
shown to achieve both. The analyses establishing this re-
solve technical issues from BPR [3] via a diﬀerent approach.
As a by product, we resolve the above questions, present-
ing a stateless ASA that breaks all randomized encryption
schemes and showing that the move to deterministic schemes
for security, made by BPR [3], is a necessary one.
Strong undetectability. Our ﬁrst contribution is to in-
troduce and formalize a stronger notion of undetectability
called strong undetectability. Our formalization,
in Sec-
tion 3, uses the framework of the above discussed deﬁnition
of BPR [3] but makes the oracle Enc more powerful with re-
gard both to inputs and outputs. It now takes input not just
a message, but a key, allowing the detector to pick, rather
than merely know, the encryption key KSE. It returns not
just the ciphertext, but the current state σ of the encryption
code.

The last means that as long as the good encryption algo-
rithm SE.Enc is stateless (the case we are interested in here),
statelessness of A.Enc is a necessary (but not suﬃcient) con-
dition for strong undetectability. That is, a strongly unde-

tectable ASA must be stateless. A consequence of this is
that the ASA will not be detectable upon system reset or
cloning, meaning strong undetectability excludes the easy
and natural methods of detection allowed by undetectabil-
ity under BPR [3].

Ensuring this was the main purpose of the deﬁnition. Be-
yond that, while BPR [3] took the view that detection is
performed by the decrypter, strong undetectability suggests
that detection may to some extent be performed by the en-
cryptor. It imagines that the detector may have blackbox
access to the encryption code and can experiment with it, so
that it can feed it keys of its choice and see whether or not
it maintains state. However one must be careful to not take
this interpretation to an extreme, for there are certainly de-
tection methods that someone with blackbox access to the
code could employ that strong undetectability does not cap-
ture, for example timing the responses and comparing this
to the time the real algorithm would be expected to take.
Indeed, it is not possible to evade all forms of detection. We
are trying to evade more forms of detection than prior work
and ﬁgure out how “undetectable” a successful ASA can be.
The biased ciphertext ASA of BPR [3] will not be strongly
undetectable due to its use of non-trivial state. The question
this raises is whether strongly undetectable (and in partic-
ular stateless) ASAs are possible, and on which randomized
encryption schemes. We will show that they are possible on
all randomized schemes.
Key recovery. Beyond introducing and formalizing strong
undetectability, we take a more rigorous approach to attack
goals. As is conventional in cryptography, BPR [3] formal-
ize security goals, not attacker goals. Thus, they provide
an indistinguishability style surveillance advantage, viewing
the goal as being to ensure that this advantage stays small
for undetectable ASAs. This is a good goal for the scheme
designer to achieve, but its violation by an attacker means
little. Big brother is after more, speciﬁcally recovery of the
target key. We carefully formalize a framework for key re-
covery attacks in which we can compare diﬀerent ones to
diﬀerentiate between the eﬀectiveness of diﬀerent attacks
and make rigorous claims about what our attacks achieve.
Our formalization introduces as a parameter a message
distribution M, distinct from the adversary, that represents
the messages encrypted by the encrypter. The larger the
class of message distributions for which the attack succeeds,
the more powerful the attack. Our ASA will succeed for all
message distributions, which means that big brother recov-
ers the target key regardless of what messages the sender
sends. In particular, big brother would not need to pick or
control the messages to succeed.
ASA. We now sketch our new ASA which we will show
to achieve key recovery (for all message distributions) and
strong undetectability for all randomized encryption schemes.
Let the good key KSE have length k, and let PRF F take
outputs in the set {0, 1} × [k] where [k] = {1, . . . , k}, mean-
ing an output is a pair (v, i) where v is a bit and i is an
index into the key. In our new ASA, the subverted encryp-
tion algorithm A.Enc, given KA, KSE, m, aims to pick r such
that the (v, i) returned by F(KA, SE.Enc(KSE, m; r)) satisﬁes
v = KSE[i], returning c ← SE.Enc(KSE, m; r). A.Ext can re-
trieve (KSE[i], i) = F(KA, c). In this way it gets the i-th bit
of the key.

1432However, there are some diﬃculties with the above de-
scription. First, it may not be possible to directly and eﬃ-
ciently pick r in the way described. In our ASA, which is
presented in detail in Section 4, A.Enc uses rejection sam-
pling, repeatedly picking r at random until either the desired
condition is met or it times out, when the latter happens be-
ing controlled by a parameter s of the attack. Second, we
must use a series of q encryptions to allow A.Ext to recover
the entire key, so that we must determine how to pick q,
which is another parameter of the attack. The challenge is
to prove both key recovery and strong undetectability with-
out making any assumptions on the encryption scheme other
than that it is randomized, and with good, concrete bounds
enabling concrete and practical choices of q, s that make the
attack both eﬃcient and eﬀective. The analyses we discuss
next resolve these challenges.
Analyses. Theorem 4.1 proves that big brother, with our
ASA, will indeed recover the target key, with high probabil-
ity even for relatively small values of the attack parameters
q, s. Given q, s and the key length k of the targeted ran-
domized encryption scheme SE, the theorem gives a concrete
lower bound on the key recovery advantage of our adversary
as a function of q, s, k. The proof is a sequence of games.
We begin, in a standard way, by exploiting the assumed
PRF security of F to move to a game where it is replaced
by a random function. We then exploit the assumption that
the scheme is randomized (ciphertexts have non-trivial min-
entropy) to move to a game where the (v, i) values are all
picked independently at random. This allow us to move to
a game where the sampling continues inﬁnitely, reaching the
conceptually correct distribution of the above attack idea.
A coupon collector argument provides the bound for the last
game. Each game transition accumulates an error, the sum
of these being our ﬁnal bound. We show with a numerical
example that a 128 bit key is recovered quite quickly.

Our approach to proving (strong) undetectability is en-
tirely diﬀerent from that used by BPR [3] to prove unde-
tectability of their biased ciphertext attack, and it is this
novel analysis that allows us to avoid extra assumptions like
coin injectivity on the encryption scheme SE. While they
use a combinatorial analysis [3, Lemma 1], we use a game
sequence. Theorem 4.2 proves strong undetectability of our
ASA assuming only that SE is randomized (ciphertexts have
non-trivial min entropy) and F is a PRF.
Related work. Simmons work on subliminal channels [15,
16, 17, 18] was an early indication of the danger of ASAs.
ASAs are part of the broader framework of kleptography
studied by Young and Yung [19, 20, 21, 23, 22]. Their
ideas seem prescient now. Back-doored blockciphers were
studied in [12, 10, 11]. Goh, Boneh, Pinkas and Golle [7]
show how to add key recovery to the SSL/TLS and SSH
protocols. Cryptographic reverse ﬁrewalls [9] represent an
architecture to counter ASAs via trusted code in network
perimeter ﬁlters. Dodis, Ganesh, Golovnev, Juels and Ris-
tenpart [6] provide a formal treatment of backdooring of
PRGs, another form of subversion. Russell, Tang, Yung and
Zhou [13] consider ASAs on one-way and trapdoor one-way
functions. The survey by Schneier, Fredrikson, Kohno and
Ristenpart [14] takes a broader look at subversion, providing
useful categorizations. In independent work that we will dis-
cuss in more depth after giving our deﬁnitions, Degabriele,
Farshim and Poettering [5] critique and reﬁne the deﬁnitions

Game PRFF
F
L ←$ {0, 1}(cid:96); bprf ←$ {0, 1}; C ← ∅
prf ←$ F Fn
b(cid:48)
Return (bprf = b(cid:48)
Fn(c)
If (bprf = 1) then yc ← F(L, c)
Else

prf )

If c (cid:54)∈ C then yc ←$ R
C ← C ∪ {c}

Return c

Figure 1: Game used to deﬁne prf advantage of ad-
versary F against function F.

of BPR [3]. Ateniese, Magri and Venturi [1] study ASAs on
signature schemes in particular giving stateful attacks based
on the methods of BPR [3]. We note that our methods can
be employed to make their attacks stateless as well.

2. NOTATION AND DEFINITIONS
Notation. If n is an integer then we let [n] = {1, . . . , n}.
If x is a string then |x| denotes its length while if S is a set
then |S| denotes it size. By ε we denote the empty string.
By x[i] we denote the i-th bit of a string x, for i ∈ [|x|].
By s ←$ S we denote picking s at random from set S. If A
is a randomized algorithm then y ← A(x1, . . . ; r) denotes
running A on inputs x1, . . . and coins r to deterministically
obtain output y, and y ←$ A(x1, . . .) denotes picking r at
random and letting y ← A(x1, . . . ; r). Deﬁnitions and proofs
use code-based games [4]. See Fig. 1 for an example of a
game. If G is a game then Pr[G] denotes the probability that
it returns true. We adopt the convention that the running
time of an adversary means the worst case execution time
of the adversary in the game that executes it, so that time
for game setup steps and time to compute answers to oracle
queries is included.
PRFs. We recall the deﬁnition as per [2, 8]. Let F :{0, 1}(cid:96) ×
{0, 1}∗ → R be a function taking a key L ∈ {0, 1}(cid:96) and
input c ∈ {0, 1}∗ to return an output F(L, c) ∈ R. Consider
game PRFF
F associated to F and adversary F . It provides
the adversary with an oracle Fn as shown. Let
F ] − 1

F (F ) = 2 Pr[PRF

Advprf

F

be the prf advantage of adversary F against function F.
In proofs we will use the standard fact that it can also be
expressed as
F (F )

Advprf

(1)

= Pr[PRF

F

F | bprf = 1] − (1 − Pr[PRF

F

F | bprf = 0]) .

3. ASA FRAMEWORK

We recall basic syntax of symmetric encryption. We then
provide our novel deﬁnitions for ASAs, namely strong unde-
tectability as well as adversary advantage in key recovery.
Symmetric encryption. A (symmetric) encryption scheme
SE speciﬁes the following. Via KSE ←$ {0, 1}SE.kl, one selects
a key of length SE.kl. Encryption algorithm SE.Enc takes
KSE, message m and coins r ∈ {0, 1}SE.rl to deterministi-

1433SE,A

Game SDETD
KA ←$ {0, 1}A.kl
b ←$ {0, 1}; σ ← ε; b(cid:48) ←$ D Enc
Return (b = b(cid:48))
Enc(K, m)
If (b = 1) then c ←$ SE.Enc(K, m)
Else (c, σ) ←$ A.Enc(KA, K, m, σ)
Return (c, σ)

SE,M

Game KRA
KSE ←$ {0, 1}SE.kl; KA ←$ {0, 1}A.kl; σ ← ε; σ(cid:48) ← ε
K ←$ A.ExtEnc(KA); Return (KSE = K)
Enc()
(m, σ(cid:48)) ←$ M(σ(cid:48))
(c, σ) ←$ A.Enc(KA, KSE, m, σ)
Return c

Figure 2: Games used to deﬁne detection and key re-
covery security of subversion A of encryption scheme
SE.

cally obtain ciphertext c ← SE.Enc(KSE, m; r). By c ←$
SE.Enc(KSE, m) we denote the operation r ←$ {0, 1}SE.rl ;
c ← SE.Enc(KSE, m; r). Decryption algorithm SE.Dec is de-
terministic and we require that

SE.Dec(KSE, SE.Enc(KSE, m; r)) = m

for all KSE, m, r.
ASAs. An algorithm substitution attack (ASA) A speciﬁes
the following. Via KA ←$ {0, 1}A.kl, one selects a key of
length A.kl. The subverted encryption algorithm A.Enc takes
KA, KSE, m and current state σ to produce ciphertext c and
updated state, (c, σ) ←$ A.Enc(KA, KSE, m, σ).
(Denoting
the state the same in input and output simply indicates an
update of this variable.) The idea is that A is speciﬁed by
big brother. Key KA is shared between the subverted en-
cryption algorithm A.Enc and its external accomplice A.Ext
who aims, from subverted ciphertexts, to violate security of
SE. Note that conceptually, A is an adversary (the ASA)
rather than a scheme, a departure in perspective from BPR
[3]. We say that A.Enc is stateless if the updated state it
returns is always the empty string ε, meaning its output for
any inputs KA, KSE, m, σ has the form (c, ε).
In this case
we might drop σ in both input and output, writing c ←$
A.Enc(KA, KSE, m).

We said that A’s goal is to violate security of SE. With no
further conditions, this is too easy, as explained in Section 1.
The goal for big brother is an attack that is undetectable yet
violates security of SE. We now turn to formalizing each of
these components.
Strong undetectability. Consider game SDET of Fig. 2
associated to encryption scheme SE, ASA A and a detection
adversary D. It can obtain via oracle Enc encryptions of
messages of its choice under keys of its choice, produced
either via SE.Enc (when b = 1) or via A.Enc (when b = 0),
and aims from examination of these ciphertexts to determine

b. Let

Advsdet

SE,A(D) = 2 Pr[SDET

D

SE,A] − 1 .

This is D’s advantage in detecting the subversion.

The state σ returned by Enc will always be the empty
string ε in the case b = 1 because SE.Enc is stateless. Thus,
if D ever sees σ (cid:54)= ε in a reply to a Enc query, it knows
that b = 0, meaning the subversion has been detected. Our
formalization thus eﬀectively implies that a subversion must
be stateless to be undetectable. A consequence of this is
that state reset, as can arise due to system reboot or cloning
to create a virtual machine, will not allow the ASA to be
detected, unlike for undetectability as per BPR [3]. This
exclusion of some simple and natural forms of detection not
covered by BPR [3] is the main consequence and intent of
the new deﬁnition.

However there are other directions as well. The view of
BPR [3] was that detection is performed by the decryptor.
Detection through state reset continues that perspective, for
this can in many cases lead to detection from the ciphertexts
alone. But strong undetectability also moves towards a per-
spective where the encryptor, not just the decryptor, may
be making some attempts at detection. We view the detec-
tor as having some sort of blackbox access to the encryption
code, so that it can pick inputs and see all outputs written
to memory. In particular, the detector not just knows, but
can pick, the encryption key K, and it can see any state
σ that the encryption code tries to maintain across invo-
cations. Thus D can supply, in calls to Enc, not just the
message, but any key K ∈ {0, 1}SE.kl of its choice for SE.Enc,
getting in response not just the ciphertext c, but also σ. This
obviously signiﬁcantly increases the power of the detector.
However we must be careful to note that we do not cap-
ture all possible detection strategies that a “real” detector
in such a position could mount. For example the detector
could measure the CPU time of an execution of the code
and compare this with the expected CPU time of the real
code. Or it could look at the number of calls to the under-
lying pseudo-random number generator that is being used
to obtain coins. These and other detection methods are not
covered by our deﬁnition.

The fact is that it impossible for an ASA to evade all
forms of detection. Our work aims to understand how far
we can push the boundary. Security in this domain is a
tradeoﬀ between detection eﬀort and attack success. Our
results indicate that detecting ASAs takes more eﬀort than
was previously thought.

We note that strong undetectability implies the BPR no-
tion of undetectability. A proof may be given by reduction,
the idea being as follows. Recall that in the detection game
of BPR [3], the undetectability adversary D(cid:48) has access to
an oracle Key that, given i, returns a key Ki ←$ {0, 1}SE.kl
for user i, and an oracle Enc that, given message M and
i, returns a ciphertext produced by running either SE.Enc
or A.Enc to encrypt M under Ki, the choice depending on
the challenge bit that D(cid:48) is trying to guess. Given such
a D(cid:48), we build a strong undetectability adversary D with
strong undetectability advantage at least the undetectabil-
ity advantage of D(cid:48). Our adversary D runs D(cid:48). When the
latter makes a query Key(i), adversary D itself picks Ki
←$ {0, 1}SE.kl and returns it to D(cid:48). When the latter makes
a query Enc(M, i), adversary D queries its own Enc oracle

1434with Ki, M to get back (c, σ) and returns c to D(cid:48). Finally
D returns the same decision as D(cid:48).

We note that the detectability game of BPR was explicitly
multi-user, meaning it involved multiple keys. The strong
undetectability game instead allows the adversary to query
Enc with any key of its choice. One advantage of this formu-
lation, as we have just illustrated, is that muti-user security
is a consequence.
Key recovery. The other side of the coin is what it means
for an ASA to succeed, meaning violate the security of the
users of SE. One measure, formalized in BPR [3], is dis-
tinguishability, meaning A succeeds if it can distinguish en-
cryptions of messages of its choice. Another measure is key
recovery, meaning A succeeds if it ﬁnds KSE. Distinguishing
is a strong measure for security but a weak one for attacks
(achieving it provides high security, but violating it entails
little loss) while key recovery is a weak measure for security
but a strong one for attacks (violating it is very damaging
but achieving it means little for security). Since our focus is
attacks, we target and formalize key recovery.
Game KR of Fig. 2 is parameterized by a message sam-
pler algorithm M that, given its current state σ(cid:48) returns the
next message m to be encrypted and updated state. It rep-
resents the choice of messages made by the sender. A wins
if A.Ext recovers the key KSE from the ciphertexts produced
by the subverted encryption algorithm A.Enc on messages
produced by M. (The state σ maintained by the latter is
entirely distinct from the state σ(cid:48) of M.) The key recovery
advantage of A is

Advkr

SE,M(A) = Pr[KRA

SE,M] .

Parametrization by M allows a ﬁne-grained taxonomy of
key recovery attacks. The less they assume about M, the
stronger they are. The strongest attack is one that works for
any M. This corresponds to an attack that works regard-
less of what messages the encrypter chooses to encrypt. A
somewhat weaker attack might work for certain message se-
quences, meaning some restricted class of samplers M. Our
ASA is of the stronger type.
Discussion and extensions. Game SDET of Fig. 2 has
been written for the case where encryption scheme SE is
stateless, since this is the case of interest for our attacks. It
can be extended to the case where SE is stateful.
In this
case, when b = 1, algorithm SE.Enc takes the current state
σ as an additional input and returns not just ciphertext c
but also an updated state σ. Additionally one should pro-
vide the adversary with a reset oracle Reset that resets the
state σ to ε. The notion is thus requiring that the detec-
tor cannot tell whether it is talking to the real or subverted
encryption algorithm even if it sees the state and can reset
it. Note that the reset oracle is redundant (and hence has
been omitted) in our present context because with state-
less schemes the deﬁnition already implies that a subversion
must be stateless as well, and with both stateless a reset
oracle is vacuous.

BPR [3] had required any ASA A to satisfy a decryptabil-
ity condition which asked that ciphertexts produced under
A.Enc(·, K,·,·) decrypted correctly under SE.Dec(K,·). We
have dropped this condition, so that decryptability holds
only to the extent that it is implied by strong undetectabil-
ity, which we think is more realistic from a detection per-

spective. However, the ASAs we provide do meet the de-
cryptability condition of BPR [3].

DFP [5] suggest that the BPR decryptability condition
is too strong. They suggest a relaxation, and then pro-
vide an ASA that is undetectable under the BPR deﬁnition,
meets their relaxed decryptability condition, and yet suc-
ceeds in that it violates the BPR subversion security deﬁni-
tion. However the DFP attack does not succeed in violating
our key recovery notion, and from a practical perspective,
is weak. In the DFP attack, A.Enc(KA, K, m, σ) returns K
when m = KA. That is, the attack requires that the attacker
can induce the encrpytor to encrypt the message m = KA.
But in practice this is quite hard and it is unlikely that a
“real” sender will ever encrypt this message. Our attacks are
much more powerful since the attacker succeeds regardless
of what messages the encryptor encrypts. This is captured
by the introduction of M in our key recovery deﬁnition and
the fact that the attack succeeds regardless of its choice. In
fact in our key recovery deﬁnition, the messages being en-
crypted in the attack cannot even depend on the subverter’s
key KA, since the latter is not given to M. The latter is why
the DFP attack [5] does not succeed under our key recovery
deﬁnition.

The issues here reﬂect, as we discussed above, that achiev-
ing a certain notion may provide good practical security, but
violating the same notion may not constitute an eﬀective
practical attack. (That is, insecurity is not really the oppo-
site of security. There is a lot in between.) Thus, achieving
security under the BPR subversion notion is a good target
for a scheme. But violating security under this notion need
not be (and, in the case of DFP [5], is not) an eﬀective at-
tack. Conversely, our key recovery notion is a good one for
attacks but not a good one for security: violating it consti-
tutes a powerful attack, but achieving it provides only weak
security. As an analogy, indistinguishability (semantic se-
curity) is accepted as a good security target for encryption
schemes that one wants constructions to reach, but violating
it is a weak attack.

4. ATTACK AND ANALYSIS

We present our ASA, having the following properties: (1)
It is stateless and proven strongly undetectable (2) It breaks
any given encryption scheme that has a non-trivial amount
of randomization, and (3) break here is in the strong sense of
key recovery for arbitrary message distributions. The attack
is simple to specify but the analysis is more challenging. We
provide a careful analysis to establish both key recovery and
strong undetectability with concrete bounds. From these
results we can extract concrete values of the parameters for
a concrete attack.
Preliminaries. As we discussed, we need SE to have non-
trivial randomization. (Otherwise, a deterministic scheme is
just a special case of a randomized scheme.) Formally, this
means that ciphertexts have some min-entropy. To measure
this we deﬁne the min-entropy H∞(SE) of the scheme SE
via

2

−H∞(SE) = max

KSE,m,c

Pr[SE.Enc(KSE, m; r) = c]

Here, with KSE, m, c ﬁxed, the probability is over a random
choice of r from {0, 1}SE.rl. Our results will assume that
2−H∞(SE) is negligible. We note that we could use collision
entropy in place of min entropy.

1435A.Enc(KA, KSE, m, σ)
j ← 0
Repeat

j ← j + 1
r ←$ {0, 1}SE.rl
c ← SE.Enc(KSE, m; r)
(v, t) ← F(KA, c)
success ← (KSE[t] = v)
out-of-time ← (j = s)

Until (success OR out-of-time)
Return (c, )

A.Ext(KA)
K ← 0SE.kl
For i = 1, . . . , q do

c ←$ Enc()
(v, t) ← F(KA, c)
K[t] ← v
Return K

Figure 3: ASA A for encryption scheme SE has al-
gorithms A.Enc and A.Ext as shown above. Here
F : {0, 1}A.kl × {0, 1}∗ → {0, 1} × [SE.kl] is a PRF used
in the attack and q, s ≥ 1 are parameters of the at-
tack.

Attack description. Let SE denote the target encryption
scheme and let F : {0, 1}F.kl × {0, 1}∗ → {0, 1} × [SE.kl] be
a PRF and key length A.kl = F.kl, meaning KA will be a
key for the PRF F deﬁning the function f (·) = F(KA,·).
The algorithms A.Enc and A.Ext are shown in Fig. 3. Here
s, q ≥ 1 are parameters of the attack. (We will show that
quite small values of these suﬃce.)

Subverted encryption algorithm A.Enc is given KA, KSE,
message m and a state σ that it ignores. (It will be stateless
and thus it will always be that σ = ε.) Its goal is to pick
r so that if c = SE.Enc(KSE, m; r) and (v, t) = F(KA, c)
then KSE[t] = v. It would then return c. When A.Ext picks
up c, it can compute (v, t) = F (KSE, c) and set K[t] = v.
An appropriate choice of q will ensure that A.Ext eventually
gets all bits of the key, meaning K = KSE except with tiny
probability.

Conceptually, then, we imagine A.Enc as trying to pick r
at random subject to the constraint that if c = SE.Enc(KSE,
m; r) and (v, t) = F(KA, c) then KSE[t] = v. However it is
not clear how to directly pick r in this way. Indeed, such an r
may not even exist. To resolve this, A.Enc in Fig. 3 samples
by picking r at random from the full space {0, 1}SE.rl until
either r satisﬁes the desired condition (at which point the
ﬂag success becomes true) or the process exceeds the num-
ber of allowed sampling attempts s (at which point the ﬂag
out-of-time becomes true). The tradeoﬀ is that for eﬃciency
we want s to be quite small but the smaller it is the farther
is the distribution of r from the conceptually desired one.
The theorems and analyses that follow will deal with these
issues and show how to appropriately pick both s and q for
an eﬀective yet eﬃcient attack.
Key recovery. The following theorem lower bounds the
key recovery advantage of our ASA A of Fig. 3, showing
that it is close to one for reasonable values of the parameters,

meaning the attack can eﬃciently and successfully recover
the target key.

We recall that our convention is that adversary running
time refers to the time of the game in which the adversary
executes, so that the time of oracle calls is included. Thus
for example the reason the time for M does not show up in
the time of F below is that KR runs M already.

Theorem 4.1. Let SE be a symmetric encryption scheme
and let k = SE.kl. Let F :{0, 1}F.kl ×{0, 1}∗ → {0, 1}× [k] be
a PRF. Let q, s ≥ 1 and let A be deﬁned as in Fig. 3. Let
M be an arbitrary message distribution. Then we can build
PRF adversary F such that

Advkr

SE,M(A) ≥ 1 − Advprf

F (F ) − (q, s, k)

(2)

where

(q, s, k) ≤ ke

−q/k + q2

−s + q2s2 · 2

(3)
The running time of F is about the sum of the running times
of A.Enc and A.Ext, and it makes at most qs oracle queries.

−H∞(SE)−1 .

For example, the key for SE is typically an AES key so that
k = SE.kl = 128. We could let q = 128 · 7 = 896 and
s = 13, which implies ke−q/k + q2−s ≤ 1/4. We can assume
F (F ) is negligible. Then as long as H∞(SE) ≥ 28,
Advprf
our attack has advantage around 1/2. The q, s values are
quite small, making the attack quite practical.
That M may be any distribution makes the ASA partic-
ularly strong. The distribution M represents the choice of
messages made by the encryptor. We are saying the attack
works regardless of these choices. It is thus a known message
attack, not a chosen message attack.

Proof of Theorem 4.1. Game H0 of Fig. 4 includes the
boxed code while H1 does not. Game H0 implements game
KR of Fig. 2 with A being as deﬁned in Fig. 3, with two
changes: (1) F(KA,·) is replaced by a lazily sampled random
function, and (2) the game returns true when key recovery
fails rather than when it succeeds. Let prf adversary F
be as deﬁned in the second panel of Fig. 4. It uses its Fn
oracle where A would use F(KA,·). It returns 1 when key
recovery fails and 0 when it succeeds. Letting bprf denote
the challenge bit in game PRF, we have

Pr[PRF
1 − Pr[PRF

F

F | bprf = 1] ≥ 1 − Advkr
F | bprf = 0] = Pr[H0] .

F

SE(A)

The reason the ﬁrst equation above is an inequality rather
than an equality is that A.Ext initially sets all bits of K to 0
and, so, for a particular bit, it may by chance end up having
the right value even when that bit is not set in the For loop.
Now, using Eq. (1), we have

Advprf

F (F )

= Pr[PRF
≥ 1 − Advkr

F

F | bprf = 1] − (1 − Pr[PRF
SE(A) − Pr[H0] .

F

F | bprf = 0])

Re-arranging terms, we have

Advkr

SE(A) ≥ 1 − Advprf

F (F ) − Pr[H0] .

We let

(q, s, k) = Pr[H0] .

This establishes Eq. (2). We now proceed to upper bound
(q, s, k). Since games H0, H1 are identical until bad, the

1436Game H0 , H1
KSE ←$ {0, 1}SE.kl; σ(cid:48) ← ε; C ← ∅; T ← ∅
For i = 1, . . . , q do
j ← 0; out-of-time ← false
(m, σ(cid:48)) ←$ M(σ(cid:48))
Repeat

j ← j + 1; r ←$ {0, 1}SE.rl
c ← SE.Enc(KSE, m; r)
(v, t) ←$ {0, 1} × [k]
If (c ∈ C) then

bad ← true; (v, t) ← (vc(cid:48) , tc(cid:48) )

(vc, tc) ← (v, t)
C ← C ∪ {c}
success ← (KSE[tc] = vc)
out-of-time ← (j = s)

Until (success OR out-of-time)
If success then T ← T ∪ {t}
Else T ← T \ {t}

Return (T (cid:54)= [k])

Adversary F
KSE ←$ {0, 1}SE.kl; σ(cid:48) ← ε
T ← ∅
For i = 1, . . . , q do
j ← 0; out-of-time ← false
(m, σ(cid:48)) ←$ M(σ(cid:48))
Repeat

j ← j + 1; r ←$ {0, 1}SE.rl
c ← SE.Enc(KSE, m; r)
(vc, tc) ←$ Fn(c)
success ← (KSE[tc] = vc)
out-of-time ← (j = s)

Until (success OR out-of-time)
If success then T ← T ∪ {t}
Else T ← T \ {t}

If (T (cid:54)= [k]) then return 1
Else return 0

Game H4
KSE ←$ {0, 1}SE.kl; T ← ∅
For i = 1, . . . , q do

Repeat

(v, t) ←$ {0, 1} × [k]

Until (KSE[t] = v)
T ← T ∪ {t}
Return (T (cid:54)= [k])

Game H2 , H3
KSE ←$ {0, 1}SE.kl; T ← ∅
For i = 1, . . . , q do

j ← 0; out-of-time ← false
Repeat

j ← j + 1
(v, t) ←$ {0, 1} × [k]
success ← (KSE[t] = v)
If (j = s AND success = false) then

bad ← true; out-of-time ← true

Until (success OR out-of-time)
If success then T ← T ∪ {t}
Else T ← T \ {t}

Return (T (cid:54)= [k])

Game H5
KSE ←$ {0, 1}SE.kl; T ← ∅
For i = 1, . . . , q do
t ←$ [k]; T ← T ∪ {t}
For (cid:96) = 1, . . . , k do bad(cid:96) ← ((cid:96) (cid:54)∈ T )
bad ← (bad1 ∨ · · · ∨ badk)
Return bad

Figure 4: Games and adversary for proof of Theorem 4.1.

fundamental lemma of game playing [4] says that

(q, s, k) = Pr[H0] ≤ Pr[H1] + Pr[H1 sets bad] .

Game H1 sets bad when there is a collision in the ciphertexts.
Since at most qs ciphertexts are created we have

(cid:32)

(cid:33)

qs
2

Pr[H1 sets bad] ≤

−H∞(SE)

· 2

≤ q2s2 · 2

−H∞(SE)−1 .

We now proceed to upper bound Pr[H1]. The ciphertexts
being chosen in this game are not relevant to its outcome,
since (vc, tc) is chosen at random each time. Furthermore,
the setting of the out-of-time ﬂag only has an eﬀect on the
behavior of the game if the success ﬂag is not already set at
the time. This leads to game H2 of Fig. 4, which includes
the boxed code. We have

Pr[H1] = Pr[H2] ≤ Pr[H3] + Pr[H3 sets bad] ,

the inequality by the fundamental lemma of game playing
[4] because games H2, H3 are identical until bad. In game
H3 the boxed code is not included, with the result that the
repeat loop continues until success. Since each iteration is
successful with probability 1/2 we have
Pr[H3 sets bad] ≤ q2

−s .

We proceed to upper bound Pr[H3]. Since the sampling in
H3 continues until success we have

Pr[H3] = Pr[H4] = Pr[H5] .

We proceed to upper bound Pr[H5]. Let p(cid:96) = Pr[H5 sets bad(cid:96)]
for (cid:96) ∈ [k]. Now we can use a standard coupon collector

problem analysis. For any particular (cid:96) ∈ [k] we have

(cid:18)

(cid:19)q ≤ e

−q/k .

p(cid:96) =

1 − 1
k

Thus

−q/k .
Putting the inequalities together yields Eq. (3).

Pr[H5] ≤ p1 + ··· + pk ≤ ke

Strong undetectability. The following theorem says that
the ASA of our adversary A of Fig. 3 is strongly unde-
tectable.

Theorem 4.2. Let SE be a symmetric encryption scheme
and let k = SE.kl. Let F : {0, 1}F.kl × {0, 1}∗ → {0, 1} × [k]
be a PRF. Let q, s ≥ 1 and let A be deﬁned as in Fig. 3.
Let D be an adversary against the strong undetectability of
A that makes at most n queries to its Enc oracle. Then we
can build PRF adversary F such that

Advsdet

SE,A(D) ≤ 2Advprf

F (F ) + n2s2 · 2

(4)
The running time of F is about that of D and it makes at
most ns oracle queries.

−H∞(SE).

Proof of Theorem 4.2. Game I0 of Fig. 5 implements
SDET with F(KA,·) replaced by a lazily sampled random
function. Let prf adversary F be as deﬁned in the second
panel of Fig. 5. It runs D, itself simulating the latter’s Enc
oracle, in the process appealing to its own Fn oracle. Letting
bprf denote the challenge bit in game PRF, we have

Pr[PRF
1 − Pr[PRF

F

F | bprf = 1] =
1
2
F | bprf = 0] = Pr[I0] .

1
2

+

F

Advsdet

SE,A(D)

1437Game I0
b ←$ {0, 1}; C ← ∅
b(cid:48) ←$ D Enc; Return (b = b(cid:48))
Enc(K, m)
If (b = 1) then c ←$ SE.Enc(K, m)
Else

j ← 0; out-of-time ← false
Repeat

j ← j + 1; r ←$ {0, 1}SE.rl
c ← SE.Enc(K, m; r)
(v, t) ←$ {0, 1} × [k]
If (c ∈ C) then (v, t) ← (vc(cid:48) , tc(cid:48) )
(vc, tc) ← (v, t)
C ← C ∪ {c}
success ← (K[tc] = vc)
out-of-time ← (j = s)

Adversary F
b ←$ {0, 1}
b(cid:48) ←$ D Enc
If (b = b(cid:48)) then return 1
Else return 0
Enc(K, m)
If (b = 1) then c ←$ SE.Enc(K, m)
Else

j ← 0; out-of-time ← false
Repeat

j ← j + 1; r ←$ {0, 1}SE.rl
c ← SE.Enc(K, m; r)
(vc, tc) ←$ Fn(c)
success ← (K[tc] = vc)
out-of-time ← (j = s)

Until (success OR out-of-time)

Until (success OR out-of-time)

Return (c, )

Return (c, )

Game I1, I2
C ← ∅
b(cid:48) ←$ D Enc; Return (b(cid:48) = 1)
Enc(K, m)
j ← 0;
out-of-time ← false
Repeat

j ← j + 1; r ←$ {0, 1}SE.rl
c ← SE.Enc(K, m; r)
(v, t) ←$ {0, 1} × [k]
If (c ∈ C) then

bad ←$ true; (v, t) ← (vc(cid:48) , tc(cid:48) )

(vc, tc) ← (v, t)
C ← C ∪ {c}
success ← (K[tc] = vc)
out-of-time ← (j = s)

Until (success OR out-of-time)
Return (c, )

Figure 5: Games an adversary for proof of Theorem 4.2.

Thus, using Eq. (1), we have

Advprf

F (F )

= Pr[PRF

=

1
2

+

1
2

F

F | bprf = 1] − (1 − Pr[PRF
Advsdet

SE,A(D) − Pr[I0] .

F

F | bprf = 0])

Re-arranging terms, we have

Advsdet

SE,A(D) ≤ 2Advprf

F (F ) + (2 Pr[I0] − 1) .

We proceed to upper bound 2 Pr[I0] − 1. Consider games
I1, I2 of Fig. 5. Game I2 includes the boxed code while I1
does not. In both, (vc, tc) is picked at random. However,
in I2, if it turns out that c was already seen, then the game
corrects, resetting (vc, tc) to its prior value. As a result, I2
is equivalent to I0 with the challenge bit b in the latter set
to b = 1. On the other hand, in I1, the choice of (vc, tc)
is independent of the choice of c and does not impact the
distribution of the latter, making it equivalent to I0 with
b = 0. Thus we have

Pr[I2] = Pr[I0 | b = 1]
Pr[I1] = Pr[I0 | b = 0] .

Additionally, games I0, I1 are identical until bad. Via the
fundamental lemma of game playing [4] we have

2 Pr[I0] − 1 = Pr[I0 | b = 1] − Pr[I0 | b = 0]

= Pr[I2] − Pr[I1]
≤ Pr[I1 sets bad] .

Game I1 sets bad whenever the same value of c is returned
twice by SE.Enc. There are ns queries to Enc. Thus

(cid:32)

(cid:33)

Pr[I1 sets bad] ≤

−H∞(SE)

· 2

ns
2

≤ n2s2 · 2

−H∞(SE)−1 .

Putting everything together gives the desired Eq. (4).

Discussion. We do not expect that most users will mount
involved detection eﬀorts. But the weakness of the ASA of
BPR [3] is that is is relatively easily detectable, even without
much eﬀort, due to its use of state. The most obvious way for
this to happen is that the state is reset, for example due to
a system reboot. When this happens, the decrypter will be
able to detect the subversion. This, however, is not captured
by their notion of detectability. Strong undetectability ﬁlls
the gap. Our new ASA, achieving this and in particular
being stateless, is harder to detect and thus more dangerous.
In a world of subversion, there are no panaceas. The ex-
tent to which big brother will risk detection in order to suc-
cessfully recover a key is not known, but it would be natural
that, all else being equal, big brother will pick the ASA that
minimizes the chance of detection. This means an ASA like
ours. Our work is intended to increase awareness and spur
the search for deterrents.

5. DEFENSES

BPR [3] present schemes that are subversion resilient.
They deﬁne unique ciphertext schemes, show they are sub-
version resilient, and then provide several ways to build
them. These schemes are deterministic and stateful, mean-
ing the encryptor and decryptor have to maintain a synchro-
nized state.

Having strengthened the BPR undetectability condition
to strong undetectability, a natural question is whether sub-
version resilience can still be achieved. In fact this strength-
ening makes no diﬀerence, and the schemes of BPR continue
to achieve subversion resilience. This is because a subversion
resilient scheme according to BPR [3] is one where any sub-
version satisfying the decryptability condition cannot suc-
ceed in their subversion game. Decryptability means that
ciphertexts created by the subverted encryption algorithm
decrypt properly under the real decryption algorithm, and
it can be seen as represented a particular and ﬁxed form of
undetectability.

DFP [5] critique the BPR decryptability condition and
instead suggest an alternative formulation of detectability

1438represented by their DETECT game in which the subver-
sion and detection adversaries run together, the latter get-
ting a transcript of the interaction of the former with its ora-
cles. They show that unique ciphertext schemes continue to
achieve their notion. In this context, consideration of strong
undetectability would involve modifying their game to a new
one, SDETECT. For example one might return the state to
the detection adversary as part of the transcript, and also
add a reset oracle Reset to allow state reset. Then the
question is whether unique ciphertext schemes continue to
meet this new deﬁnition. They do.

6. CONCLUSIONS

This paper shows that algorithm substitution attacks

(ASAs) are very powerful with regard to compromising se-
curity of randomized symmetric encryption schemes. The
new ASA we provide not only breaks all such schemes (in
contrast to prior ones that broke only some) but is much
harder to detect and thus deter, due to meeting the no-
tion of strong undetectability we introduce. Our analysis
shows that the ASA succeeds for practical values of the pa-
rameters. Our work serves to increase awareness of what is
possible with ASAs, to show that the move to deterministic
scheme to achieve security against ASAs, made by BPR [3],
is necessary and to spur the search for other ways to deter
and counter ASAs.

7. ACKNOWLEDGMENTS

Bellare and Jaeger were supported in part by NSF grants
CNS-1116800 and CNS-1228890. This work was done in
part while Bellare was visiting the Simons Institute for the
Theory of Computing, supported by the Simons Foundation
and by the DIMACS/Simons Collaboration in Cryptography
through NSF grant CNS-1523467.

8. REFERENCES
[1] G. Ateniese, B. Magri, and D. Venturi.

Subversion-resilient signature schemes. Cryptology
ePrint Archive, Report 2015/517, 2015.
http://eprint.iacr.org/2015/517.

[2] M. Bellare, J. Kilian, and P. Rogaway. The security of

cipher block chaining. In Y. Desmedt, editor,
CRYPTO’94, volume 839 of LNCS, pages 341–358.
Springer, Aug. 1994.

[3] M. Bellare, K. G. Paterson, and P. Rogaway. Security
of symmetric encryption against mass surveillance. In
J. A. Garay and R. Gennaro, editors, CRYPTO 2014,
Part I, volume 8616 of LNCS, pages 1–19. Springer,
Aug. 2014.

[4] M. Bellare and P. Rogaway. The security of triple

encryption and a framework for code-based
game-playing proofs. In S. Vaudenay, editor,
EUROCRYPT 2006, volume 4004 of LNCS, pages
409–426. Springer, May / June 2006.

[5] J. P. Degabriele, P. Farshim, and B. Poettering. A

more cautious approach to security against mass
surveillance. In G. Leander, editor, FSE 2015, volume
9054 of LNCS. Springer, Mar. 2015.

[6] Y. Dodis, C. Ganesh, A. Golovnev, A. Juels, and
T. Ristenpart. A formal treatment of backdoored
pseudorandom generators. In E. Oswald and

M. Fischlin, editors, EUROCRYPT 2015, Part I,
volume 9056 of LNCS, pages 101–126. Springer, Apr.
2015.

[7] E.-J. Goh, D. Boneh, B. Pinkas, and P. Golle. The

design and implementation of protocol-based hidden
key recovery. In C. Boyd and W. Mao, editors,
ISC 2003, volume 2851 of LNCS, pages 165–179.
Springer, Oct. 2003.

[8] O. Goldreich, S. Goldwasser, and S. Micali. How to

construct random functions. Journal of the ACM,
33(4):792–807, Oct. 1986.

[9] I. Mironov and N. Stephens-Davidowitz.

Cryptographic reverse ﬁrewalls. In E. Oswald and
M. Fischlin, editors, EUROCRYPT 2015, Part II,
volume 9057 of LNCS, pages 657–686. Springer, Apr.
2015.

[10] J. Patarin and L. Goubin. Asymmetric cryptography

with S-boxes. In Y. Han, T. Okamoto, and S. Qing,
editors, ICICS 97, volume 1334 of LNCS, pages
369–380. Springer, Nov. 1997.

[11] K. G. Paterson. Imprimitive permutation groups and
trapdoors in iterated block ciphers. In L. R. Knudsen,
editor, FSE’99, volume 1636 of LNCS, pages 201–214.
Springer, Mar. 1999.

[12] V. Rijmen and B. Preneel. A family of trapdoor

ciphers. In E. Biham, editor, FSE’97, volume 1267 of
LNCS, pages 139–148. Springer, Jan. 1997.

[13] A. Russell, Q. Tang, M. Yung, and H.-S. Zhou.

Cliptography: Clipping the power of kleptographic
attacks. Cryptology ePrint Archive, Report 2015/695,
2015. http://eprint.iacr.org/.

[14] B. Schneier, M. Fredrikson, T. Kohno, and

T. Ristenpart. Surreptitiously weakening
cryptographic systems. Cryptology ePrint Archive,
Report 2015/097, 2015.
http://eprint.iacr.org/2015/097.

[15] G. J. Simmons. The prisoners’ problem and the

subliminal channel. In D. Chaum, editor,
CRYPTO’83, pages 51–67. Plenum Press, New York,
USA, 1983.

[16] G. J. Simmons. The subliminal channel and digital
signature. In T. Beth, N. Cot, and I. Ingemarsson,
editors, EUROCRYPT’84, volume 209 of LNCS, pages
364–378. Springer, Apr. 1985.

[17] G. J. Simmons. A secure subliminal channel (?). In
H. C. Williams, editor, CRYPTO’85, volume 218 of
LNCS, pages 33–41. Springer, Aug. 1986.

[18] G. J. Simmons. Subliminal communication is easy

using the DSA. In T. Helleseth, editor,
EUROCRYPT’93, volume 765 of LNCS, pages
218–232. Springer, May 1994.

[19] A. Young and M. Yung. The dark side of “black-box”

cryptography, or: Should we trust capstone? In
N. Koblitz, editor, CRYPTO’96, volume 1109 of
LNCS, pages 89–103. Springer, Aug. 1996.

[20] A. Young and M. Yung. Kleptography: Using

cryptography against cryptography. In W. Fumy,
editor, EUROCRYPT’97, volume 1233 of LNCS,
pages 62–74. Springer, May 1997.

1439[21] A. Young and M. Yung. Monkey: Black-Box

symmetric ciphers designed for MONopolizing KEYs.
In S. Vaudenay, editor, FSE’98, volume 1372 of LNCS,
pages 122–133. Springer, Mar. 1998.

[22] A. Young and M. Yung. A subliminal channel in secret
block ciphers. In H. Handschuh and A. Hasan, editors,
SAC 2004, volume 3357 of LNCS, pages 198–211.
Springer, Aug. 2004.

[23] A. L. Young and M. Yung. Backdoor attacks on

black-box ciphers exploiting low-entropy plaintexts. In
R. Safavi-Naini and J. Seberry, editors, ACISP 03,
volume 2727 of LNCS, pages 297–311. Springer, July
2003.

1440