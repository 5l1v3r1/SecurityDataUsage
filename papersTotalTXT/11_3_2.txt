P2C: Understanding Output Data Files via On-the-Fly Transformation from Producer

to Consumer Executions

Yonghwi Kwon∗, Fei Peng∗, Dohyeong Kim∗, Kyungtae Kim∗, Xiangyu Zhang∗, Dongyan Xu∗,

Vinod Yegneswaran†, and John Qian‡

∗Department of Computer Science, Purdue University

Email: {kwon58, pengf, kim1051, kim1798, xyzhang, dxu}@cs.purdue.edu

†SRI International

Email: vinod@csl.sri.com

‡Cisco Systems

Email: johnq@cisco.com

Abstract—In cyber attack analysis, it is often highly desirable
to understand the meaning of an unknown ﬁle or network
message in the absence of their consumer (i.e. the program
that parses and understands the ﬁle/message). For example,
a malware may stealthily collect information from a victim
machine, store them as a ﬁle and later send it to a remote
server. P2C is a novel technique that can parse and understand
unknown ﬁles and network messages. Given a ﬁle/message that
was generated in the past without the presence of any monitoring
techniques, and a set of potential producers of the ﬁle/message,
P2C systematically explores the execution paths in the producers
without requiring any inputs. In the mean time,
it tries to
transform a producer execution to a consumer execution that
closely resembles the ideal consumer execution that can parse
the given unknown ﬁle/message. In particular, when a write
operation is encountered in the original execution, P2C performs
the opposite read operation on the unknown ﬁle/message and
patches the original execution with the loaded value. In order
to handle correlations between data ﬁelds in the ﬁle/message,
P2C follows a trial-and-error approach to look for the correct
transformation until the ﬁle/message can be parsed and the
meaning of their ﬁelds can be disclosed. Our experiments on a
set of real world applications demonstrate P2C is highly effective.

I.

INTRODUCTION

Understanding data ﬁles and network messages with un-
known types or unknown structures is a prominent security
challenge. Consider the following scenario: a user downloads
and installs an Internet freeware that provides some desirable
functionalities. After using the freeware for a period of time,
she ﬁnds that some mysterious binary ﬁles are generated on
her hard disk. While these may be normal data ﬁles used by
the freeware, they could also contain private data such as
personal proﬁle, contact list, and even key-strokes that the
freeware has stealthily collected from the victim machine.
The consumer of these data ﬁles is often not present on the
victim machine. In other words, there is not a program on

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23318

the victim machine that can parse and understand these data
ﬁles. Consider another scenario in which network monitoring
is deployed on an enterprise network. Assume some machines
are infected by an Advanced Persistent Threat (APT) malware,
which stays inactive until the targeted attack date is getting
close. That is the time the malware starts to communicate with
the remote Command and Control (C&C) server to coordinate
the attack. The network monitoring system picks up some
packets to a rarely visited URL. It
is highly desirable to
understand the meaning of the packets. However, the consumer
of the packets is on the remote site. The aforementioned two
scenarios represent a prominent challenge: Can we understand
an existing ﬁle/message (generated in the past) with unknown
format and unknown meanings in the absence of the consumer
of the ﬁle/message. This paper aims to address the problem.

There are a large pool of existing works on protocol reverse
engineering [5], [12], [21], [6], [16], [4], [20] and input ﬁle
format reverse engineering [12], [13]. These techniques work
by monitoring the execution of consumer, that is, how the
network messages/ﬁles are parsed and processed. For example,
if consecutive bytes in an input ﬁle are accessed by consecutive
instances of the same instruction,
these consecutive bytes
often constitute a buffer ﬁeld. Most of these techniques focus
on disclosing the syntactic structure of input ﬁles/messages.
There are type reverse engineering techniques that can recover
variable types, semantics and data structure deﬁnitions from
stripped binaries [4], [14], [10], [19]. These techniques track
data ﬂow between variables and API functions with known
interfaces. For example, if a variable has its value passed to a
parameter in strlen(), this variable must be a string pointer.
They can be combined with the aforementioned protocol/input-
ﬁle-format reverse engineering techniques to derive both the
syntax and semantics of input ﬁles/messages. However, the
biggest limitation for most of these techniques is that they
require the presence of the consumer. Some may not require
the consumer [4], [20], but they require the user to provide
inputs to drive producer execution (in order to apply dynamic
analysis) and monitor execution that produced ﬁles/messages
with the exact same format as the unknown ﬁle or message. In
our scenario, the ﬁle/message was generated in the past without
any monitoring. The user knows a set of potential producers
but she does not know which one generated the ﬁle/message or
which function of the producer generated it. She may not even
know how to run the producer (e.g. a botnet malware without
the presence of the C&C server may not run properly).

Lim et al. proposed a technique that performs static analy-
sis on producer binaries to derive the syntactic structure of
an output ﬁle [11]. It generates a regular expression from
program structure, which can be used to parse output ﬁles. For
example, a ﬁle write inside a loop leads to a kleene closure in
the resulting regular expression. However, the technique over-
approximates output format due to the conservativeness of the
underlying static analysis. It cannot denote constraints between
ﬁelds such as a preceding ﬁeld describing the length of the
following ﬁeld. It may generate regular expression such as “(4
bytes)∗(4 bytes)∗” to denote two consecutive buffer
ﬁelds, not being able to express the constraints of/between
the two buffers. Note that this regular expression can parse
any output ﬁles. But the resulting parse tree unfortunately does
not reﬂect the real structure. Furthermore, the technique cannot
associate meanings to data ﬁelds.

In [8], Driscoll et al. have a nice observation that producer
and consumer are symmetric. Although the technique has a
different goal, which is to statically verify the correctness of
a producer by checking its conformance to the corresponding
consumer or vice versa, the observation inspired our solution,
called P2C. The basic idea of P2C is the following. Given
a ﬁle1 that we want to understand and a potential producer
binary, we will
leverage a recent binary forced-execution
technique [17] to explore the paths of the binary, by concretely
executing the producer along a large number of paths without
requiring any inputs. When a ﬁle open-for-write operation is
encountered, the operation may be the place where the subject
ﬁle was created, P2C starts to monitor the producer execution
and transform it to the corresponding consumer execution. In
particular, when a ﬁle write is encountered, it performs the
opposite read on the subject ﬁle. The values that are read are
patched to the execution such that the following operations can
be performed properly, in a way closely resembling the ideal
consumer execution. For example, by transforming a buffer size
write to the corresponding buffer size read from the subject ﬁle
and setting the size variable accordingly in the execution, when
the following buffer write is transformed to the corresponding
buffer read, the proper number of bytes are read. Once the
ﬁle can be correctly parsed, data ﬂow tracking based reverse
engineering technique can be used to associate semantics to
the ﬁelds in memory.

Our contributions are summarized in the following.
• We propose the novel idea of on-the-ﬂy transformation
from a producer execution to a consumer execution
to understand unknown ﬁles/messages that were gen-
erated in the past, without the presence of the real
consumers. In fact, we ﬁnd that in some cases, the
transformed consumers are even better than the real
consumers as the real ones sometimes skip data ﬁelds.
The technique does not require the user to know the
precise producer or how to run a potential producer
binary.

• We identify that the prominent technical challenge
lies in handling correlations between ﬁelds. In some
cases, such ﬁelds correlations are not sufﬁciently ex-
posed from the producer logic. As a result, preceding

1While P2C works on both ﬁles and network messages, we will focus our

discussion on ﬁles. Handling messages is similar.

symmetric reads in a transformed execution may not
provide enough guidance for the following correlated
symmetric reads. We have formally described the
nature of the problem and proposed an iterative search
based algorithm to address the problem.

• We have evaluated P2C on a variety of real world
binary programs. Our results show that P2C is able
to correctly parse their output ﬁles or messages and
disclose the correct meanings for most ﬁelds.

II. DEMONSTRATIVE EXAMPLE

In this section, we use an example to illustrate P2C. The
code snippet of the example is presented in Fig. 1. The program
allows users to create accounts and save account information
to a ﬁle. Given a data ﬁle that was generated previously and
the program itself, our goal is to understand the ﬁle, including
identifying individual data ﬁelds and their types and meanings.
Assume the program only serves as the producer of data ﬁles
and it does not have the consumer (parsing) logic. As such,
existing input format reverse engineering techniques [5], [12],
[13] that rely on observing how a ﬁle is parsed cannot be
applied.

As shown in Fig. 1, the program has two related data
structures. Struct header represents the header information
of the output ﬁle, which contains the type of the accounts
(e.g., type 0, 1, and 2, denoting different permissions), the
number of accounts, the checksum of the ﬁle, and the name
of the group of accounts in this ﬁle (e.g., “basic” and
“silver_member”). Struct account_entry represents
the information for each account, including the id, the creation
date, and the balance. Method create_account() is used
to create accounts. It ﬁrst allocates space for a new account and
saves it to the accounts[] array (line 22). It also initializes
the creation date related ﬁelds by calling system API functions
(lines 23, 24 and 26). It then sends an email using the newly
created id to notify the account creation (line 28). Method
output() emits account information to a ﬁle. It ﬁrst emits
a magic number (line 45). It then sets the header ﬁelds (lines
46-47). It computes the size of the header (line 48), which
is dependent on the length of the name ﬁeld in the header
struct. It emits the header size (line 49), followed by the header
(line 50). After that, it uses a loop (lines 51-52) to emit the
individual accounts.

Assume in a previous native execution of the program,
an output ﬁle was emitted as Fig 2 (c). Now we want to
understand the structure of the ﬁle and the semantics of the
individual ﬁelds of the ﬁle.

We ﬁrst need an effective execution path exploration tool to
identify all the output ﬁle creation operations (e.g. fopen()
for writes). We decide to leverage a binary forced-execution
platform we recently developed, called X-Force [17], to meet
this requirement.

X-Force executes an x86 binary program without requiring
any inputs. It supplies random inputs when needed. It has an
exception recovery scheme that suppresses runtime exceptions.
For example, it allocates memory on-demand when an invalid
pointer is de-referenced. At runtime, it also systematically

2

Next, P2C leverages the type reverse-engineering capability
in X-Force to associate types and semantic tags to the ﬁelds
from the subject ﬁle. For example, in the original execution,
the year ﬁeld of accounts[0] emitted at line 52 has data
ﬂow from the library call localtime() at line 24. This
allows us to type the year ﬁeld of accounts[0] in the
original execution, which in turn types the year ﬁelds of
accounts[0] and accounts[1] at line 52’ through the
symmetry between the original execution and the transformed
execution. Similarly, the data ﬂow between lines 25 and 28
about the id ﬁeld indicates this ﬁeld contains an email id. The
data ﬂow between 25 and 52 further allows P2C to determine
that the id ﬁelds of accounts[0-1] loaded at 52’ (in the
transformed execution) are also email ids.

Observe that through such a transformation procedure, P2C
is able to identify and type the ﬁelds from the ﬁle in Fig. 2
(c), which is not the ﬁle generated by the original execution
(i.e. Fig. 2 (b)).

We want to point out that there are three observations

critical to the effectiveness of P2C.

•

•

•

The producer and consumer logics of the same kind
of data ﬁles have symmetric structures. The write
operations that generate a data ﬁle have the corre-
sponding read operations in the consumer. The essence
of P2C is to leverage the control ﬂow in the producer
to generate the sequence of write operations such
that the corresponding reads can be performed to
parse the subject ﬁle. We will discuss how P2C can
handle rare cases in which producers and consumers
are asymmetric in Section V.
A data ﬁle is often self-contained, meaning that it
has enough information to allow itself to be parsed.
For example,
the number of data entries must be
present in the same ﬁle as an entry. Intuitively, one
can imagine that if such a property did not hold, the
corresponding consumer would have difﬁculty parsing
the ﬁle independently. Later in Section V, we will
discuss some exceptions, such as encrypted ﬁles.
There are often dependences between ﬁelds, such as
that between the header size ﬁeld and the header ﬁeld
in Fig. 2 (b) and (c). We observe that the spacial
order of these ﬁelds in the ﬁle often follows the
dependence order. For example, the header size ﬁeld
precedes the header ﬁeld while the parsing of the
header ﬁeld relies on the size ﬁeld. In other words, the
values loaded earlier often provide sufﬁcient direction
for later ﬁle operations. The property allows P2C to
gradually transform the producer to the corresponding
consumer. In our example, loading the size ﬁeld
at line 49’ provides sufﬁcient direction to load the
header ﬁeld at line 50’, which in turn guides the
loading of the two account entries.

III. TECHNICAL CHALLENGES

We used an example in the previous section to demonstrate
the basic idea of P2C. In the real world, producers are often
much more complex and difﬁcult to transform. According
to our experience, these challenges root at the correlations

between ﬁelds in the ﬁle. In particular, ﬁeld correlations may
not be sufﬁciently exposed in the producer logic such that
the symmetric read of a preceding ﬁeld may not provide
sufﬁcient guidance to the later read(s) of the dependent ﬁeld(s)
(in the transformed execution). Before we elaborate on this
issue, we would like to ﬁrst deﬁne the different kinds of
ﬁeld correlations. Based on their characteristics, we introduce
the following two kinds of correlations: data correlation and
control correlation.
Deﬁnition 1. Two ﬁelds in a ﬁle are data-related if they are
computed from some common data source in the producer
execution that generated the ﬁle.

Since the two ﬁelds share some common data source,
which may be a variable or a data structure, any perturbation
on the value of the source may cause both ﬁelds to change.
Fig. 3 (e) shows such an example, in which both ﬁelds v1 and
v2 have data ﬂow from data.
Deﬁnition 2. A ﬁeld f1 is control-related to another ﬁeld f2
if the value of f2 directly decides the proper parsing of f1.

For example in Fig. 3 (a) and (b),

the buf ﬁeld is
control-related to the preceding len ﬁeld. Fig. 3 (c) and (d)
show another kind of control correlation. In particular, ﬁeld
id/l_id is control-related to the preceding type ﬁeld, which
determines if an integer or a long value should be loaded
from the subject ﬁle. Note that according to the deﬁnition,
the correlation has to be direct. If f3 is data-related to f2 and
f2 directly decides the proper parsing of f1, f1 is not control-
related to f3.

In P2C, detecting and handling control correlations is much
more important
than data correlations because the former
determines if P2C can properly parse the ﬁle ﬁelds. Note that
once these ﬁelds are parsed into memory of the execution, data
ﬂow tracking based type reverse engineering can be leveraged
to understand the meaning of the ﬁelds. In contrast, data
correlations do not affect the parsing of ﬁelds. For example,
in Fig. 3 (e), despite the data correlation, the two ﬁelds can
be properly loaded when the symmetric reads corresponding
to lines 42 and 46 are performed. Hence, our discussion will
focus on control correlation in the rest of the paper.

We observe that some control correlations are easier to
handle compared to others. In Fig. 3 (a), in the transformed
execution, the symmetric read corresponding to line 6 would
properly set the value of len, which allows the following
symmetric read of buf to proceed properly. In contrast in
Fig. 3 (b), although the symmetric read at line 15 sets the
value of len, the following read of buf is incorrect because
strlen(buf)’s value is still a random value depending on
the content of buf in the original execution. For example,
assume buf=“##” in the original execution and the value in
the subject unknown ﬁle is “Yes”. Despite that the symmetric
read of len (at line 15) gets the correct value of 3, the follow-
ing read of buf will unfortunately still use the old incorrect
length of 2 (computed from strlen(buf)). Observe that in
both cases, the buffer ﬁeld is control-related to the length ﬁeld
in the ﬁle.

Similarly, in Fig. 3 (c), the symmetric read at line 22 will
drive the execution to take the proper branch at line 23 such

4

Examples for different kinds of ﬁeld correlations; (a) and (c) are exposed control correlation; (b) and (d) are unexposed control correlation; (e) is

Fig. 3.
unexposed data correlation.
that the correct following symmetric read will be performed.
In contrast, in Fig. 3 (d), reading the correct value of type
from the ﬁle does not help choosing the correct branch.

The root cause lies in whether control correlations between
ﬁle ﬁelds manifest themselves through program dependences.
We hence further divide ﬁeld correlations to the following two
classes.
Deﬁnition 3. A ﬁeld control-correlation, f1 correlated to f2,
is exposed if there is a program dependence path from f2 to
f1 in the producer execution that generated the ﬁle.

If there is not such a dependence path, we say the ﬁeld
correlation is unexposed. Observe that in Fig. 3 (a), the ﬁeld
control correlation is exposed by the program dependence edge
from 3 to 7 (by variable len). In contrast in (b), there is not
a program dependence path from 12 to 16. Note that although
at line 12, len is computed from buf, the data ﬂow does not
expose the ﬁeld correlation in the opposite direction, which is
the buf ﬁeld control-related to the len ﬁeld. As a result,
loading the correct value of len at 15 does not help the
following read of buf at 16 as the len value cannot propagate
to and affect line 16 along program dependences.

In (c), the program dependence path 21 → 23 → 24/26
exposes that the id ﬁeld is control-related to the type ﬁeld.
In contrast, the correlation in (d) is not exposed.

A key challenge to P2C is hence to handle unexposed ﬁeld

control correlations (e.g., Fig. 3 (b) and (d)).

IV. DESIGN

Program
Stmt

Operator
Expr
Register
Const
Addr
Label

P ::= s
s ::= s1; s2 | skip | r :=(cid:96) e | r :=(cid:96) R(ra) |

W(cid:96)(ra,rv) | goto(cid:96)((cid:96)1) | if (r(cid:96)) then goto((cid:96)1) |
r f := fopen4write(cid:96)(rn) | fwrite(cid:96)(rbu f ,rl ,r f ) |
fclose(cid:96)(r f ) | call(cid:96)((cid:96)1) | ret(cid:96)(c)

...

op ::= + | − | ∗ | / |
e ::= r | c | a | r1 op r2
r ::= {r1,r2,r3, ...}
c ::= {true, f alse,0,1,2, ...}
a ::= {0,1,2, ...}
(cid:96) ::= {(cid:96)1, (cid:96)2, (cid:96)3, ...}

Fig. 4. Language

In this section, we discuss the design of P2C, focusing on

handling unexposed control correlations between ﬁelds.

Language. P2C works on x86 binary executables, without
requiring any symbolic information. However, if we were to
discuss the design at the x86 level, the complexity of the
instruction set would render the discussion and the example
presentation very verbose. Hence, we introduce a simpliﬁed

5

low level language, in which we only model enough to present
our technique. The language is presented in Fig. 42.

Memory reads and writes are denoted by R(ra) and W(ra,
rv), respectively, with ra holding the address and rv the value.
As a low level language, conditional or loop statements are
not modeled. Instead we deﬁne jumps using goto and guarded
goto. We only model a small number of system calls that are
ﬁle output related: fopen4write() takes rn as a pointer to the
buffer of a ﬁle name, creates the ﬁle for write, and returns the
handler in r f ; fwrite() writes the content in the buffer pointed
to by rbu f with length rl to ﬁle r f . In the rest of the paper,
we will also use output operations put int() and put long()
for brevity, although they are not part of the language. Note
that translating them to fwrite() operations is straightforward.
Other function invocations and returns are denoted by call((cid:96))
and ret, respectively. The return value of a function call is
stored in r0. Each statement is annotated with a label, which
can be intuitively considered as the program counter (PC) on
x86.

Design Overview. Due to the presence of unexposed ﬁeld
control correlations, simply transforming a producer execution
to the corresponding consumer execution may not work. There-
fore, P2C is essentially an iterative procedure that searches
for a valid transformation to parse the ﬁle. In particular, when
it encounters ﬁle output operations in which the symmetric
input operations cannot be determined with certainty (due
to unexposed correlations), P2C would select one option to
proceed. For example in Fig. 3 (b), at line 16, the length
of ﬁle write, which is also the length of the symmetric read,
does not come from a value loaded from the ﬁle, but rather a
value computed from the current state of buf in the original
execution. In other words, P2C does not know how many bytes
it should read. In this case, P2C will pick a value, which may
be the current length value strlen(buf) to proceed. To
detect in-appropriate choices, after each symmetric ﬁle read
operation (in the transformed run), P2C will re-execute from
the ﬁle open operation (i.e.
the starting point of P2C) to
detect any inconsistency, which will cause P2C to roll back to
pick another option to explore at one of the uncertain points,
until either the ﬁle is properly parsed or all options have
been explored. In this case, P2C will test the next producer
candidate.

In Fig. 3 (b), assume the ﬁle to be parsed has a length
value 3 followed by a string “Yes”. The length value 3 is
properly read at line 15 through the symmetric read. Since
the following operation at line 16 has a length value not
from the ﬁle, P2C creates a backtrack point and then selects

2Since we leverage X-Force as our execution engine, the language here

bears some resemblance to that deﬁned in [17].

the current strlen(buf) to proceed. Assume the current
strlen(buf)=2, the symmetric read only loads “Ye” to the
buffer. Re-executing with the length value and the buffer value
loaded from the ﬁle discloses an inconsistence. In particular, at
line 12, the left-hand-side len should have value 3 (according
to the ﬁle), but the right-hand-side strlen() operation on
the buffer loaded from the ﬁle has a value 2. As such, P2C
rolls back and selects a different length value at the previous
backtrack point at line 16. This time, it increases the length
value by one and reads 3 bytes. Re-execution does not detect
any inconsistency. P2C admits the choice and proceeds.

Store σ
TaintStore τ
InstrCnt cnt
OriginalDe f S
Trace T
TraceEntry E
Instance i
Taint t

Patch P

::= (Addr | Register) → Const
::= (Addr | Register) → Taint
::= Label (cid:55)→ Instance
::= (Addr | Register) → (Label × Instance)
::= E
::= (cid:104)(cid:96),i,c,t(cid:105)
::= Z
::= PATCH RELAT ED | INPUT RELAT ED |
::= (Label × Instance) → Constant

NONE

Fig. 5. Deﬁnitions.

A. Algorithm

In this subsection, we will present the algorithm. Later sub-
sections explain the different sub-components of the algorithm.

Deﬁnitions for Algorithms and Semantic Rules. To discuss
the algorithm and its components, we introduce a few deﬁni-
tions in Fig. 5. Store σ is a mapping from a memory address or
a register to a value, representing regular program state. Taint
store τ associates each address/register with a taint that may
be (1) PATCH RELAT ED, denoting that the current value in
the address/register is computed from a value brought in by
a symmetric read (called a patch); (2) INPUT RELAT ED,
denoting the current value is computed from some input that
is not a patch. Since the original execution is from X-Force,
such input values are random; (3) NONE, denoting the other
cases. Note that we need tainting to determine if an operation
is uncertain such that a backtrack point needs to be created,
and to detect inconsistency during re-execution. Instruction
count cnt denotes how many instances a statement has been
executed. This is to uniquely identify an execution instance of
a statement. P2C also collects trace for inconsistency detection.
A trace T consists of a sequence of trace entries E, which is a
four-value tuple with the label (i.e. PC), the execution instance,
the left hand side value of the statement, and the taint of the
left hand side value.

The original deﬁnition map S is a mapping from an
address/register to an instruction instance that denotes the orig-
inal deﬁnition point of the value held in the address/register.
This is to facilitate patch generation. Note that when a variable
is emitted at an output point, the symmetric read operation
will bring in the corresponding value in the ﬁle. But the value
should be set at the original deﬁnition point of the variable
instead of at the current ﬁle output point. For example, consider
the following code sequence:

1 type=foo(data); 2 x=type; 3 y=x; 4 put_int(y)

[C1]

6

The symmetric read will load the value at line 4, but we
should patch the value of type at line 1. The beneﬁt is
that all the related variables: x, y, and type are correctly
patched when we re-execute the code from the patched line
1. The original deﬁnition map is to facilitate such patching.
In practice, ﬁle output system calls often occur inside library
functions and use internal buffers. Without identifying the
original deﬁnitions that are usually in the user code, symmetric
ﬁle reads only patch the values of internal buffers and cannot
inﬂuence user code execution.

Patch P maps an instruction instance to a value, denoting

the patch for that instance. 2

Algorithm 1 Iterative Parsing Procedure

Input: Store σ0: the starting store.

TaintStore τ0: the starting taint store.
Label (cid:96)0: the starting PC.
F: the subject ﬁle to parse.

Output: a patch or NOT-PARSABLE
Deﬁnition: OriginalDe f S: the mapping from an address/register to its origin
deﬁnition

Patch P: the current patch.
function PARSEFILE(σ0,τ0, (cid:96)0,F)
(cid:104)T,S,τ,σ, (cid:96)(cid:105) ← (cid:104)nil,nil,τ0,σ0, (cid:96)0(cid:105)
P ← nil

1:
2:
3:
4: while true do
5:
6:
7:
8:
9:

if ISFILECLOSE((cid:96)) then
if ISEOF(F) then
return P
else
if there are unexplored options then
/*Roll back and explore a new selection*/

10:
11:
12:
13:
14:
15:
16:

17:

18:

BACKTRACK();
else
return NOT-PARSABLE
end if
end if
end if
(cid:104)T (cid:48), S(cid:48), τ(cid:48), σ(cid:48), (cid:96)(cid:48)(cid:105) ← execute from (cid:104)T, S, τ, σ, (cid:96)(cid:105) to the next ﬁle output

operation with patch P
/*Perform symmetric input operation and update patch*/

operation with the updated patch P

/*Re-execute with the new patch and validate consistency*/

UPDATEPATCH(S(cid:48), τ(cid:48), σ(cid:48), (cid:96)(cid:48), F)
(cid:104)T (cid:48)(cid:48), S, τ, σ, (cid:96)(cid:105) ← execute from (cid:104)nil, nil, τ0, σ0, (cid:96)0(cid:105) to the same output
if ¬ CHECKCONSISTENCY(T (cid:48), T (cid:48)(cid:48)) then
19:
20:
if there are unexplored options then
21:
BACKTRACK();
22:
else
23:
return NOT-PARSABLE
24:
end if
25:
end if
T ← T (cid:48)(cid:48)
26:
27:
end while
28: end function

function UPDATEPATCH(S(cid:48), τ(cid:48), σ(cid:48), (cid:96)(cid:48), F)
29:
30: Let the ﬁle operation at (cid:96)(cid:48) be fwrite(cid:96)(cid:48)
(rbu f ,rs,r f )
if τ(cid:48)[rs] ≡ INPUT RELAT ED then
31:
size ← select a value in the possible range of rs
32:
33:
else
size ← σ(cid:48)[rs]
34:
35:
end if
bu f ← σ(cid:48)[rbu f ]
36:
/*Perform the symmetric read, backtrack on exception*/
fread(bu f ,size,1,F)
/*Update the patch*/
for i=0 to size do
(cid:104)(cid:96)p,ip(cid:105) ← S(cid:48)[bu f + i]
P[(cid:104)(cid:96)p,ip(cid:105) (cid:55)→ bu f [i] ]
end for

38:
39:
40:
41:
42: end function

37:

The algorithm is presented in Algorithm 1. It is invoked
when a ﬁle creation (for write) operation is encountered during
path exploration in X-Force. It takes as input the store, the taint

store, the label for the ﬁle creation operation, and the unknown
subject ﬁle. It aims to transform the original execution between
the ﬁle creation and the corresponding ﬁle close to parse
the subject ﬁle. If it successfully parses the subject ﬁle, the
algorithm will return the generated patch that decides where
the values from the ﬁle are applied to various execution
points. Otherwise, it indicates failure. The patch can be further
leveraged to type the ﬁle ﬁelds.

The main procedure is deﬁned in PARSEFILE(). The conﬁg-
uration of program execution in P2C is a tuple of ﬁve ﬁelds: the
trace T , the original deﬁnition map S, the taint store τ, the store
σ, and the label of the current statement (cid:96). One can consider
a program execution in P2C is a procedure of updating the
conﬁguration step by step. In later subsections, we will explain
in the semantic rules how the different conﬁguration ﬁelds are
updated.

At line 2, the conﬁguration is initialized. Note that the
initial
trace and the initial original deﬁnition map are set
to nil. The WHILE loop in lines 4-27 represents the main
iterative process. The algorithm progresses to a new ﬁle output
operation in each iteration until the ﬁle close operation is
encountered. In this procedure, uncertain selections may be
backtracked. Inside the loop, the algorithm ﬁrst determines if
the ﬁle close operation is reached. If in the mean time, the
subject ﬁle also reaches its end, the ﬁle is successfully parsed
and it returns the current patch (lines 5-7). If there is still
left-over in the subject ﬁle, the current parsing efforts are not
successful, the algorithm will backtrack and try a different
option in one of the earlier selection points, until all options
are explored (lines 9-14).

If the ﬁle close operation has not been reached, the algo-
rithm executes the program until the next ﬁle output operation
is reached (line 16). It then invokes method UPDATEPATCH() to
perform the symmetric ﬁle read and generate the corresponding
patch (line 17). The patch is applied by re-executing from
the initial ﬁle creation operation (line 18). The re-execution
generates a new trace T(cid:48)(cid:48), which is compared with the previous
trace T(cid:48) (for the previous execution without applying the
new patch) (line 19). If they are inconsistent, which must be
caused by unexposed ﬁeld control correlations, the algorithm
backtracks (lines 19-25). The WHILE loop then starts another
iteration to proceed to the next ﬁle output operation.

Function UPDATEPATCH() performs the symmetric ﬁle read
and updates the patch with the newly loaded value(s). It
ﬁrst tests if the length value of the ﬁle write is tainted as
INPUT RELAT ED (line 31), meaning that it is not computed
from a patched value, but rather from an input supplied by X-
Force randomly. If so, it selects a value from the legal range
of the length ﬁeld, which is by default between 0 and the size
of the entire ﬁle3. Note that the selection can be backtracked
and neighboring values will be explored. If the length value is
not tainted as INPUT RELAT ED, it is computed from either
a patched value or a constant value. In this case, the algorithm
uses the current length value (line 34). After the ﬁle read (line
37), the patch is updated by looking up the original deﬁnition
for each byte in the buffer ﬁeld and setting the left-hand-side
values at those deﬁnitions to the ones loaded from the ﬁle.

3The ﬁrst selection is the current length value.

Fig. 6. The code snippet in our language corresponding to the example in
Fig. 3 (b).
Note that if the symmetric read fails because the end of the
subject ﬁle is reached, the algorithm also backtracks.

Example. We translate the example in Fig. 3 (b) to our
language. The resulting code is shown in Fig. 6. Note that the
parameter of the strlen() call is passed through register
r0 and the result of the call is also stored in r0. Fig. 7 shows
the execution of the algorithm on the example. It shows the
traces of three executions, including the initial execution and
two re-executions. For each trace, the control ﬂow is shown
on the left and the states are shown on the right.

Assume the subject ﬁle contains length value 3 followed
by string “Yes”. In the initial execution (Fig. 7 (a)), the buffer
contains a random string “##” provided by X-Force. Observe
that after the memory write to address &len, the original
deﬁnition of the address is updated to (cid:104)4,1(cid:105) (i.e. the ﬁrst
instance of line 4), which is the return site of strlen().
Next, we will explain the algorithm execution procedure by
highlighting a few steps.

•

•

At A(cid:13), a symmetric read with a deterministic length of
4 bytes loads the length value 3 from the ﬁle and the
patch is to set the original deﬁnition of address &len
to 3 (according to line 17 in the algorithm).
The algorithm re-executes with the patch (according
to line 18 in the algorithm), at B(cid:13), the patch is applied
and the following instructions dependent on r0 are
tainted as PATCH RELAT ED.

•

•

• When the re-execution reaches C(cid:13), the algorithm does
not detect any patch inconsistency by comparing trace
(b) with trace (a)4 (according to line 19 of the algo-
rithm). As such, it tentatively admits the patch and
proceeds to the next ﬁle operation at D(cid:13).
At D(cid:13), the algorithm detects the length value is from
a random value. It selects a value (i.e. value 2) to
proceed and loads string “Ye” (according to lines 31-
32 in the algorithm). Since buf was deﬁned earlier
than the starting point of the algorithm, we denote its
deﬁnition point as a special value 11.
The algorithm re-executes again with the new patch.
It applies the patch to buf at E(cid:13).
However, at F(cid:13), the patch applied on buf produces
the length value 2, which is inconsistent with the other
patch on r0. The algorithm backtracks, and resets
the length value to 3 at D(cid:13). This time, the correct

•

4While we will explain consistency checking in later subsections,

the
intuition is that multiple patches cannot produce inconsistent values at an
instruction.

7

len=strlen(buf)//parameterput_int(len)//fwrite(buf, strlen(buf),1,f);//parameterof the branch outcomes at 21. Similarly, different branch
outcomes are detected at 51, the algorithm discards 61 from
the old trace and 71, 81 from the new trace despite the internal
structure of 71 because the immediate post-dominator of line
5 is line 9. Observe that
the algorithm always aligns the
trace entries to ensure comparison is performed at appropriate
places. 2

The algorithm handles trace entries from loops as at
runtime a loop is essentially unrolled to multiple levels of
nesting if-statements. We also handle the additional challenges
in trace comparison caused by recursive functions even though
the details are elided from the algorithm for brevity.

D. Reverse Engineering Field Semantics

We have explained how P2C parses a given ﬁle to memory
through execution transformation. Note that
the successful
parsing of the ﬁle indicates that the syntactic structure of the
ﬁle is disclosed. Particularly, the individual ﬁelds of the ﬁle
are recognized by P2C. However, to understand the meaning
of the ﬁle, we still need to associate semantics to those ﬁelds.
In P2C, we leverage the data-ﬂow tracking based type
reverse engineering capabilities in X-Force to resolve the ﬁeld
semantics. Speciﬁcally, X-Force detects if a memory location
has data ﬂow to some API with a known interface. If so,
the parameter types and semantics of the interface can be
used to type the memory location. Note that P2C patches
the ﬁeld values loaded from the subject ﬁle to the execution,
which allows us to type these ﬁeld values by observing
the data ﬂow between the patched site and some known
APIs. For example in Fig. 2 (b), P2C replaces the original
accounts[0]={ “x#∧”,2014,...} with accounts[0]={
“kjohnson”,2004,...} by the symmetric read at line 52’.
Through the data ﬂow from 26 to 52 in the original execution,
P2C can type the newly loaded ﬁeld value 2004 as a year
value. X-Force’s type reverse engineering system has a rich
set of semantic tags besides the primitive types, such as IP,
EMAIL, PASSWORD, and STDIN (denoting that a value
originates from stdin). It allows a ﬁeld to have multiple
semantic tags. Users can also add to a pre-deﬁned dictionary
that maps API functions to semantic tags.

V. DISCUSSION

Asymmetric Producer and Consumer. So far we have
assumed that the producer and the corresponding consumer
have symmetric structure such that the sequence of writes
in the producer corresponds to the sequence of reads in
the consumer. However in practice, the implementation of
a real world consumer may not be precisely symmetric to
the producer. We have seen cases in which the consumer
skips certain data ﬁelds when parsing the ﬁle, especially when
such ﬁelds are not critical. In this case, P2C has the unique
advantage of providing a better (transformed) consumer that
parses all ﬁelds. There may be more complex asymmetric
cases. Later in Section VI, we will show a case in which
the producer ﬁrst writes a dummy header as a place holder,
then writes the main body. After that, it uses fseek() to go
back and replace the header. Note that this producer may be
asymmetric to a regular consumer that reads the header ﬁrst
and then the body. P2C can handle this case because it can

generate a consumer that parses the given ﬁle by performing
the symmetric operations including the symmetric ﬁle seek,
although the generated consumer may be different from the
real world consumer.
Encryption. P2C has limited support in handling encrypted
ﬁles. In extremal cases, the entire ﬁles are encrypted. Specif-
ically, data are usually ﬁrst stored in a buffer, which is then
encrypted and emitted through a single ﬁle write. In this case,
P2C can only perform the symmetric read and load the entire
ciphertext to the buffer. It cannot understand the structure
of the ﬁelds in the plain-text and their meanings, because
achieving this goal is as difﬁcult as decrypting the ciphertext.
If the producer can generate different kinds of encrypted ﬁles
(in different places in the program), P2C will not be able to
determine which kind of encrypted ﬁle a given subject ﬁle
belongs to. This is because the given ﬁle can be correctly
parsed by the (single) symmetric read corresponding to any of
the (single) encrypted ﬁle writes.

It is common that a data ﬁle has part of its data encrypted
(e.g. a plaintext header and an encrypted payload). In this
case, P2C can still parse and type the plaintext part of the
data. For the encrypted part, although P2C cannot recover the
corresponding plaintext and its structure, it can still associate
types and semantic tags to the entire buffer. For example, it
may be able to tell that the encrypted buffer contains user ids
and passwords. This is because although the encrypted buffer
loses the syntactic structure of its plaintext version, it inherits
all the types and semantic tags.

VI. EVALUATION

P2C is implemented on PIN [15]. We implement both bit
and byte level taint tracking mechanisms. All cases except
Steganography use a byte level taint tracking due to the
overhead. We evaluate P2C on 9 different programs shown
in Table III. The ﬁrst
two columns show program names
and sizes of program binaries. The third column shows sizes
of unknown ﬁles and network messages. The next column
presents the number of iterations P2C takes to transform the
producer execution at the correct output site (to get the desired
consumer execution), and the average number of iterations it
spends on transforming at a wrong ﬁle output site. Here an
iteration means a re-execution. Note that a program may output
multiple ﬁles and only one of the sites is the correct one. The
ﬁfth column shows a total execution time to cover both the
correct and wrong output sites. The sixth and seventh columns
are coverage and the number of paths explored by X-force. The
coverage data include both the number and the percentage of
instructions covered.

We use 5 programs that write ﬁles. InfoZip is a
ﬁle compressor utility. We use an arbitrary zip ﬁle cre-
ated by InfoZip to understand the zip ﬁle header.
Steganography is a program that can hide a piece of secret
text to an existing bitmap ﬁle. We use P2C to understand
and extract the secret text from a bitmap produced by the
program. FreePiano can record and play piano songs. We
use P2C to understand a song ﬁle format. Mp3gain scans
and analyzes mp3 ﬁles and inserts meta data using ID3 tag.
Similarly, yamdi inserts meta data into ﬂash video ﬁles. We
use P2C to understand the meta data format and make sure
that they do not add sensitive information.

10

We also evaluate P2C on 4 network programs to ana-
lyze network messages. We use P2C to understand an un-
known packet generated by the zbot malware. WinPing
sends ICMP messages and PowerOn broadcasts magic pack-
ets to turn on computers connected on the same network.
NetworkMorris is a network based chess game that also
supports chatting between players.

We have a few observations from the results. (1) P2C
can correctly parse all the given ﬁles/messages. The number
of iterations needed to ﬁnd the appropriate transformation is
not large, indicating that ﬁeld correlations are exposed by
program dependences in most cases such that backtracking
is not needed. (2) A program may output multiple ﬁles and
hence have multiple output sites. Only one of them is the
one we are looking for. When testing a wrong site, we
ﬁnd that P2C only iterates a very small number of times.
In many cases, it terminates in the ﬁrst execution. That is
because different ﬁles/messages often have different magic
numbers, which allow P2C to detect inconsistency quickly.
This also applies to the scenario where it tests a wrong program
which produces different ﬁle formats. (3) While P2C can
precisely identify all the ﬁelds in the given ﬁles/messages, it
can type (or associate semantic tags) to a large portion of the
identiﬁed ﬁelds. In some cases such as Steganography,
zbot and FreePiano, all or most ﬁelds are correctly typed.
The semantic tags have rich semantic information, which will
be illustrated by our later case studies. For some programs,
they have ﬁelds that are not related to any API calls such
that P2C cannot
type them. For instance, many ﬁelds in
NetworkMorris denote game board information that is not
related to any standard APIs. WinPing also has some ﬁelds
that are solely arithmetic operation related. yamdi has a lot
of ﬂoating point ﬁelds. But the underlying typing engine of
P2C only considers non-ﬂoating-point APIs. InfoZip has
some ﬁelds that are arithmetic and bit operation related such
as CRC32. Since we only enable the bit-level taint analysis on
Steganography, they are not typed.

Although P2C can associate primitive types to all these
ﬁelds, we consider them untyped as the information is not
helpful enough. On the other hand, since these ﬁelds are not
related to any APIs (i.e. system calls and library calls), we
argue that they may be less important. (4) For the ﬁelds that
are typed, we manually verify that the derived types (semantic
tags) are always correct. (5) We ﬁnd that some commercial
MP3 tag reader programs such as mp3tag are not able to
read the injected data by mp3gain whereas our transformed
consumer can recognize all of them. (6) X-Force is able to
achieve good coverage for most programs except FreePiano
and WinPing. FreePiano is a UI intensive program and X-
Force currently does not have good support for this kind of
programs. In all cases, X-Force is able to cover the correct
output sites. (7) The execution time of X-Force is at the scale
of a few hours. The execution time for P2C is relatively much
smaller, 18 minutes on average. Note that one iteration of the
execution takes 40 seconds on average.

A. Case Studies

Next, we will present more details for a few cases.
Stenography. This program hides a secret string in a bitmap
ﬁle. Speciﬁcally, it stores each bit of the secret data into the

least signiﬁcant bit of a pixel. As the least signiﬁcant bit of
pixel does not exhibit visible differences to human, it is hence
difﬁcult to notice the presence of the secret. In this case study,
we have a bitmap ﬁle which contains an unknown secret text
message. Fig. 9 shows how a message “SECRET” is added
to a given BMP ﬁle. The original bitmap ﬁle is on the top,
the secret is on the bottom, and the mutated bitmap is in the
middle. Note that given a secret message, a string containing
the size of the message and the message itself are added to
the bitmap ﬁle. The program always uses 5 bytes to represent
the ASCII version of the size. So the maximum length of the
secret message is 99999. The ﬁrst 55 bytes of the ﬁle denote
the bitmap ﬁle header. Its internal structure is elided for brevity.
Given a ﬁle containing an unknown secret, we want to use
P2C to recognize where and what the secret is. P2C starts
executing the program without the plaintext bitmap ﬁle or the
secret message. It successfully parses the header (i.e. the ﬁrst
55 bytes from the secret ﬁle) by transforming the header write
operations in the original execution that emit a sequence of
meaningless random values. These loaded bytes are typed as
INPUT FILE 1, indicating they are related to the ﬁrst input
ﬁle, which is supposed to be the plaintext bitmap ﬁle.

When the program emits the 56th byte, P2C performs the
symmetric read of the corresponding byte and identiﬁes that
the original deﬁnitions of the ﬁrst 7 bits are from a ﬁle read
but the remaining 1 bit is from a result buffer of a call to the
sprintf(...,"%d",...) API5. P2C patches the original
bits accordingly. In fact, the following 39 bytes from the secret
ﬁle have a bit that originates from the same buffer. After the
symmetric reads of these bytes, P2C successfully reconstructs
the buffer that holds the length of the secret, which is 6. This
length value is later used to guide the program execution to
read the least bit from the following 6 ∗ 8 = 48 bytes. The
original deﬁnition of those bits is a return buffer of a ﬁle
read operation in the original execution, with the type of
INPUT FILE 2, indicating they are from the second input ﬁle,
which is supposed to contain the secret message. By patching
the buffer, the original secret can be recovered by P2C. Note
that P2C does not require monitoring the original execution
that generated the secret ﬁle. It does not even require the
user to provide valid inputs to run the program. Compared
to techniques that reverse engineer output format [11], [4] and
hence aim to construct a general grammar for all bitmap ﬁles
with secret embedded, which may be difﬁcult, P2C leverages
the producer logic to understand a given speciﬁc ﬁle.
InfoZip We use an arbitrary zip ﬁle to evaluate P2C on the
InfoZip program. Handling InfoZip is challenging as it
extensively uses ﬁle seek operations. Speciﬁcally, when the
program writes a zip ﬁle, it ﬁrst writes a dummy ﬁle header
then appends the compressed content. The dummy ﬁle header
does not have a correct checksum value yet. After it ﬁnishes
the compression, then it seeks to the dummy ﬁle header and
rewrites the ﬁle header with the correct values. Fig. 10 (a)
shows a substantially simpliﬁed code snippet. It stores a value
writ and uses it in ﬁle seek later. Column (b) shows the
execution in which the symmetric read at line 3 is performed.
Column (c) shows the execution in which zfi.siz is patched
but the value of writ is still problematic.

5Note that our original deﬁnition tracking can be conﬁgured to be performed

at the bit level.

11

[4]

[5]

J. Caballero, P. Poosankam, C. Kreibich, and D. Song. Dispatcher:
Enabling active botnet inﬁltration using automatic protocol reverse-
engineering. In Proc. of the 16th ACM Conference on Computer and
and Communications Security (CCS’09), 2009.
J. Caballero and D. Song. Polyglot: Automatic extraction of protocol
In Proc. of the 14th ACM
format using dynamic binary analysis.
Conference on Computer and and Communications Security (CCS’07),
2007.

[6] W. Cui, M. Peinado, K. Chen, H. J. Wang, and L. Irun-Briz. Tupni:
Automatic reverse engineering of input formats. In Proc. of the 15th
ACM Conference on Computer and Communications Security (CCS’08),
Alexandria, VA, October 2008.

[7] B. Dolan-Gavitt, T. Leek, M. Zhivich, J. Gifﬁn, and W. Lee. Virtuoso:
Narrowing the semantic gap in virtual machine introspection. In Proc.
2011 IEEE Symposium on Security and Privacy, 2011.

[8] E. Driscoll, A. Burton, and T. Reps. Checking conformance of a
the 19th ACM SIGSOFT
producer and a consumer.
Symposium and the 13th European Conference on Foundations of
Software Engineering (ESEC/FSE), 2011.

In Proc. of

[9] C. Kolbitsch, T. Holz, C. Kruegel, and E. Kirda.

Inspector gadget:
Automated extraction of proprietary gadgets from malware binaries. In
Proc. 2010 IEEE Symposium on Security and Privacy, 2010.
J. Lee, T. Avgerinos, and D. Brumley. Tie: Principled reverse engineer-
In Proc. 18th Annual Network and
ing of types in binary programs.
Distributed System Security Symposium, 2011.
J. Lim, T. Reps, and B. Liblit.
Extracting output formats from
executables. In Proc. of Working Conference on Reverse Engineering
(WCRE), 2006.

[10]

[11]

[12] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Automatic protocol format
reverse engineering through context-aware monitored execution.
In
Proc. of the 15th Annual Network and Distributed System Security
Symposium (NDSS’08), San Diego, CA, February 2008.

[13] Z. Lin and X. Zhang. Deriving input syntactic structure from execution.
In Proceedings of the 16th ACM SIGSOFT International Symposium on
Foundations of Software Engineering (FSE), 2008.

[14] Z. Lin, X. Zhang, and D. Xu. Automatic reverse engineering of data
structures from binary execution. In Proc. 17th Annual Network and
Distributed System Security Symposium, 2010.

[15] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wal-
lace, V. J. Reddi, and K. Hazelwood. Pin: building customized program
analysis tools with dynamic instrumentation. In ACM SIGPLAN Notices,
volume 40, 2005.

[16] P. Milani Comparetti, G. Wondracek, C. Kruegel, and E. Kirda. Prospex:
Protocol Speciﬁcation Extraction. In IEEE Symposium on Security &
Privacy, 2009.

[17] F. Peng, Z. Deng, X. Zhang, D. Xu, Z. Lin, and Z. Su. X-force: Force
execution binaries for security applications. In Proc. USENIX Security
Symposium, 2014.

[18] T. W. Reps and G. Balakrishnan.

Improved memory-access analysis
for x86 executables. In Proc. of Intenational Conference on Compiler
Construction (CC), pages 16–35, 2008.

[19] A. Slowinska, T. Stancescu, and H. Bos. Howard: A dynamic excavator
for reverse engineering data structures. In Proc. 18th Annual Network
and Distributed System Security Symposium, 2011.

[20] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace. Reformat:
In Proc. of
Automatic reverse engineering of encrypted messages.
14th European Symposium on Research in Computer Security (ES-
ORICS’09), Saint Malo, France, September 2009. LNCS.

[21] G. Wondracek, P. Milani, C. Kruegel, and E. Kirda. Automatic network
protocol analysis. In Proc. of the 15th Annual Network and Distributed
System Security Symposium (NDSS’08), San Diego, CA, February 2008.

techniques cannot be used to solve our problem as in our case,
the subject ﬁle/message was generated in the past and there
is no way to track that producer execution. The contribution
of P2C lies in reconstructing a transformed execution that
parses the ﬁle such that types can be recovered by monitoring
the transformed execution. Balakrishnan et al. [1], [2], [18]
have shown that by statically analyzing executables alone can
largely discover syntactic structure of variables, such as sizes,
ﬁeld offsets, and simple structures. Their technique entails
points-to analysis and abstract interpretation at binary level,
which may be difﬁcult to scale to large and complex binaries.
They cannot be directly used to solve our problem.

Binary Reuse. P2C is also related to binary code reuse
[3], [9], [7] as it leverages the existing producer logic to
derive the consumer execution. BCR [3] identiﬁes and reuses
encryption/decryption functions in malware using both static
and dynamic analysis. Inspector Gadget[9] leverages dynamic
slicing for identifying speciﬁc malware behavior for extraction,
reuse, and analysis. Virtuoso[7] applies dynamic slicing to
identify program logic in applications running in a VM, which
can then be reused for VM introspection. Compared to these
techniques, P2C does not extract any components. It tries to
leverage the producer logic in the context of the producer
execution and performs on the ﬂy transformation.

VIII. CONCLUSION

We develop P2C, a system that can understand the structure
and meaning of an unknown ﬁle or network message that was
generated in the past, without the availability of their consumer.
It explores a set of potential producers to ﬁnd out the real one.
It iteratively and progressively transforms a producer execution
to a consumer execution that closely resembles the ideal con-
sumer execution that can parse and process the ﬁle/message,
leveraging the symmetry between producer and consumer. It
does not require the user to know the exact producer, where in
the producer the ﬁle/message was generated, or how to run the
producer. It also features the capability of handling unexposed
ﬁeld correlations. Experiments on a set of real world programs
show that the technique is highly effective.

ACKNOWLEDGMENT

We would like to thank the anonymous reviewers for their
insightful comments. This research was supported, in part,
by DARPA under Cooperative Agreement HR0011-12-2-0006,
NSF under Award 1409668, and a gift from Cisco Systems.
Any opinions, ﬁndings, and conclusions in this paper are those
of the authors only and do not necessarily reﬂect the views of
our sponsors.

REFERENCES

[1] G. Balakrishnan, , G. Balakrishnan, and T. Reps. Analyzing memory
In Proc. of Intenational Conference on

accesses in x86 executables.
Compiler Construction (CC), pages 5–23. Springer-Verlag, 2004.

[2] G. Balakrishnan and T. Reps. Divine: Discovering variables in executa-
bles. In Proc. of Internation Conf. on Veriﬁcation Model Checking and
Abstract Interpretation (VMCAI), Nice, France, 2007. ACM Press.
J. Caballero, N. M. Johnson, S. McCamant, and D. Song. Binary
code extraction and interface identiﬁcation for security applications. In
Proc. 17th Annual Network and Distributed System Security Symposium,
2010.

[3]

14

