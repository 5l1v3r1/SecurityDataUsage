Reverse Fuzzy Extractors: Enabling Lightweight
Mutual Authentication for PUF-enabled RFIDs

Anthony van Herrewege1, Stefan Katzenbeisser2, Roel Maes1, Roel Peeters1,
Ahmad-Reza Sadeghi3, Ingrid Verbauwhede1, and Christian Wachsmann2

1 K.U. Leuven, ESAT/COSIC, Leuven, Belgium

{anthony.vanherrewege,roel.maes,roel.peeters,

ingrid.verbauwhede}@esat.kuleuven.be

2 Technische Universität Darmstadt (CASED), Germany
katzenbeisser@seceng.informatik.tu-darmstadt.de

christian.wachsmann@trust.cased.de

3 Technische Universität Darmstadt & Fraunhofer SIT Darmstadt, Germany

ahmad.sadeghi@trust.cased.de

Abstract. RFID-based tokens are increasingly used in electronic pay-
ment and ticketing systems for mutual authentication of tickets and ter-
minals. These systems typically use cost-eﬀective tokens without expen-
sive hardware protection mechanisms and are exposed to hardware at-
tacks that copy and maliciously modify tokens. Physically Unclonable
Functions (PUFs) are a promising technology to protect against such at-
tacks by binding security critical data to the physical characteristics of
the underlying hardware. However, existing PUF-based authentication
schemes for RFID do not support mutual authentication, are often vul-
nerable to emulation and denial-of service attacks, and allow only for a
limited number of authentications.
In this paper, we present a new PUF-based authentication scheme that
overcomes these drawbacks: it supports PUF-based mutual authentica-
tion between tokens and readers, is resistant to emulation attacks, and
supports an unlimited number of authentications without requiring the
reader to store a large number of PUF challenge/response pairs. In this
context, we introduce reverse fuzzy extractors, a new approach to correct
noise in PUF responses that allows for extremely lightweight implemen-
tations on the token. Our proof-of-concept implementation shows that
our scheme is suitable for resource-constrained devices.

1

Introduction

Electronic payment and ticketing systems have been gradually introduced in
many countries over the past few years. Typically, these systems use a large
number of RFID-enabled tokens with constrained computing and memory capa-
bilities (see, e.g., [35]). A fundamental security requirement in electronic payment
and ticketing systems is mutual authentication: Only genuine tokens should be
accepted by readers and only eligible readers should be able to modify the debit

of a user’s token. The widespread use of these systems makes them attractive
targets for diﬀerent kinds of attacks. The most prominent example are attacks on
widely used MiFare Classic tokens by NXP Semiconductors [35] that allow copy-
ing (cloning) and maliciously changing the debit of tokens [13]. Other MiFare
products are claimed not to be aﬀected. Existing solutions typically use cost-
eﬃcient tokens without expensive hardware protection mechanisms [35]. Hence,
the authentication secrets of these tokens can often be recovered by basic side
channel and invasive attacks, and used to emulate the token in software, which
allows forging the information of the token (e.g., the debit of the ticket). To
prevent such attacks, the secrets and information of the token should be crypto-
graphically bound to the underlying RFID chip such that any attempt to extract
or change them permanently deactivates the token.

In this context, Physically Unclonable Functions (PUFs) [31,27,2] promise
to provide an eﬀective and cost-eﬃcient security mechanism. PUFs are physical
systems embedded into a host device, that, when challenged with a stimulus,
generate a noisy response. This means that, depending on environmental varia-
tions (e.g., temperature or voltage variations), a PUF will always return slightly
diﬀerent responses when challenged with the same stimulus. Further, due to
manufacturing variations, responses to the same challenge vary across diﬀerent
PUFs and are typically hard to predict [27,2].

The common approach to authenticate a PUF-enabled token is querying its
PUF with a challenge from a pre-recorded database of PUF challenges and re-
sponses. The token is accepted only if its response matches a PUF response in
the database (such as in [32,6,10]). An alternative approach is using the PUF to
generate the authentication secret of the token for use in a classical authentica-
tion protocol (such as in [38,34]). However, both approaches have serious draw-
backs in practice: PUF-based key storage requires the token to reliably recover
the (bit-exact) cryptographic secret from the noisy PUF response using some
kind of error correction mechanism, which is expensive in terms of number of
gates [12,7]. Further, existing PUF-based authentication schemes for RFID suﬀer
from the following deﬁciencies: (1) there is no support for mutual authentica-
tion between token and reader; (2) most PUF types are vulnerable to emulation
attacks [33] and would allow emulating the token in software; (3) some schemes
are subject to denial-of-service attacks that permanently prevent tokens from
authenticating to the reader [6]; and (4) all existing PUF-based authentication
schemes are not scalable and allow only for a limited number of authentication
protocol-runs since they rely on a database containing a large number of chal-
lenge/response pairs of the PUF of each token. It seems that emulation attacks
could be mitigated by controlled PUFs [14]. However, controlled PUFs typically
apply a cryptographic operation (such as a hash function) to the PUF response,
which requires an expensive error correction mechanism on the token to maintain
veriﬁability of the PUF.

Our Contribution. In this paper, we present the design and implementation of a
new lightweight PUF-based authentication scheme for mutual authentication of
RFID tokens and readers. Our scheme supports an unlimited number of authen-

tication protocol-runs, is resistant to emulation attacks, and does not require
the reader to store a large number of PUF challenge/response pairs.

Furthermore, we introduce the concept of reverse fuzzy extractors, a novel
approach to eliminate noise in PUF responses that moves the computationally
expensive error correction process from the resource-constrained PUF-enabled
token to the more powerful RFID reader. The resources required to implement
our authentication scheme on the token are minimal since it is based on a reverse
fuzzy extractor that requires signiﬁcantly less hardware resources than the error
correcting mechanisms used in existing PUF-based authentication schemes or
PUF-based key storage.

Outline. In Section 2, we provide background information on Physically Unclon-
able Functions (PUFs). We propose reverse fuzzy extractors in Section 3 and
present our PUF-based mutual authentication scheme in Section 4. We describe
the implementation and evaluate the performance of our scheme in Section 5, and
analyze its security in Section 6. Finally, we survey on related work in Section 7
and conclude in Section 8.

2 Background on Physically Unclonable Functions (PUFs)

A PUF is a noisy function that is embedded into a physical object, e.g., an
integrated circuit [31,27,2]. When queried with a challenge c, a PUF generates
a response r ← PUF(c) that depends on both c and the unique device-speciﬁc
intrinsic physical properties of the object containing the PUF. Since PUFs are
subject to noise (e.g., environmental variations), they return slightly diﬀerent
responses when queried with the same challenge multiple times.

In literature, PUFs are typically assumed to be robust, physically unclon-
able, unpredictable and tamper-evident, and several approaches to heuristically
quantify and formally deﬁne their properties have been proposed (see [2] for
an overview). Robustness means that, when queried with the same challenge
multiple times, the same PUF will return a similar response with high proba-
bility. Physical unclonability means that it is infeasible to produce two PUFs
that cannot be distinguished based on their challenge/response behavior. Un-
predictability requires that it is infeasible to predict the PUF response to an
unknown challenge, even responses to other challenges can be obtained adap-
tively. Tamper-evidence means that any attempt to physically access the PUF
irreversibly changes its challenge/response behavior.

There is a variety of PUF implementations (see [27] for an overview). The
most appealing ones for integration into electronic circuits are electronic PUFs.
The most prominent examples of this type are delay-based PUFs that exploit
race conditions (arbiter PUFs [22,30]) and frequency variations (ring oscillator
PUFs [15,37,28]) in integrated circuits; memory-based PUFs are based on the
instability of volatile memory cells, like SRAM [16,18], ﬂip-ﬂops [26,23] and
latches [36,21]; and coating PUFs [39] use capacitances of a dielectric coating
applied to the chip housing the PUF.

(a) Typical use of fuzzy extractors

(b) Reverse fuzzy extractor concept

Fig. 1. Concept of fuzzy extractors and reverse fuzzy extractors

Note that the number of responses of a memory-based PUF is limited by
the number of its memory cells. Further, most delay-based PUFs are subject
to model building attacks [22,30,25,33] that allow emulating the PUF in soft-
ware. To counter this problem, additional primitives must be used: Controlled
PUFs [14] use cryptography in hardware to hide the responses of the underly-
ing PUF to mitigate model building attacks. This requires correcting the noise
of PUF responses before they are processed by the cryptographic operation to
maintain veriﬁability of the PUF. The cryptographic and error correcting com-
ponents as well as the link between them and the PUF must be protected against
invasive and side channel attacks.

Many PUF-based applications, including PUF-based identiﬁcation and key
storage, require PUF responses to be reliably reproducible while at the same
time being unpredictable [3,27,2]. However, since PUFs are inherently noisy and
their responses are not uniformly random, they are typically combined with fuzzy
extractors [12] (Figure 1(a)). Fuzzy extractors consist of a secure sketch, which
maps similar PUF responses to the same value, and a randomness extractor,
which extracts full-entropy bit-strings from a partially random source.

Secure sketches generally work in two phases: in the generation phase some
helper data h = Gen(r) is computed from PUF response r, which is used later in
the reproduction phase to recover r = Rep(r(cid:48), h) from a distorted PUF response
r(cid:48) = r + e, where e is the error caused by noise. An important property of secure
sketches is that, after observing one single h, there is still some min-entropy
left in r, which means that h can be stored and transferred publicly without
disclosing the full PUF response [12].

3 Reverse Fuzzy Extractors

Fuzzy extractors and secure sketches [12] are commonly used to correct noisy
PUF responses on the PUF-enabled device, which is required when the PUF
response is used in a cryptographic algorithm or protocol (such as in [14,11,38,3]).
However, the underlying error decoding algorithms are typically complex and
require a large number of gates and/or long execution times when multiple bit
errors must to be corrected [12,7]. Hence, implementing the decoding algorithm
on the PUF-enabled device is a huge disadvantage in many applications.

VeriﬁerVPUFDeviceDBc,hr0←PUF(c)(c,r,h)∈RDBr←Rep(r0,h)VeriﬁerVPUFDeviceDBcr0←PUF(c)h(c,r)∈RDBh←Gen(r0)r0←Rep(r,h)To overcome this problem, we propose reverse fuzzy extractors that allow for
very compact and fast implementations of secure sketches and fuzzy extractors.
Instead of implementing the computationally intensive reproduction phase Rep(),
we implement the much more eﬃcient helper data generation phase Gen() on
the PUF-enabled device and move Rep() to the typically more powerful veriﬁer
(Figure 1(b)). As a consequence, new helper data h is generated each time the
PUF is queried and the veriﬁer corrects the reference value r of its database to
the noisy PUF response r(cid:48), which is diﬀerent each time the PUF is evaluated.
There is one major pitfall that must be considered: Each execution of the
helper data generator Gen() on a diﬀerent noisy version of the same PUF response
reveals new helper data. However, secure sketches give no guarantee about the
min-entropy of the PUF response in case multiple helper data for diﬀerent noisy
variants of the same response is known [8]. Hence, reverse fuzzy extractors may
leak the full PUF response, when Gen() and Rep() are based on a conventional
fuzzy extractor. This is problematic in most PUF-based applications, such as
controlled PUFs and PUF-based key storage (Section 2) that require at least
some bits of the PUF response to be secret, and must be carefully considered
when designing reverse fuzzy extractors.

We present an implementation of a reverse fuzzy extractor based on the
syndrome construction [12], which is a secure sketch with a highly eﬃcient helper
data generation phase and that has been shown to ensure a certain amount of
min-entropy in the PUF response even if multiple helper data for noisy variants of
a response is known [8]. The syndrome construction implements the helper data
generator Gen(r) as h ← r · H T , where H is the parity check matrix of a binary
linear block code and h corresponds to the syndrome of r. The reproduction
algorithm Rep(r(cid:48), h) of the syndrome construction computes r ← r(cid:48) − e, where
e is determined by decoding the syndrome s = h − r(cid:48) · H T using the decoding
algorithm of the underlying error correcting code. Note that Gen() corresponds
to computing a matrix product of the PUF response with the parity-check matrix
H of the underlying cyclic linear block code. Due to the special form of parity
check matrices of these codes, this product can be computed very eﬃciently, as
we show later when describing our prototype implementation in Section 5.

4 Our PUF-based Mutual Authentication Scheme

A naive approach to authenticate a PUF-enabled RFID token is the following:
The veriﬁer sends a random PUF challenge from a reference database to the
token and accepts the token only when its response is similar to the one in the
database. However, since the token always responds to the same PUF challenge
with a similar PUF response, replay attacks are possible. Moreover, for most
PUF implementations, sending the PUF response in clear allows cloning the
token by model building attacks [33]. Further, it is not trivial to authenticate
the reader to the token following this approach.

Our scheme solves these problems by merging the idea of controlled PUFs [14]
and logically reconﬁgurable PUFs [20]: We amend a PUF with a control logic that

(1) hides the plain PUF response from the adversary and (2) allows dynamically
changing the challenge/response behavior of the PUF in a random manner. Using
reverse fuzzy extractors allows for a very compact implementation of our scheme
that requires only minimal resources on the token.

4.1 System Model
The players in our scheme are (at least) a token issuer I, a veriﬁer V and a token
T . We denote the adversary with A. Our scheme enables mutual authentication
between V and T . V has access to a database DB containing detailed information
on all tokens T in the system. DB is initialized and maintained by I.

4.2 Trust Model and Assumptions
Issuer I and veriﬁer V. We assume I and V to be trusted, which is a typical
assumption in most RFID systems.4 Further, I initializes T and V in a secure
environment.
Token T . We consider T to be a passive device that cannot initiate communica-
tion, has a narrow communication range (a few centimeters to meters) and erases
its temporary state (all session-speciﬁc information and randomness) after it gets
out of the electromagnetic ﬁeld of V. Further, we assume T to be equipped with a
robust and unpredictable PUF (Section 2), a reverse fuzzy extractor (Section 3)
and a lightweight hash function.
Adversary A. As in most RFID security models, we assume A to control the wire-
less communication channel between V and T . This means that A can eavesdrop,
manipulate, delete and reroute all protocol messages sent by V and T . Moreover,
A can obtain useful information (e.g., by visual observation) on whether V ac-
cepted T as a legitimate token. Following the typical assumptions on PUF-based
key storage (such as in [40,24,38]), we assume that A can read any information
that is stored in the non-volatile memory of T . However, A cannot access the
responses of the PUF of T and cannot obtain temporary data stored in volatile
memory (such as intermediate results of the computations) of T while it is partic-
ipating in an authentication protocol. This can be achieved by using side-channel
aware designs for the implementation of the underlying algorithms.

4.3 Protocol Speciﬁcation
System Initialization. Token issuer I stores a random token identiﬁer ID in the
non-volatile memory of token T . Moreover, I extracts q > 0 challenge/response
q) from the PUF of T and stores them together with ID
pairs (c1, r(cid:48)
in database DB, which is later used by veriﬁer V in the authentication protocol.
4 Note that there are papers considering revocation of malicious veriﬁers (such as
in [4,29]). A simple approach to enable veriﬁer revocation in our scheme is moving
all computations of V to DB s.t. V has no access to the PUF challenge/response pairs.

1), . . . , (cq, r(cid:48)

Fig. 2. Lightweight PUF-based mutual authentication protocol

Authentication Protocol. The authentication protocol (Figure 2) works as fol-
lows: Veriﬁer V starts by sending an authentication request auth to token T ,
which responds with its identiﬁer ID. V chooses a random nonce N and a random
i) from database DB and sends (ci, N ) to T . Then, T
challenge/response pair (ci, r(cid:48)
evaluates ri ← PUF(ci), generates hi ← Gen(ri) using the reverse fuzzy extrac-
tor, computes a ← Hash(ID, N, ri, hi) and sends (hi, a) to V. Next, V reproduces
ri ← Rep(r(cid:48)
i from DB and checks whether Hash(ID, N, ri, hi) = a. If
this is not the case, V aborts and rejects. Otherwise, V sends b ← Hash(a, ri) to
T and accepts. Eventually, T accepts if Hash(a, ri) = b and rejects otherwise.

i, hi) using r(cid:48)

Discussion. Note that the case q = 1 is equivalent to PUF-based key storage,
where r1 represents the authentication secret of T . In this case, c1 can be stored
in the non-volatile memory of T and needs not to be sent from V to T . Hence,
two protocol messages can be saved: N can be sent with auth and ID can be
sent with (hi, a). Using multiple challenge/response pairs corresponds to storing
multiple (session) keys in the PUF, which limits the impact of side channel
attacks that may recover only a subset of these keys.

5

Implementation and Performance Evaluation

We demonstrate the feasibility of reverse fuzzy extractors by presenting a proto-
type implementation of the protocol depicted in Figure 2. The prototype com-
prises three main primitives (Figure 3): A challenge expander, a syndrome gen-
erator and a hash function. A controller orchestrates these primitives to execute
the protocol in the correct order.

The prototype is designed to be used with an arbiter PUF but can be eas-
ily modiﬁed to work with most existing intrinsic PUFs. The used arbiter PUF
implementation accepts 64-bit challenges and generates 1-bit responses. Since
our protocol requires multiple response bits, we use a linear feedback shift regis-
ter (LFSR) to expand a single challenge c into many consecutive 64-bit challenges

VeriﬁerVTokenTauthIDIDDB=(cid:0)ID0,(c1,r01),...,(cq,r0q)(cid:1)ifID06=IDthenrejectandaborti∈R{1,...,q}ci,Nri←PUF(ci)hi,ari←Rep(r0i,hi)b←Hash(a,ri)bifHash(a,ri)6=bthenrejectandabortN∈R{0,1}lifHash(ID,N,ri,hi)6=athenrejectandaborta←Hash(ID,N,ri,hi)hi←Gen(ri)Fig. 3. Architecture of the reverse fuzzy extractor core

Fig. 4. Implementation of the syndrome generator

c(cid:48), which are fed one after the other into the PUF. This allows generating PUF
responses of arbitrary length for a single challenge. The expansion can be omitted
for other PUF types that generate responses that have a suﬃcient length.
As described in Section 3, the syndrome generation consists of the matrix
multiplication of an n-bit PUF response r with the n × (n − k) parity check
matrix H T of an error correcting linear block code. This (n − k)-bit result is
called helper data h for r and can be used to correct a noisy version of r if
the number of bit errors is small enough. For our implementation, we use the
parity-check matrix of a [n = 255, k = 21, t = 55] BCH block code that can
correct up to t = 55 erroneous bits in a n = 255 bit PUF response, using a
(n − k) = 234-bit helper data vector. In case the probability of a single bit error
is 10%, then the probability of observing more than 55 errors in 255 response
bits (resulting in a decoding failure) will only happen with probability 10−7.82.
Due to the special structure of parity-check matrices of BCH codes, the matrix
multiplication can be eﬃciently implemented as an LFSR where the feedback
polynomial is determined by the BCH code and the feedback bit is added to the
next bit of the PUF response (Figure 4). The helper data must be sent from the
token to the veriﬁer, which causes an entropy loss of the actual PUF response of
up to n− k bits. Assuming the PUF response has full entropy, there will be only
k = 21 bits of uncertainty left after observing the helper data. In order to obtain a
security level equivalent to a 128-bit key, we need at least (cid:100)128/21(cid:101) = 7 responses,
each 255 bits in length, and 7 corresponding helper data vectors. This leads to
an overall PUF response length of 7 · 255 = 1, 785 bits and an overall helper
data length of 7 · 234 = 1, 638 bits. The probability of an authentication failure
due to a decoding failure in one of the 7 blocks is 1 − (1 − 10−7.82)7 = 10−6.97.

hastartdoneSPONGENThashfunctionSyndromegeneratorChallengeexpander(LFSR)ArbiterPUF(onASIC)IDNcc0rhControllerReversefuzzyextractorandhashfunction(onFPGA)s234s233s232s231s2s1s230PUF()LFSRFeedback=generatorpolynomialofBCHcodeTable 1. Implementation size of the reverse fuzzy extractor core and its components
when implemented on a Xilinx Virtex-5 FPGA (XC5VLX50).

Component
SPONGENT hash
Syndrome generator
Challenge expander
Controller
Complete RFE core

Registers

6-LUTs

146
234
65
51

496

160
235
67
196

658

This means that this prototype implementation of the protocol achieves a false
rejection rate of only one in approximately 10 million authentications. The ﬁnal
building block of our prototype is the lightweight hash function SPONGENT [5],
which seems to be perfectly suited for resource-constrained tokens.

Table 1 provides the implementation size results when synthesizing our pro-
totype design for a ﬁeld-programmable gate array (FPGA). The target device
is a Xilinx Virtex-5. The complete core (Figure 3) can be implemented using
496 one-bit ﬂip-ﬂops and 658 6-input lookup-tables (LUTs). We note that these
results can be further optimized by designing speciﬁcally for implementation on
FPGA. The HDL description of our design is platform independent.

6 Security Analysis

We now prove the security properties of our reverse fuzzy extractor construction
and mutual authentication scheme. In this context, we formalize all necessary
aspects and set up formal security deﬁnitions.

6.1 Security of the Reverse Fuzzy Extractor
Secure sketch. Let M be a metric space with n elements and distance metric dist.
Moreover, let C = {w1, . . . , wk} ⊆ M be an error correcting code with codewords
wi for 1 ≤ i ≤ k. Let d be the minimum distance and t be the error correcting
distance of C, which means that C can detect up to d, and correct up to t errors.
In this paper, we only consider linear binary block codes, where M = Fn
2 and dist
corresponds to the Hamming distance. These codes are commonly denoted as
[n, k, d] codes and it holds t = (cid:98)(d − 1)/2(cid:99). Following [12], we formally deﬁne a
secure sketch as follows:
Deﬁnition 1. A (M, m, m(cid:48), t)-secure sketch is a pair of probabilistic polynomial
time algorithms Gen() and Rep() with the following properties: Gen() takes input
w ∈ M, which is chosen according to a distribution W on M, and returns a bit-
string h ∈ {0, 1}∗. Rep() takes inputs w(cid:48) ∈ M and h, and returns w(cid:48)(cid:48) ∈ M.
Correctness ensures that w(cid:48)(cid:48) = w if h = Gen(w) and dist(w, w(cid:48)) ≤ t. The security
property guarantees that for any distribution W over M with min-entropy m, w
can be recovered from (a single) h = Gen(w) with at most probability 2−m(cid:48).

Next, we specify the syndrome construction that has been informally discussed
in Section 3 and that has been shown to implement a secure sketch [12]:
Deﬁnition 2. The syndrome construction is a (Fn
2 , n, k, t)-secure sketch (Defin-
ition1) that is based on a linear binary [n, k, d] error correcting block code. Gen(w)
computes h ← w· H T , where H is the parity check matrix of the underlying code.
Rep(w(cid:48), h) computes w ← w(cid:48)−e, where e is determined by decoding the syndrome
s = h − w(cid:48) · H T using the decoding algorithm of the underlying code.
Note that helper data h = w · H T corresponds to the syndrome of w. However,
since the syndrome construction does not require w to be a codeword, decoding h
may most likely fail. To overcome this problem, the reproduction algorithm Rep()
of the syndrome construction decodes the syndrome s = h − w(cid:48) · H T = e · H T .

Security deﬁnition of reverse fuzzy extractors. Similar to conventional fuzzy ex-
tractors, reverse fuzzy extractors should ensure that helper data does not leak
the full PUF response. However, for reverse fuzzy extractors this must hold
even when multiple diﬀerent helper data for noisy variants of the same PUF
response are known. This has been formalized by Boyen [8] as outsider chosen
perturbation security, which is deﬁned based on a security experiment between
an unbounded adversary A and a challenger CPS. In this experiment, A interacts
with the helper data generator Gen() of a secure sketch (Deﬁnition 1) and ob-
tains helper data for diﬀerent wi = w + ei for a ﬁxed but secret w and diﬀerent
noise vectors (perturbations) ei that can be adaptively chosen by A. This allows
A to inﬂuence the noise, which in case of PUFs can be done by changing the
operating conditions such as ambient temperature or supply voltage. The out-
sider chosen perturbation security experiment is deﬁned as follows: A sends a
description of distribution W over M to CPS, which then samples w ∈ M according
to W . Next, A interacts with Gen() and obtains an arbitrary number of helper
data hi = Gen(wi) for diﬀerent wi = w + ei, where ei ∈ M can be adaptively
chosen by A with the only restriction that the Hamming weight of ei is less or
equal to t. Eventually, A returns a guess w∗ for w. A wins if w∗ = w. Based on
this security experiment, Boyen [8] sets up the following security deﬁnition:
Deﬁnition 3. A (M, m, m(cid:48), t)-secure sketch (Deﬁnition 1) is unconditionally se-
cure against adaptive outsider chosen perturbation attacks, if no unbounded ad-
versary A can win the outsider chosen perturbation security experiment with
probability greater than 2−m(cid:48) for any distribution W over M with min-entropy m.
Moreover, Boyen [8] shows that the at the syndrome construction achieves out-
sider chosen perturbation security:
Theorem 1. The syndrome construction (Deﬁnition 2) is unconditionally se-
cure against adaptive outsider chosen perturbation attacks (Deﬁnition 3).
We now state the security of our reverse fuzzy extractor construction:
Theorem 2. The reverse fuzzy extractor (Section 3) based on the syndrome con-
struction (Deﬁnition 2) is a (Fn
2 , n, k, t)-secure sketch (Definition1) that achieves
outsider perturbation security (Deﬁnition 3).

Proof (Sketch, Theorem 2). Note that Gen() and Rep() of the syndrome con-
struction and the the reverse fuzzy extractor based on the syndrome construction
are identical. In fact, only the entities that execute Gen() and Rep() have been
switched. Hence, it is easy to see that the syndrome construction and the reverse
fuzzy extractor based on the syndrome construction are equivalent. Thus, since
the syndrome construction is a (Fn
2 , n, k, t)-secure sketch, the reverse fuzzy ex-
tractor based on the syndrome construction is also a (Fn
2 , n, k, t)-secure sketch.
Consequently, it follows from Theorem 1 that the reverse fuzzy extractor based
(cid:117)(cid:116)
on the syndrome construction achieves outsider perturbation security.

6.2 Security of the Authentication Protocol
Correctness. Correctness means that, in case token T and veriﬁer V are honest,
mutual authentication should be successful.
Deﬁnition 4. A mutual authentication scheme is correct, if an honest T always
makes an honest V accept, and an honest V always makes an honest T accept.

Theorem 3. The authentication scheme in Section 4.3 is correct, when based
on a PUF that generates responses of length n bits with at most t bit errors, and
a (Fn

2 , n, k, t)-secure sketch (Deﬁnition 1).

i, Gen(ri)) = ri for all (ri, r(cid:48)

Proof (Sketch, Theorem 3). It is easy to see that the protocol in Section 4.3
is correct if Rep(r(cid:48)
i). The correctness property of
2 , n, k, t)-secure sketch (Deﬁnition 1) ensures that Rep(r(cid:48)
the (Fn
i, Gen(ri)) = ri if
i) ≤ t. If the PUF generates responses of length n bits with a bit error
dist(ri, r(cid:48)
rate of at most ρ, then the probability of dist(r, r(cid:48)) ≤ t can be expressed as
the cumulative binomial distribution in t with parameters ρ and n. Note that
t is chosen such that this probability, which is an upper bound for the false
rejection rate of the authentication, becomes very small. Hence, a (Fn
2 , n, k, t)-
(cid:117)(cid:116)
secure sketch can then recover r from r(cid:48) with overwhelming probability.
Note that the implementation in Section 5 can handle PUFs with ρ ≤ 10%.
When both veriﬁer and token are trusted, it achieves an authentication failure
rate of less than 10−6.97, which is acceptable for most commercial applications.
Token Authentication. Token authentication means that adversary A should not
be able to make a legitimate veriﬁer V to accept A as a legitimate token T . Fol-
lowing [34,1], we formalize token authentication based on a security experiment,
where A must make an honest V to authenticate A as T . Hereby, A can arbi-
trarily interact with T and V, which both are simulated by a challenger CTA.
However, since in general it is not possible to prevent simple relay attacks, A is
not allowed to just forward all messages from T to V.5 This means that at least
5 Note that simple relay attacks can be mitigated by distance bounding techniques.
However, for simplicity we excluded relay attacks because the main focus of the
protocol is demonstrating the use of reverse fuzzy extractors.

some of the protocol messages that made V accept must have been computed
by A. More speciﬁcally, the token authentication experiment is as follows: CTA
initializes T and V. Then, CTA initializes A with the public system parameters.
Next, A can arbitrarily interact with T and V that are simulated by CTA. Hereby,
A can eavesdrop on authentication protocol-runs between an honest T and an
honest V, and manipulate protocol messages exchanged between V and T . Fur-
ther, A can start authentication protocol-runs as V or T with CTA. A wins, if it
makes V accept after a polynomial (in l) number of queries to CTA.
Deﬁnition 5. An authentication scheme achieves µ-token authentication, if no
probabilistic polynomial time adversary A wins the token authentication experi-
ment with probability greater than 2−µ.
Theorem 4. The authentication scheme in Section 4.3 achieves k-token au-
thentication (Deﬁnition 5) in the random oracle model, when using the reverse
fuzzy extractor (Section 3) based on the syndrome construction (Deﬁnition 2).

In the following, we focus on the variant of our authentication scheme that uses
only one single challenge/response pair, i.e., where q = 1 (Section 4.3). The proof
can be easily extended for q > 1. Due to space restrictions we give only proof
sketches and provide detailed proofs in the full version of the paper [17].
Proof (Sketch, Theorem 4). We show that, if there is an adversary A that violates
token authentication (Deﬁnition 5) with probability greater than 2−k, then A can
be transformed into an adversary B that violates outsider chosen perturbation
security of the reverse fuzzy extractor (Theorem 2). Note that, in the chosen
perturbation security experiment (Deﬁnition 3), B interacts with a helper data
generator oracle Gen() that, when queried with ej, returns hj = Gen(r + ej) for
a ﬁxed but unknown r ∈ Fn
2 . Based on this Gen()-oracle, B simulates challenger
CTA of the token authentication security experiment (Deﬁnition 5) such that
A cannot distinguish between B and CTA. Hereby, A and B have access to the
same random oracle Hash(), and B records all queries x made by A to Hash()
and the corresponding responses Hash(x) in a list L. Since, A cannot distinguish
B from CTA, by assumption A violates token authentication (Deﬁnition 5) with
probability greater than 2−k. B uses L to extract r∗ = r from the protocol
message (h, a) generated by A that ﬁnally makes V accept. Note that, the random
oracle ensures that (x, a) ∈ L. Hence, B can extract r with probability greater
than 2−k, which contradicts outsider chosen perturbation security of the reverse
(cid:117)(cid:116)
fuzzy extractor (Theorem 2).
Note that in practice, the success probability 2−µ (Deﬁnition 5) of A may depend
on the output length t of the hash function implementing the random oracle:
In case t < k A could simply guess the correct hash digest a with probability
2−t. For the implementation of the syndrome construction based reverse fuzzy
extractor (Section 5), we have t = 128 < k = 147, and thus µ = 128.
Veriﬁer Authentication. Veriﬁer authentication means that adversary A should
not be able to make an honest token T to accept A as a legitimate veriﬁer V.

This is formalized by a veriﬁer authentication security experiment between A
and a challenger CVA that is identical to the token authentication experiment
with the only diﬀerence that A wins, if A makes T accept after a polynomial
(in t and the bit length of PUF responses) number of queries.
Deﬁnition 6. An authentication scheme achieves µ-veriﬁer authentication, if
no probabilistic polynomial time adversary A wins the veriﬁer authentication
experiment with probability greater than 2−µ.
Theorem 5. The authentication scheme in Section 4.3 achieves k-veriﬁer au-
thentication (Deﬁnition 6) in the random oracle model, when using the reverse
fuzzy extractor (Section 3) based on the syndrome construction (Deﬁnition 2),
when the underlying PUF generates at least ρ bit errors each time it is evaluated.
Proof (Sketch, Theorem 5). We show that, if there is an adversary A that vi-
olates veriﬁer authentication (Deﬁnition 6) with probability greater than 2−k,
then A can be transformed into an adversary B that violates outsider chosen
perturbation security of the reverse fuzzy extractor (Theorem 2). B simulates
challenger CVA of the veriﬁer authentication security experiment (Deﬁnition 5)
based on the Gen()-oracle such that A cannot distinguish between B and CVA in
a similar way as in the proof of Theorem 4. Hereby, A and B have access to the
same random oracle, and B records all queries x made by A to Hash() and the
corresponding responses Hash(x) in a list L. Since, A cannot distinguish between
B and CVA, by assumption A violates veriﬁer authentication (Deﬁnition 6) with
probability greater than 2−k. B uses L to extract r∗ = r from the protocol mes-
sage b generated by A that ﬁnally makes T accept. Note that, the random oracle
assumption ensures that (x, b) ∈ L, while the bit errors in the PUF responses
ensure that A cannot just replay an old b. Hence, B can extract r with proba-
bility greater than 2−k, which contradicts outsider chosen perturbation security
(cid:117)(cid:116)
of the reverse fuzzy extractor (Theorem 2).

7 Related Work

One of the ﬁrst proposals of using PUFs in RFID systems is by Ranasinghe
et al. [32], who propose storing a set of PUF challenge/response pairs (CRPs)
in a database that can later be used by RFID readers to identify a token. The
idea is that the reader queries the PUF of the token with a random challenge
from the database and veriﬁes whether the response of the token is similar to the
database entry. One problem of this approach is that CRPs cannot be re-used
since this enables replay attacks. Hence, the number of token authentications
is limited by the number of CRPs in the database. This scheme has been im-
plemented and analyzed by Devadas et al. [10]. Holcomb et al. [18] present a
similar scheme based on an SRAM-PUF on RFID chips. Another approach to
PUF-based authentication by Bolotnyy and Robins [6] aims to prevent unautho-
rized tracking of tokens. A major drawback of their scheme is that tokens can
only be authenticated a limited number of times without being re-initialized,
which enables denial-of-service attacks.

Tuyls and Batina [38] propose using a PUF to reconstruct the authentication
secret of a token whenever it is needed instead of storing it in secure non-volatile
memory. Since the key is inherently hidden in the PUF, obtaining the key by
hardware-related attacks is supposed to be intractable. However, the scheme
proposed by Tuyls and Batina [38] relies on public-key cryptography, which is
still much too expensive for low-cost RFID tokens. Several other authentication
schemes for RFID exist that use PUF-based key storage to protect against unau-
thorized tracking of tokens [9,34] and relay attacks [19]. However, these schemes
require the expensive decoding operation of a fuzzy extractor to be implemented
on the token, which is too expensive for low-cost RFIDs.

8 Conclusion

We presented a new lightweight PUF-based authentication scheme providing
mutual authentication of RFID tokens and readers. Our scheme is resistant to
emulation attacks, supports an unlimited number of token authentications, and
does not require the reader to store a large number of PUF challenge/response
pairs. Furthermore, we introduce the concept of reverse fuzzy extractors, a novel
approach to correct noise in PUF responses moving the computationally expen-
sive error correction process from the resource-constrained PUF-enabled token to
the more powerful RFID reader. Reverse fuzzy extractors are applicable to device
authentication and PUF-based key storage (where the key is used to communi-
cate with an external entity) and can signiﬁcantly reduce the area costs of secure
PUF implementations. Future work includes a highly optimized implementation
of our scheme and developing lightweight privacy-preserving authentication pro-
tocols based on PUFs and reverse fuzzy extractors.

Acknowledgement. This work has been supported in part by the European Com-
mission under grant agreement ICT-2007-238811 UNIQUE.

References

1. Armknecht, F., Chen, L., Sadeghi, A.R., Wachsmann, C.: Anonymous authentica-
tion for RFID systems. In: Radio Frequency Identiﬁcation: Security and Privacy
Issues (RFIDSec), LNCS, vol. 6370, pp. 158–175. Springer (2010)

2. Armknecht, F., Maes, R., Sadeghi, A.R., Standaert, F.X., Wachsmann, C.: A for-
mal foundation for the security features of physical functions. In: IEEE Symposium
on Security and Privacy. pp. 397–412. IEEE (May 2011)

3. Armknecht, F., Maes, R., Sadeghi, A.R., Sunar, B., Tuyls, P.: Memory leakage-
resilient encryption based on physically unclonable functions. In: Advances in Cryp-
tology (ASIACRYPT). LNCS, vol. 5912, pp. 685–702 (2009)

4. Avoine, G., Lauradoux, C., Martin, T.: When compromised readers meet RFID.

The 5th Workshop on RFID Security (RFIDSec) (2009)

5. Bogdanov, A., Khovratovich, D., Rechberger, C.: SPONGENT: A Lightweight
Hash Function. In: Cryptographic Hardware and Embedded Systems (CHES).
LNCS, vol. 6917, pp. 312–327. Springer (2011)

6. Bolotnyy, L., Robins, G.: Physically unclonable Function-Based security and pri-
vacy in RFID systems. In: IEEE International Conference on Pervasive Computing
and Communications (PerCom). pp. 211–220. IEEE (2007)

7. Bösch, C., Guajardo, J., Sadeghi, A.R., Shokrollahi, J., Tuyls, P.: Eﬃcient helper
data key extractor on FPGAs. In: Cryptographic Hardware and Embedded Sys-
tems (CHES). LNCS, vol. 5154, pp. 181–197. Springer (2008)

8. Boyen, X.: Reusable cryptographic fuzzy extractors. In: ACM Conference on Com-

puter and Communications Security (ACM CCS). pp. 82–91. ACM (2004)

9. Bringer, J., Chabanne, H., Icart, T.: Improved privacy of the Tree-Based hash
protocols using physically unclonable function. In: Security and Cryptography for
Networks (SCN), LNCS, vol. 5229, pp. 77–91. Springer (2008)

10. Devadas, S., Suh, E., Paral, S., Sowell, R., Ziola, T., Khandelwal, V.: Design and
implementation of PUF-based unclonable RFID ICs for Anti-Counterfeiting and se-
curity applications. In: International Conference on RFID. pp. 58–64. IEEE (2008)
11. Dodis, Y., Katz, J., Reyzin, L., Smith, A.: Robust fuzzy extractors and authenti-
cated key agreement from close secrets. In: Advances in Cryptology (CRYPTO),
LNCS, vol. 4117, pp. 232–250. Springer (2006)

12. Dodis, Y., Reyzin, L., Smith, A.: Fuzzy extractors: How to generate strong keys
from biometrics and other noisy data. In: Advances in Cryptology (EUROCRYPT).
LNCS, vol. 3027, pp. 523–540 (2004)

13. Garcia, F.D., de Koning Gans, G., Muijrers, R., van Rossum, P., Verdult, R.,
Schreur, R.W., Jacobs, B.: Dismantling MiFare classic. In: Jajodia, S., Lopez, J.
(eds.) 13th European Symposium on Research in Computer Security (ESORICS).
LNCS, vol. 5283, pp. 97–114. Springer (2008)

14. Gassend, B., Clarke, D., van Dijk, M., Devadas, S.: Controlled physical random
functions. In: Computer Security Applications Conference. pp. 149–160. IEEE
(2002)

15. Gassend, B., Clarke, D., van Dijk, M., Devadas, S.: Silicon physical random
functions. In: ACM Conference on Computer and Communications Security
(ACM CCS). pp. 148–160 (2002)

16. Guajardo, J., Kumar, S.S., Schrijen, G.J., Tuyls, P.: FPGA intrinsic PUFs and their
use for IP protection. In: Workshop on Cryptographic Hardware and Embedded
Systems (CHES). LNCS, vol. 4727, pp. 63–80 (2007)

17. van Herrewege, A., Katzenbeisser, S., Maes, R., Peeters, R., Sadeghi, A.R., Ver-
bauwhede, I., Wachsmann, C.: Reverse fuzzy extractors: Enabling lightweight mu-
tual authentication for PUF-enabled RFIDs. Cryptology ePrint Archive (to ap-
pear)

18. Holcomb, D.E., Burleson, W.P., Fu, K.: Initial SRAM state as a ﬁngerprint and
source of true random numbers for RFID tags. In: Conference on RFID Security
(RFIDSec) (2007)

19. Kardas, S., Kiraz, M.S., Bingol, M.A., Demirci, H.: A novel RFID distance bound-
ing protocol based on physically unclonable functions. Cryptology ePrint Archive,
Report 2011/075 (2011)

20. Katzenbeisser, S., Kocabaş, U., van der Leest, V., Sadeghi, A.R., Schrijen, G.J.,
Schröder, H., Wachsmann, C.: Recyclable PUFs: Logically reconﬁgurable PUFs.
In: Workshop on Cryptographic Hardware and Embedded Systems (CHES). LNCS,
vol. 6917, pp. 374–389. Springer (2011)

21. Kumar, S., Guajardo, J., Maes, R., Schrijen, G.J., Tuyls, P.: Extended ab-
stract: The butterﬂy PUF protecting IP on every FPGA. In: IEEE Workshop
on Hardware-Oriented Security and Trust (HOST). pp. 67–70 (2008)

22. Lee, J.W., Lim, D., Gassend, B., Suh, G.E., van Dijk, M., Devadas, S.: A technique
to build a secret key in integrated circuits for identiﬁcation and authentication
application. In: Symposium on VLSI Circuits. pp. 176–159 (2004)

23. van der Leest, V., Schrijen, G.J., Handschuh, H., Tuyls, P.: Hardware intrinsic
security from D ﬂip-ﬂops. In: ACM Workshop on Scalable Trusted Computing
(ACM STC). pp. 53–62 (2010)

24. Lim, D., Lee, J.W., Gassend, B., Suh, G.E., van Dijk, M., Devadas, S.: Extracting
secret keys from integrated circuits. IEEE Transactions on VLSI Systems 13(10),
pp. 1200–1205 (2005)

25. Lin, L., Holcomb, D., Krishnappa, D.K., Shabadi, P., Burleson, W.: Low-power
sub-threshold design of secure physical unclonable functions. In: International Sym-
posium on Low Power Electronics and Design (ISLPED). pp. 43–48 (2010)

26. Maes, R., Tuyls, P., Verbauwhede, I.: Intrinsic PUFs from ﬂip-ﬂops on reconﬁg-
urable devices. In: Workshop on Information and System Security (WISSec). p. 17
(2008)

27. Maes, R., Verbauwhede, I.: Physically unclonable functions: A study on the state
of the art and future research directions. In: Towards Hardware-Intrinsic Security,
pp. 3–37. Springer (2010)

28. Maiti, A., Casarona, J., McHale, L., Schaumont, P.: A large scale characteriza-
tion of RO-PUF. In: IEEE Symposium on Hardware-Oriented Security and Trust
(HOST). pp. 94–99 (2010)

29. Nithyanand, R., Tsudik, G., Uzun, E.: Readers behaving badly: Reader revocation
in PKI-based RFID systems. Cryptology ePrint Archive, Report 2009/465 (2009)
30. Öztürk, E., Hammouri, G., Sunar, B.: Towards robust low cost authentication
for pervasive devices. In: International Conference on Pervasive Computing and
Communications (PerCom). pp. 170–178. IEEE (2008)

31. Pappu, R.S., Recht, B., Taylor, J., Gershenfeld, N.: Physical one-way functions.

Science 297, pp. 2026–2030 (2002)

32. Ranasinghe, D.C., Engels, D.W., Cole, P.H.: Security and privacy: Modest propos-

als for low-cost RFID systems. Auto-ID Labs Research Workshop (2004)

33. Rührmair, U., Sehnke, F., Sölter, J., Dror, G., Devadas, S., Schmidhuber, J.: Mod-
eling attacks on physical unclonable functions. In: ACM conference on Computer
and communications security (ACM CCS). pp. 237–249 (2010)

34. Sadeghi, A.R., Visconti, I., Wachsmann, C.: Enhancing RFID Security and Privacy
by Physically Unclonable Functions. In: Towards Hardware-Intrinsic Security, pp.
281–305. Springer (2010)

35. NXP Semiconductors: Web site of MiFare. http://mifare.net/ (December 2011)
36. Su, Y., Holleman, J., Otis, B.: A 1.6pJ/bit 96% stable chip-ID generating circuit
using process variations. In: IEEE International Solid-State Circuits Conference
(ISSCC). pp. 406–611 (2007)

37. Suh, G.E., Devadas, S.: Physical unclonable functions for device authentication

and secret key generation. In: Design Automation Conference. pp. 9–14 (2007)

38. Tuyls, P., Batina, L.: RFID-tags for anti-counterfeiting. In: The Cryptographers’

Track at the RSA Conference. LNCS, vol. 3860, pp. 115–131. Springer (2006)

39. Tuyls, P., Schrijen, G.J., Škorić, B., van Geloven, J., Verhaegh, N., Wolters, R.:
Read-proof hardware from protective coatings. In: Workshop on Cryptographic
Hardware and Embedded Systems (CHES). LNCS, vol. 4249, pp. 369–383 (2006)
40. Škorić, B., Tuyls, P., Ophey, W.: Robust key extraction from physical uncloneable
functions. In: Applied Cryptography and Network Security (ACNS). LNCS, vol.
3531, pp. 407–422 (2005)

