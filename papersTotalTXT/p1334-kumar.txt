Group Signatures with Probabilistic Revocation: A
Computationally-Scalable Approach for Providing

Privacy-Preserving Authentication

Vireshwar Kumar1, He Li1, Jung-Min (Jerry) Park1, Kaigui Bian2, Yaling Yang1

1 Electrical and Computer Engineering

2 Electronics Engineering and Computer Science

Virginia Tech

Blacksburg, VA, USA

{viresh, heli, jungmin, yyang8}@vt.edu

Peking University

Beijing, China

bkg@pku.edu.cn

ABSTRACT
Group signatures (GSs) is an elegant approach for provid-
ing privacy-preserving authentication. Unfortunately, mod-
ern GS schemes have limited practical value for use in large
networks due to the high computational complexity of their
revocation check procedures. We propose a novel GS scheme
called the Group Signatures with Probabilistic Revocation
(GSPR), which signiﬁcantly improves scalability with regard
to revocation. GSPR employs the novel notion of probabilis-
tic revocation, which enables the veriﬁer to check the revo-
cation status of the private key of a given signature very ef-
ﬁciently. However, GSPR’s revocation check procedure pro-
duces probabilistic results, which may include false positive
results but no false negative results. GSPR includes a pro-
cedure that can be used to iteratively decrease the probabil-
ity of false positives. GSPR makes an advantageous trade-
oﬀ between computational complexity and communication
overhead, resulting in a GS scheme that oﬀers a number of
practical advantages over the prior art. We provide a proof
of security for GSPR in the random oracle model using the
decisional linear assumption and the bilinear strong Diﬃe-
Hellman assumption.

Categories and Subject Descriptors
E.3 [Data]: Data Encryption—Public Key Cryptosystems;
K.4.1 [Computer and Society]: Public Policy Issues—
Privacy

Keywords
Privacy-preserving authentication; group signature; proba-
bilistic revocation.

1.

INTRODUCTION

The notion of authentication is to enable a sender to prove
her identity to a distant communication partner and/or to
show that she is the origin of the transmitted data. This se-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813602.

curity attribute is essential to most of today’s applications
that rely on digital communications over insecure networks.
In some applications, however, authentication is not suﬃ-
cient, and in addition to authentication, the sender’s pri-
vacy need to be protected—the combination of these two
attributes is often referred to as privacy-preserving authen-
tication (PPA). PPA schemes are needed in applications
where the veriﬁers should not learn the actual identity of
the sender (i.e., signer), and are willing to accept an au-
thentication artifact (i.e., signature) that is veriﬁably linked
to an anonymous sender, knowing that the sender’s identity
can be revealed by a trusted third party, if disputes need
to be resolved. A wide variety of applications require PPA,
including safety applications for vehicular networks, identity
escrow schemes, anonymous credential systems, remote at-
testation of computing platforms, and device-to-device com-
munications in the Internet-of-Things (IoT) paradigm.

For deployment in large networks, PPA protocols need to
rely on public-key cryptography. In public-key cryptosystem-
based PPA protocols, there are three entities that interact
with each other: signer, veriﬁer, and group manager. The
roles of the signer and the veriﬁer are obvious. The group
manager plays an important role. During the initialization
process, the group manager generates parameters, and cer-
tiﬁcates (e.g., public-key certiﬁcates) and the private sign-
ing key of each group member. Most importantly, the group
manager has the ability to reveal the signer’s true identity if
a dispute needs to be resolved. PPA schemes can be broadly
categorized into two approaches: pseudonym-based signa-
tures (PSs) [20] and group signatures (GSs) [6].

In PSs, legacy public-key cryptosystems (e.g., RSA) are
used. The group manager provides the signer with a list of
pseudonyms and the corresponding private keys, public keys,
and public-key certiﬁcates. The signer creates a signature
based on her pseudonym, and replaces her pseudonym with
a new one periodically to preserve anonymity. Although the
PS approach is straightforward, it has a number of draw-
backs. Because each pseudonym needs to be used with its
unique set of private and public keys and a certiﬁcate, key
management and distribution become a very onerous burden
in large networks [12].

GSs do not require public-key certiﬁcates, and hence do
not need a certiﬁcate distribution framework. In GS, each
signer is a member of a group, and she is provided with a pri-
vate key tuple by the group manager. Using this tuple, the

1334signer generates signatures without revealing her true iden-
tity to the veriﬁer. In the case of a conﬂict, the signature can
be “opened” by the group manager, and the identity of the
signer is revealed. The most practical GS schemes support
veriﬁer-local revocation (VLR) [3, 6, 16]. To perform VLR,
the group manager generates a revocation token for each
signer (which is a portion of the private key), publishes it in
a revocation list, and distributes the revocation list to the
veriﬁers. To check the revocation status of the private key
used to generate the received signature, the veriﬁer performs
the revocation check procedure. This procedure involves go-
ing through the revocation list, and checking whether any
of the revocation tokens contained therein can be mapped
to the received signature. This means that the computation
time for the revocation check procedure increases linearly
with the number of revoked private keys. Moreover, the
computational cost of the procedure for each revocation to-
ken is expensive. After a thorough and comprehensive anal-
ysis of existing GSs, the authors of [13] recently concluded
that revocation remains the major performance bottleneck of
modern GS schemes, and that further research is urgently
needed to design schemes oﬀering better scalability with re-
gard to revocation.

In this paper, we propose a novel VLR GS scheme called
Group Signatures with Probabilistic Revocation (GSPR). As
its name implies, the most striking attribute of GSPR is that
it supports probabilistic revocation. That is, GSPR’s revo-
cation check procedure does not produce deterministic re-
sults, but instead produces probabilistic results, which may
include false positive (i.e., false alarm) results but no false
negative results. Here, a false negative result refers to an
instance in which the revocation check algorithm fails to de-
tect that the revocation token associated with the received
signature is included in the revocation list. GSPR includes
a procedure that can be used to iteratively decrease the
probability of false alarms. The use of probabilistic revo-
cation (instead of deterministic revocation) enables GSPR
to elegantly address the primary performance bottleneck of
GSs—i.e., enable very eﬃcient revocation checking with only
a modest increase in the signature size. In fact, GSPR’s re-
vocation check time does not grow linearly with the number
of revoked keys.

The dramatic improvement in the computational eﬃciency
of the revocation check procedure is made possible by the use
of “alias codes”. Each alias code is a vector of +1s and −1s
with desirable cross-correlation properties, and each alias
code is mapped to an “alias token” (which is equivalent to
a revocation token in legacy VLR GS schemes) included in
each signature. The group manager creates a “revocation
code” (which is equivalent to a revocation list) by adding all
of the alias codes mapped to revoked alias tokens, and then
distributes this to the veriﬁers. The veriﬁer performs the
revocation check procedure by ﬁrst mapping the signature’s
alias token to an alias code, and then computing the cross
correlation of the alias code and the revocation code. Note
that the veriﬁer is able to check whether a particular alias
code is included in the revocation code in a single cross-
correlation operation, and thus avoids the burden of legacy
GS schemes in which the veriﬁer needs to iteratively check
each revocation token in the revocation list. Because of the
probabilistic nature of the revocation check procedure, its
result is not guaranteed to be correct with certainty, but
only with a certain probability.

The paper’s main contributions are summarized below.
• We propose a novel VLR GS scheme called Group
Signatures with Probabilistic Revocation which signif-
icantly reduces the computational complexity of the
revocation check procedure compared to the prior art.
• We propose the novel concept of probabilistic revoca-
tion which makes an advantageous tradeoﬀ between
computational complexity and communication over-
head. This tradeoﬀ enables GSPR to have signiﬁcantly
better scalability in terms of revocation compared to
the prior art.

• We provide a comprehensive security analysis of GSPR
in the random oracle model using standard complexity
assumptions often used in evaluating legacy schemes.
The rest of this paper is organized as follows. We provide
the security assumptions in Section 2, and present the model
and security deﬁnitions in Section 3. We present the details
of GSPR in Section 4, and analyze its security properties
in Section 5. We perform the computational and communi-
cation overhead analysis of GSPR in Section 6. We discuss
GSPR in the context of safety applications for vehicular net-
works in Section 7. We discuss the related work in Section 8,
and conclude the paper in Section 9.

2. PRELIMINARIES

The proposed scheme is constructed in cyclic groups with
a computable bilinear map [5]. Moreover, the security of
the proposed scheme is proved in the random oracle model
using the Decisional Linear (DLIN) assumption [4] and the
q-Bilinear Strong Diﬃe-Hellman (BSDH) assumption [10].
In this section, we review the deﬁnitions of bilinear groups
and of the complexity assumptions.

Deﬁnition 1. (Bilinear Groups): (G1, G2) is called a
bilinear group pair, if there exists a group GT and a bilinear
map e : G1 × G2 → GT with the following properties:

1. G1, G2 and GT are multiplicative cyclic groups of prime

order p;

2. g1 is a generator of G1, and g2 is a generator of G2;
3. ψ is an eﬃciently computable isomorphism from G2 to

G1, with ψ(g2) = g1;

4. e is an eﬃciently computable bilinear map with the

following properties:

• Bilinear: e(ua, vb) = e(u, v)ab, ∀u ∈ G1, v ∈ G2
p represents the set of in-

p, where Z∗

and a, b ∈ Z∗
tegers modulo p; and

• Non-degenerate: e(g1, g2) 6= 1.

When G1 = G2, ψ is an identity map. On the other hand,
when G1 6= G2, certain families of non-supersingular elliptic
curves can be used for eﬃcient implementation of bilinear
groups, and ψ can be implemented by a trace map [14].

Deﬁnition 2. (DLIN Assumption): Given u0, u1, h, ua
0,
ub
1, Z ∈ G2, where a, b ∈ Z∗
p, as input for each probabilis-
tic polynomial time (PPT) algorithm A, the probability
with which A is able to diﬀerentiate whether Z = ha+b or
Z R←− G2 is negligibly small. Here, R←− represents a random
selection.

2 , · · · , gγq

Deﬁnition 3. (BSDH Assumption): Given a (q + 2)-
tuple (g1, g2, gγ
2 ) as input for each PPT algorithm
A, the probability that A outputs a pair (e(g1, g2)1/(γ+x), x),
where x ∈ Z∗
p, is
negligibly small.

R←− G2, g1 = ψ(g2), and γ R←− Z∗

p, g2

13353. MODEL AND SECURITY DEFINITIONS
In this section, we describe the algorithms that make up

GSPR, and review the security properties of GSs.

Deﬁnition 4. (Group Signatures with Probabilistic

Revocation): It is composed of the following algorithms.

• KeyGen(λ): With the security parameter, λ ∈ N, this
algorithm generates a group public key gpk, and a
group manager’s secret gms. Here, N represents the
set of natural numbers.

• Join(gms, i, m): To add the signer i ∈ [1, n], where n is
the total number of signers in the network, as a mem-
ber of the group with the secret gms, this algorithm
generates a set of m alias tokens, xik, ∀k ∈ [1, m],
a corresponding secret/private key gski and a corre-
sponding revocation token grti, and makes an entry
into a registration list regi. In this paper, we use the
terms “secret key” and “private key” interchangeably.
• Sign(gpk, gski, M ): With the group public key gpk,
and the signer’s secret key gski, this algorithm gener-
ates signature σ with alias token xik on message M .

• Verify(gpk, RC, σ, M ):

If both of the following sub-
algorithms produce an output value of valid, this al-
gorithm outputs the value valid; otherwise, it outputs
the value invalid.

– SignCheck(gpk, σ, M ): With the group public key
gpk and a purported signature σ on a message M ,
this sub-algorithm outputs the value valid if σ is
an honest signature on M ; otherwise, it outputs
the value invalid.

– RevCheck(RC, σ): With a revocation code RC
and a purported signature σ, this sub-algorithm
outputs the value valid if the alias token xik em-
bedded in σ is determined to be unrevoked; oth-
erwise, it outputs the value invalid.

• Revoke(grti, RC): This algorithm updates the revo-
cation code RC using the revocation token grti if the
membership of signer i is to be revoked. Here, revoking
the membership of the signer is equivalent to revoking
her private key and revoking all of her alias tokens.

• Open(reg, σ, M ): Given a valid signature σ on a mes-
sage M , created by a signer i ∈ [1, n], this algorithm
outputs the signer’s identity i.

In this paper, we assume that the group manager runs
KeyGen to set-up the group, Join to add a signer to the
group, Revoke to revoke a private key of a signer, and Open
to open a signature. The signer runs Sign to sign a message,
and the veriﬁer runs Verify to verify a signed message.

In the following discussion, we review the three attributes

of GSs as per the deﬁnitions given in [2].

• Correctness: This ensures the following properties.

– Signature Correctness: This ensures that if a sig-
nature is generated by an honest signer, the sig-
nature check algorithm (i.e., SignCheck) outputs
the value valid.

– Identity Correctness: This ensures that if a sig-
nature is generated by an honest signer, the group
manager correctly reveals the identity of the signer
using the signature open algorithm (i.e., Open).

– Revocation Correctness: This ensures that if a
signature is generated by an honest signer using
an unrevoked private key, the revocation check al-
gorithm (i.e., RevCheck) outputs the value valid.

• Anonymity: This property ensures that no party ex-
cept the group manager is able to identify the signer
of a given signature.

• Traceability: This property requires that no colluding
set of signers (even consisting of the entire group) can
create signatures that cannot be traced back to a signer
in the group, or signatures that cannot be traced back
to some member of the colluding set.

The revocation correctness property is not considered a
core security property in most GSs. However, it is an impor-
tant property to consider in evaluating our proposed scheme,
GSPR, with respect to other GS schemes. GSPR satisﬁes
all of the security properties listed above with the exception
of the revocation correctness property. One of the intrinsic
attributes of GSPR that distinguishes it from all other GSs
is that it satisﬁes the revocation correctness property with
a certain probability, but not with certainty. GSPR exploits
the computational eﬃciency advantage of probabilistic al-
gorithm to signiﬁcantly reduce the computation cost of the
revocation check procedure. Below, we provide formal deﬁ-
nitions of the security properties mentioned above.

Deﬁnition 5. (Signature Correctness): It requires that
for all λ, n ∈ N, all (gpk, gms) obtained by KeyGen, all
(gski, grti, regi) obtained by Join for any i ∈ [1, n], and
all M ∈ {0, 1}∗,

SignCheck(gpk,Sign(gpk, gski, M ), M ) = valid.

Deﬁnition 6. (Identity Correctness): It requires that
for all λ, n ∈ N, all (gpk, gms) obtained by KeyGen, all
(gski, grti, regi) obtained by Join for any i ∈ [1, n], and
all M ∈ {0, 1}∗,

Open(reg,Sign(gpk, gski, M ), M ) = i.

Deﬁnition 7. (Revocation Correctness):

It requires
that for all λ, n ∈ N, all (gpk, gms) obtained by KeyGen,
all (gski, grti, regi) obtained by Join for any i ∈ [1, n], and
all M ∈ {0, 1}∗,

RevCheck(RC,Sign(gpk, gski, M )) = valid,

implies that the private key of the signer i is not revoked.

Deﬁnition 8. (Anonymity):

It requires that for each
PPT algorithm A, the advantage of A on winning the fol-
lowing game is negligibly small.

• Setup: The challenger runs KeyGen(λ) and Join(gms,
i, m), ∀i ∈ [1, n]. He obtains gpk, gsk, and reg. He
provides the algorithm A with gpk.

• Queries-Phase I : A queries the challenger about the

following.

– Signing: A requests a signature on an arbitrary
message M for an arbitrary member i. The chal-
lenger responds with the corresponding signature.
– Corruption: A requests the secret key of an ar-
bitrary member i. The challenger responds with
the key gski.

– Opening: A requests the identity of the signer
by providing a message M and its valid signature
σ created by signer i ∈ [1, n]. The challenger
responds with the signer’s identity i.

• Challenge: A outputs a message M and two members
i0 and i1 with the restriction that the corruption of
i0 and i1 have not been requested. The challenger
chooses φ R←− {0, 1}, and responds with the signature
σ∗ on M ∗ of member iφ.

1336• Queries-Phase II (Restricted Queries): After obtain-
ing the challenge, A can make additional queries of
signing, corruption and opening, except the corrup-
tion queries of i0 and i1, and the opening query of the
signature σ∗ on M ∗.

• Output: A outputs a bit φ′ indicating its guess of φ.

A wins the anonymity game if φ′ = φ. The advantage of A
is deﬁned as |Pr(φ′ = φ) − 1/2|.

Deﬁnition 9. (Traceability):

It requires that for each
PPT algorithm A, the probability that A wins the following
game is negligibly small.

• Setup: The challenger runs KeyGen(λ) and Join(gms,
i, m), ∀i ∈ [1, n]. He obtains gpk gsk, and reg. He
provides A with gpk, and sets U as empty.

• Queries: A queries the challenger about the following.
– Signing: A requests a signature on an arbitrary
message M for an arbitrary member i. The chal-
lenger responds with the corresponding signature.
– Corruption: A requests the secret key of an arbi-
trary member i. The challenger adds i to U , and
responds with the key gski.

• Output: A outputs a message M ∗ and a signature σ∗.

A wins the game if:

1. SignCheck(gpk, σ∗, M ∗) = valid;
2. σ∗ is traced to a member outside of U or the trace is

failure; and

3. A did not obtain σ∗ by making a signing query on M ∗.

4. PROPOSED SCHEME: GSPR

Before describing the low-level details of GSPR, we discuss
the motivation behind the concept of probabilistic revoca-
tion, which is one of the distinguishing attributes of GSPR.

4.1 Motivation for Probabilistic Revocation

In the GSs supporting VLR [3, 6, 16], the group manager
includes a revocation token corresponding to each revoked
private key in a revocation list, and distributes the revoca-
tion list to the veriﬁer. In each VLR based GS scheme, there
is an associated implicit tracing algorithm which utilizes the
revocation token to link a signature to a revoked private key
using which the signature is generated. This implicit algo-
rithm requires several exponentiation and/or bilinear map
operations which are computationally expensive. In the re-
vocation check procedure, the veriﬁer performs this implicit
tracing algorithm between the received signature, and each
revocation token in the revocation list. This means that the
computation time for the revocation check procedure of a
signature increases linearly with the number of revoked pri-
vate keys. Hence, the revocation check procedure becomes
the major bottleneck in the application of VLR based GSs
in real systems with large number of signers along with pos-
sibility of large number revoked private keys.

In this paper, we propose a VLR based GS, called Group
Signatures with Probabilistic Revocation (GSPR), in which
an alias token is embedded into the group signature gener-
ated by a signer in such a way that it can be utilized for the
purpose of revocation check procedure. GSPR signiﬁcantly
reduces the computation complexity of the revocation check
procedure by adopting two techniques. Firstly, it reduces
the computation cost of executing the implicit tracing al-
gorithm by using the alias tokens in generating signatures.
Secondly, it enables the veriﬁer to check the revocation sta-

tus of an alias token in a single step, instead of requiring the
veriﬁer to sequentially go through the revocation list and
execute the implicit tracing algorithm for each revocation
token included in the revocation list.

Speciﬁcally, the group manager issues a set of alias to-
kens corresponding to a private key of the signer, and the
signer embeds an alias token in each of its generated sig-
natures. When the private key of the signer is revoked,
all its corresponding alias tokens are added to a revocation
list. Further, each alias token is mapped to an “alias code”.
The group manager performs sample-by-sample addition of
all the alias codes corresponding to the alias tokens in the
revocation list to generate one code called the “revocation
code”. The revocation code, instead of the revocation list,
is provided to the veriﬁer. When the veriﬁer receives a par-
ticular signature with a particular alias token, he generates
the alias code corresponding to the alias token. The veri-
ﬁer computes the cross correlation of the alias code and the
revocation code. If the value of correlation exceeds a par-
ticular threshold, the veriﬁer presumes that the alias code
(of the signature being veriﬁed) is used to generate the re-
vocation code, and in turn concludes that the signature is
invalid because it is associated with a revoked alias token.
Otherwise, the veriﬁer concludes that the signature is valid.
The motivation for using alias codes comes from direct-
sequence spread spectrum (DSSS) systems used in commu-
nications [17]. DSSS is a modulation technique that enables
the receiver to remove undue interference and recover the
correct information from an aggregate of multiple signals
even when multiple transmitters send information simulta-
neously over a single channel. Information recovery is made
possible with the use of specially-crafted spreading codes.
Further, we discuss the speciﬁc technical details of GSPR.

4.2 Technical Details

p and Hg : {0, 1}∗ → G2

For a given security parameter λ ∈ N, we consider a bilin-
ear group pair (G1,G2) with isomorphism ψ. We represent
Hz : {0, 1}∗ → Z∗
2 as collision re-
sistant hash functions treated as random oracles. Also, we
consider a set of alias codes, Cp. The order of Cp is p which
is equal to the order of Z∗
p. Each element in Cp is an alias
code which is a vector of +1s and −1s of length l. Further,
we deﬁne a mapping function Fc : Z∗
p → Cp using which
an alias token in Z∗
p can be mapped to an alias code in
Cp. The details of Cp and Fc are discussed in Section 5.4.1.
G1, G2, ψ, Hz, Hg, Cp and Fc are considered public knowl-
edge. In the following paragraphs, we deﬁne the algorithms
that make up GSPR.

KeyGen(λ): With the security parameter λ ∈ N, this al-
gorithm generates the group public key gpk and the group
manager’s secret gms through the following steps.

1. Select a generator g2

R←− G2, and set g1 = ψ(g2) such

that g1 is a generator of G1.

2. Select γ R←− Z∗

p, and compute wk = gγk

2 , ∀k ∈ [0, m].

Note that w0 = g2.

The group public key is gpk = (g1, g2, w1, w2, · · · wm). The
secret belonging only to the group manager is given by gms =
γ. The output of this algorithm is (gpk, gms).

Join(gms, i, m): This algorithm adds the signer i as a mem-
ber of the group with the group manager’s secret gms, and
generates m alias tokens for signer i, and a corresponding
secret key gski. This algorithm also generates a revocation

1337token grti for signer i, and an entry in the registration list
regi using the following steps.

1. Select yi
2. Compute the set of m alias tokens,

R←− Z∗
p.

Xi = {xik : xik = Hz(yi, k), ∀k ∈ [1, m]},

(1)
where kth alias token of signer i is represented by xik.

3. Compute πi = Qm

k=1(γ + xik), and calculate

Ai = g1/πi

1

.

(2)

In the unlikely case, if πi = 0, restart from Step 1.

For signer i, the secret key is gski = (Ai, yi), the revocation
token is grti = Xi, and the entry in the registration list is
regi = Xi. Note that only the group manager has access
to reg. The output of this algorithm is (gski, grti, regi).
Sign(gpk, gski, M ): The inputs to the signing algorithm are
the group public key gpk, the signer’s secret key gski, and
the message to be signed M ∈ {0, 1}∗. This algorithm gen-
erates a signature σ on M using the following steps.

1. Generate the following parameters.

(b) Deﬁne πi = Qm

(a) Compute the alias tokens Xi using equation (1).
k=0 akγk, where
a0, a1, · · · , am ∈ Z∗
p are the coeﬃcients of the
polynomial πi with the variable γ, and compute

k=1(γ + xik) = Pm

Bi = gπi

2 =

wak
k .

(3)

mY

k=0

(c) For each xik ∈ Xi, deﬁne πi/(γ+xik) = Qm

j=1,j6=k

j=0 bjγj, where b0, b1, · · · , bm−1 ∈

(γ + xij) = Pm−1

Z∗

p are the coeﬃcients, and compute

Cik = gπi/(γ+xik)

2

=

m−1Y

j=0

w

bj
j .

(4)

2. Select a tuple (Ai, Bi, Cik, xik) by selecting some value
of k ∈ [1, m]. The signer utilizes a particular k to sign
all its signatures during some time interval. After this
time interval, she discards the alias token. When the
signer exhausts all its alias tokens, she runs the Join
algorithm again to fetch new secret key, and computes
corresponding set of new alias tokens.

3. Compute (ˆu, ˆv) = Hg(gpk, M, xik), and calculate their

images in G1, such that u = ψ(ˆu) and v = ψ(ˆv).

4. Select α, β, δ R←− Z∗

p, and compute T1 = uα, T2 = Aivα,

T3 = Bβ

i , and T4 = C δ
ik.

5. Compute the signature of knowledge (SP K) [16] which

is expressed as follows.
V = SP K{(α, β, δ, xik, Ai, Bi, Cik) :

, Cik)}(M )

i , T4 = C δ
T1 = uα, T2 = Aivα, T3 = Bβ
ik,
1 gxik
e(Ai, Bi) = e(g1, g2), e(g1, Bi) = e(gγ
= SP K{(α, β, δ, xik, Ai, Bi, Cik) :
T1 = uα, e(T2, T3) = e(v, T3)α e(g1, g2)β,
1 = e(g1, T3)δ e(ψ(w1)gxik
, T4)−β}(M ).

1

(5)
This SP K is computed with the Fiat-Shamir heuristic
method [9] using the following steps.

1

(a) Select binding factors rα, rβ, rδ

R←− Z∗

p, and com-

pute

R1 = urα , R2 = e(v, T3)rα e(g1, g2)rβ ,
R3 = e(g1, T3)rδ e(ψ(w1)gxik
, T4)−rβ .

1

(6)

(b) Compute the challenge c as

c = Hz(gpk, M, xik, T1, T2, T3, T4, R1, R2, R3).

(c) Compute responses, sα = rα + cα, sβ = rβ + cβ,

and sδ = rδ + cδ.

The output of this algorithm is the signature

σ = (xik, T1, T2, T3, T4, c, sα, sβ, sδ).

(7)

Verify(gpk, RC, σ, M ): The veriﬁcation algorithm takes as
input the group public key gpk, the revocation code RC,
the signature σ, and the message M . Using the following
sub-algorithms, it veriﬁes two things: (1) whether the sig-
nature was honestly generated, and (2) revocation status of
the alias token used to generate the signature. If both the
sub-algorithms output valid, this algorithm outputs valid;
otherwise it outputs invalid.

• SignCheck(gpk, σ, M ): With the group public key gpk
and a purported signature σ on a message M , this sub-
algorithm outputs valid if σ is an honest signature on
M . This is checked using the following steps.

1. Compute (ˆu, ˆv) = Hg(gpk, M, xik), and calculate
their images in G1, i.e., u = ψ(ˆu) and v = ψ(ˆv).

2. Retrieve:

3. Check the correctness of the challenge c as

1 , eR2 = e(v, T3)sα e(g1, g2)sβ e(T2, T3)−c

eR1 = usα T −c
eR3 = e(g1, T3)sδ e(ψ(w1)gxik
c ?= Hz(gpk, M, xik, T1, T2, T3, T4, eR1, eR2, eR3).

If the above equation holds, this sub-algorithm
outputs valid; otherwise, it outputs invalid.

, T4)−sβ .

(8)

1

• RevCheck(RC, σ): The inputs to the revocation check
algorithm are the alias token xik embedded in the sig-
nature σ, and the revocation code, RC. The purpose of
this sub-algorithm is to check whether the alias token,
xik, has been revoked or not, which is accomplished
using the following steps.

1. Map xik to the corresponding alias code sik, i.e.,
compute sik = Fc(xik), where sik is a column
vector of length l of samples of +1s and −1s.

2. Compute the value of the decision variable, z =

1

l sT

ikRC, where sT

ik is the transpose of sik.

3. Output invalid if z ≥ τ , where τ is a pre-determined

threshold; otherwise, output valid.

Revoke(grti, RC): The inputs to this algorithm are the re-
vocation token of the signer, grti, and the current revo-
cation code, RC. To revoke signer i, the group manager
updates the revocation code using the following steps.

1. Map each xik ∈ grti to the corresponding alias code

sik, i.e., compute sik = Fc(xik) for k = 1, 2 · · · m.

2. Compute the code, ¯si, by adding all the unique alias
codes corresponding to the revoked alias tokens such

that ¯si = Pm

k=1 sik.

3. Update the revocation code as RC = RC + ¯si.

Open(reg, σ, M ): With the valid signature σ on message
M , the actual signer of the signature is identiﬁed using the
following step.

1. Search the registration list reg to ﬁnd signer i that

has generated signature σ with the alias token xik.

2. If a match is successfully found, output i; otherwise,

output 0 to indicate a failure.

13385. SECURITY ANALYSIS

5.1 Signature and Identity Correctness

It can be shown that GSPR satisﬁes the signature correct-
ness and the identity correctness properties. Security proofs
for these properties can be constructed using the frameworks
discussed in [6]. We omit the proofs for the sake of brevity
of the paper.

5.2 Anonymity

Theorem 1. In the random oracle model, suppose an al-
gorithm A breaks the anonymity of GSPR with advantage
ǫ after qH hash queries and qS signing queries, then there
exists an algorithm B that breaks the DLIN assumption with
the advantage (1/n2 − qSqH /p)ǫ/2.

This theorem prescribes that GSPR satisﬁes the anonymity
property in the random oracle model when the DLIN as-
sumption is presumed. In [6], the core technique used in the
proof of anonymity is the randomness of (ˆu, ˆv) such that the
challenger can backpatch the hash oracle. GSPR also pre-
serves the randomness of (ˆu, ˆv). Hence, we can employ the
same technique, and the proof construction method used in
[6] to prove Theorem 1. However, here we omit the proof
due to space constraints.

Note that within a time interval, the signer uses the same
alias token to generate all the signatures, and hence those
signatures can be linked to the same signer. However, the
signer utilizes diﬀerent alias tokens in diﬀerent time inter-
vals, and thus non-linkability is preserved between diﬀerent
time intervals. For many applications, the duration of each
time interval is small (e.g., 1 minute in vehicular networks
[20]), resulting in only a few linkable signatures.

In GSPR, all of the previous signatures generated using
a revoked private key can be linked together using the im-
plicit tracing algorithm. The scheme proposed in [6] as well
as most other VLR schemes share this drawback. This draw-
back can be mitigated in a number of ways, including the
use of time-stamped parameters [16] or the use of accumula-
tors [21]. However, these methods incur additional overhead
that may be unacceptable in many applications.

5.3 Traceability

We consider traceability property of GSPR in Theorem 2,

and utilize Lemma 1 to prove it.

2

Lemma 1. Suppose an algorithm A which is given an in-
2 , · · · , ˜gγm
) and n tuples ( ˜Ai, xi1, xi2, · · · xim),
stance (˜g1, ˜g2, ˜gγ
∀i ∈ [1, n], where xik ∈ Z∗
p ∀i ∈ [1, n], k ∈ [1, m], ˜g2 ∈ G2,
˜g1 = ψ(˜g2) and ˜Ai = ˜g1/ Qm
k=1(γ+xik)
, forges a tuple ( ˜A∗, ˜B∗,
˜C∗, x∗) for some ˜A∗ ∈ G1, ˜B∗ ∈ G2, ˜C∗ ∈ G2 and x∗ 6= xik
∀i ∈ [1, n], k ∈ [1, m] such that e( ˜A∗, ˜B∗) = e(˜g1, ˜g2) and
e(˜g1, ˜B∗) = e(˜gγ
1 , ˜C∗), then there exists an algorithm B
solving q-BSDH problem, where q = (n + 1)m.

1 ˜gx∗

1

Proof. Algorithm B is given a q-BSDH instance repre-
sented by (g1, w0, w1, · · · , wq), where wj = gγj
2 , ∀j ∈ [0, q].
B sets q = (n + 1)m. The objective of B is to produce a
BSDH pair (e(g1, g2)1/(γ+d), d) for some d ∈ Z∗
p. For this, B
creates the following framework to interact with A.

Setup: B does the following.
R

1. Select nm values: xik

←− Z∗

p, ∀i ∈ [1, n], k ∈ [1, m].

2. Deﬁne πi = Qm

k=1(γ + xik), and f (γ) = Qn

Pnm
j=0 αjγj, where α0, α1, · · · , αnm ∈ Z∗

ﬁcients of the polynomial f with variable γ.

i=1 πi =
p are the coef-

αj
j=0 w
j
αj
j=0 w

2 = Qnm
3. Compute ˜g2 = gf (γ)
2 = Qnm
4. Compute ˜wk = ˜gγk
5. Deﬁne fi(γ) = f (γ)/πi = Qn
where a0, a1, · · · , anm−m ∈ Z∗
the polynomial fi.
= gfi(γ)

6. Calculate ˜Di = ˜g1/πi

2

, and ˜g1 = ψ( ˜g2).

j+k, ∀k ∈ [0, m].
j=1,j6=i πj = Pnm−m

ajγj,
p are the coeﬃcients of

j=0

2

= Qnm−m

j=0 w

aj
j , and

˜Ai = ψ( ˜Di).

7. Send ( ˜Ai, xi1, xi2, · · · , xim), ∀i ∈ [1, n], and (˜g1, ˜w0, ˜w1,

· · · , ˜wm) to A.

1

Note that with this information, A or B can compute nm
tuples ( ˜Ai, ˜Bi, ˜Cik, xik) such that e( ˜Ai, ˜Bi) = e(˜g1, ˜g2) and
e(˜g1, ˜Bi) = e(˜gγ
1 ˜gxik
1. Deﬁne πi = Qm

k=0 bkγk, where b0, b1,
p are the coeﬃcients of the polynomial de-

, ˜Cik) in the following manner.
k=1(γ + xik) = Pm
2 = Qm

2. Compute ˜Bi = ˜gπi
3. Deﬁne fik(γ) = πi/(γ + xik) = Qm
Pm−1
j=0 cjγj, where c0, c1, · · · cm−1 ∈ Z∗

j=1,j6=k(γ + xij) =
p are the coeﬃ-

· · · bm ∈ Z∗
ﬁned by πi.

k=0 ˜wbk
k .

cients of the polynomial fik.

4. Compute ˜Cik = ˜gfik(γ)
Also, A or B can compute nm BSDH pairs ( ˜Eik, xik) in

j=0 ˜w

2

cj
j .

= Qm−1

the following manner.

˜Eik = e( ˜Ai, ˜Cik) = e(˜g1, ˜g2)1/(γ+xik).

Output: A outputs a forged tuple ( ˜A∗, ˜B∗, ˜C∗, x∗), for some
˜A∗ ∈ G1, ˜B∗ ∈ G2, ˜C∗ ∈ G2 and x∗ 6= xik, ∀i ∈ [1, n], k ∈
[1, m], such that e( ˜A∗, ˜B∗) = e(˜g1, ˜g2) and e(˜g1, ˜B∗) =
e(˜gγ

1 ˜gx∗
Having received the forged tuple from A, B generates a
1. Deﬁne

new BSDH pair in the following manner.

1 , ˜C∗).

E′ = e(A∗, C∗) = e(˜g1, ˜g2)1/(γ+x∗) = e(˜g1, g2)f (γ)/(γ+x∗).
polynomial fd(γ) = Pnm−1

2. Rewrite f (γ) as f (γ) = (γ + x∗)fd(γ) + d∗ for some
djγj, and constant d∗ ∈

j=0

Z∗

p. This means that

E′ = e(˜g1, g2)fd(γ)+d∗/(γ+x∗).

3. Compute gfd(γ)

2

dj
j , and

j=0 w

= Qnm−1
)(cid:17)1/d∗

2

= e(˜g1, g2)1/(γ+x∗)

˜E = (cid:16)E′/e(˜g1, gfd(γ)
= e(g1, g2)f (γ)/(γ+x∗) = e(g1, g2)fd(γ)+d∗/(γ+x∗).
E∗ = (cid:16) ˜E/e(g1, gfd(γ)

= e(g1, g2)1/(γ+x∗).

)(cid:17)1/d∗

2

4. Calculate

Hence, B returns the tuple (E∗, x∗) as the solution to the

submitted instance of the BSDH problem.

Theorem 2. In the random oracle model, suppose an al-
gorithm A breaks the traceability of GSPR with advantage ǫ,
after qH hash queries and qS signature queries, then there
exists an algorithm B that breaks the q-BSDH assumption
with advantage (ǫ/n − 1/p)2/16qH , where q = (n + 1)m.

Proof. The following is an interaction between A and B.

1339Setup: B is given a bilinear group pair (G1, G2) with respec-
tive generators g1 and g2. B is also given (w0, w1, · · · wm),
where wk = gγk
2 , ∀k ∈ [0, m]. Further, B is given (Ai, yi),
∀i ∈ [1, n]. For each i, either si = 1 indicating that a valid
key pair (Ai, yi) generated using equations (1) and (2) is
known, or si = 0 indicating that Ai corresponding to yi is
not known. We run A giving it gpk = (g1, w0, w1, · · · wm)
and yi, ∀i ∈ [1, n]. Note that yi can be used to generate the
alias tokens using equation (1).
Queries: A can query B about the following.

• Hash queries: A queries the hash functions Hz and Hg,
and B responds with random values with consistency.
• Signing queries: A requests a signature of member i on
message M . If si = 1, B responds with the signature
σ using Sign algorithm with the private key (Ai, yi). If
si = 0, B selects xik, α, β, δ to compute T1, T2, T3 and
T4 and the SPK V as in equation (5). If the hash func-
tion causes a collision, B declares failure and aborts;
otherwise, B responds with σ = (xik, T1, T2, T3, T4, c,
sα, sβ, sδ). We assume that the signing queries related
to a signer does not exceed m.

• Corruption queries: A requests the secret key of mem-
If si = 1, B adds i to U , and responds with
ber i.
(Ai, yi); otherwise, B declares failure and aborts. With
(Ai, yi), A can compute alias tokens xik, ∀k ∈ [1, m]
using equation (1), Bi using equation (3), and Cik,
∀k ∈ [1, m] using equation (4).

Output: Finally, if A is successful, it outputs a forged sig-
nature σ∗ on a message M ∗ using tuple (Ai′ , Bi′ , Ci′k, xi′k).
If B fails to ﬁnd the signer i′ in U , it outputs σ∗; otherwise,
B identiﬁes some i′ = i. If si′ = 0, B outputs σ∗; otherwise,
B declares failure and aborts.

With the above framework, there can be two types of
forger algorithms [6]. Type I forger forges a signature of
the member who is diﬀerent from all i ∈ [1, n]. Type II
forger forges a signature of the member i ∈ [1, n] whose cor-
ruption is not requested. B treats these two types of forg-
ers diﬀerently. Note that using the technique of Lemma 1,
with a q-BSDH instance (ˆg1, ˆg2, ˆgγ
2 ), B can obtain
(g1, g2, gγk
), and (q − m) BSDH pairs. Moreover,
any BSDH pair besides these (q − m) pairs can be trans-
formed into a solution to the original q-BSDH instance which
means that the q-BSDH assumption is broken.

2 , · · · , gγm

2 , · · · ˆgγq

2

2 , · · · , gγm

2

Type I Forger : From an instance of (n+1)m-BSDH, B ob-
tains (g1, g2, gγk
), and n tuples (Ai, xi1, xi2, · · · xim).
From these n tuples, B obtains n valid key pairs (Ai, yi) by
setting Hz(yi, k) = xik, ∀i ∈ [1, n], k ∈ [1, m]. B applies the
above framework to A. The framework succeeds whenever
A succeeds. Hence, B obtains the Type I forgery with the
probability ǫ.
Type II Forger : From an instance of nm-BSDH, B obtains
(g1, g2, gγk
), and n− 1 tuples (Ai, xi1, xi2, · · · xim).
From these n − 1 tuples, B obtains n − 1 valid key pairs
(Ai, yi) by setting Hz(yi, k) = xik ∀i ∈ [1, n − 1], k ∈ [1, m].
These n − 1 pairs (Ai, yi) are distributed among n indices.
B sets si′ = 0 for the unﬁlled entry at random index i′. B
selects Ai′
p. B applies the framework
to A. The framework succeeds only if A never requests the
corruption of member i′, but forges a signature that traces
to Ai′ . The value of i′ is independent of the views of A,

←− G1, and yi

2 , · · · , gγm

←− Z∗

2

R

R

and hence B obtains the Type II forgery with probability at
least ǫ/n.
B obtains another BSDH pair beyond the given nm BSDH
pairs using the framework with Type I or Type II forger in
the following manner, contradicting the BSDH assumption.
B rewinds the framework to obtain two forged signatures on
the same message, where the commitments are the same,
but the challenges and responses are diﬀerent. The proba-
bility of success in achieving this is at least (ǫ′ − 1/p)2/16qH
by the forking lemma [6, 18], where ǫ′ is the probability
that the framework on each forger succeeds. B extracts
(A∗, B∗, C∗, x∗) encoded in the forged signatures [6]. Fur-
ther, B obtains a BSDH pair from (A∗, B∗, C∗, x∗) using the
technique discussed in Lemma 1. The framework is success-
ful only if the extracted BSDH pair is not among the BSDH
pairs created by B. Therefore, B obtains a new BSDH pair
with the probability (ǫ′ − 1/p)2/16qH .
Hence, we have shown that B can solve the (n+1)m-BSDH
instance with probability (ǫ−1/p)2/16qH using Type I forger,
and the nm-BSDH instance with probability (ǫ/n−1/p)2/16qH
using Type II forger. Therefore, the pessimistic Type II
forger proves the theorem. This implies that traceability
is satisﬁed in GSPR in the random oracle model under the
BSDH assumption.

5.4 Revocation Correctness

In the following discussion, we analyze the correctness
of the results generated by the revocation check algorithm,
RevCheck. The revocation correctness depends on the cross
correlation property of the alias codes since the revocation
code is generated by summing over multiple alias codes.
Here, we discuss two categories of codes from the existing
literature which can be potentially used as alias codes—
orthogonal codes and non-return-to-zero (NRZ) based ran-
dom codes. Through analytical results, we show that or-
thogonal codes and random codes are both inadequate for
use in GSPR. Hence, we propose a new type of codes which
we refer to as piecewise-orthogonal codes which can be used
as alias codes. With the use of piecewise-orthogonal codes,
GSPR’s RevCheck algorithm does not determine the revoca-
tion status of a private key with certainty, but instead with
a certain probability.
If an alias token has been revoked
and its corresponding alias code has been included in the
revocation code, then RevCheck’s result is guaranteed to be
correct. However, there is a possibility of a false alarm. Us-
ing an iterative algorithm, this probability can be decreased
iteratively, a la the well-known Miller-Rabin primality test
algorithm [19]. The details of the revocation check proce-
dure and iterative algorithm are given in Section 5.4.1.

For analyzing the revocation correctness, we deﬁne the
two hypotheses—H0 : xik has been revoked, and H1 : xik
has not been revoked. Here, the probability of false nega-
tive/dismissal, Pf d, can be deﬁned as the probability of er-
roneously determining that a given alias token has not been
revoked when it has been revoked by the group manager.
In RevCheck, Pf d is equal to the probability of z < τ when
H0 is true. Also, probability of false positive/alarm, Pf a,
can be deﬁned as the probability of the veriﬁer erroneously
determining that a given alias token has been revoked when
it has not been revoked by the group manager. In RevCheck,
Pf a is equal to the probability of z ≥ τ when H1 is true.
Further, we suppose that the number of revoked private keys
is represented by nr, and each alias token (or each element

1340Table 1: The alias and revocation codes used in the example.

s1
s2
s3
s4
s5

RC = s1 + s2

+1 −1 −1 +1 +1 −1 −1 +1
+1 +1 −1 −1 +1 +1 −1 −1
+1 −1 +1 −1 +1 −1 +1 −1
+1 −1 −1 +1 +1 −1 +1 −1
+1 −1 −1 +1 +1 +1 −1 −1
+2
0

−2

−2

0

0

+2

0

in Z∗
p) is represented by bp = 160 bits. Note that the number
of revoked alias tokens (i.e., m · nr) is equal to the number
of revoked alias codes, and the length of the revocation code
is equal to the length of an alias code (i.e., l).

Orthogonal Codes: Orthogonal or Walsh codes consist
of codes with zero cross-correlation [7]. When the two codes
are the same, the value of the cross-correlation is 1; other-
wise, it is 0. If these codes are used as alias codes, we can
set the threshold τ = 1, and the revocation check procedure
with Pf d = 0 and Pf a = 0 can be achieved. This means
that if we use orthogonal codes as alias codes, GSPR would
be able to satisfy the revocation correctness property with
certainty. However, there are only l unique orthogonal codes
of length l samples. This means that if orthogonal codes are
indexed using the alias token xik which is represented by
bp = 160 bits, then the length of each alias code has to be
l = 2160 samples long! Hence, it is prohibitively costly in
terms of storage and processing overhead to use completely
orthogonal codes as alias codes.

NRZ based Random Codes: Random codes can be
generated by NRZ encoding of a random sequence of bits,
which means bit 0 is mapped to sample −1, and bit 1 is
mapped to sample +1. As a result, the number of unique
random codes with length bp is given by 2bp . If the random
codes are utilized as alias codes, we can generate an alias
code of length, l = bp = 160 samples, by NRZ encoding of
an alias token, xik. Although the use of random codes (as
alias codes) allows us to use compact alias codes, they have
a critical drawback; use of random codes results in Pf d > 0.
As a result of the random nature of the codes, there are
inevitable false dismissals, which means there is signiﬁcant
possibility that the veriﬁer would not be able to detect a
revoked private key. This is untenable in PPA as this could
be utilized by adversaries to bypass the revocation check.

As discussed above, orthogonal codes as well as random
codes have critical drawbacks that limit their utility as alias
codes. Hence, we propose a new type of codes that we call
piecewise-orthogonal codes. The use of piecewise-orthogonal
codes enables us to create alias codes that are compact and
have a very desirable property—viz., Pf d = 0 and Pf a > 0.
In other words, when we use piecewise-orthogonal codes, the
probability of false dismissals is guaranteed to be zero, al-
though the probability of false alarms is non-zero. Note that
ensuring Pf d = 0 is much more important than Pf a = 0 from
a security point of view. The former implies that a revoked
alias token can detected by RevCheck with 100% certainty.
In the next subsection, we provide details on how piecewise-
orthogonal codes are used in probabilistic revocation.

5.4.1 Revocation with Piecewise-Orthogonal Codes
In GSPR, we utilize piecewise-orthogonal codes as alias
codes for achieving probabilistic revocation. The piecewise-
orthogonal codes are generated by concatenating multiple
segments where each segment is an orthogonal code. To gen-

erate a piecewise-orthogonal code as an alias code, an alias
token is divided into multiple segments, and an orthogonal
code is generated corresponding to each segment. These or-
thogonal codes corresponding to the segments of the alias
token are concatenated to form the complete alias code. In
this way, the alias codes are piecewise-orthogonal.

Speciﬁcally, a set of 2bs orthogonal codes, denoted by Cs,
is generated using the technique discussed in [7], where each
orthogonal code is of length 2bs . Note that an orthogonal
code in Cs can be retrieved using a bs-bit index. Further,
each alias token xik ∈ Z∗
p of bp bits is divided into d segments
each of length bs bits, such that d · bs ≤ bp < (d + 1) · bs.
The segments of the alias token xik are represented by xik,j,
∀j ∈ [1, d]. Further, ∀j ∈ [1, d], xik,j is utilized to generate
bs-bit index so that an orthogonal code sik,j is chosen from
Cs. Finally, all the d orthogonal codes, sik,j, ∀j ∈ [1, d],
are concatenated to generate the alias code sik. The length
of the resulting revocation code is l = d · 2bs . The group
manager declares the two public parameters Cp and Fc, such
that the set of all possible alias codes Cp = Cd
s, and the
mapping function Fc : Z∗
p → Cp is deﬁned as segment-wise
indexing as discussed above.

When the revocation code is generated using the Revoke
algorithm, each segment of the revocation code is generated
by summation of the corresponding segments of the revoked
alias codes. Hence, the generated revocation code also has d
segments, represented by RCj, ∀j ∈ [1, d]. Note that due to
the property of orthogonal codes, the cross-correlation of a
revocation code’s segment and an orthogonal code results in
one of the two values—(1) 0 if the revocation code was not
generated by the orthogonal code, or (2) an integral multiple
of 1 if the revocation code was generated by the orthogonal
code. Hence, the threshold τ is set to 1.

Having received a signature with alias token xik, the ver-
iﬁer can run RevCheck for each of the d segments. However,
to minimize the computational overhead, the veriﬁer only
runs RevCheck for a segments. This means that RevCheck
can be re-organized as follows.

RevCheck(RC, σ)
1. Set j = 1.
2. Generate a bs-bit index from xik,j, and select an or-

thogonal code sik,j from Cs.

3. Compute z = 1

2bs sT

ik,j · RCj. If z ≥ 1, output invalid;

otherwise, output valid, and exit.

4. Set j = j + 1. If j ≤ a, go to Step 2; otherwise, exit.

5.4.2 Example

We illustrate the revocation check procedure in GSPR
through an example. The alias codes and the revocation
code used in the example are given in Table 1. We as-
sume that there are ﬁve 4-bit alias tokens represented by
x1 = {1111}, x2 = {1010}, x3 = {0101}, x4 = {1101} and
x5 = {1110}. Also, we assume that Cs contains 22 = 4
orthogonal codes. The group manager generates the alias
codes s1, s2, s3, s4, and s5—corresponding to x1, x2, x3,
x4, and x5, respectively—by concatenating two orthogonal
codes of length 4 samples. Suppose that the group man-
ager needs to revoke alias tokens x1 and x2. Hence, the
group manager computes the sample-by-sample addition of
the alias codes s1 and s2. The resulting vector is the revoca-
tion code, represented by RC. The group manager provides
the veriﬁer with RC. In this scenario, if the veriﬁer receives
a signature with the alias token x1, he runs two iterations

1341)

a
f

P

(
 

m
r
a
a

l

 

e
s
a

l

f
 
f

o

 
y
t
i
l
i

b
a
b
o
r
P

0
10

−2

10

−4

10

10

−6
1

)

a
f

P

(
 

m
r
a
a

l

 

e
s
a

l

f
 
f

o

 
y
t
i
l
i

b
a
b
o
r
P

6

7

8

Number of revoked private keys, n
=1024
r
Number of revoked private keys, n
=2048
r
5

2

3

4

Number of iterations (a)

0
10

−5

10

−10

10

−15

10

10

Number of revoked private keys, n
=1024
r
Number of revoked private keys, n
=2048
r
18

12

14

16

20

Number of bits in each segment of an alias token (b
s

22

24

)

Figure 1: Probability of false alarm vs. number of itera-
tions.

Figure 2: Probability of false alarm vs. number of bits in
each segment of an alias token.

4 sT

4 sT

1,1 · RC1 = 1, and 1

of RevCheck. In the ﬁrst iteration, the veriﬁer computes the
cross correlation between the ﬁrst segments, i.e., ﬁrst 4 sam-
ples of s1 and RC, represented by s1,1 and RC1, respectively.
In the second iteration, the veriﬁer computes the cross cor-
relation between the second segments, i.e., second 4 samples
of s1 and RC represented by s1,2 and RC2, respectively. The
cross correlation is computed by sample-by-sample multipli-
cation of the alias code and the revocation code followed by
the addition of all the products, and the resulting value is
given by 1
1,2 · RC2 = 1. Since the
cross correlation of both the segments resulted in the value
of 1, the veriﬁer concludes that x1 has been revoked. Using
the same procedure, the veriﬁer concludes that x2 has also
been revoked. On the other hand, if the veriﬁer receives a
signature with the alias token x3, he will conclude that the
alias token is valid because the cross correlation of s3,1 with
RC1 is 0. Here, the RevCheck algorithm exits after the ﬁrst
iteration. Now, let us take a look at x4. The cross correla-
tion of s4,1 and s4,2 with RC1 and RC2 results in the values
1 and 0, respectively. Here, if the veriﬁer makes a decision
after only computing the correlation of the ﬁrst segment, to
decrease its computational overhead, he erroneously deter-
mines that x4 has been revoked because this is an instance
of a false alarm. However, after computing the correlation of
the second segment, the veriﬁer can conclude with absolute
conﬁdence that x4 has not been revoked because Pf d = 0.
Lastly, the cross correlation of s5,1 and s5,2 with RC1 and
RC2 results in 1 and 1, respectively. Hence, if the veriﬁer
receives a signature with an alias token x5, he erroneously
concludes that x5 has been revoked.

5.4.3 Discussions on the False Alarm Probability

With the proposed piecewise-orthogonal codes, the prob-
ability of false dismissal is zero, i.e., Pf d = 0. However, after
checking a segments, the upper bound of the probability of
false alarm (Pf a) can be computed to be

Pf a =

(mnr)a 2bp−abs − mnr

=

2bp − mnr

na
t 2bp − mnr
2bp − mnr ≈ na

t

(9)

where the ratio of the number of revoked alias tokens and the
length of one segment of the revocation code is represented
by nt = mnr/2bs . For nt < 1, Pf a decreases by increasing
a which is the maximum number of iterations or segments
processed by the veriﬁer before making a revocation status
decision. Here, we assume that all revoked alias tokens have
unique segments, and hence the above equation gives the

upper bound of Pf a. Note that each alias token of bp bits is
unique; however each segment of an alias token, which is bs
bits long, is not necessarily unique.

t

If the veriﬁer runs RevCheck for a iterations, then the
length of the alias code that has to be processed is lr =
a · 2bs , and Pf a ≈ nlr nt/mnr
. Note that the computational
overhead for RevCheck is directly proportional to lr. There is
a tradeoﬀ between Pf a and RevCheck’s computational cost,
and there are a number of diﬀerent strategies for making an
advantageous tradeoﬀ. One possible strategy is to construct
the revocation code in such a manner that minimizes Pf a
for a given value of lr and for a given number of revoked
alias tokens (i.e., mnr) by selecting an optimal value of bs.
Once the optimal value of bs is computed, the corresponding
nt can be computed using the relation nt = mnr/2bs . This
value can be readily derived as nt = exp(−1) ≈ 0.3679.
However, mnr and 2bs are both integer values, and hence
to minimize Pf a, the group manager needs to select bs such
that exp(−1)/2 ≤ mnr/2bs < 3 exp(−1)/2.
As discussed above, the number of iterations (i.e., a) and
the number of bits in each segment of an alias token (i.e., bs)
are adjustable parameters that directly impact Pf a. Figure 1
shows the impact of a on Pf a for a ﬁxed value of bs = 19.
This ﬁgure suggests that the veriﬁer can decrease Pf a at
the cost of increasing the computational cost of performing
RevCheck. Figure 2 illustrates the impact of bs on Pf a when
the veriﬁer utilizes all of the d segments of the revocation
code to check the revocation status of an alias token.
In
both ﬁgures, we ﬁxed the values m = 120 and bp = 160 bits.

5.4.4 Security Implications of the Alias Codes

There is a one-to-one mapping between an alias code and
an alias token deﬁned by Fc. Although the alias codes have a
non-random structure, the alias tokens, which are embedded
in the signature, are random numbers under the random
oracle model. Hence, the use of alias codes should have
no impact on the traceability property of GSPR, which is
deﬁned by Theorem 2.

6. PERFORMANCE EVALUATION

In this section, we evaluate the computational and com-
munication overhead of GSPR, and compare GSPR’s per-
formance with two schemes in the prior art—the Boneh-
Shacham (BS) scheme proposed in [6] and the Bichsel-Camenisch-
Neven-Smart-Warinschi (BCNSW) scheme proposed in [3].

1342GSPR
BS
BCNSW

5
10

4
10

3
10

2
10

1
10

)
s
m

(
 

d
a
e
h
r
e
v
o

 
l

a
n
o

i
t

a

t

u
p
m
o
C

0
10

0
10

3
1
10
10
Number of revoked private keys (n
)
r

2
10

4
10

GSPR
BS
BCNSW
PS

6
10

4
10

2
10

0
10

)

B
K

(
 

d
a
e
h
r
e
v
o

 

n
o

i
t

i

a
c
n
u
m
m
o
C

−2

10

0
10

3
1
10
10
Number of revoked private keys (n
)
r

2
10

4
10

Figure 3: Computation overhead of verifying a signature
vs. the number of revoked private keys.

Figure 4: Communication overhead of transmitting the re-
vocation list/code vs. the number of revoked private keys.

Table 2: Comparison of computationally expensive opera-
tions.

GSPR

BS

BCNSW

Sign

SignCheck
RevCheck

Sign

SignCheck
RevCheck

Sign

SignCheck
RevCheck

Exp. in
G1/G2

6
2
0
5
4
0
3
0
0

Exp. in

Bilinear

GT
4
5
0
3
4
0
1
2
0

map

3
4
0
3
4

nr + 1

1
5
nr

Table 3: Comparison of computational overhead (ms).

GSPR

Sign
14.952
15.417
BCNSW 3.242

BS

SignCheck RevCheck

9.124
15.378
8.302

5.819

1628.729
1592.019

Table 4: Comparison of number of elements communicated
in the considered scenarios.

Elem.
in Z∗
p

Elem. in
G1/G2

Int.

GSPR

BS

BCNSW

manager-signer
signer-veriﬁer

manager-veriﬁer
manager-signer
signer-veriﬁer

manager-veriﬁer
manager-signer
signer-veriﬁer

manager-veriﬁer

1
5
0
1
5
0
1
2
0

1
4
0
1
2
nr
3
3
nr

0
0
l
0
0
0
0
0
0

Table 5: Comparison of communication overhead (bits).

GSPR

BS

BCNSW

manager-

signer

signer-
veriﬁer

672
672
1696

2848
1824
1856

manager-

veriﬁer
5.03 · 107
5.24 · 105
5.24 · 105

In [13], Manulis et al. concluded that BS and BCNSW are
two of the most practical group signature schemes in terms
of being scalable to large networks. We assume that isomor-
phism is an identity map which means that G1 = G2. We
assume symmetric 80-bit security level, which provides ap-
proximately the same level of security as an RSA signature
with a modulus size of 1024 bits. In an elliptic curve cryp-
tosystem, to achieve the same security strength, the length
of an element in Z∗
p, and G1 needs to be approximately equal
to 160 bits [6]. Speciﬁcally, we utilize the “Type A” inter-
nal described in pairing-based cryptography (PBC) library
available at [1]. The internal is constructed on a supersingu-
lar curve of the form y2 = x3 + x over the ﬁeld Fq for some
prime q = 3 mod 4.
p is
denoted by 160 bits, and an element in G1 or G2 is denoted
by 512 bits. For GSPR, we assume that the group manager
distributes 120 alias tokens for each signer, and the veriﬁer
needs the probability of false alarm to be less than 0.01.

In the internal, an element in Z∗

6.1 Computational Overhead

In this section, we compare the computational cost of
GSPR with two benchmarks—viz., BS and BCNSW. We
focus on three speciﬁc algorithms: Sign (signature genera-
tion algorithm), SignCheck (signature correctness checking
algorithm), and RevCheck (revocation status checking algo-
rithm). We focus on those algorithms because they need to
be executed on-line in real time, and moreover they need to
be performed by the signer and the veriﬁer, who have limited
computational capabilities compared to the group manager.
Firstly, we consider only the most computationally expen-
sive operations—i.e., exponentiation (Exp.) in G1, G2, or
GT , and bilinear mapping. Here, since G1 = G2, the applica-
tion of isomorphism is not considered. Table 2 provides the
number of operations needed in each of the three algorithms
for GSPR, BS and BCNSW. Note that in GSPR, the opera-
tions in Step 1 in the Sign algorithm are independent of the
message to be signed or the random parameters, and hence,
they can be pre-computed. Also, ψ(w1) and e(g1, g2) can
also be pre-computed. Further, in the RevCheck algorithm
in GSPR, the computational cost of computing the cross-
correlation between a revocation code and an alias code is l
integer additions since the length of the revocation code is l
with each element being an integer, and the alias code is a
vector of +1s and −1s.
By using the PBC library, we implement the three al-
gorithms for GSPR, BS and BCNSW, and measure their

1343running time on a PC platform with Intel(R) Core(TM)2
Duo CPU E8400 @ 3GHz. The measurements are obtained
by averaging over 1000 runs of each algorithm. Table 3 pro-
vides their running times on the PC platform. Here, we
assume that the number of revoked private keys is 1024, i.e,
nr = 1024. From Table 3, we can observe that there is no
signiﬁcant diﬀerence in the computation times of the three
schemes when comparing their performance with respect to
Sign and SignCheck. However, the diﬀerence between GSPR
and the other two schemes in terms of the computational
cost of RevCheck is signiﬁcant. GSPR’s RevCheck algorithm
is more than two orders of magnitude more eﬃcient than
those of the other two schemes. Hence, when we consider
the total signature veriﬁcation time which includes the time
needed to perform SignCheck as well as RevCheck, the run-
ning time in GSPR is signiﬁcantly less than that in BS and
BCNSW.

Figure 3 shows the computation time required to verify
a signature versus the number of revoked private keys. We
observe that with only a few thousand revoked private keys,
the computation times for BS and BCNSW quickly grow
to several seconds for verifying only one signature. In con-
trast, the growth rate of GSPR’s computation time is much
lower, which is primarily due to the computational eﬃciency
advantage of GSPR’s RevCheck.

6.2 Communication Overhead

We consider the three communication scenarios—between
the group manager and the signer (manager-signer), between
the signer and the veriﬁer (signer-veriﬁer), and between the
group manager and the veriﬁer (manager-veriﬁer).
In the
ﬁrst scenario, while joining the group, the group manager
sends a secret key to the signer. In the second scenario, the
signer sends a signature to the veriﬁer. Lastly, in the third
scenario, the group manager sends a revocation list/code
to the veriﬁer. Table 4 provides the number of elements
(Elem.) of Z∗
p, G1, G2 or integers (Int.) communicated in
each of the three scenarios for GSPR, BS and BCNSW. Note
that in GSPR, the alias tokens are generated by the signer
using the secret key obtained from the group manager, and
hence they do not need to be communicated.

Table 5 shows the required communication overhead of the
three schemes for the three scenarios, assuming nr = 1024.
Results from the table indicate that GSPR’s communica-
tion overhead is two orders of magnitude larger than those
of the other two schemes when considering the manager-
veriﬁer scenario. Hence, we can conclude that GSPR makes
an advantageous trade-oﬀ between computational overhead
and communication overhead. This trade-oﬀ is advanta-
geous because reducing the computational overhead is much
more critical than reducing the communication overhead
when considering scalability. Verifying a signature (which
includes checking the revocation status of the private key)
is an inherently on-line task which needs to be performed in
real time, and it can be the primary performance bottleneck
when the scheme is deployed in a large network. However,
the greater communication overhead incurred by GSPR in
the third (i.e., manager-veriﬁer) scenario can be readily mit-
igated by pre-fetching the revocation code before the veriﬁer
needs to verify a given signature.

In Figure 4, we compare four schemes in terms of the com-
munication overhead required to transmit the revocation list
(for GSPR, it is the revocation code). The top-most curve

10

20

30

40

50

60

GSPR
BS
BCNSW
70

80

)

%

(
 

o

i
t

a
r
 
s
s
o

l
 

e
g
a
s
s
e
m
e
g
a
r
e
v
A

 

100

80

60

40

20

0
0

Number of messages received per broadcast interval

Figure 5: Average message loss ratio vs. number of mes-
sages received per broadcast interval.

is the curve for a pseudonym-based signature (PS) with El-
liptic Curve Digital Signature Algorithm (ECDSA) with the
public key size of 192 bits to achieve the 80-bit security level.
For PS, we assume that the number of pseudonyms allot-
ted to each signer is 120, and the group manager publishes
public-key certiﬁcates of all the revoked pseudonyms in the
revocation list. In Figure 4, we observe that although the
communication overhead of GSPR is higher as compared to
BS and BCNSW, it is still lower than PS.

7. USE OF GSPR IN DSRC APPLICATIONS
To illustrate the practical advantages of GSPR, in this
section, we compare the signature veriﬁcation performance
of GSPR with two benchmarks (i.e., BS and BCNSW) for a
speciﬁc type of applications, viz., vehicular network (VANET)
safety applications. Since the allocation of the Dedicated
Short-Range Communications (DSRC) spectrum in the 5.9
GHz band by the Federal Communications Commission (FCC),
the automotive industry and the other stakeholders have
been actively developing DSRC technologies, with a partic-
ular focus on vehicular safety applications.

In a typical safety application, each vehicle broadcasts
beacon messages that contain information critical to safety,
such as speed, direction of movement, acceleration, etc. The
beacon messages need to be authenticated, but, at the same
time, the privacy of the transmitting vehicle’s driver must
be protected [12]. Without such protection, adversaries can
use the beacon messages to track the driver’s movement or,
worse yet, use them for more nefarious purposes. Hence,
safety applications is one important application domain for
privacy-preserving authentication techniques.

Typically, beacon messages are broadcast in intervals of
100 ms [12].
In high vehicular density scenarios, a given
vehicle is expected to receive a large number of beacon mes-
sages within a broadcast interval, and each message needs
to be authenticated before the arrival of the next message
from the same transmitter. If the authentication of the cur-
rent message cannot be ﬁnished before the arrival of the
next message, then the current message must be discarded
because it is considered to contain “stale” information. To
measure the impact of the computational cost of signature
veriﬁcation on the performance of safety applications, we
employ the average message loss ratio, which is deﬁned as
the ratio between the number of beacon messages discarded
due to signature veriﬁcation latency and the total number of

1344beacon messages received by a particular vehicle in a broad-
cast interval of 100 ms [12].

When simulating GSPR, we assume that each vehicle is
on the road for 2 hours per day [20], and replaces its current
alias token with a new one every minute, which equates to
120 alias tokens per day. The simulation results are shown
in Figures 5 assuming nr = 64. From this ﬁgure, we ob-
serve that GSPR’s signature veriﬁcation procedure is eﬃ-
cient enough to ensure acceptable performance for safety
applications under reasonably-favorable conditions. In con-
trast, our results suggest that the computational burden of
the veriﬁcation procedures used by BS and BCNSW is too
heavy for their use in vehicular safety applications.

8. RELATED WORK

The GS based schemes in the recent literature can be di-
vided into two categories based on their revocation check
procedures. In the ﬁrst category of techniques, the revoca-
tion check procedure takes place at the signers [8, 11, 15].
The scheme proposed in [15] achieves constant signing and
veriﬁcation time at the cost of the public key of O(√n)-
size, where n is the total number of signers in the network.
In [8], although the signing and veriﬁcation have constant
time along with constant-size group public key, the compu-
tational cost at the group manager grows with O(n2) which
means that the group manager becomes the bottleneck. The
scheme proposed in [11] achieves constant cost for signing
and veriﬁcation without signiﬁcantly increasing the size of
the public key. However, the length of each signature in [11]
is signiﬁcantly large, e.g., around 20 times that in [6]. While
the schemes proposed in [8, 15] are secure in the random or-
acle model, the scheme proposed in [11] is constructed in the
standard model.

In the second category of schemes, the revocation check
procedure takes place at the veriﬁer through veriﬁer-local
revocation (VLR) [3, 6, 16]. In these schemes, it is the re-
sponsibility of the veriﬁer to check whether a signer has been
revoked or not, by using the revocation list which contains
the revocation tokens corresponding to the revoked private
keys. However, the computational cost of revocation check
procedure in these schemes increases linearly with the num-
ber of revoked private keys. These schemes are secure in the
random oracle model.

9. CONCLUSION

In this paper, we proposed a novel privacy-preserving au-
thentication scheme called Group Signatures with Proba-
bilistic Revocation (GSPR). It is well known that revocation
is the primary performance bottleneck of modern group sig-
nature schemes and that existing schemes do not scale well
to large networks because of high computational cost of their
revocation check procedures. By using the novel concept
of probabilistic revocation, GSPR manages to signiﬁcantly
reduce the computational burden of the revocation check
procedure at the cost of increased communication overhead.
The negative impact of the increased communication over-
head can be mitigated by pre-fetching the revocation code
from the group manager before signature veriﬁcation.

10. ACKNOWLEDGMENTS

This work was partially sponsored by NSF through grants
1228903, 1265886, 1314598, and 1431244; by NSFC through

grant 61201245; and by the industry aﬃliates of the Broad-
band Wireless Access & Applications Center and the Wire-
less @ Virginia Tech group.

11. REFERENCES

[1] PBC: Pairing-based cryptography.

https://crypto.stanford.edu/pbc/. Accessed: May 1, 2015.

[2] M. Bellare, D. Micciancio, et al. Foundations of group

signatures: Formal deﬁnitions, simpliﬁed requirements, and a
construction based on general assumptions. In Advances in
Cryptology - EUROCRYPT, volume 2656, pages 614–629.
Springer Berlin Heidelberg, 2003.

[3] P. Bichsel, J. Camenisch, et al. Get shorty via group signatures

without encryption. In Security and Cryptography for
Networks, volume 6280, pages 381–398. Springer Berlin
Heidelberg, 2010.

[4] D. Boneh, X. Boyen, et al. Short group signatures. In

Advances in Cryptology - CRYPTO, volume 3152, pages
41–55. Springer Berlin Heidelberg, 2004.

[5] D. Boneh, B. Lynn, et al. Short signatures from the weil

pairing. In Advances in Cryptology - ASIACRYPT, volume
2248, pages 514–532. Springer Berlin Heidelberg, 2001.

[6] D. Boneh and H. Shacham. Group signatures with veriﬁer-local

revocation. In Proceedings of the 11th ACM Conference on
Computer and Communications Security (CCS), pages
168–177, 2004.

[7] E. H. Dinan and B. Jabbari. Spreading codes for direct

sequence CDMA and wideband CDMA cellular networks.
Communications Magazine, IEEE, 36(9):48–54, 1998.

[8] C.-I. Fan, R.-H. Hsu, et al. Group signature with constant

revocation costs for signers and veriﬁers. In Cryptology and
Network Security, volume 7092, pages 214–233. Springer
Berlin Heidelberg, 2011.

[9] A. Fiat and A. Shamir. How to prove yourself: Practical

solutions to identiﬁcation and signature problems. In
Proceedings on Advances in Cryptology - CRYPTO, pages
186–194. Springer-Verlag, 1987.

[10] V. Goyal. Reducing trust in the PKG in identity based
cryptosystems. In Advances in Cryptology - CRYPTO,
volume 4622, pages 430–447. Springer Berlin Heidelberg, 2007.

[11] B. Libert, T. Peters, et al. Group signatures with

almost-for-free revocation. In Advances in Cryptology -
CRYPTO, volume 7417, pages 571–589. Springer Berlin
Heidelberg, 2012.

[12] X. Lin, X. Sun, et al. GSIS: A secure and privacy-preserving

protocol for vehicular communications. Vehicular Technology,
IEEE Transactions on, 56(6):3442–3456, November 2007.

[13] M. Manulis, N. Fleischhacker, et al. Group signatures -

authentication with privacy. Technical report, Group
Signatures Study for BSI - German Federal Oﬃce for
Information Security, 2012.

[14] A. Miyaji, M. Nakabayashi, et al. New explicit conditions of

elliptic curve traces for FR-reduction. IEICE Transactions on
Fundamentals of Electronics, Communications and
Computer Sciences, 84(5):1234–1243, 2001.

[15] T. Nakanishi, H. Fujii, et al. Revocable group signature
schemes with constant costs for signing and verifying. In
Public Key Cryptography - PKC, volume 5443, pages 463–480.
Springer Berlin Heidelberg, 2009.

[16] T. Nakanishi and N. Funabiki. A short veriﬁer-local revocation

group signature scheme with backward unlinkability. In
Advances in Information and Computer Security, volume
4266, pages 17–32. Springer Berlin Heidelberg, 2006.

[17] R. Pickholtz, D. Schilling, et al. Theory of spread-spectrum

communications-A tutorial. Communications, IEEE
Transactions on, 30(5):855–884, May 1982.

[18] D. Pointcheval and J. Stern. Security arguments for digital

signatures and blind signatures. Journal of Cryptology, pages
361–396, 2000.

[19] M. O. Rabin. Probabilistic algorithm for testing primality.

Journal of number theory, 12(1):128–138, 1980.

[20] M. Raya and J.-P. Hubaux. Securing vehicular ad hoc

networks. Journal of Computer Security, 15(1):39–68, 2007.

[21] P. P. Tsang, M. H. Au, et al. PEREA: Towards practical

TTP-free revocation in anonymous authentication. In
Proceedings of the 15th ACM Conference on Computer and
Communications Security (CCS), pages 333–344, 2008.

1345