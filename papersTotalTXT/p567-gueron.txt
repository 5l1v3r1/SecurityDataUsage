Fast Garbling of Circuits Under Standard Assumptions

Shay Gueron∗

Department of Mathematics

University of Haifa and Intel Corporation, Israel

shay@math.haifa.ac.il

Yehuda Lindell, Ariel Nof, Benny Pinkas†

Department of Computer Science

Bar-Ilan University, Israel

lindell@biu.ac.il, nofdinar@gmail.com,

benny@pinkas.net

ABSTRACT
Protocols for secure computation enable mutually distrust-
ful parties to jointly compute on their private inputs with-
out revealing anything but the result. Over recent years,
secure computation has become practical and considerable
eﬀort has been made to make it more and more eﬃcient.
A highly important tool in the design of two-party proto-
cols is Yao’s garbled circuit construction (Yao 1986), and
multiple optimizations on this primitive have led to perfor-
mance improvements of orders of magnitude over the last
years. However, many of these improvements come at the
price of making very strong assumptions on the underlying
cryptographic primitives being used (e.g., that AES is se-
cure for related keys, that it is circular secure, and even
that it behaves like a random permutation when keyed with
a public ﬁxed key). The justiﬁcation behind making these
strong assumptions has been that otherwise it is not possible
to achieve fast garbling and thus fast secure computation.
In this paper, we take a step back and examine whether it
is really the case that such strong assumptions are needed.
We provide new methods for garbling that are secure solely
under the assumption that the primitive used (e.g., AES) is
a pseudorandom function. Our results show that in many
cases, the penalty incurred is not signiﬁcant, and so a more
conservative approach to the assumptions being used can be
adopted.

∗
Supported by the PQCRYPTO project, which was partially funded
by the European Commission Horizon 2020 research Programme,
grant #645622.
†
Supported by the European Research Council under the ERC con-
solidators grant agreement n. 615172 (HIPS) and under the European
Union’s Seventh Framework Program (FP7/2007-2013) grant agree-
ment n. 609611 (PRACTICE), and by the BIU Center for Research
in Applied Cryptography and Cyber Security in conjunction with the
Israel National Cyber Bureau in the Prime Minster’s Oﬃce.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813619.

INTRODUCTION

1.
1.1 Background

In the setting of secure computation, a set of parties with
private inputs wish to compute a joint function of their in-
puts, without revealing anything but the output. Protocols
for secure computation guarantee privacy (meaning that the
protocol reveals nothing but the output), correctness (mean-
ing that the correct function is computed), and independence
of inputs (meaning that parties are not able to make their
inputs depend on the other parties’ inputs). These security
guarantees are to be provided in the presence of adversar-
ial behavior. There are two classic adversary models that
are typically considered: semi-honest (where the adversary
follows the protocol speciﬁcation but may try to learn more
than is allowed from the protocol transcript) and malicious
(where the adversary can run any arbitrary polynomial-time
strategy in its attempt to breach security).

i and k1

i and k1

Garbled circuits. One of the central tools in the con-
struction of secure two-party protocols is Yao’s garbled cir-
cuit [19, 23]. The basic idea behind Yao’s protocol is to
provide a method of computing a circuit so that values ob-
tained on all wires other than circuit-output wires are never
revealed. For every wire in the circuit, two random or gar-
bled values are speciﬁed such that one value represents 0
and the other represents 1. For example, let i be the label
of some wire. Then, two values k0
i are chosen, where
kb
i represents the bit b. An important observation here is
that even if one of the parties knows the value kb
i obtained
by the wire i, this does not help it to determine whether
b = 0 or b = 1 (because both k0
i are independently
distributed). Of course, the diﬃculty with such an idea is
that it seems to make computation of the circuit impossible.
That is, let g be a gate with incoming wires i and j and
output wire (cid:96). Then, given two random values kb
j , it
does not seem possible to compute the gate because b and
c are unknown. We therefore need a method of computing
the value of the output wire of a gate (also a random value
(cid:96) or k1
k0
(cid:96) ) given the value of the two input wires to that gate.
In short, this method involves providing “garbled compu-
tation tables” that map the random input values to random
output values. However, this mapping should have the prop-
erty that given two input values, it is only possible to learn
the output value that corresponds to the output of the gate
(the other output value must be kept secret). This is ac-
complished by viewing the four possible inputs to the gate,
k0
i , k1
j , as encryption keys. Then, the output val-
ues k0
(cid:96) , which are also keys, are encrypted under the

i , k0
(cid:96) and k1

j , and k1

i and kc

567appropriate keys from the incoming wires. For example, let
g be an OR gate. Then, the key k1
(cid:96) is encrypted under the
pairs of keys associated with the input values (1, 1), (1, 0)
and (0, 1). In contrast, the key k0
(cid:96) is encrypted under the
pair of keys associated with (0, 0).

Fast garbling and assumptions. Today, secure compu-
tation is fast enough to solve numerous problems in practice.
This has been achieved due to multiple signiﬁcant eﬃciency
improvements that have been made on the protocol level,
and also due to garbled circuits themselves. Many of the
optimizations to garbled circuits – described below – come
at the price of assuming strong assumptions on the security
of the cryptographic primitives being used. For example,
the free-XOR technique requires assuming circular security
as well as a type of correlation robustness [7], the use of
ﬁxed-key AES requires assuming that AES with a ﬁxed key
behaves like a public random permutation [5], reductions in
the number of encryption operations from 2 to 1 per entry
in the garbled gate requires correlation robustness (when a
hash function is used) and a related-key assumption (when
AES is used).

Typically, the use of less standard cryptographic assump-
tions is accepted where necessary, especially in areas like se-
cure computation where the costs are in general very high.
However, in practice, solid cryptographic engineering prac-
tices dictate a more conservative approach to assumptions.
New types of elliptic curve groups are not adopted quickly,
people shy away from non-standard use of block ciphers, and
more. This is based on sound principles, and on the under-
standing that deployed solutions are very hard to change if
vulnerabilities are discovered. In the ﬁeld of secure compu-
tation, the willingness to take any assumption that enables
a faster implementation stands in stark contrast to standard
cryptographic practice. In this paper, we propose to pause,
take a step back, and ask the question how much do non-
standard assumptions really cost us and are they justiﬁed.
We remark, for just one example, that practitioners have
warned against assuming that AES is an ideal cipher, due to
related key weaknesses that have been found; see e.g., [4, 6].
Furthermore, the security of AES with a known key was
studied in [14], and the results show that the security mar-
gin for using AES in this way is arguably not as high as
we would like. In particular, [14] present an algorithm that
distinguishes 7-round AES with a ﬁxed key from a public
random permutation, in time 256 and little memory. As in
most situations, if the beneﬁt is huge, then more ﬂexibility
with respect to the assumptions is justiﬁed, whereas if the
gains are smaller then a more cautious approach is taken.

The focus of this paper is to study how much is really
gained by relying on non-standard assumptions and to pro-
vide optimizations that require assuming nothing more than
that AES behaves like a pseudorandom function.
1.2 Known Garbled Circuit Optimizations

Before proceeding to describe our work, we present an
overview of the most important eﬃciency improvements to
garbled circuits:

• Point and permute [21]: In order to prevent the
garbled circuit evaluator from knowing what it is eval-
uating, the original construction randomly permuted
the ciphertexts in each garbled gate. Then, when com-
puting the garbled circuit, the evaluator tries each ci-

phertext in the gate until one correctly decrypts (this
requires an additional mechanism to ensure that only
one ciphertext decrypts to a valid value). On average,
this means that 2.5 entries need to be decrypted per
gate (where each costs 2 decryptions). The point and
permute method assigns a random permutation or sig-
nal bit to each wire, that determines the order of the
garbled gate. Then, the encryption of a garbled value
includes the bit needed to enable direct access to the
appropriate entry in the garbled table (given two gar-
bled values and the two associated bits). This reduces
the number of entries to decrypt to 1 (and thus 2 actual
decryptions).

• Free XOR [16]: The garbled circuit construction in-
volves carrying out encryptions at every gate in the cir-
cuit, and storing 4 ciphertexts. The free-XOR method
enables the computation of XOR gates for free (the
computation requires only computing 1-2 XORs, and
no ciphertexts need be stored). This is achieved by
choosing a ﬁxed random mask ∆ and making the gar-
bled values on every wire have ﬁxed diﬀerence ∆ (i.e.,
i ⊕ ∆,
for every i, the garbled values are k0
where k0
In many circuits, the number
i
of XOR gates is very large and so this signiﬁcantly
reduces the cost (e.g., in the AES circuit there are ap-
proximately 7,000 AND gates and 25,000 XOR gates;
in a naive 32x32 bit multiplier circuit there are approx-
imately 6,000 AND gates and 1,000 XOR gates [1]).

is random).

i and k1

i = k0

We remark that the free-XOR method is patented, and
as such, its use is restricted [17].

• Reductions in garbled-circuit size [21, 22, 24]:
Historically, the most expensive part of any secure pro-
tocol was the cryptographic operations. However, sig-
niﬁcant algorithmic improvements to secure protocols
together with much faster implementations of crypto-
graphic primitives (e.g., due to better hardware) have
considerably changed the equation.
In many cases,
communication can be the bottleneck and thus reduc-
ing the size of the garbled circuit is of great impor-
tance. In [21], a method for reducing the number of
garbled entries in a table from 4 to 3 was introduced;
this is referred to as 4-to-3 garbled row reduction (or
4-3 GRR). This improvement is achieved by “forcing”
the ﬁrst ciphertext to be 0 (by setting the appropriate
garbled value on the output wire so that the ciphertext
becomes 0). In [22], polynomial interpolation was used
to further reduce the number of ciphertexts to just 2;
this is referred to as 4-to-2 garbled row reduction (or
4-2 GRR).

Importantly, 4-3 GRR is compatible with free-XOR
since only one output garbled value needs to taken as
a function of the input values (and the other garbled
value can be set according to the ﬁxed ∆). In contrast,
4-2 GRR is not compatible with free XOR. Neverthe-
less, in recent work, a new method called half gates [24]
reduces the number of ciphertexts in AND gates from
4 to 2, while maintaining compatibility with free XOR
(in fact, half gates only work with free XOR).

• Number of encryptions [20]: Classically, each en-
try in a garbled gate contains the encryption of one
of the output garbled values under two input garbled

568values, and thus requires two encryptions.
In [20],
it was proposed to use a hash function as a type of
key-derivation function, and to encrypt by hashing
both input garbled values together and XORing the
result with the output garbled value. This is secure
in the random-oracle model, or under a “correlation-
robustness” assumption [13]. This reduces the number
of operations from 2 to 1.
(Note however that two
AES operations are typically much faster than a single
hash operation, especially when utilizing the AES-NI
instruction.)

• Fixed-key AES and use of AES-NI [5]: AES-
NI is a set of CPU instructions that are now part of
the Intel architecture. They allow AES computations
to be carried out at incredibly fast rates, especially
in modes of operation that can be highly pipelined.
AES-NI oﬀers instructions for encryption/decryption
and for the AES key expansion.

However, since typical AES usages encrypt multiple
blocks with a single key, the key expansion instructions
do not highly optimize this part of the processing, and
the key schedule generation routine is relatively ex-
pensive (compared to encryption/decryption). More
importantly, pipelining cannot be carried out between
diﬀerent keys. When computing garbled circuits, 4 dif-
ferent keys are used in every gate, requiring many key
schedules to be computed and preventing the use of
pipelining.

In light of this, [5] proposed a method of using AES
that is secure in the public random permutation model
(i.e., assuming that AES for every ﬁxed key behaves
like a public random permutation). The method uses
a ﬁxed key for AES, applies AES on a combination of
the input garbled values, and XORs the result with
appropriate output garbled value. This reduces the
number of AES computation to 4 per gate. Further-
more, since a ﬁxed key is used, only one key schedule
needs to be computed for the entire circuit, and the
encryptions within a gate can be fully pipelined. This
led to an extraordinary speedup in the computation
of garbled circuits, as demonstrated in the JustGarble
implementation [5].

We stress that there have been a very large number of
works that have provided highly signiﬁcant eﬃciency im-
provements to protocols that use garbled circuits. However,
our focus here is on improvements to garbled circuits them-
selves.
1.3 Our Results

We construct fast garbling methods solely under the as-
sumption that AES behaves like a pseudorandom function.
In particular, we do not use ﬁxed-key AES (since this re-
quires assuming that ﬁxed-key AES behaves like a public
random permutation), and we use two AES encryptions per
entry in the garbled gates (since using just one encryption
requires some sort of related-key security assumption). In
addition, we do not use free-XOR (since this requires cir-
cularity). However, this does enable us to use 4-to-2 row
reduction. In brief, we construct the following:

• Fast AES-NI without ﬁxing the key: We show
that, in addition to pipelining encryptions, it is also

possible to pipeline the key schedule of AES-NI, in or-
der to achieve very fast garbling times without using
ﬁxed-key AES or any other non-standard AES variant.
Namely, the key schedule processing of diﬀerent keys
can be pipelined together, so that the amortized eﬀect
of key scheduling on Yao garbling is greatly reduced.
Our experiments (described below) show that this and
other optimizations of AES operations have become so
fast that the beneﬁts of using ﬁxed-key AES are almost
insigniﬁcant. Thus, in contrast to current popular be-
lief, in most cases ﬁxed-key AES is not necessary for
achieving extremely fast garbling.

• Low-communication XOR gates: Over the past
years, it has become apparent that in secure protocols,
communication is far more problematic than computa-
tion. The free-XOR technique is so attractive exactly
because it requires no computation but also no com-
munication for XOR gates. We provide a new garbling
method for XOR gates that requires storing only a sin-
gle ciphertext per XOR gate; our technique is inspired
by the work of [15]. The computational cost is 3 AES
computations for garbling the gate, and 1-2 AES com-
putations for evaluating it. (This overhead is for an
optimized garbling method that we show. We ﬁrst
present a basic scheme requiring 4 AES computations
for garbling and 2 computations for evaluation.)

• Fast 4-2 row reduction: As we have mentioned,
once we no longer use the free-XOR technique, we are
able to use 4-2 GRR on the non-XOR gates. However,
the method of [22] that uses polynomial interpolation
is rather complex to implement (requiring ﬁnite ﬁeld
operations and precomputation of special constants to
In addition, even working in GF (2n)
make it fast).
Galois ﬁelds and using the PCLMULQDQ Intel in-
struction, the cost is still approximately half an AES
computation. We present a new method for 4-2 row
reduction that uses a few XOR operations only, and is
trivial to implement.

We implemented these optimizations and compared them to
JustGarble [5]. There is no doubt that the cost of garbling
and evaluation is higher using our method, since we have
to run AES key schedules, and we pay for computing XOR
gates. However, we show that within protocol executions,
the diﬀerence is insigniﬁcant. We demonstrate this running
Yao’s protocol for semi-honest adversaries which has noth-
ing but oblivious transfer (for which we use the fast OT ex-
tensions of [2]), garbled-circuit evaluation and computation,
and communication.1
Experimental results. We ran Yao’s protocol for semi-
honest adversaries inside Amazon EC2. The details of the
results can be found in Section 5. The results show removing
the public random permutation assumption does not notice-
ably aﬀect the performance of the protocol. Furthermore,
in many scenarios, such as small circuits, large inputs, or
relaively slow communication channels, garbling under the

1

We do not count the base OTs of the OT extension since these would
outweigh everything else, and can anyway be precomputed. Our aim
here is to see the eﬀect of the change in the garbled circuits and
our tests are under optimal conditions for JustGarble-type construc-
tions [5]. For the same reason, we do not look at the eﬀect inside
protocols for malicious adversaries since all of the other work will
clearly outweigh any additional costs in garbling.

569most conservative assumption (the existence of PRFs) per-
forms on par with the most eﬃcient garbling methods.

Patent-free garbled circuits. Another considerable ad-
vantage of using our method for computing XOR gates with
low communication is that it does not rely on the free XOR
technique and thus is not patented. Since patents in cryp-
tography are typically an obstacle to adoption, we believe
that the search for eﬃcient garbling techniques that are not
patented is of great importance.

Garbling under weaker yet non-standard assump-
tion. Our work focuses on the comparison between gar-
bling under a variety of strong assumptions (i.e., circularity,
public random permutation) and garbling under a standard
pseudorandom function assumption only. However, there
are also garbling schemes that have been proven secure un-
der a related-key assumption, but without circularity [15].
In the full version of this paper [11], we continue the direc-
tions introduced by [15] in order to provide a more complete
picture regarding the trade-oﬀ between eﬃciency and secu-
rity. We present two new heuristics for solving the algorith-
mic problem presented in [15], and show that a related-key
assumption based garbling scheme (using any of the sug-
gested heuristics) improves garbling and computation time,
but fails to signiﬁcantly reduce the communication overhead
of the protocol.

2. FIXED-KEY AES VS. REGULAR AES
Background. Bellare et al. introduced the use of ﬁxed-key
AES in garbling schemes and implemented the JustGarble
library [5]. This signiﬁcantly speeds up garbling since the
AES key schedule (which is quite expensive) need not be
computed at every gate. Note that when constructing the
garbled circuit four key schedules are required for every gate,
and when evaluating the circuit two key schedules are re-
quired for every gate. This is very expensive. In addition,
JustGarble utilizes the AES-NI instruction set with encryp-
tion pipelining, signiﬁcantly reducing the cost of the AES
computations.

Despite its elegance, the use of ﬁxed-key AES requires the
assumption that ﬁxed-key AES behaves like a public random
permutation. This is a very strong assumption, and one that
has been brought into question regarding AES speciﬁcally by
the block-cipher research community; see, for example, [14].
Clearly, the acceptance of this assumption in the context
of secure computation and garbling is due to the perceived
very high cost of garbling in any other way. However, the
comparisons carried out in [5] to prior work are to Kreuter et
al. [18] who use AES-256 using AES-NI without pipelining,
and to Huang et al. [12] who use a hash function only. Thus,
it is unclear how much of the impressive speedup achieved
by [5] is due to the savings obtained by using ﬁxed-key AES,
and how much is due to the other elements that they in-
cluded (pipelining of the AES computations in each gate,
optimizations to the circuit representation, and more).

In this section, we show that it is possible to achieve fast
garbling without using ﬁxed-key AES and thus without re-
sorting to public random permutation model. We stress
that some penalty will of course be incurred since the AES
key schedule is expensive. Nevertheless, we show that when
properly implemented, in many cases the penalty is not sig-
niﬁcant and it suﬃces to use regular AES. The goal is to
make the performance depend on the throughput (which is

excellent when pipelining is used) and not on the latency
of a single computation. This goal can be achieved rather
easily for the AES encryption alone, but we also achieve the
more challenging task of pipelining the key schedule as well
as the encryption.
2.1 Utilizing the AES-NI Pipeline

j

j

(kc

(kc

i , k0

i , k1

j , k1

The standard way of garbling a gate uses double encryp-
tion. Speciﬁcally, given 4 keys k0
j for the input
wires and 2 keys k0
(cid:96) , k1
(cid:96) for the output wire, four computa-
(cid:96) )) are made, for varying val-
(Ekb
tions of the type Eka
i
ues of a, b, c ∈ {0, 1}. Observe that since Ekb
(cid:96) ) must be
known before encrypting again with ka
i , this means that the
encryptions must be computed sequentially and not in par-
allel. This makes a huge diﬀerence when using the AES-NI
chip, since the cost of 8 pipelined encryptions is only slightly
more than the cost of a single non-pipelined encryption.2
We therefore garble an AND gate in a way that enables
pipelining. This is easily achieved by applying a pseudoran-
dom function F (which will be instantiated as AES) to the
gate index and appropriate signal/permutation bits. This
ensures independence between all values. For example, an
AND gate where both signal bits are 0 can be garbled as
follows:

(g(cid:107)00) ⊕ Fk0
(g(cid:107)10) ⊕ Fk0

j

j

(g(cid:107)00) ⊕ k0
(g(cid:107)10) ⊕ k0

(cid:96)

(cid:96)

Fk0

i

Fk1

i

Fk0

i

Fk1

i

(g(cid:107)01) ⊕ Fk1
(g(cid:107)11) ⊕ Fk1

j

j

(g(cid:107)01) ⊕ k0
(g(cid:107)11) ⊕ k1

(cid:96)

(cid:96)

One way of looking at this is simply double-encryption in
“counter mode”; intuitively this is therefore secure (as with
all of our constructions, full proofs appears in the full version
of the paper [11]).

i

i

j

(cid:96) = Fk0

(g(cid:107)00) ⊕ Fk0

Needless to say, 4-to-3 GRR can also be carried out by
(g(cid:107)00) meaning that the ﬁrst
setting k0
ciphertext equals 0 and so need not be stored. Observe here
that there are 8 encryptions. However, all inputs are known
and therefore it is possible to pipeline these computations.
Note that it is essential to take both signal bits as part
of the input of F . Otherwise, the scheme is not secure. To
understand this, assume that the gate was garbled as in the
example above but without using signal bits (e.g., the value
(g(cid:107)10)), and assume that the
Fk1
(g) is used instead of Fk1
evaluator holds the keys k0
j . The evaluator will com-
pute k0
(g)
and Fk1
(g) using the second and the third garbled entries
j or k1
(without learning the values of k1
i ). Now, the evalu-
ator would be able to compute k1
(cid:96) as well, using the fourth
garbled entry. Taking both signal bits as part of F ’s input
prevents this from happening, as the evaluator cannot learn
Fk1
2.2 Pipelining Key Schedule and Encryption
The computations that are needed for garbling and eval-

(cid:96) , but then it will also be able to compute Fk1

(g(cid:107)11) and Fk1

(g(cid:107)11).

i , k0

j

j

i

i

i

uating garbled circuits are as follows:

- KS4 ENC8: This consists of the computation of 4 AES
key schedules from 4 diﬀerent keys. The resulting keys
are then used to encrypt 8 blocks (each key is used for

2

Concretely, on a Haswell processor, 8 pipelined AES computations
costs approximately 77 cycles, whereas one non-pipelined AES com-
putation costs approximately 70 cycles.

570encrypting 2 blocks). This is used for garbling AND
(and other non-XOR) gates.

- KS2 ENC2: This consists of the computation of 2 AES
key schedules from 2 diﬀerent keys. The resulting keys
are then used to encrypt 2 blocks (each key is used for
encrypting 1 block). This is used for evaluating all
gates.

- KS4 ENC4: This consists of the computation of 4 AES
key schedules from 4 diﬀerent keys. The resulting keys
are then used to encrypt 4 blocks (each key is used for
encrypting 1 block). This is used for garbling XOR
gates according to our new XOR-gate garbling scheme
described in Section 3.2.

A na¨ıve software implementation approach for these compu-
tations would use the appropriate sequence of calls to a “key
expansion” function, and to a “block encryption” function.
To estimate the performance of that approach, we use, as a
comparison baseline, the OpenSSL (1.0.2) library, running
on the Haswell architecture.3

Software running on this processor can use the AES hard-
ware support, known as AES-NI (see [8, 9] for details). On
this platform, a call (using the OpenSSL library) to an
AES key expansion consumes 149 CPU cycles. A call to
an (ECB) encryption function to encrypt 2/4/8 blocks con-
sumes approximately 70+ cycles (explanation is provided
below). However, OpenSSL’s API does not support ECB
encryption with multiple key schedules. For example, this
implies that KS4 ENC4 would required 4 calls to the key ex-
pansion function, followed by 4 calls to an ECB encryption,
each one applied to a single (16B) block. The resulting per-
formance of KS4 ENC4, KS4 ENC8, KS2 ENC2 obtained
by calling OpenSSL’s functions (namely “aesni set encrypt
key” and “aesni ecb encrypt”) is summarized in middle col-
umn of Table 1 at the end of this section.

Our goal is to optimize the computations of KS4 ENC4,
KS4 ENC8, KS2 ENC2, and alleviate the overhead imposed
by the frequent key replacements. We achieve our opti-
mization by: (a) interleaving the encryption of independent
blocks; (b) optimizing the key expansion; (c) aggressive in-
terleaving of the operations; (d) building an API that allows
for encrypting with multiple key schedules. The details are
as follows.

Interleaved encryption. AES encryption on a modern
processor is accelerated by using the AES-NI instructions
(see [8, 9]). Assuming that the cipher key is expanded to
a key schedule of 11 round keys, RK[j], j=0, . . ., 10, AES
encryption of a 16 bytes block X is achieved by the code
sequence

XMM = X XOR RK [0]
for j = 1, 2, ..., 9

XMM = AESENC XMM, RK [j]

end
XMM = AESENCLAST XMM, RK [10]
output XMM

If the latency of the AESENC/AESENCLAST instruc-
tions is L cycles, then the above ﬂow can be completed

3

Haswell (resp., Broadwell) is an Intel Architecture Codename of a
recently announced 4th (resp., 5th) Generation Intel R(cid:13) CoreTM Pro-
cessor. For short, we refer to them simply as Haswell (resp., Broad-
well).

in 1 + 10L cycles. However,
if the throughput of AES-
ENC/AESENCLAST is 1 (i.e., pipelining can be used and
the processor can dispatch AESENC/AESENCLAST every
cycle, if the data is available), and the computations encrypt
more than one block, the software can interleave the AES-
ENC/AESENCLAST invocations. This achieves a higher
computational throughput, compared to the single block en-
cryption. Furthermore, the AESENC/AESENCLAST in-
structions can be applied to any round key, even those gen-
erated by diﬀerent key schedules. For example, 2 blocks X
and Y , can be encrypted, with 2 diﬀerent key schedules KS1
and KS2, by the following code sequence:

XMM1 = X XOR RK1 [0]
XMM2 = Y XOR RK2 [0]
for j = 1, 2, ..., 9

XMM1 = AESENC XMM1, RK1 [j]
XMM2 = AESENC XMM2, RK2 [j]

end
XMM1 = AESENCLAST XMM1, RK1 [10]
XMM2 = AESENCLAST XMM2, RK2 [10]
output XMM1, XMM2

These computations can be completed within 10L + 1 cy-
cles (the 2 XOR’s of the whitening step can be executed
in one cycle). Similarly, encrypting 4/8 blocks with an in-
terleaved software ﬂow could (theoretically) terminate after
(2 + 10L + 3) /(4 + 10L + 7) cycles.
(This idealized es-
timation assumes that the round keys are fetched from the
processor’s cache, and ignores the cost of loading/storing the
input/output blocks. We point out that the code sequence
indeed closely approaches the theoretical performance, un-
der these assumptions.) These computations are dominated
only by the throughput of AESENC/AESENCLAST. Note
that L = 7 on Haswell, and the AESENC/AESENCLAST
throughput is 1. As can be seen,

Optimized key expansion. We were able to optimize
the computation of AES key expansion so that it computes
(and stores) an AES128 key schedule in 96 cycles on Haswell,
which is 1.55 times faster than the code used by OpenSSL on
the same platform. The details of this optimization are quite
low-level, and we provide here only some high-level details.
The a full set of key expansion code options, was contributed
to the NSS open source library, and can be found in [10].

The AES-NI instruction set includes instructions that fa-
cilitate key expansion. For the encryption key schedule,
the relevant instruction is AESKEYGENASSIST. However,
this instruction does not provide a throughput of 1 and is
signiﬁcantly slower than the AESENC and AESENCLAST
operations (the reason being that key schedules are typi-
cally run only once and so the cost involved in optimizing
this instruction was not justiﬁed). We observe that the key
schedule consists of S-box substitutions together with rota-
tion and XOR operations. Likewise, the last round of AES
costs of S-box substitutions together with shift rows (and key
mixing, which can be eﬀectively cancelled by using a round
key of all-zeroes). Thus, the use of AESKEYGENASSIST
can be replaced by a combination of a shuﬄe followed by
an AESENCLAST invocation, to isolate the S-box trans-
formation.4 The shuﬄe is carried out eﬃciently using the
PSHUFB instruction which also has a throughput of 1. We

4

AESENCLAST is used since the last round of AES does not include
the MixColumns operation, which is a part of all other rounds and
therefore run in the AESENC instruction but not in AESENCLAST.

571therefore obtain that the key schedule can be “simulated” us-
ing much faster instructions. Additional optimizations can
be obtained by judicious usage of the available instructions
to generate eﬃcient sequences. We give one example. Con-
sider the following portion of the AES key schedule ﬂow
(where RCON = Rcon[i/4]):

w[i] = w[i-4] xor Sbox(RotWord(w[i-1])) xor RCON
w[i+1] = w[i-3] xor w[i-4]

xor Sbox(RotWord(w[i-1])) xor RCON

w[i+2] = w[i-2] xor w[i-3] xor w[i-4]

w[i+3] = w[i-1] xor w[i-2] xor w[i-3] xor w[i-4]

xor Sbox(RotWord(w[i-1])) xor RCON

xor Sbox(RotWord(w[i-1])) xor RCON

As explained above, the S-box substitution can be iso-
lated by a shuﬄe followed by AESENCLAST, and if we
place (duplicated) RCON in the second operand of AES-
ENCLAST, the addition of RCON is also done by AESEN-
CLAST. The arrangement and XOR-ing of the “words” can
be implemented by the following straightforward ﬂow:

vpslldq $4, \reg, %xmm3
vpxor %xmm3, \reg, \reg
vpslldq $4, %xmm3, %xmm3
vpxor %xmm3, \reg, \reg
vpslldq $4, %xmm3, %xmm3
vpxor %xmm3, \reg, \reg

However, the same functionality can be achieved by a

shorter, 4 instructions, ﬂow, as follows:

vpsllq $32, \reg, %xmm3
vpxor %xmm3, \reg, \reg
vpshufb (con3), \reg, %xmm3
vpxor %xmm3, \reg, \reg

(with the value con3 = -1,-1,-1,-1,-1,-1,-1,

-1,4,5,6,7,4,5,6,7)

In this way, the 3 shuﬄes and 3 xors of the straightforward
ﬂow, can be replaced by shorter and faster 1 shift, 1 shuﬄe
and 2 ﬂows. With our optimizations, we were able to write
a key expansion code that computes and stores an AES128
key schedule in 96 cycles on Haswell (i.e., 1.55 times faster
than OpenSSL).
Multiple aggressive interleaving. A higher degree of
optimization can be achieved by interleaving the computa-
tions of multiple key expansions. This helps in partially al-
leviating the key expansion’s dependency on the latency of
AESENC. For example, our code for expanding 2 key sched-
ules consumes 124 cycles (on Haswell), which is signiﬁcantly
less than two independent (without interleaving) key sched-
ules, that are 2 × 96 cycles. We applied this technique to
obtain an optimized KS4 ENC4 and KS4 ENC8 implemen-
tation. For KS2 ENC2, optimization is achieved by “mixed
interleaving” of the key expansion and the encryptions.

The performance of the optimized KS4 ENC4, KS4 ENC8,
and KS2 ENC2 is summarized in the right column of Ta-
ble 1.

2.3 Experimental Results

The results in Table 2 show the garbling and evaluation
time of 1000 AES circuits, using the free-XOR technique
and 4-to-3 row reduction (as used by JustGarble, in order to
make a fair comparison). All methods use pipelining of the
encryptions (the last two entries do not use a ﬁxed key and

Computation

KS4 ENC4
KS4 ENC8
KS2 ENC2

Naive implem. Optimized imp.

(cycles)

703
729
338

(cycles)

240 (asm - 220)
256 (asm - 248)
182 (asm - 180)

Table 1: The performance (in cycles) of KS4 ENC4,
KS4 ENC8 and KS2 ENC2, measured on the Haswell archi-
tecture. The na¨ıve implementation is the result of calling the
OpenSSL (1.0.2) functions for AES key expansion and for
ECB encryption. The performance of the optimized imple-
mentations is of C code (compiled using gcc), and of hand-
written assembly implementations (marked with “asm”).

therefore use the encryption pipelining method described in
Section 2.1). The last entry is based on using also the key
scheduling pipelining method described in Section 2.2. The
table shows the results for garbling and evaluating the cir-
cuit. We stress that the times in Table 2 are for 1000 com-
putations; thus, a single garbling of the AES circuit using
our pipelined key schedule takes 0.74 milliseconds only. The
results were obtained on the Amazon EC2 c4.large Linux
instance (with a 2.59GHz Intel Xeon E5-2666 v3 Haswell
processor, a single thread, and 3.75GiB of RAM).

Algorithm

Fixed-key AES (JustGarble)

Regular AES, pipelined encryption

Reg. AES, pipelined enc. + key schedule

Time

399 / 191
1578 / 732
743 / 389

Table 2: Garbling and evaluation times for the AES circuit
1000 times (in milliseconds)

The results show that pipelining the key schedule as well
as the encryptions (3rd row) reduces time by more than 50%
over pipelining the encryptions only (2nd row). Fixed-key
AES (1st row) does provide a signiﬁcant improvement and
the best performance. However, the gain in using ﬁxed-key
AES is not overwhelming, since, as we will show later on,
in many settings the main cost of secure computation is no
longer the garbling itself. Namely, although AES takes 86%
more time without a ﬁxed key, the objective diﬀerence is
just 0.344 milliseconds. Thus, when run in a protocol that
includes communication, this additional time makes almost
no diﬀerence. We demonstrate this in our experiments de-
scribed in Section 5.

3. GARBLING UNDER A PSEUDORAN-
DOM FUNCTION ASSUMPTION ONLY

3.1 Background

The free-XOR technique [16] is one of the most signiﬁcant
optimizations of garbling. When using this technique, the
garbling and evaluation of XOR gates are essentially for free,
requiring only two XOR operations for garbling and one for
evaluating. In addition, no garbled table is used, thereby sig-
niﬁcantly reducing communication. However, the free-XOR
technique also requires non-standard assumptions. Specif-
ically, when using this method, there is a global oﬀset ∆,
and on every wire a single random k0
is chosen and the
i ⊕ ∆. This is secure in the
i
other key is always set to k1

i = k0

572random oracle model [16] or under a circular-secure corre-
lation robustness or related key assumption [7] (correlation
robustness is formalized for hash functions whereas related
key security is for encryption or pseudorandom functions).
The need for this assumption is due to the fact that when a
global oﬀset is used, multiple encryptions are made under re-
lated keys ka, ka⊕∆, kb, kb⊕∆, and so on. In addition, since
these keys are used to encrypt the values kc and kc ⊕ ∆, the
ciphertext is related to the secret key which is exactly cir-
cular security. We remark that at some additional cost, the
circularity assumption can be removed using the FleXOR
technique [15]. However, the correlation robustness/related
key assumption remains.5

We next show that it is possible to eﬃciently garble a cir-
cuit using a pseudorandom function only. We ﬁrst show a
basic version of our garbling scheme, where the garbled table
for a X OR gate contains a single ciphertext and requires 4
pseudorandom function operations for garbling (instead of 8
for an AND gate), and 2 for evaluation. We then show an op-
timized version that reduces the number of PRF invocations
to 3 calls for garbling, and 1-2 calls for evaluation. The over-
head of these schemes is deﬁnitely beyond that of the free
XOR technique. However, as we will show, the techniques
are a considerable improvement over the naive method of
computing XOR like an AND gate, they enable the usage
of 4-2 garbled row reduction (4-2 GRR), and within pro-
tocols (where communication and other factors become the
bottleneck) they perform well.
3.2 Garbled XOR With a Single Ciphertext

In order to prove security solely under the assumption
that the primitive used is a pseudorandom function, all the
garbled values on all wires should be independently chosen.
Thus, for all pairs of wires i and j, the keys k0
j , k1
j
should be independent and either uniformly distributed or
pseudorandom.
It will be useful to equivalently write the
j ⊕ ∆j
keys as k0
j and k1
i = k0
where ∆i, ∆j are random independent strings.

i ⊕ ∆i, and k0

i and k1

j = k0

i , k0

i , k1

We use the point-and-permute method, described brieﬂy
in the introduction. In order to avoid confusion, we will call
the bit used to determine the order of the ciphertexts in the
garbling phase the permutation bit (since it determines the
random order), and we call the bit that is viewed by the
evaluator when it evaluates the circuit the signal bit (since it
signals which ciphertext is to be decrypted). We denote the
permutation bit on wire i by πi, and we denote the signal
bit on wire i by λi. Observe that if the evaluator has bit
vi on wire i (for which it does not know the value), then it
holds that λi = πi ⊕ vi. Thus, if πi = 0, then the evaluator
will see λi = vi, and if πi = 1 then the evaluation will see
λi = vi (its complement). Since πi is random, this reveals
nothing about vi whatsoever.

We now describe the basic XOR gate garbling method that
uses just a single ciphertext. The method requires 4 calls to
a pseudorandom function for garbling, but as we have seen,
this is inexpensive using AES-NI. (We remark that AND
gates are garbled in the standard way, independently of this
method.) Denote the input wires to the gate by i, j and
denote the output wire from the gate by (cid:96). We therefore

5

We note that garbling with hash functions is much slower than with
AES, especially when an AES-NI supporting architecture is utilized.
Thus, related-key security for AES is required, which is a less than
ideal assumption.

i , k0

i ⊕ ∆i and k0

j ⊕ ∆j. According to
have input keys k0
the above, we denote by πi, πj the permutation bits on wires
i and j respectively. As we will see, the keys on the output
wire will be determined as a result of the garbling method.
The method for garbling a XOR gate with index g is as
follows:

j , k0

- Step 1 – translate input keys on wire i: We
ﬁrst translate the input keys on wire i into new keys
˜k0
i , ˜k1
i by applying a pseudorandom function to the
gate index. That is, we compute ˜k0
(g) and
˜k1
i = Fk1
(g), where g is the gate index.

i = Fk0

i

i

- Step 2 – set oﬀset of wire (cid:96): The oﬀset of wire (cid:96)
(the output wire) is set to be the oﬀset of the translated
values on wire i, namely ∆(cid:96) = ˜k0
i . (Observe that
if the same wires are input to multiple gates, indepen-
dent values will be obtained since the pseudorandom
function is applied to the gate index.)

i ⊕ ˜k1

- Step 3 – translate input keys on wire j: Next,
we translate the input keys on wire j so that they too
have the oﬀset ∆(cid:96) (this will enable the output key to
be computed by XORing the translated input keys,
as in the free XOR technique). Thus, we set ˜kπj
j =
j ⊕ ∆(cid:96), where πj is the random
F
permutation bit that is associated with the bit 0 on
wire j.

(g) and ˜k ¯πj

j = ˜kπj

πj
j

k

i = ˜k0

j ⊕ ˜k1

- Step 4 – compute output keys on wire (cid:96): Since
j = ∆(cid:96), we can now use the free-XOR
(cid:96)⊕∆(cid:96).
i ⊕ ˜k1
i ⊕ ˜k1
i =
i ⊕ ˜k0
j . In addition,
(cid:96) as required, since in both cases
(cid:96) ⊕ ∆(cid:96) = k1
(cid:96) .)

i ⊕ ˜k1
˜k0
technique and can deﬁne k0
(Observe that ˜k1
j = k0
j ⊕ ˜k1
˜k0
i ⊕ ˜k1
˜k0
the result of the XOR is ˜k0

j and k1
i ⊕ ˜k1
j ⊕ ∆(cid:96) = k0

(cid:96) = ˜k0
(cid:96) as required, since ˜k0

j implies that ˜k0
j = ˜k1
j = k1

i ⊕ ˜k0

i ⊕ ˜k0

i ⊕˜k0

j = ˜k1

(cid:96) = k0

- Step 5 – set the ciphertext: Given ka
for any
a ∈ {0, 1}, the evaluator can easily compute ˜ka
i
In
i .
addition, if it has kπj
(as we show, this can be im-
j
plicitly determined from the signal bit λi), then it can
compute ˜kπj
j . The only problem is that it cannot com-
pute k ¯πj
since it does not know ∆(cid:96) (and furthermore
j
∆(cid:96) cannot be revealed). Thus, the ciphertext for the
gate is set to T = F
it is
¯πj
j
possible to compute ˜k ¯πj
the
value remains hidden since it is masked by a pseudo-
random function keyed by k ¯πj

(g) ⊕ ˜k ¯πj
j . Now, given k ¯πj
j as well (but without k ¯πj

k

j

j

j ).

In order to evaluate a XOR gate g with ciphertext T , given a
key ki on wire i and a key kj on wire j, the evaluator simply
needs to compute ˜ki = Fki (g) and either ˜kj = Fkj (g) if it has
signal bit 0, or ˜kj = Fkj (g) ⊕ T if it has signal bit 1. Then,
the key on the output wire is obtained by ﬁnally computing
k(cid:96) = ˜ki ⊕ ˜kj.

The computational cost of garbling the gate is 4 pseudo-
random function computations, and the computational cost
of evaluating the gate is 2 pseudorandom function compu-
tations. Most signiﬁcantly, the gate table includes only a
single ciphertext.

573i

i

i = Fk1

i ⊕ k1

(g) and ˜k1

(g). In contrast, ˜k0

Reducing the number of PRF calls to 3. Observe
that the pseudorandom function is used to ensure indepen-
dence of the ∆ values between diﬀerent gates. If we were
to just take ∆(cid:96) = k0
i , then the output ∆ from two dif-
ferent gates with the same input wire i would be the same,
and once again correlation robustness or a related key as-
sumption would be needed. Thus, it is necessary to compute
˜k0
i = Fk0
j can be taken
to simply be k0
j and the pseudorandom function computa-
tion is not needed. This is because ∆(cid:96) is ﬁxed independently
of wire j. Using this method, we can reduce the computa-
tional cost of garbling the XOR gate from 4 pseudorandom
function computations to 3 pseudorandom function compu-
tations (and the computational cost of evaluating the gate
is decreased from 2 to either 1 or 2 PRF computations).6
Garbling NOT Gates. When using free XOR, it is possi-
ble to eﬃciently garble NOT gates by simply deﬁning them
to be XOR with a ﬁxed wire that is always given value 1.
Since the XOR gates are free, this is highly eﬃcient. How-
ever, since we are not using free XOR, a diﬀerent method
needs to be found. Fortunately, NOT gates can still be com-
puted for free, and with no additional assumption. In order
to see this, let g be a NOT gate with input wire i and output
wire j, and let k0
i be the garbled values on wire i. Then,
we simply deﬁne k0
i . During the garbling
of the circuit, any gates receiving wire j as input will used
these “reversed” values. Furthermore, when evaluating the
circuit, if the value k0
i is given on wire i, then the result of
the NOT gate is k1
i . Thus, nothing needs to
be done. This trivially preserves security since no additional
information is provided in the garbled circuit.

j which equals k0

i and k1

j := k1

j := k0

i , k1

The full speciﬁcation and security. The detailed de-
scription of this garbling scheme, along with its full proof of
security, appears in the full version of this paper [11].

Intuition for security. The detailed proof of security
appears in the full version [11]. We describe here only the
intuition behind the proof. Observe that the ciphertext in a
XOR gate with input wires i, j and output wire (cid:96) equals
j ⊕ ∆(cid:96) =
T = F
(g(cid:107)0)[1..n]⊕∆(cid:96). In addition, by the way we deﬁned ∆(cid:96),
(g(cid:107)1)[1..n].

(g(cid:107)1)[1..n] ⊕ ˜kπj

(g(cid:107)0)[1..n]⊕ F

and that ˜kπj

j = ˜kπj

i ⊕ ˜kπi

πj
j

k

j

πj
j

F
k
we have ∆(cid:96) = ˜kπi
Thus,

k

πi
i

(g(cid:107)1)[1..n]

πi
i

i = Fk
(g(cid:107)0)[1..n] ⊕ F
(g(cid:107)0)[1..n] ⊕ F

πi
k
i

T = Fk
⊕F

πi
i

πj
k
j

(g(cid:107)1)[1..n]

πj
j

k

where πi, πj are the permutation bits that are associated
with the bit 0 on wires i, j respectively. Stated diﬀerently,
the ciphertext in a XOR gate is the result of XORing the
four outputs of the pseudorandom function, as shown above.
Each one of these four computations uses a diﬀerent key,

i

i , k1

i = kπi

i will also remain the
(g). However, in this case,

6
It may be tempting to propose that one of k0
same; i.e., set ˜kπi

and ˜k ¯πi

¯πi
i

(g). Note that T = F

¯πi
i
¯πj
and k
j
(g) ⊕ ˜k

i = F
k
if the evaluator happens to have k ¯πi
i
T ⊕ F˜k
j ⊕∆(cid:96) = F
˜k
the evaluator is ˜k
i . If these keys are used in other
gates, then an attacker sees the XOR of two keys and encryptions
computed with each key separately. This is once again a related-key
type assumption.

(g) ⊕ F
¯πj
˜k
j
(g)⊕˜k
j ⊕ kπ

then it can compute
(g) ⊕

i ⊕F
j ⊕ ˜kπ

j ⊕kπi
i = ˜k

(g) and so the result obtained by

¯πj
j = F
k

¯πj
j

¯πj
j

¯πj
j

¯πi
i

πj

πj

πj

πj

k

k

k

from which only two keys are known to the evaluator. Since
we use the gate index as an input to the function, we are
guaranteed that when a wire enters multiple gates, the pseu-
dorandom values we compute will be diﬀerent in each of the
gates. Thus, the ciphertext looks like a random string to
the evaluator. In addition, the output-wire key values are
determined by the result of the pseudorandom function com-
putation as well. Thus, they are new keys that do not appear
elsewhere in the circuit. We stress that the four values in
the equation above are not the four new translated keys. If
that was the case, then XORing them would yield 0, because
the same oﬀset is used in both wires after the translation.
Instead, the ﬁrst three values are the translated keys, but
the last value is just a pseudorandom string that is used to
mask them in a “one-time pad”-like encryption.

A similar argument applies for AND gates. Since the eval-
uator can compute only two of the eight PRF computations
using the two keys it holds, and since the values that are
used in computing the garbled table are unique and do not
appear elsewhere in the circuit (again, this is ensured by
using the gate index and the permutation bits as input to
each pseudorandom function computation), the gate cipher-
texts that are not associated with the keys known to the
evaluator, look random to the evaluator.
3.3 XOR Gates with Only Three PRF Com-

putations

Our garbling method requires four calls to the pseudoran-
dom function for garbling XOR gates, where each call uses
a diﬀerent key. In this section we show that it is possible to
remove one of these calls by leaving one of the input keys
unchanged. Recall that our ciphertext for a XOR gate g
with input wires i, j and output wire (cid:96) is:

T = Fk
⊕F

πi
i

k

πj
j

(g(cid:107)0)[1..n] ⊕ F
(g(cid:107)0)[1..n] ⊕ F

k

πi
i

(g(cid:107)1)[1..n]

(g(cid:107)1)[1..n]

(1)

πj
k
j

k

k

k

k

vi
i

vi
i

vj
j

vj
j

vj
j

i , kvj

(g(cid:107)λi)[1..n]⊕F

Assume the evaluator has the keys kvi
j and the signal
bits λi, λj when computing the gate. Then, using the cipher-
(g(cid:107)λj)[1..n]
text C[g] it computes C[g]⊕Fk
(g(cid:107)λj), which is the XOR
(g(cid:107)λi)[1..n]⊕F
and obtains F
of two pseudorandom values. If we leave, for example, the
value of kvj
j unchanged – i.e., use it in Eq. (1) instead of
(g(cid:107)λj) – then the evaluator will be able to compute
F
(g(cid:107)λi)[1..n] ⊕ kvj

j . Observe that the evaluator still can-
not learn anything since one of the two values is a new pseu-
dorandom value that does not appear anywhere else in the
circuit. Therefore, the ciphertext is pseudorandom as re-
quired.
In addition, since the two keys on wire i are still
translated to new keys, the output wire keys, generated in
the same way as before, are guaranteed to obtain new fresh
values. (See Footnote 6 as to why we cannot use the same
method to remove one of the pseudorandom function calls
on wire i as well.)

vi
i

F

k

4. SIMPLE AND FAST 4-2 GRR
4.1 Overview

Abstractly, gate garbling typically works by generating
four pseudorandom masks K0, K1, K2, K3, corresponding to

574(g(cid:107)00) ⊕ F

πi
i

πj
k
j

πi
i

(g(cid:107)01) ⊕ F

(g(cid:107)00), K1 = Fk

the four possible input combinations, in some permuted or-
der. In the notation we have used so far we have that K0 =
(g(cid:107)01),
Fk
and so on (note that K1 equals the value used to mask the
output key kg(πi,¯πj )
in T1). The evaluator of the circuit is
able to compute one of these four masks, and can also use
the signal bits to identify the index of that mask. Namely,
it computes a pair (i, Ki) (but is unable to identify the real
input combination corresponding to the value that it com-
puted).

¯πj
j

k

(cid:96)

In our base scheme described in the previous section, we
garbled non-XOR gates with three ciphertexts for each gar-
bled gate. One of the ciphertexts was “removed” by setting
one of the keys on the output wire to actually be K0 rather
than using K0 to mask the key (this is called garbled row
reduction, or GRR for short).
In this section we improve
on this by applying a 4-2 row reduction technique on these
gates in order to remove an additional ciphertext. There
are two known such techniques: The 4-to-2 reduction tech-
nique method of [22] and the new “Half-Gates” approach
of [24]. The “Half-Gates” technique was designed to be com-
patible with the free-XOR technique and actually requires
free-XOR; as such, it is based on the circularity assumption
and so is not suitable for this paper. In contrast, the 4-2
GRR technique of [22] does not require free-XOR; it has
been proved relying on a standard assumption only and can
be incorporated into our scheme. However, in this technique,
the generation of the garbled table by the circuit garbler, as
well as the computation of the output wire key given two
ciphertexts of the gate table and the K value, are carried
out by interpolating a degree 2 polynomial. We describe
here a diﬀerent 4-to-2 garbling method where the garbling
and evaluation of the gate use only simple XOR operations.
This is preferable for two major reasons:

• Eﬃciency: Polynomial interpolation uses three ﬁnite
ﬁeld multiplications and two additions (after the La-
grange coeﬃcients are precomputed). The overhead
of computing the multiplications is rather high, even
when implemented in GF (2128). For example, our im-
plementation, which used the PCLMULQDQ Intel in-
struction, needed about half as many cycles as AES
encryption.

• Simpler coding: Eﬃcient implementation of polyno-
mial interpolation, especially over GF (2128), and us-
ing machine instructions rather than calling a soft-
ware library, requires some expertise and is signiﬁ-
cantly harder to code than a few XOR operations.

Gate evaluation. We ﬁrst describe the process of evalu-
ating a gate. We will then describe the garbling procedure
which enables this gate evaluation procedure. Although this
is somewhat reversed (as one would expect a description of
how garbling is computed ﬁrst), we present it this way as
we ﬁnd it clearer.
The gate evaluator receives as input a gate table with
two entries [T1, T2], an index i ∈ {0, 1, 2, 3}, and a value Ki
computed from the two garbled values of the input wires
(note, T1, T2, Ki are all 128 bit strings).
It computes the
garbled output wire key kout in the following way:

• If i = 0 then kout = K0
• If i = 1 then kout = K1 ⊕ T1

• If i = 2 then kout = K2 ⊕ T2
• If i = 3 then kout = K3 ⊕ T1 ⊕ T2

Garbling. We now show how to garble AND gates so that
the evaluation described above provides correct evaluation.
Due to the random permutation applied to the rows (via
the permutation bit), the single output bit “1” of these gates
might correspond to any of the masks K0, K1, K2, K3. De-
note the index of that mask as s ∈ {0, 1, 2, 3}, and denote by
k0
out, k1
out the output wire keys. We need to design a method
for computing the garbled output key from the garbled table
of this gate and the Ki values, such that (1) The method
applied to Ks computes k1
out, and when applied to any other
K value it computes k0
out. (2) Given Ks and the gate table,
k0
out value is pseudorandom. Similarly, given any other K
value and the gate table, k1

out is pseudorandom.

Our starting point is the basic garbled gate procedure
without row reduction, and so with a gate table of four en-
tries [T0, T1, T2, T3]. We denote the output garbled value
associated with the ith entry of the table by k[Ti], mean-
ing that if Ti is the one “decrypted”, then the key obtained
is k[Ti]. It holds that one k[Ti] value is equal to k1
out, and
the other three k[Ti] values are equal to k0
out). The table
contains the four entries Ti = Ki ⊕ k[Ti].

out then k1
out then k0

In the 4-to-3 row reduction method, the garbled-gate en-
try T0 is always 0, and therefore (1) there is no need to
store and communicate that entry, and (2) it always holds
that k[T0] = K0. If k[T0] = k0
out can be deﬁned
arbitrarily, whereas if k[T0] = k1
out can be deﬁned
arbitrarily.
In our new garbling method we use the freedom in choos-
ing the second output wire key to always set it to K1⊕ K2⊕
K3. As a result, and as will be explained below, the gar-
bled table will have the property that entry T3 of the table
satisﬁes T3 = T1 ⊕ T2. Therefore T3 can be computed in
run-time by the evaluator and need not be stored or sent.
In summary, garbling is carried out as follows:

• If k[T0] = k0
• Else, k1

out = K0 and k0

out then k0

out = K0 and k1
out = K1 ⊕ K2 ⊕ K3

out = K1⊕K2⊕K3

This fully deﬁnes the garbled table, as follows:

• If k[T1] = k0

out = K0 then T1 = K0 ⊕ K1 (since K0 =
kout = K1 ⊕ T1). Else, we have k[T1] = K1 ⊕ K2 ⊕ K3
implying that T1 = K2 ⊕ K3.

• If k[T2] = k0

out = K0 then T2 = K0 ⊕ K2 (since K0 =
kout = K2 ⊕ T2). Else, we have k[T2] = K1 ⊕ K2 ⊕ K3
implying that T2 = K1 ⊕ K3.

See Table 3 for the full deﬁnition of the garbled table [T1, T2]
and the deﬁnition of the output wires, depending on the
permutation (recall that s is the index such that Ks = k1
out).
It is easy to verify correctness by tracing the computation
in each case according to the table.

An alternative way to verify that the new scheme is correct
is to observe that the output wire key computed for K3 is
always

k[T3] = K3 ⊕ T1 ⊕ T2

= K3 ⊕ (k[T1] ⊕ K1) ⊕ (k[T2] ⊕ K2)
= K1 ⊕ K2 ⊕ K3 ⊕ k[T1] ⊕ k[T2]

575s

3
2
1
0

k0
out

T2

T1

truth
table
0001 K0 ⊕ K1 K0 ⊕ K2
0010 K0 ⊕ K1 K1 ⊕ K3
0100 K2 ⊕ K3 K0 ⊕ K2
1000 K2 ⊕ K3 K1 ⊕ K3 K1 ⊕ K2 ⊕ K3

K0
K0
K0

k1
out

K1 ⊕ K2 ⊕ K3
K1 ⊕ K2 ⊕ K3
K1 ⊕ K2 ⊕ K3

K0

Table 3: Garbling the gate table

out = k0

out and thus k3

out then this is correct since k0

If k[T1] (cid:54)= k[T2] then k[T1]⊕ k[T2] = K0 ⊕ (K1 ⊕ K2 ⊕ K3).
In this case, k[T3] should equal K0 (since one of k[T1], k[T2]
equals k1
out), and this indeed follows
from the equation.
If k[T1] = k[T2], then by the equation we have that k[T3] =
K1⊕K2⊕K3. If k[T3] = k1
out =
K0. Furthermore, if k[T3] = k0
out then since k[T1] = k[T2]
they both also equal k0
out =
K0 and so k[T3] = K1 ⊕ K2 ⊕ K3, as required. Intuitively,
the ﬁrst case (where k[T3] = k1
out) corresponds to the case
that the 0-key is K0 and the 1-key is K1 ⊕ K2 ⊕ K3, whereas
the second case (where k[T3] = k0
out) corresponds to the case
that the 0-key is K1 ⊕ k2 ⊕ K3 and the 1-key is K0.
Encoding the permutation bits. The permutation bits
can be encoded in a similar way to that suggested in [22].
Two changes are applied to the basic garbling scheme:

out. This implies that k[T0] = k1

• The garbled values are only n−1 bits long, whereas the
values Ki are still n bits long (concretely here, we use
n = 128). Therefore, the function used for generating
the Ki inputs has n−1-bit inputs and an n-bit output.
We denote the least signiﬁcant bit of Ki by mi. Only
n − 1 bits of Ki are used for computing the garbled
key of the output wire, using the procedure described
above. Consequently, the values T1, T2 of the garbled
table are also only n − 1 bits long.

• We add 4 bits to the table. The ith of these bits is
the XOR of mi with the permutation bit of the corre-
sponding output value.

The total length of a gate table is now 2(n− 1) + 4 = 2n + 2
bits (concretely 258 bits). The evaluation of a gate is per-
formed by computing Ki; using its most signiﬁcant n − 1
bits for computing the corresponding garbled output value;
and using its least signiﬁcant bit mi for computing the cor-
responding signal bit.

As for security, note that the mi bits are pseudorandom,
and are used only for the encryption of the permutation/
signal values.

Intuition for Security. Recall that the 4-to-3 garbled row
reduction scheme enables an arbitrary choice of the output
wire key that is not k[T0]. The new 4-to-2 garbled row re-
duction scheme that we present is a special case, where we
deﬁne that output wire key to be equal to K1 ⊕ K2 ⊕ K3.
Note that the evaluator can compute one of the Ki values
using the two keys it holds, and can obtain two of the other
three using T1, T2. However, in order to learn the other
output wire key it needs the one Ki value that it cannot
compute. Thus, from the point of view of the evaluator, the
other output wire key, is a random string as required.

The complete speciﬁcation of the row-reduction scheme
and its proof of security appears in the full version of this
paper [11].

5. EXPERIMENTAL RESULTS AND

DISCUSSION

In the previous sections, we presented four tools that can
optimize the performance of garbled circuits without rely-
ing on any additional cryptographic assumption beyond the
existence of pseudorandom functions: (1) pipelined garbling;
(2) pipelined key-scheduling; (3) XOR gates with one cipher-
text and three encryptions; and (4) improved 4-2 GRR for
AND gates.
In this section, we present the results of an
experimental evaluation of these methods – together and
separately – and compare their performance to that of other
garbling methods.

Table 4 shows the time it takes to run the full Yao semi-
honest protocol [19, 23] on three diﬀerent circuits of inter-
est: AES, SHA-256 and Min-Cut 250,000. The circuits
have 6,800, 90,825 and 999,960 AND gates, respectively, and
25,124, 42,029 and 2,524,920 XOR gates, respectively. The
number of input bits for which OTs are performed are 128,
256 and 250,000, respectively [1]. We remark that our im-
plementation of the semi-honest protocol of Yao utilizes the
highly optimized OT extension protocol of [2].

We examined eight diﬀerent schemes, described using the
following notation: [pipe-garble] for the pipelined garbling
method; [pipe-garble+KS] for both pipelined garbling and
pipelined key-scheduling; [ﬁxed-key] where all PRF eval-
uations were performed using the ﬁxed-key technique de-
scribed in [5]; [XOR-3] where XOR gates were garbled us-
ing a simple 4-3 GRR method; [XOR-1] where XOR gates
were garbled using our method of garbling with one cipher-
text; [free-XOR] where the free-XOR technique was used;
[AND-3] where AND gates were garbled using simple 4-3
GRR; [AND-2] where our 4-2 GRR method was used to
garble AND gates; and ﬁnally, [AND-HalfGates] where
the “half-gates” technique of [24] was used to garble AND
gates. Note that the half-gates method is only used in con-
junction with free-XOR since this is a requirement.

The ﬁrst scheme in Table 4 is the most “na¨ıve”, where a
simple 4-3 GRR was used for both AND and XOR gates and
the garbling was pipelined but not the key-scheduling. In
contrast, the last scheme is the most eﬃcient as it uses fast
ﬁxed-key encryption and the half-gates approach to achieve
two ciphertexts per AND gates and none for XOR gates.
However, this scheme is based on the strongest assumption,
that AES behaves like a random permutation with a ﬁxed
key. The third scheme in the table uses all our optimizations
together, and thus it is the most eﬃcient scheme that is
based on a standard PRF assumption. The sixth scheme in
the table shows the best that can be achieved while assuming
circularity and related key security, but without resorting to
the public random permutation assumption.

The experiments were performed on Amazon’s c4.8xlarge
compute-optimized machines (with Intel Xeon E5-2666 v3

576Assumption

Scheme

PRF

Circularity

Pipe-garbl; XOR-3; AND-3 (na¨ıve)
Pipe-garbl+KS; XOR-1; AND-3

1
2
3 Pipe-garbl+KS; XOR-1; AND-2
4
5
6 Pipe-garbl+KS; free-XOR; HalfGates

Pipe-garbl; free-XOR; AND-3
Pipe-garbl+KS; free-XOR; AND-3

Public Random 7
Permutation

Fixed-key; free-XOR; AND-3

8 Fixed-key; free-XOR; Halfgates

AES

SHA-256

VA-VA VA-IRE VA-VA VA-IRE

Min-Cut
VA-VA

20
16
16
16
16
16
16
16

203
200
200
198
198
196
196
195

68
54
50
45
36
27
27
20

303
236
229
222
221
206
214
199

1947
1195
1047
753
701
546
596
460

Table 4: Summary of experimental results (times are for a full semi-honest execution in milliseconds). The ﬁrst row is for na¨ıve garbling.
Rows 2,3,5 and 6 are based on our improvements. The rows marked in boldface highlight the best schemes under each set of assumptions.

Assumption

PRF

Circularity

Scheme
Pipe-garbl; XOR-3; AND-3 (na¨ıve)
Pipe-garbl+KS; XOR-1; AND-3

1
2
3 Pipe-garbl+KS; XOR-1; AND-2
4
5
6 Pipe-garbl+KS; free-XOR; HalfGates

Pipe-garbl; free-XOR; AND-3
Pipe-garbl+KS; free-XOR; AND-3

Public Random 7
Permutation

Fixed-key; free-XOR; AND-3

8 Fixed-key; free-XOR; Halfgates

AES
95,772
45,524
38,724
20,400
20,400
13,600
20,400
13,600

SHA-256 Min-Cut
10,574,640
5,524,800
4,524,840
2,999,880
2,999,880
1,999,920
2,999,880
1,999,920

398,562
314,504
223,679
272,475
272,475
181,650
272,475
181,650

Table 5: Summary of garbled-circuit size in number of ciphertexts, according to scheme. The schemes are as in Table 4.

Haswell processors) running Windows. The measurements
include the time it takes to garble the circuit, send it to the
evaluator and compute the output. Since communication is
also involved, this measures improvements both in the en-
cryption technique and in the size of circuit. Each scheme
was tested on the three circuits in two diﬀerent settings:
the Virginia-Virginia (VA-VA) setting where the two par-
ties running the protocol are located at the same data center,
and the Virginia-Ireland (VA-IRE) setting where the phys-
ical distance between the parties is large. (We omitted the
results of running the large min-cut circuit in the VA-IRE
setting as they were not consistent and had a high variabil-
ity.) Each number in the table is an average of 20 executions
of the indicated speciﬁc scenario.

The table rows marked in boldface highlight the best schemes

under each set of assumptions. Looking at the results, we
derive the following observations:

• Best eﬃciency: As predicted, the ﬁxed key + half-
gates implementation (8) is the fastest and most eﬃ-
cient in all scenarios. (This seems trivial, but when us-
ing ﬁxed-key AES, the Eval procedure at AND gates re-
quires one more encryption than in a simple 4-3 GRR.
Thus, this conﬁrms the hypothesis that the communi-
cation saved is far more signiﬁcant than an additional
encryption, that is anyway pipelined.)

• Small circuits: In small circuits (e.g., AES) the run-
ning time is almost identical in all schemes and in both
communication settings. In particular, using our op-
timizations (3) yields the same performance result as
that of the most eﬃcient scheme (8), in both the VA-
VA and VA-IRE settings. This is due to the fact that
in small circuits, running the OT protocol is the bot-
tleneck of the protocol (even if, as in our experiments,
optimize OT-extension [2] is used). This means that
for small circuits there is no reason to rely on a non-
standard cryptographic assumption.

• Medium circuits:

In the larger SHA-256 circuit,
where the majority of the gates are AND gates, there
was a diﬀerence between the results in the two com-
munication settings.
In the VA-VA setting the best

scheme based on PRF alone (3) has performance that
is closer to that of the na¨ıve scheme (1) than to that of
the schemes based on the circularity or the public ran-
dom permutation assumptions (schemes 6 and 8). In
contrast, in the VA-IRE setting the PRF based scheme
performs close to schemes 6 and 8. This is explained
by observing that when the parties are closely located,
communication is less dominant and garbling becomes
a bigger factor. Thus, garbling XOR gates for free im-
proves the performance of the protocol. In contrast,
when the parties are far from each other, communi-
cation becomes the bottleneck, thus the PRF based
scheme (3) yields a signiﬁcant improvement compared
to the na¨ıve case (1) and its performance is not much
worse than that of the best ﬁxed-key based scheme
(and since there are fewer XOR gates, the overhead of
an additional ciphertext per gate is reasonable).

• Large circuits: In the large Min-Cut circuit, the run
time of our best PRF based scheme (3) is closer to
the best result (8) than to the na¨ıve result (1). This
is explained by the fact that the circuit is very large
and so bandwidth is very signiﬁcant. This is especially
true since the majority of gates are XOR gates, and so
the reduction from 3 ciphertexts to 1 ciphertext per
XOR gate has a big inﬂuence. (Observe that the num-
ber of ciphertexts sent in (8) is 2,000,000, the number
of ciphertexts sent in (3) is 4,500,000, while the num-
ber of ciphertexts sent in (1) is 10,500,000.) Observe
that schemes (6) and (8) have the same bandwidth;
the diﬀerence in cost is therefore due to the additional
cost of the AES key schedules and encryptions. Note,
however, that despite the fact that there are 1,000,000
AND gates, the diﬀerence between the running-times
is 15%, which is not negligible but also not overwhelm-
ing.

• Removing the public random permutation as-
sumption: Comparing scheme (8), which is the most
eﬃcient, to scheme (6) which is the most eﬃcient scheme
that does not depend on the public random permuta-
tion assumption, shows that in all scenarios removing

577the ﬁxed-key technique causes only a minor increase in
running time.

We conclude that strengthening security by removing the
public random permutation assumption does not noticeably
aﬀect the performance of the protocol. Thus, in many cases,
two-party secure computation protocols does not need to use
the ﬁxed-key method. Further security strengthening by
not depending on a circularity assumption (i.e., “paying” for
XOR gates) does come with a cost. Yet, in scenarios where
garbling time is not the bottleneck (e.g.
small circuits, large
inputs, communication constraints), one should consider us-
ing a more conservative approach as suggested in this work.
In any case, we believe that our ideas should encourage fu-
ture research on achieving faster and more eﬃcient secure
two-party computation based on standard cryptographic as-
sumptions.

”

Acknowledgements
We express our deepest gratitudes to Meital Levy for her
great eﬀorts in implementing the diﬀerent methods and run-
ning the experiments.

6. REFERENCES

[1] Circuits of Basic Functions Suitable For MPC and

FHE, http://www.cs.bris.ac.uk/Research/
CryptographySecurity/MPC.

[2] G. Asharov, Y. Lindell, T. Schneier and M. Zohner.

More Eﬃcient Oblivious Transfer and Extensions
for Faster Secure Computation. In the 20th ACM
Conference on Computer and Communications
Security (ACM CCS), pages 535–548, 2013.

[3] M. Bellare, V.T. Hoang and P. Rogaway.

Foundations of garbled circuits. In the 19th ACM
Conference on Computer and Communications
Security (ACM CCS0, pages 784–796, 2012.

[4] J. Black. The Ideal-Cipher Model, Revisited: An
Uninstantiable Blockcipher-Based Hash Function.
In FSE 2006, Springer (LNCS 4047), pages
328–340, 2006.

[5] M. Bellare, V.T. Hoang, S. Keelveedhi and

P. Rogaway. Eﬃcient Garbling from a Fixed-Key
Blockcipher. In the IEEE Symposium on Security
and Privacy 2013, pages 478–492, 2013.

[6] A. Biryukov, D. Khovratovich and I. Nikolic.

Distinguisher and Related-Key Attack on the Full
AES-256. In CRYPTO 2009, Springer (LNCS
5677), pages 231–249, 2009.

[7] S.G. Choi, J. Katz, R. Kumaresan and H. Zhou. On

the Security of the “Free-XOR” Technique. In the
9th TCC, Springer (LNCS 7194), pages 39–53, 2012.

https://bugzilla.mozilla.org/show_bug.cgi?
id=1122903 (2015).

[11] S. Gueron, Y. Lindell, A. Nof and B. Pinkas. Fast
Garbling of Circuits Under Standard Assumptions
(full version of this paper). Cryptology ePrint
Archive, Report 2015/751, 2015.

[12] Y. Huang, D. Evans, J. Katz and L. Malka. Faster

Secure Two-Party Computation Using Garbled
Circuits. In the 20th USENIX Security Symposium,
2011.

[13] Y. Ishai, J. Kilian, K. Nissim and E. Petrank.

Extending Oblivious Transfer Eﬃciently. In
CRYPTO 2003, Springer (LNCS 2729), pages
145–161, 2003.

[14] L.R. Knudsen and V. Rijmen. Known-Key
Distinguishers for Some Block Ciphers. In
ASIACRYPT 2007, Springer (LNCS 4833), pages
315–324, 2007.

[15] V. Kolesnikov, P. Mohassel and M. Rosulek.

FleXOR: Flexible Garbling for XOR Gates That
Beats Free-XOR. In CRYPTO 2014, Springer
(LNCS 8617), pages 440–457, 2014.

[16] V. Kolesnikov and T. Schneider. Improved Garbled
Circuit: Free XOR Gates and Applications. In the
35th ICALP, Springer (LNCS 5126), pages 486–498,
2008.

[17] V. Kolesnikov and T. Schneider. Secure Function

Evaluation Techniques For Circuits Containing
XOR Gates With Applications To Universal
Circuits. Patent No. US 8,443,205 B2, 2013.

[18] B. Kreuter, A.Shelat, and C. Shen. Billion-Gate

Secure Computation with Malicious Adversaries. In
the 21st USENIX Security Symposium, 2012.

[19] Y. Lindell and B. Pinkas. A Proof of Yao’s Protocol
for Secure Two-Party Computation. In the Journal
of Cryptology, 22(2):161–188, 2009.

[20] Y. Lindell, B. Pinkas and N. Smart. Implementing
Two-Party Computation Eﬃciently with Security
Against Malicious Adversaries. In the 6th
Conference on Security and Cryptography for
Networks, Springer (LNCS 5229), pages 2–20, 2008.

[21] M. Naor, B. Pinkas and R. Sumner. Privacy

Preserving Auctions and Mechanism Design. In the
ACM Conference on Electronic Commerce, pages
129–139, 1999.

[22] B. Pinkas, T. Schneider, N.P. Smart and

S.C. Williams. Secure Two-Party Computation Is
Practical. In ASIACRYPT 2009, Springer (LNCS
5912), pages 250–267, 2009.

[23] A. Yao. How to Generate and Exchange Secrets. In

the 27th FOCS, pages 162–167, 1986.

[8] S. Gueron. Intel Advanced Encryption Standard

[24] S. Zahur, M. Rosulek and D. Evans. Two Halves

(AES) Instructions Set, Rev 3.01. (2012)
https://software.intel.com/en-
us/articles/intel-advanced-encryption-
standard-aes-instructions-set

[9] S. Gueron. Intel’s New AES Instructions for

Enhanced Performance and Security. In the 16th
FSE (FSE 2009), Springer (LNCS 5665), pages
51–66, 2009.

[10] S. Gueron. Optimized implementation of AES
128/192/256 key expansion. Software patch in

Make a Whole - Reducing Data Transfer in Garbled
Circuits Using Half Gates. In EUROCRYPT 2015,
Springer (LNCS 9057), pages220–250, 2015. pages
220–250, 2015.

578