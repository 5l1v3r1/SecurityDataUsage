FRESCO: Modular Composable Security Services

for Software-Deﬁned Networks

Seugwon Shin1, Phillip Porras2, Vinod Yegneswaran2, Martin Fong2, Guofei Gu1, Mabry Tyson2

(1) Texas A&M University
College Station, TX 77840

seungwon.shin@neo.tamu.edu

guofei@cse.tamu.edu

(2) SRI International
Menlo Park, CA 94025

{porras,vinod,mwfong}@csl.sri.com

mabry.tyson@sri.com

Abstract

OpenFlow is an open standard that has gained tremen-
dous interest in the last few years within the network com-
munity.
It is an embodiment of the software-deﬁned net-
working paradigm, in which higher-level ﬂow routing deci-
sions are derived from a control layer that, unlike classic
network switch implementations, is separated from the data
handling layer. The central attraction to this paradigm is
that by decoupling the control logic from the closed and
proprietary implementations of traditional network switch
infrastructure, researchers can more easily design and dis-
tribute innovative ﬂow handling and network control al-
gorithms. Indeed, we also believe that OpenFlow can, in
time, prove to be one of the more impactful technologies to
drive a variety of innovations in network security. Open-
Flow could offer a dramatic simpliﬁcation to the way we
design and integrate complex network security applications
into large networks. However, to date there remains a stark
paucity of compelling OpenFlow security applications. In
this paper, we introduce FRESCO, an OpenFlow security
application development framework designed to facilitate
the rapid design, and modular composition of OF-enabled
detection and mitigation modules. FRESCO, which is it-
self an OpenFlow application, offers a Click-inspired [19]
programming framework that enables security researchers
to implement, share, and compose together, many differ-
ent security detection and mitigation modules. We demon-
strate the utility of FRESCO through the implementation of
several well-known security defenses as OpenFlow security
services, and use them to examine various performance and
efﬁciency aspects of our proposed framework.

1

Introduction
OpenFlow (OF) networks distinguish themselves from
legacy network infrastructures by dramatically rethinking
the relationship between the data and control planes of

the network device. OpenFlow embraces the paradigm of
highly programmable switch infrastructures [23], enabling
software to compute an optimal ﬂow routing decision on de-
mand. For modern networks, which must increasingly deal
with host virtualization and dynamic application migration,
OpenFlow may offer the agility needed to handle dynamic
network orchestration beyond that which traditional net-
works can achieve.

For an OpenFlow switch, the data plane is made pro-
grammable, where ﬂows are dynamically speciﬁed within a
ﬂow table. The ﬂow table contains a set of ﬂow rules, which
specify how the data plane should process all active network
ﬂows. In short, OpenFlow’s ﬂow rules provide the basic in-
structions that govern how to forward, modify, or drop each
packet that traverses the OF-enabled switch. The switch’s
control plane is simpliﬁed to support the OpenFlow proto-
col, which allows the switch to communicate statistics and
new ﬂow requests to an external OpenFlow network con-
troller. In return, it receives ﬂow rules that extend its ﬂow
table ruleset.

An OF controller is situated above a set of OF-enabled
switches, often on lower-cost commodity hardware. It is the
coordination point for the network’s ﬂow rule production
logic, providing necessary ﬂow rule updates to the switch,
either in response to new ﬂow requests or to reprogram the
switch when conditions change. As a controller may com-
municate with multiple OF switches simultaneously, it can
distribute a set of coordinated ﬂow rules across the switches
to direct routing or optimize tunneling in a way that may
dramatically improve the efﬁciency of trafﬁc ﬂows. The
controller also provides an API to enable one to develop
OpenFlow applications, which implement the logic needed
to formulate new ﬂow rules. It is this application layer that
is our central focus.

From a network security perspective, OpenFlow offers
researchers with an unprecedented singular point of con-
trol over the network ﬂow routing decisions across the
data planes of all OF-enabled network components. Using

OpenFlow, an OF security app can implement much more
complex logic than simplifying halting or forwarding a ﬂow.
Such applications can incorporate stateful ﬂow rule produc-
tion logic to implement complex quarantine procedures, or
malicious connection migration functions that can redirect
malicious network ﬂows in ways not easily perceived by
the ﬂow participants. Flow-based security detection algo-
rithms can also be redesigned as OF security apps, but im-
plemented much more concisely and deployed more efﬁ-
ciently, as we illustrate in examples within this paper.

We introduce a new security application development
framework called FRESCO. FRESCO is intended to ad-
dress several key issues that can accelerate the composition
of new OF-enabled security services. FRESCO exports a
scripting API that enables security practitioners to code se-
curity monitoring and threat detection logic as modular li-
braries. These modular libraries represent the elementary
processing units in FRESCO, and may be shared and linked
together to provide complex network defense applications.
FRESCO currently includes a library of 16 commonly
reusable modules, which we intend to expand over time.
Ideally, more sophisticated security modules can be built by
connecting basic FRESCO modules. Each FRESCO mod-
ule includes ﬁve interfaces: (i) input, (ii) output, (iii) event,
(iv) parameter, and (v) action. By simply assigning val-
ues to each interface and connecting necessary modules, a
FRESCO developer can replicate a range of essential secu-
rity functions, such as ﬁrewalls, scan detectors, attack de-
ﬂectors, or IDS detection logic.

FRESCO modules can also produce ﬂow rules, and thus
provide an efﬁcient means to implement security directives
to counter threats that may be reported by other FRESCO
detection modules. Our FRESCO modules incorporate sev-
eral security functions ranging from simple address block-
ing to complex ﬂow redirection procedures (dynamic quar-
antine, or reﬂecting remote scanners into a honeynet, and
so on). FRESCO also incorporates an API that allows exist-
ing DPI-based legacy security tools (e.g., BotHunter [12])
to invoke FRESCO’s countermeasure modules. Through
this API, we can construct an efﬁcient countermeasure ap-
plication, which monitors security alerts from a range of
legacy IDS and anti-malware applications and triggers the
appropriate FRESCO response module to reprogram the
data planes of all switches in the OpenFlow network.

Contributions.

In summary, our primary contribution
is the introduction of FRESCO, which simpliﬁes the devel-
opment and deployment of complex security services for
OpenFlow networks. To this end, we describe

• FRESCO: a new application development framework
to assist researchers in prototyping new composable
security services in OF-enabled networks. FRESCO
scripts can be deﬁned in a manner agnostic to OF con-
troller implementation or switch hardware (an impor-
tant feature given the rapid evolution of the protocol

standard).

• A collection of OpenFlow security mitigation direc-
tives (FRESCO modules) and APIs to enable legacy
applications to trigger these modules. Using FRESCO,
security projects could integrate alarms from legacy
network security DPI-based applications as inputs to
FRESCO detection scripts or as triggers that invoke
FRESCO response scripts that generate new ﬂow rules.
• Several exemplar security applications demonstrate
both threat detection and mitigation in an OpenFlow
network, including scan detectors
[16, 35, 15] and
BotMiner [11]. We further show that existing secu-
rity applications can be easily created with the use
of FRESCO. For example, our FRESCO implementa-
tions demonstrate over 90% reduction in lines of code
when compared to standard implementations and re-
cently published OpenFlow implementations [24].

• A performance evaluation of FRESCO, which shows
promise in developing OpenFlow security services that
introduce minimal overhead for use in live network en-
vironments.

2 Background and Motivation

Our intent is to design an application framework that
enables the modular design of complex OF-enabled net-
work security services, which can be built from smaller
sharable libraries of security functions. Before presenting
FRESCO’s design, we ﬁrst review some of the challenges
that motivate the features of our framework.
2.1 The Information Deﬁciency Challenge

OpenFlow controllers do not uniformly capture and store
TCP session information, among other key state tracking
data, which is often required to develop security functional-
ity (e.g., TCP connection status, IP reputation). We call this
an information deﬁciency challenge. The FRESCO archi-
tecture incorporates a database module (FRESCO-DB) that
simpliﬁes storage and management of session state shared
across applications. FRESCO also exports a high-level API
in the FRESCO language that abstracts away complexities
relating to switch management and speciﬁc controller im-
plementations. This abstraction is a critical feature to en-
able module sharing across OpenFlow network instances
that may vary in controller and OpenFlow protocol version.
2.2 The Security Service Composition Challenge

The FRESCO framework incorporates a modular and
composable design architecture, inspired by the Click router
architecture [19], which fosters rapid and collaborative de-
velopment of applications through module composition.
For example, a security module design to recognize cer-
tain trafﬁc patterns that may represent a threat should be
easily linkable to a variety of potential threat mitigation

Figure 1. High-level overview of the FRESCO architecture.

modules that, when triggered by the detection module, pro-
duce appropriate ﬂow rule responses. FRESCO incorpo-
rates a scripting language that enables the linking of mod-
ules through data sharing and event triggering. Another
important challenge is the need to provide an API that
can facilitate ﬂow rule production decisions using informa-
tion produced from legacy DPI-based security applications
(such as IDS or anti-malware applications).
2.3 The Threat Response Translation Challenge

The OpenFlow protocol enables the controlling software
layer to communicate ﬂow handling instructions to the data
plane. However, while network security technologies do in-
deed produce threat alerts applicable to responses for indi-
vidual ﬂows, these technologies also have a need to express
more complex (even stateful) security response directives
that may span many ﬂow rules, or even address network-
wide attack scenarios. We call this the threat response trans-
lation challenge.

For example, one may wish to deﬁne a notion of host
quarantine, in which all ﬂows from an infected internal ma-
chine are blocked, with the exception that the machine’s
web trafﬁc should be redirected to a web server that returns
quarantine notiﬁcation pages to the machine’s user. One
might also wish to deﬁne redirection directives that will
silently redirect ﬂows from a detected hostile external en-
tity away from an internal production network and into a
honeynet for analysis. One might even want to produce a
network-wide response to shun malicious trafﬁc, or alter-
natively, incorporate high-priority ﬂow rules to ensure that
emergency administrative ﬂows succeed during a DOS at-
tack.

Such security directives may require a complex set of
ﬂow rule production logic, which is also ideally sharable as

a countermeasure library that could be coupled with many
different detection algorithms.

3 FRESCO DESIGN

The FRESCO framework consists of an application layer
(which provides an interpreter and APIs to support compos-
able application development) and a security enforcement
kernel (SEK, which enforces the policy actions from devel-
oped security applications), as illustrated in Figure 1. Both
components are integrated into NOX, an open-source open-
ﬂow controller.

FRESCO’s application layer is implemented using NOX
python modules, which are extended through FRESCO’s
APIs to provide two key developer functions: (i) a FRESCO
Development Environment [DE], and (ii) a Resource Con-
troller [RC], which provides FRESCO application develop-
ers with OF switch- and controller-agnostic access to net-
work ﬂow events and statistics.

Developers use the FRESCO script language to instanti-
ate and deﬁne the interactions between the NOX python se-
curity modules (we present FRESCO’s scripting language
in Section 4.3). These scripts invoke FRESCO-internal
modules, which are instantiated to form a security appli-
cation that is driven by the input speciﬁed via the FRESCO
scripts (e.g., TCP session and network state information)
and accessed via FRESCO’s DE database API. These in-
stantiated modules are triggered (executed) by FRESCO DE
as the triggering input events are received. FRESCO mod-
ules may also produce new ﬂow rules, such as in response to
a perceived security threat, which are then processed by the
controller’s security enforcement kernel [SEK] (Section 5).

4 FRESCO Application Layer

The basic operating unit in the FRESCO framework is
called a module. A module is the most important element
of FRESCO. All security functions running on FRESCO are
realized through an assemblage of modules. Modules are
deﬁned as Python objects that include ﬁve interface types:
(i) input, (ii) output, (iii) parameter, (iv) action, and (v)
event. As their names imply, input and output represent the
interfaces that receive and transmit values for the module.
A parameter is used to deﬁne the module’s conﬁguration or
initialization values. A module can also deﬁne an action to
implement a speciﬁc operation on network packets or ﬂows.
An event is used to notify a module when it is time to per-
form an action.

A module is implemented as an event-driven processing
function. A security function can be realized by a single
module or may be composed into a directed graph of pro-
cessing to implement more complex security services. For
example, if a user desires to build a naive port compara-
tor application whose function is to drop all HTTP packets,
this function can be realized by combining two modules.
The ﬁrst module has input, output, parameter, and event.
The input of the ﬁrst module is the destination port value
of a packet, its parameter is the integer value 80, an event
is triggered whenever a new ﬂow arrives, and output is the
result of comparing the input destination port value and pa-
rameter value 80. We pass the output results of the ﬁrst
module as input of the second module and we assign drop
and forward actions to the second module. In addition, the
second module performs its function whenever it is pushed
as an input. Hence, the event of this module is set to be
push. A module diagram and modules representing this ex-
ample scenario are shown in Figure 2.

Figure 2. Illustration of FRESCO module de-
sign (left: model diagram; right: naive port
comparator application)

An action is an operation to handle network packets (or
ﬂows). The actions provided by FRESCO derive from the
actions supported by the NOX OpenFlow controller. The
OpenFlow standard speciﬁes three required actions, which
should be supported by all OpenFlow network switches, and
four optional actions, which might be supported by Open-
Flow network switches [29]. OpenFlow requires support for
three basic actions: (i) drop, which drops a packet, (ii) out-
put, which forwards a packet to a deﬁned port (in this paper,
we sometimes use the term forward to denote the output ac-

tion), and (iii) group, which processes a packet through the
speciﬁed group. As these actions must be supported by all
OpenFlow network switches, FRESCO also exports them to
higher-level applications.

One optional action of interest is the set action, which
enables the switch to rewrite a matching packet’s header
ﬁelds (e.g., the source IP, destination port) to enable such
features as ﬂow path redirection. Because one of the pri-
mary goals of FRESCO is to simplify development of secu-
rity functions, FRESCO handles possible issues related to
the set action by breaking the set action into three more spe-
ciﬁc actions: redirect, mirror, and quarantine. Through the
redirect action, an application can redirect network packets
to a host without explicitly maintaining state and dealing
with address translation. FRESCO ofﬂoads session man-
agement tasks from applications and automatically changes
the source and destination IP address to handle redirects.
The mirror action copies an incoming packet and forwards
it to a mirror port for further analysis. The functionality may
be used to send a packet to a feature or other packet analy-
sis systems. The quarantine action isolates a ﬂow from the
network. Quarantine does not mean dropping a particular
ﬂow, but rather, FRESCO attaches a tag to each packet to
denote a suspicious (or malicious) packet. If a packet has
the tag, then this packet can traverse only to allowed hosts
(viz., a FRESCO script can ﬁshbowl an infected host into
an isolated network using packet tags).
4.1 FRESCO Development Environment

The FRESCO development environment (DE) provides
security researchers with useful information and tools to
synthesize security controls. To realize this goal, we de-
sign the FRESCO DE with two considerations. First, this
environment must export an API that allows the developer
to detect threats and assert ﬂow constraints while abstract-
ing the NOX implementation and OF protocol complexi-
ties. Second, the component must relieve applications from
the need to perform redundant data collection and manage-
ment tasks that are common across network security appli-
cations. The FRESCO development environment provides
four main functions: (i) script-to-module translation, (ii)
database management, (iii) event management, and (iv) in-
stance execution.

Script-to-module translation: This function automati-
cally translates FRESCO scripts to modules, and creates in-
stances from modules, thus abstracting the implementation
complexities of producing OF controller extensions. It is
also responsible for validating the registration of modules.
Registration is performed via a registration API, which en-
ables an authorized administrator to generate a FRESCO ap-
plication ID and an encryption key pair. The developer em-
beds the registered application ID into the FRESCO script,
and then encrypts the script with the supplied private key.
The naming convention of FRESCO applications incorpo-
rates the application ID, which is then used by FRESCO to

associate the appropriate public key with the application. In
addition to registering modules, the module manager coor-
dinates how modules are connected to each other and deliv-
ers input and event values to each module.

Database management: The DB manager collects var-
ious kinds of network and switch state information, and
provides an interface for an instance to use the informa-
tion.
It provides its own storage mechanism that we call
the FRESCO-DataBase (F-DB), which enables one to share
state information across modules. For example, if an in-
stance wants to monitor the number of transferred packets
by an OpenFlow enabled switch, it can simply request the
F-DB for this information. In addition, this database can be
used to temporarily store an instance.

Event management: The event manager notiﬁes an in-
stance about the occurrence of predeﬁned events. It checks
whether the registered events are triggered, and if so deliv-
ers these events to an instance. FRESCO supports many
different kinds of events, including ﬂow arrivals, denied
connections, and session resets.
In addition, the event
manager exposes an API that enables event reporting from
legacy DPI-based security applications, such as Snort [38]
or BotHunter [12]. The security community has developed
a rich set of network-based threat monitoring services, and
the event manager’s API enables one to tigger instances that
incorporate ﬂow rule response logic. 1

Instance execution: This function loads the created
instances into memory to be run over the FRESCO frame-
work. During load time, FRESCO decrypts the application
using the associated public key, and conﬁrms that the ID
embedded in the script corresponds to the appropriate pub-
lic key. The application then operates with the authority
granted to this application ID at registration time.
4.2 FRESCO Resource Controller

The FRESCO resource controller monitors OpenFlow
network switches and keeps track of their status. A ﬂow
rule that is distributed from a FRESCO application is in-
serted into a ﬂow table in an OpenFlow switch. Because the
ﬂow table has a limit on the number of entries it can hold, it
is possible that a ﬂow rule from a FRESCO application can-
not be inserted into the ﬂow table. However, because ﬂow
rules from a FRESCO application deal with security policy
enforcement, such ﬂow rules require immediate installation
into the ﬂow table of an OpenFlow network switch. Thus,
FRESCO may forcibly evict some old or stale ﬂow rules,
both FRESCO and non-FRESCO, from the switch ﬂow ta-
ble to make space for new ﬂow rules. This operation is
done by the resource controller. Garbage collecting inac-
tive FRESCO rules does not compromise the network se-
curity policy: if a prohibited ﬂow is re-attempted later, the
FRESCO SEK will prevent other OF applications from per-
forming the ﬂow setup.

1The example case for this scenario is shown in section 6.

The resource controller performs two main functions.
The ﬁrst function, which we call the switch monitor, period-
ically collects switch status information, such as the number
of empty ﬂow entries, and stores the collected information
in the switch status table. The second component, i.e., the
garbage collection, checks the switch status table to moni-
tor whether the ﬂow table in an OpenFlow switch is nearing
capacity. If the availability of a ﬂow table becomes lower
than a threshold value (θ), the garbage collector identiﬁes
and evicts the least active ﬂow, using least frequently used
(LFU) as FRESCO’s default policy.
4.3 FRESCO Script Language
To simplify development of

security applications,
FRESCO provides its own script language to assist develop-
ers in composing security functions from elementary mod-
ules. The textual language, modeled after the Click lan-
guage [19], requires the deﬁnition of six different variables
per instance of modular element: (i) type, (ii) input, (iii)
output, (iv) parameter, (v) action, and (vi) event.

To conﬁgure modules through a FRESCO script, devel-
opers must ﬁrst create an instance of a module, and this in-
stance information is deﬁned in type variable. For example,
to use a function that performs a speciﬁc action, a developer
can create an instance of the ActionHandler module (de-
noted as type:ActionHandler within a FRESCO script).
Developers can specify a script’s input and output, and
register events for it to process by deﬁning the script’s in-
put, output, parameter, and event variables. Multiple value
sets for these variables (e.g., specifying two data inputs to
input) may be deﬁned by using a comma as the ﬁeld sep-
arator.

Deﬁning an instance is very similar to deﬁning a function
in C or C++. A module starts with the module name, two
variables for representing the number of inputs and outputs,
and left braces (i.e., { ). The numbers of inputs and outputs
are used to sanity check the script during module transla-
tion. Like C or C++ functions, a module deﬁnition ends
with a right brace (i.e., } ).

The action variable represents actions that a module
will perform based on some conditions, where the condi-
tions are determined by one of the input items. There may
be multiple conditions in the action, which are separated
by semicolons. We summarize these variables in Table 1,
and Figure 3 shows example scripts of the port comparator
application shown in Figure 2 (right) with two connecting
modules.

FRESCO Script Execution: We use a simple running
example, shown in Figures 3 and 4, to illustrate the exe-
cution of a FRESCO script. First, an administrator com-
poses a FRESCO script (shown in Figure 3) (1), and loads
it into FRESCO (2). Next, when Host A sends a packet
to port 80 of Host B through an OpenFlow switch, as il-
lustrated in Figure 4 (3), this packet delivery event is re-
ported to the FRESCO DE (4). The FRESCO DE cre-

Variable
instance name (#input)(#output)
type: [module]
input: a1,a2,...
output: b1, b2,...
parameter: c1,c2,...
event: d1,d2,...
action : condition ? action,...

{ }

Explanation
denotes an instance name (should be unique)
denotes a module for this instance
denotes input items for a module
denotes output items for a module
denotes conﬁguration values of a module
denotes events delivered to a module
denotes set of conditions and actions per-
formed in the module
denotes the module start ({) and end (})

Possible Values
(#input) and (#output) denote the number of inputs and outputs
[module] names an existing module
an may be set of ﬂows, packets or integer values
bn may be set of ﬂows, packets or integer values
cn may be real numbers or strings
dn may be any predeﬁned string
condition follows the same syntax of if condition of python lan-
guage; action may be one of the following strings (DROP, FOR-
WARD, REDIRECT, MIRROR, QUARANTINE)
-

Table 1. Key variables in the FRESCO scripting language

port_comparator (1)(1) {

do_action (1)(0) {

type:Comparator
event:INCOMING_FLOW
input:destination_port
output:comparison_result
parameter:80

/* no actions are defined */

action: -

}

type:ActionHandler
event:PUSH
input:comparison_result
output: - /* no outputs are defined */
parameter: - /* no parameters are defined */

/* if input equals to 1, drop, otherwise, forward */

action:comparator_result == 1 ? DROP : FORWARD

}

Figure 3. FRESCO script with two connecting modules used to build the naive port comparator

ply setting an action variable, as listed in Table 1. These
high-level security policies can help developers focus on
implementing security applications, and these policies will
be automatically translated into ﬂow rules for OpenFlow en-
abled switches by FRESCO DE (e.g., the REDIRECT ac-
tion will be translated into three ﬂow rules). Thus, develop-
ers do not need to care about network-level ﬂow rules.

However, when FRESCO DE enforces translated ﬂow
rules to switches, it will face a new challenge, which stems
from the fact that OpenFlow provides no inherent mecha-
nisms to reconcile rule conﬂicts as competing OpenFlow
applications assert new rules into a switch. For example,
a set of rules designed to quarantine an internal computing
server (i.e., the QUARANTINE action in a FRESCO script)
might subsequently be overridden by a load-balancing ap-
plication that may determine that the quarantined host is
now the least-loaded server. One needs a mechanism to en-
sure that ﬂow rules produced by a security application will
take precedence over those produced from non-security-
aware applications. OpenFlow also incorporates a packet
alteration functions (i.e., the set action), speciﬁable within
its ﬂow rule format. This feature enables virtual tunnels be-
tween hosts, such that a virtual tunnel can be used to cir-
cumvent a ﬂow rule that was inserted to prevent two hosts
from establishing a connection.

To address this issue, FRESCO incorporates a security
enforcement kernel (SEK), which is integrated directly into
the OpenFlow controller upon which FRESCO operates. A
more complete discussion of FRESCO SEK is provided in a
published workshop paper [31]. FRESCO SEK offers sev-
eral important features upon which FRESCO relies to en-
sure that ﬂow rules derived from security services are prior-
itized and enforced over competing ﬂow rules produced by

Figure 4. Operational illustration of running
FRESCO script (case of the FRESCO script
shown in Figure 3)

ates instances from modules deﬁned in the FRESCO script
(i.e., port comparator instance from comparator module and
do action instance from ActionHandler module) and dy-
namically loads them. The FRESCO DE runs each instance
(5, 6), and when it receives an action from the do action
module (i.e., drop) (7), it translates this action into ﬂow
rules, which can be understood by an OpenFlow switch. Fi-
nally, these ﬂow rules are installed into the switch through
the FRESCO SEK (8).
5 FRESCO Security Enforcement Kernel

Security applications developed in FRESCO scripts can
enforce diverse security policies, such as DROP, REDI-
RECT, QUARANTINE, to react to network threats by sim-

non-security-critical applications:

• Rule source identiﬁcation: The SEK introduces a trust
model that allows FRESCO applications to digitally
sign each candidate ﬂow rule, thus enabling the SEK
to determine if a candidate ﬂow rule was produced by
a FRESCO security module, by an OpenFlow applica-
tion, or by a network administrator.

• Rule conﬂict detection: To detect conﬂicts between a
candidate rule set and the set of rules currently active
in the switch, the SEK incorporates an inline rule con-
ﬂict analysis algorithm called alias set rule reduction,
which detects ﬂow rule conﬂicts, including those that
arise through set actions that are used to produce vir-
tual tunnels. Since this is not the main focus of this pa-
per, we include a relatively more detailed description
of our rule conﬂict detection algorithm in Appendix
A.1 for interested readers.

• Conﬂict resolution: When a conﬂict arises, the SEK
applies a hierarchical authority model that enables a
candidate rule to override (replace) an existing ﬂow
rule when the digital signature of the rule source is
deemed to possess more authority than the source
whose rule is in conﬂict.
6 Working Examples

We show two case studies by creating real working se-

curity applications written in FRESCO script.
6.1

Implementing Reﬂector Net

FRESCO’s power stems from its ability to use OpenFlow
to effectively reprogram the underlying network infrastruc-
ture to defend the network against an emerging threat. To
illustrate this notion, consider a FRESCO application that
allows OF network operators to redirect malicious scanners
to a third-party remote honeypot. Using FRESCO script, we
compose two modules that ﬁrst detect an active malicious
scanner, and then reprogram the switch data plane to redi-
rect all the scanner’s ﬂow into a remote honeynet. We refer
to our composed security service as a threat reﬂector net,
which effectively turns the address space of any OpenFlow
network that deploys this service into a contact surface for a
remote high-interaction honeypot. The incentive for an op-
erator to use such a service is that the forensic evidence col-
lected by the honeypot can be shared back for the purpose
of reﬁning the operator’s local FRESCO-based ﬁrewall.

First, we create and conﬁgure a simple threshold-
Since FRESCO already
based scan detector instance.
provides a “ScanDetector” module, we can instantiate an
instance from this module for selecting malicious exter-
nal targets.
let us assume that our
scan analysis is triggered by an external entity producing
large numbers of failed TCP connections. Thus, we es-
tablish TCP CONNECTION FAIL, which is captured in

For this example,

FRESCO’s native DB service, as an input trigger event for
our scan detection, which outputs a scan detection event
when a threshold number of failed connections is observed.
Our FRESCO script instantiates the scan detection mod-
(i) input, (ii) out-
ule using four key script variables:
put, (iii) parameter, and (iv) action. The input for this
instance is a source IP address for a ﬂow that causes
TCP CONNECTION FAIL event. The parameter will de-
termine a threshold value for a scan detection algorithm,
and here, we set this value as 5 (i.e., if a source IP generates
ﬁve failed TCP connections, we regard it as a scan attacker).
The output is a source IP address and a scan detection result
(noted as scan result), which are delivered to the second in-
stance as input variables. The action variable is not deﬁned
here, as the logic required to formulate and insert ﬂow rules
to incorporate duplex redirection is modularized into a sec-
ond ﬂow redirection instance. The FRESCO script for our
ﬂow redirection instance is shown in Figure 5 (left).

We conﬁgure a redirector instance to redirect ﬂows from
the malicious scanner to a honeynet (or forward benign
ﬂows). This function is an instance of FRESCO’s “Action-
Handler” module. This instance uses a PUSH event, which
triggers the instance each time “ﬁnd scan” is outputted from
the scan detection instance Finally, we need to deﬁne an ac-
tion to redirect ﬂows produced by scan attackers. Thus, we
set the action variable of this instance as “scan result == 1 ?
REDIRECT : FORWARD”, which indicates that if the input
variable of scan result equals 1 (denoting the scanner) this
instance redirects all ﬂows related to the source IP address.
The FRESCO script for this instance is shown in Figure 5
(right).

We test this script in an OpenFlow simulation environ-
ment with Mininet [25], which is commonly used to emu-
late OpenFlow networks, to show its real operation. In this
test, we created three hosts (scanner, target host, and hon-
eynet) and an OpenFlow enabled switch. All three hosts are
connected to the switch and able to initiate ﬂows to each
another.

As illustrated in Figure 6,

the malicious scanner
(10.0.0.2) tries to scan the host (10.0.0.4) using Nmap tool
[28]. The scan packets are delivered through an OpenFlow
switch (1), where the switch then forwards the ﬂow statistics
to a FRESCO application (i.e., ﬁnd scan instance) through
a controller. The ﬁnd scan instance determines that these
packets are scan-related, and it sends the detection result
to the do redirect instance to instantiate ﬂow rules to redi-
rect these packets to our honeynet (10.0.0.3) (2). At this
time, the network conﬁguration of the honeypot is different
from the original scanned machine (10.0.0.4), which opens
network port 445 while the honeypot opens network port
444. Then, the honeypot returns packets to the scanner as
if it is the original target (3). Finally, the scanner receives
packet responses from the honeypot (4), unaware that all of
its ﬂows are now redirected to and from the honeynet.

find_scan (1)(2){

type:ScanDetector
event:TCP_CONNECTION_FAIL
input:source_IP
output:source_IP, scan_result
parameter:5

/* no actions are defined */

action: -

}

do_redirect (2)(0){

type:ActionHandler
event:PUSH
input:source_IP, scan_result
output: -
parameter: -

/* if scan_result equals 1, redirect,

otherwise, forward */
action: scan_result == 1 ?

REDIRECT : FORWARD

}

Figure 5. FRESCO script with two connecting modules used to build a reﬂector net

on the messages through FRESCO script.

A message from a third-party security application will
be delivered to a module as a type of event - MES-
SAGE LEGACY, and the format of a message is of two
kinds: (i) FRESCO type and (ii) other standardized formats
such as the intrusion detection message exchange format
(IDMEF) [33]. If we use FRESCO type, it is notiﬁed in the
event as a keyword of FRESCO, and it can be represented as
MESSAGE LEGACY:FRESCO. If we use IDMEF, it can
be shown as MESSAGE LEGACY:IDMEF.

In the scenario, shown in Figure 7, an attacker sends a
bot binary (1) to the host C, and BotHunter responds by
producing an infection proﬁle (2). Then, BotHunter reports
this information (i.e., the Victim IP and forensic conﬁdence
score for the infection) to a security application written in
FRESCO script (3). If the proﬁle’s forensic score achieves a
threshold value, the application imposes a quarantine action
on the victim IP. The quarantine module uses the FRESCO
SEK to enforce a series of ﬂow rules that implement the
quarantine action SEK (4, 5). Finally, if an infected host
(the host C) sends another malicious data to other hosts,
such as host A or host B (6), it is automatically blocked by
the switch.

Figure 7. Operational illustration of a FRESCO
actuator cooperating with BotHunter

To implement this function, we simply reconﬁgure the
“do quarantine” instance (or create another instance) used
in the above example scenario for this case. This time,
we instantiate the instance with four alternate variables:
(i) event, (ii) input, (iii) parameter, and (iv) condition

Figure 6. Operational illustration of a FRESCO
reﬂector net application

6.2 Cooperating with a Legacy Security Application

FRESCO provides an interface, which receives messages
from legacy security applications, such as Snort [38] and
BotHunter [12]. Usually, we use these network security ap-
plications to monitor our networks, often using DPI-based
techniques to identify malicious trafﬁc content or by simply
monitoring ﬂow patterns. Using FRESCO, alerts produced
from such network security monitors can be integrated into
the ﬂow rule production logic of OF-enabled networks. To
do this, we employ FRESCO actions (e.g., drop and redi-
rect) as responses against network attacks.

One might consider reimplementing classic network
security applications directly as OpenFlow applications.
However, such efforts are both costly in engineering time
and subject to limitations in the availability of data pro-
vided by the OF controller. Also, OpenFlow does not ex-
port full packet content over its APIs, so DPI-based secu-
rity services must be implemented as external applications.
To reduce the integration burden, FRESCO provides a func-
tion of receiving messages from third-party security appli-
cations, and we can simply design response strategies based

part of action. When BotHunter forwards its infection
alarm using the FRESCO API, we set the event vari-
able as MESSAGE LEGACY:FRESCO. The input vari-
ables passed to this module include the victim ip (re-
ported as infected by BotHunter), and the infection conﬁ-
dence score, which represents the degree of forensic evi-
dence recorded within the infection proﬁle. We also spec-
ify a parameter for the conﬁdence threshold, and trigger the
QUARANTINE action when the conﬁdence score exceeds
the conﬁdence threshold. The FRESCO script for this in-
stance is shown in Figure 8.

do_quarantine (2)(0){
type:ActionHandler
event:MESSAGE_LEGACY:FRESCO
input:victim_ip,confidence_score
output: -
parameter:confidence_threshold

/* redirect all flows from source IP */

action:confidence_score > confidence_threshold

? QUARANTINE(victim_ip)

}

Figure 8. FRESCO script for invoking host
quarantine for BotHunter

7

Implementation
We have developed a prototype implementation of the
FRESCO architecture. The FRESCO Application Layer
prototype is implemented in Python and runs as an Open-
Flow application on NOX. The prototype operates on NOX
version 0.5.0 using the OpenFlow 1.1.0 protocol, and
is implemented in approximately 3,000 lines of Python.
FRESCO modules are implemented as independent Python
objects, and inputs and parameters of a module are input
variables to the Python object. The return values of a Python
object are considered as output values of a module.

A sample implementation of the FRESCO Compara-
tor module, used in Figure 2 (right), is presented in Fig-
ure 9. All modules in FRESCO start with the function
of module start, and this function has two arguments: (i)
input dic, which is a dictionary data structure contain-
ing F-DB, event, and input values, and (ii) param list,
which is a list structure storing user-deﬁned parameter val-
ues. All variables starting with ”FR ” are FRESCO native
variables. The developer ﬁlls in additional specialized logic
at the bottom of the module (lines 13-18).

The FRESCO SEK is

implemented as a native
C++ extension of the NOX source code in approxi-
mately 1160 lines of C++ code. We modiﬁed the
send openflow command function, whose main opera-
tion is to send OpenFlow commands to network switches,
to capture ﬂow rules from all OpenFlow applications.
FRESCO SEK intercepts ﬂow rules in the function and
stores them into the security constraints table if the rules
are from FRESCO applications (i.e., ﬂow rules produced

# initialize FRESCO variables
FR_ret_dic = {}
FR_ret_dic[’output’] = []
FR_ret_dic[’action’] = None

# initialize FRESCO native inputs
FR_FDB = input_dic[’FR_FDB’]
FR_event = in_dic[’FR_event’]
FR_input = input_dic[’FR_input’]

1 def module_start(input_dic, param_list):
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

FR_ret_dic[’output’].append(output)
# end - user defined logic

# start - user defined logic
if param_list[0] == FR_input[0]:

return FR_ret_dic

output = 1

else:

output = 0

Figure 9. FRESCO Comparator module

through the FRESCO path are considered trusted ﬂow rules
and are preserved as active network security constraints). If
a ﬂow rule is from a non-FRESCO application, FRESCO
SEK evaluates the rule to determine if a conﬂict exists
within its security constraints table. The match algorithm is
speciﬁcally optimized to perform the least-expensive com-
If there are conﬂicts, an error message is
parisons ﬁrst.
returned to the OF application. Otherwise,
the rule is
forwarded to the network switches. We implement and
evaluate the security constraint table using the in-memory
database opportunistic best-ﬁt comparison algorithm, which
reports an ability to execute queries in near-constant lookup
time.

8 System Evaluation

We now evaluate the FRESCO framework with respect
to its ease of use, ﬂexibility, and security constraints preser-
vation. To evaluate components in FRESCO, we employ
mininet [25], which provides a rapid prototyping environ-
ment for the emulation of OpenFlow network switches.
Using mininet, we have emulated one OpenFlow network
switch, three hosts connected to the switch, and one host to
operate our NOX controller. We perform ﬂow generation
by selecting one or two hosts to initiate TCP or UDP con-
nections. The remaining host is employed as a medium in-
teraction server, which responds to client application setup
requests. We hosted our evaluation environment on an Intel
i3 CPU with 4 GB of memory. In addition, we conduct live
performance evaluations of the FRESCO SEK using an HP
ProCurve 6600 OF-enabled switch in a test network labora-
tory.

8.1 Evaluating Modularity and Composability

For the evaluation, we begin with the basic problem of
identifying entities performing ﬂow patterns indicative of
malicious network scanning, and compare schemes of im-
plementing network scanning attacks with and without the
use of FRESCO.

While network scanning is a well-studied problem in the
network security realm, it offers an opportunity to examine
the efﬁciency of entity tracking using FRESCO. Many well-
established algorithms for scan detection exist [16, 15, 35].
However, under OpenFlow, the potential for FRESCO to
dynamically manipulate the switch’s data path in reaction
to malicious scans is a natural objective. This scenario also
lets us examine how simple modules can be composed to
perform data collection, evaluation, and response.

1. FRESCO Scan Deﬂector Service. Figure 10 illustrates
how FRESCO modules and their connections can be linked
together to implement a malicious scan deﬂector for Open-
Flow environments. This scan detection function consists of
the three modules described above. First, we have a module
for looking up a blacklist. This module checks a blacklist
table to learn whether or not an input source IP is listed.
If the table contains the source IP, the module notiﬁes its
presence to the second module. Based on the input value,
the second module performs threshold-based scan detection
or it drops a packet. If it does not drop the packet, it no-
tiﬁes the detection result to the third module. In addition,
this second module receives a parameter value that will be
used to determine the threshold. Finally, the third module
performs two actions based on input. If the input is 1, the
module redirects a packet. If the input is 0, it forwards a
packet. Implementing the three modules required 205 lines
of Python code and 24 lines of FRESCO script (this script
is shown in Figure 11).

Figure 10. FRESCO composition of a Scan De-
ﬂector

2. FRESCO BotMiner Service.
To illustrate a more
complex ﬂow analysis module using FRESCO, we have
implemented a FRESCO version of the BotMiner [11] ap-
plication. Note that our goal here is not faithful, “bug-
compatible” adherence to the full BotMiner protocol de-

scribed in [11], but rather to demonstrate feasibility and to
capture the essence of its implementation through FRESCO,
in a manner that is slightly simpliﬁed for readability.

Figure 12. FRESCO composition of the Bot-
Miner service

BotMiner detects bots through network-level ﬂow anal-
ysis. We have implemented the essentials of its detection
functionality using ﬁve modules as shown in Figure 12.
BotMiner assumes that hosts infected with the same bot-
net exhibit similar patterns at the network level, and these
patterns are different from benign hosts. To ﬁnd similar pat-
terns between bots, BotMiner clusters botnet activity in two
dimensions (C-plane and A-plane). The C-plane clustering
approach is used to detect hosts that resemble each other in
terms of (packets per second) and bps (bytes per second).
The A-plane clustering identiﬁes hosts that produce similar
network anomalies. In this implementation, we use the scan
detector module to ﬁnd network anomalies. Finally, if we
ﬁnd two clusters, we perform co-clustering to ﬁnd common
hosts that exist in both dimensions and label them as bots.
BotMiner was implemented in 312 lines of python code and
40 lines of FRESCO script (the script for BotMiner is pre-
sented in Figure 13).
3. FRESCO P2P Plotter Service. We have implemented
a FRESCO-based P2P malware detection service, simi-
larly implemented to capture the concept of the algorithm,
but simpliﬁed for the purpose of readability. Motivated
by Yen’s work [43], we have implemented the P2P mal-
ware detection algorithm, referred to as P2P Plotter, using
FRESCO. The P2P Plotter asserts that P2P malware has two
interesting characteristics, which are quite different from
normal P2P client programs. First, P2P malware usually
operates at lower volumes of network ﬂow interactions than
what is typically observed in benign P2P protocols. Second,
P2P malware typically interacts with a peer population that
has a lower churn rate (i.e., the connection duration time

1 blacklist_check (1)(1){
2
3

type:TableLookup
event:TCP_CONNECTION_FAIL,

TCP_CONNECTION_SUCCESS

input:source_IP
output:blacklist_out
parameter:-
action:-

4
5
6
7
8 }

1 table_check (1)(2){
2
3

type:TableLookup
event:TCP_CONNECTION_FAIL,

TCP_CONNECTION_SUCCESS

input:source_IP
output:table_out,source_IP
parameter:-
action:-

4
5
6
7
8 }

type:CrossCluster
event:PUSH
input:a_cls_out,c_cls_out
output:cross_out,ip_list
parameter:-
action:-

1 cr_cluster (2)(2){
2
3
4
5
6
7
8 }
-

1 find_scan (1)(1){
2
3
4
5
6
7

type:ScanDetector
event:PUSH
input:blacklist_out
output:scan_out
parameter:-
action:blacklist_out == 1

?DROP

8 }

Figure 11. FRESCO script for Scan Detector

type:A-PlaneCluster
event:PUSH
input:table_out,source_IP
output:a_cls_out
parameter:-
action:-

1 a_cluster (2)(1){
2
3
4
5
6
7
8 }
-

1 do_action (2)(0){
2
3
4
5
6
7

type:ActionHandler
event:PUSH
input:cross_out,ip_list
output:-
parameter:-
action:cross_out == 1

?DROP(ip_list):FORWARD

8 }

1 do_action (1)(0){
2
3
4
5
6
7

type:ActionHandler
event:PUSH
input:scan_out
output:-
parameter:-
action:scan_out == 1

?REDIRECT:FORWARD

8 }

1 c_cluster (0)(1){
2
3

type:C-PlaneCluster
event:TCP_CONNECTION_FAIL,

TCP_CONNECTION_SUCCESS

input:-
output:c_cls_out
parameter:-
action:-

4
5
6
7
8 }

Figure 13. FRESCO scripts illustrating composition of the BotMiner service

of P2P plotters is longer than that of normal P2P clients).
The algorithm operates by performing co-clustering, to ﬁnd
common hosts that exhibit both characteristics (i.e., low
volume and low churn rate).

Figure 14. FRESCO composition of the P2P
Plotter

We have implemented this essential functionality of the
P2P Plotter algorithm as a 4-module FRESCO script, which
is shown in Figure 14. This involved 227 lines of Python
code and 32 lines of FRESCO script. The script for the
P2P Plotter is illustrated in Figure 15. The reuse of mod-
ules (i.e., CrossCluster and ActionHandler, from
the BotMiner service implementation is noteworthy, high-
lighting the reuse potential of FRESCO modules.

8.2 Comparing FRESCO Applications with Non-

FRESCO Detectors

Network anomaly detection approaches, e.g., TRW [16],
have been well-studied and are commonly used as a com-
plement to signature-based detection systems in traditional
networks. While these approaches may be instantiated as
software programs or in hardware devices, the common
practice is to implement them as stand-alone software pro-
grams. (We envision that the FRESCO development envi-
ronment may be similarly used for rapid prototyping and
evaluation of certain anomaly detection algorithms in Open-
Flow networks.)

To highlight the advantages of FRESCO, we ﬁrst choose
an open-source network anomaly detection system and then
replicate identical functionality using FRESCO. Specif-
ically, we compare FRESCO with a recently published
work [24], where the authors implemented popular network
anomaly detection algorithms such as TRW-CB [34] and
Rate Limit [39] as applications running on an OpenFlow
network controller. We re-implement the same algorithms
(i.e., TRW-CB and Rate Limit) using existing FRESCO
modules and the FRESCO scripting language. We provide
a comparison in Table 2, in terms of the number of lines
of source code, to demonstrate the utility of the FRESCO
development environment.

As summarized in Table 2, prior work [24] makes
the case that its OpenFlow application implementation is
slightly simpler than the standard implementation (i.e., the
source code for the OpenFlow implementation is roughly
70% to 80% the length of the standard implementation).
Using FRESCO, we are able to realize similar functional-
ity with an order of magnitude fewer lines of code. That is,
we have implemented the identical TRW-CB function with

1 low_volume_peer (0)(1){
2
3
4
5
6
7
8 }

type:VolumeDetector
event:INCOMING_FLOW
input:-
output:volume_out
parameter:-
action:-

1 cr_cluster (2)(2){
2
3
4
5
6
7
8 }

type:CrossCluster
event:PUSH
input:volume_out,churn_out
output:cross_out,ip_list
parameter:-
action:-

1 low_churn_peer (0)(1){
2
3
4
5
6
7
8 }

type:ChurnDetector
event:INCOMING_FLOW
input:-
output:churn_out
parameter:-
action:-

1 do_action (2)(0){
2
3
4
5
6
7
8 }

type:ActionHandler
event:PUSH
input:cross_out,ip_list
output:-
parameter:-
action:cross_out == 1 ? DROP(ip_list):FORWARD

Figure 15. FRESCO scripts illustrating composition of the P2P Plotter

66 lines of code (58 lines of Python and 8 lines of FRESCO
script) and the rate limiting function with 69 lines of code
(61 lines of Python and 8 lines of FRESCO script). These
two examples represent 6% to 7% of the length of their stan-
dard implementations, and less than 9% of the recently pub-
lished OpenFlow implementation.

Algorithms
TRW-CB
Rate Limit

Standard
1,060
991

Implementation

OpenFlow application
741
814

FRESCO
66 (58 + 8)
69 (61 + 8)

Table 2. Source code length for standard,
OpenFlow and FRESCO implementations of
the TRW-CB and Rate Limit anomaly detec-
tion algorithms

Resource Controller Overhead. The resource controller
component monitors switch status frequently and removes
old ﬂow rules to reclaim space for new ﬂow rules, which
will be enforced by FRESCO applications. This job is per-
formed by FRESCO’s garbage collector, a subcomponent of
the resource controller, which we test under the following
scenario. First, we let non-FRESCO applications enforce
4,000 ﬂow rules to an OpenFlow network switch. In this
case, we assume that the maximum size of the ﬂow table
in the switch is 4,000, and we set the threshold value(θ) for
garbage collection as 0.75 (i.e., if the capacity of a ﬂow
table in a switch is ≤ 75%, we run the garbage collec-
tor). Our test results, shown in Figure 16, demonstrate that
the garbage collector correctly implements its ﬂow eviction
policy.

8.3 Measuring and Evaluating FRESCO Overhead
FRESCO Application Layer Overhead. We compare the
ﬂow setup time of NOX ﬂow generation with ﬁve other
FRESCO applications and summarize the results in Table
3. To measure this, we capture packets between NOX and
the OpenFlow switch, and measure the round trip required
to submit the ﬂow and receive a corresponding ﬂow con-
straint. We observe that FRESCO applications require ad-
ditional setup time in the range of 0.5 milliseconds to 10.9
milliseconds.2

NOX

0.823

Simple
Flow
Tracker
1.374

Simple
Scan
Detector
2.461

Threshold
Scan
Detector
7.196

BotMiner
Detector

P2P
Plotter

15.421

11.775

Time
(ms)

Table 3. Flow setup time comparison of NOX
with ﬁve FRESCO applications

2These setup times were measured on mininet, which is an emulated
environment running on a virtual machine. If we use a more powerful host
for the controller, which is the common case in an OpenFlow network, this
setup time will be reduced signiﬁcantly.

Figure 16. Operation of FRESCO garbage collec-
tor

9 Related Work

The OpenFlow standard has as its roots on a rich body
of work on control-ﬂow separation and clean-slate design
of the Internet (e.g., [6], [10]). SANE [7] and Ethane [6]
propose new architectures for securing enterprise networks.
The SANE [7] protection layer proposes a fork-lift (clean-
slate) approach for upgrading enterprise network security
that introduces a centralized server, i.e., domain controller,
to authenticate all elements in the network and grant access

to services in the form of capabilities that are enforced at
each switch. Ethane [6] is a more practical and backwards-
compatible instantiation of SANE that requires no modiﬁ-
cation to end hosts. Both studies may be considered as cat-
alysts for the emergence of OpenFlow and software-deﬁned
networking.

FRESCO is built over the foundations laid by these
studies and shares a common objective with these systems
in that it seeks to improve enterprise security using pro-
grammable network elements. However, FRESCO empha-
sizes composable security, and applications that it enables
are much more sophisticated than simple access control
policies. In addition, the FRESCO SEK focuses on provid-
ing continued enforcement of potentially conﬂicting ﬂow
constraints imposed by FRESCO and other OF applications.
Thus, we consider our work as greatly complementary to
existing studies such as SANE and Ethane.

FRESCO’s focus is on the development of a holistic plat-
form for specifying and developing OF security applica-
tions and enforcement of security constraints generated by
these applications. Prior work has addressed a part of this
problem, i.e., development of new languages for specifying
security policies. Nettle [40] is a new language for man-
aging OF switches that is based on functional reactive pro-
gramming. Frenetic [9] and Procera [41] provide declar-
ative query language frameworks for managing distributed
OF switches, describing high-level packet-forwarding and
specifying network policies. The OpenSAFE system pro-
vides a language framework for enabling redirection of traf-
ﬁc to network monitoring devices [3]. In contrast to these
languages, the FRESCO development environment is spe-
cialized to serve the needs of security applications. Speciﬁ-
cally, FRESCO applications issue high-level security direc-
tives (e.g., REDIRECT, QUARANTINE, MIRROR), which are
then translated into OF-speciﬁc commands by the script-to-
In addition, FRESCO applications re-
module translator.
quire aggregate session and ﬂow state information as well
as directives for asynchronous delivery of switch state in-
formation that is unavailable in standard OF environments.
Applications such as Random Host Mutation [14] are ad-
ditional motivating examples of candidate OF security ap-
plications whose development may be accelerated using
FRESCO.

The FRESCO security enforcement kernel is informed
by prior research focused on testing or verifying ﬁrewall
and network device conﬁguration [36, 8, 21, 22, 2, 42, 1],
e.g., using Firewall Decision Diagrams (FDDs) [21] or test
case generators [36, 8]. These studies do not deal with dy-
namic networks. More recently, header space analysis was
proposed, which is a generic framework to express vari-
ous network misconﬁgurations and policy violations [17].
While HSA can in theory deal with dynamic networks, the
FRESCO SEK differs in that it is specialized to deal with
speciﬁc policy violations by OF applications, rule conﬂict
detection, and dynamic ﬂow tunneling. Veriﬂow proposes

to slice the OF network into equivalence classes to efﬁ-
ciently check for invariant property violations [18]. The
alias set rule reduction algorithm used by FRESCO SEK
is complementary to this approach.

We build our system on NOX, which is an open-source
OF controller [13]. However, our methodology could be ex-
tended to other architectures like Beacon [30], Maestro [4],
and DevoFlow [26]. FlowVisor is a platform-independent
OF controller that uses network slicing to separate logical
network planes, allowing multiple researchers to run ex-
periments safely and independently in the same production
OpenFlow network [37]. Our work differs from FlowVi-
sor in several ways. First, FlowVisor cares primarily about
non-interference across different logical planes (slices) but
does not instantiate network security constraints within a
slice. It is possible that an OF application uses packet mod-
iﬁcation functions resulting in ﬂow rules that are applied
across multiple network switches within the same slice. In
such cases, we need a security enforcement kernel to re-
solve conﬂicts as described in Section 5. Second, although
FlowVisor improves security by separating the OF network
into logical planes, it does not provide analogous capabil-
ities to FRESCO for building additional security applica-
tions.

The need for better policy validation and enforcement
mechanisms has been touched on by prior and concurrent
research efforts. NICE provides a model-checking frame-
work that uses symbolic execution for automating the test-
ing of OpenFlow applications [5]. The Resonance archi-
tecture enables dynamic access control and monitoring in
SDN environments [27]. The FlowChecker system en-
codes OpenFlow ﬂow tables into Binary Decision Diagrams
(BDD) and uses model checking [1] to verify security prop-
erties. However, the evaluation of FlowChecker does not
consider handling of set action commands, which we con-
sider to be a signiﬁcant distinguisher for OpenFlow net-
works. More recently, researchers have proposed develop-
ing language abstractions to guarantee consistency of ﬂow
updates in software-deﬁned networks [32]. In contrast, our
complementary work on the FRESCO security enforcement
kernel is focused on detection of rule update conﬂicts and
security policy violations. The Onix platform [20] pro-
vides a generalized API for managing a distributed control
plane in Software Deﬁned Networks. The techniques and
the strategies developed in Onix for managing a distributed
network information base are complementary and can be
integrated into FRESCO.
10 Conclusion

Despite the success of OpenFlow, developing and de-
ploying complex OF security services remains a signiﬁcant
challenge. We present FRESCO, a new application develop-
ment framework speciﬁcally designed to address this prob-
lem. We introduce the FRESCO architecture and its integra-
tion with the NOX OpenFlow controller, and present sev-

eral illustrative security applications written in the FRESCO
scripting language. To empower FRESCO applications
with the ability to produce enforceable ﬂow constraints that
can defend the network as threats are detected, we present
the FRESCO security enforcement kernel. Our evalua-
tions demonstrate that FRESCO introduces minimal over-
head and that it enables rapid creation of popular security
functions with signiﬁcantly (over 90%) fewer lines of code.
We believe that FRESCO offers a powerful new framework
for prototyping and delivering innovative security applica-
tions into the rapidly evolving world of software-deﬁned
networks. We plan to release all developed code as open
source software to the SDN community.

11 Acknowledements

This material is based in part upon work supported
by the Defense Advanced Research Projects Agency
(DARPA) and the United States Air Force under Contract
No. FA8750-11-C-0249, the Army Research Ofﬁce under
Cyber-TA Grant no. W911NF-06-1-0316, and the National
Science Foundation under Grant no. CNS-0954096. All
opinions, ﬁndings and conclusions or recommendations ex-
pressed herein are those of the author(s) and do not neces-
sarily reﬂect the views of the U.S. Air Force, DARPA, U.S.
Army Research Ofﬁce, or the National Science Foundation.
It is approved for Public Release, Distribution Unlimited.

References
[1] E. Al-Shaer and S. Al-Haj. FlowChecker: Conﬁguration
Analysis and Veriﬁcation of Federated Openﬂow Infrastruc-
tures. In Proceedings of the 3rd ACM Workshop on Assur-
able and Usable Security Conﬁguration, SafeConﬁg, pages
37–44, New York, NY, USA, 2010. ACM.

[2] E. Al-shaer, W. Marrero, A. El-atawy, and K. Elbadawi. Net-
work Conﬁguration in A Box: Towards End-to-End Ver-
In The
iﬁcation of Network Reachability and Security.
17th IEEE International Conference on Network Protocols
(ICNP), 2009.

[3] J. R. Ballard, I. Rae, and A. Akella. Extensible and Scal-
able Network Monitoring Using OpenSAFE. In INM/WREN,
2010.

[4] Z. Cai, A. L. Cox, and T. E. Ng. Maestro: A System for
In Rice University Technical

Scalable OpenFlow Control.
Report, 2010.

[5] M. Canini, D. Venzano, P. Peresini, D. Kostic, and J. Rex-
ford. A NICE Way to Test OpenFlow Applications. In Pro-
ceedings of NSDI, 2012.

[6] M. Casado, M. J. Freedman, J. Pettit, J. Luo, N. McKeown,
and S. Shenker. Ethane: Taking Control of the Enterprise. In
Proceedings of ACM SIGCOMM, 2007.

[7] M. Casado, T. Garﬁnkel, M. Freedman, A. Akella, D. Boneh,
N. McKeowon, and S. Shenker. SANE: A Protection Ar-
chitecture for Enterprise Networks. In Proceedings Usenix
Security Symposium, August 2006.

[8] A. El-atawy, T. Samak, Z. Wali, E. Al-shaer, F. Lin, C. Pham,
and S. Li. An Automated Framework for Validating Firewall

Policy Enforcement. Technical report, De-Paul University,
2007.

[9] N. Foster, R. Harrison, M. Freedman, C. Monsanto, J. Rex-
ford, A. Story, and D. Walker. Frenetic: A Network Program-
ming Language. In ACM SIGPLAN Inernational Conference
on Functional Programming, 2011.

[10] A. Greenberg, G. Hjalmtysson, D. A. Maltz, A. Myers,
J. Rexford, G. Xie, H. Yan, J. Zhan, and H. Zhang. A Clean
Slate 4D Approach to Network Control and Management.
In Proceedings of ACM Computer Communications Review,
2005.

[11] G. Gu, R. Perdisci, J. Zhang, and W. Lee. BotMiner: Cluster-
ing Analysis of Network Trafﬁc for Protocol- and Structure-
Independent Botnet Detection. In Proceedings of USENIX
Security Symposium (Security’08), 2008.

[12] G. Gu, P. Porras, V. Yegneswaran, M. Fong, and W. Lee.
BotHunter: Detecting malware infection through ids-driven
dialog correlation. In Proceedings of the 16th USENIX Se-
curity Symposium (Security’07), August 2007.

[13] N. Gude, T. Koponen, J. Pettit, B. Pfaff, M. Casado, N. McK-
eown, and S. Shenker. NOX: Towards an Operating System
for Networks. In Proceedings of ACM SIGCOMM Computer
Communication Review, July 2008.

[14] J. H. Jafarian, E. Al-Shaer, and Q. Duan. OpenFlow Random
Host Mutation: Transparent Moving Target Defense using
Software-Deﬁned Networking. In Proceedings of ACM Sig-
comm HotSDN Workshop, 2012.

[15] J. Jung, R. Milito, and V. Paxson. On the Adaptive Real-time
Detection of Fast Propagating Network Worms. In Proceed-
ings of Conference on Detection of Intrusions and Malware
and Vulnerability Assessment (DIMVA), 2007.

[16] J. Jung, V. Paxson, A. Berger, and H. Balakrishnan. Fast
Portscan Detection Using Sequential Hypothesis Testing. In
Proceedings of IEEE Symposium on Security and Privacy,
2004.

[17] P. Kazemian, G. Varghese, and N. McKeown. Header Space
Analysis: Static Checking for Networks. In Proceedings of
NSDI, 2012.

[18] A. Khurshid, W. Zhou, M. Caesar, and P. B. Godfrey. Veri-
Flow: Verifying Network-Wide Invariants in Real Time. In
Proceedings of ACM Sigcomm HotSDN Workshop, 2012.

[19] E. Kohler, R. Morris, B. Chen, J. Jannotti, and F. Kaashoek.
The Click Modular Router. ACM Transactions on Computer
Systems, August 2000.

[20] T. Koponen, M. Casado, N. Gude, J. Stribling, L. Poutievski,
M. Zhu, R. Ramanathan, Y. Iwata, H. Inoue, T. Hama, and
S. Shenker. Onix: A Distributed Control Platform for Large-
scale Production Networks. In The Symposium on Operating
Systems Design and Implementation (NSDI), 2010.

[21] A. Liu. Formal Veriﬁcation of Firewall Policies. In Proceed-
ings of the 2008 IEEE International Conference on Commu-
nications (ICC), Beijing,China, May 2008.

[22] A. Liu and M. Gouda. Diverse Firewall Design. IEEE Trans-
actions on Parallel and Distributed Systems (TPDS), 19(8),
2008.

[23] N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar,
L. Peterson, J. Rexford, S. Shenker, and J. Turner. Open-
In Pro-
Flow: Enabling Innovation in Campus Networks.
ceedings of ACM SIGCOMM Computer Communication Re-
view, April 2008.

[24] S. A. Mehdi, J. Khalid, and S. A. Khayam. Revisiting Traf-
ﬁc Anomaly Detection Using Software Deﬁned Networking.
In Proceedings of Recent Advances in Intrusion Detection,
2011.

[25] Mininet. Rapid Prototyping for Software Deﬁned Net-
http://yuba.stanford.edu/foswiki/

works.
bin/view/OpenFlow/Mininet/.

[26] J. C. Mogul, J. Tourrilhes, P. Yalagandula, P. Sharma, A. R.
Curtis, and S. Banerjee. DevoFlow: Cost-effective Flow
Management for High Performance Enterprise Networks. In
Proceedings of the Ninth ACM SIGCOMM Workshop on Hot
Topics in Networks, 2010.

[27] A. Nayak, A. Reimers, N. Feamster, and R. Clark. Reso-
nance: Dynamic Access Control for Enterprise Networks. In
Proceedings of WREN, 2009.

[28] NMAP.ORG. Nmap: Open Source Network Discovery and

Auditing Tool. http://nmap.org.

[29] OpenFlow. OpenFlow 1.1.0 Speciﬁcation. http://www.
openflow.org/documents/openflow-spec-v1.
1.0.pdf.

[30] OpenFlowHub.

BEACON.

http://www.

openflowhub.org/display/Beacon.

[31] P. Porras, S. Shin, V. Yegneswaran, M. Fong, M. Tyson, and
G. Gu. A Security Enforcement Kernel for OpenFlow Net-
works. In Proceedings ACM SIGCOMM Workshops on Hot
Topics in Software Deﬁned Networking (HotSDN), August
2012.

[32] M. Reitblatt, N. Foster, J. Rexford, and D. Walker. Consistent
Update for Software-Deﬁned Networks: Change You Can
Believe In! In Under Submission, 2011.

[33] RFC4765. The intrusion detection message exchange format
http://www.ietf.org/rfc/rfc4765.

(idmef).
txt.

[34] S. Schechter, J. Jung, and A. Berger. Accuracy Improv-
ing Guidelines for Network Anomaly Detection Systems.
In Proceedings of International Symposium on Recent Ad-
vances Intrusion Detection.

[35] V. Sekar, Y. Xie, M. Reiter, and H. Zhang. A Multi-
Resolution Approach for Worm Detection and Containment.
In Proceedings of International Conference on Dependable
Systems and Networks (DSN), June 2006.

[36] D. Senn, D. Basin, and G. Caronni. Firewall Conformance
Testing. In The 17th IFIP International Conference on Test-
ing of Communicating Systems (TestCom), pages 226–241,
2005.

[37] R. Sherwood, G. Gibb, K.-K. Yap, G. Appenzeller,
M. Casado, N. McKeown, and G. Parulkar. Can the Produc-
tion Network Be the Testbed. In Proceedings of Operating
System Design and Implementation, 2010.

[38] Snort. http://snort.org.
[39] J. Twycross and M. M. Williamson. Implementing and test-
ing a virus throttle. In Proceedings of the USENIX Security
Symposium, 2003.

[40] A. Voellmy and P. Hudak. Nettle: Functional Reactive Pro-
gramming of OpenFlow Networks. In Yale University Tech-
nical Report, 2010.

[41] A. Voellmy, H. Kim, and N. Feamster. Procera: A Language
for High-Level Reactive Network Control. In Proceedings of
ACM Sigcomm HotSDN Workshop, 2012.

[42] G. Xie, J. Zhan, D. Maltz, H. Zhang, A. Greenberg,

G. Hjalmtysson, and J. Rexford. On Static Reachabil-
In The 24th IEEE Interna-
ity Analysis of IP Networks.
tional Conference on Computer Communications (INFO-
COM), pages 2170–2183, 2005.

[43] T.-F. Yen and M. K. Reiter. Are Your Hosts Trading or Plot-
ting? Telling P2P File-sharing and Bots Apart. In Proceed-
ings of IEEE ICDCS, 2010.

A Appendix
A.1 FRESCO Security Enforcement Kernel

It is possible that the ﬂow rules created by non-security-
related OF applications conﬂict with the ﬂow constraints
distributed by FRESCO applications. A conﬂict arises when
one or more ﬂow rules would allow a ﬂow from one end
point to another that is speciﬁcally prohibited by a ﬂow con-
straint rule produced by a FRESCO application. To manage
FRESCO ﬂow constraints and perform conﬂict evaluation,
we introduce the FRESCO SEK as an embedded NOX ex-
tension.

Two main components of OpenFlow rules are match con-
ditions and actions. The former speciﬁes packet header
ﬁelds that must match for the rule’s associated actions to
trigger. The FRESCO SEK maintains the set of active
constraint rules produced by registered FRESCO modules.
Constraint rules inserted into the FRESCO SEK security
constraints table are considered active, and must be ex-
plicitly deactivated by a registered FRESCO module. Be-
cause non-FRESCO applications can publish ﬂow rules that
potentially violate FRESCO’s network security policy, The
FRESCO SEK employs two protection mechanisms to pre-
vent such violations. The ﬁrst mechanism is rule prioriti-
zation, in which ﬂow rules produced by FRESCO applica-
tions are published to the switch using the highest rule prior-
ity. This immediately overrides any active ﬂow rules in the
switch’s ﬂow table that may contradict FRESCO’s security
policy. Second, the FRESCO SEK applies a conﬂict detec-
tion algorithm between each new ﬂow rule and the security
constraints table, rejecting the new ﬂow rule if a conﬂict
is detected. Conﬂict detection is performed in two passes:
alias set rule reduction, and then rule set conﬂict evaluation.
A conﬂict can also happen between security constraints
enforced by different FRESCO applications. In this case,
the FRESCO SEK can still detect conﬂicts but it needs to
determine which constraint should be enforced. By default,
FRESCO SEK keeps the ﬁrst enforced constraint (i.e., ig-
nore following conﬂicted constraint), but it is easy to be
conﬁgured by the administrators to apply other approaches
(e.g., keep the last enforced constraint, or based on some
priority settings).

A.1.1 Alias Set Rule Reduction
To detect conﬂicts between a candidate rule set and
FRESCO’s constraint rule sets, the source and destination

As a practical consideration, because OpenFlow rules
permit both wildcard ﬁeld matches and IP address network
masks, determining alias set intersection involves more than
simple membership equality checks. To accommodate this,
we deﬁne comparison operators that determine if a ﬁeld
speciﬁcation is (i) more encompassing (“wider”), (ii) more
speciﬁc (“narrower”), (iii) equal, or (iv) unequal. Thus, an
intersection occurs when the pairwise comparisons between
all ﬁelds of a candidate rule are wider than, equal to, or nar-
rower than that of the corresponding ﬁelds of the constraint
table rule.

For a formalization of the above, we ﬁrst deﬁne some
terms: (i) Si is the ith entry of security constraints, (ii) Fi
is the ith entry of ﬂow rules, (iii) SCi,j is the jth item of
the ith entry of the condition part of the security constraint,
(iv) SAi is the ith entry of the action part of the security
constraint, (v) F Ci,j is the jth item of the ith condition
part of a ﬂow rule from non-FRESCO applications, and (vi)
F Ai is the ith action part of the ﬂow rule. At this time,
both SCi,j and F Ci,j are sets whose elements are one of
the speciﬁc value or some ranges and j ∈ {1, 2, ..., 14}.
Rule contradiction is then formalized using the following
notation:

if there is any Si, satisfying SCi,j ∩ F Ci,j (cid:54)= (cid:11) and
SAi (cid:54)= F Ai, for all j, thenFi is conﬂicted with Si

(6)
Finally, upon an update to the security constraints ta-
ble, rule set conﬂict resolution is performed against all ﬂow
rules currently active within the switch. If a conﬂict is de-
tected in which the switch rule is found to be wider than the
FRESCO rule, SEK initiates a request to the switch to ﬂush
the resident rule.

(1)

(2)

(3)

(4)

(5)

IP addresses, their ports, and wild card members 3 for each
rule in a rule set are used to derive rules with alias sets
representing IP addresses and ports. The initial alias sets
contain the ﬁrst rule’s IP addresses, network masks, and
ports (where 0 [zero] represents any port). If the rule’s ac-
tion causes a ﬁeld substitution via a set action, the resultant
value is added to the appropriate alias set. These sets are
then compared to the next rule’s alias sets. If there is an
intersection between both the source and address sets, the
union of the respective sets is used as the subsequent rule’s
alias sets. For example, given the FRESCO rule,

a → b drop packet

its source alias set is (a), while its destination alias set is (b).
The derived rule is

(a) → (b) drop packet
For the candidate (evasion) rule set,
1 a → c set (a ⇒ a’)
2 a’ → c set (c ⇒ b)
3 a’ → b forward packet

the intermediate alias sets are
1 a → c set (a ⇒ a’)
2 a’ → c set (c ⇒ b)
3 a’ → b forward packet (a, a’) (c, b) forward packet

(a, a’) (c)
(a, a’) (c, b)

and the derived rule is

(a, a’) ⇒ (c, b) forward packet

A.1.2 Rule Set Conﬂict Evaluation
The FRESCO SEK ﬁrst performs alias set rule reduction
on the candidate rule set. These validity checks are then
performed between each derived FRESCO constraint rule
cRule and each derived ﬂow rule fRule, as follows:

1. Skip any cRule/fRule pair with mismatched proto-

types.

2. Skip any cRule/fRule pair whose actions are both ei-

ther forward or drop packet.

3. If cRule’s alias sets intersect those of fRule’s, declare

a conﬂict.

Thus, given the example security constraint table in
Equation 2 and the candidate rule set in Equation 5, assum-
ing that both rules are TCP protocol, the ﬁrst candidate rule
passes the ﬁrst two checks. However, for the third check,
because the intersection of the source and destination alias
sets results in (a) and (b), respectively, the candidate rule is
declared to be in conﬂict.

3For OpenFlow 1.1, the examined members include the source and des-
tination network mask ﬁelds (for OpenFlow 1.0 these are implicitly deﬁned
by the wildcard ﬁeld).

