Vigilare: Toward Snoop-based Kernel Integrity Monitor

Hyungon Moon

Seoul National University
hgmoon@sor.snu.ac.kr

Kihwan Kim

Korea Advanced Institute of

Science and Technology
kimgun@kaist.ac.kr

Hojoon Lee

Korea Advanced Institute of

Science and Technology
hjlee228@kaist.ac.kr

Yunheung Paek

Seoul National University

ypaek@snu.ac.kr

Jihoon Lee

Seoul National University
jhlee@sor.snu.ac.kr

∗

Brent Byunghoon Kang
George Mason University
bkang5@gmu.edu

ABSTRACT
In this paper, we present Vigilare system, a kernel integrity
monitor that is architected to snoop the bus traﬃc of the
host system from a separate independent hardware. This
snoop-based monitoring enabled by the Vigilare system, over-
comes the limitations of the snapshot-based monitoring em-
ployed in previous kernel integrity monitoring solutions. Be-
ing based on inspecting snapshots collected over a certain
interval, the previous hardware-based monitoring solutions
cannot detect transient attacks that can occur in between
snapshots. We implemented a prototype of the Vigilare
system on Gaisler’s grlib-based system-on-a-chip (SoC) by
adding Snooper hardware connections module to the host
system for bus snooping. To evaluate the beneﬁt of snoop-
based monitoring, we also implemented similar SoC with
a snapshot-based monitor to be compared with. The Vigi-
lare system detected all the transient attacks without perfor-
mance degradation while the snapshot-based monitor could
not detect all the attacks and induced considerable perfor-
mance degradation as much as 10% in our tuned STREAM
benchmark test.

Categories and Subject Descriptors
D.2.6 [Operating Systems]: Security and Protection—in-
vasive software

General Terms
Security

Keywords
Transient Attack, Hardware-based Integrity Monitor, Ker-
nel Integrity Monitor

∗Corresponding author

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

1.

INTRODUCTION

To protect the integrity of operating system kernels, many
security researchers strive to make their security monitors
independent from the host system that is being monitored.
Recent eﬀorts on this kernel integrity monitoring can be cat-
egorized into two groups: hardware based approaches [20,
30] and hypervisor based approaches [14, 24]. Recently, ap-
proaches based on hypervisors have gained popularity. How-
ever, as hypervisors are becoming more and more complex,
hypervisors themselves are exposed to numerous software
vulnerabilities [1, 2, 3, 4]. Several approaches [7, 28] noted
that inserting an additional software layer to protect the in-
tegrity of hypervisors may not be suﬃcient. The additional
layer will introduce new sets of vulnerabilities in a similar
fashion of the hypervisors; inserting another padding with a
software layer for security may enhance security temporarily,
but it does not provide a fundamental solution. As a solu-
tion for this, they introduced hardware-supported schemes
to monitor the integrity of hypervisors.

Most of the existing solutions to kernel integrity monitor-
ing make use of snapshot analysis schemes; they are usually
assisted by some type of hardware component that enables
saving of the memory contents into a snapshot, and then per-
form an analysis to ﬁnd the traces of a rootkit attack. Hy-
perSentry [7], Copilot [20], and HyperCheck [28] are exem-
plary approaches on snapshot-based kernel integrity moni-
toring. A custom Peripheral Component Interconnect (PCI)
card to create snapshots of the memory via Direct Mem-
ory Access (DMA) in Copilot, and the System Management
Mode (SMM) [12] are utilized to implement the snapshot-
based kernel integrity monitors in HyperCheck and Hyper-
Sentry.

Snapshot-based monitoring schemes in general have an in-
herent weakness because they only inspect the snapshots col-
lected over a certain interval, missing the evanescent changes
in between the intervals. The term transient attack refers to
attacks which do not leave persistent traces in memory con-
tents, but it still achieves its goal by using only momentary
and transitory manipulations.

Attackers can exploit this critical limitation of snapshot-
based kernel integrity monitoring. If attackers know the ex-
istence of a snapshot-based integrity monitor and estimate
the time and the interval of snapshot-taking, they could de-
vise a stealthy malware that subverts the kernel only in be-
tween the snapshots and restores all modiﬁcation back to
normal by the time of the next snapshot interval. This is

28called as scrubbing attack, and HyperSentry [7] addressed
this by making it impossible for the attackers to predict
when the snapshots will be taken. However, attackers can
still create a transient attack that leaves its traces as min-
imal as possible without knowing exact time that snapshot
is taken.
If the traces are left in the memory for a short
time, there is a chance that it can avoid being captured in
snapshot, and not detected. HyperSentry also noted it was
not designed to address such transient attack.

As to detecting such attacks using snapshot-based ap-
proaches, raising the rate of snapshot-taking might increase
the probability of detection. However, frequent snapshot-
taking would inevitably introduce increased overhead to the
host system. Randomizing the snapshot interval of the mon-
itor can be another solution to defeat such deliberately de-
signed transient attacks. Nonetheless, the detection rate
would greatly depend on luck and not be consistent. If the
transient attack is short-lived, not repeating its transient
attacks, the chance of detection based on random snapshot
interval would be low.

In this paper, we propose Vigilare, a snoop-based integrity
monitoring scheme that overcomes the limitations of exist-
ing kernel integrity monitoring solutions. The Vigilare in-
tegrity monitoring system takes a fundamentally diﬀerent
approach; it monitors the operation of the host system by
“snooping” the bus traﬃc of the host system from a separate
independent system located outside the host system. This
provides the Vigilare system with the capability to observe
all host system activities, and yet being completely inde-
pendent from any potential compromise or attacks in the
host system. This snoop-based architecture enables security
monitoring of virtually all system activities. All processor
instructions and data transfers among I/O devices, mem-
ory, and processor must go through the system’s bus. By
monitoring this critical path, Vigilare system acquires the
capability to observe all activities to locate malicious sys-
tem transactions. This Vigilare system is composed of the
following components. Snooper on the Vigilare system is
connected to the system bus of the main system, and col-
lects the contents of real-time bus traﬃc. Snooper delivers
the accrued bus traﬃc to Veriﬁer. The main functionality of
Veriﬁer is to examine the snooped data to look for a single
or a certain sequence of processor executions that violates
the integrity of the host system.

In summary, this paper’s contribution includes the follow-

ing:

First, we present the design of Vigilare system as a single
SoC (System-on-a-Chip), with Linux as its main operating
system, and our prototype implementation on the Gaisler
grlib-based SoC by adding newly designed Snooper hard-
ware connections module to the host system for bus snoop-
ing. To the best of our knowledge [9], our Vigilare is the ﬁrst
hardware integrity monitor that implements snooping capa-
bility of the bus traﬃc to perform integrity analysis of the
operating system kernel. Although most of the hardware-
based approaches were based on snapshot analysis, there
was an approach that employed event-driven integrity mon-
itoring [24], which has some similarities to the snoop-based
monitoring. However, it was a hypervisor-based approach
which is not a perfectly safe execution environment as we
mentioned.

Second, to illustrate and better understand the beneﬁt
of our snooper-based approach in comparison with previous

snapshot-based approaches, we also implemented a similar
SoC with a snapshot-based monitor, and created a sample
transient attack testing code with tunable parameters for the
experiment testing. The sample attack code takes advantage
of the snapshot-based solutions and we show how Vigilare
eﬀectively deals with the attack.

Third, we then present our comparison evaluation study,
reporting that the Vigilare system detected all the transient
attacks on immutable regions without performance degrada-
tion while the snapshot-based monitor could not detect all
the attacks and induced considerable performance degrada-
tion with an average of 17.5 % for 50ms snapshot interval
in our tuned STREAM benchmark test. This is due to the
performance overhead incurred by the memory access to ac-
quire snapshots periodically, which also consumes memory
bandwidth at the host.
In contrast, the Vigilare system
replicates the bus traﬃc of the host system using dedicated
hardware module, so the snooping can be performed with-
out incurring any memory bandwidth consumption at the
host system.

The rest of this paper is composed of the following: ﬁrst
we describe our assumptions and threat model in Section 2
and deﬁne the transient attack in Section 3. Also, we explain
the Vigilare system in detail in Section 4. We provide more
details about our prototypes in Section 5, and evaluate our
implementations in Section 6. We discuss limitations and
future works in Section 7, related works in Section 8 and
conclude our paper in Section 9.
2. ASSUMPTIONS AND THREAT MODEL
2.1 Assumptions

We assume that the host system is already compromised
by an attacker, that is, the attacker has gained the adminis-
trator’s privilege on the host system. In addition, we assume
that the attacker has no physical access to the entire system
therefore we can rule out the possibility of hardware mod-
iﬁcation. Thus, we are limiting the manipulation by the
attacker in the realm of software; no modiﬁcation should af-
fect the operation of the Vigilare system SoC hardware or
any other hardware components.
2.2 Threat Model

The primary threat that the Vigilare system strives to
mitigate is the kernel-level rootkits. As mentioned previ-
ously, we assume that the attackers have already gained
control over the host system, and continue their attack while
hiding the evidence of their intrusion. To achieve such goals,
they are capable of modifying some parts of kernel. For in-
stance, the attackers can install kernel rootkit that places
hooks on critical system calls. Another assumption is that
the attackers are aware of the presence of some kind of secu-
rity monitor. The attackers aim to avoid detection with the
best of their knowledge. One possible technique is to min-
imize and avoid an obvious and permanent modiﬁcation to
the kernel. By hiding the traces of malware left in the host
memory, the attackers could lower the probability of get-
ting detected. We deﬁne such malicious behavior transient
attacks and the details will be covered in the next section.
3. TRANSIENT ATTACK

As mentioned in previous sections, previous kernel in-
tegrity monitoring schemes that utilize memory snapshots

29to ﬁnd the traces of rootkits are vulnerable to transient at-
tacks. On the other hand, Vigilare solves such shortcomings
with its bus traﬃc monitoring architecture. In this section,
we deﬁne the term transient attack, introduce some exam-
ples of such attacks, and discuss the challenges in detecting
these transient attacks.
3.1 Deﬁnition

Transient attack is an attack whose traces do not incur
persistent changes to the victim’s system. In such scenar-
ios, the evidence of malicious system modiﬁcation is visible
for a short time period.
In turn, detecting the modiﬁca-
tion becomes diﬃcult. The term transient attack is deﬁned
rather broadly; any attack that does not leave permanent
changes can be classiﬁed as transient attacks. The soft-
timer based rootkit technique presented in the work by J.
Wei et al. shows the aspects of transient kernel rootkit [29].
The rootkit designed by J. Wei et al. takes advantage of
Linux timer data structure to convey the malicious code
and execute it at the scheduled time. Since the code that
had been contained in the timer is discarded shortly after its
execution, its trace is not only diﬃcult to locate but it also
stays in the memory for a very short time. The exploitation
of Linux soft-timer is a mere example, more sophisticated
transient attacks that can nullify traditional rootkit detec-
tion solutions are here to stay.
3.2 Our Transient Attack Model

and Examples

As a concrete example that we can test and observe, we
devised a simple rootkit that exhibits transient characteris-
tics. The rootkit acts similar to the traditional Linux kernel
rootkits in the wild.
Inspired by J. Wei et al.’s work, we
implemented the rootkit to repeat modiﬁcation and rever-
sion in a ﬁxed time interval using the Linux timer. Our
example rootkit modiﬁes the system call function pointers
in sys call table to hijack the control ﬂow of the system call.
To be more speciﬁc on Linux system call hooking, the Linux
system call table takes a form of an array of pointers. Each
entry in the table points to a corresponding system call such
as sys read, sys write, and many more. The adversary could
eﬀortlessly hijack these system calls by inserting a function
between the sys call table and the actual system call. The
example rootkit simply performs the old-fashioned system
call hooking, but the timer-triggered operation allows us to
illustrate the transient rootkit characteristics.
3.3 Difﬁculties of Detecting Transient Attacks
In order to successfully detect transient attacks, the de-
tection system needs to operate on an event-triggered mech-
anism; snapshot analysis or other periodic checks are likely
to miss out the events in between the snapshots. Imagine
a snapshot-based integrity monitor was launched to detect
the transient attack model shown in Figure 1. If the author
of the kernel rootkit can properly adjust the duration of the
attack tactive and the time of dormancy tinactive, he could
completely evade the snapshot-based monitors; by staying
dormant at the time of memory snapshot and becoming ac-
tive in between the snapshots, the rootkit can capably fool
the snapshot-based monitor. In the experiment, we designed
our rootkit to have tinactive inﬁnite, in order to measure the
abilities of monitors to detect single pulse of attack.

A possible temporary solution to the limitation of the

Figure 1: This ﬁgure shows the behavior of tran-
sient attack. Transient attack compromises the ker-
nel “transiently” for tactive and remove its trace for
tinactive to avoid being detected. Assuming that
there exist a snapshot-based integrity monitor, it
may detect the second pulse but fail to detect the
ﬁrst one. The transient attack with lower tactive may
have more chance to attack the host system success-
fully

snapshot-based approach would be to increase the rate of
memory snapshot-taking or to randomize the snapshot in-
terval. Frequent memory snapshots will, however, inevitably
impose a high performance overhead on the host system.
Also, random snapshot timings may not properly represent
the system status and will produce either snapshots with
little diﬀerences or snapshots with a long time interval in
between. Therefore, we conclude that snapshot-based in-
tegrity monitors are simply not apt for detection of transient
attacks. That is, an event-triggered solution is essential to
cope with transient kernel attacks.

4. VIGILARE SYSTEM REQUIREMENTS
Vigilare is designed to collect the data stream in the host
system’s memory bus to overcome the limitations of memory-
snapshot inspection. Figure 2 shows high level design of the
Vigilare system. The Vigilare system is mainly composed of
two components: Snooper and Veriﬁer. Snooper is a hard-
ware component which collects the traﬃc and transfers it to
Veriﬁer. Veriﬁer is a compact computer system optimized to
analyze the data in order to determine the integrity of the
host system. In our prototype, Veriﬁer is placed along with
Snooper for simplicity and performance. There are several
requirements that the Vigilare system needs to meet, so that
it does not fail to detect important kernel status changes
that appear in the bus traﬃc. In this section, we describe
these requirements of the Vigilare system.
4.1 Selective Bus-trafﬁc Collection

and Sufﬁcient Computing Power

In the Vigilare system, Veriﬁer analyzes the ﬁltered col-
lection of bus traﬃc that Snooper provides. A bus band-
width that is higher than Vigilare’s computing speed can be
problematic. The AHB (Advanced High-performance Bus)

(cid:3)(cid:8)(cid:7)(cid:9)(cid:10)(cid:8)(cid:7)(cid:6)(cid:11)(cid:5)(cid:4)(cid:12)(cid:8)(cid:10)(cid:7)(cid:13)(cid:14)(cid:3)(cid:5)(cid:6)(cid:4)(cid:9)(cid:16)(cid:10)(cid:16)(cid:4)(cid:7)(cid:14)(cid:11)(cid:7)(cid:8)(cid:4)(cid:15)(cid:13)(cid:4)(cid:12)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:5)(cid:8)(cid:5)(cid:9)(cid:5)(cid:10)(cid:3)(cid:8)(cid:5)(cid:11)(cid:5)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:5)(cid:8)(cid:5)(cid:9)(cid:5)(cid:10)(cid:5)(cid:12)(cid:13)(cid:5)(cid:14)(cid:5)(cid:11)(cid:5)(cid:8)(cid:5)(cid:7)(cid:5)(cid:14)(cid:5)(cid:15)(cid:5)(cid:5)(cid:9)(cid:10)(cid:3)(cid:4)(cid:8)(cid:10)(cid:8)(cid:6)(cid:10)(cid:8)(cid:7)(cid:4)(cid:8)(cid:10)(cid:8)(cid:6)(cid:10)(cid:8)(cid:7)30traﬃc so that the Veriﬁer can avoid the handling of unre-
lated bursty traﬃc.
4.3 Integrity of the Vigilare System

Hardware-based integrity monitor has its advantage in the
independence from the host system. Since it does not rely
on the core functionalities of the host system kernel, the in-
tegrity of the host system does not aﬀect the integrity of
the Vigilare system. To further augment this strength of
Vigilare, the memory interface of the Vigilare system and
interrupt handling of Veriﬁer were designed with considera-
tions for independence.

The memory of the Vigilare system contains all the pro-
grams and data used by the Vigilare system. The host sys-
tem must not be able to access this memory in any way.
There are two possible ways of meeting this requirement.
The use of separate memory for the Vigilare system is the
ﬁrst option. By using a separate memory and memory con-
troller inaccessible from the host system, the Vigilare mem-
ory becomes physically tamper-free. The second option is
to implement a memory region controller which speciﬁcally
drops all memory operation requests from the host system.
The second option may reduce the cost of hardware imple-
mentation compared to that of building a completely sepa-
rate memory for Vigilare.

The interrupt handling in Veriﬁer can be a factor that
undermines the independence from the host system. Thus,
any circumstances that might trigger interrupts to Veriﬁer
should be carefully designed. More speciﬁcally, the periph-
erals controlled by host system should have no or limited
ways of introducing interrupts to the Vigilare system.

5. PROTOTYPE DESIGN

In this section, we describe our prototypes that we used
for evaluating snoop-based monitoring. We designed and im-
plemented two SoC prototypes: SnoopMon and SnapMon.
Each SoC consists of a host system and an integrity moni-
tor. SnapMon is an example of a snapshot-based monitor,
and SnoopMon, which is a prototype of the Vigilare system,
exhibits a snoop-based integrity monitoring scheme. Each
monitor investigates the integrity of immutable regions of
the Linux kernel. We ﬁrst explain the host system and the
immutable regions of Linux kernel as background informa-
tion, and then we describe the details of SnoopMon and
SnapMon designs.
5.1 Host System

We used the Leon3 processor as a host system’s main pro-
cessor which is a 32-bit processor [5] based on SPARC V8
architecture [27] provided by Gaisler. It is designed for em-
bedded software with low complexity and low power con-
sumption. The Leon3 processor has seven stage pipeline
with Harvard architecture and runs at 50MHz in our pro-
totype SoC. It has 16KB instruction cache and 16KB data
cache. The system uses 64MB SDRAM as a main mem-
ory and has some peripherals for debugging.
It runs the
Snapgear Linux [15] which is an embedded Linux customized
for the processor and runs kernel version of 2.6.21.1. We
monitored the integrity of the Linux kernel with two mon-
itors: SnoopMon and SnapMon. We provide more details
about the speciﬁc target of monitoring and discuss an issue
related to the use of virtual memory in Linux kernel.

Figure 2: This is a high-level design of the Vigi-
lare system. C1 through CN indicates the hardware
components of the host system which connects each
other via the system bus, such as main processor,
memory controller, or network interface. The Vig-
ilare system includes a Snooper that has hardware
connections to the system bus of the host system to
be monitored. Veriﬁer analyzes the ﬁltered traﬃc
that Snooper provides.

included in AMBA 2 (Advanced Microcontroller Bus Archi-
tecture) [6], which was used in the host system of our proto-
type is a good example of such problem. Every cycle, 4 byte
address and 4 byte data is transferred to memory controller
through the bus along with a few more bits of bus-speciﬁc
signals. Thus, we cannot process the stream of bus traﬃc
in one cycle with a general purpose 32 bit machine. There-
fore, Snooper must be designed with a selective bus-traﬃc
collection algorithm; it should recognize only meaningful in-
formation while truncating other unnecessary traﬃc data
ﬂow.

The required time to process a ﬁltered collection of traf-
ﬁc is also related to the computing power of Veriﬁer. The
more computing power Veriﬁer has, the less time would be
required to process the same collection of traﬃc. Veriﬁer’s
computing power must be predetermined in the design pro-
cess, so that it provides just enough processing power yet
does not introduce excessive power consumption.
4.2 Handling Bursty Trafﬁc

Just ﬁltering out some traﬃc may not allow suﬃcient time
to process all collections of traﬃc to Veriﬁer. Filtering may
reduce the processing load imposed on Veriﬁer processor and
enables Vigilare to cooperate with high bandwidth systems.
However, even selective ﬁltering does not guarantee that the
rate of bus traﬃc collected is steady and expect-able. That
is, a deluge of meaningful information may coincidentally
congregate within a short period of time, overwhelming the
computing power of Veriﬁer.

The most intuitive workaround would be to add a FIFO
(ﬁrst-in ﬁrst-out) queue to Snooper to address the problem.
Unfortunately, it does not eﬀectively remedy the problem.
First of all, implementing a FIFO for the speciﬁc architec-
ture will inevitably bring up the hardware cost. In addition,
it is rather diﬃcult to estimate the proper size of FIFO and
we cannot aﬀord to discard the critical information when
FIFO becomes full.

A better approach is to build a more abstract, interpretable
data from the raw bus-traﬃc data in Snooper. It would re-
quire more logic implementation to make Snooper more com-
plex. However, it would be much more eﬃcient than simply
increasing FIFO queue or equipping Veriﬁer with powerful
processor, since Snooper can ﬁlter and summarize the bus

(cid:4)(cid:9)(cid:12)(cid:7)(cid:10)(cid:6)(cid:3)(cid:5)(cid:13)(cid:11)(cid:12)(cid:6)(cid:8)(cid:14)(cid:15)(cid:11)(cid:12)(cid:3)(cid:5)(cid:13)(cid:11)(cid:12)(cid:6)(cid:8)(cid:3)(cid:4)(cid:5)(cid:13)(cid:11)(cid:12)(cid:6)(cid:8)(cid:3)(cid:16)(cid:17)(cid:11)(cid:18)(cid:7)(cid:20)(cid:7)(cid:21)(cid:19)(cid:10)(cid:6)(cid:3)(cid:5)(cid:13)(cid:11)(cid:12)(cid:6)(cid:8)(cid:5)(cid:9)(cid:15)(cid:15)(cid:22)(cid:6)(cid:10)(cid:5)(cid:9)(cid:15)(cid:15)(cid:22)(cid:6)(cid:10)(cid:3)(cid:5)(cid:3)(cid:6)(cid:18)(cid:6)(cid:10)(cid:7)(cid:23)(cid:7)(cid:6)(cid:10)(cid:18)(cid:6)(cid:10)(cid:7)(cid:23)(cid:7)(cid:6)(cid:10)(cid:24)(cid:10)(cid:19)(cid:23)(cid:23)(cid:7)(cid:25)(cid:24)(cid:10)(cid:19)(cid:23)(cid:23)(cid:7)(cid:25)(cid:26)(cid:7)(cid:21)(cid:12)(cid:6)(cid:10)(cid:6)(cid:27)(cid:24)(cid:10)(cid:19)(cid:23)(cid:23)(cid:7)(cid:25)(cid:26)(cid:7)(cid:21)(cid:12)(cid:6)(cid:10)(cid:6)(cid:27)(cid:24)(cid:10)(cid:19)(cid:23)(cid:23)(cid:7)(cid:25)315.2 Immutable Regions of Linux Kernel

5.4 SnoopMon

We ﬁrst describe immutable regions of the Linux kernel
that we monitored in the experiment. We deﬁne immutable
regions as the regions that are critical to the operating sys-
tem integrity such that any modiﬁcations on the regions are
deemed malicious. Protecting the integrity of immutable
regions should be the highest priority, since modiﬁcation to
immutable regions in the attacker’s favor would be the most
critical because the immutable kernel region constitutes crit-
ical component in the OS and any compromise in this region
would seriously aﬀect all the application running on top of
the OS. Therefore, our prototype of SnoopMon focuses on
monitoring the immutable regions of kernel and it is the
main issue in this paper.

As the target of integrity monitoring, we included kernel
code region, system call table and Interrupt Descriptor Ta-
ble (IDT). Kernel code region is the most obvious example
of immutable regions; the basic functionalities of the ker-
nel must not be modiﬁed after the bootstrap. These should
never be modiﬁed at runtime. The system call table is an-
other good example of immutable regions. Hijacking the
kernel’s system call often serves as an eﬃcient way to con-
trol the kernel in the favor of an attacker. Modifying the
system call table of the Linux kernel is a popular way to
intercept the execution ﬂow of the victimized system. The
Linux system call table takes a form of an array of point-
ers. Each entry in the table points to a corresponding sys-
tem calls such as sys read, sys write, and many more. The
adversary could eﬀortlessly hijack these system calls by in-
serting a function between the syscall table and the actual
system call handlers. Most user mode applications as well
as kernel mode ones, rely on the basic system calls to com-
municate with ﬁle system, networking, process information,
and other functionalities. Therefore, taking control of the
system call table enables one to control the entire kernel
from the bottom.

IDT is also an important immutable region as a critical
gateway that kernel system calls pass through. By subvert-
ing such a low level system call invocation procedure, it is
possible to hijack the system calls before even reaching the
system call table.

5.3 Physical Addresses of Immutable Regions
As stated in [20], the virtual memory space used by the
Linux generates semantic gap between the host system and
the external monitor; independent monitors like Vigilare has
no access to the paging ﬁles that manages the mapping be-
tween the virtual address space and physical memory ad-
dress. Moreover, the operating system’s paging mechanism
often swaps out less frequently used pages to hard disk space.
However, the location in the kernel memory space in which
the static region of kernel resides, is determined at boot
time. Thus, we can reliably locate and monitor the impor-
tant symbols within the static region. The virtual address of
the kernel text is found in “/boot/System.map” ﬁle, which
lists a numerous symbols used by the kernel; it is a look-up
table that contains physical addresses of symbol names. The
symbol text and etext signiﬁes the start and the end of the
kernel’s text section. The physical address of syscall table
and IDT is also determined at compile time so we can make
use of them for monitoring.

We describe our SnoopMon design and explain how our
design meets the requirements we proposed in Section 4.
Figure 3 shows key design features of SnoopMon. To prevent
any modiﬁcations to the immutable region that we explained
in Section 5.2, we speciﬁcally capture any write operation on
those intervals of addresses.

We implemented our SnoopMon as a separate computer
system that consists of one Leon3 processor, Snooper, 2MB
SRAM, several peripherals and the bus that interconnects
them. This conﬁguration makes the memory and the mem-
ory interface of the Vigilare system to be separate from the
host system. Moreover, the host system cannot access any
peripheral of the Vigilare system and is also incapable of
triggering interrupts to the Veriﬁer. Therefore the Vigilare
system design meets the requirement in Section 4.3.

As in computer systems in general, there are L1 caches
that connects the system bus and the processor. So there
are two links between the processor and the main memory:
L1 caches and the system bus. Modifying L1 cache link in
most computers is diﬃcult or sometimes impossible while
adjusting the structure of the system bus is relatively more
ﬂexible. For instance, ARM architecture can easily adopt
Vigilare’s system bus architecture.

The Vigilare system has hardware connections to the host
system bus to snoop its traﬃc. However, an attempt to
read the main memory content that is in the cache, may not
generate corresponding read request on the bus. The bus
traﬃc that indicates read attempts will be generated only
when cache-miss occurs. The time that the traﬃc of write
attempts is generated depends on the type of cache: write-
through cache or write-back cache. In case of write-through
cache, all write attempts by processor may generate the cor-
responding packets on the bus. In case of write-back cache,
the write attempts from processor may not be seen imme-
diately on the bus, because the write-back cache does not
commit all the memory updates immediately to the memory.
Thus, it is plausible to devise a transient attack that can live
on write-back cache before the updated cache contents are
ﬂushed to the memory bus. However, predicting the time of
the write-back cache ﬂushing is not trivial, so implementing
such a rootkit would be nearly impossible. Even if an at-
tacker successfully performed the attack, it generates dirty
bits in cache lines of immutable regions, and it will be writ-
ten back. Thus we can detect the attack by snooping the
write traﬃc to the memory. Most caches write back dirty
bits even when it is restored to original value, so any cache
attack on immutable region generates corresponding write
traﬃc on the links between caches and memories, where
SnoopMon snoops. Simply enforcing write-through policy
on the host caches would also be an alternative solution.
5.5 SnapMon

To better compare our snoop-based monitoring scheme

with traditional snapshot-based method, we also implemented
a snapshot-based integrity monitor. Our SnapMon design
follows snapshot-based security monitors which were often
represented by Copilot [20]. We implemented the hardware
of SnapMon by replacing the Snooper with a DMA (Direct
Memory Access)-capable memory interface. Hence, Snap-
Mon uses the DMA to get the snapshot of the immutable
regions of host system’s kernel periodically. SnapMon cal-
culates the hash value for each kernel region snapshot, and

32Figure 3: This diagram shows the architecture of our prototype with SnoopMon. SnoopMon has its own
memory and peripherals for its independence from host system.
It snoops host system bus traﬃc with
Snooper. Snooper delivers traﬃc that indicates write attempts to immutable regions of host system kernel.
The peripherals of SnoopMon includes debug interface for out-of-band reporting.

compares it against the pre-calculated hash value of the un-
modiﬁed immutable region. The Veriﬁer logic for SnapMon
is rather simple; it only compares the two hash values to
locate any modiﬁcations. In order to implement the mon-
itoring functionality on the hardware, we used the proces-
sor for hashing the contents and some memory spaces to
store snapshots. The memory we used for SnoopMon was
suﬃcient for SnapMon since the size of immutable region
in kernel was less than 1MB. However, the processing time
was longer than we had expected; it took about 5 seconds
to hash them using the processor on Veriﬁer. Consequently,
we included a hash accelerator in SnapMon to shorten the
processing time to a reasonable level; and it improved to be
about 1.3ms to hash one snapshot.

6. EVALUATION

In this section we present results of our experiments about
SnoopMon and SnapMon. We performed two experiments to
compare the performance degradation and the ability to de-
tect transient attacks of each scheme. In case of SnapMon,
the interval of snapshots signiﬁcantly aﬀects both perfor-
mance degradation and ability to detect transient attacks.
We varied SnapMon’s interval to observe its eﬀect on both
detection rates and performance degradation. SnoopMon
does not have any parameter that possibly aﬀects the result
of experiments so we used only one type of SnoopMon.
6.1 Performance Degradation

STREAM benchmark is widely used for measuring the
memory bandwidth of a computer system. We used a tuned
version of STREAM benchmark [18] to measure the perfor-
mance degradations imposed on the host system. The origi-
nal version uses double precision numbers for measuring the
bandwidth but the Leon3 processor does not have ﬂoating
point units. Thus, we tuned it to use integer numbers for
measuring.

We let the tuned STREAM benchmark run on host sys-
tem while each monitor is running. We averaged 1000 ex-
periments to acquire more accurate results. As Figure 4
shows, SnoopMon does not degrade the performance at all,
while SnapMon with shorter intervals degrades the perfor-

mance signiﬁcantly. For instance, performance degradation
due to SnapMon with 50ms interval was measured to be
17.5% on average, 10% in the best case, and about 40% in
the worst case. If the snapshot interval is greater than 1 sec-
ond, we have less performance degradation, 0.5% on average.
This performance degradation does not include the poten-
tial overhead that can be caused by the memory bandwidth
consumption on the host with many competing processes
for memory access.
In our experiment, there is no other
process competing for the memory bandwidth except the
benchmarks. The performance degradation also depends on
the size of the immutable region, as it determines the size
of snapshots to be taken and be transferred over. Since the
Linux we used is tuned for embedded systems, the size of im-
mutable region of the kernel that we implemented for testing
was less than 1 Mbytes.

6.2 Transient Attack

Another objective of experiment was to observe the per-
formance on detecting transient attacks. To compare the
ability to detect the attacks, we built a rootkit example that
performs transient attack, and measured the probability of
detecting a pulse of an attack when we used each monitor.
We implemented a rootkit example for our experiment
that meets the deﬁnition of transient attack in Section 3.
Figure 1 shows how our rootkit example works. It modiﬁes
the system call table of the Linux kernel to hook some of the
system calls. After tactive, it removes its hooks by modifying
the system call table as it has been before. After tinactive,
it hooks the system call as it did before. In our experiment,
we measured the probability of detecting one pulse of the
attack, depending on tactive. We generated 500 pulses and
measured how many of them were detected by each monitor.
Figure 5 shows the results of the experiments. SnoopMon
detects all the pulses of attacks for all tactive, while SnapMon
misses many of the transient attacks. SnapMon with 50ms
snapshot interval detects all the pulses which have tactive
greater than 50ms, but SnapMon with 1000ms snapshot in-
terval cannot detect more than 5% of the pulses when tactive
is less than 50ms. The results show that it is necessary to

(cid:4)(cid:6)(cid:5)(cid:3)(cid:4)(cid:7)(cid:5)(cid:8)(cid:13)(cid:12)(cid:9)(cid:11)(cid:10)(cid:4)(cid:6)(cid:5)(cid:3)(cid:4)(cid:7)(cid:5)(cid:8)(cid:13)(cid:12)(cid:9)(cid:11)(cid:10)(cid:15)(cid:10)(cid:17)(cid:16)(cid:14)(cid:15)(cid:10)(cid:17)(cid:16)(cid:14)(cid:20)(cid:12)(cid:11)(cid:12)(cid:22)(cid:21)(cid:13)(cid:10)(cid:18)(cid:19)(cid:27)(cid:24)(cid:25)(cid:10)(cid:23)(cid:18)(cid:5)(cid:26)(cid:24)(cid:18)(cid:28)(cid:4)(cid:6)(cid:5)(cid:29)(cid:20)(cid:12)(cid:11)(cid:12)(cid:22)(cid:21)(cid:13)(cid:10)(cid:18)(cid:19)(cid:27)(cid:24)(cid:25)(cid:10)(cid:23)(cid:18)(cid:5)(cid:26)(cid:24)(cid:18)(cid:28)(cid:4)(cid:6)(cid:5)(cid:29)(cid:4)(cid:6)(cid:5)(cid:3)(cid:4)(cid:7)(cid:5)(cid:18)(cid:8)(cid:13)(cid:12)(cid:9)(cid:11)(cid:10)(cid:4)(cid:6)(cid:5)(cid:3)(cid:4)(cid:7)(cid:5)(cid:18)(cid:8)(cid:13)(cid:12)(cid:9)(cid:11)(cid:10)(cid:15)(cid:10)(cid:17)(cid:16)(cid:14)(cid:15)(cid:10)(cid:17)(cid:16)(cid:14)(cid:6)(cid:17)(cid:24)(cid:25)(cid:18)(cid:19)(cid:27)(cid:24)(cid:25)(cid:10)(cid:23)(cid:18)(cid:5)(cid:26)(cid:24)(cid:28)(cid:4)(cid:6)(cid:5)(cid:29)(cid:6)(cid:17)(cid:24)(cid:25)(cid:18)(cid:19)(cid:27)(cid:24)(cid:25)(cid:10)(cid:23)(cid:18)(cid:5)(cid:26)(cid:24)(cid:28)(cid:4)(cid:6)(cid:5)(cid:29)(cid:31)(cid:10)(cid:23)(cid:17)(cid:13)(cid:27)(cid:18)(cid:30)(cid:17)(cid:16)(cid:25)(cid:13)(cid:17)(cid:22)(cid:22)(cid:10)(cid:13)(cid:31)(cid:10)(cid:23)(cid:17)(cid:13)(cid:27)(cid:18)(cid:30)(cid:17)(cid:16)(cid:25)(cid:13)(cid:17)(cid:22)(cid:22)(cid:10)(cid:13)(cid:31)(cid:10)(cid:23)(cid:17)(cid:13)(cid:27)(cid:18)(cid:30)(cid:17)(cid:16)(cid:25)(cid:13)(cid:17)(cid:22)(cid:22)(cid:10)(cid:13)(cid:31)(cid:10)(cid:23)(cid:17)(cid:13)(cid:27)(cid:18)(cid:30)(cid:17)(cid:16)(cid:25)(cid:13)(cid:17)(cid:22)(cid:22)(cid:10)(cid:13)(cid:3)(cid:31)(cid:5)(cid:18)(cid:19)(cid:32)(cid:4)(cid:31)(cid:3)(cid:31)(cid:5)(cid:18)(cid:19)(cid:32)(cid:4)(cid:31)(cid:34)(cid:33)(cid:31)(cid:5)(cid:18)(cid:19)(cid:35)(cid:32)(cid:4)(cid:31)(cid:34)(cid:33)(cid:31)(cid:5)(cid:18)(cid:19)(cid:35)(cid:32)(cid:4)(cid:31)(cid:3)(cid:5)(cid:6)(cid:6)(cid:7)(cid:4)(cid:8)(cid:9)(cid:4)(cid:8)(cid:11)(cid:10)(cid:11)(cid:4)(cid:8)(cid:13)(cid:6)(cid:14)(cid:15)(cid:12)(cid:3)(cid:17)(cid:14)(cid:15)(cid:4)(cid:16)(cid:7)(cid:10)(cid:13)(cid:12)(cid:37)(cid:36)(cid:10)(cid:13)(cid:21)(cid:22)(cid:24)(cid:7)(cid:10)(cid:13)(cid:12)(cid:37)(cid:36)(cid:10)(cid:13)(cid:21)(cid:22)(cid:24)(cid:7)(cid:10)(cid:13)(cid:12)(cid:37)(cid:36)(cid:10)(cid:13)(cid:21)(cid:22)(cid:24)(cid:7)(cid:10)(cid:13)(cid:12)(cid:37)(cid:36)(cid:10)(cid:13)(cid:21)(cid:22)(cid:24)(cid:3)(cid:5)(cid:6)(cid:6)(cid:7)(cid:18)(cid:6)(cid:5)33Figure 4: Performance degradation due to each
monitor. Numbers in legend indicates tactive of each
pulse in the attack in millisecond. SnapMon with
shorter snapshot interval (i.e., increased snapshot
frequency) degrades performance of the host more.
For instance, performance degradation for SnapMon
with 50ms snapshot interval is 17.5% on average,
10% in the best case and about 40% in the worst
case, while SnoopMon has no performance degrada-
tion on the host.

increase the snapshot frequency signiﬁcantly for SnapMon
to reliably detect transient attacks.
6.3 Discussions

These two experimental results show that snapshot-based
monitoring has trade-oﬀ between the performance degrada-
tion and the ability to detect transient attacks. With snap-
shot interval higher than 1 second, the SnapMon may cause
little performance degradation but it misses out some tran-
sient attacks. Even the rootkit example with tactive 500ms,
SnapMon with snapshot interval 1 second could only detect
about 50% of them. In order to detect most of transient at-
tacks, we need to lower the snapshot interval of monitoring
but it results in signiﬁcant performance degradation of the
host system. However, SnoopMon which uses snoop-based
monitoring detects all the transient attacks with little or no
performance degradation.

7. LIMITATIONS AND FUTURE WORKS

In this section, we discuss about some limitations, and

future works.
7.1 Dynamic Kernel Region Manipulations

The most prominent trend in the latest kernel rootkit
technique is the dynamic kernel region manipulation.
In
order to evade the common rootkit detection tools that eas-
ily detect obvious static kernel hooking, the forgers of kernel
rootkits are looking aside to DKOM (direct kernel object ma-
nipulation). By directly modifying dynamically created and
removed kernel data structures that are used in core kernel
operations, the attackers can manipulate the system status
in a stealthy manner. In addition, ensuring the integrity of
static immutable regions does not necessarily guarantee the
integrity of the control ﬂow of kernel [22].

Figure 5: Ratio of detected attacks for each moni-
tor. Numbers in legend indicates tactive of each pulse
in the attacks in millisecond. This shows Snoop-
Mon detects all the attacks while SnapMon cannot.
The graph shows that SnapMon detects all the at-
tacks having tactive larger than or equals to its snap-
shot interval. However, if tactive becomes lower than
snapshot interval, the ratio of detection decreases as
tactive decreases. Transient attacks that are active for
1000ms were mostly detected, but when the attack
is short-lived tactive becomes 10ms, the ratio of de-
tected attack drops signiﬁcantly ranging from 2% to
20%. If tactive become lower than snapshot interval,
the ratio of detection decreases as tactive decreases.

Our next step in Vigilare project will be to design and im-
plement a control ﬂow integrity solution using our already
implemented Snooper architecture. More speciﬁcally, a de-
tection algorithm that senses each context-switching in the
kernel space should be implemented to successfully detect
control ﬂow hijackings. Furthermore, a more elaborate se-
mantic detection algorithm should be developed in order to
detect malicious kernel manipulations in the dynamic region.
7.2 Relocation Attack

Our SnoopMon cannot deal with relocation attacks. The
relocation attack refers to moving the entire or parts of ker-
nel to another location to stay out of the range of integrity
monitoring. However, relocating, or copying of a large vol-
ume of the kernel code will inevitably produce an abnormal
bus traﬃc pattern. Therefore, we expect that Vigilare would
be capable of detecting such attacks with a prior knowledge
of the existence of such attack patterns.

This assumption varies across diﬀerent computer archi-
tectures. If the system uses Harvard architecture, it would
be relatively easier to detect the relocation attacks. For the
initial relocation, the attacker should read the kernel code
as data, not as instruction. Since such behavior is quite un-
usual, we can detect it by analyzing the traﬃc. Even for the
systems based on the Von Neumann architecture, the traﬃc
pattern on the immutable regions under relocation attacks
would be far from normal status. In both cases, snapshot-
based monitoring would not be helpful since it gets only an
instance of the system state, not the sequence of actions
changing the states.

020406080100120SnapMon50msSnapMon100msSnapMon500msSnapMon1000msSnoopMonNormalized Performance (%)Type of Monitorcopyscaleaddtriadavg020406080100120SnoopMonSnapMon50msSnapMon100msSnapMon500msSnapMon1000msDetected Attack (%)Type of Monitor10501005001000347.3 Power Consumption Analysis

The Vigilare system might increase the total power con-
sumption of the entire system, due to additional hardware.
However, the opposite is often true as well because replacing
the functionalities of software with a hardware module de-
creases overall power consumption as it improves eﬃciency.
More work is needed to compare the amount of increased
power consumption for each type of monitors.
7.4 Vigilare on Various Platforms

We evaluated the concept of Vigilare on a small and sim-
ple embedded system but the concept might be applicable
on other platforms: desktops, servers, or application proces-
sors for mobile devices. All these platforms have link be-
tween processors and memories. Applying Vigilare to these
platforms, however, may not be straightforward since each
platform has its own characteristics and restriction. Design-
ing Vigilare for each platform would be a part of our future
work.
8. RELATED WORKS

In this section, we explain previous approaches on pro-
tecting the integrity of an operating system kernel, which
includes: kernel integrity monitors, rootkit detectors, and
intrusion detection systems. The dilemma in designing such
tools is that the security monitoring tool itself can be tam-
pered with, if the malware operates on the same privilege
level as that of the monitors. To cope with this problem,
many security researchers strive to make their security mon-
itors independent from the system that is being monitored.
A separated and tamper-free execution environment must
be preceded before any advanced detection scheme. [9]

We can categorize prior works that aim to provide a so-
lution to the problem, into two groups: hardware-based ap-
proaches and hypervisor-based approaches. We summarize
these approaches for the rest of this section.
8.1 Hypervisor-based Approaches

Virtualization solutions, commonly called VMMs (Virtual
Machine Monitors) or Hypervisors are widely used nowadays
to eﬃciently distribute computing power among diﬀerent
types of needs. Since the hypervisor resides in between the
hardware and the virtual machines, the hypervisor possess
the scope to manage and monitor the virtualized operating
systems.

There has been quite a few works that take advantage
of hypervisors for monitoring the security of the virtualized
computers. One of the ﬁrst in such works was Livewire [14]
proposed by Garﬁnkel et al. Livewire proposed security
monitor installed virtual machines. More ideas based on
hypervisor has been proposed and implemented on popular
hypervisors such as Xen [22, 23].

Although positioned underneath and separated from the
virtual machines, it has been warned that the hypervisors
can be also exploited with software vulnerabilities. Many
vulnerabilities of Xen are already reported and amended [1,
2, 3, 4]. The discovery of hypervisor vulnerabilities might
continue as the hypervisors are expanding in terms of code
size and software complexity. This implies that the hypervi-
sor might not be a safe independent execution environment,
which is an imperative requirement for a security monitor.
There has been attempts to design minimal hypervisors
for more secure execution environment for security moni-

toring [13, 17, 25, 26]. The idea is to include only essential
software components to minimize the attack surface for soft-
ware vulnerabilities. Some of such works used static analysis
to ensure that their hypervisor is vulnerability-less. SecVi-
sor, the most well-known work of among such approaches,
introduced higher performance degradation than the popu-
lar hypervisor software Xen.

Recently, Rhee et al [24] proposed an event-driven in-
tegrity monitor based on hypervisor. With event-driven na-
ture, it can be considered as a hypervisor version of snoop-
based monitoring. However, the security of the integrity
monitor itself heavily relies on the premise that the hypervi-
sors are vulnerability free. Besides, it reported non-negligent
performance degradation.
8.2 Hardware-based Approaches

Another approach in implementing a kernel integrity mon-
itor out of operating system is attaching an independent
hardware component. The idea of securing operating system
using SMP (Symmetric Multi-Processor) was ﬁrst proposed
by Hollingworth et al. [16]. Later, X.Zhang et al. proposed
IDS (Intrusion Detection System) based on a coprocessor
independent from the main processor
[30]. Petroni et al.
designed and implemented Copilot [20], which is a kernel
runtime integrity monitor operating on a coprocessor PCI-
card. More snapshot-based works followed after Copilot and
inherited the limitations of snapshot-based mechanism pre-
sented in Copilot. [8, 21].

Intel also contributed to the trend, by presenting a hardware-

based support snapshot-based rootkit detection called as
DeepWatch [10]. J. Wang et al. designed HyperCheck [28]
which is an integrity monitor for hypervisors based on a PCI
card and the SMM (System Management Mode) [12]. A. M.
Azab et al also proposed a framework called HyperSentry [7]
for monitoring the integrity of hypervisors with their agent
planted in the SMM. The critical drawback of using SMM
for security monitoring is that all system activities must halt
upon entering SMM. It implies the host system has to stop,
every time the integrity monitor on SMM runs. DeepWatch
and HyperCheck focused on building a safe execution envi-
ronment but they both utilized memory snapshots for in-
tegrity veriﬁcation.

In all, most of the hardware-based approaches use memory
or register snapshots [20, 28] as the source of system status
information. However, they are inapt for monitoring instant
changes occur in the host system and thus vulnerable to ad-
vanced attacks such as transient attacks. HyperSentry [7]
also uses the state of host system at certain points of time,
when the independent auditor stops the host system and ex-
ecute the agent. Thus, this can be considered as a snapshot-
based monitor along with Copilot [20] and HyperCheck [28],
in the sense that they all use the periodically acquired status
information. Our approach is fundamentally diﬀerent from
the previous snapshot-based approaches on hardware-based
integrity monitors since our Vigilare is snoop-based monitor.
8.3 Snooping Bus Trafﬁc

Snooping bus traﬃc is well known concept as shown in
these two prior works. Clarke et al. [11] proposed to add
special hardware between caches and external memories to
monitor the integrity of external memory. The aim of this
work is to ensure that the value read from an address is the
same as the value last written to that address. It can defeat

35attacks to integrity of external memory, but cannot address
rootkits nor monitor the integrity of operating system kernel,
unlike Vigilare System.

BusMop [19] designed a snoop-based monitor which is
similar to our SnoopMon, but the objective of BusMop is
diﬀerent from SnoopMon. BusMop is designed to monitor
behavior of peripherals. Unlike BusMop, SnoopMon is to
monitor the integrity of operating system kernel. To the
best of our knowledge, Vigilare is the ﬁrst snoop based ap-
proach to monitor OS kernel integrity while all of the pre-
vious approaches in this area were based on taking periodic
snapshots.

9. CONCLUSIONS

In this paper, we proposed snoop-based monitoring, a
novel scheme for monitoring the integrity of kernel. We in-
vestigated several requirements on implementing our scheme
and designed the Vigilare system and its snoop-based mon-
itoring. We focused on contributing improvements over the
previous approaches in two main aspects: detecting tran-
sient attacks and minimizing performance degradation. To
draw the contrast between Vigilare’s SnoopMon and snapshot-
based integrity monitoring, we implemented SnapMon which
represents snapshot-based architecture. We pointed out that
the snapshot-based integrity monitors are inherently vulner-
able against transient attacks and presented our Vigilare
system as a solution. In our experiment, we demonstrated
that SnoopMon-powered Vigilare is capable of eﬀectively
coping with transient attacks that violate the integrity of
the immutable regions of the kernel, while snapshot-based
approach had their limitations. In addition, we also inves-
tigated the performance impact on the host system using
STREAM benchmark [18], and showed that Vigilare, due to
its independent hardware module for bus snooping, imposes
no performance degradation on the host. Snapshot-based
integrity monitoring proved to be unsuitable for detecting
transient attacks in general; it is ineﬃcient because of the
trade-oﬀ between detection rates and performance degrada-
tion; higher snapshot frequencies might improve the detec-
tion rates, but the performance suﬀers from the overused
memory bandwidth. In all, Vigilare overcomes the limita-
tion of snapshot-based integrity monitors with snoop-based
architecture.

10. ACKNOWLEDGMENTS

This work was partly supported by VigilSystem, Korea
Science and Engineering Foundation (KOSEF) NRL Pro-
gram grant (No. 0421-2012-0047), the Attached Institute of
ETRI, the Engineering Research Center of Excellence Pro-
gram of Korea Ministry of Education, Science and Tech-
nology (MEST) / National Research Foundation of Korea
(NRF) (Grant 2012-0000470), and the Center for Integrated
Smart Sensors funded by the Ministry of Education, Sci-
ence and Technology as Global Frontier Project (CISS-0543-
20110012).

11. REFERENCES
[1] Vmware : Vulnerability statistics.

http://www.cvedetails.com/vendor/252/Vmware.html.

[2] Vulnerability report: Vmware esx server 3.x.

http://secunia.com/advisories/product/10757.

[3] Vulnerability report: Xen 3.x.

http://secunia.com/advisories/product/15863.

[4] Xen : Security vulnerabilities.

http://www.cvedetails.com/vulnerability-
list/vendor id-6276/XEN.html.

[5] Aeroﬂex Gaisle. GRLIB IP Core User’s Manual,

January 2012.

[6] ARM Limited. AMBATM Speciﬁcation, May 1999.
[7] A. M. Azab, P. Ning, Z. Wang, X. Jiang, X. Zhang,

and N. C. Skalsky. Hypersentry: enabling stealthy
in-context measurement of hypervisor integrity. In
Proceedings of the 17th ACM conference on Computer
and communications security, CCS ’10, pages 38–49,
New York, NY, USA, 2010. ACM.

[8] A. Baliga, V. Ganapathy, and L. Iftode. Automatic
inference and enforcement of kernel data structure
invariants. In Computer Security Applications
Conference, 2008. ACSAC 2008. Annual, pages 77
–86, dec. 2008.

[9] J. Bickford, R. O’Hare, A. Baliga, V. Ganapathy, and

L. Iftode. Rootkits on smart phones: attacks,
implications and opportunities. In Proceedings of the
Eleventh Workshop on Mobile Computing Systems
&#38; Applications, HotMobile ’10, pages 49–54, New
York, NY, USA, 2010. ACM.

[10] Y. Bulygin and D. Samyde. Chipset based approach to

detect virtualization malware a.k.a. deepwatch. In
BlackHat USA, 2008.

[11] D. Clarke, G. E. Suh, B. Gassend, M. van Dijk, and
S. Devadas. Checking the integrity of a memory in a
snooping-based symmetric multiprocessor (smp)
system. Technical report, MIT LCS memo-470,
http://csg.csail.mit.edu/pubs/memos/Memo-
470/smpMemoryMemo.pdf,
2004.

[12] L. Duﬂot, D. Etiemble, and O. Grumelard. Using cpu

system management mode to circumvent operating
system security functions. In In Proceedings of the 7th
CanSecWest conference, 2006.

[13] T. Garﬁnkel, B. Pfaﬀ, J. Chow, M. Rosenblum, and

D. Boneh. Terra: a virtual machine-based platform for
trusted computing. In Proceedings of the nineteenth
ACM symposium on Operating systems principles,
SOSP ’03, pages 193–206, New York, NY, USA, 2003.
ACM.

[14] T. Garﬁnkel and M. Rosenblum. A virtual machine

introspection based architecture for intrusion
detection. In Proc. Network and Distributed Systems
Security Symposium, February 2003.

[15] D. Hellstr¨om. SnapGear Linux for LEON. Gaisler

Research, November 2008.

[16] D. Hollingworth and T. Redmond. Enhancing

operating system resistance to information warfare. In
MILCOM 2000. 21st Century Military
Communications Conference Proceedings, volume 2,
pages 1037 –1041 vol.2, 2000.

[17] K. Kaneda. Tiny virtual machine monitor.

http://www.yl.is.s.u-tokyo.ac.jp/˜kaneda/tvmm/.
[18] J. D. McCalpin. Memory bandwidth and machine

balance in current high performance computers. IEEE
Computer Society Technical Committee on Computer

36Architecture (TCCA) Newsletter, pages 19–25, Dec.
1995.

[19] R. Pellizzoni, P. Meredith, M. Caccamo, and G. Rosu.

Hardware runtime monitoring for dependable
cots-based real-time embedded systems. In Proceedings
of the 2008 Real-Time Systems Symposium, RTSS ’08,
pages 481–491, Washington, DC, USA, 2008. IEEE
Computer Society.

[24] J. Rhee, R. Riley, D. Xu, and X. Jiang. Defeating

dynamic data kernel rootkit attacks via vmm-based
guest-transparent monitoring. In Availability,
Reliability and Security, 2009. ARES ’09.
International Conference on, pages 74 –81, march
2009.

[25] R. Russell. Lguest: The simple x86 hypervisor.

http://lguest.ozlabs.org/.

[20] N. L. Petroni, Jr., T. Fraser, J. Molina, and W. A.

[26] A. Seshadri, M. Luk, N. Qu, and A. Perrig. Secvisor:

Arbaugh. Copilot - a coprocessor-based kernel runtime
integrity monitor. In Proceedings of the 13th
conference on USENIX Security Symposium - Volume
13, SSYM’04, pages 13–13, Berkeley, CA, USA, 2004.
USENIX Association.

a tiny hypervisor to provide lifetime kernel code
integrity for commodity oses. In Proceedings of
twenty-ﬁrst ACM SIGOPS symposium on Operating
systems principles, SOSP ’07, pages 335–350, New
York, NY, USA, 2007. ACM.

[21] N. L. Petroni, Jr., T. Fraser, A. Walters, and W. A.

[27] SPARC International Inc. The SPARC Architecture

Arbaugh. An architecture for speciﬁcation-based
detection of semantic integrity violations in kernel
dynamic data. In Proceedings of the 15th conference
on USENIX Security Symposium - Volume 15,
USENIX-SS’06, Berkeley, CA, USA, 2006. USENIX
Association.

[22] N. L. Petroni, Jr. and M. Hicks. Automated detection

of persistent kernel control-ﬂow attacks. In
Proceedings of the 14th ACM conference on Computer
and communications security, CCS ’07, pages 103–115,
New York, NY, USA, 2007. ACM.

[23] N. A. Quynh and Y. Takefuji. A novel approach for a

ﬁle-system integrity monitor tool of xen virtual
machine. In Proceedings of the 2nd ACM symposium
on Information, computer and communications
security, ASIACCS ’07, pages 194–202, New York,
NY, USA, 2007. ACM.

Manual, 1992.

[28] J. Wang, A. Stavrou, and A. Ghosh. Hypercheck: A

hardware-assisted integrity monitor. In S. Jha,
R. Sommer, and C. Kreibich, editors, Recent Advances
in Intrusion Detection, volume 6307 of Lecture Notes
in Computer Science, pages 158–177. Springer Berlin /
Heidelberg, 2010. 10.1007/978-3-642-15512-3-9.

[29] J. Wei, B. Payne, J. Giﬃn, and C. Pu. Soft-timer

driven transient kernel control ﬂow attacks and
defense. In Computer Security Applications
Conference, 2008. ACSAC 2008. Annual, pages 97
–107, dec. 2008.

[30] X. Zhang, L. van Doorn, T. Jaeger, R. Perez, and

R. Sailer. Secure coprocessor-based intrusion
detection. In Proceedings of the 10th workshop on
ACM SIGOPS European workshop, EW 10, pages
239–242, New York, NY, USA, 2002. ACM.

37