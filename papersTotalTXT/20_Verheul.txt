The self-blindable U-Prove scheme from FC’14 is

forgeable (short paper)

Eric Verheul1, Sietse Ringers2, and Jaap-Henk Hoepman1

1 Radboud University, Nijmegen, The Netherlands

2 Johann Bernoulli Institute for Mathematics and Computer Science, University of

{jhh,e.verheul}@cs.ru.nl

Groningen, The Netherlands

s.ringers@rug.nl

Abstract. Recently an unlinkable version of the U-Prove attribute-
based credential scheme was proposed at Financial Crypto ’14 [9]. Un-
fortunately, the new scheme is forgeable: if suﬃciently many users work
together then they can construct new credentials, containing any set of
attributes of their choice, without any involvement of the issuer. In this
note we show how they can achieve this and we point out the error in
the unforgeability proof.

1

Introduction

Attribute-based credential schemes [1,3] provide a very secure and privacy-
friendly form of identity management. In these schemes, users are granted by
an issuer a credential that contains several attributes (generally elements of
Zq := Z/qZ for some number q), and when the user shows his credential to a
veriﬁer using a ShowCredential protocol, he can choose to reveal some of these
while keeping the other ones hidden from the veriﬁer. Some of these schemes
oﬀer anonymity in the form of multi-show unlinkability: that is, when a veriﬁer
runs the ShowCredential protocol twice and both times the same attributes with
the same values were disclosed to it, then it cannot tell whether it was shown
one credential twice, or two diﬀerent credentials that happened to disclose the
same attributes.

A well-known and very eﬃcient attribute-based credential scheme is U-Prove
[6,10]. However, this scheme oﬀers no multi-show unlinkability. In an attempt to
ﬁx this, L. Hanzlik and K. Kluczniak proposed in [9], and presented at Financial
Crypto 2014, a new scheme that is based on U-Prove but uses a diﬀerent signa-
ture scheme. This signature scheme is based on the self-blindable construction
by Verheul [11], and allows a credential to be blinded; i.e., modiﬁed into a new
valid credential over the same attributes. Although [9] does contain an argument
for the unforgeability of their scheme, we show here that this argument contains
an error, and that the proposed construction is forgeable, in the sense that if suf-
ﬁciently many users collude then they can construct new credentials containing
arbitrary attributes of their choice, without involvement of the issuer.

2 The credential scheme

Hanzlik and Kluczniak [9] present their blindable U-Prove scheme as an extension
of the original U-Prove scheme, in the following sense: a self-blindable signature
(based on [11]) is added to a U-Prove credential. When showing a credential,
the user can then choose to either show his credential using the original linkable
U-Prove ShowCredential protocol, or using a new protocol that uses the new
self-blindable signature and should oﬀer unlinkability. Since we are concerned
only with the forgeability of the self-blindable construction, our description of
the credential scheme will omit details that are relevant only to the original
construction.
The setup is as follows. q is a prime number of length k, and e : G1×G2 → GT
is a bilinear pairing of Type 2 (see [8], [5, Ch. I, X]), where q is the order of G1,
G2 and GT . The issuer’s public key is

(q, e, g0, . . . , gn, p, p(cid:48), p0, p1),

where
– g0, . . . , gn are random generators of G1,
– p and p(cid:48) are random generators of G2,
– p0 = (p(cid:48))z,
– p1 = pf .
The tuple (f, z) ∈ Z2

q is the issuer’s secret key.

A credential consists of the tuple

((x1, . . . , xn), (h, h2, h3, h4, α, b1, b2))

where
– x1, . . . , xn ∈ Zq are the attributes,
– α, b0, b1 ∈ Zq, chosen by the user during issuing of the credential,
1 ··· gxn
– h = (g0gx1
– h2 = hf ,
2 ,
– h3 = hb1 hb2
– h4 = hz
The validity of the credential can be checked by

3 = (hb1hb2

n )α,

2 )z.

e(h, p1) ?= e(h2, p)

and

e(h3, p0) ?= e(h4, p(cid:48)).

Such a credential can be blinded into a new one as follows. Take random k, (cid:96) ∈ Z∗
q,
and set (h, h2, h3, h4) = (hk, hk

4 ). Then

2, hk(cid:96)

3 , hk(cid:96)

((x1, . . . , xn), (h, h2, h3, h4, αk, b1(cid:96), b2(cid:96)))

is a new, valid credential over the same attributes. In [9] a ShowCredential proto-
col for these credential is provided, in which the credentials are blinded as above.
The protocol should oﬀer unlinkability but it is not proven that it does (and we
have not checked this).

2

3 Forging new credentials

3.1 Constructing signatures on the elements gi

We ﬁrst show that if suﬃciently many users work together, then for each i they
, even though f and z are private to the issuer.
can compute a tuple gf
Using these tuples they can easily create new valid credentials over any set of
attributes of their choice. Since this will involve many credentials, we will write
the elements from the credential of user j with an extra subscript j:

i , gf z

i , gz

i

((x1,j, . . . , xn,j), (hj, h2,j, h3,j, h4,j, αj, b1,j, b2,j)).

The element hj is of the form

hj = (g0gx1,j

1

··· gxn,j

n

)αj .

By blinding the credential with k = α−1
, (cid:96) = 1 (i.e., we raise all group elements of
the credential to the power α−1
; note that these numbers are known to the users),
we can remove the number α from our considerations, so we will henceforth
simply write

j

j

hj = g0gx1,j

1

··· gxn,j

n

.

j hb2,j

2,j = gb1,j

h3,j = hb1,j

i . Then we can write h3,j as

Let us write(cid:101)gi = gf
(cid:101)gb2,j xn,j
Setting x0,j = 1 and writing yi,j = b1,jxi,j and (cid:101)yi,j = b2,jxi,j, we get
where all numbers yi,j and (cid:101)yi,j are known to the user.

0 (cid:101)gb2,j
1 (cid:101)g(cid:101)y1,j

n (cid:101)g(cid:101)yn,j

0 (cid:101)g(cid:101)y0,j

(cid:101)gb2,j x1,j

··· gb1,j xn,j

h3,j = gy0,j

··· gyn,j

gb1,j x1,j
1

gy1,j

n

n

0

,

n

0

1

1

.

(1)

We know that h4,j = hz

3,j, i.e., the discrete log of h4,j with respect to h3,j is
z. If we raise h3,j to some power and we simultaneously raise h4,j to the same
power, then the resulting two elements will still have z as discrete log. The same
holds if we multiply two elements h3,j and h3,j(cid:48) together. In the remainder of
this section we will take a number of powers and products of the elements h3,j;
whenever we write such a power or product, the same power or product for h4,j
is implied.

Observe that when raising h3,1 to the power 1/(cid:101)yn,1 we obtain a product of
the generators gi to certain exponents, where(cid:101)gn now has exponent 1. Thus two
users 1 and 2 can work together to form the element h1/(cid:101)yn,1

(cid:14)h1/(cid:101)yn,2

, which is of

3,1

3,2

the form

h1/(cid:101)yn,1
h1/(cid:101)yn,2

3,1

3,2

0 (cid:101)g(cid:101)v0

1 (cid:101)g(cid:101)v1
1 ··· gvn
n ,

= gv0

0 gv1

3

with vi = yi,1/yn,1 − yi,2/yn,2, and similar for (cid:101)vi. Note that the right hand
side no longer contains (cid:101)gn. If two more users do the same and obtain a sim-
g0,(cid:101)g0, . . . , gn−1,(cid:101)gn−1.

ilar expression, then the four users can collectively remove gn in exactly the
same fashion, resulting in an expression as above containing only the elements

0. Similarly, they can obtain (cid:101)g0 = gf

can do this for all elements gi,(cid:101)gi, resulting ﬁnally in expressions for gf

Continuing in this fashion, 22n+1 users can ﬁnd an element in G1 that is
just g0 raised to some power which is known and can easily be removed. If they
apply all powers and products in parallel to the corresponding h4,j, then they
0 . In fact, they
also obtain gz
i and
for all i. Using these elements, anyone can calculate a valid credential over
gf z
i
any set of attributes as explained below. The amount of users that need to work
together to achieve this (22n+1) is exponential in n (the amount of attributes of
the system) but not in the security parameter. Therefore, this can be done in
polynomial time.

0 , and (cid:101)gz

0 = gf z

i , gz

Remark 1. An alternative explanation for why this is possible is as follows. Sup-
pose we are given m valid credentials, with h3,j of credential j given by (1).
Notice that the operations we apply to the elements h3,j and h4,j above corre-
spond exactly to taking linear combinations of the h3,j and h4,j (although linear
combinations are usually written additively instead of multiplicatively). So if we

consider the elements gi,(cid:101)gi occurring in h3,j as unknowns, then we can interpret
of linear equations to the gi,(cid:101)gi, gf z

Using linear algebra over the ﬁeld Zq = GF(q), then, we can solve this system
i , as long as the square matrix of the

equation (1) as one equation in 2n + 2 unknowns. Thus if we have m := 2n + 2
credentials, then we obtain 2n + 2 equations in as many unknowns.

i = (cid:101)gz

coeﬃcients,

yi,j,(cid:101)yi,j are under our control in a chosen-message attack, this should be easy

is invertible (i.e., its determinant det M is unequal to 0). Since the numbers
to achieve. If we write mi,j for the j-th entry of the i-th row of the inverse M−1
of M, we obtain



(cid:101)y0,1 ··· (cid:101)y0,2n+2
y0,1 ··· y0,2n+2
...
...
(cid:101)yn,1 ··· (cid:101)yn,2n+2
yn,1 ··· yn,2n+2

...



M :=

2n+2(cid:89)
2n+2(cid:89)

j=1

gi =

gz
i =

hm2i+1,j
3,j

,

hm2i+1,j
4,j

,

2n+2(cid:89)
2n+2(cid:89)

j=1

(cid:101)gi =
(cid:101)gz

i =

hm2i+2,j
3,j

,

hm2i+2,j
4,j

.

j=1

j=1

4

This also shows that the scheme is already completely forgeable (in the sense
that new credentials with arbitrary attributes can be computed) with just 2n + 2
collaborating users, instead of 22n+1.

3.2 Constructing a forged credential

constructed above, a new credential with at-
Using the elements gi, gf
tributes x1, . . . , xn may be constructed as follows. Choose b1, b2 ∈R Zq randomly,
and set

i , gf z

i , gz

i

1 ··· gxn
h = g0gx1
n ,
1 )x1 ··· (gf
0 (gf
h2 = gf
n)xn,
1 )b2x1 ··· gb1xn
(gf
0 (gf
0 )b2gb1x1
h3 = gb1
0)b1 (gf z
1)b1x1(gf z
h4 = (gz
0 )b2 (gz

n

1

(gf

n)b2xn ,

1 )b2x1 ··· (gz

n)b1xn (gf z

n )b2xn.

Then

h2 = hf ,

h3 = hb1hb2
2 ,

h4 = (hb1hb2

2 )z

as required.

4 The problem in the unforgeability argument

An argument for unforgeability is given in [9] in section 4, “Security Analysis”.
The argument is based on the appendix from [11], in which it is argued that
credentials of the form

h, h2 = hf , h4 = (hb1hb2

2 )z

(2)

are unforgeable. Here, as above, f and z are the issuer’s secret key, and the
numbers b1, b2 are part of the credential (i.e., known to the user). However, the
diﬀerence with Verheul’s system is that there h is randomly chosen from G1,
and in particular, no participant of the system knows the discrete log of h with
respect to any other element from G1, or any DL-representation of h (i.e., an
expression of h in terms of powers of g0, . . . , gn, such as (3)). By contrast, in
Hanzlik and Kluczniak’s U-Prove scheme the user knows numbers α, x1, . . . , xn
such that

h = (g0gx1

1 ··· gxn

n )α.

(3)

where the elements g0, . . . , gn are the same for all users. In this case, the argument
from [11] does not apply, so that no argument can be based on it.

In addition, we wish to point out that the argument from the appendix in [11]
was meant as a sketch, and in particular, there is the following subtlety. It is

5

argued in the appendix that if an adversary A manages to forge credentials of
the form (2), i.e.

(h, h2, h4, b1, b2) = A(cid:16)

(hj, h2,j, h4,j, b1,j, b2,j)j=1,...,m

(cid:17)

where the output (h, h2, h4, b1, b2) is valid (i.e., satisfying (2)), then either there
must exist a j and numbers k, (cid:96) ∈ Zq such that

(h, h2, h4, b1, b2) = (hk

j , hk

2,j, hk(cid:96)

4,j, b1,j(cid:96), b2,j(cid:96))

or the adversary A can be used to solve discrete logarithms in G1. However,
the argument mentions certain “transformation factors” which are numbers like
k, (cid:96) from Zq, and the algorithm sketched by [11] that uses the adversary A to
compute discrete logarithms would need to know these numbers in order to be
able to work. However, it is not clear how to obtain these transformation factors
from the adversary A, or even if A is aware of them. We believe, however,
that they can be extracted from the adversary by an extension of the Known
Exponent Assumption (see [7], where this assumption was introduced, and for
example [2] and [4]).

References

1. Alpár, G., Hoepman, J., Siljee, J.: The identity crisis. security, privacy and usability
issues in identity management. CoRR abs/1101.0427 (2011), http://arxiv.org/
abs/1101.0427

2. Bellare, M., Palacio, A.: The knowledge-of-exponent assumptions and 3-round zero-
knowledge protocols. In: Franklin, M. (ed.) Advances in Cryptology – CRYPTO
2004, Lecture Notes in Computer Science, vol. 3152, pp. 273–289. Springer Berlin
Heidelberg (2004)

3. Bichsel, P., Camenisch, J., Dubovitskaya, M., Enderlein, R.R., Krenn, S., Kro-
ntiris, I., Lehmann, A., Neven, G., Nielsen, J.D., Paquin, C., Preiss, F.S., Ran-
nenberg, K., Sabouri, A., Stausholm, M.: D2.2 architecture for attribute-based
credential technologies. Technical report, ﬁnal version, ABC4Trust (2014), https:
//abc4trust.eu/download/Deliverable_D2.2.pdf

4. Bitansky, N., Canetti, R., Chiesa, A., Goldwasser, S., Lin, H., Rubinstein, A.,
Tromer, E.: The hunting of the SNARK. IACR Cryptology ePrint Archive 2014
(2014), https://eprint.iacr.org/2014/580

5. Blake, I.F., Seroussi, G., Smart, N.P. (eds.): Advances in Elliptic Curve Cryptog-

raphy. Cambridge University Press (2005), cambridge Books Online

6. Brands, S.: Rethinking Public Key Infrastructures and Digital Certiﬁcates: Build-

ing in Privacy. MIT Press (2000)

7. Damgård, I.: Towards practical public key systems secure against chosen cipher-
text attacks. In: Feigenbaum, J. (ed.) Advances in Cryptology - CRYPTO ’91, 11th
Annual International Cryptology Conference, Santa Barbara, California, USA, Au-
gust 11-15, 1991, Proceedings. Lecture Notes in Computer Science, vol. 576, pp.
445–456. Springer (1991)

8. Galbraith, S.D., Paterson, K.G., Smart, N.P.: Pairings for cryptographers. Discrete

Applied Mathematics 156(16), 3113–3121 (2008)

6

9. Hanzlik, L., Kluczniak, K.: A short paper on how to improve U-Prove using self-
blindable certiﬁcates. In: Christin, N., Safavi-Naini, R. (eds.) Financial Cryptogra-
phy and Data Security. pp. 273–282. Lecture Notes in Computer Science, Springer
Berlin Heidelberg (2014)

10. Paquin, C., Zaverucha, G.: U-prove cryptographic speciﬁcation v1.1 (revision 3)
(December 2013), http://research.microsoft.com/apps/pubs/default.aspx?
id=166969, released under the Open Speciﬁcation Promise

11. Verheul, E.R.: Self-blindable credential certiﬁcates from the weil pairing. In: Boyd,
C. (ed.) Advances in Cryptology - ASIACRYPT. Lecture Notes in Computer Sci-
ence, vol. 2248, pp. 533–551. Springer (2001)

7

