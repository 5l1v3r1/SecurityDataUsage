Lattice Basis Reduction Attack against Physically

Unclonable Functions

Fatemeh Ganji1, Juliane Krämer2, Jean-Pierre Seifert1, Shahin Tajik1

1Security in Telecommunications

Department of Software Engineering and Theoretical Computer Science

Technische Universität Berlin and Telekom Innovation Laboratories

{fganji, jpseifert, stajik}@sec.t-labs.tu-berlin.de

Berlin, Germany

2Cryptography and Computer Algebra

Department of Computer Science
Technische Universität Darmstadt

Darmstadt, Germany

jkraemer@cdc.informatik.tu-darmstadt.de

ABSTRACT
Due to successful modeling attacks against arbiter PUFs
(Physically Unclonable Functions), the trend towards con-
sideration of XOR arbiter PUFs has emerged. Nevertheless,
it has already been demonstrated that even this new non-
linear structure, with a restricted number of parallel arbiter
chains, is still vulnerable to more advanced modeling attacks
and side channel analyses. However, so far the security of
XOR arbiter PUFs with a large number of parallel arbiter
chains has not been appropriately assessed. Furthermore,
as another countermeasure against modeling and physical
attacks, the concept of controlled PUFs, i.e., with a limited
access to challenges and responses, has also been developed.
Towards a better understanding of the security of XOR ar-
biter PUFs, the present paper simultaneously addresses all
above mentioned countermeasures by introducing a novel
attack, which is a combination of a lattice basis reduction
attack and a photonic side channel analysis. We present how
our new attack can be successfully launched against XOR
arbiter PUFs with an arbitrarily large number of parallel ar-
biter chains. Most interestingly, our attack does not require
any access to challenges or responses. Finally, by conduct-
ing an exhaustive discussion on our experimental results,
the practical feasibility of our attack scenario is proved as
well.

Categories and Subject Descriptors
B.7.m [Integrated Circuits]: Miscellaneous; C.3 [Special-
Purpose and Application-Based Systems]: Smartcards;
E.3 [Data Encryption]: Code breaking

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
© 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813723.

General Terms
Theory; Hardware security

Keywords
Physically Unclonable Functions; XOR arbiter PUFs; Lat-
tice basis reduction; Hidden subset sum problem; Photonic
emission analysis

INTRODUCTION

1.
Physically Unclonable Functions (PUFs) have been intro-
duced, among many other cryptographic applications, to
protect integrated circuit (IC) designs against counterfeit-
ing [12, 25]. As the previously suggested protection tech-
niques, such as storage of a secret key in non-volatile mem-
ory (NVM), have been rather ineﬀective against invasive at-
tacks [14, 16], the importance of the concept of PUFs has
been stressed by several IC manufacturers. The inherent
security associated with the physical characteristics of ICs
make PUFs interesting for IC manufacturers, and attackers
as well. These essential characteristics can be tailored to
the speciﬁc needs of hardware authentication and identiﬁca-
tion [19].
As a prime example, the principle underlying the design of
arbiter PUFs is the intrinsic delays of the symmetrically de-
signed delay lines, consisting of logic gates in an IC [17]. Due
to the subtle diﬀerences between these delays, a respective
arbiter PUF generates a (virtually unique) response to a so
called given challenge. Although this concept is well suited
for security requirements in theory, in practice several ma-
chine learning (ML) attacks against arbiter PUFs have been
successfully launched [17]. Here, the adversary collects a
small subset of challenge-response pairs (CRPs) to build a
mathematical model of the challenge-response behavior of
the arbiter PUF. By launching an ML attack, a mathemati-
cal model may be delivered, which can predict the responses
of the PUF with some accuracy for an arbitrarily chosen
challenge. However, the delivery of the mathematical clone
is not always guaranteed. Just recently, a novel probably
approximately correct (PAC) learning framework has been

1070developed, which ensures the ultimate delivery of a mathe-
matical clone for pre-deﬁned levels of conﬁdence and accu-
racy [10]. Therefore, arbiter PUF manufacturers have been
forced to propose countermeasures including XOR arbiter
PUFs as an eﬀective technical action [34].
When applying a challenge to an XOR arbiter PUF com-
posed of several arbiter chains, the joined response is gen-
erated by XORing all responses of the respective arbiter
chains. It has been demonstrated that XOR arbiter PUFs
are also subject to advanced and signiﬁcantly more complex
ML attacks [27]. The number of arbiter chains can be a
limiting factor for this type of attacks, hence, the attack
is eﬀective only against XOR arbiter PUFs with a small
number of arbiter chains. Moreover, it has also been shown
that when the number of arbiter chains exceeds this lim-
ited number, additional side channel analyses can be com-
bined with an ML attack to compromise the security of an
XOR arbiter PUF [30]. Otherwise the number of CRPs,
and consequently the time, required to launch an ML at-
tack increases drastically [37]. It remains an open question
whether the challenge-response behavior of an XOR arbiter
PUF with a large number of arbiter chains (e.g., more than
16) can be learned by launching ML attacks. On the other
hand, although being costly, semi-invasive attacks can be a
promising solution leading to a complete and linear charac-
terization of XOR arbiter PUFs. It has been demonstrated
that arbiter as well as XOR arbiter PUFs can be physically
characterized by performing a high resolution temporal pho-
tonic emission analysis [13, 35]. Due to the fact that this
attack does not require the response of the PUF, the num-
ber of required measurements is only linear in the number
of stages.
It is also clear that when the attacker cannot directly control
the challenge-response behavior of the PUF, the aforemen-
tioned attacks cannot be mounted. For instance, when an
attacker relying on the direct control of the challenges can-
not apply the desired challenge, an ML or a physical attack
would obviously fail. This promotes the introduction of a
special type of PUF protocols (e.g., Controlled PUF [11],
Slender PUF [21], and Recyclable PUFs [15]), where a part
of, or all, challenge bits are generated by using either hash
functions or True Random Number Generators (TRNGs).
The main building blocks of these protocols are legacy ar-
biter PUFs and XOR arbiter PUFs [9], although the key
message given in the above discussion is that these PUFs
are not as secure as being claimed. This highly motivates
not only the manufacturers to invest in this kind of PUFs,
but also the attackers for further investigation.
Our present work is to the best of our knowledge the ﬁrst
study, which proves that an increase in the number of ar-
biter chains is not a “silver bullet”, but rather a very lim-
ited step towards improving the robustness of XOR arbiter
PUFs against attacks, if not being a step to reduce the se-
curity. Furthermore — and more importantly — in our at-
tack scenario, an access to neither the challenges nor the
responses is required. In brief, our main contributions are
as follows:
• We present a novel mathematical proof of the vulner-
ability of legacy and controlled XOR arbiter PUFs to
lattice basis reduction attacks. Speciﬁcally, we present
how the lattice basis reduction attack proposed by
Nguyen et al. [23] can be extended to compromise the
security of XOR arbiter PUFs.

• We describe how a photonic side channel analysis can
be combined with the lattice basis reduction attack to
disclose the hidden challenges applied to a controlled
XOR arbiter PUF with an arbitrarily large number of
arbiter chains.
• Extensive experiments are conducted to validate the
performance of our lattice basis reduction framework,
qualitatively and quantitatively.

The present paper is organized as follows. The next chapter
introduces PUFs, arbiter PUFs, and XOR arbiter PUFs. It
continues with a brief introduction into the basics of lattices
and the original hidden subset sum problem. Afterwards,
in Section 3 we elaborate on the photonic side channel data
acquisition providing input data for our lattice basis reduc-
tion algorithm. Section 4 is our main section, which explains
how the notion of the extended (multi-dimensional) hidden
subset sum problem can be applied to completely break the
security of the XOR arbiter PUF family without knowing
the challenges or their respective responses. Therefore, we
explain how the original hidden subset sum must be ex-
tended and how we can overcome its main obstacles in the
case of XOR arbiter PUFs. Section 5 presents subtle imple-
mentation details of our lattice basis reduction attack and
its excellent results regarding the characterization of XOR
arbiter PUFs with a large number of parallel chains. Section
6 concludes our paper by summarizing and outlining future
work, where the newly developed framework can be applied
to asses the security of XOR arbiter PUFs.

2. DEFINITIONS AND PRELIMINARIES
This section provides the background, important notations,
and context information, which are useful to understand the
general concept of arbiter and XOR arbiter PUFs. Further-
more, we provide a brief introduction to lattices and hidden
subset sum (knapsack) problems. We also derive a repre-
sentation of an XOR arbiter PUF under the notion of this
subset sum (knapsack) problem.
2.1 PUF
PUFs, as a general concept, rely on intrinsic properties of
a physical system, which embodies them. In general, PUFs
can be thought of as mappings, which generate a response
for a given challenge. Here we brieﬂy describe the basic
characteristics of an ideal PUF, and for a formal foundation
and the formalization of the security of PUFs we refer the
reader to [2].
Deﬁnition 1. Let X = {0,1}n and Y = {0,1} be the set
of challenges and the set of responses, respectively. A PUF
can be represented by the function fPUF : X → Y where
fPUF(x) = y, cf. [19]. Note that fPUF is not a one-to-one
mathematical function.
Ideally, fPUF aims to provide the
following security-related properties.

1. Evaluable: fPUF can be evaluated in polynomial time.
2. Unique: for a given PUF instance, the mapping fPUF

is instance-speciﬁc.

3. Reproducible: applying same challenges to fPUF re-
sults in “close” responses with respect to a chosen dis-
tance metric.

4. Unclonable: for a given PUF fPUF it is (almost) im-
possible to construct another mapping (i.e., physical
entity) gPUF so that “gPUF ≈ fPUF”.
for a given set U = {(xi, yi) | yi =
fPUF(xi)}, it is (almost) impossible to predict a re-

5. Unpredictable:

1071en

ai,1
ai,2

ai,3
ai,4

r

arbiter

b1

b2

x[1] = 0

x[i] = 0

x[n] = 1

Figure 1: Schematic of an arbiter PUF composed of n stages
and a ﬁnal arbiter. Four diﬀerent delays in each stage are
shown. The signal propagates through either the direct
paths or the crossed paths based upon the applied challenge
x. The binary response is generated by the ﬁnal arbiter and
depends on the arrival times of the signals.

sponse yr = fPUF(xr), where xr is a random challenge
and (xr, yr) /∈ U .

6. One-way:

for a given random PUF instance y =
fPUF(x), where x is drawn from a uniform distribu-
tion on {0,1}n, we have

Pr[A(fPUF(x)) = x] < 1/p(n),

where p(·) is any positive polynomial. This means that
the probability that any probabilistic polynomial time
algorithm or physical procedure A can output x is neg-
ligible, cf. [26]. In other words, it is hard to ﬁnd x,
if the respective response of a random instance of the
PUF family is known, and the adversary can evaluate
the PUF a polynomial number of times [18].

The existing types of PUFs can only partially fulﬁll the
above mentioned requirements. For instance, it has been
demonstrated that one-wayness (as formulated in Deﬁni-
tion 1) and unclonability cannot be fulﬁlled for arbiter PUFs.
Nevertheless, the discussion on the formalization of PUF
properties is beyond the scope of this paper and the reader
is referred to [2, 28] for more details.
One of the most promising candidates for PUF instances,
which have been already widely accepted and utilized, are
delay-based PUFs. For these PUFs, the silicon properties of
a chip can be used eﬀectively to meet the above mentioned
requirements of PUFs.
2.2 Arbiter PUFs
For this special and widely accepted kind of PUFs, the
non-symmetrical timings of symmetrically designed electri-
cal paths on a chip play a major role for the implementation
of the PUF. As illustrated in Figure 1, n switches (so called
stages) form a chain, which is terminated by an arbiter. A
challenge is an n-bit row vector x = (x[1],··· , x[n]), where
the ith bit is fed into the ith stage (e.g., multiplexer). x[i]
determines through which path in the ith stage the signal
propagates:
if x[i] = 1, the crossed paths are chosen, oth-
erwise the direct paths. When enabling the input signal at
the ﬁrst stage, two electrical signals propagate on two sym-
metrically designed paths to reach the end of the chain. The
arrival times of these two signals diﬀer due to the imperfec-
tions on the silicon. According to this diﬀerence, individual
binary outputs of the arbiter are generated.
In order to represent the delays within the ith stage, we de-
ﬁne a random variable Ai that follows a Gaussian distribu-
tion with the mean µi and the deviation ωi, cf. [10, 29]. The
four realizations of this random variable are ai,j (1 ≤ j ≤ 4),
where ai,1 and ai,4 correspond to the delays of the upper
and lower direct paths, whereas ai,2 and ai,3 are the delays

Table 1: Mapping table for each bit of the challenge
vector x.

x[i]

0
0
1
1

ui
0
1
0
1

x1[4i − 3]

x1[4i − 2]

x1[4i − 1]

x1[4i]

1
0
0
0

0
0
1
0

0
0
0
1

0
1
0
0

x[i] = 0

x[i + 1] = 1

Figure 2: A path and its complementary path for two chal-
lenge bits are shown. The functions f1 and f2, as presented
in Table 1 and Table 2, are used to deﬁne these paths more
systematically.

of the upper and lower crossed paths, respectively, see Fig-
ure 1. Similarly, bj is the realization of a Gaussian random
variable for the total delay between the enable point and the
outputs of the last stage of the PUF (j = 1 for upper path
and j = 2 for lower path). In order to generate the binary
output, the arbiter compares the diﬀerence of the signal ar-
rival times with its limited precision γ.
If the diﬀerence
b1 − b2 is greater than, or equal to, the arbiter precision γ
(γ > 0), it generates a “1”, whereas if b2 − b1 ≥ γ, the re-
sponse is a “0”. The case of |b2 − b1| < γ, also called the
meta stable case, must have been already resolved by the
manufacturer, when verifying the respective PUF proper-
ties. However, since responses of a PUF to given challenges
are not considered in our attack scenario, the functionality
and the eﬃciency of our framework are not aﬀected in this
case.
It has been shown that the accumulated real-valued de-
lays bj lie with probability 99.7 % within the interval [nµ −
n], cf. [10]. Therefore, regarding the re-
3ω
stricted length of this interval as well as the limited precision
of the arbiter (γ), cf. [20], all above mentioned real-valued
delays can be mapped to certain integer values lying within
the interval [0,(cid:100)(nµ + 3ω
n)/γ(cid:101)]. We can therefore treat all
delays bj and also ai,j as integers, bounded by some value
M where

√
n, nµ + 3ω

√

√

M = O(n).

The integer values corresponding to the previously deﬁned
real-valued delays are presented by ai,j and bj, respectively.
To account for the diﬀerent path conﬁgurations for a given
challenge x, we deﬁne the following one-bit value, cf [10]:

i(cid:76)

ui =

x[k].

k=1

Moreover, the vector of a challenge x is mapped to a vector
x1. This reﬂects the impact of the path conﬁgurations more
systematically, cf. [35]. Thus, we deﬁne the mapping f1 :
{0, 1}n → {0, 1}4n such that x1 = f1(x) presents how each
element of x is mapped to four elements in x1 according to
Table 1.
Obviously, for each path, which has been followed by a sig-
nal, a complementary path can be deﬁned, see Figure 2. The

1072Table 2: Challenge mapping table for the complementary
path, when the challenge vector x is applied.

x[i]

0
0
1
1

ui
0
1
0
1

x2[4i − 3]

x2[4i − 2]

x2[4i − 1]

x2[4i]

0
1
0
0

0
0
0
1

0
0
1
0

1
0
0
0

mapping f2 : {0, 1}n → {0, 1}4n, such that x2 = f2(x) ex-
plains the relationship between x2 and the challenge vector
applied to the arbiter PUF, see Table 2. Hence, choosing a
path or its complementary results in obtaining the overall
delay on the lower or upper path at the output of the last
stage, i.e., b1 or b2.
The above mentioned deﬁnitions of a path and its comple-
mentary path enable a very useful and eﬃcient representa-
tion of the linear (more speciﬁcally, knapsack) behavior of
arbiter PUFs. To this end, let the column vector a ∈ Z4n
be composed of delays of all stages, i.e.,

a = (a1,1, a1,2, a1,3, a1,4, . . . , an,1, an,2, an,3, an,4)t.

(1)

ai,1
ai,2

ai,3
ai,4

x[1] = 0

x[i] = 0

x[n] = 1

en

x[1] = 0

x[i] = 0

x[n] = 1

ai,1
ai,2

ai,3
ai,4

arbiter

arbiter

arbiter

r

x[1] = 0

x[i] = 0

x[n] = 1

Figure 3: An XOR arbiter PUF has k parallel arbiter chains,
each with n stages and an arbiter. The joint binary response
is generated by XOR-ing the responses of all individual ar-
biter chains.

4n(cid:88)

Regarding the deﬁnitions of the functions f1 and f2, as well
as the linear challenge-response behavior of an arbiter PUF,
the total delay bj at the end of the last stage can be given
concisely by the equation

bj =

xj[k]a[k] = xj · a.

(2)

k=1

Now consider the column vector b ∈ {0, . . . , M}2m, whose
elements are the total delays at the end of the last stage on
the upper and the lower path obtained for m challenges:

b = (b1

1, . . . , bi

1, . . . , bm

(3)
Let X ∈ {0, 1}2m×4n be the matrix of m mapped challenges,
i.e., its rows are the m challenges mapped by applying the
functions f1 and f2. Thus, we have

2, . . . , bm

2 )t.

2, . . . , bi

1 , b1





x1
1
...
xm
1
x1
2
...
xm
2

X =

b = X · a.

(4)

(5)

which gives the following compact (knapsack-like) form of
an arbiter PUF

2.3 XOR Arbiter PUFs
XOR arbiter PUFs have been developed to improve the se-
curity of arbiter PUFs, and more precisely, to mitigate dif-
ferent types of attacks, ranging from ML attacks to fully
invasive attacks. It has been proposed that the outputs of k
arbiter chains, having the same number of PUF stages (see
Figure 3), should be XOR-ed together to generate the ﬁnal
output of the PUF, cf. [34].
Obviously, the ﬁnal response of an XOR arbiter PUF to a
given challenge x can be simply deﬁned as

k(cid:77)

j=1

fXOR(x) =

fjth arbiter PUF(x).

But regardless of having the XOR operator, the total delay
at the last stage of each individual arbiter PUF can still
be measured, e.g., following the procedure introduced by
Tajik et al. [35] (see Section 3 for more details). This crucial
observation is central to the following linearization of the
XOR arbiter PUF.
In order also to obtain a system of linear equations explain-
ing the functionality of an XOR arbiter PUF, the equations
presented for an arbiter PUF can be extended as follows.
First, we deﬁne the matrix A ∈ {0, . . . , M}4n×k in which
the ith column corresponds to the integer-valued delays of
the ith arbiter PUF chain. This means that we have
··· a1
...
...
··· ak

(cid:0)a1, . . . , ak(cid:1) :=

··· a1
...
...
··· ak

··· a1
...
...
··· ak

a1

t

...
ak
1,1

n,4

n,4

n,1

n,1

1,1

,

1,4

1,4

(6)
i,j ∈ [0, M ] for 1 ≤ i ≤ n, 1 ≤ j ≤ 4, and 1 ≤ l ≤ k.
where al
Similarly, the matrix B ∈ {0, . . . , M}2m×k is deﬁned as a
matrix composed of the accumulated delays at the output
of the last stage (for upper and lower path) of all k arbiter
chains, when applying m challenges, i.e.,

(cid:0)b1, . . . , bk(cid:1) :=

b1,1

...
bk,1
1

1

···
...
···

b1,m
1
...
bk,m
1

b1,1
2
...
bk,1
2

···
...
···

b1,m
2
...
bk,m
2

t

. (7)

Thus, we obtain again a very compact (and linear) form of
an XOR arbiter PUF

B = X · A.

(8)

2.4 Lattices
Here we give only a very brief outline of the notion of lattices
as well as the closely related ﬁeld of subset sum problems,
and especially the hidden subset sum problem. For a de-
tailed introduction we refer the reader to [6, 22, 24].
Deﬁnition 2. A set L is an integral lattice of dimension m
if it is a discrete additive subgroup of Zm.

1073Therefore, there exist n linearly independent vectors b1, . . . , bn ∈
Zm such that the integer linear combinations of these vectors
generate L, or in other words

(cid:40) n(cid:88)

i=1

(cid:41)
(cid:12)(cid:12)(cid:12) xi ∈ Z

.

xi · bi

L = L(b1, . . . , bn) =

We call {b1, . . . , bn} a basis of L and n the rank of the
lattice. For m = n, the lattice is said to have full rank.
For a lattice L we denote by det(L) its determinant and by
λ1(L) the Euclidean length of a shortest non-zero vector of
L. The main result from Minkowski states that

λ1(L) ≤ √

n · det(L)1/n

Algorithm 1 Algorithm for disclosing the hidden coeﬃ-
cients of a random HSS as proposed by [23]
Require: Vector b ∈ Zm, m, and n
Ensure: Vectors xi, 1 ≤ i ≤ n
1: Calculate the orthogonal lattice b⊥
2: Compute a reduced basis of b⊥,

i.e., (u1, u2, . . . , um−1) :=

the

BKZ(b⊥, blocksize = 20)
3: Compute
BKZ((u1, u2, . . . , um−n−1)⊥ , blocksize = 20)
x = 2 ¯Lx + Z · (1, . . . , 1)
4: L(cid:48)
5: BKZ(L(cid:48)
X , blocksize = 20)
6: Find the basis vectors of L(cid:48)
7: return xi

lattice:

hidden

x with the form ± (2xi − (1, . . . ,1))

¯Lx

:=

for a lattice L of rank n. The Gaussian volume heuris-
tic, cf. [24], suggests also that “random” lattices act well-
behaved. It postulates that for a random lattice L of rank
n we can assume that
√
n · det(L)1/n

= Θ(1).

λ1(L)

Deﬁnition 3. For a lattice L ⊆ Zm, its orthogonal lattice
L⊥ is deﬁned as the set of vectors in Zm, which are orthog-
onal to all elements of L with respect to the inner product.
We also need to deﬁne ¯L, the orthogonal lattice of L⊥, i.e.,
the lattice ¯L = (L⊥)⊥. For a lattice L ⊆ Zm it holds that
det(L⊥) = det( ¯L).
2.5 The Hidden Subset Sum Problem
The Hidden Subset Sum problem (HSS) was introduced in
1998 as a variant of the subset sum problem, where the ac-
cumulated sum is known, but the set of summands is secret,
i.e., hidden [5].
Deﬁnition 4. Given a positive integer M ∈ Z and a vector
b = (b1, . . . , bm) ∈ Zm
M , the Hidden Subset Sum problem is
to ﬁnd integers a1, . . . , an ∈ ZM so that each bi is a subset
sum modulo M of the summands a1, . . . , an, i.e., there exist
binary vectors x1, . . . , xn ∈ {0, 1}m and a vector k ∈ Zm
satisfying

b = a1x1 + a2x2 + . . . + anxn + M k.

2.5.1 Solving the Hidden Subset Sum Problem with

Lattices

In 1999, Nguyen and Stern presented a cryptanalytical at-
tack against the hidden subset sum problem in a break-
through work, cf. [23]. Speciﬁcally, they described a lattice-
based attack against the HSS, upon which our attack against
XOR arbiter PUFs is build. Their attack has three steps.
First, from the known vector b, the lattice ¯L = (L⊥)⊥ for
L = L(x1, . . . , xn, k) with b ∈ L is determined. Due to the
random construction of the underlying HSS, it is plausible to
assume that the vectors xi and k are linearly independent.
To determine ¯L, ﬁrst a reduced basis of b⊥ is computed.
The lattice b⊥ has rank m − 1. Afterwards, a basis for the
lattice ¯L, which is “very likely” spanned by the “shortest”
m− (n + 1) vectors of that reduced basis, is computed. The
lattice ¯L has rank n + 1. This step is expected to succeed
only if the quantity

n/ log2(M )

is very small, which is true if M is very large. Second,
from ¯L, the secret binary vectors x1, . . . , xn are derived.
By applying the former Gaussian volume heuristic, these

TDC

APD

en

r

arbiter

x[1] = 0

x[i] = 0

x[n] = 1

Figure 4: A high resolution Time to Digital Converter
(TDC) measures the duration between the triggering time of
the PUF and the time when a photon from the ﬁrst output
of the ith stage is captured by an Avalanche Photodiode.

vectors are assumed to be short lattice vectors due to their
binary entries, hence they are derived from a reduced basis
of ¯L. Since vectors with entries 0, 1, and −1 might also be
short vectors in such a reduced basis, the lattice is slightly
modiﬁed to ﬁnd the correct binary vectors x1, . . . , xn. These
two steps are depicted in Algorithm 1. Third, using the
known vectors b, x1, . . . , xn, and M , the secret summands
a1, . . . , an ∈ ZM are recovered. This can be performed by
adopting any approach to solve a system of modular linear
equations.

3. PHYSICAL DATA ACQUISITION FOR

ARBITER PUF ENTITIES

Our lattice basis reduction can be launched only if the ad-
versary can measure the delays at the output of the last
stages, and more generally, between any two arbitrary cho-
sen stages. We explain here how to achieve this in practice
for a given PUF implemented on a chip.
The inventors of arbiter PUFs have assumed that an at-
tacker cannot directly measure the individual delays of stages.
Moreover, they also assume that the delays could only be
measured by applying fully-invasive techniques, which would
lead to physical changes, and ﬁnally to substantial changes
in the PUF and its intrinsic challenge/response behavior.
Therefore, in their scenario the attacker is only able to set
the challenges and read their respective responses.
However, it has been shown that diﬀerent side channel anal-
yses can indeed reveal the delays at the outputs of the last
stage of the PUF [3, 30, 35]. Power analysis of delay-based
PUFs enables the attacker to measure the delay diﬀerence
between the PUF excitation time and the logical transi-
tions time of the latch (i.e., the arbiter) terminating the
chain [3, 30]. The delays and the binary response of the

1074PUF can be extracted by gathering several power traces for
a single challenge and applying statistical signal processing
techniques on them to reduce the noise of measurements.
The main limitation of power analysis is that the delays of
individual upper and lower paths of an arbiter PUF cannot
be derived from power traces. Moreover, in the XOR arbiter
PUF architecture, the delays of each individual arbiter chain
cannot be diﬀerentiated in the traces.
On the other hand, timing side channel analyses enable the
attacker to measure the delays of both upper and lower path
individually [30]. To collect the timing information, the at-
tacker has to access the dedicated debugging clock sweeping
circuits on the chip, which are embodied in the chip by the
manufacturer [20]. By changing the frequency of the clock,
which is swept through the arbiter chains of the XOR arbiter
PUF, the attacker can measure the delays of each path. Al-
though timing side channels enable the attacker to measure
the delays with picosecond resolution, the assumption that
the attacker can utilize this kind of clock sweeping circuit
might not be valid in a real attack scenario.
In order to measure the delays of the paths without using any
extra circuitry, the high resolution temporal photonic emis-
sion analysis from the IC backside can be utilized, cf. [35].
In this case, the attacker can measure the delay between the
enabling time of the PUF and the emission time of photons
from a CMOS transistor by using an Avalanche Photodiode
(APD) at the outputs of any arbitrary stage, see Figure 4.
XOR arbiter PUFs can be implemented eﬀectively on pro-
grammable logic devices, such as Complex Programmable
Logic Devices (CPLDs) and Field Programmable Gate Ar-
rays (FPGAs). On such platforms, each stage of the arbiter
PUF is implemented by two logic elements (LEs), see Fig-
ure 5 (a). The location of diﬀerent combinational circuits,
e.g., an arbiter PUF, can be found on the chip with the help
of spatial photonic emission analysis [35, 36]. After ﬁnding
the PUF circuitry and the respective input/outputs of each
stage, the delay between the inputs of the ith stage and out-
puts of the jth stage can be measured in three steps.
First, the attacker measures the delay between the excitation
time of the electrical pulse on the enable input of the chip
and the photon emission time of input transistors of the ith
LE, see Figure 5 (b). Second, the delay between the enabling
time and the photon emission time of the output transistors
of the jth stage has to be measured in a similar fashion,
see Figure 5 (b). Third, by subtracting these two measured
values, the desired delay value between two stages can be
derived.
It has been proved that an arbiter PUF can be physically
characterized by measuring just the total delays at the end
of each path for n+1 challenges, where the diﬀerence of their
Hamming distances is equal to 1 [35]. Based on this tech-
nique, a comparison between the reference challenge and any
arbitrary challenge can be made to predict the delay at the
end of the path, and hence, the response. The same method-
ology can be deployed to physically characterize XOR ar-
biter PUFs, regardless of the number of parallel arbiter
chains, by simply controlling two APDs for each individual
arbiter chain. To this end, each arbiter chain is character-
ized individually. The main drawback of this attack is that
the adversary has to control the challenge in order to set
n + 1 challenges, with Hamming distance from one another
equals 1.

However, if there is no electrical access to the challenges of
the PUF (such as controlled PUFs), the attacker faces the
problem of so called hidden challenges and obtains ﬁnally
only the total delays corresponding to the applied, but hid-
den challenges. Nevertheless, the attack proposed in this
paper does not require any special challenges (in terms of
the Hamming distance) to be applied. To launch this at-
tack, the attacker measures only the delays at the outputs
of the desired stages by programming the coordination of
the optical objective, and consequently, automatically mov-
ing them to the desired positions to capture the emitted
photons.
Although the measurement noise seems to have a destructive
impact on the eﬀectiveness of our attack, it is irrelevant due
to the following reason. The precision of the measurement
setup used for the raw physical data acquisition is naturally
higher than the precision of the arbiter terminating each
chain. Hence, the impact of the measurement noise is ir-
relevant, as the delays are mapped to integer-valued delays
(see Section 2.2), where the mapping absorbs the impact of
measurement noise.

4. EXTENDED HIDDEN SUBSET SUM

PROBLEM

In this section we aim to reveal the hidden coeﬃcients of a
controlled XOR arbiter PUF by using the techniques intro-
duced in [23] as well as Section 2.5 of this paper.
In order to explain how our proposed attack can be launched
on XOR arbiter PUFs, we begin by comparing Eq. (5) for
an ordinary arbiter PUF with the deﬁnition of the hidden
subset sum as given by Deﬁnition 4. Excluding minor diﬀer-
ences, which will be resolved in this section, our intentionally
chosen notations show a strong similarity between a PUF in
the form of b = X·a and the hidden subset sum problem. As
previously explained, for a given physical PUF (i.e., in the
form of a real circuit) and its abstract model represented by
the vector a, it is indeed possible to construct the total delay
vector b by simply measuring certain signal propagation de-
lays, without even knowing the set of challenges applied to
the PUF. This means that the matrix of mapped challenges
X is hidden and solely the vector b is accessible. Neverthe-
less, we know that the vector b is constructed according to
Eq. (5) and along with all the speciﬁc subtleties of a given
arbiter PUF. According to this sketch, the relationship be-
tween an arbiter PUF in the form of Eq. (5) and the HSS
becomes obvious. However, the considerable diﬀerences be-
tween the HSS and an XOR arbiter PUF modeled by Eq. (8)
should be carefully taken into account. Section 4.1 aims to
consider these diﬀerences. Section 4.2 is devoted to investi-
gation of the multidimensional HSS as another novelty from
us, which follows the requirements of our lattice basis reduc-
tion attack. Until today, this highly interesting extension of
the HSS has been completely unknown. The principles un-
derlying the multidimensional HSS are inspired by Nguyen’s
work [23], however, the giant step related to the calculation
of a new upper bound on the weights of the multidimensional
HSS is completely performed in our paper.
4.1 Adjustments
Here we focus on resolving the minor diﬀerence between the
model of an arbiter PUF (Eq. (5)) and the HSS.

1075Figure 5: (a) The reﬂected backside image of an Altera MAX V CPLD based on a 180 nm technology, captured by a
laser scanning microscope [36]. The chip consists of Logic Array Blocks (LABs). Each LAB contains 10 Logic Elements
(LEs). (b) The emission image of an 8-bit arbiter PUF on the MAX V CPLD, captured by a Charge-Coupled Device (CCD)
camera [35]. The PUF circuit is enabled by a 4MHz signal. Each bright spot shows a switching NMOS or PMOS transistor,
which emits photons. The attacker can measure the signal propagation delays between start points and end points by moving
the objective to the inputs and outputs of the desired LEs.

4.1.1 Excluding the Modulo Operation
Eq. (5) is an integral equation, whereas the HSS is deﬁned in
terms of modular arithmetic. Reconsidering the respective
mathematical analysis in Section 2.5.1 reveals that only the
rank of the lattice ¯L would change in this non-modular case,
from n + 1 to n. This means that asymptotically no further
change in the mathematical analysis is required. Hence, this
minor diﬀerence is easily resolved.

4.1.2 Distribution of the Vector a
From Section 2.2, it can be understood that the vector a is
generated according to a speciﬁc Gaussian distribution such
that the entries of b can be bounded by M in their expec-
tation value. To explain our lattice basis reduction attack
in an easier manner, we will assume a slightly diﬀerent situ-
ation. However, we emphasize that for the real distribution
a more complex analysis can be performed that would yield
an (asymptotically) equivalent result. Moreover, due to the
heavy use of the Gaussian volume heuristic for the resulting
random lattices, this ﬁne distinction is anyhow quite super-
ﬁcial and therefore omitted. Hence, we can simplistically
assume that the elements of the vector a are uniformly cho-
sen from the set {0, . . . , M}, and thus we can follow the
original HSS analysis of [23].

4.1.3 Mapped Challenges X are not Uniformly

Chosen

Although we assume (as in a real PUF setting) that the
challenge bits are drawn uniformly from the set {0, 1}, this
is not valid for the matrix of mapped challenges X. Indeed,
j ∈ {0,1}4n, 1 ≤ l ≤ m
all its respective challenge vectors xl

and 1 ≤ j ≤ 2, have the ﬁxed Hamming weight n. Resolving
this diﬀerence with the original HSS results in three changes
made in Algorithm 1 (see Section 2.5.1):

1. The lattice L(cid:48)

to be changed to L(cid:48)
the reader to [8] for a theoretical explanation.

x as deﬁned in step 4 of Algorithm 1 has
X = 16LX + Z · (1, . . . , 1). We refer

2. In contrast to the approach in [23], the multidimen-

sional HSS is analyzed.

3. Three centering groups of mapped challenges are ap-

plied in our attack scenario.

The ﬁrst two of these points account for the speciﬁc Ham-
ming weight, whereas the third one addresses the non-uniform
distribution. We explain the second and the third changes
step-by-step.
4.2 Main Result: The Multidimensional HSS
As outlined in Section 2.5.1 and stressed in [23], Algorithm 1
is able to solve a random HSS only if the respective quantity
M is very large, i.e., M must be exponential in n. However,
as explained in Section 2 and very carefully in [10], for ar-
biter PUFs the value M representing the maximum variation
of delays is in the order of O(n) in the best case scenario.
Looking closer at our attack scenario for XOR arbiter PUFs,
we aim at solving Eq. 8, where the unknown matrices X and
A are chosen randomly as explained previously. The diﬀer-
ence is that we now have k vectors (a1, . . . , ak), instead of a
single one as in the ordinary HSS problem. Assuming this
enlarged system, we have to go through the explanation of
[23], and adapt their Section 4.1 to our case.
To this end, we begin in this extended case from the lattice
{b1, . . . , bk}⊥ of rank 2m−k. Applying a strong lattice basis
reduction algorithm, we aim to obtain from this lattice the

1076lattice LX, whose rank is with high probability 4n, what we
assume to be true from now on. To ensure the success of the
lattice basis reduction algorithm, we ﬁrst have to estimate λ1
of the lattice {a1, . . . , ak}⊥. Using the Hadamard inequality
yields that det({a1, . . . , ak}⊥) ≤ O((M
n)k). Assuming
now the Gaussian volume heuristic to be fulﬁlled, we can
estimate the ﬁrst successive minimum by

√

)

λ1({a1, . . . , ak}⊥
4n − k

(cid:16)
(cid:16)√
4n − k(cid:0)M

√

det({a1, . . . , ak}⊥

n(cid:1)k/(4n−k)(cid:17)

)

.

≈ √

= O

(cid:17)1/(4n−k)

Next, regarding the construction of the lattice {b1, . . . , bk}⊥
we know that it also contains the lattice (LX)⊥ of rank
2m − 4n. According to the Gaussian volume heuristic, the
vectors of any reduced basis of (LX)⊥ have an expected
length of

(cid:18)(cid:16)(cid:112)O(m)

(cid:17)4n(cid:19)1/(2m−4n)

.

√
2m − 4n

Now we can follow the procedure in [23]. Namely, the ﬁrst
2m− 4n basis vectors of any reduced basis of {b1, . . . , bk}⊥
are with a high likelihood short lattice points of (LX)⊥, if
the following condition is fulﬁlled

(cid:112)O(m) · √

2m − 4n

(cid:18)(cid:16)(cid:112)O(m)

(cid:17)4n(cid:19)1/(2m−4n)

(cid:28) λ1({a1, . . . , ak}⊥

).

Letting now m and n be suﬃciently large, we can get the
simpler expression

(cid:32)

√

(

O

(cid:33)

m)(4n−k)/k

√
n

(cid:28) M.

The setting k = n gives us a very small bound for M ,
namely

M (cid:29) O(m1.5).

Note that several constants are removed and the Gaussian
volume heuristic is taken into account particularly. Hence,
this result on the bound for M should be interpreted only
as an asymptotic value, indicating that the lattice basis re-
duction approach can be applied for very small M . Our
experimental results strongly conﬁrm this.
4.2.1 Non-Uniformity of X
Now we describe how we address the issue of having the
non-uniform matrix X. We have learned from our experi-
mental results that the ﬁxed structure of the matrix X can
be a serious issue since it cannot provide enough random-
ness to conﬁrm all our assumptions made previously. To pro-
vide “somehow” enough randomness in the matrix of mapped
challenges X, we applied the following strategy— inspired
by our speciﬁc physical side channel analysis.
For each original n-bit challenge, we deﬁne 3 smaller ran-
dom sub-challenges with expected length n/4, symmetri-
cally centered on (cid:100)n/4(cid:101), (cid:100)2n/4(cid:101), and (cid:100)3n/4(cid:101) stages, respec-
tively. Afterwards, as explained in Section 2, we can map
each sub-challenge with expected length n/4, assuming that
the other remaining bits are simply set to 0. Hence, we
obtain three diﬀerent randomly chosen mapped challenges

(out of each real random challenge) with very small Ham-
ming weight, which we call centering groups. Note that this
random grouping strategy can be implemented by our data
acquisition methodology as explained before.

5. EXPERIMENTAL SETUP AND RESULTS
Our proposed lattice basis reduction attack is implemented
in Magma (V2.17) [1,4], installed on a virtual AMD64 server
having 16 cores and 32 GB of RAM. The speciﬁc single phys-
ical core is an Intel Core 2 Duo (Penryn) running at 2,4 GHz.
The Magma software package provides substantial support
for computing reduced bases of lattices. Of crucial impor-
tance for our purposes is the implementation of the Block
Korkine-Zolotarev (BKZ) algorithm provided in this pack-
age [31]. In this implementation, in addition to the block
size, the parameter δ that controls the quality of the basis
reduction algorithm can be set. A drawback of this imple-
mentation in Magma is that parallel computation is impos-
sible. Hence, the computation is performed only on a single
core of our virtual AMD64 server.
We launched our attack on simulated CRPs, generated in
Magma. However, it is worth noting that our XOR arbiter
PUF simulator implemented in Magma adopts only real ex-
perimental data obtained in [35]. Regarding those results
and the proof provided in [10], the delay values are mapped
to integer values, lying within a limited interval (see Sec-
tion 2). Our XOR arbiter PUF simulator ﬁrst generates the
matrix A composed of integer-valued delays, which are uni-
formly distributed within the interval [0, M ]. Although it
is known that the delays are normally distributed in reality,
uniformly distributed delays can be thought of being more
complicated, and thus present a harder practical case. The
matrix B is then calculated according to Eq. (7) and fed
into the algorithm, whose main steps are depicted in Algo-
rithm 2.
Comparing Algorithm 1 and Algorithm 2, the major mod-
iﬁcations made to improve the results quantitatively and
qualitatively are the following:

1. Instead of applying the BKZ function with a con-
stant block size, we perform this function by increasing
the block size in an iterative manner. Indeed, it has
been proved that the iterative reduction with respec-
tive block size 2, 4, . . . , 2t performs twice as fast as the
direct reduction with block size 2t, cf. [32, 33]. The
parameter t is set to 5, resulting in a maximal block
size of 32.

2. Before each reduction step the bases are randomly per-
muted to guarantee a better quality of the reduced
bases, cf. [33].

3. In order to further improve the quality of the reduced
bases in terms of their overall length, the step corre-
sponding to the ﬁnal computation of the hidden coef-
ﬁcients is repeated ﬁve times for randomly permuted
bases.

Finally, when constructing the lattice L(cid:48)
X , the required co-
eﬃcient is also changed from 2 to 16 to account for the
shorter average length of the mapped challenge vectors (for
more details see Section 2.2 and [8, 23]).
Our experimental results for diﬀerent settings are shown in
Table 3. In addition to the setting of the experiments, we re-
port the rank of the matrices composed of the measurements
that are centered on three diﬀerent stages of the XOR ar-
biter PUF (three centering groups). Moreover, the number

1077of hidden coeﬃcients (i.e., columns of the matrix X) dis-
closed by applying our algorithm on each of these matrices
is shown as well. The total number of disclosed coeﬃcients
is counted separately in order to avoid having common dis-
closed vectors in the three centering groups. However, we
have observed that no common disclosed vector is found in
the three groups.
The number of arbiter chains is set to k = n, although our
approach also works for k ≥ Ω (n) and even works provably
better in this case. However, we aim to further elaborate
on this speciﬁc setting, since all known machine learning at-
tacks cannot be launched in polynomial time, if k ≥ ω(ln n).
An initial and empirical study on XOR arbiter PUFs with
n = 512 and k = 16 has been performed by [30], but no
solid and fundamental research has been conducted in the
case of ω(ln n) < k ≤ O(n). Although by applying the Gaus-
sian volume heuristic we have proved that our algorithm can
be applied to disclose the hidden coeﬃcients in the case of
k = O(n), it might also be useful in the more simpliﬁed sce-
nario, where ln n (cid:28) k (cid:28) n. Given all that, we decided to
focus on disclosing the matrices X and A in the complicated
case of k = n. We stress that once X is known, a simple
standard Gaussian elimination will also reveal A.
The setting corresponding to n = 11 represents a virtually
similar example as shown by Nguyen et al. [23]. They have
demonstrated that their attack can be launched successfully
against a random HSS, with the number of hidden coeﬃ-
cients equal to 45, m = 90, and M = 2160. Our attack
can disclose the hidden coeﬃcients even when m = 78 and
n = 11 (i.e., the number of hidden coeﬃcients is 44), but
of course for a signiﬁcantly smaller number of bits, M = 26
in our case. This is in line with our former proof that the
input to our algorithm is the matrix B, whereas only a sin-
gle vector b is fed into the algorithm proposed by [23] (see
Section 2.5.1 for a detailed explanation).
We conducted further experiments on XOR arbiter PUFs
for n = 8, n = 16, n = 24, and n = 32. For n = 8 and
n = 16, our algorithm can entirely disclose the matrix X,
and thereby A. An increase in the number of XOR arbiter
PUF stages naturally leads to a slight increase in the number
of measurements as well as the time required for launching
the attack, as shown for n = 24 and n = 32. The impact
of the improvements that we make to Algorithm 1 proposed
by Nguyen et al. [23] can be clearly seen in the results for
n = 24 and n = 32. Whereas their algorithm cannot dis-
close more than 90 hidden coeﬃcients, our algorithm can
disclose 123 hidden coeﬃcients for signiﬁcantly smaller M ,
corresponding to the case of n = 32 in an XOR arbiter PUF
with 32 parallel arbiter chains. Note also that the computa-
tion times required to conduct the experiments are ranging
from only a few minutes to a few hours.
Although we performed our superior lattice basis reduction
approach only against XOR arbiter PUFs with the maxi-
mum n = 32 and k = 32, it is clear that these values are not
its ﬁnal limit.
Indeed, comparing with other approaches,
e.g., the very recent ones [30] and [37], we are only lim-
ited by the computational power of our server having an
old CPU and only 32 GB of RAM. Namely, the authors of
[30] used a more modern system providing 48 GB of RAM,
while a system with 256 GB of RAM has been employed in
[37]. Speciﬁcally, the authors of [37] used their system to
prove that XOR arbiter PUFs with n = 128 and k = 8 are
indeed “learnable”, which has been already implied in [10].

Algorithm 2 Our algorithm for disclosing the hidden bits
of the challenge vectors

(u1, u2, . . .) := BKZ(L∗, blocksize)
Randomly permute the current basis (u1, u2, . . .) of L∗
blocksize = 2 ∗ blocksize

Require: Matrix B, 2m, and 4n
Ensure: Matrix X
1: Calculate the orthogonal lattice B⊥
2: L∗ = B⊥
3: blocksize = 2
4: while blocksize ≤ 32 do
5:
6:
7:
8: end while
9: /* Compute the hidden lattice */
10: L∗ = (u1, u2, . . . , u2m−4n)⊥
11: Apply steps 4-8 on lattice L∗
12: LX = L∗
13: /* Compute the hidden coeﬃcients */
14: L(cid:48)
15: L∗ = L(cid:48)
16: z = 1
17: while z ≤ 5 do
18:
19:

X = 16LX + Z · (1, . . . , 1)

the

X

20:
21:
22: end while
23: return X

±(cid:16)

(cid:17)
j − (1, . . . ,1)

Apply steps 4-8 on lattice L∗
Find
vectors
, 1 ≤ j ≤ 2, 1 ≤ i ≤ 2m
16xi
Randomly permute the current basis of L∗
z = z + 1

basis

of L∗ with

the

form

Thus, ignoring certain O-constants, it is obvious that when
having an 8-fold increase in our RAM to achieve the compu-
tational power virtually similar to [37], our lattice method
should easily break the security of XOR arbiter PUFs with
n = 4 · 32 and k = 4 · 32 — particularly in the case of
controlled PUFs.
Last but not least, we would like to mention that we have
just applied standard lattice basis reduction algorithms pro-
vided by Magma, namely the old but most appropriate and
available BKZ reduction. Considering now that in the lat-
tice basis reduction ﬁeld several new breakthroughs have
been provided by faster and better theoretical algorithms,
cf. [7, 32, 33], we expect also new, strong, and practical re-
duction algorithms. For instance, the newly developed “BKZ
2.0” basis reduction algorithm will dramatically improve the
eﬀectiveness and the eﬃciency of our attack against XOR
arbiter PUFs for larger n and k and most likely also for
smaller k in such cases where the machine learning algo-
rithms fail.

6. CONCLUSION
In this article, we proved the vulnerability of XOR arbiter
PUFs to a new attack, which is a combination of a lattice
basis reduction attack and a photonic side channel analysis.
The success of previous modeling attacks primarily depends
on the limitation in the number of arbiter chains. More-
over, popular semi-invasive attacks against PUFs often rely
on the direct access to challenges and/or responses. We
demonstrated that neither an increase in the number of ar-
biter chains nor the limitation of the access to challenges
and responses qualiﬁes as a secure countermeasure against
our novel hybrid attack. Therefore, our study contributes
to bridging the gap between these two types of attacks, and
characterizing an XOR arbiter PUF featuring an arbitrar-
ily large number of arbiter chains, even when the challenges
and responses are not accessible.

1078Table 3: Results of the lattice basis reduction attack on
XOR arbiter PUFs with the diﬀerent number of stages and
arbiter chains

cf. [8, 24], it seems that M and its canonical density deﬁni-
tion is also the Achilles heel of arbiter PUFs.

Results

Rank of the matrix B centered on

Number of disclosed vectors
from the group centered on

Total number of disclosed vectors

Rank of the matrix B centered on

Number of disclosed vectors
from the group centered on

Total number of disclosed vectors

Rank of the matrix B centered on

Number of disclosed vectors
from the group centered on

Total number of disclosed vectors

(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)
(cid:100)n/4(cid:101)
(cid:100)n/2(cid:101)
(cid:100)3n/4(cid:101)

22
32
24
6
19
7
32
36
44
32
10
26
8
44
48
64
46
17
32
15
64
72
96
70
23
50
21
94
94
128
96
26
67
30
123

Setting

n = 8,
k = 8,
m = 60,
M = 25

n = 11,
k = 11,
m = 78,
M = 26

n = 16,
k = 16,
m = 128,
M = 28

n = 24,
k = 24,
m = 280,
M = 212

n = 32,
k = 32,
m = 370,
M = 215

Rank of the matrix B centered on

Number of disclosed vectors
from the group centered on

Total number of disclosed vectors

Rank of the matrix B centered on

Number of disclosed vectors
from the group centered on

Total number of disclosed vectors

In the realm of XOR arbiter PUFs we present a novel ap-
plication of the concept of lattice basis reduction, which is a
very powerful tool providing a ﬁrm basis for the assessment
of the security of these PUFs. Our methodology of collecting
physically measured data required for establishing a lattice-
based representation of an XOR arbiter PUF is nowadays
very well developed. We further extended a celebrated lat-
tice basis reduction attack to the multidimensional case in
order to launch it for higher densities, in contrast to its orig-
inal very low density. Therefore, we were able to adapt the
maximum variation of delays in the PUF (M ) to the real-
istic and practical values, typically found in arbiter PUFs
implemented on chips.
The importance of deﬁning this maximum variation has been
recognized and emphasized in a recent work [10]. It has been
demonstrated that the maximum variation is one of the crit-
ical parameters for launching successful machine learning at-
tacks against arbiter PUFs in general. More interestingly,
afterward this has been observed and implicitly re-conﬁrmed
in a careful practical study [37]. Hence, regarding the results
from [10] and [37], it may seem tempting to drastically in-
crease M (by increasing the intrinsic delay variations and/or
the ﬁnal arbiter precision) to impair the eﬀectiveness of ma-
chine learning attacks. While this provably protects a PUF
against machine learning attacks, having a larger M even
improves the eﬀectiveness of our novel lattice basis reduc-
tion attack against XOR arbiter PUFs. As the “knapsack-
density” eventually turned out to be the security-critical pa-
rameter for all knapsack-based cryptographic constructions,

7. ACKNOWLEDGEMENTS
The authors would like to acknowledge the support of the
German Federal Ministry of Education and Research in the
project Photon FX2 and the Helmholtz Research School on
Security Technologies.

8. REFERENCES
[1] Magma Computational Algebra System.

http://magma.maths.usyd.edu.au/magma/.

[2] F. Armknecht, R. Maes, A. Sadeghi, O.-X. Standaert,

and C. Wachsmann. A Formalization of the Security
Features of Physical Functions. In Security and
Privacy (SP), IEEE Symp. on, pages 397–412, 2011.

[3] G. T. Becker and R. Kumar. Active and Passive

Side-Channel Attacks on Delay Based PUF Designs.
IACR Cryptology ePrint Archive, 2014:287, 2014.

[4] W. Bosma, J. Cannon, and C. Playoust. The Magma

algebra system. I. The user language. J. Symbolic
Comput., 24(3-4):235–265, 1997. Computational
Algebra and Number Theory.

[5] V. Boyko, M. Peinado, and R. Venkatesan. Speeding

up Discrete Log and Factoring Based Schemes via
Precomputations. In Advances in Cryptology -
EUROCRYPT ’98, Int. Conf. on the Theory and
Application of Cryptographic Techniques, pages
221–235, 1998.

[6] J. W. S. Cassels. An Introduction to the Geometry of

Numbers, volume 99. Springer, 1996.

[7] Y. Chen and P. Q. Nguyen. BKZ 2.0: Better Lattice

Security Estimates. In Advances in
Cryptology–ASIACRYPT 2011, pages 1–20. Springer,
2011.

[8] M. J. Coster, A. Joux, B. A. LaMacchia, A. M.
Odlyzko, C.-P. Schnorr, and J. Stern. Improved
Low-Density Subset Sum Algorithms. Computational
Complexity, 2(2):111–128, 1992.

[9] J. Delvaux, D. Gu, D. Schellekens, and

I. Verbauwhede. Secure Lightweight Entity
Authentication with Strong PUFs: Mission
Impossible? In Cryptographic Hardware and Embedded
Systems–CHES 2014, pages 451–475. Springer, 2014.
[10] F. Ganji, S. Tajik, and J.-P. Seifert. PAC Learning of

Arbiter PUFs, Security Proofs for Embedded
Systems–PROOFS, 2014.
https://eprint.iacr.org/2015/378.pdf.

[11] B. Gassend, D. Clarke, M. Van Dijk, and S. Devadas.
Controlled Physical Random Functions. In Computer
Security Applications Conf., 2002. Proc. 18th Annual,
pages 149–160. IEEE, 2002.

[12] B. Gassend, D. Clarke, M. Van Dijk, and S. Devadas.

Silicon Physical Random Functions. In Proc. of the
9th ACM Conf. on Computer and Communications
Security, pages 148–160. ACM, 2002.

[13] C. Helfmeier, C. Boit, D. Nedospasov, and J.-P.

Seifert. Cloning Physically Unclonable Functions. In
Hardware-Oriented Security and Trust (HOST), IEEE
Intl. Symp. on, pages 1–6, 2013.

1079[14] C. Helfmeier, D. Nedospasov, C. Tarnovsky, J. S.
Krissler, C. Boit, and J.-P. Seifert. Breaking and
Entering through the Silicon. In Proceedings of the
2013 ACM SIGSAC conference on Computer &
communications security, pages 733–744. ACM, 2013.

[15] S. Katzenbeisser, ¨U. Kocaba¸s, V. Van Der Leest,

A.-R. Sadeghi, G.-J. Schrijen, and C. Wachsmann.
Recyclable PUFs: Logically Reconﬁgurable PUFs.
Journal of Cryptographic Engineering, 1(3):177–186,
2011.

[16] O. K¨ommerling and M. Kuhn. Design Principles for
Tamper-Resistant Security Processors. In USENIX
Workshop on Smartcard Technology, 1999.
[17] J. W. Lee, D. Lim, B. Gassend, G. E. Suh,

M. Van Dijk, and S. Devadas. A Technique to Build a
Secret Key in Integrated Circuits for Identiﬁcation
and Authentication Applications. In VLSI Circuits,
2004. Digest of Technical Papers. Symp. on, pages
176–179, 2004.

[27] U. R¨uhrmair, F. Sehnke, J. S¨olter, G. Dror,

S. Devadas, and J. Schmidhuber. Modeling Attacks on
Physical Unclonable Functions. In Proc. of the 17th
ACM Conf. on Computer and Communications
Security, pages 237–249. ACM, 2010.

[28] U. R¨uhrmair, J. S¨olter, and F. Sehnke. On the

Foundations of Physical Unclonable Functions. IACR
Cryptology ePrint Archive, 2009:277, 2009.
[29] U. Ruhrmair, J. Solter, F. Sehnke, X. Xu,

A. Mahmoud, V. Stoyanova, G. Dror, J. Schmidhuber,
W. Burleson, and S. Devadas. PUF Modeling Attacks
on Simulated and Silicon Data. Information Forensics
and Security, IEEE Trans. on, 8(11):1876–1891, 2013.

[30] U. R¨uhrmair, X. Xu, J. S¨olter, A. Mahmoud,

M. Majzoobi, F. Koushanfar, and W. Burleson.
Eﬃcient Power and Timing Side Channels for Physical
Unclonable Functions. In Cryptographic Hardware and
Embedded Systems–CHES 2014, pages 476–492.
Springer, 2014.

[18] R. Maes. Physically Unclonable Functions:

Constructions, Properties and Applications. Springer,
2013.

[31] C.-P. Schnorr. A Hierarchy of Polynomial Time
Lattice Basis Reduction Algorithms. Theoretical
Computer Science, 53(2):201–224, 1987.

[19] R. Maes and I. Verbauwhede. Physically Unclonable

[32] C. P. Schnorr. Accelerated Slide- and LLL-Reduction.

Functions: A Study on the State of the Art and Future
Research Directions. In Towards Hardware-Intrinsic
Security, pages 3–37. Springer, 2010.

Electronic Colloquium on Computational Complexity
(ECCC), 18:50, 2011.
http://eccc.hpi-web.de/report/2011/050.

[20] M. Majzoobi, F. Koushanfar, and S. Devadas. FPGA

[33] C. P. Schnorr and T. Shevchenko. Solving Subset Sum

PUF using Programmable Delay Lines. In Information
Forensics and Security (WIFS), IEEE Intl. Workshop
on, pages 1–6, 2010.

[21] M. Majzoobi, M. Rostami, F. Koushanfar, D. S.

Problems of Density close to 1 by ”randomized ”
BKZ-reduction, 2012.
http://www.math.uni-frankfurt.de/~dmst/
research/papers/Taras.pdf.

Wallach, and S. Devadas. Slender PUF protocol: A
lightweight, robust, and secure authentication by
substring matching. In Security and Privacy
Workshops (SPW), IEEE Symp. on, pages 33–44,
2012.

[22] J. Martinet. Perfect Lattices in Euclidean Spaces,

volume 327. Springer Science & Business Media, 2003.

[23] P. Nguyen and J. Stern. The Hardness of the Hidden

Subset Sum Problem and Its Cryptographic
Implications. In Advances in
Cryptology—CRYPTO’99, pages 31–46. Springer,
1999.

[24] P. Q. Nguyen and B. Vall´ee. The LLL Algorithm.

Springer, 2010.

[25] R. Pappu, B. Recht, J. Taylor, and N. Gershenfeld.

Physical One-way Functions. Science,
297(5589):2026–2030, 2002.

[26] U. R¨uhrmair, H. Busch, and S. Katzenbeisser. Strong
PUFs: Models, Constructions, and Security Proofs. In
Towards hardware-intrinsic security, pages 79–96.
Springer, 2010.

[34] G. E. Suh and S. Devadas. Physical Unclonable

Functions for Device Authentication and Secret Key
Generation. In Proc. of the 44th annual Design
Automation Conf., pages 9–14. ACM, 2007.

[35] S. Tajik, E. Dietz, S. Frohmann, J.-P. Seifert,

D. Nedospasov, C. Helfmeier, C. Boit, and H. Dittrich.
Physical Characterization of Arbiter PUFs. In
Cryptographic Hardware and Embedded
Systems–CHES 2014, pages 493–509. Springer, 2014.
[36] S. Tajik, D. Nedospasov, C. Helfmeier, J.-P. Seifert,

and C. Boit. Emission Analysis of Hardware
Implementations. In Digital System Design (DSD),
17th Euromicro Conf. on, pages 528–534. IEEE, 2014.

[37] J. Tobisch and G. T. Becker. On the Scaling of

Machine Learning Attacks on PUFs with Application
to Noise Bifurcation, 2015.
https://www.emsec.rub.de/research/
publications/ScalingPUFCameraReady/.

1080