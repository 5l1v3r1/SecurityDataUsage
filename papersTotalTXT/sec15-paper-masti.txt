Thermal Covert Channels on Multi-core Platforms

Ramya Jayaram Masti, Devendra Rai, Aanjhan Ranganathan, Christian Müller,  

Lothar Thiele, and Srdjan Čapkun, ETH Zürich

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/masti

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXThermal Covert Channels on Multi-core Platforms

Ramya Jayaram Masti∗, Devendra Rai†, Aanjhan Ranganathan∗, Christian M¨uller†

Lothar Thiele†, Srdjan Capkun∗

∗Institute of Information Security, ETH Zurich

{rmasti, raanjhan, capkuns}@inf.ethz.ch

†Computer Engineering and Networks Laboratory, ETH Zurich

{raid, thiele}@tik.ee.ethz.ch, chrismu@student.ethz.ch

Abstract
Side channels remain a challenge to information ﬂow
control and security in modern computing platforms. Re-
source partitioning techniques that minimise the number
of shared resources among processes are often used to
address this challenge. In this work, we focus on multi-
core platforms and we demonstrate that even seemingly
strong isolation techniques based on dedicated cores can
be circumvented through the use of thermal channels.
Speciﬁcally, we show that the processor core tempera-
ture can be used both as a side channel as well as a
covert communication channel even when the system im-
plements strong spatial and temporal partitioning. Our
experiments on an Intel Xeon server platform demon-
strate covert thermal channels that achieve up to 12.5 bps
and weak thermal side channels that can detect processes
executed on neighbouring cores. This work therefore
shows a limitation in the isolation that can be achieved
on existing multi-core systems.

1

Introduction

Covert and side channels have for a long time remained
an open threat to information ﬂow control and isolation
techniques in a variety of contexts including cloud and
mobile computing [50, 71, 76]. Such channels can be
used for data exﬁltration from a victim [17] and be ex-
ploited by colluding applications to covertly exchange
information [46].

A common technique to mitigate covert and side chan-
nel attacks that leverage co-location is to dedicate re-
sources (e.g. processor cores, memory) to individual pro-
cesses for the duration of their execution. Although
seemingly inefﬁcient, such a technique is becoming vi-
able with the appearance of multi and many-core sys-
tems which contain hundreds of cores [12]. However,
it has already been shown that, due to their architec-
ture and use, multi-core systems do not trivially pro-

tect against all types of information leakage — covert
channels have been demonstrated by exploiting shared
caches [35], memory bus [34], network stacks [54], vir-
tual memory [72], I/O devices [64], etc. These covert
channels, however, still exploit the resources that par-
ticular multi-core platforms, for performance and other
reasons, share among the processes. The threats arising
from covert and side channel attacks led to the develop-
ment of mitigation techniques such as partitioning of the
shared resources when possible, for example, partition-
ing caches [68] and bus bandwidth [31].

In this paper, we show that even strong isolation tech-
niques based on dedicated cores and memory can be cir-
cumvented in multi-core systems through the use of a
thermal channel. For this, we leverage the temperature
information that is exposed to processes for performance
reasons on multi-core platforms and two aspects of the
thermal behaviour of these systems. First, the thermal
capacitance and resistance of computing platforms result
in remnant heat from computations, i.e. the heat is ob-
servable even after that computation has stopped. As a
result, information about one process may leak to another
that follows it in the execution schedule. Second, the
effects of heat resulting from processes running on one
core can be observed on other cores across the chip. This
leaks information about a process to its peers running on
other cores in a processor chip. We demonstrate our at-
tacks on commodity multi-core systems. So far, thermal
(heat) channels have not been studied on these systems.
There is a trend towards exposing thermal data to users
and allowing them to make thermal management deci-
sions based on it [21]. For example, temperature infor-
mation is accessible from user-space on modern Linux
systems [1]. This paper highlights the tension between
building thermally-efﬁcient systems which requires ex-
posing high-quality temperature data to applications and
securing them.

In summary, we make the following contributions: (i)
We demonstrate the feasibility of using thermal covert

USENIX Association  

24th USENIX Security Symposium  865

channels for communication between colluding applica-
tions. We measure the throughput of such a channel on
an Intel Xeon server with two processors containing 8
cores each. The challenges in building such a channel in-
clude the system’s thermal capacitance, effect of cooling
on multi-core systems and resolution limitations of the
thermal sensors available on these platforms. Although
thermal covert channels have a low throughput, sensitive
data such as credit-cards (16 digits) can be transmitted
within 5 seconds to 4 minutes even on systems that use
resource partitioning. (ii) We explore the factors that in-
ﬂuence the throughput of this covert channel — proces-
sor frequency and relative locations of the colluding ap-
plications (processes) and show the throughput varies be-
tween 0.33 bps and 12.5 bps. (iii) We demonstrate the ex-
istence of limited thermal side channel leakage from pro-
cesses running on adjacent cores that allow identiﬁcation
of applications based on their thermal traces. On existing
systems, heat-based leakage is non-trivial to avoid with-
out a performance penalty; we discuss possible counter-
measures to eliminate or limit the impact of such attacks.
The rest of this paper is organised as follows. In Sec-
tion 2, we discuss the background and motivation for
our work. Section 3 discusses the thermal behaviour of
x86 platforms and Section 4 describes how these prop-
erties can be exploited to create thermal channels.
In
Section 5, we demonstrate the feasibility of using ther-
mal channels for covert communication even in systems
with isolation based on resource partitioning. Section 6
demonstrates that limited side channel leakage can oc-
cur through thermal channels which can be exploited for
unauthorised application proﬁling. Section 7 and Sec-
tion 8 summarise countermeasures against thermal chan-
nels and related work respectively. Finally, we conclude
in Section 9.

2 Background and Motivation

In this section, we summarise the use of thermal infor-
mation in modern processors and resource partitioning-
based isolation techniques, as well as provide a motiva-
tion for our study.

2.1 Thermal Management
Thermal management is key to the safe and reliable op-
eration of modern computing systems. Today, thermal
sensors are incorporated into a number of system com-
ponents including hard-drives, DRAM, GPU, mother-
boards and the processor chip itself [9]. In this work, we
focus on the information available from thermal sensors
that are embedded in processor chips.

Ensuring the thermal stability of a processor is be-
coming increasingly challenging given the rising power-

density in modern processor chips. As a result, major
processor vendors (e.g. Intel, AMD, VIA) incorporate
thermal sensors to enable real-time monitoring of pro-
cessor temperature. ARM-based processors also include
thermal sensors inside the system-on-chip for power and
temperature management.

Initially, thermal management was done statically in
hardware and included mechanisms to power-off the pro-
cessor to prevent melt-downs. This later evolved to
more sophisticated dynamic frequency and voltage scal-
ing techniques that change processor frequency to lower
its temperature [13,39]. Hybrid software- and hardware-
approaches to thermal monitoring have become popular
over time; operating systems today poll temperature sen-
sors and use this to manage cooling mechanisms such
as processor frequency-scaling and fan-speed [2]. More
recently, there is a trend towards user-centric thermal
management that exposes thermal data to users and al-
lows them to implement customised thermal manage-
ment policies. For example, Linux-based systems today
enable users to conﬁgure thermal policies [14, 21].

The number and topology of thermal sensors de-
pend on the processor vendor and family. For example,
while Intel and VIA processors expose temperature data
for individual cores using on-die sensors, some AMD
(e.g. Opteron K10 series) processors only allow moni-
toring the overall temperature of the entire chip using a
sensor in the processor socket [1]. Optimising the num-
ber and placement of thermal sensors on processors is an
active research topic [47, 53, 55].

2.2 Resource Partitioning-based Isolation
Isolation techniques for multi-core platforms that are
based on resource partitioning offer a number of ben-
eﬁts. First, resource management approaches that rely
on partitioning reduce the size of the software Trusted
Computing Base (TCB). In fact, resource partitioning is
gaining popularity as a means to create multiple, iso-
lated execution environments without the need for a soft-
ware TCB in servers [6] and networked embedded sys-
tems [57]. Second, the simplicity of partitioning-based
resource management eases formal veriﬁcation and this
is leveraged by separation kernels like Muen [23]. Third,
modern processors rely on partitioning techniques to
build Trusted Execution Environments (TEEs). TEE
technologies such as Intel Trusted Execution Tech-
nology (TXT) [40], Intel Software Guard Extensions
(SGX) [52] and ARM TrustZone [15] protect the execu-
tion of security-sensitive software from a compromised
operating system.
Intel TXT relies on temporal parti-
tioning of resources such as CPU and memory between
trusted and untrusted software.
Intel SGX and ARM
TrustZone use temporal partitioning only for the CPU

866  24th USENIX Security Symposium 

USENIX Association

and implement spatial partitioning for memory resources
in the system.

Resource partitioning has already been proposed as
a countermeasure against covert channels [30] and side
channels [68]. This is because most covert and side chan-
nels exploit shared resources. For example, a process can
modify shared resources (e.g. cache, ﬁle) to communi-
cate covertly with another colluding process. An attacker
can also exﬁltrate sensitive information from a victim
process by tracking the state of a shared resource such
as cache. Therefore, there have been proposals for min-
imising shared resources to reduce the number and effec-
tiveness of covert and side channels. Examples include
partitioning of caches [68] and bus-bandwidth [31].

2.3 Motivation

The main motivation behind this work is our observa-
tion that despite its security advantages, resource parti-
tioning on multi-core systems might not be able to com-
pletely eliminate some types of inference or communi-
cation across partitions. More speciﬁcally, we want to
investigate if the exposure of core temperature informa-
tion could be used to build both side channels and covert
communication channels between processes that execute
on different cores within a multi-core system. Our goal
is to study these channels primarily in terms of their fea-
sibility and throughput.

Thermal channels are particularly interesting in the
context of multi-core systems for two main reasons:
(i) today, these platforms expose the information from
thermal sensors to users and (ii) thermal channels can
be tested for their effectiveness under the resource
partitioning-based isolation mechanisms that multi-core
systems can support. To build thermal channels, it is nec-
essary to understand the type and quality of temperature
data available on systems today. One must also account
for the nature of temperature variations on such systems
and the factors that affect them. We focus on Intel x86
platforms for our study given their wide spread use.

3 Thermal Behaviour of x86 Platforms

In this section, we present theoretical and empirical as-
pects of the thermal behaviour of x86 systems. More
speciﬁcally, we ﬁrst discuss recent attempts to analyse,
model, and simulate the thermal behaviour of the state-
of-the-art processors. Then, we discuss the on-die ther-
mal sensors available on Intel processors and the thermal
behaviour of these platforms under a CPU-intensive load.

3.1 Models of Thermal Behaviour
The most common abstraction of the thermal behaviour
of processors is the resistor-capacitor mesh network
model. This model is based on the well-known duality
between thermal and electrical phenomenon [36]. Each
physical layer of the processor is modelled separately as
a resistor-capacitor mesh. The heat ﬂow between the lay-
ers itself and eventually to the environment is represented
by connecting the various meshes using additional resis-
tors and capacitors. Such an approach [28] assumes that
it is possible to approximate the thermal properties of a
processor using a linear model. It also captures factors
such as high thermal resistivity of silicon, heat-sinks and
fan cooling that affect overall processor temperature.

Alternative empirical approaches that approximate
thermal behaviour using measurements from on-die ther-
mal sensors and machine learning techniques have also
been explored (e.g. [60]). The advantage of such an
approach over using traditional models is that it does
not need information such as detailed design parameters
(e.g. ﬂoorplan of the processor) which are usually not
readily available.

Given the complexity of modern commodity proces-
sors and the lack of public information required to ac-
curately model them, in this paper, we focus on a more
empirical approach. We use measurements from the on-
die thermal sensors to understand the thermal behaviour
of commodity systems.

3.2 Temperature Sensors in Intel

Processors

Intel labels each of its processors with a maximum junc-
tion temperature which is the highest temperature that
is safe for the processor’s operation. If the processor’s
temperature exceeds this level, permanent silicon dam-
age may occur. To avoid such processor melt-down, Intel
facilitates processor temperature monitoring by incorpo-
rating one digital thermal sensor (DTS) into each of the
cores in a processor. The layout of the cores within a
processor chip can be identiﬁed using lstopo [7] on a
Linux machine. For example, on the Xeon server used
in our experiments, the cores are arranged along a line
(as shown in Section 5.1). Each DTS reports the dif-
ference between the core’s current temperature and the
maximum junction temperature [3]. The accuracy of the
DTS varies across different generations of Intel proces-
sors. They typically have a resolution of ±1◦C.
The absolute value of a core’s temperature in ◦C is
computed in software by subtracting the thermal sensor
reading from the maximum junction temperature. Ther-
mal data from a sensor can be obtained using special
CPU registers of the corresponding core. The data from

USENIX Association  

24th USENIX Security Symposium  867

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

30

0

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

30

0

2.9 GHz
2.4 GHz
1.9 GHz
1.5 GHz

50

100
150
Time (s)

200

250

50

100

Time (s)

150

200

Figure 1: Thermal Response of a CPU Intensive Ap-
plication. Temperature trace resulting from the execu-
tion of an application that does RSA decryption in a loop
for 100 s. The start and end times of the application’s
execution are indicated using the two red lines. Temper-
ature increases rapidly initially and saturates over time as
an application runs. Similarly, it falls rapidly as soon as
the core becomes idle and gradually returns to the ambi-
ent temperature.

all sensors is exposed using the coretemp kernel mod-
ule [1] on Linux systems. This information is accessible
from user space through the sysfs ﬁlesystem which is
refreshed every 2 ms.

3.3 Example Temperature Trace

To illustrate how computations affect the temperature of
a core, we ran a CPU intensive application – more specif-
ically, one that does an RSA decryption continuously in
a loop. We ran the application on core 3 of an octa-core
processor (for setup details, refer to Section 5.1). Fig-
ure 1 shows the recorded temperature trace of core 3 dur-
ing the execution of the application for 100 s (between
the dotted red lines) on it and for about 50 s thereafter
when the core cools. We observe that 25 ms after the ap-
plication begins execution, the temperature rises by 5◦C
from approximately 35 ◦C to 40 ◦C. Following this rapid
rise, the temperature increases very slowly and saturates
at 43◦C. As soon as the application stops executing, the
temperature falls rapidly to 38 ◦C in about 25 ms and
takes an additional 11 s to reach 35 ◦C.

The exponential nature of the temperature rise and fall
is a result of the system’s thermal capacitance and resis-
tance. The temperature fall curve shows that the temper-
ature changes caused by such an application’s execution
can be observed for sometime after it has stopped.

Figure 2: Effect of Processor Frequency on Thermal
Behaviour. Temperature proﬁles produced by running a
CPU intensive application on a core at different proces-
sor frequencies for 100 s.

3.4 Factors Inﬂuencing a Core’s

Temperature

The major factors affecting the temperature at a par-
ticular core are the fan speed, processor frequency and
heat propagation from neighbouring cores. Since, in our
experiments, we do not control the server fan speed (see
Section 5.1), we only discuss the effect of the processor
frequency and heat propagation on a speciﬁc core’s
temperature below.

CPU Frequency. Most Intel processors are designed to
run at a set of discrete frequencies for optimising power
consumption. For example, in our setup (Section 5.1),
the Xeon server can run at frequencies between 1.2 GHz
and 2.9 GHz. All cores within a single processor chip
run at the same frequency. Changes in frequency at a
given core are reﬂected across all the other cores. The
actual frequency can be controlled either by the user or
by the kernel; for example, Ubuntu systems allow users
to control this using the sysctl interface.

Figure 2 shows how the processor frequency affects
temperature when a CPU-intensive application runs for
100 s. We can observe that higher frequencies result
in more heat and higher saturation temperatures. This
is because processor operation at a higher frequency
results in a larger power density and therefore, more heat.

Heat Propagation From a Neighbour.
The heat
resulting from computations on one core will propagate
to neighbouring cores. As a result, the temperature at a
certain core depends not only on that core’s workload
(type of computation and schedule) but also those of its
neighbours.

868  24th USENIX Security Symposium 

USENIX Association

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

30

0

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

Core 2
Core 3
Core 4

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

Core 1
Core 3
Core 5

50

100

150

200

250

30

0

50

Time (s)
(a) 1 Hop

200

250

100

150

Time (s)
(b) 2 Hops

Core 0
Core 3
Core 6

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

Core 3
Core 7

30

0

50

100

150

Time (s)
(c) 3 Hops

200

250

30

0

50

200

250

100

150

Time (s)
(d) 4 Hops

Figure 3: Heat Propagation from a Neighbouring Core. Effect of running a CPU-intensive application on core 3 of
an octa-core processor for 100 s on the temperature sensors of its adjacent cores.

Figure 3 shows the effects of a CPU-intensive applica-
tion executing on a central core (core 3) of an octa-core
processor for 100 s. We notice that the computation on
core 3 affects the temperature sensors of its neighbouring
cores which remain idle all through. Additionally, we
observe that the saturation temperature of a neighbour-
ing core decreases with increasing distance from core 3.
This effect is not symmetric as one would expect on ei-
ther side of core 3. We suspect that this is due to an
asymmetrically located processor hotspot or asymmetri-
cally positioned thermal sensor.

4 Exploiting Thermal Behaviour

In this section, we present the intuition underlying the
construction of thermal channels on multi-core systems.

4.1

Isolation based on Spatial and
Temporal Partitioning

Isolation techniques that rely on resource partitioning are
becoming increasingly popular and there have been a
number of proposals for using such partitioning to pre-
vent covert and side channels [31, 68].
In our work,

we consider two most common types of process isola-
tion and partitioning techniques: Spatial and Temporal
as shown in Figure 4. In spatially partitioned systems,
processes are isolated by being assigned exclusive com-
putation resources, i.e. no two processes share cores or
memory. Such an approach prevents certain types of side
channels between processes that execute concurrently.
For example, cache-partitioning prevents any informa-
tion leakage that may occur based on the state of the
cache-lines in a processor (e.g. how many cache-lines
are full).
In such systems, processes do not share any
processor temperature sensors because they do not use
any common CPU resources.

In temporally partitioned systems, the processes share
the same resources but run in a time-multiplexed man-
ner. For example, this technique is used by TEEs like
Intel TXT in which only one of two partitions (trusted
or untrusted) are active at a time but have access to com-
mon cores and memory. In systems that employ temporal
partitioning, processes that share one or more cores have
access to the corresponding temperature sensor(s) during
their execution time-slice.

Thermal channels that leverage system thermal be-
haviour can be used to circumvent both these types of
isolation techniques as we describe below.

USENIX Association  

24th USENIX Security Symposium  869

HEAT-BASED CHANNEL IN SPATIALLY PARTITIONED SYSTEMS

SOURCE

SINK

PROCESSOR

C1

S1

CORE

C2

C3

...........

S2

S3
THERMAL SENSOR

Heat flow

Cn-1

Sn-1

Cn

Sn

1 0 1 0 1

ON

OFF

ON

OFF

TEMP 
TEMP 

1 0 1 0 1

.......

TIME

.......

TIME

.......

TIME
TIME

On core C, the source executes a heat-
intensive task (ON) to send bit '1' or 
remains idle (OFF) to send bit '0'

On core Cn-1, the sink continuously 
records the temperature of the core on 
which it is executing 

The sink uses its recorded temperature 
trace to decode the information sent 
by the source

HEAT-BASED CHANNEL IN TEMPORALLY PARTITIONED SYSTEMS

INTERLEAVED EXECUTION ON THE SAME CORE

(ON)

(OFF)

(ON)

time-slice

TEMP 

C

S

C

S

C

S

C

S

C

S

C

S

......

TIME

1

0

1

On core C, the source executes a heat-
intensive task (ON) to send bit '1' or 
remains idle (OFF) to send bit '0' during 
its time-slice.

The sink continuously records the 
temperature of its core during its time-slice

TIME

The sink uses its recorded temperature 
trace to decode the information sent 
by the source

Figure 4: Covert communication using Thermal Channels. We demonstrate that the temperature sensors on com-
modity multi-core platforms can be misused for covert communication by two colluding processes in spatially and
temporally isolated systems.

4.2 Constructing Thermal Channels

Based on our discussion in Section 3, we make two ob-
servations that can be used to construct thermal channels.

Remnant Heat.
Since temperature variations that
result from a computation can be observed even after
it stops,
these variations leak information regarding
the computation to the process that follows it in the
execution schedule especially if they share the same
core. This remnant heat can be exploited as a thermal
side channel and may allow a process to exﬁltrate sensi-
tive information from its predecessor thereby violating
temporal partitioning. Furthermore, it can also be used
for communication between two colluding processes
that time-share a core. Note that while it is possible
to reset most resources (e.g. CPU registers, caches)
to prevent other types of channels before switching
between applications, the remnant heat from a compu-
tation (and hence, a thermal channel) is hard to eliminate.

Heat Propagation to a Neighbouring Core. The ther-
mal conductivity of the processor results in heat propaga-
tion between cores, i.e, the heat that results from a com-
putation not only affects its underlying core’s tempera-
ture but also its neighbouring cores. This heat ﬂow can
be exploited as a thermal channel by an attacker to make
inferences about a potentially sensitive computation at a
neighbouring core. Colluding processes can also use the
heat ﬂow to communicate covertly. Since it is hard to
eliminate heat ﬂows within processors, thermal channels

are a viable threat even in spatially partitioned systems.
There are several challenges involved in the construc-
tion of thermal channels. First, the nature of temperature
changes makes it hard to control the effect that an ap-
plication’s execution will have on the temperature of its
own core and its neighbours. Second, the limited res-
olution of the temperature sensors available on current
x86 platforms prevents ﬁne-grained temperature moni-
toring. Finally, fan-based cooling mechanisms affect the
rate and extent of temperature variations.

5 Covert Communication Using Thermal

Channels

In this section, we present the feasibility and through-
put of communication using thermal covert channels in
spatially and temporally partitioned multi-core systems.
We ﬁrst describe our experimental setup that implements
such isolation mechanisms. Throughout, we refer to the
data sender as the source and the recipient as the sink.

5.1 Experimental Setup
Our setup is based on an Intel server containing two octa-
core Xeon processor chips and running an Open SUSE
installation (Figure 5). We use cpusets [4] to implement
spatial and temporal partitioning. Using cpusets, we re-
strict the OS to one of the processor chips (Processor 2)
and isolate it from the rest of the system. We achieve
spatial partitioning by running the source and the sink on

870  24th USENIX Security Symposium 

USENIX Association

achieve spatial and temporal isolation; this makes it an
ideal platform for our investigation of thermal channels.

5.2 Covert Communication in Spatially

Partitioned Systems

This section addresses the construction of
thermal
channels in the scenario where the source and sink appli-
cations run on dedicated cores and execute concurrently.
The sink has access only to its own core’s temperature
sensor and not that of the source as described in the
upper part of Figure 4. To communicate covertly in such
a scenario, the source exploits the heat propagation from
its own core to the sink that runs on a neighbouring
core.
In this section, we demonstrate the feasibility
of achieving this on a commodity multi-core platform
and evaluate the throughput of such a communication
channel. Below, we ﬁrst present the encoding scheme
that we use for data transmission and then describe the
experiments that realise covert communication using the
thermal channel.

Encoding and Decoding. The source and sink use On-
Off Keying for their communication. To send bit ‘1’,
the source application runs RSA decryption operations
to generate heat and to transmit bit ‘0’, it remains idle. It
is important that the source application runs long enough
to affect the sink’s temperature sensor on a neighbouring
core to send bit ‘1’, i.e. it must generate enough heat to
raise the temperature of the sink’s core above the ambient
temperature. We denote the minimum duration for which
the source application needs to execute to transmit a ‘1’
bit to the neighbouring cores as Tb. The source remains
idle for the same duration to send a ‘0’ bit. We assume
that the source and sink a priori agree on Tb and a ﬁxed
preamble to mark the start of the data.

The sink that records the temperature of its own core
continuously does the following to decode the data. It
ﬁrst searches the recorded temperature trace for a ﬁxed
preamble. We choose a preamble starting with bit ‘1’
because it can clearly be identiﬁed by the sink. To detect
the start of the preamble, the sink searches for a ‘1’
bit by detecting the ﬁrst rising edge, i.e. a temperature
increment ≥ 2◦C given its ambient temperature. We
use this threshold because the resolution of the sensors
on the platform is ±1◦C. It then tries to decode the bits
following this to see if they match the preamble. The
source repeats this until it recovers the preamble from
the temperature trace. It then decodes the remaining bits
using a simple edge detection mechanism in which a
rising edge indicates bit ‘1’, a falling edge indicates bit
‘0’ and a no-change implies that the value is the same as
the previous bit.

Figure 5: Our Experimental Setup. Our framework
consists of an Intel Xeon-based server platform running
Suse Linux. We use cpusets to achieve spatially or tem-
porally isolated source and sink applications. We wrote
a custom source application that uses RSA decryption
operations to generate heat and a sink application that
records its own core’s temperature continuously.

separate cores on the Processor 1 with minimal interfer-
ence from the OS. To realise temporal partitioning, our
system incorporates a scheduler that controls the dura-
tion and cores on which the source and sink execute.

We wrote a custom application that performs an RSA
decryption (using PolarSSL [10]) continuously in a loop
and we use it as the source application of the covert chan-
nel. We chose a compute intense benchmark like RSA
because thermal sensors are typically located in the pro-
cessor’s region which is most likely to experience very
high temperatures, such as the ALU [53]. Hence, this
benchmark can quickly increase CPU temperature. This
choice of benchmark also complies with popular thermal
benchmarks (e.g. CStress [5], mprime [8]), that contain
applications which extensively use the CPU register ﬁle
and ALU.

We rely on the server fan for cooling the cores. Our
server allows the fan-speed to be conﬁgured only through
the BIOS. We set the fan-speed to the maximum allowed
value (15000 rpm) for our entire study. We chose this
setting because it is the most likely setting for servers
which run computationally intensive tasks. Our server is
currently in a room whose ambient temperature is around
22◦C. We also implemented a custom sink application
that records the temperature of the core on which it exe-
cutes continuously.

Our experimental framework is implemented using
C. It allows conﬁguration of run-time parameters like
the processor frequency, set of applications to run, their
schedule and mapping to cores.
Initialisation and tear
down of the measurement framework is performed using
a set of Perl and Bash scripts. Our setup allows us to

USENIX Association  

24th USENIX Security Symposium  871

INTEL XEONOS + cpusets + schedulerSOURCESINKS1S2S0S7I/ODRAMDRAMC3S3C4S4C5S5C6S6C0C1C2C7INTEL XEONS1S2S0S7C3S3C4S4C5S5C6S6C0C1C2C7PROCESSOR 1PROCESSOR 236

34

32

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

30

0

100

200

Time (s)

300

400

Figure 6: Temperature Drift due to the Sink’s Execu-
tion. The temperature drift caused by the execution of
the sink itself is very slow as shown here. This trace was
recorded over 400 s by running the sink application on
core 3 with all the other cores idle. Note that the resolu-
tion of the sensor is ±1◦C.

Temperature Drift due to the Sink’s Execution. The
sink relies on the source to affect its core’s temperature
sensor for communication. However, to do this, it is
necessary to isolate any temperature drifts that may be
caused by the sink’s execution itself on its own tempera-
ture sensor.

To understand these drifts better, we run the sink for
a long time and observe its temperature. Figure 6 shows
the temperature trace of core 3 when the sink is running
on it for 400 s and the other cores are idle. The core’s
temperature remains stable at around 33◦C for 200 s and
later drifts slowly towards 34◦C. Therefore, we conclude
that the temperature changes caused by the execution of
the sink process itself is negligible over a long duration
of time (e.g., 200 s).

Calibration of Tb. Before the actual transmission of
data, we have to determine the optimal value of Tb, i.e.
the duration for which the source executes or remains
idle to send bit ‘1’ and bit ‘0’ respectively. Note that the
actual value of Tb depends on the relative locations of
the source and the sink. This is because the effect of the
source’s execution affects the cores farther away from it
to a lesser extent (see Section 3). For our ﬁrst experi-
ments, we ﬁx the source to execute on a core 3 because
it is a central core and the sink to execute on core 2. We
later describe the effects of increasing the distance be-
tween the source and the sink on Tb.

To estimate Tb, we ﬁrst set it to a value between 50 ms
and 1500 ms. We then attempt to send 100 data bits from
the source on core 3 to the sink on core 2 and observe
the resulting temperature traces on core 2. We do this
by conﬁguring the source application to be active and

Tb(ms)

Bit Error (%)

Core 2
(1-hop)

Core 1
(2-hop)

250
500
750
1000
1250
1500

18
14
13
11
9
8

–
–
–
24
26
15

Table 1: Calibration of Tb in Spatially Partitioned
Systems. We send a block of 100 bits consisting of al-
ternating ones and zeroes using different Tb values from
the source (core 3) to the sink that runs at one and two
hop distances from it. The processor frequency was set
to 2.9 GHz and this table shows the resulting bit-error
rates (‘–’ indicates that the data could not be decoded).
We observe when Tb≥ 500 ms, we can decode data with
less than 15% error at one hop but this does not improve
much by increasing Tb to 1500 ms. We also notice that
the required Tb increases with greater distance from the
source. At a one hop distance, setting Tb = 750 ms and
using Hamming(7,4) error correction code results in a
channel throughput of up to 0.33 bps.

idle for Tb alternately. Our data consist of 50 alternating
ones and zeros. We choose this data sequence because
it is important to ensure that the chosen Tb consistently
results in the desired temperature increment on core 2.

We were unable to decode data when Tb was smaller
than 250 ms. We observe that data transmission using
Tb ≥ 500 ms results in about 10% bit errors (Table 1).
the bit error rate does
Furthermore, we notice that
not improve much by increasing Tb from 500 ms to
1500 ms. Figure 7 shows the temperature traces of the
two cores during the data exchange using a Tb = 750 ms.
The data shown here has been post-processed to remove
noise using a smoothing function. We observe that the
temperatures of core 3 and core 2 are well-correlated
(correlation co-efﬁcient (cid:28) 0.55, p-value = 0).
Error Rate. To understand the nature of errors in ther-
mal channels, we send a pseudorandom sequence of a
1000 bits in 100-bit blocks. Each block begins with a
preamble to enable the sink to detect the start of data
transmission.

From our initial experiments, we observe that the tem-
perature traces of core 2 and core 3 are well-correlated
in time over a sequence of alternating ones and zeros
(Figure 7). Therefore, we choose a preamble of ﬁve
alternating ones and zeroes (10 bits in total). The source
and sink synchronise in 9 out of 10 tests and the average
error rate is 13.22 % (± 5.19) for a Tb value of 500 ms.
On increasing Tb to 750 ms and 1000 ms, the source and

872  24th USENIX Security Symposium 

USENIX Association

45

40

35

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

Core 3
Core 2

Tb(ms)
250
500
750
1000
1250
1500

Bit Error (%)

2.9 GHz

2.4 GHz

18
14
13
11
9
8

–
23
24
23
14
14

30

0

5

10
15
Time (s)

20

25

Figure 7: Thermal Communication in Spatially Iso-
lated Systems. Temperature traces recorded during the
transmission of the 30 bits (15 ones and 15 zeroes)
from the source (core 3) to the sink (core 2) using a
Tb = 750 ms.

sink synchronise over all 10 tests and the average er-
ror rate is 11.3% (± 2.83) and 11% (± 3.83) respectively.
Varying the Sink’s Location. We repeat similar experi-
ments by running the sink on core 1 and core 0 which are
two and three hops away from the core 3 to see how the
error rate varies with increasing distance from the source.
At a two hop distance, we observe that for a given Tb, the
error rate is higher than in the case of the one hop (Ta-
ble 1). At a three hop distance, we were unable to decode
data at 1500 ms. However, increasing the value of Tb suf-
ﬁciently will allow data transmission at a 3-hop distance.
For example, Figure 3(c) shows an extreme case in which
Tb is set to 200 s to transmit bit ‘1’.

The increased error rate and deterioration in the
ability to decode data is expected. This is because heat
resulting from computations at a given core affects the
cores closer to it more than the cores farther away. We
repeated the experiments to estimate the error rate from
the source (core 3) to a sink running on core 1 at a
two hop distance. We observe that the source and sink
synchronise successfully in 9 out of 10 tests. We can
transmit data at the rate of 1 bit in 1.5 s (Tb = 1500 s)
with an error rate of 18.33% (±4.21).
Effect of Frequency on Tb. To understand the effect of
processor frequency on Tb, we repeated our experiments
for 1-hop communication at lower frequencies, namely,
2.4 GHz and 1.9 GHz. As shown in Table 2, for a given
Tb, the error rate increases at lower processor frequen-
cies. When the processor frequency is set to 1.9 GHz,
we could not decode data even at 1500 ms. We note that
using a larger value for Tb would solve this problem and
can be done using the same methodology we used for

Table 2: Effect of Processor Frequency on Required
Tb. We send a block of 100 bits consisting of alternat-
ing ones and zeroes using different Tb values from the
source (core 3) to the sink (core 2). The table shows the
resulting bit-error rates at different processor frequencies
(‘–’ indicates that the data could not be decoded). We ob-
serve that when the processor runs at lower frequencies,
Tb has to be increased to achieve lower bit-error rates.

our experiments. This deterioration in error rates and the
ability to decode data itself is expected because lower
frequencies result in lesser heat generation from a given
computation. Therefore, the rise in temperature may not
be signiﬁcant enough to detect a bit ‘1’ .

We repeated the data transmission experiments when
the processor frequency is set to 2.4 GHz. We transmit
a pseudo-random sequence of 1000 bits in 100-bit
blocks. Each block is preceded by a preamble and is
sent from the source (core 3) to the sink (core 2) using
Tb = 1250 ms and 1500 ms. In both cases, the source
and sink synchronise in all 10 tests. The observed error
rates in both cases is similar, i.e. 14.9% (± 3.9) and
15.9% (± 6.08) for Tb = 1250 ms and Tb = 1500 ms
respectively.

Throughput Estimation. From the above discussion,
we conclude that the throughput of thermal covert chan-
nels in spatially partitioned systems depends on number
of factors. This includes the time required to transmit one
bit of information (Tb) and error rates. Both these param-
eters in turn depend on the processor frequency and the
distance between the colluding processes.

At 1-hop distances, given a Tb of 750 ms, the through-
put would be 1.33 bps in the ideal case without any er-
rors. However, due to the 11% errors that we observe
in the experiments, actual communication would require
error correction to be implemented. When we analysed
the nature of the errors, we found that for every four bits,
with a probability of over 0.9, there was one or no er-
rors. Therefore, we could use a Hamming (7,4) error-
correction code to correct for these errors. This would re-
sult in 75% overhead and hence, an effective throughput
of 0.33 bps. When the frequency is changed to 2.4 GHz,
the throughput is about 0.2 bps using a Hamming (7,4)
error correction code. A similar trend was observed on

USENIX Association  

24th USENIX Security Symposium  873

Trace from Sink

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

38
37
36
35
34
33

2.55

2.6

Time (s)

2.65

Figure 8: Thermal Communication in Temporally Iso-
lated Systems. Temperature traces recorded during the
transmission of the 6 bits ( 3 ones and 3 zeroes) from the
source to the sink. The source and the sink execute in
alternate time-slots of 10 ms (marked in grey) on core 3.
The thick lines are the actual temperature traces recorded
by the sink and the dotted lines represent the temperature
changes that occur as a result of the source’s execution.

increasing the distance between the source and sink. Al-
though the thermal channel’s throughput is low, it still
allows the transfer of sensitive data like credit-card infor-
mation (16 digit) in a few minutes. We discuss other fac-
tors that affect the thermal channel’s throughput in Sec-
tion 5.4.

5.3 Covert Communication in Temporally

Partitioned Systems

Temporal partitioning schemes securely multiplex the
same resources (e.g. cores, memory) between several
applications. Systems that use this technique mitigate
information leakage through side channels by clearing
caches, registers, etc. while switching between pro-
cesses. However, the thermal footprint of an application
(the source) remains intact for observation by the other
application that executes after it on the same core
(the sink). This is a result of the thermal capacitance
and resistance of processors and can be exploited to
communicate covertly as our experiments demonstrate.

Scheduling, Encoding and Decoding Schemes.
In
temporally partitioned systems, a scheduler determines
the order in which different partitions execute on a core.
Therefore, we implement a scheduler (Figure 5) that
realises this functionality. Since the sink and source
share the same core, they run in an interleaved manner
and the sink has access to the temperature sensors only
during its execution time-slice (ts). Note that ts is con-
trolled by the system’s scheduler while Tb is controlled

Tb(ms)
10
15
20
25
30

Bit Error (%)

2.9 GHz

2.4 GHz

1.9 GHz

0
0
0
0
0

4
1
0
0
0

0
1
1
0
0

Table 3: Effect of Processor Frequency on Required
Tb. We send a block of 100 bits consisting of alternat-
ing ones and zeroes using different Tb values from the
source (core 3) to the sink that runs on the same core.
The table shows the resulting bit-error rates at different
processor frequencies. We observe that the error rates do
not change much even at lower processor frequencies.
Setting the frequency to 2.9 GHz, Tb to 10 ms and using
Hamming(7,4) error correction code leads to the channel
throughput of up to 12.5 bps.

by the applications. If the execution time-slice (ts) ≤ Tb,
then communication becomes difﬁcult because the
source cannot generate enough heat to transmit ‘1’ bits.
However, if ts ≥ Tb, then the source can choose to
execute for long enough to cause a temperature change
that the sink notices. Note that temperature variations
over the course of the source’s execution within one
time-slice are not visible to the sink; instead the sink
only has access to the ﬁnal temperature after the source’s
execution time-slice. Therefore, in our implementation,
the source sends a single bit per time-slice (using the
temperature at the end of that time-slice) to the sink over
a thermal covert channel, i.e. Tb = ts. We use the same
On-Off keying technique as before in Section 5.2.

Calibration of Tb. We consider the scenario in which
the sink and the source share a core and run in a round-
robin fashion. The source heats up the processor (bit ‘1’)
or stays idle (bit ‘0’) to send one bit of information to the
sink application that runs immediately after.

In order to understand how fast one can transmit bits
over such a channel, we do the following. We try to
send an alternating sequence of 50 ones and 50 zeroes
from the source to the sink. We vary Tb between 10 ms
which is the minimum value that our framework allows
and 30 ms. The source and sink run on core 3 in our
experiments. Figure 8 shows an example temperature
trace that the sink records during its execution. Note
that the sink has access to the shared core’s temperature
sensor only during its own time-slice. We observed no
errors in the data that the sink decodes for Tb ≥ 10 ms
and therefore, use this value for further experiments. We
also repeated the experiment on the cores at the corners
(core 0 and core 7) and noticed similar results.

874  24th USENIX Security Symposium 

USENIX Association

Error Rate. To understand the nature of errors in this
channel, we send a pseudorandom stream of 1000 bits
in 100-bit blocks using Tb = 10 ms. We send 10 bits for
synchronisation at the beginning of every block similar
to the experiments in Section 5.2. The synchronisation
using the preamble was successful in all cases and the
data transmission resulted in error rates of 7.6% (± 1.9),
9.5% (± 4.86) and 7.1% (± 2.23) for experiments on
cores 0, core 3 and core 7 respectively.

Effect of processor frequency on Tb. We repeated
our experiments at two lower processor frequencies to
understand how it may affect the required Tb for reliable
In the Tb calibration experiments,
communication.
the error rates remain low despite the decrease in
frequency (Table 3). In the actual data transmission tests
(of 1000 bits in 100 bit blocks) at 2.4 GHz, the source
and the sink successfully synchronise in all 10 tests
and the error rate is about 6.5% (±3.58). At 1.9 GHz
however, the synchronisation succeeds only 5 out of 10
times and the error rate is 9.5% (±2.55). This indicates
that a higher Tb value is required for more reliable
communication at this lower processor frequency.

Throughput Estimation. The throughput of the thermal
channel in temporally partitioned systems depends on the
execution schedule of the applications and the time re-
quired to send one bit of information (Tb = ts). We note
that typical Linux systems have a time-slice of about 100
ms which is 10 times bigger than the one we need for
implementing thermal covert channels.

When Tb is 10 ms, we would expect the throughput of
the thermal channel would be 50 bps. However, since
the communication is error prone and results in up to
10% error, the encoding scheme would have to incor-
porate error correction codes. On analysing the nature
of the errors during the transmission of a 1000 bits, we
see that with a probability of over 0.9, there is 1 or no
errors in every four data bits. Therefore, we can use a
Hamming(7,4) code to overcome these errors and this re-
sults in an effective throughput of about 12.5 bps. This
throughput is independent of which particular core the
source and sink share (core 0/3/7). A Tb of 10 ms re-
sults in low error rates even at a processor frequency of
2.4 GHz and hence, the throughput is roughly 12.5 bps.
We note that this data rate would allow the transmission
of sensitive information such as credit-card details (16
digits) in about 5 s.

discuss additional parameters that affect the throughput.
An exhaustive evaluation of these factors is beyond the
scope of the paper and is intended as part of future work.

Noise from Other Workloads. On a given system,
the throughput of a thermal communication channel
will depend on the actual workloads running on that
In the case of thermal channels in spatially
platform.
partitioned systems,
the exact effect of a concurrent
workload on the throughput will likely depend on the
nature of the workload and its relative distance from the
sink’s core. On the one hand, a workload that saturates
its own core’s temperature is only likely to increase
the sink’s temperature by a constant amount without
disturbing the actual communication patterns. On the
other hand, a workload that runs in the opposite schedule
as the source (i.e. it is active whenever the source is idle
and vice-versa) is likely to result in increased errors at
the sink’s core. Analogous discussions hold in the case
of temporal channels. Finally, if the attacker controls
more than one core on the platform,
then he could
potentially generate more heat and build faster channels
but this requires further exploration.

Other Encoding and Error-Correction Schemes.
In
our experiments, we used the On-Off keying technique
to transmit data.
Instead, to improve throughput, one
could borrow techniques from signal processing and
telecommunications such as multi-level encoding. One
could alternatively use bi-phase encoding schemes such
as Manchester-coding that would lower the data rate
(e.g. by half) but also result in fewer errors. Further-
more, in order to detect and correct more than single-
bit errors, one could implement alternative error correc-
tion schemes such as Reed-Solomon [62] or BCH [18].
For example, a Reed-Solomon RS(32,28) code encodes
a 28-word data into a 32-word codeword and is capable
of correcting errors up to 2-words in length.

We note that our experiments were performed in con-
ditions that minimise any noise that may arise from other
concurrent workloads such as the OS. Given this and the
low resolution of the thermal sensors (±1◦C), we believe
that an order of magnitude improvement in the through-
put is unlikely.

6 Thermal Channels

Proﬁling

for Unauthorised

5.4 Other Factors Affecting Throughput
We have explored how factors like processor frequency
and relative locations of the source and sink affect the
throughput of the thermal covert channel. Below we

In this section, we present a preliminary study of how
thermal side channels enable unauthorised thermal pro-
ﬁling of processes even in systems that implement strong
isolation mechanisms like spatial resource partitioning.
In contrast to thermal covert channels in which the source

USENIX Association  

24th USENIX Security Symposium  875

and the sink collude to exchange data, thermal side chan-
nels allow an attacker to exﬁltrate information from a vic-
tim without requiring any cooperation from the victim.

The heat generated from an application (which we
refer to as the victim) can be observed from its neigh-
bours. This may leak information regarding the nature
of its computation to processes at other cores. More
speciﬁcally, if the attacker has reference thermal traces
for victim applications, he can recognise if and when
such an application executes on a neighbouring partition.
For example, identifying that a sensitive or potentially
vulnerable application is running on a neighbouring
core may aid an attacker in preparing or launching an
attack. Application identiﬁcation based on temperature
traces has not been addressed previously in literature.
Below we present a ﬁrst study that tries to understand its
effectiveness as an attack vector.

Goal and Intuition of the Attack. We assume that
an attacker has access to a reference thermal trace of
the victim application (say RSA decryption). Such a
trace can be obtained by the attacker if he has access
to a similar platform as the one he is attacking. The
attacker’s goal is to verify if the temperature trace of
his core is a result of the victim application’s execution
on a neighbouring core. Note that the attacker does not
have access to the temperature trace of its neighbouring
core(s) but only to that of his own core. For simplicity,
we assume that only the attacker and the victim are
active during the attack and that they are collocated
on adjacent cores. The attacker continuously monitors
his own core’s temperature and then, correlates it with
a reference trace of the victim application. A strong
correlation indicates that the attacker’s temperature trace
was a result of the execution of the victim application
with high probability.

Experiments and Analysis. We chose a set of ﬁve CPU-
intensive applications including RSA decryption and
four applications from a benchmark suite, MiBench [32]
(ADPCM, Quick Sort, BitCount, BasicMath) and use
them as the universal set of applications that a victim
core (core 3) executes. We intentionally chose similar
applications all of which stress the ALU and register ﬁle
region of the core. This choice makes our task harder
than distinguishing between applications with very dis-
tinct thermal behaviour, for example, an idle applica-
tion vs. a thermal benchmark. A deeper exploration of
the thermal behaviour of different classes of applications
(memory intensive, I/O intensive, etc.) and their distin-
guishability is out of the scope of this work.

To understand the feasibility of identifying these ap-
plications, we ran each of them for 200 s on core 3 of our
setup (Section 5.1) and collected the temperature traces

40

35

30

)

C
 
°
(
 
e
r
u
t
a
r
e
p
m
e
T

 

25

0

RSA
BitCount
QSORT
BasicMath
ADPCM

50

150

100
Time (s)

200

250

Figure 9: Example Temperature Traces of Different
Applications. We used a set of ﬁve CPU intensive
applications (RSA decryption, BitCount, QSort, Basic-
Math, ADPCM) from a popular MiBench benchmark
suite [32]. We ran each application for 200 s separately
and recorded the resulting temperature traces on a neigh-
bouring core.

of a neighbouring core (core 2). We repeated this ﬁve
times for each of the applications and Figure 9 shows
one such trace for each of them. We observe that the sat-
uration temperature for the RSA decryption application
is higher than the rest.

We use simple correlation as a metric to measure sim-
ilarity/differences between pairs of applications. We ﬁrst
correlated the traces from the RSA application. Since
there are 5 runs, we have 10 pairs to correlate. We ob-
serve that the correlation is higher than 85% in seven
out of ten occasions. Using this same correlation thresh-
old of 85% also results in 28% false positives when the
RSA application is correlated with the others from the
benchmark suite.
In general, traces belonging to the
same application have high correlation values (≥ 80%).
However, traces belonging to different applications also
show high correlation because they are all CPU inten-
sive and stress similar parts of the CPU (≥ 75%). There-
fore, we conclude that using a simple correlation metric
would only allow distinguishing applications that behave
very differently. More sensitive metrics (such as ther-
mal models [60] or machine-learning based classiﬁers)
are required for better accuracy in other cases.

Finally, more ﬁne-grained data exﬁltration such as de-
ducing AES or RSA keys on commodity x86-systems
using the thermal side channel is an open, unexplored
problem. A key challenge is the limited resolution of the
temperature sensors which is ±1◦C and the rate at which
the sensors are refreshed (currently, once every 2 ms).

876  24th USENIX Security Symposium 

USENIX Association

7 Discussion

In this section, we present possible countermeasures
against thermal channels and discuss their limitations.
We also discuss a potential security application for
thermal channels.

Countermeasures. Since we leveraged the tempera-
ture information exposed to software to construct ther-
mal channels, a natural solution to this problem would
be to restrict access to temperature sensors on the sys-
tem. However, such information cannot always remain
hidden. For example, centralised control and monitor-
ing of thermal states does not scale well with the ad-
vent of many-core processors [41]. Such processors con-
tain hundreds of cores and host a large number of au-
tonomous processes on separate cores. In fact, research
prototypes like Intel’s SCC platform [41] already allow
subsets of cores to administer their frequency and volt-
age independently for power-efﬁciency; temperature in-
formation is a vital input to this decision process. The
software at each core should track thermal information
to schedule intelligently and to detect if any of its threads
are misbehaving. Therefore, there is a tension between
securing platforms and improving their energy-efﬁciency
by exposing thermal data to software applications.

Even if one restricts access to the temperature sensors,
related parameters may still leak information about the
system’s thermal state. Examples of such parameters
are clock skew, fan speed and even processor frequency
in systems that allow dynamic frequency scaling. Since
all these parameters are usually common across cores
or subsets of cores within a processor chip, they can
still provide a signalling mechanism. Finally, while it
may be possible to separate processes temporally and
spatially to limit the effectiveness of thermal channels,
such resource allocation strategies are wasteful and
result in low resource utilisation.

Thermal Fingerprinting For Security. So far we dis-
cussed only how thermal behaviour of systems can be ex-
ploited by attackers. The same properties could be used
for achieving better security. Since temperature changes
resulting from computations are difﬁcult to avoid, we hy-
pothesise that thermal proﬁling techniques can also be
used to detect any anomalous behaviour in the execution
of an application. More speciﬁcally, it is highly likely
that run-time compromise of an application results in a
temperature trace that does not match its original ther-
mal ﬁngerprint. It has been shown to be possible to ex-
tract thermal models by monitoring the application under
controlled conditions [60, 61]. By comparing the actual
execution trace to the expected trace, it may be possible
to detect run-time compromise of software applications.

More generally, understanding the capacity of thermal
channels using information theory will help assess the
throughput of covert communication. Similarly, a the-
oretical estimation of the entropy of such channels will
help bound ﬁngerprint accuracy and hence, side channel
leakage. A more detailed study along these lines is an
interesting direction for future work.

8 Related Work

We review previous work on covert and side channels
on x86 systems and on thermal channels in general.
We also provide examples of existing literature on
optimising computing systems for thermal efﬁciency
because it highlights the advantages of exposing thermal
data as opposed to the other work that misuses this data
to undermine security.

Thermal Channels and Attacks. There is no previous
work that demonstrates the feasibility of thermal covert
and side channels on commodity multi-core systems as
we do in this paper. Previously, two works discussed
and one implemented thermal covert channels on FPGA
boards [19, 38, 51]. There have also been attempts to
transmit data between two processes by changing fan-
speed [20]. The ability to remotely monitor a system’s
clock-skew (inﬂuenced by the changes in the system
temperature) has also been exploited in the past for ex-
posing anonymous servers [56, 75] and covert commu-
nication with a remote entity [74]. We note that although
some of these works [20, 74] use the term thermal chan-
nel, none of them use the thermal information available
on modern systems to covertly communicate between
processes on the same host as we do in this paper.

More recently, it has been shown that it is possible to
use temperature variations to induce processor faults [59]
which can in turn be also be used to extract sensitive in-
formation like RSA keys [37]. Thermal information can
also be used for coarse-grained data-exﬁltration. For ex-
ample, since temperature directly reﬂects the intensity
of computation, it can be used to estimate the load or
resource utilisation of a machine. This was illustrated
by Liu et al. who computed the resource utilisation of
servers in Amazon’s EC2 using the temperature data that
is exposed to virtual machines [49].

Previous research has identiﬁed other security risks
that arise from hardware and software thermal manage-
ment techniques on modern systems. For example, mali-
cious processes may cause a denial-of-service by slowing
down the processor [33] or permanently damaging hard-
ware by causing thermal hotspots [27]. Such processes
could exploit the fact that certain architecture compo-
nents (e.g. instruction cache) are ignored by thermal op-
timisation approaches on processors [45].

USENIX Association  

24th USENIX Security Symposium  877

Covert and Side Channels on x86-Systems. Originally
deﬁned by Lampson as part of the conﬁnement prob-
lem [46], today, several covert channels have been iden-
tiﬁed and explored in the context of x86 systems. Covert
channels can be classiﬁed either as timing or storage
channels. Timing covert channels transmit information
in terms of the timing of certain events. Examples of
timing covert channels include cache-based and mem-
ory bus-based channels both of which were ﬁrst demon-
strated by Hu [34, 35]. Wang et al. identify more timing
channels that arise out of processor extensions such as
multi-threading and speculative execution [68]. Wu et al.
achieve improved data rates on bus-based channels [71].
Covert timing channels that use other types of shared re-
sources like virtual memory deduplication [72] and input
devices such as keyboards [64] have also been studied.

In contrast to timing channels, storage channels rely
on the source writing the data (indirectly) into a shared
resource which the sink reads at a later point in time.
Lampson’s ﬁle system based covert channel [46] and
covert channels that exploit CPU registers (e.g. FPU reg-
isters that signal exceptions) [65] are examples of such
channels. Interestingly, certain types of covert channels
such as those based on the hard-disk [70] and processor
cache [22, 35] can be used to realise timing and storage
channels. We could classify the thermal covert channels
as storage channels because they use the CPU registers
to (indirectly) exchange information.

While covert channels rely on two colluding entities
for data exﬁltration, side channels can be used to ex-
tract information from a unsuspecting victim without
any co-operation from it. Side channels can be clas-
siﬁed as access-driven channels, trace-driven channels
and timing-driven channels. Access-driven side chan-
nels rely on a victim’s modiﬁcations to a shared resource
(e.g. cache) to extract sensitive information (e.g. AES
keys [76]). Trace-driven channels require measuring a
certain aspect of the system such as power (e.g. [43])
or electromagnetic emanations (e.g. [29]) continuously
as the victim executes. Finally, timing-based side chan-
nels measure the time consumed by sensitive opera-
tions (e.g. cryptographic functions) to extract informa-
tion (e.g. such as AES keys [17]). In general, side chan-
nels are used for cryptanalysis. Example attacks include
extraction of AES keys [11, 17, 42, 76], DES keys [58]
and RSA keys [22, 43, 44]. They can also be used
to extract more coarse-grained information such as co-
residency [63], existence of ﬁles [67], etc. The thermal
side channel can be viewed as a trace-driven side chan-
nel that continuously tracks temperature to identify the
computation at a neighbouring core.

One way to mitigate timing channels (both covert
and side channels) in general is to expose less accurate
timing information [34]. This technique is unlikely

to be effective against thermal channels because they
do not exploit timing information. Another general
approach against side and covert channels is to partition
system resources. This is for example used to mitigate
cache-based channels [68] and bus-based channels [31].
However, such partitioning techniques will not eliminate
temperature-based channels completely as demonstrated
in this paper.

Thermal Monitoring of Processors. Temperature man-
agement of computing systems has gained importance
over the last few years due to the increasing on-chip
temperatures of modern processors. This has resulted
in efforts to design and implement better thermal man-
agement techniques for processors. Examples include
optimisation of sensor placement (e.g. [53, 55]),
im-
proving algorithms for dynamic temperature manage-
ment (e.g. [73]) and cooling techniques [25]. There are
also ongoing efforts to develop frameworks to thermally
proﬁle applications [61], build temperature-aware sched-
ulers [24, 26] and micro-architectures [48, 66]. Thermal
proﬁling can further be used to detect compromised pro-
cess in embedded systems [69] and design schedulers
such that they do not leak information through thermal
ﬁngerprints of applications [16].

9 Conclusion

In this paper, we demonstrated the feasibility and poten-
tial of thermal channels on commodity multi-core sys-
tems. We showed that such channels can be built by
exploiting the thermal behaviour of current platforms.
Thermal channels can be used to circumvent strong iso-
lation guarantees provided by temporal and spatial par-
titioning techniques. Our experiments indicate that it is
possible to use them for covert communication between
processes and achieve a throughput of up to 12.5 bps. We
also demonstrated that thermal channels can be exploited
to proﬁle applications running on a neighbouring core.
Our work points to a limitation in the isolation guaran-
tees that resource partitioning techniques can provide.

Attacks based on thermal channels are further facil-
itated by the increasing trend towards exposing system
temperature information to users. This would enable
users to make thermal management decisions for efﬁ-
cient system operation. This paper highlights the tension
between designing systems to support user-centric ther-
mal management for efﬁciency and security.

10 Acknowledgments

This work was carried out as a part of the SAFURE project,
funded by the European Union’s Horizon 2020 research

878  24th USENIX Security Symposium 

USENIX Association

and innovation program under grant agreement number
644080. This work was partially supported by the Zurich
Information Security and Privacy Center.
It represents
the views of the authors.

References
[1] CoreTemp. http://www.alcpu.com/CoreTemp/.
[2] CPU frequency and voltage scaling code in the Linux(TM)
https://www.kernel.org/doc/Documentation/

kernel.
cpu-freq/governors.txt.
[3] CPU Monitoring With

DTS/PECI.
//www.intel.com/content/www/us/en/
embedded/testing-and-validation/
cpu-monitoring-dts-peci-paper.html.

http:

[4] CPU Sets.

cpuset.7.html.

http://man7.org/linux/man-pages/man7/

[5] CPUBurn-in.

http://manpages.ubuntu.com/manpages/

precise/man1/cpuburn.1.html.

[6] Hitachi Embedded Virtualisation Technology.

http://www.

hitachi-america.us/supportingdocs/forbus/ssg/
pdfs/Hitachi_Datasheet_Virtage_3D_10-30-08.pdf.

[7] lstopo.

http://manpages.ubuntu.com/manpages/

oneiric/man1/lstopo.1.html.

[8] Mersenne Prime Search. http://www.mersenne.org/.
[9] Open Hardware Monitor.

http://openhardwaremonitor.

org/.

[10] SSL Library PolarSSL. https://polarssl.org.
[11] ACIIC¸ MEZ, O., SCHINDLER, W., AND KOC¸ , C. Cache based
remote timing attack on the aes. In Topics in Cryptology — CT-
RSA. 2007.
[12] ADAPTEVA.

Ephiphany Multicore

http:

IP.

//www.adapteva.com/products/epiphany-ip/
epiphany-architecture-ip/.

[13] ADVANCED MICRO DEVICES. Cool and Quiet Technology
Installation Guide for AMD Athlon 64 Processor Based Sys-
tems.
http://www.amd.com/Documents/Cool_N_Quiet_
Installation_Guide3.pdf.

[14] AMIT DANIEL, VINCENT GUITTOT, R. L. A Simpliﬁed Ther-

mal Framework for ARM Platforms.

[15] ARM. Building a Secure System using TrustZone Technology.

http://www.arm.com, 2009.

[16] BAO, C., AND SRIVASTAVA, A. A Secure Algorithm for Task
Scheduling Against Side-channel Attacks. In Workshop on Trust-
worthy Embedded Devices (2014), TrustED ’14.

[17] BERNSTEIN, D.

J.

Cache-timing Attacks on AES.

http://palms.ee.princeton.edu/system/files/
Cache-timing+attacks+on+AES.pdf, 2005.

[18] BOSE, R. C., AND RAY-CHAUDHURI, D. K. On a Class of Error

Correcting Binary Group Codes. Information and control.

[19] BROUCHIER, J., DABBOUS, N., KEAN, T., MARSH, C., AND

NACCACHE, D. Thermocommunication, 2009.

[20] BROUCHIER, J., KEAN, T., MARSH, C., AND NACCACHE, D.

Temperature Attacks. Security Privacy, IEEE (2009).

[21] BROWN, L., AND SESHADRI, H. Cool Hand Linux* Handheld

Thermal Extensions. In Linux Symposium (2007).

[22] BRUMLEY, D., AND BONEH, D. Remote timing attacks are prac-
tical. In Proceedings of the USENIX Security Symposium (2003),
USENIX-SS ’03.

[23] BUERKI, R., AND RUEEGSEGGER, A.-K. Muen-an x86/64 sep-
aration kernel for high assurance. http://muen.codelabs.
ch/muen-report.pdf, 2013.

[24] CHOI, J., CHER, C.-Y., FRANKE, H., HAMANN, H., WEGER,
A., AND BOSE, P. Thermally-Aware Task Scheduling at the Sys-
tem Software Level.
In Symposium on Low Power Electronics
and Design (2007), ISLPED ’07.

[25] CHU, R. C., SIMONS, R. E., ELLSWORTH, M. J., SCHMIDT,
R. R., AND COZZOLINO, V. Review of Cooling Technologies for
Computer Products. IEEE Transactions on Device and Materials
Reliability (2004).

[26] COSKUN, A. K., ROSING, T. S., WHISNANT, K. A., AND
GROSS, K. C. Static and Dynamic Temperature-aware Schedul-
ing for Multiprocessor SoCs. IEEE Transactions on Very Large
Scale Integration (VLSI) Systems (2008).

[27] DADVAR, P., AND SKADRON, K. Potential Thermal Security
In Semiconductor Thermal Measurement and Manage-

Risks.
ment Symposium (2005).

[28] DONALD, J., AND MARTONOSI, M. Techniques for Multi-
core Thermal Management: Classiﬁcation and New Exploration.
In International Symposium on Computer Architecture (2006),
ISCA ’06.

[29] GANDOLFI, K., MOURTEL, C., AND OLIVIER, F. Electromag-
netic analysis: Concrete results. In Cryptographic Hardware and
Embedded Systems, CHES ’01. 2001.

[30] GLIGOR, V. A guide to understanding covert channel analysis of

trusted systems. Tech. rep., DTIC Document, 1993.

[31] GUNDU, A., SREEKUMAR, G., SHAFIEE, A., PUGSLEY, S.,
JAIN, H., BALASUBRAMONIAN, R., AND TIWARI, M. Memory
Bandwidth Reservation in the Cloud to Avoid Information Leak-
age in the Memory Controller. In Workshop on Hardware and Ar-
chitectural Support for Security and Privacy (2014), HASP ’14.
[32] GUTHAUS, M. R., RINGENBERG, J. S., ERNST, D., AUSTIN,
T. M., MUDGE, T., AND BROWN, R. B. MiBench: A free, com-
mercially representative embedded benchmark suite.
In Work-
shop on Workload Characterization (2001), WWC ’01.

[33] HASAN, J., JALOTE, A., VIJAYKUMAR, T., AND BRODLEY, C.
Heat stroke: Power-density-based Denial of Service in SMT. In
Symposium on High-Performance Computer Architecture (2005),
HPCA’05.

[34] HU, W.-M. Reducing Timing Channels With Fuzzy Time. In

Research in Security and Privacy (1991).

[35] HU, W.-M. Lattice Scheduling and Covert Channels.

search in Security and Privacy (1992).

In Re-

[36] HUANG, W., GHOSH, S., VELUSAMY, S., SANKARA-
NARAYANAN, K., SKADRON, K., AND STAN, M. HotSpot: A
Compact Thermal Modeling Methodology for Early-stage VLSI
Design.
IEEE Transactions on Very Large Scale Integration
(VLSI) Systems (2006).

[37] HUTTER, M., AND SCHMIDT, J.-M. The Temperature Side
IACR Cryptology ePrint

Channel and Heating Fault Attacks.
Archive (2014).

[38] IAKYMCHUK, T., NIKODEM, M., AND KEPA, K. Temperature-
based Covert Channel in FPGA Systems. In Workshop on Recon-
ﬁgurable Communication-centric Systems-on-Chip (ReCoSoC)
(2011).

[39] INTEL CORPORATION.

http:
//www.intel.com/support/processors/sb/CS-032349.
htm?wapkw=intel+speedstep.

Intel SpeedStep FAQ.

[40] INTEL

CORPORATION.
Technology
Programming Guide.

tion
ment
eu/content/www/eu/en/software-developers/
intel-txt-software-development-guide.html.

Execu-
Environ-
Launched
http://www.intel.

Measured

Trusted

Intel

USENIX Association  

24th USENIX Security Symposium  879

[41] INTEL CORPORATION.

SCC External Architecture Speci-
ﬁcation.
https://communities.intel.com/servlet/
JiveServlet/previewBody/5852-102-1-9012/SCC_EAS.
pdf.

[59] RAHIMI, A., BENINI, L., AND GUPTA, R. Analysis of
Instruction-Level Vulnerability to Dynamic Voltage and Temper-
ature Variations. In Design, Automation Test in Europe Confer-
ence Exhibition (2012), DATE’12.

[42] IRAZOQUI, G., INCI, M., EISENBARTH, T., AND SUNAR, B.
Wait a Minute! A Fast, Cross-VM Attack on AES. In Research
in Attacks, Intrusions and Defenses (2014), RAID’14.

[43] KOCHER, P., JAFFE, J., AND JUN, B. Differential power analy-

sis. In Advances in Cryptology (1999), CRYPTO ’99.

[44] KOCHER, P. C. Timing Attacks on Implementations of Difﬁe-
Hellman, RSA, DSS, and Other Systems. In Advances in Cryp-
tology (1996), CRYPTO’96.

[45] KONG, J., JOHN, J., CHUNG, E.-Y., CHUNG, S. W., AND HU,
J. On the Thermal Attack in Instruction Caches. IEEE Transac-
tions on Dependable and Secure Computing (2010).

[46] LAMPSON, B. W. A Note on the Conﬁnement Problem. Com-

mun. ACM (1973).

[47] LEE, K.-J., SKADRON, K., AND HUANG, W. Analytical Model
for Sensor Placement on Microprocessors. In International Con-
ference on Computer Design: VLSI in Computers and Processors
(2005), ICCD ’05.

[48] LIM, C. H., DAASCH, W. R., AND CAI, G. A Thermal-
Aware Superscalar Microprocessor. In International Symposium
on Quality Electronic Design (2002).

[49] LIU, H. A Measurement Study of Server Utilization in Public
Clouds.
In 2011 IEEE Ninth International Conference on De-
pendable, Autonomic and Secure Computing (2011), DASC ’11.
[50] MARFORIO, C., RITZDORF, H., FRANCILLON, A., AND CAP-
KUN, S. Analysis of the Communication Between Colluding Ap-
plications on Modern Smartphones. In Computer Security Appli-
cations Conference (2012), ACSAC ’12.

[60] RAI, D., AND THIELE, L. A Calibration Based Thermal Mod-
eling Technique for Complex Multicore Systems. In Design, Au-
tomation Test in Europe Conference Exhibition (2015), DATE’15.
[61] RAI, D., YANG, H., BACIVAROV, I., AND THIELE, L. Power
Agnostic Technique for Efﬁcient Temperature Estimation of Mul-
ticore Embedded Systems. In Compilers, Architectures and Syn-
thesis for Embedded Systems (2012), CASES ’12.

[62] REED, I. S., AND SOLOMON, G. Polynomial codes over certain
ﬁnite ﬁelds. Journal of the Society for Industrial and Applied
Mathematics (1960).

[63] RISTENPART, T., TROMER, E., SHACHAM, H., AND SAVAGE,
S. Hey, you, get off of my cloud: Exploring Information Leakage
in Third-party Compute Clouds. In Computer and Communica-
tions Security (2009), CCS’09.

[64] SHAH, G., MOLINA, A., AND BLAZE, M. Keyboards and
In USENIX Security Symposium (2006),

Covert Channels.
USENIX-SS’06.

[65] SIBERT, O., PORRAS, P., AND LINDELL, R. An Analysis of the
Intel 80x86 Security Architecture and Implementations. Software
Engineering, IEEE Transactions on (1996).

[66] SKADRON, K., STAN, M. R., HUANG, W., VELUSAMY, S.,
SANKARANARAYANAN, K., AND TARJAN, D. Temperature-
aware Microarchitecture.
SIGARCH Comput. Archit. News
(2003).

[67] SUZAKI, K., IIJIMA, K., YAGI, T., AND ARTHO, C. Memory
Deduplication As a Threat to the Guest OS. In European Work-
shop on System Security (2011), EUROSEC ’11.

[51] MARSH, C., AND MCLAREN, D. Poster: Temperature side
channels. In Workshop on Cryptographic Hardware and Embed-
ded Systems (2007), CHES’07.

[68] WANG, Z., AND LEE, R. Covert and Side Channels Due to Pro-
cessor Architecture. In Computer Security Applications Confer-
ence (2006), ACSAC ’06.

[52] MCKEEN, F., ALEXANDROVICH, I., BERENZON, A., ROZAS,
C. V., SHAFI, H., SHANBHOGUE, V., AND SAVAGAONKAR,
U. R. Innovative Instructions and Software Model for Isolated
Execution. In Workshop on Hardware and Architectural Support
for Security and Privacy (2013), HASP’13.

[53] MEMIK, S. O., MUKHERJEE, R., NI, M., AND LONG, J. Op-
timizing Thermal Sensor Allocation for Microprocessors. IEEE
Transactions on Computer-Aided Design of Integrated Circuits
and Systems (2008).

[54] MILEVA, A., AND PANAJOTOV, B. Covert channels in TCP/IP
protocol stack - extended version. Central European Journal of
Computer Science (2014).

[55] MUKHERJEE, R., AND MEMIK, S. O. Systematic Temperature
Sensor Allocation and Placement for Microprocessors. In Design
Automation Conference (2006), DAC ’06.

[56] MURDOCH, S. J. Hot or Not: Revealing Hidden Services by
Their Clock Skew. In Computer and Communications Security
(2006), CCS ’06.

[57] NOORMAN, J., AGTEN, P., DANIELS, W., STRACKX, R.,
VAN HERREWEGE, A., HUYGENS, C., PRENEEL, B., VER-
BAUWHEDE, I., AND PIESSENS, F. Sancus: Low-cost Trustwor-
thy Extensible Networked Devices with a Zero-software Trusted
Computing Base.
In USENIX Conference on Security (2013),
USENIX-SS ’13.

[58] PAGE, D. Theoretical Use of Cache Memory as a Cryptanalytic
Side-Channel. https://eprint.iacr.org/2002/169.pdf.

[69] WOLF, T., MAO, S., KUMAR, D., DATTA, B., BURLESON,
W., AND GOGNIAT, G. Collaborative Monitors for Embed-
ded System Security.
https://hal.archives-ouvertes.
fr/hal-00089605, 2006.

[70] WRAY, J. An Analysis of Covert Timing Channels. In Research

in Security and Privacy (1991).

[71] WU, Z., XU, Z., AND WANG, H. Whispers in the Hyper-space:
In USENIX

High-speed Covert Channel Attacks in the Cloud.
Security Symposium (2012), Usenix-SS ’12.

[72] XIAO, J., XU, Z., HUANG, H., AND WANG, H. Security Impli-
cations of Memory Deduplication in a Virtualized Environment.
In Dependable Systems and Networks (2013), DSN’13.

[73] YEO, I., LIU, C. C., AND KIM, E. J. Predictive Dynamic Ther-
mal Management for Multicore Systems. In Design Automation
Conference (2008), DAC ’08.

[74] ZANDER, S., BRANCH, P., AND ARMITAGE, G. Capacity of
Temperature-Based Covert Channels. Communications Letters,
IEEE (2011).

[75] ZANDER, S., AND MURDOCH, S. J. An Improved Clock-
skew Measurement Technique for Revealing Hidden Services. In
USENIX Security Symposium (2008), USENIX-SS’08.

[76] ZHANG, Y., JUELS, A., REITER, M. K., AND RISTENPART, T.
Cross-VM Side Channels and Their Use to Extract Private Keys.
In Computer and Communications Security (2012), CCS ’12.

880  24th USENIX Security Symposium 

USENIX Association

