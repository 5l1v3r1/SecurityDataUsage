Identifying Cross-origin Resource Status Using

Application Cache

Sangho Lee, Hyungsub Kim, and Jong Kim
Department of Computer Science and Engineering
{sangho2, hyungsubkim, jkim}@postech.ac.kr

POSTECH, Korea

Abstract—HTML5 Application Cache (AppCache) allows web
applications to cache their same- and cross-origin resources in
the local storage of a web browser to enable ofﬂine access.
However, cross-origin resource caching in AppCache has potential
security and privacy problems. In this paper, we consider a novel
web privacy attack that exploits cross-origin AppCache. Our
attack allows a remote web attacker to exploit a victim web
browser to exactly identify the status of target URLs: existence,
redirection, or error. Especially, our attack can be performed
without using client-side scripts, can concurrently identify the
status of multiple URLs, and can exactly identify the redirections
of target URLs. We further demonstrate advanced attacks that
leverage the basic attack to de-anonymize and ﬁngerprint victims.
First, we determine the login status of a victim web browser by
identifying URL redirections or errors due to absent or erroneous
login information. Second, we probe internal web servers located
in the local network of a victim web browser by identifying URL
existence. We also suggest an effective countermeasure to mitigate
the proposed attacks.

I.

INTRODUCTION

The Web has become the most popular distributed appli-
cation platform due to its high cross-platform compatibility.
Users can launch a web application on any web browser in any
platform without modiﬁcation or with negligible modiﬁcation.
Therefore, many applications, including email, calendars, word
processors, and spreadsheets, are being implemented as web
applications.

However,

the Web’s popularity has made it

the most
valuable attack target, so that users demand an in-depth
security analysis of the Web to prevent attacks before they
rapidly spread. Numerous researchers have considered various
web attacks, such as clickjacking [16], cross-site scripting
(XSS) [33], cross-site request forgery (CSRF) [4], and domain
name system (DNS) rebinding [18], that attackers can exploit
to steal sensitive information or to make proﬁts. Despite the
best efforts of researchers to reduce such security and privacy
problems, unrevealed security threats probably still remain
in web applications and web browsers due to undiscovered

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23027

software vulnerabilities and problematic speciﬁcations. Con-
sequently, researchers should detect and remove new vulnera-
bilities before attackers recognize and widely abuse them.

In this paper, we demonstrate a new web privacy attack that
exploits security ﬂaws of an HTML5 functionality, Application
Cache (AppCache) [14]. AppCache allows web applications
to cache resources in the local storage of a web browser to
enable ofﬂine access to them. However, we discover security
problems, side channels, of AppCache due to its cross-origin
resource caching. By exploiting the security problems, a web
attacker [2], who serves a malicious web application, can
exploit a victim web browser to correctly identify the status
of a target URL, such as whether the URL exists, whether the
URL redirects the browser to another web page, or whether
the URL returns an error code to the browser, without using
error-prone timing information [9]. We name the attack a URL
status identiﬁcation attack.

We further describe advanced attacks that leverage the URL
status identiﬁcation attack. First, we can determine the login
status of a victim web browser. Many web applications have
web pages that (1) redirect a browser to a login page if the
browser has no login information or (2) return an error code to
a browser if the browser has erroneous login information [5],
[6], [23]. By using such web pages, an attacker can identify
which web sites a victim frequently visits and which web
pages a victim is authorized to access. When an attacker can
determine whether a victim is allowed to access web sites
or web pages for speciﬁc companies, universities, regions, or
groups, the attacker can de-anonymize the victim [34] and
perform context-aware phishing [20].

Second, we can probe internal web servers located in the
local network of a victim web browser. By using the URL
status identiﬁcation attack, an attacker can probe any URL
including an internal URL. Probing internal URLs allows an at-
tacker to probe networked devices (or things) in a victim’s local
network, such as routers, network printers, network-attached
storage (NAS), smart TVs, and smart thermostats [10], [11],
[24], [26]. Thus, the attacker can ﬁngerprint the victim and
can conduct succeeding attacks (e.g., DNS rebinding [18] and
router reconﬁguration [30]). The danger of internal web server
probing will increase as the Internet of Things (IoT) becomes
popular.

Our attack has three distinguishable features. First of all,
our attack can obtain sensitive information without using
client-side scripts nor plug-ins. Rather, it only uses an HTML
document that declares an AppCache manifest which speciﬁes

TABLE I.

TARGET WEB BROWSERS.

Browser
Chrome
Firefox
Internet Explorer
Opera
Safari

Version
34
29
11
21
7

a target URL. Conventional security tools (e.g., NoScript [28])
usually disable or limit execution of suspicious client-side
scripts and plug-ins, because most web attacks exploit client-
side malicious scripts. However, such tools cannot protect user
privacy from our attack because it leverages neither client-side
scripts nor plug-ins. Some researchers have already considered
scriptless attacks [12], [17], [27], but all of them rely on
cascading style sheets (CSS) unlike our attack.

Second, our attack can concurrently identify the status of
multiple target URLs. Attackers aim to develop a fast attack
because they cannot guarantee that a victim spends a long time
in their attack pages, so they have to obtain the victim’s secrets
as quickly as possible and as much as possible. However,
conventional timing-based web privacy attacks [5], [9]–[11],
[19], [21], [23], [24], [26], [27] cannot simultaneously infer the
status of multiple URLs because concurrent network requests
lead to timing errors. In contrast, our attack can identify the
status of a target URL without
thereby inspecting
timing,
multiple URLs concurrently (Section IV).

Third, our attack can correctly recognize whether a URL
redirection occurs when a victim web browser visits a target
URL, namely, it violates the requirement of atomic HTTP
redirect handling [31]. To infer the status of a target URL,
conventional attacks [5], [6], [10], [11], [24], [26] load the
target URL via some tags (e.g., img, script, and link)
and check when or whether onload or onerror events
occur. Such tags transparently follow URL redirections for
the atomic HTTP redirect handling, so that attackers cannot
accurately recognize whether redirections occur. Therefore,
identifying whether a URL redirection occurs and determining
a login status according to a conditional URL redirection
(Section V-A) are only exact with our attack.

We launched our attack on the recent versions of ﬁve major
web browsers at the time of writing this paper, and conﬁrmed
that all web browsers which strictly followed the AppCache
standard were vulnerable to our attack (Table I). One exception
was Safari because it did not properly follow the up-to-date
standard (Section III-D1). We reported our ﬁndings to Mozilla
and Google, and they agreed that our attack could breach user
privacy.

Our work makes the following contributions:
•

Novel attack. To the best of our knowledge, this is the
ﬁrst in-depth study of AppCache security problems.
All major web browsers that correctly implement Ap-
pCache suffer from the discovered problems. Although
other researchers have considered AppCache poison-
ing [25] and AppCache-based DNS rebinding [22],
they exploit not the security problem of AppCache
but the security problem of DNS and networks. Thus,
their studies differ from ours.
Strong attack. Our attack can be performed without

•

client-side scripts nor plug-ins, can simultaneously
identify the status of multiple URLs, and can correctly
identify the redirection of a target URL. These features
make our attack difﬁcult to defend, extend its attack
coverage, and increase its performance, respectively.
Effective countermeasure. We propose a counter-
measure to mitigate our attack: a Cache-Origin
request-header ﬁeld. The countermeasure is essential
to mitigate all of the security attacks that this work
explores.

•

The remainder of this paper is organized as follows. Sec-
tion II explains conventional cross-origin web privacy attacks.
Section III introduces the HTML5 AppCache. Section IV de-
scribes a URL status identiﬁcation attack based on AppCache.
Section V demonstrates advanced attacks to determine a login
status and probe internal web servers by using the URL status
identiﬁcation attack. Section VI discusses countermeasures
against our attacks. Section VII presents related work. Lastly,
Section VIII concludes this work. In addition, we describe an
AppCache-based URL timing attack in Appendix.

II. CROSS-ORIGIN WEB PRIVACY ATTACKS

In this section, we brieﬂy explain conventional cross-origin
web privacy attacks. We mainly focus on attacks that rely
inevitable. We
on timing channels that are unreliable but
introduce attack examples to infer browsing history,
login
status, and internal web servers.

A. Attack Model

The model of the cross-origin web privacy attack resembles
that of CSRF attacks [4]. In the cross-origin web privacy
attack, an attacker aims to obtain sensitive information of
a victim web browser relevant to a target web application
by convincing the victim web browser to visit an attacker’s
web site, which serves slightly malicious web pages. The
malicious web pages contain no exploit codes to take control
of the victim web browser or to inject malicious scripts into
the target web application. Instead, the web pages contain
legitimate HTML codes and scripts to include cross-origin
content while measuring fetch latency to obtain side-channel
information, such as the browsing history and login status of
the victim web browser. Therefore, it is difﬁcult to determine
the maliciousness of the web site.

B. Cross-origin Content Inclusion

HTML has various methods of including cross-origin con-

tent. We brieﬂy explain and compare them.

1) Speciﬁc content inclusion: HTML provides tags (e.g.,
img, script, and link) to embed speciﬁc types of same-
or cross-origin content in a web page, such as images, scripts,
and CSSs. The tags successfully include a URL that indicates
a valid resource with a matched content type. But, the tags fail
to include a URL when the URL is invalid (e.g., connection
failure, non-existent resource, and unauthorized access) or the
URL indicates a resource with an unmatched content type.
Finally, web browsers call either the onload or onerror
event handlers according to successful or unsuccessful content
inclusion via the tags.

2

Although the main purpose of the explained tags is to
include content with speciﬁc types, attackers can abuse the
tags to obtain side-channel information by including arbitrary
content and checking an error status while measuring latency.
Web browsers cannot determine the content type of a URL
until they receive an actual resource, so they send a normal
GET request to a web application to fetch the resource. When
the content type of the received resource differs from the tag
type, the web browsers abort the content inclusion and ﬁre an
error event. However, attackers can infer the status of a URL
from its fetch latency because the latency varies for various
reasons, such as whether the browsers have previously visited
the URL, whether the browsers are logged in, and whether the
URL exists. Attackers can thereby guess sensitive information
by using information implied by the varied fetch latency.

2) Arbitrary content inclusion: HTML provides tags (e.g.,
frame, iframe, object, and embed) to embed arbitrary
content in a web page. The main purpose of the frame and
iframe tags is to embed other HTML documents, and the
main purpose of the object and embed tags is to embed
multimedia, such as audio, video, and PDF ﬁles. The tags only
support the onload event handler, so that attackers should
guess the status of a URL by measuring how much time a
web browser spends before ﬁring an onload event.

However, the preceding tags are unsuitable for performing
web privacy attacks due to two shortcomings. First, the fetch
latency is unpredictable because the tags try to receive all
resources (e.g., images, scripts, and CSSs) that compose a
web page before rendering the resources. This procedure
adds a high amount of noise to the time measurement [5].
Second, to avoid security problems (e.g., clickjacking [16]
on login pages), many modern web applications do not al-
low web browsers to load their web pages in such tags.
The web applications use an HTTP response-header ﬁeld
X-Frame-Options or a frame busting code [29] to prevent
such content inclusion. Therefore, the HTML tags for arbitrary
content inclusion are unsuitable for performing web privacy
attacks.

C. Inferring Login Status

We explain a timing attack that uses variance in fetch
latency to infer the login status of a victim web browser [5]. An
attacker can reveal the real identity of a victim web browser’s
user according to which web sites the user is frequently logged
in. When a web browser accesses the front pages of web
applications, many of them provide different web pages to the
browser according to the login status. They usually redirect
a logged-in browser to a personalized web page,
thereby
introducing additional network delay. Malicious web pages
leverage this delay to infer login status by manipulating a web
browser to visit the front page of a target web application
while measuring the latency. High latency implies that the web
browser is logged in to the target web application.

A countermeasure to this attack is to make web applica-
tions spend constant time to process HTTP requests [5]. But,
guaranteeing constant processing time is not only difﬁcult but
also incurs much overhead.

The CSS-ﬁlter-based attack [23] can identify login sta-
tus by exploiting the difference in ﬁltering latency between

logged-in and non-logged-in web pages. However, two short-
comings make this attack less practical than others. First, it
takes much time to measure the latency of CSS ﬁltering.
Second, target web applications should allow the iframe
tag, but recent and security-aware web applications usually
disallow such a tag (Section II-B2).

D. Inferring Internal Web Server

We depict a timing attack to identify internal web servers
located in the local network of a victim web browser [10], [11],
[24], [26]. The basic idea of this attack is using HTML tags
(e.g., the img and script tags) to include arbitrary URLs
of internal web servers while waiting for onerror events.
Attackers can guess the servers’ status from the elapsed time.
Knowing internal web servers is an important privacy
breach because it can reveal what kinds of routers, network
printers, and NAS a victim uses. An attacker can use such
information to ﬁngerprint a victim web browser. Furthermore,
this knowledge becomes the basis of other security attacks,
such as DNS rebinding [18] and router reconﬁguration [30].
Usually, a ﬁrewall protects internal hosts from outsiders such
that attackers attempt to make a victim web browser execute
scripts to investigate servers in the internal network of the
victim web browser.

To prevent

this attack, a web browser should prevent
external scripts from accessing its internal network. We also
require DNS pinning and host name authorization to prevent
DNS rebinding attacks [18].

E. Limitations of Conventional Attacks

Conventional cross-origin web privacy attacks have some
limitations. First, their accuracy is relatively low due to un-
reliable page fetch latency affected by a number of error
sources, such as network condition, web server loads, and
client loads. Attackers can reduce the noise by averaging data
from a number of timing samples, but this process requires an
unreasonable amount of time to collect a sufﬁcient number of
samples. Furthermore, sampling becomes meaningless when a
victim web browser visits web pages via wireless networks or
Tor [7] due to their high and unstable network latency.

Second, the conventional attacks are inefﬁcient because
they cannot measure the fetch latency of multiple URLs in
parallel. If attackers open more than one connection with target
web applications, interference between multiple connections
causes timing errors. Accordingly, attackers should probe
URLs one by one.

III. HTML5 APPCACHE

In this section, we explain the HTML5 AppCache in detail.
We especially focus on when AppCache fails and how App-
Cache handles failures, because they are the most important
basis of our attacks presented in a later section.

A. Declaration

We depict how a web application announces that it uses
AppCache, and how the web application speciﬁes which
resources web browsers should store in their local storage.

3

1 <!DOCTYPE HTML>
2 <html manifest="example.appcache">
3 ...
4 </html>

Listing 1. HTML document that declares an AppCache manifest.

1 CACHE MANIFEST
2
3 CACHE:
4 /logo.png
5 https://example.cdn.com/external.jpg
6
7 NETWORK:
8 *
9
10 FALLBACK:
11 / /offline.html

Listing 2. AppCache manifest ﬁle.

First, the web application declares the path of an AppCache
manifest ﬁle (example.appcache) that corresponds to an
HTML document
in its html tag (Listing 1). The mani-
fest ﬁle and the HTML document must belong to the same
origin, and the content type of the manifest ﬁle should be
text/cache-manifest.

Next, through the manifest ﬁle, the web application spec-
iﬁes URLs that web browsers should cache (Listing 2). A
manifest ﬁle starts with CACHE MANIFEST and has three
sections: CACHE, NETWORK, and FALLBACK. (1) The CACHE
section declares URLs that need to be stored in local storage.
Each scheme of the declared URLs should be the same as
the main HTML document’s scheme. For example, when the
main HTML document’s scheme is HTTP, AppCache ignores
HTTPS URLs listed in the CACHE section. When the scheme
is HTTPS, AppCache ignores HTTP URLs listed in the CACHE
section. (2) The NETWORK section declares whitelisted URLs
that web browsers can download from outside. Web browsers
treat URLs listed in neither CACHE nor NETWORK sections
as unreachable. We can use an asterisk to allow arbitrary
URLs. (3) The FALLBACK section declares alternative URLs
to use when original URLs are inaccessible. The ﬁrst URL
is the original resource, and the second URL is the fallback
to substitute for the ﬁrst one. The FALLBACK section only
allows relative URLs because replacing a URL with another
URL that belongs to a different origin can violate SOP.

B. Download and Update Procedures

We illustrate the two procedures of AppCache: download
and update procedures. The ﬁrst time a web browser visits a
web page that declares an AppCache manifest, the browser
performs the download procedure. Otherwise, it performs the
update procedure.

1) Downloading non-cached web page: We ﬁrst describe
the AppCache download procedure for a newly-visited web
page and the corresponding events that are ﬁred during the
procedure. A web browser initiates the following download
procedure when it visits a web page that declares an AppCache
manifest for caching speciﬁc resources.

4

1)

2)

3)

4)

The browser attempts to fetch and parse the manifest
while ﬁring a checking event to an AppCache
object. If the manifest either has errors or is non-
existent, the browser terminates the download proce-
dure and ﬁres an error event.
The browser starts to download resources listed in the
manifest while ﬁring a downloading event.
The browser downloads each of the resources while
ﬁring a progress event for each resource. If the
browser cannot cache at least one of the resources
(Section III-C) or recognizes the changes in the mani-
fest while downloading the resources, the browser ter-
minates the download procedure and ﬁres an error
event.
The browser stores the downloaded resources in its
local storage and ﬁres a cached event.

2) Updating cached web page: Next, we describe the
AppCache update procedure for a cached web page and cor-
responding events ﬁred during the procedure. A web browser
initiates the following procedure to update corresponding re-
sources when it visits a web page that has already been cached
in its local storage.

1)

2)

3)

4)

The browser attempts to fetch and interpret the mani-
fest originating from the remote server while ﬁring a
checking event. First, if the content of the manifest
does not change, the browser terminates the update
procedure and ﬁres a noupdate event. Next, if the
manifest either has errors or is unreachable due to
network failures, the browser terminates the update
procedure and ﬁres an error event. Lastly, if the
manifest no longer exists in the remote server, the
browser terminates the update procedure, deletes the
cached resources, and ﬁres an obsolete event.
The browser starts to download resources listed in the
manifest while ﬁring a downloading event.
The browser re-downloads each of the resources
while ﬁring a progress event for each resource. If
the browser cannot cache at least one of the resources
or if the manifest changes during re-downloading, it
terminates the update procedure and ﬁres an error
event.
The browser stores the re-downloaded resources in
its local storage and ﬁres an updateready event.

3) Error handling: To avoid partial resource replacement
to preserve content consistency, AppCache reverts completely
to its previous status when it encounters errors during the
download or update procedures. AppCache discards all new
resources that were successfully downloaded during the failed
download or update procedures.

4) Web page refreshing: Occasionally, an AppCache proce-
dure ﬁnishes after a web page has been loaded because a web
browser performs the procedure in the background. Therefore,
the web browser needs to refresh the web page to reﬂect the
most recent version.

C. Non-cacheable URLs

We state the types of URLs that AppCache does not
cache and returns errors. Using such information allows us

to identify the status of a target URL, which will be explained
in Section IV. AppCache does not cache URLs that satisfy any
one of the following three conditions.

•

•

•

Invalid URL. AppCache does not cache this kind of
URL because the URL returns no content for caching.
If a web application returns client or server error codes
or does not respond when AppCache accesses a URL
of the web application, AppCache treats the URL as
invalid.
Dynamic URL. AppCache does not cache this
kind of URL because ofﬂine access to dynamic
content
is almost meaningless. Web applications
use HTTP response-header ﬁelds (Cache-Control
or Content-Length)
to specify their dynamic
content. AppCache does not cache content when
the response header contains a no-store direc-
tive in a Cache-Control ﬁeld [14] or has no
Content-Length ﬁeld (i.e., chunked encoding).
URL with redirections. AppCache does not cache
this kind of URL to avoid a security problem. Since
web browsers refer to the cached content with a URL
that is speciﬁed in a manifest ﬁle, allowing redirec-
tions can violate SOP. For example, some wireless
access points (APs) use a captive portal technique
that redirects web browsers to a special web page for
authentication or payment. If AppCache allows this
redirection, the stored content differs from the content
that a web application intends to cache, but has the
same URL. When the stored content embeds malicious
scripts, this problem becomes serious because SOP
is no longer guaranteed. Furthermore, malicious web
applications can abuse redirections to cache the con-
tent of target web pages under their origin to execute
their malicious scripts on the target web pages. Thus,
to enforce SOP, AppCache does not resolve URL
redirections.

Although AppCache restricts standard URL redirections
that use 3xx status codes, it ignores non-standard redirection
methods (e.g., the meta refresh tag and the JavaScript
object window.location). When AppCache encounters a
web page that uses such a non-standard redirection method,
AppCache does not follow a redirection, but caches the web
page “as is”.

D. Browser Differences

We analyze differences in AppCache implementations of
different web browsers. Due to the differences, some web
browsers are more vulnerable to our attack than others, and
some other web browsers are robust against our attack ex-
plained in Section IV.

1) Secured resources: Safari does not cache cross-origin
HTTPS URLs in a manifest ﬁle, so that we cannot attack cross-
origin HTTPS URLs when a victim uses Safari. The previous
version of the AppCache standard [13] speciﬁed that a web
browser should only cache URLs from the same origin as a
manifest when the manifest’s scheme is HTTPS. Therefore,
in the past, web application developers were not able to use
AppCache to cache cross-origin HTTPS URLs. This is bad

1 <?php
2 header("Content-Type: text/cache-manifest");
3
4 $target = "https://target.net"; //dynamically

assigned

5 echo "CACHE MANIFEST\n";
6 echo "CACHE:\n";
7 echo "$target\n\n";
8 echo "NETWORK:\n";
9 echo "*\n";
10 ?>

Listing 3.
identiﬁcation attack.

PHP-based AppCache manifest

to perform a URL status

for secured web applications that want to cache resources
provided by secured content delivery networks (CDNs). The
recent standard [14] relaxes this restriction: when a manifest’s
scheme is HTTPS, a web browser can cache any HTTPS URLs
but no HTTP URLs. An exception is Safari because it does
not use the recent standard changes at the time of writing this
paper.

2) no-store directive: Chrome, Opera, and Safari ignore
the no-store directive of a HTTP resource, so that we can
attack no-store HTTP resources when a victim uses one
of the web browsers. The AppCache standard [14] speciﬁes
that a web browser should not cache any resources with a
no-store directive. But, we observe that Chrome, Opera,
and Safari ignore a no-store directive when they cache
HTTP resources via AppCache.

3) Referrer information: Chrome, Opera, and Safari send
no referrer information during an AppCache process, so that
a stealthy attack is possible. The AppCache standard [14]
does not specify whether a web browser should send refer-
rer information during an AppCache process. Accordingly,
browser vendors choose different policies: Firefox and Internet
Explorer record the URL of an HTML document that declares
an AppCache manifest in a Referrer request-header ﬁeld
whereas Chrome, Opera, and Safari specify no referrer infor-
mation in an HTTP request. The lack of referrer information
implies that target web applications cannot recognize who
forces a victim web browser to investigate themselves.

IV. URL STATUS IDENTIFICATION ATTACK

In this section, we illustrate an AppCache-based URL sta-
tus identiﬁcation attack that does not rely on timing. This attack
is possible due to a standard behavior of AppCache: to avoid
content inconsistency and security problems, AppCache should
fail when any URL listed in a manifest is non-cacheable.
By using this attack, an attacker can correctly determine the
status of target URLs because this attack does not rely on
unreliable timing information. We demonstrate both script-
based and scriptless attacks.

A. Attack Manifest

An AppCache manifest written in PHP (example in List-
ing 3) can be used to perform a URL status identiﬁca-
tion attack. The example only speciﬁes a single target URL
(https://target.net) that attackers want to identify.

5

server probing mainly depended on whether target URLs
were unreachable. Table II shows measured AppCache timeout
values of a single unreachable URL that consisted of a literal IP
address, instead of a domain name, belonging to our campus,
with various platforms. OS X had the greatest timeout value
and Ubuntu had the smallest timeout value. Chrome, Firefox,
and Opera had almost the same timeout values in the same
platforms, but Internet Explorer had a different timeout value.
Fig. 6 shows the execution time of concurrent internal web
server probing using Chrome. The number of targets URLs
was 50, consisting of 0 to 50 unreachable URLs and 50 to
0 reachable URLs. All URLs belonged to our campus. The
timeout value of OS X was greater than those of Ubuntu and
Windows, so that the execution time of internal web server
probing was longest when a victim web browser’s platform
was OS X. We also identiﬁed that the number of unreachable
URLs did not affect the overall execution time because Chrome
concurrently opened multiple sockets for AppCache.

Unlike other web browsers, Firefox was secure against the
internal web server probing due to its sequential AppCache
handling. For example,
took 7648 s and 2100 s when
we performed URL identiﬁcation attacks on 100 unreachable
URLs by using Firefox in OS X and Windows, respectively.
Since most victim users will not spend such a long time in an
attack web page, we conclude that Firefox is secure against
our attack when its platform is OS X or Windows.

it

VI. COUNTERMEASURES

In this section, we present our countermeasures to mitigate
the proposed attacks. We ﬁrst depict some na¨ıve countermea-
sures with shortcomings and suggest our solution.

A. Problematic Countermeasures

We present some countermeasures that partially prevent our
attacks or that prevent our attacks but lead to other problems.
First, we can revise AppCache to ask user permissions to allow
web applications to cache resources as Firefox does. This
countermeasure prevents our attacks only if a user correctly
judges whether a web application is malicious.

Second, we can revise AppCache to not check the changes
in a manifest during download or update procedures as Safari
does. This countermeasure, however, results in an AppCache
inconsistency problem. Further, it cannot prevent a URL status
identiﬁcation attack if an attacker refreshes an attack page to
re-conﬁrm an AppCache procedure.

Third, we can revise AppCache to check the manifest even
when some resources are non-cacheable. This countermeasure
prevents a scriptless URL status identiﬁcation attack only when
an attacker does not refresh an attack page.

Fourth, we can attach a no-store directive to HTTP re-
sponses from web applications. This countermeasure prevents
all our attacks, but makes AppCache meaningless because web
browsers no longer cache resources.

Lastly, we can modify vulnerable web pages that condition-
ally redirect web browsers to login pages or that return error
codes according to a login status. For example, we can use a
login pop-up window instead of redirections and a custom error

page with 200 OK instead of an error code. This countermea-
sure prevents a URL status identiﬁcation attack, but ﬁnding and
modifying all vulnerable web pages are sophisticated tasks.

B. Restricting Cross-origin AppCache

We aim to restrict arbitrary cross-origin AppCache to pro-
tect browser and URL status from the URL status identiﬁcation
attack. One possible solution is to apply the Origin request-
header ﬁeld of cross-origin resource sharing (CORS) [32]
to AppCache procedures, although this approach can violate
the principle of least privilege. The Origin header ﬁeld
allows a web application to identify which web applications
initiate cross-origin requests so that the web application can
deny requests from unknown or blacklisted web applications.
However, the Origin header ﬁeld further asks a permission
to allow client-side scripts to access the requested resource,
which is unnecessary for AppCache. Therefore, we require
another method that only asks a web application whether it
allows resource caching.

the origin of an AppCache manifest;

We suggest a new HTTP request-header ﬁeld that con-
tains
this ﬁeld,
Cache-Origin, resembles the Origin header ﬁeld of
CORS. The Cache-Origin header ﬁeld only asks web
applications whether they permit caching of their resources,
unlike the Origin header ﬁeld which requests access per-
missions to their resources. A web browser must attach the
Cache-Origin header ﬁeld to its HTTP requests during
AppCache procedures.

By using the Cache-Origin header ﬁeld, a web appli-
cation can identify other web applications that request to cache
its resources. When the web application doubts the requesters
or caching the requested resources can reveal sensitive infor-
mation (e.g., access-controlled resources), the web application
either assigns a no-store directive to its response header
or returns an error code to abort an AppCache procedure.
Attackers can no longer identify browser and URL status
because their AppCache procedures always fail. Even if some
attackers bypass the Cache-Origin check,
they cannot
identify a browser status when the target web application
disallows web browsers to cache sensitive resources.

We modiﬁed a build of Chromium (35.0.1856.0) to in-
troduce a Cache-Origin request-header ﬁeld during Ap-
pCache procedures (Listings 6). Adding three lines of code
was enough to enable this countermeasure with negligible
performance overhead.

The Cache-Origin request-header ﬁeld is a minor re-
vision of the Origin request-header ﬁeld, so we believe that
adopting Cache-Origin is not a big deal of the web stan-
dard. Otherwise, using Origin during AppCache procedures
is at least desired to prevent our attack.

VII. RELATED WORK

In this section, we introduce two AppCache attacks that
manipulate DNS information: AppCache poisoning [25] and
AppCache-based DNS rebinding [22]. AppCache poisoning
attempts to store fake login pages in AppCache to steal login
credentials. When a victim web browser visits some web pages
via an attacker’s network (e.g., a rogue AP),
the attacker

9

1 /* src/webkit/browser/appcache/

appcache_update_job.cc */

2 void AppCacheUpdateJob::URLFetcher::Start() {
3

request_->set_first_party_for_cookies(job_

->manifest_url_);

request_->SetLoadFlags(request_->load_flags

() | net::LOAD_DISABLE_INTERCEPT);
if (existing_response_headers_.get())

AddConditionalHeaders(

existing_response_headers_.get());

/* Set a Cache-Origin header field */
net::HttpRequestHeaders headers;
headers.SetHeader("Cache-Origin", job_->

manifest_url_.GetOrigin().spec());

request_->SetExtraRequestHeaders(headers);

request_->Start();

4

5
6

7
8
9
10

11
12
13
14 }

Listing 6. Modiﬁed Chromium code to attach a Cache-Origin request-header
ﬁeld during AppCache procedures.

injects hidden iframe tags that point to target login pages
in responses. The victim web browser then sends requests
to the target login pages. The attacker intercepts the requests
and responds with fake login pages that look the same as the
original login pages while declaring an AppCache manifest and
including backdoors. Later, even when the victim web browser
visits the target login pages via a secured network, it will load
the fake login pages from AppCache. To mitigate this attack,
we need to use private browsing modes [1] in an insecure
network, and use HTTP strict transport security (HSTS) [15]
or HTTPS Everywhere [8] to secure login pages.

AppCache-based DNS rebinding is a modiﬁcation of the
original DNS rebinding attack [18], which attempts to violate
SOP by changing domain-to-IP mapping with a short-lived
DNS entry. In the original form, when a victim web browser
visits an attacker’s web site, the attacker delivers some ma-
licious scripts to the victim web browser while associating
the domain name of the web site with a target IP address.
Subsequently, the malicious scripts can send arbitrary same-
origin requests to the target IP address because they have
the same domain name. To mitigate this attack, modern web
browsers maintain domain-to-IP mapping for a while (DNS
pinning). However, the two characteristics of AppCache allow
attackers to write a malicious script executed after domain-to-
IP mapping changes [22]: (1) allowing web sites to persistently
cache arbitrary resources in web browsers and (2) supporting
a JavaScript API to recognize whether a script comes from
a local cache or a server. To eradicate the attack, Johns et
al. [22] suggest an X-Server-Origin response-header ﬁeld
that lists server-provided origin information.

VIII. CONCLUSION

This paper introduced a new web privacy attack that
indirectly identiﬁed the status of cross-origin URLs by using
HTML5 AppCache without client-side scripts nor plug-ins. We
conﬁrmed that all major web browsers which supported Ap-
pCache were vulnerable to our attacks. We also suggested an
effective countermeasure: a Cache-Origin request-header
ﬁeld. The countermeasure successfully mitigated our attacks.

ACKNOWLEDGMENT

We would like to thank the anonymous reviewers for
their invaluable comments and suggestions. This work was
supported by ICT R&D program of MSIP/IITP. [14-824-09-
013, Resilient Cyber-Physical Systems Research]

REFERENCES

[1] G. Aggarwal, E. Bursztein, C. Jackson, and D. Boneh, “An analysis
of private browsing modes in modern browsers,” in USENIX Security
Symposium, 2010.

[2] D. Akhawe, A. Barth, P. E. Lam, J. Mitchell, and D. Song, “Towards a
formal foundation of web security,” in Computer Security Foundations
Symposium (CSF), 2010.

addresses,”

[3] AnswersThatWork, “List of default router passwords and default router
http://www.answersthatwork.com/Download Area/

IP
ATW Library/Networking/Network 4-Admin List of default
Router Passwords and IP addresses Netgear D-Link Belkin
Linksys Others.pdf, 2013.

[4] A. Barth, C. Jackson, and J. C. Mitchell, “Robust defenses for cross-site
request forgery,” in ACM Conference on Computer and Communications
Security (CCS), 2008.

[5] A. Bortz, D. Boneh, and P. Nandy, “Exposing private information by
timing web applications,” in International World Wide Web Conference
(WWW), 2007.
[6] K. Brewster,

“Patching privacy leaks,” http://kentbrewster.com/

patching-privacy-leaks/, 2008.

[7] R. Dingledine, N. Mathewson, and P. Syverson, “Tor: The second-

generation onion router,” in USENIX Security Symposium, 2004.

[8] Eletronic Frontier Foundation, “HTTPS Everywhere,” https://www.eff.

org/https-everywhere.

[9] E. W. Felten and M. A. Schneider, “Timing attacks on web privacy,” in
ACM Conference on Computer and Communications Security (CCS),
2000.

[10] N. Garcia, “Javascript port scanner,” http://jsscan.sourceforge.net/.
[11]

J. Grossman and T. Niedzialkowski, “Hacking intranet websites from
the outside: JavaScript malware just got a lot more dangerous,” in
Blackhat USA, 2006.

[12] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and J. Schwenk,
“Scriptless attacks – stealing the pie without touching the sill,” in ACM
Conference on Computer and Communications Security (CCS), 2012.
I. Hickson, “5.6 ofﬂine web applications – HTML5,” http://www.w3.
org/TR/2011/WD-html5-20110525/ofﬂine.html, 2011.

[13]

[14] ——, “6.7 ofﬂine web applications – HTML standard,” http://www.
whatwg.org/specs/web-apps/current-work/multipage/ofﬂine.html, 2013.
J. Hodges, C. Jackson, and A. Barth, “HTTP strict transport security
(HSTS),” Internet Requests for Comments, RFC 6797, 2012. [Online].
Available: http://www.rfc-editor.org/rfc/rfc6797.txt

[15]

[16] L.-S. Huang, A. Moshchuk, H. J. Wang, S. Schechter, and C. Jackson,
“Clickjacking: Attacks and defenses,” in USENIX Security Symposium,
2012.

[17] L.-S. Huang, Z. Weinberg, C. Evans, and C. Jackson, “Protecting
browsers from cross-origin CSS attacks,” in ACM Conference on
Computer and Communications Security (CCS), 2010.

[18] C. Jackson, A. Barth, A. Bortz, W. Shao, and D. Boneh, “Protecting
browsers from DNS rebinding attacks,” in ACM Conference on Com-
puter and Communications Security (CCS), 2007.

[19] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell, “Protecting browser
state from web privacy attacks,” in International World Wide Web
Conference (WWW), 2006.

[20] M. Jakobsson and S. Stamm, “Invasive browser snifﬁng and counter-
measures,” in International World Wide Web Conference (WWW), 2006.
[21] Y. Jia, X. Dong, Z. Liang, and P. Saxena, “I know where you’ve been:
Geo-inference attacks via the browser cache,” in Web 2.0 Security &
Privacy (W2SP), 2014.

[22] M. Johns, S. Lekies, and B. Stock, “Eradicating DNS rebinding with the
extended same-origin policy,” in USENIX Security Symposium, 2013.

10

