Towards a Publicly-Veriﬁable Mix-Net Providing

Everlasting Privacy

Johannes Buchmann1 and Denise Demirel1 and Jeroen van de Graaf2

1 Department of Computer Science, Cryptography and Computer Algebra Group,

Technische Universit¨at Darmstadt, Darmstadt, Germany.

2 Departamento de Ciˆencia da Computa¸c˜ao, Universidade Federal de Minas Gerais,

CEP 31270-901, Brazil.

Abstract. All implementations of veriﬁable mix-nets provide computa-
tional privacy only, because the audit information published is encrypted
using some public key algorithm. Consequently, at some time in the fu-
ture, when the underlying cryptographic assumption is broken, privacy
is violated, and each output message can be traced back to its input.
We address this problem by presenting a mix-net that uses a homomor-
phic, unconditionally hiding commitment scheme to encrypt the audit
information, implying unconditional or everlasting privacy towards the
public. The correctness of our mix-net is guaranteed with overwhelming
probability even if all authorities conspire, under the assumption that the
commitment scheme is computationally binding until the mixing process
has ended. An implication of our result is that many current applications
that use mix-nets can be upgraded to unconditional privacy.

1

Introduction

1.1 Motivation

Mix-nets were introduced by David Chaum in 1981 [2] to allow anonymous
communication within a network. Its basic functionality is to process a set of
input messages, so that the content remains unchanged while any link between
a single input and its associated output is removed. The reencryption mix-net
introduced in 1993 by Park et al. [10] is based on this technique and allows that
its correctness can be veriﬁed by any third party, i.e. showing that each message
that comes in, goes out. Universally veriﬁable mix-nets are of interest for several
applications where privacy plays an important role. Examples of real use are
electronic auctions [6], electronic exam systems [7], and electronic voting [1, 12].
In all solutions for universal veriﬁable mix-nets that we know of, the audit
information is encrypted using some public key algorithm, which is assumed to
be computationally hard. However, when the underlying cryptographic assump-
tion is broken (perhaps decades later) all the audit information can be decrypted
and privacy is violated: each output message published can be traced back to
its input. With current trends in technology, like quantum computers, such a
scenario is realistic. With the cost for storing information becoming less, the

fact that (encrypted) information has been published on the internet makes it
virtually impossible to remove this data later on. In addition, processing power
increases continually following Moore’s law. So all an attacker needs to do is
to download the audit information published, wait until the cryptographic as-
sumption is broken, and decrypt it. In other words, the privacy oﬀered by current
implementations of mix-nets has an (often unknown) expiration date.

1.2 High-level Description of our Result

In this paper we show how to use a homomorphic, unconditionally hiding com-
mitment scheme to encode the audit information, i.e. the encoded messages and
the proofs published for correct mixing. The system commits to a submitted mes-
sage t with a (randomly chosen) decommitment value s. Like with homomorphic
encryption, each mix can recode (or rerandomize) a commitment u = Com(t, s)
by multiplying it with Com(0, s(cid:48)), that is, u(cid:48) = Com(t, s + s(cid:48)). Further, due to
the homomorphic property of the commitment scheme the correctness of the
rerandomization can be shown by proving knowledge of the used permutation
and rerandomization value. However, in order to open shuﬄed commitments,
one needs to know the decommitment values. Our solution is to send this data
together with message t as auxiliary information through a private mix-net
to which the public has no access. Any rerandomization u(cid:48) = Com(0, s(cid:48))u has
matching rerandomizations (cid:104)v(cid:48), w(cid:48)(cid:105) = (cid:104)Enc(0)v, Enc(s(cid:48))w(cid:105), where v = Enc(t) and
w = Enc(s) and Enc is a suitable homomorphic encryption scheme. So essentially
we use two tightly synchronized mix-nets run by the same mixes: one which is
mixing commitments and which is fully public. And a second mix-net which
uses homomorphic encryption to which the public has no access. Then, after the
last mix Mn has published its data, vn and wn are jointly decrypted yielding
s∗ = s0 + ··· + sn and t, the opening values of un = Com(t, s0 + ··· + sn).

The scheme sketched in the above paragraphs already provides everlasting
privacy towards observers. But it has one drawback: the ﬁrst mix, to whom
the users submit their message, gets to see Enc(t). So when, in some future,
the encryption scheme gets broken, this mix, if dishonest, could reconstruct the
user’s message. If this is considered a problem, an obvious solution is to split the
input in two (or more) parts, submit each part to a separate mix-net, and have
the parts recombined, decoded, and published by a special publication authority.

1.3 Related Work

Despite the vast literature on mix-nets, we are not aware of any publication that
accomplishes everlasting privacy for mixing. The protocol that comes closest to
what we propose here is the shuﬄing used in the Split-Ballot voting system [9].
However, this protocol is devised for a very particular situation: two voting au-
thorities who want to shuﬄe ballot shares of a speciﬁc format, allowing them to
jointly compute the tally. It is not at all obvious how to utilize this shuﬄe proto-
col in other voting protocols, nor how to obtain a general, unconditional mix-net
for mixing messages of arbitrary format. Another way to illustrate the diﬀerence

is as follows: in Split-Ballot, the voter shares a secret with two authorities “in
parallel”, whereas in conventional mixing a message is processed sequentially.

In [4] similar ideas presented here are directly applied on the Helios voting
system. In independent work parallel to ours, Pereira et al. [11] approach the
ideas of [4] and this paper from a diﬀerent angle. The commitment scheme with
matching encryption is presented as a new, uniﬁed primitive, and then used
to show that any voting scheme which uses homomorphic tallying can have an
unconditionally (or perfectly) private audit trail. A similar statement is made
for voting protocols that use mix-nets, but, unlike this paper, no details of the
mixing process are presented, nor does it address the issue of a mix-net providing
everlasting privacy towards both the public and the mixing authorities.

The structure of this paper is straightforward: In Section 2 we show how
the standard reencryption process can be adapted to provide everlasting privacy
towards observers and present formal statements of the properties. Section 3
describes a mixing process providing everlasting privacy also towards the au-
thorities, followed by conclusion and future work.

2 Mixing with Everlasting Privacy Towards the Public

2.1 Cryptographic Primitives

The protocol uses two cryptographic primitives. First, a commitment scheme
in order to provide everlasting privacy and universal veriﬁability towards the
public. Second, a matching encryption scheme allowing the authorities to open
the commitment at the end of the mixing process and at the same time providing
privacy towards the authorities.

A (non-interactive) commitment scheme is a triple (GenCom, Com, Unv)
such that GenCom(1κ) generates the public commitment key ck for security pa-
rameter κ. Note that the security parameter deﬁnes the message space M and
the randomization space R. We will suppose implicitly the presence of ck in the
remainder, leaving it out of the notation. c = Com(m, s) ∈ C takes as input a
message m ∈ M, a uniformly chosen decommitment value s ∈ R, resulting in
a commitment c ∈ C. The algorithm Unv(c, m, s) returns m if c = Com(m, s)
and ⊥ if not. The commitment scheme has to provide the following proper-
ties. (1) Correctness: For any m ∈ M, r ∈ R : Unv(Com(m, r), m, r) = m. (2)
Non-Interactive: All communication goes from the sender to the receiver. (3)
Computationally Binding: Given a commitment c = Com(m, r), for any PPT
A the probability to ﬁnd a second opening pair (m(cid:48), r(cid:48)) with m (cid:54)= m(cid:48) such
that Com(m, r) = Com(m(cid:48), r(cid:48)) is negligible in κ. (4) Unconditionally Hiding:
For any pair m, m(cid:48) ∈ M the distribution of the randomized values Com(m, r)
and Com(m(cid:48), r(cid:48)) must be identical when r, r(cid:48) ∈ R are chosen uniformly random.
(Obviously, this property can be weakened to statistically hiding, but for ease
of exposition we do not explore this.) (5) Homomorphic: For all m, m(cid:48) ∈ M and
r, r(cid:48) ∈ R Com(m, r) ·C Com(m(cid:48)r(cid:48)) = Com(m +M m(cid:48), r +R r(cid:48)). In the following,
we will denote the neutral element 0M of M and 0R of R as 0. Furthermore, we
will refer to the group operations +M and +R by +.

The encryption scheme (GenEnc, Enc, Dec) used is identical to the one
already used in standard reencryption mix-nets. The mixing process is based
on a homomorphic public key encryption algorithm deﬁned by the triple
(GenEnc, Enc, Dec) such that GenEnc generates two separate keys, a public key pk
and a private key sk, where the private key is presumed to be shared among a set
of key trustees T using threshold decryption. Enc(t, s) = c denotes the encryption
of message t ∈ G with randomness s ∈ H and public key pk. Dec(c) = t denotes
the decryption of ciphertext c to message t ∈ G using private key sk. Note that
the algorithm should provide semantical (CCA) security and be homomorphic
in t and in s, meaning that for all t, t(cid:48) ∈ G and for all s, s(cid:48) ∈ H : Enc(t, s) ·
Enc(t(cid:48), s(cid:48)) = Enc(t +G t(cid:48), s +H s(cid:48)), where +G and +H are operations in group
G and H. As a consequence, reencrypting a ciphertext c = Enc(t, s) without
knowing and changing message t is possible by multiplying it with an encryption
of the neutral element 0G of group G, i.e. ReEnc(c, s(cid:48)) = Enc(t, s) · Enc(0G, s(cid:48)) =
Enc(t, s + s(cid:48)). However, because both the message m ∈ M and the auxiliary
value r ∈ R have to be sent over the private channel, we need two instances of
this encryption scheme. One, denoted as EM, which must be homomorphic over
the message space M. The second one, denoted as ER, whose message space is
homomorphic over group R.

An additional ingredient for reencryption mix-nets are proofs of correct
reencryption: each mix has to provide a zero-knowledge proof that the data
has been processed correctly, such that the set of output values is a valid shuﬄe
of the set of input values. These proofs are made public, thus providing universal
veriﬁability. In addition this mix-net uses proofs of consistency: each mix has
to privately prove that the same permutation and random values have been used
to rerandomize the published commitments and to reencrypt the corresponding
private encrypted opening values. Note that both proofs have to be perfect zero-
knowledge. More precisely, if a proof published by the prover is correct, even a
computationally unbounded veriﬁer cannot learn more than that.

To show the viability we now give some instantiations of a commitment
scheme with matching encryption scheme satisfying the properties above. For
their Split-Ballot voting system, Moran and Noar proposed the use of Pail-
lier encryption in combination with a slightly modiﬁed Pedersen commitment
Scheme [9, Appendix A]. We also believe that an alternative implementation
with unconditional Jacobi symbols commitments and Rabin encryption might
work, but the scheme would be very ineﬃcient since each Jacobi symbol would
implement only one bit. More interesting is the recent suggestion of Pereira et al.
[11] for an eﬃcient unconditionally hiding commitment scheme with matching
homomorphic encryption scheme based on elliptic curves. If this could be used in
combination with a non-interactive proof (or rather, argument) [5, 8] this might
lead to a very eﬃcient mixing procedure.

2.2 Assumptions

For a standard reencryption mix-net to be secure the following assumptions are
made: (A) The authorities cannot break the underlying computational problem of

the encryption scheme. (B) At least one mix is honest and keeps the association
between its input and output values secret. (C) Using (k, n)-threshold decryption
at least (n− k + 1) “key trustees” act honestly and keep their key portion secret.
(D) All random challenge bits used in the mixing and veriﬁcation steps comes
from a trusted Random Beacon and are unpredictable.

Apart from that, we make the following additional assumptions: (E) The
authorities cannot break the computational binding property of the commitment
scheme for the parameters chosen before the messages have been published and
certiﬁed. (F) There exists a private channel between the user and the ﬁrst mix M1
of the mix-net, between each mix and its successor in the mix-net, and between
the last mix and the key trustees T . (H) After the protocol has been certiﬁed all
authorities destroy all information private to them.

2.3 Adapted Mixing Process

For legibility, we will interpret a batch of messages each from a diﬀerent user by
a vector, denoted by a capital letter. Operations on the entries of vectors carry
over to the vectors. For instance, the Perm operation permutes the entries of a
vector: T (cid:48) = Permπ(T ) means that t(cid:48)(i) = t(π(i)).
(I) Submission To submit a message t ∈ M encoded with randomness s, the
user calculates the triple (u, v, w) = (Com(t, s), EncM(t), EncR(s)) and provides
a proof of knowledge (POK) that the t and s used in all three components are
the same. The user uses a private channel to send the triple (u, v, w) to the
system together with the POK for consistency. The input batch of the ﬁrst mix
consists of all triples received ordered in some canonical way and is denoted as
(U0, V0, W0). The public part of the input batch, U0, is published.

(II) Mixing We now describe the shuﬄing procedure for K inputs and a
mix-net consisting of n mixes M1, M2 . . . , Mn. The input batch of Mj is de-
ﬁned as the output batch of the preceding mix Mj−1, except that the ﬁrst
mix receives its inputs directly from the system. In addition, the output batch
of the last mix will be sent to the key trustees T . In other respects, the
shuﬄing procedure for each mix is identical. (1) Let the input batch of the
mix Mj be (Uj−1, Vj−1, Wj−1). Then Mj rerandomizes the commitment vector:
j = Uj−1 · Com(0, Sj), it reencrypts the vector of encryptions of the contents:
U(cid:48)
j = Vj−1·EncM(0) and, through homomorphic encryption, updates the decom-
V (cid:48)
j = Wj−1 · EncR(Sj). (2) To obtain the output batch, Mj chooses
mit value: W (cid:48)
a random permutation πj and sets (Uj, Vj, Wj) = Permπj (U(cid:48)
j). (3) The
commitments Uj are published, whereas the corresponding encryptions Vj and
Wj are sent to Mj+1 through a private channel. (4) Mj proves, in a publicly
veriﬁable way, that Uj is a recoding and permutation of Uj−1. (5) Mj provides
a POK to Mj+1 that the output batch is a consistent rerandomization and per-
mutation of the entire input batch, i.e. it shows it knows permutation πj and
the vector of random values Sj. Note that T veriﬁes the output of the last mix.
(III) Decoding and publication The key trustees T compute and publish
T ∗ = Dec(Vn) and S∗ = Dec(Wn). Observe that due to the homomorphic prop-
erties and to the fact that the same permutations πj have been used in public

j , W (cid:48)

j, V (cid:48)

and the private network, we have that T ∗ and S∗ are the values to open Un,
that is, Un = Com(T ∗, S∗).
(IV) Certiﬁcation Auditors verify whether Un = Com(T ∗, S∗) and certify

the output if this condition and all public proofs of knowledge hold.

2.4 Properties

For proving correctness, it is necessary to show that the mixes did not change
any of the messages. In other words, T0 ≡ Tn, where ≡ stands for the existence
of a permutation that maps T0 to Tn. In our case correctness does not follow
straightaway from existing proofs of mixing schemes since these are all based
on encryption implying that the message t is unambiguously deﬁned. Since we
want the correctness to be universally veriﬁable while preserving unconditional
privacy, only public information can be used. However, as long as T can open
the commitments that are published by the last mix, i.e. publish the values T ∗
and S∗ such that Un = Com(T ∗, S∗), then T0 ≡ Tn. In other words, we argue
that for correctness it is completely irrelevant how T obtained T ∗ and S∗. This
is a consequence of the fact that the commitment scheme used is uncondition-
ally hiding and computationally binding. This can be proven by contradiction,
showing that if after running the protocol T0 (cid:54)≡ Tn, then there exists an eﬃcient
algorithm violating the binding property by computing a commitment u that
can be opened to two distinct values: u = Com(τ1, σ1) = Com(τ2, σ2). Note that,
because of the audit information published during all the mixing steps, any ob-
server can perform the checks. This, together with the fact that the randomness
of the challenge bit is guaranteed means that the protocol is universally ver-
iﬁable. Individual veriﬁability follows, simply because of the fact that the
users can check that their input u0 is published.

If at least one mix is honest and keeps the used permutation secret, then pri-
vacy follows from the fact that the output batch Tout is an unknown permuta-
tion of the input batch, Tin. Even a computationally unbounded attacker cannot
obtain any additional information, since the commitments used to encode the
messages are unconditional and all used proofs provide perfect zero-knowledge.
Regarding robustness, it is clear from the construction that if everybody
is honest, then the process must succeed, always. If cheating is detected the
malicious mix or the whole mix-net can simply be replaced. To avoid that a mix
can lie about its private input towards the veriﬁer, we ask the user and each mix
to sign its output. In addition the users have to send a POK for consistency to
ensure that they cannot submit inconsistent inputs without being detected.

3 Everlasting Privacy Towards the Authorities

Using the protocol presented in Section 2, the users submit the triple (u, v, w),
where v is an encryption of the message t. Though they use a private channel,
this protects them from outsiders, but not from the ﬁrst mix, who will be able to
recover t once the computational assumption is broken. If this is unacceptable, a

possible solution is to have several mix-nets in parallel, have the users split their
message, and submit each part to a diﬀerent mix-net. As long as none of the
ﬁrst mixes nor any of their veriﬁers share their information with one mix of each
mix-net, the privacy of the submitted message is guaranteed unconditionally.

A problem that arises here is how to match the various shares of one speciﬁc
user that come out of the various mix-nets, needed to recombine the complete
message. We solve this by supposing that a user submits each share labeled with
the same, randomly chosen identiﬁcation number ri, which should be chosen
large enough to avoid collision (say 128 bits). Since these ris cannot be public
(to prevent any of the ﬁrst mixes or its veriﬁer from tracing back a message),
the message t and the random identity ri are encoded in separate commitments
which are published and the decommitment values are sent together with the
opening values of the corresponding messages towards the private mix-nets. After
all data have been made anonymous by the mix-nets, the ris are decrypted by T
and a new authority Z who keeps the obtained IDs private. The same ri should
appear in each of the output batches of the various mixes and Z should therefore
be able to match shares coming from the same user, reconstruct the message,
and publish it. In addition, Z can use the published commitments to convince
the public that the correct tuples were matched.
Correctness, Individual and Universal Veriﬁability can be shown similar to
Section 2.4. The only diﬀerence is that Z has to prove that messages coming
from the same user have been matched correctly. This is accomplished by a POK
showing that when Z matches, shares coming from diﬀerent mixes have the same
ri. With respect to privacy, we claim that under the additional assumption that
the publication authority Z does not share its information with any of the ﬁrst
mixes or its veriﬁer, nor do one of the ﬁrst mixes or its veriﬁer collaborate with
one mix of each mix-net, privacy is also unconditional towards the authorities.
But if they do share information then, as long as a suﬃcient number of “key
trustees” are honest, they still need to break the encryption algorithm. For ro-
bustness, if all parties are honest then the protocol terminates successfully, unless
two users chose the same ri, which is an extremely unlikely event. Observe that
when using secret sharing, a user can submit inconsistent IDs. There seems no
obvious way to verify their consistency while maintaining unconditional privacy
towards the ﬁrst i mixes, Mi,1. However, if users err, it just means their mes-
sage cannot be decoded by Z; it does not aﬀect messages sent by other users.
For applications where this can be caused by malicious software, a veriﬁcation
step during the submission phase could be implemented which prevents both,
generating invalid messages and inconsistent IDs.

Conclusion and Future work

We presented a novel protocol for a publicly-veriﬁable mix-net which oﬀers ev-
erlasting privacy towards observers, meaning that the information made public
does not help an adversary with unlimited computational resources. Further, we
showed how the input can be split, each share mixed by a separate mix-net and

recombined providing everlasting privacy towards both, the observers and the
authorities. We believe this is an important step forward since, as Chaum him-
self already argued in 1984 [3], individuals cannot be expect to understand the
diﬀerence between computational and unconditional security, and they should
not have to worry about it. In particular, computational security is simply not
enough in some applications like elections, invalidating many proposed schemes.
We plan to introduce this mix-net to mixing based voting systems like Prˆet `a
Voter [12] or Split-Ballot [9]. Further, all known instantiations for a homomor-
phic commitment and encryption scheme are based on computational problems
that are not quantum resistant. We plan to work on this matter in the future.

Acknowledgement

This work is a direct result of the third author’s visit to Dagstuhl and Darm-
stadt in July 2011, and he would like to express his gratitude to the Dagstuhl
Institute, to SnT at the University of Luxemburg, to CASED at the Univer-
sity of Darmstadt, and to his hosts, Peter Ryan and Johannes Buchmann, for
making this visit possible. His research was partially supported by a FAPEMIG
grant, number APQ-02719-10. Further, this paper has been developed within
the project ‘VerKonWa’, funded by the DFG. Finally, we would like to thank
Tal Moran, Olivier Pereira and Jeremy Clark for interesting discussions.

References

1. Norwegian evote project, http://www.regjeringen.no/en/dep/
2. Chaum, D.: Untraceable electronic mail, return addresses, and digital pseudonyms.

Commun. ACM 24(2), pp. 84–88 (1981)

3. Chaum, D.: A new paradigm for individuals in the information age. In: IEEE

Symposium on Security and Privacy. pp. 99–106 (1984)

4. Demirel, D., van de Graaf, J., Samarone dos Santos Ara´ujo, R.: Improving helios
with everlasting privacy towards the public. In: Proceedings of EVT/WOTE (2012)
5. Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: ASI-

ACRYPT. pp. 321–340 (2010)

6. Howlader, J., Ghosh, A., Pal, T.D.: Secure Receipt-Free Sealed-Bid Electronic

Auction, p. 228 (2009)

7. Huszti, A., Peth¨o, A.: A secure electronic exam system. Publicationes Mathemat-

icae Debrecen 77/3.-4., 299–312 (2010)

8. Lipmaa, H., Zhang, B.: A more eﬃcient computationally sound non-interactive

zero-knowledge shuﬄe argument. In: SCN. pp. 477–502 (2012)

9. Moran, T., Naor, M.: Split-ballot voting: Everlasting privacy with distributed trust.

ACM Trans. Inf. Syst. Secur. 13(2) (2010)

10. Park, C., Itoh, K., Kurosawa, K.: Eﬃcient anonymous channel and all/nothing

election scheme. In: EUROCRYPT. pp. 248–259 (1993)

11. Pereira, O., Cuvelier, E., Peters, T.: Election veriﬁability or vote privacy: Do we

need to choose? SecVote 2012 (2012), http://secvote.uni.lu/

12. Ryan, P.Y.A., Bismark, D., Heather, J., Schneider, S., Xia, Z.: Prˆet `a voter: a

voter-veriﬁable voting system. IEEE TransIFS 4(4), 662–673 (2009)

