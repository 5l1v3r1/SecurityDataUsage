When Private Set Intersection Meets Big Data:

An Efﬁcient and Scalable Protocol

Changyu Dong

Dept. of Computer and
Information Sciences

University of Strathclyde

Glasgow, UK

changyu.dong@strath.ac.uk

Liqun Chen

Hewlett-Packard Laboratories

Bristol, UK

liqun.chen@hp.com

Zikai Wen

Dept. of Computer and
Information Sciences

University of Strathclyde

Glasgow, UK

wjb12186@uni.strath.ac.uk

ABSTRACT

Large scale data processing brings new challenges to the design of
privacy-preserving protocols: how to meet the increasing require-
ments of speed and throughput of modern applications, and how to
scale up smoothly when data being protected is big. Efﬁciency and
scalability become critical criteria for privacy preserving protocols
in the age of Big Data. In this paper, we present a new Private Set
Intersection (PSI) protocol that is extremely efﬁcient and highly
scalable compared with existing protocols. The protocol is based
on a novel approach that we call oblivious Bloom intersection. It
has linear complexity and relies mostly on efﬁcient symmetric key
operations. It has high scalability due to the fact that most opera-
tions can be parallelized easily. The protocol has two versions: a
basic protocol and an enhanced protocol, the security of the two
variants is analyzed and proved in the semi-honest model and the
malicious model respectively. A prototype of the basic protocol
has been built. We report the result of performance evaluation and
compare it against the two previously fastest PSI protocols. Our
protocol is orders of magnitude faster than these two protocols. To
compute the intersection of two million-element sets, our protocol
needs only 41 seconds (80-bit security) and 339 seconds (256-bit
security) on moderate hardware in parallel mode.
Categories and Subject Descriptors

D.4.6 [OPERATING SYSTEMS]: Security and Protection—Cryp-
tographic controls
Keywords

Private Set Intersection; Bloom Filters

1.

INTRODUCTION

In many countries, protecting data privacy is no longer optional
but a legal obligation. Legislation includes various US privacy laws
(HIPAA, COPPA, GLB, FRC, etc.), European Union Data Protec-
tion Directive, and more speciﬁc national privacy regulations. It
is a challenging task for organizations because they have to pro-
tect data in use and transmission. To this end, many security so-
lutions have been proposed to enable privacy-preserving data pro-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516701.

cessing. The amount of data to be processed and protected becomes
increasingly large. For example, geneticists need to search 3 bil-
lion base pairs in personal genome to ﬁnd genetic disorders that
might cause diabetes or cancers, epidemiologists need to link mul-
tiple medical databases that contain millions of patients’ records to
identify risk factors for diseases, and online retailers want to cor-
relate petabytes of their transaction records with customers’ social
network activities, hoping to increase customer satisfaction. Any
privacy-preserving data processing service is not cost free and this
has brought us new challenges: how to meet the increasing require-
ments of speed and throughput of modern applications, and how
to scale up smoothly when data being protected is big? With the
prevalence of large scale data processing, efﬁciency and scalability
become critical criteria for designing a privacy-preserving protocol
in the age of “Big Data”.

The subject of study in this paper is the Private Set Intersection
(PSI) problem. Namely, two parties, a client and a server, want to
jointly compute the intersection of their private input sets in a man-
ner that at the end the client learns the intersection and the server
learns nothing. The PSI problem has been extensively studied for
two reasons, ﬁrstly set intersection is a foundational primitive and
secondly it has many practical applications. For example, PSI has
been proposed as a building block in applications such as privacy
preserving data mining [4], human genome research [6], homeland
security [16], Botnet detection [33], social networks [32], location
sharing [35] and cheater detection in online games [11]. Many PSI
protocols have been proposed, e.g. [21, 30, 23, 13, 24, 27, 12, 16,
15, 28, 5, 25]. PSI protocols are often criticized as being impracti-
cal because the performance becomes unacceptable when the input
size or the security parameter becomes large, and it is difﬁcult to
improve the performance by just adding hardware proportionally.

The criticism is not unfounded. Currently two protocols claim to
be the fastest PSI protocol: the RSA-OPRF-based protocol by De
Cristofaro et al [16, 17] and the garbled circuit protocol by Huang
et al [25]. Both protocols have a highly optimized implementation.
We obtained the source code from the authors of these two proto-
cols and tested the performance. To compute the intersection of
two 1,048,576-element (220) sets, De Cristofaro’s protocol needs
10.6 minutes at 80-bit security, but requires a much longer time
at 256-bit security. We estimate the time to be approximately 131
hours from tests with smaller sets. The tests with million-element
sets on Huang’s protocol were unsuccessful because the Java Vir-
tual Machine ran out of memory on the client computer that has 16
GB RAM. From tests with smaller sets, we estimate that Huang’s
protocol requires 27 hours and 51 hours respectively to compute
the intersection at 80-bit and 256-bit security. Clearly to use PSI in
real world applications, we need more practical protocols.
Contributions We present a new PSI protocol that is much more

789efﬁcient than all the already existing PSI protocols. The protocol is
designed based on a novel two-party computation approach, which
makes use of a new variant of Bloom ﬁlters that we call garbled
Bloom ﬁlters, and we refer the new approach as oblivious Bloom in-
tersection. The ideas of garbled Bloom ﬁlters and oblivious Bloom
intersection are general and have their own interests.

Our PSI protocol has two versions: a basic protocol, security of
which can be proved in the semi-honest model, and an enhanced
protocol, security of which can be proved in the malicious model.
The basic protocol has linear complexity (with a small constant fac-
tor) and relies mostly on symmetric key operations. It is fast even
with large input sets, and when the security parameter increases,
the performance degrades gracefully. Test results show it is orders
of magnitude faster than the previous best protocols. The enhanced
protocol is an extension of the basic protocol, that only increases
the cost by a factor proportional to the security parameter.

Apart from efﬁciency, another big advantage of the protocol is
scalability: the computational, memory and communication com-
plexities are all linear in the size of the input sets. More attractively,
most operations in the protocol can be performed in the SPMD
(single program, multiple data) fashion, which means little effort
is required to separate the computation into a number of parallel
tasks. Therefore it can fully take the advantage of parallel pro-
cessing capacity provided by current multi-core CPUs, GPGPUs
(General-purpose graphics processing unit) and cloud computing.
As a result, the protocol is particularly suitable for Big Data ori-
ented applications that have to process data in a parallelized and/or
distributed way.

We have implemented a proof of concept prototype of the basic
protocol. To compute the intersection of two million-element sets,
it needs only 41 seconds (80-bit) and 5.65 minutes (256-bit) on two
moderate computers in parallel mode.
Organization The paper is organized as follows: in section 2, we
review the related work, in section 3 we introduce the notation and
building blocks; in section 4, we present the garbled Bloom ﬁlter
data structure, the semi-honest protocol, analyze the security and
provide a simulation-based proof; in section 5 we show how to
extend the basic protocol to achieve security against malicious ad-
versaries; in section 6 we show a prototype of the basic protocol
and the performance evaluation result; in section 7, we conclude
the paper.

2. RELATED WORK

The concept and ﬁrst protocol of Private Set Intersection were
introduced by Freedman et al in [21]. Their protocol is based on
oblivious polynomial evaluation. Along this line, Kissner and Song
[30] proposed protocols in multiparty settings, Dachman-Soled et
al [13], and Hazay and Nissim [24] proposed protocols which are
more efﬁcient in the presence of malicious adversaries. Hazey and
Lindell [23] proposed another approach for PSI which is based
on oblivious pseudorandom function (OPRF) evaluation. This ap-
proach is further improved by Jarecki and Liu [27, 28] and De
Cristofaro et al [16, 15]. There are also a number of variants of
PSI protocols, which aim to achieve more features than the original
PSI concept. Camenisch and Zaverucha [12] proposed a PSI pro-
tocol which requires the input sets to be signed and certiﬁed by a
trusted party, Ateniese et al [5] proposed a PSI protocol that also
hides the size of the client’s input set. Among the above protocols,
the most efﬁcient protocol is the protocol by De Cristofaro et al
It has linear complexity and requires O(n) public key
[16, 15].
operations, where n is the size of the set. The performance of this
protocol is affected signiﬁcantly by n and the security parameter.
Recently, Huang et al [25] presented a semi-honest PSI protocol

based on garble circuits. This protocol requires O(nlogn) sym-
metric key operations and a small number of public key operations.
The authors demonstrated that in certain cases this protocol is sig-
niﬁcantly more efﬁcient than the previous PSI protocols. At low
security settings, De Cristofaro’s protocol [16] is the fastest but at
high security settings, Huang’s protocol [25] is more efﬁcient.

Recently a few PSI protocols based on Bloom ﬁlters were pro-
posed. In [31], the parties AND their Bloom ﬁlters by a secure mul-
tiplication protocol and each party obtains an intersection Bloom
ﬁlter. They then query the resulting Bloom ﬁlter to obtain the inter-
section. However the protocol is not secure because the intersec-
tion Bloom ﬁlter leaks information about other party’s sets. In [29],
Bloom ﬁlters are used in conjunction with the Goldwasser Micali
homomorphic encryption.The semi-honest version of the protocol
requires kn hash operations and (k log2 e + kl + k + 2l)n modu-
lar multiplications, where k and l are parameters controlling false
positive and e is the base of natural logarithms. Our basic protocol
requires 2(k +k log2 e)n hash operations and a few hundred public
key operations (independent to n). The total number of operations
in our basic protocol is much less than the protocol in [29]. Given
that a modular multiplication is faster than a public key operation
but slower than a hash operation, for large input sets (i.e. a large
value of n), the PSI scheme in [29] would be slower than our basic
protocol. The protocol also has a higher communication overhead
than ours, as each bit in the Bloom ﬁlter and the encrypted elements
has to be expanded to a group element. The version secure in the
malicious model requires a trusted party to certify the client’s set,
thus is hard to compare fairly with our enhanced protocol.

3. PRELIMINARIES

3.1 Notation

A function µ(·) is negligible in n, or just negligible, if for ev-
ery positive polynomial p(·) and any sufﬁciently large n it holds
that µ(n) ≤ 1/p(n). A probability ensemble indexed by I is a
sequence of random variables indexed by a countable index set I.
Namely, X = {Xi}i∈I where each Xi is a random variable. Two
distribution ensembles X = {Xn}n∈N and Y = {Yn}n∈N are
c
≡ Y if for ev-
computationally indistinguishable, denoted by X
ery probabilistic polynomial-time (PPT) algorithm D, there exists
a negligible function µ(·) such that for every n ∈ N,

|P r[D(Xn, 1n) = 1] − P r[D(Yn, 1n) = 1]| ≤ µ(n)

For a set X, we denote by x r← X the process of choosing an
element x of X uniformly at random.

3.2 Bloom Filters

A Bloom ﬁlter [9] is a compact data structure for probabilis-
tic set membership testing. A Bloom ﬁlter is an array of m bits
that can represent a set S of at most n elements. A Bloom ﬁlter
comes with a set of k independent uniform hash functions H =
{h0, ..., hk−1} such that each hi maps elements to index numbers
over the range [0, m − 1] uniformly. In the rest of the paper, we use
(m, n, k, H)-Bloom ﬁlter to denote a Bloom ﬁlter parameterized
by (m, n, k, H), use BFS to denote a Bloom ﬁlter that encodes
the set S, and use BFS[i] to denote the bit at index i in BFS .

Initially, all bits in the array are set to 0. To insert an element x ∈
S into the ﬁlter, the element is hashed using the k hash functions to
get k index numbers. The bits at all these indexes in the bit array
are set to 1, i.e. set BFS[hi(x)] = 1 for 0 ≤ i ≤ k − 1. To check
if an item y is in S, y is hashed by the k hash functions, and all

790locations y hashes to are checked. If any of the bits at the locations
is 0 , y is not in S, otherwise y is probably in S.

Because the hash functions are deterministic, if y is encoded in
the ﬁlter then in the query phase every BFS[hi(y)] must be 1, so
a Bloom ﬁlter never yields a false negative. However, a false pos-
itive is possible, i.e. it is possible that y is not in the set S, but all
BFS[hi(y)] are set to 1. The probability that a particular bit in the
Bloom ﬁlter is set to 1 is p = 1 − (1 − 1/m)kn, and according to
[10], the upper bound of the false positive probability is:

ǫ = pk × (1 + O(

k

pr ln m − k ln p

m

))

(1)

which is negligible in k.

In practice we often need to build a Bloom ﬁlter with a capped
false positive probability, i.e. it represents any set of at most n ele-
ments from a universe in a manner that allows false positive proba-
bility to be at most ε. The efﬁciency of such a Bloom ﬁlter depends
on the parameters m and k. It turns out the lower bound of m in this
case is m ≥ n log2 e · log2 1/ε, where e is the base of natural loga-
rithms. The optimal number of hash functions is k = (m/n) · ln 2
and if m is also optimal then the optimal k is log2 1/ε. In the rest
of the paper, we always assume optimal k and m unless otherwise
stated.

A standard Bloom ﬁlter trick is that if we have two (m, n, k, H)-
Bloom ﬁlters that each encodes a set S1 and S2, we can obtain an-
other (m, n, k, H)-Bloom ﬁlter BFS1∩S2 by bit-wisely ANDing
BFS1 and BFS2 . The resulting Bloom ﬁlter has no false nega-
tive, which means the query result of any element y ∈ S1 ∩ S2
against BFS1∩S2 is always true. The false positive probability of
the resulting Bloom ﬁlter is no higher than either of the constituent
Bloom ﬁlter [37]. Note that due to collisions, it is possible that the
jth bit is set in BFS1 by an element in S1 − S1 ∩ S2 and jth bit is
set in BFS2 by an element in S2 − S1 ∩ S2. Therefore the resulting
Bloom ﬁlter usually contains more 1 bits than the Bloom ﬁlter built
from scratch using S1 ∩ S2.

3.3 Secret Sharing

Secret sharing is a fundamental cryptographic primitive. It al-
lows a dealer to split a secret s into n shares such that the secret
s can be recovered efﬁciently with any subset of t or more shares.
With any subset of less than t shares, the secret is unrecoverable
and the shares give no information about the secret. Such a sys-
tem is called a (t, n)-secret sharing scheme. An example of such a
scheme is Shamir’s secret sharing scheme [40].

When t = n, an efﬁcient and widely used secret sharing scheme
can be obtained by simple ⊕ (XOR) operations [39]. The scheme
works by generating n − 1 random bit strings r1, ..., rn−1 of the
same length as the secret s, and computing rn = r1⊕, ..., ⊕rn−1⊕
s. Each ri is a share of the secret. It is easy to see that s can be
recovered by computing r1⊕, ..., ⊕rn and any subset of less than
n shares reveals no information about the secret.

3.4 Oblivious Transfer

Oblivious transfer [38, 20] allows a sender to send part of its
input to a receiver in a manner that protects both parties. Namely,
the sender does not know which part the receiver receives and the
receiver does not learn any information about the other part of the
sender’s input. Generally, an oblivious transfer protocol can be
denoted as OTm
l . The notation means the sender holds m pairs l-
bit strings (xj,0, xj,1) (0 ≤ j ≤ m − 1), while the receiver holds
an m-bit selection string r = (r0, ..., rm−1). At the end of the
protocol execution, the receiver outputs xj,rj for 0 ≤ j ≤ m − 1.
Oblivious transfer protocols are costly and often become the ef-

ﬁciency bottleneck in protocol design. However it has been shown
by Beaver that it is possible to obtain a large number oblivious
transfers given only a small number of actual oblivious transfer
calls [7]. In this direction, efﬁcient OT extensions were proposed
in [26]. The extensions rely on the Random Oracle Model [8] (or
the existence of correlation robust hash functions) and can reduce
OTm
λ where λ is a security parameter. The latter can be
l
further reduced to λ invocations of OT1
λ. In our implementation,
we use the above OT extension scheme to reduce the actual cost of
an OTm
λ invocation to λ calls to the Naor-Pinkas OT protocol [34].
For the detail of the reduction, please consult [26].

to OTλ

3.5 The Semi-honest Model

We prove the security of the basic protocol in the presence of
static semi-honest adversaries.
In the model, the adversary con-
trols one of the two parties and follows the protocol speciﬁcation
exactly. However, it may try to learn more information about the
other party’s input. The deﬁnitions and model are according to [22].
A two-party protocol π computes a function that maps a pair of
inputs to a pair of outputs f : {0, 1}∗ × {0, 1}∗ → {0, 1}∗ ×
{0, 1}∗, where f = (f1, f2). For every pair of inputs x, y ∈
{0, 1}∗, the output-pair is a random variable (f1(x, y), f2(x, y)).
The ﬁrst party obtains f1(x, y) and the second party obtains f2(x, y).
The function can be asymmetric such that only one party gets the

result. It is captured as f (x, y)
the empty string.

def
= (f1(x, y), Λ), where Λ denotes

In the semi-honest model, a protocol π is secure if whatever can
be computed by a party in the protocol can be obtained from its in-
put and output only. This is formalized by the simulation paradigm.
We require a party’s view in a protocol execution to be simulatable
given only its input and output. The view of the party i during
an execution of π on (x, y) is denoted by viewπ
i (x, y) and equals
t) where w ∈ (x, y) is the input of i, ri is the
(w, ri, mi
outcome of i’s internal random coin tosses and mi
j represents the
jth message that it received.

1, ..., mi

DEFINITION 1. Let f = (f1, f2) be a deterministic function.
We say that the protocol π securely computes f in the presence of
static semi-honest adversaries
there exists probabilistic
polynomial-time algorithms S1 and S2 such that

if

{S1(x, f1(x, y))}x,y

c
≡ {viewπ

1 (x, y)}x,y

{S2(y, f2(x, y))}x,y

c
≡ {viewπ

2 (x, y)}x,y

4. THE BASIC PROTOCOL

In this section we present the basic protocol that is secure in the
semi-honest model. Conceptually the protocol is very simple: the
client computes a Bloom ﬁlter that encodes its set C and the server
computes a garbled Bloom ﬁlter (see below) that encodes its set
S. Then they run an oblivious transfer protocol so that the client
obtains a garbled Bloom ﬁlter that represents the intersection and
the server learns nothing. Then the client queries the intersection
garbled Bloom ﬁlter and obtains the intersection.

4.1 Garbled Bloom Filters

We introduce a new variant of Bloom ﬁlters called garbled Bloom
ﬁlters (GBF). A garbled Bloom ﬁlter is the garbled version of a
standard Bloom ﬁlter. From a high level point of view, there is
no difference between a garbled Bloom ﬁlter and a Bloom ﬁlter:
it encodes a set of at most n elements in an array of length m, it
supports membership query with no false negative and negligible
false positive. To add an element, the element is mapped by k in-
dependent uniform hash functions into k index numbers and the

791corresponding array locations are set. To query an element, the ele-
ment is mapped by the same k hash functions into k index numbers
and the corresponding array locations are checked.

From a low level point of view, a garbled Bloom ﬁlter is backed
by a different data structure. Namely, instead of using an array of
bits, a garbled Bloom ﬁlter uses an array of λ-bit strings, where λ is
a security parameter. In the rest of the paper, we use (m, n, k, H, λ)-
garbled Bloom ﬁlter to denote a garbled Bloom ﬁlter parameterized
by (m, n, k, H, λ), we denote a garbled Bloom ﬁlter encoding a set
S by GBFS and denote the λ-bit string at index i by GBFS[i].

To add an element x ∈ S to a garbled Bloom ﬁlter, we split the
element into k λ-bit shares using the the XOR-based secret shar-
ing scheme as described in section 3.3. The element is also mapped
into k index numbers and we store one share in each location hi(x).
Note this is a very loose description, the actual process is more
complicated. To query an element y, we collect all bit strings at
hi(y) and XOR them together. If the result is y then y is in S,
otherwise y is not in S. The correctness is obvious: if y ∈ S, the
XOR operation will recover y from its k shares which are retriev-
able from the garbled Bloom ﬁlter by their indexes. If y 6∈ S, then
the probability of the XOR result is the same as y is negligible in
λ. The algorithm to encode a set into a garbled Bloom ﬁlter and the
algorithm to query an element are given in Algorithm 1 and 2.

Algorithm 1: BuildGBF (S, n, m, k, H, λ)
input : A set S, n, m, k, λ, H = {h0, ...hk−1}
output: An (m, n, k, H, λ)-garbled Bloom ﬁlter GBFS

1 GBFS = new m-element array of bit strings;
2 for i = 0 to m − 1 do
3

GBFS [i]=NULL; // NULL is the special symbol that means “no

value”

4 end
5 for each x ∈ S do
6

emptySlot = −1, ﬁnalShare= x;
for i=0 to k-1 do

7

8

9

10

11

12

13

14

15

16

17

18

19

j = hi(x);
if GBFS[j]==NULL then

if emptySlot ==−1 then

// get an index by hashing the element

emptySlot=j;
finalShare

// reserve this location for

GBFS[j] r← {0, 1}λ;
ﬁnalShare=ﬁnalShare⊕GBFS[j];

// generate a new share

else

end

ﬁnalShare=ﬁnalShare⊕GBFS[j]; // reuse a share

else

end

// store the last share

end
GBFS[emptySlot]=ﬁnalShare;

20
21 end
22 for i = 0 to m − 1 do
23

if GBFS[i]==NULL then
GBFS[i] r← {0, 1}λ;

24

25
26 end

end

In Algorithm 1, we ﬁrst create an empty garbled Bloom ﬁlter and
initialize each location to NULL (line 1-4). To add x ∈ S, we split
x into k shares on the ﬂy and store the shares in GBFS[hi(x)]
(line 5-21). Note that in this process, some location j = hi(x)
may have been occupied by a previously added element. In this
case we reuse the existing share stored at GBFS[j] (line 16-18).
For example, in Figure 1 we ﬁrst add x1 to GBFS and split it into
3 shares s1
1. Then when we add x2, GBFS[4] has already
been occupied by s2
1 as a share of x2,

1. So we reuse the string s2

1, s3

1, s2

 0    1    2   3   4    5   6    7   8   9   10  11

*

s1
1

*

*

s2
1

*

s1
2

*

s3
1

*

s2
2

*

x1

x2

2 ⊕ s2

1 ⊕ s1

Figure 1: Add elements into a garbled Bloom ﬁlter
2. This is because if we replace s2

i.e. x2 = s2
1 with an-
other string, x1 will not be recoverable in the query phase. Reusing
shares will not cause security problems as far as the protocol con-
cerns, we will show in Theorem 3 that the probability of getting all
shares of an element that is not in the intersection in our protocol
is negligible. After adding all elements in S, we generate and store
random λ-bit strings at all locations that are still NULL (line 22-
26). Algorithm 1 will succeed with an overwhelming probability,
as stated in Theorem 1. When m and k are optimal, the success
probability in Theorem 1 is approximately 1 − 2−k.

Algorithm 2: QueryGBF (GBFS, x, k, H)

input : A gabled Bloom ﬁlter GBFS , an element x, k,

H = {h0, ...hk−1}

output: True if x ∈ S, False otherwise

j = hi(x);
recovered = recovered ⊕ GBFS[j];

1 recovered = {0}λ;
2 for i = 0 to k − 1 do
3

4
5 end
6 if recovered == x then
7
8 else
9
10 end

return False;

return True;

THEOREM 1. Algorithm 1 will succeed with a probability at

least 1 − p′k × (1 + O( k
1/m)k(n−1).

p′q ln m−k ln p′

m

)) where p′ = 1 − (1 −

PROOF. Algorithm 1 fails when emptySlot remains −1 after the
inner loop (line 20). This happens when adding an element to the
GBF, all locations the element hashes to have been occupied by
previously added elements. Because in this case, at most n − 1
elements have been added to the GBF, the probability of a particular
position is occupied is at most p′ = 1 − (1 − 1/m)k(n−1). The
probability of all k locations have been occupied can be obtained in
the same way as the false positive probability of an (m, n, k, H)-
BF, which is at most p′k × (1 + O( k
probability is then 1 minus the probability of failure.

p′q ln m−k ln p′

)). The success

m

In a garbled Bloom ﬁlter, each location is a λ-bit string that
is either a share of certain elements or a random string. Analo-
gously, a share in a gabled Bloom ﬁlter is equivalent to a “1” bit
in a Bloom ﬁlter, and a random string is equivalent to a “0” bit.
Same as the Bloom ﬁlters, there is no false negative when using
a GBF because all shares of an encoded element are guaranteed
to be retrievable and the XOR-based secret sharing scheme always
produces the original element when all shares are available. When
using a GBF, we need to consider and differentiate the following
two probabilities:

• The collision probability of a GBF is the probability when y
is not in S, but it hashes to the same set of index numbers as
some x ∈ S. A collision does not cause false positive: the
recovered string (Algorithm 2) is x but not y so the query

792result is still false. However it reveals x. The collision proba-
bility is negligible in k. Loosely, we can use the upper bound
of the false positive probability of a Bloom ﬁlter as the upper
bound of the collision probability of a garbled Bloom ﬁlter.
Note that collisions do not affect the security of our protocol,
but may be a concern if a GBF is used in other protocols.

• The false positive probability of GBFS is the probability
when y is not in S but the recovered string equals y co-
incidentally. This probability is at most 2−λ.

More formally, we have the following theorem:

THEOREM 2. Let GBFS be an (m, n, k, H, λ)-garbled Bloom
i=0 GBFS[hi(y)]) = x] ≤ ǫ,
where ǫ is the maximum false positive probability in equation (1).

ﬁlter, (i) ∀y 6∈ S, x ∈ S : P r[(Lk−1
(ii) ∀y 6∈ S : P r[(Lk−1

i=0 GBFS[hi(y)]) = y] ≤ 2−λ.

PROOF. We start from the collision probability. Let BFS be the
(m, n, k, H)-Bloom ﬁlter that encodes the same set S as GBFS.
Now for any y 6∈ S, we query y against both GBFS and BFS.
Whenever the GBF query results in a collision, the Bloom ﬁlter
query must return a false positive. This is because by deﬁnition,
y hashes to the same set of index numbers as some x ∈ S, so all
locations are set to 1 in BFS by x, therefore the Bloom ﬁlter query
returns true, but y 6∈ S so this is a false positive. Since a GBF col-
lision implies a Bloom ﬁlter false positive, the collision probability
is bounded by the false positive probability of the Bloom ﬁlter.

Let’s consider the false positive probability of a GBF. A false
positive occurs when y is not in S but the recovered string equals
y. The recovered string is GBFS[h0(y)] ⊕ . . . ⊕ GBFS[hk−1(y)].
Each constitution string GBFS[hi(y)] is either a share of certain
elements or a random string. When y 6∈ S, there are three cases:
Case 1: All constitution strings are shares of the same element in
S. We denote the probability of this case as p1. In this case for sure
recovered 6= y because y 6∈ S.
Case 2: The constitution strings are shares of several elements in
S. We denote the probability of this case as p2. In this case we can
divide the constitution strings into several groups of size at most k−
1, each group contains the shares of a particular element. From the
security of the XOR-based secret sharing scheme, the XOR result
of each group should be a uniformly random string. Therefore the
recovered string is a uniformly random string.
Case 3: At least one of the constitution strings is a random string.
The probability of this case as p3 = 1 − p1 − p2. In this case the
recovered string is also a uniformly random string.

In all three cases, a false positive occurs if recovered = y. In
case 1, the false positive probability is 0. In the other two cases,
the false positive probability is 2−λ. Let B denote the event that a
false positive occurs, and let a1, a2, a3 denote the events that case
1, case 2, case 3 occurs respectively, by the law of total probability,
the false positive probability is:

P r[B] = P r[a1]P r[B|a1] + P r[a2]P r[B|a2] + P r[a3]P r[B|a3]

= 0 · p1 + 2−λ · p2 + 2−λ · p3
= 2−λ(1 − p1) ≤ 2−λ

In summary, with proper parameters, a garbled Bloom ﬁlter ex-
hibits similar properties when encoding set membership: no false
negative and negligible false positive.

(m, n, k, H)-Bloom ﬁlter. The idea is quite similar to creating an
intersection Bloom ﬁlter by ANDing two Bloom ﬁlters.

Let’s say we have an (m, n, k, H)-Bloom ﬁlter BFC that en-
codes a set C and an (m, n, k, H, λ)-garbled Bloom ﬁlter GBFS
that encodes a set S. We use Algorithm 3 to build the intersection
garbled Bloom ﬁlter GBFC∩S .

Algorithm 3: GBF Intersection(GBFS, BFC , m)

input : An (m, n, k, H, λ)-garbled Bloom ﬁlter GBFS, an

(m, n, k, H)-Bloom ﬁlter BFC, m

output: An (m, n, k, H, λ)-garbled Bloom ﬁlter GBFC∩S

1 GBFC∩S= new m-element array of bit strings;
2 for i = 0 to m − 1 do
3

if BFC[i] == 1 then

GBFC∩S[i] = GBFS[i];

GBFC∩S[i] r← {0, 1}λ;

4

5

6

7
8 end

else

end

The intuition of the algorithm is this: if an element x is in C ∩ S,
then for every position i it hashes to, BFC [i] must be a 1 bit and
GBFS[i] must be a share of x. Therefore by running the algorithm,
all shares of x are copied to the new garbled Bloom ﬁlter. That is,
all elements in C ∩ S are preserved in the new garbled Bloom ﬁlter.
On the other hand, if x is not in C ∩ S, then with a high probability,
at least one share will not be copied. Or in other words, elements
not in C ∩S are eliminated from the new garbled Bloom ﬁlter. Thus
the new garbled Bloom ﬁlter is indeed a garbled Bloom ﬁlter that
encodes the intersection. Formally, we have the following theorem:

THEOREM 3. Let GBFC∩S be an (m, n, k, H, λ)-garbled
Bloom ﬁlter produced in Algorithm 3. For 0 ≤ i ≤ k − 1, let
ai be the event that GBFC∩S[hi(x)] equals the ith share of x, we
have (i) ∀x ∈ C ∩ S: P r[a0 ∧ . . . ∧ ak−1] = 1, (ii) ∀x 6∈ C ∩ S:
P r[a0 ∧ . . . ∧ ak−1] is negligible in k.

PROOF. The ﬁrst part: we can see from the algorithm that for
any element x ∈ C ∩ S, all the shares will be copied from GBFS
to GBFC∩S because the corresponding locations in BFC are all
set to 1.

The second part: Firstly, GBFC∩S does not encode any element
x 6∈ S because GBFS contains no share of any element x 6∈ S.
Secondly, for any element x ∈ S − C ∩ S, the probability of all
its shares are copied from GBFS to GBFC∩S is ǫ, where ǫ is the
upper bound of the false positive probability of an (m, n, k, H)-
BF. This is because if all shares of x are copied to GBFC∩S then it
means all locations that x hashes to in BFC are set to 1. However
x 6∈ C ∩ S and consequently x 6∈ C, then it implies a false positive
when we query x against BFC and the probability is ǫ.

From security point of view, a more interesting property of the
intersection GBF is that it is indistinguishable from a GBF built
from scratch that encodes C ∩ S.

THEOREM 4. Given sets C, S and their intersection C ∩ S,
let GBFC∩S be an (m, n, k, H, λ)-garbled Bloom ﬁlter produced
by Algorithm 3 from GBFS and BFC , let GBF ′
C∩S be another
(m, n, k, H, λ)-garbled Bloom ﬁlter produced by Algorithm 1 us-
ing C ∩ S, we have GBFC∩S

c
≡ GBF ′

C∩S.

4.2 Produce an Intersection GBF

In this section we show how to produce an intersection garbled
Bloom ﬁlter from an (m, n, k, H, λ)-garbled Bloom ﬁlter and an

PROOF. Given GBFC∩S , we modify it to get GBF ′′

C∩S . We
scan GBFC∩S from the beginning to the end and for each location
i, we modify GBFC∩S[i] using the following procedure:

7931. If GBFC∩S[i] is a share of an element in C ∩ S, then do

nothing.

2. Else if GBFC∩S[i] is a random string, do nothing.
3. Else if GBFC∩S[i] is a share of an element in S − C ∩ S,

replace it with a uniformly random λ-bit string.

n, m, k, λ, h0, . . . , hk−1

C lient

set : C

Server

set : S

BFC

OT m
λ

GBFS

The result is GBF ′′
these three cases, so there is no unhandled case.

C∩S. Every GBFC∩S[i] must fall into one of

Now we argue that the distribution of GBF ′′

C∩S is identical to

C ∩ S

query GBF π

C∩S

Figure 2: The basic PSI protocol π∩

C∩S and GBF ′

C∩S[i] is a share of an element in C ∩ S iff GBF ′

C∩S . To see that, let’s compare each location in GBF ′′

C∩S
C∩S . From Algorithm 1 and the above procedure, we can
C∩S contain only shares of elements

GBF ′
and GBF ′
see that GBF ′′
in C ∩ S and random strings. Because GBF ′′
C∩S
use the same set of hash functions, for each 0 ≤ i ≤ m − 1,
GBF ′′
C∩S[i] is
a share of the same element; GBF ′′
C∩S[i] is a random string iff
GBF ′
C∩S[i] is a random string. The distribution of a share de-
pends only on the element and the random strings are uniformly
distributed. So the distribution of every location in GBF ′′
C∩S and
C∩S are identical therefore the distributions of GBF ′′
GBF ′
C∩S and
GBF ′
C∩S are identical.

C∩S and GBF ′

Then we argue that the distribution of GBF ′′

C∩S is identical to

GBFC∩S except for a negligible probability η.
Case 1, GBFC∩S encodes at least one elements in S − C ∩ S. In
this case the distribution of GBF ′′
C∩S differs from the distribution
of GBFC∩S . From Theorem 3, the probability of each element
in S − C ∩ S being encoded in GBFC∩S is ǫ. Since there are
d = |S| − |C ∩ S| elements in S − C ∩ S, the probability of at
least one element is falsely contained in GBFC∩S is:

η =

d

X

i=1

(cid:16)d
i(cid:17) · ǫi =

d

X

i=1

d(d − 1)...(d − i + 1)

i(i − 1)...1

· ǫi ≤

d

X

i=1

(dǫ)i ≤ 2dǫ

As we can see η is negligible if ǫ is negligible.
Case 2: GBFC∩S encodes only elements from C ∩ S. In this case,
each element in S−C∩S may leave up to k−1 shares in GBFC∩S.
The only difference between GBFC∩S and GBF ′′
C∩S is that in
GBF ′′
C∩S , all “residue” shares of elements in S − C ∩ S are re-
placed by random strings. From the security of the XOR-based
secret sharing scheme, the residue shares should be uniformly ran-
dom (otherwise they leak information about the elements). Thus
the procedure does not change the distribution when modifying
GBFC∩S into GBF ′′
C∩S. So the distributions of GBFC∩S and
GBF ′′
C∩S are identical. The probability of this case is at least 1−η.
C∩S always holds and GBFC∩S ≡
C∩S holds in case 2, we can conclude that P r[GBFC∩S ≡
C∩S] ≥ 1 − η thus

C∩S ≡ GBF ′

GBF ′′
GBF ′

Since GBF ′′

|P r[D(GBFC∩S) = 1] − P r[D(GBF ′

C∩S) = 1]| ≤ η

Theorem 4 shows that the probability of GBFC∩S and GBF ′

C∩S
are distinguishable is η. In our implementation we set k = λ so ǫ
is about 2−λ, then a question may arise whether this is appropri-
ate: since η is bounded by 2dǫ, will the security be weakened?
For example if λ = 80 and d = 220, will the security be weak-
ened to about 60-bit rather then desired 80-bit? The answer is no.
Loosely speaking, a bigger d means that an adversary can distin-
guish GBFC∩S and GBF ′
C∩S with a smaller number of attempts,
but in each attempt the amount of computation required to distin-
guish the two also increases. Therefore the total amount of work
needed to distinguish the two remains unchanged. We demonstrate
it through the following game: an adversary can query an oracle
with two sets S and C of its choice. The oracle randomly chooses
b r← {0, 1}, if b = 1, it returns GBFC∩S, if b = 0, it returns

GBF ′
C∩S .The adversary can repeatedly query the oracle. At the
end of the game, it challenges the oracle and outputs b′. It wins the
game if b′ = b. The advantage is |P r[b′ = b] − 1
2 |. As we show in
Theorem 5, the advantage depends only on ǫ, not η.

THEOREM 5. For an adversary runs in time t, the adversary’s

advantage in the above game is no more than O(t) · ǫ.

PROOF. In each oracle query, the adversary has a probability of
η to distinguish GBFC∩S and GBF ′
C∩S . Therefore if it makes q
oracle queries, the advantage will be q · η. The number of oracle
queries the adversary can make is t/td, where td is the time needed
to check whether the GBF encodes an element that is not in the
intersection. As there is no way other than querying the GBF to
decide, the best the adversary can do is to query all elements in
S −C ∩S against the GBF. Therefore td = |S −C ∩S|·tg = d·tg,
where tg is the time of a GBF query. Therefore the advantage of
the adversary is: q · η = t
td

· 2dǫ = O(t) · ǫ.

· η ≤ t
d·tg

4.3 Oblivious Bloom Intersection

The idea of the basic protocol is shown in Figure 2. That is, to
run Algorithm 3 by two parties using oblivious transfer. Thus we
call it oblivious Bloom intersection. The protocol runs as follows:

1. The server’s private input is S, and the client’s private input
is C. The auxiliary inputs include the security parameter λ,
the maximum set size n, the optimal Bloom ﬁlter parameters
m, k and H = {h0, ..., hk−1}. The parameter k is set to be
the same as the security parameter λ.

2. The client generates an (m, n, k, H)-BF that encodes its pri-
vate set C, the server generates an (m, n, k, H, λ)-GBF that
encodes its private set S. The client uses its Bloom ﬁlter as
the selection string and acts as the receiver in an OT m
λ proto-
col. The server acts as the sender in the OT protocol to send
m pair of λ-bit strings (xi,0, xi,1) where xi,0 is a uniformly
random string and xi,1 is GBFS[i]. For 0 ≤ i ≤ m − 1,
if BFC [i] is 0, then the client receives a random string, if
BFC[i] is 1 it receives GBFS[i]. The result is GBF π

C∩S.

3. The client computes the intersection by querying all elements

in its set against GBF π

C∩S.

At the end of step 2, the client receives a new garbled Bloom
C∩S . The OT protocol does exactly what we want to

ﬁlter GBF π
achieve in Algorithm 3.

THEOREM 6. Given an (m, n, k, H, λ)-Garbled Bloom ﬁlter
GBFS and an (m, n, k, H)-Bloom ﬁlter BFC . the garbled Bloom
ﬁlter GBF π
C∩S is equivalent to a garbled Bloom ﬁlter GBFC∩S
that is built by Algorithm 3 using GBFS and BFC .

PROOF. Let’s run the algorithm and protocol simultaneously and
use the same random coins for the random strings that are to be
placed in GBF π
C∩S and GBFC∩S. From the description of the
algorithm and the protocol, we can see that for 0 ≤ i ≤ m − 1,

794Huang’s

De Cristofaro’s

The Basic Protocol

PK ops
O(λ)
O(n)
O(λ)

SK ops

Memory

Comm.

O(n log n) O(n log n) O(n log n)

O(n)
O(n)

O(n)
O(n)

O(n)
O(n)

Assuming the underlying OT m
λ protocol is secure, then the basic
PSI protocol π∩ in Section 4.3 securely computes f∩ in the pres-
ence of semi-honest adversaries.

Table 1: Asymptotic Costs Comparison: n is size of the input sets,
λ is the security parameter, PK (SK) ops means public (symmetric)
key operations.
if BFC[i] = 1, then GBF π
C∩S[i] = GBFC∩S[i] = GBFS[i]; if
BFC [i] = 0, then GBF π
C∩S[i] = GBFC∩S[i] = ri where ri is a
uniformly random strings. Therefore the two garbled Bloom ﬁlters
are equivalent.

Informally, the correctness of the protocol follows from Theo-
rem 3 and 6. The protocol produces a garbled Bloom ﬁlter that
encodes C ∩ S, then by querying it the client can obtain the cor-
rect intersection except for a negligible probability. To see why the
protocol is secure, notice that the only messages being sent in the
protocol are the messages in the OT protocol. The client’s privacy
is protected because the server learns no information about BFC
in the OT execution. The server’s privacy is protected because the
client receives only GBF π
C∩S from the server and it contains only
information about elements in C ∩ S.

The reader may have noticed that the OT protocol can also be
used to AND two Bloom ﬁlters in a similar way and create an inter-
section Bloom ﬁlter BFC∩S on the client side. Then do we really
need the garbled Bloom ﬁlter? Can the server just encode its set
into a Bloom ﬁlter and run the protocol? The quick answer is we
do need the garbled Bloom ﬁlter. BFC∩S leaks information about
the server’s set because it contains more 1 bits than the Bloom ﬁlter
built from scratch using C ∩ S. The expected number of additional
1 bits is (tS −t∩)(tC −t∩)
, where tS, tC, t∩ are the number of 1 bits
in BFS, BFC and the the Bloom ﬁlter built from scratch using
C ∩ S respectively [37]. The additional knowledge the client gets
is the additional 1 bits in BFC∩S.

m−t∩

The protocol makes a single call to OT m

λ , so the efﬁciency de-
pends largely on the efﬁciency of the underlying OT protocol. If
we use the semi-honest OT extension protocol from [26] and the
Naor-Pinkas OT [34], then:
Computational complexity: To build BFC or GBFS, each party
needs k · n hash operations. Then the server needs λ public key op-
erations and the client need 2λ public key operations for the Naor-
Pinkas OT, and both parties need m = kn log2 e ≈ 1.44kn hash
operations for the OT extension.
Memory complexity: The client needs to keep a copy of the Bloom
ﬁlter and a copy of the intersection Garbled Bloom ﬁlter which
in total need at most (λ + 1)m bits. This can be optimized to
(λ/2 + 1)m bits because the client can throw away the string re-
ceived when BFC[i] = 0 and leave GBF π
C∩S[i] = N U LL. The
server needs to store the garbled Bloom ﬁlter that is λ · m bits.
Communication complexity: The main data sent in the protocol
is a bit matrix required by the OT extension and the strings sent
by the server in the OT extension. In total 2λ · m bits. All other
communication costs are much less signiﬁcant and can be ignored.
A quick asymptotic costs comparison of Huang’s, De Cristo-

faro’s and our basic protocol is shown in Table 1.

4.4 Security Analysis

Now we sketch the security proof of the basic protocol. The ba-
sic protocol is secure in the semi-honest model. The main theorem
is stated below:

THEOREM 7. Let C, S be two sets from a predeﬁned universe,

f∩ be the set intersection function deﬁned as:

f∩(C, S) = (fC (C, S), fS(C, S)) = (C ∩ S, Λ).

PROOF. (sketch) If the OT m

snd that is guaranteed to exist. SimS obtains SimOT

λ is secure then the simulators for
the sender and receiver are guaranteed to exist, we can use them as
subroutines when constructing our simulators.
Server’s view We start from the case in which the server is cor-
rupted. We construct a simulator SimS that receives the server’s
private input and output and generates the view of the server in the
protocol. Given S, the simulator SimS uniformly chooses its ran-
dom coins rs and generates the garbled Bloom ﬁlter GBFS that
encodes its set S. Then SimS invokes the simulator of the OT
sender SimOT
snd’s
view for the OT protocol. Finally SimS outputs the simulated view:
(S, rs, SimOT
snd(GBFS, Λ)). We then need to show that the view is
indistinguishable from a view in an execution of π∩. A view of the
real protocol execution contains the input S, the random coins and
the messages in the OT protocol. In the simulated view, the input
set S is the same as in the view of a real execution, the outcome of
internal random coins rs is uniformly random thus the distribution
is the same as in a real execution. As the OT protocol is secure,
then the distribution of the view produced by SimOT
snd(GBFS, Λ)
should be indistinguishable from the view in a real execution of
the OT protocol. Thus we conclude the simulated view is indistin-
guishable from a real view.
Client’s view We construct a simulator SimC that is given the
client’s private input C and the output C ∩ S. SimC chooses its
random coins rc. It then generates the Bloom ﬁlter BFC to en-
code its set and the garbled Bloom ﬁlter GBFC∩S from scratch
It then invokes the simulator of the OT re-
using Algorithm 1.
ceiver SimOT
rec with BFC and GBFC∩S. SimC obtains the view
for the OT protocol. Finally SimC outputs the simulated view:
(C, rc, GBFC∩S, SimOT
rec (BFC, GBFC∩S)). The view of a real
protocol execution contains the input set C, the random coins, the
garbled Bloom ﬁlter GBF π
C∩S, and the messages in the OT proto-
col. In the simulated view, the input set C and rc should be indis-
tinguishable from the counter parts in the real view. The garbled
Bloom ﬁlter GBFC∩S is indistinguishable from GBF π
C∩S as we
have shown in Theorem 4 and 6. The rest parts in the views are the
simulated OT messages and the OT messages in the real execution.
As the OT protocol is secure, then they should be indistinguishable.
Thus we conclude the simulated view is indistinguishable from a
real view.

Combine the above, we conclude that:

{SimS (S, fS (C, S)}C,S

{SimC (C, fC (C, S))}C,S

and ﬁnish our proof.

c
≡ {viewπ
c
≡ {viewπ

S(C, S)}C,S

C (C, S)}C,S

5. THE ENHANCED PROTOCOL

In this section, we present a fully secure PSI protocol whose
security holds in the presence of malicious parties. The protocol is
shown in Figure 3. The security model and proof can be found in
the full version [19].

In the basic protocol, the interaction between the two parties is
essentially an oblivious transfer. At the ﬁrst glance, it seems that
we can easily obtain a fully secure protocol by replacing the semi-
honest OT protocol with one that is secure against malicious par-
ties. However, this is not enough. A fully secure OT protocol can
prevent malicious behaviors such as changing input during the pro-
tocol execution but it cannot prevent a malicious client from mount-
ing a full universe attack.

795Server’s input: Set S
Client’s input: Set C
Auxiliary input: the security parameter λ , parameters for BF and GBF n, k = λ, m = 2kn, H = {h0, . . . , hk−1}, a secure block cipher E.

1. The client generates a Bloom ﬁlter BFC . The client then generates m λ-bit random strings, say r0, ...rm−1. The client sends the random strings

to the server.

2. The server generates the garbled Bloom ﬁlter GBFS . The server generates a random key sk for the block cipher E. For 0 ≤ i ≤ m − 1, the

server computes ci = E(sk, ri||GBFS[i]). The server also uses a (m/2, m)-secret sharing scheme to split sk into m shares (t0, ..., tm−1).

3. The server and the client engage in an OT protocol that is secure against malicious parties. The client uses BFC as the selection string and
the server uses as input two sets of strings ci and ti (0 ≤ i ≤ m − 1). As a result of the protocol, if BFC [i] = 1, the client receives ci; if
BFC [i] = 0,the client receives ti.

4. The client recovers sk from the shares it received in the OT. The client creates a garbled Bloom ﬁlter GBFC∩S of size m as follows. For
r
← {0, 1}λ; if BFC [i] = 1, the client decrypts ci and gets di = E−1(sk, ci), checks
0 ≤ i ≤ m − 1 if BFC [i] = 0 then GBFC∩S[i]
whether the ﬁrst λ-bit equals ri that is sent in step 1. If yes then skip the ﬁrst λ bits in di and copy the second λ bits to GBFC∩S [i]. Otherwise
output ⊥ and terminate. Finally, the client queries GBFC∩S with its own set C and outputs C ∩ S.

Figure 3: The Enhanced PSI protocol

In a full universe attack, a malicious client encodes the full uni-
verse of all possible elements in its Bloom ﬁlter and uses it in the
PSI protocol to learn the server’s entire set. A Bloom ﬁlter can eas-
ily represent the full universe by setting all the bits to 1. This is a
special feature of Bloom ﬁlters and it causes a problem when we
try to construct a simulator for the client in the malicious model.
Namely, when the adversary uses the all-one Bloom ﬁlter, the sim-
ulator needs to enumerate all elements in the universe and send
them to the trusted party in the ideal process. Without making any
assumptions, the universe is potentially too large and a polynomial
time algorithm may fail to enumerate all elements.

To prevent the full universe attack, we add a step to make sure
that the client’s Bloom ﬁlter is not all-one. More speciﬁcally, the
server uses a symmetric key block cipher to encrypt strings in its
garbled Bloom ﬁlter before transferring them to the client. It forces
the client to behave honestly by splitting the key into m shares us-
ing a (m/2, m)-secret sharing scheme. The client uses the bit array
in its Bloom ﬁlter as the selection string to receive the intersection
garbled Bloom ﬁlter and the shares of the key. If the bit in the se-
lection string is 0, the client receives a share of the key; if the bit is
1, the client receives an encrypted string in GBFS . The intuition is
that if the client cheats by using an all-one Bloom ﬁlter, it will not
be able to gather enough shares to recover the key, and thus will not
be able to decrypt the encrypted garbled Bloom ﬁlter. In the proto-
col we set m = 2kn in order to make sure that the client’s Bloom
ﬁlter has at least m/2 0 bits to receive enough shares to recover
the key. Since the client has at most n elements and each element
needs to be hashed k times, then the number of 1 bits in BFC will
never exceed kn = m/2, consequently the number of 0 bits will
always be at least m/2. Although in this setting m is not optimal,
the overhead is acceptable given the optimal number of m is about
1.44kn.

The added step will not affect the client’s privacy, but may affect
the correctness of the protocol if a malicious server sends wrong
shares of the key or uses a different key to encrypt its garbled
Bloom ﬁlter. The client cannot detect it because the key is ran-
dom and the strings in the garbled Bloom ﬁlter look random. To
prevent this malicious behavior, we also require the client to send
m λ-bit random strings (r0, ..., rm−1) to the server before the OT.
For each GBFS[i], the server encrypts ri||GBFS [i] (|| means con-
catenation) and sends the ciphertext in the OT. After the transfer,
the client can recover the key and decrypt the received ciphertexts.
If the server is honest, then the client can correctly decrypt using
the key it recovered and ri should present in the decrypted mes-

80

128

192

256

Ours

SHA-1, NIST P-192
curve
SHA-1 (ﬁlter), SHA-
256 (OT), NIST P-256
curve
SHA-1 (ﬁlter), SHA-
384 (OT), NIST P-384
curve
SHA-1 (ﬁlter), SHA-
512 (OT), NIST P-521
curve

De Cristofaro’s

RSA 1024, SHA-1

RSA 3072, SHA-1

Huang’s

1024-bit p, 160-bit q,
SHA-1
3072-bit p, 256-bit q,
SHA-1

RSA 7680, SHA-1

7680-bit p, 384-bit q,
SHA-256

RSA 15360, SHA-1

15360-bit p, 512-bit q,
SHA-256

Table 2: Security parameters and settings

sage. For each garbled Bloom ﬁlter string the client received, the
probability of the server getting away with cheating is 2−λ.
Efﬁciency In [26] a fully secure version of the OT extension pro-
tocol is given. It uses the cut-and-choose approach to ensure a ma-
licious party can cheat with at most 2−Ω(λ) probability. The ma-
jor overhead of the fully secure protocol is introduced by the non-
optimal m and cut-and-choose, which increase the communication
and computation complexity of the semi-honest one by a factor of
1.4λ. Overhead introduced by other parts of our protocol is small.
The additional computational overhead in our protocol includes:
the server needs to perform m encryptions and to use the threshold
secret sharing scheme to split the key, the client needs to perform
m/2 decryptions, to recover the key. The additional communica-
tion overhead in our protocol includes: m · λ bits for sending the
random strings of in step 1.

6.

IMPLEMENTATION AND EVALUATION

6.1 Implementation

We have implemented a prototype of the basic protocol in C.
The source code (and its Java port) is released online1.
It uses
OpenSSL (1.0.1e) for the cryptographic operations. We currently
use keyed SHA-1 to build/query Bloom ﬁlters and garbled Bloom
ﬁlters2. Namely each hi(x) is instantiated as sha1(si||x) mod m,
where si is a unique salt. We implement the semi-honest OT ex-
tension protocol [26] on top of the Naor-Pinkas OT protocol [34].

1http://personal.cis.strath.ac.uk/changyu.dong/PSI/PSI.html
2Cryptographically strong hash functions are not necessary here.
Later we will change to more efﬁcient hash functions e.g. Mur-
murHash [2] that has been used by Apache Hadoop and Cassandra
in their Bloom ﬁlter implementation.

7961800

1600

1400

1200

1000

800

600

400

200

)
c
e
S

(
 
e
m
T

i

0

256

192

128

80

1,024

1,048,576

262,144

65,536

16,384

4,096

Set Size

Security Level

(a) Performance: the pipelined mode

(b) Running time of each step in the pipelined mode

350

300

250

200

150

100

50

)
c
e
S

(
 

e
m
T

i

parallel
pipelined
unencrypted pairwise comparison (best case)
unencrypted pairwise comparison (worst case)

set size=1,048,576

 

1800

1600

1400

1200

1000

800

600

400

200

)
c
e
S

(
 

e
m
T

i

0

256

192

128

80

1,024

4,096

65,536

16,384

Set Size

Security Level

(c) Performance: the parallel mode

1,048,576

262,144

0
 
80

128

192

Security Level

256

(d) A comparison of running time in the two modes

Figure 4: Performance of our basic protocol

The hash functions in the OT extension protocol are instantiated
depending on the security parameters. When hash values need to
be truncated, the truncation follows the steps speciﬁed by the NIST
[14]. We use the NIST elliptic curve groups over Fp [36] for the
public key operations required by the Naor-Pinkas OT protocol. We
use elliptic curve groups because they are much faster than integer
groups at high security levels.

The C prototype has two executables, one for the client and one
for the server. The client and server communicate through TCP.
The prototype can work in two modes: pipelined and parallel. In
the pipelined mode, on each side, the computation is done in a sin-
gle thread, an additional thread transmits data in parallel when pos-
sible. Parallel data transmission enables the server or the client to
start working immediately without waiting for the other party to
complete its computation. The parallel mode extends the pipeline
mode by utilizing all CPU cores and distributing tasks on all cores
evenly. Our test result shows that the parallel mode can improve the
performance signiﬁcantly on multicore systems. This is due to the
fact that the computation in our protocol is dominated by indepen-
dent hashing. Namely, on each side, n independent set elements
each needs to be hashed k times to build the Bloom ﬁlter or the
garbled Bloom ﬁlter, also hashing of m matrix rows are needed in
the OT extension protocol. As the data to be hashed is indepen-

dent, this is a perfect SPMD (single program multiple data) sce-
nario. The program detects the number of cores available, decides
the number of threads, evenly allocates a portion of data to each
thread, and then launch the threads to execute the tasks in paral-
lel. The hash values are then consumed by main threads that run
the protocol. This approach requires only minimal changes to the
program structure. For example, only one line (line 8) needs to be
changed in Algorithm 1. Namely instead of hashing the element,
the algorithm reads from an array a precomputed index number.

6.2 Performance Evaluation

In this section we show the performance evaluation results of our
prototype. All experiments were conducted on two Mac computers.
The server is a Mac Pro with 2 Intel E5645 6-core 2.4GHz CPUs,
32 GB RAM and runs Mac OS X 10.8. The client is a Macbook
Pro laptop with an Intel 2720QM quad-core 2.2 GHz CPU, 16 GB
RAM and runs Mac OS X 10.7. The two computers are connected
by 1000M Ethernet. The security settings of the experiments in this
and the next section are summarized in Table 2. In all experiments
we set BF/GBF parameter k = λ so the false positive probability
of a BF is at most 2−λ, we set m to be the optimal value kn log2 e.
For example, at 80-bit security k = λ = 80, and when n = 220,
m = 120795960. We use randomly generated int sets in the ex-

797❳

❳

❳

Set size

protocol

❳

❳

❳❳

210

212

214

80-bit Security

Huang’s(Java)

Our pipelined (Java)
Our parallel (Java)
De Cristofaro’s (C)
Our pipelined (C)
Our parallel (C)

Huang’s (Java)

Our pipelined (Java)
Our parallel (Java)
De Cristofaro’s (C)
Our pipelined (C)
Our parallel (C)

19
0.693
0.195
0.590
0.275
0.075

32
8.2
1.5
462
4.09
0.741

65
2.34
0.431
2.41
0.863
0.207

157
20.3
3.2
1850
8.94
1.53

216

2049
31.5
6.31
41.3
13.9
2.49

331
7.02
1.42
9.84
3.37
0.642

256-bit Security

733
68.44
10.5
7419
29.8
4.68

4647
313.4
54
29654
113
17.8

218

220

22853
110.6
25
159
54.0
9.49

43156
1298
215
118286
453
74.2

98468†
426
91
641
237
40.9

185570†
5421
1132
473144†
1852
339

)

B
M

(
 
n
o
i
t
p
m
u
s
n
o
c
h
t
d
w
d
n
a
B

i

 

14000

12000

10000

8000

6000

4000

2000

 

0
1024

De Cristofaro
Our
Huang

 

Set size

262144

All time shown in the table are in seconds.

† – estimated running time

Table 3: Performance comparison

periments. We measure the total running time of the protocol. The
measurement starts from the client sending the request and ends
immediately after the client outputting the intersection. The time
includes all operations such as building the Bloom ﬁlter, building
the garbled Bloom ﬁlter, the full OT extension protocol (including
the underlying Naor-Pinkas OT), data transmission, and the client-
side query for obtaining the intersection. We do not, however, in-
clude the time for initialization tasks, e.g. to generate random sets,
to interpret the command line arguments, and to setup sockets.

We ﬁrst show the performance of the prototype working in the
pipelined mode. In the pipelined mode, all computation on each
side is done in a single thread. We vary the set size (n) from 210 to
220 and security parameters (λ and k) from 80 to 256. The result is
shown in Figure 4a. We can see the running time increases almost
linearly in the set size at each security level. And for each increase
in security parameter, the running time increases only by a factor
of approximately 2. We also measured the time for each individual
step of the protocol. In the experiments, we ﬁx the set size (220)
and vary only security levels. The result is shown in Figure 4b. We
can see the protocol running time is dominated by the OT execu-
tion. This suggests that with a more efﬁcient OT protocol, the total
running time can be further reduced.

Then we show the performance of the parallel mode. In the par-
allel mode, we use multiple threads for computation. The result is
shown in Figure 4c. The total running time in the parallel mode is
much less than in the pipelined mode. At 80-bit security, million
elements set intersection can be done in 41 seconds. In the highest
security setting, the same computation can be done in 339 seconds
– that is less than 6 minutes. A comparison of the performance in
the two modes is shown in Figure 4d. The client has 4 cores and
the server has 12 cores, and we can see that the parallel mode is
about 5 times faster than the pipelined mode. This shows that our
protocol can fully take the advantage of the multicore architecture.
We believe the ability to easily scale up to multiple cores is a clear
advantage of our protocol and makes the protocol suitable for large
scale private data processing.

The performance of our protocol can even beat some inefﬁcient
plain algorithms in some settings. For example, Figure 4d shows
the time needed for a single threaded C program to compute the in-
tersection of two unencrypted random sets (n = 220) by pairwisely
comparing the elements. It needs 429 seconds in the best case when
C = S, and needs 844 seconds in the worst case when C ∩ S = ∅.

6.3 Performance Comparison

We compared the performance of our basic protocol against two

(a) Bandwidth Consumption: 80-bit security

x 104

De Cristofaro
Our
Huang

 

4

3.5

3

2.5

2

1.5

1

0.5

)

B
M

(
 
n
o
i
t
p
m
u
s
n
o
c
 
h
t
d
w
d
n
a
B

i

 

0
1024

Set size

262144

(b) Bandwidth Consumption: 256-bit security

Figure 5: Bandwidth Consumption Comparison

other semi-honest PSI protocols. The protocols we compared to
are De Cristofaro’s RSA-OPRF protocol (implemented in C) and
Huang’s Sort-Compare-Shufﬂe with Waksman Network protocol
(implemented in Java). They are previously the fastest PSI pro-
tocols and the code has been optimized by the authors. We test
the two protocols on the same hardware and OSes that we use for
testing ours. De Cristofaro’s C implementation is compiled with
OpenSSL 1.0.1e and GMP 5.1.1 using gcc. The RSA public expo-
nent is 3 in all tests. We run Huang’s Java code using Java 1.7.0_12.
The element bit length in Huang’s protocol is set to 32. As it is un-
fair to compare the performance of Huang’s Java code with our C
code, we ported our C code to Java and measured the performance.
We measured the total running time of the protocols. De Cristo-
faro’s code outputs running time so we use the output directly3.
Huang’s code has no such output, and we measure the running time
of the execution() function in the P rogram class.

The comparison in Table 3 shows that in all settings, both modes
of our protocol are faster than the other two protocols. Both De
Cristofaro’s implementation and Huang’s implementation pipeline
the protocol execution, which is exactly what we do in the pipelined
mode. Therefore the performance of these three can be compared
directly4. The performance of De Cristofaro’s protocol is close to
ours at 80-bit security and is faster than Huang’s. But when the se-

3We exclude the running time of the last step in the protocol. In
this step the client searches the hash values received in the protocol
to ﬁnd the intersection. This step is excluded because it uses an
inefﬁcient pairwise comparison and the authors plan to replace it
with a hashtable search.
4De Cristofaro’s code uses two threads on each side for computa-
tion. But this does not affect the comparison result.

798curity parameter increases to 256-bit, it becomes much slower than
our protocol and Huang’s. This is because De Cristofaro’s protocol
is based mainly on public key operations, while ours and Huang’s
protocols rely on mostly symmetric key operations. Put aside dif-
ferences caused by languages and implementation, our protocol is
faster than Huang’s because it requires the same number of pub-
lic key operations but signiﬁcantly less symmetric key operations.
For example, at 80-bit security with 220 input size, our protocol
requires 0.4 billion symmetric key operations, while Huang’s re-
quires 8.5 billion (1.7 billion non-free gates, each requires 4 sym-
metric key operations to build and another 1 to evaluate).

We skip the test with the biggest input size (220) on De Cristo-
faro’s protocol at 256-bit security because it would take too long.
The running time of De Cristofaro’s protocol is linear in the input
size, our estimation is that it would need 131 hours to ﬁnish. This
estimation is based on the result of test with 218-element sets at
the same security level. The JVM on the client computer ran out
of memory (16 GB) when we testing Huang’s protocol with 220-
element sets at 80-bit security. The test was repeated twice and both
times we got the same error. We could not ﬁnish the test but base
on the test result of input size 218, we estimate the test would need
27 hours. This estimation is somehow far from the time reported
by the authors, that is 6 hours. However the test had been running
for more than 24 hours before the JVM threw the error. Therefore
we believe the estimation is reasonable. We observed excessive
paging activities during the test on the client computer because the
JVM occupied all free memory (14 GB). This may account for the
difference between our estimation and the authors’ measurement.
Because at 256-bit security Huang’s protocol requires even more
memory, we skip the test with 220 input size and estimate the run-
ning time to be 51 hours from test result of input size 218.

We also measured bandwidth consumption of the protocols. As
we couldn’t ﬁnish the tests with the other protocols using 220 input
size, the largest input size we used in the experiment was 218. The
results are shown in Figure 5. As we can see, the bandwidth con-
sumption of De Cristofaro’s and our protocol is almost linear. Our
protocol consumes more bandwidth than De Cristofaro’s protocol
but less than Huang’s protocol.

6.4 Further Parallelization
GPGPUs For many personal computers, a readily available mas-
sive parallel computing device is the graphic cards. Modern GPUs
have hundreds of processing cores and can provide ample com-
putation cycles and high memory bandwidth to massively parallel
applications. The computation in our protocol can be easily paral-
lelized and therefore is an ideal application for GPU acceleration.
We have started implementing the protocol on top of OpenCL [3].
A test on our GPU version of SHA-1 shows that on an ATI Radeon
HD 5770 graphic card, it only takes 37.5 milliseconds to perform 1
million hash operations. This is about 5 times faster than a single
2.4 GHz CPU core.
Extremely Big Data Set & Cloud Computing In practice, to pro-
cess extremely big data set, we have to distribute the task on mul-
tiple computers. New computing paradigms such as cloud comput-
ing make it possible to execute such distributed tasks “on demand”.
Our protocol can be easily deployed on cloud platforms. Here we
show how to do it with the semi-honest protocol. The fully se-
cure protocol case is similar. From a high level point of view, the
client and the server throw their elements into bins using an hash
function. Each side has b bins and each bin contains about ⌈ n
b ⌉
elements. Then they build Bloom ﬁlters and garbled Bloom ﬁlters
for each bin. The parameter k is still determined by the desired
false positive probability, the parameter m is determined by k and

input
set

map

<bin,(element,[index])>

shufﬂe

reduce

GBFbin0

GBFbin1

OT

GBFbin2

Figure 6: MapReduce on the server side

the bin size. The ﬁlters are associated with the bin number. Then
for each 0 ≤ i < b, the server uses OT to transfer the garbled
Bloom ﬁlter for bin i to the client, who uses its Bloom ﬁlter for
bin i as the selection string. The client then queries all elements
in its bin i against the received garbled Bloom ﬁlter and adds any
positive elements into the result set. In the end, the client has the
intersection. Conceptually, this splits a big set into b smaller sets
that each can be handled by a single node. It is correct because
the two parties use the same hash function so an element thrown
by the server into bin i will also be threw by the client into bin i.
The idea can be implemented using the MapReduce programming
model [18] easily. For example, ﬁgure 6 depicts the MapReduce
procedure of the ﬁrst step on the server side with 3 bins: the map
function takes a portion of the input set and maps an element into a
key-value pair such that the key is the bin number and the value is
a tuple consists of the element and k index numbers. The MapRe-
duce framework shufﬂes and groups together the values returned
by the map function that have the same key. The reduce function
generates a garbled Bloom ﬁlter of a certain bin and outputs it for
OT. We are currently experimenting with Hadoop [1] to implement
the protocol in MapReduce.

7. CONCLUSION AND FUTURE WORK

In this paper we presented a highly efﬁcient and scalable PSI
protocol based on oblivious Bloom intersection. The protocol de-
pends mostly on efﬁcient symmetric key operations and the op-
erations can be parallelized easily. We presented two variants of
the protocol: the basic one is secure in the semi-honest model and
the enhanced one is secure in the malicious model. The perfor-
mance evaluation and comparison results show that our protocol
is orders of magnitude faster than the previously fastest protocols.
The results also show that our protocol can fully utilize the parallel
processing capability provided by the multicore architecture. The
efﬁciency and scalability make our protocol suitable for large scale
privacy preserving data processing.

As discussed in Section 6.4, we are in the process of prototyp-
ing the protocol on GPGPUs and MapReduce. The preliminary
results of this work is encouraging. We hope more parallelization
options could enable more applications in various computing envi-
ronments.

In the ﬁeld of cryptographic protocols, we have seen many ex-
amples that a new protocol improves performance of previous work
by using a better algorithm. It is different in this work: the perfor-
mance gain comes mainly from a better data structure. We would
like to continue our research along this line. Namely we will inves-
tigate, adapt and design better data structures, so that they can be
used in the design of more efﬁcient cryptographic protocols.

799Acknowledgements

Changyu Dong is supported by a science faculty starter grant from
the University of Strathclyde. Zikai Wen is supported by an un-
dergraduate research internship from the University of Strathclyde.
We thank Emiliano De Cristofaro and Yan Huang for sharing their
PSI source code. We also thank the anonymous reviewers for their
helpful comments.

8. REFERENCES
[1] Hadoop. http://hadoop.apache.org/.
[2] Murmurhash. https://code.google.com/p/smhasher/.
[3] Opencl. http://www.khronos.org/opencl/.
[4] C. C. Aggarwal and P. S. Yu, editors. Privacy-Preserving

Data Mining - Models and Algorithms, volume 34 of
Advances in Database Systems. Springer, 2008.

[5] G. Ateniese, E. De Cristofaro, and G. Tsudik. (If) size

matters: Size-hiding private set intersection. In Public Key
Cryptography, pages 156–173, 2011.

[6] P. Baldi, R. Baronio, E. De Cristofaro, P. Gasti, and

G. Tsudik. Countering gattaca: efﬁcient and secure testing of
fully-sequenced human genomes. In ACM Conference on
Computer and Communications Security, pages 691–702,
2011.

[7] D. Beaver. Correlated pseudorandomness and the complexity

of private computations. In STOC, pages 479–488, 1996.

[8] M. Bellare and P. Rogaway. Random oracles are practical: A

paradigm for designing efﬁcient protocols. In ACM
Conference on Computer and Communications Security,
pages 62–73, 1993.

[9] B. H. Bloom. Space/time trade-offs in hash coding with
allowable errors. Commun. ACM, 13(7):422–426, 1970.
[10] P. Bose, H. Guo, E. Kranakis, A. Maheshwari, P. Morin,

J. Morrison, M. H. M. Smid, and Y. Tang. On the
false-positive rate of bloom ﬁlters. Inf. Process. Lett.,
108(4):210–213, 2008.

[11] E. Bursztein, M. Hamburg, J. Lagarenne, and D. Boneh.
Openconﬂict: Preventing real time map hacks in online
games. In IEEE Symposium on Security and Privacy, pages
506–520, 2011.

[12] J. Camenisch and G. M. Zaverucha. Private intersection of
certiﬁed sets. In Financial Cryptography, pages 108–127,
2009.

[13] D. Dachman-Soled, T. Malkin, M. Raykova, and M. Yung.

Efﬁcient robust private set intersection. In ACNS, pages
125–142, 2009.

[14] Q. Dang. SP 800-107 (rev. 1). recommendation for

applications using approved hash algorithms. Technical
report, Gaithersburg, MD, United States, 2012.

[15] E. De Cristofaro, J. Kim, and G. Tsudik. Linear-complexity
private set intersection protocols secure in malicious model.
In ASIACRYPT, pages 213–231, 2010.

[16] E. De Cristofaro and G. Tsudik. Practical private set

intersection protocols with linear complexity. In Financial
Cryptography, pages 143–159, 2010.

[17] E. De Cristofaro and G. Tsudik. Experimenting with fast

private set intersection. In TRUST, pages 55–73, 2012.
[18] J. Dean and S. Ghemawat. Mapreduce: Simpliﬁed data

processing on large clusters. In OSDI, pages 137–150, 2004.
[19] C. Dong, L. Chen, and Z. Wen. When private set intersection

meets big data: An efﬁcient and scalable protocol.
Cryptology ePrint Archive, Report 2013/515, 2013.

[20] S. Even, O. Goldreich, and A. Lempel. A randomized

protocol for signing contracts. Commun. ACM,
28(6):637–647, 1985.

[21] M. J. Freedman, K. Nissim, and B. Pinkas. Efﬁcient private
matching and set intersection. In EUROCRYPT, pages 1–19,
2004.

[22] O. Goldreich. The Foundations of Cryptography - Volume 2,

Basic Applications. Cambridge University Press, 2004.

[23] C. Hazay and Y. Lindell. Efﬁcient protocols for set

intersection and pattern matching with security against
malicious and covert adversaries. In TCC, pages 155–175,
2008.

[24] C. Hazay and K. Nissim. Efﬁcient set operations in the

presence of malicious adversaries. In Public Key
Cryptography, pages 312–331, 2010.

[25] Y. Huang, D. Evans, and J. Katz. Private set intersection: Are

garbled circuits better than custom protocols? In NDSS,
2012.

[26] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank. Extending

oblivious transfers efﬁciently. In CRYPTO, pages 145–161,
2003.

[27] S. Jarecki and X. Liu. Efﬁcient oblivious pseudorandom

function with applications to adaptive OT and secure
computation of set intersection. In TCC, pages 577–594,
2009.

[28] S. Jarecki and X. Liu. Fast secure computation of set

intersection. In SCN, pages 418–435, 2010.

[29] F. Kerschbaum. Outsourced private set intersection using

homomorphic encryption. In ASIACCS, pages 85–86, 2012.

[30] L. Kissner and D. X. Song. Privacy-preserving set

operations. In CRYPTO, pages 241–257, 2005.

[31] D. Many, M. Burkhart, and X. Dimitropoulos. Fast private
set operations with sepia. Technical Report 345, Mar 2012.
[32] G. Mezzour, A. Perrig, V. D. Gligor, and P. Papadimitratos.

Privacy-preserving relationship path discovery in social
networks. In CANS, pages 189–208, 2009.

[33] S. Nagaraja, P. Mittal, C.-Y. Hong, M. Caesar, and

N. Borisov. Botgrep: Finding P2P bots with structured graph
analysis. In USENIX Security Symposium, pages 95–110,
2010.

[34] M. Naor and B. Pinkas. Efﬁcient oblivious transfer protocols.

In SODA, pages 448–457, 2001.

[35] A. Narayanan, N. Thiagarajan, M. Lakhani, M. Hamburg,

and D. Boneh. Location privacy via private proximity testing.
In NDSS, 2011.

[36] NIST. Recommended elliptic curves for federal government

use, 1999.

[37] O. Papapetrou, W. Siberski, and W. Nejdl. Cardinality

estimation and dynamic length adaptation for bloom ﬁlters.
Distributed and Parallel Databases, 28(2-3):119–156, 2010.
[38] M. O. Rabin. How to exchange secrets by oblivious transfer.

Technical Report TR-81, Harvard Aiken Computation
Laboratory, 1981.

[39] B. Schneier. Applied cryptography - protocols, algorithms,

and source code in C (2. ed.). Wiley, 1996.

[40] A. Shamir. How to share a secret. Commun. ACM,

22(11):612–613, 1979.

800