S3: A Symbolic String Solver for Vulnerability Detection

in Web Applications

Minh-Thai Trinh

trinhmt@comp.nus.edu.sg

Duc-Hiep Chu

hiepcd@comp.nus.edu.sg
National University of Singapore

Joxan Jaffar

joxan@comp.nus.edu.sg

ABSTRACT
Motivated by the vulnerability analysis of web programs which
work on string inputs, we present S3, a new symbolic string solver.
Our solver employs a new algorithm for a constraint language that
is expressive enough for widespread applicability. Speciﬁcally, our
language covers all the main string operations, such as those in
JavaScript. The algorithm ﬁrst makes use of a symbolic represen-
tation so that membership in a set deﬁned by a regular expression
can be encoded as string equations. Secondly, there is a constraint-
based generation of instances from these symbolic expressions so
that the total number of instances can be limited. We evaluate S3
on a well-known set of practical benchmarks, demonstrating both
its robustness (more deﬁnitive answers) and its efﬁciency (about 20
times faster) against the state-of-the-art.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Veriﬁcation; D.2.5 [Software
Engineering]: Testing and Debugging
General Terms
Security, Reliability, Veriﬁcation
Keywords
String Analysis; String Constraint Solver; Web Applications

1.

INTRODUCTION

Web applications nowadays provide critical services over the In-
ternet and frequently handle sensitive data. Unfortunately, the de-
velopment is error prone, resulting in applications that are vulnera-
ble to attacks by malicious users. The global accessibility of critical
web applications make this an extremely serious problem.

According to the Open Web Application Security Project, or
OWASP for short [26], the most serious web application vulner-
abilities include: (#1) Injection ﬂaws (such as SQL injection) and
(#3) Cross Site Scripting (XSS) ﬂaws. These two vulnerabilities
occur mainly due to inadequate sanitization and inappropriate use
of input strings provided by users.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660372.

How Important is Symbolic String Solving?
To explain why we need string solving, let us look at dynamic anal-
ysis which involves testing an application as a closed entity with a
set of concrete inputs. Its main disadvantage is of course that it
is not a complete method. For example, some program paths may
only be executed if certain inputs are passed as parameters to the
application, but it is very unlikely that a dynamic analyzer can ex-
haustively test an application with all possible inputs. For web ap-
plications, the problem is even more severe since dynamic analysis
needs to take into account not only the value space (i.e., how the
execution of control ﬂow paths depends on input values), but also
an application’s event space (i.e., the possible sequences of user-
interface actions). As a result, there is in general an impractical
number of execution paths to systematically explore, leading to the
“low code coverage” issue of dynamic analysis.

A standard approach to have good or complete coverage is static
analysis. However, the problem here is the existence of false posi-
tives, arising from an over-approximation of the program’s behav-
ior. Recent works to avoid false positives, but still preserve high
code coverage, are based on dynamic symbolic execution (DSE).
Some examples are [28, 4, 5, 23, 12, 30, 15, 16, 17, 14, 29, 9, 8, 24,
35, 21]. These approaches employ both concrete and symbolic ex-
ecution to automatically and systematically generate tests in order
to expose vulnerabilities in web applications. DSE for automated
test generation involves instrumenting and concolically running a
program while collecting path constraints on the inputs. Then it at-
tempts to derive new inputs – using an SMT (Satisﬁability Modulo
Theories) solver – with the hope to steer next executions toward
new program paths. For vulnerability detection, DSE combines the
derived path constraints with the speciﬁcations for attacks, often
given by the security experts, to create queries for the SMT solver.

Code Coverage
False Positives
Executable
Paths (EPs)

Dynamic Analysis
Potentially Low
Low
Unlikely to cover
all EPs

DSE
High
Low
Likely to cover all
EPs

Table 1: DSE as a More Effective Paradigm

In fact, there is a strong connection between an effective vulner-
ability detection framework and symbolic string solving. As shown
in Table 1, DSE achieves higher code coverage. However, because
not all path executed by DSE are guaranteed to be executable, to
avoid false positives we must be able to decide if a (symbolic) path
constraint is satisﬁable or not. Thus a powerful SMT solver, ca-
pable of handling symbolic string variables, is the key to achieve
efﬁcient analyses with high code coverage and low false positives.

12321
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

25

26
27
28
29

...
<html>
...
<script>
function validateEmail(form) {

var email = form["email"].value;
var index = email.indexOf("@");
var local = email.substr(0, index);
var domain = email.substr(index+1);

if (domain.equals("nus.edu.sg")){

var re = new RegExp("^[a-zA-Z][0-9]*$");
var test1 = re.test(local);
var test2 = local.length == 8;
return test1 && test2;

}
else if (domain.equals("comp.nus.edu.sg"))

return local.length >= 4;

else

return false;

}
</script>
...
<form name="loginForm" action="/Login"

onsubmit="return validateEmail(this);">

Email: <input type="text" name="email"

size="64" />

<input type="submit" value="Login" />

</form>
...
</html>

Figure 1: An Example of Email Address Validation

To illustrate more clearly how constraint solvers can be helpful in
securing web applications, in Fig. 1, we present a JavaScript func-
tion which is used to validate input email addresses. The user ﬁlls
the client-side form, by providing an email address to the HTML
input element with name "email" (and a password, removed for
simplicity). When the Login button is clicked, the browser in-
vokes the JavaScript validating function validateEmail, which
is assigned to the submit event of the form. This function ﬁrst
fetches the email address supplied by the user from the correspond-
ing form ﬁeld and then checks if the email address is valid. Each
student of our department has two email accounts, one from NUS
(nus.edu.sg), the other from SoC (comp.nus.edu.sg). The
web page hence accepts both of these two domains. However, these
two types of accounts have different formats. While the local
part of the former is constructed by one alphabetic characters, fol-
lowed by seven numeric ones, the latter’s simply requires at least
four characters.

The question is whether this web page is vulnerable to an XSS
attack, or to an SQL injection. More speciﬁcally, can the follow-
ing PHP code, with an appropriate instantiation for string variable
$eml, be executed on the server side, leading to an attack:
$eml = $_POST['email'];
$pwd = $_POST['password'];
$stm="SELECT ... where email='$eml' and password='$pwd'";
$result = mysql_query($stm);

The answer is yes for both of the questions. Now, let us explain
the way DSE detects possible vulnerabilities, in comparison with
typical dynamic analyses. Since a dynamic analysis is essentially
black-box testing, it has no knowledge about the JavaScript code.
Thus, it is possible that the dynamic analyzer does not test with
email addresses whose domain is comp.nus.edu.sg, and sub-
sequently, cannot detect SQL injection and XSS vulnerabilities. In
contrast, DSE, which can be seen as white-box testing, enables us
to attempt all execution paths by generating three path constraints,

corresponding to the three program paths of the validateEmail
function.

After symbolically executing the program, DSE frameworks such
as [28] will combine its results with the speciﬁcations for attacks,
given by the security experts, to create queries for the constraint
solver. The speciﬁcations, often come in form of assertions, are
some (regular) grammars encoding a set of strings that would con-
stitute an attack against a particular sink. If the constraint solver
ﬁnds a solution to a query, then this represents an attack that can
reach the critical sink and exploit a code injection vulnerability. For
example, with the speciﬁcation to assert if the input email address
contains ' OR 1=1--, we can in fact generate the input

' OR 1=1--@comp.nus.edu.sg

that leads to an SQL injection. Similarly, a speciﬁcation for an
XSS attack <script>alert('Test')</script> would help us
to generate the input email address

<script>alert('Test')</script>@comp.nus.edu.sg

that can be exploited by attackers.

In summary for this subsection, DSE, presently the state-of-the-
art in vulnerability detection, is intimately tied to being able to pro-
vide deﬁnitive answers for the derived constraint queries. In the
case of JavaScript and web applications, since the constraints of-
ten concern string variables, symbolic string solving is thus the key
to detect vulnerabilities in this class of applications. As the en-
countered string constraints may be in an undecidable class, it is
important to have a solver which returns a deﬁnitive answer often
and in a timely manner.

We next describe the main contribution of this paper, a new con-
straint solver S3, which stands for Symbolic String Solver. Our
solver makes use of Z3 [11], in order to leverage the recent ad-
vances in modern SMT solvers.
What Language Do We Need?
We ﬁrst argue that a pure string language does not sufﬁce to analyze
web applications. This is due to the fact that non-string operations
(e.g., boolean, arithmetic constraints) are also widely used in web
applications. Moreover, their use is often intertwined with string
operations, such as in the case of string length — a string-to-integer
constraint. Reasoning about strings and non-strings simultaneously
is thus necessary. In other words, we need to deal with a multi-
sorted theory which includes, at least, strings and integers.

To amplify this point, let us now state some statistics from a com-
prehensive study of practical JavaScript applications [28]. Con-
straints arising from the applications have an average (per bench-
mark query) of 63 JavaScript string operations, while the remaining
are boolean, logical and arithmetic constraints. The largest fraction
are for operations like indexOf, length (78%). A signiﬁcant
fraction of the operations, including substring (5%), replace
(8%), and split, match (1%). Of the match, split and
replace operations, 31% are based on regular expressions. Op-
erations such as replace and split give rise to new strings
from the original ones, thereby giving rise to constraints involving
multiple string variables.

To summarize, constraints of interest are either non-strings (e.g.,
bool-sort, int-sort and particularly length constraints) or strings such
as: string equations, membership predicates and high-level string
operations, which are over multiple string variables. It is folklore
that query with just basic string equations along with length con-
straints on the string variables is extremely hard to solve (its decid-
ability is open). Therefore, the validation of any approach can only
realistically be done empirically.

1233S3: A Robust and Incremental String Solver
Although there exist solvers that can reason about both string and
non-string constraints (e.g., [28, 6, 27, 39]), they depend on strings
being bounded in length. Unbounded regular expressions, which
can be constructed using Kleene star operation, are not supported
Thus the supported high-level operations are only in bounded forms.
For example, instead of fully supporting replace function, which
could mean replacement of all occurrences. existing tools support
an operation to replace a ﬁxed number of occurrences in a string.

It may be argued that certain bounds sufﬁce for a class of appli-
cations. There is a more important reason why the bound depen-
dency is bad: the algorithms that rely on the bounded reasoning
are highly combinatorial in approach. In other words, the problem
at hand is broken down into cases, the number of which is often a
large combinatorial combination arising from some given bounds.
Finally, we mention [1], where there is a real requirement for rea-
soning about unbounded strings. In verifying client-side input val-
idation functions, a bounded string solver can only ﬁnd policy vio-
lations but it cannot prove the conformance to a given policy. There
are certainly some solvers [19, 12, 36, 37] that can reason about un-
bounded strings. However, their key weakness is that they cannot
handle non-string constraints, particularly length constraints. As
shown in the statistics above, missing length constraints (whose ap-
pearance is frequent) will lead to many false positives. This clearly
is not acceptable.

With regard to all the arguments above, we now conclude this

Section with three important features of S3.

First, S3 is expressive (Section 2). Speciﬁcally, it is the ﬁrst
to handle unbounded regular expressions in the presence of length
constraints, and express precisely high-level string operations, which
ultimately enables a more accurate string analysis.

Second, S3 is robust. This means that S3 is able to provide
deﬁnitive answers to a new level, far beyond the state-of-the-art.
This in turn means we can detect more vulnerabilities and more
bugs. We demonstrate in Section 6 with two case studies:

• The ﬁrst compares with Kaluza – the core of Kudzu [28] – a
JavaScript symbolic execution framework. We show that S3
is several times faster, and helps detect many more paths that
reach the critical sink, that is, paths that are vulnerable.

• The second compares with Z3-str [39]. We show S3 reasons
about length constraints much more effectively than Z3-str.
This leads to a large increase in applicability to web pro-
grams, because these kind of constraints are widely used.

Third, S3 is efﬁcient, and one key reason is that it is incremen-
tal. Our algorithm for string theory is designed in an incremental
fashion driven by the try-and-backtrack procedure of the Z3 core
(Section 4), so that given a set of input constraints, we perform
incremental reduction for string variables until the variables are
bounded with constant strings/characters. Another technical chal-
lenge is how to reason, effectively and efﬁciently, about the Kleene
star and high-level operations such as replace (in its most gen-
eral usage), of which the semantics are by nature recursively de-
ﬁned. Section 5 introduces the gist of our proposal, the encodings
using recursively-deﬁned functions, on which we can incrementally
reason: by lazily unfolding them.
2. OUR CONSTRAINT LANGUAGE

We introduce the constraint language of our solver in Fig. 2. For
simplicity, we only list three primitive types: int, bool and string1.
The input formula can be of the following forms:
1Z3 supports more primitive types [11].

Assertion
Fml:bool

Term:bool

Term:int

Term:str

L:str list

true
false
contains((Term:str), (Term:str))

(Term:bool) = (Term:bool)
(Term:int) {<,≤, =,≥, >} (Term:int)
(Term:str) = (Term:str)
(Term:str) ∈ (Term:regexpr)
¬ (Fml:bool)
(Fml:bool) {∧,∨,⇒} (Fml:bool)

::= assert ((Fml:bool))
::= (Term:bool)
|
|
|
|
|
|
::= (Var:bool)
|
|
|
::= (Var:int)
|
Number
(Term:int) {+,−,×,÷} (Term:int)
|
|
length((Term:str))
|
indexOf ((Term:str), (Term:str))
|
search((Term:str), (Term:regexpr))
|
test((Term:regexpr), (Term:str))
::= ConstString
|
|
|
|
|
|
::= match((Term:str), (Term:regexpr))
|
|
|
|
|

(Term:regexpr)(cid:63)
(Term:regexpr) · (Term:regexpr)
(Term:regexpr) + (Term:regexpr)

split((Term:str), (Term:regexpr))
exec((Term:regexpr), (Term:str))

(Var:str)
(Term:str) · (Term:str)
concat((Term:str), (Term:str))
substring((T:str), (T:int), (T:int))
replaceN((T:str),(T:regexpr),(T:str),(T:int))
replaceAll((T:str), (T:regexpr), (T:str))

Term:regexpr::= ConstString

Figure 2: The Grammar of Our Input Constraint Language

• a boolean expression;
• a comparison operation between two integer or boolean expres-
sions;
• an equation between two string expressions. S3 also supports
other common string operations. We list here only important ones;
• a membership predicate between a string expression and a regu-
lar expression, where an expression can either be a string constant,
a variable or their concatenation2, and regular expressions are con-
structed from string constants using concatenation (·), union (+)
and Kleene star ((cid:63));
• a composite formula constructed using negation and binary con-
nectives, including ∧, ∨, ⇒.

Z3-str [39] and Kaluza [28] are important existing solvers that
can support both string and non-string operations, especially the
length constraint. Compared to the constraint syntax of Z3-str, ours
can be viewed as an extension with regular expressions, member-
ship predicates, and high-level string operations that often work on
regular expressions such as search, replaceAll3, match, split, test,
exec. Our constraint language is also slightly more expressive than
Kaluza’s since we handle above string operations in its original se-
mantics — unbounded.
2We use x · y as a shorter form for concat(x, y).
3This operation is used to replace all occurrences.

1234A JavaScript Program

function validateFields(p1,p2) {

var re1 = /^(ab)*$/;
var re2 = /^(bc)*$/;
var t1 = re1.test(p1);
var t2 = re2.test(p2);
var t3 = p2.length > 0;
return (t1 && t2 && t3)

}

Generated Constraints

p1 ∈ (“ab”)(cid:63) ∧
p2 ∈ (“bc”)(cid:63) ∧
length(p2) > 0 ∧
res = p1 · p2 ∧
nM = “ababababababcc” ∧
res = nM

Our Internal Representation
p1 = star(“ab”,n1) ∧
p2 = star(“bc”,n2) ∧
length(p2) > 0 ∧
res = p1 · p2 ∧
nM = “ababababababcc” ∧
res = nM

Figure 3: From a JavaScript Program to the Generated Constraints

In addition, we note that our constraint language, which is nec-
essary to reason about high-level string operations in scripting lan-
guages, is beyond the class of context free languages. To illustrate,
let us look at the following constraints, in which x can be of any
string in the context-sensitive language { an·bn·cn | n≥0 }:

x = y · z · t ∧ y ∈ a(cid:63) ∧ z ∈ b(cid:63) ∧ t ∈ c(cid:63)∧

length(y)=length(z) ∧ length(z)=length(t)

Therefore, existing solvers, which only approximate strings us-
ing context free grammars, are not able to reason about the con-
straints addressed by this paper.

Finally, though it is not shown in Fig. 2, S3 is able to accom-
modate most regular expression features in JavaScript via a pre-
processing step as done in Kudzu [28]. Examples are (possibly
negated) character classes, escaped sequences, repetition operators
({n}/?/(cid:63)/+/) and sub-match extraction using capturing parentheses.

3. MOTIVATING EXAMPLES

In this Section, we present two simpliﬁed examples to position

our work against the state-of-the-art.

In Fig. 3 we start with an example of a regular-expression-based
input validation function. The ﬁrst column is the JavaScript func-
tion used to validate the two input ﬁelds, namely p1 and p2. This
function ensures that p2 is not an empty string and p1 and p2 must
belong to the regular expressions re1 and re2, respectively.

Now we want to prove that, given the inputs which have passed
the validation function, the output res, that is constructed by con-
catenating p1 with p2, is different from a speciﬁed bad string
nM = “ababababababcc”. Ultimately, the above question is reduced
to the problem of deciding the satisﬁability of the generated con-
straint formula, presented in the second column of Fig. 3. The proof
succeeds if the formula is unsatisﬁable4.
This requires reasoning about string equation res=p1·p2, mem-
bership predicates p1 ∈ (“ab”)(cid:63) and p2 ∈ (“bc”)(cid:63), and length
constraint length(p2) > 0.
In short, it becomes a complicated
problem involving strings, non-strings and their combinations (e.g.,
length constraints). Now, let us discuss how existing solvers would
deal with this particular problem.

HAMPI [22], and other solvers [10, 31, 20, 34, 2, 38, 19, 32, 13,
18], which work in the string domain only, cannot handle this ex-
ample. Since they only support string operations, they are not able
to handle non-string constraints, and particularly length constraints
that are related to both string and non-string domain and cannot be
captured in each individual one.

On the other hand, the solvers Kaluza [28], [6] and Z3-str [39]
are in the same category as ours, and can reason about strings and
non-strings simultaneously. Since [6] is similar to Kaluza in many
ways, we will just focus on Kaluza here. Kaluza is the string solver

4Otherwise, the solver should return satisfying assignments, repre-
senting a potential bug/vulnerability of the system.

used in a JavaScript dynamic test generation framework [28]. To
support a wider range of constraint types including integer, boolean
and string, it extends both STP [22] and HAMPI.

One major drawback of Kaluza is that it requires the lengths of
string variables to be known prior to being able to encode them and
query the underlying SMT solvers. In particular, before solving for
string constraints, Kaluza ﬁnds a set of satisfying solutions for each
string length. For each possible length, it encodes each string vari-
able as an array of bits and then queries a bit-vector solver. Kaluza
is unable to reuse the encodings and the result of bit-vector solver
in previous calls, which induces the overall high cost of repetitive
encoding and querying external solvers.

For the example at hand in Fig. 3, Kaluza ﬁrst needs to come
up with a set of satisfying solutions for the lengths of p1 and p2,
each denoted by a pair (cid:104)l1; l2(cid:105), where l1 is the length of p1 and l2
is the length of p2. In this case, the set of satisfying solutions for
the lengths is {(cid:104)0; 12(cid:105),(cid:104)2; 10(cid:105),(cid:104)4; 8(cid:105),(cid:104)6; 6(cid:105),(cid:104)8; 4(cid:105),(cid:104)10; 2(cid:105)}. For
each possible length solution, Kaluza encodes the string variables,
and then queries the external bit-vector solver, before ﬁnding out
that the original set of constraints is unsatisﬁable. Overall, Kaluza
needs to encode and query bit-vector solver 6 times.

Let us not have the impression that, in general, the number of
satisfying solutions for the string lengths should be of this linear
complexity. In fact, practical applications involve many string vari-
ables, Kaluza approach, i.e., generate-and-test, would easily suffer
from a combinatorial explosion.

Z3-str [39] cannot handle regular expressions, thus also cannot
handle this example. However, it can be considered the ﬁrst SMT-
based string solver. Instead of relying on other theories, it builds a
string theory for itself and allows this string theory to be plugged
into a modern and powerful solver – Z3 [11]. Thus an important
contribution of Z3-str is that string and non-string constraints are
now solved simultaneously, in an incremental manner.

Inspired by Z3-str’s design, our target is to build a string theory
that can interact with other theories via Z3. Nevertheless, we want
to support a powerful input language, which is especially demanded
for testing and analysis of practical web applications.

There are two key technical challenges: (1) how to incrementally
handle the Kleene star, which is the heart of the issue in reasoning
about regular expressions; (2) how to incrementally handle high-
level string operation such as replace, whose semantics is most
naturally deﬁned by recursive rules. Our solution therefore is to
employ, in our string theory, recursively deﬁned functions whose
semantics will be lazily unfolded during the process of incremen-
tal solving. Such approach resembles the constrain-and-generate
technique (to contrast with generate-and-test) in the literature of
constraint solving.

We elaborate later with a technical description in Section 5. But
now let us give some intuitions on how we approach this exam-
ple. Internally, we represent membership of regular expression as
equation involving a symbolic representation of the Kleene star. In

1235particular, p1∈(“ab”)(cid:63) is represented as p1=star(“ab”,n1) and
similarly p2∈(“bc”)(cid:63) is represented as p2=star(“bc”,n2). By
rewriting, we would derive the following equation:
star(“ab”,n1) · star(“bc”,n2) = “ababababababcc”
Since the length of p2 is positive and the RHS is a constant
string, this would force the unfolding of expression star(“bc”,n2)
to star(“bc”,n2-1) · “bc”. A conﬂict is then derived since the
LHS string ends with “bc” while the RHS string ends with “cc”.
Our system then can conclude that the input formula is UNSAT.

x = x1 · x2 ∧ z = y · z3 ∧ y = z1 · z2 ∧ z2 = “_” ∧
l1 = length(x1) ∧ l2 = length(z1) ∧ l1 = l2 + 1 ∧
x = z ∧ indexOf (y, “a”) = 3 ∧ indexOf (x1, “a”) = 4

Figure 4: A Frequent Constraint Pattern

Now let us dissect Z3-str more carefully. Fig. 4 presents an input
example for Z3-str, a pattern which is commonly found in many
benchmarks extracted from [28]’s comprehensive set of JavaScript
applications (e.g. big2). Starting with the fact that z2 is a constant
string of one character, Z3-str is able to deduce that z2 is of length
1. This constraint will be fed into the arithmetic theory. Similarly,
the arithmetic theory would receive the information that y’s length
is the sum of z1’s length and z2’s length. Since, from the input, the
length of x1 equals to the length of z1 plus 1, the arithmetic theory
can deduce that x1 and y are of the same length. However, this
information will never be passed back to the string theory.

As discussed in [39], the current design of Z3 enforces that the
plug-in theory, namely Z3-str, to be disjoint from Z3’s arithmetic
theory. Being a plug-in, however, means there is supervisory con-
trol over Z3-str which can feed length information to the arithmetic
theory so that early conﬂicts can be detected and exploited. But,
importantly, partial information derived by the arithmetic theory
will not be fed back to Z3-str. This is the source of Z3-str’s inefﬁ-
ciency in many cases.

Returning to the example, if the information that x1 and y are
of the same length is propagated back to the string theory, together
with the fact that x1 and y are preﬁxes of the two equal strings x
and z, our string theory can derive that x1 and y are equal, there-
fore proceed the search much more efﬁciently. In Section 4.2, we
discuss our new design in order to overcome this drawback, there-
fore even when restricted to the same input language as of Z3-str,
our tool, S3, does advance the concept of incremental solving to
the next level.

4. DESIGN OF S3

Here we present the design of S3. This design is inspired by
Z3-str [39], and thus inherits its two main advantages. First, we
support the primitive type of string so that there is no need to con-
vert strings to other representations, e.g., bit-vectors. As a result,
we can support string variables whose lengths can be unknown, es-
pecially in the context of static analysis. Second, we leverage the
power of Z3 in dealing with multiple theories, and this ultimately
leads to the capability of reasoning on string and non-string con-
straints simultaneously and efﬁciently. We ﬁrst give an overview
of Z3-str, focusing on how it interacts with the core of Z3. Later
we describe our design of S3, along with the improvement of the
corresponding component Z3-str-star over Z3-str.
4.1 Overview of Z3-str

Z3-str acts as a plug-in string theory for a SMT solver Z3 [11].
The architecture of Z3 is shown in the shaded box of Fig. 5. Its

Figure 5: The Design of S3

the congru-
core component consists of the following modules:
ence closure engine, a SAT solver-based DPLL layer, and several
built-in theory solvers, such as integer linear arithmetic, bit-vectors,
etc. The congruence closure engine can detect equivalent terms
and then classify them into different equivalence classes, which are
shared among all built-in theory solvers. The SAT-based DPLL
layer is responsible for handling the boolean structure of the input
formula.

assert ((e1 ∨ e2) ∧ e3 ∧ e4)

e1 : x = “abc” · m e2 : x = “ef gh”
e3 : y = “ef g” · n

e4 : x = y

Consider the assertion above. The core component cannot inter-
pret the string operations; instead it treats them as four independent
boolean variables (e1, e2, e3 and e4) and tries to assign boolean
values to them. We now walk through the process of how Z3’s core
component and the string theory solver interact.

Fact added

Eq-class

1 y=“ef g”·n {y,“ef g”·n}
{x,y}
2 x=y
{y,“ef g”·n}
{x,“abc”·m,
y,“ef g”·n}

3 x=“abc”·m

4 x=“ef gh”

{x,“ef gh”,
y,“ef g”·n}

Reduction/Action

• conﬂict detected
• backtrack and remove facts
• try another option for e1
“ef gh”=“ef g”·n ⇒ n=“h”

SAT solution: x = “ef gh”, y = “ef gh”, n = “h”

Table 2: How Z3-str Interacts with Z3 and Its Backtracking

In Table 2, initially there is no fact. The core starts by setting
e3 and e4 to true and reaches step 3. Without loss of generality,
assume the core component ﬁrst tries true for e1. Beware that the
core can detect functionally equivalent terms, based on the theory

ConstraintsS3RegexReductionZ3SAT and a possible modelUNSATCongruence closure coreSAT solverString theory plug-inZ3-str-starBuilt-in theory solvers:-arithmetic, …1236of uninterpreted functions. Hence, it puts {x, y, “abc”· m, “ef g”·
n} into one equivalence class and notiﬁes the string theory plug-in.
We note that the plug-in string theory Z3-str can only know about
the equivalent terms that belong to its theory.

As a side remark, if we have an equation length(x) = 4, then
Z3-str is not aware of the fact that length(x) is equal to 4. How-
ever, if e2 were set to true, Z3-str would know that x is equiva-
lent to a constant string of length 4. Therefore, it can deduce that
length(x) is equal to 4, thus subsequently passing this informa-
tion to the arithmetic theory.

Back to the example, with the above equivalence class at step
3, Z3-str detects a conﬂict and then informs the core component
about the new ﬁnding through an axiom e3 ∧ e4 → ¬e1. With this
new axiom, the core component backtracks and tries false for
e1. When the core component backtracks, it discards the relevant
fact and any insertions into equivalence classes as the consequence
of the fact. The core then derives that e2 must be true and this
assignment is performed in step 4.

Based on the concatenation semantics, Z3-str can infer that n
must be “h”. This new ﬁnding is formulated by introducing a new
boolean variable e5 representing n = “h” and an axiom “ef gh” =
“ef g” · n ⇒ e5, which is sent back to the core. From the existing
facts and the new axiom, the core component derives e5 is true.
After all boolean expressions have been assigned consistently and
Z3-str can ﬁnd the satisfying values for string variables x, y, and n,
the search procedure terminates.
4.2 Improvement of Z3-str-(cid:63) over Z3-str

Z3-str-star (or Z3-str-(cid:63) for short), a component of our tool, is
responsible for solving equations between string expression and
recursively-deﬁned functions. It can be viewed as a signiﬁcant ex-
tension of Z3-str with the support of recursively-deﬁned functions,
introduced to facilitate representing and reasoning about the Kleene
star and commonly used high-level string operations.

As mentioned before, in its current implementation, Z3-str does
not know about equivalent terms that belong to other theories, es-
pecially the arithmetic theory. Another important improvement of
Z3-str-(cid:63) (over Z3-str) is its direct interactions with the Z3 core, to
query about the equivalence classes among multiple theories. More
speciﬁcally, it asks Z3 core two following questions:

• Is a string length “ground" with a non-negative constant?
• What is the relationship (=, <, >,≤,≥) between different

length variables?

To answer these questions, we extend Z3 API so that Z3-str-(cid:63) can
interact with the congruence closure core, similarly to other built-in
theory solvers. Moreover, the newly introduced API methods also
help us to query about other inequality relationship, if necessary.
Answers to these questions ultimately allow us to propagate the
information of string lengths to string theory solver so that string
and non-string constraints can be simultaneously reasoned about.
In short, this gives us a truly incremental solver for strings and non-
strings. We will revisit this side contribution in our experimental
evaluation – Section 6.

5. ALGORITHM
5.1 Top-level Algorithm

S3 ﬁnds a list of string assignments that satisﬁes the input for-
mula or decides that no satisfying assignment exists. Algorithm 1
summarizes its top level algorithm.

Input: F : Formula
(cid:87)n
Output: (IsSat : bool, Solutions : (variable, string) list)
reduced_F ← reduce(F);
i disjuncti ← normalize_to_DNF(reduced_F);
for i = 1 to n do
(Res, Sols) ← Z3-str-(cid:63)(disjuncti);
if Res = SAT then

return (true, Sols);

end

end
return (false, []);

Algorithm 1: Top-level Algorithm

Given an input formula F, S3 recursively reduces F into new
formula reduced_F, which may contain equations (among string
expressions and recursive functions such as star) and length con-
straints. Here we only take into consideration the string and length
constraints, non-string constraints will be unchanged unless other-
wise stated. Reduction rules may result in a disjunctive formula.
Thus, the next step is to normalize reduced_F into disjunctive nor-
mal form (DNF). To decide the satisﬁability of each disjunct, we
extend Z3-str [39] to support recursive functions. In particular, we
use the recursive function star to represent the Kleene star. For
presentation purpose, we ﬁrst only discuss how to handle the star
function, calling our extended component Z3-str-(cid:63). Similar treat-
ment for high-level operations such as replaceAll will be elabo-
rated later. If Z3-str-(cid:63) ﬁnds a satisﬁable disjunct, it stops and re-
turns the corresponding satisfying assignments. Otherwise, it de-
cides that no such assignment exists.
5.2 Reduction of Regular Expressions

Rule

[CONST]

[UNION]

[CONCAT]

[STAR]

Reduction

e ∈ s → e=s

e ∈ r1+r2 → e ∈ r1 ∨ e ∈ r2

e ∈ r1·r2 → e=e1·e2 ∧(cid:86)2

e ∈ r(cid:63) → e

∨
= star(r, n)

i=1 ei ∈ ri

Table 3: Reduction Rules

Given an input constraint formula, we ﬁrst reduce membership
predicates into equations among string expressions and star func-
tion. The reduction rules are summarized in Table 3. Our aim is
to obtain a list of new constraints of the form that can be solved
incrementally by Z3-str-(cid:63) — equations among string expressions
and recursively-deﬁned functions, along with length constraints.

These rules deal with constraints checking if a string expression
e (LHS) is in a regular expression (RHS). If the RHS is merely a
string constant, rule [CONST] will convert such membership con-
straint into an equality. The next two rules handle the case when the
RHS is constructed by union and concatenation operations. While
rule [UNION] ensures that the LHS expression e is a member of one
of the RHS sub-expressions (of the union), rule [CONCAT] splits e
into two fresh string variables, namely e1 and e2, and checks that
they satisfy the condition e1 ∈ r1 ∧ e2 ∈ r2 conjunctively.

The RHS regular expression can also be formed by repeating r
zero or more times (Kleene star). Rule [STAR] encodes such con-
straint as an equation, where the LHS is a string expression and the
RHS is a symbolic representation for a family of strings generated
by the Kleene star. The fresh (symbolic) integer variable n indi-
cates the frequency where r is repeated. This symbolic variable is
used to:

1237• Distinguish different star functions, which have the same

base regular expression (e.g. r).

• Guide the on-demand unfolding in the recursively-deﬁned
functions such as star or replaceAll (that will be discussed
later).

• Interact with the Arithmetic Solver module in Z3.
∨
When r is a constant string and n is a concrete value, the
= operator
is interpreted as equality operator =. For convenience, we overload
∨
= with the = notation.

In short, after the reduction for regular expressions, we have
equations among string expressions and recursively-deﬁned star
functions, along with length constraints. Z3-str-(cid:63) is then responsi-
ble for solving them.
5.3 star Functions

Z3-str-(cid:63) extends Z3-str [39] with the support for handling star

functions. The internal language is extended with the following:

Term:str

::= ConstString
|
|

...
star(Term:regexpr, Term:int)

Like Z3-str, Z3-str-(cid:63) also works as a plug-in of Z3. It is notiﬁed
by the Z3 core component when a string equation is asserted as part
of the try-and-backtrack process. In particular, the core component
invokes a callback function in the plug-in, providing the abstract
syntax tree (AST ) of the equation as an input parameter. The call-
back function inspects the AST , and if it involves string operations,
the function tries to reduce AST to a simpler abstract syntax tree,
say AST (cid:48). The reduction is conveyed to the core component by
adding an axiom with the form of AST ⇒ AST (cid:48). Recall that
since the core component does not understand the string domain, it
treats both AST and AST (cid:48) as independent boolean variables. Be-
cause AST has been assigned a true value, with the new axiom,
the core will assign true to AST (cid:48) as well, which is a new fact,
and in turn triggers further plug-in processing. Thus, to act as a
plug-in, we need to provide reduction rules for each callback from
Z3.

We list selected reduction rules in Table 4. There are 3 cases of

interest related to star functions:

• when star appears in one side of an equation,
• when star appears in both side of an equation and
• when star can be used to concretize other concatenations

based on its concrete string value.

The gist of our reduction rules is to make use of the semantics
of star functions (or their previous forms – regular expressions
with Kleene star). In fact, with a membership constraint such as
x ∈ (“ab”)(cid:63), we can directly make use Z3-str to generate the possi-
ble string assignments for x, then checking membership is straight-
forward since x is already ground. However, this naive approach is
likely to be inefﬁcient. Sometimes, it may be worse than Kaluza’s
approach, where the lengths are used to reﬁne the string constraints.
To deal with star functions effectively and efﬁciently, we propose
to reduce it lazily and only on demand. We call that technique
“unfold and consume". The basic principle is to lazily unfold its
semantics, until we ﬁnd a matching between constant string seg-
ments in the two sides of an equation. At that time, we can easily
to choose either consume these constants (of course with the capa-
bility of backtracking), or to ﬁnd a conﬂict between unmatchable
constants in the two sides.

r

Incremental Solving for star Functions
In Table 4 we introduce four auxiliary functions: csm_hd(s, r),
csm_tl(s, r),
csm_hd(r2, r1), and csm_all(s, r). The ﬁrst one
takes a constant string and a regular expression, and returns a list
of strings si such that: s ∈ r·si. Intuitively, this function aims to
consume the preﬁx of s matching r. Similarly, while the second,
csm_tl(s, r), consumes the sufﬁx of s matching r, the third one
applies to two regular expressions instead. Lastly, csm_all(s, r)
checks if s can be consumed completely by matching it with r.

Now, let us have a look at reductions rules in Table 4. The rule
[CON−(cid:63)] says about the case when star(r, n) equals to some con-
stant string s. As we explained above, method csm_all(s, r) is
used to decide whether s can be a member of r(cid:63). If yes, we can
update other string expressions that contain star(r, n). Otherwise,
it is a conﬂict and Z3 core component will need to backtrack. Note
that, in Table 4, all E1, E2 and E3 are concatenations among string
expressions and star functions.

The rules [HT−(cid:63)] and [HD−(cid:63)] are to handle the case when there
is a matching between star and a constant string. In the latter, the
matching is at the beginning of the LHS; while the former is a spe-
cial case of it, where the matchings occur at both ends. These two
rules will be elaborated more in the next example. Similarly, we
have the rule [TL−(cid:63)] for the matching at the end of the LHS.

r

The rule [HD−(cid:63)−(cid:63)] ([TL−(cid:63)−(cid:63)], [HT−(cid:63)−(cid:63)]) is applied when there
are two star function at the beginning (end or both) of each side
In the rule [HD−(cid:63)−(cid:63)], we assume that r1 can-
of the equation.
not be consumed by r2 so that we only need the auxiliary function
csm_hd(r2, r1).

The last rule [REP−(cid:63)] aims to replace all string variables by their
aliases, which are a concatenation among constant strings and star
functions.

To illustrate how these rules are applied, in Table 5, we present
running steps for solving the example in Fig. 3. Z3 core continually
sends the assignments to our Z3-str-(cid:63) (via its call back function)
from step 1 to step 5. At the same time, Z3 also maintains func-
tionally equivalent terms in their equivalence classes. From step 1
to step 4, we apply the rule [REP−(cid:63)] repetitively to replace a string
variable by a constant string, a star function or their concatenation
(shown in column 4, step 1-4). In step 5, we apply a specialized
version of rule [HT−(cid:63)], where we also make use of constraints on
variable n1 and n2. More speciﬁcally, for this running example,
we are able to force the unfolding of star(“bc”,n2) so that we can
ﬁnd a conﬂict between “bc” and “cc”. Finally, we give back the
new axiom (in column 4, step 5) to Z3 so that Z3 can conclude the
input formula is UNSAT.
5.4 String Operations

Operations
I=search(S, r)

Reduction Rules
(I<0 ∧ ¬(S ∈ (.(cid:63))·r·(.(cid:63)))) ∨ (I≥0 ∧
S=U·M1·M2·R ∧ M1·M2 ∈ r ∧ length(U)=I ∧
length(M2)=1 ∧ ¬(U·M1 ∈ (.(cid:63))·r·(.(cid:63))))
R=replaceAll(S, r, T) I=search(S, r) ∧ ((I<0 ∧ R=S) ∨
(I≥0 ∧ S=U·M·S1 ∧ R=U·T·R1 ∧ M ∈ r ∧
length(U)=I ∧ R1=replaceAll(S1, r, T)))

Table 7: Reduction Rules for search and replaceAll

Typically, the semantics of string operations such as replaceAll,
match, split, test, exec, are recursively deﬁned. As such, it is nat-
ural for us to interpret them as recursively-deﬁned functions, simi-
larly to our handling of star functions. In this Subsection, we only

1238Rule

[CON−(cid:63)]

star(r, n)=s
star(r, n)=s∧
(E1·star(r, n)·E2=E3)

Reduction
⇒ ¬star(r, n)=s
⇒ E1·s·E2=E3

[HT−(cid:63)]

star(r1, n1)·E1·star(r2, n2)
=s1·E2·s2

⇒

[HD−(cid:63)]

[TL−(cid:63)]

star(r, n)·E1=s·E2
E1·star(r, n)=E2·s

[HT−(cid:63)−(cid:63)]

star(r1, n1)·E1·star(r3, n3)=
star(r2, n2)·E2·star(r4, n4)

⇒

[HD−(cid:63)−(cid:63)]

star(r1, n1)·E1=
star(r2, n2)·E2

[TL−(cid:63)−(cid:63)]

E1·star(r1, n1)=
E2·star(r2, n2)

[REP−(cid:63)]

x=E∧ (E1·x·E2)

(E1=s1·E2·s2∧n1=0∧n2=0)∨
(

star(r1, n1−1)·E1=si·E2·s2∧n2=0)∨
E1·star(r2, n2−1)=s1·E2·sj∧n1=0)∨

i=1

(

k(cid:87)
l(cid:87)
k,l(cid:87)

j=1

star(r1, n1−1)·E1·star(r2, n2−1)=si·E2·sj

i,j

⇒ (E1=s·E2∧n=0)∨ k(cid:87)
⇒ (E1=E2·s∧n=0)∨ k(cid:87)

i=1

star(r, n−1)·E1=si·E2
E1·star(r, n−1)=E2·si

i=1

(n2=0∧n4=0∧star(r1, n1)·E1·star(r3, n3)=E2)∨
(n2=0∧star(r1, n1)·E1·star(r3, n3)=E2·star(r4, n4))∨
(n4=0∧star(r1, n1)·E1·star(r3, n3)=star(r2, n2)·E2)∨

i,j

star(r1, n1−1)·E1·star(r3, n3−1)=
si·star(r2, n2−1)·E2·star(r4, n4−1)·sj
(E1=E2∧n1=0∧n2=0)∨ (star(r1, n1)·E1=E2∧n2=0)∨
(E1=star(r2, n2)·E2∧n1=0)∨

star(r1, n1−1)·E1=si·star(r2, n2−1)·E2

i=1

(E1=E2∧n1=0∧n2=0)∨ (E1·star(r1, n1)=E2∧n2=0)∨
(E1=E2·star(r2, n2)∧n1=0)∨

E1·star(r1, n1−1)=E2·star(r2, n2−1)·si

k,l(cid:87)

k(cid:87)
k(cid:87)

⇒

⇒

Condition
¬csm_all(s, r),
s: ConstString
csm_all(s, r),
s: ConstString

[si]=csm_hd(s1, r1),
[sj]=csm_tl(s2, r2)

[si]=csm_hd(s, r)

[si]=csm_tl(s, r)

r

[si]=
[sj]=

csm_hd(r3, r1),
csm_tl(r4, r2)

r

[si]=

csm_hd(r2, r1)

r

[si]=

csm_tl(r2, r1)

r

i=1

⇒ E1·E·E2

Table 4: Selected Reduction Rules for star Functions

E is a concatenation
constant
among
star
strings
functions

and

give the details of reduction for replaceAll. Other operations can
be treated in a similar manner.

As stated earlier, we aim to support the most general usage of
replace function – replacing all occurrences. In practice, there
is also another version (e.g. in PHP) which allows users to spec-
ify the maximum number of occurrences to be replaced. We call it
replaceN, to distinguish the two versions. In fact, replaceN is al-
ready supported by existing solvers, e.g., Kaluza. The typical treat-
ment is to model the input parameter as a concatenation of N parts,
and then apply one replacement to each part. However, this tech-
nique cannot be generalized to address replaceAll, since we do not
know such an N beforehand. Here we propose to model both re-
placeAll and replaceN, again, using recursively-deﬁned functions.
In fact, restricting to replaceN alone, our approach will be more
efﬁcient than Kaluza’s. This efﬁciency comes from the superiority
of incremental solving (via constrain-and-generate approach) over
generate-and-test approach.

Since replaceN is a special case of replaceAll, we focus on dis-
cussing only the latter. Table 7 shows that R=replaceAll(S, r, T)
belongs to one of two possible cases:

• the recursive case, when we ﬁnd a substring M, that matches
regular expression r, at an index I. We then can replace M by
T and continue to apply replaceAll function on the remaining
part S1 until we reach the base case.

• the base case, when we cannot ﬁnd any substring that satis-
ﬁes such condition. The resulting string R is then the same as
the input string S.

The replaceAll function will use search function to ﬁnd the index
of substring M=M1·M2 in S. Speciﬁcally, this auxiliary function takes
as input a symbolic string input S, a regular expression r, and re-
turns the starting index I of a substring in S that matches r. If there
exists no such substring, it returns a negative number. Otherwise, it
returns the index of the substring M that satisﬁes the condition.

We remark that the second parameter of replaceAll function can-
not be a variable since in such case, the behavior of this function
is undeﬁned. Naively, we can keep unfolding recursively-deﬁned
function replaceAll, until we can decide if the current formula is
satisﬁable or not. However, we provide reduction rules (unfolding
on demand) for them instead. For presentation purpose, Table 6
lists only two reduction rules for the case when the preﬁx of the
ﬁrst parameter S is known5. In rule [RED−1], the preﬁx of S is a
constant string s, while it is star(s, n) in rule [RED−2]. In both
cases, since the preﬁx is already known, we are able to apply the
replacement on the part s (star(s, n) in the other case) via auxiliary
function rep. In rule [RED−1], suppose that S is composed by s
and R, function rep(s, r, T ) replaces all occurrences in s, match-
5Other rules related to the second, the third parameter, the result
and their combinations are constructed similarly.

1239Step

Fact added

1
2
3

4

5

nM = “ababababababcc”
p1 = star(“ab”,n1)
p2 = star(“bc”,n2)

res=
star(“ab”,n1)·star(“bc”,n2)
star(“ab”,n1) · star(“bc”,n2) =
“ababababababcc”

res,

Eq-class
{“ababababababcc”,
nM, p1 · p2}
{p1, star(“ab”,n1)}
{p2, star(“bc”,n2)}
{“ababababababcc”,
res, nM,
star(“bc”,n2), p1 · p2}
{“ababababababcc”,
res, nM,
star(“bc”,n2), p1 · p2}
UNSAT

star(“ab”,n1)·

star(“ab”,n1)·

Reduction/Action
[REP−(cid:63)]: res = “ababababababcc”
[REP−(cid:63)]: res = star(“ab”,n1) · p2
[REP−(cid:63)]: res = star(“ab”,n1) · star(“bc”,n2)
[REP−(cid:63)]:star(“ab”,n1)·star(“bc”,n2)=
“ababababababcc”
star(“ab”,n1)·star(“bc”,n2)=“ababababababcc”⇒
¬star(“ab”,n1)·star(“bc”,n2)=“ababababababcc”

Table 5: A Solving Procedure for the Motivating Example in Fig. 3

Rule

[RED−1]
[RED−2]

replaceAll(s·R, r, T )=U

⇒ V ·replaceAll(t·R, r, T )=U

replaceAll(star(s, n)·R, r, T )=U ⇒ V ·replaceAll(t·R, r, T )=U (V, t)=rep(star(s, n), r, T )

Condition

(V, t)=rep(s, r, T )

Reduction

Table 6: Reduction Rules for replaceAll Functions

ing the regular expression r, by T . It then returns the pair (V, t)
such that replaceAll(s, r, T )=V ·t, where t is guaranteed to be
the longest sufﬁx of s that must be examined together with R in the
next step replaceAll(t·R, r, T ). The application of rep for the
case star(s, n) is similar to s except that V is parameterized by n.
Now, we illustrate how this auxiliary function can be applied via
two examples. In the ﬁrst example:

replaceAll(“abcd”·R, “ab”, T ) = U

the rep(“abcd”, “ab”, T ) method will return (T·“cd”, “”). In the
second one:

replaceAll(“abcd”·R, (“ab” + “de”), T ) = U

it will return (T·“c”, “d”) since it is possible that R starts with
character ‘e’.
Length constraints. We have inherited rules from Z3-str, to infer
length constraints such as X=Y → length(X)=length(Y ).
Due to space limit, we do not include them in our paper. Impor-
tantly, the unfolding of recursive functions (star, replaceAll, etc.)
would incrementally expose more concrete (sub)strings and there-
fore the interactions from Z3-str-(cid:63) to the Arithmetic Solver module
in Z3 also happen incrementally.

In addition, as stated in Sec. 4.2, the length constraints, in the
feedback from the Arithmetic Solver module, can also be used to
prune the search space in string theory component, Z3-str-(cid:63). For
example, when the Arithmetic Solver module can deduce concrete
values for length variables, Z3-str-(cid:63) will be able to make use of
such information.

6. EVALUATION

In our experimental evaluation, we conduct two case studies to
compare S3 with state-of-the-art string solvers. All experiments are
run on an 3.2GHz machine with 8GB memory.

In Section 3, we stated that constraint solvers, which work only
on string domain or only on non-string domain, are not effective for
analyzing web applications. Thus, it is sufﬁcient for us to compare
S3 only with Kaluza and Z3-str.
6.1 Comparison with Kaluza

In this case study, we use the set of (50,000+) benchmarks that

is shipped with Kaluza, which can be downloaded at:

http://webblaze.cs.berkeley.edu/2010/kaluza

They were generated using Kudzu [28], a symbolic execution frame-
work for JavaScript. Since our solver can parse these generated
constraints directly, it is straight-forward to plug S3 into Kudzu.
The Kaluza benchmarks are classiﬁed into two:

• SAT, where Kaluza ﬁnds a satisfying solution and returns

YES.

• UNSAT, where Kaluza cannot ﬁnd any solutions and returns

NO or it ends up with errors.

For each category, the benchmarks are further divided into two
groups: small and big, based on the size of the ﬁles. We note that
the classiﬁcation is done by [28]; such classiﬁcation is not necessar-
ily accurate in reality. In fact, after rectifying totally 1 ﬁle in SAT
category and 4057 ﬁles in UNSAT category, those having parsing
errors (due to incorrect syntax or types), Kaluza can now answer
YES (means satisﬁable) for 2894 out of 4057 previously UNSAT
cases. We will elaborate on this later.

#Files
19984
1835
11761

Time(s)

S3
267
166
173

K/S3
19.4x
19.0x
26.2x

K

5190
3165
4532

SAT/Small
SAT/Big

UNSAT/Small

Table 8: Timing Comparison: S3 vs. Kaluza

We ﬁrst consider a timing comparison. We ran both Kaluza (col-
umn K) and S3 on all the benchmarks in the SAT category, as
well the small benchmarks in the UNSAT category. The reason
for omitting the large benchmarks in the UNSAT category is that
often Kaluza fails to ﬁnd a deﬁnitive answer here (due to crashing
or timing out, after 1 minute), and therefore it is not meaningful
to compare with its timing. The results, which are summarized in
Table 8, clearly show that S3 is much faster, by a factor 19 or more.
In the next experiment, we consider something of perhaps greater
importance: robustness. Roughly speaking, this measures how of-
ten a solver is able to provide a deﬁnitive answer. This, in turn,
means that if the solver returns YES, then it should produce a par-
ticular model which demonstrates the executability of the path in
question.
If the solver returns NO, then it should mean that the
path in question is in fact not executable. There is of course a third
possible answer, MAYBE, which is not deﬁnitive (and which is the

1240cause of false alarms). A robust system therefore is one which re-
turns deﬁnitive answers often.

As mentioned above, the Kaluza benchmarks are categorized

into SAT and UNSAT.

In the SAT category (of 19984 + 1835 = 21819 benchmarks),
S3 ﬁnds 6 of them are unsatisﬁable. By a careful investigation, it
is in fact the case. Moreover, S3 successfully reports YES on all
the benchmarks (excluding the 6 which are wrongly classiﬁed), and
further, the complete models, returned by S3, are cross-checked by
running them using Kaluza.

Next, we use S3 to cross-check the models produced by Kaluza.
Since in Kaluza, each query must specify a variable, for which they
will generate the model, in our setting we tested with the vari-
able that starts with ‘var’6. As a result, Kaluza has errors with
11 benchmarks that do not have any variable starting with ‘var’.
For the other 21808 benchmarks, it reports a YES answer. How-
ever, in 695 out of 21813 indeed satisﬁable benchmarks, the model
returned by Kaluza is incomplete. Because Kaluza only returns the
model for one variable, it is possible that the return model for the
chosen variable may not be extensible to become a complete model
which includes other variables. In short, these 695 models are in
fact not really models that are useful to reproduce attacks.
(We
note that [39] has previously remarked this “semi-soundness" issue
of Kaluza.)

Table 9 shows statistics for 33230 (11761 + 21469) benchmarks
in the UNSAT category. Kaluza reports a YES answer for 2894 out
of 4057 rectiﬁed benchmarks. For other ﬁles (including the other
rectiﬁed ﬁles), Kaluza is not reporting a NO answer to all bench-
marks therein; rather, the answer is MAYBE most of the times. In
fact, more than half (18210) of the benchmarks in this category was
determined by S3 as SATISFIABLE! Again, the return models are
conﬁrmed by running them using Kaluza. This means that S3 has
much more potential for vulnerability detection than Kaluza does.

NO
YES
ERROR
TIMEOUT (1 min)
MAYBE

S3

14877
18210
0
0
143

Kaluza
7124
2894
22653
559
0

Table 9: S3 vs. Kaluza on UNSAT Category

Note that in Table 9 we no longer distinguish between big and
small programs. The frequency of Kaluza crashing (ERROR) or
timing out (TIMEOUT, after 1 minute), as opposed to saying NO,
is extremely high. Also note that, 2894 ﬁles that Kaluza reports
SAT (YES) only belong to rectiﬁed ones. Moreover, Kaluza often
(about 70% of the time) returns a non-deﬁnitive answer, either by
crashing or timing out. In contrast, S3 returns a deﬁnitive answer
much more often.

In summary for this study, we have ﬁrst shown that S3 is far more
efﬁcient than Kaluza using its own impressive set of (50, 000+)
benchmarks, by a signiﬁcant margin. Perhaps as importantly, we
have also shown that for a large number of cases where Kaluza
provides no conclusion, S3 can actually provide a deﬁnitive con-
clusion (about 99.6% on the UNSAT benchmarks). Thus S3 is far
more efﬁcient and robust than Kaluza.
6.2 Comparison with Z3-str

Recall that Z3-str deals with a smaller class of constraints than
S3 (since Z3-str cannot handle regular expressions). The purpose
6There is usually one such variable in each benchmark.

of this study is to answer the question: w.r.t constraints that can be
handled by both of the two solvers, are the performances the same?
We now demonstrate that the answer is no, via deﬁning the classes
that show S3’s improvement (esp. our enhanced design).

Time(ms)

Benchmark

Model produced?
Z3-str S3 Z3-str/S3
Z3-str
_
ID_3482
NO
_
ID_3468
NO
_
ID_1543(*)
NO
_
ID_3464
NO
_
ID_3487
NO
_
ID_new.23484(*) NO
27x
YES
sat_bnd
3496x
sat_unbnd
YES
_
unsat_bnd
unsat_unbnd
_
Timeout (TO) is at 2h. ‘*’: regular expressions are removed.

58
23
36
35
31
21
3225 120
451s 129
TO 30
TO 46

S3
YES
YES
YES
YES
YES
YES
YES
YES
NO
NO

_
_
_
_
_
_

_
_

Table 10: S3 vs. Z3-str

To demonstrate that S3 is better, we ﬁrst use six test cases from the
SAT benchmarks of Kaluza. We follow the setting of Z3-str [39]
and remove all the constraints related to regular expressions. This
way we can run Z3-str on the resulting constraints. These six
benchmarks are presented in the ﬁrst part of Table 10. For each of
them, while S3 returns YES with a solution model, Z3-str instead
returns NO. We note that the models S3 provides are validated as
correct by using Z3-str itself.

We now brieﬂy discuss why we have this difference. One reason
is that Z3-str cannot acquire the concrete values assigned to length
variables. In contrast, our design, presented in Section 4.2, enables
the direct interactions between the string solver plug-in Z3-str-(cid:63)
and Z3 core, to query if the lengths of some string variables have
been deduced or constrained in the arithmetic theory. This helps
Z3-str-(cid:63) avoid repetitive case analysis.

More speciﬁcally, the six we use in Table 10, have the following
(frequent) pattern: there exists at least one variable that is only con-
strained by its length. Basically, with the constraint length(x)=i,
the solution for x can be any string of length i, i.e. “@..@”, where
each @ is an arbitrary character. However, Z3-str cannot make use
of this length constraint and keeps trying to assign string value for
x, starting from the empty string. Given that x is constrained by its
length, Z3-str must try-and-test many times until there is no more
conﬂict with that length constraint. Thus, the total number of values
to be tested by Z3-str will be blown up, preventing it from ﬁnding
a solution.

We next consider another set of benchmarks, representing an-
other pattern (which is also frequent in Kaluza’s benchmarks): there
exists a relationship between the lengths of different string vari-
ables. Indeed the example presented in Fig. 4 resembles such pat-
tern. See the second part of Table 10, where statistics for 4 bench-
marks are shown. We purposely make two benchmarks satisﬁable
– names start with ‘sat’, whereas the other two are unsatisﬁable –
names start with ‘unsat’. In the two whose names end with ‘bnd’,
the lengths of the string variables are bounded by 10, while in the
other two (the names end with ‘unbnd’), there is no such bound.
For each satisﬁable benchmarks, both Z3-str and S3 can ﬁnd a cor-
rect solution model. However, S3 outperforms Z3-str signiﬁcantly
by an order of magnitude. For the unsatisﬁable cases, while S3 re-
turns NO within a second, Z3-str runs for more than 2 hours without
producing an answer.

1241In summary, our design allows the full interaction between string
theory and arithmetic theory, enabling S3 to handle length con-
straints more effectively. Thus, even discounting the fact that S3
solves a more general class of constraints than Z3-str, its perfor-
mance is much better in the common class of constraints. This
ensures its applicability in web programs, where length constraints
are ubiquitous.
7. RELATED WORK

Symbolic execution has recently been exploited to address a wide
range of security problems. Some notable examples are: auto-
mated ﬁngerprint generation [7], protocol replay [25], automated
code transformation to eliminate SQL injection attacks in legacy
web applications [4].

Motivated by the problem of analyzing JavaScript code for the
purpose of detecting security ﬂaws, [28] proposed a framework,
Kudzu, which leverages the beneﬁts of both concrete and symbolic
evaluation. This work effectively reduced the analysis problem of
web applications to the problem of solving string constraints. In
order to be widely applicable, it is important to have a string solver
which is able to reason about both string and non-string constraints.
Importantly, the solver must also support constraints involving reg-
ular expressions and with multiple variables.

There is a vast literature on the problem of string solving. In
previous Sections, we have carefully positioned our work against
Kaluza and Z3-str. We now focus on other closely related work.

Practical methods for solving string equations can loosely be di-
vided into bounded and unbounded methods. Bounded methods
(e.g., HAMPI [22], CFGAnalyzer [3], and [18]) often assume ﬁxed
length string variables, then treat the problem as a normal constraint
satisfaction problem (CSP). These methods can be quite efﬁcient in
ﬁnding satisfying assignments and often can express a wider range
of constraints than the unbounded methods. However, as also iden-
tiﬁed in [28], there is still a big gap in order to apply them to con-
straints arising from the analysis of web applications.

In the spirit of Kaluza, [6] proposed to reason about feasibility
of a symbolic execution path from high-level programs, of which
string constraints are involved. In principle, the approach is similar
to Kaluza: it proceeds by ﬁrst enumerating concrete length values,
before encoding strings into bit-vectors. It supports common in-
teger related string operations, taken from the basic .NET string
library, except for replace. Unlike Kaluza, however, regular ex-
pressions are not supported here. In a similar manner,
[27] ad-
dresses multiple types of constraints for Java PathFinder. Though
this approach can handle many operators, it provides limited sup-
port for replace, requiring the result and arguments to be con-
crete. Furthermore, it does not handle regular expressions. In sum-
mary, the above methods are less powerful than S3 in terms of the
expressiveness of the input language. Importantly, they have simi-
lar limitations as Kaluza, which we have carefully discussed.

PISA [33] is the ﬁrst path- and index-sensitive string solver that
targets static analysis of web applications. The veriﬁcation is con-
ducted by encoding the program in Monadic Second-Order Logic
(M2L). It supports regular expressions as well as Java’s replace
method. However, it does not support binary operations between
two variables, i.e., PISA requires at least one of them to be con-
stant. Also importantly, its expressiveness for arithmetic operations
is restricted due to the limitations of M2L. For example, it does not
support numeric multiplications and divisions.

Other unbounded methods are often built upon the theory of au-
tomata or regular languages. We will be brief and mention a few
notable works. Java String Analyzer (JSA) [10] applies static anal-
ysis to model ﬂow graphs of Java programs in order to capture de-
pendencies among string variables. A ﬁnite automata is then de-
rived to constrain possible string values. The work [31] used ﬁ-
nite state machines (FSMs) for abstracting strings during symbolic
execution of Java programs. They handle a few core methods in
the java.lang.String class, and some other related classes.
They partially integrate a numeric constraint solver. For instance,
string operations which return integers, such as indexOf, trigger
case-splits over all possible return values.

In short, using automata and/or regular language representations
potentially enables the reasoning of inﬁnite strings and regular ex-
pressions. However, most of existing approaches have difﬁculties
in handling string operations related to integers such as length
and indexOf, let alone other high-level operations addressed in
this paper. More importantly, to assist web application analysis, it
is necessary to reason about both string and non-string behavior to-
gether. It is not clear how to adapt such techniques for the purpose,
given that they do not provide native support for constraints of the
type integer.

Since our method does not rely on the length bounds in enu-
merating solutions, and our particular treatment of (possibly un-
bounded) recursive operations is lazy, it is possible that S3 can
handle query of unbounded length variables as well as unbounded
regular expression. However, to guarantee termination, we do rely
on the fact that the lengths are bounded. In fact, our work targets
the input constraints arising from realistic web applications. There-
fore, even when the lengths are not precisely known – in the case
of static analysis – it is reasonable to assume that the lengths of in-
put string variables are indeed bounded, as many modern practical
string solvers do.

8. CONCLUDING REMARKS

This paper presents a new algorithm for solving string constraints.
The class of constraints is practically expressive, for its intended
purpose of analyzing web programs which manipulate string in-
puts. Experimental evaluations show that our solver S3, despite
being more expressive than other solvers, is much more robust and
efﬁcient.

We remark that in lieu of presenting an end-to-end system, we
show that our proposed solver is indeed a modular contribution to
any hypothetical dynamic symbolic execution end-to-end system.
That is, the superior performance of our solver can be used, without
signiﬁcant engineering of integrating it, to obtain an improvement
in the hypothetical system.

We believe, based on its symbolic representation of string con-
straints, S3 can also be extended to be more efﬁcient in the context
of static analysis, where even regular expressions can also be sym-
bolically constructed.

Astute readers might already notice that our underlying symbolic
representation goes well beyond regular languages. As an example,
{an·bn | n ≥ 0} can be easily modeled as star(a, n)·star(b, n)∧
n ≥ 0. While this paper focuses on the practical impact of S3,
investigating the theoretical impact of such symbolic representation
is left as our future work.

12429. REFERENCES
[1] M. Alkhalaf, T. Bultan, and J. L. Gallegos. Verifying
Client-side Input Validation Functions Using String
Analysis. In ICSE, pages 947–957, 2012.

[2] M. Alkhalaf, S. R. Choudhary, M. Fazzini, T. Bultan,

A. Orso, and C. Kruegel. ViewPoints: Differential String
Analysis for Discovering Client- and Server-side Input
Validation Inconsistencies. In ISSTA, pages 56–66, 2012.

[3] R. Axelsson, K. Heljanko, and M. Lange. Analyzing

Context-Free Grammars Using an Incremental SAT Solver.
In ICALP, pages 410–422, 2008.

[4] P. Bisht, T. Hinrichs, N. Skrupsky, R. Bobrowicz, and V. N.

Venkatakrishnan. NoTamper: Automatic Blackbox Detection
of Parameter Tampering Opportunities in Web Applications.
In CCS, pages 607–618, 2010.

[5] P. Bisht, T. Hinrichs, N. Skrupsky, and V. N.

Venkatakrishnan. WAPTEC: Whitebox Analysis of Web
Applications for Parameter Tampering Exploit Construction.
In CCS, pages 575–586, 2011.

[6] N. Bjørner, N. Tillmann, and A. Voronkov. Path Feasibility

Analysis for String-Manipulating Programs. In TACAS,
pages 307–321, 2009.

[7] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and

D. Song. Towards Automatic Discovery of Deviations in
Binary Implementations with Applications to Error
Detection and Fingerprint Generation. In USENIX Security
Symposium, pages 15:1–15:16, 2007.

[8] S. Bucur, J. Kinder, and G. Candea. Prototyping Symbolic
Execution Engines for Interpreted Languages. In ASPLOS,
pages 239–254, 2014.

[9] A. Chaudhuri and J. S. Foster. Symbolic Security Analysis of

Ruby-on-rails Web Applications. In CCS, pages 585–594,
2010.

[10] A. S. Christensen, A. Møller, and M. I. Schwartzbach.

Precise Analysis of String Expressions. In SAS, pages 1–18,
2003.

[11] L. M. de Moura and N. Bjørner. Z3: An Efﬁcient SMT

Solver. In TACAS, pages 337–340, 2008.

[12] M. Emmi, R. Majumdar, and K. Sen. Dynamic Test Input

Generation for Database Applications. In ISSTA, pages
151–162, 2007.

[13] G. Gange, J. A. Navas, P. J. Stuckey, H. Søndergaard, and

P. Schachte. Unbounded Model-Checking with Interpolation
for Regular Language Constraints. In TACAS, pages
277–291, 2013.

[14] I. Ghosh, N. Shaﬁei, G. Li, and W.-F. Chiang. JST: An

Automatic Test Generation Tool for Industrial Java
Applications with Strings. In ICSE, pages 992–1001, 2013.

[15] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed

Automated Random Testing. SIGPLAN Not., 40(6):213–223,
June 2005.

[16] P. Godefroid, M. Y. Levin, and D. A. Molnar. Automated
Whitebox Fuzz Testing. In NDSS, pages 151–166, 2008.
[17] W. G. Halfond, S. Anand, and A. Orso. Precise Interface

Identiﬁcation to Improve Testing and Analysis of Web
Applications. In ISSTA, pages 285–296, 2009.

[18] J. He, P. Flener, J. Pearson, and W. Zhang. Solving String

Constraints: The Case for Constraint Programming. In CP,
pages 381–397, 2013.

[19] P. Hooimeijer and W. Weimer. A Decision Procedure for

Subset Constraints over Regular Languages. In PLDI, pages
188–198, 2009.

[20] P. Hooimeijer and W. Weimer. Solving String Constraints

Lazily. In ASE, pages 377–386, 2010.

[21] C. S. Jensen, M. R. Prasad, and A. Møller. Automated

Testing with Targeted Event Sequence Generation. In ISSTA,
pages 67–77, 2013.

[22] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D.
Ernst. HAMPI: A Solver for String Constraints. In ISSTA,
pages 105–116, 2009.

[23] A. Kiezun, P. J. Guo, K. Jayaraman, and M. D. Ernst.
Automatic Creation of SQL Injection and Cross-site
Scripting Attacks. In ICSE, pages 199–209, 2009.

[24] J. Maras, M. Štula, and J. Carlson. Generating Feature Usage

Scenarios in Client-side Web Applications. In ICWE, pages
186–200, 2013.

[25] J. Newsome, D. Brumley, J. Franklin, and D. Song.

Replayer: Automatic Protocol Replay by Binary Analysis. In
CCS, pages 311–321, 2006.

[26] OWASP. Top ten project, May 2013.

http://www.owasp.org/.

[27] G. Redelinghuys, W. Visser, and J. Geldenhuys. Symbolic

Execution of Programs with Strings. In SAICSIT, pages
139–148, 2012.

[28] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A Symbolic Execution Framework for JavaScript.
In SP, pages 513–528, 2010.

[29] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs. Jalangi: A

Selective Record-replay and Dynamic Analysis Framework
for JavaScript. In ESEC/FSE, pages 488–498, 2013.

[30] K. Sen, D. Marinov, and G. Agha. CUTE: A Concolic Unit
Testing Engine for C. In ESEC/FSE, pages 263–272, 2005.
[31] D. Shannon, I. Ghosh, S. Rajan, and S. Khurshid. Efﬁcient

Symbolic Execution of Strings for Validating Web
Applications. In DEFECTS, pages 22–26, 2009.
[32] T. Tateishi, M. Pistoia, and O. Tripp. Path- and

Index-sensitive String Analysis based on Monadic
Second-order Logic. In ISSTA, pages 166–176, 2011.

[33] T. Tateishi, M. Pistoia, and O. Tripp. Path- and

Index-sensitive String Analysis Based on Monadic
Second-order Logic. ACM Trans. Softw. Eng. Methodol.,
22(4):33:1–33:33, Oct. 2013.

[34] M. Veanes, P. d. Halleux, and N. Tillmann. Rex: Symbolic

Regular Expression Explorer. In ICST, pages 498–507, 2010.

[35] R. Wang, P. Ning, T. Xie, and Q. Chen. MetaSymploit:

Day-one Defense Against Script-based Attacks with
Security-enhanced Symbolic Analysis. In SEC, pages 65–80,
2013.

[36] G. Wassermann and Z. Su. Sound and Precise Analysis of
Web Applications for Injection Vulnerabilities. In PLDI,
pages 32–41, 2007.

[37] G. Wassermann and Z. Su. Static Detection of Cross-site
Scripting Vulnerabilities. In ICSE, pages 171–180, 2008.

[38] F. Yu, M. Alkhalaf, and T. Bultan. STRANGER: An

Automata-based String Analysis Tool for PHP. In TACAS,
pages 154–157, 2010.

[39] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A Z3-based

String Solver for Web Application Analysis. In ESEC/FSE,
pages 114–124, 2013.

1243