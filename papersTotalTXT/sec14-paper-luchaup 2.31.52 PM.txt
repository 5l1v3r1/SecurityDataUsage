LibFTE: A Toolkit for Constructing Practical,  

Format-Abiding Encryption Schemes

Daniel Luchaup, University of Wisconsin—Madison; Kevin P. Dyer, Portland State University; 

Somesh Jha  and Thomas Ristenpart, University of Wisconsin—Madison;  

Thomas Shrimpton, Portland State University

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/luchaup

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXLibFTE: A Toolkit for Constructing

Practical, Format-Abiding Encryption Schemes

Daniel Luchaup1

luchaup@cs.wisc.edu

Kevin P. Dyer2
kdyer@cs.pdx.edu

Somesh Jha1

jha@cs.wisc.edu

Thomas Ristenpart1
rist@cs.wisc.edu

Thomas Shrimpton2
teshrim@cs.pdx.edu

1Department of Computer Sciences, University of Wisconsin-Madison

2Department of Computer Science, Portland State University

Abstract

Encryption schemes where the ciphertext must abide by a
speciﬁed format have diverse applications, ranging from
in-place encryption in databases to per-message encryp-
tion of network trafﬁc for censorship circumvention. De-
spite this, a unifying framework for deploying such en-
cryption schemes has not been developed. One conse-
quence of this is that current schemes are ad-hoc; another
is a requirement for expert knowledge that can disuade
one from using encryption at all.

We present a general-purpose library (called libfte)
that aids engineers in the development and deploy-
ment of format-preserving encryption (FPE) and format-
transforming encryption (FTE) schemes. It incorporates
a new algorithmic approach for performing FPE/FTE
using the nondeterministic ﬁnite-state automata (NFA)
representation of a regular expression when specifying
formats. This approach was previously considered un-
workable, and our approach closes this open problem.
We evaluate libfte and show that, compared to other en-
cryption solutions, it introduces negligible latency over-
head, and can decrease diskspace usage by as much
as 62.5% when used for simultaneous encryption and
compression in a PostgreSQL database (both relative to
conventional encryption mechanisms).
In the censor-
ship circumvention setting we show that, using regular-
expression formats lifted from the Snort IDS, libfte can
reduce client/server memory requirements by as much as
30%.

1

Introduction

Both in practice and in the academic literature, we see
an increasing number of applications demanding encryp-
tion schemes whose ciphertexts abide by speciﬁc for-
matting requirements. A small industry has emerged
around the need for in-place encryption of credit-card
numbers, and other personal and ﬁnancial data. In the

case of credit-card numbers, this means taking in a string
of 16 decimal digits as plaintext and returning a string
of 16 decimal digits as ciphertext. This is an example of
format-preserving encryption (FPE). NIST is now con-
sidering proposals for standardized FPE schemes, such
as the FFX mode-of-operation [7], which is already used
in some commercial settings [3]. On a totally different
front, a recent paper [11] builds a format-transforming
encryption scheme. It takes in plaintext bit strings (for-
matted or not) and returns ciphertexts formatted to be in-
distinguishable, from the point of view of several state-
of-the-art network monitoring tools, from real HTTP,
SMTP, SMB or other network protocol messages. This
FTE scheme is now part of the Tor Project’s Browser
Bundle, and is being integrated into other anti-censorship
systems.

It seems clear that FPE and FTE have great poten-
tial for other applications, too. Unfortunately, developers
will ﬁnd a daunting collection of design choices and en-
gineering challenges when they try to use existing FPE
or FTE schemes in new applications, or to instantiate en-
tirely new schemes. To begin with, there isn’t a stan-
dard way to specify the formats that plaintexts or cipher-
texts must respect. There are no established guidelines,
and certainly no automated tools, to help developers un-
derstand whether they should be targeting deterministic
schemes or randomized ones, or how their chosen for-
mats might affect runtime performance and memory us-
age. (In the case of FTE, it can be difﬁcult to tell if a
given input and output format will result in a scheme that
operates properly.) There are no established APIs, and
no reference implementations or open-source libraries to
aid development.

Making FPE/FTE More Approachable:
In
this work, we offer a unifying framework for build-
ing and deploying FPE and FTE schemes. We design
and implement an algorithm library, libfte, and include
in it developer-assistance tools. A paramount goal of

libfte.

USENIX Association  

23rd USENIX Security Symposium  877

1

our effort is ease-of-use: our library exposes an inter-
face in which formats for plaintexts and ciphertexts are
easily speciﬁed via Perl-compliant regular expressions
(regexes), and it relieves the programmer of the burdens
of making good algorithm and parameter choices.

Some of what we do is to make existing algorithms
(e.g., FFX) signiﬁcantly easier to use. But some of the
engineering and deployment challenges demand entirely
new approaches to both FPE and FTE. Perhaps most no-
tably, we solve an open problem regarding how to build
regular-expression-based schemes using a regex’s non-
deterministic ﬁnite automaton (NFA) representation, as
opposed to its DFA representation. This is desirable
because it can lead to signiﬁcantly more space-efﬁcient
schemes, but the approach was previously thought to be
unworkable [5, 11]. We dispel this thought, and experi-
mentally observe the resulting boost in efﬁciency.
To summarize the main contributions of this work, we:
(cid:127) Design and implement a library and toolkit

to
make development and deployment easy. The libfte
library exposes simple interfaces for performing
FPE/FTE over regex formats speciﬁed by the user.
We provide a conﬁguration tool that guides devel-
opers towards good choices for the algorithms that
will instantiate the scheme, and that provides con-
crete feedback on expected ofﬂine and online per-
formance and memory usage.

(cid:127) Develop new FTE schemes that

take regular-
expression formats, but can work directly with their
NFA representation. This was previously thought to
be an unworkable approach [5], due to a PSPACE-
hardness result, but we show how to side-step this
via a new encoding primitive called relaxed rank-
ing. The result is FTE schemes that handle a larger
class of regexes, and impose smaller ofﬂine/online
memory requirements.

(cid:127) Detail a general, theoretical framework that cap-
tures existing FPE/FTE schemes as special cases,
and surfaces potentially useful new constructions,
e.g., deterministic FTE that encrypts and com-
presses simultaneously. Due to space constraints,
the formalisms appear mostly in the full ver-
sion [16].

In addition, the libfte library will be made publicly avail-
able as free and open-source software1, with APIs for
Python, C++ and JavaScript.
Applications. We exercise libfte by applying it to a va-
riety of application settings. Table 1 gives a summary
of the diversity of formats required across these various
applications.

We ﬁrst show how to use libfte to perform FPE of SQL

1https://libfte.org/

Deployment
Setting
Databases

Web Forms

Network
Monitors

Type
credit card number
dateﬁeld
account balance
email address

year, month, day
URL
HTTP GET request

Examples

Constraint
16-digit string
YYYYMMDD
32-bit integers
contains @ symbol,
ends with {.com,. . .}
YYYY, MM, DD
starts with http(s)
“GET /...”

Browser X “. . . User-Agent: X . . . ”
SSH trafﬁc

“SSH-. . . ”

Table 1: Example deployment settings and constraints
for FPE/FTE schemes.

database ﬁelds, a classic motivational setting for FPE, but
one that has (to the best of our knowledge) never been re-
ported upon. We show that performance loss compared
to conventional encryption is negligible. We also show
how to leverage the ﬂexibility of libfte to improve per-
formance, by using a (deterministic) FTE scheme that si-
multaneously encrypts and compresses ﬁelds (in a prov-
ably secure manner).

We then use libfte to build a proof-of-concept browser
plugin that encrypts form data on websites such as Ya-
hoo! Contacts. This uses a variety of FPE and FTE
schemes, and allows one to abide by a variety of format
restriction checks performed by the website.

Finally, we show that our NFA-based algorithms in
libfte enable signiﬁcant memory savings, speciﬁcally for
the case of using FTE in the network-monitor-avoidance
setting [11]. Using a corpus of 3,458 regular expres-
sions from the Snort monitor we show that we can reduce
memory consumption of this FTE application by 30%.

2 Previous Approaches and Challenges

We review in more detail some of the main results in
the areas of format-preserving and format-transforming
encryption, and then discuss some of the challenges pre-
sented when one attempts to implement and use these in
practice. As we shall see, existing tools fall short for the
types of applications we target. Table 2 provides a sum-
mary.
Format-preserving encryption.
In many settings the
format of a plaintext and its encryption must be the same,
and the tool used to achieve this is format-preserving en-
cryption (FPE). Work on FPE predates its name, with
various special cases such as length-preserving encryp-
tion of bit strings for disk-sector encryption (c.f., [14,
15]), ciphers for integral sets [8], and elastic block ci-
phers [10] including de novo constructions such as the
hasty pudding cipher [21]. For an overview of work on

878  23rd USENIX Security Symposium 

USENIX Association

2

Paper
[7]
[5]

Builds
FPE
FPE

[11]

FTE

Formats
slice of ⌃⇤
slice of chosen
regular language
slice of chosen
regular language

Schemes
deterministic
deterministic

randomized

Implementation
none
none

open source,
but domain speciﬁc

This
Work

FPE/
FTE

range-slice of
chosen regular language

deterministic/
randomized

open source,
conﬁguration toolchain,
non domain speciﬁc

Comments
proposed NIST standard
ﬁrst FPE paper, theory only,
requires regex-to-DFA conversion
input format ﬁxed as bitstrings,
control of output format,
requires regex-to-DFA conversion
control of input and output format,
NFA and DFA ranking,
regex-to-DFA conversion not required

Table 2: Analysis of prior works, and a comparison of features.

FPE, see Rogaway [20].

FPE was ﬁrst given a formal cryptographic treatment
by Bellare, Ristenpart, Rogaway and Spies (BRRS) [5].
In their work, BRRS suggested an approach to FPE
called the “rank-encipher-unrank” construction. First,
they show how to build a cipher that maps ZN to ZN ,
for an arbitrary ﬁxed number N.
(Recall that ZN =
{0, 1, . . . N − 1}.) Now say that X is a set of strings
that all ﬁt some speciﬁed format, and one desires an en-
cryption scheme mapping X to X. A classic algorithm
due to Goldberg and Sipser (GS) [12] shows that, given a
DFA for X, there exists an efﬁciently computable func-
tion rank : X ! ZN , where |X| = N and rank(x)
is deﬁned to be its position (its “rank”) in the shortlex
ordering of X. In addition, rank has an efﬁciently com-
putable inverse unrank : ZN ! X, so that unrankL(i)
is the i-th string in the ordering of L. Then to encrypt
a string x 2 X: (1) rank the input x to yield a num-
ber a   rank(x), (2) encipher a, giving a new number b,
then (3) unrank b to yield the ciphertext y   unrank(b),
which is an element of X.
BRRS focus on FPE for sets X that are a slice of a
language L, that is X = L\ ⌃n for some n and where ⌃
is the alphabet of L. Relatedly, we deﬁne a range-slice
of a language L as X = L \ (⌃n [ ⌃n+1 [ ··· [ ⌃m),
for n  m. The latter is superior because it offers greater
ﬂexibility, although not explored by BRRS. Still, extend-
ing BRRS to an FPE scheme over the entire (regular)
language is possible, by establishing a total ranking one
slice at a time. The main disadvantage of the BRRS
scheme is that it requires a DFA to represent the set X.
For most users, this is an unnatural way to specify lan-
guages, or slices thereof.

We quickly note that the BRRS algorithm may be sus-
ceptible to timing-based side-channel attacks, since rank
is not constant time. Timing information may therefore
leak partial information about plaintexts. We leave to
future work exploration of this potential security issue,
which extends to libfte and other non-constant-time mes-
sage encodings as well.
The FFX scheme.

Bellare, Rogaway, and Spies [7]

specify the FFX mode of operation, which is a speciﬁc
kind of FPE scheme and is based on the BRRS work [5].
FFX takes a parameter 2  r  216, the radix, and en-
crypts a plaintext P 2 L = S`{0, 1, . . . , r − 1}` to a
ciphertext in L with |L| = |P|. The length ` ranges
between a minimum value of 2 (or 10, if r ≥ 10) and
232 − 1. For example, FFX[10] enciphers strings of dec-
imal digits to (same length) strings of decimal digits;
FFX[8] does likewise for octal strings. In addition, FFX
has an extra “tweak” input, making it a length-preserving
tweakable cipher, in the sense of [17]. The tweak allows
FFX to support associated data.

We are aware of no public, open-source implementa-
tions of FFX, though there do exist proprietary ones [3].
Even given such an implementation, the formats sup-
ported by FFX are not as general as we might like.
For example, the scheme does not support domain ZN
when N is not expressible as r` for the supported
radices r. One can rectify this using cycle walking [8]
but the burden is on developers to properly do so, hinder-
ing usability. Moreover, the user is left to determine how
best to map more general formats into the set of formats
that FFX supports.
Format-transforming encryption. Dyer, Coull, Risten-
part and Shrimpton (DCRS) [11] introduced the notion
of format-transforming encryption, and gave a purpose-
built scheme that mapped bitstring plaintexts to cipher-
texts belonging to a speciﬁed regular language. Their
FTE scheme was built to force protocol misidentiﬁcation
in state of the art deep-packet-inspection (DPI) systems
used for Internet censorship.

The DCRS scheme is randomized, which lets it tar-
get strong privacy goals for the plaintexts (namely, se-
mantic security [13]), and also naturally aligns with us-
ing standard encryption schemes as building blocks. The
scheme itself is similar in spirit to BRRS: the plaintext
bitstring is encrypted using an authenticated encryption
scheme, the resulting intermediate ciphertext interpreted
as a number, and this number is then unranked into the
target language. Like BRRS, this scheme works on slices
of a given regular language.

USENIX Association  

23rd USENIX Security Symposium  879

3

DCRS observe that regular expressions provide a
friendlier programming interface for specifying inputs.
But to use the GS scheme for ranking/unranking, they
must ﬁrst convert the given regular expression to an NFA
and then from an NFA to a DFA. The last step often leads
to a large blowup in the number of states, sometimes ren-
dering the process completely intractable. (Examples of
such regexs, and the associated NFA and DFA sizes, are
given in Table 6 in Section 6.) Even when the process is
tractable, the precomputed tables that DCRS and BRRS
use to implement ranking require space that scales lin-
early in the number of states in the DFA. Many of the for-
mats used by DCRS require several megabytes of mem-
ory; in one case, 383 MB. This is prohibitive for many
applications, especially if one wants to keep several po-
tential formats in memory.

Thus, in many instances it would be preferable to use
the NFA representation of the given regex, but BRRS
showed that ranking given just the NFA representation
of a regular language is PSPACE-hard. Building any FPE
or FTE scheme that works directly from an NFA has re-
mained an open problem.

We also note that developers might hope for a gen-
eral purpose FTE scheme, that takes arbitrary regular ex-
pressions for the input and output formats, and that can
be built from existing deterministic cryptographic prim-
itives (e.g., wideblock tweakable blockciphers) or ran-
domized ones (e.g., authenticated encryption schemes).
But actually instantiating such a scheme presents an ar-
ray of algorithmic and engineering choices; in the current
state of affairs, expert knowledge is required.
Summary. While a number of approaches to FPE and
FTE exist, there is a gap between theory and developer-
friendly tools.
Implementations are non-existent, and
even expert developers encounter challenges when im-
plementing schemes from the literature, including: un-
derstanding and managing memory requirements, devel-
oping a “good” construction, or engineering the plain-
text/ciphertext format pair. Finally, there exist funda-
mental performance roadblocks when using some classes
of regular expressions. This is compounded by the fact
that, a priori, it isn’t obvious when a given regex will
raise these roadblocks.

3 Overview of libfte

To aid adoption and usage of FPE and FTE, we de-
veloped a set of tools known collectively as libfte. At
libfte has two primary components (see
a high level,
Figure 3): a standalone tool called the conﬁguration as-
sistant, and a library of algorithms (implemented in a
mixture of Python and C/C++) that exposes an API for
encryption and decryption via a number of underlying

{ s 2 L(R)(cid:31)(cid:31) ↵  |s|  β }, where L(R) is the set

FPE/FTE schemes. Loosely, the API takes a conﬁgura-
tion, describing what algorithms to use, and some key
inputs for those algorithms, while the assistant helps de-
velopers determine good conﬁgurations. Let us start by
talking about the assistant.
Conﬁguration assistant.
A format is a tuple F =
(R, ↵, β), where R is a regular expression, and ↵  β
are numbers. A format deﬁnes a set of strings L(F) =
of strings matched by R. Following traditional naming
conventions, we call L(F) the language of the format.
Because of its wide-spread use, in libfte the input R is
speciﬁed in Perl-Compatible Regular Expression syntax.
However, we note that PCRE syntax allows expressions
that have no equivalent, formal regular expression. For
instance, PCRE expressions using \1,\2, ... (where \1 is
a back-reference to the ﬁrst capture group; see [1]) are
not even context free, let alone regular. Thus, libfte ac-
cepts expressions built from a subset of the full PCRE
syntax.

Our conﬁguration assistant takes as input two formats,
one describing the format of plaintext strings (FP ), and
one describing the desired format of ciphertext strings
(FC). It also accepts some “preference parameters”, for
example specifying the maximum memory footprint of
any scheme considered by the assistant, but these are set
to some reasonable default value if not speciﬁed. It then
runs a battery of tests, in an effort to determine which
conﬁgurations will result in FPE/FTE scheme that abide
by the user’s inputs. Concretely, the assistant outputs a
table listing various possible conﬁgurations (some con-
ﬁgurations may not be possible, given the user’s input),
along with information pertaining to expected perfor-
mance and memory usage. Given the user’s preferences,
the table lists the best option ﬁrst. In the case that no
available conﬁguration is possible, the assistant provides
information as to why, so that the user can alter their in-
puts and try again.
The encryption API. The algorithm library exposes an
encryption API that takes as input an encryption conﬁg-
uration, which consist of a plaintext format, a cipher-
text format, and a conﬁguration identiﬁer. The latter is
a string that speciﬁes the desired methods for perform-
ing ranking, unranking, encryption and decryption. The
library performs all necessary precomputations (initial-
ize rankers, build look-up tables, etc.) in an initialization
function and returns a handle to an object that can per-
form encryption and decryption, according to the speci-
ﬁed conﬁguration. Currently, ten conﬁgurations are sup-
ported by libfte (see Section 6 for descriptions).
Roadmap.
In Sections 4 and 5 we describe in detail
the algorithms that result in these conﬁgurations. In Sec-
tion 4 we detail a new type of ranking algorithm, what

880  23rd USENIX Security Symposium 

USENIX Association

4

input/output 

format

encryption is
(randomized | 
deterministic)

…

utilization | runtime 

prefer (memory 
performance)

M

input
format

output
format

…

…

…

valid
conﬁg.

valid
conﬁg.

invalid
conﬁg.

valid
conﬁg.

rank

a

encrypt

b

“valid?”
Y
N
“try again”

b

unrank

C

Figure 3: Left: The libfte conﬁguration assistant (built against the library) helps users create formats that meet their
speciﬁc performance requirements. The assistant takes an input/output format pair and uses a decision-tree process
to determine if the formats are valid. If the formats are deemed valid, performance statistics are reported for the
instantiated scheme(s). Right: The library implements APIs for FPE/FTE schemes. Shown is a diagram of the basic
ﬂow of our FPE/FTE schemes. As input it takes an input/output format and message M and returns a ciphertext C.

we call relaxed ranking, that allows us to work more di-
rectly with regular expressions (in particular, their equiv-
alent NFAs), and sidestep the PSPACE-hardness obsta-
cle. In Section 5, we lay out methods of combining re-
laxed ranking with standard cryptographic primitives to
build both deterministic and randomized FPE and FTE
schemes. For deterministic schemes, we leverage a tech-
nique called cycle walking, and for randomized schemes,
we employ rejection sampling.

Then in Section 6 we describe speciﬁc instantiations
of these schemes, and explain how the conﬁguration as-
sistant works in more detail. Finally, in Section 7 we
show how these schemes can be put to work in three dif-
ferent use cases: database encryption, web form encryp-
tion, and network monitor circumvention.

4 Fast, Relaxed Ranking

The rank-encipher-unrank method for constructing
FPE/FTE schemes needs efﬁcient techniques for map-
ping strings in a regular language L to positive integers
as well as computing the inverse operation (mapping pos-
itive integers back to strings in the language). Exist-
ing techniques are often impractical for two main rea-
sons. First, the traditional DFA-based ranking requires
the construction of a DFA corresponding to a regular
expression. DFAs for some regular expressions can be
very large. For instance, the minimum DFA for the regex
(a|b)⇤a(a|b){20} has 1 + 221 states. Second, the num-
bers involved in ranking can be very large (for languages
with many strings) and operations on these integers can
therefore be computationally expensive. As an extreme
example, ranking a 10, 000-byte long element accepted
by the regex .⇤ requires numbers of up to (28)10000 bits,
or 10, 000 bytes. This section tackles these two chal-

lenges.

4.1 Relaxed Ranking
We introduce a framework for building FPE and FTE
schemes directly from NFAs. The resulting algorithms
will often use signiﬁcantly less memory than the DFA ap-
proach, thus enabling general-purpose regex-based rank-
ing in memory-constrained applications. For instance,
the NFA for the regex (a|b)⇤a(a|b){20} has 48 states.
A key insight is that we can circumvent the negative
result about NFA ranking if we shift to a relaxed rank-
ing approach, which we formally deﬁne in a moment.
This will require, in turn, constructing FPE and FTE
schemes given only relaxed ranking which we address
in Section 5.

4.1.1 Relaxed Ranking Schemes
Informally, a relaxed ranking of a language L relaxes the
requirement for a bijection from L to Z|L|.
Formally, a relaxed ranking scheme for L is a pair of
functions RankL and UnrankL, such that:
1. RankL : L ! Zi is injective, i ≥ |L| (Note that
we capitalize ‘Rank’ to distinguish relaxed ranking
from ranking.)

2. UnrankL : Zi ! L is surjective; and
3. For all X 2 L, UnrankL(RankL(X)) = X.
The last condition means that we can correctly invert
points in the image of L, denoted Img(L) ✓ Zi. Note
that a ranking is a relaxed ranking with i = |L|.
DFA-based ranking revisited. As a thought experi-
ment, one can view the traditional GS DFA-based rank-
ing for regular languages as follows: let I be the set of all

USENIX Association  

23rd USENIX Security Symposium  881

5

accepting paths in a DFA. First, one maps a string X 2 L
to its accepting path ⇡X 2 I. Then, one maps ⇡X to an
integer via an (exact) ranking. The composition of these
two functions yields a ranking function for all strings in
L. In the DFA ranking algorithms of [5, 12], these two
steps are merged.
A two-stage framework. We can use this two-step pro-
cedure to build efﬁcient relaxed ranking algorithms. Sup-
pose we desire to build a relaxed ranking function RankL
from a given set L into Zi. We ﬁrst identify three com-
ponents:
1. an intermediate set I for which we can efﬁciently
perform ranking, i.e., there is an efﬁcient algorithm
for rankI : I ! Zi where i = |I|;

2. an injective function map : L ! I; and
3. a surjective function unmap : I ! L such that for
We then deﬁne

all X 2 L it holds that unmap(map(X)) = X.

RankL(X) =rank

I(map(X))

UnrankL(Y ) =unmap (unrankI(Y ))

Should unmap additionally be injective, then RankL is a
bijection, and we have (strict) ranking.
At ﬁrst glance, this framework may seem to not have
accomplished much as we rely on a strict ranking to real-
ize it. But we will ensure that the language I allows for
strict ranking, and so the framework allows us to trans-
form the problem of ranking from a difﬁcult set (L) to an
easier one (I).
4.1.2 Relaxed Ranking Using NFAs
We construct relaxed ranking for NFAs using the ap-
proach above. We use as intermediate set I the set of
all accepting paths in the NFA. To map into this set, for
each string in L we deterministically pick an accepting
path (a process called parsing). To rank on I we de-
ﬁne a path ordering, and generalize the Goldberg-Sipser
ranking algorithm for DFAs to count paths based on this
ordering.

Recall that an NFA is a 5-tuple M = (Q, ⌃, δ, q0, F ),
where Q is a ﬁnite set of states, ⌃ is the alphabet, δ ✓
Q ⇥ ⌃ ⇥ Q is the transition relation2, q0 2 Q is the
start state, and F ✓ Q is the set of ﬁnal (or accepting)
states. If (q, a, q0) 2 δ then M may transition from state
q to state q0 when the current input symbol is a. We also
write a transition ⌧ = (q, a, q0) 2 δ as q a! q0, where q
is the source and q0 is the destination of ⌧.
A path ⇡ in M is a sequence of transitions
ajn! qin ·

aj2! qi2 ··· qin−1

aj1! qi1

qi0

2We assume that there are no ✏-transitions, but this is without loss
of generality as there are standard methods to efﬁciently remove them
from an NFA.

Path ⇡ can also be expressed as a sequence of transitions
⌧1⌧2 ··· ⌧n, where n = |⇡| is the length of ⇡. The sufﬁx
⇡1 of the path ⇡ is ⌧2 ··· ⌧n, and we have ⇡ = ⌧1⇡1. The
sequence of characters in the path is ⇡|⌃ = aj1 aj2 ...ajn.
The intermediate set I. An accepting path is one that
ends in an accepting state. Let AccM(q) be the set
of accepting paths starting from state q. We let I =
AccM(q0).
The functions map and unmap. We must map from L
to I and back. The latter is simpler: deﬁne unmap(⇡) to
be the word ⇡|⌃. This is fast to compute, in time linear in
|w|. The forward direction map(w) requires a determin-
istic choice for an accepting path for w. This is called
parsing. Any suitable parsing algorithm will work, but
we note that the most obvious algorithms may be quite
inefﬁcient. For example, simply recording all accepting
paths while running the NFA runs in time exponential in
|w| in the worst case.
Linear-time parsing. We now give the (to the best of
our knowledge) ﬁrst algorithm for determining a com-
pact representation of all of an NFA’s accepting paths for
a string w. Then map(w) simply runs this algorithm for
w and outputs the lexicographically least accepting path.
Our algorithm constructs an implicit representation of a
directed-acyclic graph (DAG) representing all accepting
paths for w. The lexicographically least accepting path
for w can then be found using a simple traversal of the
DAG. Next we describe the algorithm in detail.

Let M = (Q, ⌃, δ, q0, F ) be an NFA, Q0 ✓ Q, and
c 2 ⌃. We denote by δ(Q0, c) the set of states q such that
(q0, c, q) 2 δ for some q0 2 Q0, and by δ−1(Q0, c) the set
of states q such that (q, c, q0) 2 δ for some q0 2 Q0.
Consider a string w = c1c2...cn. Traditional NFA
matching starts with a frontier of states F0 = {q0}, and
at every position k in w it computes Fk = δ(Fk−1, ck).
The string is accepted if Fn \ F 6= ;. However, this
does not allow easy recovery of an accepting path, even
if all Fk sets are saved. The main reason for this is that
there might be states in the frontiers that do not lead to
an accepting state. To work around this, we also scan
the input backwards, maintaining a backwards frontier
set of states where Bn = F , and Bk−1 = δ−1(Bk, ck).
Given the sequences {Fk} and {Bk}, with k = 0, ..., n,
we compute {Sk} where Sk = Fk \ Bk. The set Sk
contains all states reachable from the start state follow-
ing transitions on c1...ck such that ck+1ck+2...cn is an
accepting path. Together, {Sk} and the NFA transitions
of the form (q, ck, q0) with q 2 Sk−1 ^ q0 2 Sk, form an
implicit Direct Acyclic Graph (DAG) representation of
all accepting paths for w. Finally, we traverse this DAG
starting from q0 2 S0 and following the lexicographi-
cally smallest transitions, which yields map(w).
NFA path ranking. All that remains is to give a strict

882  23rd USENIX Security Symposium 

USENIX Association

6

ranking algorithm for I, the set of accepting paths in
the NFA. Here, we can adapt techniques from the DFA-
based ranking by Goldberg and Sipser. Their algorithm
can be viewed as a recursive procedure for counting the
number of accepting DFA paths that precede a given path
in lexicographical order.

Let T (q, n) be the number of paths of length n in
AccM(q). Note that, for all q 2 Q and 0  i  n,
the value of T (q, i) can be computed in polynomial time
using a simple dynamic-programming algorithm.

1 and ⇡2 = ⌧2⇡1

2, then this order is:

(1)

2�
1 ≺ ⇡1

Assume that the NFA transitions are enumerated ac-
cording to a total ordering, and that ⌧ l ⌧0 means that
⌧ precedes ⌧0 according to this order. The ordering
on transitions induces a lexicographical ordering ’≺’ on
paths (which are sequences of transitions). Formally, if
⇡1 = ⌧1⇡1
⇡1 ≺ ⇡2 () ⌧1 l ⌧2 _�⌧1 = ⌧2 ^ ⇡1
Let rank(⇡) be the number of accepting paths ⇡0 ≺ ⇡
that precede ⇡ in the lexicographical order on paths. It
follows that, rank(✏) = 0 (the rank of the empty string
is 0), and for any ⇡ = ⌧ ⇡1 2 AccM(q), we have:
rank(⇡) = rank(⇡1) + X(q,c0,q0)l⌧
T (q0, n − 1)
Note that the sum is over transitions ⌧0 = (q, c0, q0) 2 δ
that precede ⌧ in transition order, ⌧0 l ⌧. In words, we
are summing over all outgoing edges from q that lead
to paths that are lexicographically smaller than the paths
that follow the transition ⌧. Unrolling the recursion gives
us an iterative procedure for ranking accepting paths of
length n that can be efﬁciently implemented via dynamic
programming.

(2)

To conclude, the relaxed ranking for a string w ac-
cepted by an NFA is Rank(w) = rank(map(w)), and the
reverse is Unrank(r) = unmap(unrank(r)).

4.2 Large Integer DFA/NFA Optimization
We present a simple but effective optimization that
speeds up both NFA and DFA-based ranking. In prac-
tice, ranking efﬁciency depends on how fast we evaluate
the sum in equation (2), and this depends on the precise
deﬁnition of the transition order. We deﬁne this order so
that we can replace multiple large-integer additions with
a single multiplication. Our experiments conﬁrmed that
this replacement indeed resulted in faster code.

Observe that equations (1) and (2) used for path rank-
ing depend only on transition (edge) order and structure
of the automaton. This observation is valid for both NFA
and DFA. Previous, traditional, DFA ranking is given by
these equations and standard lexicographical ordering,
using character order: (q, c0, q0) l (q, c00, q00) () (c0 <

c00). In a DFA c0 = c00 =) q0 = q00. But equation (1)
does not have to use standard lexicographical ordering.
Our idea is to give priority to states over characters.
We assume a state and character order given by an ar-
bitrary but ﬁxed enumeration of Q and ⌃, and use the
following order for transitions originating from the same
state q: (q, c0, q0)l(q, c00, q00) if-and-only-if (q0 < q00) or
q0 = q00 and c0 < c00. This speciﬁc order allows for pre-
computation in equation (2). In equation (2) we can re-
place all the terms T (q0, n−1) which correspond to tran-
sitions (q, c0, q0) l ⌧ with n[q, q0] ⇥ T (q0, n−1), where
the precomputed value n[q, q0] represents the number of
transitions from q to q0. Similarly, all the terms corre-
sponding to edges ⌧0 = (q, c0, q00), where ⌧0 l ⌧ =
(q, c00, q00), can be replaced by r[q, c00, q00] ⇥ T (q00, n
−1), where r[q, c00, q00] is the number of such transitions.
These optimizations have beneﬁt, because the numbers
T (q, n) can be very large multiple precision integers.

5 Building FTE Schemes

Now we turn to building FTE schemes, treating FPE in
passing as a special case of FTE. We speciﬁcally give
two methods for composing relaxed-ranking algorithms
with an underlying cryptographic primitive to make an
FTE scheme. For deterministic FTE, the cryptographic
component is a tweakable cipher (e.g. FFX), and we
call the composition cycle-walking FTE. For random-
ized FTE, the cryptographic component is an authenti-
cated encryption scheme, and we call the composition
method rejection-sampling FTE. (Impatient readers can
look ahead to Figure 4 for the pseudocode.) We delay
speciﬁc instantiations of the schemes until Section 6.1.
Informal FTE scheme syntax. We provide a formal
treatment of FTE scheme syntax in the full version. We
provide a simpler, more informal discussion of it here;
this will sufﬁce for what follows. An FTE scheme is a
pair of algorithms (Enc, Dec). The FTE encryption al-
gorithm Enc takes as inputs
(cid:127) a key K
(cid:127) a pair of formats (FP ,FC) that describe the language
L(FP ) of plaintext inputs, and the language L(FC)
of ciphertext outputs

tional)

(cid:127) a plaintext string M 2 L(FP )
(cid:127) associated data, and encryption parameters (both op-
and outputs a ciphertext string C 2 L(FC), or a special
“failure” symbol ?. Associated data is data that must
be bound to the underlying plaintext, but whose privacy
is not required. (For example, metadata meant to pro-
vide context for the use or provenance of the plaintext.)
We allow for encryption parameters to help enforce spe-

USENIX Association  

23rd USENIX Security Symposium  883

7

K (M ) :

EncT
c0   n2s(r, RankX (M ))
i   0
Do
if i > imax then Ret ?
i   i + 1
ci   ET
K (ci−1)
v   s2n(r, ci)
Until v 2 Img(X)[ Img(Y )
If v 2 Img(Y ) then
Ret UnrankY (v)
Ret ?

K (C) :

DecT
p0   n2s(r, RankY (C))
i   0
Do

i   i + 1
pi   DT
K (pi−1)
u   s2n(r, pi)
Until u 2 Img(X)
Ret UnrankX (u)

K (M ) :

EncT
a   RankX (M )
M0   n2s(t − ⌧, a)
i   0
Do
if i > imax then Ret ?
i   i + 1
K (M0)
C0  $ E T
b   s2n(t, C0)
Until b 2 Img(Y )
Ret UnrankY (b)

K (C) :

DecT
b   RankY (C)
C0   n2s(t, b)
If C0 = ? Ret ?
M0  $ DT
K (C0)
If M0 = ? Ret ?
a   s2n(t − ⌧, M0)
Ret UnrankX (a)

Figure 4: Left: Cycle-walking deterministic FTE. n2s(r, a) returns the string representing number a in radix r, and
s2n(r, b) returns the number whose radix r representation is b. The parameter imax determines the maximum number
of iterations. Right: Rejection-sampling randomized FTE.

Now, ﬁx integers

If RankX and
ate sets I(X) for X and I(Y ) for Y .
RankY are the corresponding relaxed-ranking functions,
let Img(X) be the image of X under RankX, and like-
wise Img(Y ) be the image of Y under RankY . Deﬁne
(Recall that if we
NX = |I(X)| and NY = |I(Y )|.
are using NFA-based ranking over either X or Y , these
values can be signiﬁcantly larger than |X| or |Y |.) We
assume that both NX , NY are ﬁnite.
Say one has a tweakable cipher3 E that natively
supports strings over a variety of radices, e.g. FFX.
(At a minimum, there are many constructions of se-
cure tweakable ciphers that support radix 2, e.g. [9,
14, 15].)
r ≥ 2 and t ≥
dmax{logr(NX ), logr(NY )}e, so that a string of t sym-
bols from {0, 1, . . . , r − 1} sufﬁces to represent the
relaxed-rankings of X and Y . Then if E can encipher
the set of strings {0, 1, . . . , r − 1}t, we can encrypt a
plaintext M 2 X as shown on the left side of Figure 4.
Cycle walking. A well-known fact about permutations
is that they can be decomposed into a collection of dis-
joint cycles: starting from any element a in the domain of
the permutation ⇡, repeated application of ⇡ will result in
a sequence of distinct values that eventually ends with a.
Black and Rogaway [8] were the ﬁrst to exploit this fact
to build ciphers with non-standard domains, and we use
it, too. For any ﬁxed K and T , the mapping induced by
K is a permutation. Thus, inside the Do-loop, the dis-
ET
K(c0)), and
tinct strings c0, c1   ET
so on form a sequence that eventually must return to c0.
Intuitively, if we want a ciphertext that belongs to a par-
ticular subset S ✓ {0, 1, . . . , r − 1}t, we can walk the
cycle until we hit a string ci 2 S.
There are, however, two important details to consider.
The ﬁrst is that encryption is not guaranteed to hit any

K(c0), c2   ET

K(ET

ciﬁc failure criteria, which will become clear when we
describe our schemes. We write EncT,P
K (M ) for FTE
encryption of message M, under key K, using associ-
ated data T and parameters P . To ease the burden of
notation (slightly), we typically do not explicitly list the
parameters as inputs. The encryption algorithm may be
randomized, meaning that fresh randomness is used for
each encryption.

The FTE decryption algorithm Dec takes as input
(FP ,FC), K, a ciphertext C, and the associated data T
(if any), and returns a plaintext M or ?. The decryption
algorithm is always deterministic.
Unlike conventional encryption schemes, we do not
demand that EncT,P
K (M ) always yield a valid ciphertext,
or always yield ?, when T, P and K are ﬁxed. Instead,
we allow encryption to “fail”, with some small probabil-
ity, to produce a ciphertext for a any given plaintext in
its domain. Doing so will permit us to give simple and
natural FTE schemes that would be ruled out otherwise.
In general, the formats can change during the lifetime
of the key, even on a per-plaintext basis.
(Of course,
changes must be synchronized between parties.) When
we talk about an FTE scheme being over some given
formats, or their languages, we implicitly have in mind
some notion of a format-session, during which the for-
mats do not change.

5.1 Cycle-walking (deterministic) FTE
To build deterministic FTE schemes we take inspira-
tion from BRRS rank-encrypt-unrank. However, accom-
modating format transformations and, especially, NFA-
based language representations introduces new chal-
lenges.

To begin, let X = L(FP ) and Y = L(FC). As-
sume that we perform relaxed ranking using the two-
stage framework in Section 4.1.1, with the intermedi-

3If the FTE scheme does not need to support associated data, then
the underlying cipher need not be tweakable, and references to T in the
pseudocode can be dropped.

8

884  23rd USENIX Security Symposium 

USENIX Association

string ci 2 S. For example, if the subset is small, or the
cycle is very short. So encryption must be equipped with
test that tells it when this has happened, and ? should
be returned. The second is that there must be a test that
uniquely identiﬁes the starting string c0. This is because
decryption should work by waking the cycle in reverse.
Absent a test that uniquely identiﬁes c0, it may not be
clear when the reverse cycle-walk should stop.

Our implementation deals with both of these issues.
In particular, c0 is the t-symbol string that results from
relaxed-ranking our FTE plaintext input M. By deﬁni-
tion, c0 is a string that, when viewed as a radix-r integer,
is in Img(X). We desire to ﬁnd a ci that, when viewed
as an integer, is in Img(Y ), since this is the set of in-
tegers that yield ciphertexts in Y that will be properly
decrypted. Intuitively, the walk should halt on the ﬁrst i
for which this is true. But then, if any of c1, . . . , ci−1
represent integers that are in Img(X), proper decryption
is not possible (because we do not know how many steps
to go from ci back to c0). Thus our cycle-walking en-
cryption checks, at each step, to see if the current walk
should be terminated because decryption will not be pos-
sible, or because we have found a ci that will yield a
ciphertext Y that will decrypt properly. We also allow
cycle-walking FTE to take a maximum-number-of-steps
parameter imax, and encryption fails if that number of
steps is exceeded.
Efﬁciency.
The standard security assumption for a
tweakable cipher is that, for any secret key K, and any
K is indis-
associated data T , the mapping induced by ET
tinguishable from that of a random permutation. Mod-
K as such, the expected number of steps be-
eling ET
fore the cycle-walk terminates is at most rt/|Img(X) [
Img(Y )| (a conservative bound) and never more than
imax. Assuming the walk terminates before imax steps,
then the probability that the encryption succeeds is ps =
|Img(Y )|/|Img(X) [ Img(Y )|. Since relaxed ranking
is injective, |Img(X)| = |X| and |Img(Y )| = |Y |, so
ps ≥ 1/(1 + |X|/|Y |). Thus we expect that ps is quite
close to 1 if |Y |  |X|.
Each step of the cycle-walk requires checking v 2
Img(X) [ Img(Y ), which can be done by checking v 2
Img(X) ﬁrst (signaling termination of the walk), and
then v 2 Img(Y ) (signaling successful termination). A
straightforward way to implement the last is to test if v =
RankY (UnrankY (v)) or, using our two-stage viewpoint
on relaxed ranking, map(Unrank(v)) = unrankI(v),
which may be faster. Checking v 2 Img(X) can be done
likewise.
Recall that the NFA representation of a regex, un-
like a DFA representation, may have many accepting
paths for a given string in its language. This can lead
to NX  |X| = Img(X) or NY  |Y | = Img(Y ),
hence, potentially, rt  |Img(X) [ Img(Y )|. When

this happens, the resulting in cycle-walking scheme may
be prohibitively inefﬁcient in some applications.
Simpliﬁcations. We note that the cycle-walking tech-
nique is used in [5], as well, but they restrict to the much
simpler case that X = Y . More generally when we
know that Img(X) ✓ Img(Y ), we can simplify our
construction. One may still need to cycle-walk in this
case if rt > |Y |. For example, say one desires to use
r = 2 (binary strings) but the larger of |X|,|Y | is not
a power of two. But when Img(X) ✓ Img(Y ) we
know that, if the encryption cycle-walk terminates be-
fore imax steps, then it always ﬁnds a point in Img(Y ),
i.e. ps = 1. Also, the expected number of steps is at most
rt/|Img(Y )| = rt/|Y |, again modeling ET
K as a random
permutation. Finally, we note that the walk termination
test can be simpliﬁed to v 2 Img(Y ), and encryption can
thereafter immediately return UnrankY (v).
Security. We mentioned, above, that the standard secu-
rity assumption for a tweakable cipher is that, when the
key K is secret, every associated data string T results in
K(·) being indistinguishable from a random permuta-
ET
tion. Under this assumption, it is not hard to see that the
cycle-walking construction outputs (essentially) random
elements of the set Y = L(Fc), when it does not output
K(ci−1) in the cycle-walk is a ran-
?. Intuitively, each ET
dom string (subject to permutivity), so the corresponding
number v represented by the string is random, too. Thus,
if v 2 Img(Y ), it is a random element of this set, result-
ing in a random element of Y being chosen when v is
unranked.

In the full version we formally deﬁne a security no-
tion for deterministic FTE schemes, and give a theorem
stating the security of our construction relative to this se-
curity notion.

5.2 Rejection-Sampling (randomized) FTE
We now turn our attention to building randomized FTE
schemes. Let ⇧ = (K,E,D) be a conventional, ran-
domized, authenticated-encryption scheme with support
for associated data (AEAD). We assume that this scheme
has a ﬁxed ciphertext stretch ⌧; this is typical of in-use
AEAD schemes. To build a randomized FTE scheme us-
ing a generalized ranking scheme, we use a rejection-
sampling approach. Let t be the least integer such that
both of the following are true: (1) |I(X)|  2t−⌧ , and
(2) |I(Y )|  2t. Then to encrypt M 2 X, or de-
crypt C 2 Y , under key K and associated data T , we
do as shown on the right side of Figure 4.
A standard security assumption for AEAD schemes is
that its ciphertexts are indistinguishable from strings (of
the same length) that are uniformly random. Under this
assumption, treating each C0 as a random t-bit string, the

USENIX Association  

23rd USENIX Security Symposium  885

9

Sub-Component
Regular Expression Parser
DFA Minimizer
NFA/DFA Ranking
FFX
FPE/FTE
Conﬁguration Assistant

Written in...
C/C++/Flex/Bison
C/C++
C/C++
C++
C++
C++/Python

Lines of Code
2,057
1,166
2,752
842
870
731

Table 5: The sub-components of libfte.

K is 2t/|Img(Y )| =
expected number of invocations of E T
2t/|Y |. (And certainly no more than imax.)
Under this standard security assumption, it is intuitive
that any element of Y = Fc returned by our rejection-
sampling FTE is a uniform one. If each C0 is indistin-
guishable from a random string, then the corresponding
number b represented by C0 is random, too. Hence if
b 2 Img(Y ), then it is a random element of that set, and
so the element of Y that results from unranking b will be
random.

We give a formal security notion for randomized
FTE, and a security theorem for rejection-sampling-
based FTE, in the full version.

6 Realizing LibFTE

In Section 5 we explored strategies for constructing
FPE/FTE schemes in theory. Now, let’s concretely de-
scribe the schemes implemented in libfte.
Implementation. The libfte implementation is a hy-
brid of C, C++, Python, Flex and Bison. We present a
detailed breakdown of the sub-components in Table 5.
We engineered a custom regular expression parser be-
cause off-the-shelf solutions did not expose the appro-
priate data structures necessary to implement our NFA
relaxed-ranking algorithm.

In addition to a native C++ interface, we also pro-
vide interfaces in Python and JavaScript for libfte. The
Python interface is exposed through a manually-written
wrapper around the C++ implementation. The JavaScript
interface is provided through C++-to-JavaScript compi-
lation.

6.1 Schemes Implemented in LibFTE
We use a shorthand notation to refer to types of libfte in-
stantiations. As an example, T-ND-$ is a an FTE scheme
that uses NFA-based ranking (Section 4.1) for the input
format, and DFA-based ranking (Section 4.2) for the out-
put format, and is randomized ($); T-ND denotes the
same, but the scheme is deterministic. FPE constructions
are similarly named, but begin with P.

For deterministic schemes (those without the ﬁnal $)
we use the cycle-walking construction, with FFX[2]
as the underlying tweakable cipher. For randomized
schemes, we use the rejection-sampling construction.
As the underlying encryption scheme, we employ the
Bellare-Rogaway “encode-then-encipher” paradigm [6],
prepending the result of RankX (M ) (interpreted as a
ﬁxed-length bitstring) with the appropriate number of
random padding bits, and applying FFX[2] to this. Be-
cause our particular application of randomized FTE does
not need support for associated data, the FFX tweak was
ﬁxed to an all-zeros string, and we do not need redun-
dancy padding in our encode-then-encipher scheme.

We note that, although we ﬁxed speciﬁc instantiations
of FPE/FTE schemes for the sake of a concrete evalua-
tion, there is no reason to restrict to these. In the ran-
domized scheme, for example, one could use CTR-AES
(with a random IV) and HMAC-SHA256 in an “encrypt-
then-mac” composition [4, 18] (including any associated
data in the mac-scope) for the underlying primitive.4

6.2 The LibFTE Conﬁguration Assistant
We now turn our attention towards the implementation
details of the libfte conﬁguration assistant. We di-
vide the internal workﬂow of the conﬁguration assistant
into three steps. First, we gather requirements from the
user, this is done by the user passing parameters to a
command-line interface. Then, we start with an initial
set of all possible FPE/FTE schemes (i.e., P-xx, T-xx, T-
xx-$) that one could instantiate, and use a decision tree
algorithm to eliminate schemes from the initial set that
do not satisfy user requirements. Finally, the conﬁgura-
tion assistant analyzes the set of all schemes that were
not eliminated in stage two, performs a battery of tests
on them, and returns the results to the user. We provide
a sample output of this tool in Figure 7.
Collecting requirements from the user. The command-
line conﬁguration assistant (see Figure 7) takes two re-
quired parameters, the input and output formats. In addi-
tion to the required parameters, the conﬁguration assis-
tant takes optional parameters, most notably: the mem-
ory threshold for the conﬁguration assistant to deter-
minize regexs, and the memory threshold for FPE/FTE
scheme instantiation.
Identifying feasible schemes. Next, the conﬁguration
assistant’s job is to eliminate schemes that fall outside
the user-speciﬁed requirements. It starts with a set of all
possible FPE/FTE schemes that one could construct (i.e.,

4One should keep in mind the interaction between the cipher-
text length overheads of AEAD and the expected number of steps in
rejection-sampling.

886  23rd USENIX Security Symposium 

USENIX Association

10

Input/Output Format

Scheme R

P-DD

P-NN

(a|b)*
(a|b)*a(a|b){16}
(a|a|b){16}(a|b)*
(a|b){1024}
(a|b)*
(a|b)*a(a|b){16}
(a|a|b){16}(a|b)*
(a|b){1024}

↵
0
16
16
1,024
0
16
16
1,024

β
32
32
32
1,024
32
32
32
1,024

2

18

1,026

States

131,073

DFA/NFA Memory
Required
4KB
266MB
36KB
34MB
6KB
73KB
103KB
68MB

3
36
51

2,049

Encrypt
(ms)
0.18
0.25
0.19
1.2
0.36
0.61
1,340
6.6

Decrypt
(ms)
0.18
0.21
0.18
1.2
0.35
0.60
1,340
6.6

Table 6: Performance benchmarks for P-DD and P-NN constructions, based on our Python API. The regular expres-
sions have been selected to highlight the strengths and weaknesses of the constructions. Recall that ↵ and β are upper-
and lowerbounds (respectively) on the length of strings used in a range slice.

$ ./configuration-assistant \
>
>

--input-format "(a|b)*a(a|b){16}" 0 32 \
--output-format "[0-9a-f]{16}" 0 16

==== Identifying valid schemes ====
WARNING: Memory threshold exceeded when

building DFA for input format

VALID SCHEMES: T-ND, T-NN,

T-ND-$, T-NN-$

==== Evaluating valid schemes
SCHEME ENCRYPT DECRYPT ... MEMORY
T-ND
T-NN
...

0.31ms ... 77KB
0.38ms ... 79KB

0.32ms
0.39ms

====

Figure 7: A sample execution of our conﬁguration as-
sistant for building an FTE scheme. The tool failed to
determinize the regex of the input format, and notiﬁes
the user that that T-ND, T-NN, T-ND-$ and T-NN-$ con-
structions are possible. Then reports on the performance
of these schemes.

P-xx, T-xx, T-xx-$). If the DFA can’t be built (within the
user-speciﬁed memory thresholds) for the input format,
then we eliminate P-Dx, T-Dx and T-Dx-$ schemes from
consideration. We repeat this process for the output for-
mat. Then we perform a series of additional checks — in-
volving the sizes of L(FP ), L(FC), the sizes of the inter-
mediate representations, the minimum ciphertext stretch
of underlying cryptographic primitives, etc. — to cull
away schemes that should not be considered further.
Evaluating feasible schemes. Finally, we consider the
set of schemes that remain from the previous step.
If
there are none, we output an error. Otherwise, we iterate
through the set of schemes and perform a series of func-
tional and performance tests against them. We have four-
teen quantitative tests, such as: the average time elapsed
to perform encryption/decryption, the (estimated) prob-
ability that encryption returns ?, and memory require-
ments. The ﬁnal result of the tool is a table output to
the user, each row of the table represents one scheme

and the columns are results from the quantitative tests
performed. The method for sorting (i.e., prefer memory
utilization, prefer runtime performance, etc.) is a user-
conﬁgurable parameter.

6.3 Performance

We conclude this section with benchmarks of our
libfte
implementation. All benchmarks were per-
formed on Ubuntu 12.04, with an Intel Xeon E3-1220 at
3.10GHz and 32GB of memory. Numbers reported are
an average over 1,000 trials for calls to our libfte Python
API. For memory utilization of each scheme, we mea-
sure the memory required at runtime to use the speciﬁed
formats. For encrypt benchmarks we select a random
string in the language of the input format and measure
the time it takes for encrypt to return a ciphertext. For de-
crypt benchmarks we select a random plaintext, encrypt
it, then measure the time it takes for decrypt to recover
the plaintext.

In Table 6 we have the performance of libfte for P-DD
and P-NN schemes. Note that (a|b)*a(a|b){16}
requires roughly four orders of magnitude less memory
using a P-NN scheme, compared to a P-DD scheme.
With the P-NN scheme for (a|a|b){16}(a|b)*,
the high encrypt cost is completely dominated by cycle
walking, we do roughly 720 FFX[2] encrypt calls per
P-NN call.
(The conﬁguration assistant would inform
the user of this, and the user would have the opportu-
nity to re-write the expression as (a|b){16}(a|b)*.)
For (a|b)*, the two constructions (i.e., P-DD, P-NN)
require a comparable amount of memory but the P-DD
construction is twice as fast for encryption/decryption.

Due to space constraints we omit benchmarks for T-
xx and T-xx-$ schemes in this section, and defer their
analysis to Section 7.

USENIX Association  

23rd USENIX Security Symposium  887

11

7 Exploring LibFTE Use Cases

We turn our attention to integrating libfte into third-party
applications. Our goal is to show that libfte is easy to
use, ﬂexible, and in some cases improves performance,
compared to other cryptographic solutions. In this sec-
tion we consider three use cases: database encryption,
web form encryption, and encryption using formats lifted
from a network monitoring device.

7.1 Databases
We start with integration of libfte into a PostgreSQL
database. For our database we used PostgreSQL 9.1 in
its default conﬁguration. Our server was Ubuntu 12.04
with an Intel Xeon E3-1220 v3 @ 3.10GHz and 32GB
of memory. We use the pgcrypto library that is included
in PostgreSQL’s contrib directory as our baseline cryp-
tographic library. We performed all tests with the Post-
greSQL client and server on the same machine, such that
network latency did not impact our performance results.
The integration of libfte into our database as Post-
greSQL stored procedures required 53 lines of plpython
code.

Pgbench is tool included with PostgreSQL to measure
database performance. As input, pgbench takes a de-
scription of a database transaction and runs the transac-
tion repeatedly, emulates concurrent users, and measures
statistics such as transactions per second and response la-
tency. We used pgbench’s default database schema and
transaction set for testing libfte’s impact on PostgreSQL
performance. The default pgbench testing schema simu-
lates a simple bank and has four tables: accounts, tellers,
branches, and history. The default transaction set for test-
ing includes three query types: SELECT (S), UPDATE
(U) and INSERT (I). There are three different transaction
types that can be selected using pgbench: S, USI, and
USUUI — for each transaction type the acronym repre-
sents the type and order of queries executed.

In order to test the performance impact libfte has on
PostgreSQL, we created four conﬁgurations for populat-
ing and accessing data in the database:
(cid:127) PSQL: The default conﬁguration and schema used
by the pgbench utility for its simple bank application.
No encryption is employed.

(cid:127) +AES: The default schema, with the following mod-
iﬁcations: the balance columns in accounts, tellers,
and branches are changed from type integer to
type bytea. To secure these ﬁelds we use AES128
in ECB mode with PKCS padding.

(cid:127) +AE: We use the same schema as +AES, but we
change our encryption algorithm to pgcrypto’s rec-
ommended encrypt function pgp sym encrypt,

Transaction
Type
S
USI
USUUI

Account Balance Queries

Transactions Per Second

+FPE
8,280
1,540
96.5

PSQL
38,500
2,380
99.2

+AES
30,246
2,259
97.5

+AE
8,380
1,580
97.2

Table 8: A comparison of
tions/second) for our four database conﬁgurations.

throughput

(transac-

which provides privacy and integrity of data.

(cid:127) +FPE: We use the default schema, but employ
a libfte
P-DD scheme with the format R  
\-[0-9]{9}, (R, 9, 10), to encrypt account bal-
ances (in accounts, tellers, and branches) in-place.
We note that in our evaluation we did not have the
option to compare libfte to a scheme that provides the
same functionality or security, as no prior scheme ex-
ists. We compare to +AES because it provides a base-
line performance that we would not expect libfte to ex-
ceed. The comparison to +AE, which provides privacy
and integrity, can be used as a baseline for the perfor-
mance of a cryptographic primitive implementation in a
widely-used, mature database product.
Performance For each conﬁguration and transaction
type we executed pgbench for ﬁve minutes with 50 ac-
tive customers, leaving all other pgbench parameters as
default.
In all conﬁgurations except PSQL, when per-
forming modiﬁcations to the database we perform an en-
crypt when storing the account balance. When retrieving
the account balance we recover the plaintext via a call to
the decryption algorithm.

In Table 8 we have the have the benchmark results
for transactions per second carried out by the server for
our four database conﬁgurations and three transaction
types. For the most complex transaction type (USUUI)
our +FPE conﬁguration reduces the number of transac-
tions per seconds by only 0.8%, compared to the +AE
conﬁguration. For the simplest query type (S), +FPE
reduces the transactions-per-second rate by only 1.1%,
compared to +AE. Compared to the +AES conﬁguration
the +AE and +FPE reduce the transactions per second
by roughly 72%. This is, in fact, not surprising as under
the hood the +FPE conﬁguration relies on FFX, which in
turn calls AES at least ten times.

In Table 9 we have the average latency for each of the
ﬁve different query types. This measures the amount
of time elapsed between a client request and server re-
sponse. Compared to the +AE conﬁguration, +FPE in-
troduces no substantial latency.
Simultaneous encryption and compression. As one ﬁ-
nal test, we deploy a T-DD scheme in our PostgreSQL

888  23rd USENIX Security Symposium 

USENIX Association

12

Account Balance Queries

Average Latency (ms)

Query
(U) accounts
(S) accounts
(U) tellers
(U) branches
(I) history

PSQL
0.6
0.4
412
78
0.2

+AES
1.2
0.5
412
80
0.2

+AE
2.1
1.0
415
80
0.2

+FPE
2.1
1.0
420
84
0.2

Table 9: Average latency per query for each database
conﬁguration.

Credit Card Number Queries

Table Size
Query Avg.

PSQL
50MB
74ms

+AES
65MB
92ms

+AE
112MB
112ms

+FPECC
50MB
125ms

+FTECC
42MB
110ms

Table 10: FTE for simultaneous encryption and compres-
sion. The table size is the amount of space required on
disk to store the table. We also present the average query
time (over 1,000 trials) for selecting (and decrypting) 100
credit card numbers at random from 1 million records.

database to provide simultaneous privacy and compres-
sion. We augment the default pgbench database schema
to add a new table for credit card numbers. This table has
two columns: an account number of type integer and
a credit card number ﬁeld of type bytea. (Following
the structure of the pgbench schema, we do not add any
indexes to this table.) We start with the four conﬁgura-
tions we presented in our initial benchmarks. However,
we change our +FPE conﬁguration to a P-DD scheme
that encrypts 16-digit credit card number in-place and
call this +FPECC. Then we introduce a new conﬁgura-
tion, +FTECC, a T-DD scheme where our input format
is a 16-digit credit card number and our output format is
the set of all 7-byte strings.

In each conﬁguration we populated our database with
1 million random credit card numbers. For each database
conﬁguration, we have a breakdown (Table 10) of the
query cost to retrieve 100 credit card numbers at ran-
dom (and decrypt, if required) as well as the total size
of the new credit card table. Compared to the +AES and
+AE conﬁguration, our +FTECC conﬁguration requires
35% and 62.5% less space, respectively. We note that it
may be possible to employ additional compression in the
PSQL, +FPECC settings (e.g., an int to bitstring conver-
sion). However, such optimizations are not possible in
the +AES and +AE conﬁgurations.

We also highlight that, with respect to query times
(Table 10) our +FTECC conﬁguration modestly outper-
forms the +AE conﬁguration. Compared to +AES,
+FTECC introduces a 19.5% increase in query cost.

7.2 Web Forms
Next, we present a Firefox extension powered by libfte.
The job of this browser extension is to encrypt sensitive
contact information, client-side, in a Yahoo address book
contact form, prior to submission to the remote Yahoo
servers.
Browser extension. We tested our libfte-extension with
Firefox version 26, using our C++-to-JavaScript com-
piled libfte API. In addition to libfte , in roughly 200
lines of code, we implemented logic that was responsi-
ble for locating page elements to encrypt/decrypt. The
Yahoo-speciﬁc logic was minimal and consisted of map-
pings between form ﬁelds and FPE/FTE schemes.

Fields were manually speciﬁed using unique identi-
ﬁers (e.g., CSS id tags) and mapped to their correspond-
ing P-DD FPE scheme in JavaScript. There are many
options for determining what input/output formats to use
for a given scheme. For this proof-of-concept we started
with a set of formats we considered to be reasonable,
then progressively relaxed/increased constraints on the
formats appropriately until they were accepted by Ya-
hoo’s server-side validation. As a couple examples, we
found that the email address ﬁeld is required to have an
@ symbol, and all dates are required to be valid date
ranges. (e.g., month must between 1 and 12 inclusive)
We expect that such constraints could be identiﬁed pro-
grammatically, at scale, using a browser automation tool
such as Selenium [2].

Our Firefox extension exposes an “encrypt/decrypt”
drop-down menu to the user. Prior to saving a new con-
tact to their address book, the user can press the “en-
crypt” button to automatically libfte-encrypt all ﬁelds in
the form. To recover the encrypted data, they user visits
the page for a contact, then presses the libfte extension’s
decrypt button to recover the plaintext data. With fur-
ther engineering efforts this encryption/decryption pro-
cess could be transparent to the user. We present a
screenshot of our extension in Figure 11.

7.3 Network Monitors
Finally, we turn our attention to building T-xx-$ schemes
(as used in [11]) by lifting regular expressions from the
Snort IDS [19]. As far as these authors are aware, this
Snort IDS corpus of regular expressions is the largest and
most diverse (publicly available) set of regexes used for
deep-packet inspection.

In the initial exploration of FTE by Dyer et al. [11]
a fundamental limitation to their construction was the
need to perform a regex-to-DFA conversion for formats.
Unfortunately, this creates a natural asymmetry: systems

USENIX Association  

23rd USENIX Security Symposium  889

13

Figure 12: The CDF representing the fraction of the
Snort corpus that can be instantiated for a given memory
threshold. The CDF graph has a long tail and reaches
100% at 143MB for T-DN-$. We were unable to cal-
culate the threshold for T-DD-$ to reach 100%, due to
memory constraints on our test system.

pus that can be instantiated when constrained by a given
memory threshold, for each scheme. At 1MB, roughly
60% of the corpus can be instantiated using T-DD-$
ranking, compared to roughly 85% of the corpus with
T-DN-$ ranking. At 5MB, T-DN-$ is at roughly 97% and
T-DD-$ is at roughly 92%. If we increase the threshold
to 143MB (beyond the focus of the graph) we can instan-
tiate 100% of the corpus using T-DN-$. Yet, at at thresh-
old of 1GB, we are able to instantiate only 97.0% of the
corpus using T-DD-$.
In fact we were unable to con-
struct some schemes (due to memory constraints) using
T-DD-$, so we don’t know the exact threshold required
to reach 100% instantiation.

As a ﬁnal test we measured the total memory utiliza-
tion for instantiating the complete Snort corpus.
Ini-
tially, we instantiated all regular expressions in the cor-
pus using T-DD-$, which required a cumulative 8.8GB
of memory. Then we considered a “best case” scenario,
where, over the 97% of tractable regexs (those that we
could construct a T-DD-$ scheme) we took the minimum
of the T-DD-$ or T-DN-$ memory utilization. Using
the best-case approach we reduced memory utilization to
6.2GB, a reduction of roughly 30%. The best-case sce-
nario is, of course, biased against T-DN-$, as 3% of the
corpus couldn’t be instantiated with T-DD-$.

8 Conclusion

In this paper we presented a unifying approach for de-
ploying format-preserving encryption (FPE) and format-
transforming encryption (FTE) schemes. The approach
is realized via a library we call libfte, which has two
components: an ofﬂine conﬁguration assistant to aid en-
gineers in developing formats and understanding their
system-level implications, and an API for instantiating

Figure 11: Screenshot from our Firefox Browser Ex-
tension that encrypts the data ﬁelds of our Yahoo ad-
dress book, client-side, prior to transmission to the Ya-
hoo servers.

such as Snort are able to perform network monitoring di-
rectly from an NFA representation, but the construction
presented by Dyer et al. requires regex-to-DFA conver-
sion. In this section we show that we’ve overcome this
limitation — regular expressions that were intractable us-
ing the construction by Dyer et al. are no longer an ob-
stacle, given our new NFA ranking algorithm.
Snort IDS regex corpus. To build our corpus, we started
with the ofﬁcial Snort ruleset, version 2955, released Jan
14, 2014. Each rule in the ruleset contains a mixture of
values, including static strings or regular expressions to
match against trafﬁc. From each rule we extracted all
regular expressions (as deﬁned by the pcre ﬁeld) which
resulted in 6,277 expressions. Of these, 3,458 regular ex-
pressions compiled with our regular expression parser5.
For all regular expressions that compiled, if we were able
to instantiate their precomputation table in memory, we
were able to successfully utilize them for encryption.
Corpus evaluation. For each regular expression R in
the Snort corpus we attempted to build a T-DD-$ and
T-DN-$ scheme with an output format F   (R, 0, 256),
and input format that is a blog2 |L(F)|c-bit string. This
choice of libfte scheme and ↵ and β is motivated by the
construction in [11].

In Figure 12 we plot the CDF of the fraction of the cor-

5We don’t support greedy operators *? or case insensitivity
(?i...), which accounted for the majority of compilation failures.
Greedy operators are used for parsing, not for language deﬁnition, and
we do not support extended patterns of the form (?...) in general.

890  23rd USENIX Security Symposium 

USENIX Association

14

12345Threshold(MB)0.30.40.50.60.70.80.91.0CDF(%underthreshold)T-DN-$vs.T-DD-$T-DN-$T-DD-$[10] Debra L. Cook, Angelos D. Keromytis, and Moti Yung.
Elastic block ciphers: the basic design. pages 350–352,
2007.

[11] Kevin P. Dyer, Scott E. Coull, Thomas Ristenpart, and
Thomas Shrimpton. Protocol misidentiﬁcation made easy
with format-transforming encryption. In Proceedings of
the 20th ACM Conference on Computer and Communica-
tions Secuirty (CCS 2013), November 2013.

[12] A Goldberg and M Sipser. Compression and ranking. In
Proceedings of the seventeenth annual ACM symposium
on Theory of computing, STOC ’85, pages 440–448, New
York, NY, USA, 1985. ACM.

[13] Shaﬁ Goldwasser and Silvio Micali. Probabilistic en-
Journal of Computer and System Sciences,

cryption.
28(2):270–299, 1984.

[14] Shai Halevi. EME*: Extending EME to handle arbitrary-
length messages with associated data. pages 315–327,
2004.

[15] Shai Halevi and Phillip Rogaway. A tweakable encipher-

ing mode. pages 482–499, 2003.

[16] Daniel Lachaup, Kevin P. Dyer, Somesh Jha, Thomas
Ristenpart, and Thomas Shrimpton. LibFTE: A toolkit
for constructing practical,
format-abiding encryption
schemes (full version), 2014. Available from authors’
websites.

[17] Moses Liskov, Ronald L Rivest, and David Wagner.
In Advances in Cryptology-

Tweakable block ciphers.
CRYPTO 2002, pages 31–46. Springer, 2002.

[18] Chanathip Namprempre, Phillip Rogaway, and Thomas
Shrimpton. Reconsidering generic composition. In Ad-
vances in Cryptology – EUROCRYPT ‘14, LNCS, pages
257–274. Springer-Verlag, 2014.

[19] Martin Roesch. Snort - lightweight intrusion detection
for networks. In Proceedings of the 13th USENIX Con-
ference on System Administration, LISA ’99, pages 229–
238, Berkeley, CA, USA, 1999. USENIX Association.

[20] Phillip Rogaway. A synopsis of format-preserving en-

cryption. Unpublished manuscript, March 2010.

[21] Rich Schroeppel. An overview of the hasty pudding ci-

pher, July 1998.

In the development
and deploying FPE/FTE schemes.
of libfte we overcame a number of obstacles. Most no-
tably, we developed a new approach to perform FPE/FTE
directly from the NFA representation of a regular expres-
sion, which was previously considered to be impractical.
This signiﬁcantly increases the expressiveness of regular
languages for which FTE can be made useful in practice,
and generally improves system efﬁciency, potentially
making FTE a viable cryptographic option in contexts
where it previously was not. We studied libfte perfor-
mance empirically in several application contexts, ﬁnd-
ing that it typically introduces negligible performance
overhead relative to conventional encryption.
In some
cases (e.g. simultaneous compressions and encryption)
even enables substantial performance improvements.

Our work surfaces many avenues for future research.
To name a few: investigate the security of libfte’s algo-
rithms (and FTE implementations, in general) in the face
of side-channel attacks; integrate FTE into additional ap-
plications, and report on newly found algorithmic and
engineering challenges; and explore efﬁciency improve-
ments for speciﬁc classes of regular expressions that are
in wide use. To promote further research and develop-
ment, we will make libfte open source and publicly avail-
able at https://libfte.org/.

References

[1] Perl regular expressions man page. http://perldoc.perl.

org/perlre.html, February 2014.

[2] Seleniumhq:

Browser

automation.

http://www.

seleniumhq.org/, February 2014.

[3] Voltage security.

http://www.voltage.com/, February

2014.

[4] Mihir Bellare and Chanathip Namprempre. Authenticated
encryption: Relations among notions and analysis of the
generic composition paradigm. pages 531–545, 2000.

[5] Mihir Bellare, Thomas Ristenpart, Phillip Rogaway, and
Till Stegers. Format-preserving encryption. In Selected
Areas in Cryptography, pages 295–312. Springer-Verlag,
2009.

[6] Mihir Bellare and Phillip Rogaway.

Encode-then-
encipher encryption: How to exploit nonces or redun-
dancy in plaintexts for efﬁcient cryptography. pages 317–
330, 2000.

[7] Mihir Bellare, Phillip Rogaway, and Terence Spies. The
ffx mode of operation for format-preserving encryption
draft 1.1, 2010.

[8] John Black and Phillip Rogaway. Ciphers with arbitrary
In Topics in Cryptology–CT-RSA 2002,

ﬁnite domains.
pages 114–130. Springer Berlin Heidelberg, 2002.

[9] Debrup Chakraborty and Mridul Nandi. An improved se-

curity bound for HCTR. pages 289–302, 2008.

USENIX Association  

23rd USENIX Security Symposium  891

15

