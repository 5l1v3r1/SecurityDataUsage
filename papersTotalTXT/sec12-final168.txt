Privilege Separation in HTML5 Applications

Devdatta Akhawe, Prateek Saxena, Dawn Song
{devdatta,prateeks,dawnsong}@cs.berkeley.edu

University of California, Berkeley

Abstract

The standard approach for privilege separation in
web applications is to execute application components
in different web origins. This limits the practicality of
privilege separation since each web origin has ﬁnan-
cial and administrative cost.
In this paper, we pro-
pose a new design for achieving effective privilege sep-
aration in HTML5 applications that shows how appli-
cations can cheaply create arbitrary number of com-
ponents. Our approach utilizes standardized abstrac-
tions already implemented in modern browsers. We do
not advocate any changes to the underlying browser or
require learning new high-level languages, which con-
trasts prior approaches. We empirically show that we
can retroﬁt our design to real-world HTML5 applica-
tions (browser extensions and rich client-side applica-
tions) and achieve reduction of 6x to 10000x in TCB for
our case studies. Our mechanism requires less than 13
lines of application-speciﬁc code changes and consider-
ably improves auditability.
1
Applications written with JavaScript, HTML5 and CSS
constructs (called HTML5 applications) are becoming
ubiquitous. Rich web applications and web browser ex-
tensions are examples of HTML5 applications that al-
ready enjoy massive popularity [1, 2]. The introduc-
tion of browser operating systems [3, 4], and support for
HTML5 applications in classic operating systems [5, 6]
herald the convergence of web and desktop applica-
tions. However, web vulnerabilities are still pervasive in
emerging web applications and browser extensions [7],
despite immense prior research on detection and mitiga-
tion techniques [8–12].

Introduction

Privilege separation is an established security prim-
itive for providing an important second line of de-
fense [13]. Commodity OSes enable privilege separated
applications via isolation mechanisms such as LXC [14],
seccomp [15], SysTrace [16]. Traditional applications
have utilized these for increased assurance and secu-
rity. Some well-known examples include OpenSSH [17],

QMail [18] and Google Chrome [19]. In contrast, privi-
lege separation in web applications is harder and comes
at a cost. If an HTML5 application wishes to separate
its functionality into multiple isolated components, the
same-origin policy (SOP) mandates that each component
execute in a separate web origin.1 Owning and main-
taining multiple web origins has signiﬁcant practical ad-
ministrative overheads. 2 As a result, in practice, the
number of origins available to a single web application
is limited. Web applications cannot use the same-origin
policy to isolate every new component they add into the
application. At best, web applications can only utilize
sub-domains for isolating components, which does not
provide proper isolation, due to special powers granted
to sub-domains in the cookie and document.domain be-
haviors.

Recent research [12, 20] and modern HTML5 plat-
forms, such as the Google Chrome extension platform
(also used for “packaged web applications”), have recog-
nized the need for better privilege separation in HTML5
applications. These systems advocate re-architecting the
underlying browser or OS platform to force HTML5 ap-
plications to be divided into a ﬁxed number of compo-
nents. For instance, the Google Chrome extension frame-
work requires that extensions have three components,
each of which executes with different privileges [19].
Similarly, recent research proposes to partition HTML5
applications in “N privilege rings”, similar to the isola-
tion primitives supported by x86 processors [12]. We
observe two problems with these approaches. First, the
ﬁxed limit on the number of partitions or components
creates an artiﬁcial and unnecessary limitation. Differ-

1Browsers isolate applications based on their origins. An origin is
deﬁned as the tuple <scheme, host, port>. In recent browser exten-
sion platforms, such as in Google Chrome, each extension is assigned
a unique public key as its web origin. These origins are assigned and
ﬁxed at the registration time.

2To create new origins, the application needs to either create new
DNS domains or run services at ports different from port 80 and 443.
New domains cost money, need to be registered with DNS servers and
are long-lived. Creating new ports for web services does not work: ﬁrst,
network ﬁrewalls block atypical ports and Internet Explorer doesn’t
include the port in determining an application’s origin

1

ent applications require differing number of components,
and a “one-size-ﬁts-all” approach does not work. We
show that, as a result, HTML5 applications in such plat-
forms have large amounts of code running with unneces-
sary privileges, which increases the impact from attacks
like cross-site scripting. Second, browser re-design has
a built-in deployment and adoption cost and it takes sig-
niﬁcant time before applications can enjoy the beneﬁts
of privilege separation.

In this paper, we rethink how to achieve privilege sepa-
ration in HTML5 applications. In particular, we propose
a solution that does not require any platform changes
and is orthogonal to privilege separation architectures en-
forced by the underlying browsers. Our proposal uti-
lizes standardized primitives available in today’s web
browsers, requires no additional web domains and im-
proves the auditability of HTML5 applications. In our
proposal, HTML5 applications can create an arbitrary
number of “unprivileged components.” Each compo-
nent executes in its own temporary origin isolated from
the rest of the components by the SOP. For any priv-
ileged call, the unprivileged components communicate
with a “privileged” (parent) component, which executes
in the main (permanent) origin of the web application.
The privileged code is small and we ensure its integrity
by enforcing key security invariants, which we deﬁne in
Section 3. The privileged code mediates all access to
the critical resources granted to the web application by
the underlying browser platform, and it enforces a ﬁne-
grained policy on all accesses that can be easily audited.
Our proposal achieves the same security beneﬁts in en-
suring application integrity as enjoyed by desktop appli-
cations with process isolation and sandboxing primitives
available in commodity OSes [14–16].

We show that our approach is practical for exist-
ing HTML5 applications. We retroﬁt two widely used
Google Chrome extensions and a popular HTML5 appli-
cation for SQL database administration to use our design.
In our case studies, we show that the amount of trusted
code running with full privileges reduces by a factor of
6 to 10000. Our architecture does not sacriﬁce any per-
formance as compared to alternative approaches that re-
design the underlying web browser. Finally, our migra-
tion of existing applications requires minimal changes to
code. For example, in porting our case studies to this
new design we changed no more than 13 lines of code
in any application. Developers do not need to learn new
languages or type safety primitives to migrate code to
our architecture, in contrast to recent proposals [21]. We
also demonstrate strong data conﬁnement policies. To
encourage adoption, we have released our core infras-
tructure code as well as the case studies (where permit-
ted) and made it all freely available online [22]. We are
currently collaborating with the Google Chrome team to

apply this approach to secure Chrome applications, and
our design has inﬂuenced the security architecture of up-
coming Chrome applications.

In our architecture, HTML5 applications can de-
ﬁne more expressive policies than supported by exist-
ing HTML5 platforms, namely the Chrome extension
platform [19] and the Windows 8 Metro platform [5].
Google Chrome and Windows 8 rely on applications
declaring install-time permissions that end users can
check [23]. Multiple studies have found permission sys-
tems to be inadequate: the bulk of popular applications
run with powerful permissions [24, 25] and users rarely
check install-time permissions [26]. In our architecture,
policy code is explicit and clearly separated, can take
into account runtime ordering of privileged accesses, and
can be more ﬁne-grained. This design enables expert au-
ditors, such as maintainers of software application gal-
leries, to reason about the security of applications. In our
case studies, these policies are typically a small amount
of static JavaScript code, which is easily auditable.
2 Problem and Approach Overview
Traditional HTML applications execute with the author-
ity of their “web origin” (protocol, port, and domain).
The browser’s same origin policy (SOP) isolates differ-
ent web origins from one another and from the ﬁle sys-
tem. However, applications rarely rely on domains for
isolation, due to the costs associated with creating new
domains or origins.

In more recent application platforms, such as the
Google Chrome extension platform [23], Chrome pack-
aged web application store [1] and Windows 8 Metro ap-
plications [5], applications can execute with enhanced
privileges.
These privileges, such as access to the
geo-location, are provided by the underlying platform
through privileged APIs. Applications utilizing these
privileged API explicitly declare their permissions to use
privileged APIs at install time via manifest ﬁles. These
applications are authored using the standard HTML5 fea-
tures and web languages (like JavaScript) that web ap-
plications use; we use the term HTML5 applications to
collectively refer to web applications and the aforemen-
tioned class of emerging applications.

Install-time manifests are a step towards better secu-
rity. However, these platforms still limit the number of
application components to a ﬁnite few and rely on sep-
arate origins to isolate them. For example, each Google
Chrome extension has three components. One compo-
nent executes in the origin of web sites that the exten-
sion interacts with. A second component executes with
the extension’s permanent origin (a unique public key as-
signed to it at creation time). The third component exe-
cutes in an all-powerful origin having the authority of the
web browser. In this section, we show how this limits the

2

Issues with the Current Architecture

degree of privilege separation for HTML5 applications in
practice.
2.1
In this section, we point out two artifacts of today’s
HTML5 applications: bundling of privileges and TCB
inﬂation. We observe that these issues are rooted in the
fact that, in these designs, the ability to create new web
origins (or security principals) is severely restricted.

Common vulnerabilities (like XSS and mixed content)
today actually translate to powerful gains for attackers
in current architectures. Recent ﬁndings corroborate the
need for better privilege separation—for instance, 27 out
of 100 Google Chrome extensions (including the top 50)
recently studied have been shown to have exploitable
vulnerabilities [7]. These attacks grant powerful privi-
leges like code execution in all HTTP and HTTPS web
sites and access to the user’s browsing history.

As a running example, we introduce a hypothetical ex-
tension for Google Chrome called ScreenCap. Screen-
Cap is an extension for capturing screenshots that also in-
cludes a rudimentary image editor to annotate and mod-
ify the image before sending to the cloud or saving to a
disk.
Bundling. The ScreenCap extension consists of two
functionally disjoint components: a screenshot capturing
component and an image editor. In the current architec-
ture, both the components run in the same principal (ori-
gin), despite requiring disjoint privileges. We call this
phenomenon bundling. The screenshot component re-
quires the tabs and <all urls> permission, while the
image editor only requires the pictureLibrary permis-
sion to save captured images to the user’s picture library
on the cloud.

(cid:91)

Bundling causes over-privileged components. For ex-
ample, the image editor component runs with the power-
ful tabs and <all urls> permission. In general, if an
application’s components require privilege sets α1, α2...,
all components of the application run with the privileges
αi, leading to over-privileging. As we show in Sec-
tion 5.4, 19 out of the Top 20 extensions for the Google
Chrome platform exhibit bundling. As discussed earlier,
this problem manifests on the web too.
TCB inﬂation. Privileges in HTML5 are ambient—all
code in a principal runs with full privileges of the princi-
pal. In reality, only a small application core needs access
to these privileges and rest of the application does not
need to be in the trusted computing base (TCB). For ex-
ample, the image editor in ScreenCap consists of a num-
ber of complex and large UI and image manipulation li-
braries. All this JavaScript code runs with the ambient
privilege to write to the user’s picture library. Note that
this is in addition to it running bundled with the privi-

3

Figure 1: CDF of percentage of functions in an extension that
make privileged calls (X axis) vs. the fraction of extensions
studied (in percentage) (Y axis). The lines for 50% and 20% of
extensions as well as for 5% and 20% of functions are marked.

leges of the screenshot component.

We measured the TCB inﬂation for the top 50 Chrome
extensions. Figure 1 shows the percentage of total func-
tions in an extension requiring privileges as a fraction of
the total number of static functions. In half the exten-
sions studied, less than 5% of the functions actually need
any privileges.
In 80% of the extensions studied, less
than 20% of the functions require any privileges.
Summary.
It is clear from our data that HTML5 ap-
plications, like Chrome extensions, do not sufﬁciently
isolate their sub-components. The same-origin policy
equates web origins and security principals, and web ori-
gins are ﬁxed at creation time or tied to the web do-
main of the application. All code from a given provider
runs under a single principal, which forces privileges
to be ambient. Allowing applications to cheaply create
as many security principals as necessary and to conﬁne
them with ﬁne-grained, ﬂexible policies can make privi-
lege separation more practical.

Ideally, we would like to isolate the image editor com-
ponent from the screenshot component, and give each
component exactly the privileges it needs. Moving the
complex UI and image manipulation code to an unprivi-
leged component can tremendously aid audit and anal-
ysis. Our ﬁrst case study (Section 5.1) discusses un-
bundling and TCB reduction on a real world screenshot
application. We achieved a 58x TCB reduction.
2.2 Problem Statement
Our goal is to design a new architecture for privilege sep-
aration that side steps the problem of scarce web origins
and enables the following properties:
Reduced TCB. Given the pervasive nature of code in-
jection vulnerabilities, we are interested, instead, in
reducing the TCB.

 0 10 20 30 40 50 60 70 80 90 100 0 5 10 15 20 25 30 35 40 45 50Number of Extensions (Percentage)Percentage of Functions requiring privilegesEase of Audit. Dynamic code inclusion and use of com-
plex JS constructs is pervasive. An architecture that
eases audits, in spite of these issues, is necessary.

Flexible policies. Current manifest mechanisms pro-
vide insufﬁcient contextual data for meaningful se-
curity policies. A separate ﬂexible policy mecha-
nism can ease audits and analysis.

Reduce Over-privileging. Bundling of disjoint applica-
tions in the same origin results in over-privileging.
We want an architecture that can isolate applications
agnostic of origin.

Ease of Use. For ease of adoption, we also aim for min-
imal compatibility costs for developers. Mecha-
nisms that would involve writing applications for a
new platform are outside scope.

Scope. We focus on the threat of vulnerabilities in be-
nign HTML5 application. We aim to enable a privilege
separation architecture that benign applications can uti-
lize with ease to provide a strong second line of defense.
We consider malicious applications as out of scope, but
our design improves auditability and may be applicable
to HTML5 malware in the future.

This paper strictly focuses on mechanisms for achiev-
ing privilege separation and on mechanisms for expres-
sive policy-based conﬁnement. Facilitating policy devel-
opment and checking if policies are reasonable is an im-
portant issue, but beyond the scope of this paper.
3 Design
We describe our privilege separation architecture in this
section. We describe the key security invariants we main-
tain in Section 3.2 and the mechanisms we use for en-
forcing them in Section 3.3.
3.1 Approach Overview
We advocate a design that is independent of any privilege
separation scheme enforced by the underlying browser.
In our design, HTML5 applications have one privileged
parent component, and can have an arbitrary number of
unprivileged children. Each child component is spawned
by the parent and it executes in its own temporary ori-
gin. These temporary origins are created on the ﬂy for
each execution and are destroyed after the child exits;
we detail how temporary origins can be implemented us-
ing modern web browsers primitives in Section 3.3. The
privileged parent executes in the main (permanent) origin
assigned to the HTML5 application, typically the web
origin for traditional web application. The same origin
policy isolates unprivileged children from one another
and from the privileged parent. Figure 2 shows our pro-
posed HTML5 application architecture. In our design,
applications can continue to be authored in existing web
languages like JavaScript, HTML and CSS. As a result,

Figure 2: High-level design of our proposed architecture.

our design maintains compatibility and facilitates adop-
tion.
Parent. Our design ensures the integrity of the privi-
leged parent by maintaining a set of key security invari-
ants that we deﬁne in Section 3.2. The parent guards ac-
cess to a powerful API provided by the underlying plat-
form, such as the Google Chrome extension API. For
making any privileged call or maintaining persistent data,
the unprivileged children communicate with the parent
over a thin, well-deﬁned messaging interface. The par-
ent component has three components:

• Bootstrap Code. When a user ﬁrst navigates to the
HTML5 application, a portion of the parent code
called the bootstrap code executes. Bootstrap code
is the unique entry point for the application. The
bootstrap code downloads the application source,
spawns the unprivileged children in separate tempo-
rary origins, and controls the lifetime of their exe-
cution. It also includes boilerplate code to initialize
the messaging interface in each child before child
code starts executing. Privileges in HTML5 appli-
cations are tied to origins; thus, a temporary origin
runs with no privileges. We explain temporary ori-
gins further in Section 3.3.

• Parent Shim. During their execution, unprivileged
children can make privileged calls to the parent.
The parent shim marshals and unmarshals these re-
quests to and from the children. The parent shim
also presents a usable interface to the policy code
component of the parent.

• Policy Code.

The policy code enforces an
application-speciﬁc policy on all messages received

4

Browser PageParentChild IframeChild IframeBootstrap CodeSHIMApplication CodeSHIMPolicy CodeApplication CodeSHIMfrom children. Policy code decides whether to allow
or disallow access to privileged APIs, such as access
to the user’s browsing history. This mechanism pro-
vides complete mediation on access to privileged
APIs and supports ﬁne-grained policies, similar to
system call monitors in commodity OSes like Sys-
Trace [16]. In addition, as part of the policy code,
applications can deﬁne additional restrictions on the
privileges of the children, such as disabling import
of additional code from the web.

Only the policy code is application-speciﬁc; the boot-
strap and parent shim are the same across all applica-
tions. To ease adoption, we have made the application-
independent components available online. The applica-
tion independent components need to be veriﬁed once
for correctness and can be reused for all application in
the future. For new applications using our design, only
the application’s policy code needs to be audited. In our
experimental evaluation, we ﬁnd that the parent code is
typically only a small fraction of the rest of the applica-
tion and our design invariants make it statically auditable.
Children. Our design moves all functional compo-
nents of the application to the children. Each child con-
sists of two key components:

• Application Code. Application code starts execut-
ing in the child after the bootstrap code initializes
the messaging interface. All the application logic,
including code to handle visual layout of the appli-
cation, executes in the unprivileged child; the parent
controls no visible area on the screen. This implies
that all dynamic HTML (and code) rendering op-
erations execute in the child. Children are allowed
to include libraries and code from the web and ex-
ecute them. Vulnerabilities like XSS or mixed con-
tent bugs (inclusion of HTTP scripts in HTTPS do-
mains) can arise in child code. In our threat model,
we assume that children may be compromised dur-
ing the application’s execution.

• Child Shim. The parent includes application inde-
pendent shim code into the child to seamlessly al-
low privileged calls to the parent. This is done to
keep compatibility with existing code and facilitate
porting applications to our design. Shim code in
the child deﬁnes wrapper functions for privileged
APIs (e.g., the Google Chrome extension API [27]).
The wrapper functions forward any privileged API
calls as messages to the parent. The parent shim un-
marshals these messages, checks the integrity of the
message and executes the privileged call if allowed
by the policy. The return value of the privileged
API call is marshaled into messages by the parent
shim and returned to the child shim. The child shim

5

unmarshals the result and returns it to the original
caller function in the child. Certain privileged API
functions take callbacks or structured data objects;
in Section 4.1 we outline how our mechanism prox-
ies these transparently. Together, the parent and
child shim hide the existence of the privilege bound-
ary from the application code.

3.2 Security Invariants
Our security invariants ensure the integrity and correct-
ness of code running in the parent with full privileges.
We do not restrict code running in the child; our threat
model assumes that unprivileged children can be com-
promised any time during their execution. We enforce
four security invariants on the parent code:

1. The parent cannot convert any string to code.

2. The parent cannot include external code from the

web.

3. The parent code is the only entry point into the priv-

ileged origin.

4. Only primitive types (speciﬁcally, strings) cross the

privilege boundary.

The ﬁrst two invariants help increase assurance in the
parent code. Together, they disable dynamic code exe-
cution and import of code from the web, which elimi-
nates the possibility of XSS and mixed content vulner-
abilities in parent code. Furthermore, it makes parent
code statically auditable and veriﬁable. Several analysis
techniques can verify JavaScript when dynamic code ex-
ecution constructs like eval and setTimeout have been
syntactically eliminated [9–11, 28, 29].

Invariant 3 ensures that only the trusted parent code
executes in the privileged origin; no other application
code should execute in the permanent origin. The naive
approach of storing the unprivileged (child) code as a
HTML ﬁle on the server suffers from a subtle but seri-
ous vulnerability. An attacker can directly navigate to
the unprivileged code. Since it is served from the same
origin as the parent, it will execute with full privileges
of the parent without going through the parent’s boot-
strap mechanism. To prevent such escalation, invariant
3 ensures that all entry points into the application are
directed only through the bootstrap code in the parent.
Similarly, no callbacks to unprivileged code are passed
to the privileged API—they are proxied by parent func-
tions to maintain Invariant 3. We detail how we enforce
this invariant in Section 3.3.

Privilege separation, in and of itself, is insufﬁcient to
improve security. A problem in privilege-separated C ap-
plications is the exchange of pointers across the privi-
lege boundary, leading to possible errors [30, 31]. While

JavaScript does not have C-style pointers, it has ﬁrst-
class functions. Exchanging functions and objects across
the privilege boundary can introduce security vulnerabil-
ities. Invariant 4 eliminates such attacks by requiring that
only primitive strings are exchanged across the privilege
boundary.
3.3 Mechanisms
We detail how we implement the design and enforce the
above invariants in this section. Whenever possible, we
rely on browser’s mechanisms to declaratively enforce
the outlined invariants, thereby minimizing the need for
code audits.
Temporary Origins. To isolate components, we exe-
cute unprivileged children in separate iframes sourced
from temporary origins. A temporary origin can be cre-
ated by assigning a fresh, globally unique identiﬁer that
the browser guarantees will never be used again [32].
A temporary origin does not have any privileges, or in
other words, it executes with null authority. The globally
unique nature means that the browser isolates every tem-
porary origin from another temporary origin, as well as
the parent. The temporary origin only lasts as long as the
lifetime of the associated iframe.

Several mechanisms for implementing temporary ori-
gins are available in today’s browsers, but these are rarely
found in use on the web. In the HTML5 standard, iframes
with the sandbox directive run in a temporary origin.
This primitive is standardized and already supported in
shipping versions of Google Chrome/ChromeOS, Safari,
Internet Explorer/Windows 8, and a patch for Mozilla
Firefox is in the ﬁnal stages of review [33].
Enforcement of Security Invariants. To enforce se-
curity invariants 1 and 2 in the parent, our implemen-
tation utilizes the Content Security Policy (CSP) [34].
CSP is a new speciﬁcation, already supported in Google
Chrome and Firefox, that deﬁnes browser-enforced re-
strictions on the resources and execution of application
code.
In our case studies, it sufﬁces to use the CSP
policy directive default-src ’none’; script-src
’self’—this disables all constructs to convert strings
into code (Invariant 1) and restricts the source of all
scripts included in the page to the origin of the appli-
cation (Invariant 2). We ﬁnd that application-speciﬁc
code is typically small (5 KB) and easily auditable in our
case studies. On platforms on which CSP is not sup-
ported, we point out that disabling code evaluation con-
structs and external code import is possible by syntacti-
cally restricting the application language to a subset of
JavaScript [11, 28, 29].

We require that all non-parent code, when requested,
is sent back as a text ﬁle.
Browsers do not ex-
ecute text ﬁles—the code in the text ﬁles can only

execute if downloaded and executed by the parent,
via the bootstrap mechanism. This ensures Invariant
3.
In case of pure client-side platforms like Chrome,
this involves a simple ﬁle renaming from .html to
.txt.
In case of classic client-server web applica-
tions, this involves returning a Content-Type header of
text/plain. To disable mime-snifﬁng, we also set the
X-Content-Type-Options HTTP header to nosniff.

Messaging Interface. We utilize standard primitives
like XMLHttpRequest and the DOM API for download-
ing the application code and executing it in an iframe.
We rely on the postMessage API for communication
across the privilege boundary. postMessage is an asyn-
chronous, cross-domain, purely client-side messaging
mechanism. By design, postMessage only accepts
primitive strings. This ensures Invariant 4.

Policy. Privilege separation isolates the policy and the
application logic. Policies, in our design, are written in
JavaScript devoid of any dynamic evaluation constructs
and are separated from the rest of the complex applica-
tion logic. Permissions on existing browser platforms are
granted at install-time. In contrast, our design allows for
more expressive and ﬁne-grained policies like granting
and revoking privileges at run-time. For example, in the
case of ScreenCap, a child can get the ability to capture
a screenshot only once and only after the user clicks the
‘capture’ button. Such ﬁne-grained policies require the
policy engine to maintain state, reason about event or-
dering and have the ability to grant/revoke ﬁne-grained
privileges. Our attempt at expressive policies is along the
line of active research in this space [21], but in contrast
to existing proposals, it does not require developers to
specify policies in new high-level languages. Our focus
is on mechanisms to support expressive policies; deter-
mining what these policies should be for applications is
beyond the scope of this paper.

Additional Conﬁnement of Child Code. By default,
no restrictions are placed on the children beyond those
implied by use of temporary origins. Speciﬁcally, the
child does not inherit the parent’s CSP policy restric-
tions.
In certain scenarios, the application developer
may choose to enforce additional restrictions on the child
code, via an appropriate CSP policy on the child iframe
at the time of its creation by the parent code. For ex-
ample, in the case of ScreenCap, the screenshot compo-
nent can be run under the script-src ’self’. This
increases assurance by disabling inline scripts and code
included from the web, making XSS and mixed content
attacks impossible. The policy code can then grant the
powerful privilege of capturing a screenshot of a user’s
webpage to a high assurance screenshot component.

6

The parent proceeds to create a temporary origin,
unprivileged iframe using the downloaded code as the
source (Step 3, Figure 3). Listing 1 outlines the code
to create the unprivileged temporary origin. The parent
builds up the child’s HTML in the sb content variable.
The parent can optionally include content restrictions on
the child via a CSP policy, as explained in Section 3.3.
Creating multiple children is a simple repetition of the
step 3.

The parent also sources the child shim into the
child iframe.
The parent concatenates the child’s
code (HTML) and URI-encodes it all into a variable
called sb content. The parent creates an iframe with
sb content as the data: URI source, sets the sandbox
attribute and appends the iframe to the document. The
parent code also inserts a base HTML tag that enables
relative URIs to work seamlessly.

data: is a URI scheme that enables references to in-
line data as if it were an external reference. For example,
an iframe with src attribute set to data:text/html;Hi
is similar to an iframe pointing to an HTML page con-
taining only the text ‘Hi’. Recall our enforcement mech-
anism for Invariant 3: the application code is a text ﬁle.
The use of data: is necessary to convert text to code
that the iframe src can point to, without storing un-
privileged application code as HTML or JavaScript ﬁles.
4.1 API Shims
Recall that the child executes in a temporary origin, with-
out the privileges needed for making privileged calls like
chrome.tabs.captureVisibleTab. Privileged API
calls in the original child code would fail when it exe-
cutes in a temporary origin; our transformation should,
therefore, take additional steps to preserve the original
functionality of the application. In our design, we pro-
pose API shims to proxy calls to privileged API in the
child to the parent code safely and transparently.

The child shim deﬁnes wrapper objects in the child
that proxy a privileged call to the parent. The aim of the
parent and child shim is to make the privilege separa-
tion boundary transparent. We have implemented shims
for all the privileged API functions needed for our case
studies. This implementation of the parent shim is 5.46
KB and that of the child shim is 9.1 KB. Note that only
the parent shim is in the TCB.

First,

Figure 4 outlines the typical events involved in prox-
ying a privileged call.
the child shim de-
ﬁnes a stub implementation of the privileged APIs
(e.g., chrome.tabs.captureVisibleTab) that, when
called, forwards the call to the parent. On receiving the
message, the parent shim checks with the policy and if
the policy allows, the parent shim makes the call on be-
half of the child. On completion of the call, the parent
shim forwards the callback arguments (given by the run-





7

Figure 3: Sequence of events to run application in sandbox.
Note that only the bootstrap code is sent to the browser to exe-
cute. Application code is sent directly to the parent, which then
creates a child with it.



var s b c o n t e n t ="<html ><head >" ;
s b c o n t e n t +="<meta http -equiv=’X-WebKit -CSP ’" ;
// csp_policy is defined in downloaded policy
s b c o n t e n t +=" content =’"+ c s p p o l i c y +"’>" ;
s b c o n t e n t +="<script src=’"+ c h i l d S h i m S r c +"’>" ;
// the baseurl is current window uri
//so that relative URIs work
s b c o n t e n t +="<base href=’"+ b a s e u r l +"’>" ;
// contents of app.txt
s b c o n t e n t += a p p l i c a t i o n c o d e ;
// attribute values are URI - decoded
// by HTML parser
s b c o n t e n t =encodeURIComponent ( s b c o n t e n t ) ;
var f r = document . c r e a t e E l e m e n t ( "iframe" ) ;
f r . s r c ="data:text/html; charset =utf -8,"+

s b c o n t e n t ;



// sandboxed frames run in fresh origin
f r . s e t A t t r i b u t e ( ’sandbox ’ , ’allow - scripts ’ ) ;
document . body . a p p e n d C h i l d ( f r ) ;

Listing 1: Bootstrap Code (JavaScript)

Implementation

4
As outlined in Section 3, the parent code executes when
the user navigates to the application. The bootstrap code
is in charge of creating an unprivileged sandbox and ex-
ecuting the unprivileged application code in it. The shim
code and policy also run in the parent, but we focus on
the bootstrap and shim code implementation in this sec-
tion. The unprivileged child code and the security policy
vary for each application, and we discuss these in our
case studies (Section 5).

Figure 3 outlines the steps involved in creating one
unprivileged child. First, the user navigates to the ap-
plication and the parent’s bootstrap code starts executing
(Step 1 in Figure 3). In Step 2, the parent’s bootstrap
code retrieves the application HTML code (as plain text
ﬁles) as well as the security policy of the application. For
client-side platforms like Chrome and Windows 8, this is
a local ﬁle retrieval.

Browser PageParentChild IframeBootstrap CodePolicy CodeApplication CodeSHIM1. Bootstrap Code2. Application Code and Policy4. Source Policy Code3. Create ChildSHIM

tabs . c a p t u r e V i s i b l e T a b =

f u n c t i o n ( windowid , options , c a l l b a c k ) {

var id = c a l l b a c k c t r ++;
c a c h e d _ c a l l b a c k s [ id ] = c a l l b a c k ;

s e n d T o P a r e n t ({

" type " : " tabs . c a p t u r e V i s i b l e T a b " ,
" w i n d o w i d " : windowid ,
" options " : options ,
" c a l l b a c k i d " : id

}) ;

Listing 2: Child shim for captureVisibleTab

};


// m is the a r g u m e n t given to
// s e n d T o P a r e n t in the child shim
if ( m . type === ’ tabs . c a p t u r e V i s i b l e T a b ’)
{ // fail if policy does not allow
if (! policy . a l l o w C a l l ( m ) { return ;}
tabs . c a p t u r e V i s i b l e T a b (

m . windowid ,
m . options ,
f u n c t i o n ( imgData ) {

s e n d T o C h i l d ({

type : " cb_tabs . c a p t u r e V i s i b l e T a b " ,
id : m . callbackid ,
imgData : imgData
}) ;

}

}) ;








Listing 3: Parent shim for captureVisibleTab

cation can continue calling the privileged API as before.
Parent Shim. On receiving the message, the parent’s
shim ﬁrst checks with the policy (Step 4 in Fig. 4 and
line 5 in Listing 3) and if the policy allows it, the parent
shim makes the requested privileged call.

In case of ScreenCap, a simple policy could disallow
captureVisibleTab call if the request came from the
image editor, and allow the call if the request came from
the screenshot component. Such a policy unbundles the
two components. If a network attacker compromises one
of the two components in ScreenCap, then it only gains
the ability to make request already granted to that com-
ponent. As another example, the application can enforce
a policy to only allow one captureVisibleTab call af-
ter a user clicks the ‘capture’ button. All future requests
during that execution of the application are denied until
the user clicks the ‘capture’ button again.

Note that the privileged call is syntactically the same
as what the child would have made, except for the call-
back. The modiﬁed callback (lines 9-14 in Listing 3)
forwards the returned image data to the child (Step 6),
the original callback still executes in the child.
Child Callback The message handler on the child re-
ceives the forwarded arguments from the parent and exe-
cutes the saved callback with the arguments provided by
the parent. (Step 7 in Figure 4 and line 6 in Listing 4).
The saved callback is then deleted from the cache (Line

Figure 4: Typical events for proxying a privileged API call.
The numbered boxes outline the events. The event boxes span
the components involved. For example, event 4 involves the
parent shim calling the policy code.

time) to the child shim, and the child shim executes the
original callback.

code

examples of

the

for

shims

Continuing with our

running example, we give
the
concrete
chrome.tabs.captureVisibleTab function,
used
to capture a screenshot. captureVisibleTab takes
three arguments: a windowID, an options object, and
a callback parameter. On successfully capturing a
screenshot of the given window, the chrome runtime
executes the callback with the encoded image data as
the only argument. Note that the callback parameter is a
ﬁrst-class function; our invariants do not allow exchange
of a function across the privilege boundary.
Child Shim. The child shim creates a stub implemen-
tation of the privileged API. In the unprivileged child, a
privileged call would fail since the child does not have
privileges to execute it.
Instead, the stub function de-
ﬁned by the child function is called. This stub func-
tion marshals all the arguments and sends it to the par-
ent. Listing 2 is the child shim implementation for the
captureVisibleTab function.

No code is passed across the privilege boundary. In-
stead, the child saves the callback (Step 2 in Fig. 4) and
forwards the rest of the argument list to the parent (Step
3). The callback is stored in a cache and a unique iden-
tiﬁer is sent to the parent. The parent uses this identiﬁer
later.

We stress that this process is transparent to the applica-
tion: the parent code ensures that the child shim is loaded
before any application code starts executing. The appli-

8

Browser PageParentChild IframeBootstrap CodeSHIMPolicy CodeApplication CodeSHIM1. Privileged Call2. Save Callback3. Parent Request4. CheckPolicy5. Make PrivilegedCall6. Forward Callback Arguments7. Execute Saved Callback

if (

m . type === ’ cb_tabs . c a p t u r e V i s i b l e T a b ’
) {
var cb_id = m . c a l l b a c k i d ;
var savedCb = c a c h e d _ c a l l b a c k s [ cb_id

savedCb . call ( window , m . imgData ) ;
delete c a c h e d _ c a l l b a c k s [ cb_id ];

];

}

Listing 4: Child shim for captureVisibleTab: Part 2









7).
Persistent State. We take a different approach to
data persistence APIs like window.localStorage and
document.cookie. It is necessary that the data stored
using these APIs is also stored in the parent since the next
time a child is created, it will run in a fresh origin and the
previous data will be lost. We point out that enabling per-
sistent storage while maintaining compatibility requires
some changes to code. Persistent storage APIs (like
window.localStorage) in today’s platforms are syn-
chronous; our proxy mechanism uses postMessage to
pass persistent data, but postMessage is asynchronous.
To facilitate compatibility, we implement a wrapper for
these synchronous API calls in the child shim code and
asynchronously update the parent via postMessage un-
derneath. For example, a part of the localStorage child
shim is presented in Listing 5. The shim creates a
wrapper for the localStorage API using an associa-
tive array (viz., data). On every update, the new as-
sociative array is sent to the parent. On receiving the
localStorage save message, the parent can save the
data or discard it per policy.

We observe that in our transformation, calls to API
that access persistent state become asynchronous which
contrasts the synchronous API calls in the original code.
To preserve the application’s intended behavior, in prin-
ciple, it may be necessary to re-design parts of the code
that depend on the synchronous semantics of persistent
storage APIs—for example, when more than one unpriv-
ileged children are sharing data via persistent state simul-
taneously. In our case studies so far, however, we ﬁnd
that the application behavior does not depend on such se-
mantics. In future work, we plan to investigate transfor-
mation mechanisms that can provide reasonable memory
consistency properties in accessing persistent local stor-
age.
5 Case Studies
We retroﬁt our design onto three HTML5 applications
to demonstrate that our architecture can be adopted by
applications today:

• As an example of browser extensions, we retroﬁt
our design to Awesome Screenshot, a widely used

9





setItem : f u n c t i o n ( key , value ) {

data [ key ] = value + ’ ’;
s a v e T o M a i n C a c h e ( data ) ;

} ,

s a v e T o M a i n C a c h e : f u n c t i o n ( data ) {

s e n d T o P a r e n t ({
" type " : " l o c a l S t o r a g e _ s a v e " ,
" value " : data
}) ;

} ,

Listing 5: localStorage Shim in the Child Frame

chrome extension (802,526 users) similar to Screen-
Cap.

• As an example of emerging packaged HTML5 web
applications, we retroﬁt our design to SourceKit, a
full-ﬂedged text editor available as a Chrome pack-
aged web application. SourceKit’s design is similar
to editors often bundled with online word proces-
sors and web email clients. These editors typically
run with the full privileges of the larger application
they accompany.

• As an example of traditional HTML5 web appli-
cations, we retroﬁt our design to SQL Buddy, a
PHP web application for database administration.
Web interfaces for database administration (notably,
PHPMyAdmin) are pervasive and run with the full
privileges of the web application they administer.

Our goal in this evaluation is to measure (a) the reduc-
tion in TCB our architecture achieves, (b) the amount of
code changes necessary to retroﬁt our design, and (c) per-
formance overheads (user latency, CPU overheads and
memory footprint impact) compared to platform redesign
approaches. Table 1 lists our case studies and summa-
rizes our results. First, we ﬁnd that the TCB reduction
achieved by our redesign ranges from 6x to 10000x. Due
to the prevalence of miniﬁcation, we believe LOC is not
a useful metric for JavaScript code and, instead, we re-
port the size of the code in KB. Second, we ﬁnd that we
require minimal changes, ranging from 0 to 13 lines, to
port the case studies to our design. This is in addition to
the application independent shim and bootstrap code that
we added.

We also demonstrate examples of expressive policies
that these applications can utilize. The focus of this paper
is on mechanisms, not policies, and we do not discuss
alternative policies in this work.

Finally, we also quantify the reduction in privileges
we would achieve in the 50 most popular Chrome exten-
sions with our architecture. We also ﬁnd that in half the
extensions studied, we can move 80% of the functions
out of the TCB. This quantiﬁes the large gap between
the privileges granted by Chrome extensions today and

what is necessary. In addition, we also analyze the top
20 Chrome extensions to determine the number of com-
ponents bundled in each. We ﬁnd that 19 out of the top
20 extension exhibit bundling, and estimate that we can
separate these between 2 to 4 components, in addition to
the three components that Chrome enforces.

To facilitate further research and adoption of our tech-
niques, we make all the application independent compo-
nents of the architecture and the SQL Buddy case study
available online [22]. Due to licensing restrictions, we
are unable to release the other case studies publicly.

Table 1: Overview of case studies. The TCB sizes are in KB.
The lines changed column only counts changes to application
code, and not application independent shims and parent code.

Application Number
of users

Initial
TCB
(KB)

New
Lines
TCB Changed
(KB)

Awesome
Screenshot
SourceKit
SQL Buddy

802,526

580

14,344
45,419

15,000
100

16.4

5.38
2.67

0

13
11

5.1 Awesome Screenshot
The Awesome Screenshot extension allows a user to cap-
ture a screenshot of a webpage similar to our running
example [35]. A rudimentary image editor, included in
the extension, allows the user to annotate and modify the
captured image as he sees ﬁt. Awesome Screenshot has
over 800,000 users.3

of

three

The

extension

consists

components:
background.html, popup.html, and editor.html.
A typical
interaction involves the user clicking the
Awesome Screenshot button, which opens popup.html.
The user selects her desired action; popup.html
forwards the choice to background.html, which
captures a screenshot and sends it to the image editor
(editor.html) for post-processing. All components
communicate with each other using the sendRequest
API call.
Privilege
redesigned Awesome
Screenshot following the model laid out in Section 3
(Figure 2). Each component runs in an unprivileged tem-
porary origin. The parent mediates access to privileged
APIs, and the policy keeps this access to the minimum
required by the component in question.
Code Changes. Apart from the application indepen-
dent code, we required no changes to the code. The
parent and child shims make the redesign seamless. We

Separation. We

3Due to a bug in Chrome, the current Awesome Screenshot exten-
sion uses a NPAPI binary to save big (> 2MB) images. We used the
HTML5 version (which doesn’t allow saving large ﬁles) for the pur-
poses of this work. This is just a temporary limitation.

10

manually tested the application functionality thoroughly
and did not observe any incompatibilities.
Unbundling.
In the original version of Awesome
Screenshot, the image editor (editor.html) accepts the
image from background.html and allows the user to
edit it, but runs with the full privileges of the extension—
an example of bundling. Similarly, the popup.html only
needs to forward the user’s choice to background.html
but runs with all of the extension’s privileges.

In our privilege-separated implementation of Awe-
some Screenshot, the editor code, stored in editor.txt
now, runs within a temporary origin. The policy only
gives it access to the sendRequest API to send the exit
and ready messages as well as receive the image data
message from the background page.
TCB Reduction. The image editor in the original
Awesome Screenshot extension uses UI and image ma-
nipulation libraries (more than 500KB of complex code),
which run within the same origin as the extension. As
a result, these libraries run with the ambient privileges
to take screenshots of any page, log the user’s browsing
history, and access the user’s data on any website. While
some functions in the extension do need these privileges,
the complete codebase does not need to run with these
privileges.

In our privilege-separated implementation of Awe-
some Screenshot, the amount of code running with full
privileges (TCB) decreased by a factor of 58. We found
the UI and image manipulation libraries, speciﬁcally
jQuery UI, used dynamic constructs like innerHTML and
eval. Our design moves these potentially vulnerable
constructs to an unprivileged child.

The code in the child can still request privileged func-
tion calls via the interface provided by the parent. How-
ever, this interface is thin, well deﬁned and easily au-
ditable.
In contrast, in the non-privilege separated de-
sign, the UI and image libraries run with ambient privi-
leges. In contrast, in the original extension all the code
needs to be audited.
Example Policy.
In addition to unbundling the im-
age editor from the screenshot component, the parent
can enforce stronger, temporal policies on the appli-
cation.
In particular, the parent can require that the
captureVisibleTab function is only called once after
the user clicks the capture button. Any subsequent calls
have to be preceded by another button click. Such tem-
poral policies are impossible to express and enforce in
current permission-based systems.
5.2 SourceKit Text Editor
The SourceKit text editor is an HTML5 text editor for
a user’s documents stored on the Dropbox cloud ser-
vice [36].
It uses open source components like the

Ajax.org cloud editor [37] and Dojo toolkit [38], in con-
junction with the Dropbox REST APIs [36].

SourceKit is a powerful text editor. It includes a ﬁle-
browser pane and can open multiple ﬁles at the same
time. The text editor component supports themes and
syntax highlighting. The application consists of 15MB
of JavaScript code, all of which runs with full privileges.
Privilege Separation.
In our least privilege design, the
whole application runs in a single child. Redesigning
SourceKit to move code to an unprivileged temporary
origin was seamless because of the library shims (Sec-
tion 4.1). One key change was replacing the included
Dojo toolkit with its asynchronous version. The included
Dojo toolkit uses synchronous XMLHttpRequest calls,
which the asynchronous postMessage cannot proxy.
The asynchronous version of Dojo is freely available on
the Dojo website. We do not include this change in the
number of lines modiﬁed in Table 1.
Unbundling. Functionally, SourceKit
is a single
Chrome application, and no bundling has occurred in its
design. Popular Web sites (like GitHub [39]), use the
text editor module as an online text editor [37]. In such
cases, the text editor runs bundled with the main applica-
tion, inheriting the application’s privileges and increas-
ing its attack surface. While we focus only on SourceKit
for this case study, our redesign directly applies to these
online text editors.
TCB Reduction.
In our privilege separated SourceKit,
the amount of code running with full privileges reduced
from 15MB to 5KB. A large part of this reduction is
due to moving the Dojo Toolkit, the syntax highlight-
ing code and other UI libraries to an unprivileged prin-
cipal. Again, we found the included libraries, speciﬁ-
cally the Dojo Toolkit, relying on dangerous, dynamic
constructs like eval, string arguments to setInterval,
and innerHTML. In our redesign, this code executes un-
privileged.
Code Change.
In addition to the switch to asyn-
chronous APIs, we also had to modify one internal
function in SourceKit to use asynchronous APIs.
In
particular, SourceKit relied on synchronous requests to
load ﬁles from the dropbox.com server. We modi-
ﬁed SourceKit to use an asynchronous mechanism in-
stead. The change was minor; only 13 lines of code were
changed.
Example Policy.
In the original application, all code
runs with the tabs permission, which allows access to
the user’s browsing history, and permission to access
dropbox.com. In our privilege-separated design, the pol-
icy only allows the child access to the tabs.open and
tabs.close Chrome APIs for accessing dropbox.com.
Similarly, it only forwards tab events for dropbox.com

URIs. Thus, after the redesign, the child has access to the
user’s browsing history only for dropbox.com, and not
for all websites. Implementing this policy requires only
two lines of code—an if condition that forwards events
only for dropbox.com domains sufﬁces.

SourceKit accesses Dropbox using the Dropbox
OAuth APIs [36]. At ﬁrst run, SourceKit opens Drop-
box in a new tab, where the user can grant SourceKit the
requisite OAuth access token [40]. The parent can only
allow access to the tabs privileges at ﬁrst run, and disable
it once the child receives the OAuth token. Such tempo-
ral policies cannot be expressed by install-time permis-
sions implemented in existing platforms.

We can also enforce stronger policies to provide a
form of data separation [41]. By default, the Dropbox
JS API [42] stores the OAuth access token in localStor-
age, accessible by all the code in the application.
In-
stead, the policy code can store the OAuth token in the
parent and append it to all dropbox.com requests. This
mitigates data exﬁltration attacks where the attacker can
steal the OAuth token to bypass the parent’s policy.4
Such application-speciﬁc data-separation policies cannot
be expressed in present permission systems.
5.3 SQL Buddy
SQL Buddy is an open source tool to administer the
MySQL database using a Web browser. Written in PHP,
SQL Buddy is functionally similar to phpMyAdmin and
supports creating, modifying, or deleting databases, ta-
bles, ﬁelds, or rows; SQL queries; and user management.
SQL Buddy uses the MooTools JS library to create an
AJAX front-end for MySQL administration. It uses the
MySQL user table for authentication and logged-in users
maintain authentication via PHP session cookies.
Privilege Separation. We modiﬁed SQL Buddy to ex-
ecute all its code in an unprivileged child. To en-
sure that no code is interpreted by the browser, we re-
quired all PHP ﬁles to return a Content-Type header of
text/plain, as discussed in Section 3.3. Only two
new ﬁles: buddy.html and login.html execute in the
browser; these are initialized by the bootstrap code.
Unbundling. A typical SQL Buddy installation runs at
www.example.net/sqlbuddy, and helps ease database
management for the application at www.example.net.
Classic operating system mechanisms can isolate SQL
Buddy and the main application on the server side. But
SQL Buddy runs with the full privileges of the applica-
tion on the client-side. In particular, an XSS vulnerabil-
ity in SQL Buddy is equivalent to an XSS vulnerability
on the main application: it is not isolated from the ap-
plication at the client-side. SQL Buddy inherits all the

4For example, to prevent malware, the parent can require that all

ﬁles accessed using SourceKit have non-binary ﬁle extensions.

11

privileges of the application, including special client-side
privileges such as access to camera, geolocation, and am-
bient privileges granted to the web origin such as the abil-
ity to do cross-origin XMLHttpRequests [43].

is

available

In our privilege-separated redesign, a restrictive
policy on the child mitigates SQL Buddy bundling.
The parent allows the child XMLHttpRequest ac-
to only /sqlbuddy/<filename>.php URIs.
cess
No other privilege
to SQL Buddy
code, including document.cookie, localStorage, or
XMLHttpRequest to the main application’s pages. This
policy isolates SQL Buddy from any other application
executing on the same domain, a hitherto unavailable op-
tion.
Code Change. The key change we made to the SQL
Buddy client side code was to convert the login script at
the server. The original SQL Buddy system returned a
new login page on a failed login. Instead, we changed it
to only return an error code over XMLHttpRequest. The
client-side code utilized this response to show the user
the new login page, thereby preserving the application
behavior. This change required modiﬁcation of only 11
lines of code.
TCB Reduction. SQL Buddy utilizes the MooTools
JavaScript library, which runs with the full privileges
of the application site (e.g., www.example.net). Over
100KB of JavaScript code runs with full privileges of
the www.example.net origin. This code uses danger-
ous, dynamic constructs such as innerHTML and eval.
In our design, the total amount of code running in the
www.example.net origin is 2.5KB, with the JavaScript
code utilizing dynamic constructs running in an unprivi-
leged temporary origin
Example Policy. Privilege separation reduces the am-
bient authority from these libraries. For example, the
session cookie for www.example.net, is never sent to
the child: all HTTP trafﬁc requiring the cookie needs
to go through the parent. Note that the cookie for
the www.example.net principal includes both, the SQL
Buddy session cookie as well as the cookie for the
main www.example.net application.
In case of suc-
cessful code injection, the attacker cannot exﬁltrate this
cookie. Furthermore, the policy strictly limits privileged
API access to those calls required by SQL Buddy. The
SQL Buddy code does not have ambient authority to
make privileged calls in the www.example.net princi-
pal. Again, implementing this policy requires two lines
of JavaScript code in our architecture.
5.4 Top 50 Google Chrome extensions
Finally, we measure the opportunity available to our
technique by quantifying the extent of TCB inﬂation and
bundling in Chrome extensions. To perform this analy-

12

sis, we developed a syntactic static analysis engine for
JavaScript using an existing JavaScript engine called Py-
narcissus [44] and performed a manual review for addi-
tional conﬁdence. We report our results on 46 out of the
top 50 extensions we study.5 In our analysis, we (conser-
vatively) identify all calls to privileged APIs (i.e., calls
to the chrome object) and list them in Figure 1. We be-
lieve that our analysis is overly conservative, being syn-
tactic, so these numbers represent only an undercount of
the over-privileging in these applications.6
TCB Reduction. We show the distribution of the num-
ber of functions requiring any privileges as a percentage
of the total number of functions. TCB inﬂation is per-
vasive in the extensions studied. In half the extensions,
less than 5% of the total functions require any ambient
privileges. In the current architecture the remaining 95%
run with full privileges, inﬂating the TCB.
Bundling. We manually analyzed the 20 most popular
Google Chrome extensions, and found 19 of them exhib-
ited bundling. The most common form of bundling oc-
curred when the options page or popup window of an ex-
tension runs with full privileges, in spite of not requiring
any privileges at all. While the Google Chrome archi-
tecture does enable privilege separation between content
scripts and extension code, running all code in an exten-
sion with the same privileges is unnecessary.

Another form of over-privileging occurs due to the
bundling of privileges in Chrome’s permission system.
Google Chrome’s extension system bundles multiple
privileges into one coarse-grained install-time permis-
sion. For example, the tabs permission in Chrome ex-
tension API, required by 42 of the 46 extensions ana-
lyzed, bundles together a number of related, powerful
privileges. This install-time permission includes the abil-
ity to listen to eight events related to tabs and windows,
access users’ browsing history, and call 20 other miscel-
laneous functions. Figure 5 measures the percentage of
the tabs API actually used by extensions as a percent-
age of the total API granted by tabs for the 42 exten-
sions analyzed. As can be seen, no extension requires
the full privileges granted by the tabs permission, with
one extension requiring 44.83% of the permitted API be-
ing the highest. More than half of the extensions require
only 6.9% of the API available, which indicates over-
privileging. In our design, the policy acts on ﬁne-grained
function calls and replaces coarse-grained permissions.
6 Performance Benchmarks
Our approach has two possible overheads: run-time over-
head caused by the parent’s mediation on privileged APIs

5Due to limitations of Pynarcissus, it was unable to completely

parse code in 4 out of the top 50 extensions.

6More precise analysis can be used in the future.

tension. For example, Awesome Screenshot could be
broken up into two extensions: a screenshot extension
and an image editor extension. In addition to requiring
two install decisions from the user, each additional ex-
tension runs in its own process on the Chrome platform.
We measured the memory consumption of creating two
extensions over a single extension and found an increase
in memory consumption of 20MB. This demonstrates
that our approach has no memory overhead as opposed
to the 20MB overhead of creating a new extension.
7 Related Work
The concept of privilege separation was ﬁrst formalized
by Saltzer and Schroeder [13]. Several have used priv-
ilege separation for increased security. We discuss the
most closely related works in the space.
Privilege Separation in Commodity OS Platforms.
Notable examples of user-level applications utilizing
privilege separation include QMail [18], OpenSSH [17]
and Google Chrome [19]. Brumley and Song investi-
gated automatic privilege separation of programmer an-
notated C programs and implemented data separation as
well [41]. More recently, architectures like Wedge [45]
identiﬁed subtleties in privilege separating binary appli-
cations and enforcing a default-deny model. Our work
shows how to achieve privilege separation in emerging
HTML5 applications, which are fuelling a convergence
between commodity OS applications and web applica-
tions, without requiring any changes to the browser plat-
form.
Re-architecting Browser Platforms. Several previ-
ous works on compartmentalizing web applications have
suggested re-structuring the browser or the underly-
ing execution platform altogether. Some examples in-
clude the Google Chrome extension platform [23], Es-
cudo [12], MashupOS [46], Gazelle [47], OP [48], IPC
Inspection [49], and CLAMP [50]. Our work advo-
cates that we can achieve strong privilege separation us-
ing abstractions provided by modern browsers. This ob-
viates the need for further changes to underlying plat-
forms. We point out that temporary origins is similar
to MashupOS’s “null-principal SERVICEINSTANCE” pro-
posal; therefore, the alternative line of research into new
browser primitives has indeed been fruitful. Our work
demonstrates how we can utilize these advancements by
combining deployed primitives (like temporary origins
and CSP [34]) to achieve effective privilege separation,
without requiring any further changes to the platform.

Carlini et al. [7] study the effectiveness of privilege
separation in the Chrome extension architecture and ﬁnd
that in 4 (19) out of 61 cases, insufﬁcient validation of
messages exchanged over the privilege boundary allowed
for full (partial) privilege escalation. In our design, we

Figure 5: Frequency distribution of event listeners and API
calls used by the top 42 extensions requiring the tabs permis-
sion.

and the memory consumption of the new DOM and
JavaScript heap created for each iframe. We measure the
impact of each below.
Performance Overhead. First, as a micro-benchmark,
we measured the run-time overhead caused by the par-
ent’s mediation on privileged APIs. We created a func-
tion that measures the total time taken to open a tab and
then close it. This involves four crossings of the privilege
boundary.

We performed the experiment 100 times with and
without privilege separation. The median time with and
without privilege-separation was 140ms and 80ms re-
spectively. This implies an overhead of 15ms on each
call crossing the sandbox.

As a macro-benchmark, we measured the amount of
time required to load an image in the Awesome Screen-
shot image editor. Recall that the image editor receives
the image data from the background page. We took a
screenshot of www.google.com and measured the time
taken for the image to load in the image editor, once
the background sends it. We repeated the experiment 20
times each for the privilege separated and the original
versions. The average (median) amount of time taken
for the image load was 72.5ms (77.3ms) for the image
load in the original Awesome Screenshot extension, and
78.5ms (80.1ms) for the image load in the privilege sep-
arated version—an overhead of 8.2% (3.6%). In our test-
ing, we have not noticed any user-perceivable increase in
latency after our redesign.
Memory Consumption. We measured the increase in
memory consumption caused by creating a new tempo-
rary origin iframe, and found no noticeable increase in
memory consumption.

On the Google Chrome platform, an alternate mech-
anism to get additional principals is creating a new ex-

13

 0 5 10 15 20 25 30 35 40 45 0 10 20 30 40 50Number of extensionsPercentage of API used (cumulative)explicitly prohibit the parent from using incoming mes-
sages in a way that can lead to code execution. Fur-
thermore, Chrome extensions today tend to have inﬂated
TCB in the privileged component as we show in Sec-
tion 5.4. This is in contrast to our proposed design.
Mashup & Advertisement Isolation. The problem
of isolating code in web applications, especially in
mashups [46, 51] and malicious advertisements [52], has
received much attention in research. Our work has sim-
ilarities with these works in that it uses isolation primi-
tives like iframes. However, one key difference is that
we advocate the use of temporary origins, which are now
available in most browsers, as a basis for creating arbi-
trary number of components.

In concurrent work, Treehouse [53] provides similar
properties, but relies on isolated web workers with a
virtual DOM implementation for backwards compatibil-
ity. A virtual DOM allows Treehouse to interpose on all
DOM events, providing stronger security and resource
isolation properties, but at a higher performance cost.
Language-based Isolation of web applications. Re-
cent work has focused on language-based analysis of
web application code, especially JavaScript, for conﬁne-
ment. IBEX proposed writing extensions in a high-level
language (FINE) that can later by analyzed to conform
to speciﬁc policies [21].
In contrast, our work does
not require developers to learn new language, and thus
maintains compatibility with existing code. Systems like
IBEX are orthogonal to our approach and can be sup-
ported on top of our architecture; if necessary, the par-
ent’s policy component can be written in a high-level lan-
guage and subject to automated analysis.

Heavyweight language-based analyses and rewriting
systems have been used for isolating untrusted code, such
as advertisements [28, 29, 54]. Our approach instead
relies on a lighter weight mechanism based on built-in
browser primitives like iframes and temporary origins.
8 Conclusion
Privilege separation is an important second line of de-
fense. However, achieving privilege separation in web
applications has been harder than on the commodity OS
platform. We observe that the central reason for this
stems in the same origin policy (SOP), which mandates
use of separate origins to isolate multiple components,
but creating new origins on the ﬂy comes at a cost. As a
result, web applications in practice bundle disjoint com-
ponents and run them in one monolithic authority. We
propose a new design that uses standardized primitives
already available in modern browsers and enables par-
titioning web applications into an arbitrary number of
temporary origins. This design contrasts with previ-
ous approaches that advocate re-designing the browser

or require adoption of new languages. We empirically
show that we can apply our new architecture to widely
used HTML5 applications right away; achieving dras-
tic reduction in TCB with no more than thirteen lines of
change for the applications we studied.
9 Acknowledgements
We thank Erik Kay, David Wagner, Adrienne Felt,
Adrian Mettler, the anonymous reviewers, and our shep-
herd, William Enck for their insightful comments. This
material is based upon work partially supported by the
NSF under the TRUST grant CCF-0424422, by the
Air Force Ofﬁce of Scientiﬁc Research (AFOSR) un-
der MURI awards FA9550-09-1-0539 and FA9550-08-
1-0352 and by Intel through the ISTC for Secure Com-
puting. The second author is supported by the Symantec
Research Labs Graduate Fellowship.
References
[1] Google Inc., “Google chrome webstore.” https:

//chrome.google.com/webstore/.

[2] HTTP Archive, “JS Transfer Size and JS Re-
http://httparchive.org/trends.

quests.”
php#bytesJS&reqJS.

[3] Google Inc., “Chromium os.”
chromium.org/chromium-os.

http://www.

[4] “Mozilla boot2gecko.” https://wiki.mozilla.

org/B2G.

[5] Microsoft,

“Metro

development,”
http://msdn.microsoft.com/en-us/

style

app

2012.
windows/apps/.

[6] H. Wang, A. Moshchuk, and A. Bush, “Conver-
gence of desktop and web applications on a multi-
service os,” in Proceedings of the 4th USENIX con-
ference on Hot topics in security, 2009.

[7] N. Carlini, A. P. Felt, and D. Wagner, “An evalua-
tion of the google chrome extension security archi-
tecture,” in Proceedings of the 21st USENIX Con-
ference on Security, 2012.

[8] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. Mc-
Camant, and D. Song, “A symbolic execution
framework for javascript,” in Proceedings of the
2010 IEEE Symposium on Security and Privacy,
pp. 513–528.

[9] S. Bandhakavi, S. T. King, P. Madhusudan, and
M. Winslett, “Vex: vetting browser extensions for
security vulnerabilities,” in Proceedings of the 19th
USENIX conference on Security, 2010.

14

[10] M. Dhawan and V. Ganapathy, “Analyzing in-
formation ﬂow in javascript-based browser ex-
tensions,” in Proceedings of the Computer Secu-
rity Applications Conference, pp. 382–391, IEEE,
2009.

[11] S. Guarnieri and B. Livshits, “Gatekeeper: mostly
static enforcement of security and reliability poli-
cies for JavaScript code,” in Usenix Security, 2009.

[12] K. Jayaraman, W. Du, B. Rajagopalan, and
S. Chapin, “Escudo: A ﬁne-grained protection
model for web browsers,” in Proceedings of the
30th International Conference on Distributed Com-
puting Systems, pp. 231–240, IEEE, 2010.

[24] A. P. Felt, K. Greenwood, and D. Wagner, “The
effectiveness of application permissions,” in Pro-
ceedings of the 2nd USENIX conference on Web ap-
plication development, 2011.

[25] K. W. Y. Au, Y. F. Zhou, Z. Huang, P. Gill, and
D. Lie, “Short paper: A look at smartphone per-
mission models,” in Proceedings of the 1st ACM
workshop on Security and privacy in smartphones
and mobile devices, 2011.

[26] A. P. Felt, “Advertising and android permissions,”
Nov 2011. http://www.adrienneporterfelt.
com/blog/?p=357.

[13] J. Saltzer and M. Schroeder, “The protection of in-
formation in computer systems,” Proceedings of the
IEEE, vol. 63, no. 9, pp. 1278–1308, 1975.

[27] Google Inc., “Google chrome extensions: chrome.*
http://code.google.com/chrome/

apis.”
extensions/api_index.html.

[14] “lxc

linux

sourceforge.net/.

containers.”

http://lxc.

[15] “Google seccomp sandbox for linux.” http://

code.google.com/p/seccompsandbox/.

[16] N. Provos, “Improving host security with system
call policies,” in Proceedings of the 12th USENIX
Security Symposium, 2003.

[17] N. Provos, M. Friedl, and P. Honeyman, “Prevent-
ing privilege escalation,” in Proceedings of the 12th
USENIX Security Symposium, 2003.

[18] D. J. Bernstein, “Some thoughts on security after
ten years of qmail 1.0,” in Proceedings of the 2007
ACM workshop on Computer security architecture.

[19] A. Barth, C. Jackson, C. Reis, and T. G. C.
Team, “The security architecture of the chromium
browser,” 2008.

[20] E. Y. Chen, J. Bau, C. Reis, A. Barth, and C. Jack-
son, “App isolation: get the security of multiple
browsers with just one,” in Proceedings of the 18th
ACM conference on Computer and communica-
tions security, pp. 227–238, 2011.

[21] A. Guha, M. Fredrikson, B. Livshits,

and
N. Swamy, “Veriﬁed security for browser exten-
sions,” in Proceedings of the IEEE Symposium on
Security and Privacy, pp. 115–130, 2011.

[22] “Html5 privilege separation: Source code release.”

http://github.com/devd/html5privsep.

[23] A. Barth, A. Felt, P. Saxena, and A. Boodman,
“Protecting browsers from extension vulnerabili-
ties,” in Proceedings of the 17th Network and Dis-
tributed System Security Symposium, 2010.

15

[28] S. Maffeis, J. C. Mitchell, and A. Taly, “Object ca-
pabilities and isolation of untrusted web applica-
tions,” in Proceedings of the 2010 IEEE Symposium
on Security and Privacy, pp. 125–140.

[29] Google Inc., “Issues: google-caja: A source-to-
for securing Javascript-based
content.” http://code.google.com/p/

source translator
web
google-caja.

[30] M. Finifter, J. Weinberger, and A. Barth, “Prevent-
ing capability leaks in secure JavaScript subsets,”
in Proc. of Network and Distributed System Secu-
rity Symposium, 2010.

[31] G. Tan and J. Croft, “An empirical security study
of the native code in the jdk,” in Proceedings of the
17th Usenix Conference on Security, pp. 365–377,
2008.

[32] A. Barth, “Rfc 6454: The web origin concept.”

http://tools.ietf.org/html/rfc6454.

[33] Bugzilla@Mozilla, “Bug 341604 - (framesand-
implement html5 sandbox attribute for
https://bugzilla.mozilla.org/

box)
iframes.”
show_bug.cgi?id=341604.

[34] B. Sterne and A. Barth, “Content security policy:
https://dvcs.

W3c editor’s draft,” 2012.
w3.org/hg/content-security-policy/
raw-file/tip/csp-specification.dev.
html.

[35] diigo.com, “Awesome screenshot : Capture anno-
tate share.” http://www.awesomescreenshot.
com/.

[50] B. Parno, J. M. McCune, D. Wendlandt, D. G. An-
dersen, and A. Perrig, “Clamp: Practical preven-
tion of large-scale data leaks,” in Proceedings of
the 30th IEEE Symposium on Security and Privacy,
pp. 154–169, 2009.

[51] A. Barth, C. Jackson, and W. Li, “Attacks on
javascript mashup communication,” in Workshop
on Web 2.0 Security and Privacy (W2SP), 2009.

[52] M. T. Louw, K. T. Ganesh, and V. N. Venkatakrish-
nan, “Adjail: practical enforcement of conﬁdential-
ity and integrity policies on web advertisements,”
in Proceedings of the 19th USENIX conference on
Security, 2010.

[53] L. Ingram and M. Walﬁsh, “Treehouse: Javascript
sandboxes to help web developers help them-
selves,” in Proceedings of the USENIX annual tech-
nical conference, 2012.

[54] “AdSafe : Making JavaScript Safe for Advertis-

ing.” http://www.adsafe.org/.

[36] Dropbox Inc., “Dropbox developer

reference.”

http://www.dropbox.com/developers/
reference.

[37] “Ace - ajax.org cloud9 editor.”

ajax.org/.

http://ace.

[38] The Dojo Foundation, “The dojo toolkit.” http:

//dojotoolkit.org/.

[39] GitHub Inc., “Edit like an ace.” https://github.

com/blog/905-edit-like-an-ace.

[40] “Oauth.” http://oauth.net/.

[41] D. Brumley and D. Song, “Privtrans: automatically
partitioning programs for privilege separation,” in
Proceedings of the 13th on USENIX Conference on
Security, 2004.

[42] P. Josling, “dropbox-js: A javascript library for
the dropbox api.” http://code.google.com/p/
dropbox-js/.

[43] A. van Kesteren (Ed.), “Cross-origin resource shar-

ing.” http://www.w3.org/TR/cors/.

[44] “pynarcissus : The narcissus javascript interpreter
ported to python.” http://code.google.com/
p/pynarcissus/.

splitting applications

[45] A. Bittau, P. Marchenko, M. Handley, and B. Karp,
“Wedge:
into reduced-
privilege compartments,” in Proceedings of the 5th
USENIX Symposium on Networked Systems Design
and Implementation, pp. 309–322, 2008.

[46] H. J. Wang, X. Fan, J. Howell, and C. Jackson,
“Protection and communication abstractions for
web browsers in mashupos,” SIGOPS Oper. Syst.
Rev., vol. 41, pp. 1–16, Oct. 2007.

[47] H. Wang, C. Grier, A. Moshchuk, S. King,
P. Choudhury, and H. Venter, “The multi-principal
os construction of the gazelle web browser,” in Pro-
ceedings of the 18th USENIX security symposium,
pp. 417–432, 2009.

[48] C. Grier, S. Tang, and S. King, “Designing and im-
plementing the op and op2 web browsers,” ACM
Transactions on the Web (TWEB), 2011.

[49] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna,
and E. Chin, “Permission re-delegation: Attacks
and defenses,” in Proceedings of the 20th USENIX
conference on Security, 2011.

16

