Structural Detection of Android Malware

using Embedded Call Graphs

Hugo Gascon

University of Göttingen
Göttingen, Germany

Fabian Yamaguchi
University of Göttingen
Göttingen, Germany

Konrad Rieck

University of Göttingen
Göttingen, Germany

Daniel Arp

University of Göttingen
Göttingen, Germany

ABSTRACT
The number of malicious applications targeting the Android
system has literally exploded in recent years. While the
security community, well aware of this fact, has proposed
several methods for detection of Android malware, most of
these are based on permission and API usage or the iden-
tiﬁcation of expert features. Unfortunately, many of these
approaches are susceptible to instruction level obfuscation
techniques. Previous research on classic desktop malware
has shown that some high level characteristics of the code,
such as function call graphs, can be used to ﬁnd similarities
between samples while being more robust against certain
obfuscation strategies. However, the identiﬁcation of simi-
larities in graphs is a non-trivial problem whose complexity
hinders the use of these features for malware detection. In
this paper, we explore how recent developments in machine
learning classiﬁcation of graphs can be eﬃciently applied to
this problem. We propose a method for malware detection
based on eﬃcient embeddings of function call graphs with an
explicit feature map inspired by a linear-time graph kernel.
In an evaluation with 12,158 malware samples our method,
purely based on structural features, outperforms several re-
lated approaches and detects 89% of the malware with few
false alarms, while also allowing to pin-point malicious code
structures within Android applications.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and Protection; K.6.5 [Computing Milieux]: Man-
agement of Computing and Information Systems—Security
and Protection - Invasive software; I.5.1 [Pattern Recog-
nition]: Models—Statistical

Keywords
Malware Detection; Graph Kernels; Machine Learning

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
AISec’13, November 4, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2488-5/13/11 ...$15.00.
http://dx.doi.org/10.1145/2517312.2517315

1.

INTRODUCTION

The growing popularity of smartphones and tablet com-
puters has made mobile platforms a prime target for attack.
In a recent study conducted by Juniper Networks, the num-
ber of malicious mobile applications observed in the wild is
reported to have grown exponentially at a rate of 614% be-
tween March 2012 and March 2013 [23]. Moreover, 92% of
these applications are found to target the Google Android
platform, creating the need for eﬀective defense mechanisms
to protect Android systems.

To account for this threat, the oﬃcial Android market
is regularly scanned for possibly malicious code. Unfortu-
nately, this process is often ineﬀective [22] and the market
is abused to deliver malware on a daily basis. Furthermore,
Android applications are also made available in third party
repositories, which often implement no methods for malware
detection at all. As a result, Android malware detection
has become a vivid area of research in both industry and
academia in recent years.

Several researchers have proposed to detect malware based
on manually speciﬁed expert features, such as the permis-
sions requested by applications [10, 14, 31] or the usage of
speciﬁc API functions [16, 44]. While these approaches add
an additional security layer to the Android platform, sev-
eral of the proposed mechanisms are easy to circumvent,
for example using kernel-based exploits or API-level rewrit-
ing [18]. Moreover, the designed expert features often target
a speciﬁc type of malware and hence fail to provide a generic
protection from malicious applications.

Fortunately, the vast majority of newly discovered mal-
ware samples are variations of existing malware, and thus
detecting similarities to known malware has shown to be a
promising approach [see 7, 16, 42].
Identifying variations
of code, however, is an involved task as small changes at
the source code may already have drastic eﬀects on com-
piled code: instructions may be reordered, branches may be
inverted or the allocation of registers may change [see 9].
To make matters worse, such changes are often introduced
deliberately by malware to evade detection.

Researchers dealing with the detection of malware target-
ing desktop systems have discovered that high-level proper-
ties of code, in particular function call graphs, oﬀer a suit-
ably robust representation to account for these variations
[21, 25]. By contrast, existing approaches for Android mal-
ware detection mostly focus on contextual information, such
as permission and API usage, and do not model the struc-
tural composition of code.

45In this paper, we therefore present a method for structural
detection of Android malware on a large scale. To this end,
we extract function call graphs from Android applications
and employ an explicit mapping inspired by a linear-time
graph kernel to eﬃciently map call graphs to an explicit fea-
ture space. A support vector machine is then trained to
distinguish between benign and malicious applications. In
an empirical evaluation on a total of 12,158 malware sam-
ples, this approach is shown to be highly eﬀective, enabling a
detection of 89% of the malware with only 1% false positives,
by analyzing the structure of the underlying code only.

In summary, our main contributions are the following.
‚ Generic labeling of Dalvik functions. We present
a generic labeling scheme for Dalvik code that enables
us to construct labeled function calls graphs without
information about function names.

‚ Explicit embedding of call graphs. We derive a
feature map inspired by graph kernels that allows for
embedding function call graphs in a vector space cap-
turing structural relationships.

‚ Structural detection of Android malware. The
vectorial representation of function call graphs ﬁnally
enables us to detect Android malware with high accu-
racy using machine learning techniques.

The rest of this paper is structured as follows: we intro-
duce our method for analyzing function call graphs and de-
tecting Android malware in Section 2 and present a detailed
evaluation in Section 3. Limitations of our approach and
related work are discussed in Section 4 and 5 respectively.
Section 6 concludes the paper.

2. STRUCTURAL MALWARE DETECTION
Our method for the detection of Android malware is based
on two key observations. First, malicious functionality of
an Android application often concentrates on only a small
number of its functions and second, similar malicious code
is often found throughout the malware landscape as attack-
ers reuse existing code to infect diﬀerent applications. Our
method therefore strives to identify subgraphs of the func-
tion call graph representing known malicious code. This is,
however, not trivial, in particular since no polynomial time
solution exists to test whether two graphs are isomorphic.

In consequence, several solutions have been developed for
inexact matching. Some of these methods rely on subop-
timal strategies such as the graph edit distance [21] or the
identiﬁcation of maximum common subgraphs, while other
ad hoc solutions propose the serialization of the graph struc-
ture [5] as a way to measure similarity. In most setups, this
similarity metric is later used in a neighbor search to identify
close candidates to a test sample.

When it comes to classiﬁcation tasks, kernel-based sup-
port vector machines (SVM) have been proven extremely
powerful. Graph kernels have emerged as a solution to let
SVM operate eﬃciently in the graph space. A graph ker-
nel is, in short, a kernel function that computes an inner
product on graphs. These kernels have been proposed at
several occasions to address graph classiﬁcation problems in
chemistry and bioinformatics, however, their applicability to
static malware analysis remains largely unexplored.

Some graph kernels are designed to operate only on unla-
beled graphs or are unable to be evaluated on graphs with
more than a few hundreds of nodes. Moreover, many of these
kernels induce only an implicit feature space, which makes it
impossible to determine the features predominantly respon-
sible for the classiﬁcation of a sample.

The use of graph kernels for the task of malware detection
allows to abstract the code into a representation that enables
learning its underlying structure. However, function call
graphs have thousands of nodes and are characterized as
directed labeled graphs. Therefore, it is necessary to apply
a graph kernel that can not only deal with these speciﬁcities,
but can also operate on a large number of nodes eﬃciently.
In this paper, we show how the combination of a graph kernel
that meets these requirements and a convenient embedding
in an equivalent explicit vector space can be applied to the
problem of malware detection successfully.

The resulting method comprises the following major steps:

1. Call graph extraction and labeling. The function call
graph for an application is extracted, which contains
a node for each function of the application. Nodes are
labeled according to the instructions contained in their
corresponding functions (Section 2.1).

2. Hashing of neighborhoods. For each node in the func-
tion call graph, a hash-value is calculated over the node
and direct neighboring nodes, allowing occurrences of
graph substructures to be eﬃciently and explicitly enu-
merated (Section 2.2).

3. Feature space embedding. Samples are embedded us-
ing an explicit map inspired by the neighborhood hash
graph kernel introduced by Hido and Kashima [20].
The map is designed such that evaluating an inner
product in the feature space is equivalent to computing
the respective graph kernel (Section 2.3).

4. Learning and feature analysis. A linear support vector
machine is trained to learn a detection model that is
able to classify applications as benign or malicious.
The explicit feature space is then used to highlight
subgraphs in an application likely to contain malicious
functionality (Section 2.4).

In the following sections, each of these steps is described

in greater detail.
2.1 Call Graph Extraction and Labeling

In the ﬁrst step of our method, applications are disas-
sembled and their function call graphs are extracted using
the Androguard framework [8].
In addition, nodes of the
function call graph are labeled to characterize their content
conveniently by short bit sequences.

Intuitively, the extracted function call graphs are directed
graphs containing a node for each of the application’s func-
tions and edges from callers to callees. Moreover, a labeled
function call graph can be constructed by attaching a label
to each node. Formally, this graph can be represented as
a 4-tuple G “ pV, E, L, (cid:96)q, where V is a ﬁnite set of nodes
and each node v P V is associated with one of the appli-
cation’s functions. E Ď V ˆ V denotes the set of directed
edges, where an edge from a node v1 to a node v2 indicates
a call from the function represented by v1 to the function
represented by v2. Finally, L is the multiset of labels in the

46graph and (cid:96) : V Ñ L is a labeling function, which assigns a
label to each node by considering properties of the function
it represents.

The design of the labeling function (cid:96) is crucial for the
success of our method. While in principle, a unique label
could be assigned to each node, this would not allow the
method to exploit properties shared between functions. By
contrast, a suitable labeling function maps two nodes onto
the same label if their functions share properties relevant
to the detection task. Moreover, labeling must be robust
against small changes in the code such as identiﬁer renaming
or branch inversion.

To meet these requirements, we propose to label nodes
according to the type of the instructions contained in their
respective functions. Reviewing the Dalvik speciﬁcation, we
deﬁne 15 distinct categories of instructions based on their
functionality as shown in Table 1. Each node can thus be
labeled using a 15-bit ﬁeld, where each bit is associated with
one of the categories.

Category Bit

Category

Bit

nop
move
return
monitor
test
new
throw
jump

1
2
3
4
5
6
7
8

branch
arrayop
instanceop
staticop
invoke
unop
binop

9
10
11
12
13
14
15

Table 1: List of instruction categories and their cor-
responding bit in the label assigned to each node.

Formally, the function (cid:96) can be deﬁned as follows: We
denote the set of categories by C “ tc1, c2,¨¨¨ , cmu and the
function associated with a node v by fv. The label (cid:96)pvq of
a node v P V is then a bit ﬁeld of length m, i.e., (cid:96)pvq “
rb1pvq, b2pvq,¨¨¨ , bmpvqs where

#

bcpvq “

1 if fv contains an instruction from category c
0 otherwise.

Consequently, the set of labels L is given by a subset of all
possible 15-bit sequences. As an example, Figure 1 shows
the disassembled code of a function named openWebURL and
the categories assigned to each of its instructions. Note that
the function contains the new-instance instruction, which
is used to instantiate an object. This instruction is part of a
larger set of instructions denoted as new and associated with
the sixth bit of the label. The sixth bit is therefore set in
the resulting function label.
2.2 Hashing of Neighborhoods

Upon labeling nodes in the function call graph, each func-
tion is characterized by the instructions it contains. How-
ever, our method strives to model the composition of func-
tions and thus the neighborhood of a function must be taken
into account. To this end, for each node, we compute a
neighborhood hash over all of its direct neighbors in the func-
tion call graph, a procedure inspired by the neighborhood
hash graph kernel (NHGK) originally proposed by Hido and
Kashima [20].

Instructions

Category Bit

#LX;->openWebURL(Ljava/lang/String;)V

new-instance v0, Landroid/content/Intent;
const-string v1, android.intent.action.VIEW
invoke-static v4, Landroid/net/Uri;->
parse(Ljava/lang/String;)Landroid/net/Uri;
move-result-object v2
invoke-direct v0, v1, v2,
Landroid/content/Intent;->
<init>(Ljava/lang/String; Landroid/net/Uri;)V
invoke-virtual v3, v0,
Lru/getcorvin/mettir/MetrDotel;->
startActivity(Landroid/content/Intent;)V
return-void

new
move
invoke

move
invoke

6
2
13

2
13

invoke

13

return

3

Bit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0

Label 0 1 1 0 0 1 0 0 0

0

0

0

0

1

Figure 1: Labeling example of a method from its
code. Every opcode belongs to a category, which is
a associated to a certain bit in the label.

The NHGK is a so called decomposition kernel as de-
ﬁned by Haussler [19]. As such, it is a kernel operating
over an enumerable set of subgraphs in a labeled graph. It
has low computational complexity and high expressiveness
of the graph structure, but its main advantage is that it is
able to run in time linear in the number of nodes and can
therefore process graphs with thousands of nodes such as
the function call graphs of Android applications.

The main idea behind the NHGK is to condense the infor-
mation contained in a neighborhood into a single hash value.
This value is calculated over the labels of a neighborhood
and represents the distribution of the labels around a cen-
tral node. It thus allows us to enumerate all neighborhood
subgraphs in linear time without running an isomorphism
test over all pairs of neighborhoods.

The computation of the hash for a given node v and its

set of adjacent nodes Vv is deﬁned by the operation

¸

˜à

zPVv

hpvq “ rp(cid:96)pvqq ‘

(cid:96)pzq

(1)

where ‘ represents a bit-wise XOR on the binary labels and
r denotes a single-bit rotation to the left. This computa-
tion can be carried out in constant time for each node, more
speciﬁcally in Θpmdq time where d is the maximum outde-
gree and m the length of the binary label.
The neighborhood hash of a complete graph G denoted by
Gh “ hpGq “ pV, E, Lh, hp¨qq is then obtained by calculating
hashes for each node individually and replacing the original
labels with the calculated hash values. This creates an ad-
ditional linear dependence of the computation time on the
number of nodes in the graph. Furthermore, it can be noted
that the hash values have the same length m as the origi-
nal label, however, they aggregate information spread across
neighboring nodes. Moreover, the hash values are indepen-
dent of the actual order in which children are processed, and
thus sorting is not necessary.

Hido and Kashima also consider applying the neighbor-
hood hash iteratively to aggregate information across neigh-
bors up to a path length p. The neighborhood hash of or-
der p can then be deﬁned recursively as Gpp`1q “ hpGpq.
Choosing p larger than one still allows to construct a valid
decomposition kernel, however, higher values of p also lead
to an increased number of overlapping substructures.

47Since we are particularly interested in designing an ex-
plicit representation of the kernel feature space that is easy
to interpret by analysts, we thus ﬁx p “ 1 in order to limit
the complexity of the feature space.
2.3 Feature Space Embedding

The neighborhood hash graph kernel function, evaluates
the count of common identical substructures in two graphs,
which after the hashing, is the number of shared node labels.
Considering that several nodes can be labeled with the same
hash, the kernel value can be represented as the size of the
intersection of the multisets Lh and L1
h for two function call
graphs Gh and G1

h, that is,
KpGh, G

hq “ |Lh X L
h|
1
1

(2)

For the speciﬁc application of malware analysis, our goal
is to ﬁnd an explicit representation that is equivalent to that
of the graph kernel. In this vector space, a linear SVM can
be used to learn a model that is able to (a) classify samples
into benign and malicious applications and (b) allows for
an interpretation of its decisions. In order to achieve this,
we abstain from using the implicit kernel function K, but
instead embed every sample in a feature space whose inner
product is equivalent to the graph kernel.
To this end, we start by considering the histogram of the
multiset Lh as H “ ta1, a2,¨¨¨ , aNu, where ai P N indicates
the occurrences of the i-th hash in Gh. The number of shared
elements between two multisets can be calculated by sorting
all elements of a certain type and counting the minimum
number of elements of this type that are present in both
multisets. This is known as the multiset intersection. If the
size of the intersection of two histograms H and H1 of length
N is deﬁned as

SpH, H

minpai, a

iq
1

(3)

1q “ Nÿ

i“1

it becomes apparent that the kernel deﬁned in Eq. (2) can
be also phrased using the intersection of the histograms for
two graphs Gh and G1

h as
KpGh, G
hq “ SpH, H
1

1q.

(4)

Barla et al. [2] show that this histogram intersection can
be indeed adopted in kernel-based methods and propose a
feature mapping, such that S is an inner product in the
induced vector space. For this purpose, each histogram H
hkkkikkkj
aNhkkkikkkj
is mapped to a P -dimensional vector φpHq as follows
looooooooomooooooooon
M´aN
0,¨¨¨ , 0
1,¨¨¨ , 1,

¨˝ a1
hkkkikkkj
hkkkikkkj
loooooooooomoooooooooon
M´a1
0,¨¨¨ , 0,
1,¨¨¨ , 1,

˛‚ (5)

φpHq “

¨¨¨ ,

bin 1

bin N

where M is the maximum value of all bins in the dataset,
N is the number of bins in each histogram and P “ N M is
the dimension of the vector.

In this representation, each bin i of the histogram is asso-
ciated with M dimensions in the vector space. These dimen-
sions are ﬁlled with 1’s according to the value of ai, whereas
the remaining M ´ ai dimensions are set to 0. As a result,
the sum of the M dimensions associated with the i-th bin is
equal to ai and moreover the sum of all dimensions in φpHq
is equal to the sum of all bins in the histogram.

By putting the diﬀerent steps together, we can ﬁnally
show that the inner product in the vector space induced

by Eq. (5) indeed resembles the neighborhood hash graph
kernel given in Eq. (2). That is, we have

KpGh, G

hq “ SpH, H
1

1q “ xφpHq, φpH

1qy.

(6)

The interested reader is referred to the original work of Barla
et al. [2], which provides a more detailed analysis of his-
togram intersections and this mapping.

The mapping φ ﬁnally allows us to embed every call graph
in a feature space, where a linear SVM can be used for eﬃ-
ciently learning with hundreds of thousands of graphs each
containing thousands of nodes and edges.
2.4 Learning and Feature Analysis

A two-class classiﬁcation problem can be then posed and
solved by means of a linear SVM, which learns a linear sep-
aration of the given classes with a maximum margin [13].
The decision function f of the linear SVM is given by

fpGhq “ xφpHq, wy ` b,

(7)
where w P RP is the direction of the hyperplane and b the
oﬀset from the origin of the vector space. In this setting, a
function call graph Gh is classiﬁed as malicious if fpGhq ą 0
and as benign if fpGhq ď 0.

In order to identify what substructures of Gh contribute
to this decision, it is necessary to reverse the expansion per-
formed in Eq. (5). In particular, we compute an aggregated
weight ˆwi for each bin i of the histogram (corresponding to
the i hash value of the graph Gh). Formally, this is achieved
for the i-th bin of the histogram as follows

pi`1qMÿ

ˆwi “

wj.

j“iM

(8)

The largest of these aggregated weights allows us to high-
light those neighborhoods in a given graph Gh that predom-
inantly inﬂuence the decision and can be interpreted as typ-
ically belonging to the malicious class. That is, if the weight
ˆwi of the i-th bin is large, all nodes labeled with the corre-
sponding hash value signiﬁcantly contribute to the decision
of the SVM and thus likely reﬂect malicious functionality.

As a last step and as we will see in the evaluation section,
a relevance map can be constructed by shading each node in
the graph with the sum of the weights of the neighborhoods
it belongs to. This will produce a representation that is
ready for visual inspection and further feature analysis by a
malware analyst.

3. EVALUATION

Our method is evaluated on a large data set of real An-
droid applications. We begin by providing a detailed de-
scription of our data set in Section 3.1 and demonstrating
that our method scales linearly in the number of functions
contained in an application. We then proceed to evaluate
our method’s ability to detect malicious Android applica-
tions in Section 3.2. Finally, a case study on a malware
sample from a popular family is given in Section 3.3 to high-
light the practical advantages of an explicit feature space.
3.1 Data Set

The data set used in our evaluation consists of 135,792
benign and 12,158 malicious Android applications obtained
from both the oﬃcial Google Play store as well as popu-
lar third-party markets. To decide whether an application

48(a) Sample size distribution

(b) Neighborhood size distribution

(c) Average neighborhood size

Figure 2: Characteristics of the dataset: (a) distribution of the number of nodes per sample, (b) size of
neighborhoods across the dataset and (c) the average size of a neighborhood within an individual sample.

(a) Distribution of Dalvik op-codes

(b) Distribution of 15-bit labels

(c) Runtime of feature vector

Figure 3: Distribution of (a) instruction categories and (b) labels over all functions in the dataset, and
(c) runtime of the embedding as a function of the number of nodes in the graph.

is malicious or not, we employ 10 commercial malware de-
tectors and consider a sample to be benign if none of the
scanners triggers an alert while in all other cases we label
the application as malicious. We proceed to extract function
call graphs from each application to examine the properties
of the data set in more detail.

Figure 2(a) shows the sample size distribution obtained by
determining the number of functions in each application. We
observe that most applications are rather small, consisting of
less than 2,000 functions, however, applications consisting of
up to 16,000 functions exist and must therefore be accounted
for by our method. Furthermore, we examine the number
of outgoing calls made by functions as illustrated in the dis-
tribution shown in Figure 2(b). We ﬁnd that the majority
of functions contain less than 50 outgoing calls. Moreover,
Figure 2(c) shows the average number of outgoing calls to
be only slightly above two, thus making the computation of
neighborhood hashes very eﬃcient.

We further examine the distribution of the diﬀerent cat-
egories of Dalvik instructions as shown in Figure 3(a). We
observe that the return class has the highest probability,
as an instruction of this type is present in every method.
On the contrary, certain types of instructions rarely occur.
For example, the nop instruction, which performs no opera-
tion, or the monitor instruction, which is used for synchro-
nization. This observation that some instructions are much
more common than others seems problematic at ﬁrst, as it

suggests that labels will not be equally distributed, possi-
bly distorting the distribution of updated node labels once
the neighborhood hash is computed. However, Figure 3(b)
shows how the distribution of 15-bit node labels is not sig-
niﬁcantly skewed and every possible label appear in the call
graphs extracted from the dataset.

Finally, we evaluate the runtime performance of the fea-
ture extraction process presented in Section 2.3. Figure 3(c)
shows the time required to process a sample plotted against
the sample size. We observe that the computation of fea-
ture vectors indeed scales linearly in the number of functions
contained in a sample.

3.2 Malware Detection

The experiment for malware detection is posed as a su-
pervised two-class classiﬁcation problem. Random subsets
of benign and malicious applications from the dataset are
embedded and split into training and testing sets which are
then fed to the linear SVM algorithm.

Figure 4 shows a ROC curve which illustrates the per-
formance of the binary classiﬁer. Bounded to a maximum
false-positive rate (FPR) of 10% the area under the curve
reaches a value of 0.935. The performance measure is de-
picted along three recently proposed methods for static de-
tection of Android malware that we have also tested on our
dataset: Kirin [10], RCP [35] and the approach proposed
by Peng et. al in [31], where we implement the latter using

0200040006000800010000120001400016000NumberofNodes−0.00020.00000.00020.00040.00060.00080.00100.0012ProbabilityDensity406080100120140NeighborhoodSize10−910−810−710−610−510−410−310−210−1ProbabilityDensity(log)1.52.02.53.03.5AverageNeighborhoodSize−0.20.00.20.40.60.81.01.21.41.6ProbabilityDensitynopmovereturnmonitortestnewthrowjumpbrancharrayopinstanceopstaticopinvokeunopbinop0.000.050.100.150.200.25ProbabilityDensity50001000015000200002500030000Label(decimal)10−710−610−510−410−310−210−1ProbabilityDensity(log)−50000500010000150002000025000300003500040000SampleSize(nodes)−202468101214ComputationTime(s)49Id Family

# Id Family

DroidDream
SMSreg
Kmin
FakeInstaller
FakeRun
Yzhc
DroidKungFu
SendPay
Adrd
Adware.Airpush

0
1
2
3
4
5
6
7
8
9
10 BaseBridge

71
49
145
859
58
31
570
44
82
175
319

Iconosys

11 Glodream
12 ExploitLinuxLotoor
13
14 GinMaster
15 MobileTx
16
17 Hamob
18 Opfake
19 Plankton
20 Geinimi

FakeDoc

#

67
46
52
271
55
116
31
606
545
84

Figure 4: Detection performance as ROC curve for
our method and related detection methods.

Figure 5: Detection accuracy for the largest mal-
ware families in the dataset (see Table 2)

SVM instead of a naive bayes classiﬁer. Our method signiﬁ-
cantly outperforms these approaches and detects 89% of the
malware at a false-positive rate of only 1%—corresponding
to only one false alarm when installing 100 applications on
a smartphone. The related methods enable a detection be-
tween 10%-50% at the same false-positive rate, likely due to
their focus on Android permissions which reﬂect only little
of the information inside a malicious application.

Several of the malware samples in our dataset are labeled
with a particular malware family. Table 2 shows a list of the
21 largest families in our dataset. Using this labeling, we
are able to show in Figure 5 the detection performance of
the SVM for the individual families. For several families a
detection rate above 90% is achieved. It can be noted that
certain malware families, like 12 and 13, are detected with
lower accuracy than the rest. However, the standard error
for these measures is also considerable larger than that of
the families with better performance, what indicates that
these measures have a lower conﬁdence as a result of the
limited number of samples available.
3.3 Case Study: FakeInstaller

A weakness of many machine learning approaches to mal-
ware detection [e.g., 35, 39] is their inability to provide inter-
pretable results. Therefore, it is often diﬃcult for analysts
to understand why samples are marked as benign or ma-
licious. Our method addresses this shortcoming by using
an explicit feature space representation. The advantage of
this representation is that it allows a weight to be attached

Table 2: List of malware families with largest num-
ber of samples in the dataset.

to each node of the call graph according to its importance
for the decision. This allows the analyst to highlight nodes
corresponding to functionality deemed malicious, simply by
considering only nodes with large weights.

As an example, Figure 6 shows the function call graph
of Android.Trojan.FakeInst.AS, a sample from the FakeIn-
staller malware family. Note, that disconnected nodes are
not displayed to obtain a cleaner presentation. By shading
each node in accordance with the sum of the weights ˆwi of
the neighborhoods it belongs to, this allows a visual map to
be constructed. This map is suitable to guide the analyst
during the examination of a sample classiﬁed as malicious
as it points directly to function neighborhoods considered
typical for malware by the classiﬁer.

Figure 7 shows a more concise example, the complete call
graph of Android:RuFraud-C again from the FakeInstaller
family. Samples from this malware family are wide spread
and are often repackaged versions of popular applications.
Malware authors hide the malicious code in these modiﬁed
packages and upload them to third-party markets. Once
a user installs the application, it will send SMS messages
to expensive premium services owned by the authors. This
speciﬁc sample, an SMS Trojan, ﬁrst determines the Mobile
Country Code of the device and, depending on the result,
sends an SMS message to a premium number.

The depicted call graph of this sample includes in every
node the class name, the function name and the ﬁnal weight
assigned to each individual node. It can be observed how
the learned model assigns a high weight to the neighbor-
hood of the sendSms function of the FileloaderActivity
class. This speciﬁc function is called by the malware to
send multiple SMS messages to diﬀerent premium numbers.
The numbers are stored in the SmsClass class and accessed
using the getSms function. The sendSms function, which has
been tagged with the highest weight, is therefore identiﬁed
as the most insidious element in the sample.

We found similar code structures in other members of the
FakeInstaller family and although these methods are often
renamed by the malware authors to obfuscate their malicious
intent, our method is still able to correctly identify them as
malicious and assign a high weight to their neighborhoods.

4. LIMITATIONS

By analyzing the global structure of Android applications,
our method is resilient towards typical local obfuscation
techniques, such as instruction reordering, branch inversion
or the renaming of packages and identiﬁers. However, as

0.000.020.040.060.080.10FalsePositiveRate0.00.20.40.60.81.0TruePositiveRateExpl.NHGKPeng.etAlRCPKIRIN01234567891011121314151617181920Family0.00.20.40.60.81.0DetectionAccuracy50Figure 6: Subgraph from the function call graph of “Android.Trojan.FakeInst.AS” from the malware family
FakeInstaller. Dark shading of nodes indicate malicious structures identiﬁed by the SVM.

Figure 7: Complete function call graph of “Android:RuFraud-C” from the malware family FakeInstaller. Dark
shading of nodes indicate malicious structures identiﬁed by the SVM.

a purely static method, it suﬀers from the inherent limita-
tions of static code analysis.
In particular, the construc-
tion of static call graphs is undecidable and thus the func-
tion call graphs processed by our method are typically over-
approximations.
In principle, this works towards the at-
tacker’s advantage, as the call graph can be obfuscated by
adding unreachable calls. Moreover, function inlining can
be used to hide the graph structure. While in the extreme
case, this allows for the creation of malware with only a
single function, Android’s event-driven programming model
usually prohibits this in practice.

Attackers may also target the decompilation process to
evade detection by our method. For example, invalid but
unreachable bytecode sequences (“junk code”) can be delib-
erately inserted to hinder successful decompilation. More-
over, bytecode unpacked and loaded at runtime cannot be
processed by the decompiler and thus can only be consid-
ered if our method is coupled with dynamic analysis tech-
niques. Finally, native code is currently not analyzed, how-
ever, this is not a fundamental limitation, as our method
can be adapted to process native code by adding a suitable
decompilation stage and a corresponding labeling.

While these obfuscation techniques may be employed by
malware targeting desktop computers, they are rarely en-
countered in current Android malware so far. This hypoth-
esis is supported by the high detection performance observed
in the empirical evaluation (see Section 3).

5. RELATED WORK

The analysis of malicious code and its structure have been
a vivid area of security research in the last years. In the fol-
lowing, we ﬁrst discuss related work on structural code com-
parison in general and then proceed to present approaches
speciﬁcally designed for static detection of Android malware.

Structural Comparison of Code.

Determining similar program code is an important prob-
lem encountered in several areas of security research, in-
cluding the detection of malware [1, 21, 27, 36], software
plagiarism [28, 30] and vulnerabilities [9, 40]. To this end,
several methods to assess the structural similarity of code
have been proposed. For example, Kruegel et al. [27] as
well as Cesare and Xiang [6] present methods for polymor-
phic malware detection based on the comparison of control
ﬂow graphs. In particular, Kruegel et al. perform graph la-
beling to preserve instruction level information in a similar
manner as performed by our method. Unfortunately, both
approaches are based on sets of control ﬂow graphs and thus
ignore the composition of functions entirely. We address this
shortcoming by taking into account the function call graph.
Other researchers have also recognized function call graphs
as a robust representation for code comparison. For exam-
ple, Hu et al. [21] as well as Shang et al. [36] deﬁne similarity
metrics for function call graphs, however, without consider-

FileloaderActivity;timerMethod-0.0939516002911FileloaderActivity;sendSms0.612777546256FileloaderActivity$1;run-0.15376949588FileloaderActivity;access$000-0.131014990905FileloaderActivity$1;<init>-0.435965822755FileloaderActivity;access$200-0.14518686699FileloaderActivity;onCreate-0.165418207702SmsClass;getSms-0.0812504575594FuckingSms;<init>-0.186379864911R$string;<init>-0.303240245663R$attr;<init>-0.303240245663FileloaderActivity;<init>0.000858676313552FileloaderActivity$2;<init>-0.26968893874FileloaderActivity$2;run0.108455483836FuckingSms;getText-0.14518686699FileloaderActivity;access$100-0.14518686699FileloaderActivity;access$3000.335723394146FileloaderActivity;access$400-0.14518686699FuckingSms;getNumber-0.14518686699R$layout;<init>-0.303240245663SmsClass;<init>-0.303240245663R$drawable;<init>-0.303240245663R$id;<init>-0.303240245663R;<init>-0.30324024566351ing the use of supervised learning techniques to automat-
ically detect malware. The related problem of clustering
known malware into families has been considered by Kin-
able and Kostakis [24], who use approximations to graph
edit-distances to cluster malware by call graph similarity.
Eﬃciency is however, not a primary concern in this setting,
whereas it is vital in malware detection, a problem we ad-
dress using an eﬃcient linear time mapping.

Kernel functions for structured data have been pioneered
by Haussler [19] and have been ﬁrst applied over graphs by
Kondor et al. [26]. Graph kernels have since then been ap-
plied mainly in bioinformations [e.g., 3, 37] and chemical
informatics [e.g., 20, 33]. Unfortunately, the high compu-
tational eﬀort involved has prohibited many applications in
the past. Researchers have therefore focused on developing
eﬃcient approximations of graph kernels. An overview of
these approaches is given in [4].

Regardless of these eﬀorts, graph kernels have found little
attention in malware detection to date. An exception is
the work by Wagner et al. [38] and Anderson et al. [1] who
use graph kernels to analyze execution traces obtained from
dynamic analysis.

Static Detection of Android Malware.

The increasing popularity of mobile devices has made An-
droid a prime target for attack. Consequently, a unique
malware landscape has evolved in recent years as described
in surveys by Felt et al. [15] and Zhou and Jiang [43]. To
counter this emerging threat, methods based on both static
code analysis [e.g., 10, 14, 31, 42] and dynamic code analy-
sis [e.g., 11, 32, 34, 41, 44] have been proposed.

Most existing static approaches have focused on the An-
droid permission system. For example, Enck et al. [10] an-
alyze the permissions requested by applications at install
time and manually formulate rules to detect malicious ap-
plications. Similarly, Peng et al. [31] analyze permissions
to infer probabilistic models for malicious applications. Felt
et al. [14] go one step further by correlating requested per-
missions with statically observable API calls to detect over-
privileged applications. Unfortunately, these approaches are
unable to detect malware which elevates its privileges by ex-
ploiting vulnerabilities [see 12, 29].

A second strain of research focuses on detecting variants
of known malware families. For example, Zhou et al. [42]
as well as Hanna et al. [17] employ feature hashing on byte
code sequences to measure code similarity. Furthermore,
Crussel et al. [7] present a method called DNADroid, which
compares program dependence graphs. Finally, RiskRanker
by Grace et al. [16] compares function call graphs. Unfortu-
nately, RiskRanker requires source and sink functions com-
monly linked to malicious behavior to be speciﬁed manually,
thus requiring constant manual adaption to changing trends
in malware development. In contrast, the classiﬁer learned
by our method can be easily adapted by re-training on more
recent malware data sets.
6. CONCLUSION AND FUTURE WORK

In this work, we have presented a learning-based method
for the detection of malicious Android applications. Our
method employs an explicit feature map inspired by the
neighborhood hash graph kernel to represent applications
based on their function call graphs. This representation is
shown to be both, eﬃcient and eﬀective, for training an

SVM that ultimately enables us to automatically identify
Android malware with a detection rate of 89% with 1% false
positives, corresponding to one false alarm in 100 installed
applications on a smartphone.

As the vast majority of mobile malware targets the An-
droid platform, this work focuses on Android malware de-
tection. However, the method presented can be adapted to
other platforms with minor changes, given that (a) function
call graphs can be extracted and (b) instructions can be suit-
ably categorized. Adapting the method to other platforms,
including desktop systems, may thus be an interesting direc-
tion for future work. Moreover, combining existing classiﬁers
based on contextual features with our structural detection
approach seems promising.

7. ACKNOWLEDGEMENTS

This work has been supported by the German Federal

Ministry of Education and Research (BMBF) under the project
PROSEC (FKZ 01BY1145). We thank Felix Leder for fruit-
ful discussions and Michael Spreitzenbarth for supplying us
with the malware samples.

References
[1] B. Anderson, D. Quist, J. Neil, C. Storlie, and T. Lane.
Graph-based malware detection using dynamic analy-
sis. Journal in Computer Virology, 2011.

[2] A. Barla, F. Odone, and A. Verri. Histogram intersec-
tion kernel for image classiﬁcation. In Proc. of Interna-
tional Conference on Image Processing, ICIP, volume 2,
pages III–513–516, 2003.

[3] K. M. Borgwardt, C. S. Ong, S. Sch¨onauer, S. V. N.
Vishwanathan, A. J. Smola, and H.-P. Kriegel. Protein
function prediction via graph kernels. Bioinformatics,
2005.

[4] K. Borhwardt. Graph Kernels. PhD thesis, University

of Munich, 2007.

[5] S. Cesare and Y. Xiang. Classiﬁcation of malware us-
ing structured control ﬂow. In Proc. of the Eighth Aus-
tralasian Symposium on Parallel and Distributed Com-
puting, 2010.

[6] S. Cesare and Y. Xiang. Malware variant detection us-
ing similarity search over sets of control ﬂow graphs.
In Proc. of the International Conference on Trust, Se-
curity and Privacy in Computing and Communications
(TrustCom), 2011.

[7] J. Crussell, C. Gibler, and H. Chen. Attack of the
clones: Detecting cloned applications on android mar-
kets. In Proc. of European Symposium on Research in
Computer Security (ESORICS), 2012.

[8] A. Desnos. Androguard - Reverse engineering, Malware
and goodware analysis of Android applications. http:
//code.google.com/p/androguard/, 2013.

[9] T. Dullien and R. Rolles. Graph-based comparison of

executable objects, 2005.

52[10] W. Enck, M. Ongtang, and P. D. McDaniel. On
lightweight mobile phone application certiﬁcation.
In
Proc. of ACM Conference on Computer and Commu-
nications Security (CCS), pages 235–245, 2009.

[11] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox,
J. Jung, P. McDaniel, and A. Sheth. Taintdroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In Proc. of USENIX Sym-
posium on Operating Systems Design and Implementa-
tion (OSDI), pages 393–407, 2010.

[12] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri.
In Proc. of

A study of Android application security.
USENIX Security Symposium, 2011.

[13] R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang,
and C.-J. Lin. LIBLINEAR: A library for large linear
classiﬁcation. Journal of Machine Learning Research
(JMLR), 9:1871–1874, 2008.

[14] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wag-
ner. Android permissions demystiﬁed. In Proc. of ACM
Conference on Computer and Communications Security
(CCS), pages 627–638, 2011.

[15] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and D. Wag-
ner. A survey of mobile malware in the wild. In Proc.
of ACM Worksgop on Security and Privacy in Smart-
phones and Mobile Devices (SPSM), pages 3–14, 2011.

[16] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.
Riskranker:
scalable and accurate zero-day android
malware detection. In Proc. of International Conference
on Mobile Systems, Applications, and Services (MO-
BISYS), pages 281–294, 2012.

[17] S. Hanna, E. Wu, S. Li, C. Chen, D. Song, and
L. Huang. Juxtapp: A scalable system for detecting
code reuse among android applications.
In Detection
of Intrusions and Malware & Vulnerability Assessment
(DIMVA), 2012.

[18] H. Hao, V. Singh, and W. Du. On the eﬀectiveness of
api-level access control using bytecode rewriting in an-
droid.
In Proc. of the ACM SIGSAC symposium on
Information, computer and communications security,
2013.

[19] D. Haussler. Convolution kernels on discrete structures.
Technical Report UCSC-CRL-99-10, UC Santa Cruz,
July 1999.

[20] S. Hido and H. Kashima. A linear-time graph kernel.
In Proc. of International Conference on Data Mining
(ICDM), pages 179–188, 2009.

[21] X. Hu, T.-c. Chiueh, and K. G. Shin. Large-scale mal-
In Proc. of
ware indexing using function-call graphs.
the ACM conference on Computer and communications
security, 2009.

[22] X. Jiang. An evaluation of the application (”app”) ver-
iﬁcation service in android 4.2, December 2012. http:
//www.csc.ncsu.edu/faculty/jiang/appverify/.

[23] Juniper Networks. Juniper networks third annual mo-

bile threats report, 2013.

[24] J. Kinable and O. Kostakis. Malware classiﬁcation
based on call graph clustering. Journal in Computer
Virology, 2011.

[25] C. Kolbitsch, P. Comparetti, C. Kruegel, E. Kirda,
X. Zhou, and X. Wang. Eﬀective and eﬃcient mal-
ware detection at the end host. In Proc. of USENIX
Security Symposium, 2009.

[26] R. I. Kondor and J. D. Laﬀerty. Diﬀusion kernels on
graphs and other discrete input spaces. In Proc. of the
International Conference on Machine Learning, 2002.

[27] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and
G. Vigna. Polymorphic worm detection using struc-
tural information of executables. In Recent Adances in
Intrusion Detection (RAID), 2005.

[28] C. Liu, C. Chen, J. Han, and P. S. Yu. Gplag: detection
of software plagiarism by program dependence graph
analysis. In Proc. of the ACM SIGKDD international
conference on Knowledge discovery and data mining,
2006.

[29] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. Chex:
statically vetting android apps for component hijacking
vulnerabilities. In Proc. of ACM Conference on Com-
puter and Communications Security (CCS), 2012.

[30] J. Ming, M. Pan, and D. Gao. ibinhunt: Binary hunt-
ing with inter-procedural control ﬂow. In Information
Security and Cryptology (ICISC), 2012.

[31] H. Peng, C. S. Gates, B. P. Sarma, N. Li, Y. Qi,
R. Potharaju, C. Nita-Rotaru, and I. Molloy. Using
probabilistic generative models for ranking risks of an-
droid apps. In Proc. of ACM Conference on Computer
and Communications Security (CCS), pages 241–252,
2012.

[32] G. Portokalidis, P. Homburg, K. Anagnostakis, and
H. Bos. Paranoid android: Versatile protection for
smartphones.
In Proc. of Annual Computer Security
Applications Conference (ACSAC), 2010.

[33] L. Ralaivola, S. J. Swamidass, H. Saigo, and P. Baldi.
Graph kernels for chemical informatics. Neural Net-
works, 2005.

[34] V. Rastogi, Y. Chen, and W. Enck. Appsplayground:
Automatic security analysis of smartphone applica-
tions. In Proc. ACM Conference on Data and Appli-
cation Security and Privacy (CODASPY), 2013.

[35] B. P. Sarma, N. Li, C. Gates, R. Potharaju, C. Nita-
Rotaru, and I. Molloy. Android permissions: a per-
spective combining risks and beneﬁts. In Proc. of ACM
symposium on Access Control Models and Technologies
(SACMAT), pages 13–22, 2012.

[36] S. Shang, N. Zheng, J. Xu, M. Xu, and H. Zhang. De-
tecting malware variants via function-call graph simi-
larity. In Proc. of the International Conference on Ma-
licious and Unwanted Software (MALWARE), 2010.

53[37] N.

Shervashidze,

S. Vishwanathan, T. Petri,
K. Mehlhorn, and K. Borgwardt. Eﬃcient Graphlet
Kernels for Large Graph Comparison. In Proc. of the
International Conference on Artiﬁcial Intelligence and
Statistics (AISTATS), 2009.

[38] C. Wagner, G. Wagener, R. State, and T. Engel. Mal-
ware analysis with graph kernels and support vector
machines.
In International Conference on Malicious
and Unwanted Software (MALWARE), 2009.

[39] D.-J. Wu, C.-H. Mao, T.-E. Wei, H.-M. Lee, and K.-
P. Wu. Droidmat: Android malware detection through
manifest and API calls tracing. In Proc. of Asia Joint
Conference on Information Security (Asia JCIS), pages
62–69, 2012.

[40] F. Yamaguchi, M. Lottmann, and K. Rieck. General-
ized vulnerability extrapolation using abstract syntax
trees. In Proc. of 28th Annual Computer Security Ap-
plications Conference (ACSAC), pages 359–368, Dec.
2012.

[41] L.-K. Yan and H. Yin. Droidscope: Seamlessly recon-
structing os and dalvik semantic views for dynamic an-
droid malware analysis. In Proc. of USENIX Security
Symposium, 2012.

[42] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. Detecting
repackaged smartphone applications in third-party an-
droid marketplaces. In Proc. ACM Conference on Data
and Application Security and Privacy (CODASPY),
pages 317–326, 2012.

[43] Y. Zhou and X. Jiang. Dissecting android malware:
Characterization and evolution. In Proc. of IEEE Sym-
posium on Security and Privacy, pages 95–109, 2012.

[44] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey,
you, get oﬀ of my market: Detecting malicious apps
in oﬃcial and alternative android markets. In Proc. of
Network and Distributed System Security Symposium
(NDSS), 2012.

54