NDSS 2012 

Kruiser: Semi-synchronized Non-
blocking Concurrent Kernel Heap 

Buffer Overflow Monitoring 

Donghai Tian1,2, Qiang Zeng2, Dinghao Wu2,  

Peng Liu2 and Changzhen Hu1 

 

1 Beijing Institute of Technology 

2 The Pennsylvania State University 

1 

Kernel Heap Buffer Overflow 

 

Function 
Pointer

Kernel
Object

Kernel
Object

2 

Motivation 

• There are more and more kernel buffer 

overflow exploits. 
 

• To our knowledge, there are no practical 

mechanisms that have been widely 
deployed detecting kernel heap buffer 
overflows. 

3 

Current Methods: Limitations 1 & 2 

• Some approaches perform detection before 

each buffer write operation. 
[PLDI '04], [USENIX ATC '02], [NDSS '04] 
 
 

High overhead!  

• Some approaches do not check heap buffer 

overflows until a buffer is de-allocated. 
[LISA '03], [BLACKHAT '11] 

Large detection delay! 

4 

Our Idea 

Sync. 

Core 1 

Core 2 

Program 
Program 
Program 
execution 
execution 
execution 
Security 
Security 
checking 
checking 
Program 
Program 
execution 
execution 
Security 
Security 
checking 
checking 

Inlined Checking 

Concurrent checking 

5 

Basic Method 

• Canary-based Concurrent 

Monitoring 

Kernel Object 

Canary 

Hook 

Network 
drivers

.
.
.

.
.
.

File 

extenstions

Hook 

Heap 
metadata

Monitor

6 

Challenges 

• Self-protection. 

• Monitor and the metadata 

• Synchronization. 

• Races between hooks and monitor 

• Compatibility. 

• OS and hardware 

7 

Out-of-the-VM Architecture 
(Our previous CCS submission - rejected) 

 

Core 1 

Core 2 

8 

Hybrid VM monitoring Architecture 

(NDSS submission - accepted) 

 

Guest VM1

Kernel 

address space

Network 
drivers

Entry code
Exit code

.
.
.

.
.
.

Hooks

File 
systems

Entry code
Exit code

Secure 

address space 

Guest VM2

Heap 
metadata

Monitor

VMM

9 

Now, Kernel Cruising 

• How to gather canary location info?  

 

• How to deal with the races between hooks and 

monitor?    

 

10 

Kernel Cruising 

• Page Identity Array (PIA) 

• Heap buffer canary location information 
• Other information 

 

• Race conditions 

• Concurrent updates by two hooks 
• Inconsistent reads by monitor  
• Time of check to time of use (TOCTTOU) 

 

11 

Semi-synchronized Non-blocking 

Cruising Algorithm 
• Avoid Concurrent Entry Updates. 

• Put the PIA entry update operations into the 

critical section. 

 

12 

Resolve TOCTTOU 

flag = true; 

flag = false; 

Hook: 
if the page is moved to the heap page pool 
 
else if the page is removed from the heap 
 
Monitor: 
if (the canary is tempered) { 
     
             report overflow! 
     
} 

true->false->true 
A        B         A 

} 

if (flag == true) { // the page is still in heap 

13 

ABA Hazard Solution 

version++; 

version++; 

if the page is moved to the heap page pool 
 
else if the page is removed from the heap 
 
… 
if (the canary is tampered) { 
     
             report overflow! 
     
} 

if (version == original version) { 

} 

14 

Secure Canary Generation 

• R1) The canaries are not predictable. 

 

• R2) The canary generation and verification 

algorithms should be efficient. 
 

• Generate unpredictable canaries using 

RC4 from a per-virtual-page random value. 

15 

Outline 

• Idea 
• Architecture 
• Kernel Cruising 
• Evaluation 
• Related Work 
• Summary 

16 

Effectiveness 

• We exploited five heap buffer overflow 
vulnerabilities in Linux, including three 
synthetic bugs and two real world 
vulnerabilities .  
 

• All the overflows are successfully detected 

by Kruiser. 

17 

Performance Overhead 

1.04
1.02
1
0.98
0.96
0.94
0.92
0.9

e
m

i
t
 
n
o
i
t
u
c
e
x
E

perlbench

SIM-Kruiser

Kruiser

sjeng
libquantum

h264ref

omnetpp

xalancbmk
astar

geo. mean

bzip2 gcc mcf

gobmk

hm mer

SPEC CPU2006 performance (normalized to the execution time of original Linux). 
18 

Scalability 

Original
SIM-Kruiser
Kruiser

d
n
o
c
e
s
 
r
e
p

 
s
t
s
e
u
q
e
R

1000
900
800
700
600
500
400
300
200

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

Concurrency

Throughput of the Apache web server for varying numbers of concurrent requests. 

19 

Detection Latency 

Different cruising cycle for different applications in the SPEC CPU2006 benchmark 

10 of 12 applications have less than  
29ms  (for scanning the kernel heap). 

20 

Outline 

• Idea 
• Architecture 
• Kernel Cruising 
• Evaluation 
• Related work 
• Summary 

21 

Related Work 

• Countermeasures Against Buffer Overflows 

• StackGuard [USENIX Security '98] 
• Heap Integrity Detection [LISA '03] 
• Cruiser [PLDI '11] 
• DieHard [PLDI '06] and DieHarder [CCS '10] 

• VM-based Methods 

• SIM [CCS '09] 
• OSck [ASPLOS '11] 

22 

Summary 

• Kruiser can achieve concurrent monitoring  

against kernel heap buffer overflows. 
• Non-blocking 
• Semi-synchronized 
• NO false positive 

 

• The hybrid VM monitoring scheme 

provides high efficiency without sacrificing 
the security guarantees. 

23 

Thank you! 

Questions? 

 

24 

Outline 

• Background and Idea 
• Architecture 
• Kernel Cruising 
• Evaluation 
• Related Work 
• Summary 

25 

Non-blocking Cruising Algorithm 

  

Monitor(){
uint ver1, ver2;
for (int page = 0; page < ENTRY NUMBER; page++){

ver1 = PIA[page].version;
if (The page is non-heap page)

continue; // Bypass non−heap page
Read the metadata stored in PIA[page];
ver2 = PIA[page].version;
if (ver1 != ver2)

continue; // Metadata was updated 

Avoid Read 

Inconsistency! 

Is the page still 
used by the heap? 

for (each canary within the page){
if (the canary is tampered){

DoubleCheckOnTamper(page, ver1);

}

}

}

27 

