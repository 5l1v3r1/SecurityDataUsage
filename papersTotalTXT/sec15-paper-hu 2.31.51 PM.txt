Automatic Generation of Data-Oriented Exploits
Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai Liang, 

National University of Singapore

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/hu

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXAutomatic Generation of Data-Oriented Exploits

Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, Zhenkai Liang

Department of Computer Science, National University of Singapore
{huhong, chuazl, sendroiu, prateeks, liangzk}@comp.nus.edu.sg

Abstract

As defense solutions against control-ﬂow hijacking at-
tacks gain wide deployment, control-oriented exploits
from memory errors become difﬁcult. As an alterna-
tive, attacks targeting non-control data do not require
diverting the application’s control ﬂow during an at-
tack. Although it is known that such data-oriented at-
tacks can mount signiﬁcant damage, no systematic meth-
ods to automatically construct them from memory er-
rors have been developed.
In this work, we develop a
new technique called data-ﬂow stitching, which system-
atically ﬁnds ways to join data ﬂows in the program to
generate data-oriented exploits. We build a prototype
embodying our technique in a tool called FLOWSTITCH
that works directly on Windows and Linux binaries. In
our experiments, we ﬁnd that FLOWSTITCH automati-
cally constructs 16 previously unknown and three known
data-oriented attacks from eight real-world vulnerable
programs. All the automatically-crafted exploits respect
ﬁne-grained CFI and DEP constraints, and 10 out of the
19 exploits work with standard ASLR defenses enabled.
The constructed exploits can cause signiﬁcant damage,
such as disclosure of sensitive information (e.g., pass-
words and encryption keys) and escalation of privilege.

1

Introduction

In a memory error exploit, attackers often seek to ex-
ecute arbitrary malicious code, which gives them the
ultimate freedom in perpetrating damage with the vic-
tim program’s privileges. Such attacks typically hijack
the program’s control ﬂow by exploiting memory errors.
However, such control-oriented attacks, including code-
injection and code-reuse attacks, can be thwarted by efﬁ-
cient defense mechanisms such as control-ﬂow integrity
(CFI) [10, 43, 44], data execution prevention (DEP) [12],
and address space layout randomization (ASLR) [15,33].
Recently, these defenses have become practical and are

gaining universal adoption in commodity operating sys-
tems and compilers [8, 36], making control-oriented at-
tacks increasingly difﬁcult.

However, control-oriented attacks are not the only ma-
licious consequence of memory error exploits. Memory
errors also enable attacks through corrupting non-control
data — a well-known result from Chen et al. [19]. We
refer to the general class of non-control data attacks as
data-oriented attacks, which allow attackers to tamper
with the program’s data or cause the program to disclose
secret data inadvertently. Several recent high-proﬁle vul-
nerabilities have highlighted the menace of these attacks.
In a recent exploit on Internet Explorer (IE) 10, it has
been shown that changing a single byte — speciﬁcally
the Safemode ﬂag — is sufﬁcient to run arbitrary code in
the IE process [6]. The Heartbleed vulnerability is an-
other example wherein sensitive data in an SSL-enabled
server could be leaked without hijacking the control-ﬂow
of the application [7].

If data-oriented attacks can be constructed such that
the exploited program follows a legitimate control ﬂow
path, they offer a realistic attack mechanism to cause
damage even in the presence of state-of-the-art control-
ﬂow defenses, such as DEP, CFI and ASLR. However,
although data-oriented attacks are conceptually under-
stood, most of the known attacks are straightforward cor-
ruption of non-control data. No systematic methods to
identify and construct these exploits from memory er-
rors have been developed yet to demonstrate the power of
data-oriented attacks. In this work, we study systematic
techniques for automatically constructing data-oriented
exploits from given memory corruption ﬂaws.

Based on a new concept called data-ﬂow stitching, we
develop a novel solution that enables us to systematize
the understanding and construction of data-oriented at-
tacks. The intuition behind this approach is that non-
control data is often far more abundant than control data
in a program’s memory space; as a result, there exists
an opportunity to reuse existing data-ﬂow patterns in the

USENIX Association  

24th USENIX Security Symposium  177

program to do the attacker’s bidding. The main idea of
data-ﬂow stitching is to “stitch” existing data-ﬂow paths
in the program to form new (unintended) data-ﬂow paths
via exploiting memory errors. Data-ﬂow stitching can
thus connect two or more data-ﬂow paths that are disjoint
in the benign execution of the program. Such a stitched
execution, for instance, allows the attacker to write out a
secret value (e.g., cryptographic keys) to the program’s
public output, which otherwise would only be used in
private operations of the application.
Problem. Our goal is to check whether a program is ex-
ploitable via data-oriented attacks, and if so, to automat-
ically generate working data-oriented exploits. We aim
to develop an exploit generation toolkit that can be used
in conjunction with a dynamic bug-ﬁnding tool. Specif-
ically, from an input that triggers a memory corruption
bug in the program, with the knowledge of the program,
our toolkit constructs a data-oriented exploit.

Compared to control-oriented attacks, data-oriented
attacks are more difﬁcult to carry out, since attackers
cannot run malicious code of their choice even after the
attack. Though non-control data is abundant in a typi-
cal program’s memory space, due to the large range of
possibilities for memory corruption and their subtle in-
ﬂuence on program memory states, identifying how to
corrupt memory values for a successful exploit is difﬁ-
cult. The main challenge lies in searching through the
large space of memory state conﬁgurations, such that the
attack exhibits an unintended data consequence, such as
information disclosure or privilege escalation. An addi-
tional practical challenge is that defenses such as ASLR
randomize addresses, making it even harder since abso-
lute address values cannot be used in exploit payloads.
Our Approach. In this work, we develop a novel so-
lution to construct data-oriented exploits through data-
ﬂow stitching. Our approach consists of a variety of
techniques that stitch data ﬂows in a much more efﬁ-
cient manner compared to manual analysis or brute-force
searching. We develop ways to prioritize the search-
ing for data-ﬂow stitches that require a single new edge
or a small number of new edges in the new data-ﬂow
path. We also develop techniques to address the chal-
lenges caused by limited knowledge of memory lay-
out. To further prune the search space, we model the
path constraints along the new data-ﬂow path using sym-
bolic execution, and check its feasibility using SMT
solvers. This can efﬁciently prune out memory corrup-
tions that cause the attacker to lose control over the ap-
plication’s execution, like triggering exceptions, failing
on compiler-inserted runtime checks, or causing the pro-
gram to abort abruptly. By addressing these challenges, a
data-oriented attack that causes unintended behavior can
be constructed, without violating control-ﬂow require-
ments in the victim program.

We build a tool called FLOWSTITCH embodying these
techniques, which operates directly on x86 binaries.
FLOWSTITCH takes as input a vulnerable program with
a memory error, an input that exploits the memory er-
ror, as well as benign inputs to that program. It employs
dynamic binary analysis to construct an information-
ﬂow graph, and efﬁciently searches for data ﬂows to be
stitched. FLOWSTITCH outputs a working data-oriented
exploit that either leaks or tampers with sensitive data.
Results. We show that automatic data-oriented exploit
generation is feasible.
In our evaluation, we ﬁnd that
multiple data-ﬂow exploits can often be constructed from
a single vulnerability. We test FLOWSTITCH on eight
real-world vulnerable applications, and FLOWSTITCH
automatically constructs 19 data-oriented exploits from
eight applications, 16 of which are previously unknown
to be feasible from known memory errors. All con-
structed exploits violate memory safety, but completely
respect ﬁne-grained CFI constraints. That is, they create
no new edges in the static control-ﬂow graph. All the
attacks work with the DEP protection turned on, and 10
exploits (out 19) work even when ASLR is enabled. The
majority of known data-oriented attacks (c.f. Chen et.
al. [19], Heartbleed [7], IE-Safemode [6]) are straight-
forward non-control data corruption attacks, requiring at
most one data-ﬂow edge. In contrast, seven exploits we
have constructed are only feasible with the addition of
multiple data-ﬂow edges in the data-ﬂow graph, showing
the efﬁcacy of our automatic construction techniques.
Contributions. This paper makes the following contri-
butions:

• We conceptualize data-ﬂow stitching and develop a
new approach that systematizes the construction of
data-oriented attacks, by composing the benign data
ﬂows in an application via a memory error.

• We build a prototype of our approach in an au-
tomatic data-oriented attack generation tool called
FLOWSTITCH. FLOWSTITCH operates directly on
Windows and Linux x86 binaries.

• We show that constructing data-oriented attacks
from common memory errors is feasible, and offers
a promising way to bypass many defense mecha-
nisms to control-ﬂow attacks. Speciﬁcally, we show
that 16 previously unknown and three known data-
oriented attacks are feasible from eight vulnerabili-
ties. All our 19 constructed attacks bypass DEP and
the CFI checks, and 10 of them bypass ASLR.

2 Problem Deﬁnition

2.1 Motivating Example
The following example shown in Code 1 is modeled after
a web server. It loads the web site’s private key from a

2

178  24th USENIX Security Symposium 

USENIX Association

char *userInput, *reqFile;
char *privKey, *result, output[BUFSIZE];
char fullPath[BUFSIZE] ="/path/to/root/";

privKey = loadPrivKey("/path/to/privKey");
/* HTTPS connection using privKey */
GetConnection(privKey, ...);
userInput = read_socket();
if (checkInput(userInput)) {

1 int server() {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19 }
Code 1: Vulnerable code snippet. String concatenation on line 14
introduces a stack buffer overﬂow vulnerability.

/* user input OK, parse request */
reqFile = getFileName(userInput);
/* stack buffer overflow */
strcat(fullPath, reqFile);
result = retrieve(fullPath);
sprintf(output,"%s:%s",reqFile,result);
sendOut(output);

}

ﬁle, and uses it to establish an HTTPS connection with
the client. After receiving the input — a ﬁle name, the
code sanitizes the input by invoking checkInput()
(on line 10). The code then retrieves the ﬁle content and
sends the content and the ﬁle name back to the client.
There is a stack buffer overﬂow vulnerability on line 14,
through which the client can corrupt the stack memory
immediately after the fullPath buffer.

However, there is no obvious security-sensitive non-
control data [19] on the stack of the vulnerable function.
To create a data-oriented attack, we analyze the data ﬂow
patterns in the program’s execution under a benign input,
which contains at least two data ﬂows: the ﬂow involv-
ing the sensitive private key pointed to by the pointer
named privKey, and the ﬂow involving the input ﬁle
name pointed by the pointer named reqFile, which is
written out to the program’s public outputs. Note that in
the benign run, these two data ﬂows do not intersect —
that is, they have no shared variables or direct data de-
pendence between them, but we can corrupt memory in
such a way that the secret private key gets written out to
the public output. Speciﬁcally, the attacker crafts an at-
tack exploiting the buffer overﬂow to corrupt the pointer
reqFile, making it to point to the private key. This
forces the program to copy the private key to the output
buffer in the sprintf function on line 16, and then the
program sends the output buffer to the client on line 17.
Note that the attack alters no control data, and executes
the same execution path as the benign run.

This example illustrates the idea of data-ﬂow stitch-
ing, an exploit mechanism to manipulate the benign data
ﬂows in a program execution without changing its con-
trol ﬂow. Though it is not difﬁcult to manually analyze
this simpliﬁed example to construct a data-oriented at-

tack, real-world programs are much more complex and
often available in binary-only form. Constructing data-
oriented attacks for such programs is a challenging task
we tackle in this work.

2.2 Objectives & Threat Model
In this paper, we aim to develop techniques to automat-
ically construct data-oriented attacks by stitching data
ﬂows. The generated data-oriented attacks result in the
following consequences:
G1: Information disclosure. The attacks leak sensitive
data to attackers. Speciﬁcally, we target the following
sources of security-sensitive data:

• Passwords and private keys. Leaking passwords
and private keys help bypass authentication controls
and break secure channels established by encryption
techniques.

• Randomized values. Several memory protection
defenses utilize randomized values generated by the
program at runtime, such as stack canaries, CFI-
enforcing tags, and randomized addresses. Disclo-
sure of such information allows attackers bypass
randomization-based defenses.

G2: Privilege escalation. The attacks grant attackers the
access to privileged application resources. Speciﬁcally,
we focus on the following kinds of program data:

• System call parameters. System calls are used for
high-privilege operations, like setuid(). Cor-
rupting system call parameters can lead to privilege
escalation.

• Conﬁguration settings.

Program conﬁguration
data, especially for server programs (e.g., data
loaded from httpd.conf for Apache servers)
speciﬁes critical information, such as the user’s per-
mission and the root directory of the web server.
Corrupting such data directly escalates privilege.

Threat Model. We assume the execution environment
has deployed defense mechanisms against control-ﬂow
hijacking attacks, such as ﬁne-grained CFI [10,32], non-
executable data [12] and state-of-the-art implementation
of ASLR. Therefore attackers cannot mount control ﬂow
hijacking attacks. All non-deterministic system gener-
ated values, e.g., stack-canaries or CFI tags, are assumed
to be secret and unknown to attackers.

2.3 Problem Deﬁnition
To systematically construct data-oriented exploits, we
introduce a new abstraction called the two-dimensional
data-ﬂow graph (2D-DFG), which represents the ﬂows
of data in a given program execution in two dimensions:
memory addresses and execution time. Speciﬁcally, a

USENIX Association  

24th USENIX Security Symposium  179

3

address 

&privKey 

privKey1 

privKey1 

output 
&userInput 
&reqFile 
userInput1 
reqFile1 

userInput1 

reqFile1 

0 

6 

9 

12 

16 

time 

Figure 1: 2D-DFG of a concrete execution of Code 1. Black edges
are data edges, while grey edges are address edges. For clarity, ver-
tices do not strictly conform the order on address-axis (this applies to
all ﬁgures). We use line number to represent the time. var1 means a
particular value (constant) of the variable var in Code 1.

2D-DFG is a directed graph, represented as G = {V,E},
where V is the set of vertices, and E is the set of edges. A
vertex in V is a variable instance, i.e., a point in the two
dimensional address-time space, denoted as (a,t), where
a is the address of the variable, and t is a representation
of the execution time when the variable instance is cre-
ated. The address includes both memory addresses and
register names1, and the execution time is represented as
an instruction counter in the execution trace of the pro-
gram. An edge (v(cid:29), v) from vertex v(cid:29) to vertex v denotes
a data dependency created during the execution, i.e., the
value of v or the address of v is derived from the value of
v(cid:29). Therefore, the 2D-DFG also embodies the “points to”
relation between pointer variables and pointed variables.
Each vertex v has a value property, denoted as v.value.
A new vertex v = (a,t) is created if an instruction
writes to address a at the execution time t. A new data
edge (v(cid:29), v) is created if an instruction takes v(cid:29) as the
source operand and takes v as a destination operand. A
new address edge (v(cid:29), v) is created if an instruction takes
v(cid:29) as the address of one operand v. Therefore, an instruc-
tion may create several vertices at a given point in execu-
tion if it changes more than one variables, for instance in
the loop-preﬁxed instructions (e.g., repmov). Note that
the 2D-DFG is a representation of the direct data depen-
dencies created in a program execution under a concrete
input, not the static data-ﬂow graph often used in static
analysis. Figure 1 shows a 2D-DFG of Code 1.

We deﬁne the core problem of data-ﬂow stitching as
follows. For a program with a memory error, we take
the following parameters as the input: a 2D-DFG G from
a benign execution of the program, a memory error in-
ﬂuence I, and two vertices vS (source) and vT (target).
In our example, vS is the private key buffer, shown as
(privKey12, 6) in Figure 1 and vT is the public output

1We treat the register name as a special memory address.
2privKey1 here means the key buffer address, a concrete value.

buffer, shown as (output, 16) in Figure 1. Our goal is
to generate an exploit input that exhibits a new 2D-DFG
G(cid:29) = {V(cid:29),E(cid:29)}, where V(cid:29) and E(cid:29) result from the memory
error exploit, and that G(cid:29) contains data-ﬂow paths from
vS to vT . Let E = E(cid:29)−E be the edge-set difference and
V = V(cid:29) − V be the vertex-set difference. Then, E is the
set of new edges we need to generate to get E(cid:29) from E.
The memory error inﬂuence I is the set of memory
locations which can be written to by the memory error,
represented as a set of vertices. Therefore, we must se-
lect V to be a subset of vertices in I. To achieve G1
we consider variables carrying program secrets as source
vertices and variables written to public outputs as target
vertices. In the development of attacks for G2, source
vertices are attacker-controlled variables and target ver-
tices are security-critical variables such as system call
parameters. A successful data-oriented attack should ad-
ditionally satisfy the following critical requirements:

• R1. The exploit input satisﬁes the program path
constraints to reach the memory error, create new
edges and continue the execution to reach the in-
struction creating vT .

• R2. The instructions executed in the exploit must
conform to the program’s static control ﬂow graph.

2.4 Key Technique & Challenges
The key idea in data-ﬂow stitching is to efﬁciently search
for the new data-ﬂow edge set E to add in G(cid:29) such that
it creates new data-ﬂow paths from vS to vT . For each
edge (x,y) ∈ E, x is data-dependent on vS and vT is data-
dependent on y. We denote the sub-graph of G contain-
ing all the vertices that are data-dependent on vS as the
source ﬂow. We also denote the sub-graph of G contain-
ing all the vertices that vT is data-dependent on as the
target ﬂow. For each vertex pair (x, y), where x is in the
source ﬂow and y is in the target ﬂow, we check whether
(x, y) is a feasible edge of E resulting from the inclusion
of vertices from I. The vertices x and y may either be
contained in I directly, or be connected via a sequence of
edges by corruption of their pointers which are in I. If we
change the address to which x is written, or change the
address from which y is read, the value of x will ﬂow to y.
If so, we call (x, y) the stitch edge, x the stitch source, and
y the stitch target. For example, in Figure 2, we change
the pointer (which is in I) of the ﬁle name from reqFile1
to privKey1. Then the ﬂow of the private key and the
ﬂow of the ﬁle name are stitched, as we discuss in Sec-
tion 2.1. In ﬁnding data-ﬂow stitching in the 2D-DFG,
we face the following challenges:

• C1. Large search space for stitching. A 2D-DFG
from a real-world program has many data ﬂows and
a large number of vertices. For example, there are

180  24th USENIX Security Symposium 

USENIX Association

4

address 

&privKey 

privKey1 

privKey1 

output 
&userInput 
&reqFile 
userInput1 
reqFile1 

userInput1 

reqFile1 

privKey1 

Attack 

0 

6 

9 

12 

14 

16 

time 

Figure 2: A data-oriented attack of Code 1. This attack connects
ﬂow of the private key and ﬂow of the ﬁle name, with the new edges
(dashed lines).

776 source vertices and 56 target vertices in one of
SSHD attacks. Therefore, the search space to ﬁnd a
feasible path is large, for we often need heavy anal-
ysis to connect each pair of vertices.

• C2. Limited knowledge of memory layout. Most
of the modern operating systems have enabled
ASLR by default. The base addresses of data mem-
ory regions, like the stack and the heap, are random-
ized and thus are difﬁcult to predict.

The 2D-DFG captures only the data dependencies
in the execution, abstracting away control dependence
and any conditional constraints the the program imposes
along the execution path. To satisfy the requirements R1
and R2 completely, the following challenge must be ad-
dressed:

• C3. Complex program path constraints. A suc-
cessful data-oriented attack causes the victim pro-
gram execute to the memory error, create a stitch
edge, and continue without crashing. This requires
the input to satisfy all path constraints, respect the
program’s control ﬂow integrity constraints, and
avoid invalid memory accesses.

3 Data-ﬂow Stitching

Data-oriented exploits can manipulate data-ﬂow paths in
a number of different ways to stitch the source and target
vertices. The solution space can be categorized based on
the number of new edges added by the exploit. The sim-
plest case of data-oriented exploits is when the exploit
adds a single new edge. More complex exploits that use
a sequence of corrupted values can be crafted when a
single-edge stitch is infeasible. We discuss these cases to
solve challenge C1 in Section 3.1 and 3.2. To overcome
the challenge C2, we develop two methods to make data-
oriented attacks work even when ASLR is deployed, dis-
cussed in Section 3.3. For each stitch candidate, we con-
sider the path constraints and CFI requirement (C3) to
generate input that trigger the stitch edge in Section 4.4.

1 struct passwd { uid_t pw_uid; ... } *pw;
2 ...
3 int uid = getuid();
4 pw->pw_uid = uid;
5 ...
6 void passive(void) { ...
7
8
9
10
Code 2: Code snippet of wu-ftpd, setting uid back to process user
id.

seteuid(0);
...
seteuid(pw->pw_uid);
... }

//format string error

//set root uid

//set normal uid

address 

I 

100 

100 

0 

3 

4 

pw1 

&uid 
&arg 

100 

address 

 Attack  

100 

0 

100 

0 

100 
9 

(a) 

time 

0 

3 

4 

5 
(b) 

0 
9 

time 

Figure 3: Target ﬂow in the single-edge stitch of wu-ftpd. &arg
is the stack address of setuid’s argument. (a) is the original target
ﬂow, where the pw->pwd uid has vale 100 and address pw1. Grey
area stands for the memory inﬂuence I. With the stitching attack, the
value at address pw1 is changed to 0 in (b).

3.1 Basic Stitching Technique
A basic data-oriented exploit adds one edge in the new
edge set E to connect vS with vT . We call this case
a single-edge stitch. For instance, attackers can cre-
ate a single new vertex at the memory corruption point
by overwriting a security-critical data value, causing es-
calation of privileges. Most of the previously known
data-oriented attacks are cases of single-edge stitches,
including attacks studied by Chen et al. [19] and the
IE Safemode attack [6]. We use the example of a vul-
nerable web server wu-ftpd, shown in Code 2, which
was used by Chen et al. to explain non-control data at-
tacks [19]. In this exploit, the attackers utilizes a format
string vulnerability (skipped on line 5) to overwrite the
security-critical pw->pw uid with root user’s id. The
subsequent setuid call on line 9, which is intended to
drop the process privileges, instead makes the program
retain its root user privileges. Figure 3 (a) and Figure 3
(b) show the 2D-DFG for the execution of the vulnerable
code fragment under a benign and the exploit payload re-
spectively. Numbers on time-axis are the line numbers in
Code 2. The exploit aims to introduce a single edge to
write a zero value from the network input to the memory
allocated to the pw->pw id. Note that the exploit is a
valid path in the static control-ﬂow graph.
Search for Single-Edge Stitch. Instead of brute-forcing
all vertices in the target ﬂow for a stitch edge, we propose
a method that utilizes the inﬂuence set I of the mem-

USENIX Association  

24th USENIX Security Symposium  181

5

StitchAlgo-1: Single-edge Stitch
Input: G: benign 2D-DFG,

I: memory inﬂuence,
vT : target vertex,
cp: memory error vertex,
X: value to be in VT .value (requirement for stitch edge)

Output: E: stitch edge candidate set

1 E = /0
2 T DFlow = dataSubgraph(G, vT )
3 foreach v ∈ V(TDFlow) do

if isRegister(v) then

4
5

continue

/* only data edges */

/* Skip registers */

0 

2 

6

7

if ∃ (v, v(cid:29)) ∈ E(TDFlow): ∃ t : v.time < t < v(cid:29).time ∧
(v.address, t) ∈ I then
E = E ∪ {(cp, v)}

/* Stitch edge candidate */

ory error to prune the search space. The inﬂuence set I
contains vertices that can be corrupted by the memory
error, like the grey area shown in Figure 3. For ver-
tices in the target ﬂow, attackers can only affect those
in the intersection of the target ﬂow and the inﬂuence
I. Other vertices do not yield a single-edge stitch and
can be ﬁltered out. Speciﬁcally, we utilize three obser-
vations here. First, register vertices can be ignored since
memory error exploit cannot corrupt them. Second, the
vertex must be deﬁned (written) before the memory error
and used (read) after the memory error. In Figure 3 (a),
the code reads vertex (&uid, 3) before the memory error
and writes vertices (&arg, 9) and the following one af-
ter the memory error. Therefore these three vertices are
useless for single-edge stitches. Third, in the memory
address dimension, the vertex address should belong to
the memory region of the inﬂuence I. In our example,
only vertex (pw1, 4) falls into the intersection of the tar-
get ﬂow and the inﬂuence area and we select this vertex
for stitch. StitchAlgo-1 shows the algorithm to identify
single-edge stitch. From the given 2D-DFG, StitchAlgo-
1 gets the target ﬂow T DFlow for the target vertex vT ,
which only considers data edges. For each vertex v that
satisﬁes the requirements, we add the edge from memory
error vertex to v into E as one possible solution.

We consider the search space reduction due to our al-
gorithm over a brute-force search for stitch edges. The
na¨ıve brute-force search would consider the Cartesian
product of all vertices in the source ﬂow and the tar-
get ﬂow. In our algorithm, this search is reduced to the
Cartesian product of only the live variables in the source
ﬂow at the time of corruption, and the vertices in the tar-
get ﬂow as well as in I. In our experiments, we show that
this reduction can be signiﬁcant.
3.2 Advanced Stitching Technique
Single-edge stitch is a basic stitching method, creating
one new edge. Advanced data-ﬂow stitching techniques
create paths with multiple edges in the new edge set E.
A multi-edge stitch can be synthesized through several

b2 

b1 

&pw 

pw1 
&arg 

address 

source flow 

address 

0 

source flow 

0 

0 

0 

Attack 

pw1 

target flow 

pw1 

b2 

100 

4 
(a) 

100 
9 

time 

0 

100 

2 

4 

5 

(b) 

target 
flow 

0 
9 

time 

Figure 4: Two-edge stitch of wu-ftpd. The target ﬂow is
pw->pw uid’s ﬂow, and the source ﬂow is the ﬂow of a constant 0.
With the attack, the variable pw at &pw is changed to b2. A later opera-
tion reads 0 from b2 and writes it to stack for setuid. Two edges are
changed: one for pointer dereference and another for data movement.

ways. Attackers can use several single-edge stitches to
create a multi-edge stitch. Another way is to perform
pointer stitch, which corrupts a variable that is later used
as a pointer to vertices in the source or target ﬂow. Since
the pointer determines the address of the stitch source
or the stitch target, corrupting the pointer introduces two
different edges: one edge for the new “points to” rela-
tionship and one edge for the changed data ﬂow. We re-
visit the example of wu-ftpd shown earlier in Code 2,
illustrating a multi-edge stitch exploit in it. Instead of
directly modifying the ﬁeld pw uid, we change its base
pointer pw to an address of a structure with a constant
0 at the offset corresponding to the pw uid. The vul-
nerable code then reads 0 and uses it as the argument
of setuid, creating a privilege escalation attack. Fig-
ure 4 shows the 2D-DFGs for the benign and attack exe-
cutions. Changing the value of pw creates two new edges
(dashed lines): the grey edge that connects the corrupted
pointer to a new variable it points to, and the black edge
that writes the new variable into setuid argument. As
a result, we create a two-edge stitch.
Identifying Pointer Stitches. Our algorithm for ﬁnding
multi-edge exploits using pointer stitching is shown in
the StitchAlgo-2. The basic idea is to check each mem-
ory vertex in the source ﬂow and the target ﬂow. If it is
pointed to by another vertex in the 2D-DFG, we select
the pointer vertex to corrupt. The search for stitchable
pointers on the target ﬂow is different from that on the
source ﬂow. Speciﬁcally, for a vertex v in the target ﬂow,
we need to ﬁnd an data edge (v(cid:29),v) and a pointer vertex
vp of v(cid:29), and then change vp to point to a vertex vs in the
source ﬂow, so that a new edge (vs,v) will be created to
stitch the data ﬂows. For a vertex v in the source ﬂow, we
need to ﬁnd an data edge (v,v(cid:29)) and a pointer vertex vp of
v(cid:29), and change vp to point to a vertex vt in the target ﬂow,
so that a new edge (v,vt) will be created to stitch the data
ﬂows. At the same time, we need to consider the liveness
of the stitching vertices. For example, the source vertex

182  24th USENIX Security Symposium 

USENIX Association

6

StitchAlgo-2: Pointer Stitch
Input: G: benign 2D-DFG,

vS: source vertex,
cp: memory error vertex

Output: E: stitch edge candidate set

1 E = /0
2 SrcFlow = subgraph(G, vS)
3 T gtFlow = subgraph(G, vT )
4 SDFlow = dataSubgraph(G, vS)
5 T DFlow = dataSubgraph(G, vT )
6 foreach v ∈ V(TDFlow) do

I: memory inﬂuence,
vT : target vertex,

/* both data and address edges. */

/* only data edges */

if isRegister(v) then continue
if (cid:31) (vi ∈ E(I)∧ (v, v(cid:29)) ∈ TDFlow) : vi.time < v(cid:29).time then
continue
foreach (vp, v) ∈ E(TgtFlow) – E(TDFlow) do

/* Only consider address edges.
if vp is used to write v then continue
/* Expect data ﬂow from v
foreach vs ∈ V(SDFlow) do

if ¬isRegister(vs) ∧ vs.isAliveAt(vp.time) then

StitchAlgo-1(G, I, vp, cp, vs.address)

14 foreach v ∈ V(SDFlow) do

if isRegister(v) then continue
if ∀ vi ∈ I: v.time < vi.time then continue
foreach (vp, v) ∈ E(SrcFlow) – E(SDFlow) do
if vp is used to read v then continue
/* Expect data ﬂow into v
foreach vt ∈ V(TDFlow) do
if ¬ isRegister(vt) ∧∃(vt, v(cid:29)) ∈ TDFlow : vt.time
< vp.time < v(cid:29).time then

StitchAlgo-1(G, I, vp, cp, vt.address)

7
8

9

10

11
12
13

15
16
17
18

19
20

21

*/

*/

*/

v1 

v2 

address 

VS 

source 
flow 

target  
flow 

t0 

v3 

v4 

v5 

VT 

t1 

t2 

time 

Figure 5: Stitch edge selection. The execution starts at time t0, and
reaches memory error instructions at time t1. Target data is used at time
t2, just before target vertex VT . There are two stitch source candidates
(black points in the source ﬂow) and three stitch destination candidate
(black points in the target ﬂow). One of the stitch edge candidate is
shown using the dotted line.

the search space to the Cartesian product of the R-set and
W -set instead.
R-set = V (SrcFlow)∩ I, W -set = V (T gtFlow)∩ I

|SSnaive| = |V (SrcFlow)|×|V (T gtFlow)|
|SSpointer−stitch| = | R-set |×| W -set |

Pointer stitch constitutes a natural hierarchy of ex-
ploits, which can consist of multiple levels of derefer-
ences of attacker-controlled pointers. For instance, in a
two-level pointer stitch we can construct an exploit that
corrupts a pointer vp2 that points to the pointer vp. This
can be achieved by treating vp as the target vertex, an-
other pointer vp(cid:29) holding the intended value (vt’s or vs’s
address) as the source vertex and applying StitchAlgo-2
to change vp. In this case, StitchAlgo-2 is recursively
used twice. Similarly, N-level stitch corrupts a pointer
vpN of the the pointer vp(N−1) to make an attack (and so
on), by applying StitchAlgo-2 N times recursively. Note
that for a N-level stitch to work, we need to make sure
the source vertex vp(cid:29)N “aligns” with the target vertex vpN
at each level, such that the program dereferences vpN N-
1 times to get the vertex vp, and dereferences vp(cid:29)N N-1
time to get the intended value in the exploit.

Pointer stitch is one speciﬁc way to implement multi-
edge stitches. In principle, it can be composed to create
more powerful exploits, combining several other single-
edge stitches in a “multi-step” stitch attack. In a multi-
step stitch, several intermediate data ﬂows are used to
achieve data-ﬂow stitching. Each step can be realized
by pointer stitch or single-edge stitch. Multi-step stitch
is useful when direct stitches of the source ﬂow and the
target ﬂow are not feasible.

3.3 Challenges from ASLR
Address space layout randomization (ASLR) deployed
by modern systems poses a strong challenge in mounting

7

should carry valid source data when it is used to write
data out to the target vertex. Once we select the pointer
vertex vp and its value (vt’s or vs’s address), the last step
is to set the value into vp through the memory error ex-
ploit. StitchAlgo-2 invokes the basic stitching technique
in StitchAlgo-1 to complete the last step.

Our technique uses vertex liveness and the memory er-
ror inﬂuence I to signiﬁcantly reduce the search space. A
na¨ıve solution to ﬁnding pointer stitches would consider
all pairs (vs, vt) where vs is in the source ﬂow and vt is
in the target ﬂow. The search space will be the Carte-
sian product of the vertex set in the source ﬂow (denoted
as V (SrcFlow)) and the vertex set in the target ﬂow (de-
noted as V (T gtFlow)). In contrast, in StitchAlgo-2, if
the memory corruption occurs at time t1, the vertex used
in the stitch edge from the source ﬂow must be live at
t1. Similarly, the vertex used in the stitch edge from
the target ﬂow should be created after t1. We illustrate
it in Figure 5, where only the black vertices are candi-
dates. Furthermore, we restrict our search to the set of
vertices whose pointer vertices vp are inside the mem-
ory inﬂuence as well. We call the selected vertices from
the source ﬂow R-set. Similarly, we call the vertices se-
lected from the target ﬂow W-set. Our algorithm reduces

USENIX Association  

24th USENIX Security Symposium  183

FA1: fixed address 1  FA2: fixed address 2  G: content of .got.plt section 
V: version string  

R: response to client 

source flow 
G 

address 

source flow 
G 

Table 1: Deterministic memory region size of binaries on Ubuntu
12.04 x86 system. Position-independent executables have size 0. Two
largest numbers are highlighted for each directory.

size (KB)
0
1 - 8
8 - 16
16 - 32
32 - 64
64 - 128
128 - 256
256 - 512
> 512
Total

/bin
21
10
12
23
19
15
7
3
2
112

/sbin
22
33
17
17
22
8
2
2
2
125

/usr/bin
73
150
113
147
103
66
35
32
32
751

/usr/sbin
18
20
11
14
25
8
4
3
2
105

Total
134
213
153
201
169
97
48
40
38
1093

FA2 

b1 

FA1 

a1 
a2 

address 

G 

a1 

target flow 

V 

(a) 

t0 

R 
time 

t0 

G 

Attack 

a1 

FA2 

V 

ta 

tb 

(b) 

target  
flow 

R 
tc 

time 

successful data-oriented attacks since vertex addresses
are highly unpredictable. We develop two methods in
data-oriented attacks to address this challenge: stitch-
ing with deterministic addresses and stitching by address
reuse. Note that attackers can use others methods devel-
oped for control ﬂow attacks to bypass ASLR here, like
disclosure of random addresses [14, 35].

3.3.1 Stitching With Deterministic Addresses

When security-critical data is stored in deterministic
memory addresses, stitching data ﬂows of such data is
not affected by ASLR. Existing work [2, 34, 37] have
shown that current ASLR implementations leave a large
portion of program data in the deterministic memory
region. For example, Linux binaries are often com-
piled without the “-pie” option, resulting in deterministic
memory regions. We study deterministic memory size
of Ubuntu 12.04 (x86) binaries under directories /bin,
/sbin, /usr/bin and /usr/sbin, and show the re-
sults in Table 1. Among 1093 analyzed programs, more
than 87.74% have deterministic memory regions. Two
hundred and twenty-three programs have deterministic
memory regions larger than 64KB. Inside such memory
regions, there is many security-critical data, like random-
ized addresses in .got.plt and conﬁguration struc-
tures in .bss. Hence we believe stitch with determinis-
tic addresses in real-world programs is practical.

We build an information leakage attack against the
orzhttpd web server [5] (details in Section 6.4.3) us-
ing the stitch with deterministic addresses. To respond
to a page request, orzhttpd uses a pointer to retrieve
the HTTP protocol version string. The pointer is stored
in memory. If we replace the pointer value with the ad-
dress of a secret data, the server will send that secret to
the client. However this requires both the address of the
pointer and the address of the secret to be predictable.
In the orzhttpd example, we ﬁnd that the address of
the pointer is ﬁxed (0x8051164) and choose the con-
tents of the .got.plt section (allocated at a ﬁxed ad-
dress) as the secret to leak out. Figure 6 shows two 2D-

Figure 6:
Stitch with deterministic memory addresses of the
orzhttpd server. This attack is the similar to the one in Figure 4,
except the address of the source vertex and the pointer’s address of of
the target vertex are ﬁxed. This attack works with ASLR.

DFGs for the benign execution and the attack, respec-
tively. With this attack, the content of .got.plt is sent
to the attacker, which leads to an memory address disclo-
sure exploit useful for constructing second-stage control-
hijacking attacks or stealing secret data in randomized
memory region. Unlike a direct memory disclosure at-
tack, here we use the corruption of deterministically-
allocated data to leak randomized addresses.
Identifying Stitch with Deterministic Addresses. We
represent the deterministic memory region as a set D.
Our algorithm considers the intersection of D for the ver-
tices in the source ﬂow and the target ﬂow. The previ-
ously outlined stitching algorithms can then be used di-
rectly prioritizing the vertices in the intersection with D.
3.3.2 Stitching By Address Reuse
If the security-critical data only exists inside the random-
ized memory region, data-oriented attacks cannot use de-
terministic addresses. To bypass ASLR in such cases,
we leverage the observation that a lot of randomized ad-
dresses are stored in memory. If we can reuse such real-
time randomized addresses instead of providing concrete
address in the exploit, the generated data-oriented attacks
will be stable (agnostic to address randomization). There
are two types of address reuse: partial address reuse and
complete address reuse.
Partial Address Reuse. A variable’s relative address,
with respect to the module base address or with respect
to another variable in the same module, is usually ﬁxed.
Attackers can easily calculate such relative addresses in
advance. On the other hand, instructions commonly get
a memory address with one base address and one rela-
tive offset (e.g., array access, switch table).
If attack-
ers control the offset variable, they can corrupt the offset
with the pre-computed relative address from the selected
vertex (source vertex or target vertex) and reuse the ran-
domized base address. In this way attackers can access

184  24th USENIX Security Symposium 

USENIX Association

8

1 struct user_details { uid_t uid; ... } ud;
2 ...
//run with root uid
3 ud.uid = getuid(); //in get_user_info()
4 ...
5 vfprintf(...);
6 ...
7 setuid(ud.uid);
8 ...

//in sudo_askpass()

//in sudo_debug()

Code 3: Code snippet of sudo, setting uid to normal user id.

the intended data without knowing their randomized ad-
dresses. We show an example of a vulnerable instruction
pattern, that allows the attacker partial ability to read a
value from memory and write it out without knowing
randomized addresses. If attackers control %eax, they
can reuse the source base address %esi in the ﬁrst in-
struction, and reuse the destination base address %edi
in the second instruction. In fact, any memory access in-
struction with a corrupted offset can be used to mount
partial address reuse attack.

1 //attackers control %eax
2 mov
(%esi,%eax,4), %ebx
3 mov
%ecx, (%edi,%eax,4)

//reuse %esi
//reuse %edi

Complete Address Reuse. We observe that a variable’s
address is frequently saved in memory due to the limi-
tation of CPU registers. If the memory error allows re-
trieving such spilled memory address for reading or writ-
ing, attackers can reuse the randomized vertex address
existing in memory to bypass ASLR. For example, in
the following assembly code, if attacker controls %eax
on line 1, it can load a randomized address into %ebx
from memory. Then, attacker can access the target ver-
tex pointed by %ebx without knowing the concrete ran-
domized address. The attacker merely needs to know the
right offset value to use in %eax on line 2, or may have
a deterministic %esi value to gain arbitrary control over
addresses loaded on line 2.

1 //attacker controls %eax
2 mov
3 mov

(%esi, %eax, 4), %ebx
%ecx, (%ebx) /mov

(%ebx), %ecx

Let us consider a real example of the sudo pro-
gram [9] that shows how to use such instruction patterns
that permit complete address reuse meaningfully. Code 3
shows the related code of sudo, where a format string
vulnerable exists in the sudo debug function (line 5).
At the time of executing vfprintf() on line 5, the
address of the user identity variable (ud.uid) exists on
the stack. The vfprintf() function with format string
“%X$n” uses the Xth argument on stack for “%n”. By
specifying the value of X, vfprintf() can retrieve the
address of ud.uid from its ancestor’s stack frame and
change the ud.uid to the root user ID without knowing

address 

&arg 

&ud.uid 

0 

100 
3 

address 
stack  
area  

100 

7 

time 

0 

(a) 

&ud.uid 
… ….  
vsprintf 
 Attack  

100 
3 

0 
5 

%X$n  

0 

time 

7 
(b) 

Figure 7: Stitch by complete memory address reuse of sudo. The
dashed line is the new edge (single-edge stitch). An address of ud.uid
exists on ancestor’s stack frame, which is reused to overwrite ud.uid.

the stack base address. Figure 7 shows the 2D-DFGs for
the benign execution and the attack. This attack works
even if the ﬁne-grained ASLR is deployed.
Identifying Stitch by Address Reuse. Memory error in-
structions for address reuse stitch should match the pat-
terns we discuss above. For partial address reuse, the
memory error exploit corrupts variable offsets, while for
complete address reuse, the memory error exploit can re-
trieve addresses from memory. Our approach intersects
the memory error inﬂuence I with the source ﬂow and
the target ﬂow. Then we search from the new source ﬂow
and the new target ﬂow to identify matched instructions,
from which we can build stitch by address reuse with
methods discuss above.
4 The FLOWSTITCH System

We design a system called FLOWSTITCH to system-
atically generate data-oriented attacks using data-ﬂow
stitching. As shown in Figure 8, FLOWSTITCH takes
three inputs: a program with memory errors, an error-
exhibiting input, and a benign input of the program. The
two inputs should drive the program execution down the
same execution path until the memory error instruction,
with the error-exhibiting input causing a crash. FLOW-
STITCH builds data-oriented attacks using the memory
errors in ﬁve steps. First, it generates the execution trace
for the given program. We call the execution trace with
the benign input the benign trace, and the execution trace
with the error-exhibiting input the error-exhibiting trace.
Second, FLOWSTITCH identiﬁes the inﬂuence of the
memory errors from the error-exhibiting trace and gen-
erates constraints on the program input to reach memory
errors. Third, FLOWSTITCH performs data-ﬂow anal-
ysis and security-sensitive data identiﬁcation using the
benign trace. Fourth, FLOWSTITCH selects stitch can-
didates from the identiﬁed security-sensitive data ﬂows
with the methods discussed in Section 3. Finally, FLOW-
STITCH checks the feasibility of creating new edges with
the memory errors and validates the exploit.
It ﬁnally
outputs the input to mount a data-oriented attack.

USENIX Association  

24th USENIX Security Symposium  185

9

                                       FlowStitch 

error-exhibiting  

input 
vuln.  
program 
  benign 
input 

 
r
e
g
g
o

l
 
 
 
 

e
c
a
r
T

error-

exhibiting 

trace 

Influence 
Analysis 

constraints, 
influence 

benign 
trace 

Flow  
Analysis 

data flows, 
sec. data 

Candidate 
Generation 

Single-
edge 
Multi-
edge 

Address
-reuse 
Determi
nistic-
address 

candidate 
exploits 

Filtering 

DOA 

exploits 

Figure 8: Overview of FLOWSTITCH. FLOWSTITCH takes a vulnerable program, an error-exhibiting input and a benign input of the program as
inputs. It builds data-oriented attacks against the given program using data-ﬂow stitching. Finally it outputs the data-oriented attack exploits.

FLOWSTITCH requires that the error-exhibiting input
and the benign input make the program follow the same
code path until memory error happens. Such pairs of in-
puts can be found by existing symbolic execution tools,
like BAP [16] and SAGE [25], which explore multiple
execution paths with various inputs. Before detecting
one error-exhibiting execution, these tools usually have
explored many matched benign executions.

4.1 Memory Error Inﬂuence Analysis

FLOWSTITCH analyzes the error-exhibiting trace to un-
derstand the inﬂuence I of the memory errors. It identi-
ﬁes two aspects of the memory error inﬂuence: the time
when the memory errors happens during the execution
(temporal inﬂuence) and the memory range that can be
written to in the memory error (spatial inﬂuence). From
the error-exhibiting trace, FLOWSTITCH detects instruc-
tions whose memory dereference addresses are derived
from the error-exhibiting input. We call these instruc-
tions memory error instructions. Note that data ﬂows
ending before such instructions or starting after them
cannot be affected by the memory error, therefore they
are out of the temporal inﬂuence.

Attackers get access to unintended memory locations
with memory error instructions. However, the program’s
logic limits the total memory range accessible to attack-
ers. To identify the spatial inﬂuence of the memory er-
ror instruction, we employ dynamic symbolic execution
techniques. We generate a symbolic formula from the
error-exhibiting trace in which all the inputs are sym-
bolic variables and all the path constraints are asserted
true. Inputs that satisfy the formula imply that the execu-
tion to memory error instructions with an unintended ad-
dress3. The set of addresses that satisfy these constraints
and can be dereferenced at the memory error instruction
constitute the spatial inﬂuence.

3This is true if the symbolic formula constructed is complete [26].

4.2 Security-Sensitive Data Identiﬁcation
As we discuss in Section 2.3, FLOWSTITCH synthesizes
ﬂows of security-sensitive data. There are four types of
data that are interesting for stitching:
input data, out-
put data, program secret and permission ﬂags. To iden-
tify input data, FLOWSTITCH performs taint analysis at
the time of trace generation, treating the given input as
an external taint source. For output data, FLOWSTITCH
identiﬁes a set of program sinks that send out the pro-
gram data, like send() and printf(). The parame-
ters used in sinks are the output data. Further, we classify
program secret and permission ﬂags into two categories:
the program-speciﬁc data and the generic data. FLOW-
STITCH accepts user speciﬁcation to ﬁnd out program-
speciﬁc data. For example, user can provide addresses of
security ﬂags. For the generic data, FLOWSTITCH uses
the following methods to automatically infer it.

• System call parameters. FLOWSTITCH identi-
ﬁes all system calls from the trace, like setuid,
unlink. Based on the system call convention,
FLOWSTITCH collects the system call parameters.
• Conﬁguration data. To identify conﬁguration data,
FLOWSTITCH treats the conﬁguration ﬁle as a taint
source and uses taint analysis to track the usage of
the conﬁguration data.

• Randomized data. FLOWSTITCH identiﬁes stack
canary based on the instructions that set and check
the canary, and identiﬁes randomized addresses if
they are not inside the deterministic memory region.
Deterministic Memory Region Identiﬁcation. FLOW-
STITCH identiﬁes the deterministic memory region for
stitch with deterministic addresses (Section 3.3.1).
It
ﬁrst checks the program binary to identify the memory
regions that will not be randomized at runtime.
If the
program is not position-independent, all the data sec-
tions shown in the binary headers will be at deterministic
addresses. FLOWSTITCH collects loadable sections and
gets a deterministic memory set D. FLOWSTITCH fur-
ther scans benign traces to ﬁnd all the memory writing
instructions that write data into the deterministic mem-
ory set to identify data stored in such region.

186  24th USENIX Security Symposium 

USENIX Association

10

Note that based on the functionality of the security-
sensitive data, we predeﬁne goals of the attacks. For ex-
ample, the attack of setuid parameter is to change it
to the root user’s id 0. For a web server’s home directory
string, the goal is to set it to system root directory.
4.3 Stitching Candidate Selection
For identiﬁed security-sensitive data, FLOWSTITCH gen-
erates its data ﬂow from the 2D-DFG. FLOWSTITCH se-
lects the source ﬂow originated from the source vertex VS
and the target ﬂow ended at the target vertex VT . It then
uses the stitching methods discussed in Section 3 to ﬁnd
stitching solutions. Although any combination of stitch-
ing methods can be used here, FLOWSTITCH uses the
following policy in order to produce a successful stitch-
ing efﬁciently.

1. FLOWSTITCH tries the single-edge stitch technique
before the multi-edge stitch technique. After the
single-edge stitch’s search space is exhausted, it
moves to multi-edge stitch. FLOWSTITCH stops
searching at four-edge stitch in our experiments.

2. FLOWSTITCH considers stitch with deterministic
addresses before stitch by address reuse. After ex-
hausting the search space of deterministic address
and address reuse space, FLOWSTITCH continues
searching stitches with concrete addresses shown in
benign traces, for cases without ASLR.

4.4 Candidate Filtering
To overcome challenge C3, FLOWSTITCH checks the
feasibility of each selected stitch edge candidate. We
deﬁne the stitchability constraint to cover the following
constraints.

• Path conditions to reach memory error instructions;
• Path conditions to continue to the target ﬂow;
• Integrity of the control data;
FLOWSTITCH generates the stitchability constraint
using symbolic execution tools. The constraint is sent
to SMT solvers as an input.
If the solver cannot ﬁnd
any input satisfying the constraint, FLOWSTITCH picks
the next candidate stitch edge. If it exists, the input will
be the witness input that is used to exercise the execu-
tion path in order to exhibit the data-oriented attack. Due
to the concretization in symbolic constraint generation
in the implementation, the constraints might not be com-
plete [26], i.e., it may allow inputs that results in different
paths. FLOWSTITCH concretely veriﬁes the input gener-
ated by the SMT solver to check if it successfully mounts
the data-oriented attack on the program.
5

Implementation

We prototype FLOWSTITCH on Ubuntu 12.04 32 bit sys-
tem. Note that as the ﬁrst step the trace generation tool

can work on both Windows and Linux systems to gener-
ate traces. Although the following analysis steps are per-
formed on Ubuntu, FLOWSTITCH works for both Win-
dows and Linux binaries.
Trace Generation. Our trace generation is based on
the Pintraces tool provided by BAP [16]. Pintraces is
a Pin [28] tool that uses dynamic binary instrumentation
to record the program execution status.
It logs all the
instructions executed by the program into the trace ﬁle,
together with the operand information.
In our evalua-
tion, the traces also contain dynamic taint information to
facilitate the extraction of data ﬂows.
Data Flow Generation. For input data and conﬁgura-
tion data, FLOWSTITCH uses the taint information to get
the data ﬂows. To generate the data ﬂow of the security-
sensitive data, FLOWSTITCH performs backward and
forward slicing on the benign trace to locate all the re-
lated instructions.
It is possible for one instruction to
have multiple source operands. For example, in add
%eax, %ebx, the destination operand %ebx is derived
from %eax and %ebx. In this case, one vertex has mul-
tiple parent vertices. As a result, the generated data ﬂow
is a graph where each node may have multiple parents.
Constraint Generation and Solving. The generation of
the stitchability constraint required in Section 4.4 is im-
plemented in three parts: path constraints, inﬂuence con-
straints, and CFI constraints.The stitchability constraint
is expressed as a logical conjunction of these three parts.
We use BAP to generate formulas which capture the path
conditions and inﬂuence constraints. For control ﬂow in-
tegrity constraint, we implement a procedure to search
the trace for all the indirect jmp or ret instruction.
Memory locations holding the return addresses or indi-
rect jump targets are recorded. The control ﬂow integrity
requires that at runtime, the memory location contain-
ing control data should not be corrupted by the memory
errors. The stitchability constraint is checked for satisﬁ-
ability using the Z3 SMT-solver [22], which produces a
witness input when the constraint is satisﬁable.

6 Evaluation

In this section, we evaluate the effectiveness of data-
ﬂow stitching using FLOWSTITCH,
including single-
edge stitch, multi-edge stitch, stitch with deterministic
addresses and stitch by address reuse. We also measure
the search space reduction using FLOWSTITCH and the
performance of FLOWSTITCH.

6.1 Efﬁcacy in Exploit Generation
Table 2 shows the programs used in our evaluation, as
well as their running environments and vulnerabilities.
The trace generation phase is performed on different

USENIX Association  

24th USENIX Security Symposium  187

11

Table 2: Experiment environments and benchmarks. # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ-
ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs.

ID
CVE-2013-2028
CVE-2012-0809
CVE-2009-4769
bugtraq ID: 41956
CVE-2002-1496
CVE-2001-0820
CVE-2001-0144
CVE-2000-0573
Total

Vul. Program Vulnerability
nginx
sudo
httpdx
orzhttpd
null httpd
ghttpd
SSHD
wu-ftpd
8 programs

stack buffer overﬂow
format string
format string
format string
heap overﬂow
stack buffer overﬂow
integer overﬂow
format string

Environment (32b)
Ubuntu 12.04
Ubuntu 12.04
Windows XP SP3
Ubuntu 9.10
Ubuntu 9.10
Ubuntu 12.04
Ubuntu 9.10
Ubuntu 9.10

1
1
4
1
2
1
2
2
14

1
0
1
1
0
0
1
1
5

# of Data-Oriented Attacks
Escalation

Leakage

Table 3: Evaluation of FLOWSTITCH on generating data-oriented attacks. In the Attack Description column, Li stands for information leakage
attack, while Mi represents privilege escalation attack. The third column indicates whether the built attack can bypass ASLR or not. The “CP”
column shows the number of memory error instructions. Trace size is the number of instructions inside the trace. The last four columns show the
number of stitch sources and stitch targets before and after our selection. SrcFlow means source ﬂow, while TgtFlow stands for target ﬂow.

ASLR
Bypass

Error-exhibiting

Trace Size

Benign

Trace Size

# of nodes before

# of nodes after

SrcFlow

TgtFlow

SrcFlow

TgtFlow

Vul. Apps

nginx

sudo

httpdx

orzhttpd

null httpd

ghttpd

SSHD

wu-ftpd

Attack Description
L0: private key
M0: http directory path
M0: user id
L0: admin’s password
M0: admin’s password
M1: anon.’s permission
M2: anon.’s root directory
M3: CGI directory path
L0: randomized address
M0: directory path
M0: http directory path
M1: CGI directory path
M0: CGI directory path
L0: root password hash
M0: user id
M1: authenticated ﬂag
L0: env. variables
M0: user id (single-edge)
M1: user id (multi-edge)

(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)

(cid:31)
(cid:31)

CP

1

1

1

1

2

1

1

1

50789

351988

1197657

84694

160844

312130

38201

328108

411437
1717182
854371
1361761
1298247
1233522
1522672
1257694
131871
131871
401285
335329
316473
3094592
674365
674365
1417908
1057554
1057554

3
173
2083
152
78
78
78
78
8
368
3
3

3579
776
1
1
88
183
183

48
462
1
7
120
2
165
480
28
95
141
144
6
56
24
2
5
2
1

3
1
1
152
1
1
1
1
8
1
2
2
1
97
1
1
88
1
1

1
42
1
2
8
1
11
30
1
19
47
48
1
2
1
1
1
1
1

systems according to the tested program. All gener-
ated traces are analyzed by FLOWSTITCH on a 32-bit
Ubuntu 12.04 system. The vulnerabilities used for the
experiments come from four different categories to en-
sure that FLOWSTITCH can handle different vulnerabili-
ties. Seven of the 8 vulnerable programs are server pro-
grams, including HTTP and FTP servers, which are the
common targets of remote attacks. The other one is the
sudo program, which allows users to run command as
another user on Unix-like system. The last four vulner-
abilities were discussed in [19], where data-oriented at-
tacks were manually built. We apply FLOWSTITCH on
these vulnerabilities to verify the efﬁcacy of our method.
Results. Our result demonstrates that FLOWSTITCH
can effectively generate data-oriented attacks with dif-
ferent vulnerabilities on different platforms. The num-
ber of generated data-oriented attacks on each program
is shown in Table 2 and their details are given in Ta-
ble 3. FLOWSTITCH generates a total of 19 data-oriented

attacks for eight real-world vulnerable programs, more
than two attacks per program on average. Among 19
data-oriented attacks, there are ﬁve information leak-
age attacks and 14 privilege escalation attacks. For the
vulnerable httpdx server, FLOWSTITCH generates ﬁve
data-oriented attacks from a format string vulnerability.
Out of the 19 data-oriented attacks, 16 are previ-
ously unknown. The three known attacks are two uid-
corruption attacks on SSHD and wu-ftpd, and a CGI
directory corruption attack on null httpd, discussed
in [19]. FLOWSTITCH successfully reproduces known
attacks and builds new data-oriented attacks with the
same vulnerabilities. Note that FLOWSTITCH produces
a different ghttpd CGI directory corruption attack than
the one described in [19]. Details of this attack are dis-
cussed in Section 6.4.2. The results show the efﬁcacy of
our systematic approach in identifying new data-oriented
attacks.

From our experiments, seven out of 19 of the data-

188  24th USENIX Security Symposium 

USENIX Association

12

oriented attacks are generated using multi-edge stitch.
The signiﬁcant number of new data-oriented attacks gen-
erated by multi-edge stitch highlights the importance of
a systematic approach in managing the complexity and
identifying new data-oriented attacks. As a measure-
ment of the efﬁcacy of ASLR on data-oriented attacks,
we report that 10 of 19 attacks work even with ASLR
deployed. Among 10 attacks, two attacks reuse ran-
domized addresses on the stack and eight attacks cor-
rupt data in the deterministic memory region. We ob-
serve that security-sensitive data such as conﬁguration
option is usually represented as a global variable in C
programs and reside in the .bss segment. This high-
lights the limitation of current ASLR implementations
which randomize the stack and heap addresses but not
the .bss segment.

For three of 19 attacks, FLOWSTITCH requires the
user to specify the security-sensitive data, including the
private key of nginx, the root password hash and the au-
thenticated ﬂag of SSHD. For others, FLOWSTITCH au-
tomatically infers the security-sensitive data using tech-
niques discussed in Section 4.2. Once such data is
identiﬁed, FLOWSTITCH automatically generates data-
oriented exploits.
6.2 Reduction in Search Space
Data-ﬂow stitching has a large search space due to the
large number of vertices in the ﬂows to be stitched. Man-
ual checking through a large search space is difﬁcult.
For example, in the root password hash leakage attack
against SSHD server, there are 776 vertices in source ﬂow
containing the hashed root passwords. In the target ﬂow,
there are 56 vertices leading to the output data. Without
considering the inﬂuence of the memory errors, there are
a total of 43,456 possible stitch edges. After applying the
methods described in Section 3, we get the intersection
of the memory error inﬂuence I with the stitch source set
R-set and the stitch target set W-set. In this way, the num-
ber of candidate edges is reduced from 43,456 to 194,
obtaining a reduction ratio of 224.

The last four columns in Table 3 give the detailed in-
formation of the search space for each attack. For most of
the data-oriented attacks, there is a signiﬁcant reduction
in the number of possible stitches. ghttpd-M0 achieves
the highest reduction ratio of 21,474 while SSHD-M1
achieves the lowest reduction ratio of two. The median
reduction ratio is 183 achieved by wu-ftpd-M1(multi-
edge). Given the relatively large spatial inﬂuence of the
memory error, most of the reduction is achieved by the
temporal inﬂuence of I.
6.3 Performance
We measure the time FLOWSTITCH uses to generate
data-oriented attacks. Table 4 shows the results, includ-

Table 4: Performance of trace and ﬂow generation using FLOW-
STITCH. The unit used in the table is second, so 1:07 means one minute
and seven seconds.

Trace Gen

Slicing

error
0:08

0:35

0:08

0:17

0:13

0:09

2:35

0:12

0:32

benign
0:22
0:36
1:07
0:45
0:51
0:50
1:03
0:53
0:20
0:20
1:20
0:52
0:18
9:38
5:30
5:30
0:50
0:31
0:31
1:41

error
0:06

1:17

0:12

0:12

0:14

0:12

1:02

0:19

0:26

Attacks

nginx

sudo

httpdx

L0
M0
M0
L0
M0
M1
M2
M3
L0
orzhttpd
M0
null httpd M0
M1
M0
ghttpd
L0
M0
M1
L0
M0
M1

wu-ftpd

SSHD

Average

benign
2:41
0:12
3:34
5:56
4:44
4:52
4:45
4:47
0:24
1:04
6:21
2:29
0:09
21:08
1:22
1:00
5:42
0:27
0:26
3:47

Total
3:17
1:02
6:33
7:01
5:55
6:02
6:08
6:00
1:13
1:53
8:08
3:48
0:48
34:23
10:29
10:07
7:03
1:29
1:28
6:27

ing the time of trace generation and the time of data-
ﬂow collection (slicing). Note that the trace generation
time includes the time to execute instructions that are
not logged (e.g., crypto routines and mpz library for
SSHD). As we can see from Table 4, FLOWSTITCH takes
an average of six minutes and 27 seconds to generate the
trace and ﬂows. Most of them are generated within 10
minutes. The information leakage attack of SSHD server
takes the longest time, 34 minutes and 23 seconds, since
crypto routines execute a large number of instructions.
From the performance results, we can see that the gen-
eration of data ﬂows through trace slicing takes up most
of the generation time, from 20 percent to 87 percent.
Currently, our slicer works on BAP IL ﬁle. We plan to
optimize the slicer using parallel tools in the future.
6.4 Case Studies
We present ﬁve case studies to demonstrate the effective-
ness of stitching methods and interesting observations.

6.4.1 Sensitive Data Lifespan

A common defense employed to reduce the effective-
ness of data-oriented attacks is to limit the lifespan of
security-critical data [19, 20]. This case study highlights
the difﬁculty of doing it correctly. In the implementa-
tion of SSHD, the program explicitly zeros out sensi-
tive data, such as the RSA private keys, as soon as they
are not in use. For password authentication on Linux,
getspnam() provided by glibc is often used to ob-
tain the password hash. Rather than using the password
hash directly, SSHD makes a local copy of the password

USENIX Association  

24th USENIX Security Symposium  189

13

hash on stack for its use. Although the program makes
no special effort is to clear the copy on the stack, the
password on stack is eventually overwritten by subse-
quent function frames before it can be leaked. The devel-
oper explicitly deallocates the original hash value using
endspent() [1] in the glibc internal data structures.
However, glibc does not clear the deallocated memory
after endspent() is called and this allows FLOW-
STITCH to successfully leak the hash from the copy held
by glibc. Hence, this case study highlights that sensitive
information should not be kept by the program after us-
age, and that identifying all copies of sensitive data in
memory is difﬁcult at the source level.

6.4.2 Multi-edge Stitch – ghttpd CGI Directory

The ghttpd application is a light-weight web server
supporting CGI. A stack buffer overﬂow vulnerability
was reported in version 1.4.0 - 1.4.3, allowing remote at-
tackers to smash the stack of the vulnerable Log() func-
tion. During the security-sensitive data identiﬁcation,
FLOWSTITCH detects execv() is used to run an exe-
cutable ﬁle. One of execv()’s arguments is the address
of the program path string. Controlling it allows attack-
ers to run arbitrary commands. FLOWSTITCH is unable
to ﬁnd a new data dependency edge using single-edge
stitching, since there is no security-sensitive data on the
stack frame to corrupt. FLOWSTITCH then proceeds to
search for a multi-edge stitch. For the program path pa-
rameter of execv(), FLOWSTITCH identiﬁes its ﬂow,
which includes use of a series of stack frame-base point-
ers saved in memory. The temporal constraints of the
memory error exploit only allow the saved %ebp of the
Log() function to be corrupted. Once the Log() func-
tion returns, the saved %ebp is used as a pointer, refer-
ring to all the local variables and parameters of Log()
caller’s stack frame. FLOWSTITCH corrupts the saved
%ebp to change the variable for the CGI directory used
in execv() system call. This attack is a four-edge stitch
by composing two pointer stitches.

Chen et al. [19] discussed a data-oriented attack with
the same vulnerability, which was in fact a two-edge
stitch. However, that attack no longer works in our exper-
iment. The ghttpd program compiled on our Ubuntu
12.04 platform does not store the address of command
string on the stack frame of Log(). Only the four-edge
stitching can be used to attack our ghttpd binary.

6.4.3 Bypassing ASLR – orzhttpd Attacks

The orzhttpd web server has a format string vulnera-
bility which the attacker can exploit to control almost the
whole memory space of the vulnerable program. FLOW-
STITCH identiﬁes the deterministic memory region and
the randomized address on stack under fprintf()

frame. The ﬁrst attack which bypasses ASLR is a privi-
lege escalation attack. This attack corrupts the web root
directory with single-edge stitching and memory address
reuse. The root directory string is stored on the heap,
which is allocated at runtime. FLOWSTITCH identiﬁes
the address of the heap string from the stack and reuses it
to directly change the string to / based on the pre-deﬁned
goal (Section 4.2). The second attack is an information
leakage attack, which leaks randomized addresses in the
.got.plt section. FLOWSTITCH identiﬁes the deter-
ministic memory region from the binary and performs
a multi-edge stitch. The stitch involves modifying the
pointer of an HTTP protocol string stored in a determin-
istic memory region. FLOWSTITCH changes the pointer
value to the address of .got.plt section and a sub-
sequent call to send the HTTP protocol string leaks the
randomized addresses to attackers.

6.4.4 Privilege Escalation – Nginx Root Directory
The Nginx HTTP server 1.3.9-1.4.0 has a buffer over-
ﬂow vulnerability [4]. FLOWSTITCH checks the local
variables on the vulnerable stack and identiﬁes two data
pointers that can be used to perform arbitrary memory
corruption. The memory inﬂuence of the overwriting is
limited by the program logic. FLOWSTITCH identiﬁes
the web root directory string from the conﬁguration data.
It tries single-edge stitching to corrupt the root directory
setting. The root directory string is inside the memory in-
ﬂuence of the arbitrary overwriting. FLOWSTITCH over-
writes the value 0x002f into the string location, thus
changing the root directory into /. FLOWSTITCH veri-
ﬁes the attack by requesting /etc/passwd ﬁle. As a
result, the server sends the ﬁle content back to the client.

Information Leakage – httpdx Password

6.4.5
The httpdx server has a format string vulnerability be-
tween version 1.4 to 1.5 [3]. The vulnerable tolog()
function records FTP commands and HTTP requests into
a server-side log ﬁle. Note that direct exploitation of this
vulnerability does not leak information. Using the error-
exhibiting trace, FLOWSTITCH identiﬁes the memory er-
ror instruction and ﬁgures out that there is almost no lim-
itation on the memory range affected by attackers. From
the httpdx binary, FLOWSTITCH manages to ﬁnd a to-
tal of 102MB of deterministic memory addresses. From
the benign trace, FLOWSTITCH generates data ﬂows of
the root user passwords. This is the secret to be leaked
out. The FLOWSTITCH generates the necessary data ﬂow
which reaches the send() system call automatically.

Starting from the memory error instruction, FLOW-
STITCH searches backwards in the secret data ﬂow and
identiﬁes vertices inside the deterministic memory re-
gion. FLOWSTITCH successfully ﬁnds two such mem-
ory locations containing the “admin” password: one is a

190  24th USENIX Security Symposium 

USENIX Association

14

buffer containing the whole conﬁguration ﬁle, and an-
other only contains the password. At the same time,
FLOWSTITCH searches forwards in the output ﬂow to
ﬁnd the vertices that affect
the buffer argument of
send(). Our tool identiﬁes vertices within the deter-
ministic memory region. The solver gives one possible
input that will trigger the attack. FLOWSTITCH conﬁrms
this attack by providing the attack input to the server and
receiving the “admin” user password.

7 Related Work

Data-Oriented Attack. Several work [21, 32, 36, 38, 41,
43, 44] has been done to improve the practicality of CFI,
increasing the barrier to constructing control ﬂow hijack-
ing attacks. Instead, data-oriented attacks are serious al-
ternatives. Data-oriented attacks have been conceptually
known for a decade. Chen et al. constructed non-control-
data exploits to show that data-oriented attack is a real-
istic threat [19]. However, no systematic method to de-
velop data-oriented attacks is known yet. In our paper,
we develop a systematic way to search for possible data-
oriented attacks. This method searches attacks within the
candidate space efﬁciently and effectively.
Automatic Exploit Generation. Brumley et al. [17] de-
scribed an automatic exploit generation technique based
on program patches. The idea is to identify the difference
between the patched and the unpatched binaries, and
generate an input to trigger the difference. Avgerinos et
al. [13] discussed Automatic Exploit Generation(AEG)
to generate real exploits resulting in a working shell. Fel-
metsger et al. [24] discussed automatic exploit genera-
tion for web applications. The previous work focused
on generating control ﬂow hijacking exploits. FLOW-
STITCH on the other hand generates data-oriented at-
tacks that do not violate the control ﬂow integrity. To
our knowledge, FLOWSTITCH is the ﬁrst tool to system-
atically generate data-oriented attacks.
Defenses against Data-Oriented Attacks.
Data-
oriented attacks can be prevented by enforcing data-ﬂow
integrity (DFI). Existing work enforces DFI through dy-
namic information tracking [23, 39, 40] or by legitimate
memory modiﬁcation instruction analysis [18,42]. How-
ever, DFI defenses are not yet practical, requiring large
overheads or manual declassiﬁcation. An ultimate de-
fense is to enforce the memory safety to prevent the at-
tacks in their ﬁrst steps. Cyclone [27] and CCured [31]
introduce a safe type system to the type-unsafe C lan-
guages. SoftBound [29] with CETS [30] uses bound
checking with fat-pointer to force a complete memory
safety. Cling [11] enforces temporal memory safety
through type-safe memory reuse. Data-oriented attack
prevention requires a complete memory safety.

8 Conclusion

In this paper, we present a new concept called data-
ﬂow stitching, and develop a novel solution to systemati-
cally construct data-oriented attacks. We discuss novel
stitching methods, including single-edge stitch, multi-
edge stitch, stitch with deterministic addresses and stitch
by address reuse. We build a prototype of data-ﬂow
stitching, called FLOWSTITCH. FLOWSTITCH gener-
ates 19 data-oriented attacks from eight vulnerable pro-
grams. Sixteen attacks are previously unknown attacks.
All attacks bypass DEP and the CFI checks, and 10 by-
pass ASLR. The result shows that automatic generation
of data-oriented exploits exhibiting signiﬁcant damage is
practical.

Acknowledgments. We thank R. Sekar, Shweta Shinde,
Yaoqi Jia, Xiaolei Li, Shruti Tople, Pratik Soni and
the anonymous reviewers for their insightful comments.
This research is supported in part by the National Re-
search Foundation, Prime Minister’s Ofﬁce, Singapore
under its National Cybersecurity R&D Program (Award
No. NRF2014NCR-NCR001-21) and administered by
the National Cybersecurity R&D Directorate, and in part
by a research grant from Symantec.
References
[1] Endspent(3C).

https://docs.oracle.com/cd/

E36784 01/html/E36874/endspent-3c.html.

[2] How Effective is ASLR on Linux Systems?

http:

//securityetalii.es/2013/02/03/how-
effective-is-aslr-on-linux-systems/.

[3] HTTPDX tolog() Function Format String Vulnerability.

http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2009-4769.

[4] Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer
Overﬂow. http://mailman.nginx.org/pipermail/
nginx-announce/2013/000112.html.

[5] OrzHTTPd.

orzhttpd/.

https://code.google.com/p/

[6] Subverting without EIP.

http://mallocat.com/

subverting-without-eip/.

[7] The Heartbleed Bug. http://heartbleed.com/.
[8] Visual Studio 2015 Preview: Work-in-Progress Security Fea-
ture. http://blogs.msdn.com/b/vcblog/archive/
2014/12/08/visual-studio-2015-preview-
work-in-progress-security-feature.aspx.

[9] Sudo Format String Vulnerability. http://www.sudo.ws/

sudo/alerts/sudo debug.html, 2012.

[10] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.
Control-ﬂow Integrity. In Proceedings of the 12th ACM Confer-
ence on Computer and Communications Security (2005).

[11] AKRITIDIS, P. Cling: A Memory Allocator to Mitigate Dangling
Pointers. In Proceedings of the 19th USENIX Security Symposium
(2010).

[12] ANDERSEN, S., AND ABELLA, V. Changes to Functionality in
Microsoft Windows XP Service Pack 2, Part 3: Memory protec-
tion technologies, Data Execution Prevention. Microsoft TechNet
Library, September 2004.

USENIX Association  

24th USENIX Security Symposium  191

15

[13] AVGERINOS, T., CHA, S. K., HAO, B. L. T., AND BRUMLEY,
D. AEG: Automatic Exploit Generation. In Proceedings of the
18th Annual Network and Distributed System Security Sympo-
sium (2011).

[14] BACKES, M., HOLZ, T., KOLLENDA, B., KOPPE, P.,
N ¨URNBERGER, S., AND PEWNY, J. You Can Run but You Can’t
Read: Preventing Disclosure Exploits in Executable Code.
In
Proceedings of the 21st ACM Conference on Computer and Com-
munications Security (2014).

[15] BHATKAR, S., DUVARNEY, D. C., AND SEKAR, R. Address
Obfuscation: An Efﬁcient Approach to Combat a Broad Range
of Memory Error Exploits. In Proceedings of the 12th USENIX
Security Symposium (2003).

[16] BRUMLEY, D., JAGER, I., AVGERINOS, T., AND SCHWARTZ,
E. J. BAP: A Binary Analysis Platform. In Proceedings of the
23rd International Conference on Computer Aided Veriﬁcation
(2011).

[17] BRUMLEY, D., POOSANKAM, P., SONG, D., AND ZHENG, J.
Automatic Patch-Based Exploit Generation is Possible: Tech-
niques and Implications. In Proceedings of the 29th IEEE Sym-
posium on Security and Privacy (2008).

[18] CASTRO, M., COSTA, M., AND HARRIS, T. Securing Soft-
ware by Enforcing Data-Flow Integrity.
In Proceedings of the
7th Symposium on Operating Systems Design and Implementa-
tion (2006).

[19] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER,
R. K. Non-Control-Data Attacks Are Realistic Threats. In Pro-
ceedings of the 14th USENIX Security Symposium (2005).

[20] CHOW, J., PFAFF, B., GARFINKEL, T., AND ROSENBLUM, M.
Shredding Your Garbage: Reducing Data Lifetime Through Se-
cure Deallocation. In Proceedings of the 14th USENIX Security
Symposium (2005).

[21] CRISWELL, J., DAUTENHAHN, N., AND ADVE, V. KCoFI:
Complete Control-Flow Integrity for Commodity Operating Sys-
tem Kernels.
In Proceedings of the 35th IEEE Symposium on
Security and Privacy (2014).

[22] DE MOURA, L., AND BJØRNER, N. Z3: An Efﬁcient SMT
Solver. In Proceedings of the Theory and Practice of Software,
14th International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (2008).

[23] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
J., MCDANIEL, P., AND SHETH, A. N.
TaintDroid: An
Information-ﬂow Tracking System for Realtime Privacy Monitor-
ing on Smartphones. In Proceedings of the 9th USENIX Confer-
ence on Operating Systems Design and Implementation (2010).

[24] FELMETSGER, V., CAVEDON, L., KRUEGEL, C., AND VIGNA,
G. Toward Automated Detection of Logic Vulnerabilities in Web
Applications. In Proceedings of the 19th USENIX Security Sym-
posium (2010).

[25] GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. A. Auto-
mated whitebox fuzz testing. In Proceedings of the 15th Annual
Network and Distributed System Security Symposium (2008), In-
ternet Society.

[26] GODEFROID, P., AND TALY, A. Automated Synthesis of Sym-
bolic Instruction Encodings from I/O Samples. In Proceedings of
the 33rd ACM SIGPLAN Conference on Programming Language
Design and Implementation (2012).

[27] JIM, T., MORRISETT, J. G., GROSSMAN, D., HICKS, M. W.,
CHENEY, J., AND WANG, Y. Cyclone: A Safe Dialect of
C. In Proceedings of the USENIX Annual Technical Conference
(2002).

[28] LUK, C.-K., COHN, R., MUTH, R., PATIL, H., KLAUSER, A.,
LOWNEY, G., WALLACE, S., REDDI, V. J., AND HAZELWOOD,
K. Pin: Building Customized Program Analysis Tools with Dy-
namic Instrumentation.
In Proceedings of the 2005 ACM SIG-
PLAN Conference on Programming Language Design and Im-
plementation (2005).

[29] NAGARAKATTE, S., ZHAO,

J., MARTIN, M. M., AND
ZDANCEWIC, S. SoftBound: Highly Compatible and Complete
Spatial Memory Safety for C. In Proceedings of the 30th ACM
SIG-PLAN Conference on Programming Language Design and
Implementation (2009).

[30] NAGARAKATTE, S., ZHAO,

J., MARTIN, M. M., AND
ZDANCEWIC, S. CETS: Compiler Enforced Temporal Safety for
C. In Proceedings of the 9th International Symposium on Mem-
ory Management (2010).

[31] NECULA, G. C., MCPEAK, S., AND WEIMER, W. CCured:
Type-safe Retroﬁtting of Legacy Code.
In Proceedings of the
29th ACM SIGPLAN-SIGACT Symposium on Principles of Pro-
gramming Languages (2002).

[32] NIU, B., AND TAN, G. Modular Control-ﬂow Integrity. In Pro-
ceedings of the 35th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (2014).

[33] PAX TEAM.

PaX Address Space Layout Randomization
(ASLR). http://pax.grsecurity.net/docs/aslr.
txt, 2003.

[34] PAYER, M., AND GROSS, T. R. String Oriented Programming:
When ASLR is Not Enough.
In Proceedings of the 2nd ACM
SIGPLAN Program Protection and Reverse Engineering Work-
shop (2013).

[35] SERNA, F. J. The Info Leak Era on Software Exploitation. Black

Hat USA (2012).

[36] TICE, C., ROEDER, T., COLLINGBOURNE, P., CHECKOWAY,
S., ERLINGSSON, U., LOZANO, L., AND PIKE, G. Enforcing
Forward-edge Control-ﬂow Integrity in GCC & LLVM. In Pro-
ceedings of the 23rd USENIX Security Symposium (2014).

[37] UBUNTU. List of Programs Built with PIE, May 2012. https:

//wiki.ubuntu.com/Security/Features#pie.

[38] WANG, Z., AND JIANG, X. HyperSafe: A Lightweight Ap-
proach to Provide Lifetime Hypervisor Control-Flow Integrity.
In Proceedings of the 31st IEEE Symposium on Security and Pri-
vacy (2010).

[39] XU, W., BHATKAR, S., AND SEKAR, R. Taint-Enhanced Policy
Enforcement: A Practical Approach to Defeat a Wide Range of
Attacks. In Proceedings of the 15th USENIX Security Symposium
(2006).

[40] YIP, A., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F.
Improving Application Security with Data Flow Assertions. In
Proceedings of the ACM SIGOPS 22nd Symposium on Operating
Systems Principles (2009).

[41] ZENG, B., TAN, G., AND ERLINGSSON, U. Strato: A Retar-
getable Framework for Low-level Inlined-reference Monitors. In
Proceedings of the 22nd USENIX Security Symposium (2013).

[42] ZENG, B., TAN, G., AND MORRISETT, G. Combining Control-
Flow Integrity and Static Analysis for Efﬁcient and Validated
Data Sandboxing. In Proceedings of the 18th ACM conference
on Computer and Communications Security (2011).

[43] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical Control
Flow Integrity and Randomization for Binary Executables.
In
Proceedings of the 34th IEEE Symposium on Security and Pri-
vacy (2013).

[44] ZHANG, M., AND SEKAR, R. Control Flow Integrity for COTS
Binaries. In Proceedings of the 22nd USENIX Security Sympo-
sium (2013).

192  24th USENIX Security Symposium 

USENIX Association

16

