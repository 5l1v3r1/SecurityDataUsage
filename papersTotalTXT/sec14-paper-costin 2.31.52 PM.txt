A Large-Scale Analysis of the Security  

of Embedded Firmwares

Andrei Costin, Jonas Zaddach, Aurélien Francillon, and Davide Balzarotti, Eurecom

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/costin

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXA Large-Scale Analysis of the Security of Embedded Firmwares

Andrei Costin, Jonas Zaddach, Aur´elien Francillon and Davide Balzarotti

EURECOM

Sophia Antipolis

France

{name.surname}@eurecom.fr

Abstract

1 Introduction

As embedded systems are more than ever present in
our society, their security is becoming an increasingly
important issue. However, based on the results of many
recent analyses of individual ﬁrmware images, embed-
ded systems acquired a reputation of being insecure. De-
spite these facts, we still lack a global understanding of
embedded systems’ security as well as the tools and tech-
niques needed to support such general claims.

In this paper we present the ﬁrst public, large-scale
analysis of ﬁrmware images. In particular, we unpacked
32 thousand ﬁrmware images into 1.7 million individ-
ual ﬁles, which we then statically analyzed. We leverage
this large-scale analysis to bring new insights on the se-
curity of embedded devices and to underline and detail
several important challenges that need to be addressed in
future research. We also show the main beneﬁts of look-
ing at many different devices at the same time and of
linking our results with other large-scale datasets such as
the ZMap’s HTTPS survey.

In summary, without performing sophisticated static
analysis, we discovered a total of 38 previously unknown
vulnerabilities in over 693 ﬁrmware images. Moreover,
by correlating similar ﬁles inside apparently unrelated
ﬁrmware images, we were able to extend some of those
vulnerabilities to over 123 different products. We also
conﬁrmed that some of these vulnerabilities altogether
are affecting at least 140K devices accessible over the
Internet. It would not have been possible to achieve these
results without an analysis at such wide scale.

We believe that this project, which we plan to provide
as a ﬁrmware unpacking and analysis web service1, will
help shed some light on the security of embedded de-
vices.

1http://firmware.re

Embedded systems are omnipresent in our everyday life.
For example, they are the core of various Common-
Off-The-Shelf (COTS) devices such as printers, mobile
phones, home routers, and computer components and pe-
ripherals. They are also present in many devices that are
less consumer oriented such as video surveillance sys-
tems, medical implants, car elements, SCADA and PLC
devices, and basically anything we normally call elec-
tronics. The emerging phenomenon of the Internet-of-
Things (IoT) will make them even more widespread and
interconnected.

All these systems run special software, often called
ﬁrmware, which is usually distributed by vendors as ﬁrm-
ware images or ﬁrmware updates. Several deﬁnitions for
ﬁrmware exist in the literature. The term was originally
introduced to describe the CPU microcode that existed
“somewhere” between the hardware and the software
layers. However, the word quickly assumed a broader
meaning, and the IEEE Std 610.12-1990 [6] extended
the deﬁnition to cover the “combination of a hardware
device and computer instructions or computer data that
reside as read-only software on the hardware device”.

Nowadays, the term ﬁrmware is more generally used
to describe the software that is embedded in a hard-
ware device. Like traditional software, embedded de-
vices’ ﬁrmware may have bugs or misconﬁgurations that
can result in vulnerabilities for the devices which run
that particular code. Due to anecdotal evidence, embed-
ded systems acquired a bad security reputation, gener-
ally based on case by case experiences of failures. For
instance, a car model throttle control fails [47] or can be
maliciously taken over [21, 55]; a home wireless router
is found to have a backdoor [48, 7, 44], just to name
a few recent examples. On the one hand, apart from a
few works that targeted speciﬁc devices or software ver-
sions [39, 27, 63], to date there is still no large-scale se-
curity analysis of ﬁrmware images. On the other hand,

USENIX Association  

23rd USENIX Security Symposium  95

manual security analysis of ﬁrmware images yields very
accurate results, but it is extremely slow and does not
scale well for a large and heterogeneous dataset of ﬁrm-
ware images. As useful as such individual reports are for
a particular device or ﬁrmware version, these alone do
not allow to establish a general judgment on the over-
all state of the security of ﬁrmware images. Even worse,
the same vulnerability may be present in different de-
vices, which are left vulnerable until those ﬂaws are re-
discovered independently by other researchers [48]. This
is often the case when several integration vendors rely
on the same subcontractors, tools, or SDKs provided by
development vendors. Devices may also be branded un-
der different names but may actually run either the same
or similar ﬁrmware. Such devices will often be affected
by exactly the same vulnerabilities, however, without a
detailed knowledge of the internal relationships between
those vendors, it is often impossible to identify such sim-
ilarities. As a consequence, some devices will often be
left affected by known vulnerabilities even if an updated
ﬁrmware is available.

1.1 Methodology

Performing a large-scale study of the security of embed-
ded devices by actually running the physical devices (i.e.,
using a dynamic analysis approach) has several major
drawbacks. First of all, physically acquiring thousands of
devices to study would be prohibitively expensive. More-
over, some of them may be hard to operate outside the
system for which they are designed — e.g., a throttle
control outside a car. Another option is to analyze exist-
ing online devices as presented by Cui and Stolfo [29].
However, some vulnerabilities are hard to ﬁnd by just
looking at the running device, and it is ethically ques-
tionable to perform any nontrivial analysis on an online
system without authorization.

Unsurprisingly, static analysis scales better than dy-
namic analysis as it does not require access to the physi-
cal devices. Hence, we decided to follow this approach in
our study. Our methodology consists of collecting ﬁrm-
ware images for as many devices and vendors as possi-
ble. This task is complicated by the fact that ﬁrmware
images are diverse and it is often difﬁcult to tell ﬁrm-
ware images apart from other ﬁles. In particular, distri-
bution channels, packaging formats, installation proce-
dures, and availability of meta-data often depend on the
vendor and on the device type. We then designed and im-
plemented a distributed architecture to unpack and run
simple static analysis tasks on the collected ﬁrmware im-
ages. However, the contribution of this paper is not in
the static analysis techniques we use (for example, we
did not perform any static code analysis), but to show
the advantages of an horizontal, large-scale exploration.

For this reason, we implemented a correlation engine to
compare and ﬁnd similarities between all the objects in
our dataset. This allowed us to quickly “propagate” vul-
nerabilities from known vulnerable devices to other sys-
tems that were previously not known to be affected by
the same vulnerability.

Most of the steps performed by our system are concep-
tually simple and could be easily performed manually on
a few devices. However, we identiﬁed ﬁve major chal-
lenges that researchers need to address in order to per-
form large scale experiments on thousands of different
ﬁrmware images. These include the problem of building
a representative dataset (Challenge A in Section 2), of
properly identifying individual ﬁrmware images (Chal-
lenge B in Section 2), of unpacking custom archive for-
mats (Challenge C in Section 2), of limiting the required
computation resources (Challenge D in Section 2), and
ﬁnally of ﬁnding an automated way to conﬁrm the re-
sults of the analysis (Challenge E in Section 2). While
in this paper we do not propose a complete solution for
all these challenges, we discuss the way and the extent to
which we dealt with some of these challenges to perform
a systematic, automated, large-scale analysis of ﬁrmware
images.

1.2 Results Overview

For our experiments we collected an initial set of
759,273 ﬁles (totaling 1.8TB of storage space) from
publicly accessible ﬁrmware update sites. After ﬁltering
out the obvious noise, we were left with 172,751 poten-
tial ﬁrmware images. We then sampled a set of 32,356
ﬁrmware candidates that we analyzed using a private
cloud deployment of 90 worker nodes. The analysis and
reports resulted in a 10GB database.

The analysis of sampled ﬁles led us to automatically
discover and report 38 new vulnerabilities (ﬁxes for some
of these are still pending) and to conﬁrm several that
were already known [44, 48]. Some of our ﬁndings in-
clude:

• We extracted private RSA keys and their self-signed
certiﬁcates used in about 35,000 online devices
(mainly associated with surveillance cameras).

• We extracted several dozens of hard-coded pass-
word hashes. Most of them were weak, and there-
fore we were able to easily recover the original pass-
words.

• We identiﬁed a number of possible backdoors such
as the authorized keys ﬁle (which lists the SSH
keys that are allowed to remotely connect to the
system), a number of hard-coded telnetd creden-
tials affecting at least 2K devices, hard-coded web-
login admin credentials affecting at least 101K de-

96  23rd USENIX Security Symposium 

USENIX Association

vices, and a number of backdoored daemons and
web pages in the web-interface of the devices.

and balanced dataset of ﬁrmware images a difﬁcult prob-
lem to solve.

• Whenever a new vulnerability was discovered (by
other researchers or by us) our analysis infrastruc-
ture allowed us to quickly ﬁnd related devices or
ﬁrmware versions that were likely affected by the
same vulnerability. For example, our correlation
techniques allowed us to correctly extend the list of
affected devices for variations of a telnetd hard-
coded credentials vulnerability. In other cases, this
led us to ﬁnd a vulnerability’s root problem spread
across multiple vendors.

1.3 Contributions

In summary this paper makes the following contribu-
tions:

• We show the advantages of performing a large-scale
analysis of ﬁrmware images and describe the main
challenges associated with this activity.

• We propose a framework to perform ﬁrmware col-
lection, ﬁltering, unpacking and analysis at large
scale.

• We implemented several efﬁcient static techniques

that we ran on 32, 356 ﬁrmware candidates.

• We present a correlation technique which allows to
propagate vulnerability information to similar ﬁrm-
ware images.

• We discovered 693 ﬁrmware images affected by at
least one vulnerability and reported 38 new CVEs.

2 Challenges

As mentioned in the previous section, there are clear ad-
vantages of performing a wide-scale analysis of embed-
ded ﬁrmware images. In fact, as is often the case in sys-
tem security, certain phenomena can only be observed by
looking at the global picture and not by studying a single
device (or a single family of devices) at a time.

However, large-scale experiments require automated
techniques to obtain ﬁrmware images, unpack them, and
analyze the extracted ﬁles. While these are easy tasks for
a human, they become challenging when they need to be
fully automated. In this section we summarize the ﬁve
main challenges that we faced during the design and im-
plementation of our experiments.

Challenge A: Building a Representative Dataset

The embedded systems environment is heterogeneous,
spanning a variety of devices, vendors, architectures, in-
struction sets, operating systems, and custom compo-
nents. This makes the task of compiling a representative

The real market distribution of a certain hardware ar-
chitecture is often unknown, and it is hard to compare
different classes of devices (e.g., medical implants vs.
surveillance cameras). Which of them need to be taken
into account to build a representative ﬁrmware dataset?
How easy is it to generalize a technique that has only
been tested on a certain brand of routers to other ven-
dors? How easy is it to apply the same technique to other
classes of devices such as TVs, cameras, insulin pumps,
or power plant controllers?

From a practical point of view, the lack of centralized
points of collection (such as the ones provided by an-
tivirus vendors or public sandboxes in the malware ana-
lysis ﬁeld) makes it difﬁcult for researchers to gather a
large and well triaged dataset. Firmware often needs to
be downloaded from the vendor web pages, and it is not
always simple, even for a human, to tell whether or not
two ﬁrmware images are for the same physical device.

Challenge B: Firmware Identiﬁcation

One challenge often encountered in ﬁrmware analysis
and reverse engineering is the difﬁculty of reliably ex-
tracting meta-data from a ﬁrmware image. For instance,
such meta-data includes the vendor, the device product
code and purpose, the ﬁrmware version, and the proces-
sor architecture, among many other details.

In practice, the diversity of ﬁrmware ﬁle formats
makes it harder to even recognize that a given ﬁle down-
loaded from a vendor website is a ﬁrmware at all. Often
ﬁrmware updates come in unexpected formats such as
HP Printer Job Language and PostScript documents for
printers [24, 23, 27], DOS executables for BIOS, and ISO
images for hard disk drives [72].

In many cases, the only source of reliable informa-
tion is the ofﬁcial vendor documentation. While this
is not a problem when looking manually at a few de-
vices, extending the analysis to hundreds of vendors and
thousands of ﬁrmware images automatically downloaded
from the Internet is challenging. In fact, the information
retrieval process is hard to automate and is error prone, in
particular for certain classes of meta-data. For instance,
we often found it hard to infer the correct version num-
ber. This makes it difﬁcult for a large-scale collection and
analysis system to tell which is the latest version avail-
able for a certain device, and even if two ﬁrmware images
corresponded to different versions for the same device.
This further complicates the task of building an unbiased
dataset.

USENIX Association  

23rd USENIX Security Symposium  97

Challenge C: Unpacking and Custom Formats

Assuming the analyst succeeded in collecting a repre-
sentative and well labeled dataset of ﬁrmware images,
the next challenge consists in locating and extracting im-
portant functional blocks (e.g., binary code, conﬁgura-
tion ﬁles, scripts, web interfaces) on which static analysis
routines can be performed.

While this task would be easy to address for tra-
ditional software components, where standardized for-
mats for the distribution of machine code (e.g., PE and
ELF), resources (e.g., JPEG and GZIP) and groups of
ﬁles (e.g., ZIP and TAR) exist, embedded software dis-
tribution lacks standards. Vendors have developed their
own ﬁle formats to describe ﬂash and memory images.
In some cases those formats are compressed with non-
standard compression algorithms. In other cases those
formats are obfuscated or encrypted to prevent analysis.
Monolithic ﬁrmware, in which the bootloader, the oper-
ating system kernel, the applications, and other resources
are combined together in a single memory image are es-
pecially challenging to unpack.

Forensic strategies, like ﬁle carving, can help to ex-
tract known ﬁle formats from a binary blob. Unfortu-
nately those methods have drawbacks: On the one hand,
they are often too aggressive with the result of extract-
ing data that matches a ﬁle pattern only by chance. On
the other hand, they are computationally expensive, since
each unpacker has to be tried for each ﬁle offset of the bi-
nary ﬁrmware blob.

Finally, if a binary ﬁle has been extracted that does
not match any known ﬁle pattern, it is impossible to say
if this ﬁle is a data ﬁle, or just another container for-
mat that is not recognized by the unpacker. In general,
we tried to unpack at least until reaching uncompressed
ﬁles. In some cases, our extraction goes one step further
and tries to extract sections, resources and compressed
streams (e.g., for the ELF ﬁle format).

Challenge D: Scalability and Computational Limits

One of the main advantages of performing a wide-scale
analysis is the ability of correlating information across
multiple devices. For example, this allowed us to auto-
matically identify the re-use of vulnerable components
among different ﬁrmware images, even from different
vendors.

Capturing the global picture of the relationship be-
tween ﬁrmware images would require the one-to-one
comparison of each pair of unpacked ﬁles. Fuzzy hashes
(such as sdhash [62] and ssdeep [54]) are a common
and effective solution for this type of task and they have
been successfully used in similar domains, e.g., to cor-
relate samples that belong to the same malware fami-
lies [35, 15]. However, as described in more detail in

Section 3.4, computing the similarity between the ob-
jects extracted from 26,275 ﬁrmware images requires
1012 comparisons. Using the simpler fuzzy hash vari-
ant, we estimate that on a single dual-core computer this
task would take approximately 850 days2. This simple
estimation highlights one of the possible computational
challenges associated with a large-scale ﬁrmware ana-
lysis. Even if we had a perfect database design and a
highly optimized in-memory database, it would still be
hard to compute, store, and query the fuzzy hash scores
of all pairs of unpacked ﬁles. A distributed computational
infrastructure can help reduce the total time since the
task itself is parallelizable [57]. However, since the num-
ber of comparisons grows quadratically with the number
of elements to compare, this problem quickly becomes
impracticable for large image datasets. If, for example,
one would like to build a fuzzy hash database for our
whole dataset, which is just ﬁve times the size of the cur-
rent sampled dataset, this effort would already take more
than 150 CPU years instead of 850 CPU days. Our at-
tempt to use the GPU-assisted fuzzy hashing provided
by sdhash [62] only resulted in a limited speedup that
was not sufﬁcient to perform a full-scale comparison of
all ﬁles in our dataset.

Challenge E: Results Conﬁrmation

The ﬁrst four challenges were mostly related to the col-
lection of the dataset and the pre-processing of the ﬁrm-
ware images. Once the code or the resources used by the
embedded device have been successfully extracted and
identiﬁed, researchers can focus their attention on the
static analysis. Even though the details and goals of this
step are beyond the scope of this paper, in Section 3.3 we
present some examples of simple static analysis and we
discuss the advantages of performing these techniques on
a large scale.

However, one important research challenge remains
regarding the way the results of static analysis can be
conﬁrmed. For example, we can consider a scenario
where a researcher applies a new vulnerability detection
technique to several thousand ﬁrmware images. Those
images were designed to run on speciﬁc embedded de-
vices, most of which are not available to the researcher
and would be hard and costly to acquire. Lacking the
proper hardware platform, there is still no way to manu-
ally or automatically test the affected code to conﬁrm or
deny the ﬁndings of the static analysis.

For example, in our experiments we identiﬁed a ﬁrm-
ware image that included the PHP 5.2.12 banner string.
This allowed us to easily identify several vulnerabilities

2 This is mainly because comparing fuzzy hashes is not a simple bit
string comparison but actually involves a rather complex algorithm and
high computational effort.

98  23rd USENIX Security Symposium 

USENIX Association

that have been retrieved either by the web crawler or that
have been submitted through the public web interface.
When a new ﬁle is received by the ﬁrmware data store,
it is automatically scheduled to be processed by the ana-
lysis cloud. The analysis cloud consists of a master node,
and a number of worker and hash cracking nodes. The
master node distributes unpacking jobs to the worker
nodes (Figure 2), which unpack and analyze ﬁrmware
images. Hash cracking nodes process password hashes
that have been found during the analysis, and try to ﬁnd
the corresponding plaintext passwords. Apart from co-
ordinating the worker nodes, the master node also runs
the correlation engine and the data enrichment system
modules. These modules improve the reports with results
from the cross-ﬁrmware analysis.

The analysis cloud is where the actual analysis of the
ﬁrmware takes place. Each ﬁrmware image is ﬁrst sub-
mitted to the master node. Subsequently, worker nodes
are responsible for unpacking and analyzing the ﬁrm-
ware and for returning the results of the analysis back
to the master node. At this point, the master node will
submit this information to the reports database. If there
were any uncracked password hashes in the analyzed
ﬁrmware, it will additionally submit those hashes to one
of the hash cracking nodes which will try to recover the
plaintext passwords.

It is important to note that only the results of the ana-
lysis and the meta-data of the unpacked ﬁles are stored
in the database. Even though we do not currently use the
extracted ﬁles after the analysis, we still archive them for
future work, or in case we want to review or enhance a
speciﬁc set of analyzed ﬁrmware images.

The architecture contains two other components: the
correlation engine and the data enrichment system. Both
of them fetch the results of the ﬁrmware analysis from
the reports database and perform additional tasks. The
correlation engine identiﬁes a number of “interesting”
ﬁles and tries to correlate them with any other ﬁle present
in the database. The enrichment system is responsible for
enhancing the information about each ﬁrmware image
by performing online scans and lookup queries (e.g., de-
tecting vendor name, device name/code and device cate-
gory).

In the remainder of this section we describe each step
of the ﬁrmware analysis in more detail so that our exper-
iments can be reproduced.

3.2 Firmware Acquisition and Storage

The ﬁrst step of our experiments consisted in gathering
a ﬁrmware collection for analysis. We achieved this goal
by using mainly two methods: a web crawler that auto-
matically downloads ﬁles from manufacturers’ websites
and specialized mirror sites, and a website with a submis-

Figure 1: Architecture of the entire system.

associated with that version of the PHP interpreter. How-
ever, this is insufﬁcient to determine if the PHP inter-
preter is vulnerable, since the vendor may have applied
patches to correct known vulnerabilities without this be-
ing reﬂected in the version string. In addition, the vendor
might have used an architecture and/or a set of compi-
lation options which produced a non-vulnerable build of
the component. Unfortunately, even if a proof of concept
attack exists for that vulnerability, without the proper
hardware it is impossible to test the ﬁrmware and con-
ﬁrm or deny the presence of the problem.

Conﬁrming the results of the static analysis on ﬁrm-
ware devices is a tedious task requiring manual interven-
tion from an expert. Scaling this effort to thousands of
ﬁrmware images is even harder. Therefore, we believe
the development of new techniques is required to accu-
rately deal with this problem at a large scale.

3 Setup

In this section we ﬁrst present the design of our dis-
tributed static analysis and correlation system. Then we
detail the techniques we used, and how we addressed the
challenges described in Section 2.

3.1 Architecture

Figure 1 presents an overview of our architecture. The
ﬁrst component of our analysis platform is the ﬁrmware
data store, which stores the unmodiﬁed ﬁrmware ﬁles

USENIX Association  

23rd USENIX Security Symposium  99

sion interface where users can submit ﬁrmware images
for analysis.

We initialized the crawler with tens of support pages
from well known manufacturers such as Xerox, Bosch,
Philips, D-Link, Samsung, LG, Belkin, etc. Second,
we used public FTP indexing engines 3 to search for
ﬁles with keywords related to ﬁrmware images (e.g.,
firmware). The result of such searches yields either di-
rectory URLs, which are added to the crawler list of
URLs to index and download, or ﬁle URLs, which are
directly downloaded by the crawler. At the same time,
the script strips ﬁlenames out of the URLs to create ad-
ditional directory URLs.

Finally, we used Google Custom Search Engines
(GCSE) [3] to create customized search engines. GCSE
provides a ﬂexible API to perform advanced search
queries and returns results in a structured way. It also
allows to programmatically create a very customized
CSE on-the-ﬂy using a combination of RESTful and
XML APIs. For example, a CSE is created using
support.nikonusa.com as the “Sites to Search” pa-
rameter. Then a ﬁrmware related query is used on the
CSE such as ‘‘firmware download’’. The CSE from
the above example returns 2,210 results at the time of
this publication. The result URLs along with associated
meta-data are retrieved via the JSON API. Each URL
was then used by the crawler or as part of other dynamic
CSE, as previously described. This allowed us to mine
additional ﬁrmware images and ﬁrmware repositories.

We chose not to ﬁlter data at collection time, but to
download ﬁles greedily, deciding at a later stage if the
collected ﬁles were ﬁrmware images or not. The reason
for this decision is two-fold. First, accompanying ﬁles
such as manuals and user guides can be useful for ﬁnd-
ing additional download locations or for extracting con-
tained information (e.g., model, default passwords, up-
date URLs). Second, as we mentioned previously, it is
often difﬁcult to distinguish ﬁrmware images from other
ﬁles. For this reason, ﬁltering a large dataset is better than
taking a chance to miss ﬁrmware ﬁles during the down-
loading phase. In total, we crawled 284 sites and stopped
downloading once the collection of ﬁles reached 1.8TB
of storage. The actual storage required for this amount
of data is at least 3-4 times larger, since we used mir-
rored backup storage, as well as space for keeping the
unpacked ﬁles and ﬁles generated during the unpacking
(e.g., logs and analysis results).

The public web submission interface provides a means
for security researchers to submit ﬁrmware ﬁles for ana-
lysis. After the analysis is completed, the platform pro-

3FTP

indexing
www.filemare.com,
www.filesearching.com,
www.search-ftps.com

engines

such

as:

www.mmnt.ru,
www.filewatcher.com,
www.ftpsearch.net,

duces a report with information about the ﬁrmware con-
tents as well as similarities to other ﬁrmware in our
database. We have already received tens of ﬁrmware im-
ages through the submission interface. While this is cur-
rently a marginal source of ﬁrmware ﬁles, we expect that
more ﬁrmware will be submitted as we advertise our ser-
vice. This will also be a unique chance to have access to
ﬁrmware images that are not generally available and, for
example, need to be manually extracted from a device.

Files fetched by the web crawler and received from
the web submission interface are added to the ﬁrmware
data store. Files are simply stored on a ﬁle system and a
database is used for meta-data (e.g., ﬁle checksum, size,
download location).

3.3 Unpacking and Analysis

The next step towards the analysis of a ﬁrmware image is
to unpack and extract the contained ﬁles or objects. The
output of this phase largely depends on the type of ﬁrm-
ware. In some examples, executable code and resources
(such as graphics ﬁles or HTML code) can be linked into
a binary blob that is designed to be directly copied into
memory by a bootloader and then executed. Some other
ﬁrmware images are distributed in a compressed and ob-
fuscated ﬁle which contains a block-by-block copy of a
ﬂash image. Such an image may consist of several parti-
tions containing a bootloader, a kernel and a ﬁle system.

Unpacking Frameworks

There are three main tools to unpack arbitrary ﬁrmware
images: binwalk [41], FRAK [26] and Binary Analysis
Toolkit (BAT) [66].

Binwalk is a well known ﬁrmware unpacking tool de-
veloped by Craig Heffner [41]. It uses pattern matching
to locate and carve ﬁles from a binary blob. Additionally,
it also extracts meta-data such as license strings.

FRAK is an unpacking toolkit ﬁrst presented by Cui
et al. [27]. Even though the authors mention that the tool
would be made publicly available, we were not able to
obtain a copy. We therefore had to evaluate its unpack-
ing performance based on the device vendors and mod-
els that FRAK supports, according to [27]. We estimated
that FRAK would have unpacked less than 1% of the
ﬁles we analyzed, while our platform was able to unpack
more than 81% of them. This said, both would be com-
plementary as some of the ﬁle formats FRAK unpacks
are unsupported by our tool at present.

The Binary Analysis Toolkit (BAT), formerly known
as GPLtool, was originally designed by Tjaldur soft-
ware to detect GPL violations [45, 66]. To this end,
it recursively extracts ﬁles from a ﬁrmware blob and
matches strings with a database of known strings from

100  23rd USENIX Security Symposium 

USENIX Association

Table 1: Comparison of Binwalk, BAT, FRAK and our framework.
The last three columns show if the respective unpacker was able to ex-
tract the ﬁrmware. Note that this is a non statistically signiﬁcant sample
which is given for illustrating unpacking performance (manual analysis
of each ﬁrmware is time consuming). As FRAK was not available for
testing, its unpacking performance was estimated based on information
from [26]. The additional performance of our framework stems from
the many customizations we have incrementally developed over BAT
(Figure 2).

Device

Vendor

OS

Binwalk BAT

FRAK

Our

framework

PC
Camera
Router
ADSL
Gateway
PLC
DSLAM
PC
ISDN
Server
Voip
Modem
Home
Automation

Intel
STL
Bintec

BIOS
Linux
-

Zyxel

ZynOS

Siemens
-
Intel

-
-
BIOS

Planet

-

Asotel
-

Vxworks
-

Belkin

Linux

























































































55%

64%

0%

82%

GPL projects. Additionally, BAT supports ﬁle carving
similar to binwalk.

Table 1 shows a simple comparison of the unpack-
ing performance of each framework on a few samples
of ﬁrmware images. We chose to use BAT because it is
the most complete tool available for our purposes. It also
has a signiﬁcantly lower rate of false positive extractions
compared to binwalk. In addition, binwalk did not sup-
port recursive unpacking at the time when we decided on
an unpacking framework. Nevertheless, the interface be-
tween our framework and BAT has been designed to be
generic so that integrating other unpacking toolkits (such
as binwalk) is easy.

We developed a range of additional plugins for BAT.
These include plugins which extract interesting strings
(e.g., software versions or password hashes), add un-
packing methods, gather statistics and collect interesting
ﬁles such as private key ﬁles or authorized keys ﬁles.
In total we added 35 plugins to the existing framework.

Password Hash Cracking

Figure 2: Architecture of a single worker node.

mon password lists and strings extracted from ﬁrmwares,
manuals, readme ﬁles and other resources. This allows
to ﬁnd both passwords that are directly present in those
ﬁles as well as passwords that are weak and based on
keywords related to the product.

Parallelizing the Unpacking and Analysis

To accelerate the unpacking process, we distributed this
task on several worker nodes. Our distributed environ-
ment is based on the distributed-python-for-scripting
framework [65]. Data is synchronized between the repos-
itory and the nodes using rsync (over ssh) [67].

Our loosely coupled architecture allows us to run
worker nodes virtually anywhere. For instance, we in-
stantiated worker virtual machines on a local VMware
server and several OpenStack servers, as well as on Ama-
zon EC2 instances. At the time of this publication we
were using 90 such virtual machines to analyze ﬁrmware
ﬁles.

3.4 Correlation Engine

The unpacked ﬁrmware images and analysis results are
stored into the analysis & reports database. This allows
us to perform queries, to generate reports and statistics,
and to easily integrate our results with other external
components. The correlation engine is designed to ﬁnd
similarities between different ﬁrmware images. In partic-
ular, the comparison is made along four different dimen-
sions: shared credentials, shared self-signed certiﬁcates,
common keywords, and fuzzy hashes of the ﬁrmwares
and objects within the ﬁrmwares.

Password hashes found during the analysis phase are
passed to a hash cracking node. These nodes are dedi-
cated physical hosts with a Nvidia Tesla GPU [56] that
run a CUDA-enabled [59] version of John The Rip-
per [60]. John The Ripper is capable of brute forcing
most encoded password hashes and detecting the type of
hash and salt used. In addition to this, a dictionary can be
provided to seed the password cracking. For each brute
force attempt, we provide a dictionary built from com-

Shared Credentials and Self-Signed Certiﬁcates

Shared credentials (such as hard coded non-trivial pass-
words) and shared self-signed certiﬁcates are effective
in ﬁnding strong connections between different ﬁrmware
images of the same vendor, or even ﬁrmwares of differ-
ent vendors. For example, we were able to correlate two
brands of CCTV systems based on a common non-trivial
default password.

USENIX Association  

23rd USENIX Security Symposium  101

Therefore, ﬁnding a password of one vendor’s product
can directly impact the security of others. We also found
a similar type of correlation for two other CCTV vendors
that we linked through the same self-signed certiﬁcate, as
explained in Section 5.2.

Keywords

Keywords correlation is based on speciﬁc strings ex-
tracted by our static analysis plugins. In some cases, for
example in Section 5.1, the keyword “backdoor” re-
vealed several other keywords. By using the extended
set of keywords we clustered several vendors prone
to the same backdoor functionality, possibly affecting
500, 000 devices. In other cases, ﬁles inside ﬁrmware
images contain compilation and SDK paths. This turns
out to be sufﬁcient to cluster ﬁrmware images of differ-
ent devices.

Fuzzy hashes

Fuzzy hash triage (comparison, correlation and cluster-
ing) is the most generic correlation technique used by
our framework. The engine computes both the ssdeep
and the sdhash of every single object extracted from the
ﬁrmware image during the unpacking phase. This is a
powerful technique that allows us to ﬁnd ﬁles that are
“similar” but for which a traditional hash (such as MD5
or SHA1) would not match. Unfortunately, as we already
mentioned in Section 2, a complete one-to-one compar-
ison of fuzzy hashes is currently infeasible on a large
scale. Therefore, we compute the fuzzy hashes of each
ﬁle that was successfully extracted from a ﬁrmware im-
age and store this result. When a ﬁle is found to be inter-
esting we perform the fuzzy hash comparison between
this ﬁle’s hash and all stored hashes.

For example, a ﬁle (or all ﬁles unpacked from a ﬁrm-
ware) may be ﬂagged as interesting because it is affected
by a known vulnerability, or because we found it to be
vulnerable by static analysis. If another ﬁrmware con-
tains a ﬁle that is similar to a ﬁle from a vulnerable ﬁrm-
ware, then there might be a chance that the ﬁrst ﬁrmware
is also vulnerable. We present such an example in Sec-
tion 5.3, where this approach was successful and allowed
us to propagate known vulnerabilities of one device to
other similar devices of different vendors.

Future work

In the literature, there are several approaches proposed
to perform comparison, clustering, and triage on a large
scale. Jang et al. propose large-scale triage techniques
of PC malware in BitShred [52]. The authors concluded
that at the rate of 8,000 unique malware samples per day,
which required 31M comparisons, it is unfeasible on a

single CPU to perform one-to-one comparisons to ﬁnd
malware families using hierarchical clustering. French
and Casey [13] propose, before fuzzy hash comparison,
to perform a “bins” partitioning approach based on the
block and ﬁle sizes. This approach, for their particular
dataset and bins partitioning strategy, allowed on aver-
age to reduce the search space for a given fuzzy hash
down to 16.9%. Chakradeo et al. [20] propose MAST,
an effective and well performing triage architecture for
mobile market applications. It solves the manual and
resource-intensive automated analysis at market-scale
using Multiple Correspondence Analysis (MCA) statis-
tical method.

As a future work, there are several possible improve-
ments to our approach. For instance, instead of perform-
ing all comparisons on a single machine, we could adopt
a distributed comparison and clustering infrastructure,
such as the Hadoop implementation of MapReduce [32]
used by BitShred. Second, on each comparison and clus-
tering node we could use the “bins” partitioning ap-
proach from French and Casey [13].

3.5 Data Enrichment

The data enrichment phase is responsible for extending
the knowledge base about ﬁrmware images, for exam-
ple by performing automated queries and passive scans
over the Internet. In the current prototype, the data en-
richment relies on two simple techniques. First, it uses
the <title> tag of web pages and authentication
realms of web servers when these are detected inside a
ﬁrmware. This information is then used to build targeted
search queries (such as “intitle:Router ABC-123 Admin
Page”) for both Shodan [5] and GCSE.

Second, we correlate SSL certiﬁcates extracted from
ﬁrmware images to those collected by the ZMap project.
ZMap was used in [37] to scan the whole IPv4 address
space on the 443 port, collecting SSL certiﬁcates in a
large database.

Correlating these two large-scale databases (i.e.,
ZMap’s HTTPS survey and our ﬁrmware database) pro-
vides new insights. For example, we are able to quickly
evaluate the severity of a particular vulnerability by iden-
tifying publicly reachable devices that are running a
given ﬁrmware image. This gives a good estimate for the
number of publicly accessible vulnerable devices.

For instance, our framework found 41 certiﬁcates hav-
ing unprotected private keys. Those keys were extracted
from ﬁrmware images in the unpacking and analysis
phase. The data enrichment engine subsequently found
the same self-signed certiﬁcate in over 35K devices
reachable on the Internet. We detail this case study in
Section 5.2.

102  23rd USENIX Security Symposium 

USENIX Association

3.6 Setup Development Effort

Our framework relies on many existing tools. In addition
to this, we have put a considerable effort (over 20k lines
of code according to sloccount [68]) to extend BAT,
develop new unpackers, create the results analysis plat-
form and run results interpretation.

4 Dataset and Results

In this section we describe our dataset and we present the
results of the global analysis, including the discussion of
the new vulnerabilities and the common bad practices we
discovered in our experiments. In Section 5, we will then
present a few concrete case studies, illustrating how such
a large dataset can provide new insights into the security
of embedded systems.

4.1 General Dataset Statistics

While we currently collect ﬁrmware images from multi-
ple sources, most of the images in our dataset have been
downloaded by crawling the Internet. As a consequence,
our dataset is biased towards devices for which ﬁrmware
updates can be found online, and towards known vendors
that maintain well organized websites.

We also decided to exclude ﬁrmware images of smart-
phones from our study. In fact, popular smartphone ﬁrm-
ware images are complete operating system distributions,
most of them iOS, Android or Windows based – making
them closer to general purpose systems than to embed-
ded devices.

Our crawler collected 759,273 ﬁles, for a total of
1.8TB of data. After ﬁltering out the ﬁles that were
clearly unrelated (e.g., manuals, user guides, web pages,
empty ﬁles) we obtained a dataset of 172,751 ﬁles. Our
architecture is constantly running to fetch more samples
and analyze them in a distributed fashion. At the time of
this publication the system was able to process (unpack
and analyze) 32,356 ﬁrmware images.

Firmware Identiﬁcation The problem of properly
identifying a ﬁrmware image (Challenge 2) still requires
a considerable amount of manual effort. Doing so accu-
rately and automatically at a large scale is a daunting
task. Nevertheless, we are interested in having an esti-
mate of the number of actual ﬁrmware images in our
dataset.

For this purpose we manually analyzed a number of
random samples from our dataset of 172,751 poten-
tial ﬁrmware images and computed a conﬁdence inter-
val [19] to estimate the global representativeness in the
dataset. In particular, after manually analyzing 130 ran-
dom ﬁles from the total of 172,751, we were able to

2 and more

fm11−os

rtems

ambarella

ecos

windows ce

nucleus

vxworks

linux

S
O

1

10

100

1000

10000

Detections (log)

Figure 3: OS distribution among ﬁrmware images.

mark only 44 as ﬁrmware images. This translates to a
proportion of 34% (± 8%) ﬁrmware images on our data-
set – with a 95% conﬁdence. The manual analysis pro-
cess took approximately one person-week because the
inspection of the extracted ﬁles for ﬁrmware code is quite
tedious.

We can therefore expect our dataset to contain be-
tween 44,431 and 72,520 ﬁrmware images (by applying
34%−8%, and 34%+8% respectively, to the entire can-
didates set of 172,751). While the range is still relatively
large, this estimation gives a 95% reliable measure of the
useful data in our sample. We also developed a heuristic
to automatically detect if a ﬁle is successfully unpacked
or not. This heuristic takes multiple parameters, such as
the number, type and size of ﬁles carved out from a ﬁrm-
ware, into account. Such an empirical heuristic is not per-
fect, but it can guide our framework to mark a ﬁle as un-
packed or not, and then take actions accordingly.

Files Analysis As described in Section 3.3, unpack-
ing unknown ﬁles is an error-prone and time-consuming
task. In fact, when the ﬁle format is not recognized, un-
packing relies on a slow and imprecise carving approach.
File carving is essentially an attempt to unpack at every
offset of the ﬁle, iterating over several known signatures
(e.g., archive magic headers).

As a result, out of the 32,356 ﬁles we processed so
far, 26,275 were successfully unpacked. The process is
nevertheless continuous and more ﬁrmware images are
being unpacked over time.

4.2 Results Overview

In the rest of the section we present the results of the ana-
lysis performed by our plugins right after each ﬁrmware
image was unpacked.

Files Formats The majority of initial ﬁles being un-
packed were identiﬁed as compressed ﬁles or raw data.
Once unpacked, most of those ﬁrmware images were

USENIX Association  

23rd USENIX Security Symposium  103

identiﬁed as targeting ARM (63%) devices, followed by
MIPS (7%). As reported in Figure 3, Linux is the most
frequently encountered embedded operating system in
our dataset – being present in more than three quarters
(86%) of all analyzed ﬁrmware images. The remaining
images contain proprietary operating systems like Vx-
Works, Nucleus RTOS and Windows CE, which alto-
gether represent around 7%. Among Linux based ﬁrm-
ware images, we identiﬁed 112 distinct Linux kernel
versions.

Password Hashes Statistics Files like /etc/passwd
and /etc/shadow store hashed versions of account cre-
dentials. These are usual targets for attackers since they
can be used to retrieve passwords which often allow to
login remotely to a device at a later time. Hence, an ana-
lysis of these ﬁles can help understanding how well an
embedded device is protected.

Our plugin responsible for collecting entries from
/etc/passwd and /etc/shadow ﬁles retrieved 100 dis-
tinct password hashes, covering 681 distinct ﬁrmware
images and belonging to 27 vendors. We were also able
to recover the plaintext passwords for 58 of those hashes,
which occur in 538 distinct ﬁrmware images. The most
popular passwords were <empty>, pass, logout, and
helpme. While these may look trivial, it is important to
stress that they are actually used in a large number of
embedded devices.

Certiﬁcates and Private RSA Keys Statistics Many
vendors include self-signed certiﬁcates inside their ﬁrm-
ware images [43, 42]. Due to bad practices in both re-
lease management and software design, some vendors
also include the private keys (e.g., PEM, GPG), as con-
ﬁrmed by recent advisories [49, 51].

We developed two simple plugins for our system
which collect SSL certiﬁcates and private keys. These
plugins also collect their ﬁngerprints and check for
empty or trivial passphrases. So far, we have been able to
extract 109 private RSA keys from 428 ﬁrmware images
and 56 self-signed SSL certiﬁcates out of 344 ﬁrmware
images. In total, we obtained 41 self-signed SSL cer-
tiﬁcates together with their corresponding private RSA
keys. By looking up those certiﬁcates in the public ZMap
datasets [36], we were able to automatically locate about
35,000 active online devices.

For all these devices, if the certiﬁcate and private key
are not regenerated on the ﬁrst boot after a ﬁrmware up-
date, HTTPS encryption can be easily decrypted by an
attacker by simply downloading a copy of the ﬁrmware
image. In addition, if both a regenerated and a ﬁrmware-
shipped self-signed certiﬁcate are used interchangeably,
the user of the device may still be vulnerable to man-in-
the-middle (MITM) attacks.

Packaging Outdated and Vulnerable Software An-
other interesting ﬁnding relates to bad release manage-
ment by embedded ﬁrmware vendors. Firmware images
often rely on many third-party software and libraries.
Those keep updating and have security ﬁxes every now
and then. OWASP Top Ten [61] lists “Using Components
with Known Vulnerabilities” at position nine and under-
lines that “upgrading to these new versions is critical”.
In one particular case, we identiﬁed a relatively re-
cently released ﬁrmware image that contained a kernel
(version 2.4.20) that was built and packaged ten years af-
ter its initial release. In another case, we discovered that
some recently released ﬁrmware images contained nine
years old BusyBox versions.

Building Images as root While prototyping, putting
together a build environment as fast as possible is very
important. Unfortunately, sometimes the easiest solution
is just to setup and run the entire toolchains as superuser.
Our analysis plugins extracted several compilation
banners such as Linux version 2.6.31.8-mv78100
(root@ubuntu) (gcc version 4.2.0 20070413
(prerelease)) Mon Nov 7 16:51:58 JST 2011
or BusyBox v1.7.0 (2007-10-15 19:49:46 IST).
24% of the 450 unique banners we collected contain-
ing the user@host combinations were associated to the
root user. In addition to this, among the 267 unique
hostnames extracted from those banners, ten resolved to
public IP addresses and one of these even accepted in-
coming SSH connections.

All these ﬁndings reveal a number of unsafe practices
ranging from build management (e.g., build process done
as root) to infrastructure management (e.g., build hosts
reachable over public networks), to release management
(e.g., usernames and hostnames not removed from pro-
duction release builds).

Web Servers Conﬁguration We developed plugins to
analyze the conﬁguration ﬁles of web servers embed-
ded in the ﬁrmware images such as lighttpd.conf or
boa.conf. We then parsed the extracted ﬁles to retrieve
speciﬁc conﬁguration settings such as the running user,
the documents root directory, and the ﬁle containing au-
thentication secrets. We collected in total 847 distinct
web server conﬁguration ﬁles and the ﬁndings were dis-
couraging. We found that in more than 81% of the cases
the web servers were conﬁgured to run as a privileged
user (i.e., having a setting such as user=root). This re-
veals unsafe practices of insecure design and conﬁgu-
ration. Running the web server of an embedded device
with unnecessarily high privileges can be extremely risky
since the security of the entire device can be compro-
mised by ﬁnding a vulnerability in one of the web com-
ponents.

104  23rd USENIX Security Symposium 

USENIX Association

5 Case Studies

5.1 Backdoors in Plain Sight

Many backdoors in embedded systems have been re-
ported recently, ranging from very simple cases [44] to
others that were more difﬁcult to discover [50, 64]. In one
famous case [44], the backdoor was found to be activated
by the string “xmlset roodkcableoj28840ybtide”
(i.e., edit by 04882 joel backdoor in reverse).
This fully functional backdoor was affecting three ven-
dors. Interestingly enough, this backdoor may have been
detected earlier by a simple keyword matching on the
open source release from the vendor[2].

Inspired by this case, we performed a string search in
our dataset with various backdoor related keywords. Sur-
prisingly, we found 1198 matches, in 326 ﬁrmware can-
didates.

Among those search results, several matched the ﬁrm-
ware of a home automation device from a major vendor.
According to download statistics from Google Play and
Apple App Store, more than half a million users have
downloaded an app for this device [9, 8].

We manually analyzed the ﬁrmware of this Linux-
based embedded system and found that a daemon pro-
cess listens on a network multicast address. This service
allows execution of remote commands with root privi-
leges without any authentication to anybody in the local
network. An attacker can easily gain full control if he can
send multicast packets to the device.

We then used this example as a seed for our corre-
lation engine. With this approach we found exactly the
same backdoor in two other classes of devices from two
different vendors. One of them was affecting 109 ﬁrm-
ware images of 44 camera models of a major CCTV
solutions vendor, Vendor C. The other case is affecting
three ﬁrmware images for home routers of a major net-
working equipment vendor, Vendor D.

We investigated the issue and found that the affected
devices were relying on the same provider of a System on
a Chip (SoC) for networking devices. It seems that this
backdoor is intended for system debugging, and is part of
a development kit. Unfortunately we were not able to lo-
cate the source of this binary. We plan to acquire some of
those devices to verify the exploitability of the backdoor.

5.2 Private SSL Keys

In addition to the backdoors left in ﬁrmware images from
Vendor C, we also found many ﬁrmware images contain-
ing public and private RSA key pairs. Those unprotected
keys are used to provide SSL access to the CCTV cam-
era’s web interface. Surprisingly, this private key is the
same across many ﬁrmware images of the same brand.

Figure 4: Correlation engine and shared self-signed certiﬁcates clus-
tering.

Our platform automatically extracts the ﬁngerprint
of the public keys, private keys and SSL certiﬁcates.
Those keys are then searched in ZMap’s HTTPS sur-
vey database [36, 37]. Vendor C’s SSL certiﬁcate was
found to be used by around 30K online IP addresses,
most likely each corresponding to a single online de-
vice. We then fetched the web pages available at those
addresses (without trying to authenticate). Surprisingly,
we found CCTV cameras branded by another vendor –
Vendor B – which appears to be an integrator. Upon in-
spection, cameras of Vendor B served exactly the same
SSL certiﬁcate as cameras from Vendor C (including the
SSL Common Name, and SSL Organizational Unit as
well as many other ﬁelds of the SSL certiﬁcate). The only
difference is that CCTV cameras of Vendor B returned
branded authentication realms, error messages and logos.
The correlation engine ﬁndings are summarized in Fig-
ure 4.

Unfortunately, the ﬁrmware images from Vendor B do
not seem to be publicly available. We are planning to
obtain a device to extract its ﬁrmware and to conﬁrm
our ﬁndings. We have reported these issues to the ven-
dor. Nevertheless, it is very likely that devices from Ven-
dor B are also vulnerable to the multicast packet back-
door given the clear relationship with Vendor C that that
our platform discovered.

USENIX Association  

23rd USENIX Security Symposium  105

5.3 XSS in WiFi Enabled SD Cards?

SD cards are often more complex than one would imag-
ine. Most SD cards actually contain a processor which
runs ﬁrmware. This processor often manages functions
such as the ﬂash memory translation layer and wear lev-
eling. Security issues have been previously shown on
such SD cards [69].

Some SD cards have an embedded WiFi interface with
a full ﬂedged web server. This interface allows direct ac-
cess to the ﬁles on the SD card without ejecting it from
the device in which it is inserted. It also allows admin-
istration of the SD card conﬁguration (e.g., WiFi access
points).

We manually found a Cross Site Scripting (XSS) vul-
nerability in one of these web interfaces, which consists
of a perl based web application. As this web application
does not have platform speciﬁc binary bindings, we were
able to load the ﬁles inside a similar Boa web server on
a PC and conﬁrm the vulnerability.

Once we found the exact perl ﬁles responsible for
the XSS, we used our correlation engine based on fuzzy
hashes. With this we automatically found another SD
card ﬁrmware that is vulnerable to the same XSS. Even
though the perl ﬁles were slightly different, they were
clearly identiﬁed as similar by the fuzzy hash. This corre-
lation would not have been detected by a normal check-
sum or by a regular hash function.

The process is visualized in Figure 5. The ﬁle (*) was
found vulnerable. Subsequently, we identiﬁed correlated
ﬁles based on fuzzy hashing. Some of them were related
to the same ﬁrmware or a previous version of the ﬁrm-
ware of the same vendor (in red). Also, fuzzy hash cor-
relation identiﬁed a similar ﬁle in a ﬁrmware from a dif-
ferent vendor (in orange) that is vulnerable to the same
weakness. It further identiﬁed some non-vulnerable or
non-related ﬁles from other vendors (in green).

Those ﬁndings are reported as CVE-2013-5637 and
CVE-2013-5638. We were also able to conﬁrm this vul-
nerability and extend the list of affected versions for one
of these vendors.

Such manual vulnerability conﬁrmation does not
scale. Hence, in the future we plan to integrate static ana-
lysis tools for web applications [30, 11, 53, 38, 1] in our
process.

6 Ethical Discussion

Large-scale scans to test for the presence of vulnerabil-
ities often raise serious ethical concerns. Even simple
Internet-wide network scans may trigger alerts from in-
trusion detection systems (IDS) and may be perceived as
an attack by the scanned networks.

Figure 5: Fuzzy hash clustering and vulnerability propagation. A vul-
nerability was propagated from a seed ﬁle (*) to other two ﬁles from
the same ﬁrmware and three ﬁles from the same vendor (in red) as well
as one ﬁle from another vendor (in orange). Also four non-vulnerable
ﬁles (in green) have a strong correlation with vulnerable ﬁles. Edge
thickness displays the strength of correlation between ﬁles.

In our study we were particularly careful to work
within legal and ethical boundaries. First, we obtain ﬁrm-
ware images either through user submission or through
legitimate distribution mechanisms. In this case, our web
crawler was designed to obey the robots.txt direc-
tives. Second, when we found new vulnerabilities we
worked together with vendors and CERTs to conﬁrm the
devices vulnerabilities and to perform responsible dis-
closure. Finally, the license of some ﬁrmware images
may not allow redistribution. Therefore, the public web
submission interface limits the ability to access ﬁrm-
ware contents only to the users who uploaded the cor-
responding ﬁrmware image. Other users can only access
anonymized reports. We are currently investigating ways
to make the full dataset available for research purposes
to well identiﬁed research institutions.

7 Related Work

Several studies have been proposed to asses the secu-
rity of embedded devices by scanning the Internet. For
instance, Cui et al. [28, 29] present a wide-scale In-
ternet scan to ﬁrst recognize devices that are known
to be shipped with default password, and then to con-
ﬁrm that these devices are indeed still vulnerable by at-
tempting to login into them. Heninger et al. [46] per-
formed the largest ever network survey of TLS and SSH
servers, showing that vulnerable keys are surprisingly
widespread and that the vast majority appear to belong to
headless or embedded devices. ZMap [37] is an efﬁcient
and fast network scanner, that allows to scan the com-
plete Internet IPv4 address space in less than one hour.
While the scans are not especially targeted to embed-
ded devices, in our work we reuse the SSL certiﬁcates

106  23rd USENIX Security Symposium 

USENIX Association

scans performed by ZMap [36]. Similar scans were tar-
geting speciﬁc vulnerabilities often present in embedded
devices [40, 4]. Such wide-scale scans are mainly tar-
geted at discovering online devices affected by already
known vulnerabilities, but in some cases they can help to
discover new ﬂaws. However, many categories of ﬂaws
cannot be discovered by such scans. Some online ser-
vices like Shodan [5] provide a global updated view on
publicly available devices and web services. This easy-
to-use research tool allows security researchers to iden-
tify systems worldwide that are potentially exposed or
exploitable.

Unpacking ﬁrmware images is a known problem, and
several tools for this purpose exist. Binwalk [41] is a
ﬁrmware analysis toolbox that provides various methods
and tools for extraction, inspection and reverse engineer-
ing of ﬁrmware images or other binary blobs. FRAK [26]
is a framework to unpack, analyze, and repack ﬁrmware
images of embedded devices. FRAK was never publicly
released and reportedly supports only a few ﬁrmware for-
mats (e.g., Cisco IP phones and IOS, HP laser printers).
The Binary Analysis Toolkit (BAT) [45, 66] was origi-
nally designed to detect GPL license violations, mainly
by comparing strings in a ﬁrmware image to strings
present in open source software distributions. For this
purpose BAT has to unpack ﬁrmware images. Unfortu-
nately, as we show in Section 3, none of these tools are
accurate and complete enough to be used as is in our
framework.

There are many examples of security analysis of em-
bedded systems [71]. Several network card ﬁrmware im-
ages have been analyzed and modiﬁed to insert a back-
door [33, 34] or to extend their functionality [16]. David-
son et al. [31] propose FIE, built on top of the KLEE sym-
bolic execution engine, to incorporate new symbolic exe-
cution techniques. It can be used to verify security prop-
erties of some simple ﬁrmware images often found in
practice. Zaddach et al. [70] describe Avatar, a dynamic
analysis platform for ﬁrmware security testing. In Avatar,
the instructions are executed in an emulator, while the IO
accesses to the embedded system’s peripherals are for-
warded to the real device. This allows a security engi-
neer to apply a wide range of advanced dynamic analysis
techniques like tracing, tainting and symbolic execution.
A large set of ﬁrmware images of Xerox devices were
reverse-engineered by Costin [24] leading to the discov-
ery of hidden PostScript commands. Such commands al-
low an attacker to e.g., dump a device’s memory, recover
passwords, passively scan the network and more generi-
cally interact with devices’ OS layers. Such attacks could
be delivered to printers via web pages, applets, MS Word
and other standard printed documents [23].

Bojinov et al. [18] conducted an assessment of the se-
curity of current embedded management interfaces. The

study, conducted on real physical devices, found vulner-
abilities in 21 devices from 16 different brands, includ-
ing network switches, cameras, photo frames, and lights-
out management modules. Along with these, a new class
of vulnerabilities was discovered, namely cross-channel
scripting (XCS) [17]. While XCS vulnerabilities are not
particular to embedded devices, embedded devices are
probably the most affected population. In a similar study,
the authors manually analyzed ten Small Ofﬁce/Home
Ofﬁce (SOHO) routers [48] and discovered at least two
vulnerabilities per device.

Looking at insecure (remote) ﬁrmware updates, re-
searchers reported the possibility to arbitrarily in-
ject malware into the ﬁrmware of a printer [24, 27].
Chen [22] and Miller [58] presented techniques and im-
plications of exploiting Apple ﬁrmware updates. In a
similar direction, Basnight et al. [12] examined the vul-
nerability of PLCs to intentional ﬁrmware modiﬁcations.
A general ﬁrmware analysis methodology is presented,
and an experiment demonstrates how legitimate ﬁrmware
can be updated on an Allen-Bradley ControlLogix L61
PLC. Zaddach et al. [72] explore the consequences of a
backdoor injection into the ﬁrmware of a hard disk drive
and uses it to exﬁltrate data.

French and Casey [13] present fuzzy hashing tech-
niques in applied malware analysis. Authors used
ssdeep on CERT Artifact Catalog database containing
10.7M ﬁles. The study underlines the two fundamental
challenges to operational usage of fuzzy hashing at scale:
timeliness of results, and usefulness of results. To reduce
the quadratic complexity of the comparisons, they pro-
pose assigning ﬁles into “bins” based on the block and
ﬁle sizes. This approach, for their particular dataset and
bins partitioning strategy, allowed for a given fuzzy hash
to reduce the search space on average by 83.1%.

Finally, Bailey et al. [10] and Bayer et al. [14] propose
efﬁcient clustering approaches to identify and group mal-
ware samples at large scale. Authors perform dynamic
analysis to obtain the execution traces of malware pro-
grams or obtain a description of malware behavior in
terms of system state changes. These are then general-
ized into behavioral proﬁles which serve as input to an
efﬁcient clustering algorithm that allows authors to han-
dle sample sets that are an order of magnitude larger than
previous approaches. Unfortunately, this approach can-
not be applied in our framework since dynamic analysis
is unfeasible due to the heterogeneity of architectures
used in ﬁrmware images.

8 Conclusion

In this paper we conducted a large-scale static analysis
of embedded ﬁrmwares. We showed that a broader view
on ﬁrmware is not only beneﬁcial, but actually necessary

USENIX Association  

23rd USENIX Security Symposium  107

for discovering and analyzing vulnerabilities of embed-
ded devices. Our study helps researchers and security an-
alysts to put the security of particular devices in context,
and allows them to see how known vulnerabilities that
occur in one ﬁrmware reappear in the ﬁrmware of other
manufacturers.

We plan to continue collecting new data and extend
our analysis to all the ﬁrmware images we downloaded
so far. Moreover, we want to extend our system with
more sophisticated static analysis techniques that allow
a more in-depth study of each ﬁrmware image. This ap-
proach shows a lot of potential and besides the few pre-
viously mentioned case studies it can lead to new inter-
esting results such as the ones recently found by Costin
et al. [25].

The

are
http://firmware.re/usenixsec14.

summarized

datasets

available

at

Acknowledgments

We thank the anonymous reviewers for their many sug-
gestions for improving this paper. In particular we thank
our shepherd, Cynthia Sturton, for her valuable time and
inputs guiding this paper for publication. We also thank
Pietro Michiardi and Daniele Venzano for providing ac-
cess and support to their cloud infrastructure, and John
Matherly of Shodan search engine for providing direct
access to Shodan’s data and resources.

The research leading to these results was partially
funded by the European Union Seventh Framework Pro-
gramme (contract Nr 257007 and project FP7-SEC-
285477-CRISALIS).

References

[1] Audit PHP Conﬁguration Security Toolkit.
[2] Deﬁne
DI-524
https://gist.github.com/ccpz/6960941.

in
source

backdoor

string

GPL

UP

of

DLink
code.

[3] Google Custom Search Engine API.
[4] Internet Census

2012

using

scanning
devices.
/0
http://internetcensus2012.bitbucket.org.
Engine.

Port
embedded

Computer

insecure

Search

–

–

[5] SHODAN

http://www.shodanhq.com.

[6] IEEE Standard Glossary of Software Engineering
Terminology. IEEE Std 610.12-1990, pages 1–84,
1990.

[7] Slashdot: Backdoor found in TP-Link routers,

March 2013.

[8] Download

statistics

for

the wemo

droid
http://xyo.net/android-app/wemo-JJUZgf8/.

application,

February

an-
2014.

the

statistics

application,

[9] Download

for
February

wemo
iOS
2014.
http://xyo.net/iphone-app/wemo-J1QNimE/.
[10] M. Bailey, J. Oberheide, J. Andersen, Z. M. Mao,
F. Jahanian, and J. Nazario. Automated Classiﬁ-
cation and Analysis of Internet Malware. In Pro-
ceedings of the 10th International Conference on
Recent Advances in Intrusion Detection, RAID’07,
pages 178–197, Berlin, Heidelberg, 2007. Springer-
Verlag.

[11] D. Balzarotti, M. Cova, V. Felmetsger, N. Jo-
vanovic, E. Kirda, C. Kruegel, and G. Vigna. Saner:
Composing Static and Dynamic Analysis to Vali-
date Sanitization in Web Applications. In Proceed-
ings of the 2008 IEEE Symposium on Security and
Privacy, SP ’08, pages 387–401, Washington, DC,
USA, 2008. IEEE Computer Society.

[12] Z. Basnight, J. Butts, J. L. Jr., and T. Dube. Firm-
ware modiﬁcation attacks on programmable logic
controllers.
International Journal of Critical In-
frastructure Protection, 6(2):76 – 84, 2013.

[13] L. Bass, N. Brown, G. M. Cahill, W. Casey,
S. Chaki, C. Cohen, D. de Niz, D. French,
A. Gurﬁnkel, R. Kazman, et al. Results of CMU
SEI Line-Funded Exploratory New Starts Projects.
2012.

[14] U. Bayer, P. M. Comparetti, C. Hlauschek,
Scalable, Behavior-
C. Kruegel, and E. Kirda.
Based Malware Clustering.
In Proceedings of
the 16th Symposium on Network and Distributed
System Security, NDSS ’09. The Internet Society,
2009.

In Proceedings of

[15] U. Bayer, I. Habibi, D. Balzarotti, E. Kirda, and
C. Kruegel. A View on Current Malware Be-
haviors.
the 2nd USENIX
Conference on Large-scale Exploits and Emer-
gent Threats: Botnets, Spyware, Worms, and More,
LEET’09, pages 8–8, Berkeley, CA, USA, 2009.
USENIX Association.

[16] A. Blanco and M. Eissler. One ﬁrmware to moni-

tor’em all. Ekoparty, 2012.

[17] H. Bojinov, E. Bursztein, and D. Boneh. Xcs: Cross
channel scripting and its impact on web applica-
tions. In Proceedings of the 16th ACM Conference
on Computer and Communications Security, CCS
’09, pages 420–431, New York, NY, USA, 2009.
ACM.

[18] H. Bojinov, E. Bursztein, E. Lovett, and D. Boneh.
Embedded management interfaces: Emerging mas-
sive insecurity. BlackHat USA, 2009.

[19] J.-Y. L. Boudec. Performance Evaluation of Com-
puter and Communication Systems. EFPL Press,
2011.

[20] S. Chakradeo, B. Reaves, P. Traynor, and W. Enck.
MAST: Triage for Market-scale Mobile Malware

108  23rd USENIX Security Symposium 

USENIX Association

Analysis. In Proceedings of the Sixth ACM Confer-
ence on Security and Privacy in Wireless and Mo-
bile Networks, WiSec ’13, pages 13–24, New York,
NY, USA, 2013. ACM.

[21] S. Checkoway, D. McCoy, B. Kantor, D. Anderson,
H. Shacham, S. Savage, K. Koscher, A. Czeskis,
F. Roesner, and T. Kohno. Comprehensive exper-
imental analyses of automotive attack surfaces. In
Proceedings of the 20th USENIX Conference on
Security, SEC’11, pages 6–6, Berkeley, CA, USA,
2011. USENIX Association.

[22] K. Chen. Reversing and exploiting an Apple ﬁrm-

ware update. BlackHat USA, 2009.

[23] A. Costin. Hacking Printers for Fun and Proﬁt.
[24] A. Costin. PostScript(um): You’ve Been Hacked.
[25] A. Costin and A. Francillon. Short Paper: A Dan-
gerous ’Pyrotechnic Composition’: Fireworks, Em-
bedded Wireless and Insecurity-by-Design. In Pro-
ceedings of the ACM Conference on Security and
Privacy in Wireless and Mobile Networks (WiSec),
WiSec ’14. ACM, 2014.

[26] A. Cui. Embedded Device Firmware Vulnerability

Hunting with FRAK. DefCon 20, 2012.

[27] A. Cui, M. Costello, and S. J. Stolfo. When Firm-
ware Modiﬁcations Attack: A Case Study of Em-
bedded Exploitation.
In Proceedings of the 20th
Symposium on Network and Distributed System Se-
curity, NDSS ’13. The Internet Society, 2013.

[28] A. Cui, Y. Song, P. V. Prabhu, and S. J. Stolfo.
Brave New World: Pervasive Insecurity of Em-
bedded Network Devices.
In Proceedings of the
12th International Symposium on Recent Advances
in Intrusion Detection, RAID ’09, pages 378–380,
Berlin, Heidelberg, 2009. Springer-Verlag.

[29] A. Cui and S. J. Stolfo. A Quantitative Analysis
of the Insecurity of Embedded Network Devices:
Results of a Wide-area Scan.
In Proceedings of
the 26th Annual Computer Security Applications
Conference, ACSAC ’10, pages 97–106, New York,
NY, USA, 2010. ACM.

[30] J. Dahse and T. Holz. Simulation of Built-in PHP
Features for Precise Static Code Analysis. In Pro-
ceedings of the 21st Symposium on Network and
Distributed System Security, NDSS ’14. The Inter-
net Society, 2014.

[31] D. Davidson, B. Moench, S. Jha, and T. Risten-
part. FIE on Firmware: Finding Vulnerabilities in
Embedded Systems Using Symbolic Execution. In
Proceedings of the 22nd USENIX Conference on
Security, SEC’13, pages 463–478, Berkeley, CA,
USA, 2013. USENIX Association.

[32] J. Dean and S. Ghemawat. MapReduce: Simpliﬁed
Data Processing on Large Clusters. In Proceedings
of the 6th Conference on Symposium on Opeart-

ing Systems Design & Implementation - Volume 6,
OSDI’04, pages 10–10, Berkeley, CA, USA, 2004.
USENIX Association.

[33] G. Delugr´e. Closer to metal: reverse-engineering
the Broadcom NetExtreme’s ﬁrmware. Hack.lu,
2010.

[34] L. Duﬂot, Y.-A. Perez, and B. Morin. What if
You Can’T Trust Your Network Card?
In Pro-
ceedings of the 14th International Conference on
Recent Advances in Intrusion Detection, RAID’11,
pages 378–397, Berlin, Heidelberg, 2011. Springer-
Verlag.

[35] K. Dunham. A fuzzy future in malware research.

The ISSA Journal, 11(8):17–18, 2013.

[36] Z. Durumeric, J. Kasten, M. Bailey, and J. A. Hal-
derman. Analysis of the HTTPS Certiﬁcate Ecosys-
tem.
In Proceedings of the 2013 Conference on
Internet Measurement Conference, IMC ’13, pages
291–304, New York, NY, USA, 2013. ACM.

[37] Z. Durumeric, E. Wustrow, and J. A. Halderman.
ZMap: Fast Internet-wide Scanning and Its Security
Applications. In Proceedings of the 22nd USENIX
Conference on Security, SEC’13, pages 605–620,
Berkeley, CA, USA, 2013. USENIX Association.

[38] B. Eshete, A. Villaﬁorita, and K. Weldemariam.
Early Detection of Security Misconﬁguration Vul-
nerabilities in Web Applications.
In Proceed-
ings of the 2011 Sixth International Conference
on Availability, Reliability and Security, ARES
’11, pages 169–174, Washington, DC, USA, 2011.
IEEE Computer Society.

[39] B. Gourdin, C. Soman, H. Bojinov,

and
Toward Secure Embedded Web
E. Bursztein.
Interfaces.
In Proceedings of the 20th USENIX
Conference on Security, SEC’11, pages 2–2,
Berkeley, CA, USA, 2011. USENIX Association.

[40] HDMoore. Security Flaws in Universal Plug and

Play: Unplug, Don’t Play, 2013.

[41] C. Heffner. binwalk – ﬁrmware analysis tool de-
signed to assist in the analysis, extraction, and re-
verse engineering of ﬁrmware images.

[42] C. Heffner. littleblackbox – Database of private SS-

L/SSH keys for embedded devices.

[43] C. Heffner. Breaking SSL on Embedded Devices,

December 2010.

[44] C. Heffner. Reverse Engineering a D-Link Back-

door, October 2013.

[45] A. Hemel, K. T. Kalleberg, R. Vermaas, and E. Dol-
stra. Finding Software License Violations Through
Binary Code Clone Detection.
In Proceedings of
the 8th Working Conference on Mining Software
Repositories, MSR ’11, pages 63–72, New York,
NY, USA, 2011. ACM.

[46] N. Heninger, Z. Durumeric, E. Wustrow, and J. A.

USENIX Association  

23rd USENIX Security Symposium  109

Halderman. Mining Your Ps and Qs: Detection
of Widespread Weak Keys in Network Devices.
In Proceedings of the 21st USENIX Conference
on Security Symposium, Security’12, pages 35–35,
Berkeley, CA, USA, 2012. USENIX Association.

[47] J. Hirsch and K. Bensinger. Toyota settles acceler-
ation lawsuit after $3-million verdict. Los Angeles
Times, October 25, 2013.

[48] Independent Security Evaluators. SOHO Network

Equipment (Technical Report), 2013.

[49] IOActive. Critical DASDEC Digital Alert Systems

(DAS) Vulnerabilities, June 2013.

[50] IOActive.

stringﬁghter – Identify Backdoors in
Firmware By Using Automatic String Analysis,
May 2013.

[51] IOActive. Critical Belkin WeMo Home Automa-

tion Vulnerabilities, February 2014.

[52] J. Jang, D. Brumley, and S. Venkataraman. Bit-
Shred: Feature Hashing Malware for Scalable
Triage and Semantic Analysis. In Proceedings of
the 18th ACM Conference on Computer and Com-
munications Security, CCS ’11, pages 309–320,
New York, NY, USA, 2011. ACM.

[53] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A
Static Analysis Tool for Detecting Web Application
Vulnerabilities (Short Paper). In Proceedings of the
2006 IEEE Symposium on Security and Privacy, SP
’06, pages 258–263, Washington, DC, USA, 2006.
IEEE Computer Society.

[54] J. Kornblum.

Identifying Almost Identical Files
Using Context Triggered Piecewise Hashing. Digit.
Investig., 3:91–97, 2006.

[55] K. Koscher, A. Czeskis, F. Roesner, S. Patel,
T. Kohno, S. Checkoway, D. McCoy, B. Kantor,
D. Anderson, H. Shacham, and S. Savage. Experi-
mental Security Analysis of a Modern Automobile.
In Proceedings of the 2010 IEEE Symposium on Se-
curity and Privacy, SP ’10, pages 447–462, Wash-
ington, DC, USA, 2010. IEEE Computer Society.

[56] E. Lindholm, J. Nickolls, S. Oberman, and J. Mon-
trym. NVIDIA Tesla: A Uniﬁed Graphics and
Computing Architecture. IEEE Micro, 2008.

[57] P. C. Messina, R. D. Williams, and G. C. Fox. Par-
allel computing works ! Parallel processing scien-
tiﬁc computing. Morgan Kaufmann, San Francisco,
CA, 1994.

[58] C. Miller. Battery ﬁrmware hacking. BlackHat

USA, 2011.

[59] Nvidia. CUDA – Compute Uniﬁed Device Archi-

tecture Programming Guide. 2007.

[60] OpenwallProject.

John the Ripper password

cracker. http://www.openwall.com/john/.

[61] OWASP. Top 10 Vulnerabilities, 2013.
[62] V. Roussev. Data Fingerprinting with Similarity Di-
gests. In IFIP Int. Conf. Digital Forensics, pages
207–226, 2010.

[63] F. Schuster and T. Holz. Towards reducing the at-
tack surface of software backdoors.
In Proceed-
ings of the 20th ACM Conference on Computer and
Communications Security, CCS ’13, pages 851–
862, New York, NY, USA, 2013. ACM.

[64] S. Skorobogatov and C. Woods. Breakthrough sili-
con scanning discovers backdoor in military chip.
In Proceedings of the 14th International Confer-
ence on Cryptographic Hardware and Embedded
Systems, CHES’12, pages 23–40, Berlin, Heidel-
berg, 2012. Springer-Verlag.

[65] J. V. Stough.

distributed-python-for-scripting –

DistributedPython for Easy Parallel Scripting.

[66] Tjaldur Software Governance Solutions. Binary

Analysis Tool (BAT).

[67] A. Tridgell. rsync – utility that provides fast incre-

mental ﬁle transfer.

[68] D. A. Wheeler. SLOCCount – a set of tools for
counting physical Source Lines of Code (SLOC).
http://www.dwheeler.com/sloccount/.

[69] xobs and bunnie. The Exploration and Exploitation

of an SD Memory Card. CCC – 30C3, 2013.
[70] J. Zaddach, L. Bruno, A. Francillon,

and
D. Balzarotti. Avatar: A Framework to Sup-
port Dynamic Security Analysis of Embedded
Systems’ Firmwares.
In Proceedings of the 21st
Symposium on Network and Distributed System
Security, NDSS ’14. The Internet Society, 2014.

[71] J. Zaddach and A. Costin. Embedded Devices Se-
curity and Firmware Reverse Engineering. Black-
Hat USA, 2013.

[72] J. Zaddach, A. Kurmus, D. Balzarotti, E.-O. Blass,
A. Francillon, T. Goodspeed, M. Gupta, and I. Kolt-
sidas. Implementation and Implications of a Stealth
Hard-drive Backdoor. In Proceedings of the 29th
Annual Computer Security Applications Confer-
ence, ACSAC ’13, pages 279–288, New York, NY,
USA, 2013. ACM.

110  23rd USENIX Security Symposium 

USENIX Association

