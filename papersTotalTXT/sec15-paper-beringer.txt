Verified Correctness and Security  

of OpenSSL HMAC

Lennart Beringer, Princeton University; Adam Petcher, Harvard University and MIT Lincoln 

Laboratory; Katherine Q. Ye and Andrew W. Appel, Princeton University

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/beringer

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXVeriﬁed correctness and security of OpenSSL HMAC

Lennart Beringer
Princeton Univ.

Adam Petcher

Harvard Univ. and

MIT Lincoln Laboratory

Katherine Q. Ye
Princeton Univ.

Andrew W. Appel
Princeton Univ.

Abstract
We have proved, with machine-checked proofs in Coq,
that an OpenSSL implementation of HMAC with SHA-
256 correctly implements its FIPS functional speciﬁ-
cation and that its functional speciﬁcation guarantees
the expected cryptographic properties.
This is the
ﬁrst machine-checked cryptographic proof that combines
a source-program implementation proof, a compiler-
correctness proof, and a cryptographic-security proof,
with no gaps at the speciﬁcation interfaces.

The veriﬁcation was done using three systems within
the Coq proof assistant:
the Foundational Cryptogra-
phy Framework, to verify crypto properties of functional
specs; the Veriﬁed Software Toolchain, to verify C pro-
grams w.r.t. functional specs; and CompCert, for veriﬁed
compilation of C to assembly language.

1

Introduction

HMAC is a cryptographic authentication algorithm, the
“Keyed-Hash Message Authentication Code,” widely
used in conjunction with the SHA-256 cryptographic
hashing primitive. The sender and receiver of a mes-
sage m share a secret session key k. The sender com-
putes s = HMAC(k,m) and appends s to m. The receiver
computes s(cid:31) = HMAC(k,m) and veriﬁes that s(cid:31) = s. In
principle, a third party will not know k and thus cannot
compute s. Therefore, the receiver can infer that message
m really originated with the sender.

What could go wrong?

Algorithmic/cryptographic problems. The compres-
sion function underlying SHA might fail to have
the cryptographic property of being a pseudoran-
dom function (PRF); the SHA algorithm might not
be the right construction over its compression func-
tion; the HMAC algorithm might fail to have the
cryptographic property of being a PRF; we might
even be considering the wrong crypto properties.

Implementation problems. The SHA program (in C)
might incorrectly implement the SHA algorithm;
the HMAC program might incorrectly implement
the HMAC algorithm; the programs might be cor-
rect but permit side channels such as power analy-
sis, timing analysis, or fault injection.

Speciﬁcation mismatch. The speciﬁcation of HMAC
or SHA used in the cryptographic-properties [15]
proof might be subtly different from the one pub-
lished as the speciﬁcation of computer programs
[28, 27]. The proofs about C programs might in-
terpret the semantics of the C language differently
from the C compiler.

Based on Bellare and Rogaway’s probabilistic game
framework [16] for cryptographic proofs, Halevi [30] ad-
vocates creating an “automated tool to help us with the
mundane parts of writing and checking common argu-
ments in [game-based] proofs.” Barthe et al. [13] present
such a tool in the form of CertiCrypt, a framework that
“enables the machine-checked construction and veriﬁca-
tion” of proofs using the same game-based techniques,
written in code. Barthe et al.’s more recent EasyCrypt
system [12] is a more lightweight, user-friendly version
(but not foundational, i.e., the implementation is not
proved sound in any machine-checked general-purpose
logic). In this paper we use the Foundational Cryptogra-
phy Framework (FCF) of Petcher and Morrisett [38].

But the automated tools envisioned by Halevi—and
built by Barthe et al. and Petcher—address only the
“algorithmic/cryptographic problems.” We also need
machine-checked tools for functional correctness of C
programs—not just static analysis tools that verify the
absence of buffer overruns. And we need the functional-
correctness tools to connect, with machine-checked
proofs of equivalence, to the crypto-algorithm proofs. By
2015, proof systems for formally reasoning about crypto
algorithms and C programs have come far enough that it
is now possible to do this.

USENIX Association  

24th USENIX Security Symposium  207

15. HMAC cryptographic

security property

14. SHA cryptographic

security property

16.    Crypto security

proof

(nobody knows 

  how to prove this)

3. Bellare HMAC functional spec

4.    Equivalence

Proof

1. SHA functional spec 2. FIPS HMAC functional spec

10. SHA API spec

11.    Correctness

Proof

sha.c

12. HMAC API spec
13.    Correctness

Proof
hmac.c

Bold face

indicates new

results in 
this paper

End-to-End

machine-checked
crypto-security
+ implementation

proof

5.  Verifiable C
program logic

7.    Soundness   

Proof

6. C operational

semantics

9.    Correctness

Proof

8. Intel IA-32

operational semantics

CompCert 

verified optimizing 

C compiler

Figure 1: Architecture
of our assurance case.

sha.s

hmac.s

Here we present machine-checked proofs, in Coq, of
many components, connected and checked at their speci-
ﬁcation interfaces so that we get a truly end-to-end result:
Version 0.9.1c of OpenSSL’s HMAC and SHA-256 cor-
rectly implements the FIPS 198-1 and FIPS 180-4 stan-
dards, respectively; and that same FIPS 198-1 HMAC
standard is a PRF, subject to certain standard (unproved)
assumptions about the SHA-256 algorithm that we state
formally and explicitly.

Software is large, complex, and always under main-
tenance; if we “prove” something about a real program
then the proof (and its correspondence to the syntactic
program) had better be checked by machine. Fortunately,
as G¨odel showed, checking a proof is a simple calcula-
tion. Today, proof checkers can be simple trusted (and
trustworthy) kernel programs [7].

A proof assistant comprises a proof-checking kernel
with an untrusted proof-development system. The sys-
tem is typically interactive, relying on the user to build
the overall structure of the proof and supply the impor-
tant invariants and induction hypotheses, with many of
the details ﬁlled in by tactical proof automation or by de-
cision procedures such as SMT or Omega.

Coq is an open-source proof assistant under develop-
ment since 1984. In the 21st century it has been used for
practical applications such as Leroy’s correctness proof
of an optimizing C compiler [34]. But note, that com-
piler was not itself written in C; the proof theory of C
makes life harder, and only more recently have people

done proofs of substantial C programs in proof assistants
[32, 29].

Our entire proof (including the algorithmic/crypto-
graphic proofs, the implementation proofs, and the spec-
iﬁcation matches) is done in Coq, so that we avoid mis-
understandings at interfaces. To prove our main theorem,
we took these steps (cf. Figure 1):

1. Formalized.[5] We use a Coq formalization of the
FIPS 180-4 Secure Hash Standard [28] as a speci-
ﬁcation of SHA-256. (Henceforth, “formalized” or
“proved” implies “in the Coq proof assistant.”)

2. Formalized.* We have formalized the FIPS 198-1
Keyed-Hash Message Authentication Code [27] as
a speciﬁcation of HMAC. (Henceforth, the * indi-
cates new work ﬁrst reported in this paper; other-
wise we provide a citation to previous work.)

3. Formalized.* We have formalized Bellare’s func-

tional characterization of the HMAC algorithm.

4. Proved.* We have proved the equivalence of FIPS
198-1 with Bellare’s functional characterization of
HMAC.

5. Formalized.[6] We use Veriﬁable C, a program logic
(embedded in Coq) for specifying and proving func-
tional correctness of C programs.

6. Formalized.[35] Leroy has formalized the opera-

tional semantics of the C programming language.

208  24th USENIX Security Symposium 

USENIX Association

7. Proved.[6] Veriﬁable C has been proved sound.
That is, if you specify and prove any input-output
property of your C program using Veriﬁable C, then
that property actually holds in Leroy’s operational
semantics of the C language.

8. Formalized.[35] Leroy has formalized the opera-
tional semantics of the Intel x86 (and PowerPC and
ARM) assembly language.

9. Proved.[35] If the CompCert optimizing C compiler
translates a C program to assembly language, then
input-output property of the C program is preserved
in the assembly-language program.

10. Formalized.[5] We rely on a formalization (in Ver-
iﬁable C) of the API interface of the OpenSSL
header ﬁle for SHA-256,
including its semantic
connection to the formalization of the FIPS Secure
Hash Standard.

11. Proved.[5] The C program implementing SHA-256,
lightly adapted from the OpenSSL implementation,
has the input-output (API) properties speciﬁed by
the formalized API spec of SHA-256.

12. Formalized.* We have formalized the API interface
of the OpenSSL header ﬁle for HMAC, including
its semantic connection to our FIPS 198-1 formal-
ization.

13. Proved.* Our C program implementing HMAC,
lightly adapted from the OpenSSL implementation,
has the input-output (API) properties speciﬁed by
our formalization of FIPS 198-1.

14. Formalized.* Bellare et al. proved properties of
HMAC [15, 14] subject
to certain assumptions
about the underlying cryptographic compression
function (typically SHA). We have formalized those
assumptions.

15. Formalized.* Bellare et al.

proved that HMAC
implements a pseudorandom function (PRF); we
have formalized what exactly that means. (Bellare’s
work is “formal” in the sense of rigorous mathe-
matics and LATEX; we formalized our work in Coq
so that proofs of these properties can be machine-
checked.)

16. Proved.* We prove that, subject to these formal-
ized assumptions about SHA, Bellare’s HMAC al-
gorithm is a PRF; this is a mechanization of a vari-
ant of the 1996 proof [15] using some ideas from
the 2006 proofs [14].

Theorem. The assembly-language program, resulting
from compiling OpenSSL 0.9.1c using CompCert, cor-
rectly implements the FIPS standards for HMAC and
SHA, and implements a cryptographically secure PRF
subject to the usual assumptions about SHA.
Proof. Machine-checked, in Coq, by chaining together
speciﬁcations and proofs 1–16. Available open-source at
https://github.com/PrincetonUniversity/VST/, subdi-
rectories sha, fcf, hmacfcf.

The trusted code base (TCB) of our system is quite
small, comprising only items 1, 2, 8, 12, 14, 15. Items
4, 7, 9, 11, 13, 16 need not be trusted, because they are
proofs checked by the kernel of Coq. Items 3, 5, 6, 10
need not be trusted, because they are speciﬁcation inter-
faces checked on both sides by Coq, as Appel [5, §8]
explains.
One needs to trust the Coq kernel and the software that

compiles it; see Appel’s discussion [5, §12].
We do not analyze timing channels or other side chan-
nels. But the programs we prove correct are standard
C programs for which standard timing and side-channel
analysis tools and techniques can be used.

The HMAC brawl. Bernstein [19] and Koblitz and
Menezes [33] argue that the security guarantees proved
by Bellare et al. are of little value in practice, because
these guarantees do not properly account for the power
of precomputation by the adversary. In effect, they argue
that item 15 in our enumeration is the wrong speciﬁca-
tion for desired cryptographic properties of a symmetric-
key authentication algorithm. This may well be true; here
we use Bellare’s speciﬁcation in a demonstration of end-
to-end machine-checked proof. As improved speciﬁca-
tions and proofs are developed by the theorists, we can
implement them using our tools. Our proofs are sufﬁ-
ciently modular that only items 15 and 16 would change.

version

of OpenSSL. We

Which
veriﬁed
HMAC/SHA from OpenSSL 0.9.1c, dated March
1999, which does not include the home-brew object sys-
tem “engines” of more recent versions of OpenSSL. We
further simpliﬁed the code by specializing OpenSSL’s
use of generic “envelopes” to the speciﬁc hash function
SHA-256,
thus obtaining a statically linked code.
Veriﬁable C is capable of reasoning about function
pointers and home-brew object systems [6, Chapter
29]—it is entirely plausible that a formal speciﬁcation of
“engines” and “envelopes” could be written down—but
such proofs are more complex.

USENIX Association  

24th USENIX Security Symposium  209

2 Formalizing functional speciﬁcations

(Items 1, 2 of the architecture.) The FIPS 180-4 speciﬁ-
cation of the SHA function can be formalized in Coq as
this mathematical function:

Deﬁnition SHA-256 (str : list Z) : list Z :=

intlist-to-Zlist (

hash-blocks init-registers (generate-and-pad str)).
where hash-blocks, init-registers, and generate-and-pad
are translations of the FIPS standard. Z is Coq’s type
for (mathematical) integers; the (list Z) is the contents
of a string of bytes, considered as their integer values.
SHA-256 works internally in 32-bit unsigned modular
arithmetic; intlist-to-Zlist converts a sequence of 32-bit
machine ints to the mathematical contents of a byte-
sequence. See Appel [5] for complete details. The func-
tional spec of SHA-256, including deﬁnitions of all these
functions, comes to 169 lines of Coq, all of which is in
the trusted base for the security/correctness proof.

In this paper we show the full functional spec for
the HMAC construction applied to hash

HMAC256,
function SHA 256:

Deﬁnition mkKey (l:list Z):list Z :=
zeropad (if |l| > 64 then SHA-256 l else l).
Deﬁnition KeyPreparation (k: list Z):list byte :=
map Byte.repr (mkKey k).

Deﬁnition HASH l m := SHA-256 (l++m)
Deﬁnition HmacCore m k :=
HASH (opad ⊕ k) (HASH (ipad ⊕ k) m)
Deﬁnition HMAC256 (m k : list Z) : list Z :=
HmacCore m (KeyPreparation k)

where zeropad right-extends1 its argument to length 64
(i.e. to SHA256’s block size, in bytes), ipad and opad are
the padding constants from FIPS198-1, ⊕ denotes byte-
wise XOR, and ++ denotes list concatenation.

3 API speciﬁcations of C functions

(Items 10, 12 of the architecture.) Hoare logic [31], dat-
ing from 1969, is a method of proving correctness of im-
perative programs using preconditions, postconditions,
and loop invariants. Hoare’s original logic did not handle
pointer data structures well. Separation logic, introduced
in 2001 [37], is a variant of Hoare logic that encapsulates
“local actions” on data structures.

1The more recent RFC4868 mandates that when HMAC is used
for authentication, a ﬁxed key length equal to the output length of
the hash functions MUST be supported, and key lengths other than
the output length of the associated hash function MUST NOT be sup-
ported. Our speciﬁcation clearly separates KeyPreparation from
HmacCore, but at the top level follows the more permissive standards
RFC2104/FIPS198-1 as well as the implementation reality of even con-
temporary snapshots of OpenSSL and its clones.

Veriﬁable C [6] is a separation logic that applies to the
real C language. Veriﬁable C’s rules are complicated in
some places, to capture C’s warts and corner cases.

The FIPS 180 and FIPS 198 speciﬁcations—and our
deﬁnitions of SHA 256 and HMAC256—do not explain
how the “mathematical” sequences of bytes are laid out
in the arrays and structs passed as parameters to (and
used internally by) the C functions. For this we need an
API spec. Using Veriﬁable C, one speciﬁes the API be-
havior of each function: the data structures it operates on,
its preconditions (what it assumes about the input data
structures available in parameters and global variables),
and the postcondition (what it guarantees about its return
value and changes to data structures). Appel [5, §7] ex-
plains how to build such API specs and shows the API
spec for the SHA 256 function.

Here we show the API spec for HMAC. First we deﬁne

a Coq record type,

Record DATA := { LEN:Z; CONT: list Z }.
If key has type DATA, then LEN(key) is an integer and
CONT(key) is “contents” of the key, a sequence of inte-
gers. We do not use Coq’s dependent types here to en-
force that LEN corresponds to the length of the CONT
ﬁeld, but see the has lengthK constraint below.

To specify the API of a C-language function in Veriﬁ-

able C, one writes

DECLARE f WITH (cid:30)v

PRE[params] Pre POST [ret] Post.

where f is the name of the function, params are the for-
mal parameters (of various C-language types), and ret is
the C return type. The precondition Pre and postcondi-
tion Post have the form PROPP LOCALQ SEPR, where
P is a list of pure propositions (true independent of the
current program state), Q is a list of local/global variable
bindings, and R is a list of separation logic predicates that
describe the contents of memory. The WITH clause de-
scribes logical variables (cid:30)v, abstract mathematical values
that can be referred to anywhere in the precondition and
postcondition.

In our HMAC256-spec, shown below, the ﬁrst “ab-
stract mathematical value” listed in this WITH clause is
the key-pointer kp, whose “mathematical” type is “C-
language value’,’ or val.
It represents an address in
memory where the HMAC session key is passed. In the
LOCAL part of the PREcondition, we say that the formal
parameter -key actually contains the value kp on entry to
the function, and in the SEP part we say that there’s a
data-block at location kp containing the actual key bytes.
In the postcondition we refer to kp again, saying that the
data-block at address kp is still there, unchanged by the
HMAC function.

210  24th USENIX Security Symposium 

USENIX Association

Deﬁnition HMAC256-spec :=
DECLARE -HMAC
WITH kp: val, key:DATA, KV:val,

mp: val, msg:DATA, shmd: share, md: val

PRE [ -key OF tptr tuchar, -key-len OF tint,

-d OF tptr tuchar, -n OF tint,
-md OF tptr tuchar ]
PROP(writable share shmd;

has lengthK (LEN key) (CONT key);
has lengthD 512 (LEN msg) (CONT msg))
LOCAL(temp -md md; temp -key kp; temp -d mp;
temp -key-len (Vint (Int.repr (LEN key)));
temp -n (Vint (Int.repr (LEN msg)));
gvar -K256 KV)

SEP(`(data-block Tsh (CONT key) kp);
`(data-block Tsh (CONT msg) mp);
`(K-vector KV);
`(memory-block shmd (Int.repr 32) md))

POST [ tvoid ]

PROP() LOCAL()
SEP(`(K-vector KV);
`(data-block shmd

(HMAC256 (CONT msg) (CONT key)) md);

`(data-block Tsh (CONT key) kp);
`(data-block Tsh (CONT msg) mp)).

The next WITH value is key, a DATA value, that
is, a mathematical sequence of byte values along
In the PROP clause of
with its (supposed) length.
the precondition, we enforce this supposition with
has lengthK (LEN key) (CONT key).

The function Int.repr injects from the mathemati-
cal integers into 32-bit signed/unsigned numbers. So
temp -n (Vint (Int.repr (LEN msg))) means,
take the
mathematical integer (LEN msg), smash it into a 32-bit
signed number, inject that into the space of C values,
and assert that the parameter -n contains this value on
entry to the function. This makes reasonable sense if
0 ≤ LEN msg < 232, which is elsewhere enforced by
has lengthD. Such 32-bit range constraints are part of
C’s “warts and all,” which are rigorously accounted for
in Veriﬁable C. Both has lengthK and has lengthD are
user-deﬁned predicates within the HMAC API spec.

The precondition contains an uninitialized 32-byte
memory-block at address md, and the -md parameter of
the C function contains the value md. In the postcondi-
tion, we ﬁnd that at address md the memory block has
become an initialized data block containing a represen-
tation of HMAC256 (CONT msg) (CONT key).

For stating and proving these speciﬁcations, the fol-

lowing characteristics of separation logic are crucial:

1. The SEP lists are interpreted using the separat-
ing conjunction ∗ which (in contrast to ordinary
conjunction ∧) enforces disjointness of the mem-

ory regions speciﬁed by each conjunct. Thus,
the precondition requires—and the postcondition
guarantees—that keys, messages, and digests do not
overlap.

2. Implicit in the semantic interpretation of a separa-
tion logic judgment is a safety guarantee of the ab-
sence of memory violations and other runtime er-
rors, apart from memory exhaustion.
In particu-
lar, veriﬁed code is guaranteed to respect the spec-
iﬁed footprint: it will neither read from, nor mod-
ify or free any memory outside the region speci-
ﬁed by the SEP clause of PRE. Moreover, all heap
that is locally allocated is either locally freed, or is
accounted for in POST. Hence, memory leaks are
ruled out.

3. As a consequence of these locality principles, sep-
aration logic speciﬁcations enjoy a frame property:
a veriﬁed judgment remains valid whenever we add
an arbitrary additional separating conjunct to both
SEP-clauses. The corresponding proof rule, the
frame rule, is crucial for modular veriﬁcation, guar-
anteeing, for example, that when we call SHA-256,
the HMAC data structure remains unmodiﬁed.

The HMAC API spec has the 25 lines shown here
plus a few more for deﬁnitions of auxiliary predicates
(has-lengthK 3 lines, has-lengthD 3 lines, etc.); plus the
API spec for SHA-256, all in the trusted base.
Incremental hashing. OpenSSL’s HMAC and SHA
functions are incremental.
One can initialize the
hasher with a key, then incrementally append message-
fragments (not necessarily block-aligned) to be hashed,
then ﬁnalize to produce the message digest. We fully
support this incremental API in our correctness proofs.
For simplicity we did not present it here, but Appel [5]
presents the incremental API for SHA-256. The API
spec for fully incremental SHA-256 is 247 lines of Coq;
the simple (nonincremental) version has a much smaller
API spec, similar to the 25+6 lines shown here for the
nonincremental HMAC.
Once every function is speciﬁed, we use Veriﬁable C
to prove that each function’s body satisﬁes its speciﬁca-
tion. See Section 6.

4 Cryptographic properties of HMAC

(Items 14, 15, 16 of the architecture.) This section de-
scribes a mechanization of a cryptographic proof of se-
curity of HMAC. The ﬁnal result of this proof is similar
to the result of Bellare et al. [15], though the structure
of the proof and some of the deﬁnitions are inﬂuenced

USENIX Association  

24th USENIX Security Symposium  211

by Bellare’s later proof [14]. This proof uses a more ab-
stract model of HMAC (compared to the functional spec
in §2) in which keys are in {0,1}b (the set of bit vectors
of length b), inputs are in {0,1}∗ (bit lists), and outputs
are in {0,1}c for arbitrary b and c such that c ≤ b. An
implementation of HMAC would require that b and c are
multiples of some word size, and the input is an array
of words, but these issues are typically not considered in
cryptographic proofs.

In the context of the larger proof described in this pa-
per, we refer to this model of HMAC in which sizes are
arbitrary as the abstract speciﬁcation of HMAC. In or-
der to use security results related to this speciﬁcation, we
must show that this speciﬁcation is appropriately related
to the speciﬁcation provided in §2. We chose to prove the
security of the abstract speciﬁcation, rather than directly
proving the security of a more concrete speciﬁcation, be-
cause there is signiﬁcant value in this organization. Pri-
marily, this organization allows us to use the exact def-
initions and assumptions from the cryptography litera-
ture, and we therefore gain greater assurance that the def-
initions are correct and the assumptions are reasonable.
Also, this approach demonstrates how an existing mech-
anized proof of cryptographic security can be used in a
veriﬁcation of the security of an implementation. This
organization also helps decompose the proof, and it al-
lows us to deal with issues related to the implementation
in isolation from issues related to cryptographic security.
We address the “gap” between the abstract and con-
crete HMAC speciﬁcations by proving that they are
equivalent. Section 5 outlines the proof and states the
equivalence theorem.

4.1 The

Foundational

Framework

Cryptography

This proof of security was completed using the Founda-
tional Cryptography Framework (FCF), a Coq library for
reasoning about the security of cryptographic schemes
in the computational model [38]. FCF provides a proba-
bilistic programming language for describing all crypto-
graphic constructions, security deﬁnitions, and problems
that are assumed to be hard. Probabilistic programs are
described using Gallina, the purely functional program-
ming language of Coq, extended with a computational
monad that adds sampling uniformly random bit vectors.
The type of probabilistic computations that return values
of type A is Comp A. The code uses {0,1}ˆn to de-
scribe sampling a bit vector of length n. Arrows (<-$)
denote sequencing (i.e. bind) in the monad.

Listing 1 contains an example program implementing
a one-time pad on bit vectors of length c (for any natural
number c). The program produces a random bit vector
and stores it in p, then returns the xor (using the standard

Deﬁnition OTP c (x : Bvector c) : Comp (Bvector c)
:= p <-$ {0, 1}ˆc; ret (BVxor c p x)

Listing 1: Example Program: One-Time Pad.

Coq function BVxor) of p and the argument x.

The language of FCF has a denotational semantics that
relates programs to discrete, ﬁnite probability distribu-
tions. A distribution on type A is modeled as a function
in A → Q which should be interpreted as a probability
mass function. FCF provides a theory of distributions, a
program logic, and a library of tactics that can be used to
complete proofs without appealing directly to the seman-
tics. We can use FCF to prove that two distributions are
equivalent, that the distance between the probabilities of
two events is bounded by some value, or that the proba-
bility of some event is less than some value. Such claims
enable cryptographic proofs in the “sequence of games”
style [16].

In FCF, an oracle has

In some cryptographic deﬁnitions and proofs, an
adversary is allowed to interact with an “oracle”
that maintains state while accepting queries and pro-
viding responses.
type
S → A → Comp (B ∗ S) for types S, A, and B, of state,
input, and output, respectively. The OracleComp type is
provided to allow an adversary to interact with an oracle
without viewing or modifying its state. By combining
an OracleComp with an oracle and a value for the initial
state of the oracle, we obtain a computation returning a
pair of values, where the ﬁrst value is produced by the
OracleComp at the end of its interaction with the oracle,
and the second value is the ﬁnal state of the oracle.

4.2 HMAC Security
We mechanized a proof of the following fact. If h is a
compression function, and h∗ is a Merkle-Damg˚ard hash
function constructed from h, then HMAC based on h∗ is
a pseudorandom function (PRF) assuming:

1. h is a PRF.

2. h∗ is weakly collision-resistant (WCR).

3. The dual family of h (denoted ¯h) is a PRF against

⊕-related-key attacks.

The formal deﬁnition of a PRF is shown in Listing
2. In this deﬁnition, f is a function in K → D → R that
should be a PRF. That is, for a key k : K, an adversary
who does not know k cannot gain much advantage in
distinguishing f k from a random function in D → R.
The adversary A is an OracleComp that interacts with
either an oracle constructed from f or with randomFunc,

212  24th USENIX Security Symposium 

USENIX Association

a random function constructed by producing random val-
ues for outputs and memoizing them so they can be re-
peated the next time the same input is provided. The
randomFunc oracle uses a list of pairs as its state, so an
empty list is provided as its initial state. The value tt is
the “unit” value, where unit is a placeholder type much
like “void” in the C language. This deﬁnition uses alter-
native arrows (such as <-$2) to construct sequences in
which the ﬁrst computation produces a tuple, and a name
is given to each value in the tuple. The size of the tuple
is provided in the arrow in order to assist the parser.

Deﬁnition f-oracle (k : K) (x : unit) (d : D)

ret (f k d, tt).

: Comp (R × unit) :=

Deﬁnition PRF-G0 : Comp bool :=

k <-$ RndKey;
[b, -] <-$2 A (f-oracle k) tt; ret b.

Deﬁnition PRF-G1 : Comp bool :=

[b, -] <-$2 A (randomFunc) nil; ret b.

Deﬁnition PRF-Advantage : Rat :=

| Pr[PRF-G0] -Pr[PRF-G1] |.

Listing 2: Deﬁnition of a PRF. The f oracle function
wraps the function f (closed over key k) and turns it into
an oracle. A is an adversary. Comp bool is the type of
probabilistic computations that produce a bool. Rat is
the type of (unary, nonnegative) rational numbers.

This security deﬁnition is provided in the form of
a “game” in which the adversary tries to determine
whether the oracle is f (in game 0) or a random function
(in game 1). After interacting with the oracle, the adver-
sary produces a bit, and the adversary “wins” if this bit
is likely to be different in the games. We deﬁne the ad-
vantage of the adversary to be the difference between the
probability that it produces “true” in game 0 and in game
1. We can conclude that f is a PRF if this advantage is
sufﬁciently small.

Deﬁnition Adv-WCR-G : Comp bool :=

k <-$ RndKey;
[d1, d2, -] <-$3 A (f-oracle k) tt;
ret ((d1 != d2) && ((f k d1) ?= (f k d2))).

Deﬁnition Adv-WCR : Rat := Pr[Adv-WCR-G].

Listing 3: Deﬁnition of Weak Collision-Resistance.

Listing 3 deﬁnes a weakly collision-resistant function.
This deﬁnition uses a single game in which the adversary
is allowed to interact with an oracle deﬁned by a keyed
function f. At the end of this interaction, the adversary

attempts to produce a collision, or a pair of different in-
put values that produce the same output. In this game, we
use ?= and != to denote tests for equality and inequal-
ity, respectively. The advantage of the adversary is the
probability with which it is able to locate a collision.

Finally, the security proof assumes that a certain keyed
function is a PRF against ⊕-related-key attacks (RKA).
This deﬁnition (Listing 4) is similar to the deﬁnition of
a PRF, except the adversary is also allowed to provide a
value that will be xored with the unknown key before the
PRF is called. Note that this assumption is applied to the
dual family of h, in which the roles of inputs and keys are
reversed. So a single input value is chosen at random and
ﬁxed, and the adversary queries the oracle by providing
values which are used as keys.

Deﬁnition RKA-F (k: Bvector b) (s: unit)

(p: Bvector b × Bvector c)

: (Bvector c × unit) :=

ret (f ((fst p) xor k) (snd p), tt).

Deﬁnition RKA-R (k: Bvector b)

(s : list (Bvector c × Bvector c))
(p: Bvector b × Bvector c)
: (Bvector c × list (Bvector c × Bvector c) :=

randomFunc s ((fst p) xor k, (snd p))

Deﬁnition RKA-G0 : Comp bool :=

k <-$ RndKey; [b, -] <-$2 A (RKA-F k) tt; ret b.

Deﬁnition RKA-G1 : Comp bool :=

k <-$ RndKey; [b, -] <-$2 A (RKA-R k) nil; ret b.

Deﬁnition RKA-Advantage : Rat :=

| Pr[RKA-G0] -Pr[RKA-G1] |.
Listing 4: Deﬁnition of Security against ⊕ Related-Key
Attacks. b is the key length of the compression function,
c is the input length of the compression function; Bvec-
tor b is the type of bit-vectors of length b.

The proof of security has the same basic structure
(Figure 2) as Bellare’s more recent HMAC proof [14],
though we simplify the proof signiﬁcantly by assum-
ing h∗ is WCR. The proof makes use of a nested MAC
(NMAC) construction that is similar to HMAC, but it
uses h∗ in a way that is not typically possible in imple-
mentations of hash functions. The proof begins by show-
ing that NMAC is a PRF given that h is a PRF and h∗ is
WCR. Then we show that NMAC and HMAC are “close”
(that no adversary can effectively distinguish them) un-
der the assumption that ¯h is a ⊕-RKA-secure PRF. Fi-
nally, we combine these two results to derive that HMAC
is a PRF.

USENIX Association  

24th USENIX Security Symposium  213

h  PRF

h ⨁-RKA

PRF

HMAC/NMAC

“close”

h*  WCR

NMAC PRF

HMAC PRF

Figure 2: HMAC Security Proof Structure

We also mirror Bellare’s proof by reasoning about
slightly generalized forms of HMAC and NMAC (called
GHMAC and GNMAC) that require the input to be a list
of bit vectors of length b. The proof also makes use of
a “two-key” version of HMAC that uses a bit vector of
length 2b as the key. To simplify the development of this
proof, we build HMAC on top of these intermediate con-
structions in the abstract speciﬁcation (Listing 5).

Deﬁnition h-star k (m : list (Bvector b))

:= fold-left h m k.

Deﬁnition hash-words := h-star iv.

Deﬁnition GNMAC k m :=

let (k-Out, k-In) := splitVector c c k in
h k-Out (app-fpad (h-star k-In m)).

Deﬁnition GHMAC-2K k m :=

let (k-Out, k-In) := splitVector b b k in
let h-in := (hash-words (k-In :: m)) in
hash-words (k-Out :: (app-fpad h-in) :: nil).

Deﬁnition HMAC-2K k (m : list bool) :=

GHMAC-2K k (splitAndPad m).

Deﬁnition HMAC (k : Bvector b) :=

HMAC-2K ((k xor opad) ++ (k xor ipad)).
Listing 5: HMAC Abstract Speciﬁcation.

splitAndPad produces a list of bit-vectors from a list of
bits (padding the last bit-vector as needed), and app-fpad
is a padding function that produces a bit vector of length
b from a bit vector of length c. In the HMAC function, we
use constants opad and ipad to produce a key of length
2b from a key of length b.

The statement of security for HMAC is shown in List-
ing 6. We show that HMAC is a PRF by giving an expres-
sion that bounds the advantage of an arbitrary adversary
A. This expression is the sum of three terms, where each
term represents the advantage of some adversary against
some other security deﬁnition.

The listing describes all the parameters to each of the
security deﬁnitions. In all these deﬁnitions, the ﬁrst pa-
rameter is the computation that produces random keys,
and in PRF-Advantage and RKA-Advantage, the second
parameter is the computation that produces random val-

ues in the range of the function. In all deﬁnitions, the
penultimate parameter is the function of interest, and the
ﬁnal parameter is some constructed adversary. The de-
scriptions of these adversaries are omitted for brevity, but
only their computational complexity is relevant (e.g. all
adversaries are in ZPP assuming adversary A is in ZPP).

Theorem HMAC-PRF:
PRF-Advantage ({0, 1}ˆb) ({0, 1}ˆc) HMAC A <=
PRF-Advantage ({0, 1}ˆc) ({0, 1}ˆc) h B1 +
Adv-WCR ({0, 1}ˆc) h-star B2 +
RKA-Advantage ({0, 1}ˆb) ({0, 1}ˆc)
(BVxor b) (dual-f h) B3.
Listing 6: Statement of Security for HMAC.

We can view the result in Listing 6 in the asymptotic
setting, in which there is a security parameter η, and pa-
rameters c and b are polynomial in η. In this setting, it
is possible to conclude that the advantage of A against
HMAC is negligible in η assuming that each of the other
three terms is negligible in η. We can also view this re-
sult in the concrete setting, and use this expression to ob-
tain exact security measures for HMAC when the values
of b and c are ﬁxed according the sizes used by the imple-
mentation. The latter interpretation is more informative,
and probably more appropriate for reasoning about the
cryptographic security of an implementation.

5 Equivalence of the two functional specs
(Item 4 of the architecture.) In §2 we described a bytes-
and-words speciﬁcation following FIPS198-1, suited for
proving the C program; call that the concrete speciﬁca-
tion. In §4 we described a length-constrained bit-vector
speciﬁcation following Bellare et al.’s original papers;
call that the abstract speciﬁcation. Here we describe the
proof that these two speciﬁcations are equivalent.

Proof outline. There are seven main differences be-
tween the concrete and abstract specs:
(0) The abstract spec, as its name suggests, leaves sev-
eral variables as parameters to be instantiated. Thus,
in order to compute with the abstract HMAC, one
must pass it “converted” variables and “wrapped”
functions from the concrete HMAC.

(1) The abstract spec operates on bits, whereas the con-

crete spec operates on bytes.

(2) The

abstract

spec uses

the dependent

type
Bvector n, which is a length-constrained bit list of
length n, whereas the concrete spec uses byte lists
and int lists, whose lengths are unconstrained by
deﬁnition.

214  24th USENIX Security Symposium 

USENIX Association

(3) Due to its use of dependent types,

the abstract
spec must pad its input twice in an ad-hoc man-
ner, whereas the concrete spec uses the SHA-256
padding function consistently.

(4) The concrete spec treats the hash function (SHA-
256) as a black box, whereas the abstract spec ex-
poses various parts of its functionality, such as its
initialization vector, internal compression function,
and manner of iteration. (It does this because the
Bellare-style proofs rely on the Merkle-Damg˚ard
structure of the hash function.)

(5) The abstract spec pads the message and splits it into
a list of blocks so that it can perform an explicit fold
over the list of lists. However, the concrete spec
leaves the message as a list of bytes and performs
an implicit fold over the list, taking a new block at
each iteration.

(6) The abstract spec deﬁnes HMAC via the HMAC 2K

and GHMAC 2K structures, not directly.

Instantiating the abstract speciﬁcation. The abstract
HMAC spec leaves the following parameters abstract:

Variable c p : nat.

(∗ compression function ∗)
Variable h : Bvector c → Bvector b → Bvector c.
(∗ initialization vector ∗)
Variable iv : Bvector c.
Variable splitAndPad : Blist → list (Bvector b).
Variable fpad : Bvector c → Bvector p.
Variable opad ipad : Bvector b.

The abstract HMAC spec is also more general than the
concrete spec, since it operates on bit vectors, not byte
lists, and does not specify a block size or output size. Af-
ter “replacing” the vectors with lists (see the explanation
of difference (2)) and specializing c = p = 256 (result-
ing in b = 512), we may instantiate abstract parameters
with concrete parameters or functions from SHA-256,
wrapped in bytesToBits and/or intlist to Zlist conversion
functions. For example, we instantiate the block size to
256 and the output size to 512, and deﬁne iv and h as:
Deﬁnition intsToBits := bytesToBits ◦ intlist-to-Zlist.
Deﬁnition sha-iv : Blist :=

intsToBits SHA256.init-registers.

Deﬁnition sha-h (regs : Blist) (block : Blist) : Blist :=

intsToBits (SHA256.hash-block (bitsToInts regs)

(bitsToInts block)).

The intlist to Zlist conversion function is necessary
because portions of the SHA-256 spec operate on lists of

Integers, as speciﬁed in our bytes-and-words formaliza-
tion of FIPS 180-4. (Z in Coq denotes arbitrary-precision
mathematical integers. Our SHA-256 spec represents
byte values as Z. An Integer is four byte-Zs packed big-
endian into a 32-bit integer.)

We are essentially converting the types of the func-
tions from functions on intlists (intlist → . . . → intlist) to
functions on Blists (Blist → . . . → Blist) by converting
their inputs and outputs.
Let us denote by HmacAbs256 the instantiation of
function HMAC from Listing 5 to these parameters.
Since Bellare’s proof assumes that the given key is of the
right length (the block size), our formal equivalence re-
sult relates HmacAbs256 to the function HmacCore from
Section 2, i.e. to the part of HMAC256 that is applied af-
ter key length normalization. (Unlike Bellare, FIPS 198
includes steps to ﬁrst truncate or pad the key if it is too
long or short.)

Theorem. For key vector kv of type Bvector 256 and
message m of type list bool satisfying |l| ≡ 0 (mod 8),
HmacAbs256 kv m≈ HmacCore m (map Bytes.repr kv).
where (·) denotes bitsToBytes conversion, and ≈ is
equality modulo conversion between lists and vectors.

Reconciling other differences. The last difference
(6) is easily resolved by unfolding the deﬁnitions of
HMAC 2K and GHMAC 2K. We solve the other six
problems by changing deﬁnitions and massaging the two
specs toward each other, proving equality or equivalence
each time.

Bridging (5) is basically the proof of correctness of a
deforestation transformation. Consider a message m as a
list of bits bi. First, split it into 512-bit blocks Bi, then
“fold” (the “reduce” operation in map-reduce) the hash
operation H over it, starting with the initialization vector
iv: H(H(H(iv,B0),B1), . . . ,B n−1). Alternatively, express
this as a recursive function on the original bit-sequence
b: grab the ﬁrst 512 bits, hash with H, then do a recursive
call after skipping the ﬁrst 512 bits:
Function F (r: list bool) (b: list bool)
{measure length b} : list bool :=
nil ⇒ r
| - ⇒ F (H r (ﬁrstn 512 b)) (skipn 512 b)
end.
Provided that |b| is a multiple of 512 (which we prove
elsewhere), F(iv,b) =H (H(H(iv,B0),B1), . . . ,B n−1).
We bridge (4) by using the fact that SHA-256 is a
Merkle-Damg˚ard construction over a compression func-
tion. This is a simple matter of matching the deﬁnition
of SHA-256 to the deﬁnition of an MD hash function.

match msg with

USENIX Association  

24th USENIX Security Symposium  215

Bridging (3) is a proof that two different views of the
SHA padding function are equivalent. Before iterating
the compression function on the message, SHA-256 pads
it in a standard, one-to-one fashion such that its length is
a multiple of the block size. It pads it as such:

msg| [1]| [0,0, . . .0] |L

where | denotes list concatenation and L denotes the 64-
bit representation of the length of the message. The num-
ber of 0s is calculated such that the length of the entire
padded message is a multiple of the block size.

The abstract spec accomplishes this padding in two
ways using the functions fpad and splitAndPad.
fpad
pads a message of known length of the output size c to
the block size b, since c is speciﬁed to be less than b.
splitAndPad breaks a variable-length message (of type
list bool) into a list of blocks, each size b, padding it
along the way. fpad is instantiated as a constant, since we
know that the length of the message is c < b. splitAndPad
is instantiated as the normal SHA padding function, but
tweaked to add one block size to the length appended
in [l1,l2], since kin (with a length of one block) will be
prepended to the padded message later.

To eliminate these two types of ad-hoc padding,
we rewrite the abstract spec to incorporate fpad and
splitAndPad into a single padding function split-and-pad
included in the hash function, in the style of SHA-256.
hash-words-padded := hash-words ◦ split-and-pad.

We then remove fpad and splitAndPad from subse-
quent versions of the speciﬁcation. We can easily prove
equality by unfolding deﬁnitions.

Bridging bytes and bits. The abstract and concrete
HMAC functions have different types, so we cannot
prove them equal, only equivalent. HMACc operates on
(lists of) bits and HMACa operates on (lists of) bytes.
(HMACc used to operate on vectors, but recall that we
replaced them with lists earlier.) To bridge gap (1) we
prove, given that the inputs are equivalent, the outputs
will be equivalent:

kc ≈ ka →
mc ≈ ma →

HMACc(kc,mc) ≈ HMACa(ka,ma).

The equivalence relation ≈ can be deﬁned either compu-
tationally or inductively, and both deﬁnitions are useful.
To reason about the behavior of the wrapped functions
with which we instantiated the abstract HMAC spec, we
use the computational equivalence relation (≈c) instan-
tiated with a generic conversion function. This allows
us to build a framework for reasoning about the asym-
metry of converting from bytes to bits versus from bits
to bytes, as well as the behavior of repeatedly applied
wrapped functions.

Bridging vectors and lists. We bridge (2) by changing
all Bvector n to list bool, then proving that all functions
preserve the length of the list when needed. This main-
tains the Bvector n invariant that its length is always n.
In general, the use of lists (of bytes, or Z values) is mo-
tivated by the desire to reuse Appel [5]’s prior work on
SHA literally, whereas the use of Bvector enables a more
elegant proof of the proof of cryptographic properties.

Indeed,

Injectivity of splitAndPad. The security proof relies
on the fact that splitAndPad is injective, in the sense
that b1 = b2 should hold whenever splitAndPad(b1)
= splitAndPad(b2).
this property is vio-
lated if we naively instantiate splitAndPad with the
bitlists-to-bytelists roundtrip conversion of SHA-256’s
padding+length function, due to the non-injectivity of
bitlists-to-bytelists conversion. On the other hand, as
the C programs interpret all length informations as re-
ferring to lengths in bytes, attackers that attempt to send
messages whose length is not divisible by 8 are ef-
fectively ruled out. To verify this property formally,
we make the abstract speciﬁcation (and the proof of
Theorem HMAC-PRF) parametric in the type of mes-
sages. Instantiating the development to the case where
messages are bitlists of length 8n allows us to establish
the desired injectivity condition along the the lines of the
following informal argument.

Given a message m, SHA’s splitAndPad appends a 1
bit, then k zero bits, then a 64-bit integer representing
the length of the message |m|; k is the smallest number
so that |splitAndPad(m1)| is a multiple of the block size.
Injective means that if m1 (cid:27)= m2 then splitAndPad(m1) (cid:27)=
splitAndPad(m2). The proof has ﬁve cases:

• m1 = m2, then by contradiction.
• |m1| = |m2|, then splitAndPad(m1) must differ from

splitAndPad(m2) in their ﬁrst |m1| bits.
• |m1| (cid:27)= |m2|, |m1| ≤2 64, |m2| ≤2 64, then the last 64
bits (representation of length) will differ.
• (|m1|−|m2|) mod 264 (cid:27)= 0, then the last 64 bits (rep-
resentation of length) will differ.
• |m1|(cid:27)=|m2|, and (|m1|−|m2|) mod 264 = 0; then the
lengths |m1|,|m2| must differ by at least 264, so the
variation in k1 and k2 (which must each be less than
twice the block size) cannot make up the difference,
so the padded messages will have different lengths.
Our machine-checked proof of injectivity is somewhat
more comprehensive than Bellare et al.’s [15], which
reads in its entirety, “Notice that a way to pad messages
to an exact multiple of b bits needs to be deﬁned, in par-
ticular, MD5 and SHA pad inputs to always include an
encoding of their length.”

216  24th USENIX Security Symposium 

USENIX Association

Preservation of cryptographic security. Once the
equivalence between the two functional programs has
been established, and injectivity of the padding function
is proved, it is straightforward to prove the applicability
of Theorem HMAC-PRF (Listing 6) to the API spec.

6 Specifying and verifying the C program

(Items 11, 13 of the architecture.) We use Veriﬁable C
to prove that each function’s body satisﬁes its speciﬁca-
tion. As in a classic Hoare logic, each kind of C-language
statement has one or more proof rules. Appel [6, Ch.
24-26] presents these proof rules, and explains how tac-
tics—programmed in the Ltac language of Coq—apply
the proof rules to the abstract syntax trees of C programs.
The ASTs are obtained by applying the front-end phase
of the CompCert compiler to the C program. The HMAC
proof (item 13 in §1) is 2832 lines of Coq (including
blanks and comments), none of which is in the trusted
base because it is all machine-checked.

Just like OpenSSL’s implementation of SHA-256, the
C code implementing HMAC is incremental:
the one-
shot HMAC function is obtained by composing auxil-
iary functions hmacInit, hmacUpdate, hmacFinish, and
hmacCleanup that are all exposed in the header ﬁle.
They allow a client to reuse a key for the authenti-
cation of multiple messages, and also to provide each
individual message in chunks, by repeatedly invoking
hmacUpdate. To this end, the auxiliary functions em-
ploy the hash function’s incremental interface and are
formulated over a client-visible struct, HMAC-CTX.
Specializing OpenSSL’s original header ﬁle to the hash
function SHA-256 yields the following:2
typedef struct hmac-ctx-st {

SHA256-CTX md-ctx; // workspace
SHA256-CTX i-ctx; // inner SHA structure
SHA256-CTX o-ctx; // outer SHA structure
unsigned int key-length;
unsigned char key[64];
} HMAC-CTX;

void HMAC-Init(HMAC-CTX ∗ctx,

unsigned char ∗key, int len);

void HMAC-Update(HMAC-CTX ∗ctx,

const void ∗data, size-t len);

void HMAC-Final(HMAC-CTX ∗ctx,

unsigned char ∗md);

2During the veriﬁcation, we observed that the ﬁelds key-length and
key can be eliminated from hmac-ctx-st, for the price of minor alter-
ations to the code, API speciﬁcation, and proof. A similar modiﬁcation
has recently (and independently) been implemented in boringssl.

void HMAC-cleanup(HMAC-CTX ∗ctx);
unsigned char ∗HMAC(unsigned char ∗key,

int key-len,
unsigned char ∗d, int n,
unsigned char ∗md);

Fields i-ctx and o-ctx store partially constructed SHA
data structures that are initialized during HMAC-Init to
hold the ⊕ of the normalized key and ipad/opad, respec-
tively, and are copied to the workspace md-ctx where the
inner and outer hashing applications are performed.

Omitting the implementations of the other functions,
the one-shot HMAC invokes the incremental functions
on a freshly stack-allocated HMAC-CTX, where 32 is
the digest length of SHA-256:
unsigned char ∗HMAC(unsigned char ∗key,

int key-len, unsigned char ∗d,
int n, unsigned char ∗md) {

HMAC-CTX c; static unsigned char m[32];
if (md == NULL) md=m;
HMAC-Init(&c, key, key-len);
HMAC-Update(&c,d,n);
HMAC-Final(&c,md);
HMAC-cleanup(&c);
return(md);

}
In order to verify that this code satisﬁes the speciﬁcation
HMAC256-spec from Section 2, each incremental func-
tion is equipped with its individual Veriﬁable C speciﬁca-
tion. Each speciﬁcation is formulated with reference to a
suitable Coq function (or alternatively a propositional re-
lation, as extractability is not required) that expresses the
function’s effect on the HMAC-CTX structure abstractly,
without reference to the concrete memory layout.

More precisely,

the logical counterpart of an

HMAC-CTX structure is given by the Coq type
Inductive hmacabs :=
HMACabs: ∀ (ctx iSha oSha: s256abs)

(keylen: Z) (key: list Z), hmacabs.

That is, an HMAC abstract state has ﬁve components:
ctx, iSha, and oSha are SHA abstract states, keylen is an
integer, and key is a list of (integer) byte values. Appel
[5] deﬁnes SHA abstract states; if you initialize a SHA
module and dump the ﬁrst n bytes of a message into it,
you get a value of type s256abs representing the abstract
state of the incremental-mode SHA-256 program.

Appel also deﬁnes a relation, update-abs a c1 c2, say-
ing that adding another (incremental mode) message
fragment s to abstract state c1 yields state c2.

We deﬁne abstract

for HMAC, and the
incremental-mode HMAC update relation, in terms of
the SHA s256abs type and update-abs relation.

states

USENIX Association  

24th USENIX Security Symposium  217

Deﬁnition hmacUpdate (data: list Z)

(h1 h2: hmacabs) : Prop :=

match h1 with HMACabs ctx1 iS oS klen k
⇒ ∃ ctx2, update-abs data ctx1 ctx2
end.

∧ h2 = HMACabs ctx2 iS oS klen k

To connect these deﬁnitions to the upper parts of our
veriﬁcation architecture, we prove that the composi-
tion of these counterparts of the incremental functions
(i.e. the counterpart of the one-shot HMAC) coincides
with HMAC256 the FIPS functional speciﬁcation from
Section 3.

Deﬁnition hmacIncremental (k data dig:list Z) :=
∃ hInit hUpd, hmacInit k hInit ∧

hmacUpdate data hInit hUpd ∧
hmacFinal hUpd dig.

Lemma hmacIncremental-sound k data dig:

hmacIncremental k data dig →
dig = HMAC256 data k.

Proof. ... Qed.
Downward, we connect hmacabs and HMAC-CTX by a
separation logic representation predicate:
Deﬁnition hmacstate- (h:hmacabs) (c:val): mpred:=

EX r:hmacstate,
!! hmac-relate h r
&& data-at Tsh t-struct-hmac-ctx-st r c.

where hmac-relate is a pure proposition specifying that
each component of a concrete struct r has precisely the
content prescribed by h.

Using these constructions, we obtain API spec-
such as

incremental

functions

the

iﬁcations of
HMAC-Update.
Deﬁnition HMAC-Update-spec :=
DECLARE -HMAC-Update
WITH h1: hmacabs, c : val, d:val, len:Z,

data:list Z, KV:val

PRE [ -ctx OF tptr t-struct-hmac-ctx-st,
-data OF tptr tvoid, -len OF tuint]

PROP(has-lengthD (s256a-len (absCtxt h1))

len data)

LOCAL(temp -ctx c; temp -data d;

PROP(hmacUpdate data h1 h2)
LOCAL()
SEP(`(K-vector KV); `(hmacstate- h2 c);

`(data-block Tsh data d)).

temp -len (Vint (Int.repr len));
gvar -K256 KV)

SEP(`(K-vector KV); `(hmacstate- h1 c);

`(data-block Tsh data d))

POST [ tvoid ]

EX h2: hmacabs,

7 Proof effort

It is difﬁcult to estimate the proof effort, as we used this
case study to learn where to make improvements to the
usability and automation of our toolset. However, we can
give some numbers: size, in commented lines of code, of
the speciﬁcations and proofs. Where relevant, we give
the size of the corresponding C API or function.

Functional correctness proof of the C program:
C lines Coq lines SHA-256 component

71

10
81
10
38
31
7
248

25
25

74
7
27
5
21
134

FIPS-180 functional spec of SHA

169
247 API spec of SHA-256
1022 Lemmas about the functional spec
229
1640
43
1682
1484
58
6574

Proof of addlength function
sha256 block data order()
SHA256 Init()
SHA256 Update()
SHA256 Final()
SHA256()
Total SHA-256

FIPS-198 functional spec of HMAC

159
374 API spec
533

Total HMAC spec

Supporting lemmas

875
1530 HMAC Init proof
101 HMAC Update proof
196 HMAC Final proof
31 HMAC Cleanup proof
99 HMAC proof

2832

Total HMAC proof

FCF proof that HMAC is a PRF:
Coq lines component

70 Bellare-style functional spec of HMAC
25
377
472

Statement, HMAC is a PRF
Proof, HMAC is a PRF
Total

Connecting Veriﬁable C proof to FCF proof:
Coq lines component

3017 General equivalence proof of the two func-

tional specs for any compression function
Specialization to SHA-256
Total

993
4010

8 Related work

We have presented a foundational, end-to-end veriﬁca-
tion. All the relevant aspects of cryptographic proofs or
of the C programming language are deﬁned and checked

218  24th USENIX Security Symposium 

USENIX Association

with respect to the foundations of logic. We say a rea-
soning engine for crypto is foundational if it is imple-
mented in, or its implementation is proved correct in, a
trustworthy general-purpose mechanized logic. We say a
connection to a language implementation is foundational
if the synthesizer or veriﬁer is connected (with proofs in
a trustworthy general-purpose mechanized logic) to the
operational semantics compiled by a veriﬁed compiler.

Crypto veriﬁcation. Smith and Dill [40] verify sev-
eral block-cipher implementations written in Java with
respect to a functional spec written either in Java or in
ACL2. They compile to bytecode, then use a subset
model of the JVM to generate straight-line code. This
work is not end-to-end, as the JVM is unveriﬁed—and it
wouldn’t sufﬁce to simply plug in a “veriﬁed” JVM, if
one existed, without also knowing that the same speciﬁ-
cation of the JVM was used in both proofs. Their method
applies only where the number of input bits is ﬁxed and
the loops can be completely unrolled. Their veriﬁer
would likely be applicable to the SHA-256 block shuf-
ﬂe function, but certainly not to the management code
(padding, adding the length, key management, HMAC).
Cryptol [25] generates C or VHDL directly from a
functional speciﬁcation, where the number of input bits
is ﬁxed and the loops can be completely unrolled, i.e.
the SHA-256 block shufﬂe, but not the SHA-256 man-
agement code or HMAC. The Cryptol synthesizer is not
foundational because its semantics is not formally speci-
ﬁed, let alone proved.

CAO is a domain speciﬁc language for crypto appli-
cations, which is compiled into C [11], and equipped
with veriﬁcation technology based on the FRAMA-C
tool suite [4].

Libraries of arbitrary-precision arithmetic functions
have been veriﬁed by Fischer [39] and Berghofer [17]
using Isabelle/HOL. Bertot et al. [20] verify GMP’s com-
putation of square roots in Coq, based on Filliatre’s COR-
RECTNESS tool for ML-style programs with imperative
features [26]. Neither of these formalizations is foun-
datationally connected to a veriﬁed compiler.

Veriﬁed assembly implementations of arithmetic func-
tions have been developed by Myreen and Curello [36]
and Affeldt [1], who use, respectively, proof-producing
(de)compilation and simulation to link assembly code
and memory layout
to functional speciﬁcations at
(roughly) the level of our FIPS speciﬁcations. Chen et
al. [24] verify the Montgomery step in Bernstein’s high-
speed implementation of elliptic curve 25519 [18], using
a combination of SMT solving and Coq to implement a
Hoare logic for Bernstein’s portable assembly represen-
tation qhasm.

The abstraction techniques and representation predi-
cates in these works are compatible with our memory

layout predicates. One important future step is to con-
dense commonalities of these libraries into an ontology
for crypto-related reasoning principles, reusable across
multiple language levels and realised in multiple proof
assistants. Doing this is crucial for scaling our work to
larger fragments of cryptographic libraries.

Formal veriﬁcation of protocols is an established re-
search area, and efforts to link abstract protocol veriﬁca-
tions to implementations are emerging using automated
techniques like model extraction or code generation [8],
or interactive proof [2].

Toma and Borrione [41] use ACL2 to prove correct-
ness of a VHDL implementation of the SHA-1 block-
shufﬂe algorithm. There is no connection to (for exam-
ple) a veriﬁed compiler for VHDL.

Backes et al. [10] verify mechanically (in EasyCrypt)
that Merkle-Damg˚ard constructions have certain security
properties.

EasyCrypt. Almeida et al. [3] describe the use of their
EasyCrypt tool to verify the security of an implemen-
tation of the RSA-OAEP encryption scheme. A func-
tional speciﬁcation of RSA-OAEP is written in Easy-
Crypt, which then veriﬁes its security properties. An
unveriﬁed Python script translates the EasyCrypt spec-
iﬁcation to (an extension of) C, then an extension of
CompCert compiles it to assembly language. Finally, a
leakage tool veriﬁes that the assembly language program
has no more program counter leakage than the source
code, i.e.
that the compiled program’s trace of condi-
tional branches is no more informative to the adversary
than the source code’s.

The EasyCrypt veriﬁer is not foundational; it is an
OCaml program whose correctness is not proved. The
translation from C to assembly language is foundational,
using CompCert. However, EasyCrypt’s C code relies on
bignum library functions, but provides no mechanism by
which these functions can be proved correct.

CertiCrypt [13] is a system for reasoning about cryp-
tographic algorithms in Coq; it is foundational, but (like
EasyCrypt) has no foundational connection to a C se-
mantics. ZKCrypt[9] is a synthesizer that generates C
code for zero-knowledge proofs, implemented in Cer-
tiCrypt, also with no foundational connection to a C se-
mantics.

Bhargavan et al.

[21] “implement TLS with veri-
ﬁed cryptographic security” in F# using the F7 type-
checker. F7 is not capable of reasoning about all of
the required cryptographic/probabilistic relationships re-
quired to complete the proof. So parts of the proof are
completed using EasyCrypt, and there is no formal rela-
tionship between the EasyCrypt proofs and the F7 proof;
one must inspect the code to ensure that the things ad-
mitted in F7 are the same things that are proved in Easy-

USENIX Association  

24th USENIX Security Symposium  219

Crypt. F7 is also not foundational, because the type
checker has a large amount of trusted code and because
it depends on the Z3 SMT solver. Another difference
between this work and ours is that the code provides a
reference implementation in F#, not an efﬁcient imple-
mentation in C.

CryptoVerif
[22] is a prover (implemented in OCaml)
for security protocols in which one can, for example, ex-
tract a OCaml program from a CryptoVerif model [23].
CryptoVerif is not foundational, the extraction is not
foundational, and the compiler for OCaml is not foun-
dationally veriﬁed.

C program veriﬁcation. There are many program
analysis tools for C. Most of them do not address func-
tional speciﬁcation or functional correctness, and most
are unsound and incomplete. They are useful in practice,
but cannot be used for an end-to-end veriﬁcation of the
kind we have done.

Foundational formal veriﬁcation of C programs has
only recently been possible. The most signiﬁcant such
works are both operating-system kernels: seL4 [32] and
CertiKOS [29]. Both proofs are reﬁnement proofs be-
tween functional speciﬁcations and operational seman-
tics. Both proofs are done in higher-order logics: seL4
in Isabelle/HOL and CertiKOS in Coq.

Neither of those proof frameworks uses separation
logic, and neither can accommodate the use of address-
able local variables in C. This means that OpenSSL’s
HMAC/SHA could not be proved in these frameworks,
because it uses addressable local variables.

Additionally, neither of those proof frameworks can
handle function pointers. OpenSSL uses function point-
ers in its “engines” mechanism, an object-oriented style
of programming that dynamically connects components
together, such as HMAC and SHA. The Veriﬁable C pro-
gram logic is capable of reasoning about such object-
oriented patterns in C [6, Chapter 29], although we have
not done so in the work described in this paper.

9 Conclusion

Widely used open-source cryptographic libraries such as
OpenSSL, operating systems kernels, and the C compil-
ers that build them, form the backbone of the public’s
communication security. Since 2013 or so, it has be-
come clear that hackers and nation-states (is there a dif-
ference anymore?) are willing to invest enormous re-
sources in searching for vulnerabilities and exploiting
them. Other authors have demonstrated that compilers
[34] and OS kernels [32, 29] can be built to a prov-
able zero-functional-correctness-defect standard. Here

we have demonstrated the same, in a modular way, for
key components of our common cryptographic infras-
tructure.

Functional correctness implies zero buffer-overrun de-
fects as well. But there are side channels we have not ad-
dressed here, such as timing, fault-injection, and leaks
through dead memory. Our approach does not solve
these problems; but it makes them no worse. Because we
can reason about standard C code, other authors’ tech-
niques for side channel analysis are applicable without
obstruction.

Functional correctness (with respect to a speciﬁcation)
does not always guarantee that a program has abstract
security properties. Here, by linking a proof of crypto-
graphic security to a proof of program correctness, we
provide that guarantee.

Acknowledgments. Funded in part by DARPA award
FA8750-12-2-029 and by a grant from Google ATAP.

References
[1] AFFELDT, R. On construction of a library of formally veriﬁed
low-level arithmetic functions. Innovations in Systems and Soft-
ware Engineering (ISSE) 9, 2 (2013), 59–77.

[2] AFFELDT, R., AND SAKAGUCHI, K. An intrinsic encoding of a
subset of C and its application to TLS network packet processing.
Journal of Formalized Reasoning 7, 1 (2014), 63–104.

[3] ALMEIDA, J. B., BARBOSA, M., BARTHE, G., AND DUPRES-
SOIR, F. Certiﬁed computer-aided cryptography: efﬁcient prov-
ably secure machine code from high-level implementations. In
Proceedings of the 2013 ACM SIGSAC Conference on Computer
and Communications security (2013), ACM, pp. 1217–1230.

[4] ALMEIDA, J. B., BARBOSA, M., FILLI ˆATRE, J., PINTO, J. S.,
AND VIEIRA, B. CAOVerif: An open-source deductive veriﬁca-
tion platform for cryptographic software implementations. Sci.
Comput. Program. 91 (2014), 216–233.

[5] APPEL, A. W. Veriﬁcation of a cryptographic primitive: SHA-
256. ACM Trans. on Programming Languages and Systems 37, 2
(Apr. 2015), 7:1–7:31.

[6] APPEL, A. W., DOCKINS, R., HOBOR, A., BERINGER, L.,
DODDS, J., STEWART, G., BLAZY, S., AND LEROY, X. Pro-
gram Logics for Certiﬁed Compilers. Cambridge, 2014.

[7] APPEL, A. W., MICHAEL, N. G., STUMP, A., AND VIRGA, R.
A trustworthy proof checker. J. Automated Reasoning 31 (2003),
231–260.

[8] AVALLE, M., PIRONTI, A., AND SISTO, R. Formal veriﬁca-
tion of security protocol implementations: a survey. Formal Asp.
Comput. 26, 1 (2014), 99–123.

[9] BACELAR ALMEIDA, J., BARBOSA, M., BANGERTER, E.,
BARTHE, G., KRENN, S., AND ZANELLA B ´EGUELIN, S. Full
proof cryptography: veriﬁable compilation of efﬁcient zero-
knowledge protocols. In Proceedings of the 2012 ACM confer-
ence on Computer and communications security (2012), ACM,
pp. 488–500.

[10] BACKES, M., BARTHE, G., BERG, M., GR ´EGOIRE, B., KUNZ,
C., SKORUPPA, M., AND B ´EGUELIN, S. Z. Veriﬁed security of
Merkle-Damg˚ard. In Computer Security Foundations Symposium
(CSF), 2012 IEEE 25th (2012), IEEE, pp. 354–368.

220  24th USENIX Security Symposium 

USENIX Association

[27] Keyed-hash message authentication code. Tech. Rep. FIPS PUB
198-1, Information Technology Laboratory, National Institute of
Standards and Technology, Gaithersburg, MD, July 2008.

[28] Secure hash standard (SHS). Tech. Rep. FIPS PUB 180-4, Infor-
mation Technology Laboratory, National Institute of Standards
and Technology, Gaithersburg, MD, Mar. 2012.

[29] GU, L., VAYNBERG, A., FORD, B., SHAO, Z., AND
COSTANZO, D. CertiKOS: A certiﬁed kernel for secure cloud
computing. In Proceedings of the Second Asia-Paciﬁc Workshop
on Systems (2011), APSys’11, ACM, pp. 3:1–3:5.

[30] HALEVI, S. A plausible approach to computer-aided crypto-

graphic proofs. http://eprint.iacr.org/2005/181, 2005.

[31] HOARE, C. A. R. An axiomatic basis for computer program-

ming. Commun. ACM 12, 10 (October 1969), 578–580.

[32] KLEIN, G., ELPHINSTONE, K., HEISER, G., ANDRONICK, J.,
COCK, D., DERRIN, P., ELKADUWE, D., ENGELHARDT, K.,
KOLANSKI, R., NORRISH, M., ET AL.
seL4: Formal veriﬁ-
cation of an OS kernel.
In Proceedings of the ACM SIGOPS
22nd symposium on Operating systems principles (2009), ACM,
pp. 207–220.

[33] KOBLITZ, N., AND MENEZES, A. Another look at HMAC.

Journal of Mathematical Cryptology 7, 3 (2013), 225–251.

[34] LEROY, X. Formal certiﬁcation of a compiler back-end, or: pro-
gramming a compiler with a proof assistant. In POPL’06 (2006),
pp. 42–54.

[35] LEROY, X. Formal veriﬁcation of a realistic compiler. Commu-

nications of the ACM 52, 7 (2009), 107–115.

[36] MYREEN, M. O., AND CURELLO, G. Proof pearl: A veri-
In Cer-
ﬁed bignum implementation in x86-64 machine code.
tiﬁed Programs and Proofs - Third International Conference,
CPP 2013, Proceedings (2013), G. Gonthier and M. Norrish,
Eds., vol. 8307 of Lecture Notes in Computer Science, Springer,
pp. 66–81.

[37] O’HEARN, P., REYNOLDS, J., AND YANG, H. Local reasoning
about programs that alter data structures.
In CSL’01: Annual
Conference of the European Association for Computer Science
Logic (Sept. 2001), pp. 1–19. LNCS 2142.

[38] PETCHER, A., AND MORRISETT, G. The foundational cryptog-
raphy framework. In Principles of Security and Trust - 4th In-
ternational Conference, POST 2015, Proceedings (2015), R. Fo-
cardi and A. C. Myers, Eds., vol. 9036 of Lecture Notes in Com-
puter Science, Springer, pp. 53–72.

[39] SCHMALTZ, S. F. F. Formal veriﬁcation of a big integer library
including division. Master’s thesis, Saarland University, 2007.
busserver.cs.uni-sb.de/publikationen/Fi08DATE.pdf.

[40] SMITH, E. W., AND DILL, D. L. Automatic formal veriﬁca-
In Formal Methods in

tion of block cipher implementations.
Computer-Aided Design (FMCAD’08) (2008), IEEE, pp. 1–7.

[41] TOMA, D., AND BORRIONE, D. Formal veriﬁcation of a SHA-1
circuit core using ACL2. In Theorem Proving in Higher Order
Logics. Springer, 2005, pp. 326–341.

[11] BARBOSA, M., CASTRO, D., AND SILVA, P. F. Compiling
CAO: from cryptographic speciﬁcations to C implementations.
In Principles of Security and Trust - Third International Confer-
ence, POST 2014, Proceedings (2014), M. Abadi and S. Kremer,
Eds., vol. 8414 of Lecture Notes in Computer Science, Springer,
pp. 240–244.

[12] BARTHE, G., DUPRESSOIR, F., GR ´EGOIRE, B., KUNZ, C.,
SCHMIDT, B., AND STRUB, P.-Y. EasyCrypt: A tutorial.
In
Foundations of Security Analysis and Design VII. Springer, 2014,
pp. 146–166.

[13] BARTHE, G., GR ´EGOIRE, B., AND ZANELLA B ´EGUELIN, S.
Formal certiﬁcation of code-based cryptographic proofs. In Pro-
ceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages (New York, NY, USA,
2009), POPL ’09, ACM, pp. 90–101.

[14] BELLARE, M. New proofs for NMAC and HMAC: Secu-
In Advances in Cryptology-

rity without collision-resistance.
CRYPTO 2006. Springer, 2006, pp. 602–619.

[15] BELLARE, M., CANETTI, R., AND KRAWCZYK, H. Keying
hash functions for message authentication. In Advances in Cryp-
tologyCRYPTO96 (1996), Springer, pp. 1–15.

[16] BELLARE, M., AND ROGAWAY, P. Code-based game-playing
IACR Cryptology

proofs and the security of triple encryption.
ePrint Archive 2004 (2004), 331.

[17] BERGHOFER, S. Veriﬁcation of dependable software using
SPARK and Isabelle. In 6th International Workshop on Systems
Software Veriﬁcation, SSV 2011 (2011), J. Brauer, M. Roveri, and
H. Tews, Eds., vol. 24 of OASICS, Schloss Dagstuhl - Leibniz-
Zentrum fuer Informatik, pp. 15–31.

[18] BERNSTEIN, D. J. Curve25519: New Difﬁe-Hellman speed
records. In Public Key Cryptography - PKC 2006, 9th Interna-
tional Conference on Theory and Practice of Public-Key Cryp-
tography, Proceedings (2006), M. Yung, Y. Dodis, A. Kiayias,
and T. Malkin, Eds., vol. 3958 of Lecture Notes in Computer Sci-
ence, Springer, pp. 207–228.

[19] BERNSTEIN,

D.

J.

cr.yp.to/talks/2012.03.20/slides.pdf, Mar. 2012.

The

HMAC

brawl.

[20] BERTOT, Y., MAGAUD, N., AND ZIMMERMANN, P. A proof of
GMP square root. J. Autom. Reasoning 29, 3-4 (2002), 225–252.
[21] BHARGAVAN, K., FOURNET, C., KOHLWEISS, M., PIRONTI,
A., AND STRUB, P.
Implementing TLS with veriﬁed crypto-
graphic security. In Security and Privacy (SP), 2013 IEEE Sym-
posium on (2013), IEEE, pp. 445–459.

[22] BLANCHET, B. A computationally sound mechanized prover
for security protocols. Dependable and Secure Computing, IEEE
Transactions on 5, 4 (2008), 193–207.

[23] CAD ´E, D., AND BLANCHET, B. Proved generation of imple-
mentations from computationally secure protocol speciﬁcations.
In Principles of Security and Trust. Springer, 2013, pp. 63–82.

[24] CHEN, Y., HSU, C., LIN, H., SCHWABE, P., TSAI, M., WANG,
B., YANG, B., AND YANG, S. Verifying curve25519 software.
In Proceedings of the 2014 ACM SIGSAC Conference on Com-
puter and Communications Security (2014), G. Ahn, M. Yung,
and N. Li, Eds., ACM, pp. 299–309.

[25] ERKOK, L., CARLSSON, M., AND WICK, A. Hardware/-
software co-veriﬁcation of cryptographic algorithms using Cryp-
tol. In Formal Methods in Computer-Aided Design, 2009 (FM-
CAD’09) (2009), IEEE, pp. 188–191.

[26] FILLI ˆATRE, J. Veriﬁcation of non-functional programs using in-
terpretations in type theory. J. Funct. Program. 13, 4 (2003),
709–745.

USENIX Association  

24th USENIX Security Symposium  221

