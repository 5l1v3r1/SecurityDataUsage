Practical DIFC Enforcement on Android

Adwait Nadkarni, Benjamin Andow, and William Enck, North Carolina State University; 

Somesh Jha, University of Wisconsin—Madison

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/nadkarni

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Practical DIFC Enforcement on Android

Adwait Nadkarni, Benjamin Andow, William Enck

{anadkarni,beandow,whenck}@ncsu.edu

North Carolina State University

Somesh Jha

jha@cs.wisc.edu

University of Wisconsin-Madison

Abstract

Smartphone users often use private and enterprise data
with untrusted third party applications. The fundamen-
tal lack of secrecy guarantees in smartphone OSes, such
as Android, exposes this data to the risk of unauthorized
exﬁltration. A natural solution is the integration of se-
crecy guarantees into the OS. In this paper, we describe
the challenges for decentralized information ﬂow control
(DIFC) enforcement on Android. We propose context-
sensitive DIFC enforcement via lazy polyinstantiation
and practical and secure network export through domain
declassiﬁcation. Our DIFC system, Weir, is backwards
compatible by design, and incurs less than 4 ms over-
head for component startup. With Weir, we demonstrate
practical and secure DIFC enforcement on Android.

1

Introduction

Application-based modern operating systems, such as
Android, thrive on their rich application ecosystems. Ap-
plications integrate with each other to perform complex
user tasks, providing a seamless user experience. To
work together, applications share user data with one an-
other. Such sharing exposes the user’s private and en-
terprise information to the risk of exﬁltration from the
device. For example, an email attachment opened in a
third party document editor (e.g., WPS Ofﬁce) could be
exported if the editor was malicious or compromised.

Android’s permission framework is used to protect ap-
plication data. However, permissions are only enforced
at the ﬁrst point of access. Data once copied into the
memory of an untrusted application can be exported.
This problem is generic in OSes that provide only data
protection, but not data secrecy, and can be solved by
integrating information ﬂow secrecy guarantees.

Classic information ﬂow control (IFC) [8] only cap-
tures well-known data objects through a centralized pol-
icy. On Android, data is often application-speciﬁc (e.g.,

email attachments, notes). Therefore, Android requires
decentralized IFC (DIFC) [21, 26, 44, 49], which allows
data owners (i.e., applications) to specify the policy for
their own data objects.

Although DIFC systems have been proposed for An-
droid [19,28,46], existing enforcement semantics cannot
achieve both security and practicality. For instance, an
Android application’s components are instantiated in the
same process by default, even when executing separate
user tasks. Since the various secrecy contexts from the
tasks share state in process memory, DIFC enforcement
on the process is hard, as the combined restrictions from
all secrecy contexts would make individual components
unusable. Prior approaches solve this problem by elim-
inating Android’s default behavior of application multi-
tasking, and in ways detrimental to backwards compati-
bility, i.e., 1) killing processes per new call, which could
result in dangling state, or 2) blocking until the applica-
tion voluntarily exits, which could lead to deadlocks.

Similarly, different secrecy contexts may share state
on storage through common application ﬁles (e.g., appli-
cation settings). Proposals to separate this shared state
on storage (e.g., Maxoid [46]) either deny access to ap-
plication resources or require applications to be modi-
ﬁed. To summarize, prior DIFC proposals for Android
cannot separate shared state in memory and on storage
while maintaining security and backwards compatibility.
In this paper, we present Weir,1 a practical DIFC sys-
tem for Android. Weir allows data owner applications to
set secrecy policies and control the export of their data
to the network. Apart from the data owners, and applica-
tions that want to explicitly use Weir to change their la-
bels, all other applications can execute unmodiﬁed. Weir
solves the problem of shared state by separating mem-
ory and storage for different secrecy contexts through
polyinstantiation. That is, Weir creates and manages in-
stances of the application, its components, and its stor-

1Weir: A small dam that alters the ﬂow of a river.

USENIX Association  

25th USENIX Security Symposium  1119

age for each secrecy context that the application is called
from, providing availability along with context-sensitive
separation. Our model is transparent to applications; i.e.,
applications that do not use Weir may execute oblivious
to Weir’s enforcement of secrecy contexts.

We term our approach as “lazy” polyinstantiation, as
Weir creates a new instance of a resource only if needed,
i.e., if there is no existing instance whose secrecy con-
text matches the caller’s. Additionally, Weir provides the
novel primitive of domain declassiﬁcation for practical
and secure declassiﬁcation in Android’s network-driven
environment. Our approach allows data owners to artic-
ulate trust in the receiver of data (i.e., trusted network
domain). This paper makes the following contributions:

• We identify the challenges of integrating DIFC into
Android. Using these challenges, we then derive the
goals for designing DIFC enforcement for Android.
• We introduce the mechanism of “lazy” polyinstanti-
ation for context-sensitive separation of the shared
state. Further, we provide the primitive of Domain
Declassiﬁcation for practical declassiﬁcation in An-
droid’s network-driven environment.

• We design and implement Weir on Android. Weir
incurs less than 4ms overhead for starting compo-
nents. Weir’s design ensures backwards compatibil-
ity. We demonstrate Weir’s utility with a case study
using the K-9 Mail application.

While Weir presents a mechanism that is independent
of the actual policy syntax, our implementation uses the
policy syntax of the Flume DIFC model [21]. Weir ex-
tends Flume by allowing implicit label propagation, i.e.,
ﬂoating labels, for backwards compatibility with unmod-
iﬁed applications. Since ﬂoating labels are by themselves
susceptible to high bandwidth information leaks [8], we
show how Weir’s use of ﬂoating labels is inherently re-
sistant to such leaks. Note that while language-level IFC
models [40–42] often incorporate checks that prevent im-
plicit ﬂows due to ﬂoating labels, our solution addresses
the challenges faced by OS-level ﬂoating label DIFC sys-
tems [19, 44]. Finally, we note that Weir provides prac-
tical DIFC enforcement semantics for Android, and the
usability aspect of DIFC policy and enforcement will be
explored in future work.

In the remainder of this paper, we motivate the prob-
lem (Section 2), and describe the challenges in integrat-
ing DIFC on Android (Section 3). We then describe the
design (Section 4), implementation (Section 5) and secu-
rity (Section 6) of Weir, followed by the evaluation (Sec-
tion 7), and a case study (Section 8). We then discuss
the limitations (Section 9), related work (Section 10) and
conclude (Section 11).

2 Motivation and Background

We now motivate the need for data secrecy on Android.
This is followed by background on DIFC and Android.
2.1 Motivating Example and Threat Model
Consider Alice, an enterprise user in a BYOD (bring
your own device) context. Alice receives an email in
the enterprise OfﬁceEmail application with an attached
report. She edits the report in a document editor, WPS
Ofﬁce, and saves a copy on the SD card, accessible to all
applications that have the READ EXTERNAL STORAGE
permission. Later, Alice uses the ES File Explorer to
browse for the report, edits it in WPS Ofﬁce, and then
shares it with OfﬁceEmail to reply to the initial email.

To perform their functions, untrusted third party data
managers such as ES File Explorer require broad stor-
age access. Even without direct access, user-initiated
data sharing grants data editors like WPS Ofﬁce access
to conﬁdential data. If ES File Explorer or WPS Ofﬁce
were malicious or compromised, they could export Al-
ice’s conﬁdential data to an adversary’s remote server.
Threat Model and Assumptions: We seek to enable le-
gitimate use of third party applications to process secret
user data, while preventing accidental and malicious data
disclosure to the network. For this purpose, our solution,
Weir, must mediate network access, and track ﬂows of
secret data 1) among applications and 2) to/from storage.
Weir’s trusted computing base (TCB) consists of the
Android OS (i.e., kernel and system services), and core
network services (e.g., DNS). Weir assumes a non-rooted
device, as an adversary with superuser privileges may
compromise OS integrity.
Further, we assume cor-
rect policy speciﬁcation by the data owner applications,
speciﬁcally regarding declassiﬁcation. To prevent timing
and covert channels based on shared hardware resources
(e.g., a hardware cache), the only alternative is denying
data access to secret data or the shared resource. Weir
does not defend against such channels, which are notori-
ously hard to prevent in DIFC OSes in general.

2.2 Why Information Flow Control (IFC)?
Android uses its permission framework to protect user
data. While permissions provide protection at the ﬁrst
point of access, the user or the data owner application
(e.g., OfﬁceEmail) have no control over the ﬂow of data
once it is shared with another application (e.g., WPS Of-
ﬁce). Unauthorized disclosure is an information ﬂow
problem that permissions are not designed to solve.

Information ﬂow control (IFC) [8] can provide data
secrecy and prevent unauthorized disclosure, through the
deﬁnition and enforcement of the allowable data ﬂows in
the system. In an IFC system, subjects (e.g., processes)

1120  25th USENIX Security Symposium 

USENIX Association

and objects (e.g., ﬁles) are labeled with predeﬁned se-
curity classes (e.g., top-secret, secret, conﬁdential). The
secrecy policy determines the data ﬂow (i.e., ordering)
between any two classes based on a partially ordered ﬁ-
nite lattice. Labels may also be joined to form a higher
label in the lattice. For secrecy, data can only ﬂow up,
i.e., to a higher security class [6], and violating ﬂows re-
quire declassiﬁcation by the policy administrator.

2.3 What is DIFC?
A centralized IFC policy can only describe the secrecy
constraints for well-known data objects (e.g., location,
IMEI). Decentralized IFC (DIFC) [26] extends the IFC
lattice to include unknown subjects and objects, and is
appropriate for protecting application-speciﬁc data, such
as Alice’s secret report received by OfﬁceEmail. We now
describe some fundamental aspects of DIFC.
Label Deﬁnition: In a DIFC system, security principals
create labels (i.e., security classes) for their own secret
data. On Android, decentralized label deﬁnition would
allow apps to control the ﬂow of their data by creating
and managing labels for their data. Note that while DIFC
also provides integrity, our description is for data secrecy
as it is the most relevant to the problem in Section 2.1.
Label Changes and Floating Labels: The ﬁnality of
subject and object label assignment is called tranquil-
ity [6], a property of mandatory protection systems.
Tranquility constraints have to be relaxed for DIFC pol-
icy. Subjects may then change (raise or lower) their la-
bels “safely”, i.e., with authorization from the data own-
ers whose security classes are involved in the change.

Explicit label changes offer ﬂexibility over immutable
labels, but are not practical in environments where com-
munication is user-directed and unpredictable a priori.
Floating labels (e.g., in Asbestos [44]) make DIFC com-
patible with unmodiﬁed apps in such cases, by allowing
seamless data ﬂows through implicit label propagation.
That is, the caller’s and the callee’s labels are joined, and
the resultant label is set as the callee’s label.
Declassiﬁcation: The network is considered to be pub-
lic, and any network export requires declassiﬁcation by
the data owner. Data owners may choose to explicitly
declassify every request to export their data, or allow
trusted third parties to declassify on their behalf. While
the former is impractical when frequent declassiﬁcation
is required, the latter bloats the data owner’s TCB.
System Integration: One of the ﬁrst steps while inte-
grating data secrecy into an existing OS is the selec-
tion of the subject for data ﬂow tracking. Fine-grained
dynamic taint tracking (e.g.,TaintDroid [13]) labels pro-
gramming language objects to provide precision, but
does not protect against implicit ﬂows. OS-based DIFC

approaches [21, 49] adopt the better mediated OS pro-
cess granularity, but incur high false positives; i.e., func-
tions sharing the process with unrelated functions that
read secret data may be over-restricted. While secure
process-level labeling is desired, practical DIFC enforce-
ment must minimize its impact on functionality.

Instantiation:

2.4 Android Background
The Android application model consists of four com-
ponents, namely activities for the user interface (UI),
services for background processing, content providers
to provide a uniform interface to application data, and
broadcast receivers to handle broadcast events.
Component
Services and content
providers run in the background, and have one active in-
stance. Activities can have multiple instances, and the
default “standard” launch behavior for activities is to
start a new instance per call. Developers use Android’s
“android:launchMode” manifest attribute to manage ac-
tivity instances as follows: SingleTop activities are re-
sumed for new calls if they already exist at the top of
the activity stack. SingleTask and SingleInstance activi-
ties are similar in that they are allocated an instance in a
separate user task and every call to such an activity re-
sumes the same instance; the only difference being that
the latter can be the only activity in its task.
Inter-Component Communication:
Inter-component
communication on Android can be 1) indirect or 2) di-
rect.
Indirect communication is an asynchronous call
from one component to another, through the Activity
Manager service (e.g., startActivity, bindService). Di-
rect communication involves a synchronous Binder re-
mote procedure call (RPC) to the callee using the callee’s
“Binder object”. While direct communication bypasses
the Activity Manager, its setup involves one mediated in-
direct call to retrieve the callee’s Binder object. For ex-
ample, the ﬁrst operation executed on a content provider
(e.g., query, update) by a caller is routed through the
Activity Manager, which retrieves the content provider’s
Binder object and loads it into the caller’s memory. Fu-
ture calls are routed directly to the content provider.

3 DIFC Challenges on Android

In this section, we discuss the four aspects of Android
that make DIFC enforcement challenging. Further, we
describe how previous Android DIFC systems fare with
respect to the challenges, and state the design goals for
practical DIFC enforcement on Android.
1. Multitasking on Android: Android’s UI is organized
into user tasks representing the user’s high-level objec-
tives. An application can be involved in multiple tasks

USENIX Association  

25th USENIX Security Symposium  1121

Process Boundaries

secret.pdf

WPS Ofﬁce
PDF Activity

secret.pdf

Evernote
Create Note

public.pdf

WPS Ofﬁce
PDF Activity

public.pdf

WPS Ofﬁce
Print Activity

Task 1

Task 2

Figure 1: Shared state in memory: Instances of WPS Of-
ﬁce performing different tasks in the same process.

by default. Further, a default activity can be instantiated
multiple times in one or more concurrent tasks [3].

Figure 1 shows two tasks. In Task 1, the user opens
a secret PDF (e.g., a contract) with WPS Ofﬁce, which
loads it in its PDF Activity, and shares it with the Ever-
note app. In Task 2, the user opens a non-conﬁdential
PDF (e.g., a published paper) in another instance of
WPS Ofﬁce’s PDF Activity. Further, in Task 2, the user
chooses to print the PDF, which is then sent to WPS Of-
ﬁce’s internal Print Activity. As seen in Figure 1, multi-
ple activities of the WPS Ofﬁce app as well as multiple in-
stances of the PDF Activity run in the same process, and
may share data in memory (e.g., via global variables).

As the two instances of the PDF Activity are instan-
tiated with data of different secrecy requirements (i.e.,
secret.pdf and public.pdf), they run in different secrecy
contexts. Enforcing the DIFC policy on the process due
to the sensitive nature of Task 1 would also unjustiﬁ-
ably restrict the non-sensitive Task 2. A naive solution
of forcing every component to start in a separate process
may break components; e.g., Print Activity may try to
access a global variable initialized by the PDF Activity,
and may crash if the PDF Activity is not in the same pro-
cess. To summarize, component instances in various se-
crecy contexts often share state in process memory, mak-
ing process-level enforcement challenging.
2. Background components: As described in Sec-
tion 2.4, service and content provider components have
only one active instance, which is shared among all of an
application’s instances, and may also communicate with
other applications. As a result, various secrecy contexts
may mix in a single background component instance.

If ﬂoating labels (described in Section 2.3) are applied,
then the background component may accumulate the la-
bels of all the secrecy contexts it communicates with,
and then propagate its new label back to the components
connected to it. This results in a label explosion, where
the entire system acquires a large, restrictive label that
cannot be declassiﬁed by any single security principal.
Note that background components may run in the shared
application process by default. Therefore, restarting a
background component’s process for each new call is in-
feasible, as it would crash the other components (e.g., a

foreground activity) running in that process.
3.
Internal and External Application storage: An-
droid provides each application with its own internal
(i.e., private) storage shared amongst all of its runtime
instances, irrespective of the secrecy context. For ex-
ample, both the sensitive and non-sensitive instances of
WPS Ofﬁce may access the same user settings in the
application’s private directory. For availability from all
secrecy contexts, storage access enforcement uses ﬂoat-
ing labels. The propagation of sensitive secrecy labels
through shared application ﬁles (i.e., shared state on stor-
age) may cause label explosion. The risk and impact of
label explosion is higher on the external storage (i.e., the
SD card) shared by all applications.
4. Internet-driven environment: Android applications
are often connected to the Internet. In such an environ-
ment with frequent network export, explicit declassiﬁ-
cation by the data owner is inefﬁcient. Delegation of
the declassiﬁcation privilege to allow export without the
owner’s intervention would bloat the application’s TCB.
Additionally, existing declassiﬁcation mechanisms de-
scribed in Section 2.3 make the policy decision based
on the identity of the security principal performing the
export. On Android, such mechanisms would limit the
user to using a small subset of applications for data ex-
port (i.e., out of the 2 million applications on Google
Play [39]), which would be detrimental to adoption of
DIFC on Android.

3.1 Prior DIFC Proposals for Android
We discuss three prior DIFC proposals for Android,
namely Aquifer [28], Jia et al. [19] and Maxoid [46], all
of which are OS-level DIFC systems. Our objective is
to understand the design choices made by these systems,
with respect to the challenges described previously.
1. Aquifer: Our prior work, Aquifer [28], provides pro-
tection against accidental data disclosure, by tracking the
ﬂow of data through applications, and enforcing the de-
classiﬁcation policy for network export.

For seamless data sharing between applications,
Aquifer uses the ﬂoating labels described in Section 2.3.
To limit label explosion, Aquifer does not label back-
ground components, and hence can only prevent acci-
dental data disclosure. On the other hand, Aquifer la-
bels storage, but does not claim to mitigate label explo-
sion on storage. Further, to prevent different secrecy re-
quirements for data in the memory of a single process,
Aquifer disables Android’s multi-tasking and restarts the
process of the existing instance when the application is
called from another secrecy context. Finally, Aquifer’s
declassiﬁcation policy allows the data owner to explic-
itly specify the security principal that may export data,

1122  25th USENIX Security Symposium 

USENIX Association

or a condition on the call chain for implicit export.
2. Jia et al.: The DIFC system by Jia et al. [19] also
uses ﬂoating labels to support general-purpose applica-
tions, but supports strict secrecy policies (i.e., relative to
Aquifer) that may restrict data sharing among applica-
tions if needed.

Contrary to Aquifer, the system propagates labels to
background components, providing stronger protection
against malicious data exﬁltration. At the same time, the
system makes no claims of controlling label explosion
via background components or storage. The system uses
Flume’s capabilities [21] for declassiﬁcation. This work
also acknowledges the challenge of multi-tasking along
with DIFC enforcement, and disallows multi-tasking by
blocking new calls to an application until all of its com-
ponents voluntarily exit. Since Android components do
not exit by themselves like conventional OS programs,
such blocking could potentially lead to deadlocks.
3. Maxoid: Xu and Witchel [46] provide an alternate ap-
proach to ﬁle system labeling to prevent label explosion
in Maxoid, by using ﬁle system polyinstantiation [22] to
separate differently labeled data on disk.

Maxiod addresses new calls to existing labeled in-
stances in a manner similar to Aquifer’s; i.e., by restart-
ing the instance. Additionally, Maxoid prevents access to
background components from labeled instances, thereby
preventing label explosion, although at the cost of back-
wards compatibility. On the other hand, Maxoid consid-
ers overt data ﬂows through Binder IPC as declassiﬁca-
tion, unlike the system by Jia et al.
that mediates such
communication. Finally, Maxoid modiﬁes system con-
tent providers (e.g., Contacts) to use a SQL proxy, in
order to extend its label separation into system content
providers. As a result, Maxoid’s storage separation is
unavailable for use by content providers in unmodiﬁed
third party applications.
Takeaways: Prior approaches demonstrate the possibil-
ity of DIFC on Android, and make convincing arguments
in favor of using ﬂoating labels, mainly for backwards
compatibility with Android’s unpredictable data ﬂows.
At the same time, we observe that in prior systems it
becomes necessary to relax either security or backwards
compatibility in order to use ﬂoating labels on Android
(e.g., with background components). Additionally, prior
approaches recognize the need to separate different se-
crecy contexts in process memory, but the proposed so-
lutions disable Android’s default multi-tasking.2 Finally,
in systems that aim to address label explosion on storage,
only separating the shared state on storage without ad-
dressing the shared state in memory may be insufﬁcient
to support unmodiﬁed applications.

2Killing existing processes or blocking can result in the killing of
unrelated components sharing the process, or deadlocks, respectively.

3.2 Design Goals
Our objective is to design DIFC enforcement that pro-
vides security, and is backwards compatible with unmod-
iﬁed applications. Our design goals are as follows:
G1 Separation of shared state in memory. DIFC en-
forcement must ensure that data from different
secrecy contexts is always separated in memory,
preferably in the memory of different processes.
Process-level enforcement can then be used to me-
diate ﬂows between differently labeled data.

G2 Separation of shared state on storage. DIFC en-
forcement must ensure that data from different se-
crecy contexts is separate on persistent storage. For
mediation by the OS, the separation must be at the
level of OS objects (e.g., ﬁles, blocks).

G3 Transparency. A naive implementation of goals G1
and G2 would affect the availability of components
and storage. Our system must be transparent, i.e.,
applications that do not use the DIFC system must
be able to operate oblivious to the enforcement.

G4 Secure and practical declassiﬁcation for network
export. A DIFC system on Android should provide
a declassiﬁcation primitive that is both feasible (i.e.,
does not hinder the use of applications) and secure.

4 Weir

In this paper, we propose Weir, a practical and secure
DIFC system for Android. Weir’s design is guided by the
security and backwards compatibility goals described in
Section 3.2. We now brieﬂy describe the speciﬁc proper-
ties expected from our design, followed by an overview
of Weir and design details.
Design Properties: Taking a lesson from prior work in
Section 3.1, our system must allow seamless data shar-
ing between applications for backwards compatibility
with Android’s application model. Data ﬂows must be
tracked using implicit label propagation (i.e., ﬂoating la-
bels), while mitigating the risk of label explosion. More
speciﬁcally, our system must not deny data access, unless
an application explicitly changes its label and fails a la-
bel check. Since our goal is to prevent unauthorized data
export, network access may be denied if an application
tries to export sensitive data to the network in violation
of the declassiﬁcation requirements of the data owner.
Finally, our system must mediate all overt data ﬂows, but
covert channels existing in Android are not the targets of
our system (discussed further in Section 9).

4.1 Overview
In Weir, applications deﬁne the policy for their data by
creating their own security classes. Weir labels ﬁles (as

USENIX Association  

25th USENIX Security Symposium  1123

P
{LP}

P
{LP}

P
{LP}

X

Q
{LQ}

Q

{LQ} --> {LPLQ}

Q
{LQ}

Q1

{} --> {LP}

World A

Explicit labels

World B

Floating labels

World C

Floating labels with
Polyinstantiation

Figure 2: Overview of ﬂoating labels w/ polyinstantia-
tion relative to explicit and ﬂoating labels.

objects) and processes (as subjects), granting the ker-
nel complete mediation over all data ﬂows among sub-
jects and objects. As Weir’s contributions are in its
policy-agnostic mechanism, we use the generic terminol-
ogy from Section 2.3 in policy-related discussions. Sec-
tion 5.1 describes our implementation’s policy model.

Weir uses ﬂoating labels (described in Section 2.3),
as explicit labels are hard to assign a priori in An-
droid, where data ﬂows are often user-directed and un-
predictable. However, naive (i.e., context-insensitive)
ﬂoating label propagation can cause certain components
to acquire more labels due to involvement in multiple
secrecy contexts, and eventually become unusable. We
propose polyinstantiation to make ﬂoating labels con-
text sensitive, and hence separate the shared state from
different secrecy contexts in memory (G1) and on stor-
age (G2). Our approach is in principal similar to context
sensitive inter-procedural analysis that adds precision by
considering the calling context when analyzing the tar-
get of a function call (e.g., summary functions and call
strings [36], k-CFA [37], and CFL-reachability [31]). To
our knowledge, context sensitivity has not been explored
in the scenario investigated in this paper. Further, the ap-
proach of secure multi-execution [11] also uses multiple
executions of the program, but is fundamentally different
in many aspects, as we describe in Section 10.

We describe polyinstantiation relative to explicit and
ﬂoating labels with the example scenario in Figure 2,
where an instance of component P with label {LP} tries
to send a message to an instance of component Q with a
label {LQ}, and where {LP} 6= {LQ}. In World A where
only explicit labels are allowed, the message would be
denied as Q would not be able to explicitly change its la-
bel to {LP} without a priori knowledge of P0s intention
to send a message. In World B with ﬂoating labels, the
ﬂow would be automatically allowed, with Q0s new label
implicitly set to a join of the two labels. While World B
allows seamless communication, it does not prevent the
two secrecy contexts (i.e., {LP} and {LQ}) from mixing,
leading to the challenges we explored in Section 3. In
World C, we use polyinstantiation along with ﬂoating la-
bels, and a new instance of Q denoted as Q1 is created

in the caller’s context (i.e. with the caller’s label {LP}),
separate from the original instance of Q with label {LQ}.
Thus, our approach allows the call to take place, without
the mixing of secrecy contexts. The “lazy” aspect of our
approach (not represented in the ﬁgure) is that we would
reuse a previously created instance of Q, denoted Qpast,
if its label matched the caller’s label (i.e., {LP}). Addi-
tionally, while the new instance has an empty label (i.e.,
{}) as the base (compile-time) label in our prototype, our
model can be adapted to support a different base label.
Weir uses lazy polyinstantiation for all indirect inter-
component calls (e.g., starting an activity, querying
a content provider) (described in Section 2.4). Weir
polyinstantiates processes, Android components and the
ﬁle system, creating new instances of each for different
secrecy contexts. Floating labels allow legacy apps to
integrate into Weir without modiﬁcation for making or
receiving calls, while polyinstantiation adds context sen-
sitivity. Weir’s use of ﬂoating labels supports process-
level labeling along with application multi-tasking (G3),
a more practical solution than the alternatives of killing
existing instances [28, 46] or indeﬁnite blocking [19].

We now describe Weir’s polyinstantiation of memory,
followed by storage. We then discuss how Weir supports
explicit label changes. Finally, we describe how Weir’s
domain declassiﬁcation satisﬁes goal G4.

4.2 Polyinstantiation of Memory
To satisfy goal G1, Weir must ensure that no two com-
ponent instances with mismatching labels execute in the
same process. At the same time, Weir must make com-
ponents available if the underlying Android enforcement
(i.e., permission framework) allows. Therefore, our ap-
proach polyinstantiates both components and processes
to make them available in multiple secrecy contexts.

For backwards compatibility, our approach refrains
from affecting developer conﬁgurations (e.g., by forc-
ing the “multi-process” manifest attribute).
Instead,
Weir polyinstantiates components within the applica-
tion’s own context. Speciﬁcally, Weir upholds the pro-
cess assignments made for components by the developer,
through the “android:process” manifest attribute (i.e., the
component’s processName). That is, Weir ensures that
components that were meant to run together (i.e., as-
signed the same processName), still run together . We
now describe our approach, followed by an example.
Our approach: On every call, Weir retrieves the label of
the caller (i.e., the callerLabel). Weir then checks if an
instance of the desired component is running in a process
whose label matches callerLabel. If one is found, the call
is delivered to the matching instance. If not, Weir creates
a new instance of the called component.

When the target component instance is assigned, Weir

1124  25th USENIX Security Symposium 

USENIX Association

"procActivity" ;

label = {}
A

startActivity

label={}

"procService"; 

label = {}

C

B

startService

label={}

startActivity

label={}

(a) Step 1: A is called from an empty label.

"procActivity" ;

label = {}
A

startActivity

label={}

"procActivity_0" ;

label = {L1}
A

startActivity
label={L1}

startActivity

label={}

startActivity
label={L1}

B

B

"procService"; 

label = {}

C

startService

label={}

"procService_0"; 

label = {L1}

startService
label={L1}

C

(b) Step 2: A is called from a label = {L1}.

"procActivity" ;

label = {}
A

startActivity

label={}

"procActivity_0" ;

label = {L1}
A

startActivity
label={L1}

startActivity

label={}

startActivity
label={L1}

B

B

"procService_1"; 

label = {L2}

bindService
label={L2}

C

"procService"; 

label = {}

C

startService

label={}

"procService_0"; 

label = {L1}

startService
label={L1}

C

(c) Step 3: C is called from a label = {L2}.

Figure 3: Weir’s lazy polyinstantiation of three app com-
ponents; activities A and B, and a service C.

must ﬁnd a process to execute it. If the process associ-
ated with this component (i.e., processName) has a dif-
ferent label, Weir cannot execute the new instance in it,
and has two options: a) assign a polyinstantiated process
that is associated with processName and has the label
callerLabel or 2) create a new process associated with
the processName with label callerLabel. As it is evident
based on the ﬁrst option, Weir keeps track of a process-
Name and all its instances created for various secrecy la-
bels. Weir can then reuse a previously instantiated pro-
cess that is associated with the original processName and
already has the required label (i.e., lazy polyinstantia-
tion). Additionally, Weir can ensure adherence to the
developer’s process assignment; i.e., that component in-
stances only execute in the process associated with their
processName.
If a matching process is not available,
Weir creates a new process for callerLabel, and internally
maintains its association with the original processName.
Example: Consider an app with three components, ac-
tivities A and B, and a service C. The developer sets the
processName for A and B to be “procActivity”, whereas
the processName for C is set to “procService”. This
means that A and B are expected to run in the same pro-
cess, while C runs in a separate process. The app is pro-
grammed such that when A is started, it starts B, follow-
ing which B starts C. Using Figure 3, we describe Weir’s
instantiation of A, B, and C and their processes.

In Step 1 (Figure 3a), A is ﬁrst called by an unlabeled
caller; i.e., the callerLabel is empty. A new instance of A

is created, and a new process by the name “procActivity”
is started for it. Then, A calls B. The label of A0s process
is empty, so B is also instantiated with an empty label, in
the matching process, i.e., “procActivity”. B then calls C,
which is instantiated in the new process “procService”.
In the Step 2 (Figure 3b), A is called from a caller with
callerLabel = {L1}. Weir cannot deliver the call to the
existing instance of A, as its process has a mismatching
label (i.e., callerLabel = {L1} 6= {}). Thus, Weir creates
a new instance of A for this call. As there are no pro-
cesses associated with “procActivity” and with the label
{L1}, Weir also allocates a new process “procActivity 0”
to host this instance. Thus, for this call, a new instance
of A is started in a new process “procActivity 0”, whose
label is set to {L1}. When this instance of A calls B, the
call is treated as a call to B with callerLabel = {L1}, the
caller being A0s new instance with label {L1}. As Weir
keeps records of all the processes created for polyinstan-
tiation, it starts a new instance of B in the process that
is associated with B’s original process “procActivity”,
and has a matching label {L1}, i.e., “procActivity 0”.
Reusing an existing process instance is an example of
“lazy” polyinstantiation. When this instance of B starts
C, Weir creates a new instance of C due to mismatching
labels, in a new process “procService 0” with label {L1}.
In Step 3 (Figure 3c), bindService is called on C with
the label callerLabel = {L2}. Since the caller’s label
{L2} mismatches with the two existing instances of C
that are running with labels {} and {L1}, a new instance
of C is created. As there are no processes associated with
“procService” that have a label matching {L2}, a new
process “procService 1” is created to host the new in-
stance. Note that all of these instances and processes
exist simultaneously, as shown in the ﬁgures.
If C is
called again with the label callerLabel = {L2}, Weir will
not have to create a new instance, and the call will be
delivered to the existing instance of C running in pro-
cess “procService 1” with the matching label {L2} (i.e.,
“lazy” polyinstantiation).

Weir’s approach maintains context-based separation in
memory (G1), and also ensures that components conﬁg-
ured to run in the same process still run together; i.e.,
our approach is transparent to the application, satisfying
goal G3. For example, instances of A and B exist to-
gether, both in the labeled as well as the unlabeled con-
texts. Weir supports all Android components declared
in the application manifest, i.e., activities, services, con-
tent providers and broadcast receivers. An exception is
broadcast receivers registered at runtime, which are in-
stantiated at registration in the secrecy context of the reg-
istering process, and hence not subject to further instanti-
ation. Any future broadcasts to such receivers are treated
as direct calls subject to strict DIFC label checks.

USENIX Association  

25th USENIX Security Symposium  1125

4.3 Polyinstantiation of Storage
To prevent restrictive labeling of shared storage by
processes running in sensitive contexts, Weir extends
context-based separation to the storage as well (G2).
Weir achieves this separation without denying access to
instances in sensitive secrecy contexts (G3).
Our approach: Weir separates shared state in the inter-
nal and external storage using ﬁle-system polyinstanti-
ation via a layered ﬁle system approach [29]. Our ap-
proach is similar to Solaris Containers [22], and more re-
cently, Docker [24]. Context-sensitive storage separation
has also been used previously in DIFC, for known persis-
tent data objects. For example, in their DIFC system for
the Chromium Web browser, Bauer et al. create context-
speciﬁc copies of bookmarks to prevent a restrictive label
from making bookmarks unusable [5].

In Weir, every secrecy context receives its own copy-
on-write ﬁle system layer. Processes running in a par-
ticular secrecy context have the same view of the ﬁle
system, which may be different from those running in
other contexts. All ﬁle operations are performed on the
context-speciﬁc layer attached to a process, which relays
them to the underlying ﬁle system (i.e., the default layer).
Unlabeled processes are assigned the default layer.

For simplicity, new layers are always created from
the default layer, and never from existing labeled layers.
That is, for any layer with label L, the copy-on-write al-
ways occurs from the default layer (with label {}), and
not another lower layer (say label L1), even if L1 is lower
than L (i.e., L1 ✓ L). An alternate design choice of using
a non-default lower layer for copy-on-write could lead
to conﬂicts due to incompatible copies of data at differ-
ent, but similarly labeled lower layers. For example, two
labels L2 and L3 might be at the same level below L in
the DIFC lattice, but may have different copies of the
same ﬁle. For resolving such conﬂicts, the system may
have to either involve the user or the application. The
backwards compatibility and usability effects of choos-
ing a lower layer need further exploration, although it
may be a more ﬂexible option. Hence, our design sim-
pliﬁes the potential choice between contending layers by
always choosing to copy from the default layer.

For efﬁciency, a layer only stores the changes made
to the default layer by processes in the layer’s secrecy
context (i.e., copy-on-write). When a ﬁle present in the
default layer is ﬁrst written by a process attached to a
non-default layer, the ﬁle is ﬁrst copied to the non-default
layer and then modiﬁed. Future accesses for the ﬁle from
that context are directed to its own copy. When a process
attached to a non-default layer tries to read a ﬁle that
has never been modiﬁed in the calling process’s layer, it
reads the original ﬁle on the default layer. Weir’s storage
approach is an extension of its lazy polyinstantiation, i.e.,

"procService"; 

label = {}

"procService_0"; 

label = {L1}

C

read/write

C

read

"procService"; 

label = {}

C

read/write

"procService_0"; 

label = {L1}

C

write

Shared
Prefs

Layer (L1)

Shared
Prefs

copy

Shared
Prefs

Layer (L1)

(a) Labeled instance reads.

(b) Labeled instance writes.

Figure 4: Weir’s storage polyinstantiation using layers.

new layers are created only when a process with a pre-
viously unknown secrecy context is initialized. Applica-
tions transparently access storage using any ﬁle system
API, and Weir directs the accesses to the correct ﬁles.

Weir stores the ﬁles copied to layers in layer-speciﬁc
copy-on-write directories. While creating such directo-
ries, Weir accounts for the security and availability re-
quirements of applications and users. For application-
speciﬁc internal storage, copy-on-write directories are
created in an area that is accessible only to instances of
the particular application. For public external storage,
Weir creates common label-speciﬁc copy-on-write direc-
tories in an area accessible to all apps. This approach
ensures that when an application is uninstalled, its data
on external storage is still available to the user.
Example: Figure 4 shows two instances of the compo-
nent C, one of which is running in the unlabeled secrecy
context (i.e., label {}), while the other has a label {L1}.
Weir sets up a ﬁle system layer, i.e., Layer (L1), to medi-
ate all ﬁle accesses by the labeled instance. Layer (L1) is
only attached to processes with label {L1}.
As seen in Figure 4a, initially, both the unlabeled and
labeled instances of C read from the shared preferences
ﬁle (i.e., SharedPrefs). That is, Layer (L1) relays all the
read requests by the labeled instance of C for unmodiﬁed
SharedPrefs ﬁle to the default storage. Once the labeled
instance of C attempts to write to the SharedPrefs ﬁle,
Weir copies it to Layer (L1). This copy is used for all
future read or write accesses by instances with label (L1).
Security of copy-on-write directories: Weir ensures the
security of the layered directories through a combination
of ﬁle labeling and Linux permissions. File labels are ini-
tialized when ﬁrst written, to the writing process’s label.
Weir uses strict DIFC label checks for all successive ﬁle
accesses. Further, Weir prevents the implicit ﬂows due
to the presence or number (i.e., count) of such copy-on-
write directories. To address ﬂows through the presence
of speciﬁc copy-on-write directories, Weir uses random
directory names known only to the system. To prevent
ﬂows that make use of the number of such directories,
Weir creates the copy-on-write directories inside a parent
directory owned by Weir. The Linux permissions of this
parent directory are set to deny the read operation on it,
and hence cannot be used to list or count subdirectories.

1126  25th USENIX Security Symposium 

USENIX Association

Together with the polyinstantiation in memory, Weir’s
approach enables transparent separation of different se-
crecy contexts without modifying legacy apps.

4.4 Label Changes and Binder checks
A component instance’s label is implicitly set when it is
instantiated. Similarly, a ﬁle’s label is initialized when it
is ﬁrst written to. For all successive accesses (i.e., direct
Binder IPC and ﬁle reads/writes respectively), Weir does
not apply ﬂoating labels, but performs a strict DIFC label
check (i.e., data may not ﬂow to a “lower” label). Hence,
any label changes after initialization can only be explicit.
An application aware of Weir may change the label of
its instances by raising it (to read secret data), or low-
ering it (to declassify data), provided the change is le-
gal with respect to the policy for the security classes in-
volved in the change, as described in Section 2.3. For
example, to read secret data labeled with label {L1}, a
component instance may raise its label to {L1}, if it has
authorization (e.g., a capability) from the owner of {L1}
(see Section 5.1 for the policy syntax). We now describe
the problem caused by explicit label changes.
Problem of explicit label change: A component in-
stance may establish Binder connections with other in-
stances through the Activity Manager, and then use direct
Binder RPC. When an instance changes its label, its ex-
isting Binder RPC connections (established via indirect
communication, see Section 2.4) may be affected. That
is, its new label may be higher or lower relative to the
instances it is connected to. Hence, it may not be able to
send or receive data on existing connections due to the
strict DIFC check on Binder transactions. An explicit
label change may also make the component instance’s
context inconsistent with its attached storage layer. At
the same time, explicit label changes are unavoidable in
applications that use Weir.
Our solution: Weir provides applications with the in-
tent labeling mechanism, i.e., components can label calls
(i.e., intent messages), before they are sent to the Activ-
ity Manager service, ensuring that the target component
is instantiated with the label set on the intent. In fact, a
component may instantiate itself with the desired secrecy
label by specifying itself as the intent’s target. Intent la-
beling eliminates the need for explicit label changes.
Security of Intent Labeling: Weir does not blindly trust
the label set on the intent, as applications may otherwise
abuse the mechanism for unauthorized declassiﬁcation.
For example, a malicious component with the label {L1}
may add secret data to an intent, and set an empty la-
bel (i.e., {}) on the intent before calling itself with it.
To account for such malicious use cases, Weir checks if
the calling application would be authorized to explicitly
change its current label to the label on the intent, as per

the policy (see Section 5.1). A call with a labeled intent
may proceed only if the caller passes the check.

While we have not encountered use cases that can-
not be expressed using intent labeling, our implemen-
tation allows explicit label changes, mainly for expert
developers who may want to make temporary changes
to their instance labels. Explicit label changes must be
used with caution, as our design does not account for
the problems due to label change after instantiation (e.g.,
dropped Binder calls), since labels do not ﬂoat to existing
Binder connections and ﬁles to prevent label explosion
(explained in Section 3).

4.5 Domain Declassiﬁcation
Problems with traditional network declassiﬁcation are
rooted in the decision to declare trust in the exporting
subject, as discussed in Section 3. More precisely, in an
internet-driven environment, it may be more practical for
the data secrecy enforcement to reason about where the
data is being delivered, rather than who is performing the
export. Weir introduces the alternative of domain declas-
siﬁcation to allow data owners to articulate trust in terms
of the receiver, i.e., the target Web domain. Weir allows
the data owner to associate a set of network domains (tD)
with its security class (t). When the data in context {t}
is to be exported to the network, Weir’s enforcement im-
plicitly declassiﬁes t, if the destination domain is in tD.
The data owner is neither required to explicitly declassify
nor trust the exporting application.

In Section 8, we discuss an example where the en-
terprise only wants data to be exported to a set of en-
terprise domains, irrespective of the application export-
ing it. Such a policy allows the user to use the same
email application for both the personal and work ac-
count, but prevents accidental export of work data to the
personal SMTP server. Domain declassiﬁcation not only
addresses the goal of practical declassiﬁcation in a net-
work driven environment (G4), but also prevents the user
from accidentally exporting data from a trusted applica-
tion, but to an untrusted server.

Weir is not

the ﬁrst IFC system to use domains
for declassiﬁcation, although most prior systems to
do so consider domains as security principals (e.g.,
COWL [41], Bauer et al. [5]). For instance, COWL con-
ﬁnes JavaScript using a declassiﬁcation policy analogous
to the well-known same origin policy (SOP), i.e., code
executes in the context of its origin, and hence possesses
the declassiﬁcation privilege for export to the origin’s
Web domain. In this case, the origin Web domain is a
ﬁrst class security principal, as it has physical presence
on the device in the form of the code running in its con-
text. Thus, in COWL, the declassiﬁcation privilege is
still expressed in terms of the security principal that is
sending the data (i.e., the origin). On Android, there is

USENIX Association  

25th USENIX Security Symposium  1127

no direct correlation between Web domains and appli-
cations; i.e., Web domains do not have code executing
in their context on the device, and hence are not secu-
rity principals. Thus, Weir’s approach of expressing trust
in the receiver of the data (i.e., the Web domain) rather
than the sender is indeed unique among OS-level DIFC
systems where Web domains may not be security prin-
cipals [1, 21, 28, 49]. Hails [15], an IFC web framework
for user privacy, may be closer to Weir’s approach, as it
allows users to declassify their data for speciﬁc domains.
Hails users are prompted to explicitly declassify when
network requests to disallowed domains are ﬁrst made,
which may not be feasible on Android (see Section 3).

Weir’s enforcement is limited to the device, and may
not defeat an adversary controlling the network. While
we leave this aspect relaxed for our threat model, we note
that DNSSEC or IPsec could be used in such scenarios.

Implementation

5
We implemented Weir on Android v5.0.1, and the An-
droid Kernel v3.4. This section describes the essential
aspects of our implementation. The source code can be
found at http://wspr.csc.ncsu.edu/weir/.

5.1 Weir’s DIFC Policy
Weir derives its policy structure from the Flume DIFC
model [21], which consists of tags and labels. A data
owner (O) application deﬁnes a security class for its sen-
sitive data in the form of a secrecy tag (t). A set of tags
forms a secrecy label (S). Weir enforces the IFC secrecy
guarantee, i.e., “no read up, no write down” [6]. Informa-
tion can ﬂow from one label to another only if the latter
dominates, i.e., is a superset of the former. For instance,
data can ﬂow from a process P to a process Q if and only
if SP ✓ SQ. Weir applies this strict DIFC check to direct
Binder communication and ﬁle accesses.
Each tag t has associated capabilities, namely t+ (for
reading) and t− (for declassiﬁcation), which data owners
delegate to speciﬁc apps, or all other apps (i.e., the global
capability set G). At any point of time, a process P has
an effective capability set composed of the capabilities
delegated to its application (CP), and the capabilities in
+ by adding a tag t if
G. P can change its label SP to SP
and only if t+ 2 CP[G. Similarly, P can change its label
SP to SP− by removing a tag t if and only if t− 2 CP [ G.
As the network interface is untrusted, it has an empty
label, i.e. SN = {}. Thus, a process P must have an
empty label (i.e., SP = {}), or the ability to change its
label to SP = {} to create a network connection, i.e.,
8t 2 SP,t− 2 CPtG. Additionally, Weir extends Flume’s
syntax with the domain declassiﬁcation capability tD,
which is a set of trusted Web domains for tag t speci-
ﬁed by the owner O. For a network export to a domain
d 2 tD, t is implicitly declassiﬁed.

5.2 Component Polyinstantiation
When a component calls (i.e., sends an intent message
or queries a content provider), the Activity Manager
resolves the target component to be called using the
static information present in the application manifest.
Weir does not interfere with this intent resolution pro-
cess. Then, the Activity Manager chooses the actual
runtime instance of the resolved component, which is
where Weir’s polyinstantiation takes effect. That is, Weir
controls component instantiation, without modifying the
components themselves. Hence, Weir is compatible with
all developer manifest options, except ones that control
instantiation. Section 7.2 provides a compatibility eval-
uation for such options. For a detailed explanation on
Android’s component startup workﬂow and Weir’s com-
ponent instantiation logic, see Appendix A.

5.3 File-system Layering
We chose OverlayFS [29] over alternatives (e.g., aufs),
as it is in the Linux kernel (since v3.18). As the cur-
rent OverlayFS patch is incompatible with SELinux, we
set SELinux to monitoring mode. This is a tempo-
rary limitation, as OverlayFS developers are working to-
wards full integration [45], which is on SELinux’s Ker-
nel ToDo list as well [10]. Additionally, we could use a
ﬁne-grained block-level copy-on-write ﬁle system (e.g.,
BTRFS [32]). There are advantages to using such ﬁle
systems, as we describe in the trade-offs (Section 9).
Note that while we could get the Android Linux ker-
nel to compile with BTRFS, the build system support
tools that are required to build Android’s sparse-images
for BTRFS (e.g., ext4 utils for ext4) are missing.
Therefore, our prototype opts for OverlayFS, as it does
not require user-space support.

5.4 Process Initialization
On Android, the zygote process forks and prepares new
processes for applications. When a new process is
forked, Weir sets its secrecy label in the kernel, and uses
zygote to mount the appropriate storage layer to the pro-
cess’s mount namespace based on its label. If the pro-
cess has a non-empty label, Weir separates the process’s
mount namespace from the global mount namespace us-
ing the unshare system call, and mounts the appropriate
OverlayFS copy-on-write layer based on the label on top
of the unlabeled ﬁle system. New layers are allocated
when new labels are ﬁrst encountered. Weir maintains
the mapping between a label, its assigned layer and the
speciﬁc copy-on-write directories used for it.

5.5 Kernel Enforcement
Weir uses a Linux security module (LSM) to track the
security contexts of processes and ﬁles in the kernel. We

1128  25th USENIX Security Symposium 

USENIX Association

P
01
{L1}

Q1
{}

Q2
{}

Q
{}

P
01
{L1}

Q1
{L1}

0

Q2
{}

Q
{}

P
01
{L1}

Q1
{L1}

Q2
{}

1

Q
01
{}

(a) Initial State.

(b) P calls Q1

(c) Q2 calls Q

Figure 5: Floating label DIFC system: Q receives 1 and
guesses 0 for every reply not received.

integrated the multi-LSM patch [35] to enable concur-
rent SELinux and Weir enforcement. The security con-
text of a process contains its secrecy label and capabil-
ities, while that of a ﬁle only contains a secrecy label.
We now describe the enforcement for ﬁle access, Binder
communication and network access, as follows:
1. Files: Weir uses the ﬁle permission LSM hook to me-
diate each ﬁle read and write access. The secrecy label
of a ﬁle (stored in the xattrs) is initialized from the label
of the process that ﬁrst writes it.
2. Binder: Weir mediates Binder transactions in the ker-
nel using the Binder LSM hooks. For compatibility, Weir
whitelists Binder communication with Android system
services in the kernel. To prevent apps from misusing
whitelisted services as implicit data channels, we manu-
ally analyzed all system service API, and modiﬁed API
that may be misused, e.g., the Clipboard Manager service
provides label-speciﬁc clipboards in Weir.
3. Network: Weir mediates the socket connect and bind
operations in the kernel. The tags in the calling process’s
label that cannot be declassiﬁed using its capability set
are sent to Weir’s system service in the userspace via
a synchronous upcall, along with the IP address of the
destination server. Weir’s system service then resolves
the domain name from the IP address, which is challeng-
ing, as a reverse DNS lookup may not always resolve to
the same domain used in the initial request. Fortunately,
Android proxies all DNS lookups from applications to
a separate system daemon. We modify the daemon to
notify Weir when a process performs a DNS lookup, in-
cluding the domain name and the IP address returned.
During the domain declassiﬁcation upcall, this mapping
is referenced to identify the destination domain. Weir al-
lows the connection only if all the tags in the upcall can
be declassiﬁed for that domain.

6 Security of Polyinstantiation

Floating labels were ﬁrst predicted to be prone to infor-
mation leaks by Denning [8]. While language-level ﬂoat-
ing label IFC models (e.g., COWL [41] and LIO [40,42])
can mitigate such leaks, securely using ﬂoating labels is

0

P
01
{L1}

Q1
{L1}
Q1
{}

Q2
{}

Q
{}

P
01
{L1}

Q1
{L1}
Q1
{}

Q2
{}

1

1

Q
11
{}

(a) Q1 is polyinstanti-
ated
Figure 6: Weir: Q always receives data “11”

(b) Unlabeled Q1 and
Q2 send 1 to Q.

still a challenge for OS-level DIFC systems (e.g., IX [23]
and Asbestos [44]). We discuss an attack on an OS-
level ﬂoating label DIFC system, described in Krohn and
Tromer’s paper on the non-interference of Flume [20],
and show how Weir is resistant to such data leaks. We
use Android’s terminology to describe the attack.

We describe the attack twice; once in a ﬂoating label
system without polyinstantiation (Figure 5) and once in
Weir (Figure 6). Figure 5a shows the malicious compo-
nents (e.g., services) P, Q, Q1 and Q2. P has obtained the
data “01”, and the accompanying label {L1}. P wants to
transfer the data to Q, without Q obtaining the label {L1}.
Note that Q, Q1 and Q2 initially have the empty label {}.
Additionally, P and Q have a prior understanding that P
will call the ith service of Q to indicate “0” at the ith bit.
Q0s components are programmed to send a message to Q
after a predetermined time if they do not receive a mes-
sage from P (i.e., indicating a “1”). Since the ﬁrst data
bit is “0”, P sends “0” to Q1, whose label ﬂoats to {L1}
( Figure 5b). After a predeﬁned time, the component
that did not receive a message from P, i.e., Q2, sends a
“1” to Q (Figure 5c). The data leak is successful, as Q
knows that the second bit is “1”, and assumes the ﬁrst to
be “0”, all without acquiring the label {L1}. As Android
does not place any limits on the number of components,
a wider n bit channel is possible with n components.

Weir’s polyinstantiation defeats this attack by creating
a new instance of Q1 in a separate process to deliver a call
from a label that mismatches its own (Figure 6a). Next,
the unlabeled instance of Q1 and Q2 both call Q with data
“1”, as shown in Figure 6a. In fact, for n components of
Q, Q will always get n calls with data “1”, as Weir will
polyinstantiate all the components that have been called
by P with the label {L1}. Weir’s use of ﬂoating labels
is resistant to implicit ﬂows inherent to regular ﬂoating
labels, as labels do not ﬂoat to the original instance, but
to a new instance created in the caller’s context.

Jia et al [19] attempt to solve a similar problem,3 by
making the raised label the component’s base (i.e., static)
label. This defense allows the existing leak, but makes
the components that received the message (e.g., Q1) un-

3Refer to page 8 of the paper by Jia et al. [19] for details.

USENIX Association  

25th USENIX Security Symposium  1129

usable for future attacks. Attackers can be expected to
beat this defense by coordinating the components used
for every attack, and transfering signiﬁcant data before
all the components have restrictive static labels.

Finally, while polyinstantiation is resistant to data
leaks in ﬂoating labels, we leave the complete formal-
ization of this idea as future work. The intuition be-
hind the formalization is described as follows: Let L be
the type system corresponding to the labels (e.g., type-
system for ﬂoating labels) and S be the type system cor-
responding to information about stacks (e.g., for k-CFA
analyis strings of size k that capture information about
last k calls). Assume that we have inferencing/propoga-
tion rules for both type systems and they are sound. We
have an intuition that the combined system (denoted by
L ⇥ S ) is sound (the inferencing/propogation rules are
basically a combination of both rules).

7 Evaluation

Our evaluation answers the following questions about
Weir’s performance and compatibility:
Q1 Is Weir compatible with developer preferences that

manipulate component instantiation?

Q2 What is Weir’s performance overhead?
Q3 Is Weir scalable for starting components?
We now provide an overview of the experiments and
highlight the results. The rest of this section describes
each experiment in detail.

7.1 Experiment Overview and Highlights
Weir does not modify components, but only modiﬁes
their instantiation.
Thus, we evaluate compatibility
with options that control component instantiation (Q1),
i.e., the singleTop, singleTask and singleInstance activ-
ity launch modes described in Section 2.4. We trigger
the launch modes in popular Android apps from Google
Play, and record application behavior in unlabeled and la-
beled contexts. We did not observe any crashes or unex-
pected behavior. Every launch mode worked as expected,
while the underlying polyinstantiation ensured delivery
of calls to instances in the caller’s context.

We measure the performance overhead of Weir over
an unmodiﬁed Android (AOSP) build (Q2) with mi-
crobenchmarks for common operations (e.g., starting
components). Our comparison between the unmodiﬁed
build, Weir (unlabeled instance), and Weir (labeled in-
stance) in Table 1 shows negligible overhead. Even in
cases where the overhead percentage is large, the ab-
solute overhead value is negligible (<4ms). Further,
the negligible difference in the values of Weir’s labeled
and unlabeled instances (i.e., relative to the error) would
make a noisy covert channel at best.

As described in Section 5, for every call, Android’s in-
tent resolution gets the target component. The OS then
chooses a runtime instance from available instances of
the target. Hence, the total number of a component’s run-
time instances only affects its own start time. We eval-
uate the scalability of a component’s start time, when a
certain number of its instances already exist (Q3). Our
results in Figure 7 show a linear increase in the start time
with increase in the number of concurrent instances, and
low absolute values (e.g., about 56 ms for 100 instances).

7.2 Compatibility with Launch Modes
We randomly pick 30 of the top applications on Google
Play (i.e., 10 per launch mode, complete list available
at http://wspr.csc.ncsu.edu/weir/).
Methodology: For each launch mode, we ﬁrst launch
each application from two separate unlabeled compo-
nents, and navigate to the speciﬁc activity we want to
test. With this step, we conﬁrm that the application and
speciﬁcally the singleTask/Top/Instance activity works
as expected. Without closing existing instances, we start
the same application from a labeled context and repeat
the prior steps. We record any unexpected behavior.
Observations: We did not observe any unexpected be-
havior, and activities started in their assigned tasks. In
the case of singleTask and singleInstance activities, two
instances of the same activity ran in the designated task
instead of one; i.e., one labeled and the other unlabeled.
Intent messages were delivered to the activity instance
with the caller’s label. This behavior is compatible with
singleTask and singleInstance activities, and also main-
tains label-based separation in memory.

7.3 Microbenchmarks
We evaluate the performance of the operations affected
by Weir (i.e., ﬁle/network access, component/process
start) , on a Nexus 5 device. We perform 50 runs of each
experiment, waiting 200 ms between runs. Table 1 shows
the mean with 95% conﬁdence intervals. Cases with neg-
ative overhead can be attributed to the high error in some
operations. Speciﬁc experimental details are as follows:
Component and Process start: We measure the com-
ponent start time as the time from the placement of the
call (e.g., startActivity) till its delivery. The component is
stopped between runs. To measure the process start time,
we kill the process between subsequent runs. While the
overhead percentages may be high (e.g., for providers),
the absolute values are low, and would not be noticeable
by a user. Further, the process start time that includes
ﬁle-system layering in zygote shows minimal overhead.
File access: We perform ﬁle read and write operations on

1130  25th USENIX Security Symposium 

USENIX Association

Table 1: Performance - Unmodiﬁed Android (AOSP), Weir in unlabeled context, Weir in labeled context.

Operation
Activity start
Service start

Broadcast Receiver start
Content Provider start

Process start

File Read (1MB)
File Write (1MB)

Network

Weir (ms)

Overhead (ms)

AOSP (ms) Weir w/o label Weir w/ label Weir w/o label Weir w/ label
0.76 (3.79%)
20.06±4.47
3.42 (24.53%)
13.94±2.87
12.92±3.96
-1.06 (-8.2%)
4.54±2.28
3.36 (74.01%)
127.18±5.62
5.8 (4.56%)
42.38±6.05
-1.06 (-2.5%)
0.36 (0.77%)
46.8±5.79
66.98±3.62
2.02 (3.02%)

2.16 (10.77%)
1.02 (7.32%)
-1.5 (-11.6%)
2.72 (59.91%)
3.1 (2.44%)
1.08 (2.55%)
1.04 (2.22%)
-1.3 (-1.94%)

22.22±4.69
14.96±2.85
11.42±4.44
7.26±5.32
130.28±5.63
43.46±5.44
47.84±5.42
65.68±2.78

20.82±4.87
17.36±4.78
11.86±3.34
7.9±4.73
132.98±6.66
41.32±5.39
47.16±5.85
69.00±7.04

56.34

49.9649.24

43.56

1 // Creating the tag ‘‘t’’
2 domains={‘‘www.bcloud.com’’,‘‘smtp.bcloud.com’’,...};
3 createTag(‘‘t’’, domains);

Listing 1: BCloud’s policy conﬁguration

41.84

40.9

37.6

32.74

22.8 20.86

)
s

m

(

t
n
e
n
o
p
m
o
c

a

t
r
a
t
s

o
t

n
e
k
a
t

e
m
T

i

60

50

40

30

20

14.96

10

10 20 30 40 50 60 70 80 90 100
0
Number of component instances already started

Figure 7: Linear increase in component start time when
0 ! 100 instances (in steps of 10) already exist.
a 1MB ﬁle using a 8KB buffer. Since the entire check is
performed using the process and ﬁle labels in the kernel,
the overhead value is negligible (e.g., about 0.77% for a
labeled ﬁle write). We also measure the cost of copying
the 1MB ﬁle to the labeled layer, i.e., repeating the ﬁle
write experiment on Weir but deleting the ﬁle between
runs. The extra time taken to copy relative to AOSP is
5.98 ms (about 13% overhead). RedHat’s evaluation of
OverlayFS further demonstrates its scalability [18].
Network access: We measure the time to establish a net-
work connection using the HTTPSUrlConnection API,
using domain declassiﬁcation for the labeled instance.
The labeled instance’s overhead includes the kernel up-
calls and the DNS proxy lookup. The overhead for the
labeled instance (2.02 ms or 3.02%) includes the time
taken by the DNS proxy to inform Weir of the lookup, as
well as the synchronous kernel upcalls.

1

7.4 Scalability of Component Instantiation
We create up to 100 simultaneous instances (in steps of
10) of a service component, each with a different label.
At each step, we then invoke the last instance, i.e., from
a caller with the last instance’s label, and measure the
component start time. Note that this experiment presents
the worst case scenario; i.e., our prototype does not im-
plement any particular strategy (e.g., least recently used
(LRU)) for matching a call with a list of available in-

1 addTag{‘‘t’’};//raise own label to {t}
2 //perform sharing action ...
3 removeTag{‘‘t’’}//lower own label

Listing 2: BCloud raises its label

stances, and a request with the last instance’s label will
always result in a label comparison with all available in-
stances. Figure 7 shows linear scalability, with the high-
est absolute value being less than 57 ms.

8 Case Study

We investigated the use of labeled enterprise data with an
unmodiﬁed third party email (K-9 Mail) application [9].
With this case study, we demonstrate Weir’s utility, and
motivate the trade-off discussion in Section 9.
Application Setup: We created an enterprise cloud ap-
plication, BCloud that allows the user to sync her work
data (e.g., contacts, documents) to the device. Further,
we used the popular email application K-9 Mail with
both user and enterprise data. The setup is as follows:
1. BCloud. We assume that the enterprise policy is to
enable the use of third party applications with work data,
but to allow export to only enterprise domains. For ex-
ample, work data must only be emailed using the work
SMTP server smtp.bcloud.com.4 Thus, BCloud
creates a tag t as shown in Listing 1. To set the policy be-
fore sharing its data or saving it to storage, BCloud may
temporarily raise its label to {t} (Listing 2), or start itself
or other applications with {t} using intent labeling (List-
ing 3). For instance, BCloud raises its label before copy-
ing the work contacts to Android’s Contacts Provider.
2. K-9 Mail. We conﬁgured K-9 Mail for both per-
sonal and work email accounts. Like most modern email
clients, K-9 Mail allows the user to send an email us-
ing the work or the personal account, using the send
as email ﬁeld.
Internally, K-9 Mail uses the SMTP
server smtp.gmail.com for the personal account, and

4We

used mail.yahoo.com, smtp.mail.yahoo.com

and imap.mail.yahoo.com as BCloud’s trusted domains.

USENIX Association  

25th USENIX Security Symposium  1131

smtp.bcloud.com for the work account. To assist
the user in composing an email, K-9 Mail retrieves con-
tacts from the Contacts Provider app, and makes sugges-
tions as the user types into the “to” (i.e., sender) ﬁeld.
Experiment: We opened a document from BCloud in
the WPS Ofﬁce application. Then, from the WPS Ofﬁce
app, we shared the document with K-9 Mail. K-9 Mail’s
“compose” window was displayed. We then chose to
send as the work account, and picked a contact to add
to the “to” ﬁeld. We tried to attach another ﬁle, and the
“attach” action opened Android’s system ﬁle browser.
We selected a ﬁle and returned to K-9 Mail’s compose
screen. We then switched to the home screen without
sending the work email. We repeated the entire experi-
ment in the default (i.e., unlabeled) context, with the send
as ﬁeld set to the personal account. We then sent both
emails. Throughout the experiment, we watched the sys-
tem log for important events (e.g., network denial).
Observations: We made the following observations, and
veriﬁed them using the system log:
1. Context-speciﬁc instances. As we shared work data (in
the context {t}) with WPS Ofﬁce and subsequently K-9
Email, instances of these applications (i.e., processes and
components) were started in the work context {t}, and
attached to the internal and external (SD card) storage
layer Layer(t). The unlabeled context resulted in sepa-
rate instances with the empty label ({}), attached to the
default storage layer. Instances in both contexts existed
concurrently, without any crashes or abnormal behavior.
2. Context-speciﬁc data separation. While attaching an-
other document in the work ({t}) instance of K-9 Mail,
we could see all the documents on the default stor-
age layer (i.e., unlabeled ﬁles), and documents in work
Layer(t) (i.e., added from BCloud). On the contrary, in
the default context, we could only see the ﬁles on the
default layer. Further, in the default context, K-9 Mail
suggested from all of the user’s unlabeled contacts, but
none of the work contacts. In the work context, K-9 Mail
suggested from all the work contacts, and the unlabeled
contacts that existed before BCloud synced its labeled
contacts. That is, K-9 Mail could not see new records
created in the default layer’s contacts database after it
was copied over to Layer(t).
3. Domain Declassiﬁcation. In the work context, K-9
Email was unable to connect to the SMTP and IMAP
sub-domains of gmail.com, but could only connect
with the domains declassiﬁed by tag t. Unmodiﬁed K-9
Email silently handled these network access exceptions,
without crashing or displaying errors messages.

9 Trade-offs and Limitations
This section describes the trade-offs of our approach,
motivated in part by the observations in the case study.

1 Intent intent = new Intent();
2 // Add ‘‘t’’ to the intent’s label.
3 intent.addToLabel(‘‘t’’);
4 // Add data to the intent ...
5 startActivity(intent);//Call self

Listing 3: BCloud starts itself with new label

1. Centralized perspective: The user cannot view both
labeled and unlabeled data together, unless an applica-
tion is started in the labeled context (e.g., K-9 Mail in
context {t}). We envision modiﬁed application launch-
ers and phone settings that allow the user to start applica-
tions (e.g., File Browsers) with a certain label by default,
for making labeled and default data available together.
Our test apps use similar techniques; hence such launch-
ers should not be hard to create. On the other hand,
a centralized perspective on more than one non-default
context (e.g., {t1,t2,t3, ..}) may require a trusted OS ap-
plication exempt from polyinstantiation (but subject to
only ﬂoating labels), as ﬂoating labels by themselves are
vulnerable to information leaks ( Section 6).
2. Updates to default layer: While context-speciﬁc ver-
sions of ﬁles may be generally acceptable, in case of
database ﬁles (e.g., contacts read by K-9 Mail in the work
context) the user may expect new records in the unla-
beled context to be propagated to the copy in the labeled
context. The lack of updates is mainly a trade-off of
our ﬁle-level copy-on-write implementation (i.e., Over-
layFS). As mentioned in Section 5, a block-level copy-
on-write ﬁle system (e.g., BTRFS [32]) may mitigate this
trade-off, as it would only copy the blocks modiﬁed by
the labeled context, and newly allocated blocks in the de-
fault context would be accessible to the labeled context,
although this aspect needs further exploration.
3. Access control denials: Floating labels ensure that
inter-component communication is never denied, and
that resources (e.g., ﬁles, other components) are available
in all secrecy contexts. Although apps may be denied
network access, research has addressed this challenge in
the past (e.g., AppFence [17]). Further, most IDEs (e.g.,
Eclipse) enforce compile-time checks for proper excep-
tion handling, and it is uncommon for apps to crash due
to network denial, as observed in the case study as well.
4. Instance Explosion: Weir creates separate context-
speciﬁc K-9 Mail instances, only for the contexts in use.
The theoretical worst-case count of component instances
is equivalent to the number of components multiplied
by the number of all existing contexts (not just those
in use). Our event-based and “lazy” instantiation makes
this worst case practically improbable, unlike approaches
that execute all existing contexts (see Section 10). On the
other hand, a denial of service attack on a particular ap-
plication component may be feasible, by starting a very
large number of its instances in a short amount of time
for noticeable impact on the lookup time of that compo-

1132  25th USENIX Security Symposium 

USENIX Association

nent. Our implementation can be modiﬁed to detect and
prevent unusual rates of component instantiation. Note
that polyinstantiation of a component only affects its own
lookup time (as discussed in Section 7.1), and cannot be
used for an attack with a device-wide impact.
5. Resource Overhead: Polyinstantiation may cause
resource overhead in terms of the memory, battery and
storage. The memory overhead is manageable as An-
droid’s out of memory manager automatically reclaims
memory from low priority components. Further, any
measurement of the battery or storage use is bound to
be subjective with respect to the number of labels, num-
ber of apps/components, type of apps (e.g., game vs. text
editor), aspects of the user scenario (e.g., user-initiated
ﬂows, scenario-speciﬁc storage access). An objective
large-scale study will be explored in the future.
6. Consistency Issues: To a remote server, the instances
of an application in Weir are analogous to instances run-
ning on different devices (e.g., a user logged in from two
devices). Hence, any data consistency issues in such sce-
narios are not a result of polyinstantiation.
7. Covert Channels: Weir mediates overt communi-
cation between subjects and objects, but does not ad-
dress covert channels existing in Android. A clearance
label [6, 40, 44] can be used to defend against adver-
saries using covert channels by preventing access to cer-
tain tainted data in the ﬁrst place. While a clearance
label can be easily incorporated into Weir, setting the
clearance policy for third party applications with un-
predictable use cases is hard, and needs further explo-
ration from a policy speciﬁcation standpoint. Finally,
unlike IFC systems that focus on preventing untrusted
code within a program from exﬁltrating data (e.g., Secure
multi-execution [11]), Weir’s focus is inter-application
data sharing. Hence, compartmentalizing an application
using clearance is outside the scope of this paper.
8. Explicit labeling of messages and ﬁles: On Android,
an indirect message through the OS (e.g., intent message)
is required before a bi-directional Binder connection can
be established between two instances. Weir allows ﬂoat-
ing labels on such indirect communication (but not on
direct Binder calls), and polyinstantiation ensures that
the two instances at the end of a bidirectional Binder
connection have the same label, which is sufﬁcient for
synchronous Binder messages. Hence, labeling of indi-
vidual Binder messages does not provide additional ﬂex-
ibility, unlike in explicit labeling DIFC systems (e.g.,
COWL [41], Flume [21]). Note that Weir allows explicit
labeling of indirect messages (i.e., intent labeling). Fur-
ther, explicit labeling of a ﬁle with a label that is different
from its creating process instance would place it on an
incorrect layer. Such incorrectly stored ﬁles will not be
visible to future instances started with matching labels,

and may cause unpredictable application behavior. Thus,
our design trades the ﬂexibility in explicitly labeling ﬁles
for stable context-sensitive storage.

10 Related Work

In Section 3.1 we described prior DIFC proposals for An-
droid (i.e., Aquifer [28], Jia et al. [19] and Maxoid [46]).
We now describe other relevant prior research.
DIFC: Myers and Liskov presented the Decentralized
Labeling Model (DLM) [26] that allowed security prin-
cipals to deﬁne their own labels. Since then, numerous
DIFC systems have been proposed that provide valuable
policy and enforcement models [20,21,25–27,33,44,49,
50]. Language-based DIFC approaches (e.g., JFlow [25]
and Jif [27]) provide precision within the program, but
rely on the OS for DIFC enforcement on OS objects
(e.g., processes, ﬁles, sockets). On the contrary, coarse-
grained OS-level approaches (e.g., HiStar [49] and As-
bestos [44]) provide security for ﬂows between OS ob-
jects, but cannot reason about ﬂows at the granularity of
a programming language variable. While Weir is also an
OS-level DIFC approach, which means it cannot achieve
precision at the program variable level, context sensitive
enforcement ensures that Weir always has higher preci-
sion than traditional OS-level DIFC. Further, while Lam-
inar [30, 33] provides both language-level as well as the
OS-level enforcement, it requires applications to be mod-
iﬁed to use the precise language-level enforcement. This
is not an option for backwards compatible DIFC on An-
droid. Finally, Weir does not require general-purpose ap-
plications to explicitly deﬁne ﬂows as in Laminar, HiStar
and Flume [20, 21], as inter-application communication
in Android tends to be unpredictable.
Secure multi-execution: Secure multi-execution [11]
was proposed to determine and enforce that a program’s
execution is noninterferent, i.e., to eliminate unlawful
data ﬂows by untrusted code within a program. The
approach achieves noninterference using multiple con-
current executions at all points in the lattice, removing
statements that do not match the labels of speciﬁc exe-
cutions. On the contrary, lazy polyinstantiation creates
only one instance in the security context of the caller.
Unlike secure multi-execution where the multiple execu-
tions are treated as a part of the same program instance,
polyinstantiation treats multiple executions as unrelated
context-speciﬁc instances separated in memory and stor-
age. Our approach is more suitable for Android’s inter-
application data sharing abstractions, while secure multi-
execution may be useful to prove non-interference for a
general program. Further, secure multi-execution only
assumes a ﬁnite, predeﬁned label set. This assumption
is violated in DIFC systems, where the label set is often

USENIX Association  

25th USENIX Security Symposium  1133

large and not known a priori, and executing all labels at
once is impractical.
Faceted Execution: Jeeves [48] and Jaqueline [47] en-
sure that security principals see different views of data
based on their secrecy contexts, using a technique de-
ﬁned as faceted execution. The result of Weir’s approach
is similar; i.e., each security principal can only see data
at its own secrecy context. For faceted execution, the
copies of data have to be speciﬁed by the programmer
a priori, which is acceptable if the security of different
users using a single program (e.g., a conference submis-
sion site) is to be deﬁned. On the contrary, on Android,
Weir’s approach of allowing applications to operate un-
modiﬁed, and creating context-speciﬁc copies on the go,
is more practical. To elaborate, data in terms of Weir is
not the value(s) of a programming language variable, but
the instances of components in memory and ﬁle system
layers per label. Finally, just like secure multi-execution,
faceted execution is more suitable when the IFC lattice is
small (e.g., two labels) or ﬁnite, and may not be feasible
for DIFC, where tags can be created at runtime.
Coarse-grained Containers: Approaches such as Sam-
sung Knox [34] and Android for Work [2] protect en-
terprise data by isolating groups of applications into dif-
ferent containers. Containers cannot compensate for the
lack of data secrecy guarantees, as they do not address
threats within the container, i.e., the accidental export of
secret data by a trusted application or the potential com-
promise of a trusted application. Virtual phones (e.g.,
Cells [4]) are similarly inadequate for data secrecy.
Transitive Enforcement on Android: Android permis-
sions lack transitive enforcement, and are susceptible to
privilege escalation attacks [7, 16]. IPC Inspection [14]
enforces transitivity by reducing the caller’s effective
permissions to those of the least privileged component in
the call chain. Quire [12] provides the call chain infor-
mation to applications being called, to prevent confused
deputy attacks. Like ﬂoating labels, privilege reduction
is additive, and may severely restrict shared components.
Fine-grained Taint Tracking on Android: Taint-
Droid [13] detects private data leaks via ﬁne-grained taint
tracking on Android, but is vulnerable to implicit ﬂows.
CleanOS [43] and Pebbles [38] use ﬁne-grained taint
tracking on memory and storage to evict and manage pri-
vate data respectively. For tracking data in databases,
both approaches rely on modiﬁcation to the database li-
brary, which may not be secure as the library executes in
the memory of the enforcement subject.

11 Conclusion

Android’s component and storage abstractions make se-
cure and practical DIFC enforcement challenging. To ad-

dress these challenges, we present lazy polyinstantiation
and domain declassiﬁcation. We design and implement a
DIFC system, Weir, and show a negligible performance
impact as well as compatibility with legacy applications.
In doing so, we show how secure and backwards com-
patible DIFC enforcement can be achieved on Android.

Acknowledgements

This work was supported in part by the NSA Sci-
ence of Security Lablet at North Carolina State Uni-
versity, NSF CAREER grant CNS-1253346, NSF-SaTC
grants CNS-1228782 and CNS-1228620, and the United
State Air force and Defense Advanced Research Agency
(DARPA) under Contract No. FA8650-15-C-7562. Any
opinions, ﬁndings, and conclusions or recommendations
expressed in this material are those of the authors and do
not necessarily reﬂect the views of the funding agencies.

References
[1] ALJURAIDAN,

J., FRAGKAKI, E., BAUER, L.,

JIA, L.,
FUKUSHIMA, K., KIYOMOTO, S., AND MIYAKE, Y. Run-Time
Enforcement of Information Flow Properties on Android. Tech.
Rep. CMY-CyLab-12-015, CyLab, Carnegie Mellon University,
2012.

[2] ANDROID. Android for Work. https://www.android.

com/work/.

[3] ANDROID DEVELOPERS

.

Tasks

and Back Stack.

https://developer.android.com/guide/
components/tasks-and-back-stack.html.

[4] ANDRUS, J., DALL, C., HOF, A. V., LAADAN, O., AND NIEH,
J. Cells: a virtual mobile smartphone architecture. In Proceed-
ings of the Twenty-Third ACM Symposium on Operating Systems
Principles (2011), ACM, pp. 173–187.

[5] BAUER, L., CAI, S., JIA, L., PASSARO, T., STROUCKEN, M.,
AND TIAN, Y. Run-time Monitoring and Formal Analysis of In-
formation Flows in Chromium. In Proceedings of the ISOC Net-
work and Distributed Systems Security Symposium (NDSS) (Feb
2015).

[6] BELL, D. E., AND LAPADULA, L. J. Secure Computer Sys-
tems: Mathematical Foundations. Tech. Rep. MTR-2547, Vol. 1,
MITRE Corp., 1973.

[7] DAVI, L., DMITRIENKO, A., SADEGHI, A.-R., AND
WINANDY, M. Privilege Escalation Attacks on Android.
In
Proceedings of the 13th Information Security Conference (ISC)
(2010).

[8] DENNING, D. E. A Lattice Model of Secure Information Flow.

Communications of the ACM (1976).

[9] DEVELOPERS, K.-. M. K-9 Mail. https://github.com/

k9mail, 2015.

[10] DEVELOPERS, S.

SELinux Kernel ToDo.

https:

//github.com/SELinuxProject/selinux/wiki/
Kernel-Todo, 2015.

[11] DEVRIESE, D., AND PIESSENS, F. Noninterference through se-
cure multi-execution. In 31st IEEE Symposium on Security and
Privacy (May 2010).

1134  25th USENIX Security Symposium 

USENIX Association

[12] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WAL-
LACH, D. S. Quire: Lightweight Provenance for Smart Phone
Operating Systems. In Proceedings of the USENIX Security Sym-
posium (2011).

[28] NADKARNI, A., AND ENCK, W. Preventing Accidental Data
Disclosure in Modern Operating Systems.
In Proceedings of
the ACM Conference on Computer and Communications Secu-
rity (CCS) (2013).

[13] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
TaintDroid: An
J., MCDANIEL, P., AND SHETH, A. N.
Information-Flow Tracking System for Realtime Privacy Mon-
itoring on Smartphones.
In Proceedings of the 9th USENIX
Symposium on Operating Systems Design and Implementation
(OSDI) (2010).

[14] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND
CHIN, E. Permission Re-Delegation: Attacks and Defenses. In
Proceedings of the USENIX Security Symposium (2011).

[15] GIFFIN, D. B., LEVY, A., STEFAN, D., TEREI, D., MAZI `ERES,
D., MITCHELL, J. C., AND RUSSO, A. Hails: Protecting Data
Privacy in Untrusted Web Applications. In Presented as part of
the 10th USENIX Symposium on Operating Systems Design and
Implementation (OSDI 12) (2012).

[16] GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X. Systematic
Detection of Capability Leaks in Stock Android Smartphones. In
Proceedings of the ISCO Network and Distributed System Secu-
rity Symposium (2012).

[17] HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND
WETHERALL, D. These Aren’t the Droids You’re Looking For:
Retroﬁtting Android to Protect Data from Imperious Applica-
tions. In Proceedings of the ACM Conference on Computer and
Communications Security (CCS) (2011).

EDER.
Scalability

[18] JEREMY
Storage
developerblog.redhat.com/2014/09/30/
overview-storage-scalability-docker/.

Comprehensive

Docker.

in

Overview

of
https://

[19] JIA, L., ALJURAIDAN,

J., FRAGKAKI, E., BAUER, L.,
STROUCKEN, M., FUKUSHIMA, K., KIYOMOTO, S., AND
MIYAKE, Y. Run-Time Enforcement of Information-Flow Prop-
erties on Android (Extended Abstract).
In Proceedings of the
European Symposium on Research in Computer Security (ES-
ORICS) (2013).

[20] KROHN, M., AND TROMER, E. Noninterference for a Practi-
cal DIFC-Based Operating System. In Proceedings of the IEEE
Symposium on Security and Privacy (2009).

[21] KROHN, M., YIP, A., BRODSKY, M., CLIFFER, N.,
KAASHOEK, M. F., KOHLER, E., AND MORRIS, R. Informa-
tion Flow Control for Standard OS Abstractions. In Proceedings
of ACM Symposium on Operating Systems Principles (SOSP)
(2007).

[22] LAGEMAN, M., AND SOLUTIONS, S. C. Solaris Containers-

What They Are and How to Use Them.

[23] MCILROY, M. D., AND REEDS, J. A. Multilevel security in the

UNIX tradition. Software: Practice and Experience (1992).

[24] MERKEL, D. Docker: lightweight linux containers for consistent

development and deployment. Linux Journal (2014).

[25] MYERS, A. C. JFlow: Practical Mostly-Static Information Flow
Control. In Proceedings of the ACM Symposium on Principles of
Programming Languages (POPL) (1999).

[26] MYERS, A. C., AND LISKOV, B. A Decentralized Model for In-
formation Flow Control. In Proceedings of the ACM Symposium
on Operating Systems Principles (SOSP) (1997).

[27] MYERS, A. C., AND LISKOV, B. Protecting Privacy Using the
Decentralized Label Model. ACM Transactions on Software En-
gineering and Methodology (2000).

[29] NEIL BROWN.

Overlay Filesystem.

https://www.

kernel.org/doc/Documentation/filesystems/
overlayfs.txt.

[30] PORTER, D. E., BOND, M. D., ROY, I., MCKINLEY, K. S.,
AND WITCHEL, E. Practical Fine-Grained Information Flow
Control Using Laminar. ACM Trans. Program. Lang. Syst. (Nov.
2014).

[31] REPS, T. W. Program Analysis via Graph Reachability. Infor-

mation & Software Technology 40, 11-12 (1998).

[32] RODEH, O., BACIK, J., AND MASON, C. BTRFS: The Linux
B-Tree Filesystem. ACM Transactions on Storage (TOS) (Aug.
2013).

[33] ROY, I., PORTER, D. E., BOND, M. D., MCKINLEY, K. S.,
AND WITCHEL, E. Laminar: Practical Fine-Grained Decentral-
ized Information Flow Control. In Proceedings of the Conference
on Programming Language Design and Implementation (PLDI)
(2009).

[34] SAMSUNG ELECTRONICS. An Overview of Samsung Knox.

http://www.samsung.com/global/business/
business-images/resource/white-paper/2014/
02/Samsung_KNOX_whitepaper_June-0-0.pdf,
2013.

[35] SCHAUFLER, C. LSM: Multiple concurrent LSMs. https:

//lkml.org/lkml/2013/7/25/482, 2013.

[36] SHARIR, M., AND PNUELI, A. Two Approaches to Interproce-
dural Data Flow Analysis. In Program Flow Analysis: Theory
and Applications. 1981.

[37] SHIVERS, O. Control-Flow Analysis of Higher-Order Lan-
guages. PhD thesis, Carnegie Mellon University Pittsburgh, PA,
1991.

[38] SPAHN, R., BELL, J., LEE, M., BHAMIDIPATI, S., GEAM-
BASU, R., AND KAISER, G. Pebbles: Fine-Grained Data Man-
agement Abstractions for Modern Operating Systems.
In Pro-
ceedings of the USENIX Operating Systems Design and Imple-
mentation (OSDI) (2014).

[39] STATISTA.

Number of

in the
Google Play Store from December 2009 to February 2016.
http://www.statista.com/statistics/266210/
number-of-available-applications-in-the-google-play-store/.

applications

available

[40] STEFAN, D., RUSSO, A., MITCHELL, J. C., AND MAZI `ERES,
D.
Flexible Dynamic Information Flow Control in Haskell.
In Proceedings of the 4th ACM Symposium on Haskell (2011),
Haskell ’11.

[41] STEFAN, D., YANG, E. Z., MARCHENKO, P., RUSSO, A., HER-
MAN, D., KARP, B., AND MAZI `ERES, D. Protecting Users
by Conﬁning JavaScript with COWL. In 11th USENIX Sympo-
sium on Operating Systems Design and Implementation (OSDI
14) (Oct. 2014).

[42] STEFAN, H., STEFAN, D., YANG, E. Z., RUSSO, A., AND
MITCHELL, J. C. IFC Inside: Retroﬁtting Languages with Dy-
namic Information Flow Control. In Proceedings of the 4th Con-
ference on Principles of Security and Trust (POST 2015) (2015).
[43] TANG, Y., AMES, P., BHAMIDIPATI, S., BIJLANI, A., GEAM-
BASU, R., AND SARDA, N. CleanOS: Limiting Mobile Data Ex-
posiure with Idle Eviction. In Proceedings of the USENIX Sympo-
sium on Operating Systems Design and Implementation (OSDI)
(2012).

USENIX Association  

25th USENIX Security Symposium  1135

Call 

(Component C)

callerLabel = 

label(caller's process)

Resolve Target 

component 
name (C)

Yes

No

Is C 
running?
No

Create a new 
instance of C

P = 

match_Weir
_Proc(P, 
callerLabel)

Resolve target 
process P for 
C.processName

 label (C's 
process) == 
callerLabel ?
Yes

Yes

Is P 

running?
No
Start new 

process P for 

C

Set callerLabel 
as label (P)

Deliver the call 

to C

match_Weir_Proc
(Process P, Label 

callerLabel)

Yes

callerLabel 
== label (P)?

No
pList = 

weirProcessList 
(P.processName)

Yes

pList.next()!= 

P = 
null?

No

No

Yes

callerLabel 
== label 

(P)?

Yes

Allocate new 
Process P'

P = P'

pList.add (P')

Return 

P

Figure 8: Flow of the Activity Manager starting a com-
ponent. The areas modiﬁed or added by Weir are shaded.

[44] VANDEBOGART, S., EFSTATHOPOULOS, P., KOHLER, E.,
KROHN, M., FREY, C., ZIEGLER, D., KAASHOEK, F., MOR-
RIS, R., AND MAZI `ERES, D. Labels and Event Processes in
the Asbestos Operating System. ACM Transactions on Computer
Systems (TOCS) (2007).

[45] WALSH,

D.

SELinux/OverlayFS

integration.

https://twitter.com/rhatdan/status/
588338475084029953, 2015.

[46] XU, Y., AND WITCHEL, E. Maxoid:

transparently conﬁning
mobile applications with custom views of state. In Proceedings
of the Tenth European Conference on Computer Systems (2015),
ACM.

[47] YANG, J., HANCE, T., AUSTIN, T. H., SOLAR-LEZAMA,
A., FLANAGAN, C., AND CHONG, S. End-To-End Policy-
Agnostic Security for Database-Backed Applications.
arXiv
preprint arXiv:1507.03513 (2015).

[48] YANG, J., YESSENOV, K., AND SOLAR-LEZAMA, A. A Lan-
guage for Automatically Enforcing Privacy Policies. In Proceed-
ings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (2012).

[49] ZELDOVICH, N., BOYD-WICKIZER, S., KOHLER, E., AND
MAZI `ERES, D. Making Information Flow Explicit in HiStar. In
Proceedings of the 7th symposium on Operating Systems Design
and Implementation (2006).

[50] ZELDOVICH, N., BOYD-WICKIZER, S., AND MAZIERES, D.
Securing Distributed Systems with Information Flow Control. In
Proceedings of the USENIX Symposium on Networked Systems
Design and Implementation (2008).

A Component Polyinstantiation Logic

In this section, we describe Weir’s changes to the Ac-
tivity Manager service’s component and process assign-
ment logic. Figure 8 shows the workﬂow inside the
Activity Manager when a component C is called. The

shaded blocks form Weir’s label checks and polyinstan-
tiation logic. Note that the ﬁgure portrays the high level
steps followed by the Activity Manager, common to all
components. When a call arrives, Weir ﬁrst gets the la-
bel for the caller’s process from the kernel and stores it
in callerLabel. The Activity Manager then resolves the
target component C using the information in the call. At
this point the Activity Manager only knows the name and
type of the target component (e.g., the content provider
C). The Activity Manager then checks if there is a run-
time instance of C in its records. If a runtime instance
exists and is executing in a process with a matching la-
bel, the call is delivered to the running instance. Other-
wise, Weir forces the Activity Manager to create another
runtime instance, for this new callerLabel.

Without Weir, the Activity Manager would always de-
liver the call to the existing instance.5 Weir modiﬁes the
Activity Manager’s internal bookkeeping structures to be
consistent with its polyinstantiation; i.e., it enables the
Activity Manager to manage multiple runtime records
for the same component. For example, the ActivityMan-
ager uses a direct mapping between a service’s name and
its runtime instance, to store records of running services.
Weir modiﬁes this mapping to one between the name and
a set of services.

At this stage, the system has a new component in-
stance that needs to be executed in a process. The Ac-
tivity Manager selects the process based on the pro-
cessName extracted from the “android:process” mani-
fest attribute. A runtime record of the resolved pro-
cess P is then sent to Weir for process matching (i.e.,
the Match Weir Proc (P, callerLabel) subroutine). Weir
ﬁrst checks the label of the existing process P, and if it
matches, returns P itself. If not, Weir retrieves its internal
list of processes associated with P. This list constitutes
the processes that were created in the past to be assigned
instead of P for speciﬁc caller labels. Weir checks if the
list contains a process with a label matching the current
callerLabel; this step ensures that components with the
same processName as well as callerLabel are executed in
the same process. If Weir fails to ﬁnd a matching process
in the list, it allocates a new process for the callerLabel,
and adds it to the list of existing processes mapped to the
speciﬁc processName. This process is then returned as
P to the Activity Manager. The Activity Manager then
starts P, if it is not already started, and Weir sets its label
in the kernel. Note that if the process is already started
(i.e., the original P was matching, or a matching process
was found in Weir’s pList (P.processName), the Activity
Manager does not restart it. Finally, the component in-
stance is executed in the assigned process, and the call is
delivered to it.

5Except in the case of standard and multi-process activities.

1136  25th USENIX Security Symposium 

USENIX Association

