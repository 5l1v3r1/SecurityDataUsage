2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Post-quantum key exchange for the TLS protocol

from the ring learning with errors problem

Joppe W. Bos

NXP Semiconductors

Craig Costello, Michael Naehrig

Douglas Stebila

Microsoft Research

Queensland University of Technology

Abstract—Lattice-based cryptographic primitives are believed
to offer resilience against attacks by quantum computers. We
demonstrate the practicality of post-quantum key exchange by
constructing ciphersuites for the Transport Layer Security (TLS)
protocol that provide key exchange based on the ring learning
with errors (R-LWE) problem; we accompany these ciphersuites
with a rigorous proof of security. Our approach ties lattice-
based key exchange together with traditional authentication
using RSA or elliptic curve digital signatures: the post-quantum
key exchange provides forward secrecy against future quantum
attackers, while authentication can be provided using RSA keys
that are issued by today’s commercial certiﬁcate authorities,
smoothing the path to adoption.

Our cryptographically secure implementation, aimed at the
128-bit security level, reveals that the performance price when
switching from non-quantum-safe key exchange is not too high.
With our R-LWE ciphersuites integrated into the OpenSSL
library and using the Apache web server on a 2-core desktop
computer, we could serve 506 RLWE-ECDSA-AES128-GCM-SHA256
HTTPS connections per second for a 10 KiB payload. Compared
to elliptic curve Difﬁe–Hellman, this means an 8 KiB increased
handshake size and a reduction in throughput of only 21%. This
demonstrates that provably secure post-quantum key-exchange
can already be considered practical.

I. INTRODUCTION

While lattice-based primitives [1], [2] have been used to
achieve exciting new cryptographic functionalities like fully
homomorphic encryption [3] and multilinear maps [4], there
has also been a great deal of work on instantiating traditional
cryptographic functionalities using lattices. One of the catalysts
for this direction of research is that, unlike other number-
theoretic primitives1 such as RSA [6] and elliptic curve
cryptography (ECC) [7], [8], lattices are currently believed
to offer resilience against attacks using quantum computers.
Motivated by such post-quantum security, in this work we
replace the traditional number-theoretic key exchange in the
widely deployed Transport Layer Security (TLS) protocol [9]
with one based on the ring learning with errors (R-LWE)
problem [10], which is related to hard lattice problems. Using
lattice problems in addition to or instead of number-theoretic
problems is useful not only in protecting against attacks by
quantum computers but also in providing robustness if other
mathematical breakthroughs lead to more efﬁcient algorithms
for factoring or compute discrete logarithms.

Our basic key exchange protocol is simple—similar to the
unauthenticated Difﬁe–Hellman protocol [11]—and comes with

1Shor’s algorithm [5] solves (classically) hard problems based on these

primitives in polynomial time on a quantum computer.

a rigorous proof of security based on the R-LWE problem. We
put it in the context of TLS by (i) constructing a TLS ciphersuite
that uses R-LWE key exchange rather than elliptic curve
Difﬁe–Hellman (ECDH), (ii) providing a proof in a suitable
security model [12] that this new TLS ciphersuite is a secure
channel, and (iii) integrating our software implementation into
the OpenSSL library to benchmark its performance against
elliptic curve Difﬁe–Hellman key exchange. This analysis gives
practitioners an idea of the price one would pay for using R-
LWE to cure post-quantum paranoia today. We focus our work
on the key exchange component, not authentication: we assume
that a quantum computer does not currently exist so that the
standard RSA-based authentication in TLS is secure for now.
However, using R-LWE as a current key exchange mechanism
would assure us that if a quantum computer is realized at some
stage in the future, the ephemeral session keys we establish
today will remain secure so long as the R-LWE problem does.
R-LWE at the 128-bit security level. The implementation
we describe in this work is intended to serve as a drop-
in replacement for traditional forward-secret key exchange
mechanisms targeting the 128-bit security level, e.g. in place
of the standardized elliptic curve nistp256, which is the
most widely used elliptic curve in TLS [13] and provides
much faster key exchange than ﬁnite-ﬁeld Difﬁe–Hellman.
While the complexities of the best known attacks against these
traditional primitives are widely agreed upon, the state of
affairs for attacks against R-LWE is altogether different: for
one, there are more parameters that affect the security level in
the realm of ideal lattices, so many papers differ signiﬁcantly in
their suggested combinations of parameter sizes for particular
security levels. In addition, the majority of authors giving
concrete parameters in the (R-)LWE setting have done so at
the 80-bit security level. Thus, in this work we have always
opted for the conservative approach, making security parameters
larger or smaller than they might need to be at stages where
the actual attack complexity is unclear. The upshot is that our
performance timings could be viewed as somewhat of an upper
bound for R-LWE key exchange at the 128-bit level.
Implementation and performance. We implemented the R-
LWE algorithms in C. As it has become mandatory to guard
cryptographic implementations against physical attacks, such
as the leakage of secret material over side channels [14], we
have implemented an important counter-measure against such
attacks by ensuring our implementation has constant run-time:

© 2015, Joppe W. Bos. Under license to IEEE.
© 2015, Joppe W. Bos. Under license to IEEE.
DOI 10.1109/SP.2015.40
DOI 10.1109/SP.2015.40

553
553

the execution time of the implementation does not depend on
the input. In practice this is usually realized by eliminating all
code that contains data-dependent branches, however this often
incurs a performance penalty, so we also provide performance
of our variable-time implementation in order to highlight the
price one pays in practice when guarding against physical
attacks in the context of R-LWE. The most expensive R-LWE
operation is sampling from the error distribution, which takes
slightly over one million cycles, and has to be performed once
by the client and twice by the server during key exchange.

We integrated our R-LWE algorithm into the OpenSSL
library. Whereas OpenSSL’s implementation of ECDH using
the nistp256 curve takes about 0.8 ms total (here we are
referring to just the ECDH point operations, no other signing
or encryption operations), the R-LWE operations take about
1.4 ms for the client’s operations and 2.1 ms for the server’s
operations (on a standard desktop computer; see Section VI-B):
our constant-time R-LWE implementation is a factor of 1.8–
2.6 times slower than ECDH. However, our implementation is
entirely in C, so further performance improvements could be
achieved through assembly-level optimizations or architecture
speciﬁc optimization like using the vector instruction set, as
well as through a more aggressive parameter selection.

While this is a signiﬁcant performance difference in terms
of raw cryptographic operations, the penalty of using R-LWE
becomes less pronounced when used in the context of TLS, as
seen in Fig. 1. We did performance testing with our modiﬁed
OpenSSL in the context of the Apache web server. Using a
3072-bit RSA certiﬁcate for authentication (we chose RSA
for authentication because the vast majority of commercial
certiﬁcate authorities only support RSA, and we chose 3072-
bit RSA keys to match the desired 128-bit security level [15]),
our 2-core web server (serving 10 KiB web pages) could
handle 177 ECDHE-RSA-AES128-GCM-SHA256 connections per
second, compared to 164 RLWE-RSA connections per second,
a factor of about 1.08 difference. Switching to ECDSA-based
authentication, we can serve 642 ECDHE-ECDSA versus 506
RLWE-ECDSA connections per second, which is a larger gap,
but which shows that RLWE-ECDSA is still highly competitive.
Even for hybrid ciphersuites, which use both ECDH and R-
LWE key exchange (for users who worry about the potential of
quantum computers but still need to use ECDH for reasons such
as FIPS compliance2), performance is reasonable. It should
be noted that using R-LWE instead of ECDH increases the
handshake by about 8 KiB.

Our performance data demonstrates that R-LWE is a plausi-
ble candidate for providing post-quantum key exchange security
in TLS. There is a performance penalty for web servers
compared to elliptic curve cryptography—a factor of between
1.08–1.27 in our portable C implementation—but this is not
too bad. Performance improvements can be expected as future
research is done on parameter choices and scheme designs,
new optimizations are developed, and CPU speeds increase.

2From the FIPS perspective, non-FIPS keying material when XORed or
combined in a PRF (like we are doing) is treated as a “constant” that does
not negatively affect security or compliance.

554554

d
n
o
c
e
s

r
e
p

s
n
o
i
t
c
e
n
n
o
C

700

600

500

400

300

200

100

0

ECDHE-ECDSA

RLWE-ECDSA

HYBRID-ECDSA

ECDHE-RSA
RLWE-RSA
HYBRID-RSA

1 B

1 KiB
HTTP payload size

10 KiB

100 KiB

Fig. 1. HTTPS connections per second supported by the server at 128-bit
security level. All ciphersuites use AES-128-GCM and SHA256.

Related work. A simple unauthenticated key exchange proto-
col based on the learning with errors (LWE) problem seems
to have been folklore for some time. Ding et al. [16, §3]
present a DH-like protocol based on LWE and give a security
proof. Blazy et al. [17, Fig. 1, 2] describe a similar DH-like
protocol based on LWE but without a detailed analysis. Katz
and Vaikuntanathan [18] build a password-authenticated key
exchange protocol from the LWE problem.

Whereas the hardness of LWE is related to the shortest vector
problem (SVP) on lattices, the R-LWE problem is related to
the SVP on ideal lattices, allowing for shorter parameter sizes.
Four existing works present key exchange protocols based
on R-LWE: Ding et al. [16, §4], Fujioka et al. [19, §5.2],
Peikert [20, §4.1], and Zhang et al. [21]. The ﬁrst three bear
similarities, although differ somewhat in the error correction
of the shared secret. Fujioka et al. and Peikert phrase their
protocols as key encapsulation mechanisms (KEMs) which have
passive (IND-CPA) security. To achieve a fully post-quantum
authenticated key exchange protocol, Fujioka et al. use standard
techniques [22] to compile a passively secure KEM into an
actively secure KEM which is used to provide authentication
in a KEM-KEM approach [23], whereas Peikert uses a
SIGMA-like design [24]. Zhang et al.construct an HMQV-like
key exchange protocol that uses R-LWE for both long-term
and ephemeral keys. Our work builds on Peikert’s passively
secure KEM, but is phrased in a DH-like fashion. Our work
contrasts with both Peikert’s and that of Zhang et al. in that
we integrate the R-LWE key exchange directly into TLS,
perform authentication using standard signatures for ease of
adoption, and provide a constant-time implementation with full
performance measurements.

NTRU [25] is another lattice-based cryptographic primitive
that potentially resists attacks by quantum computers and relies
on arithmetic in a polynomial ring. In 2001 an Internet-Draft
was published proposing NTRU-based ciphersuites for TLS,

with authentication using either NTRU or RSA signatures
[26]. Although not widely adopted or standardized, it has
been implemented in the CyaSSL library. A recent open-source
implementation of NTRU public key encryption in a standalone
setting reports that at the 128-bit security level optimized NTRU
key generation and private key operations can require about
1.0 ms and 0.1 ms runtime, respectively, on a desktop CPU
with key sizes of 0.6 KiB.3 While outperforming our R-LWE
protocol both in terms of performance and key sizes, one major
advantage of using R-LWE is that it provides security proofs via
reductions to hard standard problems in ideal lattices, whereas
NTRU is not known to be provably secure in the sense that no
such reduction is known; as well, there are no known patents
covering R-LWE, whereas use of NTRU in non-GPL-licensed
software is restricted under patents.
Organization and summary of contributions. The main
contribution of this work is the design, security analysis, and
implementation of key exchange for the TLS protocol which
is conjectured to be post-quantum secure. Our work serves as
an off-the-shelf, drop-in replacement to the traditional number-
theoretic (but post-quantum insecure) key exchange mecha-
nisms already deployed in TLS, with comparable efﬁciency.
The ﬁrst step is the construction of a key agreement protocol
whose simplicity, functionality and high-level description
closely mimics that of the discrete logarithm-based DH protocol.
As mentioned above, previous (R)-LWE-based key exchange
constructions were not phrased to resemble traditional DH;
this is why we present a new, simple and provably secure key
agreement protocol in Section III. In Section IV we discuss the
implementation details speciﬁc to our R-LWE protocol; this
includes parameter selection, error sampling, and polynomial
arithmetic. Although we prove that our standalone scheme is
cryptographically secure in Section III, in Section V we bridge
an important practical gap by proving that its integration into the
TLS protocol is also secure using the standard security model
for TLS. This proof, alongside our constant-time, fast, open-
source implementation, are two of the high-level contributions
that set our work aside from previous works on lattice-based
key-agreement (cf. [17], [18], [19], [20], [21]). In Section VI
we present performance measurements of the standalone R-
LWE operations and of our protocol in the context of TLS;
our R-LWE implementation is sufﬁciently optimized to be an
order of magnitude faster than another recent lattice-based key
agreement protocol [21] (which is not integrated into TLS).
We conclude the paper in Section VII. The appendix contains
additional standard cryptographic deﬁnitions.

II. BACKGROUND ON RING LEARNING WITH ERRORS

This section introduces notation and presents the basic
background for cryptographic schemes based on the ring
learning with errors (R-LWE) problem, which was introduced
in [10] (see also [27], [20]). Terminology is mostly as in [20].

3https://github.com/NTRUOpenSourceProject/ntru-crypto

Notation. Let Z be the ring of rational integers, and let
R = Z[X]/(Φm(X)) be the ring of integers of the m-
th cyclotomic number ﬁeld, i.e. Φm ∈ Z[X] is the m-th
cyclotomic polynomial. In this paper, we restrict to the case
of m being a power of 2. This means that Φm(X) = X n + 1
for n = 2l, l > 0 and m = 2n. Let q be an integer
∼
= Zq[X]/(X n + 1) with
modulus and deﬁne Rq = R/qR
Zq = Z/qZ. If χ is a probability distribution over R, then
$← χ denotes sampling x ∈ R according to χ. If S is a set,
x
then U (S) denotes the uniform distribution on S, and we denote
$← U (S)
sampling x uniformly at random from S either with x
$← S. If A is a probabilistic algorithm,
or sometimes x
$← A(x) denotes running A on input x with randomly
y
chosen coins and assigning the output to y. Different typefaces
and cases are used to represent different types of objects:
Algorithms (also A,B, . . . ); Queries; Protocols, Schemes,
and ProtocolMessages; variables; security-notions; and
Y (A) denotes the advantage of algorithm A
constants. Adv
in breaking security notion xxx of scheme or protocol Y.

xxx

A. The decision R-LWE problem

Using the above notation, we deﬁne the decision version of

the R-LWE problem as follows.
Deﬁnition 1 (Decision R-LWE problem). Let n, R, q and Rq
$← χ.
be as above. Let χ be a distribution over R, and let s
Deﬁne Oχ,s as the oracle which does the following:

$← U (Rq), e

$← χ,

1) Sample a
2) Return (a, as + e) ∈ Rq × Rq.

The decision R-LWE problem for n, q, χ is to distinguish Oχ,s
from an oracle that returns uniform random samples from Rq×
Rq. In particular, if A is an algorithm, deﬁne the advantage

(cid:2)(cid:2)(cid:2)Pr

(cid:3)
− Pr

(cid:4)
(cid:4)(cid:2)(cid:2)(cid:2)
(cid:3)
$← χ;AOχ,s (·) = 1
AU (Rq×Rq)(·) = 1

s

.

drlwe

n,q,χ(A) =

Adv

Note that the R-LWE problem presented here is stated in its
so-called normal form, which means that the secret s is chosen
from the error distribution instead of the uniform distribution
over Rq as originally deﬁned in [10]. See [27, Lemma 2.24]
for a proof of the fact that this problem is as hard as the one
in which s is chosen uniformly at random.

B. Rounding and reconciliation functions

The remainder of this section introduces notation and
concepts needed for the key exchange protocols below, mainly
following [20]. Let (cid:5)·(cid:6) : R → Z be the usual rounding function,
i.e. (cid:5)x(cid:6) = z for z ∈ Z and x ∈ [z − 1/2, z + 1/2).
Deﬁnition 2. Let q be a positive integer. Deﬁne the modular
rounding function

(cid:5)
(cid:5)

(cid:6)
(cid:7)

2
q x

mod 2.

4
q x

mod 2.

(cid:5)·(cid:6)q,2 : Zq → Z2, x (cid:8)→ (cid:5)x(cid:6)q,2 =

and the cross-rounding function

(cid:9)·(cid:10)q,2 : Zq → Z2, x (cid:8)→ (cid:9)x(cid:10)q,2 =

555555

.

,

4 and p0 = 1

Both functions are extended to elements of Rq coefﬁcient-wise:
(cid:3)
(cid:4)
for f = fn−1X n−1 + ··· + f1X + f0 ∈ Rq, deﬁne
(cid:4)
(cid:3)
(cid:5)fn−1(cid:6)q,2 ,(cid:5)fn−2(cid:6)q,2 , . . . ,(cid:5)f0(cid:6)q,2
(cid:9)fn−1(cid:10)q,2 ,(cid:9)fn−2(cid:10)q,2 , . . . ,(cid:9)f0(cid:10)q,2

(cid:5)f(cid:6)q,2 =
(cid:9)f(cid:10)q,2 =
In [20], Peikert deﬁnes a reconciliation mechanism using
the above functions. If the modulus q is odd, it requires to
work in Z2q instead of Zq to avoid bias in the derived bits.
Since we use odd q in this paper, we need to introduce the
randomized doubling function from [20]: let dbl : Zq →
Z2q, x (cid:8)→ dbl(x) = 2x−e, where e is sampled from {−1, 0, 1}
with probabilities p−1 = p1 = 1
2. The following
lemma shows that the rounding of dbl(v) ∈ Z2q for a uniform
random element v ∈ Zq is uniform random in Z2q given its
cross-rounding, i.e. (cid:9)dbl(v)(cid:10)
Lemma 1 ([20, Claim 3.3]). For odd q, if v ∈ Zq is uniformly
random and v
2q,2 is uniformly
random given (cid:9)v(cid:10)
is extended to
elements f ∈ Rq by applying it to each of its coefﬁcients,
resulting in a polynomial in R2q, which in turn can be taken
as an input to the rounding functions (cid:5)·(cid:6)
2q,2 and (cid:9)·(cid:10)
In [20], a reconciliation function is deﬁned to recover (cid:5)v(cid:6)q,2
from an element w ∈ Zq close to an element v ∈ Zq, given
only w and the cross-rounding (cid:9)v(cid:10)q,2. We recall the deﬁnition
(cid:9) − 1} and I1 =
(cid:8)
{−(cid:8)
from [20] working via Z2q since the modulus q is odd in
this paper. Deﬁne the sets I0 = {0, 1, . . . ,
function rec : Z2q × Z2 → Z2 is deﬁned by

$← dbl(v) ∈ Z2q, then (cid:5)v(cid:6)
2q,2.

, . . . ,−1}. Let E = [− q
4 ,

The randomized doubling function dbl

2q,2 hides (cid:5)dbl(v)(cid:6)

4 ), then the reconciliation

2q,2.

2q,2.

(cid:10)

q
2

q
2

q

(cid:11)

rec(w, b) =

0,
1,

if w ∈ Ib + E mod 2q,
otherwise.

2q,2.

2q,2.

2q,2) = (cid:5)v(cid:6)

It is shown in the next lemma that one can recover the rounding
(cid:5)dbl(v)(cid:6)
2q,2 of a random element v ∈ Zq from an element
w ∈ Zq close to v and the cross-rounding (cid:9)dbl(v)(cid:10)
Lemma 2 ([20, Section 3.2]). For odd q, let v = w + e ∈ Zq
for w, e ∈ Zq such that 2e ± 1 ∈ E (mod q). Let v = dbl(v).
Then rec(2w,(cid:9)v(cid:10)
Again, reconciliation of a polynomial
in Rq is done
coefﬁcient-wise using the reconciliation function on Z2q × Z2.
Note that Lemma 2 ensures that for two polynomials v, w ∈ Rq
which are close to each other, i.e. v = w + e for a polynomial
e, the polynomial w can be exactly reconciled to (cid:5)v(cid:6)
2q,2 given
(cid:9)v(cid:10)
2q,2 whenever every coefﬁcient ei ∈ Zq of the difference
e ∈ Rq satisﬁes 2ei±1 ∈ E (mod q). The rounding functions
in Deﬁnition 2 are trivial to implement. They involve a simple
precomputed partitioning of Zq into two (not necessarily
connected) subdomains D and Zq \ D, and on input of x ∈ Zq,
these functions return a bit depending on whether x ∈ D or
not. The time taken by the rounding functions is negligible
compared to the other cryptographic operations while the time
of the doubling function is dominated by sampling of the
necessary random bits (see Section VI-A for details).

556556

C. Discrete Gaussians

The distribution χ referred to in the above deﬁnition of the
R-LWE problem is usually a discrete Gaussian distribution
on R. Since this paper restricts to the case of n = 1024
being a power of 2, sampling from a discrete Gaussian can
be done by sampling each coefﬁcient from a 1-dimensional
discrete Gaussian DZ,σ with parameter σ (see [10, §1.2]).
The discrete Gaussian (see [28]) assigns to each x ∈ Z a
), normalized by the factor
probability proportional to e
−x2/(2σ2
−k2/(2σ2
).
S = 1+2
The discrete Gaussian distribution on R is the discrete Gaussian
DZn,σ obtained by sampling each coefﬁcient from DZ,σ.

−x2/(2σ2
), given by DZ,σ(x) = 1

(cid:12)∞

k=1 e

S e

III. UNAUTHENTICATED DIFFIE–HELLMAN-LIKE KEY

EXCHANGE PROTOCOL

In this section we describe an unauthenticated Difﬁe–
Hellman-like key exchange protocol based on the R-LWE
problem. In order to have an exact key exchange protocol,
we need to apply error correction to Alice’s computation
of the shared secret. We employ Peikert’s error correction
mechanisms described in §II-B, resulting in a key exchange
protocol that is effectively a reformulation of Peikert’s KEM
[20, §4]. There are several advantages to phrasing it as a Difﬁe–
Hellman-like protocol: it is easier to integrate into existing
network protocols like TLS that are DH-based; many other
cryptographic schemes are built from DH assumptions, so
having ring-LWE encapsulated as a DH-like assumption may
serve as a suitable building block elsewhere in cryptography;
and cryptographers and security practitioners we have spoken
with understand this work much better when we phrase it
as a DH-like protocol. This protocol, shown in Fig. 2, is a
rephrasing of the following computational problem:
Deﬁnition 3 (DDH-like problem). Let q, n, χ be R-LWE
parameters. The decision Difﬁe–Hellman-like (ddh(cid:4)) problem
for q, n, χ is to distinguish DH-like tuples with a real shared
secret from those with a random value, given reconciliation
information. If A is an algorithm, deﬁne
(cid:3)

ddh(cid:4)

Adv

q,n,χ(A) = |Pr (A(a, b, b
− Pr (A(a, b, b
(cid:3)
$← χ, b ← as + e, b
(cid:3)
, e, e
$← dbl(v), c ← (cid:9)v(cid:10)
2q,2, k ← (cid:5)v(cid:6)

, c, k) = 1)
) = 1)|

$← U (Rq), s, s
(cid:3)(cid:3), v

, c, k

, e

(cid:3)(cid:3)

(cid:3)

(cid:3)

,

(cid:3) ←
2q,2,

(cid:3)

where a
(cid:3), v ← bs
+ e
+ e
as
(cid:3) $← U ({0, 1}n).
and k

(cid:3)

Theorem 1 (Hardness of DDH-like problem). Let q be an odd
integer, let n be a parameter, and χ be a distribution on Rq.
If the decision R-LWE problem for q, n, χ is hard, then the
DDH-like problem for q, n, χ is also hard. More precisely,
n,q,χ(A ◦ B2)

n,q,χ(A ◦ B1) + Adv

n,q,χ(A) ≤ Adv

Adv

where B1 and B2 are the reduction algorithms given in Fig. 7.
The proof of Theorem 1 appears in Appendix C; a proof

drlwe

drlwe

ddh(cid:4)

sketch follows.

Public parameters
Decision R-LWE parameters q, n, χ
a $← U (Rq)
Alice
s, e $← χ
b ← as + e ∈ Rq

Bob
s(cid:2), e(cid:2) $← χ

b−→ b(cid:2) ← as(cid:2) + e(cid:2) ∈ Rq
e(cid:2)(cid:2) $← χ
v ← bs(cid:2) + e(cid:2)(cid:2) ∈ Rq
v $← dbl(v) ∈ R2q

kA ← rec(2b(cid:2)s, c) ∈ {0, 1}n

b(cid:2),c←− c ← (cid:5)v(cid:6)2q,2 ∈ {0, 1}n
kB ← (cid:7)v(cid:8)2q,2 ∈ {0, 1}n
Fig. 2. Unauthenticated Difﬁe–Hellman-like key exchange from R-LWE.

Proof (sketch). The proof closely follows Peikert’s proof of
IND-CPA security of the related KEM [20, Lemma 4.1]. It
proceeds by a sequence of games. The basic idea is as follows.
Note that in the initial protocol, there are three R-LWE pairs:
(cid:3)
(a, b) (with secret s); and (a, b
) and (b, v) (both with secret
(cid:3)). First, we replace the client’s ephemeral public key b with a
s
random value, so (a, b) becomes a random pair rather than an
R-LWE pair; by the decision R-LWE assumption, this change
is indistinguishable. Next, we simultaneously replace both the
(cid:3) and the session key b with
server’s ephemeral public key b
(cid:3)
random values, so (a, b
) and (b, v) become random pairs rather
than R-LWE pairs; again by the decision R-LWE assumption,
these changes are indistinguishable. This leaves the session key
being uniformly random and independent of the messages.

IV. IMPLEMENTING R-LWE

In this section we describe two implementations of the R-
LWE key exchange protocol. The difference between the two
implementations arises from the fact that one takes additional
measures to ensure that the routine runs in constant-time,
meaning that there is no data ﬂow from secret material to
branch conditions.

√

A. Parameter selection
For our implementation, we chose the following parameters:
n = 1024, q = 232−1, σ = 8/
2π ≈ 3.192. These parameters
provide a security of at least 128 bits against the distinguishing
attack described in [29], [30], [31], [32] with distinguishing
−128, when run by a classical, non-
advantage less than 2
quantum adversary. To achieve a certain advantage requires
the adversary to ﬁnd a short vector of a certain length in
a corresponding lattice. We evaluated the parameters with
the analysis from [32], which uses the BKZ-2.0 simulation
algorithm according to [33]. Based on our simulation results,
the parameters guarantee that an adversary running BKZ 2.0
cannot obtain a vector of the required size in 2128 steps, keeping
the distinguishing advantage below 2

−128.

Albrecht et al. [34] provide a variety of Sage scripts for
calculating the runtime of several different algorithms for (clas-
sically) solving LWE. With our parameters, the best classical

557557

attack is to solve LWE via BDD (Bounded Distance Decoding
problem) by reducing BDD to uSVP (unique shortest vector
problem) by Kannan’s embedding technique, and to implement
the SVP oracle via sieving; the total runtime is estimated
using Albrecht et al.’s scripts as 2163.8 operations (combining
heuristic runtime estimates with experimental observations)
with at least 294.4 memory usage. (See Appendix A for the
commands.)

The runtime of the best known quantum attacker is less clear.
While Grover’s search algorithm gives a square-root speedup to
the search problem, it is not necessarily the case that Grover’s
algorithm immediately halves the security level. For example,
Laarhoven et al. [35] give a quantum algorithm for ﬁnding
shortest lattice vectors in time 21.799n+o(n), compared to the
best known classical algorithm with time 22.465n+o(n). If the
best quantum algorithm is just a square-root speedup of the
best known classical algorithm, then our parameters would
require 281.9 operations for a quantum attacker to break; but
it is an open question whether Grover’s algorithm can naively
be applied in that way, or whether the quantum impact is less
dramatic like in the work of Laarhoven et al.

The above mentioned algorithms do not use the ideal lattice
structure, which means that they treat the R-LWE problem as a
general LWE problem. This is common practice, since currently
there is no attack on R-LWE that signiﬁcantly improves
upon the best known attacks on LWE for either a classical
or a quantum computer. Previous works on implementing
lattice-based cryptographic primitives typically use smaller
dimension (usually n = 512, provided the schemes are
not used for homomorphic encryption for which dimensions
are much larger). By increasing the dimension to 1024 we
are particularly conservative against progress in lattice-basis
reduction algorithms. The size of the modulus q provides a large
margin for correctness and could possibly be reduced. Note
that according to [36], the form of the modulus does not have
an inﬂuence on the security of the LWE problem. Assuming
that this also holds for R-LWE, we allow the modulus to be
composite.

B. Sampling from the Gaussian

In this subsection we describe how to sample small elements
in the ring Rq; this corresponds to the operations denoted as
$← χ in Fig. 2. We use a simple adaptation of the inversion
method, which independently samples each of the n = 1024
coefﬁcients of an Rq-element from a one-dimensional discrete
Gaussian. For more details on inversion sampling, and on
(R-)LWE-style sampling in general, see [28].
For a one-dimensional, discrete Gaussian distribution DZ,σ
centred at μ = 0 with standard deviation σ, recall from §II-C
the probability of a random variable taking the value x ∈ Z is

(cid:12)∞

where S =
we have S = 8.

k=−∞ e

−x2/(2σ2

),

1
S

DZ,σ(x) =

e

−k2/(2σ2

√
2π,
); in our case, when σ = 8/

Our adaptation of inversion sampling uses a precomputed
lookup table T = [T [0], . . . T [51]] of size 52, where T [0] =
(cid:5)2192 · 1

S(cid:15), where

(cid:16)(cid:17)

(cid:13)

T [i] =

2192 ·

(cid:14)

1
S

i(cid:15)

+ 2

DZ,σ(x)

x=1

1023

(cid:12)

$← χ,

for i = 1, . . . , 50, and where T [51] = 2192. Since S = 8,
note that all table elements are integers in [2189, 2192], and
that T [i + 1] > T [i] for i = 0, . . . , 50. The sampling of
an element s ∈ Rq, denoted s
is performed as
j=0 sjX j. For each j = 0, . . . , 1023,
follows. Write s =
we independently generate a 192-bit integer vj uniformly at
random, and compute the unique integer index indj ∈ [0, 50]
such that T [indj] ≤ vj < T [indj + 1]. We then generate one
additional random bit to decide the sign signj ∈ {−1, 1},
and return the j-th coefﬁcient as sj ← signj · indj. Note
$← χ requires 1024
that since every operation of the form s
random strings of length 192, in total we need 196,608 bits of
randomness for each execution of the operation $← χ. Since the
1024 coefﬁcients of s are sampled independently, the sampling
routine is embarassingly parallelizable.

As outlined above, our implementation needs a large amount
of random data (e.g. we need 24 KiB of random data each
time we sample a small ring element). It is sufﬁcient from a
security perspective and more efﬁcient to use a random number
generator to create a seed value whose size is determined by
the security parameter, then expand this seed using a pseudo
random number generator (PRNG) when sampling ring ele-
ments. The PRNG should use quantum-safe primitives to retain
security against quantum attackers. In our implementation, we
use OpenSSL’s RAND_bytes function to generate a 256-bit
seed, then use AES in counter mode as the PRNG function to
obtain the subsequent 24 KiB of data for sampling. We re-seed
the PRNG for each ring element.

The security (proof) of our protocol requires that the statis-
tical difference of our sampling algorithm and the theoretical
−128. The proposition below shows
distribution is less than 2
that this is indeed the case; the accompanying proof uses two
lemmas (and the associated notation) from [28].
(cid:3)(cid:3) be the distribution corresponding to
Proposition 1. Let D
the sampling routine described above and let DZn,σ be the true
n. The statistical difference
discrete Gaussian distribution on Z
Δ(D

, DZn,σ) of the two distributions is bounded by

(cid:3)(cid:3)

(cid:3)(cid:3)

Δ(D

, DZn,σ) < 2

−128.

√

2π and c = 1.30872 to get Pr(||v|| > 42σ) < 2

Proof. In [28, Lemma 1], we use k = 129, m = 1024, σ =
−129 for
8/
v ← DZn,σ. Subsequently, we take t = 42 and  = 2
−192
−k + 2mtσ =
in [28, Lemma 2] to get Δ(D
−128. Finally, for all x ∈
−129+2·210·42·(8/
2
Z with |x| > 51, the true probabilities DZ,σ(x) in [28, Lemma
−192,
2] (where they are denoted ρx) are such that DZ,σ(x) < 2
meaning that we can zero the approximate probabilities px
and maintain |px − DZ,σ(x)| = |DZ,σ(x)| < ; this allows the

−192 < 2

, DZn,σ) < 2

2π)·2

√

(cid:3)(cid:3)

558558

individual samples to be instead taken from [−51, 51], provided
T [51] is set as 2192 so that

x=−51 px = 1.

51

(cid:12)

We implemented the above sampling routine in two different
ways, based on the way that each index indj is retrieved
from T (on input of the random 192-bit integer vj). The ﬁrst
uses a plain binary search which (with overwhelmingly high
probability) returns the correct value ind using 6 (192-bit)
integer comparisons for each j. While this approach uses the
same number of identical steps each time it is called, it is not
constant-time. Accessing elements from different parts of the
table might require a variable amount of time depending on
whether or not this data was already loaded into the cache.
Attacks which use this type of information are known as cache-
attacks [37]. Thus, we also implemented a truly constant-time
sampling routine that loads every table element and creates
a mask based on whether each accessed element is smaller
than the input or not. This requires exactly 51 (constant-time)
integer comparisons, which explains the performance difference
between these routines (see Section VI).

C. Correctness of the scheme

In this subsection we provide a brief argument as to why

the key agreement scheme in Fig. 2 is indeed exact.
Proposition 2. If two parties honestly execute the protocol in
Fig. 2, the probability that the two derived keys are not the
same is less than 2

17.

−2

Proof. We use xi to denote the i-th coefﬁcient of a ring element
x ∈ Rq, i.e. x =
(cid:12)n−1
i=0 xiX i. By the cyclic nature of reduction
modulo X n + 1, it is straightforward to see that (xy)i =
j=0 xj ˜yj, where for each ﬁxed (i, j) there is a unique k such
that ˜yj = ±yk (i.e. the ˜yj’s are, up to sign, just a reordering
of the yj’s).

(cid:3)

8

(cid:3)

(cid:3)

(cid:3)

q
8

+ e

+ e

(cid:3)(cid:3)
i +

s)i| >
(cid:3)

s)i| ≥ q

)s and v = (as + e)s

s)i| = |(cid:12)n−1

The reconciliation functions that derive kA and kB from
(cid:3)(cid:3) in Fig. 2 can
(cid:3)
s = (as
b
only produce kA (cid:16)= kB if there is at least one value of i ∈
[0, n − 1] such that |vi − (b
− 1
2, see the condition
(cid:12)n−1
in Lemma 2. For a ﬁxed i, we bound the probability pi that
|vi − (b
2 as follows. Write |vi − (b
s)i| = |(es
− 1
(cid:3)
(cid:3)
(cid:3)
)i +
i − (e
j ˜sj|, where ˜sj
(cid:3)(cid:3)
(cid:3)
(cid:3)
j=0 e
j=0 ej ˜s
j + e
e
(cid:3)
j are used to denote the appropriate reorderings (and
and ˜s
(cid:3)
j, respectively.
sign changes when necessary) of the sj and s
Observe that since there are 2n + 1 terms in the previous
sum, if |vi − (b
(cid:3)
(cid:3)
2, then at least one of the ej, e
j,
sj, s
8(2n+1) in absolute
value (note that 511 < z < 512). As all of these coefﬁcients
are sampled from a one-dimensional discrete Gaussian, we
know the probability of an individual coefﬁcient exceeding
z in absolute value is equal to 2
x=512 DZ,σ(x). Since the
probability that at least one of the 2n + 1 terms exceeds z
is clearly bounded above by the sum of all 2n + 1 individual
probabilities (of each coefﬁcient exceeding z), we have that
x=512 DZ,σ(x). Similarly, the probability
pi < 2(2n + 1)
that at least one coefﬁcient of kA and kB disagree is clearly

s)i| >
(cid:3)(cid:3)
i must exceed z =

(cid:3)
j or indeed e

(cid:12)∞

(cid:12)∞

(cid:18)

− 1

q−4

q
8

(cid:12)n−1

bounded above by the sum of all the pi for 0 ≤ i < n, so we
get

Pr(kA (cid:16)= kB) ≤ n−1(cid:15)

pi < 2n(2n + 1)

DZ,σ(x).

i=0

x=512

∞(cid:15)

(cid:19) ∞

√
2σ
S

−t2

e

(cid:19) ∞

(cid:19) ∞

511

1
S

As an upper bound on the sum on the right hand side, we use
the integral

−x2/(2σ2

e

511

DZ,σ(x)dx =

)dx =
√
2 erfc(511), where erfc
The integral on the right is equal to
is the complementary error function. We use [38, Thm.1 and
Cor.1], and obtain that erfc(511) ≤ e
−511
2. Overall, we get
that Pr(kA (cid:16)= kB) ≤ 2n(2n + 1) · √
S · √
π
2. For our
2σ
2 e
parameters, we get Pr(kA (cid:16)= kB) ≤ 222e
−511
−2

−511

< 2

17.

dt.

511

π

2

D. Polynomial arithmetic

l

The arithmetic used in the key agreement

scheme
is polynomial arithmetic in the cyclotomic ring Rq =
Zq[X]/(Φ2l+1 (X)) where Zq = Z/qZ and Φ2l+1 (X) =
+ 1 is the 2l+1-th cyclotomic polynomial. We assume
X 2
that 2 is invertible in the ring Zq (i.e. q is odd). Multiplying
two elements in Rq can be achieved by computing the
discrete Fourier transform via fast Fourier transform (FFT) [39]
algorithms. More speciﬁcally, we use the approach from
Nussbaumer [40] based on recursive negacyclic convolutions
(see [41, Exercise 4.6.4.59] for more details) since this naturally
applies to cyclotomic rings where the degree is a power of 2.
Nussbaumer observed that for any ring R in which 2 is
invertible and whenever 2l = k · r with k | r then

R[X]/(X 2

l

+ 1)

∼
= (R[Z]/(Z

r

+ 1))[X]/(Z − X

k

),

where Z r/k is a 2k-th root of unity in R[Z]/(Z r + 1). Hence,
multiplying by powers of the root of unity is computationally
cheap since it boils down to shufﬂing around the polynomial
coefﬁcients. This polynomial multiplication method requires
O(l log l) multiplications in R. Investigation of other asymp-
totically efﬁcient polynomial multiplication algorithms, such
as Sch¨onhage-Strassen multiplication [42], is left as future
research.
We implemented the version of Nussbaumer’s method as
outlined by Knuth [41, Exercise 4.6.4.59]. We use q = 232 − 1
to deﬁne Zq, note that q is not prime (q = (21 + 1)(22 +
1)(24 + 1)(28 + 1)(216 + 1)). This choice of the modulus q
allows us to compute the modular reduction efﬁciently. We
follow the strategy for the modular arithmetic in [43], and our
implementation represents the elements in Zq as {0, . . . , q− 1}
(rather than, say, {−(cid:5)q/2(cid:6), ...,(cid:5)q/2(cid:6)}). If a prime modulus q
is required, one could use the eighth Mersenne prime: 231 − 1.
This also allows efﬁcient modular reduction but we found
that an exponent which is a multiple of eight outweighs other
positive performance aspects.

V. INTEGRATION INTO TLS

In this section we discuss the integration of R-LWE into
the Transport Layer Security (TLS) protocol. We describe
how to integrate the R-LWE-based key exchange protocol into
the message ﬂow of TLS, discuss our implementation in the
OpenSSL software,4 and demonstrate that the new ciphersuites
satisﬁes the standard security model for TLS.

A. Message ﬂow and operations

The message ﬂow and cryptographic computations for
our TLS ciphersuite with signatures for entity authentica-
tion and R-LWE for key exchange are given in Fig. 3.
The R-LWE key exchange values from the basic proto-
col (Fig. 2) are inserted in the ServerKeyExchange and
ClientKeyExchange messages. Notice that, compared with
signed-Difﬁe–Hellman ciphersuites, the server’s signature is
separated out from the ServerKeyExchange message into a
separate CertificateVerify message near the end of the
handshake; for the rationale of this design choice, see Remark 4.
Note that current drafts of TLS 1.3 [44] also separate out
the server signature into a separate message near the end of
the handshake even for normal signed-DH ciphersuites, so
our message ﬂow is compatible with the design of TLS 1.3.
We ﬁxed a public parameter a to be used by all parties. We
generated a once at random; for standardization purposes, a
single a value should be generated in a veriﬁably random,
“nothing up my sleeve” manner (e.g. as the output of a hash
function whose input is a well-deﬁned seed without much
room for choosing alternate inputs). The computation of each
of the ciphersuite-speciﬁc (highlighted) messages, as well as
the premaster key derivation, is given in Fig. 3. Notice that,
since the server sends the ﬁrst key exchange message, the
server plays the role of Alice from the basic unauthenticated
DH-like protocol (Fig. 2) and the client plays the role of Bob.

B. Implementation

We implemented the R-LWE-based ciphersuite described
in the previous subsection into OpenSSL. Speciﬁcally, we
created four new ciphersuites, all designed to achieve a 128-bit
security level. The ﬁrst two, RLWE-ECDSA-AES128-GCM-SHA256
and RLWE-RSA-AES128-GCM-SHA256, consist of:

• key exchange based on R-LWE key exchange, as described
in Section V-A and Fig. 3, with parameters as described
in Section IV-A, namely n = 1024, q = 232 − 1, and
σ = 8/
• authentication based on ECDSA or RSA digital signa-

2π;

√

tures;5

• authenticated encryption (with associated data) (AEAD)
based on AES-128 in GCM (Galois Counter Mode),
which provides conﬁdentiality as well as message integrity
without the addition of a separate MAC; and

• key derivation and hashing based on SHA-256.

4http://www.openssl.org/
5The ciphersuite does not ﬁx the ECDSA/RSA parameter sizes; to get
128-bit security, we use the nisp256 curve and 3072-bit RSA signatures.

559559

Client
ClientHello

Server

ServerHello

Certificate
ServerKeyExchange
∗

CertificateRequest

ServerHelloDone

accept
CertificateVerify
[ChangeCipherSpec]

compute keys
Finished

∗
Certificate
ClientKeyExchange
∗
CertificateVerify
[ChangeCipherSpec]

compute keys
Finished

verify signature
accept

application data

ServerKeyExchange:
1: s, e $← χ
2: b ← as + e
3: return b

ClientKeyExchange:
1: s(cid:2), e(cid:2) $← χ
2: b(cid:2) ← as(cid:2) + e(cid:2)
3: e(cid:2)(cid:2) $← χ
4: v ← bs(cid:2) + e(cid:2)(cid:2)
5: v $← dbl(v)
6: c ← (cid:5)v(cid:6)2q,2
7: return b(cid:2), c
Client compute keys:
1: pms ← (cid:7)v(cid:8)2q,2
2: Compute master secret ms and encryption keys as per TLS

speciﬁcation [9, §8.1, §6.3].

Server CertificateVerify:
1: Sign handshake messages to this point as in client’s

CertificateVerify algorithm [9, §7.4.8].

Server compute keys:
1: pms ← rec(2b(cid:2)s, c)
2: Compute master secret ms and encryption keys as per TLS

speciﬁcation [9, §8.1, §6.3].

denotes optional messages for client authentication and [ChangeCipherSpec] denotes the ChangeCipherSpec alert protocol message, after
) denote unprotected communication,
) denote encrypted/authenticated (record layer) communication, rectangles highlight messages or steps which have changed

∗
which all data sent by that party is encrypted and authenticated on the record layer. Single lines (
double lines (
for this ciphersuite.

Fig. 3. The TLS protocol with a signed R-LWE key exchange ciphersuite. Left: TLS message ﬂow. Right: R-LWE-speciﬁc computations.

We also created two HYBRID ciphersuites that are as above,
except the key exchange includes both R-LWE and ECDH key
exchange; the pre-master secret is the concatenation of the
ECDH shared secret and the R-LWE shared secret.

All these ciphersuite require TLSv1.2 because of the use
of AES-GCM (which we chose since it provably satisﬁes the
stateful length-hiding authenticated encryption notion [45]), but
TLSv1.0 ciphersuites using AES in CBC mode are possible.
We integrated our C code implementation of the R-LWE
operations described in Section IV into OpenSSL v1.0.1f.
Speciﬁcally, we added the unauthenticated DH-like protocol
from Section III to OpenSSL’s libcrypto module, then
added the TLS ciphersuite to OpenSSL’s libssl module,
and ﬁnally extended various OpenSSL command-line programs
(such as openssl speed, s_client, and s_server)
appropriately. Note that all required randomness is generated us-
ing OpenSSL’s RAND_bytes function. The resulting libraries
can then be used with OpenSSL-reliant applications with few
or no changes. For example, to use our R-LWE ciphersuite with
Apache’s httpd web server,6 it sufﬁces to recompile Apache
to link against the new OpenSSL library, and set the ciphersuite
option in Apache’s runtime conﬁguration ﬁles. We report on
the performance of the new ciphersuite in Section VI-B.

6http://httpd.apache.org/

C. Security model: authenticated and conﬁdential channel
establishment (ACCE)

We now turn to analyzing the security of our new TLS
ciphersuite. Jager et al. [12] introduced the authenticated and
conﬁdential channel establishment (ACCE) security model
to prove the security of TLS. It is based on the Bellare–
Rogaway model for authenticated key exchange [46], but
leaves the key exchange security property implicit, instead
having separate properties for entity authentication and channel
security, where the latter property is based on the stateful
length-hiding authenticated encryption notion introduced by
Paterson et al. [45] for the TLS record layer. In this subsection,
we present the ACCE security model, and in the next section
we prove security of the ciphersuite in that model. Our model
differs slightly from the original model in that it explicitly
includes forward secrecy. Our presentation is based largely on
the text of Bergsma et al. [47].
Parties, long-term keys, and sessions. The execution envi-
ronment consists of nP parties P1, . . . , PnP, each of whom is
a potential protocol participant. Each party Pi generates a long-
term private key / public key pair (ski, pki). Each party can
execute multiple sessions of the protocol, either concurrently
or subsequently. We denote the s-th session of a protocol at
party Pi by πs
i , and use nS to denote the maximum number

560560

of sessions per party. Each session within the party has read
access to the party’s long-term key, and read/write access to
the per-session variables. We overload notation and use πs
i to
denote the collection of the following per-session variables:
• ρ ∈ {init, resp}: The party’s role in this session.
• pid ∈ {1, . . . , nP,⊥}: The identiﬁer of the alleged peer
of this session, or ⊥ for an unauthenticated peer.
• α ∈ {inprogress, reject, accept}: The status of the
• k: A session key, or ⊥. Note that k consists of two
sub-keys: bi-directional authenticated encryption keys ke
and kd, which themselves may consist of encryption and
possibly MAC sub-keys.

session.

• sid: A session identiﬁer deﬁned by the protocol.
• stE, stD: State for the stateful authenticated encryption

and decryption algorithms (see Deﬁnition 9).

• b: A hidden bit (used for a security experiment). On

session initialization, b

$← {0, 1}.

• Additional state speciﬁc to the security experiment as

described in Fig. 4.

• Any additional state speciﬁc to the protocol.

Adversary interaction. The adversary controls all communi-
cations: it directs parties to initiate sessions, delivers messages
to parties, and can reorder, alter, delete, and create messages.
The adversary can also compromise certain long-term or per-
session secrets. The adversary interacts with the parties using
the following queries.

The ﬁrst query models normal, unencrypted communication

of parties during session establishment:

$→ m
(cid:3): The adversary sends message m
• Send(i, s, m)
to session πs
i . Party Pi processes message m according
to the protocol speciﬁcation and its per-session state πs
i ,
updates its per-session state, and optionally outputs an
(cid:3). There is a distinguished initializa-
outgoing message m
tion message which allows the adversary to initiate the
session with the role ρ it is meant to play in the session
and optionally the identity pid of the intended partner
of the session. This query may return error symbol ⊥ if
the session has entered state α = accept and no more
protocol messages are transmitted over the unencrypted
channel.

term and per-session secrets:

The next two queries model adversarial compromise of long-
• Reveal(i, s) → k: Returns session key πs
• Corrupt(i) → sk: Return party Pi’s long-term secret
key ski. Note the adversary does not take control of
the corrupted party or learn state variables, but can
impersonate Pi in later sessions by using ski.

i .k.

The ﬁnal

two queries model communication over the
encrypted channel. The adversary can cause plaintexts to be
encrypted as outgoing ciphertexts, and can cause ciphertexts to
be decrypted and delivered as incoming plaintexts. The queries
are used to capture the security notion of stateful length-hiding
authenticated encryption as described in Appendix A.

i .Cπs

i .b, πs

i .stE)
i .stE)
i .stE ← stπs

i .u ← πs
i .st0
i .st1
i .u ← C πs

i .u + 1
E) $← AENC.Enc(πs
E) $← AENC.Enc(πs
i .adπs

Enc(i, s, (cid:3), ad, m0, m1)
1: πs
i .k, (cid:3), ad, m0, πs
2: (C 0, πs
i .k, (cid:3), ad, m1, πs
3: (C 1, πs
4: if C 0 = ⊥ or C 1 = ⊥ then return ⊥
i .u ← ad, πs
5: πs
6: return C πs
i .b
Dec(i, s, ad, C)
i .b = 0 then return ⊥
1: if πs
2: j ← πs
i .pid, t ← index of (ﬁrst) matching session at Pj
i .v ← πs
3: πs
i .stD) ← AENC.Dec(πs
4: (m(cid:2), πs
i .v > πt
5: if πs
j.Cπs
i .phase ← 1
πs
6:
7: end if
8: if πs
9: return ⊥

i .v + 1
j.u or c (cid:10)= πt

i .k, ad, C, πs
i .v or ad (cid:10)= πt

i .phase = 1 then return m

i .stD)

j.adπs

i .v then

i .b

E

Fig. 4. Encrypt and Decrypt oracles for the ACCE security experiment.

$→ C: If πs
• Encrypt(i, s, m0, m1)
• Decrypt(i, s, C) → m or ⊥: If πs

returns ⊥. Otherwise, it procceds as in Fig. 4.
returns ⊥. Otherwise, it procceds as in Fig. 4.

i .k = ⊥, the query
i .k = ⊥, the query

The Encrypt/Decrypt oracles, which embody the stateful
length-hiding authenticated encryption property, simultaneously
capture four security properties:

• indistinguishability under chosen ciphertext attack: the ad-
versary cannot distinguish whether m0 or m1 is encrypted,
even when given access to a decryption oracle;

• integrity of ciphertexts: only ciphertexts generated by

legitimate parties successfully decrypt;

• integrity of associated data; and
• stateful delivery of ciphertexts:
deliver ciphertexts out of order.

the adversary cannot

i .b is leaked to the adversary if any of those

The hidden bit πs
conditions are violated.
Security experiment. The ACCE security experiment is played
between an adversary A and a challenger C who implements
all parties according to the execution environment above. After
the challenger initializes the long-term private key / public
key pairs, the adversary receives the public keys and then
interacts with the challenger using the queries above. Finally,
the adversary outputs a triple (i, s, b
) and terminates. The
adversary’s goal is to either break authentication (by causing
an honest session to accept without a matching session) or to
successfully guess that the bit b used in the Encrypt/Decrypt
(cid:3). The details of these
oracles of session SV owner is equal to b
security goals follow. We begin by deﬁning matching sessions.
Deﬁnition 4 (Matching sessions). We say that session πt
i .ρ (cid:16)= πt
j
matches πs
j.sid,
meaning that (i) if πs
i .sid, then
πt
j.sid is a preﬁx of πs
j sent the last message
in πs

i sent the last message in πs
i .sid, or (ii) if πt

i .sid preﬁx-matches πt

i .sid, then πs

j.ρ and πs

i .sid = πt

i if πs

j.sid.

(cid:3)

Correctness is deﬁned in the natural way: in the presence

561561

of a benign adversary, two communicating oracles will (with
overwhelming probability) accept, compute equal session keys,
and be able to successfully communicate encrypted application
data. For details see [48, full version, Defn. 10].

We can now deﬁne server-to-client (a.k.a., server-only)

i be a session. Let j = πs

authentication based on the existence of matching sessions.
Deﬁnition 5 (Server-to-client authentication). Let P be a
protocol. Let πs
i .pid. We say that πs
i
accepts maliciously if
i .α = accept;
i .ρ = init; and

1) πs
2) πs
3) no Corrupt(j) query was issued before πs

i accepted,

but there is no unique session πt

Deﬁne Adv

(A) as the probability that, when A
termiantes in the ACCE experiment for P , there exists a(n
initiator) session πs

i that has accepted maliciously.

acce-so-auth
P

j which matches πs
i .

We deﬁne channel security based on the adversary’s ability
to guess the hidden bit b of an uncompromised session, thereby
breaking one of the four properties of stateful length-hiding
authenticated encryption described above. We focus on channel
security in the context of server-only authentication, so the
adversary wins if it guesses the hidden bit at any client session,
or at any server session in which it was passive.
Deﬁnition 6 (Channel security with forward secrecy in
server-only authentication mode). Let P be a protocol. Let πs
i .pid. Suppose A outputs (i, s, b
i
(cid:3)
be a session. Let j = πs
). We
say that A answers the encryption challenge correctly if

i .α = accept;

1) πs
2) no Corrupt(i) query was issued before πs
3) no Corrupt(j) query was issued before any session πt
j

i accepted;

which matches πs

i accepted;

4) no Reveal(i, s) query was ever issued;
5) no Reveal(j, t) query was ever issued for any session πt
j

which matches πs
i ;
(cid:3);
6) πs
i .b = b
7) and either:

a) πs
b) πs

i .ρ = init; or
i .ρ = resp and there exists a session which
matches πs
i .
(A) as |p − 1/2|, where p is the
acce-so-aenc-fs
Deﬁne Adv
probability that, in the ACCE experiment for P , A answers
P
the encryption challenge correctly.

Remark 1 (Mutual authentication). We focus on the case of
server-to-client authentication, as that is the dominant mode in
which TLS is used on the Internet. The ACCE framework can
deal with the mutual authentication case as well, by removing
item 2 from Deﬁnition 5 and item 7 from Deﬁnition 6.

D. Security result

The following informal theorem summarizes our security
result for our R-LWE-based TLS ciphersuite. The proof is in
the standard model, and does not rely on random oracles.

562562

Theorem 2 (TLS signed R-LWE is a secure ACCE (informal)).
Let TLS-RLWE-SIG-AENC denote the TLS protocol with a R-
LWE-based ciphersuite as described in Fig. 3, with SIG for
the signature scheme and AENC as the stateful length-hiding
authenticated encryption for the record layer. Let PRF denote
the pseudorandom function used by TLS in that ciphersuite.
If the signature scheme SIG is existentially unforgeable under
chosen message attack, then TLS-RLWE-SIG-AENC provides
secure server-to-client authentication.

If additionally the DDH-like problem for the R-LWE pa-
rameters is hard, PRF is a secure pseudorandom function, and
AENC is a secure stateful length-hiding authenticated encryption
scheme, then TLS-RLWE-SIG-AENC provides channel security,
with forward secrecy, in server-only auth. mode.

Moreover, the protocol is correct with high probability.

Precise statements for the server-to-client authentication
property and the channel security property are given in
Lemmas 3 and 4 in Appendix D; a sketch of the argument
follows. Precise statements of the correctness property are
omitted, as they follow clearly from Section IV-C. Security
deﬁnitions of standard cryptographic components appear in
Appendix A.

Proof (sketch). The server-to-client authentication property fol-
lows straightforwardly from the unforgeability of the signature
scheme. The proof proceeds ﬁrst by ensuring that honest parties
use unique nonces in the ClientHello and ServerHello
messages. From there, it is easy to see that an honest client
who accepts without a matching server instance has done so
because of a signature forgery. A key aspect of the proof is
that the signature comes later in the protocol ﬂow than in
existing signed-DH ciphersuites in TLS; see Remark 4 below
for details.

The channel security property is shown using a sequence of
games. First, we assume that there are no sessions without a
matching session, which for client instances follows from the
server-to-client authentication property and for server instances
follows from the freshness condition in Deﬁnition 6. Next,
we guess the session that will be attacked by the adversary
and replace the R-LWE key established in that session with a
random value, which cannot be detected due to the security
of the basic DDH-like ring-LWE protocol in Theorem 1.
The master secret and authenticated encryption keys are then
replaced with random values using the security of the PRF.
Finally, any break of the conﬁdentiality or integrity of the
channel in the target session corresponds to a break of the
authenticated encryption scheme, since we have decoupled the
encryption key from the TLS handshake.

Remark 2 (Quantum-safe reduction and long-term security).
Song [49] notes that security proofs of allegedly post-quantum
classical schemes typically assume classical adversaries, and it
does not immediately follow that the proof “lifts” to provide
security against quantum adversaries. Song gives conditions
under which a classical proof can be lifted to provide quantum
security. Some technical conditions must be met, including

the reduction is a “straight-line” reduction, meaning
that
that the reduction runs the adversary from beginning to end,
without rewinding or restarting. Our reductions are straight-line
reductions. Thus, it seems that Song’s framework should apply:
if all of the other primitives in our ciphersuite are quantum-safe
with proofs against classical adversaries, then they should also
be secure against quantum adversaries.

Even if our non-quantum-safe digital signatures are used in
our construction (as we do in our implementation), users still
have a long-term security property [50]: a polynomial-time
quantum computer built in the future may be able to break
authentication of sessions that occur after it exists, but cannot
decrypt sessions that were executed before it was active.
Remark 3 (Multi-ciphersuite security). Bergsma et al. [47]
extend the ACCE deﬁnition to consider the case of multi-
ciphersuite security, when long-term public keys are shared
across multiple ciphersuites using the same long-term authen-
tication algorithm but different key exchange or encryption
algorithms. Just because a ciphersuite is ACCE-secure on its
own does not mean that ciphersuite is secure in when its
long-term public key is used in other ciphersuites.

Bergsma et al. give a framework for proving multi-ciphersuite
security. They give a composition theorem that says many
mutually compatible ciphersuites are secure with shared long-
term keys provided each ciphersuite is ACCE-secure with an
auxiliary oracle that provides access to operations based on
the long-term key. One must then prove that the individual
ciphersuite remains ACCE-secure even when the auxiliary
oracle provides operations based on the long-term key.

The signed ﬁnite ﬁeld and elliptic Difﬁe–Hellman cipher-
suites in TLS do not satisfy this property because the data
structure that is signed in these ciphersuites consists just
of the random nonces and the ephemeral public key. But
Bergsma et al. do show that signed-Difﬁe–Hellman ciphersuites
in SSH are multi-ciphersuite secure.

However, in our TLS-R-LWE ciphersuite, the data structure
that is signed consists of the entire transcript, which uniquely
identiﬁes the ciphersuite. This sufﬁces to be able to prove
TLS-R-LWE is ACCE-secure with an auxiliary signing oracle,
where the predicate Φ (in Bergsma et al.’s framework) is based
on the ciphersuite chosen by the server in the ServerHello
message in the transcript; thus our TLS-R-LWE ciphersuite is
multi-ciphersuite secure. It is safe to reuse the same long-term
signing with other compatible multi-ciphersuite secure ACCE
protocols, including signed-Difﬁe–Hellman ciphersuites in SSH
and a hypothetical future version of signed-DH ciphersuites in
TLS that sign the entire transcript.
Remark 4 (Oracle assumptions and moving the server signature).
The security proofs of signed-DH ciphersuites in TLS [12],
[48] required a new Difﬁe–Hellman assumption, the PRF-
Oracle-Difﬁe–Hellman assumption. Instead of the normal
decision Difﬁe–Hellman assumption, which assumes that the
adversary cannot distinguish real DH tuples (g, gu, gv, guv)
from random tuples (g, gu, gv, gw), the PRF-ODF assumption
assumes the adversary cannot distinguish tuples of the form

$← {0, 1}(cid:4)), where m
(g, gu, gv, F(guv, m)) from (g, gu, gv, z
is chosen in advance by the adversary and F is a pseudorandom
function (see Appendix A), even given access to an oracle that
) for any X (cid:16)= gu. While controversial when
(cid:3)
outputs F(X v, m
initially proposed by Jager et al. [12], Krawczyk et al. [48,
full version, Appendix C] later demonstrated that the PRF-
ODH assumption was in fact necessary, and that a simple PRF
assumption would not sufﬁce.

The reason signed-DH ciphersuites in TLS require the PRF-
ODH assumption is that the server’s signature comes very
early in the protocol (as part of the ServerKeyExchange).
This signature is only over the client and server nonces
and the server’s ephemeral public key value; server-to-client
authentication of the full handshake transcript is done using
a MAC under the session key, which was derived from the
DH shared secret. An attacker trying to trick the client into
accepting a fake transcript could do so either by forging a
signature early in the handshake or by trying to break the
session key and MAC calculation later in the handshake. This
is why the PRF-oracle-DH assumption is required.

In our R-LWE-based ciphersuite in Fig. 3, we move the
server’s signature to later in the handshake, so that server-to-
client authentication of the full handshake transcript is done
using the signature scheme. This allows us to prove server-to-
client authentication using just signature security, rather than
some oracle-DH-like assumption. Our change however is not
just for convenience. As noted by Peikert [20, §5.3], R-LWE
assumptions are not hard in an oracle setting: “the reason
is related to the search/decision equivalence for (ring)-LWE:
the adversary can query the [...] oracle on a specially crafted
[values] for which the [...] oracle input is one of only a small
number of possibilities (and depends on only a small portion
of the secret key), and can thereby learn the entire secret key
very easily.” Technically, the oracle-like assumption used in
TLS would only require security against a single query per
secret, whereas the attack discusses the use of multiple queries.
It is an interesting open question to determine whether oracle
R-LWE assumptions with a single query remain secure.

VI. PERFORMANCE

In this section we outline the performance of the separate
components used for the cryptographic implementation, as
well as overall performance numbers when integrated within
the OpenSSL framework.7 Our standalone C implementation
has no OpenSSL dependencies, and should be quite easy to
integrate with other libraries and protocols.

Timings reported involved two computers. Our “client”
computer had an Intel Core i5 (4570R) processor with 4 cores
running at 2.7 GHz each. Our “server” computer had an Intel
Core 2 Duo (E6550) processor with 2 cores running at 2.33 GHz
each. Software was compiled for the x86_64 architecture with

7Source code for our standalone R-LWE implementation is available under
a public domain license at https://github.com/dstebila/rlwekex. Source code
for our modiﬁcations to OpenSSL is available under the OpenSSL license at
https://github.com/dstebila/openssl-rlwekex/tree/OpenSSL 1 0 1-stable.

563563

AVERAGE CYCLE COUNT OF STANDALONE MATHEMATICAL OPERATIONS

TABLE I

(ON CLIENT COMPUTER)

AVERAGE RUNTIME IN MILLISECONDS OF CRYPTOGRAPHIC OPERATIONS

TABLE II

USING openssl speed

Operation
sample $← χ
FFT multiplication
FFT addition
dbl(·) and crossrounding (cid:3)·(cid:4)2q,2
rounding (cid:5)·(cid:6)2q,2
reconciliation rec(·, ·)

constant-time

Cycles

non-constant-time

Operation

1 042 700
342 800
1 660
23 500
5 500
14 400

668 000
—
—
21 300
3,700
6 800

R-LWE key generation
R-LWE Bob shared secret
R-LWE Alice shared secret
Total R-LWE runtime
EC point mul., nistp256
Total ECDH runtime
RSA sign, 3072-bit key
RSA verify, 3072-bit key

Client
Server
constant-time
0.9
1.7
(1.1)
0.5
0.4
(0.1)
2.1
1.4
0.7
0.4
0.8
1.4
8.8
(3.7)
0.1
(0.2)

Client
Server
non-constant-time

0.6
0.4
(0.1)
1.0
—
—
—
—

1.3
(0.9)
0.4
1.7
—
—
—
—

-O3 optimizations using llvm 5.1 (clang 503.0.40) on the
client computer and gcc 4.7.2 on the server computer.

Numbers in parentheses are reported for completeness, but do not contribute

to the runtime in the client and server’s role in the TLS protocol.

A. Standalone cryptographic operations

The average performance numbers, expressed in cycles on
the client computer, for the individual mathematical operations
used in our implementation are summarized in Table I. We
distinguish between operations which have a constant or
variable running time. Note that
the computation of the
polynomial arithmetic (the computation of the DFT) and the
computation with the coefﬁcients of these polynomials (the
modular arithmetic) are designed to run inherently in constant-
time. This code contains no branches except for simple loop-
counters which do not depend on any secret material. The
operation with the highest running time is the sampling. As
outlined in Section IV-B, our approach requires a signiﬁcant
amount of random data as well as a number of (constant-time)
comparison operations to a 52-entry look-up table. Querying
this random data consumes most of the time in the sampling
function. Accessing all elements in the sampling table in order –
as performed for the constant-time approach (see Section IV-B)
– can be done relatively efﬁciently, since the total size is
slightly over 1.2 KiB, and this ﬁts in the cache. Although
we access 52/6 ≈ 8.7 times more table elements compared
to the binary search approach, the overall slow-down is less
than a factor two for the sampling functionality. The time for
computing the polynomial multiplication using the Nussbaumer
FFT algorithm (see Section IV-D) includes the two forward
and single inverse FFT transforms. Interestingly, computing
the high-degree polynomial multiplications is (much) faster
than sampling.

B. Within TLS and HTTPS

In this section we draw a comparison between the per-
formance of RSA-signed elliptic curve Difﬁe–Hellman and
RSA-signed R-LWE-based TLS ciphersuites within the context
of an HTTPS connection. Our approach for analyzing the
performance of ECDH versus R-LWE in TLS/HTTPS follows
that of Gupta et al. [51], who analyzed the performance of
RSA versus ECDH. Our comparison takes place at the 128-

√

bit security level:8 for elliptic curve operations we used the
nistp256 curve [53] and for R-LWE operations we used the
R-LWE parameters as described in Section IV-A (n = 1024,
q = 232 − 1, and σ = 8/
2π). For RSA authentication,
the server used a 3072-bit RSA self-signed certiﬁcate or a
nistp256 ECDSA certiﬁcate depending on the ciphersuite;
no client authentication was used. As noted in Section V-B,
the implementation is based on OpenSSL v1.0.1f.
OpenSSL cryptographic primitive performance. Table II
shows the runtime of operations within the context of
OpenSSL’s crypto library using the openssl speed com-
mand. For R-LWE, we report
the performance of both
our constant-time and non-constant-time implementations.
OpenSSL’s RSA and nistp256 code is constant-time.

Table II shows that, in the context of R-LWE key exchange,
a constant-time implementation only slows the client and server
down by factors 1.4x and 1.2x (respectively) over a non-
constant-time implementation; this presents a strong argument
for adopting a sampling routine that is side-channel resistant.
When comparing the total runtime for ephemeral key exchange,
it is encouraging to see that, on both the client and the server
sides, the post-quantum R-LWE key exchange incurs less than
a factor 2x performance loss over key exchange using the
nistp256 curve: the client is slower by a factor 1.8x, while
the server is only slower by a factor 1.5x.

The only other implementation for R-LWE with comparable
parameters of which we are aware is by Zhang et al. [21].
Their authenticated key exchange protocol has a somewhat
different structure, and in particular achieves both key exchange
and authentication from R-LWE. They do not report timings
for individual cryptographic operations like in Table I, only
total protocol operations like in Table II. Results are not
directly comparable, although in the end both protocols
achieve authenticated key exchange, so there is some basis for
comparison. Their protocol’s implementation requires 14.57 ms

8To provide a direct comparison with non-quantum-safe implementations,
we have aimed for 128-bit security against classical adversaries, rather than
128-bit security against quantum adversaries which would require the use of
256-bit AES due to Grover’s search algorithm [52].

564564

for key generation and 3.7 ms for shared secret generation on
a 2.83GHz Intel Core 2 Quad processor. Even accounting for
authentication and the slight difference in hardware, this is an
order of magnitude slower than our software.
OpenSSL/Apache TLS performance. Table III shows the
performance of ECDH, R-LWE, and hybrid ciphersuites within
the context of HTTP connections over TLS. For R-LWE, we
use the constant-time code. The server was running Apache
httpd 2.4.10 with the prefork module for multi-threading. The
client and server computers were connected over an isolated
local area network with less than 1 ms ping time.

The ﬁrst section of Table III reports the number of si-
multaneous connections supported by the server. Multiple
client connections were generated using the http_load tool
(version 09jul2014),9 which makes many HTTP connections
in parallel using OpenSSL for TLS. The client and network
conﬁguration was sufﬁcient to ensure that the server’s 2 cores
had at least 95% utilization during all tests. Session resumption
was disabled. To simulate a variety of web page sizes, we ran
separate benchmarks where the HTTP payload was 1 byte,
1 KiB = 1024 bytes, 10 KiB, and 100 KiB. Each test was run
for 100 seconds; ﬁgures reported are the average of 5 runs,
with standard deviation listed in parentheses and performance
penalty compared to ECDH key exchange listed in bold. The
second section of Table III reports the time required for the
client to establish a connection, measured using Wireshark
from when the client opens the TCP connection to the server’s
IP address to when the client starts to receive the ﬁrst packet
of application data. The ﬁnal section of the table shows the
size of the handshake in each case.

Table III shows that, when ECDSA is used as the authentica-
tion mechanism, employing R-LWE as the TLS key exchange
mechanism achieves between a factor 1.2–1.3x fewer HTTP
connections per second than when ECDH key exchange is
used. On the other hand, when coupled instead with RSA
signatures, the relative difference between the R-LWE and
ECDH key exchange components is diluted by the slower
authentication, and the number of connections per second
is (relatively speaking) much closer. These is a larger ratio
when comparing the connection times obtained using ECDH
key exchange versus R-LWE key exchange, which may be
explained due to the difference in the size of the TLS handshake.
In all cases, Table III shows that the hybrid version (which
combines R-LWE for post-quantum assurance and ECDH
for FIPS compliance) naturally performs the slowest. Again
however, when coupled with RSA signatures, the number of
connections per second is only a factor 1.2x fewer than an
ECDH-only connection.

VII. CONCLUSIONS

The ring learning with errors (R-LWE) problem is a
promising cryptographic primitive that is believed to be resistant
to attacks by quantum computers. The decision R-LWE problem
naturally leads to a Difﬁe–Hellman-like unauthenticated key

9http://www.acme.com/software/http_load/

565565

exchange protocol. We have integrated this key exchange mech-
anism into the Transport Layer Security protocol. The resulting
provably secure construction provides post-quantum forward
secrecy yet remains practical, both in terms of efﬁciency and
in terms of its integration with the widely-deployed RSA-based
public key authentication infrastructure. Our constant-time C
implementation in the OpenSSL library shows that web servers
using R-LWE key exchange incur a small performance penalty
to achieve post-quantum assurance. Even hybrid key exchange—
using both R-LWE and elliptic curve Difﬁe–Hellman for “best
of both worlds” security—provides reasonable performance.
With post-quantum cryptography still in its early days, future
work includes optimization of parameter sizes, implementations,
and comparisons between post-quantum primitives.

ACKNOWLEDGEMENTS

D.S. acknowledges funding from the Australian Research
(ARC) Discovery Project scheme under grant

Council
DP130104304.

REFERENCES

[1] O. Regev, “On lattices, learning with errors, random linear codes, and
cryptography,” in 37th ACM STOC, H. N. Gabow and R. Fagin, Eds.
ACM Press, May 2005, pp. 84–93.

[2] ——, “Lattice-based cryptography (invited talk),” in CRYPTO 2006, ser.
LNCS, C. Dwork, Ed., vol. 4117. Springer, Aug. 2006, pp. 131–141.
[3] C. Gentry, “Fully homomorphic encryption using ideal lattices,” in 41st
ACM STOC, M. Mitzenmacher, Ed. ACM Press, May / Jun. 2009, pp.
169–178.

[4] S. Garg, C. Gentry, and S. Halevi, “Candidate multilinear maps from
ideal lattices,” in EUROCRYPT 2013, ser. LNCS, T. Johansson and P. Q.
Nguyen, Eds., vol. 7881. Springer, May 2013, pp. 1–17.

[5] P. W. Shor, “Polynomial-time algorithms for prime factorization and
discrete logarithms on a quantum computer,” SIAM Journal on Computing,
vol. 26, no. 5, pp. 1484–1509, 1997.

[6] R. L. Rivest, A. Shamir, and L. M. Adleman, “A method for obtaining
digital signature and public-key cryptosystems,” Communications of the
Association for Computing Machinery, vol. 21, no. 2, pp. 120–126, 1978.
[7] V. S. Miller, “Use of elliptic curves in cryptography,” in CRYPTO’85,
ser. LNCS, H. C. Williams, Ed., vol. 218. Springer, Aug. 1985, pp.
417–426.

[8] N. Koblitz, “Elliptic curve cryptosystems,” Mathematics of Computation,

vol. 48, no. 177, pp. 203–209, 1987.

[9] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) Protocol
Version 1.2,” RFC 5246 (Proposed Standard), Internet Engineering Task
Force, Aug. 2008. [Online]. Available: http://www.ietf.org/rfc/rfc5246.txt
[10] V. Lyubashevsky, C. Peikert, and O. Regev, “On ideal lattices and learning
with errors over rings,” Journal of the ACM, vol. 60, no. 6, p. 43, 2013.
[11] W. Difﬁe and M. E. Hellman, “New directions in cryptography,” IEEE
Transactions on Information Theory, vol. 22, no. 6, pp. 644–654, 1976.
[12] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk, “On the security of TLS-
DHE in the standard model,” in CRYPTO 2012, ser. LNCS, R. Safavi-
Naini and R. Canetti, Eds., vol. 7417. Springer, Aug. 2012, pp. 273–293.
[13] J. W. Bos, J. A. Halderman, N. Heninger, J. Moore, M. Naehrig, and
E. Wustrow, “Elliptic curve cryptography in practice,” Cryptology ePrint
Archive, Report 2013/734, 2013, http://eprint.iacr.org/2013/734.

[14] P. C. Kocher, “Timing attacks on implementations of Difﬁe-Hellman,
RSA, DSS, and other systems,” in CRYPTO’96, ser. LNCS, N. Koblitz,
Ed., vol. 1109. Springer, Aug. 1996, pp. 104–113.

[15] NIST. (2012, July) Recommendations for key management – Part 1:
General (revision 3). [Online]. Available: http://csrc.nist.gov/publications/
nistpubs/800-57/sp800-57 part1 rev3 general.pdf

[16] J. Ding, X. Xie, and X. Lin, “A simple provably secure key exchange
scheme based on the learning with errors problem,” Cryptology ePrint
Archive, Report 2012/688, 2012, http://eprint.iacr.org/2012/688.

[17] O. Blazy, C. Chevalier, L. Ducas, and J. Pan, “Exact smooth projective
hash function based on LWE,” Cryptology ePrint Archive, Report
2013/821, 2013, http://eprint.iacr.org/2013/821.

PERFORMANCE OF HTTPS USING APACHE WITH OPENSSL

TABLE III

ECDHE

RLWE

HYBRID

ECDSA

RSA

ECDSA

RSA

ECDSA

RSA

Connections / second:
— 1 B payload
— 1 KiB payload
— 10 KiB payload
— 100 KiB payload
Connection time (ms)
Handshake (bytes)

645.9 (2.1)
641.6 (3.1)
630.2 (2.3)
487.6 (1.4)
6.0 (0.13)
1 278

177.4 (0.1)
177.0 (0.2)
176.2 (0.3)
161.2 (0.3)
14.0 (0.24)
2 360

507.5 (1.7) 1.27× 164.2 (0.2) 1.08× 362.9 (0.6) 1.78× 145.1 (0.3) 1.22×
505.9 (2.1) 1.27× 163.8 (0.2) 1.08× 361.0 (1.2) 1.78× 145.0 (0.1) 1.22×
494.9 (0.9) 1.27× 161.9 (1.2) 1.09× 356.2 (0.6) 1.77× 144.1 (0.2) 1.22×
397.6 (1.4) 1.23× 150.2 (1.2) 1.07× 300.5 (1.1) 1.62× 134.3 (0.1) 1.20×
54.6 (1.35) 3.9×
45.6 (0.90) 7.6×
9 469 7.4×
10 690 4.5×

47.2 (0.41) 7.9×
9 607 7.5×

54.0 (1.49) 3.9×
10 479 4.4×
Legend: mean, (std. dev.), penalty compared to ECDHE

[18] J. Katz and V. Vaikuntanathan, “Smooth projective hashing and password-
based authenticated key exchange from lattices,” in ASIACRYPT 2009, ser.
LNCS, M. Matsui, Ed., vol. 5912. Springer, Dec. 2009, pp. 636–652.
[19] A. Fujioka, K. Suzuki, K. Xagawa, and K. Yoneyama, “Practical and
post-quantum authenticated key exchange from one-way secure key
encapsulation mechanism,” in ASIACCS 13, K. Chen, Q. Xie, W. Qiu,
N. Li, and W.-G. Tzeng, Eds. ACM Press, May 2013, pp. 83–94.

[20] C. Peikert, “Lattice cryptography for the Internet,” in PQCrypto 2014,

ser. LNCS, M. Mosca, Ed., vol. 8772. Springer, 2014, pp. 197–219.
[21] J. Zhang, Z. Zhang, J. Ding, M. Snook, and ¨O. Dagdelen, “Authenticated
key exchange from ideal lattices,” Cryptology ePrint Archive, Report
2014/589, 2014, http://eprint.iacr.org/2014/589.

[22] E. Fujisaki and T. Okamoto, “How to enhance the security of public-
key encryption at minimum cost,” in PKC’99, ser. LNCS, H. Imai and
Y. Zheng, Eds., vol. 1560. Springer, Mar. 1999, pp. 53–68.

[23] A. Fujioka, K. Suzuki, K. Xagawa, and K. Yoneyama, “Strongly secure
authenticated key exchange from factoring, codes, and lattices,” in
PKC 2012, ser. LNCS, M. Fischlin, J. Buchmann, and M. Manulis,
Eds., vol. 7293. Springer, May 2012, pp. 467–484.

[24] H. Krawczyk, “SIGMA: The “SIGn-and-MAc” approach to authenticated
Difﬁe-Hellman and its use in the IKE protocols,” in CRYPTO 2003, ser.
LNCS, D. Boneh, Ed., vol. 2729. Springer, Aug. 2003, pp. 400–425.
[25] J. Hoffstein, J. Pipher, and J. H. Silverman, “NTRU: A ring based public
key cryptosystem,” in Algorithmic Number Theory (ANTS III), ser. LNCS,
J. P. Buhler, Ed., vol. 1423. Springer, 1997, pp. 267–288.

[26] A. Singer, “NTRU cipher suites for TLS,” July 2001, Internet-Draft.

[Online]. Available: https://tools.ietf.org/html/draft-ietf-tls-ntru

[27] V. Lyubashevsky, C. Peikert, and O. Regev, “A toolkit for ring-LWE
cryptography,” in EUROCRYPT 2013, ser. LNCS, T. Johansson and P. Q.
Nguyen, Eds., vol. 7881. Springer, May 2013, pp. 35–54.

[28] N. C. Dwarakanath and S. D. Galbraith, “Sampling from discrete
gaussians for lattice-based cryptography on a constrained device,” Appl.
Algebra Eng. Commun. Comput., vol. 25, no. 3, pp. 159–180, 2014.

[29] D. Micciancio and O. Regev, “Lattice-based cryptography,” in Post-
Quantum Cryptography, D. J. Bernstein, J. Buchmann, and E. Dahmen,
Eds. Springer Berlin Heidelberg, 2009, pp. 147–191.

[30] R. Lindner and C. Peikert, “Better key sizes (and attacks) for LWE-based
encryption,” in CT-RSA 2011, ser. LNCS, A. Kiayias, Ed., vol. 6558.
Springer, Feb. 2011, pp. 319–339.

[31] J. van de Pol and N. P. Smart, “Estimating key sizes for high
dimensional lattice-based systems,” in 14th IMA International Conference
on Cryptography and Coding, ser. LNCS, M. Stam, Ed., vol. 8308.
Springer, Dec. 2013, pp. 290–303.

[32] T. Lepoint and M. Naehrig, “A comparison of the homomorphic
encryption schemes FV and YASHE,” in AFRICACRYPT 2014, ser.
LNCS, D. Pointcheval and D. Vergnaud, Eds., vol. 8469.
Springer,
2014, pp. 318–335.

[33] Y. Chen and P. Q. Nguyen, “BKZ 2.0: Better lattice security estimates,”
in ASIACRYPT 2011, ser. LNCS, D. H. Lee and X. Wang, Eds., vol.
7073. Springer, Dec. 2011, pp. 1–20.

[34] M. R. Albrecht, R. Player, and S. Scott, “On the concrete hardness of
learning with errors,” Cryptology ePrint Archive, Report 2015/046, 2015,
http://eprint.iacr.org/2015/046.

[35] T. Laarhoven, M. Mosca, and J. van de Pol, “Finding shortest lattice
vectors faster using quantum search,” Cryptology ePrint Archive, Report
2014/907, 2014, http://eprint.iacr.org/2014/907.

566566

[36] Z. Brakerski, A. Langlois, C. Peikert, O. Regev, and D. Stehl´e, “Classical
hardness of learning with errors,” in 45th ACM STOC, D. Boneh,
T. Roughgarden, and J. Feigenbaum, Eds. ACM Press, Jun. 2013,
pp. 575–584.

[37] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks and countermea-
sures: The case of AES,” in CT-RSA 2006, ser. LNCS, D. Pointcheval,
Ed., vol. 3860. Springer, Feb. 2006, pp. 1–20.

[38] S. Chang, P. C. Cosman, and L. B. Milstein, “Chernoff-type bounds for
the Gaussian error function,” IEEE Transactions on Communications,
vol. 59, no. 11, pp. 2939–2944, 2011.

[39] J. W. Cooley and J. W. Tukey, “An algorithm for the machine calculation
of complex Fourier series,” Mathematics of Computation, vol. 19, pp.
297–301, 1965.

[40] H. J. Nussbaumer, “Fast polynomial transform algorithms for digital
convolution,” IEEE Transactions on Acoustics, Speech and Signal
Processing, vol. 28, no. 2, pp. 205–215, 1980.

[41] D. E. Knuth, Seminumerical Algorithms, 3rd ed., ser. The Art of Computer
Programming. Reading, Massachusetts, USA: Addison-Wesley, 1997.
[42] A. Sch¨onhage and V. Strassen, “Schnelle multiplikation großer zahlen,”

Computing, vol. 7, no. 3-4, pp. 281–292, 1971.

[43] J. W. Bos, C. Costello, H. Hisil, and K. Lauter, “Fast cryptography in
genus 2,” in EUROCRYPT 2013, ser. LNCS, T. Johansson and P. Q.
Nguyen, Eds., vol. 7881. Springer, May 2013, pp. 194–210.

[44] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) protocol
version 1.3,” January 2015, Internet-Draft -04. [Online]. Available:
https://tools.ietf.org/html/draft-ietf-tls-tls13-04

[45] K. G. Paterson, T. Ristenpart, and T. Shrimpton, “Tag size does matter:
Attacks and proofs for the TLS record protocol,” in ASIACRYPT 2011,
ser. LNCS, D. H. Lee and X. Wang, Eds., vol. 7073. Springer, Dec.
2011, pp. 372–389.

[46] M. Bellare and P. Rogaway, “Entity authentication and key distribution,”
in CRYPTO’93, ser. LNCS, D. R. Stinson, Ed., vol. 773. Springer, Aug.
1993, pp. 232–249.

[47] F. Bergsma, B. Dowling, F. Kohlar, J. Schwenk, and D. Stebila, “Multi-
ciphersuite security of the Secure Shell (SSH) protocol,” in ACM CCS
14, G.-J. Ahn, M. Yung, and N. Li, Eds. ACM Press, Nov. 2014, pp.
369–381.

[48] H. Krawczyk, K. G. Paterson, and H. Wee, “On the security of the TLS
protocol: A systematic analysis,” in CRYPTO 2013, Part I, ser. LNCS,
R. Canetti and J. A. Garay, Eds., vol. 8042. Springer, Aug. 2013, pp.
429–448.

[49] F. Song, “A note on quantum security for post-quantum cryptography,”
in PQCrypto 2014, ser. LNCS, M. Mosca, Ed., vol. 8772. Springer,
2014, pp. 246–265.

[50] M. Mosca, D. Stebila, and B. Ustaoglu, “Quantum key distribution in
the classical authenticated key exchange framework,” in PQCrypto 2013,
ser. LNCS, P. Gaborit, Ed., vol. 7932. Springer, 2013, pp. 136–154.

[51] V. Gupta, D. Stebila, S. Fung, S. C. Shantz, N. Gura, and H. Eberle,
“Speeding up secure web transactions using elliptic curve cryptography,”
in NDSS 2004. The Internet Society, Feb. 2004.

[52] L. K. Grover, “A framework for fast quantum mechanical algorithms,”

in 30th ACM STOC. ACM Press, May 1998, pp. 53–62.

[53] National Institute of Standards and Technology. (1999, July) Recom-
mended elliptic curves for Federal government use. [Online]. Available:
http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf

APPENDIX

A. Sage commands for parameter estimation

See Figure 5.

• KeyGen()

B. Additional cryptographic deﬁnitions
Deﬁnition 7 (Digital signature scheme). A digital signature
scheme Σ is a typle of algorithms:
$→ (sk, pk): A probabilistic key generation
that generates a secret signing key sk and public veriﬁ-
cation key pk.
$→ σ: A probabilistic signing algorithm that
takes as input a signing key sk and a message m ∈ {0, 1}∗,
and outputs a signature σ.
• Ver(pk, m, σ) → {0, 1}: A deterministic veriﬁcation
algorithm that takes as input a veriﬁcation key pk, message
m, and alleged signature σ, and outputs 0 or 1.
For an adversary A, we deﬁne its advantage in the existential

• Sign(sk, m)

unforgeability under chosen message attack experiment as

(cid:3)

Adv

euf-cma
Σ

(A) = Pr

∗
Σ.Ver(pk, m

∗

, σ

) = 1 :
$← Σ.KeyGen() ;
$← AΣ.Sign(sk,·)(pk)
)

(cid:4)

(sk, pk)
∗

∗
(m

, σ

with the restriction that A never queries Σ.Sign(sk,·) on input
∗.
m
Our deﬁnition of a pseudorandom function and a stateful
length-hiding authenticated encryption scheme follows that of
[48, full version, p. 43–45].
Deﬁnition 8 (Pseudorandom function). A pseudorandom func-
tion F with key space {0, 1}λ1 and input space {0, 1}∗ is
a deterministic algorithm. On input a key k ∈ {0, 1}λ1 and
an input string x ∈ {0, 1}∗, the algorithm outputs a value
F(k, x) ∈ {0, 1}λ2.
For a stateful adversary A, we deﬁne the PRF distinguishing
(cid:3)
(cid:3)
b
k0 ← F(k, x) ; k1
$← {0, 1} ; b

(cid:4)
$← {0, 1}λ2 ;
(cid:3) $← AF(k,·)(kb)

advantage for F as
F (A) = Pr

$← {0, 1}λ1 ; x

$← AF(k,·)() ;

= b : k

Adv

prf

b

.

• Gen()

with the restriction that A never queries F(k,·) on input x.
Deﬁnition 9 (Stateful length-hiding authenticated encryption).
A stateful length-hiding authenticated encryption scheme Π is
a tuple of algorithms:
$→ K: A probabilistic key generation algorithm
that chooses a key K at random from the keyspace K and
outputs it.
• Init() → (stE, stD): A deterministic initialization algo-
rithm that outputs initial encryption and decryption states
stE and stD.
$→ (c, st
(cid:3)
E): A probabilistic encryp-
tion algorithm that takes as input a key K, length (cid:4) ∈ N,

• Enc(K, (cid:4), ad, m, stE)

associated data ad ∈ {0, 1}∗, message m ∈ {0, 1}∗, and
encryption state stE, and outputs a ciphertext c ∈ {0, 1}∗
or error symbol ⊥ and an updated encryption state st
(cid:3)
E,
where |c| = (cid:4) if c (cid:16)= ⊥.
• Dec(K, ad, C, stD) → (m
(cid:3)
(cid:3)
D): A deterministic decryp-
, st
tion algorithm that takes as input a key K, associated data
ad, ciphertext c, and decryption state stD, and outputs a
(cid:3) ∈ {0, 1}∗ or error symbol ⊥ and an updated
message m
decryption state st

(cid:3)
D.

see Jager et al. [12] or Krawczyk et al. [48].

Correctness is deﬁned in the natural way and is omitted;
For a stateful adversary A, we deﬁne the advantage
Π (A) = Pr
Π (A) is

Π (A) = 1
Adv
the experiment deﬁned in Figure 6.

where Exp

(cid:3)

(cid:4)

Exp

slhae

slhae

slhae

C. Proof of Theorem 1 (DDH-like security)
Proof. The proof closely follows Peikert’s proof of IND-CPA
security of the related KEM [20, Lemma 4.1]. It proceeds by
a sequence of games which are shown in Fig. 7. Let Si be the
event that the adversary guesses the bit b
Game 0. This is the original game, where the messages are
generated honestly as in Fig. 2. We want to bound Pr(S0).
Note that in Game 0, the R-LWE pairs are: (a, b) (with secret
(cid:3)
s); and (a, b

) and (b, v) (both with secret s

∗ in Game i.

(cid:3)). Hence,

ddh(cid:4)

n,q,χ(A) = | Pr(S0) − 1/2| .

Adv

(cid:3)).

Game 1. In this game, Alice’s ephemeral public key is
generated uniformly at random, rather than being generated as
a R-LWE sample from distribution χ and public parameter a.
(cid:3)
Note that in Game 1, the R-LWE pairs are: (a, b
) and (b, v)
(both with secret s
Difference between Game 0 and Game 1. In Game 0, (a, b)
is a sample from Oχ,s. In Game 1, (a, b) is a sample from
U (R2
q). Under the decision ring learning with errors assumption
(Deﬁnition 1), these two distributions are indistinguishable.
More explicitly, let B1 be the algorithm shown in Fig. 7 that
takes as input a pair (a, b). When (a, b) is a sample from Oχ,s
$← χ, then the output of B1 is distributed exactly as in
where s
Game 0. When (a, b) is a sample from U (R2
q), then the output
of B1 is distributed exactly as in Game 1. Thus, if A can
distinguish Game 0 from Game 1, then A ◦ B1 can distinguish
samples from Oχ,s from samples from U(R2

|Pr(S0) − Pr(S1)| ≤ Adv

q). Thus,
n,q,χ(A ◦ B1) .

drlwe

Game 2. In this game, the shared secret key k is generated
uniformly at random, rather than being generated via a
combination of Alice and Bob’s ephemeral keys. Note that in
Game 2, there are no R-LWE pairs.
(cid:3)
Difference between Game 1 and Game 2. In Game 1, (a, b
)
(cid:3)
(cid:3)
and (b
, v) are two samples from Oχ,s(cid:2). In Game 2, (a, b
)
, v) are two samples from U (R2
(cid:3)
q). Under the decision
and (b

567567

load("https://bitbucket.org/malb/lwe-estimator/raw/1a8a81acd218e387a680496a7011c39a459aaccb/estimator.py")
n, alpha, q = 1024, alphaf(8,2ˆ32-1), 2ˆ32-1
set_verbose(1)
_ = estimate_lwe(n, alpha, q, skip=["arora-gb"])

Fig. 5. Sage source code listing for calculating attack runtime for our parameter choices

TLS-RLWE-SIG-AENC. Then, for the reduction algorithm B2
described in the proof of the lemma,
TLS-RLWE-SIG-AENC(A) ≤ (nPnS)2
2(cid:4)rand

+ nPAdv

euf-cma
SIG

acce-so-auth

(BA

2 ) .

Adv

Proof. The proof proceeds via a sequence of games. Since
we have altered the TLS protocol so that the server signs the
the whole transcript, our proof is simpler than the signed-DH
TLS proof of Jager et al. [12] or Krawczyk et al. [48]. In
particular, our proof follows closely the proof of signed-DH
in the Secure Shell (SSH) protocol of Bergsma et al. [47], in
which the server signs the whole handshake transcript.

Let breakδ be the event that occurs when a client session

accepts maliciously in Game δ in the sense of Deﬁnition 5.
Game 0 [original experiment]. This game equals the ACCE
security experiment described in Section V-C. Thus,
TLS-RLWE-SIG-AENC(A) = Pr(break0) .

acce-so-auth

Adv

Game 1 [exclude colliding nonces]. In this game, we add an
abort rule for non-unique nonces rC or rS. Speciﬁcally, the
challenger collects a list of all random nonces sampled by the
challenger for client or server sessions during the simulation.
If one nonce appears on the list twice, the simulator aborts
the simulation. This is a transition based on a failure event.
There are at most nPnS sampled random nonces, each taken
uniformly at random from {0, 1}(cid:4)rand. Thus,

Pr(break0) ≤ Pr(break1) +

(nPnS)2
2(cid:4)rand

.

Game 2 [signature forgery]. In this game, we exclude
signature forgeries. Technically, we abort the simulation the
ﬁrst time some session πs∗
i∗ accepts after receiving a signature
that was not the output of a session with a matching session
identiﬁer and the signing peer’s long-term public key was
uncorrupted at the time πs∗
i∗ accepted; denote this as event
abort2. We excluded nonce collisions in the previous game, so
in this game all values signed by honest parties are different.
We show that the abort event is related to a signature forgery.
To demonstrate the signature forgery, we construct an
algorithm BA
2 which simulates the TLS protocol execution
as in Game 1. B2 interacts with A. B2 receives a public key
∗ from an euf-cma signature challenger for SIG and guesses
pk
∗’s
a party j
public key and B2 uses the signing oracle from the euf-cma
signature challenger for SIG to generate all signatures for j1.
Under the assumption that the abort event abort2 occurs, with
probability 1/nP, session πs∗
i∗ aborted after receiving a forged
∗. Moreover, the adversary did not issue a
signature for party j
) query. Thus, B2 can perfectly simulate Game 1:
Corrupt(j
in particular, B2 can answer any Corrupt queries for all parties

∗. In its simulation of Game 1, B2 uses pk

∗ as j

∗

Π (A)

E, st0

D) ← Π.Init()

Expslhae
1: K $← Π.Gen()
2: (st0
3: i ← 0; j ← 0; phase ← 0
4: b $← {0, 1}
5: b(cid:2) $← AEnc,Dec()
6: if b(cid:2) = b then return 1
7: else return 0

Enc((cid:3), ad, m0, m1)
1: i ← i + 1
E) $← Π.Enc(K, (cid:3), ad, m0, stE)
2: (C 0, st0
E) $← Π.Enc(K, (cid:3), ad, m1, stE)
3: (C 1, st1
4: if C 0 = ⊥ or C 1 = ⊥ then return ⊥
5: Ci ← C b, adi ← ad, stE ← stb
6: return Ci

E

Dec(ad, c)
1: if b = 0 then return ⊥
2: j ← j + 1
3: (m(cid:2), stD) ← Π.Dec(K, ad, C, stD)
4: if j > i or C (cid:10)= Cj or ad (cid:10)= adj then phase ← 1
5: if phase = 1 then return m
6: return ⊥

Fig. 6. Security experiment for stateful length-hiding authenticated encryption
of scheme Π.

(cid:3)
), (b, v)). When (a, b

ring learning with errors assumption (Deﬁnition 1), these two
distributions are indistinguishable.
More explicitly, let B2 be the algorithm shown in Fig. 7 that
(cid:3)
) and (b, v)
takes as input two pairs ((a, b
(cid:3) $← χ, then the output of B2
are samples from Oχ,s(cid:2) where s
(cid:3)
is distributed exactly as in Game 1. When (a, b
) and (b, v)
q), then the output of B2 is distributed
are samples from U (R2
exactly as in Game 2. Thus, if A can distinguish Game 1 from
Game 2, then A ◦ B2 can distinguish samples from Oχ,s from
samples from U (R2

q). Thus,

|Pr(S1) − Pr(S2)| ≤ Adv

drlwe

n,q,χ(A ◦ B2) .

∗ and thereby distinguish between k and k

Analysis of Game 2. In Game 2, the adversary is asked to
(cid:3). Since k
guess b
is computed as k ← (cid:5)v(cid:6)
2q,2 where v is chosen uniformly at
$← dbl(v), we have from Lemma 1 that
random from Rq and v
k is distributed uniformly on {0, 1}n, even given c = (cid:9)v(cid:10)
2q,2.
(cid:3) is chosen uniformly at random from {0, 1}n. Note
As well, k
(cid:3) are independent of the values a, b, b
that k and k
, c provided
to the adversary. Thus, the adversary has no information about
∗, and hence Pr(S2) = 1/2.
b
Combining the above equations yields the result.

(cid:3)

D. Proof of Theorem 2 (ACCE security)
Lemma 3 (Server-to-client authentication). Let A denote
the server-only authentication of
an adversary against

568568

Game 0.
1: a $← U(Rq)
2: s, e $← χ
3: b ← as + e
4: s(cid:2), e(cid:2) $← χ
5: b(cid:2) ← as(cid:2) + e(cid:2)
6: e(cid:2)(cid:2) $← χ
7: v ← bs(cid:2) + e(cid:2)(cid:2)
8: v $← dbl(v)
9: c ← (cid:5)v(cid:6)2q,2
10: k ← (cid:7)v(cid:8)2q,2
11: k(cid:2) $← U ({0, 1}n)
12: b∗ $← U ({0, 1})
13: if b∗ = 0 then

14: else

return
(a, b, b(cid:2), c, k(cid:2))

Game 1.
1: a $← U (Rq)
2: b $← U (Rq)
3: s(cid:2), e(cid:2) $← χ
4: b(cid:2) ← as(cid:2) + e(cid:2)
5: e(cid:2)(cid:2) $← χ
6: v ← bs(cid:2) + e(cid:2)(cid:2)
7: v $← dbl(v)
8: c ← (cid:5)v(cid:6)2q,2
9: k ← (cid:7)v(cid:8)2q,2
10: k(cid:2) $← U ({0, 1}n)
11: b∗ $← ({0, 1})
12: if b∗ = 0 then

13: else

return (a, b, b(cid:2), c, k)

return (a, b, b(cid:2), c, k)

Game 2.
1: a $← U (Rq)
2: b $← U (Rq)
3: b(cid:2) $← U (Rq)
4: v $← U (Rq)
5: v $← dbl(v)
6: c ← (cid:5)v(cid:6)2q,2
7: k ← (cid:7)v(cid:8)2q,2
8: k(cid:2) $← U ({0, 1}n)
9: b∗ $← U ({0, 1}
10: if b∗ = 0 then

return (a, b, b(cid:2), c, k)

11: else

B2((a, b(cid:2)), (b, v))
1: v $← dbl(v)
2: c ← (cid:5)v(cid:6)2q,2
3: k ← (cid:7)v(cid:8)2q,2
4: k(cid:2) $← U ({0, 1}n)
5: b∗ $← U ({0, 1})
6: if b∗ = 0 then

return (a, b, b(cid:2), c, k)

7: else

return
(a, b, b(cid:2), c, k(cid:2))

B1(a, b)
1: s(cid:2), e(cid:2) $← χ
2: b(cid:2) ← as(cid:2) + e(cid:2)
3: e(cid:2)(cid:2) $← χ
4: v ← bs(cid:2) + e(cid:2)(cid:2)
5: v $← dbl(v)
6: c ← (cid:5)v(cid:6)2q,2
7: k ← (cid:7)v(cid:8)2q,2
8: k(cid:2) $← U ({0, 1}n)
9: b∗ $← U ({0, 1})
10: if b∗ = 0 then

return (a, b, b(cid:2), c, k)

11: else

return
(a, b, b(cid:2), c, k(cid:2))

return
(a, b, b(cid:2), c, k(cid:2))
Fig. 7. Sequence of games and reductions B1 and B2 for proof of Theorem 1.

return
(a, b, b(cid:2), c, k(cid:2))

∗

) is not asked.

∗, and Corrupt(j

∗ without knowing the signing key corresponding

i∗ on the handshake transcript of πs∗

other than j
to pk
Since we have excluded nonce collisions, the signature
received by πs∗
i∗ was not
∗ that B2 has simulated. This implies
output by any instance of j
that B did not query the signing oracle of its euf-cma signature
challenger for this transcript. This transcript and signature is
thus a valid forgery.
Thus, if B2 guess j
∗ correctly (which happens with prob-
ability 1/nP), then A has helped B2 ﬁnd a valid forgery for
the euf-cma challenger for SIG. Thus,

Pr(abort2) ≤ nPAdv

euf-cma
SIG

(BA

2 ) .

Moreover, games 1 and 2 are indistinguishable as long as

the failure event does not occur, so

|Pr(break1) − Pr(break2)| ≤ Pr(abort2) .

Combining the above equations yields the result.

Game 2 only completes if the abort event abort2 does not
occur. By deﬁnition of the abort event, this means that no
client session accepts without a matching session whenever the
peer’s public key was uncompromised. Thus game 2 cannot
be won: Pr(break2) = 0 .
Lemma 4 (Channel security, server-only auth. mode). Let A
denote an adversary against the channel security (in server-
only authentication mode) of TLS-RLWE-SIG-AENC in the sense
of Deﬁnition 6. Then, for the reduction algorithms B2 described
in the proof of Lemma 3 and D3, . . . ,D6 described in the proof
of this lemma,

Adv

(cid:3)

acce-so-aenc-fs

TLS-RLWE-SIG-AENC(A) ≤ (nPnS)2
2(cid:4)rand
q,n,χ(DA
PRF(DA

+ nPnS

+Adv

Adv

ddh(cid:4)

prf

3 ) + Adv

5 ) + Adv

prf

+ nPAdv
PRF(DA
4 )
AENC(DA
6 )

slhae

(cid:4)

.

euf-cma
SIG

(BA
2 )

where PRF is

the pseudorandom function used in

TLS-RLWE-SIG-AENC.

The adversary’s goal is to compute that random bit πs∗

Proof. The proof again proceeds via a sequence of games, and
follows closely the proofs of signed-DH channel security of
TLS by Jager et al. [12] and of SSH by Bergsma et al. [47].
i∗ .b of a
client session (where the peer’s long-term key was uncorrupted
at the time the client accepted) or the random bit of a server
session (where a matching anonymous client session exists).
Let guessδ be the event that occurs when A answers the
encryption challenge correctly for session π, namely that A
(cid:3) but all freshness
outputs a tuple (i, s, b
conditions in Deﬁnition 6 are satisﬁed.
Game 0 [original experiment]. This game equals the ACCE
security experiment described in Section V-C. Thus,
TLS-RLWE-SIG-AENC(A) = | Pr(guess0) − 1/2| .

) such that π.b = b

acce-so-aenc-fs

Adv

(cid:3)

Game 1 [exclude non-matching sessions]. In this game, we
exclude sessions that have no matching session. Technically,
we abort the simulation in either of the following cases:

1) if the adversary’s chosen session π is a client ses-
sion that accepted without a matching session and no
Corrupt(π.pid) query occurred before π accepted; or

2) if the adversary’s chosen session π is a server session

that accepted without a matching session.

In the ﬁrst case, this directly corresponds to a server imper-
sonation, and thus a break in authentication. The second case
is already excluded by Deﬁnition 6. Thus,

|Pr(guess0) − Pr(guess1)| ≤ Adv

acce-so-auth

TLS-RLWE-SIG-AENC(A) .

∗

Game 2 [guess target session]. In this game, we guess which
session will be the adversary’s target session. Technically, we
$← [nP]× [nS], then continue as in game 1, and at
pick (i
the end abort if the adversary’s chosen session (i, s) (cid:16)= (i
∗
).
Our guess is correct with probability

nPnS . Thus,

, s

, s

∗

∗

)

1

Pr(guess1) = nPnS Pr(guess2) .

569569

There now exists a unique partner session πt∗

j∗ for the guessed
i∗ which can be determined by the simulator by

session πs∗
looking for matching client/server nonces.
Game 3 [replace R-LWE premaster secret]. In this game,
we replace the premaster secret pms in session πs∗
i∗ and its peer
j∗ with a value chosen uniformly at random from {0, 1}n.
πt∗
Any algorithm that can distinguish game 2 from game 3 can
be used to construct an algorithm that can distinguish DH-like
R-LWE tuples with a real shared secret from those with a
random value, in the sense of Deﬁnition 3.

More explicitly, let DA
3 be the following algorithm that
(cid:3)
receives an DDH-like challenge (ˆa, ˆb, ˆb
, ˆc, ˆk) for R-LWE
parameters q, n, χ. D3 executes just as in game 2 and interacts
with A, with the following exceptions.

• The system uses ˆa as the global R-LWE parameter a.
• When the target server session (whichever of πs∗

i∗ and
πt∗
j∗ is the server) is generating its ServerKeyExchange
message, the simulator uses the given ˆb value, rather than
generating b as in Fig. 3.
i∗ and
πt∗
j∗ is the client) is generating its ClientKeyExchange
(cid:3) and ˆc values,
message, the simulator uses the given ˆb
rather than generating b

• When the target client session (whichever of πs∗

(cid:3) and c itself as in Fig. 3.

(cid:3)

), D3 outputs b

• When the target client and server sessions are computing
keys, the simulator uses ˆk as the premaster secret rather
than generating pms itself as in Fig. 3.
When A terminates and outputs (i, s, b
When D3 receives an DDH-like tuple with a real shared
secret, then D3 behaves exactly as in game 2. When D3 receives
an DDH-like tuple with a random shared secret, then D3
behaves exactly as in game 3. Thus, D3 behaves differently
on real versus random tuples exactly with the same probability
that A behaves differently on game 2 versus game 3:
3 ) .

|Pr(guess2) − Pr(guess3)| ≤ Adv

q,n,χ(DA

ddh(cid:4)

(cid:3).

i∗ and its peer πt∗

Game 4 [replace master secret]. In this game, we replace the
master secret ms in session πs∗
j∗ with a value
chosen uniformly at random from {0, 1}(cid:4)ms, rather than being
computed as ms = PRF(pms, label1(cid:19)rC(cid:19)rS), where PRF is
the pseudorandom function used in TLS, label1 is a ﬁxed
string, and rC and rS are the client and server random nonces
from the ClientHello and ServerHello messages.

Due to the substitution in the previous game, the premaster
secret pms input to PRF is chosen uniformly at random from
{0, 1}n. Thus, any algorithm that can distinguish game 3
from game 4 can be used to construct an algorithm that can
distinguish the output of PRF from random, in the sense of
Def. 8. More explicitly, let DA
4 be the following algorithm
that interacts with a prf challenger for PRF as in Deﬁnition 8.
D4 executes just as in game 3 and interacts with A, with the
following exceptions.

• When the target client session is computing keys, rather
than computing ms itself, the simulator outputs the string
label1(cid:19)rC(cid:19)rS to the prf challenger, which proceeds as in

Deﬁnition 8, then activates the simulator with a real-or-
random output K which the simulator uses as ms.

• When the target server session is computing keys, the
simulator uses the same ms as the target client session.
When A terminates and outputs (i, s, b
When D4 receives the real PRF result from the prf challenger,
D4 behaves exactly as in game 3. When D4 receives a random
value from the prf challenger, D4 behaves exactly as in game 4.
Thus, D4 behaves differently on real versus random PRF values
exactly with the same probability that A behaves differently
on game 3 versus game 4:

), D4 outputs b

(cid:3).

(cid:3)

|Pr(guess3) − Pr(guess4)| ≤ Adv

prf

PRF(DA

4 ) .

i∗ and its peer πt∗

Game 5 [replace encryption keys]. In this game, we replace
the encryption keys k in session πs∗
j∗ with a
value chosen uniformly at random from {0, 1}(cid:4)k, rather than
being computed as k = PRF(ms, label2(cid:19)rC(cid:19)rS), where label1
is a ﬁxed string, and rC and rS are the client and server random
nonces from the ClientHello and ServerHello messages.
Due to the substitution in the previous game, the master
secret ms input to PRF is chosen uniformly at random from
{0, 1}(cid:4)ms. Thus, any algorithm that can distinguish game 4
from game 5 can be used to construct an algorithm that can
distinguish the output of PRF from random, in the sense of
Def. 8. This reduction algorithm DA
5 follows in an analogous
way to DA

4 in the previous game, and we ﬁnd:
|Pr(guess4) − Pr(guess5)| ≤ Adv

PRF(DA

5 ) .

prf

More explicitly, let DA

Analysis of game 5. In game 5, the encryption key k of the
target session is information-theoretically independent from the
key exchange messages. Thus, any adversary that can break
the channel security of the target session can be used to break
the underlying stateful length-hiding authenticated encryption
scheme AENC.

, s

6 be the following algorithm that in-
teracts with a slhae challenger for AENC; recalling Deﬁnition 9,
this means that the slhae challenger has chosen a secret key,
and provides DA
6 with oracle access to Enc and Dec oracles
as in Fig. 6. D6 executies just as in game 5 and interacts with
A, with the following exceptions.
• When A makes an Encrypt(i
, (cid:4), ad, m0, m1) query
to D6, D6 makes an Enc((cid:4), ad, m0, m1) query to its slhae
challenger and returns the result to A.
• When A makes a Decrypt(i
, ad, C) query to D6, D6
makes a Dec(ad, C) query to its slhae challenger and
returns the result to A.
When A terminates and outputs (i, s, b
(cid:3). The
i∗ .b in D6 corresponds to the challenge bit b
challenge bit πs∗
in the slhae challenger.
The values generated by D6 are distributed identically as in
game 5. Moreover, A’s guess of b
(cid:3) direcly corresponds to a
(cid:3) in the slhae experiment. Thus,
guess of b
AENC(DA

), D6 outputs b

Pr(guess5) = Adv

6 ) .

slhae

, s

∗

∗

∗

∗

(cid:3)

Combining the above equations yields the result.

570570

