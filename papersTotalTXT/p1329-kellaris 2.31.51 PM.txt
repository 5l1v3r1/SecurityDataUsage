Generic Attacks on Secure Outsourced Databases

∗
Georgios Kellaris
Boston University and

Harvard University

gkellaris@g.harvard.edu

†
George Kollios
Boston University

gkollios@cs.bu.edu

Adam O’Neill

Georgetown University

adam@cs.georgetown.edu

‡

kobbi@seas.harvard.edu

Kobbi Nissim

Ben-Gurion University
and Harvard University

ABSTRACT
Recently, various protocols have been proposed for securely
outsourcing database storage to a third party server, rang-
ing from systems with “full-ﬂedged” security based on strong
cryptographic primitives such as fully homomorphic encryp-
tion or oblivious RAM, to more practical implementations
based on searchable symmetric encryption or even on deter-
ministic and order-preserving encryption. On the ﬂip side,
various attacks have emerged that show that for some of
these protocols conﬁdentiality of the data can be compro-
mised, usually given certain auxiliary information.

We take a step back and identify a need for a formal un-
derstanding of the inherent eﬃciency/privacy trade-oﬀ in
outsourced database systems, independent of the details of
the system. We propose abstract models that capture se-
cure outsourced storage systems in suﬃcient generality, and
identify two basic sources of leakage, namely access pattern
and communication volume. We use our models to distin-
guish certain classes of outsourced database systems that
have been proposed, and deduce that all of them exhibit at
least one of these leakage sources.

We then develop generic reconstruction attacks on any
system supporting range queries where either access pattern
or communication volume is leaked. These attacks are in a
rather weak passive adversarial model, where the untrusted
server knows only the underlying query distribution. In par-
ticular, to perform our attack the server need not have any
prior knowledge about the data, and need not know any of
the issued queries nor their results. Yet, the server can re-
construct the secret attribute of every record in the database
after about N 4 queries, where N is the domain size. We pro-
vide a matching lower bound showing that our attacks are
∗Work supported by NSF Grants no. CNS-1414119 and
†Work partially supported by the NSF CNS-1414119 grant.
‡Work supported by NSF Grant no. NSF CNS-1565387 and

CNS-1565387.

grants from the Sloan Foundation.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978386

essentially optimal. Our reconstruction attacks using com-
munication volume apply even to systems based on homo-
morphic encryption or oblivious RAM in the natural way.

Finally, we provide experimental results demonstrating
the eﬃcacy of our attacks on real datasets with a variety of
diﬀerent features. On all these datasets, after the required
number of queries our attacks successfully recovered the se-
cret attributes of every record in at most a few seconds.
Keywords: Secure outsourced databases, generic attacks

1.

INTRODUCTION

As organizations struggle with the accumulation of large
amounts of data, a popular practice is to outsource them
to third party servers. Because their data may be sensi-
tive (e.g., medical or ﬁnancial), a natural idea is to employ
cryptographic techniques to ensure conﬁdentiality while still
allowing eﬃcient query processing.

Many cryptographic techniques exist that can be applied
to this problem, ranging from solutions based on tools such
as fully homomorphic encryption (FHE) [20, 46] or oblivious
RAM (ORAM) [23, 25] to more practical solutions based
on weaker primitives such as structural encryption [33] or
deterministic and order-preserving encryption [42, 2]. How-
ever, the privacy provided by the resulting secure outsourced
database systems is poorly understood. For example, recent
works focusing on some practical solutions [28, 3, 31, 11, 38],
have shown that conﬁdentiality can be compromised given
auxiliary information on the data.

Here, we take a step back and identify a need for a formal
understanding of the inherent eﬃciency/privacy trade-oﬀ in
outsourced database systems, independent of the details of
the system. In particular, we develop the ﬁrst attack against
systems leaking only communication volume. This attack
applies even to systems based on FHE or ORAM.
1.1 Our Results

Abstract Models. We present abstract models that capture
secure outsourced database systems in suﬃcient generality
to reason about their security in a generic and implemen-
tation independent way. In particular, we consider two ba-
sic sources of leakage for such systems: access pattern and
communication volume. Access pattern refers to the server
learning which “encrypted” records are returned as the re-
sult of a query. On the other hand, communication volume
refers to the server learning how many encrypted records are
returned as a result of a query.

1329A Taxonomy. In order to reason about which protocols
have which leakage channels (and how to design new pro-
tocols without them), it is useful to distinguish some classes
of outsourced database systems.
In particular, we deﬁne
atomic outsourced database systems, where the server stores
a collection of ciphertexts such that each record in the dataset
(or rather the search key for each record) is encrypted as one
of these ciphertexts, but there may be additional cipher-
texts encrypting a dummy record; further, communication
from the server on a query includes some subset of these
ciphertexts. It is useful to also deﬁne static atomic systems,
where the encrypted records are not changed as a result of
a query, and non-storage-inﬂating atomic systems, where
the number of encrypted records is equal to the number
of records in the database. We observe that static atomic
systems that are non-storage-inﬂating must leak the access
pattern, i.e., which of the encrypted records are returned on
a query. This covers most systems based on searchable sym-
metric encryption or on deterministic and order-preserving
encryption [42, 2, 4]. In the more general (not necessarily
atomic) setting, we also deﬁne ﬁxed communication overhead
protocols, where the length of communication sent from the
server as a result of a query is proportional to the number of
records matching the query. Systems simply based on FHE
or ORAM have ﬁxed communication overhead. We observe
that such systems leak the communication volume.

Reconstruction Attacks. We develop reconstruction attacks
on outsourced database systems where either access pattern
or communication volume is leaked, and thus our attacks
apply to most solutions proposed in prior work.
In a re-
construction attack an adversary exploits leakage to recover
the search keys. A successful reconstruction attack should
recover a signiﬁcant fraction of the search keys with good
probability, preferably in polynomial-time and with a poly-
nomial number of queries in the database size. Here we
consider a rather weak adversarial model (hence making our
attacks stronger) in which the untrusted server only knows
the underlying query distribution (i.e., does not have prior
knowledge about the stored data and does not get to di-
rectly learn the issued queries or their results). Thus, unlike
prior work [28, 3, 31, 11, 38] our adversary is passive (does
not choose the queries) and does not get any auxiliary in-
formation about the data. Our attacks speciﬁcally apply
to outsourced database systems for range queries. Further-
more, we will assume queries are uniform. Clearly, these
are limiting assumptions but they are an important natural
basic case to start with; see discussion below.

Attacks using Access Pattern. Our reconstruction attack
using the access pattern proceeds in two phases: ﬁrst, the
adversary identiﬁes a record with the minimal (or maximal)
value. Then, it uses the frequency in which this record is
returned on random queries to determine its index. Finally
it uses statistics on the occurrence of other records with the
minimal record to determine their index. A simple analysis,
based on Chernoﬀ bounds, shows that the adversary can ex-
actly reconstruct the entire index set after observing O(N 4)
queries, where N is the domain size, assuming queries are
uniform. For dense databases ˜O(N 2) queries suﬃce.

Attacks Using Communication Volume. Our reconstruc-
tion attacks using communication volume proceed as follows.

Let n be the number of records in the dataset. The attacker
ﬁrst observes O(N 4) queries and determines for every value
of 0 ≤ i ≤ n the number ui of range queries (out of all possi-
ble queries) which return exactly i records. Next, the adver-
sary derives a polynomial F (x) whose positive integer coef-
ﬁcients are computable from u1, . . . , un. It turns out that if
F (x) uniquely factors into two polynomials d(x), dR(x) then
each of these polynomials can be used to recover the entire
index set. That was true for all datasets in our experiments.

A Matching Lowerbound. We complement our attacks
with a lowerbound showing the existence of datasets that
cannot be distinguished by attackers that observe signiﬁ-
cantly less than N 4 uniformly chosen range queries. This
lowerbound holds both for attacks using access pattern and
for attacks using communication volume.

Experiments. In order to demonstrate our attacks, we have
built the following prototype. The server is instantiated as
a mySQL server, and the users upload their data and query
them through a CryptDB proxy. A packet sniﬀer residing
on the server side monitors the query answers, and executes
our attacks. We attacked several real datasets with diﬀerent
indexed domains, number of records, and record distribu-
tions. The average size of each dataset was a few thousands
of records. After collecting the required number of queries,
our attacks ran in a few seconds for the worst case. Both
attacks (i.e., using the access pattern and using the commu-
nication volume) managed to reconstruct all datasets.

1.2 Discussion

In reality queries are not uniform. However, we believe
that our attacks represent a signiﬁcant weakness that needs
to be addressed, because (1) good systems should provide
protection regardless of query distribution (2) uniform or
almost uniform queries on a small subset of the domain
are realistic, and when that happens our attacks apply, and
(3) other than the assumption on the query distribution, our
attack model is very weak. Our attacks show that secure
outsourced databases should avoid being static non-storage-
inﬂating, as well as with ﬁxed communication overhead.

Open Questions. We leave open the question on which
datasets our reconstruction attack using communication vol-
ume succeeds. Additionally, it’s open to extend our attacks
to other query distributions and also to use only “short”
range queries, as they are typically observed in practice. Fi-
nally, our attacks require N 4 queries in general and an open
question is which privacy guarantees can be made when N is
large. We note that in the case of order-preserving encryp-
tion, security on very large domains was studied by [8], who
showed that OPE hides half of the bits of each plaintext for
a dataset of uniformly chosen points (where the adversary
gets the OPE encryptions of these points).

1.3 Related Work

Work in Cryptographic Community. For an overview of
cryptographic techniques for search on encrypted data, we
recommend the talk of Kamara [32]. Broadly, the tech-
niques include multi-party computation [47, 24], oblivious
RAM [25, 25], searchable symmetric and structural encryp-

1330tion [45, 22, 13, 15, 14, 12, 40, 19, 33], functional encryp-
tion [9, 43], property-preserving encryption [5, 1, 7, 39] and
homomorphic encryption [10, 21]. These techniques provide
diﬀerent levels of security based on their leakage.
In par-
ticular, [32] distinguishes between L1 and L2 leakage where
access pattern corresponds to L2 leakage, but neither one
considers communication volume.
[37] identiﬁes the basic
leakages of schemes that combine searchable encryption and
ORAM. It refers to access pattern leakage as LC3, and com-
munication volume as LC2.

Work in Database Community. In the database commu-
nity, the problem of querying an encrypted database was
introduced by [26]. Depending on the query type, diﬀer-
ent methods have been proposed. In this work, we focus on
range queries over arithmetic valued attributes. Existing so-
lutions for range queries can be divided into three categories;
(i) bucketization techniques that partition the domain space
and group data records before indexing (e.g.
[27, 29, 28]),
(ii) order-preserving encryption schemes that use determin-
istic encryption which ensures that the order of the cypher-
texts is the same as the order of the plaintexts (e.g.
[1, 7,
41]), and (iii) solutions that use specialized data structures
(e.g. [35, 44, 17]). Finally, notable examples of outsourced
database systems that support range queries are CryptDB
[42], Cipherbase [2], and TrustedDB [4].

Attacks. Several works (e.g., [28, 3, 31]) have shown that
all the current methods allowing range queries on encrypted
data can reveal information about the distribution of the
plaintext values on the search domain.
Islam, Kuzu, and
Kantarcioglu [30] studied attacks exploiting access pattern
based on auxiliary information. Liu, Zhu, Wang and Tan [36]
developed such attacks based on the query pattern (i.e., in-
formation about which queries repeat). Recently, attacks on
existing systems have been introduced ([11, 38]), but these
attacks are application dependent as they make assumptions
about the data distribution and exploit weaknesses of spe-
ciﬁc encryption protocols (e.g., OPE). Finally, [16] is the
closest to our work. It is similarly general, assuming only
access pattern is leaked. However, the presented attack
only recovers (partial) order of the records depending on
the retrieved range queries. Applied to our setting where
the queries are uniformly drawn, it can reconstruct the full
order after observing enough answers. Speciﬁcally, the algo-
rithm ﬁrst considers all possible orders of records, and then
prunes some of them by observing answers of queries.

2. THE MODEL

We describe our abstract models of secure outsourced data-
base systems. While the focus of our work is on attacks, our
models are general enough to prove positive results as well.
2.1 Outsourced database systems

We abstract a database as a collection of records associ-

ated with search keys

D = {(r1, sk1), . . . , (rn, skn)}.

We will assume that all records have ﬁxed length κ, and that
search keys are elements of domain X (essentially, the search
keys can be viewed as the database indexing information).

A query is a predicate

q : X → {0, 1}.

Applying a query q to a database D results in all records
whose search keys satisfy q, i.e.,

q(D) = {ri : q(ski) = 1}.

Example 2.1. Throughout this article X will be an or-
dered domain of N ∈ N elements {1, . . . , N}. We will con-
sider the family of interval or range queries

(cid:26) 1 a ≤ c ≤ b

(cid:9)

Q =(cid:8)q[a,b]
Overall, there are(cid:0)N

1≤a≤b≤N

;

q[a,b](c) =

(cid:1) + N queries in Q. Applying q[a,b] on

0 otherwise

a database D results in all records with search keys in the
range [a, b], i.e.,

2

q[a,b](D) = {ri : a ≤ ski ≤ b}.

Let Q be a collection of queries. An outsourced database
system for queries in Q consists of two protocols between a
user U and a server S:
Setup protocol Πsetup: U has as input a database D =
{(r1, sk1), . . . , (rn, skn)}; S has no input. The output
for U is a query key K and the output for S is a data
structure DS.1

Query protocol Πquery: U has as input a query q ∈ Q
and the key K produced in the setup protocol; S has as
input DS produced in the setup protocol. The output
for U is q(D); S has no formal output.

We note that our model is somewhat similar to the notion
of structured encryption due to Chase and Kamara [14], but
is more general and applies more easily to general protocols
for outsourced database systems.

Atomic Systems. We also deﬁne the special case that the
outsourced database system is atomic in the following sense:
1. DS = (DS1,DS2) where DS1 = (c1, . . . , cn(cid:48)} con-
tains encrypted records and DS2 depends solely on
(sk1, . . . , skn) (but not on the content of r1, . . . , rn).
For correctness, DS1 should contain at least one en-
crypted copy of each of the records r1, . . . , rn. It may
also contain additional encryptions of records in the
database or encryptions of dummy records (hence, gen-
erally n(cid:48) ≥ n).

2. The communication sent from S to U consists of ele-
ments of DS1 plus information that depends solely on
DS2 (and hence does not depend on r1, . . . , rn).

Static and Non-Static: For simplicity of exposition, the
above refers more speciﬁcally to the static atomic case: there
are no updates to D beyond initial setup, and, furthermore,
no updates to DS while queries are made. More generally,
we can allow U and S in Πquery to also take as inputs their
current states and output new states. This in particular
allows them to modify the query key K and DS, respectively.
1More formally, both U, S also have as input a security
parameter.

1331Non-Storage-Inﬂating: In the case that n = n(cid:48) above
(and hence the server-side storage contains no additional
encryptions of records in the database or dummy records)
we say the protocol is non-storage inﬂating. We observe that
most of the existing practical systems such as CryptDB and
Cipherbase are non-storage-inﬂating.

Fixed Communication Overhead. In the general (not nec-
essarily atomic) setting we deﬁne another class of outsourced
database systems we call ﬁxed communication overhead. We
say that an outsourced database system for Q has ﬁxed com-
munication overhead if for any database D of size n there are
constants α and β (depending only on the security parameter
and n) such that for any sequence of queries q1, . . . , qk ∈ Q,
after Πsetup is run on D and Πquery is run on qi for each
i = 1 to k, the length of communication from S to U on the
i-th execution of Πquery is α · |qi(D)| + β.2
2.2 Adversarial models
We present generic attacks on the privacy of secure out-
sourced databases by an honest-but-curious S. Intuitively,
we want to guarantee that all S can learn is some well deﬁned
“leakage.” As discussed above, this typically includes the
pattern of accesses to encrypted records in DS1, or the num-
ber of records retrieved by U in every execution of Πquery.
To be more general, we follow a formalization of Chase and
Kamara [14] in the context of “structured encryption.”

For an outsourced database system Π, assume a ﬁxed
database sampling algorithm databaseGen, query sampling
algorithm QueryGen, leakage functions Lsetup,Lquery, and
simulator Sim. Consider the following experiments3:
Real Experiment: Sample D ← databaseGen where D =
{(r1, sk1), . . . , (rn, skn)} and run Πsetup(D,⊥). Then,
repeat the following until S halts: Sample q ← QueryGen
and run Πquery(q,DS). The output of the experi-
ment is the output of S.

Ideal Experiment: Sample D ← databaseGen where D =
{(r1, sk1), . . . , (rn, skn)} and give Lsetup(D) to Sim.
Then, repeat the following until Sim halts: Sample
q ← QueryGen, run Lquery(q, sk1, . . . , skn), and give
the result to Sim. The output of the experiment is the
output of Sim.

Definition 2.2. We say that outsourced database system
Π is (Lsetup,Lquery)-secure if there is a simulator Sim
such that for any databaseGen, QueryGen the output distri-
butions of the above experiments are computationally indis-
tinguishable.

Above Lsetup is called the “setup leakage” and Lquery
is called the “query leakage.” We identify the fundamental
leakage channels of outsourced database systems as special
cases of the query leakage.
Access Pattern Leakage: In the case of Lquery for an
atomic outsourced database system, we deﬁne the special
2The experiment is somewhat informal here with the inputs
of the parties implied. The actual inputs follow the same
format as the security deﬁnitions presented in Section 2.2.
3We leave the search key domain D and collection of queries
Q supported by Π implicit for readability, and assume that
subsequent sampling algorithms output elements from the
right sets.

case Laccess (called “access pattern leakage”) that outputs
a subset of S ⊆ [n(cid:48)] corresponding to indices in DS1 =
(c1, . . . , cn(cid:48) ) encrypting a record matching the query, i.e.,
S contains exactly those indices i ∈ [n(cid:48)] for which ci is an
encryption of some rj such that rj ∈ q(D).
Communication Volume Leakage: In the general (not
necessarily atomic) setting, we also deﬁne the special case
Lcomm (called “communication volume leakage”) that out-
puts |q(D)|. Note that in the case of an atomic outsourced
database system, this corresponds to |S| above.

Leakage of atomic systems and ﬁxed communication
overhead. We observe that static, atomic, and non-storage-
inﬂating outsourced database systems leak the access pat-
tern, i.e., their query leakage includes Laccess. This in-
cludes practical systems based on searchable symmetric en-
cryption or on deterministic and order-preserving encryp-
tion. Similarly, outsourced database protocols with ﬁxed
communication overhead leak the communication volume,
i.e., their query leakage includes Lcomm. This includes “full-
ﬂedged” protocols based on FHE or ORAM in the natural
way.

Remark 2.3. While some speciﬁc implementations of out-
sourced database systems may also leak to S information
about the query q and sk1, . . . , skn, aiming for generality
we ignore this additional leakage in our attacks.
2.3 Reconstruction attacks

We will be mostly interested in reconstruction attacks [18]
blatant non-privacy) on outsourced database sys-
(a.k.a.
tems. In a reconstruction attack, an adversary exploits leak-
age to recover the search keys. As it is possible to encrypt
the database records with a semantically secure encryption
scheme, a reconstruction attack results in the maximum in-
formation an attacker could learn about the database. The
existence of a reconstruction attack hence demonstrates a
complete failure of the outsourced database system to keep
the dataset private beyond what is achieved by storing the
encrypted records with cleartext indexing information.4 Our
goal will be to demonstrate the existence of reconstruction
attacks with a weak adversary: passive, with no prior knowl-
edge about the dataset, and with no ability to decipher the
queries issued by U.
a guess { ˆsk1, . . . , ˆskn}.

Namely, consider the ideal experiment where Sim outputs

Definition 2.4. Outsourced database system Π is said
to be (α, β)-reconstructible w.r.t. databaseGen, QueryGen,
Lsetup, Lquery if Sim’s output { ˆsk1, . . . , ˆskn} satisﬁes
[|{sk1, . . . , skn} ∆ { ˆsk1, . . . , ˆskn}| ≤ αn] ≥ 1 − β,

Pr
Sim

where ∆ denotes symmetric set diﬀerence. If α = 0 and β
is inverse polynomial, we say that Π is fully reconstructible
(w.r.t. databaseGen, QueryGen, Lsetup, Lquery) .

Remark 2.5. When our attack algorithms succeed they
produce two candidate search key sets one of which is exactly
{sk1, . . . , skn} and the other is its reﬂection over the domain
[1, . . . , N ], i.e., {N − sk1, . . . , N − skn}.
4We note, however, that the existence of a reconstruction
attack does not always preclude hiding the queries.

1332Note that the above models the scenario that the adver-
sary possibly knows the distributions of either the data or
the queries (or both), but does not directly learn the issued
queries or their results. Thus, we consider a relatively weak
adversarial model for reconstruction attacks.
In fact, our
main reconstruction attacks only use adversarial knowledge
of the distribution of queries and the data can be arbitrary.
In contrast to previous attacks on speciﬁc systems [30, 36,
11, 38], our goal is to capture the fundamental leakage rather
than the weaknesses of a speciﬁc implementation, database,
or cryptographic tool.

To summarize, we consider a passive attacker that does
not bring her previous domain knowledge (e.g., no assump-
tions on the data distribution), cannot aﬀect the dataset
(e.g., by injecting records), and does not directly query the
database. We assume that the adversary knows the domain
size, the total number of records, and that the output of
QueryGen is uniform. Finally, the adversary can only ob-
serve the encrypted answers of queries.

In the sequel, we devise reconstruction attacks on out-
sourced database systems for range queries. We ﬁrst con-
sider the leaked access pattern model (Section 3), and then
the leaked communication volume model (Section 4).
3. ATTACK USING THE ACCESS PATTERN
We present an attack using access pattern leakage, i.e., as-
suming the query leakage Lquery includes Laccess. Such
leakage is typical for current systems based on deterministic
primitives such as order-preserving encryption, or on sym-
metric searchable encryption.

Attack Overview. Assume that the database consists of n
records and sk1, . . . , skn are their (unknown) search keys
(i.e., positions in the domain X = {1, . . . , N}). Let i1, . . . , in
be the actual order of sk1, . . . , skn. We assume for sim-
plicity that there is at most one record per position, but
the attack trivially extends to the general case. The algo-
rithm initially determines its guess for the order of the sets
of records, ˆi1, . . . ,ˆin. This could be done using the method
of [16], but we give a simpler and more eﬃcient method us-
ing our assumption on the query distribution. Namely, the
algorithm ﬁrst samples enough queries so that all subsets
of indices that can match a query are returned with high
probability. It determines ˆi1 by searching the query results
for the largest proper subset of the set of all indices, taking
ˆi1 to be the symmetric diﬀerence of the two. Given ˆi1, it
determines ˆi2 by searching the query results for the smallest
proper superset of ˆi1. In general, given ˆi1, . . . ,ˆij−1, the al-
gorithm determines ˆij by searching the query results for the
smallest proper superset of ˆi1, . . . ,ˆij−1.

If we have at least one record per a domain position (i.e.,
no empty domain positions), then, recovering the order suf-
ﬁces for the reconstruction attack. Otherwise, we have to
determine the position of each record in the domain, in order
to identify which positions are empty. Towards this, after
determining the order, the attack determines its guess for
the exact positions of the records, ˆsk1, . . . , ˆskn by exploit-
ing the uniformity of the QueryGen. Speciﬁcally, it utilizes
the number of queries that include only the records at po-
sitions ski1
ski2 , . . . , skij , which is unique for each domain
position.
Interestingly, this phase of the attack does not
use the order of the records beyond the ﬁrst record, but we
include order recovery because it suﬃces in the case that

the records are dense in the domain. The pseudocode and
detailed description of the attack are in Appendix B.

Next, we show the correctness of the attack and bounds on
the number of required queries p1 for recovering the order,
and p2 for recovering the positions.

Main Result. To showcase the attack, we prove the follow-
ing theorem.

Theorem 3.1. Let Π be an outsourced database system
for range queries with access pattern leakage. Then, Π is
fully reconstructible wrt. databaseGen, QueryGen, Lsetup,
and Laccess, where the output of QueryGen is uniform, and
databaseGen and Lsetup are arbitrary. The reconstruction
algorithm requires O(N 4 log N ) queries.

We note that if the records are dense in the domain, re-
covering only the order suﬃces for a reconstruction attack,
in which case we require only O(N 2 log N ) queries. This is
why we include full order recovery in the attack.

Proof. The theorem follows via Claims 3.2 and 3.3.

Claim 3.2. Let p1 = O(N 2 log N ). Then, an execution
of GetOrderO (see Appendix B) returns the correct output
(up to reﬂection) with inverse polynomial probability.

Proof. The claim follows by the coupon collector’s prob-

lem.

Claim 3.3. Let p2 = O(N 4 log N ). Then, assuming i1 is
correctly recovered (up to reﬂection), an execution of GetDistO
(see Appendix B) returns the correct output (up to reﬂection)
with inverse polynomial probability.

Proof. See Appendix C.

A Matching Lowerbound. To conclude this section, we
show the optimality of our attack in terms of the number of
queries that need to be observed.

Theorem 3.4. Assume uniform output of QueryGen. There

exists a distribution databaseGen such that no outsourced
database system for range queries that leaks the access pat-
tern is fully reconstructable w.r.t. databaseGen, QueryGen,
Lsetup, Laccess, with O(N 4) queries, where Lsetup is
arbitrary.

Proof. The proof derives directly from Claim D.1 in the

Appendix D

4. ATTACK USING THE COMMUNICATION

VOLUME

Access pattern attacks can be avoided using cryptographic
tools such as Oblivious RAM and Fully Homomorphic En-
cryption, and it is tempting conclude that such measures
suﬃce to prevent reconstruction attacks against outsourced
database systems. However, here we show that such an
attack assuming that the query leakage Lquery includes
Lcomm.

Attack Overview. Let n be the total number of records.
We label them according to their order in the domain as

1333Figure 1: Dataset example

record 1, 2, . . . , n, and their positions as 1 ≤ sk1 ≤ sk2 ≤
··· ≤ skn ≤ N . Deﬁne

 sk1

di =

i = 0
ski+1 − ski
1 ≤ i ≤ n − 1
N − skn + 1 i = n

(Equivalently, extend the range to also include the points
0 and N + 1 and assume two additional “fake” records on
these locations, i.e., sk0 = 0 and skn+1 = N + 1 and deﬁne
di = ski+1−ski). Figure 1 shows an example for N = 8 and
n = 4 where dots represent the domain positions, and each
box represents a record. The positions of the records are
sk1 = 2, sk2 = 4, sk3 = 7, and sk4 = 8, and we compute
d0 = sk1 = 2, d1 = sk2 − sk1 = 2, d2 = sk3 − sk2 = 3,
d3 = sk4 − sk3 = 1, and d4 = 8 − sk4 + 1 = 1.
queries q[a,b] where 1 ≤ a ≤ b ≤ N . We ﬁrst determine the
number of distinct queries that return 0 < i ≤ n records:

(cid:1) + N = N (N + 1)/2 distinct interval

There are exactly(cid:0)N

2

number of distinct queries (out of(cid:0)N
number of distinct queries (out of(cid:0)N

that return i records.

2

(cid:1) + N )
(cid:1) + N )

Similarly, let

ui =

ˆu0 =

that return no records.

2

Then, we can express u1, . . . , un and ˆu0 in terms of the

values di. Speciﬁcally,

d0 · dn = un.

queries (q[1,N ] and q[2,N ]) out of the(cid:0)N

2

(cid:1) + N would include

For example, if d0 = 2 and dn = 1 as in Figure 1, then two

these two (and hence all) records. Similarly, we get
d0 · dn−1 + d1 · dn = un−1
d0 · dn−2 + d1 · dn−1 + d2 · dn = un−2

d0 · d1 + d1 · d2 + ··· + dn−1 · dn = u1.

...

m(cid:88)

The number of queries ˆu0 that return no records is a special
case, and we add the equation
1 + . . . + d2

n = 2 · ˆu0 + N + 1.

d2
0 + d2

By setting u0 = 2 · ˆu0 + N + 1, we get the following system
of n + 1 quadratic equations over the non-negative integers:

di · dn−(m−i) = un−m for m ∈ [0, n].

(1)

i=0

We now show how to solve this system of quadratic equa-

tions. Consider the polynomial

d(x) = d0 + d1x + d2x2 + ··· + dnxn

and its “mirror” polynomial

dR(x) = dn + dn−1x + dn−2x2 + ··· + d0xn,

and deﬁne

F (x) = d(x) · dR(x).

A crucial observation is that the coeﬃcients of F (x) are
u0, . . . , un:
F (x) = unx2n + un−1x2n−1 +··· + u0xn +··· + un−1x + un.
I.e., we can construct F (x) by determining the values ui
based on the query answers volume, and, furthermore, fac-
toring F (x) into two polynomials with non-negative integer
coeﬃcients ˆd(x) and its “mirror” ˆdR(x) provides a solution
to the system 1.

If F (x) uniquely factors into two polynomials with non-
negative integer coeﬃcients then these would be d(x) and
dR(x) and hence u0, . . . , un suﬃce for exact reconstruction.
In practice, one can use algorithms for factoring polynomials
with integer coeﬃcients, e.g., the LLL algorithm [34].
Figure 2 depicts the resulting reconstruction algorithm.
Initially, RO constructs the vector u (RO:line 1) by execut-
ing ConstructUO. The latter retrieves p (the value of p is
discussed later) uniformly drawn queries from the oracle O
(ConstructUO:lines 1-2). O essentially draws a random query
q, and returns the size of the answer (i.e., the communication
volume leakage). Next, ConstructUO determines the number
of distinct queries that returned a speciﬁc number of records,
and returns the result (ConstructUO: lines 3-4). Then, RO
recovers the di’s (RO:line 2) by executing FactorFO using u.
FactorFO initially sets the u0 value (FactorFO:line 1), and
deﬁnes the polynomial F (x) by using as coeﬃcients the val-
ues of u (FactorFO:line 2). Then, it runs any state-of-the-art
polynomial factorization algorithm and stores the factors of
F (x) in a list (FactorFO:line 3). It picks an arbitrary factor
from the list as a factor of d(x), and removes it from the list
along with its mirror (FactorFO:lines 5-7). Finally, it checks
that the resulting polynomial d(x) has non-negative coef-
ﬁcients and if so returns these coeﬃcients (FactorFO:lines
8-10).5 Finally, RO uses the di’s to determine the positions
of the records in the domain (RO:lines 3-6) (recall that each
di represents the distance of record i from record i + 1).

Main Result. The attack described above provides full re-
construction when F (x) uniquely factors into irreducible
d(x), dR(x) over the integers.
In case the factorization of
F (x) results in more than 2 irreducible factors, there may
be more than two candidate solutions for the database, and
the algorithm picks an arbitrary solution.

Remark 4.1. We give an example where a dataset is not
uniquely reconstructed. Let N = 11 and consider a dataset
with sk1 = 1, sk2 = 6. This corresponds to d(x) = 1 +
5x + 6x2 (and dR(x) = 6 + 6x + x2). We get that F (x) =
d(x)·dR(x) = 6+35x+62x2 +35x3 +6x4. Over the integers,
F (x) factors as (1 + 2x)(2 + x)(1 + 3x)(3 + x). Our attack
algorithm may hence choose to recover d(x) = (1 + 2x)(3 +
x) = 3+7x+2x2 (and dR(x) = (2+x)(1+3x)) which results
in sk1 = 3, sk2 = 10. Note that this is not a reﬂection of
the true dataset.

We note here that our experiments indicate that for real
life databases the factorization is likely to result in two irre-
ducible factors d(x) and dR(x). Indeed, this was the case for
all 6,786 datasets used in our evaluation (Section 5.2 below).
5As described, FactorFO ﬁnds one solution to F (x) = d(x) ·
dR(x), it can be modiﬁed to ﬁnd all such solutions.

1234d1=2d2=3d3=1d0=2d4=11N1334/* Recover distances and actual values */

Algorithm RO:
/* Construct c */
1. u ← ConstructUO
2. ˆd ← FactorFO(u)
3. ˆsk1 ← r[0]
4. For j = 2 to n do:
5.
6. Return ( ˆsk1, . . . , ˆskn)
Oracle O:
1. q ←$ QueryGen
2. C ← Lcomm(q, sk1, . . . , skn)
3. Return C

ˆskj ← ˆskj−1 + ˆd[j − 1]

Algorithm ConstructUO():
1. For k = 1 to p do:
Uk ←$ O
2.
u[Uk] ← u[Uk] + 1
3.
4. Return u · N (N +1)

2·p1

+u[1]xn+1 + u[0]xn + u[1]xn−1 + . . . + u[n]

Algorithm FactorFO(u):
1. Set u[0] = 2u[0] + N + 1
2. Set F (x) = u[n]x2n + u[n − 1]x2n−1 + . . . +
3. f actors ← Factorize(F (x))
4. Set d(x) = 1 (and dR(x) = 1)
5. For each pair of factors e and reciprocal(e) in f actors do
Set d(x) = d(x) · e (and dR(x) = dR(x)· reciprocal(e))
6.
7.
remove e and reciprocal(e) from f actors
8.
9.
10. Otherwise fail

Set ˆd as the coeﬃcients of d(x) and return ˆd

If coeﬃcients of d(x) are non-negative

Figure 2: Reconstruction algorithm using the communication volume leakage

5. EXPERIMENTS

We implemented and ran our attacks on an Intel Core
i7 2.5GHz machine with 16GB of RAM, running MacOS
10.11. Using Parallels, we created two virtual machines run-
ning Ubuntu Linux 14.04, each with 2 CPU cores and 4GB
of memory. Speciﬁcally, our implementation is depicted in
Figure 3. We installed mySQL server on the ﬁrst virtual ma-
chine (hereafter called server), and CryptDB on the second
(called proxy). We implemented our client in Java and ran
it on the proxy. The client stores a database to the server
through the CryptDB proxy, and chooses an attribute to
be indexed. The CryptDB proxy encrypts each record be-
fore storing it to the mySQL server. Then, the user asks
range queries on the indexed attribute, the CryptDB proxy
retrieves the required encrypted records from the server, de-
crypts them, and sends them back to the user. Addition-
ally, we implemented a packet sniﬀer in Java, residing on
the server side, which can only observe the network packets
from the server to the proxy.
In our implementation, the
sniﬀer ignores the communication between the user and the
proxy. Finally, the packet sniﬀer performs our attacks.

Remark 4.2. Factorization might be slow for large num-
ber of records. Thus, we design a simple algorithm (see Ap-
pendix E) that checks the possible combinations of di’s in
order to determine the correct values, and is faster than fac-
torization in practice.

To complete the attack description, we now give a bound
on the number of queries needed for estimating the coeﬃ-
cients u[i].

Claim 4.3. Let p = O(N 4 log N ). Then, an execution of
ConstructUO returns the correct ui’s with inverse polynomial
probability.

Proof. Let E[u[i]] be the expected value of u[i]. We draw

p queries to ensure that every u[i] lies in the range

u[i] ∈ [E[u[i]] − , E[u[i]] + ]

with probability at least 1 − δ, for  = O(1/N 2) and in-
verse polynomial δ. Using the same steps as in the proof of
Theorem 3.1, we get that p is O(N 4 log N ).

Claim 4.4. An execution of FactorFO on the correct in-
puts un, un−1, . . . , u0 returns the correct outputs d0, d1, . . . , dn
when d(x) is irreducible.

Proof. Our algorithm factorizes F (x) (line 3). If d(x)
is irreducible over the integers, then the factoring of F (x)
results in d(x) and dR(x).

Next, we show the optimality of our attack in the number

Figure 3: System implementation

of required queries.

Lemma 4.5. Let the output of QueryGen be uniform. Then
there is a distribution databaseGen such that no outsourced
database system for range queries that leaks the communi-
databaseGen,
cation volume is fully reconstructable wrt.
QueryGen, Lsetup, and Lcomm with O(N 4) queries, where
Lsetup is arbitrary.

Proof. The proof derives directly from Claim D.1 in the

Appendix D.

In order to evaluate the performance of each attack, we en-
crypted and uploaded to the server the 518 datasets from the
Texas Hospital Inpatient Discharge Public Use Data File of
2008 (PUDF)6, and the 1049 datasets from the 2009 HCUP
Nationwide Inpatient Sample (NIS)7. Each dataset repre-
sents a speciﬁc hospital, and consists of records of hospital-
ized patients. We indexed diﬀerent attributes deriving in
6http://archive.ahrq.gov/
7http://www.hcup-us.ahrq.gov/

ServerCryptDBProxyUsersEncrypted QueryEncrypted RecordsQueryRecordsAdversaryClient SidePacketSniffer1335total 6,786 databases and ran the attacks on all of them.
Both the attack using the access pattern and the attack
using the communication volume successfully reconstructed
all the search keys in every case. Table 1 summarizes the
characteristics of each data source. The datasets and the
domains are similar to those in [38].

capture the packets of all the users simultaneously. Finally,
we note that our attack always succeeds to fully reconstruct
the records on the domain.
5.1 Access Pattern Attack

Table 1: Dataset Characteristics

Source Datasets
PUDF

518

NIS

1049

Index

Mortality Risk

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

N
4
6
16
22
365
18
107
125
365

n(max)
55,605
20,454
34,162
50,626
55,605
16,954
106,252
121,663
121,663

Source
PUDF

NIS

n(avg)

5,612
1,170
4,130
5,300
5,612
1,195
6,240
7,435
7,435

Table 2: Access pattern attack
Positions

Ordering

Index

Mortality Risk

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

1 ms
1 ms
1 ms
1 ms
43 ms
1 ms
1 ms
1 ms
5 ms

1 ms
1 ms
1 ms
1 ms
4.2 sec
1 ms

202 ms
356 ms
3.4 sec

Dense

85%
34.1%
67.3%
32.2%

0%

31.5%

0%
0%
0%

The average number of patients per hospital from the

PUDF source is 5,612 (with minimum 1 and maximum 55,605).
Each patient record has size 1,486 bytes (1,547 bytes after
the encryption). We used 3 attributes of the PUDF datasets
as the ordered domains for the range queries, namely Mor-
tality Risk, Age, and Length of Stay. The Mortality Risk
has 4 possible values; minor, moderate, major, and extreme.
The Age domain consists of 22 diﬀerent values, each repre-
senting an age interval, instead of a speciﬁc age in years.
We further divided it into two domains; one for patients
under the age of 18, and one for adult patients, assuming
that some users are only interested in these attribute val-
ues. The Length of Stay represents the number of days a
patient was hospitalized. Each domain position is a speciﬁc
number of days, ranging from 0 to 364. Finally, the combi-
nations of search keys and datasets produce essentially 2,590
diﬀerent databases because for each domain, the records are
distributed diﬀerently.

The NIS datasets incorporate similar information, with
average number of patients equal to 7,435 (minimum 1 and
maximum 121,663) and record size of 621 bytes (684 bytes
after the encryption). However, there is no Mortality Risk
information. As such, we indexed only the Age and Length
of Stay attributes. Again, we divided the Age domain into
two additional domains for minor and adult patients respec-
tively. NIS has more detailed age information, i.e., each
domain position represents a speciﬁc age in years, ranging
from 0 to 124. The eﬀective databases are in this case 4,196.
We ﬁrst gathered enough queries in order to be able to
run each attack. The user issues uniformly drawn range
queries to the proxy. For each query, the proxy retrieves
the encrypted records, decrypts them, and sends them back
to the user. Then, the client asks the next query. The
running time depends on the number of required queries
(or in the domain size), the number of records to decrypt,
the network speed, and the number of users. For all the
datasets, this time varied from some seconds to one month
(for retrieving N 4 queries on the large domain with size N =
365). For datasets where the required time for executing
enough queries exceeded an hour, we simulated the query
retrieval. However, we expect that in real life scenarios the
system is running for more than several months, and more
importantly, that several users are issuing queries. In case
of 100 users issuing queries, the packet sniﬀer would gather
enough information 100 times faster (e.g., only a few hours
for the largest domain size of N = 365), because it can

In this section we evaluate the running time of the attack
using the access pattern leakage. Table 2 summarizes our re-
sults. Column Ordering represents the average required time
to recover the order of the records using N 2 log N queries,
while Positions depicts the average time needed to recover
the positions, requiring N 4 queries.
If a dataset is dense,
then the attack terminates when it determines the order.
The last column represents the percentage of datasets where
the targeted domain is dense.

The attack on the PUDF datasets for the Mortality Risk
attribute ran in milliseconds. Moreover, 85% of the datasets
have dense domain, rendering the ordering suﬃcient to re-
construct the data, and thus, it only requires to observe
N 2 log N queries. For domains extracted from the age at-
tribute, the running time is similar to that for the Mortality
Risk. Recall that the age attribute has a small domain,
since the original data report the age range for each patient.
67.3% of datasets that include only the records of adults
have dense domains, where for records with age < 18 there
are 34.1% dense domains, and for all the ages, we have 32.2%
dense domains. For the Length of Stay attribute, recovering
the order took 43 milliseconds, and the positions 4.2 seconds.
In this case, we only encountered sparse domains.

Regarding the NIS datasets, the attack recovered the or-
der in a few milliseconds for all the attributes. However, it
was enough for reconstruction only for 31.2% datasets with
domain representing ages younger than 18. All the other
domains were sparse, and as such, the attack completed in
0.2 to 3.4 seconds.
5.2 Communication Volume Attack

Next, we evaluate our attack utilizing only the communi-
cation volume leakage. In order to determine the values of u
array, i.e., the coeﬃcients of the F (x) polynomial, we have
retrieved N 4 queries.

After building vector u, we performed the attack using
the factorization algorithm and the brute-force version (Ap-
pendix E). Due to the large amount of records, the fac-
torization algorithm needed several hours to terminate. As
such, we only ran it on datasets with fewer than 150 records.
However, our brute-force attack terminated in seconds for
the complete datasets in all cases. More importantly, the
attack successfully reconstructed all the data, i.e., d(x) was
irreducible in all 6,786 databases.

Table 3 summarizes the attack performance. Column Fac-
tor shows the average running time of the attack using the
factorization algorithm, after constructing the u vector with

1336the coeﬃcients of F (x). Column BruteForce depicts the av-
erage running time of our brute-force algorithm, showing
that in practice it terminates within a few milliseconds.

Source
PUDF

Index

NIS

Table 3: Communication volume attack

Factor (n ≤ 150) BruteForce

Mortality Risk

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

Age (<18)
Age (≥ 18)
Age (All)

Length of Stay

11 min
39 sec
4.3 min
4.1 min
3 min
3.3 min
6 min
5.1 min
4 min

22 ms
1.7 ms
15 ms
390 ms
22 ms
2 ms
34 ms
189 ms
44 ms

The reconstruction attack using the factorization method
runs in a few minutes for almost all the settings, since it was
executed only for datasets with fewer than 150 records. For
larger datasets we observed that it required hours and hence,
we omit the results. On the other hand, the running time of
the brute force attack is much shorter (runs in milliseconds),
and depends mainly on the number of records. Interestingly,
the attack is slower when reconstructing the age attribute
than the Length of Stay, although the number of records are
almost the same. This is due to the fact that the distribu-
tion of the Length of Stay values is highly skewed, with the
majority of records concentrated in the ﬁrst few domain po-
sitions. As such, the brute force algorithm can prune values
of di’s that correspond to more uniformly distributed data
early on, resulting in fewer candidate datasets to check.

6. REFERENCES
[1] R. Agrawal, J. Kiernan, R. Srikant, and Y. Xu. Order
preserving encryption for numeric data. In SIGMOD,
2004.

[2] A. Arasu, S. Blanas, K. Eguro, R. Kaushik,

D. Kossmann, R. Ramamurthy, and R. Venkatesan.
Orthogonal security with cipherbase. In CIDR, 2013.

[3] A. Arasu, K. Eguro, R. Kaushik, and R. Ramamurthy.

Querying encrypted data (tutorial). In ICDE, 2013.

[4] S. Bajaj and R. Sion. Trusteddb: A trusted

hardware-based database with privacy and data
conﬁdentiality. TKDE, 26(3):752–765, 2014.

[5] M. Bellare, A. Boldyreva, and A. O’Neill.

Deterministic and eﬃciently searchable encryption. In
CRYPTO, 2007.

[6] E. R. Berlekamp. Factoring polynomials over ﬁnite

ﬁelds. Bell System Technical Journal, 46(8):1853–1859,
1967.

[7] A. Boldyreva, N. Chenette, Y. Lee, and A. O’Neill.

Order-preserving symmetric encryption. In
EUROCRYPT, 2009.

[8] A. Boldyreva, N. Chenette, and A. O’Neill.

Order-preserving encryption revisited: Improved
security analysis and alternative solutions. In
CRYPTO, 2011.

[9] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and

G. Persiano. Public key encryption with keyword
search. In EUROCRYPT, 2004.

[10] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating 2-dnf

formulas on ciphertexts. In TCC, 2005.

[11] D. Cash, P. Grubbs, J. Perry, and T. Ristenpart.

Leakage-abuse attacks against searchable encryption.

In CCS, 2015.

[12] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M.-C.

Ro¸su, and M. Steiner. Highly-scalable searchable
symmetric encryption with support for boolean
queries. In CRYPTO. 2013.

[13] Y.-C. Chang and M. Mitzenmacher. Privacy

preserving keyword searches on remote encrypted
data. In ACNS, 2005.

[14] M. Chase and S. Kamara. Structured encryption and

controlled disclosure. In ASIACRYPT, 2010.

[15] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky.

Searchable symmetric encryption: improved
deﬁnitions and eﬃcient constructions. In CCS, 2006.

[16] J. L. Dautrich Jr and C. V. Ravishankar.

Compromising privacy in precise query protocols. In
EDBT, 2013.

[17] I. Demertzis, S. Papadopoulos, O. Papapetrou,
A. Deligiannakis, and M. Garofalakis. Practical
private range search revisited. In SIGMOD, 2016.

[18] I. Dinur and K. Nissim. Revealing information while

preserving privacy. In PODS, 2003.

[19] B. A. Fisch, B. Vo, F. Krell, A. Kumarasubramanian,

V. Kolesnikov, T. Malkin, and S. M. Bellovin.
Malicious-client security in blind seer: a scalable
private dbms. In S&P, pages 395–410, 2015.
[20] C. Gentry. Computing arbitrary functions of
encrypted data. CACM, 53(3):97–105, 2010.

[21] C. Gentry et al. Fully homomorphic encryption using

ideal lattices. In STOC, 2009.

[22] E.-J. Goh et al. Secure indexes. IACR Cryptology

ePrint Archive, 2003:216, 2003.

[23] O. Goldreich. Towards a theory of software protection

and simulation by oblivious rams. In STOC, 1987.
[24] O. Goldreich, S. Micali, and A. Wigderson. How to

play any mental game. In STOC, 1987.

[25] O. Goldreich and R. Ostrovsky. Software protection

and simulation on oblivious rams. JACM,
43(3):431–473, 1996.

[26] H. Hacig¨um¨u¸s, B. Iyer, C. Li, and S. Mehrotra.

Executing sql over encrypted data in the
database-service-provider model. In SIGMOD, 2002.

[27] H. Hacig¨um¨u¸s, B. Iyer, C. Li, and S. Mehrotra.

Executing sql over encrypted data in the
database-service-provider model. In SIGMOD, 2002.

[28] B. Hore, S. Mehrotra, M. Canim, and

M. Kantarcioglu. Secure multidimensional range
queries over outsourced data. VLDBJ, 21(3):333–358,
2012.

[29] B. Hore, S. Mehrotra, and G. Tsudik. A

privacy-preserving index for range queries. In VLDB,
2004.

[30] M. S. Islam, M. Kuzu, and M. Kantarcioglu. Access

pattern disclosure on searchable encryption:
Ramiﬁcation, attack and mitigation. In NDSS, 2012.

[31] M. S. Islam, M. Kuzu, and M. Kantarcioglu. Inference
attack against encrypted range queries on outsourced
databases. In CODASPY, 2014.

[32] S. Kamara. How to search on encrypted data, 2015.

https:
//cs.brown.edu/˜seny/slides/encryptedsearch-full.pdf.

[33] S. Kamara and T. Moataz. Sql on

1337structurally-encrypted databases. Cryptology ePrint
Archive, Report 2016/453, 2016.
http://eprint.iacr.org/.

[34] A. K. Lenstra, H. W. Lenstra, and L. Lov´asz.

Factoring polynomials with rational coeﬃcients.
Mathematische Annalen, 261(4):515–534, 1982.

[35] J. Li and E. R. Omiecinski. Eﬃciency and security
trade-oﬀ in supporting range queries on encrypted
databases. pages 69–83, 2005.

[36] C. Liu, L. Zhu, M. Wang, and Y.-a. Tan. Search

pattern leakage in searchable encryption: Attacks and
new construction. Information Sciences, 265:176–188,
2014.

[37] M. Naveed. The fallacy of composition of oblivious
ram and searchable encryption. Cryptology ePrint
Archive, Report 2015/668, 2015.

[38] M. Naveed, S. Kamara, and C. V. Wright. Inference
attacks on property-preserving encrypted databases.
In CCS, 2015.

[39] O. Pandey and Y. Rouselakis. Property preserving

symmetric encryption. In EUROCRYPT, 2012.

[40] V. Pappas, F. Krell, B. Vo, V. Kolesnikov, T. Malkin,
S. G. Choi, W. George, A. Keromytis, and S. Bellovin.
Blind seer: A scalable private dbms. In S&P, 2014.

[41] R. A. Popa, F. H. Li, and N. Zeldovich. An

ideal-security protocol for order-preserving encoding.
In SP, pages 463–477, 2013.

[42] R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and

H. Balakrishnan. Cryptdb: Protecting conﬁdentiality
with encrypted query processing. In SOSP, 2011.

[43] E. Shen, E. Shi, and B. Waters. Predicate privacy in

encryption systems. In TCC, 2009.

[44] E. Shi, J. Bethencourt, T.-H. Chan, D. Song, and

A. Perrig. Multi-dimensional range query over
encrypted data. In SP, 2007.

[45] D. X. Song, D. Wagner, and A. Perrig. Practical
techniques for searches on encrypted data. In SP,
2000.

[46] V. Vaikuntanathan. Computing blindfolded: New
developments in fully homomorphic encryption. In
FOCS, 2011.

[47] A. C. Yao. Protocols for secure computations. In

SFCS, 1982.

APPENDIX
A. TAIL INEQUALITIES

We use the following tail inequalities:

Theorem A.1

(Chernoff-Hoeffding Inequalities).

Let X1, . . . , Xn be independent random variables such that
Xi ∈ [0, 1] and E[Xi] = µ and denote S = 1
i=1 Xi.
Then, for all  > 0:

n

(cid:80)n

Hoeﬀding:

Chernoﬀ:

−2n2

−2n2

Pr[S > µ + ] ≤ e
Pr[S < µ − ] ≤ e
Pr[S > (1 + )µ] ≤ e
Pr[S < (1 − )µ] ≤ e

and

.

−nµ2/3 and
−nµ2/2.

(2)

(3)

Theorem A.2

tingale satisfying |Xi − Xi−1| < ∆. Then, for all  > 0

(Azuma’s inequality). Let Xi be a mar-

Pr[|Xi − X0| ≥ ] ≤ 2e

−2/2i∆2

.

We get the following corollary:

√

Pr[|Xi − X0| ≥

i · t · ∆] ≤ 2e

−t2/2.

(4)
B. PSEUDOCODE OF THE ATTACK USING

THE ACCESS PATTERN

Figure 4 shows the pseudocode of the attack.

It ini-
tially retrieves the order of the records by calling GetOrderO
(RO:line 1). GetOrderO retrieves p1 uniformly drawn queries
(GetOrderO:line 1) from the oracle O. The latter essentially
chooses a random range query q, determines the access pat-
tern leakage, and returns it. Then, GetOrderO searches the
query results for the largest proper subset L(cid:48) of the set of
all indices [n] (GetOrderO:line 2), and sets ˆi1 as the symmet-
ric diﬀerence of the two (GetOrderO:line 3). Next, for each
subsequent record j (GetOrderO:line 4), it determines ˆij by
searching the query results for the smallest proper superset
of ˆi1, . . . ,ˆij−1 GetOrderO:lines 5-6. Finally, it returns the
ordering (GetOrderO:line 7).
After recovering the order, RO checks if there are no
empty positions in the domain (RO:line 2), and if this is
the case, the attack terminates by returning the ordering
(RO:line 3). Otherwise, it continues to recover the positions
(RO:line 5). GetDistO initially retrieves p2 uniformly drawn
queries (GetDistO:line 1) from the oracle O. Then, it de-
termines the ﬁrst value of A, i.e., number of queries that
include the record that is ﬁrst in the ordering (GetDistO:line
2), and value B, which represents the number of queries that
include the record that is last in the ordering (GetDistO:line
3). Then, it sets as ordering either the original one or its
reverse so that the record which is closest to a domain end-
point comes ﬁrst8, and it ﬁnds the position ˆskˆi1
of the ﬁrst
record up to reﬂection (GetDistO:lines 4-8). Next, it re-
samples the queries and for every other record in the or-
dering (GetDistO:line 9), it discovers the value A, i.e., the
number of queries that include the previously determined
records and the next one in the ordering (GetDistO:line 11).
Finally, after computing all the positions by utilizing A
(GetDistO:line 12), the algorithm returns the positions of
the records (GetDistO:line 13).
C. PROOF OF CLAIM 3.3

Proof. For i ≤ j ≤ m, let Ej be the event that skij is
correctly recovered; here we allow the position to be recov-
ered up to reﬂection, as long as the reﬂection is consistent
for all the positions. Our goal is to set p2 to ensure that all of
the Ej’s occur together with inverse polynomial probability.
Using a union bound

(cid:32)

Pr(cid:2) Ej | E1

(cid:3)(cid:33)(cid:33)

(5)

(cid:32) n(cid:88)

j=2

(cid:35)

(cid:34) n(cid:94)

j=1

Pr

Ej

≥ Pr [ E1 ] ·

1 −

For 1 ≤ j ≤ n, let Aj be the random variable counting
the number of queries that match the records with posi-
tions ski1 , ski2 , . . . , skij . We ﬁrst show how to set p2 to
8This procedure ensures that we receive the correct posi-
tions, up to reﬂection, when all the records lie on either the
ﬁrst or second half of the domain.

1338If n = N

Algorithm RO:
1. (ˆi1, . . . ,ˆin) ←$ GetOrderO
2.
3.
4. Else
5.
6.

Return (ˆi1, . . . ,ˆiN )

( ˆskˆi1
Return ( ˆskˆi1

, . . . , ˆskˆin

) ←$ GetDistO(ˆi1, . . . ,ˆin)
, . . . , ˆskˆin

)

Oracle O:
1. q ←$ QueryGen
2. L ← Laccess(q, sk1, . . . , skn)
3. Return L

Algorithm GetOrderO:
1. For k = 1 to p1 do: Lk ←$ O
2. Let L(cid:48) be a query result s.t. |L(cid:48)| = n − 1
3, ˆi1 ← [n] \ L(cid:48)
4. For j = 2 to n do:
5.
6.
7. Return (ˆi1, . . . ,ˆin)

Let L(cid:48) be a query result of the form L(cid:48) = {ˆi1, . . . ,ˆij−1} ∪ {k}
ˆij ← k

← minz, z ∈ argminz |A/p2 − 2z(N − z + 1)/(N (N + 1))|

If A < B

ˆskˆi1
Reverse({ˆi1, . . . ,ˆin})
ˆskˆi1

Algorithm GetDistO(ˆi1, . . . ,ˆin)
1. For k = 1 to p2 do: Lk ←$ O
/* Determine ﬁrst point */
2. Let A = {Lk | 1 ≤ k ≤ p2,ˆi1 ∈ Lk}
3. Let B = {Lk | 1 ≤ k ≤ p2,ˆin ∈ Lk}
4.
5.
6. Else
7.
8.
9. For k = 1 to p2 do: Lk ←$ O
10. For j = 2 to n do:
11. Let A = {Lk | 1 ≤ k ≤ p2, {ˆi1 ∪ ˆi2 ∪ . . . ∪ ˆij} ⊆ Lk}
12.
13. Return ( ˆskˆi1

← argminz |A/p2 − 2 ˆskˆi1

/* Two possible z values above, take the smallest */

/* Determine j-th point using ﬁrst point */

, . . . , ˆskˆin

ˆskˆij

)

(N − z + 1)/(N (N + 1))|

← minz, z ∈ argminz |B/p2 − 2z(N − z + 1)/(N (N + 1))|

Figure 4: Reconstruction algorithm using the access pattern leakage.

ensure that E1 happens with inverse polynomial probabil-
ity. According to GetDistO:line 3, to ensure E1 happens with
inverse polynomial probability, we want that
± 

(cid:20) 2ski1 (N − ski1 + 1)

A1/p2 ∈

(cid:21)

N (N + 1)

with probability at least 1 − δ, for  = O(1/N 2) and inverse
polynomial δ. To see that  = O(1/N 2) suﬃces, note that
we want that for choices of z diﬀerent from ski1 and its

reﬂection(cid:12)(cid:12)(cid:12)(cid:12) 2ski1 (N − ski1 + 1)

N (N + 1)

− 2z(N − z + 1)

N (N + 1)

(cid:12)(cid:12)(cid:12)(cid:12)

is Ω(1/N 2). But this follows from the fact that the absolute
value of the numerator is at least 1 in this case. Now using
Hoeﬀding’s inequality (Equation 2 in Section A) we have
that

Pr

A1/p2 >

2ski1 (N − ski1 + 1)

N (N + 1)

+ 

≤ e

−2p22

(cid:20)

(cid:21)

and similarly for the lower bound. Above, to calculate the
expectation of A1, we use the fact that the probability that
a uniformly random query q[a,b] satisﬁes ski1 ∈ [a, b] is

2ski1 (N − ski1 + 1)

N (N + 1)

since for any a ≤ ski1 there are N − ski1 + 1 values for b
satisfying ski1 ∈ [a, b]. Thus, we set e−2p22
= δ. Solving
for p2 we get p2 = O(N 4 log N ) as desired.

A similar argument shows that when p2 = O(N 4 log N )
the probability of Ej given E1 is inverse polynomial prob-
ability for each j ≥ 2, using the fact that the subsequent
p2 queries after the ﬁrst p2 queries are independently sam-
pled (GetDistO:line 4).
In the argument we can take say
δ = O(1/N 2) (instead of simply any inverse polynomial as
above) so that the overall expression in Equation 5 is inverse
polynomial as desired.

D. OPTIMALITY OF OUR ATTACKS

Here we show that our reconstruction attacks are nearly
optimal. Namely, we show that for an outsourced database
system for range queries, there are two datasets D1 and
D2 such that an adversary needs to observe Ω(N 4) uni-
formly chosen queries to distinguish whether D1 or D2 is
outsourced. This bound holds for either Laccess or Lcomm
leakage functions.

Theorem D.1. Let the output of QueryGen be uniform.
Then there is a distribution databaseGen such that no out-
sourced database system for range queries is fully recon-
structable w.r.t. databaseGen, QueryGen, Lsetup, Lquery
with O(N 4) queries, where Lsetup is arbitrary and Lquery
includes Lcomm.

4

(N +1)2

Proof. Let D1 and D2 be equal-sized databases where in
D1 all records lie at position sk1 = (N + 1)/2, and in D2 all
records lie at sk2 = sk1 + 1 (assume N is odd). With both
databases, an adversary can observe see exactly two types of
queries: those that return all records record and those that
return no records.
The total number of diﬀerent queries is T = N (N + 1)/2.
In case of D1 the number of non-empty queries is T1 =
and hence the probability of observing a non-empty
query is p = T1/T . In case of D2 the probability to receive
a non-empty query p + δ where δ = 1/T .
Consider a setting where the database is chosen to be
D1 or D2 with equal probability before the adversary be-
gin observing queries. The adversary’s a priory belief is
that the database is D1 or D2 with equal probability. Af-
ter observing each query answer, the adversary updates her
belief. Let Pr[D1|a1, a2, . . . , ai] be the posterior probability
the database is D1, and Pr[D2|a1, a2, . . . , ai] be the posterior
probability the database is D2, after observing i queries.

Writing the log-ratio of the posterior probabilities and us-
ing Bayes rule we can describe how the adversary’s conﬁ-

1339/* Recover distances and actual values */

Algorithm RO:
/* Construct u */
1. u ← ConstructUO
2. d ← ConstructDO(u, N U LL, 0)
3. ˆsk1 ← d[0]
4. For j = 2 to n do:
5.
6. Return ( ˆsk1, . . . , ˆskn)
Oracle O:
1. q ←$ QueryGen
2. C ← Lcomm(q, sk1, . . . , skn)
3. Return C

ˆskj ← ˆskj−1 + d[j − 1]

Algorithm ConstructUO():
1. For k = 1 to p do:
Uk ←$ O
2.
u[Uk] ← u[Uk] + 1
3.
4. Return u · N (N +1)

2·p1

For k = 1 to N/2 do

Return d
If m ≤ n/2

If m = n and(cid:80)m

For l = 1 to N − k + 1 do

Algorithm ConstructDO(u, d, m):
1.
i=0 d[i] = N + 1
2.
3.
4.
5.
6.
7.
8.
9.
10. Else
11.
12.

ConstructDO(u, d, m + 1)

d[m] ← k
d[n − m] ← l

If(cid:80)m

If(cid:80)m

ConstructDO(u, d, m + 1)

i=0 (d[i] · d[n − (m − i)]) = u[n − m]

i=0 (d[i] · d[n − (m − i)]) = u[n − m]

Figure 5: Brute-force reconstruction algorithm

dence whether the database is D1 or D2 evolves:

Ci = log

= log

(cid:19)

· Pr[ai|D1]
Pr[ai|D2]

Pr[D2|a1, a2, . . . , ai−1]

(cid:18) Pr[ai|D1]

Pr[D1|a1, a2, . . . , ai]
Pr[D2|a1, a2, . . . , ai]

(cid:18) Pr[D1|a1, a2, . . . , ai−1]
(cid:19)
(cid:16)

Pr[ai|D2]

= Ci−1 + log

= Ci−1 + stepi.

(cid:17)

(cid:17)

(cid:16)

Thus, C0, C1, . . . describes a random walk on the real
line where C0 = 0 and an empty observed query corre-
sponds to a (positive) stepi = − log
and a non-
empty observed query corresponds to a (negative) stepI =
− log
. We analyze this random walk in the case
where the database is D1 to show a lowerbound on the num-
ber of steps needed to reach Ci > C for constant C. (A
similar analysis holds when the database is D2.) We get

1 − δ
1−p

1 + δ
p

− log

 − log
(cid:19)
(cid:19)

δ
p

∈

∈

(cid:16)
(cid:16)

(cid:17)

(cid:17)

1 + δ
p
1 − δ
1−p

(cid:20) δ
(cid:20) −δ

p

− δ2
p2 ,
−

stepi =

(cid:18)

(cid:18)

log

1 +

1 − δ

w.p. p
w.p. 1 − p

(cid:21)

δ
p

δ2

Using

(7)

log

1 − p

(1 − p)2 ,

1 − p
p(1−p) ≤ 16
N 4 . Hence, 0 ≤
we get that 0 ≤ E[stepi] ≤ δ2
N 4 . Note that Ci − E[Ci] is a martingale with
E[Ci] ≤ 16i
C0 = E[Ci] = 0 and ∆ = 8
√
N 2 . Using Equation (4) we
i log N/N 2] ≤ e− log2 N/2. We
get that Pr[|Ci − E[Ci]| > 64
conclude that, except with negligible probability, Ci < C
unless i = ˜Ω(N 4).

(6)

(cid:21)

−δ
1 − p

E. BRUTE-FORCE ALGORITHM UTILIZ-
ING THE COMMUNICATION VOLUME
LEAKAGE

The factorization procedure for our attack using the com-
munication volume leakage may be slow for large datasets.
This is due to the fact that factorizing a polynomial takes
O(n3) time (e.g., Berlekamp algorithm [6]), where n is the
degree of the polynomial, i.e, the number of records in our
setting. As such, we design a brute force algorithm that
checks all the possible combinations of di’s in order to de-
termine the correct values, while pruning values that cannot
be the answer.
Speciﬁcally, algorithm RO in Figure 5 determines all the
di’s, which are used to determine all the ski’s as follows.
Initially, it constructs vector u (RO:line 1), which holds the
ui’s, by executing ConstructUO. After computing u, RO
passes it as argument to ConstructDO (RO:line 2), which de-
termines vector d that holds the di’s. Each time, ConstructDO
computes pairs of feasible values d[m] and d[n− m], and for
each pair, it ﬁnds all the feasible values for d[m + 1] and
d[n− m− 1], and so on (ConstructDO:lines 3-9). Essentially,
the algorithm builds a tree of height n/2, where each path
represents a possible vector d. Then, it checks which of these
paths can be an actual solution (ConstructDO:lines 11-12),
and returns one of them (ConstructDO:lines 1-2). Finally,
RO computes the ˆski’s (RO:lines 3-5), and returns them
(RO:line 6).

m − 1] that satisfy(cid:80)m+1

Although we do not have any formal guarantees about the
running time of the algorithm, it prunes many candidates at
every step, because, for some accepted values of d[m] and
d[n − m], there are no integer values of d[m + 1] and d[n −
i=0 (d[i] · d[n − (m − i)]) = u[n − m].
Our experiments showed that our attack runs in milliseconds
even for domains of size N = 365 and thousands of records.

1340