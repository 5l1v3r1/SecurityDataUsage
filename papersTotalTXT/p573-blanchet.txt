Automatic Veriﬁcation of Protocols

with Lists of Unbounded Length

Bruno Blanchet

INRIA Paris-Rocquencourt, France

Bruno.Blanchet@inria.fr

Miriam Paiola

INRIA Paris-Rocquencourt, France

Miriam.Paiola@inria.fr

ABSTRACT
We present a novel automatic technique for proving secrecy
and authentication properties for security protocols that ma-
nipulate lists of unbounded length, for an unbounded num-
ber of sessions. This result is achieved by extending the Horn
clause approach of the automatic protocol veriﬁer ProVerif.
We extend the Horn clauses to be able to represent lists of
unbounded length. We adapt the resolution algorithm to
handle the new class of Horn clauses, and prove the sound-
ness of this new algorithm. We have implemented our al-
gorithm and successfully tested it on several protocol exam-
ples, including XML protocols coming from web services.

Categories and Subject Descriptors
C.2.2 [Computer-communication networks]: Network
Protocols—Protocol veriﬁcation

Keywords
Security protocols; veriﬁcation;
clauses; resolution.

1.

INTRODUCTION

lists; web services; Horn

Security protocols are protocols that rely on cryptographic
primitives such as encryption and signatures for securing
communication between several parties. They aim at en-
suring security properties such as secrecy or authentication.
However, attacks are often found against protocols that were
thought correct. Furthermore, security ﬂaws cannot be de-
tected by testing since they appear only in the presence of an
attacker. The conﬁdence in these protocols can then be in-
creased by a formal analysis that proves the desired security
properties. To ease formal veriﬁcation, one often uses the
symbolic, so-called Dolev-Yao model [13], which abstracts
from the details of cryptographic primitives and considers
messages as terms. In this work, we also rely on this model.
The formal veriﬁcation of security protocols with ﬁxed-
size data structures has been extensively studied. However,

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516679.

some protocols, for instance XML protocols of web services,
use more complex data structures, such as lists. The veriﬁ-
cation of protocols that manipulate such data structures has
been less studied and presents additional diﬃculties: these
complex data structures add another cause of undecidability.
In this work, we extend the veriﬁer ProVerif [7] to proto-
cols with lists of unbounded length. ProVerif is an automatic
veriﬁer that takes as input a protocol, translates it into a
representation in ﬁrst-order logic clauses, and uses a resolu-
tion algorithm to determine whether a fact is derivable from
the clauses. One can then infer security properties of the
protocol. For instance, ProVerif uses a fact att(M ) to mean
that the attacker may have the message M . If att(s) is not
derivable from the clauses, then s is secret. The main goal
of this approach is to prove security properties of protocols
without bounding the number of sessions of the protocol.

Like other protocol veriﬁers, ProVerif can analyze pro-
tocols with lists if we ﬁx the lengths of the lists a priori.
However, if the protocol is veriﬁed only for some lengths,
attacks may exist for other lengths.
If there is an attack
against a protocol, then there is a bound such that this at-
tack appears with lists shorter than the bound, but this
bound depends on the protocol and is not easy to compute.
So our goal is to extend ProVerif to the veriﬁcation of pro-
tocols with lists of any length without bounding the length
(and still not bounding the number of sessions). To obtain
this result, we extend the language of Horn clauses, intro-
ducing a new kind of clauses, generalized Horn clauses, to
be able to represent lists of any length. We adapt the reso-
lution algorithm to deal with these new clauses, and prove
the soundness of the new algorithm. The obtained algorithm
can prove secrecy and authentication properties. (More pre-
cisely, the authentication property that we consider is non-
injective agreement [17]:
if some participant B terminates
the protocol with some parameters, then A started the pro-
tocol with the same parameters.) This algorithm performs
approximations, so it may fail to prove security properties
that actually hold, and it does not always terminate. This is
unavoidable because the problem of verifying protocols with
an unbounded number of sessions is undecidable. However,
the algorithm works well in practice: we have implemented
it and successfully tested it on several protocol examples (see
Section 6). Applications of our results include in particular
the treatment of XML protocols such as web services, XML
documents being modeled using possibly nested lists. In this
paper, we focus mainly on these protocols. We illustrate
our work on the SOAP extension [9] to XML signatures [4].
XML signatures allow one to sign several parts of an XML

573document, recorded in a SignedInfo element, which can be
modeled as a list of references to the signed parts of the
document. A known attack [18] may occur when the docu-
ment contains several Body elements, and the signed Body
is not the one that is used for subsequent treatments. Our
tool detects this attack, and proves that a corrected version
is secure. Another possible application is the veriﬁcation of
some group protocols that manipulate lists that contain one
element for each group member, with an unbounded number
of group members.
1.1 Related Work

The ﬁrst approach considered for proving protocols with
recursive data structures was interactive theorem proving:
a recursive authentication protocol was studied for an un-
bounded number of participants, using Isabelle/HOL [20],
and using rank functions and PVS [10]. However, this ap-
proach requires considerable human eﬀort.

Truderung [22] showed a decidability result (in NEXP-
TIME) for secrecy in recursive protocols, which include
transformations of lists, for a bounded number of sessions.
This result was extended to a class of recursive protocols
with XOR [16] in 3-NEXPTIME. Chridi et al [11, 12] present
an extension of the constraint-based approach in symbolic
protocol veriﬁcation to handle a class of protocols (Well-
Tagged protocols with Autonomous keys) with unbounded
lists in messages. They prove that the insecurity problem
for Well-Tagged protocols with Autonomous keys is decid-
able for a bounded number of sessions.

Several approaches were considered for verifying XML
protocols [6, 21, 15, 3], by translating them to the input for-
mat of a standard protocol veriﬁer: the tool TulaFale [6] uses
ProVerif as back-end; Kleiner and Roscoe [21, 15] translate
WS-Security protocols to FDR; Backes et al [3] use AVISPA.
All these approaches have little or no support for lists of un-
bounded length. For instance, TulaFale has support for list
membership with unbounded lists, but does not go further.
Recently, Paiola and Blanchet [19] showed that, for a cer-
tain class of Horn clauses, if secrecy is proved by ProVerif
for lists of length one, then secrecy also holds for lists of
unbounded length. Their target applications are group pro-
tocols and XML protocols. However, this work is limited to
secrecy, and the class of protocols that they handle is limited
to protocols that treat all elements of lists uniformly. When
their reduction result does not apply, a diﬀerent approach
is needed. We propose such an approach in this paper. We
provide a practical algorithm that can prove both secrecy
and authentication properties of protocols that manipulate
diﬀerent list elements in diﬀerent ways.
1.2 Outline

The next section recalls the technique used by ProVerif. In
Section 3, we introduce our running example and motivate
the introduction of a new type of clauses, the generalized
Horn clauses, that we will use to model group protocols.
In Section 4, we formally deﬁne generalized Horn clauses,
and their semantics by giving their translation into Horn
clauses. In Section 5, we adapt the resolution algorithm to
generalized Horn clauses and prove its soundness. Section 6
summarizes our experimental results. Because of space con-
straints, the proofs of all our results and additional details
on our algorithm can be found in the long version of the
paper, available at [8], together with our implementation.

2. A REMINDER ON PROVERIF

ProVerif translates the initial protocol into a set of Horn
clauses. The syntax of these clauses is deﬁned in Figure 1.

p ::=

patterns

x, y, z, v, w
a[p1, . . . , pn]
f (p1, . . . , pn)

variable
name
constructor application

F ::= pred (p)
R ::= F1 ∧ ··· ∧ Fn ⇒ F Horn clause

facts

Figure 1: Syntax of Horn clauses

The patterns represent messages that are exchanged be-
tween participants of the protocol. A variable can represent
any pattern. Names represent atomic values, such as keys
and nonces. Each participant can create new names.
In-
stead of creating a fresh name at each run of the protocol,
the created names are considered as functions represented
by the pattern a[p1, . . . , pn]. These functions take as ar-
guments the messages previously received by the principal
that creates the name as well as session identiﬁers, which
are variables that take a diﬀerent value at each run of the
protocol, to distinguish names created in diﬀerent runs. As
shown in, e.g., [7], this representation of names is a sound
approximation. When a name has no arguments, we write
a instead of a[ ]. We use a for a generic name and identiﬁers
in sans serif font (e.g., sk) for ﬁxed names.

The fact att(p) means that the attacker may have the
pattern (message) p. ProVerif models authentication as cor-
respondence assertions, such as “if event e(x) has been exe-
cuted, then event e(cid:48)(x) has been executed”. It uses the fact
m-event(p) to represent that the event p must have been ex-
ecuted, and the fact event(p) to represent that the event p
may have been executed.
A clause F1 ∧ ··· ∧ Fn ⇒ F means that, if all facts Fi
are true, then the conclusion F is also true. We use R for a
clause, H for its hypothesis, and C for its conclusion. The
hypothesis of a clause is considered as a multiset of facts. A
clause with no hypothesis ⇒ F is written simply F .

Cryptographic primitives are represented by functions.
There are two kinds of functions: constructors and destruc-
tors. A constructor f is a function that explicitly appears
in the patterns that represent messages and builds new pat-
terns of the form f (p1, . . . , pn). Destructors manipulate pat-
terns. A destructor g is deﬁned by a set def (g) of rewrite
rules of the form g(p1, . . . , pn) → p where p1, . . . , pn, p are
patterns with only variables and constructors and the vari-
ables of p appear in p1, . . . , pn. Using constructors and
destructors, one can represent data structures and cryp-
tographic operations. For instance, senc(m, k) is the con-
structor that represents the symmetric key encryption of the
message m under the key k. The corresponding destructor
sdec(m(cid:48), k) returns the decryption of m(cid:48) if m(cid:48) is a message
encrypted under k. The rewrite rule that deﬁnes sdec is

sdec(senc(m, k), k) → m.

A protocol is represented by three sets of Horn clauses:
• initial knowledge of the attacker: we have a fact att(p)

for each p initially known by the attacker.

• abilities of the attacker:

att(a[x])

574for each constructor f of arity n:

att(x1) ∧ ··· ∧ att(xn) ⇒ att(f (x1, . . . xn))
for each rule g(p1, . . . , pn) → p in def (g):

for each destructor g,

att(p1) ∧ ··· ∧ att(pn) ⇒ att(p)

The ﬁrst clause represents the ability of the attacker to
create fresh names: all fresh names that the attacker
may create are represented by the names a[x] for any
x. The other clauses mean that if the attacker has
some messages, then he can apply constructors and
destructors to them.

1) ∧ . . . ∧ m-event(p(cid:48)

• the protocol itself: for each message p of the protocol
sent by agent A, we have the clause att(p1) ∧ ··· ∧
att(pn) ∧ m-event(p(cid:48)
n(cid:48) ) ⇒ att(p),
where A receives messages p1, . . . , pn and executes
events p(cid:48)
n(cid:48) before sending message p.
Indeed,
if the attacker has p1, . . . , pn, then he can send them
1, . . . , p(cid:48)
to A and intercept A’s reply p; the events p(cid:48)
n(cid:48)
are executed by A during this operation.

1, . . . , p(cid:48)

Similarly, for each event p executed by A, we have
the clause att(p1) ∧ ··· ∧ att(pn) ∧ m-event(p(cid:48)
1) ∧ . . . ∧
n(cid:48) ) ⇒ event(p), where A receives messages
m-event(p(cid:48)
p1, . . . , pn and executes events p(cid:48)
n(cid:48) before exe-
cuting event p.

1, . . . , p(cid:48)

Let R1 be the set of these clauses. This representation of
protocols by Horn clauses is approximate, mainly because
Horn clauses that represent the protocol can be applied any
number of times instead of only once per session. However,
it is sound: if the attacker knows p after the events p1, . . . , pn
have been executed, then att(p) is derivable from R1 and the
facts m-event(p1), . . . , m-event(pn). In particular, if att(p)
is not derivable from R1 and any facts m-event(p(cid:48)), then
the protocol preserves the secrecy of p. If the event p is ex-
ecuted after the events p1, . . . , pn, then event(p) is derivable
from R1 and the facts m-event(p1), . . . , m-event(pn). (This
is proved by Theorem 1 in [7] when the clauses are generated
from a pi calculus model of the protocol.)

ProVerif determines whether a fact is derivable from the
clauses using resolution with free selection [2]: it combines
pairs of clauses by resolution; the literals upon which we
resolve are chosen by a selection function. Next, we detail
this algorithm.

We say that R1 subsumes R2 when R2 can be obtained
by adding hypotheses to an instance of R1. In this case, all
facts derivable using R2 can also be derived by R1, so R2
can be eliminated. Formally, subsumption is deﬁned by:

Definition 1

(Subsumption). We say that R1 = H1
⇒ C1 subsumes R2 = H2 ⇒ C2, and we write R1 (cid:119) R2, if
and only if there exists a substitution σ such that σC1 = C2
and σH1 ⊆ H2 (multiset inclusion).

When the conclusion of a clause R uniﬁes with a hypoth-
esis of a clause R(cid:48), resolution creates a new clause that cor-
responds to applying R and R(cid:48) one after the other.

Definition 2

(Resolution). Let R and R(cid:48) be two
clauses, R = H ⇒ C and R(cid:48) = H(cid:48) ⇒ C(cid:48). Assume that
there exists F0 ∈ H(cid:48) such that C and F0 are uniﬁable and
σ is their most general uniﬁer.
In this case, we deﬁne
R◦F0 R(cid:48) = σ(H ∪ (H(cid:48) (cid:114){F0})) ⇒ σC(cid:48). The clause R◦F0 R(cid:48)
is the result of resolving R(cid:48) with R upon F0.

satur(R0) =

1. R ← elim(R0).

2. Repeat until a ﬁxpoint is reached

for each R ∈ R such that sel (R) = ∅,

for each R(cid:48) ∈ R, for each F0 ∈ sel (R(cid:48)) such
that R ◦F0 R(cid:48) is deﬁned,

R ← elim({R ◦F0 R(cid:48)} ∪ R).

3. Return {R ∈ R| sel (R) = ∅}.

Figure 2: ProVerif ’s Algorithm

The facts upon which we resolve are selected through a

selection function:

Definition 3

(Selection function). A

selection
function is a function from clauses to sets of facts, such
that sel (H ⇒ C) ⊆ H. If F ∈ sel (R), we say that F is
selected in R. If sel (R) = ∅, we say that no hypothesis is
selected in R, or that the conclusion of R is selected.

The algorithm is correct with any selection function that
never selects facts of the form m-event(p), but the choice
of the selection function can change the behavior of the al-
gorithm. Facts att(x) where x is a variable can be uniﬁed
with all facts att(M ), so we should avoid selecting att(x)
to reduce the number of possible resolution steps. Hence a
good selection function satisﬁes the following formula:



∅

sel (H ⇒ C) =

{F0} where F0 ∈ H,

for all variables x, F0 (cid:54)= att(x), and
for all patterns p, F0 (cid:54)= m-event(p)
if there exists no such F0

The resolution algorithm is shown in Figure 2. It trans-
forms the initial set of clauses into a new one that derives
the same facts. The algorithm satur(R0) has 3 steps:

• The ﬁrst step inserts in R the clauses in R0 after elimi-
nation of subsumed clauses by elim: when R(cid:48) (cid:119) R and
both R and R(cid:48) are in R, R is removed by elim(R).

• The second step is a ﬁxpoint iteration that adds the
clauses created by resolution:
if the conclusion of a
clause R such that sel (R) = ∅ uniﬁes with F0 ∈ sel (R(cid:48)),
then the resolution R◦F0 R(cid:48) is added to R. Then, sub-
sumed clauses are eliminated by elim.

• Finally, the algorithm returns the clauses in R with no

selected hypothesis.

Let Fme be any set of facts of the form m-event(p).
Theorem 1

(Lemma 2 in [7]). Let F be a closed fact
and R0 a set of clauses. F is derivable from R0 ∪ Fme if
and only if it is derivable from satur(R0) ∪ Fme.

To prove that a closed fact att(p) is not derivable from
R0 ∪ Fme, we use the following result, where att(cid:48) is a new
predicate:

Corollary 1. If satur(R1 ∪ {att(p) ⇒ att(cid:48)(p)}) con-
tains no clause of the form H ⇒ att(cid:48)(p(cid:48)), then att(p) is not
derivable from R1 ∪ Fme for any Fme. So, by soundness of
the clauses, the protocol preserves the secrecy of p.

575Indeed, if satur(R1 ∪ {att(p) ⇒ att(cid:48)(p)}) contains no
clause of the form H ⇒ att(cid:48)(p(cid:48)), then att(cid:48)(p) is not derivable
from satur(R1∪{att(p) ⇒ att(cid:48)(p)})∪Fme, so by Theorem 1,
att(cid:48)(p) is not derivable from R1 ∪ {att(p) ⇒ att(cid:48)(p)} ∪ Fme,
so att(p) is not derivable from R1 ∪ Fme. Similarly, we also
have:

Corollary 2

(Corollary 2 in [7]). Suppose that all
clauses of satur(R1) that conclude event(e(p)) for some p
are of the form m-event(e(cid:48)(p(cid:48)))∧ H ⇒ event(e(p(cid:48))) for some
H and p(cid:48). Then, for all Fme, for all p, if event(e(p)) is
derivable from R1 ∪ Fme, then m-event(e(cid:48)(p)) ∈ Fme. So
by soundness of the clauses, the protocol satisﬁes the cor-
respondence “if e(x) has been executed, then e(cid:48)(x) has been
executed”.

3. MOTIVATION

This section motivates this work, explaining the introduc-

tion of a new type of clauses through a running example.
3.1 Running Example

As a running example, we use a version of the SOAP ex-
tension to XML signatures [9]. SOAP envelopes are XML
documents with a mandatory Body containing a request, re-
sponse or a fault message together with an optional Header
element containing application-speciﬁc information about
the message (for example security information). In particu-
lar, the SOAP header can carry digital signature information
within a SOAP envelope, as follows:

<Envelope>
<Header>

<Signature>

<SignedInfo>

<Reference URI=”#theBody”>

<DigestValue> hash of the body </DigestValue>

</Reference>
<Reference URI=”#x1”>

<DigestValue> hash of the content of x1
</DigestValue>

</Reference>
...

</SignedInfo>
<SignatureValue>

signature of SignedInfo with key sk

</SignatureValue>

</Signature>

</Header>
<Body Id=”#theBody”> request </Body>

</Envelope>

The Signature header contains two components. The ﬁrst
component is a SignedInfo element, which is basically a
list of references to the elements of the message that are
signed, designated by their identiﬁer and accompanied by a
DigestValue, a hash of their content. The hash may be com-
puted with the hash function SHA-1. The second component
of the Signature header is the signature of the SignedInfo el-
ement using a secret key sk.

We consider a simple protocol in which a client sends such
a message to a server. The server processes the document
and checks the signature before authorizing the request given
in the Body:
if the SignedInfo contains a Reference to an
element with tag Body, then he will authorize the request.
This protocol should guarantee that the server authorizes
only requests signed by legitimate clients.

This protocol is subject to a known wrapping attack [18]:
an attacker can intercept an envelope and create a new en-
velope wrapping the Body in the Header and adding a new
body with a diﬀerent id and a diﬀerent request. The server
will verify the signature and authorize the fake request made
by the attacker. This attack is possible because the server
does not check that the signed Body is the one he authorizes.
3.2 Need for Generalizing Horn Clauses

In order to model the previous example, we suppose that
the XML parser parses the SOAP envelope as a pair, con-
taining as ﬁrst component a list of triplets (tag, id, corre-
sponding content) and as second component the content of
the mandatory body. The list in the ﬁrst component is help-
ful so that one can retrieve the content of an element from
its id by looking up the list. The content of the Signature
header is modeled as a pair (SignedInfo, SignatureValue);
SignedInfo is a list of pairs containing an id and the hash of
the content corresponding to the id; SignatureValue is the
signature of SignedInfo with a secret key sk. We use such a
simple model for illustrative purposes.

A given XML document can then be represented using
lists of ﬁxed length (and other standard functions). We de-
note by (cid:104)p1, . . . , ph(cid:105) a list of ﬁxed length h; such lists are
modeled as a family of constructors, one for each length.

.
= Signature, cont j

.
= d, tag d

However, the receiver of the SOAP envelope accepts mes-
sages containing any number of headers, and the SignedInfo
element may also contain references to any number of el-
ements in the message. Therefore, we need lists of vari-
able length in order to model the expected message. So
we introduce the construct list(i ≤ M, pi) which stands for
(cid:104)p1, . . . , pM(cid:105), for an unknown M (inspired by [12, 19]).
Thanks to this new construct, we can model the SOAP
envelope from the point of view of the server: (list(i ≤ M,
(tag i, id i, cont i)), r), where tag i, id i, and cont i are variables
representing tags, identiﬁers, and contents respectively and
r is the variable for the request. The server has to check the
signature, that is, he has to verify that the list contains a
tag tag j equal to Signature and that cont j contains a correct
signature. These checks can be represented by the following
.
= (sinfo, sign(sinfo, sk)),
equations: tag j
= list(k ≤ N, (idφ(k), sha1 (cont φ(k)))), where the func-
.
sinfo
tion φ is a mapping from the index k of each element in the
sinfo list to its index φ(k) in the list that represents the
whole message. Furthermore, one of the signed elements
.
= Body. We
must have tag Body, that is, φ(m)
cannot directly replace the variables tag i, id i, and cont i
with their values given by these equations, because in the
list list(i ≤ M, (tag i, id i, cont i)), all elements tag i, id i and
cont i need to have the same form, while the equations give
diﬀerent forms to diﬀerent elements. So we keep the equa-
tions in the clause for future use. The equations allow us to
handle protocols that treat elements of lists non-uniformly.
We can represent that the adversary has a SOAP envelope
by att((list(i ≤ M, (tag i, id i, cont i)), r)). The adversary can
build such a SOAP envelope from its components, so we need
to express that the adversary has (tag i, id i, cont i) for all
i∈[1,M ] att((tag i, id i, cont i))
(i1,...ih)∈I F represents

i ≤ M . We use a conjunction(cid:86)
for this purpose. More generally, (cid:86)
suppose that we resolve R2 =(cid:86)

the conjunction of facts F for all indices (i1, . . . , ih) ∈ I.
After modeling the clauses, we need to perform resolution
on these generalized clauses. Let [1, M ] = {1, . . . , M} and
i∈[1,M ] att(sha1 (cont φ(i))) ⇒

576event(e(r)) with the clause R1 = att(x) ⇒ att(sha1 (x)),
that is, we use R1 to derive one hypothesis of R2, say the
one of index i = k1 ∈ [1, M ]. So we unify att(sha1 (x)) with
.
att(sha1 (cont φ(k1))), yielding the equality x
= cont φ(k1).
The obtained clause would then be:

att(x1) ∧(cid:86)

i∈[1,M ](cid:114){k1} att(sha1 (cont φ(i))) ∧

{x1

= cont φ(k1)} ⇒ event(e(r))
.

att(x1) ∧ att(x2) ∧(cid:86)

The variable x is renamed into x1 to distinguish it from the
variable x in R1. The obtained clause can then again be
resolved with R1 for some i = k2 ∈ [1, M ] (cid:114) {k1}, yielding
i∈[1,M ](cid:114){k1,k2} att(sha1 (cont φ(i))) ∧
= cont φ(k2)} ⇒ event(e(r))
.

.
= cont φ(k1), x2

{x1

which can again be resolved with R1, and so on. Since M
is not bounded, such resolution steps yield an inﬁnite loop.
To avoid this loop, we deﬁne a resolution step that simul-
taneously resolves R with several instances of R(cid:48) for i in
any non-empty subset I ⊆ [1, M ]. We name such a step hy-
perresolution by analogy with the hyperresolution rule that
allows one to resolve one clause with several clauses [14]. To
perform hyperresolution, we ﬁrst transform R1 into a clause
R(cid:48)
1 corresponding to the combination of several instances of
R1, one for each i ∈ I. This step is named immersion and
i∈I att(xi) ⇒ att(sha1 (xi)). We can then
yields R(cid:48)
perform hyperresolution with R2 and obtain:

1 = (cid:86)
i∈I att(xi) ∧(cid:86)
(cid:86)
{(cid:86)

i∈I xi

i∈[1,M ](cid:114)I att(sha1 (cont φ(i))) ∧

= cont φ(i)} ⇒ event(e(r)).
.

When I = [1, M ], the second hypothesis is removed and the
substitution of cont φ(i) for xi is performed for all i, so we
obtain

(cid:86)
i∈[1,M ] att(cont φ(i)) ⇒ event(e(r)).

When I (cid:54)= [1, M ], to have a more symmetric notation and
to simplify the language of sets used in conjunctions, we
introduce a symbol I(cid:48) for [1, M ](cid:114) I, and keep the constraint
that I (cid:93) I(cid:48) = [1, M ]: I and I(cid:48) are disjoint and their union is
[1, M ]. The clause is then denoted by

= [1, M ], (cid:86)

I (cid:93) I

(cid:86)
(cid:48)
i∈I(cid:48) att(sha1 (cont φ(i))) ⇒ event(e(r)).

i∈I att(cont φ(i)) ∧

where I and I(cid:48) represent non-empty subsets of [1, M ].

4. GENERALIZED HORN CLAUSES

This section formally deﬁnes the syntax and semantics of
generalized Horn Clauses, which were motivated informally
in the previous section.
4.1 Syntax

The syntax of these new clauses is deﬁned in Figure 3.
The patterns pG that represent messages are enriched with
several new constructs. The variables may have indices
xι1,...,ιh . The pattern for function application f (pG
1 , . . . , pG
l )
includes not only constructor application but also names
a[pG
l ] where a is a name without index. We consider
l (cid:105) as
tuples (p1, . . . , pG
particular constructors. We suppose that the implementa-
tion of the protocol uses distinct encodings for tuples and for
lists, so that they cannot be confused with each other. The

l ) and lists of ﬁxed length (cid:104)pG

1 , . . . , pG

1 , . . . , pG

ι ::=

i
φ(ι1, . . . , ιh)
pG, p(cid:48)G ::=
xι1,...,ιh
1 , . . . , pG
f (pG
l )
1 , . . . , pG
aM
ι [pG
l ]
list(i ≤ M, pG)
J ::=
I
{()}
J × [1, M ]

C ::=(cid:86)

(i1,...ih)∈J
F G ::= C pred (pG)
E ::= C pG .
= p(cid:48)G
E(cid:48) ::= C ι
= ι(cid:48)
.
E ::= {E1, . . . , En, E(cid:48)

index term

index variable
function application

patterns
variable (h ≥ 0)
function application
indexed names
list constructor

set computation

set symbol
singleton
product

conjunction

fact

equation over patterns

equation over indices

1, . . . , E(cid:48)

n(cid:48)}

I ::= I1 (cid:93) ··· (cid:93) Ih = J
Cts ::= {I1, . . . ,In}
RG ::= Cts, F G

1 ∧ ··· ∧ F G

set of equations

constraint over sets

set of constraints
n ∧ E ⇒ pred (pG)
generalized Horn clause

Figure 3: Syntax of generalized Horn clauses

come(cid:86)

ι [pG

1 , . . . , pG

construct aM
l ] represents a fresh name a indexed
by ι in [1, M ]. For instance, in the context of group proto-
cols, it may represent a name created by the group member
number ι, inside a group of size M . We use the construct
list(i ≤ M, pG) to represent lists of length M .

of {()} × [1, M ]. For example, intuitively,(cid:86)
The conjunction C =(cid:86)

We extend facts to model the possibility of having a con-
junction of facts depending on indices, so that the facts be-
(i1,...,ih)∈J pred (pG). The set J can be a product of a
set symbol I or a singleton {()} and of diﬀerent sets [1, M ],
depending on diﬀerent bounds M . The symbol [1, M ] rep-
resents the set {1, . . . , M}. The symbol [1, M ] allows us to
keep the information that an index ranges over the full set of
indices of bound M , while other set symbols I represent an
unknown, non-empty set of indices. We write [1, M ] instead
i∈[1,N ] pred (pG)
represents pred (pG{i (cid:55)→ 1}) ∧ ··· ∧ pred (pG{i (cid:55)→ N}), where
pG{i (cid:55)→ i(cid:48)} denotes pG in which i has been replaced with i(cid:48).
(i1,...,ih)∈J with J = {()} and h = 0
n ∧ E ⇒
pred (pG), there are two new members: a set of constraints
Cts and a set of equations E. The ﬁrst one is a set of con-
straints on sets used in conjunctions: the constraint I1 (cid:93)
. . . (cid:93) Ih = J means that I1, . . . , Ih are pairwise disjoint and
their union is J. The second one is a set of equations that
represent the substitutions that cannot be done because the
equations hold for some but not all values of the indices.
These equations can be equations over patterns E and equa-
n ∧ E ⇒
tions over indices E(cid:48). The clause Cts, F G
pred (pG) means that, if the constraints in Cts are satisﬁed,

is omitted: the fact C pred (pG) is then simply pred (pG).

In the generalized Horn clause Cts, F G

1 ∧ ··· ∧ F G

1 ∧ ··· ∧ F G

5771 , . . . , F G

n and the equations in E hold, then
and the facts F G
the fact pred (pG) also holds. The conclusion of a clause does
not contain a conjunction C: we can simply leave the indices
of pred (pG) free to mean that pred (pG) can be concluded for
any value of these indices.

The clauses are required to satisfy the following invariants:

1. In a conjunction(cid:86)

pairwise distinct.

(i1,...,ih)∈J , the indices i1, . . . , ih are

2. Each set symbol I occurs at most once in each con-

straint in Cts.

3. Each set symbol I occurs in at most one left-hand side

of a constraint in Cts.

4. If a set symbol I occurs in a conjunction or in the
right-hand side of a constraint in Cts, then it occurs
in exactly one left-hand side of a constraint in Cts.

We use H G for hypothesis and C G for conclusions. When

Cts or E are empty, we omit them in the clause.
4.2 Representation of the Protocol

The representation of the abilities of the attacker includes
the clauses given in Section 2. For our running example,
att(pk(sk)), att(Signature), att(Body) represent that the at-
tacker initially knows the public key pk (sk) and the con-
stants Signature and Body, and the clauses

att(a[x])
att(x) ∧ att(y) ⇒ att(sign(x, y))
att(x) ⇒ att(pk(x))
att(x) ⇒ att(sha1 (x))
att(x) ∧ att(y) ⇒ att((x, y))

att((x, y)) ⇒ att(x)
att((x, y)) ⇒ att(y)
att(x) ⇒ att((cid:104)x(cid:105))
att((cid:104)x(cid:105)) ⇒ att(x)

represent that the attacker can create fresh names, sign mes-
sages, create its own public keys, apply hash functions, com-
pose and decompose pairs and lists of length one. We have
similar clauses for triples and lists of length two.
(These
arities are the only ones used in our example.)

In addition, we have clauses for list, which generalize

clauses for tuples and lists of ﬁxed length:

i∈[1,M ] att(xi) ⇒ att(list(j ≤ M, xj))

att(list(j ≤ M, xj)) ⇒ att(xi)

(1)

(2)

(cid:86)

is to prove that,

Let us now give clauses that represent the protocol
it-
self. To model the authentication, we use two events
b and e. The event b(r) means that the client sends
the request r; the event e(r) means that the server au-
thorizes the request r. Our goal
if
e(r) is executed,
then b(r) has been executed. We
suppose that the only element signed by the client is
the Body.
Hence the document can be represented
as follows: ((cid:104)(Signature, ids, ((cid:104)(idb, sha1 (Req))(cid:105), sign(((cid:104)(idb,
sha1 (Req))(cid:105), sk)))), (Body, idb, Req)(cid:105), Req), where ids is the
identiﬁer of the Signature and idb the one of the Body. The
client executes the event b(Req), then sends the SOAP en-
velope on the network and the attacker intercepts it, so we
have the clause:
m-event(b(Req)) ⇒ att(((cid:104)(Signature, ids, ((cid:104)(idb, sha1 (Req))(cid:105),

sign(((cid:104)(idb, sha1 (Req))(cid:105), sk)))), (Body, idb, Req)(cid:105), Req)).

(3)

The server expects a document (list(i ≤ M, (tag i, id i,
cont i)), r); he checks the signature, and if the check suc-
ceeds, he executes the event e(r):

att((list(i ≤ M, (tag i, id i, cont i)), r)) ∧
{tag j
sinfo

.
= Signature, cont j
= list(k ≤ N, (id φ(k), sha1 (cont φ(k)))),
.
.
= d, tag d
event(e(r))

= Body} ⇒
.

.
= (sinfo, sign(sinfo, sk)),

φ(m)

(4)

This clause uses the equations explained in Section 3.2.

As already mentioned in Section 3.1, this protocol has
a wrapping attack. The corrected version of this protocol
additionally requires that the signed body is the one that
the server authorizes. This additional check can be modeled
by adding the equation cont d
4.3 Type System

.
= r in the clause (4).

In this section, we deﬁne a simple type system for gen-
eralized Horn clauses, to guarantee that the indices of all
variables vary in the appropriate interval.

Definition 4. An index i is bound if:
• it appears as an index of a conjunction deﬁning a fact,
(i1,...,ih)∈J pred (pG), i1,

so, for instance, in the fact (cid:86)

. . . , ih are bound in pred (pG).

• it appears as an index for a list constructor, that is, in

the pattern list(i ≤ M, pG), i is bound in pG.

We identity facts, equations, and clauses up to renaming
of bound indices. For simplicity, we suppose that the bound
indices of clauses have been renamed so that they have pair-
wise distinct names, and names distinct from the names of
free indices. The set of free indices of a fact F G, of a clause
RG, or of an hypothesis H G is denoted by ﬁ (F G), ﬁ (RG),
ﬁ (H G) respectively.

In the type system, the type environment Γ is a list of

type declarations:

• i : [1, M ] means that i is of type [1, M ], that is, intu-
itively, the value of index i can vary between 1 and the
value of the bound M ;

• φ : [1, M1] × ··· × [1, Mh] → [1, M ] means that the
function φ expects as input h indices of types [1, Mj],
for j = 1, . . . , h and computes an index of type [1, M ];
• x : [1, M1] × ··· × [1, Mh] means that the variable x

expects indices of types [1, M1], . . . , [1, Mh];

• I : [1, M1] × ··· × [1, Mh] means that the elements of
set I are tuples of h indices, each of type [1, Mj] for
j = 1, . . . , h.

The type system deﬁnes the judgments:

• Γ (cid:96) ι : [1, M ], which means that ι has type [1, M ] in

the type environment Γ;

• Γ (cid:96) J : [1, M1] × ··· × [1, Mh], which means that the
elements of set J are tuples of h indices, each of type
[1, Mj] for j = 1, . . . , h in the type environment Γ;

578• Γ (cid:96) pG, Γ (cid:96) F G, Γ (cid:96) E, Γ (cid:96) E(cid:48), Γ (cid:96) I, Γ (cid:96) RG,
which mean that pG, F G, E, E(cid:48), I, RG, respectively,
are well-typed in the type environment Γ.

The typing rules are straightforward and are given in the
long version of the paper [8]. They basically guarantee that
all indices have their expected type.

We suppose that all clauses are well-typed, and we con-
sider that each clause RG comes with its type environment
Γ such that Γ (cid:96) RG. It is easy to verify that the clauses of
our running example are all well-typed.
4.4 Translation from Generalized Horn

Clauses to Horn Clauses

A generalized Horn clause represents several Horn clauses:
for each value of the bounds M , set symbols I, functions φ,
and free indices i that occur in a generalized Horn clause
RG, RG corresponds to a certain Horn clause. This section
formally deﬁnes this correspondence.

Definition 5. Given a well-typed generalized Horn
clause Γ (cid:96) RG, an environment T for Γ (cid:96) RG is a func-
tion that associates:

• to each bound M that appears in RG or Γ an integer

M T ;

• to each index i such that i : [1, M ] ∈ Γ, an index iT ∈

{1, . . . , M T};

• to each index function φ such that φ : [1, M1] × ··· ×
1 } ×

[1, Mh] → [1, M ] ∈ Γ, a function φT : {1, . . . , M T
··· × {1, . . . , M T

h } → {1, . . . , M T}.

• to each set symbol I such that I :

[1, Mh] ∈ Γ, a set I T such that ∅ ⊂ I T ⊆ {1, . . . , M T
··· × {1, . . . , M T

[1, M1] × ··· ×
1 }×

h };

Given an environment T and values v1, . . . , vh, we write
T [i1 (cid:55)→ v1, . . . , ih (cid:55)→ vh] for the environment that associates
to indices i1, . . . , ih the values v1, . . . , vh respectively and
that maps all other values like T .
Given an environment T for Γ (cid:96) RG, the generalized Horn
clause RG is translated into the standard Horn clause RGT
deﬁned as follows. We denote respectively pGT , ET , . . . the
translation of pG, E, . . . using the environment T .
The translation of an index term ι such that Γ (cid:96) ι : [1, M ]
is an integer ιT ∈ {1, . . . , M T} deﬁned as follows:

(cid:40)

ιT =

iT
φT (ιT

1 , . . . , ιT
h )

if ι = i
if ι = φ(ι1, . . . , ιh)

The translation of a pattern pG is deﬁned as follows:

f (pG

1 ,...,ιT
h

(xι1,...,ιh )T = xιT
1 , . . . , pG
1 , . . . , pG

l )T = f (pGT
l ]T = aM T

1

, . . . , pGT

l

)

aM
ι [pG
list(i ≤ M, pG)T =(cid:104)pGT [i(cid:55)→1], . . . , pGT [i(cid:55)→M T ](cid:105)

ιT [pGT

, . . . , pGT

]

1

l

The translation of list(i ≤ M, pG) is a list of length M T .
The translation of a set computation J is a set of tuples

deﬁned by:

J T =

I T

{ ()}
J(cid:48)T × {1, . . . , M T} if J = J(cid:48) × [1, M ]

if J = I
if J = {()}

Given a conjunction C = (cid:86)

In this deﬁnition, the cross product × decomposes tuples
before building the whole tuple, so that J(cid:48)T × {1, . . . , M T}
= {(v1, . . . , vh, v) | (v1, . . . , vh) ∈ J(cid:48)T , v ∈ {1, . . . , M T}}.
(i1,...,ih)∈J and an environ-
ment T , we deﬁne the set of environments T C = {T [i1 (cid:55)→
v1, . . . , ih (cid:55)→ vh] | (v1, . . . , vh) ∈ J T}: these environments
map the indices i1, . . . , ih of the conjunction to all their pos-
sible values in J T and map all other values like T .

The translation of a fact F = C pred (pG) is

(C pred (pG))T = pred (p1) ∧ . . . ∧ pred (pk)

| T (cid:48) ∈ T C}, and (F1 ∧ ··· ∧
The translation of a set of equations E is the set E T ob-

where {p1, . . . , pk} = {pGT (cid:48)
Fn)T = F T
tained by translating the equations E, E(cid:48) as follows:

1 ∧ ··· ∧ F T
n .

(cid:40)

• (C ι

= ι(cid:48))T =
.

true
false

= ι(cid:48)T (cid:48)

if for all T (cid:48) ∈ T C, ιT (cid:48)
otherwise.
= p(cid:48)GT (cid:48) | T (cid:48) ∈ T C}.

• (C pG .

= p(cid:48)G)T = {pGT (cid:48)

• If ∀E(cid:48) ∈ E, E(cid:48)T = true, then E T = (cid:83)

wise, E T is undeﬁned.

E∈E ET ; other-

1 (cid:93) ··· (cid:93) I T

m = J T , that is, I T
1, . . . , pn = p(cid:48)

The equations over indices can be evaluated to true or false
knowing the environment T . The equations over generalized
patterns are translated into equations over patterns. A set
of equations E is translated into a set of equations over pat-
terns if all equations over indices are true. Otherwise, the
translation of E is undeﬁned.
Given a set of constraints Cts and an environment T , we
say that T satisﬁes Cts when, for all equations I1(cid:93)···(cid:93)Im =
J in Cts, we have that I T
1 , . . . ,
m are pairwise disjoint and their union is J T .
I T
Given a set of equations {p1 = p(cid:48)
n} over
standard patterns, we deﬁne as usual its most general uni-
n}) as the most general substi-
ﬁer mgu({p1 = p(cid:48)
1, . . . , pn = p(cid:48)
i for all i ∈ {1, . . . , n}, dom(σ)∪
tution σ such that σpi = σp(cid:48)
fv (im(σ)) ⊆ fv (p1, p(cid:48)
n), and dom(σ)∩fv (im(σ)) =
1, . . . , pn, p(cid:48)
∅, where fv (p) designates the (free) variables of p, dom(σ)
is the domain of σ: dom(σ) = {x | σx (cid:54)= x}, and im(σ) is
im(σ) = {σx | σx (cid:54)= x}. We denote by
the image of σ:
{x1 (cid:55)→ p1, . . . , xn (cid:55)→ pn} the substitution that maps xi to pi
for all i = 1, . . . , n.
Finally, we deﬁne the translation of the generalized Horn
clause RG = Cts, H G ∧ E ⇒ pred (pG) as follows. If T does
not satisfy Cts, E T is undeﬁned, or the uniﬁcation of E T fails,
then RGT is undeﬁned. Otherwise, RGT = mgu(E T )H GT ⇒
mgu(E T )pred (pGT ).
When RG is a set of well-typed generalized Horn clauses
(i.e., a set of pairs of a type environment Γ and a clause RG
such that Γ (cid:96) RG), we deﬁne RGT = {RGT | Γ (cid:96) RG ∈
RG, T is an environment for Γ (cid:96) RG and RGT is deﬁned}.
In terms of abstract interpretation, the sets of generalized
Horn clauses ordered by inclusion constitute the abstract
domain, the sets of Horn clauses ordered by inclusion the
concrete domain, and RGT is the concretization of RG.

5. RESOLUTION FOR GENERALIZED

HORN CLAUSES

In this section, we adapt ProVerif’s resolution algorithm
to generalized Horn clauses: we ﬁrst deﬁne adapted algo-

579rithms for subsumption, resolution, and uniﬁcation, and then
use these components to build the new resolution algorithm.
5.1 Subsumption

To adapt the subsumption test to generalized Horn clauses,
we ﬁrst deﬁne adapted notions of substitutions, then deﬁne
subsumption and prove its soundness.

Definition 6

(Substitutions). We denote by ρ a sub-

stitution that maps:

• bounds to bounds ρ(M ) = N ;
• index variables to index terms: ρ(i) = ι;
• set symbols to set symbols: ρ(I) = I(cid:48);
• function symbols φ to function symbols: ρ(φ) = φ(cid:48).

We denote by σG a substitution that maps variables to pat-
terns: σG(xi1,...,ih ) = pG where ﬁ (pG) ⊆ {i1, . . . , ih}.

As usual, substitutions are extended from variables to
index terms, patterns, facts, equations, constraints, and
clauses as homomorphisms: for instance, ρ(φ(ι1, . . . , ιk)) =
(ρ(φ))(ρ(ι1), . . . , ρ(ιk)). However, since the grammar of gen-
eralized Horn clauses is richer than usual, we need to notice
two points:

• Substitutions avoid the capture of bound indices:

if
i /∈ dom(ρ) and i /∈ ﬁ (im(ρ)), ρ(list(i ≤ M, pG)) =
list(i ≤ ρ(M ), ρ(pG)), which can be guaranteed by re-
naming i if necessary. We have similar formulas for
indices bound by conjunctions as well as for substitu-
tions σG.

• The substitutions σG are extended from variables
xi1,...,ih with indices i1, . . . , ih to variables xι1,...,ιh
with terms ι1, . . . , ιh as indices: if σG(xi1,...,ih ) = pG,
then σG(xι1,...,ιh ) = ρpG where ρ = {i1 (cid:55)→ ι1, . . . , ih (cid:55)→
ιh}.

We need a notion of subsumption between type environ-
ments, which is intuitively ρΓ1 ⊆ Γ2. However, we cannot
use exactly ρΓ1 ⊆ Γ2 because ρ maps indices to index terms
and not to indices, so we deﬁne Γ1 ≤ρ Γ2 by:

• for each i : [1, M ] ∈ Γ1, we have Γ2 (cid:96) ρi : [1, ρM ];
• for each φ : [1, M1] × ··· × [1, Mh] → [1, M ] ∈ Γ1, we

have ρφ : [1, ρM1] × ··· × [1, ρMh] → [1, ρM ] ∈ Γ2;

• for each I : [1, M1] × ··· × [1, Mh] ∈ Γ1, we have ρI :

[1, ρM1] × ··· × [1, ρMh] ∈ Γ2;

• for each x : [1, M1] × ··· × [1, Mh] ∈ Γ1, we have

x : [1, ρM1] × ··· × [1, ρMh] ∈ Γ2.

Definition 7

(Subsumption). Given two well-typed
generalized Horn clauses, Γ1 (cid:96) RG
1 and Γ2 (cid:96) RG
2 , with
1 ∧ E1 ⇒ C G
2 ∧ E2 ⇒
RG
1 and RG
2 = Cts 2, H G
1 = Cts 1, H G
1 subsumes Γ2 (cid:96) RG
2 , we say that Γ1 (cid:96) RG
C G
2 , and we
write Γ1 (cid:96) RG
1 (cid:119) Γ2 (cid:96) RG
2 , if there exist substitutions ρ
1 ⊆ H G
and σG such that σGρC G
(multi-
set inclusion), σGρE1 ⊆ E2 (modulo commutativity of
.
=),
ρCts 1 ⊆ Cts 2 (modulo associativity and commutativity of
(cid:93)), and Γ1 ≤ρ Γ2.

2 , σGρH G

1 = C G

2

This deﬁnition is similar to subsumption for standard
clauses but uses the richer substitutions introduced above.

Example 1. The clause

1 ={I (cid:93) I1 = [1, M ]},(cid:86)

RG

{(cid:86)

m∈I1

ym

.
= cM

m} ⇒ att(yl)

i∈I att(sign(xi, skL

φ(l))) ∧

2 ={I
RG

typed by the type environment Γ1 = {I : [1, M ], I1 : [1, M ],
x : [1, M ], φ : [1, M ] → [1, L], y:[1, M ], l : [1, M ]}, subsumes
the clause

(cid:48) (cid:93) I

(cid:86)
{(cid:86)

1 = [1, N ]},
(cid:48)
j∈I(cid:48) att(sign((rN
n∈I(cid:48)

.
= cN

ϕ(ψ(k)))) ∧

1

zn

ψ(j), sN

ψ(j)), skO
n } ⇒ att(zψ(k)).
typed by the environment Γ2 = {I(cid:48) : [1, N ], I(cid:48)
1 = [1, N ], ψ :
[1, N ] → [1, N ], ϕ : [1, N ] → [1, O], k : [1, N ], z : [1, N ], k :
[1, N ]} With ρ = {M (cid:55)→ N, L (cid:55)→ O, I (cid:55)→ I(cid:48), I1 (cid:55)→ I(cid:48)
1, φ (cid:55)→
ϕ, l (cid:55)→ ψ(k)} and renaming the bound indices i into j and
m into n, we obtain:

1 = [1, N ]},(cid:86)

(cid:48)

ρRG

1 ={I

(cid:48) (cid:93) I

{(cid:86)

n∈I(cid:48)

1

yn

.
= cN

n } ⇒ att(yψ(k))

j∈I(cid:48) att(sign(xj, skO

ϕ(ψ(k)))) ∧

and conclude that RG

1 subsumes RG

2 using the substitution

σG = {xi (cid:55)→ (rN

ψ(i), sN

ψ(i)), yi (cid:55)→ zi}.

The following theorem shows the soundness of subsump-

tion for generalized Horn clauses.

(Subsumption). Let Γ1 (cid:96) RG

Theorem 2
2 be two well-typed clauses. If Γ1 (cid:96) RG
RG
for all environments T2 for Γ2 (cid:96) RG
ﬁned, there exists an environment T1 for Γ1 (cid:96) RG
RGT1

1 (cid:119) Γ2 (cid:96) RG
2 such that RGT2

1 and Γ2 (cid:96)
2 then,
is de-
1 such that

is deﬁned and RGT1

1 (cid:119) RGT2

.

2

1

2

As for standard clauses, our resolution algorithm for gen-
eralized Horn clauses will eliminate subsumed clauses. This
theorem shows that, if RG
2 is eliminated in the algorithm
for generalized Horn clauses because it is subsumed by RG
1 ,
then all corresponding clauses RGT2
would be eliminated in
the algorithm for standard clauses: RGT2
is subsumed by
some RGT1

.

2

2

1

The subsumption test is approximate, because clauses that
have the same meaning may sometimes be written in diﬀer-
ent forms. For instance, one can compose two functions φ
and ψ, always writing φ(ψ(i, j)) instead of a single function
ψ(i, j). These two formulas yield the same translation into
standard Horn clauses, but are considered diﬀerent by the
subsumption test. This approximation does not contradict
the soundness of subsumption, and the subsumption test is
precise enough for the proof to succeed on our examples.

Because of the presence of indices, the algorithm for com-
puting the substitutions ρ and σG required in Deﬁnition 7
is more complex than for standard clauses. We detail it in
the long version of the paper [8].
5.2 Resolution and Hyperresolution

As introduced in Section 3.2, resolution becomes hyper-
resolution for generalized clauses. We ﬁrst give the formal
deﬁnition of hyperresolution, then explain it.

5801 and RG

(Hyperresolution). Let RG

2 = Cts 2, F G
1 and RG

Definition 8
1 = Cts 1,
1 ∧ E1 ⇒ C G
2 ∧ E2 ⇒ C G
0 ∧ H G
H G
2
be two clauses. We rename RG
2 so that they do not
use common names for bounds M , variables x, indices i,
functions on indices φ, and set symbols I.
2 ) (h (cid:54)= 0). Let
1 and J such that Γ2 (cid:96) J : [1, M1] × ··· × [1, Mh].
1 into (i1, . . . , ih) ∈ J is the clause
1 , (i1, . . . , ih) ∈ J) obtained by replacing:

Γ1 (cid:96) RG
The immersion of RG
imm(RG

0 = (cid:86)

(i1,...,ih)∈J pred 2(pG

First case: F G

1. all free indices i of RG

1 with φ(cid:48)(i1, . . . , ih), where a new
function symbol φ(cid:48) is associated to each free index i of
RG
1 ;

2. all index terms φ(ι1, . . . , ιk) with φ(cid:48)(i1, . . . , ih, ι1, . . . ,
ιk), where a new function symbol φ(cid:48) is associated to
each function symbol φ in RG
1 ;

3. all variables xι1,...,ιk in RG

(j1,...,jk)∈[1,M(cid:48)
(i1,...,ih,j1,...,jk)∈J×[1,M(cid:48)

1 with xi1,...,ih,ι1,...,ιk ;
k] in H G
k];

1]×···×[1,M(cid:48)
1]×···×[1,M(cid:48)

1 and

4. all conjunctions(cid:86)
E1 with(cid:86)
5. all conjunctions (cid:86)
and E1 with(cid:86)

(j1,...,jk)∈I×[1,M(cid:48)
(i1,...,ih,j1,...jk)∈I(cid:48)×[1,M(cid:48)

l ] in H G
l ], where
a new set symbol I(cid:48) is associated to each set symbol I
in RG
1 ;

1]×···×[1,M(cid:48)
1]×···×[1,M(cid:48)

1

6. all constraints I1 (cid:93) ··· (cid:93) In = [1, M(cid:48)
n = J × [1, M(cid:48)

Cts 1 with I(cid:48)
all constraints I1 (cid:93)···(cid:93) In = I × [1, M(cid:48)
n = I(cid:48) × [1, M(cid:48)
in Cts 1 with I(cid:48)

1 (cid:93)···(cid:93) I(cid:48)

1 (cid:93)···(cid:93) I(cid:48)

1] × ··· × [1, M(cid:48)
1]×···× [1, M(cid:48)

k] in
k] and
1]×···× [1, M(cid:48)
k]
1]×···× [1, M(cid:48)
k].
J ∧ EJ ⇒

Let imm(RG

1 , (i1, . . . , ih) ∈ J) = Cts J , H G

pred 1(pG

1 ). If pred 1 = pred 2, we deﬁne:
2 = Cts J ∪ Cts 2, H G
RG

1 ◦Full
RG

J ∧ H G
2 ∧

({(cid:86)

F G
0
(i1...,ih)∈J pG

1

.
= pG

2 } ∪ EJ ∪ E2) ⇒ C G

2

Let I(cid:48) and I(cid:48)(cid:48) be fresh set symbols.
(i1, . . . , ih) ∈ I(cid:48)) = Cts I(cid:48) , H G
pred 1 = pred 2, we deﬁne:

I(cid:48) ∧ EI(cid:48) ⇒ pred 1(pG
1 ).

imm(RG
1 ,
If

Let

F G
0

1 ◦Part
RG
(H G

I(cid:48) ∧(cid:86)
({(cid:86)

2 = Cts I(cid:48) ∪ Cts 2 ∪ {I
RG
(i1,...,ih)∈I(cid:48)(cid:48) pred 2(pG

(cid:48) (cid:93) I
2 ) ∧ H G

(cid:48)(cid:48)
2 )∧

= J},

.
= pG

2 } ∪ EI(cid:48) ∪ E2) ⇒ C G
2 .

(i1,...,ih)∈I(cid:48) pG

1

1

F G
0

RG

.
= pG

Second case: F G

. . . , ih) ∈ J corresponds to (cid:86)

0 = pred 2(pG
2 = Cts 1 ∪ Cts 2, H G
1 ◦Full
RG
F G
2 }∪E1∪E2) ⇒ C G
1 ◦Part
0
2 . RG

2 ) (ordinary resolution). If
1 ∧
pred 1 = pred 2, we deﬁne RG
2 ∧({pG
H G
2 is undeﬁned.
Intuitively, the immersion of RG = H G ⇒ C G into (i1,
(i1,...,ih)∈J H G(i1, . . . , ih) ⇒
C G(i1, . . . , ih), which represents the combination of a dis-
tinct instance of RG for each (i1, . . . , ih) ∈ J, as outlined in
Section 3.2. To represent distinct instances of RG, the free
indices i, variables x, and functions φ use (i1, . . . , ih) as addi-
tional indices or arguments. Sets I should also become func-
tions of the indices (i1, . . . , ih); however, to simplify the syn-
tax of generalized Horn clauses, we avoid sets that depend on

(j1,...,jk)∈I×[1,M1]×···×[1,Ml] pred (pG) ∈ H G,

indices: when (cid:86)
(cid:86)
(cid:86)

instead of writing

(i1,...,ih)∈J

(j1,...,jk)∈I(i1,...,ih)×[1,M1]×···×[1,Ml] pred (pG)

we write(cid:86)

F G
0

1 ◦Full

1 upon F G

In order to resolve RG

0 = (cid:86)

0 ∧ H G
2 = Cts 2, F G
(i1,...,ih)∈J pred 2(pG

(i1,...,ih,j1,...,jk)∈I(cid:48)×[1,M1]×···×[1,Ml]pred (pG) where
the symbol I(cid:48) stands for {(i1, . . . , ih, j1, . . . , jk−l) | (i1, . . . ,
ih) ∈ J, (j1, . . . , jk−l) ∈ I(i1, . . . , ih)}. This leads to point 5
of the deﬁnition of immersion, and the corresponding trans-
formation of constraints in point 6. This transformation in-
troduces a minor approximation, since the obtained clause
does not keep the information on how the set I(cid:48) is built.
2 ∧ E2 ⇒ C G
2
with RG
2 ), we perform
the resolution on any non-empty subset I(cid:48) of J. We dis-
tinguish two cases: either I(cid:48) is the full set J, and we pro-
2 , or I(cid:48) is a strict
duce the full hyperresolution RG
RG
subset of J, and we produce the partial hyperresolution
1 ◦Part
2 . In the latter case, using the set I(cid:48)(cid:48) such that
RG
RG
2 = Cts 2 ∪ {I(cid:48) (cid:93) I(cid:48)(cid:48) =
I(cid:48) (cid:93) I(cid:48)(cid:48) = J, RG
2 )∧ H G
2 ∧
2 . We can then perform resolution upon F G
I(cid:48) =
2 ) for the full set I(cid:48). We use the immer-
sion to compute a clause RG
I(cid:48) that corresponds to instances
1 for all (i1, . . . , ih) ∈ I(cid:48), and then perform a fairly stan-
of RG
dard resolution step: we require that the conclusion of RG
I(cid:48)
equals the hypothesis F G
2 and generate the combined
clause. (The uniﬁcation of the conclusion of RG
I(cid:48) with the
hypothesis F G
2 is delayed until the simpliﬁcation of
clauses, described in Section 5.3.)
When h = 0 and J = {()}, F G

E2 ⇒ C G
(i1,...,ih)∈I(cid:48) pred 2(pG

J},(cid:86)
(cid:86)

2 can also be written RG

(i1,...,ih)∈I(cid:48)(cid:48) pred 2(pG

(i1,...,ih)∈I(cid:48) pred 2(pG

2 )∧(cid:86)

I(cid:48) of RG

2 ) and J is a
2 does not exist, and we perform an

0 = pred 2(pG

singleton, so RG
ordinary resolution step. (Immersion is not necessary.)

1 ◦Part

I(cid:48) of RG

RG

F G
0

F G
0

2

F G
0

1 ◦Full

Theorem 3

2 . We have ΓFull (cid:96) RG

(Resolution). Let Γ1 (cid:96) RG

1 and Γ2 (cid:96) RG
0 ∧ H G
2 ∧
2 = Cts 2, F G
be two well-typed clauses, such that RG
1 ◦Part
2 and ΓPart (cid:96) RG
E2 ⇒ C G
RG
F G
0
RG
2 for some type environments ΓFull and ΓPart (when these
clauses are deﬁned).
Let Ti be an environment for Γi (cid:96) RG
is
deﬁned, for i = 1, 2. Let F0 ∈ mgu(E T2
be a fact in
the hypothesis of RGT2
that comes from the translation F G
0 .
Suppose that RGT1
can be resolved upon F0 into
1 ◦Part
the clause R. Then R is equal to (RG
F G
0
RG
2 )T up to renaming of variables, for some environment T
for ΓFull (cid:96) RG

i such that RGTi
2 )F GT2

2 (resp. ΓPart (cid:96) RG
RG

2
and RGT2

2 )T or (RG

1 ◦Part

1 ◦Full

1 ◦Full

RG

RG

2 ).

F G
0

0

1

2

i

F G
0

F G
0

i∈[1,L] att(sha1 (contφ(i))) ∧

Example 2. Let us consider the following two clauses:
1 = att(x) ⇒ att(sha1 (x))
RG
RG
att(sign(list(i ≤ L, sha1 (contφ(i))), sk)) ⇒ event(e(r))
To compute the partial hyperresolution of (6) with (5) for a
set I, we compute the immersion of (5) into i ∈ I: we add to
i∈I in the hypoth-

2 =(cid:86)
x the index i and we add a conjunction(cid:86)
esis (replacing the omitted empty conjunction(cid:86)

(5)

(6)

()∈{()}):

(cid:86)
i∈I att(xi) ⇒ att(sha1 (xi))

Partial hyperresolution yields

F0 RG

2 = {I (cid:93) I

1 ◦Part
RG
i∈I(cid:48) att(sha1 (contφ(i))) ∧

(cid:48)

= [1, L]},(cid:86)

i∈I att(xi) ∧

(cid:86)
{(cid:86)

att(sign(list(i ≤ L, sha1 (contφ(i))), sk)) ∧

i∈I sha1 (xi)

= sha1 (contφ(i))} ⇒ event(e(r))
.

(7)

(8)

581This clause will be further simpliﬁed by the transformations
given in Section 5.3.
5.3 Simpliﬁcation of Clauses

• When one of the two sides of an equation is a variable
that does not occur anywhere else in the clause, we
remove that equation.

We use several additional transformations in order to
simplify clauses. Some of these transformations are eas-
ily adapted from similar transformations already used in
ProVerif. We summarize here the new transformations and
refer the reader to the long version of the paper [8] for details
on all these transformations.
5.3.1 Uniﬁcation
Instead of performing uniﬁcation as part of resolution, we
simplify equations a posteriori. The main simpliﬁcations are
as follows. (The others are detailed in the long version of
the paper [8].)

1

1

k

k

= f (p(cid:48)G
.

1 , . . . , p(cid:48)G

k ] with C pG

k ) with C pG

• We decompose equations. We replace the equation
C f (pG
= p(cid:48)G
.
1 , . . . , pG
k )
1 ,
. . . , C pG
k . We replace the equation C aM
= p(cid:48)G
.
ι [pG
1 ,
= aM(cid:48)
[p(cid:48)G
= p(cid:48)G
1 , . . . , p(cid:48)G
.
.
. . . , pG
k ]
1 ,
. . . ,
ι(cid:48)
(cid:86)
C pG
k , C ι
= p(cid:48)G
= ι(cid:48) and replace every occurrence of
.
.
M(cid:48) in the clause with M . We replace the equation
(cid:86)
= list(i ≤ M(cid:48), p(cid:48)G) with
(i1,...,ih)∈J list(i ≤ M, pG)
.
= p(cid:48)G and replace every occur-
(i1,...,ih,i)∈J×[1,M ] pG .
The equation(cid:86)
rence of M(cid:48) in the clause with M .

(i1,...,ih(cid:48) )∈J list(i ≤ M, pG)

1 , . . . ,
h (cid:105) can be handled in two ways. The preferred so-
pG
lution is to instantiate M into the integer h. In this
instantiation, variables x that have an index of type
[1, M ] become h variables x 1, . . . , x h, and functions
φ that have an argument of type [1, M ] become h func-
tions φ 1, . . . , φ h. After instantiation, we apply uniﬁ-
cation again on the obtained clause(s). This solution is
applied when the clause contains no function φ with a
result of type [1, M ], no set symbol I with a type that
contains [1, M ], and no name with an index of type
[1, M ]. (Otherwise, the instantiated clause may not ﬁt
in our language of clauses.) When this instantiation
cannot be applied, we replace the equation with

= (cid:104)pG
.

(cid:86)
(cid:86)
(cid:86)

(i1,...,ih(cid:48) ,i)∈J×[1,M ] xi1,...,ih(cid:48) ,i
.
= pG
(i1,...,ih(cid:48) ,i)∈I1
.
= pG
(i1,...,ih(cid:48) ,i)∈Ih
h

xi1,...,ih(cid:48) ,i
xi1,...,ih(cid:48) ,i

.
= pG,

1 , . . . ,

and add the constraint I1(cid:93) . . .(cid:93) Ih = J × [1, M ], where
x is a fresh variable and I1, . . . , Ih are fresh set sym-
bols. Intuitively, the variable xi1,...,ih(cid:48) ,i contains the
i-th element of the list. This solution introduces an
approximation: we remember that the elements of the
list are pG
h but we forget their order and their
number of repetitions.

1 , . . . , pG

The clause is removed when the two sides of the equa-
tion have diﬀerent root function symbols. The equa-
tion is removed when its two sides are identical.

• When there is an equation(cid:86)

.
= pG,
we replace x with its value (provided the indices of x
match, and no occurrence of x in p(cid:48)G can be replaced;
the latter condition serves to avoid loops).

(i1,...,ih)∈J xι1,...,ιk

• When there is an equation i

.
= ι and i does not occur

in ι, we replace i with ι and delete the equation.

Example 3. Applying these transformations, the clause

= [1, L]},(cid:86)

(8) becomes

(cid:48)

F0 RG

2 = {I (cid:93) I

1 ◦Part
RG
i∈I(cid:48) att(sha1 (contφ(i))) ∧

(cid:86)
Indeed, the equation (cid:86)
becomes(cid:86)

i∈I xi

xi, and the equation is removed.

att(sign(list(i ≤ L, sha1 (contφ(i))), sk)) ⇒ event(e(r))

.
= sha1 (contφ(i)) ﬁrst
.
= contφ(i), then contφ(i) is substituted for

i∈I sha1 (xi)

i∈I att(contφ(i)) ∧

(9)

The unication algorithm is not complete, in that for some
complex equations, it may be unable to use the equations to
simplify the clause or to remove it, even though that would
be sound. This limitation may be lead to false attacks. In
practice, the algorithm is still precise enough to be able the
prove all desired properties of our case studies (Section 6).
5.3.2 Merging of Sets
When a clause uses two disjoint sets I and I(cid:48) in the same
facts and equations (up to renaming), we merge these two
sets into a single set I(cid:48)(cid:48). This transformation is key to obtain
termination of the algorithm: when a clause RG is obtained
by partial hyperresolution of two clauses RG
2 , it
1 into R(cid:48)G, and so on, which
can be resolved again with RG
would yield an inﬁnite loop. However, by merging sets in
R(cid:48)G, we can build a clause that is subsumed by RG, and so
removed, which stops the loop. We illustrate this point on
an example. The clause (9) can be resolved again by partial
hyperresolution with the clause (6). We obtain:

1 and RG

(cid:48)},(cid:86)

i∈I att(contφ(i)) ∧

(cid:86)
(cid:86)

{I (cid:93) I
i∈I1
i∈I(cid:48)

1

(cid:48)
1 = I

= [1, L], I1 (cid:93) I
(cid:48)
att(contφ(i)) ∧
att(sha1 (contφ(i))) ∧

att(sign(list(i ≤ L, sha1 (contφ(i))), sk)) ⇒ event(e(r))

which could be resolved again with (6). However, after re-
placing the two constraints with I(cid:93)I1(cid:93)I(cid:48)
1 = [1, L], we merge
I and I1 together into the set I2:

1 = [1, L]},(cid:86)

(cid:48)
att(sha1 (contφ(i))) ∧

i∈I2

(cid:86)

{I2 (cid:93) I
i∈I(cid:48)

1

att(contφ(i)) ∧

att(sign(list(i ≤ L, sha1 (contφ(i))), sk)) ⇒ event(e(r))

This clause will be removed by the algorithm of Section 5.4,
because it is subsumed by (9), so the loop is avoided.

The merging of sets is not always able to avoid loops that
come from partial hyperresolution, in particular when a fresh
bound M is created at each partial hyperresolution step.
This limitation is the main new cause of non-termination,
but its impact is limited in practice since the selection func-
tion is tuned to avoid partial hyperresolution when possible.
5.3.3
Let simp(Γ (cid:96) RG) be the set of well-typed generalized
Horn clauses obtained by simplifying RG as described above.
This function is naturally extended to sets of clauses. The
following theorem shows the soundness of simp.

Soundness of Simpliﬁcation

582saturG(RG

0 ) =

1. RG ← elimG(simp(RG

0 )).

2. Repeat until a ﬁxpoint is reached:

for each Γ (cid:96) RG ∈ RG such that sel G(RG) = ∅,
for each Γ(cid:48) (cid:96) R(cid:48)G ∈ RG, for each F G
RG ← elimG(simp({ΓFull (cid:96) RG ◦Full
ΓPart (cid:96) RG ◦Part

0 ∈ sel G(R(cid:48)G),
R(cid:48)G,
R(cid:48)G}) ∪ RG).

F G
0

F G
0

3. Return {Γ (cid:96) RG ∈ RG | sel G(RG) = ∅}.

Figure 4: New Resolution Algorithm

Theorem 4. Let Γ (cid:96) RG be a well-typed generalized Horn
clause. For all environments T for Γ (cid:96) RG, if RGT is de-
ﬁned, then there exist a clause Γ(cid:48) (cid:96) R(cid:48)G ∈ simp(Γ (cid:96) RG) and
an environment T (cid:48) for Γ(cid:48) (cid:96) R(cid:48)G such that R(cid:48)GT (cid:48) (cid:119) RGT .
5.4 Extension of the Resolution Algorithm

The resolution algorithm for generalized Horn clauses sim-
ulates the one for standard Horn clauses. We need to deﬁne
a generalized selection function sel G.

Definition 9

(Generalized selection function).
A generalized selection function is a function from general-
ized Horn clauses to sets of facts, such that sel G(Cts, H G ∧
E ⇒ C G) ⊆ H G.

Similarly to the case of standard Horn clauses, a good
generalized selection function does not select m-event(pG)
nor att(xι1,...,ιh ). Furthermore, resolution is much simpler
for facts att(pG) without conjunction than for facts with
conjunction, so we select a fact without conjunction when
possible. Hence, we use the following selection function:
sel G(Cts, H G ∧ E ⇒ C G) =



∅

{att(pG)}
∅

if att(pG) ∈ H G for some non-variable pG
if the ﬁrst case does not apply and
C G = att(pG) for some non-variable pG
{C att(pG)} if the previous cases do not apply and

C att(pG) ∈ H G for some non-variable pG
otherwise

The resolution algorithm is shown in Figure 4. It mimics
the algorithm of Figure 2: saturG(RG
0 ) ﬁrst inserts in RG
the clauses in RG
0 after elimination of subsumed clauses by
elimG: when Γ(cid:48) (cid:96) R(cid:48)G subsumes Γ (cid:96) RG and both Γ (cid:96) RG
and Γ(cid:48) (cid:96) R(cid:48)G are in RG, Γ (cid:96) RG is removed by elimG(RG).
Next, the resolution algorithm performs hyperresolution un-
til a ﬁxpoint is reached. Finally, it returns the clauses in RG
with no selected hypothesis.

Let Fme be any set of facts of the form m-event(p).
Theorem 5. Let F be a well-typed closed fact and RG

0 a
set of well-typed generalized Horn clauses. If F is derivable
from RGT

0 ∪ Fme, then F is derivable from
T ∪ Fme.

(saturG(RG
0 ))

This result shows the soundness of our algorithm.

Its
proof is adapted from the proof of satur (Theorem 1) and

uses the soundness theorems for resolution, simpliﬁcation,
and subsumption.
To prove that a closed fact att(pGT ) is not derivable from
RGT
1 ∪ Fme, we use the following result, where att(cid:48) is a new
predicate:

Corollary 3. If saturG(RG

1 ∪ {att(pG) ⇒ att(cid:48)(pG)})
contains no clause of the form Γ (cid:96) Cts, H G ∧E ⇒ att(cid:48)(p(cid:48)G),
then, for all environments T , att(pGT ) is not derivable from
RGT
1 ∪ Fme.

This corollary is proved like Corollary 1, and makes it pos-
sible to prove that the protocol preserves the secrecy of p,
for lists of any length.

Cts,(cid:86)

Corollary 4. Suppose that all clauses of saturG(RG
1 )
that conclude event(e(pG)) for some pG are of the form Γ (cid:96)
(i1,...,ih)∈[1,M1]×···×[1,Mh] m-event(e(cid:48)(p(cid:48)G))∧H G∧E ⇒
event(e(ρp(cid:48)G)) for some Γ, Cts, i1, . . . , ih, M1, . . . , Mh, H G,
E, p(cid:48)G, and some substitution ρ that maps indices i1, . . . , ih
to index terms. Then, for all Fme, for all p, if event(e(p))
is derivable from RGT
1 ∪ Fme, then m-event(e(cid:48)(p)) ∈ Fme.

This corollary makes it possible to prove that the protocol
satisﬁes the correspondence “if e(x) has been executed, then
e(cid:48)(x) has been executed”.

6. EXPERIMENTAL RESULTS

Our algorithm cannot prove authentication for our run-
ning example. Indeed, the result of saturG contains a clause
of the form

att(r) ∧ m-event(b(Req)) ∧ E ⇒ event(e(r))

where r does not occur in E. This clause does not sat-
isfy Corollary 4: the event e(r) may be executed for any r
that the adversary has, even though only b(Req) has been
executed. This clause corresponds to the wrapping attack
described in Section 3.1.

In contrast, our algorithm proves authentication for the
corrected version of our running example. The only clause
in the result of saturG that concludes event(e(pG)) is of the
form

m-event(e(Req)) ∧ E ⇒ event(e(Req))

Hence, using Corollary 4, we can conclude that, if event e(r)
has been executed, then event b(r) has been executed as well.
(In our case, the only possible value of r is the request Req
of the client.)

In addition to this protocol, we tested our tool on the XML
protocols studied in [5]: password digest, password-based
signature, X.509 signature, and ﬁrewall-based authentica-
tion. These are web services security protocols, whose goal
is to authenticate a client to a web service. The ﬁrst two
protocols depend on password-based authentication: a pass-
word is shared between the user and the server. In the ﬁrst
protocol, a digest of the password, a nonce, and a timestamp
is sent by the client to the server. In the second protocol, the
client signs its request using a signature key generated from
the password. The X.509 signature protocol uses public-key
signatures based on X.509 certiﬁcates. Finally, the ﬁrewall-
based authentication protocol uses a SOAP-level ﬁrewall in
addition to the server and the client. The client uses a
password-based signature; the ﬁrewall veriﬁes this signature,

583and when this authentication succeeds, adds a new fire-
wall header, signed using its X.509 certiﬁcate, indicating
that it has authenticated the client. For all these protocols,
we automatically proved the authentication property proved
manually in [5].

Finally, we also modeled the Asokan-Ginzboorg group pro-
tocol [1], and proved the secrecy of the session key. This
property was already proved in [19], but on a model less
precise than ours. For all these examples, our tool termi-
nates in less than 0.5 s on a MacBook Air 1.4 Ghz. The
input ﬁles for all these case studies can be found at [8].

7. CONCLUSION AND FUTURE WORK

We have proposed a new type of clauses, generalized Horn
clauses, useful to represent protocols that manipulate lists of
unbounded length. We have adapted the deﬁnitions previ-
ously introduced for Horn clauses to these new clauses. We
have thus obtained a new algorithm for verifying secrecy and
authentication properties for protocols with lists, which we
have proved correct and implemented. We have successfully
tested our tool on several XML protocols.

ProVerif supports a variant of the applied pi calculus for
modeling protocols. However, in this paper, we need to
model protocols with generalized Horn clauses. We plan
to extend the input language of ProVerif to model protocols
with lists of unbounded length, and to translate it automat-
ically to generalized Horn clauses. We also plan to provide
an input format with messages in XML, in the style of the
tool TulaFale [6], with an extension to unbounded lists.

8. ACKNOWLEDGMENTS

This work was partly supported by the ANR project ProSe
(decision number ANR-2010-VERS-004-01). It was partly
done while the authors were at ´Ecole Normale Sup´erieure,
Paris.

9. REFERENCES
[1] N. Asokan and P. Ginzboorg. Key agreement in ad

hoc networks. Computer Communications,
23(17):1627–1637, 2000.

[2] L. Bachmair and H. Ganzinger. Resolution theorem
proving. In A. Robinson and A. Voronkov, editors,
Handbook of Automated Reasoning, volume 1,
chapter 2, pages 19–100. North Holland, 2001.
[3] M. Backes, S. M¨odersheim, B. Pﬁtzmann, and

L. Vigan`o. Symbolic and cryptographic analysis of the
secure WS-ReliableMessaging scenario. In
FoSSaCS’06, volume 3921 of LNCS, pages 428–445.
Springer, 2006.

[4] M. Bartel, J. Boyer, B. Fox, B. LaMacchia, and
E. Simon. XML signature syntax and processing
(second edition). Available at
http://www.w3.org/TR/xmldsig-core/.

[5] K. Bhargavan, C. Fournet, and A. D. Gordon. A

semantics for web services authentication. In
POPL’04, pages 198–209. ACM, 2004.

[6] K. Bhargavan, C. Fournet, A. D. Gordon, and

R. Pucella. Tulafale: A security tool for web services.
In FMCO’03, volume 3188 of LNCS, pages 197–222.
Springer, 2004.

[7] B. Blanchet. Automatic veriﬁcation of

correspondences for security protocols. Journal of
Computer Security, 17(4):363–434, July 2009.

[8] B. Blanchet and M. Paiola. Automatic veriﬁcation of

protocols with lists of unbounded length. Long
version, ﬁles available at
http://prosecco.gforge.inria.fr/personal/
bblanche/publications/BlanchetPaiolaCCS13.html,
2013.

[9] A. Brown, B. Fox, S. Hada, B. LaMacchia, and

H. Maruyama. SOAP security extensions: Digital
signature. Available at
http://www.w3.org/TR/SOAP-dsig/.

[10] J. Bryans and S. Schneider. CSP, PVS and recursive

authentication protocol. In DIMACS Workshop on
Formal Veriﬁcation of Security Protocols, Sept. 1997.

[11] N. Chridi, M. Turuani, and M. Rusinowitch.

Constraints-based Veriﬁcation of Parameterized
Cryptographic Protocols. Research Report RR-6712,
INRIA, 2008.

[12] N. Chridi, M. Turuani, and M. Rusinowitch.

Decidable analysis for a class of cryptographic group
protocols with unbounded lists. In CSF’09, pages
277–289. IEEE Computer Society, 2009.

[13] D. Dolev and A. C. Yao. On the security of public key
protocols. IEEE Transactions on Information Theory,
IT-29(12):198–208, Mar. 1983.

[14] L. Georgieva, U. Hustadt, and R. A. Schmidt. A new

clausal class decidable by hyperresolution. In
CADE-18, volume 2392 of LNCS, pages 260–274.
Springer, 2002.

[15] E. Kleiner and A. W. Roscoe. On the relationship

between web services security and traditional
protocols. In MFPS 21, volume 155 of Electronic Notes
in Theoretical Computer Science, pages 583–603, 2006.

[16] R. K¨usters and T. Truderung. On the automatic

analysis of recursive security protocols with XOR. In
W. Thomas and P. Weil, editors, STACS’07, volume
4393 of LNCS, pages 646–657. Springer, 2007.

[17] G. Lowe. A hierarchy of authentication speciﬁcations.

In CSFW’97, pages 31–43. IEEE Computer Society,
June 1997.

[18] M. Mcintosh and P. Austel. XML signature element
wrapping attacks and countermeasures. In SWS’05,
pages 20–27. ACM, 2005.

[19] M. Paiola and B. Blanchet. Veriﬁcation of security
protocols with lists: from length one to unbounded
length. In POST’12, volume 7215 of LNCS, pages
69–88. Springer, 2012.

[20] L. C. Paulson. Mechanized proofs for a recursive

authentication protocol. In CSFW’97, pages 84–95.
IEEE Computer Society Press, 1997.

[21] A. W. Roscoe and E. Kleiner. Web Services Security:

a preliminary study using Casper and FDR. In
Automated Reasoning for Security Protocol Analysis
(ARSPA’04), 2004.

[22] T. Truderung. Selecting theories and recursive

protocols. In CONCUR 2005, volume 3653 of LNCS,
pages 217–232. Springer, 2005.

584