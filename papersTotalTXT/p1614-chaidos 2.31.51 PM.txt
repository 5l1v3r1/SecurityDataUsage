A Non-interactive Receipt-Free Electronic Voting Scheme

BeleniosRF:

Pyrros Chaidos

University College London

Gower St, London WC1E 6BT, UK
pyrros.chaidos.10@ucl.ac.uk

Véronique Cortier

LORIA, CNRS & INRIA & Université de Lorraine

54500 Vandœuvre-lès-Nancy, France

veronique.cortier@loria.fr

Georg Fuchsbauer

Inria, ENS, CNRS, PSL Research University

45, rue d’Ulm, 75005 Paris, France

georg.fuchsbauer@ens.fr

David Galindo

University of Birmingham

Edgbaston, Birmingham B15 2TT, UK

D.Galindo@cs.bham.ac.uk

ABSTRACT
We propose a new voting scheme, BeleniosRF, that oﬀers both
receipt-freeness and end-to-end veriﬁability. It is receipt-free
in a strong sense, meaning that even dishonest voters cannot
prove how they voted. We provide a game-based deﬁnition
of receipt-freeness for voting protocols with non-interactive
ballot casting, which we name strong receipt-freeness (sRF).
To our knowledge, sRF is the ﬁrst game-based deﬁnition
of receipt-freeness in the literature, and it has the merit
of being particularly concise and simple. Built upon the
Helios protocol, BeleniosRF inherits its simplicity and does
not require any anti-coercion strategy from the voters. We
implement BeleniosRF and show its feasibility on a number
of platforms, including desktop computers and smartphones.

1.

INTRODUCTION

Electronic voting protocols should achieve two antagonistic
security goals: privacy and veriﬁability. Additionally, they
must be practical, from a usability, operational, and eﬃciency
point of view. Privacy can be expressed via several, increas-
ingly demanding security properties.

• Basic ballot privacy guarantees that no one can learn

how a voter voted.

• Receipt-freeness ensures that a voter cannot prove to
anyone how she voted. While privacy protects honest
voters, receipt-freeness aims at protecting vote privacy
even when voters willingly interact with an attacker.
• Coercion-resistance should allow an honest voter to
cast her vote even if she is, during some time, fully
under the control of an attacker. Coercion-resistance
typically requires revoting.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978337

Conversely, veriﬁability ensures that voters’ ballots are in-
cluded in the ballot box (individual veriﬁability), that the
result corresponds to the content of the ballot box (universal
veriﬁability) and that ballots come only from voters entitled
to vote (eligibility veriﬁability).

Helios [3, 4] is a scheme that “only” achieves privacy and
veriﬁability and is based on a voting system by Cramer,
Gennaro and Schoenmakers [25] with modiﬁcations proposed
by Benaloh [7]. It has been used in several elections such as
that of the president of UC Louvain in Belgium, and of the
Board of Directors of the IACR since 2011 [1]. As emphasized
by its authors, Helios should only be used in low-coercion
environments. Indeed, a voter may reveal the randomness
used to compute her ballot; one can then re-encrypt the
claimed vote and check if the encryption is contained in the
public bulletin board. Helios is thus not receipt-free.

To our knowledge, Civitas [21, 37] is the only scheme that
achieves both veriﬁability and coercion-resistance, without
requiring a great deal of interaction between the ballot box or
the election authorities and the voter (such as [8, 20]). While
the scheme is a foundational work, it seems diﬃcult to use
it in large-scale elections mainly for two reasons. First, the
tally phase requires O(n2) operations where n is the number
of received ballots, which opens the way to denial-of-service
attacks. Second, to achieve coercion-resistance, a voter should
be able to adopt an anti-coercion strategy (in Civitas, a voter
has to lie about her true credential) and then later revote
for her true choice once she is freed from the attacker. We
believe that this scenario is unrealistic in many cases, as it
requires cryptographic skills and a heavy infrastructure to
realize an untappable channel (e.g. in-person registration).
It is also worth noticing that in most countries revoting
is not allowed, as for example in Australia, France, Spain,
Switzerland and the United Kingdom. The only exceptions we
are aware of are Estonia and the Internet voting pilots for the
parliamentary elections in 2011 and 2013 in Norway. While
this way of thinking might be a cultural aspect inherited
from traditional paper ballot systems, it is foreseeable that
it will take time before countries change their electoral rules
in order to adopt a revote policy.
1.1 Our Contributions

Building upon a recent variant of Helios, called Belenios
[22, 30], and a cryptographic primitive called signatures on

1614randomizable ciphertexts [12], we propose a receipt-free ver-
sion of Helios, which we call BeleniosRF. In our scheme a
voter cannot prove how she voted, even if she is provided
with all the ballot material by the coercer. Interestingly, our
scheme does not demand any strategy of the voter; in partic-
ular, it does not require the active participation of a voter
to deceive a coercer that is asking for a receipt. For example,
a voter does not need to lie or produce fake credentials as in
Civitas, she simply has no way to prove how she voted. This
represents a huge improvement in usability from the voter’s
point of view: all that is required of the voter is to vote.

We show that our scheme BeleniosRF is receipt-free in
a strong sense, meaning that even a dishonest voter using
a voting client that has been tampered with cannot prove
how she voted. We formalize this property, called strong
receipt-freeness (sRF), via a game-based deﬁnition building
on the privacy deﬁnition recently proposed by Bernhard et
al. [9]. We view this formal deﬁnition of receipt-freeness, which
applies to non-interactive ballot casting protocols, as the ﬁrst
contribution of this work. We call it strong receipt-freeness
to emphasize that in non-interactive protocols an attacker
has less room to build a receipt. Indeed, in the absence of
interaction the adversary does not obtain information from
the voting server apart from what is displayed on the bulletin
board; hence any receipt must be built by the adversary
locally and before submitting the ballot.

We claim sRF is the ﬁrst game-based receipt-freeness deﬁni-
tion in the literature accounting for a voter that is corrupted
during the voting phase. Additionally, sRF has the merit of
being simple and concise, potentially allowing for simpler
proofs. In doing so we give a new formulation for the receipt-
freeness deﬁnition by Benaloh and Tuinstra [8] and highlight
that receipt-freeness can be achieved without asking the vot-
ers to vote several times and cancel previously submitted
ballots, and without requiring an untappable channel. All we
need to assume is that the attacker is not permanently eaves-
dropping the communication between the voting server and
the voter, an assumption made by all previous constructions
of receipt-free or coercion-resistant voting schemes.

A key ingredient of BeleniosRF is a randomization service, a
role that we assume is played by the voting server, but which
could be played by a diﬀerent server. The randomization
service is in charge of re-randomizing the ballot cast by a
voter. BeleniosRF’s receipt-freeness then relies on the fact
that the randomness contained in the ballot displayed in
the bulletin board is not under the control of the voter.
Both the voter and the randomization service contribute
to the randomness of the voter’s ballot as displayed on the
bulletin board. In fact, in light of the impossibility result
of [19], the existence of a randomization agent is assumed
in most constructions that claim to be receipt-free. Here
however, we do not rely on letting voters vote multiple times
or on the existence of a trusted token for each voter (such as
e.g. [20, 34, 35, 43]).

The foremost challenge in achieving receipt-freeness non-
interactively and via a randomization service is to prevent
the latter from changing the voter’s intent. The only existing
non-interactive proposal [12] claiming receipt-freeness uses a
powerful cryptographic primitive called signatures on ran-
domizable ciphertexts. It consists of a signature scheme and a
public-key encryption scheme that is randomizable (that is,
given a ciphertext, anyone can create a fresh ciphertext of the
same plaintext—without knowing it). The primitive provides

an additional functionality: given a signature on a ciphertext,
anyone can randomize the ciphertext and adapt the signature
to the new ciphertext, that is, produce a signature that is
valid on the new ciphertext—and all that knowing neither the
decryption key nor the signing key nor the plaintext. On the
other hand, unforgeability guarantees that it is infeasible to
compute a signature on a ciphertext that encrypts a message
of which no encryption has been signed.

Alas, Blazy et al. [12] did not provide a receipt-freeness
deﬁnition nor a proof. By exhibiting a ballot-copying at-
tack adapted from [24], we demonstrate that their scheme
is not receipt-free, worse, it is not even ballot-private. Our
scheme ﬁxes the Blazy et al. construction by binding the ci-
phertexts to voters, while still inheriting the randomizability
from Groth-Sahai non-interactive proofs [32].

We start with giving a new instantiation of signatures on
randomizable ciphertexts, which we show yields an RCCA-
secure public-key encryption scheme [16], from which we build
a non-interactive1 receipt-free e-voting scheme as follows:

• As in Belenios, each voter is provided with a signature
key pair, in addition to authentication means to the
ballot box (typically a login and password).

• Each voter encrypts and signs their ballot and includes

a proof of knowledge to prevent ballot malleability.

• Upon receiving a ballot, the server re-randomizes the
ballot and adapts the corresponding signature and proof
before publishing it.

Receipt-freeness comes from the fact that a voter no longer
has control over, nor knowledge of, the randomness used to
form the ﬁnal ballot stored in the ballot box. On the other
hand, even after the voting server re-randomizes the ballot
cast by the voter’s voting device, the voter can still verify
that her legitimate ballot is present, as the re-randomized
ciphertext comes with a signature that is valid under the
voter’s veriﬁcation key. By unforgeability of the signature
primitive, the vote cannot have been altered by the ballot
box, which we show implies veriﬁability.

Our ﬁnal contribution consists of assessing the feasibility of
BeleniosRF; for this purpose we implemented and measured
the eﬃciency of a Javascript voting client (see Section 5).
1.2 Related Work

Our deﬁnition requires that an adversary cannot distin-
guish whether a voter votes for either a or b, even if the
attacker provides the voter in advance with all the crypto-
graphic material (such as randomness to be used to cast
the ballot). Interestingly, this deﬁnition does not require the
voter to follow a “strategy” to fool the coercer.

The early deﬁnitions of receipt-freeness [8, 43] introduced
the idea that an attacker should not be able to distinguish be-
tween a real transcript and a fake one, but their descriptions
are rather informal. A weaker deﬁnition of receipt-freeness,
proposed in [15, 38], lets the attacker only interact with the
voter after the election (in particular, the attacker cannot
control the randomness of the voter’s device). A simulation-
based deﬁnition for receipt-freeness (UC-RF) was given in [42].
It assumes however that the voters adopt an “anti-coercion
strategy” and is therefore closer to coercion-resistance as de-
ﬁned in [37], even if it does not cover, for instance, abstention

1After successful authentication between the voter and the
ballot box, ballot casting is non-interactive.

1615attacks. Since BeleniosRF does not require any anti-coercion
strategy from the voters, and game-based security deﬁnitions
are known to be easier to work with, we opted not to use
UC-RF to analyze the receipt-freeness of our new protocol.
The coercion-resistance and receipt-freeness deﬁnitions in [40]
also assume a strategy from the voter. Our deﬁnition can be
seen as a formalization of one of the other possible strategies
sketched in the paper.

Similarly, the symbolic deﬁnition of receipt-freeness in [26]
also requires the voter to adopt a strategy to fool the ad-
versary. Other deﬁnitions in symbolic models aim at charac-
terizing the notion of a receipt [14, 33, 36] but (as usual in
symbolic models) they are much more abstract than standard
computational models.

Previous receipt-free schemes. The scheme by Kiayias
et al. [38] only achieves receipt-freeness for honest voters, as
discussed above. Other well-known and deployed schemes
include Prˆet-`a-voter [44] and Scantegrity [18]. These sys-
tems however are designed for elections with physical voting
booths. The system used in Estonia [46] and the one de-
ployed in Norway [5, 29] might possibly satisfy some level of
receipt-freeness, as the corresponding ballot boxes are not
publicly available. But because of this, they do not achieve
universal veriﬁability (in contrast to BeleniosRF). Kulyk et
al. [39] propose an extension of Helios where voters may later
cancel their vote, still being indistinguishable from null votes
submitted by the crowd. In addition to being diﬃcult to
deploy in practice, this scheme strongly relies on revoting.
Hirt’s scheme [34] heavily depends on the existence of un-
tappable channels. Selene [45] proposes an enhancement for
receipt-free schemes, applicable to BeleniosRF, to ease the
veriﬁcation step made by voters through tracking numbers.
BeleniosRF can be seen as realizing receipt-freeness under
the assumption that the voting server, which is in charge of
running the ballot box, can be trusted to re-randomize ballots
and not reveal the randomness used for that procedure. In
contrast, Helios [41] and [38] achieve receipt-freeness under
the assumption that the voting client is not going to reveal
the randomness it used for sealing the vote. The latter seems
diﬃcult to ensure in practice, unless voters are provided with
secure hardware tokens. In contrast, BeleniosRF only needs
the voting server to be protected against randomness leakage.
BeleniosRF has one disadvantage compared to Helios and
Belenios: if the registrar and the voting server collude, they
can undetectably change a voter’s choice. This is due to the
features that guarantee receipt-freeness, namely that signa-
tures on diﬀerent ciphertexts encrypting the same message
cannot be linked, and that the registrar generates the voters’
signing keys (and thus can vote on their behalf). This can be
prevented by deﬁning a less powerful registrar that simply
grants voting rights to signing keys that are generated by the
voters themselves (cf. Section 4.3). This solution diﬀers from
the Belenios approach, where voters receive their signing
keys from the registrar for the sake of usability. This is just
another manifestation of the usual tension between usability,
privacy and veriﬁability in e-voting systems (and computer
security systems in general), in the sense that increasing one
of them entails a decrease of at least one of the others.

2. RECEIPT-FREENESS

We now formally deﬁne receipt-freeness and start by pro-

viding the syntax of a voting system, inspired by [9, 22].

2.1 Syntax of a Voting System

Election systems typically involve several entities. For the
sake of simplicity we consider each entity to consist of only one
individual but note that all of them could be thresholdized.
1. Election administrator : denoted by E, is responsible for
setting up the election; it publishes the identities id
of eligible voters, the list of candidates and the result
function ρ of the election (typically counting the number
of votes received by every candidate).

2. Registrar : denoted by R, is responsible for distributing
secret credentials to voters and registering the corre-
sponding public credentials.

3. Trustee: denoted by T , is in charge of tallying and

publishing a ﬁnal result.

4. Voters: the eligible voters are denoted by id1, . . . , idτ .
5. Ballot-box (voting server) manager : denoted by B, is
responsible for processing and storing valid ballots in
the ballot box BB, and for publishing PBB, the public
view of BB, also called (public) bulletin board.

The following syntax considers single-pass schemes, that is,
systems where voters only have to post a single message to the
board, i.e. ballot casting is non-interactive. A voting protocol
V = (Setup, Register, Vote, Valid, Append, Publish, VerifyVote,
Tally, Verify) is relative to a family of result functions {ρτ}τ≥1
for τ ∈ N, with ρτ : Vτ → R, where V is the set of admissible
votes and R is the result space.

Setup(1λ), on input a security parameter 1λ, outputs an
election public/secret key pair (pk, sk), where pk could
contain a list of credentials L. We let pk be an implicit
input of the remaining algorithms.

Register(id), on input an identiﬁer id, outputs the secret
part of the credential uskid and its public credential
upkid, which is added to the list L = {upkid}.
Vote(id, upk, usk, v) is run by voter id with credentials upk,
usk to cast her vote v ∈ V. It outputs a ballot b, which
is sent to the voting server (possibly through an au-
thenticated channel).

Valid(BB, b) takes as input the ballot box BB and a ballot b
and checks the validity of the latter. It returns (cid:62) for
valid ballots and ⊥ for invalid ones (e.g. ill-formed, con-
taining duplicated ciphertext from the ballot box. . . ).

Append(BB, b) updates BB with the ballot b. Typically, this
consists in adding b as a new entry to BB, but more
involved actions might be possible (as in our scheme).

Publish(BB) outputs the public view PBB of BB. Often one

simply has Publish(BB) = BB.

VerifyVote(PBB, id, upk, usk, b) is run by voters for checking
that their ballots will be included in the tally. On inputs
the public board PBB, a ballot b, and the voter’s identity
and credentials id, usk, upk, it returns (cid:62) or ⊥.

Tally(BB, sk) on inputs the ballot box BB and the secret
key sk, outputs the tally r and a proof of correct tabu-
lation Π. If the election is declared invalid then r := ⊥.
Verify(PBB, r, Π), on inputs the public bulletin board PBB
and (r, Π), checks whether Π is a valid proof of correct
tallying for r. If so, it returns (cid:62), and ⊥ otherwise.

1616The exact implementation of these algorithms depends
on the concrete voting protocol. In particular, the notion
of public and private credentials of a voter varies a lot. For
example upkid might be simply the identity of the voter or
may correspond to her signature-veriﬁcation key.
2.2 Strong Receipt-Freeness

Intuitively, privacy ensures that an adversary cannot learn
the vote of an honest voter. Receipt-freeness furthermore
guarantees that a voter cannot prove how she voted, even if
she willingly provides information to, or follows instructions
by, the adversary. This captures the seminal intuition from
Benaloh and Tuinstra [8]. The latter insisted that a reasonably
private electronic voting protocol should emulate traditional
voting in a voting booth: it should allow voters to conceal
their individual votes and, at the same time, prevent them
from revealing their vote. Voters should not be able to give
away the privacy of their vote granted by the voting protocol,
even if they are willing to.

Building upon a deﬁnition of privacy recently introduced [9],
we argue that this requirement can be formalized for single-
pass schemes by simply providing the adversary with an
additional oracle OreceiptLR, which allows him to submit his
own ballots on behalf of a dishonest voter. Apart from im-
mediately implying ballot privacy, this simple formalization
captures several important scenarios:

• A voter who wants to convince a vote buyer of how
she voted may prepare her ballot in an arbitrary way
that allows him to construct a convincing receipt (e.g.,
consider a voter that uses biased random coins to build
her ballot and to prove how she voted [28]).

• A voter that might have been corrupted before the
ballot casting phase may just follow the instructions
given to her by the adversary (as in [37]).

• A voter can record, but also forge, its interaction with

the ballot box (as in [8]).

As in previous formal or intuitive deﬁnitions of receipt-
freeness, we assume the adversary is not monitoring the
interaction between the voter and the voting server. However,
the voter can record this interaction, and later on present this
information (or any transformation thereof) to the adversary.
Formally, we consider two games, Game 0 and Game 1,
deﬁned by the oracles in Figure 1. In both games BB0 and BB1
are ballot boxes that start out empty. Box BB0 corresponds to
the real election (that will be tallied) and BB1 is a fake ballot
box which the adversary’s task is to distinguish from BB0.
In Game β the adversary has indirect access to BBβ, that
is, she can see the public part of that box at any time. The
game Expsrf,βA,V provides an adversary A access to the oracles
deﬁned in Figure 1, which intuitively proceed as follows:
Oinit generates secret and public keys for the election; the
public key is returned to the adversary. If β = 1, it
also returns auxiliary information aux to be used by a
simulator SimProof introduced below.

Oreg, on input an identiﬁer id, initializes id’s credentials
(upk, usk) by running Register(id). It gives upk to the
adversary.

Ocorrupt is used by the attacker to obtain the credentials

(upk, usk) of a registered voter.

OvoteLR, a left-or-right oracle, takes two potential votes
(v0, v1) for an honest user id, produces ballots b0 and
b1 for these votes and places them in the ballot boxes
(one in BB0 and one in BB1), provided that v0, v1 ∈ V.
Ocast allows the adversary to cast a ballot b on behalf of
any party. If the ballot is valid with respect to BBβ, it
is placed in both ballot boxes.

OreceiptLR allows an adversarial voter id to cast a ballot b1
in BB1 and a ballot b0 in BB0. If each ballot b0, b1 is
valid with respect to its respective ballot box, then the
ballots are appended by running Append(BB0, b0) and
Append(BB1, b1). This allows the adversary to encode
special instructions in the ballots that could later serve
as the basis for a vote receipt (e.g. as in [28]).

Oboard models the adversary’s ability to see the publishable

part of the board. It returns Publish(BBβ).

Otally allows the adversary to see the result of the elec-
tion. In both games the result is obtained by tallying
a valid BB0; the proof of correct tabulation is however
simulated in the second world, i.e., for β = 1.

We demand that the adversary ﬁrst calls Oinit, then oracles
Oreg,OcorruptU,OvoteLR,Ocast,OreceiptLR,Oboard in any
order, and any number of times. Finally, A can call Otally;
after it receives its reply, A must return a guess of the bit β.
The guess bit is the result returned by the game.

Inherited from ballot privacy [9], Deﬁnition 1 uses simula-
tors SimSetup and SimProof to model the fact that the proof
should not reveal anything, as it is “zero-knowledge”.

D e f i n i t i o n 1

( s R F ) . Let V = (Setup, Register, Vote,
Valid, Append, VerifyVote, Publish, Tally, Verify) be a voting pro-
tocol for a set ID of voter identities and a result function ρ.
We say that V has strong receipt-freeness if there exist algo-
rithms SimSetup and SimProof such that no eﬃcient adver-
sary can distinguish between games Expsrf,0B,V (λ) and Expsrf,1B,V (λ)
deﬁned by the oracles in Figure 1; that is, for any eﬃcient
algorithm A the following is negligible in λ:

(cid:12)(cid:12) Pr(cid:2)Expsrf,0A,V (λ) = 1(cid:3) − Pr(cid:2)Expsrf,1A,V (λ) = 1(cid:3)(cid:12)(cid:12) .

In protocols with non-interactive ballot casting an adver-
sary does not receive any output from its interaction with
the ballot box (apart from the public view of the protocol
run), the sRF adversary must therefore build a receipt using
local data only, and before casting the ballot. An adversary
might encode arbitrary instructions in bβ, for instance mak-
ing those instructions dependent on the vote vβ; e.g. he could
set the least signiﬁcant bit of bβ equal to vβ ∈ {0, 1}. Intu-
itively, strong receipt-freeness implies that a ballot b0 could
be replaced by a ballot b1, both submitted via the oracle
OreceiptLR, without the adversary noticing. Thus a receipt,
i.e. a proof for a certain vote having been cast, cannot exist
as OreceiptLR captures all what a RF adversary can do.

This deﬁnition does not assume that the voter is capable of
successfully applying some anti-coercion strategy (in contrast
to [42]). We believe this to be important in practice for two
reasons. First, this is of course much easier to use: with our
deﬁnition, the system is receipt-free by construction and there
is no need to instruct voters how they should proceed to lie
about their vote. Second, we need not assume that revoting
is allowed (our deﬁnition accommodates any revoting policy
though, including no revote). This is important since most
countries forbid revoting.

1617Oinit for β = 0
(pk, sk) ← Setup(1k)
return pk
Oreg(id)

Oinit for β = 1
(pk, sk, aux) ← SimSetup(1k)
return pk

If id was not previously queried,
then run Register(id) and set
U = U ∪ {(id, upkid, uskid)};
return upkid.

OcorruptU(id)

On a registered voter id, output (upkid, uskid)
and set CU = CU ∪ {(id, upkid)}.

Ocast(id, b)

If Valid(BBβ , b) = ⊥ then return ⊥.
Else Append(BB0, b) and Append(BB1, b).

OvoteLR(id, v0, v1)

If v0 /∈ V or v1 /∈ V then return ⊥.
b0 = Vote(id, upkid, uskid, v0)
b1 = Vote(id, upkid, uskid, v1).
Append(BB0, b0); Append(BB1, b1)

OreceiptLR(id, b0, b1)

If id /∈ CU return ⊥.
If Valid(BB0, b0) = ⊥ or Valid(BB1, b1) = ⊥
return ⊥.
Else Append(BB0, b0) and Append(BB1, b1)

Oboard()

Return Publish(BBβ )

Otally() for β = 0
(r, Π) ← Tally(BB0, sk)
return (r, Π)

Otally() for β = 1
(r, Π) ← Tally(BB0, sk)
Π(cid:48) ← SimProof aux(BB1, r)
return (r, Π(cid:48))

Figure 1: Oracles deﬁning experiments Expsrf,βA,V (λ) for β = 0, 1. The games diﬀer in the way the tallying oracle creates auxiliary
data, in the board displayed in response to Oboard queries, and the board against which ballots are validated.

As expected, strong receipt-freeness trivially implies BPRIV
privacy [9], since BPRIV equals sRF except that there is no
oracle OreceiptLR.
Helios. Under the RF deﬁnition provided in [38] the He-
lios protocol would be receipt-free. In contrast, under our
deﬁnition Helios is not receipt-free. Indeed, if the adver-
sary is allowed to cast diﬀerent ballots b0, b1 to the ballot
boxes BB0, BB1, respectively, then distinguishing Game 0
from Game 1 is trivial. This is due to the fact that in Helios
PBB contains the encryption of the votes, so it suﬃces for
an adversary to produce diﬀerent encryptions c, d and check
which one is showing up when calling oracle Oboard.

Interestingly, we believe that a Helios instantiation in which
voting devices are built upon trusted hardware tokens that
conceal the randomness used for encryption (as proposed by
Magkos et al. [41]) satisﬁes sRF, when interpreting trusted
tokens as preventing A from accessing the OreceiptLR oracle—
in which case sRF collapses to ballot privacy. This shows the
ﬂexibility of our deﬁnition. Moreover, we are conﬁdent that
the same result applies to [38].

3. BUILDING BLOCKS

Before describing our voting scheme, we ﬁrst present the

necessary cryptographic building blocks.
3.1 Assumptions and Primitives

We will work in asymmetric bilinear groups and assume
the existence of a bilinear-group generator GrpGen, which on
input 1λ outputs (p, G1, G2, g1, g2, GT , e), where p is a prime
of length λ, G1, G2 and GT are cyclic groups of order p, g1 is
a generator of G1, g2 is a generator of G2, and e is a bilinear
map e : G1 × G2 → GT such that e(g1, g2) generates GT . The
following was discussed in [13, p. 304] and deﬁned in [12].

D e f i n i t i o n 2

( C D H+ ) . The CDH+ assumption for
GrpGen holds if for G = (p, G1, G2, g1, g2, GT , e) ←$ GrpGen(1λ),
and for a, b ←$ Zp, for every p.p.t. adversary given (G, ga
2 , gb
1),
the probability that it outputs gab
1

is negligible in λ.

1 , ga

The next assumption implies the security of ElGamal encryp-
tion in both groups G1 and G2:

D e f i n i t i o n 3

( S X D H ) . The Symmetric external
Diﬃe-Hellman assumption (SXDH) holds for GrpGen if for
G = (p, G1, G2, g1, g2, GT , e) ←$ GrpGen(1λ), a, b, c ←$ Zp and
for both i ∈ {1, 2}, p.p.t. adversaries only distinguish (G, ga
i , gb
i ,
i ) from (G, ga
gab

i ) with advantage negligible in λ.

i , gb

i , gc

ElGamal Encryption. We deﬁne encryption for messages
in G1 from an asymmetric bilinear group G = (p, G1, G2, g1,
g2, GT , e) and show that it is randomizable.
KeyGen(G, i): Choose d ←$ Zp and deﬁne P := gd

1 . Return

(pk = P, dk = d).

Encrypt(P, M ; r): Using randomness r ∈ Zp, output c =

(c1 = gr

1, c2 = M · P r).

Decrypt(d, c = (c1, c2)): Output M = c2 · c
Random(P, c = (c1, c2); r(cid:48)): Using randomness r(cid:48) ∈ Zp, out-

−d
1 .

put c(cid:48) = (c1 · gr(cid:48)

1 , c2 · P r(cid:48)

).

This scheme is IND-CPA secure assuming hardness of DDH in
G1, which follows from SXDH. It is perfectly randomizable as
Random(pk, Encrypt(pk, M ; r); r(cid:48)) = Encrypt(pk, M ; r + r(cid:48)).

Groth-Sahai Proofs. Groth-Sahai (GS) proofs [32] allow
us to prove satisﬁability of equations involving group ele-
ments from G1 or G2 and scalars. We will use them to prove
consistency and knowledge of encryptions. On input a bilinear
group G, Setupg s outputs a common reference string (CRS)
crs ∈ G4
2. The CRS is used to commit to group elements
X ∈ G1, which we denote by C1(X), and elements Y ∈ G2,
denoted by C2(Y ). Moreover, C(cid:48)
i(x) denotes a commitment
to a scalar, which can be made in G1 (i = 1) and G2 (i = 2).
The GS system lets us prove that committed values satisfy
certain equations.

1 × G4

Under a CRS computed via Setupg s, commitments are
perfectly binding and the proofs are perfectly sound. That

1618is, the values uniquely determined by the commitments sat-
isfy the proved equation. Moreover, the committed values
can be extracted using an extraction trapdoor ξ that can
be computed together with the CRS. We denote this by
(crs, ξ) ←$ Setup(x)

g s (G).

There is an alternative CRS-generation algorithm Setup(h)
g s ,
which outputs (crs(cid:48), td). Commitments made under crs(cid:48) con-
tain no information about the committed value and the
trapdoor td allows simulation of proofs. As CRSs output by
Setupg s and Setup(h)
g s are indistinguishable under SXDH, GS
proofs are computationally zero-knowledge. Moreover, GS
proofs are randomizable [27], that is, given commitments and
proofs, one can (without knowing the witness) create a fresh
set of commitments and proofs.
3.2 Signatures on Randomizable Ciphertexts
The primitive introduced by Blazy et al. [12] consists of
the following algorithms: Setup, on input the security param-
eter 1λ, outputs the parameters (such as the bilinear group);
SKeyGen outputs a pair of signing key and veriﬁcation key
(sk, vk), EKeyGen outputs a pair of encryption and decryp-
tion key (pk, dk). SKeyGen together with Sign and Verify
constitutes a signature scheme and EKeyGen with Encrypt
and Decrypt a public-key encryption scheme.

As the signature and the encryption scheme are used to-
gether, these algorithms have extensions Sign+ and Verify+,
which additionally take the encryption key pk as input; and
Encrypt+, Decrypt+, which also take the veriﬁcation key vk.

Randomizability. The main feature of signatures on ran-
domizable ciphertexts (SRC) is an algorithm Random+, which
takes pk, vk, a ciphertext c under pk and a signature σ on
c valid under vk, and outputs a re-randomization c(cid:48) of c
together with a signature σ(cid:48), valid on c(cid:48).

An output of Random+ is distributed like a fresh encryp-
tion of the plaintext of c and a fresh signature on it; for-
mally, for all messages m, (pk, dk) ∈ [EKeyGen(G)], (vk, sk) ∈
[SKeyGen(G)], c ∈ [Encrypt+(pk, vk, m)], σ ∈ [Sign+(sk, pk, c)],
the following two random variables are equally distributed:

(cid:104)

(cid:48)

(cid:48)

, σ

(c

) ←$ Random+(pk, vk, c, σ) : (c

(cid:105)
(cid:20) c(cid:48) ←$ Encrypt+(pk, vk, m);

, σ

)

(cid:48)

(cid:48)

σ(cid:48) ←$ Sign+(sk, pk, c(cid:48))

≈

(cid:21)

)

.

(cid:48)

(cid:48)

, σ

: (c

Unforgeability. Unforgeability of signatures on random-
izable ciphertext is deﬁned via the following experiment:
The challenger computes a signature key pair and an en-
cryption key pair (sk, vk), (dk, pk) and runs the adversary on
(vk, pk, dk). It is also given access to an oracle Sign+(sk, pk,·),
which it can query adaptively on ciphertexts c1, . . . , cq of its
choice. Finally, the adversary outputs a pair (c∗, σ∗) and wins
if Verify+(vk, pk, c∗, σ∗) = 1 and m = Decrypt+(dk, vk, c∗) is
diﬀerent from all mi := Decrypt+(dk, vk, ci).
3.3 Our SRC Construction

At a high level, we need a construction that enforces our
restricted message space and is malleable enough to be re-
randomized but no more. The ﬁrst requirement ensures that
voters can only submit valid ballots, while the second gives
us privacy via randomization while preventing copying or
tampering attacks. Speciﬁcally, we use GS proofs to ensure
validity and prevent copying or producing ballots related to

those of another user. We use signatures to ensure integrity,
meaning a randomizer cannot change the ballot contents.

Asymmetric Waters signature scheme. Blazy et al. [12]
deﬁne a variant of Waters’ signature scheme [47] for asym-
metric groups that is perfectly randomizable and which they
prove secure under the CDH+ assumption.
Setup(1λ, 1k): To sign messages m = (m1, . . . , mk) ∈ {0, 1}k,
generate (p, G1, G2, g1, g2, GT , e) ←$ GrpGen(1λ), choose
, deﬁne F(m) :=
z ←$ G1, u = (u0, . . . , uk) ←$ Gk+1
. Output pp := (p, G1, G2, GT , e, g1, g2, z, u).
u0
1 , X2 = gx
2 ,
Y = zx; output the public key vk = (pp, X1, X2) and
the secret key sk = (pp, Y ).

SKeyGen(pp): Choose x ←$ Zp, deﬁne X1 = gx

(cid:81)k

i=1 umi

Sign(sk = (pp, Y ), m; s): For randomness s ∈ Zp, return the

1

i

signature σ deﬁned as

(cid:0)σ1 = Y · F (m)s, σ2 = gs

1, σ3 = gs
2

(cid:1) .

Verif(vk = (pp, X1, X2), m, σ): Output 1 if both of the

following hold and 0 otherwise:
e(σ1, g2) = e(z, X2) · e(F(m), σ3)

e(σ2, g2) = e(g1, σ3)
Random((pp, X1, X2), F, σ; s(cid:48)): For randomness s(cid:48) ∈ Zp, out-

put σ(cid:48) = (σ1 · F s(cid:48)

, σ2 · gs(cid:48)

1 , σ3 · gs(cid:48)
2 ).

Note that for Random it suﬃces to know the hash F = F(m)
of the signed message. The scheme is perfectly randomiz-
able, as for any ((pp, X1, X2), (pp, Y )) ∈ [SKeyGen(pp)] and
m, s, s(cid:48) we have Random((X1, X2),F(m), Sign(Y, m; s), s(cid:48)) =
Sign(Y, m; s + s(cid:48)).

R e m a r k 1. Blazy et al. [12] show that their signature
scheme also satisﬁes a (stronger) EUF-CMA notion, where
the adversary’s signing queries are of the form (m, R, T ) and
if e(T, g2) = e(R, X2) then the oracle returns an additional
signature element σ4 = Rs.

We will combine ElGamal encryption, Groth-Sahai proofs
and Waters signatures to create an SRC scheme. Our con-
struction extends that of [12], so that it immediately yields
an RCCA-secure encryption scheme (deﬁned below) and
ultimately a strongly receipt-free e-voting scheme.

Our SRC scheme. Our scheme is deﬁned for a polynomial-
size message space M = {0, 1}k, that is, we assume k to
be logarithmic in the security parameter. Messages m are
encrypted as ElGamal ciphertexts of F(m). Decryption works
by decrypting a ciphertext to F and then looking for m with
F = F(m). We deﬁne a function H and add a third ciphertext
element c3 = H(vk)r, which will tie the ciphertext to the
veriﬁcation key for which it is produced.

We moreover add Cm, Groth-Sahai commitments to the
message bits, and a commitment CT to X r
1 , which is needed
for the security reduction (it corresponds to T from Re-
mark 1). Finally, we add GS proofs which show consistency
of these commitments, and consistency of the additional
ciphertext element c3. In more detail, in order to show a com-
ponent Cmi of Cm contains a bit, we require commitments
in both groups (C1,m,i, C2,m,i) and proofs π(cid:48)
i. A commitment
Cr to the randomness r is used to prove consistency of the
values c1 with Cr, c2 with Cr and {Cm,i}k
i=1, c3 with Cr, as
well as CT with X1 and Cr.

1619Now, given ciphertext elements c1 = gr

1 and c2 = F(m)·P r,
the crucial observation is that, due to the interoperability
of ElGamal encryption and Waters signatures, a signer can
produce an encryption of a signature on the plaintext, without
knowing the latter: setting σ1 = cs
2 =
Y · F(m)s · P rs yields an encryption under P of the ﬁrst
Waters signature element Y · F(m)s. This is completed to
a full signature by (gs
2). Finally, in order to enable full
randomization of ciphertext/signature pairs, we also include
P s in the signature.

1 and σ2 = Y · cs

1 = grs

1, gs

Let Setup (for Waters signatures), Setupg s (for Groth-Sahai
proofs) and KeyGen (for ElGamal encryption) be deﬁned as
above, and H : {0, 1}(cid:63) → G1 be deﬁned as

H(x) := h1 · hH(cid:48)(vk)
for h = (h1, h2) ∈ G2
1 and a collision-resistant hash function
H(cid:48) : {0, 1}(cid:63) → Zp. Our scheme is given in Figure 2. It is
based on the scheme from [12], to which we add the crucial
ciphertext elements c3 and πV .

(1)

2

Correctness follows, as Verify+ checks, via the pairings, that
σ is of the form in (2) for some s. From a ciphertext/signature
pair (c, σ) with randomness (r, s), Random+ creates a fresh
pair (c(cid:48), σ(cid:48)) with randomness r + r(cid:48), s + s(cid:48) (and with random-
ized proofs). We omit the speciﬁc structure of the proofs in
π as they will not be relevant to the rest of this work.

T h e o r e m 1. The SRC scheme (Setup, EKeyGen, SKeyGen,

Encrypt+, Decrypt+, Sign+, Verify+, Random+) deﬁned in Fig-
ure 2 is unforgeable under the CDH+ assumption.

R e m a r k 2. We will prove a stronger statement, namely
that our SRC scheme is unforgeable even when the adversary
only needs to output a “partial” forgery (c1, c2,{C1,m,i, C2,m,i},
Cr, πr, πm), (σ1, σ2, σ3, σ4), i.e., it need not contain c3, CT , πT ,
πV and σ5.

Moreover, note that one can also decrypt ciphertexts using
the extraction trapdoor ξ for GS proofs to recover m from Cm,
sidestepping the ineﬃcient hash inversion. We let EKeyGen(x)
denote key generation that returns ξ instead of dk.

P ro o f . The proof is by reduction from unforgeability of
Waters signatures. The reduction obtains a veriﬁcation key
vk including parameters pp. It simulates EKeyGen by run-
ning (crs, ξ) ←$ Setup(x)
g s (G), (P, d) ←$ KeyGen(G, 1) and choos-
ing h ←$ G2
1, and runs the adversary on vk, pk := (pp, crs, h, P )
and dk := d. If the adversary queries a signature on a valid
tuple c = (c1, c2, c3, C, π), the reduction uses ξ to extract m
and T = X r
1 from C (note that by soundness of π, we have
m = Decrypt+(dk, vk, c)). The reduction makes a special
query, as deﬁned in Remark 1, (m, c1, T ) to its signing oracle
(note that c1, T satisfy e(T, g2) = e(c1, X2)); it obtains a
signature (τ1 = Y F(m)s, τ2 = gs
1); it de-
ﬁnes (letting r be the unknown randomness in (c1, c2, c3))
4 = Y F(m)sP rs, σ3 := τ2 = gs
σ1 := τ4 = grs
1,
2 = P s, which is distributed as an
σ4 := τ3 = gs
SCR signature on c.
Let {m1, . . . , mq} be the extracted (equivalently: decrypted)
messages of the signing queries. Assume the adversary out-
puts a (partial) valid forgery, namely one which only contains
(c1, c2, σ1, σ2, σ3, σ4), commitments Cm, Cr and proofs πr, πm.
The reduction extracts m from Cm. Then soundness of πr and
1 and c2 = F(m)P r
πm ensures that for some r we have c1 = gr
(and thus m = Decrypt+(dk, vk, c)).

1 , σ2 := τ1 · τ d
2, σ5 := τ d

1, τ3 = gs

2, τ4 = cs

1 = Y F(m)s, σ∗
−d

Moreover, let s be such that σ4 = gs
2. Since the forgery
is valid, from Verify+ we have: σ1 = grs
(from (3a)), σ2 =
Y F(m)sP rs (from (3b)) and σ3 = gs
1
1 (from (3c)). The re-
1 := σ2 · σ
duction sets σ∗
1 and
2 and returns (m, σ∗). This is a valid Waters
σ∗
3 := σ4 = gs
forgery, as σ∗ is valid for m and m /∈ {m1, . . . , mq} (otherwise
the adversary would not have won the SRC unforgeability
game).
3.4 RCCA-Secure Encryption from SRC

2 := σ3 = gs

As a next step towards our voting protocol, we show that
our SRC scheme, contrary to the one from [12], yields an
RCCA-secure [16] encryption scheme, as deﬁned next.

CCA-security is the standard notion for public-key encryp-
tion and implies that ciphertexts are non-malleable. It states
that for an eﬃcient adversary which after choosing m0, m1
receives c∗ it should be impossible to decide whether c∗ en-
crypts m0 or m1, even when given an oracle that decrypts
any ciphertext c (cid:54)= c∗. For randomizable schemes this notion
is unachievable, as the adversary could submit a random-
ization of the challenge ciphertext to the decryption oracle.
The strongest achievable notion for randomizable schemes is
RCCA, where whenever the oracle receives an encryption of
m0 or m1, it returns a special symbol (cid:62).
tion scheme for a polynomial-size message space {0, 1}k.

Based on our SRC scheme we deﬁne the following encryp-

KeyGen is deﬁned as EKeyGen.
Encrypt(pk, m): Run (vk, sk) ←$ SKeyGen(pp);

c ←$ Encrypt+(pk, vk, m); σ ←$ Sign+(sk, pk, c);
return c = (c, σ, vk).

Decrypt(dk, (c, σ, vk)): If Verify+(vk, pk, c, σ) = 1, return

m = Decrypt+(dk, vk, c); else return ⊥.

Random is deﬁned as Random+.

T h e o r e m 2. The above encryption scheme for polynomial-

size message spaces is RCCA-secure under the SXDH and
the CDH+ assumption.

P ro o f S k e t c h . We will give a proof sketch and re-
fer to the full version for a detailed proof. Intuitively, ci-
phertexts hide the message, since under SXDH we could
replace the commitments and proofs in the challenge cipher-
text by simulated ones and under DDH, we could replace
c2 = F(m)P r by a random element, so the ciphertext would
contain no more information about the message. The diﬃ-
culty is that we need to simulate the decryption oracle. For
this we program the hash function H: let vk∗ be the key
contained in the challenge ciphertext; we choose a, b ←$ Zp
and set h1 = P −a·H(cid:48)(vk∗) · gb
1 and h2 = P a, which is dis-
tributed correctly and set H(vk) = P a(H(cid:48)(vk)−H(cid:48)(vk∗)) · gb
1.
For a well-formed ciphertext containing vki (cid:54)= vk∗, we then
have c2 · (c3 · c
−d
1 =
Decrypt(d, (c1, c2)), meaning we can use c3 to decrypt with-
out knowing d; for the challenge ciphertext under vk∗ we
have c3 = gbr
The reduction can thus answer decryption queries contain-
ing some vk (cid:54)= vk∗, but not if it contains vk∗. However, if
an adversary submits a valid ciphertext with vk∗ which does
not encrypt the challenge message, then it would break SRC
unforgeability, so security of our SRC scheme implies that
the adversary cannot make this type of query.

1 )−1/(a(H(cid:48)(vk)−H(cid:48)(vk∗))) = c2 · P −r = c2 · c
−b

1 , so we can embed a DDH challenge.

1620EKeyGen(1λ, 1k):

pp := (G, z, u) ←$ Setup(1λ, 1k); crs ←$ Setupg s (G); h ←$ G2
(P, dk) ←$ KeyGen(G, 1); return pk := (pp, crs, h, P ), dk.

1

Encrypt+((pp, crs, h, P ), vk = (pp, X1, X2), m; r):

Compute, with H deﬁned by h as in (1):

c1 = gr
1

c2 = F (m) · P r

c3 = H(vk)r

Make commitments C: For i = 1, . . . , k:

C1,m,i = C(cid:48)

1(mi)
CT = C1(X r
1 )

C2,m,i = C(cid:48)
Cr = C(cid:48)

2(mi)
2(r)

Compute GS proofs π for the following (with r being the
value committed in Cr; mi in C2,m,i; and w in CT ):

• πr proves gr
• πm consists of:

1 = c1.

π(cid:48)
i proving mi is a bit for all i;
π(cid:48)
i=1 umi
m proving c2 = u0

i

· P r.

(cid:81)k

• πT proves X r
• πV proves H(vk)r = c3.
Return c := (c1, c2, c3, C, π).

1 = w.

Sign+(sk = (pp, Y ), (pp, crs, h, P ), c; s):

If π is not valid for C, vk, P , return ⊥. Else return

σ1 = cs
1
σ3 = gs
1

σ2 = Y · cs
σ4 = gs
2

2

(2)

σ5 = P s

Random+(vk, (pp, crs, h, P ), c, σ; (r(cid:48), s(cid:48))):

Let c = (c1, c2, c3, C, π); set:

1

(cid:48) := c1 · gr(cid:48)
(cid:48) := c3 · H(vk)r(cid:48)
(cid:48) := σ1 · cs(cid:48)
1 · σr(cid:48)
(cid:48) := σ2 · cs(cid:48)
2 · σr(cid:48)
(cid:48) := σ3 · gs(cid:48)
(cid:48) := σ5 · P s(cid:48)

1

c1

c3

σ1

σ2

σ3

σ5

1

3 · gr(cid:48)·s(cid:48)
5 · P r(cid:48)·s(cid:48)
σ4

(cid:48) := c2 · P r(cid:48)

c2

(cid:48) := σ4 · gs(cid:48)

2

r = Cr · C2(r(cid:48)), adapt πr, πT , πV accordingly.

Set C(cid:48)
Randomize all commitments and proofs to C(cid:48) and π(cid:48).
Return (c(cid:48)

3, C(cid:48), π(cid:48)) and σ(cid:48).

1, c(cid:48)

2, c(cid:48)

Verify+((pp, X1, X2), (pp, crs, h, P ), (c1, c2, c3, C, π), σ):

Return 1 iﬀ π veriﬁes and the following hold:

e(σ1, g2) = e(c1, σ4)
e(σ2, g2) = e(z, X2) e(c2, σ4)
e(σ3, g2) = e(g1, σ4)

e(σ5, g2) = e(P, σ4)

(3a)

(3b)

(3c)

Decrypt+(dk, (pp, crs, h, P ), vk, c):

Let c = (c1, c2, c3, C, π). If π is not valid, return ⊥;
else let F = Decrypt(dk, c = (c1, c2));
browse M and return the ﬁrst m with F (m) = F .

Figure 2: Our SRC scheme

4. BELENIOSRF

In this section we deﬁne Belenios Receipt-Free (BeleniosRF),
a strongly receipt-free voting protocol that builds on [12, 22].

4.1 Overview

The election public/secret key pair (pk, sk) is an encryp-
tion/extraction key pair generated via EKeyGen(x) (cf. Re-
mark 2), and user key pairs (upk, usk) are signature keys
generated by SKeyGen. A user casts a vote by encrypting it
via Encrypt+ under pk w.r.t. his upk, and uses usk to then
sign the ciphertext via Sign+ (together, this corresponds to
a ciphertext of our RCCA encryption scheme).

When the ballot box receives a valid ballot, it randomizes it
via Random+ and publishes the resulting ciphertext/signature
pair on the public bulletin board PBB. Users can verify that
their vote is present, since they can verify the adaptation of
their signature on their now-randomized ciphertexts.

Tallying follows standard techniques of e-voting: our con-
struction allows for homomorphic tallying as well as shuﬄing.
In the ﬁrst case, we take advantage of the special structure of
GS commitments, which allow us to calculate a partial tally
for each option by adding the corresponding commitment
across voters, and then decrypting the resulting commitment
(with proof of correctness).

Using shuﬄing, the encrypted votes are re-randomized and
shuﬄed (and a proof of correct execution of this is generated)
via an algorithm Shuﬄe. Then the ballots are decrypted
(again accompanied with a proof that this was done correctly)
and the result is published. These proofs make the tallying
process publicly veriﬁable.

We now describe the homomorphic tallying version, where

V = {0, 1}k, and the result function is simple vector addition.
The scheme V BeleniosRF is based on the SCR scheme from

Section 3.3 and consists of the following algorithms:
Setup(1λ, 1k): Compute (pk, sk) ←$ EKeyGen(x)(1λ, 1k), pro-
duce a Fiat-Shamir random oracle proof Πσ that crs, con-
tained in pk, is binding. Return (pk∗ = (pk, Πσ), sk).
Register(id): On (implicit) input pk = (pp, crs, h, P ), return
(upkid, uskid) ←$ SKeyGen(pp).
Vote (id, upk, usk, v) is used by a voter to create a ballot b
for vote v ∈ V. It computes c ← Encrypt+(pk, upk, v) and
σ ← Sign+(usk, pk, c); and returns b = (id, upk, c, σ).
Valid(BB, b) ﬁrst checks that the ballot b is valid, i.e., that
it is well-formed and the signature is correct. Formally, it
parses b as (id, upk, c, σ) and checks if

– id corresponds to an eligible voter from ID and upk

corresponds to the registration of user id;

– Verify+(upk, pk, c, σ) = 1.

If any step fails, it returns ⊥; otherwise, it returns (cid:62).
Append(BB, b = (id, upk, c, σ)) randomizes (c, σ) as (c(cid:48), σ(cid:48)) ←
Random+(upk, pk, c, σ) and appends to BB a randomized
version b(cid:48) = (id, upk, c(cid:48), σ(cid:48)) of b.
Publish(BB) takes every entry b = (id, upk, c, σ) in BB and
removes elements id, c3, CT , πT , πV and σ5, constructing ˆb :=

(cid:0)upk, (c1, c2, Cm, Cr, πr, πm), (σ1, σ2, σ3, σ4)(cid:1). It then adds ˆb

to PBB,2 and returns PBB.
2As noted in Remark 2, these are precisely the elements
that guarantee unforgeability, which assures a voter that the
plaintext of his encrypted vote was not altered.

1621VerifyVote(PBB, id, upk, usk, b) browses PBB for an entry ˆb
containing upk. If none exists, it returns ⊥. For entry ˆb :=

(cid:0)upk = (pp, X1, X2), (c1, c2, Cm, Cr, πr, πm), (σ1, σ2, σ3, σ4)(cid:1)

if πr and πm are valid and

e(σ1, g2) = e(c1, σ4)
e(σ3, g2) = e(g1, σ4)

e(σ2, g2) = e(z, X2) · e(c2, σ4)

then return (cid:62), else return ⊥.
Tally(BB, sk) consists of the following steps. Let N be the
number of ballots.

– Parse each ballot b ∈ BB as b = (id(b), upk(b), c(b), σ(b)).
– If there is any ballot b that does not pass Valid(BB, b),

output (r = ⊥, PBB, Πd = ∅).

– Let {C (b)

1,m,i}k

in c(b). Compute Ti =(cid:80)

i=1 be the commitments in C (b)

m contained
1,m,i. The tally ti for
candidate i is produced by decrypting Ti with the GS
extraction key ξ = sk.

b∈BB C (b)

– Produce the result r = (t1, . . . , tk) and Πd, a Fiat-

Shamir proof of correct extraction.

– Output (r, PBB, Πd).

Verify(PBB, r, Πσ, Πd) veriﬁes Πσ w.r.t. crs and Πd w.r.t.
PBB and the result r.
4.2 Receipt-Freeness

We now show that BeleniosRF satisﬁes strong receipt-
freeness, as deﬁned in Deﬁnition 1. Note that this in particular
implies vote privacy of BeleniosRF.

T h e o r e m 3. V BeleniosRF is strongly receipt-free under the

SXDH assumption in the random-oracle model.

P ro o f . The proof uses the ideas of that of Theorem 2.
The main one is again to use hash-function programmability
and to decrypt a ciphertext (c1, c2, c3) using components
c2 and c3 instead of the GS commitments. This will allow
us to switch to a hiding CRS, for which the commitments
would not be extractable. By randomizability of our SCR
scheme and of Groth-Sahai proofs, instead of re-randomizing
the ballots in PBB, we can simply recompute them. Finally,
having switched to a hiding CRS and a simulated ROM
proof thereof, we are able to replace the adversary’s view
with uniformly distributed values, irrespective of β.

We proceed by a sequence of hybrid games, which we show

are indistinguishable:
Hybrid (β,0) is the sRF game Expsrf,βA,V (Deﬁnition 1 and
Figure 1).

Hybrid (β,1) is the same game as Hybrid (β,0) for β = 1;
for β = 0 the diﬀerence is that the Fiat-Shamir proofs for
the CRS and the tally are simulated.
Hybrid (β,0) → Hybrid (β,1): Since ROM proofs can be
perfectly simulated by using random-oracle programmability,
the two hybrid games are distributed equivalently.

Hybrid (β,2) is deﬁned as Hybrid (β,1), except for how h
is chosen. For a, b ←$ Zp we deﬁne h1 = gb
1 and h2 = P a (as
in Theorem 2 but setting H(cid:48)(vk∗) := 0).
Hybrid (β,1) → Hybrid (β,2): It is immediate that both
games are distributed equivalently.

Hybrid (β,3) is deﬁned as Hybrid (β,2), but the result is
computed diﬀerently: each ballot bi = (idi, upki, ci, σi) is
decrypted as Fi = ci,2 · (ci,3 · c
−b
i,1 )−1/(a·upki) and vote vi is
deﬁned as the smallest vi ∈ {0, 1}k satisfying F(vi) = Fi.

The result is r = (t1, . . . , tk) with tj =(cid:80)

Hybrid (β,2) → Hybrid (β,3): Perfect soundness of the GS
proofs contained in ci guarantees that this alternative way
of decryption leads to the same result as extracting the bits
of vi from the commitments (we ignore collisions in F which
only occur with negligible probability).

i vi,j.

Hybrid (β,4) is deﬁned as Hybrid (β,3), except that PBB is
computed diﬀerently: for ballot bi, after extracting vi, instead
of re-randomizing bi, we freshly compute ˆbi for user i with
uski = (pp, Yi) as follows: we pick ri, si ←$ Zp to set
σi,1 = csi
1
σi,4 = gsi
2

πi,r, πi,m. We set ˆbi =(cid:0)upki, (ci,1, ci,2, Ci,m, Ci,r, πi,r, πi,m),
(σi,1, σi,2, σi,3, σi,4)(cid:1).

and using witnesses ri and vi, we compute Ci,m, Ci,r and

ci,2 = F(vi) · P ri
σi,3 = gsi
1

ci,1 = gri
1
σi,2 = Yi · csi

2

Hybrid (β,3) → Hybrid (β,4): By re-randomizability of our
SCR scheme and GS proofs, re-randomized ciphertexts, signa-
tures and proofs are distributed exactly as freshly computed
ones. The two hybrids are thus equally distributed.

Hybrid (β,5) is deﬁned as Hybrid (β,4), except that the
CRS contained in pk is set up in hiding mode, i.e., computed
via Setup(h)
g s .
Hybrid (β,4) → Hybrid (β,5): By the properties of GS proofs,
the two hybrids are indistinguishable under the SXDH as-
sumption.

Hybrid (β,6) is deﬁned as Hybrid (β,5), except that the
commitments and proofs published in PBB are simulated.
Hybrid (β,5) → Hybrid (β,6): By the properties of GS proofs,
under a hiding CRS regularly computed proofs and simulated
proofs are distributed equivalently; the two hybrids are thus
equally distributed.

1

for wi ←$ Zp.

Hybrid (β,7) is deﬁned as Hybrid (β,6), except that for
every i, when computing PBB entry ˆbi, ci,2 is computed as
ci,2 = F(vi) · gwi
Hybrid (β,6) → Hybrid (β,7): The two hybrids are indistin-
guishable under the DDH assumption in G1, which is proved
as follows: we ﬁrst note that in Hybrid (β,6), d (the decryp-
tion key with P = gd
1 ) is not used anywhere, and ri is only
used to compute ci,1 and ci,2 (since the GS commitments
and proofs are simulated).

1 , R = gr

We give a reduction from DDH to distinguishing Hybrids 6
and 7. Let (P = gd
1, W ) be a DDH instance, where ei-
ther W is random or W = gd·r
1 . By random self-reducibility of
DDH [6] we can create arbitrarily many instances (P, Ri, Wi),
where Ri = gri
for some uniformly random ri, and Wi is
1
independently random if W was, or Wi = gd·ri
if W = gd·r
1 .
The simulator now sets pk = (pp, crs, P ), with P from the
instance, and ci,1 = Ri and ci,2 = F(vi) · Wi. If Wi = P ri
then this is distributed as in Hybrid (β,6), whereas if Wi is
random, this is distributed as in Hybrid (β,7).

1

Observe that Hybrid (0,7) and Hybrid (1,7) are equally dis-
tributed, since in both games every ciphertext (ci,1, ci,2) is a

1622uniformly random pair. We have thus constructed a sequence
of hybrid games Hybrid (0,0), . . . , Hybrid (0,7), Hybrid (1,7),
. . . , Hybrid (1,0) which are indistinguishable under SXDH
and of which the ﬁrst one corresponds to the sRF game
with β = 0 and the last is the sRF game with β = 1. This
concludes the proof of strong receipt-freeness.

R e m a r k 3. We note that our scheme can be easily mod-
iﬁed and proven secure in the standard model if we assume a
trusted CRS: drop Πσ in Setup and use GS proofs fro Πd.
4.3 Veriﬁability

We consider strong veriﬁability from [22], which intuitively

ensures that the result of the election reﬂects the votes of:
• All voters who properly checked that their ballot ap-
pears in the bulletin board at the end of the election.
In BeleniosRF, a voter should check that one ballot in
PBB is signed with her credential.

• A subset of the voters who did not perform that ﬁnal
check. A voters may stop after casting her vote, thus
there is no guarantee that her ballot made it into the
ballot box. However, if the ballot is present, it should
not be possible to modify the corresponding vote.

• At most all corrupted voters. In particular, an adversary
should not be able to add more votes than the number
of voters he controls.

We refer the reader to [22] for the formal deﬁnition and point
out that strong veriﬁability assumes that voting devices are
honest. We ﬁrst note that BeleniosRF cannot be strongly
veriﬁable if revoting is allowed. Indeed, if a voter ﬁrst casts
a ballot b1 for a candidate v1, but later changes her mind
and votes for v2, casting a new ballot b2, a malicious voting
server may force the voter to keep the initial vote v1 by
re-randomizing b1 instead of b2, and the voter would not be
able to detect it. Therefore, in what follows, we assume that
a no-revote policy is applied. We believe that no-revoting is
not a real restriction since, as discussed in the introduction,
this actually corresponds to the most common setting used
in practice. By slightly generalizing the strong-veriﬁability
transformation in [22, Section 4], we are able to show:

T h e o r e m 4. BeleniosRF is strongly veriﬁable if the un-
derlying signature on randomizable ciphertexts scheme is
unforgeable.

The transformation to strong veriﬁability in [22] consists
in the voter signing with her private signing key usk a bal-
lot b obtained via an existing voting protocol that is weakly
veriﬁable (roughly speaking, weak veriﬁability assumes that
the voting server is honest, e.g., it does not modify nor erase
ballots). Next, the voter sends the triple (upk, b, σ) to the
voting server. The latter, after validating the ballot b and
verifying its signature σ, adds the triple (upk, b, σ) to the
ballot box. At the end of the election, the voter checks that
her ballot (upk, b, σ) appears in PBB by a simple search.
We generalize this transformation by allowing the voting
server to add a transformed triple (upk, b(cid:48), σ(cid:48)) to the ballot
box on input the voter’s ballot (upk, b, σ), such that poten-
tially b (cid:54)= b(cid:48) and σ (cid:54)= σ(cid:48) (in the original construction, one
simply sets b(cid:48) = b and σ(cid:48) = σ). In our generalized transfor-
mation, the voter on input her cast ballot (upk, b, σ) checks
whether there exists an entry (upk, b(cid:48), σ(cid:48)) in PBB such that

(b(cid:48), σ(cid:48)) veriﬁes under her key upk. Due to unforgeability of
randomizable signatures on ciphertexts (cf. Section 3.3) and
because of the no-revoting policy, this check guarantees that
the new ballot b(cid:48) displayed in the bulletin board contains the
same vote as the original ballot b cast by the voter.

Strong veriﬁability assumes that either the ballot box (i.e.
the re-randomization server) or the registrar is honest. As
pointed out in Section 1.2, the security of the generalized
transformation described in the previous paragraph is jeopar-
dized if this trust assumption is violated, as the existence of
an entry (upk, b(cid:48), σ(cid:48)) in PBB would no longer guarantee that
b(cid:48) contains the choice cast by the voter. In fact, an attacker
controlling both the registrar and the voting server can insert
entries (upk, b(cid:48), σ(cid:48)) in PBB that pass all tests but modiﬁed
the voter’s choice. This is due to the fact that the registrar
knows each voter’s private signing key. An obvious counter-
measure is to let each voter generate their own signing key
pair and simply ask the registrar to include the corresponding
veriﬁcation key in the list of eligible keys for the election.

Alternatively, one can thresholdize the role of the registrar
(who simply sends a private signing key to each voter) so it
becomes less likely for the attacker to obtain a voter’s private
key.

5. EFFICIENCY OF BE L E N I O SRF

The ballot encryption scheme we introduced is somewhat
involved, especially since we use bit-by-bit Groth-Sahai proofs.
For this reason, we benchmarked ballot creation on a number
of potential client devices. We built a JavaScript implementa-
tion [2] of the voting process (encrypt, sign, prove) using the
CertiVox IoT Crypto Library [17]. We used a BN curve on a
254-bit prime ﬁeld. We considered the values k = 1, 5, 10 and
25. For homomorphic tallying, as used in Section 4, k repre-
sents the number of candidates in an election. If we switch to
shuﬄe-based tallying, k is the length of the message, which
means we can support up to 2k candidates.

As seen in Table 1, recent devices can complete the required
cryptographic operations in reasonable time for small values
of k. We see that while the linear cost associated with the
message size is the dominant factor, the constant factor is not
negligible for low-end devices. While slower than the current
Helios or Belenios implementation (which do not use elliptic
curves), performance is acceptable, especially for modern de-
vices. Moreover, our implementation is single-threaded with
only rudimentary optimizations. By constructing proofs in-
crementally as the ballot is ﬁlled, we could amortize the linear
part of the cost. Alternatively, we may increase performance
by coding a native client, e.g. a smartphone app.

We expect that server performance for BeleniosRF will be
less of a bottleneck. Compared to Helios, the main additional

Device

2013 Laptop –i7-4650U
2010 Desktop –i3-530
2014 Tablet –Exynos 5420
2016 Phone –SD 810
2014 Phone –SD 801
2012 Phone –A6

k = 1
1.00s
1.49s
6.97s
2.75s
5.55s
9.04s

k = 5
2.43s
3.46s
12.91s
6.26s
13.12s
18.65s

k = 10
4.02s
5.92s
21.92s
10.39s
22.70s
29.96s

k = 25
9.24s
13.62s
47.26s
22.19s
48.06s
63.77s

Table 1: Time to encrypt, sign and perform GS proofs
for ballots with a k-bit payload. This allows for up to k
candidates with homomorphic tallying, or 2k using shuﬄes.

1623pk, σvk,s

c

, πt,v ∈ {0,1}

pk

(cid:1) ,

cost is verifying our Groth-Sahai proofs, which is dominated
by ca. 64(k + 1) pairings, reducible to 4(k + 35) using tech-
niques from [11] and [31]. Given the timings provided by
Beuchat et al. [10], we expect a throughput of roughly 5
ballots/second/core for k = 10. Additionally, checks can be
amortized throughout the voting period, as ballots come in.

6. THE BLAZY ET AL. VOTING PROTO-

COL IS NOT BALLOT-PRIVATE

Blazy et al. [12], who introduced the notion of signatures
on randomizable ciphertexts, proposed to use this primitive
for a receipt-free e-voting protocol. Their ballot-creation and
-casting protocol workﬂow is as follows:
• The voter sends ballot

b =(cid:0)vk, c = {v}r

where r, s, t ∈ Zp denote the randomness used for encrypting
the vote v, signing the resulting ciphertext c and creating
the NIZK proof π, respectively.
• The server re-randomizes the ballot b to b(cid:48) as follows:

(cid:1), where r(cid:48), s(cid:48), t(cid:48) ←$ Zp.

(cid:0)vk, c = {v}r(cid:48)

, πt(cid:48),v ∈ {0,1}

pk, σvk,s(cid:48)

c

pk

Similarly to BeleniosRF, the server can only re-randomize
legitimate signatures, meaning that any new ballot b(cid:48) that
contains a valid signature w.r.t. vk must originate from a
ballot b that has been previously created by the voter, and
thus b and b(cid:48) contain the same vote.
An attack on ballot privacy. However, the above ballot
casting workﬂow is not ballot private, let alone receipt-free.
The following is a ballot replay attack, which is known to
break ballot privacy [23]:

• Honest voter sends b =(cid:0)vk, c = {v}r

, πt,v ∈ {0,1}

(cid:1).

pk, σvk,s

c

pk

• Server re-randomizes the ballot b as

b(cid:48) =(cid:0)vk, c = {v}r(cid:48)

pk, σvk,s(cid:48)

c

, πt(cid:48),v ∈ {0,1}

pk

(cid:1)

and displays it on the public bulletin board.

• Dishonest voter with credentials ( ¯vk, ¯sk) and knowledge
of target ballot b(cid:48)

– Copies c = {v}r(cid:48)

pk, πt(cid:48),v ∈{0,1}

¯c = {v}¯r

pk, π

pk
¯t,v ∈ {0,1}
;
pk

– Signs ¯c with ¯sk yielding σ

– Sends ballot ¯b =(cid:0)vk, ¯c = {v}¯r

¯vk,¯s
¯c

;

(cid:1) .

¯t,v ∈ {0,1}
pk

, ¯π

¯vk,¯s
pk, σ
¯c

Moreover, our deﬁnition builds on the recent work [9], in-
heriting a simple, concise, and game-based deﬁnition. Such
deﬁnitions are well-known for easing the job of conceiving
and writing security proofs; a point we conﬁrm by giving a
new e-voting protocol that satisﬁes our deﬁnition in bilinear
groups under the SXDH assumption in pairing groups, in
the random oracle model. The protocol is built using ideas
from a previous work [12] that claimed to have solved this
problem. We show however that the previous voting scheme
was not ballot-private, which is weaker than receipt-freeness.
To the best of our knowledge, this is the ﬁrst scheme that
is both receipt-free (in a strong sense) and has universal
veriﬁability (in the sense of strong veriﬁability [22]), without
requiring the existence of an untappable channel, or the use
of secure hardware tokens. We only require that the receipt-
freeness adversary is not eavesdropping the communication
between the voter and the voting server, and the existence
of a re-randomization service. As a result, we overcome the
impossibility result [19], stating no scheme can be receipt-free
and universally veriﬁable without an untappable channel. We
achieve this by relying on a ballot box server that is entrusted
to re-randomize ballots without changing its contents, in a
publicly veriﬁable way [12]. Finally, we showed the feasibility
of our approach by implementing a voting client in Javascript
and measuring its performance in a number of platforms.

Acknowledgements. The authors are grateful to the anony-
mous reviewers for their comments and suggestions that have
helped improve this work. This work has received funding
from the European Research Council (ERC) under the EU’s
Horizon 2020 research and innovation program (grant agree-
ment No 645865-SPOOC), the ERC FP7 programme (grant
No 307937), EPSRC grant EP/G037264/1 and COST Action
IC1306.

8. REFERENCES
[1] International Association for Cryptologic Research,

elections. Page at http://www.iacr.org/elections/.

[2] BeleniosRF –Voting Client Core. https://gist.github.

com/pyrros/4fddd7d49ae7c9c935f5d6a9a27d14c3, 2016.

[3] B. Adida. Helios: Web-based Open-Audit Voting. In

USENIX 2008, 2008. http://heliosvoting.org.

Quisquater. Electing a university president using
open-audit voting: Analysis of real-world use of Helios.
In EVT/WOTE 2009, 2009.

[5] J. P. Allepuz and S. G. Castell´o. Internet voting system

with cast as intended veriﬁcation. In VoteID 2011.
Springer, 2011.

[6] M. Bellare, A. Boldyreva, and S. Micali. Public-key

encryption in a multi-user setting: Security proofs and
improvements. In EUROCRYPT 2000. Springer, 2000.
[7] J. Benaloh. Ballot casting assurance via voter-initiated

poll station auditing. In EVT/WOTE 2007, 2007.

[8] J. C. Benaloh and D. Tuinstra. Receipt-free

secret-ballot elections (extended abstract). In ACM
STOC 94. ACM Press, 1994.

[9] D. Bernhard, V. Cortier, D. Galindo, O. Pereira, and

B. Warinschi. A comprehensive analysis of game-based
ballot privacy deﬁnitions. In IEEE Security and
Privacy 2015. IEEE Computer Society, 2015.

[10] J.-L. Beuchat, J. E. Gonz´alez-D´ıaz, S. Mitsunari,

E. Okamoto, F. Rodr´ıguez-Henr´ıquez, and T. Teruya.

and re-randomizes it to

[4] B. Adida, O. de Marneﬀe, O. Pereira, and J.-J.

These instructions allow any voter with knowledge of a
ballot b to produce an independent-looking ballot ¯b, that
will be accepted by the voting server and eﬀectively contains
a copy of the vote in b. Thus, the voting protocol [12] is
not ballot-private. (Note that due to re-randomizing being
allowed, the ballot box cannot discard copied votes, as they
look like legitimate ones.)

7. CONCLUSIONS

We introduced the notion of strong receipt-freeness, where
a malicious voter (i.e. vote-selling or coerced) cannot produce
a receipt proving how she voted, whether the voter decided
to act maliciously before, during or after casting the ballot.

Our adversarial model is close to the spirit of the sem-
inal work on receipt-freeness by Benaloh and Tuinstra [8].

1624High-speed software implementation of the optimal ate
pairing over barreto–naehrig curves. In Pairing-Based
Cryptography 2010. Springer, 2010.

[11] O. Blazy, G. Fuchsbauer, M. Izabachene, A. Jambert,

H. Sibert, and D. Vergnaud. Batch groth–sahai. In
ACNS 2010. Springer, 2010.

[12] O. Blazy, G. Fuchsbauer, D. Pointcheval, and

D. Vergnaud. Signatures on randomizable ciphertexts.
In PKC 2011. Springer, 2011.

[13] D. Boneh, B. Lynn, and H. Shacham. Short signatures

from the Weil pairing. Journal of Cryptology, 17(4),
2004.

[14] K. Br¨aunlich and R. Grimm. Formalization of

receipt-freeness in the context of electronic voting. In
Availability, Reliability and Security 2011. IEEE
Computer Society, 2011.

[15] R. Canetti and R. Gennaro. Incoercible multiparty

computation (extended abstract). In FOCS ’96. IEEE
Computer Society, 1996.

[16] R. Canetti, H. Krawczyk, and J. B. Nielsen. Relaxing

chosen-ciphertext security. In CRYPTO 2003. Springer,
2003.

[17] CertiVox. A Cryptographic Library for the Internet of

Things. https://github.com/CertiVox/MiotCL, 2015.

[18] D. Chaum, A. Essex, R. Carback, J. Clark,

S. Popoveniuc, A. Sherman, and P. Vora. Scantegrity:
end-to-end voter-veriﬁable optical-scan voting. IEEE
Security and Privacy, 6(3), 2008.

[19] B. Chevallier-Mames, P. Fouque, D. Pointcheval,

J. Stern, and J. Traor´e. On some incompatible
properties of voting schemes. In EVT/WOTE, 2010.

[20] S. S. M. Chow, J. K. Liu, and D. S. Wong. Robust
receipt-free election system with ballot secrecy and
veriﬁability. In Network and Distributed System
Security Symposium 2008. The Internet Society, 2008.
[21] M. R. Clarkson, S. Chong, and A. C. Myers. Civitas:
Toward a secure voting system. In IEEE Security and
Privacy 2008. IEEE Computer Society, 2008.

[22] V. Cortier, D. Galindo, S. Glondu, and M. Izabach`ene.

Election veriﬁability for Helios under weaker trust
assumptions. In ESORICS 2014. Springer, 2014.

[23] V. Cortier and B. Smyth. Attacking and ﬁxing Helios:
An analysis of ballot secrecy. In CSF 2011. IEEE, 2011.
[24] V. Cortier and B. Smyth. Attacking and ﬁxing Helios:

An analysis of ballot secrecy. Journal of Computer
Security, 21(1), 2013.

Veriﬁable online voting system.
http://belenios.gforge.inria.fr, 2015.

[31] A. Gonz´alez, A. Hevia, and C. R`afols. Qa-nizk

arguments in asymmetric groups: new tools and new
constructions. In ASIACRYPT 2015. Springer, 2015.
[32] J. Groth and A. Sahai. Eﬃcient non-interactive proof

systems for bilinear groups. In EUROCRYPT 2008.
Springer, 2008.

[33] J. Heather and S. Schneider. A formal framework for
modelling coercion resistance and receipt freeness. In
Formal Methods 2012. Springer, 2012.

[34] M. Hirt. Receipt-free K -out-of-L voting based on

ElGamal encryption. In EVT/WOTE 2010. Springer,
2010.

[35] M. Hirt and K. Sako. Eﬃcient receipt-free voting based

on homomorphic encryption. In EUROCRYPT 2000.
Springer, 2000.

[36] H. L. Jonker and E. P. de Vink. Formalising

receipt-freeness. In Information Security 2006. Springer,
2006.

[37] A. Juels, D. Catalano, and M. Jakobsson.

Coercion-resistant electronic elections. In Workshop on
Privacy in the Electronic Society 2005. ACM, 2005.
[38] A. Kiayias, T. Zacharias, and B. Zhang. End-to-end

veriﬁable elections in the standard model. In
EUROCRYPT 2015. Springer, 2015.

[39] O. Kulyk, V. Teague, and M. Volkamer. Extending

Helios towards private eligibility veriﬁability. In
E-Voting and Identity 2015. Springer, 2015.

[40] R. K¨usters and T. Truderung. An epistemic approach
to coercion-resistance for electronic voting protocols. In
S&P 2009. IEEE Computer Society, 2009.

[41] E. Magkos, M. Burmester, and V. Chrissikopoulos.

Receipt-freeness in large-scale elections without
untappable channels. In E-Commerce, E-Business,
E-Government 2001. Kluwer, 2001.

[42] T. Moran and M. Naor. Receipt-free

universally-veriﬁable voting with everlasting privacy. In
CRYPTO 2006. Springer, 2006.

[43] T. Okamoto. Receipt-free electronic voting schemes for
large scale elections. In Security Protocols 97. Springer,
1997.

[44] P. Ryan, D. Bismark, J. Heather, S. Schneider, and
Z. Xia. The Prˆet `a Voter veriﬁable election system.
IEEE Transactions on Information Forensics and
Security, 4, 2009.

[25] R. Cramer, R. Gennaro, and B. Schoenmakers. A

[45] P. Y. A. Ryan, P. B. Roenne, and V. Iovino. Selene:

secure and optimally eﬃcient multi-authority election
scheme. In EUROCRYPT’97. Springer, 1997.

[26] S. Delaune, S. Kremer, and M. Ryan.

Coercion-resistance and receipt-freeness in electronic
voting. In CSFW 2006. IEEE Computer Society, 2006.
[27] G. Fuchsbauer and D. Pointcheval. Proofs on encrypted

values in bilinear groups and an application to
anonymity of signatures. In Pairing-Based
Cryptography–Pairing 2009. Springer, 2009.

[28] R. W. Gardner, S. Garera, and A. D. Rubin. Coercion
resistant end-to-end voting. In FC 2009. Springer, 2009.

[29] K. Gjøsteen. The Norwegian internet voting protocol.

IACR Cryptology ePrint Archive, 2013, 2013.

[30] S. Glondu, V. Cortier, and P. Gaudry. Belenios –

Voting with transparent veriﬁability and
coercion-mitigation. Cryptology ePrint Archive, Report
2015/1105, 2015. http://eprint.iacr.org/.

[46] D. Springall, T. Finkenauer, Z. Durumeric, J. Kitcat,

H. Hursti, M. MacAlpine, and J. A. Halderman.
Security analysis of the estonian internet voting system.
In ACM CCS 2014. ACM Press, 2014.

[47] B. R. Waters. Eﬃcient identity-based encryption
without random oracles. In EUROCRYPT 2005.
Springer, 2005.

1625