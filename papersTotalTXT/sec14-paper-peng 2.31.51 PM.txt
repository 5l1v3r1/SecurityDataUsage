X-Force: Force-Executing Binary Programs  

for Security Applications

Fei Peng, Zhui Deng, Xiangyu Zhang, and Dongyan Xu, Purdue University; Zhiqiang Lin,  

The University of Texas at Dallas; Zhendong Su, University of California, Davis
https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/peng

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXX-Force: Force-Executing Binary Programs for Security Applications

Fei Peng, Zhui Deng, Xiangyu Zhang, Dongyan Xu

Purdue University

Zhiqiang Lin
UT Dallas

Zhendong Su

UC Davis

zhiqiang.lin@utdallas.edu

su@cs.ucdavis.edu

{pengf, deng14, xyzhang, dxu}@cs.purdue.edu

Abstract
This paper introduces X-Force, a novel binary analysis
engine. Given a potentially malicious binary executable,
X-Force can force the binary to execute requiring no in-
puts or proper environment. It also explores different ex-
ecution paths inside the binary by systematically forc-
ing the branch outcomes of a very small set of condi-
tional control transfer instructions. X-Force features a
crash-free execution model that can detect and recover
from exceptions. In particular, it can ﬁx invalid mem-
ory accesses by allocating memory on-demand and set-
ting the offending pointers to the allocated memory. We
have applied X-Force to three security applications. The
ﬁrst is to construct control ﬂow graphs and call graphs
for stripped binaries. The second is to expose hidden
behaviors of malware, including packed and obfuscated
APT malware. X-Force is able to reveal hidden mali-
cious behaviors that had been missed by manual inspec-
tion. In the third application, X-Force substantially im-
proves analysis coverage in dynamic type reconstruction
for stripped binaries.

1

Introduction

Binary analysis has many security applications. For ex-
ample, given an unknown, potentially malicious exe-
cutable, binary analysis helps construct its human in-
spectable representations such as control ﬂow graph
(CFG) and call graph (CG), with which security analysts
can study its behavior [40, 23, 50, 46, 6, 33]. Binary anal-
ysis also helps identify and patch security vulnerabilities
in COTS binaries [10, 14, 31, 51, 11]. Valuable informa-
tion can be reverse-engineered from executables through
binary analyses. Such information includes network pro-
tocols [44, 12, 7, 47, 28, 32], input formats [27, 29, 13],
variable types, and data structure deﬁnitions [30, 25, 39].
They can support network snifﬁng, exploit generation,
VM introspection, and forensic analysis.

Existing binary analysis can be roughly classiﬁed into
static, dynamic, and symbolic (concolic) analysis. Static
analysis analyzes an executable directly without execut-
ing it; dynamic analysis acquires analysis results by exe-
cuting the subject binary; symbolic (concolic) analysis is
able to generate inputs to explore different paths of a bi-
nary. These different styles of analyses have their respec-
tive strengths and limitations. Static analysis has difﬁ-

culty in handling packed and obfuscated binaries. Mem-
ory disambiguation and indirect jump/call target analysis
are known to be very challenging for static analysis.

Dynamic binary analysis is based on executing the bi-
nary on a set of inputs. It is widely used in analyzing
malware. However, dynamic analysis is incomplete by
nature. The quality of analysis results heavily relies on
coverage of the test inputs. Moreover, modern malware
[16, 26, 19] has become highly sophisticated, posing
many new challenges for binary analysis: (1) For a zero-
day binary malware, we typically do not have any knowl-
edge about it, especially the nature of its input, making
traditional execution-based analysis [15, 50, 4, 43, 49]
difﬁcult; (2) Malware binaries are increasingly equipped
with anti-analysis logic [37, 5, 17, 18, 35] and hence may
refuse to run even if given valid input; (3) Malware bi-
naries may contain multi-staged, condition-guarded, and
environment-speciﬁc malicious payloads, making it dif-
ﬁcult to reveal all payloads, even if one manages to exe-
cute them.

Symbolic [8] and concolic analysis [38, 20, 40, 10]
has seen much progress in recent years. Some handle
binary programs [40, 10, 33, 6] and can explore various
paths in a binary. However, difﬁculties exist when scal-
ing them to complex, real-world binaries, as they oper-
ate by modeling individual instructions as symbolic con-
straints and using SMT/SAT solvers to resolve the gen-
erated constraints. Despite recent impressive progress,
SMT/SAT remains expensive. While symbolic and con-
crete executions can be performed simultaneously so that
concrete execution may help when symbolic analysis en-
counters difﬁculties, the user needs to provide concrete
inputs, called seed inputs, and the quality of seed inputs
is critical to the execution paths that can be explored.
With no or little knowledge about malware input, creat-
ing such seed inputs is difﬁcult. Moreover, many existing
techniques cannot handle obfuscated or self-modifying
binaries.

In this paper, we propose a new, practical execution
engine called X-Force. The core enabling technique
behind X-Force is forced execution which, as its name
suggests, forces an arbitrary binary to execute along
different paths without any input or environment setup.
More speciﬁcally, X-Force monitors the execution of a
binary through dynamic binary instrumentation, system-
atically forcing a small set of instructions that may affect
the execution path (e.g., predicates and jump table ac-

USENIX Association  

23rd USENIX Security Symposium  829

cesses) to have speciﬁc values, regardless of their com-
puted values, and supplying random values when inputs
are needed. As such, the concrete program state of the
binary can be systematically explored. For instance, a
packed/obfuscated malware can be forced to unpack/de-
obfuscate itself by setting the branch outcomes of self-
protection checks, which terminate execution in the pres-
ence of debugger or virtual machine. X-Force is able
to tolerate invalid memory accesses by performing on-
demand memory allocations. Furthermore, by exploring
the reachable state of a binary, X-Force is able to explore
different aspects or stages of the binary behavior. For
example, we can expose malware’s data exﬁltration op-
erations, without the presence of the real data asset being
targeted.

Compared to manual inspection and static analysis,
X-Force is more accurate as many difﬁculties for static
analysis, such as handling indirect jumps/calls and ob-
fuscated/packed code, can be substantially mitigated by
the concrete execution of X-Force. Compared to sym-
bolic/concolic analysis, X-Force trades precision slightly
for practicality and extensibility. Note that X-Force may
explore infeasible paths as it forces predicate outcomes;
whereas symbolic analysis attempts to respect path fea-
sibility through constraint solving1. The essence of X-
Force will be discussed later in Section 6. Furthermore,
executions in X-Force are all concrete. Without the need
for modeling and solving constraints, X-Force is more
likely to scale to large programs and long executions.
The concrete execution of X-Force makes it suitable for
analyzing packed and obfuscated binaries. It also makes
it easy to port existing dynamic analysis to X-Force to
leverage the large number of executions, which will mit-
igate the incompleteness of dynamic analyses.

Our main contributions are summarized as follows:
• We propose X-Force, a system that can force a bi-
nary to execute requiring no inputs or any environ-
ment setup.

• We develop a crash-free execution model that could
detect and recover from exceptions properly. We
have also developed various execution path explo-
ration algorithms.

• We have overcome a large number of technical chal-
lenges in making the technique work on real world
binaries including packed and obfuscated malware
binaries.

• We have developed three applications of X-Force.
The ﬁrst is to construct CFG and CG of stripped bi-
naries, featuring high quality indirect jump and call
target identiﬁcation; the second is to study hidden
behavior of advanced malwares; the third one is to

1However, due to the difﬁculty of precisely modeling program be-
havior, even state-of-the-art symbolic analysis techniques [8, 10, 40]
cannot guarantee soundness.

apply X-Force in reverse engineering variable types
and data structure deﬁnitions of executables. Our
results show that X-Force substantially advances the
state-of-the-arts.

2 Motivation Example

Consider the snippet in Figure 1. It shows a hidden mali-
cious payload that hijacks the name resolution for a spe-
ciﬁc domain (line 14), which varies according to the cur-
rent date (in function genName()).
In particular, it re-
ceives some integer input at line 2. If the input satisﬁes
condition C at line 3, a DNSentry object will be allocated.
In lines 5-8, if the input has the CODE RED bit set, it
populates the object by calling genName() and stores the
input and the generated name as a (key, value) pair into a
hash table. In lines 12-14, the pair is retrieved and used
to guide domain name redirection. Note that the hash
table is used as a general storage for objects of various
types. In line 10, an irrelevant object o is also inserted
into the table.

This example illustrates some of the challenges faced
by both static and symbolic/concolic analysis. In static
analysis, it is difﬁcult to determine that the object re-
trieved at line 12 is the one inserted at line 7 because
the abstract domain has to precisely model the behav-
ior of the hash table put/get operations and the con-
dition that y==x, which requires context-sensitive and
path-sensitive analysis, and disambiguating the mem-
ory bucket[i] and bucket[i+4] in table get() and
table put(). The approximations made by many static
analysis techniques often determine the object at line 12
could be the one put at line 7 or 10. Performed solely at
the binary level, such an analysis is actually much more
challenging than described here.
In symbolic/concolic
analysis, one can model the input at line 2 as a symbolic
variable such that, by solving the symbolic constraints
corresponding to path conditions, the hidden payload
might be reached. However, the dictionary read at line 21
will be difﬁcult to handle if the ﬁle is unavailable. Mod-
eling the ﬁle as symbolic often causes scalability issues
if it has nontrivial format and size, because the generated
symbolic constraints are often complex and the search
space for acquiring syntactically correct inputs may be
extremely large.

In X-Force, the binary is ﬁrst executed as usual by pro-
viding random inputs. Note that X-Force does not need
to know the input format a priori as its exception recov-
ery mechanism prevents any crashes/exceptions. In other
words, the supply of random input values is merely to
allow the execution to proceed, not to drive the execu-
tion along different paths.
In the ﬁrst normal run, as-
sume that the false branches of the conditionals at lines
3, 5 and 13 are taken, yielding an uninteresting execu-

830  23rd USENIX Security Symposium 

USENIX Association

Figure 1: Motivating Example.

tion. X-Force will then try to force-set branch outcomes
at a small number (say, 1 or 2) of predicates by perform-
ing systematic search. Assume that the branch outcome
at line 5 is force-set to “true”. The malicious payload
will be forced to activate. Note that pointer p has a null
value at line 6, which will normally crash the execution
at line 22. X-Force tolerates such invalid accesses by al-
locating memory on demand, right before line 22. Also,
even if the dictionary ﬁle at line 21 is absent, X-Force
will force it through by supplying random input values.
As such, some random integer and domain are inserted
into the table (line 7) and retrieved later (line 12). Even-
tually, the random domain name is redirected at line 14,
exposing the DNS hijacking operation. We argue that the
domain name itself is not important as long as the hidden
hijacking logic is exposed.

3 High Level Design

3.1 Forced Execution Semantics
This section explains the basics of how a single forced
execution proceeds. The goal is to have a non-crashable
execution. For readability, we focus on explaining how
to detect and recover from memory errors in this subsec-
tion, and then gradually introduce the other aspects of
forced execution such as path exploration and handling
libraries and threads in later sections.

Program
Stmt

Operator
Expr
Register
Const
Addr
PC

P ::= s
s ::= s1; s2 | nop | r :=(cid:31) e | r :=(cid:31) R(ra) |

W(cid:31)(ra,rv) | jmp(cid:31)((cid:31)1) | if (r(cid:31)) then jmp((cid:31)1) |
jmp(cid:31)(r) | r := malloc(cid:31)(rs) |
free(cid:31)(r) | call(cid:31)((cid:31)1) | call(cid:31)(r) | ret(cid:31)

op ::= + | − | ∗ | / | > | < | ...
e ::= c | a | r1 op r2
r ::= {esp,eax,ebx, ...}
c ::= {true, f alse,0,1,2, ...}
a ::= {0,MIN ADDR,MIN ADDR + 1, ...,MAX ADDR}
(cid:31) ::= {(cid:31)1, (cid:31)2, (cid:31)3, ...}

Language. Due to the complexity of the x86 instruction
set, we introduce a simple low-level language that mod-
els x86 binary executables to facilitate discussion. We
only model a subset that is sufﬁcient to illustrate the key
ideas. Fig. 2 shows the syntax.

Memory reads and writes are modeled by R(ra) and
W(ra, rv) with ra holding the address and rv the value.
Since it is a low-level language, we do not model con-
ditional or loop statements, but rather guarded jumps;
malloc() and free() represent heap allocation and deal-
location. Function invocations and returns are modeled
by call() and ret. In our language, stack/heap memory
addresses are modeled as a range of integers and a special
value 0 to denote the null pointer value. Program coun-
ters (or instruction addresses) are explicitly modeled by
the PC set. Observe that each instruction is labeled with
a PC, denoting its instruction address. Direct jumps/calls
are parameterized with explicit PC values whereas indi-
rect jumps/calls are parameterized with a register.

LSet
SR ∈ RegLinearSet
SM ∈ MemLinearSet
accessible ∈ AddrAccessible

::= P (Addr)
::= Register (cid:25)→ &LSet
::= Addr (cid:25)→ &LSet
::= Addr (cid:25)→ boolean

VS ← VS + {∗(a)}

recovery (r) ::=
1: S ← SM(r)
2: VS ← {}
3: for each address a ∈ S do
4:
5: end for
6: min ← the minimal value in VS
7: max ← the maximum value in VS
8: t ← malloc(max− min + BLOCKSIZE)
9: accessible[t,t + max− min + BLOCKSIZE − 1] = true
10: for each address a ∈ S do
offset ← ∗(a)− min
11:
∗(a) ← t + offset
12:
13: end for

Figure 3: Deﬁnitions.

Figure 2: Language.

In X-Force, we ensure that an execution is not crash-

USENIX Association  

23rd USENIX Security Symposium  831

Table 1: Linear Set Computation Rules.
Rule
L-INIT

Statement
initially

r := R(ra)

W(ra,rv)

r := a
r := c
/*!isAddr(c)*/
r := r1 + /− r2

r := r1 ∗ /... r2
free(r)

Action1,2
foreach (global address t)
if (isAddr(∗t)) SM(t) ={ t};
SR(“r”) → nil;
if(SM(ra)) SR(“r”) → SM(ra);
if (SM(ra)) SM(ra) =SM (ra)−{ra}
SM(ra) → nil;
if (SR(“rv”))
SR(“rv”) =SR (“rv”) ∪ {ra};
SM(ra) → SR(“rv”);
SR(“r”) → {}
SR(“r”) → nil
if (!(isAddr(r1)&&isAddr(r2)))
SR(“r”) → nil
if (isAddr(r1)) SR(“r”) → SR(“r1”);
if (isAddr(r2)) SR(“r”) → SR(“r2”);
SR(“r”) → nil
t = r;
while (accessible(t))
if (SM(t)) SM(t) =SM (t)−{t};
t + +;

L-READ

L-WRITE

L-ADDR
L-CONST

L-LINEAR

L-NON-LNR
L-FREE

1. The occurrence“r” denotes the symbolic name of register r, the
occurrence of r denotes the value stored in r.
2. Operator “=” means set update, “→” means pointer update.
able by allocating memory on-demand. However, when
we replace a pointer pointing to an invalid address a with
the allocated memory, we need to update all the other
pointer variables that have the same address value or a
value denoting an offset from the address. We achieve
this through the linear set tracing semantics, which is
also the basic semantics for forced executions2. Its goal
is to identify the set of variables (i.e. memory locations
and registers at the binary level), whose values have lin-
ear correlations. In this paper, we say two variables are
linearly correlated if the value of one variable is com-
puted from the value of the other variable by adding or
subtracting a value. Note that it is simpler than the tradi-
tional deﬁnition of linear correlation, which also allows
a scaling multiplier. It is however sufﬁcient in this work
as the goal of linear set tracing is to identify correlated
pointer variables, which are induced by address offset-
tings that are exclusively additions and subtractions.

The semantics is presented in Table 1. The corre-
sponding deﬁnitions are presented in Fig 3. Particularly,
linear set LSet denotes a set of addresses such that the
values stored in these addresses are linearly correlated.
Mapping SR maps a register to the reference of a LSet.
Intuitively, one could interpret that it maps a register to
a pointer pointing to a set of addresses such that the val-
ues stored in the register and those addresses are linearly
correlated. Two registers map to the same reference (of a
LSet) implies that the values of the two registers are also
linearly correlated. Similarly, mapping SM maps an ad-
dress to the reference of a LSet such that the values in the
address and all the addresses in LSet are linearly corre-

2We will explain the predicate switching part of the semantics in

Section 3.2

Table 2: Memory Error Prevention and Recovery.

Statement
r := malloc(r1)

free(r)

r := R(ra)

W(ra,rv)

Rule

Action
for (i = r to r + r1 − 1) M-ALLOC
accessible(i) = true
t = r;
M-FREE
while (accessible(t))
accessible(t) = false
t + +;

if (!accessible(ra))

recovery(ra);

if (!accessible(ra))

recovery(ra);

M-READ

M-WRITE

lated. The essence of linear set tracing is to maintain the
SR and SM mappings for all registers and addresses that
have been accessed so that at any execution point, we can
query the set of linearly correlated variables of any given
variable.

Before execution, the SM mapping of all global vari-
ables that have an address value is set to the address it-
self, meaning the variable is only linearly correlated with
itself initially (rule L-INIT). Function isAddr(v) deter-
mines if a value v could be an address. X-Force monitors
all memory allocations and the image loading process.
Thus, given a value, X-Force treats it as a pointer if it
falls into static, heap, or stack memory regions. Note
that we do not need to be sure that the value is indeed
an address. Over-approximations only cause some addi-
tional linear set tracing. For a memory read operation,
the SR mapping of the destination register points to the
SM set of the value in the address register if the SM set
exists, which implies the value is an address, otherwise it
is set to nil (rule L-READ). Note that in the rule we use
“r” to denote the symbolic name of r and ra to denote the
value stored in ra. SR(“r”) → SM(ra) means that we set
SR(“r”) to point to the SM(ra) set. For a memory write,
we ﬁrst eliminate the destination address from its linear
set. Then, the address is added to the linear set of the
value register as the address essentially denotes a new
linearly correlated variable. Finally, the SM mapping of
the address is updated (rule L-WRITE). Note that oper-
ation “=” means set update, which is different from “→”
meaning set reference update. For a simple address as-
signment, the SR set is set to pointing to an empty linear
set, which is different from a nil value (rule L-ADDR).
The empty set is essentially an LSet object that could be
pointed to by multiple registers to denote their linear cor-
relation. A nil value cannot serve this purpose. For a lin-
ear operator, the SR mapping of the destination register
is set to pointing to the SR mapping of the register hold-
ing an address value (rule L-LINEAR). Intuitively, this
is because we are only interested in the linear correla-
tion between address values (for the purpose of memory
error recovery). For heap de-allocation, we have to re-
move each de-allocated address from its linear set (rule
L-FREE).

Table 2 presents the set of memory error detection and

832  23rd USENIX Security Symposium 

USENIX Association

recovery rules. The relevant deﬁnitions are in Fig. 3.
An auxiliary mapping accessible() is introduced to de-
note if an address has been allocated and hence accessi-
ble. The M-ALLOC and M-FREE rules are standard.
Upon reading or writing an un-accessible address, X-
Force calls function recovery () with the register hold-
ing the invalid address to perform recovery. In the func-
tion, we ﬁrst acquire the values of all the variables in the
linear set and identify the minimal and maximum val-
ues (lines 1-6). Note that the values may be different
(through address offsetting operations). We then allocate
a piece of memory on demand according to the range of
the values and a pre-deﬁned default memory block size.
Then in lines 9-12, the variables in the linear set are up-
dated according to their offsets in the block. We want
to point out that on-demand allocation may not allocate
enough space. However, such insufﬁciency will be de-
tected when out-of-bound accesses occur and further on-
demand re-allocation will be performed. We also want
to point out that a correctly developed program would
ﬁrst write to an address before it reads. As such, the on-
demand allocation is often triggered by the ﬁrst write to
an invalid buffer such that the value could be correctly
written and later read. In other words, we do not need to
recover values in the on-demand allocated buffers.

In our real implementation, we also update all the reg-
isters that are linearly correlated, which can be deter-
mined by identifying the registers pointing to the same
set. Furthermore, the rules only describe how we ensure
heap memory safety whereas X-Force protects critical
stack addresses such as return addresses and parameters,
which we will discuss later.
Example. Fig. 4 presents part of a sample execution
with the linear set tracing and memory safety semantics.
The program is from the motivation example (Fig. 1). In
the execution, the else branch of line 3 is taken but the
true branch of line 5 is forced. As such, pointer p has
a null value when it is passed to function genName(),
which would cause an exception at line 22. In Fig. 4,
we focus on the executions of lines 6, 22 and 7. The sec-
ond column shows the binary code (in our simpliﬁed lan-
guage). The third column shows the corresponding linear
set computation and memory exception detection and re-
covery. Initially, SM(&p = 0x8004c0) is set to pointing
to the set {0x8004c0} according to rule L-INIT. At bi-
nary code line 2, SR(eax) is set to pointing to the set of
SM(&p). At line 3, since the value is further copied to
a stack address 0xce0080, eax, &p and the stack address
all point to the same linear set containing &p and the
stack address. Intuitively, these are the three variables
that are linearly correlated. At lines 9 and 10, edi fur-
ther points to the same linear set. At line 12, when the
program tries to access the address denoted by edi = 4,
the memory safety component detects the exception and

performs on demand allocation. According to the lin-
ear set, &p and the stack address 0xce0080 are set to
the newly allocated address 0xd34780 while edi is up-
dated to 0xd34784 according to its offset. While it is not
presented in the table, the program further initializes the
newly allocated data structure. As a result, when pointer
p is later passed to table put(), it points to a valid data
structure. 2

Algorithm 1 Path Exploration Algorithm
Output:

Deﬁnition

Ex - the set of executions (each denoted by a se-
quence of switched predicates) achieving a cer-
tain given goal (e.g. maximum coverage)
switches:
the set of switched predicates in a
forced execution, denoted by a sequence of in-
tegers. For example, 1· 3· 5 means that the 1st,
3rd, and 5th predicates are switched
WL : P (Int) - a set of forced executions, each
denoted by a sequence of switched predicates
preds : Predicate× boolean - the sequence of
executed predicates with their branch outcomes

1: WL ← {nil}
2: Ex ← nil
3: while WL do
4:
5:
6:

switches ← WL.pop()
Ex ← Ex ∪ switches
Execute the program and switch branch outcomes ac-

cording to switches, update ﬁtness functionF

7:
8:
9:
10:
11:

preds ← the sequence of executed predicates
t ← the last integer in switches
preds ← remove the ﬁrst t elements in preds
for each (p,b) ∈ preds do
if eval(F , p,b) then

update ﬁtness functionF
WL ← WL∪ switches·t

12:
13:
14:
15:
end for
16:
17: end while

end if
t ← t + 1

In the early stage of the project, we tried a much sim-
pler strategy that is to terminate a forced execution when
an exception is observed. However, we observed that
since we do not provide any real inputs, exceptions are
very common. Furthermore, simply skipping instruc-
tions that cause exceptions did not work either because
that would have cascading effects on program state cor-
ruption. Finally, a crash-proof execution model as pro-
posed turned out to be the most effective one.

X-Force also automatically recovers from other excep-
tions such as division-by-zero, by skipping those instruc-
tions that cause exceptions. Details are omitted.

USENIX Association  

23rd USENIX Security Symposium  833

Figure 4: Sample Execution for Linear Set Tracing and Memory Safety. The code is from Fig. 1.

3.2 Path Exploration in X-Force
One important functionality of X-Force is the capability
of exploring different execution paths of a given binary
to expose its behavior and acquire complete analysis re-
sults. In this subsection, we explain the path exploration
algorithm and strategies.

To simplify discussion, we ﬁrst assume a binary only
performs control transfer through simple predicates (i.e.
predicates with constant control transfer targets). We will
introduce how to extend the algorithms in realistic set-
tings, e.g., supporting exploration of indirect jumps in
later section.

Algorithm 1 describes a general path exploration algo-
rithm, which generates a pool of forced executions that
are supposed to meet our goal speciﬁed by a conﬁgurable
ﬁtness function. It is a work list algorithm. The work list
stores a list of (forced) executions that may be further
explored by switching more predicates. Each execution
is denoted by a sequence of integer numbers that spec-
ify the executed predicate instances to switch. Note that
X-Force only force-sets the branch outcome of a small
set of predicate instances. It lets the other predicate in-
stances run as usual. Initially (line 1), the work list is
a singleton set with a nil sequence, representing an ex-
ecution without switching any predicate. Note that the
work list is not empty initially. At the end of a forced ex-
ecution, we update the ﬁtness function that indicates the
remaining space to explore (line 6), e.g., coverage. Then
in lines 7-16, we try to determine if it would be of inter-
est to further switch more predicate instances. Lines 7-9
compute the sequence of predicate instances eligible for
switching. Note that it cannot be a predicate before the
last switched predicate speciﬁed in switches as switching
such a predicate may change the control ﬂow such that
the speciﬁcation in switches becomes invalid.
In lines
10-16, for each eligible predicate and its current branch
outcome, we query the ﬁtness function to determine if
we should further switch it to generate a new forced ex-
ecution. If so, we add it to the work list and update the

ﬁtness function. Note that in each new forced execution,
we essentially switch one more predicate.
Different Fitness Functions. The search space of all
possible paths is usually prohibitively large for real-
world binaries. Different applications may deﬁne differ-
ent ﬁtness functions to control the scope they want to ex-
plore. In the following, we introduce three ﬁtness func-
tions that we use. Other more complex functions can be
similarly developed.
• Linear Search.

In certain applications, such as
constructing control ﬂow graphs and dynamic type
reverse engineering (Section 5), the goal may be
just to cover each instruction. The ﬁtness func-
tion F could be deﬁned as a mapping covered :
Predicate × boolean (cid:29)→ boolean that determines
if a branch of a predicate has been covered. The
evaluation in the box in line 11 of Algorithm 1 is
hence deﬁned as !covered(p,¬b), which means we
will switch the predicate if the other branch has not
been covered. Once we decide to switch an addi-
tional predicate, the ﬁtness function is updated to
reﬂect the new coverage (line 12). The number of
executions needed is hence O(n) with n the number
instructions in the binary.

• Quadratic Search. In applications such as identify-
ing indirect call targets, which is a very important
challenge in binary analysis, simply covering all in-
structions may not be sufﬁcient, we may need to
cover paths that may lead to indirect calls or gener-
ate different indirect call targets. We hence deﬁne F
as a set icalls to keep the set of the indirect call sites
and potential indirect call targets that have been dis-
covered by all the explored paths. The evaluation in
line 11 is hence to test if cardinality of icall grows
with the currently explored path. If so, the execu-
tion is considered important and all eligible unique
predicates (not instances) in the execution are fur-
ther explored. The complexity is O(n2) with n the
number of instructions. X-Force can also limit the

834  23rd USENIX Security Symposium 

USENIX Association

quadratic search within a function.

• Exponential Search. If we simply set the evaluation
in the line 12 to true, the algorithm performs ex-
ponential search because it will explore each possi-
ble combination. In practice, we cannot afford such
search. However, X-Force provides the capability
for the user to limit such exponential search within
a sub-range of the binary.

Taint Analysis to Reduce Search Space. An observa-
tion is that we do not have to force-set predicates in low-
level utility methods, because their branch outcomes are
usually not affected by any input. Hence in X-Force, we
use taint analysis to track if a predicate is related to pro-
gram input. X-Force will only force branch outcomes of
those tainted predicates. Since this is a standard tech-
nique, we omit its details.

4 Practical Challenges

In this section, we discuss how we address some promi-
nent challenges in handling real world executables.
Jump Tables.
In our previous discussion, we assume
control transfer is only through simple predicates. In re-
ality, jump tables allow a jump instruction to have more
than two branches. Jump tables are widely used. They
are usually generated from switch statements in the
source code level. In X-Force, we leverage existing jump
table reverse engineering techniques [21] to recover the
jump table for each indirect jump. Our exploration al-
gorithm then tries to explore all possible targets in the
table.
Handling Loops and Recursions. Since X-Force may
corrupt variables, if a loop bound or loop index is cor-
rupted, an (incorrect) inﬁnite loop may result. Similarly,
if X-Force forces the predicate that guards the termina-
tion of some recursive function call, inﬁnite recursion
may result. To handle inﬁnite loops, X-Force leverages
taint analysis to determine if a loop bound or loop in-
dex is computed from input.
If so, it resets the loop
bound/index value to a pre-deﬁned constant. To handle
inﬁnite recursion, X-Force constantly monitors the call
stack.
If the stack becomes too deep, X-Force further
checks if there are cyclic call paths within the call stack.
If cyclic paths are detected, X-Force skips calling into
that function by simulating a ”ret” instruction.
Protecting Stack Memory. Our early discussion on
memory safety focused on protecting heap memory.
However, it is equally important to protect stack memory.
Particularly, the return address of a function invocation
and the stack frame base address of the caller are stored
on stack upon the invocation. They are restored when the
callee returns. Since X-Force may corrupt variable val-
ues that affect stack accesses, such critical data could be

undesirably over-written. We hence need to protect stack
memory as well. However, we cannot simply prevent
any stack write beyond the current frame. The strategy
of X-Force is to prevent any stack writes that originate in
the current stack-frame to go beyond the current frame.
Speciﬁcally, when a stack write attempts to over-write
the return address, the write is skipped. Furthermore,
the instruction is ﬂagged. Any later instances of the in-
struction that access a stack address beyond the current
stack-frame are also skipped. The ﬂags are cleared when
the callee returns.
Handling Library Function Calls. The default strategy
of X-Force is to avoid switching predicates inside library
calls as our interest falls in user code. X-Force handles
the following library functions in some special ways.

• I/O functions. X-Force skips all output calls and
most input calls except ﬁle inputs. X-Force provides
wrappers for ﬁle opens and ﬁle reads. If the ﬁle to
open does not exist, X-Force skips calling the real
ﬁle open and returns a special ﬁle handler. Upon
ﬁle reads, if the ﬁle handler has the special value,
it returns without reading the ﬁle such that the in-
put buffer contains random values. Supporting ﬁle
reads allows X-Force to avoid unnecessary failure
recovery and path exploration if the demanded ﬁles
are available.

• Memory manipulation functions. To support mem-
ory safety, X-Force wraps memory allocation and
de-allocation. For memory copy functions such as
memcpy() and strcpy(), the X-Force wrappers
ﬁrst determine the validity of the copy operation,
e.g., the source and target address ranges must have
been allocated, must not overlap with any critical
stack addresses.
If necessary, on-demand alloca-
tion is performed before calling the real function.
This eliminates the need of memory safety monitor-
ing, linear set tracing, and memory error recovery
inside these functions, which could be quite heavy-
weight due to the special structure of these func-
tions. For example, memcpy() copies individual ad-
dresses one by one and these addresses are linearly
correlated as they are computed through pointer ma-
nipulation, leading to very large linear sets.

For statically linked executables, X-Force relies on IDA-
Pro to recognize library functions in a pre-processing
step. IDA leverages a large signature dictionary to rec-
ognize library functions with very good accuracy. For
functions that are not recognized by IDA, X-Force exe-
cutes them as user code.
Handling Threads. Some programs spawn additional
threads during their execution. It is difﬁcult for X-Force
to model multiple threads into a single execution since
the order of their execution is nondeterministic.
If we

USENIX Association  

23rd USENIX Security Symposium  835

simply skip the thread creation library functions such as
CreateThread() and beginthread(), the functions in the
thread could not be covered. To solve this problem, we
adopt a simple yet effective approach of serializing the
execution of threads. The calls to thread creation library
functions are replaced with direct function calls to the
starting functions of threads, which avoid creating mul-
tiple threads and guarantees code coverage at the same
time. Note that as a result, X-Force is incapable of an-
alyzing behavior that is sensitive to schedules. We will
leave it to our future work.

5 Evaluation

X-Force is implemented in PIN. It supports WIN32 ex-
ecutables. In this section, we use three application case
studies to demonstrate the power of X-Force.

Table 4: Detailed Coverage Comparison with Dynamic Analysis

164.gzip
175.vpr
176.gcc
181.mcf
186.crafty
197.parser
252.eon

253.perlbmk

254.gap
255.vortex
256.bzip2
300.twolf

Input Union X-Force

3601
19398
157451
1622
27811
17339
15580
55964
37564
53798
3612
19996

5075
29218
227546
1935
42763
23135
27224
33643
110066
101207
4830
41935

Input Union
∩ X-Force
3601
19398
157451
1622
27811
17339
15580
27003
37564
53798
3612
19996

Input Union
\ X-Force
0
0
0
0
0
0
0
28961
0
0
0
0

X-Force

\ Input Union
1474
9820
70095
313
14952
5796
11644
6640
72502
47409
1218
21939

5.1 Control Flow Graph (CFG) and Call

Graph (CG) Construction

Construction of CFG and CG is a basic but highly chal-
lenging task for binary analysis, especially the identiﬁ-
cation of indirect call targets. In the ﬁrst case study, we
apply X-Force to construct CFGs and CGs for stripped
SPECINT 2000 binaries. We also evaluate the perfor-
mance of X-Force in this study. To construct CFGs and
CGs, we use X-Force to explore execution paths and
record all the instructions, control ﬂow edges, and call
edges, including indirect jump and indirect call edges.
The exploration algorithm is a combination of linear
search and quadratic search (Section 3.2). Quadratic
search is limited to functions that contain indirect calls
or encounter values that look like function pointers.

We compare X-Force results with four other ap-
proaches: (1) IDA-Pro; (2) Execute all the test cases pro-
vided in SPEC and union the CFGs and CGs observed
for each program (i.e., dynamic analysis); (3) Static CG
construction using LLVM on SPEC source code (i.e.,
static analysis) 3. (4) Dynamic CFG construction using

3We cannot compare LLVM CFGs with X-Force CFGs as LLVM

CFGs are not represented at the instruction level.

a symbolic execution system S2E [10]. We could not
compare with CodeSurfer-X86 [2], which can also gen-
erate CFG/CG for executables based on static analysis,
because it is not available through commercial or aca-
demic license.

Part of the results is presented in Table 3. Columns 2-
4 present the instructions that are covered by the differ-
ent approaches. Particularly, the second column shows
the number of instructions recognized by IDA. The third
column shows those that are executed by concrete input
runs. Columns 5-8 show the indirect call edges recog-
nized by the different approaches4. The last ﬁve columns
show internal data of X-Force.

From the coverage data, we observe that X-Force
could cover a lot more instructions than dynamic analysis
except 253.perlbmk. Note that the dynamic analysis re-
sults are acquired using all the test, training and reference
inputs in SPEC, which are supposed to provide good cov-
erage. Table 4 presents more detailed coverage compari-
son with dynamic analysis. Observe that X-Force covers
all the instructions that are covered by natural runs for
all benchmarks except 253.perlbmk, which we will ex-
plain later. X-Force could cover most of the instructions
identiﬁed by IDA except 252.eon and 253.perlbmk.
We have manually inspected the differences between the
IDA and X-Force coverage. For most programs except
253.perlbmk, the differences are caused by part of the
code in those binaries being unreachable. In other words,
they are dead code that cannot be executed by any input.
Since IDA simply scans the code body to construct CFG
and CG, it reports all instructions it could ﬁnd including
the unreachable ones.

Input Union X-Force

Table 5: Detailed Indirect Call Edges Identiﬁcation
Comparison with Dynamic Analysis
Input Union
∩ X-Force
2
169
60
103
1103
28

\ Input Union
0
1551
61
48
19382
2

Input Union
\ X-Force
0
0
0
122
0
0

253.perlbmk

254.gap
255.vortex

164.gzip
176.gcc
252.eon

2
169
60
225
1103
28

2
1720
121
151
20485
30

X-Force

Indirect call edge identiﬁcation is very challenging in
binary analysis as a call site may have multiple call tar-
gets depending on execution states, which are usually
difﬁcult to cover or abstract. Some of them are dependent
on states related to multiple procedures. Note that there
does not exist an oracle that can provide the ground truth
for the set of real indirect call edges. From the results,
we could observe that LLVM’s indirect call identiﬁca-
tion algorithm generates a large number of edges, much
more than X-Force. However, we conﬁrm that most of
them are bogus because the LLVM algorithm simply re-
lies on method signatures to identify possible targets and

4Direct jump and call edges are easy to identify and elided.

836  23rd USENIX Security Symposium 

USENIX Association

IDA-Pro
7913
31847
310277
2184
43327
25532
70592
132264
113410
132053
5761
46556

Coverage
Input Union X-Force
5075
29218
227546
1935
42763
23135
27224
33643
110066
101207
4830
41935

3601
19409
157451
1622
27811
17339
15580
55964
37564
53798
3612
19996

IDA-Pro
0
0
25
0
0
0
0
24
2
0
0
0

164.gzip
175.vpr
176.gcc
181.mcf
186.crafty
197.parser
252.eon

253.perlbmk

254.gap
255.vortex
256.bzip2
300.twolf

Table 3: CFG and CG Construction Results.

Indirect Call Edge

X-Force Internals

# of Runs Avg. # of Exp. Avg./Max. Linear Set Size
2.9/36
2.8/19
4.5/265
3.1/23
2.6/9
2.5/17
2.3/10
3.5/40
30.0/1846
2.9/33
3.3/15
2.6/8

246
1849
26606
113
2496
1820
2091
843
7319
8566
209
2825

10
49
95
10
0.4
8
4
0.8
1353
13
5
17

Switched/Total # of predicates
2.1/1291
4.7/2164
12.9/29847
4.3/153
8.0/62582
6.4/944
4.1/3146
8.3/9535
6.0/173316
7.3/2548
1.4/7001
5.4/1322

Input Union
2
0
169
0
0
0
60
225
1103
28
0
0

LLVM X-Force Time (s)
704
8725
173241
129
43995
3424
6379
7137
50745
34776
557
10043

2
0
9141
0
0
0
28802
-
187155
340
0
0

2
0
1720
0
0
0
121
151
20470
30
0
0

hence is too conservative. X-Force could recognize a lot
more indirect call edges than dynamic analysis. The de-
tailed comparison in Table 5 shows that the X-Force re-
sults cover all the dynamic results and have many more
edges, except 253.perlbmk. We have manually inspected
a random set of the selected edges that are reported by
X-Force but not the dynamic analysis and conﬁrmed that
they are feasible. From the results in Table 3, IDA can
hardly resolve any indirect call edges.

253.perlbmk

Function Block

164.gzip
176.gcc
252.eon

Functions
21/186(11%)
19/1398(1%)
13/649(2%)
27/1510(1%)
21/941(2%)
21/1031(2%)

Touched
Functions
62/186(33%)
62/1398(4%)
19/649(2%)
134/1510(8%)
80/941(8%)
437/1031(42%)

Coverage
768/1294(59%)
740/1468(50%)
64/101(63%)
1708/6912(24%)
1235/3136(39%)
10933/20822(52%)

Basic Block
Coverage
768/2240(34%)
740/46487(1%)
64/2830(2%)
1708/37384(4%)
1235/28871(4%)
10933/35979(30%)

Table 6: Result of using S2E to analyze SPEC programs
Fully Covered Number
of Paths
134
261
33
329
254.gap
29
255.vortex
9
We also use S2E to analyze the six SPECINT 2000
programs that contain indirect calls. The four programs
other than 252.eon and 255.vortex read input from
stdin, so we use the s2ecmd utility tool provided by S2E
to write 64 bytes to stdout and pipe the symbolic bytes
into these programs. We run each program in S2E and
use the ExecutionTracer plugin to record the execu-
tion trace. We use the IDA scripts provided by S2E to
extract information of basic blocks and functions from
the binaries, and then use the coverage tool provided
by S2E to calculate the result.

The result is shown in Table 6. The columns show the
following metrics from left to right: (1) coverage of basic
blocks; (2) coverage of basic blocks when excluding the
basic blocks in those functions that are not executed; (3)
coverage of functions; (4) percentage of fully-covered
functions; (5) the number of different paths that S2E ex-
plored. Observe that the coverage is much lower than X-
Force in general. 176.gcc, 253.perlbmk and 254.gap
are parsers/compilers. They have poor coverage on S2E
because they get stuck in the parsing loops/automatas,
whose termination conditions are dependent on the sym-
bolic input. Regarding 255.vortex, S2E fails to solve
the constraints when an indirect jump uses the symbolic
variable as the index of jump table. As a result, S2E fails
to identify most of the indirect call edges due to the fail-
ure of creating different objects. In 252.eon, S2E fails
to solve the constraints of the input ﬁle format, which

must contain a speciﬁc string as header. The program
throws exception and terminates quickly, which leads to
poor coverage.

253.perlbmk is a difﬁcult case for X-Force. It parses
perl source code to generate syntax trees. The indirect
call targets are stored in the nodes of syntax trees. How-
ever, since the syntax tree construction is driven by ﬁ-
nite automata, path coverage does not seem to be able to
cover enough states in the automata to generate enough
syntax trees of various forms. A few other benchmarks
such as 176.gcc and 254.gap also leverage automata
based parsers, however their indirect call targets are not
so closely-coupled with the state of the automata and
hence X-Force can still get good coverage. We will leave
it to our future work to address this problem.

The last ﬁve columns show some statistics of X-Force.
The run time and the number of explorations are largely
linear regarding the number of instructions except for a
small number of functions on which quadratic search is
performed. Some take a long time (e.g., close to 50 hours
for 176.gcc) due to their complexity. The average num-
ber of exceptions is the number of exceptions encoun-
tered and recovered from in each execution (e.g. memory
exceptions, division by zero). The numbers are smaller
than we expected given that we execute these programs
without any inputs and switch branch outcomes. It shows
that our exception recovery could effectively prevent cas-
cading exceptions. The linear set sizes are manageable.
The last column shows the average number of switched
predicates versus the average number of predicate in-
stances in total in an execution. It shows that X-Force
may violate path feasibility only in a very small part of
execution. The performance overhead of X-Force com-
pared to the vanilla PIN is 473 times on average. It is
measured by comparing the number of instructions that
could be executed by X-Force and the vanilla PIN within
the same amount of time.

5.2 Malware Analysis
One common approach to understanding the behavior of
an unknown malware sample is by looking at the library
calls it makes. This could be done by static, dynamic
or symbolic analysis; however, they all have limitations.

USENIX Association  

23rd USENIX Security Symposium  837

Table 7: Result of using X-Force for malware analysis compared with IDA Pro and native run.
Number of Library Call Sites

Number of Library Functions

Name

MD5

File Size(KB)

4ec0027bef4d7e1786a04d021fa8a67f
dg003.exe
04eb2e58a145462334f849791bc75d18
Win32/PWSteal.F
995442f722cc037885335340fc297ea0
APT1.DAIRY
0c5e9f564115bfcbee66377a829de55f
APT1.GREENCAT
APT1.HELAUTO
47e7f92419eb4b98ff4124c3ca11b738
APT1.STARSYPOUND 1f2eb7b090018d975e6d9b40868c94ca
36cd49ad631e99125a3bb2786e405cea
APT1.WARP
APT1.NEWSREEL
2c49f47c98203b110799ab622265f4ef
57f98d16ac439a11012860f88db21831
APT1.GOGGLES
APT1.BOUNCER
6ebd05a02459d3b22a9d4a79b8626bf1

192
20
19
14.5
8.5
7
45.5
21
10.5
56

Static analysis could not obtain the parameters of library
calls that are dynamically computed and is infeasible
when the sample is packed or obfuscated. Traditional
dynamic analysis can obtain parameters and is immune
to packing and obfuscation, however, it could only ex-
plore some of the execution paths depending on the input
and the environment. Unfortunately, the input is usually
unknown for malware. Symbolic analysis, while being
able to construct input according to path conditions, has
difﬁculty in handling complex or packed binaries.

X-Force overcomes these problems as traditional dy-
namic analysis could be built upon X-Force to explore
various execution paths without providing any inputs or
the environment. In this case study, we demonstrate the
use of a library call analysis system we built on top of
X-Force to analyze real-world malware samples.

When we implement library call analysis on top of
X-Force, we slightly adjust X-Force to make it suitable
for handling malware: (1) We enable the concrete exe-
cution of most library functions including output func-
tions because many packers use output functions (e.g.
RtlDecompressBuffer()) to unpack code. We con-
tinue to skip some library calls such as Sleep() and
DeleteFile(); (2) We intercept a few functions that
allocate memory and change page attributes, such as
VirtualAlloc() and VirtualProtect(). This is for
tracking the memory areas of code and data which keep
changing at runtime due to self-modifying and dynami-
cally generated code.

Given a malware sample, we use X-Force to explore
its paths. We use the linear search algorithm (Sec-
tion 3.2) as it provides a good balance between efﬁciency
and coverage. During each execution, we record a trace
of function calls. For library calls, we also record the
parameter values. The trace is then transformed into an
interprocedural ﬂow graph that has control transfer in-
structions, including jumps and calls, as its nodes, and
control-ﬂow/call edges as its edges. The parameters
of library calls are also annotated on the graph. The
graphs generated in multiple executions are unioned to
produce the ﬁnal graph. We then manually inspect the
ﬁnal graphs to understand malware behavior.

IDA Pro Native Run X-Force
252
42
100
64
39
36
79
67
36
97

147
7
90
66
41
37
77
67
35
11

129
21
40
26
16
14
47
31
21
16

IDA Pro Native Run X-Force
1750
94
236
302
109
80
414
192
131
562

808
9
213
303
109
80
495
189
127
24

546
28
68
114
33
15
156
49
45
39

No. of Runs
in X-Force
800
30
121
112
30
25
221
93
42
298

(cid:36)(cid:71)(cid:71)(cid:85)(cid:72)(cid:86)(cid:86)
(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:69)(cid:24)(cid:19) (cid:38)(cid:82)(cid:83)(cid:92)(cid:3)(cid:86)(cid:72)(cid:79)(cid:73)(cid:3)(cid:87)(cid:82)(cid:3)(cid:8)(cid:36)(cid:83)(cid:83)(cid:79)(cid:76)(cid:70)(cid:68)(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:39)(cid:68)(cid:87)(cid:68)(cid:8)(cid:63)(cid:90)(cid:86)(cid:21)(cid:75)(cid:79)(cid:83)(cid:17)(cid:72)(cid:91)(cid:72)

(cid:48)(cid:68)(cid:79)(cid:76)(cid:70)(cid:76)(cid:82)(cid:88)(cid:86)(cid:3)(cid:37)(cid:72)(cid:75)(cid:68)(cid:89)(cid:76)(cid:82)(cid:85)

(cid:68)(cid:81)(cid:71)(cid:3)(cid:72)(cid:91)(cid:72)(cid:70)(cid:88)(cid:87)(cid:72)(cid:3)(cid:90)(cid:76)(cid:87)(cid:75)(cid:3)(cid:5)(cid:88)(cid:83)(cid:71)(cid:68)(cid:87)(cid:72)(cid:5)(cid:3)(cid:68)(cid:85)(cid:74)(cid:88)(cid:80)(cid:72)(cid:81)(cid:87)

(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:25)(cid:20)(cid:27)(cid:19) (cid:40)(cid:91)(cid:72)(cid:70)(cid:88)(cid:87)(cid:72)(cid:3)(cid:68)(cid:3)(cid:70)(cid:82)(cid:80)(cid:80)(cid:68)(cid:81)(cid:71)(cid:3)(cid:86)(cid:72)(cid:81)(cid:87)(cid:3)(cid:69)(cid:92)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:38)(cid:9)(cid:38)(cid:3)(cid:86)(cid:72)(cid:85)(cid:89)(cid:72)(cid:85)
(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:24)(cid:71)(cid:27)(cid:19) (cid:39)(cid:72)(cid:79)(cid:72)(cid:87)(cid:72)(cid:3)(cid:68)(cid:3)(cid:73)(cid:76)(cid:79)(cid:72)(cid:3)(cid:86)(cid:72)(cid:81)(cid:87)(cid:3)(cid:69)(cid:92)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:38)(cid:9)(cid:38)(cid:3)(cid:86)(cid:72)(cid:85)(cid:89)(cid:72)(cid:85)
(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:73)(cid:20)(cid:22)(cid:19) (cid:53)(cid:72)(cid:69)(cid:82)(cid:82)(cid:87)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:89)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:3)(cid:80)(cid:68)(cid:70)(cid:75)(cid:76)(cid:81)(cid:72)
(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:72)(cid:68)(cid:26)(cid:19) (cid:54)(cid:72)(cid:79)(cid:73)(cid:16)(cid:85)(cid:72)(cid:80)(cid:82)(cid:89)(cid:68)(cid:79)(cid:3)(cid:73)(cid:85)(cid:82)(cid:80)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:89)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:3)(cid:80)(cid:68)(cid:70)(cid:75)(cid:76)(cid:81)(cid:72)
(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:24)(cid:72)(cid:71)(cid:19) (cid:39)(cid:72)(cid:79)(cid:72)(cid:87)(cid:72)(cid:3)(cid:68)(cid:79)(cid:79)(cid:3)(cid:73)(cid:76)(cid:79)(cid:72)(cid:86)(cid:3)(cid:82)(cid:81)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:75)(cid:68)(cid:85)(cid:71)(cid:3)(cid:71)(cid:76)(cid:86)(cid:78)

(cid:81)(cid:87)(cid:82)(cid:75)(cid:79)(cid:11)(cid:19)(cid:91)(cid:19)(cid:12)(cid:3)(cid:32)(cid:3)(cid:19)(cid:91)(cid:19)(cid:3)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:20)(cid:28)(cid:71)(cid:19)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:20)(cid:19)(cid:71)(cid:19)

(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:70)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:20)(cid:23)(cid:27)(cid:19)

(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:70)(cid:80)(cid:83)(cid:3)(cid:72)(cid:68)(cid:91)(cid:15)(cid:3)(cid:19)(cid:91)(cid:20)(cid:28)(cid:25)
(cid:77)(cid:68)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:19)(cid:73)(cid:22)

(cid:70)(cid:80)(cid:83)(cid:3)(cid:72)(cid:68)(cid:91)(cid:15)(cid:3)(cid:19)(cid:91)(cid:20)(cid:73)(cid:23)
(cid:77)(cid:68)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:28)(cid:22)(cid:24)

(cid:80)(cid:82)(cid:89)(cid:3)(cid:71)(cid:79)(cid:15)(cid:3)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:68)(cid:23)(cid:27)(cid:62)(cid:72)(cid:68)(cid:91)(cid:64)
(cid:77)(cid:80)(cid:83)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:68)(cid:19)(cid:23)(cid:62)(cid:72)(cid:71)(cid:91)(cid:13)(cid:23)(cid:64)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:24)(cid:72)(cid:71)(cid:19)

(cid:77)(cid:80)(cid:83)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:68)(cid:71)(cid:70)(cid:62)(cid:72)(cid:68)(cid:91)(cid:13)(cid:23)(cid:64)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:24)(cid:71)(cid:27)(cid:19)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:71)(cid:69)(cid:24)(cid:19)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:25)(cid:20)(cid:27)(cid:19)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:72)(cid:68)(cid:26)(cid:19)

(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:73)(cid:20)(cid:22)(cid:19)

(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:54)(cid:79)(cid:72)(cid:72)(cid:83)(cid:11)(cid:19)(cid:91)(cid:22)(cid:72)(cid:27)(cid:12)(cid:3)(cid:32)(cid:3)(cid:19)(cid:91)(cid:19)(cid:3)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:20)(cid:19)(cid:22)(cid:19)

(cid:38)(cid:68)(cid:79)(cid:79)(cid:3)(cid:19)(cid:91)(cid:20)(cid:19)(cid:19)(cid:19)(cid:20)(cid:19)(cid:22)(cid:19)

Figure 5: The ﬂow graph of the function at 0x1000c630
generated by X-Force when analyzing dg003.exe.

We evaluate our system on 10 real-world malware
samples which are either wild-captured virus/trojan or
APT samples described in [9]. Since our analysis fo-
cuses on library calls, we choose the number of identiﬁed
library functions and the total number of their call sites
as the evaluation metric5. We also compare our results
with IDA-Pro and the native run. In IDA, library func-
tions are identiﬁed from the import table; the call sites
are identiﬁed by scanning the disassemblies. In the na-
tive run, we execute the malware without any arguments
and record the library calls using a PIN tool.

The results are shown in Table 7. We can see that
for packed or obfuscated samples such as dg003.exe,
Win32/PWSteal.F, APT1.DAIRY, and APT1.BOUNCER,
IDA gets fewer library functions and call sites compared
to X-Force. For other samples that are not packed or
obfuscated, since the executables could be properly dis-
assembled, the metrics obtained in IDA and X-Force are

5We exclude the C/C++ runtime initialization functions which are

only called before the main function.

838  23rd USENIX Security Symposium 

USENIX Association

very close. However, even in such cases, static analysis
is insufﬁcient to understand the malicious behavior be-
cause it does not show the values of the library function
parameters. Compared to the native run method, X-Force
can identify more library functions and call sites.

Next, we present detailed analysis for two representa-

tive samples.

(cid:11)(cid:12)(cid:13)(cid:14)(cid:11)(cid:12)(cid:29)(cid:30)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:34)(cid:32)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:9)(cid:24)(cid:20)(cid:25)(cid:26)(cid:5)(cid:6)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:8)(cid:20)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:11)(cid:12)(cid:29)(cid:30)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:35)(cid:36)(cid:31)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:34)(cid:32)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:24)(cid:5)(cid:31)(cid:25)(cid:26)(cid:5)(cid:6)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:14)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:5)(cid:5)(cid:8)(cid:9)(cid:10)(cid:5)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:11)(cid:12)(cid:29)(cid:30)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:7)(cid:40)(cid:5)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:34)(cid:32)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:5)(cid:9)(cid:5)(cid:25)(cid:26)(cid:5)(cid:6)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)(cid:10)(cid:8)(cid:9)(cid:40)(cid:20)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:11)(cid:12)(cid:29)(cid:30)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:20)(cid:31)(cid:8)(cid:36)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:41)(cid:16)(cid:3)(cid:16)(cid:2)(cid:30)(cid:16)(cid:33)(cid:34)(cid:32)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:20)(cid:9)(cid:10)(cid:36)(cid:25)(cid:26)(cid:5)(cid:6)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)(cid:10)(cid:8)(cid:31)(cid:42)(cid:5)

(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:8)(cid:20)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:9)(cid:24)(cid:20)(cid:25)(cid:26)(cid:5)(cid:6)(cid:23)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:8)(cid:20)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:9)(cid:24)(cid:20)(cid:25)(cid:26)(cid:5)(cid:6)(cid:23)(cid:24)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:8)(cid:20)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:9)(cid:24)(cid:20)(cid:25)(cid:26)(cid:5)(cid:6)(cid:23)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:16)(cid:6)(cid:17)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:8)(cid:20)(cid:21)(cid:4)(cid:22)(cid:7)(cid:23)(cid:8)(cid:9)(cid:24)(cid:20)(cid:25)(cid:26)(cid:5)(cid:6)(cid:23)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)

(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)

(cid:11)(cid:12)(cid:13)(cid:14)(cid:1)(cid:3)(cid:37)(cid:30)(cid:16)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:8)(cid:31)(cid:42)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:1)(cid:3)(cid:37)(cid:30)(cid:16)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:8)(cid:9)(cid:40)(cid:20)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:1)(cid:3)(cid:37)(cid:30)(cid:16)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:8)(cid:9)(cid:40)(cid:20)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)
(cid:11)(cid:12)(cid:13)(cid:14)(cid:1)(cid:3)(cid:37)(cid:30)(cid:16)(cid:19)(cid:5)(cid:6)(cid:7)(cid:10)(cid:14)(cid:2)(cid:14)(cid:5)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)(cid:6)(cid:7)

(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)

(cid:43)(cid:16)(cid:3)(cid:16)(cid:17)(cid:16)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:18)(cid:44)(cid:45)(cid:46)(cid:47)(cid:48)(cid:47)(cid:1)(cid:28)(cid:49)(cid:18)(cid:45)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:43)(cid:16)(cid:3)(cid:16)(cid:17)(cid:16)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:9)(cid:37)(cid:37)(cid:17)(cid:28)(cid:12)(cid:13)(cid:12)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)
(cid:43)(cid:16)(cid:3)(cid:16)(cid:17)(cid:16)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:40)(cid:50)(cid:28)(cid:17)(cid:6)(cid:17)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:43)(cid:16)(cid:3)(cid:16)(cid:17)(cid:16)(cid:11)(cid:12)(cid:3)(cid:16)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:1)(cid:46)(cid:15)(cid:11)(cid:51)(cid:52)(cid:28)(cid:53)(cid:54)(cid:53)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)

(cid:41)(cid:16)(cid:55)(cid:37)(cid:56)(cid:16)(cid:43)(cid:12)(cid:29)(cid:16)(cid:31)(cid:17)(cid:37)(cid:29)(cid:57)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:7)(cid:40)(cid:5)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:41)(cid:16)(cid:3)(cid:16)(cid:2)(cid:30)(cid:16)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:41)(cid:16)(cid:55)(cid:37)(cid:56)(cid:16)(cid:43)(cid:12)(cid:29)(cid:16)(cid:31)(cid:17)(cid:37)(cid:29)(cid:57)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:35)(cid:36)(cid:31)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:41)(cid:16)(cid:55)(cid:37)(cid:56)(cid:16)(cid:43)(cid:12)(cid:29)(cid:16)(cid:31)(cid:17)(cid:37)(cid:29)(cid:57)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:35)(cid:36)(cid:31)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:33)(cid:41)(cid:16)(cid:3)(cid:16)(cid:2)(cid:30)(cid:16)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:41)(cid:16)(cid:55)(cid:37)(cid:56)(cid:16)(cid:43)(cid:12)(cid:29)(cid:16)(cid:31)(cid:17)(cid:37)(cid:29)(cid:57)(cid:18)(cid:19)(cid:22)(cid:7)(cid:23)(cid:8)(cid:31)(cid:2)(cid:20)(cid:25)(cid:26)(cid:32)(cid:33)(cid:31)(cid:37)(cid:13)(cid:17)(cid:29)(cid:37)(cid:3)(cid:3)(cid:16)(cid:29)(cid:38)(cid:6)(cid:39)(cid:40)(cid:37)(cid:29)(cid:31)(cid:16)(cid:32)(cid:27)(cid:4)(cid:26)(cid:4)(cid:5)

(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)(cid:28)

Figure 6: The ﬂow graph of the function at 0x10009b50
in dg003.exe that delete all ﬁles on the hard disk.
Dg003.exe.
This is a typical APT malware sam-
ple that features multi-staged, condition-guarded and
environment-speciﬁc payload. In the ﬁrst stage, the mal-
ware extracts a DLL which it carries as its resource,
packs the DLL in memory using a proprietary algorithm
and writes the packed DLL to the disk. In the second
stage, the packed DLL is loaded, unpacks itself in mem-
ory and executes the main payload.

There is a previous report [26] in which the analysts
used both static and dynamic analyses to analyze this
sample. To perform static analysis using IDA Pro, they
manually extract and unpack the DLL. This requires re-
verse engineering the unpacking algorithm, which could
be both time consuming and difﬁcult. Our system avoids
such trouble by concretely executing the unpacking rou-
tine which performs the unpacking for us. Compared
with their dynamic analysis, it takes X-Force about 5
hours to ﬁnish 800 executions to explore all paths in both
the ﬁrst and second stages of the malware. After that,
the traces are transformed into a ﬂow graph containing
378 functions. Our system is able to discover a set of
malicious behaviors that are NOT mentioned in the pre-
vious report. As shown in Fig. 5, each highlighted func-
tion call in the graph corresponds to a previously unre-
vealed malicious behavior. Each behavior is identiﬁed
using the library calls made in the corresponding func-
tion. For example, as shown in Fig. 6, the library calls
and the parameters in the function at 0x10009b50 show
that it recursively enumerates and deletes ﬁles and direc-
tories starting from the root directory, which indicates its
behavior is to delete all ﬁles on the disk.

In Fig. 5 we can see that the common dominator of all
these function calls (highlighted in red color) determines
if the value of eax register is larger than 0x196. With taint
analysis in X-Force, we ﬁnd that the value of the eax reg-
ister is related to an input which is a buffer in a previous
recv library function call. This indicates it represents the
command ID sent by the C&C server, which leads to the
execution of different malicious behaviors. Hence, we
suspect that the previous analysts missed some behav-
iors because the C&C server only sent part of the pos-
sible commands at the time they ran the malware. We
also ﬁnd that the buffer in the recv function call is trans-
lated to the command ID using a private decryption algo-
rithm, so it would be infeasible for symbolic analysis to
solve the constraints and construct a valid input. We also
want to point out that at the time we perform the analysis,
the C&C server of this malware is already inactive; we
would not be able to discover these malicious behaviors,
had we not used X-Force.
Win32/PWSteal.F. Before trying X-Force on this sam-
ple, we ﬁrst try static analysis using IDA-Pro. Surpris-
ingly, this sample does not import any suspicious library
function; not even a function that could perform I/O
(e.g.
read/write ﬁle, registry or network socket). The
LoadLibrary() and GetProcAddress() functions are
not imported either, which means the common approach
of dynamically loading libraries is not used. The strings
in the executable do not contain any DLL name or li-
brary function name either. This indicates the sample
is equipped with advanced API obfuscation technique to
thwart static analysis.

Since static analysis is infeasible, we submit the sam-
ple to the Anubis malware analysis platform for dynamic
analysis. The result shows the malware does read some
registry entries and ﬁles, however, none of them seems
malicious. Hence, we feed the sample to our system
in hopes of revealing its real intent. X-Force achieves
full coverage after exploring 30 paths and generates a
graph with 15 functions. By traversing the graph, we
ﬁnd that this malware aims at stealing the password that
is stored by IE and Firefox in the victim’s machine. It
enumerates the registry entry that stores the encrypted
auto-complete password for IE and calls library func-
tions such as CryptUnprotectData() to decrypt the
stored password. This is very similar to the attack men-
tioned in [1]. Regarding Firefox, it ﬁrst gets the user
name from profiles.ini under the Firefox applica-
tion data directory, and then steals the password that is
stored in the signons*.txt under the directory of the
user name. The password is then uploaded to a remote
FTP server using the ﬁle name [Computer Name].[IP
Address].txt. Clearly, this sample ﬁnds the entry ad-
dresses of these library functions at runtime using some
obfuscation techniques. X-Force allows us to identify the

USENIX Association  

23rd USENIX Security Symposium  839

malicious behavior without spending unnecessary time
on reverse-engineering the API obfuscation.

Moreover, the ﬂow graph also reveals the reason why
Anubis missed the malicious behavior: the malware per-
forms environment checks to make sure the targets ex-
ist before trying to attack. For example, in the function
where the malware steals password from IE, it will try
to open the registry entry that contains the auto-complete
password; if such entry does not exist or is empty, the
malware will cease its operation and return from that
function. Also, before it tries to steal password stored by
Firefox, it will ﬁrst try querying the installation directory
of Firefox from registry to make sure the target program
exists in the system. Such “prerequisites“ are unlikely
to be fulﬁlled in automated analysis systems as they are
unpredictable. However, by force-executing through dif-
ferent paths, X-Force is able to get through these checks
to reveal the real intent of the malware.

TYPE_1 func1(TYPE_2 arg1, TYPE_3 arg2) {

TYPE_4 var1;
var1 = strlen (arg1);
if (arg2 >= var1)
return 0;
return arg1[arg2];

1 
2 
3 
4 
}
Figure 7: REWARDS example.

5.3 Type Reverse Engineering
Researchers have proposed techniques to reverse engi-
neer variable and data structure types for stripped bi-
naries [30, 39, 25]. The reverse engineered types can
be used in forensic analysis and vulnerability detection.
There are two common approaches. REWARDS [30]
and HOWARD [39] leverage dynamic analysis. They
can produce highly precise results but incompleteness
is a prominent limitation – they cannot reverse engineer
types of variables if such variables are not covered by ex-
ecutions. TIE [25] leverages static analysis and abstract
interpretation such that it provides good coverage. How-
ever, it is challenging to apply the technique to large and
complex binaries due to the cost of analysis.





















Figure 8: Type reverse engineering coverage results.
One advantage of X-Force is that the forced execu-
tions are essentially concrete executions such that exist-
ing dynamic analyses could be easily ported to X-Force

to beneﬁt from the good coverage. Therefore in the third
case study, we port the implementation of REWARDS to
X-Force. Given a binary executable and a few test in-
puts, REWARDS executes it while monitoring dataﬂow
during execution. When execution reaches system or
library calls, the types of the parameters of these calls
are known. Such execution points are called type sinks.
Through the dynamic dataﬂow during execution, such
types could be propagated to variables that (transitively)
contributed to the parameters in the past and to variables
that are (transitively) dependent on these parameters.

Consider the example in Fig. 7. Assume func1 is
executed. After line 1, the type of arg1 and var1 get
resolved using the interface of strlen(). So TYPE 2
is char *, and TYPE 4 is unsigned int.
In line 2,
arg2 is compared with var1, implying they have the
same type. Thus TYPE 3 gets resolved as unsigned
int. Later when line 4 gets executed, it returns TYPE 1
which is resolved as char since arg1 is of char *.





















Figure 9: Type reverse engineering accuracy results.

Porting REWARDS to X-Force requires very little
modiﬁcation of either the REWARDS or the X-Force
systems as they only interface through the (forced) con-
crete executions. Facilitated by X-Force, REWARDS is
able to run legacy binaries and COTS binaries without
any inputs. In our experiment, we run the new system on
the 12 SPEC2000 INT binaries. They are a lot more com-
plex than the Linux core-util programs used in the origi-
nal paper [30]. To acquire the ground truth, we compile
the programs with the option of generating debugging
symbols as PDB ﬁles, and use DIA SDK to read the type
information from the PDB ﬁles.

We evaluate the system in terms of both coverage and
accuracy. Coverage means the percentage of variables in
the program that have been executed by our system. Ac-
curacy is the percentage of the covered variables whose
types are correctly reverse engineered. From Fig. 8, the
average coverage is around 84%. The coverage heav-
ily relies on the code coverage of X-Force. Recall that
these programs have non-trivial portion of unreachable
code. The variables in those code regions cannot be re-
verse engineered by our system. From Fig.9, the average
accuracy is about 90%. The majority of type inference

840  23rd USENIX Security Symposium 

USENIX Association

Figure 10: Essence of X-Force.

failures is caused by the fact that the variables are not
related to any type sink.

We also compare with IDA and the original RE-
WARDS. IDA has a static type inference algorithm that
works in a similar fashion. When we run the original
REWARDS, we have two conﬁgurations: (1) use the test
input only (1 input per program) and (2) use both the
test and the reference inputs (around 4 inputs per pro-
gram). From Fig. 8 and Fig. 9, our system has much
better accuracy than IDA (90% vs. 55% on average) and
better coverage than the original REWARDS, i.e., 84%
vs. 57% (test+reference) or 34% (test input only). The
better accuracy than IDA is achieved by the more precise
modeling of behavior difﬁcult for static analysis, such as
heap accesses and indirect calls and jumps.

6 Discussion and Future Work
X-Force is intended to be a practical solution for ana-
lyzing unknown (malicious) binaries without requiring
any source code or inputs. Hence, X-Force trades sound-
ness and completeness for practicality.
It is unsound
as it could explore infeasible paths. It is incomplete as
it cannot afford exploring all paths. Figure 10 shows
how X-Force compares with static and dynamic analysis:
The “Reachable Program State” oval denotes all states
that can be reached through possible program inputs –
the ideal coverage for program analysis. Static analyses
often make conservative approximations such that they
yield over-approximate coverage. Dynamic analyses an-
alyze a number of real executions and hence yield under-
approximate results. X-Force explores a larger set of ex-
ecutions than dynamic analyses. Since X-Force makes
unsound approximations, its results may be invalid (i.e.,
outside the ideal oval). Furthermore, it is incomplete as
its results may not cover the ideal ones.

However, we argue that X-Force is still of importance
in practice:
(1) There are many security applications
whose analysis results are not so sensitive to paths, such
as the three studies in this paper. As such, path infeasi-
bility may not affect the results much. However, having
concrete states in path exploration is still critical in these
applications such that an execution based approach like
X-Force is suitable; (2) Only a very small percentage of
predicates are switched (Section 5.1) in X-Force. Execu-
tion is allowed to proceed naturally in most predicates,
respecting path feasibility. According to our observa-
tions, most of the predicates that got switched in linear

search are those checking if the program has been pro-
vided the needed parameters, if ﬁles are properly opened,
and if certain environmental conﬁgurations are correctly
set-up; (3) In X-Force, taint analysis is used to identify
predicates that are affected by inputs and only such pred-
icates are eligible for switching.

Moreover, X-Force allows users to (1) rapidly explore
the behaviors of any (unknown) binary as it simply exe-
cutes the binary (without solving constraints); (2) handle
binaries in a much broader spectrum (e.g., large, packed,
or obfuscated binaries); (3) easily port or develop dy-
namic analysis on X-Force as the executions in X-Force
are no different from regular concrete executions.
Future Work. We believe this paper is just an initial step
in developing a unique type of program analysis different
from the traditional static, dynamic, and symbolic anal-
ysis. We have a number of tasks in our future research
agenda.

• While X-Force simply forces the branch outcomes
of a few predicates without considering their feasi-
bility, we suspect that there is a chance in practice
the forced paths are indeed feasible in many cases.
Note that the likelihood of infeasibility is not high if
the forced predicates are not closely correlated. We
plan to use a symbolic analysis engine that mod-
els the path conditions along the forced paths to ob-
serve how often they are infeasible.

• We develop 3 exploration algorithms in this pa-
per. From the evaluation data on the SPECINT2000
programs, there are cases (e.g., perlbmk) that the
current exploration algorithms cannot handle well.
More effective algorithms, for example, based on
modeling functions behaviors and caching previous
exploration choices, will be developed.

• We currently handle multi-threaded programs by se-
rializing their executions. In the future, we will ex-
plore forcing real concurrent executions. We envi-
sion this has to be integrated with ﬂipping sched-
ule decisions, which is a standard technique in ex-
ploring concurrent execution state. How to handle
the enlarged state space and the potentially intro-
duced infeasible thread schedules will be the new
challenges.

• The current system is implemented as a tool on
top of PIN. To build a tool that makes use of X-
Force, for example REWARDS, the implementation
of the additional tool is currently mixed with X-
Force. They are compiled together to a single PIN-
tool. We aim to make X-Force transparent to dy-
namic analysis developers by providing an PIN-like
interface. Ideally, existing PIN-tools can be easily

USENIX Association  

23rd USENIX Security Symposium  841

ported to X-Force to beneﬁt from the large number
of executions provided by the X-Force engine.

• We also plan to port the core X-Force engine to
other platforms such as mobile and HTML5 plat-
forms.

7 Related Work
Researchers proposed to force branch outcomes for
patching software failures in [51]. Hardware support was
proposed to facilitate path forcing in [31]. Both require
source code and concrete program inputs. Branch out-
comes are forced to explore paths of binary programs
in [48] to construct control ﬂow graphs. The technique
does not model any heap behavior. Moreover, it skips all
library calls. Similar techniques are proposed to expose
hidden behavior in Android apps [22, 45]. These tech-
niques randomly determine each branch’s outcome, pos-
ing the challenge of excessive infeasible paths. Forced
execution was also proposed to identify kernel-level
rootkits [46]. It completely disregards branch outcomes
during execution and performs simple depth-ﬁrst search.
None of these techniques performs exception recovery
and instead simply terminates executions when excep-
tions arise. Constraint solving was used in exploring
execution paths to expose malware behavior in [33, 6].
They require concrete inputs to begin with and then mu-
tate such inputs to explore different paths.

X-Force is related to static binary analysis [21, 3, 25,
42, 41], dynamic binary analysis [30, 39, 24] and sym-
bolic binary analysis [10, 40]. We have discussed their
differences from X-Force in Section 6, which are also
supported by our empirical results in Section 5. X-Force
is also related to failure oblivious computing [36] and
on-the-ﬂy exception recovery [34], which are used for
failure tolerance and debugging and require source code.

8 Conclusion
We develop a novel binary analysis engine X-Force,
which forces a binary to execute without any inputs or the
needed environment. It systematically forces the branch
outcomes at a small number of predicates to explore dif-
ferent paths. It can recover from exceptions by allocat-
ing memory on-demand and ﬁxing correlated pointers
accordingly. Our experiments on three security applica-
tions show that X-Force has similar precision as dynamic
analysis but much better coverage due to the capability of
exploring many paths with any inputs.

Acknowledgements

part by the earlier research of Dr. Vinod Yegneswaran
on brute-force malware execution and analysis. His in-
ﬂuence and support is gratefully acknowledged. This
research has been supported, in part, by DARPA under
Contract 12011593 and by a gift from Cisco Systems.
Any opinions, ﬁndings, and conclusions in this paper are
those of the authors only and do not necessarily reﬂect
the views of the sponsors.

References

[1] Exposing the password secrets of internet ex-
http://securityxploded.com/

plorer.
iepasswordsecrets.php.

[2] G. Balakrishnan, R. Gruian, T. Reps, and T. Teit-
elbaum. Codesurfer/x86–a platform for analyzing
x86 executables.
In Proceedings of International
Conference on Compiler Construction (CC), 2005.

[3] G. Balakrishnan and T. Reps. Analyzing mem-
ory accesses in x86 executables. In Proceedings of
Intenational Conference on Compiler Construction
(CC), 2004.

[4] D. Balzarotti, M. Cova, C. Karlberger, E. Kirda,
C. Kruegel, and G. Vigna. Efﬁcient detection of
split personalities in malware.
In Proceedings of
Network and Distributed System Security Sympo-
sium (NDSS), 2010.

[5] R. R. Branco, G. N. Barbosa, and P. D. Neto. Scien-
tiﬁc but not academical overview of malware anti-
debugging, anti-disassembly and anti-vm technolo-
gies. Blackhat USA’12.

[6] D. Brumley, C. Hartwig, Z. Liang, J. Newsome,
D. Song, and H. Yin. Automatically identifying
trigger-based behavior in malware. In Botnet De-
tection. 2008.

[7] J. Caballero and D. Song. Polyglot: Automatic ex-
traction of protocol format using dynamic binary
analysis. In Proceedings of the 14th ACM Confer-
ence on Computer and and Communications Secu-
rity (CCS), 2007.

[8] C. Cadar, D. Dunbar, and D. Engler. Klee: unas-
sisted and automatic generation of high-coverage
tests for complex systems programs.
In Proceed-
ings of the 8th USENIX conference on Operating
systems design and implementation (OSDI), 2008.

We would like to thank the anonymous reviewers for
their insightful comments. This work was motivated in

[9] M. I. Center. Apt1: Exposing one of chinas cyber

espionage units. Technical report, 2013.

842  23rd USENIX Security Symposium 

USENIX Association

[10] V. Chipounov, V. Kuznetsov, and G. Candea. S2e: a
platform for in-vivo multi-path analysis of software
systems. In Proceedings of the 16th international
conference on Architectural support for program-
ming languages and operating systems (ASPLOS),
2011.

[11] C. Csallner and Y. Smaragdakis. DSD-Crasher: A
hybrid analysis tool for bug ﬁnding.
In Proceed-
ings of International Symposium on Software Test-
ing and Analysis (ISSTA), pages 245–254, 2006.

[12] W. Cui, J. Kannan, and H. J. Wang. Discoverer:
Automatic protocol reverse engineering from net-
work traces.
In Proceedings of the 16th USENIX
Security Symposium (Security), 2007.

[13] W. Cui, M. Peinado, K. Chen, H. J. Wang, and
L. Irun-Briz. Tupni: Automatic reverse engineering
of input formats. In Proceedings of the 15th ACM
Conference on Computer and Communications Se-
curity (CCS), 2008.

[14] Z. Deng, X. Zhang, and D. Xu. Bistro: Bi-
nary component extraction and embedding for soft-
ware security applications. In 18th European Sym-
posium on Research in Computer Security (ES-
ORICS), 2013.

[15] A. Dinaburg, P. Royal, M. Sharif, and W. Lee.
Ether: malware analysis via hardware virtualiza-
tion extensions.
In Proceedings of the 15th ACM
conference on Computer and Communications Se-
curity (CCS), 2008.

[16] N. Falliere, L. Murchu, and E. Chien. W32. stuxnet
dossier. White paper, Symantec Corp., Security Re-
sponse, 2011.

[17] P. Ferrie. Attacks on virtual machine emulators.

Symantec Advanced Threat Research, 2006.

[18] P. Ferrie. Attacks on more virtual machine emula-

tors. Symantec Technology Exchange, 2007.

[19] FireEye. Advanced targeted attacks: How to pro-
tect against the new generation of cyber attacks. In
White Paper, 2013.

[20] P. Godefroid, N. Klarlund, and K. Sen. Dart: Di-
rected automated random testing.
In Proceedings
of the ACM SIGPLAN 1991 Conference on Pro-
gramming Language Design and Implementation
(PLDI), 2005.

[21] Hex-Rays.

Ida pro disassembler. http://www.

hex-rays.com/products/ida/index.shtml.

[22] R. Johnson and A. Stavrou. Forced-path execution
for android applications on x86 platforms. Tech-
nical report, Technical Report, Computer Science
Department, George Mason University, 2013.

[23] C. Kolbitsch, P. M. Comparetti, C. Kruegel,
E. Kirda, X. Zhou, and X. Wang. Effective and
efﬁcient malware detection at the end host. In Pro-
ceedings of the 18th USENIX Security Symposium
(Security), 2009.

[24] C. Kolbitsch, T. Holz, C. Kruegel, and E. Kirda.
Inspector gadget: Automated extraction of propri-
etary gadgets from malware binaries. In 2010 IEEE
Symposium on Security and Privacy (SP), pages
29–44, 2010.

[25] J. Lee, T. Avgerinos, and D. Brumley. Tie: Prin-
cipled reverse engineering of types in binary pro-
grams. In Proceedings of the Annual Network and
Distributed System Security Symposium (NDSS),
2011.

[26] F. Li. A detailed analysis of an advanced persistent

threat malware. SANS Institute, 2011.

[27] J. Lim, T. Reps, and B. Liblit. Extracting ﬁle
formats from executables.
In Proceedings of the
13th Working Conference on Reverse Engineering
(WCRE), 2006.

[28] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Auto-
matic protocol format reverse engineering through
context-aware monitored execution.
In Proceed-
ings of the 15th Annual Network and Distributed
System Security Symposium (NDSS), 2008.

[29] Z. Lin and X. Zhang. Deriving input syntactic
structure from execution.
In Proceedings of the
16th ACM SIGSOFT International Symposium on
Foundations of Software Engineering (FSE), 2008.

[30] Z. Lin, X. Zhang, and D. Xu. Automatic reverse en-
gineering of data structures from binary execution.
In Proceedings of the 17th Annual Network and
Distributed System Security Symposium (NDSS),
2010.

[31] S. Lu, P. Zhou, W. Liu, Y. Zhou, and J. Torrellas.
Pathexpander: Architectural support for increasing
the path coverage of dynamic bug detection. In Pro-
ceedings of the 39th Annual IEEE/ACM Interna-
tional Symposium on Micro-architecture (MICRO),
2006.

[32] J. Ma, K. Levchenko, C. Kreibich, S. Savage, and
G. M. Voelker. Unexpected means of protocol in-
ference. In Proceedings of the 6th ACM SIGCOMM

USENIX Association  

23rd USENIX Security Symposium  843

on Internet measurement (IMC), pages 313–326,
2006.

[33] A. Moser, C. Kruegel, and E. Kirda. Exploring mul-
tiple execution paths for malware analysis. In Pro-
ceedings of the 2007 IEEE Symposium on Security
and Privacy (SP), pages 231–245, 2007.

[34] F. Qin, J. Tucek, Y. Zhou, and J. Sundaresan. Rx:
Treating bugs as allergies a safe method to survive
software failures. ACM Transactions on Computer
Systems, 25(3), 2007.

[35] T. Raffetseder, C. Kr¨ugel, and E. Kirda. Detecting
system emulators. In Proceedings of the 10th inter-
national conference on Information Security (ISC).
2007.

[36] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy,
T. Leu, and W. S. Beebee, Jr. Enhancing server
availability and security through failure-oblivious
computing.
In Proceedings of the 6th conference
on Symposium on Opearting Systems Design & Im-
plementation (OSDI), 2004.

[37] N. Riva and F. Falc´on. Dynamic binary instrumen-
tation frameworks: I know you’re there spying on
me. In RECON Conference, 2012.

[38] K. Sen, D. Marinov, and G. Agha. Cute: A con-
colic unit testing engine for c.
In Proceedings of
the 10th European Software Engineering Confer-
ence held jointly with 13th ACM SIGSOFT Interna-
tional Symposium on Foundations of Software En-
gineering (ESEC/FSE-13), 2005.

[39] A. Slowinska, T. Stancescu, and H. Bos. Howard:
A dynamic excavator for reverse engineering data
structures. In Proceedings of the 17th Annual Net-
work and Distributed System Security Symposium
(NDSS), 2011.

[40] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager,
M. G. Kang, Z. Liang, J. Newsome, P. Poosankam,
and P. Saxena. Bitblaze: A new approach to com-
puter security via binary analysis. In Proceedings
of the 4th International Conference on Information
Systems Security (ICISS), 2008.

[41] B. D. Sutter, B. D. Bus, K. D. Bosschere, P. Keyng-
naert, and B. Demoen. On the static analysis of in-
direct control transfers in binaries. In Proceedings
of Parallel and Distributed Processing Techniques
and Applications (PDPTA), 2000.

[42] H. Theiling. Extracting safe and precise control
ﬂow from binaries.
In Proceedings of the Sev-
enth International Conference on Real-Time Sys-
tems and Applications (RTCSA), 2000.

[43] A. Vasudevan and R. Yerraballi. Cobra: Fine-
grained malware analysis using stealth localized-
executions. In 2006 IEEE Symposium on Security
and Privacy (SP), 2006.

[44] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace.
Reformat: Automatic reverse engineering of en-
crypted messages.
In Proceedings of 14th Euro-
pean Symposium on Research in Computer Security
(ESORICS), 2009.

[45] Z. Wang, R. Johnson, R. Murmuria, and A. Stavrou.
Exposing security risks for commercial mobile de-
vices. In Proceedings of the 6th international con-
ference on Mathematical Methods, Models and Ar-
chitectures for Computer Network Security: com-
puter network security (MMM-ACNS), pages 3–21,
2012.

[46] J. Wilhelm and T.-c. Chiueh. A forced sampled
execution approach to kernel rootkit identiﬁcation.
In Proceedings of the 10th international conference
on Recent advances in intrusion detection (RAID),
pages 219–235, 2007.

[47] G. Wondracek, P. Milani, C. Kruegel, and E. Kirda.
Automatic network protocol analysis. In Proceed-
ings of the 15th Annual Network and Distributed
System Security Symposium (NDSS), 2008.

[48] L. Xu, F. Sun, and Z. Su. Constructing precise
control ﬂow graphs from binaries. Technical re-
port, Technical Report CSE-2009-27, Department
of Computer Science, UC Davis, 2009.

[49] L.-K. Yan, M. Jayachandra, M. Zhang, and H. Yin.
V2e: Combing hardware virtualization and soft-
ware emulation for transparent and extensible mal-
ware analysis.
In 8th Annual International Con-
ference on Virtual Execution Environments (VEE),
2012.

[50] H. Yin, D. Song, M. Egele, C. Kruegel, and
E. Kirda. Panorama: capturing system-wide infor-
mation ﬂow for malware detection and analysis. In
Proceedings of the 14th ACM conference on Com-
puter and communications security (CCS), 2007.

[51] X. Zhang, N. Gupta, and R. Gupta. Locating faults
through automated predicate switching.
In Pro-
ceedings of ACM/IEEE International Conference
on Software Engineering (ICSE), 2006.

844  23rd USENIX Security Symposium 

USENIX Association

