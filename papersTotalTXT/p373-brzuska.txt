An Analysis of the EMV Channel Establishment Protocol

Christina Brzuska

School of Computer Science,

Tel Aviv University

brzuska@post.tau.ac.il

Bogdan Warinschi
Department of Computer

Science, University of Bristol
bogdan@cs.bris.ac.uk

ABSTRACT
With over 1.6 billion debit and credit cards in use worldwide, the
EMV system (a.k.a. “Chip-and-PIN”) has become one of the most
important deployed cryptographic protocol suites. Recently, the
EMV consortium has decided to upgrade the existing RSA based
system with a new system relying on Elliptic Curve Cryptography
(ECC). One of the central components of the new system is a pro-
tocol that enables a card to establish a secure channel with a card
reader. In this paper we provide a security analysis of the proposed
protocol, we propose minor changes/clariﬁcations to the “Request
for Comments” issued in Nov 2012, and demonstrate that the re-
sulting protocol meets the intended security goals.

The structure of the protocol is one commonly encountered in
practice: ﬁrst run a key-exchange to establish a shared key (which
performs authentication and key conﬁrmation), only then use the
channel to exchange application messages. Although common in
practice, this structure takes the protocol out of the reach of most
standard security models for key-exchange. Unfortunately, the only
models that can cope with the above structure suffer from some
drawbacks that make them unsuitable for our analysis. Our second
contribution is to provide new security models for channel estab-
lishment protocols. Our models have a more inclusive syntax, are
quite general, deal with a realistic notion of authentication (one-
sided authentication as required by EMV), and do not suffer from
the drawbacks that we identify in prior models.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—security
and protection; K.6.5 [Management of Computing and Informa-
tion Systems]: Security and Protection—authentication

Keywords
Key Exchange; Channel Establishment

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage, and that copies bear this notice and the full ci-
tation on the ﬁrst page. Copyrights for third-party components of this work must be
honored. For all other uses, contact the owner/author(s). Copyright is held by the
author/owner(s).
CCS’13, November 4–8, 2013, Berlin, Germany.
ACM 978-1-4503-2477-9/13/11.
http://dx.doi.org/10.1145/2508859.2516748.

Nigel P. Smart

Department of Computer

Science, University of Bristol

nigel@cs.bris.ac.uk
Gaven J. Watson

Department of Computer

Science, University of Bristol
gaven.watson@bristol.ac.uk

1.

INTRODUCTION

The EMV chip-and-pin system is used to secure a vast number
of the world’s credit card and ATM transactions and protects elec-
tronic banking in many countries [15]. The USA is due to switch
from magnetic stripe to EMV cards from October 2015; after this
time if a terminal (or ATM) does not support EMV then the mer-
chant (ATM owner) will be liable for any fraudulent transactions
and not the card issuer. The current EMV system uses RSA public-
key cryptography, combined with DES and AES based symmetric-
key cryptography. In the system, bank or credit card customers re-
ceive a plastic card containing an embedded chip that holds several
cryptographic keys and can perform various cryptographic opera-
tions. The card is used to communicate with a terminal (typically
a point-of-sale terminal in a shop, but other terminals are possi-
ble). In addition the card can produce cryptographically secured
data which is sent to the cardholder and merchant’s banks for pro-
cessing. Nonetheless, the cryptographic functionality provided by
the card in its ﬁrst generation incarnation is relatively limited.

As part of a major reworking of the system, the EMV consor-
tium has decided to replace RSA with ECC based systems and
to let the card provide additional cryptographic functionalities. In
November 2012 EMVCo released a Request-For-Comments [16]
on a draft speciﬁcation for an important sub-protocol within the
system; namely a protocol that allows a card to establish a channel
with a terminal. Calling the security of these protocols “impor-
tant” is a serious understatement: the total number of public keys
and certiﬁcates (1.62 billion [15]) deployed in the EMV systems
dwarfs the paltry 5.8 million TLS certiﬁcates found in [11].

The problem of establishing and implementing secure channels
is central to practical uses of cryptography and a superﬁcial look at
existing literature would lead one to believe that this is a solved
problem. What can be simpler than ﬁrst running a secure key-
exchange protocol and then using the resulting keys to encrypt and
authenticate the messages to be sent?

Indeed, there is a plethora of works looking at key establish-
ment [4, 5, 9] and a similar number of works treating secure chan-
nels based on shared keys [1, 6, 18]. Unfortunately, traditional
key agreement models such as those following the schema set out
by Bellare and Rogaway [4] have been shown to be less useful to
analyze deployed protocols. In particular, they demand for session
keys to be indistinguishable from a random string. However, when-
ever practical protocols implement explicit key conﬁrmation, then
key indistinguishability is violated.

Realizing that real-world protocols, such as TLS, are therefore
outside the reach of the traditional models for key-exchange and
channels, has triggered renewed interest in formal models for se-

373cure channels [17, 13, 7]. These approaches deal with what is es-
sentially an overlap between the key-exchange part and the secure
channel part of a channel-establishment protocol by either modify-
ing the protocol, analyzing the overall protocol monolithically, or
developing methods that allow for a modular analysis despite the
overlapping phases.

The structure of the EMV protocol for establishing channels fol-
lows the recipe described above: during the key-exchange phase
itself, the channel is already used before the deployed keys are ac-
cepted; and the messages that are sent over the channel are crucial
for the security of the overall protocol. Our work can therefore be
seen as a continuation of the recent thrust on research on models
for channel establishment protocols. Below we describe the state-
of-the art for such models, identify some of their weaknesses, and
overview our results.
EXISTING MODELS FOR SECURE CHANNEL ESTABLISHMENT.
When studying the combined properties of a key establishment and
a secure channel protocol, one usually considers a security game
where the execution model and the attack interface for key ex-
change and secure channels are “glued” together; and the adver-
sary tries to break the secure channel using additional information
that possibly leaked during the key-exchange phase. In particular,
such a model also allows to analyze protocols that do not clearly
separate the two components.

There are currently two approaches to prove the security in such
a model. Very roughly, the ﬁrst approach is to relax the security
requirement on the keys by demanding that they are sufﬁciently
strong to be used for the primitives that make-up the channel, and
then show that the channel security relies only on these primitives.
This modular approach is explored in [7], where a game-based
composition theorem shows that a key-exchange protocol that is
sufﬁciently strong for the primitives and a channel whose security
reduces to these primitives automatically yield a secure protocol in
the composed security model. The approach is shown to work for
real-world protocols such as TLS.

In this paper, we prefer to avoid the machinery needed to work
within this framework and instead concentrate on the approach of
Jager et al. [13]. They propose to analyze channel establishment
protocols, monolithically, with respect to a security model devised
for this speciﬁc task. The models that they give are tailored for
TLS and are not immediately applicable for EMV. Worse, both the
original version of the model [13] and a more recent reﬁned ver-
sion [12] do not seem to appropriately capture the level of security
that one would like. In brief, the former model is too strong, to the
point that it actually rules as insecure protocols like TLS and the
one that we analyze in this paper. The reﬁned version, on the other
hand seems to be too weak, as it takes away one of the adversary’s
abilities, an ability that reﬂects possible real-world powers.

A bit more in detail, the issue concerns the ability of an adversary
to “reveal” a key, and its interaction with how “partnering” is de-
ﬁned. We explain these concepts next. Traditionally, reveal queries
model the unintended leakage of session keys from a participant to
assure that keys which leak from one session should not affect the
security of other sessions. To distinguish between the same session
and “other sessions”, key exchange protocols match each session
of a protocol with a single session of the intended partner via a
partnering mechanism [3]. One of the ﬁrst formulations of partner-
ing relies on “matching” conversations [4] (the outgoing/incoming
messages of one sessions are the same as the incoming/outgoing
messages of its partner). The requirement is that if a session ac-
cepts, then it has had a matching conversation with “the right” part-
ner. Unfortunately, in any protocol where some messages are sent
encrypted with the key that is derived, the above requirement can-

not hold. An attacker can proceed as follows. When an encrypted
message goes on the network, block it, reveal the key that was used
for encryption and then send to the recipient a different encryp-
tion of the same message, deploying fresh randomness. The two
partners will not have a matching conversation, although the proto-
col will be executed successfully. In the full version of this paper
[8] we describe an attack against entity authentication via match-
ing conversations for TLS when an adversary is permitted to reveal
keys as soon as they are derived. We stress that our attack uncov-
ers subtleties in modelling and is not an actual attack on the TLS
protocol. This attack demonstrates why neither version of ACCE is
suitable for analysing these types of channel establishment proto-
col. The original ACCE model is too strong (the attack rules TLS
insecure) and the revised too weak (the attack is no longer cap-
tured). Our model sits neatly in the middle, giving the adversary
the capabilities of this attack but not treating it as an attack against
the security of the protocol.

One approach to circumvent this attack is to preclude the ad-
versary from performing such a reveal. This is the approach taken
in [12] which only considers that keys can be revealed once the ses-
sion in which they are derived had accepted. We ﬁnd this restriction
unsatisfactory. If reveals are considered possible, then they should
be able to target a key as soon as that key has been derived. In par-
ticular, revealing a key that has just been used to perform an encryp-
tion should be allowed. A more in-depth discussion of weaknesses
present in the existent models for channel-establishment protocols
is given in the full version of this paper [8].
Our Contribution
In this paper we present a new deﬁnitional framework which ad-
dresses the problems identiﬁed in previous approaches. In particu-
lar we present a security model which is particularly tailored to the
case of key-exchange followed by the creation of a secure channel.
Our new framework is conceptually simpler than previous models
and can be further extended to capture one-sided key agreement fol-
lowed by composition with a secure channel. Providing a general
model rather than one tailored speciﬁcally to EMV is important. A
general framework can be used to analyse any channel establish-
ment protocol and sets a clear goal that all such protocols should
achieve. As a result, it is not only much easier to perform future
analyses of such protocols but also facilitates comparison of dif-
ferent protocols which have now been proved secure with respect
to the same notion of security. Below we highlight some of our
contributions and techniques.
MODELS FOR CHANNEL-ESTABLISHMENT PROTOCOLS. For en-
tity authentication, we deal with the realistic case of one-sided au-
thentication. This is demanded by the protocol that we analyze: the
card is authenticated, while the terminal is not. The EMV system is
designed to authenticate the card holder. Intuitively, the only goal,
a fraudulous terminal can pursue when interacting with a card, is
to extract authentication data from the card in order to impersonate
it later. As impersonation attacks are taken care of by secure one-
sided authenticated key agreement protocols already, one-sided au-
thentication is considered a sufﬁcient security goal in light of the
costs that a certiﬁcation structure for terminals would induce. We
remark that existing models for channel-establishment concentrate
on mutual authentication, and the case of one-sided authentication
had been considered only sporadically in the key-exchange litera-
ture.

We also resolve the issue of bad interaction between partner-
ing and reveal queries. Here, we take a different route than [13,
12]. Instead of weakening the adversary, we relax the partnering
requirement: we only demand that partners agree on a common

374session identiﬁer. This approach originates in the work of Bellare,
Pointcheval, and Rogaway [3], is standard in key-exchange litera-
ture, and reﬂects an intuitively appealing level of security.

Finally we model and analyze unlinkability properties of the pro-
posed protocol from EMVCo. One of the new design criteria of the
protocol is a mild form of unlinkability; an adversary that sees a
message ﬂow between a terminal and a card should not be able to
link this card’s current transaction with a previous transaction from
the same card. The new protocol aims to ensure this by using the
channel to secure all trafﬁc coming from the card. Thus any card
identifying information (most importantly the certiﬁcate) will never
be sent to the terminal in the clear. However the proposed protocol
also uses a performance optimization in that the card uses a small
ephemeral private key. We establish that using a small ephemeral
key in this way should be avoided.
PROTOCOL ANALYSIS & EMV RECOMMENDATIONS. The EMV
channel establishment protocol consists of a key exchange phase
and an application phase. The key exchange phase is an ECC-
based Difﬁe-Hellman-like protocol with one-sided authentication.
We analyze the EMV channel establishment protocol and identify
the assumptions under which it can be proved secure with respect
to the notion that we put forth. We end this introduction by point-
ing out a number of recommendations related to the EMV protocol
which have been passed to the designers as a result of our analysis:

1. The resulting Difﬁe–Hellman key should be hashed down to
obtain the used symmetric keys. The proposal in [16] says to
use a hash function or the x-coordinate of the elliptic curve
point as the key derivation function. The x-coordinate of an
elliptic curve point is a high-entropy value only. That is, it is
not a random string, as required by primitives such as the
ciphers that are deployed in the secure channel. We thus
strongly recommend to extract the entropy via hashing and
not use the x-coordinate directly.

2. The resulting keys should be used in a uni-directional man-
ner; thus two keys need to be obtained from the hashing pro-
cess. This avoids a large number of potential replay attacks
on the application layer. If this was not done, the application
layer would need to be implemented extremely carefully to
thwart these attacks. Having two keys, one for each direc-
tion, makes the design of a secure application layer less vul-
nerable.

3. The card ephemeral key a should not be selected from the
set {0, 1}32. We suggest that it is not restricted in size and
instead chosen at random from Fq. If the value a is selected
from the set {0, 1}32, then this has a signiﬁcant effect on se-
curity. Not only does it reduce the scheme’s ability to achieve
unlinkablity. But in addition, when a is selected from a small
set an adversary could establish two sessions of one card
which share the same key with a single terminal.

SCOPE The EMV standard has a huge scope, and not all of the
next generation sub-protocols are currently fully deﬁned. The goal
of this paper is to analyse the proposed key exchange protocol ac-
cording to the stipulated security goals while assuming as little as
possible about the other protocols. For the secure channel, we have
implicitly assumed, as this is not stated in [16], that the resulting
secure channel should be secure against adversaries both deleting
messages and playing messages out of order; since this is the usual
deﬁnition of a secure channel. We did not assume any further secu-
rity guarantees of the channel or other protocols; these need to be
deﬁned and proven separately from this paper.

2. SCHEME

Our presentation follows that in [16], augmented with informa-
tion obtained from public discussions with the authors of the proto-
col at several meetings. The basic underlying idea of the protocol
is to use a Difﬁe–Hellman key exchange in which one side (the
card) has a static public key. In order to achieve unlinkability the
certiﬁcate of this public key is not passed in the clear; instead, the
card’s static Difﬁe–Hellman key share is randomized by an addi-
tional ephemeral secret. The resulting Difﬁe–Hellman key is then
hashed using a cryptographic hash function; which we will model
as a random oracle.
The protocol uses a Difﬁe–Hellman group deﬁned over an ellip-
tic curve G = E(Fp) having group order a prime q and also uses a
base point P ∈ G. The prime q is a function of an implicit security
parameter k, but in practice the group is ﬁxed and so all our results
are given in the concrete security setting.

After the protocol has established secret keys, it uses them in a
secure channel protocol (SendCh, ReceiveCh). On input an appli-
cation message m and state ste, SendCh returns a channel message
ch. On input a channel message ch and state std, ReceiveCh returns
an application message m. The secure channel protocol is based on
a stateful authenticated-encryption (AE) scheme AE = {enc, dec}.
We assume that all plaintext headers used by the secure channel are
unauthenticated, implying that no header is sent in clear as part of
the AE scheme. The states ste and std here model the fact that
in practice sequence numbers are used to ensure that messages are
delivered in order, thus the operations are stateful. We assume that
the underlying AE scheme satisﬁes the properties of indistinguisha-
bility under chosen-ciphertext attack (IND-sfCCA) and integrity of
plaintexts (INT-sfPTXT) for such stateful schemes, assuming the
key-agreement scheme has generated a randomly distributed key.
See Appendix A for formal deﬁnitions of these security notions.

We also assume that there is a public-key signature algorithm
used to deﬁne certiﬁcates. In particular each card C has a long term
public/private key pair (QC , d), where d ∈ Fq and QC = dP ∈ G.
A certiﬁcate is a signature/message pair certC = (sigsk(QC ), QC )
provided by an issuing authority with a key pair (pk, sk) for some
(unspeciﬁed) public-key signature algorithm (sig, ver). All that we
require of the signature algorithm is that it be existentially unforge-
able under a chosen-message attack (EUF-CMA). To save space
we reserve a precise deﬁnition for this standard notion to the full
version of our paper [8].

We are now in a position to deﬁne the EMV key establishment
and secure channel protocol in Figure 1. As well as the components
above, the protocol makes use of a hash function H that takes ele-
ments in the group G and maps them onto a pair of keys for the AE
scheme. The keys are used to secure the communication in both
directions; we propose the use of two keys so that replay attacks
are prevented at the level of the protocol as opposed to needing to
be dealt with at the application layer.

As mentioned in the introduction the proposal by EMVCo [16]
suggest that the ephemeral secret1 a should be small, (less than
232). They state that this choice is “set to be ﬁt for purpose for
blinding a one-off session key”. First note that the unlinkability
property may be hard to achieve when a is small: Given two public
keys Q1 and Q2 and the ﬁrst message of a session aQi, there is an
obvious square-root attack which determines Qi when a is small,
i.e. an attack which runs in time roughly 216 operations.

More seriously, the security of entity authentication would also
be at risk. An adversary can perform an attack which allows two
sessions of a card to share the same key with a single terminal.

1In the EMV draft a is denoted r.

375Card (C)

r← Fq

a

A=aQC

−−−−−−−−−→
←−−−−−−−−−

E=eP

Terminal (T)

r← Fq

e

(κC

e , κC

d ) = H(daE)

(κT

d , κT

e ) = H(eA)

(ch, stC

e ) = SendChκC

e

(certC(cid:107)a(cid:107)QC ; stC
e )

ch

−−−−−−−−−→

(ch1, stC

e ) = SendChκC

(m1; stC
e )

e

· · ·

(m2, stC

d ) = ReceiveChκC

d

(ch2; stC
d )

ch1

−−−−−−−−−→

ch2

←−−−−−−−−−

(certC(cid:107)a(cid:107)QC , stT

d ) = ReceiveChκT

(ch; stT
d )

Check verpk(certC , QC )
?
= A

Check aQC

d

?
= true

(m1, stT

d ) = ReceiveChκT

(ch1; stT
d )

d

· · ·

(ch2, stT

e ) = SendChκT

e

(m2; stT

e ).

Figure 1: Combined Authenticated Key Agreement Scheme and Secure Channel Protocol. Note that κC

e = κT

d and κC

e .
d = κT

Consider a card with public key Q = dP and assume that the
ephemeral blinding exponents a are small. In the ﬁrst session the
card chooses a1 at random and sends a1Q. The terminal will re-
spond by choosing e at random and returning E = eP . Their estab-
lished key for this session will then be κ = a1deP . Next the card
wants to establish a second session. It chooses at random a new
ephemeral blind a2 and sends a2Q. When the ephemeral blinds
(a1 and a2) are small then an adversary can easily ﬁnd a(cid:48) = a1/a2.
The adversary can then calculate a(cid:48)E and return this to the card.
This second card session now establishes the key a2d(a(cid:48)E) =
a2d(a1/a2)eP = a1deP = κ; the same key as the ﬁrst session.
As a result of this (depending on the setting) the adversary may be
able to perform a replay attack on the second card session.

There are other approaches which could prevent the latter attack
(in cases where unlinkability is not an issue) but we believe increas-
ing the size of a to be the simplest and to offer the least chance of
implementation errors being introduced. In the rest of the paper we
assume that a is chosen from Fq and therefore our security results
apply only to this case.

3. NEW SECURITY MODELS

In this section we present our security models for the secure
channel establishment and unlinkability. Most of the section is
however devoted to the more complex case of modeling secure
channel establishment.
PRELIMINARIES. Before giving our new deﬁnition we present
some preliminary deﬁnitions. Let I be the set of participants. Each
participant has a distinct ID i, long-term public key pki and cor-
responding secret key ski. The protocol description is deﬁned by
two efﬁciently computable stateful (sub)-protocols P = {Π,G}.
The protocol Π deﬁnes how honest parties behave and G is a pub-
lic/private key pair generation algorithm. Each execution of this
algorithm maintains the following state information:

• stk ∈ {0, 1}∗ is some state for the key exchange.
• δ ∈ {derived, accept, reject,⊥} is current state of the

key exchange (initialised to ⊥).

• ρ ∈ {initiator, responder} is the role of the participant.
• sid a session identiﬁer.

• pid a partner identiﬁer
• κ = (κρ

e, κρ

d) ∈ ({0, 1}∗ ∪ {⊥})2. This is the agreed
pair of keys. The order of these keys depends on the role
ρ ∈ {initiator, responder} and κ = (⊥,⊥) unless
δ = derived.

A CLASS OF PROTOCOLS. In this paper we are concerned with the
large class of protocols obtained by combining key-exchange with
channel protocols, and where the two components cannot be easily
disentangled. Existing models are either too speciﬁc [13] or do not
consider the case of overlap between the components [7].

The syntax that we provide for such protocols naturally implies
a classiﬁcation of the different types of messages that may oc-
cur in an execution. The classiﬁcation is a crucial ingredient of
our security deﬁnitions. Speciﬁcally, we identify three different
execution “modes” of protocols: establishing a key, sending, re-
spectively receiving messages from the established channel. For-
mally, we deﬁne the honest operation of a participant by a triple
Π = (KeyExch, SendCh, ReceiveCh).

Some of the messages sent during the key-exchange may travel
over the channel so, strictly speaking, KeyExch may make use of
the latter algorithms. To facilitate the description of the resulting
complex interaction we deﬁne the algorithm EstChannel which,
essentially, is in charge of establishing the channel. This algorithm
may make calls to the algorithms deﬁning Π. As an example, for
EMV, one can view EstChannel as everything above the line drawn
in Figure 1, see Figure 4 in Section 4 for full details. At any point
during its execution protocol Π takes as input a message m and a
message type, type ∈ {ap, ch} (indicating whether the message
was received from the user’s application or the channel, respec-
tively), runs the appropriate algorithm, and returns the output of
that algorithm.

We now detail the execution of Π which is summarised in Figure
2. Prior to the channel being established (i.e. prior to δ = accept)
whenever the input message m has type ch then EstChannel will
be called. This algorithm will make calls to KeyExch in order to
establish the keys of the secure channel. The algorithm KeyExch
takes as input a message m and a state stk, and outputs a new
message m(cid:48) and updated state stk (shared with EstChannel). The
state stk is used to manage the internal state of KeyExch and will
contain the session identiﬁer sid, partner identiﬁer pid, the state
of keys δ, the established keys κe, κd, the states of the secure

376channel ste, std, and any additional information α. Before any
keys have been derived (δ =⊥), EstChannel forwards messages
directly to KeyExch. Once keys have been derived (δ = derived)
then we enter the key conﬁrmation stage. At this point EstChannel
initialises the states ste, std of the secure channel and makes ap-
propriate2 calls to SendCh and ReceiveCh before and after calling
KeyExch. Finally, once KeyExch outputs δ = accept the secure
channel has been successfully established.

After the channel has been established whenever the input mes-
sage type is ch then ReceiveCh will be called. This models mes-
sages that are received from the channel (for decryption). It takes
as input a message m and state std and outputs a message m(cid:48) for
output to the user’s application.

When the message type is ap then SendCh will be called. This
models application messages that are input to be sent (encrypted)
on the channel. It takes as input a message m and state ste and
outputs a message m(cid:48) for output to the channel. Note that if keys
have not yet been established (δ (cid:54)= accept) then such a call to
SendCh will output ⊥.

Protocol Π(m, type):
if type = ch ∧ δ (cid:54)= accept then

else if type = ch then

(m(cid:48); stk) ← EstChannel(m; stk)
(m(cid:48); std) ← ReceiveChκd (m; std)
(m(cid:48); ste) ← SendChκe (m; ste)

else (type = ap)
return m(cid:48)

Figure 2: Honest Protocol Execution

EXECUTION MODEL. We consider the standard execution model
for key exchange protocols where an adversary A, is assumed to
control all communication between participating parties i.e. the ad-
versary can intercept all messages sent and inject any message that
i denote the oracle modelling participant i ∈ I
he wishes. Let Πs
engaged in session s of the protocol described above. Each oracle
i runs the program Π and maintains the states of that program
Πs
instance. The adversary can make the following queries:

• NewSession(i, ρ): Create a session for user i with role ρ.
• Send(Πs

i , m, type): Sends a message m to Πs

i with type,

type. As a result Πs

i will run Π on input (m, type).

• Reveal(Πs
i ): reveals the current session key κ of Πs
i .
• Corrupt(i): reveals the long-term private key of i.

PARTNERING AND FRESHNESS.
In order to deﬁne security for
key-exchange protocols it is necessary to deﬁne the notion of part-
nering. Two participants should only establish a shared key if they
have been successfully partnered. There are many approaches to
deﬁning such a notion. We begin by discussing the concept of
matching conversations, introduced by Bellare and Rogaway [4]
in the context of authenticated key exchange. A participant’s con-
versation can be deﬁned as a transcript of all the messages it re-
ceives and sends. As the name suggest, matching conversations
deﬁnes two participants to be partnered if their transcripts match.
It is this approach which is followed by Jager et al. [13] in their
deﬁnition of ACCE. Unfortunately, when protocols use the session
key to encrypt messages as part of a key-conﬁrmation step, attacks

2Such calls will be dependent on the speciﬁc protocol construction.

may be possible which violate the requirements of matching con-
versations3. For further details see the full version of this paper [8].
Notice however that while such attacks violate the matching con-
versation property, they should perhaps not be considered attacks.
The plaintext that was sent by one party still reached its intended
recipient. We interpret this attack as a limitation of the model: it
may rule out as insecure protocols with no obvious weaknesses.

Our formulation is routed in the deﬁnition of partnering based
on session identiﬁers by Bellare et al. [3]. Informally, Bellare et
al. declared two oracles partnered if they have already derived keys
and i) they both share the same session identiﬁer sid, ii) they de-
rived the same key κ, and iii) one oracle is an initiator and the other
a responder. Moreover, to ensure each oracle accepted with only
a single partner we also ask that iv) there should exist no other
oracle which has derived keys and holds the same session identi-
ﬁer. Bellare et al. make a distinction between an oracle accepting
and terminating. Accepting deﬁnes the event that the session keys
have been established but the key conﬁrmation steps are still to fol-
low. An oracle terminates after the key conﬁrmation steps have
completed. Once keys are accepted they may be revealed but the
key-exchange protocol has yet to terminate. We argue that a key is
not “accepted” until after the key conﬁrmation step since this step
may fail. As a result, we use the terms derived and accepted, where
derived corresponds to Bellare et al.’s accepted and our accepted
corresponds to their terminated.

The speciﬁc formulation we give is similar but a stronger notion
than that of Rogaway and Stegers [20]. First we deﬁne a notion of
partnering which informally states that two oracles which have de-
rived keys are partners if they share the same session identiﬁer. The
deﬁnition makes use of the following predicate on two oracles Πs
i
and Πt
j), respectively:

j holding (κs

i ) and (κt

i , pids

i , sids

j, pidt

j, sidt

(cid:40)

P(Πs

i , Πt
j)
if sids
otherwise

true
false

=

i = sidt

j ∧ δs

i , δt

j ∈ {derived, accept}

Deﬁnition 1. (Partner) Two oracles Πs

i and Πt

j are said to be

partnered if P(Πs

i , Πt

j) = true.

We follow this with three further deﬁnitions related to partnering
which will be necessary when we give our main security deﬁnitions
later. It shall be required that partnerings are valid, conﬁrmed and
unique. In short these three requirements ensure that any oracle that
accepts, has a partner and that this partner is unique. More specif-
ically, Valid means that partners will have corresponding partner
identiﬁers (i.e. they both believe they are talking with each other),
have different roles and share the same key. Conﬁrmed partners
ensures that for each oracle that accepts there exists at least one
partner and for unique partners that there exists at most one.

Deﬁnition 2. (Valid Partners) A protocol P = {Π,G} ensures
valid partners if the bad event notval does not occur, where notval
is deﬁned as follows:

j such that: (cid:0)P(Πs
∧(cid:0)pids

i (cid:54)= j ∨ pidt

i , Πt

∃ Πs

j) = true(cid:1)

i , Πt

j (cid:54)= i ∨ ρs

i = ρt

j ∨ κs

i (cid:54)= κt

j

(cid:1) .

Deﬁnition 3. (Conﬁrmed Partners) A protocol P = {Π,G} en-
sures conﬁrmed partners if the bad event notconf does not occur,

3The adversary reveals the key and then uses this to re-encrypt the
conﬁrmation message with new randomness. The two transcripts
now differ for this message.

377where notconf is deﬁned as follows:

∃ Πs

i such that: δs
∧ i, pids

i not corrupt ∧(cid:0)P(Πs

i = accept

i , Πt

j) = false : ∀Πt

j

(cid:1) .

Deﬁnition 4. (Unique Partners) A protocol P = {Π,G} en-
sures unique partners if the bad event notuni does not occur, where
notuni is deﬁned as follows:

∃Πs

i , Πt
j, Πr
∧ P(Πs

k such that: (j, t) (cid:54)= (k, r)
i , Πt
i , Πr

j) = true ∧ P(Πs

k) = true.

A concept that plays a central role in deﬁning security in two-
party protocols is that of “freshness”. Intuitively, an oracle is fresh
if it has accepted and an adversary had not “tampered” with it in
any way, i.e. the adversary has not revealed or corrupted the oracle
or its partner. This can be viewed as being related to the bad event
notconf with the extra requirement that the oracle has not been re-
vealed. A notion of freshness is necessary when deﬁning security
since the security guarantees are only for such oracles. The next
deﬁnition formalises the concept. As with partnering we ﬁrst intro-
duced a predicate, F(Πs

i ) = true, if and only if:

1. δs

i = accept.

2. Oracle Πs

i has not been revealed and user i is not corrupted.
i has been revealed and no parent of

3. No partner oracle of Πs

such a oracle has been corrupted.

Deﬁnition 5. (Fresh) An oracle Πs

i is fresh if F(Πs

i ) = true.

3.1 Security Deﬁnitions: Two-Sided Authen-

tication Setting

We formulate three levels of security: entity authentication, mes-
sage authentication and message privacy. The later deﬁnitions rely
on entity authentication and we start by deﬁning that deﬁnition.
ENTITY AUTHENTICATION. We consider that an adversary vio-
lates entity authentication if he can get a session to accept even if
there is no unique session of its intended partner that has derived
the same key. More formally, we wish to verify that none of the
bad events notval, notconf, notuni occurs (cf. Deﬁnitions 2, 3, 4).
First consider the entity authentication experiment entauth that
generates public/private key pairs for each user i ∈ I (by run-
ning G) and returns the public keys to Aent. The experiment then
allows the adversary Aent to make the queries NewSession(i, ρ),
i , m, type) with oper-
Reveal(Πs
ations type ∈ {ap, ch}. We say that an adversary violates entity
authentication (and hence “wins” this experiment) if one of the bad
events (notval, notconf, notuni) occurs. The adversary’s advan-
tage is deﬁned to be:

i ), Corrupt(i) as well as Send(Πs

Adventauth

Π

(Aent) = Pr[notval ∨ notconf ∨ notuni].

Deﬁnition 6. (Entity Authentication (EA)) Protocol P = {Π,G}
is a (t, EA)-secure EA protocol if for all adversaries Aent running
in time at most t, Adventauth

(Aent) ≤ EA.

Π

To deﬁne the security experiments for message authentication
and privacy we shall make use of the following notation for lists
maintained for each Πs

i as follows:

• Application messages sent Ap-Ss
i , m, ap).
• Channel messages sent Ch-Ss

m input to Send(Πs

Send(Πs

i , m, ap).

i , i.e. the list of all messages

i , i.e. the list of all outputs from

• Channel messages received Ch-Rs
i , m, ch).
• Application messages received Ap-Rs

sages m input to Send(Πs

puts from Send(Πs

i , m, ch).

i , i.e. the list of all mes-

i , i.e. the list of all out-

As described at the beginning of this section during the execution
of a protocol an oracle can receive two types of input, an appli-
cation message (user input) or a channel message (received from
the wire). Once a channel is established whenever an application
message is input to Send, the protocol Π is run and a channel mes-
sage will be output and sent on the channel. Similarly whenever
a channel message is input to Send, the protocol Π is run and an
application message will be output to the user. The above lists help
us keep track of these messages and facilitate checks necessary in
the following security models.
MESSAGE AUTHENTICATION. We now turn our attention to mes-
sage authentication. Here we wish to ensure the integrity and au-
thenticity of all messages sent over the channel. For any two partner
i should only successfully receive
oracles Πs
messages which were output by Πt
j and vice versa. In the deﬁni-
tion which follows we formalise the intuition above by requiring
j, the following
i with unique partner Πt
that for any fresh oracle Πs
holds Preﬁx(Ap-Rs
j) = true, where Preﬁx(X, Y ) is the
i , Ap-St
function which outputs true if X is a preﬁx of Y (provided not
empty) and false otherwise. If this does not hold then the adversary
i into receiving an application message
was successfully fooled Πs
which was not output by the partnered oracle Πt
j.
Consider the authentication experiment auth that generates pub-
lic/private key pairs for each user i ∈ I (by running G) and re-
turns the public keys to A. The adversary is permitted to make
i ), Corrupt(i) as well as
the queries NewSession(i, ρ), Reveal(Πs
i , m, type) with message type ∈ {ap, ch}. On query
Send(Πs
i , m, type), the game behaves as in Figure 3(a).
Send(Πs

j, the oracle Πs

i and Πt

For the session matching, we consider the notion of partnering
as speciﬁed in Deﬁnition 1. The notion of freshness that we use in
the following deﬁnition is according to Deﬁnition 5.
Π (A) between an adver-
sary A and challenger C:

We deﬁne the following game Execauth

1. The challenger C generates public/private key pairs for each
user i ∈ I (by running G) and returns the public keys to A.4
2. A is allowed to make as many NewSession, Reveal, Corrupt,

Send queries as it likes.

3. The adversary stops with no output.

We say that an adversary A wins the game if there exists Πs
unique partner Πt
not a preﬁx of Ap-St
j.

i ) = true and the list Ap-Rs

j such that F(Πs

i with
i is

We deﬁne the adversary’s advantage as:

Advauth

Π (A) = Pr[∃Πs

j : F(Πs

i , Πt
∧ Preﬁx(Ap-Rs

i ) = true ∧ P(Πs

i , Πt
j) = false].

i , Ap-St

j) = true

Deﬁnition 7. (Message Authentication (MA)) A protocol P =
{Π,G} is a (t, M A)-secure MA protocol if for all adversaries
Aauth running in time at most t, Advauth

Π (Aauth) ≤ M A.

MESSAGE PRIVACY. Next we consider the notion of message
privacy. Our deﬁnition follows the standard indistinguishability
4Note that in the scheme considered in this paper, public keys of
cards are not actually made public to A but are sent in encrypted
form during the conﬁrmation step.

378Send(Πs
m(cid:48) ← Πs
if δ = accept and type = ap then

i , m, type) :
i (m, type)
i ← Ap-Ss

i(cid:107)m
Ap-Ss
if m(cid:48) (cid:54)= ⊥ then Ap-Rs

else if δ = accept and type = ch then
i ← Ap-Rs
return m(cid:48)

i(cid:107)m(cid:48)

(a) Send query for auth game.

i , m0, m1, type)

SendLR(Πs
if δ = accept and type = ap then
m(cid:48) ← Πs
Ch-Ss

i (mbs
i ← Ch-Ss

else if m0 (cid:54)= m1 then m(cid:48) :=⊥
else

, ap)
i(cid:107)m(cid:48)

i

m(cid:48) ← Πs
if δ = accept and type = ch then

i (m0, type)
if m(cid:48) (cid:54)= ⊥ and Πs

i has a partner Πt

j then

i ← Ch-Rs
Ch-Rs
if Preﬁx(Ch-Rs

i(cid:107)m0
i , Ch-St

j ) = true then m(cid:48) := ∅

(b) SendLR query for priv game.

return m(cid:48)

Figure 3: The Send (resp. SendLR) query for the auth (resp.
priv) games

paradigm. The adversary should not be able to determine which set
of message {m01, m02, m03, ....} and {m11, m12, m13, ....} has
been transmitted on the secure channel.

The message privacy experiment priv initializes the states as in
the authentication experiment auth, except that each session now
i . As before, the adversary can
also holds a random secret bit bs
i ), Corrupt(i). In
make the queries NewSession(i, ρ), Reveal(Πs
addition, we introduce a left-right version of Send(Πs
i , m, type)
which we use to model message privacy. Speciﬁcally, the query
i , m0, m1, type) takes as input two messages and re-
SendLR(Πs
, type). When type (cid:54)= ap we require that
turns Send(Πs
these two message are equal,

i , mbs

i

SendLR(Πs

i , m, m, type) = Send(Πs

i , m, type).

i and CSt

As before, two sessions are considered partners by Deﬁnition 1.
i , m0, m1, type) query, the game behaves as in
On the SendLR(Πs
Figure 3(b). We note that once the channel is establish, whenever
i , m, m, ch) is called (i.e. the input is a channel mes-
SendLR(Πs
sage), we allow the protocol to run as normal but check the lists
i ’s
CRs
j then SendLR will not return anything. This allows the
partner Πt
adversary to progress the state of an oracle but prevents them from
trivially winning the game. The formulation is closely related to
IND-sfCCA which we give in Appendix refapp:defn.
Π (A) between an adver-
sary A and challenger C:

j. If the message m was a channel output from Πs

We deﬁne the following game Execpriv

1. The challenger C, generates public/private key pairs for each
user i ∈ I (by running G) and returns the public keys to A.5
2. A is allowed to make as many NewSession, Reveal, Corrupt,

SendLR queries as it likes.

3. Finally A outputs a tuple (i, s, b(cid:48)).

We say the adversary A wins if its output b(cid:48) = bs
i ) =
Π (A) is set
true (and has a unique partner) and the output of Execpriv
5Note that in the scheme considered in this paper, public keys of
cards are not actually made public to A but are sent in encrypted
form during the conﬁrmation step.

i and F(Πs

to 1. Otherwise the output is 0. Formally we deﬁne the advantage
of A as

Advpriv

Π (A) = | Pr[Execpriv

Π (A) = 1] − 1/2|.

Deﬁnition 8. (Message Privacy (MP)) A protocol P = {Π,G}
is a (t, M P )-secure MP protocol if for all adversaries Apriv run-
ning in time at most t, Advpriv

Π (Apriv) ≤ M P .

We call a channel establishment protocol secure if it satisﬁes all of
the three notions above. We call the resulting notion EAMAP for
obvious reasons.

Deﬁnition 9. (EAMAP) Protocol P = {Π,G} is a (t, )-secure
EAMAP protocol if it is a (t, )-secure EA protocol, a (t, )-secure
MA protocol and a (t, )-secure MP protocol.

Remark 1. Our deﬁnitions are with respect to the speciﬁc type
of protocol construction deﬁned in Figure 2. We note however, that
our notions can be extended to more general classes of protocols
by simply placing fewer restrictions on the Send queries.

Remark 2. Our mechanism of deﬁning message authentication
by requiring that the list of messages received by a party is a pre-
ﬁx of the list of the messages sent by its partner is quite ﬂexible.
By appropriately modifying this requirement one can also capture
more relaxed notions e.g. where packet dropping or reordering is
allowed. Furthermore, we expect that with appropriate restrictions
this mechanism can also be adapted to deal with fragmentation.
This is a common feature of many secure/authenticated channels in
practice and has been formally studied by Boldyreva et al. [6], but
is not relevant for EMV.
3.2 Security Deﬁnitions: One-Sided Authenti-

cation Setting

The above security deﬁnitions enforce mutual authentication, yet
in many scenarios of practical concern only one party needs to be
authenticated. For example, the protocol we consider requires au-
thentication of the credit card but does not authenticate the com-
municating terminal. To model this situation we split our set of
participants I in two. Let C be the set of authenticated participants
(the cards) and let T by the set of unauthenticated participants (the
terminals), where unauthenticated participants do not hold a long-
term private/public key pair. This formalisation is the same as that
of registered and unregistered users in [17]. We say authenticated
participants are always initiators and unauthenticated are always
responders. As a result of this change we must alter our previous
security deﬁnitions for entity authentication, message authentica-
tion, message privacy and their combination (EAMAP) to consider
a one-sided protocol.
ONE-SIDED ENTITY AUTHENTICATION. In the one-sided setting
a terminal j ∈ T wishes to authenticate a card i ∈ C and estab-
lish a key (additionally a secure channel) with this card. Since all
j ∈ T have no long-term secret then it would always be possible
for an adversary to impersonate an unauthenticated participant and
establish a session with a real card. We need only aim to ensure
that a genuine card session is authenticated to an unauthenticated
terminal.

We ﬁrst describe informally the changes we must make to the
original two-sided deﬁnitions. Recall the deﬁnition of partnering
(cf. Deﬁnition 1 and the associated Deﬁnitions 2, 3 and 4). We are
now only concerned with the case where a terminal is partnered
correctly, i.e. for every terminal that accepts there exists a card ses-
sion and this card session is unique. As a result this means we must

379give new one-sided versions of the deﬁnitions for valid partners and
conﬁrmed partners. These new deﬁnitions now speciﬁcally focus
on the terminal, ensuring that it believes it is talking to the correct
card and it is a responder (in the case of valid), and its partner is not
corrupt (in the case of conﬁrmed). Note that we do not adjust the
uniqueness deﬁnition since we still wish to ensure that both a single
card session cannot be partnered with two terminal sessions and a
single terminal session cannot be partnered with two card sessions.
Deﬁnition 10. (One-Sided Valid Partners) Protocol P = {Π,G}
ensures valid partners if the bad event os-notval does not occur,
where os-notval is deﬁned as follows:

j such that: i ∈ T ∧ j ∈ C ∧(cid:0)P(Πs
∧(cid:0)pids

i (cid:54)= responder = ρt

i (cid:54)= j ∨ ρs

i , Πt
j ∨ κs

j) = true(cid:1)
(cid:1) .

i (cid:54)= κt

∃ Πs

i , Πt

j

Deﬁnition 11. (One-Sided Conﬁrmed Partners) Protocol P =
{Π,G} ensures one-sided conﬁrmed partners if os-notconf does
not occur, where os-notconf is deﬁned as follows:

∃ Πs

i such that: i ∈ T ∧ δs
∧ pids

i not corrupt ∧(cid:0)P(Πs

i = accept

i , Πt

j) = false : ∀Πt

j

(cid:1) .

We consider an adversary that violates one-sided entity authen-
tication if he can get a terminal session to accept if there is no
unique card session that has derived the same key. More formally,
we deﬁne the os-entauth experiment in a similar fashion to before
but now say that an adversary violates one-sided entity authentica-
tion (and hence “wins” this experiment) if one of the bad events
(os-notval, os-notconf, notuni) occurs. The adversary’s advantage
is deﬁned to be:
Advos-entauth
Deﬁnition 12. (One-Sided EA (OS-EA)) A protocol P = {Π,G}
is a (t, EA)-secure OS-EA protocol if for all adversaries Aent
running in time at most t, Advos-entauth

(Aent) = Pr[os-notval ∨ os-notconf ∨ notuni].

(Aent) ≤ EA.

Π

Π

ONE-SIDED MESSAGE AUTHENTICATION AND PRIVACY. In or-
der to adapt the deﬁnitions of message authenticity and privacy we
must consider a one-sided version of freshness. The reason behind
this again being that we wish to discount the trivial attack when
the adversary impersonates an unauthenticated terminal j ∈ T . A
card oracle is deﬁned to be OS-fresh if it has accepted, has not been
revealed or corrupted and it is partnered with a genuine terminal or-
acle. A terminal oracle is deﬁned to be OS-fresh if it has accepted,
has not been revealed and it is partnered with a card oracle that has
not been revealed or corrupted. We formalise one-sided freshness
as follows. As before we deﬁne a predicate, OSF(Πs
i ) = true, if
and only if:

1. δs

i = accept.

i has not been revealed.

2. Oracle Πs
3. If i ∈ C then it is uncorrupted and has a partner Πt

j, where

j ∈ T .

4. If i ∈ T then Πs
5. No oracle Πt

i has a partner Πt

j, where j ∈ C.
j) = true, has been re-
i , Πt

vealed and if j ∈ C then it is uncorrupted.

j, such that P(Πs

Deﬁnition 13. (One-Sided Fresh) An oracle Πs

i , is OS-fresh if

OSF(Πs

i ) = true.

Using the above we can alter our previous experiments of auth
and priv by requiring that the winning oracle is OS-fresh. We there-
fore obtain one-sided versions os-auth and os-priv, respectively.

Deﬁnition 14. (OS-MA/OS-MP) A protocol P = {Π,G} is a
if for all ad-
(A) ≤  (or

(t, )-secure OS-MA protocol (or OS-MP resp.)
versaries A running in time at most t, Advos-auth
Advos-priv
We call a channel establishment protocol with one-sided authenti-
cation secure if it satisﬁes all three of the notions above.

(A) ≤  resp.).

Π

Π

Deﬁnition 15. (OS-EAMAP) A protocol P = {Π,G} is a (t, )-
secure OS-EAMAP protocol if it is a (t, )-secure OS-EA pro-
tocol, a (t, )-secure OS-MA protocol and a (t, )-secure OS-MP
protocol.
3.3 Security Deﬁnitions: Unlinkability

A further property that the EMVCo protocol aims to achieve is
unlinkability. This means that it should be hard for an adversary
to determine when two particular sessions involve the same card.
Goldberg et al. [10] deﬁne a related notion of anonymity and un-
linkability. They aim to prove a scheme secure if an authenticated
party remains anonymous to its unauthenticated partner and hence
call this internal anonymity. Here we are concerned with eaves-
droppers external to the execution and hence deﬁne a new notion
for external unlinkability.
We deﬁne this security property in terms of a game between ad-
(A) . Informally, the adver-
versary A and challenger C, Execunlink
sary is able to interact with the card and terminal much as in the key
agreement game. At some point the adversary halts the ﬁrst part of
his game, and outputs two card identities on which it wishes to be
challenged. The challenger then picks one of these two identities
and passes to the adversary new oracles (i.e. card/terminal session)
with respect to the chosen identity. The adversary can then make
additional queries, bar Reveal or Corrupt queries on the two test
oracles. At the end of the experiment the adversary needs to output
which identity the challenger selected. More formally the game is
deﬁned as follows:

Π

1. The challenger C, generates public/private key pairs for each
user i ∈ C (by running G) and returns the public keys to A6.
2. A is allowed to make as many NewSession, Reveal, Corrupt,

Send queries as it likes.

3. At some point A outputs two identities i0 ∈ C and i1 ∈ C.
4. The challenger then chooses a bit b r← {0, 1} and creates
j, (for some j ∈ T ), by

ib and OT = Πt

new oracles OC = Πs
calling NewSession.

5. A continues making queries NewSession, Reveal, Corrupt,
Send. However, A is allowed to query oracles OC and OT
only with the Send query.

6. Eventually A stops and outputs a bit b(cid:48).

We say the adversary A wins if its output b(cid:48) = b and P(OC ,OT ) =
(A) is set to one, other-
true. In this case the output of Execunlink
wise the output is zero. We deﬁne the advantage of A to be
(A) = 1] − 1/2|.

(A) = | Pr[Execunlink

Advunlink

Π

Deﬁnition 16. (Unlinkability) A protocol (Π,G) is (t, unlink)-
unlinkable, if for all A running in time t, Advunlink
(A) ≤ unlink.
6Note that in the scheme considered in this paper, public keys of
cards are not actually made public to A but are sent in encrypted
form during the conﬁrmation step.

Π

Π

Π

3804. SECURITY ANALYSIS

In this section we state our main security results, and in particular
clarify the assumptions under which the proposed EMV channel-
establishment protocol is secure, namely the security of the signa-
ture scheme that is used to produce the certiﬁcates and, the Gap-DH
and CDH assumptions in the group that underlies the scheme. We
provide formal deﬁnitions of these assumptions later in this section.
Before stating our main security results we ﬁrst give a formal
description of the EMV protocol P = {Π,G}. Here G is the key-
generation algorithm of the underlying signature scheme. As de-
scribed at the start of Section 3, we deﬁne Π in terms of a key-
exchange protocol KeyExch and two algorithms which deﬁne the
secure channel SendCh, ReceiveCh. In order to deﬁne channel es-
tablishment we utilise an additional algorithm EstChannel which
makes calls to the underlying key exchange protocol KeyExch and
secure channel algorithms SendCh, ReceiveCh. For simplicity we
do not give a separate description of KeyExch but instead deﬁne
EstChannel directly. We require three further algorithms which
are used during the execution, loadkey, keyid, initial. An execution
of a card oracle will involve a call to loadkey which will retrieve
the public key Q, secret key d and certiﬁcate cert associated to an
identity i. Recall that Q = dP and cert = (sigsk(Q), Q). An ex-
ecution of a terminal oracle will involve a call to keyid which will
retrieve the identity j associated to a public key Q. The algorithm
initial will initialise the states of the secure channel ste, std.

In Figure 4 we deﬁne the execution of EstChannel for a session
s of a party i with state stk = (α, δ, ρ, ste, std, κe, κd, pid, sid)
where each variable is initiated as ⊥, the value α is used to store a
and A for the card and the terminal respectively.

We now state our main security result.

THEOREM 1. If the Gap-DH problem is hard, the CDH prob-
lem is hard, AE = (enc, dec) is an ind-sfcca secure and int-sfptxt
secure AE scheme, and the signature scheme (sig, ver) used to pro-
duce card certiﬁcates is EUF-CMA, then the EMV protocol P =
{Π,G} in Figures 1 and 4 is secure in the sense of OS-EAMAP. In
particular we have

• If there exists an adversary A running in time at most t
against the entity authentication property of OS-EAMAP se-
curity then there are adversaries B,C,D,E, such that
Advos-entauth

(A) ≤ Adveufcma

(sig,ver)(B)

Π

+ nC · (1 − 1/|h|) · AdvGap-DH
+ nS · nC · Advint-0
E(Fp)(E),
+ n2

C · AdvCDH

AE (D)

E(Fp) (C)

where B,C,D,E each run in time t + O(µ) where µ is total
number of bits queried.

• If there exists an adversary A running in time at most t
against the message authentication property of OS-EAMAP
security then there are adversaries B, C and D, such that
(D)
+ nC · (1 − 1/|h|) · AdvGap-DH
E(Fp) (C)
+ Advos-entauth

(A) ≤ nS · (nC + nT ) · Advintsfptxt

Advos-auth

(B),

AE

Π

Π

where B runs in time t and, C and D each run in time t +
O(µ) where µ is total number of bits queried.

• If there exists an adversary A against the message privacy
property of OS-EAMAP security then there are adversaries

EstChannel(i, m; stk):
case i ∈ C

(Q, d, cert) ← loadkey(i)
case ρ
=⊥:
= initiator:
case i ∈ T
case δ
=⊥:
= derived:
return (ch, stk)

(ch, stk) ← HelloCard(Q, stk)

(ch, stk) ← ConﬁrmCard(m, Q, d, cert, stk)

(ch, stk) ← HelloTerminal(m, stk)

(ch, stk) ← ConﬁrmTerminal(m, stk)

HelloCard(Q, stk):
Parse stk as (⊥, ⊥, ⊥, ⊥, ⊥, ⊥, ⊥, ⊥)
r← Fq; A ← aQ
a
α := a; ρ := initiator
stk := (α, ⊥, ρ, ⊥, ⊥, ⊥, ⊥, ⊥)
return (A, stk)
HelloTerminal(A, stk):
Parse stk as (⊥, ⊥, ⊥, ⊥, ⊥, ⊥, ⊥, ⊥)
ρ := responder; α := A
r← Fq; E ← eP
e
κd(cid:107)κe ← H(eA); sid := κd(cid:107)κe
δ := derived
(ste, std) ← initial(stk)
stk := (α, δ, ρ, ste, std, κe, κd, ⊥, sid)
return (E, stk)
ConﬁrmCard(E, Q, d, cert, stk):
Parse stk as (a, ⊥, ρ, ⊥, ⊥, ⊥, ⊥, ⊥, ⊥)
δ := accept
κe(cid:107)κd ← H(daE); sid := κe(cid:107)κd
(ste, std) ← initial(stk)
(ch, ste) ← SendChκe (cert(cid:107)a(cid:107)Q; ste)
stk := (a, δ, ρ, ste, std, κe, κd, ⊥, sid)
return (ch, stk)
ConﬁrmTerminal(ch, stk):
Parse stk as (A, δ, ρ, ste, std, κe, κd, ⊥, sid)
(cert(cid:107)a(cid:107)Q, std) ← ReceiveChκd (ch; std)
if verpk(cert, Q) = true ∧ aQ = A then
else δ := reject
stk := (A, δ, ρ, ste, std, κe, κd, pid, sid)
return (δ, stk)

δ := accept; pid ← keyid(Q)

Figure 4: Channel Establishment Protocol EstChannel for
EMV.

B, C and D, such that

Advos-priv

Π

(A) ≤ nS · (nC + nT ) · Advindsfcca

(D)
+ nC · (1 − 1/|h|) · AdvGap-DH
E(Fp) (C)
+ Advos-entauth

(B),

AE

Π

where B runs in time t and, C and D each run in time t +
O(µ) where µ is total number of bits queried.

where nC is the number of cards in the system, nT the number of
terminals, nS the number of sessions and |h| is the output size of
the hash function.

Note that int-0 deﬁnes security for an adversary against intsfptxt
(or intsfctxt) that is permitted no encryption oracle queries.

We now prove each of the entity authentication, message authen-

tication and message privacy properties in turn.

Before proceeding with the main proof we ﬁrst examine a related
concept of Key Secrecy for a simpler protocol, π, described in Fig-

381ure 5. To analyse this protocol we are only interested in whether the
secret key remains secret, and so we introduce a new security game
to model this fact. The security deﬁnition for Weak Key Secrecy
can in found in Appendix B.

Card (C)

a r← Fq

κ = H(daE)

A=aQC

−−−−−−−−→
←−−−−−−−−

E=eP

Terminal (T)

e r← Fq

κ = H(eA)

Figure 5: Unauthenticated Key-Agreement Scheme

Given this deﬁnition we can now analyse the protocol in Figure

5. The proof relies on the following problem being hard.

Deﬁnition 17. (Gap Difﬁe–Hellman) Let ODDH be an oracle that
solves the DDH problem in G, i.e. takes as input rP, sP, tP ∈ G,
and outputs one if tP = rsP and zero otherwise.
The Gap Difﬁe–Hellman problem then asks that given aP, bP ∈ G
where a, b r← Fq, and access to ODDH, compute abP (i.e. solve
CDH). The advantage of an adversary A against the Gap Difﬁe–
Hellman problem is deﬁned by

π

G

(A) = Pr[a, b r← Fq : AODDH (aP, bP ) = abP ].

AdvGap-DH
LEMMA 1. The weak key secrecy of the reduced protocol π is
reducible to the Gap Difﬁe–Hellman assumption, i.e. we have for
all adversaries A there exists an adversary B such that
(A) ≤ nC · (1 − 1/|h|) · AdvGap-DH

AdvwKSec

E(Fp) (B),

where nC is the number of cards in the system and |h| is the output
length of the hash function.
The proof of this lemma uses a technique ﬁrst presented by Kudla
and Paterson [14] for analysing a hashed Difﬁe–Hellman based key
agreement protocol. Our proof can be found in the full version of
this paper [8].
4.1 One-sided Entity Authentication

We now turn to proving the different properties in our main the-
orem, starting with one-sided entity authentication. We make use
of the following deﬁnition.

Deﬁnition 18. (Computational Difﬁe–Hellman) The CDH prob-
lem then asks that given rP, sP ∈ G, where r, s r← Fq, compute
rsP . The advantage of an adversary A against the CDH problem
is deﬁned by

AdvCDH

G (A) = Pr[r, s r← Fq : A(rP, sP ) = rsP ].

LEMMA 2. If the gap-DH and CDH problems are hard, AE =
(enc, dec) is an int-0 secure AE scheme, and the signature scheme
(sig, ver) used to produce card certiﬁcates is EUF-CMA, then the
EMV protocol P = {Π,G} is secure in the sense of OS-EA. In
particular, if there exists an adversary A against P = {Π,G} in
the sense of os-entauth then there are adversaries B, C, D and E
such that

Advos-entauth

Π

(A) ≤ Adveufcma

(sig,ver)(B)

+ nC · (1 − 1/|h|) · AdvGap-DH
+ nS · nC · Advint-0
E(Fp)(E),
+ n2

C · AdvCDH

AE (D)

E(Fp) (C)

where nC is the number of cards in the system, nS the number of
sessions and |h| is the output size of the hash function.

PROOF. Let A be an adversary that wins the os-entauth experi-
ment, that is the adversary succeeds in getting one of the bad events
os-notval, os-notconf, notuni to occur. Then using the inequality
Pr[A ∨ B] ≤ Pr[A] + Pr[B|¬A], we obtain:

(A)

Π

Advos-entauth
= Pr[os-notval ∨ os-notconf ∨ notuni]
≤ Pr[os-notconf] + Pr[os-notval ∨ notuni|¬os-notconf]
≤ Pr[os-notconf] + Pr[notuni]

+ Pr[os-notval|¬os-notconf ∧ ¬notuni].

In the full version of the paper [8] we prove the following bounds:

Pr[os-notconf] ≤ Adveufcma

(sig,ver)(B)

+ nC · (1 − 1/|h|) · AdvGap-DH
+ nS · nC · Advint-0

AE (D).

E(Fp) (C)

Pr[notuni] ≤ n2

C · AdvCDH

E(Fp)(E).

Pr[os-notval|¬os-notconf ∧ ¬notuni] = 0.

4.2 One-sided Message Authentication
We now turn to the message authentication property:
LEMMA 3. If the Gap-DH problem is hard in E(Fp), AE =
(enc, dec) is an int-sfptxt secure AE scheme and P = {Π,G} is
secure in the sense of os-entauth, then P = {Π,G} is secure in the
sense of os-auth. In particular if there is an adversary A against
the os-auth property then there are adversaries B,C and D such
that

Advos-auth

Π

(A) ≤ nS · (nC + nT ) · Advintsfptxt

(D)
+ nC · (1 − 1/|h|) · AdvGap-DH
E(Fp) (C)
+ Advos-entauth

(B),

AE

Π

where nC is the number of cards in the system, nT the number of
terminals, nS the number of sessions and |h| is the output size of
the hash function.

PROOF. We shall prove this result via a sequence of games. Let

A be an adversary attacking Π in the sense of auth.
(A).
Game 0: This game is identical to Execos-auth
Pr[Game0 ⇒ 1] = Advos-auth
(A).

Π

Π

Game 1: This proceeds identically to the previous game but aborts
if a terminal (i ∈ T ) oracle Πs
i accepts but has no unique partner
oracle which establishes the same key. It is easy to see that if this
event occurs then one of the events os-notval, os-notconf, notuni
has occurred. Therefore,

Pr[Game0 ⇒ 1] ≤ Pr[Game1 ⇒ 1] + Advos-entauth

Π

(B).

Game 2: This proceeds identically to the previous game but aborts
if A makes a query to H which reveals the key for an oracle Πs
i .
Again it is easy to see that

Pr[Game1 ⇒ 1] ≤ Pr[Game2 ⇒ 1] + AdvwKSec

π

(C(cid:48)

).

382Game 3: The challenger now selects at random an oracle Πs∗
game aborts if Preﬁx(Ap-Rs
Since i∗ is chosen at random from I = C ∪ T we have:

i∗ . The
j) = false for (i, s) (cid:54)= (i∗, s∗).

i , Ap-St

Pr[Game2 ⇒ 1] ≤ nS · (nC + nT ) · Pr[Game3 ⇒ 1].

i∗ , Πt∗

i∗ or Πt∗

j∗ (where P(Πs∗

It remains to study the probability that A wins (Game3 ⇒ 1). We
shall use A in Game3 to construct a new adversary D against the
INT-sfPTXT security of AE. What we effectively do is set the out-
put of the random oracle H for the key corresponding to Πs∗
i∗ to be
the key chosen at random for the INT-sfPTXT experiment. The ad-
versary D will use its enc and dec oracles to provide simulations of
A’s Send queries with Πs∗
j∗ ) = true) as
the input session. All other queries NewSession, Reveal, Corrupt
and all other Send queries will be simulated internally by D. We
further explain how Send queries for Πs∗
i∗ or Πt∗
j∗ are simulated.
When A makes a Send query for Πs∗
i∗ or Πt∗
j∗ before δ = derived,
D performs the key exchange himself by using appropriate ran-
domness. Once δ = derived, D must make calls to enc and dec
in order to perform the key conﬁrmation. Since the conﬁrmation
message received/sent by Πs∗
i∗ should be equal to that sent/received
by the partnered card/terminal session respectively, when D calls
dec he will not be given the plaintext due to restrictions on de-
cryption queries in the INT-sfPTXT model. If this happens then he
accepts the card session and sets δ = accept, otherwise he sets
δ = reject. After δ = accept whenever A makes a Send query
where type = ap or ch, D calls his enc or dec oracle, respec-
tively. Since A does not make any reveal queries or hash queries
corresponding to the key of Πs∗
i∗ the simulation remains perfect. If
A wins the auth game then Preﬁx(Ap-Rs∗
j∗ ) = false and
thus A has output a ciphertext forgery which allows D to win the
INT-sfPTXT game.

i∗ , Ap-St∗

Pr[Game3 ⇒ 1] ≤ Advintsfptxt

AE

(D).

Combining all of the above we obtain

(A)

Π

Advos-auth
= Pr[Game0 ⇒ 1]
≤ Pr[Game1 ⇒ 1] + Advos-entauth
≤ Pr[Game2 ⇒ 1] + AdvwKSec
(C(cid:48)
≤nS · (nC + nT ) · Pr[Game3 ⇒ 1] + AdvwKSec

(B)
) + Advos-entauth
(C(cid:48)

Π

Π

π

π

(B)
)

≤nS · (nC + nT ) · Advintsfptxt

(D) + AdvwKSec

π

(C(cid:48)

)

AE

+ Advos-entauth

Π

(B)

+ Advos-entauth

Π

(B)

With the ﬁnal result following from applying Lemmas 1 and 2.
4.3 One-sided Message Privacy
We now turn to the message privacy property:
LEMMA 4. If the Gap-DH problem is hard in E(Fp), AE =
(enc, dec) is an ind-sfcca secure AE scheme and P = {Π,G} is
secure in the sense of os-entauth. Then P = {Π,G} is secure
in the sense of os-priv, i.e. any adversary A against the os-priv
property can be turned into adversaries B, C and D such that

Advos-priv

Π

(A) ≤ nS · (nC + nT ) · Advindsfcca

(D)
+ nC · (1 − 1/|h|) · AdvGap-DH
E(Fp) (C)
+ Advos-entauth

(B),

AE

Π

The proof of this is similar to Lemma 3; details can be found in
the full version of this paper [8]. We again use game hopping with
almost identical hops to the previous proof. The ﬁnal step is to
argue that security in Game 3 is reducible to IND-sfCCA security.
4.4 Unlinkability

Finally, we present our theorem for unlinkability:

THEOREM 2. If gap-DH is hard and AE = (enc, dec) is an
ind-sfcca secure AE scheme, then P = {Π,G} is secure in the
sense of unlink; in particular we have

(A)

C ·(cid:16)

Π

Advindsfcca

Advunlink
≤n2
where, again, nC is the number of cards in the system and |h| is
the output size of the hash function.

(C) + nC · (1 − 1/|h|) · AdvGap-DH

E(Fp) (B)

AE

(cid:17)

Note that if a were instead chosen to be of size 232 (as suggested by
the RFC) our security analysis would show only 16 bits of security.
We refer the reader to the proof in Appendix C for further details.

5. ACKNOWLEDGEMENTS

This work was support in part by ERC Advanced Grant ERC-
2010-AdG-267188-CRIPTO. The second author was also partially
supported by a Royal Society Wolfson Merit Award. The ﬁrst au-
thor was supported by the Israel Science Foundation (grant 1076/11
and 1155/11), the Israel Ministry of Science and Technology (grant
3-9094), and the German-Israeli Foundation for Scientiﬁc Research
and Development (grant 1152/2011).

6. REFERENCES
[1] Mihir Bellare, Tadayoshi Kohno, and Chanathip

Namprempre. Breaking and provably repairing the SSH
authenticated encryption scheme: A case study of the
encode-then-encrypt-and-mac paradigm. ACM Trans. Inf.
Syst. Secur., 7(2):206–241, 2004.

[2] Mihir Bellare and Chanathip Namprempre. Authenticated
encryption: Relations among notions and analysis of the
generic composition paradigm. In Tatsuaki Okamoto, editor,
ASIACRYPT, volume 1976 of Lecture Notes in Computer
Science, pages 531–545. Springer, 2000.

[3] Mihir Bellare, David Pointcheval, and Phillip Rogaway.

Authenticated key exchange secure against dictionary
attacks. In Bart Preneel, editor, EUROCRYPT, volume 1807
of Lecture Notes in Computer Science, pages 139–155.
Springer, 2000.

[4] Mihir Bellare and Phillip Rogaway. Entity authentication and

key distribution. In Douglas R. Stinson, editor, CRYPTO,
volume 773 of Lecture Notes in Computer Science, pages
232–249. Springer, 1993.

[5] Simon Blake-Wilson, Don Johnson, and Alfred Menezes.

Key agreement protocols and their security analysis. In
Michael Darnell, editor, IMA Int. Conf., volume 1355 of
Lecture Notes in Computer Science, pages 30–45. Springer,
1997.

[6] Alexandra Boldyreva, Jean Paul Degabriele, Kenneth G.

Paterson, and Martijn Stam. Security of symmetric
encryption in the presence of ciphertext fragmentation. In
David Pointcheval and Thomas Johansson, editors,
EUROCRYPT, volume 7237 of Lecture Notes in Computer
Science, pages 682–699. Springer, 2012.

383[7] Christina Brzuska, Marc Fischlin, Nigel P. Smart, Bogdan

Warinschi, and Stephen C. Williams. Less is more: Relaxed
yet composable security notions for key exchange. IACR
Cryptology ePrint Archive, 2012:242, 2012.

[8] Christina Brzuska, Nigel P. Smart, Bogdan Warinschi, and

Gaven J. Watson. An analysis of the EMV channel
establishment protocol. IACR Cryptology ePrint Archive,
2013:31, 2013.

[9] Ran Canetti and Hugo Krawczyk. Analysis of key-exchange
protocols and their use for building secure channels. In Birgit
Pﬁtzmann, editor, EUROCRYPT, volume 2045 of Lecture
Notes in Computer Science, pages 453–474. Springer, 2001.

[10] Ian Goldberg, Douglas Stebila, and Berkant Ustaoglu.

Anonymity and one-way authentication in key exchange
protocols. Designs, Codes and Cryptography, 2012. Online
ﬁrst; print version to appear.

[11] Nadia Heninger, Zakir Durumeric, Eric Wustrow, and J.Alex

Halderman. Mining your Ps and Qs: Detection of
widespread weak keys in network devices. In USENIX
Security Symposium – 2012, pages 205–220, 2012.

[12] Tibor Jager, Florian Kohlar, Sven Schäge, and Jörg Schwenk.

On the security of TLS-DHE in the standard model. IACR
Cryptology ePrint Archive, 2011:219, 2011.

[13] Tibor Jager, Florian Kohlar, Sven Schäge, and Jörg Schwenk.

On the security of TLS-DHE in the standard model. In
Reihaneh Safavi-Naini and Ran Canetti, editors, CRYPTO,
volume 7417 of Lecture Notes in Computer Science, pages
273–293. Springer, 2012.

[14] Caroline Kudla and Kenneth G. Paterson. Modular security
proofs for key agreement protocols. In Bimal K. Roy, editor,
ASIACRYPT, volume 3788 of Lecture Notes in Computer
Science, pages 549–565. Springer, 2005.

[15] EMVCo LLC. EMV deployment statistics.

http://www.emvco.com/about_emvco.aspx?id=202, 2012.

[16] EMVCo LLC. EMV ECC key establishment protocols.

http://www.emvco.com/speciﬁcations.aspx?id=243, 2012.

[17] Paul Morrissey, Nigel P. Smart, and Bogdan Warinschi. The
TLS handshake protocol: A modular analysis. J. Cryptology,
23(2):187–223, 2010.

[18] Kenneth G. Paterson, Thomas Ristenpart, and Thomas

Shrimpton. Tag size does matter: Attacks and proofs for the
tls record protocol. In Dong Hoon Lee and Xiaoyun Wang,
editors, ASIACRYPT, volume 7073 of Lecture Notes in
Computer Science, pages 372–389. Springer, 2011.

[19] John Pollard. Monte Carlo methods for index computation

mod p. Mathematics of Computation, 32:918–924, 1978.
[20] Phillip Rogaway and Till Stegers. Authentication without
elision: Partially speciﬁed protocols, associated data, and
cryptographic models described by code. In CSF, pages
26–39. IEEE Computer Society, 2009.

APPENDIX
A. BASIC SECURITY DEFINITIONS

The underlying AE scheme we assume satisﬁes the following
two properties which are variants of the stateful security models of
Bellare et al. [1] and Paterson et al. [18].

An adversary against a stateful encryption scheme needs to be
given the capability to progress the scheme’s state without triv-
ially winning the security experiment.
It is for this reason that
there is a subtle difference between the standard notions of Indis-
tinguishability under Chosen-Ciphertext Attack (IND-CCA) and

Integrity of Plaintexts (INT-PTXT)[2], and their stateful versions
IND-sfCCA and INT-sfPTXT. An adversary against IND-sfCCA
and INT-sfPTXT security is permitted to query the decryption ora-
cle with an output from the encryption oracle in order to progress
the state but the output of this query should not be returned to the
adversary (to avoid the trivial attack).

In order to match with our security deﬁnitions of auth and priv
we alter previous IND-sfCCA of Bellare et al. [1] and introduce a
new notion for INT-sfPTXT (which is analogous to the deﬁnition
of INT-sfCTXT given by Bellare at al.) to now compare the lists
M-E and C-E with M-D and C-D respectively. In the case of IND-
sfCCA, C-E is the list of all ciphertexts output by the encryption
oracle and C-D is the list of all ciphertexts successfully decrypted
by the decryption oracle. For INT-sfPTXT the lists M-E, M-D cor-
respond to plaintext messages input to and output from the encryp-
tion and decryption oracle, respectively. In order to prevent an ad-
versary trivially winning he is not permitted to see the output of
the decryption oracle if C-D (M-D resp.) is a preﬁx of C-E (M-E
resp.), i.e. if all ciphertexts (plaintexts resp.) decrypted so far were
output by the encryption oracle in the case of IND-sfCCA or if all
plaintexts output so far were inputs to the encryption oracle in the
case of INT-sfPTXT.

Deﬁnition 19. (IND-sfCCA) Consider the scheme AE = {encκ,
decκ}. Let A be an adversary with access to a left-or-right en-
cryption oracle encκ(h, LRb(m0, m1); ste) and a decryption ora-
cle decκ(h, c; std). It is mandated that any two messages queried
to encκ(h, LRb(m0, m1); ste) have equal length. We deﬁne an ex-
periment as follows:

(A)

AE

Execindsfcca-b
κ r← {0, 1}k, C-E := ∅, C-D := ∅, ste := ∅ and std := ∅
Run Aencκ,decκ

Reply to encκ(h, LRb(m0, m1); ste) as follows:

(c, ste) r← encκ(h, mb; ste)
C-E ← C-E ∪ c; A ⇐ c
(m, std) r← decκ(h, c; std)
if m (cid:54)=⊥ then

Reply to decκ(h, c; std) as follows:

C-D ← C-D ∪ c
if Preﬁx(C-D, C-E) = false then A ⇐ m

Until A returns a bit b(cid:48)
return b(cid:48)

The attacker wins when b(cid:48) = b, and his advantage is deﬁned as

Advindsfcca

AE

(A) = 2 Pr[Execindsfcca-b

AE

(A) = b] − 1.

Deﬁnition 20. (INT-sfPXT) Consider the scheme AE = {encκ,
decκ}. Let A be an adversary with oracle access to encκ(h, m; ste)
and decκ(h, c; std). We deﬁne an experiment as follows:

384(A)

AE

Execintsfptxt
κ r← {0, 1}k, d := 0
M-E := ∅, M-D := ∅, ste := ∅ and std := ∅
Run Aencκ,decκ

Reply to encκ(h, m; ste) as follows:

(c, ste) r← encκ(h, m; ste)
M-E ← M-E ∪ m; A ⇐ c
(m, std) r← decκ(h, c; std)
if m (cid:54)=⊥ then

Reply to decκ(h, c; std) as follows:

M-D ← M-D ∪ m; A ⇐ 1
if Preﬁx(M-D, M-E) = false then d := 1

else A ⇐ 0

Until A halts
return d

The advantage Advintsfptxt

(A) of an adversary is deﬁned as

AE
Advintsfptxt

AE

(A) = Pr[Execintsfptxt

(A) = 1].

AE

In addition we deﬁne the related notion int-0 which considers an
adversary A against intsfptxt (or in fact intsfctxt) that is permitted
no encryption oracle queries.

B. KEY SECRECY
sary A and challenger C:

We deﬁne the following game ExecKSec

Π (A) between an adver-
1. The challenger C, generates public/secret key pairs for each
user i ∈ I (by running G) and returns the public keys to A.
2. Adversary A is allowed to make as many NewSession, Send,

Reveal, Corrupt queries as it likes.
3. Finally A outputs a pair Π∗ and κ∗.

We say the adversary A wins if F(Π∗) = true and κ∗ is the key
Π (A) is set to 1.
agreed by Π∗. In this case the output of ExecKSec
Otherwise the output is 0. We deﬁne the advantage of A to be

AdvKSec

Π (A) = | Pr[ExecKSec

Π (A) = 1]|.

Deﬁnition 21. (Key Secrecy) P = {Π,G} is a (t, KSec)-key se-
cret AK protocol if for all adversaries A running in time t the
following holds:

1. In the presence of a benign adversary on Πs

j both or-
acles accept holding the same session identiﬁer sid, the same
session key κ, and this key is distributed uniformly at random
on {0, 1}k.

i and Πt

2. A’s advantage is bounded by AdvKSec

Π (A) ≤ KSec.

We can also deﬁne a weaker version of this model for one-sided
authentication by running the experiment in the same way as before
but changing the winning condition slightly. We say the adversary
A wins the wKSec experiment if OSF(Π∗) = true and κ∗ is the
key agreed by Π∗.

Deﬁnition 22. (Weak Key Secrecy) P = {Π,G} is a (t, wKSec)-
weak Key-secure AK protocol if for all adversaries A running in
time t the following holds:

1. In the presence of a benign adversary on Πs

j both or-
acles accept holding the same session identiﬁer sid, the same
session key κ and this key is distributed uniformly at random
on {0, 1}k.

i and Πt

2. A’s advantage is bounded by AdvwKSec

(A) ≤ wKSec.

Π

(cid:18)

(cid:19)

.

C. PROOF OF THEOREM 2

PROOF. We shall prove this result via a sequence of games. Let

A be an adversary attacking Π in the sense of unlink.
Game 0: This game is identical to Execunlink

(A).

Π

Pr[Game0 ⇒ 1] − 1
2

(A).
Game 1: The challenger now selects at random i∗
1. The
game aborts and returns random b(cid:48) if A does not output i0 = i∗
0
and i1 = i∗

= Advunlink

0 and i∗

1. We obtain

Π

Pr[Game0 ⇒ 1] − 1
2

≤ n2
C ·

Pr[Game1 ⇒ 1] − 1
2

Game 2: This proceeds identically to the previous game but aborts
if A makes a query to H which reveals the key for the oracle O. We
obtain

Pr[Game1 ⇒ 1] ≤ Pr[Game2 ⇒ 1] + AdvwKSec

π

(B(cid:48)

).

Game 3: This proceeds identically to the previous game except that
whenever Send is called with OC and type = ap then the chal-
lenger replaces m with a random message which it then encrypts.
Again it is easy to see that we obtain

Pr[Game2 ⇒ 1] ≤ Pr[Game3 ⇒ 1] + Advindsfcca

(C).

AE

It remains to study the probability that A wins (Game2 ⇒ 1).
Since ciphertexts are now distributed uniformly at random the only
useful information that A can determine are the public keys Qi∗
,
. Since a is chosen
Qi∗
at random from Fq, then the distributions (Qi∗
) and
) are identical, i.e. the advantage is zero even if
(Qi∗
the adversary is computationally unbounded. We therefore have:

, and the blinded challenge value aQi∗

, aQi∗

, aQi∗

, Qi∗

, Qi∗

1

0

1

0

1

1

0

0

b

Pr[Game3 ⇒ 1] − 1
2

= 0.

Combining all of the above:

(A)

Π

Advunlink
= Pr[Game0 ⇒ 1] − 1
2
≤n2
C ·

Pr[Game1 ⇒ 1] − 1
2
Pr[Game2 ⇒ 1] − 1
2

(cid:19)

(cid:18)
(cid:18)
C ·(cid:16)
C ·(cid:16)

≤n2
C ·
≤n2
≤n2

(cid:19)

(B(cid:48)

)

(cid:17)

+ AdvwKSec

π

Advindsfcca

AE

Advindsfcca

AE

(C) + AdvwKSec
(C) + nC · (1 − 1/|h|) · AdvGap-DH

(B(cid:48)

)

π

E(Fp) (B)

(cid:17)

.

0

1

0

, Qi∗

, Qi∗

, aQi∗

) and (Qi∗

We note that if we were permitted to have a small (as would be
the case in the original EMV proposal) distinguishing the two dis-
tributions (Qi∗
) may no longer
be hard. Let l denote the maximum bit length of a. The real ques-
tion of interest would then be how small can l be before the above
problem becomes easy for computationally bounded adversaries. It
is clear that the best attack against the problem for 2l (cid:28) q will be
Pollard Lambda method [19], which runs in time O(2l/2). This
implies that a 32-bit randomizer a only gives 16 bits of security
and an 80-bit randomizer only gives 40 bits of security.

, aQi∗

0

1

1

385