Micropayments for Decentralized Currencies

∗

Rafael Pass
Cornell University

rafael@cs.cornell.com

†

abhi shelat
U of Virginia

abhi@virginia.edu

ABSTRACT
Electronic ﬁnancial transactions in the US, even those en-
abled by Bitcoin, have relatively high transaction costs. As
a result, it becomes infeasible to make micropayments, i.e.
payments that are pennies or fractions of a penny.

To circumvent the cost of recording all transactions, Wheeler

(1996) and Rivest (1997) suggested the notion of a prob-
abilistic payment, that is, one implements payments that
have expected value on the order of micro pennies by run-
ning an appropriately biased lottery for a larger payment.
While there have been quite a few proposed solutions to such
lottery-based micropayment schemes, all these solutions rely
on a trusted third party to coordinate the transactions; fur-
thermore, to implement these systems in today’s economy
would require a a global change to how either banks or elec-
tronic payment companies (e.g., Visa and Mastercard) han-
dle transactions.

We put forth a new lottery-based micropayment scheme
for any ledger-based transaction system, that can be used
today without any change to the current infrastructure. We
implement our scheme in a sample web application and show
how a single server can handle thousands of micropayment
requests per second. We analyze how the scheme can work
at Internet scale.

1.

INTRODUCTION

This paper considers methods for transacting very small
th to 1 penny. Traditional bank-based
amounts such as 1
10
transactions usually incur fees of between 21 to 25 cents
(in the US) plus a percentage of the transaction [16] and
thus transactions that are less than 1$ are rare because of
this ineﬃciency; credit-card based transactions can be more
expensive.

∗Supported in part by NSF Award CNS-1217821, NSF
†Supported by NSF Award CNS-0845811, TC-1111781, and

Award CCF-1214844 and AFOSR Award FA9550-15-1-0262.

the Microsoft Faculty Fellowship.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813713 .

Although several new crypto-currencies have removed the
centralized trust from a currency and have substantially re-
duced the cost of a large international transaction, they have
not solved the problem of reducing transaction fees to enable
micro-payments. In Fig. 1, we show that Bitcoin transaction
fees are usually at least 0.0001 bitcoin, which corresponds to
between 2.5 and 10 cents over the last two years. See Fig. 8
in the Appendix for another graph showing the distribution
of fees among recent transactions.

The transaction fee pays for the cost of bookkeeping, credit
risk and overhead due to fraud. Although the cost of stor-
age and processing have diminished, the cost of maintaining
reliable infrastructure for transaction logs is still noticeable.

Figure 1: A plot of transaction fee versus frequency
for 1 million transactions in May 2015. Very few
transactions have fees less than 0.0001 Bitcoin. As
of May 2015, 10k milliBitcoin, or 0.0001 bitcoin cor-
responds to roughly 2.5 cents.

One method for overcoming a transaction fee is to batch
several small transactions for a user into a large transac-
tion that occurs say, monthly. Standard implementations
of this idea, however, rely on the extension of credit to
the user from a merchant or bank, and thus, incurr credit
risk. Systems like Apple iTunes and Google play appar-
ently implement their $1 transactions using a probabilistic
model for user behavior to pick an optimal time to bal-
ance credit risk versus transaction fee. Systems like Star-
bucks attempt to sell pre-paid cards for which several or-
ders result in one credit transaction. PayPal introduced
a micropayments pricing model (5.0% plus $0.05). Simi-
larly, the Bitcoinj project (see https://bitcoinj.github.
io/working-with-micropayments) enables setting up a mi-
cropayment channel to a single predetermined party (e.g., a
single webpage): Each payer must set up a separate chan-
nel and escrow account for each merchant; moreover, the

7%80%98%0.00010.0005(cid:9)0.001+Percentage of transactionsFee (Bitcoin)207merchants require a bookkeeping system for each user (to
issue a “claw-back” transactions). In contrast, we are here
interested in a decentralized payment system where users
can make micropayments to anyone.

Lottery-based Micropayments.

Wheeler [19] and Rivest [18] suggested a intriguing ap-
proach to overcome the cost of bookkeeping for small trans-
actions. The idea in both works is to employ probabilistic
“lottery-based” payments: to provide a payment of X, the
payer issues a “lottery ticket” that pays, say, 100X with
probability 1
100 . In expectation, the merchant thus receives
100 · 100X = X, but now (in expectation) only 1 in a hun-
1

dred transactions “succeeds”, and thus the transaction cost
becomes 100 times smaller. Several implementations of this
idea subsequently appeared; most notable among them is
the Peppercoin scheme by Micali and Rivest [15] which pro-
vided a convenient non-interactive solution.

However, these elegant ideas all require a trusted third
party—either a bank or an electronic payment companies
(e.g., Visa and Mastercard)—to coordinate the transactions.
In this case, the trusted party cannot be veriﬁed or audited
to ensure that it is performing its job correctly. Further-
more, to implement these systems in today’s economy re-
quires a global change to banks and/or electronic payment
companies that handle transactions. Consequently, such so-
lution have gained little traction in real-life system.

Cryptocurrency-based Micropayments.

In this paper, we propose cryptocurrency-based micropay-
ment systems. We follow the lottery-based approach put
forth by Wheeler [19] and Rivest [18] and show how to imple-
ment such an approach using any suitable crypto-currency
system. We provide two main solutions:

• Using the current Bitcoin/altcoin scripting language,
we provide an implementation of lottery-based micro-
payments that only relies on a publicly-veriﬁable third
party; that is, anyone can verify that the third party
is correctly fulﬁlling its proper actions. This solution
also enables performing transaction with fast valida-
tion times (recall that standard Bitcoin transactions
require roughly 10 minute validations, which is unde-
sirable in the context of micropayments). Using this
solutions, bitcoin-based micropayments can be imple-
mented today without any change to the current in-
frastructure.

• We also suggest simple modiﬁcations to the Bitcoin
scripting language that enables implementing lottery-
based micropayments without the intervention of any
third party. Furthermore, this scheme can be directly
implemented in the Ethereum currency [7] without any
modiﬁcation to the scripting language.
(Validation
times for transaction, however, are no longer faster
than in the underlying cryptocurrency.)

At a high-level, the idea behind our solution is the following:
The user starts by transferring 100X into an “escrow”. This
escrow transaction has an associated “puzzle”, and anyone
that has a solution to this puzzle can spend the escrow.
Roughly speaking, the solution to the puzzle consists of a
signed transcript of a cryptographic coin-tossing protocol
(where the signature is w.r.t. to the user’s public key) such

that the string computed in the coin-tossing ends with 00 (an
event that happens with probability 1/100 by the security
of the coin-tossing protocol).

Whenever the payer wants to spend X, it engages with a
merchant in a coin-tossing protocol and agrees to sign the
transcript. The merchant thus receives a signed coin-tossing
transcript in every transaction, and additionally, with prob-
ability 1/100, the coin-tossing transcript yields a solution
to the puzzle (i.e., the string computed in the coin-tossing
protocol ends with 00). The merchant can thus spend the
money (i.e., 100X) placed in escrow.

This approach, which we refer to as MICROPAY1, how-
ever, cannot be directly implemented today because of limi-
tations in crypto-currency scripting languages. Additionally,
as mentioned above, validation times for Bitcoin transac-
tions are high which makes Bitcoin undesirable for micropay-
ments. (Neither issue is inherent for cryptocurrencies and
thus MICROPAY1 may be the best solution for low-latency
cryptocurrencies with expressive scripting languages.)

Our next solution, MICROPAY2, makes use of a veriﬁable
trusted third party—which we refer to as a Veriﬁable Trans-
action Service (VTS)—to overcome these issues. Roughly
speaking, the VTS performs a speciﬁc polynomial-time com-
putation and signs certain messages in case the computa-
tions produce a speciﬁed desired result:
in our case, the
VTS checks whether a coin-tossing transcript is “winning”,
and if so it “releases” the escrow by signing some release
transaction. Thus, anyone can verify that the VTS only
signs messages correctly (by checking that the computation
indeed gave the desired result). Furthermore, the VTS is
only invoked on “winning” transactions (i.e., on average ev-
ery 1/100 transactions.) and can thus handle a large vol-
ume of transactions. Additionally, if the VTS only agrees
to sign the escrow release once, MICROPAY2 implements
fast transaction validation times. That is, merchants can be
assured that as long as the VTS is acting honestly, as soon
as they receive back a signature from the VTS, they will
receive their payment without having to wait 10 minutes for
the transaction to appear on the block-chain. Furthermore,
if the VTS is acting dishonestly (i.e., if it signs multiple
times), this will be observed. (Using a standard approach
with locktime, our protocol can also be slightly modiﬁed to
ensure that the user can always recover its money from the
escrow within some pre-determined expiration time.)

Finally, MICROPAY2 can be modiﬁed into a solution
called MICROPAY3 where the VTS never needs to be acti-
vated if users are honest—i.e., it is an “invisible” third party.
This solution, however, cannot have faster validation times
than the underlying cryptocurrency.

Generalization to “Smart-Contracts”.

We mention that our solution provides a general method

for a user A to pay x to diﬀerent user B if some pre-determined
polynomial-time computation produces some speciﬁc output
(in the micropayment case, the polynomial time computa-
tion is simply checking whether the most signiﬁcant two bits
of the random tape are 00.)

Projects like Ethereum [7] provide Turing-complete script-
ing languages for crypto-currencies. These systems require a
much more sophisticated mechanism to evaluate the scripts
associated with transactions in order to prevent attacks.
Our methods enable extending these “smart-contract” to
deal with probabilistic events (such as our micro-payment

208“lottery-tickets”). Furthermore, we enable using other cur-
rent cryptocurrencies (such as Bitcoin) to implement a large
class of “smart-contracts” even if the contract may be writ-
ten in a more complex language than what is currently
supported by the scripting languages for the currency. Fi-
nally, our method enables using “soft” contracts, where the
polynomial-time processes that determines if A should pay x
to B may take as inputs also facts about the world (e.g., the
whether the “Red Sox beat Yankees” in a particular game),
or the process may even be speciﬁed in natural language, as
long as the outcome of the process can be publicly veriﬁable.

Applications of our Micropayment System.

We outline some applications that may be enabled by our
system. We emphasize that none of these applications re-
quire any changes to current transactional infrastructures.
To make these applications feasible however, it is critical
that the user only needs to setup once, and be able to in-
teract with any number of merchants, as opposed, to say,
a “channels” system which requires the user to perform a
diﬀerent escrow transaction with each merchant.

An Ad-Free Internet: Our micropayment system could
be used to replace advertisements on the Internet. Users
can request an “ad-free version” of a webpage by us-
ing the protocol httpb:// (instead of http://) which
transparently invokes our micropayment protocol and
then serves a page instead of having the server display
an ad on the requested page. In Section 4, we report
on an implementation of this idea.

Pay-as-you-go Games and Services: Our micropayment
system could be used to enable pay-as-you go WiFi in-
ternet connections where users pay for every packet
they send.
Internet content providers (e.g., newspa-
pers, magazines, blogs, music and video providers) and
game-writers could charge for every item requested by
the user, or for game-playing by the minute.

Generalized wagering In some of our schemes, a trusted
party is used to sign a message if a certain event occurs.
In our case, the event relates to a coin-tossing protocol
that is executed between two parties. In general, one
can imagine that the trusted-party signs statements
about worldly events that have occurred such as “Red
Sox beat Yankees” or “Patriots win Super Bowl”, or
interpret the outcome of contracts written in natural
language. Using such a party, our protocols can be
generalized to enable wagers that are implemented en-
tirely without a bookkeeper, and only require the par-
ties to trust a 3rd party who can digitally sign facts
that can be publicly veriﬁed.

1.1 Prior work

Electronic payments research is vast. Our work follows
a series of paper [19, 18, 12, 15] on the idea of probabilis-
tic payments. Our work improves those papers by remov-
ing or simplifying the trust assumptions and bootstrap re-
quirements for their systems by using a crypto-currency, by
simplifying the cryptographic assumptions needed, and by
demonstrating a practical system in a web-server that im-
plements the protocol. Some of those prior works focus on
reducing the number of digital signatures required by the
protocol: this concern is no longer a bottleneck. Moreover,

none of those scheme focus on how to implement the transfer
(they all require a bank to handle it).

An older form of digital currency is studied in [6, 5, 13].
These schemes rely on digital signatures from a trusted-third
party (such as a bank) to record transfer of ownership of a
coin. Various (online and oﬀ-line) methods are considered
to prevent double-spending attacks. The schemes are not
optimized for handling micropayments, and the economics
of the scheme do not depart from the economics of current
credit-card or ACH network based transactions.
In some
cases, the schemes oﬀer a level of anonymity not provided
by credit-cards etc.

Coupon-based schemes [10, 1, 17] are similar and require
a trusted-party to issue coupons to users, then users spend
these coupons with merchants, who then return the coupon
to the trusted-party. The main focus for this line of research
was to optimize the cryptographic operations that were nec-
essary; today, these concerns are not relevant as we show in
our evaluation section (see §4). Furthermore, these schemes
have double-spending problems and require a trusted-party
to broker all transactions and issue and collect coupons.

A few recent works discuss lotteries and Bitcoin, but none
focus on reducing transaction costs or allowing a single setup
to issue micropayments to an unlimited number of mer-
chants. Andrychowicz et al. [2] implement Bitcoin lotteries
using O(n) or O(n2) ledger transactions per lottery where n
is the number of players. Bentov and Kumaresan [3] discuss
UC modeling and achieving fairness in secure computation
by providing an abstract description of how to enforce penal-
ties with Bitcoin through a novel “ladder mechanism” that
uses O(n) transactions per penalty. In contrast, the main
idea in our work is to amortize 2-3 transaction fees over
thousands of lottery protocol instances.

The goal of Mixcoin [4] is anonymity, and with this dif-
ferent motivation (see its footnote 12), the paper describes
how to charge for mixing in a probabilistic way. Their mech-
anism diﬀers in that it uses a random beacon, i.e. a public
trusted source of randomness for the lottery, which does not
work for micropayments.

As mentioned, the Bitcoinj project (see https://bitcoinj.

github.io/working-with-micropayments) enables setting
up a micropayment channel to a single predetermined mer-
chant (e.g., a single webpage), by establishing a new address
for the merchant, so this scheme falls short of our goal of one
decentralized payment system where users can make micro-
payments to anyone.
1.2 Outline of the paper

In Section 2 we provide a detailed description of our pro-
tocol in an abstract crypto-currency scheme. This model
leaves out many of the implementation details behind the
currency protocol but enables describing our solution in a
convenient way; in essence, this abstract model captures the
principles underlying all modern ledger-based transactional
systems (such as bitcoin and all alt-coins). In Section 3 we
next describe how to implement the abstract solution us-
ing the actual Bitcoin scripting language and formalism. In
Section 4 we describe our implementation and present ex-
periments to demonstrate the practical feasibility of our MI-
CROPAY2 solution. In particular, we report on the above
mentioned “ad-free internet” application.

2092. PROTOCOLS

2. c = Com(r1; s),

Abstract Model for Crypto-currencies.

A cryptocurrency system provides for a way to implement
a distributed ledger specifying how coins are transferred; we
here ignore how miners are incentivized to ensure that the
ledger is available and not manipulated. We will, however,
be concerned about how coins are transferred. Very roughly
speaking, transactions are associated with a public-key pk
and a “release condition” Π. A transaction from an address
a1 = (pk, Π) to an address a2 = (pk(cid:48), Π(cid:48)) is valid if it speci-
ﬁes some input x that satisﬁes the release condition Π, when
applied to both applied to a1 and a2; that is Π(x, a1, a2) = 1.
The most “standard” release condition Πstd is one where a
transaction is approved when x is a signature with respect to
the public key pk on a2; that is, pk is a public-key for a sig-
nature scheme, the “owner” of the address has the secret key
for this signature scheme (w.r.t. pk), and anyone with the se-
cret key for this signature scheme can transfer bitcoins from
the address by signing the destination address. The bitcoin
protocol speciﬁes a restrictive script language for describing
the release condition Π; see Section 3 for more details on
this script language. In this section, we ignore the concrete
formalism of the scripting language and instead describe our
solutions in prose.
2.1 MICROPAY 1

We ﬁrst provide a solution that uses a release condition
Π that does not require any third party at all, but cur-
rently cannot be implemented in the bitcoin scripting lan-
guage. However, it can be directly implemented in crypto-
currencies using more expressive script languages, such as
Ethereum [7].

The only cryptographic primitive that we rely on (apart
from digital signatures) is that of a commitment scheme (see
[11] for details) which can be implemented with any hash
operation such as sha or ripemd; both are supported in
most crypto-currency scripting languages.

Escrow Set-up: To initialize a “lottery-ticket”, a user U
with a = (pk, Πstd) containing 100X coins generates a
new key-pair (pkesc, skesc) and transfers the 100X coins
to an escrow address aesc = (pkesc, Πesc) (by signing
(a, aesc) using its key corresponding to pk). For easy
of exposition, we postpone specifying the release con-
dition Πesc.

Payment Request: Whenever a merchant M wants to
request a payment of X from U , it picks a random
number r1 ← {0, 1}128, generates a commitment c ←
Com(r1; s) (where s represents the string that can be
used to open/reveal the commitment), generates a new
bitcoin address a2 (to which the payment should be
sent) and sends the pair (c, a2) to the payer U .

Payment Issuance: To send a probabilistic payment of
X, user U picks a random string r2, creates a signa-
ture σ on c, r2, a2 (w.r.t. to pkesc) and sends σ to the
merchant. The merchant veriﬁes that the signature is
valid.

We now return to specifying the release condition Πesc.

Deﬁne Πesc(x, aesc, a2) = 1 if and only if

1. x can be parsed as x = (c, r1, s, r2, σ)

3. σ is a valid signature on (c, r2, a2) with respect to the

public key pkesc and

4. if the ﬁrst 2 digits of r1 ⊕ r2 are 00.

In other words, the merchant can ensure a transfer from the
escrow address to a2 happens if it correctly generated the
commitment c (and knows the decommitment information
r1, s), and then sent c, a2 to U ; U agreed to the transaction
(by providing a valid signature on c, r2, a2), AND it “won”
the lottery using r1 ⊕ r2 as randomness.

Security Analysis.
It can be shown using standard arguments that the “coin-
tossing” r1⊕r2 cannot be biased (by more than an negligible
amount) by either the merchant or the user (if the merchant
can bias it, it can either break the binding property of the
commitment, or forge a signature; if the user can bias it,
it can break the hiding property of the commitment.) As
a consequence, whenever the user agrees to a transaction,
the merchant has a 1/100 (plus/minus a negligible amount)
chance of getting a witness which enables it to release the
money in the escrow address. More precisely, the following
properties hold:

• [P1] Consider some potentially malicious user that
correctly signs a transaction with non-negligible prob-
ability. Then, conditioned on the event that the user
produces an accepting signature on a transaction, the
merchant receives a witness for the escrow address with
probability at least 1/100 (minus a negligible amount)
as long as the merchant honestly follows the protocol.
• [P2] Even if the merchant is arbitrarily malicious, it
cannot receive a witness for the escrow address with
probability higher than 1/100 (plus a negligible amount),
as long as the user honestly follows the protocol.

2.2 MICROPAY2: Using a VTS

MICROPAY1 requires using a release condition Πesc that
uses two operations that currently are not supported in the
bitcoin scripting language. First, while digital signatures are
supported in the script language, the language only permits
checking the validity of signatures on messages derived from
the current transaction in a very speciﬁc way; the checksig
operation does not directly allow signature veriﬁcation on
messages of the form that we use in the protocol. A second
problem is that arithmetic operations can only be applied
to 32-bit values. In Section 3.2, we describe some minimal
changes to the bitcoin scripting language that can allow the
MICROPAY1 scheme to be implemented.

To overcome both issues without modifying the Bitcoin
scripting language, we present a scheme that uses a (partially-
trusted) third party T , which we refer to as a Veriﬁable
Transaction Service (VTS. T ’s only task will be to verify
certain simple computations and, if the computations are
correct, will release a signature on a transaction. If T ever
signs a transaction that corresponds to an incorrect compu-
tation, there is irrefutable evidence that (unless the signa-
ture scheme is broken) T “cheated” (or has been corrupted),
and so T can be legally punished and/or replaced.
(To
achieve greater robustness against corruption of T , we can
generalize the solution to use multiple parties T1, T2, . . . Tn,

210and only require that a majority of them correctly check the
computations.)

MICROPAY2 follows the structure of MICROPAY1 with
the key diﬀerence being that we use a diﬀerent release script
˜Πesc. This new release condition will require two signatures
on a transaction (i.e. a multi-signature), one from the user,
and one from the trusted party T . Roughly speaking, U
will always provide M a signature, and in case of a winning
ticket, T will verify that the lottery ticket was winning and
then provide a second signature to release the transaction
to M . That is, ˜Πesc((σ1, σ2), aesc, a2) = 1 if and only if σ1
is a signature of the transaction (aesc, a2) with respect to
pkesc and σ2 is a signature of the transaction (aesc, a2) with
respect to pkT , where pkT is T ’s permanent public key.

In more details, the system involves the following steps:
• Escrow Set-up: To initialize a “lottery-ticket”, a user
U with an address a = (pk, Πstd) containing X bitcoins
generates a new key-pair (pkesc, skesc) and transfers the
X bitcoins to an “escrow” address aesc = (pkesc, ˜Πesc)
(by signing (a, aesc) using its key corresponding to pk).
• Payment Request: This step is identical to the one
in MICROPAY1: Whenever a merchant M wants to
request a payment of X/100 from U , it picks a random
number r1 ← {0, 1}128, generates a commitment c =
Com(r1; s) (where s represents the string that can be
used to open/reveal the commitment), generates a new
bitcoin address a2 (to which the payment should be
sent) and sends the pair (c, a2) to the payer U .

• Payment Issuance: If the user U agrees to send a
probabilistic payment pay X/100, it picks a random
string r2, creates 1) a signature σ1 on the transaction
(aesc, a2), and 2) a signature σ on (c, r2, a2) (w.r.t. to
pkesc), and sends σ1, σ to the merchant M . The mer-
chant veriﬁes that the signatures are valid.

• Claim Prize: If merchant M has received a winning
lottery ticket, then M sends T the triple (x, aesc, a2). T
computes a signature σT on the transaction (aesc, a2)
using public key pkT and sends it to M if and only
if x = (c, r1, s, r2, σ), c = Com(r1; s), σ is a valid
signature on (c, r2, a2) w.r.t. pkesc, and the last 2 digits
of r1 ⊕ r2 are 00.
Furthermore, T publishes the tuple x (either on its
own bulletin board, on the blockchain, or some other
“alt-chain”). If T ever signs (aesc, a2) without having
made public a “witness” x, it is deemed faulty. T ’s only
job is to verify whether a lottery ticket is “winning”
and if so agree to transfer the money to the merchant;
additionally, whenever it agrees to such a transfer, it
needs to publish a witness that enables anyone to check
that its action was correctly performed.

Finally, once M has received the signature σT from T ,
then M can spend aesc to address a2 (which it controls)
using σ1, σT to satisfy the release condition ˜Πesc.

Security Analysis.

The following claims can be easily veriﬁed using standard

cryptographic techniques:

• If T acts honestly, then properties P1 and P2 from

Section 2.1 hold.

• If T deviates from its prescribed instructions, then (a)
except with negligible probability, this can be publicly
veriﬁed, and (b) the only damage it can create is to
bias the probability that the escrow is released in an
otherwise approved transaction.

By the second claim, T can never “steal” the escrow money.
By cheating, it can only transfer the money to a merchant
(even for a losing lottery ticket), but only to a merchant to
whom the user agreed to issue a (micropayment) transac-
tion. Additionally, by cheating, it can withhold a payment
for a merchant. By the ﬁrst claim, if T performs either of
these (cheating) actions, this can be noticed.

Fast Validation Times.

We ﬁnally remark that if T only agrees to sign the escrow
release once, MICROPAY2 implements fast transaction vali-
dation times. That is, merchants can be assured that as long
as the T is acting honestly, as soon as they receive back a
signature from T , they will receive their payment (without
having to wait 10 minutes for the transaction to appear on
the block-chain). Furthermore, if the VTS is acting dishon-
estly (i.e., if it signs multiple times), this will be observed.
(Additionally, using a standard approach, our protocol can
be slightly modiﬁed to ensure that the user can always re-
cover its money from the escrow within some pre-determined
exipration time.)

2.3 MICROPAY3: Using an “Invisible” VTS
MICROPAY2 requires the intervention of T in every win-
ning transaction. We now present an optimistic solution
MICROPAY3 where the VTS T is only invoked when either
user or merchant deviates from their prescribed instructions.
In this sense, the trusted third party T is invisible in the op-
timistic (honest) case. (MICROPAY3, however, no longer
implements faster validation time than Bitcoin.)

MICROPAY3 proceeds similarly to MICROPAY2, with
the key diﬀerence being that we now use 2 escrow addresses.
Roughly speaking, the idea is that U should release the
money to M whenever M receives a winning ticket. The
problem with naively implementing this approach is that
whenever U learns that M received a winning ticket, it may
try to spend the escrow back to itself before M can claim
the escrow.

To prevent this attack, we use two escrow addresses. Money
from the ﬁrst escrow address gets released if U agrees to a
(micro)-transaction to M . Money from the second escrow
address can only be released to either a) M if either U or T
agree, or b) U if T agrees. Speciﬁcally, whenever M has a
winning ticket, it spends the money from escrow 1 to escrow
2. It then asks U ’s help to spend from escrow 2 to its own
address. Note that by condition a) U can only release from
escrow 2 to M , so there is no way for U to (on its own)
“revoke” the escrow when it learns that M won. If U is not
willing to release escrow 2, M can contact T to spend escrow
2. Condition b), on the other hand, is used to prevent M
from “orphaning” escrow 1 to escrow 2 even when it does
not have a winning ticket. Note that M can always transfer
the money from escrow 1 to escrow 2 as long as U agrees to
a micropayment (even if M didn’t win the lottery). When
this happens, U can request that T spends the escrow back
to U . We can implement this idea using multi-signatures.

2112

(σ2, aesc

2

1 , aesc

1 , aesc

1 (σ1, aesc

2 ) w.r.t pkesc

Let (cid:101)Πesc
Deﬁne (cid:101)ΠaU ,aM
condition (cid:101)ΠaU ,aM

a2 = aM and σ2 is a signature of the transaction (aesc
w.r.t pkesc
the transaction (aesc

2 ) = 1 if and only if σ1 is a signa-
ture of the transaction (aesc
1 . This condi-
tion can be implemented with a standard release condition.
2 , a2) to be 1 if and only if either (a)
2 , aM )
2 or pkT , or (b) a2 = aU and σ2 is a signature of
2 , aU ) w.r.t pkT . Formally, the release
can be encoded by taking the OR of two
multi-signature requires: either there is a 2-out-of-3 multi-
signature by parties U , M , and T , or there is a 2-out-of-2
multi-signature by U and T . In the optimistic case, parties
U and M provide signatures on a transaction to aM and sat-
isfy the ﬁrst clause of the OR condition; if U refuses, then
parties M and T can provide signatures on a transaction
to aM , and if M orphans an escrow, then parties U and T
can provide signatures on transaction to aU and satisfy the
second clause of the OR-condition.

• Escrow Set-up: To initialize a “lottery-ticket”, a user
U with an address a = (pk, Πstd) containing X bit-
coins generates a new key-pair (pkesc
1 ) and trans-
fers the X bitcoins to the ﬁrst “escrow” account aesc
1 =
(pkesc
1 ) (by signing (a, aesc) using its key corre-
sponding to pk).

1 ,(cid:101)Πesc

1 , skesc

• Payment Request: This step is the same as in MI-
CROPAY1; M sends the pair (c, aM ) to the payer U .
• Payment Issuance: If the user U wants to agree to
send a probabilistic payment pay X/100, it picks a ran-
dom string r2, generates a new address aU , generates a
2 , ˜ΠaU ,aM
new key-pair (pkesc
).
It then creates 1) a signature σ1 on the transaction
2 ), and 2) a signature σ on c, r2, aM (w.r.t. to
1 , aesc
(aesc
1 ), and sends aU , aesc
pkesc
2 , σ1, σ to the merchant. The
merchant checks that aesc
is well formed (i.e, that the
2
˜ΠaU , aM ) and that signatures are
release condition is
valid.

2 ) and lets aesc

2 = (pkesc

2 , skesc

• Claim Prize: If M has received a winning lottery
1 , aesc
ticket, then M ﬁrst publishes the transaction (aesc
2 )
to the ledger using the signature σ1 to satisfy the re-
lease condition.

1 , aesc

Once this transaction has been conﬁrmed on the blockchain,
M convinces U that it has a winning lottery ticket, and
then asks U for a signature that allows it to spend aesc
2
to aM . Speciﬁcally, M sends U a tuple (x, aesc
2 , aM )
such that x = (c, r1, s, r2, σ), c = Com(r1; s), σ is a
valid signature on (c, r2, aM ) w.r.t. pkesc
1 , and the last
2 digits of r1 ⊕ r2 are 00. After verifying all of those
2 , aM )
conditions, U computes a signature σ2 on (aesc
w.r.t. pkesc
2 and sends the signature to M .
2 , aU ) to the
Finally, M publishes the transaction (aesc
ledger using σ2 (and a signature it computes on its own
w.r.t. pkM ) as the release condition. If U does not send
M a valid signature σ2 within a certain timeout, then
M invokes the Resolve Aborted Prize method.

1 , aesc

• Resolve Aborted Prize: When T receives a tu-
2 , aM ) such that x = (c, r1, s, r2, σ), c =
ple (x, aesc
Com(r1; s), σ is a valid signature on (c, r2, aM ) w.r.t.
1 , and if the last 2 digits of r1 ⊕ r2 are 00, T signs
pkesc
2 , aM ) w.r.t. pkT .
(aesc

• Resolve Orphaned Transaction: When T receives
a request (aesc, aU ) from U to resolve an “orphaned”
transaction ending up in escrow aesc
2 , it waits an ap-
propriate amount of time (say 10 minutes), to ensure
that any merchant that has a prize to claim has time
to do it. If nobody claimed the prize for escrow aesc
2 ,
T signs (aesc

2 , aU ) w.r.t. pkT .

Security Analysis.

It follows using standard cryptographic techniques that
the same security claims that held w.r.t. MICROPAY2 also
hold for MICROPAY3. Additionally, note that if U and M
are both executing the protocol honestly, T is never invoked.
2.4 Making Our Schemes Non-interactive

In all of our MICROPAY schemes, the merchant must
send the ﬁrst message to the payer, which is followed by the
payer “conﬁrming” the transaction. In some situation it may
be desirable for the merchant to be able to post a single, ﬁxed
ﬁrst message, that can be resued for an any number of users
(payers) and any number of transactions (and the payer still
just sends a single message conﬁrming the transaction).

We generalize ideas from Micali and Rivest [15]1 to modify
our scheme to be non-interactive in this respect. We present
this technique concretely for the MICROPAY1 scheme, but
note that the technique applies to all of our schemes. This
technique requires each transaction to be uniquely identiﬁed
by both Payer and Merchant; e.g. the rough time-of-day and
IP-address of the payer and merchant, which we denote as
t, can be used to identify the transaction.

Merchant Set-up: The merchant samples a veriﬁable un-
predictable function (VUF) [14] fm and a bitcoin ad-
dress aM and publishes fM , aM .

Escrow Set-up: The payer follows the same instructions
to setup an escrow; the release condition for the escrow
requires a witness (σ, y, π, t, aM ) such that

1. σ is a signature on (t, aM , fM ) w.r.t. to pkesc

2. π certiﬁes that fM (σ) = y (recall that each VUF
is associated with a proof systems which enables
certifying the output of the VUF on a particular
input).

3. H(y) begins with 00, where H is a hashfunction

(modeled as a random oracle).

Payment Issuance: To send a probabilistic payment of
X/100 for transaction t, the payer retrieves the func-
tion fM for the merchant, computes a signature σ on
t, aM , fM (w.r.t. to pkesc) and sends σ to the merchant.
The merchant veriﬁes that the signature is valid.

Claim prize: The merchant’s ticket is said to win the lot-

tery if H(fm(σ)) begins with 00.

1The central diﬀerence is that we rely on a veriﬁable un-
predictable function (VUF), whereas [15] rely on a verﬁable
random function (VRF); see [14] for deﬁnitions of these no-
tions. Relying on a VUF enables greater eﬃciency.

212Efﬁcient instantiations of VUFs.

Practical VUFs in the Random Oracle Model can be based
on either the RSA assumption (as in [15]), or the Compu-
tational Diﬃe-Hellman assumption, as we now show. This
new VUF (which leads to greater eﬃciency than the RSA
based one used in [15]) is the same as a construction from [9]
but for our purposes we only need to rely on the CDH as-
sumption (whereas [9] needs the DDH assumption). Let
G be a prime order group in which the CDH problem is
hard and g is a generator. The VUF is indexed by a secret
seed r ∈ Zq, and the public description of the function is
G, g, gr. On input y, the VRF evaluates to H(y)r, where
H is a random oracle, and produces a proof π which is a
non-interactive zero-knowledge proof in the random oracle
model that the pair (g, gr, H(y), H(y)r) form a DDH triple.
We further develop this scheme in the full version.

3.

IMPLEMENTATION IN BITCOIN

In this section, we describe how our schemes can be imple-
mented in Bitcoin. We begin with a more formal description
of the Bitcoin protocol.
3.1 Formal description of the Bitcoin protocol
A ledger consists of an (ordered) sequence of blocks, each
block consists of a sequence of transactions. Blocks and
transactions are uniquely identiﬁed by a hash of their con-
tents. Each transaction consists of a sequence of inputs and
a sequence of outputs. An input consists of a triple (tin, i, ω)
where tin is the identiﬁer (hash) of a previous transaction,
i is an index of an output in transaction tin, and ω is the
input script or the “cryptographic witness to spend the ith
output of transaction tin.” The ith output of a transaction t
consists of a triple (a, x, Πt,i) where a is an address, x is an
amount of Bitcoin, and Πt,i is a “release condition”, i.e. a
predicate that returns either true or false. A “cryptographic
witness” to spend an output (tin, i) is a string ω such that
Πtin,i(ω) = 1.

1,4) where h(cid:48)

An address a is formed from the public key of an ECDSA
key pair as follows: generate an ECDSA key pair (ask, apk),
then compute the hash h ← 00||ripemd-160(sha256(apk)),
compute a checksum h(cid:48) ← sha256(sha256(h)), and ﬁnally
compute the address a ← base58(h||h(cid:48)
1,4 are the
ﬁrst four bytes of h(cid:48) and base58 is a binary-to-text encoding
scheme2. Thus, given a public key pk, one can verify that it
corresponds to a particular address apk.
Suppose the i-th output of transaction tin is (a(cid:48), Π(cid:48), x(cid:48)).
An input (tin, i, ω) is valid if the following holds: (a) ω and
Π(cid:48) can be interpreted as a bitcoin script, and (b) after ex-
ecuting ω and then executing Π(cid:48) on a stack machine, the
machine has an empty stack and its last instruction returns
true. A transaction is considered valid if each of its inputs
are valid, and the sum of the amounts of the inputs is larger
than the sum of the amounts of the outputs.

A standard release condition Πstd mentioned earlier in this
paper simply requires a signature of the current transaction
using a key speciﬁed in Πstd. This condition is speciﬁed in
the Bitcoin scripting language as follows:

dup hash160 [h(pk)] eq verify checksig

An input script that satisﬁes this condition is ω = [σ] [pk].
To illustrate, we brieﬂy describe the steps to check the
release condition Πstd with script ω. First, ω = [σ] [pk]
is interpreted, which pushes the string σ and the string pk
onto the stack. Next, Πstd is interpreted. It ﬁrst duplicates
the argument on the top of the stack (pk), then hashes the
duplicated argument, pushes the hash of a particular public
key pk onto the stack, veriﬁes the equality of the ﬁrst two
arguments on the stack (which should be the string h(pk)
that was just pushed onto the stack and the hash of the
public key given by the input script ω), and if equal, then
checks the signature on the current transaction3 using the
next two arguments on the stack which are pk and σ.

Another common release condition is called a script hash.
In this case, the release condition only speciﬁes a hash of
the actual release condition script. This condition is usually
coded in the scripting language as

hash160 [h] eq verify

which is interpreted as a script that ﬁrst hashes the top ar-
gument on the stack, pushes the string h onto the stack, and
then veriﬁes equality of the two. An input script that satis-
ﬁes this condition might be ω = [a1]
[a2] . . . [an] [script],
i.e. the script pushes arguments a1, . . . , an onto the stack,
and then pushes a string script onto the stack. When a
certain bit is set in the output address, then the release con-
dition ﬁrst evaluates ω to setup the stack, then interprets
the release condition which checks that the ﬁrst argument
[script] on the stack is the same one speciﬁed in the release
condition, and then interprets [script] as a new script which
it then executes against the values a1, . . . , an which remain
on the stack.

A script hash is the preferred method for encoding multi-
signature release conditions, i.e. transactions which require
more than one party to sign for the release condition to be
satisﬁed. A script such as

2 [pk1] [pk2] 2 check multisig

pushes the constants 2, pk1, pk2, 2 onto the stack and then
involves the check multisig operation which then reads
these 4 arguments and interprets them as “succeed if the
next two arguments on the stack correspond to signatures
under 2 of the public keys pk1, pk2.” To satisfy this script,
the witness should be of the form ω = 0 σ1 σ2 where σi is a
signature on the transaction under key ski. The extra 0 at
the beginning is a peculiarity of the check sig operation.
3.2 Modiﬁcations to Bitcoin for MICROPAY1
The Bitcoin script language supports a check sig opera-
tion that reads a public key and a signature from the stack
and then veriﬁes the signature against the public key on
a message that is derived in a special way from the current
transaction. This (and its multi-sig version) is the only oper-
ation that performs signature veriﬁcation. In MICROPAY1,
however, our scheme requires the veriﬁcation of a signature
on a transcript of a coin-tossing protocol, i.e. step (3) of
the release condition Πesc(x, aesc, a2) needs to verify a signa-
ture on the tuple (c, a2, r2). Thus, to support our protocol,
we suggest a new operation check rawsig which reads a
public key, a signature, and values from the stack which it

2Base58 uses upper- and lower- case alphabet characters and
the numerals 1-9, but removes the upper-case O, upper-case
I and lower-case l to eliminate ambiguities

3A very speciﬁc transformation is used to change the cur-
rent transaction into a string upon which the signature σ is
veriﬁed using public key pk.

213concatenates to produce the message that is used to check
the signature. More speciﬁcally, when this instruction is
called, the top of the stack should appear as follows:

[an] ··· [a1] [n] [σ] [pk]

The operation performs the following steps:

1. Read the top argument on the stack; interpret as a
public key. (Same as the ﬁrst step of op checksig.)

2. Read the next argument on the stack; interpret as a

signature string. (Same as the second step of op checksig.)

3. Read the next argument n from the stack and interpret

as a 32-bit unsigned integer.

4. Read the next n arguments an, an−1, . . . , a1 from the
top of the stack and concatenate to the string m =
a1||a2||···||an where || is a unique delimiter string.

5. Verify that σ is a signature on message m under public
key pk. If not, then abort. (Same as the last step of
the standard op checksig instruction.)

Thus, the only diﬀerence between this instruction and the
op checksig instruction is how the message m is constructed.
In the later case, the message is constructed by removing
part of the script from the current transaction in a spe-
ciﬁc way. An implementation of this method in the libbit-
coin[8] library requires only 30 additional lines of code.

Additionally, in order to verify that the transcript of our
“coin-ﬂipping” protocol is a winning transcript, we need to
add (or xor) integers on the top of the stack and compare
and integer on the stack to a ﬁxed constant. In the current
scripting language, numeric opcodes such as add and ltcmp
are restricted to operating on 4-byte integers. To ensure the
soundness of our coin-ﬂipping protocol, however, we require
the merchant to select a witness x (that is used to form
the commitment c) from 128-bit strings. Thus, the integers
on our stack will be larger than 4-bytes, and currently, the
Bitcoin script stops evaluating the script and fails when this
event occurs. To enable our functionality, we require the
operations to simply truncate the integers on the stack to
4-byte values and continue evaluating the script (instead of
aborting the execution of the script as they do now). This
change requires only ﬁve lines of code in libbitcoin.
3.3 Implementing MICROPAY2

We implement our second scheme in this section. Figure 2
shows the message ﬂow; we then describe each message in
detail.

step 0. The VTS T publishes a public key pkT and retains
a secret key skT used for signing.

example: Party T publishes public key

0305a8643a73ecddc682adb2f9345817d
c2502079d3ba37be1608170540a0d64e7

step 1. The ﬁrst step of our scheme is for the user to post
an escrow transaction for $100X onto the blockchain. To do
so, the payer generates a new address aesc while retaining the
associated key pair (skesc, pkesc), and publishes a transaction
on the ledger that speciﬁes an output aesc with a special
scripthash output script. The scripthash output script will
be

hash160 [hesc] eq verify

Figure 2: An example of how MICROPAY2 can be
implemented in the Bitcoin scripting language.

where hesc is constructed by ﬁrst producing the redeemscript

resc ← “2 [pkT ]

[pkesc] 2 check multisig”

and then computing hesc ← hash160(resc).

example The user posts escrow to the blockchain:

transaction {

hash fc7237b89...d347
inputs {

input {

address mtGBirEkX5...SMPQszNtYR
previous_output {

hash da27eb8d...6979
index 0

}
script "[ 30440...f401 ] [ 03c7...e463 ]"
sequence 4294967295

}

}
lock_time 0
outputs {

output {

address 2N8Q...Cw41VBPgWHoHv
script "hash160 [ a640...c939 ] equal"
value 1000000

}
output {

address mtGB...NtYR
script "dup hash160 [ 8b...c2 ] eqver checksig"
value 3250000

}

}
version 1

}

The escrow address for this example is 2N8Q...HoHv.

step 2. To request a payment, the merchant picks a random
r1 ← {0, 1}128 string and then computes c ← H(r1) where H
is the SHA256 operation implemented in the Bitcoin script-
ing language. The merchant also generates a new Bitcoin

Payer creates escrow2N8QHzsKadx92nRUjUX3U5Cw41VBPgWHoHvMmerchantPpayer1.Pick random r1 and addr a2.c=Com(r1), a2hash160 [ a64..939 ] equalscripthash2.  𝜎1, 𝜎, L1,RSL1transaction {  hash da27…ef42    input  {  <aesc> }     script { empty   }    …    output { <addr a2>     <standard out script> }    version 1 }𝜎1=sigesc(L1)The redeem script RS requires a multi-signature by payer key esc and by service key T.4. Verify win. sign L1.Tservice3. If r1+r2<R, t wins lottery.(L1,𝜎1,𝜎,c,r1,r2,a2)𝜎t=sigT(L1)5. Use (𝜎1,𝜎t) and redeem script RS  to spend escrow.RS𝜎=sigesc(c,r2,a2)aesc214address a2 and sends (c, a2) to the payer while retaining the
public and secret keys associated with a2.

example The Merchant picks the random message

r1 ← 29c14f18638da11b75663e050087b591
computes c ← sha256(r1) and sends the message
7c12e848a4a3a9f31c7abea5ab323eeb
6893c3a08675cc6c076e39950e52695e

c =

along with a new bitcoin address

a2 ← mkKKRLweRbu7Dam82KiugaA9bcnYXSyAVP

step 3. Upon receiving (c, a2) from a merchant, the payer
veriﬁes that c is the proper length for the hash of a 128-bit
string, and that a2 is a well-formed bitcoin address. The
payer picks a random 8-bit string r2 ← {0, 1}8, and then
uses skesc in order to compute the signature σ on the message
(c, r2, a2) using the secret key skesc. The payer also computes
a signature σ1 on the transaction (aesc, a2) using the secret
key skesc. The payer sends (aesc, r2, σ, σ1) to the merchant.
example The payer randomly samples r2 ← 37 and then

computes a signature on (c, r2, a2) as

σ ← IKZRV...rgXLHs=

The payer then forms the transaction (aesc, a2) as follows

transaction {

hash 2de3...0e73
inputs {
input {

previous_output {

hash fc72...d347
index 0

}
script ""
sequence 4294967295

}

}
lock_time 0
outputs {
output {

address mkKK...yAVP
script "dup hash160 [ 34a...e2a ] eq_ver chksig"
value 100000

}

}
version 1

}

and then signs the transaction using skesc

σ1 ← 3044...ed01

step 4. Upon receiving (r2, σ, σ1) from the payer, the Mer-
chant ﬁrst veriﬁes the two signatures on the respective mes-
sages and veriﬁes that aesc has not yet been spent. The
merchant then checks whether r1 ⊕ r2 results in a string
whose last two (or alternatively, ﬁrst two) digits are zero.

If so, then the merchant has a winning ticket. To redeem
the escrow amount, the merchant sends the winning tuple
consisting of x = (c, r1, r2, σ, σ1, aesc, a2) to the VTS T . T
veriﬁes that the tuple corresponds to a win for the escrow
aesc, and if so, then signs the transaction (aesc, a2) using

public key pkT . Speciﬁcally, T veriﬁes that c = H(r1), σ
is a valid signature on (c, r2, a2) w.r.t. pkesc, and the last 2
digits of r1 ⊕ r2 are 00.

Furthermore, T publishes tuple x on its own bulletin board,

on the bitcoin blockchain, or on some “alt-chain”.

step 5. Finally, once M has received the signature σT from
T , then M can spend aesc to address a2 (which it controls)
using σ1, σT to satisfy the release condition.

4. EVALUATION
4.1 Expected Revenue and Expenditure

With each of our probabilistic payment schemes, the seller
receives X coins in expectation for every interaction with a
buyer. We provide a statistical analysis to guarantee that
after suﬃciently many payments, both the buyer and the
seller respectively spend and receive an amount that is close
to the expectation with high probability.

Our scheme is parameterized by ρ, the probability that
a lottery ticket wins. One can tune ρ to balance the num-
ber of winning transactions with the variance in the actual
cost/revenue from each transaction. Although the previous
section used ρ = 1
100 , our implementation uses ρ that is a
power of 2 to simplify the coin-ﬂipping protocol. Thus, in
the following sections, we consider ρ1 = 1
512 .
A standard Bernoulli analysis suﬃces because the security
properties of our scheme prevent even malicious parties from
biasing independent executions of the protocol. Let Ri be a
random variable denoting revenue from the ith execution of
the protocol (e.g., Ri is either 0 or X/ρ, in our case, either
i Ri. As
discussed previously E[Ri] = ρ · X/ρ = X, so E[R] = Xn.
Recall that the probability that revenue is exactly Xk is

0 or 128). The total revenue is therefore R = (cid:80)n

128 and ρ2 = 1

Pr [R = Xk] =

(ρ)kρ (1 − ρ)n−kρ

(cid:32)

(cid:33)

n
kρ

Using this formula and ρ1 = 1

128 , we illustrate the prob-
ability of paying (or receiving) a speciﬁc amount per trans-
action in Fig. 3. These graphs show that both the buyer
(who may, say, make 1000 transactions per year) and a seller
(who may receive 10,000 transactions per month), the av-
erage price over those transactions will be close to the ex-
pected amount of X per transaction. The blue sections of
those graphs show 99% of the probability mass.

As the number of transactions increases for a very busy
seller (e.g, a web site that receives millions of views), the
guarantees on revenue become even tighter. To illustrate,
we now compute the probability that R < 0.8n, i.e., that
revenue is less than 80% of the expected value:

(cid:98)0.8nρ(cid:99)(cid:88)

Pr [R < 0.8n] =

Pr [R = ρ · k]

k=0

The ﬂoor function in the summation’s upper bound make
the function “choppy” and non-monotone at those n when
the value discretely increases by 1. The Chernoﬀ bound is a
general tool that can be used to bound tail inequalities such
as this one. However, this estimate is loose, and we instead
compute the exact value in Fig. 4. After 100,000 transac-
tions, there is high probability that the actual revenue will
be at least 80% of the expected value and good probability

215Figure 3: Pr of payment amount (parameterized by
X) after 1,000 and 10,000 transactions (for win rate
ρ1 = 1
128 ). The blue region shows 99% of the mass.
If escrow is 128X, then the expected payment is X.

that the revenue will be at least 90% of the expected. In
Fig. 5, we show the same results for win rate ρ2 = 1

512 .

Figure 5: For win rate ρ2 = 1
512 , probability that
the seller’s revenue is less than 80% and 90% of the
expected revenue.

computation of two signatures. The ﬁnal check to deter-
mine whether the transaction is paying requires two signa-
ture veriﬁcations and one comparison operation. We ﬁrst
show micro-benchmarks for each of these operations, and
then demonstrate how the scheme operates in a real system.

Micro-benchmarks for each operation.

operation avg time (µs)

95% ci (µs)

Request Ticket

Request Ticket (Fast)

Make a Ticket

Check Ticket

VTS Check

84.9 ± 2.56
3.7 ± 0.12
170.6 ± 5.28
437.6 ± 10.45
496.1 ± 6.60

Figure 4: For win rate ρ1 = 1
128 , probability that
the seller’s revenue is less than 80% and 90% of the
expected revenue. The curves have a “sawtooth”
pattern due to discreteness. At 15,000 and 50,000
transactions, there is a roughly 2% chance that rev-
enue is less than 80% or 90% respectively of the
expected revenue.

4.2 Performance of the Scheme

Our schemes are all highly eﬃcient; the ﬁrst message from
the seller requires only a hash computation (and optionally
the creation of a new address, in the fast version of this step,
we reuse the same bitcoin address for all merchant transac-
tions4). The second message from the buyer requires the

4Although Bitcoin speciﬁcations suggest that each transac-
tion use a totally new address, with proper key management
on behalf of the merchant, there is no reason the same ad-
dress cannot be used to receive many payments.

These measurements where taken on an Intel Core i7-
4558U CPU @ 2.80GHz, with 2 cores, 256 KB of L2 cache
per core, 4MB of L3 cache, and 16GB of RAM. Each func-
tion was proﬁled using the Go language benchmark frame-
work which called the function at least 10000 times to time
the number of nanoseconds per operation. The Go bench-
mark framework was run 50 times and averaged to report
the sample time and the 95% conﬁdence interval reported in
the table. Only one core was used during the testing. As the
table demonstrates, the protocol messages can be generated
in microseconds, with ticket checking requires less than half
a milli-second. Thus, the overhead of the protocol is very
low in terms of computation.

In terms of communication, we have made no eﬀort to
compress or minimize the size of the messages. For ease of
implementation, we use base64 encodings for the signatures,
commitments, and addresses in the protocol (rather than
a more eﬃcient binary encoding).
In the table below, we
report the size (in bytes) for each of the messages. The
ticket message has a variable size because it includes two
signatures whose message sizes are variable.

Pr[win]=1/128PrPrice per transactionActual price per transaction (after 1000 transactions)1%6%12%0.12XX2XPr[win]=1/128PrPrice per transactionActual price per transaction (after 10000 transactions)1%4%0.7XX1.33XPr# of tickets<80% Expected Rev<90% Expected Rev2%10%25%50%5k15k25k35k45kPr# of tickets<80% Expected Rev<90% Expected Rev2%10%25%50%10k50k100k216operation message size (bytes)

Request Ticket

Request Ticket (Fast)

Make a Ticket

Check Ticket

VTS Check

73

73
398 ± 10
-

-

4.3 Experiments in a sample web server

To illustrate how our scheme can be used to sell “content”
on the Internet, we developed a webserver that serves dy-
namic pages and also implements our MICROPAY2 proto-
col. Our experiment shows that the overhead of adding the
messages of the micropayment protocol add little in terms
of performance penalty to the infrastructure. The most ex-
pensive operation on the server is to verify the lottery ticket
(i.e., check two signatures), and this adds less than half a
milli-second to the server response time—a value that is es-
sentially masked by the variance in network performance.

In practice, we envision our system as a proxy that sits
in front of a legacy content server and only handles the mi-
cropayment; this experiment serves as an illustrative bench-
mark for that architecture.
In particular, it shows that a
basic and unoptimized server can handle millions of tickets.

Design.

We implemented a webserver using the Go net/http pack-
age. The server handles three kinds of requests, \base, \ask,
and \buy. The \base endpoint returns a page that is ren-
dered with a template and a dynamic parameter (to model
the fact that it is not simply a static page that is cached in
memory). The size of this page is roughly 2kb. This end-
point serves as a control for our experiment to understand
the baseline performance of our webserver implementation.
Next, the \ask endpoint returns the ﬁrst message of our mi-
cropayment scheme, i.e. a request for a ticket. This method
models what a buyer’s client queries in order to receive a
ticket request5. Finally, the \buy endpoint accepts the sec-
ond message (the ticket) of our micropayment protocol and
checks whether the ticket is well-formed and whether the
ticket is a winning one.
If the ticket is well-formed, the
method returns the same dynamically generated webpage
as the \base method. Thus, the combination of making an
\ask query and then a \buy query reﬂects the overhead of
processing a micropayment before serving content.

Compute-bound experiment.

In the ﬁrst experiment, we measured the extent to which
the extra computation for a server would become a bottle-
neck at Internet scale. We ran a client that made both con-
trol and experiment requests from a 2-core/4-hyperthread
laptop running on a university network from the east coast.
The control experiment makes a call to \ask and then \base;
the experiment makes a call to \ask and \buy. Our experi-
ment attempts to isolate the diﬀerence between calling just
\base and accessing the same content through \buy; but in
order to perform the latter, we need to have information

5In practice, the ﬁrst message will be embedded in the link
to the content that requires a payment, hence the most ex-
pensive component of this message—the network cost— can
essentially be hidden from the user’s experience.

Figure 6: A histogram of response times for a single
request over a cable modem. The base red is the
experiment, the overlaid checkerbox is the control.

conveyed through \ask. This extra round-trip is hidden in
practice because it is bundled with the (several) calls to a
server that are used to access the “homepage” from which the
links to content-for-purchase are conveyed. Thus, to avoid
comparing one round-trip against two, both of the experi-
ments make a call to \ask.

The client issued 25000 requests using 20 threads for at
least 20 seconds; each thread pooled its network connection
to amortize network overhead over the requests. Each run
(to either control or experiment) was performed 30 times
over the course of a day and a delay of at least 15 seconds
was introduced between runs to allow network connections
to gracefully terminate. The client sent its queries from the
east coast. The server used a single core on a t4.xlarge
instance from the US-East region of EC2 which has an Intel
Xeon CPU E5-2666 v3 @ 2.90GHz and 8GB of memory.

As illustrated by the table below, the diﬀerence between
the performance of the \base system and \buy are over-
whelmed by network timing noise; the conﬁdence interval of
the experiment roughly matches the microbenchmark tim-
ings for the \buy calls.

operation req/sec avg resp time (95% conf int)

\base

\buy

534

497

1.87 ± 0.26 ms
2.01 ± 0.30 ms

Extrapolation.

When run as a proxy, a micropayment server with 8 cores/16

threads can handle at least 4000 transactions per second, or
roughly 350 million page views per day. At roughly 600
bytes per message to account for protocol overheads, this
amounts to a bandwidth overhead for micropayment mes-
sages of merely 600 ∗ 4000 = 2.4mb/sec.

Network Test.

The previous tests did not include network connection
overhead. We ran the same experiment using a single thread
making a single request, serially, 2000 times with a 2 second
delay between each request. The client ran from a laptop
connected to the internet over a cable modem. Figure 6 plots
a histogram of the response times for the control and exper-
iment. The two distributions are very close as expected.

1%3%5%7%9%70ms100ms130ms200ms217VTS Performance.

In MICROPAY2, the VTS signs all winning lottery trans-
actions. At Internet scale, this party could become a bot-
tleneck since every winning ticket must be processed in near
real-time to mitigate double-spending attacks. Based on the
microbenchmarks in the previous section, a single core can
also verify and sign 2000 winning tickets per second.
In-
cluding networking overhead extrapolated from our ﬁrst ex-
periment, we estimate that a micropayment server with 8
cores/16 threads can handle at least 4000 winning transac-
tions per second, or roughly 350 million winning lottery tick-
ets per day. When the winning ratio parameter is ρ1 = 1
128 ,
roughly 1 out of 128 tickets will be winning, and thus, a
single VTS server can theoretically support 512,000 global
micro-payment content views per second, or ∼44 billion to-
tal micropayment content views per day. The later number
assumed uniform access rate throughout the day, but real
traﬃc follows cyclic patterns with peak times that are much
busier than oﬀ-peak times. These are theoretical maximums,
but after adding redundancy for robustness, this analysis
and experiment suggests that a small set of servers suﬃce
to handle Internet scale transaction processing.

Another potential bottleneck occurs with the underlying
cryptocurrency bandwidth. As the graph in Fig. 7 depicts,
during 2015, the number of daily Bitcoin transactions pro-
cessed on the blockchain hovers around 105. The current
Bitcoin protocol can only handle 7 transactions per second
on average, or roughly 106 transactions per day, and thus, at
parameter ρ1, it seems feasible for the current Bitcoin pro-
tocol to handle roughly 108 total paid transactions. Many
research eﬀorts are underway to increase the bandwidth for
the number of transactions by a factor of 10x to 100X, and
our scheme’s scalability naturally beneﬁts from these ad-
vancements. We can also decrease the ρ1 value to improve
the scalability (at the cost of increasing the variance of ex-
pected revenue and costs for the sellers and buyers).

Felten. Mixcoin: Anonymity for bitcoin with
accountable mixes. eprint.org/2014/77, 2014.

[5] David Chaum. Achieving electronic privacy. Scientiﬁc

American, pages 96–101, August 1992.

[6] David Chaum, A. Fiat, and M. Naor. Untraceable

electronic cash. In CRYPTO’89, 1989.

[7] Etherium Foundation. White paper. https:

//github.com/ethereum/wiki/wiki/White-Paper,
2015.

[8] Libbitcoin foundation. A bitcoin library.

https://github.com/libbitcoin/libbitcoin/, 2015.

[9] Matthew Franklin and Haibin Zhang. Unique ring
signatures: A practical construction. In Financial
Cryptography and Data Security. 2013.

[10] Steve Glassman, Mark Manasse, Martin Abadi, Paul

Gauthier, and Patrick Sobalvarro. The millicent
protocol for inexpensive electronic commerce. In
WWW’95, 1995.

[11] Oded Goldreich. Foundations of Cryptography —

Basic Tools. Cambridge University Press, 2001.

[12] Richard J. Lipton and Rafail Ostrovsky.

Micro-payments via eﬃcient coin-ﬂipping. In
Financial Cryptography, pages 1–15, 1998.

[13] G. Medvinsky and C. Neuman. Netcash: A design for

practical electronic currency on the internet. In
CCS’94, 1994.

[14] Silvio Micali, Michael Rabin, and Salil Vadhan.

Veriﬁable random functions. In FOCS. IEEE, 1999.
[15] Silvio Micali and Ronald L. Rivest. Micropayments

revisited. In CT-RSA, 2002.

[16] Board of Governors of the Federal Reserve System.

Federal reserve board press release 29 june 2011.
http://www.federalreserve.gov/newsevents/
press/bcreg/20110629a.htm, June 2011.

[17] Ron Rivest and Adi Shamir. Payword and micromint:

Two simple micropayment schemes. In Cambridge
Workshop on Security Protocols, 1996.

[18] Ronald L. Rivest. Electronic lottery tickets as

micropayments. In In Financial Cryptography, 1997.

[19] David Wheeler. Transactions using bets, 1996.
APPENDIX

Figure 7: Bitcoin transactions per day (2015)

5. REFERENCES
[1] Ross Anderson, Charalampos Manifavas, and Chris

Sutherland. Netcard—a practical electronic-cash
system. In Security Protocols, pages 49–57, 1997.

[2] Marcin Andrychowicz, Stefan Dziembowski, Daniel

Malinowski, and Lukasz Mazurek. Secure multiparty
computations on bitcoin. In IEEE S&P, 2014.

[3] Iddo Bentov and Ranjit Kumeresan. How to use

bitcoin to design fair protocols. In CRYPTO’14, 2014.

[4] Jon Bonneau, Arvind Narayanan, Andrew Miller,

Jeremy Clark, Joshua A. Kroll, and Edward W.

Figure 8: A plot of transaction fee versus transac-
tion size for one million Bitcoin transactions that
occurred in May 2015. The Bitcoin speciﬁcation
suggests that each transaction should pay roughly
0.0001 bitcoin per kilobyte (rounded up) of transac-
tion data.

6095130Jan’15Feb’15Mar’15Apr’15May’15Total Transactions (1000s)0.00010.0005(cid:9)0.001+ 0 500 1000 1500 2000 2500 3000 3500 4000Fee (Bitcoin)Size of Transaction (bytes)218