Revoke and Let Live: A Secure Key

Revocation API for Cryptographic Devices

Véronique Cortier

CNRS, Loria, UMR 7503
Vandœuvre-łès-Nancy,

F-54506, France
cortier@loria.fr

Graham Steel

INRIA

Paris, France

graham.steel@inria.fr

Cyrille Wiedling

CNRS, Loria, UMR 7503
Vandœuvre-łès-Nancy,

F-54506, France

cyrille.wiedling@loria.fr

ABSTRACT
While extensive research addresses the problem of establish-
ing session keys through cryptographic protocols, relatively
little work has appeared addressing the problem of revoca-
tion and update of long term keys. We present an API for
symmetric key management on embedded devices that sup-
ports key establishment and revocation, and prove security
properties of our design in the symbolic model of cryptogra-
phy. Our API supports two modes of revocation: a passive
mode where keys have an expiration time, and an active
mode where revocation messages are sent to devices. For
the ﬁrst we show that once enough time has elapsed after
the compromise of a key, the system returns to a secure
state, i.e.
the API is robust against attempts by the at-
tacker to use a compromised key to compromise other keys
or to keep the compromised key alive past its validity time.
For the second we show that once revocation messages have
been received the system immediately returns to a secure
state. Notable features of our designs are that all secret val-
ues on the device are revocable, and the device returns to a
functionally equivalent state after revocation is complete.

Categories and Subject Descriptors
K.6.m [Miscellaneous]: Security

Keywords
Revocation, API, formal methods

1.

INTRODUCTION

Embedded systems deployed in hostile environments often
employ some dedicated tamper-resistant secure hardware to
handle cryptographic operations and keep keys secure. Ex-
amples include mobile phones (which contain SIM cards),
smartphones (recent models include ‘Secure Elements’), pub-
lic transport ticketing systems (such as the Calypso sys-
tem which employs smartcards and ‘SAM’ modules [10]),
smart utility meters (that include a smartcard-like chip for

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

cryptography), on-vehicle cryptographic devices to support
vehicle-to-vehicle networking [16] et cetera. In such systems,
it is often necessary to support the possibility of remotely
revoking and updating the long-term keys on the device.
However, while extensive research addresses the problem of
establishing a new session key or determining what security
properties can be guaranteed in the event of long-term key
corruption, relatively little work has appeared addressing
the problem of revocation and update of long-term keys.

Most existing solutions for key revocation follow one of
two approaches: either key revocation actually relies on
some ‘longer term’ key that cannot be itself revoked, or key
revocation is simply achieved by disabling, resetting or iso-
lating the compromised device. For many applications, both
these approaches are unsatisfactory. We propose that a key
revocation API should ideally satisfy the following proper-
ties:

1. The device should remain functional - speciﬁcally, when-

ever possible, the device should return to an equivalent
functional state after revocation (but with fresh keys
in place).

2. Any key should be revocable - side-channel attacks may
compromise (perhaps with signiﬁcant eﬀort) any of the
keys stored on a cryptographic device, and the more
sensitive a key is, the more likely an attacker is to
dedicate eﬀort to breaking it. Hence it is not prudent
to decide in advance which keys may or may not be
compromised.

The ﬁrst main contribution of this paper is the design of an
API with update and revocation functionalities that satisfy
these properties. We assume a very general scenario in which
a population of user devices (which could be anything from
employee smartcards to enterprise HSMs and can include
clients and servers) wish to establish keys and communicate
securely between themselves, and a small number of admin-
istrator devices are used only to setup new devices and to
revoke compromised keys. We start from an existing API for
symmetric key management [4] capable of supporting a vari-
ety of protocols and show how to extend it with commands
for revocation and update of long-term keys. Our design
allows the right to update long-term keys to be shared or
delegated in a secure way, making it suitable for the modern
embedded systems environment where many actors (manu-
facturer, infrastructure provider, service provider, applica-
tion developer) may need diﬀerent access rights. We also
discuss some limitations of revocation when symmetric key

918cryptography is the only operation available (as is in fact
the case in many real-world embedded systems).

Our second main contribution is a formal proof of security
of our API. We show that it ensures two main properties.
First, when a key is lost, the system is able to repair itself
after some time. Indeed, our ﬁrst technique for revoking a
key is time-based: each key expires after some delay. Second,
if the need to revoke a key is urgent, an explicit revocation
command allows us to immediately secure the device, by
prohibiting keys of certain levels for a certain period of time.
We show in an example how with careful labelling of key
levels this can be used to maintain full functionality. Our
API makes use of special management keys, which may of
course be revoked as well. Our security proofs are carried
out in a symbolic model, based on terms for representing
messages. The detailed proofs are available in a research
report [5].

Related work.

Most deployed key revocation mechanisms are quite sim-
ple. For example, the Trusted Platform Module [15] sup-
ports a TPM_OwnerClear command that resets the ‘owner-
ship’ status of the device and erases most keys such as the
root key for the storage hierarchy. It does not support, for
example, the revocation of individual keys in the hierarchy.
In multicast group key management schemes, hierarchies are
also standard, and here revocation of a key corresponds ei-
ther to permanent removal of an entity from the group, or re-
moval until the entity resubscribes, in which case long term
secrets are assumed to be still intact. Our work will not
make this assumption. One lesson from this domain is that
many proposals published without proofs of security have
turned out to have attacks [14].

Richer key revocation schemes have received some previ-
ous attention in the academic literature, e.g. in the key man-
agement schemes of wireless sensor networks. Here nodes in
the network are expected to be deployed in hostile environ-
ments where key compromise may occur. Eschenauer and
Gligor propose a scheme under which every node i shares a
long-term symmetric key KCi with a control server [7]. If
a node n is compromised, the server sends a fresh signature
key Si to each nodes i sharing keys with n encrypted under
KCi, and then signs a list of keys to be revoked and sends
this list to each i. The nodes then delete the keys, isolating
the compromised node. This scheme has two disadvantages
for the general case: ﬁrst it assumes that a central author-
ity knows the key identiﬁers of all the keys in the network
and between what parties they are shared, and second it
has no way to recover a device which has lost its KCi to
the attacker. An alternative scheme is KeyRev [17], which
proposes the use of a secret sharing scheme to distribute
session keys only to unrevoked nodes, thereby isolating com-
promised notes without explicitly revoking their long term
keys. Again this has the disadvantage that the loss of a
long term key means the unrecoverable loss of a device: ac-
ceptable in a wireless sensor network perhaps but not in the
general case. In this paper we aim to be able to securely
update all keys on the device, provided not too many keys
have been compromised.

The Sevecom API [9] is a proposal for an on-board tamper-
resistant device to handle cryptography in next-generation
vehicles supporting VANETs (vehicle to vehicle ad-hoc net-
works). It includes two root public keys which are used to

check authenticity of messages coming from a central server.
The signed messages from the central server are used to trig-
ger updates of working keys. The Sevecom API is interesting
because it allows update of the long term root keys using a
simple two step protocol. We will examine this example in
more detail in the next section.

There are other proposals for key management APIs with
security proofs in the literature, but none of these address
the question of revocation [3, 6, 8].

2. REVOCATION API DESIGN ISSUES
We set the following requirements for our design:

(1)
the device should return to full functionality whenever pos-
sible, and (2) all secret values should be revocable. Re-
sources within the tamper-resistant boundary of an embed-
ded crypto device are usually tightly restricted. We there-
fore design our API to use a minimum of memory (instead
of storing lists of blacklisted keys, we blacklist sets of keys
through their attributes) and cryptographic functionality
(just symmetric encryption using an authenticated encryp-
tion scheme). We do however require that the devices con-
tain loosely synchronized real-time clocks. This assumption
is standard in some domains, e.g. on-vehicle cryptographic
units [9], Smartmeters, but is not suitable for every applica-
tion - we will comment brieﬂy in section 6 on how to adapt
our design to devices without clocks.

Our starting point is a generalisation of the symmetric
key management API of Cortier and Steel [4], which deﬁnes
a simple hierarchy on keys under management whereby keys
higher in the hierarchy are allowed to encrypt (wrap) keys
lower down, for storage outside the device or as part of a
key exchange protocol. We will describe the API fully in
the next section. Here we note some design constraints that
are imposed on us by our key revocation requirements, since
these may be of independent interest to future designers of
revocation APIs.

Firstly, since we can have no single upper bound to the key
hierarchy in order to satisfy requirement (2), our design must
incorporate a set of keys of the same level Max which can re-
voke each other. The Sevecom API mentioned in section 1
tackles this by having two root keys, where knowledge of
the private halves of both is required in order to revoke and
update any one of them. The update protocol is given in ﬁg-
ure 1, where the terms to the left of the semi-colon represent
protocol messages, and the terms to the right are predicates
on the state of the device. Initially, the device is in a ‘two key
state’, with root keys k1 and k2 available for use. Then a re-
voke message is given for key k1, which consists of k1 signed
under its own private half inv (k1 ). The device receives this
and deletes k1 , moving into a ‘one key state’ where no fur-
ther revocation messages will be processed. Then an update
message is given, using k2 to sign the new root key k3 .

RevokeRootKey1 :
{k1}inv (k1 ); keys(k1, k2) → ; keys( , k2)

UpdateRootKey1 :
{k3}inv (k2 ); keys( , k2) → ; keys(k2, k3)

Figure 1: Sevecom Revocation Protocol (simpliﬁed)

919At ﬁrst it may seem that this protocol is achieves its se-
curity goal: unless the intruder manages to obtain access to
both inv (k1 ) and inv (k2 ), he cannot replace a key with one
of his own. However, analysis by M¨odersheim and Modesti
showed that there is another attack scenario [12]: suppose
an attacker had corrupted only inv (k2 ), and then waited
until the server sent a revocation message for k1 . He could
then intervene and inject his own root key ki using inv (k2 )
to sign it. In a footnote, M¨odersheim and Modesti propose
that both signature keys be used to sign both messages,
and the current public keys be included in the message to
prevent replays of old updates. They did not verify this so-
lution however. In our scheme we generalise the idea to a
scheme where some number NMax of the K level Max keys
are required in order to revoke and replace one. We similarly
require the revocation message to demonstrate knowledge of
the current key in order to avoid replays, but we do this by
encrypting under the old key rather than adding it to the
plaintext, to prevent possible key cycles. Since the old key
may be corrupted, it is the innermost encryption. A revo-
cation message, e.g. ‘replace ki with kj’, will therefore have
the following form:

{update, kj}

...

kn

ki k1

In our setting, we only have symmetric key cryptography
available, so unlike the public keys in Sevecom, our root keys
must remain conﬁdential. This imposes an upper limit to the
security we can achieve: if at any point in the future, it is
possible for the attacker to obtain all the keys k1, . . . , kn,
then he will obtain also kj, and by repeating this for all the
subsequent key updates be able to obtain NMax of the current
level Max keys. To prevent this, for our security proofs, we
demand that ‘honest’ updates to the level Max keys, i.e.
updates generated by the server, remain unknown to the
attacker. In practice this could mean that the level Max keys
are only updated when the device is connected to a trusted
host. If this is too cumbersome for the application then a
quantitative risk assessment would have to be undertaken
to set the N and K high enough to achieve the required
degree of security. A full solution would require asymmetric
cryptography, as we will discuss in section 6. Note that we
will still prove that the device will resist attacks against fake
update messages constructed by the intruder, even when he
has corrupted individual level Max keys.

For keys of lower level than Max, we assume that the at-
tacker can see all (encrypted) update messages. We need
some way to ensure freshness of messages containing keys
encrypted by other keys, otherwise revocation will be inef-
fective. To see this, consider the following example: Assume
{..., k3, ...}k5 and {..., k3, ...}k4 have been sent out through
normal key encryption commands, with ki at level i(< Max)
in the hierarchy. Assume that at some point k4 is lost to the
attacker. Then he learns k3 as well (by decrypting the sec-
ond message). Our revocation API would allow us to remove
k4, and if we are smart we will also remove k3 since it must
be assumed to be lost as well. However, this will not suf-
ﬁce: the attacker could replay the key distribution message
{..., k3, ...}k5 , and therefore re-inject the corrupted k3 into
the device. To avoid this one could blacklist all keys below a
corrupted key, which is problematic (this blacklist will take
up device memory and will have to be kept indeﬁnitely), or
revoke all the keys in the hierarchy all the way to the top

(impractical), or assure some kind of freshness of key distri-
bution messages. We choose the latter option, requiring that
every key is given a validity time when it is issued. After
the expiry date passes, the device will refuse to use the key.
Without this property, we would need some other way to
ensure freshness of all messages, such as challenge-response
exchanges for every message.

Finally, note that though we design our API to use mem-
ory eﬃciently, we do not explicitly analyse its resistance to
denial of service attacks.

3. DESCRIPTION OF THE API

We describe the design and commands for our key man-

agement and key revocation API.
3.1 Setting

We assume that keys are structured in a hierarchy, such
that a key k1 may encrypt a key k2 only if k1 is greater than
k2. More precisely, we assume a set of levels L equipped with
a (partial) order <, a maximal element Max and minimal
element 0. Management keys used for revocation or updates
will be keys of maximum level Max, and knowledge of at least
NMax of them will be required for many operations. We also
assume that a level can only be compared to ﬁnite number
of levels. More precisely, we assume that for any l ∈ L, the
set {l(cid:48) | l(cid:48) < l} is ﬁnite. This will ensure that we have no
inﬁnite sequence of the form {. . . k1 . . .}k2 , {. . . k2 . . .}k3 , . . .
We assume that each tamper resistant device (TRD) a

has:

• a clock, whose current time is given by ta ∈ T where T
is an inﬁnite ordered set of time events. For example,
T may be R+, the set of non negative real numbers.
For simplicity, we will assume that all clocks are syn-
chronized with a global clock, referred to as the time
of the global system. Our security properties could be
adapted to take account of clock drift, provided some
limit on the drift is assured.

• a table Θa of keys. Each entry in the table is indexed
by a handle h and the corresponding entry Θa(h) is
(k, l, v, m) where k is the actual key stored on the TRD,
l is its corresponding level, v its validity date of the key,
and m ∈ M is a miscellaneous ﬁeld that may describe
some other attributes of the key (e.g. describing the
purpose of the key).

• a blacklist Ba of elements of the form (l, t) where l is a
level and t is an expiration time. Intuitively, whenever
(l, t) occurs in a blacklist, it means that the TRD will
never accept a key of level l (or below), unless time t
has now passed.

Intuitively, the design of our API will ensure that a key
may only encrypt other keys lower in the hierarchy whose
validity dates have not expired.
We also assume that the TRDs share a function δ : L →
T , that associates lifetime to keys depending on their levels.
We may sometimes abbreviate δ(l) by δl. Since we have
assumed that a level can only be compared to ﬁnite number
of levels, we can compute the maximum lifetime of a chain
of levels, smaller than a given level. Formally, we consider

920the function

∆ : l (cid:55)→

max

l1<···<ln<l,n∈N

n(cid:88)

i=1

δ(li)

Intuitively, ∆(l) is the time where compromising a key k
of level l may compromise keys of lower levels, even if the
validity time of k has expired, due to chains of encryptions
(see Section 5).

For initialisation, we assume that each device contains at
least NMax keys of level Max which are known to an admin-
istrator. From this, using the commands of the API, the
administrator can bootstrap the system and, if necessary,
update all the level Max keys.
3.2 Commands

We ﬁrst give the standard commands which do not con-
cern revocation or keys of level Max, but suﬃce for normal
key management operations. The are mostly the same as
in the original API, [4], where they were shown to be suﬃ-
cient to implement a number of key establishment protocols
while always keeping sensitive keys in the secure memory
of the TRD, never exposing them in the clear on the host
machine. We have generalised the ordering on the hierarchy
and introduced checking of the validity time of keys and a
blacklist Ba of key levels together with expiration times. We
will write l ∈ Ba if there is (l(cid:48), t) ∈ Ba with l ≤ l(cid:48) and t a
valid time. We also assume a test Distinct(h1, . . . , hn) which
checks that the hi are pairwise distinct.

Public generation
The generation command for public (level 0) data (e.g a fresh
public nonce), which possibly takes an argument m ∈ M, is
deﬁned as follows. It returns both the value and a handle to
the value as stored on the device.

generatePublic(m)

let h = Fresh(Ha) in
Ha := Ha ∪ {h}
let n = Fresh(N ) in
N := N ∪ {n}
let v = t + δ(0) in
Θa := Θa ∪ {h → (n, 0, v, m)}
return h, n

where Fresh(E) (respectively with E ∈ {Ha, N, K}) re-
turns a element of the set E \ E (respectively with E ∈
{Ha,N ,K}).
Secret generation
The generation command for a secret key, with level of se-
curity l and, possibly, an argument m ∈ M:

generateSecret(l, m)

if 0 < l < Max

let h = Fresh(Ha) in
Ha := Ha ∪ {h}
let k = Fresh(K) in
K := K ∪ {k}
let v = ta + δ(l) in
Θa := Θa ∪ {h → (k, l, v, m)}
return h

Encryption
The encryption command takes as input a list of data that
are meant to be encrypted (which may include handles point-
ing to values stored on the device) and a handle for the key
k that will be used for encryption. We check that k has not
expired and is not below a level which has been blacklisted.
For each term to be encrypted, we check the level is lower
than that of k, the expiration date is valid, and that the
level is not blacklisted. Note that break aborts the entire
command.

encrypt([X1, . . . , Xn], h)

let (k, l, v, m) = Θa(h) in
if (l = Max) ∨ (v ≤ ta) ∨ (l ∈ Ba)

break

for i = 1..n

if Xi = Mi, mi /* message */
Yi := (Mi, 0, ta + δ(0), mi)

if Xi = hi /* handle */

let (ki, li, vi, mi) = Θa(hi) in
if (li < l) ∧ (vi > ta) ∧ (l /∈ Ba)

Yi := (ki, li, vi, mi)

else break

return {Y1, . . . , Yn}k

Decryption
The decryption command takes as inputs a handle for the
key that will be used for decryption and a cipher-text. We
also assume that decrypt throws break on failure of authenti-
cation (i.e. we assume an authenticated encryption scheme).
Note that the checks on the levels etc. performed during en-
cryption are repeated. This is important for security in the
presence of corrupted keys.

decrypt(C, h)

let (k, l, v, m) = Θa(h) in
if (l = Max) ∨ (v ≤ ta) ∨ (l ∈ Ba)

break

let X1, . . . , Xn = dec(k, C) in
for i = 1..n

let (ki, li, vi, mi) = Xi in
if (li = 0) ∧ (ta < vi ≤ ta + δ(li)) ∧ (li /∈ Ba)
elsif (li < l) ∧ (ta < vi ≤ ta + δ(li)) ∧ (li /∈ Ba)

Yi := ki, mi /* message */

let hi = Fresh(Ha) in
Ha := Ha ∪ {hi}
Yi := hi /* handle */
Θa := Θa ∪ {hi → (ki, li, vi, mi)}

else break

return Y1, . . . , Yn

3.3 Management of Revocation keys

We now introduce the commands for managing keys of
level Max, which will only need to be used if a compromise to
one of these keys is suspected. These keys, called revocation
keys, can be used either to revoke and update lower level
keys (keys with a smaller level than Max), or to revoke and
update the revocation keys. At least NMax revocation keys
must be given to revoke or update a revocation key.

921Update Max
If we cannot trust a certain revocation key anymore, the ad-
ministrator can update it using the updateMax function. It
takes as inputs a cipher-text of the key to be updated and
its update encrypted with n revocation keys k1, . . . , kn such
that n ≥ NMax and takes also the corresponding handles
where these keys are stored, h1, . . . , hn. updateMax com-
mands will be assumed to be sent on secure channels to
avoid that, if an attacker breaks very old Max keys, he could
immediately deduce the current active Max keys. Actually,
we do not need all updateMax commands to be runned un-
der secure channels but simply that this occurs suﬃciently
regularly.

updateMax(C, h1, . . . , hn)

for i = 1..n

let (ki, Max, vi, mi) = Θa(hi) in

if ∃ j ∈(cid:74)1, n(cid:75) s.t. vj ≤ ta ∨ ¬Distinct(h1, . . . , hn)

k) = dec(k1, . . . , dec(kn, C)) in

break
k ≤ ta) ∨ (v(cid:48)
break

let (updateMax, k(cid:48), v(cid:48)
if (v(cid:48)
Θa(h1) := (k(cid:48), Max, v(cid:48)

k, m(cid:48)

k, m(cid:48)
k)

k > ta + δMax)

Note that the updateMax command does not introduce

key cycles and avoid replays.
3.4 Management of Working keys

We call any key of level l : l < Max a working key. We in-
clude separate commands for creating working keys on the
device and for updating or revoking them, each of which
require a NMax level Max keys. These commands are in ad-
dition to the usual operational key management functions
arising from the encryption and decryption commands given
in section 3.2: they are intended to be used for bootstrapping
the system or for removing and updating possibly compro-
mised keys. In the descriptions below, n ≥ NMax.
Create
The create function takes as inputs a cipher-text containing
the “order” to create and the diﬀerent data to create, the
whole encrypted with n revocation keys k1, . . . , kn and takes
also the corresponding handles where these keys are stored,
h1, . . . , hn.

create(C, h1, . . . , hn)
let (ki, Max, v(cid:48)

for i = 1..n

if ∃ j ∈(cid:74)1, n(cid:75) s.t. v(cid:48)

i, m(cid:48)

break

i) = Θa(hi) in
j ≤ ta ∨ ¬Distinct(h1, . . . , hn)

let C(cid:48) = dec(k1, . . . , dec(kn, C)) in
let (create, x1, l1, v1, m1, . . . , xp, lp, vp, mp) = C(cid:48) in
if ∃ j s.t. (lj ≥ Max) ∨ (vj ≤ ta)∨

for j = 1..p

(vj > ta + δ(lj)) ∨ (lj ∈ Ba)
break
let h(cid:48)
Ha := Ha ∪ {h(cid:48)
i}
Θ(h(cid:48)
i) := (xi, li, vi, mi)
1, . . . , h(cid:48)
return h(cid:48)

i = Fresh(Ha) in

p

their updates, the whole encrypted with n revocation keys
k1, . . . , kn and takes also the corresponding handles where
these keys are stored, h1, . . . , hn.

update(C, h1, . . . , hn)

for i = 1..n

let (ki, Max, vi, mi) = Θa(hi) in

if ∃ j ∈(cid:74)1, n(cid:75) s.t. vj ≤ ta ∨ ¬Distinct(h1, . . . , hn)

break

1, l(cid:48)

1, v(cid:48)

1, m(cid:48)

let C(cid:48) = dec(k1, . . . , dec(kn, C)) in
let (update, x1, x(cid:48)
for j = 1..p

1, . . . , xp, x(cid:48)
for h ∈ Ha s.t. Θ(h) = (xj, l, v, m)
if (l < Max) ∧ (l(cid:48)
∧(l(cid:48)
j, l(cid:48)

j = l) ∧ (ta < v(cid:48)
j, v(cid:48)

j /∈ Ba)
Θ(h) := (x(cid:48)

j, m(cid:48)
j)

p, . . . , m(cid:48)

p) = C(cid:48) in

j ≤ ta + δ(lj))

Revoke
We ﬁrst deﬁne the revoke command in its most general form.
The administrator may wish to revoke keys, for example if
he suspects them to be compromised. He may wish to revoke
a precise set of keys but he may also wish to revoke them
on the basis of their attributes, e.g. validity time. To be as
ﬂexible as possible, we consider a revoke command that is
parametrized by a function F such that :
F : L × T × M → {⊥,(cid:62)}

which deﬁnes, according to some criteria (e.g. level, validity,
etc) what is going to be kept or deleted.

The revoke function takes as input such a function F ,
encrypted with n revocation keys, and the corresponding
handles h1, . . . , hn.

revoke(C, h1, . . . , hn)

for i = 1..n

let (ki, Max, vi, mi) = Θa(hi) in

if ∃ j ∈(cid:74)1, n(cid:75) s.t. vj ≤ ta ∨ ¬Distinct(h1, . . . , hn)

break

let (revoke, F ) = dec(k1, . . . , dec(kn, C)) in
for h ∈ Ha s.t. Θa(h) = (x, i, v, m)
Θa := Θa \ {h (cid:55)→ (x, i, v, m)}

if F (i, v, m) = (cid:62)

Note that, in practice an implementation should oﬀer some
specialized revoke functions for the particular application.
Indeed, sending an arbitrary Boolean function as a param-
eter would raise both implementation and security issues.
However, by deﬁning F in this general way we ensure that
our security results hold for any choice of F .
Blacklist
The Blacklist function takes as input a cipher-text contain-
ing the levels to blacklist together with expiration times, en-
crypted with n revocation keys k1, . . . , kn. The eﬀect of the
command is to add the levels to the blacklist and erase all
the keys of the corresponding levels, including smaller ones.
Blacklisting the level instead of all the keys saves memory.
It also means the administrator does not need to retain the
actual values of all the working keys.

Update
The update function takes as inputs a cipher-text containing
the “order” to update, the diﬀerent values to change and

blacklist(C, h1, . . . , hn)

for i = 1..n

let (ki, Max, vi, mi) = Θa(hi) in

922if ∃ j ∈(cid:74)1, n(cid:75) s.t. vj ≤ ta ∨ ¬Distinct(h1, . . . , hn)

break

let (blacklist, (l1, t1), . . . , (lp, tp)) =

dec(k1, . . . , dec(kn, C)) in

for i = 1..p
/* add to blacklist */
Ba := Ba ∪ {(li, ti)}
/* erase aﬀected keys */

for h ∈ Ha s.t. Θa(h) = (x(cid:48), l(cid:48), v(cid:48), m(cid:48))
Θa := Θa \ {h (cid:55)→ (x(cid:48), l(cid:48), v(cid:48), m(cid:48))}

if l(cid:48) ≤ li

3.5 Example

Let us consider two TRDs a and b (see Figure 2) initial-
ized with handles containing keys of level Max k and k(cid:48) and
sharing key k1 of level l1. In a ﬁrst step, the user of device
a generates, using the generateSecret command, a secret key
k2 with a level l2 (such that l2 < l1) and a validity v2, this
new secret appears in TRD a stored under a new handle. To
share the key with b, a encrypts k2 under k1 using encrypt.
When the message is received by the user of b he uses the
decrypt command which will store the new key k2 under a
new handle.
3.6 Threat Scenario

We consider a scenario where the attacker:
• controls the network (he may read and send messages

on the network),

• controls the host machines on which the TRD are con-
nected; therefore he can execute API commands on
any TRD

• may break some arbitrary keys of his choice, typically
by brute-forcing some keys or employing side-channel
attacks.

In the remainder of the paper we show that, provided
the attacker does not break too many keys of level Max (an
attacker should not break more than NMax − 1 keys simulta-
neously stored on a TRD), then our system can self-repair
given time or one can explicitly ﬁx a TRD. More precisely,
we show the two following results:

• If some key of level l (cid:54)= Max is lost then after some
time (actually, at time v + δl where v is the validity
date of the lost key) the keys of level l are secure again.
• Moreover, if some key of level l (cid:54)= Max is lost and a
TRD receives a command blacklisting the level l, then
all the keys on the TRD are secure again.

Note that our analysis will not deal with denial of service

attacks.

4.1 Syntax
We assume a ﬁnite set of names A and two inﬁnite sets
N and K respectively for nonces and keys. We also assume
a ﬁnite set H representing handles and an inﬁnite set M
representing the miscellaneous ﬁelds, with  ∈ M represent-
ing the empty element. We recall that L denotes the set of
levels. Messages are represented using a term algebra Terms
deﬁned by the following grammar:

T, T1, T2, . . . := a | n | k | l | t | m | {T}k | (cid:104)T1, T2(cid:105)

where a ∈ A, n ∈ N , k ∈ K, l ∈ L, t ∈ T , m ∈ M. The term
{t}k represents the message t (symmetrically) encrypted by
the key k while the term (cid:104)t1, t2(cid:105) represents the concatenation
(or more precisely, the pairing) of the two messages t1 and t2.
For simplicity, we will often write t1, t2, . . . , tn instead of
(cid:104)t1,(cid:104)t2, . . .(cid:104)tn−1, tn(cid:105) . . .(cid:105). The notion of subterm is deﬁned
as usual: t(cid:48) is a subterm of t if t(cid:48) occurs at some position p in
t, that is t|p = t(cid:48). We denote by St(m) the set of subterms
of m and by extension St(S) is the set of subterms of terms
in S.
A global state of our system is described by a tuple
(P,I, M, N, K, t) where P ⊆ A is the set of TRDs in the
system, t ∈ T represents the current time, M ⊆ Terms rep-
resents the set of messages sent so far over the network, N
and K are respectively sets of currently used nonces and
keys1 by all the APIs and I is a function:

I : a (cid:55)→ (Θa, Ha, Ba, ta, Na, Ka)

that represents the current local state of the TRD a ∈ P.
More precisely, Ha ⊆ H represents the ﬁnite set of handles
currently used in the API a and Ba ⊆ L × T represents the
set of blacklisted levels for which the TRD does not accept
keys anymore. Na ⊆ N and Ka ⊆ K are respectively the
nonces and keys that have been generated or stored on the
API. Θa represents the key table of the TRD. Formally, it
is a function

Θa : Ha → (K ∪ N ) × L × T × M

Indeed, as seen in Section 3.1, each handle h ∈ Ha points to
an entry (x, l, v, m) corresponding a nonce or a key x and its
attributes: the level l, its validity v, and other miscellaneous
information m.

As indicated in the deﬁnition of a global state, all keys

come with a level.

Definition 1. Let (P,I, M, N, K, t) be a global state and

let k be a key in K. The level of k is deﬁned as follows :
Level(k) = {l | ∃ a ∈ P, h ∈ Ha s.t. Θa(h) = (k, l, v, m)}

It is a priori possible for a key k to have several levels (i.e.
Level(k) is not a singleton) but we will show in our proofs
that this never happens for uncompromised keys. We will
therefore say that a key k is of level l if l ∈ Level(k).

4. FORMAL MODEL

We study the security oﬀered by our model in a symbolic
model, where messages are represented by terms, following
a now standard approach used for many protocols (see e.g.
[1, 2, 11]).

1N and K are here as artifacts of the model. Since an API
gets a random key (or nonce) when it creates it, there is
very little chance that it generates a key (or nonce) which
has already been used. To capture this, we model a global
knowledge of all nonces and keys used by all APIs to be sure
that freshly generated keys (or nonces) are new.

923TRD a

k, Max, v, m
k1, l1, v1, m1

···

TRD b

k(cid:48), Max, v(cid:48), m(cid:48)
k1, l1, v1, m1

···

generateSecret

−−−−−−−→

TRD a

k, Max, v, m
k1, l1, v1, m1

···

k2, l2, v2, m2

TRD b

k(cid:48), Max, v(cid:48), m(cid:48)
k1, l1, v1, m1

···

{k2,l2,v2,m2}k1
−−−−−−−−−−−→

TRD a

k, Max, v, m
k1, l1, v1, m1

···

TRD b

k(cid:48), Max, v(cid:48), m(cid:48)
k1, l1, v1, m1

···

k2, l2, v2, m2

k2, l2, v2

Figure 2: A simple execution. A key is created on device a and shared with device b.

t ∈ M
M (cid:96) t

M (cid:96) (cid:104)x, y(cid:105)

M (cid:96) y

M (cid:96) x, M (cid:96) y
M (cid:96) (cid:104)x, y(cid:105)
M (cid:96) x, M (cid:96) y
M (cid:96) {x}y

M (cid:96) (cid:104)x, y(cid:105)

M (cid:96) x

M (cid:96) {x}t, M (cid:96) y

M (cid:96) x

Figure 3: Deduction Rules (Intruder)

4.2 Semantics

The behavior of our API is modeled by the transitions
of our formal system. We deﬁne four kinds of transitions:
transition of time, forgery by the attacker, silent transitions,
and key management commands.

Transition of time.

We assume that the execution of API commands is instan-
taneous (this could be adapted to take into account worst
case execution time). The eﬀect of the time is modelled by
a separate and explicit TIM transition:

(P,I, M, N, K, t)

(Time passes)

−−−−−−−→ (P,I, M, N, K, t

(cid:48)

)

(TIM)
with t(cid:48) > t.

Forgery by the attacker.

As is usually the case in formal models, the ability of the
attacker to construct, or deduce, is modeled by a relation
(cid:96). We write S (cid:96) m if m can be deduced from S. The
deduction relation is formally deﬁned in Figure 3 Intuitively,
the attacker can deduce any term that can be obtained by
pairing, encrypting, projecting, and decrypting whenever it
has the encryption key.

Example 1. Let S = {{k1}k2 ,(cid:104)k2, k3(cid:105),{k4}k5}. Then
S (cid:96) k1, S (cid:96) k2, S (cid:96) k3, but S (cid:54)(cid:96) k4, S (cid:54)(cid:96) k5. We also
have S (cid:96) (cid:104)k2, k1(cid:105), but S (cid:54)(cid:96) (cid:104)k2, k4(cid:105).

The attacker may send any deducible message over the

network. This is reﬂected by the following transition.

The function I(cid:48) is deﬁned by I(cid:48) : a (cid:55)→ (Θ(cid:48)
the corresponding API a and I(cid:48)(a(cid:48)) = I(a(cid:48)) otherwise.

a, H(cid:48)

a, B(cid:48)

a, ta) for

Key management commands.

As explained in Section 2, at least some revocation com-
mands need to be kept hidden from the attacker. Other-
wise, assuming that the attacker controls and memorizes all
the traﬃc on the network and assuming he can break keys
(which corresponds to our threat scenario), then breaking
NMax old keys may compromise the entire system, even if
the compromised keys had not been in use for some time.

We therefore assume that the key management commands
for keys of level Max are sent over a private channel. In prac-
tice, this could be achieved by several means. For example,
we may assume that the key administrator has a physical
access to the TRD that needs to be updated. Or we may
also assume that the user would connect his/her TRD to a
trusted machine, on which a secure channel (e.g. via TLS)
is established with the key administrator. Note that the
key management commands for keys of level Max are exe-
cuted only when a key of level Max is lost (or suspected to
be lost), or when keys of level Max are updated (e.g. when
their validity has expired). We expect these events to occur
infrequently.

Note that our assumption does not prevent an adversary
from trying to run the UPM command. In particular, in case
it has suﬃciently many keys of level Max, it may well build
a well formed Update Max command and send it to a TRD.
This is reﬂected in the silent transitions deﬁned above.

All the other key management commands can be sent over
an insecure network. The corresponding transition system
is presented in Figure 4. The fact that we assume the UPM
command is sent over a secure channel is reﬂected in the fact
that the set M remains unchanged for this transition.

In the remainder of the paper we assume that managers
in charge of generating key management commands behave
consistently. More precisely, we assume that they only use
fresh keys when updating and creating keys and that they
never give diﬀerent attributes to the same key value.

(P,I, M, N, K, t)

(DED)
provided M (cid:96) m}.

(Deduction)

−−−−−−→ (P,I, M∪{m}, N, K, t)

Key compromise.

Silent transitions.
Each API command executed on a TRD a with input
m deﬁnes a transition Θa, Ha, Ba → Θ(cid:48)
a. More-
over, the TRD outputs some message m(cid:48). Given a global
state (P,I, M, N, K, t) such that m ∈ M, the corresponding
global transition is
(P,I, M, N, K, t) → (P,I(cid:48)
, t)
with N(cid:48) and K(cid:48) being respectively the sets of nonces and
keys generated by a during the execution of the command.

(cid:48)}, N ∪ N

, M ∪ {m

, K ∪ K

(cid:48)

a, H(cid:48)

a, B(cid:48)

(cid:48)

We model the fact that the attacker may compromise a
key by adding a transition lost, which allows an attacker to
obtain a key of his choice.
(P,I, M, N, K, t)

Lost(k)−−−−→ (P,I, M ∪ {k}, N, K, t)

(LST)

where k is a key that appears on at least one TRD, that is
k occurs in the image of I.
4.3 Example
Let us reconsider the example of Figure 2. Let E be the
initial global state, we have E = (P,I, M, N, K, t). To sim-
plify, let us consider that P = {a, b}, K = {k, k(cid:48), k1}, t and

924(UPM)

(NEW)

(UPD)

(RVK)

(BLK)

updateMax

−−−−−−→ (P,I(cid:48), M, N(cid:48), K(cid:48), t)

(P,I, M, N, K, t)
(P,I, M, N, K, t) create−−−→ (P,I(cid:48), M ∪ {m}, N(cid:48), K(cid:48), t)
with m = {create, N, N(cid:48), x1, l1, v1, m1 . . . , mp}k1···kn
(P,I, M, N, K, t)
update−−−→ (P,I(cid:48), M ∪ {m}, N(cid:48), K(cid:48), t)
p}k1···kn
with m(cid:48) = {update, x1, x(cid:48)
(P,I, M, N, K, t) revoke−−−→ (P,I(cid:48), M ∪ {m}, N, K, t)
with m = {revoke, F}k1···kn
(P,I, M, N, K, t) blacklist
with m = {blacklist, (l1, t1), . . . , (ln, tn)}k1···kn

−−−−→ (P,I(cid:48), M ∪ {m}, N, K, t)

1 . . . , m(cid:48)

1, m(cid:48)

1, v(cid:48)

1, l(cid:48)

For each transition, the function I(cid:48) and the sets N(cid:48) and K(cid:48)
are updated as speciﬁed by the corresponding command, as
for silent transitions.

Figure 4: Key management command transitions

2) =

M are arbitrary. Then I = {a (cid:55)→ (Θa, Ha, Ba, ta, Na, Ka),
b (cid:55)→ (Θb, Hb, Bb, tb, Nb, Kb)} where ta = tb = t, Ha =
{h1, h2}, Hb = {h(cid:48)
2}, Ka = Kb = K. We have Θa(h1) =
1, h(cid:48)
1) = (k(cid:48), Max, v(cid:48), m(cid:48)) and Θa(h2) = Θb(h(cid:48)
(k, Max, v, m), Θb(h(cid:48)
(k1, l1, v1, m1).
Using the generationSecret command with TRD a will lead
to a global state E(cid:48) = (P,I(cid:48), M, N, K(cid:48), t) where I(cid:48) = {a (cid:55)→
a), b (cid:55)→ (Θb, Hb, Bb, tb, Nb, Kb)} with
a, Ba, ta, Na, K(cid:48)
(Θ(cid:48)
a, H(cid:48)
a = K(cid:48) = K∪{k2}, H(cid:48)
a = Θa∪{h3 (cid:55)→
a = Ha∪{h2} and Θ(cid:48)
K(cid:48)
(k2, l2, v2, m2)}.
Then the encrypt command leads to a global state E(cid:48)(cid:48) =
(P,I, M(cid:48), N, K, t) where M(cid:48) = M ∪ {{k2, l2, v2}k1}. Finally
the decrypt command is used by TRD b on the message
{k2, l2, v2}k1 . That leads to E(cid:48)(cid:48)(cid:48) = (P,I(cid:48)(cid:48)(cid:48), M, N, K, t) with
I(cid:48)(cid:48)(cid:48) = {a (cid:55)→ (Θ(cid:48)
b , Bb, tb,
3} and
Nb, K(cid:48)(cid:48)(cid:48)
b = Θb ∪ {h(cid:48)
Θ(cid:48)(cid:48)(cid:48)
5. SECURITY

a, H(cid:48)
a, Ba, ta, Na, K(cid:48)
b = Kb ∪ {k2}, H(cid:48)(cid:48)(cid:48)
b )} with K(cid:48)(cid:48)(cid:48)
3 (cid:55)→ (k2, l2, v2, m2)}.

b , H(cid:48)(cid:48)(cid:48)
b = Hb ∪ {h(cid:48)

a), b (cid:55)→ (Θ(cid:48)(cid:48)(cid:48)

We are now ready to formally state the security properties
discussed in section 3.6. Intuitively, we would like to show
that apart from explicitly lost keys, any key that has not ex-
pired is secure, that is, cannot be deduced by the attacker.
However, this is not strictly the case: several commands such
as encrypt or the administrator commands produce messages
of the form {. . . k(cid:48) . . .}k that are sent over the network and
possibly stored by the attacker. It could the case that k ex-
pires before k(cid:48). Clearly, if k becomes known to the attacker
then k(cid:48) will be immediately known as well, even if k has
expired and k(cid:48) has not.

Therefore, we distinguish three kinds of key: valid keys,
latent keys, and dead keys. Informally, valid keys are those
stored on a device whose validity time has not passed, latent
keys are those which are not valid but on which security of
some encryption of a valid lower level key might still depend,
and dead keys are everything else.

Definition 2. Let E = (P,I, M, N, K, t) be a global state
and k ∈ K. Given a ∈ P, we denote by Θa the key table
stored on a and deﬁned by I(a) = (Θa, . . .).

• k is a valid key if ∃ a ∈ P, ∃ h ∈ Ha s.t. Θa(h) =
exists

(k, l, v, m) with
if
{. . . , k, l, v, m, . . .} ∈ St(M) with v > t.
We denote by VE the set of valid keys in E.

v > ta

there

or

• k is a latent key if ∃ a ∈ P, ∃ h ∈ Ha s.t. Θa(h) =
there exists

(k, l, v, m) with v + ∆(l) > t or if
{. . . , k, l, v, m, . . .} ∈ St(M) with v + ∆(l) > t.
We denote by UE the set of latent keys in E. The
notation UE comes from the fact that these keys may
also be viewed as “undead”.
• Otherwise, k is a dead key.

l1 < ··· < ln < l such that ∆(l) = (cid:80)n

A key is latent if it expired but less than ∆(l) ago. The
reason why latent keys still inﬂuence the security of the
whole system can be illustrated with the following scenario.
Let k be a key of level l and validity time v and consider
i=1 δ(li). Then it
may be the case that k was used to encrypt a key kn of
level ln just before its expiration time, yielding the message
{kn, ln, vn, mn}k with vn = v + δ(ln). Similarly, each key ki
may have been used to encrypt a key ki−1 of level li−1,
yielding a message {ki−1, li−1, vi−1, mi−1}ki with vi−1 =
vi + δ(li−1). Then it is easy to see that v1 = v + ∆(l)
and clearly if k is lost at anytime after its expiration date v
but before v + ∆(l) then the security of k1 (valid) would be
immediately compromised as well.
5.1 Initial states

As discussed in section 3.2, before being deployed, a TRD
is loaded with some level Max keys so that the administrator
can then remotely equip the device with an initial set of
working keys.

i , Max, va

Definition 3. A global state E∅ is said to be originating
if E∅ = (P,I0,∅, 0,∅,∅) with I0 : a (cid:55)→ (Θa, Ha, 0,∅,∅) and
for all a ∈ P, we have Ha = {ha
i ) =
(ka
i keys are revocation keys initially
placed in the memory of each API and should be all distinct:
ka
i = ka
5.2 Keys of level Max

n} with Θa(ha

j implies i = j.

i ). The ka

1, . . . , ha

i , ma

The keys of level Max are crucial since they can be used
to update and revoke all the keys, including keys of level
Max themselves. We ﬁrst show that security of these keys is
preserved, assuming that not too many of the keys of level
Max stored on an API are simultaneously lost.

Hypothesis 1. Let E = (P,I, M, N, K, t) be a global
state such that E∅ →∗ E and let L the set of keys that have
been lost so far (i.e. the set of keys k such that the transi-
tion Lost(k) has been executed). We assume that ∀a ∈ P,
we have
#{k | k ∈ UE ∩ L ∩ Ka and Max ∈ Level(k)} ≤ NMax − 1
where Ka is the set of keys associated to a by the function
I (that is I(a) = (. . . , Ka)).

We assume this hypothesis to hold in all the global states
we consider in the remainder of the paper. From a practical
point of view, it means that the lifetime of a key of level Max
should be set such that during the time when a Max key is
latent, it is suﬃciently unlikely that an attacker will break
more than NMax − 1 such latent keys. More precisely, our

925assumption is slightly weaker since the attacker may break
more keys provided that no more than NMax−1 of them have
occurred on the same TRD.

The design of our API ensures that no Max keys can be
learned by an attacker, except for the explicitly lost ones.
Theorem 1. Let E be a global state such that E∅ −→∗ E,

then :

∀k ∈ V Max

E

\ L , E (cid:54)(cid:96) k.

The proof relies on the fact that keys of level Max only
appear in key position in the messages sent over the network
and the fact that for any Max key, Level(k) is a singleton.
These two properties are shown to be preserved by appli-
cation of the rules and rely on Hypothesis 1 that ensures
that the attacker never knows suﬃciently many Max keys to
forge an administrator command.
5.3 Lower level keys

The case of keys of lower level is more diﬃcult than the
case of Max keys. First, as soon as a key k of level l is lost,
then any key of lower level l(cid:48) < l is compromised as well.
Indeed, for any key k(cid:48) of level l(cid:48) < l stored on the same TRD
as the key k, the attacker may use the encrypt command to
get k(cid:48) encrypted by k and therefore deduce k(cid:48). This attack
does not only compromise the keys stored on TRDs that
contain the compromised key k.
Indeed, assume that the
key k is stored on some TRD a1 and does not appear in
some other TRD a2. Then as soon as a1 and a2 share some
key k(cid:48)(cid:48) of level l(cid:48)(cid:48) > l, the attacker may use the encrypt
command on a1 to get k encrypted by k(cid:48)(cid:48). Sending this
encryption to a2 and executing the decrypt command on a2,
the attacker registers k on a2 and can now gain any key of
level lower then l.
Therefore, as soon as a key of level l is lost, any key of
level l(cid:48) < l should be considered as lost too. We introduce
the notion of keys compatible with a set of levels, which are
latent keys that have an uncompromised level.

Definition 4. Let E = (P,I, M, N, K, t) be a global state,
L a set of keys (typically lost keys), and k ∈ K. Let Lv be a
set of levels (that typically corresponds to the levels of keys
lost so far). Then k is compatible with Lv if k ∈ UE \ L ,
Max /∈ Level(k), and there exists l ∈ Level(k) such that l (cid:54)< Lv
(that is l (cid:54)< l(cid:48) for any l(cid:48) ∈ Lv).
global state E. We may write GLv
L is clear from the context.

(E,L ) the set of keys compatible with Lv in the
(E,L ) when

E instead of GLv

We note GLv

The ﬁrst property of our API is that keys of levels not
marked as lost are uncompromised. We also show that
for such keys, the level and all other attributes are unique
(i.e. consistent across all TRDs). We actually need to en-
force a stronger property, called robustness.

Definition 5. A global state E = (P,I, M, N, K, t) is
robust up to a set of levels Lv and a set L of (lost) keys if
the following properties are satisﬁed:

(1) We consider that (l, v, m) are attributes of k if any of

these three cases holds :
(a) ∃ a ∈ P, h ∈ Ha s.t. Θa(h) = (k, l, v, m),

(b) ∃ q ∈ K, m(cid:48) ∈ M s.t. Max ∈ Level(q) and

{cmd, . . . , k, l, v, m, . . . }q1···qj q ∈ St(m(cid:48)) with cmd (cid:54)=
blacklist and Max ∈ Level(qi),

(c) ∃ q ∈ K, m(cid:48) ∈ M s.t. {. . . , k, l, v, m, . . .}q ∈

St(m(cid:48)).

If (l1, v1, m1) and (l2, v2, m2) are attributes of a key
k ∈ GLv
(2) ∀k ∈ GLv

E , then (l1, v1, m1) = (l2, v2, m2).
E , ∀m ∈ M s.t. k ∈ St(m), then, any occur-

rences of k is of one of these three forms :
(i) {m(cid:48)}k,
(ii) {. . . , k, . . .}k(cid:48) with k(cid:48) ∈ K, vk ≤ vk(cid:48) + δk and
Level(k) < Level(k(cid:48)) (cid:54)= Max,
(iii) {. . . , k, . . .}q1···qnk(cid:48) with q1, . . . , qn, k(cid:48) ∈ K s.t.,
for i ∈ [1, n], Max ∈ Level(qi), Max ∈ Level(k(cid:48)),
k(cid:48) /∈ L and vk ≤ vk(cid:48) + δk,

(3) Lv ≥s {l | ∃k ∈ L ∩ UE s.t. l ∈ Level(k)}) where
S1 ≥s S2 if for any l1 ∈ S1, there exists l2 ∈ S2 such
that l1 ≥ l2.

Robustness is meant to precisely control how compatible
keys occur in a global state E. It ensures two main proper-
ties. First, compatible keys have a unique attribute in the
system, that is, levels and validity times of compatible keys
are consistently propagated through the system. Moreover,
robustness ensures that compatible keys occur only in key
position, except if they are encrypted by a key of greater
level or if they occur in an administrator command (thus
encrypted by a key of level Max). The third item is a tech-
nical condition that ensures that levels corresponding to lost
(and not yet dead) keys should always be considered as com-
promised.

Whenever a state is robust, all its compatible keys remain

secret from the attacker.

Proposition 1. Let E = (P,I, M, N, K, t) be a global
state, L a set of keys (typically lost keys), and k ∈ K. Let
Lv be a set of levels. Assume that E is robust up to Lv and
L then:

∀k ∈ GLv

(E,L ) M (cid:54)(cid:96) k.

Our three main results are:
• A global state is always robust up to the levels of lost
keys (Theorem 2). This means that losing a key does
not compromise any other key apart from those at
lower levels than the lost key, i.e.
those which are
trivially compromised.

• Once a lost key is dead, the corresponding level is pro-
tected again (Theorem 3), meaning that even when a
key is lost and no special action is taken, the system
repairs itself after a certain time.

• When a TRD receives a blacklist command, the cor-
responding levels are immediately protected again on
this TRD (Theorem 4).

Theorem 2. Let E be a global state such that E∅ −→∗
E and let L be the set of keys lost along the execution
E∅ −→∗ E. Then E is robust up to Lv = {l | ∃ Lost(k) ∈
L and Level(k) = l} and L .

926Theorem 2 is the key theorem of our paper and its proof
consists in proving that robustness is invariant under the
rules of our API. Theorem 1 ensures that it is impossible for
an attacker to break more than NMax − 1 keys of level Max.
This, in turn, ensures that all accepted key management
commands come from the administrator. Then it remains
to show that the robustness property is invariant under ap-
plication of the other rules of the API. For the deduction
rule, the ﬁrst step is to show that compatible (latent) keys
are all non-deducible. For decryption, the robustness prop-
erty in the global state E ensures that encrypted messages
have the right form. Therefore when decrypting a message,
the newly stored keys also satisfy the invariant. In case the
attacker forges a message, the checks on the levels and the
validity times ensure that the newly stored keys are of an
incompatible level and therefore their security does not need
to be assessed. The arguments for encryption and the other
commands are along the same lines.

Theorem 3. Let E, E(cid:48) be two global states such that
E∅ −→∗ E −→∗ E(cid:48). Assume that E is robust up to Lv and
L and let l ∈ Lv be a compromised level. Let L (cid:48) be the set of
keys lost along the execution E −→∗ E(cid:48). We further assume
that there has been no ‘lost’ event for keys of level greater
than l, that is, there is no k ∈ L (cid:48) such that Level(k) ≥ l.
Let v = sup({vk | k ∈ L and Level(k) = l}), where vk is
the validity time associated to k (Theorem 2 ensures vk is
unique). Then:

(cid:48) ≥ v + ∆(l) =⇒ E

t

(cid:48)(cid:48)

(cid:48)(cid:48)
v for L (cid:48)(cid:48)
is robust up to L

,
−−−−→
where t(cid:48) is the global time of E(cid:48) and E(cid:48)(cid:48) is such that E(cid:48) Lost(A)
(cid:48)(cid:48)
E(cid:48)(cid:48) with A = {k | Level(k) = l(cid:48) with l(cid:48) < l} and L
v =

k∈L (cid:48)(cid:48) Level(k)) \ {l} where L (cid:48)(cid:48) = L (cid:48) ∪ A.

(Lv ∪(cid:83)

Intuitively, Theorem 3 ensures that whenever a key k has
been lost then once k is not latent any more (i.e. once k
is dead), the system is now robust up to Lv \ {l} plus the
levels {l(cid:48) | l(cid:48) < l} which can still be compromised and the
newly lost keys L (cid:48), that is, the keys that might have been
lost during the execution between E and E(cid:48). Theorem 3
is actually a consequence of Theorem 2, which can be seen
by carefully analysing the robustness property and noticing
that once the lost key k is dead, the set of keys compati-
(cid:48)(cid:48)
ble with L
v and Lv coincide (if the keys of lower levels are
explicitly lost).

We now state the security gained with the blacklist com-
mand. This command only ﬁxes the system locally. We
therefore need to deﬁne robustness locally to a TRD.

Definition 6. Let E be a global state, L be a set of
lost keys, and Lv be a set of levels. Let a ∈ P be a TRD.
Then a is locally robust up to Lv and L in E if Ea =
({a},Ia, M, N, K, t) is robust up to Lv where Ia is the re-
striction of I on {a} and where the conditions of robustness
are considered for keys that are stored on a (that is, appear
in the image of Θa).

Proposition 2 is the analog of Proposition 1 for locally
robustness and states that compatible keys on locally robust
TRDs are secure.

Proposition 2. Let E = (P,I, M, N, K, t) be a global
state, L a set of keys (typically lost keys), and k ∈ K. Let

Lv be a set of levels. Assume that a is locally robust up to Lv
and L in E then:
(E,L ) ∩ {k
∀k ∈ GLv

(cid:48) | ∃h s.t. Θa(h) = (k

, l, v, m)} M (cid:54)(cid:96) k.

(cid:48)

Finally, we can state our ﬁnal theorem that ensures that
blacklisting a level protects the corresponding keys on a
TRD.

Theorem 4. Let E = (P,I, M, N, K, t) a be a global
state s.t. E∅ −→∗ E. Let L be a set of (lost) keys. As-
sume that a ∈ P is locally robust up to Lv and L in E.
Assume that E L−−→−→∗ E(cid:48) with L a blacklist command for
TRD a, level l, and validity time th (with th greater or equal
to vh = sup({vk | k ∈ L and l ∈ Level(k)}). Let L (cid:48) be
the set of keys lost along the execution E L−−→−→∗ E(cid:48). We
further assume that there has been no lost event for keys of
level greater than l, that is, there is no k ∈ L (cid:48) such that
Level(k) ≥ l.
k∈L (cid:48)(cid:48) Level(k))\
−−−−→ E(cid:48)(cid:48) with A =

{l} in E(cid:48)(cid:48) where E(cid:48)(cid:48) is such that E(cid:48) Lost(A)
{k | Level(k) = l(cid:48) with l(cid:48) < l} and L (cid:48)(cid:48) = L (cid:48) ∪ A.

(cid:48)(cid:48)
Then a is locally robust up to L

v = (Lv∪(cid:83)

Similarly to Theorem 3, Theorem 4 ensures that once a
level is blacklisted, the corresponding level is secure again.
More precisely, it states that the system is then robust up
to Lv \ {l} plus the levels {l(cid:48) | l(cid:48) < l} which can still be
compromised and the newly lost keys L (cid:48), that is, the keys
that might have been lost during the execution between E
and E(cid:48). The proof follows easily from Theorem 3.
5.4 Application

Suppose we are using our API to implement a protocol
similar to Kerberos [13] for granting access to resources (see
Figure 5). We consider key distribution centre (KDC ), a
ticket granting server (TGS ) and principals Alice (a) and
Bob (b).

We will order the levels using an inclusion ordering, where
Ka has level (a), Ka,TGS has level (a, TGS , KDC ) and Ka,b
has level (a, b, TGS , KDC ) (i.e. the levels correspond to the
parties assumed to have access to the key). Other terms are
considered public (level 0). For two levels l, l(cid:48), l > l(cid:48) ⇔ l ⊂
l(cid:48). The protocol is now implementable using the commands
of the API.

In a deployment of the system, we assume that devices for
the users a, b,. . . and for the servers TGS , KDC are loaded
with appropriate keys of level Max as part of some personal-
isation process. The administrator can then load long term
keys Ka, Ka,TGS etc. on to the user devices and the servers.
They can now play out the protocol using just the working
key commands encrypt, decrypt, secretGenerate, publicGener-
ate. Note that when implemented by our API the protocol
messages will be tagged following our scheme, e.g. message
2 will appear as {tgt, 0, v(cid:48), TGT}KTGS ,
{Ka,TGS , (a, TGS , KDC ), v, KA,TGS}Ka where TGT and KA,TGS
are elements in the miscellaneous ﬁeld and v, v(cid:48) are some va-
lidity times.

Suppose key Ka,TGS is compromised. Then the admin-
istrator has two choices. One is to do nothing. Then he
knows that after time v + ∆((a, TGS , KDC )), where v is
the expiry time of Ka,TGS , the system returns to a state
where keys at level (a, TGS , KDC ) are secure. Lower level
keys like session keys Ka,b might still be compromised, but

927a

→ KDC :
1.
2. KDC → a
:
→ TGS
3.
:
4. TGS → a
:
→ b
5.
:

a

a

request, KDC
{tgt}KTGS ,{Ka,TGS}Ka
a,b, {tgt}KTGS ,{Auth1}Ka,TGS
{Ka,b}Kb ,{Ka,b}Ka,TGS
b,{Ka,b}Kb ,{Auth2}Ka,b

Figure 5: A Kerberos-like protocol

new session keys will be safe. Alternatively he can signal
to TGS and a to blacklist the key. In this case this level
(a, TGS , KDC ) becomes unusable. However, to preserve
functionality, and administrator can add extra tags ti to all
levels, so level (a) becomes (a, t1), level (a, TGS , KDC ) be-
comes (a, TGS , KDC , t1, t2), and the session keys Ka,b will
have level (a, b, TGS , KDC , t1, t2, t3). If Ka,TGS is compro-
mised the administrator only needs to issue a new key with a
new level a, b, TGS , KDC , t1, t(cid:48)
2 and the device can continue
to issue tickets securely while level (a, TGS , KDC , t1, t2) is
blacklisted.

6. CONCLUSIONS

We have presented our API for key management with re-
vocation and proved its security properties. While the un-
derlying assumptions for our system to be secure are not un-
realistic, in future work we intend to weaken them further.
To relax the assumption on level Max messages remaining
conﬁdential seems to require more cryptographic primitives.
In particular, in order to ensure that the loss of long term
keys does not lead to the loss of update messages we require
perfect forward secrecy, which would seem to imply the use
of asymmetric cryptography. Extending our API to asym-
metric cryptography is ongoing work. We also assume here
that each device has a real time clock. This could be weak-
ened by adding some sort of nonce based freshness test for
each new key accepted, as required in the restricted version
of the API on which our revocation scheme is based [4]. All
our security proofs are made in the symbolic model, but it
should be possible to extend them to the standard model of
cryptography under the usual assumptions, i.e. IND-CCA2
for the authenticated encryption scheme, since we avoid
problematic constructions such as key cycles.

Acknowledgments
The research leading to these results has received funding
from the European Research Council under the European
Union’s Seventh Framework Programme (FP7/2007-2013)
/ ERC grant agreement no 258865, project ProSecure, and
the Direction G´en´erale de l’Armement under contact no
11810242, Secure Interfaces.

7. REFERENCES
[1] M. Abadi, B. Blanchet, and C. Fournet. Just fast

keying in the pi calculus. ACM Transactions on
Information and System Security (TISSEC),
10(3):1–59, July 2007.

[2] B. Blanchet and A. Chaudhuri. Automated formal

analysis of a protocol for secure ﬁle sharing on
untrusted storage. In Proceedings of the 29th IEEE
Symposium on Security and Privacy (S&P’08), pages
417–431, Oakland, CA, 2008. IEEE.

[3] C. Cachin and N. Chandran. A secure cryptographic

token interface. In Computer Security Foundations
(CSF-22), pages 141–153, Long Island, New York,
2009. IEEE Computer Society Press.

[4] V. Cortier and G. Steel. A generic security API for

symmetric key management on cryptographic devices.
In Proceedings of the 14th European Symposium on
Research in Computer Security (ESORICS’09),
volume 5789 of Lecture Notes in Computer Science,
pages 605–620, Saint Malo, France, September 2009.
Springer.

[5] V. Cortier, G. Steel, and C. Wiedling. Revoke and let

live: A secure key revocation api for cryptographic
devices. Research Report RR-7949, INRIA, 2012.

[6] J. Courant and J.-F. Monin. Defending the bank with

a proof assistant. In Proceedings of the 6th
International Workshop on Issues in the Theory of
Security (WITS’06), pages 87 – 98, Vienna, Austria,
March 2006.

[7] L. Eschenauer and V. D. Gligor. A key management

scheme for distributed sensor networks. In Proceedings
of the 9th ACM Conference on Computer and
Communications Security (CCS), pages 41–47, 2002.

[8] S. Fr¨oschle and G. Steel. Analysing PKCS#11 key
management APIs with unbounded fresh data. In
Joint Workshop on Automated Reasoning for Security
Protocol Analysis and Issues in the Theory of Security
(ARSPA-WITS’09), volume 5511 of Lecture Notes in
Computer Science, pages 92–106, York, UK, 2009.
Springer.

[9] F. E. Kargl. Sevecom baseline architecture. Deliverable

D2.1-App.A for EU Project Sevecom, 2009.

[10] F. Levy. SAM and key management functional

presentation. Available from
http://www.calypsostandard.net/, December 2010.
[11] G. Lowe. Breaking and ﬁxing the Needham-Schroeder

public-key protocol using FDR. In Tools and
Algorithms for the Construction and Analysis of
Systems (TACAS’96), volume 1055 of LNCS, pages
147–166. Springer-Verlag, march 1996.

[12] S. M¨odersheim and P. Modesti. Verifying sevecom

using set-based abstraction. In IWCMC, pages
1164–1169. IEEE, 2011.

[13] C. Neuman, T. Yu, S. Hartman, and K. Raeburn. The

kerberos network authentication service - rfc 4120.
Available at http://tools.ietf.org/html/rfc4120.
[14] G. Steel and A. Bundy. Attacking group protocols by

refuting incorrect inductive conjectures. Journal of
Automated Reasoning, 46(1–2):149–176, January 2006.
Special Issue on Automated Reasoning for Security
Protocol Analysis.

[15] Trusted Computing Group. TPM Main Part 3

Commands., level 2 revision 116 edition, March 2011.
Speciﬁcation Version 1.2.

[16] B. Weyl. Secure on-board architecture speciﬁcation.

Deliverable D3.2 for EU Project EVITA, http:
//evita-project.org/Deliverables/EVITAD3.2.pdf,
August 2011.

[17] X. Z. Yong Wan, Byrav Ramamurthy. Keyrev: An
eﬃfcient key revocation scheme for wireless sensor
networks. In IEEE International Conference on
Communications (ICC), pages 1260 – 1265, 2007.

928