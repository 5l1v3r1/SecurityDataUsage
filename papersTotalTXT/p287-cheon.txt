A New Additive Homomorphic Encryption

based on the co-ACD Problem

Jung Hee Cheon

Seoul National University

Republic of Korea

jhcheon@snu.ac.kr

Hyung Tae Lee

Nanyang Technological

University
Singapore

hyungtaelee@ntu.edu.sg

Jae Hong Seo
Myongji University
Republic of Korea

jaehongseo@mju.ac.kr

ABSTRACT
We propose an eﬃcient additive homomorphic encryption
scheme. In our scheme, an encryption of a message is simply
its noisy modular reduction by several diﬀerent moduli. The
security of our scheme relies on the hardness of a new prob-
lem, the co-Approximate Common Divisor problem. We an-
alyze its hardness by applying all known attacks and devis-
ing dedicated attacks. These analyses are not complete, but
give suﬃciently plausible evidence for the hardness of this
new problem.

Our scheme has an advantage in the performance since
both of encryption and decryption consist of only several
modular multiplications where a modulus is a hard-to-factor
integer N or its prime factor, whereas the previous require
more expensive modular exponentiations. In fact, our rudi-
mentary implementation demonstrates that our public-key
encryption scheme requires about 0.72 ms, 4.00 µs and 0.40 µs
for encryption, decryption and an addition of ciphertexts,
respectively.
It also takes about 40 µs to compute an en-
cryption of the mean of 1000 integers of 128-bit from their
ciphertexts. To the best of our knowledge, our encryption
scheme is the most eﬃcient of those that support an additive
homomorphic property.

As an application of additive homomorphic encryption,
we present how to eﬃciently evaluate a symmetric polyno-
mial by additionally providing ciphertexts of some powers of
messages. We also present a threshold version of our encryp-
tion scheme for smooth adoption of our scheme to advanced
applications such as private set operations.

Categories and Subject Descriptors
E.3 [Data]: Data Encryption

General Terms
Design; Theory

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/266026.2660335.

Keywords
Additive homomorphic encryption; Chinese remainder the-
orem; co-ACD problem

1.

INTRODUCTION

Additive homomorphic encryption has numerous applica-
tions. It is a fundamental tool to design cryptographic pro-
tocols, such as oblivious pseudorandom functions [30], obliv-
ious transfers [30], private information retrieval [40], and se-
cure 2-party computations including private set intersection
protocols [22, 30].
Its threshold version is also an impor-
tant primitive to construct various cryptographic protocols
including secure multi-party computations [16, 19, 22, 33,
31], electronic voting [17], and commitment schemes [18], to
name a few.

1.1 Our Results

In this paper, we provide a new additive homomorphic
encryption scheme based on noisy modular reduction and its
threshold version. Our proposed scheme has two advantages:

• Both of encryption and decryption consist of simple
operations, such as modular/integer additions and only
several modular multiplications and so take only quad-
ratic time (or quasilinear time using the FFT) in the
size of modulus, where a modulus is a hard-to-factor
integer N or its prime factor.

• The message space is ZQ for any positive integer Q.
Hence it can be a prime ﬁeld as well as a ring with a
hard-to-factor order as in Paillier scheme.

Our scheme has an advantage in the performance due to
the simplicity of operations in encryptions/decryptions. Our
implementation takes about 0.72 ms, 4.00 µs, and 0.40 µs
for encryption, decryption, and addition of our public-key
encryption, respectively.
It shows that our scheme is the
most eﬃcient of those that support an additive homomor-
phic property.

The type of the message space is important in some appli-
cations. For instance, we can eﬃciently and uniquely deter-
mine roots of a polynomial over the message space when it is
a ﬁeld. In particular, ﬁnding a root of a polynomial deﬁned
over ZN is equivalent to factoring N [44] and so there is no
polynomial-time root-ﬁnding algorithm for polynomials over
the message space of Paillier encryption without the factor-
ization of N . Hence, many polynomial representation based
private set operation protocols require additional expensive
costs to extract roots of polynomials [33, 23, 43].

287Note that our scheme supports a limited number of ad-
ditions, but it is allowed to add exponentially many cipher-
texts in the security parameter. Our scheme also supports a
limited number of scalar multiplications with respect to the
size of the message space and selected parameters. Hence,
our scheme can be applied to applications requiring additive
property and a limited number of scalar multiplications. For
instance, private set operations [22, 33, 43] and electronic
voting [17] require only one scalar multiplication. We pro-
vide a threshold version of our scheme for smooth adoption
to such applications.

Finally, we propose a way to advance the advantage of the
proposed scheme. To be concrete, we present a method to
eﬃciently evaluate symmetric polynomials by additionally
giving encryptions of powers of messages. This is particu-
larly eﬃcient when evaluating low-degree symmetric poly-
nomials in many variances, such as the variance function
for numerous data. Our implementation takes about 120 µs
to evaluate the variance of 1000 128-bit elements using our
method.

1.2 Our Methodology

We ﬁrst provide a symmetric additive homomorphic en-
2 , Q
cryption scheme. To encrypt a message M ∈ Z ∩ (− Q
2 ],
we add some error eQ where e is a randomly chosen ele-
ment from Z ∩ (−2ρ, 2ρ) for some positive integer ρ. We
then perform modular reductions with hidden prime moduli
pi. When decrypting the ciphertext, we use the Chinese Re-
mainder Theorem (CRT) to obtain M + eQ and remove an
error by modular reduction with modulus Q. The ciphertext
corresponding to the sum of messages can be obtained from
component-wise additions among ciphertexts.

One may try to apply a generic conversion [42] using ad-
ditive homomorphic property to convert our symmetric en-
cryption into an asymmetric one. Since the output length
of the addition algorithm of our scheme is logarithmic in
the number of input ciphertexts, we can apply this conver-
sion to our scheme when the message space is Z2. However,
there is no such conversion when the message space is larger
than Z2. Moreover, since pi’s are hidden in our scheme,
the subset sum functions of encryption of zeros are not 2-
universal hash functions and hence we can not apply the
classical leftover hash lemma to our scheme. To overcome
this obstacle, we consider a lattice generated by two vectors
which are encryption of zeros and satisfy some constraints.
Then, we choose some encryption of zeros which are in the
half-open parallelepiped generated by this lattice and deﬁne
an encryption algorithm by adding the subset sum function
of them and the relatively large constant times basis vectors
to a message.

To provide a security analysis of our construction, we in-
troduce a new hard problem, the co-Approximate Common
Divisor (co-ACD) problem. Informally, the co-ACD prob-
lem is to ﬁnd a nontrivial factor ofQk
i=1 pi when polynomi-
ally many vectors (eQ mod p1, ··· , eQ mod pk) are given for
a public integer Q and a randomly chosen e ∈ Z∩ (−2ρ, 2ρ).
Here, we note that (eQ mod p1, eQ mod p2) is of form of
ciphertext of zeros in our encryption scheme. The name of
the co-ACD problem is derived from the similarity with the
(extended) ACD problem, which has been used to prove the
security of the recently proposed somewhat/fully homomor-
phic encryption schemes over the integers [47, 14, 15, 9].
The diﬀerence between two problems is only the sampling

distributions of the problem instances: One is from erro-
neous outputs of the CRT homomorphism, and the other
from erroneous outputs of its inverse. To validate the hard-
ness of this problem, we consider various attacks, includ-
ing all known attacks against the ACD problem: Chen and
Nguyen [8] and Coron et al. [15] attacks, simultaneous Dio-
phantine approximation, orthogonal lattice attacks, and the
Coppersmith attack [12]. Based on these analyses, we pro-
vide speciﬁc parameters for our scheme and it shows that the
public key size of our scheme is about 1000 times larger than
the previous [41, 32], but it is around 1.3 MB. Our scheme
also has a comparable ciphertext size to the previous best
result [41, 32].

1.3 Related Work

There have been various studies for constructing additive
homomorphic encryption schemes under various assumptions.
Goldwasser and Micali [27] proposed the scheme which sup-
ports additions on Z2 using the quadratic residuosity as-
sumption. Later, Benaloh [2] extended the message space
to Zp for a prime p under the prime residuosity assump-
tion and Naccache and Stern [35] subsequently extended the
for small primes pi’s. Recently,
message space to Z
Joye and Libert [32] modiﬁed a scheme so that its message
space is Z2k under the 2k-th residuosity assumption. Since
these schemes should solve a discrete logarithm problem over
their message spaces for decryption, either their decryption
algorithms are very ineﬃcient or their message spaces are
limited.

i=1 pi

Qk

Okamoto and Uchiyama [39] proposed a diﬀerent approach
on Z∗
p2q under assuming that factoring p2q is hard. Pail-
lier [41] presented the construction on Z∗
N 2 under a new as-
sumption, the decisional residuosity assumption, and Dam-
g˚ard and Jurik [20] generalized Paillier cryptosystem to the
scheme on ZN s+1 for s ≥ 1. Their message spaces are either
Zp for a hidden prime p or ZN s for an RSA modulus N , and
hence they are also limited.

In 2005, Boneh et al. [3] proposed an additive homo-
morphic encryption supporting one multiplication, but their
scheme has to solve a discrete logarithm problem for decryp-
tion. Recent fully or somewhat homomorphic encryption
schemes [26, 34, 36, 5, 9] have also the additive homomor-
phic property, but their public key and ciphertext size are
much larger than (at least 10 times) those of ours.

1.4 Organization

We provide our symmetric additive homomorphic encryp-
tion scheme in Section 2 and convert it into a public version
in Section 3. Section 4 analyzes the hardness of the co-
ACD problem by applying well-known techniques and de-
vising dedicated attacks. Some speciﬁc parameters and im-
plementation results are presented in Section 5. Section 6
provides a threshold version of our encryption scheme and
Section 7 explores various applications.

2. OUR SYMMETRIC ADDITIVE HOMO-

MORPHIC ENCRYPTION

Notation If A is a set, a ← A deﬁnes a as being uniformly
and independently sampled from A. When D is a distribu-
tion, a ← D denotes choosing an element a according to the

2(cid:3) and x mod p denote the

distribution D. Zp := Z ∩(cid:0)− p

2 , p

288ulo p.

unique integer in Z ∩(cid:0)− p
For pairwise co-prime integers p1, . . . , pk and N =Qk

2(cid:3) that is equivalent to x mod-

we will use the following ring isomorphism:

i=1 pi,

2 , p

Φ(p1,··· ,pk ) : ZN →

Zpi ,

x 7→ (x mod p1,· ·· , x mod pk).

kYi=1

This is simply denoted by Φ unless there is a chance of con-
fusion. Given integers p1,··· , pk, and Q, we say that ~xj
is sampled from the distribution ˆDρ,Q(p1,· ·· , pk) if ~xj =
Φ(p1,··· ,pk )(eQ) where e ← Z ∩ (−2ρ, 2ρ).
We say a function f : N → R is negligible if for every c,
there exists nc such that f (n) ≤ n−c for every n ≥ nc.
Throughout the paper, we will use the following parame-
ters.

λ: the security parameter
ρ: the bit length of the error
η: the bit length of secret primes
γ: the bit length of a domain modulus N where N is
a product of secret primes
Q: the size of the message space
A: the maximum number of allowed additions among
fresh ciphertexts
m: the number of public keys

2.1 Construction

In this subsection, we present our symmetric additive ho-
momorphic encryption scheme. Our scheme is constructed
by adopting the recently proposed technique for constructing
homomorphic encryption schemes to the inverse function of
CRT. More precisely, we encode a message by adding some
error, and perform modular reductions with hidden prime
moduli in the encryption phase. Then, we decrypt a cipher-
text by applying the CRT, and then by removing the error
using a modular reduction.

The details of our scheme are as follows:
• Setup(1λ) : Generate two η-bit distinct primes p1, p2
and a positive integer Q for the message space which
satisfy gcd(Q, pi) = 1. Set N := p1p2. For each i, com-
pute a unique positive integer ¯pi ∈ [1, N ) that is con-
gruent to 1 modulo pi and 0 modulo the other prime.
Then each ¯pi can be written as

¯pi = pj(cid:0)p−1

j mod pi(cid:1) mod N

for j 6= i. Output the secret key sk = {N, p1, p2, ¯p1, ¯p2}.
• Enc(sk, M ): Choose e ← Z ∩ (−2ρ, 2ρ). For a given

message M ∈ ZQ, compute a vector

~c = (M + eQ mod p1, M + eQ mod p2)

and output ~c.

• Dec(sk, ~c): Parse ~c into (c1, c2). Output M = (c1 ¯p1 +

c2 ¯p2 mod N ) mod Q.

• Add(~c1,··· , ~cℓ): OutputPℓ

wise integer additions.

i=1 ~ci through component-

Correctness We can easily verify the correctness of our
scheme. For a given fresh ciphertext ~c = (c1, c2) = (M +
eQ mod p1, M + eQ mod p2), it holds that

M + eQ ≡ c1 ¯p1 + c2 ¯p2 mod N

1, c′

c′
1 ¯p1 + c′

by the CRT and hence M ≡ (c1 ¯p1 + c2 ¯p2 mod N ) mod Q.
Assume that ~ci = (ci1, ci2) = (Mi+eiQ mod p1, Mi+eiQ mod
p2) are given for 1 ≤ i ≤ A. Let ~c′ = (c′
2) be the sum
of A ciphertexts ~ci’s deﬁned by ~c′ = (c′
1, c′
i=1 ~ci =
(cid:16)PA
i=1 ci1,PA

2) = PA
i=1 ci2(cid:17). Then the following relation holds:

AXi=1
and gives the correct valuePA
i=1 Mi mod Q if |PA
QPA
most 2γ−(ρ+⌈log Q⌉+2) fresh ciphertexts since |PA
QPA

i=1 Mi +
i=1 ei| < N/2. Hence our scheme allows us to add at
i=1 Mi +
i=1 ei| < 2ρ+1AQ, and so our scheme supports the lim-
ited number of additions. However, the number of allowed
additions is exponential in the security parameter λ under
our parameter setting.

AXi=1

2 ¯p2 ≡

ei mod N

Mi + Q

2.2 Security Analysis

To guarantee the security of our scheme, we start with in-
troducing a new hard problem, called the co-ACD problem.
Under assuming the hardness of this problem, we will pro-
vide the semantic security of our symmetric additive homo-
morphic encryption scheme. We will discuss on the hardness
of this problem in Section 4.

The co-ACD Problem Now, we introduce a new hard
problem, the co-ACD problem, which is similar to the ACD
problem, ﬁrstly presented by Howgrave-Graham [29] and
whose variants are recently utilized to guarantee the security
of somewhat/fully homomorphic encryption schemes [47, 14,
15, 9].

Throughout the paper, for η-bit primes pi’s and a posi-
tive integer Q, Alg1(p1, ··· , pk, ρ, Q) denotes the algorithm
which performs outputting (eQ mod p1,··· , eQ mod pk) from
the distribution ˆD(ρ,Q)(p1,··· , pk) and Alg2(p1,··· , pk) de-
notes the algorithm which chooses ci ← (− pi
2 ] ∩ Z for
1 ≤ i ≤ k and outputs (c1,··· , ck). OAlg denotes an oracle
such that each oracle returns an output of the corresponding
algorithm Alg with a fresh randomness.

2 , pi

Definition 1

(co-ACD Problem). The (ρ, η, k; Q)-co
Approximate Common Divisor (co-ACD) problem is deﬁned
as follows. Pick η-bit random hidden primes pi for 1 ≤ i ≤
k. Given polynomially many samples ~xj from ˆDρ,Q, ﬁnd a
nontrivial factor of Qk
When 2ρQ ≤ min{p1,··· , pk}, the co-ACD problem is triv-
ial, and hence, throughout this paper, we only consider the
problem when 2ρ ≫ max{p1,·· · , pk}.

i=1 pi.

Definition 2

(Decisional co-ACD Problem). The
(ρ, η, k; Q)-decisional co-ACD problem is deﬁned as follows.
When oracles OAlg1 and OAlg2 which can be accessed polyno-
mially many times, are given, decide where ~x∗ ∈ Zp1 × Zp2 ,
which is an output of Alg1 or Alg2 with 1/2, comes from.

Note that the problem is deﬁned so that the adversary can
access to OAlg2 for the security proof of our public key con-
struction. In case of the symmetric version, the security can
be proved though OAlg1 is only given.
(ρ, η, k; Q)-decisional co-ACD problem to be

We deﬁne the advantage of an adversary A in solving the

289AdvA =(cid:12)(cid:12)(cid:12)(cid:12)Pr[AOAlg1,OAlg2

(ρ, η, k, Q, ~x∗) = b] −

1

2(cid:12)(cid:12)(cid:12)(cid:12)

where ~x∗ is a target element of the problem.

We state that the (ρ, η, k; Q)-decisional co-ACD assump-

tion holds if no PPT adversary solves the (ρ, η, k; Q)-decisional
co-ACD problem with non-negligible advantage.

While our (computational) co-ACD problem is to ﬁnd a
nontrivial factor of Qk
i=1 pi for given polynomially many
samples from {Φ(eQ)|e ← Z∩(−2ρ, 2ρ)}, the extended ACD
problem can be regarded as a problem which ﬁnds the same
answer for given polynomially many samples from

D(t)
ρ′ (p1, . . . , pk) := {Φ−1
, 2ρ′

ei ← Z ∩ (−2ρ′

(p1,...,pk)(e1, . . . , et, rt+1, . . . , rk) |
), ri ← Z ∩ (−pi/2, pi/2)}

with suﬃciently small ρ′. Hence, the diﬀerence between the
co-ACD problem and the (extended) ACD problem is only
the sampling distribution: One takes from erroneous outputs
of Φ, and the other from erroneous outputs of Φ−1.

Security Proof Now, we show that our scheme is semanti-
cally secure based on the hardness of the (ρ, η, 2; Q)-decisional
co-ACD problem.

Theorem 1. The proposed symmetric additive homomor-

phic encryption scheme is semantically secure under the
(ρ, η, 2; Q)-decisional co-ACD assumption when Q < 2η−3−2λ.
Proof. Suppose there is a polynomial-time algorithm A
that breaks the semantic security of our scheme with non-
negligible advantage ǫ in the security parameter. We con-
struct a polynomial-time algorithm B that solves the (ρ, η, 2;
Q)-decisional co-ACD problem using the algorithm A. The
input of the algorithm B is (ρ, η, Q, ~x∗) where p1, p2 are η-
bit hidden primes and ~x∗ is the instance of the (ρ, η, 2; Q)-
decisional co-ACD problem whose sampling distribution is
ˆDρ,Q(p1, p2). The algorithm B can access an oracle OAlg1
polynomially many times to get instances sampled from the
distribution ˆDρ,Q(p1, p2). The algorithm B works as follows:

1. B gives ρ, η, γ, Q to A as public information.
2. A queries an encryption of Mj ∈ ZQ to B.
3. B accesses the oracle OAlg1 to obtain ~xj sampled from
ˆDρ,Q(p1, p2).
4. B computes cj = Mj · ~1 + ~xj through the component-
wise integer additions, where ~1 is the vector of all 1s,
and sends this to A.

0, M ′

b = M ′

1 ∈ ZQ and sends them to B.

5. A and B repeatedly run Steps 2, 3, and 4.
6. A chooses M ′
7. B randomly chooses b ∈ {0, 1}, computes ~c′

b ·~1 +
~x∗ through the component-wise integer additions, and
sends this to A as an encryption of M ′
b.
chosen by A.

8. A and B repeatedly run Steps 2, 3, and 4 for messages
9. A outputs b′ ∈ {0, 1}.
10. If b = b′, then B outputs 0. Otherwise, B outputs 1.
B might fail to simulate a challenger if A becomes aware
that at least one of the i-th coordinates of the ciphertexts
received from B are larger than pi
2 . In
this case, A might abort, and B outputs a random element
in {0, 1}. Let τ be the number of ciphertexts queried by A
b and Mτ +1 = M ′
during the above game and let ~cτ +1 = ~c′
b.

2 or smaller than - pi

2

pi

Let E be the event where at least one of the i-th coordinates
of the ciphertexts ~cj are larger than pi
2 or smaller than − pi
for any i, j. Let Xj,i be the event where |xji| ≥ pi
2 −|Mj| for
Mj chosen by A in ZQ and Yj,i be the event where |xji| ≥
2 − Q
2 when xji is the i-th coordinate of ~xj for 1 ≤ j ≤ τ +1
and i = 1, 2. Note that Pr[xji = si|xji = ejQ mod pi, ej ←
Z ∩ (−2ρ, 2ρ)] ≤ 2
2η−2 and Pr[xji = si|xji ← Z ∩
(− pi
2 ] when ρ > η + 1.
Using the union bound, we have
Pr[E] = Pr[[i,j

pi ≤ 1
for any si ∈ (− pi
Xj,i] ≤Xi,j
Pr[Xj,i] ≤Xi,j

Pr[Yj,i] ≤

2 ]] = 1
pi

(τ + 1)Q

2 , pi

2 , pi

2η−3

.

1

2 + ǫ

Now, we are ready to compute the advantage of B. Let
S be the event that B solves the given problem.
If b =
0, then A will correctly guess, so Pr[A succeeds|b = 0] =
1
2 + ǫ. If b = 1, the challenging ciphertext does not reveals
no information of b, so Pr[A succeeds|b = 1] = 1
2 . Hence,
Pr[S|¬E] = 1

2 . Therefore,

AdvB = (cid:12)(cid:12)(cid:12)(cid:12)Pr[S] −

2(cid:12)(cid:12)(cid:12)(cid:12) =(cid:12)(cid:12)(cid:12)(cid:12)Pr[S ∧ E] + Pr[S ∧ ¬E] −
= (cid:12)(cid:12)(cid:12)(cid:12)Pr[S|E] Pr[E] + Pr[S|¬E] Pr[¬E] −
2(cid:12)(cid:12)(cid:12)(cid:12)
= (cid:12)(cid:12)(cid:12)(cid:12)
2(cid:12)(cid:12)(cid:12)(cid:12)
= (cid:12)(cid:12)(cid:12)(cid:12)(cid:18)Pr[S|¬E] −
2(cid:18)1 − (τ + 1)

2η−3(cid:19) .
Since we assume Q < 2η−3−2λ and τ is polynomial in λ and
so τ < 2λ, (τ +1)Q
2η−3 < 2−λ. Therefore, the advantage of B is
2 (1−2−λ) and it is non-negligible in the security
larger than ǫ
parameter.

Pr[E] + Pr[S|¬E] Pr[¬E] −
ǫ

2(cid:19) Pr[¬E](cid:12)(cid:12)(cid:12)(cid:12) ≥

2(cid:12)(cid:12)(cid:12)(cid:12)

1
2

Q

1

1

1

1

3. OUR PUBLIC-KEY ADDITIVE HOMO-

MORPHIC ENCRYPTION

To convert our symmetric encryption to public key en-
cryption, basically we use the well-known technique, subset-
sum of zero encryptions, as in [47, 14, 15, 9]. However,
it is not enough for our construction since we cannot di-
rectly apply the classical leftover hash lemma due to our
ciphertext format, which is considered as not an element of
ﬁnite set but an element of inﬁnite set Z. Instead, we adopt
the technique used for similar purpose to ours in the recent
multilinear maps construction due to Coron, Lepoint, and
Tibouchi [13].

3.1 Construction

We present our public key construction for additive ho-
momorphic encryption. We begin with deﬁning some algo-
rithms along with their properties that will be used in both
our construction and security proof.

We consider an algorithm InstGen outputting two vectors
~b1 and ~b2 such that the half-open parallelepiped generated
by (~b1,~b2) satisﬁes the followings:
(1) It is contained in R = (−2η−2, 2η−2] × (−2η−2, 2η−2].
(2) It is suﬃciently large in the sense that | det B| ≥ 15 ·
22η−8 = 15
64 · volume(R), where B is the 2-by-2 matrix with
column vector ~bi.

It is not hard to design an eﬃciently computable InstGen;

290e.g., we can repeatedly generate ~bi’s at random until they
satisfy the above conditions.
In fact, we are interested in
InstGenAlg such that it uses an algorithm Alg as a subroutine
(in a black-box manner), which generates vectors with some
distribution, until the output vectors ~b1 and ~b2 satisfy the
above conditions.

More precisely, let Alg be a probabilistic algorithm taking
two η-bit primes p1, p2 and an integer Q as inputs and out-
putting an element ~c in Zp1 × Zp2 . If the input of Alg is clear
from the context, we often omit it. InstGenAlg takes p1, p2,
and Q as inputs and uses Alg as a subroutine by feeding p1,
InstGenAlg repeatedly runs Alg (each with fresh
p2 and Q.
randomness) to obtain ~a0, ~a1, ~a2 ∈ Z × Z until
~a0 ∈ (−2η−2,−(2η−3 + 2η−4)) × (−2η−2, −(2η−3 + 2η−4)),
~a1 ∈ (−2η−3,−(2η−3 + 2η−4)) × (2η−4, 2η−3),
~a2 ∈ (2η−4, 2η−3) × (−2η−3,−(2η−3 + 2η−4)),
and outputs ~b1 = ~a1 − ~a0 and ~b2 = ~a2 − ~a0. Then, it is
clear that InstGenAlg satisﬁes the above two conditions. Al-
gorithms Alg1 and Alg2 deﬁned in Section 2 are suitable
candidates for Alg which can be utilized in InstGenAlg. We
will construct our public key scheme with Alg1.

Now, we are ready to describe our public key construction

for additive homomorphic encryption.
SetupAlg1(1λ): Choose two η-bit primes p1 and p2 at ran-
dom and an integer Q for the message space. Run
InstGenAlg1(p1, p2, Q) to obtain ~b1 and ~b2. Run Alg1
to obtain a sequence of vectors (~x1, . . . , ~xm) such that
each ~xj is an output of Alg1 with taking independent
randomness and is contained in the half-open paral-
lelepiped generated by ~b1 and ~b2. Finally, set pk =
{N = p1p2, Q,~b1,~b2, ~x1, . . . , ~xm} and sk = {¯p1, ¯p2},
where ¯p1 = p2(p−1
1 mod
p2) mod N , and ZQ is the message space.

2 mod p1) mod N , ¯p2 = p1(p−1

Enc(pk, M ): Choose sj ← {0, 1}, ti ← [0, 2µ) ∩ Z for j ∈

{1, . . . , m} and i ∈ {0, 1}. Compute and output

~c = (M, M ) +

sj~xj +

mXj=1

ti~bi,

2Xi=1

where ‘+’ is a binary operation meaning an addition
in Z × Z.

Dec(sk, ~c): Parse ~c as (c1, c2) ∈ Z × Z. Output M =

(c1 ¯p1 + c2 ¯p2 mod N ) mod Q.

Note that in SetupAlg1 algorithm, the secret information
p1 and p2 are taken by Alg1 as inputs and the remaining
process of SetupAlg1 algorithm uses Alg1 only a black-box
manner; that is, p1 and p2 are not utilized elsewhere except
for generating a secret key.

Theorem 2. The proposed scheme satisﬁes the correct-
ness requirement under the condition 2η > ρ + log Q(C +
1) + log A + µ + 3 holds where C is the number of allowed
scalar multiplications and µ > log m.

Proof. Let ejQ = Φ−1(~xj) and eiQ = Φ−1(~bi) for ei, ej ∈
(−2ρ, 2ρ), 1 ≤ i ≤ 2, and 1 ≤ j ≤ m. Then, a fresh cipher-
text ~c is Φ(M +Pm
i=1 tieiQ) for some message
M ∈ (−Q/2, Q/2], sj ∈ {0, 1}, and ti ∈ [0, 2µ). For correct
decryption, |M +Pm
i=1 tieiQ| should be less

j=1 sjej Q +P2
j=1 sjej Q +P2

Add(~c1,··· , ~cℓ): OutputPℓ

integer additions.

i=1 ~ci through component-wise

than N/2 and it is satisﬁed when 2η > ρ + µ + log Q + 3
under assuming µ > log m.

Moreover, let ~c′ be a ciphertext which is the result of A
additions and C scalar multiplications of fresh ciphertexts.
Then, the pre-image of ~c′ under Φ is less than (1 + m2ρ +
2µ+ρ)AQC+1. If 2η > ρ + log Q(C + 1) + log A + µ + 3 and
µ > log m, then (1 + m2ρ + 2µ+ρ)AQC+1 < N/2 and hence
the proposed scheme is correct.

Note that we assume µ > log m for the security. See Lemma 3
for the details.

3.2 Security Proof

We present the security theorem for our public key en-

cryption.

Theorem 3. The proposed public key scheme using Alg1
is semantically secure against any PPT adversaries under
the decisional co-ACD assumption.

The proof of Theorem 3 directly comes from the following
sequence of lemmas. In short, Lemma 2 says that the scheme
using Alg1 and the scheme using Alg2 are computationally
indistinguishable and Lemma 4 implies the semantic security
of the scheme using Alg2, though such scheme does not hold
the correctness requirement indeed.

Lemma 1. Let p1 and p2 be η-bit random primes and
Q be the size of the message space. We can consider ~xj
(~yj , resp.) as a random variable generated by the probabilis-
tic algorithm Alg1(p1, p2, Q) (Alg2(p1, p2, Q), resp.). Then,
X = (~x1, . . . , ~xm) and Y = (~y1, . . . , ~ym) are computationally
indistinguishable under the decisional co-ACD assumption,
where m is polynomial in the security parameter.

Proof. We prove the lemma via the standard hybrid ar-
gument. First, we begin with deﬁning a sequence of inter-
mediate variables Xj for j = 1, . . . , m as follows:

Xj (for j = 1, . . . , m) : (~y1, . . . , ~yj , ~xj+1, . . . , ~xm)

ǫ = (cid:12)(cid:12) Pr[A(Xj ) → 1] − Pr[A(Xj+1) → 1](cid:12)(cid:12) is non-negligible

Set X0 = X. We assume that for some adjacent vari-
ables Xj and Xj+1 there is a distinguisher A such that
in the security parameter. Then, we can construct an al-
gorithm breaking the decisional co-ACD assumption. Since
we can access polynomially many outputs of Alg1 and Alg2,
we can generate (~y1, . . . , ~yj, ~x∗, ~xj+2, . . . , ~xm), where each ~xj
is generated by Alg1, each ~yj is output of Alg2, and ~x∗ is
the challenge. Give (~y1, . . . , ~yj , ~x∗, ~xj+2, . . . , ~xm) to A and
transfer A’s output to the decisional co-ACD problem chal-
lenger. Then, it is quite straightforward that we have ǫ
advantage, which is non-negligible, to break the decisional
co-ACD assumption. Therefore, any adjacent variables are
computationally indistinguishable. Since there are polyno-
mially many variables only, by the standard hybrid argu-
ment we complete the proof of the lemma.

Lemma 2. Under the decisional co-ACD assumption, the
public key outputted by SetupAlg1 is indistinguishable from
that of SetupAlg2.

Proof. We can easily check that SetupAlg algorithm uses
Alg1 only a black-box manner so that the process of SetupAlg1
to generate public key (except for Q) can be considered
as a publicly computable function with taking polynomi-
ally many outputs of Alg1. By Lemma 1, the outputs of

291Alg1 is computationally indistinguishable from those of Alg2.
Therefore, we conclude that the result of Setup algorithm
should be indistinguishable between using two algorithms
Alg1 and Alg2, hence we complete the proof of the lemma.

The proof of Lemma 2 also implies that the performance
(e.g., the expected running time) of SetupAlg1 is almost the
same as that of SetupAlg2 under the co-ACD assumption.

To prove the semantic security of the scheme with Alg2,
we need the following lemma due to Coron, Lepoint, and
Tibouchi [13].

Lemma 3

(Leftover Hash Lemma over Lattices [13]).

Let L ⊂ Zn be a lattice of rank n of basis B = (~b1, . . . ,~bn).
Let ~xi for 1 ≤ i ≤ m be generated independently according
to the distribution DB, where DB is obtained by generating
a random element in the half-open parallelepiped generated
by the basis B. Let ~y = Pm
i=1 ti~bi and ~y′ ←
D2µB, where sj ← {0, 1} and ti ← [0, 2µ) ∩ Z and 2µB =
(2µ~b1, . . . , 2µ~bm). Then (~x1, . . . , ~xm, ~y) and (~x1, . . . , ~xm, ~y′)
2 ·q | det L|
are ǫ-statistically close, with ǫ = mn

j=1 sj~xj +Pn

2µ + 1

2m .

Lemma 4. The encryption algorithm of the scheme with

Alg2 statistically hides message M .

j=1 sj~xj +P2

Proof. We argue that for arbitrary message M , ~c =
(M, M ) +Pm
i=1 ti~bi, which is the ciphertext
generated by the scheme using Alg2, is statistically indis-
tinguishable from ~y ← D2µB. To this end, we consider an
intermediate random variable of the form ~z = (M, M ) + ~y′,
where ~y′ ← D2µB. Lemma 3 and our parameter selection
directly implies the statistical indistinguishability between ~c
and ~z.

Next, we show that ~z is ε-statistical close to ~y, where ε is
negligible in our parameters. To this end, it is suﬃcient to
show that the probability that ~z is not contained in the half-
open parallelepiped generated by 2µB is upper-bounded by
ε = 2µ+η ·Q
| det L| , where L is the lattice of basis 2µB. Since all
messages are chosen from (− Q
2 ], such the probability is
less than or equal to (|2µ~b1|+|2µ~b2|)·Q
| det L| . Further-
256 )2µ+2η and Q
more, InstGen guarantees that | det L| > ( 15
is chosen to be exponentially smaller than each modulus pi,
that is, 2η. Therefore, we obtain the desired result.

≤ 2µ+η ·Q

2 , Q

| det L|

4. HARDNESS OF THE CO-ACD PROBLEM
As shown in Section 2 and Section 3, the security of our
constructions relies on the hardness of the co-ACD prob-
lem.
In this section, we examine the hardness of the co-
ACD problem using well-known techniques for solving the
ACD problem. We analyze the general (ρ, η, k; Q)-co-ACD
problem, without the restriction that k = 2.

4.1 Using One Component of Instances

In this subsection, we ﬁrst consider the statistical distance
between the distribution ˆDρ,Q of the co-ACD problem and
the uniform distribution on Z ∩(cid:0)− pi
2(cid:3). We also provide
some attacks to ﬁnd a prime pi on the co-ACD problem
using the i-th component of the instances.

2 , pi

4.1.1 Statistical Distance

If we consider only one component of the multiple co-
ACD instances, it looks uniform when the condition ρ ≥

1

2ρ+1

2ρ+1

2 , pi

on Z∩(cid:0)− pi

|Pr[Di,ρ,Q = s] − Pr[Di = s]| ≤

η + λ holds. Fix i and let Di be the uniform distribution
Then, the statistical distance between Di and Di,ρ,Q is as
follows:

2(cid:3) and Di,ρ,Q := {eQ mod pi | e ← (−2ρ, 2ρ)}.
2Xs

∆[Di,ρ,Q;Di] =
since Pr[Di,ρ,Q = s] = ⌊2ρ+1/pi⌋
and hence
pi | ≤ 1
|Pr[Di,ρ,Q = s] − Pr[Di = s]| = | Pr[Di,ρ,Q = s]− 1
2ρ+1 .
This is less than 1
2λ if we take ρ ≥ η + λ. However, we
note that this does not guarantee that the sampling distri-
bution ˆDρ,Q in the co-ACD problem is statistically close to
the uniform distribution on Zp1 × ··· × Zpk .
4.1.2 Chen-Nguyen’s Attack and Its Variant

or ⌈2ρ+1/pi⌉

pi
2ρ+1 ,

Recently, Chen and Nguyen [8] proposed an improved at-
tack that can solve the partial ACD problem with complex-

ity eO(2ρ/2) and the general ACD (GACD) problem with
complexity eO(23ρ/2), where ρ is the bit length of the error.

Coron et al. [15] extended this attack to solve the GACD
problem on multiple instances. Now, we apply the method
of Coron et al. to solve the co-ACD problem.

Given multiple elements sampled from the distribution
ˆDρ,Q, we can apply Coron et al.’s method as follows: Let
~cj = (cj1, cj2, . . . , cjk) = Φ(ejQ) be elements sampled from
the distribution ˆDρ,Q in the co-ACD problem for 1 ≤ j ≤
t. Let us focus that our parameters satisfy ρ > η + 1.
Here, e′
j := ej mod pi is divided by pi since ci − ejQ =
ci − (e′
j + qpi)Q ≡ ci − e′
jQ mod pi for some q. Let yji =
Qx∈(−2η ,2η )(cji − xQ) for 1 ≤ j ≤ t.
multiplications to compute each yji, and pi divides yji for
1 ≤ j ≤ t and 1 ≤ i ≤ k. Hence, pi also divides Mi =
gcd(y1i, . . . , yti). To compute Mi eﬃciently, we perform the
following gcd computations sequentially:

It requires eO(2η)

Mi = gcd(··· gcd(gcd(y1i, y2i), y3i),· ·· , yti)).

(1)

and η > log Q. We have a multiple of pi, and can ﬁnd

This has a complexity of eO(t2η(η + log Q)), since log yji ≈
2η(η + log Q), and this becomes eO(2ηη2) when t = O(η)
the exact pi in eO(max{2η+1, log Mi}) by the trivial divi-
eO(max{2ηη2, 2η+1, log Mi}). Since 2η is suﬃciently large, it

sion algorithm. Hence, the total complexity of this attack is

is hard to solve the co-ACD problem with our parameters.

We also investigate how to apply the Lagarias algorithm to
the co-ACD problem using one component of each instance,
and show that this does not work for our parameters. Refer
to the full version for details.

4.2 Using Multiple Components of Instances
Now, we consider two attacks using multiple components
of instances. One is based on orthogonal lattice attacks,
and the other is based on the Coppersmith algorithm and
its variants.

4.2.1 Orthogonal Lattice Attacks
Suppose we have t vectors ~x1, . . . , ~xt sampled from ˆDρ,Q(p1,
. . . , pk). Then there exist ei’s in Z ∩ (−2ρ, 2ρ) such that
eij := eiQ mod pj where ~xi := (ei1, . . . , eik) for 1 ≤ i ≤ t
and 1 ≤ j ≤ k. Let Ej be a column vector (e1j , . . . , etj)T and
L the lattice generated by column vectors Ej’s, 1 ≤ j ≤ k−1.
Consider a vector ~a := (a1, . . . , at) orthogonal to the lat-

292tice L. Then we have

ai · (eiQ mod pj) = 0

tXi=1
tXi=1

for j = 1, . . . , k − 1, and so
ai · ei = 0

(mod

pj).

k−1Yj=1

(2)

over the integers. Then Pt

If ~a has only entries small enough, Equation (2) holds
i=1 ai(ei mod pk) is divisible by
pk. By factorizing this integer or computing its gcd with
another integer obtained from another orthogonal vector to
L, one can easily ﬁnd pk.

To prevent this attack, the short vector should not be too

short, i.e.

log(λ1(L⊥)) + ρ > (k − 1)η.

Note that dim L⊥ = t − k + 1 and det(L⊥) = det(L) ≤
j=1 kEjk ≤ (2η√t)k−1 when L is perfect. Then, the
Qk−1
norm of the shortest vector in L⊥ is expected to be about
2η(k−1)/(t−k+1). (Refer to [37] for details of orthogonal lat-
tices.) In this case, the inequality becomes

1

+ ρ > (k − 1)η

or ρ >(cid:18)1 −

t(cid:19) (k − 1)η.
(k − 1)η
t − k + 1
Let us consider the above attack when k = 2. For k = 2,
we can estimate the determinant of a lattice span(L) ∩ Zt
more precisely. L is a lattice generated by E1 = (e11,··· , et1)T
and det(L⊥) = det(span(L)∩ Zt) = 1
gt kE1k ≈
2η
if in-
gt
stances of the co-ACD problem were “random”, it is expected
that the norm of the shortest vector ~a1 is approximately
gt 2η)1/t. Since it is expected that gt elements are required
( 1
to obtain t elements whose gcd is g, we assume that g is
less than 2λ. Then, to make it hard to ﬁnd a short vector
satisfying Equation (2), the parameters should satisfy

gt · det(L) = 1
for g = gcd(e11,··· , et1) in this case. Hence,

η
t − λ + ρ > η

and hence ρ >(cid:18)1 −

1

t(cid:19) η + λ.

Therefore, if we take ρ ≥ η + 2λ when k = 2, the above
attack will take at least 2λ although the most signiﬁcant
λ-bit of the ei’s must be guessed to reduce the size of ρ.

4.2.2 Coppersmith Algorithm and Its Variants

We apply Coppersmith algorithm and its variants to solve
the co-ACD problem. Given τ ciphertexts in our scheme,
we might guess the log τ most signiﬁcant bits of hidden pi’s.
Then, we obtain a multivariate polynomial and several uni-
variate polynomials that have common divisors when eval-
uated at certain points. We devise a new algorithm to ﬁnd
these common divisors by extending the Coppersmith algo-
rithm and show that the co-ACD problem is still hard for
our parameters. Due to the space limitation, we omit Cop-
persmith algorithm for one instance of the co-ACD problem.
Recently, Cohn and Heninger improved an algorithm to
solve the ACD problem using multiple instances. We ap-
ply this to solve the co-ACD problem using its multiple in-
stances.

Theorem 4. Given τ instances ~ci = Φ(Qei) = (ci1, . . . ,
cik) of ˆDρ,Q and N , we can compute e1, . . . , eτ in polynomial
time if |ej|k < N (1+o(1)) for each i.

Proof. The attack is best when we use (k − 1) compo-
nents. Put Fij (x) = (xQ − ci1) ··· (xQ − cij ) for 1 ≤ i ≤ τ
and 1 ≤ j ≤ k−1. Then, p1 ··· pj divides gcd(N, F1j (e1), . . . ,
Fτ j(eτ )). Thus, we can compute all ei’s with |ei| < Xi when
(X1 ··· Xτ )j/τ < N (1+o(1))(j/k)(τ +1)/τ
, which achieves the
maximum N (1+o(1)) at j = k−1. That is, if X k
i < N (1+o(1)),
we can compute those ei for which |ei| < Xi in polynomial
time.
We do not know whether it is possible to improve this at-
tack further. Currently, it seems to be optimal, unless we
improve Theorem 5 in [11]. Theorem 4 shows that the Cohn-
Heninger attack does not solve the co-ACD problem under
our parameter setting.

When Some Most Signiﬁcant Bits of pi’s Are Given
When we focus on one component of the co-ACD instances,
the distribution Di,ρ,Q := {eQ mod pi|e ← (−2ρ, 2ρ)} is sta-
2(cid:3).
tistically close to the uniform distribution on Z ∩(cid:0)− pi
2 , pi
Hence, if many co-ACD instances are given, the most signif-
icant some bits of pi might be revealed as follows: Let ~cj =
(cj1, cj2, . . . , cjk) be the co-ACD instances for 1 ≤ j ≤ τ ,
and c′
i be the largest integer among the cji’s for 1 ≤ j ≤ τ .

2(cid:3) into τ disjoint intervals(cid:0)− pi

Divide(cid:0)− pi
2 , pi
(cid:0)− pi
τ pi,− pi
2 + 2
belongs to(cid:0)− pi
2 + τ −1
distribution Di,ρ,Q is statistically close to the uniform distri-
bution. Hence, (pi−2c′
2 + τ −1
τ pi, and
the most signiﬁcant (log τ )-bit of 2c′
i and pi are the same.
Therefore, we might obtain the most signiﬁcant (log τ )-bit
of pi. For example, when 230 co-ACD instances are given,
the most signiﬁcant 30-bit of pi might be revealed.

τ pi(cid:3) ,
2 ,− pi
τ pi(cid:3) , . . . ,(cid:0)− pi
2(cid:3). Then, c′
2(cid:3) with high probability, since the
τ pi(cid:1) = 2
i) < pi−2(cid:0)− pi

2 + τ −1

τ pi, pi

τ pi, pi

2 + 1

2 + 1

i

Assume that the most signiﬁcant λ-bit of the pi’s is re-
vealed. Then, we have a multivariate polynomial Gj (x1, . . . ,

xj) = Q1≤i≤j (xi + ˆpi) that has the solution (r1, . . . , rj)
such that ri < pi/2λ for all i, and gcd(N, Gj (r1, . . . , rj)) ≥
p1 ··· pj ≈ N j/k when each ˆpi is an η-bit integer whose most
signiﬁcant (log λ)-bit is the same as that of pi. Then, we
may try to ﬁnd r1, . . . , rj using a lattice algorithm. The fol-
lowing lemma gives the condition under which we can ﬁnd
r1, . . . , rj.

Lemma 5. Given a positive integer N , let G(x1, . . . , xd) =
Qd
i=1(xi + ci) ∈ Z[x1, . . . , xd] for some constant ci and β ∈
[0, 1) with β2 log N ≫ 2d. Given X1, . . . , Xd ∈ Z+ with
X1 ··· Xd < N β2(1+o(1)), we can ﬁnd d integer equations
F1, . . . , Fd ∈ Z[x1, . . . , xd] such that F1(r1, . . . , rd) = ··· =
Fd(r1, . . . , rd) = 0 and for all d-tuples r1, . . . , rd satisfying

gcd(N, G(r1, . . . , rd)) ≥ N β,

|ri| < Xi.

Due to the space limitation, we omit the proof of Lemma 5.
From Lemma 5, the relation |X1 ·· · Xj| < N β2
must hold
to ﬁnd r1, . . . , rj satisfying gcd(N, Gj (r1, . . . , rj)) ≥ N β and
|ri| < Xi. However, in the case of our parameters,

|X1 · ·· Xj| ≈ 2ηj > 2ηk·j2/k2

≈ N β2

,

since N = p1 ·· · pk ≈ 2ηk, gcd(N, Gj(r1, . . . , rj)) ≥ p1 ··· pj ≈
N j/k, and j ≤ k. Hence, it does not work for our parame-
ters.
Moreover, since we may also have polynomials Fij (x) =
(xQ − ci1) ··· (xQ − cij) for 1 ≤ i ≤ τ and 1 ≤ j ≤ k − 1
when multiple instances are given, we may try to ﬁnd a
certain pi with such Fij’s and Gj using a lattice algorithm.

293The following theorem gives the condition under which we
may ﬁnd the solution of the co-ACD problem.

Then,

(X d1

1 · · · X dτ

τ )(Xτ +1 · · · Xτ +d) < N

τ +2 (cid:17)/C3) τ +2

t+τ +2

(βk(τ +2)−(cid:16)k+τ +1
≈ N βk(τ +2)/t−(k/t)τ +2
t+τ +2 ≈ τ +2

τ +2

t

(4)

and

Theorem 5. Given a positive integer N , let G(x1, . . . , xd)
= Qd
i=1(xi + ci) ∈ ZN [x1, ··· , xd] for some constant ci.
Let Fi(x) ∈ ZN [x] be a polynomial of degree di for 1 ≤
i ≤ τ , and β ∈ [0, 1) with β2 log N ≫ 2dQτ
i=1 di. Given
X1, . . . , Xd+τ ∈ Z+ with

τ +2

(X d1

1 ··· X dτ

τ Xτ +1 · ·· Xτ +d)

1

τ +1 < N β

τ +1 (1+o(1)),

we can ﬁnd d + τ integer equations F1, . . . , Fd+τ ∈ Z[x1, . . . ,
xd+τ ] such that F1(r1, . . . , rd+τ ) = . . . = Fd+τ (r1, . . . , rd+τ )
= 0 and for all (d + τ )-tuples r1, . . . , rd+τ satisfying

gcd(N, F1(r1), . . . , Fτ (rτ ), G(rτ +1, . . . , rτ +d)) ≥ N β

and |ri| < Xi.

Proof. Let k, t be positive integers to be determined
later. Let L be a lattice generated by the coeﬃcient vectors
(replace xi by Xi as in [25]) corresponding to the polynomial

F1(x1)α1 ··· Fτ (xτ )ατ G(xτ +1, . . . , xτ +d)ℓ
i=1 αi−ℓ},

τ +dN max{0,k−Pτ

τ xℓ1

τ +1 ··· xℓd

×xκ1

1 · ·· xκτ

i=1 αi−ℓ}.

τ

1

··· X dτ ατ +kτ

τ +d N max{0,k−Pτ

τ +1 (cid:1) · (2d − 1).

dimension of lattice L is dim L = d1 ··· dτ(cid:0)t+τ +1

where 0 ≤ κi < di, 0 ≤ α1 + α2 + ··· + ατ + ℓ ≤ t, and
0 ≤ ℓi ≤ 1 except that ℓi = 1 for all 1 ≤ i ≤ d. The
Let us compute the determinant of L. When we represent
a basis matrix of lattice L, we can choose a monomial order-
ing so that it is a lower triangular, and the determinant of
L will be the product of its diagonal entries. The diagonal
entries of this basis matrix have the form
X d1α1+κ1

τ +1 ··· X ℓ+ℓd
X ℓ+ℓ1
Hence the determinant of L is at most
Xτ +j!C1C2(C3+C′
  τYi=1
dYj=1
i=1 di, C2 = 2d − 1, C3 =(cid:0)τ +t+1
where C1 =Qτ
(cid:0)τ +t+1
τ +2 (cid:1). Note that the dimension of L is C1C2C3.
We apply the LLL algorithm for the lattice L, and obtain
the smallest d + τ vectors b1, . . . , bd+τ of the LLL-reduced
basis. By Theorem 2 in [28], bi satisﬁes |bi| < 2(dim L−1)/4
×(det L)1/(dim L+1−i), and the polynomial Fi correspond-
ing to the vector bi satisﬁes |Fi| ≤ √dim L · bi. Hence,
the polynomial Fi satisﬁes |Fi(r1, . . . , rd+τ )| < √dim L ·

τ +1 (cid:1) and C ′

N C1C2(k+τ +1
τ +2 )

X di
i

3 =

3)

1

2(dim L−1)/4(det L)

dim L−1+i . Therefore, if

2(dim L−1)/4(det L)

dim L−1+i < N βk,
then Fi(r1, . . . , rd+τ ) = 0 for all 1 ≤ i ≤ d + τ .
isﬁed. Then we obtain the relation

Consider the condition under which the relation (3) is sat-

(3)

1

√dim L2(dim L−1)/4(det L)
√dim L2(C1C2C3−1)/4((

≤

τ
Y
i=1

1

dim L−1+i

(X

i )C1C2(C3+C′
di

3))

d
Y
j=1

×(

Xτ +j)C1C2(C3+C′

3)N

C1C2(cid:16)k+τ +1

τ +2 (cid:17))

1

C1 C2C3 < N βk,

when C1C2C3 ≈ C1C2C3−1+d+τ . Since β2 log N ≫ 2dC1
and √dim L2(dim L−1)/4 ≈ N βko(1), we omit √dim L2(dim L−1)/4.

1

when t is suﬃciently large, and hence

t(cid:1)τ +2

is maximized at t = k/β

. The right-hand side of (4)

(cid:16)(cid:0)k+τ +1
τ +2 (cid:1)/C3(cid:17) τ +2

t+τ +2 ≈(cid:0) k
τ +1 (1+o(1)). Note that k ≈ (cid:16) β2 log N

C1·2d (cid:17)1/2τ
imately N (τ +1)β
,
since βk log N ≫ C1kτ 2d from N βk ≫ 2(dim L−1)/4. The
theorem has been proved.
5. PERFORMANCE

τ +1 , attaining a value of approx-

τ +2

In this section, we provide some speciﬁc parameters for
our public-key construction, and present results from its
implementation. Throughout Section 3 and Section 4, we
looked at the constraints that the parameters of our con-
struction must satisfy for security and correctness. Under
these constraints, we set the parameters as follows.

set ρ to be η + 2λ.

• From our analyses in Section 4, ρ ≥ η + 2λ. Hence, we
• The bit size η of primes pi has to be large enough to
protect against factorization algorithms. Hence, we set
η to be equal or larger than that of recommendation
of NIST [38].1 For the correctness of our public key
encryption scheme in Theorem 2, η holds the relation
2η > ρ + log Q(C + 1) + log A + µ + 3 where C is the
number of allowed scalar multiplications.

γ + 2λ and µ > λ + log m + 1.

• Then, the bit size γ of fresh ciphertext is to be 2η.
• From Lemma 3, we set m and µ to be satisﬁed m >
• We set the size Q of the messages space to 2256. In
this case, it supports the calculation of the mean of
2127 nonnegative 128-bit integers.

Table 1 provides some concrete parameters for the number
of allowed additions. We have tested on an ordinary laptop
with an Intel Core i7-2600 processor running at 3.4 GHz,
with 16 GB of memory. Test results given in Table 1 are the
averages from 100 key generations and 100 operations per
key generation.

We also compare the performance of our public-key scheme
with that of previously proposed additive public-key homo-
morphic encryption schemes. To do this, we provide imple-
mentation results of Paillier encryption [41] and Joye and
Libert encryption [32]. For the case of a ring-LWE-based
additive homomorphic encryption scheme, we referred to the
implementation results in [36].2

The results show that the encryption of our scheme is a
little bit faster than the previous best result and decryption
and addition algorithms are much faster than the previous.
Though the public key size of ours is around 10 thousand
times larger than the previous, the ciphertext size is compa-
rable to the previous results. In summary, our additive ho-
momorphic encryption scheme is the most practical of those
that support an additive homomorphic property.
1We set η assuming N is given as the threshold version in
Section 6. Considering N is private in secret key and public
key schemes, η may become small and hence public key and
ciphertext sizes become short.
2Note that the implementation results provided in [36] can
be improved by estimating the parameter size according to
a recent result [46].

294[Pai99]
[NLV11]†
[JL13]

λ

128
120
128

Table 1: Parameter Sizes, Implementation Results, and Comparison
η

log Q log A

PK Size

Setup

Enc

m

µ

γ

ρ

Dec

Add

1536

−

1536

−

−
−

−

−
−

−

−
−

3072
10
256

∞ 6144
20
61440
∞ 3072

1.5 kB
7.6 kB
0.8 kB

437.39 s
0.11 s
250.32 s

62.46 ms
164.00 ms
2.07 ms

40.38 ms
4.00 ms
903.36 ms

12.40 µs
≤ 1.00 ms
2.40 µs

128

142

256

Ours

0.40 µs
0.80 µs
0.80 µs
† We referred to the implementation results in [NLV11] and they were done on a 2.1 GHz Intel Core 2 Duo, with 3 MB L3 cache and
1 GB of memory.

1.3 MB
2.6 MB
3.9 MB

0.72 ms
1.07 ms
1.29 ms

4.00 µs
8.00 µs
8.80 µs

0.35 s
1.18 s
2.34 s

1536
2194
2706

1792
2450
2962

3328
4645
5669

1134
1536
2048

3072
4388
5412

6. THRESHOLD SCHEME

of the discrete logarithm of

In this subsection, we present a (t, t)-threshold version of
the proposed public key additive homomorphic encryption.
We follow Fouque et al.’s syntax and security deﬁnition of
the threshold scheme [21]. We use a homomorphic commit-
ment scheme Com(m), where m ∈ ZN .
Key Generation Algorithm. The dealer runs SetupAlg1
and obtains pk = {N = p1p2, Q,~b1,~b2, ~x1, . . ., ~xm}
and sk = {¯p1, ¯p2}. Each ¯pi is randomly divided into
random t pieces ¯pi1, . . . , ¯pit. The veriﬁcation keys vk
is the description of the commitment scheme Com(·)
secret key share ski is the openings of the committed
values of vki.

and for i = 1, . . . , t, vki =(cid:0)Com(¯p1i), Com(¯p2i)(cid:1). The

Encryption Algorithm. It is the same as Enc(·, ·) algo-

rithm of the non-threshold version.

Share Decryption Algorithm. Parse a ciphertext ~c as
(c1, c2). Each server Si chooses ei ← (−2max+λ, 2max+λ)
at random, where (−2max, 2max) is the bound of errors
in the ciphertext, possibly homomorphically evaluated
ciphertext. She computes her decryption share

di = c1 · ¯p1i + c2 · ¯p2i + ei · Q mod N,

(5)
where di = c1 · ¯p1i + c2 · ¯p2i + ei · Q − kiN for some
ki ∈ Z. To prove the validity of the share, she commits
ei and ki and then sends them along with a proof πi
that the openings ¯p1i, ¯p2i, ei and ki of the committed
values satisfy the equation (5) and ei is contained in
(−2max+λ, 2max+λ).
biner computes (Pt

Combining Algorithm. If one of πi’s is an invalid proof,
then the combiner outputs ‘f ail’. Otherwise, the com-
i=1 di mod N ) mod Q and outputs

the result.

For the commitment scheme Com, we can use the Fujisaki
and Okamoto commitment scheme [24]: Let n be a large
composite number whose factorization is unknown and g
and h be elements of large order in Z∗
n such that both the
discrete logarithm of h in base g and the discrete logarithm
of g in base h are unknown. In fact, the commitment to an
integer x is Com(x; r) = gxhr mod n, where r is chosen from
[−2λn + 1, 2λn− 1]∩ Z at random. Then, it is easy to check
that Com has the additive homomorphic property; that is,
Com(x1; r1)·Com(x2; r2) = Com(x1 +x2; r1 +r2) mod n. We
often omit the randomness part from the input of Com if it
is not important.

Using the Fujisaki and Okamoto commitment scheme as
Com, the proof for the validity of each decryption share can
be constructed by well-known technique for the knowledge of
the discrete logarithm and the range proof. More precisely,
for the former proof, it is suﬃcient to prove the knowledge

Com(¯p1i)c1 · Com(¯p2i)c2 · Com(ei)Q · Com(ki)N · g−di
= Com(c1 · ¯p1i + c2 · ¯p2i + ei · Q − kiN − di)

in base h, for example [6, 7], and for the latter proof, we can
use the range proof that ei ∈ (−2max, 2max), for example [4].
Note that the proofs we use in the threshold scheme satisfy
the perfect completeness, the computational soundness un-
der the strong RSA assumption [1, 24], and the statistical
zero-knowledge property in the random oracle model [4]. We
provide the security theorem below, and followed by sketch
of proof due to space constraint.

i=1 eiQ−Pt−1

Theorem 6. If the original scheme is semantically se-
cure, its threshold version is also secure scheme under the
strong RSA assumption in the random oracle model.
Sketch of Proof. We construct an attack algorithm B against
the original scheme using an attacker A against the thresh-
old scheme. Without loss of generality, we assume that A
controls servers S1, . . . ,St−1.
We ﬁrst describe B’s process. B starts with receiving pub-
lic parameters pk of the original scheme. B chooses random
integers ¯p1i and ¯p2i for i = 1, . . . , t − 1, from ZN , gener-
ates parameters for Com, and commits to ¯p1i’s and ¯p2i’s. B
sends pk, the parameters for Com, Com(¯p1i)’s, Com(¯p2i)’s,
and their openings for i = 1, . . . , t − 1 to A. Whenever
A queries decryption shares of the chosen message M , B
chooses ei ← (−2max+λ, 2max+λ) for i = 1, . . . , t and for
i = 1, . . . , t − 1 computes the decryption shares di and the
corresponding validity proofs πi using the secret ski nor-
mally. B computes dt = M +Pt
i=1 di mod N and
simulates πt using the zero-knowledge simulation property
by simulating the random oracles. Then, B returns t shares
di’s along with the validity proofs πi’s as the query result. In
the challenge phase, B relays between A and the challenger;
that is, B transfers A’s two messages and the challenge ci-
phertext given by the challenger. Finally, B receives A’s
output bit, and then B outputs the same bit as A’s.
Since the public key and the encryption algorithm in both
the original scheme and the threshold scheme are the same,
it is suﬃcient to show that the distribution of the ski, vki
and the result of queries for decryption shares is indistin-
guishable from the real transcript. Since we randomly di-
vide sk into t pieces ski modulus N , t − 1 pieces of se-
cret key shares looks perfectly random so that ski and vki
for i = 1, . . . , t − 1 are well distributed. Next, we argue
that the decryption shares di’s and the validity proofs πi’s
are statistically indistinguishable from the real transcript.
Let us consider the distribution of the case that the de-
cryption shares are normally generated with the real secret
key shares; we ﬁrst compute an encryption (c1, c2) of M
and then compute decryption share di = c1 ¯p1i + c2 ¯p2i +
eiQ mod N such that Pt
i=1 eiQ mod
N , where e ∈ (−2max, 2max) is determined by (c1, c2) and

i=1 di = M + eQ +Pt

295i=1 ei +e′

ei ∈ (−2max+λ, 2max+λ). Then, the joint distribution of
(d1, . . . , dt−1,Pt
i=1 di mod N ) is statistically indistinguish-
able from (d1, . . . , dt−1, M +(Pt−1
t)Q mod N ), where
e′
t is chosen from (−2max+λ, 2max+λ) at random, since ei is
chosen from suﬃciently larger range than e so that e + et
is statistically indistinguishable from e′
t; the statistical dis-
tance is less than 1
2λ . The remaining of the proof is straight-
forward. In B’s description, for i = 1, . . . , t−1, di and πi are
i=1 di
mod N ) is well distributed, πt is simulated using the power
of the random oracle. Therefore, we complete the sketch of
proof.

normally generated, dt is chosen so that (d1, . . . , dt−1,Pt

7. APPLICATIONS

In this section, we consider some basic applications of ad-
ditive homomorphic encryption. Then, we provide an alter-
native method of evaluating a multivariate symmetric poly-
nomial with only an additive homomorphic property. We
also brieﬂy look into another main application of (threshold
version of) additive homomorphic encryption, secure multi-
party computation, focusing on private set operation proto-
cols.

7.1 Basic Applications

Mean and Weighted Sum A weighted sum is deﬁned as
the inner product of a weight vector (α1,··· , αn) ∈ Qn and
an input vector (x1,··· , xn) ∈ Zn and a weighted mean is
obtained by dividing a weighted sum by the sum of weights
Pn
i=1 αi. These values are commonly used in statistics.
For given Enc(mi)’s, we ﬁrst compute the smallest inte-
ger α that makes ααi ∈ Z for all i. Then, we compute
i=1 ααiEnc(xi) =Pn
Pn
i=1 Enc(ααixi) and obtains a weight-
ed sum by decrypting this and dividing by α. A weighted
mean is obtained by dividing a weighted sum by Pn
i=1 αi.
Therefore, we can calculate a weighted sum and a weighted
mean using an additive homomorphic property ifPn
i=1 ααixi
< Q
2 for the size Q of the message space. Note that the mean
is the special case of the weighted mean for α1 = ··· = αn =
1
n . Our unoptimized implementation takes about 40 µs to
compute the mean of 1000 128-bit integers.
Polynomial Evaluation of Hidden Coeﬃcients We can
also consider applications to evaluate a multivariate polyno-
mial whose coeﬃcients are secret, such as in ranking sys-
tems. When coeﬃcients are encrypted, we can evaluate the
corresponding polynomial using scalar multiplication and
addition.

A polynomial evaluation of hidden coeﬃcients can be re-
garded as a matrix multiplication. In general, we can also
compute a matrix multiplication when one matrix is en-
crypted and the other is unencrypted. From our imple-
mentation, it takes about 1.04 ms to evaluate a degree-1000
polynomial when the bit size of the message space is 256.

7.2 Symmetric Polynomial Evaluation

We focus on the fundamental theorem of symmetric poly-
nomials, which states that every symmetric polynomial in n
variables with rational coeﬃcients can be generated by the
i=1 xj
i
for j = 1, . . . , n. In the following proposition, we show that
a low-degree symmetric polynomial of many variables can
also be represented only a small number of power-sum sym-
metric polynomials. Due to space limitations, we omit the

power-sum symmetric polynomials Pj (x1, . . . , xn) =Pn

proof of this proposition, but it is fairly straightforward us-
ing mathematical induction.

Proposition 1. Let f ∈ Q[x1, ··· , xn] be a symmetric
polynomial of degree d for a given d < n. Then, f =
d ∈ Q[x1, ··· , xn] for ~i = (i1,· ·· , id) ∈ Zd

1 ·· · P id

≥0

P a~iP i1

such that 0 ≤ i1 + ··· + id ≤ d.

To support the evaluation of symmetric polynomials using
the above proposition, we deﬁne a new encryption algorithm
as follows:
Ed(pk, M ) := (Enc(pk, M ), Enc(pk, M 2), . . . , Enc(pk, M d)),
where Enc is an additive homomorphic encryption. Then,
we can easily evaluate the power-sum symmetric polynomi-
als Enc(pk, Pj(x1,· ·· , xn)) for 1 ≤ j ≤ d with only an ad-
ditive homomorphic property, and evaluate symmetric poly-
nomials of degree d by decrypting Enc(pk, Pj (x1,··· , xn))’s
and multiplying and adding on the decrypted data.
In particular, this method is more eﬃcient when evalu-
ating low-degree symmetric polynomials in many variables.
For example, one can calculate the variance eﬃciently. Since
the variance is a polynomial of degree 2, set d to 2. From
given ciphertexts E2(pk, Mi) := (Enc(pk, Mi), Enc(pk, M 2
i ))
for 1 ≤ i ≤ n, one obtains Enc(pk, Pj(M1,··· , Mn)) =
Pn
i ) for j = 1, 2 using an additive homomor-
phic property. Then we decrypt each ciphertext and obtain
the variance by computing (Variance) = 1
This requires only two decryptions, two integer divisions,
and one squaring operation. From our unoptimized imple-
mentation under the environment described in Section 5, it
takes about 120 µs to compute the variance of 1000 128-bit
integers, and it is quite eﬃcient.

n (P2) −(cid:0) 1

n P1(cid:1)2.

i=1 Enc(pk, M j

7.3 Secure Computing - Private Set Operations
(Threshold version of) additive homomorphic encryptions
have used in numerous applications for secure computing [16,
19, 22, 33, 31]. Here, we review some of them, in particular,
focus on private set operations [22, 33]. Private set oper-
ations cover private computations such as set intersection,
set union, multi-set intersection, and many others. In par-
ticular, private set operation has received attention since
it can be used as an important primitive in many applica-
tions. There are a lot of private set operation protocols using
public key additive homomorphic encryption, e.g., Paillier
cryptosystem. Such private set operation protocols require
several additions and limited scalar multiplications and our
scheme has advantage over the other scheme in such applica-
tions; for example, there is an approach to represent private
set operation by polynomial operations [22, 33] (rational
function operations, resp. [43]), and one scalar multiplica-
tion is suﬃcient for set intersection in polynomial operation
(set union in rational function operations, resp.).

In these applications, to obtain the ﬁnal result, users re-
cover a set from the resulting polynomial by ﬁnding roots of
the polynomial. The sizes of message spaces of the previous
eﬃcient additive homomorphic encryption are composite or
hidden.
If it is hidden, there is no method to ﬁnd roots
of a polynomial deﬁned over the message space. When it
is composite, the polynomial ring over the message space
is not a unique factorization domain, and hence they can-
not eﬃciently obtain the exact corresponding set from the
polynomial. In particular, the message space of Paillier en-
cryption is ZN for a hard-to-factor integer N . In this case,

296ﬁnding roots of the polynomial in ZN is equivalent to fac-
toring N [44].

To avoid this obstacle, some previous (multi-)set union
protocols [33, 23] hire a mix-net protocol with additive ho-
momorphic encryption, but it additionally causes O(t) rounds
for the number of corrupted users t. Other protocol [43] uti-
lizes a secret sharing technique instead of additive homomor-
phic encryption. It runs in a constant round, but requires nκ
times communicational and n times computational overhead
costs than the previous when n is the number of users and
κ is the cardinality of users’ set. Recently, Cheon et al. [10]
proposed a new encoding to uniquely determine a set from a
polynomial deﬁned over the message space of Naccache and
Stern encryption. However, their encoding is complicated
and supports the correct result only with some probability.
On the other hand, the message space of our scheme can
be a ﬁeld, and hence our scheme enables us to exceed this
obstacle by using some eﬃcient root ﬁnding algorithm over a
ﬁeld [45]. As a result, we can obtain a constant round private
set union protocol which reduces nκ times communicational
and n2 times computational costs than [43].

8. CONCLUSION

We have presented an eﬃcient additive homomorphic en-
cryption scheme and proved the security under the hardness
of a new problem, the co-ACD problem. We could not re-
duce this problem to other well-known cryptographic hard
problems, but extensively analyzed its hardness using all
known techniques. These analyses have provided suﬃciently
plausible evidence of its hardness. Our implementation re-
sults show that our scheme is the fastest scheme of those
that support an additive homomorphic property.

To extend the usefulness of additive homomorphic encryp-
tion, we have presented a method to eﬃciently evaluate sym-
metric polynomials by additionally providing ciphertexts of
some powers of messages. We also have provided a (t, t)-
threshold version of our scheme for smooth adoption to var-
ious applications.
It still remains as an open problem to
construct a (t, n)-threshold version of our scheme for t < n.

Acknowledgement This work was supported by IT R&D
program of MSIP/KEIT [No. 10047212]. Hyung Tae Lee
was also supported in part by the Singapore Ministry of Ed-
ucation under Research Grant MOE2013-T2-1-041. Part of
work was done while Hyung Tae Lee was with Seoul Na-
tional University, Korea. The authors would like to thank
Hyunsook Hong, Jinsu Kim, Moon Sung Lee, Hansol Ryu
and the anonymous reviewers of ACM CCS 2014 for their
helpful comments.

9. REFERENCES
[1] N. Bari´c and B. Pﬁtzmann. Collision-free

accumulators and fail-stop signature schemes without
trees. In W. Fumy, editor, EUROCRYPT 1997,
volume 1233 of LNCS, pages 480–494. Springer, 1997.

[2] J. Benaloh. Veriﬁable secret-ballot elections. PhD

thesis, Yale University, New Haven, CT, USA, 1987.

[3] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating

2-DNF formulas on ciphertexts. In J. Kilian, editor,
TCC 2005, volume 3378 of LNCS, pages 325–341.
Springer, 2005.

[4] F. Boudot. Eﬃcient proofs that a committed number

lies in an interval. In B. Preneel, editor,

EUROCRYPT 2000, volume 1807 of LNCS, pages
431–444. Springer, 2000.

[5] Z. Brakerski, C. Gentry, and V. Vaikuntanathan.
(Leveled) fully homomorphic encryption without
bootstrapping. In S. Goldwasser, editor, ITCS 2012,
pages 309–325. ACM, 2012.

[6] J. Camenisch. Group signatue schemes and payment

systems based on the discrete logarithm problem. PhD
thesis, ETH Z¨urich, 1998.

[7] J. Camenisch and M. Michels. A group signature
scheme with improved eﬃciency. In K. Ohta and
D. Pei, editors, ASIACRYPT 1998, volume 1514 of
LNCS, pages 160–174. Springer, 1998.

[8] Y. Chen and P. Q. Nguyen. Faster algorithms for

approximate common divisors: Breaking
fully-homomorphic-encryption challenges over the
integers. In D. Pointcheval and T. Johansson, editors,
EUROCRYPT 2012, volume 7237 of LNCS, pages
502–519. Springer, 2012.

[9] J. H. Cheon, J.-S. Coron, J. Kim, M. S. Lee,

T. Lepoint, M. Tibouchi, and A. Yun. Batch fully
homomorphic encryption over the integers. In
T. Johansson and P. Q. Nguyen, editors,
EUROCRYPT 2013, volume 7881 of LNCS, pages
315–335. Springer, 2013.

[10] J. H. Cheon, H. Hong, and H. T. Lee. Invertible

polynomial representation for private set operations.
2013. Appeared in ICISC 2013, Available at
http://eprint.iacr.org/2012/526.

[11] H. Cohn and N. Heninger. Approximate common

divisors via lattices. In E. W. Howe and K. S.
Kedlaya, editors, ANTS X, volume 1 of The Open
Book Series, pages 271–293. Mathematical Sciences
Publishers, 2013.

[12] D. Coppersmith. Small solutions to polynomial

equations, and low exponent RSA vulnerabilities.
Journal of Cryptology, 10(4):233–260, 1997.

[13] J.-S. Coron, T. Lepoint, and M. Tibouchi. Practical

multilinear maps over the integers. In R. Canetti and
J. A. Garay, editors, CRYPTO 2013 (1), volume 8042
of LNCS, pages 476–493. Springer, 2013.

[14] J.-S. Coron, A. Mandal, D. Naccache, and

M. Tibouchi. Fully homomorphic encryption over the
integers with shorter public keys. In P. Rogaway,
editor, CRYPTO 2011, volume 6841 of LNCS, pages
487–504. Springer, 2011.

[15] J.-S. Coron, D. Naccache, and M. Tibouchi. Public

key compression and modulus switching for fully
homomorphic encryption over the integers. In
D. Pointcheval and T. Johansson, editors,
EUROCRYPT 2012, volume 7237 of LNCS, pages
446–464. Springer, 2012.

[16] R. Cramer, I. Damg˚ard, and J. B. Nielsen. Multiparty
computation from threshold homomorphic encryption.
In B. Pﬁtzmann, editor, EUROCRYPT 2001, volume
2045 of LNCS, pages 280–299. Springer, 2001.

[17] I. Damg˚ard, M. Jurik, and J. B. Nielsen. A

generalization of Paillier’s public-key system with
applications to electronic voting. Int. J. Inf. Sec.,
9(6):371–385, 2010.

[18] I. Damg˚ard and J. B. Nielsen. Perfect hiding and

perfect binding universally composable commitment

297schemes with constant expansion factor. In M. Yung,
editor, CRYPTO 2002, volume 2442 of LNCS, pages
581–596. Springer, 2002.

[19] I. Damg˚ard and J. B. Nielsen. Universally composable

eﬃcient multiparty computation from threshold
homomorphic encryption. In D. Boneh, editor,
CRYPTO 2003, volume 2729 of LNCS, pages 247–264.
Springer, 2003.

[20] I. Damg˚ard and M. Jurik. A generalisation, a

simpliﬁcation and some applications of Paillier’s
probabilistic public-key system. In K. Kim, editor,
PKC 2001, volume 1992 of LNCS, pages 119–136.
Springer, 2001.

[21] P.-A. Fouque, G. Poupard, and J. Stern. Sharing
decryption in the context of voting or lotteries. In
Y. Frankel, editor, FC 2000, volume 1962 of LNCS.
Springer, 2000.

[22] M. Freedman, K. Nissim, and B. Pinkas. Eﬃcient

private matching and set-intersection. In C. Cachin
and J. Camenisch, editors, EUROCRYPT 2004,
volume 3027 of LNCS, pages 1–19. Springer-Verlag,
2004.

[23] K. B. Frikken. Privacy-preserving set union. In

J. Katz and M. Yung, editors, ACNS 2007, volume
4521 of LNCS, pages 237–252. Springer, 2007.

[24] E. Fujisaki and T. Okamoto. Statistical zero

knowledge protocols to prove modular polynomial
relations. In B. S. K. Jr., editor, CRYPTO 1997,
volume 1294 of LNCS, pages 16–30. Springer, 1997.

[25] S. D. Galbraith. Mathematics of Public Key

Cryptography. Cambridge University Press, 2012.
[26] C. Gentry, S. Halevi, and V. Vaikuntanathan. A

simple BGN-type cryptosystem from LWE. In
H. Gilbert, editor, EUROCRYPT 2010, volume 6110
of LNCS, pages 506–522. Springer, 2010.

[27] S. Goldwasser and S. Micali. Probabilistic encryption.

Journal of Computer and System Sciences,
28(2):270–299, 1984.

[28] M. Herrmann and A. May. Solving linear equations

modulo divisors: On factoring given any bits. In
J. Pieprzyk, editor, ASIACRYPT 2008, volume 5350
of LNCS, pages 406–424. Springer, 2008.

[29] N. Howgrave-Graham. Approximate integer common

divisors. In J. H. Silverman, editor, CaLC 2001,
volume 2146 of LNCS, pages 51–66. Springer, 2001.

volume 3621 of LNCS, pages 241–257.
Springer-Verlag, 2005.

[34] C. A. Melchor, P. Gaborit, and J. Herranz. Additively

homomorphic encryption with d-operand
multiplications. In T. Rabin, editor, CRYPTO 2010,
volume 6223 of LNCS, pages 138–154. Springer, 2010.

[35] D. Naccache and J. Stern. A new public key

cryptosystem based on higher residues. In L. Gong
and M. K. Reiter, editors, ACM CCS 1998, pages
59–66. ACM, 1998.

[36] M. Naehrig, K. Lauter, and V. Vaikuntanathan. Can
homomorphic encryption be practical? In C. Cachin
and T. Ristenpart, editors, CCSW 2011, pages
113–124. ACM, 2011.

[37] P. Q. Nguyen and J. Stern. The two faces of lattices in

cryptology. In J. H. Silverman, editor, CaLC 2001,
volume 2146 of LNCS, pages 146–180. Springer, 2001.
[38] NIST. Recommendation for key management. Special

Publication 800-57 Part 1 Rev. 3, July 2012.

[39] T. Okamoto and S. Uchiyama. A new public-key

cryptosystem as secure as factoring. In K. Nyberg,
editor, EUROCRYPT 1998, volume 1403 of LNCS,
pages 308–318. Springer, 1998.

[40] R. Ostrovsky and W. E. S. III. A survey of

single-database private information retrieval:
Techniques and applications. In T. Okamoto and
X. Wang, editors, PKC 2007, volume 4450 of LNCS,
pages 393–411. Springer, 2007.

[41] P. Paillier. Public-key cryptosystems based on

composite degree residuosity classes. In J. Stern,
editor, EUROCRYPT 1999, volume 1592 of LNCS,
pages 223–238. Springer, 1999.

[42] R. Rothblum. Homomorphic encryption: From

private-key to public-key. In Y. Ishai, editor, TCC
2011, volume 6597 of LNCS, pages 219–234. Springer,
2011.

[43] J. H. Seo, J. H. Cheon, and J. Katz. Constant-round
multi-party private set union using reversed Laurent
series. In M. Fischlin, J. Buchmann, and M. Manulis,
editors, PKC 2012, volume 7293 of LNCS, pages
398–412. Springer, 2012.

[44] A. Shamir. On the generation of multivariate
polynomials which are hard to factor. In S. R.
Kosaraju, D. S. Johnson, and A. Aggarwal, editors,
STOC 1993, pages 796–804. ACM, 1993.

[30] S. Jarecki and X. Liu. Eﬃcient oblivious

[45] C. Umans. Fast polynomial factorization and modular

pseudorandom function with applications to adaptive
ot and secure computation of set intersection. In
O. Reingold, editor, TCC 2009, volume 5444 of LNCS,
pages 577–594. Springer, 2009.

[31] S. Jarecki and V. Shmatikov. Eﬃcient two-party

secure computation on committed inputs. In M. Naor,
editor, EUROCRYPT 2007, volume 4515 of LNCS,
pages 97–114. Springer, 2007.

[32] M. Joye and B. Libert. Eﬃcient cryptosystems from
2 k -th power residue symbols. In T. Johansson and
P. Q. Nguyen, editors, EUROCRYPT 2013, volume
7881 of LNCS, pages 76–92. Springer, 2013.

[33] L. Kissner and D. Song. Privacy-preserving set

operations. In V. Shoup, editor, CRYPTO 2005,

composition in small characteristic. In C. Dwork,
editor, STOC 2008, pages 481–490. ACM, 2008.

[46] J. van de Pol and N. P. Smart. Estimating key sizes

for high dimensional lattice-based systems. In
M. Stam, editor, IMACC 2013, volume 8308 of LNCS,
pages 290–303. Springer, 2013.

[47] M. van Dijk, C. Gentry, S. Halevi, and

V. Vaikuntanathan. Fully homomorphic encryption
over the integers. In H. Gilbert, editor, EUROCRYPT
2010, volume 6110 of LNCS, pages 24–43. Springer,
2010.

298