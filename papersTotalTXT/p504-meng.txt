GRECS: Graph Encryption for Approximate

Shortest Distance Queries

Xianrui Meng
Boston University

xmeng@cs.bu.edu

Seny Kamara
Microsoft Research

senyk@microsoft.com

George Kollios
Boston University

gkollios@cs.bu.edu

Kobbi Nissim

Ben-Gurion University

∗

CRCS Harvard University

kobbi@cs.bgu.ac.il

ABSTRACT
We propose graph encryption schemes that eﬃciently sup-
port approximate shortest distance queries on large-scale en-
crypted graphs. Shortest distance queries are one of the
most fundamental graph operations and have a wide range
of applications. Using such graph encryption schemes, a
client can outsource large-scale privacy-sensitive graphs to
an untrusted server without losing the ability to query it.
Other applications include encrypted graph databases and
controlled disclosure systems. We propose GRECS (stands
for GRaph EnCryption for approximate Shortest distance
queries) which includes three oracle encryption schemes that
are provably secure against any semi-honest server. Our
ﬁrst construction makes use of only symmetric-key opera-
tions, resulting in a computationally-eﬃcient construction.
Our second scheme makes use of somewhat-homomorphic
encryption and is less computationally-eﬃcient but achieves
optimal communication complexity (i.e. uses a minimal
amount of bandwidth). Finally, our third scheme is both
computationally-eﬃcient and achieves optimal communica-
tion complexity at the cost of a small amount of additional
leakage. We implemented and evaluated the eﬃciency of our
constructions experimentally. The experiments demonstrate
that our schemes are eﬃcient and can be applied to graphs
that scale up to 1.6 million nodes and 11 million edges.

Categories and Subject Descriptors
G.2.2 [Discrete Mathematics]: Graph Theory—graph
algorithms; H.2.7 [DATABASE MANAGEMENT]:
Database Administration—Security, integrity, and protec-
tion; D.4.6 [OPERATING SYSTEMS]: Security and
Protections—Cryptographic controls

∗Work partly done when the author was visiting the Hariri

Institute for Computing and Computational Science & En-
gineering at Boston University.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813672.

Keywords
Graph encryption; structured encryption; graph algorithms;
shortest distance queries; searchable encryption

1 Introduction
Graph databases that store, manage, and query large graphs
have received increased interest recently due to many large-
scale database applications that can be modeled as graph
problems. Example applications include storing and query-
ing large Web graphs, online social networks, biological net-
works, RDF datasets, and communication networks. As a
result, a number of systems have been proposed to manage,
query, and analyze massive graphs both in academia (e.g.,
Pregel [35], GraphLab [34], Horton [42], Trinity [44], Tur-
boGraph [23], and GraphChi-DB [29]) and industry (e.g.,
Neo4j, Titan, DEX, and GraphBase). Furthermore, with
the advent of cloud computing, there is a natural desire for
enterprises and startups to outsource the storage and man-
agement of their databases to a cloud provider.
Increas-
ing concerns about data security and privacy in the cloud,
however, have curbed many data owners’ enthusiasm about
storing their databases in the cloud.

To address this, Chase and Kamara [7] introduced the
notion of graph encryption. Roughly speaking, a graph en-
cryption scheme encrypts a graph in such a way that it can
be privately queried. Using such a scheme, an organization
can safely outsource its encrypted graph to an untrusted
cloud provider without losing the ability to query it. Several
constructions were described in [7] including schemes that
support adjacency queries (i.e., given two nodes, do they
have an edge in common?), neighbor queries (i.e., given a
node, return all its neighbors) and focused subgraph queries
on web graphs (a complex query used to do ranked web
searches). Graph encryption is a special case of structured
encryption, which are schemes that encrypt data structures
in such a way that they can be privately queried. The
most well-studied class of structured encryption schemes are
searchable symmetric encryption (SSE) schemes [46, 6, 20,
13, 25, 24, 5, 4, 37, 47] which, roughly speaking, encrypt
search structures (e.g., indexes or search trees) for the pur-
pose of eﬃciently searching on encrypted data.

In this work, we focus on the problem of designing graph
encryption schemes that support one of the most fundamen-
tal and important graph operations: ﬁnding the shortest
distance between two nodes. Shortest distance queries are

504a basic operation in many graph algorithms but also have
applications of their own. For instance, on a social net-
work, shortest distance queries return the shortest number
of introductions necessary for one person to meet another.
In protein-protein interaction networks they can be used to
ﬁnd the functional correlations among proteins [39] and on
a phone call graph (i.e., a graph that consists of phone num-
bers as vertices and calls as edges) they return the shortest
number of calls connecting two nodes.

Our techniques and contributions. Computing short-
est distance queries on massive graphs (e.g., the Web graph,
online social networks or a country’s call graph) can be very
expensive, so in practice one typically pre-computes a data
structure from the graph called a distance oracle that an-
swers shortest distance queries approximately [48, 14, 11];
that is, given two vertices v1 and v2, the structure returns a
distance d that is at most α· dist(v1, v2) + β, where α, β > 1
and dist(v1, v2) is the exact distance between v1 and v2.

In this work, we focus on designing structured encryption
schemes for a certain class of distance oracles referred to
as sketch-based oracles. Below we summarize our contribu-
tions:

• We propose three distance oracle encryption schemes.
Our ﬁrst scheme only makes use of symmetric-key
operations and, as such,
is very computationally-
eﬃcient. Our second scheme makes use of somewhat-
homomorphic encryption and achieves optimal com-
munication complexity.
is
computationally-eﬃcient, achieves optimal communi-
cation complexity and produces compact encrypted or-
acles at the cost of some leakage.

third scheme

Our

• We show that all our constructions are adaptively
semantically-secure with reasonable leakage functions.
• We implement and evaluate our solutions on real large-
scale graphs and show that our constructions are prac-
tical.

1.1 Related Work
Graph privacy. Privacy-preserving graph processing has
been considered in the past. Most of the work in this area,
however, focuses on privacy models that are diﬀerent than
ours. Some of the proposed approaches include structural
anonymization to protect neighborhood information [17, 33,
9], use diﬀerential privacy [15] to query graph statistics pri-
vately [26, 45], or use private information retrieval (PIR)
[36] to privately recover shortest paths. We note that none
of these approaches are appropriate in our context where
the graph itself stores sensitive information (and therefore
must be hidden unlike in the PIR scenario) and is stored
remotely (unlike the diﬀerential privacy and anonymization
scenarios). Structured and graph encryption was introduced
by Chase and Kamara in [7]. Structured encryption is a gen-
eralization of searchable symmetric encryption (SSE) which
was ﬁrst proposed by Song, Wagner and Perrig [46]. The no-
tion of adaptive semantic security was introduced by Curt-
mola, Garay, Kamara and Ostrovsky in [13] and generalized
to the setting of structured encryption in [7]. One could
also encrypt and outsource the graph using fully homomor-
phic encryption [18], which supports arbitrary computations
on encrypted data, but this would be prohibitively slow in
practice. Another approach is to execute graph algorithms

over encrypted and outsourced graphs is to use Oblivious
RAM [21] over the adjacency matrix of the graph. This
approach, however, is ineﬃcient and not practical even for
small graphs since it requires storage that is quadratic in the
number of nodes in the graph and a large number of costly
oblivious operations. Recent work by [49] presents an obliv-
ious data structure for computing shortest paths on planar
graphs using ORAM. For a sparse planar graph with O(n)
√
edges, their approach requires O(n1.5) space complexity at
n log n) online query time. Recent works
the cost of O(
based on ORAM, such as [31, 32], also propose oblivious se-
cure computation frameworks that can be used to compute
single source shortest paths. However, these are general pur-
pose frameworks and are not optimized to answer shortest
distance queries. Other techniques, such as those developed
by Blanton, Steele and Aliasgari [2] and by Aly et al. [1]
do not seem to scale to sparse graphs with millions of nodes
due to the quadratic complexity of the underlying operations
which are instantiated with secure multi-party computation
protocols.

Distance oracles. Computing shortest distances on large
graphs using Dijkstra’s algorithm or breadth ﬁrst search is
very expensive. Alternatively, it is not practical to store all-
pairs-shortest-distances since it requires quadratic space. To
address this, in practice, one pre-computes a data structure
called a distance oracle that supports approximate shortest
distance queries between two nodes with logarithmic query
time. Solutions such as [14, 38, 40, 11, 8, 10, 12] care-
fully select seed nodes (also known as landmarks) and store
the shortest distances from all the nodes to the seeds. The
advantage of using such a data structure is that they are
compact and the query time is very fast. For example, the
distance oracle construction of Das Sarma, Gollapudi, Na-
jork and Panigrahy [14] requires ˜O(n1/c) work to return a
(2c−1)-approximation of the shortest distance for some con-
stant c.

2 Preliminaries and Notations
Given an undirected graph G = (V, E), we denote its to-
tal number of nodes as n = |V | and its number of edges
as m = |E|. A shortest distance query q = (u, v) asks for
the length of the shortest path between u and v which we
denote dist(u, v). The notation [n] represents the set of in-
tegers {1, . . . , n}. We write x ← χ to represent an element
x being sampled from a distribution χ. We write x $←− X to
represent an element x being uniformly sampled at random
from a set X. The output x of a probabilistic algorithm A
is denoted by x ← A and that of a deterministic algorithm
B by x := B. Given a sequence of elements v, we deﬁne
its ith element either as vi or v[i] and its total number of
elements as |v|. If A is a set then |A| refers to its cardinal-
ity. Throughout, k ∈ N will denote the security parameter
and we assume all algorithms take k implicitly as input. A
function ν : N → N is negligible in k if for every positive
polynomial p(·) and all suﬃciently large k, ν(k) < 1/p(k).
We write f (k) = poly(k) to mean that there exists a poly-
nomial p(·) such that f (k) ≤ p(k) for all suﬃciently large
k ∈ N; and we similarly write f (k) = negl(k) to mean that
there exists a negligible function ν(·) such that f (k) ≤ ν(k)
for all suﬃciently large k. A dictionary DX is a data struc-
ture that stores label/value pairs ((cid:96)i, vi)n
i=1. Dictionaries
support insert and lookup operations deﬁned as follows: an

505insert operation takes as input a dictionary DX and a la-
bel/value pair ((cid:96), v) and adds the pair to DX. We denote
this as DX[(cid:96)] := v. A lookup operation takes as input a dic-
tionary DX a label (cid:96)i and returns the associated value vi. We
denote this as vi := DX[(cid:96)i]. Dictionaries can be instantiated
using hash tables and various kinds of search trees.

2.1 Cryptographic Tools

Encryption. In this work, we make use of several kinds of
encryption schemes including standard symmetric-key en-
cryption and homomorphic encryption. A symmetric-key
encryption scheme SKE = (Gen, Enc, Dec) is a set of three
polynomial-time algorithms that work as follows. Gen is a
probabilistic algorithm that takes a security parameter k as
input and returns a secret key K; Enc is a probabilistic al-
gorithm that takes as input a key K and a message m and
returns a ciphertext c; Dec is a deterministic algorithm that
takes as input a key K and a ciphertext c and returns m
if K was the key under which c was produced. A public-
key encryption scheme PKE = (Gen, Enc, Dec) is similarly
deﬁned except that Gen outputs a public/private key pair
(pk, sk) and Enc encrypts messages with the public key pk.
Informally, an encryption scheme is CPA-secure (Chosen-
Plaintext-Attack-secure) if the ciphertexts it outputs do not
reveal any partial information about the messages even to
an adversary that can adaptively query an encryption or-
acle. We refer the reader to [27] for formal deﬁnitions of
symmetric-key encryption and CPA-security.

A public-key encryption scheme is homomorphic if, in ad-
dition to (Gen, Enc, Dec), it also includes an evaluation al-
gorithm Eval that takes as input a function f and a set of
ciphertexts c1 ← Encpk(m1) through cn ← Encpk(mn) and
returns a ciphertext c such that Decsk(c) = f (m1, . . . , mn).
If a homomorphic encryption scheme supports the evalu-
ation of any polynomial-time function, then it is a fully-
homomorphic encryption (FHE) scheme [41, 18] otherwise
it is a somewhat homomorphic encryption (SWHE) scheme.
In this work, we make use of only “low degree” homomor-
phic encryption; namely, we only require the evaluation of
quadratic polynomials. In particular, we need the evaluation
algorithm to support any number of additions: Encpk(m1 +
cation: Encpk(m1m2) = Eval(×, Encpk(m1), Encpk(m2)), that
is, a ciphertext that results from a homomorphic multiplica-
tion cannot be used in another homomorphic multiplication.
Concrete instantiations of such schemes include the scheme
of Boneh, Goh and Nissim (BGN) [3] based on bilinear maps
and the scheme of Gentry, Halevi and Vaikuntanathan [19]
based on lattices.

m2) = Eval(cid:0)+, Encpk(m1), Encpk(m2)(cid:1); and a single multipli-

Pseudo-random functions. A pseudo-random function
(PRF) from domain D to co-domain R is a function fam-
ily that is computationally indistinguishable from a random
function. In other words, no computationally-bounded ad-
versary can distinguish between oracle access to a function
that is chosen uniformly at random in the family and oracle
access to a function chosen uniformly at random from the
space of all functions from D to R. A pseudo-random per-
mutation (PRP) is a pseudo-random family of permutations
over D. We refer the reader to [27] for formal deﬁnitions of
PRFs and PRPs.

3 Distance Oracles
At a high-level, our approach to designing graph encryption
schemes for shortest distance queries consists of encrypting
a distance oracle in such a way that it can be queried pri-
vately. A distance oracle is a data structure that supports
approximate shortest distance queries. A trivial construc-
tion consists of pre-computing and storing all the pairwise
shortest distances between nodes in the graph. The query
complexity of such a solution is O(1) but the storage com-
plexity is O(n2) which is not practical for large graphs.

We consider two practical distance oracle constructions.
Both solutions are sketch-based which means that they as-
sign a sketch Skv to each node v ∈ V in such a way that
the approximate distance between two nodes u and v can be
eﬃciently (sublinear) computed from the sketches Sku and
Skv. The ﬁrst construction is by Das Sarma et al. [14] which
is itself based on a construction of Thorup and Zwick [48]
and the second is by Cohen et al.
[11]. The two solutions
produce sketches of the same form and distance queries are
answered using the same operation.

Sketch-based oracles. More formally, a sketch-based dis-
tance oracle DO = (Setup, Query) is a pair of eﬃcient algo-
rithms that work as follows. Setup takes as input a graph
G, an approximation factor α and an error bound ε and
outputs an oracle ΩG = {Skv}v∈V . Query takes as input an
oracle ΩG and a shortest distance query q = (u, v). We say
that DO is (α, ε)-correct if for all graphs G and all queries
q = (u, v), Pr [ dist(u, v) ≤ d ≤ α · dist(u, v) ] ≥ 1 − ε, where
d := Query(ΩG, u, v). The probability is over the random-
ness of algorithm Setup.

The Das Sarma et al.

makes σ = (cid:101)Θ(n2/(α+1)) calls to a Sketch sub-routine with

oracle. The Setup algorithm

v1 , . . . , Ski

the graph G. Throughout, we refer to σ as the oracle’s sam-
pling parameter and we note that it aﬀects the size of the
sketches. During the ith call, the Sketch routine generates
and returns a collection of sketches (Ski
vn ), one for
every node vj ∈ V . Each sketch Ski
vj is a set constructed as
follows. During the ith call to Sketch, it samples uniformly
at random λ = log n sets of nodes S0, . . . , Sλ−1 of progres-
sively larger sizes. In particular, for all 0 ≤ z ≤ λ− 1, set Sz
vj then consists of λ pairs {(wz, δz)}0≤z≤λ−1
is of size 2z. Ski
such that wz is the closest node to vj among the nodes in
Sz and δz = dist(vj, wz). Having computed σ collections of
sketches (Ski
vn )i∈[σ], Setup then generates, for each
vj . Finally, it out-
puts a distance oracle ΩG = (Skv1 , . . . , Skvn ). Throughout,
we refer to the nodes stored in the node/distance pairs of
the sketches as seeds.

node vj ∈ V , a ﬁnal sketch Skvj =(cid:83)σ

v1 , . . . , Ski

i=1 Ski

The Cohen et al. oracle. The Setup algorithm assigns
to each node v ∈ V a sketch Skv that includes pairs (w, δ)
chosen as follows. It ﬁrst chooses a random rank function
rk : V → [0, 1]; that is, a function that assigns to each
v ∈ V a value distributed uniformly at random from [0, 1].
Let Nd(v) be the set of nodes within distance d − 1 of v
and let ρ = Θ(n2/(α+1)). Throughout, we refer to ρ as the
oracle’s rank parameter and note that it aﬀects the size of
the sketches. For each node v ∈ V , the sketch Skv includes
pairs (w, δ) such that rk(w) is less than the ρth value in the
sorted set {rk(y) : y ∈ Ndist(u,v)(v)}. Finally it outputs a
distance oracle ΩG = (Skv1 , . . . , Skvn ). Like above, we refer

506to the nodes stored in the node/distance pairs of the sketches
as seeds.

Shortest distance queries. The two oracle constructions
share the same Query algorithm which works as follows.
Given a query q = (u, v), it ﬁnds the set of nodes I in
common between Sku and Skv and returns the minimum
over s ∈ I of dist(u, s) + dist(s, v). If there are no nodes in
common, then it returns ⊥.

Sk(u): {(a, 3), (b, 3), (e, 6), (g, 3), (h, 4)}
Sk(v): {(b, 2), (d, 1), (e, 3), (h, 3), (f, 7)}

Figure 1: Two sketches for nodes u and v. The approximate
shortest distance d = 5.

4 Distance Oracle Encryption
In this section we present the syntax and security deﬁni-
tion for our oracle encryption schemes. There are many
variants of structured encryption, including interactive and
non-interactive, response-revealing and response-hiding. We
consider interactive and response-hiding schemes which de-
note the fact that the scheme’s query operation requires at
least two messages (one from client and a response from
server) and that queries output no information to the server.

Definition 4.1

(Oracle Encryption). A distance
oracle encryption scheme Graph = (Setup, distQuery) con-
sists of a polynomial-time algorithm and a polynomial-time
two-party protocol that work as follows:

• (K, EO) ← Setup(1k, Ω, α, ε):

is a probabilistic algo-
rithm that takes as input a security parameter k, a
distance oracle Ω, an approximation factor α, and an
error parameter ε. It outputs a secret key K and an
encrypted graph EO.
• (d,⊥) ← distQueryC,S

(cid:0)(K, q), EO(cid:1): is a two-party pro-

tocol between a client C that holds a key K and a short-
est distance query q = (u, v) ∈ V 2 and a server S that
holds an encrypted graph EO. After executing the pro-
tocol, the client receives a distance d ≥ 0 and the server
receives ⊥. We sometimes omit the subscripts C and
S when the parties are clear from the context.

For α ≥ 1 and ε < 1, we say that Graph is (α, ε)-correct if
for all k ∈ N, for all Ω and for all q = (u, v) ∈ V 2,

Pr [ d ≤ α · dist(u, v) ] ≥ 1 − ε,

where the probability is over the randomness in com-
puting (K, EO) ← Setup(1k, Ω, α, ε) and then (d,⊥) ←

distQuery(cid:0)(K, q), EO(cid:1).

4.1 Security
At a high level, the security guarantee we require from an
oracle encryption scheme is that: (1) given an encrypted
oracle, no adversary can learn any information about the
underlying oracle; and (2) given the view of a polynomial
number of distQuery executions for an adaptively generated
sequence of queries q = (q1, . . . , qn), no adversary can learn
any partial information about either ΩG or q.

Such a security notion can be diﬃcult to achieve eﬃ-
ciently, so often one allows for some form of leakage. Follow-
ing [13, 7], this is usually formalized by parameterizing the
security deﬁnition with leakage functions for each operation
of the scheme which in this case include the Setup algorithm
and distQuery protocol.

We adapt the notion of adaptive semantic security from
[13, 7] to our setting to the case of distance oracle encryp-
tion.

Definition 4.2. Let Graph = (Setup, distQuery) be an
oracle encryption scheme and consider the following proba-
bilistic experiments where A is a semi-honest adversary, C
is a challenger, S is a simulator and LSetup and LQuery are
(stateful) leakage functions:

IdealA,S (1k):

• A outputs an oracle Ω, its approximation factor α and

its error parameter ε.

• Given LSetup(Ω), 1k, α and ε, S generates and sends

an encrypted graph EO to A.

• A generates a polynomial number of adaptively cho-
sen queries (q1, . . . , qm). For each qi, S is given
LQuery(Ω, qi) and A and S execute a simulation of
distQuery with A playing the role of the server and S
playing the role of the client.

• A computes a bit b that is output by the experiment.

RealA(1k):

• A outputs an oracle Ω, its approximation factor α and
its error parameter ε.
• C computes (K, EO) ← Setup(1k, Ω, α, ε) and sends the
encrypted graph EO to A.
• A generates a polynomial number of adaptively cho-
sen queries (q1, . . . , qm). For each query qi, A and C
execute distQueryC,A
• A computes a bit b that is output by the experiment.
(LSetup,LQuery)-
We
there

(cid:0)(K, q), EO(cid:1).

for all ppt adversaries A,

that Graph

is

adaptively

say

semantically secure if
exists a ppt simulator S such that

(cid:104)

(cid:12)(cid:12)(cid:12)Pr

(cid:105) − Pr

(cid:104)

(cid:105)

(cid:12)(cid:12)(cid:12) = negl(k).

RealA(1k) = 1

IdealA,S (1k)

= 1

The deﬁnition above captures the fact that, given the en-
crypted oracle and its view of the query protocol, an adver-
sarial server cannot learn any information about the oracle
beyond the leakage.
4.2 Leakage
All the distance oracle encryption schemes we discuss in
this work leak information. We describe and formalize these
leakages below.

Setup leakage. The setup leakage of our ﬁrst and sec-
ond constructions, GraphEnc1 and GraphEnc2 in Sections
5.1 and 5.2,
includes the total number of nodes in the
underlying graph n,
the maximum sketch size S =
maxv∈V |Skv| and the maximum distance over all seeds
D = maxv∈V max(w,δ)∈Skv δ. The setup leakage of our third
construction, GraphEnc3 in Section 5.3, includes n, S, D and

the total number of seeds Z =(cid:80)

v∈V |Skv|.

507Query pattern leakage. The query leakage of our
ﬁrst two constructions, GraphEnc1 and GraphEnc2, reveals
whether the nodes in the query have appeared before. We
refer to this as the query pattern leakage and formalize it
below.

Definition 4.3

(Query pattern). For two queries
q, q(cid:48) deﬁne Sim(q, q(cid:48)) = (u = u(cid:48),u = v(cid:48),v = u(cid:48), v = v(cid:48)), i.e.,
whether each of the nodes q = (u, v) matches each of the
nodes of q(cid:48) = (u(cid:48), v(cid:48)). Let q = (q1, . . . , qm) be a non-empty
sequence of queries. Every query qi ∈ q speciﬁes a pair of
nodes ui, vi. The query pattern leakage function LQP (q) re-
turns an m × m (symmetric) matrix with entry i, j equals
Sim(qi, qj). Note that LQP does not leak the identities of
the queried nodes.

We do not claim that it is always reasonable for a graph
encryption scheme to leak the query pattern - it may convey
sensitive information in some settings. Furthermore, Deﬁni-
tion 4.2 does not attempt to capture all possible leakages.
As with many similar deﬁnitions, it does not capture side
channels, and, furthermore, it does not capture leakage re-
sulting from the client’s behavior given the query answers,
which, in turn may be aﬀected by the choice of an approxi-
mation algorithm (see also [16, 22] for a discussion of privacy
of approximation algorithms).

third

pattern

leakage. Our

construction,
Sketch
GraphEnc3,
leaks the query pattern and an additional
pattern we refer to as the sketch pattern. The sketch
pattern reveals which seeds are shared between the diﬀerent
sketches of the oracle and the size of the sketches. We
formalize this below by revealing randomized “pseudo-ids”
of the seeds in each sketch.

Definition 4.4

(Sketch pattern leakage). The

sketch pattern leakage function LSP (ΩG, q) for a graph
G and a query q = (u, v) is a pair (X, Y ), where
X = {f (w) : (w, δ) ∈ Sku} and Y = {f (w) : (w, δ) ∈ Skv}
are multi-sets and f : {0, 1}log n → {0, 1}log n is a random
function.

It is not clear what this leakage implies in practice but
we note that the leakage is not (directly) over the graph but
over the sketches which contain a random subset of nodes.
Therefore, it may be possible to add some form of noise in
the sketches (e.g., using fake sketch elements) to guarantee
some level of privacy to the original graph. We note that
leakage is revealed in all SSE constructions such as [46, 6, 20,
13, 7, 25, 28, 24, 5, 37, 4]. However, in all these constructions
the leakage is over a data structure (e.g., an inverted index)
that holds all of the original data (i.e., all the keywords and
documents). In our case, the leakage is over a structure that
holds only a random subset of the data. This could provide
additional help with respect to privacy but this is a topic
for future work and is not the main focus of this paper.
4.3 Efﬁciency
We evaluate the eﬃciency and practicality of our construc-
tions according to the following criteria:

• Setup time: the time for the client to pre-process and

encrypt the graph;

• Space complexity: the size of the encrypted graph;

• Query time: The time to execute a shortest distance

query on the encrypted graph;

• Communication complexity:

the number of bits ex-

changed during a query operation.

5 Our Constructions
In this section, we describe our three oracle encryption
schemes. The ﬁrst scheme, GraphEnc1, is computationally
eﬃcient, but has high communication overhead. Our second
scheme, GraphEnc2, is communication eﬃcient but has high
space overhead. Our third scheme, GraphEnc3, is compu-
tationally eﬃcient with optimal communication complexity.
GraphEnc1 and GraphEnc2 do not leak anything besides the
Query Pattern, and GraphEnc3 also leaks the Sketch Pattern.
5.1 A Computationally-Efﬁcient Scheme
We now describe our ﬁrst scheme which is quite practical.
The scheme GraphEnc1 = (Setup, distQuery) makes use of
a symmetric-key encryption scheme SKE = (Gen, Enc, Dec)
and a PRP P . The Setup algorithm works as follows. Given
a 1k, ΩG, α and ε:

• It pads each sketch to the maximum sketch size S by

ﬁlling them with dummy values.

• It then generates keys K1, K2 for the encryption
scheme and PRP respectively and sets K = (K1, K2).
For all v ∈ V , it computes a label PK2 (v) and cre-
ates an encrypted sketch ESkv = (c1, ..., cλ), where
ci ← EncK1 (wi(cid:107)δi) is a symmetric-key encryption of
the ith pair (wi, δi) in Skv.

• It then sets up a dictionary DX in which it stores, for
all v ∈ V , the pairs (PK2 (v), ESkv), ordered by the
labels. The encrypted graph is then simply EO = DX.

The distQuery protocol works as follows.

To query
EO on q = (u, v),
the client sends a token tk =
(tk1, tk2) = (PK2 (u), PK2 (v)) to the server which returns
the pair ESku := DX[tk1] and ESkv := DX[tk2]. The
client then decrypts each encrypted sketch and computes
mins∈I dist(u, s) + dist(s, v) (note that the algorithm only
needs the sketches of the nodes in the query).

Security and eﬃciency. It is straightforward to see
that the scheme is adaptively (L,LQP )-semantically secure,
where L is the function that returns n, S and D. We defer
a formal proof to the full version of this work. The com-
munication complexity of the distQuery protocol is linear in
S, where S is the maximum sketch size. Note that even
though S is sub-linear in n, it could still be large in prac-
tice. For example, in the Das Sarma et al. construction
S = O(n2/α · log n). Also, in the case of multiple concurrent
queries, this could be a signiﬁcant bottleneck for the scheme.
In the following Section, we show how to achieve a solution
with O(1) communication complexity and in Section 6 we
experimentally show that it scales to graphs with millions
of nodes.
5.2 A Communication-Efﬁcient Scheme
second scheme GraphEnc2 =
We now describe our
(Setup, distQuery) which is less computationally eﬃcient

508Algorithm 1: Setup algorithm for GraphEnc2
Input : 1k, ΩG, α, ε
Output: EO
1 begin Setup

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Sample K $← {0, 1}k;
Initialize a dictionary DX;
Generate a key pair (pk, sk) ← SWHE.Gen(1k);
Set S := maxv∈V |Skv|;
Set D := maxv∈V
Set N := 2 · D + 1 and t = 2 · S2 · ε−1;
Sample a hash function h : V → [t] from H;
foreach v ∈ V do

(cid:8) max(w,δ)∈Skv δ(cid:9);

compute (cid:96)v := PK (v);
initialize an array Tv of size t;
foreach (wi, δi) ∈ Skv do

set Tv[h(wi)] ← SWHE.Encpk(2N−δi );
ﬁll remaining cells of Tv with encryptions of
0; set DX[(cid:96)v] := Tv;

Output K and EO = DX

than our ﬁrst but is optimal with respect to communication
complexity.

The details of the construction are given in Algorithms 1
It makes use of a SWHE scheme SWHE =
and 2.
(Gen, Enc, Dec, Eval), a pseudo-random permutation P and
a family of universal hash functions H.

The Setup algorithm works as follows. Given 1k, ΩG, α,
and ε as inputs, it generates a public/secret-key pair (pk, sk)
for SWHE. Let D be the maximum distance over all the
sketches and S be the maximum sketch size. Setup sets
N := 2 · D + 1 and samples a hash function h $← H with
domain V and co-domain [t], where t = 2 · S2 · ε−1.
It then creates a hash table for each node v ∈ V . More
precisely, for each node v, it processes each pair (wi, δi) ∈
Skv and stores Encpk(2N−δi ) at location h(wi) of a t-size ar-
ray Tv. In other words, for all v ∈ V , it creates an array Tv
such that for all (wi, δi) ∈ Skv, Tv[h(wi)] ← Encpk(2N−δi ).
It then ﬁlls the empty cells of Tv with homomorphic encryp-
tions of 0 and stores each hash table Tv1 through Tvn in a
dictionary DX by setting, for all v ∈ V , DX[PK (v)] := Tv.
Finally, it outputs DX as the encrypted oracle EO.
Fig. 2 below provides an example of one of the hash tables
Tv generated from a sketch Skv = {(w1, δ1), . . . , (ws, δs)},
where s is the size of the sketch. For all i ∈ [s], the cipher-
text Encpk(2N−δi ) is stored at location h(wi) of the table
Tv. For example, we place Encpk(22−δj ) to Tv[h(wj)] since
h(wj) = 1. Finally, all remaining locations of Tv are ﬁlled
with SWHE encryptions of 0. Notice that, since we are using
probabilistic encryption, the encryptions of 0 are diﬀerent,
and are indistinguishable from the encryptions of the other
values.

Figure 2: One node’s encrypted hash table.

The distQuery protocol works as follows.

Given a
query q = (u, v), the client sends tokens (tk1, tk2) =
(PK (u), PK (v)) to the server which uses them to retrieve the

hash tables of nodes u and v by computing Tu := DX[tk1]
and Tv := DX[tk2]. The server then homomorphically eval-
uates an inner product over the hash tables. More precisely,

i=1 Tu[i] · Tv[i], where(cid:80) and · refer to

it computes c :=(cid:80)t

the homomorphic addition and multiplication operations of
of the SWHE scheme. Finally, the server returns only c to
the client who decrypts it and outputs 2N − log2 (Decsk(c)).

Algorithm 2: DistQuery algorithm for GraphEnc2
Input : Client’s input is (K, q) and server’s input is

Output: Client’s output is distq and server’s output is

EO.
⊥.

1 begin distQuery
2

C: client parses q as (u, v);
C ⇒ S: client sends
tk = (tk1, tk2) = (PK (u), PK (v));
S: server retrieves T1 := DX[tk1] and T2 := DX[tk2];
foreach i ∈ [t] do
Server computes
ci ← SWHE.Eval(×, T1[i], T2[i]);

S ⇒ C: server sends c ← SWHE.Eval(+, c1, . . . , ct);
C: client computes m ← SWHE.Decsk(c);
C: client outputs dist = 2N − log m.

3

4

5

6

7

8

9

Note that the storage complexity at the server is O(n · t)
and the communication complexity of distQuery is O(1) since
the server only returns a single ciphertext. In Section 5.2.1,
we analyze the correctness and security of the scheme.
Remark. The reason we encrypt 2N−δi as opposed to δi
is to make sure we can get the minimum sum over the dis-
tances from the sketches of both u and v. Our observation
is that 2x + 2y is bounded by 2max(x,y)−1. As we show Theo-
rem 5.2, this approach does not, with high probability, aﬀect
the approximation factor from what the underlying distance
oracle give us.

Instantiating & optimizing the SWHE scheme. For
our experiments (see Section 6) we instantiate the SWHE
scheme with the BGN construction of [3]. We choose BGN
due to the eﬃciency of its encryption algorithm and the
compactness of its ciphertexts and keys (as compared to the
lattice-based construction of [19]). Unfortunately, the BGN
decryption algorithm is expensive as it requires computa-
tions of discrete logarithms. To improve this, we make use
of various optimizations. In particular, we compute discrete
logs during decryption using the Baby step Giant step al-
gorithm [43] and use a pre-computed table to speed up the
computation. We defer the details of our optimizations to
the full version of this work.
5.2.1 Correctness
Here, we analyze the correctness of GraphEnc2. We ﬁrst
bound the collision probability of our construction and then
proceed to prove correctness in Theorem 5.2 below.

Lemma 5.1. Let q = (u, v) be a shortest distance query
and let Eq be the event that a collision occurred in the Setup
algorithm while constructing the hash tables Tu and Tv.
Then, Pr [Eq ] ≤ 2 · S2
t .

Proof: Let Collv be the event that at least one collision
occurs while creating v’s hash table Tv (i.e., in Algorithm 1

!!…!…!TvEncpk(2N−δi)Encpk(2N−δk)Encpk(2N−δj)Encpk(0)Encpk(0)Encpk(0)0(cid:1)h(wi)(cid:1)h(wj)(cid:1)h(wk)(cid:1)2(cid:1)t-1(cid:1)509Setup Line 13). Also, let XCollu,v be the event that there
exists at least one pair of distinct nodes wu ∈ Sku and wv ∈
Skv such that h(wu) = h(wv). For any q = (u, v), we have

Pr [Eq ] ≤ Pr [ Collu ] + Pr [ Collv ] + Pr [ XCollu,v ].

(cid:1) node pairs in Sku and Skv, respectively,

(1)

Let su be the size of Sku an sv be the size of Skv. Since there

(cid:1) and (cid:0)sv

are (cid:0)su

2

2

t

v

u

2·t and Pr [ Collv ] ≤ s2

and each pair collides under h with probability at most
1/t, Pr [ Collu ] ≤ s2
2·t . On the other
hand, if I is the set of common nodes in Sku and Skv, then
. Recall that su = sv ≤ S, so
Pr [ XCollu,v ] ≤ (su−|I|)(sv−|I|)
by combining with Eq. 1, we have Pr [Eq ] ≤ 2 · S2
(cid:4)
t .
Note that in practice “intra-sketch” collision events Collu
and Collv may or may not aﬀect the correctness of the
scheme. This is because the collisions could map the SWHE
encryptions to locations that hold encryptions of 0 in other
sketches. This means that at query time, these SWHE en-
cryptions will not aﬀect the inner product operation since
they will be canceled out.
Inter-sketch collision events
XCollu,v, however, may aﬀect the results since they will
cause diﬀerent nodes to appear in the intersection of the
two sketches and lead to an incorrect sum.

Theorem 5.2. Let G = (V, E), α ≥ 1 and ε < 1. For all

q = (u, v) ∈ V 2 with u (cid:54)= v,

Pr [ α · dist(u, v) − log |I| ≤ d ≤ α · dist(u, v) ] ≥ 1 − ε,

GraphEnc2.distQuery(cid:0)(K, q), EO(cid:1),

where
(K, EO) ← GraphEnc2.Setup(1k, ΩG, α, ε), and I is the
number of common nodes between Sku and Skv.

:=

(d,⊥)

i + δv

c =(cid:80)t

i ∈ Sku and δv

Proof: Let I be the set of nodes in common between Sku
i }, where for all
and Skv and let mindist = minwi∈I{δu
i ∈ Skv. Note that at line 7
0 ≤ i ≤ |I|, δu
in Algorithm 2 distQuery, the server returns to the client
Let Eq be the event a collision occurred during Setup in
the construction of the hash tables Tu and Tv of u and v
respectively. Conditioned on Eq, we therefore have that

i=1 Tu[i] · Tv[i].

|I|(cid:88)

c =

Encpk(2N−δu

i ) · Encpk(2N−δv
i )

(cid:0)22N · Σ

i=1

= Encpk

i )(cid:1),

|I|
i=12

−(δu

i +δv

where the ﬁrst equality holds since for any node wi (cid:54)∈ I,
one of the homomorphic encryptions Tu[i] or Tv[i] is an
It follows then that (conditioned on Eq)
encryption of 0.
at Step 9 the client outputs

d = 2N − log(cid:0)22N · Σ
≤ 2N − log(cid:0)22N−mindist(cid:1)

|I|
i=12

i )(cid:1)

−(δu

i +δv

≤ mindist,

where the ﬁrst inequality holds since mindist ≤ (δu
i ) for
all i ∈ |I|. Towards showing a lower bound on d note that

i + δv

d = 2N − log(cid:0)22N · Σ
≥ 2N − log(cid:0)22N−mindist + |I|(cid:1)

|I|
i=12

−(δu

i )(cid:1)

i +δv

≥ mindist − log |I|,

where the ﬁrst inequality also holds from mindist ≤ (δu
i +δv
i )
for all i ∈ |I|. Now, by the (α, ε)-correctness of DO, we have

that mindist ≤ α · dist(u, v) with probability at least (1 − ε)
over the coins of DO.Setup. So, conditioned on Eq,

mindist − log |I| ≤ d ≤ α · dist(u, v).

The Theorem follows by combining this with Lemma 5.1
which bounds the probability of Eq and noting that Setup
sets t = 2 · S2 · ε−1.
(cid:4)

Space complexity. Note that to achieve (α, ε)-correctness,
our construction produces encrypted sketches that are larger
than the original sketches. More precisely, if the maximum
sketch size of the underlying distance oracle is S, then the
size of every encrypted sketch is t = 2 · S2 · ε−1, which
is considerably larger. In Section 5.3, we describe a third
construction which achieves better space eﬃciency at the
cost of more leakage.

Remark on the approximation. Note that Theorem 5.2
also provides a lower bound of α · dist(u, v) − log |I| for the
approximate distance. In particular, the bound depends on
the set of common nodes |I| which varies for diﬀerent queries
but is small in practice. Furthermore, if log |I| is larger than
mindist, the approximate distance returned could be neg-
ative (we indeed observe a few occurrences of this in our
experiments).

To improve the accuracy of the approximation, one
could increase the base in the homomorphic encryptions.
More precisely,
instead of using encryptions of the form
Encpk(2N−δ) we could use Encpk(BN−δ) for B = 3 or
B = 4. This would result in an improved lower bound of
mindist − logB |I| but would also increase the homomorphic
decryption time since this increases the message space which
in turn adds overhead to the decryption algorithm. We leave
it as an open problem to further improve this lower bound
without increasing the message space.

Remark on error rate. Given the above analysis, a client
that makes γ queries will have an error ratio of ε · γ.
In
our experiments we found that, in practice, when using the
Das Sarma et al. oracle, setting σ ≈ 3 results in a good
√
n),
approximation. So if we ﬁx σ = 3 and set t = O(

then the error rate is O(cid:0)γ · log2(n)/
we achieve about the same error rate O(cid:0)γ · ln2(n)/

√
signiﬁcantly as n grows. In the case of the Cohen et al. all-
√
n), then
distance sketch, if we ﬁx ρ = 4 and set t = O(

n(cid:1) which decreases
n(cid:1). We

√

provide in Section 6 detailed experimental result on the error
rate.
5.2.2
In the following Theorem, we analyze the security of
GraphEnc2.

Security

Theorem 5.3. If P is pseudo-random and SWHE
is CPA-secure
as described above,
is adaptively (LSetup,LQuery)-semantically secure, where
LSetup(ΩG) = (n, S, D) and LQuery(ΩG, q) = LQP (ΩG, q).

then GraphEnc2,

Proof Sketch: Consider the simulator S that works as fol-
lows. Given leakage LSetup(ΩG) = (S, D), it starts by gen-
erating (pk, sk) ← SWHE.Gen(1k). For all 1 ≤ i ≤ n, it
$← {0, 1}log n without repetition and sets
then samples (cid:96)i
DX[(cid:96)i] := Ti, where Ti is an array that holds t = 2 · S2
m · ε−1
homomorphic encryptions of 0 ∈ 2N , where N = 2 · D + 1.
It outputs EO = DX.

510Given leakage LQuery(ΩG, q) = LQP (ΩG, q) it checks if ei-
ther of the query nodes u or v appeared in any previous
query. If u appeared previously, S sets tk1 to the value that
was previously used. If not, it sets tk1 := (cid:96)i for some pre-
viously unused (cid:96)i. It does the same for the query node v;
that is, it sets tk2 to be the previously used value if v was
previously queried or to an unused (cid:96)i if it was not.

The theorem follows from the pseudo-randomness of P
(cid:4)

and the CPA-security of SWHE.

5.3 A Space-Efﬁcient Construction
Although our second construction, GraphEnc2, achieves opti-
mal communication complexity, it has two limitations. The
ﬁrst is that it is less computationally-eﬃcient than our ﬁrst
construction GraphEnc1 both with respect to constructing
the encrypted graph and to querying it. The second limita-
tion is that its storage complexity is relatively high; that is,
it produces encrypted graphs that are larger than the ones
produced by GraphEnc1 by a factor of 2 · S · ε−1. These lim-
itations are mainly due to the need to ﬁll the hash tables
with many homomorphic encryptions of 0. This also slows
down the query algorithm since it has to homomorphically
evaluate an inner product on two large tables.

To address

this, we propose a third construction
GraphEnc3 = (Setup, distQuery) which is both space-eﬃcient
and achieves O(1) communication complexity. The only
trade-oﬀ is that it leaks more than the two previous con-
structions.

Algorithm 3: Setup algorithm for GraphEnc3
Input : 1k, ΩG, α, ε
Output: EO
1 begin Setup

$← {0, 1}k;
Sample K1, K2
Initialize a counter ctr = 1;

Let Z =(cid:80)

v∈V |Skv|;

Sample a random permutation π over [Z];
Initialize an array Arr of size Z;
Initialize a dictionary DX of size n;
Generate (pk, sk) ← SWHE.Gen(1k);
Set S := maxv∈V |Skv|;
Set D := maxv∈V
Set N := 2 · D + 1 and t = 2 · S2 · ε−1;
Initialize collision-resistant hash function
h : V → [t];
foreach v ∈ V do

(cid:8) max(w,δ)∈Skv δ(cid:9);

sample Kv ← {0, 1}k;
foreach (wi, δi) ∈ Skv do

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

compute ci ← SWHE.Encpk(2N−δi );
if i (cid:54)= |Skv| then
Set Ni = (cid:104)h(wi)(cid:107)ci(cid:107)π(ctr + 1)(cid:105);
Set Ni = (cid:104)h(wi)(cid:107)ci(cid:107)NULL(cid:105);

else

$← {0, 1}k;

Sample ri
Set Arr[π(ctr)] := (cid:104)Ni ⊕ H(Kv(cid:107)ri), ri(cid:105);
Set ctr = ctr + 1 ;

foreach v ∈ V (in random order) do

Set DX[PK1 (v)] := (cid:104)addrArr(hv)(cid:107)Kv(cid:105) ⊕ FK2 (v)
Output K = (K1, K2, pk, sk) and EO = (DX, Arr);

The details of the scheme are given in Algorithms 3 and 4.
At a high-level, the scheme works similarly to GraphEnc2
with the exception that the encrypted sketches do not store
encryptions of 0’s, i.e., they only store the node/distance
pairs of the sketches constructed by the underlying distance
oracle.
Implementing this high-level idea is not straight-
forward, however, because simply removing the encryptions
of 0’s from the encrypted sketches/hash tables reveals the
size of the underlying sketches to the server which, in turn,
leaks structural information about the graph. We overcome
this technical diﬃculty by adapting a technique from [13]
to our setting. Intuitively, we view the seed/distance pairs
in each sketch Skv as a linked-list where each node stores a
seed/distance pair. We then randomly shuﬄe all the nodes
and place them in an array; that is, we place each node of
each list at a random location in the array while updating
the pointers so that the “logical” integrity of the lists are
preserved (i.e., given a pointer to the head of a list we can
still ﬁnd all its nodes). We then encrypt all the nodes with
a per-list secret key.

The scheme makes use of a SWHE scheme SWHE =
(Gen, Enc, Eval, Dec), a pseudo-random permutation P , a
pseudo-random function F , a random oracle H and a
collision-resistant hash function h modeled as a random
function

v∈V |Skv|.

π over the domain [Z], where Z = (cid:80)

The Setup algorithm takes as input a security parameter
k, an oracle ΩG , an approximation factor α, and an error
parameter ε < 1. As shown in Algorithm 3, it ﬁrst initial-
izes a counter ctr = 1 and samples a random permutation
It then
initializes an Z-size array Arr. It proceeds to create an en-
crypted sketch ESkv from each sketch Skv as follows. It ﬁrst
samples a symmetric key Kv for this sketch. Then for each
seed/distance pair (wi, δi) in Skv, it creates a linked-list node
Ni = (cid:104)h(wi)(cid:107)ci(cid:107)π(ctr + 1)(cid:105), where ci ← Encpk(2N−δi ), and
stores an H-based encryption (cid:104)Ni ⊕ H(Kv(cid:107)rv), rv(cid:105) of the
node at location π(ctr) in Arr. For the last seed/distance
pair, it uses instead a linked-list node of the form Ni =
(cid:104)h(wi)(cid:107)ci(cid:107)NULL(cid:105), it then increments ctr.
Setup then creates a dictionary DX where it stores for each
node v ∈ V , the pair (PK1 (v),(cid:104)addrArr(hv)(cid:107)Kv(cid:105) ⊕ FK2 (v)),
where addrArr(hv) is the location in Arr of the head of v’s
linked-list. Figure 3 provides a detailed example for how we
encrypt the sketch. Suppose node u’s sketch Sku has the
element (a, d1), (b, d2), (c, d3). The locations ind1, ind2, ind3
in Arr are computed according the random permutation π.

Figure
{(a, d1), (b, d2), (c, d3)}.

3:

Example

of

encrypting

Sku

=

The distQuery protocol, which is

rithm 4, works as
(u, v),

client

the

follows.

sends

tokens

shown in Algo-
Given a query q =
(tk1, tk2, tk3, tk4) =

ind3%ind2%ind1%…%…%…%…%…%Arr%…%…%Kv||ind1      FK2(v)…%DX:(a,%d1)(cid:1)(b,%d2)(cid:1)(c,%d3)(cid:1)v(cid:1):(cid:1)<h(b)||SWHE.Enc(2N-d2))||ind3%%%%%H(Kv||r2), r2>(cid:1)<(h(c)||SWHE.Enc(2N-d3))||NULL%%%%%H(Kv||r3), r3>(cid:1)<h(a)||SWHE.Enc(2N-d1))||ind2%%%%%%H(Kv||r1), r1>(cid:1)511Algorithm 4: The protocol distQueryC,S.
Input : Client’s input is K, q = (u, v) and server’s
Output: Client’s output is d and server’s output is ⊥

input is EO

1 begin distQuery
2

C: computes (tk1, tk2, tk3, tk4) =
(PK1 (u), PK1 (v), FK2 (u), FK2 (v));
C ⇒ S: sends tk = (tk1, tk2, tk3, tk4);
S: computes γ1 ← DX[tk1] and γ2 ← DX[tk2];
if γ1 = ⊥ or γ2 = ⊥ then
exit and return ⊥ to the client
S: compute (cid:104)a1||Ku(cid:105) := γ1 ⊕ tk3;
S: parse Arr[a1] as (cid:104)σu, ru(cid:105);
S: compute N1 := σu ⊕ H(Ku(cid:107)ru);
repeat

parse Ni as (cid:104)hi(cid:107)ci(cid:107)ai+1(cid:105);
parse Arr[ai+1] as (cid:104)σi+1, ri+1(cid:105);
compute Ni+1 := σi+1 ⊕ H(Ku(cid:107)ri+1);
set i = i + 1;

until ai+1 = NULL;
S: compute (cid:104)b1||Kv(cid:105) := γ2 ⊕ tk4;
S: parse Arr[b1] as (cid:104)σv, rv(cid:105);
1 := σv ⊕ H(Kv(cid:107)rv);
(cid:48)
S: compute N
repeat

j(cid:107)c(cid:48)

j(cid:107)bj+1(cid:105);

j as (cid:104)h(cid:48)
(cid:48)
parse N
parse Arr[bj+1] as (cid:104)σj+1, rj+1(cid:105);
j+1 := σj+1 ⊕ H(Kv(cid:107)rj+1);
(cid:48)
compute N
set j = j + 1;

until bj+1 = NULL;
S: set s := SWHE.Encpk(0);
(cid:48)
foreach (Ni, N
j) do
if hi = h(cid:48)
j then

compute p := SWHE.Eval(×, ci, c(cid:48)
j);
compute s := SWHE.Eval(+, s, p);

S ⇒ C: send s;
C: compute d := SWHE.Decsk(s)

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

:= DX[tk1] and γ2

(PK1 (u), PK1 (v), FK2 (u), FK2 (v)) to the server which uses
them to retrieve the values γ1
:=
DX[tk2]. The server computes (cid:104)a1||Ku(cid:105) := γ1 ⊕ tk3 and
(cid:104)b1||Kv(cid:105) := γ2 ⊕ tk4. Next, it recovers the lists pointed
to by a1 and b1. More precisely, starting with i = 1, it
parses Arr[a1] as (cid:104)σu, ru(cid:105) and decrypts σu by computing
(cid:104)hi(cid:107)ci(cid:107)ai+1(cid:105) := σu ⊕ H(Ku(cid:107)ru) while ai+1 (cid:54)= NULL. And
starting with j = 1, it does the same to recover (cid:104)h(cid:48)
j(cid:107)bj+1(cid:105)
while bj+1 (cid:54)= NULL.

The server then homomorphically computes an inner
product over the ciphertexts with the same hashes. More

precisely, it computes ans := (cid:80)

j, where (cid:80)

ci · c(cid:48)

j

and · refer to the homomorphic addition and multiplica-
tion operations of the SWHE scheme. Finally, the server
returns only ans to the client which decrypts it and outputs
2N − log2 (SWHE.Decsk(ans)).
Note that the storage complexity at the server is O(m +
|V |) and the communication complexity of distQuery is still
O(1) since the server only returns a single ciphertext.

(i,j):hi=h(cid:48)

j(cid:107)c(cid:48)

5.3.1 Correctness and Security
The correctness of GraphEnc3 follows directly from the cor-
rectness of GraphEnc2. To see why, observe that: (1) the

homomorphic encryptions stored in the encrypted graph of
GraphEnc3 are the same as those in the encrypted graph pro-
duced by GraphEnc2 with the exception of the encryptions of
0; and (2) the output d of the client results from executing
the same homomorphic operations as in GraphEnc2, with the
exception of the homomorphic sums with 0-encryptions.

We note that GraphEnc3 leaks only a little more than the
previous constructions. With respect to setup leakage it re-
veals, in addition to (n, S, D), the total number of seeds
Z.
Intuitively, for a query q = (u, v), the query leakage
consists the query pattern leakage in addition to: (1) which
seed/distance pairs in the sketches Sku and Skv are the same;
and (2) the size of these sketches. This is formalized in Def-
inition 4.4 as the sketch pattern leakage LSP (ΩG, q). In the
following Theorem, we summarize the security of GraphEnc3.

Theorem 5.4. If P and F are pseudo-random, if SWHE
is CPA-secure then GraphEnc3, as described above,
is
adaptively (LSetup,LQuery)-semantically secure in the ran-
dom oracle model, where LSetup(ΩG) = (n, S, D, Z) and
LQuery(ΩG, q) = (LQP (ΩG, q),LSP (ΩG, q)).
Proof Sketch: Consider the simulator S that works as fol-
lows. Given leakage LSetup = (n, S, D, Z), for all 1 ≤ i ≤ Z
$← {0, 1}log t+g(N )+log Z+k, where g(·) is the ci-
it samples Γi
phertext expansion of SWHE, t = 2·S2·ε−1 and N = 2·D+1.
It then stores all the Γi’s in a Z-element array Arr. For
all 1 ≤ i ≤ n, it samples (cid:96)i
$← {0, 1}log n without repe-
tition and sets DX[(cid:96)i] $← {0, 1}log Z+k. Finally, it outputs
EO = (DX, Arr).
Given leakage LQuery(G, q) = (LQP (G, q),LSP (G, q)) such
that LSP (G, q) = (X, Y ), S ﬁrst checks if either of the query
nodes u or v appeared in any previous query. If u appeared
previously, S sets tk1 and tk3 to the values that were pre-
If not, it sets tk1 := (cid:96)i for some previously
viously used.
unused (cid:96)i and tk3 as follows.
It chooses a previously un-
used α ∈ [Z] at random, a key Ku
$← {0, 1}k and sets
tk3 := DX[tk1] ⊕ (cid:104)α(cid:107)Ku(cid:105). It then remembers the associa-
tion between Ku and X and the sketch size |Sku|. It does
the same for the query node v, sets tk2 and tk4 analogously
and associates |Skv| and Y with the key Kv it chooses.

It simulates the random oracle H as follows. Given (K, r)
as input, it checks to see if: (1) K has been queried before
(in the random oracle); and (2) if any entry in Arr has the
form (cid:104)s, r(cid:105) where s is a (log t + g(N ) + log Z)-bit string.
If K has not been queried before, it initializes a counter
ctrK := 0. If an appropriate entry exists in Arr, it returns
s ⊕ (cid:104)γ, c, p(cid:105), where γ is the ctrth element of the multi-set
X or Y associated with K, c is a SWHE encryption of 0
and p is an unused address in Arr chosen at random or ∅ if
ctr = |Sk|, where |Sk| is the sketch size associated with K. If
no appropriate entry exists in Arr, S returns a random value.
The Theorem then follows from the pseudo-randomness of
(cid:4)
P and F and the CPA-security of SWHE.

6 Experimental Evaluation
In this section, we present experimental evaluations of our
schemes on a number of large-scale graphs. We implement
the Das Sarma et al. distance oracle (DO1) and Cohen et
al. distance oracle (DO2) and all three of our graph encryp-
tion schemes. We use AES-128 in CBC mode for symmet-
ric encryption and instantiate SWHE with the Boneh-Goh-

512Nissim (BGN) scheme, implemented in C++ with the Stan-
ford Pairing-Based Library PBC1. We use OpenSSL2 for all
basic cryptographic primitives and use 128-bit security for
all the encryptions. We use HMAC for PRFs and instanti-
ate the hash function in GraphEnc3 with HMAC-SHA-256.
All experiments were run on a 24-core 2.9GHz Intel Xeon,
with 512 GBs of RAM running Linux.
6.1 Datasets
We use real-world graph datasets publicly available from the
Stanford SNAP website3. In particular, we use as-skitter,
a large Internet topology graph; com-Youtube, a large so-
cial network based on the Youtube web site; loc-Gowalla, a
location-based social network; email-Enron, an email com-
munication network; and ca-CondMat, a collaboration net-
work for scientiﬁc collaborations between authors of papers
related to Condensed Matter research. Table 1 summarizes
the main characteristics of these datasets.

Dataset
as-skitter
com-Youtube
loc-Gowalla
email-Enron
ca-CondMat

Nodes
1,696,415
1,134,890
196,591
36,692
23,133

Edges
11,095,298
2,987,624
950,327
367,662
186,936

Diameter Storage
143MB
37MB
11MB
1.84MB
158KB

25
20
14
11
14

Table 1: The graph datasets used in our experiments

Notice that some of these datasets contain millions of
nodes and edges and that the diameters of these graphs are
small. This is something that has been observed in many
real-life graphs [30] and is true for expander and small-world
graphs, which are known to model many real-life graphs.
The implication of this, is that the maximum distance D in
the sketches generated by the distance oracles is, in practice,
small and therefore the value N that we use in GraphEnc2
and GraphEnc3 (see Algorithm 1 and 3) is typically small.
6.2 Overview
For a graph G = (V, E) with n nodes, we summarize in
Table 2 our constructions’ space, setup, and communica-
tion complexities as well as the complexities for both the
server and client during the query phase. Note that the
complexities for each scheme also depend on α, however, in
practice, since setting σ for DO1 (ρ for DO2) to some small
numbers resulted good approximations, therefore, it makes
α = O(log n). In our experiments, we test diﬀerent σ and
ρ’s and the sketch size, |Skv|, for each node is sublinear in
the size of the graph, i.e. O(log n).

Scheme

Space

Setup Time

Communication

GraphEnc2

GraphEnc1
O(n log n) O(n log2 n/ε)
O(n log n) O(n log2 n/ε)
O(log n)

O(1)

GraphEnc3
O(n log n)
O(n log n)

O(1)

Server Query Comp.
Client Query Comp.

O(1)

O(log n)

O(log2 n/ε)
O(diameter) O(diameter)

O(log n)

Table 2: The space, setup, communication, and query com-
plexities of our constructions (α is set to be in O(log n)).

1http://crypto.stanford.edu/pbc/
2https://www.openssl.org/
3https://snap.stanford.edu/data/

Table 3 summarizes our experimental results. Compared
to existing schemes, such as [1], our experiments shows that
the constructions are very eﬃcient and scalable for large
real dataset. For example, in [1], it takes several minutes
to securely compute the shortest path distance for graph
with only tens to hundreds of nodes, whereas it takes only
seconds for our scheme to query the encrypted graph up to
1.6 million nodes.
6.3 Performance of GraphEnc1
We evaluate the performance of GraphEnc1 using both the
Das Sarma et al. and Cohen et al. distance oracles. For the
Das Sarma et al. oracle (DO1), we set the sampling param-
eter σ = 3 and for the Cohen et al. oracle (DO2) we set the
rank parameter ρ = 4. We choose these parameters because
they resulted in good approximation ratios and the maxi-
mum sketch sizes (i.e., S) of roughly the same amount. Note
that, the approximation factor α in those then is in O(log n)
for GraphEnc1, therefore, the communication complexity (see
Table 2) in GraphEnc1 is O(log n). We can see from Table 3
that the time to setup an encrypted graph with GraphEnc1
is practical—even for large graphs. For example, it takes
only 8 hours to setup an encryption of the as-skitter graph
which includes 1.6 million nodes. Since the GraphEnc1.Setup
is highly-parallelizable, we could speed setup time consider-
ably by using a cluster. A cluster of 10 machines would be
enough to bring the setup time down to less than an hour.
Furthermore, the size of the encrypted sketches range from
1KB for CondMat to 1.94KB for as-skitter per node. The
main limitation of this construction is that the communica-
tion is proportional to the size of the sketches. We tested
for various sketch sizes, and the communication per query
went up to 3.8KB for as-skitter when we set S = 80. This
can become quite signiﬁcant if the server is interacting with
multiple clients.
6.4 Performance of GraphEnc2
The ﬁrst column in Table 3 of the GraphEnc2 experiments
gives the size the encrypted hash tables Tv constructed dur-
ing GraphEnc2.Setup. Table sizes range from 5K for ca-
CondMat to 11K for as-skitter.

The Time column gives the time to create an encrypted
hash-table/sketch per node. This includes generating the
BGN encryptions of the distances and the 0-encryptions.
Note that this makes GraphEnc2.Setup quite costly, about 3
orders of magnitude more expensive than GraphEnc1.Setup.
This is mostly due to generating the 0-encryptions. Note,
however, that similarly to GraphEnc1, we can use extensive
parallelization to speed up the setup. For example, using a
cluster of 100 machines, we can setup the encrypted graph
on the order of hours, even for as-skitter which includes 1.6
million nodes. The space overhead per node is also large, but
the encrypted graph itself can be distributed in a cluster
since every encrypted sketch is independent of the other.
Finally, as shown in Table 3, GraphEnc2 achieves a constant
communication cost of 34B.

In Fig. 4, we report on the intra- and inter-collisions that
we observed when executing over 10K diﬀerent queries over
our datasets. The collision probability ranges between 1%
and 3.5%. As we can see from the results, the oracle DO2
has less collisions than DO1.

We would like to point out that those inter-collisions can
be detected by associating with each encryption of a node

513Dataset

As-skitter

Youtube

Gowalla

Enron

CondMat

sketch

size
S
80
71
80
68
70
53
60
45
55
42

Graph

Sketching
Scheme
DO1
DO2
DO1
DO2
DO1
DO2
DO1
DO2
DO1
DO2

Comm.

per query
(in bytes)

GraphEnc1
Setup Time

per node
(in ms)

Size

per node
(in KBs)

3,840
3,120
3,840
3,120
3360
2544
2880
2160
2640
2016

16.7
14
16.5
14.5
14.9
12
12.5
9.39
11.8
7.8

1.94
1.63
1.94
1.63
1.7
1.29
1.44
1.11
1.34
1.03

T
size
11K
8.4K
10K
8.5K
7.5K
7K
7K
6.5K
5.5K
5K

GraphEnc2

Comm.

per query
(in bytes)

Setup Time

Size

per node
(in secs)

per node
(in MBs)

Comm.

per query
(in bytes)

GraphEnc3
Setup Time

per node
(in ms)

Size

per node
(in KBs)

34
34
34
34
34
34
34
34
34
34

7.3
6.59

8

6.57
7.4
5
5.6
4.81
4.65
3.8

1.1
0.76
1.1
0.76
0.82
0.62
0.76
0.53
0.65
0.49

34
34
34
34
34
34
34
34
34
34

20.1
16
18.2
17.3
15.6
14.7
14
10
13.2
8.2

1.91
1.83
1.91
1.7
1.71
1.41
1.48
1.25
1.31
1.21

Table 3: A full performance summary for GraphEnc1, GraphEnc2, and GraphEnc3

a random value and its inverse value that are unique for
each node.
If two diﬀerent nodes collide, the product of
these values will be a random value, whereas if the same
node is mapped to the same entry the product will give 1.
More discussion about this technique will appear in the full
version of this work.

6.5.2 Query Time

(a) Query Time (in ms) using DO1

Figure 4: Collision probabilities for diﬀerent datasets

6.5 Performance of GraphEnc3
The GraphEnc3 columns in Table 3 show that GraphEnc3
is as eﬃcient as GraphEnc1 in terms of setup time and en-
crypted sketch size. Moreover, it achieves O(1) commu-
nication of 34B like GraphEnc2. Using a single machine,
GraphEnc3.Setup took less than 10 hours to encrypt as-
skitter, but like the other schemes, it is highly paralleliz-
able, and this could be brought down to an hour using 10
machines. We instantiated the hash function h using a cryp-
tographic keyed hash function HMAC-SHA-256.
6.5.1 Construction time & encrypted sketch size
Since the performance of GraphEnc3 depends only on the
size of the underlying sketches we investigate the relation-
ship between the performance of GraphEnc3.Setup and the
sampling and rank parameters of the Das Sarma et al. and
Cohen et al. oracles, respectively. We use values of σ and ρ
ranging from 3 to 6 in each case which resulted in maximum
sketch sizes S ranging from 43 to 80. Figure 5 and Figure 6
give the construction time and size overhead of an encrypted
sketch when using the Das Sarma et al. oracle and Cohen
et al. oracle respectively.

In each case, the construction time scales linearly when σ
and ρ increase. Also, unlike the previous schemes, GraphEnc3
produces encrypted sketches that are compact since it does
not use 0-encryptions for padding purposes.

(b) Query Time (in ms) DO2

Figure 7: Average Query time

We measured the time to query an encrypted graph as a
function of the oracle sampling/rank parameter. The aver-
age time at the server (taken over 10K random queries) is
given in Figure 7 for all our graphs and using both distance
oracles. In general, the results show that query time is fast
and practical. For as-skitter, the query time ranges from 6.1
to 10 milliseconds with the Das Sarma et al. oracle and from
5.6 to 10 milliseconds with the Cohen et al. oracle. Query
time is dominated by the homomorphic multiplication oper-
ation of the BGN scheme. But the number of multiplications
only depends on the number of common seeds from the two
encrypted sketches and, furthermore, these operations are
independent so they can be parallelized. We note that we
use mostly un-optimized implementations of all the underly-
ing primitives and we believe that a more careful implemen-
tation (e.g., faster pairing library) would reduce the query
time even further. We also measure the decryption time at

369123456ρAverage Query Time (in ms)As−skittercondmatenrongowallayoutube369123456ρAverage Query Time (in ms)As−skittercondmatenrongowallayoutube514Construction Time (in ms)

Size Overhead (in KB)

Figure 5: Construction time and size overhead (DO1)

Construction Time (in ms)

Size Overhead (in KB)

Figure 6: Construction time and size overhead (DO2)

the client. As pointed out previously, decryption time de-
pends on N which itself is a function of the diameter of the
graph. Since all our graphs have small diameter, client de-
cryption time—which itself consists of a BGN decryption—
was performed very eﬃciently.
In particular, the average
decryption time was less than 4 seconds and in most cases
the decryption ranged between 1 and 3 seconds.

Finally, we would like to mention that there is some ad-
ditional information that is leaked. In our construction, we
leak the parameter ρ and σ that are related to the size of
the encrypted graph and this may leak some information
about how “hard” it is to approximate the shortest distance
values for the particular graph at hand. Also, the time that
it takes to estimate the ﬁnal result at the client may reveal
the diameter of the graph, since it is related to the N and
the max distance in the sketches.
6.6 Approximation errors
We investigate the approximation errors produced by our
schemes. We generate 10K random queries and run the
QueryC,S protocol. For client decryption, we recover 2N −
log m and round it to its ﬂoor value. We used breadth-ﬁrst
search (BFS) to compute the exact distances between each
pair of nodes and we compare the approximate distance re-
turned by our construction to exact distances obtained with
BFS. We report the mean and the standard deviation of the
relative error for each dataset. We used both oracles to com-
pute the sketches. We present our results in Figure 8, which
shows that our approximations are quite good. Indeed, our
experiments show that our constructions could report bet-
ter approximations than the underlying oracles. This is due
to the fact that both oracles overestimate the distance so
subtracting log |I| can improve the approximation. For the

DO1

DO2

Figure 8: Mean of Estimated Error with Standard Deviation

Gowalla dataset, the mean of the relative error ranges from
0.36 to 0.13 when using the Das Sarma et al. oracle DO1.
For as-skitter, it ranges from 0.45 to 0.22. The mean error
and the variance decreases as we increase the size of each
sketch. In addition, we note that DO2 performs better in

0.00.20.40.63456σmean of relative error with sdas−skittercondmatenrongowallayoutube0.00.10.20.30.40.53456ρmean of relative error with sdas−skittercondmatenrongowallayoutube515all datasets. Also, half of the distances returned are exact
and most of the distances returned are at most 2 away from
the real distance. Figure 9 shows the histogram for the ab-
solute error when using DO2 with ρ = 3. All the other
datasets are very similar to them, so we omit them due to
space limitations.

Figure 9: Absolute error histogram DO2 and ρ = 3

We note that a very small number of distances were neg-
ative and we removed them from the experiments. Nega-
tive distances result from the intersection size |I| being very
large. Indeed, when the client decrypts the SWHE cipher-
text returned by the server, it recovers d ≥ mindist − log |I|.
If |I| is large and mindist is small (say, 1 or 2) then it is very
likely that d is negative. However, in the experiments, the
number of removed negative values were very small (i.e., 80
out of 10000 queries).

7 Conclusion
In this work, we described three graph encryption schemes
that support approximate shortest distance queries. Our
ﬁrst solution, GraphEnc1, is based only on symmetric-key
primitives and is computationally very eﬃcient while our
second solution, GraphEnc2, is based on somewhat homomor-
phic encryption and is optimal in terms of communication
complexity. Furthermore, our third solution, GraphEnc3,
achieves the “best of both worlds” and is computationally
very eﬃcient with optimal communication complexity. Our
schemes work with any sketched-based distance oracle. We
implemented our constructions and evaluated their eﬃciency
experimentally, showing that our constructions are practical
for large-scale graphs.

8 Acknowledgments
George Kollios and Xianrui Meng were partially supported
by NSF grants IIS-1320542 and CNS-1414119. Kobbi Nis-
sim was supported by NSF grant CNS-1237235, a Simons
Investigator grant, and ISF grant 276/12. The ﬁrst author
would like to thank Edith Cohen for clarifying the imple-
mentation of the all-distance sketches. The authors would
also like to thank the anonymous reviewers for their useful
comments.

9 References

[1] A. Aly, E. Cuvelier, S. Mawet, O. Pereira, and M. V.

Vyve. Securely solving simple combinatorial graph
problems. In Financial Cryptography, pages 239–257,
2013.

[2] M. Blanton, A. Steele, and M. Aliasgari.

Data-oblivious graph algorithms for secure
computation and outsourcing. In ASIACCS, pages
207–218, 2013.

[3] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating 2-dnf
formulas on ciphertexts. In TCC 2005, pages 325–342,
2005.

[4] D. Cash, J. Jaeger, S. Jarecki, C. Jutla, H. Krawczyk,

M. Rosu, and M. Steiner. Dynamic searchable
encryption in very-large databases: Data structures
and implementation. In NDSS ’14, 2014.

[5] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu,
and M. Steiner. Highly-scalable searchable symmetric
encryption with support for boolean queries. In
CRYPTO ’13, pages 353–373, 2013.

[6] Y. Chang and M. Mitzenmacher. Privacy preserving

keyword searches on remote encrypted data. In ACNS
’05, pages 442–455. Springer, 2005.

[7] M. Chase and S. Kamara. Structured encryption and

controlled disclosure. In ASIACRYPT ’10, volume
6477, pages 577–594, 2010.

[8] S. Chechik. Approximate distance oracles with

constant query time. In STOC, pages 654–663, 2014.
[9] J. Cheng, A. W.-C. Fu, and J. Liu. K-isomorphism:

privacy preserving network publication against
structural attacks. In SIGMOD, pages 459–470, 2010.

[10] E. Cohen. All-distances sketches, revisited: Hip

estimators for massive graphs analysis. In PODS,
pages 88–99, 2014.

[11] E. Cohen, D. Delling, F. Fuchs, A. V. Goldberg,

M. Goldszmidt, and R. F. Werneck. Scalable similarity
estimation in social networks: closeness, node labels,
and random edge lengths. In COSN, pages 131–142,
2013.

[12] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick.

Reachability and distance queries via 2-hop labels.
SIAM J. Comput., 32(5):1338–1355, 2003.

[13] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky.

Searchable symmetric encryption: Improved
deﬁnitions and eﬃcient constructions. In CCS, pages
79–88. ACM, 2006.

[14] A. Das Sarma, S. Gollapudi, M. Najork, and

R. Panigrahy. A sketch-based distance oracle for
web-scale graphs. In WSDM, pages 401–410, 2010.
[15] C. Dwork, F. McSherry, K. Nissim, and A. Smith.

Calibrating noise to sensitivity in private data
analysis. In TCC, pages 265–284, 2006.

[16] J. Feigenbaum, Y. Ishai, T. Malkin, K. Nissim, M. J.

Strauss, and R. N. Wright. Secure multiparty
computation of approximations. ACM Transactions on
Algorithms, 2(3):435–472, 2006.

[17] J. Gao, J. X. Yu, R. Jin, J. Zhou, T. Wang, and

D. Yang. Neighborhood-privacy protected shortest
distance computing in cloud. In SIGMOD, pages
409–420, 2011.

[18] C. Gentry. Fully homomorphic encryption using ideal

lattices. In STOC ’09, pages 169–178. ACM Press,
2009.

[19] C. Gentry, S. Halevi, and V. Vaikuntanathan. A

simple bgn-type cryptosystem from lwe. In
EUROCRYPT, pages 506–522. Springer, 2010.

516[20] E.-J. Goh. Secure indexes. Technical Report 2003/216,

IACR ePrint Cryptography Archive, 2003. See
http://eprint.iacr.org/2003/216.

[21] O. Goldreich and R. Ostrovsky. Software protection

and simulation on oblivious RAMs. Journal of the
ACM, 43(3):431–473, 1996.

[22] S. Halevi, R. Krauthgamer, E. Kushilevitz, and

K. Nissim. Private approximation of np-hard
functions. In STOC, pages 550–559. ACM, 2001.

[23] W. Han, S. Lee, K. Park, J. Lee, M. Kim, J. Kim, and

H. Yu. Turbograph: a fast parallel graph engine
handling billion-scale graphs in a single PC. In KDD,
pages 77–85, 2013.

[24] S. Kamara and C. Papamanthou. Parallel and

dynamic searchable symmetric encryption. In FC ’13,
2013.

[25] S. Kamara, C. Papamanthou, and T. Roeder.

Dynamic searchable symmetric encryption. In CCS.
ACM Press, 2012.

[26] S. P. Kasiviswanathan, K. Nissim, S. Raskhodnikova,

and A. Smith. Analyzing graphs with node diﬀerential
privacy. In TCC, pages 457–476, 2013.

[27] J. Katz and Y. Lindell. Introduction to Modern

Cryptography. Chapman & Hall/CRC, 2008.

[28] K. Kurosawa and Y. Ohtaki. Uc-secure searchable

symmetric encryption. In Financial Cryptography and
Data Security (FC ’12), Lecture Notes in Computer
Science, pages 285–298. Springer, 2012.

[29] A. Kyrola and C. Guestrin. Graphchi-db: Simple

design for a scalable graph database system - on just a
PC. CoRR, abs/1403.0701, 2014.

[30] J. Leskovec, J. M. Kleinberg, and C. Faloutsos. Graphs
over time: densiﬁcation laws, shrinking diameters and
possible explanations. In KDD, pages 177–187, 2005.
[31] C. Liu, Y. Huang, E. Shi, J. Katz, and M. W. Hicks.
Automating eﬃcient ram-model secure computation.
In IEEE SP, pages 623–638, 2014.

[32] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi.

Oblivm: A programming framework for secure
computation. In IEEE SP, pages 359–376, 2015.

[33] K. Liu and E. Terzi. Towards identity anonymization

on graphs. In SIGMOD, pages 93–106, 2008.
[34] Y. Low, J. Gonzalez, A. Kyrola, D. Bickson,

C. Guestrin, and J. M. Hellerstein. Graphlab: A new
framework for parallel machine learning. In UAI,
pages 340–349, 2010.

[35] G. Malewicz, M. H. Austern, A. J. C. Bik, J. C.
Dehnert, I. Horn, N. Leiser, and G. Czajkowski.
Pregel: a system for large-scale graph processing. In
SIGMOD, pages 135–146, 2010.

[36] K. Mouratidis and M. L. Yiu. Shortest path

computation with no information leakage. PVLDB,
pages 692–703, 2012.

[37] M. Naveed, M. Prabhakaran, and C. Gunter. Dynamic

searchable encryption via blind storage. In Oakland
S& P, pages 639–654, 2014.

[38] M. Potamias, F. Bonchi, C. Castillo, and A. Gionis.

Fast shortest path distance estimation in large
networks. In CIKM, pages 867–876, 2009.

[39] N. Przulj, D. A. Wigle, and I. Jurisica. Functional

topology in a network of protein interactions.
Bioinformatics, 20(3):340–348, 2004.

[40] Z. Qi, Y. Xiao, B. Shao, and H. Wang. Toward a
distance oracle for billion-node graphs. In VLDB,
pages 61–72, 2013.

[41] R. Rivest, L. Adleman, and M. Dertouzos. On data

banks and privacy homomorphisms. In Foundations of
Secure Computation, pages 169–180, 1978.

[42] M. Sarwat, S. Elnikety, Y. He, and G. Kliot. Horton:

Online query execution engine for large distributed
graphs. In ICDE, pages 1289–1292, 2012.

[43] D. Shanks. Class number, a theory of factorization,
and genera. In 1969 Number Theory Institute, pages
415–440. Providence, R.I., 1971.

[44] B. Shao, H. Wang, and Y. Li. Trinity: a distributed

graph engine on a memory cloud. In SIGMOD, pages
505–516, 2013.

[45] E. Shen and T. Yu. Mining frequent graph patterns

with diﬀerential privacy. In KDD 2013, pages 545–553,
2013.

[46] D. Song, D. Wagner, and A. Perrig. Practical
techniques for searching on encrypted data. In
Oakland S & P, pages 44–55, 2000.

[47] E. Stefanov, C. Papamanthou, and E. Shi. Practical

dynamic searchable encryption with small leakage. In
NDSS, 2014.

[48] M. Thorup and U. Zwick. Approximate distance

oracles. Journal of the ACM, 52(1):1–24, Jan. 2005.
[49] X. S. Wang, K. Nayak, C. Liu, T. H. Chan, E. Shi,

E. Stefanov, and Y. Huang. Oblivious data structures.
In CCS, pages 215–226, 2014.

517