Toward Robust Hidden Volumes Using

Write-Only Oblivious RAM

Erik-Oliver Blass Travis Mayberry Guevara Noubir Kaan Onarlioglu

College of Computer and Information Science

Northeastern University, Boston MA

Email: {blass|travism|noubir|onarliog}@ccs.neu.edu

ABSTRACT
With sensitive data being increasingly stored on mobile devices and
laptops, hard disk encryption is more important than ever. In partic-
ular, being able to plausibly deny that a hard disk contains certain
information is a very useful and interesting research goal. However,
it has been known for some time that existing “hidden volume” so-
lutions, like TrueCrypt, fail in the face of an adversary who is able
to observe the contents of a disk on multiple, separate occasions.
In this work, we explore more robust constructions for hidden vol-
umes and present HIVE, which is resistant to more powerful ad-
versaries with multiple-snapshot capabilities. In pursuit of this, we
propose the ﬁrst security deﬁnitions for hidden volumes, and prove
HIVE secure under these deﬁnitions. At the core of HIVE, we de-
sign a new write-only Oblivious RAM. We show that, when only
hiding writes, it is possible to achieve ORAM with optimal O(1)
communication complexity and only poly-logarithmic user mem-
ory. This is a signiﬁcant improvement over existing work and an
independently interesting result. We go on to show that our write-
only ORAM is specially equipped to provide hidden volume func-
tionality with low overhead and signiﬁcantly increased security. Fi-
nally, we implement HIVE as a Linux kernel block device to show
both its practicality and usefulness on existing platforms.

1.

INTRODUCTION

Disk encryption is an important security technology that is in-
creasingly being used by individuals and businesses alike. All ma-
jor operating systems now support basic encrypted volumes na-
tively, and both corporations and governments are increasingly man-
dating [5] the use of full disk encryption. Additionally, there are
open source software products, most prominently TrueCrypt [21],
that provide more advanced solutions.

One of the advanced features that TrueCrypt offers is a so-called
“hidden volume”.
Instead of a single encrypted volume, a user
may optionally have two encrypted volumes. These volumes are
encrypted with different keys (derived from passwords), and the
user has the ability to plausibly deny the existence of the second
volume. An adversary, knowing only the password to the ﬁrst vol-
ume, cannot tell for sure whether there exists a second volume, let
alone what its contents may be. Given the widespread use of en-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise,
or republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660313.

crypted disks, this is a very useful feature. If an adversary takes
possession of an encrypted disk, they know that there is at least
some data on that disk. They can then coerce the user to reveal
their password used to encrypt the disk. With a hidden volume, the
user can reveal the password to the ﬁrst volume while withholding
the password for the second. The adversary will not know whether
the second volume exists, and therefore cannot be sure if there even
is a second password for the user to reveal.

TrueCrypt accomplishes this by storing the second, “hidden”
volume inside the free space of the ﬁrst, “main” volume. Since
the semantics of TrueCrypt guarantee that all free space in the en-
crypted volume will be ﬁlled with random data, and the encryption
used is presumed to be indistinguishable from random, an adver-
sary cannot tell if the blocks marked “free” in the main volume
are actually free or if they contain encrypted data that is part of a
hidden volume.

However, as already noticed by Czeskis et al. [3], TrueCrypt’s
approach has a signiﬁcant ﬂaw:
if the adversary has the ability
to take multiple “snapshots” of the hard disk at different times,
they can determine with high probability whether a hidden vol-
ume exists. Since disk encryption is speciﬁcally designed to protect
against scenarios where the user loses control of their device, this
is a major drawback. Requiring that an adversary has access to
the machine and hard disk only one time is in many situations un-
realistic. As a motivating example for why we consider multiple
access to a hard disk a real threat, it is common for users to travel
with their devices and lose direct possession of them on multiply
occasions (checking bags, leaving them in a hotel room, etc.).

Consequently, we design a system whereby a user can plausi-
bly deny the existence of a hidden volume even if the adversary
has been able to take several snapshots of their disk and knows the
password for the main volume. The reason that TrueCrypt does
not maintain security against multiple snapshots is that it makes
no attempt to hide the pattern of accesses that the user makes to
the disk. That, combined with the fact that the hidden volume is
stored separately from the main volume (in the free blocks of the
main volume), gives the adversary a large advantage. An adversary
can compare separate snapshots and see if a large number of “free”
blocks have changed values. This would indicate that they are ac-
tually encrypted blocks that are part of a hidden volume, since they
would otherwise not have a reason to change spontaneously.

These weaknesses lead us to our ﬁrst observation: a system that
is secure against multiple snapshots must make some attempt to
hide the user’s access pattern. There are several ways to do this,
chief among them being Oblivious RAM [6]. We show how ORAM
can be used to create exactly such a solution. Yet, a straightfor-
ward ORAM application comes with a signiﬁcant read/write over-
head. This motivates us to introduce a more efﬁcient ORAM that

203is write-only, but provides sufﬁcient security for our purposes and
has a signiﬁcantly lower overhead than related work. Based upon
this write-only ORAM, we ﬁnally present HIVE, a new scheme for
Hidden Volume Encryption.

The technical highlights of this paper are:
• The ﬁrst formal treatment for hidden volume encryption and
security, including multiple adversarial models. In addition,
we show that several intuitive notions of security against a
strong adversary are impossible to achieve.
• HIVE, a new solution which provides hidden volume encryp-
tion and provably achieves our notions of security using any
write-only ORAM.
• A novel write-only ORAM construction which achieves op-
timal (constant) communication complexity. This result is of
independent interest.
• An implementation of HIVE in the Linux kernel that is prac-
tical. Our implementation realizes hidden volumes as regular
Linux block devices. We evaluate our implementation, and
our benchmarks show that HIVE is both efﬁcient and usable.
The source code is available for download [19].

Plausibly Deniable Encryption: The hidden volume function-
ality offered by HIVE, TrueCrypt, and others [4, 8, 17] is also
called plausibly deniable encryption. Yet, in this paper, we refrain
from using this term, not to confuse it with the slightly different
ideas of deniable encryption by Canetti et al. [2], see Section 7.
Instead, we use hidden volume encryption in this paper.

2. ROBUST HIDDEN VOLUMES

We start by introducing the system and adversary model for hid-
den volume encryption. We envision a typical scenario with a user
U having read/write access to a block storage device, e.g., a hard
disk, USB stick or a network block device. User U is running a
special software for hidden volume encryption. This software gives
access to a sequence of independent volumes Vi that are mapped to
the underlying storage device. To get access to these volumes, U
knows a sequence of passwords P. We stress that each Pi ∈ P
gives full access to hidden Vi, i.e., encryption keys used in Vi are
derived from passwords Pi, and U chooses the Pi carefully. Al-
though passwords have notorious security issues, we simplify the
exposition and assume that each Pi is chosen securely and can be
used to derive a key with at least s bits of entropy, where s is a
security parameter [10].
2.1 Model

One of our main contributions is the ﬁrst formalization for hid-
den volume encryption. A hidden volume encryption scheme Σ
provides an interface to access max volumes. We generalize to
max volumes instead of two for increased ﬂexibility. Each volume
Vi has a password Pi associated with it and holds ni blocks of data,
each of size B. The size of the entire disk is N blocks. For simplic-
ity, both volume blocks and hard disk blocks have the same size B.
Usually, B = 512 Byte, but B can be varied up to 4096 Byte as dis-
cussed later. We do not try to hide the value of max, but rather al-
low the user, U, to choose some number of volumes (cid:96)≤ max which
he will be actively using. It is this choice (cid:96) that will be hidden. Thus
a hidden volume encryption scheme Σ works in such a way that an
adversary, seeing changes to the blocks of a hard disk and knowing
one or more passwords, has some uncertainty about (cid:96). We also as-
sume that the user has t blocks of RAM which are not visible to the
adversary. To avoid the trivial solution of storing everything out of

sight of the adversary, we constrict the size of the RAM to be much
smaller than the size of the disk (i.e., logarithmic in N).

Typically, a hidden volume encryption scheme Σ is embedded
in an operating system. There, it provides the functionality of a
block device driver, yet it resides on top of an underlying (hard-
ware) block device which we now call the disk for simplicity.

DEFINITION 1

(HIDDEN VOLUME ENCRYPTION Σ). Let s
denote the security parameter, t denotes the number of available
RAM blocks, and P =< P1,...,P(cid:96) > denotes the sequence of user
passwords. A hidden volume encryption (HVE) scheme Σ com-
prises the following algorithms.

• HVESetup(s,t,P,B,< n1,...,n(cid:96) >): Using parameters s,
t, the sequence of passwords P, block size B, and the size of
each volume ni, this algorithm generates volumes < V1,...,
V(cid:96),V(cid:96)+1,...,Vmax >.
• HVEWrite(b,d,i,P): Using passwords P, if i≤ (cid:96), then this
algorithm stores data d at block index b in volume Vi, where
Vi was output by HVESetup(s,P).
• HVERead(b, i,P): Using passwords P, if i ≤ (cid:96), then this
algorithm returns data from the block indexed by b in volume
Vi, where Vi was output by HVESetup(s,P).

DEFINITION 2

(SOUNDNESS). Hidden volume encryption scheme

Σ is called sound, iff for any sequence of HVERead and HVEWrite
operations, the last HVEWrite(b,d,i,P) to block b in volume Vi,
i≤ (cid:96), implies d = HVERead(b,i,P).

To allow a scheme Σ to read from and to write to the disk, we
assume availability of regular read and write system calls. In the
rest of this paper, we will use DiskRead(β) to denote a read from
block index β of the disk and DiskWrite(β,d) to denote a write of
data d to block β. Again for simplicity, we assume that a scheme
Σ creates, for each volume, a new virtual block device within the
operating system, which can be formatted with a ﬁle system and
used just like a regular device. Informally speaking, a scheme Σ
has to 1) translate OS reads and writes to one of the block devices
(volumes) into calls of HVERead and HVEWrite, and 2) apply its
logic to ﬁnally use DiskRead(β) and DiskWrite(β). Note that b
denotes the index of a virtual block in one of the volumes, while β
denotes the index of a physical block of the disk.
2.2 Security Deﬁnitions

We now formalize security for hidden volume encryption. To
start, we deﬁne an access o = (op, b, V, d). If op = write, then
this access is a write to block b with value d in volume V , and if
op = read, then this access is a read of block b in volume V which
returns data value d. We call the sequence of accesses O =< o1,
...,on > the access pattern. We also allow o =⊥, which is a “null”
operation that is simply ignored.

Our formalization of different security levels uses standard game-
based deﬁnitions. All games Γ will be played between an adversary
A and a challenger C running a scheme Σ. All games Γ will adhere
to the following generic game. We present the speciﬁc differences
between the games and corresponding levels of security after the
generic game.
In our games, an adversary A is allowed to repeatedly retrieve
snapshots of the disk. We deﬁne a snapshot as the entire contents
of the disk (i.e., addresses and current values of every block), and a
snapshot is meant to represent a dump or capture of the hard drive
from a machine.

The generic game Γgeneric
A,Σ (s), cf. Fig. 1, is deﬁned as:
1. Adversary A chooses (cid:96)≤ max and sends it to C.

204A

chooses (cid:96)≤ max

−−−−−−−−−−−−→

(cid:96)

C

$←−{0,1}
b
∀1≤ i≤ (cid:96),
$←{0,1}s
Pi
Σ0 ← HVESetup(s,< P1,
...,P(cid:96) >)
Σ1 ← HVESetup(s,< P1,
...,P(cid:96)−1 >)

Chooses accesses
O0,1 and O1,1

< P1,...,P(cid:96)−1 >,D0
←−−−−−−−−−−−− D0 = InitialSnapShotΣb
O0,1,O1,1,d1
−−−−−−−−−−−−→

D1 ← ExecuteΣb (Ob,1)

←−−−−−−−−−−−− If d1 = 1, sends D1

D1
···

Let p = poly(s)

Chooses accesses
O0,p and O1,p

O0,p,O1,p,dp
−−−−−−−−−−−−→

Dp ← ExecΣb (Ob,p)
←−−−−−−−−−−−− If dp = 1, sends Dp
The outcome of this game is 1, iff b = b(cid:48), and 0 otherwise.

Ds

A outputs b(cid:48)

Figure 1: Security Game Γgeneric

A,Σ (s)

depending on bit b.

2. Using security parameter s, C chooses (cid:96) passwords and a ran-
dom bit b. C initializes two different hidden volume encryp-
tion schemes: Σ0 (with (cid:96) passwords) and Σ1 (with (cid:96) − 1
passwords). Finally, C sends passwords < P1,...,P(cid:96)−1 > and
an initial snapshot D0 of the disk to A.
3. A chooses two accesses and sends them to C, along with a
bit d that speciﬁes whether A would like a snapshot of the
disk after execution. Both the access patterns and bit d will
adhere to speciﬁc restrictions that we detail below.
4. Following scheme Σb, C “executes” one of the two accesses,
5. If d = 1, C sends a snapshot Di of the disk to A.
6. Repeat steps 3 to 5 for p = poly(s) times (rounds i). Oi,j
7. A outputs bit b(cid:48). The outcome of Γgeneric
A,Σ (s) is 1, iff b(cid:48) = b.
From this general game, we develop two axes along which we
can deﬁne varying levels of security: 1) the frequency with which
A can access snapshots of the disk (regulating when and how often
di can be 1 in our game above), and 2) the restriction applied to the
two access patterns O0,O1 that A chooses and submits to C. We de-
note by Γx,yA,Σ(s) a game that follows generic game Γgeneric
A,Σ (s), but
implies restrictions “x” (deﬁned below) on the frequency of snap-
shots and restrictions “y” (deﬁned below) on the access patterns.

denotes access j∈{0,1} in round i, 1≤ i≤ poly(s). E

DEFINITION 3

(HIDDEN VOLUME ENCRYPTION). A hidden
volume encryption scheme Σ is secure regarding restrictions (x,y),
iff for any probabilistic polynomial time adversary A there exists a
function (s) that is negligible in security parameter s, such that

P r[Γx,yA,Σ(s) = 1]≤ 1
2

+(s).

In conclusion, the rationale behind this game-based deﬁnition is
to prevent adversary A from successfully guessing whether there
exist (cid:96) − 1 or (cid:96) volumes in use, even when A is able to choose
(cid:96). We allow A to specify two patterns O0, O1, similar to classic

Restricted

Table 1: Different Notions for Hidden Volume Encryption
Plausible
Hiding
HIVE
HIVE

Hiding
HIVE-B
HIVE-B

Impossible
Reencryption

Opportunistic

Hiding

TrueCrypt, HIVE

TrueCrypt, HIVE

TrueCrypt, HIVE

Arbitrary
On-Event
One-Time

indistinguishability proofs, which allows us to capture a stronger
chosen plaintext adversary. The restrictions we place on these ac-
cess patterns will lead to an intuitive understanding of the security
our scheme provides.
2.2.1
We consider three different adversarial capabilities in terms of

Snapshot Frequency

snapshotting:

1. Arbitrary ΓArbitrary,(·)

A,Σ

: A can obtain snapshots after every

operation to the disk (any number of di can be 1).

A,Σ

2. On-Event ΓOn−Event,(·)

: A can obtain snapshots after U has
run an “unmount” operation. We represent this by having an
additional function Unmount which is called after Execute,
whenever di = 1, to generate the snapshot.

3. One-Time ΓOne−Time,(·)

A,Σ

: A can obtain only a single snap-

shot (di = 1 for only a single value of i).

Our justiﬁcation for also considering an “on-event” adversary is
that, in reality, some adversaries will not have the capability to take
arbitrary snapshots of the disk while it is in use. More likely, the
machine will be conﬁscated or compromised while U does not have
the hidden volume mounted. Therefore, a model where the adver-
sary can only take snapshots after an “unmount” is interesting.
2.2.2 Access Pattern Choice
An important part of our formal security is allowing the adver-
sary to choose some part of the access pattern. This represents the
fact that, in reality, an adversary may have partial knowledge of
U’s access pattern. Informally, allowing adversary A to choose the
access pattern will guarantee that no matter what a priori knowl-
edge A might have, they still cannot learn the secret we are trying
to protect (i.e., whether there is a volume still unrevealed). To for-
malize this, we allow A to choose a value (cid:96), between 1 and max
which represents the number of volumes in use by U. To maintain
some uncertainty about exactly how many volumes are actually be-
ing used, we then allow A to also choose two access patterns, one
which includes accesses to volume (cid:96) and one which does not.

We stress that restrictions on access pattern choices are manda-
tory to prevent “trivial” impossibility. For instance, in our model
A will get the passwords for all volumes up to V(cid:96)−1. If the two
patterns contain different writes to these volumes, then the result-
ing snapshots will allow A to distinguish between them easily (i.e.,
he simply decrypts these volumes and checks which values were
written). This is to be expected, since the point of hidden volume
encryption is to protect accesses to the secret volumes which may
or may not exist, from the adversary’s perspective. Once a pass-
word is given up, we cannot hide the contents any longer.

Therefore, the ﬁrst restriction which must exist for all of our def-
initions is that any access where both patterns write to a volume V1
through V(cid:96)−1 must contain identical writes in both patterns chosen
by adversary A.

We now present three settings, along with a justiﬁcation for why
they are useful analogues for the real world. The restrictions in each
settings are presented as A being able to choose an access pattern

205.

O0 and then a second pattern O1 that must constrain to some re-
strictions based on O0. Intuitively, the restrictions on O0 govern
which types of access patterns are protected, and the restrictions on
O1 express the level of security that is achieved.
Restricted Hiding: Γ(·),Restricted
The ﬁrst setting we consider is the most straightforward: in each
round, we allow A to choose any access pattern O0 =< o0,1,...,
o1,n >. As stated before, if access o0,i is a write in volume Vj,
j ≤ (cid:96)− 1, then access o1,i in pattern O1 must be equal to o0,i. If
o0,i is in V(cid:96), then o1,i must be ⊥ (the null operation, it is simply
ignored by C). The access pattern executed when b = 1 is then the
same as when b = 0, with all accesses to V(cid:96) ignored by C.

A,Σ

Since the difference between O0 and O1 is only the removal of
all accesses to V(cid:96), a Restricted Hiding scheme effectively prevents
an adversary from distinguishing between the case where a user
uses (cid:96) volumes and the case where a user only uses (cid:96)−1 volumes,
with no restriction on the user’s access pattern. This means that a
scheme with Restricted Hiding would be the ideal system, since
it would protect any access pattern and an adversary would not be
able to learn whether there are (cid:96) or (cid:96)−1 volumes in use. Unfortu-
nately, this level of security is difﬁcult to achieve.

A,Σ

LEMMA 1. Let n∗ be the number of blocks of volume V(cid:96). There
-secure and requires less

is no scheme Σ that is ΓArbitrary,Restricted
than n∗ blocks of RAM.

PROOF (COUNTEREXAMPLE). A submits two access patterns
of length n∗, O0 and O1, where O0,i = (write,i,(cid:96),ri), O1,i = ⊥
$←− {0,1}B. In case A observes changes to the disk, A out-
and ri
puts 1. Otherwise, A outputs 0. If C executes O1, nothing on the
disk will change because ⊥ operations are ignored. If C executes
O0, then either the disk must change or C must have at least n∗
blocks or RAM to hold all the writes from O0.

This essentially means that against an adversary with Arbitrary
snapshotting capability you can do no better than storing all the
hidden volumes in RAM, which is quite unrealistic.

A,Σ

Although none of this paper’s solutions are directly targeted at
On-Event security, we include it in our deﬁnitions because it is
a distinctly separate adversarial model from Arbitrary and One-
Time. It has at least one interesting property: even though it is
impossible to achieve ΓArbitrary,Restricted
security, it is quite simple
(albeit inefﬁcient) to obtain ΓOn−Event,Restricted
security. If a True-
Crypt-like approach is taken except, upon unmount, every data
block is reencrypted and every empty block is ﬁlled with a uni-
formly random string, we achieve this security. This is highly in-
efﬁcient, but we point it out as an interesting observation on our
various adversarial models and possible motivation for more efﬁ-
cient solutions in the future.
Opportunistic Hiding: Γ(·),Opportunistic

A,Σ

.

The second setting we consider, opportunistic hiding, is similar
to restricted hiding, but with a slightly more speciﬁc access pat-
tern: again, if o0,i is in volume Vj, j ≤ (cid:96) − 1, then o1,i must be
equal to o0,i. Also, if o0,i is in V(cid:96), then o1,i will be ⊥. The addi-
tional restriction is that between snapshots, every write to a volume
V2 through V(cid:96) in O0 must have a corresponding read to volume V1
which occurs after it. More formally, the additional restriction says
that for O0 = (o1,...,on), there must exist a one-to-one mapping
f : [1...n] → [1...n] such that if O0,i is a write to a volume higher
than V1, then f (i) > i, O0,f (i) is a read from volume V1.

What this effectively means is that the system will hide writes
to volumes higher than V1 by executing them simultaneously with

A,Σ

A,Σ

reads to V1. This reﬂects the idea that, if we make execution of
reads and writes similar, there will be extra capacity during a read
to simultaneously do a write. We believe this that is not a very
onerous constraint, because it is very reasonable that the “secret”
volumes will be accessed much less frequently than the lowest vol-
ume, which is known to exist to the adversary.

This security deﬁnition also provides “complete” security to the
user, in that an adversary should not be able to distinguish whether
there are (cid:96)− 1 or (cid:96) volumes. In that way, it is similar to our ﬁrst
deﬁnition, however, in order for the user to receive this security, it
requires that the access pattern O0 must have fewer accesses to V2
through V(cid:96) than V1. In practice this means that the user must access
volume V1 more often than the other, more secret volumes.
Plausible Hiding: Γ(·),Plausible

.

Finally, we consider an even more restricted setting where writes
to V(cid:96) can be plausibly denied as operations to the other volumes V1,
...,V(cid:96)−1. A may choose any access O0,i. Again, if O0,i is a write
in volume Vj,j≤ (cid:96)−1, then o1,i must be equal to O0,i. Otherwise,
we only require that neither pattern contains ⊥ operations (so their
“true” lengths are equal).

The intuition of this security deﬁnition is that, if an access pat-
tern contains writes to V(cid:96), there is always a plausible access pattern
containing only accesses to V1 through V(cid:96)−1 (with writes to V(cid:96)
replaced by reads to other volumes) which would have produced
the same sequence of disk operations. Therefore an adversary can
never be sure of the existence of V(cid:96). Additionally, all writes to V(cid:96)
will be indistinguishable from each other. In contrast with the pre-
vious two deﬁnitions, we have restrictions on O1 beyond that the
accesses to lower volumes must be equal.

Finally, Table 1 summarizes our two orthogonal axes of hid-
den volume encryption. Our new scheme, HIVE, provides plau-
sible hiding with arbitrary snapshots. A variant of HIVE, HIVE-B,
provides opportunistic hiding with arbitrary snapshots (as well as
weaker notions). TrueCrypt and other related work [1, 4, 8, 13, 17,
21] only provide security against one-time snapshots [3]. Addition-
ally, as noted above, one can achieve on-event, restricted security
with an expensive reencryption technique. Note that Arbitrary ⇒
On-Event⇒ One-Time, and Restricted⇒ Opportunistic.

We would like to stress that any hidden volumes scheme needs
additional requirements to maintain security. For example, the OS
and applications should not keep any trace of previously mounted
hidden volumes, e.g. in a “recently opened documents” list. For a
detailed discussion, we refer to Czeskis et al. [3] and [20].

3. GENERIC HIDDEN

VOLUME ENCRYPTION

Current hidden volume encryption solution only protect against
One−Time adversaries. We now present a ﬁrst “generic” proto-
col, using Oblivious RAM as a building block, that offers stronger,
more robust security against One-Time and Arbitrary adversaries.

3.1 ORAM Preliminaries

An ORAM provides three operations: ORAMSetup(n, B, k, s),
ORAMRead(i), and ORAMWrite(i, d). It is a block-based data
structure storing n blocks of size B bits, each indexed by a log2n
bit integer, using a key κ for encryption, and s is the security param-
eter. This data structure is backed by a simple key-value store. As
shorthand, we write Execute(O) to be the reads and writes induced
on the underlying data store by the ORAM executing an access pat-
tern O. We refer to the large body of related work for more details,

206e.g., seminal work by Goldreich and Ostrovsky [6] or recently Shi
et al. [16] or Stefanov et al. [18].

DEFINITION 4

(ORAM SECURITY). An ORAM is secure iff,
for any probabilistic polynomial time adversary A and any two ac-
cess patterns O0 and O1 of the same length there exists a function
 negligible in security parameter s, such that
|P r[A(Execute(O0)) = 1]−P r[A(Execute(O1)) = 1]|≤ (s).

We note that, although this is the classic deﬁnition of ORAM se-
curity, it does not capture an adaptive adversary like we need in our
setting. Fortunately, although it is not discussed in related work, all
major ORAM constructions are adaptively secure. To obtain such
a security deﬁnition, we simply allow A to choose the operations
in O0 and O1 one at a time after receiving the results of Execute
being called on the previous operation.

The goal of our ﬁrst, “generic” hidden volume encryption is two-
fold: to hide the pattern of writes issued by the user and to give a
plausible reason to access the disk when writing into hidden vol-
umes. Broadly, we accomplish the ﬁrst by using ORAM and the
second by making a read to a volume cause a “dummy write”. This
dummy will cover for a write to a hidden volume, and is in line
with the idea that all operations should “look the same” regardless
of which volume it is in, or even if it is a read or write.
3.2 Generic Construction

To start, we use max separate ORAMs (ORAM1≤i≤max), each
holding the data for a single volume and encrypted with its own
password, e.g., we simply run ORAMSetup for each of these ORAMs.
The only requirement we have on our ORAM scheme is that it be
efﬁciently simulatable, i.e., a simulator S, without the password
or any knowledge of the access pattern beyond its length can out-
put a series of disk accesses which are indistinguishable from those
output by an actual ORAM. Additionally, this simulator needs to
be stateless, in that its output for each operation cannot depend
on anything other than the output from the previous operations.
Fortunately, typical ORAM constructions meet this deﬁnition. So,
for j > (cid:96), ORAMj is replaced by a simulator S. Therewith, an
ORAM can execute a “dummy” operation containing no informa-
tion, which, to all adversaries, looks identical to a real operation.
This is necessary so that the ORAMs not actually in use by the user
will not even have keys that could be revealed to the adversary.
This gives the user deniability, since they can reasonably claim that
no key exists for a certain volume.
When the system executes a write to volume i (Algorithm 2), it
executes that write on ORAMi. For all j (cid:54)= i, it picks a random
block in Vj and writes its same data value back to ORAMj, i.e., a
“dummy” operation which changes no data. When the system exe-
cutes a read (Algorithm 3), it reads from the respective ORAM and
then does a dummy write for all ORAMs (or executes the simulator,
for volumes greater than (cid:96)). The idea is that, if an adversary does
not have a key to volume i, they cannot tell whether we are reading
from some volume (maybe i, but maybe not) or writing to volume
i. For the internal encryption and decryption within ORAMi, we
use password Pi as the key.

THEOREM 1. If (ORAMSetup, ORAMRead, ORAMWrite) is
a simulatable ORAM, then our generic hidden volume encryption
is a ΓArbitrary,Plausible

-secure hidden volume encryption.

A,Σ

PROOF. Under Plausible Hiding security, the access patterns
given by A will differ only when neither O0,i nor O1,i is a write to
a volume less than (cid:96). Since A cannot distinguish on operations of
the access patterns that are identical, we only need to show that, for

Input: Security parameter s, RAM size

t, passwords P, block size B, volumes sizes < n1,...,n(cid:96) >

Output: Volumes < V1,...,V(cid:96),V(cid:96)+1,...,Vmax >

1 largestVolume := maximum(n1,...,n(cid:96));
2 for i := 1 to max do
3
4
5 end

Vi := ORAMSetup(largestVolume,B,Pi,s);
return < V1,...,Vmax >;

Algorithm 1: Generic HVESetup(s,t,P,B,< n1,...,n(cid:96) >)
Input: Block b, data d, volume index i, passwords P
1 forall the j do
2
3
4
5

ORAMj.ORAMWrite(b,d);

if j = i then

end
else

$←{1,...,sizeof(ORAMj )};
r
// Using password Pj as key
dummy := ORAMj .ORAMRead(r);
ORAMj .ORAMWrite(r,dummy);

6

7
8
9
10 end

end

Algorithm 2: Generic HVEWrite(b,d,i,P)

Input: Block index b, volume i, passwords P
Output: Data d
1 d := ORAMi.ORAMRead(b);
2 forall the i do
3

$←{1,...,sizeof(ORAMi)};
r
// Using password Pi as key
dummy := ORAMi.ORAMRead(r);
ORAMi.ORAMWrite(r,dummy);

4
5
6 end
7 return d;

Algorithm 3: Generic HVERead(b,i,P)

operations that differ, A cannot distinguish. So, if O0,i and O1,i
differ, then they can each be either a read to any volume or a write
to a volume j≥ (cid:96). By the security deﬁnition of ORAM, a “dummy”
write in a volume j ≥ (cid:96) is not distinguishable from an actual write
with probability greater than 1/2+(s). This implies that a read to
one of these volumes cannot be distinguished from a write. We also
have that for all i,j, a read to Vi is indistinguishable from a read
to Vj. Therefore, since A cannot distinguish between the outputs
with probability greater than 1/2+(s), they cannot win the game
with any non-negligible advantage.
3.3 Opportunistic Hiding Security

Opportunistic security gives more freedom to the user, since it
does not require them to “pretend” that they did some reads that
were actually writes in other volumes. Thus, it is relatively sim-
ple to achieve. Instead of writing a block immediately when the
user wants to, if it is part of a volume Vi, i > 1, we add it to a
queue Qi. Every time the user does an operation on V1 (read or
write), for all i > 1 if Qi is not empty, we write one block from
Qi to Vi, instead of doing the dummy write. Reads to volumes
other than V1 are trivial, i.e., we read the requested block, but do
not change anything on the disk. Writing during such a reads is no
longer necessary, because writes to all volumes higher than V1 are
simultaneously hidden by accesses to V1.

THEOREM 2. If (ORAMSetup, ORAMRead, ORAMWrite) is
a simulatable ORAM, then this modiﬁed generic hidden volume
encryption is ΓArbitrary,Opportunistic

-secure.

A,Σ

PROOF. O0 and O1 are only different when O0,i is an operation
in V(cid:96). If O0,i is a read, it will be identical to a ⊥ operation in our
modiﬁed generic scheme. Such a read does not trigger any write. If
O0,i is a write, it equally triggers no writes, as it just adds a block to
the Q(cid:96), and again is indistinguishable. Therefore, we only need to

207show that a read to V1 which also writes from Q(cid:96) is indistinguish-
able from one which just causes a dummy operation in V(cid:96). This
follows directly from the security of our ORAM, and so A cannot
win the game with any non-negligible advantage.

4. WRITE-ONLY ORAM

We have proven a generic hidden volume encryption secure us-
ing ORAM as a building block. Note, however, that the snapshots
A gets in our security game do not include any information about
block reads that occur to the disk. This reﬂects the idea that an ad-
versary can see the impact of block writes, in the form of modiﬁed
data, but they cannot see where or how often user U reads. Typ-
ically, block reads do not leave any discernible trace on the disk.
This means that the ORAMs we are using are actually more pow-
erful than we need them to be. In fact, an ORAM which only hides
writes to the disk is sufﬁcient. We can deﬁne the security of such a
write-only ORAM as follows:

DEFINITION 5

(WRITE-ONLY ORAM SECURITY). Let sequence

ExecW(O) be the sequence of writes caused to the disk when an
ORAM executes access pattern O. A write-only ORAM (with algo-
rithms ORAMSetup,ORAMRead,ORAMWrite) is secure iff, for
any probabilistic polynomial time adversary A and any two access
patterns O0 and O1 that contain the same number of writes there
exists a function  negligible in security parameter s, such that
|P r[A(ExecW(O0)) = 1]−P r[A(ExecW(O1)) = 1]|≤ (s).
There has been limited work on write-only ORAMs until now.
There are several schemes by Li and Datta [11], but they all have
signiﬁcant drawbacks. They are able to obtain an amortized write
communication complexity of O(B· logn), but only at the cost of
reads being in O(B · n). As ORAM communication complexities
directly relate to the hidden volume encryption overhead, this does
not suit our needs. Applications might perform as many reads as
writes, and reads would quickly become too expensive for increas-
ing n. For efﬁcient reads, Li and Datta [11] require either memory
or communication complexity to be polynomial in n. We stress that
their schemes only provide amortized complexity guarantees, with
worst-case complexity being polynomial in n.

Since we target good read and write performance for our hidden
volume encryption to be useful, we now present a new write-only
ORAM which achieves worst-case constant communication com-
plexity and only poly-logarithmic memory requirements. We will
start with a very simple, inefﬁcient construction and show how its
shortcomings can be addressed one at a time until we have our ﬁnal,
efﬁcient construction HIVE.
4.1 Basic Write-Only ORAM Construction

We now present our new ORAM that only supports write opera-
tions. Our ORAM makes use of a mapping data structure Map that
maps blocks from the ORAM to physical blocks (sectors) on the
disk. For now, we will consider it as an associative array such that
Map[b] contains the physical address β on the disk where ORAM
block b is currently located. Later, we will show how this map is
structured and actually implemented, but for now assume that it is
simply stored in RAM and can be efﬁciently accessed. Also as-
sume that the hard disk has at least twice the size of the ORAM,
i.e., N ≥ 2· n, so we have at least twice as much storage available
as needed. All mapping entries Map[b] are set to ⊥. For encryp-
tion and decryption, we employ any pair Enc, Dec of algorithms
realizing IND$-CPA encryption [15]. An IND$-CPA encryption is
an encryption that produces ciphertexts indistinguishable from ran-

$←{1,...,N}∧1≤ i≤ k∧∀u,v : βu (cid:54)= βv holds;

Input: Block index b, data d

1 S :=< βi >,
such that βi
$←S, such that β is free;
2 β
3 DiskWrite(β,Encκ(d));
4 ReencryptOrRandomize(S\β);
// Find out which block

in the Map ORAM has the address we want

logN (cid:99) ;

5 M :=(cid:98) B
6 mapblock := Map.ORAMRead((cid:98) b
// Retrieve the address from the map block

M (cid:99)) ;

7 mapblock[b modM ] := β ;
8 Map.ORAMWrite((cid:98) b

M (cid:99), mapblock);

Algorithm 4: ORAMWrite(b,d)

Input: Block index b

logN (cid:99) ;

1 M :=(cid:98) B
2 mapblock := Map.ORAMRead((cid:98) b
3 β := mapblock[b modM ] ;
4 return Decκ(DiskRead(β));

M (cid:99)) ;

Algorithm 5: ORAMRead(b)

dom strings, e.g., AES in CBC or counter mode. The encryption
makes use of secret key κ, only known to the ORAM user U.
ORAMWrite: For an ORAMWrite(b,d) operation (see Algo-
rithm 4), U picks a sequence S of k random, distinct hard disk
block indices βi, where k is a security parameter. U then ran-
domly picks one index β ∈ S that is “free”. Here, free means
that there is no block in the ORAM that is mapped to disk block
β. User U writes Encκ(d) at position β to disk. Of the k − 1
remaining block indices, if their corresponding blocks contain en-
crypted data, U reencrypts their contents, and if the blocks are free
U writes a random strings into them (“ReencryptOrRandomize”).
Finally, U updates the mapping for b. Since U picks the k block in-
dices in S randomly and independently from b, and the encryption
produces ciphertexts indistinguishable from random, an adversary
seeing these k blocks change cannot learn anything about b or d.

ORAMRead: Our ORAM does not aim at protecting read oper-

ations. Thus, reads are trivial as shown in Algorithm 5.

ORAMSetup: For initialization, we require only that the map
looking up the address of
be initialized to an “empty” state, e.g.
any block should return a ⊥ value indicating that the block has not
been written in the system yet.
Choice of k: To guarantee that U always ﬁnds at least one free
block in S to put data d into, U has to choose k sufﬁciently large.
Since at least half the disk is empty, the probability that any ran-
domly chosen block is free is at least 1/2. Let X be the random
variable that, when selecting k blocks uniformly from all N, de-
scribes the number of blocks among those k that are free. As N is
typically large compared to k, we approximate the hypergeometri-
cally distributed X with a binomial distributed X. P r[X ≥ 1] =
N )k = 1−2−k for N = 2·n. Therefore,
if we set k equal to our security parameter s, the probability of not
ﬁnding at least one free block for any single write will be negligi-
ble small in s with 2−s. Setting N to twice n will “only” double
storage requirements, but leads to high efﬁciency and practicality
as we will show in Section 4.2.

1−P r[X = 0]≈ 1−(cid:0) k

(cid:1)·( n

Free Blocks: A remaining detail is how to determine which
physical blocks β on the disk are actually “free”, so no block b
of the ORAM maps to them. The challenge is to do this in an
efﬁcient way in order to keep a low complexity. A simple so-
lution is a reverse mapping that tags each block β on the disk
with the index for the ORAM block that maps to it. For an op-
eration ORAMWrite(b,d), what U actually writes to disk block β

0

208is Encκ(d)||Encκ(b). Then, when U needs to determine if a disk
block β is free, U decrypts β’s content to restore ORAM address
b and checks if Map[b] = β. If that condition is not true, then it
means that β is an “old” version of ORAM block b, so β is free,
and it can be safely overwritten. Consequently, U can therewith
check if a block is free in constant time.
In practice, we cannot write the two ciphertexts Encκ(d)||Encκ(b)
into a single block of size B, as |d| = B already. Also, for each
IND$-CPA encryption, we need to store random coins such as an
IV or counter. Consequently, we write the ciphertext of Encκ(d)
into block β, and we write Encκ(b) and the encryptions’ random
coins into another metadata block β(cid:48). One can imagine that, in
addition to the N hard disk blocks for the write-only ORAM, we
need additional N blocks for metadata. Each time an ORAM block
β is written to disk, the corresponding metadata block β(cid:48) is also up-
dated. As the mapping between an ORAM block and its metadata
block is ﬁxed, this does not have any consequences for security.
A straightforward optimization of this idea is to store multiple IVs
and multiple Encκ(b) for multiple ORAM blocks in a single meta-
data block β(cid:48), as typically |IV |+|Encκ(b)| < B.
In conclusion, U writes a block b into one of the k blocks from
S chosen randomly and thus independently of b, updating Map ac-
cordingly. Since k is a security parameter independent from n, we
only need to actually write a constant O(1) number of blocks to
disk for each ORAM write operation. Still, our write-only ORAM
has two drawbacks: ﬁrst, it requires us to access a large number of
blocks per operation (k is, for example, 64), and second, it requires
O(B·n·logN ) memory complexity to store the Map.

We now move on to optimizing our initial write-only ORAM to

allow for smaller k and for efﬁcient storage of the map.

4.2 Stash-Optimized Write-Only ORAM
We have set k to be equal to a security parameter s. This is to
ensure that with probability 1 − 2s U will choose a free block to
write new data into on every write operation. It turns out that this is
quite wasteful, because in expectation, U will ﬁnd s/2 free blocks
per operation – many more than are necessary. We only have to set
k so high to avoid a potential worst-case situation where U does
not ﬁnd any free blocks.

We now exploit that fact that typically there will be many more
blocks free than just one. We set k such that in expectation we will
have one (or slightly more than one) free blocks, e.g., by setting k
to only 4. The intuition is that in that case, there will be many times
where U does not ﬁnd a free block, but there will even more times
when U ﬁnds more than one free block. We can take advantage of
this situation by having a small stash of pending blocks in memory.
If U chooses k blocks, and none of them are free, then U puts the
block to be written at that time in the stash, to be written later. If
U ends up with more than one free block during a write, then U
additionally writes out some extra blocks from the stash. Note that
this idea and its analysis is different from the one by Stefanov et al.
[18], where a stash is used in case one of the bucket ORAMs is full.
The ﬁrst challenge is to bound the size of the stash, such that we
do not overburden user U’s memory, but still have high probabil-
ity of the stash not overﬂowing. To determine the stash’s size, we
use a standard queueing argument. Our stash can be modeled as
a D/M/1 queue with deterministic arrival rate γ = 1 and service
times exponentially distributed with rate parameter µ = k/2. As
shown by Jansson [9], we can then express the steady state proba-
bility P of having i items in the stash at any time as P = (1−δ)·δi,
where δ is the root of the equation δ = 2−µγ(1−δ) with the smallest
absolute value. If µ is larger than 1, then δ < 1, and the steady state
probability of having i blocks in the stash will be O(2−i). That

means that the size of the stash will be O(B·s) with probability all
but negligible in s.

This optimization allows us a huge savings in performance. We
can go from k = s to k being a small constant, independent of the
security parameter. For example, if k = 3, we can solve to ﬁnd δ =
0.41718, and we can bound the probability of overﬂowing the stash
at 2−64 using only a stash of size 50 blocks. With a block/sector
size of 4096 Byte, the stash would consume only 200 KByte RAM.
Security: The actual writing that U performs to the k blocks of
S is hidden by the security of the IND$-CPA encryption. There-
fore, whether U writes one, two, or no blocks from the stash on any
given operation is not observable by the adversary. Consequently,
the stash does not impact security at all.

4.3 Recursive map

As we have described our write-only ORAM thus far, we have
good communication complexity, but at the cost of a large map that
must be kept in memory. The total size of the map will be O(B·n·
logN ), prohibitively large if we hope to store it in memory. How-
ever, we can use a standard technique [11, 12, 16] which is to recur-
sively store the map in smaller and smaller ORAMs. If our block
size B is at least χ·logN for some constant χ > 2, then we are guar-
anteed that if we (recursively) store our map in another ORAM, that
ORAM in turn will have a map that is no greater than half the size of
the original map. Therefore, after O(logn) recursive ORAMs, we
will have a map that is constant size and can be stored in memory.
This reduces the map to a much more comfortable size, but at
the expensive of increasing the communication complexity: now,
to access the map, we have to, in turn, access O(log n) recursive
ORAMs. This will also slightly impact our stash analysis, since the
ORAMs that hold the map do not have deterministic arrival rates,
since their arrivals are in fact the result of service on the above
queue. Fortunately, we can model them as M/M/1 queues with
expected arrival rate equal to 1 which still results in exponentially
distributed stationary probabilities [7], and we end up with the same
O(logn) bound on the size.

As seen in algorithms 5 and 4, we can then simply treat the
map for each level as another ORAM and issue ORAMRead and
ORAMWrite calls as necessary. Each level is unaware of how the
next level structures itself, only that it provides an interface to read
and write, and that it can do so securely. However, we cannot treat
the map as a simple associative array now because the recursive
ORAM will need to store more than one address per block in or-
der to guarantee that we have only O(log n) levels of recursion.
Therefore, to read an entry from the map, we have to calculate
logN (cid:99), the number of entries we can ﬁt per block, then ﬁg-
N = (cid:98) B
ure out which block the entry we want will be in. For instance, if
we want the address for block i, we would get block (cid:98) i
n(cid:99) from the
map, and read the i modNth entry from it.

4.4 Write Complexity
For each ORAMWrite operation, our write-only ORAM reads k
random blocks, checks if they are empty, ﬁlls from zero to k−1 of
them with blocks from our stash, and updates the map accordingly.
The initial reading of the k blocks from the map (and hence
checking if a block is empty) requires reading one block from each
of log n recursive levels. Therefore, we can accomplish that ﬁrst
step with k · O(B · log n) = O(B · log n) communication com-
plexity. However, when we then write to the map, each recursive
ORAM has to, itself, read from all the recursive ORAMs “below” it
in order to read its own map. Thus, these writes costs O(B·log2n),
bringing the total complexity for an ORAMWrite to O(B·log2n).

209This overhead would be disappointing, as there are several full-
functionality (read and write) ORAMs which provide the same over-
head. However inspired by Stefanov et al. [18], we can use the
following optimization to reduce the cost of the expensive map ac-
cesses. If we set the size of only the data blocks on our disk to
B = Ω(log2n), the total size of logn blocks in the recursive map is
no greater than the size of one B-sized data block at the “top level”.
What we end up with is non-uniform block sizes: top level blocks
(actual data blocks) have size Ω(log2n), and blocks that are part of
the map have only size χlogn for some constant χ≥ 2. We are still
guaranteed that the map will have O(logn) levels, but we reduce
the communication complexity of a map operation by a factor of
O(log n). Consequently, in terms of communication complexity,
reading from the map is constant in O(B), and updating/writing is
in O(B·logn). We can apply the same optimization again, as long
as B = Ω(log3n). In terms of communication for an ORAMWrite,
we reduce total complexity to O(B).
In conclusion, our write-only ORAM features O(B·s) memory

and constant O(B) communication complexity.

4.5 Security Analysis

Security for our scheme follows directly from the fact that we
only write to uniformly randomly chosen blocks at each level of
the ORAM. Since the blocks we choose are independent of the ad-
dresses in the user’s access pattern, they cannot reveal any infor-
mation about it to the adversary. Additionally, all the data we write
is freshly encrypted with a semantically secure encryption, so the
data itself cannot reveal any information.

Simulator: We note in the previous section that, to be useful in
our scheme, an ORAM needs to be (efﬁciently) simulatable. Fortu-
nately, such a simulator S is simple to construct for our scheme. S
proceeds in every operation to change k uniformly random blocks
at each level of the recursion to fresh random strings. Since, in
normal operation of our ORAM, we will access k random blocks
at each level, and those blocks will be ﬁlled with either random
strings or IND$-CPA encryptions indistinguishable from random,
S will be indistinguishable from an actual execution of our ORAM.

5. PRACTICAL HIDDEN VOLUME

ENCRYPTION WITH HIVE

Thus far we have presented a generic hidden volume encryp-
tion scheme which uses a write-only ORAM as a building block
and has constant communication complexity per access. We now
present HIVE that builds upon this idea and makes it practical. We
start by addressing an important consideration that we must take
into account when designing a practical, real-world system.

5.1 Uniform vs. Non-uniform Blocks

Current storage devices, e.g., today’s hard disks, have ﬁxed size
blocks (sectors). This means that we cannot use our non-uniform
block optimization from the previous section, unless we wanted to
use the base device blocks as “small” blocks and combine many of
these blocks together to make “large” blocks. However, most sys-
tems use either 512 or 4096 byte blocks, so there is not much room
for optimizing these parameters.

Fortunately, although we cannot easily obtain optimal O(B) com-
plexity with uniform blocks, our write-only scheme is still sub-
stantially more efﬁcient than the currently most efﬁcient full-functionality
ORAMs, e.g., Path ORAM [18]. In Figure 2, we show the compar-
ative costs for our scheme and Path ORAM for a concrete selection
of parameters (see Appendix A for the recurrence relations used to

Figure 2: Communication cost

Figure 3: Random mapping of blocks from volumes to disk blocks

calculate these numbers). Our write-only ORAM is more than an
order of magnitude more efﬁcient than Path ORAM.

To see why we are more efﬁcient, it is useful to consider the
complexity of our write-only ORAM and Path ORAM in terms of
the level of recursions required to store the map. We denote this
required level of recursion with L. In the uniform block setting,
Path ORAM has O(B·L·logn) communication complexity. Since
L = O(logn), this leads to the overall complexity of O(B·log2n).
Our write-only ORAM, by comparison, has O(B · L2) complex-
ity, with no independent logn factor. Again, since L = O(logn)
our scheme has overall O(B · log2 n) complexity. However, for
L to actually approach the worst-case log n, the block size needs
to be close to 2 · log n. In other words, with 512 byte = 4096 bit
blocks, we would need a disk holding 22056 bytes to approach that
many levels of recursion (4096 = 2 · log n, so n = 22048 blocks,
each of size B = 512 byte. Note that our write-only ORAM wastes
50% of all blocks, though). In contrast, up to 16 TB requires only
L ≤ 3 levels of recursion. However, for that same disk, we have
logn = 35. Therefore, for practical parameter choices, L2 will be
signiﬁcantly smaller than L· logn, resulting in large savings of at
least an order of magnitude.

The “jump” at 16 GByte ORAM size in Figure 2 is due to an

increased level of recursion L required for ORAMs of this size.
5.2 HIVE: Combining Volumes

A signiﬁcant drawback of our generic hidden volume construc-
tion is that it requires a separate ORAM for each volume. This
requires us to do a full operation on each of those ORAMs, result-
ing in a complexity dependent on max. If we make a reasonable
choice, say max = 10, this could be a signiﬁcant overhead. For-
tunately, our ORAM construction is particularly suited to solving
this problem. As we are only actually changing one data block each
operation, independent of the number of volumes (the rest are reen-
cryptions), we can thus combine all of our volumes into one. This
is the main idea of our new scheme HIVE.

 0 20 40 60 80 100 120 140 160 1 10 100 1000Total Communication per Write (KByte)ORAM Size (GByte)k=3, B=4096 Byte, t=10 MByteL=1L=2L=1L=2Path ORAMWrite-Only ORAMVolume 1Volume 2Volume max...block b1. Map[b] = β 2. Map[b] = β' block βblock β'Hard Disk210Overview: HIVE’s approach will be to store all the volumes
randomly interleaved. Then, as shown in Figure 3, after writing to a
block b, we will randomly change b’s mapping Map[b] from β to β(cid:48)
using our write-only ORAM trick. This hides the write pattern for
all volumes. We now present the full procedure for HIVE’s writing
(HVEWrite) in Algorithm 6 and for HIVE’s reading (HVERead)
in Algorithm 7.

HVEWrite: Compared with our original ORAM scheme, there
is only one major change: instead of only modifying one block out
of k given by the indices in S, we now have to potentially mod-
ify all k blocks. To see why, it is useful to consider the following
scenario. Imagine user U wants to write a block into V1. In or-
der to do that, they randomly choose k blocks to form S. If, for
instance, three of these blocks contain data from V2, and one is
empty, we cannot simply write our block from V1 into this empty
space because, after continuously writing “around” blocks in V2, A
could infer its presence by the pattern we make trying to avoid it.
Therefore, in order to be secure, we have to make sure that no pre-
vious writes to a Vj,j > i can inﬂuence a write to Vi. Intuitively, if
operations in higher volumes cannot inﬂuence operations in lower
volumes, then the existence of a higher volume cannot be inferred
from the observed behavior in a lower volume.

This can be accomplished by structuring the stash as a series of
multiple queues (called Stashi in Algorithm 6), one for each vol-
ume Vi. For an HVEWrite, all the blocks in S are read and their
content copied into the respective queues for their volume. A block
on the disk may belong to some volume i, or it may be a random
string not containing any information. To put it into the correct
queue, we have to attempt to decrypt the block with every key until
we ﬁnd the right volume or we run out of keys. This means that our
ciphertexts must contain some redundant information, for decryp-
tion veriﬁcation, but this can easily be accomplished by padding
our plaintexts with a number of zero bits proportional to security
parameter s. Veriﬁcation then consists of decrypting and check-
ing if the plaintext begins with a sufﬁcient number of zeroes. This
meshes with our notion of security, because A, knowing some num-
ber of keys, cannot tell whether a block is part of a volume which
he does not have the key for or if it is simply a random string.
Now, having freed k blocks on the disk, we will write k blocks
back to the positions given by S. For this, we read out of our stash
queues, giving priority to the queues for lower volumes. That is,
we empty the queue Stash1 for V1 ﬁrst, followed by Stash2 for V2,
etc. If there are less than k blocks in all stashes, then the leftover
blocks from S are ﬁlled with random strings.

HVERead: For a HVERead, we read the block just like in our
regular ORAM by querying the recursive map for the address and
then reading that block from the disk. After we retrieve the target
block, we also perform a “dummy” write to make reads and writes
look identical to adversary A. This write does not change any val-
ues in the system, but it gives us a chance to write items from the
stash, if necessary. Note that a block b we want to read in volume
Vi might reside in the stash, so we ﬁrst lookup b in Stashi.

HVESetup: Initialization is identical to our base ORAM, we
simply initialize the map to an “empty” state where every block
starts unmapped.

Complexity: Figure 4, moved together with its recurrence rela-
tions to Appendix A, shows how HIVE is more efﬁcient than the
generic construction using max separate ORAMs. Although HIVE
performs better for a large range of parameters, note that HIVE
scales exponentially in L. Since we have to change up to k blocks at
each level, which in turn requires changing k blocks in all the levels
below them, the overall complexity is O(kL). With max = 10, for
up to 1 Exabyte, HIVE is still cheaper than our generic construction

since it is independent of max. However, with larger volumes and
more levels of recursion, HIVE becomes less practical than our ﬁrst
construction. Therefore, depending on the choice of parameters, it
can be more efﬁcient to use one or the other.

For completeness sake, we note that Path ORAM can also be
modiﬁed to produce a “combined volume” version in a similar
manner (due to its use of a stash), but it would be signiﬁcantly less
efﬁcient than our construction, just as Path ORAM is less efﬁcient
than our write-only ORAM.
Security: Since a block from Vj, j > i is written only if the
queue for Vi is already empty, blocks from Vj cannot inﬂuence A’s
view of Vi. Additionally, since an encryption under Pj is indis-
tinguishable from a random string to A which does not know Pj.
What this means is that A’s view of the disk cannot be impacted by
volumes which he does not have the key to, therefore we achieve
ΓArbitrary,Plausible

A,Σ
HIVE-B: To make HIVE secure against Opportunistic adver-
saries, we can follow the same idea as in Section 4.2. Instead of
immediately writing in volumes Vi, i > 1, we just add the block
to Stashi. When we do operations in V1, we proceed as normal,
writing as much as we can from Stash2,Stash3, etc. We omit full
algorithms and proofs for HIVE-B, because of space constraints,
but they follow immediately from existing descriptions and proofs.
5.3 Discussion

security as before.

We have shown that, under various adversarial models, HIVE
does not give any information about the number of volumes in use,
beyond what is known a priori. Yet, in practice, just the presence of
HIVE on a user’s system is an indication that there might be more
than one volume.

However, we stress that there is a legitimate reason a user would
want to use HIVE with only a single volume: even with a single
volume, HIVE offer stronger security than related work such as
TrueCrypt.
It provides security against multiple snapshot adver-
saries that could deduce information from the user’s access pattern.
For instance, between snapshots adversary A may see a particu-
lar ﬁle has been written that matches the size of a known ﬁle. A
does not need the decryption key then to determine what the ﬁle is.
Therefore, even without the encryption key, signiﬁcant data leak-
age can occur to a multiple snapshot adversary just by observing
patterns of changes.

This gives a plausible reason why a user would be using only a
single volume and hence allows for deniability in the case that they
actually do have hidden volumes.

Since HIVE acts as an Oblivious RAM for each of the volumes,

the user’s access pattern is hidden. Given our new write-only ORAM,
our approach is more efﬁcient than simply using existing ORAMs
not tailored for disk encryption.

6.

IMPLEMENTATION

To show its real-world practicality, we have implemented HIVE
for Linux. Our implementation comprises a kernel module offering
a virtual block device for each volume and a userland tool to man-
age these volumes. The source code is available for download [19].
The kernel module is built using device-mapper, a standard Linux
kernel framework for mapping block devices onto virtual devices,
also used to implement technologies such as LVM, dm-crypt and
software RAID.

Device-mapper allows placing HIVE between the Linux block
IO layer and the underlying device drivers. There, HIVE intercepts
all block IO requests in ﬂight, splits them into single-block-sized
chunks, remaps them to their new physical blocks on the disk, and
performs cryptography operations, as previously described. Note

211Enqueue(Stashi,(b,d)) ;

Input: Block index b, data d, volume i, passwords P
1 if b(cid:54)=⊥ then
2
3 end
4 S :=< βj >,
such that βj
// Fetch blocks from S and put into stashes

$←{1,...,N}∧1≤ j ≤ k∧∀u,v : βu (cid:54)= βv} holds;

5 for u := 1 to k do
6
7

d := DiskRead(S[u]);
if d is block b from volume Vv then
// Derive κv from Pv
d := Decκv (S[u]);
Enqueue(Stashv,(b,d)) ;

end

8
9
10
11 end
12 v := 1 ;
13 for u := 1 to max do
14
15
16
17
18
19 end
20 while v≤ k do

end

if v≤ k∧Stashu (cid:54)=∅ then

(b,d) := DeQueue(Stashv);
DiskWrite(S[v],Encκu (d));
v := v+1;

$←{0,1}B ;
r
DiskWrite(S[v],r);

21
22
23 end
24 M :=(cid:98) B
logN (cid:99) ;
25 for j := 1 to k do

// Let b(cid:48), i(cid:48) be

// Fill remaining

blocks in S with random strings

the block index and volume number of the
block that was written to disk block S[j]

mapblock := Map.Read(i(cid:48),(cid:98) b(cid:48)
mapblock[b(cid:48) modM ] :=Sj ;
Map.HVEWrite(i(cid:48),(cid:98) b(cid:48)

M (cid:99)) ;

M (cid:99), mapblock);

26
27

28
29 end

Algorithm 6: HIVE HVEWrite(b,d,i,P)

Read and return most recent version of block i from Stashi ;

Input: Volume i, block index b

logN (cid:99) ;

1 if block b is in Stashi then
2
3 end
4 M :=(cid:98) B
5 mapblock := Map.Read(i,(cid:98) b
M (cid:99)) ;
6 location := mapblock[b modM ] ;
7 d := DiskRead(location);
8 HVEWrite(⊥,⊥,⊥,⊥);
9 return v

// Do a “dummy” write

Algorithm 7: HIVE HVERead(b,i)

that our implementation works on any block device (e.g., hard disks,
USB sticks, network block devices, etc.) since it stacks on top of
the actual device driver which communicates with hardware.

We use AES-CBC with 256 Bit keys for encryption and PBKDF2
for key derivation. For performance reasons, we generate random-
ness using RC4, using the kernel’s entropy pool only to generate
an initial key for RC4. Our implementation supports up to a 4 KB
logical block size (this limit is imposed by the x86 architecture and
kernel internals), regardless of the underlying hardware’s physical
structure. In our evaluation presented below, we set the block size
B to 4 KB, even though our test device has 512-byte sectors. This
minimizes the number of random disk accesses performed during
IO and results in a signiﬁcant performance improvement. As an-
other performance optimization, our system disables IO reordering
and scheduling in the kernel for the virtual devices, because HIVE

Table 2: HIVE Benchmarks, L = 2, k = 3
Seq. Write Seq. Read Create
(Kﬁles/s)
82.29
1.57

(Kﬁles/s)
201.18
3.23

216.04
0.97

221.74
0.99

(MB/s)

(MB/s)

Stat

Delete
(Kﬁles/s)
105.10
1.79

Raw disk

HIVE

always performs random device access and cannot beneﬁt from ker-
nel’s access pattern anticipation features.

The userland tool allows users to create, mount and unmount
HIVE devices /dev/mapper/HIVEi for volume Vi on top of
any other block device (e.g., /dev/sda). Upon receiving the cre-
ate command, our tool formats the speciﬁed device by creating the
necessary metadata structures, such as the max different Maps,
max stashes of ﬁxed size, IV s and the reverse mappings for data
blocks. Note that our implementation allows for recursion, so it
recursively stores and accesses the Maps of ﬁxed size as described
in Section 4.3. Finally, to mount or unmount these volumes, our
tool issues the appropriate ioctl commands to the kernel’s device-
mapper module.

Benchmarks: We have tested our implementation on a standard
desktop computer with an Intel i7-930 CPU, 9 GB RAM (although
RAM was not an issue during our evaluation), running Arch Linux
x86-64 with kernel 3.13.6. As the underlying block device, we have
used an off-the-shelf Samsung 840 EVO SSD.

For the evaluation, we used bonnie++, a standard disk and ﬁlesys-
tem benchmarking tool. Note that in the face of IO caching by
the OS, ﬁles created in the bonnie++ benchmarks must be set to
twice the size of system memory installed (9 GB in our case) to
reliably measure device performance. To speed up the total bench-
mark time, we modiﬁed bonnie++, ﬂushing IO buffers to the device
after running a benchmark, and signaling the kernel to drop page,
dentry, and inode caches before the next run. This ensured that
our performance measurements remained unaffected from caching.
We have ﬁrst tested an ext4 ﬁlesystem with 4 KB blocks on the
“raw” disk to get a baseline. We then created 2 hidden volumes on
our disk and set L = 2 and k = 3. With this conﬁguration, HIVE
supports volumes of a total size of up to 16 TByte. We repeated the
experiments by running bonnie++ on an ext4 ﬁlesystem created on
top of the HIVE block device. Table 2 presents the results, aver-
aged over 5 runs with a relative standard deviation of < 6%. These
results show that IO operations (sequential writes and reads in MB
per second) were slower by a factor of ≈ 200, while ﬁlesystem
operations (create, stat, and delete in thousands of ﬁles per second)
were slower by a factor of 50 to 60. Random seek performance was
not measurable on the raw SSD (i.e., bonniee++ reported that the
tests completed too quickly to measure reliable timings), whereas
HIVE achieved 1.2 Kseeks/s. The HIVE induced CPU utilization
was low with < 1% during measurements, indicating that random
access IO constitutes the main bottleneck.

We conclude that, while the slowdown is certainly signiﬁcant,
a throughput of 1 MB/s on an off-the-shelf disk is acceptable in
many scenarios, rendering HIVE practical for the real-world. Fu-
ture work is dedicated for additional performance tuning.

7. RELATED WORK

Anderson et al. [1] present StegFS, two different techniques to
hide data on a hard disk. The ﬁrst technique creates a set of “cover
ﬁles” such that any user ﬁle can be reconstructed as a password-
based linear combination of the cover ﬁles. As the security of this
scheme is based on the number of linear combinations possible,
note that knowledge of some user ﬁles jeopardizes secrecy of other
ﬁles. Modiﬁcations to ﬁles with unknown passwords are not deni-

212able in the case of multiple snapshots. Consequently, this technique
offers weaker security than the ones discussed in this paper. The
second technique by Anderson et al. [1] (and its extension [13]) is
based on a simple hash scheme, where an encrypted ﬁle is stored
in the hard disk block indexed by β := h(ﬁle name). To avoid
resulting hash collisions, Pang et al. [14], iterate over the physical
blocks following β, until a free block is found. While this mitigates
the original problem of known ﬁles, none allow deniability against
multiple snapshots, as write access patterns are not protected.

The same holds for prominent disk encryption tools such as True-
Crypt [21], Mobiﬂage [17], FreeOTFE [4], and Rubberhose [8]:
these tools use a ﬁxed mapping between blocks of a volume (“vir-
tual disks”, “aspects”) to hard disk blocks. With access to one vol-
ume, other (hidden) volumes look like free space to adversary A.
Thus, repeated access to the same blocks in the hidden volumes
will be impossible to deny.
The idea of deniable disk encryption originates to work by Canetti
et al. [2]. There, A intercepts ciphertext c = Encpk(m,r) sent from
a sender to a receiver, where pk is the receiver’s public key, m a
(delicate) plaintext, and r a random coin. The goal is that, under
coercition, the sender can present an innocent plaintext, random
coin pair (m(cid:48),r(cid:48)), where m(cid:48)(cid:54)= m, such that c = Encpk(m(cid:48),r(cid:48)).

8. CONCLUSION

In this paper, we have proposed new, parameterized deﬁnitions
of formal security for hidden volume encryption. Existing work
lacks security against strong adversaries with multiple snapshot and
chosen plaintext capabilities. We have proposed new constructions
which meet strong security deﬁnitions using ORAM as a build-
ing block. Observing that strong security can be provided with
less powerful write-only ORAM, we have then introduced a novel
construction of a write-only ORAM which achieves optimal O(1)
communication complexity. This is a surprising result, indicating
that writes are easier to hide than reads. We leave further explo-
ration of this idea to future work. Additionally, we have shown
how our ORAM can be specially adapted to the problem of hid-
den volume encryption to produce an even more efﬁcient solution,
which we dub HIVE. Finally, we have implemented our scheme as
a kernel-level block device and benchmarked its performance on
commodity hardware, achieving a throughput of ≈ 1 MByte/s.
Acknowledgments:
This work was partially supported by NSF grant 1218197.

References
[1] R.J. Anderson, R.M. Needham, and A. Shamir. The Stegano-
graphic File System. In Proceedings of Information Hiding,
pages 73–82, Portland, USA, 1998. ISBN 3-540-65386-4.

[2] R. Canetti, C. Dwork, M. Naor, and R. Ostrovsky. Deniable
In Proceedings of CRYPTO, pages 90–104,

Encryption.
Santa Barbara, USA, 1997. ISBN 3-540-63384-7.

[3] A. Czeskis, D.J. St. Hilaire, K. Koscher, S.D. Gribble,
T. Kohno, and B. Schneier. Defeating Encrypted and De-
niable File Systems: TrueCrypt v5.1a and the Case of the
Tattling OS and Applications. In Proceedings of HotSec, San
Jose, USA, 2008.

[4] S. Dean. FreeOTFE, 2010. Archive available at https://
web.archive.org/web/20130531062457/http:
//freeotfe.org/.

[5] Executive Ofﬁce of the President. Protection of Sensitive
Agency Information, 2006. http://www.whitehouse.

gov/sites/default/files/omb/memoranda/
fy2006/m06-16.pdf.

[6] O. Goldreich and R. Ostrovsky. Software protection and
simulation on oblivious RAMs. Journal of the ACM, 43(3):
431–473, 1996. ISSN 0004-5411.
[7] P.G. Harrison and N.M. Patel.

Performance Modelling
of Communication Networks and Computer Architectures.
Addison-Wesley Longman Publishing Co., Inc., 1992. ISBN
0201544199.

[8] R.P. Weinmann J. Assange and S. Dreyfus.

Rubber-
hose Filesystem, 2001. Archive available at http://
web.archive.org/web/20120716034441/http:
//marutukku.org/.

[9] B. Jansson. Choosing a good appointment system – A study
of queues of the type (D,M,1). Operations Research, 14(2):
292–312, 1966. ISSN 0030-364X.

[10] B. Kaliski.

RFC 2898,

PKCS 5:

Based Cryptography Speciﬁcation Version 2.0,
https://tools.ietf.org/html/rfc2898.

Password-
2000.

[11] L. Li and A. Datta. Write-Only Oblivious RAM based
Privacy-Preserved Access of Outsourced Data, 2013. Cryp-
tology ePrint Archive, https://eprint.iacr.org/
2013/694.

[12] T. Mayberry, E.-O. Blass, and A.H. Chan. Efﬁcient Private
In Pro-
File Retrieval by Combining ORAM and PIR.
ceedings of Annual Network & Distributed System Security
Symposium, pages 1–11, San Diego, USA, 2014.

[13] A.D. McDonald and M.G. Kuhn. StegFS: A Steganographic
In Proceedings of Information
ISBN

File System for Linux.
Hiding, pages 462–477, Dresden, Germany, 1999.
3-540-67182-X.

[14] H.H. Pang, K.-L. Tan, and X. Zhou. StegFS: A stegano-
In International Conference on Data
graphic ﬁle system.
Engineering, pages 657–667, Bangalore, India, 2003. ISBN
0-7803-7665-X.

[15] P. Rogaway. Nonce-Based Symmetric Encryption.

In
Proceedings of Fast Software Encryption, pages 348–358,
Delhi, India, 2004. ISBN 978-3-540-22171-5.

[16] E. Shi, T.-H.H. Chan, E. Stefanov, and M. Li. Oblivious
In Proceedings
RAM with O(log3(N )) Worst-Case Cost.
of Advances in Cryptology – ASIACRYPT, pages 197–214,
Seoul, South Korea, 2011. ISBN 978-3-642-25384-3.

[17] A. Skillen and M. Mannan. On Implementing Deniable
In Proceedings of
Storage Encryption for Mobile Devices.
Annual Network & Distributed System Security Symposium,
San Diego, USA, 2013.

[18] E. Stefanov, M. van Dijk, E. Shi, C. Fletcher, L. Ren,
X. Yu, and S. Devadas. Path ORAM: An Extremely Simple
In Proceedings of Conference
Oblivious RAM Protocol.
on Computer & Communications Security, pages 299–310,
Berlin, Germany, 2013. ISBN 978-1-4503-2477-9.

[19] The Authors.

HIVE Source Code, 2014.

//hive.ccs.neu.edu.

http:

[20] TrueCrypt.

Security Requirements and Precautions,
http://www.truecrypt.org/docs/

2014.
security-requirements-and-precautions.

[21] TrueCrypt. Free open-source on-the-ﬂy encryption, 2014.

http://www.truecrypt.org/.

213(cid:40)0,

APPENDIX
A. RECURRENCE RELATIONS

For Path ORAM, we deﬁne relation A(n) expressing the number
of block operations (reads and writes) which need to be performed
for one ORAM access.

A(n) =

2·k(cid:100)log2n(cid:101)+A((cid:100)

n

B(cid:100)log2n(cid:101) (cid:99)(cid:101)),

(cid:98)

if n≤ t
B
if n > t
B

Access requires that the user retrieve k blocks from each bucket
on a path of a heigh log2n tree, plus retrieval of one block from the
map which is itself stored in an ORAM.
operations using Path ORAM is then max·A( n

For a generic hidden volume construction, the number of block

Similarly, we can deﬁne relations W (n) and R(n) for our write-
only ORAM which express the number of block accesses required
per write and read operation respectively.

max ).


(cid:40)0,

W (n) =

0,
k·R((cid:100)
W ((cid:100)

(cid:98)

n

(cid:98)

B(cid:100)log22n(cid:101) (cid:99)(cid:101))+
B(cid:100)log2 2n(cid:101) (cid:99)(cid:101))+2k,

n

if n≤ t

B

if n > t
B

Writing requires reading and writing k blocks, plus reading k

entries from the recursive map and writing one entry.

R(n) =

1+R((cid:100)

n

B(cid:100)log22n(cid:101) (cid:99)(cid:101)),

(cid:98)

if n≤ t
B
if n > t
B

Reading requires just one block per level of the recursive map.
Again, for a generic hidden volume construction, the number of

block operations using our ORAM is then max·W ( n

max ).

Finally, we deﬁne a similar set of recurrences for HIVE as fol-

lows.



(cid:40)0,

W (n) =

0,
k·R((cid:100)
(cid:98)
k·W ((cid:100)

(cid:98)

n

B(cid:100)log2 2n(cid:101) (cid:99)(cid:101))+
B(cid:100)log22n(cid:101) (cid:99)(cid:101))(cid:101)+2·k,

n

if n≤ t

B

if n > t
B

Writing is the same as above, except now we have to change k

blocks in the recursive map instead of just one.

R(n) =

1+R((cid:100)

n

B(cid:100)log2 2n(cid:101) (cid:99)(cid:101)),

(cid:98)

if n≤ t
B
if n > t
B

However, for this construction the total number of access is just

W (n), since we do not divide the system into separate volumes.

Figure 4: Communication cost, N = 2·(cid:80)max

i=1 ni, Log-Log plot

 1 10 100 1000 10000 1 10 100 1000Total Communication per Write (KByte)Total size of all volumes N (GByte)k=3, max=8, B=4096 Byte, t=10 MByteL=1L=2L=1L=2L=1L=2Path ORAMWrite-Only ORAMHIVE214