Eﬃcient Non-Interactive Zero Knowledge

Arguments for Set Operations(cid:63)

Prastudy Fauzi1, Helger Lipmaa1, and Bingsheng Zhang2

1 University of Tartu, Estonia

2 National and Kapodistrian University of Athens, Greece

Abstract. We propose a non-interactive zero knowledge pairwise multi-
set sum equality test (PMSET) argument in the common reference string
(CRS) model that allows a prover to show that the given committed mul-
tisets Aj for j ∈ {1, 2, 3, 4} satisfy A1 (cid:93) A2 = A3 (cid:93) A4, i.e., every element
is contained in A1 and A2 exactly as many times as in A3 and A4. As
a corollary to the PMSET argument, we present arguments that en-
able to eﬃciently verify the correctness of various (multi)set operations,
for example, that one committed set is the intersection or union of two
other committed sets. The new arguments have constant communication
and veriﬁcation complexity (in group elements and group operations,
respectively), whereas the CRS length and the prover’s computational
complexity are both proportional to the cardinality of the (multi)sets.
We show that one can shorten the CRS length at the cost of a small
increase of the communication and the veriﬁer’s computation.
Keywords. Multisets, non-interactive zero knowledge, set operation ar-
guments.

1

Introduction

One of the most common tasks undertaken to achieve active security (i.e., se-
curity against malicious participants) in various cryptographic protocols is to
construct an eﬃcient zero knowledge proof that the committed (or encrypted)
messages sent by various parties belong to correct sets. For example, some of the
most eﬃcient e-voting protocols [15,17] and e-auction protocols [38] are secure
only if the voters (resp., bidders) have committed to inputs from a certain range.
Because of such reasons, range proofs — where the prover aims to convince the
veriﬁer that the committed message belongs to some public range — have been
widely studied in cryptographic literature. There are many well-known eﬃcient
range proofs, both interactive [9,38,35,10,13] and non-interactive [42,14,21].

However, in many applications it is not suﬃcient to prove that the inputs
belong to a continuous range, since the valid input set may be an arbitrary
(polynomial-size) set of integers. Moreover, often the same party has to com-
mit to related inputs many times, and the whole protocol is secure only if the
committed input sets satisfy some set-theoretic relations. E.g., in an approval

(cid:63) First eprint version, January 31, 2014

2

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

Paper
[32]
[19]

[33]
[31]
This paper PMSET,
set

Operation
zero-knowledge sets
committed subset of disjoint
sets
set intersection, set union
set intersection

committed sub-
set,
intersection,
set
union, set diﬀerence, zero-
knowledge sets, accumula-
tor, . . .

RO |CRS| Prov comp Ver comp Comm
Θ(1)
yes Θ(k) Θ(k)
Ω(k)
Ω(k)
yes -

Θ(1)
Ω(k)

yes -
O(k)
yes Θ(1) Θ(k)
no Θ(k) Θ(k)

O(k)
Θ(k)
Θ(1)

O(k)
Θ(k)
Θ(1)

Table 1. Performance comparison of NIZK for set operations

e-voting protocol, one could ﬁrst to be asked to commit to a set A of all approved
candidates, and in the second round (based on the outcome of the ﬁrst round)
to a certain subset B of A. One could interpret A and B as multisets, where a
voter is allowed to distribute a limited number of points between the set of all
candidates. To achieve active security, the voter must prove in particular that
B ⊆ A ⊆ U, where U is the set of all candidates. Moreover, in any concrete
application, it can also be required to lower and upper bound the cardinality of
A and B. For instance, in the case of approval voting, the voter may only have a
number of votes to spend, but may be required to vote at least once. Similarly,
in a combinatorial auction, a bidder may bid up to a certain number items, but
might be required to bid at least once to continue in the next round.

Similar issues arise in many other applications, and thus a lot of work has
been done in constructing eﬃcient zero knowledge proofs for (multi)set-theoretic
operations. However, practically all existing (multi)set-theoretic zero knowledge
proofs [19,33,31] require at least linear communication in the size of the com-
mitted sets. This is not acceptable in many applications where the cardinality
of the underlying sets is large. See Table 1 for a brief comparison, and App. A
for a longer comparison. (App. A also compares the current work with [32].)

Moreover, all existing eﬃcient set-theoretic zero-knowledge proofs are inter-
active, which makes them less useful in practice. While they can be made non-
interactive in the random oracle model by using the Fiat-Shamir heuristic [22], it
is well-known that such a heuristic is not a proof [12,26]. Thus, a better approach
is to build non-interactive zero knowledge (NIZK) proofs in the common refer-
ence string (CRS) model. See Sect. 2 for more preliminaries on NIZK proofs and
arguments (i.e., computationally sound proofs). For the rest of this introduction,
we recall that sublinear NIZK proofs can only be (a) computationally sound, and
(b) cannot be based on standard (falsiﬁable) assumptions [25]. Thus, following a
long line of contemporary cryptographic research [28,14,36,24,5,3,21,37], we will
construct NIZK arguments that are sound under some knowledge assumptions.

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

3

Our Contibutions. We tackle the task of constructing eﬃcient (multi)set-
theoretic NIZK arguments in a modular way. First, we design an eﬃcient pairing-
based NIZK argument for a certain multiset relation. Second, we show that the
proposed argument can be used to construct eﬃcient NIZK arguments for a
plethora of other (multi)set relations.
More precisely, recall that if A is a multiset, then every element a of the
universe U belongs to A with some multiplicity 1A(a) ≥ 0. (Multiplicity 0 means
that a does not belong to A.) In particular, A1(cid:93)A2 is a multiset that has as many
copies of any element a as A1 and A2 put together, 1A1(cid:93)A2 (a) = 1A1 (a) + 1A2 (a)
for each a ∈ U. See Sect. 2 for more preliminaries on multisets.

is encoded as χAj (σ), where χAj (X) :=(cid:81)

We propose a non-interactive pairwise multiset sum equality test (PMSET)
argument, where the prover has committed to four multisets A1, A2, A3 and A4,
and aims to prove in zero knowledge that A1 (cid:93) A2 = A3 (cid:93) A4. That is, for all
a ∈ U, 1A1(a) + 1A2 (a) = 1A3(a) + 1A4 (a). Moreover, for some public constants
kj, this argument guarantees the veriﬁer that |Aj| ≤ kj.
Brieﬂy, the intuition behind our new PMSET argument is as follows. The
prover ﬁrst commits to a succinct encoding of each Aj. More precisely, Aj ⊂ Zp
(X − a) (with correct multiplic-
ities), and σ is a secret key. The prover commits to χAj (σ) for j ∈ {1, 2, 3, 4}.
After that, the prover creates a succinct NIZK argument that χA1 (σ)χA2(σ) =
χA3(σ)χA4(σ), where χAj (X) is a degree ≤ kj polynomial. The real argument is
more complicated, since it has to include several extra values to allow for both
the soundness and the zero knowledge part of the security proof to go through:
(i) to achieve computational soundness, every group element in the argument

a∈Aj

is accompanied by a knowledge component,

(ii) to achieve zero knowledge, the argument contains independent random
commitments Dj to all 4 multisets Aj. In the simulation, the simulator
sets Dj to be equal to random group elements, and simulates the NIZK
arguments that Dj commit to the original sets Aj.

(See Sect. 4 for details.) The argument can be veriﬁed by using a small number
of computations of a bilinear map.

By relying on suitable cryptographic hardness assumptions, from a successful
veriﬁcation it follows that χA1 (X)χA2 (X) = χA3 (X)χA4(X), and thus the two
polynomials χA1(X)χA2 (X) and χA3(X)χA4(X) have the same set of roots with
the same multiplicities. Thus, if the PMSET argument veriﬁes, then the veriﬁer
is convinced that the prover knows multisets Aj, such that A1 (cid:93) A2 = A3 (cid:93) A4.
Moreover, since χAj (X) is a degree ≤ kj polynomial, the veriﬁer is also convinced
that |Aj| ≤ kj.
We actually work in a relaxation of the described model, by allowing χAj (X)
to be any polynomial that has Aj as its null set (again, with correct multiplici-
ties). This somewhat simpliﬁes the argument. Moreover, it allows us to specify
parameters kj such that the prover can additionally convince the veriﬁer that the
cardinality of Aj is not larger than kj. Thus, we automatically achieve the size-
hiding property, required (in particular) in the case of zero-knowledge sets [39].
On the other hand, we can use the upper bound on |Aj| to guarantee, for exam-

4

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

ple, that a voter has approved at most kj candidates. Without the mentioned
relaxation, it seems that the cardinality of Aj would have to be exactly equal to
kj, where kj is ﬁxed during the CRS generation.

The length of the new argument is Θ(1) group elements, while the veri-
ﬁer’s computation is dominated by Θ(1) cryptographic pairings. As a drawback,
the CRS length is Θ(k∗), where k∗ = maxj kj, and the prover’s computational
complexity is dominated by several k∗-wide bilinear-group multiexponentiations.
Although multiexponentiations can be optimized by using the algorithms of
Straus [43] and Pippenger [41], they are still costly.

We also provide a version of the PMSET argument that has a smaller CRS
length but larger communication and veriﬁer’s computation. In the balanced
k). (The prover’s computation
version, all these parameters have complexity Θ(
is still linear in k — this seems, although we are not claiming it, to be necessary
unless Aj have a speciﬁc structure that one can exploit.)

√

Applications. We ﬁnish the paper by showing how to use the PMSET argument
to prove the correct execution of several (multi)set operations. Many applications
are possible since any of the multisets Aj can be either public (e.g., in some
applications we can choose Aj = ∅ to be public) or committed to, and that
we are given ﬂexibility of choosing the values kj for committed multisets. For
example, we obtain arguments for A1 ⊆ A2, A1 = A2 \ A3, A1 = A2 ∪ A3,
A1 = A2 ∩ A3, etc.
As another example, we can prove that A1 is a multiset obtained from A2 by
increasing or decreasing the multiplicity of exactly one (public or committed)
element by one. If that element is public, we obtain a dynamic accumulator [11].
Finally, we mention that one can construct a zap (two-message witness-
indistinguishable argument, where the veriﬁer’s ﬁrst message can be shared be-
tween many protocol executions, [20]) from the new NIZK argument by using
standard techniques: basically, the veriﬁer creates the CRS, and the prover then
replies with the NIZK argument. Such a zap is secure in the standard model,
without assuming the existence of a trusted third party who creates the CRS.

2 Preliminaries

Notation. Sets are denoted by blackboard bold uppercase letters as in A. By
deg(f ), we denote the degree of the polynomial f . If h = gx in a group G,
then we write x = logg h. For a group G, we utilize the fact that G2 = G × G
is a group and thus aggressively use notation like (g, h)a or (g1, h1) · (g2, h2).
Let NUPPT stand for non-uniform probabilistic polynomial time. A positive
function ε(·) is negligible in its parameter if it decreases faster than the inverse
of any polynomial, i.e., ε(n) = n−ω(1). By κ, we denote the security parameter.

Sets And Multisets. Formally, a multiset is a 2-tuple (A, µA) where A is some
set and µA : A → N≥1 is a function from A to the set N≥1 = {1, 2, 3, . . .} of

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

5

positive natural numbers. The set A is called the underlying set of elements. For
each a in A the multiplicity of a is the number µA(a). If A ⊆ U for some larger
set U, then one can extend µA to U, by deﬁning µA(a) = 0 for a (cid:54)∈ A. We denote
this extended multiplicity function by 1A, and assume its existence implicitly,
talking about a multiset A instead of a multiset (A, 1A).
If A and B are sets, then 1A(a) = 1 if a ∈ A and 1A(a) = 0 if x (cid:54)∈ A. If A and B
are sets, then 1A∩B(a) = min{1A(a), 1B(a)} and 1A∪B(a) = max{1A(a), 1B(a)}.
We have that A ⊆ B iﬀ ∀a, 1A(a) ≤ 1B(a). The cardinality of a ﬁnite (multi)set
Now, assume that A and B are multisets. The multiset sum A (cid:93) B is deﬁned
so that 1A(cid:93)B(i) = 1A(i) + 1B(i) for all i, and the multiset diﬀerence A \ B is
deﬁned so that 1A\B(i) = max(0, 1A(i) − 1B(i)) for all i. In most of the cases,
we just use common set-theoretic operations with multisets. For example, a ∈ A
means that 1A(a) ≥ 1.

A is |A| =(cid:80)

a∈U 1A(a).

1 , gb

Bilinear Groups. Let Gbp(1κ) be a bilinear group generator that outputs
a description of a bilinear group parm := (p, G1, G2, GT , ˆe) ← Gbp(1κ), s.t. p
is a κ-bit prime, G1, G2 and GT are multiplicative cyclic groups of order p,
ˆe : G1 × G2 → GT is a bilinear map (pairing), s.t. ∀a, b ∈ Zp and gz ∈ Gz,
2) = ˆe(g1, g2)ab. If gz generates Gz for z ∈ {1, 2}, then ˆe(g1, g2) generates
ˆe(ga
GT . Deciding the membership in G1, G2 and GT , group operations, the pairing ˆe,
and sampling the generators are eﬃcient, and the descriptions of the groups and
group elements are O(κ)-bit long each. A cryptographic pairing is also required
to satisfy some hardness assumptions (see later in this section).

Well-chosen asymmetric pairings (with no eﬃcient isomorphism between G1
and G2) are much more eﬃcient than symmetric pairings (where G1 = G2).
For κ = 128, the current recommendation is to use an optimal (asymmetric)
Ate pairing [30] over a subclass of Barreto-Naehrig curves [2,40]. In that case,
at security level of κ = 128, an element of G1/G2/GT can be represented in
respectively 512/256/3072 bits.

(Λ, u) Trapdoor Commitment Scheme. A trapdoor commitment scheme is
a randomized cryptographic primitive (in the common reference string model [8])
that takes a message and outputs a commitment and a trapdoor. It is required
to have the following three security properties.

Computational binding: without access to the trapdoor, it is intractable to

open the same commitment to two diﬀerent messages.

Perfect hiding: the commitments of any two messages have the same distri-

bution.

Trapdoor: given an access to the original message, the randomizer and the

trapdoor, one can open the commitment to an arbitrary message.
Let z ∈ {1, 2}. Assume that k > 0 and u (cid:54)∈ [0, k] are public parameters. Let
Ψk,u := [0, k]∪{u}. We use the following ([0, k], u) trapdoor commitment scheme
from [21]. For parm ← Gbp(1κ), gz ←r Gz \ {1} and the trapdoor (σ, α) ← Z2

p

6

i∈Ψk,u

(gz, gα

z )σu(cid:1)r

z )rσu+(cid:80)k

z )σi(cid:17)
(cid:16)

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

(with σ (cid:54)= 0), let the common reference string be ck =
commmon reference string ck is made public, while the trapdoor (σ, α) is only

(cid:16)
used in security proofs. Deﬁne3 comck((a0, . . . , ak); r) := (cid:81)k
(cid:0)(gz, gα

. The computation of com can be sped up
by using eﬃcient multi-exponentiations algorithms [43,41]. Groth [28] and Lip-
maa [36] used a similar trapdoor commitment scheme, but with u = 0. (See
also [27].) In our arguments, the case of an arbitrary u is more suitable, though
we can also modify them to work in the case u = 0.
Let Λ ⊆ Zp. A bilinear group generator Gbp is Λ-PSDL (power symmetric
discrete logarithm) secure [36], if for any NUPPT adversary A, the following
probability is negligible in κ:

(cid:34) parm := (p, G1, G2, GT , ˆe) ← Gbp(1κ), g1 ←r G1 \ {1} ,

. The

z )σi(cid:17)ai ·

= (gz, gα

(gz, gα

i=0

i=0 aiσi

Pr

g2 ←r G2 \ {1} , σ ←r Zp : A(parm; (gσi

1 , gσi

2 )i∈Λ) = σ

(cid:35)

.

For algorithms A and XA, we write (y; yX ) ← (A||XA)(σ) if A on input σ
outputs y, and XA on the same input (including the random tape of A) outputs
yX . Let z ∈ {1, 2}. Let Λ ⊂ Zp. Gbp is Λ-PKE (power knowledge of exponent)
secure [28,36] in Gz if for any NUPPT A there exists an NUPPT extractor XA,
such that the following probability is negligible in κ:

parm := (p, G1, G2, GT , ˆe) ← Gbp(1κ), gz ←r Gz \ {1} , (α, σ) ←r Z2
p,

parm; ((gz, gα

z )σi

)i∈Λ

, (c, ˆc; (ai)i∈Λ) ← (A||XA)(crs) :

(cid:17)

 .



Pr

crs ←(cid:16)

ˆc = cα ∧ c (cid:54)=

gaiσi
z

(cid:89)

i∈Λ

commitment (C, ˆC) ∈ G2

Let z = 1. Consider a CRS ck that in particular speciﬁes g2, ˆg2 ∈ G2. A
1 is valid, if ˆe(C, ˆg2) = ˆe( ˆC, g2). The case z = 2 is dual.
As shown in [21], the ([0, k], u) trapdoor commitment scheme is perfectly hid-
ing, and computationally binding under the Ψk,u-PSDL assumption. Moreover,
if the Ψk,u-PKE assumption holds, then for any NUPPT A that outputs a valid
commitment C, there exists a NUPPT extractor that, given A’s input together
with A’s random coins, extracts a valid opening of C.

Non-Interactive Zero Knowledge (NIZK). NIZK proofs [8] allow the
prover to convince the veriﬁer that some input x belongs to some NP lan-
guage L in the manner that nothing else expect the truth of the statement is
revealed. It is well-known that NIZK proofs do not exist without trusted setups
unless P = NP. There are two popular approaches to deal with this. The ﬁrst
approach, the use of random oracle model, results often in very eﬃcient proto-
cols. It is well known [12,26] that some protocols that are secure in the random

3 Here and in what follows, elements of the form (g, gα)x, where α is a secret random

key, can be thought of as a linear-only encoding of x, see [5] for a discussion

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

7

oracle model are non-instantiable in the standard model, and thus the random
oracle model is a heuristic at its best.

A better approach is to construct NIZK proofs in the common reference
string (CRS) model [8]. Many veriﬁers can then later independently verify the
proof, by having access to the same CRS. The proof has to be complete, sound
and satisfy the zero-knowledge property. In practice, one is interested in proofs
where both the proof length and veriﬁcation time are sublinear in the statement
size. Such succinct proofs cannot be statistically sound, and their soundness
cannot be proven under falsiﬁable assumptions [25]. The latter means that one
has to employ knowledge assumptions [16]. A computationally sound proof is
also known as an argument. Succinct NIZK arguments have been proposed for
languages like Circuit-SAT [28,36,24,3,37], Range [14,21], Set Partition,
Subset Sum and Decision Knapsack [21]. While several of these arguments
are eﬃcient, they are all highly technical, and based on a careful combination of
already complex basic arguments.

More formally, an NIZK argument for a language L consists of three algo-
rithms, Gencrs, Pro and Ver. The CRS generation algorithm Gencrs takes as input
1κ (and possibly some other, public, language-dependent information) and out-
puts the prover’s CRS crsp, the veriﬁer’s CRS crsv, and the trapdoor td. (The
distinction between crsp and crsv is not important for security, but in many ap-
plications crsv is much shorter.) The prover’s algorithm Pro takes as an input
crsp together with a statement x and a witness w, and outputs an argument π.
The veriﬁer’s algorithm Ver takes as an input crsv together with a statement x
and an argument π, and either accepts or rejects.

We expect the argument to be (i) perfectly complete (the honest veriﬁer
always accepts the honest prover), (ii) perfectly zero knowledge (there exists
an eﬃcient simulator who can, given x, crsp and td, output an argument that
comes from the same distribution as the argument produced by the prover), and
(iii) computationally sound (if x (cid:54)∈ L, then an arbitrary NUPPT prover has only
a negligible success in creating a satisfying argument). We refer to say [28,36]
for formal deﬁnitions.

3 New Succinct Trapdoor Multiset Commitment Scheme

tiplicities) of a polynomial. For a multiset A ⊂ Zp, let χA(X) :=(cid:81)

To succinctly commit to a multiset A, we represent A as a null set (with mul-
a∈A(X − a),
where every a has been counted with its multiplicity. For example, χ{1,1,2}(X) =
(X − 1)2(X − 2).
Let z ∈ {1, 2}, and let k = |A| (recall that |A| includes the multiplic-
ities of all elements) and u (cid:54)∈ [0, k] be again public parameters. To com-
mit to a multiset A, we use the ([0, k], u) trapdoor commitment scheme
from [21]. Again, we ﬁrst choose parm ← Gbp(1κ) and α, σ ←r Zp, and then
set ck ← (parm, ((gz, gα
)i∈Ψk,u ) to be the common reference string. We
then deﬁne comck(A; r) := comck(χA(σ); r). More precisely, the committer as-
i=0 siX i for some coeﬃcients si, and then computes

sumes that χA(X) = (cid:80)k

z )σi

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

8

comck(A; r) :=(cid:81)k

(cid:16)

(gz, gα

i=0

z )σi(cid:17)si ·(cid:0)(gz, gα
z )σu(cid:1)r

for r ←r Zp. The trapdoor is

equal to td ← (α, σ).
Theorem 1. Suppose z ∈ {1, 2}. The described trapdoor multiset commitment
scheme is hiding and, under the Ψk,u-PSDL assumption, computationally bind-
ing. If the Ψk,u-PKE assumption holds in Gz, then one can also extract the
contents of the commitment.

z

i=0 siσi + rσu = (cid:80)k

1, . . . , s(cid:48)
i=0 s(cid:48)

i=0 siX i + rX u and f(cid:48)(X) = (cid:80)k

for some i, such that loggz c = (cid:80)k
f (X) = (cid:80)k

Proof. The proof follows [21]. Perfect Hiding: follows from the fact that if r
is uniformly random in Zp, then gχA(σ)+rσu
is a uniformly random element of
Gz and thus does not depend on A. Computational Binding: assume that an
k; r(cid:48)) with si (cid:54)= s(cid:48)
adversary can eﬃciently produce (s1, . . . , sk; r) and (s(cid:48)
iσi + r(cid:48)σu. Then
iX i + r(cid:48)X u are two diﬀerent
polynomials. Thus, d(X) = f (X) − f(cid:48)(X) is a non-zero polynomial such that
d(σ) = 0. By using eﬃcient polynomial factorization [34], we can ﬁnd all possible
roots of d, and then ﬁnd σ by comparing for each root x the value gx
z with the
given gσ
Trapdoor: given td, ck, (A, r), (C, C(cid:48)) = comck(A; r) and A(cid:48), one can com-
pute r(cid:48) such that (C, C(cid:48)) = comck(A(cid:48); r(cid:48)) by using the fact that loggz C =
Extraction: follows straightforwardly from the Ψk,u-PKE assumption. (cid:117)(cid:116)

iσi + r(cid:48)σu.

z in ck.

(cid:80) siσi + rσu =(cid:80) s(cid:48)

i=0 s(cid:48)

i

4 New Pairwise Multiset Sum Equality Test Argument

In a pairwise multiset sum equality test (PMSET) argument, the prover aims to
convince the prover, that he knows how to open given four commitments Cj to
four multisets Aj, for j ∈ {1, 2, 3, 4}, such that A1 (cid:93) A2 = A3 (cid:93) A4, where in
both sides, the multiplicities of all elements are summed up. That is, we have
1A1(i) + 1A2 (i) = 1A3(i) + 1A4(i) for all i ∈ Zp. In addition to that, one can also
upperbound |Aj| by some public value kj.
The intuition of the new PMSET argument is as follows. The prover commits
to Aj, for j ∈ {1, 2, 3, 4}, by using the multiset commitment scheme of Sect. 3.
After that, the prover creates a short NIZK argument to show that

χA1 (σ)χA2(σ) = χA3(σ)χA4 (σ) .

(1)

If one does not randomize the commitments, the use of the trapdoor commitment
scheme from [21] makes the corresponding NIZK argument relatively (but not
completely) straightforward. To take into account the fact that the commitment
scheme is randomized, we let the prover also to create a crib E that enables the
veriﬁer to verify Eq. (1) on committed elements.
Moreover, due to technical reasons, the prover also has to add extra elements
(Dj, ∆j), j ∈ {1, 2, 3, 4}, to the argument. These elements make it possible
for the simulator to simulate the NIZK argument, and are necessary since the

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

9

commitments Cj are a part of the statement (i.e., the input of the prover) and
not a part of the NIZK argument. Here, Dj is basically an alternative random
commitment to Aj, while ∆j is an element that makes it possible to verify that
Dj was created correctly. In the simulation, Dj are chosen uniformly and at
random, and ∆j will be set so that the veriﬁcation still accepts. Such a design
also increases the compatibility of our argument; namely the four multisets to
be proven can be arbitrarily committed in either G1 or G2. This allows the
prover to freely compose our arguments for some complex (multi)set relations.
Without loss of generality, in the remaining of this section, we assume that all
the commitments in the statement are in G1.
Thus, in the new argument, the prover creates new random commitments Dj
to Aj for j ∈ {1, 2, 3, 4}, together with ∆j and the crib E. Since we will use a
knowledge assumption, all elements have an accompanying knowledge compo-
nent.

By relying on suitable assumptions,

(1) we obtain that
χA1(X)χA2(X) = χA3 (X)χA4 (X), and thus in particular χA1 (X)χA2 (X) and
χA3(X)χA4(X) have the same roots with the same multiplicities. Therefore, the
veriﬁer is convinced that A1 (cid:93) A2 = A3 (cid:93) A4 (and due to the use of a knowledge
assumption, that the prover actually knows all four multisets).

from Eq.

|A| = (cid:80)
the CRS. Hence, χAj (X) =(cid:80)kj

We relax the multiset commitment scheme of Sect. 3 slightly, by allowing
χAj (X) to be any polynomial that has Aj as its null set (with correct mul-
tiplicities). This relaxation allows us to achieve the following property. Re-
call that the cardinality of a multiset counts the multiplicities of its elements,
a 1A(a) = deg χA(X). In the new PMSET argument, one sets an up-
per bound kj to the cardinality of the multiset Aj, |Aj| ≤ kj, before creating
i=0 sjiX i for some coeﬃcients sji. As we will see
later, setting diﬀerent kj to related values makes it possible to design interesting
variations of the PMSET argument.

We do not know how to achieve such ﬂexibility without the relaxation of the
previous paragraph: without it, the committed polynomial χAj has to be monic,
and thus in the committed subset argument one has to check that a speciﬁc
coeﬃcient of χAj is equal to 1. This would mean that the cardinality of Aj has
to be known before even creating the CRS. In our case, one just has an upper
bound on |Aj|, and thus our arguments are size-hiding which allows to build
zero-knowledge sets [39].

partial

commitment

schemes

as

into

two

ck(A; r)) ← comck(A; r). (Thus, com2

We note that we have another complication. We divide the com-
mitment
follows
scheme
ck(A; r), com2
(com1
is the knowledge
ck(Aj; rj) is given as a part
component of the commitment scheme.) Only com1
of the statement. To obtain soundness, it is necessary that the prover generates
com2

ck(Aj; rj) as a part of the argument.
the new PMSET argument
We now give a formal deﬁnition of
(Gencrs, Pro, Ver). Here, the statement is (Cj)4
j=1.
On the other hand, the witness is (Aj, rj)4
j=1. Note that most of the elements gj
i
that are used by the prover or the veriﬁer include a secret component in their

j=1 where Cj = com1

ck(Aj; rj)4

10

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

exponent and thus they are computed based on the elements that are a part
of the CRS. To avoid ﬁlling the variable namespace, we will not assign special
variable names for all those elements.

CRS generation Gencrs(1κ, k1, k2, k3, k4):

Set parm := (p, G1, G2, GT , ˆe) ←r Gbp(1κ); Set g1 ←r G1 \ {1} and
g2 ←r G2 \ {1}; Set σ, α, β1, β2, β3, β4, η, γ ←r Zp with σ (cid:54)= 0; Set
k∗ ← max(k1, k2, k3, k4); Set u ← k∗ + 1;
For j ∈ {1, 2, 3, 4}: Let z = 1 if j ∈ {1, 3} and z = 2 if j ∈ {2, 4}; Set
ckj ← (((gz, gβj
Output

)i∈Ψkj ,u ); Set ck ← ((g1, gα

)i∈Ψk∗ ,u ;

z )σi

1 )σi

crsp ←(cid:16)
crsv ←(cid:16)

parm, ck, ck1, ck2, ck3, ck4, ((g2, gη

parm, g1, gγ

1 , gβ3
td ←(σ, α, β1, β2, β3, β4, η, γ) .

2 , gβ1

2 , gσu

1 , g2, gβ2

2 , gβ4

2 )σ2u(cid:17)

,

)k∗
i=0, (g2, gη

(cid:17)

2 )σi+u
2 , gη

2

,

j=1; (Aj, rj)4

j=1):

(i) Write χAj (X) =(cid:80)kj

Prover Pro(crsp; (Cj)4
For j ∈ {1, 2, 3, 4}:
j ← com2
j ←r Zp;

(ii) Set C(cid:48)
(iii) Set r(cid:48)
(iv) Set (Dj, D(cid:48)
(v) Set (∆j, ∆(cid:48)
Set

i=0 sjiX i;

ck(Aj; rj);

j) ← comckj (Aj; r(cid:48)
j);
j) ← (g1, gγ
1 )rj−r(cid:48)
j ;

(E, E(cid:48)) ← k1(cid:89)
k3(cid:89)
(cid:16)

i=0

i=0

(cid:16)
(cid:16)

(g2, gη

i=0

2 )σi+u(cid:17)r(cid:48)
2 )σi+u(cid:17)−r(cid:48)
2 )σ2u(cid:17)r(cid:48)

(cid:16)
2s1i · k2(cid:89)
4s3i · k4(cid:89)
j=1, E, E(cid:48)(cid:1);

j, Dj, D(cid:48)

2−r(cid:48)

1r(cid:48)

3r(cid:48)

i=0

;

4

(g2, gη

Output π ←(cid:0)(C(cid:48)

(g2, gη
j, ∆j, ∆(cid:48)

Veriﬁer Ver(crsv; (Cj)4

j)4
j=1; π): Accept if

2 )σi+u(cid:17)r(cid:48)
2 )σi+u(cid:17)−r(cid:48)

1s2i ·

(g2, gη

(cid:16)

(g2, gη

3s4i ·

(a) Verify knowledge components:

– For j ∈ {1, 2, 3, 4}, ˆe(∆(cid:48)
– For j ∈ {1, 2, 3, 4}, ˆe(C(cid:48)
– ˆe(D(cid:48)
1, g2) =? ˆe(D1, gβ1

ˆe(D3, gβ3

2 ), ˆe(g1, D(cid:48)
1 , E),

j, g2) =? ˆe(∆j, gγ
2 ),
j, g2) =? ˆe(Cj, gα
2 ),
2 ), ˆe(g1, D(cid:48)
1 , D4),

4) =? ˆe(gβ4

(b) Verify that Cj and Dj commit to the same multisets:

– ˆe(g1, E(cid:48)) =? ˆe(gη
– For j ∈ {1, 3}, ˆe(Cj/Dj, g2) =? ˆe(∆j, gσu
2 );
– For j ∈ {2, 4}, ˆe(Cj, g2)/ˆe(g1, Dj) =? ˆe(∆j, gσu
2 );

2) =? ˆe(gβ2

1 , D2), ˆe(D(cid:48)

3, g2) =?

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

11

(c) Verify that A1 (cid:93) A2 =? A3 (cid:93) A4: ˆe(g1, E) =? ˆe(D1, D2)/ˆe(D3, D4).
Otherwise, reject.

Theorem 2. The argument of the current subsection is a perfectly complete and
perfectly zero-knowledge argument that the prover knows how to open Cj as a
multiset Aj for j ∈ {1, 2, 3, 4}, such that A1 (cid:93) A2 = A3 (cid:93) A4 and |Aj| ≤ kj for
j ∈ {1, 2, 3, 4}. Let Ψk∗,u,2u := [0, k∗] ∪ [u, k∗ + u] ∪ {2u}. Moreover:
– If the Ψk∗,u,2u-PSDL, the Ψk1,u-PKE and Ψk3,u-PKE assumption in G1, the
Ψk2,u-PKE and the Ψk4,u-PKE and the ([u, u + k∗] ∪ {2u})-PKE assumption
in G2 hold, then it is computationally sound.
– If the Ψk1,u-PKE assumption and the Ψk3,u-PKE assumption hold in G1 and
the Ψk2,u-PKE assumption and the Ψk4,u-PKE assumption hold in G2, then
it is an argument of knowledge.

We remark that to simplify the claim, one can combine the the diﬀerent PKE
assumptions into one (stronger than necessary) PKE assumption, but we pre-
ferred to state precise assumptions. For example, (Ψ1 ∪ Ψ2)-PKE implies both
Ψ1-PKE and Ψ2-PKE, but the opposite direction does not necessarily hold.

g
1

1σu

i∈A1

(cid:19)

we get

i∈A3(cid:93)A4

i∈A1(cid:93)A2

logh ˆe(D1, D2) = logh ˆe
i=0 s2iσi + r(cid:48)

Proof. Let h = ˆe(g1, g2). Completeness: It is easy to see that if the prover is
honest, then all the equations but the last one hold. For the very last equa-
(σ −
i∈A2
i=0 s4iσi),
2σu

i=0 s1iσi)((cid:80)k2
i=0 s2iσi) = (cid:81)
(σ − i) ·(cid:81)
(σ − i) = ··· = ((cid:80)k3
i=0 s3iσi)((cid:80)k4
(cid:18)
(cid:80)k1
(cid:80)k2
2σu(cid:17)
= χA1(cid:93)A2(σ) + (cid:80)k1
i=0 s1iσi+r(cid:48)
i=0 s2iσi+r(cid:48)
1s2iσi+u(cid:17) − (cid:16)(cid:80)k3
4s3iσi+u +(cid:80)k4

tion, note that since ((cid:80)k1
i) = (cid:81)
(σ − i) = (cid:81)
(cid:16)(cid:80)k1
1σu(cid:17)(cid:16)(cid:80)k2
(cid:80)k2
i=0 s1iσi + r(cid:48)
2s1iσi+u +
(cid:80)k3
4s3iσi+u +(cid:80)k4
i=0 r(cid:48)
1r(cid:48)
1s2iσi+u + r(cid:48)
(cid:16)(cid:80)k1
2s1iσi+u +(cid:80)k2
2σ2u, and analogously logh ˆe(D3, D4) = χA3(cid:93)A4(σ) +
i=0 r(cid:48)
i=0 r(cid:48)
3s4iσi+u +r(cid:48)
3r(cid:48)
4σ2u. Thus, logh (ˆe(D1, D2)/ˆe(D3, D4)) =
i=0 r(cid:48)
i=0 r(cid:48)
+
2 − r(cid:48)
(r(cid:48)
1r(cid:48)
3r(cid:48)
4) σ2u = logh E.
Zero-Knowledge: In the real execution, the variables Cj, Dj, ∆j, and E
are distributed randomly, modulo the last veriﬁcation equation. Moreover, C(cid:48)
j,
D(cid:48)
j, ∆(cid:48)
The simulator, who knows td but does not know the witness, will simulate

j, and E(cid:48) are such that the veriﬁcation equations on line (a) hold.

3s4iσi+u(cid:17)

i=0 r(cid:48)

i=0 r(cid:48)

i=0 r(cid:48)

, g
2

=

2

1

the proof as follows.
1. Let D1 ← gβ∗

(cid:17)1/σu
2. For j ∈ {1, 2, 3, 4}, set ∆j ← (cid:16)
1 , D4 ← gβ∗
2 , D3 ← gβ∗
1 , D2 ← gβ∗
(cid:17)
(cid:16)
2
(cid:1) for j ∈ {1, 3} and
= ˆe(cid:0)∆j, gσu
−β∗
Cjg
(cid:17)
(cid:16)
1
(cid:1) for
j /ˆe(g1, Dj) = ˆe(cid:0)∆j, gσu

2 , β∗
It is obvious that

ˆe(Cj/Dj, g2) = ˆe

ˆe(g1, g2)β∗

4 ←r Zp.

1 , β∗
.

−β∗
Cjg
1

, g2
−β∗
Cjg
1

for β∗

3 , β∗

, g2

2

2

4

j

3

j

j

ˆe(Cj, g2)/ˆe(g1, Dj) = ˆe
j ∈ {2, 4}.
2−β∗
3 β∗
gβ∗

1 β∗

4

2

3. Choose E so that the last veriﬁcation equation holds, that is, E ←
4 = ˆe(g1, E).

. Clearly, ˆe(D1, D2)/ˆe(D3, D4) = ˆe(g1, g2)β∗

2−β∗

1 β∗

3 β∗

12

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

j ← C α
j , ∆(cid:48)
4. Now, set C(cid:48)
5. Finally, let π ← ((C(cid:48)

j ← ∆γ
j, ∆j, ∆(cid:48)

j , D(cid:48)
j, Dj, D(cid:48)

j ← Dβj

j

j=1, E, E(cid:48)).
j)4

Such a choice satisﬁes the veriﬁcation equations on line (a).

for j ∈ {1, 2, 3, 4}, and E(cid:48) ← Eη.

Since all veriﬁcations are satisﬁed and π comes from the correct distribu-
tion, then the simulation has been successful and the argument is perfect zero-
knowledge.
Computational soundness: Assume that an adversary A can break the
soundness assumption. We construct another adversary Apsdl that breaks the
Ψk∗,u,2u-PSDL assumption as follows.

Assume that all the required knowledge assumptions hold. Therefore, we can
extract the following values:
– For j ∈ {1, 2, 3, 4}, by the Ψkj ,u-PKE assumption in G1, from (Cj, C(cid:48)

adversary obtains a polynomial fj(X) =(cid:80)kj

j) the
i=0 sjiX i +rjX u, such that Cj =

gfj (σ)
1

.

.

.

– For j ∈ {1, 2, 3, 4}, by the {0}-PKE assumption in G2, from (∆j, ∆(cid:48)

j) the
1 . (Note that the {0}-PKE assumption
– For j ∈ {1, 2, 3, 4}: let z = 1 for j ∈ {1, 3} and z = 2 for j ∈ {2, 4}. By
j) the adversary obtains a

adversary obtains δj such that ∆j = gδj
follows from the Ψkj ,u-PKE assumption.)
the Ψkj ,u-PKE assumption in Gz, from (Dj, D(cid:48)
polynomial f(cid:48)

– By the ([u, u+k∗]∪{2u})-PKE assumption in G2, from (E, E(cid:48)) the adversary

f(cid:48)
j (σ)
jX u, such that Dj = g
z

j(X) =(cid:80)kj

obtains a polynomial ˆf (X) =(cid:80)k∗

ˆf (σ)
i=0 ˆsiX u+i + ˆrX 2u, such that E = g
2

jiX i + r(cid:48)

i=0 s(cid:48)

1 = gσ

2 ) holds, we have fj(σ)−f(cid:48)

Since for j ∈ {1, 3}, ˆe(Cj/Dj, g2) = ˆe(∆j, gσu

If any extraction does not succeed, then Apsdl aborts (this happens with a neg-
ligible probability). Assume now that Apsdl does not abort.
j(σ) =
δjσu. Therefore, if for some i, j, sji (cid:54)= s(cid:48)
ji or δj (cid:54)= tj − rj we have a non-zero
j(X)− δjX u, such that d(σ) = 0. Note that σ (cid:54)= 0,
polynomial d(X) := fj(X)− f(cid:48)
so Apsdl uses an eﬃcient polynomial factorization algorithm [34] to ﬁnd all roots
of d(X), and then tests for which root x it holds that (say) gx
1 . Thus,
Apsdl has found σ and broken the Ψk∗,u-PSDL assumption (and thus also the
Ψk∗,u,2u-PSDL assumption).
Analogously, Apsdl can break the Ψk∗,u-PSDL assumption if for some i, sji (cid:54)=
ji or δj (cid:54)= tj − rj in the case j ∈ {2, 4}.
s(cid:48)
Assuming that the adversary did not already break the Ψk∗,u-PSDL assump-
tion, we now have that for all j ∈ {1, 2, 3, 4}, (Dj, D(cid:48)
j) commit to
the same set, let it be Aj.
2(σ) −
1(σ)f(cid:48)
4(X) −
3(X)f(cid:48)
3(σ)f(cid:48)
f(cid:48)
i=0 ciX i+u + c(cid:48)X 2u
for some coeﬃcients ci and c(cid:48), we have d(σ) = 0.
Since A succeeded in cheating, it must be the case that d(X) is a non-
zero polynomial. But in this case, Apsdl has obtained a non-zero polynomial
d(X) where d(σ) = 0 for some unknown σ. Apsdl uses an eﬃcient polynomial
factorization algorithm [34] to ﬁnd all roots of d(X), and then tests for which

j) and (Cj, C(cid:48)
Finally, due to the last veriﬁcation equation, we have ˆf (σ) = f(cid:48)
2(X) − f(cid:48)

4(σ). This means that, deﬁning d(X) := f(cid:48)

2iX i(cid:1) −(cid:0)(cid:80) s(cid:48)

ˆf (X) = (cid:0)(cid:80) s(cid:48)

4iX i(cid:1) +(cid:80)k∗

3iX i(cid:1)(cid:0)(cid:80) s(cid:48)

1iX i(cid:1)(cid:0)(cid:80) s(cid:48)

1(X)f(cid:48)

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

13

1 = gσ

Thus, (Dj, D(cid:48)

j) and (Dj, D(cid:48)

root x it holds that (say) gx
Ψk∗,u,2u-PSDL assumption.
have already established before that (Cj, C(cid:48)
values. The claim follows.

1 . Thus, Apsdl has found σ and broken the
j) commit to the sets Aj such that A1 (cid:93) A2 = A3 (cid:93) A4. We
j) commit to the same
(cid:117)(cid:116)

Argument of knowledge: follows from the last claim of Thm. 1.

Clearly, the communication complexity of this argument is Θ(1) group ele-
ments and the veriﬁer’s computational complexity is dominated by Θ(1) pair-
ings. The veriﬁer’s CRS length contains the parameters parm and Θ(1) group
elements. On the other hand, the prover’s CRS length, the CRS computation,
and the prover’s computation are Θ(k) group elements or operations respec-
tively. Once again, the computation can be sped up by using eﬃcient multi-
exponentiation algorithms [43,41].

follows. Let k = |A1 (cid:93) A2|. Partition both A1 and A2 into ≈ √
Balancing. One can design a balanced version of the new subset argument as
k subsets A1i and
A2i, so that |A1i (cid:93) A2i| ≈ √
k. Partition A3 and A4 in a similar way, so that
A1i(cid:93)A2i = A3i(cid:93)A4i. Now, the PMSET argument that A1(cid:93)A2 = A3(cid:93)A4 is just
√
k PMSET arguments that A1i (cid:93) A2i = A3i (cid:93) A4i.
equal to the concatenation of
√
Clearly, in this balanced version, the CRS length, the veriﬁer’s computation,
and the communication are Θ(
k), that is, sublinear in k. On the other hand,
the prover’s computational complexity is still Θ(k). However, Θ(k) total work is
clearly a lower bound for arbitrary sets Aj.

5 Applications

Next, we show how to apply the new PMSET argument to construct arguments
for standard (multi)set operations, such as intersections, unions, and comple-
ments. In such arguments, the prover wants to convince the veriﬁer that its
three committed (multi)sets A, B, C satisfy relations like A ⊆ B, A = B ∩ C,
A = B ∪ C or A = B \ C. We ﬁrst note that one can clearly modify the PMSET
argument so that to allow any subset of {A, B, C, D} to be publicly known sets
(e.g., C = ∅). This just means that canonical commitments of the public sets
are included to the CRS. One has to obviously take care about including only
the correct knowledge components to the CRS, but we omit further discussion
because of the lack of space.

In what follows, let U be some publicly known universal set. For eﬃciency
reasons, it is required that U is not too large; this is usually not a too restrictive
assumption. In fact, in many cases U has been ﬁxed by the application and one
has to verify among other things that all sets belong to U. E.g., in the case of
e-voting, U can be the set of all candidates, and in the case of e-auctions, U can
be the set of bids (or in combinatorial auctions, the set of all auctioned goods).

14

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

Is-a-Sub(multi)set argument. Clearly, A ⊆ B (i.e., 1A(a) ≤ 1B(a) for all a ∈ U)
iﬀ A (cid:93) C = ∅ (cid:93) B, for some (committed) multiset C. Thus, the prover simply
provides a commitment to C as a part of the is-a-subset argument, and then
directly utilizes the PMSET argument.
Is-a-Set argument. A committed multiset A is a set (i.e., 1A(a) ≤ 1 for all a) if
A ⊆ U. Thus, for example to show that A ⊆ B where A and B are both sets, one
has to show that A ⊆ B and B ⊆ U by using the argument from the previous
paragraph. Note that having an upper bound on |C| eﬀectively enforces an lower
bound on |A|.
Multiset-Sum argument. Multiset sum is trivial, as C = A (cid:93) B iﬀ A (cid:93) B = C (cid:93) ∅.

Set-Intersection-And-Union argument. Set intersection and union are closely
related. Suppose the prover wants to show that the given four committed sets
A, B, C, D ⊆ U satisfy C = A ∩ B and D = A ∪ B. For this it is suﬃcient to
show that A (cid:93) B = C (cid:93) D, C ⊆ A, C ⊆ B and that A, B and D are sets.
Really, if A, B and D are sets, and C ⊆ A then also C is a set. Thus, for all
a, 1A(a), 1B(a), 1C(a), 1D(a) ∈ {0, 1}. If 1A(a) = 1B(a) = 0, then also 1C(a) =
1D(a) = 0. If 1A(a) = 1B(a) = 1, then 1C(a) + 1D(a) = 2. But since C and D
are sets, then 1C(a) = 1D(a) = 1. If 1A(a) = 0 and 1B(a) = 1 (the opposite case
is similar), then 1C(a) + 1D(a) = 1. But since C ⊆ A, 1C(a) = 0 and 1D(a) = 1.
Thus, C = A ∩ B and D = A ∪ B.
Set-Diﬀerence argument. To show that committed sets A, B, C ⊆ U satisfy A =
B\C (i.e., 1A(a) = max(0, 1B(a)−1C(a)) for all a), the prover shows (by using the
set-intersection-and-union argument from the previous paragraph) that A∩C = ∅
and A ∪ C = B ∪ C. Since ∅ is not committed to, one can somewhat simplify the
resulting argument (e.g., one does not have to verify that ∅ ⊆ A).

Accumulators. We can extend the applications to the case of cryptographic
accumulators [4], where given committed S and a public k, one has to present a
short proof of either k ∈ S or k (cid:54)∈ S. In this case, one is traditionally not interested
in privacy, but the proofs should be sound. More precisely, given k ∈ S, we can
give a PMSET argument that {k} ∪ S(cid:48) = S for some committed multiset S(cid:48).
Similarly, given k (cid:54)∈ S, we can give a PMSET argument that {k}∪ S(cid:48)(cid:48) = U\ S for
some committed multiset S(cid:48)(cid:48). In both cases, one can additionally use an is-a-set
argument to show that S (or S(cid:48)(cid:48), in the k (cid:54)∈ S case) is a set. This also means that
we can implement a dynamic accumulator [11], by ﬁrst showing that k ∈ S (or
k (cid:54)∈ S) and then using commitment to S(cid:48) as the accumulator for S \ {k} (resp.,
commitment to S ∪ {k} as the accumulator for S ∪ {k}).

Acknowledgments. The ﬁrst two authors were supported by the Estonian
Research Council, and European Union through the European Regional De-
velopment Fund. The third author was supported by Project FINER, Greek
Secretariat of Research and Technology, and by ERC project CODAMODA.

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

15

References

1. Abe, M. (ed.): ASIACRYPT 2010, LNCS, vol. 6477. Springer, Heidelberg
2. Barreto, P.S.L.M., Naehrig, M.: Pairing-Friendly Elliptic Curves of Prime Order.
In: Preneel, B., Tavares, S.E. (eds.) SAC 2005. LNCS, vol. 3897, pp. 319–331.
Springer, Heidelberg

3. Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C:
Verifying Program Executions Succinctly and in Zero Knowledge. In: Canetti, R.,
Garay, J. (eds.) CRYPTO (2) 2013. LNCS, vol. 8043, pp. 90–108. Springer, Hei-
delberg

4. Benaloh, J., de Mare, M.: One-Way Accumulators: A Decentralized Alternative to
Digital Signatures. In: Helleseth, T. (ed.) EUROCRYPT 1993. LNCS, vol. 765, pp.
274–285. Springer, Heidelberg

5. Bitansky, N., Chiesa, A., Ishai, Y., Ostrovsky, R., Paneth, O.: Succinct Non-
interactive Arguments via Linear Interactive Proofs. In: Sahai, A. (ed.) TCC 2013.
LNCS, vol. 7785, pp. 315–333. Springer, Heidelberg

6. Blanton, M., Aguiar, E.: Private and oblivious set and multiset operations. In:

Youm, H.Y., Won, Y. (eds.) ASIACCS 2012. pp. 40–41. ACM

7. Blaze, M. (ed.): FC 2002, LNCS, vol. 2357. Springer, Heidelberg
8. Blum, M., Feldman, P., Micali, S.: Non-Interactive Zero-Knowledge and Its Appli-

cations. In: STOC 1988. pp. 103–112. ACM Press (May 2–4, 1988)

9. Boudot, F.: Eﬃcient Proofs That a Committed Number Lies in an Interval. In:
Preneel, B. (ed.) EUROCRYPT 2000. LNCS, vol. 1807, pp. 431–444. Springer,
Heidelberg

10. Camenisch, J., Chaabouni, R., shelat, a.: Eﬃcient Protocols for Set Membership
and Range Proofs. In: Pieprzyk, J. (ed.) ASIACRYPT 2008. LNCS, vol. 5350, pp.
234–252. Springer, Heidelberg

11. Camenisch, J., Lysyanskaya, A.: Dynamic Accumulators and Application to Eﬃ-
cient Revocation of Anonymous Credentials. In: Yung, M. (ed.) CRYPTO 2002.
LNCS, vol. 2442, pp. 61–76. Springer, Heidelberg

12. Canetti, R., Goldreich, O., Halevi, S.: The Random Oracle Methodology, Revisited.

In: Vitter, J.S. (ed.) STOC 1998. pp. 209–218

13. Chaabouni, R., Lipmaa, H., shelat, a.: Additive Combinatorics and Discrete Log-
arithm Based Range Protocols. In: Steinfeld, R., Hawkes, P. (eds.) ACISP 2010.
LNCS, vol. 6168, pp. 336–351. Springer, Heidelberg

14. Chaabouni, R., Lipmaa, H., Zhang, B.: A Non-Interactive Range Proof with Con-
stant Communication. In: Keromytis, A. (ed.) FC 2012. LNCS, vol. 7397, pp.
179–199. Springer, Heidelberg

15. Cramer, R., Gennaro, R., Schoenmakers, B.: A Secure and Optimally Eﬃcient
Multi-Authority Election Scheme. In: Fumy, W. (ed.) EUROCRYPT 1997. LNCS,
vol. 1233, pp. 103–118. Springer, Heidelberg

16. Damg˚ard, I.: Towards Practical Public Key Systems Secure against Chosen Ci-
phertext Attacks. In: Feigenbaum, J. (ed.) CRYPTO 1991. LNCS, vol. 576, pp.
445–456. Springer, Heidelberg

17. Damg˚ard, I., Jurik, M.: A Generalisation, a Simpliﬁcation and Some Applications
of Paillier’s Probabilistic Public-Key System. In: Kim, K. (ed.) PKC 2001. LNCS,
vol. 1992, pp. 119–136. Springer, Heidelberg

18. D’Arco, P., Gonzalez Vasco, M.I., P´erez del Pozo, A.L., Soriente, C.: Size-Hiding in
Private Set Intersection: Existential Results and Constructions. In: Mitrokotsa, A.,
Vaudenay, S. (eds.) AFRICACRYPT 2012. LNCS, vol. 7374, pp. 378–394. Springer,
Heidelberg

16

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

19. Dimitriou, T., Foteinakis, D.: A Zero Knowledge Proof for Subset Selection from
a Family of Sets with Applications to Multiparty/Multicandidate Electronic Elec-
tions. LNCS, vol. 3416, pp. 100–111. Springer, Heildeberg

20. Dwork, C., Naor, M.: Zaps and Their Applications. In: FOCS 2000. pp. 283–293.

IEEE Computer Society Press

21. Fauzi, P., Lipmaa, H., Zhang, B.: Eﬃcient Modular NIZK Arguments from Shift
and Product. In: Abdalla, M., Nita-Rotaru, C., Dahab, R. (eds.) CANS 2013.
LNCS, vol. 8257, pp. 92–121. Springer, Heidelberg

22. Fiat, A., Shamir, A.: How to Prove Yourself: Practical Solutions to Identiﬁcation
and Signature Problems. In: Odlyzko, A.M. (ed.) CRYPTO 1986. LNCS, vol. 263,
pp. 186–194. Springer, Heidelberg

23. Freedman, M.J., Nissim, K., Pinkas, B.: Eﬃcient Private Matching and Set Inter-
section. In: Cachin, C., Camenisch, J. (eds.) EUROCRYPT 2004. LNCS, vol. 3027,
pp. 1–19. Springer, Heidelberg

24. Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic Span Programs and
NIZKs without PCPs. In: Johansson, T., Nguyen, P.Q. (eds.) EUROCRYPT 2013.
LNCS, vol. 7881, pp. 626–645. Springer, Heidelberg

25. Gentry, C., Wichs, D.: Separating Succinct Non-Interactive Arguments from All
Falsiﬁable Assumptions. In: Vadhan, S. (ed.) STOC 2011. pp. 99–108. ACM Press
26. Goldwasser, S., Kalai, Y.T.: On the (In)security of the Fiat-Shamir Paradigm. In:

FOCS 2003. pp. 102–113. IEEE, IEEE Computer Society Press

27. Golle, P., Jarecki, S., Mironov, I.: Cryptographic Primitives Enforcing Communi-

cation and Storage Complexity. In: Blaze [7], pp. 120–135

28. Groth, J.: Short Pairing-Based Non-interactive Zero-Knowledge Arguments. In:

Abe [1], pp. 321–340

29. Henry, R., Goldberg, I.: All-but-k Mercurial Commitments and their Applications.
Tech. Rep. 26, Centre for Applied Cryptographic Research (Dec 2012), available
at http://cacr.uwaterloo.ca/techreports/2012/cacr2012-26.pdf

30. Hess, F., Smart, N.P., Vercauteren, F.: The Eta Pairing Revisited. IEEE Transac-

tions on Information Theory 52(10), 4595–4602 (2006)

31. Jarecki, S., Liu, X.: Eﬃcient Oblivious Pseudorandom Function with Applications
to Adaptive OT and Secure Computation of Set Intersection. In: Reingold, O. (ed.)
TCC 2009. LNCS, vol. 5444, pp. 577–594. Springer, Heidelberg

32. Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-Size Commitments to Polyno-

mials and Their Applications. In: Abe [1], pp. 177–194

33. Kissner, L., Song, D.: Privacy-Preserving Set Operations. In: Shoup, V. (ed.)

CRYPTO 2005. LNCS, vol. 3621, pp. 241–257. Springer, Heidelberg

34. Lenstra, A.K., Lenstra, Jr., H.W., Lov´asz, L.: Factoring Polynomials with Rational

Coeﬃcients. Mathematische Annalen 261, 513–534 (1982)

35. Lipmaa, H.: On Diophantine Complexity and Statistical Zero-Knowledge Argu-
ments. In: Laih, C.S. (ed.) ASIACRYPT 2003. LNCS, vol. 2894, pp. 398–415.
Springer, Heidelberg

36. Lipmaa, H.: Progression-Free Sets and Sublinear Pairing-Based Non-Interactive
Zero-Knowledge Arguments. In: Cramer, R. (ed.) TCC 2012. LNCS, vol. 7194, pp.
169–189. Springer, Heidelberg

37. Lipmaa, H.: Succinct Non-Interactive Zero Knowledge Arguments from Span Pro-
grams and Linear Error-Correcting Codes. In: Sako, K., Sarkar, P. (eds.) ASI-
ACRYPT 2013 (1). LNCS, vol. 8269, pp. 41–60. Springer, Heidelberg

38. Lipmaa, H., Asokan, N., Niemi, V.: Secure Vickrey Auctions without Threshold

Trust. In: Blaze [7], pp. 87–101

Eﬃcient Non-Interactive Zero Knowledge Arguments for Set Operations

17

39. Micali, S., Rabin, M.O., Kilian, J.: Zero-Knowledge Sets. In: FOCS 2003. pp. 80–

91. IEEE, IEEE Computer Society Press

40. Pereira Geovandro, C.C.F., Simpl´ıcio Jr., M.A., Naehrig, M., Barreto, P.S.L.M.:
A Family of Implementation-Friendly BN Elliptic Curves. Journal of Systems and
Software 84(8), 1319–1326 (2011)

41. Pippenger, N.: On the Evaluation of Powers and Monomials. SIAM J. Comput.

9(2), 230–250 (1980)

42. Rial, A., Kohlweiss, M., Preneel, B.: Universally Composable Adaptive Priced
Oblivious Transfer. In: Shacham, H., Waters, B. (eds.) Pairing 2009. LNCS, vol.
5671, pp. 231–247. Springer, Heidelberg

43. Straus, E.G.: Addition Chains of Vectors. American Mathematical Monthly 70,

806–808 (1964)

A Related Work

Our multiset commitment scheme is a modiﬁcation of the (what we call a FLZ)
commitment scheme [21], which in turn is related to the polynomial commitment
scheme of [32]. In [32], the authors proposed a commitment scheme for polyno-
mials f , where instead of committing to the coeﬃcients of f separately, one
commits to f (σ), where σ is a random key. Their commitment scheme is based
on the fact that for any polynomial f , x− i divides f (x)− f (i). Our commitment
scheme is somewhat more eﬃcient than the one from [32], since [32] required the
randomness r also to be a polynomial. Thus, one needs to generate deg(f ) times
more randomness, and the opening of the commitment is also more burdensome.
While the need for a new commitment scheme was motivated by the applications
considered in [32], it is not necessary in our distinctively diﬀerent applications.
Also, based on their commitment scheme, [32] proposed an NIZK proof that
a speciﬁc public element belongs to the committed subset, which they named
zero knowledge sets. Henry and Goldberg [29] showed that this argument was
insecure, and provided a secure improvement. However, both these constructions
were interactive, and would either require a random oracle, or be less eﬃcient to
get non-interactiveness. We provide a non-interactive implementation without
random oracles in our accumulator argument, which is as eﬃcient as both [32]
and [29].

The balanced version of our multiset commitment scheme is somewhat similar
to the setting in the electronic voting protocol of Dimitriou and Foteinakis [19],
which had K disjoint but same size sets V1,··· VK with total cardinality C =
K ·|V1|, and a prover commits to S such that S ⊆ Vi for some i ∈ [1, K]. We can
C = |V1|. But in both cases Dim-
directly compare when either K = 1 or K =
itriou and Foteinakis require a separate zero-knowledge proof for each candidate,
√
hence the prover’s computation, communication and veriﬁcation are all ω(C),
√
C) communication and
whereas we have either Θ(C) prover’s computation, Θ(
Θ(
C) veriﬁcation (in the balanced version) or Θ(C) prover’s computation, con-
stant communication and constant veriﬁcation (in the non-balanced version).

√

In terms of set operations, there is a lot of related research in the literature.
We denote k to be an upper bound for the size of the client’s and server’s sets (or

18

Prastudy Fauzi, Helger Lipmaa, and Bingsheng Zhang

the maximum of the two, if an upper bound is not required). Freedman, Nissim
and Pinkas presented a two-party private matching and set intersection proto-
col [23], where the client inputs a private set C, and the server inputs a private
set S; if si ∈ S ∩ C, the client learns si, otherwise it learns a uniformly random
value. The proposed 2-round protocol requires oblivious pseudorandom functions
(OPRF) and is provably secure in the random oracle model, but requires O(k)
communication. Jarecki and Lim [31] improved upon this and used OPRF to
get a 1-round protocol secure in the random oracle model, and a 2-round pro-
tocol secure in the CRS model, both cases having O(k) communication. Both
protocols reveal the size of the server’s set.

Kissner and Song [33] proposed diﬀerent privacy-preserving set operation
protocols that employed the concept of multi-sets. For example, the set union
operation is seen as simply the product of the polynomial representations of the
two sets. They implement secure set intersection with a ﬁxed and equal size
for the client and server sets, using the fact that for random polynomials r, s,
χAr + χBs = χA∩Bt with t having no roots from the universal set U, except for
a negligible probability. However, their protocols have O(k) proof size, prover’s
computation and veriﬁcation, with the overhead being a proof of correct poly-
nomial multiplication. Moreover, they also have several operations on encrypted
polynomials, such as derivatives to reduce duplicated elements of a multiset.
These operations are costly, and we choose not to implement them as they will
require a product argument as in [21].

There are several other results on private set intersections that are not di-
rectly comparable to ours. For example, Blanton and Aguiar [6] had more ef-
ﬁcient set operations than the work stated above based on eﬃcient parallelized
multi-party operations, but it requires n > 2 parties while we focus on two-party
protocols. D’Arco et al. [18] showed that unconditionally secure size-hiding set
intersection is possible with the help of a trusted third party (TTP), given that
the client and server have set cardinality at most k. However, the TTP sends
output to the client and server based on their speciﬁc sets. This means that even
for a ﬁxed server set V, the TTP is required for each new client set. Moreover,
their 2-round, O(k)-communication protocol was only secure in the semi-honest
model. Extending it to become a protocol secure against malicious adversaries,
the proof size (that is dominated by proof of correct encryption for each of k
Paillier ciphertexts) will also become O(k).

We summarize in Table 1. Note that we only include results that either have
non-interactive zero knowledge proofs, or can be made non-interactive using the
Fiat-Shamir heuristic. None of the work discussed has 1 round (non-interactive),
does not require a random oracle and has proof size sublinear in the set cardi-
nality, whereas our set operations have constant-size proof and is secure in the
CRS model.

