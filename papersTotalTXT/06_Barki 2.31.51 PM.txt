Private eCash in Practice (Short Paper)

Amira Barki1,2, Solenn Brunet1,3, Nicolas Desmoulins1, S´ebastien Gambs4, Sa¨ıd

Gharout1, and Jacques Traor´e1

1 Orange Labs, Caen, France

2 Sorbonne universit´es, Universit´e de technologie de Compi`egne (UTC), CNRS, UMR

7253 Heudiasyc, Compi`egne, France

3 Universit´e de Rennes 1, Rennes, France

4 Universit´e du Qu´ebec `a Montr´eal (UQAM), Montr´eal, Canada

Abstract. Most electronic payment systems for applications, such as
eTicketing and eToll, involve a single entity acting as both merchant
and bank. In this paper, we propose an eﬃcient privacy-preserving post-
payment eCash system suitable for this particular use case that we refer
to, afterwards, as private eCash. To this end, we introduce a new partially
blind signature scheme based on a recent Algebraic MAC scheme due to
Chase et al. Unlike previous constructions, it allows multiple presentations
of the same signature in an unlinkable way. Using it, our system is the ﬁrst
versatile private eCash system where users must only hold a sole reusable
token (i.e. a reusable coin spendable to a unique merchant). It also enables
identity and token revocations as well as ﬂexible payments. Indeed, our
payment tokens are updated in a partially blinded way to collect refunds
without invading user’s privacy. By implementing it on a Global Platform
compliant SIM card, we show its eﬃciency and suitability for real-world
use cases, even for delay-sensitive applications and on constrained devices
as a transaction can be performed in only 205 ms.

Keywords: eCash, post-payment, refunds, partially blind signature,
anonymity, eToll, eTicketing, EVC.

1

Introduction

Electronic Cash (eCash), introduced by Chaum [6], is the digital analogue of hard
currency in which users withdraw electronic coins from a bank and spend them
to merchants. Later, each merchant deposits the collected coins to the bank.

Using eCash, user’s anonymity is protected both from the bank and merchants.
To ensure this, it should be impossible to link the following pair of events: either
a withdrawal and a spending or two spendings. However, owing to its digital
nature, eCash has to be protected from duplication. Thus, eCash protocols must
enable the detection of double-spending and the identiﬁcation of defrauders.

To be as attractive as possible, the user’s side of an eCash system is sometimes
implemented on a mobile device or even a smart card. Therefore, protocols have
to comply with both the limited resources of such environments as well as the
stringent delay constraint arising from transactions requirements.

2

A. Barki, S. Brunet, N. Desmoulins, S. Gambs, S. Gharout and J. Traor´e

Public transport [2], electronic Toll (eToll) [7] and Electric Vehicle Charging
(EVC) [3] are the main emerging uses cases of private eCash (i.e. involving a
single merchant managed by the same entity acting as the bank) that signiﬁcantly
invade user’s privacy. Indeed, transactions records may disclose user’s location at
a given time and reveal personal information such as work, home or habits.

Related work. Recently, several proposals have addressed this issue. However,
ﬁnding a good tradeoﬀ between necessary security properties and performance
has not always been completely successful. In the sequel, we only focus on schemes
related to eCash although other approaches exist in the literature [12, 4, 10].

Public transport users’ privacy was tackled in [13], [11] and [2]. In the ﬁrst
two proposals, users pay for their trips through the use of payment tokens that
are worth the highest possible fare. As fares have diﬀerent values, a refund
process is set up to guarantee the accurate charging of users. However, to ensure
user’s anonymity with respect to the transport company, the scheme of Rupp
et al. [13] entails heavy veriﬁcations that constrained devices cannot handle [2].
The proposal of Milutinovic et al. [11] is also computationally expensive and less
eﬃcient than [13] as refunds are separately collected on distinct refund tokens.
Arfaoui et al. [2] protocol meets the stringent delay requirement and is eﬃcient
even when implemented in constrained environment. It is also the only one
allowing anonymity revocation under exceptional circumstances. Nevertheless,
this scheme does not enable ﬂexible prices. As regards to EVC user’s privacy,
it was addressed by Au et al. [3]. However, their scheme requires costly zero-
knowledge proofs of knowledge and is not suitable for time-sensitive applications.
Finally, Day et al. [7] proposed two privacy-preserving payment systems for
eToll. However, the ﬁrst one is only partially private as it relies on spot checks
that record some of the user’s spatio-temporal information to detect and identify
defrauders. Furthermore, through an exhaustive search on tokens, it is possible
to trace all user’s trips. In contrast, the second proposal provides full anonymity
and enables double spending detection. Unfortunately, to be eﬃcient, users have
to hold a large number of tokens where each one can only be used at a speciﬁc
time. Besides, similarly to eCoupons, both proposals do not allow ﬂexible prices,
which we believe to be an important issue.

Contributions. In this paper, we propose an eﬃcient post-payment private eCash
system designed for scenarios in which the same entity acts as both merchant
and bank like public transport, eToll and EVC. Indeed, we leverage this feature
to strike a balance between eﬃciency and privacy. Our system relies on a new
partially blind signature scheme built based on the recent Chase et al. Algebraic
MAC scheme [5]. Unlike ordinary eCash systems, users must only hold a single
token that can be reused a speciﬁed number of times without allowing anyone
to trace users or link their transactions. Through a refund process5, our eCash
system supports both post-payments (i.e. users are charged after the use of the

5 As shown in [13], an aggregate refund amount should not enable to deduce the
diﬀerent toll fares and hence, the details of the individual trips the user has taken.

Private eCash in Practice

3

service) and ﬂexible prices while removing the need to withdraw several tokens of
diﬀerent values. Our proposal is proven secure in the random oracle model (ROM)
and its implementation on a SIM card shows that it complies with the limited
computational power of constrained devices and stringent time constraints.

The paper is organized as follows. Section 2 introduces our main notation and
building blocks and details our partially blind signature scheme. Based on this ﬁrst
contribution, Section 3 explains our eCash system through the eToll use case. As
an electronic payment system dedicated to toll roads, it illustrates the challenging
requirements we have to face both in terms of privacy and performance. Finally,
implementation results in Section 4 show that our system is truly eﬃcient.

2 Preliminaries

2.1 Notation

To state that x is chosen uniformly at random from the set X, we use one of
the two following notations x R←− X or x ∈R X. In addition,
respectively denote the vector (x0, x1, . . . , xn) and the set {g1, g2, . . . , gl}.
Zero-Knowledge Proofs of Knowledge (ZKPK) allow a prover P to convince a
veriﬁer V that he knows some secrets verifying a given statement without revealing
anything else about them. They are denoted by the usual notation in which Greek
letters correspond to P’s knowledge: π := PoK{α, β : statements about α, β}.

→
x and {gi}l

i=1

2.2 Building Blocks

Algebraic MAC in Prime-Order Group. Chase et al. introduce in [5] two MAC
schemes constructed using a cyclic group of prime order. An interesting feature of
their schemes is that the issuer and the veriﬁer are actually the same entity and
consequently share a set of keys. To build our private eCash scheme, we focus
on their MACGGM construction, that can be seen as a digital signature scheme,
proven unforgeable under chosen message and veriﬁcation attack (UF-CMVA) in
the generic group model. In the following, we brieﬂy review their construction by
explaining how to sign n distinct messages (m1, . . . , mn):
1. Setup(1k) creates the system public parameters denoted pp := (G, q, g, h)
where G is a cyclic group of prime order q, a k-bit prime, and g, h are two
random generators such that logg h is unknown.

2. KeyGen(pp) generates a secret key sk :=

and a value ˜x0 ∈R Fq
to build a commitment Cx0 := gx0h˜x0 to the secret value x0. Denoted by
iparams, (Cx0, X1 := hx1, . . . , Xn := hxn) corresponds to the issuer’s public
parameters.
where u ∈R G\{1} and u(cid:48) := ux0+x1m1+···+xnmn.

→
m := (m1, . . . , mn)
→
m, (u, u(cid:48))) checks the validity of the token with respect to the
4. Verify(sk,
→
m. The token is accepted only if u (cid:54)= 1 and u(cid:48) = ux0+x1m1+···+xnmn .

→
m) produces an authenticated token (u, u(cid:48)) on

→
x ∈R Fn+1

q

3. MAC(sk,

message

4

A. Barki, S. Brunet, N. Desmoulins, S. Gambs, S. Gharout and J. Traor´e

Based on MACGGM, Chase et al. proposed a keyed-veriﬁcation anonymous
credentials scheme allowing the blind issuance of credentials. However, it requires
ZKPK for each hidden attribute and does not provide perfect unlinkability as the
credential attributes are sent to the issuer encrypted, using ElGamal encryption
scheme, before being signed. Thus, it is not suitable for eCash systems.

Partially blind signatures. A variation of basic digital signatures, called blind
signature, allows a receiver R to get a signature on a message without revealing
any information about it to the signer S. However, in use cases like eCash, S
may want to add some information to the blind signature such as a date, a
validity period or an amount. To address this issue, Abe et al. [1] proposed an
extension known as partially blind signature. It allows R and S to agree on a
→
common information info to be added in the blind signature of a message
m.
A partially blind signature scheme should be (1) one-more unforgeable (i.e. it
should be impossible to obtain L + 1 signatures with at most L signing requests)
and (2) unlinkable (i.e. it should be impossible to link two signatures or identify
for whom the signature was issued).
→
m),S(sk)) described below,
we detail our partially blind signature scheme based on MACGGM and which is
executed between R holding
1. R sends the common value info, a commitment C→

Through the interactive protocol BlindIssue(R(

→
m and S who acts as the issuer holding sk:

to

. . . X mn
q as well as the ZKPK π1 deﬁned as follows:

m := hrX m1
n }.
. . . X αn

m = hβX α1

2. If π1 is valid, S computes u(cid:48)(cid:48) := ux0(C→

the message
π1 := P oK{α1, α2, . . . , αn, β : C→
q and u := hb.
Then, he provides R with the partially blind signature ((u, u(cid:48)(cid:48)), info) as well
as a ZKPK π2 proving that u(cid:48)(cid:48)
:= ux0+x1m1+...+xn−1mn−1+xn(mn+info)hbr
m(Xn)info)β ∧ Cx0 = gαhγ}.
and π2 := P oK{α, β, γ : u(cid:48)(cid:48) = uα(C→
3. Finally, R unblinds (u, u(cid:48)(cid:48)) and obtains the signature (u, u(cid:48) := u(cid:48)(cid:48)
ur ).

m(Xn)info)b s.t. b ∈R Z∗

1

n

→
m where r ∈R Z∗

1

To show the obtained signature in an anonymous way, the receiver has just

to randomize it by computing (ul, (u(cid:48))l) where l ∈R Z∗
q.

In our eCash system, info will correspond to the refund amount and will be
used with mn to aggregate refunds. Usually, mn may be set to zero and info
would be the validity period, thus enabling a convenient update of signatures.

Theorem 1. Our partially blind signature scheme is perfectly unlinkable and
one-more unforgeable under the assumption that MACGGM is UF-CMVA secure.6

3 Our private eCash system: the eToll use case

3.1 System framework
Stakeholders. Our private eToll system involves three main entities: a user U, a
toll company T C and a set of revocation authorities RAs that must collaborate
to revoke user’s anonymity or tokens.

6 Owing to the lack of space, we defer the proofs of Theorem 1 and Theorem 2 to an

extended version.

Private eCash in Practice

5

Overview. To beneﬁt from the eToll service, a user must ﬁrst register to obtain a
badge that will perform all computations on his behalf. At the beginning of each
billing period, registered users receive a unique reusable token generated using
our partially blind signature scheme detailed in Section 2.2. This token is worth
the highest possible fare and can be reused at most Nmax times. To be granted
access while preserving his anonymity, the user shows a randomized version of
his token. Concurrently, as toll fares are generally diﬀerent, the user’s token is
updated in a blinded way, using our partially blind signature scheme, to add the
refund amount associated to the transaction. At the end of the billing period,
users are charged according to their token value. Such a post-payment approach
prevent them from reﬁlling a prepaid account with a large amount of money.
However, if a user does not return his token, he will pay the maximal allowed
amount corresponding to Nmax trips with the highest fare.

Security and performance requirements. None of the entities can be fully trusted
since all of them have some incentives to cheat. Only the user’s badge is subject
to the limited trust assumption that all the computations it performs are correct.
Nevertheless, any attempt to cheat by tampering it must be detected. To this end,
in addition to the usual correctness property, some security properties must be
satisﬁed. Our private eCash system should provide (1) unlinkability (i.e. it should
be impossible to link together two events such as two transactions or a transaction
and a given token) which implies the regular anonymity property, (2) revocability
(i.e. RAs can always revoke user’s anonymity and tokens), (3) non-frameability
(i.e. nobody should be able to falsely accuse another user of performing a given
transaction) and, (4) unforgeability (i.e. it should be impossible for users to cheat
by paying less charges than what they have to). To be eﬀective and suitable for
most use cases, a transaction must be performed in at most 300 ms [2].

3.2 Description of the protocols

Our private eCash system consists of six phases. (1) The public parameters and
required keys are initialized during setup. (2) The Registration phase enables a user
to register to the system and to obtain his badge. (3) The Token Issuance phase
provides legitimate users with a unique reusable token. (4) During Access Control,
a user uses his token to be granted access at tollbooths. (5) The Toll Computation
phase allows the computation of the user’s bill based on his token value. Finally,
(6) the Revocation phase enables user’s anonymity and token revocations. Below,
we explain these phases and detail the main protocols in Figure 1. Owing to
space limitations, the ZKPKs are not detailed. Except otherwise speciﬁed, they
are quite standard and many values in these proofs can be precomputed.

Setup. Let pp = (G, g, h, q, gR, Nmax,{gi}Nmax
i=1 ) denote the public parameters
where G is a cyclic group of prime order q and (g, h, gR,{gi}Nmax
i=1 ) a set of random
generators. Nmax indicates the allowed number of reuses of a token and could be
set according to user’s needs. Each user U is also provided with a pair of keys
(sku, pku) that identiﬁes him.

6

A. Barki, S. Brunet, N. Desmoulins, S. Gambs, S. Gharout and J. Traor´e

The toll company shares the secret key

→
x := (x0, x1, x2) with tollbooths that
are denoted by T C as well. The associated public parameters are Cx0 := gx0h˜x0,
a commitment to x0 where ˜x0 ∈R Z∗
q, and X1 := hx1 , X2 := hx2. They are also
provided with a pair of keys (sktc, pktc) used to sign transaction data.

The revocation authorities jointly generate two pairs of keys: (skra, pkra) of
the threshold ElGamal and (skrp, pkrp) of the threshold Paillier cryptosystems.
Paillier encryption scheme is used as an extractable commitment (see [9]) to
satisfy the unforgeability requirement, even in a concurrent setting, where an
adversary is allowed to interact with T C in an arbitrarily interleaving (concurrent)
manner. Let gE and gP be two generators of G. ElGamal keys are deﬁned as
skra := xT ∈ Z∗
E ). Paillier pair of keys consists of
skrp := (a, b) and pkrp := (gP , n := ab) where a and b are two diﬀerent random
primes such that |a|= |b| and gcd(ab, (a − 1)(b − 1)) = 1. The private keys are
shared among RAs [8] and at least t of them should cooperate to identify the
user or revoke a token.

q and pkra := (gE, XT := gxT

Registration. To use the service, U must provide T C with his public key pku
and a ZKPK proving the knowledge of the secret key sku. If the proof is valid, U
receives a personal badge Bu including a SIM card. It allows U to anonymously
use the service. Moreover, pku is saved in a dedicated database denoted by DBREG.

Token Issuance. The token issuance phase occurs at the beginning of each
billing period upon a signed request of a registered user. During this phase, T C
provides U with a permission token T := (u, u(cid:48) := ux0+x1su+x2m). It is a partially
blind signature on the unknown message su = s + s(cid:48) and the common information
m corresponding to the refund amount, initially set to 0. In fact, su is a secret
value only known by U: it involves a secret s ∈R Z∗
q chosen by U and hidden from
T C and s(cid:48) ∈R Z∗
q chosen by T C and provided to U. The token is worth the highest
possible toll fare and can be reused Nmax times. Two ZKPKs π1 and π2 ensure
that exchanged values are well-formed (see Figure 1). Besides, (gs, s(cid:48), D) is saved
in DBREG where D is a Paillier encryption of s necessary for token revocation.

Access Control. To be granted access at tollbooths, U provides a randomized
version of his token T and an ElGamal encryption E of gsu along with a ZKPK
π3 proving that these values are well-formed. Upon receipt, T C checks the token
both for the allowed number of uses and validity. Indeed, whenever reaching a
tollbooth, Bu randomly chooses a gi among the set F of unused ones. The selected
gi is then removed from F to prevent over-spending of a token. If checks succeed,
U receives an updated T with a new m aggregating all the refunds collected so
far. This new token is computed using our partially blind signature scheme with
a common value equal to the current refund amount. Due to delay constraint,
the associated ZKPK π4 cannot be instantly veriﬁed. Thus, U is also provided
with S, an RSA signature with a short public veriﬁcation exponent, of all the
received values. S can be quickly veriﬁed upon receipt while π4 is rather checked

Private eCash in Practice

7

User U
Public Input: pp, X1, X2, Cx0 , pktc, pkra, pkrp and pku

Toll Company T C

(1) Token Issuance Protocol

Private Input: sku
Choose r, r1, s R← Z∗
Compute C ← hrX s
Build π1 = PoK[α, β, γ : C = hαX β
1
∧ W = gβ ∧ D = gβ

1 , W = gs, D = gs

q

P γn]

P rn

1

Check π2
Compute su ← s + s(cid:48) and u(cid:48) ← u(cid:48)(cid:48)
T ← (u, u(cid:48)), m ← 0, F ← {gi}Nmax

ur

i=1

Private Input: (x0, x1, x2), DBREG

C,π1,W,D

−−−−−−−−−−→ Check π1 and Choose s(cid:48), b R← Z∗
←−−−−−−−−−−−− Compute u ← hb
Sign(C,π1,W,D)

q

Compute u(cid:48)(cid:48) ← ux0 (CX s(cid:48)

1 )b

s(cid:48) ,(u,u(cid:48)(cid:48) ),π2
←−−−−−−−−−− Build π2 = PoK[α, β, γ : u = hα
1 )α ∧ Cx0 = gβ hγ ]

∧u(cid:48)(cid:48) = uβ (CX s(cid:48)
Save (W , D, s(cid:48)) in DBREG

(2) Access Control Protocol

Public Input: m(cid:48)

q , gi

Private Input: T := (u, u(cid:48)), m, su, F
R←− F
Choose l, r, z1, z2, t and b R←− Z∗
Compute w ← ul; w(cid:48) ← (u(cid:48))l; c(cid:48) ← w(cid:48)gr
c1 ← wsu hz1 ; c2 ← wmhz2 ; F ← F\{gi}
V ← g−rX z1
E ← (e1 = gb
Build π3 = PoK[α, β, γ, δ, σ, µ, η : Ti = gσ
i
∧ c2 = wµhγ ∧ V = g−αX β
2 ∧ e1 = gη
1 X γ
c1 = wσhβ ∧ A = hδX σ
2 ∧ e2 = gσX η
1 X µ
T ]

1 X z2
E , e2 = gsu X b

2 ; A ← htX su

T ); Ti ← gsu

1 Xm

2

i

Check π4 and S
Compute y(cid:48) ← y(cid:48)(cid:48)
and T ← (y, y(cid:48))

yt , m ← m + m(cid:48)

q

R←− Z∗

Private Input: T := (u, u(cid:48)), m, su
Choose l, r, z1
Compute R ← ul; R(cid:48) ← (u(cid:48))l; c(cid:48) ← R(cid:48)gr
c1 ← Rsu hz1 ; V ← g−rX z1
Build π5 = PoK[α, β, γ : Tg = gα
R
∧ c1 = Rαhβ ∧ V = g−γ X β
1 ]

1 ; Tg ← gsu

R

Private Input: (x0, x1, x2), DBAC

w,c(cid:48) ,c1 ,c2,V
x1
wx0 c
−−−−−−−−−→ Check if V ?=
1 c
c(cid:48)
−−−−−−−−−→ Check π3 and Ti /∈ DBAC
Ti,A,gi,π3,E

x2
2

q ; Compute y ← hd

Choose d R← Z∗
Compute y(cid:48)(cid:48) ← yx0 (AXm(cid:48)
S = SignRSA(m(cid:48), y, y(cid:48)(cid:48), π4)

2 )d

m(cid:48),y,y(cid:48)(cid:48) ,π4,S
←−−−−−−−−−− Build π4 = PoK[α, β, γ : y = hα
2 )α ∧ Cx0 = gβ hγ ]

∧y(cid:48)(cid:48) = yβ (AXm(cid:48)
Save (E, Ti) in DBAC

Private Input: (x0, x1, x2), DBREG

−−−−−−−−−→ Check if V ?=

m,R,c(cid:48) ,c1
Rx0+mx2 c
−−−−−−→ Check π5 and Tg /∈ DBREG
V, Tg ,π5

c(cid:48)

x1
1

Save Tg in DBREG

(3) Toll Computation Protocol

Fig. 1: Our private eCash system: the eToll use case

during the idle time of the SIM card. Concurrently, (E, Ti := gsu
i ) is saved in the
database of transactions DBAC. Note that, to provide full unlinkability, one may
add randomness in Ti using a pseudo-random function as in [2].

Toll Computation. At the end of the billing period, U shows his randomized
token T and a tag Tg := gsu
R to be charged for all his trips. The tag ensures that
U has not already asked for a refund during that period. Based on the refund
amount m, T C computes the user’s charges and saves Tg in DBREG. If a user’s
token has been used less than Nmax times, a speciﬁc process emulates their use
with no associated charges to ensure that U will only pay for the trips he took.

8

A. Barki, S. Brunet, N. Desmoulins, S. Gambs, S. Gharout and J. Traor´e

Card

Get Data

T C

Send Data

Card

Total

Precomputation from card computation

to card

Veriﬁcation On-line part

(1)

(2)

(3)

(4)

(5)

(1672-1688) 1678

(9-34) 22

(501-522) 511

Battery-On:
Battery-Oﬀ:
Table 1: Timings ((min-max) average in ms) of the Access Control Protocol. The oﬀ-line computa-
tions (steps 1 and 5) are launched from the smartphone (battery-on). On-line computations concern
steps 2, 3 and 4, and can be done battery-oﬀ.

(186-224) 205
(298-322) 315

(96-115) 102
(175-184) 182

(66-68) 67

85

Revocation. Two diﬀerent revocations may be triggered in exceptional circum-
stances: the revocation of user’s anonymity or tokens. In the former, the goal
is to identify the user who performed a given access control (e.g. for national
security reasons). To do so, T C sends to RAs the ElGamal encryption E of gsu .
At least t of them should collaborate to recover gsu . Using the information stored
in DBREG, T C identiﬁes the corresponding user. In the latter, the aim is to revoke a
token following, for example, the loss or theft of the badge. To this end, RAs are
provided with the Paillier encryption D of the secret s that they jointly decrypt.
i }Nmax
Thereby, T C can compute su = s + s(cid:48) and thus blacklists all the {Ti := gsu
i=1 .

Theorem 2. Our private eCash system is unlinkable under the Decisional Com-
posite Residuosity (DCR) and the Decisional Diﬃe-Hellman (DDH) assumptions,
unforgeable and revocable under the assumption that MACGGM is UF-CMVA
secure and non-frameable under the Discrete Logarithm assumption, in the ROM.

4 Performance assessment

Table 1 gives timing results of the implementation of the Access Control protocol
on a Javacard 2.2.2 SIM card, Global Platform 2.2 compliant, embedded in
a Samsung galaxy S3 NFC smartphone. The only particularity of our card,
compared to the javacard speciﬁcations, is some additional API provided by the
card manufacturer enabling modular and elliptic curve operations. Although the
used SIM card is more powerful than most cards, as it requires a cryptoprocessor
to be able to handle asymmetric cryptography, it is worth emphasizing that such
powerful SIM cards with cryptoprocessors are already widely deployed by some
mobile phone carriers, such as Orange in France, to provide NFC-based services.
The implementation uses a 256-bit prime elliptic curve. To have the fastest
possible veriﬁcation on card, T C uses an RSA signature scheme with a short
public veriﬁcation exponent. Since our private eCash system is not only intended
for eToll but also for public transport, communications between the SIM card
in the smartphone and the PC (Intel Xeon CPU 3.70GHz) acting as T C was
done in NFC using a standard PC/SC reader (an Omnikey 5321). “Battery-Oﬀ”
denotes a powered-oﬀ mobile phone either by the user or because its battery is
ﬂat. In this case, as stated by NFC standards, NFC-access to the SIM card is
still possible, but with degraded performances. On average, the on-line part of
the Access Control protocol is very fast even with a powered-oﬀ phone. In fact,
data exchange is the most time-consuming task.

Private eCash in Practice

9

5 Conclusion

In this paper, our contribution is twofold. First, we proposed a new partially
blind signature scheme that relies on Chase et al. Algebraic MAC scheme. Then,
based on it, we designed a private eCash system that only requires users to hold
a unique reusable token while preserving their privacy. Through a refund process,
it also enables ﬂexible prices as well as post-payments. Finally, implementation
results show its eﬃciency even when implemented on a SIM card.

References

1. Abe, M., Fujisaki, E.: How to date blind signatures. In: Kim, K., Matsumoto, T.
(eds.) Advances in Cryptology ASIACRYPT ’96, LNCS, vol. 1163, pp. 244–251.
Springer Heidelberg (1996)

2. Arfaoui, G., Lalande, J., Traor´e, J., Desmoulins, N., Berthom´e, P., Gharout, S.:
A practical set-membership proof for privacy-preserving NFC mobile ticketing.
Proceedings on Privacy Enhancing Technologies abs/1505.03048 (2015)

3. Au, M.H., Liu, J., Fang, J., Jiang, Z., Susilo, W., Zhou, J.: A new payment system
for enhancing location privacy of electric vehicles. IEEE Transactions on Vehicular
Technology 63(1), 3–18 (Jan 2014)

4. Balasch, J., Rial, A., Troncoso, C., Preneel, B., Verbauwhede, I., Geuens, C.: PrETP:
Privacy-preserving electronic toll pricing. In: Proceedings of the 19th USENIX
Conference on Security. pp. 5–5. USENIX Security’10 (2010)

5. Chase, M., Meiklejohn, S., Zaverucha, G.: Algebraic MACs and keyed-veriﬁcation
anonymous credentials. In: Proceedings of the 2014 ACM SIGSAC CCS. pp. 1205–
1216. CCS ’14, ACM, New York, NY, USA (2014)

6. Chaum, D.: Blind signatures for untraceable payments. In: Chaum, D., Rivest, R.,

Sherman, A. (eds.) Advances in Cryptology, pp. 199–203. Springer US (1983)

7. Day, J., Huang, Y., Knapp, E., Goldberg, I.: SPEcTRe: spot-checked private ecash

tolling at roadside. In: WPES. pp. 61–68. ACM (2011)

8. Fouque, P.A., Poupard, G., Stern, J.: Sharing decryption in the context of voting
or lotteries. In: Frankel, Y. (ed.) Financial Cryptography, LNCS, vol. 1962, pp.
90–104. Springer Berlin Heidelberg (2001)

9. Hufschmitt, E., Traor´e, J.: Fair blind signatures revisited. In: Takagi, T., Okamoto,
T., Okamoto, E., Okamoto, T. (eds.) Pairing-Based Cryptography Pairing 2007,
LNCS, vol. 4575, pp. 268–292. Springer Berlin Heidelberg (2007)

10. Meiklejohn, S., Mowery, K., Checkoway, S., Shacham, H.: The phantom tollbooth:
Privacy-preserving electronic toll collection in the presence of driver collusion. In:
Proceedings of the 20th USENIX Conference on Security. pp. 32–32. SEC’11 (2011)
11. Milutinovic, M., Decroix, K., Naessens, V., De Decker, B.: Privacy-preserving public
transport ticketing system. In: Samarati, P. (ed.) Data and Applications Security
and Privacy XXIX, LNCS, vol. 9149, pp. 135–150. Springer International Publishing
(2015)

12. Popa, R.A., Balakrishnan, H., Blumberg, A.J.: VPriv: Protecting privacy in location-
based vehicular services. In: Proceedings of the 18th Conference on USENIX Security
Symposium. pp. 335–350. SSYM’09 (2009)

13. Rupp, A., Hinterwlder, G., Baldimtsi, F., Paar, C.: P4R: Privacy-preserving pre-
payments with refunds for transportation systems. In: Sadeghi, A.R. (ed.) FC 2013,
LNCS, vol. 7859, pp. 205–212. Springer Heidelberg (2013)

