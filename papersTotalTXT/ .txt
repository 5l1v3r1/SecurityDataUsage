2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Malicious-Client Security in Blind Seer:

A Scalable Private DBMS

Ben A. Fisch∗, Binh Vo∗, Fernando Krell∗, Abishek Kumarasubramanian†,

Vladimir Kolesnikov‡, Tal Malkin∗, Steven M. Bellovin∗,

∗ Columbia University, benafisch@gmail.com, {binh, fkrell, tal, smb}@cs.columbia.edu

† UCLA, abishekk@gmail.com

§Bell Labs, kolesnikov@research.bell-labs.com

Abstract—The Blind Seer system (Oakland 2014) is an efﬁcient
and scalable DBMS that affords both client query privacy and
server data protection. It also provides the ability to enforce
authorization policies on the system, restricting client’s queries
while maintaining the privacy of both query and policy. Blind
Seer supports a rich query set,
including arbitrary boolean
formulas, and is provably secure with respect to a controlled
amount of search pattern leakage. No other system to date
achieves this tradeoff of performance, generality, and provable
privacy.

A major shortcoming of Blind Seer is its reliance on semi-
honest security, particularly for access control and data protec-
tion. A malicious client could easily cheat the query authorization
policy and obtain any database records satisfying any query of
its choice, thus violating basic security features of any standard
DBMS. In sum, Blind Seer offers additional privacy to a client,
but sacriﬁces a basic security tenet of DBMS.

In the present work, we completely resolve the issue of a
malicious client. We show how to achieve robust access control
and data protection in Blind Seer with virtually no added cost
to performance or privacy. Our approach also involves a novel
technique for a semi-private function secure function evaluation
(SPF-SFE) that may have independent applications.

We fully implement our solution and report on its perfor-

mance.

I. INTRODUCTION

With the exponential growth of electronically generated,
transmitted and stored information comes the question of
scalable authorized access to these databases. In many impor-
tant scenarios there is an additional requirement of security
and privacy of the data, the query, and the access control
policies. These privacy requirements frequently arise in law
enforcement and government scenarios, as well as in some
business scenarios. For detailed motivation and examples of
private DBMS applications, we refer the reader to, e.g., [14],
[28].

Combining functionality, scalability and privacy has long
been an elusive goal of the crypto and security research
communities. Recently, two systems were concurrently pro-
posed [14], [28], both supporting highly practical, sublinear,
and privacy protected DB querying, with provable security
with respect
to a controlled amount of information leak-
age (e.g., search patterns across multiple queries). The two
systems, called OSPIR-OXT and Blind Seer, offer varying
features and relative advantages, making each system better

© 2015, Ben A. Fisc. Under license to IEEE.
© 2015, Ben A. Fisc. Under license to IEEE.
DOI 10.1109/SP.2015.31
DOI 10.1109/SP.2015.31

395
395

suited for different application scenarios (see Section VII for a
more detailed discussion). In terms of privacy, Blind Seer [28]
offers somewhat stronger guarantees in that they formally
ensure that the individual terms of the query formula are
privacy-protected. (In contrast, OSPIR-OXT [14] leaks support
sizes of the disjunctive formula terms.)

However, a major disadvantage of Blind Seer as compared
to OSPIR-OXT is that it is only secure against semi-honest
clients, namely clients who honestly follow the protocol
speciﬁcation. Even standard DBMS systems with no client
privacy generally have robust access control, which Blind Seer
does not provide against actively cheating clients. In fact,
a very simple and undetectable deviation from the protocol
enables a client to easily circumvent all access control in
Blind Seer. This failure to meet a standard requirement and
a common feature of database systems severely limits Blind
Seer’s viability and scope for practical deployment.

Lifting the Blind Seer protocol into the malicious setting
using standard techniques is very expensive. For example,
the cut-and-choose approach to malicious MPC (cf. [19],
[20], [24]) carries the cost of at least 128-fold performance
degradation for 2−128 security. These costs can be made
somewhat better using very recent amortized garbled circuit
techniques [12], [22]. Still, state-of-the-art generic or special-
ized techniques result in order(s) of magnitude cost overhead.
The result of the present work, surprisingly, is that malicious
security against the client can be obtained for free. That is,
we show how to protect against a malicious client at virtually
no additional performance cost, as well as no privacy or
functionality degradation. Our result applies not only to Blind
Seer, but also to any setting where a potentially malicious
party needs to evaluate a private function on a semi-honest
party’s private inputs. When both parties are semi-honest (or
at least the party holding the private function is semi-honest),
the Yao Garbled Circuits (Yao GC) protocol is a practical
method that entirely preserves the privacy of the inputs and
reveals no more than the private function’s circuit topology.
While it is well-known how to achieve this functionality (or
even stronger privacy) for malicious players using general and
expensive techniques, our technique is as efﬁcient and achieves
the same level of privacy as Yao GC.

We still assume that the server in our setting is semi-honest.
In many natural applications, both in business and government,

the trust in the server (e.g., Bank) is much higher than in
the client. This is often because the server is operated by a
business or an agency, and would risk a high legal penalty for
actively compromising the privacy of a client. (Note, however,
that we do not trust the server with private information).

Our Contributions

−

− Malicious-client security in Blind Seer: We present
the ﬁrst design and implementation of a DBMS that features
both fully robust access control and private arbitrary boolean
querying, with performance about 2-3 times slower than (inse-
cure and non-private) MySQL. The access control mechanism
is highly expressive, and can implement any policy dependent
on the client’s query.
− Novel SPF-SFE technique: We give an extremely
simple and efﬁcient protocol for a semi-private function secure
function evaluation which allows for secure function evalua-
tion of any private function of known circuit topology that is
held by the party who will receive the output.

Formal proofs: We formally prove security against
arbitrary malicious behavior of the client. We note that full
cryptographic proofs are unusual for large systems such as
ours. Our other privacy features and leakage proﬁles remain
nearly the same as those of the original Blind Seer.
− Implementation and Performance: We implement our
design of malicious-client secure Blind Seer, and discuss the
details in Section VI-A. We compare the performances of the
new design, the original Blind Seer design, and MySQL. We
also demonstrate a greatly improved performance by imple-
menting batching and parallelization within query processing.
Since the original design did not support multi-threading, we
ran the new system on a single thread when collecting the
comparison data. When running our system with 16 threads
on a 10TB, 100M-record DB, typical queries run in time
comparable to MySQL, or up to only 3 times slower. This
is more than a 5-fold improvement over the single threaded
Blind Seer (while security is signiﬁcantly better).

Organization

In the next section (Section II) we provide an overview
of the malicious-client vulnerability in Blind Seer and our
solution. In Section III we present our main building block
for malicious security—our new SPF-SFE protocol. We de-
scribe in detail our complete malicious-client secure system
in Section IV, and formally analyze its security in Section
V. We discuss implementation and performance features in
Section VI and end with related work in Section VII.

II. OVERVIEW

This section provides an overview of our solution for
achieving malicious-client security in Blind Seer. We will
review the basic architecture of Blind Seer [28], point out
how the previous design was vulnerable to malicious-client
cheating, and then describe how we address that vulnerability.
Preliminaries We use Bloom ﬁlters (BF), semantically secure
encryption (both public key and symmetric key), Yao Garbled

396396

Circuits (GC), and Oblivious Transfer (OT). All these standard
cryptographic primitives are described in Appendix A.

We use Yao GC to achieve secure computation, also called
secure function evaluation (SFE), which intuitively means that
the two-party function is computed so that each of the parties
learns no information except what follows from their own
inputs and outputs. One may also consider Private Function
SFE (PF-SFE), where in addition the function that is being
computed is itself the input of one of the parties, and remains
hidden from the other party. A generalization of this is Semi-
Private Function SFE (SPF-SFE), where the function is known
to belong to some class of functions, but beyond that remains
hidden. Here, we will consider SPF-SFE where the function is
known to have a certain topology. Explicitly, the structure of
the gates in the circuit describing the function is known, but
the operation of each gate (e.g., OR or AND) remains hidden.
(See more details in Section III). Yao GC is an example of
a protocol that achieves this property. Yao GC involves one
party sending a “garbled circuit” to the other, and while the
technique was not designed to hide the function, it turns out
to hide the values of the gates.

In our setting, OT preprocessing [1] and OT extension [13]
dramatically improve performance. We use the Naor-Pinkas
protocol [25] for the “base” OTs that seed OT extension. We
then use a version of the IKNP protocol for OT extension
suggested by Nielsen [26] that is robust against a malicious
receiver with small additional cost.

The Blind Seer DBMS

We review here the basic features of the Blind Seer DBMS
provided by [28]. We refer the interested reader to that paper
for more details, as well as discussion and motivation for the
setting and design choices (some of which are also discussed
in [3], [14]). However, we stress that further details of the
Blind Seer design beyond what
is described here and in
Section IV are not necessary for understanding the malicious-
client vulnerability of the original design and the contributions
of the present work.
Participants. The Blind Seer system consists of three main
parties: a server S, a client C, and a third party server called
the index server IS. The server S owns a database DB. The
client C submits queries and retrieves records satisfying those
queries. IS holds an encryption of DB as well as an encrypted
index to DB, and facilitates the private and efﬁcient evaluation
of the client’s queries (without learning either the query or the
data).

A fourth logical entity, called the query checker QC, is
responsible for enforcing policy restrictions on the client’s
queries. For
instance, a policy restriction might prohibit
queries that ask for records associated with an important
political ﬁgure. QC may be run by the server S or index server
IS, but we will view it as a separate logical entity for sake of
generality. This way, we also demonstrate that we can keep
the policy hidden from S and IS in addition to the client C. As
long as the separate parties do not collude, C only learns the
results of queries that pass the policy, C’s query is kept private

from all other parties, the policy is kept private from C, and
the results of the policy check are unknown to any party.
Architecture. The basic architecture of Blind Seer is depicted
in Figure 1. The server S, who holds the DB, will hand an
encrypted copy of the DB to the third party server IS. In
addition, S builds an encrypted Bloom ﬁlter (BF) tree index
to the DB and sends it to IS.

The BF tree index is constructed as follows. The records of
the DB are randomly permuted, and a b-ary tree is initialized
with a one-to-one correspondence of tree leaves to records in
the DB. A BF is placed at every node in the tree. Each leaf-
node BF holds all the (indexed) keywords of its corresponding
DB record. Each internal-node BF contains the union of all
the keywords inserted into its children BFs. Keywords are
inserted into a BF using k cryptographic hash functions (see
Appendix A for details on Bloom ﬁlters). Finally, each BF
in the tree is encrypted with a one time pad generated from
a keyed pseudorandom function, which (via the PRF key) is
given to the client C.

The client submits all its queries to IS only. A query is
expressed as a boolean formula over keyword terms (e.g.,
fname:Jeffery ∧ lname:Smith). Each keyword terms
tests the presence of a keyword in a Bloom ﬁlter, and so
expands into a conjunction of k predicates, each testing a
single bit in the input BF. The query is interactively evaluated
on each node down the BF tree. The query processing proceeds
to children nodes only if it returns true on their parent node.
When a query returns true on a leaf-node BF, the associated
record is returned to the client. A Yao garbled circuit protocol
variant is used to evaluate the query at each BF node. To avoid
garbling a circuit that takes an entire Bloom ﬁlter as input, C
reveals to IS the relevant BF indices that the query circuit
examines (k for each individual keyword term). Note that IS
does not know the value of the BF at those indices because
the BF is encrypted.

QC and C also separately engage in a computation of the
policy circuit via the Yao GC technique, and with the help of
IS. Speciﬁcally, C chooses key pairs for the input and output
wires of the policy circuit, sends these pairs to QC, and sends
only the keys corresponding to its query input to IS. In turn,
QC garbles the secret policy circuit using the client’s key pairs,
and sends this garbled circuit to IS for oblivious evaluation on
the client’s inputs. The output of the policy circuit is integrated
into the query circuit evaluation so that C learns only the AND
of the two circuit outputs.

Finally, if the query evaluation (and policy approval) on any
leaf record outputs success, IS sends the record and decryption
information to C. C obtains any ﬁnal decryption information
from S.
Privacy and Leakage.
Ideally, the client C would learn
nothing except the result sets of its authorized queries, and
the servers S and IS (as well as the query checker QC) would
learn nothing at all. Blind Seer achieves privacy up to a con-
trolled amount of leakage of search patterns. IS may correlate
repeated queries, and both C and IS may observe traversal

Server 

Index Server 

1: Build encrypted index 

yp

4: Decryption  
    keys 

Client 

Query Checker 

Figure 1. Basic architecture of Blind Seer.

patterns through the tree index across multiple queries, possi-
bly obtaining some correlation information between different
queries. Additionally, since Yao’s GC technique is used, IS
does learn certain structural information about C’s query and
QC’s policy, namely their circuit topologies. However, the
individual search terms (i.e., keywords) and logical gates
are hidden (as Yao GC provides SPF-SFE, leaking only the
circuit’s topology).

The privacy guarantees of Blind Seer have been formally
proven with respect
to semi-honest adversaries using the
simulation paradigm. Semi-honest adversaries will not deviate
from the prescribed protocol, but may attempt to learn arbitrary
information from their view of the protocol. The controlled
leakage was formally captured by including a leakage oracle
in the ideal world functionality deﬁnition.

Malicious-Client Vulnerabilities in Blind Seer

The Blind Seer policy enforcement collapses with a mali-
cious client because there is no mechanism for evaluating an
authorization policy directly on the client’s private query. The
client submits one query (represented as a garbled circuit) to
be evaluated privately in the DB search protocol, and a second
query (represented as input wires to the policy circuit) to be
evaluated privately in the authorization policy protocol. An
honest client will submit the same query to both protocols, but
a malicious client could submit entirely separate query inputs
to the search protocol and policy protocol, rendering the access
control mechanism completely ineffective. Crucially, there is
no risk of detection for C.

The Solution

Our solution simultaneously cryptographically binds the
client’s inputs to both the query evaluation and policy check
circuits, and encrypts the DB record results under a key that
can only be obtained when both the outputs of the query and
the policy are positive. Of course, this could be accomplished
using any number of off-the-shelf expensive techniques, such
as zero-knowledge or fully malicious-secure SFE, but our goal
is to maintain the efﬁciency of Blind Seer.

397397

Blind Seer uses Yao Garbled Circuits (GC) in both the
search protocol and the policy protocol. Yao GC is one of
the fastest secure two-party computation protocols for semi-
honest players. In the Yao GC protocol,
the two parties
are distinguished as generator and evaluator. The generator
selects the function to evaluate and “garbles” the function. The
evaluator is able to obliviously evaluate the garbled function
using both his own inputs and secret inputs that the generator
supplies. While Yao GC satisﬁes only semi-honest security
against the generator, it offers malicious security against the
evaluator. Furthermore, Yao’s GC is a special case of SPF-SFE
in that it leaks only the boolean circuit topology of the function
to the evaluator. The garbled circuit generator can even choose
to cryptographically bind any of the evaluator’s inputs by
synchronizing the decryption key pairs on the corresponding
input wires. The evaluator receives only one of the two keys
through a single oblivious transfer, and is forced to reuse the
same key for both wires.

The difﬁculty in using standard Yao GC to achieve
malicious-client security in Blind Seer arises since the client
is the generator, rather than the evaluator, of the query circuit
in the search protocol.

The crux of our solution is a low-cost way of converting
the client’s query from a circuit to a circuit input, thereby
swapping the role of the client from generator to evaluator.
There are several challenges that we need to overcome in order
to achieve this without sacriﬁcing either efﬁciency or privacy:
1) How does IS play the role of garbled circuit generator
without knowing the query circuit (that should remain
hidden from IS)?

2) How do we link inputs to the query and policy that are
related but formatted differently? For instance, where the
query circuit takes a keyword field : value, the policy
circuit might take only the ﬁeld name field.

3) Recall how each DB index Bloom ﬁlter is encrypted with
a randomly generated one-time pad. C and IS receive
random shares of each BF from S, and both parties
submit these bits as inputs to the query circuit. How do
we prevent a cheating client from faking positive query
results by ﬂipping some of its BF input bits?

Universal query circuit.
IS can play the role of generator
in the query evaluation protocol without knowing the query
by using a universal circuit. A universal circuit U CF is a
well-known construction that can simulate any circuit C in
the family F. Speciﬁcally, it is a circuit that will take as
input the description of any circuit C ∈ F, any input x, and
will output C(x). There are many constructions of universal
circuits U Ck that can simulate any circuit of size k [18], [31].
This is a very powerful tool for PF-SFE since it can be used
to hide everything about the private function except its size.
Indeed, a universal circuit provides exactly what we need in
terms of swapping the role of the circuit generator to be input
provider, while maintaining circuit privacy. Unfortunately,
however, constructing a general universal circuit U Ck results
in a signiﬁcant increase in circuit size, and thus a very high

398398

overhead in performance when evaluating it through the Yao
GC technique.

Instead, we take advantage of the fact

that we do not
need full function privacy for PF-SFE, since the topology of
the circuit is already leaked to the IS even in the previous
solution. We construct a much simpler universal circuit U CT
that simulates any monotone circuit with topology T , with
virtually no overhead in its secure computation. We stress
that considering only monotone circuits is not a limitation,
since Blind Seer’s tree traversal (and any natural DB tree
index traversal, for that matter) only works for monotone
query circuits (i.e., containing only AND and OR gates) over
keyword terms, where negations are pushed to the variable
level (something which can always be done efﬁciently). Also
note that the keyword terms are computed by conjunctions of
k XOR gates, each taking one input from each party. However,
since these circuits computing the keyword terms are ﬁxed and
known to both parties, they are not included in the universal
query circuit.
Our construction of U CT from T increases the number
of gates by a factor two, but the extra gates are all XOR
gates. Thus, when using the free-XOR technique [17], the cost
of securely computing U CT with Yao GC has roughly the
same cost as securely computing any monotone circuit C with
topology T .

In our new protocol, C sends the topology of its query
circuit Q to IS, and IS generates the corresponding universal
query circuit U Q. IS garbles U Q and sends it back to C for
evaluation. Note that sending the topology of Q does not
increase leakage to IS because running Yao GC directly on
Q (with C as generator and IS as evaluator) also reveals its
topology.
Policy circuit. QC garbles a policy circuit P C and sends
it to C for evaluation. The circuit outputs a key that reveals
no information on its own, but is used to evaluate a garbled
conjunction of the policy and query: U Q ∧ P C. The key
difference from the previous design mechanism is that C
will not submit any separate input to QC. Instead, the client
commits to its query only once, and receives from IS all the
keys it needs to evaluate both U Q and P C.

QC and IS exchange information on the keys used in the
garbling of U Q and P C in order to synchronize the keys used
for common inputs to both circuits and so that IS can respond
to the client’s query with the appropriate keys. The new
protocol also requires C to separately submit cryptographic
hashes of all the ﬁeld names and keywords used in its query.
Keywords are inserted into the Bloom ﬁlter index in a way
that binds each keyword hash to its corresponding ﬁeld hash.
While the query circuit must be evaluated on every BF node
encountered during the index tree traversal, it is only necessary
to evaluate P C once per query. The only inputs to U Q that
change as the BF node changes are the BF input bits to the
keyword terms. The policy circuit is a ﬁxed function of the
query, and its output should be unaffected by the BF input.
Thus, as long as the same query is executed on every node of
the BF tree, the P C input should remain the same at every

Index Server 
Inde

ex S

Key synchronization 

Query Checker 

Garbled Policy Circuit 

Client 

Figure 2. Malicious-client secure protocol overview.

node. By reusing the same keys for all invariant inputs, we
guarantee this property. Likewise, the P C is evaluated once,
and its output key can be reused for every subsequent query-
policy conjunction gate.

QC does not learn anything about the query except its
topology, which it uses for constructing the policy circuit. We
may also avoid this leakage at some cost of efﬁciency by using
universal circuits for the policy. In fact, since the policy circuit
is only computed once per query, its size is not a critical point
for performance.
Supported policies. The system supports a rich class of
policies. The policy can be any function of the keywords, ﬁeld
names, and syntax (structure) of the query. An example of such
a policy is: any conjunctive query that includes the keyword
“lname = Obama” cannot include any keyword on the ﬁeld
“income.” While our design essentially supports any policy
that is dependent on the query, it doesn’t support policies that
might depend on the data as well. For instance, we would not
support a policy that prohibits queries that have fewer than 20
matching records.
Bloom ﬁlter FPR. The ﬁnal question we posed was how to
prevent C from faking positive query results by ﬂipping input
bits from its BF shares. C’s share is a pseudorandom mask,
and reveals no information on which bits in the BF are 1 or
0. In order to fake positive results, C must set k speciﬁc bits
to 1. C can only do this by ﬂipping bits, and it does not know
if any given bit is initially a 0 or a 1. By setting parameters
appropriately, we can choose a false positive rate (FPR) that
makes these events equally likely. This way C only succeeds
in setting any given bit with probability 1/2.
DB security and policy privacy. For each leaf node reached
in the tree traversal, IS sends C a ﬁnal garbled gate that
computes the AND of the policy and universal query circuit
outputs. IS sends the record R associated with this leaf node
to C, but encrypted under the output key OUT1
R of this ﬁnal
gate. Concretely, C needs to obtain the 1-key output of both
the garbled P C and U Q in order to obtain OUT1
R and decrypt
the record received.

While policy failure prevents the client from feasibly ob-
taining any records of the database, the tree traversal pattern
still leaks partial information about the database. Alternatively,

evaluating the conjunction of P C and U Q at the root of the
search index prevents such leakage, but arguably affords less
privacy to the policy. In fact, the policy conjunction can be
evaluated anywhere inside the tree traversal, and this design
decision is left open.

We formalize and prove security properties of our system
in Section V. These properties are proved with respect to
a malicious client adversary and a semi-honest index server
adversary. The deﬁnitions are general enough so that open
ended design decisions do not invalidate any of the proofs
(e.g. where to evaluate the PC), and are intended to elucidate
the tradeoffs of such decisions.
Optimizations. To optimize performance, the universal query
circuit protocol is only run on leaf nodes of the Bloom ﬁlter
tree index, where it matters the most. As a further optimization,
the policy circuit will only be evaluated once, and its output
key will be reused for each leaf node.

III. SEMI-PRIVATE FUNCTION SFE

Private Function Secure Function Evaluation (PF-SFE) is
a two-party functionality in which a private function known
only to one party (the selector) is evaluated on private inputs
of both parties, and nothing but the outputs and function size
is revealed. Semi-private function SFE (SPF-SFE) [29] is a
generalization of PF-SFE in which the private function is
chosen from any restricted class of functions known to both
parties.

Since Yao’s GC protocol reveals only the circuit topology to
the evaluator, it can be viewed as a special case of SPF-SFE,
where both parties may learn the topology T of the private
function, but only the selector knows the identity of each gate
in the circuit (AND, OR, XOR, etc). This requires the function
selector to be the garbled circuit generator. Here, our goal is
to construct such a protocol where the function selector is the
garbled circuit evaluator. While it is known that this (and even
PF-SFE) can be accomplished using universal circuits (UC),
applying a general UC transformation would be expensive.
Instead, in this section we present a simple protocol which is
virtually as efﬁcient as the standard Yao GC protocol, as long
as the circuit topology is monotone, with all negations pushed
to the input level (any circuit can be easily and efﬁciently
converted to this form). To achieve this, we capitalize on the
fact that the topology T is known to both parties, and take
advantage of the free-XOR technique.
U CT construction. First, a fan-in two (i.e. two wires per
gate) circuit with topology T is constructed out of universal
gates, or “blank gates” that do not have any pre-deﬁned
functionality. A third input wire is added to each universal
gate, and represents the value of the gate (either AND or OR).
Equivalently, each universal gate is a function G(b, x, y) of
three bits so that G(0, x, y) = OR(x, y), and G(1, x, y) =
AND(x, y). Next, each fan-in 3 universal gate is replaced by
the fan-in two cluster:

b ⊕ ((x ⊕ b) ∨ (y ⊕ b))

399399

Protocol 3.1: Yao Semi-Private Function SFE with Selector
As Evaluator
Party P1 selects a monotone boolean circuit C. P1 has input
x and P2 has input y. The topology T = topo(C) is known
to both parties.

1) P2 constructs the universal circuit U CT and generates
U CT according to the
its corresponding garbled circuit
U CT to
free-XOR GC protocol. P2 sends the tables of
P1 along with the keys corresponding to the input bits
y.

˜

˜

2) P1 runs OT with P2 to receive the keys corresponding

to its input bits x and its gate value bits b.

3) P1 evaluates the garbled circuit

˜

U CT and obtains the

output.

Efﬁciency. Each gate of the original circuit is replaced with
a cluster of 3 XOR gates and 1 OR gate. Thus, the number
of non-XOR gates remains constant. The cost of applying
the free-XOR GC protocol to U CT is roughly the same as
applying it to the original circuit.
Applications. The capabilities of the generator and evaluator
in Yao GC are not symmetric, particularly when dealing with
malicious adversaries. For instance, Protocol 4.1 is useful for
repeated SPF-SFE, where the same private function is to be
evaluated more than once on different inputs, or possibly given
as input to other functions. The selector could cheat as the
garbler by using different functions for each set of inputs.
But when the selector is the evaluator, the garbler can enforce
consistency of the function. A special case is the problem that
we address in Blind Seer, where the private function (client’s
query) must be evaluated on the DB index and also supplied as
input to the policy check. A second capability of the generator
is to encrypt a message under an output key from the garbled
circuit so that the evaluator can only decrypt the message
contingent on the output of the function.

IV. SYSTEM PROTOCOL

This section details our new system protocol for Blind Seer.
We describe the protocol for a single client C, a server S, and
an index server IS. The outline of the protocol is as follows:
Stage 1: Preprocessing. S encrypts the database, builds an
encrypted Bloom ﬁlter tree index, and sends these encrypted
objects to IS.

Stage 2: Client queries. C builds a logical circuit Q
representing its query, sends Q’s topology to IS, together with
hashes of all the ﬁeld names and ﬁeld values used in Q.
IS uses Q’s topology to construct a universal query circuit
U Q (Section III) equivalent to Q with output keys OUTU Q
u ,
u ∈ {0, 1}.

Stage 3: Policy evaluation. The query checker QC gener-
ates and sends C a garbled policy circuit (PC), C obtains the
keys for evaluating PC from IS, and C computes the output
key of the policy evaluation OUTP C

, p ∈ {0, 1}.

Stage 4: Tree traversal. C and IS begin a multi-threaded
traversal of the Bloom ﬁlter tree index, evaluating the query
Q on each node processed using Yao GC with C as generator

p

400400

and IS as evaluator. Upon reaching a leaf node, the protocol
proceeds to Stage 5.

Stage 5: Leaf (record) nodes. When a leaf node is reached,
IS and C use the universal circuit UQ constructed in Stage 2
and the SPF-SFE protocol (Protocol 3.1) to evaluate Q on
u , u ∈ {0, 1}. In addition, IS
that node, and outputs OUTU Q
and OUTP C
sends C a garbled AND gate that takes OUTU Q
as input, and gives a ﬁnal output key OUTu·p. IS sends to C
the encrypted record ˜
R at this leaf node doubly encrypted as
EncOUT1

( ˜
R).

to obtain OUT1, and decrypts EncOUT1 ( ˜

Stage 6: Record retrieval. When a query is successful in
satisfying both U Q and P C, C uses the output keys OUTU Q
R). Fi-
and OUTP C
nally, C uses the decryption keys obtained from the server
S to decrypt ˜
R. Note that C always asks for the decryption
information from S and always receives an encrypted record
from IS, however, it only is able to successfully decrypt the
record if both U Q and P C evaluated to true.

u

p

1

1

Stage 1: Preprocessing

Shufﬂe and Encrypt Records.
Let (Gen, Enc, Dec) be
a semantically secure homomorphic public key encryption,
(gen, enc, dec) a semantically secure symmetric key scheme.
S randomly permutes the database records, and encrypts each
record Ri as:
(pk , sk )← Gen(1λ), si←{0, 1}λ, ˜si← Encpk (si),
S sends (pk ,{(˜si,
Generate Encrypted Index. S builds a balanced b-ary tree
index T of Bloom ﬁlters. Each leaf of the tree is associated
with a unique database record, and a Bloom ﬁlter holding all
of that record’s indexed keywords. Each internal node ﬁlter
Bv holds all of the keywords of its children.

i=1) to IS.

Ri)}n

Ri← encsi (Ri).

˜

˜

function

We introduce a subtle but signiﬁcant change to the format of
keyword insertions. For the purpose of efﬁcient policy check-
ing, C will separately submit hashes of both the ﬁeld names
and keywords in its query. In order to bind corresponding
keyword hashes and ﬁeld hashes, S inserts the concatenation
of these hashes into the Bloom ﬁlters.
random keys
Hash
generation.
S
kc, ks←{0, 1}λ. S sends
and
kc
functions
to
IS. S then
sends
ks
: {0, 1}∗→[(cid:2)]}η
H = {hi
i=1. S can choose H1, H2
independently and set hi(x) = H1(x) + i · H2(x) [16]. ((cid:2) is
chosen to satisfy the desired false positive rate). We use the
notation H(x) = {hi(x) : hi ∈ H}. Keyed hashes are derived
naturally as Hk(x) = H(k||x).
Inserting keywords. To insert the keyword field : value in
a ﬁlter Bv of length (cid:2)v:

chooses
to C and QC,

generates

hash

(Hkc

• Derive the set I of BF index values by computing
(field)||Hkc
I = Hks
• ∀i ∈ I, set Bv[i mod (cid:2)v] = 1
BF mask: Let F denote a pseudorandom function (PRF). S
chooses a new key key←{0, 1}λ for the PRF. Let T denote

(field : value))

(cid:4)
ψ(n).

Bv := Bv ⊕ Fkey(v).

Bv}v∈T to IS and (key,H, F ) to C.

the BF tree. The ﬁlter Bv is masked as: ˜
S sends { ˜
Prepare Decryption Keys. To reduce online query latency,
the index server and the server precompute decryption keys.
S holds the decryption keys s1, ..., sn that it used to sym-
metrically encrypt the records. It also holds ˜si = Encpk (si)
for all i. S sends to IS these values ˜s1, ..., ˜sn. IS chooses a
random permutation ψ, and random values r1, ..., rn. IS ho-
(cid:4)
momorphically computes ˜si + Enc(ri) = Enc(si + ri) = ˜s
ψ(i)
for all i, and sends these value back to S. S decrypts and stores
(cid:4)
ψ(1), ..., s
s
Multiple clients. Although the description of the system
protocol is for a single client, we can easily support multiple
clients without compromising security as long as the clients
do not collude. Under this assumption, we can actually use the
same keys for all clients. However, if all clients use the same
key kc to encrypt their query keywords, then IS may correlate
the queries of different clients. To prevent this, the server S
can distribute separate keys kc to each client, and insert each
keyword into the BF separately for each client encrypted under
that client’s key. The disadvantage of this additional security
measure is that the size of the BF will scale not only with the
size of the data but also with the number of clients.

Stage 2: Client Queries

Every query in the Blind Seer DBMS can be represented
as a monotone boolean logical formula over atomic search
terms. There are three types of atomic search terms: keywords,
ranges, and negations. However, in Blind Seer, any range query
from a ﬁeld with value range r is translated into a disjunction
of O(log r) keywords queries. A negation of a keyword α is
translated into a disjunction of two range queries (i.e. x < α
OR x > α), which is again converted into disjunctions of
keyword queries. Thus, the ﬁnal representation of a query is
a monotone logical formula over solely keyword terms (see
[28] for details).
Query circuits. Queries are computed by query circuits. A
query circuit transforms each atomic keyword term α into a
small circuit computing the presence of α in an input Bloom
ﬁlter. This is simply a conjunction of the bits at the η BF hash
indices of α, but since C and IS hold separate shares of the
input Bloom ﬁlter, it is actually a conjunction of η XOR gates.
Committing to Q. For the purpose of malicious-security, we
force C to effectively commit to its query circuit Q as follows.

1) C sends topo(Q) to IS.
2) For each keyword of the form field : value, C sends
to IS the hashes: Hkc (field)||Hkc (field : value).
3) IS generates a garbled universal circuit U Q from
topo(Q) as described in Section III. Each gate in the
query formula layer of Q is associated with a pair of
keys in U Q. OR maps to a 0-key, and AND maps to a
1-key.

4) C does OT with IS to receive the keys corresponding to

the gate values (i.e. AND/OR) of U Q.

5) IS computes the set of indices:

Hks (Hkc (field)||Hkc (field : value))
for each keyword field : value, and sends these
back to C.

Stage 3: Policy evaluation

At

(FQ) = (Hkc

(KQ) = (Hkc

(α1), . . . , Hkc

the end of Stage 2,

(field)||Hkc

IS has received topo(Q) and
(field : value) for
hashes of the form Hkc
each keyword, and has generated U Q. We denote by GQ =
(g1, . . . , gn) the gate value inputs to the garbled U Q, and by
KQ = (α1, . . . , αt) the query’s keywords. Each keyword αi
is associated with a ﬁeld fi. We use the following notations:
FQ = (f1, . . . , ft), Hkc
(αt)), and
(ft)). Recall that QC receives
(f1), . . . , Hkc
Hkc
kc from S during preprocessing.
Policy functions. A query policy is any function p: Q →
{0, 1}, where Q is the space of queries. Our system can
implement as a policy any boolean function of the query
keywords, ﬁelds, and syntax (with a tunable probability of
error). More precisely, we can implement any function of
(Q, Hkc (KQ), Hkc (FQ)), and so the error probability of sim-
ulating p is proportional to the collision probability of H.
Policy circuit structure. There are three types of inputs to
policy circuits: gate values GQ, keyword hashes Hkc (KQ),
and ﬁeld hashes Hkc (FQ). A policy circuit consists of an
upper logical
layer built over a bottom layer of keyword
check gates and ﬁeld check gates. A keyword check gate is
associated with a blacklist/whitelist set of keywords, and
evaluates whether its input hashed keyword Hkc (α) is in the
set. Likewise, each ﬁeld check gate is associated with a subset
of the database ﬁelds, and indicates whether its input hashed
(f ) is a member of that set. The inputs GQ are fed
ﬁeld Hkc
directly into the logical layer along with the outputs of the
keyword check gates and ﬁeld check gates.
Keyword check gates. Let L denote the blacklist/whitelist of
the gate, and let α denote the keyword submitted by the client.
(w) for all
QC initializes a Bloom ﬁlter, and inserts into it Hkc
w ∈ L. QC generates a mask for this ﬁlter and sends it to IS.
Recall that IS holds Hkc (α). QC and IS build a garbled circuit
evaluating the presence of Hkc (α) in the ﬁlter, and send both
the garbled circuit and its input keys to C for evaluation.
Field check gates. Let F = {f1, . . . , fm} denote the ﬁelds
of the database schema. Let π : [m] → [m] be a random
permutation. A ﬁeld check gate consists of the following
elements.
− Field function. A boolean function b : F → {0, 1}.
− Permuted key table. A table of keys [kπ(1), . . . , kπ(m)]
− Output keys. A pair of output keys kOUT
− Garbled table. A table of encrypted output keys:
b(fπ(m)))]

b(fπ(1))), . . . , enckπ(m)

[enckπ(1)

(kOUT

, kOUT

1

.

0

(kOUT

Evaluation: The private evaluation of a ﬁeld check gate on a
ﬁeld field between QC, IS, and C is very simple. IS receives
Hkc (field) from C. QC sends the permuted key table along
with the mapping of ﬁeld hashes into the table so that IS may
(field), and send it to
locate the key corresponding to Hkc

401401

C. QC sends the garbled table to C, who locates and decrypts
the appropriate output key using the input key received from
IS, exactly as in Yao.
Policy False Positives and Negatives. The use of Bloom
ﬁlters for evaluating the keyword gates introduces a tunable
false positive rate in the outcome of the gate. This contributes
to either a false positive rate F P Rp or false negative rate
F N Rp of the overall policy, depending on how the keyword
gates are used in the logical layer of the policy circuit (e.g.
keyword blacklists may cause false rejects, and keyword
whitelists may cause false approvals). Since the protocol only
requires storing one relatively small policy circuit in RAM,
we can afford to make the false positive rates of the keyword
gate Bloom ﬁlters sufﬁciently small. For example, a policy
that has 10 keyword gates, 10 keywords per gate ﬁlter, and
overall error rate 2−256 would only require approximately 4.6
GB of space at most.
Policy protocol.

IS initiates the policy evaluation.

1) IS sends topo(Q) to C along with key pairs for the
gate value wires of the garbled U Q (i.e. the key pairs
for the inputs GQ).

2) Given topo(Q), QC generates the policy circuit P C.

The input to P C is (GQ, Hkc (KQ), Hkc (FQ)).

0

3) QC generates a garbled circuit from P C. It sets the key
pairs for the inputs GQ using the key pairs received from
IS, and it generates all other key pairs randomly (as in
the usual Yao garbled circuit construction). It sends the
garbled tables of P C to C, and sends the key pairs for
all the input wires to IS. Additionally, it sends the key
pair {OUTP C
1 } for the policy output wire to IS.
4) Using the table of keys received from QC, IS identiﬁes
(KQ)
the input keys to P C corresponding to inputs Hkc
(FQ). IS sends these keys to the client. Note that
and Hkc
the client has already received the keys for the inputs GQ
via OT in Stage 2 (these are the same input keys that C
will use for evaluating U Q in Stage 5).

, OUTP C

5) Finally, C uses the keys received from IS in (4) and the
garbled tables received from QC in (3) to evaluate P C,
, p ∈ {0, 1}.
and obtains the output policy key OUTP C

p

Stage 4: Tree traversal

C and IS begin a multi-threaded breadth ﬁrst traversal of the
Bloom ﬁlter index tree. They do not process leaf nodes at this
stage. At any non-leaf node v visited, C and IS evaluate Q on
the Bloom ﬁlter Bv (IS’s input bits are derived from ˜
Bv and
C’s input bits are derived from the mask Fk(v) at the hash
indices computed in Stage 2). They use the following Yao GC
variant:

1) C garbles Q and sends the garbled circuit to IS. C also

sends keys for its own input bits.

2) IS executes OT with C to obtain Yao keys for its input
bits, evaluates the garbled circuit, and sends the output
key back to C.

3) C learns the output value from the output key.
When the output value of Q is 1, C visits all of v’s children

nodes. Otherwise, C terminates the path at v.

Stage 5: Leaf nodes

When C and IS reach a leaf node v corresponding to record
index i in the search procedure of Stage 4, IS selects keys
(OUT0, OUT1), encrypts ˜
( ˜
Ri), and
sends to C the tuple (ψ(i), ri, E( ˜
Ri)). In addition, IS sends to
C the garbled AND table:
(OUTi∧j||i ∧ j))]

Ri) = EncOUT1

Ri as E( ˜

(EncOUTP C

[EncOUT

IS constructed U Q in Stage 2 and C has already obtained
the keys corresponding to its gate value inputs via OT. Addi-
tionally, both IS and C already have the sets of Bloom ﬁlter
indices Iα for each keyword term α in the query. IS has a
masked Bloom ﬁlter ˜

Bv. C has a mask Fk(v). Now:

U Q
i

j

1) IS generates a new garbled U C using fresh key pairs for

2) IS sends to C the keys corresponding to its input bits

all wires except the gate value input wires.
{ ˜
Bv[i]}i∈Iα for each α.
to its input bits {Fk(v)[i]}i∈Iα for each α.

3) C performs OT with IS to receive the keys corresponding

output key OUTU C

u , u ∈ {0, 1}.

C has already obtained an output key OUTP C

4) Finally, C evaluates the garbled U C and obtains an
, p ∈ {0, 1},
from P C in Stage 3. If p = u = 1, then C can successfully
obtain OUT1 and decrypt E( ˜
Ri). Otherwise, C cannot feasibly
deduce any information about ˜
Stage 6: Record retrieval

Ri other than its size.

p

When C reaches a record Ri, IS will send it ψ(i), ri, and
(cid:4)
E( ˜
(i). C
Ri). C then sends ψ(i) to S, who sends back s
ψ(i) − ri. If C successfully decrypted E( ˜
ψ
(cid:4)
Ri) to
obtains si = s
obtain ˜
Ri using si, and
obtains the record Ri. Otherwise, C cannot feasibly deduce
any information about Ri other than its size.

Ri in Stage 5, then C now decrypts ˜

V. SECURITY AND PRIVACY ANALYSIS

Privacy and security in the Blind Seer system was previously
achieved with respect to semi-honest static adversaries [28].
An ideal functionality Fdb was deﬁned, and included a leakage
proﬁle describing the precise information that is leaked to each
of the parties C, S, and IS. A standard simulation argument in
the semi-honest static adversary model attests that Blind Seer
securely realizes Fdb.
The main contribution of the present work is a mechanism
that we claim strengthens the security of Blind Seer against
a malicious client adversary in numerous respects including
privacy, data protection, and access-control. The preceding
sections presented the security beneﬁts of our new mechanism
in conceptual terms, and with a focus on how they address
the vulnerabilities of Blind Seer’s previous design. The goal
of this section is to characterize these security properties more
precisely in formal deﬁnitions, and to prove that our new Blind
Seer protocol realizes these properties.
Security properties. We distinguish and analyze four prop-
erties of the system.

Query indistinguishability captures the inability of

the
server (or index server) to distinguish between queries that

402402

the client may submit. Blind Seer does not achieve perfect
query indistinguishability. The query security of the original
Blind Seer was analyzed using the simulation paradigm. It was
shown that the client’s queries reveal nothing to the semi-
honest server and index server beyond a speciﬁed leakage
proﬁle. Essentially, the leakage proﬁle for the server included
record retrieval patterns, and the leakage proﬁle for the index
server included the search tree traversal pattern and deter-
ministic hashes of the query keywords (i.e. BF indices). In
terms of indistinguishability, this simulation security implies
that the server (resp. index server) cannot distinguish between
two queries that have the same (or indistinguishable) leakage
proﬁles. Simulation security is actually a stronger notion
than indistinguishability. The new system mostly preserves
the privacy of the client’s query that the original Blind Seer
offered, but with some additions to the query leakage proﬁles.
We do not include the full proof of simulation security in this
paper, but we will describe the new query leakage proﬁles.

Policy compliance indistinguishability expresses that com-
pliant queries with zero results and non-compliant queries
are indistinguishable provided that they have identical index
traversal patterns. Policy soundness is the extent to which the
system prevents the release of information on non-compliant
queries. Query soundness is the extent to which the system
prevents the release of information from records that do
not satisfy the query. We show that non-compliant queries
reveal no information about the DB payload—the non-indexed
primary data contained in the records of the DB. Similarly, we
show that queries reveal no information from the payload of
records outside their result set.

The strongest notions of policy and query soundness would
require that the amount of information revealed is negligible.
However, as previously discussed, Blind Seer’s search mech-
anism may reveal some partial information about the indexed
DB data, especially to a malicious client. Thus, the client
may learn some meta information even on records that are not
ultimately returned. The only way to prevent all leakage on
non-compliant queries is to prevent the client from evaluating
non-compliant queries on any part of the DB index. This would
create an inherent asymmetry in the processing of compliant
and non-compliant queries, detracting from policy privacy. We
made a conscious design decision to compromise full policy
security for policy privacy.
Multiple clients. Our analysis assumes a single client.
However, the proofs naturally extend to multiple client parties
as long as there is no collusion among the parties. If there
is collusion between parties, then the proofs still apply to
the combination of those parties as a single entity. We note
that collusion between a client and the index server IS would
compromise security for everyone.
Indistinguishability vs. simulation. Our analysis will use
indistinguishability games rather than the simulation paradigm.
Some of the primitives we implemented are not simulatable
in malicious and/or concurrent settings, speciﬁcally Naor-
Pinkas OT, which we use during the multi-threaded traversal

of the Bloom ﬁlter. This technical issue could be resolved
by implementing a UC-secure OT primitive such as PVW
[30] instead of Naor-Pinkas [25] and using simulatable UC-
secure OT extension protocols1, or the server S could actually
distribute random OTs during the preprocessing phase.
OT Extension Security. As previously mentioned, our OT
extension protocol does not satisfy a simulation-based deﬁni-
tion of security in our setting, which involves both concurrency
and a malicious receiver party (the client).

Nonetheless, we can prove that it is sufﬁciently secure for
the malicious-client security properties that we ultimately want
to prove. Informally, the property we need is that no malicious
(cid:2)
(cid:3)
receiver can feasibly output both messages in any individual
1
-OT when the messages are independent and random.
2
Let OT-EXTp(k)

(cid:3)
m denote an instance of our OT extension
protocol producing p(k) preprocessed
-OTs of length m
strings, where k is a security parameter and p is a polynomial.
OT-EXTp(k)
) is
i
) are
Sender’s output, eri
independent and random, and r ← {0, 1}p(k) is uniformly
i
distributed. We prove the following Lemma in Appendix B.
Lemma 1. No adversary corrupting Receiver in a poly-
nomial number of concurrent and independent OT-EXTp(k)
sessions can output both e0
i from any individual session
with probability greater than negl(k).

m outputs {(e0

i , e1
i , e1

i and e1

i , e1

i=0 , where (e0
is Receiver’s output, All (e0

), (eri
i

i

m

(cid:2)

1
2

)}p(k)

i

In what follows we will refer to the new system protocol

as mBS, for malicious Blind Seer.

Client query privacy

We describe the client query leakage proﬁles for the server
S, the index server IS, and the query checker QC. Only the
leakage to IS and QC has changed from the original Blind
Seer design. The new leakage to IS amounts to patterns in
the keyword ﬁelds (e.g., columns) used in the query, and the
new leakage to QC is the query topology. We note that it is
straightforward to update the formal analysis of the original
Blind Seer design to incorporate these new leakage proﬁles,
but we will not include here the updated analysis.
Leakage to S in each query. Let R1, ..., Rn denote the
)) denote
records of the database and let ((i1, Ri1
[n] → [n] denote a random
the query results. Let π :
permutation (unknown to S, but ﬁxed for all queries). The
leakage to the server is (π(i1), π(i2), . . . , π(ij)).
Leakage to IS in each query.
The leakage to IS
includes
the BF-search tree traversal paths,
the topol-
the query topo(Q), and the pairs of hashes
ogy of
Hkc (field)||Hkc (field : value) for each of the client’s
keywords field : value included in the query. This leakage
reveals to IS when two different keywords in the query share
the same ﬁeld. (In contrast, the previous design only leaked

), . . . , (ij, Rij

1There are various OT extension protocols offering full simulation security
in the malicious adversary model that also have constant amortized cost [11],
[27], but these protocols still have constant factor overheads that are relatively
expensive.

403403

hashes of the keywords in the query, and so IS only learned
when full keywords repeated).

These leakage proﬁles imply that S cannot distinguish any
two queries that access the same number of records and IS can-
not distinguish any two queries that have the same number of
repeated keywords/ﬁelds, indistinguishable traversal paths, and
identical topologies. However, both S and IS may respectively
accumulate record retrieval and query pattern information over
many queries.

Policy and query soundness
We ﬁrst deﬁne the notion of payload indistinguishability.
Assume that each record R of the DB has a payload L, the
main data associated with the record, and separate metadata
M, or the keywords that index the data. We write R =
(L,M). Queries are evaluated on the metadata, so for any
boolean query q we can write q(M) ∈ {0, 1}.
Deﬁnition 1. Let Σ(D, λ) denote a DBMS mechanism ex-
ecuted on input database D with security parameter λ. We
(A, λ) played with an
deﬁne the following game Game
adversary A.

PAY-IND
Σ

PAY-IND
Σ

(A, λ):

b

1

Σ

Σ

b

) = 1.

b

PAY-IND
Σ

1, ..., Rn

0 = Li

1 ) where Ri
b

0, ..., Rn
b,Mi

(cid:4) = b, output 1. If b

(A, λ) = |P r[Game

A chooses D0 = (R1
= (Li

Game
−
0 ) and D1 =
) and Mi
0 = Mi
(R1
∀i.− Sample b ∈ {0, 1} uniformly at random.
1
− The protocol Σ(Db, λ) is executed with A in the
querier’s role. A outputs a decision bit b
(cid:4).
(cid:4) (cid:9)= b, output 0.
− If b
(A, λ) = 1] −
(A, λ) < negl(λ) for any poly time adversary

Deﬁne AdvPAY-IND
2|. If AdvPAY-IND
A, then the mechanism Σ is payload indistinguishable.
More generally, we deﬁne f-payload indistinguishability by
1 for all i where f (Mi
modifying the game so that Li
) =
0, i.e. the payloads are only indistinguishable on records for
which f (Mi
Theorem 1. An execution of mBS on any policy p and query
q such that p(q) = 0 is payload indistinguishable.
Proof. We prove the claim by reduction to the semantically
secure encryption scheme Π = (gen, enc, dec) used by mBS.
Let us ﬁrst unfold the meaning of executing mBS on policy
p and query q. The policy p is deﬁned by an input to the
semi-honest party QC. However, since C is now a malicious
adversary A, the query q deﬁned by the actions of A may
be unrelated to anything on C’s initial input tape. A commits
to the query circuit Q that is ultimately evaluated on the DB
records when it sends the circuit topology, sends the keyword
and ﬁeld hashes, and receives keys in {0, 1}k representing
the gate values of Q using OTs generated by the subprotocol
. If A submits ill-formatted messages, then the
OT-EXTp(k)
protocol is aborted, and the query is considered empty. Thus,
Q is uniquely determined unless A is able to obtain more
than one valid key for each OT, the probability of which is
negligible in k by Lemma 1.

k

1

Σ

1−p(Q).

(A, λ) ≤ AdvIND

The garbled policy circuit P C and evaluation keys in
{0, 1}k that A receives are derived from the same information
that determines Q. As long as Q is uniquely determined, the
following hold except with probability negligible in k: A only
obtains the keys that allow it to compute the output policy key
p(Q), and the security of Yao GC evaluation guarantees
OUTP C
that A cannot obtain the key OUTP C
Any record payload L that A receives is encrypted using
1 = gen(1k). We have seen that
enc with the key OUTP C
A cannot compute OUTP C
when p(Q) = 0 except with
1
some negligible probability (k). Thus, it is easy to see that
Π (A, λ) + (k) < negl(k) by
AdvPAY-IND
semantic security of Π (cf. Appendix A).
Theorem 2. For any query q, let ¯q denote its negation so that
¯q(D) is the set of records that fail q. An execution of mBS on
any query q is ¯q-payload indistinguishable.
Proof. For any record R = (M,L) that A receives, L is
encrypted using enc with a key OUTU Q
that is output by the
garbled U Q circuit evaluated on M. As noted in the analysis
of policy soundness (Theorem 1), the query q is uniquely
determined by A’s messages to IS except with probability
negligible in k, the security parameter of Π = (gen, enc, dec).
We show that if q(M) = 0, i.e. ¯q(M) = 1, then A cannot
obtain OUTU Q
1 with probability greater than negl(λ) where λ
is the minimum of k and the Bloom ﬁlter FPR used at the leaf
nodes of the tree index. In the ¯q-payload indistinguishability
game, the payloads Li
1 are
identical unless ¯q(Mi
1) = 1. Once we establish
1 when ¯q(M) = 0 is
that A’s probability of obtaining OUTU C
negligible in λ, ¯q-payload indistinguishability reduces to the
semantic security of Π, as in Theorem 1.
Consider A’s evaluation of U Q on record R. As with the
policy, A can only obtain one valid set of input keys, and can
only compute one valid output key, except with probability
negl(k). However, unlike the policy evaluation keys, the keys
that A obtains to evaluate U Q are not solely determined from
the information that deﬁnes the query circuit Q. The reason
is that A has some control over the DB inputs to U Q. Recall
that for each BF node Bv, the client C holds a mask string
Bv = Bv⊕mv. The circuit U Q
mv = Fk(v) and IS holds ˜
computes XORs of bits taken from m and Bv. Nothing prevents
A from ﬂipping bits in mv when evaluating U Q.
We investigate A’s success probability in ﬂipping the output
of U Q from 0 to 1. Because Q is monotone over its keyword
predicates, A must succeed in ﬂipping the output of at least
one keyword predicate Pα from 0 to 1 in order to succeed.
Suppose A receives η indices α1, ..., αη for a keyword α that
has not been inserted into the ﬁlter Bv, i.e. Pα(Bv) = 0.
There is a unique vector of bits zα = (zα1 , ..., zαη
) such that
Bv[αi]⊕zv[αi] = 1 for each i. A must guess zα to succeed.
˜
zα is actually a random variable over the randomness in
the initialization of Bv. The bits of Bv were set via insertions
of keywords (distinct from α) using Hks, where ks is secret
from A, and H is a family of random oracles by assumption.
Therefore, zα is distributed independently from A’s view of

0 and Li
0) = ¯q(Mi

1 of records Ri

0 and Ri

404404

the protocol. Recall that the BF parameters are set so that
the FPR is 2−η. Together with the simplifying assumption
that the bits zαi are η-wise independent, the FPR implies that
P r[zαi = 1] = 1/2 for each i, and that the min entropy zα is
2−η.2

False positives. The above theorems (policy soundness and
query soundness) do not account for false positives in the result
set q(D) due to false positive hits in the Bloom ﬁlters repre-
senting the indexed records. This threat becomes negligible
when the FPR of the Bloom ﬁlter is made negligible. Even
a malicious client who has learned some bits of the Bloom
ﬁlter (e.g. from previous queries) and attempts to deliberately
choose a query that incurs a false positive has negligible
advantage over the FPR because our Bloom ﬁlters use non-
invertible (cryptographic) hash functions.

Policy compliance indistinguishability

There are three possibilities when a query returns no results:
the query was noncompliant, the query actually had an empty
result set, or both. The client cannot ever tell with certainty
which one of these is true. However, the search pattern may
give the client heuristic reasons to believe one possibility over
the other. For instance, if the policy is evaluated at the leaves
and a query traversal reaches many leaf nodes in the DB index
before failing on all, the client may reasonably infer that the
query is failing the policy.

Thus, a deﬁnition that requires complete indistinguishability
regardless of the database and query would be too strong for
mBS to satisfy. Instead, we use a deﬁnition that incorporates
a database equivalence relation Eq parametrized by the query
q. Similar to a leakage proﬁle, Eq factors out instances where
the adversary may defeat the indistinguishability game, for
reasons either related or unrelated to distinguishing query non-
compliance from empty results.
Deﬁnition 2. We deﬁne the policy compliance indistinguisha-
PC-IND
bility game Game
Σ

(A, Eq, λ) as follows.

PC-IND
Σ

(A, Eq, λ):

Game
− A chooses a query q, databases (D0, D1) ∈ Eq,
and policies p0, p1 such that p0(q) = 1, q(D0) =
0, and p1(q) = 0.
− A bit b is sampled uniformly at random.
− The protocol Σ(Db, q, pb, λ) is executed with
A in the querier’s role. A outputs a decision bit b
(cid:4).
− If b
(A, Eq, λ) = 1] −
AdvPC-IND
2|. If AdvPC-IND
(A, Eq, λ) < negl(λ) for any poly time adver-
sary A, then Σ satisﬁes policy compliance indistinguishability
with respect to Eq.

(cid:4) = b, output 1. If b
(A, Eq, λ) = |P r[Game

(cid:4) (cid:9)= b, output 0.

PC-IND
Σ

Σ

1

Σ

2It is inaccurate to assume that all BF bits are mutually independent.
However, η-wise independence of the {zαi}η
i=1 is easily obtained. With an
FPR of 2−η, the fraction of 1s in the BF cannot be more than 1/2 after all
word insertions. If smaller, we can randomly set BF bits until exactly 1/2 are
1. The distribution of the ﬁnal subset of 1s is uniform, independent of H(α).
Thus, the {zαi}η
i=1 are independent if η < (cid:4)/2, where (cid:4) is the BF length.

405405

We formally deﬁne an equivalence relation ≡q for mBS.
First, the relation must express traversal pattern equivalence.
Otherwise, A could distinguish executions of q on D0 and
D1 whenever the traversal patterns differ. In certain instances
the traversal pattern may actually reveal policy failure (e.g.,
a search for a single name that returns true at the root and
fails on every single record must be non-compliant). This
instance is eliminated from the game by requiring that the
traversal patterns are identical for both the compliant and non-
compliant scenarios. Formally, let Iπ(·) denote the DB index
construction function of mBS using the record permutation
π. Let T P (q, Iπ, D) denote the distribution of traversal pat-
terns induced by q on Iπ(D) for randomly sampled π. If
D0 ≡q D1, then T P (q, Iπ, D0) ≈ T P (q, Iπ, D1). Further,
since the client generates the query circuit for the internal
nodes, a malicious client can compute an arbitrary single bit
of the BF inputs at each node. Thus, ≡q must express the
stronger condition that corresponding Bloom ﬁlter nodes in
the two databases must be identical on all indices the query
touches. This does not include the last layer, where policy and
U Q circuits are evaluated.
Theorem 3. mBS satisﬁes policy compliance indistinguisha-
bility with respect to ≡q.
Proof. Given the strict deﬁnition of ≡q, A’s views of the ex-
ecutions mBS(D0, q, p0, λ) and mBS(D0, q, p0, λ) are iden-
tical up until the failure nodes where U Q ∧ P C is evaluated
with Yao GC. If A can distinguish the intermediary outputs
of U Q and P C, it would contradict the security of Yao.

VI. IMPLEMENTATION AND EVALUATION

We implemented a prototype of our design in C++. In this
section, we describe some interesting choices we made during
the development of the prototype, and show experimental
results.
OT pool. One important component of our system is the OT
pool. This pool contains preprocessed Oblivious Transfers that
are used in garbled circuit evaluations. The OT pool is ﬁlled
regularly using the OT extension protocol of [13], [26]. We use
the Naor-Pinkas [25] OT protocol as a base for OT extension.
Parallelism within queries. Our most important efﬁciency
improvement comes from query parallelization. While the
original Blind Seer implementation supported parallelization
between queries to improve throughput, our new system sup-
ports multi-threaded evaluation of the tree structures within a
single query to improve latency. Instead of having one global
OT pool for all threads, each thread has its own OT pool. This
signiﬁcantly decreases the standby time of ﬁlling a single OT
pool, as well as bypassing synchronization issues. We used
the Intel Threading Building Block library to implement most
of the parallelization used in the system.

Figure 3 shows query latency time plotted against

number of threads for the query

the

first:DIANE AND last:CASTRO

)
s
c
e
s
(
 

e
m
T

i

 500
 450
 400
 350
 300
 250
 200
 150
 100
 50
 0

 0

 2

Query Latency

 8

 10  12  14  16

 6

 4
Number of Threads

Figure 3. Query Latency versus number of threads on a 107 record database.
Run on a Boolean query with individually frequent terms but with sparse
aggregate results.

This query traverses a large fraction of the DB index, and
hence, clearly illustrates the beneﬁts from parallelization. We
see full utilization and improvement all the way up to 15
threads.
Cryptographic Tools. Our system requires pseudorandom
bits, used primarily for garbling circuits. We avoid expensive
system calls to /dev/urandom by implementing a PRG using
AES as a building block. All AES operations were performed
using 128-bit key length. We used SHA256 for hashing, and
implemented the keyed hash for keyword ingestion as an
HMAC using SHA256 as the underlying hash function. Since
OpenSSL uses the AES-NI instruction, we used this library to
implement our basic cryptographic primitives. Our system also
depends on operation on a group to which DDH intractability
applies. We used the standard quadratic residues subgroup of
Zp, where p is a 2048-bit strong prime. The group operations
were implemented using the GNU Multiple Precision library.
Tree Traversal. During tree traversal, each internal node
evaluation requires 4 rounds of communication. The client ﬁrst
submits the node identiﬁer to be evaluated and the garbled
circuit to be evaluated, then OT is performed (2 rounds), and
ﬁnally the index server sends back the output key. The roles
are reversed at the leaf nodes. Since these rounds involve
small packets, network latency becomes the bottleneck. In
order to reduce standby time, we batched the evaluation of
all sibling nodes. This reduced the number of rounds by 10
rounds. This batching technique is mostly helpful for queries
with low branching traversal patterns, e.g., a single root to
record path in the tree index.

A. Experimental Results

Our system was tested in a similar way to Blind Seer.
A synthetic 100-million record database mimicking the US
census data was constructed. Each database record contained
global unique ID, personal information taken from randomized
census,
text ﬁelds for free-text search, XML data, and a

payload of 100KB of random bytes used to simulate the cost
of transferring data in real-life practical applications.

Our system was compared against MySQL (having sepa-
rate indexes for each ﬁeld) using a special-purpose testbed
implemented by Lincoln Labs speciﬁcally for this purpose.
Each party ran on a separate machine equipped with two Intel
Xeon X5650 processors of 2.66Ghz and 12M cache, 96GB
RAM3at 1066 MHz, and Broadcom 1GB Ethernet NICS with
TOE each. Index Server and Server each had a 20TB raid
array attached also. All machines ran 64-bit Ubuntu 12.04LTS
as base OS.

We show next the efﬁciency of our system (running us-
ing 16 threads on full 100-million record DB) in terms of
query latency time for a number of representative queries:
single-term and size-3 conjunctive and disjunctive SELECT-
id queries. We also show that when using SELECT-* queries
on 100KB records, and thus incorporating a payload with our
interactions, the associated overhead which is constant for all
systems begins to dominate the costs of our system.
Boolean SELECT-id Queries. We compare the perfor-
mance of our system against MySQL. Figures Fig. 4, Fig. 5,
and Fig. 6 show the query latency for single-term, 3-term
conjunctions (with two low-entropy terms and one medium-
entropy term), and 3-term disjunctions as SELECT-id queries
plotted against the number of records satisfying them. While
original Blind Seer was 15 times slower than MySQL [28],
our implementation manages to be only 2-3 times slower than
MySQL for the case of single terms queries and 3-6 times
slower for conjunctive and disjunctive queries on 3 terms.
This saving is due to parallelization and low overhead of our
new construction. Note that these queries are SELECT-id, and
thus delivering a small payload. The relative overhead of our
system would decrease with larger payloads since this cost is
constant for both systems.
Single-term SELECT-* Queries. We measured query latency
of our system and MySQL for queries returning 100KB
records. Our system, as well as original Blind Seer, performs
better (compared to MySQL) when the records retrieved are
bigger. In this case,
the standby time required to submit
records’ data dominate the network usage. We can observe
from the results shown in ﬁgure Fig. 7 that our system is only
10% slower than MySQL in this setting.
Overhead of malicious-client security. As a validation of
the costs of our malicious-client algorithms, we also compare
the performance of our malicious-client secure Blind Seer
to that of the original Blind Seer. To eliminate extraneous
implementation performance variables, we compare the two
designs by running our current
implementation of Blind
Seer with and without the design changes introduced in this
work. In particular, the design differences potentially affecting
performance include two additional hash function calls per

3Although we ran the client on a machine with 96GB RAM, the client’s
actual memory consumption in our system is insigniﬁcant. The client only
needs to store a key and pre-processed OTs. In our experiments, the client
used approximately 200MB of RAM.

406406

)
s
c
e
s
(
 

e
m
T

i

 350

 300

 250

 200

 150

 100

 50

 0

 0

16T-Our
MySQL

 4000

 2000
Number of Records Returned

 6000

 8000

)
s
c
e
s
(
 

e
m
T

i

 400
 350
 300
 250
 200
 150
 100
 50
 0

 0

16T-Our
MySQL

 4000

 2000
 8000
Number of Records Returned

 6000

Figure 4. Single-term SELECT-id performance against number of records
returned for our system and MySQL.

Figure 7. Single-term SELECT-* performance against number of results
returned for our system and MySQL.

)
s
c
e
s
(
 
e
m
T

i

 160
 140
 120
 100
 80
 60
 40
 20
 0

16T-Our
MySQL

 0

 500  1000  1500  2000  2500  3000  3500

Number of Records Returned

Figure 5.
number of records returned for our system and MySQL.

3-terms conjunction SELECT-id queries performance against

16T-Our
MySQL

 12

 10

 8

 6

 4

 2

)
s
c
e
s
(
 

e
m
T

i

 0
 115  120  125  130  135  140  145  150  155  160  165

Number of Records Returned

Figure 6. 3-terms disjunction SELECT-id queries performance against number
of records returned for our system and MySQL.

keyword, the new semi-private SFE using a universal circuit,
an additional Oblivious Transfer per gate of the query circuit,
and one additional symmetric encryption and decryption per
record returned to C. The experiment consisted of running
single-threaded SELECT-id queries for single-term, 3-term
boolean queries containing a conjunction and a disjunction,
and range queries (which are each translated to a 5-7 term
disjunction [28]) over a 1-million record database. The results
are shown in ﬁgures 8, 9, 10. As expected, the design changes
for achieving malicious-client security incur no signiﬁcant
overhead. The costs of the design changes for malicious-client
security are proportional to the query size and number of
leaf nodes reached in the Bloom ﬁlter tree index traversal,
and not the total number of tree nodes processed. Thus, the
performance gap will be even smaller on large databases when
the number of leaf nodes reached is small compared to the
number of internal nodes processed, which we expect to often
be the case in practice.
Caching. We did not run experiments on repeated queries.
On repeated queries, MySQL beneﬁts from server-side caching
of query results. In our system, the client caches result sets
(database record indices) locally.

VII. RELATED WORK

Full privacy in a DBMS is possible to achieve using
cryptographic tools such as SPIR [4], [6], FHE [5], ORAM
[9], [10], [23], and MPC [8], [21], [32], [33]. However, all
such solutions are prohibitively expensive to be used in many
scenarios of interest where the amount data involved is large.
More efﬁcient private search solutions have been proposed
for more restricted scenarios. Allowing leakage of client access
patterns is a common relaxation, since it is required in order to
avoid the polylogarithmic overhead of ORAMs. Until recently,
these solutions only offered very limited search capabilities.
For a survey of different systems, we refer the reader to the
related work sections of [3], [14], [28].

407407

)
s
c
e
s
(
 

e
m
T

i

 100
 90
 80
 70
 60
 50
 40
 30
 20
 10
 0

Our Blind Seer
Original Blind Seer

 0

 500  1000  1500  2000  2500  3000  3500  4000

Number of Records Returned

Figure 8. Performance of our prototype against original Blind Seer for single-
term queries.

)
s
c
e
s
(
 
e
m
T

i

 300

 250

 200

 150

 100

 50

 0

Our Blind Seer
Original Blind Seer

 0

 500  1000  1500  2000  2500  3000  3500  4000

Number of Records Returned

Figure 9. Performance of our prototype against original Blind Seer for 3-term
boolean queries.

Our Blind Seer
Original Blind Seer

 600

 500

 400

 300

 200

 100

)
s
c
e
s
(
 

e
m
T

i

 0
 500  1000  1500  2000  2500  3000  3500  4000

Number of Records Returned

Figure 10. Performance of our prototype against original Blind Seer for range
queries.

The Blind Seer [28] and OSPIR-OXT [14] projects are two
recent systems aiming towards a favorable trade off between
performance, functionality, security and privacy. The core
philosophy of these system is to allow a reasonable and limited
privacy leakage in order to achieve a performance and rich
functionality close to an industry-standard baseline.

These two solutions are very different in terms of design
and offer different tradeoffs between privacy, functionality
and performance. At a high level, Blind Seer’s core data
structure is a search tree index that
is traversed node by
node, requiring high interaction between the client and server.
OSPIR-OXT’s index is an inverted index that doesn’t require
much interaction, and as a result, offers better performance
than Blind Seer in this respect.

In terms of functionality, both systems offer rich set of
queries. OSPIR-OXT functionality is a bit poorer since queries
must be of the form t1 AND φ(t2, .., tn) (where ti are single
terms), with performance that depends on the number of
records satisfying the ﬁrst term t1 (so to avoid linear time
computation, the client should identify a representation of
the query in this form, where t1 does not have too many
matches). In many applications, however, relevant queries are
conjunctions, and it is reasonable to assume that the client
has some a priori information of the database allowing it
to guess which term is of low frequency. Blind Seer, on
the other hand, supports arbitrary Boolean queries in time
that depends on the number of records satisfying the best
(minimal) term, even if that
term is not ﬁrst, not known
by the client, or not even appearing explicitly in the query
representation. A big strength of OSPIR-OXT is its support for
multiple clients. Blind Seer can support non-colluding clients,
but achieving more robust support for multiple clients is still an
open problem. In particular, IS colluding with a client could
compromise the privacy of other clients accessing the same
data.

With respect to privacy, OSPIR-OXT reveals to the index
server the number of records satisfying t1 and number of
records satisfying each subterm t1 AND ti, while Blind Seer
hides this information completely. Both systems leak index
traversal patterns. Both rely on semi-honest servers for secu-
rity, but (until the current work) only OSPIR-OXT was secure
against a malicious client.

VIII. ACKNOWLEDGEMENTS

This work was supported in part by the Intelligence Ad-
vanced Research Project Activity (IARPA) via Department
of Interior National Business Center (DoI/NBC) contract
Number D11PC20194. The U.S. Government is authorized to
reproduce and distribute reprints for Governmental purposes
notwithstanding any copyright annotation thereon. The views
and conclusions contained herein are those of the authors
and should not be interpreted as necessarily representing the
ofﬁcial policies or endorsements, either expressed or implied,
of IARPA, DoI/NBC, or the U.S. Government. Fernando
Krell was additionally supported in part by BECAS CHILE,
CONICYT, Gobierno de Chile. We thank MIT Lincoln Labs

408408

researchers for supporting this program from the beginning
to the end and facilitating extensive testing of our code.
We thank George Argyros for helpful discussions and for
contributions to the implementation of this project. Finally,
we thank our colleagues from other IARPA SPAR teams for
great collaboration and exchange of ideas.

REFERENCES

[1] D. Beaver. Precomputing oblivious transfer. In D. Coppersmith, editor,
CRYPTO’95, volume 963 of LNCS, pages 97–109. Springer, Aug. 1995.
[2] B. H. Bloom. Space/time trade-offs in hash coding with allowable errors.

Commun. ACM, 13(7):422–426, 1970.

[3] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M. Ros¸u, and M. Steiner.
for
Highly-scalable searchable symmetric encryption with support
boolean queries.
In Advances in Cryptology - CRYPTO 2013 - 33rd
Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-
22, 2013. Proceedings, Part I, pages 353–373, 2013.

[4] B. Chor, N. Gilboa, and M. Naor. Private information retrieval by
keywords. Technical Report TR-CS0917, Dept. of Computer Science,
Technion, 1997.

[5] C. Gentry. Fully homomorphic encryption using ideal lattices.

In
M. Mitzenmacher, editor, 41st ACM STOC, pages 169–178. ACM Press,
May / June 2009.

[6] Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin. Protecting data
privacy in private information retrieval schemes. Journal of Computer
and System Sciences, 60(3):592–629, 2000.

[7] O. Goldreich. Foundations of Cryptography: Basic Tools, volume 1.

Cambridge University Press, Cambridge, UK, 2001.

[8] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental
game or A completeness theorem for protocols with honest majority.
In A. Aho, editor, 19th ACM STOC, pages 218–229. ACM Press, May
1987.

[9] O. Goldreich and R. Ostrovsky. Software protection and simulation on

oblivious rams. J. ACM, 43:431–473, 1996.

[10] S. D. Gordon, J. Katz, V. Kolesnikov, F. Krell, T. Malkin, M. Raykova,
and Y. Vahlis. Secure two-party computation in sublinear (amortized)
time. In ACM CCS 12, pages 513–524, 2012.

[11] D. Harnik, Y. Ishai, E. Kushilevitz, and J. B. Nielsen. OT-combiners
via secure computation. In R. Canetti, editor, TCC 2008, volume 4948
of LNCS, pages 393–411. Springer, Mar. 2008.

[12] Y. Huang, J. Katz, V. Kolesnikov, R. Kumaresan, and A. J. Malozemoff.
Amortizing garbled circuits. In Advances in Cryptology - CRYPTO 2014
- 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August
17-21, 2014, Proceedings, Part II, pages 458–475, 2014.

[13] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank. Extending oblivious
transfers efﬁciently. In D. Boneh, editor, CRYPTO 2003, volume 2729
of LNCS, pages 145–161. Springer, Aug. 2003.

[14] S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu, and M. Steiner. Outsourced
symmetric private information retrieval. In Proceedings of the 2013 ACM
SIGSAC conference on Computer & communications security, CCS ’13,
pages 875–888, New York, NY, USA, 2013. ACM.

[15] J. Katz and Y. Lindell. Introduction to Modern Cryptography. Chapman

and Hall/CRC Press, 2007.

[16] A. Kirsch and M. Mitzenmacher. Less hashing, same performance:
Building a better bloom ﬁlter. Random Struct. Algorithms, 33(2):187–
218, 2008.

[17] V. Kolesnikov and T. Schneider.

Improved garbled circuit: Free xor
gates and applications. In L. Aceto, I. Damg˚ard, L. A. Goldberg, M. M.
Halld´orsson, A. Ing´olfsd´ottir, and I. Walukiewicz, editors, ICALP (2),
volume 5126 of Lecture Notes in Computer Science, pages 486–498.
Springer, 2008.

[18] V. Kolesnikov and T. Schneider. A practical universal circuit construc-
tion and secure evaluation of private functions.
In G. Tsudik, editor,
Financial Cryptography, volume 5143 of Lecture Notes in Computer
Science, pages 83–97. Springer, 2008.

[19] Y. Lindell. Fast cut-and-choose based protocols for malicious and covert
adversaries. In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part
II, volume 8043 of LNCS, pages 1–17. Springer, Aug. 2013.

[20] Y. Lindell and B. Pinkas. An efﬁcient protocol for secure two-party
computation in the presence of malicious adversaries. In M. Naor, editor,
EUROCRYPT 2007, volume 4515 of LNCS, pages 52–78. Springer, May
2007.

[21] Y. Lindell and B. Pinkas. A proof of security of Yao’s protocol for two-
party computation. Journal of Cryptology, 22(2):161–188, Apr. 2009.
[22] Y. Lindell and B. Riva. Cut-and-choose yao-based secure computation
in the online/ofﬂine and batch settings.
In Advances in Cryptology -
CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara,
CA, USA, August 17-21, 2014, Proceedings, Part II, pages 476–494,
2014.

[23] S. Lu and R. Ostrovsky. Distributed oblivious ram for secure two-party

computation. In TCC, pages 377–396, 2013.

[24] P. Mohassel and M. Franklin. Efﬁcient polynomial operations in the
shared-coefﬁcients setting.
In M. Yung, Y. Dodis, A. Kiayias, and
T. Malkin, editors, PKC 2006, volume 3958 of LNCS, pages 44–57.
Springer, Apr. 2006.

[25] M. Naor and B. Pinkas. Efﬁcient oblivious transfer protocols. In S. R.
Kosaraju, editor, 12th SODA, pages 448–457. ACM-SIAM, Jan. 2001.
[26] J. B. Nielsen. Extending oblivious transfers efﬁciently - how to get
robustness almost for free. IACR Cryptology ePrint Archive, 2007:215,
2007.

[27] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra. A new
approach to practical active-secure two-party computation. In R. Safavi-
Naini and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS,
pages 681–700. Springer, Aug. 2012.

[28] V. Pappas, F. Krell, B. Vo, V. Kolesnikov, T. Malkin, S. G. Choi,
W. George, S. Bellovin, and A. Keromytis. Blind seer: A private scalable
DBMS. In IEEE Symposium on Security and Privacy. IEEE Computer
Society, 2014.

[29] A. Paus, A.-R. Sadeghi, and T. Schneider. Practical secure evaluation of
semi-private functions. In M. Abdalla, D. Pointcheval, P.-A. Fouque, and
D. Vergnaud, editors, ACNS 09, volume 5536 of LNCS, pages 89–106.
Springer, June 2009.

[30] C. Peikert, V. Vaikuntanathan, and B. Waters. A framework for efﬁcient
and composable oblivious transfer. In D. Wagner, editor, CRYPTO 2008,
volume 5157 of LNCS, pages 554–571. Springer, Aug. 2008.

[31] L. G. Valiant. Universal circuits (preliminary report). In A. K. Chandra,
D. Wotschke, E. P. Friedman, and M. A. Harrison, editors, STOC, pages
196–203. ACM, 1976.

[32] A. C.-C. Yao. Protocols for secure computations (extended abstract). In
23rd FOCS, pages 160–164. IEEE Computer Society Press, Nov. 1982.
[33] A. C.-C. Yao. How to generate and exchange secrets (extended abstract).
In 27th FOCS, pages 162–167. IEEE Computer Society Press, Oct. 1986.

APPENDIX

A. Preliminary tools
Bloom ﬁlters. A Bloom ﬁlter [2] is a well-known data
structure that efﬁciently stores arbitrary items for membership
checking The ﬁlter’s underlying data structure is an array of
(cid:2) bits that are assigned using k hash functions h1, ..., hk with
range {1, ..., (cid:2)}. If B denotes a Bloom ﬁlter, then we will use
the notation B[i] to denote the ith bit of B.

The operations on a Bloom ﬁlter are as follows. Initializa-
tion: all (cid:2) bits of B are set to 0. Insertion: to insert keyword α,
for 1 ≤ i ≤ k set B[hi(α)] = 1. Lookup: to see if B contains
a keyword α, check that B[hi(α)] = 1 for all 1 ≤ i ≤ k.
A Bloom ﬁlter guarantees no false negatives and allows a

tunable rate of false positives:
(cid:3)
1 − 1
(cid:2)

(cid:4)
1 − (cid:2)

F P R =

(cid:5)

kt

k ≈

(cid:4)
1 − e

− kt

(cid:5)

(cid:5)

k

,

where t is the number of search keywords inserted into the
ﬁlter. In our system, we set k = 20 and (cid:2) = 28.86t, which
gives F P R = 2−20 ≈ 10−6.
Semantic security. Semantic security and ciphertext indis-
tistinguishability are equivalent concepts for symmetric en-
cryption [7], [15]. Let Π = (gen, enc, dec) denote a symmetric
Π (A, λ) is played with
encryption scheme. The game Game

IND

409409

IND

(cid:4). If b

Π (A, λ) = |P rob[Game

an “eavesdropping” adversary A as follows. A chooses equal
length messages m0, m1. The game derives sk ← gen(λ),
samples b ← {0, 1}, and sends A the ciphertext encsk(mb). A
(cid:4) = b, the game outputs 1, and oth-
outputs a decision bit b
Π (A, λ) = 1] −
erwise 0. Let AdvIND
Π (A, λ) <
2|. Π is semantically secure if and only if AdvIND
1
negl(λ).
Semantic security for a public key scheme (Gen, Enc, Dec)
is deﬁned similarly, only A is given the public key pk. The
resulting deﬁnition is equivalent to indistinguishability under
chosen-plaintext attack (IND-CPA).
Yao garbled circuits (GC). Yao’s GC [33] is a protocol for
two-party secure computation. One party generates a “garbled
circuit” on which a second party can obliviously evaluate
hidden inputs.

0, wi

1, where key wi

The garbling procedure is as follows. Let C be a Boolean
circuit. Each ith wire of C is given a pair of random keys
0 corresponds to the value ‘0’, and wi
wi
1
corresponds to the value ‘1’. For each gate g with input wires
labeled i, j and output wire k, the corresponding garbled gate
˜g consists of four ciphertexts from which the evaluator can
uniquely recover the output key wk
g(bi,bj ) given input keys wi
and wj
bj .

When using the free-XOR technique of [17], XOR gates
can be garbled and evaluated ”for free” because they do not
require extra communication or cryptographic operations. The
technique uses a global random value Δ and sets all input wire
0⊕Δ for all i. The output wire k of an
1 = wi
keys so that wi
0⊕wj
XOR gate with input wires i, j is given keys wk
0 and
⊕wj
0⊕wj
0⊕Δ. Thus, the output wire wk
= wi
wk
bi
(cid:2)
(cid:3)
can be computed arithmetically from the input wires.
Oblivious Transfer. A 1-out-2 oblivious transfer (
-OT)
protocol is a two-party functionality in which a sender holds
input (x0, x1), a receiver holds a choice r ∈ {0, 1}, the
receiver obtains xr, and neither the sender nor the receiver
learn anything else.

0 = wi
bi⊕bj

1 = wi

1
2

bi

bj

m

Recall

view that is statistically indistinguishable from its view of
the real session. If A is active and substitutes arbitrary input
, T(cid:4)) in place of the Receiver’s randomly sampled input,
(r(cid:4)
it can still produce a statistically indistinguishable view of the
session by using the same r(cid:4)
, T(cid:4) and randomly sampling s for
Sender’s input.4
By the hypothesis that the Sender behaves independently
in all sessions, A cannot distinguish between an experiment in
which it engages with all real sessions versus an experiment
where it only engages with one real session and simulates all
others. Therefore, we restrict our attention to the security of
a single session sid.

that our OT-EXTp(k)

is Nielsen’s OT extension
protocol for malicious receivers [26], using Naor-Pinkas to
instantiate the base OT protocol. Nielsen gave a concrete
analysis showing that A cannot output both e0
i for any
i with probability greater than negl(k) when the base OT is
instantiated with an ideal OT box. However, the starting point
of Nielsen’s analysis only assumes that the output of the base
OT is correct, and that s remains uniformly random in the view
of A. s is the choice vector of the Sender acting as receiver in
the base OT protocol. Sequential or parallel Naor-Pinkas OT
guarantees both correctness and the property that A’s views
of the protocol (as sender) executed with different choice
vectors of the receiver are statistically indistinguishable [25].
Equivalently, conditioned on A’s view, s remains statistically
indistinguishable from a uniformly random vector. It follows
that
the adversary cannot gain a non-negligible advantage
when the ideal OT box is replaced with Naor-Pinkas in
Nielsen’s OT extension (as otherwise this protocol could be
used to distinguish s from random).

i and e1

OT preprocessing is the technique of running random OTs
ofﬂine, and later using them to efﬁciently run online OTs
on real inputs. OT extension is a method that produces N
oblivious transfers from an initial pool of only k << N “base”
OTs of random N-bit strings, where k is a ﬁxed security
parameter. The IKNP protocol [13] for semi-honest parties
has a constant amortized cost per OT.

B. Proof of Lemma 1

i and e1

No adversary corrupting Receiver in a polynomial number
m sessions can out-
i from any individual session with probability

of concurrent and independent OT-EXTp(k)
put both e0
greater than negl(k).
Proof. Note that the protocol OT-EXTp(k)
m is a randomized
functionality that does not take any external input. Internally,
the Receiver samples r ← {0, 1}p(k) and T ← {0, 1}k×k,
and Sender samples s ← {0, 1}k. An adversary A can
therefore simulate any session of OT-EXTp(k)
m , producing a

4Note that this is different than simulatability, where the simulator in an
ideal world secure execution of the protocol is required to simulate the attacks
of any adversary in the real world with the same results. There we consider
the views of both parties, or a third environment party observing the system,
while here we are only concerned with a single party’s view.

410410

