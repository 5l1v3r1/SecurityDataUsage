MPC-Friendly Symmetric Key Primitives

Lorenzo Grassi

Graz University of Technology.

Christian Rechberger

Graz University of Technology.

Dragos Rotaru
Dept. of Comp. Sci.,
University of Bristol.

Peter Scholl

Dept. of Comp. Sci.,
University of Bristol.

Nigel P. Smart
Dept. of Comp. Sci.,
University of Bristol.

ABSTRACT
We discuss the design of symmetric primitives, in partic-
ular Pseudo-Random Functions (PRFs) which are suitable
for use in a secret-sharing based MPC system. We consider
three diﬀerent PRFs: the Naor-Reingold PRF, a PRF based
on the Legendre symbol, and a specialized block cipher de-
sign called MiMC. We present protocols for implementing
these PRFs within a secret-sharing based MPC system, and
discuss possible applications. We then compare the per-
formance of our protocols. Depending on the application,
diﬀerent PRFs may oﬀer diﬀerent optimizations and advan-
tages over the classic AES benchmark. Thus, we cannot
conclude that there is one optimal PRF to be used in all
situations.

1.

INTRODUCTION

Secure multi-party computation (MPC) allows a set of
parties to jointly evaluate a function on private inputs, with
the guarantee that no party can learn anything more than
the output of the function.
In the last decade, MPC has
moved from a theoretical pursuit to a very practical ﬁeld, as
protocols have become more eﬃcient and many implemen-
tations been been developed.

For many years now, the de facto benchmark for MPC
systems has been secure computation of the AES function
[41, 23, 24, 39, 35]. Although the actual choice of this func-
tion was originally as a testbed for comparing protocols, it
has often been justiﬁed as “useful”; for example if an appli-
cation needs to evaluate a symmetric encryption scheme or
pseudorandom function (PRF) with a secret-shared key. If
this is indeed required, then there is no particular reason why
AES should be the best choice to work with MPC, compared
with other PRFs or symmetric ciphers. Indeed we contend
that AES is in many ways a very unnatural choice of a PRF
evaluation for use in MPC applications.
In this work, we
conduct a study of some PRFs for use in MPC, including
new protocols for evaluating number-theoretic PRFs, and

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978332

implementation of “traditional” block cipher candidates de-
signed to have a low complexity in MPC.
1.1 Main Motivating Applications

Before proceeding, we ﬁrst outline some applications we
have in mind. Our focus is on secret sharing based MPC sys-
tems such as that typiﬁed by BDOZ [7], SPDZ [26, 25], and
VIFF [22]; or indeed any classical protocol based on Shamir
Secret Sharing. In such situations data is often shared as
elements of a ﬁnite ﬁeld Fp, of large prime characteristic.
Using such a representation one then has eﬃcient proto-
cols to compute relatively complex functions such as integer
comparison [21], ﬁxed point arithmetic [17], and linear pro-
gramming [16].
Indeed the most famous of such eﬃcient
high level protocols is that needed to compute the output of
an auction [8].

Given such applications, evaluated by an MPC “engine”,
the question arises as to how to get data securely in and out
of the engine. In traditional presentations the data is entered
by the computing parties, and the output is delivered to
the computing parties. However, this in practice will be a
simpliﬁcation. Input and output may need to be securely
delivered/received by third parties, in addition in a long
term reactive functionality the intermediate secure data may
need to be stored in a database, or other storage device.

If we examine the case of long term storage of data, which
is stored by the MPC engine only to be used again at a later
date, the trivial way to store such shared data is for each
party to encrypt their share with a symmetric key, and then
store each encrypted share. However, this incurs an N -fold
increase in storage at the database end (for N MPC servers),
which may be prohibitive. A similar trivial solution also
applies for data input and output, except data input is now
performed using N public keys (one for each MPC server)
and output is performed by each server producing a public
key encryption of its share to the recipient’s public key.

A more eﬃcient solution would be to use a direct eval-
uation of a symmetric key primitive within the MPC en-
gine. Such a symmetric key primitive should be able to
be eﬃciently evaluated by the MPC engine1. We call such
a symmetric key primitive “MPC-Friendly”. Given almost
all symmetric key primitives can be constructed easily from

1Note that public key encryption applications as mentioned
above can be built from the symmetric key key primitives
in the standard KEM-DEM manner. The KEM component
being relatively easy to implement, in most cases, in an MPC
friendly manner. Thus we focus on symmetric key primitives
in this paper.

430Pseudo-Random Functions (PRFs), the goal is therefore to
produce an MPC-Friendly PRF.

The main problem of using “traditional” PRFs such as
AES is that these are built for computational engines which
work over data types that do not easily match the operations
possible in the MPC engine. For example AES is very much
a byte/word oriented cipher, which is hard to represent using
arithmetic in Fp. Thus we are led to a whole new area of
PRF design, with very diﬀerent eﬃciency metrics compared
to traditional PRF design.
1.2 Secondary Applications

A simple example application of MPC is to enable dis-
tributed secure storage of long-term cryptographic keys, by
secret-sharing the key and storing each share at a separate
server. When the key is required by an application such
as encryption or authentication, the MPC protocol is used
to compute this functionality.
If this cryptographic func-
tionality is a symmetric cipher, then this application would
be greatly enhanced by using an “MPC-Friendly” symmetric
primitive.

Using traditional symmetric cryptographic primitives di-
rectly on shared data can also improve eﬃciency for some
applications. For example, Laur et al. [33] used an obliv-
ious AES implementation to perform a secure join opera-
tion on a secret-shared database. After obliviously shuﬄing
the database, the (deterministic) AES encryptions are made
public to all parties, so that the join can then be performed
eﬃciently using standard database algorithms.

Lu and Ostrovsky [36] presented a distributed oblivious
RAM protocol, which achieves only O(log N ) overhead, bet-
ter than any ORAM scheme in the non-distributed setting.
This protocol could be combined with a secret-shared MPC
system to provide a mechanism to allow secure computa-
tion of RAM programs. However, the ORAM construction
of [36] makes heavy use of a PRF, so such an application
would require the use of an MPC-Friendly PRF.

For other operational reasons it may be useful to encrypt
data using a special form of encryption such as determin-
istic encryption, searchable symmetric encryption (SSE) or
(leaky) order-revealing encryption (ORE) [9, 10, 18, 6, 14],
under a secret-shared key. These algorithms can enable eﬃ-
cient queries on the encrypted data, whilst the query results
can then be decrypted into shares for more complex pro-
cessing using MPC. For transmission across the wire, to (or
from) an external application, a form of Authenticated En-
cryption (AE) is needed. We note that all of these symmet-
ric primitives (SSE, OPE, AE etc) can be built, in generic
ways, out of a PRF. Thus the main obstacle preventing such
applications is an eﬃcient MPC-Friendly PRF.
1.3 Related Work

Surprisingly there has been little direct work on this prob-
lem, despite the recent plethora of proposed MPC applica-
tions; indeed the only paper we know of which explicitly
designs PRFs for use in MPC, is [4], which we shall discuss
below. The three lines of work most related to the work in
this paper, apart from re-purposing designs from elsewhere,
are

• Low complexity, “lightweight” ciphers for use in IoT

and other constrained environments.

• Block and stream ciphers suited to evaluation by a

Fully Homomorphic/Somewhat Homomorphic encryp-
tion scheme. So called SHE-Friendly ciphers.

• Designs for use in SNARKs.

We now elaborate on the prior work in these areas.

Low Complexity Lightweight Ciphers: Block ciphers
often iterate a relatively simple round function a number of
times to achive security goals. Most early designs in this
domain focused on small area when implemented as a cir-
cuit in hardware. There, large depth (via a large number
of rounds) is of no concern as simply means clocking a cir-
cuit that implements a single round more times. Notable
exceptions are mCrypton[34] and Noekeon[19] which also
feature a relatively low depth. The more recent trend to
emphasize low latency (with designs like PRINCE[11]) ﬁts
much better with our requirement of having low-depth. A
property of all these designs is that they lend themselves
well to implementations where binary NAND gates, XOR
gates, or multiplexers are the basic building blocks in the
used libraries. As explained above the majority of secret
sharing based MPC applications require description via Fp.
Whilst bit operations are possible over Fp using standard
tricks (which alas turn XOR into a non-linear operation),
applying such ciphers would require the Fp data types to be
split into a shared bit representation over Fp to apply the
cipher. Such a conversion is expensive.

SHE-Friendly Ciphers: Perhaps due to the recent theo-
retical interest in SHE/FHE schemes this area has had more
attention than the more practical issues addressed in this pa-
per. The motivating scenario for a SHE-Friendly cipher is
to enable data to be securely passed to a cloud environment,
using a standard encryption scheme, which the cloud server
then homomorphically decrypts to obtain a homomorphic
encryption of the original data.

This line of work has resulted in a handful of designs.
A block cipher called LowMC [4], a stream cipher called
Kreyvium [13] (based on the Trivium stream cipher) and
FLIP [37] (based on a ﬁlter permutation)2. The block cipher
LowMC is designed for both MPC and FHE implementation,
but actually does not meet the MPC design goals we have
set. It does indeed have low depth, but it is a cipher based
on operations in characteristic two. The two SHE friendly
stream cipher designs of Kreyvium and FLIP also suﬀer from
the same problem as the lightweight designs describe above,
as they are also bit-oriented.

SNARK-Friendly Constructions: Being SNARK-friendly
means that the number of constraints is low. This generally
favours larger data types like Fp or F2n , and the depth of the
circuit is of no concern. MiMC [2] was originally designed
for this use case and seems to be the only one in this area.
As the depth is not too high either, we choose it for detailed
evaluation.
1.4 Contributions

The goal of this work is to investigate the eﬃcient evalu-
ation of PRFs in a secret-sharing based MPC setting. 3 We
2FLIP was recently cryptanalysed in [28].
3We leave the construction of the various higher level prim-
itives (SSE, ORE, AE etc.) to future work, although many
of these can easily be constructed directly from a PRF.

431(cid:26)

form

F :

present new protocols for secure computation of PRFs, and
implementation results using an actively secure MPC proto-
col, which tolerates up to N − 1 out of N corrupted parties
(with an online phase based on the SPDZ protocol [26, 25]).
To ﬁx notation we will consider a PRF of the following

(Fp)(cid:96) × (Fq)n

(k1, . . . , k(cid:96), x1, . . . , xn)

−→
(cid:55)−→ Fk(x1, . . . , xn).

(Fr)m

The various ﬁnite ﬁelds Fp, Fq and Fr may be distinct. Our
MPC engine is assumed to work over the ﬁnite ﬁeld Fp, as
we always assume the key to the PRF will be a secret shared
value. As a benchmark, we compare all of our candidates
to the baseline AES example used in prior work, and to
implementations of the given PRFs on clear data.

Depending on the precise application, there are several
distinct design criteria which we may want to consider. Thus,
there will not be a one size ﬁts all PRF which works in all
applications. We then have various potential cases:

• In some applications the input is public and we need
to embed the public elements x1, . . . , xn ∈ Fq into Fp.
However, the more general case is when the input is
secret shared itself, and we have Fq = Fp.

• In some applications the output of the PRF will be
public, and thus Fr can be any ﬁeld. In other appli-
cations we also want the output to be secret shared,
so we can use it in some other processing such as a
mode of operation.
In this latter case we will have
Fr = Fp. In addition, some applications, such as when
using the (leaky) ORE scheme presented in [18] require
PRF outputs in {0, 1, 2}, and we may (or may not) re-
quire these to be secret shared (and hence embedded
in Fp).

• In some applications we would like a PRF which is
just eﬃcient in the MPC engine, and we do not care
whether the equivalent standard PRF is eﬃcient or
not.
In other applications we also require that the
standard PRF is also eﬃcient. For example when an
external third party is encrypting data for the MPC
engine to decrypt.

In this paper we consider four candidate PRFs for use in
MPC systems, as well as the comparison case of AES. Two
of these are number theoretic in nature (the Naor-Reingold
PRF, based on DDH, and a PRF based on the Legendre
symbol), whilst MiMC [2] and LowMC [4] are more akin to
traditional symmetric block cipher constructions.

AES: Since AES does not lend itself well to secure compu-
tation over prime ﬁelds, we use this purely as a benchmark.
We assume an MPC system which is deﬁned over the ﬁnite
ﬁeld F
28 , allowing for eﬃcient evaluation of the S-box [23,
24]. We have

FAES : (F

28 )16 × (F

28 )16 → (F

28 )16.

LowMC: This is a block cipher candidate [4] designed to
be suitable for FHE and MPC style applications; thus it has
a low multiplicative depth and a low number of multiplica-
It operates over F2, so like AES, is not well-suited
tions.
to the MPC applications for which we envisage our block
ciphers being used for. Thus we only consider LowMC as
an additional base line comparison (along with AES) for our

ciphers. LowMC has block size n bits and key size k bits
(we use n = 256 and k = 128), giving:

FLowMC : (F2)k × (F2)n → (F2)n

Naor-Reingold: Let G = (cid:104)g(cid:105) be an elliptic curve group
of prime order p in which DDH is hard, and encode(·) be
a hash function that maps elements of G into elements of
Fp. The Naor-Reingold PRF takes a uniform secret-shared
key in Fn+1
2 (secret-shared over Fp), and
outputs a public Fp element as follows:

, a message in Fn

p

FNR(n) : (Fp)n+1 × (F2)n → Fp

(k, x) (cid:55)→ encode(gk0·(cid:81)n

i=1 k

xi
i )

To evaluate FNR in MPC naively would require computing
exponentiations (or EC scalar multiplications) on secret ex-
ponents, which is very expensive. However, if the PRF out-
put is public, we show how the exponentiation (and hence
PRF evaluation) can be done very eﬃciently, with active se-
curity, using any MPC protocol based on secret sharing.

Legendre Symbol: We also consider an unusual PRF
based on the pseudorandomness of the Legendre symbol.
This is a relatively old idea, going back to a paper of Damg˚ard
in 1988 [20], but has not been studied much by the crypto-
graphic community. The basic version of the PRF is deﬁned
as,

FLeg(bit) : Fp × Fp → F2

(cid:1) ∈
where Lp(a) computes the usual Legendre symbol (cid:0)a

(k, x) (cid:55)→ Lp(x + k)

{−1, 0, 1} and maps this into {0, 1, (p + 1)/2}, by computing

p

(cid:19)

(cid:18)(cid:18) a

(cid:19)

p

Lp(a) =

1
2

+ 1

(mod p).

The output is embedded into Fp, giving a secret-shared out-
put in Fp. If needed, the range can easily be extended to
the whole of Fp by using a key with multiple ﬁeld elements
and performing several evaluations in parallel. This gives a
PRF

FLeg(n) : (Fp)((n+1)·(cid:96)) × (Fp)n → Fp,

for some value (cid:96) = O(log2 p) chosen large enough to ensure
a suﬃcient statistical distance from uniform of the output.
This PRF takes n ﬁnite ﬁeld elements as input and produces
an element in Fp as output, where n is some ﬁxed (and
relatively small) number, say one or two.

Perhaps surprisingly, we show that the Legendre PRF can
be evaluated very eﬃciently in MPC, at the cost of just two
multiplications in three rounds of interaction for FLeg(bit). To
the best of our knowledge, this is the only PRF that can be
evaluated in a constant number of rounds on secret-shared
data, using any arithmetic MPC protocol. Since the under-
lying hard problem is less well-studied than, say, DDH or
factoring, we also provide a brief survey of some known at-
tacks, which are essentially no better than brute force of the
key.

MiMC: This is a very recent class of designs whose pri-
mary application domain are SNARKs [2]. In addition to a
cryptographic hash function, the design also includes a block
cipher which is also usable as a PRF, with up to birthday

432bound security. The input, output and keys are all deﬁned
over Fp, so we get:

FMiMC : Fp × Fp → Fp.

The core of the round function is the simple map x (cid:55)→ x3
over Fp. The number of rounds is quite high (for a 128-bit
prime p 82 for full security, 73 for PRF security), but in
terms of Fp multiplications the performance turns out to be
competitive.

The reason for selecting MiMC as a “standard” block ci-
pher is that ﬁrstly it works over a ﬁnite prime ﬁeld of large
characteristic, which is a common requirement for applica-
tions of secret-sharing based MPC that perform arithmetic
on integers or ﬁxed-point data types. Secondly, the depth
of the computation is not too large, being 146. Thirdly, the
number of non-linear operations is also 146, this means that
the oﬄine pre-processing needed (to produce multiplication
triples) will be very small compared to other constructions.
In Table 1 we present an overview of the MPC-friendly
PRFs we consider. The table shows the number of secure
multiplication needed to execute the online evaluation of
the function on shared inputs (since in secret-sharing based
MPC, additions are free) as well as the number of rounds of
communication.
1.5 Length Extension

We end this introduction by noting that FMiMC and FLeg(n)
can be extended to cope with arbitrary length inputs in the
standard way; either by using a CBC-MAC style construc-
tion or a Merkle–Damg˚ard style construction. For example,
to extend FLeg(1)and FMiMC, so that they can be applied to an
input x1, . . . , xn ∈ Fp we can use CBC mode as in Figure 1.
Whereas, to extend FLeg(2) we can apply Merkle–Damgard
as in Figure 2. These two extension techniques are often
more eﬃcient than using an arbitrary length PRF as a base
building block.

Length Extension for FLeg(1)

1. c0 ← n.
2. For i = 1, . . . , n do

(a) ci ← xi + FLeg(1)(k, ci−1).

3. a ← FLeg(1)(k, cn).
4. Return a.

Figure 1: Using CBC Mode With FLeg(1)

Length Extension for FLeg(2)

1. c0 ← n.
2. For i = 1, . . . , n do

(a) ci ← FLeg(2)(k, ci−1, xi).

3. Return cn.

Figure 2: Using Merkle-Damg˚ard With FLeg(2)

2. BACKGROUND

In this section we outline some of the basic material which

we will assume for the rest of this paper.
2.1 Multi-Party Computation Model

The general model of MPC we consider is the so-called
arithmetic black box, which is an ideal functionality that al-
lows parties to input and output values to be secret-shared,
and performs basic arithmetic operations on these secret
values over a ﬁnite ﬁeld Fp. This abstracts away the un-
derlying details of secret-sharing and MPC, and gives us
the commands in Figure 3. Note that as well as addition
and multiplication, FABB has commands for generating ran-
dom values according to various distributions, which allows
more eﬃcient protocols for certain tasks. Finally, the Share
command gives parties access to random, additive shares of
a value stored in the box. This essentially assumes the un-
derlying MPC protocol uses additive secret sharing, but is
only used for the Naor-Reingold PRF protocol (Section 3).
We use the notation [x] to denote a secret-shared value
that is stored in FABB. We also deﬁne addition and multi-
plication operators for the [·] notation; so, for example, the
statement

[w] = [x] · [y] + 2[z]

implicitly means that the Add and Mult commands of FABB
are used to compute the shared value [w].

Functionality FABB

Each value stored in this functionality is associated with a
unique identiﬁer that is given to all parties. Let [x] denote
the identiﬁer for a value x that is stored by the functionality.
Let A ⊂ {1, . . . , n} denote the index set of corrupted parties.
Input: Receive a value x ∈ Fp from some party and store x.
Add([x], [y]): Compute z = x + y and store [z].
Mult([x], [y]): Compute z = x · y and store [z].

Random: Sample r

R← Fp and store [r].

RandomBit: Sample b

R← {0, 1} ⊂ Fp and store [b].

R← Fp and store [s2].

RandomSquare: Sample s
Share([x]): For each i ∈ A, receive xi ∈ Fp from the adver-
sary. Sample uniform honest parties’ shares {xj}j /∈A,
i=1 xi = x. Send xi to

subject to the constraint that (cid:80)n

party Pi.

Output([x]): Send the value x to all parties.

Figure 3: Ideal functionality for arithmetic MPC

Concretely, the MPC protocol we use to implement FABB
is the SPDZ protocol by Damg˚ard et al. [26, 25], which op-
erates over a ﬁnite ﬁeld of size ≥ 2κ (for statistical secu-
rity κ) and provides active security against any number of
corrupted parties. The protocol consists of two stages: a
preprocessing phase, which is independent of the inputs and
done in advance, and a more eﬃcient online phase, where
the actual computation takes place. The purpose of the pre-
processing is to generate enough random shared data that
will be consumed later by the online phase. The main data
produced is one of three diﬀerent forms:

• Multiplication Triples: A triple of random shares

([a], [b], [c]) such that c = a · b mod p.

433PRF

log2 p

Output (type)

Online cost

Assumption

FAES
FLowMC

FNR(n)
FLeg(bit)
FLeg(n)
FMiMC

8
2

256
128
128
128

shared
shared

public
shared
shared
shared

Mult.

960
1911
2 · n
2
256 · n
146

Rounds

50
13

–
–

3 + log(n + 1)

EC-DDH

3
3
73

DSLS
DSLS

–

Table 1: Overview of the cost of evaluating the PRFs in MPC.

• Square Pairs: A pair of random shares ([a], [b]) such

that b = a2 mod p.

• Random Bit: A random sharing [a] of a value a ∈

{0, 1}.

The main arithmetic operations in FABB have roughly the
following complexity when implemented in SPDZ. Additions
(and linear operations) are local operations so essentially
for free. A multiplication uses a preprocessed multiplication
triple and requires sending two ﬁeld elements in the online
phase, with one round of interaction. Squaring can be done
using a square pair and sending just one ﬁeld element, again
in one round.

The preprocessing can be implemented using either some-
what homomorphic encryption (SHE) — as in the original
SPDZ protocols — or oblivious transfer (OT), using the re-
cent protocol of Keller et al. [31]. We present runtimes using
the OT-based oﬄine phase only, as it is much more eﬃcient,
even when compared with the weaker covertly secure proto-
cols using SHE.
2.2 MPC Evaluation of AES and LowMC

28 , embedded into F

As a means of comparison for the other PRFs we use
as a base line a two party implementation of AES using
a SPDZ engine over the ﬁnite ﬁeld F
240 ,
as in [24]. We estimate the oﬄine phase costs 200ms per
block, with an online phase latency of 8ms and a through-
put of over 500 blocks per second. Note that recently, much
lower latencies have been obtained by evaluating AES using
secure table lookup [27]. However, this technique requires
far more (i.e., 256 times) preprocessing data, so we do not
consider this. One should also bear in mind that this is only
the time needed to evaluate the PRF. In a given application,
which is likely to be over a diﬀerent ﬁnite ﬁeld, the MPC
engine will also need to convert data between the two ﬁelds
Fp and F
240 . This is likely to incur a more signiﬁcant cost
than the evaluation of the PRF itself.

In addition to AES, we also present comparison execu-
tions for the low complexity block cipher LowMC. This is to
enable a comparison with our Fp based block ciphers against
not only a standard in-use block cipher (AES), but also a
block cipher designed for use in MPC/FHE environments.
2.2.1 FLowMC Deﬁnition
LowMC [4] is a ﬂexible family of block ciphers with oper-
ations over F2, designed to have a low number of multiplica-
tions and a low multiplicative depth when implemented in
MPC. Similar to AES, it is based on an SPN structure where
the block size n, the key size k, the number of Sboxes m in

the substitution layer and the allowed data complexity d of
attacks can independently be chosen. The number of rounds
r needed to reach the security claims is then derived from
these parameters. The two most relevant parts of the round
transformation are the SboxLayer and the LinearLayer.
SboxLayer is an m-fold parallel application of the same 3-
bit Sbox (of multiplicative depth 1) on the ﬁrst 3m bits of
the state. If n > 3m then for the remaining n− 3m bits, the
SboxLayer is the identity. LinearLayer is the multiplica-
tion in F2 of the state with a predetermined dense randomly
chosen invertible binary n × n matrix that is diﬀerent for
every round.

Using the most recent v2[3] formula for r, we need at
least 13 rounds to achieve a security comparable to AES as
a PRF, i.e. k = 128 and d = 64. Using n = 256, the minimal
number Sboxes m for which this is true turns out to be 49.

2.2.2 Computing FLowMC in MPC
To evaluate LowMC in MPC, we consider two approaches.
In the ﬁrst method, denoted FLowMC(vector), we work over
F
2128 and compute the matrix multiplications and XOR op-
erations by parallelizing over 128-bit vectors. Speciﬁcally,
each column Mi of the n × n matrix M is packed into F
2128
elements; to compute the product M [x] we take the inner
product of all columns with [x]. For n = 256, this requires
512 XORs and 512 local ﬁnite ﬁeld multiplications. How-
ever, we then need to switch back to F2 to evaluate the Sbox
(with three F2 multiplications), which requires bit decompo-
sition, adding one round of interaction for every round of the
cipher.

In the second approach, denoted FLowMC(M4R), we use
the “Method of Four Russians” [1] to perform each matrix
multiplication in O(n2/ log n) bit operations. We do not
parallelize the computation by packing bits into vectors, so
this actually results in a higher computation cost than the
vector method, but avoids the need for bit decomposition in
each round.
In both methods, the total number of multiplications over
F2 is 3· m· r. The vector approach requires 256· r additional
random bits, and also 2r rounds of communication, instead
of r rounds for M4R.

2.2.3 Performance
With parameters n = 256, m = 49, r = 13, we obtained a
latency of 4ms and a throughput of almost 600 blocks per
second.

As for AES, the need to convert from a Fp representation
to a bit-oriented representation for application of LowMC
is likely to dominate the run-time for the actual PRF eval-

434uation, making LowMC unsuitable for the applications we
discussed at the beginning.

3. NAOR–REINGOLD PRF

FNR Deﬁnition

In this section we describe the Naor-Reingold PRF, orig-
inally presented in [38]. We then go on to describe how
it can be eﬃciently implemented in a secret sharing based
MPC system.
3.1
Let G = (cid:104)g(cid:105) be a multiplicatively written group of prime
order p in which DDH is hard, and encode(·) be a hash
function that maps group elements into elements of Fp. For
a message x = (x1, . . . , xn) ∈ {0, 1}n, the Naor-Reingold
PRF [38] is deﬁned by:

FNR(n)(k, x) = encode(gk0·(cid:81)n

i=1 k

xi
i )

where k = (k0, . . . , kn) ∈ Fn+1

p

is the key.

In practice, we choose G to be a 256-bit elliptic curve
group over the NIST curve P-256, so require an MPC pro-
tocol for Fp with a 256-bit prime p.
3.2 Public Output Exponentiation Protocol

The main ingredient of our method to evaluate FNR in
MPC, when the key and message are secret-shared over Fp,
is an eﬃcient protocol for publicly computing gs, for some
secret value s ∈ Fp. The protocol, shown in Figure 4, uses
any arithmetic MPC protocol based on linear secret sharing
over Fp. This is modeled for the case of additive secret
sharing by the Share command of the FABB functionality,
which produces random shares of secret values.
Given additive shares si ∈ Fp, each party Pi ﬁrst broad-

casts gsi , so the result y = (cid:81) gsi can be computed. To

obtain active security, we must ensure that each party used
the correct value of si. We do this by computing an addi-
tional public exponentiation of gt, where t = r · s for some
random, secret value r. This serves as a one-time MAC on
s, which can then be veriﬁed by opening r and checking
that gt = yr. If an adversary cheats then passing the check
essentially requires guessing the value of r, so occurs only
probability 1/p.
Note that the functionality FABB-Exp (Figure 5) models an
unfair computation, whereby the adversary ﬁrst learns the
output, and can then decide whether to give this to the
honest parties or not. This is because in the protocol, they
can always simply stop sending messages and abort after
learning y.

Theorem 1. The protocol ΠExp securely computes the func-
tionality FABB-Exp in the FABB-hybrid model.
Proof. We construct a simulator S, which interacts with any
adversary A (who controls the corrupt parties {Pi : i ∈ A})
and the ideal functionality FABB-Exp, such that no environ-
ment can distinguish between an interaction with S and a
real execution of the protocol ΠExp.

• In the ﬁrst round S receives si for i ∈ A, as the cor-
rupt parties’ inputs to the FABB-Share command. S calls
FABB-Exp with (exp, [s]) and receives y = gs. Then S
R← Fp and sets yi = gsi for all i /∈ A. S
samples si
−1
,
j(cid:54)=i y
j

modiﬁes one honest party’s share yi to gs(cid:81)

Protocol ΠExp([s])

1. The parties call FABB with command (Share, [s]), so

that each party Pi obtains an additive share si ∈ Fp

4. Take a random shared [r], and compute [t] = [r] · [s]
5. Call FABB with (Share, [t]) so that each Pi obtains ti.

2. Each party Pi broadcasts yi = gsi

3. Compute y =(cid:81)
6. Open [r] and check that(cid:81)

Broadcast zi = gti

i yi

i zi = yr

7. Output y

Figure 4: Securely computing a public exponentia-
tion

Functionality FABB-Exp

Let G = (cid:104)g(cid:105) be a group of prime order p. This functionality has
all of the features of FABB (running in Fp), plus the following
command:

PubExp: On receiving (exp, [s]) from all parties, where s
is stored in memory, retrieve s, then send y = gs to
the adversary and wait for a response. If the adversary
responds with Deliver then send y to all parties. Oth-
erwise output ⊥ to all parties.

Figure 5: Ideal functionality for public exponentia-
tion

then sends yi for all i /∈ A to the adversary and gets
back the corrupted parties’ response y∗

i , for i ∈ A.
• Proceed similarly to the previous step: S samples ri

R←
i zi = yr. Sends zi to A on
Fp, sets zi = yri
behalf of the honest parties. Receives back courrupted
parties z∗
i .

i such that(cid:81)

i ri to the adversary. S performs the
i from A and the honest zi. If

checking phase with z∗
the check passes send Deliver to FABB-Exp.

• Sends r ← (cid:80)

The indistinguishability argument follows from the fact
that all broadcasted values gxi by S and the real protocol
ΠExp have uniform distribution over Fp with output in G

with respect to(cid:81)

i gxi = gx.

Suppose a corrupt party Pj sends y∗

j such that (cid:81)

Correctness is straightforward if all parties follow the pro-
tocol. An adversary A wins if it changes the distribution
of the functionality to output Deliver. Alas, this happens
with negligible probability:
j instead of yj = gsj .
j = gsj · e, for some error e (cid:54)= 1 ∈ G, and
We can write y∗
so y = gs · e. Then the check passes if A can come up with
i zi = grs · er. Writing z∗
j = zj · f , this
z∗
is equivalent to coming up with f ∈ G such that f = er.
Since r is uniformly random and unknown to the adversary
at the time of choosing e and f , passing this check can only
happen with probability 1/|G|. Note that this requires G to
be of prime order, so that e (which is adversarially chosen)
is always a generator of G.
More Efﬁcient Protocol based on SPDZ.
When using the SPDZ MPC protocol with the secret-shared
MAC representation from [25], we can save performing the

435multiplication [t] = [r] · [s]. Instead, we can take the shared
MAC value [m] (on the shared s), which satisﬁes m = s · α
for a shared MAC key α, and use [m] and [α] in place of
[t] and [r]. However, in this case α cannot be made public,
otherwise all future MACs could be forged. Instead, steps
4–6 are replaced with:

• Each party commits to zi = yαi · g−mi .
• All parties open their commitments and check that

(cid:81)

i zi = 1.

If the parties are honest, we have zi = gs·αi−mi , so the check
will pass. Since in SPDZ, the honest parties’ MAC shares mi
are uniformly random, the shares of αi are perfectly masked
by the g−mi factor in zi, so no information on α is leaked.
The main diﬀerence here is that the parties must commit to
the zi shares before opening, to prevent a rushing adversary
from waiting and forcing the product to always be 1. The
number of rounds and exponentiations is the same, but one
multiplication is saved compared with the previous protocol.
3.3 Secure Computation of Naor-Reingold

Protocol ΠNR

KeyGen: Call FABB.Random to generate n + 1 random keys

[k0] . . . [kn].

Eval: To evaluate FNR(n)(k, x) on input [x] with key [k]:

1. Bit decompose [x] into [x1] . . . [xn].

2. Compute [s] = [k0] ·(cid:81)n

i=1([ki][xi] + (1 − [xi]) (see

text for details).

3. Call FABB-Exp on input [s].

Figure 6: Computing FNR(n)(k, x)

Given the protocol for public exponentiation, it is straight-
forward to evaluate the Naor-Reingold PRF with public
output when given a bit-decomposed, secret-shared input
[x1], . . . , [xn] and key [k0], . . . , [kn]. First compute

[s] = [k0] · n(cid:89)

([xi] · [ki] + (1 − [xi]))

i=1

using FABB, and then use ΠExp to obtain gs.

The product can be computed in (cid:100)log2 n + 1(cid:101) rounds us-
ing a standard binary tree evaluation. Alternatively, we can
obtain a constant (4) rounds protocol using the preﬁx mul-
tiplication protocol of Catrina and de Hoogh [15], (which is
an optimized variant of the trick of Bar-Ilan and Beaver [5])
at the expense of 2(n + 1) additional multiplications.

Security of the ΠNR protocol is straightforward, since there
is no interaction outside of the arithmetic black box func-
tionality.
Handling Input in Fp.
If the input is given as a ﬁeld element rather than in bit-
decomposed form, then we must ﬁrst run a bit decomposi-
tion protocol, such as that of Catrina and de Hoogh [15] or
Damg˚ard et al. [21]. The latter works for arbitrary values
of x, whilst the former is more eﬃcient, but requires x is (cid:96)
bits long, where p > 2(cid:96)+κ for statistical security κ.

Complexity.
For the logarithmic rounds variant based on SPDZ, with
n-bit input that is already bit decomposed, the protocol re-
quires 2n multiplications of secret values and three exponen-
tations, in a total of (cid:100)log2 n + 1(cid:101) + 3 rounds. The constant
rounds variant takes 4n+2 multiplications in 7 rounds. Note
that there is a higher cost for the secure multiplications, as
we require an MPC protocol operating over Fp for a 256-
bit prime p (for 128-bit security), whereas our other PRF
protocols only require MPC operations in 128-bit ﬁelds.
3.4 Performance

The main advantage of this PRF is the small number of
rounds required, which leads to a low latency in our bench-
marks (4.4ms over LAN). However, the high computation
cost (for EC operations) slows down performance and re-
sults in a low throughput. We found that with a 256-bit
prime p and n = 128, the logarithmic rounds variant out-
performed the constant rounds protocol in all measures in a
LAN environment. In a WAN setting, the constant round
protocol achieves a lower latency, but is worse for through-
put and preprocessing time.

4. PRF FROM THE LEGENDRE SYMBOL
In this section we consider a PRF based on the Legen-
dre symbol, which to the best of our knowledge was ﬁrst
described in [44]. Whilst this PRF is very ineﬃcient when
applied to cleartext data, we show that with secret-shared
data in the MPC setting it allows for a very simple protocol.
4.1

FLeg Deﬁnition

In 1988, Damg˚ard proposed using the sequence of Legen-
dre symbols with respect to a large prime p as a pseudoran-
dom generator [20]. He conjectured that the sequence

(cid:32)

(cid:33)

(cid:32)

k
p

,

(cid:33)

(cid:32)

(cid:33)

k + 1

p

,

k + 2

p

, . . .

is pseudorandom, when starting at a random seed k. Al-
though there have been several works studying the statisti-
cal uniformity of this sequence, perhaps surprisingly, there
has been very little research on cryptographic applications
since Damg˚ard’s paper. Damg˚ard also considered variants
with the Jacobi symbol, or where p is secret, but these seem
less suitable for our application to MPC.
We ﬁrst normalize the Legendre symbol to be in {0, 1, (p+
1)/2}, by deﬁning:

(cid:19)

(cid:18)(cid:18) a

(cid:19)

p

Lp(a) =

1
2

+ 1

(mod p).

We now deﬁne the corresponding pseudorandom function
(as in [44]) as

FLeg(bit)(k, x) = Lp(k + x)

for k, x ∈ Fp, where p ≈ 2λ is a public prime. The security
of this PRF is based on the following two problems:

Deﬁnition 1 (Shifted Legendre Symbol Problem). Let k be
uniformly sampled from Fp, and deﬁne OLeg to be an oracle

that takes x ∈ Fp and outputs(cid:0)k+x

(cid:1). Then the Shifted Leg-

p

endre Symbol (SLS) problem is to ﬁnd k, with non-negligible
probability.

436Deﬁnition 2 (Decisional Shifted Legendre Symbol Prob-
lem). Let OLeg be deﬁned as above, and let OR be a ran-
dom oracle that takes values in Fp and produces outputs in
{−1, 1}. The Decisional Shifted Legendre Symbol (DSLS)
problem is to distinguish between OLeg and OR with non-
negligible advantage.

The following proposition is then immediate.

Proposition 1. The function FLeg(bit) is a pseudorandom
function if there is no probabilistic polynomial time algo-
rithm for the DSLS problem.

4.2 Hardness of the Shifted Legendre Symbol

Problem

The SLS problem has received some attention from the
mathematical community, particularly in the quantum set-
ting. We brieﬂy survey some known results below.

(cid:16) k+x

(cid:17)

A naive algorithm for deterministically solving the SLS
p and com-
problem is to compute
pare these with OLeg(x) for all x ∈ Fp, which requires ˜O(p2)
binary operations. Russell and Shparlinski [42] described a
more sophisticated algorithm using Weil’s bound on expo-
nential sums, which reduces this to ˜O(p).

for all (k, x) ∈ F2

p

Van Dam, Hallgren and Ip [44] described a quantum poly-
nomial time algorithm for the SLS problem that recovers the
secret k if the oracle can be queried on a quantum state.
They conjectured that classically, there is no polynomial
time algorithm for this problem. Russell and Shparlinski [42]
also extended this quantum algorithm to a generalization of
the problem where the secret is a polynomial, rather than
just a linear shift.

One can also consider another generalization called the
hidden shifted power problem, where the oracle returns (k +
x)e for some (public) exponent e|(p − 1). The SLS problem
is a special case where e = (p− 1)/2. Vercauteren [45] called
this the hidden root problem and described eﬃcient attacks
over small characteristic extension ﬁelds, with applications
to fault attacks on pairings-based cryptography. Bourgain
et al. [12] showed that if e = p1−δ for some δ > 0 then
this problem has classical query complexity O(1). Note that
neither of these attacks apply to the SLS problem, which
cannot be solved with fewer than Ω(log p) queries [43].

In conclusion, we are not currently aware of any classical
algorithms for the SLS problem in better than ˜O(p) time,
nor of any method for solving the DSLS problem without
ﬁrst recovering the secret. We note that unlike discrete log
and factoring, it is still an open question as to whether there
are even eﬃcient quantum algorithms if the SLS oracle can
only be queried classically.

4.3 Secure Computation of FLeg(bit)

It turns out that FLeg(bit) can be evaluated in MPC very
eﬃciently, at roughly the cost of just 2 multiplications in 3
rounds of communication. Although this only produces a
single bit of output, composing together multiple instances
in parallel with independent keys allows larger outputs to
be obtained (see later).

We ﬁrst describe how to evaluate FLeg(bit) when the output
is public, and then show how to extend this to secret-shared
output, with only a small cost increase.

Public output.
Suppose we have a shared, non-zero [a] and want to compute
the public output, Lp(a). Since the output is public, we
can simply take a random preprocessed non-zero square [s2],
compute [c] = [s2] · [a] and open c. By the multiplicativity
of the Legendre symbol, Lp(c) = Lp(a).

By composing the PRF n times in parallel, this gives an
n-bit output PRF that we can evaluate in MPC with just n
multiplications and n openings in two rounds. The prepro-
cessing requires n random squares and multiplication triples.
Shared output.
Now suppose we instead want shared output, [Lp(a)]. If we
have a random non-zero value [t], and also the shared value
[Lp(t)], then this is easy. Just open [a]· [t], and compute the
Legendre symbol of this to get c = Lp(a·t). The shared value
[Lp(a)] can then be computed locally using c and [Lp(t)], as
c is public.

Generating a random value with a share of its Legendre
symbol can be done very cheaply. Our key observation is
that we can do this without having to compute any Legendre
symbols in MPC. Let α ∈ Zp be a (public) quadratic non-
residue, and perform the following:

• Take a random square [s2] and a random bit [b].
• Output (2[b] − 1, [b] · [s2] + (1 − [b]) · α · [s2])

Note that since α is a non-square, the second output value
is clearly either a square or non-square based on the value
of the random bit b (which is mapped into {−1, 1} by com-
puting 2 · b − 1). Finally, note that since s2 provides fresh
randomness each time, α can be reused for every PRF eval-
uation. This gives us the protocol in Figure 7, which realizes
the functionality FABB-Leg shown in Figure 8. Notice that all
bar the computation of u can be performed in a preprocess-
ing phase if needed.

Protocol ΠLegendre

Let α be a ﬁxed, quadratic non-residue modulo p.
KeyGen: Call FABB.Random to generate a random key [k].
Eval: To evaluate FLeg(bit) on input [x] with key [k]:

1. Take a random square [s2] and a random bit [b]
2. [t] ← [s2] · ([b] + α · (1 − [b]))
3. u ← Open([t] · ([k] + [x]))

4. Output [y] ← ((cid:0)u

(cid:1) · (2[b] − 1) + 1)/2

p

Figure 7: Securely computing the FLeg(bit) PRF with
secret-shared output

Security.
At ﬁrst glance, the security of the protocol appears straight-
forward: since t and k are uniformly random, the opened
value u should be simulatable by a random value, and this
will be correct except with probability 1/p (if s2 = 0). How-
ever, proving this turns out to be more tricky. We need to
take into account that if x = −k then the protocol causes
u = 0 to be opened, but in the ideal world the simulator
does not know k so cannot simulate this. This reﬂects the

437fact that an adversary who solves the SLS problem can ﬁnd
k and run the protocol with x = −k. Therefore, we need
to assume hardness of the SLS problem and show that any
environment that distinguishes the two worlds (by causing
x = −k to be queried) can be used to recover the key k. The
reduction must use the SLS oracle, OLeg, to detect whether
x = −k, in order to simulate the u value to the environment.

To do this, they simply obtain the value y =(cid:0)x+k

(cid:1) from OLeg

and check whether y = 0, for each Eval query made by the
adversary.

p

Functionality FABB-Leg

This functionality has all of the same commands as FABB, plus
the following:

KeyGen: On receiving (keygen) from all parties, sample

R← Fp and store k.

k

PRF: On receiving (legendre, [x]) from all parties, where x
is stored in memory, compute y = Lp(x + k) and store y
in memory.

Figure 8: Ideal functionality for the Legendre sym-
bol PRF, FLeg(bit)

Theorem 2. The protocol ΠLegendre securely computes the
functionality FABB-Leg in the FABB-hybrid model, if the SLS
problem is hard.
Proof. We construct a simulator S such that no environment
Z corrupting up to n − 1 parties can distinguish between
the real protocol ΠLegendre, and S interacting with the ideal
functionality FABB-Leg.
In the KeyGen stage, S simply calls FABB-Leg with the
keygen command. In the Eval stage, the main task of S is
to simulate the opened value u, which is done by sampling
u R← Fp, and then call FABB-Leg with (legendre, [x]).
We now argue indistinguishability of the two executions.
In the real world, since t is computed as s2 · (b + (1 − b) · α)
for a uniform quadratic residue s2 and random bit b, then
t is uniform in Fp. This is because the map deﬁned by
multiplication by α is a bijection between the sets of squares
and non-squares modulo p. Therefore, if s2 is a uniformly
random square, then α·s2 is a uniformly random non-square.
Now, since t is a fresh uniformly random value on each
evaluation, the real world value u and output y, as seen
by Z, will be identically distributed to the simulated values
as long as k + x (cid:54)= 0 and s (cid:54)= 0. Whenever the former
happens in the real world u = 0 is opened, whereas the ideal
world still simulates a random value, so the environment can
distinguish. In the latter case, s = 0, the output y will be
incorrectly computed in the real world, but this can only
happen with probability 1/p.
However, any environment Z that causes k+x = 0 to hap-
pen with non-negligible probability can be used to construct
an algorithm A∗ that breaks the SLS problem, as follows.
A∗ runs Z, emulating a valid execution of ΠLegendre by
replacing Lp(x + k) computation with calls to OLegk . These
modiﬁed transcripts have the same distribution since the
SLS oracle and (keygen) both generate a random key. When
A∗ runs Z internally, it knows the inputs provided by Z
to all parties, so knows the x value on each invocation of
ΠLegendre. Once Z constructs a query for which OLegk returns

0 then A∗ responds to the SLS challenge with k = −x.
Finally, the algorithm looks like this:

1. Interact with Z as the simulator S would do.
2. Instead of computing the Legendre symbol Lp(x + k)

as in FABB-Leg, make a call to OLegk .

3. If OLegk (x) = 0, return −x as the SLS secret.
The only way Z can distinguish between S and ΠLegendre
— except with probability 1/p — is by producing a query x
for which OLegk (x) = 0, since the two worlds are statistically
close up until this point. If Z can do this with probability 
then the probability that A∗ solves the SLS problem is the
same.
Overall, S correctly simulates the protocol ΠLegendre as long
as u (cid:54)= 0, which happens with probability ≤ 1/p +  (s = 0
or solving SLS with probability ).

Perfect Correctness.
The basic protocol above is only statistically correct, as
s2 = 0 with probability 1/p, and if this occurs the output
will always be zero. Although this suﬃces for most appli-
cations, we note that perfect correctness can be obtained,
at the expense of a protocol that runs in expected constant
rounds. We can guarantee that the square s2 is non-zero by
computing it as follows:

• Take a random square [s2] and a random value [y].
• Compute [v] = [y· s2] and open v. If v = 0 then return

to the ﬁrst step.

Note, that the iteration of the ﬁrst step only happens if y = 0
or s = 0, which occurs with probability 2/p, so the expected
number of rounds for this stage of the protocol is one.
4.4 Domain and Codomain Extension

Some applications may require a PRF which takes multi-
ple ﬁnite ﬁeld elements as input, and outputs a ﬁnite ﬁeld
element. We now present how to extend the basic PRF
FLeg(bit) to a function which takes messages consisting of n
ﬁnite ﬁeld elements and outputs a single uniformly random
ﬁnite ﬁeld element. Indeed our input could consist of up to
t elements in the ﬁnite ﬁeld where t ≤ n. In practice we will
take n = 1 or 2, and can then extend to larger lengths using
CBC-mode or Merkle-Damg˚ard (as in Section 1.5).
We ﬁrst deﬁne a statistical security parameter 2−stat, which
bounds the statistical distance from uniform of the output
of our PRF. We let deﬁne p(cid:48) to be the nearest power of two
to the prime p and set α = |p − p(cid:48)|. Then if α/p < 2−stat
we set (cid:96) = (cid:100)log2 p(cid:101), otherwise we set (cid:96) = (cid:100)log2 p(cid:101) + stat. A
standard argument will then imply that the following PRF
outputs values with the correct distribution.
The key for the PRF is going to be an (cid:96)×(n+1) matrix K
of random elements in Fp, except (for convenience) that we
ﬁx the ﬁrst column to be equal to one. To apply the PRF to
a vector of elements x = (x1, . . . , xt) we “pad” x to a vector
of n + 1 elements as follows x(cid:48) = (x1, . . . , xt, 0, . . . , 0, t) and
then product the matrix-vector product y = K · x(cid:48) ∈ (Fp)(cid:96).
The output of FLeg(n) is then given by

FLeg(n)(K, x) =

2i · Lp(yi)

(mod p).

(cid:33)

(cid:32)(cid:96)−1(cid:88)

i=0

438This extended PRF requires one extra round of (cid:96) · (n − 1)
secure multiplications compared to FLeg(bit).

Since the matrix K is compressing, the distribution of
y will act, by the leftover hash lemma, as a random vec-
p. With probability (cid:96)/p we have yi (cid:54)= 0 for all i,
tor in F(cid:96)
which implies that the values of Lp(yi) behave as uniform
random bits, assuming our previous conjectures on the Leg-
endre symbol. Thus the output value of FLeg(n)(K, x) will,
by choice of (cid:96), have statistical distance from uniform in Fp
bounded by 2−stat.

Our choice of padding method, and the choice of the ﬁrst
matrix column to be equal to one, is to ensure that in the
case of n = 1 we have

(cid:33)

(cid:32)(cid:96)−1(cid:88)

FLeg(n)(K, x) =

2i · FLeg(bit)(ki, yi)

(mod p).

i=0

In addition the padding method ensures protection against
length extension attacks.
4.5 Performance

We measured performance using the prime p = 2127 +
45, which implied for FLeg(n) we could take (cid:96) = 128. Both
FLeg(bit) and FLeg(1) obtain very low latencies (0.35ms and
1.2ms over LAN, respectively) due to the low number of
rounds. For a PRF with small outputs, FLeg(bit) achieves by
far the highest throughput, with over 200000 operations per
second. For full ﬁeld element outputs, FLeg(1) is around 128
times slower, but still outperforms AES in all metrics except
for cleartext computation.

5. MIMC
5.1

FMiMC Deﬁnition

MiMC is a comparatively simple block cipher design, where
the plaintexts, the ciphertexts and the secret key are ele-
ments of Fp and can be seen as a simpliﬁcation of the KN-
cipher[40]. Its design is aimed at achieving an eﬃcient im-
plementation over a ﬁeld Fp by minimizing computationally
expensive ﬁeld operations (e.g. multiplications or exponen-
tiations).
Let p a prime that satisﬁes the condition gcd(3, p−1) = 1.
For a message x ∈ Fp and a secret key k ∈ Fp, the encryption
process of MiMC is constructed by iterating a round function
r times. At round i (where 0 ≤ i < r), the round function
Fi : Fp → Fp is deﬁned as:

Fi(x) = (x + k + ci)3,

where ci are random constants in Fp (for simplicity c0 = cr =
0). The output of the ﬁnal round is added with the key k
to produce the ciphertext. Hence, the output of FMiMC(x, k)
is then given by

FMiMC(x, k) = (Fr−1 ◦ Fr−2 ◦ ... ◦ F0)(x) + k.

The condition on p ensures that the cubing function creates
a permutation.
The number of rounds for constructing the keyed permu-
tation is given by r = (cid:100)log3 p(cid:101) - for prime ﬁelds of size 128
bits the number of rounds is equal to r = 82. This number
of round r provides security against a variety of cryptana-
lytic techniques. In particular, due to the algebraic design
principle of MiMC, the most powerful key recovery meth-
ods are the algebraic cryptanalytic attacks, as the Interpo-

lation Attack and the GCD Attack. In the ﬁrst one intro-
duced by Jakobsen and Knudsen in [30], the attacker con-
structs a polynomial corresponding to the encryption func-
tion without any knowledge of the secret key.
In partic-
ular, the attacker guesses the key of the ﬁnal round, con-
structs the polynomial at round r− 1 and checks it with one
extra plaintext/ciphertext pair.
In the second one, given
two plaintext/ciphertext pairs (pj, cj) for j = 1, 2, the at-
tacker constructs the polynomials FMiMC(p1, K) − c1 and
FMiMC(p2, K) − c2 in the ﬁxed but unknown key K. Since
these two polynomials share (K − k) as a factor (where k
is the secret key), the attacker can ﬁnd the value of k by
computing the GCD of them.

If the attacker has access to a limited number of plain-
text/ciphertext pairs only (at most n < p), then the number
of round r can be reduced. In this case, the number of rounds
is given by r = max{(cid:100)log3 n(cid:101),(cid:100)log3 p − 2 log3(log3 p)(cid:101)} - for
prime ﬁeld of size 128 bits, the number of rounds is equal to
r = 73 if n ≤ 2115, while r = (cid:100)log3 n(cid:101) otherwise.
5.2 Computing FMiMC in MPC

We consider two diﬀerent approaches for computing FMiMC
in MPC, with a secret shared key and message. The ba-
sic approach is simplest, whilst the second variant has half
the number of rounds of communication, with slightly more
computation.

MiMCbasic: The naive way to evaluate FMiMC requires one
squaring and one multiplication for each of the r rounds.
Using SPDZ, the squaring costs one opening in one round of
communication, and the multiplication costs two openings
in one round, giving a total of 3r openings in 2r rounds of
communication.

MiMCcube: If for each round we ﬁrst compute a tuple ([r],
[r2], [r3]), where r R← Fp, then given a secret-shared value
[x], we can open y = x− r and obtain a sharing of x3 by the
computation

[x3] = 3y[r2] + 3y2[r] + y3 + [r3]

which is linear in the secret-shared values so does not require
interaction.

For a single MiMC encryption, we ﬁrst compute all of the
cube triples for each round, which takes just one round of
communication by taking a preprocessed random square pair
([r], [r2]) and performing one multiplication to obtain [r3].
Each round of the cipher then requires just one opening and
a small amount of interaction. The total communication
complexity is still 3r openings, but in only r rounds.
5.3 Performance

Using r = 73, we measured a latency of 12ms per evalua-
tion for the simple protocol MiMCbasic, which halves to 6ms
for the lower round variant, MiMCcube. MiMCbasic gives a very
high throughput of over 8500 blocks per second (around 20%
higher than MiMCcube), and the oﬄine cost is fairly low, at
34 blocks per second. In fact, apart from in latency, MiMC
outperforms all the other PRFs we studied.

6. PERFORMANCE EVALUATION

In this section, we evaluate the performance of the PRFs
using the SPDZ multi-party computation protocol [26, 25],

439which provides active security against any number of cor-
rupted parties. We focus here on the two-party setting, al-
though the protocol easily scales to any number of parties
with roughly a linear cost.

The two main metrics we use to evaluate performance are
latency and throughput, both of which relate to the online
phase of the SPDZ protocol. Latency measures the waiting
time for a single PRF evaluation; the best possible latency
is recorded by simply timing a large number of sequential
executions of the PRF, and taking the average for one op-
eration. In contrast, throughput is maximized by running
many operations in parallel to reduce the number of rounds
of communication. Of course, this comes at the expense of
a higher latency, so a tradeoﬀ must always be made depend-
ing on the precise application. In addition to latency and
throughput, we present the cost of running the preprocess-
ing phase and computing the PRF on cleartext data, for
comparison.

Implementation Details: We implemented the protocols
using the architecture of Keller et al. [32], which runs the
online phase of SPDZ. This system automatically uses the
minimum number of rounds of communication for a given
program description, by merging together all independent
openings. We extended the software to use the Miracl library
for elliptic curve operations over the NIST P-256 curve, as
required for the Naor-Reingold protocol. Note that although
the SPDZ implementation supports multi-threading, all of
our online phase experiments are single-threaded to simplify
the comparison.

Data type

Triple/Sq.
Bit

Triple/Sq.
Bit

LAN

WAN

Fp (ms)

128-bit

256-bit

F
2128 (ms)

0.204
0.204

4.150
4.150

0.816
0.816

16.560
16.560

0.204

0.00014

4.150

0.00285

Table 2: Time estimates for generating preprocess-
ing data in various ﬁelds using oblivious transfer.

To estimate the cost of producing the preprocessing data
(multiplication triples, random bits etc.), we used ﬁgures
from the recent MASCOT protocol [31], which uses OT ex-
tensions to obtain what are currently the best reported triple
generation times with active security. Although in [31], ﬁg-
ures are only given for triple generation in a 128-bit ﬁeld,
we can also use these times for random square and random
bit generation, since each of these can be easily obtained
from one secret multiplication [21]. For the Naor-Reingold
PRF, we multiplied these times by a factor of 4 to obtain
estimates for a 256-bit ﬁeld (instead of 128), reﬂecting the
quadratic communication cost of the protocol. 4 The costs
for all of these preprocessing data types are summarized in
Table 2.

Note that LowMC only requires multiplication triples in
F2, for which the protocol of [29] could be much faster than
4The experiments in [31] showed that communication is the
main bottleneck of the protocol, so this should give an ac-
curate estimate.

using F
an implementation of this protocol, so use the F
for now.

2128 triples. However, we are not currently aware of
2128 times

Benchmarking Environment: In any application of MPC,
one of the most important factors aﬀecting performance is
the capability of the network. We ran benchmarks in a stan-
dard 1Gbps LAN setting, and also a simulated WAN setting,
which restricts bandwidth to 50Mbps and latency to 100ms,
using the Linux tc tool. This models a real-world envi-
ronment where the parties may be in diﬀerent countries or
continents. In both cases, the test machines used have Intel
i7-3770 CPUs running at 3.1GHz, with 32GB of RAM.

Results: The results of our experiments in the LAN and
WAN environments are shown in Tables 3 and 4, respec-
tively. All ﬁgures are the result of taking an average of 5
experiments, each of which ran at least 1000 PRF opera-
tions. We present timings for AES and LowMC purely as a
comparison metric; as explained in the introduction, these
are not suitable for many MPC applications as they do not
operate over a large characteristic ﬁnite ﬁeld.

LowMC obtains slightly better throughput and latency
than AES over a LAN, with both the vector and M4R meth-
ods achieving similar performance here. In the WAN setting,
LowMC gets a very high throughput of over 300 blocks per
second. This is due to the low online communication cost for
multiplications in F2 instead of F2n or Fp, and the fact that
local computation is less signiﬁcant in a WAN. The M4R
method gets half the latency of the vector method in this
scenario, since the number of rounds is halved. As discussed
earlier, the preprocessing for LowMC would likely be much
better than AES if implemented with the protocol of [29].

In both scenarios, the Legendre PRF gives the lowest la-
tency, even when outputing 128-bit ﬁeld elements rather
than bits, due to its low round complexity. The single-bit
output variant achieves by far the highest throughput of all
the PRFs, so would be ideally suited to an application based
on a short-output PRF, such as secure computation of the
(leaky) order-revealing encryption scheme in [18]. The Leg-
endre PRF with large outputs is useful in scenarios where
low latency is very important, although the preprocessing
costs are expensive compared to MiMC below. However,
the high cost of the Legendre PRF “in the clear” may not
make it suitable for applications in which one entity is en-
crypting data to/from the MPC engine

The Naor-Reingold PRF also achieves a low latency —
though not as good as the Legendre PRF — but it suﬀers
greatly when it comes to throughput. Notice that in the
LAN setting, the constant rounds protocol actually performs
worse than the logarithmic rounds variant in all measures,
showing that here the amount of computatation and com-
munication is more of a limiting factor than the number of
rounds. Proﬁling suggested that over 70% of the time was
spent performing EC scalar multiplications, so it seems that
computation rather than communication is the bottleneck
in these timings. The requirement for a 256-bit ﬁeld (for
128-bit security) will be a limiting factor in many applica-
tions, as will the need to bit decompose the input, if it was
previously a single ﬁeld element.

The MiMC cipher seems to provide a good compromise
amongst all the prime ﬁeld candidates, especially as it also
performs well when performed “in the clear”. The “cube”

440PRF

AES

FLowMC(vector)
FLowMC(M4R)

FNR(128)(log)
FNR(128)(const)

FLeg(bit)
FLeg(1)

FMiMC(basic)
FMiMC(cube)

PRF

AES

FLowMC(vector)
FLowMC(M4R)

FNR(128)(log)
FNR(128)(const)

FLeg(bit)
FLeg(1)

FMiMC(basic)
FMiMC(cube)

Best latency

Best throughput

Prep. (ops/s)

Cleartext (ops/s)

(ms/op)

Batch size

7.713
4.302
4.148

4.375
4.549
0.349
1.218
12.007
5.889

2048
256
64

1024
256
2048
128
2048
1024

ops/s

530
591
475

370
281
202969
1535
8788
6388

5.097
2.562
2.565

4.787
2.384
1225
9.574
33.575
33.575

Table 3: Performance of the PRFs in a LAN setting

Best latency

(ms/op)

Best throughput

Batch size

2640
1315
659

713
478
202
210
7379
3691

1024
2048
2048

1024
1024
1024
512
512
512

ops/s

31.947
365
334

59.703
30.384
2053
68.413
59.04
79.66

Table 4: Performance of the PRFs in a simulated WAN setting

106268670
7000
1420

1359
1359
17824464
115591
189525
189525

Prep. (ops/s)

0.256
0.1259
0.1261

0.2359
0.1175
60.241
0.4706
1.650
1.650

variant, which halves the number of rounds, eﬀectively halves
the latency compared to the naive protocol. This results
in a slightly worse throughput in the LAN setting due to
the higher computation costs, whereas in the WAN set-
ting round complexity is more important. Although the la-
tency is much higher than FLeg, due to the large number of
rounds, MiMC achieves the best throughput for Fp-bit out-
puts, with over 6000 operations per second. In addition, the
pre-processing costs of MiMC are better than that of both
Legendre and the Naor-Reingold PRFs.

So in conclusion there is no single PRF which meets all the
criteria we outlined at the beginning. But one would likely
prefer the Legendre PRF for applications which require low
latency, and which do not involve any party external to the
MPC engine, and MiMC for all other applications.

7. ACKNOWLEDGEMENTS

The work in this paper has been partially supported by the
ERC via Advanced Grant ERC-2010-AdG-267188-CRIPTO,
the Defense Advanced Research Projects Agency (DARPA)
and Space and Naval Warfare Systems Center, Paciﬁc (SSC
Paciﬁc) under contract No. N66001-15-C-4070, and by the
Austrian Science Fund via project P26494-N15.

8. REFERENCES
[1] M. Albrecht, G. Bard, and W. Hart. Algorithm 898:

Eﬃcient multiplication of dense matrices over GF(2).
ACM Transactions on Mathematical Software
(TOMS), 37(1):9, 2010.

[2] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and

T. Tiessen. MiMC: Eﬃcient encryption and
cryptographic hashing with minimal multiplicative
complexity. Cryptology ePrint Archive, 2016.
http://eprint.iacr.org/2016/492.

[3] M. Albrecht, C. Rechberger, T. Schneider, T. Tiessen,

and M. Zohner. Ciphers for MPC and FHE.
Cryptology ePrint Archive, Report 2016/687, 2016.
http://eprint.iacr.org/2016/687.

[4] M. R. Albrecht, C. Rechberger, T. Schneider,

T. Tiessen, and M. Zohner. Ciphers for MPC and
FHE. In E. Oswald and M. Fischlin, editors,
EUROCRYPT 2015, Part I, volume 9056 of LNCS,
pages 430–454. Springer, Heidelberg, Apr. 2015.

[5] J. Bar-Ilan and D. Beaver. Non-cryptographic

fault-tolerant computing in constant number of rounds
of interaction. In P. Rudnicki, editor, 8th ACM
PODC, pages 201–209. ACM, Aug. 1989.
[6] M. Bellare, A. Boldyreva, and A. O’Neill.

Deterministic and eﬃciently searchable encryption. In
A. Menezes, editor, CRYPTO 2007, volume 4622 of
LNCS, pages 535–552. Springer, Heidelberg, Aug.
2007.

[7] R. Bendlin, I. Damg˚ard, C. Orlandi, and S. Zakarias.

Semi-homomorphic encryption and multiparty
computation. In K. G. Paterson, editor,
EUROCRYPT 2011, volume 6632 of LNCS, pages
169–188. Springer, Heidelberg, May 2011.

[8] P. Bogetoft, D. L. Christensen, I. Damg˚ard,

441M. Geisler, T. Jakobsen, M. Krøigaard, J. D. Nielsen,
J. B. Nielsen, K. Nielsen, J. Pagter, M. I.
Schwartzbach, and T. Toft. Secure multiparty
computation goes live. In R. Dingledine and P. Golle,
editors, FC 2009, volume 5628 of LNCS, pages
325–343. Springer, Heidelberg, Feb. 2009.

V. Rijmen. Nessie proposal: Noekeon. In First Open
NESSIE Workshop, 2000.

[20] I. Damg˚ard. On the randomness of legendre and jacobi

sequences. In S. Goldwasser, editor, CRYPTO’88,
volume 403 of LNCS, pages 163–172. Springer,
Heidelberg, Aug. 1990.

[9] A. Boldyreva, N. Chenette, and A. O’Neill.

[21] I. Damg˚ard, M. Fitzi, E. Kiltz, J. B. Nielsen, and

Order-preserving encryption revisited: Improved
security analysis and alternative solutions. In
P. Rogaway, editor, CRYPTO 2011, volume 6841 of
LNCS, pages 578–595. Springer, Heidelberg, Aug.
2011.

[10] D. Boneh, K. Lewi, M. Raykova, A. Sahai,

M. Zhandry, and J. Zimmerman. Semantically secure
order-revealing encryption: Multi-input functional
encryption without obfuscation. In E. Oswald and
M. Fischlin, editors, EUROCRYPT 2015, Part II,
volume 9057 of LNCS, pages 563–594. Springer,
Heidelberg, Apr. 2015.

[11] J. Borghoﬀ, A. Canteaut, T. G¨uneysu, E. B. Kavun,
M. Kneˇzevi´c, L. R. Knudsen, G. Leander, V. Nikov,
C. Paar, C. Rechberger, P. Rombouts, S. S. Thomsen,
and T. Yal¸cin. PRINCE - A low-latency block cipher
for pervasive computing applications - extended
abstract. In X. Wang and K. Sako, editors,
ASIACRYPT 2012, volume 7658 of LNCS, pages
208–225. Springer, Heidelberg, Dec. 2012.

[12] J. Bourgain, M. Z. Garaev, S. V. Konyagin, and I. E.

Shparlinski. On the hidden shifted power problem.
SIAM Journal on Computing, 41(6):1524–1557, 2012.

[13] A. Canteaut, S. Carpov, C. Fontaine, T. Lepoint,

M. Naya-Plasencia, P. Paillier, and R. Sirdey. Stream
ciphers: A practical solution for eﬃcient
homomorphic-ciphertext compression. In Fast
Software Encryption - 23nd International Workshop,
FSE 2016, 2016.

[14] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C.

Rosu, and M. Steiner. Highly-scalable searchable
symmetric encryption with support for Boolean
queries. In R. Canetti and J. A. Garay, editors,
CRYPTO 2013, Part I, volume 8042 of LNCS, pages
353–373. Springer, Heidelberg, Aug. 2013.

[15] O. Catrina and S. de Hoogh. Improved primitives for

secure multiparty integer computation. In J. A. Garay
and R. D. Prisco, editors, SCN 10, volume 6280 of
LNCS, pages 182–199. Springer, Heidelberg, Sept.
2010.

[16] O. Catrina and S. de Hoogh. Secure multiparty linear

programming using ﬁxed-point arithmetic. In
D. Gritzalis, B. Preneel, and M. Theoharidou, editors,
ESORICS 2010, volume 6345 of LNCS, pages
134–150. Springer, Heidelberg, Sept. 2010.

[17] O. Catrina and A. Saxena. Secure computation with

ﬁxed-point numbers. In R. Sion, editor, FC 2010,
volume 6052 of LNCS, pages 35–50. Springer,
Heidelberg, Jan. 2010.

[18] N. Chenette, K. Lewi, S. A. Weis, and D. J. Wu.
Practical order-revealing encryption with limited
leakage. In Fast Software Encryption - 23nd
International Workshop, FSE 2016, 2016.

[19] J. Daemen, M. Peeters, G. Van Assche, and

T. Toft. Unconditionally secure constant-rounds
multi-party computation for equality, comparison, bits
and exponentiation. In S. Halevi and T. Rabin,
editors, TCC 2006, volume 3876 of LNCS, pages
285–304. Springer, Heidelberg, Mar. 2006.

[22] I. Damg˚ard, M. Geisler, M. Krøigaard, and J. B.
Nielsen. Asynchronous multiparty computation:
Theory and implementation. In S. Jarecki and
G. Tsudik, editors, PKC 2009, volume 5443 of LNCS,
pages 160–179. Springer, Heidelberg, Mar. 2009.

[23] I. Damg˚ard and M. Keller. Secure multiparty AES. In
R. Sion, editor, FC 2010, volume 6052 of LNCS, pages
367–374. Springer, Heidelberg, Jan. 2010.

[24] I. Damg˚ard, M. Keller, E. Larraia, C. Miles, and N. P.

Smart. Implementing AES via an actively/covertly
secure dishonest-majority MPC protocol. In
I. Visconti and R. D. Prisco, editors, SCN 12, volume
7485 of LNCS, pages 241–263. Springer, Heidelberg,
Sept. 2012.

[25] I. Damg˚ard, M. Keller, E. Larraia, V. Pastro,

P. Scholl, and N. P. Smart. Practical covertly secure
MPC for dishonest majority - or: Breaking the SPDZ
limits. In J. Crampton, S. Jajodia, and K. Mayes,
editors, ESORICS 2013, volume 8134 of LNCS, pages
1–18. Springer, Heidelberg, Sept. 2013.

[26] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias.

Multiparty computation from somewhat homomorphic
encryption. In R. Safavi-Naini and R. Canetti, editors,
CRYPTO 2012, volume 7417 of LNCS, pages 643–662.
Springer, Heidelberg, Aug. 2012.

[27] I. Damg˚ard and R. W. Zakarias. Fast oblivious AES A

dedicated application of the MiniMac protocol. In
AFRICACRYPT 2016, pages 245–264, 2016.

[28] S. Duval, V. Lallemand, and Y. Rotella. Cryptanalysis

of the FLIP family of stream ciphers. In CRYPTO
2016, 2016.

[29] T. K. Frederiksen, M. Keller, E. Orsini, and P. Scholl.

A Uniﬁed Approach to MPC with Preprocessing
Using OT. In T. Iwata and J. H. Cheon, editors,
ASIACRYPT 2015, volume 9452 of LNCS, pages
711–735. Springer, Heidelberg, Dec. 2015.

[30] T. Jakobsen and L. R. Knudsen. The interpolation

attack on block ciphers. In E. Biham, editor, FSE’97,
volume 1267 of LNCS, pages 28–40. Springer,
Heidelberg, Jan. 1997.

[31] M. Keller, E. Orsini, and P. Scholl. MASCOT: Faster

malicious arithmetic secure computation from
oblivious transfer. Cryptology ePrint Archive, 2016.
http://eprint.iacr.org/2016/505.

[32] M. Keller, P. Scholl, and N. P. Smart. An architecture

for practical actively secure MPC with dishonest
majority. In A.-R. Sadeghi, V. D. Gligor, and
M. Yung, editors, ACM CCS 13, pages 549–560. ACM
Press, Nov. 2013.

[33] S. Laur, R. Talviste, and J. Willemson. From oblivious

442AES to eﬃcient and secure database join in the
multiparty setting. In M. J. Jacobson Jr., M. E.
Locasto, P. Mohassel, and R. Safavi-Naini, editors,
ACNS 13, volume 7954 of LNCS, pages 84–101.
Springer, Heidelberg, June 2013.

[34] C. H. Lim and T. Korkishko. mCrypton - a

lightweight block cipher for security of low-cost RFID
tags and sensors. In J. Song, T. Kwon, and M. Yung,
editors, WISA 05, volume 3786 of LNCS, pages
243–258. Springer, Heidelberg, Aug. 2006.

[35] Y. Lindell and B. Riva. Blazing fast 2PC in the
oﬄine/online setting with security for malicious
adversaries. In I. Ray, N. Li, and C. Kruegel:, editors,
ACM CCS 15, pages 579–590. ACM Press, Oct. 2015.

[39] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S.

Burra. A new approach to practical active-secure
two-party computation. In R. Safavi-Naini and
R. Canetti, editors, CRYPTO 2012, volume 7417 of
LNCS, pages 681–700. Springer, Heidelberg, Aug.
2012.

[40] K. Nyberg and L. R. Knudsen. Provable security

against a diﬀerential attack. Journal of Cryptology,
8(1):27–37, 1995.

[41] B. Pinkas, T. Schneider, N. P. Smart, and S. C.

Williams. Secure two-party computation is practical.
In M. Matsui, editor, ASIACRYPT 2009, volume 5912
of LNCS, pages 250–267. Springer, Heidelberg, Dec.
2009.

[36] S. Lu and R. Ostrovsky. Distributed oblivious RAM

[42] A. Russell and I. Shparlinski. Classical and quantum

for secure two-party computation. In A. Sahai, editor,
TCC 2013, volume 7785 of LNCS, pages 377–396.
Springer, Heidelberg, Mar. 2013.

polynomial reconstruction via Legendre symbol
evaluation. Journal of Complexity, 20(2-3):404–422,
2004.

[37] P. M´eaux, A. Journault, F. Standaert, and C. Carlet.

[43] W. Van Dam. Quantum algorithms for weighing

Towards stream ciphers for eﬃcient FHE with
low-noise ciphertexts. In M. Fischlin and J. Coron,
editors, EUROCRYPT 2016, volume 9665 of Lecture
Notes in Computer Science, pages 311–343. Springer,
2016.

[38] M. Naor and O. Reingold. Number-theoretic

constructions of eﬃcient pseudo-random functions. In
38th FOCS, pages 458–467. IEEE Computer Society
Press, Oct. 1997.

matrices and quadratic residues. Algorithmica,
34(4):413–428, 2002.

[44] W. van Dam, S. Hallgren, and L. Ip. Quantum

algorithms for some hidden shift problems. In 14th
SODA, pages 489–498. ACM-SIAM, Jan. 2003.

[45] F. Vercauteren. The hidden root problem. In S. D.

Galbraith and K. G. Paterson, editors, PAIRING
2008, volume 5209 of LNCS, pages 89–99. Springer,
Heidelberg, Sept. 2008.

443