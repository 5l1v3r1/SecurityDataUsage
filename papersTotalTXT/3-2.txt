Unconditionally-Secure Robust Secret Sharing

with Minimum Share Size

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

Department of Computer Science

University of Calgary, Canada

Abstract. An n-player (t, δ)-secure robust secret sharing scheme is a
(t, n)-threshold secret sharing scheme with the additional property that
the secret can be recovered, with probability at least 1 − δ, from the set
of all shares even if up to t players provide incorrect shares. The existing
constructions of robust secret sharing schemes for the range n/3 ≤ t <
n/2 have the share size larger than the secret size. An important goal
in this area is to minimize the share size. In the paper, we propose a
new unconditionally-secure robust secret sharing scheme for the case
n ≥ 2t + 2 with share size equal to the secret size. This is the minimum
possible size as dictated by the perfect secrecy of the scheme. We discuss
our results and propose directions for future research.

1

Introduction

Secret Sharing is one of the most important tools in modern cryptography. The
concept and the ﬁrst realization of secret sharing were presented independently in
[24] and in [3]. In a secret sharing scheme, there exists a dealer, n participants,
and possibly a reconstructor. The dealer splits a secret s ∈ S, into n pieces,
called shares, and sends one share to each participant over a private point-to-
point channel. An access structure is the set of subsets of participants that
are qualiﬁed to recover the secret. In a (t, n)-threshold access structure, where
1 ≤ t < n, any t + 1 or more participants can reconstruct the secret, and the
knowledge of t or less shares leaves the secret s indeterminate. A (t, n)-threshold
secret sharing scheme is said to be perfect if no subset of t or less shares can leak
any information about the secret s where the leakage is in information theoretic
sense and without assuming any limit on the computational resources of the
adversary.

In its basic form, secret sharing assumes that the corrupted participants
are passive (or semi-honest) and follow the protocol during the reconstruction
phase. Extensions of this basic model considers cases that the corrupted partici-
pants deviate from the protocol [19, 27, 22, 4, 6, 20]. In these extensions diﬀerent
requirements such as cheater detection [4], cheater identiﬁcation [20] and un-
trusted dealer [8] have been considered. A minimal robust requirement when
participants are allowed to submit incorrect shares, is that the set of all shares,
some possibly corrupted, can recover the correct secret. Perfect secret sharing

2

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

schemes that satisfy this additional property are called robust secret sharing
schemes.

Robust secret sharing schemes provide a powerful tool for building secure and
reliable distributed data storage systems. Users’ data (ﬁles) can be broken into
pieces (shares) and stored on multiple servers such that privacy of data against
servers is provided, and the system ensures recovery of the data when a subset
of servers corrupt their stored shares, accidentally or intentionally. In recent
years, systems and architectures based on this primitive have emerged [16, 28,
11] which shows importance of robust secret sharing in practice. Robust secret
sharing has also direct application to Secure Message Transmission (SMT). In
an unconditionally secure SMT [10, 12, 13], a sender is connected to a receiver
through n wires such that up to t of which are controlled by an adversary.
The goal of an SMT protocol is to ensure that the message sent by the sender
is received correctly by the receiver, and no information about the message is
leaked to the adversary. Good robust secret sharing schemes lead to good secure
message transmission schemes [18]. Robust secret sharing schemes may also be
seen as an stepping stone towards the construction of veriﬁable secret sharing
(VSS) schemes [8], in which, in addition to the corrupted players, the dealer is
dishonest and may hand out inconsistent shares. Finally robust secret sharing is
an important primitive for secure multi-party computation.

1.1 Motivation

In perfect threshold robust secret sharing schemes, in addition to the requirement
of perfect threshold secret sharing schemes,

– any t + 1 shares reconstruct the secret, and any t shares give no information

about the secret,

it is also required that,

– the secret can be reconstructed with high probability from the set of all

shares, even if up to t shares are incorrect.

The reconstruction may be with, or without, a reconstructor, and may include
one or more rounds of communication [9, 7]. Also, reconstruction failure may be
deﬁned diﬀerently [9, 7]. These variations of the model needs careful considera-
tions in comparing schemes and their performances. A framework for consider-
ing robust secret sharing is provided in [23], which includes schemes in both the
information-theoretic and computationally secure settings.

In this paper we shall follow the model of [7], where during the reconstruction,
all the n players communicate their shares to a trusted third party called the
reconstructor. Based on the received shares (some of them are incorrect), the
reconstructor then produces an output s(cid:48), which with a probability at least 1− δ
is the same as the original secret s.

Important eﬃciency measures for robust secret sharing schemes are the com-
munication cost (number of communicated bits) of reconstruction [9] and the

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

3

share size measured by the number of bits required to represent a share. In this
paper we focus on the latter measure. It is well known that in any perfect se-
cret sharing scheme, the length of a share σi is at least the length of the secret,
that is log |S| [25]. Secret sharing schemes that meet this lower bound are called
ideal [25]. Shamir secret sharing meets this lower bound and is ideal. This lower
bound also holds for robust secret sharing scheme which are perfect secret shar-
ing schemes. So a natural question is how much redundancy, that is extra share
length compared to the secret length, is needed for robustness.

It follows from the theory of Reed-Solomon error correcting codes that Shamir
secret sharing scheme is robust if (and only if) t < n/3 [1] and so no increase in
the share size is needed to obtain robustness. On the other hand, the robust secret
sharing is impossible if t ≥ n/2: the (t, n)-threshold access structure requires at
least (t + 1) correct shares for the recovery of the original secret. The interesting
range is n/3 ≤ t < n/2. In this range, all existing schemes have share sizes that
are strictly larger than the secret size. The problem is naturally more diﬃcult
when t is maximal in the range n/3 ≤ t < n/2 i.e., n = 2t + 1 (when n is odd)
and n = 2t + 2 (when n is even). In particular, for the range n/3 ≤ t < n/2,
there is no known robust secret sharing scheme such that,

– the maximum length of individual share size of a participant is the same
as the secret size (thus no increase in the share size), and the probability
of correctly recovering the secret from the set of all shares is at least 1 − δ,
where δ is a negligible value.

This is irrespective of the computational complexity of reconstruction which can
be exponential in n. The result of this paper shows that it is possible to keep
the share size same as the secret size when n ≥ 2t + 2.

1.2 Our Contribution

We consider the model of [7] in which reconstruction is by a trusted reconstruc-
tor, and propose a new construction of robust secret sharing which is based on
Shamir’s secret sharing and has share size equal to the secret size, which is the
minimum required by perfect secret sharing schemes. That is, the extra robust-
ness property is obtained without increasing the share size. The system’s public
parameter, in addition to what is required by Shamir’s scheme, includes a struc-
tured matrix that has O(n) random elements. This matrix can be distributed
during share distribution, or stored on an authenticated and publicly accessi-
ble storage. The system works for n ≥ 2t + 2 and eﬀectively uses the share of
the extra participants as the veriﬁcation information. We note that if n is even,
then n = 2t + 2 is the minimum required number of participants. For n odd,
the scheme works for n = 2t + 2 and so constructing a scheme without share
increase for n = 2t + 1 is an open problem.

The reconstruction is one round and requires participants to send their shares
to the reconstructor. The reconstruction is secure against a non-rushing adver-
sary (this is properly deﬁned in Sect. 2.2), and the reconstruction procedure

4

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

may output an incorrect secret with a negligible probability. The reconstruction
algorithm however is ineﬃcient and requires that all subsets of size t + 1 of n
shares be considered. Construction of schemes with the above properties and
eﬃcient reconstruction, remains an open problem.

1.3 Related Work

Cheating detection and providing robustness against cheaters, is an important
problem in secret sharing schemes. Diﬀerent models and constructions have been
proposed for this problem over the year [22, 4, 6, 19, 27, 20]. Robustness in the
sense of recoverability of the secret when some shares are wrong is a basic prop-
erty that ensures the secret is not lost because of the share corruption. Robust
secret sharing with unconditional security was ﬁrst considered by McEliece and
Sarwate [19] where they pointed out the close relationship between Shamir se-
cret sharing scheme and Reed-Solomon coding. Little is known about robust
secret sharing for the range n/3 ≤ t < n/2. The ﬁrst scheme for the range
n/3 ≤ t < n/2 is due to Rabin and BenOr [22]. Their scheme consists of Shamir
secret sharing, but enhanced by means of an unconditionally secure message au-
thentication code. The constructions in [9, 7] represent the two main approaches
to this problem and provide the best performances in terms of trade-oﬀ results
between share size and the reconstruction complexity (see Sect. 5 for their de-
scription). In [9], the redundancy of the share size is exactly two ﬁeld elements
(here n = 2t + 1, secert size is one ﬁeld element, and the reconstruction model
is diﬀerent). The reconstruction time is however exponential in n. The scheme
in [7] has the smallest share size (see Sect. 6) among schemes with eﬃcient
(polynomial) reconstruction.

2 Preliminaries

We begin by formally deﬁning the model of robust secret sharing. The “deﬁni-
tions” are taken verbatim from [7].

2.1 Robust Secret Sharing

A robust secret sharing scheme can be described by two interactive protocols,
Share and Rec, where Share involves a dealer D and n players P1, . . . , Pn, and Rec
involves the n players and a reconstructor R. The dealer is connected to every
player by a secure, untappable channel. There is also a broadcast channel that
can be used by everyone in the system. An n-player robust secret sharing scheme
for a secret space S consists of two phases, the sharing and the reconstruction
phase, speciﬁed by two protocols Share and Rec respectively, described below.
Let [n] = {1, . . . , n}.
– Share: The dealer D takes as input a secret s ∈ S, locally computes shares
σ1, . . . , σn, and for every i ∈ [n], sends the i-th share σi privately to player
Pi.

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

5

– Rec: During reconstruction, player Pi, i ∈ [n], communicates, possibly by
means of several synchronous communication rounds, σi to the reconstructor
R. The reconstructor R uses the received shares to produce an output s(cid:48),
which is supposed to be the original secret s.

2.2 Adversarial Capabilities

We now specify the capabilities (and limitations) of the adversary who has un-
bounded computing power. The goal of the adversary is to make the reconstruc-
tor output a value diﬀerent from the original secret s.

– During the sharing phase, the adversary remains inactive, and does not learn
any information about the secret as the shares are distributed using private
channels between players and the dealer.

– After the sharing phase, the adversary can adaptively corrupt up to t of
the players Pi, where t is the threshold parameter. The corruption can
be done between communication rounds and continue as long as the total
number of corrupted players does not exceed t. D or R are assumed incor-
ruptible. Once a player Pi is corrupted, the adversary learns Pi’s share σi,
and from then on, the adversary has full control over Pi. The corruptions
being adaptive means that after each corruption, the adversary can decide
on whom to corrupt next depending on the shares he has seen so far.

– During the reconstruction phase, the adversary sees the communications
between players Pi and the reconstructor R. Furthermore, he controls the
information that the dishonest players send to the reconstructor R. Recon-
struction in general has multiple rounds. In every communication round, for
every corrupted player, the adversary decides what this player should send
to R. A rushing adversary can choose these values after observing what
honest players send to R in the current round. A non-rushing adversary
selects the corrupted shares before the start of the reconstruction phase.

2.3 Security

An n-player robust secret sharing scheme (Share, Rec) is (t, δ)-secure if the fol-
lowing properties hold for any distribution of s ∈ S and for any adversary as
speciﬁed above:

1. Privacy: Before Rec starts, the adversary has no more information about
2. Reconstructability: At the end of Rec, the reconstructor R outputs s(cid:48) = s

the shared secret s than he had before the execution of Share.
with probability at least 1 − δ.

It is well known that in any perfect secret sharing scheme, the bit-size of
a share σi is at least the same as the bit-size of secret, that is log |S| [25].
Much research eﬀort focused on ﬁnding the least required redundancy to achieve
robustness. Let σi denotes the share for player Pi. The redundancy (also known
as overhead) is measured by the quantity maxi{log σi} − log |S|. For t < n/3,

6

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

one can use Reed-Solomon error correcting codes to construct a robust secret
sharing scheme with eﬃcient reconstruction algorithm and no redundancy in
the share size i.e., the share size is the same as the secret size [1]. On the other
hand, for t ≥ n/2 there is no solution to the problem (the (t, n)-threshold access
structure requires at least t + 1 correct shares for the recovery of the original
secret). In this work we construct a robust secret sharing scheme for n = 2t + 2
with no redundancy in the share size. The construction works for any t in the
range n

3 ≤ t ≤ n

2 − 1.

3 The Proposed Scheme

The scheme of [9] can be understood as being obtained from a secret sharing
scheme that allows error detection, i.e., that detects if a set of t + 1 shares
contains some incorrect ones (but can not necessarily tell which ones). It was
analyzed in [15] that any secret sharing scheme with error detection [5, 21, 27]
can be transformed into a robust secret sharing scheme by looping over all sets of
size t + 1. This line of thinking has provided schemes with low share redundancy
and the work in [9] represents the best so far. It is apparent that any such
scheme will suﬀer from the same exponential complexity and our new proposal,
being constructed on this line, is no exception, but what is interesting is that
the proposed scheme employs a technique that leverage some extra public values
to eliminate redundancy in the shares.

3.1 The Scheme
Let t and n are positive integers such that n = 2t+2. Let Fq be a ﬁnite ﬁeld with
q elements, where q is a prime power with q > n. We now present an n-player
robust secret sharing scheme over Fq which is (t, δ) secure and individual share
size is same as secret size.

– Share:

most t such that f (0) = s and computes si = f (i) for all i ∈ [t + 1].

a selection) and for every i ∈ [n], he computes σi =(cid:80)t+1

• Let s ∈ Fq be a secret.
• The dealer randomly chooses a polynomial f (x) ∈ Fq[x] of degree at
• D choose n vectors of length t + 1, (ri1, . . . , ri(t+1)) ∈ (Fq)n, 1 ≤ i ≤ n
such that any t + 1 of them are linearly independent (see below for such
• For every i ∈ [n], the dealer D sends to player Pi the share σi (just one
ﬁeld element). The n vectors {(ri1, . . . , ri(t+1))}1≤i≤n are part of system’s
public parameters. The dealer can send the public parameters to users,
using the broadcast channel. Alternatively the public parameters can be
stored on a publicly accessible authenticated bulletin board.

j=1 rijsj ∈ Fq.

– Rec:• Every player sends σi to the reconstructor R.

• To reconstruct the secret, the reconstructor does the following for every

subset of t + 1 players.

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

7

t+1) using t + 1 shares by solving t + 1

∗ He reconstructs (s(cid:48)

2, . . . , s(cid:48)
equations in t + 1 variables.

∗ He checks if(cid:80)t+1

1, s(cid:48)
j=1 rijs(cid:48)

j = σi for at least one of the remaining t + 1
• R then computes (using Lagrange interpolation) a polynomial f (x) ∈

shares, and halts if it holds.

Fq[x] of degree at most t and outputs s = f (0).

3.2 Remarks
Standard methods are available to choose n vectors of length t + 1 over Fq with
the property that any t + 1 of them are linearly independent. For completeness
we describe some of them here. Let z1, . . . , zn, w1, . . . , wt+1 ∈ Fq be such that
the zi’s are distinct, the wj’s are distinct, and zi + wj (cid:54)= 0 for all i, j. Deﬁne

(cid:18) 1

(cid:19)

ri =

, . . . ,

1

zi + wt+1

zi + w1

, 1 ≤ i ≤ n .

One can check that any t + 1 vectors chosen among these n row vectors are
linearly independent as the matrix so formed has non-zero determinant (see Ch
11, [17]). In particular let M denote the matrix with rows r1, . . . , rt+1, then

(cid:81)
(cid:81)
i<j(zj − zi)(wj − wi)

i,j(zi + wj)

.

det(M ) =

The number of ﬁeld elements that are distributed publicly is equal to n + t + 1.
Another way of selection is to choose an n × (t + 1) Vandermonde matrix which
also has the property that any t + 1 rows are independent. A Vandermonde
matrix of size n × (t + 1) can be described by n elements and in this case only
n ﬁeld elements are distributed publicly.

4 Security

4.1 Perfect Secrecy

The secret is the constant term of a random polynomial of degree at most t.
The t + 1 evaluations of the polynomial, {s1, . . . , st+1}, are independent and are
needed to reconstruct the secret. We will show that any group CP = {Pi1, . . . , Pit}
of corrupted participants will be completely uncertain about at least one value
from {s1, . . . , st+1}. This is true because the group CP has t shares {σi1, . . . , σit}
and these shares correspond to t equations,

M · (s1, . . . , st+1)T = (σi1, . . . , σit)T ,

where M is the t × (t + 1) matrix consisting of the t row vectors ri1 , . . . rit
associated with the corrupted users, and ‘T’ denotes matrix transpose.

Let M1, . . . , Mt+1 be the column vectors of M . As Mi’s constitute a set
of t + 1 t-dimensional vectors, they are linearly dependent. Thus there exists

8

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

at least one column vector, without loss of generality say M1, such that M1
belongs to the subspace (cid:104)M2, . . . , Mt+1(cid:105). So there exists a (t + 1)-dimensional
vector b = (b1, . . . , bt+1) such that M bT = 0 and b1 (cid:54)= 0. Thus, we have
(σi1 , . . . , σit)T = M · (s1, . . . , st+1)T = M · ((s1, . . . , st+1)T + α(b1, . . . , bt+1)T )
for all α ∈ Fq. Hence, given any β1 ∈ Fq, there exists (β1, . . . , βt+1) ∈ (Fq)t+1
such that M · (β1, . . . , βt+1)T = (σi1, . . . , σit )T . Therefore, the participants in
CP cannot rule out any element of Fq as a possibility for s1. Thus, there exists q
values for s1 and distinct values for s1 leads to distinct polynomials. This makes
f (0) indeterminate.
(cid:117)(cid:116)

4.2 Reliability

Theorem 1. Let k be a security parameter. For any positive integer n and t such
that n = 2t + 2, and any ﬁnite ﬁeld Fq with k = (cid:100)log2 q(cid:101), the pair (Share, Rec)
forms an n-player (t, δ)-robust secret sharing for message space Fq with

√
t + 1
2k−n

.

δ ≤

Proof. Consider the state of the reconstruction phase right before the recon-
structor R has received the shares from the players. We may assume that at this
stage the adversary has corrupted t players. Thus R has now n shares of which
at most t are corrupted. To reconstruct the secret, R does the following for every
subset of t + 1 players.
(a) He computes (s(cid:48)
1, s(cid:48)

t+1) using t + 1 chosen shares (σ(cid:48)

2, . . . , s(cid:48)

, . . . , σ(cid:48)

, σ(cid:48)

)

it+1

i1

i2

(by solving t + 1 equations in t + 1 variables).

(b) He then checks if (cid:80)t+1

j=1 rijs(cid:48)
shares, and halts if it holds.

j = σi for at least one of the remaining t + 1

Consider an arbitrary set A = {σ(cid:48)
} of t + 1 shares submitted during
the reconstruction phase. Let us assume that j (0 ≤ j ≤ t) of them are corrupted.
Let M be the matrix with rows ri1, . . . , rit+1 such that,

, . . . , σ(cid:48)

it+1

i1

M · (s(cid:48)
t+1)T = σ(cid:48)

1, . . . , s(cid:48)
˜M1 +··· + σ(cid:48)

i1

t+1)T = (σ(cid:48)

i1

, . . . , σ(cid:48)

it+1

)T .

t+1

it+1

1, . . . , s(cid:48)

Then (s(cid:48)
˜Mt+1, where the ˜Mi’s are the columns
of the inverse matrix M−1. For a ﬁx set of values of the j corrupted shares,
there are qt+1−j solution vectors to the above equality. Therefore the probabil-
ity that the solution vector is a solution to one of the remaining equations is
(cid:18)
qt+1−j , the maximum value is t+1
q when j = t. Thus, taking into account union
bound over all subsets of size t + 1 leaves us with the failure probability ≤ √
t+1
2k−n
(cid:117)(cid:116)
as (t + 1) ·
The eﬃciency comparison for the proposed scheme with the known schemes

t + 1 · 2n when n = 2t + 2 and k = (cid:100)log2 q(cid:101)

(cid:18) n

≤ √

(cid:19)

(cid:19)

t + 1

.

(described below) is given in Sect. 6.

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

9

5 Known Schemes and Possible Extensions

Previous works on robust secret sharing schemes with unconditional security for
the range n/3 ≤ t < n/2 can be broadly divided into two classes. We now brieﬂy
recall the best scheme from each class.

The ﬁrst one is due to Cramer et al. [9], based on an idea by [5]. The scheme
works as follows. Using standard Shamir secret sharing, the dealer shares inde-
pendently the actual secret s ∈ Fq, a randomly chosen ﬁeld element r ∈ Fq,
and their product p = s · r. To reconstruct the secret, the reconstructor does
the following: for every subset of t + 1 players, he reconstructs s(cid:48), r(cid:48) and p(cid:48) and
checks if s(cid:48) · r(cid:48) = p(cid:48), and halts and outputs s(cid:48) if it is the case. One can show that
for any subset of t + 1 players: if s(cid:48) (cid:54)= s then s(cid:48) · r(cid:48) (cid:54)= p(cid:48) except with probability
1/q. Thus for a ﬁeld of size 2k, taking into account union bound over all subsets
of size t + 1, gives a robust secret sharing scheme with failure probability 2k−n
and shares of size 3k bits (consisting of three ﬁeld elements).

The second scheme is given by Cevellos, Fehr, Ostrovsky and Rabani [7], and
is based on the scheme of Rabin and BenOr [22] with an elegant twist to its
reconstruction algorithm. This scheme’s description is given below.

– Share:

that f (0) = s.

• Choose a random polynomial f (x) ∈ Fq[X] with degree at most t such
• Compute the Shamir shares s1 = f (x1), . . . , sn = f (xn), where xi’s are
distinct points in Fq.
• For every pair i, j ∈ [n], choose a random key keyij ∈ K and compute
τij = M AC(keyji, si), where M AC : Fq × K → T be an -secure MAC
[29, 30, 7] with message space Fq.

• For every i ∈ [n], the player Pi is given the share

σi = (si, τi1, . . . , τin, keyi1, . . . , keyin).

– Rec:• First Round: Every player Pi sends si and τi1, . . . , τin. to the recon-

structor R.

• Second Round: Every player Pi sends keyi1, . . . , keyin to R.
• Local Computation:

∗ For every pair i, j ∈ [n], R sets νij to be 1 if the share si of player
Pi is accepted by the corresponding key of player Pj, i.e., if τij =
MAC(keyji, si), and else to 0.

∗ R computes the largest set I ⊆ [n] with the property that

∀i ∈ I : |{j ∈ I|νij = 1}| =

νij ≥ t + 1 ;

(cid:88)

j∈I

in other words, every share of a player in I is accepted by at least t+1
players in I. Clearly I contains all honest players. Let c = |I|−(t+1)
be the maximum number of corrupt players in I.

10

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

∗ Use the Berlekamp-Welch algorithm [2, 14] to compute a polynomial
f (x) ∈ F[X] of degree at most t such that f (xi) = si for at least
2 players i in I. If no such polynomial exists then R outputs
(t+1)+ c
⊥; otherwise, he outputs s = f (0).

The Share algorithm of this scheme is the same as the well-known scheme of
Rabin and Ben-Or [22] which relies on message authentication. The redundancy
in share size for Rabin and Ben-Or scheme consists of 3n elements from the ﬁeld
where the secret is drawn from. The scheme uses a message authentication code
with short tags and keys and with the resulting weak security. The short tags and
keys result in the required saving (improvement over Rabin and Ben-Or scheme)
in the share size. The weakened security of authentication (and so higher chance
of forging) is compensated with a more sophisticated reconstruction procedure
which runs in polynomial time and results in an exponentially small failure
probability. The overhead of the share size depends directly on the exponent of
the failure probability.

Assuming the same share distribution as Rabin and Ben-Or’s scheme [22], one
may consider further reduction in authentication information and improvement
in the reconstruction, to obtain shorter share sizes. In Sect. 5.1 we explore one
such possibility by employing list decoding algorithm for Reed-Solomon codes
[26] in the reconstruction algorithm of [7]. Our goal is to reduce δ, the error
probability of the decoder, which will translate into smaller share size. Our anal-
ysis shows that this modiﬁcation does not reduce δ and so the share size cannot
be further reduced.

5.1 Using List Decoding to Improve Decoding Error in [7]

We begin by describing a natural modiﬁcation to the Cevallos et al.’s Scheme.

– Share: Same
– Rec:

• First Round: Same
• Second Round: Same
• Local Computation: Step 1 and 2 are the same as above. Recall that
c = |I| − (t + 1) is the maximum number of corrupt players in I.
∗ Step 3 of Cevallos et al. scheme: Use Berlekamp-Welch to com-
pute a polynomial f (x) ∈ F[X] of degree at most t such that f (xi) (cid:54)=
si for at most c
∗ Modiﬁcation: Use list decoding algorithm for [n = 2t + 1, k =
t + 1, d = n− k + 1 = t + 1] Reed-Solomon codes [26] that corrects up
to n−√
nt of errors, to compute a (list of) polynomial(s) f (x) ∈ F[X]
of degree at most t such that f (xi) (cid:54)= si for at most
(c + 1)
players in I.

2 players in I.

∗ Find correct f from the decoding list and output s = f (0).

√

1

1+

t

t+1+c

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

11

5.2 Robustness:

The analysis is similar to [7]. Deﬁne the following sets: A ⊂ [n] is the set of
corrupted players that have handed in modiﬁed Shamir shares, and P ⊂ [n] is
the set of corrupted players that have handed in the correct Shamir shares. It
holds that |A| + |P| = t. The set H = [n]\(A ∪ P) is the set of uncorrupted
players.

θ · (p + 1) players i ∈ A end up in I, where p = |P| and θ =

(cid:113) t
The set I computed during reconstruction contains H and P with certainty.
Thus, the reconstruction procedure is guaranteed to output the correct secret
if at most 1
n .
θ · (p + 1), then the requirement for list-decoding is satisﬁed
Indeed, if |A∩I| ≤ 1
θ · (p + 1) and thus
(|I| = t + 1 + c = t + 1 + p + e where e = |A ∩ I| ≤ 1
θ · (p + 1) = 1
e = 1
We need to ﬁnd the probability P [|A ∩ I| > 1

θ (p + 1) + 1) = 1

1+θ (c + 1)).

1+θ (p + 1

1+θ · t; indeed if p > θ
1+θ · (t− 1) = 1

1+θ · t and thus p ≥ θ

θ · (p + 1)]. It is suﬃcient to
1+θ · (t− 1) then
θ · (p + 1)].

1+θ · (t + 1) and hence P [|A∩P| ≤ 1

consider the case p ≤ θ
obviously |A| ≤ t− θ
Thus

1+θ ·t(cid:88)

θ

p=1

P [|A ∩ I| >

· (p + 1)] .

1
θ

δ =

For any p in the range 1 ≤ p ≤ θ

θ ·(p+1)].
θ·(p+1) is an integer. In order to bound the above probability,

1+θ ·t, we ﬁrst compute P [|A∩I| > 1

Let us assume that 1
it is convenient to introduce the following random variables:

– For every pair i, j ∈ [n], we deﬁne the binary random variable Vij that
speciﬁes if the player Pi’s share and his submitted tag associated with player
Pj are accepted by player Pj’s key. Note that, all the Vij with i ∈ [n] and
j ∈ H are independent. Further P [Vij = 1] ≤  for all i ∈ A and j ∈ H.

– For every i ∈ A the random variable

(cid:88)

j∈H

Ni =

Vij = |{j ∈ H|Vij = 1}| ,

i.e., the number of honest players that accept Pi’s incorrect share. Note that
since the Vij’s are independent for all i ∈ [n] and j ∈ H, so are all the Ni’s.

12

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

P [|A ∩ I| >

1
θ

· (p + 1)] = P [

(cid:18)

|A ∩ I| =

1
θ

(cid:19)

(cid:18)

∪ ··· ∪

· (p + 1) + 1

|A ∩ I| = t − 1
θ
· (p + 1)] (best strategy for adversary)

· (p + 1)

(cid:19)

]

≤ P [|A ∩ I| = t − 1
θ
= P [∩i∈A\P (Ni = 1)]
=

P [Ni = 1]

i∈A\P

i∈A\P

=

(cid:89)
(cid:89)
≤ (cid:89)
≤ (cid:89)

i∈A\P

 (cid:88)

i∈A\P

H0⊆H:|H0|=1

((t + 1) · )

P [∃H0 ⊆ H : (|H0| = 1) ∧ (∀j ∈ H0 : Vij = 1)]



P [∀j ∈ H0 : Vij = 1)]

= ((t + 1) · )t− 1

θ ·(p+1)

We can now compute the robustness probability as follows:

θ

1+θ ·t(cid:88)
1+θ ·t(cid:88)

p=1

θ

p=1

δ =

≤

P [|A ∩ I| >

· (p + 1)]

1
θ

((t + 1) · )t− 1

θ ·(p+1)

≤ ((t + 1) · )
≤ 2((t + 1) · )

1+θ ·t− 1

θ

θ

1+θ ·t− 1

θ

θ (1 + ((t + 1) · )

1

θ + ((t + 1) · )

2

θ + ··· ) [assuming,  ≤ 1
t + 1

]

Note that the bound on δ is similar to the bound while considering the
Berlekamp-Welch setting. Also note that we have not included the analysis for
the required probability to ﬁnd the correct polynomial from the list of polyno-
mials output by the list decoding algorithm.

6 Eﬃciency Comparison

In this section we compare the eﬃciency of our scheme, in terms of relation
among the following three parameters: secret size, the share size and the relia-
bility in the reconstruction, with the schemes of Cramer et al. [9] and Cevallos
et al. [7]. Note that our scheme works for n ≥ 2t + 2 while the other two schemes
work for n ≥ 2t + 1. To share a k-bit secret among the n players using our

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

13

proposed scheme, the failure probability is at most
al. scheme it is
respectively.

√
t+1
2k−n , and for the Cramer et
2k−n . The share size for the two schemes are k bits and 3k bits,

1

Understanding the relation for [7] is more subtle. Here the failure probability
depends on an extra parameter. Let λ be a parameter that can be chosen inde-
pendent of the secret size k. The two parameters λ, k are used in the following
MAC function which has been used in [7]:

M AC : GF (2k) × (GF (2k/λ))2 → GF (2k/λ) .

Sharing a k-bit secret among the n players using the scheme [7], results in the
. For λ ≤ n, the failure probability is
λ −n log(n·λ). The share size
λ = k + 3((cid:96) + n log(n· λ)). Clearly [7] has eﬃcient reconstruction

failure probability of at most
less than for the other schemes. Let us deﬁne (cid:96) = n k
for [7] is k + 3n k
complexity and improved failure probability. However the share size is higher
than the other two schemes.

−n log(n·λ)

1

2n k

λ

Table 1. Comparison Table

Scheme

Secret size
(in bits)

Share size (in bits) Rec Com-

δ

plexity

Public
Parameters

[9]

[7]

Proposed
Scheme

k

k

k

3k

Exp. in n

2−(k−n)

Nil

k +3((cid:96)+n log(n·λ)) Poly. in n 2−(n k

λ −n log(n·λ)) Nil

k

Exp. in n

√

t + 1 · 2−(k−n) n ﬁeld ele-

ments

The last column for public parameters represents the elements that are re-
quired in addition to the interpolating points for Shamir’s secert sharing scheme.

7 Conclusion

The problem of the minimum share size for robust secret sharing has received
considerable attention in recent years. In this paper, we proposed and analyzed
a new robust secret sharing scheme for which the share size of participants is
the same as the secret size. This is the minimum possible value for the share
size of a perfect secret sharing scheme and hence also the least possible share
size for robust secret sharing. The result is interesting as it means that the
extra robustness property can be obtained with no extra cost on the share size.
However the scheme works only for n ≥ 2t + 2 and eﬀectively uses the share of
one extra honest participant as the veriﬁcation information. The reconstruction

14

Mahabir Prasad Jhanwar and Reihaneh Safavi-Naini

algorithm is exponential in the number of players. Construction of schemes with
eﬃcient reconstruction in our setting, and also robust secret sharing schemes
with share size equal to the secret size for n = 2t + 1, remain open problems.

Acknowledgments.

Financial support for this research was provided in part by Alberta Innovates -
Technology Futures, in the Province of Alberta in Canada.

References

1. Michael Ben-Or, Shaﬁ Goldwasser, and Avi Wigderson. Completeness theorems
for non-cryptographic fault-tolerant distributed computation (extended abstract).
In Janos Simon, editor, STOC 1988, pages 1–10. ACM, 1988.

2. E. R. Berlekamp and L. R. Welch. Error correction of algebraic block codes. U.S.

patent number 4.633.470. 1986.

3. G. Blakley. Safeguarding cryptographic keys. AFIPS National Computer Confer-

ence, 48:313–317, 1979.

4. Ernest F. Brickell and Douglas R. Stinson. The detection of cheaters in threshold

schemes. SIAM J. Discrete Math., 4(4):502–510, 1991.

5. Sergio Cabello, Carles Padr´o, and Germ´an S´aez. Secret sharing schemes with de-
tection of cheaters for a general access structure. In Gabriel Ciobanu and Gheorghe
Paun, editors, Fundamentals of Computation Theory 1999, volume 1684 of LNCS,
pages 185–194. Springer, 1999.

6. Marco Carpentieri, Alfredo De Santis, and Ugo Vaccaro. Size of shares and prob-
ability of cheating in threshold schemes. In Tor Helleseth, editor, EUROCRYPT
1993, volume 765 of LNCS, pages 118–125. Springer, 1993.

7. Alfonso Cevallos,

Serge Fehr, Rafail Ostrovsky,

and Yuval Rabani.
Unconditionally-secure robust secret sharing with compact shares.
In David
Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of
LNCS, pages 195–208. Springer, 2012.

8. Benny Chor, Shaﬁ Goldwasser, Silvio Micali, and Baruch Awerbuch. Veriﬁable
secret sharing and achieving simultaneity in the presence of faults (extended ab-
stract). In FOCS 1985, pages 383–395. IEEE Computer Society, 1985.

9. Ronald Cramer, Ivan Damg˚ard, and Serge Fehr. On the cost of reconstructing a
secret, or VSS with optimal reconstruction phase. In Joe Kilian, editor, CRYPTO
2001, volume 2139 of LNCS, pages 503–523. Springer, 2001.

10. Danny Dolev, Cynthia Dwork, Orli Waarts, and Moti Yung. Perfectly secure mes-

sage transmission. In FOCS 1990, pages 36–45. IEEE Computer Society, 1990.

11. G.R. Ganger, P.K. Khosla, M. Bakkaloglu, M.W. Bigrigg, G.R. Goodson, S. Oguz,
V. Pandurangan, C.A.N. Soules, J.D. Strunk, and J.J. Wylie. Survivable storage
systems.
In DARPA Information Survivability Conference amp; Exposition II,
2001. DISCEX ’01. Proceedings, volume 2, pages 184 –195 vol.2, 2001.

12. Juan A. Garay, Clint Givens, and Rafail Ostrovsky. Secure message transmission
with small public discussion. In Henri Gilbert, editor, EUROCRYPT 2010, volume
6110 of LNCS, pages 177–196. Springer, 2010.

13. Juan A. Garay, Clint Givens, and Rafail Ostrovsky. Secure message transmission

by public discussion: A brief survey. In IWCC, pages 126–141, 2011.

Unconditionally-Secure Robust Secret Sharing with Minimum Share Size

15

14. Peter Gemmell and Madhu Sudan. Highly resilient correctors for polynomials. Inf.

Process. Lett., 43(4):169–174, 1992.

15. Kaoru Kurosawa and Kazuhiro Suzuki. Almost secure (1-round, n-channel) mes-

sage transmission scheme. IEICE Transactions, 92-A(1):105–112, 2009.

16. Subramanian Lakshmanan, Mustaque Ahamad, and H. Venkateswaran. Respon-
sive security for stored data. IEEE Trans. Parallel Distrib. Syst., 14(9):818–828,
2003.

17. Florence J. MacWilliams and Neil J. A. Sloane. The theory of error-correcting

codes. North-Holland publishing company.

18. Keith M. Martin, Maura B. Paterson, and Douglas R. Stinson. Error decodable
secret sharing and one-round perfectly secure message transmission for general
adversary structures. Cryptography and Communications, 3(2):65–86, 2011.

19. Robert J. McEliece and Dilip V. Sarwate. On sharing secrets and Reed-Solomon

codes. Commun. ACM, 24(9):583–584, 1981.

20. Satoshi Obana. Almost optimum t-cheater identiﬁable secret sharing schemes. In
Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages
284–302. Springer, 2011.

21. Wakaha Ogata, Kaoru Kurosawa, and Douglas R. Stinson. Optimum secret sharing

scheme secure against cheating. SIAM J. Discrete Math., 20(1):79–95, 2006.

22. Tal Rabin and Michael Ben-Or. Veriﬁable secret sharing and multiparty protocols
In David S. Johnson, editor, STOC

with honest majority (extended abstract).
1989, pages 73–85. ACM, 1989.

23. Phillip Rogaway and Mihir Bellare. Robust computational secret sharing and a
uniﬁed account of classical secret-sharing goals. In Peng Ning, Sabrina De Capitani
di Vimercati, and Paul F. Syverson, editors, ACM Conference on Computer and
Communications Security, pages 172–184. ACM, 2007.

24. A. Shamir. How to share a secret. Communications of the ACM, 22(11):612–613,

1979.

25. Douglas R. Stinson. An explication of secret sharing schemes. Des. Codes Cryp-

tography, 2(4):357–390, 1992.

26. Madhu Sudan. Decoding of Reed-Solomon codes beyond the error-correction

bound. J. Complexity, 13(1):180–193, 1997.

27. Martin Tompa and Heather Woll. How to share a secret with cheaters. J. Cryp-

tology, 1(2):133–138, 1988.

28. Marc Waldman, Aviel D. Rubin, and Lorrie Faith Cranor. The architecture of

robust publishing systems. ACM Trans. Internet Techn., 1(2):199–230, 2001.

29. Mark N. Wegman and Larry Carter. New classes and applications of hash functions.

In FOCS 1979, pages 175–182. IEEE Computer Society, 1979.

30. Mark N. Wegman and Larry Carter. New hash functions and their use in authen-

tication and set equality. J. Comput. Syst. Sci., 22(3):265–279, 1981.

