KI-Mon: A Hardware-assisted Event-triggered 
Monitoring Platform for Mutable Kernel Object

Hojoon Lee, Korea Advanced Institute of Science and Technology (KAIST);  

HyunGon Moon, Seoul National University;  

DaeHee Jang and Kihwan Kim, Korea Advanced Institute of Science and Technology (KAIST); 

Jihoon Lee and Yunheung Paek, Seoul National University;  

Brent ByungHoon Kang, Korea Advanced Institute of Science and Technology (KAIST)

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4KI-Mon: A Hardware-assisted Event-triggered Monitoring Platform for

Mutable Kernel Object

Hojoon Lee1, Hyungon Moon2, Daehee Jang1, Kihwan Kim1, Jihoon Lee2, Yunheung Paek2, and

Brent ByungHoon Kang∗1

1Graduate School of Information Security, KAIST

2Department of Electrical and Computer Engineering, Seoul National University

{hojoon.lee,daehee87,abc,brentkang}@kaist.ac.kr
{hgmoon,jhlee}@sor.snu.ac.kr and ypaek@snu.ac.kr

Abstract
Kernel rootkits undermine the integrity of system by
manipulating its operating system kernel.
External
hardware-based monitors can serve as a root of trust
that is resilient to rootkit attacks. The existing exter-
nal hardware-based approaches lack an event-triggered
veriﬁcation scheme for mutable kernel objects. To ad-
dress the issue, we present KI-Mon, a hardware-based
platform for event-triggered kernel integrity monitor. A
reﬁned form of bus trafﬁc monitoring efﬁciently veriﬁes
the update values of the objects, and callback veriﬁca-
tion routines can be programmed and executed for a des-
ignated event space. We have built a KI-Mon prototype
to demonstrate the efﬁcacy of KI-Mon’s event-triggered
mechanism in terms of performance overhead for the
monitored host system and the processor usage of the
KI-Mon processor.

1

Introduction

Kernel rootkits are a special class of malware that com-
promise an OS kernel; they pose severe threat to the mon-
itored host system as they can hide their attack traces to
stay undetected while persisting in their malicious ac-
tivities. Since rootkits place themselves in the lowest
kernel layer that has the highest privilege level in a sys-
tem, they can trick and compromise any host-based intru-
sion detection system running on the above layer, mak-
ing the detection system ineffective. Many researchers
have made active efforts to address rootkit attacks by
providing a safe execution environment where kernel in-
tegrity monitors can run with the root of trust estab-
lished below the kernel OS layer. These efforts can be
categorized into two types of approaches: Virtual Ma-
chine Monitor (VMM) based [19, 34, 31, 28, 37], and
hardware-based [29, 26, 10, 40]. Both VMM and hard-
ware platforms are used as safe execution environments

∗corresponding author

for integrity monitoring, as a root of trust under the OS
kernel. However, since they are implemented in soft-
ware, VMMs also have to suffer from software vulner-
abilities. As the discoveries of VMM vulnerability con-
tinue [5, 4, 2, 3], more attacks can subvert the VMM
layer underneath the OS kernel [32].

External hardware-based approaches [29, 26] attempt
to utilize the underlying hardware as another root of
trust for integrity monitors, seeking physical isolation
from the monitored system. By deploying the integrity
monitor on an external hardware device, the monitor-
ing can persist even when the entire OS on the moni-
tored host system is compromised. One of the earlier ex-
ternal hardware-based monitors, Copilot [29] presented
a snapshot-based kernel integrity monitor implemented
as a peripheral device. It utilized periodically collected
snapshots of memory contents of the kernel static region
to perform a hash value comparison with a known good
value. In such approaches, increasing the frequency of
snapshot to monitor all the modiﬁcations of a rapidly
changing target leads to signiﬁcant performance over-
head [26]. Therefore, we believe that event-triggered
veriﬁcation is needed for monitoring mutable kernel ob-
jects.

Event-triggered monitoring techniques are relatively
common in VMM-based approaches. Hypercall inter-
ception, page fault interception, exception handling in-
terception, and other techniques using VM Exits in Hard-
ware Virtual Machines (HVM) [37, 17, 34, 38] are well-
known examples. By inserting additional codes into the
handlers of those events, a preset veriﬁer routine can be
executed upon the occurrence of the events. However, in
contrast to VMM-based approaches, the hardware-based
event-triggered approaches are still in their infancy.

The ﬁrst external hardware-based event-triggered
monitoring scheme was introduced in Vigilare [26]. Vig-
ilare is an immutable region snooper that is limited to the
detection of the existence of any write trafﬁc, destined
for the monitored memory region on the host bus.
In

USENIX Association  

22nd USENIX Security Symposium  511

other words, an event in Vigilare only signiﬁes an occur-
rence of a memory modiﬁcation while it does not provide
any ability to extract the data value in the write trafﬁc for
the invariant veriﬁcation, nor does it provide any call-
back mechanism that could further verify the event for
consistent modiﬁcation with respect to other related data
objects. Vigilare’s rudimentary scheme has been sufﬁ-
cient for the immutable regions. However, it is incapable
of monitoring mutable kernel objects.

The contents of mutable objects in dynamic regions,
or dynamic data structures, are frequently modiﬁed by
the operating system kernel. Such a characteristic intro-
duces complexities in monitoring the mutable kernel ob-
jects. Since the modiﬁcations made to the mutable ob-
jects could be legitimate changes, resulting from the nor-
mal operations of a kernel, simply detecting the occur-
rence of modiﬁcation to these structures does not provide
decisive evidence in determining whether the modiﬁca-
tions are malicious or benign. In addition, there are cases
in which verifying the update value against a known good
value is not sufﬁcient for integrity veriﬁcation. Consider
the example of a linked list manipulation attack, where
the adversary removes an entry from a linked list to hide
the entry. Inspecting the linked list will reveal that the
entry has been removed. However, from this observa-
tion alone, we cannot determine if the entry was removed
by an adversary or legitimately removed by the kernel.
In these cases, additional semantic veriﬁcation to check
the consistent modiﬁcation of other related kernel data
structures is required to conﬁrm the legitimacy of these
changes.

We propose an external hardware-based Kernel In-
tegrity Monitoring platform, called KI-Mon. To explore
possibilities of monitoring mutable kernel objects with
an event-triggered mechanism, KI-Mon presents archi-
tectural foundations of hardware-assisted event-triggered
detection and veriﬁcation mechanism. KI-Mon is ca-
pable of generating an event which reports the address
and value pair of memory modiﬁcation, occurred on the
monitored object. Event generation is reﬁned with a sup-
port for whitelist-based ﬁltering to eliminate unnecessary
software involvement in value veriﬁcation. KI-Mon also
allows an event-triggered callback veriﬁcation routine
to be programmed and executed for a designated event
space.
In addition, we developed the KI-Mon API to
ensure the programmability of the platform, which sup-
ports development of monitoring rules. Example mon-
itoring rules were developed and tested against attacks
from real-world rootkits to conﬁrm the effectiveness of
the platform. Also, our evaluation shows the efﬁcacy of
event-triggered monitoring in terms of the performance
overhead to the monitored system using benchmarking
tools.

We built the KI-Mon prototype on a FPGA-based de-

velopment board, and evaluated the effectiveness of KI-
Mon with experiments. We used the STREAMBENCH
and RAMSPEED benchmarking tools for measuring the
performance overhead on the monitored system’s mem-
ory bandwidth. The results showed that the snapshot-
only monitor incurred a signiﬁcant overhead to the mon-
itored host system’s memory bandwidth while KI-Mon
consumed signiﬁcantly less CPU cycles due to its event-
triggered mechanism. This is because KI-Mon detects
memory modiﬁcations at hardware level using VTMU
which features an event ﬁltering mechanism to eliminate
CPU cycles consumed by snapshot-based polling by 6
orders of magnitude.

2 KI-Mon Design

KI-Mon is an external hardware-based Kernel Integrity
Monitor that adapts an event-triggered mechanism to en-
able monitoring of dynamic-content data structures. To
achieve the desired functionality, we designed and im-
plemented a prototype of a platform that includes both
hardware and software components. The design objec-
tives for KI-Mon are summarized as the following:
O1. Safe Execution Environment: The most funda-
mental requirement for any kernel integrity monitor is a
safe execution environment. That is, a kernel integrity
monitor should be designed to be resilient to any type of
interference from the compromised monitored system.
O2. Event-triggered Monitoring: For an external mon-
itor to trace mutable kernel objects, it should be able to
identify any modiﬁcation as an event that is comprised
of an address and value pair. As previously mentioned,
the update value is essential for veriﬁcation of the legiti-
macy of the modiﬁcation. In addition, there needs to be
a mechanism that allows a semantic veriﬁcation routine
to be executed when the value of an event alone cannot
serve as proof that the modiﬁcation is malicious. Fur-
thermore, KI-Mon deviates from periodic state captur-
ing techniques such as memory snapshots, implementing
a hardware platform that focuses on events, rather than
states. We further deﬁne the desiderata for an event-
triggered monitoring mechanism as below, in O2.1 to
O2.4.
O2.1 Reﬁned event generation: For an external moni-
tor to trace mutable kernel objects, it should be able
to identify any modiﬁcation as an event, comprised
of an address and a value pair. Furthermore, a re-
ﬁned event can be generated from raw events by
suppressing commonly occurring benign updates at
the snooping hardware module, so that the veriﬁer
can be engaged only when it is necessary.

O2.2 Event-triggered semantic veriﬁcation: As

previously mentioned,

the value is essential for

512  22nd USENIX Security Symposium 

USENIX Association

2

USENIX Association  

22nd USENIX Security Symposium  513

veriﬁcationofthelegitimacyofthemodiﬁcation.Inaddition,thereneedstobeamechanismthatallowsasemanticveriﬁcationroutinetobeexecutedwhenthevalueofaneventalonecannotserveasaproofthatthemodiﬁcationismalicious.Theroutineshouldreferenceotherrelatedkernelobjectsinordertoverifythesemanticconsistency.O2.3Minimaloverheadonmonitoredsystem:KI-Mondeviatesfromperiodicstatecapturingtechniquessuchasmemorysnapshots,imple-mentingahardwareplatformthatfocusesonevents,ratherthanstates.Anevent-triggeredmechanismshouldalsominimizeperformanceoverheadinﬂictedonthemonitoredsystemduringitsoperation.O2.4Efﬁcientmonitoringprocessorusage:Anevent-triggeredschemeisexpectedtominimizetheworkload,imposedonthemonitoringproces-sor.Thisminimizationcanbebeneﬁcialwhentheamountofmonitoreddataislargerandthehardwarecostofthemonitoringprocessorneedstobelimited.O3.Programmability:Theoperatingsystemsmaintainalargenumberofvariousdynamicdatastructuresduringrun-time,andtheformatandusageofthesedatastruc-turesvaryacrossdifferentoperatingsystems.Moreover,kernelupdatestotheoperatingsystemsoftenchangethebehaviorofkerneloperationsthatarerelatedtothedatastructuresortheformatofthedatastructures.Forthisreason,KI-Monneedstobehighlyprogrammable,inor-dertoguaranteeacertaindegreeofportabilityacrossdif-ferentoperatingsystemversionsandtosupportdevelop-mentofnewmonitoringalgorithms.ThedetailsoftheKI-Mondesignthataddresstheabovedesignobjectiveswillbeexplainedintherestofthissection.Designobjec-tiveO1isachievedusingKI-Mon’shardwareplatformbydesign.WedevelopedKI-MonAPItoprovidepro-grammabilitytoKI-Mon.ThisprogrammabilitysatisﬁesdesignobjectiveO3.DesignobjectiveO2.1isaddressedbyKI-Mon’sHAWmechanism;O2.2isachievedbytheemphEvent-triggeredSemanticVeriﬁcationmechanism.O2.3andO2.4willbefurtherevaluatedinSection4.2.1SafeExecutionEnvironmentTheKI-Monhardwareplatformisacompletemicroprocessor-basedsystemlikethoseinexistingexternalindependentprocessorapproaches[26].WhileKI-Monoperatesindependentlyfromthemonitoredhostsystem,itiscapableofmonitoringhostmemorymodiﬁcationswithabustrafﬁcmonitoringmodulecalledValueTableManagementUnit(VTMU)andaFigure1:KI-MonMonitoringMechanismDirectMemoryAccess(DMA)Moduleforthemonitoredsystem.Thein-depthcapabilitiesofVTMUandtheuseofDMAwillbefurtherdiscussedintherestofthissection,butitshouldbenotedthattheiroperationsdonotinvolvethemonitoredsystem’sprocessor,noranyothercomponentsonthemonitoredsystem.Thisismadepossiblebythesharedbusarchitecture,whichenablesKI-Montoinspectthemonitoredsystem.Ontheotherhand,themonitoredsystemhasnophysicalconnectiontoKI-Monthroughwhichitcouldinteractwith.Infact,themonitoredsystemisnotawareoftheexistenceofKI-Mon.Hence,KI-Monensuresthatitsmonitoringactivitiesaresafeevenwhenthemonitoredhostsystemiscompromisedbyarootkit.Inthisway,KI-MonachievesitsﬁrstdesignobjectiveO1:SafeExecutionEnvironment.2.2Event-triggeredMonitoringKI-Monincorporatesitshardwareandsoftwareplat-form.Thehardwareplatformgenerateseventswhenmodiﬁcationsoccurinthemonitoredregions.Thesoft-wareplatformveriﬁeseventsasshowninFigure1.Theexplanationofthismechanismwillstartfromthecaptur-ingofhostbustrafﬁcinthehardwareplatform.Itwillthenexplorehowthesecapturedinstancesoftrafﬁcarepasseduptothesoftwareplatformforthefurtherveriﬁ-cation.2.2.1ReﬁnedEventGenerationVTMUisthecorecomponentthatmonitorsthehostmemorybustrafﬁctogenerateevents.Itsoperationcanbedividedintothreestages:bustrafﬁcsnooping,ad-dressﬁltering,andvalueﬁltering.Thebusofthemon-itoredsystemisfedintoVTMU,andVTMUextractsonlywritesignalsfromthestreamofthehost’smemory3I/O trafﬁc. As the collected write signals pass through
the address ﬁlter, all signals except the ones correspond-
ing to the monitored region are discarded. Finally, the
signals are once again ﬁltered in the comparator units.
The signals are compared against the preloaded values in
the whitelist registers. The signals with the address and
value pair, that survived the two-stage ﬁltering, are re-
ported to the software platform, running on the KI-Mon
processor. We call this mechanism hardware-assisted
whitelisting (HAW); the reports, sent to the software plat-
form, are called HAW-Events.

Also, it should be noted that the VTMU is a highly
conﬁgurable hardware component, and our software
platform can readily adjust the monitored regions and the
whitelisted values. For instance, the whitelist registers
can be conﬁgured to be inactive, so that all write signals
to the monitored regions generate HAW-Events. In addi-
tion to VTMU, the DMA module is also implemented
and included in the KI-Mon hardware platform. The
module steals memory cycles of host processor to fetch
the contents from the host memory on an on-demand ba-
sis. When the software platform requests the contents
of a certain region of the host memory, the DMA mod-
ule takes a snapshot of the region and provides it to the
kernel integrity monitor. In summary, VTMU is capable
of monitoring host memory without constantly polling
host memory. It can also reduce the generation of benign
events by using a whitelist.

2.2.2 KI-Veri and MonitoringRules

It

Kernel Integrity Veriﬁer (KI-Veri) is the main component
in the software platform, enabling the event-triggered
monitoring mechanism.
interfaces with Monitor-
ingRules, which are high-level objects implemented on
top of the KI-Mon API. Each MonitoringRule deﬁnes the
target regions to be monitored by VTMU, and such re-
gions are called critical regions. VTMU generates HAW-
Events when the contents of these regions are modiﬁed.
For this reason, the regions should be chosen prudently
so that a modiﬁcation of the regions will serve as an
effective trigger to the monitoring mechanism. Critical
regions and their whitelists are stored in VTMU upon
the registration of MonitoringRules.A MonitoringRule
is also required to have predetermined actions such as
an HAW-Event Handler and an Integrity Veriﬁer, to be
executed when HAW-Events occur in the critical re-
gions. These actions are fetched and executed by KI-
Veri. HAW-Event Handlers verify HAW-Events in or-
der to invoke other actions, such as Integrity Veriﬁers, as
needed.

In summary, VTMU monitors critical regions reg-
istered by MonitoringRules in KI-Veri, and generates
HAW-Events when a write signal that does not match any

of the values in the whitelist registers appears in critical
regions. Upon receiving a HAW-Event, KI-Veri executes
the HAW-event handler of the MonitoringRule, that is
responsible for the HAW-Event. Then, the HAW-event
handler triggers an action that corresponds to the pair of
the address and the update value.

2.2.3 Detection Methodology of MonitoringRule

Templates

The main focus of the current implementation of KI-Mon
is to propose an event-triggered monitoring scheme for
mutable kernel objects. Rootkit attacks on mutable ker-
nel objects can be classiﬁed into two categories: control
ﬂow components and data components [19]. Control-
ﬂow components are usually function pointers that store
the addresses of kernel functions. Since such control
ﬂow components are referenced to execute the functions
located at the addresses, rootkits often place hooks on
such components to inject their routine into the control
ﬂow.

Many data components or non-control-ﬂow compo-
nents, store critical pieces of information that reﬂect the
current state of the kernel. Critical data components such
as lists of processes, kernel modules, and network con-
nections lists can be subverted by rootkits so that the
traces of rootkits are hidden. KI-Mon deploys two types
of MonitoringRule templates in its prototype for moni-
toring of control ﬂow and data components: Hardware-
Assisted Whitelisting (HAW)-based Veriﬁcation for con-
trol ﬂow components and Callback-based Semantic Ver-
iﬁcation for data components.

Hardware-Assisted Whitelisting

(HAW)-based
Veriﬁcation: As we discussed in the previous section,
update value veriﬁcation can serve as an indication of
malicious manipulations in some cases; semantic veri-
ﬁcation is otherwise imperative. Recall that a semantic
veriﬁcation references other semantically related kernel
objects to ﬁnd semantic inconsistencies. We observe
that value veriﬁcation is particularly effective against
attacks on control ﬂow components. All control ﬂow
components should point to the functions in the kernel
code section, or functions in the known kernel drivers
loaded via loadable kernel modules. More speciﬁcally,
many control ﬂow components in kernel dynamic data
structures always point to one possible landing site. We
deﬁne such property as the value set invariant of a kernel
object. We take advantage of this property in modeling
the monitoring scheme for control ﬂow components.
HAW-based Veriﬁcation is a MonitoringRule, where
the address of the control ﬂow component is set as a
critical region and its possible landing sites as a whitelist
in VTMU. HAW-events, generated from this type of
MonitoringRule, are simply considered malicious.

514  22nd USENIX Security Symposium 

USENIX Association

4

USENIX Association  

22nd USENIX Security Symposium  515

Callback-basedSemanticVeriﬁcation:Callback-basedSemanticVeriﬁcationisatypeofMonitoringRule,whichisdesignedtoserveasatemplateformonitor-ingkerneldatacomponents.Themonitoringschemeforcontrolﬂowcomponentsisnotsuitableformonitor-ingofmodiﬁcationsondatacomponentsthatrequirese-manticveriﬁcationbecausetheprocessesofidentifyingmemorymodiﬁcationsandtheirvaluesareinadequatefordetectingmanipulationattacksonsemanticinforma-tion.TheHAW-EventhandlercaninvoketheIntegrityVeriﬁerforfurtherinspection,whichinvolvesacquisi-tionofsemanticallyrelateddatastructures.ThistypeofIntegritycheckingiscalledtheenforcementofseman-ticinvariants[12].NotethattheHAW-EventhandlercanbeprogrammedtocallfunctionsotherthanIntegrityVeriﬁers.Thisfeaturecanbeusedtoupdatetheinfor-mationonthemonitoreddatastructure.Forexample,detectionofanewlyinsertedentryinalinkedlistcanbeprogrammedandinvokedbytheHAW-Eventhandler.2.3KI-MonAPIforProgrammabilityAspreviouslymentioned,theMonitoringRulesthatop-erateinKI-MonarebuiltwiththeKI-MonAPI.TheKI-MonAPI,asshowninFigure4,includeshigh-levelsoftwarestacksandlow-leveldriversforthehardwareplatform,toenableconvenientandrapiddevelopmentofkernelintegritymonitoringrules.KI-MonAPIisde-velopedsothatwritingnewMonitoringRules,basedonourdetectionmethodology,becomeconvenient.Itisevenpossibletocreateentirelynewalgorithms.Thus,KI-MonAPIcorrespondstoourthirddesignobjective:O3:Programmability.AmoredetailedexplanationoftheinternalsoftheAPIwillbegiveninthefollowingsec-tion.Figure2:KI-MonHardwarePlatform.(Grayboxshowsbusarchitecture)3PrototypeImplementation3.1KI-MonHardwarePlatformPrototypeTheKI-Monplatform,includingthemonitoredhostsys-tem,isimplementedasanSystemonaChip(SoC)onanFPGA-basedprototypingsystemforrapidprototyp-ing.Figure2showstheoverallstructureofourSoCimplementation.Themonitoredsystem,runningonaLeon3[7]processor,conﬁguredtooperateat50MHz.SnapgearLinuxwithakernelversionof2.6.21.1[18],providedfromtheprovideroftheLeon3processor,wasusedastheoperatingsystemforthemonitoredsystem.BothKI-MonandthehostprocessoruseanS-compatiblesharedbus[9]asaninterconnectionnetwork.AscanbeseenfromFigure2,theKI-Monhardwareplatformhasbeenbuiltonthesamearchitecturebaseasthatofthehostprocessorsystem,beingaugmentedwithnewfea-tureswithevent-triggeredmonitoringcapabilities.OtherthanVTMU,thehardwareplatformalsoin-cludesaDMAmoduleandahashacceleratortosupportsnapshot-relatedfeatures.Aspreviouslydiscussed,theDMAmoduletakessnapshotsofthemonitoredsystem’smemoryandstorestheminKI-Mon’sprivatememory.TheDMAmodulehastwomasterinterfacesandoneslaveinterface.Oneofthetwomasterinterfacesiscon-nectedtothemonitoredsystem’sbus.Theotheriscon-nectedtoKI-Mon’sbus.Withthemasterinterfaces,themoduleiscapableofreadinganyregionsofthemon-itoredsystem’smemory;itcanthencopythecontentstothedesignatedspaceinKI-Mon.Theslaveinterface,whichisconnectedtotheKI-Monbus,isusedforKI-Veriinthesoftwareplatformtomakerequestsforsnap-shots.ThehashacceleratorgeneratesSHA-1hashval-uesfromgivenmemorycontents.ThehashacceleratorhasbothslaveandmasterinterfacestotheKI-Monbus.TheslaveinterfaceisusedtoreceiverequestsforhashingacertainregionandreturningthecalculatedhashvaluetoKI-Mon,andthemasterinterfaceisusedtoreadthememoryregionstobehashed.VTMUisacorecomponentoftheKI-Monhardwareplatform.ItgeneratesHAW-eventsbysnoopingthehostbustrafﬁcformodiﬁcations,ﬁlteringthetrafﬁcbasedontheaddressesandthevaluesbeingwritten.Bydoingso,trafﬁcwithaddressesthatdonotbelongtothemonitoredregionsisignored,asarebenignmodiﬁcationsinwhichawhitelistedvalueiswritten.Asmentionedinthepre-vioussection,VTMUregistersareconﬁgurableviathedriverweimplemented.TheaddressesofthemonitoredregionsandcorrespondingwhitelistscanbepassedtoVTMUatanytime,sotheoperationofVTMUcanbecontrolledevenduringruntime.Inaddition,themonitor-ingcapacity,suchasthetotalnumberofregionsmoni-toredsimultaneouslyorthelengthofthewhitelist,can5516  22nd USENIX Security Symposium 

USENIX Association

Figure3:VTMUInternalArchitectureOverviewbeadjustedeasily.Morespeciﬁcally,onecanincreasethenumberofregistersorsimplyplacemultipleVTMUunitsinKI-Mon.TheoperationofVTMUconsistsofthreestages:bustrafﬁcsnooping,addressﬁltering,andvalueﬁltering.TheﬁrststageofVTMUoperations,bustrafﬁcsnoop-ing,isimplementedbasedonasharedbusarchitecturethatconformstotheAMBA2protocol.Modulesat-tachedtotheAMBA2AHBprotocolbusarecategorizedintomastersandslaves.Mastersareactivemodulesthataccessslavemodulesasneeded,whereasslavesarepas-sivemodulesthatrespondtotherequestsofmasters.Inourimplementation,theprocessorandDMAmodulearemastermodules,andthememorycontroller(MCTRL),serialport(UART),andVTMUareslavemodules.ThegrayboxinFigure2showsthebusarchitectureofthemonitoredsystemandtheKI-Monhardwareplatform.Also,theconnectionsofVTMUontheKI-Monhard-wareplatformareshown.MuxMisamultiplexerunitthatpassesonlyonemaster’strafﬁctoaslave.MuxMiscontrolledbyhardwarelogicscalledarbitersandde-coders.Thesemodulesdecidewhichmasterutilizesthebusateachclockcycle.Thatis,onlyonemastercanutilizethebusateachclockcycle,andallslavesreceivethesametrafﬁcfromthemasterateachtime.Withthishardwareprinciple,wedesignedthebustrafﬁcsnoop-ingstageofVTMUtoacquireallmemorytrafﬁcfromthemonitoredsystembyduplicatingtheoutputsignalsofMuxM.Thetypeofthetrafﬁc–whetherthetrafﬁcin-dicatesawriteoperationornot–ischeckedwithasimplecomparator,sothatthisstageonlypasseswrite-trafﬁctotheaddressﬁlteringstage.ThevalueﬁlteringprocessisthelaststageofVTMUoperations.Thevalueﬁlterisanextensionoftheaddressﬁlterintermsofthehardwarestructure.Whiletheaddressﬁlterhas8setsof2addressregistersthatstorethestartingandendingaddressesofthemonitoredregions,thevalueﬁlterhas8setsof6reg-isters.Thisisbecausethe6whitelistvaluescorrespondtoeachofthe8monitoredregions.Figure4:KI-MonAPITheFIFObufferstorestheoutputoftheﬁlteruntilthatoutputisfetchedbyKI-Mon.AlthoughalargerFIFOwouldbemorerobustagainstburstytrafﬁc,abufferlengthof16wassufﬁcientforourcurrentpro-totypeandexperimentsettings.Thetagregisterskeeptrackofwhitelistvaluesthatmatchtheoccurredtrafﬁc.Theregisterissetoncetrafﬁchitstheregisters.Withthisfeature,KI-Moncanreplacethevaluesinthewhitelistregistersasneededwiththerecentlyusedvalues.Forinstance,KI-Monkeepstherecentlyusedvaluesinthewhitelistregistersandreplacesthosethathavenotre-centlybeenused.Thetrafﬁcthathaspassedthroughthesecondstageisfedintothevalueﬁlters.Thevalueofthetrafﬁc,orthevaluebeingwrittentothemonitoredre-gions,iscomparedwiththevaluesstoredinthewhitelistregisters.Ifthetrafﬁcmatches–meaningthatthistraf-ﬁcindicatesbenignchanges–itisdiscarded;ifthetrafﬁcdoesnotmatch,suchbustrafﬁcisstoredintheFIFObufferunit.Finally,aHAWeventisgeneratedandtrig-gersKI-Veritoacquiretheaddressandvaluepair,gener-atedfromtheFIFObuffer.TheoverallviewofVTMU’sinternalstructureisillustratedinFigure3.3.2KI-MonSoftwarePlatformPrototypeKI-Veri,whichisthemainoperatorofthesoftwareplat-form,ispositionedatthemonitorlayertocoordinatethemonitoringrules,theAPI,andinteractionswiththehardwarecomponents.ThesemanticlayerimplementsMonitoringRule,whichdeﬁnesthemonitoredregions,whitelists,andcorrespondingactions.Thedatastructurelayeraddsabstractionstoaccessthemonitoredsystem’srawmemorycontents,sothattherawdataisparsedintoappropriatetypesandstructures.Lastly,therawdatalayercontainsthelow-leveldriversforthehardwareplat-form,whichdirectlyinteractswiththemonitoredhostsystem’smemoryinterface.KI-MonAPIconsistsof913linesofCcode.Upontheoccurrenceofanevent,KI-VerisearchestheVTMUregisterstoﬁndtheMonitoringRuleinstanceforwhichtheregistersarereserved.Then,KI-Veriexecutes6the HAW-event handler of the MonitoringRule instance
to verify which action needs to be invoked for the HAW-
event.

As shown in Figure 5, KI-Veri retrieves the pointer
to the MonitoringRule that is responsible for the HAW-
event. The HAW-event handler of this MonitoringRule
determines the action that needs to be taken for the given
addr and value pair. The pair contains the address, where
the modiﬁcation has occurred and the value of the modi-
ﬁcation.

The class MonitoringRule is implemented as an
object-oriented C structure. It is designed to serve as a
template for writing a kernel integrity monitoring rule
on KI-Mon’s event-triggered mechanism. The class in-
cludes critical regions, corresponding whitelists, an ini-
tializer function, and the action functions. Figure 6 is a
pseudo code deﬁnition of the class MonitoringRule.

The CriticalRegion data structure deﬁnes the starting
and ending address of the monitored region as well as the
whitelist for the region. The initMonitoringRule can con-
tain initialization procedures such as acquiring of the ad-
dresses of the monitored data structures, which addresses
will be stored in the criticalRegion variable. The on-
HawEvent deﬁnes the action to be taken upon the arrival
of HAW-events from the hardware layer. If the Moni-
toringRule was of a HAW-based Veriﬁcation template –
all write attempts to the monitored regions are consid-
ered malicious if they are not in the whitelist – the func-
tion can simply declare that an attack was detected. For
the MonitoringRules, which were written for a Callback-
based Semantic Veriﬁcation template, onHawEvent can
call inspectIntegrity passing arguments as needed. Then,
the inspectIntegrity function veriﬁes the modiﬁcation re-
ported via HAW-event with memory snapshots collected
from the monitored system. Similarly, traceDataStruc-
tures can be called if onHawEvent sees that the HAW-
event generated signiﬁes change in the location or size
of the monitored structure.

onHawEventFromVTMU(addr,value) {
monitoringRule = getMonitoringRuleFor(addr);
requiredAction = \
monitoringRule->HawEventHandler(addr,value);
if(requiredAction == INSPECT_NEEDED) {
monitoringRule->inspectIntegrity(argArray);
}
else if(requiredAction == RAISE_ALERT) {
monitoringRule->traceDataStructures(argArray);
}
else {
//Other requiredAction can be here
}

Figure 5: KI-Veri’s Main Routine

typedef struct MonitoringRuleType {
CriticalRegion criticalRegion;
void initMonitoringRule();
int (*onHawEvent)(addr,value);
int (*inspectIntegrity)(argArray);
int (*traceDataStructures)();
}MonitoringRule;

Figure 6: Class MonitoringRule

The functions and macros deﬁned in the data struc-
ture layer can be used as building blocks for implement-
ing the action functions in MonitoringRules. The Data
Structure Acquisition Engine is the actual implementa-
tion of the layer. Memory snapshots extracted from the
monitored system’s memory are raw memory contents.
Since KI-Mon or any other external hardware monitor
does not have OS-managed metadata of the monitored
data structures, additional parsing and constructing of a
meaningful data structure out of the raw data is essential.

The Raw Data Layer consists of the low-level hard-
ware drivers that provide core functionalities for the up-
per layers. The VTMU Driver manages the memory
value veriﬁcation units, which count up to 16 in our cur-
rent implementation. Each unit consists of 6 registers:
the ﬁrst two registers store the starting and ending ad-
dresses of the interval to be monitored. The rest of the
registers store the whitelisted values referenced by the
comparators. It should be noted that the VTMU driver
only engages in the conﬁguration of the hardware. That
means, the memory bus trafﬁc monitoring can be effort-
lessly done in the hardware layer thus it is not neces-
sary for the driver to be running during the monitoring.
VTMU notiﬁes the software stack of an event when a
write event to the monitored regions is detected. The
DMA Driver makes DMA requests to the monitored sys-
tem memory to acquire memory snapshots. The func-
tionality of the driver is rather straightforward: given
an address and size of a snapshot, it fetches the region
from the monitored system memory. The aforemen-
tioned Data Structure Acquisition Engine adds usabil-
ity to the snapshot-taking capability of the DMA mod-
ule. The Address Translation Engine translates the vir-
tual addresses of the monitored system into a physical
address. The Address Translation Engine implements
a virtual to physical address translation process of the
monitored system in KI-Mon. The Address Translation
Engine performs page table walks by fetching the corre-
sponding entries of the page table in the monitored sys-
tem’s memory.

USENIX Association  

22nd USENIX Security Symposium  517

7

3.3 KI-Mon MonitoringRule Examples

In order to illustrate the monitoring capabilities of KI-
Mon and the programmability of its API, we developed
two MonitoringRule examples against the two real-world
rootkit attacks, ported to operate on the Linux kernel
running on our prototype, where the VFS hooking at-
tack from Adore-NG is an example of an attack on ker-
nel control-ﬂow components and the LKM hiding attack
from EnyeLKM is a kernel data component manipulation
attack.

The two examples that we choose, represent real-
world rootkit attacks on control-ﬂow and data compo-
nents. We analyzed the open source real-world rootk-
its [39, 16, 27, 33, 1] and referenced works that analyzed
the behaviors of well-known rootkits [42, 35, 22, 19]. Ta-
ble 1 summarizes some of the attacks on kernel mutable
objects identiﬁed from the rootkits. These well-known
rootkits manipulate both the control-ﬂow and the data
components. It is noticeable that the VFS hooking at-
tack and its variants, which manipulates the control-ﬂow
components of Linux Virtual File System including the
proc ﬁle system (VFS) [24, 14], are popular for being
deployed to hide ﬁles, processes, and network connec-
tions. Also, the LKM hiding was a common behavior
among the analyzed rootkits. The attack manipulates a
module->list structure to hide an entry in the Loadable
Kernel Module (LKM) list. The rootkits utilize LKMs
as a means to inject kernel-level code into the victimized
kernel, and they launch the LKM hiding attack once their
malicious code is loaded in the kernel memory space.

One of the two MonitoringRules we implemented is
built using the HAW-based veriﬁcation template to de-
tect the VFS hooking attack. The other MonitoringRule
is built using the Callback-based Semantic Veriﬁcation
template to demonstrate the detection of the LKM hid-
ing attack. The rest of this subsection provides the two
attack examples and our MonitoringRules in detail.

VFS Hooking Attack: The Virtual File System
(VFS) [24, 14] provides an abstraction to accessing ﬁle
systems in the Linux kernel; all ﬁle access is made
through VFS in the modern Linux kernel. The kernel
maintains a unique inode data structure for each ﬁle,
which includes a fops data structure that stores pointers
to the VFS operation functions such as open, close, read,
write, and so forth. Various critical information about the
kernel, such as the network connections and the system
logs, are stored in the form of a ﬁle and are queried via
the VFS interface. Rootkits are capable of directly ma-
nipulating the functionalities of VFS. More speciﬁcally,
they can hook the VFS operation functions of the fops
data structure in a ﬁle to manipulate the contents read
from it. Examples of malicious exploitation of VFS in-
clude hiding network connections or running processes,

Table 1: Examples of Attacks on Mutable Kernel Objects
Rootkit
Name
Adore-NG 0.41

Target
Object Type
inode->i ops

task struct->
{ﬂags,uid,...}
module->list

Knark 2.4.3

proc dir entry

task struct->
ﬂags
module->list

Kis 0.9

proc dir entry

tcp4 seq fops

module->list

EnyeLKM 1.3

module->list

Object
Type
Control-ﬂow
component
Data
component
Data
component

Control-ﬂow
component
Data
component
Data
component

Control-ﬂow
component
Control-ﬂow
component
Data
component

Data
component

associated with the attacker. In Linux, /proc [24] con-
tains important ﬁles that maintain system information.
By hooking the VFS data structure that corresponds to
/proc, the adversary can deceive administrative tools that
rely on /proc for retrieving system information.

VFS MonitoringRule: The implemented VFS Moni-
toringRule applies the HAW-based Veriﬁcation method
to detect VFS hooking attacks on /proc in the Linux
ﬁlesystem. We observe that the VFS operation func-
tion pointers in the fops data structure store the addresses
of the legitimate ﬁlesystem functions. For instance, the
VFS function pointers of the data structure of a ﬁle in
a ext3 ﬁlesystem, point to ext3 operations in the kernel
static region. In the same way, the fops data structure of
a ﬁle in an NTFS ﬁle system includes pointers to NTFS
operations. Using this property, we apply HAW-based
Veriﬁcation to detect this particular attack. The procedu-
ral ﬂow of the monitor is as follows: First, we trace the
exact location of the fops data structure using the DMA
module and Address Translation Engine. Next, we set
the function pointers as critical regions of the Monitor-
ingRule, and the location of the operation functions of
the known ﬁle systems – such as ext3, ext2, and NTFS –
as the whitelist. With these settings, VTMU notiﬁes the
onHawEvent function of the MonitoringRule, which will
subsequently provide notiﬁcation of this likely malicious

518  22nd USENIX Security Symposium 

USENIX Association

8

event.

LKM Hiding Attack: Many rootkits take advantage
of the Linux kernel’s support of LKM. Initially designed
to support extending of the kernel code during runtime
without modifying and recompiling the entire kernel,
LKMs often serve as a means to inject malicious code
into the highest privilege level in a system. Moreover,
adversaries often manipulate the linked list data structure
that maintains the list of loaded LKMs in order to con-
ceal malicious LKM loaded in the kernel. The following
code line frequently appears in rootkits that are injected
via LKMs:

list_del_init(&__this_module.list);

The kernel function list del init removes the given en-
try from the list in which it belongs. The developers of
rootkits insert the code into the module init function, so
that the malicious LKM will be removed from the linked
list upon its load. If the snapshot is not taken immedi-
ately, this attack cannot be detected because it removes
itself from the linked list as soon as it gets loaded.

LKM MonitoringRule: LKM MonitoringRule ex-
empliﬁes the Callback-based Semantic Veriﬁcation tem-
plate used in KI-Mon. By setting the next pointer of the
LKM linked list head as the critical region of the Mon-
itoringRule, KI-Mon gets notiﬁed of the insertion of a
new LKM as well as the address of the newly inserted
module structure. When a new LKM is inserted, the on-
HawEvent function of the MonitoringRule is triggered,
and it requests the DMA module to obtain a snapshot of
the new module’s code region and the hash accelerator to
hash the contents of the region.

The rest of the procedure to verify if the new LKM
is hidden from the list is as follows. First, the monitor
waits for 30 milliseconds. Note that the wait time before
this check is arbitrary. However, many rootkit LKMs in-
clude codes that hide the LKMs in the initialization func-
tion [39, 16, 27, 33]. Second, the linked list is traversed
with the Data Structure Acquisition Engine to check if
the inserted LKM is still in the list. Third, if the LKM
is not found in the list, we walk the page table using the
Address Translation Engine to verify that the virtual to
physical address mapping that correspond to the LKM’s
code region has been deleted. The Linux kernel frees the
memory regions of the LKM upon its removal. There-
fore, the absence of the page table mapping to the region
once occupied by the LKM indicates that the LKM was
normally removed. In case mapping does exist, the last
step of the procedure is executed. Recall that the monitor
took a hash of the LKM’s code region: we compare this
hash against the hash of the current contents of the phys-
ical memory. If the two hashes match, this indicates that
the LKM that was not found in the linked list iteration,
is not properly freed from the memory. In other words,

the inconsistency between the LKM linked list and the
memory contents reveals the LKM hiding attack.

A page table consistency check is used to avoid the
hash comparison of the memory contents, which requires
additional processing time and memory bandwidth. The
Linux kernel allocates the memory space for LKMs us-
ing vmalloc and de-allocates with vfree. The vmalloc
function allocates a physically non-contiguous region of
the requested size. That is, the allocated region is not
necessarily contiguous in the physical memory, but is
mapped to contiguous virtual addresses. Such non-linear
mapping in the page table is deleted as the region is freed,
using the vfree function. Therefore, the fact that the map-
ping is deleted in the page table assures that the LKM
object is freed in the memory.

Even when page table mapping exists, it does not nec-
essarily mean that a hidden LKM attack has occurred be-
cause the region that had been allocated for the LKM
was possibly freed already and reallocated for another
data object. Thus, a hash comparison of the region is
necessary to verify the contents of the region. The ker-
nel constantly allocates and de-allocates memory blocks
from the non-contiguous memory regions for vmalloc re-
quests. Therefore, it is likely that the freed region that
used to hold a data structure object will soon be allocated
for new one.

The consistency check is performed once, 30 millisec-
onds after the detection of a new LKM. This Monitor-
ingRule for the LKM hiding attack, is effective against
known LKM hiding technique, deployed in many real-
world rootkits. However, it is possible that rootkits evade
the single ﬁxed-timed check by delaying the execution
of LKM hiding using a timer. To cope with such eva-
sions, we can simply adjust the MonitoringRule to sched-
ule multiple random-interval checks for each occurrence
of an LKM loading. For instance, we let the time of ﬁrst
check in seconds t1 at the interval [0,5], the t2 at [5,20],
and so forth. By setting the lower bound of the random
interval of tn sufﬁciently long, we render the hiding at-
tack ineffective; the longer the attacker has to wait, the
effectiveness of the attack substantially diminishes.

4 Evaluation

In this section, we explain the experiments conducted to
prove the effectiveness of the event-triggered mechanism
employed in KI-Mon. The VFS MonitoringRule and
LKM MonitoringRule were implemented as explained
in the previous section. Both successfully detected the
example rootkit attacks. In this section, we discuss the
implications of the experiment with respect to evaluating
the design objectives O2.3: Minimal overhead on mon-
itored region and O2.4: Efﬁcient monitoring processor
usage, which are deﬁned in Section 2.

9

USENIX Association  

22nd USENIX Security Symposium  519

520  22nd USENIX Security Symposium 

USENIX Association

Inadditiontotheexperimentsthatwillbepresentedanddiscussedinthissection,weconductedanexperi-mentonVTMUwhitelistregisterreplacementschemeforlargewhitelists.Whilethereplacementschemeim-provesthescalabilityaspectofKI-Mon,itisrathersup-plementaltothemainexperiments.Thereforetheexper-imentisnotdiscussedinthissection,butincludedintheAppendixsection.Intheﬁrstexperiment,wemeasuredtheperformanceoverheads,inﬂictedonthemonitoredhostsystembyKI-Monandbyasnapshot-onlymonitorusingtheLKMMonitoringRuleexample.Usingthesameexample,KI-Mon’sefﬁciency,intermsoftheCPUusageofthemonitoringprocessor,ispresentedinthesecondexper-iment.Thethirdexperiment,whichisperformedusingtheLKMMonitoringRuleexample,comparesthedetec-tionrateofKI-Mon’sevent-triggeredmechanismwiththatofthesnapshot-onlymonitoragainstfrequentlyre-curringLKMhidingattacks.Onedesirablerequirementforanexternalkernelin-tegritymonitoristominimizetheperformanceoverheadimposedonthetargetsystem.Takingexhaustivemem-orysnapshotswouldincuramemorybuscontention,whichinturnwouldbeamajorcauseofperformancedegradationofthemonitoredsystem.KI-Monmini-mizestheperformancedegradationbyapplyingefﬁcientevent-triggeredmonitoringbasedontheVTMUhard-waremodule.Thesnapshot-onlyversionoftheVFSmonitorwasimplementedforthisexperiment.Inad-ditiontothemonitoringoftheinodedatastructureof/proc,themonitoralsoperformshashcheckingonthestaticregionsofthekernel.Thiscorrespondstothede-faultMonitoringRule,whichthwartsallmodiﬁcationstothestaticregions,inKI-Mon.Here,twobenchmarksareused,STREAMBENCH[25],andRAMSPEED[20]tomeasuretheimpactonthememorybandwidthperfor-manceofthemonitoredsystem.Thesetwoopen-sourcebenchmarktoolswereportedtoourplatformwithminormodiﬁcations:wereplacedtheﬂoating-pointtestswithintegertestsbecausetheprocessoronourcurrentproto-typedoesnotsupportﬂoating-pointinstructions.Inad-dition,wemodiﬁedthetotalsizeofthememoryusedforthebenchmarkbecausethemonitoredsystemonlyhas64MBofRAM.Figure7showstheaverageof10trialsofthemeasure-mentusingthetwobenchmarktools.Thesnapshot-onlymonitorinevitablyincursperformanceoverheadthatisdirectlyproportionaltothefrequencyofthesnapshottaking.Inordertomonitormoredynamicdatastruc-turesinthedynamicregionsofakernel,thefrequencyneedstobeincreasedaccordingly.Thisis,however,aninefﬁcientapproachtothemonitoringofthedynamicre-gions.KI-Monimplementsanevent-triggeredmonitor-ingmechanismthatovercomesthisinherentlimitationFigure7:PerformanceImpactofSnapshotsonMoni-toredSystem(Avg.of10trials):Theperformanceover-headcausedbysnapshot-onlymonitorincreasesasthesnapshotintervalshortens.Whenthesnapshotintervalfallsbelow1ms,thememorybandwidthofthemonitoredsystemdropsmorethan20%.ofthesnapshot-onlymonitorforanefﬁcientformofdy-namicregionmonitoring.ThedetectionofmodiﬁcationsinKI-Mondoesnotoperateonaperiodicbasis;VTMUﬁltersmemorymodiﬁcationeventsandtriggerthesoft-wareplatformonlywhenaneventrequiresfurtherveri-ﬁcaiton.4.1MonitorProcessor’sCPUUsageEfﬁcientusageoftheCPUandmemorybandwidthisanotherbeneﬁcialaspectforahardware-basedexternalmonitor,suchthatthemonitorcanbeimplementedevenwithlesspowerfulhardwarecomponents.WeinsertedcheckpointsinthesoftwarecomponentsofKI-Monandthesnapshot-onlymonitortoanalyzetheCPUusageofthetwomonitoringmechanisms.WeusedtheLKMhid-ingattackexampletoillustratethedifferenceinCPUus-agebetweenKI-Monandthesnapshot-onlymonitor.Figure8showstheexecutiontimelineofthetwomon-itoringschemes.Theclock()function,whichisfromthestandardLinuxlibrary,wasplacedatthebeginningandintheendofeachfunctionstorecordprocessortimes.Thesnapshot-onlymonitorrepeatsthesnapshot-basedpollingbeforeeventuallycapturingtheexistenceofanewlyinsertedLKM,whereasKI-MonstaysidleuntilaHAW-eventisreceivedfromVTMU.Thesnapshot-onlymonitorkeepstheexternalmonitor’sCPUactivewiththesnapshotpollinguntiltheoccurrenceofanevent.EachblockrepresentsfunctionsthatareexecutedbytheLKMMonitoringRuleupontheinsertionofanLKMbyKI-Monandthesnapshot-onlymonitor.Notethatthefunctionsexecutedafterthedetectionoftheeventsarethesameforbothmonitors.Eachsnapshotusedinthepollingtakes400microsecondsofCPUtimetoread16bytesoftheLKMlinkedlisthead.ThegetLKMHash()took5600microsecondsfor280bytestotakeasnapshot10of the code section of the LKM. The checkLKM() spent
2000 microseconds of CPU time to iterate the LKM
linked list of 6 entries to ﬁnd the newly inserted mod-
ule. Because it found that the newly inserted module is
missing in the list, it took another 1750 microseconds
of CPU time to look up the page table entry of the LKM
address. The compareHash() is ﬁnally executed and took
5600 microseconds to take a snapshot of the region that is
supposedly the code section of the hidden LKM to con-
ﬁrm that the LKM is indeed hidden. Thus, a total of
14950 microseconds of CPU time were used to verify the
event. KI-Mon only uses a total of 14950 microseconds
of CPU time for the example, whereas the snapshot-only
monitor uses additional CPU time for snapshot polling.
Although only a part of the snapshot polling is shown in
Figure 8, it should be noted that the polling is constantly
running to consume CPU time.

In addition, this particular trial represents a case in
which the snapshot-only monitor detects the LKM inser-
tion event; the snapshot-only monitor does not always
detect the event. Discussion of the detection rates will be
presented later in this section.

While Figure 8 shows the state of the CPU, Figure
9 compares CPU usage rates between the snapshot-only
monitor and KI-Mon. The CPU cycles consumed were
calculated from the processor times that we obtained for
8. Before the occurrence of the attack, the snapshot-only
monitor shows a steady usage over 106 cycles per sec-
ond while KI-Mon does not consume any CPU cycles.
At 18 seconds from the origin, an LKM hiding attack
was launched using the rootkit sample and both mon-
itoring mechanisms detected the modiﬁcation and exe-
cuted the veriﬁcation procedures, which consume CPU

Figure 8: CPU State during Operation of KI-Mon
and Snapshot-only Monitor: X-axis represents the time
elapsed in microseconds, and Y-axis represents the CPU
state as either busy or idle. The labels in each blocks are
the names of the functions being executed during that
time.

11

Figure 9: CPU Cycles Consumed in Operation of KI-
Mon and Snapshot-only monitor: X-axis represents the
time elapsed in seconds, and Y-axis represents the sum
of CPU cycles of the external monitor used in log-
scale. The vent at 18th second is the LKM hiding attack.
Snapshot-only monitor constantly consumes CPU cycles
whereas KI-Mon stays idle until an event is occurred.

cycles. The snapshot-only monitor consumes additional
CPU cycles to verify the event on top of the periodic
polling, whereas KI-Mon consumes only the required
number of cycles for veriﬁcation.

The fundamental difference in the monitoring mech-
anisms is shown in this experiment. For the snapshot-
only monitor to detect an event that occurs with a time
interval of t seconds with a snapshot-polling frequency
of f hz, a total number of snapshots n is calculated as
t ∗ f . The times of occurrences of modiﬁcation events
on the monitored data structures are often unpredictable.
For instance, connecting a new USB device to a Linux
machine might trigger the loading of a corresponding
driver LKM. Even for such unpredictable rare events,
however, the snapshot-only monitor has no choice but
to keep taking snapshots for possible events. Moreover,
the frequency of the snapshots may need to be increased
to keep up with frequently-changing objects, and this in-
creases the number of snapshots used for polling.

KI-Mon does not consume CPU cycles until an event
triggers its operation, whereas the snapshot-only moni-
tor continuously consumes a signiﬁcant number of CPU
cycles until an event is captured. KI-Mon overcomes the
inefﬁciency of the snapshot-only model with its event-
triggered mechanism. VTMU replaces the snapshot
polling with bus trafﬁc without consuming any CPU cy-
cles because it snoops the bus trafﬁc for modiﬁcation
events. Also, not all events need to be inspected in KI-
Mon’s mechanism since VTMU ﬁlters known legitimate
changes with HAW.

USENIX Association  

22nd USENIX Security Symposium  521

Table 2: Detection rate against 100 trials of recurring
LKM hiding attack

1khz Snapshot

KI-Mon

Max-frequency
Snapshot
(over 10khz)
70% detected

4% detected

100% detected

4.2 Detection Rate Against Recurring At-

tacks

The detection rates against frequent and recurring mod-
iﬁcations were measured using an LKM hiding attack.
As explained in the previous section, many real-world
rootkits [1] hide themselves from the LKM linked list
when they load. Therefore, the head of the linked list
changes for a short period of time, then reverts to the
original value. We tested the detection rate for 100 oc-
currences of such an attack with KI-Mon and with the
snapshot-only monitor using 1khz and 10khz, the maxi-
mum frequency.

Table 2 shows the results of this experiment. The
snapshot-only monitor only detected 4% of the attacks
with a frequency of 1khz, and 70%, with a maximum
frequency that is over 10khz. On the other hand, KI-Mon
detected all occurrences of attacks. As shown in this
experiment, the snapshot-only monitor cannot reliably
detect all modiﬁcations even with full-throttle snapshot
polling. However, KI-Mon maintains a continuous view
on mutable kernel object with its event-triggered mon-
itoring mechanism. That is, VTMU’s bus trafﬁc moni-
toring enables tracing of the history of the modiﬁcations
made to the monitored region. This indicates that KI-
Mon is capable of keeping a history of all modiﬁcations
of the monitored region.

There are cases in which the history of modiﬁcations
can be used for validation of integrity. This means that
the fact that value x was written to the region becomes
a trigger for the integrity veriﬁcation condition y. To be
more concrete with the LKM hiding example, KI-Mon
detects all LKM insertion events, and then performs an
integrity validation for each one of those events. On the
other hand, the snapshot-only monitor only detects 70%
of the LKM insertions, with 30% of the events were not
even given an attempt for veriﬁcation. The experiment
shows the inherent difference in the monitoring mecha-
nisms and proves why KI-Mon is more suitable for mon-
itoring of the dynamic regions of the kernel.

5 Related Work

KI-Mon is an external hardware-based platform that en-
ables event-triggered kernel integrity monitoring. Moni-
toring rules can be implemented using the KI-Mon API

In
to monitor mutable kernel objects with invariants.
order to discuss the novelty of our work, we introduce
previous works about hardware-based integrity monitor-
ing, monitoring of mutable kernel objects in general,
and event-triggered monitoring. We also brieﬂy discuss
works that adopt the concept of an independent auditor,
and VMM self-protection.

5.1 Hardware-based Kernel/VMM In-

tegrity Monitoring

Before VMM became a popular platform on which to
build kernel integrity monitors, several hardware-based
operating system kernel monitors were proposed. Zhang
et al. [43] was one of the ﬁrst to propose the concept
of integrity monitoring with a coprocessor. Petroni et
al. [29] presented Copilot, an external hardware-based
kernel integrity monitor based on memory snapshot in-
spection for static kernel regions.

When virtualization technology emerged, many
VMM-based approaches to kernel integrity monitoring
were also introduced. A majority of works in ker-
nel integrity monitoring were implemented on VMMs
due to the ease of development. However, the expan-
sion of VMMs in both code size and complexity, as
well as the attention of researchers and attackers, pro-
pelled the discovery of vulnerabilities in VMMs them-
selves [5, 4, 2, 3]. As a consequence, works that strived
to secure the integrity of VMMs with the assistance
of hardware support were presented to address the is-
sue [10, 40]. An alternative approach was to implement
minimalistic VMMs, so that static analysis could be ap-
plied to the minimized attack surface to mitigate vulner-
ability [37, 23, 36].

HyperSafe [41] took a different approach. This work
proposed a self-protection scheme to ensure the integrity
of the static region and control ﬂow of VMMs. Azab et
al. proposed HyperSentry [10], a VMM-integrity mon-
itor framework in which the root-of-trust is a hardware
component (Intel SMM). Recently, in line with Copi-
lot [29], Moon et al. presented Vigilare [26], which
introduces the concept of snoop-based monitoring for
static immutable regions of operating system kernels us-
ing SoC hardware.

5.2 Event-triggered Monitoring
Works that deploy event-triggered monitoring have been
presented, following the existing snapshot-based moni-
toring schemes. Payne et al. [28] presented Lares, which
provides a VMM-based platform to add hooks to the
monitored system for monitoring; however, their work
lacks monitoring schemes that use the proposed tech-
nique. KernelGuard [34] and OSck [19], mentioned

522  22nd USENIX Security Symposium 

USENIX Association

12

in previous section, used the event-triggered monitor-
ing scheme in their works. KernelGuard, by hooking
the VMM hypercall, achieved an event-triggered method
to map and monitor dynamic regions of the kernel. In
addition, OSck adopted both snapshot-based and event-
triggered schemes, and used event-triggered schemes to
monitor static regions of the kernel.

Even though previous works have dealt with the mon-
itoring of kernel dynamic regions with event-triggered
monitoring, they are all designed on VMM-based plat-
forms. On the other hand, KI-Mon implements an
event-triggered monitoring scheme as well as having
a hardware-based platform on which the monitoring
scheme operates. VMM-based event-triggered tech-
niques such as hypercalls or page fault handler hooking
are limited to VMM-based platforms.

Vigilare was the ﬁrst external hardware-based sys-
tem to introduce event-triggered monitoring with its bus
snooping [26]. However, its snooper module was only
capable of detecting the occurrence of write trafﬁc on
a ﬁxed immutable region. It could not extract a newly
updated value from a modiﬁcation event, nor could it
trigger any further veriﬁcation processing with the event.
Thus, Vigilare’s deﬁnition of an event is rather primitive
and was only sufﬁcient for monitoring a ﬁxed immutable
region in the kernel. In order to monitor mutable kernel
objects with invariants, KI-Mon reﬁnes event generation
from bus trafﬁc monitoring by extracting an address and
value pair for each event; its hardware-assisted whitelist-
ing scheme eliminates unnecessary event generation for
repeated benign updates. Also, its callback-based seman-
tic veriﬁcation scheme enables monitoring of mutable
kernel objects with semantic invariants.

5.3 Monitoring Dynamic Regions of Ker-

nel

Early works in integrity monitoring of operating system
kernels have focused on the integrity of static regions.
Since monitoring static regions is rather straightforward,
many kernel integrity monitors apply similar techniques
such as hash checking [29]. Unlike that for static re-
gions, monitoring of dynamic regions of kernels has in-
herent challenges. As studies have progressed in VMM-
based and hardware-based integrity monitoring, numer-
ous works on the monitoring of kernel dynamic regions
have been presented [6, 31, 34, 13, 30, 41, 15].

The contents of the dynamic regions of kernels can be
mainly put into two categories: control-ﬂow related data
and non-control-ﬂow related data. Monitoring the link-
ages of control-ﬂow related data, which is also known as
Control-Flow Integrity (CFI), was introduced by Abadi
et al. [6]. Petroni and Hicks [31] deﬁned State-Based
Control Flow Integrity (SBCFI) of Linux kernels. This

system is an approximation of CFI. They implemented
a monitor that checks the SBCFI of the Linux kernel
on a VMM-based platform. Rhee et al. proposed Ker-
nelGuard [34] to watch dynamic data of a Linux kernel
on a VMM-based platform. Carbone et al. proposed
KOP [15], which aimed to map dynamic kernel data
from a memory dump of the monitored system. More
recently, Hofmann et al. presented OSck [19], which
implemented existing monitoring schemes comprehen-
sively with the addition of self-created rootkit attacks and
detection mechanisms for monitoring kernel dynamic re-
gions on a VMM-based platform.

KI-Mon focuses on providing an event-triggered
mechanism as an architectural foundation for monitor-
ing mutable kernel objects with invariants. Although KI-
Mon’s main objective is not to monitor the dynamic re-
gions of a kernel as a whole, the architecture of KI-Mon
and its API leaves room for extensions that may cover
more mutable objects in the dynamic regions of the ker-
nel.

6 Limitations and Future Work

KI-Mon is a novel hardware-based platform of event-
triggered monitoring. Its concepts are shown through ex-
periments with a prototype. Nevertheless, development
of a new platform that incorporates both hardware and
software components is a rather formidable task. The
current prototype of KI-Mon is not at in its full maturity.
We describe the limitations of the current prototype in
this section.

The current prototype has a total of eight address reg-
isters for the snooper module. Depending on the required
monitoring coverage for KI-Mon, tens or even hundreds
of MonitoringRules might run concurrently, which in
turn may require a large number of address registers.
Design constraints such as hardware cost and chip area
would possibly limit the number of registers that can be
equipped. For this reason, we plan to explore the possi-
bility of improving the snooper module to utilize a dedi-
cated memory space in addition to the provided registers.
On the other hand, we can modify the host kernel’s mem-
ory allocation mechanism if the source code of the kernel
is provided. More speciﬁcally, the kernel can be modi-
ﬁed to allocate the monitored data structure of the same
types in a contiguous physical memory space so that less
number of registers are required for efﬁcient enforcement
of MonitoringRules.

We also consider a quantitative estimation of the re-
quirements for KI-Mon’s processing power as future
work. We used the same processor for the monitored
host and KI-Mon for the prototype. When the monitored
host operates at much faster clock speed compared to that
of our prototype, the processing power requirements for

USENIX Association  

22nd USENIX Security Symposium  523

13

KI-Mon needs to be investigated. While it is fairly un-
complicated to design a snooper module that operates at
the bus clock speed of the host, the processing power re-
quirements for KI-Mon depend on several other factors
such as the required number of MonitoringRules and the
computation complexity of each rule. The snooper mod-
ule is designed to drop incoming HAW-events when its
queue is full, hence the optimum combination of the size
of the queue and processor speed of KI-Mon needs to be
explored.

This paper focuses on illustrating the capability of the
KI-Mon platform to efﬁciently enforce kernel invariants
with a principle of event-triggered monitoring. Although
the generation of invariants on mutable kernel objects
was not discussed as it would exceed the scope of this
paper, automation of kernel invariant extraction is an-
other avenue in kernel integrity monitoring. Existing
works in the topic aim to infer and enforce invariants for
each data structure type used in the operating system ker-
nel [12, 30]. Developing or adapting such tools, as well
as creating an API extension that can automatically build
monitoring rules for KI-Mon based on extracted invari-
ants, will be essential improvements for KI-Mon in terms
of applicability.

We discharge a few classes of attacks that are beyond
the scope of this paper. Attacks only tampering with
processor registers or caches are not considered in this
work. Although it might be theoretically possible to de-
vise a rootkit that can reside only in registers and caches,
it would be practically impossible to leave no footprint
in the memory or in the system bus. Such hypothetical
rootkits are not within the scope of this paper. Bahram
et al. [11] explain that the existing virtual machine intro-
spection tools are vulnerable to DKSM attacks. Just like
these VMM-based introspection tools, KI-Mon is also
vulnerable to such types of attack that exploit the seman-
tic gap between the monitor and the monitored host sys-
tem. Difﬁculties with semantic gaps are an innate weak-
ness of external monitors. To overcome the issue, one
possible extension [11, 38] would be the planting of an
in-host agent that can interact with KI-Mon. However, it
is also notable that KI-Mon is resilient to TLB poisoning
attacks. This is because, unlike VMM-based monitors,
KI-Mon does not depend on the TLB cache.
Instead,
KI-Mon walks the host page tables to perform virtual to
physical address translation. The KI-Mon processor is
independent of the monitored host system, so it cannot
use the host processor’s TLB cache.

In addition, we assume that the caches on the host fol-
low a write-through policy, and that the update trafﬁc to
registers will always appear on the bus. Today’s proces-
sors have a more than 2 level memory hierarchy. The
level 2 or higher caches usually use a write-back policy to
replace their cache contents. Therefore, if memory traf-

ﬁc is monitored from outside these caches, much of the
memory access history would be lost. However, many
modern processors have a write-through policy for their
level 1 caches [21, 8]. In our hardware design, we con-
nect VTMU right below the L1 write-through cache so
that KI-Mon can monitor the whole memory access his-
tory of the host processor in a timely manner. This design
is viable for some architectures such as ARM Cortex,
which do not integrate an L2 cache inside the processor
core, but rather only include the L1 cache while provid-
ing an interface to the L2 cache that can be assembled
later into an SoC along with other hardware components
like VTMU.

7 Conclusion

In this paper, we have presented KI-Mon, an external
hardware-based monitoring platform that operates on
an event-triggered mechanism based on a VTMU hard-
ware unit. Unlike the existing external hardware-based
approaches, KI-Mon is an event-triggered veriﬁcation
mechanism, designed to monitor the integrity of dynamic
regions of kernels.

We built the KI-Mon prototype on an FPGA-based de-
velopment board and evaluated the possibility of mon-
itoring dynamic data structures using LKM attack and
VFS attack examples. KI-Mon is designed to operate
independently of the monitored host system; thus, its op-
eration remains unaffected even when the host is com-
promised by a rootkit. The hardware platform monitors
the host bus trafﬁc and generates events, assisted by its
whitelisting capability of ﬁltering benign updates, so that
the monitor will not be triggered by common benign up-
dates. This HAW-generated event triggers the software
platform to execute veriﬁcation routines. Also, the KI-
Mon API has been developed to support the programma-
bility of the monitoring rules that takes advantage of this
event-triggered veriﬁcation scheme.

Our experiments have showed that KI-Mon consumes
signiﬁcantly fewer CPU cycles due to its event-triggered
mechanism because it eliminates the need of constant
snapshot-based polling of the monitored region. We have
also showed that even at the maximum frequency, the
snapshot-only monitor missed 30% of LKM hiding at-
tacks, while KI-Mon was able to detect 100% of the at-
tacks. Overall, KI-Mon lays an architectural foundation
for an event-triggered kernel monitoring mechanism on
an external hardware-based monitor.

8 Acknowledgments

We would like to thank our shepherd Niels Provos
and the anonymous reviewers for
insightful com-

524  22nd USENIX Security Symposium 

USENIX Association

14

ments and suggestions. This research was supported
by MOTIE(The Minister of Trade, Industry and En-
ergy), Korea, under the BrainScoutingProgram(HB609-
12-3002) by the NIPA(National IT Promotion Agency).
This research is also based on work supported by
the Engineering Research Center of Excellence Pro-
gram of Korea Ministry of Science, ICT & Future Plan-
ning(MSIP) (NRF-2008-0062609), and the Center for
Integrated Smart Sensors funded by the Ministry of
Education, Science and Technology as Global Frontier
Project (CISS-20126054193).

References
[1] http://packetstormsecurity.com/UNIX/penetration/

rootkits. Last accessed Sep 4, 2012.

[2] Vmware: Vulnerability statistics. http://www.cvedetails.
com/vendor/252/Vmware.html. Last accessed April 4, 2012.
[3] Vulnerability report: Vmware esx server 3.x. http://secunia.
com/advisories/product/10757. Last accessed April 4,
2012.

[4] Vulnerability report: Xen 3.x.

http://secunia.com/

advisories/product/15863. Last accessed April 4, 2012.

[5] Xen: Security vulnerabilities. http://www.cvedetails.com/
Last

vulnerability-list/vendor_id-6276/XEN.html.
accessed April 4, 2012.

[6] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.
Control-ﬂow integrity. In Proceedings of the 12th ACM confer-
ence on Computer and communications security (New York, NY,
USA, 2005), CCS ’05, ACM, pp. 340–353.

[7] AEROFLEX GAISLE. GRLIB IP Core User’s Manual, January

2012.

[8] ARM. Cortex-A Series Programmers Guide, January 2011.
[9] ARM LIMITED. AMBATM Speciﬁcation, May 1999.
[10] AZAB, A. M., NING, P., WANG, Z., JIANG, X., ZHANG,
X., AND SKALSKY, N. C. Hypersentry: enabling stealthy in-
context measurement of hypervisor integrity. In Proceedings of
the 17th ACM conference on Computer and communications se-
curity (New York, NY, USA, 2010), CCS ’10, ACM, pp. 38–49.
[11] BAHRAM, S., JIANG, X., WANG, Z., GRACE, M., LI, J.,
SRINIVASAN, D., RHEE, J., AND XU, D. Dksm: Subverting
virtual machine introspection for fun and proﬁt. In Reliable Dis-
tributed Systems, 2010 29th IEEE Symposium on (31 2010-nov. 3
2010), pp. 82 –91.

[12] BALIGA, A., GANAPATHY, V., AND IFTODE, L. Automatic in-
ference and enforcement of kernel data structure invariants.
In
Proceedings of the 24th Annual Computer Security Applications
Conference (2008), ACSAC ’08.

[13] BALIGA, A., GANAPATHY, V., AND IFTODE, L. Detecting
kernel-level rootkits using data structure invariants. Dependable
and Secure Computing, IEEE Transactions on 8, 5 (sept.-oct.
2011), 670 –684.

[14] BOVET, D. P., AND CESATI, M. Understanding the Linux Ker-

nel, 2 ed. OReilly and Associates, Dec. 2002.

[15] CARBONE, M., CUI, W., LU, L., LEE, W., PEINADO, M., AND
JIANG, X. Mapping kernel objects to enable systematic integrity
checking. In Proceedings of the 16th ACM Conference on Com-
puter and Communications Security (2009), CCS ’09, ACM.

[16] CYBERWINDS.

knark-2.4.3.tgz.

http://

packetstormsecurity.com/files/24853/knark-2.
4.3.tgz.html. Last accessed Sep 4, 2012.

[17] DINABURG, A., ROYAL, P., SHARIF, M., AND LEE, W. Ether:
malware analysis via hardware virtualization extensions. In Pro-
ceedings of the 15th ACM conference on Computer and commu-
nications security (New York, NY, USA, 2008), CCS ’08, ACM,
pp. 51–62.

[18] HELLSTR ¨OM, D. SnapGear Linux for LEON. Gaisler Research,

November 2008.

[19] HOFMANN, O. S., DUNN, A. M., KIM, S., ROY, I., AND
WITCHEL, E. Ensuring operating system kernel integrity with
osck.
In Proceedings of the sixteenth international conference
on Architectural support for programming languages and oper-
ating systems (New York, NY, USA, 2011), ASPLOS ’11, ACM,
pp. 279–290.

[20] HOLLANDER, R. M. Ramspeed, a cache and memory bench-
marking tool. http://www.alasir.com/ramspeed/. Last ac-
cessed April 30, 2012.

[21] INTEL. Intel 64 and IA-32 Architectures Software Developers

Manual, Aug 2012.

[22] JUNGHWAN RHEE, D. X. Livedm: Temporal mapping of dy-
namic kernel memory for dynamic kernel malware analysis and
debugging. Tech. rep., 2 2010.

[23] KANEDA, K. Tiny virtual machine monitor. Http://www.yl.

is.s.u-tokyo.ac.jp/~kaneda/tvmm/.

[24] LOVE, R. Linux Kernel Development, 3 ed. Addison Wesley,

Nov. 2010.

[25] MCCALPIN, J. D. Memory bandwidth and machine balance in
IEEE Computer Society
current high performance computers.
Technical Committee on Computer Architecture (TCCA) Newslet-
ter (Dec. 1995), 19–25.

[26] MOON, H., LEE, H., LEE, J., KIM, K., PAEK, Y., AND KANG,
B. B. Vigilare:
toward snoop-based kernel integrity monitor.
In Proceedings of the 2012 ACM conference on Computer and
communications security (New York, NY, USA, 2012), CCS ’12,
ACM, pp. 28–37.

[27] OPTYX. Kis 0.9.

http://packetstormsecurity.com/
files/25029/kis-0.9.tar.gz.html. Last accessed Sep 4,
2012.

[28] PAYNE, B. D., CARBONE, M., SHARIF, M., AND LEE, W.
Lares: An architecture for secure active monitoring using virtual-
ization. In Proceedings of the 2008 IEEE Symposium on Security
and Privacy (Washington, DC, USA, 2008), SP ’08, IEEE Com-
puter Society, pp. 233–247.

[29] PETRONI, JR., N. L., FRASER, T., MOLINA, J., AND AR-
BAUGH, W. A. Copilot - a coprocessor-based kernel runtime
integrity monitor.
In Proceedings of the 13th conference on
USENIX Security Symposium - Volume 13 (Berkeley, CA, USA,
2004), SSYM’04, USENIX Association, pp. 13–13.

[30] PETRONI, JR., N. L., FRASER, T., WALTERS, A., AND AR-
BAUGH, W. A. An architecture for speciﬁcation-based detec-
tion of semantic integrity violations in kernel dynamic data. In
Proceedings of the 15th conference on USENIX Security Sympo-
sium - Volume 15 (Berkeley, CA, USA, 2006), USENIX-SS’06,
USENIX Association.

[31] PETRONI, JR., N. L., AND HICKS, M. Automated detection
of persistent kernel control-ﬂow attacks. In Proceedings of the
14th ACM conference on Computer and communications security
(New York, NY, USA, 2007), CCS ’07, ACM, pp. 103–115.

[32] RAFAL WOJTCZUK, JOANNA RUTKOWSKA, A. T.

Xen
http://invisiblethingslab.com/itl/

0wning trilogy.
Resources.html, 2008.

USENIX Association  

22nd USENIX Security Symposium  525

15

526  22nd USENIX Security Symposium 

USENIX Association

[33]RAISE.Enyelkmrookitmodiﬁedforubuntu8.04.http://packetstormsecurity.com/files/75184/Enye-LKM-Rookit-Modified-For-Ubuntu-8.04.html.LastaccessedSep4,2012.[34]RHEE,J.,RILEY,R.,XU,D.,ANDJIANG,X.Defeat-ingdynamicdatakernelrootkitattacksviavmm-basedguest-transparentmonitoring.InAvailability,ReliabilityandSecu-rity,2009.ARES’09.InternationalConferenceon(march2009),pp.74–81.[35]RHEE,J.,RILEY,R.,XU,D.,ANDJIANG,X.Kernelmalwareanalysiswithun-tamperedandtemporalviewsofdynamicker-nelmemory.InProceedingsofthe13thinternationalconferenceonRecentadvancesinintrusiondetection(Berlin,Heidelberg,2010),RAID’10,Springer-Verlag,pp.178–197.[36]RUSSELL,R.Lguest:Thesimplex86hypervisor.http://lguest.ozlabs.org/.LastaccessedApril31,2012.[37]SESHADRI,A.,LUK,M.,QU,N.,ANDPERRIG,A.Secvisor:atinyhypervisortoprovidelifetimekernelcodeintegrityforcom-modityoses.InProceedingsoftwenty-ﬁrstACMSIGOPSsym-posiumonOperatingsystemsprinciples(NewYork,NY,USA,2007),SOSP’07,ACM,pp.335–350.[38]SHARIF,M.I.,LEE,W.,CUI,W.,ANDLANZI,A.Securein-vmmonitoringusinghardwarevirtualization.InProceedingsofthe16thACMconferenceonComputerandcommunicationssecurity(NewYork,NY,USA,2009),CCS’09,ACM,pp.477–487.[39]TESO,S.adore-ng-0.41.tgz.http://packetstormsecurity.com/files/32843/adore-ng-0.41.tgz.html.Lastac-cessedSep4,2012.[40]WANG,J.,STAVROU,A.,ANDGHOSH,A.Hypercheck:Ahardware-assistedintegritymonitor.InRecentAdvancesinIn-trusionDetection,S.Jha,R.Sommer,andC.Kreibich,Eds.,vol.6307ofLectureNotesinComputerScience.SpringerBerlin/Heidelberg,2010,pp.158–177.10.1007/978-3-642-15512-3-9.[41]WANG,Z.,ANDJIANG,X.Hypersafe:Alightweightapproachtoprovidelifetimehypervisorcontrol-ﬂowintegrity.InProceed-ingsofthe31stIEEESymposiumonSecurityandPrivacy(2010).[42]WANG,Z.,JIANG,X.,CUI,W.,ANDWANG,X.Counteringpersistentkernelrootkitsthroughsystematichookdiscovery.InProceedingsofthe11thinternationalsymposiumonRecentAd-vancesinIntrusionDetection(Berlin,Heidelberg,2008),RAID’08,Springer-Verlag,pp.21–38.[43]ZHANG,X.,VANDOORN,L.,JAEGER,T.,PEREZ,R.,ANDSAILER,R.Securecoprocessor-basedintrusiondetection.InProceedingsofthe10thworkshoponACMSIGOPSEuropeanworkshop(NewYork,NY,USA,2002),EW10,ACM,pp.239–242.AAppendixA.1VTMUReplacementAlgorithmforLargeWhitelistsInordertoutilizeKI-Mon’smemoryspaceasanadditionalstorageforwhitelistvalues.WepreliminarilyimplementedanapproximationoftheLRUreplacementscheme,whichswapsbetweenthevaluesintheregistersandthoseinmemory.Thetagregistersissetwhenthevaluewrittentothemonitoredre-gionmatchesthevalueinawhitelistregister,alltagregistersareclearedwhenallthetagregistersareset.KI-Moncomparestheupdatevaluewiththewhitelistvaluesintheregistersaswellasthoseinthememory.Whenamatchhasoccurredwiththeoneinthememory,KI-Monswapsthematchedwhitelistvaluewithavalueinaregisterwhosetagvalueis0.Figure10:WhitelistLRUtestresults:X-axisofgraphindi-catesparameterh,lengthofhistorylocality,andthelegendin-dicatestheparameterr,therateoflocality.Y-axisofthegraphshowsthehitratio.Weevaluatedthereplacementschemewithanexperimentinwhichsynthesizedbustrafﬁcwasusedastheinput.Thechar-acteristicofthesynthesizedbustrafﬁcismodeledwithtwopa-rameters:lengthoflocalityhandrateoflocalityr.Weimple-mentedatrafﬁcgeneratorthatwritesavaluetothemonitoredtheregionofVTMU,sothatthetrafﬁcwilltriggertheopera-tionofthereplacementscheme.Thetrafﬁcgeneratorchoosesavalueoutofthe100whitelistvalues,whichconsistofhlocalvaluesand100−hnon-localvalues.Amongthesevalues,wechoosealocalnumberoutofthehlocalnumberwithaproba-bilityofr,andpresumablyanon-localnumberfromthe100−hnon-localpoolwithaprobabilityof1−r.Notethathigherrorlowerhwouldgenerateamorelocalmodelinthissetting.Figure10showstheresultsoftheexperiment.Weseethatfortrafﬁcpatternswithlesslocality,whichweregeneratedwithhigherhorlowerr,thehitratioislower.Thismeansthatourre-placeschemeislesseffectivelyutilizedforthisparticulartrafﬁcpattern.Forcaseswithhighlocality,however,thehitratioishigherthan50%andtopsoutat90%.Notethatthenumberofwhitelistregistersismuchsmallerthanthewhitelist,whichhas100entries.ThismeansthattheapproximatepreliminaryLRUschemehelpsKI-Mondealwithlargewhitelistsinsituationsinwhichwherethepatternofbenignupdatesonthemonitoredregionsarelocal.Foreverymiss,KI-Verineedstomanuallycheckifthemodiﬁcationislegitimateusingthewhitelistval-uesthatarestoredinKI-Mon’smainmemory.ThisproceduretakesaminimalnumberofCPUcycles;nevertheless,itcouldburdentheCPUincasesofburstytrafﬁc.Whilethesnapshot-onlymodelconsumesCPUcyclesforcomparinganymodiﬁedvaluewiththewhitelistvaluesforeverydetectionofmodiﬁ-cations,KI-Mononlyneedstoperformacomparisonwithaprobabilityof1−hitratio.16