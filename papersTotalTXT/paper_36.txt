Augmented Learning with Errors:

The Untapped Potential of the Error Term

Rachid El Bansarkhani, Özgür Dagdelen, and Johannes Buchmann

Technische Universität Darmstadt

Fachbereich Informatik

Kryptographie und Computeralgebra,

Hochschulstraße 10, 64289 Darmstadt, Germany

elbansarkhani@cdc.informatik.tu-darmstadt.de, oezguer.dagdelen@cased.de,

buchmann@cdc.informatik.tu-darmstadt.de

Abstract. The Learning with Errors (LWE) problem has gained a lot of
attention in recent years leading to a series of new cryptographic appli-
cations. Interestingly, cryptographic primitives based on LWE often do
not exploit the full potential of the error term beside of its importance
for security. To this end, we introduce a novel LWE-close assumption,
namely Augmented Learning with Errors (A-LWE), which allows one
to hide auxiliary data injected into the error term by a technique that
we call message embedding. In particular, it enables existing cryptosys-
tems to strongly increase the message throughput per ciphertext. We
show that A-LWE is for certain instantiations at least as hard as the
LWE problem. This inherently leads to new cryptographic constructions
providing high data load encryption and customized security properties
as required, for instance, in economic environments such as stock mar-
kets resp. for ﬁnancial transactions. The security of those constructions
basically stems from the hardness to solve the A-LWE problem.As an ap-
plication we introduce (among others) the ﬁrst lattice-based replayable
chosen-ciphertext secure encryption scheme from A-LWE.

Key words: lattice-based cryptography, encryption, computational as-
sumption

1

Introduction

Lattice-based cryptography constitutes arguably one of the most promising al-
ternatives to classical cryptography. This observation is supported by various
arguments such as the conjectured resistance against quantum attacks. More-
over, lattice-based cryptography is equipped with a rich combinatorial structure
providing provable-security guarantees [1–3], while carrying out low complex-
ity operations and thus allowing for eﬃcient constructions. The security of such
cryptosystems is mainly based on the hardness of either solving the Small Integer
Solution (SIS) problem or the Learning With Errors (LWE) problems. The for-
mer is widely employed for building provably secure primitives from Minicrypt,
such as collision-resistant hash functions [4, 5] and signature schemes [6–10],

while the latter mainly serves as a hard underlying problem for the security of
primitives from Cryptomania, such as key exchange [11–13] and oblivious trans-
fer [14]. Remarkably, both problems are strongly related as SIS is considered to
be the dual problem of LWE.

× Zm

q

, ei ←R χ and b(cid:62)

q

i ) ∈ Zn×m

q

i mod q for s ∈ Zn

q , where Ai ←R Zn×m

The LWE problem exists essentially in two variants, the decision and search
version. Following this, the challenger is given poly(n) number of independent
× Zm
samples (Ai, b(cid:62)
i =
s(cid:62)Ai + e(cid:62)
q where χ is some arbitrary distribution over Zm
q ,
typically discrete Gaussian. He is then asked to distinguish those samples from
uniformly random samples in Zn×m
q . In search-LWE, however, the chal-
lenger is required to ﬁnd the secret s. Besides its presumably quantum hardness,
one of the most noteworthy properties lattice-based assumptions oﬀer is worst-
case hardness of average-case instances. Starting with the works of Ajtai [1]
and Micciancio and Regev [3], the hardness of some average-case instances of
the SIS problem was shown to be hard as long as worst-case instances of the
(decision version of the) shortest vector problem, known as GapSVP, are hard.
The worst-case hardness for LWE was ﬁrst stated by Regev [15]. Regev showed
that if the error vector follows the discrete Gaussian distribution DZm,αq with
√
parameter αq ≥ 2
n, solving search-LWE is at least as hard as quantumly
solving ˜O(n/α)-SIVP and GapSVP in n-dimensional worst-case lattices. Later,
Peikert [16] and Brakerski et al. [17] gave a classical reduction from GapSVP to
LWE. In [18], Döttling and Müller-Quade proved the hardness of LWE for uni-
formly distributed errors. Subsequently, Micciancio and Peikert [19] show that
LWE remains hard even for binary errors.

Ever since the breakthrough work of Regev [15] lattice-based cryptography
emerged and novel encryption schemes have been built upon LWE such as fully
homomorphic encryption [20–24] and identity-based encryption [6,25–27] besides
of CPA-secure [14, 15, 28–30] and CCA-secure encryption schemes [7, 13, 16, 31].
Cryptographic constructions which rely on the LWE assumption usually sam-
ple an error term according to some distribution, most often Gaussian. Such a
choice has many advantages over other distributions. However, many of the ex-
isting LWE-based schemes do not exploit the full potential of the error term.
This observation is mainly due to three reasons, which can be summarized using
the example of encryption schemes.

1. Previous LWE-based encryption schemes produce ciphertexts mainly follow-
ing the idea of one-time pad encryption, where LWE samples play the role
of random vectors. As a consequence, the underlying constructions heavily
rely on the error term to be short in order to correctly recover the message.
A major drawback of such schemes is the waste of bandwidth, i.e., all bits
created for the error term are sacriﬁced for a few message bits.

2. There exist no proposals using the error term or other involved random vari-
ables as additional containers carrying auxiliary data, besides of its task to
provide the required distributions. Once recognizing its feasibility, it fun-
damentally changes the way of building cryptosystems. For instance, in en-

2

cryption schemes one may inject the message into the error term without
necessarily changing the target distributions.

3. There is a lack of eﬃcient trapdoor functions that recover the secret and the
error term from an LWE instance, which is obviously a necessary condition
for exploiting the error term. Only a few works such as [7,32] provide mech-
anisms to recover the error term. The most promising trapdoor construction
is proposed by Micciancio and Peikert [7].

We make the following conclusions. The above limitations of LWE intuitively
ask for an alternative LWE deﬁnition that takes account for the modiﬁcations
made to the error term, while ensuring essentially the same hardness results
as the traditional LWE problem. Since such an assumption already encompasses
message data within the error term, one obtains, as a consequence, a generic and
practically new encryption scheme secure under the new variant of the LWE
assumption, where the trapdoor function is viewed as a black box recovering
the secret and the error vector from a modiﬁed LWE instance. The message
is subsequently extracted from the error vector. This allows one to exploit the
full bandwidth of the error vector with full access to all its entries and not
just its length. Remarkably, one could even combine this approach with existing
methods for encryption in order to further increase the message throughput per
ciphertext. In this work we address this challenge and give a detailed description
of how to exploit the error vector.

Our Contribution. Based on these observations and subsequently made conclu-
sions, we start by giving an alternative LWE deﬁnition, called Augmented LWE
(A-LWE), that extends the existing one by modifying the error term in such a
way that it encapsulates additional information. We further show which instan-
tiations yield A-LWE samples that are indistinguishable from traditional LWE
samples, thereby enjoying the hardness of traditional LWE. In conjunction with
the high quality trapdoor candidate from [7], we have full access to the error
term. This result inherently yields new cryptographic applications, which ensure
security in various models while simultaneously allowing for high data load en-
cryption that are applicable, for instance, in ﬁnancial environments such as stock
markets operating with huge amounts of stock information. It is even possible to
encrypt lattice-based signatures much more eﬃciently than ordinary messages,
which is an interesting technique for Internet protocols, where the acknowledg-
ment of ip-packets represents an important measure for reliability. In this case,
the whole entropy of the error term is supplied by lattice-based signatures.

Conceptually, the strategy of injecting messages into the error term allows
us to derive a generic encryption scheme, where ciphertexts are represented by
plain A-LWE samples. Besides of its evident security properties, that can di-
rectly be deduced from A-LWE, our construction beneﬁts from encrypting more
message bits per ciphertext and a faster decryption engine through a conceptu-
ally easier instantiation as compared to other proposals. Furthermore, we give a
detailed description of how to achieve publicly-detectable replayable CCA (pd-
RCCA) security [33], a slightly relaxed version of CCA2, but strictly stronger

3

than CCA1. In fact, we propose the ﬁrst lattice-based RCCA-secure encryp-
tion scheme. Due to the versatility of the error term, this functionality does not
involve ciphertext expansion. As a third application, it is possible to replace
parts of the error term by signatures that are generated according to the best
known and widely used lattice-based signature schemes. Speciﬁcally, we focus
on the GPV signature scheme [6] in combination with the trapdoor construc-
tion [7] and the practical signature schemes presented in [8,10], and thus realize
an asymmetric authenticated encryption scheme. As a nice byproduct, one can
immediately transfer the proposed concepts to the CCA-secure construction pro-
vided in [7]. This allows us to increase the message throughput per ciphertext,
while enjoying RCCA-security at almost no costs. Noteworthy, all the proposed
concepts are also applicable to speciﬁc constructions such as the somewhat ho-
momorphic symmetric key encryption scheme due to [34], which does not rely
on the trapdoor construction from [7].

1.1 Augmented Learning with Errors

v (G),r. Vectors e ∈ Zm

In many lattice-based cryptographic schemes, one has to sample error terms
following the discrete Gaussian distribution as a requirement for the scheme
to be secure. This is often due to an LWE-based security reduction. The key
concept underlying our proposal is to embed further information in the error
term e ∈ Zm, but in such a way that the distribution of the augmented error
term is indistinguishable from the discrete Gaussian distribution over Zm. We
also show that one can embed messages in uniformly distributed error vectors
using the same methodology.
The idea of our technique is the following. We employ the gadget matrix
G = I ⊗ g(cid:62), ﬁrstly introduced in [7], with g(cid:62) = (1, 2, . . . , 2k−1) and modulus
q = 2k in order to sample vectors according to the discrete Gaussian distribution
DΛ⊥
v (G),r satisfy the equation
. Let H : {0, 1}∗ → {0, 1}m be some
Ge ≡ v mod q for arbitrary v ∈ Zm/k
function and (encode, decode) a pair of algorithms which allow one to switch
and {0, 1}m. We compute a random coset
between the representations Zm/k
v = encode(H(seed) ⊕ m) ∈ Zm/k, where m ∈ {0, 1}m denotes an arbitrary
message of bit length m. We show that if H is instantiated by a cryptographic
hash function modeled as a random oracle, v is indeed indistinguishable from
uniform. We only have to take care that the input to the function H, namely the
seed, has suﬃcient (computational) min-entropy. Whoever has access to this seed
can deterministically recover the message by m = decode(Ge mod q)⊕H(seed).
This result immediately impacts all schemes that allow for error term recovery,
as it enhances the compactness of the scheme.

q distributed according to DΛ⊥

Embedding auxiliary private information into the error term raises certain
new computational problems. In addition to the secret and error vector of an
LWE instance, also the new embedded message is concealed. In fact, we claim
that LWE samples modiﬁed as above are indistinguishable from uniform even for
adversarially chosen messages. To this end, we introduce a novel problem, namely

q

q

4

q

q of LWE into e = (e1, e2), where e1 ∈ Zm1

the Augmented LWE (A-LWE) problem, which diﬀers from the traditional LWE
problem only in the way the error term is produced. More speciﬁcally, we split
the error term e ∈ Zm
and e2 ∈
. An A-LWE sample is then distributed as follows. For a given s ∈ Zn
Zm2
q ,
ﬁrst choose A ←R Zn×m
uniformly at random. Then, sample e1 ←R DZm1 ,αq
q
v (G),αq, where v = encode(H(s, e1) ⊕ m) for some function
and e2 ←R DΛ⊥
H. The tuple (A, bt = s(cid:62)A + e(cid:62)) represents an A-LWE sample. We show
that distinguishing A-LWE samples from traditional LWE samples is hard for
properly chosen random function H. More formally, if H is a cryptographic hash
function modeled as a random oracle, the tuple (s, e1) has suﬃcient entropy in
each sample and the LWE problem for parameters m, n, α, q is hard to solve,
then we obtain a negligible computational distance between LWE and A-LWE
distributions. Thus, we immediately deduce the hardness of A-LWE from LWE.
As an immediate consequence, the conﬁdentiality of the message is protected as
long as decision A-LWE and hence decision LWE is hard.

q

Based on the A-LWE hardness, we present a novel and generic encryp-
tion scheme, where ciphertexts are embodied by plain A-LWE samples. One
merely employs an arbitrary suitable trapdoor construction for the function
gA(s, e) = s(cid:62)A + e(cid:62) that allows for error term recovery. Hence, the eﬃciency
of encryption and decryption greatly depends on the quality of the trapdoor
and the inversion algorithm. The currently most eﬃcient candidate function is
known from Micciancio and Peikert [7]. Note that while some encryption schemes
like [7, 32] utilize such a trapdoor function, the error term is left unpacked. To
the best of our knowledge, we provide the ﬁrst lattice-based encryption schemes
exploiting the error term as an (additional) data container in addition to its
necessity for security.

1.2 Applications

CCA-Secure Encryption. Based on the A-LWE hardness, we build a conceptually
new and very simple CCA1 secure encryption scheme. In previous lattice-based
encryption schemes such as [7, 26, 29, 31], ciphertexts are computed in a one-
time pad manner by adding the message to a random vector coming from the
LWE distribution. Thus, an adversary succeeds in the respective security game,
if she is able to distinguish LWE samples from random ones with non-negligible
advantage. Our scheme, however, moves apart from this approach and focuses
on the error term recovery of A-LWE samples and subsequently decoding the
error term. By this means, the ciphertext represents an A-LWE instance in
its purest form. This implies a direct security reduction of the scheme to A-
LWE. Employing the framework proposed in [7], we construct a random public
key A that is endowed with a trapdoor. In conjunction with the corresponding
inversion algorithm, we can eﬃciently recover the secret and the error term from
the ciphertext c(cid:62) = s(cid:62)A+e(cid:62) with e ←R DΛ⊥
v (G),αq for v = encode(H(s)⊕m).1
1 We show that if matrix A is ﬁxed and each secret s is uniformly sampled from Zn
q ,
the entropy of s suﬃces to sample the entire error term from DΛ⊥

v (G),αq.

5

√

Due to αq ≥ 2
q (G)), we even do not impose any further restrictions
to the parameters. Such a construction is almost optimal, since we do not initiate
any further transformations.

n ≥ η(Λ⊥

The bit size of the message is equal to the dimension of the ciphertext m
resulting in a small message expansion factor, which is lower than most of the
existing schemes. In fact, due to this relationship there is an incentive to increase
the parameter m in order to eﬃciently encrypt large amounts of data involving
less computations per ciphertext as compared to lower dimensions. We consid-
ered this case and can even show that decryption is essentially as fast as in lower
dimensions. In particular, we provide an enhanced encryption scheme for high
data load, where parts of the ciphertext and thus the error term are ignored
when inverting the underlying A-LWE instance. That is, one extends any public
key Au = [ ¯A | ¯AR − h(u)Gnk ] ∈ Zn×m with trapdoor [ R(cid:62) I ](cid:62) ∈ Znk×m to
u = [ A(cid:48) | ¯A | ¯AR − h(u)Gnk ] ∈ Zn×(m(cid:48)+m) with trapdoor [ 0 R(cid:62) I ](cid:62) ∈
Aext
Znk×(m(cid:48)+m). When inverting a ciphertext c = (c1, c2) ∈ Zm(cid:48)+m – that is, an
A-LWE instance – only the lower part of the ciphertext c2 is required to recover
s and e. This idea does not seem to carry over to the construction of [7]. In fact,
their message are ﬁxed to nk bits and extending the public key as above cannot
be applied to their scheme.

Nonetheless, we show that message injection into the error term can directly
enhance the CCA-secure scheme in [7] yielding a decrease of the message ex-
pansion factor. As a result, one obtains a scheme that follows the one-time-pad
approach while encapsulating further messages in the error vector. Put it dif-
ferently, with message embedding one could choose smaller parameters for the
scheme in [7] when encrypting the same message length. In terms of security the
original proof in [7] gets through without any major modiﬁcations. Table 1 gives
an overview of parameters and the corresponding sizes for various lattice-based
encryption schemes where we, for simplicity, ﬁx the ciphertext size. Note that
we have c ∈ Q≥2 for a matrix statistically close to uniform, and consequently
the message throughput in our scheme is at least twice as the one from [7]. The
ring setting, however, allows for smaller key sizes and more eﬃcient implemen-
tations. In Table 1 we mainly focus on the most eﬃcient ones including the
CPA-secure encryption scheme from [29]. Due to space reasons, Table 1 does
not include the less eﬃcient schemes from [16, 26, 31], which are characterized
by large public keys or small LWE error-rates beside of high message expansion
factors. For instance, in [31] the LWE error rate α = ˜O(1/n4) is quite small
(yielding to an easier LWE instance) with public keys of size ˜O(n2) bits. In [16],
Peikert improved the LWE error rate to α = ˜O(1/n) but with the cost of an
increased public key of size ˜O(n3). The CCA-secure encryption scheme [26] pro-
vides a trade-oﬀ of the previous proposals with an LWE error rate of ˜O(1/n2)
and public key size of ˜O(n2) bits.

Replayable Chosen-Ciphertext Secure Encryption. The notion of replayable CCA-
security, which constitutes a relaxed version of CCA2-security, was ﬁrstly intro-
duced by Canetti et al. [33] and addresses the ability of an adversary to replay ci-
phertexts that decrypt to the same message. An RCCA-secure encryption scheme

6

CCA1

CCA1
Constr. 4.1 Constr. 4.1 + [7]
m · k
c · nk
k
˜O(1/n)
n · m

m · k
(c + 1) · nk
k − k
˜O(1/n)
n · m

(c+1)

CPA
[29]
m · k
cnk − n
k + k
ck−1
˜O(1/n)
n · m

m = c · nk,
CCA1
[7]
k = log q
Ciphertext size m · k
Message size
nk
c · k
Message Exp.
Error rate α
˜O(1/n)
n · m
public key size

Table 1. Comparison of key ﬁgures among CCA1-secure encryption schemes

detects modiﬁcations carried out on the ciphertext that alter the message. Valid
encryptions of the same ciphertexts, however, are allowed. Canetti et al. have
shown that RCCA is suﬃcient for most practical applications. There exist a series
of RCCA-secure encryption schemes [35–39]. However, to our knowledge, we are
the ﬁrst realizing an RCCA-secure encryption scheme based on lattice problems,
and hence relying on the worst-case hardness of lattice problems. We show that
RCCA security comes essentially through our message embedding technique with
only minor modiﬁcations. Our construction resembles GPV signatures generated
for the public matrix G. Just as for standard GPV signatures, it is required to
hash all sensible (random) variables such as the tag u, the secret s and the lower
part of the error term e2 containing the message to v = H(u, s, e2) using a ran-
dom oracle H. Subsequently, we sample a preimage e1 ← DΛ⊥
v (G) that serves as
the upper-part of the error term. Due to the injectivity of the trapdoor function,
altering the ciphertext leads to diﬀerent values for the corresponding variables
such that the decryption routine outputs a failure. But modiﬁcations caused to
the upper part of the error term do not result in a failure as long as short vectors
from Λ⊥

q (G) are added.

This obviously implies a publicly-detectable RCCA-secure encryption scheme
(pd-RCCA), an even stronger security guarantee than plain RCCA. In fact, we
have the relation CCA2 ⇒ pd-RCCA ⇒ secretly-detectable RCCA ⇒ RCCA
[33]. Security in the pd-RCCA model implies that a public party can check
whether a modiﬁed ciphertext decrypts to the same message.

When it comes to CCA2 security, there exist many generic constructions
[40–43] that ensure CCA2-security. For instance, one can use strongly unforge-
able one-time signature schemes [40], commitment schemes or message authen-
tication codes (MAC) in order to transform a CPA-secure scheme into a CCA2-
secure one. However, these generic constructions typically involve high complex-
ity and overhead resulting in a less eﬃcient encryption scheme. Our approach
works diﬀerently as it uses the error term in order to provide this feature. Once
having RCCA-security one can eﬃciently convert the scheme into a CCA2-secure
encryption scheme using generic solutions as provided in [33] or our individual
approach at the expense of some small overhead.

Signature Embedding. There exist various approaches to provide message au-
thentication of encrypted data. Many of them are generic and thus coupled to
overhead and loss of eﬃciency. For instance, one can use MACs or digital sig-

7

natures that are appended to the ciphertext. In our work we aim at providing
this feature without suﬀering from the drawbacks of generic solutions through a
thorough analysis of our encryption scheme.

Our goal is to replace parts of the error vector such as e1 completely by a
lattice-based signature rather than appending it to the ciphertext or including it
as a part of the message. This allows us to optimally exploit the full bandwidth
of e1 due to some nice properties lattice-based signature schemes oﬀer. One of
the features is to let signatures be distributed following the discrete Gaussian
distribution. For the underlying signature scheme itself, such a strategy has
many advantages over other choices as it allows to decouple the distribution of
the signature from the secret key, while sampling short signatures with higher
probability. There exist many lattice-based proposals that have similar properties
and perform very well in practice [7, 8, 10].

Our construction inherently relies on the capability to recover the error term
from an A-LWE instance. As a result, we provide an authentication mechanism
for encrypted data, since it is by construction possible to retrieve back an arbi-
trary discrete Gaussian vector with support Zm, hence also a signature, that was
plugged into the error term. Therefore, we can embed signatures of size approx-
imately m · log(αq) = O(m log n) bits into the error vector, which is far more
(see Table 1) than with the standard encryption schemes that are restricted to
the message size. For instance, we can embed signatures of size c log(αq)nk bits
as compared to nk bits following [7]. Here, we denote by αq the parameter of
the discrete Gaussian vector of the error term. In fact, our proposal allows for a
ﬂexible selection of parameters, because we do not impose any new constraints.
However, the parameters of the signature scheme should not be too large in order
to correctly invert the underlying A-LWE instances.

Remarkably, when using the encryption scheme for high data load with an
the upper part of the error term is ignored when
extended public key Aext
decrypting the ciphertext. This allows us to select the parameters in such a
way that A-LWE (and LWE) is hard for arbitrarily chosen parameters of the
signature scheme. Therefore, one can employ the upper-part of the error term
for signatures. The resulting scheme has a CCA2-like behavior, where changes
induced to the ciphertext are detected by the receiver. These ideas immediately
help to improve the construction provided in [7]. In particular, we can apply the
proposed techniques to the error term without changing the other ingredients.
More speciﬁcally, we still build the ciphertext in a one-time pad manner, while
simultaneously endowing the error vector with additional messages. The proof
of security will subsequently be based on A-LWE rather than plain LWE.

u

Embedding Auxiliary Data in Homomorphic Encryption. As already noticed, we
improve the CCA1-secure encryption scheme from [7], if we apply the proposed
concepts from above to the error term. As a result, we have the ﬁrst message
being encrypted following the one-time pad approach and a second message
injected into the error-term. However, this encryption scheme heavily relies on
a trapdoor construction. But we stress that it is also possible to improve other
more speciﬁc constructions that do not require trapdoors as such. For instance,

8

if we consider the somewhat homomorphic encryption scheme due to Brakerski
and Vaikuntanathan [34], we can apply essentially the same ideas without any
major modiﬁcations. Indeed, it is a symmetric key encryption scheme, where
a ciphertext (c1 = a, c2 = b + m) is derived by adding a ring-LWE samples
b = as + te ∈ Rq = Z[X]/(cid:104)f (X)(cid:105) to an arbitrary message m ∈ Rt for t coprime
to q and freshly sampled c1 = a ∈ Rq and error vector e ∈ Rq. The secret key
is given by the secret ring element s ∈ Rq. After decrypting the ciphertext, we
get full access to the error-term via e = t−1(c2 − c1s − m). A quick view to
this construction reveals, that the error term can be recovered very eﬃciently.
Clearly, this positively impacts the performance of the diﬀerent concepts, when
applied to the error term.

Due to space limitations, we detail the application of our technique to obtain
a CCA-secure encryption scheme and refer the reader to our full version [44] for
the further aforementioned applications.

2 Preliminaries
By ⊕ we denote the XOR operator. We let [(cid:96)] denote the set {1, . . . , (cid:96)} for
any (cid:96) ∈ N≥1. We indicate vectors by lower-case bold letters (e.g., x) and use
upper-case bold letters for matrices (e.g., A).
A lattice is an additive subgroup of Rn. For a basis B = {b1, . . . , bn} ⊂ Rn
consisting of n linearly independent vectors, we deﬁne by Λ the n-dimensional
lattice generated by the basis B where Λ = L(B) = {B·c =
: c ∈ Zn} .
We deﬁne by ρ : Rn → (0, 1] the n-dimensional Gaussian function ρs,c(x) =
, ∀x, c ∈ Rn . The discrete Gaussian distribution DΛ+c,s is deﬁned to

−π· (cid:107)x−c(cid:107)2
e
have support Λ + c, where c ∈ R and Λ ⊂ Rn is a lattice.

n(cid:80)

bi·ci

i=0

s2

2

Below we deﬁne the LWE distribution. For our purposes, we only focus on
the error sampled by the discrete Gaussian distribution. One can easily deﬁne
LWE with respect to any error distribution.
Deﬁnition 1 (LWE Distribution). Let n, m, q be integers and χe = DZm,αq
be the discrete Gaussian distribution over Zm. For s ∈ Zn
q , deﬁne the LWE
× Zm
q obtained such that
distribution LLWE
one ﬁrst draws A ←R Zn×m
uniformly, e ←R DZm,αq and returns (A, b(cid:62)) ∈
Zn×m

n,m,αq to be the distribution over Zn×m

q with b(cid:62) = s(cid:62)A + e(cid:62).

× Zm

q

q

q

Deﬁnition 2 (Learning with Error (LWE)). Let (A, b) be a sample from
n,m,αq and c be uniformly sampled from Zm
q .
LLWE
The Decision Learning with Error (decision LWEn,m,αq) problem asks to distin-
guish between (A, b(cid:62)) and (A, c(cid:62)) for a uniformly sampled secret s ←R Zn
q .
The Search Learning with Error (search LWEn,m,αq) problem asks to output the
vector s ∈ Zn
q given LWE sample (A, b) for a uniformly sampled secret
s ←R Zn
q .

9

We say decision LWEn,m,αq (resp. search LWEn,m,αq) is hard if all polynomial time
algorithm solves decision LWEn,m,αq (resp. search LWEn,m,αq) only with negligi-
ble probability.
Various algorithms for diﬀerent tasks such as sampling from Λ⊥(G) or in-
verting LWE instances are presented in the full version [44]. In this paper we
use those algorithms in a block-box way and take them as given.

3 Learning with Errors Augmented with Auxiliary Data

In this section, we show how one can augment further useful information in the
error vectors of LWE samples without necessarily changing its distribution. We
call this technique ”message embedding” and formulate a modiﬁed LWE problem
deﬁnition, namely the Augmented LWE (A-LWE) problem, where this technique
is applied to LWE. We show that certain instantiations of the A-LWE problem
are as hard as the original LWE problem.

3.1 Message Embedding

We start explaining the core functionality of our work leading to conceptually
new cryptographic applications such as encryption schemes. In particular, we
show how to generate vectors that encapsulate an arbitrary message while simul-
taneously following the discrete Gaussian distribution DZm,r. This mechanism
can be exploited in cryptographic applications in order to embed further infor-
mation in discrete Gaussian vectors. For instance, we can apply this technique
to LWE-based encryption schemes (e.g., [7]), that enable the recovery of the
error term. As a result, we take advantage of an increased message throughput
per ciphertext. In the full version [44] we provide a description of how to embed
messages in error vectors that are uniformly distributed rather than from the
discrete Gaussian distribution.
Let the very simple operations encode : {0, 1}m → Zm/k
and decode :
q → {0, 1}m allow to bijectively switch between the bit and vector rep-
Zm/k
resentations. The embedding approach is realized by use of the gadget G =
I ⊗ g(cid:62). A ﬁrst idea of doing this is to sample a preimage x ←R DΛ⊥
with v = encode(m) for an arbitrary message m ∈ {0, 1}m such that Gx
mod q = encode(m) holds. Sampling from DΛ⊥
v (G),r is performed very eﬃciently
(see [44]) and can be reduced to samples from D2Z,r and D2Z+1,r. However, since
the target Gaussian distribution of many cryptographic schemes, such as the
LWE encryption schemes, require to have support Zm, we modify the message
to m ⊕ r prior to invoking the preimage sampler for a randomly chosen vector
r ←R {0, 1}m. Below in Lemma 1 we show that given this setup we indeed ob-
tain a sample x that is distributed just as DZm,r with overwhelming probability.
To illustrate this approach exemplarily, let e ∈ Zm denote the error term with
m ∈ O(nk). We then split the error term e = (e1, e2) ∈ Zm1+m2 into two subvec-
tors, each serving for a diﬀerent purpose. The second part e2 is used for message
embedding, whereas e1 provides enough entropy in order to sample a random

v (G),r

q

10

vector r. To this end, one has to ﬁnd a proper trade-oﬀ for the choice of m1
and m2, since a too large value for m2 implies low entropy of e1. A reasonable
small lower bound is given by m1 ≥ n, since the discrete Gaussian vector e1 has
min-entropy of at least n − 1 bits as per [6, Lemma 2.10].
The message embedding functionality comes at almost no costs. Let k be a
factor of m2. One samples e1 ← DZm1 ,r and a preimage e2 ←R DΛ⊥
v (G),r for
the syndrome v = encode(m ⊕ H(e1)) for some random function H : {0, 1}∗ →
{0, 1}m2 . Following this approach, the message is recovered by computing m =
H(e1)⊕decode(Gm2 e2 mod q) where Gm2 = Im2/k⊗g(cid:62). In many cryptographic
applications there are diﬀerent random sources available, which can replace the
role of e1 such that e is completely used for message embedding.
In the following theorems we prove that it is possible to simulate the discrete
Gaussian distribution DZm,r (statistically or computationally) by use of a preim-
age sampler for any full-rank matrix A. This allows for embedding messages in
the error vectors of LWE without changing noticeably the LWE distribution.
The proofs of the following lemmata and the case of uniformly distributed error
vectors is presented in the full version [44].
Lemma 1 (statistical). Let A ∈ Zn×m
an arbitrary full-rank matrix. The statistical distance ∆(DZm,r,DΛ⊥
uniform v ←R Zl
Lemma 2 (computational). Let A ∈ Zn×m
be an arbitrary full-rank matrix. If the distribution of v ∈ Zl
ally indistinguishable from the uniform distribution over Zl
computationally indistinguishable from DZm,r for r ≥ η(Λ⊥(A)).

, k = (cid:100)log q(cid:101) ≥ 1 with m = l · k
q is computation-
q, then DΛ⊥
v (A),r is

, k = (cid:100)log q(cid:101) ≥ 1 with m = l · k be
v (A),r) for

q with r ≥ η(Λ⊥(A)) and  = negl(λ) is negligible.

q

q

3.2 Augmented LWE

Based on the message embedding approach as described above, we introduce an
alternative LWE deﬁnition that extends the previous one in such a way that the
error term is featured with additional information. We show how the modiﬁed
error still coincides with DZm,r in order to allow a reduction from LWE to our
new assumption. We make use of the gadget matrix G = I ⊗ g(cid:62) for g(cid:62) =
(1, . . . , 2k−1). For simplicity, assume q = 2k. For general q, the preimage sampling
algorithm for Λ⊥(G) is more involved (see [7]).

Deﬁnition 3 (Augmented LWE Distribution). Let n, m, m1, m2, k, q be in-
tegers with k = log q and m = m1 + m2, where k | m2. Let H : Zn
q →
{0, 1}m2 be a function. Let Gm2 = Im2/k ⊗ g(cid:62) ∈ Zm2/k×m2
q , deﬁne
n,m1,m2,αq(m) with m ∈ {0, 1}m2 to be the distribution
the A-LWE distribution LA-LWE
over Zn×m
– Sample A ←R Zn×m
– Set v = encode(H(s, e1) ⊕ m) ∈ Zm2/k

and e1 ←R DZm1 ,αq .

q obtained as follows:

. For s ∈ Zn

q × Zm1

× Zm

q

q

q

q

.

11

– Sample e2 ←R DΛ⊥
– Return (A, b(cid:62)) where b(cid:62) = s(cid:62)A + e(cid:62) with e = (e1, e2) .

v (G),αq .

Accordingly, we deﬁne the augmented LWE problem(s) as follows. As opposed
to the traditional LWE, augmented LWE blinds, in addition to the secret vector
s ∈ Zn
q , also some (auxiliary) data m ∈ {0, 1}m2. Thus, we have an additional
assumption that the message m is hard to ﬁnd given A-LWE samples. Note that
the decision version requires that any polynomial bounded number of samples
(A, b(cid:62)) from the A-LWE distribution are indistinguishable from uniform random
samples in Zn×m
q . Its hardness implies that no information about s and m
is leaked through A-LWE samples. In some scenarios, e.g., in security notions of
an encryption scheme, the adversary may even choose the message m. Hence,
we require in the corresponding problems that their hardness holds with respect
to A-LWE distributions with adversarially chosen message(s) m except for the
search problem of m.

× Zm

q

Deﬁnition 4 (Augmented Learning with Errors (A-LWE)).
Let n, m1, m2, k, q be integers with k = log q. Let H be some function.

The Decision Augmented Learning with Errors (decision A-LWEH

n,m1,m2,αq) prob-
lem asks upon input m ∈ {0, 1}m2 to distinguish in polynomial time (in n)
between samples (Ai, b(cid:62)
n,m1,m2,αq(m) and uniform random samples
from Zn×m

i ) ←R LA-LWE
q for a secret s ←R Zn
q .

× Zn

The Search-Secret Augmented Learning with Errors (search-s A-LWEH

q given polynomially many samples (Ai, bi) ←R LA-LWE

n,m1,m2,αq)
to output in polynomial time (in n) the
n,m1,m2,αq(m)

q

problem asks upon input m ∈ Zm2/k
vector s ∈ Zn
for secret s ←R Zn
q .

q

The Search-Message Augmented Learning with Errors (search-m A-LWEH

n,m1,m2,αq)
problem asks to output in polynomial time (in n) the vector m given poly-
q and m ←R
nomially many A-LWE samples (Ai, bi) for a secret s ←R Zn
{0, 1}m2.

We say that decision/search-s/search-m A LWEH
time algorithms solve the decision/search-s/search-m A LWEH
only with negligible probability.

n,m1,m2,αq is hard if all polynomial
n,m1,m2,αq problem

Throughout the paper, the function H will be a cryptographic hash function
modeled as a random oracle. For this reason we simplify the notation and denote
by decision/search-s/search-m A LWEn,m1,m2,αq the A-LWE problems where H is
speciﬁed to be a random oracle in the A-LWE distribution.

In the following, we show that if the function H is instantiated by a random
oracle, the hardness of LWE is reducible to the hardness of A-LWE. To this end,
we show that the LWE and A-LWE distribution are computationally indistin-
guishable, if we assume that the former search problem is hard and the inputs
to function H have suﬃcient entropy in each sample given previous samples.

12

Theorem 1. Let λ be the security parameter. Let n, m, m1, m2, k, q be integers
where k = (cid:100)log q(cid:101), m = m1+m2. Let H : Zn
q → {0, 1}m2 be a hash function
modeled as a random oracle. Let αq ≥ η(Λ⊥
q (G)) for a real  = negl(λ) > 0.
Furthermore, denote by χs and χe1 the distributions of the random vectors s and
e1 involved in each A-LWE sample. If search LWEn,m,αq is hard and H∞(s, e1) >
λ, then LA-LWE
n,m,αq for
arbitrary m ∈ {0, 1}m2.
n,m,α,q are indistinguishable from
Proof. We need to show that samples from LLWE
LA-LWE
n,m1,m2,α,q(m) if we assume that the search LWEn,m,α,q problem is hard to
solve in polynomial time and tuples (s, (e1)i) for each sample i have suﬃcient
entropy . That is, LLWE

n,m1,m2,αq(m) is computationally indistinguishable from LLWE

n,m1,m2,α,q(m) for arbitrary m ∈ {0, 1}m2.

n,m,α,q ≈c LA-LWE

q ×Zm1

We consider a series of intermediate hybrid experiments. In the ﬁrst hybrid,
we modify the A-LWE samples in such a way that we replace H(s, e1) with
a uniformly sampled value u. Here, we use the fact, that H∞(s, e1) > λ and
the same input will be queried with negligible probability. Consequently, v =
encode(H(s, e1) ⊕ m) becomes uniformly distributed. The next hybrid replaces
2 which is sampled according to DZm2 ,r. The ﬁnal distribution is
e2 by value e∗
identically distributed as the original LWE. In the following we describe the
hybrids more formally.
Hybrid1. In the ﬁrst hybrid, in each A-LWE sample we replace the value
H(s, e1) by a uniformly sampled value u ∈ {0, 1}m2. We argue that a
(polynomial-time) distinguisher notices the diﬀerence only if it queries the
random oracle on input (s, e1). Otherwise, if (s, e1) has not been queried
before, the distribution of H(s, e1) is statistically close to the uniform dis-
tribution in {0, 1}m2 due to the property of a random oracle drawing el-
ements from the output range uniformly at random. Moreover, we have
H∞(s, e1) > λ such that the same input element (s, e1) will not be sam-
pled again except with negligible probability. This holds, in particular, if
many samples are given to the distinguisher and all H(s, (e1)i) have been
replaced because by assumption we have suﬃcient entropy such that all pairs
(s, (e1)i) are distinct with overwhelming probability.
We comment on a distinguisher which queries the random oracle at a cer-
tain point on (s, e1) below in the proof, and assume for now, that no such
distinguisher exists.
Hybrid2. In the next hybrid, we replace the error term e2 by value e∗2 which
is sampled according to DZm2 ,r. Note that A-LWE samples from Hybrid1
satisfy that v = encode(u⊕ m) is uniformly distributed since u is uniformly
picked (even if m is chosen by the distinguisher). Now, Lemma 1 implies that
DΛ⊥
v (A),r is statistically indistinguishable from DZm2 ,r for r ≥ η(Λ⊥(A)),
if H has not been queried on input (s, e1) before. For this reason, replacing
e2, which is distributed according to DΛ⊥
2 is unnoticeable
to a distinguisher.

v (A),r, by vector e∗

We argue that A-LWE samples from Hybrid2 are indistinguishable from LWE
samples. This follows from the fact that the error term in A-LWE is now identi-

13

Adversary ALW E is given samples from LLWE

cally distributed as LWE which is the only diﬀerence between A-LWE and LWE
samples. We still need to argue that it is very unlikely that a distinguisher queries
the random oracle H on input (s, e1) for some e1 used in an A-LWE sample.
Suppose that there exists an algorithm A which distinguishes in polynomial
time original A-LWE samples from A-LWE samples from Hybrid1 with non-
negligible probability. We then construct an adversary ALW E with black-box
access to algorithm A that solves the search LWEn,m,α,q problem in polynomial
time with non-negligible probability. This contradicts the theorem assumption
that search LWEn,m,α,q is hard.
n,m,α,q and is asked to ﬁnd the
secret vector s. Let us denote by q∗ the query (s, e1) on H made by A, where
q∗ is polynomially bounded by the security parameter. Whenever algorithm A
asks for new samples, ALW E asks for samples in her challenge and forwards
them to A. That is, A obtains samples from LLWE
n,m,α,q instead of either version
of LA-LWE
n,m1,m2,α,q(m) is
n,m,α,q, if (s, e1) was not sent to oracle H. This means
indistinguishable from LLWE
that before A makes query q∗ to H, those samples are indistinguishable. As a
result, A must query H on input (s, e1) even if given LWE samples. We stress
that after returning the hash value of (s, e1) to A it may be noticing that ALW E
has tricked her. However, eavesdropping the input to oracle H suﬃces to ALW E
to break her search LWEn,m,α,q problem independently whether A aborts at this
time. Hence, if A queries H on input (s, e1) with non-negligible probability, so
does ALW E solve the search LWEn,m,α,q problem with the very same probability.
By assumption there does not exist such a successful algorithm.

n,m1,m2,α,q(m). We have already shown via hybrids that LA-LWE

We conclude that the step from the original A-LWE samples to Hybrid1 will
be unnoticeable to a distinguisher if search LWEn,m,α,q is hard, and both distri-
butions LLWE
(cid:117)(cid:116)

n,m1,m2,α,q(m) are computationally indistinguishable.

n,m,α,q and LA-LWE

Note that if the ﬁrst error part e1 has entropy exceeding the security pa-
rameter λ, the (computational) entropy induced by s is not required. This is
important, since a distinguisher could ask for many A-LWE samples using the
same secret s as input to the hash function. However, as typical in encryption
schemes (e.g., in [7, 16, 28, 29] and in ours), if we ﬁx a random matrix A and
sample fresh secret vectors s ← Zn
q uniformly at random for each A-LWE sam-
ple, we can indeed choose m1 to be zero. This corresponds to the case, where an
A-LWE sample is drawn once for every fresh secret s resulting in essentially un-
related A-LWE instances. Hence, the secret s provides the suﬃcient randomness
required as input to H.

Theorem 1 immediately entails the following statement.

Theorem 2. Let n, m, m1, m2, k, q be integers with k = log q and m = m1 +m2.
Let H be a random oracle as deﬁned in Theorem 1. Let αq ≥ η(Λ⊥
q (G)) for a
real  = negl(λ) > 0. Furthermore, denote by χs and χe1 the distributions of
the random vectors s and e1 involved in each A-LWE sample. If H∞(s, e1) > λ,
then the following statements hold.

14

– If search LWEn,m,αq is hard, then search-s A-LWEn,m1,m2,αq is hard.
– If decision LWEn,m,αq is hard, then decision A-LWEn,m1,m2,αq resp.

search-m A-LWEn,m1,m2,αq is hard.

Proof. As per Theorem 1, LA-LWE
n,m1,m2,αq(m) is computationally indistinguishable
from LLWE
n,m,αq. This proves the hardness of decision A-LWEn,m1,m2,αq and
search-m A-LWEn,m1,m2,αq. And by essentially the same arguments we also de-
duce the hardness of search-s A-LWEn,m1,m2,αq, because solving the search prob-
lem implies distinguishability of A-LWE instances from uniform due to the
knowledge of (s, e) and by Theorem 1 we obtain distinguishability of LWE in-
(cid:117)(cid:116)
stances from uniform, hence a contradiction.

3.3 Generic Encryption Scheme from A-LWE

In what follows we provide a generic construction of an A-LWE based encryption
scheme. Due to our new feature of embedding messages in the error term, we can
employ any trapdoor function that allows for error-term recovery. We restrict to
the case, where function H inputs only s (i.e., m1 = 0) as discussed above. Let
TDF = (KeyGen, g, g−1) be a trapdoor function with gA(x, y) := x(cid:62)A + y(cid:62) ∈
Zm. The algorithm KeyGen outputs a matrix A ∈ Zn×m
, that is close to uniform,
with an associated trapdoor T used to invert gA. The trapdoor function satisﬁes
A (T, c) = (x, y) with c = gA(x, y) for arbitrary x ∈ Zn
g−1
q and properly chosen
y ∈ Zm.
Our generic encryption scheme from A-LWE is constructed as follows:
KGen(1n): Generate public key pk := A ∈ Zn×m
Enc(pk, m ∈ {0, 1}l with 0 ≤ l ≤ m): Sample s ←R Zn

(A, T) ← TDF.KeyGen(1n).

with trapdoor sk := T where

q

q

encode(H(s) ⊕ m) ∈ Zm/k
q
is given by c = gA(s, e).
Dec(sk, c) : Compute g−1

. Then, sample e ←R DΛ⊥

q and compute v =
v (G),αq. The ciphertext
A (T, c) = (s, e). Return m = decode(Ge mod q) ⊕

H(s).

The generic construction is mainly based on the capability of the scheme to
recover the error vector. Thus, the underlying trapdoor construction acts as
a black box granting full access to the secret s and the error term e, when
applying the secret trapdoor on a corresponding A-LWE instance. Once having
revealed the error term, the message is recovered via the last step of the scheme
involving the simple matrix G and the function H(·). Improving the quality
of the trapdoor and its inversion algorithm directly impacts the eﬃciency of
the encryption scheme, since decoding of the message from e is performed very
eﬃciently.

Theorem 3. The generic encryption scheme above is secure assuming the hard-
ness of decision A-LWEn,0,m,αq for αq ≥ 2
η(Λ⊥

√

q (G)) .

n ≥ 2 ·(cid:112)ln(2n(1 + 1/))/π ≥

15

Proof. Ciphertexts generated according to the generic encryption scheme from
above correspond to plain A-LWE samples with m1 = 0. By assumption
decision A-LWEn,0,m,αq is hard, and consequently, an adversary is not able to
distinguish a challenge ciphertext from uniformly chosen samples.

One can apply Theorem 1 and Theorem 2 to have a direct reduction from
(cid:117)(cid:116)

traditional LWE.

Remark. We like to note that one could increase the message throughput of our
encryption scheme even further by embedding the message not only into the error
term but also into (part of) the secret s. This allows for an additional message
of size approximately n(k − 1) bits. This is possible since each encryption query
involves a fresh secret vector s. One has to make sure that the hash function H
is invoked on a value with suﬃcient entropy (e.g. the ﬁrst n bits are random).

4 New Chosen-Ciphertext Secure Encryption Schemes

Due to the new functionality of embedding messages in error vectors, we are able
to propose a novel encryption scheme providing full CCA security when adopting
the tagging approach presented in [45, 46]. In fact, we get this feature for free,
if we instantiate our generic construction from Section 3.3 with the trapdoor
provided in [7]. More speciﬁcally, the authors add a tag u to the matrix A such
that the modiﬁed matrix Au keeps changing for every encryption query.

Originally, in almost all previous encryption schemes ciphertexts are build
in a one-time pad manner by adding the message to a random-looking vector
coming from an LWE instance. By our modiﬁcations, we omit the way of encod-
ing messages and the restrictions made to the parameters. Our aim is to let the
ciphertexts resemble an ordinary A-LWE instance such that the hardness of the
scheme can be directly reduced to the plain A-LWE problem. Indeed, the error
term hides the message while following the required distribution. This allows for
more ﬂexibility, eﬃciency and larger messages per ciphertext at no costs. Even
more, this greatly simpliﬁes the security proof. As we show later, we can even
lift up the security to publicly-detectable RCCA (pd-RCCA) with a simple trick
ensuring non-malleability of ciphertexts. When applying these functionalities to
the error term in the CCA1-secure scheme due to [7], the message throughput is
at least twice as large while simultaneously providing pd-RCCA security instead
of CCA1, as before. In addition to that, we give an intuition of how to get a
CCA2-secure encryption scheme involving only minor modiﬁcations.

In this paper, we assume the reader is familiar with the various security
models for encryption schemes. We refer to the full version [44] for a description
of the CCA1, CCA2, and RCCA models.

4.1 CCA1-Secure Encryption Scheme

We start with a detailed description of the CCA1 secure encryption scheme
q → {0, 1}m be some function. Let
and the involved algorithms. Let H : Zn

16

q

R = Zq[x]/(f (x)) be a ring as constructed in [7], where f (x) denotes a monic
irreducible polynomial of degree n. Furthermore, let h : R → Zn×n
be an in-
jective ring homomorphism mapping elements a ∈ R to the matrix h(a). By
U = {u1, . . . , u(cid:96)} we denote a large set with “unit diﬀerences” property. That is,
for any two ring elements ai and aj ∈ R∗ with i (cid:54)= j we have ai − aj ∈ R∗ and
h(ai − aj) = h(ai)− h(aj) is invertible. By Gm we denote the matrix Im/k ⊗ g(cid:62) .
Our encryption scheme works as follows.
KGen(1n): Let k = log q and m, ¯m > 0 with k | m and m = ¯m + nk. Invoking
TDF.KeyGen(1n) outputs keys (A, R), where A = [ ¯A | ¯AR ] for randomly
selected matrix ¯A ∈ Zn× ¯m
and R ←R D is sampled from a desired dis-
tribution D, typically the discrete Gaussian distribution. For instance, one
chooses ¯m = nk and D = D ¯m×nk
log n). The public and secret
key are given by pk = A ∈ Zn×m
Enc(pk, m ∈ {0, 1}l with 0 < l < m): Select a nonzero u ∈ U. Set Au =
[ ¯A | ¯AR − h(u)Gnk ] with Gnk = In ⊗ g(cid:62). Then, select s ←R Zn
q and
√
n ≥
and αq ≥ 2
e ←R DΛ⊥

2 ·(cid:112)ln(2n(1 + 1/))/π. Output the ciphertext

v (Gm),αq where v = encode(H(s) ⊕ m) ∈ Zm/k

for t ∈ ω(
and sk = R ∈ Z ¯m×nk

√

Z,t

.

q

q

q

q

c = (u, b) ∈ U × Zm

q with b(cid:62) = gAu (s, e) = s(cid:62)Au + e(cid:62) mod q .

Dec(sk, c) : Determine Au = [ ¯A | ¯AR − h(u)Gnk ].

1. If parsing c causes an error or u = 0, output ⊥. Otherwise invoke the
LWE inversion algorithm as provided in [7, 44] with input parameters
(R, Au, b), which outputs a failure ⊥ or g−1
m. If it is satisﬁed, compute r = H(s(cid:48)) and m =
r ⊕ decode(Gme(cid:48) mod q).
3. Output m as the message.

2. Check (cid:107)e(cid:48)(cid:107) ≤ αq

(b(cid:62)) = (s(cid:48), e(cid:48)).

√

Au

q (G)).

n ≥ η(Λ⊥

√
Theorem 4. The encryption scheme above is CCA1-secure assuming the hard-
ness of decision A-LWEn,0,m,αq for αq ≥ 2
Proof. The proof is greatly simpliﬁed as compared to [7], since we are not re-
quired to perform any transformations to the initial A-LWE samples. In fact, we
draw samples (A, b(cid:62)) ←R LA-LWE
n,0,m,α,q(m) from the A-LWE distribution, where
b(cid:62) = s(cid:62)A + e(cid:62), s ←R Zn
q , A ←R Zn×m
v (G),αq
with v = encode(H(s) ⊕ m) and αq ≥ 2
η(Λ⊥
decision A-LWEn,0,m,αq for the given parameters (see Theorem 3).
Encryption queries in our scheme are represented by ordinary A-LWE queries,
thus we can give a direct reduction. Indeed, we have b1 = s(cid:62) ¯A + e1 mod q and
b2 = s(cid:62)(h(u)G− ¯AR)+e2 mod q, where ( ¯A, h(u)G − ¯AR) is statistically close
to uniform by the leftover hash lemma and h(u)G − ¯AR is negl(n)-uniform for
any choice of u ∈ U following essentially the same argumentation as in [7]. Hence,
the advantage of the adversary in the CCA1 security game with our scheme from
(cid:117)(cid:116)
above is negligible.

n ≥ 2 ·(cid:112)ln(2n(1 + 1/))/π ≥

q (G)). Distinguishing these samples from random ones is as hard as solving

and e ←R DZm1 ,αq × DΛ⊥
√

q

17

For instance, if one chooses m = c · nk corresponding to a statistical instan-
tiation of the scheme – that is, A is statistically close to uniform – one can
encrypt messages of length c · nk bits. In combination with the one-time-pad
approach from [7] and message injection into the secret vector s, we can embed
approximately (c + 2)nk − n message bits.

Further Applications. In the full version [44] we show how to use this cryp-
tosystem as a main building block for the ﬁrst lattice-based RCCA-secure en-
cryption scheme and provide the schemes with an optional mode for high data
load encryption. Moreover, we propose an asymmetric authenticated encryp-
tion scheme (amongst others) by exploiting the full entropy of the error vector
for signatures and give a more eﬃcient variant of the somewhat homomorphic
encryption scheme initially proposed by Brakerski and Vaikuntanathan [34].

Acknowledgments. The work presented in this paper was performed within
the context of the Software Cluster project Sinnodium and Software Campus
project IT-GiKo by Rachid El Bansarkhani. It was funded by the German Fed-
eral Ministry of Education and Research (BMBF). Özgür Dagdelen and Jo-
hannes Buchmann are supported by BMBF within EC-SPRIDE. The authors
thank Steven Galbraith for useful comments.

References

1. Ajtai, M.: Generating hard instances of lattice problems (extended abstract). In:

28th ACM STOC, ACM Press (1996) 99–108

2. Regev, O.: New lattice-based cryptographic constructions. J. ACM 51 (2004)

899–942

3. Micciancio, D., Regev, O.: Worst-case to average-case reductions based on Gaus-

sian measures. In: 45th FOCS, IEEE Computer Society Press (2004) 372–381

4. Lyubashevsky, V., Micciancio, D., Peikert, C., Rosen, A.: Swiﬀt: A modest proposal

for FFT hashing. In: FSE. Volume 5086 of LNCS., Springer (2008) 54–72

5. Arbitman, Y., Dogon, G., Lyubashevsky, V., Micciancio, D., Peikert, C., Rosen,
A.: SWIFFTX: A proposal for the SHA-3 standard (2008) In The First SHA-3
Candidate Conference.

6. Gentry, C., Peikert, C., Vaikuntanathan, V.: Trapdoors for hard lattices and new
cryptographic constructions. In Ladner, R.E., Dwork, C., eds.: 40th ACM STOC,
ACM Press (2008) 197–206

7. Micciancio, D., Peikert, C.: Trapdoors for lattices: Simpler, tighter, faster, smaller.
In Pointcheval, D., Johansson, T., eds.: EUROCRYPT 2012. Volume 7237 of
LNCS., Springer (2012) 700–718

8. Ducas, L., Durmus, A., Lepoint, T., Lyubashevsky, V.: Lattice signatures and

bimodal gaussians. In: CRYPTO (1). (2013) 40–56

9. Güneysu, T., Lyubashevsky, V., Pöppelmann, T.: Practical lattice-based cryptog-
raphy: A signature scheme for embedded systems. In Prouﬀ, E., Schaumont, P.,
eds.: CHES 2012. Volume 7428 of LNCS., Springer (2012) 530–547

10. Lyubashevsky, V.: Lattice signatures without trapdoors. In Pointcheval, D., Jo-
hansson, T., eds.: EUROCRYPT 2012. Volume 7237 of LNCS., Springer (2012)
738–755

18

11. Katz, J., Vaikuntanathan, V.: Smooth projective hashing and password-based
authenticated key exchange from lattices. In Matsui, M., ed.: ASIACRYPT 2009.
Volume 5912 of LNCS., Springer (2009) 636–652

12. Jintai Ding, X.L.: A simple provably secure key exchange scheme based on the
learning with errors problem. Cryptology ePrint Archive, Report 2012/688 (2012)
http://eprint.iacr.org/.

13. Peikert, C.: Lattice cryptography for the internet. Cryptology ePrint Archive,

Report 2014/070 (2014) http://eprint.iacr.org/.

14. Peikert, C., Vaikuntanathan, V., Waters, B.: A framework for eﬃcient and com-
posable oblivious transfer. In Wagner, D., ed.: CRYPTO 2008. Volume 5157 of
LNCS., Springer (2008) 554–571

15. Regev, O.: On lattices, learning with errors, random linear codes, and cryptog-
In Gabow, H.N., Fagin, R., eds.: 37th ACM STOC, ACM Press (2005)

raphy.
84–93

16. Peikert, C.: Public-key cryptosystems from the worst-case shortest vector problem:
extended abstract. In Mitzenmacher, M., ed.: 41st ACM STOC, ACM Press (2009)
333–342

17. Brakerski, Z., Langlois, A., Peikert, C., Regev, O., Stehlé, D.: Classical hardness

of learning with errors. In: STOC. (2013) 575–584

18. Döttling, N., Müller-Quade, J.: Lossy codes and a new variant of the learning-
with-errors problem. In Johansson, T., Nguyen, P., eds.: Advances in Cryptology –
EUROCRYPT 2013. Volume 7881 of Lecture Notes in Computer Science. Springer
Berlin Heidelberg (2013) 18–34

19. Micciancio, D., Peikert, C.: Hardness of sis and lwe with small parameters. In:

20. Gentry, C.: Fully homomorphic encryption using ideal lattices. In: STOC, ACM

CRYPTO (1). (2013) 21–39

(2009) 169–178

21. Brakerski, Z., Vaikuntanathan, V.: Eﬃcient fully homomorphic encryption from
(standard) LWE. In Ostrovsky, R., ed.: 52nd FOCS, IEEE Computer Society Press
(2011) 97–106

22. Gentry, C., Halevi, S.: Fully homomorphic encryption without squashing using
depth-3 arithmetic circuits. In Ostrovsky, R., ed.: 52nd FOCS, IEEE Computer
Society Press (2011) 107–109

23. Brakerski, Z.: Fully homomorphic encryption without modulus switching from
classical GapSVP. In Safavi-Naini, R., Canetti, R., eds.: CRYPTO 2012. Volume
7417 of LNCS., Springer (2012) 868–886

24. Brakerski, Z., Gentry, C., Vaikuntanathan, V.: (leveled) fully homomorphic en-

cryption without bootstrapping. In: ITCS. (2012) 309–325

25. Cash, D., Hofheinz, D., Kiltz, E., Peikert, C.: Bonsai trees, or how to delegate
a lattice basis. In Gilbert, H., ed.: EUROCRYPT 2010. Volume 6110 of LNCS.,
Springer (2010) 523–552

26. Agrawal, S., Boneh, D., Boyen, X.: Eﬃcient lattice (H)IBE in the standard model.
In Gilbert, H., ed.: EUROCRYPT 2010. Volume 6110 of LNCS., Springer (2010)
553–572

27. Agrawal, S., Boneh, D., Boyen, X.: Lattice basis delegation in ﬁxed dimension and
In Rabin, T., ed.: CRYPTO 2010. Volume

shorter-ciphertext hierarchical IBE.
6223 of LNCS., Springer (2010) 98–115

28. Lyubashevsky, V., Peikert, C., Regev, O.: On ideal lattices and learning with
errors over rings. In Gilbert, H., ed.: EUROCRYPT 2010. Volume 6110 of LNCS.,
Springer (2010) 1–23

19

29. Lindner, R., Peikert, C.: Better key sizes (and attacks) for LWE-based encryption.
In Kiayias, A., ed.: CT-RSA 2011. Volume 6558 of LNCS., Springer (2011) 319–339
30. Lyubashevsky, V., Peikert, C., Regev, O.: A toolkit for ring-lwe cryptography. In
Johansson, T., Nguyen, P., eds.: Advances in Cryptology – EUROCRYPT 2013.
Volume 7881 of Lecture Notes in Computer Science. Springer Berlin Heidelberg
(2013) 35–54

31. Peikert, C., Waters, B.: Lossy trapdoor functions and their applications. In Ladner,

R.E., Dwork, C., eds.: 40th ACM STOC, ACM Press (2008) 187–196

32. Stehlé, D., Steinfeld, R., Tanaka, K., Xagawa, K.: Eﬃcient public key encryption
based on ideal lattices. In Matsui, M., ed.: ASIACRYPT 2009. Volume 5912 of
LNCS., Springer (2009) 617–635

33. Canetti, R., Krawczyk, H., Nielsen, J.B.: Relaxing chosen-ciphertext security. In
Boneh, D., ed.: CRYPTO 2003. Volume 2729 of LNCS., Springer (2003) 565–582
34. Brakerski, Z., Vaikuntanathan, V.: Fully homomorphic encryption from ring-LWE
In Rogaway, P., ed.: CRYPTO 2011.

and security for key dependent messages.
Volume 6841 of LNCS., Springer (2011) 505–524

35. Groth, J.: Rerandomizable and replayable adaptive chosen ciphertext attack secure
In Naor, M., ed.: TCC 2004. Volume 2951 of LNCS., Springer

cryptosystems.
(2004) 152–170

36. Phan, D., Safavi-Naini, R., Tonien, D.: Generic construction of hybrid public key
traitor tracing with full-public-traceability. In Bugliesi, M., Preneel, B., Sassone,
V., Wegener, I., eds.: ICALP 2006, Part II. Volume 4052 of LNCS., Springer (2006)
264–275

37. Prabhakaran, M., Rosulek, M.: Rerandomizable RCCA encryption. In Menezes,

A., ed.: CRYPTO 2007. Volume 4622 of LNCS., Springer (2007) 517–534

38. Xue, R., Feng, D.: Toward practical anonymous rerandomizable RCCA secure
In Qing, S., Imai, H., Wang, G., eds.: ICICS 07. Volume 4861 of

encryptions.
LNCS., Springer (2007) 239–253

39. Libert, B., Vergnaud, D.: Unidirectional chosen-ciphertext secure proxy re-
encryption. In Cramer, R., ed.: PKC 2008. Volume 4939 of LNCS., Springer (2008)
360–379

40. Dolev, D., Dwork, C., Naor, M.: Nonmalleable cryptography. SIAM Journal on

Computing 30 (2000) 391–437

41. Coron, J.S., Handschuh, H., Joye, M., Paillier, P., Pointcheval, D., Tymen, C.:
GEM: A generic chosen-ciphertext secure encryption method. In Preneel, B., ed.:
CT-RSA 2002. Volume 2271 of LNCS., Springer (2002) 263–276

42. Herzog, J., Liskov, M., Micali, S.: Plaintext awareness via key registration.

In
Boneh, D., ed.: CRYPTO 2003. Volume 2729 of LNCS., Springer (2003) 548–564
43. Boneh, D., Canetti, R., Halevi, S., Katz, J.: Chosen-ciphertext security from

identity-based encryption. SIAM Journal on Computing 36 (2007) 1301–1328

44. El Bansarkhani, R., Dagdelen, O., Buchmann, J.: Augmented learning with errors:
The untapped potential of the error term. Cryptology ePrint Archive, Report
2014/733 (2014) http://eprint.iacr.org/.

45. Kiltz, E.: Chosen-ciphertext security from tag-based encryption.

In Halevi, S.,

Rabin, T., eds.: TCC 2006. Volume 3876 of LNCS., Springer (2006) 581–600

46. Canetti, R., Halevi, S., Katz, J.: Chosen-ciphertext security from identity-based
encryption. In Cachin, C., Camenisch, J., eds.: EUROCRYPT 2004. Volume 3027
of LNCS., Springer (2004) 207–222

20

