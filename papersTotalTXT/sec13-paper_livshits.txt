Automatic Mediation of Privacy-Sensitive 
Resource Access in Smartphone Applications

Benjamin Livshits and Jaeyeon Jung, Microsoft Research

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Automatic Mediation of Privacy-Sensitive

Resource Access in Smartphone Applications

Benjamin Livshits and Jaeyeon Jung

Microsoft Research

Abstract

Mobile app development best practices suggest that
developers obtain opt-in consent from users prior
to accessing potentially sensitive information on the
phone. We study challenges that mobile application
developers have with meeting such requirements,
and highlight the promise of using new automated,
static analysis-based solutions that identify and in-
sert missing prompts in order to guard otherwise
unprotected resource accesses. We ﬁnd evidence
that third-party libraries, incorporated by develop-
ers across the mobile industry, may access privacy-
sensitive resources without seeking consent or even
against the user’s choice. Based on insights from real
examples, we develop the theoretical underpinning
of the problem of mediating resource accesses in mo-
bile applications. We design and implement a graph-
theoretic algorithm to place mediation prompts that
protect every resource access, while avoiding repeti-
tive prompting and prompting in background tasks
or third-party libraries.

We demonstrate the viability of our approach by
analyzing 100 apps, averaging 7.3 MB in size and
consisting of dozens of DLLs. Our approach scales
well: once an app is represented in the form of a
graph, the remaining static analysis takes under a
second on average. Overall, our strategy succeeds in
about 95% of all unique cases.

1

Introduction

Privacy on smartphones is far from being a theo-
retical issue: a popular iOS application, Path, had
been found to upload the entire address book of an
iPhone user by default; similarly, a number of high-
proﬁle incidents [1–3] show negative consequences
for mobile applications that surreptitiously collected
privacy-sensitive information about users without
explicit consent. Furthermore, a recent survey of 714

cell phone users shows that 30% of the respondents
had uninstalled an application because they discov-
ered that the application in question was collecting
personal information they did not wish to share [20].
Runtime consent dialogs (sometimes called run-
time permission prompts) are commonly used by
mobile applications to obtain a user’s explicit con-
sent prior to accessing privacy-sensitive data. How-
ever, mobile operating systems diﬀer in terms of
their approach to raising these consent dialogs.
iOS implements OS-level consent dialogs which are
raised when accessing GPS location, contacts stored
on the phone, as well as a few other key resources.
These dialog boxes are far from being “no-ops” for
the user: A recent study of hundreds of iPhone users
shows that 85% of them exercised this control to
deny at least one application from accessing location
data [13]. However, in the absence of OS-level sup-
port, application developers can individually imple-
ment opt-in consent dialogs for enhancing the overall
privacy for end-users.

This paper focuses on a number of technical chal-
lenges that arise when mobile application developers
determine the right place to insert runtime prompts
within an application. First, minimizing the runtime
frequency of consent dialogs is important, as repet-
itive prompts tend to habituate users to blindly ac-
cept the terms [7]. However, to protect user privacy,
every single attempt to access sensitive information
should be guarded with a prompt. Second, apps
should provide just-in-time prompts in order for it
to make sense to the user within the application con-
text. If prompts are placed early, e.g., at install time,
users may forget about granted permissions, leading
to unpleasant surprises because of data access per-
formed by the app, especially when it runs in the
background [21].

The aim of this paper is to formalize the prob-
lem of placing runtime consent dialogs within a mo-

USENIX Association  

22nd USENIX Security Symposium  113

bile application, and to propose a solution for au-
tomatic and correct prompt placement. We try to
both 1) ﬁnd missing prompts and 2) propose a valid
prompt placement when prompts are missing.

1.1 Analysis Design Philosophy

While it is possible to use dynamic analysis to ob-
serve missing prompts at runtime, this approach is
fraught with signiﬁcant challenges. The traditional
challenge is low path coverage, which can be allevi-
ated with path exploration techniques such as sym-
bolic execution, but never completely ﬁxed. Other,
more technical, challenges related to running UI-
based mobile apps automatically also remain.

Because we aim to provide a technique that would
err on the side of safety, we do not believe runtime
analysis is suitable. To this end, we propose a new
scalable static analysis algorithm to automatically
ﬁnd places for inserting prompts if they are miss-
ing. Our solution scales well with application size
and does not require any changes to the underlying
operating system.

Given the inherent nature of static analysis tech-
niques and the complexity of both the applications
and the execution environment, our tool may pro-
duce false positives. However, at the worst, these
false positives will result in double-prompts that oc-
cur at most once per application. We believe this
to be a considerable improvement over the current
error-prone practice of manual prompt placement.
Our approach in this paper may not be fully sound
due to issues such as reﬂection (see Section 4); how-
ever, our goal is be as sound as possible. Our evalua-
tion in Section 6 does not reveal any false negatives.
Finally, note that our target is benign, but poten-
tially buggy non-obfuscated apps. If the app writer
tries to either obfuscate their code or take advan-
tage of features that are not treated conservatively
(such as reﬂection) to hide control ﬂow, the preci-
sion and soundness of our analysis will suﬀer. Luck-
ily, the presence of obfuscation is relatively easy to
detect [22].

1.2 Contributions

Our contributions are three-fold:

• Using a set of .NET WP (Windows Phone) ap-
plications, we study how existing applications
implement resource access prompts. We note
that some advertising libraries access location
data without a prompt.

• We propose a two-prong static analysis algo-
rithm for correct resource access prompt place-

ment. We ﬁrst attempt to use a fast, dominator-
based placement technique. If that fails, we re-
sort to a slower but more exhaustive backward
search.

• We evaluate our approach to both locating
missing prompts and placing them when they
are missing on 100 apps. Overall, our two-
prong strategy of dominator-based and back-
ward placement succeeds in about 95% of all
unique cases. Our analyses run in seconds, mak-
ing it possible to run them as part of the app
submission process.

Our analysis reveals that some application develop-
ers fail to show the proper set of prompts, showing
the diﬃculty and ineﬀectiveness of manual place-
ment. Frequently, the issue that exacerbates this
situation is that resource access takes place within
third-party libraries shipped as bytecode, making
them more diﬃcult to reason about largely placing
them outside developer’s control.

1.3 Paper Organization

The rest of this paper is organized as follows. We
discuss case studies of real applications and chal-
lenges associated with proper prompt placement in
Section 2. We then formulate the problem and pro-
vide much of the insight for our proposed solution
in Section 3. We discuss the implementation of the
algorithms in Section 4. Results from an experi-
mental study are described in Section 5 and further
discussed in Section 6. We summarize related work
in Section 7 and conclude in Section 8.

2 Background

We ﬁrst provide three motivating case studies in Sec-
tion 2.1 and then provide intuition for the complex-
ity of the problem in Section 2.2.

2.1 Motivating Case Studies

We begin by discussing several interesting real-world
examples, which illustrate how existing WP apps
mediate access to location data. One of the ways
in which the WP SDK exposes location access API
to applications is through the GeoCoordinateWatcher
class
in the System.Device.Location namespace.
Prompts are created with a call to MessageBox.Show,
with the text of the prompt provided by the devel-
oper.

Figure 1 shows screen-shots of three applica-
tions — AroundMe, Burger King (inoﬃziell), Lumi-
aClock — immediately before these applications in-

114  22nd USENIX Security Symposium 

USENIX Association

USENIX Association  

22nd USENIX Security Symposium  115

(a)AroundMe(b)BurgerKing(c)LumiaClockFigure1:Screen-shotsofthreeexaminedapplications.TheﬁrsttwoapplicationsdisplayalocationpromptpriortoinvokinglocationAPIs.Thethirdapplicationnevershowsalocationprompt;thescreen-shotwascapturedwhenwedetectedtheﬁrsttimethatalocationAPIwasinvokedbytheapplication.AppResourceaccessesAPIsusedLibrariesAroundMe2TryStart,getPositionAroundMe.dllBurgerKing5Start,getPositionBurgerKing.dll,GART.dllLumiaClock2Start,getPositionSOMAWP7.dllFigure2:Locationaccessesfoundinthreeapps.vokelocationaccessAPI.WepickedthesethreeappsfromtheWPStore,ﬁlteringforappsthatuseGPSlocationdata.EachapplicationconsistsofasetofDLLsandresources.Wehavedisassembledtheap-plicationsandinspectedthecodetoﬁndinstancesoflocationAPIinvocations.Figure2shows(1)thenumberoflocationaccesspointsobservedineachofthethreeapplications;(2)whichlocationAPIisused;and(3)whichlibrariescallthelocationAPI.AsshowninFigure2,locationaccesshappensbothinapplicationcodeandinthird-partylibraries.Forinstance,GART.dllisalibrarythatprovidesaug-mentedrealityfeaturesandSOMAWP7.dllisalibrarythatprovidesadvertisingtoWPapplications.Notsurprisingly,theuseoflocationdatabythird-partylibrariescomplicatesaccessmediation,asthird-partylibrariesoftencomeasablackboxtoappli-cationdevelopers.Thefollowingin-depthanalysisillustratestheissue.Case1(properprotection):Locationaccessesarecontainedonlyintheapplicationcodeandprop-erlymediatedbyaruntimeconsentdialog.ThecodesnippetinFigure3(a)isfromtheAroundMeapplica-tion.Asshowninthecodebelow,thisapplicationpublicstaticboolAroundMe.App.CheckOptin(){if(((Option)Enum.Parse(typeof(Option),Config.GetSetting(SettingConstants.UseMyLocation),true))==Option.Yes){returnGetCurrentCoordinates();}if(MessageBox.Show("Thisappneeds...","Uselocationdata?",MessageBoxButton.OKCancel)==MessageBoxResult.OK){Config.UpdateSetting(newKeyValuePair<string,string>(SettingConstants.UseMyLocation,Option.Yes.ToString()));returnGetCurrentCoordinates();}...}(a)IllustrationforCase1publicBurgerKing.View.MapPage(){this.InitializeComponent();base.DataContext=newMapViewModel();this.BuildApplicationBar();if(AppSettings.Current.UseLocationService){this.watcher=newGeoCoordinateWatcher();}..}protectedvirtualvoidGART.Controls.ARDisplay.OnLocationEnabledChanged(DependencyPropertyChangedEventArgse){if(this.servicesRunning){if(this.LocationEnabled){this.StartLocation();}else{this.StopLocation();}}}(b)IllustrationforCase2publicSomaAd(){...this._locationUseOK=true;...if(this._locationUseOK){this.watcher=newGeoCoordinateWatcher(GeoPositionAccuracy.Default);this.watcher.MovementThreshold=20.0;this.watcher.StatusChanged+=newEventHandler<GeoPositionStatusChangedEventArgs>(this.watcher_StatusChanged);this.watcher.Start();}}(c)IllustrationforCase3Figure3:IllustrativecasesforSection2.1.invokesGetCurrentCoordinates()onlyaftertheuserclickstheOKbuttonasshowninFigure1.Case2(partialprotection):Locationaccessesarespreadacrossapplicationandthird-partycodeandonlyaccessesbyapplicationcodearepro-tectedbyruntimeconsentdialog.Thecodesnip-petinFigure3(b)isfromtheBurgerKingapplica-tion.TheconsentdialogshowninFigure1onlyaf-fectsAppSettings.Current.UserLocationServiceandleavesGART.Controls.ARDisplay.StartLocation()un-protected.Usingnetworkpacketinspection,wecon-while(P){

l1 = getLocation();

}

prompt();
while(P){

(a) original

l1 = getLocation();

}

while(P){

(b) static prompt

if(not-yet-prompted-for-location){

prompt();

}
l1 = getLocation();

}

(c) dynamic check

Figure 4: Resource access in a loop.

ﬁrmed that the application accesses and transmits
location using the GART component even when the
Cancel button is clicked.

Case 3 (no protection): Location accesses are
only present in third-party code and the applica-
tion provides no consent dialogs. The following code
snippet is from the LumiaClock application. The
application has no location features. Although the
third-party code SomaAd exposes a ﬂag to protect lo-
cation access, the application appears unaware of it.
Moreover, the SomaAd component enables the ﬂag,
locationUseOK by default, as shown in Figure 3(c).

In summary, the case studies above
Summary:
demonstrate that properly protecting location access
is challenging because multiple components, includ-
ing third-party libraries, are involved in accessing
sensitive resources. The current practice often fails
in providing adequate privacy protection, as some
applications do not honor the user’s choice (as shown
in case 2) or do not obtain the user’s consent prior
to acquiring privacy-sensitive information.

2.2 Challenges

Next, we dive into the properties that we want to en-
sure, while deciding where to place missing prompts
via static analysis. Na¨ıvely, one might suspect that
prompt placement is a fairly trivial task, reducing to
(1) ﬁnding resource access points and (2) inserting
prompts right in front of them. In reality, situation
is considerably more complex.
In this section, we
systematically investigate the challenges we need to
overcome in order to provide a satisfactory solution.

problem that it might initially seem; indeed, con-
sider the following code:

if(P) l1 = getLocation();
l2 = getLocation();

There are two location access points and two ways
to avoid duplicate prompts. One is to introduce
a boolean ﬂag to keep track of whether we have
prompted for the location already:

flag = true;
if(P){

prompt();
flag = true;
l1 = getLocation();

}
if(!flag){

prompt();
l2 = getLocation();

}

The disadvantage of this approach is that it requires
introducing extra runtime instrumentation to per-
form this sort of bookkeeping. A fully static ap-
proach involves rewriting the original code by “fold-
ing” the second prompt into the if:

if(P){

prompt();
l1 = getLocation();
l2 = getLocation();

}else{

prompt();
l2 = getLocation();

}

This approach has the advantage of not having to in-
troduce extra bookkeeping code. The disadvantage
is replication of the existing code across the branches
of the if, which leads to extra code growth.

The problem of double-prompts can be exacer-
bated. Figure 4a illustrates the challenge of placing
a prompt within a loop. Placing the prompt before
the loop as in Figure 4b is not valid if the loop never
executes. Placing the prompt within the loop body
will lead to execution on every iteration. However, a
simple dynamic check will ensure that the location
prompt is not shown more than once (Figure 4c).

2) Sticky prompts: Applications frequently make
user-granted permissions persistent and avoid dupli-
cate prompts, by saving the prompt status to the
app’s isolated storage, as illustrated in Figure 5.
Here the challenge comes in both recognizing ex-
isting “sticky” prompts in app code and in making
inserted prompts sticky, as discussed in Section 4.3.

1) Avoiding double-prompts: We need to avoid
prompting the user for access to resource R more
than once on a given execution path. This is a harder

3) Avoiding weaker prompts: Suppose there are
two resources r1, r2 such that r2 is less sensitive
than r1. If an app has already prompted the user for

116  22nd USENIX Security Symposium 

USENIX Association

access to r1, it should avoid prompting the user for
access to resource r2. For instance, if an app already
has requested access to ﬁne-grained location, there
is no need to prompt for access to coarse-grained lo-
cation. Note that in the current version of the WP
operating system, there is no diﬀerence in capabili-
ties between ﬁne- and coarse-grained locations; both
require the ID CAP LOCATION capability in the app
manifest. However, in the future more ﬁne-grained
capabilities subsuming one another may evolve, as
they have on Android. Moreover, it is still possible
and perhaps even desirable to distinguish between
ﬁne- and coarse-grained locations when prompting
at runtime, even though they are treated the same
at installation time.

4) Avoiding prompts in background tasks:
WP apps provide non-interactive background tasks.
These are often used for polling remote servers and
other tasks that do not require access to the user’s
screen beyond, perhaps, a live tile of the app. We
cannot raise dialog boxes within background tasks.
To properly determine where the prompts should be
located, we should compute the call graph and deter-
mine what foreground code precedes the code within
background tasks.

5) Avoiding prompts in libraries: Given that li-
braries are often shipped in the form of bytecode and
are updated separately from the rest of the applica-
tions, we choose to avoid placing prompts in library
code. This approach allows developers to examine
prompt placement within their own code, and to al-
leviate the need to keep custom-modiﬁed versions
of third-party libraries such as SOMAWP7.dll, which
can make error reporting, debugging, and sharing
libraries across apps a challenge.

if (MessageBox.Show(

"This app needs to know your location

in order to find locations
around you, can it use your location data?
note: you can change the settings later
through the settings menu",
"Use location data? ", 1) == 1)

{

}

Config.UpdateSetting(

new KeyValuePair<string, string>(

SettingConstants.UseMyLocation,
Option.Yes.ToString()));

return

GetCurrentCoordinates();

Figure 5: Sticky location prompt.

3 Overview

A recent spate of research eﬀorts is centered around
detecting undesirable information ﬂows, i.e. sensi-
tive data like contacts leaving the phone, usually
via the network (e.g.,
[9, 10]). Reasoning about
these kinds of leaks involves understanding inter-
procedural data ﬂow within the app and perhaps
even across diﬀerent apps. Data ﬂow analysis of this
kind is a known diﬃcult problem which, despite a
great deal of work on both the static and runtime
sides has not yet found widespread practical deploy-
ment [24].

In the context of mobile apps, there is another
aspect further complicating this problem. Even if
there is in fact a perfect mechanism for precisely
and eﬃciently tracking inter-procedural data ﬂow,
a viable policy is hard to come by.
Indeed, how
does a tool automatically distinguish between a Yelp
app that shares GPS location information with a
back-end server to obtain restaurant listings from
(a potentially malicious) ﬂashlight app that obtains
the same GPS information and shares it with an
ad server? Constructing a robust policy is not triv-
ial. Our paper rather focuses on providing a method
for assisting application developers in checking their
apps against the currently accepted practice of ob-
taining consent prior to accessing potentially sensi-
tive user data on the phone and in ﬁxing problems
before submitting apps to a marketplace. Note that
our work in this paper is in the control ﬂow, not
data ﬂow space; we want to reason about whether
the acquisition points for sensitive content are well-
protected.
In this section we ﬁrst formulate the
problem of prompt placement and then discuss some
approaches for computing a valid placement.

3.1 Graph Representation

As is typical in static analysis, it is helpful to rep-
resent the program in the form of a graph, to ab-
stract away many unnecessary features of the origi-
nal source or bytecode representation.

Since our goal is to reason about prompts “guard-
ing” resource access points, we choose a represen-
tation similar to a control-ﬂow graph. Because
both prompts and resource accesses take the form
of method calls, we ﬁnd it convenient to augment
the traditional notion of basic blocks to treat call
sites specially. We use the term enhanced basic block
to emphasize the diﬀerence in construction. An en-
hanced basic block is diﬀerent from a basic block in
that only the ﬁrst and last of its instructions can be
(method) calls. Consequently, call instructions exist

USENIX Association  

22nd USENIX Security Symposium  117

in a block of their own. (First and last instructions
can also be jumps, just as in the case of regular basic
blocks.)

Our

representations also need to be inter-
procedural: we need to be able to handle prompts
that are located outside of the method in which the
resource access takes place. This is especially neces-
sary given that WP apps are written in .NET, where
methods generally tend to be small. We therefore
augment the control glow graph with call and return
edges denoted as C below.

Deﬁnition 1 A resource access prompt place-
Let P =
ment problem is deﬁned as follows.
(cid:30)N, A, B, E, C,L(cid:28) be a tuple with the following com-
ponents:

• N :

set of enhanced basic blocks in the pro-
gram consisting of a sequence of instructions
N = n1, n2, . . . nk. For simplicity, we as-
sume that graph G has unique entry and exit
nodes Nentry, Nexit ∈ N .

• A ⊂ N : set of resource access points;
• B ⊂ N : set of enhanced basic blocks located
within background tasks and (third-party) li-
braries; we assume that Nentry and Nexit are
outside background tasks and libraries;
• E: intra-procedural control ﬂow edges;
• C: inter-procedural call and return edges.
• L = (cid:30)R,∧(cid:28): the semi-lattice of access permis-

sions with meet operator ∧1.

Intuitively, this representation is an expanded inter-
procedural control ﬂow graph G = (cid:30)N, E ∪ C(cid:28).

3.2 Valid Placement

Based on the challenges described in Section 2.2, we
proceed to formulate what it means to have a valid
placement of resource access prompts.

Deﬁnition 2 We say that placement P ⊂ N is a
valid placement for a prompt placement problem P =
(cid:30)N, A, B, E, C,L(cid:28) if the following conditions hold for
every runtime execution of the app:

• Safe: Every access to resource r ∈ R is preceded

by a prompt check for r.

• Visible: No prompt is located within a back-

ground task or a library.

1We assume that in the general case it is possible for per-
missions to subsume one another, like in the case of ﬁne- and
coarse-grained GPS locations, giving rise to a partial order,
although we currently do not strictly need this kind of support
in our implementation.

Check if access is 

adequately protected

no

Dominator-based 
strategy successful? 

no

Try backward 

placement strategy

Figure 6: Analysis steps.

• Frugal: Prompt for r ∈ R is never invoked
unless it is either followed by a call to get(r)
or an exception occurs2.

• Not-repetitive: Prompt for permission r2 ∈
R is never invoked if permissions for r1 ∈ R
have already been granted and r2 (cid:22) r1 (that
is, r1 is at least as or more permissive than r2).

3.3 Solution Outline

We provide intuition for our solution in the remain-
ing sections; Section 4 gives the actual algorithms.
Figure 6 shows the overall ﬂow of our analysis. Given
a graph with well-identiﬁed resource access points,
a safe placement is relatively easy to come up with.
The main obstacle is the fact that we cannot always
put prompts right before accesses, because some-
times accesses are within background tasks or, more
frequently, in libraries (violating the visible require-
ment).

Intuitively, we can start with resource access
points A and move the prompts up until we are
outside of background tasks. The downside of this
approach is a possibility of moving these prompts
too far (to the beginning of the app in the most
extreme case), which would violate the frugal re-
quirement. This gives rise to a notion of a prompt
being needed at a particular point, for which we use
the term anticipating, common in compiler litera-
ture [4]. By way of example, for the code snippet in
Figure 7, location access is anticipating before line 3,
but it is not anticipating before the if on line 2, be-
cause of the else branch. So placing the prompt on
line 1 leads to unnecessary prompting, violating the
requirement of being frugal .

1.
2. if(P){
3.
4. } else {
5.
x++;
6. }

var l = getLocation();

Figure 7: Conditional location access.

2Note that this notion of frugality is optimized for runtime

savings, not necessarily savings in terms of code size.

118  22nd USENIX Security Symposium 

USENIX Association

entry

1

exit

4

5

2

3

entry

1

4

2

3

5

exit

Figure 8: Graph (left) and its dominator tree (right).
Node 5 is a resource access node within a library.

Deﬁnition 3 We say that basic block B ∈ N is r-
anticipating if every path from B to Nexit passes
through a resource access of type r.

Intuitively, placing prompts for resource accesses of
type r at r-anticipating nodes is necessary because
these nodes are guaranteed to require them eventu-
ally; in other words, these placements will be frugal .
Finally, the discussion so far has not considered
the case of prompts granting permissions of diﬀer-
ent “strength”, resulting in potentially unnecessary
prompts. This suggests that the notion of being an-
ticipating should be deﬁned not globally, but with
respect to a particular kind of resource, taking into
account the lattice of resource access permissions.

Dominator-based Approach: Using the notion
of dominators in the graph [4] we can abstract away
unnecessary details. Recall that we say that node
d ∈ N dominates node n ∈ N if every path from
Nentry → n passes through d. Dominator rela-
tionships induce a dominator tree over the set of
nodes N . An example of such a dominator tree for
a graph in Figure 8a is shown in Figure 8b.

By this deﬁnition, dominator-based placement is
an easy way to “block” access to a particular resource
access. The most immediate approach is to place
prompts on the nodes dominating the resource ac-
cess node.

Of course, since we want a placement as close as
possible to the access point, we will prefer the im-
mediate dominator of the resource access node. By
deﬁnition, we will have a safe placement, because
∀ a ∈ A, every path from Nentry → a must pass
through idom(a), the immediate dominator of a.
This simple approach suﬀers from two problems:

• Background and library nodes can invalidate
immediate dominator-based placement. To deal
with the issue of visibility, we can shift the
prompts up in the dominator tree.

• Immediate dominator-based placement can vi-
olate the frugal condition. Indeed, consider the
location access at line 3 in Figure 7.
Its im-
mediate dominator is the if(P) node. However,
this node is not location-anticipating, because
the else branch is not accessing the location.

A viable approach is therefore to start at the re-
source access node and walk up the dominator tree
until we encounter a node that is not in the back-
ground or a library. We are guaranteed to encounter
such a node eventually, because sooner or later we
will encounter Nentry, which is a foreground non-
library node by Deﬁnition 1.

For the graph in Figure 8, node 5 is a library node.
Nodes 1 and Nentry are in the cover for node 5.
Node 1 is the immediate cover of 5. Our approach,
therefore, will choose node 1 for a prompt protect-
ing node 5, but, unfortunately, this placement will
violate the frugality condition.
Backward Placement:
Sometimes dominator-
based placement will backtrack “too far” in the graph
to become unnecessary — in other words, not fru-
gal . In these cases, we propose an alternative strat-
egy called backward placement, which often avoids
this problem. Backward placement explores the pre-
decessors of the resource access node and ﬁnd an
individual separate place for a prompt for each of
them. For node 5 in Figure 8, both predecessors 2
and 4 present valid placement opportunities, which
are also frugal. Frequently, the backward placement
approach will yield a valid placement. The concern
with this strategy is two-fold:

• This approach may not scale well, as it involves
an exponential graph search. While this is true
in general, in practice we frequently ﬁnd a valid
placement within several nodes, as detailed in
Section 5.

• More prompts will be created compared to the
dominator-based approach. (Indeed, in our Fig-
ure 8 example, we inserted two nodes instead of
one.) More inserted prompts may increase the
size of the rewritten app and may also make
manual validation of placement results more
challenging and time-consuming.

Unlike dominator-based placement, there is a possi-
bility of passing through prompt placement nodes
multiple times at runtime. To see this, consider
adding a backward edge from 3 → 1 in Figure 8.

USENIX Association  

22nd USENIX Security Symposium  119

n (cid:28)∈ G.Background ∧ n (cid:28)∈ G.Libraries

if ¬HasPrompt(G, a.Type, a) then
// Try dominator-based ﬁrst
P lacement ← ∅
success ← InsertPrompt-D(G, a, ant, idom)
if ¬ success then
// Try backward placement next
P lacement ← ∅
InsertPrompt-B(G, a, ant)
end if

if IsAnticipating(n, a.Type, ant) ∧
then
Placement ← Placement ∪ {n}
return true
else
n ← idom(n) (cid:19) Proceed to the immediate dominator
end if

1: function InsertPrompt(G, a, ant, idom)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11: end if
12: end function
13:
14: //Dominator-based placement
15: function InsertPrompt-D(G, a, ant, idom)
16: n ← a
17: while n (cid:28)= Nentry do
18:
19:
20:
21:
22:
23:
24:
25:
26: end while
27: return false
28: end function
29:
30: //Backward search placement
31: function InsertPrompt-B(G, a, ant)
32: Occurs-check(a)
33:
34:
35:
36:
37:
38: else
39:
40:
41:
42:
43:
44:
45:
46: end if
47: end function
48:
49: //Helper function to check if n is anticipating for r ∈ R
50: function IsAnticipating(n, r, ant)
r(cid:31) ← ant(n)
(cid:19) Computed prompt type at n
51:
(cid:19) True if r(cid:31) is more permissive
return r (cid:21) r(cid:31)
52:
53: end function

(cid:19) Prevent inﬁnite recursion
if ¬IsReachable(a) ∨ (IsAnticipating(a, a.Type, ant)
then
Placement ← Placement ∪ {a}
return true

∧ a (cid:28)∈ G.Background ∧ a (cid:28)∈ G.Libraries)

for all p ∈ G.predecessors(a) do
success ← InsertPrompt-B(G, p, ant)
if ¬success then
return false
end if
end for
return true

(cid:19) Predecessors

(cid:19) One of the predecessors failed

(cid:19) All predecessors succeeded

Figure 9: Insertion of resource access prompts. G is the
graph; a is the access node; ant : N → 2R is the antic-
ipating lookup map computed as speciﬁed in Figure 10,
and, ﬁnally, idom is the immediate dominator relation.

This edge does not aﬀect the dominator tree or
dominator-based placement. If we place prompts at
nodes 2 and 4 for resource access at node 5, there is
a possibility of encountering the prompt at node 2
multiple times as we go through the loop 1 → 2 → 3.
This kind of double-prompting violates the not-
repetitive condition in Deﬁnition 2. A simple way
to address this is to record user consent in app’s iso-
lated storage for both the current runtime session
and future app invocations, as shown in Section 4.3.

Semi-lattice
Top
Initial value

2R, the power set of R
L
(cid:20)
∅
init(n) ∅

Transfer func. T F (n) (cid:31) add r to set
identity
Meet operator ∧(x, y) union x ∪ y
Direction

backward

if n is an access
for r ∈ R
otherwise

Figure 10: Dataﬂow analysis formulation for comput-
ing anticipating nodes: ∀n ∈ N , we compute the set of
resource types that node n is anticipating.

3.4 Placement Algorithm

In our evaluation section, we will examine the trade-
oﬀs between the dominator-based and backward
placement strategies. To summarize, this is an out-
line of our placement approach:
1. For every r ∈ R and every node n ∈ N , compute
2. Merge values by meeting them in the semi-

its r-anticipating value Ar(n).

lattice L = (cid:28)R,∧(cid:25) for all resource types:

A(n) = (cid:30)r∈R

Ar(n)

3. For every resource access a of type r, use a back-
ward search to ﬁnd if it is adequately covered
by existing prompts of type r(cid:30) such that r (cid:24) r(cid:30).
4. If not, proceed to insert a prompt of type A(n)
using either a dominator-based or a backward
placement strategy.

Anticipating values can be calculated using a simple
data-ﬂow computation, in the style of the Dragon
book [4]. A formulation of this analysis is shown
in Figure 10 in the form of a table traditional for
succinctly representing data-ﬂow problems. The ad-
vantage of such a formulation is that it runs in lin-
ear time, given a lattice of ﬁnite height (and size),
and that most compiler frameworks already provide
a data-ﬂow framework into which this kind of anal-
ysis can be “dropped”.

There is some ﬂexibility when it comes to the last
step.
Indeed, we can choose to use a dominator-
based, or a backward placement strategy, or some
combination.
In our implementation, we try the
dominator strategy ﬁrst to see if it yields a valid
placement and, failing that, resort to the backward
strategy. This hybrid approach is shown in the
function InsertPrompt in Figure 9. Note that if
placement is successful, the outcome is stored in the
Placement ⊂ N set.
to avoid the possibility of

InsertPrompt-B has an occurs-check on line 32
inﬁnite recursion for

120  22nd USENIX Security Symposium 

USENIX Association

(cid:27) Prevent inﬁnite recursion

(cid:27) Existing prompt at least as

(cid:27) Check if adequately protected

1: //Checks for existing prompts
2: function HasPrompt(G, r, a)
3: Occurs-check(a)
4:
5:
6:

if a ∈ G.Prompts then
r(cid:31) ← a.Type
adequate ← (r (cid:29) r(cid:31))
permissive as needed?
if adequate then

return true

7:
8:
9:
end if
10: end if
11:
//Explore all predecessors in turn
12:
for all p ∈ G.predecessors(a) do
13:
success ← HasPrompt(G, r, p)
14:
if ¬success then
15:
return false
16:
17:
end if
18: end for
19:
return true
20: end function

(cid:27) One of the predecessors failed

(cid:27) All predecessors succeeded

Figure 11: Checking for resource access prompts. G is
the graph; r is the resource type; a is the access node.

graphs with loops, which are encountered in the pro-
cess of backward exploration. If the current node is
not reachable from non-library code as indicated by
IsReachable, we return true. We discuss the chal-
lenges of fast backward computation in Section 4.2.

3.5 Checking For Existing Prompts

Note that before we choose to insert prompts we
need to make sure they are in fact missing as shown
on line 2 of Figure 9. Doing so requires a backward
search, as shown in Figure 11. Note that in prac-
tice, HasPrompts frequently returns false, failing
quickly without exploring the entire set of predeces-
sors. Section 4.2 demonstrates how this search can
be made faster.

1: function CreatePlacement(G, ant, idom)
for all a ∈ G.Accesses do
2:
success ← InsertPrompt(G, a, ant, idom)
3:
if ¬ success then
4:
return false
5:
else
6:
for all p ∈ Placement do
7:
Prompts ← Prompts ∪ (cid:26)p, ant(a)(cid:25)
8:
end for
9:
10:
end if
11: end for
12:
13:
14:
15:
16: end for
17:
return true
18: end function

// All clear: proceed with the placement
for all (cid:26)n, t(cid:25) ∈Prompts do
InsertAtNode(n, t)

Figure 12: Putting it all together: creating an overall
prompt placement for graph G.

3.6 Proof Sketch

The algorithm that pulls everything together to cre-
ate a placement is shown in Figure 12. We ﬁrst check
that whether there is indeed a valid placement for all
resource accesses. Once this is ensured, we proceed
to modify the underlying graph by inserting prompts
at appropriate places. Note that prompt insertion is
only attempted if they are in fact missing, as en-
sured by the check on line 2 of Figure 9. The details
of runtime instrumentation are given in Section 4.3.
The structure of the algorithm allows us to reason
about the resulting placement.

Theorem 1 The placement of prompts above is in
fact valid if the placement routine CreatePlace-
ment returns true.

Proof sketch: It is easier to consider each correct-
ness property in turn. We will refer to code lines in
Figure 9 unless indicated otherwise.
Safe: We need to ensure that every access a to
resource r is preceded by a prompt check for r.
The call to InsertPrompt must have returned
true for resource access a. This is because either
the dominator-based or backward strategy was suc-
cessful. If the dominator-based strategy succeeded,
there was a non-background, non-library node dom-
inating a which is also anticipating for a.Type. The
check on line 18 maintains this invariant.
If the
dominator-based strategy failed and the backward
strategy succeeded, this is because every path from a
to Nentry has encountered a placement point which
satisﬁed the check on line 33, providing adequate
protection for the access at a.
Visible: No prompt is placed within a background
task or library code. This is true by construction
because of checks on lines 19 and 34.
Frugal: Placement only occurs at anticipating
nodes because of checks on lines 18 and 33.
Not-repetitive: Prompt for r2 ∈ R is never in-
voked if permissions for r1 have already been granted
and r2 (cid:30) r1. This property is maintained by a com-
bination of three steps: (1) merging in Step 2 on the
overall algorithm, (2) check on line 52 and (3) the
runtime “sticky” treatment of prompts that avoids
double-prompting for the same resource type further
explained in Section 4.3.

4

Implementation Details

Our current implementation of the static analysis
described in this paper involves dealing with a vari-
ety of practical details, some of which are fairly com-
mon in bytecode-based static analysis tools, whereas

USENIX Association  

22nd USENIX Security Symposium  121

others are quite speciﬁc to our setting of WP apps
written in .NET.

A signiﬁcant part of the implementation involves
building a graph on which to perform our analysis.
Intra-procedurally, we parse the .NET bytecode to
construct basic blocks; we terminate them at method
calls to simplify analysis. For call graph construc-
tion, we use a simple class hierarchy analysis (CHA)
to resolve virtual calls within the program. We also
construct a dominator tree as part of graph construc-
tion, as we need it later. In many cases, the resulting
graphs have enough precision for our analysis.

4.1 Reﬂection & Analysis Challenges

WP applications are distributed as XAP ﬁles, which
are archives consisting of code in the form of byte-
code DLLs, resources such as images and XAML,
and the app manifest, which speciﬁes requested ca-
pabilities, etc. Unsurprisingly, various reﬂective con-
structs found in WP apps create challenges for our
analysis. While we outline some of the details of
our solutions below, constructing precise static call
graphs for mobile apps remains an ongoing chal-
lenge, and require further research.

Analysis imprecision usually does not stem from
the underlying call graph construction approach,
which could be alleviated through pointer analysis,
which generally provides suﬃcient precision for call
graph construction, but in challenges speciﬁc to com-
plex WP apps, as discussed below.

Event handlers: The code below illustrates some
complications posed by event handlers.

static void Main(string[] args) {

AppDomain.CurrentDomain.ProcessExit +=

new EventHandler(OnProcessExit);

}

// library code
static void OnProcessExit(object sender, EventArgs e) {

// location access
var watcher =

new System.Device.Location.GeoCoordinateWatcher();

var pos = watcher.Position;

}

By default, method OnProcessExit does not have any
predecessors in the call graph. At runtime, it may
in fact be called from a variety of places, which is
not easy to model as part of call graph construction.
However, it may not be called before the event han-
dler is registered in method Main. Our solution is to
augment the call graph construction code to create
a special invocation edge from the registration site
to OnProcessExit. The analysis will then be able
to place the prompt right before the registration in

method Main, which makes a signiﬁcant diﬀerence in
our ability to ﬁnd successful placements.
Actions and asynchronous wrappers: Another
similar form of delayed execution in WP apps is ac-
tions (System.Action) and its asynchronous cousin
System.AsyncCallback, which are eﬀectively wrap-
pers around delegates registered for later execution.
We deal with actions in a way that is similar to event
handlers.
XAML: A particular diﬃculty for analysis stems
from the use of declarative UIs speciﬁed in XAML,
an XML-like language that combines an easy-to-
read UI speciﬁcation with “hooks” into code. XAML
is compiled into special resources that are em-
bedded into an app’s DLLs. When the method
InitializeComponent() is called on the class speci-
ﬁed in XAML, it proceeds to register events that are
speciﬁed declaratively, as shown in a XAML snippet
below:

1

2

3

4

5

6

7

8

<phone:PhoneApplicationPage.ApplicationBar>

<shell:ApplicationBar IsVisible="True">

<shell:ApplicationBar.MenuItems>

<shell:ApplicationBarMenuItem Text="Settings"

Click="SettingsClick" />

</shell:ApplicationBar.MenuItems>

</shell:ApplicationBar>

</phone:PhoneApplicationPage.ApplicationBar>

Event handler SettingsClick should be properly reg-
istered so that it can later be invoked.

Alas, some aspects of declarative app speciﬁcation
defy static analysis. A typical example is navigation
between an app’s pages.

1

2

3

4

5

base.NavigationService.

Navigate(new Uri(

"/VenueByGeo.xaml?mc=" + this.strMenuCode +
"&t=" + this.strToken,
UriKind.RelativeOrAbsolute));

Statically, we do not know which page will be nav-
igated to, and, consequently, which OnNavigatedTo
event handler will be called. To avoid polluting the
call graph, we only link up page navigation when
the destination is a string constant. Unfortunately,
this approach is unsound. A more robust technique
would be to integrate a string analysis [8, 19, 33] into
our implementation.
Summary: Reﬂective coding constructs are the
Achilles heel of static analysis. While this is true as
it applies to applications written in .NET and Java,
this is especially so given the declarative program-
ming style often used in WP apps, where code is
“glued together” with declarative speciﬁcation. Sev-
eral approaches to handling reﬂection have been pro-
posed and used in the literature [6, 18, 26, 28, 35].
Alas, all of them require a certain degree of cus-
tomization to the problem and APIs at hand. Addi-
tionally, reﬂection analysis tends to be intertwined

122  22nd USENIX Security Symposium 

USENIX Association

with a heavyweight analysis such as a points-to. We
instead opt for a lightweight analysis that pattern-
matches for the easily-to-resolve case, potentially in-
troducing unsoundness. We evaluate the eﬀects of
this treatment in Section 6.

[SomaAd..ctor() @ 0134) bg

// resource access

[SomaAd..ctor() @ 0120) bg

[SomaAd..ctor() @ 0118) bg

[SomaAd..ctor() @ 0000) bg

[SomaAdViewer.StartAds() @ 00a6) bg

[SomaAdViewer.StartAds() @ 009e) bg

[SomaAdViewer.StartAds() @ 0000) bg

[CollectHome.g_AdFailed(object, ...) @ 00f7) fg

[CollectHome.g_AdFailed(object, ...) @ 0052) fg

[CollectHome.g_AdFailed(object, ...) @ 000a) fg

[CollectHome.g_AdFailed(object, ...) @ 0000) fg
[CollectHome.g_AdFailed(object, ...) @ 0040) fg

[CollectHome.g_AdFailed(object, ...) @ 0030) fg

[CollectHome.g_AdFailed(object, ...) @ 0008) fg

[CollectHome.g_AdFailed(object, ...) @ 004a) fg

[CollectHome.g_AdFailed(object, ...) @ 00df) fg

[CollectHome.g_AdFailed(object, ...) @ 006c) fg

[CollectHome.g_AdFailed(object, ...) @ 0066) fg

Figure 13: A backward exploration tree of depth 20.
Method names and signatures are abbreviated for
brevity. bg and fg stands for background/library vs.
foreground/non-library methods, respectively.

4.2 Fast Backward Placement

Recall from Section 3 that our approach resorts to
a search for both checking if a resource access is
already protected with a prompt and for inserting
prompts if the dominator-based strategy fails.
In
implementing backward search, we need to be con-
cerned with preventing inﬁnite recursion (the occurs-
check from Section 3). There is also the possibility of
exponential path explosion, which is quite real given
that we we are dealing with graphs that typically
have tens of thousands of nodes. It is therefore im-
perative to design an eﬃcient exploration strategy.
Our approach for both checking for prompts and
inserting them relies on ﬁrst building a spanning tree
rooted at the access node, computed using a depth-
ﬁrst search. Figure 13 gives an example of such a
tree. The tree allows us to classify underlying graph
edges as ether forward, backward, or cross edges.
Further analysis is performed on the tree as a se-
ries of downward passes, implemented as recursive
procedures, starting at the resource access and ex-
ploring the predecessors3.
In summary, we perform
three recursive passes over the spanning tree. Each
pass computes a boolean value for each of the vis-
ited nodes to represent the checking or placement

3To avoid stack overﬂow issues stemming from deep trees,
once the tree has been constructed, we make sure that the size
is below a ﬁxed threshold (set to 250 for our experiments).

status; values are maintained across the passes in a
map called υ.

The advantage of this multi-pass approach is its
simplicity and guaranteed runtime complexity. We
start with all spanning tree nodes as unvisited and
then perform three recursive traversals of the tree,
as shown in Figure 14 and described below. In our
implementation, we reuse the same spanning tree for
the prompt checking and placement analysis stages.
This approach is linear in the size of the graph, and
is generally quite fast, even when there are hundreds
of nodes reachable from a resource access.

1. Traverse:

non-library

each
declare

non-
For
background node,
it as a valid
placement point and set υ[n] to true 4. For
other nodes, if all their children have their υ
as true, set υ[n] to true; otherwise, set υ[n] to
false.

2. Patch-up: Traverse the tree considering cross-
edges originating at the current node.
If all
cross-edges emanating from nodes have valid
placements (υ value is true), set υ[n] to true.

3. Collect: Propagate (newly) true values up to
the root: set υ[n] to true if the υ value is true for
all of n’s children.

The ﬁnal result is computed by running all three
steps in order and examining the result at the root
of the spanning tree.

4.3 Runtime Considerations

While much of the focus of this paper is on statically
locating placement points, choosing the right kind of
runtime instrumentation presents some interesting
challenges. We need to ensure that we are not go-
ing to induce double-prompting, as discussed in Sec-
tion 3. To do so, we maintain a “sticky” app-global
setting value in the app’s isolated storage, as illus-
trated by the following example for the ﬁne-grained
GPS location resource type:

1

2

3

4

5

6

7

8

9

10

11

12

var setting = IsolatedStorageSettings.

get_ApplicationSettings().

get_Item("UserLocationSettings");

if (setting == null){

int result = MessageBox.Show(

"Is it okay to access your fine-grained GPS location?",
"Allow "+Assembly.GetExecutingAssembly().FullName()+
" to access and use your location.",

1);

{

settings.set_Item("UserLocationSettings",

(result == 1) ? "Y" : "N");

4Note that to maximize backward placement opportuni-
ties, for all unreachable nodes, we set υ[n] to true, as shown
in Figure 9. This is because the presence of dead code should
not prevent prompt placement.

USENIX Association  

22nd USENIX Security Symposium  123

for all c ∈ children(n) do
Traverse(c)

1: function Traverse(n)
2:
3:
4: end for
5: υ[n] ← true
6:

if n (cid:29)∈ G.Background ∧ n (cid:29)∈
G.Libraries return

7:
for all c ∈ children(n) do
8:
if ¬υ[c] then
9:
υ[n] ← false
10:
return
11:
12:
end if
13: end for
14: end function
15:

1: function Collect(n)
for all c ∈ children(n) do
2:
if ¬υ[c] then
3:
υ[n] ← false
4:
return
5:
6:
end if
7: end for
8:
9: υ[n] ← true
10: end function

if ¬υ[n] then
crossEdges← CrossEdges(n)
if |crossEdges| > 0 then
υ[n] ← true
for all (cid:25)n(cid:31) → n(cid:23) ∈ crossEdges do
if ¬υ[n(cid:31)] then
υ[n] ← false
break
end if
end for

1: function PatchUp(n)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17: end if
18: end function

for all c ∈ children(n) do
PatchUp(c)
end for

end if

Step 1: Traverse

Step 2: Patch-up

Step 3: Collect

Figure 14: Three-stage backward placement algorithm explained in Section 4.2.

13

14

15

16

17

18

}

}else{

if(setting.ToString().Equals("Y")){

// proceed with the prompt

}

}

Because the prompt remains sticky application-wide
and persists across application invocations, even if
we conservatively insert an extra prompt, we will
only show it at most once per app.

5 Evaluation

We have analyzed 100 WP 7 apps from the WP
Store to collect our results. To make the analysis
more meaningful, we have selected only apps with
LOCATION and NETWORKING capabilities. Such apps
constitute about a ﬁfth of a larger set of about 2,000,
from which we drew our 100
app sample. The
goal of our evaluation is to understand how fre-
quently prompts are omitted and to attempt to in-
sert prompts in a fully automatic manner.

Characterizing the input: We ﬁrst present some
aggregate statistics of the analysis results in Fig-
ure 15. WP applications are quite substantial in size,
constituting about 3,528 methods on average. This
is in part because they rely (and therefore recursively
include within their call graph) large libraries, some
of which are part of the operating system SDK, and
others are included .NET libraries. The average size
for our apps is 7.3 MB; many consist of dozens of
DLLs.
We

in the
quently.
functionality, and many request

shown
fre-
These libraries provide advertising
location data.

discovered
inlined ﬁgure are

included most

libraries

that

the

Count

Component

42
13
10
10
10
8
7
5
5
5

SOMAWP7
NetDragon.PandaReader
EchoEchoBackgroundAgent
Utilities
BMSApp
MobFox.Ads.LocationAware
XIMAD Ad Client
EchoEcho
DirectRemote
DCMetroApp

About
7% of
all methods are
contained in back-
ground tasks or
libraries,
which
presents a signif-
icant
challenge
for prompt place-
ment.
Out of
these, most are in
fact in third-party libraries. Recall that we do not
want to place prompts in libraries. To recognize
third-party libraries in our experiments, we used a
list of 100 common advertising libraries, identiﬁed by
the DLL in which they are contained; these include
AdRotator.dll,
Microsoft.Advertising.Mobile.dll,
MobFox.Ads.LocationAware.dll,
FlurryWP7SDK.dll,
Inneractive.Nokia.Ad.dll,
adMob7.dll,
Photobucket.Ads.dll and many others. Our analysis
is parameterized with respect to this list. Frame-
works such as these may access GPS location deep
within library code, making prompt placement
analysis particularly diﬃcult.

MoAds.dll,

Our analysis represents each application as 13,330
nodes on average. Out of these, about 12% are con-
sidered to be anticipating by our analysis. In other
words, about 88% of nodes are not eligible prompt
placement points.

all

apps,

The last section of Figure 15 describes the re-
applications.

source accesses found in these 100
Across
there
are 227 resource accesses we
analyze. Overall, apps have
an average of 2.27 resource
accesses, with a maximum
of 9 for one of the apps. The ﬁgure shown inline
in this paragraph shows how frequent individual

Location
Contacts
Calendar

95.15%
4.41%
0.44%

124  22nd USENIX Security Symposium 

USENIX Association

apps analyzed

processed methods
background/library methods
library methods

nodes
anticipating

accesses
accesses in background/library methods

100

352,816
26,033
25,898

1,333,056
171,253

227
78

Figure 15: Apps analyzed: summary of input statistics.

succeeded
failed
succeeded unique
failed unique

dominator-based succeeded
na¨ıve

backward succeeded
regular
dead code
backward placements
depth exceeded

202
19
143
7

150
143

56
150
2,094
(40,270, 56)
15

Figure 16: Prompt placement: summary of results of
applying analysis to 100 apps.

resource types are. We ﬁnd that the majority of
sensitive resource accesses are to GPS location
data, with occasional accesses to user contacts and
calendar.

Inserting prompts:
Figure 16 provides statis-
tics describing the prompt placement process. Over-
all, our two-prong strategy of dominator-based and
backward placement succeeds in about 91% of all
cases. However, it is important to observe that many
cases, including challenging resource accesses deep
in library code, are shared by many applications.
To avoid double-counting, we show the number of
unique placement attempts that have succeeded and
failed. Considering these numbers of unique ac-
cesses, we are able to successfully place prompts

app loading
call graph construction
placement graph construction
anticipating computation

ﬁnding missing prompts

prompt insertion, per app
dominator-based, per access
backward, per access

Average

Max #

1,779
18,152
15,103
158

123

942
0.05
1,366

24,585
147,287
293,480
3826

100
100
100
86

649

100

70,228
1
49,277

103
221
71

Figure 17: Timing, in ms. All measurements are per
app, unless stated otherwise.

in 95% of cases (143 out of 150), a higher success
percentage. Several other lessons can be drawn from
the rest of the table:

• When dominator-based placement succeeds, it
is usually immediate (95% of all dominator-
based successes are na¨ıve successes).

• Backward placement is helpful for cases where
dominator-based placement fails.
However,
some of these cases are still too hard, leading
to 7 unique failures.

Timing: Figure 17 provides a summary of tim-
ing information for our analysis. For each mea-
surement, we provide the average timing across 100
apps, the maximum observed time and the num-
ber of observations. Each measurement in given
in ms. Overall, the most time goes into initial pro-
cessing of the application, which involves reading
it from disk, constructing a representation of the
app’s assemblies in memory (1.7 seconds on aver-
age), traversing it to create a call graph and control
ﬂow graphs (CFGs) (18 seconds on average), dom-
inator calculation, and reachability calculation, re-
sulting in a graph suitable for analysis. Computing
anticipating nodes only takes 158 ms on average.

Finding missing prompts takes about 123 ms on
average, in part because many instructions need to
be examined in search of existing prompts. Prompt
insertion, on average, is fast, only about .9 seconds
per application. Dominance-based placement is vir-
tually instantaneous. Backward placement is slower,
at 1.3 seconds per resource access, raising the aver-
age. Based on these performance numbers, we are
optimistic that prompt insertion can be done entirely
automatically over a large number of applications.

6 Discussion

We have selected static analysis as a method of
choice to avoid code coverage issues inherent with
runtime analysis and for analysis speed (end-to-end
processing is several minutes per app). In this sec-
tion we discuss some of the limitations of our current
static analysis approach. There are two potential
sources of errors in our analysis. Our analysis may
classify a resource access as unprotected whereas it
is properly protected with runtime prompts; we call
these cases false positives. By the same token, our
analysis may classify a resource access as protected
whereas in fact at runtime there are no preceding
prompts that protect the resource access; we call
these cases false negatives.
Manual inspection: We examined a subset of ap-
plications to manually check for these errors. The

USENIX Association  

22nd USENIX Security Symposium  125

veriﬁcation process includes running these applica-
tions in the emulator to collect network packets and
to collect API calls invoked by each application at
runtime. We manually exercise as much functional-
ity of each application as possible. If the application
presented a runtime prompt, we inspected the text
of the message and clicked through each “allow” (to
use my location) and “don’t allow” button to deter-
mine how the choice aﬀects application behavior.

Once the runtime inspection was complete, we ex-
amined network packets and invoked API lists, cor-
relating them with the app’s disassembled code to
verify the observed behavior. Although this veriﬁca-
tion process is thorough, it requires signiﬁcant man-
ual eﬀorts, thus limiting the number of cases that can
be examined. Next, we discuss ﬁndings from 10 ap-
plications. These apps contain 27 resource access
points, among which 21 are classiﬁed as unprotected
by our analysis.

6.1 False Negatives

Our manual analysis found no false negatives. On
a close examination of each of the 27 resource ac-
cesses, we ﬁnd 10 accesses that are not protected.
Our analysis correctly identiﬁes all of these accesses
as unprotected and ﬁnds proper placements.

These unprotected accesses are found in third-
Interest-
party libraries included across 5 apps.
ingly,
in an eﬀort to maximize revenue, one app
embeds two advertising related third-party libraries
(SOMAWP7.dll and AdRotatorXNA.dll) and both con-
tain unprotected location accesses. Two placements
are made via dominator-based placement; the other
eight through backward placement. Backward place-
ments result in 40 inserted prompts in application
code, which upon casual examination appear to be
correct. We ﬁnd these results promising, as users
express increasing concern about data sharing with
third parties [21], and our analysis properly detects
and ﬁxes such unprotected accesses.

6.2 False Positives

Eleven out of 21 accesses ﬂagged as unprotected turn
out to be properly protected. Although the number
of false positives is somewhat high, with manual in-
spection, we found the following reasons for them:

Sticky location prompt: Seven false positives are
due to our analysis’s inability to analyze sticky lo-
cation prompts, as shown in Figure 5. Three cases
are similar to the example in Figure 18(a). The rest
are caused by one application that uses the location
ﬂag to enable or disable the button that allows the

private void mapLocaitons() {

if (this.avisAppUnitService.UseLocationsMapping) {

this.watcher=null;
GeoCoordinateWatcher watcher=new GeoCoordinateWatcher

(GeoPositionAccuracy.Default){MovementThreshold = 20.0};

this.watcher = watcher;
...
this.watcher.Start();

}

}

(a) Sticky
saves
the
Athis.avisAppUnitService.UseLocationsMapping.

prompt
result

example #1:

of

the

prompt

response

This

app
in

public MapPage() {

this.InitializeComponent();
base.DataContext = new MapViewModel();
this.BuildApplicationBar();
if (AppSettings.Current.UseLocationService) {

this.watcher = new GeoCoordinateWatcher();

}
((ApplicationBarIconButton)base.ApplicationBar.Buttons[0]).

IsEnabled = AppSettings.Current.UseLocationService;

((ApplicationBarIconButton)base.ApplicationBar.Buttons[2]).

IsEnabled = AppSettings.Current.UseLocationService;
this.UpdatePushpinsBackground();

}

(b) Sticky prompt example #2: This app disables page
navigation based on the location access depending on
AppSettings.Current.UseLocationService.

Figure 18: Sticky prompt examples.

user to navigate to the page (that invokes location
access) as shown in Figure 18(b). WP apps can use
several diﬀerent storage mechanisms; we are looking
into ways to detect them statically.

Consent dialog implementation: Two false pos-
itives are due to the limitation of identifying exist-
ing prompts. Both result from a single app that
implements a custom consent dialog page instead
of MessageBox(), as shown in Figure 19. We are
looking into ways to parse a blocking page with
buttons to detect such custom-made consent dialog
pages, although this is obviously a diﬃcult problem.
However, such cases are not common and we ﬁnd
that ﬁve out of six applications that show prompts
employ MessageBox(), as expected.

Async calls and XAML ﬁles: Two false positives
are due to limitations of call graph construction.
Figure 20(a) shows an expanded example of the
case discussed in Section 4.1. Applications may
use multiple types of EventHandlers to be called
asynchronously. In our current implementation, we
parse EventHandlers and add links when handlers
are registered. However, the current implementa-
tion fails when multiple delegates and EventHandlers
are used in a tricky way, as shown in Figure 20(b).
We are investigating ways to extend our call graph
construction to support these cases.

126  22nd USENIX Security Symposium 

USENIX Association

USENIX Association  

22nd USENIX Security Symposium  127

(a)Apppagewithloca-tionaccess.(b)Prompt(consentdi-alog).Figure19:Falsepositiveduetoacustomprompt:ApromptiscustomizedasaseparateWPUIpage.6.3EﬀectofFalsePositivesLikemostpracticalstaticanalysistools,ouranalysisispotentiallyvulnerabletofalsepositives,primarilybecauseofprogramrepresentationchallenges.Un-likemoststaticanalysistoolsforbugdetection,ouranalysisistwo-phase:ifitdetectsthataresourceaccessisnotadequatelyprotected,ittriestopro-poseaplacementofpromptsthatwouldprotectit.Ouranalysiserrsonthesafeside,introducingfalsepositivesandnotfalsenegatives.Falsepositives,however,mayleadtodouble-prompting,sinceouranalysiswillinjectaprompttoprotectalreadyprotectedresourceaccesses.Be-causeourinsertedpromptsaresticky,ourapproachintroducesatmostoneextraruntimepromptperappduringtheentireapp’slifecycle,whichwebe-lievewillnotleadtopromptfatigue.Nonetheless,double-promptingcantriggerconfusioninend-usersandthereforeshouldbeminimized.Ourexperiencewiththetentestapplicationsshowsthatinallcases,resourceaccessesgettriggeredquickly,withseveralclicks,soruntimecheckingofthiskindisunlikelytorequireexcessiveeﬀort.Ifdesired,runtimetest-ingbythedeveloperorAppStoremaintainerscanaccompanyouranalysistodetectandeliminatepo-tentialdouble-prompting.7RelatedWorkTherequirementofprotectingprivacy-sensitivere-sourceaccesseswithruntimepromptsorconsentdi-alogshasonlyrecentlybeenintroducedtomobileapplications.Toourknowledge,nopreviousworkhasinvestigatedstaticanalysisapproachestodetectprivatevoidGPS_MouseLeftButtonDown(objectsender,MouseButtonEventArgse){...elseif(MessageBox.Show("Sharingthisinfoallowsustofindtheatersandeventsnearyou.Wewon’tsharethisinformation.","AllowBookMyShowtoaccessanduseyourlocation.",MessageBoxButton.OKCancel)==MessageBoxResult.OK){...base.NavigationService.Navigate(newUri("/VenueByGeo.xaml?mc="+this.strMenuCode+"&t="+this.strToken,UriKind.RelativeOrAbsolute));}...}(a)ComplexCFG#1:FunctionNavigate()internallycallsBMSApp.VenueByGeo.OnNavigatedTo()asdeﬁnedinVenueByGeo.xaml.publicstaticboolGetCurrentLocation(){...Observable.FromEvent<GeoPositionStatusChangedEventArgs>(delegate(EventHandler<GeoPositionStatusChangedEventArgs>ev){GeoCoordinateWatcher.StatusChanged+=ev;},delegate(EventHandler<GeoPositionStatusChangedEventArgs>ev){GeoCoordinateWatcher.StatusChanged-=ev;}).Where<IEvent<GeoPositionStatusChangedEventArgs>>(delegate...args){if(args.EventArgs.Status!=GeoPositionStatus.Ready){return(args.EventArgs.Status==GeoPositionStatus.Disabled);}returntrue;}).Take<IEvent<GeoPositionStatusChangedEventArgs>>(1).Subscribe<IEvent<GeoPositionStatusChangedEventArgs>>(delegate(IEvent<GeoPositionStatusChangedEventArgs>args){if(args.EventArgs.Status==GeoPositionStatus.Ready){RaiseCurrentLocationAvailable(newCurrentLocationAvailableEventArgs(GeoCoordinateWatcher.Position.Location));}...}(b)ComplexCFG#2:Thiscodegeneratesacompiler-generatedfunction<GetCurrentLocation>b3inEventful.Helpers.LocationHelper,whichiscalledwithinGetCurrentLocation(),asdeﬁnedinVenueByGeo.xaml.Figure20:ComplexCFGcases.unprotectedresourceaccessesinmobileapplicationbinaries.Thissectiondiscussespreviousresearchinthreerelatedareas:automatichookplacement,graph-basedanalysisforinformationsecurity,anduserstudiesofconsentdialogs.Automatichookplacement:Anumberofprevi-ousstudiesexaminetheissuesofprotectingsecurity-sensitiveoperationswithauthorizationhooks(e.g.,checkingpermissionsforﬁleoperations).Ganapa-thyetal.[14]useastaticprogramanalysisovertheLinuxkernelsourcecodetoidentifypreviouslyun-speciﬁedsensitiveoperationsandﬁndtherightsetof hooks that need to protect them. AutoISES by
Tan et al. [34] is designed for the similar goal as [14]
but the ways that AutoISES infers access to sensi-
tive data structure are diﬀerent from [14]. Muthuku-
maran et al. [27] focus on server code such as the
X server and postgresql and use their insight con-
cerning object access patterns in order to identify
sensitive operations that require authorization.

In comparison to these eﬀorts, our work begins
with a set of known APIs that access sensitive re-
sources. Such a set is easy to mine from developer
documentation for most mobile operating systems.
In particular, our work focuses on algorithms to ﬁnd
placements that meet the four important conditions
speciﬁc to user prompts on mobile devices, whereas
the previous work concentrates of placement being
safe [14, 34] or safe and not-repetitive [27].
Program dependence
Graph-based analysis:
graphs are used for analyzing information security
of programs in several projects [16, 17, 32]. Program
dependence graphs include both data dependen-
cies and control dependencies whereas the dataﬂow
graphs that we use in this work typically contain
just data dependencies. Hammer et al. [15] con-
sider the enforcement of declassiﬁcation [30] using
program dependence graphs. Recent eﬀorts focus
on automating security-critical decisions for appli-
cation developers [31, 36]. The use of a security type
system for enforcing correctness is another case of co-
operating with the developer to achieve better code
quality and correctness guarantees [29]. Livshits and
Chong [25] address the problem of sanitizer place-
ment through static analysis and partially inspire
our work on consent dialog placement. In our work,
we use a backwards traversal to ﬁnd the closest
valid node to insert a missing prompt. Au et al. [5]
use a similar backward reachability analysis over a
call graph constructed from the Android framework.
However, their goal is to create a mapping between
API calls and permission checks and therefore their
analysis need not consider the four conditions.
Mobile user privacy and consent dialogs: Sev-
eral recent studies have investigated the eﬀectiveness
of existing consent dialogs used on mobile devices at
informing users about which privacy-sensitive data
can be accessed by apps. Felt et al. [12] show that
only 17% of study participants paid attention to the
permissions when installing Android applications.
This ﬁnding may indicate that placing consent di-
alogs at install time (far removed from when the data
is actually being accessed) renders these dialogs in-
eﬀective. On the contrary, a study by Fisher et al.
focus on iPhone users’ responses to runtime consent
dialogs to location access and shows that 85% of

study participants actually denied location requests
for at least one app on their phone [13].

Although orthogonal to our work, previous stud-
ies have explored ways to improve the presentation
of consent dialogs in mobile devices. Lin et al. mea-
sure users’ “expectations” of apps’ access to phone
resources [23]. By highlighting unexpected behav-
iors in the Android permissions interface, the au-
thors show that the new permission interface is more
easily understood and eﬃcient than the existing one.
Felt et al. propose a framework for requesting per-
missions on smartphones [11]. Findings of these
studies can inform a better usable privacy design of a
consent dialog, which our analysis can automatically
insert in mobile apps.

8 Conclusions

In this paper, we have explored the problem of miss-
ing prompts that should guard sensitive resource ac-
cesses. Our core contribution is a graph-theoretic
algorithm for placing such prompts automatically.
The approach balances the execution speed and few
prompts inserted via dominator-based placement
with a comprehensive nature of a more exhaustive
backward analysis.

Overall, our two-prong strategy of dominator-
based and backward placement
in
about 95% of all unique cases. Our approach is
highly scalable; once the application has been
represented in the form of a graph, analysis usually
takes under a second on average.

succeeds

References

[1] Pandora discloses privacy-related US inquiry into phone
http://www.nytimes.com/2011/04/05/technology/

apps.
05pandora.html, April 2011.

[2] Daily report:

Social app makes oﬀ with address
books.
http://bits.blogs.nytimes.com/2012/02/08/daily-
report-social-app-makes-off-with-address-books/, Febru-
ary 2012.

[3] LinkedIn’s

iOS app collects

and transmits names,
emails and notes
in plain text.
http://thenextweb.com/insider/2012/06/06/linkedins-ios-
app-collects-and-sends-names-emails-and-meeting-notes-
from-your-calendar-back-in-plain-text/, June 2012.

from your calendar,

[4] A. V. Aho, M. Lam, R. Sethi, and J. D. Ullman. Compilers:
Principles, Techniques, and Tools. Addison-Wesley, 2007.

[5] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie. Pscout: an-
alyzing the android permission speciﬁcation. In ACM CCS,
2012.

[6] E. Bodden, A. Sewe, J. Sinschek, H. Oueslati, and M. Mezini.
Taming reﬂection: Aiding static analysis in the presence of
reﬂection and custom class loaders. In Software Engineer-
ing (ICSE), 2011 33rd International Conference on, pages
241–250, 2011.

128  22nd USENIX Security Symposium 

USENIX Association

[7] R. B¨ohme and S. K¨opsell. Trained to accept?: a ﬁeld exper-

iment on consent dialogs. In Proceedings of CHI, 2010.

[8] A. S. Christensen, A. Møller, and M. Schwartzbach. Precise
analysis of string expressions. In International Conference
on Static analysis, 2003.

[9] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. PiOS: De-
tecting privacy leaks in iOS applications.
In Proceedings
of the Annual Network and Distributed System Security
Symposium, Feb. 2011.

[10] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. Mc-
Daniel, and A. N. Sheth. TaintDroid: an information-ﬂow
tracking system for realtime privacy monitoring on smart-
phones. In Proceedings of the Usenix Conference on Oper-
ating Systems Design and Implementation, 2010.

[11] A. P. Felt, S. Egelman, M. Finifter, D. Akhawe, and D. Wag-
ner. How to ask for permission. In Proceedings of HotSec,
2012.

[12] A. P. Felt, E. Hay, S. Egelman, A. Haney, E. Chin, and
D. Wagner. Android permissions: User attention, compre-
hension, and behavior. In Proceedings of SOUPS, 2012.

[26] B. Livshits, J. Whaley, and M. S. Lam. Reﬂection analysis
for Java. In Asian Symposium on Programming Languages
and Systems, Nov. 2005.

[27] D. Muthukumaran, T. Jaeger, and V. Ganapathy. Leverag-
ing ”choice” to automate authorization hook placement. In
ACM CCS, 2012.

[28] G. Richards, S. Lebresne, B. Burg, and J. Vitek. An analysis
In ACM

of the dynamic behavior of javascript programs.
Sigplan Notices, volume 45, pages 1–12. ACM, 2010.

[29] W. Robertson and G. Vigna. Static enforcement of Web
application integrity through strong typing. In Proceedings
of the Usenix Security Symposium, Aug. 2009.

[30] A. Sabelfeld and D. Sands. Dimensions and principles of de-
classiﬁcation. In Proceedings of the 18th IEEE Computer
Security Foundations Workshop, pages 255–269. IEEE
Computer Society, June 2005.

[31] M. Samuel, P. Saxena, and D. Song. Context-sensitive auto-
sanitization in web templating languages using type quali-
ﬁers. In Proceedings of the Conference on Computer and
Communications Security, Oct. 2011.

[13] D. Fisher, L. Dorner, and D. Wagner. Short paper: location
privacy: user behavior in the ﬁeld. In Proceedings of SPSM,
2012.

[32] B. Scholz, C. Zhang, and C. Cifuentes. User-input depen-
dence analysis via graph reachability. Technical Report 2008-
171, Sun Microsystems Labs, 2008.

[14] V. Ganapathy, T. Jaeger, and S. Jha. Automatic placement
of authorization hooks in the linux security modules frame-
work. In ACM CCS, 2005.

[15] C. Hammer, J. Krinke, and F. Nodes. Intransitive noninter-
ference in dependence graphs. In 2nd International Sympo-
sium on Leveraging Application of Formal Methods, Veri-
ﬁcation and Validation, Nov. 2006.

[16] C. Hammer, J. Krinke, and G. Snelting. Information ﬂow
control for java based on path conditions in dependence
graphs. In IEEE International Symposium on Secure Soft-
ware Engineering, Mar. 2006.

[17] C. Hammer and G. Snelting.

Flow-sensitive, context-
sensitive, and object-sensitive information ﬂow control based
on program dependence graphs. International Journal of
Information Security, 8(6):399–422, Dec. 2009.

[18] M. Hirzel, D. von Dincklage, A. Diwan, and M. Hind. Fast
online pointer analysis. ACM Trans. Program. Lang. Syst.,
29(2), 2007.

[19] P. Hooimeijer and M. Veanes. An evaluation of automata al-
gorithms for string analysis. In Veriﬁcation, Model Check-
ing, and Abstract Interpretation, pages 248–262. Springer,
2011.

[33] D. Shannon, S. Hajra, A. Lee, D. Zhan, and S. Khur-
shid. Abstracting symbolic execution with string anal-
ysis.
In Testing: Academic and Industrial Conference
Practice and Research Techniques-MUTATION, 2007.
TAICPART-MUTATION 2007, pages 13–22, 2007.

[34] L. Tan, X. Zhang, X. Ma, W. Xiong, and Y. Zhou. Autoises:
Automatically inferring security speciﬁcation and detecting
violations. In USENIX Security Symposium, 2008.

[35] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weis-
man. TAJ: eﬀective taint analysis of Web applications. In
Proceedings of the Conference on Programming Language
Design and Implementation, 2009.

[36] J. Weinberger, P. Saxena, D. Akhawe, M. Finifter, R. Shin,
and D. Song. A systematic analysis of XSS sanitization in
Web application frameworks. In Proceedings of the Euro-
pean Symposium on Research in Computer Security, Sept.
2011.

[20] P.

Internet.

Privacy and data management on mo-
bile devices. http://pewinternet.org/Reports/2012/Mobile-
Privacy.aspx, September 2012.

[21] J. Jung, S. Han, and D. Wetherall. Short paper: Enhancing
mobile application permissions with runtime feedback and
constraints. In Proceedings of SPSM, 2012.

[22] S. Kaplan, B. Livshits, B. Zorn, C. Seifert,

and
”nofus: Automatically detecting” +
C. Curtsinger.
string.fromcharcode(32) + ”obfuscated ”.tolowercase() +
”javascript code”. Technical Report MSR-TR-2011-57, Mi-
crosoft Research, May 2011.

[23] J. Lin, S. Amini, J. Hong, N. Sadeh, J. Lindqvist, and
J. Zhang. Expectation and purpose: Understanding users’
mental models of mobile app privacy through crowdsourcing.
In Proceedings of UbiComp 2012, 2012.

[24] B. Livshits. Dynamic taint tracking in managed runtimes.
Technical Report MSR-TR-2012-114, Microsoft Research,
2012.

[25] B. Livshits and S. Chong. Towards fully automatic place-
ment of security sanitizers and declassiﬁers. In Proceedings
of the Sympolisium on Principles of Programming Lan-
guages (POPL), Jan. 2013.

USENIX Association  

22nd USENIX Security Symposium  129

