Practical Yet Universally Composable Two-Server

Password-Authenticated Secret Sharing

Jan Camenisch
IBM Research – Zurich
jca@zurich.ibm.com

Anna Lysyanskaya

Brown University

anna@cs.brown.edu

Gregory Neven
IBM Research – Zurich
nev@zurich.ibm.com

ABSTRACT
Password-authenticated secret sharing (PASS) schemes, ﬁrst intro-
duced by Bagherzandi et al. at CCS 2011, allow users to distribute
data among several servers so that the data can be recovered using a
single human-memorizable password, but no single server (or even
no collusion of servers up to a certain size) can mount an off-line
dictionary attack on the password or learn anything about the data.
We propose a new, universally composable (UC) security deﬁni-
tion for the two-server case (2PASS) in the public-key setting that
addresses a number of relevant limitations of the previous, non-UC
deﬁnition. For example, our deﬁnition makes no prior assumptions
on the distribution of passwords, preserves security when honest
users mistype their passwords, and guarantees secure composition
with other protocols in spite of the unavoidable non-negligible suc-
cess rate of online dictionary attacks. We further present a concrete
2PASS protocol and prove that it meets our deﬁnition. Given the
strong security guarantees, our protocol is surprisingly efﬁcient: in
its most efﬁcient instantiation under the DDH assumption in the
random-oracle model, it requires fewer than twenty elliptic-curve
exponentiations on the user’s device. We achieve our results by
careful protocol design and by exclusively focusing on the two-
server public-key setting.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Cryptographic control; D.4.6
[Security and Protection]: Authentication

Keywords
Password-authenticated secret sharing, universal composability

1.

INTRODUCTION

Personal computing has long moved beyond the “one computer
on every desk and in every home” to a world where most users own
a plethora of devices, each of which is capable of general computa-
tion but is better suited for a speciﬁc task or environment. However,
keeping personal data synchronized across laptops, mobile phones,

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$10.00.

tablets, portable media players, and other devices is not straight-
forward. Since most of these have some way of connecting to the
Internet, the most obvious solution is to synchronize data “over the
cloud”. Indeed, many services doing exactly this are commercially
available today.

Data synchronization over the cloud poses severe security and
privacy threats, however, as the users’ whole digital lives are at risk
when the cloud host turns out to be malicious or is compromised
by an attack. A ﬁrst solution could be to encrypt the data under a
key that is stored on the user’s devices but is unknown to the cloud
host. This approach has security as well as usability problems: If
one of the devices gets lost or stolen, the owner’s data is again at
risk, and securely (which in some cases means manually) entering
strong cryptographic keys on devices is too tedious for most users.
A much better approach is to protect the data under a secret that
is associated with the human user such as a human-memorizable
password or biometric data. Passwords are still the most prevalent
and easily deployable alternative. Although passwords are inher-
ently vulnerable to dictionary attacks, an important distinction must
be made between online and ofﬂine dictionary attacks. The former
type of attacks, where an attacker simply repeatedly tries to login
to an online server, are easily prevented by blocking the account,
presenting CAPTCHAs, or enforcing time delays after a number of
failed login attempts. Ofﬂine attacks, however, allow the adversary
to test passwords independently and are therefore more dangerous.
With sixteen-character passwords having an estimated 30 bits of
entropy [7] and modern GPUs able to test billions of passwords per
second, security should be considered lost as soon as an ofﬂine at-
tack can be performed. Therefore, to offer any relevant security,
protocols need to be designed such that the correctness of a pass-
word can only be tested by interacting with an online server that
can refuse cooperation after too many failed attempts.

One possibility to safely store password-protected data in the
cloud is to use a password-authenticated key exchange (PAKE) pro-
tocol to establish a secure and authenticated channel with the server
and to send and retrieve the data over this channel. There is a con-
siderable amount of literature on single-server PAKE protocols that
protect against ofﬂine dictionary attacks [5, 24, 25, 3, 29, 14].

It is easy to see, however, that no single-server scheme can pro-
tect against ofﬂine dictionary attacks by a malicious or compro-
mised server. A better approach is to secret-share [36] the data as
well as the information needed to verify the password across multi-
ple servers, and to design the authentication protocol so that no sin-
gle server (or a collusion of servers up to a certain size) learns any-
thing that allows it to perform an ofﬂine dictionary attack. This is
what a password-authenticated secret sharing (PASS) scheme does.
One way to obtain a PASS scheme is by combining a multi-
server PAKE protocol with a secret-sharing scheme so that the user

525ﬁrst establishes secure channels with each of the servers using her
(single) password, and then submits and retrieves the shares over
these channels. Ford and Kaliski [20] were the ﬁrst to propose a
multi-server PAKE protocol in a setting where the user remembers
her password as well as the public keys of n servers, of which n−1
can be compromised. Jablon [27] proposed a similar protocol in the
password-only setting, i.e., where the user cannot remember public
keys. Brainard et al. [6] proposed a dedicated two-server proto-
col in the public-key setting. None of these protocols had formal
security notions or proofs, however.

The ﬁrst provably secure multi-server PAKE protocol, by Mac-
Kenzie et al. [30], is a t-out-of-n protocol supporting t < n ma-
licious servers in the public-key setting. Szydlo and Kaliski [37]
provided security proofs for slight variants of the two-server pro-
tocol by Brainard et al. [6] mentioned earlier. Di Raimondo and
Gennaro [17] proposed the ﬁrst provably secure solution in the
password-only model, which was at the same time the ﬁrst solu-
tion not relying on random oracles [4] in the security proof. Their
protocol tolerates the compromise of t < n/3 out of n servers,
which means that it cannot be used for two servers—probably the
most relevant setting in practice. This gap was ﬁlled by Katz et
al. [28], who presented a dedicated two-server PAKE protocol for
the password-only setting, also without random oracles.

All the solutions mentioned so far are multi-server PAKE pro-
tocols. However, PASS is a simpler primitive than PAKE and so
one can hope to obtain more efﬁcient and easier to analyze PASS
protocols from scratch, rather than from PAKE protocols. Indeed,
Bagherzandi et al. [1] recently introduced the ﬁrst direct PASS
scheme, supporting coalitions of any t < n out of n servers.

Properly deﬁning security of password-based protocols is a del-
icate task. The fact that an adversary can always guess a low-
entropy password in an online attack means that there is an inher-
ent non-negligible probability of adversarial success; security must
therefore be deﬁned as the adversary’s inability to do signiﬁcantly
better than that. The highly distributed setting of multi-user and
multi-server protocols further complicates the models and proofs.
Secure composition is another issue. All provably secure multi-
server protocols mentioned above employ property-based security
notions that cover the protocol when executed in isolation, but fail
to provide guarantees when the protocol is composed with other
protocols and network activity. Composing password-based pro-
tocols is particularly delicate because the composition of several
protocol may amplify the non-negligible adversarial success. Also,
human users are much more likely to leak information about their
passwords in their online activities than they are to leak information
about about their cryptographic keys.

Our Contributions.

We propose the ﬁrst two-server password-authenticated secret
sharing (2PASS) scheme in the public-key setting that is provably
secure in the universal composability (UC) framework [12]. We
show that, when considering static corruptions and the fact that an
adversarial environment necessarily learns whether a protocol suc-
ceeded or failed, our notion implies the only existing 2PASS secu-
rity deﬁnition [1], but that the converse is not true. The UC frame-
work not only guarantees secure composition in arbitrary network
environments, but also, as argued before by Canetti et al. [14] for
the case of single-server PAKE, better addresses many other con-
cerns about property-based deﬁnitions for password-based proto-
cols. For example, all property-based deﬁnitions assume that pass-
words are generated outside of the adversary’s view according to
pre-determined, known, and independent distributions. This does
not reﬂect reality at all: users use the same or related passwords

across different services, they share passwords with other users,
and constantly leak information about their passwords by using
them for other purposes. Rather, our UC security notion follows
that of Canetti et al. [14] in letting the environment dictate the par-
ties’ passwords and password guesses. As a result, this approach
avoids any assumptions on the distribution of passwords, and at the
same time incorporates the non-negligible success of online guess-
ing attacks straight into the model, so that secure protocol compo-
sition is guaranteed through the universal composition theorem. As
another example, our UC deﬁnition allows the adversary to observe
authentication sessions by honest users who attempt passwords that
are related but not equal to their correct passwords. This is a very
common situation that arises every time a user mistypes her pass-
word; previous deﬁnitions fail to model and, consequently, provide
security guarantees in this case.

Our model is also the ﬁrst to explicitly capture throttling mecha-
nisms, i.e., mechanisms to block accounts after a number of failed
authentication attempts, or because a particular server is under at-
tack and deems it prudent to temporarily block an account. As
we’ve seen earlier, throttling is crucial to drive a wedge between
the efﬁciency of online and ofﬂine attacks. Throttling is impossi-
ble for the PASS scheme of Bagherzandi et al. [1] since the servers
do not learn whether the password was correct. The model and
protocol for UC-secure single-server PAKE of Canetti et al. [14]
does not explicitly notify servers about the success or failure of an
authentication attempt, although it is mentioned that such function-
ality can be added with a two-round key-conﬁrmation step. In our
model, honest servers can decide at each invocation whether to go
through with the protocol based on a prompt from the environment.
In summary, we believe that for password-based protocols, UC
security not only gives stronger security guarantees under compo-
sition, but is actually a more natural, more practically relevant, and
less error-prone approach than property-based deﬁnitions. In view
of these strong security guarantees, our protocol is surprisingly ef-
ﬁcient, as we discuss in Section 4. When instantiated based on the
decisional Difﬁe-Hellman assumption in the random-oracle model,
it requires the user to perform eighteen modular exponentiations to
set up her account and nineteen to retrieve her stored secret.

We believe that this is an exciting research area, with challeng-
ing open problems that include strengthening our protocol to with-
stand adaptive corruptions, designing a UC-secure 2PASS scheme
in the password-only (i.e., non-public-key) model, and building
UC-secure protocols for the t-out-of-n case.

2. DEFINITIONS

Although intuitively the security properties we want to capture
seem clear, giving a rigorous deﬁnition for the problem is a chal-
lenging task. Numerous subtleties have to be addressed. For ex-
ample, where does the password come from? Having the user pick
her password at random from a dictionary of a particular size does
not accurately model the way users pick their passwords. Can any
security still be retained if a user is tricked into trying to retrieve
another user’s key with her correct password? Do two users get
any security if their passwords are correlated in some way that is
potentially known to an attacker? Do the servers learn anything
when a user mistypes a password?

We deﬁne the problem by giving an ideal functionality in the
universal-composability (UC) framework [12, 32] that captures all
the intuitive security properties required in this scenario. The ideal
functionality stores a user’s password p and a key K .
(Without
loss of generality, we assume that the only data that users store
on and retrieve from the servers are symmetric encryption keys.
With those, users can always encrypt data of arbitrary length and

526store the resulting ciphertext on an untrusted device or in the cloud.)
It only reveals the user’s key K when presented with the correct
password. It notiﬁes the two servers of all attempts (successful and
unsuccessful) to retrieve the key, and allows the servers to interrupt
the retrieval whenever they deem necessary. As long as one of the
servers is not corrupt, the adversary does not learn anything about
the user’s password or key, unless it can guess her password.

Following the UC framework, we then require that a protocol
must not reveal any more information to an adversary than the ideal
functionality does, no matter what values users use for their pass-
words and keys. This is a very strong deﬁnition of security:
in
particular, a protocol satisfying it is guaranteed to remain secure
even when run concurrently with any other protocols.
2.1 Ideal Functionality

Preliminaries.
A 2PASS scheme operates in a setting with multiple users Ui,
i = 1, . . . , U, multiple servers Sj, j = 1, . . . , S, an adversary A
and the environment E. Users in our protocol are stateless, but each
server Sj maintains an associative array st j[·] containing its local
user directory. The scheme is deﬁned by two interactive protocols
Setup and Retrieve. A user Ui performs the Setup protocol with
two servers of its choice Sj and Sk to store her secret K under
username u and password p. Any user Ui(cid:48), possibly different from
Ui, can recover the secret K by running the Retrieve protocol with
Sj and Sk using the correct username u and password p.

We assume static Byzantine corruptions, meaning that at the be-
ginning of the game the adversary decides which parties, users and
servers alike, are corrupted. From then on, the adversary controls
all corrupted parties and cannot corrupt any other parties. The ideal
functionality “knows” which participants are honest and which ones
are corrupt. Without loss of generality, we assume that there is at
least one corrupt user through which the adversary can make setup
and retrieve queries. Note that since there is no user authentication
other than by passwords, in the real world the adversary can always
generate such queries by inserting fake messages into the network.
While our protocol clearly envisages a setting where multiple
users can create multiple accounts with any combination of servers
of their choice, the UC framework allows us to focus on a single
session only, i.e., for a single user account. Security for multi-
ple sessions follows from the UC composition theorem [12], or if
the different sessions share the same common reference string and
PKI (as one would prefer in practice), from the joint-state universal
composition (JUC) theorem [15].

For the protocol speciﬁcation and security proof, we can there-
fore focus on a single user account u that is established with two
servers S1 and S2. The detailed ideal functionality F2PASS is given
in Figures 1 and 2. The triple sid = (u,S1,S2) is used as the ses-
sion identifer, but multiple simultaneous setup and retrieve queries
by different users may take place within this session. Each setup
and retrieve query within this session has a unique query identiﬁer
qid. (See below for further discussion on session and query iden-
tiﬁers.) For compactness of notation, we will from now on refer to
the functionality F2PASS as F.

We recall that in the UC framework, parties are modeled as in-
teractive Turing machines with two ways of communicating with
other machines: reliable, authentic communication via the input
and subroutine output tapes, and unreliable communication via the
incoming and outgoing communication tapes. The former models
local communication between processes and their subroutines; we
say that one machine provides/obtains input/output to/from another
machine. The latter models network communication; we say that

Functionality F2PASS – Setup

Setup Request: Upon input (Stp, sid, qid, p, K ) from U, check that
sid = (u, S1, S2) for some u ∈ {0, 1}∗ and for some server
identities S1, S2. Also check that query identiﬁer qid is unique.
Create a record (AStp, qid, U , p, K ).
If S1 and S2 are corrupt
then send (Stp, sid, qid, U , p, K ) to the adversary. Otherwise, send
(Stp, sid, qid, U ) to the adversary and record nothing.
Setup Hijack: Upon input (SHjk, sid, qid, ˆp, ˆK ) from the adversary
A for sid = (u, S1, S2), check that a record (AStp, qid, U , p, K )
exists and that query qid has not been marked for any of {S1, S2, A}.
Mark query qid as hjkd for A and replace record (AStp, qid, U , p, K )
with (AStp, qid, U , ˆp, ˆK ).
Setup Result Server: When receiving (Stp, sid, qid, S, s) from the
adversary for sid = (u, S1, S2), for an honest server S ∈ {S1, S2},
and for s ∈ {succ, fail}, check that a record (AStp, qid, ·, ·, ·) ex-
ists. If query qid is already marked succ or fail for S, or if some
other setup query is already marked succ for S, then do nothing. Else,
mark query qid as s for S and output (Stp, sid, qid, s) to S. If now
query qid is marked succ for all honest servers among S1 and S2, then
record (Stp, p, K ).
Setup Result User: When receiving (Stp, sid, qid, U , s) from the
adversary for sid = (u, S1, S2), for an honest user U, and for
s ∈ {succ, fail}, check that a record (AStp, qid, U , ·, ·) exists that
is not yet marked for U. If it is marked succ for all honest servers and
not marked for A, then mark it s for U and output (Stp, sid, qid, s) to
U; else, mark it fail for U and output (Stp, sid, qid, fail) to U.

Figure 1: Ideal functionality for setup of 2PASS protocols.

one machine sends/receives a message to/from another machine.
The environment provides input to and obtains output from the ad-
versary and regular protocol machines, while protocol machines
can provide input to and receive output from their local subroutines.
The adversary can send and receive messages to and from all pro-
tocol machines, modeling that it controls all network trafﬁc. Ideal
functionalities are special protocol machines that are local to all
parties except the adversary, so they interact with regular protocol
machines through their input/output tapes and with the adversary
through their communication tapes.

The ideal functionality maintains state by creating “records” and
by “marking” these records. The state is local to a single instance of
F, i.e., for a single session identiﬁer sid = (u,S1,S2) deﬁning a
single user account. The multi-session functionality keeps separate
state for each user account. The functionality also keeps a two-
dimensional associative array mark [·,·]. When we say that query
qid is marked X for party P, we mean that entry mark [qid ,P] is
assigned the value X.

Clariﬁcation.
Through the Setup Request interface, a user U can initiate the
creation of an account u with servers S1 and S2 to store a secret K
protected with password p. If at least one server is honest, p and
K remain hidden from the adversary; if both servers are corrupt,
F sends K and p to the adversary. Since the environment instructs
users to create accounts and since the adversary controls the net-
work, multiple setup queries may be going on concurrently. The
different queries are distinguished by means of a query identiﬁer
qid that U, S1, and S2 agree on upfront. (See further discussion
below.)

Since agreeing on a query identiﬁer does not mean that a secure
channel has been established, in the real world, the adversary can
always “hijack” the user’s query by intercepting the user’s network
trafﬁc and substituting it with its own. This is modeled by the Setup
Hijack interface, using which the adversary can replace the pass-

527Functionality F2PASS – Retrieve

Retrieve Request: Upon input (Rtr, sid, qid(cid:48), p(cid:48)) from U(cid:48), check
that sid = (u, S1, S2) and that query identiﬁer qid(cid:48) is unique. Create
a record (ARtr, qid(cid:48), U(cid:48), p(cid:48)). If S1 and S2 are both corrupt then send
(Rtr, sid, qid(cid:48), U(cid:48), p(cid:48)) to the adversary, else send (Rtr, sid, qid(cid:48), U(cid:48))
to the adversary.
Retrieve Hijack: Upon input (RHjk, sid, qid(cid:48), ˆp(cid:48)) from the adver-
sary A for sid = (u, S1, S2), check that a record (ARtr, qid(cid:48), U(cid:48), p(cid:48))
exists and that query qid(cid:48) has not been marked for any of {S1, S2, A}.
Mark query qid(cid:48) as hjkd for A and replace record (ARtr, qid(cid:48), U(cid:48), p(cid:48))
with (ARtr, qid(cid:48), U(cid:48), ˆp(cid:48)).
Retrieve Notiﬁcation: When receiving (RNot, sid, qid(cid:48), Si) from
the adversary for sid = (u, S1, S2) and for an honest server
Si ∈ {S1, S2}, check that a record (ARtr, qid(cid:48), ·, ·) exists.
If
there exists a setup query that is marked succ for Si then output
(RNot, sid, qid(cid:48)) to Si. Else, create a record (Perm, qid(cid:48), Si, deny),
output (Rtr, sid, qid(cid:48), fail) to Si, and mark qid(cid:48) as fail for Si.
Retrieve Permission: Upon input (Perm, sid, qid(cid:48), a) from Si ∈
{S1, S2}, where sid = (u, S1, S2) and a ∈ {allow, deny},
check that a record (ARtr, qid(cid:48), ·, ·) exists and that no record
(Perm, qid(cid:48), Si, ·) exists.
Record (Perm, qid(cid:48), Si, a) and send
(Perm, sid, qid(cid:48), Si, a) to the adversary.
If now a record (Perm, qid(cid:48), Si, allow) exists for all honest Si ∈
{S1, S2} and U(cid:48) is honest, then send (Rtr, sid, qid(cid:48), c, K (cid:48)(cid:48)) to the
adversary, where (c, K (cid:48)(cid:48)) ← (correct, K ) if a record (Stp, p, K )
exists, p(cid:48) = p, and either U(cid:48) is corrupt or qid(cid:48) is marked hjkd for
A; where (c, K (cid:48)(cid:48)) ← (correct, ⊥) if a record (Stp, p, ·) exists,
p(cid:48) = p, U(cid:48) is honest, and qid(cid:48) is not marked for A; and where
(c, K (cid:48)(cid:48)) ← (wrong, ⊥) otherwise. If records (Perm, qid(cid:48), Si, allow)
exist for all honest Si ∈ {S1, S2} and U(cid:48) is corrupt, then send
(Rtr, sid, qid(cid:48), c) to the adversary.
Retrieve Result Server: Upon receiving (Rtr, sid, qid(cid:48), Si, a) from
the adversary for sid = (u, S1, S2), for an honest server Si ∈
{S1, S2}, and for a ∈ {allow, deny}, check that records (ARtr,
qid(cid:48), ·, p(cid:48)) and (Perm, qid(cid:48), Si, ai) exist, and that query qid(cid:48) is not
yet marked for Si.
Output (Rtr, sid, qid(cid:48), s) to Si and mark query qid(cid:48) as s for Si,
where s ← succ if a = allow, a record (Stp, p, ·) exists, records
(Perm, qid(cid:48), Sj , allow) exist for all honest Sj ∈ {S1, S2}, and
p(cid:48) = p. Otherwise, s ← fail.
Retrieve Result User: Upon receiving (Rtr, sid, qid(cid:48), U(cid:48), a, K (cid:48))
from the adversary for honest user U(cid:48), where sid = (u, S1, S2),
a ∈ {allow, deny}, and Si ∈ {S1, S2}, check that record (ARtr,
qid(cid:48), U(cid:48), p(cid:48)) exists and that query qid(cid:48) is not yet marked for U(cid:48). Out-
put (Rtr, sid, qid(cid:48), K (cid:48)(cid:48), s(cid:48)(cid:48)) to U(cid:48) and mark query qid(cid:48) as s(cid:48)(cid:48) for U(cid:48)
where (K (cid:48)(cid:48), s(cid:48)(cid:48)) is

• (⊥, fail) if a = deny; else,
• (K (cid:48), succ) if S1 and S2 are corrupt; else,
• (K , succ) if a record (Stp, p, K ) exists, p = p(cid:48), and qid(cid:48) is
marked succ for S1 and S2 and is not marked for A; else,
• (⊥, fail).

Figure 2: Ideal functionality for retrieve of 2PASS protocols.

Functionality FCA

Registration: Upon receiving the ﬁrst message (Register, sid, v)
from party P, send (Registered, sid, v) to the adversary; upon re-
ceiving ok from the adversary, and if sid = P and this is the ﬁrst
request from P, then record the pair (P, v).
Retrieve: Upon receiving a message (Retrieve, sid) from party
P(cid:48), send (Retrieve, sid, P(cid:48)) to the adversary, and wait for an ok
from the adversary. Then, if there is a recorded pair (sid, v) output
(Retrieve, sid, v) to P(cid:48). Otherwise output (Retrieve, sid, ⊥) to
P(cid:48).

Figure 3: Ideal certiﬁcation functionality.

word and key with its own. The user will always output fail after
a query was hijacked, but the servers do not notice the difference
with a regular setup.

The adversary controls when a server or user learns whether the
setup succeeded or failed through the Setup Result Server and Setup
Result User interfaces. Once the adversary lets a setup succeed
for an honest server, this server will refuse all further setups. The
adversary can always make setup transactions fail for a subset of
the participants, but the user will only output that setup succeeded
if all honest servers did so as well and the query was not hijacked.
A user U(cid:48) (possibly different from U) can recover the secret key
K by calling the Retrieve Request interface with a password at-
tempt p(cid:48). If at least one server is honest, then no party learns p(cid:48);
if both are corrupt, then p(cid:48) is sent to the adversary. Similarly to
setup queries, the adversary can hijack the retrieve query through
the Retrieve Hijack interface and replace p(cid:48) with its own ˆp(cid:48).

When the adversary notiﬁes a server of a retrieve request via
the Retrieve Notiﬁcation interface, the server outputs a (RNot, . . .)
message. At this point, the server can apply any external throttling
mechanism to decide whether to participate in this retrieval, e.g.,
by not participating after too many failed attempts. The servers in-
dicate whether they will proceed with the retrieval through the Re-
trieve Permission interface. Only after both servers have allowed
the transaction to proceed does the adversary learn whether the
password was correct and, if the password is correct and either the
user U(cid:48) is corrupt or the query was hijacked, also the key K .

The adversary decides at which moment the results of the re-
trieval are delivered to the parties by invoking the Retrieve Result
Server and Retrieve Result User interfaces. The adversary can al-
ways make a party fail by setting a = deny, even if p(cid:48) = p, but
cannot make the retrieval appear successful if p(cid:48) (cid:54)= p. This reﬂects
the fact that in the real world, the adversary can always tamper
with communication to make a party fail, but cannot force an hon-
est party to succeed, unless he knows the password.
If both servers are corrupt, then the adversary can force the user
to succeed with any key K (cid:48) of the adversary’s choice. If at least one
server is honest, however, then F either sends the real recorded key
K to U(cid:48), or sends it a fail message. The adversary doesn’t learn
anything about p(cid:48) or K , and the user can only obtain K if all honest
servers participated in the retrieval and the password was correct.

2.2 Discussion
On session and query identiﬁers. The UC framework imposes that
the session identiﬁer sid be globally unique. The security proof
considers a single instance of the protocol in isolation, meaning
that in the security proof, all calls to the ideal functionality have the
same sid. For 2PASS protocols, the sid must be (1) the same for
setup and retrieval, so that the ideal functionality can keep state be-
tween these phases, and (2) human-memorizable, so that a human
user can recover her secret key K based solely on information she
can remember. We therefore model sid to consist of a user name u
and the two server identities S1,S2. Together, these uniquely de-
ﬁne a “user account”. To ensure that sid is unique, servers reject
setups for accounts that are taken.

Within a single user account (i.e., a single sid), multiple setup
and retrieve protocol executions may be going on concurrently. To
distinguish the different protocol executions, we let the environ-
ment specify a unique (within this sid) query identiﬁer qid when
the execution is ﬁrst initialized by the user. The qid need not be
human-memorizable, so it can be agreed upon like any session
identiﬁer in the UC framework, e.g., by running an initialization
protocol that implements Finit as deﬁned by Barak et al. [2].

As mentioned above, security for multiple user accounts is ob-

528tained through the JUC theorem [15]. In the multi-session func-
tionality ˆF2PASS, the tuple (u,S1,S2) becomes the sub-session
identiﬁer ssid, whereas the session identiﬁer sid is a unique string
that speciﬁes the “universe” in which the multi-session protocol op-
erates, describing for example which CRS to use and which PKI to
trust. In practice, the sid of the multi-session functionality can be
thought of as hardcoded in the software that users use to set up and
retrieve their accounts, so that human users need not remember it.
Strengthening the deﬁnition. If both servers are corrupt, our ideal
functionality hands the password p, the key K , and all password
attempts p(cid:48) to the adversary. Giving away the passwords and key
“for free” is a somewhat conservative model for the fact that two
corrupt servers can always perform an ofﬂine dictionary attack on
p—a model that, given the low entropy in human-memorizable
passwords and the efﬁciency of brute-force attacks, is actually quite
close to reality. At the same time, it allows for efﬁcient instantia-
tions such as ours that let passwords do what they do best, namely
protect against online attacks. One could further strengthen the
deﬁnition in the spirit of Canetti et al. [14] by merely giving the ad-
versary access to an ofﬂine password testing interface that returns
K only when called with the correct password p. Protocols satis-
fying this stronger notion will have to use a very different and most
likely less efﬁcient approach than ours, but would have the bene-
ﬁt of offering some protection when both servers are corrupt but a
very strong password is used.
Relation to existing notions. The only existing security notion for
2PASS is due to Bagherzandi et al. [1]. In the static corruption case,
if we bear in mind that an adversarial environment will necessarily
learn whether the retrieval succeeded or failed, our ideal function-
ality meets the existing security deﬁnition, so our notion implies
it. The notion of Bagherzandi et al. does not imply ours, however,
because it fails to capture related-password attacks.

To see why this is true, consider the following (contrived) scheme
that satisﬁes Bagerzandi et al.’s deﬁnition but is insecure against a
related-password attack. Take a scheme that is secure under the ex-
isting notion [1]. Consider a modiﬁed scheme where, if the user’s
input password starts with 1, the user sends the password in the
clear to both servers; else, follow the normal protocol. This scheme
still satisﬁes their deﬁnition for the dictionary of passwords start-
ing with 0:
their deﬁnition does not consider the case when the
honest user inputs an incorrect password. It does not satisfy our
deﬁnition, however: suppose the environment directs a user whose
correct password is 0(cid:107)p to perform a retrieve with password 1(cid:107)p.
In the real protocol, a dishonest server involved in the protocol will
see the string 1(cid:107)p. In the ideal world, the ideal functionality hides
an incorrect password from the servers, and so no simulator will be
able to correctly simulate this scenario.
2.3 Setup Assumptions

Our protocol requires two setup assumptions. The ﬁrst is the
availability of a public common reference string (CRS), modeled
by an ideal functionality F D
CRS parameterized with a distribution
D. Upon receiving input (CRS, sid ) from party P, if no value
r is recorded, it chooses and records r ←R D.
It then sends
(CRS, sid , r) to P.

The second is the existence of some form of public-key infras-
tructure where servers can register their public keys and the user
can look up these public keys. The user can thus authenticate the
servers so that she can be sure that she runs the retrieve protocol
with the same servers that she previously ran the setup protocol
with. In other words, we assume the availability of the functional-
ity FCA by Canetti [13] depicted in Figure 3. We will design our
protocol in a hybrid world where parties can make calls to FCA.

3. OUR PROTOCOL

Let GGen be a probabilistic polynomial-time algorithm that on
input security parameter 1k outputs the description of a cyclic group
G, its prime order q, and a generator g.
Let (keyg, enc, dec) be a semantically secure public-key encryp-
tion scheme with message space G; we write c = encpk (m; r)
to denote that c is an encryption of m with public key pk us-
ing randomness r. Our protocol will require this cryptosystem to
(1) have committing ciphertexts, so that it can serve as a commit-
ment scheme; (2) have appropriate homomorphic properties (that
will become clear in the sequel); (3) have an efﬁcient simulation-
sound zero-knowledge proof of knowledge system for proving cer-
tain relations among ciphertexts (which properties are needed will
be clear in the sequel) and for proving correctness of decryption.
The ElGamal cryptosystem satisﬁes all the properties we need.
Let (keygsig, sig, ver) be a signature scheme with message space
{0, 1}∗ secure against adaptive message attacks and let (keyg2,
enc2, dec2) be a CCA2 secure public key encryption scheme with
message space {0, 1}∗ that supports labels. To denote an encryp-
tion of m with public key pk using randomness r with label l ∈
{0, 1}∗ we write c = enc2pk (m; r; l) (if we do not need to refer
to the randomness, we simply write c = enc2pk (m;∗; l)). When
employing these schemes, we assume suitable (implicit) mappings
from (tuples of) elements from G to {0, 1}∗.
3.1 High-Level Idea

The main idea underlying our protocol is similar to the approach
of Brainard et al. [6]: in the setup protocol, the user sends secret
shares of her password and her key to each of the servers. To re-
trieve the shares of her key, the user in the retrieve protocol sends
new secret shares of her password to the servers. These then run
a protocol to determine whether the secrets received in the retrieve
protocol and those in the setup protocol are shares of the same pass-
word. If so, they send the secret shares of the key to the user.

This basic idea is very simple; the challenge in the design of our
protocol is to implement this idea efﬁciently and in a way that can
be proved secure in the UC model. We ﬁrst explain how this is
achieved on a high level and then describe our protocols in detail.
Setup protocol. The servers S1 and S2 receive from the user secret
shares p1 and p2, respectively, of the user’s password p = p1p2,
and, similarly, secret shares K1 and K2 of the user’s symmetric
key K = K1K2. To make sure that during the retrieval a mali-
cious server cannot substitute different values for the password and
key share, S1 additionally receives from the user commitments C2
and ˜C2 of the shares p2 and K2, while S2 is given the opening in-
formation s2, ˜s2 for both commitments. Similarly, S2 receives two
commitments C1 and ˜C1 to the shares p1 and K1, while S1 is given
the corresponding opening information s1, ˜s1. Later, during the re-
trieve protocol, the servers will have to prove that they are behaving
correctly with respect to these commitments.

To create the commitments and to be able to achieve UC security,
we rely on the CRS model by encrypting the values using random-
ness si, ˜si under a public key PK given by the CRS, for which
nobody knows the corresponding decryption key.

To communicate the secret shares and the opening information
to the servers securely, the user will encrypt them under the servers’
public keys (which she looks up via the FCA functionality). This is
not enough, however. To prevent a malicious server from substitut-
ing different values for the password and key share, we make use
of the labels of the CCA2-secure encryption scheme, to bind the
encryptions to the speciﬁc instance of the protocol, in particular to
the commitments C1, ˜C1, C2, and ˜C2. To signal to the user that the
setup has worked, the servers will send her a signed statement.

529i; s(cid:48)

1p(cid:48)

1 and p(cid:48)

2 and gives p(cid:48)

1 and C(cid:48)
2 to p(cid:48)
1 to S1 and s(cid:48)

Retrieve protocol. The user re-shares the password guess p(cid:48) =
2 to servers S1 and S2, respectively. In ad-
p(cid:48)
1p(cid:48)
dition, she gives S1 and S2 commitments C(cid:48)
1 and p(cid:48)
2.
She hands the opening information s(cid:48)
2 for C(cid:48)
1 for C(cid:48)
to S2. The user also generates an ephemeral key pair (PK u, SK u)
2
of a semantically secure encryption scheme and sends the public
key to the servers.
Then, S1 and S2 jointly compute the following randomized two-
party function: on public input (C1, C2, C(cid:48)
2) and with each
server having his password shares and opening information as pri-
vate inputs, output 1 if (1) Ci = enc(pi; si) for i ∈ {1, 2}; (2)
C(cid:48)
i = enc(p(cid:48)
2. Otherwise,
output a random element of the group G. If the output is 1, each
server sends to the user his share of K encrypted under PK u.

i) for i ∈ {1, 2}; (3) p1p2 = p(cid:48)

1, C(cid:48)

1p(cid:48)

Let us explain how this two-party computation is done in a way
that is both efﬁcient and secure in the UC model. As the ﬁrst
idea, consider the following approach: S1 forms a ciphertext E1
1, and sends E1 to S2. S2 uses the
of the group element δ1 = p1/p(cid:48)
homomorphic properties of the underlying cryptosystem to obtain
E = E1 × E2, where E2 is an encryption of δ2 = p(cid:48)
2/p2. Now E
is an encryption of 1 if and only if p(cid:48)
2 = p1p2, i.e., if the user’s
password matches. However, there are three issues: (1) How do S1
and S2 decrypt E? (2) How do we make sure that they don’t learn
anything if the user submitted an incorrect password? (3) How do
we make sure that the servers do not deviate from this protocol?
To address (1), we have S1 generate a temporary public key pk
for which it knows the secret key, and so now the ciphertexts E1,
E2 and E are formed under this temporary public key. This way, S1
will be able to decrypt E when he receives it. To address (2), our
protocol directs S2 to form E somewhat differently; speciﬁcally,
by computing E = (E1 × E2)z for a random z ∈ Zq. Now if
the password the user has submitted was correct, the decryption of
E will still yield 1. However, if it was incorrect, it will be a truly
random element of G. Finally, to address (3), S1 and S2 must prove
to each other, at every step, that the messages they are sending to
each other are computed correctly.

As in the Setup protocol, the user encrypts the secret shares and
the opening information under the server’s public keys (which she
looks up via the FCA functionality). She uses the commitments
C(cid:48)
1, C(cid:48)
2 and the ephemeral public key PK u as a label for these ci-
phertexts. As we will see in the proof of security, owing to the
security properties of labelled CCA2 encryption, if the shares are
correct the servers can safely use PK u to encrypt their shares of
K . To ensure that the servers encrypt and send the correct shares,
they ﬁrst convince each other that their respective encryptions are
consistent with the commitments of the shares received from the
user in the Setup protocols. To inform the user of the encryptions’
correctness, each server sends to the user a signature of both en-
cryptions and the commitments C(cid:48)
2 received just now. Thus a
malicious server will be unable to substitute K with a key different
from what was stored during setup.

1, C(cid:48)

Our retrieve protocol requires the servers to prove to each other
the validity of some statements (essentially that the encryptions
were computed correctly). In the description of the protocol we
denote these protocols as ZK{(w) : predicate(w, y) = 1} for a
proof that a predicate is true w.r.t. to a public value y and a witness
value w. We provide the concrete instantiation of these protocols
and the encryption schemes that we use in Section 4. For now we
only require that the protocols are concurrent zero-knowledge and
simulation-sound proofs. We refer to Section 4 for more details on
how this can be achieved.

We assume the following communication and process behavior.
The servers are listening on some standard port for protocol mes-
sages. As we do not assume secure channels, messages can ar-
rive from anyone. All messages that the parties send to each other
are tagged by (Stp, sid , qid ) or (Rtr, sid , qid ) and by a sequence
number corresponding to the step in the respective protocol. All
other messages received on that port will be dropped. Also dropped
are messages that cannot be parsed according to the format for the
protocol step corresponding to the tag a message carries and mes-
sages which have the same tag as a message that has already been
received. The tags are used to route the message to the different
protocol instances, and are only delivered to a protocol instance in
the order of the sequence number. If they arrive out of sequence, the
messages are buffered until they can be delivered in sequence (and
might be dropped if they cannot be delivered after some timeout).
If a server receives a message with a fresh tag (Stp, sid , qid ) or
(Rtr, sid , qid ), and sequence number 1 (message from the user),
it starts a new instance of the respective protocol, or drops the mes-
sage if such an instance is already running.
3.2.1 The Setup Protocol
All parties have access to the system parameters including the
group G and the public key PK through FCRS . We assume that
each server Si keeps internal persistent storage st i.
The input to U is (Stp, sid , p, K ), where sid = (u,S1,S2),
u is the chosen username, p is the user’s chosen password, and
K the key to be stored. We assume that both p and K are en-
coded as elements of G. Whenever a test fails, the user or server
sends (Stp, sid , qid , fail) to the other parties and aborts with out-
put (Stp, sid , fail). Furthermore, whenever any party receives
a message (Stp, sid , qid ), it aborts with output (Stp, sid , fail).
The structure of the Setup protocol is depicted in Figure 4; the
individual steps are as follows.
Step S1: On input (Stp, sid , qid , p, K ), user U performs the fol-
lowing computations.
(a) Obtain public keys of the servers and CRS: Query FCRS to
receive PK and query FCA with (Retrieve, sid ,S1) and
(Retrieve, sid ,S2) to receive (PE 1, PS 1) and (PE 2, PS 2).
(b) Compute shares of password and key: choose p1 ←R G and

K1 ←R G and compute p2 ← p/p1 and K2 ← K /K1.

3.2 Protocol Details

We assume that the common reference string functionality FCRS
describes a group G of prime order q and generator g generated
through GGen(1k), together with a public key PK of (keyg, enc,
dec) for which the corresponding secret key is unknown. We also
assume the presence of certiﬁed public keys for all servers in the
system through FCA; we do not require users to have such public
keys. More precisely, we assume each server Si to have generated
key pairs (PE i, SE i) and (PS i, SS i) for (keyg2, enc2, dec2) and
(keygsig, sig, ver), respectively, and to have registered the public
keys by calling FCA with (Register,Si, (PE i, PS i)).

(c) Encrypt shares under the CRS and the public keys of the ser-
vers: Choose randomness s1, s2, ˜s1, ˜s2 ←R Zq, encrypt shares
of p and K under the CRS as C1 ← encPK (p1; s1), ˜C1 ←
encPK (K1; ˜s1), C2 ← encPK (p2; s2), and ˜C2 ← encPK (K2;
˜s2), and encrypt shares and randomness under the servers’ pub-
lic keys as F1 ← enc2PE 1 ((p1, K1, s1, ˜s1);∗; (sid , qid , C1,
˜C1, C2, ˜C2)) and F2 ← enc2PE 2 ((p2, K2, s2, ˜s2, );∗; (sid ,
qid , C1, ˜C1, C2, ˜C2)).

(d) Send encryptions to servers: Send (F1, C1, ˜C1, C2, ˜C2) to S1

and (F2, C1, ˜C1, C2, ˜C2) to S2.

530U

(F2, C1, ˜C1, C2, ˜C2)

S1

(F1, C1, ˜C1, C2, ˜C2)

(sid, qid, C1, ˜C1, C2, ˜C2, succ)

sigSS 1


S5

-

S1

S2

S4

S2

-

sigSS 1

(sid, qid, C1, ˜C1, C2, ˜C2)



sigSS 2

sigSS 2

-
(sid, qid, C1, ˜C1, C2, ˜C2, succ)

S3

(sid, qid, C1, ˜C1, C2, ˜C2, succ)

Figure 4: Communication messages of the Setup protocol with computation steps Si.

Step S2: The ﬁrst server S1 proceeds as follows.
(a) Receive message from user and check if fresh instance: Parse
the received message as (Stp, sid , qid , 1, F1, C1, ˜C1, C2, ˜C2).
(b) Obtain public keys of the second server: Query FCA with

(Retrieve, sid ,S2) to receive (PE 2, PS 2).

(c) Decrypt shares and randomnes: Decrypt F1 with label (sid ,

qid , C1, ˜C1, C2, ˜C2), which will fail if the label is wrong.

(d) Verify correct encryption of shares under CRS: Check whether

C1 = encPK (p1; s1) and ˜C1 = encPK (K1; ˜s1).

(e) Verify that this is a new instance: Check that there is no entry

st 1[sid ] in the state.

(f) Inform second server that all checks were successful: Compute
(sid , qid , C1, ˜C1, C2, ˜C2) and send

the signature σ1 ← sigSS 1
it to S2.

Step S3: The second server S2 proceeds as follows.
(a) Receive message from user and ﬁrst server: Parse the message
received from U as (Stp, sid , qid , 1, F2, C1, ˜C1, C2, ˜C2) and
the message from S1 as (Stp, sid , qid , 2, σ1).

(b) Obtain public keys of S1: Send (Retrieve, sid ,S1) to FCA to

obtain (PE 1, PS 1).

(c) Decrypt shares and randomness: Decrypt F2 with label (sid ,

qid , C1, ˜C1, C2, ˜C2), which will fail if the label is wrong.

(d) Verify correct encryption of shares under CRS: Check whether

C2 = encPK (p2; s2) and ˜C2 = encPK (K2; ˜s2).

(e) Verify that this is a new instance: Check that there is no entry

st 2[u] in the state.

(f) Verify ﬁrst server’s conﬁrmation: Check that verPS 1 ((sid , qid ,

C1, ˜C1, C2, ˜C2), σ1) = 1.

(g) Inform user and ﬁrst server of acceptance: Compute signature
(sid , qid , C1, ˜C1, C2, ˜C2, succ) and send τ2 to

τ2 ← sigSS 2
U and S1.

(h) Update state and exit: Update state st 2[sid ] ← (PS 1, p2, K2,

s2, ˜s2, C1, ˜C1, C2, ˜C2) and output (Stp, sid , qid , succ).

Step S4: The ﬁrst server S1 proceeds as follows.
(a) Receive message from second server: Parse the message re-

ceived from S2 as τ2.

(b) Verify second server’s conﬁrmation: Check that verSS 2 ((sid ,

qid , C1, ˜C1, C2, ˜C2, succ), τ2) = 1.

(c) Inform user of acceptance: Compute τ1 ← sigSS 1

C1, ˜C1, C2, ˜C2, succ) and send τ1 to U.

(sid , qid ,

(d) Update state and exit: Update state st 1[sid ] ← (PS 2, p1, K1,

s1, ˜s1, C1, ˜C1, C2, ˜C2) and output (Stp, sid , qid , succ).

Step S5: The user U proceeds as follows.
(a) Receive messages from both servers: Parse the messages re-

ceived from S1 and S2 as as τ1 and τ2, respectively.

(b) Verify that servers accepted and ﬁnalize protocol: Check that
verPS 1 ((sid , qid , C1, ˜C1, C2, ˜C2, succ), τ1) = 1 and that
verPS 2 ((sid , qid , C1, ˜C1, C2, ˜C2, succ), τ2) = 1. If so, out-
put (Stp, sid , qid , succ).

3.2.2 The Retrieve Protocol
The input to U(cid:48) is (Rtr, sid , qid(cid:48), p(cid:48)). The servers S1 and S2
have their respective state information st 1[sid ] and st 2[sid ] as in-
put. The structure of the Retrieve protocol is depicted in Figure 5;
the individual steps are as follows. In all steps, whenever a party
“fails” or any veriﬁcation step fails, the party sends (Rtr, sid , qid(cid:48),
fail) to the other parties and aborts with output (Rtr, sid , qid(cid:48),
fail) in case the party is a server, or with output (Rtr, sid , qid(cid:48),
fail) if it’s a user. Furthermore, whenever any party receives a
message (Rtr, sid , qid(cid:48), fail), it aborts with the same outputs.
Step R1: On input (Rtr, sid , qid(cid:48), p(cid:48)), user U(cid:48) performs the fol-
lowing computations.
(a) Obtain public keys of the servers and CRS: Query FCRS to
receive PK and query FCA with (Retrieve, sid ,S1) and
(Retrieve, sid ,S2) to receive (PE 1, PS 1) and (PE 2, PS 2).
(b) Compute shares of password and choose encryption key pair:
1. Generate (PK u,

1 ←R G and compute p(cid:48)

2 ← p(cid:48)/p(cid:48)

Choose p(cid:48)
SK u) ← keyg(1k).

(c) Encrypt shares under the CRS and the servers’ public keys:
2 ←R Zq and encrypt password shares under the
2). En-
1 ←
2 ←

Choose s(cid:48)
1, s(cid:48)
1 ← encPK (p(cid:48)
CRS as C(cid:48)
crypt the shares and randomness for both servers as F (cid:48)
2, PK u)) and F (cid:48)
1, s(cid:48)
enc2PE 1 ((p(cid:48)
enc2PE 2 ((p(cid:48)
2, s(cid:48)
2, PK u)).
1, C(cid:48)
1, C(cid:48)

2 ← encPK (p(cid:48)
1, C(cid:48)
1, C(cid:48)
(d) Send encryptions to servers: Send (F (cid:48)

1), C(cid:48)
1);∗; (sid , qid(cid:48), C(cid:48)
2);∗; (sid , qid(cid:48), C(cid:48)

2, PK u) to S1

1; s(cid:48)

2; s(cid:48)

and (F (cid:48)

2, C(cid:48)

1, C(cid:48)

2, PK u) to S2.

531U(cid:48)

R1

R7

(F (cid:48)
(F (cid:48)

1, C(cid:48)
2, C(cid:48)

1, C(cid:48)
1, C(cid:48)

2, PK u)

2, PK u)

-

1, ˜C(cid:48)

2, sigSS 1

( ˜C(cid:48)



(sid , qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u, ˜C(cid:48)

1, ˜C(cid:48)

2))

S1

R2

R4

R6

π1, (pk , E1, sigSS 1


π3, π4, ˜C(cid:48)

1



(sid, qid(cid:48), C(cid:48)

1, C(cid:48)
π2, (E, sigSS 2

2, PK u, E1, pk ))
(sid, qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u, E))

S2

-

- R3

(sid, qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u, ˜C(cid:48)

-
π5, ˜C(cid:48)
1, ˜C(cid:48)

2))

2

R5

( ˜C(cid:48)

1, ˜C(cid:48)

2, sigSS 2

Figure 5: Communication messages of the Retrieve protocol with computation steps Ri. In this picture, zero-knowledge proofs are
assumed to be non-interactive and thus denoted simply as sending the value π; however, depending on their instantiation, they might
be interactive protocols.

Step R2: The ﬁrst server S1 proceeds as follows.
(a) Receive message from user, fail if account doesn’t exist: Parse
the message received from U(cid:48) as (Rtr, sid , qid(cid:48), 1, F (cid:48)
1, C(cid:48)
2,
PK u). If no entry st 1[sid ] exists in the state information then
fail, else recover st 1[sid ] = (PS 2, p1, K1, s1, ˜s1, C1, ˜C1, C2,
˜C2).

1, C(cid:48)

(b) Ask environment for permission to continue: Output (RNot,
sid , qid(cid:48)) to the environment and wait for an input (Perm, sid ,
qid(cid:48), a) with a ∈ {allow, deny}. If a = deny then fail.

(c) Decrypt share and randomness: Decrypt F (cid:48)

1 with label (sid ,

qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u), which will fail if the label is wrong.

(d) Verify correct encryption of share under CRS: Check that C(cid:48)

1 =

encPK (p(cid:48)

1; s(cid:48)
1).

(e) Generate key pair for homomorphic encryption scheme and en-
crypt shares’ quotient: Generate (pk , sk ) ← keyg(1k), choose
r1 ←R Zq, and compute E1 ← encpk (p1/p(cid:48)

1; r1).

(f) Send signed encrypted quotient to second server: Compute the
2, PK u, E1, pk ) and

(sid , qid(cid:48), C(cid:48)

1, C(cid:48)

signature σ(cid:48)
send (pk , E1, σ(cid:48)

1 ← sigSS 1
1) to S2.

(g) Prove to second server that E1 is correct: Perform the follow-

ing proof protocol with S2:
π1 := ZK{(p1, p

(cid:48)
1, s1, s

(cid:48)
1, r1) : E1 = encpk (p1/p

∧ C1 = encPK (p1; s1) ∧ C

(cid:48)
1 = encPK (p

1)} .
(cid:48)

(cid:48)
1; r1)
(cid:48)
1; s

Step R3: The second server S2 proceeds as follows.
(a) Receive message from user, fail if account doesn’t exist: Parse
the message received from U(cid:48) as (Rtr, sid , qid(cid:48), 1, F (cid:48)
1, C(cid:48)
2,
PK u). If no entry st 2[sid ] exists in the saved state then fail,
else recover st 2[sid ] = (PS 1, p2, K2, s2, ˜s2, C1, ˜C1, C2, ˜C2).

2, C(cid:48)

(b) Ask environment for permission to continue: Output (RNot,
sid , qid(cid:48)) to the environment and wait for an input (Perm, sid ,
qid(cid:48), a) with a ∈ {allow, deny}. If a = deny then fail.

(c) Receive message from ﬁrst server and check proof: Parse the
1). Further-

message from S1 as (Rtr, sid , qid(cid:48), 2, pk , E1, σ(cid:48)
more interact in the proof π1 with S1.

(d) Decrypt password share and randomness: Decrypt F (cid:48)

2 with la-

bel (sid , qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u) and fail if decryption fails.

(e) Verify share encryption under CRS and ﬁrst server’s signa-
2) and that verPS 1 ((sid ,

2 = encPK (p(cid:48)

ture: Check that C(cid:48)
qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u, E1, pk ), σ(cid:48)

2; s(cid:48)
1) = 1.

(f) Multiply encryption by quotient of own shares: Choose random
2; r2) and E ←

r2, z ←R Zq and compute E2 ← encpk (p2/p(cid:48)
(E1 × E2)z.

(g) Send signed encrypted quotient to ﬁrst server: Compute σ(cid:48)
2) to S1.

2, PK u, E) and send (E, σ(cid:48)

(sid , qid(cid:48), C(cid:48)

1, C(cid:48)

sigSS 2

2 ←

(h) Prove to ﬁrst server that E is correct: Perform with S1 the

proof protocol:

π2 := ZK{(p2, p

(cid:48)
2, s2, s

(cid:48)
2, r2, z) :
E = (E1 × encpk (p
(cid:48)
2/p2; r2))z
∧ C2 = encPK (p2; s2) ∧ C
(cid:48)
2 = encPK (p

(cid:48)
2; s

2)} .
(cid:48)

Step R4: The ﬁrst server S1 proceeds as follows.
(a) Receive message from second server and verify proof: Parse

the message from S2 as (E, σ(cid:48)

2) and interact with S2 in π2.

(b) Verify signature and check z (cid:54)= 0: Verify that verPS 2 ((sid ,

qid(cid:48), C(cid:48)

1, C(cid:48)

2, PK u, E), σ(cid:48)

2) = 1 and that E (cid:54)= encpk (1; 0).

(c) Learn whether password matches: Decrypt E using sk and

verify that it decrypts to 1.

(d) Inform and convince second server of result: Prove to S2 that

E indeed decrypts to 1 with the protocol:

π3 := ZK{(sk ) : 1 = decsk (E)}.

(e) Veriﬁably encrypt key share for the user: Compute ciphertext
1 to S2.
1 encrypts the same key share as ˜C1 from

1 ←R Zq and send ˜C(cid:48)

1 ← encPK u (K1; ˜s(cid:48)
˜C(cid:48)
Prove to S2 that ˜C(cid:48)
the setup phase:

1) with ˜s(cid:48)

1) : ˜C1 = encPK (K1; ˜s1) ∧
π4 := ZK{(K1, ˜s1, ˜s
(cid:48)

1)}.
(cid:48)
(cid:48)
1 = encPK u (K1; ˜s

˜C

Step R5: The second server S2 proceeds as follows.
(a) Receive message from ﬁrst server and verify proof: Parse the
1 and participate in proofs π3 and π4

message from S1 as ˜C(cid:48)
with S1.

532(b) Veriﬁably encrypt key share for the user: Compute ciphertext
2 to S1.
2 encrypts the same key share as ˜C2 from

2 ←R Zq and send ˜C(cid:48)

2 ← encPK u (K2; ˜s(cid:48)
˜C(cid:48)
Prove to S1 that ˜C(cid:48)
the setup phase:

2) with ˜s(cid:48)

π5 := ZK{(K2, ˜s2, ˜s
2) : ˜C2 = encPK (K2; ˜s2) ∧
(cid:48)
2)} .
(cid:48)
(cid:48)
2 = encPK u (K2; ˜s
(c) Send signed result to user and ﬁnish protocol: Compute τ(cid:48)
1, ˜C(cid:48)

1, ˜C(cid:48)
2, PK u, ˜C(cid:48)
sigSS 2
to U(cid:48). Output (Rtr, sid , qid(cid:48), succ).

2) and send ( ˜C(cid:48)

(sid , qid(cid:48), C(cid:48)

1, C(cid:48)

˜C

2 ←
2, ˜τ(cid:48)
2)

Step R6: The ﬁrst server S1 proceeds as follows.
(a) Receive message from second server and verify proofs: Parse

the message from S2 as ˜C(cid:48)

2 and interact with it in π5.

1, C(cid:48)

(sid , qid(cid:48), C(cid:48)

(b) Send signed result to user and ﬁnish protocol: Compute τ(cid:48)
1, ˜C(cid:48)

1, ˜C(cid:48)
2, PK u, ˜C(cid:48)
sigSS 1
to U(cid:48). Output (Rtr, sid , qid(cid:48), succ).
Step R7: The user U(cid:48) proceeds as follows.
(a) Receive messages from both servers: Parse the messages from

2) and send ( ˜C(cid:48)

1 ←
2, τ(cid:48)
1)

S1 and S2 as ( ˜C(cid:48)

1, ˜C(cid:48)

2, τ(cid:48)

1) and ( ˜C(cid:48)

1, ˜C(cid:48)

2, τ(cid:48)

2), respectively.

(b) Check that both servers agree and verify signatures: Check
2) are present in the messages
1, C(cid:48)
2,
2, PK u,

that the same ciphertexts ( ˜C(cid:48)
from the two servers. Verify that verPS 1 ((sid , qid(cid:48), C(cid:48)
1, ˜C(cid:48)
PK u, ˜C(cid:48)
2), τ(cid:48)
2), τ(cid:48)
˜C(cid:48)
1, ˜C(cid:48)
2).

1) and that verPS 2 ((sid , qid(cid:48), C(cid:48)

1, ˜C(cid:48)

1, C(cid:48)

(c) Compute and output key: Compute the two key shares K1 ←
2), reconstruct the key as

decSK u ( ˜C(cid:48)
K ← K1 · K2, and output (Rtr, sid , qid(cid:48), K , succ).

1) and K2 ← decSK u ( ˜C(cid:48)

4. CONCRETE INSTANTIATION

In this section we give constructions of the encryption schemes
and zero-knowledge protocols with which our 2PASS protocol can
be instantiated. They are secure under the decisional Difﬁe-Hell-
man (DDH) assumption; the proofs require the random-oracle mo-
del. For the signature scheme and the CCA2-secure encryption we
propose that the Schnorr [35, 33] and Cramer-Shoup [16] schemes
be used since the DDH assumption also sufﬁces for their security.
We also provide an efﬁciency analysis.
4.1 ElGamal Encryption
The ElGamal encryption scheme [18] assumes a generator g of
a group G = (cid:104)g(cid:105) of prime order q. The secret key x is chosen at
random from Zq. The public key is y = gx. To encrypt a message
m ∈ G, select a random r and compute c1 ← yrm and c2 ←
gr. Output as ciphertext is the tuple (c1, c2). To decrypt (c1, c2),
compute m ← c1/cx
2.

It is well known that the ElGamal encryption scheme is CPA
i.e., E = E1 × E2 is deﬁned as
secure and is homomorphic:
(e1, e2) = (e11, e12) × (e21, e22) := (e11e21, e12e22) and also
we deﬁne Ez = (e1, e2)z = (ez
4.2 Zero-Knowledge Proofs and Σ-Protocols
Using the ElGamal encryption scheme will allow us to instanti-
ate the proof protocols in our scheme by well known and efﬁcient
Σ-protocols for statements about discrete logarithms in the group
G. When referring to the proofs above, use the following nota-
tion [11, 8]. For instance, PK{(a, b, c) : y = gahb ∧ ˜y = gahc}

1, ez

2).

denotes a “zero-knowledge Proof of Knowledge of integers a, b, c
such that y = gahb and ˜y = gahcholds,” where y, g, h, and ˜y are
elements of G. The convention is that the letters in the parenthe-
sis (a, b, c) denote quantities of which knowledge is being proven,
while all other values are known to the veriﬁer.

Given a protocol in this notation, it is straightforward to derive an
actual protocol implementing the proof. Indeed, the computational
complexities of the proof protocol can be easily derived from this
notation: basically for each term y = gahb, the prover and the
veriﬁer have to perform an equivalent computation, and to transmit
one group element and one response value for each exponent. We
refer to, e.g., Camenisch, Kiayias, and Yung [8] for details on this.
The most efﬁcient way to make these protocol concurrent zero-
knowledge and simulation-sound is by the Fiat-Shamir transfor-
mation [19]. In this case, we will have to resort to the random-
oracle model [4] for the security proof. To make the resulting non-
interactive proofs simulation-sound, it sufﬁces to let the prover in-
clude context information as an argument to the random oracle in
the Fiat-Shamir transformation, such as the sid, the qid, the pro-
tocol step in which the statement is being proven, and a collision-
resistant hash of the communication transcript that the prover and
veriﬁer have engaged in so far, so that the proof is resistant to a
man-in-the-middle attack.

We note, however, that there are alternative methods one could
employ instead to make Σ-protocols non-interactive that do not rely
on the random oracle model (e.g., [31, 21, 9]). Unfortunately, these
methods come with some performance penalty. In our protocol that
would impact only the servers, not the user, so should still be very
acceptable in practice.
4.3 Concrete ZK Protocols in Our Scheme

As said in the description of our scheme, we assume that the
description of a group G of prime order q and a generator g chosen
through GGen(1k) is publicly available, together with a public key
PK of the cryptosystem (keyg, enc, dec). In the following we will
further assume that PK = (Y, g) is a public key of the ElGamal
encryption scheme.
Proof π1 in Step R2 of the Retrieve protocol. Suppose that, in Step
R2, S1 has generated (pk , sk ) as ((y = gx, g), x) ∈ ((G, G), Zq ).
Let E1 = (e11, e12) = (p1/p(cid:48)
1yr1 , gr1 ), C1 = (c11, c12) =
1 ) with r1, s1, s(cid:48)
(p1Y s1 , gs1 ), and C(cid:48)
11, c(cid:48)
12) = (p(cid:48)
elements of Zq be the encryptions computed in the setup and re-
trieve protocol. Then the proof π1 can be instantiated with the pro-
tocol speciﬁed as:

1 = (c(cid:48)

1 , gs(cid:48)

1Y s(cid:48)

1

PK{(s1, s

1, r1) : e12 = gr1 ∧ c12 = gs1 ∧ c
(cid:48)

12 = gs(cid:48)
1∧
(cid:48)
−s1} .

= yr1 Y s(cid:48)
1 Y

e11c(cid:48)
c11

11

This protocol requires both the prover and the veriﬁer to compute
four exponentiations in G (note that G can be an elliptic-curve
group).
Let us argue that the protocol indeed proves that E1 encrypts
the quotient of the messages encrypted in C1 and C(cid:48)
1. We know
that if the prover is successful, then there are values (s1, s(cid:48)
1, r1)
1, and e11c(cid:48)
such that e11 = gr1, c11 = gs1, c(cid:48)
=
yr1 Y s(cid:48)
1 Y −s1 hold (see e.g., [8]). As we are using the ElGamal
encryption scheme, the ciphertexts encrypted in E1, C1, and C(cid:48)
1
thus must be e11y−r1, c11Y −s1, and c(cid:48)
1, respectively. The
last term of the proof protocol e11c(cid:48)
1 Y −s1 can be re-
formed into e11y−r1 = (c11Y −s1 )/(c(cid:48)
1 ) which amounts to
the statement that we claimed.

11Y −s(cid:48)
= yr1 Y s(cid:48)
11Y −s(cid:48)

11 = gs(cid:48)

c11

c11

11

11

533Proof π2 in Step R3 of the Retrieve protocol. Let the encryptions
computed in the setup and retrieve protocol be E = (e1, e2) =
((e11yr2 p2/p(cid:48)
2)z, (e12gr2 )z), C2 = (c21, c22) = (p2Y s2 , gs2 ),
2 ∈ Zq.
and C(cid:48)
21, c(cid:48)
2 = (c(cid:48)
Then the proof π2 can be instantiated with the protocol speciﬁed
as:
PK{(s2, s

2 ) with z, r2, s2, s(cid:48)

22) = (p(cid:48)

2 , gs(cid:48)

2Y s(cid:48)

(cid:48)
2, r2, z, α, β, γ) : e2 = ez
22 = gs(cid:48)
(cid:48)
1 = cz

−β ∧ c

22g

−βY γ} .

12gα ∧ c22 = gs2 ∧
−γ ∧
2 ∧ 1 = c
e11c21
c(cid:48)

(cid:48)
22
)zyαY

zg

21

e1 = (

21

22

c(cid:48)

11(m/m(cid:48))zyα.

12gα = gr1z+α and e1 = ez

where by deﬁnition α = zr2 and by proof β = zs2 and γ = zs(cid:48)
2.
Let’s again show that this proof protocol is indeed a proof that E is
an encryption of a random power of the plaintext in E1 (let’s call it
˜m) times the quotient of the plaintexts in C(cid:48)
2 and C2 (let’s call them
m(cid:48) and m, respectively). Again, from the properties of the proof
protocol we know that there exist values s2, s(cid:48)
2, r2, z, α, β, γ so that
the terms in the protocol speciﬁcation hold. Now from c22 = gs2,
22 = gs(cid:48)
2 and 1 = c(cid:48)
zg−γ we can conclude that
22g−β c(cid:48)
1 = cz
β = zs2 and γ = zs(cid:48)
2 holds. Further, the ciphertexts encrypted
21Y −s(cid:48)
in C2, and C(cid:48)
2 thus must be m := c21Y −s2, and m(cid:48) := c(cid:48)
2,
)zyαY −βY γ we
respectively. From the proof term e1 = ( e11c21
can derive that e1 = ez
Also, let r1 be the value such that e12 := gr1 and let ˜m :=
e11y−r1. Thus, e2 = ez
11(m/m(cid:48))zyα
= ˜mzy−r1z(m/m(cid:48))zyα. We can write e1 = ( ˜mm/m(cid:48))zy−r1z+α
which means that E is indeed an encryption of ( ˜mm/m(cid:48))z as we
claimed.
Proof π3 in Step R4 of the Retrieve protocol. The proof π3 show-
ing that the encryption E = (e1, e2) decrypts to 1 (w.r.t. the pub-
lic/secret key pair (pk , sk ) = ((y = gx, g), x) that S1 has gener-
ated in Step R2 of the retrieve protocol) can be implemented with
the following protocol speciﬁcation: PK{(x) : y = gx ∧ e1 =
2} . It is not very hard to see that this protocol indeed shows that
ex
E encrypts to 1.
Proofs π4 and π5 in Steps R4 and R5. The proofs in these two
steps are essentially the same (just the indices are different), so we
describe only the ﬁrst one. Let the encryptions computed in the
setup and retrieve protocol be ˜C1 = (˜c11, ˜c12) = (K1Y ˜s1 , g ˜s1 ),
1 , g ˜s(cid:48)
and ˜C(cid:48)
1 ). Then the proof π4 can be
realized with the protocol speciﬁed as

12) = (K1Y ˜s(cid:48)

1 = (˜c(cid:48)

11, ˜c(cid:48)

12 = g ˜s(cid:48)
1) : ˜c12 = g ˜s1∧˜c
PK{(˜s1, ˜s
(cid:48)
(cid:48)

1∧ ˜c(cid:48)

11
˜c11

= Y ˜s(cid:48)
1 Y

−˜s1} .

It is not hard to see that this protocol indeed proves that the two
ciphertexts encrypt the same plaintext.
4.4 Efﬁciency Analysis

Let us count the number of exponentiations in the group G when
our protocol is instantiated as suggested above and using the Fiat-
Shamir transformation [19] to obtain simulation-sound non-interac-
tive proofs in the random-oracle model. The cost of operations
other than exponentiations is insigniﬁcant in comparison. The user
has to perform 18 exponentiations in the Setup protocol and 19 ex-
ponentiations in the Retrieve protocol. Each server has to do 10
exponentiations in the Setup protocol. In the Retrieve protocol, S1
and S2 need to do 26 and 30 exponentiations, respectively. (Note
that some of the exponentiations by the servers could be optimized
as they are part of multi-base exponentiations.) Finally we note that
an elliptic-curve group can be used for G and that our protocols do

not require secure channels and hence avoid the additional cost of
setting these up.

The communication costs are as follows: the user sends to each
server 16 group elements and receives 1 group element from each
in the Setup protocol. The user sends 11 group elements to and
receives 5 group elements from each server in the Retrieve proto-
col. The servers send to each other 1 group elements in the Setup
protocol and 6 (resp. 5) group elements, 6 (resp. 9) exponents, and
3 (resp. 2) hash values in the Retrieve protocol.

Therefore, our protocol is efﬁcient enough to be useful in prac-

tice.

5. SECURITY ANALYSIS

THEOREM 1. If the encryption scheme (keyg, enc, dec) is se-
mantically secure, the encryption scheme (keyg2, enc2, dec2) is
CCA2 secure, the signature scheme (keygsig, sig, ver) is existen-
tially unforgeable, and the associated proof system is a simulation-
sound concurrent zero-knowledge proof, then our protocols Setup
and Retrieve securely realize F2PASS in the FCA and FCRS -hybrid
model.

When instantiated with the ElGamal encryption scheme [18] for
(keyg, enc, dec), Cramer-Shoup encryption [16] for (keyg2, enc2,
dec2), Schnorr signatures [35, 33] for (keygsig, sig, ver), and the
Σ protocols of Section 4 [35, 8], by the UC composition theorem
and the security of the underlying building blocks we have the fol-
lowing corollary:

COROLLARY 1. Under the decisional Difﬁe-Hellman assump-
tion for the group associated with GGen, the Setup and Retrieve
protocols as instantiated above securely realize F2PASS in the ran-
dom-oracle and FCA-hybrid model.

A detailed proof of Theorem 1 is given in the full version of the
paper [10]; we provide a proof outline here. First, let us conceptu-
ally view all honest participants as a single interactive Turing ma-
chine (ITM) called the challenger, which obtains all inputs from the
environment E intended for honest parties and which outputs the
responses back to E. We deﬁne a series of games with a series of
challengers; the challenger corresponding to game i is denoted Ci.
In the ﬁrst game, C1 receives as input the value sid = (u,S1,S2)
and runs our real protocol on behalf of the honest participants, with
A as the adversary, so the environment receives the same view as it
would in a real execution of the protocol. In the last game, C10 runs
the ideal protocol via the ideal functionality on behalf of the honest
participants, with the simulator SIM as the adversary, so the en-
vironment receives the same view as it would in an ideal execution.
Let view i(sid , 1k) denote the view that E receives when interact-
ing with Ci for session identiﬁer sid and security parameter k; we
will often omit sid and 1k. We brieﬂy describe each challenger Ci
and why each view i is indistinguishable from view i−1; we refer to
the full version [10] for details.
Challenger C1: The challenger runs all honest parties with the
real protocol with all the inputs coming directly from the environ-
ment. Therefore, view 1 is identical to the view that E receives
when honest participants execute our protocol.
Challenger C2: Identical to C1, except that it halts whenever it
receives some values (PS i, m, σ) where PS i is an honest server’s
signature veriﬁcation key and σ is a valid signature under PS i of
the message m, and yet m has never been signed by Si. We have
that view 2 ≈ view 1 by the unforgeability of the signature scheme.
Challenger C3: Identical to C2, except that when an honest user
uses enc2 to send an encryption of a plaintext m to an honest server,

534the ciphertext is computed as an encryption of 1|m|. More con-
cretely, this affects ciphertexts Fi and F (cid:48)
i sent by an honest user to
an honest server Si in Steps S1 and R1.

Let’s call a setup or retrieve query intact if it was initiated by
an honest user and the ﬁrst message (Stp, sid , qid , 1, . . .) or (Rtr,
sid , qid(cid:48), 1, . . .) arrives at an honest server unmodiﬁed. We call
the query hijacked if it was initiated by an honest user but these
messages were modiﬁed in transit, and we call the query corrupt if
it was either hijacked or intiated by a dishonest user. If this query
is intact, then the honest server pretends that the ciphertext Fi or
F (cid:48)
i correctly decrypted to m; otherwise, it decrypts the ciphertext
from the modiﬁed message and proceeds normally. We can show
that view 2 ≈ view 1 by the CCA-2 security of enc2.
Challenger C4: Identical to C3, except that the public key PK in
the CRS is generated such that C4 knows the corresponding secret
key SK . Since PK is distributed exactly as in a real CRS, this hop
is purely conceptual.
Further, C4 runs, on the side, a registry R, that in several ad-
ditional steps will become the ideal functionality F. Whenever
the ﬁrst message of an intact setup query qid is delivered to an
honest server, C4 adds a record (AStp, qid ,U, p, K ) to R. When-
ever the ﬁrst message of a corrupt query is delivered to an hon-
est server, C4 uses the fact that it knows SK to decrypt the ci-
phertexts (C1, ˜C1, C2, ˜C2) to recover p and K .
It then records
(AStp, qid ,U, p, K ) in R. The challenger continues running the
setup protocol, marking qid as succ or fail for a party P when-
ever P outputs succ of fail. If all honest servers output succ, it
records (Stp, qid ,U, p, K ) in R. The existence of the registry R
is internal to C4 and has no effect on view 4.
Challenger C5: Identical to C4, except that, whenever an honest
party performs a zero-knowledge proof, it uses the zero-knowledge
simulator instead of the prover’s algorithm, which results in indis-
tinguishable view by indistinguishability of simulation.
Challenger C6: Identical to C5, except that when the protocol
directs an honest party H to compute c = encPK (m; r) under the
CRS public key PK , where (m, r) will never be sent to a dishonest
party, H instead computes c = encPK (1|m|; r). More concretely,
this change affects the ciphertexts Ci, ˜Ci, C(cid:48)
i that an honest user
sends to an honest server Si in Steps S1 and R1. Whenever the
protocol directs an honest party H(cid:48) to prove something about the
ciphertext c, C6 will, just as C5, have H(cid:48) run the zero-knowledge
simulator for the proof system, instead of the prover, pretending
that c is an encryption of m (as m is known to the challenger).
We have that view 6 ≈ view 5 by semantic security of enc and
simulation-soundness and indistinguishability of simulation of the
ZK proof system.
Challenger C7: Suppose that an honest server S2 is engaged
with a server S1 in a Retrieve attempt for a particular (sid , qid(cid:48)).
C7 differs from C6 in how it computes the ciphertext E in Step R3
and how it forms the ciphertext ˜C(cid:48)
If the current query qid(cid:48) is a corrupt query, then C7 decrypts C(cid:48)
and C(cid:48)
2 using SK to recover p(cid:48); else the environment explicitly pro-
vided p(cid:48) as input to C7 on behalf of the honest user. It then looks
up the record (Stp, p, K ) in its registry R. If p = p(cid:48), then form
E as an encryption of 1; else as an encryption of a random group
element. The proof π2 is executed, as done by all challengers start-
ing with C5, via the simulator. Further, in Step R5, if query qid(cid:48)
is intact, compute the ciphertext ˜C(cid:48)
2 as an encryption of 1|K2|; else
(i.e., if this query is corrupt) compute it correctly as an encryption
of the key share K2 established in the setup phase. The proof π5 is
computed via the zero-knowledge simulator.
To prove that view 7 ≈ view 6, we rely on the simulation-sound-

2 in Step R5.

ness of the proof system and the semantic security of enc.

1 and C(cid:48)

Challenger C8: Suppose that an honest server S1 is engaged
with S2 in a Retrieve attempt for a particular (sid , qid(cid:48)). C8 dif-
fers from C7 in that it computes the ciphertext E1 in Step R2 as
an encryption of 1. If query qid(cid:48) is corrupt, then C8 recovers p(cid:48)
by decrypting C(cid:48)
2; else p(cid:48) is known to it. In Step R4, if
(cid:54)= p, it simply fails; if p(cid:48) = p, the honest server completes
p(cid:48)
the rest of the retrieve protocol as follows: in Step R4 it computes
the ciphertext ˜C(cid:48)
1 correctly if the current query qid(cid:48) is corrupt (so
that the dishonest user controlled by the adversary, upon submitting
the correct password, will learn the correct key share K1), and as
an encryption of 1|K1| otherwise. The proofs π3 and π4 are simu-
lated. Similarly to the previous step, to show that view 7 ≈ view 6,
we rely on the simulation-soundness of the proof system and the
semantic security of enc.

1 and ˜C(cid:48)

Note that at this point, if the user and at least one of the servers is
honest, then the only way in which the protocol messages depend
on the honest user’s input, is on the fact whether the passwords
match (p = p(cid:48)) during the retrieve protocol. If they match and
the query is corrupt, then the ciphertexts ˜C(cid:48)
2 additionally
depend on the stored key K . We still want to make sure that for
honest queries, the user retrieves the correct key or outputs fail if
the passwords match, and outputs fail if they don’t match. This
we will do in the next step.
Challenger C9: Same as C8, except that it halts if one of the
following bad events happens: (1) the event that an honest user
carries out a retrieval with at least one honest server and the correct
password, and at the end of the protocol the user outputs a key K (cid:48)
that is not equal to K stored in the registry R; or (2) the event
that an honest user carries out a retrieval with at least one honest
server and an incorrect password, but successfully ends the retrieval
protocol with some key K (cid:48); or (3) the event that in a corrupt retrieve
query with an incorrect password, an honest server Si encrypts his
key share Ki under PK u.
The fact that view 9 ≈ view 8 is shown by an argument about
the statements proved by the various zero-knowledge proofs.
It
relies on the simulation-soundness of the proof system, as well as
the fact that, for all challengers starting with C2, an honest server’s
signature implies that this server has accepted all preceding proofs.
Challenger C10: In this game, the idea is to give the environment
a view that is identical to view 9, but to have C10 internally run the
full-ﬂedged ideal functionality F, and to have all the honest partic-
ipants run the ideal protocol with F; interaction with the adversary
will now be based solely on what F sends to the ideal-world ad-
versary. To this end, we turn the registry R into the internal book-
keeping of F: F keeps track of what the correct password is, and
at what stage various attempts at setup and retrieve currently are.
Essentially, C10 is now viewed not as a single ITM, but as several
ITMs interacting with each other: one ITM that executes the ideal
functionality F; a “dummy” ITM for each ideal-world honest par-
ticipant that simply relays messages between the environment and
F; and an ITM SIM that talks to F on behalf of the ideal-world
adversary and to A on behalf of the honest participants.
We have already described F and the ideal parties in Section 2.
What remains to do is to describe SIM and to verify that the re-
sulting view 10 is identical to view 9. The description of SIM is
given in detail in the full version of this paper [10]. In a nutshell,
in order to view C9 as consisting of all these different ITMs, we
observe that the protocol messages that the honest parties inside C9
send out only depend on information about the actual password and
key that is provided to the simulator SIM by F.
Although the way that C10 is structured internally is different
from the way C9 is structured (because C9 doesn’t separate its com-
putation steps into those carried out by F, those carried out by

1

535SIM, and those carried out by honest ideal parties), each message
that C10 sends to A and E is computed exactly as in C9, so we have
that view 10 ≈ view 9.

Acknowledgments
We thank Kristiyan Haralambiev, Stas Jarecki, Anja Lehmann, Vic-
tor Shoup, and the anonymous referees for their valuable feedback
and comments on earlier versions of this work. This work was sup-
ported in part by the European Commission through the ICT Pro-
gramme under Contract ICT-2007-216676 ECRYPT II. The ﬁrst
and third authors were supported in part by EC Grant Agreement
257782 ABC4Trust. The second author is supported by the United
States NSF grants 1012060, 0964379, 0831293.

6. REFERENCES
[1] A. Bagherzandi, S. Jarecki, N. Saxena, and Y. Lu.

Password-protected secret sharing. In ACM CCS 2011.

[2] B. Barak, Y. Lindell, and T. Rabin. Protocol initialization for
the framework of universal composability. Cryptology ePrint
Archive, Report 2004/006, 2004.

[3] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated

key exchange secure against dictionary attacks. In
EUROCRYPT 2000.

[4] M. Bellare and P. Rogaway. Random oracles are practical: A
paradigm for designing efﬁcient protocols. In ACM CCS 93.

[5] S. M. Bellovin and M. Merritt. Encrypted key exchange:

Password-based protocols secure against dictionary attacks.
In IEEE Symposium on Security and Privacy 1992.

[6] J. Brainard, A. Juels, B. S. Kaliski Jr., and M. Szydlo. A new
two-server approach for authentication with short secrets. In
USENIX SECURITY 2003.

[7] W. E. Burr, D. F. Dodson, E. M. Newton, R. A. Perlner,

W. T. Polk, S. Gupta, and E. A. Nabbus. Electronic
authentication guideline. NIST Special Publication 800-63-1,
2011.

[8] J. Camenisch, A. Kiayias, and M. Yung. On the portability of

generalized Schnorr proofs. In EUROCRYPT 2009.

[9] J. Camenisch, S. Krenn, and V. Shoup. A framework for

practical universally composable zero-knowledge protocols.
In ASIACRYPT 2011.

[10] J. Camenisch, A. Lysyanskaya, and G. Neven. Practical yet
universally composable two-server password-authenticated
secret sharing. Cryptology ePrint Archive, 2012.

[11] J. Camenisch and M. Stadler. Efﬁcient group signature

schemes for large groups. In CRYPTO ’97.

[12] R. Canetti. Universally composable security: A new

paradigm for cryptographic protocols. In FOCS 2001.

[13] R. Canetti. Universally composable signature, certiﬁcation,
and authentication. In 17th Computer Security Foundations
Workshop, page 219. IEEE Computer Society, 2004.

[14] R. Canetti, S. Halevi, J. Katz, Y. Lindell, and

P. D. MacKenzie. Universally composable password-based
key exchange. In EUROCRYPT 2005.

[15] R. Canetti and T. Rabin. Universal composition with joint

state. In CRYPTO 2003.

[16] R. Cramer and V. Shoup. Design and analysis of practical

public-key encryption schemes secure against adaptive
chosen ciphertext attack. SIAM Journal on Computing,
33(1):167–226, 2003.

[17] M. Di Raimondo and R. Gennaro. Provably secure threshold

password-authenticated key exchange. In
EUROCRYPT 2003.

[18] T. ElGamal. A public key cryptosystem and a signature
scheme based on discrete logarithms. In CRYPTO ’84.
[19] A. Fiat and A. Shamir. How to prove yourself: Practical

solutions to identiﬁcation and signature problems. In
CRYPTO ’86.

[20] W. Ford and B. S. Kaliski Jr. Server-assisted generation of a

strong secret from a password. In IEEE WETICE 2000.

[21] J. A. Garay, P. D. MacKenzie, and K. Yang. Strengthening

zero-knowledge protocols using signatures. In
EUROCRYPT 2003.

[22] S. Goldwasser and S. Micali. Probabilistic encryption.
Journal of Computer and System Sciences, 28(2), 1984.

[23] S. Goldwasser, S. Micali, and R. Rivest. A digital signature

scheme secure against adaptive chosen-message attacks.
SIAM Journal on Computing, 17(2):281–308, 1988.

[24] L. Gong, T. M. A. Lomas, R. M. Needham, and J. H. Saltzer.

Protecting poorly chosen secrets from guessing attacks.
IEEE Journal on Selected Areas in Communications,
11(5):648–656, 1993.

[25] S. Halevi and H. Krawczyk. Public-key cryptography and
password protocols. ACM TISSEC, 2(3):230–268, 1999.

[26] C. Herley, P. C. van Oorschot, and A. S. Patrick. Passwords:
If we’re so smart, why are we still using them? In FC 2009.
[27] D. P. Jablon. Password authentication using multiple servers.

In CT-RSA 2001.

[28] J. Katz, P. D. MacKenzie, G. Taban, and V. D. Gligor.

Two-server password-only authenticated key exchange. In
ACNS 05.

[29] J. Katz, R. Ostrovsky, and M. Yung. Efﬁcient and secure

authenticated key exchange using weak passwords. Journal
of the ACM, 57(1), 2009.

[30] P. D. MacKenzie, T. Shrimpton, and M. Jakobsson.
Threshold password-authenticated key exchange. In
CRYPTO 2002.

[31] P. D. MacKenzie and K. Yang. On simulation-sound trapdoor

commitments. In EUROCRYPT 2004.

[32] B. Pﬁtzmann and M. Waidner. Composition and integrity

preservation of secure reactive systems. In ACM CCS 2000.

[33] D. Pointcheval and J. Stern. Security proofs for signature

schemes. In EUROCRYPT ’96.

[34] C. Rackoff and D. R. Simon. Non-interactive

zero-knowledge proof of knowledge and chosen ciphertext
attack. In CRYPTO ’91.

[35] C. P. Schnorr. Efﬁcient signature generation for smart cards.

Journal of Cryptology, 4(3):239–252, 1991.

[36] A. Shamir. How to share a secret. Communications of the

ACM, 22(11):612–613, Nov. 1979.

[37] M. Szydlo and B. S. Kaliski Jr. Proofs for two-server

password authentication. In CT-RSA 2005.

536