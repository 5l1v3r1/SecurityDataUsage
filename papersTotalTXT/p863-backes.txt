Veriﬁable Delegation of Computation on Outsourced Data

Michael Backes

Saarland University, MPI-SWS

Dario Fiore

MPI-SWS

Saarbrücken, Germany

Saarbrücken, Germany

Raphael M. Reischuk

Saarland University

Saarbrücken, Germany

ABSTRACT
We address the problem in which a client stores a large
amount of data with an untrusted server in such a way that,
at any moment, the client can ask the server to compute
a function on some portion of its outsourced data. In this
scenario, the client must be able to eﬃciently verify the cor-
rectness of the result despite no longer knowing the inputs of
the delegated computation, it must be able to keep adding
elements to its remote storage, and it does not have to ﬁx in
advance (i.e., at data outsourcing time) the functions that
it will delegate. Even more ambitiously, clients should be
able to verify in time independent of the input-size – a very
appealing property for computations over huge amounts of
data.

In this work we propose novel cryptographic techniques
that solve the above problem for the class of computations
of quadratic polynomials over a large number of variables.
This class covers a wide range of signiﬁcant arithmetic com-
putations – notably, many important statistics. To conﬁrm
the eﬃciency of our solution, we show encouraging perfor-
mance results, e.g., correctness proofs have size below 1 kB
and are veriﬁable by clients in less than 10 milliseconds.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
Veriﬁable Delegation of Computation; CloudComputing; Se-
cure Data Outsourcing; Homomorphic MACs; Amortized
Closed-Form Eﬃcient PRF

INTRODUCTION

1.
Given the emergence of cloud computing (an infrastructure
where clients or businesses lease computing and storage re-
sources from powerful service providers), it is of critical im-
portance to provide integrity guarantees for outsourced data

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516681.

management. Consider for example the following scenario.
A client has a collection of a large (potentially unbounded)
amount of data D = D1, D2, D3, . . ., for instance, environ-
mental data such as air pollution levels at ﬁxed time intervals
(e.g., every hour), and it may wish to compute statistics on
such data. If the client’s memory is not large enough to store
the entire data, the client might consider relying on a cloud
service and storing the data on a remote server S. Other
signiﬁcant examples of this scenario include arbitrary ﬁles
at remote storage systems, as well as endless data streams
such as ﬁnancial data (e.g., price ﬁxing data from the stock
markets, ﬁnancial ﬁgures and revenues of companies), exper-
imental data (e.g., genetic data, laboratory measurements),
and further environmental data (e.g., surface weather ob-
servations).
In this scenario, we hence have a client who
incrementally sends D to a server S, the server stores D,
and at certain points in time the client asks S to compute
a function on (a portion of) the currently outsourced data.
We stress that the data D and its size cannot be ﬁxed in ad-
vance as the client may need to add additional data to the
outsourced storage. Analogously, the client might not know
in advance what functions it will apply on the outsourced
data (e.g., it may wish to compute several statistics).

However, if the server is untrusted (i.e., it is malicious or
becomes prey to an external attack), how can the client ver-
ify that the results provided by the server are correct? This
question naturally leads to two important requirements: (1)
security, meaning that the server should be able to “prove”
the correctness of the delegated computation for some func-
tion f ; and (2) eﬃciency, meaning that the client should be
able to check the proof by requiring signiﬁcantly fewer re-
sources than those that are needed to compute f (including
both computation and communication). Furthermore, if we
consider computations over very large sets of inputs (e.g.,
statistics on huge data sets), we want to be more ambitious
and envision the achievement of (3) input-independent eﬃ-
ciency, meaning that verifying the correctness of a compu-
tation f (D1, . . . , Dn) requires time independent of n. More-
over, two further requirements are crucial in this setting: (4)
unbounded storage, meaning that the size of the outsourced
data should not be ﬁxed a-priori, i.e., clients should be able
to outsource any (possibly growing) amount of data; and (5)
function-independence, meaning that a client should be able
to outsource its data without having to know in advance the
functions that it will delegate later.

Relation with Verifiable Computation. The problem
of securely and eﬃciently outsourcing the computation of a
function f to a remote server has been the subject of many

863works in the so-called ﬁeld of veriﬁable computation. Most
of these works achieve the goals of security (1) and eﬃciency
(2), but they inevitably fail in achieving requirements (3)–
(5). Roughly speaking, the issue is that most existing work
requires the client to know (i.e., to store a local copy of) the
input D for the veriﬁcation of the delegated function (e.g.,
in SNARG-based approaches [10, 25] and in signatures of
correct computation [40]), or, otherwise, to send D to the
server all at once (rather than sending it over time) and to
keep a small local state which would not allow to append
additional data at a later time (e.g., in [44, 22]). Perhaps
more critically, many of the existing solutions in this area re-
quire the delegator to run in time proportional to the input
size n of the delegated function, e.g., in time poly(n). In the
various existing protocols, these limitations arise for diﬀer-
ent reasons (see Section 1.1 for a more detailed discussion).
However, even if veriﬁcation in these works is more eﬃcient
than running f , we think that, for computations over huge
data sets, a poly(n) overhead is still unacceptably high.

The only approach that comes close to achieving require-
ments (1)–(5) is the work by Chung et al. on memory delega-
tion [20]. The authors propose a scheme based on techniques
from [29] which exploit the power of the PCP theorem [6].
With this scheme, a client can delegate a broad class of com-
putations over its outsourced memory fulﬁlling the require-
ments from above (except for veriﬁcation eﬃciency, which
requires time log n, instead of constant time). While provid-
ing a satisfying solution in theory, this approach suﬀers from
the usual impracticality issues of general-purpose PCP tech-
niques and hence does not lead to truly practical solutions
to the problem.

In this work, we address the prob-
Our Contribution.
lem of veriﬁable delegation of computations on (growing)
outsourced data. Our main contribution is the ﬁrst practi-
cal protocol that achieves all ﬁve of the requirements stated
before. Namely, a client can (continuously) store a large
amount of data D = D1, D2, D3 . . . with the server, and
then, at certain points in time,
it can request the com-
putation of a function f on (a portion of) the outsourced
data, e.g., v = f (Di1 , . . . , Din ). Using our protocol, the
server sends to the client a short piece of information vouch-
ing for the correctness of v. The protocol achieves input-
independent eﬃciency in the amortized model: after a sin-
gle precomputation with cost |f |, the client can verify every
subsequent evaluation of f in constant time, i.e., regardless
of the input size n. Moreover, fulﬁlling properties (4)–(5),
we have that data outsourcing and function delegation are
completely decoupled, i.e., the client can continuously add
elements to the remote storage, and the delegated functions
do not have to be ﬁxed a priori. This means that the cost
of outsourcing the data can be, in fact, excluded from the
delegation; think for instance of incrementally outsourcing a
large data stream during an entire year, and then computing
statistics on the data at the end of the year.

Our solution works for computations over integers in the
ring Zp (where p is a large prime of roughly 2λ bits, for a
security parameter λ), and supports the evaluation of arith-
metic circuits of degree up to 2. This restricted class of
computations is enough to capture a wide range of signiﬁ-
cant arithmetic computations, such as meaningful statistics,
including counting, summation, (weighted) average, arith-
metic mean, standard deviation, variance, covariance, weighted
variance with constant weights, quadratic mean (aka root-

mean square – RMS), mean squared error (MSE), the Pear-
son product-moment correlation coeﬃcient, the coeﬃcient
of determination (R2), and the least squares ﬁt of a data set
{(xi, vi)}n
i=1 (in the case when the xi are universal constants,
e.g., days of the year)1.

Our key technical contribution is the introduction of ho-
momorphic MACs with eﬃcient veriﬁcation. This crypto-
graphic primitive extends homomorphic message authenti-
cators [27] by adding a crucial eﬃciency property for the
veriﬁcation algorithm. We propose a ﬁrst realization of ho-
momorphic MACs with eﬃcient veriﬁcation (see Section 1.2
for an overview of our techniques), and we prove its secu-
rity under the Decision Linear assumption [11]. Using the
above construction we build an eﬃcient protocol that can
be implemented using bilinear pairings.

To demonstrate the practicality of our solution, we eval-
uate the concrete operations that have to be performed by
the client and the server, as well as the bandwidth overhead
introduced by the protocol for transferring the proofs.
If
we consider 80 bits of security and an implementation of
symmetric pairings [35] on a standard desktop machine, we
observe the following costs (see Table 2 for the 128-bit case):
For outsourcing a data item Di, the client needs to perform
a single modular exponentiation in 0.24ms. This operation
yields a very short authentication tag of size 0.08kB, which
is sent to the server along with Di. For the veriﬁcation of
a computation result v, the client receives a proof σv of size
0.21kB from the server, and can check this proof by com-
puting one pairing and one multi-exponentiation in 1.06ms.
As we mentioned before, we achieve input-independent
eﬃciency in an amortized sense. So, the above veriﬁcation
costs are obtained after the precomputation of some concise
information ωf related to the delegated function f . Pre-
computing ωf takes the same time as computing f (with
almost no additional overhead!), it does not require knowl-
edge of the input data, and ωf can be re-used an unbounded
number of times to verify several evaluations of f on many
diﬀerent outsourced data sets. To generate the proof σv re-
lated to the evaluation of a function f , the server has to
run f with an additional, yet constant, overhead – derived
from replacing additions in f with a group operation, and
replacing multiplications with a pairing. Although our solu-
tion can still not capture general-purpose computations, the
above performance evaluation shows that for our case of in-
terest we achieve results that are encouraging for a practical
deployment of this protocol.

1.1 Related Work
Memory Delegation. The work of Chung et al. [20] on
memory delegation and streaming delegation is the closest
one to the model considered in our work. In memory del-
egation the client uploads his memory to the server (in an
oﬄine phase), and it can later ask the server to update the
outsourced memory and to compute a function f on its entire
memory (in an online phase). In streaming delegation the
memory can be updated only by appending elements. The
main advantages of the work of Chung et al. over our results
are that: (i) the client can change values in the outsourced
memory, (ii) they provide solutions for more expressive com-
putations (i.e., a 4-round protocol for arbitrary poly-time
programs). However, their solutions also suﬀer some disad-

1The least squares ﬁt for this case can indeed be computed
using a linear function [13].

864vantages. First, they require the client to be stateful (in our
solution the client keeps only a ﬁxed secret key). Second, in
streaming delegation, the size N of the stream has to be a-
priori bounded. Such a bound also aﬀects the client’s mem-
ory since it requires a local storage size of approximately
log N at the client, meaning that N cannot be chosen arbi-
trarily long, and thus the stream cannot be endless. Also,
in their solutions, the client still runs in time polylog(n) in
the online phase, where n is the size of the entire memory.

Authenticated Data Structures. A line of research
which addresses a problem closely related to the one consid-
ered in this paper is the existing work on authenticated data
structures [39, 50]. This area considers a setting in which
clients want to securely delegate certain operations on data
structures that are stored at untrusted remote servers. Ex-
isting work addresses both static settings and dynamic set-
tings (where data structures can be updated), and it mostly
focuses on speciﬁc data structure operations, such as range
search queries over databases [31, 36], authenticated dictio-
naries [21, 41, 30], and set operations over a dynamic col-
lection of sets [42]. However, none of the works in this area
considers the secure outsourcing of arbitrary or arithmetic
computations (e.g., statistics) over remotely stored data.

Multi-Function Verifiable Computation. The notion
of multi-function veriﬁable computation proposed by Parno,
Raykova, and Vaikuntanathan [44] is close to our model, in
that a client can delegate the computation of many func-
tions f1, f2, . . . on the same input D, while being able to
eﬃciently verify the results. Even though multi-function
veriﬁable computation does not require the client to ﬁx the
function f before outsourcing the data, this model still falls
short of our requirements. The main problem is that in
multi-function veriﬁable computation, the client has to store
some information τD for every input D on which it will ask
to compute a function fi(D). Furthermore, there is no pos-
sibility of updating τD without locally storing the previous
data. This essentially means that the data D has to be sent
all at once, thus ruling out all applications in the growing
data scenario.

Homomorphic Signatures and MACs. The problem of
realizing homomorphic message authentication schemes in
both the symmetric setting (MACs) and in the asymmet-
ric setting (signatures) has been considered by many prior
works. Homomorphic signatures were ﬁrst proposed by John-
son et al. [32]. However, since then, most works focus solely
on linear functions, mainly because of the important appli-
cation to network coding [12]. Several eﬃcient schemes for
linear functions have been proposed both in the random ora-
cle model [12, 26, 14, 16] and in the standard model [1, 3, 17,
18, 23, 4, 5]. Three more recent works consider the case of
larger classes of functions [13, 27, 15]. Boneh and Freeman
[13] proposed a realization of homomorphic signatures for
bounded constant degree polynomials. Gennaro and Wichs
[27] introduced homomorphic MACs and gave a construc-
tion for arbitrary computations which is proven secure in
a weaker model where the adversary cannot ask veriﬁcation
queries. Catalano and Fiore [15] proposed realizations of ho-
momorphic MACs that, despite capturing a restricted class
of computations (i.e., arithmetic circuits with polynomially-
bounded degree), support veriﬁcation queries and are more
eﬃcient than previous works.

However, virtually all of the above works suﬀer the prob-
lem of having a veriﬁcation algorithm which runs in time
proportional to the function. Gennaro and Wichs [27] dis-
cuss the possibility of verifying a MAC in time better than
executing the function, and propose some general solutions
for their scheme which are based on fully homomorphic en-
cryption and SNARGs [37]. However, neither the proposed
solutions nor the suggested techniques yield schemes that
achieve input-independent eﬃciency, and they do not seem
to lead to practically eﬃcient solutions, at least not as prac-
tical as required in this work.
Succinct Non-Interactive Arguments of Knowledge
(SNARKs). A solution for realizing fully homomorphic sig-
natures would be to use succinct non-interactive arguments
of knowledge (SNARKs) [10]. For a given NP statement, this
primitive allows for producing a succinct argument for prov-
ing knowledge of the corresponding witness. The main ad-
vantage of SNARKs is the succinctness of the argument (i.e.,
its size is independent of the size of both the NP statement
and its witness), which can thus be veriﬁed eﬃciently. How-
ever, SNARKs are not as practically eﬃcient as we might
wish, and require either the random oracle model [37] or non
standard, non-falsiﬁable, assumptions [28].
Verifiable Computation. As we mentioned earlier, the
problem considered by our work and addressed via homo-
morphic authenticators is related to the notion of veriﬁable
computation for which there exits a vast literature, ranging
from works for arbitrary computations [33, 37, 29, 24, 19,
2, 44, 25, 43] to works for speciﬁc classes of computations
[9, 22, 40, 16]. In veriﬁable computation, a client wants to
delegate a computationally heavy task to a remote server
while being able to verify the result in a very eﬃcient way.
As we mentioned before, most of these works suﬀer several
limitations that do not make them appropriate for the model
considered in this paper. For example, many existing solu-
tions require the delegator to run in time proportional to the
input size of the delegated function. This limitation arises
for diﬀerent reasons. For instance, in the deﬁnition proposed
by Gennaro, Gentry, and Parno [24] (and later adopted in
several works, e.g., [19, 9, 44, 22]), to delegate the compu-
tation of f (D), the client has to compute an encoding τD,f
of D, which depends on the function f . However, if we want
to choose f after outsourcing D, the computation of τD,f is
no longer possible. Alternatively, one could keep the entire
input D locally and then compute τD,f from D and f , which
would yield a running time proportional to the input size.
In other work (e.g., [33, 37, 29]) the eﬃciency requirement
for a client is to run in time poly(n, log T ), when delegating
a function f that runs in time T and takes inputs of size n.
Furthermore, as observed by Gennaro and Wichs [27],
even if it is possible to reinterpret some of the results on
veriﬁable computation in the setting of homomorphic mes-
sage authenticators, the resulting solutions are still not ap-
propriate. In particular, they might require a client to send
the data all at once and would not allow for composition of
several authenticated computations. We refer the reader to
[27] for a thorough discussion about this.

Another interesting line of work in this area recently pro-
posed eﬃcient systems for veriﬁable computation [47, 46, 45,
51]. The proposed solutions also work in a model where the
client needs to know the input of the computation, and it
also has to engage in an interactive protocol with the server
in order to verify the results. In contrast, our work consid-

865ers a completely non-interactive setting in which the proof
is transferred from the server to the client in a single round
of communication. In the past there have been proposals of
practical solutions, but of limited provable security: e.g., so-
lutions based on audit (e.g., [38, 8]) or secure co-processors
(e.g., [49, 52]) which prove the computation as correct, un-
der the assumption that the adversary cannot tamper with
the processor. Compared to these results, our work relies
only on standard cryptographic assumptions, and does not
require any trusted hardware.

1.2 A High-Level Overview of Our Techniques
To obtain our solution we build on the notion of homo-
morphic message authenticators proposed by Gennaro and
Wichs [27], a primitive which can be considered the secret-
key equivalent of homomorphic signatures [13]. The basic
idea of homomorphic MACs is that a user can use a se-
cret key to generate a set of tags σ1, . . . , σn authenticating
values D1, . . . , Dn respectively. Then, anyone can homo-
morphically execute a function f over (σ1, . . . , σn) to gen-
erate a short tag σ that authenticates D as the output of
f (D1, . . . , Dn). At ﬁrst glance, homomorphic MACs seem
to perfectly ﬁt the problem of veriﬁable computations on
(growing) outsourced data. However, a closer look at this
primitive reveals that this idea lacks the very important
property of eﬃcient veriﬁcation. As discussed in Section 1.1,
the issue is that in all existing constructions the veriﬁcation
algorithm of homomorphic MACs runs in time proportional
to the description of the function. Our key contribution is
therefore to solve this eﬃciency issue by proposing a deﬁni-
tion and a ﬁrst practical realization of homomorphic MACs
with eﬃcient veriﬁcation.

The starting point for the design of our construction is
the homomorphic MAC scheme of Catalano and Fiore [15]:
to authenticate a value m ∈ Zp, one “encodes” m into a
degree-1 polynomial y ∈ Zp[x] such that y(0) = m and
y(α) = FK (L). Here α ∈ Zp is a secret value randomly
chosen by the client, and FK(·) is a pseudorandom func-
tion that is used to “randomize” a label L. One can think
of a label as arbitrary information (e.g., a string) chosen
by the client to describe the meaning of the authenticated
value m (e.g., “air pollution on 2013/08/14 at 9:06:12”).
Given a set of n authentication polynomials y1, . . . , yn, the
server creates a new MAC y which authenticates (i.e., it
proves) that m is the result of f (m1, . . . , mn), e.g., f could
be the variance of pollution levels at all time instants within
a speciﬁc day/year etc. More speciﬁcally, the basic idea
in [15] is to compute y by homomorphically executing the
function f on the corresponding authentication polynomials,
i.e., y = f (y1, . . . , yn). By the design of the yi, this com-
putation satisﬁes y(0) = f (m1, . . . , mn) and also y(α) =
f (FK (L1), . . . , FK (Ln)). Hence, the client can test whether
a value m′ (proposed by the server) is indeed the result
of a computation f (m1, . . . , mn) by checking whether the
MAC y provided by the server veriﬁes the two conditions:
(i) y(0) = m′ and (ii) y(α) = f (FK (L1), . . . , FK (Ln)).

However, the Catalano-Fiore homomorphic MAC cannot
be adopted in our setting: verifying a MAC for a function f
requires the client to compute W = f (FK (L1), . . . , FK (Ln))
to perform check (ii), but this clearly takes the same time T
as that for computing f — exactly what we want to avoid!
One may then hope that once this value W is computed,
it could be re-used, e.g., to verify other computations in-

volving f . Unfortunately, this would require the re-use of
labels, which is not possible at all:
it is forbidden by the
security deﬁnition used in [15]. More critically, the security
of the Catalano-Fiore MAC completely breaks down in the
presence of label re-use!

In our work, we solve this critical issue with two main
ideas. Very informally, we ﬁrst elaborate a model that allows
us to partially, but safely, re-use labels. Then, we introduce
the construction of a pseudorandom function which allows us
to precompute a piece of label-independent information ωf ,
such that ωf can be re-used to compute W very eﬃciently
(when the labels Li are known).

To allow for a meaningful re-use of labels, we split labels
in two dimensions, thus elaborating a model of multi-labels.
A multi-label L consists of two components (∆, τ ) where ∆
is the data set identiﬁer and τ is the input identiﬁer. A
data set identiﬁer could for instance be “air pollution on
2013/08/14”; and an input identiﬁer could be used to iden-
tify a time, e.g., 9:06:12 am. For the example of the stock
market data, the values could be the stock market prices
for a company C at diﬀerent times T . Then, the data set
identiﬁer could be the name of C while the input identiﬁer
could be the date and time T of the stock market price. The
data set identiﬁer is essentially a way of grouping together
homogeneous data (e.g., data of the same population over
which one wants to compute signiﬁcant statistics) in such a
way that one can compute within a data set ∆.

While a multi-label L = (∆, τ ) can still not be re-used to
authenticate diﬀerent messages, this model does allow us to
assign the same input identiﬁers τ to as many messages as
we need, as long as such messages lie in diﬀerent data sets.
In any case, a re-use of a complete multi-label for authenti-
cation purposes would not make much sense, as multi-labels
are used by clients to “remember” and categorize the out-
sourced data. This transition from labels to multi-labels is
natural: think again of the air pollution levels for a speciﬁc
day. The input identiﬁers capture the hours of a day. Hence,
the input identiﬁers might be re-used for other days, but the
combination of date and time would never be re-used.

The use of multi-labels, however, does not in itself solve
the issue of the ineﬃcient veriﬁcation algorithm: in this case
one still has to compute W = f (FK (∆, τ1), . . . , FK(∆, τn)).
Our key technical tool for achieving eﬃcient veriﬁcation is
the introduction of a pseudorandom function F with a new
property that we call amortized closed-form eﬃciency: if one
precomputes some information ωf related to a program f
with input identiﬁers τ1, . . . , τn, but independent of the data
set ∆, then it is possible to use ωf to compute W , for any
data set ∆, very eﬃciently, e.g., in constant time. Amor-
tized closed-form eﬃciency essentially extends the closed-
form eﬃciency of Benabbas et al. [9] to the setting in which
the same function f is evaluated on many pseudorandom
inputs.2

If we consider the example mentioned before, then one can
precompute the veriﬁcation information ωf for the function
“variance of the air pollution levels at all time instants within
a day” (without knowing the actual data), and then use such

2We notice that the amortized extension was necessary in
our case: while previous works [9, 22] used the PRF to ob-
tain a shorter description of the function f (e.g., by deﬁning
the coeﬃcients of a polynomial in a pseudorandom way),
this is not possible in our case where the description of f
remains arbitrary.

866ωf for verifying the computation of this statistic on any
speciﬁc day (i.e., the data set) in constant time.

We propose an eﬃcient instantiation of amortized closed-
form eﬃcient PRFs whose security is based on standard
PRFs and on the Decision Linear assumption [11], thereby
achieving amortized closed-form eﬃciency in constant time,
i.e., independent of the input size n. Our PRF maps pairs of
binary strings (∆, τ ) to pseudorandom values in a group G
of prime order p. For this technical reason, we changed the
Catalano-Fiore MAC (which works with a PRF mapping to
Zp) so as to encode the MACs y into elements of G, and we
used pairings to “simulate” the ring behavior over Zp for all
those computations that require at most one multiplication,
i.e., arithmetic circuits of degree bounded by 2.

1.3 Organization of the Paper
The paper is organized as follows. In Section 2 we review
notation and basic deﬁnitions.
In Section 3 we introduce
the notions of multi-labeled programs and the deﬁnition of
homomorphic message authenticators with eﬃcient veriﬁca-
tion for multi-labeled programs. Next, Section 4 contains
the description of two technical tools that will be impor-
tant for the design of our new construction of homomorphic
MACs: algorithms for the homomorphic evaluation of arith-
metic circuits, and pseudorandom functions with amortized
closed-form eﬃciency. Finally, in Section 5, we give our con-
struction of homomorphic MACs with eﬃcient veriﬁcation,
we discuss its eﬃciency, and we prove its security.

Due to space constraints, some detailed descriptions and

proofs appear in an extended version of this work [7].

2. PRELIMINARIES
We will denote with λ ∈ N a security parameter. We say
that a function ǫ is negligible if it vanishes faster than the
inverse of any polynomial. If S is a set, x ←R S denotes
the process of selecting x uniformly at random in S. If A is
a probabilistic algorithm, x ←R A(·) denotes the process of
running A on some input and assigning its output to x.

Algebraic Tools. Let G(1λ) be an algorithm that on input
the security parameter 1λ, outputs the description of bilinear
groups bgpp = (p, G, GT , e, g) where G and GT are groups
of the same prime order p > 2λ, g ∈ G is a generator and
e : G × G → GT is an eﬃciently computable bilinear map.
We call such an algorithm G a bilinear group generator.

Informally, an arithmetic circuit
Arithmetic Circuits.
takes input variables X = {τ1 . . . τn} over a ﬁeld F on its
incoming wires, and computes over these inputs using ad-
dition and multiplication gates. For lack of space, we refer
the interested reader to [48] for a useful survey on this sub-
ject. Here we only review some deﬁnitions useful for our
work. Arithmetic circuits evaluate polynomials in the fol-
lowing way. Addition (resp. multiplication) gates compute
the polynomial obtained by the sum (resp. product) of the
two polynomials on their incoming wires. The output of the
circuit is the value returned by its last gate. The degree of
a gate is deﬁned as the total degree of the polynomial com-
puted by that gate. The degree deg(f ) of a circuit f is the
maximal degree of all its gates. In this paper, we restrict our
interest to families of circuits {fλ} over F with deg(fλ) ≤ 2.

3. HOMOMORPHIC MACS WITH

EFFICIENT VERIFICATION

Homomorphic message authenticators were ﬁrst deﬁned by
Gennaro and Wichs [27]. Their deﬁnition was tailored to the
model of labeled programs deﬁned therein. Roughly speak-
ing, a labeled program is a function f (e.g., a circuit) which
takes in n variable inputs such that each of these variables
is assigned a label τ (e.g., a binary string). One may think
of such labeling of variables as a way to give useful names to
the variables of a program. Using this model, homomorphic
message authenticators were deﬁned in [27] in such a way
that a message m is authenticated with respect to a label τ .
Binding m with τ essentially means that the value m can
be assigned to those input variables of a labeled program f
whose label is τ . This, however, imposes a limitation: a la-
bel cannot be re-used for multiple messages, i.e., one cannot
authenticate two diﬀerent messages m, m′ with respect to
the same label τ . This limitation makes perfect sense if one
considers labeling of the data as a way to uniquely “catego-
rize” the data, which is useful, for instance, in cases where
a user outsources her data to a remote server and does not
keep a local copy of the data. However, for the purpose of
labeling programs, the re-use limitation also requires chang-
ing the labeling of the variable inputs of f whenever f is
executed on a diﬀerent set of inputs.

In other words, labels are useful to identify both concrete
data items and variable inputs of programs. The current
deﬁnition of homomorphic MACs, however, focuses more on
a labeling mechanism for data items, instead of capturing
the notion of identifying the program inputs. In the next
section, we bridge this gap by introducing so-called multi-
labels that aim to capture both useful properties of labels:
program variable labeling and data labeling. Thereafter, we
give a deﬁnition of homomorphic MACs for multi-labeled
programs.

3.1 Multi-Labeled Programs
We elaborate a variation of labeled programs that we call
multi-labeled programs. The basic idea behind our model is
to introduce the notion of a multi-label L, which consists of
two parts: a data set identiﬁer ∆ and an input identiﬁer τ .
Input identiﬁers, in isolation, are used to label the variable
inputs of a function f , whereas the combination of both, i.e.,
the full multi-label L = (∆, τ ), is used to uniquely identify a
speciﬁc data item. Precisely, binding a value m with multi-
label (∆, τ ) means that m can be assigned to those input
variables with input identiﬁer τ . The pair (∆, τ ) is necessary
to uniquely identify m. While one can still not re-use a pair
(∆, τ ) for authentication purposes, one can re-use the input
identiﬁer τ , instead.

For the sake of illustration, consider the multi-labeled ap-
proach as a separation of data items into two independent
dimensions. One might think of a database table, e.g., stor-
ing air pollution levels, where some function f : Mn → M
is evaluated over n columns (labeled τ1, . . . , τn). Each such
column could represent a point in time, e.g., 7:05, 07:10,
etc. This computation is performed for each row (labeled
∆i) of the table. Each such row could represent a diﬀerent
day, e.g., 2013/08/14, 2013/08/15, etc. We hence evaluate
f∆i (τ1, . . . , τn) for each row i, hence for each day.

Labeled Programs. First, we review the notion of labeled
programs introduced by Gennaro and Wichs [27]. While

867this notion was given for the case of Boolean circuits f :
{0, 1}n → {0, 1}, here we generalize it to the case of any
function f deﬁned over an appropriate set M. A labeled
program P is deﬁned by a tuple (f, τ1, . . . , τn) where f :
Mn → M is a function on n variables, and each τi ∈ {0, 1}∗
is the label of the i-th variable input of f . Labeled programs
allow for composition as follows. Given labeled programs
P1, . . . , Pt and given a function g : Mt → M, the composed
program P ∗ corresponds to evaluating g on the outputs of
P1, . . . , Pt. The composed program is compactly denoted
as P ∗ = g(P1, . . . , Pt). The labeled inputs of P ∗ are all
distinct labeled inputs of P1, . . . , Pt, i.e., all inputs with the
same label are grouped together in a single input of the new
program. If fid : M → M is the canonical identity function
and τ ∈ {0, 1}∗ is a label, then Iτ = (fid, τ ) denotes the
identity program for input label τ . Notice that any program
P = (f, τ1, . . . , τn) can be expressed as the composition of n
identity programs P = f (Iτ1 , . . . , Iτn ).
Multi-labeled Programs. Intuitively, multi-labeled pro-
grams are an extension of labeled programs in which a la-
beled program P is augmented with a data set identiﬁer ∆.
Formally, we deﬁne a multi-labeled program P∆ as a pair
(P, ∆) where P = (f, τ1, . . . , τn) is a labeled program (as
deﬁned above) and ∆ ∈ {0, 1}∗ is a binary string called
the data set identiﬁer. Multi-labeled programs allow for
composition within the same data set in the most natural
way, i.e., given multi-labeled programs (P1, ∆), . . . , (Pt, ∆)
having the same data set identiﬁer ∆, and given a func-
tion g : Mt → M, the composed multi-labeled program
∆ is the pair (P ∗, ∆) where P ∗ is the composed program
P ∗
g(P1, . . . , Pt), and ∆ is the data set identiﬁer shared by
all the Pi.
If fid : M → M is the canonical identity
function and L = (∆, τ ) ∈ ({0, 1}∗)2 is a multi-label, then
IL = (fid, L) denotes the identity multi-labeled program for
data set ∆ and input label τ . As for labeled programs, any
multi-labeled program P∆ = ((f, τ1, . . . , τn), ∆) can also be
expressed as the composition of n identity multi-labeled pro-
grams: P∆ = f (IL1 , . . . , ILn ) where Li = (∆, τi).

It is worth noting that, in the notation of [27], a multi-
labeled program P∆ = ((f, τ1, . . . , τn), ∆) is essentially a
labeled program (f, L1, . . . , Ln) where each string Li is a
multi-label (∆, τi). The main diﬀerence here is the (explicit)
notion of labeled data sets that we use in order to group
together several inputs, similarly to the deﬁnition used for
homomorphic signatures [13, 23]. This explicit splitting will
turn out to be crucial in order to achieve the desired prop-
erty of eﬃcient veriﬁcation.

3.2 Hom. MACs for Multi-Labeled Programs
We review the notion of homomorphic message authentica-
tors [27, 15]. We have adapted the deﬁnition to our model
of multi-labeled programs as deﬁned in the previous section.

Definition 1.

A homomorphic message authenticator
scheme HomMAC-ML for multi-label programs is a tuple of
algorithms (KeyGen, Auth, Ver, Eval) satisfying four proper-
ties: authentication correctness, evaluation correctness, suc-
cinctness, and security. More precisely:

KeyGen(1λ): given the security parameter λ, the key gener-
ation algorithm outputs a secret key sk and a public evalu-
ation key ek.

Auth(sk, L, m): given the secret key sk, a multi-label L =

(∆, τ ) and a message m ∈ M, it outputs a tag σ.

Ver(sk, P∆, m, σ):

given the secret key sk, a multi-labeled
program P∆ = ((f, τ1, . . . , τn), ∆), a message m ∈ M, and
a tag σ, the veriﬁcation algorithm outputs 0 (reject) or 1
(accept).

Eval(ek, f, ~σ): on input the evaluation key ek, a circuit f :
Mn → M and a vector of tags ~σ = (σ1, . . . , σn), the eval-
uation algorithm outputs a new tag σ.

Authentication Correctness.
Informally speaking, a
homomorphic MAC has authentication correctness if any
tag σ generated by the algorithm Auth(sk, L, m) authenti-
cates m with respect to the identity program IL. More
formally, we say that a scheme HomMAC-ML satisﬁes au-
thentication correctness if for any message m ∈ M, all
keys (sk, ek) ←R KeyGen(1λ), any multi-label L = (∆, τ ) ∈
({0, 1}∗)2, and any tag σ ←R Auth(sk, L, m), we have that
Ver(sk, IL, m, σ) = 1 holds with probability 1.
Evaluation Correctness. This property aims at cap-
turing that if the evaluation algorithm is run on a vector
of tags ~σ = (σ1, . . . , σn) such that each σi authenticates
some message mi as the output of a multi-labeled program
(Pi, ∆), then the tag σ produced by Eval must authenti-
cate f (m1, . . . , mn) as the output of the composed program
(f (P1, . . . , Pn), ∆). More formally, let us ﬁx a pair of keys
(sk, ek) ←R KeyGen(1λ), a function g : Mt → M and any
set of message/program/tag triples {(mi, P∆,i, σi)}t
i=1 such
that all multi-labeled programs P∆,i = (Pi, ∆) (i.e., share
the same data set identiﬁer ∆) and Ver(sk, P∆,i, mi, σi) = 1.
If m∗ = g(m1, . . . , mt), P ∗ = g(P1, . . . , Pt), and σ∗ =
∆, m∗, σ∗) = 1 holds
Eval(ek, g, (σ1, . . . , σt)), then Ver(sk, P ∗
with probability 1.
Succinctness. The size of a tag is bounded by some ﬁxed
polynomial in the security parameter, which is independent
of the number n of inputs taken by the evaluated circuit.
Security. A homomorphic MAC has to satisfy the follow-
ing notion of unforgeability. Let HomMAC-ML be a homo-
morphic MAC scheme as deﬁned above and let A be an
adversary. HomMAC-ML is said to be unforgeable if for ev-
ery PPT adv. A, we have Pr[HomUF−CMAA,HomMAC-ML(λ) =
1] ≤ ǫ(λ) where ǫ(λ) is a negligible function. The experiment
HomUF−CMAA,HomMAC-ML(λ) is the one deﬁned below.

Setup The challenger generates (sk, ek) ←R KeyGen(1λ)

and gives ek to A.

Authentication queries The adversary can adaptively ask
for tags on multi-labels and messages of its choice. Given
a query (L, m) where L = (∆, τ ), the challenger proceeds
as follows: If (L, m) is the ﬁrst query with data set identi-
ﬁer ∆, then the challenger initializes an empty list T∆ = ∅
for data set identiﬁer ∆. If T∆ does not contain a tuple
(τ, ·) (i.e., the multi-label (∆, τ ) was never queried), the
challenger computes σ ←R Auth(sk, L, m), returns σ to A
and updates the list T∆←T∆ ∪ (τ, m). If (τ, m) ∈ T∆ (i.e.,
the query was previously made), then the challenger replies
with the same tag generated before. If T∆ contains a tu-
ple (τ, m′) for some message m′ 6= m, then the challenger
ignores the query.

Veriﬁcation queries The adversary has access to a veriﬁ-
cation oracle as follows: Given a query (P∆, m, σ) from A,
the challenger replies with the output of Ver(sk, P∆, m, σ).

Forgery The adversary terminates the experiment by re-
∆∗ = (P ∗, ∆∗)

∆∗, m∗, σ∗) for some P ∗

turning a forgery (P ∗

868and P ∗ = (f ∗, τ ∗
n). Notice that, equivalently, A
can implicitly return such a tuple as a veriﬁcation query
(P ∗

∆∗, m∗, σ∗) during the experiment.

1 , . . . , τ ∗

Before describing the outcome of this experiment, we re-
view the notion of well-deﬁned programs with respect to a
list T∆ [15]. A labeled program P ∗ = (f ∗, τ ∗
n) is well-
deﬁned with respect to T∆∗ if either one of the following two
cases holds:

1 , . . . , τ ∗

• there exist messages m1, . . . , mn such that the list T∆∗
contains all tuples (τ ∗
Intuitively,
this means that the entire input space of f for data set
∆∗ has been authenticated.

1 , m1), . . . , (τ ∗

n, mn).

• there exist indices i ∈ {1, . . . , n} such that (τ ∗

i , ·) /∈ T∆∗
(i.e., A never asked authentication queries with multi-
label (∆∗, τ ∗
i )), and the function f ∗({mj}(τj ,mj )∈T∆∗ ∪
{ ˜mj}(τj ,·) /∈T∆∗ ) outputs the same value for all possible
choices of ˜mj ∈ M. Intuitively, this case means that the
unauthenticated inputs never contribute to the compu-
tation of f .

To deﬁne the output of the experiment HomUF−CMA, we
∆∗, m∗, σ∗) = 1 and

say it outputs 1 if and only if Ver(sk, P ∗
one of the following conditions holds:

• Type 1 Forgery: no list T∆∗ was created during the game,
i.e., no message m has been authenticated with respect
to a data set identiﬁer ∆∗ during the experiment.

• Type 2 Forgery: P ∗ is well-deﬁned w.r.t. T∆∗ and m∗ 6=
f ∗({mj}(τj ,mj )∈T∆∗ ), i.e., m∗ is not the correct output
of the labeled program P ∗ when executed on previously
authenticated messages (m1, . . . , mn).

• Type 3 Forgery: P ∗ is not well-deﬁned w.r.t. T∆∗ .

Our deﬁnition is obtained by extending the one by Cata-
lano and Fiore [15] to our model of multi-labeled programs.
The resulting deﬁnition is very close to the one proposed
by Freeman for homomorphic signatures [23], with the ex-
ception that we allow for arbitrary labels, and we do not
impose any a-priori ﬁxed bound on the number of elements
in a data set.

In the most general case where f can be any function, it
might not be possible to eﬃciently (i.e., in polynomial time)
check whether a program P is well-deﬁned w.r.t. a list T .
However, for more speciﬁc classes of computations, this is
not an issue. For example, Freeman showed that this is not
a problem for linear functions [23]. In the following propo-
sition (whose proof appears in the full version), we show a
similar result for the classes of computations considered in
our work, i.e., arithmetic circuits deﬁned over the ﬁnite ﬁeld
Zp where p is a prime of roughly λ bits, and whose degree
d is bounded by a polynomial. In particular, we show that
any adversary who wins by producing a Type 3 forgery can
be converted into one who outputs a Type 2 forgery.

Proposition 1. Let λ ∈ N be the security parameter, let
p > 2λ be a prime number, and let {fλ} be a family of arith-
metic circuits over Zp whose degree is bounded by some poly-
nomial d = poly(λ). If for any adversary B producing a Type
2 forgery we have that Pr[HomUF−CMAB,HomMAC-ML(λ) =
1] ≤ ǫ, then for any adversary A producing a Type 3 forgery
it holds Pr[HomUF−CMAA,HomMAC-ML(λ) = 1] ≤ ǫ + d/p.

3.3 Homomorphic MACs with Efﬁcient Veri-

ﬁcation for Multi-Labeled Programs

In this section we introduce a new property for homomor-
phic MACs that we call eﬃcient veriﬁcation.
Informally,
a homomorphic MAC satisﬁes eﬃcient veriﬁcation if it is
possible to verify a tag σ against a multi-labeled program
P∆ = (P, ∆) in less time than that required to compute P.
We deﬁne this eﬃciency property in an amortized sense, so
that the veriﬁcation is more eﬃcient when the same program
P is executed on diﬀerent data sets. The formal deﬁnition
follows.

Definition 2. Let HomMAC-ML = (KeyGen, Auth, Ver,
Eval) be a homomorphic MAC scheme for multi-labeled pro-
grams as deﬁned in the previous section. HomMAC-ML sat-
isﬁes eﬃcient veriﬁcation if there exist two additional algo-
rithms (VerPrep, EﬀVer) as follows:

VerPrep(sk, P): on input the secret key sk and a labeled pro-
gram P = (f, τ1, . . . , τn), this algorithm generates a con-
cise veriﬁcation key VKP . We stress that this veriﬁcation
key does not depend on any data set identiﬁer ∆.

EﬀVer(sk, VKP , ∆, m, σ):

given the secret key sk, a veriﬁ-
cation key VKP , a data set identiﬁer ∆, a message m ∈ M
and a tag σ, the eﬃcient veriﬁcation algorithm outputs 0
(reject) or 1 (accept).

The above algorithms are required to satisfy the following
two properties:
Correctness. Let (sk, ek) ←R KeyGen(1λ) be honestly
generated keys, and (P∆, m, σ) be any program/message/tag
tuple with P∆ = (P, ∆) such that Ver(sk, P∆, m, σ) = 1.
Then, for every VKP ←R VerPrep(sk, P), we have Pr[EﬀVer(sk,
VKP , ∆, m, σ) = 1] = 1.

Amortized Efficiency. Let P∆ = (P, ∆) be a program,
let (m1, . . . , mn) ∈ Mn be any vector of inputs, and let
t(n) be the time required to compute P(m1, . . . , mn).
If
VKP ←VerPrep(sk, P), then the time required for EﬀVer(sk,
VKP , ∆, m, σ) is O(1), i.e., independent of n.

Notice that in our eﬃciency requirement, we do not include
the time needed to compute VKP . The reason is, since VKP
is independent of ∆, the same VKP can be re-used in many
veriﬁcations involving the same labeled program P but many
diﬀerent ∆.
In this sense, the cost of computing VKP is
amortized over many veriﬁcations of the same function on
diﬀerent data sets.

Application to Veriﬁable Computation on Outsourced
Data. A homomorphic MAC scheme with eﬃcient veriﬁ-
cation can be easily used to obtain a protocol for veriﬁable
delegation of computations on outsourced data, satisfying
the requirements (1)–(5) mentioned in Section 1. Below, we
sketch such a protocol between a client C and a server S:

Setup: C generates the keys (sk, ek) ←R KeyGen(1λ) for a

homomorphic MAC, sends ek to S and stores sk.

Data Outsourcing: to outsource a value m, C ﬁrst au-
thenticates m wrt. some multi-label L, i.e., σ ←R Auth(sk,
L, m), and then sends (m, L, σ) to the server. It is easy to
see that this phase satisﬁes the requirements of unbounded
storage (4) and function independence (5).

869Client’s Preparation: assume that C needs to evaluate a
labeled program P = (f, τ1, . . . , τn) on some of its out-
sourced data sets. In this preparation phase (oﬄine), the
client computes and stores VKP ←R VerPrep(sk, P) (inde-
pendently of any ∆).

Delegation: when the client wants to compute P on a data

set ∆ (online), it simply sends (P, ∆) to the server.3

Computation: to compute (P, ∆), where P = (f, τ1, . . . ,
τn), the server ﬁrst looks for the corresponding data (m1,
. . . , mn) and tags (σ1, . . . , σn) according to the labeling
previously sent by C. Next, S computes m = f (m1, . . . , mn)
and σ←Eval(ek, f, σ1, . . . , σn), and sends (m, σ) to C.

Veriﬁcation: given the result (m, σ) sent by S, the client
checks that m is the correct output of the multi-labeled
program (P, ∆) by running EﬀVer(sk, VKP , ∆, m, σ). By
the amortized eﬃciency property of the homomorphic MAC,
we obtain that C achieves amortized input-independent ef-
ﬁciency (3) – and thus also eﬃciency (2) – in verifying the
delegated computations.

Finally, from the unforgeability of the homomorphic MAC,
it is straightforward to see that the server cannot induce the
client to accept incorrect results (1).

4. UTILITIES
This section provides some technical tools that will be use-
ful to obtain our construction of homomorphic MACs with
eﬃcient veriﬁcation.

4.1 Hom. Evaluation of Arithmetic Circuits
In the next two sections, we describe algorithms for the ho-
momorphic evaluation of an arithmetic circuit f : Mn → M
over values deﬁned in some appropriate set J 6= M.
Homomorphic Evaluation over Polynomials. As a
ﬁrst example, we consider the case in which J is a ring
of polynomials. More formally, let Jpoly = Zp[x1, . . . , xm] be
the ring of polynomials in variables x1, . . . , xm over Zp. For
every ﬁxed tuple ~a = (a1, . . . , am) ∈ Zm
p , let φ~a : Jpoly →
Zp be the function deﬁned by φ~a(y) = y(a1, . . . , am) for
any y ∈ Jpoly. By the substitution property of polynomi-
als, φ~a is a homomorphism from Jpoly = Zp[x1, . . . , xm] to
Zp, i.e., ∀y1, y2 ∈ Jpoly it holds: φ~a(y1 + y2) = φ~a(y1) +
φ~a(y2) and φ~a(y1 · y2) = φ~a(y1) · φ~a(y2). By simple in-
duction, we then observe that for a given arithmetic cir-
cuit f : Zn
poly →
Jpoly such that ∀y1, . . . , yn ∈ Jpoly: φ~a( ˆf (y1, . . . , yn)) =
f (φ~a(y1), . . . , φ~a(yn)). The circuit ˆf is basically the same
as f , except that operations in Zp are replaced by the cor-
responding operations in Zp[x1, . . . , xm]. We formally write
the computation of ˆf as the algorithm PolyEval(m, f, y1, . . . ,
yn), for which the following property holds: for any homo-
morphism φ~a deﬁned by ~a = (a1, . . . , am) ∈ Zm
p , and for any
circuit f and any values y1, . . . , yn ∈ Jpoly:

p → Zp, there exists another circuit ˆf : J n

φ~a(PolyEval(m, f, y1, . . . , yn)) = f (φ~a(y1), . . . , φ~a(yn))

We remark that in our work we will use PolyEval only for f
of degree 2, and with m = 1 and m = 2.
3While in general the description of P may be large, here we
assume the case in which P has a succinct description, e.g.,
“daily variance of the air pollution levels at every 5 minutes”.
Hence, the cost of communicating P can, in fact, be ignored.

Homomorphic Evaluation over Bilinear Groups. As
a second example, we show how to homomorphically eval-
uate arithmetic circuits, of degree at most 2, over prime
order groups with bilinear maps. Let bgpp = (p, G, GT , e, g)
be the description of bilinear groups where G has prime or-
If we ﬁx a generator g ∈ G, then G and the ad-
der p.
ditive group (Zp, +) are isomorphic by considering the iso-
morphism φg(x) = gx for every x ∈ Zp. Similarly, by the
property of the pairing function e, we also have that GT
and the additive group (Zp, +) are isomorphic by consider-
ing φgT (x) = e(g, g)x. Since φg and φgT are isomorphisms
there also exist the corresponding inverses φ−1
: G → Zp
and φ−1
gT : GT → Zp, even though these are not known to be
eﬃciently computable.

g

For every arithmetic circuit f : Zn

p → Zp of degree at
most 2, we deﬁne GroupEval(f, X1, . . . , Xn) to be the algo-
rithm which homomorphically evaluates f with inputs in
G and output in GT in such a way that, for every tuple
(X1, . . . , Xn) ∈ Gn, and every such circuit f , we have that

GroupEval(f, X1, . . . , Xn) = e(g, g)f (x1,...,xn)

(1)

holds, where xi = φ−1

g (Xi), ∀i = 1, . . . , n.

Given a circuit f of degree at most 2, and given an n-tuple
of values (X1, . . . , Xn) ∈ Gn, GroupEval intuitively proceeds
as follows. It computes additions by using the group oper-
ation in G or in GT . To compute multiplications, it uses
the pairing function, e.g., R = e(R1, R2), thus “lifting” the
result to the group GT . By our assumption on the degree of
f , one can see that multiplication is well deﬁned. A more
formal description of GroupEval and a proof that it satisﬁes
Equation (1) are given in the full version.

4.2 Pseudorandom Functions with Amortized

Closed-Form Efﬁciency

Here we introduce one of most important technical tools for
our construction, that is the notion of pseudorandom func-
tions with amortized closed-form eﬃciency. This primitive
is an extension of closed-form eﬃcient PRFs proposed by
Benabbas et al. [9], and later reﬁned by Fiore and Gennaro
[22]. As we will show in Section 5, this new notion of PRFs
will be crucial for achieving the property of eﬃcient veriﬁ-
cation in our homomorphic MAC realization.

In a nutshell, closed-form eﬃcient PRFs [9] are deﬁned
like standard PRFs with the additional requirement of sat-
isfying the following eﬃciency property. Assume there exists
a computation Comp(R1, . . . , Rn, ~z) which takes random in-
puts R1, . . . , Rn and arbitrary inputs ~z, and runs in time
t(n, |~z|). Also, think of the case in which each Ri is gener-
ated as FK (Li). Then the PRF F is said to satisfy closed-
form eﬃciency for (Comp, ~L) if, by knowing the seed K, one
can compute Comp(FK(L1), . . . , FK (Ln), ~z) in time strictly
less than t. Here, the key observation is that in the pseudo-
random case all the Ri values have a shorter “closed-form”
representation (as function of K), and this might also allow
for a shorter closed-form representation of the computation.
Starting from the above considerations, we introduce a
new property for PRFs that we call amortized closed-form
eﬃciency. Our basic idea is to address computations Comp(R1,
. . . , Rn, ~z) of the above form, but then consider the case in
which all values Ri are generated as FK (∆, τi). Basically,
we interpret the PRF inputs Li as pairs of values (∆, τi),
all sharing the same ∆ component. Then, we informally
say that F satisﬁes amortized closed-form eﬃciency if it is

870possible to compute ℓ computations {Comp(FK(∆j , τ1), . . . ,
FK (∆j, τn), ~z)}ℓ
j=1 in time strictly less than ℓ · t. More de-
tailed deﬁnitions follow.

A PRF consists of two algorithms (KG, F) such that (1)
the key generation KG takes as input the security parameter
1λ and outputs a secret key K and some public parameters
pp that specify domain X and range R of the function, and
(2) the function FK (x) takes input x ∈ X and uses the secret
key K to compute a value R ∈ R. As usual, a PRF must
satisfy the pseudorandomness property. Namely, we say that
(KG, F) is secure if for every PPT adversary A we have that:

| Pr[AFK (·)(1λ, pp) = 1] − Pr[AΦ(·)(1λ, pp) = 1] | ≤ ǫ(λ)

where ǫ(λ) is negligible, (K, pp) ←R KG(1λ), and Φ : X →
R is a random function.

For any PRF (KG, F) we deﬁne amortized closed-form ef-

ﬁciency as follows.

Definition 3

(Amortized Closed-Form Efficiency).

Consider a computation Comp that takes as input n ran-
dom values R1, . . . , Rn ∈ R and a vector of m arbitrary
values ~z = (z1, . . . , zm), and assume that the computation of
Comp(R1, . . . , Rn, z1, . . . , zm) requires time t(n, m).

Let ~L = (L1, . . . , Ln) be arbitrary values in the domain
X of F such that each can be interpreted as Li = (∆, τi).
We say that a PRF (KG, F) satisﬁes amortized closed-form
eﬃciency for (Comp, ~L) if there exist algorithms CFEvaloﬀ
and CFEvalon

Comp,∆ such that:

Comp, ˜τ

1. Given ω←CFEvaloﬀ

Comp, ˜τ (K, ~z), we have CFEvalon
ω) = Comp(FK(∆, τ1), . . . , FK (∆, τn), z1, . . . , zm)

Comp,∆(K,

2. the running time of CFEvalon

Comp,∆(K, ω) is o(t).

We remark two important facts on our deﬁnition. First,
the computation of ω←CFEvaloﬀ
Comp, ˜τ (K, ~z) does not depend
on ∆, which means that the same value ω can be re-used in
CFEvalon
Comp,∆(K, ω) to compute Comp(FK(∆, τ1), . . . , FK (∆,
τn), ~z) for many diﬀerent ∆. Second, the eﬃciency property
puts a restriction only on the running time of CFEvalon. This
is related to the previous remark, and it captures the idea
of achieving eﬃciency in an amortized sense when consider-
ing many evaluations of Comp(FK (∆, τ1), . . . , FK(∆, τn), ~z),
each with a diﬀerent data set identiﬁer ∆. More concretely,
this means that one can precompute ω once, and then use it
to run CFEvalon as many times as he needs, almost for free.
It is worth noting that the structure of Comp may en-
force some constraints on the range R of the PRF, and
that due to the pseudorandomness property, the output dis-
tribution of CFEvalon
Comp, ˜τ (K, ~z)) (over the
random choice of K) is computationally indistinguishable
from the output distribution of Comp(R1, . . . , Rn, ~z) (over
the random choices of the Ri ∈ R).

Comp,∆(K, CFEvaloﬀ

4.3 A PRF with Amortized Closed-Form Efﬁ-

ciency for GroupEval

We propose an eﬃcient construction of a pseudorandom
function which satisﬁes amortized closed-form eﬃciency for
the algorithm GroupEval, given in Section 4.1.

Our PRF construction uses two generic pseudorandom
functions which map binary strings to integers in Zp (where
p is a suﬃciently large prime number), together with a weak
PRF whose security relies on the Decision Linear assump-
tion, ﬁrst introduced by Boneh, Boyen, and Shacham [11].

Our pseudorandom function. Here we describe our PRF
with amortized closed-form eﬃciency:

KG(1λ). Let bgpp = (p, G, GT , e, g) be a bilinear group de-
scription. The key generation chooses two seeds K1, K2 for
a family of PRFs F′
p. Finally, it outputs
K = (bgpp, K1, K2) and pp = bgpp. The parameters de-
ﬁne a function F with domain X = {0, 1}∗ × {0, 1}∗ and
range G, as described below.

K1,2 : {0, 1}∗ → Z2

FK (x). Let x = (∆, τ ) ∈ X be the input value. To compute
the corresponding output R ∈ G, the algorithm generates
values (u, v)←F′
K2 (∆), and then out-
puts R = gua+vb.

K1 (τ ) and (a, b)←F′

We ﬁrst show that the above function is pseudorandom,
and then we will show that it admits amortized closed-form
eﬃciency for GroupEval.

Theorem 1. If F′ is a pseudorandom function and the
Decision Linear assumption holds for G, then the function
(KG, F) described above is a pseudorandom function.

For lack of space, the proof of Theorem 1 appears only in
the full version of this work. Here we notice that the pseudo-
randomness essentially follows from the security of the PRF
F′, and the fact that R = gua+vb = U aV b = fa,b(U, V ) is a
weak pseudorandom function under the Decision Linear as-
sumption. To prove the weak pseudorandomness of fa,b(·, ·)
we use the random self-reducibility property of the Decision
Linear problem, shown in Lemma 7 in [34].
Amortized Closed-Form Efficiency. Here we show that
the pseudorandom function described before satisﬁes amor-
tized closed-form eﬃciency for (GroupEval, ~L).

CFEvaloﬀ

GroupEval, ˜τ (K, f ). Let K = (bgpp, K1, K2) be a secret
key as generated by KG(1λ). For i = 1 to n, compute
(ui, vi)←F′
K1 (τi), and set ~ρi = (0, ui, vi): ~ρi are essentially
the coeﬃcients of a degree-1 polynomial ρi(z1, z2) in two
(unknown) variables z1, z2.
Next, run ~ρ←PolyEval(2, f, ρ1, . . . , ρn) to compute the co-
eﬃcients ~ρ of a polynomial ρ(z1, z2) such that ∀z1, z2 ∈ Zp
it holds ρ(z1, z2) = f (ρ1(z1, z2), . . . , ρn(z1, z2)).
Finally, output ωf = ~ρ.

CFEvalon

GroupEval,∆(K, ωf ). Let K = (bgpp, K1, K2) be a se-
cret key and let ωf = ~ρ be as computed by the previous
algorithm. The online evaluation algorithm ﬁrst generates
(a, b)←F′
K2 (∆), and then it uses the coeﬃcients ~ρ to com-
pute w = ρ(a, b), and it ﬁnally outputs W = e(g, g)w.

We observe that the complexity of the online algorithm de-
pends on the size of ~ρ, hence on the number of coeﬃcients
of a two-variate polynomial whose degree is the same as
In general, for f of degree d, this would
the degree of f .
be |~ρ| = (cid:0)d+2
d (cid:1). Considering our speciﬁc case of GroupEval
which evaluates arithmetic circuits of degree at most 2, and
by observing that the degree-0 coeﬃcient is always 0, we ob-
tain a vector ~ρ which can be represented with 5 elements of
Zp. Moreover, we observe the interesting fact that, due to
the bound deg(f ) ≤ 2 and due to having only m = 2 vari-
ables, the computation of ~ρ using PolyEval(2, f, ρ1, . . . , ρn)
can be done at roughly the same cost of running f .

It is not hard to check that the above algorithms satisfy
the properties of correctness and amortized eﬃciency given

871in Deﬁnition 3. In particular, correctness follows from the
the correctness properties of PolyEval and GroupEval. A for-
mal proof of this property appears in the full version.

5. HOMOMORPHIC MACS WITH

EFFICIENT VERIFICATION

In this section, we describe our construction of homomorphic
MACs with eﬃcient veriﬁcation for multi-labeled programs
as introduced in Section 3.3.
In particular, the following
theorem summarizes the main result of this work which is
obtained by combining the EVH−MAC construction (see be-
low) and our concrete instantiation of the PRF with amor-
tized closed-form eﬃciency based on the Decision Linear as-
sumption (Section 4.3).

Theorem 2. If the Decision Linear assumption holds, then

EVH−MAC is a secure homomorphic message authentica-
tor which supports evaluations of any arithmetic circuit f
of degree at most 2, and achieves eﬃcient veriﬁcation, i.e.,
EVH−MAC has amortized eﬃciency in which the oﬄine ver-
iﬁcation VerPrep takes time O(|f |), and the online veriﬁca-
tion EﬀVer takes time O(1).

Our construction works for circuits whose additive gates
do not get inputs labeled by constants. As mentioned in [15],
this can be done without loss of generality as one can use an
equivalent circuit with a special variable/label for the con-
stant 1 and publish the MAC of 1. Our scheme EVH−MAC
is deﬁned as follows:

KeyGen(1λ). Run bgpp ←R G(1λ) to generate the descrip-
tion of bilinear groups. Let bgpp = (p, G, GT , e, g) as de-
ﬁned above. Let the message space M be Zp. Choose
a random value α ←R Zp, and run (K, pp) ←R KG(1λ)
to obtain the seed K of a pseudorandom function FK :
{0, 1}∗ × {0, 1}∗ → G. Output the secret key sk = (bgpp,
pp, K, α), and the evaluation key ek = (bgpp, pp).

Auth(sk, L, m). To authenticate a message m ∈ Zp with
multi-label L = (∆, τ ) where ∆ ∈ {0, 1}λ is the identi-
ﬁer of a data set and τ ∈ {0, 1}λ is an input identiﬁer,
proceed as follows. First, compute R←FK(∆, τ ) and then
compute values (y0, Y1) ∈ Zp × G by setting: y0 = m and
Y1 = (R · g−m)1/α. Finally, output the tag σ = (y0, Y1).
If we let y1 ∈ Zp be the (unique) value such that Y1 =
gy1 , then (y0, y1) are basically the coeﬃcients of a degree-
1 polynomial y(x) that evaluates to m on the point 0 (i.e.,
y(0) = m) and it evaluates to r = φ−1
g (R) on a hidden
random point α (i.e., y(α) = r).

p → Zp, and a vector ~σ of tags (σ1, . . . , σn).

Eval(ek, f, ~σ). The homomorphic evaluation algorithm takes
as input the evaluation key ek = (bgpp, pp), an arithmetic
circuit f : Zn
Eval proceeds gate-by-gate as follows. At every gate fg,
given two tags σ1, σ2 (or a tag σ1 and a constant c ∈ Zp),
it runs the algorithm σ←GateEval(ek, fg, σ1, σ2) described
below that returns a new tag σ, which is in turn passed
on as input to the next gate in the circuit. When the
computation reaches the last gate of the circuit f , Eval
outputs the tag vector σ obtained by running GateEval on
such last gate. To complete the description of Eval we thus
describe the subroutine GateEval:
GateEval(ek, fg, σ(1), σ(2)). Let σ(i) = (y(i)
2 ) ∈
Zp × G × GT for i = 1, 2 (see below for the special case

1 , ˆY (i)

0 , Y (i)

2

(1)

· Y (2)

1

1

(1) + y0

(2), Y1 = Y (1)

when one of the two inputs is a constant c ∈ Zp). For
ease of description, whenever ˆY (i)
is not deﬁned, we as-
sume ˆY (i)
2 = 1 ∈ GT . The goal is to compute (y0, Y1, ˆY2)
as follows. For an addition with gate f+, compute y0 =
y0
. For
(2),
a multiplication with gate f× compute y0 = y0
Y1 = (Y (1)
). Be-
cause of our assumption that deg (f ) ≤ 2, we can assume
that σ(i) = (y(i)
1 ) ∈ Zp × G for both i = 1, 2. For a
multiplication with a constant, where one of the two
(1),
inputs, say σ2, is a constant c ∈ Zp, compute y0 = c · y0
Y1 = (Y (1)
)c. Return σ = (y0, Y1, ˆY2).

0 , and ˆY2 = e(Y (1)

)c, and ˆY2 = (Y (1)

, and ˆY2 = ˆY (1)

2
(1) · y0

0 , Y (i)

· (Y (2)

)y

1

, Y (2)

1

(2)
0

)y

1

1

2

· ˆY (2)

2

1

Ver(sk, P∆, m, σ). Let sk = (bgpp, pp, K, α) be a secret key.
Let P∆ = (P, ∆) be a multi-labeled program for P =
(f, τ1, . . . , τn) and data set ∆. Let m ∈ Zp be the re-
sult to be veriﬁed, and let σ = (y0, Y1, ˆY2) be a tag. The
veriﬁcation proceeds as follows. For i = 1 to n, compute
Ri←FK (∆, τi). Then run W ←GroupEval(f, R1, . . . , Rn) ∈
GT , as described in Section 4.1. Finally, check the follow-
ing equations:

m = y0
W = e(g, g)y0 · e(Y1, g)α · ( ˆY2)α2

(2)

(3)

If both checks are satisﬁed, then output 1, and 0 otherwise.

Finally, to complete the description of EVH−MAC we give
the algorithms for eﬃcient veriﬁcation:

VerPrep(sk, P). Let P = (f, ~τ ) be a labeled program where
f ∈ Zn
p → Zp is an arithmetic circuit and ~τ = (τ1, . . . , τn)
is a vector of input identiﬁers for f . The algorithm com-
putes concise veriﬁcation information VKP = ω where ω is
obtained by using the oﬄine closed-form eﬃcient algorithm
of F for GroupEval, i.e., ω←CFEvaloﬀ

GroupEval, ˜τ (K, f ).

EﬀVer(sk, VKP , ∆, m, σ). Let sk = (bgpp, pp, K, α) be a se-
cret key. Let VKP = ω be the concise veriﬁcation infor-
mation for P. Let m ∈ Zp be the result to be veriﬁed
and let σ = (y0, Y1, ˆY2) be a tag. The online veriﬁcation
proceeds as follows. First, it runs the online closed-form
eﬃcient algorithm of F for GroupEval, in order to com-
pute W ←CFEvalon
GroupEval,∆(K, ω). Finally, it runs the same
checks (2) and (3) as in standard veriﬁcation.
If both
checks are satisﬁed, then output 1. Otherwise output 0.

Eﬃciency Analysis. We discuss the concrete eﬃciency
of our scheme when implemented with speciﬁc security pa-
rameters of 80 and 128 bits. In particular, we consider the
bandwidth costs for sending the MACs over the network,
and the computational timings of the various algorithms at
both the client and the server. The timings are obtained
by evaluating the most signiﬁcant operations performed by
our algorithms, namely modular exponentiations and pair-
ing computations. For our evaluation, we consider an imple-
mentation of Type-A (symmetric) pairings using the PBC
library [35], on an 2.5 GHz Intel Core i5 workstation run-
ning Mac OS X 10.8.3. The timings of all basic operations
needed by our scheme are summarized in Table 1. In addi-
tion, we note that by using 80 (resp. 128) bits of security, an
element of Zp can be represented with 160 (resp. 256) bits,
an element of G with 512 (resp. 1536) bits, and an element
of GT with 1024 (resp. 3072) bits. Most clients’ costs are

872Operation

Pairing
⋆ Pairing

Exp. in G
⋆ Exp. in G
Exp. in GT
⋆ Exp. in GT

Multiexp(2). in G
Multiexp(3). in GT

Time (ms)

80-bits

128-bits

1.23
0.62
1.83
0.24
0.22
0.05
2.53
0.44

12
6.34
9.55
1.34
1.15
0.26
13.34
2.45

⋆ Costs obtained using precomputation.

Table 1: Summary of costs per operation (in ms).

only in the full version of this work. Below we provide the
reader with some intuitive ideas.

Roughly speaking, correctness is based on the following
facts: (i) our MACs “encode” polynomials y(x) satisfying
y(0) = m and y(α) = r(∆,τ ); (ii) by the property of GroupEval,
the veriﬁcation can recompute w = f (r(∆,τ1), . . . , r(∆,τn))
“in the exponent”; (iii) Eval essentially evaluates PolyEval
“in the exponent”, thus preserving the property on y(α),
i.e., y(α) = w. Correctness of EﬀVer instead follows from
the correctness of the amortized closed-form eﬃciency for
GroupEval (see Section 4.3).

The security of EVH−MAC is shown via the following the-

orem whose proof is contained in the long version [7].

Operations at
the client side
Data Outsourcing
Verif. w/o prep.

Time (ms)

80 bits

128 bits

Size of tags (kB)
80 bits
128 bits

0.24
1.06

1.34
8.79

0.08
0.21

0.22
0.59

Table 2: Clients’ costs to outsource and to verify.

Theorem 3. Let λ be the security parameter, F be a pseu-
dorandom function with security ǫF, and G be a bilinear
group generator. Then, any PPT adversary A making Q
veriﬁcation queries has probability at most ǫ = 2·ǫF+ 8Q
of breaking the security of EVH−MAC.

p−2(Q−1)

summarized in Table 2. Below we illustrate how they are
obtained, and we give more details on the remaining costs.
To obtain the bandwidth costs, we observe that the MAC
σ created by the client, i.e., as generated by Auth, consists of
two elements (y0, Y1) ∈ Zp × G, whereas the MAC returned
by Eval may include the additional element ˆY2 ∈ GT .

Next, let us consider the computational performances of
the algorithms of EVH−MAC. To authenticate a data item,
the client runs Auth, whose cost basically boils down to that
of computing Y1. The latter requires one PRF evaluation
to generate R (which amounts to one exponentiation in G),
plus two other exponentiations, one for m, and one for α−1.
However, with a more careful look at our PRF construction,
we observe that this operation can be optimized by comput-
ing directly Y1 = g(ua+vb−m)/α, a single exponentiation in
G (with precomputation on the ﬁxed basis g). For veriﬁca-
tion, the client has to ﬁrst prepare the re-usable veriﬁcation
information VKP using VerPrep. The cost of this algorithm
depends on the computation of ω←CFEvaloﬀ
GroupEval, ˜τ (K, f ),
which is essentially the same as computing the function f (no
exponentiations, pairings or group operations are needed).
Such value VKP is stored by the client (its size amounts
to at most 5 elements of Zp), and it can be re-used over
and over when running P on diﬀerent data sets, thus amor-
tizing the cost of its computation. To verify a MAC us-
ing EﬀVer in the online phase, the client needs to compute
only one pairing (with precomputation on the ﬁxed g), i.e.,
e(Y1, g), and one multi-exponentiation with three bases4,
for e(g, g)y0−we(Y1, g)α( ˆY2)α2
. To conclude our analysis, we
consider the cost required to the server for generating the
correctness proofs, i.e., to run Eval. As one can notice, Eval
evaluates the circuit f with an additional, constant, over-
head which derives from replacing every addition of f with
the group operation (in either G or GT ), and every multipli-
cation with one multi-exponentiation in G plus one pairing.

Correctness and Security. For lack of space, we formally
prove correctness and security properties of our construction

4Here we observed that the explicit computation of W =
e(g, g)w in CFEvalon can be avoided by directly considering
e(g, g)y0−w.

6. REFERENCES

[1] S. Agrawal and D. Boneh. Homomorphic MACs:

MAC-based integrity for network coding. In ACNS,
2009.

[2] B. Applebaum, Y. Ishai, and E. Kushilevitz. From

secrecy to soundness: Eﬃcient veriﬁcation via secure
computation. In ICALP 2010, Part I, 2010.

[3] N. Attrapadung and B. Libert. Homomorphic network

coding signatures in the standard model. In PKC,
2011.

[4] N. Attrapadung, B. Libert, and T. Peters. Computing

on authenticated data: New privacy deﬁnitions and
constructions. In ASIACRYPT, 2012.

[5] N. Attrapadung, B. Libert, and T. Peters. Eﬃcient

completely context-hiding quotable and linearly
homomorphic signatures. In PKC, 2013.

[6] L. Babai. Trading group theory for randomness. In

STOC, 1985.

[7] M. Backes, D. Fiore, and R. M. Reischuk. Veriﬁable

delegation of computation on outsourced data.
Cryptology ePrint Archive, Report 2013/469, 2013.
http://eprint.iacr.org/.

[8] M. Belenkiy, M. Chase, C. C. Erway, J. Jannotti,

A. K¨up¸c¨u, and A. Lysyanskaya. Incentivizing
outsourced computation. In NetEcon, 2008.

[9] S. Benabbas, R. Gennaro, and Y. Vahlis. Veriﬁable

delegation of computation over large datasets. In
CRYPTO, 2011.

[10] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.

From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In ITCS, 2012.

[11] D. Boneh, X. Boyen, and H. Shacham. Short group

signatures. In CRYPTO, 2004.

[12] D. Boneh, D. Freeman, J. Katz, and B. Waters.
Signing a linear subspace: Signature schemes for
network coding. In PKC, 2009.

[13] D. Boneh and D. M. Freeman. Homomorphic

signatures for polynomial functions. In EUROCRYPT,
2011.

873[14] D. Boneh and D. M. Freeman. Linearly homomorphic

[36] C. Martel, G. Nuckolls, P. Devanbu, M. Gertz,

signatures over binary ﬁelds and new tools for
lattice-based signatures. In PKC, 2011.

[15] D. Catalano and D. Fiore. Practical homomorphic

MACs for arithmetic circuits. In EUROCRYPT, 2013.

[16] D. Catalano, D. Fiore, R. Gennaro, and

K. Vamvourellis. Algebraic (trapdoor) one way
functions and their applications. In TCC, 2013.

A. Kwong, and S. G. Stubblebine. A general model for
authenticated data structures. Algorithmica,
39(1):21–41, 2004.

[37] S. Micali. CS proofs. In 35th FOCS, 1994.
[38] F. Monrose, P. Wyckoﬀ, and A. D. Rubin. Distributed

execution with remote audit. In NDSS, 1999.

[39] M. Naor and K. Nissim. Certiﬁcate revocation and

[17] D. Catalano, D. Fiore, and B. Warinschi. Adaptive

certiﬁcate update. In USENIX Security, 1998.

pseudo-free groups and applications. In
EUROCRYPT, 2011.

[18] D. Catalano, D. Fiore, and B. Warinschi. Eﬃcient

network coding signatures in the standard model. In
PKC, 2012.

[19] K.-M. Chung, Y. Kalai, and S. P. Vadhan. Improved

delegation of computation using fully homomorphic
encryption. In CRYPTO, 2010.

[20] K.-M. Chung, Y. T. Kalai, F.-H. Liu, and R. Raz.

Memory delegation. In CRYPTO, 2011.

[21] G. Di Battista and B. Palazzi. Authenticated

relational tables and authenticated skip lists. In
DBSec, 2007.

[22] D. Fiore and R. Gennaro. Publicly veriﬁable

delegation of large polynomials and matrix
computations, with applications. In CCS, 2012.

[23] D. M. Freeman. Improved security for linearly

homomorphic signatures: A generic framework. In
PKC, 2012.

[24] R. Gennaro, C. Gentry, and B. Parno. Non-interactive

veriﬁable computing: Outsourcing computation to
untrusted workers. In CRYPTO, 2010.

[25] R. Gennaro, C. Gentry, B. Parno, and M. Raykova.

Quadratic span programs and succinct NIZKs without
PCPs. In EUROCRYPT, 2013.

[26] R. Gennaro, J. Katz, H. Krawczyk, and T. Rabin.
Secure network coding over the integers. In PKC,
2010.

[40] C. Papamanthou, E. Shi, and R. Tamassia. Signatures

of correct computation. In TCC, 2013.

[41] C. Papamanthou and R. Tamassia. Time and space
eﬃcient algorithms for two-party authenticated data
structures. In ICICS, 2007.

[42] C. Papamanthou, R. Tamassia, and N. Triandopoulos.
Optimal veriﬁcation of operations on dynamic sets. In
CRYPTO, 2011.

[43] B. Parno, J. Howell, C. Gentry, and M. Raykova.

Pinocchio: Nearly practical veriﬁable computation. In
IEEE Symposium on Security and Privacy, 2013.

[44] B. Parno, M. Raykova, and V. Vaikuntanathan. How

to delegate and verify in public: Veriﬁable
computation from attribute-based encryption. In
TCC, 2012.

[45] S. Setty, B. Braun, V. Vu, A. Blumberg, B. Parno, and

M. Walﬁsh. Resolving the conﬂict between generality
and plausibility in veriﬁed computation. EuroSys 2013.
[46] S. Setty, R. McPherson, A. Blumberg, and M. Walﬁsh.
Making argument systems for outsourced computation
practical (sometimes). In NDSS, 2012.

[47] S. Setty, V. Vu, N. Panpalia, B. Braun, A. Blumberg,

and M. Walﬁsh. Taking proof-based veriﬁed
computation a few steps closer to practicality. In
USENIX Security Symposium, 2012.

[48] A. Shpilka and A. Yehudayoﬀ. Arithmetic circuits: A

survey of recent results and open questions.
Foundations and Trends in TCS, 2010.

[27] R. Gennaro and D. Wichs. Fully homomorphic

[49] S. W. Smith and S. Weingart. Building a

message authenticators. Cryptology ePrint Archive,
Report 2012/290, 2012. http://eprint.iacr.org/.

[28] C. Gentry and D. Wichs. Separating succinct
non-interactive arguments from all falsiﬁable
assumptions. In STOC, 2011.

high-performance, programmable secure coprocessor.
Computer Networks, 1999.

[50] R. Tamassia. Authenticated data structures. In

G. Battista and U. Zwick, editors, Algorithms - ESA.
Springer, 2003.

[29] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum.

[51] V. Vu, S. Setty, A. Blumberg, and M. Walﬁsh. A

hybrid architecture for interactive veriﬁable
computation. In IEEE Security and Privacy, 2013.

[52] B. Yee. Using Secure Coprocessors. PhD thesis,

Carnegie Mellon University, 1994.

Delegating computation: interactive proofs for
muggles. In STOC, 2008.

[30] M. T. Goodrich, R. Tamassia, and J. Hasic. An
eﬃcient dynamic and distributed cryptographic
accumulator. In ISC, 2002.

[31] M. T. Goodrich, R. Tamassia, N. Triandopoulos, and

R. Cohen. Authenticated data structures for graph
and geometric searching. In CT-RSA, 2003.

[32] R. Johnson, D. Molnar, D. X. Song, and D. Wagner.
Homomorphic signature schemes. In CT-RSA, 2002.
[33] J. Kilian. A note on eﬃcient zero-knowledge proofs

and arguments. In STOC, 1992.

[34] A. B. Lewko and B. Waters. Eﬃcient pseudorandom
functions from the decisional linear assumption and
weaker variants. In CCS, 2009.

[35] B. Lynn. PBC: The pairing-based crypto library.

874