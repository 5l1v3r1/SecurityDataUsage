On Secure Two-party Integer Division

Morten Dahl1, Chao Ning2,3(cid:63), and Tomas Toft1

1 Aarhus University, Denmark (cid:63)(cid:63) (cid:63) (cid:63) (cid:63) † {mdahl,ttoft}@cs.au.dk

2 IIIS, Tsinghua University, Beijing, China ncnfl@mail.tsinghua.edu.cn

3 School of Computer Science and Technology, Shandong University, Jinan, China

Abstract. We consider the problem of secure integer division: given two
Paillier encryptions of (cid:96)-bit values n and d, determine an encryption of
(cid:98) n
d (cid:99) without leaking any information about n or d. We propose two new
protocols solving this problem.
The ﬁrst requires O((cid:96)) arithmetic operations on encrypted values (se-
cure addition and multiplication) in O(1) rounds. This is the most ef-
ﬁcient constant-rounds solution to date. The second protocol requires

only O(cid:0)(log2 (cid:96))(κ + loglog (cid:96))(cid:1) arithmetic operations in O(log2 (cid:96)) rounds,

where κ is a correctness parameter. Theoretically, this is the most eﬃ-
cient solution to date as all previous solutions have required Ω((cid:96)) oper-
ations. Indeed, the fact that an o((cid:96)) solution is possible at all is highly
surprising.
Key words: Secure two-party computation, Secure integer division

1

Introduction

Secure multiparty computation (MPC) allows two or more mutually mistrust-
ing parties to evaluate a function on private data without revealing additional
information. Classic results show that any function can be computed with poly-
nomial overhead but specialised protocols are often used to improve eﬃciency:
integer arithmetic can for instance be simulated using ZM arithmetic. On the
other hand, this makes non-arithmetic operations diﬃcult, including determin-
ing which of two sums is the larger (as needed in the double auction of Bogetoft
et al. [BCD+09]), or performing an integer division of sums (essentially the com-
putation of the mean problem of Kiltz et al. [KLM05]).

(cid:63) This work was supported in part by the National Basic Research Program of China
Grant 2011CBA00300, 2011CBA00301, the National Natural Science Foundation of
China Grant 61033001, 61061130540, 61073174 and 61173139.

(cid:63)(cid:63) The authors acknowledge support from the Danish National Research Foundation
and The National Science Foundation of China (under the grant 61061130540) for
the Sino-Danish Center for the Theory of Interactive Computation, within which
part of this work was performed.

(cid:63) (cid:63) (cid:63) The authors acknowledge support from the Center for research in the Foundations of
Electronic Markets (CFEM), supported by the Danish Strategic Research Council.
† The authors acknowledge support from Conﬁdential Benchmarking (COBE), sup-
ported by The Danish Research Council for Technology and Production.

In this paper we consider the problem of secure integer division – computing
(cid:98)n/d(cid:99) given n and d – in the two-party setting. Immediate applications include
statistics on data from companies in the same line of business, as well as data-
mining tasks, e.g., the k-means clustering protocol of Jagannathan and Wright
[JW05]. Further, since the problem of secure integer division is equivalent to that
of secure modulo reduction – n mod m = n− m·(cid:98)n/m(cid:99) – any such protocol may
be utilized in joint key-generation, e.g., as done by Algesheimer et al. [ACS02].

Related work. Algesheimer et al. introduced the problem of secure integer di-
vision in the context of passively secure RSA-modulus generation with honest
majority [ACS02]; active security is achievable using standard techinques. Their
solution was based on Newton iteration and required O((cid:96)) work and communi-
cation (using the notation of this paper) in O(log (cid:96)) rounds, where (cid:96) is the bit-
length of the inputs. The protocols were implemented by From and Jakobsen in
the passively secure three-party setting [FJ05]. Recently, Catrina and Dragulin
have used similar ideas to construct secure ﬁxed-point arithmetic [CD09].

Regarding constant-rounds solutions, Kiltz et al. proposed specialised proto-
cols based on Taylor series for the related, but simpler, problem of computing
the means in a two-party setting [KLM05]. Damg˚ard et al. [DFK+06] observed
that combining the ideas of [ACS02,KLM05] and bit-decomposition (BD) im-
plied constant-rounds modulo reduction and hence integer division. No details
were presented, though naturally complexity was at least that of BD, O((cid:96) log (cid:96)).
The simpler problem where d is known to all parties (a single party) has been
studied by Guajardo et al. [GMS10] and Ning and Xu [NX10] (Veugen [Veu10]).
Finally, we remark that it is possible to “switch technique” mid-protocol
and use homomorphic encryption for arithmetic and (small) Yao circuits for
primitives such as integer division as done by Henecka et al. [HKS+10]. However,
achieving active security in this setting typically requires the use of cut-and-
choose techniques. Moreover, while it is possible to use generic non-interactive
zero-knowledge proofs to demonstrate correct protocol execution to independent
observers – e.g. clients which have supplied the inputs as in the Danish “sugar
beet auction” [BCD+09] – this will be much more expensive than using non-
generic zero-knowledge proofs as our solution allows.

e.g., up to 40 bits. The second protocol communicates O(cid:0)(log2 (cid:96))(κ + loglog (cid:96))(cid:1)

Contribution. We present two two-party protocols for the problem of secure
integer division: given Paillier encryptions of (cid:96)-bit values n and d, compute an
encryption of (cid:98)n/d(cid:99) without leaking any information. Both are based on Taylor
series. The ﬁrst protocol requires O((cid:96)) encryptions to be exchanged between the
parties in a constant number of rounds; this is quite practical for small inputs,
encryptions in O(log2 (cid:96)) rounds. Moreover, we are able to avoid bit-decomposi-
tion; indeed, as the latter complexity is sub-linear in the bit-length, it precludes
the use of bit-decomposition. That a sub-linear solution is possible at all is quite
surprising, but the construction is of theoretical rather than practical interest.
Though our protocols are presented in the two-party Pailier-based setting,
they are applicable in other settings providing secure arithetmic, e.g. the pro-

tocols of Ben-Or et al. [BGW88]. However, the sub-linear solution requires the
presence of two mutually incorruptible parties, at least with current knowledge.

Acknowledgements. The authors would like to thank Troels Sørensen, Jesper
Buus Nielsen, and the anonymous reviewers for their comments and suggestions.

2 Preliminaries

After presenting Paillier encryption and secure two-party computations we in-
troduce a set of protocols used in our constructions. All sub-protocols are secure
against malicious (i.e., potentially deviating) attackers. Regarding complexity,
we shall use Rπ and Cπ to denote respectively the number of rounds used and
the number of ring elements communicated during a single run of protocol π.

Paillier encryption. Paillier’s encryption scheme [Pai99] is an additively homo-
morphic, sematically secure public key encryption scheme based on the decisional
composite residuosity assumption of RSA-moduli. Suppressing the randomness
used for encryption, we write [m] to denote an encryption of m.

Secure computation. Secure multi-party computation can be based on Paillier
encryption with a threshold key using the protocols of Cramer et al. [CDN01].
The threshold sharing can be constructed using the ideas of Damg˚ard and Jurik
[DJ01]. Though not explicitly stated, apart from guaranteed termination, the
protocols of [CDN01] are still valid even if all but a single party are corrupt. In
particular this allows the two-party setting. We assume the following setting:

– Alice and Bob know a public Paillier key and share the decryption key.
– Inputs and intermediary values are held in encrypted form by both parties.
Paillier encryption is additively homomorphic, hence given [m] and [m(cid:48)] both
parties may compute an encryption [m + m(cid:48)]. We will use inﬁx operations in the
plaintext space and write [m + m(cid:48)] ← [m] + [m(cid:48)] for this operation. To perform
a multiplication, the parties need to run a protocol; see [CDN01] for details.

Zero-knowledge proof of boundedness. In addition to secure arithmetic in ZM
we require a zero-knowledge proof of boundedness, i.e. that Alice and Bob may
demonstrate to each other that the plaintext of an encryption [m] sent to the
other party (where the sender knows m) is smaller than some public bound B.
For Paillier encryption this can be achieved with O(1) communication (of ring
elements) using integer commitments and the fact that any non-negative integer
can be written as a sum of four squares. See [Bou00,Lip03] for further discussion.

Computing the greater-than relation. Given encryptions [m] and [m(cid:48)] of (cid:96)-bit
values, obtain an encryption [b] of a bit b such that b = 1 iﬀ m > m(cid:48). A
constant-rounds protocol πc
>? for this can be based oﬀ of the comparison protocol

of Nishide and Ohta [NO07]; communication complexity is Cπc
elements. We use πc≤? as syntactic sugar for running πc

= O((cid:96)) ring
>? with inputs swapped.
>? and πs≤?, is possible due to Toft [Tof11]. Its
= O(log (cid:96))

>?

A sub-linear protocol, denoted πs

>?

= O ((log (cid:96))(κ + loglog (cid:96))) ring elements in Rπs

complexity is Cπs
rounds, where κ is a correctness parameter.
Computing the inverse of an element. Given an encryption [x] of x ∈ Z∗
M ,

compute an encryption (cid:2)x−1(cid:3) of its inverse. We use the protocol from [BB89]

>?

which performs this task in a constant number of rounds and communicating
a constant number of ﬁeld elements. We shall use this protocol in both the
constant-rounds and the sub-linear protocol and hence simply denote it by πinv.

form – i.e. computing bits [m(cid:96)−1] , . . . , [m0] such that m = (cid:80)(cid:96)−1

Bit-decompositon (BD). Decomposing an encrypted (cid:96)-bit value [m] into binary
i=0 2i · mi – is
not strictly required (details appear in the full version) but we use it here for
clarity. We denote by πc
BD the BD protocol of Reistad and Toft [RT10]; this uses
Cπc

= O((cid:96)) communication.

Preﬁx-or of a sequence of bits. Given encrypted bits [x(cid:96)−1] , . . . , [x0], compute
j=i xj. An O(1)-rounds protocol

encrypted bits [y(cid:96)−1] , . . . , [y0] such that yi =(cid:87)(cid:96)−1
(cid:2)x1(cid:3) ,(cid:2)x2(cid:3) , . . . , [xω]. πc

communicating Cπc
Powers of a number. Given an encrypted number [x] and public ω ∈ Z, compute
= O(ω) communication
in O(1) rounds using a preﬁx-product computation, [BB89,DFK+06].

pre-∨ = O((cid:96)) elements, πc

pre-∨, is provided in [DFK+06].

pre-Π achieves this using Cπc

pre-Π

BD

3 The Intuition Behind the Constructions

In this section we take a high-level view and present the ideas behind the desired
computation. The following sections then explain how to do this securely in the
stated complexity. Assume in the following that n and d are (cid:96)-bit integers, and
let k be a suitable large, public integer. Our solutions then consist of two steps:
I. Compute an encrypted approximation [˜a] of a = (cid:98)2k/d(cid:99)

II. Compute [(cid:98)n/d(cid:99)] as(cid:4)([˜a] · [n])/2k(cid:5)

Step I is explained over the reals in Section 3.1. This is then converted to in-
teger computation in Section 3.2 and ﬁnally realised using ZM arithmetic in
Section 3.3. Note that the integer division in step II is simpler as 2k is public.

3.1 The Taylor Series

As in [KLM05] or the constant depth division circuit of Hesse et al. [HAB02],
we start with a geometric series to compute a “k-shifted” approximation of 1/d:

∞(cid:88)

1
α

=

ω(cid:88)

(1 − α)i =

(1 − α)i + ω

(1)

i=0

i=0

where ω =(cid:80)∞
∞(cid:88)

ω =

∞(cid:88)

i=ω+1(1−α)i. This is easily veriﬁed for any real 0 < α < 1. Further,
approximating 1/α by keeping only the ﬁrst ω + 1 terms of the summation
introduces an additive error of ω. If 0 < 1 − α ≤ 1/2 then this error is at most

(1 − α)i = (1 − α)ω+1 ·

(1 − α)i ≤ 2−ω−1 · 1
α

≤ 2−ω.

(2)

i=ω+1

i=0

By picking ω suﬃciently large this ensures an appropriately small error below.

3.2 Converting the Taylor Series to an Integer Computation

Multiplying 1/α by a power of two “shifts” the value; this ensures that each of
the ω + 1 terms of the ﬁnite sum of Eq. (1) are integer. The non-integer part of
the shifted value is entirely contained in ω, which will be discarded.
Let (cid:96)d = (cid:98)log2(d) + 1(cid:99) be the bit-length of d, i.e. 2(cid:96)d−1 ≤ d < 2(cid:96)d ; deﬁne
(cid:96)n similarly. Any ω ≥ max{(cid:96)n − (cid:96)d, 0} provides suﬃcient accuracy, however, the
public ω cannot depend on the secret (cid:96)n and (cid:96)d. Thus, we let ω = (cid:96) ≥ (cid:96)n − (cid:96)d.
For α = d/2(cid:96)d and k = (cid:96)2 + (cid:96) the following provides 1/d shifted up by k bits:

(cid:32)

2k
d

= 2k−(cid:96)d ·

1

d/2(cid:96)d

=

2k−(cid:96)d(ω+1)

We deﬁne the desired approximation of 2k/d as

˜a = 2k−(cid:96)d(ω+1) · ω(cid:88)

(cid:0)2(cid:96)d − d(cid:1)i · 2(cid:96)d(ω−i)

ω(cid:88)
(cid:0)2(cid:96)d − d(cid:1)i · 2(cid:96)d(ω−i).

i=0

+ 2k−(cid:96)d · ω.

(3)

i=0

Note that not only is this an integer since k ≥ (cid:96)d(ω + 1) and 2(cid:96)d > d, it may
also be computed as the product of 2k−(cid:96)d(ω+1) and the evaluation of the integer
polynomial with coeﬃcients 2(cid:96)d(ω−i) for 0 ≤ i ≤ ω at point 2(cid:96)d − d. Furthermore,
since 0 < 1 − d/2(cid:96)d ≤ 1/2 we have a bound on the additive error by Eq. (2):

(cid:33)

(cid:23)

This ensures that the result computed in step II is oﬀ by at most 1; we have:

2k−(cid:96)d · ω ≤ 2k−(cid:96)d−ω.

(cid:36)

n ·(cid:0)˜a + 2k−(cid:96)d · ω

(cid:1)

(cid:37)

(cid:22) n · ˜a

=

2k +

n · 2k−(cid:96)d · ω

2k

2k

(cid:106) n

(cid:107)

d

=

(4)

and see that the second summand is bound by

n · 2k−(cid:96)d · ω

2k

≤ n · 2k−(cid:96)d−ω

2k

<

2k
2k = 1

since (cid:96)n ≤ ω. (cid:98) n·˜a
2k (cid:99) is the desired result except that the sum of the error, n ·
2k−(cid:96)d · ω, and the discarded bits of the approximation, n · ˜a mod 2k, may be
greater than 2k; i.e. there may be an additive error of −1 due to a lost carry.
To recap: Given integers 2k−(cid:96)d(ω+1), 2(cid:96)d − d and 2(cid:96)d(ω−i) for 0 ≤ i ≤ (cid:96),
performing step I yields an approximation ˜a of 2k/d using Eq. (3). Down-shifting
this almost gives the desired result, namely ˜q ∈ {q, q − 1}, where q = (cid:98)n/d(cid:99).

3.3 Performing the Integer Computation Using ZM Arithmetic
The underlying primitives provide secure ZM arithmetic, with M = p · q being
the Paillier key whose secret key is held jointly by the parties. We assume4 that

M (cid:29) 2(cid:96)2+(cid:96)+κs,

where κs is a statistical security parameter, e.g. κs = 100. This implies that no
“overﬂow” modulo M occurs in Eq. (3), hence it can be seen as occurring in
ZM . However, for eﬃciency reasons we rephrase the expression as

˜a = 2k−(cid:96)d(ω+1) · ω(cid:88)

(cid:0)2(cid:96)d − d(cid:1)i · 2(cid:96)d(ω−i) = 2k−(cid:96)d · ω(cid:88)

(cid:0)(cid:0)2(cid:96)d − d(cid:1) · 2−(cid:96)d(cid:1)i

(5)

i=0

i=0

where addition and multiplication occur in ZM . Although this should no longer
be seen as an integer computation, the key observation is that it is irrelevant how
the encryption [˜a] is obtained; what matters is that the plaintext is correct. Es-
sentially this altered calculation can be viewed as using the encoding of rational
values suggested in [FSW02]. Note that this simpliﬁes the desired calculation:
we now only need the values 2k−(cid:96)d , 2(cid:96)d − d, and 2−(cid:96)d as well as the evaluation
of a ZM -polynomial with known coeﬃcients (all equal to 1).

4 The Overall Division Protocol

Having presented the desired ZM -expression for computing the approximation
˜a ≈ 2k/d in Section 3.3 above, the goal now is to give a high-level view of
the actual protocol. We ﬁrst formalise the required sub-tasks, and then present
the overall protocol based on assumed protocols for these. Instantiating these
protocols with either the constant-rounds (Section 5) or the sub-linear (Section 6)
versions of the sub-protocols we obtain our two division protocols.

4.1 Sub-tasks and Sub-protocols

In addition to the basic primitives of Section 2 we require the following sub-
protocols:

(cid:2)2(cid:96)d(cid:3) for (cid:96)d = (cid:98)log 2(d) + 1(cid:99)
A(x) =(cid:80)ω

– πBL: Given an encryption [d] of an (cid:96)-bit value d, determine an encryption
– πpoly: Given an encryption [p] of p ∈ Z∗
M , evaluate the known polynomial
i=0 xi over ZM securely at point p, i.e. compute encryption [A(p)]
– πtrunc: Given an encryption [ˆq] of an ((cid:96) + k)-bit value ˆq ∈ ZM , compute an
encryption [˜q] of an approximation of (cid:98)ˆq/2k(cid:99) s.t. ˜q = (cid:98)ˆq/2k(cid:99)+ for  ∈ {0, 1}.

4 M needs to be at least a thousand bits long to ensure security of the Paillier scheme

and hence this assumption is not as bad as it may appear at ﬁrst glance.

4.2 The High-level View

I. Compute an encryption [˜a] of the approximation

The full division protocol is seen in Figure 1 and proceeds by the following steps:

(a) Determine(cid:2)2(cid:96)d(cid:3) and in turn compute(cid:2)2k−(cid:96)d(cid:3) and [p] =(cid:2)(2(cid:96)d − d) · 2−(cid:96)d(cid:3)
(b) Evaluate the polynomial of Eq. (5) in [p] and securely multiply by(cid:2)2k−(cid:96)d(cid:3)

(a) Obtain encryption [˜q] of ˜q ≈ (cid:98)n/d(cid:99) by computing and truncating [n · ˜a]
(b) Eliminate errors introduced by approximations, i.e., compute [q] from [˜q]

II. Compute [(cid:98)n/d(cid:99)]

where the elimination of errors are performed by two secure comparions.

A: sk A

pk = M, [n] , [d]

(cid:2)2(cid:96)d(cid:3) ← πBL ([d])
(cid:2)2−(cid:96)d(cid:3) ← πinv
(cid:0)(cid:2)2(cid:96)d(cid:3)(cid:1)
[p] ← ((cid:2)2(cid:96)d(cid:3) − [d]) ·(cid:2)2−(cid:96)d(cid:3)
[˜a] ← 2k ·(cid:2)2−(cid:96)d(cid:3) · πpoly([p])

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

B: sk B

[ˆq] ← [n] · [˜a]

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[˜q] ← πtrunc([ˆq] , k)

[r] ← [n] − [d] · [˜q]

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[+] ← π≤? ([d] + [d] , [r] + [d])

[−] ← π>? ([d] , [r] + [d])
[q] ← [˜q] + [+] − [−]

Fig. 1. The full division protocol, πdiv([n] , [d]) (cid:55)→ [(cid:98)n/d(cid:99)]

Correctness. Correctness follows almost entirely from the previous section. For
the plaintext of [ˆq], the most signiﬁcant bits are oﬀ by at most 1:

(cid:98)ˆq/2k(cid:99) ∈ {(cid:98)n/d(cid:99),(cid:98)n/d(cid:99) − 1}.

The execution of πtrunc may introduce an additional additive error, i.e. we have

˜q ∈ {(cid:98)n/d(cid:99) − 1,(cid:98)n/d(cid:99),(cid:98)n/d(cid:99) + 1}.

Using r = n − d · ˜q ∈ [−d; 2d[ we can securely determine which case we are in.
Namely, ˜q + 1 = (cid:98)n/d(cid:99) when d ≤ r and ˜q − 1 = (cid:98)n/d(cid:99) when 0 > r. In order to
deal only with positive integers we scale these tests to respectively 2d ≤ r + d
and d > r + d. Letting + and − denote the Boolean outcome of these tests, it
follows that q = ˜q + + − − = (cid:98)n/d(cid:99).

Privacy. The protocol reveals no information about the inputs (other than the
desired encryption of the result). This follows from the fact that no value is
ever decrypted and that we only invoke secure sub-protocols which do not leak
information. We note that πinv and πpoly require the input to be invertible –
M , while
M . Further, the input [n · ˜a] for the truncation is (cid:96) + k-bit

this is indeed the case as M is the product of two odd primes, p, q ≈ √
2(cid:96)d , 2(cid:96)d − d ≤ 2(cid:96) (cid:28) √
long as n < 2(cid:96) and ˜a ≤ 2k/d ≤ 2k, and hence the input is of the correct size.

A formal security proof using the real/ideal paradigm requires the construc-
tion of a simulator for each party. These are straightforward to construct from
the simulators of the sub-protocols; as our protocol consists of the sequential
evaluation of sub-protocols, the overall simulator simply consists of the sequen-
tial execution of the simulators of these.

Complexity. The complexity depends on the details of the sub-protocols πBL,
πpoly, πtrunc, and π>?. Formally we have

Rπdiv = RπBL + Rπinv + Rπpoly + Rπtrunc + 2 · Rπ>? + 3 · Rπmult

= RπBL + Rπpoly + Rπtrunc + O(Rπ>?) + O(1)

Cπdiv = CπBL + Cπinv + Cπpoly + Cπtrunc + 2 · Cπ>? + 3 · Cπmult

(6)

= CπBL + Cπpoly + Cπtrunc + O(Cπ>?) + O(1)
such that for the constant-rounds instantiation we get Rπc
+
+O((cid:96)). Likewise, for the sub-
Rπc
= Cπc
linear instantiation we get Rπs
=
+ O ((log (cid:96))(κ + loglog (cid:96))). Finally, a slight optimisation
Cπs
regarding rounds is possible by invoking π>? and π≤? in parallel.

+ Rπc
+O(log (cid:96)) and Cπs

+O(1) and Cπc

+ Cπc
= Rπs

+ Cπc
+Rπs

poly

= Rπc

BL

+Rπs

trunc

+ Cπs

poly

+ Cπs

trunc

BL

trunc

div

BL

poly

div

BL

poly

div

trunc

div

Active Security. The protocol in Figure 1 is only passively secure. However,
obtaining active security is straightforward by executing appropriate ZK proofs.
This increases the communication complexity by a constant factor.

5 The Constant-rounds Protocol

In this section we plug in protocols for the three sub-tasks. All protocols use
a constant number of rounds and linear communication. Combined with the
previous section this provides a constant-rounds protocol for division.

5.1 The constant-rounds πBL protocol
In the full version of this paper [DNT12] we give a πc
BL protocol that, somewhat
surprising, does not rely on bit-decomposition. However, for clarity the πc
BL
protocol presented here in Figure 2 is composed of two protocols introduced
in Section 2: πc
pre-∨. To recap, given [d] the former returns a vector of
i=0 xi·2i = d. The latter
j=i xj.

encrypted bits [x(cid:96)−1] , . . . , [x0] for which it holds that(cid:80)(cid:96)−1
takes such a vector of encrypted bits and returns another such that yi =(cid:87)(cid:96)−1

BD and πc

A: sk A

B: sk B

pk = M, [d]
[x(cid:96)−1] , . . . , [x0] ← πc

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[y(cid:96)−1] , . . . , [y0] ← πc

pre-∨([x(cid:96)−1] , . . . , [x0])

BD([d])

(cid:2)2(cid:96)d(cid:3) ← 1 +(cid:80)(cid:96)−1

i=0 [yi] · 2i

BL([d]) (cid:55)→(cid:2)2(cid:96)d(cid:3)

Fig. 2. Constant-rounds bit-length protocol, πc

yi = 1 if and only if d ≥ 2i. This means that 1 +(cid:80)(cid:96)−1

Correctness. By the correctness of the two sub-protocols we only have to argue
the correctness of the ﬁnal step. Note that the result of πc
pre-∨ is a set such that
i=0 yi · 2i is the desired 2(cid:96)d .
Privacy and Active Security. Follows immediately by the privacy and security
guarantees of the two sub-protocols.

Complexity. Since the ﬁnal step of πc
that Rπc

pre-∨ = O(1) and Cπc

= Rπc

+ Rπc

BD

BL

BL

BL is a local computation we simply have

= Cπc

BD

+ Cπc

pre-∨ = O((cid:96)).

5.2 The constant-rounds πpoly protocol

i=0 xi in point p =(cid:0)2(cid:96)d − d(cid:1) · 2−(cid:96)d using the preﬁx-product protocol πc
(cid:80)ω

As shown in the protocol in Figure 3, we simply evaluate polynomial A(x) =
pre-Π .
This gives encryptions of p1, p2, . . . , pω – and knowing these, all there is left to
do is to sum them together with p0 = 1 to form A(p).

A: sk A

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

pre-Π ([x] , . . . , [x])

pk = M, [x]

(cid:2)p1(cid:3) , . . . , [pω] ← πc
[y] ← 1 +(cid:80)ω

i=1 [pi]

B: sk B

Fig. 3. Constant-rounds polynomial evaluation protocol, πc

poly([x]) (cid:55)→ [A(x)]

Correctness, Privacy, Complexity, and Active Security. Noting that the second
step of πc
poly is a local computation, all properties directly reﬂect those of the
πc
pre-Π subprotocol. Formally, Rπc

= O(1) and Cπc

= O(ω).

poly

poly

5.3 The constant-rounds πtrunc protocol

Our constant-rounds protocol for truncation (shown in Figure 4) takes encryp-
tion [ˆq] and public k as input and returns [˜q] such that ˜q ≈ (cid:98)q/2k(cid:99). The result

may have an additive error c ≤ 1. It is possible to eliminate this error with a com-
parison [c] ← ([˜q] · 2k >? [ˆq]), and computing the correct result as [q] ← [˜q] − [c].
However, instead of comparing two (cid:96)2-bit numbers here, we handle the error in
the main protocol with a comparison of two (cid:96)-bit numbers instead.

A: sk A

pk = M, [ˆq] , k

B: sk B

2k+(cid:96)+κ

r ∈R Z
r(cid:62) ← (cid:98)r/2k(cid:99)
[z] ← [ˆq] + r

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

z ← decrA([z])

[z], [r(cid:62)]

z(cid:62) ← (cid:98)z/2k(cid:99)

−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[z(cid:62)]

[˜q] ← [z(cid:62)] − [r(cid:62)]

Fig. 4. Constant-rounds truncation protocol, πc

trunc([ˆq] , k) (cid:55)→(cid:2)(cid:98)ˆq/2k(cid:99) + c(cid:3)

To perform the truncation, party B ﬁrst picks a random integer of a bit-length
suﬃcient for using it as a mask for ˆq. He also stores the (cid:96) + κ most signiﬁcent
bits of r as r(cid:62) and computes an encryption of it. Upon receiving [z], the masked
value of ˆq, A and B now decrypt [z] for A to see. After learning this value z, A
can locally perform the truncation to form z(cid:62). She sends an encryption of this
value to B and both can ﬁnally compute the output locally by [z(cid:62)] − [r(cid:62)].

Correctness. When computing z it may happen that r causes a carry bit c from
the k least signiﬁcant bits to spill over into the (cid:96) + κ most signiﬁcant bits. In
this case the truncation of z will maintain this carry bit, causing the result of
z(cid:62) − r(cid:62) to be (cid:98)ˆq/2k(cid:99) + 1 instead of (cid:98)ˆq/2k(cid:99). For eﬃciency we allow this error.

Privacy. The only point where information could potentially be leaked is through
A seeing z. However, since r is chosen uniformly at random and κ bit longer than
ˆq, z leaks information about ˆq with probability negligible in κ.

trunc is Rπc

trunc

= 2 + Rdecr = O(1)
Complexity. We see that the complexity of πc
where Rdecr is the round complexity of a decryption, assumed to be constant.
Likewise the communication complexity is Cπc

Active Security. To obtain active security B must also send (cid:2)r⊥ = r mod 2k(cid:3)
to A, who in turn must also send(cid:2)z⊥ = z mod 2k(cid:3). B can now append a zero-

knowledge proof that z = (r(cid:62)· 2k + r⊥) + ˆq as well as proofs that both r(cid:62) and r⊥
are within the correct bounds. Similary, A also appends a proof of z = z(cid:62)·2k +z⊥
and that z(cid:62) and z⊥ are within bounds.

= 3 + Cdecr = O(1).

trunc

5.4 Combined Protocol and Analysis

By plugging the protocols introduced in this section into the πdiv protocol of
Section 4 we obtain our constant-rounds division protocol πc
div. Correctness, pri-
vacy, and active security follow from the discussions above. Using the complexity
expressions in Eq. 6 from Section 4 and the fact that ω = (cid:96) we get:

Rπc

div

= Rπc

BL

+ Rπc

poly

+ O(1) = O(1)

+ Rπc
+ O((cid:96)) = O(ω) + O((cid:96)) = O((cid:96)).

trunc

Cπc

div

= Cπc

BL

+ Cπc

poly

+ Cπc

trunc

6 The Sub-linear Protocol

In this section we give the protocols needed for giving the division protocol of
Section 3 a sub-linear communication complexity. We can reuse the truncation
protocol πc
trunc from Section 5 and hence only present two new πBL and πpoly
protocols.

6.1 The sub-linear πBL protocol

To compute(cid:2)2(cid:96)d(cid:3) from [d] in sub-linear communication complexity we take in-

spiration from [Tof11] and perform, in a sense, a binary search. Assuming we
have a protocol πs≤? for performing comparison of two encrypted numbers, we
give the protocol in Figure 5. For simplicity we assume that (cid:96) = 2γ for some
integer γ.

Intuitively, our construction recursively computes a pointer p into the binary
representation of d. Initially p points to the ﬁrst bit position (p0 = 20). In the
ﬁrst round we then ask in which half of the binary representation of d the most
signiﬁcant 1 occurs and store the result in bit c1. Next we update p to point to
position (cid:96)/21 if c = 1 (i.e. p1 = p0 · 2(cid:96)/21
) and to the same position as before
if c = 0 (i.e. p1 = p0 · 1). Iterating in this way p will eventually point to the
position of the most signiﬁcant bit of d. Shifting the position by one will give us
integer 2(cid:96)d .

Correctness and Privacy. Correctness follows from the above description of the
protocol, and privacy follows immediately from the sub-protocols as we only
compute on encrypted values.

Complexity. The protocol requires γ = log2 (cid:96) iterations, each requiring one com-
parison and one multiplication (not counting multiplication by public values).
+ Rπmult ) = O(log2 (cid:96)) and com-
Hence we get round complexity Rπs
munication complexity Cπs

+ Cπmult ) = O(cid:0)(log2 (cid:96))(κ + loglog (cid:96))(cid:1).

= γ · (Rπs≤?

= γ · (Cπs≤?

BL

BL

Active Security. Since the sub-protocol is actively secure, we only have to append
zero-knowledge proofs of correctness to every multiplication in order to make the
protocol resistant against active attackers. This increases the number of messages
communicated but only by a constant factor.

A: sk A

B: sk B

pk = M, [d]
[p0] ← 1

(cid:16)

2(cid:96)/2 · [p0] , [d]

(cid:17)

(cid:17)

(cid:17)

[c1] ← πs≤?

[p1] ← [p0] ·(cid:16)
(cid:16)
[pγ] ← [pγ−1] ·(cid:16)

[cγ] ← πs≤?

...

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[c1] · (2(cid:96)/2 − 1) + 1

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

2(cid:96)/2γ · [pγ−1] , [d]
[cγ] · (2(cid:96)/2γ − 1) + 1

(cid:17)

(cid:2)2(cid:96)d(cid:3) ← 2 · [pγ]

Fig. 5. Sub-linear bit-length protocol, πs

BL([d]) (cid:55)→(cid:2)2(cid:96)d(cid:3)

6.2 The sub-linear πpoly protocol

Evaluating the A(x) =(cid:80)ω
the notation is that σj = (cid:80)2j
this is indeed the case. Speciﬁcally this gives us that σγ =(cid:80)2γ
σγ + 1 =(cid:0)(cid:80)ω
i=1 xi(cid:1) + 1 =(cid:80)ω

i=0 xi polynomial at a point p can be done by a method
similar to “square and multiply”. We give the protocol in Figure 6 where for
simplicity we have assumed that ω = 2γ for some integer γ. The intuition behind
– it is not hard to see that
i=1 xi and hence

i=1 xi and xj = x2j

i=0 xi as required.

Correctness, Privacy, and Complexity. The ﬁrst two follow respectively from
the description above and from that fact that only arithmetical operations on
encryptions are performed. For complexity we have that the protocol requires
γ = log2 ω iterations with two multiplications in each. Hence the round com-
= γ · (2· Rπmult ) = O(log ω), and likewise for the communication
plexity is Rπs
= γ · (2 · Cπmult ) = O(log ω).
complexity Cπs

poly

poly

Active Security. By appending zero-knowledge proofs of correctness to every
multiplication we make the protocol resistant against active attackers. This in-
creases the number of messages communicated but only by a constant factor.

6.3 The sub-linear πtrunc protocol

The truncation protocol πc
the sub-linear protocol πs
decryption of [z]. The remaining operations can be carried out locally.

trunc of Section 5 is eﬃcient enought to be reused for
trunc: only a single operation is performed, namely the

A: sk A

B: sk B

pk = M, [x]
[σ0] ← [x]
[x0] ← [x]

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

[σ1] ← ([x0] + 1) · [σ0]

←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

...

[xγ−1] ← [xγ−2] · [xγ−2]
[σγ] ← ([xγ−1] + 1) · [σγ−1]

(cid:2)(cid:80)ω
i=0 xi(cid:3) ← [σγ] + 1

Fig. 6. Sub-linear polynomial evaluation protocol, πs

poly([x]) (cid:55)→ [A(x)]

6.4 Combined Protocol and Analysis

Our sub-linear division protocol πs
div is obtained from the πdiv protocol of Sec-
tion 4. Correctness, privacy, and active security follow from the discussions in
the previous sections and in this section. As for complexity, since ω = (cid:96), we get:
+ ··· + O(log (cid:96)) = O(log2 (cid:96)) + O(log ω) + O(log (cid:96)) = O(log2 (cid:96))

+ ··· + O ((log (cid:96))(κ + loglog (cid:96))) = O(cid:0)(log2 (cid:96))(κ + loglog (cid:96))(cid:1) .

= Rπs

Rπs

div

BL

Cπs

div

= Cπs

BL

7 Variations and Extensions

The multiparty case. Though we have presented our protocols in the two-party
setting, the ideas are also applicable to the multiparty case, based e.g. on the
protocols of [CDN01]. Arithmetic operations on encrypted values are immediate,
hence we must only consider πBL, πtrunc, and the sublinear comparison π>?.

For the constant-rounds protocol we may use the arithmetic-based compar-
ison of [NO07] while πBL is essentially the bit-decomposition of [RT10]. Thus,
these immediately work in the multiparty setting. The πtrunc protocol in Fig-
ure 4 can be jointly played by the parties. Part A is played publicly and part
B is played using the protocols of [CDN01]. First each party Pi (1 ≤ i ≤ n)
with plaintext

(cid:105)
(cid:104)
supplies an encryption of a random value(cid:2)r(i)(cid:3) as well as
(cid:4)r(i)/2k(cid:5). The parties then compute and decrypt [z] ← [ˆq] +(cid:80)n
turn [ˆq] ←(cid:4)z/2k(cid:5) −(cid:80)n

. This is the right result plus an additive error
originating from a carry in the addition of r. Since r is a sum itself, the possible
error grows linearly in the number of parties. However, as in the main protocol
(Figure 1) this may be corrected using a number of secure comparisons.

(cid:2)r(i)(cid:3) and in

r(i)(cid:62)

r(i)(cid:62)

(cid:105)

(cid:104)

i=1

i=1

With the additional requirement of two named and mutually incorruptible
parties, the sub-linear case follows analogously by the protocols of [Tof11]. Since

πBL is based on comparison and arithmetic, and πtrunc is the same as the
constant-rounds case, a sub-linear multiparty protocol is possible too.

Unconditionally secure integer division. Unconditionally secure variations of our
protocols are possible, based e.g. on Shamir’s secret sharing scheme and the
protocols of Ben-Or et al. [Sha79,BGW88]. The construction is straightforward
as all sub-protocols are applicable in this setting as well.

Improving the complexity of the sub-linear protocol. Using the other comparison
protocol given in [Tof11] we may obtain slightly better bounds on our division

protocol, namely O(log (cid:96)) rounds and O(cid:16)

√
(log (cid:96))

(cid:17)

(cid:96)(κ + log (cid:96))

communications.

References

[ACS02]

[BB89]

J. Algesheimer, J. Camenisch, and V. Shoup. Eﬃcient computation mod-
ulo a shared secret with application to the generation of shared safe-prime
products. In M. Yung, editor, CRYPTO, volume 2442 of Lecture Notes in
Computer Science, pages 417–432. Springer, 2002.
J. Bar-Ilan and D. Beaver. Non-cryptographic fault-tolerant computing in
a constant number of rounds of interaction.
In P. Rudnicki, editor, Pro-
ceedings of the eighth annual ACM Symposium on Principles of distributed
computing, pages 201–209, New York, 1989. ACM Press.

[BCD+09] P. Bogetoft, D. Christensen, I. Damg˚ard, M. Geisler, T. P. Jakobsen,
M. Krøigaard, J. D. Nielsen, J. B. Nielsen, K. Nielsen, J. Pagter, M. I.
Schwartzbach, and T. Toft. Secure multiparty computation goes live. In
R. Dingledine and P. Golle, editors, Financial Cryptography, volume 5628
of Lecture Notes in Computer Science, pages 325–343. Springer, 2009.

[Bou00]

[BGW88] M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for
noncryptographic fault-tolerant distributed computations. In 20th Annual
ACM Symposium on Theory of Computing, pages 1–10. ACM Press, 1988.
F. Boudot. Eﬃcient proofs that a committed number lies in an interval. In
Bart Preneel, editor, Advances in Cryptology – EUROCRYPT 2000, volume
1807, pages 431–444, 2000.
O. Catrina and C. Dragulin. Multiparty computation of ﬁxed-point multi-
plication and reciprocal. Database and Expert Systems Applications, Inter-
national Workshop on, 0:107–111, 2009.

[CD09]

[CDN01] R. Cramer, I. Damg˚ard, and J. Nielsen. Multiparty computation from
threshold homomorphic encryption. In Birgit Pﬁtzmann, editor, Advances
in Cryptology – EUROCRYPT 2001, volume 2045, pages 280–300, 2001.

[DFK+06] I. Damg˚ard, M. Fitzi, E. Kiltz, J. Nielsen, and T. Toft. Unconditionally
secure constant-rounds multi-party computation for equality, comparison,
bits and exponentiation.
In S. Halevi and T. Rabin, editors, Theory of
Cryptography, volume 3876 of Lecture Notes in Computer Science, pages
285–304. Springer Berlin / Heidelberg, 2006.
I. Damg˚ard and M. Jurik. A generalisation, a simpliﬁcation and some ap-
plications of paillier’s probabilistic public-key system. In K. Kim, editor,
Public Key Cryptography, volume 1992 of Lecture Notes in Computer Sci-
ence, pages 119–136. Springer, 2001.

[DJ01]

[FJ05]

[DNT12] M. Dahl, C. Ning, and T. Toft. On secure two-party integer division. Tech-
nical report, 2012. Available at www.daimi.au.dk/~ttoft/publications/.
S. From and T. Jakobsen. Secure multi-party computation on integers.
Master’s thesis, Aarhus University, 2005. Available at http://users-cs.
au.dk/tpj/uni/thesis/.

[FSW02] P. Fouque, J. Stern, and J. Wackers. Cryptocomputing with rationals. In
M. Blaze, editor, Financial Cryptography, volume 2357 of Lecture Notes in
Computer Science, pages 136–146. Springer, 2002.

[GMS10] J. Guajardo, B. Mennink, and B. Schoenmakers. Modulo reduction for
paillier encryptions and application to secure statistical analysis. In R. Sion,
editor, Financial Cryptography, volume 6052 of Lecture Notes in Computer
Science, pages 375–382. Springer, 2010.

[HAB02] W. Hesse, E. Allender, and D. A. Mix Barrington. Uniform constant-depth
threshold circuits for division and iterated multiplication. Journal of Com-
puter and System Sciences, 65(4):695 – 716, 2002.

[HKS+10] W. Henecka, S. K¨ogl, A. Sadeghi, T. Schneider, and I. Wehrenberg. TASTY:
tool for automating secure two-party computations. In CCS ’10: Proceedings
of the 17th ACM conference on Computer and communications security,
pages 451–462, New York, NY, USA, 2010. ACM.
G. Jagannathan and R. N. Wright. Privacy-preserving distributed k-means
clustering over arbitrarily partitioned data. In R. Grossman, R. J. Bayardo,
and K. P. Bennett, editors, KDD, pages 593–599. ACM, 2005.

[JW05]

[KLM05] E. Kiltz, G. Leander, and J. Malone-Lee. Secure computation of the mean
In J. Kilian, editor, TCC, volume 3378 of Lecture

[Lip03]

[NO07]

[NX10]

[Pai99]

[RT10]

[Sha79]

[Tof11]

[Veu10]

and related statistics.
Notes in Computer Science, pages 283–302. Springer, 2005.
H. Lipmaa. On diophantine complexity and statistical zero-knowledge
arguments.
In Chi-Sung Laih, editor, Advances in Cryptology – ASI-
ACRYPT 2003, volume 2894, pages 398–415, 2003.
T. Nishide and K. Ohta. Multiparty computation for interval, equality,
and comparison without bit-decomposition protocol. In Tatsuaki Okamoto
and Xiaoyun Wang, editors, PKC 2007, volume 4450 of Lecture Notes in
Computer Science, pages 343–360, 2007.
C. Ning and Q. Xu. Multiparty computation for modulo reduction with-
out bit-decomposition and a generalization to bit-decomposition. In ASI-
ACRYPT, pages 483–500, 2010.
P. Paillier. Public-key cryptosystems based on composite degree residu-
osity classes.
In Jacques Stern, editor, Advances in Cryptology – EURO-
CRYPT’99, volume 1592 of Lecture Notes in Computer Science, pages 223–
238, 1999.
T. Reistad and T. Toft. Linear, constant-rounds bit-decomposition.
In
D. Lee and S. Hong, editors, Information, Security and Cryptology - ICISC
2009, volume 5984 of Lecture Notes in Computer Science, pages 245–257.
Springer Berlin / Heidelberg, 2010.
A. Shamir. How to share a secret. Communications of the ACM, 22(11):612–
613, 1979.
T. Toft. Sub-linear, secure comparison with two non-colluding parties. In
D. Catalano, N. Fazio, R. Gennaro, and A. Nicolosi, editors, Public Key
Cryptography, volume 6571 of Lecture Notes in Computer Science, pages
174–191. Springer, 2011.
Thijs Veugen. Encrypted integer division. In IEEE Workshop on Informa-
tion Forensics and Security (WIFS’10), Seattle, 2010. IEEE, IEEE.

