GCM-SIV: Full Nonce Misuse-Resistant Authenticated

Encryption at Under One Cycle per Byte

Shay Gueron∗

Department of Mathematics

University of Haifa and Intel Corporation, Israel

shay@math.haifa.ac.il

Yehuda Lindell†

Department of Computer Science

Bar-Ilan University, Israel

lindell@biu.ac.il

ABSTRACT
Authenticated encryption schemes guarantee both privacy
and integrity, and have become the default level of encryp-
tion in modern protocols. One of the most popular au-
thenticated encryption schemes today is AES-GCM due to
its impressive speed. The current CAESAR competition is
considering new modes for authenticated encryption that
will improve on existing methods. One property of impor-
tance that is being considered more today – due to multiple
real-life cases of faulty sources of randomness – is that re-
peating nonces and IVs can have disastrous eﬀects on secu-
rity. A (full) nonce misuse-resistant authenticated encryp-
tion scheme has the property that if the same nonce is used
to encrypt the same message twice, then the same cipher-
text is obtained and so the fact that the same message was
encrypted is detected. Otherwise, full security is obtained –
even if the same nonce is used for diﬀerent messages.

In this paper, we present a new fully nonce misuse-resistant
authenticated encryption scheme that is based on carefully
combining the GCM building blocks into the SIV paradigm
of Rogaway and Shrimpton. We provide a full proof of secu-
rity of our scheme, and an optimized implementation using
the AES-NI and PCLMULQDQ instruction sets. We com-
pare our performance to the highly optimized OpenSSL 1.0.2
implementation of GCM and show that our nonce misuse-
resistant scheme is only 14% slower on Haswell architecture
and 19% slower on Broadwell architecture. On Broadwell,
GCM-SIV encryption takes only 0.92 cycles per byte, and
GCM-SIV decryption is exactly the same as GCM decryp-
tion taking only 0.77 cycles per byte. In addition, we com-
pare to other optimized authenticated-encryption implemen-
tations carried out by Bogdanov et al., and conclude that our
mode is very competitive. Beyond being very fast, our new
∗
Supported by the PQCRYPTO project, which was partially funded
by the European Commission Horizon 2020 Research Programme,
grant #645622.
†
Supported by the BIU Center for Research in Applied Cryptography
and Cyber Security in conjunction with the Israel National Cyber
Bureau in the Prime Minster’s Oﬃce.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813613.

mode of operation uses the same building blocks as GCM
and so existing hardware and software can be utilized to eas-
ily deploy GCM-SIV. We conclude that GCM-SIV is a viable
alternative to GCM, providing full nonce misuse-resistance
at little cost.

1.

INTRODUCTION

Authenticated encryption.
A symmetric encryption
scheme achieves authenticated encryption if it provides both
privacy and integrity.
Informally, such a scheme provides
the guarantee that no adversary can generate a ciphertext
that decrypts to a valid value, and that encryptions of plain-
texts are indistinguishable from each other. Classically, au-
thenticated encryption was achieved via the “encrypt-then-
authenticate” paradigm that states that one should ﬁrst en-
crypt and then apply a message authentication code to the
obtained ciphertext [5, 13]. This methodology is sound, but
is often ineﬃcient. A more general study of composition
methods, considering multiple diﬀerent options and secu-
rity goals, was carried out in [18]. However, in many cases,
dedicated modes of encryption have been proposed that are
optimized for high performance. One of the most popular
such modes used today is GCM, and it has very fast per-
formance on the latest Intel architectures. For example, it
achieves performance of 0.77 cycles per byte (C/B hereafter)
on the architecture codename Broadwell.1 Many authenti-
cated encryption modes have been proposed, and the CAE-
SAR competition currently being run is considering some of
them.

IV and nonce misuse resistance. For a long time, au-
thenticated encryption was considered the highest level of
security for symmetric encryption schemes. Indeed, with re-
spect to adversarial capabilities, this is the case. However,
it has been observed that in many cases, something can go
wrong in the encryption procedure. For example, when ran-
dom IVs are needed and encryption is carried out on devices
with weak randomness (like mobile phones), the IV may re-
peat with high probability. This same problem arises on
strong devices, where the random source is buggy. Likewise,
in nonce-based encryption schemes (where the requirement
is just that a unique nonce is used every time), the repetition

1

Broadwell (and similarly Haswell) is an Intel Architecture Codename
of a very recently announced micro-architecture. Broadwell is the 5th
Generation Intel R(cid:13) Core(cid:32)l Processor, and Haswell is the 4th Generation
Intel R(cid:13) CoreTM Processor. They can have diﬀerent conﬁgurations in
diﬀerent products. Hereafter, for short, we refer to them simply as
Broadwell and Haswell (or BDW/HSW).

109of a nonce happens in practice and compromises security.2
In order to see why repeating IVs or nonces can have disas-
trous results, consider the case that the counter is repeated
in counter-mode encryption. In this case, all security is lost
(an attacker can easily detect that this is the case, and can
just XOR the ciphertexts in order to obtain the XOR of the
plaintexts). In another example, in GCM encryption, if the
initial counter is repeated, then this also completely compro-
mises the integrity property and an attacker who views the
two encryptions can generate as many forgeries as it wishes
in the future.

These observations prompted Rogaway and Shrimpton in
a breakthrough work to deﬁne the notion of nonce misuse-
resistant authenticated encryption [20]. An encryption scheme
with this property provides an extraordinarily high level of
security. If the same nonce is used to encrypt the same mes-
sage, then this will be detected by the adversary (since the
same output will be obtained both times). Otherwise, full
security will be obtained. This means that encrypting diﬀer-
ent messages with the same nonce will reveal nothing what-
soever (except for the fact that the messages were diﬀerent).
Such an encryption scheme can be used comfortably in sce-
narios where devices cannot be trusted to generate good
quality randomness.
Indeed, it is advisable to always use
misuse resistant encryption, since low quality randomness
has shown up multiple times due to software bugs. Unfor-
tunately, nonce misuse-resistant authenticated encryption is
inherently less eﬃcient since it requires two passes over the
data.

We remark that a weaker notion of nonce misuse-resistance
has been proposed, where some more information is allowed
to be revealed in the case of a nonce repeating. Speciﬁcally,
if a nonce repeats between two messages that have a com-
mon preﬁx, then this fact is revealed, along with the length
of the common preﬁx [6]. This deﬁnition allows for achiev-
ing support for online encryption, where the encryptor does
not need to hold the entire plaintext at any time (this is im-
possible to achieve under the more stringent notion of [20]).
In this paper, we adopt the stronger notion.

In this paper, we present a new fast
Our contributions.
mode of encryption that achieves nonce misuse-resistant au-
thenticated encryption. Our mode of encryption is based on
the GCM mode of encryption, and a careful combination
of the building blocks used in GCM together with the SIV
construction paradigm of [20]; we call this mode GCM-SIV.
Our mode of operation works by ﬁrst applying GHASH (the
GCM authenticator) to the plaintext and any associated au-
thenticated data, and then applying a pseudorandom func-
tion to the result XORed with the IV. We show that this
is a pseudorandom function over the nonce, plaintext and
associated data, and thus the result can be used as the IV
in CTR mode. Therefore, this is a highly eﬃcient instanti-
ation of the IV misuse resistance mode proven in [20] (and
further abstracted in [18]).

Beyond a full speciﬁcation of the scheme and proof of se-
curity, we provide optimized implementations of GCM-SIV
and compare their performance to GCM on the Haswell and
Broadwell Intel architectures. We compare our performance
to the highly optimized OpenSSL (v.1.0.2) implementation
of GCM on the same architectures, and provide exact cycle

2

In this paper, we refer to IVs as values that must be randomly

chosen, whereas nonces must simply be non repeating.

counts. (We argue that such a detailed study is essential to
truly understand the eﬃciency of new modes of encryption.)

The advantages of our construction are:

1. Ease of deployment: Our construction uses the same
building blocks as GCM. Therefore, existing code bases
(and hardware implementations) can be used to imple-
ment GCM-SIV. This is an important consideration
when adopting new modes of operation. In addition,
our construction only uses AES encryption (and not
its inverse).

2. Encryption performance on Intel architectures:
Encryption under GCM-SIV is not far from the per-
formance of GCM. For encryption, GCM-SIV is only
14% (resp., 19%) slower than GCM on Haswell (resp.,
Broadwell). This diﬀerence is due to the fact that us-
ing the Intel AES-NI and PCLMULQDQ instructions,
the GHASH and AES operations can be run in parallel
in GCM, but must be computed one after the other in
GCM-SIV.

Concretely, our implementation runs at 1.17 cycles per
byte on the Haswell architecture, and 0.92 cycles per
byte on the recent Broadwell architecture. Thus, we
obtain full nonce misuse-resistance on the latest Intel
architecture with encryption costing less than one cycle
per byte!

3. Encryption performance on other architectures:
GCM-SIV is fast on every architecture that has sup-
port for AES-NI and carry-less multiplication, in some
form. The current trend is that such support is oﬀered
on most (if not all) the new 64-bit architectures. Some
examples are AMD (Bulldozer) and NVidia (Denver),
ARM little core (A53) and big core (A57), and Apple
(A7/A8). With this ubiquitous support, AES-GCM
(and hence our GCM-SIV) would enjoy the best per-
formance on most modern platforms.

We remark that on architectures where AES-NI is not
available (and a single thread is used), the cost of
GCM-SIV is the same as GCM alone. This is due
to the fact that the operations carried out in GCM-
SIV are almost identical to that of GCM, and on such
architectures the computation of GCM cannot be par-
allelized with a single thread.

4. Decryption performance: Decryption of GCM-SIV
has the exact same cost as decryption of GCM. This
is due to the fact that they have the same operations
and in decryption they can both be parallelized. Both
achieve rates of 0.77 cycles per byte on Broadwell.

5. Encryption of short messages: For short messages
(up to 32 bytes), GCM-SIV is actually more eﬃcient
than GCM. Thus, it is preferable for key wrapping and
in settings were many short messages are sent.

In summary, GCM-SIV achieves full nonce misuse-resistant
authenticated encryption at an extremely low cost. It has
a proof of security, and a full implementation to validate
its true cost. Finally, it is easily deployable due to existing
hardware support on a wide range of processors.

110Comparison to other full nonce-misuse resistant
schemes. We compare GCM-SIV to other schemes that
provide the same level of nonce-misuse resistance. Clearly,
GCM-SIV is much faster than the original SIV of [20] since
it uses CMAC which is not parallelizable. Therefore, on a
platform using AES-NI, the performance is dominated by
the latency of the AES-NI (7 cycles on Broadwell/Haswell),
and is 4.44 cycles per byte. Therefore, the performance of
the original SIV scheme would be at least 5 cycles per byte
on Broadwell/Haswell.

The HBS and BTM modes of operation [14, 15] have a
similar theoretical complexity to our implementation. How-
ever, our scheme is far simpler, on small messages our mode
is faster, and importantly we can reuse GCM software and
hardware which are already widely deployed. Finally, we
have a fully optimized implementation to validate our claims
of eﬃciency, whereas we are not aware of such results for
HBS and BTM.

Of the CAESAR competition candidates, the only three
that achieve full nonce misuse-resistance are AEZ [12], Julius
[2] and HS1-SIV [16]; see also [1]. On Broadwell, AEZ can
achieve (for long messages) a throughput of 0.7 C/B [12].
This relative performance advantage of AEZ over GCM-SIV
exists for encryption only, and not decryption. In addition,
AEZ meets a slightly stronger form of security, called robust
authenticated encryption. However, this comes at the cost of
relying on a nonstandard security assumption; speciﬁcally,
AEZ internally uses AES with just 4 rounds and so is not
a full block cipher operation. Julius (ECB/CTR) requires
1 AES computation plus 2 ﬁeld multiplications per block.
An optimized software implementation of Julius using the
AES-NI instruction set was carried out by [3] as discussed
below. As can be seen in Table 1, it is signiﬁcantly slower
than GCM-SIV.

HS1-SIV takes a diﬀerent approach, and is targeted at
achieving good performance on platforms that do not have
the AES-NI/PCLMULQDQ instructions (e.g., embedded sys-
tems). ChaCha20/Poly1305 is another authenticated en-
cryption scheme that targets performance on CPUs that
have no AES-NI/PCLMULQDQ. It is gaining popularity on
small-device client platforms. However, on platforms with
AES-NI/PCLMULQDQ (e.g., servers that service such con-
nections and the latest mobile devices that do have strong
CPUs with these instructions), ChaCha20/Poly1305 (stream
cipher and authenticator) is outperformed by GCM-SIV (and
AES-GCM) due to the dedicated hardware support. Opti-
mized ChaCha20 (i.e., encryption alone) consumes approx-
imately 1.04 cycles per byte on Broadwell, and the fastest
Poly1305 implementations we are aware of performs at 0.67/
0.66 C/B on HSW/BDW.This is signiﬁcantly slower than
GCM-SIV on these platforms.

In addition to the above, [19] recently presented a nonce
misuse-resistant version of OMD. Their scheme requires 2
AES operations per block, and so would cost at least 1.3
cycles per byte using optimized code and AES-NI.

Comparison to nonce-misuse AE modes on HSW. In
a recent publication [3], Bogdanov et al.
report on opti-
mized AES-NI implementations of authenticated-encryption
modes of operation on Intel Haswell architecture. In Table 1,
we show the results for the nonce misuse-resistant schemes
and compare them to ours. We note that amongst these
modes, only Julius receives full nonce misuse-resistance; the
others achieve online encryption and thus the weaker notion

Mode

128

256

512

1024

2048

Message length (bytes)

single message

McOE-G
COPA
POET
Julius

McOE-G
COPA
POET
Julius

7.77
3.37
5.30
4.18

1.91
1.62
3.24
2.53

# msgs.

7
15
8
7

7.17
2.27
4.75
3.24

7.07
7.36
2.08
2.64
4.68
4.93
3.08
4.69
multiple messages
1.64
1.76
1.46
1.53
3.24
2.79
2.09
2.27

1.68
1.48
2.98
2.16

7.02
1.88
4.62
3.03

1.62
1.45
2.75
2.06

GCM-SIV

2.20

1.66

1.41

1.28

1.22

single message

Table 1: Performance comparison of GCM-SIV
(bottom row) to the AES-NI optimized implemen-
tations of nonce misuse-resistant schemes, reported
in [3] (top rows). The measurements are on a
Haswell processor and are in cycles per byte.

of misuse resistance. The optimized implementations by [3]
are for a single message and for multiple messages processed
in parallel; see Table 1.

Observe that GCM-SIV is faster than Julius for all mes-
sage sizes, and even when considering the speed for paral-
lel multiple messages for Julius versus a single message for
GCM-SIV. The fastest mode shown by [3] is COPA [4]. Ob-
serve that GCM-SIV is signiﬁcantly faster than COPA for
all message sizes when processing a single message. In ad-
dition, for large messages (of size greater than 512 bytes),
GCM-SIV outperforms COPA, even when comparing par-
allel multiple messages for COPA to a single message for
GCM-SIV. (In contrast, for short messages COPA is up
to 25% faster for multiple messages. However, recall that
GCM-SIV achieves a higher level of security than COPA,
and COPA is only faster when processing multiple messages
in parallel.)

This comparison sheds signiﬁcant light on the eﬃciency
of GCM-SIV since it compares it to highly optimized imple-
mentations of analogous modes on exactly the same archi-
tecture.3

Organization. We use the notions of CPA-secure IV-
based encryption (ivE), nonce-based authenticated encryp-
tion (nAE), and nonce misuse-resistant authenticated en-
cryption (mrAE), as deﬁned in [20, 18]. These deﬁnitions
are repeated in Appendix A for the sake of completeness.
In Section 2 we describe the abstract SIV scheme of Rog-
away and Shrimpton [20], and in Section 3 we present and
prove the security of our speciﬁc instantiation based on any
XOR universal hash function and any pseudorandom func-
tion. Our proof includes a concrete analysis and bounds. In
Section 4, we describe the ﬁnal concrete scheme that uses
the GHASH universal hash function (from GCM) and AES.
Finally, in Section 5 we provide an in-depth analysis of the

3

We stress that McOE-G, COPA and POET do not achieve full mis-
use resistance, and only achieve a weaker notion called “online authen-
ticated encryption”. However, they do enable online encryption with
a single pass and constant memory, unlike any full misuse-resistant
scheme. Nevertheless, the comparison is helpful to understanding the
performance of GCM-SIV.

111performance of our scheme. Our analysis includes an exact
operation count, along with a description of our empirical
results. We provide actual cycle counts for diﬀerent size
messages on Haswell and Broadwell, and compare them to
the actual cycle counts of the optimized OpenSSL (v.1.0.2)
implementation of GCM.

2. THE ABSTRACT SIV ENCRYPTION

SCHEME

In [18], a number of constructions for authenticated en-
cryption were considered. The construction called A4 is a
generalisation of the SIV mode of operation [20] that has
been proven to be nonce-misuse resistant. In this section,
we describe this abstraction.
Let FK1 : {0, 1}∗ → {0, 1}n be a pseudorandom function
and let (Gen, Enc, Dec) be a CPA-secure IV-based encryption
scheme. For simplicity, we assume that all keys are of length
n. Let k be a parameter such that the maximum message
length is 2k · n bits.

Let Encode be a function that outputs a unique encoding
of its (multiple) inputs as a string. Thus Encode(x, y) fully
determines the pair of inputs x and y. We remark that
simply concatenating x with y is not a unique encoding,
since this would imply that Encode(x, y) = Encode(x(cid:107)y1, y2)
where y = y1(cid:107)y2 and (cid:107) denotes concatenation.

Construction 2.1.
• Key generation: K1, K2 ∈ {0, 1}n chosen uniformly

and independently at random

• Encryption of M with associated data A and

nonce N :

1. Compute T = FK1 (Encode(N, A, M ))
2. Let IV be the n − k most signiﬁcant bits of T ,4

and compute C = EncK2 (IV, M )

3. Output: (N, A, C, T )

• Decryption of (N, A, C, T ):

1. Let IV be the n − k most signiﬁcant bits of T .
2. Compute M = DecK2 (IV, C)
3. Compute T (cid:48) = FK1 (N, A, M )
4. Output: If T (cid:48) = T then output (A, M ); else out-

put ⊥

Security. In [18], the following is proven (this construction
is called A4 in [18]).

Theorem 2.2

(Proven in Section A.3 of [18]).

If (Gen, Enc, Dec) is a secure IV-based encryption scheme
and F is a pseudorandom function, then Construction 2.1,
denoted Π, is a secure nonce-based authenticated encryption
scheme.

Concretely, [18, Section A.3] proves that the nAE advan-

tage of any adversary A for this construction is:

AdvnAE

Π (A) ≤ Advprf

F (B(A)) + AdvivE

Enc (D(A)) +

qd
2n

4

This is not necessary in the abstract SIV scheme, but we will use

this later on.

with the following parameters. Let n be the output length
of the pseudorandom function. Let A ask qE queries to its
encryption oracle, and qd queries to its decryption oracle,
with q = qE + qd. The encryption queries have total length
Le, and the decryption queries have total length Ld, with
L = Le + Ld. Let tA be the running time of A, given
this total number and length of queries, let tF (L) be the
running-time to compute the pseudorandom function F on
inputs of length L, and likewise tEnc(L) for the underlying
ivE encryption. Then reduction B has running time at most
tA + 2tF (L) + tEnc(L), asks at most 2(qE + qd) queries to
its oracle, with total length at most L. Reduction D has
running time tA + tF (L) + tEnc(Le), asks at most qE queries
to its oracle, with total length at most Le.

Theorem 2.2 considers nonce-based authenticated encryp-
tion. However, we have to prove nonce misuse-resistant au-
thenticated encryption. In order to see that this holds, note
that the security of the nonce-based authenticated encryp-
tion holds as long as the input to the pseudorandom function
is diﬀerent each time, since this guarantees pseudorandom
output each time (up to the probability of a collision). In the
nonce-based encryption setting this is guaranteed by always
using a diﬀerent nonce. However, since the pseudorandom
function is applied to entire triple (N, A, M ) in this con-
struction, it receives a diﬀerent input each time as long as
the same (N, A, M ) is not used twice. However, this is ex-
actly what happens in the nonce misuse-resistant setting.
Thus, we conclude that the exact same security and bounds
are achieved in this setting. We conclude:

Corollary 2.3. If (Gen, Enc, Dec) is a secure IV-based
encryption scheme and F is a pseudorandom function, then
Construction 2.1, denoted Π, is a secure nonce misuse-resistant
authenticated encryption scheme. In addition,

AdvmrAE

Π

(A) ≤ Advprf

F (B(A)) + AdvivE

Enc (D(A)) +

where B, D, qd and n are as above.

qd
2n

3. THE UNIVERSAL-SIV INSTANTIATION
In this section, we describe our Universal-SIV construc-
tion, which is an instantiation of the abstract construction
provided in Section 2 as follows:

• The pseudorandom function applied to the data (as-
sociated authentication data as well as plaintext) is
constructed by computing a universal hash function
on the data, XORing in the nonce, and then applying
a pseudorandom function to the result.

• The encryption scheme used is CTR mode, where the
initial counter is n − k bits long and the remaining k
bits in the block are used for counters for a message
with at most 2k blocks of length n. Note that this
method ensures that as long as the same initial counter
is not used twice, no counter in any block is reused.

3.1 The Universal-SIV Speciﬁcation

The scheme uses the following primitives:
• An -XOR universal hash function HK1 : {0, 1}∗ →
{0, 1}n. Formally, a hash function is -XOR universal if
for every x, y, z ∈ {0, 1}∗ it holds that PrK1 [HK1 (x) ⊕
HK1 (y) = z] ≤ (n), where the probability is over the

112choice of K1. For simplicity, we assume that the key
length is n.

• A pseudorandom function FK2 : {0, 1}n → {0, 1}n; for

simplicity, we assume that the key length is n.

• A parameter k < n, where 2k · n is the maximum

message length.

• The GCM encoding function Encode(x, y). This en-
coding works by adding an additional block of 128 bits,
where the 64-bits contains the length of x and the sec-
ond 64-bits contains the length of y.

Construction 3.1. (The Universal-SIV scheme for

block length n):

• Key generation: K1, K2, K3 ∈ {0, 1}n chosen uni-

formly and independently at random

• Encryption of M with associated data A and

n-bit nonce N :

1. Step 1: Compute h = HK1 (Encode(A, M ))
2. Step 2: Compute T = FK2 (h ⊕ N )
3. Step 3: Encrypt M with CTR mode using the
pseudorandom function F with key K3. The ini-
tial counter is taken to be the n − k most sig-
niﬁcant bits of T followed by k zeroes. Denote
the initial counter by I1(cid:107)I2 where I1 ∈ {0, 1}n−k
and I2 = 0k; stated otherwise, the initial counter
equals I1 · 2n−k + I2. The jth counter is deﬁned to
be I·2n−k +[(I2 +j) mod 2k] for j = 0, . . . , 2k−1.
Denote the resulting ciphertext by C

4. Output: (N, A, C, T )

• Decryption of (N, A, C, T ):

1. Step 1: Decrypt C with CTR mode using F with
key K3, and using the n − k most signiﬁcant bits
of T as the initial counter; denote the resulting
plaintext by M .

2. Step 2: Compute h = HK1 (Encode(A, M ))
3. Step 3: Compute T = FK2 (h ⊕ N )
4. Output: If T (cid:48) = T then output (A, M ); else out-

put ⊥.5

We remark that for standard nonce-based authenticated
encryption, it would suﬃce to take T = h ⊕ FK2 (N ). How-
ever, if T is computed in this way and a nonce N is repeated
for two diﬀerent messages with hash results h, h(cid:48) then it is
possible to XOR the two tags together and obtain h ⊕ h(cid:48)
(since the mask FK2 disappears). In this case, the adversary
obtains two messages and their hash, and can forge messages
(since this suﬃces to learn the key K1 for H). For this rea-
son, we compute the tag as T = FK2 (h⊕ N ). Formally, it is
required that T be computed by applying a pseudorandom
function to (N, A, M ), as described in Construction 2.1.

5

A constant-time comparison function must be used here.

3.2 Proof of Security of Universal-SIV

Notation. We provide a concrete analysis of security,
counting the running time of the adversaries, the number
of oracle queries that they make, and their advantage. For
an adversary A we denote by t(A) its running time, and by
q(A) the number of oracle queries it makes. For the sake
of clarity, we diﬀerentiate between diﬀerent types of oracle
queries and denote by qE(A) the number of oracle queries
to the encryption oracle (where such an oracle is given), by
qD(A) the number of oracle queries to the decryption oracle
(where such an oracle is given), and by qf (A) the number
of oracle queries to the function oracle (for adversaries dis-
tinguishing a pseudorandom function from a random one).
Finally, for a function F , we denote by tF (L) the time taken
to compute F on overall inputs of length L.

Proof of security. By Corollary 2.3, in order to prove
security we need to show that

FK1,K2 (N(cid:107)M ) def= FK2 (HK1 (M ) ⊕ N )

is a pseudorandom function from {0, 1}n → {0, 1}n, when H
is an -XOR universal hash function from {0, 1}∗ → {0, 1}n.
(Note that M here includes an encoding of both the asso-
ciated data and plaintext message used in the encryption
process. We removed the explicit reference to A for clarity.)
Before proving that F is indeed a pseudorandom func-
tion, we deﬁne security for pseudorandom functions via the
following experiment:

Experiment ExptbA,F

1. If b = 0 then choose K at random and set O = FK .

Else, if b = 1, set O to be a truly random function
f : {0, 1}∗ → {0, 1}n.

2. b(cid:48) ← AO(·)
3. Output 1 if and only if b(cid:48) = b
Definition 3.2. A family of functions F is a (t, qf , δ)-
pseudorandom function if for every adversary A running in
time at most t and asking at most qf queries to its oracle it
holds that,

AdvprfF (A) def= (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12) ≤ δ.

Recall that tH (L) denotes the time to compute the univer-
sal hash function H on overall input of length L, that t(A)
denotes the running time of algorithm A, and that qf (A)
denotes the number of queries made by A to its function
oracle. We use the following lemma:

Lemma 3.3. Let F be a family of pseudorandom func-
tions from {0, 1}n to {0, 1}n, and let H be a family of -
XOR universal hash functions from {0, 1}∗ to {0, 1}n. De-
ﬁne FK1,K2 (N(cid:107)M ) = FK2 (HK1 (M ) ⊕ N ). Then, F is a
family of pseudorandom functions from {0, 1}∗ to {0, 1}n,
and there exists an adversary A1 such that for every adver-
sary A:

F (A1) +  ·(cid:16) qf (A)

(cid:17)

AdvprfF (A) ≤ Advprf

2

where t(A1) = t(A) + tH (L) · qf (A), qf (A1) = qf (A), and
the overall length of message sent by A to its oracle is L.

113Proof: Before beginning the proof, we rewrite the pseu-
dorandom function experiment using our speciﬁc scheme:

Experiment ExptbA,F (1n)

1. If b = 0 then choose K1, K2 ← {0, 1}n, and set O =

FK2 ◦ HK1 .
Else, if b = 1, set O to be a truly random function
f : {0, 1}∗ → {0, 1}n.

2. b(cid:48) ← AO(·)(1n)
3. Output 1 if and only if b(cid:48) = b
We ﬁrst change the experiment to ExptA,f,H (1n) where K1
is
chosen as above, but a truly random function
f : {0, 1}n → {0, 1}n is used instead of FK2 in the case of
b = 0 (and so O = f ◦ HK1 when b = 0). A straightfor-
ward reduction to the pseudorandomness of F yields that
for every adversary A1,

(cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[ExptA,f,H = 1](cid:12)(cid:12) ≤ Advprf

F (A1). (1)
The adversary A1 attacking the underlying pseudorandom
function invokes A, chooses K1 itself and answers every
oracle query M(cid:107)N of A by ﬁrst computing HK1 (M ) ⊕ N
and then sending the result to its oracle. If A1 received a
truly random function as an oracle, then this perfectly sim-
ulates ExptA,f,H ; in contrast, if A1 received the pseudoran-
dom function F as its oracle, then this perfectly simulates
Expt0A,F . The running time of A1 is exactly that of A plus
qf computations of H, and the number of queries made by
A1 to its oracle is exactly the same number made by A.
Thus, t(A1) = t(A) + tH (L) · qf (A), and qf (A1) = qf (A).
Next, we prove that for every adversary A making qf

(cid:12)(cid:12)Pr[ExptA,f,H (1n) = 1]−Pr[Expt1A,F (1n) = 1](cid:12)(cid:12) ≤ ·(cid:16) qf (A)

queries to its oracle,

(cid:17)

2

(2)
In order to see this, consider ﬁrst the event coll which equals 1
if and only if there exist two queries M(cid:107)N, M(cid:48)(cid:107)N(cid:48) with
M(cid:107)N (cid:54)= M(cid:48)(cid:107)N(cid:48) made by A such that HK1 (M ) ⊕ N =
HK1 (M(cid:48)) ⊕ N(cid:48). Then, it holds that

Pr[ExptA,f,H (1n) = 1 | ¬coll] = Pr[Expt1A,F (1n) = 1].

This holds because when HK1 (M ) ⊕ N (cid:54)= HK1 (M(cid:48)) ⊕ N(cid:48)
for every pair of distinct M(cid:107)N, M(cid:48)(cid:107)N(cid:48) queried by A to the
oracle, the inputs to f in Expt are all distinct. Thus, the
output distribution over f (HK1 (M )⊕N ) in Expt is the same
as the output distribution over f (M(cid:107)N ) in Expt1. Since
Pr[ExptA,f,H (1n) = 1]

= Pr[ExptA,f,H (1n) = 1 | ¬coll] · Pr[¬coll]
+ Pr[ExptA,f,H (1n) = 1 | coll] · Pr[coll]

≤ Pr[ExptA,f,H (1n) = 1 | ¬coll] + Pr[coll]

it remains to prove that

Pr[coll] ≤  ·(cid:16) qf

(cid:17)

.

2

to see this, observe that A never

In order
receives
HK1 (M ) ⊕ N , but rather receives f (HK1 (M ) ⊕ N ) where
f is a truly random function. Thus, A learns nothing about
K1. Intuitively, this means that there will be a collision on
the queries made by A with the same probability that there

will be a collision if all the queries are ﬁrst made and then
K1 is chosen at random.
In order to prove this formally,
we modify ExptA,f,H (1n) so that in the ith query, the out-
put f (i) is given (we assume without loss of generality that
A never makes the same query twice to the oracle.) Then,
at the end of the experiment, K1 is chosen at random and
HK1 (M ) ⊕ N is computed on all the values M(cid:107)N queried
to the oracle. As long as no collision takes place, the distri-
bution over the outputs that A receives is identical in both
experiments. Furthermore, if a collision occurs, then it has
already occurred and it makes no diﬀerence what happens to
A’s view afterwards (since a collision already occurred and
we are only interested in the question of whether collisions
occur). Thus, the collision probability in both experiments
is identical.
M1(cid:107)N1, . . . , Mqf (cid:107)Nqf to the oracle, we have that
Pr[coll] = Pr [∃i, j ∈ [qf ] : HK1 (Mi) ⊕ Ni = HK1 (Mj) ⊕ Nj]

In this latter experiment, for a series of qf distinct queries

Pr[HK1 (Mi) ⊕ HK1 (Mj) = Ni ⊕ Nj]

qf(cid:88)
qf −1(cid:88)
(cid:17) · .
(cid:16) qf

i=1

2

j=i+1

=

=

.

Combining Equations (1) and (2), we have that

where the probability is taken over the choice of K1 (that
speciﬁes the concrete hash function H). Note that the last
equality is obtained since H is an -XOR universal hash
function.

AdvprfF (A) = (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12)
≤ (cid:12)(cid:12)Pr[Expt0A,F = 1] − Pr[ExptA,f,H = 1](cid:12)(cid:12)
+(cid:12)(cid:12)Pr[ExptA,f,H = 1] − Pr[Expt1A,F = 1](cid:12)(cid:12)
≤ AdvprfF (A1) +  ·(cid:16) qf (A)

(cid:17)

2

and this completes the proof.

The security of counter mode based on a pseudorandom
function is well known. Here we provide the bounds for
encryption of messages with at most 2k − 1 blocks, and
where the initial counter is of length n− k bits. This ensures
that as long as the initial counters are all diﬀerent, then the
pseudorandom function is applied to a diﬀerent input each
time. Since we consider the case of random initial counters,
it follows that the probability that a counter repeats is at
2n−k , where qE(A) is the number of queries made
most qE (A)2
by adversary A to the encryption oracle. The reduction
to security is very straightforward, with the adversary for
the pseudorandom function just querying all the appropri-
ate counters to its oracle. We therefore conclude:

AdvivE

Lemma 3.4. Let F : {0, 1}n → {0, 1}n be a pseudoran-
dom function. Then, there exists an adversary A2 making
such that for every adversary A:
Enc (A) ≤ Advprf

qE(A)2
2n−k .
where t(A2) = t(A) + Le(A) and qf (A2) = Le(A)
n , with qE
being the number of queries made by A to its encryption
oracle, Le(A) being the total length of all plaintexts queried
by A to its encryption oracle, and qf being the number of
queries made by A2 to its function oracle.

F (A2) +

114We are now ready to state the main theorem that provides
the security bounds for our construction (we use Π to denote
Construction 3.1):

Theorem 3.5. Let F be a pseudorandom function, and
let H be an -XOR universal hash function. Then, Con-
struction 3.1 is a nonce misuse-resistant authenticated en-
cryption scheme, and there exists an adversary A(cid:48) for F
such that for every A attacking Construction 3.1:

(A) ≤ 2·Advprf

qd(A)
AdvmrAE
2n .
(The running time and oracle query complexity of A(cid:48) is given
in the proof.)

qE(A)2
2n−k +

F (A(cid:48)

)+·(cid:16) qE(A)

(cid:17)

+

2

Π

Π

Proof: By Corollary 2.3, we have that:
(A) ≤ AdvprfF (B(A)) + AdvivE

AdvmrAE
where F is the pseudorandom function used that combines
the universal hash and underlying pseudorandom function
F . By Lemma 3.3 we have that there exists an adversary
A1 such that

Enc (D(A)) +

qd(A)
2n

F (A1) +  ·(cid:16) qf (A)

(cid:17)

2

AdvprfF (A) ≤ Advprf

and by Lemma 3.4 we have that there exists an adversary
A2 such that

AdvivE

Enc (A) ≤ Advprf

F (A2) +

qE(A)2
2n−k .

Now, adversary B(A) is a PRF adversary who runs it time
at most t(A) + 2tF (L) + tEnc(L) (where L is the total length
of the values queried to oracles by A) and asks at most
2(qE(A) + qd(A)) queries to its oracle, and A1(B(A)) runs
in time t(B(A))+tH (L)·qf (B(A)) and asks qf (B(A)) queries
to its oracle. Thus, A1 is an adversary for the pseudoran-
dom function who runs in time t(A) + 2tF (L) + tEnc(L) +
tH (L)·2(qE(A)+qd(A)) and asks qf (A1) = 2(qE(A)+qd(A))
queries to its oracle.
Furthermore, adversary D(A) is an ivE encryption ad-
versary who runs in time t(A) + tF (L) + tEnc(L) and asks
at most qE(A) queries to its oracle. Thus, A2 is an ad-
versary for the pseudorandom function who runs in time
t(A) + tF (L) + tEnc(L) + Le(A) ≈ t(A) + tF (L) + tEnc(L) (we
can ignore the Le(A) factor since it is just the length of the
plaintext, whereas tEnc(L) is the actual cost of encryption
which is greater), and asks qf (A2) = Le(A)
n queries to
its oracle.
Take A(cid:48) to be the adversary that incorporates A1 and A2.
Then, we have that there exists an adversary A(cid:48) for the un-
derlying pseudorandom function so that for every adversary
A for the mrAE setting:

n < L

• A(cid:48) runs in time
[t(A) + 2tF (L) + tEnc(L) + tH (L) · 2(qE (A) + qd(A))]

= 2 ·(cid:16)

+ [t(A) + tF (L) + tEnc(L)]

(cid:17)
t(A) + tF (L) + tEnc(L) + tH (L) · (qE (A) + qd(A))
Observe that the running time of A(cid:48) is essentially
linear in the running time of A (under the very rea-
sonable assumption that the cost of applying the pseu-
dorandom function to the plaintexts queried by A and
encrypting them, is not more than the running time
of A itself). It is reasonable to therefore writhe that
t(A(cid:48)) ≤ 6 · t(A).

• The number of queries made by A(cid:48) to its function or-

acle is at most 2qE(A) + 2qd(A) + L

n

• The advantage of A in the mrAE setting, when reduc-

ing to the underlying pseudorandom function F , is

AdvmrAE

Π

(A) ≤ Advprf

) + Advprf

F (A(cid:48)

+ ·(cid:16) qE(A)

(cid:17)

2

+

)

F (A(cid:48)
qE(A)2
2n−k +

(3)

qd(A)
2n .

This completes the proof.

4. THE GCM-SIV INSTANTIATION

In this section, we describe our concrete instantiation of
the universal-SIV construction that uses GHASH, which is
a part of the GCM speciﬁcation. Thus, this construction
uses the exact same components as GCM in a slightly dif-
ferent way, with the result being nonce misuse resistance.
Throughout this section, we use the following lemma, that
states the GHASH is indeed a XOR universal hash function:

Lemma 4.1

(Lemma 2 in [17]). The GHASH function
n + 1(cid:101) · 2−t,

is an -XOR universal hash function with  = (cid:100) L
where L is an upper bound on the length of the input, n is
the length of the block, and t is the length of the output.
4.1 Theoretical 3-Key Instantiation

In this instantiation, we simply use the GHASH universal
hash function in Construction 3.1. This hash function works
by ﬁrst concatenating zeroes to each of A and M to make
them of length that is a multiple of the block length n. Then,
an additional block that contains the lengths of both A and
M is concatenated (where the length of A is given in the
ﬁrst n/2 bits of the block, and the length of M in the last
n/2 bits). Finally, a polynomial is evaluated over this result.
Observe that GHASH requires a key, the pseudorandom
function applied to the output of GHASH requires a key, and
ﬁnally the pseudorandom function used in counter mode re-
quires a key. Thus, this instantiation requires three separate
keys. Although this is a perfectly reasonable instantiation,
3 keys would typically be considered too much for real world
usages; we therefore refer to this as a “theoretical instantia-
tion”. Later, we present 2-key and 1-key instantiations.

When plugging GHASH directly into Construction 3.1, all
that is required is to plug in the value of  given in Lemma 4.1
into the bounds of Theorem 3.5.

Theorem 4.2

(3-Key GCM-SIV). Construction 3.1
with the pseudorandom function F and the hash function
GHASH is a nonce misuse-resistant authenticated encryp-
tion scheme. Furthermore, there exists an adversary A(cid:48) for
F such that for every A attacking Construction 3.1 making
qE encryption queries and qd decryption queries of overall
length L:

n(cid:101) + 1(cid:1) · qE(A)2 + qd(A)
(cid:0)(cid:100) L

(A)
AdvmrAE
qE(A)2
< 2 · Advprf
2n−k
where t(A(cid:48)) ≤ 6 · t(A) and qf (A(cid:48)) ≤ 2qE(A) + 2qd(A) + L
n .

F (A(cid:48)

) +

2n

+

Π

Proof: We take t = n in Lemma 4.1 and so obtain  =
n + 1(cid:101) · 2−n. Plugging this into Eq. (3) in the proof of
(cid:100) L

115Theorem 3.5, we obtain:

AdvmrAE

Π

(A)

≤ 2 · Advprf

≤ 2 · Advprf

(cid:17)
·(cid:16) qE(A)

) +  ·(cid:16) qE(A)
n(cid:101) + 1(cid:1) · qE(A)2 + qd(A)
(cid:0)(cid:100) L

qE(A)2
2n−k +

(cid:100) L
n + 1(cid:101)
2n

qd(A)
2n
qE(A)2
2n−k +

(cid:17)

) +

+

+

2

2

2qE(A)2
2n−k +

) +

2n
qE(A)2 + qd(A)

2n

F (A(cid:48)
F (A(cid:48)
F (A(cid:48)
F (A(cid:48)

qd(A)
2n
qE(A)2
2n−k

+

< 2 · Advprf

) +

≤ 2 · Advprf

where the last inequality holds since L ≤ 2k · n and so
2n ≤ 1
(cid:100)L/n(cid:101)
2n−k . The running time and number of oracle
queries are taken directly from the proof of Theorem 3.5.

In the speciﬁc AES instantiation with n = 128 and k = 32,

we conclude:

Π

AdvmrAE
2 · Advprf

(A) <
F (A(cid:48)

) +

qE(A)2

295 +

qE(A)2 + qd(A)

2128

.

Note that setting k = 32 limits the number of blocks to
be 232 and so the maximum length message that can be
encrypted is 64GB. This is standard and is used in typical
implementations of GCM.

4.2 Two-Key GCM-SIV

In this instantiation, the same key is used for the pseu-
dorandom function applied to the output of GHASH and
for the counter mode encryption (i.e., we take K2 = K3).
There are two possible ways of doing this. The ﬁrst is to
simply bound the probability that the output of GHASH
collides with a possible counter. However, this will result in
an additional birthday degradation. The other possibility
is to force the output from GHASH to always be diﬀerent
from the counters used in the encryption. This is achieved
by truncating the output of GHASH to n− 1 bits and using
an n − 1-bit nonce. Then, the most signiﬁcant bit of the in-
put to the pseudorandom function in order to generate T is
always zero. Furthermore, the initial counter is taken to be
the n− k − 1 most signiﬁcant bits of T followed by k zeroes,
and the most signiﬁcant bit is set to 1. This ensures that
the counter never overlaps with the input to the pseudoran-
dom function for generating T . From a security perspective,
this means that the same key can be reused with no aﬀect
on security at all (a single reduction for the pseudorandom
function suﬃces).

This variant yields the following bounds (obtained as in
the 3-key case while changing the exact parameters due to
the single bit):

length L:

AdvmrAE

Π

(A)

< 2 · Advprf

F (A(cid:48)

) +

qE(A)2
2n−k−2 +

qE(A)2 + qd(A)

2n−1

where t(A(cid:48)) ≤ 6 · t(A) and qf (A(cid:48)) ≤ 2qE(A) + 2qd(A) + L
n .
4.3 Single-Key GCM-SIV

In this ﬁnal instantiation, we take a single key K0 and de-
rive two keys K1 and K2 by computing K1 = AESK0 (0128)
and K2 = AESK0 (0127(cid:107)1). We then proceed as in the two-
key case. The bounds for here almost identical (with an
additional reduction for a single query to the pseudorandom
function, which is not signiﬁcant here).

5. THE PERFORMANCE OF GCM-SIV

In this section, we provide a detailed performance analy-
sis of our GCM-SIV construction together with experimental
results of an optimized software implementation, measured
on the latest high end processors with architecture code-
names Haswell (HSW) and Broadwell (BDW). The perfor-
mance of GCM-SIV depends on the message length. We
measure the length of the message |M| and the length of
the associated data |A| in bytes.
5.1 Encryption Operations

The computational cost of computing GCM-SIV is the

following sum:

GCM-SIV Encryption

= Key Derivation + GHASH + Tag Generation

+ CTR INPUT Generation + CTR ENCRYPTION

We discuss each component separately.

Key Derivation: Derivation is required only with the one-
key GCM-SIV variant (to derive K1, K2 from the input key
K0). This derivation requires expanding one AES key and
using it to encrypt 2 blocks.
GHASH: This requires a ﬁeld multiplication in GF (2128)
for every 16-byte block or part thereof (in the plaintext mes-
sage M and associated data A), plus a block containing the
data length. Thus, the number of ﬁeld multiplications equals
(cid:96) =

(cid:108) |M|+|A|

(cid:109)

+ 1.

16

Tag Generation: Generating the authentication tag from
the output of GHASH involves executing AES key expansion
with K2, and using it to encrypt a single block (the cost of
XORing with IV , and forcing the top bit to 1, is negligible).

CTR INPUT Generation: This involves preparing the
input blocks to AES in the counter-mode encryption. The
cost of forcing the top bit to 0, and incrementing the 32-
bit counters (in the least signiﬁcant quarter of the counter
block) is negligible.

CTR ENCRYPTION This is the cost of

AES op-

(cid:108) |M|

(cid:109)

16

Theorem 4.3

(2-Key GCM-SIV). Consider the above
variant of Construction 3.1 with one key for the pseudoran-
dom function F and one key for the hash function GHASH.
Then, the result is a nonce misuse-resistant authenticated
encryption scheme, and there exists an adversary A(cid:48) for F
such that for every A attacking Construction 3.1 making
qE encryption queries and qd decryption queries of overall

erations on preprepared input. (Note that the key used has
already been expanded when preparing the tag.)
5.2 Implementation Optimizations

Software implementations on high end Intel processors use
the AES-NI and the PCLMULQDQ instructions. There ex-
ist optimizations that improve the performance signiﬁcantly,

116# bytes

HSW/BDW GCM-SIV
Two keys
149 / 136
198 / 171
322 / 281
516 / 440
674 / 566
966 / 796

16
32
64
128
256
512
1,024
1,536
2,048
4,096
8,192

1566 / 1252
2159 / 1713
2751 / 2171
5118 / 4005
9862 / 7666

Full

Cycles

GCM-SIV
One key
297 / 241
318 / 284
444 / 417
645 / 568
800 / 694
1093 / 930
1695 / 1385
2274 / 1843
2869 / 2300
5244 / 4136
9994 / 7782

C/B

AES-GCM

1289 / 1263
1277 / 1318
1292 / 1335
1415 / 1371
1558 / 1417
1808 / 1730
2312 / 2108
2816 / 2416
3372 / 2842
5332 / 4354
9521 / 7388

No Init
Cycles

GCM-SIV
One key
133 / 121
178 / 153
319 / 278
282 / 262
426 / 401
722 / 626

GCM-SIV
Two keys
133 / 121
178 / 153
319 / 278
282 / 262
426 / 401
722 / 626

1315 / 1085
1907 / 1544
2498 / 1996
4867 / 3837
9611 / 7498

1315 / 1085
1907 / 1544
2498 / 1996
4867 / 3837
9611 / 7498

C/B

AES-GCM

178 / 172
219 / 217
236 / 238
293 / 266
421 / 385
760 / 651
1252 / 989
1714 / 1305
2287 / 1765
4296 / 3243
8399 / 6289

8,192

1.2/0.94

1.22/0.95

1.16/0.9

1.17/0.92

1.17/0.92

1.03/0.77

Table 2: GCM-SIV encryption performance for diﬀerent message lengths, on the Haswell and Broadwell (HSW/BDW) archi-
tectures. Comparison to the performance of AES-GCM (OpenSSL 1.0.2) is provided. The numbers are in cycles, except for the
last row which reports the performance in C/B.

compared to straightforward implementations. We brieﬂy
describe these optimizations.

1. The key derivation (required only for one-key GCM-
SIV) can be reduced by a new software optimization
that pipelines the instructions eﬃciently. We were able
to execute this derivation in 84 cycles (on HSW/BDW
architectures).

2. When the message includes more than 8 blocks, then
GHASH can be optimized by: (1) Preparing a lookup
table with “powers” of H, (2) Interleaving the polyno-
mial multiplications, and (3) Deferring the reduction
modulo Q(x) (the ﬁeld polynomial) to take place only
once per 8 blocks [10, 11]. See also [8]for an analysis
and an improved reduction method. Eﬀectively, this
reduces the cost of GHASH to (cid:96) polynomial multipli-
cations + 1
8 (cid:96) reductions, instead of (cid:96) ﬁeld multiplica-
tions. We were able to compute GHASH using this
method at the asymptotic performance of 0.56 and 0.3
cycles per byte (C/B) on HSW and BDW, respectively
(for an 8KB message).

3. For long enough messages, the encryption can operate
on 8 blocks
interleaving AESENC/
AESENCLAST instructions [7, 9]. We were able to
encrypt at the asymptotic performance of 0.63 C/B
on both HSW and BDW.

in parallel,

Remark 5.1. For long messages the setup cost is small,
and the diﬀerences between one key and two keys become
negligible. From the above data, we can predict the perfor-
mance (for long messages) to be the sum of GHASH and
encryption, which is 1.19 C/B for HSW, and 0.93 C/B for
BDW.
5.3 Theoretical Comparison to AES-GCM

AES-GCM uses CTR mode for encryption, and GHASH
for the authentication. It uses a single key, and involves a
derivation step: H = AESK (0128) and M ASK = AESK (·).6

6

The mask is XOR-ed with the GHASH result, to make it a MAC
tag. Here, · denotes the ﬁrst counter block used in AES-GCM.

When counting the number of operations, GCM and GCM-
SIV have roughly the same performance. In fact, GCM-SIV
is slightly cheaper due to a simpler counter incrementing.
However, for encryption, the main diﬀerence between GCM
and GCM-SIV is in the possible order of operations. By
deﬁnition, GCM-SIV can start AES-CTR encryption only
after the authentication tag has been computed. By con-
trast, GCM can interleave the AES and GHASH computa-
tions (for the message; not for the AAD). This enables GCM
encryption to be faster than GCM-SIV.

Note, however, that for decryption GCM-SIV can also in-
terleave the AES and GHASH computations, and so its per-
formance is identical to that of GCM.
5.4 Experimental Results

For our study, we prepared an optimized software imple-
mentation of GCM-SIV, and measured it on the Haswell
and Broadwell (HSW/BDW) architectures. The results are
summarized in Table 2. The table provides the cycles count
for GCM-SIV for various message lengths, to illustrate the
performance characteristics. They are compared to the op-
timized AES-GCM implementation of OpenSSL (1.0.2). We
note that the cost of the “Init” step in OpenSSL is approxi-
mately 1,100 cycles. This includes, among other operations
the preparation of a lookup table, keys setup, and more.
Therefore, to facilitate a more detailed comparison, Table
1 also shows the AES-GCM performance without the Init
step, as well as GCM-SIV without the initialization (this
neutralises the fact that OpenSSL carries out more opera-
tions in its Init than we do in our implementation). Needless
to say, the two-key and one-key variants are identical after
Init, as can be seen in the table.

The last row of the table shows the performance in C/B,
for a long message. Note that the measured performance
matches the predictions of Remark 5.1.

The methodology used for carrying out these measure-
ments is as follows (and is the same for GCM-SIV and AES-
GCM). The following process was repeated 30 times: com-
pute the operation 500 times for a ”warmup” (e.g., to place
code/data in the caches). Then, compute and clock the op-
eration 500 times, and take the average result. The output

117appearing in the table is the minimum value over the 30
runs. The reason that we take the minimum is to neutralize
noise caused by interrupts to the operating system.
All the runs were carried out on a system where the Intel R(cid:13)
Turbo Boost Technology, the Intel R(cid:13) Hyper-Threading Tech-
nology, and the Enhanced Intel Speedstep R(cid:13) Technology,
were disabled.

The results show that up to 32 bytes (including), GCM-
SIV with 2 keys is faster even than GCM without Init.
Therefore, for key wrap, GCM-SIV is an excellent choice.
It is also very eﬃcient for scenarios that encrypt many short
messages with the same key (since the key derivation is car-
ried out only once here and so the cost is like without Init).
For long messages, as expected, we see only a very small
diﬀerence between the 2-key and 1-key versions of GCM-
SIV, in the “full” implementation. This allows for choosing
the more cost eﬀective variant (i.e., 1 key) from the network
traﬃc viewpoint. We observe that on the latest Broadwell
architecture, the cost of GCM-SIV encryption falls below 1
cycle per byte.

For encryption, Table 2 shows that GCM-SIV is 14% slower
than AES-GCM on Haswell, and 19% slower than AES-
GCM on Broadwell. The reason for this diﬀerence is that
the optimized AES-GCM software is able to interleave AES
and GHASH computations, while GCM-SIV cannot. Recall
that nonce misuse-resistance provably requires two passes,
and thus there is an inevitable cost incurred. However, we
point out that for decryption, optimized AES-GCM and
GCM-SIV would have the same performance because the
AES and GHASH operations can be interleaved.

We comment about the performance of GCM-SIV without
initialization for 64 and 128 bytes messages. Our optimized
GHASH code prepares a lookup table to aggregate 8 block
multiplications before the reduction step. Of course, this
becomes relevant only when the message length is at least
128 bytes.
If the cost of the setup is not (including the
preparation of the table), then this leads to the seeming
anomaly in Table 2 where 128-byte GCM-SIV takes less time
than 64-byte GCM-SIV.
6. REFERENCES

[1] F. Abed, C. Forler and S. Lucks. Classiﬁcation of

the CAESAR Candidates. Cryptology ePrint
Archive, 2014/792.
http://eprint.iacr.org/2014/792.pdf.
[2] L. Bahack. Julius. http://competitions.

cr.yp.to/caesar-submissions.html, 2014.

[3] A. Bogdanov, M.M. Lauridsen and E. Tischhauser.

AES-Based Authenticated Encryption Modes in
Parallel High-Performance Software. IACR
Cryptology ePrint Archive, report 2014:186, 2014.

[4] E. Andreeva, A. Bogdanov, A. Luykx, B. Mennink,

E. Tischhauser and K. Yasuda. AES-COPA v.1.
CAESAR competition submission.

[5] M. Bellare, and C. Namprempre. Authenticated

Encryption: Relations among Notions and Analysis
of the Generic Composition Paradigm. In
ASIACRYPT 2000, Springer (LNCS 1976), pages
531–545, 2000.

[6] E. Fleischmann, C. Forler and S. Lucks. McOE: A

Family of Almost Foolproof On-Line Authenticated
Encryption Schemes. In FSE 2012, Springer (LNCS
7549), pages 196–215, 2012.

[7] S. Gueron. Intel Advanced Encryption Standard
(AES) Instructions Set, Rev 3.01. Intel Software
Network. (2012)
https://software.intel.com/en-us/
articles/intel-advanced-encryption-standard-
aes-instructions-set

[8] S. Gueron, AES-GCM for Eﬃcient Authenticated
Encryption – Ending the Reign of HMAC-SHA-1?
In Real-World Cryptography, 2013.
https://crypto.stanford.edu/RealWorldCrypto/
slides/gueron.pdf

[9] S. Gueron. Intel’s New AES Instructions for

Enhanced Performance and Security. 16th FSE
(FSE 2009), Springer (LNCS 5665), pages 51–66,
2009.

[10] S. Gueron, M. E. Kounavis. Intel Carry-Less

Multiplication and Its Usage for Computing The
GCM Mode, Rev 2.01. Intel Software Network.
http://software.intel.com/sites/default/files/
article/165685/clmul-wp-rev-2.01-2012-09-
21.pdf

[11] S. Gueron, M. E. Kounavis. Eﬃcient

Implementation of the Galois Counter Mode Using
a Carry-less Multiplier and a Fast Reduction
Algorithm. Information Processing Letters
110:549–553, 2010.

[12] V.T. Hoang, T. Krovetz and P. Rogaway. Robust
Authenticated-Encryption: AEZ and the Problem
That It Solves. In EUROCRYPT 2015, Springer
(LNCS 9056), pages 15–44, 2015.

[13] H. Krawczyk. The Order of Encryption and

Authentication for Protecting Communications (or:
How Secure Is SSL?). In CRYPTO 2001, Springer
(LNCS 2139), pages 310–331, 2001.

[14] T. Iwata and K. Yasuda. HBS: A Single-Key Mode

of Operation for Deterministic Authenticated
Encryption. In FSE 2009, Springer (LNCS 5665),
pages 394–415, 2009.

[15] T. Iwata and K. Yasuda. BTM: A Single-Key,

Inverse-Cipher-Free Mode for Deterministic
Authenticated Encryption. In Selected Areas in
Cryptography 2009, Springer (LNCS 5867), pages
313–330, 2009.

[16] T. Krovetz. HS1-SIV. http://competitions.

cr.yp.to/caesar-submissions.html, 2014.

[17] D.A. McGrew and J. Viega. The Security and

Performance of the Galois/Counter Mode (GCM)
of Operation. In INDOCRYPT 2004, Springer
(LNCS 3348), pages 343–355, 2004.

[18] C. Namprempre, P. Rogaway and T. Shrimpton.

Reconsidering Generic Composition. In
EUROCRYPT 2014.

[19] R. Reyhanitabar, S. Vaudenay and D. Viz´ar.

Misuse-Resistant Variants of the OMD
Authenticated Encryption Mode. In ProvSec 2014,
Springer (LNCS 8782), pages 55–70, 2014.

[20] P. Rogaway and T. Shrimpton. Deterministic

Authenticated Encryption: A Provable-Security
Treatment of the Key-Wrap Problem. In
EUROCRYPT 2006, Springer (LNCS 4004), pages
373–390, 2006.

118APPENDIX
A. DEFINITIONS

We use the following deﬁnitions taken from [20, 18]. We

begin by deﬁning CPA-secure IV-based encryption and nonce-
based authenticated-encryption. The diﬀerence between IV-
based and nonce-based encryption is that in the former a
random IV is used, whereas in the latter a unique nonce
is provided as input in every encryption. The guarantee
of nonce-based encryption is security is maintained as long
as the nonce used is diﬀerent each time. Beyond that, we
consider CPA security for IV-based encryption and authen-
ticated encryption for nonce-based encryption. We do this
since this is what we need for our construction. We adopt
the deﬁnition of authenticated encryption from [20, 18] who
replace the encryption oracle with a random function, and
mandate that the decryption oracle always outputs ⊥. Ob-
serve that this means that the adversary – who is given
oracle access to either the pair of oracles EncK , DecK or a
random function and ⊥ – is not allowed to query the output
of an “encryption” query to its “decryption” oracle. This is
because when given EncK , DecK the decryption query will
return the plaintext queries to EncK , whereas when given
a random function and ⊥ the decryption query will return
⊥. Thus, it will be trivial to distinguish. Nevertheless, this
restriction is without loss of generality since any adversary
who makes such queries can be converted to an adversary
who does not make such queries and succeeds with exactly
the same probability (if such a query is asked, just return
the plaintext it was generated from).

CPA-secure IV-based encryption (ivE). Let Π =
(Gen, Enc, Dec) be an IV-based encryption scheme, and let
the space of IVs be IV. Encryption involves choosing IV ←
IV uniformly at random, and then computing the determin-
istic function EncK (IV, M ). Consider the following oracles:
• Oracle EncK : upon input M ∈ {0, 1}∗, it chooses IV ←
IV at random and computes C = EncK (IV, M ). The
output is IV (cid:107)C.

• Oracle $K : upon input M ∈ {0, 1}∗, it chooses IV ←
IV at random and computes C = EncK (IV, M ). The
output is a random string of length |IV (cid:107)C|.

The advantage of an adversary A against an IV-based en-
cryption scheme is deﬁned to be:

(cid:12)(cid:12)(cid:12)PrK

(cid:104)AEncK (·) = 1

(cid:105) − PrK

(cid:104)A$K (·) = 1

(cid:105)(cid:12)(cid:12)(cid:12)

AdvivE

Π (A) =

We say that Π is a CPA-secure IV-based encryption scheme
if for every probabilistic-polynomial time adversary A there
Π (A) ≤ µ(n).
exists a negligible function µ such that AdvivE
Secure nonce-based authenticated encryption (nAE).
Let Π = (Gen, Enc, Dec) be a nonce-based encryption scheme.
Encryption is a deterministic function receiving a key K,
nonce N , associated data A and plaintext message M , and
is denoted C = EncK (N, A, M ). We denote decryption by
DecK (N, A, C). Consider the following oracles:

• Oracle $K : upon input (N, A, M ), it computes C =
EncK (N, A, M ). If C = ⊥ then the output is ⊥; other-
wise, the output is a random string of length |C|.

• Oracle ⊥: upon any input, returns ⊥.

The advantage of an adversary A against a nonce-based au-
thenticated encryption scheme is deﬁned to be:

Π (A) ≤ µ(n).

where A may not make two queries (N, M, C), (N, M(cid:48), C(cid:48))
to Enc with the same ﬁrst component (nonce), and may not
make any decryption query for a value (N, A, C) that was
obtained as output from some query to Enc. We say that Π
is a secure nonce-based authenticated encryption scheme if for
every probabilistic-polynomial time adversary A there exists
a negligible function µ such that AdvnAE
Secure nonce misuse-resistant authenticated encryp-
tion (mrAE). We deﬁne a notion of misuse resistance
for nonce-based encryption. Speciﬁcally, we deﬁne nonce
misuse-resistance where full security is guaranteed to hold as
long as the same nonce is not used for the same message and
associated data. Since nonce-based encryption is determin-
istic, when the same nonce is used for the same message and
associated data, the same ciphertext is obtained. Thus, the
only information revealed to the adversary is that the same
message was encrypted. It is immediate that nonce-based
misuse-resistant encryption implies IV misuse-resistant en-
cryption by simply using a random IV (and noting that for
q encryptions the probability that an IV repeats is q2/2(cid:96)
where (cid:96) is length of the IV).

Let Π = (Gen, Enc, Dec) be a nonce-based encryption
scheme. Encryption is a deterministic function receiving a
key K, nonce N , associated data A and plaintext message
M , and is denoted C = EncK (N, A, M ). We denote decryp-
tion by DecK (N, A, C). Consider the following oracles:
• Oracle $K : upon input (N, A, M ), it computes C =
EncK (N, A, M ). If C = ⊥ then the output is ⊥; other-
wise, the output is a random string of length |C|.

• Oracle ⊥: upon any input, returns ⊥.

The advantage of an adversary A against a nonce-based au-
thenticated encryption scheme is deﬁned to be:

(cid:12)(cid:12)(cid:12)PrK

(cid:104)AEncK (·,·,·),DecK (·,·,·) = 1
(cid:105)
(cid:104)A$K (·,·,·),⊥(·,·,·) = 1

−PrK

(cid:105)(cid:12)(cid:12)(cid:12)

AdvmrAE

Π

(A) =

(cid:12)(cid:12)(cid:12)PrK

AdvnAE

Π (A) =

(cid:105)
(cid:104)AEncK (·,·,·),DecK (·,·,·) = 1
(cid:105)(cid:12)(cid:12)(cid:12)
(cid:104)A$K (·,·,·),⊥(·,·,·) = 1

−PrK

where A may not make two identical queries to Enc (with
the same nonce, associated data and message), and may not
make any decryption query for a value (N, A, C) that was ob-
tained as output from some query to Enc. We say that Π is a
secure nonce misuse-resistant authenticated encryption scheme
if for every probabilistic-polynomial time adversary A there
Π (A) ≤ µ(n).
exists a negligible function µ such that AdvnAE
Nonce misuse-resistant authenticated encryption is the
same as nonce-based authenticated encryption with the ex-
cept that if a nonce is reused then the only damage is that
an adversary can know if the AD and plaintext message in
two messages with the same nonce are the same or diﬀerent,
but nothing more. This is because Enc is deterministic and
so a nonce reused with exactly the same associated data and
plaintext message will give the same ciphertext, whereas by
the deﬁnition above whenever either the nonce or the asso-
ciated data or the plaintext message is diﬀerent, the result
is completely diﬀerent (and indistinguishable from random).
We do not allow A to make two identical queries since the
$ oracle always returns a fresh random string and so this is
a trivial (but meaningless) distinguisher.

119