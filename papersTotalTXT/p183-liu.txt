An End-to-End Measurement of

Certiﬁcate Revocation in the Web’s PKI

Yabing Liu∗ Will Tome∗ Liang Zhang∗ David Choffnes∗ Dave Levin†

Bruce Maggs‡ Alan Mislove∗ Aaron Schulman§ Christo Wilson∗

∗Northeastern University

†University of Maryland

‡Duke University and Akamai Technologies

§Stanford University

ABSTRACT
Critical to the security of any public key infrastructure
(PKI) is the ability to revoke previously issued certiﬁcates.
While the overall SSL ecosystem is well-studied, the fre-
quency with which certiﬁcates are revoked and the circum-
stances under which clients (e.g., browsers) check whether
certiﬁcates are revoked are still not well-understood.

In this paper, we take a close look at certiﬁcate revoca-
tions in the Web’s PKI. Using 74 full IPv4 HTTPS scans,
we ﬁnd that a surprisingly large fraction (8%) of the certiﬁ-
cates served have been revoked, and that obtaining certiﬁ-
cate revocation information can often be expensive in terms
of latency and bandwidth for clients. We then study the
revocation checking behavior of 30 diﬀerent combinations of
web browsers and operating systems; we ﬁnd that browsers
often do not bother to check whether certiﬁcates are re-
voked (including mobile browsers, which uniformly never
check). We also examine the CRLSet infrastructure built
into Google Chrome for disseminating revocations; we ﬁnd
that CRLSet only covers 0.35% of all revocations. Overall,
our results paint a bleak picture of the ability to eﬀectively
revoke certiﬁcates today.

Categories and Subject Descriptors
C.2.3 [Computer-Communication Networks]: Network
Operations; E.3 [Data Encryption]: Public Key Cryp-
tosystems, Standards

Keywords
SSL; TLS; PKI; HTTPS; X.509; Certiﬁcates; Revocation;
Extended validation, Web browsers, CRLSet

1.

INTRODUCTION

The Secure Sockets Layer (SSL) and Transport Layer Se-
curity (TLS) protocols secure a signiﬁcant fraction of Inter-
net traﬃc today. Coupled with a Public Key Infrastructure

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
IMC’15, October 28–30, 2015, Tokyo, Japan.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3848-6/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2815675.2815685.

(PKI), SSL1 provides authentication via certiﬁcate chains
and private communication via encryption.

Critical to the security of any PKI is the ability to revoke
a previously-issued certiﬁcate, that is, to invalidate it be-
fore it expires. If the private key corresponding to a given
certiﬁcate were compromised, the attacker could imperson-
ate the certiﬁcate owner or eavesdrop on encrypted traﬃc
sent to the certiﬁcate owner until the certiﬁcate’s expiry
date. Even more harrowing, if an intermediate certiﬁcate
were compromised, an attacker could issue valid certiﬁcates
for any domain (and, unfortunately, such attacks have oc-
curred in the past [5,31,48]). The only recourse a certiﬁcate
owner has is to request that their Certiﬁcate Authority (CA)
create and disseminate revocations: signed attestations that
the certiﬁcate should no longer be considered valid.

Successfully revoking a certiﬁcate requires action not only
from website administrators and CAs; clients, especially web
browsers, must request and respect revocations.
If any of
these principals fail to meet their responsibilities—if admin-
istrators fail to request revocations, CAs fail to distribute
them, or browsers fail to fetch them—users risk being sus-
ceptible to impersonation attacks.

And yet, surprisingly, security practitioners have devel-
oped a strikingly negative view towards certiﬁcate revoca-
tion, even going so far as to doubt the fundamental useful-
ness of revocations [27, 28, 32, 42, 46]. These objections are
largely rooted in the costs that the various parties incur in
supporting revocations and the tradeoﬀs that clients (i.e.,
web browsers) face when they are unable to obtain the re-
vocation status of certiﬁcates. While the incentives appear
at odds with proper security, the extent to which they have
led to inaction is largely unknown. This uncertainty leads to
a chicken-and-egg problem: administrators argue that they
need not revoke because clients rarely check, while clients
argue they need not check because administrators rarely re-
voke. Without a concrete understanding of revocation in
today’s PKI, it is unclear how to break this logjam and im-
prove the PKI’s handling of certiﬁcate revocation.

In this paper, we empirically evaluate the extent to which
all three parties involved—website administrators, CAs, and
browsers—meet their revocation responsibilities. Our inves-
tigation extends prior work in the measurement of the SSL
ecosystem; to date, most studies [7, 14] have focused on live
certiﬁcates (proper key lengths, trust aggregation among
CAs, etc), and there have been few studies of the critical
revocation mechanisms available today.
In particular, we

1TLS is the successor of SSL, but both use the same certiﬁcates.
We refer to “SSL certiﬁcates,” but our ﬁndings apply equally to both.

183provide the ﬁrst end-to-end evaluation of the Web’s certiﬁ-
cate revocation ecosystem, with the following contributions:

First, we study website administrators’ revocation behavior
using 74 separate, full IPv4 port 443 scans between October
2013 and March 2015, collected by Rapid7 [40]. We select
all valid certiﬁcates from these scans, and then check their
revocation status every day, starting in October 2014. Over-
all, we ﬁnd that a surprisingly large fraction (> 8%) of these
certiﬁcates are revoked, and that almost 1% of certiﬁcates
that continue to be advertised are actually revoked. Addi-
tionally, we observe that OCSP Stapling, which addresses
many of the diﬃculties of obtaining revocation information,
is not widely deployed: only 3% of certiﬁcates are served by
hosts supporting OCSP Stapling.

Second, we examine the CA’s role in distributing certiﬁ-
cate revocation information. We ﬁnd that the most well-
established distribution method, CRLs, can impose signiﬁ-
cant bandwidth and latency overhead on clients: the median
certiﬁcate has a CRL of 51 KB, and some certiﬁcates have
CRLs up to 76 MB in size. At the same time, we observe that
checking certiﬁcate status via OCSP is signiﬁcantly cheaper
but still requires the client to delay accepting the connection
until the OCSP responder can be contacted.

Third, we examine client-side revocation checking behav-
ior, since clients are responsible for checking certiﬁcates’ re-
vocation status. We develop a test suite for web browsers
that includes 244 distinct certiﬁcate conﬁgurations. We de-
ploy this test suite to the most recent versions of all major
browsers on both mobile and desktop devices. Overall, we
ﬁnd that the fraction of times that revocation information is
actually checked is surprisingly low: Firefox only checks leaf
and EV certiﬁcates for revocations, and only if the certiﬁ-
cates have OCSP responders; all browsers except for Internet
Explorer assume that a leaf certiﬁcate is valid if revocation
information cannot be obtained; and not a single mobile
browser checks revocation information for any certiﬁcates.
In the process, we found three bugs in revocation checking
behavior and ﬁled bug reports with browser vendors.

Fourth, we examine the revocation checking policy for
Chrome in more detail, as Chrome also uses a Google-
curated subset of all CRLs called the CRLSet. Essentially,
Google pre-selects a subset of all revoked certiﬁcates and
pushes this information to Chrome browsers. Unfortunately,
our analysis shows that the CRLSet contains only 0.35% of
revoked certiﬁcates.

Taken together, our ﬁndings paint a bleak picture of cer-
tiﬁcate revocation on the Internet today. While a signiﬁ-
cant fraction of certiﬁcates are revoked, many clients will
never receive these revocations and will obliviously accept
the certiﬁcates as valid. Fortunately, our ﬁndings also point
towards potential improvements that could be implemented
in the very near term, including an improved CRLSet con-
struction based on Bloom Filters (§7).

Our analysis relied on both public sources of data and
those we collected ourselves. We make our data and our
browser “test suite” available to the research community at

http://www.sslresearch.org

2. BACKGROUND

SSL and TLS provide conﬁdentiality and integrity for the
vast majority of secure online communication. When com-

bined with a PKI, they also allow parties to authenticate
the identity of the other communicating party. In this sec-
tion, we provide a brief background of SSL/TLS and PKIs
relevant to our study, and detail the protocols that exist to
support certiﬁcate revocation. We refer the reader to the
book by Gutmann [20] for a more in-depth treatment of
these topics.
2.1 Certiﬁcates

A certiﬁcate is an attestation signed by an issuer that
binds a subject to a public key.
In the web’s PKI, the is-
suers are Certiﬁcate Authorities (CAs) such as Verisign or
GoDaddy, who possess their own certiﬁcates binding their
identities to their public keys. These CA certiﬁcates are,
in turn, signed by other CAs, and so on, terminating at a
small set of self-signed root certiﬁcates. Clients are assumed
to obtain these trusted root certiﬁcates out-of-band (e.g.,
most browsers and operating systems ship with a set of root
certiﬁcates).

The PKI does not include a widely accepted mechanism
for delegating partial authority to issue certiﬁcates to CAs.2
As a result, any CA can issue a certiﬁcate for any domain.
To verify a leaf certiﬁcate (i.e., a certiﬁcate that is not
permitted to sign other certiﬁcates, used by most websites),
a client needs to obtain a logical chain of certiﬁcates, leading
from a root certiﬁcate through zero or more intermediate
(CA) certiﬁcates, to the leaf certiﬁcate.3 The private keys
for each certiﬁcate are used to sign the certiﬁcate at the
next level, with the exception of the root (which is signed
by its own private key). To verify the leaf’s identity, the
client thus needs to verify that each certiﬁcate along this
chain has a correct signature, is still fresh (certiﬁcates have
a well-deﬁned period during which they can be accepted),
and has not been revoked.

The most common format for certiﬁcates on the Internet
today is X.509 [11], which contains an ASN.1 [34] encoding
of the certiﬁcate along with its signature. The X.509 format
allows for additional information to be supplied, including
a certiﬁcate’s serial number (unique for the issuer), the cer-
tiﬁcate’s validity period, and where to check whether the
certiﬁcate has been revoked.

Validating Identities. Ultimately, CAs exist to bind iden-
tities to public keys, and are therefore responsible for val-
idating their customers’ identities. Typically, a CA chal-
lenges an applicant to prove ownership of the domain for
which they are applying, for instance by requiring the ap-
plicant to post CA-chosen data at a URL in that domain;
this process is called Domain Validation (DV). To provide
greater assurance to clients that certiﬁcates were issued
properly, Extended Validation (EV) certiﬁcates are a mecha-
nism for CAs to assert that the identity veriﬁcation process
has followed a set of established criteria.

EV certiﬁcates follow the same format as X.509 certiﬁ-
cates, but simply contain an additional Policy Identifier
that indicates that a more thorough veriﬁcation was per-
formed. Many browsers display EV certiﬁcates diﬀerently
(typically with a green box in the address bar). As we will
see later in the paper, browsers often also perform a diﬀerent
set of revocation checks on EV certiﬁcates.

2The X.509 speciﬁcation includes the Name Constraints extension

for exactly this, but it is rarely used and few clients support it.

3Certiﬁcates can also be cross-signed [22] by other issuers for re-

dundancy, providing multiple valid chains for a given certiﬁcate.

1842.2 Revocation

Most CAs allow entities who have been issued certiﬁcates
to later request to have them revoked. Revocations are rep-
resented by attestations signed by the same CAs who issued
the corresponding certiﬁcates. CAs are also responsible for
disseminating the revocation status for all certiﬁcates they
have issued.

When a client establishes an SSL connection, the server
presents a chain of certiﬁcates as part of the SSL handshake.
In addition to verifying the chain itself, the correct behavior
of the client is to ensure that all certiﬁcates in the chain4
have not been revoked before continuing with the connec-
tion. Each certiﬁcate typically includes information about
how and where to check for revocation information (i.e., a
protocol and a URL).

There are two predominant methods for disseminating re-
vocations: Certiﬁcate Revocation Lists (CRLs) and the On-
line Certiﬁcate Status Protocol (OCSP):

CRLs. CRLs are the most well-established means of dis-
seminating revocations. A CRL is simply an ASN.1-encoded
ﬁle that contains a list of (serial number, revocation times-
tamp, revocation reason) tuples, all of which are collectively
signed by the CA. Thus, checking the revocation status of
a certiﬁcate using a CRL involves downloading the CRL ﬁle
speciﬁed in the certiﬁcate and checking whether the certiﬁ-
cate’s serial number is listed in the CRL.

Similar to X.509 certiﬁcates, each CRL contains informa-
tion specifying the range of time that it is good for; CAs are
therefore required to re-issue CRLs periodically even if no
additional certiﬁcates have been revoked. Clients can there-
fore cache CRLs, but must download an updated CRL once
they expire.

CRLs have been criticized [15] for being an ineﬃcient
means of disseminating revocation information: clients must
download information about all of the CA’s revoked certiﬁ-
cates even though they are typically only interested in the
validity status of a single certiﬁcate. Thus, CRLs impose
on CAs and clients a burden of excessive communication
overhead.

OCSP. OCSP was designed to reduce the overhead of CRLs
by allowing clients to query the CA for the revocation status
of a single certiﬁcate. OCSP allows a client to generate an
HTTP request for the status of a given certiﬁcate’s serial
number. The URL that clients should query is stated in the
certiﬁcate. The CA returns a signed response that includes
the certiﬁcate’s current status (good, revoked, or unknown5),
as well as a validity period, meaning clients can cache the
response, typically on the order of days (longer than most
CRLs).

OCSP addresses many of the ineﬃciencies of CRLs, but
still requires request(s) to the CA(s) before a certiﬁcate can
be trusted. Additionally, using OCSP reveals information
about the users’ browsing behavior to CAs, a potential pri-
vacy risk. Thus, checking the revocation status of certiﬁ-
cates via OCSP still imposes a signiﬁcant burden on clients.

4The client need not check the revocation status of the root cer-
tiﬁcate, as root certiﬁcates can only be “revoked” by removing them
from the list of trusted certiﬁcates on clients.

5The OCSP speciﬁcation [44] states that the unknown response
“indicates that the status could not be determined by this responder”.
While the correct client behavior when receiving an unknown response
is the subject of some debate, it is clear that the response does not
indicate that certiﬁcate in question should be trusted.

OCSP Stapling. OCSP Stapling is an SSL/TLS exten-
sion that allows a server to cache OCSP responses and send
them to clients as part of the SSL handshake. Thus, when
communicating with a server that supports OCSP Stapling,
a client receives both the server’s certiﬁcate and an OCSP
statement of the certiﬁcate’s validity. The client can ver-
ify the OCSP statement and therefore be assured that the
certiﬁcate is not revoked. OCSP Stapling removes most of
the latency penalty associated with verifying a certiﬁcate’s
revocation status.

Unfortunately, OCSP Stapling does not entirely remove
the latency penalty for clients, as OCSP Stapling only in-
cludes the OCSP response for the leaf certiﬁcate (the pro-
tocol does not allow the server to include cached OCSP re-
sponses for intermediate certiﬁcates). A recently proposed
extension to OCSP Stapling [37] addresses this limitation
by allowing the server to include stapled OCSP responses
for intermediates and the leaf certiﬁcate, but has yet to see
wide adoption.
2.3 Certiﬁcate Validation

Despite its critical importance for securing the integrity
of the PKI, the X.509 speciﬁcation [11] is somewhat vague
when discussing revocation checking during certiﬁcate vali-
dation. While it is clear that a client should not trust a re-
voked certiﬁcate that appears in a CRL or OCSP response,
there is an active discussion [20, 28] regarding what to do
when a client is unable to access the revocation status of
a certiﬁcate (e.g., if the browser cannot resolve the domain
name of the CRL server, if the OCSP server is down, etc).
The X.509 speciﬁcation states that, in this case, the certiﬁ-
cate should be given the status undetermined [11], but does
not specify how this should be interpreted.

For maximum security, the client should not trust the cer-
tiﬁcate chain if any of its revocation information is unavail-
able; after all, the client cannot be certain that one of the
certiﬁcates has not been revoked. But from a user’s per-
spective, this would look like the browser’s inability to load
a page that an incorrect browser would successfully load.
Thus, browser developers often soft-fail by deciding to trust
certiﬁcates when revocation information is unavailable, so
as not to rest their perceived reliability on the shoulders of
a disparate set of third-party CAs.

Soft-failing when revocation information is unavailable
may at ﬁrst appear to be an innocuous trade-oﬀ for usabil-
ity, but in practice it has surprisingly extensive implications
on the security of the PKI. Any attacker who can block a
victim’s access to speciﬁc domains (e.g., an attacker on the
same wireless network) could leverage soft-failures to eﬀec-
tively turn oﬀ the victim’s revocation checking. As a result,
some browser maintainers have concluded that requesting
revocation information in direct response to visiting a web-
site does not actually increase security [28], and have advo-
cated instead for pushing incomplete subsets of revocation
information to clients (§7).

To ensure user security, however, there is simply no re-
placement for maintaining as complete and up-to-date revo-
cation information as possible. And when it is not possible,
it is our opinion that hard-failing would better inform users
of the potential security risks, and may apply useful cus-
tomer pressure on CAs with unreliable services.6 Thus, we

6Browser maintainers have also claimed that hard-failing browsers
would also cause CRL servers and OCSP responders to become single

185maintain that revocation is a critical component of a PKI,
and in the remainder of this paper, we analyze to what ex-
tent it is supported by administrators, CAs, and clients.

3. DATA COLLECTION

In this section, we describe the data we use to understand
certiﬁcate revocation behavior, and deﬁne several terms that
we use in our analysis.
3.1 SSL Certiﬁcates

Obtaining representative statistics on certiﬁcates that are
revoked is not entirely straightforward, as revoked certiﬁ-
cates (by deﬁnition) should no longer be advertised. Thus,
simply measuring the number of entries in CRLs is suﬃ-
cient to count revocations, but does not reveal which cer-
tiﬁcates were revoked (CRLs only contain the certiﬁcates’
serial numbers). As a result, it is necessary to collect data
on advertised certiﬁcates over time, and then periodically
check to see which of the certiﬁcates have been revoked.
However, obtaining a representative sample of advertised
certiﬁcates is also diﬃcult; relying on data gathered from
passive traces [16, 23] is likely to have good coverage of pop-
ular certiﬁcates but may miss unpopular ones.

We obtain our collection of SSL certiﬁcates from (roughly)
weekly scans of port 443 over the entire IPv4 address space,
made available by Rapid7 [40]. In this paper, we use 74 scans
conducted between October 30, 2013 and March 30, 2015.
Overall, we observe 38,514,130 unique SSL certiﬁcates.

Many of the certiﬁcates that we ﬁnd in the scans are in-
valid (e.g., self-signed certiﬁcates on WiFi routers). Thus,
we pre-process the dataset by verifying all observed certiﬁ-
cates. We do so by ﬁrst building the set of all intermediate
certiﬁcates that can be veriﬁed relative to the roots.7 This
is an iterative process (as certain intermediates can only be
veriﬁed once other intermediates are veriﬁed); in the end,
we discover 1,946 intermediate certiﬁcates, which we refer
to as the Intermediate Set.

We then proceed to verify all leaf certiﬁcates using this set
of intermediate and root certiﬁcates. We conﬁgure OpenSSL
to ignore certiﬁcate date errors (as our scans cover over 1.5
years), but to fail on any other error (except revocation,
which we address later). This allows us to only keep cer-
tiﬁcates that were valid at some point in time. We ﬁnd a
total of 5,067,476 such leaf certiﬁcates; this Leaf Set is the
set of certiﬁcates that we examine throughout the remainder
of the paper. Of these, we observe that 2,291,511 (45.2%)
were still being advertised in the latest port 443 scan.
3.2 Obtaining Revocation Information

We collect our data on certiﬁcate revocations using the
revocation information present in the certiﬁcates.
In the
Leaf Set, we observe that 99.9% of the certiﬁcates list a po-
tentially reachable8 CRL distribution point, and 95.0% of
certiﬁcates list a potentially reachable OCSP responder. In-
terestingly, we ﬁnd 4,384 (0.09%) Leaf Set certiﬁcates that
have neither a CRL distribution point nor an OCSP respon-
der. These represent certiﬁcates that can never be revoked.

points of failure and attractive DDoS targets. However, CRLs and
OCSP responses are cacheable, and existing techniques for distribut-
ing static content (e.g., CDNs) can be applied to them as well.

7We use the root store in OS X 10.9.2 [35] as our set of trusted

roots; this includes 222 unique root certiﬁcates.

Figure 1: Diagram of events in a certiﬁcate’s lifetime. Two
diﬀerent timelines exist for any certiﬁcate: when it is fresh (be-
tween validity dates) and when it is alive (advertised by servers).
Certiﬁcates may also be revoked during the time they are fresh.

In the Intermediate Set, we observe that 98.9% of the cer-
tiﬁcates list a potentially reachable CRL distribution point,
while 48.5% list a potentially reachable OCSP responder.
Similar to the Leaf Set, we ﬁnd 18 (0.92%) intermediate
certiﬁcates that have no CRL distribution point or OCSP
responder.9 Being unable to revoke a CA certiﬁcate is par-
ticularly worrisome, as possessing a CA certiﬁcate’s private
key allows one to generate certiﬁcates for any Internet do-
main (and private keys for CA certiﬁcates have be inappro-
priately given out multiple times in the past [5, 31, 48]).

CRLs. For the certiﬁcates that include a CRL distribution
point, we use this CRL to obtain revocation information for
the certiﬁcate. We observe a total of 2,800 unique CRLs,
and we conﬁgure a crawler to download each of these CRLs
once per day between October 2, 2014 and March 31, 2015.

OCSP. We observe a total of 499 unique OCSP respon-
ders across all certiﬁcates. However, querying each of these
responders to check the status of each certiﬁcate is pro-
hibitively expensive, and also unnecessary in the case where
a CRL distribution point is also provided. Thus, we only
query the OCSP responders for the 642 certiﬁcates that only
have an OCSP responder provided (i.e., no CRL distribution
point). This data was collected on March 31, 2015.
3.3 Deﬁnitions

Throughout this study, we will consider a variety of events
in the lifetime of an SSL certiﬁcate. For a given certiﬁcate,
we are concerned with two interrelated timelines (Figure 1
demonstrates a few possible conﬁgurations of these time-
lines):

Fresh. We deﬁne a certiﬁcate’s fresh period to be the time
between its Not Valid Before date and its Not Valid Af-
ter date. This is the period of time in which a client will
potentially accept the certiﬁcate.

Lifetime. We consider a certiﬁcate to be alive during the
time from when we ﬁrst saw the certiﬁcate advertised (its
birth) to when we last saw it advertised (its death). Typi-
cally, the lifetime is a strict subset of the certiﬁcate’s fresh
period, but we do observe many instances where expired
certiﬁcates are still advertised.

Note that neither of these deﬁnitions account for revoca-
tions: we consider a certiﬁcate in its fresh period to still be

8We only consider http[s]:// CRL URLs, and ignore distribution

9This ﬁgure excludes root certiﬁcates, as these certiﬁcates have

points in private networks such as ldap:// and file:// URLs.

no CRL distribution points or OCSP responders by design.

timeTypical certi(cid:31)cateLifetime is a subset of validity period.Revoked certi(cid:31)cateCerti(cid:31)cate stops being advertised once revoked.Atypical certi(cid:31)cateCerti(cid:31)cate advertised after revoked and expired.Not BeforeNot AfterRevokedFresh period(between validity dates)Alive period(advertised by hosts)186fresh, and an advertised certiﬁcate to be alive, regardless
of whether or not it has been revoked. We do so because
clients that do not check revocation information will still
accept revoked fresh certiﬁcates.

4. WEBSITE ADMIN BEHAVIOR

The revocation process begins with the website admin-
istrator making a request to its CA, and oﬀering a reason
for the revocation. We begin our analysis at the source by
analyzing the frequency and reasons for revocations.
4.1 Frequency of Revocations

First, we examine the characteristics of individual certiﬁ-
cates. Figure 2 shows the fraction of fresh and alive certiﬁ-
cates that are revoked in our data set between January 2014
and March 2015. We ﬁrst observe that a surprisingly large
fraction of all fresh certiﬁcates are actually revoked: as of
this writing, over 8% of them are revoked. The majority
of these revocations are caused by the Heartbleed vulnera-
bility [52]; this shows up in the graph as the “spike” start-
ing in May 2014.10 However, even before this vulnerability,
over 1% of fresh certiﬁcates were revoked, indicating that a
non-trivial fraction of SSL certiﬁcates are revoked even in
steady-state.

Second, we observe that the fraction of alive certiﬁcates
that are revoked is much smaller—less than 1% of all alive
certiﬁcates—but still non-zero. Certiﬁcates in this category
are surprising, as it suggests that the site administrator went
to the eﬀort to revoke the certiﬁcate, but failed to update
(all of) their machines with the new certiﬁcate. Examples of
such certiﬁcates include https://west-secvpn.apple.com,
https://vpn.trade.gov, and https://gamespace.adobe.
com (the last of which is both expired and revoked).

Third, when considering only EV certiﬁcates, we observe
largely similar trends: Over 6% of fresh EV certiﬁcates are
currently revoked, and over 0.5% of alive EV certiﬁcates are
revoked. EV certiﬁcates have much stricter entity validation
requirements by CAs, so it is surprising to see that a higher
fraction of EV certiﬁcates are revoked but still advertised.

Compared to the revocation behavior shortly after Heart-
bleed [52], we ﬁnd that certiﬁcate owners quickly returned
to pre-Heartbleed behaviors, despite the fact that there were
still many vulnerable certiﬁcates that needed to be revoked.
Moreover, we ﬁnd that revocation alone may not be enough,
as there are many revoked certiﬁcates still being advertised.
Whether they have any impact on client security depends
on whether clients are downloading revocation information,
which we study in §6.
4.2 Reasons for Revocation

We have observed that a signiﬁcant fraction of all fresh
certiﬁcates are revoked, but a key question remains: Why
are these certiﬁcates revoked? Unfortunately, the reasons
for revocation are typically diﬃcult to measure; only the
certiﬁcate owners (or, potentially, the CA) knows why a
certiﬁcate is being revoked, and many administrators are
likely to consider this information to be private or sensitive.
Zhang et al. [52] used CRL reason codes—which range
from “Unspeciﬁed” to “Key Compromised” to “Privilege

10Previous work demonstrated that, a full month after Heartbleed
was announced, only about 13% of site owners that should have re-
voked did revoke [52]. Thus, an even larger fraction of fresh certiﬁ-
cates should be revoked, but are not.

Figure 2: Fraction of fresh (top) and alive (bottom) certiﬁcates
over time that are revoked (for all certiﬁcates and EV-only cer-
tiﬁcates). The large “spike” in April 2014 is due to certiﬁcate
revocations caused by the Heartbleed vulnerability. We observe
that today, over 8% of all fresh certiﬁcates are revoked, and more
surprisingly, over 0.6% of alive certiﬁcates are revoked.

Withdrawn” [11]—to attempt to gain some insight, but
found reason codes not to be particularly informative. We
repeated their methodology with our dataset, extracting the
reason code for all revocations. Even on our larger data set,
we ﬁnd a similar distribution of reason codes: in particular,
the vast majority of revocations actually include no reason
code. Thus, CRL reason codes provide some information
(and as we will see in §7, they form the basis of Google’s
decision to include the revocation in CRLSets), but should
likely be viewed with caution.
4.3 OCSP Stapling

Recall from §2.2 that OCSP Stapling was developed to ad-
dress the limitations of CRLs and OCSP. One would thus ex-
pect that OCSP Stapling has been embraced at web servers.
However, OCSP Stapling requires the website administra-
tors to enable it on their web server (unlike CRLs and OCSP,
which only involve the CA), so it is unclear how often web-
site administrators do so.

To determine what fraction of certiﬁcates are hosted on
servers that support OCSP Stapling, we use the IPv4 TLS
Handshake scans conducted by the University of Michi-
gan [49]. Each scan contains details about the port 443 SSL
handshake with every IPv4 server, including the support for
various TLS extensions. We examine the scan of March 28,
2015, and look for servers that were advertising certiﬁcates
in the Leaf Set.

Some web servers that support OCSP Stapling (e.g., Ng-
inx) may not include a staple in the response if they do not
have a valid staple cached (in this case, they will then at-
tempt to fetch a fresh staple). Thus, the scan data from
above may underestimate the fraction of servers that ac-
tually support OCSP Stapling. To measure this eﬀect, we
chose 20,000 random servers and connected to them repeat-
edly (sleeping 3 seconds between connections) to see if we
ever received a staple, and present the results in Figure 3.
Overall, the results suggest that using only a single connec-
tion is likely to underestimate the true fraction of OCSP

0.0000.0010.0020.0030.0040.0050.0060.0070.00801/1403/1405/1407/1409/1411/1401/1503/15Fraction of Alive Certsthat are RevokedDateAll CertsEV Certs0.0000.0200.0400.0600.0800.1000.120Fraction of Fresh Certsthat are RevokedAll CertsEV Certs187Figure 3: Fraction of servers observed to support OCSP Stapling
as multiple requests are made; certain servers will only provide a
staple if a fresh one is cached (note that the y-axis does not start
at 0). Using only a single request is likely to underestimate the
fraction of OCSP Stapling support by approximately 18%.

Figure 4: Fraction of new certiﬁcates that include CRL or OCSP
revocation information over time (note that the y-axis does not
start at 0). We observe that, today, almost all new certiﬁcates
contain both types of revocation information.

Stapling support by about 18%; this eﬀect should be taken
into account when interpreting our results below.

Looking at the TLS Handshake scan data, we observe
12,978,883 servers advertising fresh Leaf Set certiﬁcates (this
is larger than the number of Leaf Set certiﬁcates, as one cer-
tiﬁcate could be advertised by many servers), of which only
337,856 (2.60%) support OCSP stapling. However, this only
tells us the fraction of servers that support OCSP Stapling,
but not the fraction of certiﬁcates that we see it supported
for. Of the 2,298,778 fresh certiﬁcates advertised in this
scan, we observe that only 119,519 (5.19%) are served by
at least one server that supports OCSP Stapling, and only
70,996 (3.09%) are served by servers that all do so.

If we narrow our focus to only EV certiﬁcates, we ﬁnd
that of the 83,974 fresh EV certiﬁcates advertised during
the scan, only 2,644 (3.15%) are advertised by at least one
server that supports OCSP Stapling, and only 1,640 (1.95%)
are advertised by servers that all support OCSP Stapling.
This is a smaller fraction than all certiﬁcates, and may be
caused by many large hosting providers (commonly used by
owners of EV certiﬁcates) not supporting OCSP Stapling.

Thus, while OCSP Stapling is supported by all major
web server implementations, OCSP Stapling has still seen
very little adoption. Even taking into account the underes-
timation of OCSP Stapling support from a single-connection
scan, only about 6–7% of certiﬁcates are served by at least
one server that supports OCSP Stapling. Our results stand
in contrast to scans that focus only on popular web sites
(e.g., Qualys’ SSL Pulse [38] reports ∼20% OCSP Stapling
support), suggesting that less popular sites are signiﬁcantly
less likely to support OCSP Stapling.
4.4 Summary

Our results show that a considerable number of certiﬁ-
cates are advertised even long after they are revoked. This
should have no impact on security if clients are vigilant in
downloading revocation information, but otherwise, could
make impersonation attacks possible. Moreover, our results
suggest that website administrators rarely enable OCSP Sta-
pling, the most eﬃcient and client-friendly protocol for dis-
tributing revocations. Next, we investigate the behavior of
the distributors of revocation information: the CAs.

5. CA BEHAVIOR

Upon receiving a request to revoke a certiﬁcate, CAs are
responsible for maintaining a highly available service for dis-

seminating revocation information. In this section, we turn
our study towards the CAs by investigating the characteris-
tics of the distribution mechanisms they make available.
5.1 Availability of Revocation Information

We brieﬂy explore how the inclusion of revocation infor-
mation in certiﬁcates has evolved in Figure 4, where we
plot the fraction of new certiﬁcates that contain potentially
reachable CRL distribution points or OCSP responders each
month. We observe that CRLs have been included in almost
all certiﬁcates issued over the past four years, but that OCSP
was slower to be adopted (unsurprisingly, as it was standard-
ized much later than CRLs). Moreover, we observe a “spike”
in the prevalence of OCSP information in July 2012, corre-
sponding to the adoption of OCSP by RapidSSL (a low-cost
CA owned by GeoTrust).

These encouraging results show that, today, both forms of
revocation are included in nearly all certiﬁcates. Unfortu-
nately, both of these schemes have their shortcomings: CRLs
impose bandwidth burdens (which we investigate later in
this section), and having to query an OCSP responder im-
poses slower page-load times for browsers. As a result, there
has been push-back from both the CA and browser commu-
nities. Unfortunately, as we demonstrated in the previous
section, OCSP Stapling is still only deployed on a small frac-
tion of web servers.
5.2 Size of Revocation Information

One of the common criticisms of CRLs is the network
traﬃc required to download them. We now examine the
sizes of CRLs, and how this has evolved over time.

Recall that CRLs contain one entry for each certiﬁcate
that is revoked. Thus, the size of the CRL (in bytes) is
expected to correlate with the number of entries. We plot
this correlation as a scatterplot in Figure 5, and observe a
strong linear relationship (except for CRLs with just a few
entries, which have some ﬁxed overhead).11 On average,
each entry is 38 bytes.

Figure 5 suggests that most CRLs are small. We explore
this trend further in Figure 6, which presents the CDF of
CRL sizes as the Raw line. We immediately observe that
half of all CRLs are under 900 B. However, this statistic is
deceiving: if you select a certiﬁcate at random from the Leaf

11The variance between CRL sizes at the same number of entries
is largely due to diﬀerences in serial number assignment policies for
diﬀerent CAs; some CAs use serial numbers of up to 49 decimal digits,
which results in larger CRL ﬁle sizes.

 0.8 0.82 0.84 0.86 0.88 0.9 0.92 0.94 0.96 0.98 1 1 2 3 4 5 6 7 8 9 10Fraction of Servers Observedto Support OCSP StaplingNumber of Requests 0.65 0.7 0.75 0.8 0.85 0.9 0.95 101/1107/1101/1207/1201/1307/1301/1407/1401/15Fraction of New Certificateswith Revocation InformationDate Certificate IssuedRapidSSL beginssupporting OCSPCRLOCSP188Figure 5: Scatterplot of the number of entries in CRLs versus
CRL ﬁle size, for all 2,800 CRLs we crawled. As expected, a
linear correlation is observed.

Set, it is unlikely to point to a tiny CRL, since the tiny CRLs
cover very few certiﬁcates. To adjust for this issue, we plot
the CRL size per certiﬁcate as the Weighted distribution in
Figure 6.12 The Weighted distribution tells a diﬀerent story:
the CRL size for the median certiﬁcate is 51 KB, and we ob-
serve CRLs ranging up to 76 MB.13 Although one can argue
that weighing CRLs is unfair (as clients can cache them),
95% of CRLs expire in less than 24 hours [52], reducing a
client’s ability to save bandwidth through caching.

One mechanism that CAs can use to reduce the size of
CRLs is to maintain multiple CRLs [20], assigning only a
subset of all issued certiﬁcates to each CRL. We explore the
extent to which diﬀerent CAs do this in Table 1, and observe
that, in general, CAs use only a small number of CRLs.
The CA that uses this technique to the largest extent is
GoDaddy with 322 unique CRLs, but given the large number
of GoDaddy revocations, their average certiﬁcate’s CRL is
still over 1MB in size. Moreover, the trend is not entirely
consistent, as various CA policies will aﬀect the resulting
CRL size.14

Our ﬁndings conﬁrm that fetching CRLs can be an ex-
pensive operation for clients, especially ones on bandwidth-
constrained networks (e.g., mobile devices). Moreover, prop-
erly verifying a certiﬁcate requires the client to download the
CRL before fully establishing the SSL connection; thus, for
interactive applications like web browsers, downloading the
CRL also comes with a latency penalty. The large size of
CRLs is especially glaring when compared to the size of an
OCSP query and response (which is typically less than 1 KB
and often comes with a latency penalty under 250 ms [33]).
5.3 Summary

Overall, our results show that, while there are potentially
high costs involved in disseminating revocation information,
many CAs have not widely adopted smaller CRLs. Com-
bined with the lack of wide OCSP Stapling adoption, we see
that there are multiple opportunities to signiﬁcantly lower
the costs incurred by CAs and browsers when obtaining cer-
tiﬁcate revocation information.

12For certiﬁcates that have multiple CRLs, we pick the smallest.
13The 76 MB CRL is hosted by Apple at http://crl.apple.com/

wwdrca.crl and contains over 2.6 million revoked certiﬁcates.

14One notable example in the table is StartCom, which has an out-
sized average CRL size relative to the number of revocations. This is
due to a single CRL (http://www.startssl.com/crt1-crl.crl) that is
over 22 MB and has over 290 K revocations. This CRL is for StartSSL
“Free” certiﬁcates that, after a year of validity, require customers to
revoke an expiring certiﬁcate (at a fee of $24.90) before a new certiﬁ-
cate for the same domain will be reissued [45].

Figure 6: Cumulative distribution of the sizes of CRLs (shown
under the raw line). Most CRLs are small (median size is less
than 1 KB), but most CRLs cover few certiﬁcates. The weighted
distribution shows the CRL size distribution across certiﬁcates;
in this case, the mean certiﬁcate has a CRL size of 51 KB.

6. CLIENT BEHAVIOR

Recall that the burden of certiﬁcate validation is placed
entirely on the client: it is up to the client to check the va-
lidity of the presented certiﬁcate chain and to obtain revo-
cation information from CAs to make sure that none of the
certiﬁcates have been revoked. We now explore the extent
to which the most popular SSL clients—web browsers—do
so. Because web browser developers care deeply about min-
imizing latency, and (as we observed above) checking certiﬁ-
cate revocation information can take signiﬁcant eﬀort, web
browser developers have a strong tension between minimiz-
ing latency and ensuring security.
6.1 Methodology

Our goal is to build a test harness that is able to de-
termine whether a web browser chooses to check certiﬁcate
revocation information for a variety of diﬀerent kinds of cer-
tiﬁcates and chains. Ideally, we would like to use real certiﬁ-
cates, but doing so would require obtaining access to a real
intermediate certiﬁcate (an unlikely prospect). Instead, we
generate our own root certiﬁcate and install it so that the
web browser trusts it. This allows us to then generate and
sign intermediate and leaf certiﬁcates as we wish.

We build a test suite that covers many combinations of
chain length, protocols, etc. For each test, we generate a
unique set of certiﬁcates (i.e., the intermediates and leaf cer-
tiﬁcates are not re-used across tests, in order to eliminate
caching eﬀects). Each intermediate contains a unique sub-
ject name, and each leaf contains a unique common name.
Each test is served by a dedicated Nginx web server. When
generating test cases, we consider four diﬀerent dimensions:

CA

GoDaddy
RapidSSL
Comodo
PositiveSSL
GeoTrust
Verisign
Thawte
GlobalSign
StartCom

Unique
CRLs
322
5
30
3
27
37
32
26
17

Certiﬁcates

Total Revoked
277,500
2,153
7,169
8,177
3,081
15,438
4,446
24,242
1,752

1,050,014
626,774
447,506
415,075
335,380
311,788
278,563
247,819
236,776

Avg. CRL
size (KB)
1,184.0
34.5
517.6
441.3
12.9
205.2
25.4
2,050.0
240.5

Table 1: Number of CRLs, certiﬁcates (total and revoked), and
the average CRL size per certiﬁcate for the largest CAs.

 0.1 1 10 100 1000 10000 100000 1 10 100 1000 10000 100000 1e+06 1e+07CRL Size (KB)Number of Revocations in CRL 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0.1 1 10 100 1000 10000CDFCRL Size (KB)RawWeighted189Chrome 44

Firefox

Opera

OS X Win.

Lin.

40

12.17

31.0

Safari

6–8

IE
10

7–9

11

iOS Andr. 4.1–5.1
6–8
Stock Chrome

IE
8.0

Desktop Browsers

Mobile Browsers

Int. 1

Int. 2+

Leaf

Int. 1

Int. 2+

Leaf

CRL
Revoked
Unavailable
Revoked
Unavailable
Revoked
Unavailable

OCSP
Revoked
Unavailable
Revoked
Unavailable
Revoked
Unavailable

Reject unknown status
Try CRL on failure

OCSP Stapling

Request OCSP staple
Respect revoked staple

ev
ev
ev

ev


ev

ev

ev


ev






ev

ev


ev

ev

ev


ev




ev
–
ev
–
ev
–

ev
–
ev
–
ev
–
–
–



–








ev

ev





































l/w







l/w



l/w



















–

























a






a







































–
–



–















–
–

i

–















–
–

i

–















–
–



–

Table 2: Browser test results, when intermediate (Int.) and leaf certiﬁcates are either revoked or have revocation information unavailable.
 means browser passes test in all cases;  means browser fails test in all cases. Other keys include ev (browser passes only for EV
certiﬁcates), l/w (browser passes only on Linux and Windows), a (browser pops up an alert), and i (browser requests OCSP staple but
ignores the response).

Chain Length. Recall that a certiﬁcate chain starts at a
root certiﬁcate, has 0 or more intermediates, and ﬁnally con-
tains a leaf certiﬁcate. As certiﬁcate chains get longer (i.e.,
more intermediates), revocation checking becomes more ex-
pensive for the client. We therefore generate tests that con-
tain between 0 and 3 intermediate certiﬁcates (between 2
and 5 total certiﬁcates, including the root and leaf), with
separate tests where each element of the chain is revoked.

Revocation Protocol. Browsers may treat diﬀerent revo-
cation protocols diﬀerently, so we generate some certiﬁcate
chains that only contain CRL information and others that
only contain OCSP information (i.e., for each chain, all cer-
tiﬁcates contain either CRL distribution points or OCSP
responders), as well as some chains that contain both. We
also implement tests where the server is conﬁgured to per-
form OCSP Stapling if the client requests it.15,16

Extended Validation. Browsers may have special rules
for EV certiﬁcates, so we generate additional tests where the
leaf certiﬁcate contains an object identiﬁer (OID) indicating
that it is an EV certiﬁcate.17

Unavailable Revocation Information. Finally, if the
browser is unable to fetch certiﬁcate revocation informa-
tion (e.g., the OCSP responder or CRL server is down), the
browser must choose whether or not to accept the certiﬁcate
or to try and obtain revocation information using a diﬀerent

15In this case, the OCSP responder is ﬁrewalled from the client, so
the only way the client can access the revocation information is via
the stapled OCSP response.

16By default, Nginx refuses to staple an OCSP response that con-
tains the status revoked or unknown. We modiﬁed Nginx to disable
this behavior.

17We use OID 2.16.840.1.113733.1.7.23.6, an OID used by Verisign

to distinguish EV certiﬁcates.

protocol. We generate additional tests where the revocation
information is unavailable due to four diﬀerent failures: the
domain name of the revocation server does not exist, the
revocation server returns a HTTP 404 error code, the re-
vocation server does not respond, or the OCSP responder
generates a response with status unknown.

Considering all possible combinations, the result is a suite
of 244 diﬀerent tests. When running tests, we also capture
network traces to examine the SSL handshake and commu-
nication with revocation servers.
6.2 Test Suite Implementation

We implement our test suite with a script that,

for
each test, (1) generates a unique DNS name, (2) uses
OpenSSL to generate a certiﬁcate chain and CRLs, (3) con-
ﬁgures OpenSSL OCSP responders18 (if OCSP is used), and
(4) generates an Nginx server conﬁguration for the test.
Thus, each test has a dedicated DNS name, Nginx instance
to serve the certiﬁcate chain, and set of OCSP responders.
We create a web page containing JavaScript that iter-
atively tries to fetch a ﬁle from each test’s domain using
XHRs.19 If the browser determines that one of the certiﬁ-
cates has been revoked, the ﬁle fails to load and our script
gets an error callback. Thus, we can programmatically de-
termine the tests where the browser checks the revocation
status of diﬀerent certiﬁcates.
6.3 Desktop Browsers

We begin by examining the behavior of popular desktop
web browsers. For each browser/OS combination, we create

18By default, the OpenSSL OCSP responder implementation only
supports POST OCSP queries; we modiﬁed it to also support the more
commonly used GET queries.

19Our Nginx instances were conﬁgured to enable CORS.

190a distinct virtual machine (VM), conﬁgured with the default
settings. Our only VM conﬁguration was to install our root
certiﬁcate.20 Unless otherwise stated, all tests were done on
Ubuntu 14.04, Windows 8.1, and OS X 10.10.2. Overall,
we tested 30 diﬀerent combinations of OS and browser; our
results are summarized in Table 2.

Chrome. Chrome uses the Mozilla NSS library [1] for SSL
connection establishment, but it uses platform-speciﬁc li-
braries for certiﬁcate validation [3]. Because Chrome aggres-
sively auto-updates (i.e., it checks for new versions every few
days), we only test with the latest version of Chrome (44.0).
On OS X, Chrome treats EV and non-EV certiﬁcates dif-
ferently. For non-EV certiﬁcates, Chrome does not check
any revocation information. For EV certiﬁcates, Chrome
checks all elements of the chain (using either CRLs or
OCSP responders). Chrome does request OCSP staples,
but Chrome does not respect OCSP staples with the sta-
tus of revoked (instead, it attempts to contact the OCSP
responder), and it incorrectly treats OCSP responses with
the unknown status as trusted. When certiﬁcate revocation
information is unavailable, Chrome does try to fetch revo-
cation information from the CRL if the OCSP responder is
not available. If revocation information is still unavailable,
Chrome only rejects the chain if the ﬁrst intermediate’s CRL
is unavailable and the leaf is an EV certiﬁcate. Otherwise,
Chrome silently accepts the certiﬁcate.

On Windows, Chrome also treats EV and non-EV cer-
tiﬁcates diﬀerently. For non-EV certiﬁcates, Chrome only
checks the ﬁrst intermediate in the chain, and only if it
only has a CRL listed (Chrome does not check any non-EV
OCSP responders). For EV certiﬁcates, Chrome checks the
revocation status of all elements of the chain, both OCSP
and CRLs. Additionally, Chrome requests OCSP staples on
Windows for all certiﬁcates. Chrome’s behavior when cer-
tiﬁcate revocation information is unavailable or when the
revocation status is unknown is the same as above, except
that it rejects the chain for non-EV certiﬁcates as well.

On Linux, we were able to import our root certiﬁcate,
but we were unable to get Chrome to use our root certiﬁ-
cate to verify CRL or OCSP signatures (i.e., we observed
that Chrome would request the same certiﬁcate revocation
information multiple times). As a result, we rely on packet
traces to measure Chrome’s behavior, and are unable to test
Chrome with unavailable revocation information or diﬀerent
OCSP response statuses. Overall, we found that Chrome’s
behavior is largely consistent with the other platforms:
it
only checks CRLs and OCSP responders for EV certiﬁcates,
and does request OCSP staples.

In addition to the distribution mechanisms analyzed in
this section, Chrome also has a built-in list of revoked cer-
tiﬁcates called the CRLSet; we explore CRLSets in more
detail in §7.

Firefox. Firefox uses Mozilla’s NSS library [1]. We tested
the most recent version of Firefox (40.0) and found it to
have the same behavior on all platforms.21 Firefox does not
check any CRLs. For OCSP, Firefox treats EV and non-

EV certiﬁcates diﬀerently: for Non-EV certiﬁcates, Firefox
only queries the OCSP responder of the leaf certiﬁcate. For
EV certiﬁcates, Firefox checks all OCSP responders. Firefox
correctly rejects OCSP responses with the unknown status,
but does not try to fetch the CRL if the OCSP responder
is not available.
Instead, if the revocation information is
not available, Firefox accepts the certiﬁcate. Firefox does
request OCSP staples.

Opera. In mid-2013, Opera re-architected its browser: up
through version 12.17, Opera used its own rendering en-
gine; for all versions afterwards, Opera uses a fork of the
Chromium project. These two versions have diﬀerent be-
havior, and we examine them separately.

On Opera 12.17, the behavior is consistent across all OSes.
Opera checks the revocation information for all certiﬁcates
in the chain if they have CRLs listed, but only the leaf
certiﬁcate if the certiﬁcates have OCSP responders listed.
If certiﬁcate revocation information is not available, Opera
accepts the certiﬁcate. Opera correctly rejects OCSP re-
sponses with the unknown status, and requests OCSP staples
on all platforms.

On Opera 31.0, the behavior is largely consistent across
all OSes: Opera checks all certiﬁcates in the chain when
certiﬁcates have CRLs or OCSP responders listed.
If the
revocation information is not available for the ﬁrst interme-
diate certiﬁcate (or the leaf certiﬁcate if no intermediates
exist), Opera rejects the certiﬁcate on all platforms (if using
CRLs) and only on Linux and Windows (if using OCSP);
in all other cases, Opera accepts the certiﬁcate. Opera in-
correctly treats OCSP responses with the unknown status
as trusted. Opera requests OCSP staples on all platforms;
however, on OS X (similar to Chrome) Opera does not re-
spect revoked staples and attempts to contact the OCSP
responder directly.

Safari. We examined the three most recent major versions
of Safari (6.0–8.0) and found them all to have the same be-
havior.22 Safari checks all certiﬁcates in the chain using
CRLs or OCSP. Safari incorrectly treats OCSP responses
with the unknown status as trusted. Safari does attempt
to fetch the CRL if the OCSP responder is unavailable. If
the revocation information is not available for the ﬁrst in-
termediate certiﬁcate (or the leaf certiﬁcate, if there are no
intermediates) and the certiﬁcate has a CRL, Safari rejects
the certiﬁcate; in all other cases, it accepts the certiﬁcate.
Safari does not request OCSP staples.

OS X oﬀers system-wide settings via Keychain Access that
allow users to change certiﬁcate revocation checking behav-
ior. The default behavior, which we used in our above analy-
sis, is referred to as “Best attempt”. If a user selects “Require
if certiﬁcate indicates”, Safari does indeed reject all chains
where any of the revocation information is unavailable.

Internet Explorer. We tested every major version of In-
ternet Explorer (IE) between 7.0 (on Vista) to 11.0 (on Win-
dows 10, 8.1, and 7). We found that the behavior of IE
changed between version 9.0 and 10.0, and again with IE
11.0; we therefore consider them separately.

20We must create separate VMs for each browser/OS, as some
browsers use system-wide libraries and daemons for checking revo-
cation information, which can lead to caching eﬀects at the OS level.
21Firefox contains a hardcoded list of root certiﬁcates that are
allowed to issue EV certiﬁcates. We recompiled Firefox 40.0 after
adding our root certiﬁcate to Firefox’s list.

22We observed strange behavior with the most recent Safari/OS
X update (8.0.5/10.0.3). With this update, Safari does not check
any CRLs and only checks OCSP responders for EV certiﬁcates. The
release notes do not mention any SSL policy changes, so we believe
this behavior to be a bug; we have ﬁled a bug report with Apple.

191On IE 7.0–9.0, IE checks all certiﬁcates in the chain for
both CRLs and OCSP responders. If the OCSP responder
is unavailable, IE does download the CRL. If the revoca-
tion information is not available for the ﬁrst certiﬁcate in
the chain, IE rejects the certiﬁcate; in all other cases, IE ac-
cepts the certiﬁcate. IE incorrectly treats OCSP responses
with the unknown status as trusted. IE does request OCSP
staples.

On IE 10.0, IE has the same behavior except that when
revocation information is not available for the leaf certiﬁcate,
IE pops up a warning to the user and asks them if they wish
to proceed.

On IE 11.0, IE has the same behavior except that when
revocation information is not available for the leaf certiﬁ-
cate, IE correctly rejects the certiﬁcate without popping up
a warning.

In summary, we observe that no browser in its default con-
ﬁguration correctly checks all revocations and rejects certiﬁ-
cates if revocation information is unavailable (as described
in §2.2). In fact, many browsers do not bother to check re-
vocation information at all. Overall, Internet Explorer per-
forms the most checks, followed closely by Safari and newer
versions of Opera.

We also found that many browsers do not correctly in-
terpret unknown OCSP responses, not all browsers support
OCSP Stapling, and many do not understand revoked sta-
ples. This is surprising, as OCSP Stapling is the most ef-
ﬁcient way of obtaining certiﬁcate revocation information,
and it imposes almost no extra latency on clients.
6.4 Mobile Browsers

Next, we study the certiﬁcate revocation checking behav-
ior of browsers on mobile devices. To make the tests easier
to conduct, we use the device simulators provided by the OS
vendors where possible, rather than physical devices. These
simulators run a full version of the mobile OS, allowing us
to easily test multiple versions.

iOS. We begin by checking the behavior of Mobile Safari on
iOS. We used the Xcode-based iOS simulator to test iOS 7
and 8, and use a physical iPhone 3GS device for iOS 6.23
We observe that Mobile Safari does not check any certiﬁcate
revocation information, nor does it request OCSP staples.

Android. We test the certiﬁcate revocation checking be-
havior of Android by using the Android Emulator. We test
the “stock” Browser app and Chrome on the three most re-
cent versions of Android: Lollipop (5.1), KitKat (4.4), and
Jelly Bean (4.3). Similar to iOS, we ﬁnd that neither appli-
cation checks any certiﬁcate revocation information. How-
ever, by examining the network traﬃc, we found that both
applications do request OCSP staples, but do not use them
in certiﬁcate validation. Even when served an OCSP staple
with status revoked, both applications validate the certiﬁ-
cate and continue with the connection.

We also attempted to test the Android port of the Firefox
browser, but were unable to successfully import our root
certiﬁcate into the application.

Windows Phone. Finally, we tested the mobile version
of IE running on Windows Phone 8.0 using the Windows

23The iPhone simulator for iOS 6 does not provide an option for

Phone Emulator. Mobile IE performs identically to all other
tested browsers, not checking revocation information and
not requesting OCSP staples.

Overall, our results on mobile devices are disheartening. De-
spite the increasing fraction of web traﬃc that is generated
by these devices, none of the major web browsers bother to
check whether any certiﬁcates they are presented with are
revoked. This design decision is likely driven by the higher
cost (in terms of latency and power) of obtaining revocation
information on a mobile device [20]. However, this decision
does not excuse the universal lack of proper OCSP Stapling
support, as requesting OCSP staples for the leaf certiﬁcate
requires the client to create no additional connections.
6.5 Summary

If clients do not fetch and respect revocation information,
the revocation eﬀorts of website administrators and CAs are
wasted. To analyze client behavior, this section presented
our test suite, and the results from all major desktop and
mobile browsers. While we see widely disparate behavior—
often even among the same browser on diﬀerent platforms—
we ﬁnd that no browser meets all necessary criteria for re-
vocation checking. Moreover, we empirically demonstrate
the extent to which EV certiﬁcates are validated diﬀerently.
Perhaps most concerning is the fact that no mobile browsers
check for revocations at all.

For desktop browsers, it is diﬃcult to determine whether
the absence of revocation checking is an explicit design de-
cision or a set of common bugs. For mobile browsers, on
the other hand, we believe the complete lack of revocation
checking is an explicit decision to conserve users’ bandwidth.

7. CRLSETS

In response to the cost of obtaining revocation informa-
tion, Google adopted an additional approach in 2013 called
CRLSets [26]. Chrome checks a small, pre-populated list of
revoked certiﬁcates. This list is updated and sent to clients
out-of-band, thus eliminating the cost of checking revocation
information at page load time.

In this section, we characterize CRLSets and investigate
their impact on security in the face of revocations. While
CRLSets currently aﬀect only users of the Chrome browser,
this approach has recently been adopted by Firefox in the
OneCRL [41] project24, so understanding the implications
of this approach can have a signiﬁcant impact on a large
number of web users.
7.1 Overview and Methodology

The high-level CRLSet approach is documented [2], but
the process used for generating them is not public. Impor-
tantly, the developers state that: (1) the size of the CRLSet
ﬁle is capped at 250 KB; (2) they populate it using an “in-
ternal list of crawled CRLs” (some of which are not public)
fetched on the order of hours; (3) if a CRL has too many
entries it will be dropped from the CRLSet; and (4) revoca-
tions are included only if they use one of a small number of
reason codes25 (we refer to these as CRLSet reason codes).
CRLSet ﬁles are published to a public URL and fetched
periodically by Chrome. We fetched these ﬁles once per

24In contrast to CRLSets, OneCRL is for intermediate certiﬁcates.

As of this writing, there are only 8 revoked certiﬁcates on the list.

25No reason code, Unspeciﬁed, KeyCompromise, CACompromise,

installing root certiﬁcates.

or AACompromise

192Figure 7: Cumulative distribution of the fraction of a CRL’s
entries that appear in CRLSets. Also shown are just those entries
that have CRLSet reason codes. Most certiﬁcates with “valid”
reasons are included the CRLSet, but most CRL entries overall
are missing.

Figure 8: Number of entries in the CRLSet over time (note that
the y-axis does not start at 0). The peak of nearly 25,000 entries
is due to the Heartbleed vulnerability; since then the size of the
CRLSet has decreased over time by more than a third.

day between September 23, 2014 and March 31, 2015, and
crawled 110 historical CRLSets originally published between
July 18th, 2013 and September 23, 2014; in total our dataset
contains 300 unique CRLSets. CRLSets are internally or-
ganized as a list of key/value pairs, where the key is the
SHA256 of the certiﬁcate issuer’s public key (which we call
the parent), and the values for that key are all the serial
numbers of revoked certiﬁcates signed by that parent.26

Mapping a revoked certiﬁcate in a CRLSet to a CRL is
nontrivial because CAs can have multiple signing certiﬁ-
cates, public keys, and CRLs. When comparing CRLSet
entries with CRLs (using the data described in §3.2), we
compare the entries in the CRLSet for each parent with the
entries in all CRLs for certiﬁcates signed by that parent.
7.2 CRLSet Coverage

We ﬁrst determine the fraction of CAs covered by
CRLSets. In our CRL dataset, we see 2,168 CA certiﬁcates
(both intermediate and root) with 1,584 distinct public keys.
In CRLSets, we observe 62 unique parents. Thus, CRLSets
cover revocations for only 3.9% of CA certiﬁcates.27 Of those
62, we can only map 52 to a CA certiﬁcate that we know of;
the remainder are likely from non-public CA certiﬁcates.

Next, we investigate how entries in CRLSets compare with
those in CRLs. Across all CRLs we crawled, we observe
11,461,935 revoked certiﬁcates; only 41,105 of these appear
in CRLSets. Thus, only 0.35% of all revoked certiﬁcates
ever appear in the CRLSet. Additionally, of the 2,800 total
CRLs we observed, only 295 (10.5%) have ever had any entry
appear in a CRLSet (this number is larger than the number
of parents, as a given parent can sign multiple CRLs). We
refer to these CRLs as covered CRLs.

Covered CRLs. For the covered CRLs, we examine the
fraction of their entries that appear in the CRLSet. Fig-
ure 7 presents the cumulative distribution of CRLSet cov-
erage across covered CRLs. Since the Chromium project
states that only revocations with a certain reason codes will

26CRLSets also include a small set of leaf certiﬁcates that are ex-
plicitly blocked based on their public key; this list is called BlockedSP-
KIs. The list current contains 11 such certiﬁcates. Curiously, Chrome
44.0 declares these certiﬁcates as revoked in the URL Status Bar, but
still completes the connection and renders the page. For an example,
please see https://revoked.grc.com/ and the corresponding discus-
sion [8]. We have ﬁled a bug with the Chrome developers regarding
this behavior.

27We cannot say precisely what fraction of CAs are represented in

CRLSets, as CAs often have many keys.

appear in the CRLSet, we also plot the cumulative distribu-
tion of coverage only for entries with CRLSet reason codes
as well.

We ﬁnd that for 75.6% of covered CRLs, all entries with
CRLSet reason codes appear in the CRLSet. For the re-
maining CRLs, we ﬁnd that the number of entries with
CRLSet reason codes missing ranges from 1 to 5,826 (the
latter comes from Verisign’s “International EV” CRL, mak-
ing it especially strange). Overall, we observe that for most
covered CRLs, CRLSets provide perfect coverage; however,
there are many CRLs for which CRLSets provide only par-
tial coverage.

Un-covered Revocations. We now address the question
of what certiﬁcates are not included in CRLSets. While
there are millions of revoked certiﬁcates that do not ap-
pear in CRLSets, we focus on those that belong to popular
websites, since they will impact the largest fraction of In-
ternet traﬃc. Across all Alexa top one million domains,
we see 42,225 revocations in CRLs, but only 1,644 (3.9%) in
CRLSets. If we focus on the Alexa top 1,000 domains, we see
392 revoked certiﬁcates, but only 41 (10.4%) ever appear in
CRLSets. Thus, unless these sites use EV certiﬁcates (which
cause Chrome to perform the revocation checks described
above), certiﬁcates presented by the many of the most pop-
ular domains are left unchecked by Chrome’s CRLSets.
7.3 CRLSet Dynamics

We now examine CRLSet dynamics, and begin by inves-
tigating how the CRLSet size changes over time. Figure 8
shows that the number of entries in CRLSets ranges from
15,922 to 24,904, with the peak corresponding to the Heart-
bleed vulnerability, followed by a decrease over the following
year. The signiﬁcant decrease in May–June 2014 is largely
explained by the removal of the “VeriSign Class 3 Extended
Validation” parent (and its 5,774 entries) from the CRLSet,
and general downward trend corresponds with the behavior
of the underlying CRLs.

To better understand the dynamics of CRLSet entries, we
zoom in on the number of entries added and removed from
the CRLSet each day, and limit ourselves to the time period
of October 1, 2014 to March 31, 2015 where we have daily
scans of both CRLSet ﬁles and CRL entries. Figure 9 shows
this, using a log scale on the y-axis. We observe that CRLs
exhibit weekly patterns, with increased activity during the
week and lulls during the weekend. We also observe that
CRLSets are updated frequently, but there is a noticeable

 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.2 0.4 0.6 0.8 1CDFFraction of CRLs’ Entries in CRLSetCRLSet Reason CodesAll Revocations 15000 16000 17000 18000 19000 20000 21000 22000 23000 24000 25000SepNovJanMarMayJulSepNovJanMarNumber of Entries in CRLSetDate (2013-2015)193Figure 9: Number of daily new revocations appearing in CRLs
(upper line) and CRLSets (lower line). CRL additions show
weekly patterns and are much larger than CRLSet additions. For
two weeks in late 2014, we observed no additions to CRLSets.

gap with no additions in November–December 2014. Other-
wise we observe no direct correlation between peaks/troughs
in CRL and CRLSet updates, consistent with the fact that
CRLSets track only a small subset of the CRLs.

Lastly, we focus on the security impact of CRLSet dynam-
ics, speciﬁcally for the set of revocations that appear in both
CRLs and CRLSets. We focus on periods of time when a cer-
tiﬁcate appears in a CRL but not in the CRLSet (687 cases
in our dataset), or was removed from a CRLSet before the
revoked certiﬁcate expired (629 cases in our dataset). We
refer to these as periods of vulnerability. Figure 10 shows
this using the cumulative distribution of days of vulnerabil-
ity over all certiﬁcates that appeared in CRLSets. We ﬁnd
that most revoked certiﬁcates appear in the CRLSets within
one day (60%), and more than 90% appear within two days.
This suggests that an automated process pulls CRL data
into CRLSets, and thus there is a relatively small window
of vulnerability after a revocation occurs.28

However, we observe that revoked certiﬁcates are some-
times removed from the CRLSet hundreds of days before
they expire. This result is due to the signiﬁcant decrease
in CRLSet size seen in Figure 8.
In one case, a revoked
CA cert was removed from the CRLSet that is valid until
the year 2020. In the median case, revocations are removed
from CRLSets 187 days before the certiﬁcate expires.
7.4 Improving CRLSets: Bloom Filters

As we have shown, Google’s CRLSet implementation has
very low coverage. An alternative data structure that could
hold more revocations while also obeying Google’s strict size
constraints is a Bloom Filter [4]. A Bloom Filter has the ad-
vantage of no false negatives (if a certiﬁcate is revoked, it will
be ﬂagged as revoked by the ﬁlter); however, it will produce
a tunable false positive rate (a non-revoked certiﬁcate may
be ﬂagged as revoked). Thus, when a certiﬁcate “hits” the
ﬁlter, the client would need to check a CRL before ﬂagging
the connection as insecure. Although checking CRLs intro-
duces lag, this lag would only impact performance for false
positives (since true positives should be blocked anyway).
Also note that the size of the Bloom Filter would depend on
the number of revoked certiﬁcates (which is relatively easy
to determine), not the number of fresh, issued certiﬁcates
(which is unknown and much, much larger).

28Note that this does not take into account the time it takes to
push updated CRLSets to clients, which may add to the window of
vulnerability.

Figure 10: Number of days that clients are vulnerable to revoked
certiﬁcates using CRLSets. Revoked certiﬁcates on covered CRLs
are added quickly (within a day), but many revoked certiﬁcates
are removed from the CRLSet well before they expire.

As a proof-of-concept, we brieﬂy analyze the character-
istics of a Bloom Filter-based revocation list. As shown in
Figure 11, we examine the trade-oﬀs between ﬁlter size m,
the number of revoked certiﬁcates inserted into the ﬁlter n,
and false positive rate p. The number of hash functions k is

calculated using the optimal formula k =(cid:6) m

n ∗ log 2(cid:7).

Figure 11 highlights the advantages of our Bloom Filter-
based implementation over CRLSet.
The grey region
shows the minimum and maximum revocations covered
by CRLSets over time. For the same maximum ﬁle size
(256 KB), our Bloom Filter can store an order of magnitude
more revocations with only a 1% false positive rate (i.e., in-
stances where the CRL would be checked to avoid actually
blocking the connection). If we use a ﬁlter that is 2 MB in
size, we can cover 1.7 million revocations at this false pos-
itive rate; this represents 15% of all revocations across all
CRLs in our dataset.

The results of this analysis are similar to the examination
of the suitability of Bloom Filters for distributing revocation
information conducted by Langley [25]; Bloom Filters show
signiﬁcant promise as a mechanism for dramatically increas-
ing the coverage of CRLSets at little cost to clients. In fact,
Langley suggests that using a variant of Bloom Filters called
Golomb Compressed Sets [17] may serve to reduce the space
requirements even more.
7.5 Summary

To summarize, we ﬁnd that CRLSets have limited cover-
age, their coverage of revoked certiﬁcates is diminishing over
time, they are updated frequently but experience outages,
and they leave browsers vulnerable to unexpired revoked
certiﬁcates. While the CRLSet approach has a number of

Figure 11: Number of revocations that would ﬁt in Bloom Fil-
ters of various sizes, compared to CRLSets of today.

 1 10 100 1000 10000 100000OctNovDecJanFebMarAprNumber of Entires AddedDate (2014-2015)CRL EntriesCRLSet Entries 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1 10 100 1000 10000CDFDaysDays to appearDays between removal and expiry 0.0001 0.001 0.01 0.1 1 10 10010K100K1M10MFalse Positive Rate (p)Revocations in the Bloom Filter (n)CRLSetm=256KBm=512KBm=1MBm=2MBm=16MB194beneﬁts to users, it is clear that the developers have chosen
to provide security only for a small fraction of sites in order
to decrease the amount of bandwidth required to dissemi-
nate revocation information; this leaves the vast majority of
popular sites uncovered.

8. RELATED WORK

SSL Certiﬁcate Ecosystem. There has been a long
thread of work that examines the SSL certiﬁcate ecosys-
tem, ranging from the contents of diﬀerent browser/OS root
stores [36,50] to the trust relationships between CAs [14] and
the patterns of certiﬁcates advertised by servers [22]. While
Durumeric et al. [14] brieﬂy examine certiﬁcate revocation
in their study, our work builds on theirs by examining the
dynamics of revocation behavior, diﬀerent revocation proto-
cols, and the cost of obtaining revocation information.

Researchers have proposed ideas to reduce the level of
trust placed in CAs. Signiﬁcant recent work has gone into
increasing the transparency of the SSL ecosystem [24, 29,
30, 39, 43], ideally leading to better accountability. For ex-
ample, the Certiﬁcate Transparency Project [29] introduces
public logs to monitor all certiﬁcates issued by CAs. Oth-
ers have proposed alternate architectures to the current CA-
based system [9,12,47], often requiring modiﬁcations to both
servers and clients. The DANE [47] proposal, for example,
allows the owner of a DNS domain to distribute their public
keys via DNS itself (thereby obviating the need for SSL cer-
tiﬁcates), while relying on DNSSEC to secure the binding.

Studying and Improving Revocations. There has been
signiﬁcant debate over the actual eﬀectiveness of certiﬁcate
revocation in practice [27, 28, 32], and researchers have at-
tempted to improve the certiﬁcate revocation process and
dissemination mechanisms. For example, there are propos-
als for very short certiﬁcate lifetimes [46], ideally making
revoking a certiﬁcate as easy as not renewing it. Alterna-
tively, Schulman et al. [42] proposed a broadcast system that
disseminates revocation data over FM radio.

Two recent security incidents (a Debian vulnerability
and the Heartbleed bug) provided opportunities to study
whether site operators who should revoke their certiﬁcates
actually do [13, 51, 52]. The results are disheartening, as
only around 10% of vulnerable certiﬁcates were correctly re-
voked. Our work is complementary: we look at a larger set
of certiﬁcates over a longer period of time, we investigate
the burden that disseminating revocation information has
on CAs, and explore when clients obtain this information.

Client-side Certiﬁcate Validation. Finally, much work
has gone into understanding client-side behavior when cre-
ating SSL connections. Recent work has shown that many
pieces of non-browser software do not correctly implement
SSL checks, often due to mis-use of SSL APIs [18,19]. Others
have shown that the SSL libraries themselves are buggy [10].
Because browsers often ask users whether or not to proceed
when the SSL connection is suspicious, other work has fo-
cused on how browsers present warnings and how users re-
act [6, 7]. Taken together, these results show that correctly
implementing SSL validation is diﬃcult to get right; our
results show that this situation is further complicated by
browsers that decline to check revocation information at all.
The GRC browser revocation test [21] is similar to our
“test suite”, but ours is much more comprehensive (the GRC

test only contains a single certiﬁcate). As a result, our con-
clusions diﬀer: while Firefox performed well on their test, we
found that Firefox fails in other conﬁgurations of certiﬁcate
chains/revocation protocols.

9. CONCLUDING DISCUSSION

Certiﬁcate revocation is a necessary component of any
PKI, but it comes with costs, both real and perceived: CAs
carry the cost of disseminating revocation information, while
browsers risk the cost of increased web page load times. In
the trade-oﬀ between low communication overheads and se-
curity, both ends of certiﬁcate revocation (those who issue
and those who fetch) are naturally tempted towards the for-
mer.
Indeed, the very utility of revocations has been de-
bated and doubted [28] by the security community, but to
date, these debates have had to largely depend on anecdotal
CA and browser behavior.

We have presented in this paper an empirical measure-
ment of the options at all parties’ disposal—website admin-
istrators, CAs, and browsers—in terms of the communica-
tion overhead costs they impose and the extent to which
they are currently being employed.
Overall, our results show that,

in today’s Web’s PKI,
there is extensive inaction with respect to certiﬁcate revo-
cation. While many certiﬁcates are revoked (over 8% of
fresh certiﬁcates and almost 1% of alive certiﬁcates), many
web browsers either fail to check certiﬁcate revocation in-
formation or soft-fail by accepting a certiﬁcate if revocation
information is unavailable.

On the positive side, our results also demonstrate that
there are several clear paths to improvement. To reduce
CRL sizes, CAs can simply maintain more, smaller CRLs
(in the extreme, each certiﬁcate could be assigned a unique
CRL, resulting in an approximation of OCSP)—surprisingly
few CAs currently take such an approach (§5) and there-
fore incur greater bandwidth costs than strictly necessary.
A promising improvement is OCSP Stapling, as it reduces
CA bandwidth costs as well as web page load times—yet,
not all browsers support it, and some that do simply ig-
nore the responses. A more pervasive deployment of OCSP
Stapling, at both websites and browsers, could lead to an
immediate improvement in user security at little additional
performance cost, particularly if the Multiple OCSP Staple
Extension [37] were adopted to allow intermediate certiﬁ-
cates to be stapled. Finally, we show that a straightforward
modiﬁcation to CRLSets could increase their coverage by
several orders of magnitude.

From these results, we conclude that certiﬁcate revocation
ought not be given up on—that indeed it serves a critical yet
overlooked role that, with proper support from all parties,
can be achieved at a cost far outweighed by the beneﬁts. To
realize this, we believe continued measurement and valida-
tion of future browsers will be of utmost importance, and
to this end have made our data and our browser test suite
publicly available at http://www.sslresearch.org

Acknowledgments
We thank the anonymous reviewers for their helpful com-
ments. This research was supported by NSF grants CNS-
1054233, CNS-1409191, CNS-1319019, CNS-1421444, and
CNS-1345284, by USAF award FA8750-14-2-0150, and by
the NSA as part of a Science of Security lablet.

19510. REFERENCES
[1] Network Security Services. Mozilla Developer Network,

2014. http://mzl.la/1DRKqGZ.

[2] CRLSets. The Chromium Projects, 2015.

http://bit.ly/1JPsUeC.

[3] Network Stack. The Chromium Projects, 2015.

http://bit.ly/1GYuMhE.

[4] B. Andrei and M. Michael. Network applications of bloom

ﬁlters: A survey. Int. Math., 1(4), 2004.

[5] C. Arthur. DigiNotar SSL certiﬁcate hack amounts to

cyberwar, says expert. The Guardian.
http://www.theguardian.com/technology/2011/sep/05/
diginotar-certificate-hack-cyberwar.

[6] D. Akhawe and A. P. Felt. Alice in Warningland: A

Large-scale Field Study of Browser Security Warning
Eﬀectiveness. USENIX Security, 2013.

[7] D. Akhawe, B. Amann, M. Vallentin, and R. Sommer.

Here’s My Cert, So Trust Me, Maybe?: Understanding TLS
Errors on the Web. WWW, 2013.

[8] An Evaluation of the Eﬀectiveness of Chrome’s CRLSets.

Gibson Research Corporation.
https://www.grc.com/revocation/crlsets.htm.

[9] A. Bates, J. Pletcher, T. Nichols, B. Hollembaek, and

K. R.B. Butler. Forced Perspectives: Evaluating an SSL
Trust Enhancement at Scale. IMC, 2014.

[10] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V.

Shmatikov. Using Frankencerts for Automated Adversarial
Testing of Certiﬁcate Validation in SSL/TLS
Implementations. IEEE S&P, 2014.

[11] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley,

and W. Polk. Internet X.509 Public Key Infrastructure
Certiﬁcate and Certiﬁcate Revocation List (CRL) Proﬁle.
RFC 5280, IETF, 2008.

[12] Convergence. http://convergence.io.
[13] Z. Durumeric, J. Kasten, D. Adrian, J. A. Halderman, M.

[27] A. Langley. Revocation still doesn’t work. 2014.
https://www.imperialviolet.org/2014/04/29/
revocationagain.html.

[28] A. Langley. No, don’t enable revocation checking. 2014.

https://www.imperialviolet.org/2014/04/19/
revchecking.html.

[29] B. Laurie, A. Langley, and E. Kasper. Certiﬁcate

Transparency. 2013.
https://tools.ietf.org/html/rfc6962.

[30] S. Matsumoto, P. Szalachowski, and A. Perrig. Deployment

Challenges in Log-based PKI Enhancements. EuroSec,
2015.

[31] Mozilla piles on China’s SSL cert overlord: We don’t trust

you either. http://bit.ly/1GBPwfG.

[32] NetCraft. How certiﬁcate revocation (doesn’t) work in

practice. 2013.
http://news.netcraft.com/archives/2013/05/13/how-
certificate-revocation-doesnt-work-in-practice.html.

[33] NetCraft. OCSP Server Performance in April 2013. 2013.
http://news.netcraft.com/archives/2013/05/23/ocsp-
server-performance-in-april-2013.html.

[34] D. Olivier. ASN. 1 communication between heterogeneous

systems. Morgan Kaufmann, 2001.

[35] OS X Yosemite: List of available trusted root certiﬁcates.

https://support.apple.com/en-us/HT202858.

[36] H. Perl, S. Fahl, and M. Smith. You Won’t Be Needing

These Any More: On Removing Unused Certiﬁcates from
Trust Stores. FC, 2014.

[37] Y. Pettersen. The Transport Layer Security (TLS) Multiple
Certiﬁcate Status Request Extension. RFC 6961 (Proposed
Standard), IETF, 2013.

[38] Qualys SSL Pulse.

https://www.trustworthyinternet.org/ssl-pulse/.
[39] M. D. Ryan. Enhanced Certiﬁcate Transparency and

End-to-End Encrypted Mail. NDSS, 2014.

Bailey, F. Li, N. Weaver, J. Amann, J. Beekman, M. Payer,
and V. Paxson. The Matter of Heartbleed. IMC, 2014.

[40] Rapid7 SSL Certiﬁcate Scans.

https://scans.io/study/sonar.ssl.

[14] Z. Durumeric, J. Kasten, M. Bailey, and J. A. Halderman.
Analysis of the HTTPS Certiﬁcate Ecosystem. IMC, 2013.
[15] C. Ellison and B. Schneier. Ten Risks of PKI: What You’re
not Being Told about Public Key Infrastructure. Computer
Security Journal, 16(1), 2000.

[16] EFF SSL Observatory. https://www.eff.org/observatory.
[17] P. Felix, S. Peter, and S. Johannes. Cache-, hash- and
space-eﬃcient bloom ﬁlters. Experimental Algorithms,
Springer, 2007.

[18] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B.
Freisleben, and M. Smith. Why Eve and Mallory Love
Android: An Analysis of Android SSL (in)Security. CCS,
2012.

[19] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh,

and V. Shmatikov. The Most Dangerous Code in the
World: Validating SSL Certiﬁcates in Non-browser
Software. CCS, 2012.

[20] P. Gutmann. Engineering Security. 2014. https:

//www.cs.auckland.ac.nz/~pgut001/pubs/book.pdf.

[41] Revoking Intermediate Certiﬁcates: Introducing OneCRL.

Mozilla Security Blog. http://mzl.la/1zLFp7M.

[42] A. Schulman, D. Levin, and N. Spring. RevCast: Fast,

Private Certiﬁcate Revocation over FM Radio. CCS, 2014.

[43] P. Szalachowski, S. Matsumoto, and A. Perrig. PoliCert:
Secure and Flexible TLS Certiﬁcate Management. CCS,
2014.

[44] S. Santesson, M. Myers, R. Ankney, A. Malpani, S.
Galperin, and C. Adams. X.509 Internet Public Key
Infrastructure Online Certiﬁcate Status Protocol - OCSP.
RFC 6960 (Proposed Standard), IETF, 2013.

[45] StartSSL: Frequently Asked Questions.

https://www.startssl.com/?app=25.

[46] E. Topalovic, B. Saeta, L.-S. Huang, C. Jackson, and D.

Boneh. Towards Short-Lived Certiﬁcates. W2SP, 2012.

[47] The DNS-Based Authentication of Named Entities (DANE)

Transport Layer Security (TLS) Protocol: TLSA. 2012.
https://tools.ietf.org/html/rfc6698.

[48] Trustwave to escape ’death penalty’ for SSL skeleton key.

[21] S. Gibson. Security Certiﬁcate Revocation Awareness Test.

http://bit.ly/1RbPlNe.

2014. https://www.grc.com/revocation.htm.

[22] R. Holz, L. Braun, N. Kammenhuber, and G. Carle. The
SSL Landscape – A Thorough Analysis of the X.509 PKI
Using Active and Passive Measurements. IMC, 2011.

[23] ICSI SSL Notary. http://notary.icsi.berkeley.edu.
[24] T. H.-J. Kim, L.-S. Huang, A. Perring, C. Jackson, and V.
Gligor. Accountable Key Infrastructure (AKI): A Proposal
for a Public-key Validation Infrastructure. WWW, 2013.

[25] A. Langley. Smaller than Bloom ﬁlters. 2011. https:

//www.imperialviolet.org/2011/04/29/filters.html.

[26] A. Langley. Revocation checking and Chrome’s CRL. 2012.

https:
//www.imperialviolet.org/2012/02/05/crlsets.html.

[49] University of Michigan Daily Full IPv4 HTTPS

Handshakes. https://scans.io/series/https-full-ipv4.
[50] N. Vallina-Rodriguez, J. Amann, C. Kreibich, N. Weaver,

and V. Paxson. A Tangled Mass: The Android Root
Certiﬁcate Stores. CoNEXT, 2014.

[51] S. Yilek, E. Rescorla, H. Shacham, B. Enright, and S.

Savage. When Private Keys Are Public: Results from the
2008 Debian OpenSSL Vulnerability. IMC, 2009.

[52] L. Zhang, D. Choﬀnes, T. Dumitras, D. Levin, A. Mislove,

A. Schulman, and C. Wilson. Analysis of SSL certiﬁcate
reissues and revocations in the wake of Heartbleed. IMC,
2014.

196