Signatures and Efﬁcient Proofs on Committed Graphs

and NP-Statements

School of Computing Science, Newcastle University, UK

Thomas Groß

thomas.gross@ncl.ac.uk

No Institute Given

Abstract. Digital signature schemes are a foundational building block enabling
integrity and non-repudiation. We propose a graph signature scheme and corre-
sponding proofs that allow a prover (1) to obtain a signature on a committed graph
and (2) to subsequently prove to a veriﬁer knowledge of such a graph signature.
The graph signature scheme and proofs are a building block for certiﬁcation sys-
tems that need to establish graph properties in zero-knowledge, as encountered in
cloud security assurance or provenance. We extend the Camenisch-Lysyanskaya
(CL) signature scheme to graphs and enable efﬁcient zero-knowledge proofs of
knowledge on graph signatures, notably supporting complex statements on graph
elements. Our method is based on honest-veriﬁer proofs and the strong RSA as-
sumption. In addition, we explore the capabilities of graph signatures by estab-
lishing a proof system on graph 3-colorability (G3C). As G3C is NP-complete,
we conclude that there exist Camenisch-Lysyanskaya proof systems for state-
ments of NP languages.

1

Introduction

Digital signature schemes are foundational cryptographic primitives; they are useful
in themselves to ensure integrity and non-repudiation and as building block of other
systems. From their ﬁrst construction by Rivest, Shamir and Adleman [26], digital
signatures have been on bit-strings or group elements, on a committed sequence of
bit-strings [10] or structure-preserved group elements [1]. In this work, we establish a
signature scheme and corresponding proof system for committed graphs.

The basis for this work is the Camenisch-Lysyanskaya proof system: a collection
of distributed algorithms that allow an issuer, a prover and a veriﬁer to prove knowl-
edge of committed values, issue a Camenisch-Lysyanskaya (CL) signature [9,10] on
committed values, and prove knowledge of such a signature in zero-knowledge, while
selectively disclosing values or proving statements about them. It uses honest-veriﬁer
Σ-proofs (Schnorr proofs [27]) and has the advantage that it keeps all attributes in the
exponent. It thereby allows us to access attributes with known discrete-logarithm-based
zero-knowledge proofs of knowledge [27,16,18,11,4,13]. The attributes that could be
signed are, however, limited by the message space of the CL-signature scheme: a se-
quence of small bit-strings.

We study how to extend the Camenisch-Lysyanskaya proof system to establish sig-
natures on committed graphs and, by extension, on committed statements from NP

languages. Zero-knowledge proofs of certiﬁed or committed graphs with the capability
of selective disclosure of graph elements or complex statements over graph attributes
have many signiﬁcant applications beyond classical graph proof techniques [21,3] or the
more recent proposal of transitive signatures [23]. The key difference to earlier work is
that the graph encoding is universal, enables direct access to graph elements, and allows
a prover to be ﬂexible in the statements proven after the graph is certiﬁed. Such graph
proofs are instrumental in foundational techniques, such as the zero-knowledge proof
of knowledge of certiﬁed Petri nets as well as in various application scenarios, such
as for the certiﬁcation of audited cloud topologies for which we proposed a dedicated
framework for topology proofs [2]. including coverage, disjointness and partitions as
well as connectivity and isolation.

First, we establish a new encoding of undirected graphs into the message space of
CL-Signatures. The encoding allows for unlabeled, vertex- or edge-labeled graphs. The
graph encoding is universal and operational in the sense that it supports efﬁcient proofs
over graph elements (vertices, edges, labels) and their relations.

Second, we extend the Camenisch-Lysyanskaya proof system to graphs by integrat-
ing the graph encoding into integer commitments and the CL-Signature bootstrapping
process. This allows prover and issuer to sign committed graphs with sub-graphs con-
tributed by both parties and to prove knowledge of graph signatures in honest-veriﬁer
Σ-proofs. The obtained graph proof system in itself allows for efﬁcient zero-knowledge
proofs of interesting graph properties, such as partitions, connectivity and isolation [2],
already demonstrated in an application scenario of topology certiﬁcation and proofs
in virtualized infrastructures. Graph proofs with a level of indirection between the au-
thority on the graph (the issuer) and the veriﬁer, established by a graph signature and
with access to a wide range of graph properties, have not been covered by existing
zero-knowledge graph proofs, such as [21,3,20], or transitive signatures [23]. While the
former graph proofs are powerful constructions allowing for NP statements, e.g., graph
3-colorability or directed Hamiltonian cycle, their encoding does not cater for proving
relations over graph elements in zero-knowledge. The latter is focused on the transitive
closure along graph edges.

Third, we establish a proof system for graph 3-colorability (G3C) that allows us
to obtain CL-Signatures on committed instances of 3-colorable graphs and to prove
knowledge thereof to a veriﬁer in zero-knowledge. Given that graph 3-colorability is
NP-complete, we can lift the Camenisch-Lysyanskaya proof system to NP statements.
Based on the 3-colorability proof system in a special RSA group and under the Strong
RSA assumption, we show that there exists a Camenisch-Lysyanskaya proof system
for any NP language, that is, the proof is capable of issuing CL-Signatures on com-
mitted statements from the NP language and to prove knowledge of such signatures in
honest-veriﬁer Σ-proofs. Whereas the G3C-reduction does not offer particularly efﬁ-
cient constructions for graph proofs, it shows the theoretical expressiveness of the graph
credential system.

In effect, this work extends the reach of the Camenisch-Lysyanskaya proof system
to signatures and proofs on structures of entire systems. To our knowledge, it is the
ﬁrst work to enable signatures on committed graphs. Notably, the graph elements are

present in the exponents and, thereby, accessible to known discrete-logarithm-based
zero-knowledge proofs on a wide range graph properties in honest-veriﬁer proofs.

1.1 Outline

In §2, we discuss the preliminaries of our graph proof construction: Camenisch-
Lysyanskaya signatures and Camenisch-Groß encoding. Based on the Camenisch-Groß
encoding, we establish a canonical encoding for vertex- and edge-labeled graphs in §3.
§4 establishes how integer commitments and CL-Signature are extended with the graph
encoding. In §5 we show how graph 3-colorability can be expressed in the graph proof
system as proof of the encoding’s theoretical reach. §7 considers earlier work on zero-
knowledge proofs and signatures on graphs, while §8 draws conclusions of this work’s
properties.

2 Preliminaries

2.1 Assumptions
Special RSA Modulus A special RSA modulus has the form N = pq, where p = 2p0 + 1
and q = 2q0 + 1 are safe primes, the corresponding group is called special RSA group.
Strong RSA Assumption [26,18]: Given an RSA modulus N and a random element
g ∈ Z∗
N and integer e > 1 such that he ≡ g mod N.
The modulus N is of a special form pq, where p = 2p0 + 1 and q = 2q0 + 1 are safe
primes. Quadratic Residues The set QRN is the set of Quadratic Residues of a special
RSA group with modulus N.

N , it is hard to compute h ∈ Z∗

2.2

Integer Commitments

Damgård and Fujisaki [16] showed for the Pedersen commitment scheme [24] that if it
operates in a special RSA group and the committer is not privy to the factorization of the
modulus, then the commitment scheme can be used to commit to integers of arbitrary
size. The commitment scheme is information-theoretically hiding and computationally
binding. The security parameter is ‘. The public parameters are a group G with special
RSA modulus N, and generators (g0, . . . , gm) of the cyclic subgroup QRN . In order
to commit to the values (V1, . . . , Vl) ∈ (Z∗
n)l, pick a random R ∈ {0, 1}‘ and set
C = gR0

Ql

i=1 gvi
i .

2.3 Known Discrete-Logarithm-Based, Zero-Knowledge Proofs

In the common parameters model, we use several previously known results for proving
statements about discrete logarithms, such as (1) proof of knowledge of a discrete log-
arithm modulo a prime [27] or a composite [16,18], (2) proof of knowledge of equality
of representation modulo two (possibly different) composite [11] moduli, (3) proof that
a commitment opens to the product of two other committed values [5,11], (4) proof
that a committed value lies in a given integer interval [4,11], and also (5) proof of the

disjunction or conjunction of any two of the previous [15]. These protocols modulo a
composite are secure under the strong RSA assumption and modulo a prime under the
discrete logarithm assumption.

Proofs as described above can be expressed in the notation introduced by Camenisch

and Stadler [12]. For instance,

PK{(α, β, δ) : y = gαhβ ∧ ˜y = ˜gα˜hδ ∧ (u ≤ α ≤ v)}

denotes a “zero-knowledge Proof of Knowledge of integers α, β, and δ such that y =
gαhβ and ˜y = ˜gα˜hδ holds, where u ≤ α ≤ v,” where y, g, h, ˜y, ˜g, and ˜h are elements
of some groups G = hgi = hhi and ˜G = h˜gi = h˜hi. The convention is that Greek letters
denote quantities of which knowledge is being proven, while all other values are known
to the veriﬁer. We apply the Fiat-Shamir heuristic [17] to turn such proofs of knowledge
into signatures on some message m; denoted as, e.g., SPK{(α) : y = gα}(m). Given a
protocol in this notation, it is straightforward to derive an actual protocol implementing
the proof.

2.4 Camenisch-Lysyanskaya Signatures

Let us introduce Camenisch-Lysyanskaya (CL) signatures in a Strong RSA setting [10].
Let ‘M, ‘e, ‘N , ‘r and L be system parameters; ‘r is a security parameter, ‘M the
message length, ‘e the length of the Strong RSA problem instance prime exponent, ‘N
the size of the special RSA modulus. The scheme operates with a ‘N -bit special RSA
modulus. Choose, uniformly at random, R0, . . . , RL−1, S, Z ∈ QRN . The public key
pk(I) is (N, R0, . . . , RL−1, S, Z), the private key sk(I) the factorization of the special
RSA modulus. The message space is the set {(m0, . . . , mL−1) : mi ∈ ±{0, 1}‘M}.

Signing hidden messages. On input m0, . . . , mL−1 , choose a random prime number e
of length ‘e > ‘M + 2, and a random number v of length ‘v = ‘N + ‘M + ‘r. To sign
hidden messages, user U commits to values V in an integer commitment C and proves
knowledge of the representation of the commitment. The issuer I veriﬁes the structure
of C and signs the commitment:

 

A =

!1/e

Z

. . . RmL−1

L−1 Sv0

CRml

l

mod N.

The user completes the signature as follows: σ = (e, A, v) = (e, A, (v0 + R)).
that the following statements hold: Z ≡ AeRm0
0
±{0, 1}‘M, and 2‘e > e > 2‘e−1 holds.

To verify that the tuple (e, A, v) is a signature on message (m0, . . . , mL−1), check
L−1 Sv (mod N), mi ∈

. . . RmL−1

Theorem 1. [10] The signature scheme is secure against adaptive chosen message at-
tacks under the strong RSA assumption.

Proving Knowledge of a Signature. The prover randomizes A: Given a signature
(A, e, v), the tuple (A0 := AS−r mod N, e, v0 := v + er) is also a valid signature
as well. Now, provided that A ∈ hSi and that r is chosen uniformly at random from
{0, 1}‘N +‘∅, the value A0 is distributed statistically close to uniform over Z∗
N . Thus,
the user could compute a fresh A0 each time, reveal it, and then run the protocol

PK{(ε, ν0, µ0, . . . , µL−1) :
0 ··· RµL−1

Z ≡ ±Rµ0
µi ∈ ±{0, 1}‘M ∧ ε ∈ [2‘e−1 + 1, 2‘e − 1]}

L−1 A0εSν0 (mod N) ∧

2.5 Set Membership from CL-Signatures

Set membership proofs can be constructed from CL-Signatures following a method pro-
posed by Camenisch, Chaabouni and shelat [7]. For a set S = {m0, . . . , mi, . . . , ml},
the issuer signs all set members mi in CL-Signatures σi = (A, e, v) and publishes
the set of message-signature pairs {(mi, σi)} with integrity. To prove set membership
of a value committed in C, the prover shows knowledge of the blinded signature σ0
i
corresponding to the message mi and equality of exponents with C. We explain this
technique in detail in the extended version of this paper and denote a set membership
proof µ[C] ∈ S, which reads µ encoded in commitment C is member of set S.

2.6 Camenisch-Groß Encoding

The Camenisch-Groß (CG) Encoding [8] establishes structure on the CL message space
by encoding multiple binary and ﬁnite-set values into a single message, and we will use
a similar paradigm to encode graphs efﬁciently. We explain the key principles brieﬂy
and give more details in the extended version of this paper.

The core principle of the CG-Encoding is to represent binary and ﬁnite-set attribute
values as prime numbers. It uses divisibility and coprimality to show whether an at-
tribute value is present in or absent from a credential. The attribute values certiﬁed in a
credential, say ei, ej, and el, are represented in a single message of the CL-Signature,
by signing the product of their prime representative E = ei·ej·el in an Integer attribute.
The association between the value and the prime number of the encoding is certiﬁed by
the credential issuer.
Divisibility/AND-Proof. To prove that a disclosed prime representative ei is present in
E, we prove that ei divides the committed product E, we show that we know a secret
µ0 that completes the product:
PK{(µ0, ρ) :

hρ (mod N)}.

D ≡ ±(gei)µ0

Coprimality/NOT-Proof. We show that one or multiple prime representatives are not
present in a credential, we show coprimality. To prove that two values E and F are
coprime, i.e., gcd(E, F) = 1, we prove there exist integers a and b such that Bézout’s
Identity equals 1, where a and b for this equation do not exist, if gcd(E, F) > 1.
PK{(µ, ρ, α, β, ρ0) :

D ≡ ±gµhρ (mod N) ∧ g ≡ ±Dα(gF )βhρ0 (mod N)}.

list, we show there exists an integer a such that ae =Q‘

OR-Proof To show that a credential contains an attribute e that is contained in an OR-
i ei; if e is not in the list, then
there is no such integer a as e does not divide the product. We use the notation α ⊆ Ξ
for an OR-proof that α contains one or more values of Ξ.

3 Graph Encoding

We consider graphs over ﬁnite vertex sets, with undirected edges or directed arcs, and
ﬁnite sets of vertex and edge labels. Vertices and edges may be associated with multiple
labels. We leave the encoding of directed arcs to the extended version of this paper.

Finite set of vertices
Finite set of edges

V
E ⊆ (V × V)
G = (V,E, tV , tE) Graph
LV ,LE
fV : V → P(LV) Labels of a given vertex
fE : E → P(LE) Labels of a given edge
n = |V|, m = |E| Number of vertices and edges

Finite sets of vertex and edge labels

For each vertex i in V, we introduce a vertex identiﬁer, a prime ei, which represents
this vertex in credential and proofs. The symbol ⊥, associated with identiﬁer e⊥ repre-
sents that a vertex is not present. All vertex identiﬁers are pair-wise different. We call
the set of all vertex identiﬁers ΞV, their product χV = ΠΞV. For each label k in the
label sets LV and in LE, we introduce a prime representative ek. All label representa-
tives are pair-wise different. We call the set of all label representatives ΞL, their product
χL = ΠΞL. Vertex identiﬁers and label representatives are disjoint:

ΞV ∩ ΞL = ∅ ⇔ gcd(χV , χL) = 1.

Random Base Association We encode vertices and edges into the exponents of integer
commitments and CL-Signatures and make them therefore accessible to proofs of linear
equations over exponents. We randomize the base association to vertices and edges:
For a vertex index set V= 0,. . . ,i,n-1 with vertex identiﬁers ei, we choose a uniformly
random permutation πV of set V to determine the base Rπ(i) to encode vertex i. Edge
bases Rπ(i,j) are chosen analogously with a random permutation πE.

Encoding Vertices To encode a vertex and its associated labels into a graph commitment
or CL-Signature, we encode the product of the vertex identiﬁer ei ∈ ΞV and the prime
representatives ek ∈ ΞL for k ∈ fV(i) of the labels into a single of the signature
message. The product of prime representatives is encoded as exponent of dedicated
vertex bases R ∈ GV.

Encoding Edges To get a compact encoding and efﬁcient proofs thereon, the encoding
needs to maintain the graph structure and to allow us to access it to proof higher-level
properties, such as connectivity and isolation. The proposal we make in this paper after

Table 1. Interface of the graph signature scheme.

Commit(G; R)
A PPT algorithm computing an Integer commitment on a graph.
Keygen(1‘, params)
A PPT algorithm computing the key setup.
HiddenSign(C,VU,VI, pkI) An interactive PPT algorithm signing a committed graph.
User U: GU, commitment randomness R; Issuer I: GI, skI.
Verify(pkI, C, R0, σ)
A veriﬁcation algorithm on graph commitment C and signature σ.

Private inputs:

evaluating multiple approaches is to use divisibility and coprimality similar to the CG-
Encoding to afford us these efﬁcient operations over the graph structure, while offering
a compact encoding of edges.
Recall that each vertex is certiﬁed with an vertex identiﬁer from ΞV, e.g., ei or ej.
For each edge (i, j) ∈ E, we include an edge attribute as exponent of a random edge
base Rπ(i,j) ∈ GE, containing the product of the vertex identiﬁers and the associated
label representatives ek ∈ ΞL for k ∈ fE(i, j) of the edge:
E(i,j) := ei · ej · Πk∈fE(i,j)ek.

Whereas we usually consider simple graphs, specialties such as multigraphs, loops (i, i)
encoded as e2

i or half-edges encoded as (ej, e⊥) can be included.

Well-formed Graphs

Deﬁnition 1 (Well-formed graph). We call a graph encoding well-formed iff 1. the
encoding only contains prime representatives e ∈ ΞV ∪ ΞL in the exponents of des-
ignated vertex and edge bases R ∈ GV ∪ GE, 2. each vertex base R ∈ GV contains
exactly one vertex identiﬁer ei ∈ ΞV, pair-wise different from other vertex identiﬁers
and zero or more label representatives ek ∈ ΞL, and 3. each edge base R ∈ GE con-
tains exactly two vertex identiﬁers ei, ei ∈ ΞV and zero or more label representatives
ek ∈ ΞL.

Theorem 2 (Unambiguous encoding and decoding). A well-formed graph encoding
on the integers is unambiguous modulo the base association.
[Proof A.1]

4 Signatures on Committed Graphs

CL-signatures are signatures on committed messages, where messages can be con-
tributed by issuer and user. This translates to a user committing to a hidden partial graph
GU, which is then completed by the issuer GI, as outline in the interface in Table 1. We
establish the setup for the construction ﬁrst, explain the proof of representation second,
and the issuing third. We discuss notions of secrecy and imperfections of this construc-
tion in §4.1.
As a point of reference, we give the structure of the graph signatures ﬁrst. We have
bases Rπ(i) ∈ GV, which store attributes encoding vertices, and bases Rπ(i,j) ∈ GE,

which store attributes encoding edges. Observe that which base stores which vertex or
edge is randomized by permutations πV and πE.

{z

∀ edges (i,j)

···

}

Z = ··· R

|

{z

eiΠk∈fV (i)ek
π(i)
∀ vertices i

}

|

···

··· R

eiej Πk∈fE (i,j)ek
π(i,j)

AeSv mod N

4.1 Secrecy Notion
In a known-graph proof, the structure of the graph G = (V,E) is an auxiliary input to
the veriﬁer. Such a proof occurs if the prover needs to prove knowledge of a (NP-hard)
property of the entire graph, e.g., a proper coloring in graph 3-colorability (cf. §5.1).
A hidden-graph proof keeps the structure of the graph G = (V,E) secret. For in-
stance, there are graph proofs in which a local property is proven and the graph structure
itself kept secret, e.g., when proving that disclosed vertices of the graph are connected
by a hidden path.
The number of bases from GV and GE in a CL-Signature reveals an upper-bound on
the number of vertices n and edges m of the signed graph. A suitable padding can be
introduced by encoding nil-vertices e⊥ and nil-edges (e⊥, e⊥).

Proving properties over multiple attributes reveals which bases were involved in
the proof. Characteristic patterns over said bases may interfere with the CL-Signature’s
multi-use unlinkability. For instance, if the prover shows that vertices i and j are con-
nected by an edge (i, j) along with properties on the vertices themselves, the veriﬁer
will learn that the bases for the vertex identiﬁers ei and ej are related to the base for
the encoding of edge (i, j). To overcome this linking, the prover can obtain a collec-
tion of CL-Signatures on the same graph, each with a randomized association between
bases and vertices/edges, that is, using different random permutations πV and πE. When
proving a property over the graph the prover chooses a CL-Signature from the collection
uniformly at random and proves possession over that instance.

4.2 Proof of Representation

For a full proof of representation, we need to establish that the encoded graph in a graph
commitment or CL-Signature is indeed well-formed (Def. 1). Given a graph commit-
ment C the prover and veriﬁer engage in the following proof of representation (the
proof for a CL credential work analogously). We show that vertex bases contain a bi-
partition of one and only one vertex identiﬁer ei ∈ ΞV and a set of labels el ∈ ΞL.
Edge bases contain a bi-partition of a product of exactly two vertex identiﬁers (ei · ej)
and a set of labels el ∈ ΞL. To prove that the representation contains exactly one vertex
identiﬁer for a vertex base and two vertex identiﬁers for an edge base, we establish a set
membership proof.

1. Commitments The prover computes Integer commitments on the exponents of all
vertex and edge bases. For each vertex i and for each edge (i, j), the prover computes
commitments on vertex attribute and identiﬁer (all modN)::

Ci = ReiΠk∈fV (i)ek Sr

and

˘Ci = ReiS˘r;

C(i,j) = Reiej Πk∈fE (i,j)ek Sr,

˘C(i,j) = Reiej S˘r

and

˙Ci = ReiS ˙r.

2. Proof of knowledge. We build up the proof of possession and well-formedness
step by step, where it is understood the proofs will be done in one compound proof
of knowledge with referential integrity between the secret exponents. Let us consider a
proof fragment for vertices i, j and an edge (i, j) committed in a graph commitment C
(the same proof structure is used for CL-Signatures).

2.1 Proof of representation. We prove that commitment C can be decomposed into
commitments Ci, Cj, one for each vertex i, j and one commitment C(i,j) for each edge
(i, j):

PK{(µi, µj, µ(i,j), ρ, ρi, ρj, ρ(i,j)) :
π(j) ··· R

π(i) ··· Rµj

C ≡ ±··· Rµi
Ci ≡ ±RµiSρi (mod N) ∧ Cj ≡ ±Rµj Sρj (mod N) ∧
C(i,j) ≡ ±Rµ(i,j) Sρ(i,j) (mod N)}.

π(i,j) ··· Sρ (mod N) ∧

µ(i,j)

(1)
(2)
(3)

2.2 Vertex composition. Second, we need to show properties of the vertex composition,
that the encoding for each vertex i contains exactly one vertex identiﬁer ei ∈ ΞV and
zero or multiple label representatives ek ∈ ΞL. We show this structure with help of
the commitments ˘Ci and set membership and prime-encoding OR proofs. This proof is
executed for all vertices.

PK{(εi, ˘ρi, γi, ρ0

i) :

˘Ci ≡ ±RεiS ˘ρi (mod N) ∧ Ci ≡ ± ˘C γiSρ0
γi[Ci] ⊆ ΞL ∧ εi[ ˘Ci] ∈ ΞV}.

(4)
(5)
2.3 Edge composition. Third, we prove the structure of each edge (i, j) over the
commitments C(i,j), showing that each commitment contains exactly two vertex iden-
tiﬁers ei, ej ∈ ΞV as well as zero or more label representative ek ∈ ΞL:

i (mod N) ∧

PK{(εj, ρ(i,j), γ(i,j), ρ0

(i,j)) :

˘C(i,j) ≡ ± ˙C εj
C(i,j) ≡ ± ˘C

i Sρ(i,j) (mod N) ∧
(i,j) Sρ0

(i,j) (mod N) ∧

γ(i,j)

γi,j ⊆ ΞL}.

(6)
(7)
(8)

2.4 Pair-wise difference. Finally, we prove pair-wise difference of vertices by show-
ing that the vertex representatives are pair-wise co-prime over the commitments ˘Ci and
˘Cj.

PK{(∀i, j : αi,j, βi,j, ρi,j) :

R ≡ ± ˘C αi,j

i

j Sρi,j (mod N)}.
˘C βi,j

(9)

Theorem 3 (Proof of Well-formedness). The compound proof of knowledge estab-
lishes the well-formedness of an encoded graph according to Def. 1.
[Proof B]

4.3

Joint Graph Issuing

To jointly issue a graph CL-signature, a user commits to a hidden partial graph and the
issuer adds further elements to the graph (cf. §2.4)

In the setup, the issuer establishes a user vertex space and issuer vertex space, i.e.,
a bi-partition on vertex and edge bases, GV and GE and on vertex identiﬁers ΞV. Thus,
user and issuer can encode partial graphs without interfering with each other.

In the joint graph issuing, user and issuer designate and disclose connection points
(vertex identiﬁers) that allow the user and the issuer to connect their sub-graphs delib-
erately. The user constructs a graph representation by choosing two uniformly random
permutation πV and πE for the base association on the user bases and commits to his
sub-graph in a graph commitment. The user interacts with the issuer in a proof of repre-
sentation of his committed sub-graph. The issuer veriﬁes this proof, chooses uniformly
random permutations for his graph elements and encodes them into his base range. The
issuer creates the pre-signature of the CL-Signature scheme on the entire graph, proving
that the added sub-graph is well-formed. The user completes the CL-Signature with his
own randomness.

Theorem 4 (Security of graph signatures). The graph signature scheme maintains
conﬁdentiality and integrity of the encoded graphs and offers existential unforgeability
against adaptive chosen message attacks under the strong RSA assumption.[Proof A.1]

5 Graph 3-Colorability and NP Statements

5.1 Graph 3-Colorability

We adapt the following deﬁnition from Goldreich, Micali and Wigderson [21].
Deﬁnition 2 (Graph 3-Colorability). A graph G = (V,E) is said to be 3-colorable if
there exists a vertex label mapping fV : V → {R, G, B} called proper coloring such
that every two adjacent vertices are assigned different color labels. This means that for
each edge (i, j) ∈ E fV(i) 6= fV(j). The language graph 3-colorability, denoted G3C,
consists of the set of undirected graphs that are 3-colorable. Graph 3-Colorability is
known to be NP-complete. [19]

We adapt the graph 3-colorability problem to show in honest-veriﬁer zero-knowledge
that the prover knows an CL signature on an instance of a proper coloring of a given
graph G.
Without loss of generality, we assume that graph G is simple and connected. The
three color labels L = {R, G, B} are encoded with three primes ΞL = {eR, eG, eB}. The
graph is encoded with vertex identiﬁers ΞV and these vertex labels. In addition to the
conditions for a well-formed graph (Def. 1), we require that each vertex base contains
exactly one label representative from ΞL, which we show with a set membership proof
on the secret vertex label.

The prover shows knowledge of a proper graph coloring by showing that the product
of vertex identiﬁers and label representatives for each pair of adjacent vertices (i, j) are
coprime.

Fig. 1. Example of a 3-colored graph, where the vertex identiﬁers are prime numbers, and the
labels R,G, and B are represented as colors.

Common inputs: Graph G, public-key of the CL-issuer.
Prover input: CL-Signature on proper coloring for G3C.

1. Credential randomization and commitments. The prover computes randomiza-
tions for the graph signature as well as for all occurrences of set membership proofs.
The prover computes Integer commitments on the exponents of all vertex and edge
bases. For each vertex i, the prover computes two commitments on the vertex attribute
and the vertex identiﬁer:

Ci = ReiefV (i) Sr mod N and

˘Ci = ReiSr mod N.

For each edge (i, j), the prover computes the commitment:

˘Ci,j = Reiej Sr mod N.

2. Proof of knowledge. The prover sends the commitments to the veriﬁer. Then,
prover and veriﬁer engage in the following proof of possession over the graph signature
and vertices i and j and all edges (i, j). We build upon the proof of representation and
well-formedness presented in §4.2 with the following differences: Instead of proving
that a vertex contains zero or multiple labels, we prove that the vertex contains ex-
actly one label. Further, the proof is simpliﬁed because the edges do not contain labels.
Again, we explain the proofs step by step, while it is understood that the proofs are
executed as compound proof of knowledge with referential integrity between the secret
exponents.

2.1 Possession of CL-Signature. First, we prove of possession of the graph signature
and representation of the commitments. Clause 1 proves possession of the CL-Signature
on the graph. The clauses 2 and 3 prove the representation on the integer commitments
on signed attributes for vertices j, j and edges (i, j), and, thereby, make the attributes
accessible for the analysis of the exponents.

PK{(µi, µj, µ(i,j), ε, ν0, ρi, ρj, ρ(i,j)) :

π(j) ··· R

µ(i,j)

π(i) ··· Rµj

Z ≡ ±··· Rµi
π(i,j) ··· (A0)εSν0 (mod N) ∧
Ci ≡ ±Rµi Sρi (mod N) ∧ Cj ≡ ±Rµj Sρj (mod N) ∧
C(i,j) ≡ ±Rµ(i,j)Sρ(i,j) (mod N) ∧
µi, µj, µ((i,j)) ∈ ±{0, 1}‘M ∧ ε ∈ [2‘e−1 + 1, 2‘e − 1]}

(1)
(2)
(3)

2.2 Well-formedness. Second, we establish that the vertex attributes are well-
formed: Clause 4 establishes the relation between Ci and ˘Ci and, thereby, shows that a

235711131719vertex attribute is bi-partitioned onto a vertex identiﬁer and a label representative part.
Clause 5 establishes that they contain exactly one vertex identiﬁer and label represen-
tative of the certiﬁed sets ΞV and ΞL.

PK{(εi, ρi, γi, ˘ρi) :

˘Ci ≡ ±RεiSρi (mod N) ∧ Ci ≡ ± ˘C γiS ˘ρi (mod N) ∧
γi[Ci] ∈ ΞL ∧ εi[ ˘Ci] ∈ ΞV}.

(4)
(5)

Clause 5 is different from a proof of well-formedness as introduced in §4.2, as it en-
forces that that vertex i contains exactly one label.

2.3 Proper coloring. Third, clauses 6 and 7 complete the statement by establishing
that there is a proper coloring for the adjacent vertices i and j: Clause 6 shows that
commitment C(i,j) is on an edge (i, j). Finally, Clause 7 establishes that the attributes
for vertex i and j are coprime, by proving that Bézout’s Identity equals 1. It follows that
the labels of both vertices must be different.

PK{(εi, ρ0

(i,j), α(i,j), β(i,j), ρ(i,j)00) :

˘C(i,j) ≡ ± ˘C εi
j Sρ0
R ≡ ±C
C

α(i,j)
i

(i,j) (mod N) ∧

β(i,j)
j

Sρ00

(i,j) (mod N)}.

(6)

(7)

3. Veriﬁcation. The veriﬁer outputs accept if the proof of knowledge checks out;

reject otherwise.

Lemma 1 (Knowledge of a CL-Signature of G3C). The prover convinces the veriﬁer
in zero-knowledge that the prover knows a proper graph 3-coloring for known graph G.
[Proof B.1]
Lemma 2. The proof has an asymptotic computation complexity of O(n+m) exponen-
tiations and a communication complexity of O(n + m) group elements and is thereby
a polynomial time proof.
[Proof B.1]

5.2 Proofs Systems for Languages in NP

Having established a proof for certiﬁed graph 3-colorability, we can use the fact that
G3C is NP-complete to establish that such Camenisch-Lysyanskaya proof systems exist
for statements from other NP languages.

Deﬁnition 3. We call a Camenisch-Lysyanskaya proof system a set of PPT machines
Prover P, Veriﬁer V and Issuer I that engage in the following protocols:
Proof of representation P → I : Proof of representation on committed values V .
Issuing I → P : Issuing of CL-Signature σ on hidden committed values V .
Proof of possession P → V : Proof of possession of CL-Signature σ.
The issuer I can act in the role of the veriﬁer V and thereby allow the bootstrapping of
further CL-Signatures from the hidden v alues of existing CL-Signatures.

Compared to a zero-knowledge proof system for an NP language, this construction
offers a level of indirection: The issuer acts as auditor with authority to decide whether
the statement of an NP language is fulﬁlled in a certain environment, and its signature
binds this statement to that environment. The instance of the NP language can either be
provided by the issuer or provided by the prover and veriﬁed by the issuer.

The proof follows the same strategy as one of the initial results that all languages
in NP have zero-knowledge proof systems, by Goldreich, Micali and Widgerson [21]:
Given a CL proof system for G3C, we use the existing poly-time NP reductions to
transform any NP language statement into an instance of G3C. This instance is then en-
coded as a graph in a CL-Signature and knowledge of the signature proven to a veriﬁer.
Lemma 1 shows that this is a zero-knowledge proof of knowledge of a proper coloring.

Theorem 5. Statements of languages in NP can efﬁciently be proven in a Camenisch-
Lysyanskaya proof system based in honest-veriﬁer zero-knowledge.
[Proof B.2]

6 Efﬁciency Analysis

We display the efﬁciency analysis for the proof predicates in Table 2, where vertex
and edge composition proofs show the overhead over the basic proof of possession
(cf. topology proofs [2]). We measure computational complexity in multi-base expo-
nentiations. The communication complexity is dominated by the transmitted group el-
ements from Z∗
N , which is equal to the number of multi-base exponentiations (one for
each Integer and Schnorr proof commitment). The most expensive proof is the com-
plete graph representation established in the issuing, where the set membership proofs
(4 MExps) and the OR-based subset proofs (6 MExps) constitute signiﬁcant overhead.
The square-complexity is introduced by the ﬁnal disjointness proof to establish that the
graph is indeed well-formed. In the down-stream proofs, the veriﬁer trusts the issuer
to only certify well-formed graphs, which allows us to reduce complexity by only the
computing the proof of possession and the statement proven.
The modular exponentiations for message bases Ri are with small exponents of
size of ‘M (cid:28) ‘N , where the parameter ‘M can be chosen similarly small as in Direct
Anonymous Attestation (DAA) [6].

In addition, the Σ-proofs employed in this work beneﬁt from batch-proof tech-
niques, such as [25]. The graph proofs are likely to be transformed to signature proofs
of knowledge with the Fiat-Shamir heuristic [17] and can thereby be computed ofﬂine.
We have evaluated the system experimentally in [2], in computations using compo-
nents of the Identity Mixer Library [22] with modulus length ‘n = 2048 bits and default
system parameters (‘v, etc.). The performance analysis is executed on 64-bit Java JDK
1.7.13 on a Windows 7 SP 1 Thinkpad X220 Tablet, on Intel CPU i5-2520 with 2.5 GHz,
8 GB RAM, where all computations are performed on a single processor core only, a
very conservative setup. Figure 2 contains the results of a prototypical implementation
of computations of the graph signature scheme, on representative computations of com-
mitments and a proof of knowledge thereof. Based on uniform random bit-strings of the
prescribed length and number (as in the actual Schnorr proof witnesses), we compute:
C := Rm0
0

‘ Sv mod N,

··· Rm‘

Table 2. Efﬁciency of proofs of predicates in multi-base exponentiations (MultiExps) dependent
on the number of vertices n and of edges m. For a simple graph holds m ≤ n(n−1)

.

2

Predicate

Possession

Vertex Composition
Edge Composition

Possession
Possession

Total Well-formed Graph

Basis

Commitments

#

MultiExps
#

O

n + m

2n + 2m + 1 O(n + m)

n
2m

O(n)
O(m)
2n + 3m n2 + 8n + 8m + 1 O(n2)

3n
4m

Graph-3 Colorability (§5)

n + m

6n + 4m + 1 O(n + m)

The simulation uses random graphs with speciﬁed number of vertices n and a de-
rived number of edges m := 2n as major independent variable (on the x-axis), the
dependent variable is computation time in milliseconds (in log-scale on the y-axis).

7 Related Work

Establishing zero-knowledge proofs on graphs and their properties is a classic area of
research. Such proofs were instrumental in showing that there exist zero-knowledge
proof systems for all NP languages. We discuss their graph modeling: Goldreich, Mi-
cali and Wigderson [21] offered such a construction with O(m2) rounds and O(n)
messages each. Based on the existence of a non-uniformly secure encryption function,
they explored graph isomorphism and non-isomorphism as well as graph 3-colorability
(G3C). Blum’s proof [3] shows directed Hamiltonian cycles (DHC) in graphs. Both
proofs use a metaphor of locked boxes to formulate the proof. Goldreich et al.’s G3C
proof encodes the colors of adjacent vertices in boxes. Blum’s proof of Hamiltonian

cycles encodes the graph’s adjacency matrix randomly in n +(cid:0)n

(cid:1) such boxes, giving

the veriﬁer the choice to either verify the correct graph representation or the knowledge
of the Hamiltonian cycle. Blum offers an alternative construction for G3C with a sim-
ilar methodology, encoding the graph representation and the coloring of each vertex in
separate yet related boxes and operating on an adjacency matrix lifted to the labeling.
Goldreich and Kahan [20] offered a constant-round construction based on the existence
of collections of claw-free functions, also using G3C as NP-problem. We observe that
these constructions are speciﬁc to the statement to be proven and do not cater for a level
of indirection through a signature scheme.

2

A related notion to full graph signatures is transitive signature schemes, e.g., as
proposed by Micali and Rivest [23]. They are concerned with the transitive closure of
signatures on graph elements, where vertices and edges are signed individually; how-
ever, they do not offer zero-knowledge proofs of knowledge on graph properties.

Fig. 2. Experimental performance analysis with a secure modulus length of 2048 bits, in the worst
case of a non-parallelized computation on a single processor core (adapted from [2]). x-axis con-
tains the number of vertices n and the y-axis a log-scale of computation time in milliseconds.
Blue colors denote provider computations to prove properties of a committed graph, where the
green line shows a proof of representation of a graph signature. Red colors denote auditing sys-
tem/issuer computations to sign the graph.

8 Conclusion

We have introduced a practical construction of signatures on committed graphs and
zero-knowledge proofs over their structure. The scheme is special in that it enables
proofs over the entire graph structure, including statements such as isolation (two ver-
tices are not connected by any sequence of edges). The construction derives its secu-
rity from the properties of the Camenisch-Lysyanskaya (CL) signature scheme under
the Strong RSA assumption. The interactive proofs are honest-veriﬁer zero-knowledge
if executed with multiple rounds with small challenges. While we have established a
framework for graph topology proofs separately [2], this work focuses on the founda-
tions of graph encoding in CL-signatures itself. We show its theoretical expressiveness
by proving that the scheme is capable of signing committed NP statements and prov-
ing properties thereof, via reduction to graph 3-colorability. The presented scheme is
efﬁcient and practical because once the issuer has established graph well-formedness
in O(n2), the prover can resort to proofs over the graph structure in linear time. The
used Σ-proofs can be handled efﬁciently with batch processing techniques [25]. As fu-
ture work, we aim at establishing a differential graph signature scheme, which can be
employed for large-scale graph topologies as found in virtualized infrastructures.

1.00E+001.00E+011.00E+021.00E+031.00E+041.00E+051.00E+061.00E+07010002000300040005000600070008000900010000Time in milliseconds   (log-scale) # Vertices n (# Edges m=2n) DecompositionVertex CompositionEdge CompositionRepresentationSignature GenerationIssuing: 1 second Representation: 5 minutes Full Decomposition: 3 hours References

1. ABE, M., FUCHSBAUER, G., GROTH, J., HARALAMBIEV, K., AND OHKUBO, M.
In Advances in

Structure-preserving signatures and commitments to group elements.
Cryptology–CRYPTO 2010. Springer, 2010, pp. 209–236.

2. ANONYMIZED FOR REVIEW. Anonymized for review. In conference proceedings to appear

(Nov. 2014).

3. BLUM, M. How to prove a theorem so no one else can claim it.

In Proceedings of the

International Congress of Mathematicians (1986), vol. 1, p. 2.

4. BOUDOT, F. Efﬁcient proofs that a committed number lies in an interval. In Advances in
Cryptology — EUROCRYPT 2000 (2000), B. Preneel, Ed., vol. 1807 of Lecture Notes in
Computer Science, Springer Verlag, pp. 431–444.

5. BRANDS, S. Rapid demonstration of linear relations connected by boolean operators. In
Advances in Cryptology — EUROCRYPT ’97 (1997), W. Fumy, Ed., vol. 1233 of Lecture
Notes in Computer Science, Springer Verlag, pp. 318–333.

6. BRICKELL, E., CAMENISCH, J., AND CHEN, L. Direct anonymous attestation. In Proc.
11th ACM Conference on Computer and Communications Security (2004), acm press,
pp. 225–234.

7. CAMENISCH, J., CHAABOUNI, R., AND SHELAT, A. Efﬁcient protocols for set membership
and range proofs. In Advances in Cryptology-ASIACRYPT 2008 (2008), Springer, pp. 234–
252.

8. CAMENISCH, J., AND GROSS, T. Efﬁcient attributes for anonymous credentials. ACM

Transactions on Information and System Security (TISSEC) 15, 1 (2012), 4.

9. CAMENISCH, J., AND LYSYANSKAYA, A. Efﬁcient non-transferable anonymous multi-
show credential system with optional anonymity revocation. In Advances in Cryptology —
EUROCRYPT 2001 (2001), B. Pﬁtzmann, Ed., vol. 2045 of LNCS, Springer Verlag, pp. 93–
118.

10. CAMENISCH, J., AND LYSYANSKAYA, A. A signature scheme with efﬁcient protocols. In
Security in Communication Networks SCN 2002 (2003), vol. 2576 of LNCS, Springer Verlag,
pp. 268–289.

11. CAMENISCH, J., AND MICHELS, M. Proving in zero-knowledge that a number n is the
product of two safe primes. In Advances in Cryptology — EUROCRYPT ’99 (1999), J. Stern,
Ed., vol. 1592 of Lecture Notes in Computer Science, Springer Verlag, pp. 107–122.

12. CAMENISCH, J., AND STADLER, M. Efﬁcient group signature schemes for large groups. In
Advances in Cryptology — CRYPTO ’97 (1997), B. Kaliski, Ed., vol. 1296 of Lecture Notes
in Computer Science, Springer Verlag, pp. 410–424.

13. CHAN, A., FRANKEL, Y., AND TSIOUNIS, Y. Easy come – easy go divisible cash.

In
Advances in Cryptology — EUROCRYPT ’98 (1998), K. Nyberg, Ed., vol. 1403 of Lecture
Notes in Computer Science, Springer Verlag, pp. 561–575.

14. COOK, S. A. The complexity of theorem-proving procedures. In Proceedings of the third

annual ACM symposium on Theory of computing (1971), ACM, pp. 151–158.

15. CRAMER, R., DAMGÅRD, I., AND SCHOENMAKERS, B. Proofs of partial knowledge and
simpliﬁed design of witness hiding protocols. In Advances in Cryptology — CRYPTO ’94
(1994), Y. G. Desmedt, Ed., vol. 839 of LNCS, Springer Verlag, pp. 174–187.

16. DAMGÅRD, I., AND FUJISAKI, E. An integer commitment scheme based on groups with

hidden order. http://eprint.iacr.org/2001, 2001.

17. FIAT, A., AND SHAMIR, A. How to prove yourself: Practical solutions to identiﬁcation and
signature problems. In Advances in Cryptology — CRYPTO ’86 (1987), A. M. Odlyzko, Ed.,
vol. 263 of Lecture Notes in Computer Science, Springer Verlag, pp. 186–194.

18. FUJISAKI, E., AND OKAMOTO, T. Statistical zero knowledge protocols to prove modular
polynomial relations. In Advances in Cryptology — CRYPTO ’97 (1997), B. Kaliski, Ed.,
vol. 1294 of Lecture Notes in Computer Science, Springer Verlag, pp. 16–30.

19. GAREY, M. R., JOHNSON, D. S., AND STOCKMEYER, L. Some simpliﬁed np-complete
In Proceedings of the sixth annual ACM symposium on Theory of computing

problems.
(1974), ACM, pp. 47–63.

20. GOLDREICH, O., AND KAHAN, A. How to construct constant-round zero-knowledge proof

systems for NP. Journal of Cryptology 9, 3 (1996), 167–190.

21. GOLDREICH, O., MICALI, S., AND WIGDERSON, A. Proofs that yield nothing but their
validity or all languages in np have zero-knowledge proof systems. Journal of the ACM
(JACM) 38, 3 (1991), 690–728.

22. IBM. Speciﬁcation of the Identity Mixer cryptographic library, v. 2.3.40. Speciﬁcation, IBM

Research, Jan. 2013. http://prime.inf.tu-dresden.de/idemix/.

23. MICALI, S., AND RIVEST, R. L. Transitive signature schemes. In Topics in Cryptology-

CT–RSA 2002. Springer, 2002, pp. 236–243.

24. PEDERSEN, T. P. Non-interactive and information-theoretic secure veriﬁable secret sharing.
In Advances in Cryptology – CRYPTO ’91 (1992), J. Feigenbaum, Ed., vol. 576 of Lecture
Notes in Computer Science, Springer Verlag, pp. 129–140.

25. PENG, K., BOYD, C., AND DAWSON, E. Batch zero-knowledge proof and veriﬁcation and
its applications. ACM Transactions on Information and System Security (TISSEC) 10, 2
(2007), 6.

26. RIVEST, R. L., SHAMIR, A., AND ADLEMAN, L. A method for obtaining digital signatures

and public-key cryptosystems. Communications of the ACM 21, 2 (Feb. 1978), 120–126.

27. SCHNORR, C. P. Efﬁcient signature generation for smart cards. Journal of Cryptology 4, 3

(1991), 239–252.

A Proofs

A.1 Well-formed Encoding and Security

Proof (Unambiguous encoding and decoding: Theorem 2). We show that there is a bijection
between encoding and graph.
Graph → encoding: For each graph there exits a unique encoding modulo base association. For
all vertices i ∈ V choose the vertex identiﬁer ei ∈ ΞV, for the labels k ∈ fV(i) choose the prime
representative ek ∈ ΞL and compute their product. As said factors are prime, it follows from
the fundamental theorem of arithmetic that the eiΠk∈fV (i)ek represents a unique integer. Given
that the user is not privy to the discrete logarithm between one base and another (guaranteed by
the CL-Signature setup), the bases unambiguously separate the exponents. Thus, apart from the
random permutation of the base association, the encoding is unambiguous.
Encoding → graph: With knowledge of the elements of ΞV and ΞL, an encoded product can
be decoded efﬁciently and unambiguously into the elements of the graph. That the parties are not
privy to the discrete logarithm between base and another guarantees attribute separation. The base
designates unambiguously whether a vertex or an edge is encoded. Given that all representatives
of the encoding are prime, the product can be decomposed into a unique factorization by the
fundamental theorem of arithmetic. Each representative unambiguously represents either a vertex
(cid:3)
identiﬁer in ΞV or a label in ΞL, as both sets are disjoint.

Proof (Security of graph signatures: Theorem 4). The security of the scheme is directly derived
from the unambiguous embedding into Integer commitments and Camenisch-Lysyanskaya sig-
natures and their security properties. Theorem 2 establishes that the graph encoding encodes

graphs unambiguously into the CL-message space. The graph structure is encoded in the expo-
nents of the Integer commitment and CL-signature schemes. Conﬁdentiality is derived from the
information-theoretical hiding property of the Integer commitment scheme and the hiding proper-
ties of CL-signatures on committed messages. Under the condition that the adversary is not privy
to the group-order of the commitment and the CL signature scheme, we obtain that integrity for
both schemes holds over the integers and thereby the graph encoding (cf. [16]). We obtain exis-
tential unforgeability against chosen message attacks directly from the CL-signature scheme in
Theorem 1 [10].

B Well-formedness Proof

The following proof is representative for the argument structure of the proofs for different predi-
cates; others use the same tools.

Proof (Wellformedness proofs, Theorem 3).
The Schnorr proofs used in the construction are honest-veriﬁer zero-knowledge if executed re-
peatedly with small challenges, otherwise witness-indistinguishable. It is standard to extract from
a successful prover knowledge on the secrets ranging over ∀i, j:
0
0
i, ˙εi, γ(i,j), ρ
(i,j), αi,j, βi,j, ρi,j

µi, µ(i,j), ρ, ρi, ρ(i,j), εi, ˘ρi, γi, ρ

such that all equations of the CS-notation hold for some t, where t must be ±1 as modulus N is
a product of two safe primes [16]. As CL-signatures are existentially unforgeable [10], we obtain
that the messages µi and µ(i,j) are indeed signed, and that the membership proofs for εi establish
that εi ∈ ΞV, i.e., are certiﬁed vertex identiﬁers (the CL multi-show unlinkability ensures that the
veriﬁer learns no other information about εi). The CG-OR proofs [8] yield that γi and γ(i,j) must
encode valid vertex label identiﬁers (but yield no further information on the labels). Therefore,
we have ﬁxes the roots µi, µ(i,j) and the leaves εi, γi, γ(i,j) of the proof tree in the CL-notation.
It remains to show what can be derived from the equations that connect the roots to the leaves
in the vertex and edge composition statements and from the pairwise difference. The technique
used is a standard decomposition of certiﬁed messages in Integer commitments to make their
components accessible to discrete-logarithm based proofs of knowledge; if the same secret is
referenced we have an equality proof, if not there is no further information learned about the re-
i Sρ0
lation of the secrets. For the vertices, the equation Ci ≡ ± ˘C γi
i(4) establishes that µi = εiγi,
given that the prover does not know a multiple of the group order, ˘Ci separates out εi connected
(i,j) Sρ0
to the membership proof. For edges, the equation C(i,j) ≡ ± ˘C
(i,j)(7) establishes that
(i,j)γ(i,j), where ˘C(i,j) is shown to contain a product ˙εi ˙εj in equation (3), which are
µ(i,j) = µ0
in turn shown to be valid vertex identiﬁers (8). By that all variables are bound and the connection
between the roots and the leaves established.

γ(i,j)

Finally, we claim pair-wise difference on vertices from the equation

R ≡ ± ˘C αi,j

i

˘C βi,j
j Sρi,j

(9).

Unless the prover knows a multiple of the group order or the discrete logarithm logR S, the
following equation must hold over the integers:

1 = εiαi,j + εjβi,j.

It is well-known that αi,j and βi,j only exist if εi and εj are coprime, which gives us the pair-wise
difference claimed.

B.1 Graph 3-Colorability (G3C)

Proof (Graph 3-Colorability: Lemma 1). 1. Proof of Knowledge. It is standard to show that there
exists a knowledge extractor for all exponents of the proof such that the equality of exponents
equations are fulﬁlled.

We obtain from Clause 1 that the prover knows the representation of a CL-Signature of the
given structure. From the existential unforgeability of CL-Signatures, we see that the issuer must
have signed the secret attributes µi, µj and µ(i,j). Proving equality of exponents with correspond-
ing integer commitments is standard, by which the arguments over the commitments, such as Ci,
˘Ci and C(i,j) transfer to the structure of the signed messages.
The Clause 4 shows that a message µi consists of two factors known to the prover: µi = εiγi.
The following Clause 5 employs a set membership proof to show that εi ∈ ΞV and that γi ∈ ΞL.
We use that the set membership from §2.5 guarantees that εi and γi are exactly one member of the
set to conclude that a message µi contains exactly one vertex identiﬁer and one label identiﬁer.
Thus, µi is well-formed. Similarly, Clause 6 establishes the structure µ(i,j) = εiε for the edge
(i, j), showing it to be well-formed. Because the prover is not privy to the group order, these
statements hold over the integers, by the results of Damgård and Fujisaki [16]. Therefore, with
the proof of representation including pair-wise difference, we conclude that the signed graph is
well-formed.

Clause 7 shows that the labeling fV of the signed graph is a proper coloring. Again, we
employ Damgård and Fujisaki’s [16] result that equations hold over the integers. We have that for
each edge (i, j), the corresponding signed messages have the following structure:

µi = εiγi

and

µj = εjγj.

We show that the secret labels γi and γj are different by showing that µi and µj are coprime,
where we use Bézout’s Identity:

gcd(µi, µj) = 1 ⇔ 1 = α(i,j)µi + β(i,j)µj.

The equality of exponent proof of Clause 7 achieves this as follows

α(i,j)
i

C

β(i,j)
j

Sρ(i,j) (mod N)

R ≡ ±C
1 ≡ ±(Rµ
R
1 ≡ ±Rα(i,j)µi Sα(i,j)ρi Rβ(i,j)µj Sβ(i,j)ρj Sρ(i,j) (mod N)
1 ≡ ±Rα(i,j)µi+β(i,j)µj Sα(i,j)ρi+β(i,j)ρj+ρ(i,j) (mod N)

j Sρj )β(i,j) Sρ(i,j) (mod N)

i Sρi)α(i,j)(Rµ

R

R

From this equation we can conclude that gcd(µi, µj) = 1 and that, therefore, γi 6= γj, which
implies that fV(i) 6= fV(j) and that the CL signature indeed contains a proper coloring.
(cid:3)
2. Zero-Knowledge. We claim that proof does not disclose anything else than the statement
made that the prover knows a CL-Signature of a proper coloring on known graph G.

The Σ-proofs here are zero-knowledge in an honest veriﬁer setting if performed with multiple
rounds and small challenges. It is standard to construct a simulator for all Σ-proofs of representa-
tion for the CL-Signature and the commitments as well as for their conjunction [12,15], showing
that the veriﬁer does not learn anything else than the relations on exponents shown.

It remains to be shown what the relations disclose. We will argue on the statements made on
the secret messages γi, which contain the color. Clause 4 establishes that γi is part of commitment
Ci, but does not disclose further information than the equality of exponents.
Clause 5 proves that γi is a member of the set ΞL = {eR, eG, eB}. This statement itself is part
of the known problem deﬁnition of G3C. The set membership proof is a proof of representation

for an anonymized CL-Signature and a standard proof of equality of exponents, and thereby, does
not disclose further information.

Finally, Clause 7 references µi = iγi to prove that γi and γj of an adjacent edge are
coprime. As the vertex identiﬁers are pair-wise different by deﬁnition and as all representatives
are primes, this only establishes that γi 6= γj as required by the G3C problem, but nothing else.
(cid:3)

Proof (Polynomial Proof of G3C: Lemma 2). Precomputation: The prover computes 2n + 1
signature randomizations with one exponentiation each and 2n + m integer commitments with 2
exponentiations each. The pre-computation phase uses 6n + 2m + 1 exponentiations, transmits
4n + m + 1 group elements, and thereby has a computation complexity of O(n + m) and a
communication complexity of O(n + m).

Proof of Knowledge: The Schnorr proofs in the proof of knowledge are zero-knowledge if
executed with small challenges over multiple rounds and can be connected with techniques from
Cramer et al. [15]. The round complexity of the overall protocol is dependent on the proof mode
(cf. Brands [5]).

Clause 1 is executed once yielding a Schnorr proof with n + m + 2 exponentiations for the

prover.

The clauses 2 are executed once for each vertex, such as i and j, Therefore we have n Schnorr

proofs with 2 exponentiations each for the prover.

The clauses 3 are executed once for each edge (i, j), making m Schnorr proofs with 2 expo-

nentiations each for the prover.

with 2 exponentiations each for the prover.

The clauses 4 are executed once for each vertex, such as i or j. We have 2n Schnorr proofs

The set membership proofs of Clauses 5 are executed once for each vertex and its label. Each
set membership proof is a proof of representation of a designated CL-Signature for the set mem-
ber, amounting to 3 exponentiations for the prover. In total, we have 2n such proofs of posses-
sions, all done with a single Schnorr proof proving equality of exponents with the corresponding
commitment.

Clause 6 proves the edge structure and is executed once per edge, yielding m Schnorr proofs
with 2 exponentiations each for the prover. Finally, the proper graph coloring in Clause 7 is shows
once for each edge (i, j) amounting to m Schnorr proofs with 3 exponentiations for the prover.
The proof of knowledge of graph coloring thereby requires 5n + 3m + 1 = O(n + m)
Schnorr proofs with a computational complexity for the prover of 13n + 8m + 2 = O(n + m)
exponentiations.

The total computational complexity is therefore O(n + m), the communication complexity
is O(n + m) group elements. The G3C proof is done in polynomial time. The round complexity
depends on the proof mode, where variants with multiple rounds (number of rounds depending
on the error probability), with four rounds and initial commitments of the veriﬁer on challenges,
(cid:3)
and three rounds in a Σ-proof (not zero-knowledge) are possible.

B.2 CL Proof Systems for NP-Statements

Proof (Sketch NP-Statements: Theorem 5). Let a NP language L be given. Let τ be a polynomial-
time computable and invertible reduction from L to Graph 3-Colorability (G3C): τ can be con-
structed by composing a polynomial-time reduction of L to 3SAT by Cook’s proof [14] and a
polynomial-time reduction from 3SAT to G3C. We have that x ∈ L iff τ(x) is 3-colorable.
On common input x, both prover and veriﬁer compute graph G ← τ(x). In Goldreich, Micali
and Widgerson’s work, the proof proceeds to use any interactive zero-knowledge proof system to

prove that G is 3-colorable and thereby show that x ∈ L. Our proof continues from this point to
show that there exists a Camenisch-Lysyanskaya proof system.
On obtaining G = τ(x), the prover constructs a graph commitment C on G as deﬁned in §3,
including a labeling fV of a proper coloring of G. The known-graph proof transmits G itself, yet
keeps the proper coloring conﬁdential as default.
Proof of representation P → I : The prover interacts with an CL-Signature issuer, proving
representation and well-formedness of the commitment C in a known-graph proof, disclosing
information to satisfy the veriﬁcation requirements of the issuer. As τ(x) is invertible, this proof
of representation of G and the proper coloring serves as proof of representation for x and x ∈ L.
Issuing I → P : Upon acceptance of the proof, the issuer signs the committed graph G in
a CL-Signature σ. Given the invertibility of τ, this signature holds for x as well. sigma is a
CL-Signature on τ(x) and the proper coloring of τ(x) iff x ∈ L.
Proof of possession P → V : The prover interacts with the veriﬁer to proof knowledge of the
CL-Signature σ on a proper coloring on G and thereby shows graph 3-colorability of τ(x), which
holds iff x ∈ L. Thereby, the proof of possession of σ translates to a proof of possession of the
statement x ∈ L. The proof is zero-knowledge if executed with small challenges over multiple
(cid:3)
rounds.

