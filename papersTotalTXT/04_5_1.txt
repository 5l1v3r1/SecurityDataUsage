DEFY: A Deniable, Encrypted File System

for Log-Structured Storage

Timothy M. Peters

Cal Poly, San Luis Obispo

tipeters@calpoly.edu

Mark A. Gondree

Naval Postgraduate School

mgondree@nps.edu

Zachary N. J. Peterson
Cal Poly, San Luis Obispo

znjp@calpoly.edu

Abstract—While solutions for ﬁle system encryption can pre-
vent an adversary from determining the contents of ﬁles,
in
situations where a user wishes to hide the existence of data,
encryption alone is not sufﬁcient. Indeed, encryption may draw
attention to those ﬁles, as they may likely contain information the
user wishes to keep secret. Consequently, adversarial coercion
may motivate the owner to surrender their encryption keys,
under duress. This paper presents DEFY, a deniable ﬁle system
following a log-structured design. Maintaining a log-structure is
motivated by the technical constraints imposed by solid-state
drives, such as those found in mobile devices. These devices
have consequential properties that previous work largely ignores.
Further, DEFY provides features not offered by prior work,
including: authenticated encryption, fast secure deletion, and
support for multiple layers of deniability. We consider security
against a snapshot adversary, the strongest deniable ﬁlesystem
adversary considered by prior literature. We have implemented
a prototype based on YAFFS and an evaluation shows DEFY
exhibits performance degradation comparable to the encrypted
ﬁle system for ﬂash, WhisperYAFFS.

I.

INTRODUCTION

Mobile devices are becoming increasingly ubiquitous and
powerful. They collect and store large amounts of personal
or sensitive information. Some users need to protect
that
data from unauthorized access just as they would on normal
platforms. Evidence of this need can be found on the Google
Play store where there are a number of privacy-enhancing
technology apps, including: ChatSecure [3] (secure texting),
WhisperYAFFS [51] (an encrypted ﬁle system), RedPhone [49]
(encrypted calls), TextSecure [50] (secure texting), Orbot [4]
(tor for mobile), Lookout [5] (data backups and anti-virus),
and many more.

The standard method of preventing unauthorized access
to information on mobile devices is the same as in general
secure communication: encryption. While encryption serves to
limit access to certain ﬁles, it does not attempt to hide their
existence. In fact, encryption reveals the existence (and often,
size) of information that the user does not want others to see.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23078

In many environments, allowing an adversary to learn that
a device contains sensitive data may be as damaging as the loss
or disclosure of that data. Consider covert data collection in
a hostile country, where mobile devices carrying information
might be examined and imaged at border checkpoints. Inspec-
tors may discover the presence of encrypted data, or identify
changes to the encrypted ﬁle system over time, and demand
that they be decrypted before allowing passage. This is not a
ﬁctional scenario. In 2012, a videographer smuggled evidence
of human rights violations out of Syria. He lacked any data
protection mechanisms and instead hid a micro-SD card in a
wound on his arm [29]. In another example, the human rights
group Network for Human Rights Documentation - Burma
(ND-Burma) collects data on hundreds of thousands of human
rights violations by the Burmese government. They collect
testimony from witnesses within the country that the Burmese
government would not want released, putting both activists and
witnesses in grave danger should the government gain access to
these data [2]. In light of the control exerted by the government
over the Internet within Burma [37], ND-Burma activists carry
data on mobile devices, risking exposure at checkpoints and
border crossings. Using a way to hide the encrypted data such
that inspectors cannot reasonably infer sensitive data exist on
the device, risk to activists and witnesses can be lessened.

A promising approach to securing data under these condi-
tions is to employ a class of ﬁle system known as deniable ﬁle
systems. Deniable ﬁle systems mask information about stored
data, and allow a user to plausibly deny any storage artifacts
on their device, typically by encrypting data with different
keys based on the sensitivity of the data. Unfortunately, all
known methods to provide deniability from previous designs
are inapplicable when applied to ﬂash-based storage devices.
In particular, for ﬂash media, strategies that require in-place
modiﬁcation of blocks are unavailable, due to wear-leveling
requirements and the special handling required for erasures
and writes in NAND ﬂash.

In this paper we present DEFY, the Deniable Encrypted
File System from YAFFS. DEFY is speciﬁcally designed
for ﬂash-based, solid-state drives—the primary storage device
found in most mobile devices. The physical properties of ﬂash
memory introduce unique challenges to plausible deniability,
requiring us to depart non-trivially from the designs of prior
deniable ﬁle systems. In particular, hardware-implemented
wear leveling essentially forces DEFY to embrace a log-
structured design. The DEFY ﬁle system provides a number
of features not offered by prior work:

•

•

•

•

•

it features a generic design, adaptable to other set-
tings requiring deniability while maintaining a log-
structure;

it supports an arbitrary number of user-deﬁned denia-
bility levels that can be created or removed from the
system, dynamically;

it is the ﬁrst encrypted ﬁle system for mobile devices
providing authenticated encryption;

it provides a fast and efﬁcient mechanism to securely
delete data, allowing individual ﬁles or the entire ﬁle
system to be deleted in bounded time. What’s more,
it is the ﬁrst ﬁle system to provide secure deletion of
prior allocations by policy;

it is designed to be resistant against the most powerful
adversary considered by prior work, a snapshotting
adversary.

DEFY’s design is a signiﬁcant departure from previous
deniable ﬁle systems, which require strict control over block
placement on the device, and whose security guarantees do
not hold when the underlying media re-maps their writes.
For example, for storage using a hardware ﬂash translation
layer (FTL), prior designs are only secure under the addi-
tional assumption that the media is effectively tamperproof,
i.e. the hardware controller implementing the FTL cannot be
bypassed during adversarial analysis (revealing past writes).
Alternatively, when no FTL is performed, those systems ignore
the constraints of the underlying media, e.g., they do not wear-
level appropriately. In contrast, DEFY embraces a logical log-
structure so that its security guarantees hold, especially when
the underlying media is also written in a log-structure. Indeed,
DEFY solution is generalizable, and can be used with devices
employing hardware FTL (without additional assumptions),
with those requiring FTL logic be implemented by the ﬁle
system, or with those requiring no FTL logic at all.

When DEFY is used with only a single deniability level,
it acts like an encrypted ﬁle system with additional features
(secure deletion, authenticated encryption) appropriate for
mobile devices, making it attractive beyond deniability. We
provide a prototype implementation of DEFY and remark on
the system’s performance, showing performance comparable
to WhisperYAFFS, the encrypted ﬁle system for ﬂash storage.

II. RELATED WORK

Anderson et al. propose the ﬁrst ﬁle system with the secu-
rity property of plausible deniability [9]. They present schemes
demonstrating two alternate approaches: hiding blocks within
valid-looking data (“cover ﬁles”), and hiding blocks within
random data. DEFY follows this second basic approach.
Writing new data has the possibility of over-writing data
at unrevealed levels. Anderson et al. use block replication
and random block placement
to reduce the probability of
overwriting,

McDonald and Kuhn describe StegFS, an implementation
based on adapting Anderson et al.’s construction to the ext2
ﬁle system [28]. They use a block allocation table to track
ﬁles, rather than random block placement.

Pang, Tan, and Zhou describe a different implementation,
also called StegFS [33]. Their implementation uses an unen-
crypted global bitmap to ensure blocks are not accidentally
overwritten. To ensure deniability, “dummy blocks” are oc-
casionally written; these explain blocks apparently in-use but
otherwise unreadable by the ﬁle system.

Gasti et al. describe DenFS, a FUSE leveraging cloud
storage and providing deniability in the event the cloud ser-
vice becomes compromised [22]. DenFS uses cover ﬁles and
deniable encryption [16] to protect remote data. In DenFS, the
adversary may intercept messages and request remote ﬁles be
revealed, but it cannot seize arbitrary snapshots of local storage
(which may reveal local caches, the database of pre-generated
cover ﬁles, etc.). Their model is not appropriate for threats
associated with seizure of mobile devices, as considered here
and in other prior work.

Skillen and Mannan describe Mobiﬂage, a deniable ﬁlesys-
tem for Android devices [46]. Their system hides a drive image
in the standard encrypted ﬁle system, placing it at a random
location, somewhere in the third quarter of the drive’s address
space. This is similar to the design of a “hidden volume” under
TrueCrypt [6]. Efforts to port TrueCrypt to mobile platforms
also follow this pattern. Each of these systems work at the
block device layer or higher, ignoring the unique properties
of ﬂash storage; thus, the log-structure below this layer may
potentially undermine the deniability of the hidden ﬁlesystem
above it, revealing recent activity on the hidden portion of the
device. Further, these systems lack support for more than one
deniability level, and are not trivially extensible to handle this
feature.

WhisperYAFFS is a system providing full disk encryption
on ﬂash devices [51]. It provides only conﬁdentiality without
authenticity and, unlike DEFY and other deniable ﬁle systems,
does not provide plausible deniability; in particular, its use of
plaintext block sequence numbers trivially leaks the history of
block updates.

III. BACKGROUND

Pushed by demand from the growing mobile device market,
solid-state memory has become a popular alternative to hard
disk drives, due to its small power footprint, lack of moving
mechanical parts and high speed. The evolution of ﬂash has
largely been a balancing act between cost, capacity, perfor-
mance, lifespan, and granularity of access/erasure. The most
recent generation of ﬂash is NAND ﬂash. NAND is cheaper
to manufacture and denser (bytes per die) than it predecessors,
EEPROM and NOR technologies. Current NAND chip sizes
are as large as 256GB.

NAND offers random-access reads and writes at the page
level, while erasure occurs at the block level. For example, an
8GB NAND device with 212 blocks can write a 4KB page but
must erase at the granularity of a 256KB block. Once pages
are programmed, they must be erased before they are written
again; this is called the program-erase cycle. A per-page Out-
of-Bound (OOB) area holds metadata and error correction
codes for the page’s data.

Flash memory degrades after many program-erase cycles,
becoming unreliable after 10,000–100,000 cycles. Many solid-
state drives employ wear leveling to extend their lifespan

2

within this constraint: drivers attempt to disperse erase/write
trafﬁc to avoid media wear. In dynamic wear leveling, data is
written to locations based on availability and a least-written
count. In static wear leveling, some existing, under-utilized
(static) block may be moved to distribute wear on the device
during a page write request. Most devices implement dynamic
wear leveling, for its simplicity and speed.

Flash devices can be accessed using Linux’s memory
technology device (MTD) subsystem interface, essentially pro-
viding a “raw” interface to NAND ﬂash devices. An MTD
provides a consistent mapping from logical blocks to physical
blocks, it provides no write leveling, and thus nothing to pre-
vent cell overuse. The unsorted block images (UBI) interface
builds on MTD, providing an abstraction comparable to the
Linux Logical Volume Manager for ﬂash storage. UBI tracks
logical blocks in a data structure, deciding to re-map logical
blocks based on use, implementing wear leveling. A ﬂash
translation layer (FTL) can be built on top of UBI, providing a
simpliﬁed, block-level interface for ﬂash, in exchange for a loss
of low-level control over data placement and strict overwrites.

A. YAFFS Overview

YAFFS is a ﬁle system designed for use with NAND ﬂash
memory. Due to its simplicity, portability, and small memory
footprint, YAFFS has been used as the default ﬁle system in
many mobile devices, including the Android operating system.
YAFFS is a true log-structured ﬁle system [41], [44] in that
write requests are allocated sequentially within the logical
address space. Its design is largely motivated by a desire
to integrate with device-level wear leveling. Next, we brieﬂy
summarize YAFFS’s design; for a more thorough description,
we direct readers to Manning [27] and related resources, e.g.,
Schmitt et al. [42].

The unit of allocation is the page (called a chunk in YAFFS
terminology), ranging from 512-bytes to 32KB in size. The
unit of erasure is the block, each block being composed of 32–
128 pages, depending on the NAND block capacity. YAFFS
uses the OOB space provided by a ﬂash device to store page
metadata and an error correction code.

There are two versions of YAFFS: YAFFS1 and YAFFS2.
The key distinctions between these are: (1) YAFFS1 is de-
signed to work with page sizes up to 1KB while YAFFS2
supports larger pages, and (2) YAFFS2 implements a true log-
structured ﬁle system, performing no overwrites when new
data are written. This paper refers to the YAFFS2 design, and
we use the terms YAFFS2 and YAFFS interchangeably.

Every YAFFS entity (ﬁles, directories, links, etc.) is main-
tained as an object, with an object header. Each object header
stores metadata about its associated object, including its name,
its size, and location its pages. A directory’s header contains
the location of headers for its children (ﬁles and subdirecto-
ries).

B. Writing in YAFFS

Every page is assigned a sequence number, stored in the OOB
section of memory. The sequence number is monotonically
increasing, i.e., the last page written has the highest value,
making it the new leading edge of the log. The leading edge
marks the starting point for the system when searching for the
next page to allocate.

When a page is updated, its corresponding object header
is updated to reference the new page. When an object header
is updated, it too will be written to a new page, and the object
containing it (e.g. a directory) will also be updated. Therefore,
when a page is modiﬁed, the directory path above its object,
up to and including the root, is modiﬁed on disk.

C. Mounting in YAFFS

YAFFS supports special objects known as checkpoints.
These commit information about the state of the ﬁle system
to the drive. On mount, YAFFS searches for the most recent
checkpoint, using it to reconstruct in-memory data structures.
In the absence of a checkpoint, YAFFS will scan the entire
disk, creating a list of blocks and sorting these by sequence
number. Then, in descending order, it examines the contents
of each block: invalid pages are ignored and valid pages are
added to an associated in-memory object (creating an object,
if necessary).

Unlike most disk ﬁles systems (e.g., ext2/3/4, NTFS,
HFS+), a YAFFS partition does not need to be formatted
before being mounted. If no valid objects or checkpoints are
found during mounting, all blocks are marked as available for
allocation.

D. Garbage Collection in YAFFS

Since YAFFS is a log-structured ﬁle system, a page is
never updated in place. Thus, when a page is updated, an
older version of the page likely exists elsewhere on disk. Since
NAND requires a page be erased before it can be written and
offers only block-level erasure granularity, a block may contain
many obsolete pages that cannot be reclaimed until all pages
in the block are obsolete.

YAFFS supports two, heuristic modes of garbage collec-
tion: passive and aggressive garbage collection. In general,
YAFFS garbage collection proceeds in the following fashion.
The system scans the disk looking for a “dirty” block, i.e. a
block with “few” valid pages. The deﬁnition of “few” depends
on the garbage collection mode. During normal operation, the
collector considers a block to be “dirty” if the number of
valid (active) pages in the block is below some threshold. On
startup, during passive garbage collection, this threshold is
lowest: if no more than four pages are valid, then the block
is dirty. On each unsuccessful scan, the threshold is increased,
beginning with four but never going beyond half the pages in a
block. When every block is more than half full, the system will
switches to aggressive garbage collection, where a block with
any dirty page is considered dirty. Once a block is identiﬁed
for collection, YAFFS re-writes its valid pages to the leading
edge and erases the dirty block, making it available for writing.

Write requests are divided into pages, allocated and written
sequentially following the leading edge of the log (the last page
written). If the leading edge is the last page of a block, YAFFS
searches for the next block past the leading edge that is not full.

IV. SECURITY MODEL

Before describing the design of DEFY, we introduce our

adversarial model and security goals.

3

A. Adversaries

A secure, deniable ﬁle system hides the existence of
information from an adversary. It conceals all indication as
to whether or not there are hidden ﬁles or directories, at the
ﬁle system level. It does not, however, enforce a system-wide
information ﬂow policy. Czekis et al. demonstrate how it is
possible to infer the existence of hidden ﬁles using the content
of revealed ﬁles, e.g. indices generated by services for desktop
search [17]. We assume users, the OS and applications use the
ﬁle system appropriately.

We deﬁne two types of passive adversaries for deniable
ﬁle systems: those with one-time access to the device (single-
view adversaries) and those with periodic access (snapshot
adversaries). In this context, an adversary’s “access” yields a
full copy of the disk and a complete description of the ﬁle
system (e.g. through a copy of its source code). Further, the
adversary is allowed to force the user to reveal some set of hid-
den ﬁles. As with previous work, the adversary cannot access
the device’s RAM contents nor capture the running state of the
device while outside of the adversary’s immediate possession,
e.g. using a Trojan to implement a, so called, “Evil Maid”
attack [18], [43] or extracting cryptographic keys from RAM
using a cold boot attack [30]. To help ameliorate these threats,
DEFY could be enhanced with an interface to immediately
zero RAM data structures (including cryptographic keys) in
an emergency situation, i.e. a quick lockout feature that may
result in limited data loss.

The single-view adversary is one that is able to access
the ﬁle system and its user only once. This adversarial model
describes many natural scenarios: those in which the device is
stolen, or it is conﬁscated and the user detained for questioning.
The snapshot adversarial model describes scenarios in which
access to the device is granted at distinct points in time, and ﬁle
system images are collected. For example, upon entering and
exiting a guarded facility or at a border-crossing. The snapshot
adversary may then use differences in the collected images to
identify changed data blocks on the device.

Both models include the ability of adversaries to use
various means (i.e., threats and physical violence) to compel
the user to reveal some set of ﬁles. Both models allow the
adversary to perform advanced computer forensics on the disk
image, use password cracking programs, employ statistical
tests, etc. These models subsume all previous deniable ﬁle
system adversarial models in the literature.

B. Security Deﬁnitions

A deniable ﬁle system offers plausible deniability if the
adversary has no means of proving that the user has withheld
data, beyond what she has chosen to reveal. Alternatively, the
user must be able to convince the adversary that no data has
been written to the ﬁle system beyond what she has chosen to
reveal. In other words, it must be plausible that any unrevealed
block on the disk contains no valid data. Additionally, the ﬁle
system offers snapshot resistance if it has plausible deniability,
even in the presence of a snapshot adversary. In particular, the
user may have written data to the disk between snapshots, and
the adversary can determine which blocks have been modiﬁed
between accesses. It must be possible that any unrevealed
block (modiﬁed or not) contains no data.

V. DESIGN REQUIREMENTS

Before we describe the details of our design, we provide
an overview of the requirements that we believe should guide
the design of any secure, deniable ﬁle system.

Deniability Levels: The concept of a deniability level was in-
troduced in previous deniable ﬁle systems implementations [9],
[28], [33]. A deniability level is a collection of ﬁles that
form a sensitivity equivalence class (e.g., love letters vs. trade
secrets). Here, as in previous work, deniability levels form
a total order: (cid:96)0 ≤ (cid:96)1 ≤ . . . ≤ (cid:96)h. A user has some
secret password to reveal all ﬁles at a chosen deniability level.
Following a convenience established in previous work, when
revealing a level, all lower levels should also be revealed.
The system should be ﬂexible enough to accommodate the
dynamic creation of new deniability levels, rather than pre-
specifying and deﬁning the total set of levels at initialization.
An implementation may, of course, elect to restrict users to
some large, ﬁxed number of levels by default; however, we
believe this should not be a restriction imposed by design.

Secure Deletion: Providing secure deletion is complementary
to the setting of deniability. Secure deletion assures that a
deleted object is permanently inaccessible, even if the device
and keys are later revealed to an adversary. We desire secure
deletion to be efﬁcient, deniable and granular. Granular dele-
tion means deleting the entire ﬁle system or a set of ﬁles is
as complex as deleting an individual ﬁle. Finally, to preserve
deniability, deleted data should not appear to be deleted: it
should be indistinguishable from both data unused by the
system and unrevealed data.

Garﬁnkel and Shelat [21] survey methods to destroy digital
data, and identify two techniques that leave storage devices
usable after erasure: secure overwriting and cryptographic key
disposal. In secure overwriting, old data are overwritten with
new data such that the old data are irrecoverable. Gutmann
[23] gives a technique for magnetic storage devices that takes
35 synchronous passes over the data in order to degauss the
media. (Fewer passes may be sufﬁcient.) Techniques designed
to securely delete data from hard disk drives have been shown
to be ineffective for ﬂash-based storage [48].

For systems that employ encryption, Boneh and Lipton
propose that data may be securely deleted by “forgetting”
the corresponding encryption key [15]; without the key, it
is computationally infeasible to ever decrypt the data again.
The actual disposal of the encryption key may involve secure
overwriting. Results from Reardon et al. [36] and Lee et
al. [26] indicate that key disposal techniques may be the most
appropriate technique for ﬂash storage.

Authenticated Encryption: Authenticated encryption pro-
vides conﬁdentiality and data integrity [11]. Conﬁdentiality,
of course, is essential for hiding data at unrevealed levels.
When users may be compelled to relinquish possession of their
mobile device, the beneﬁts of data integrity under the loss of
physical security are also beneﬁcial. Authenticated encryption,
though, requires message expansion—ciphertext are larger than
the original plaintext—which is an obstacle to its integration
into legacy ﬁle systems. Existing work in cryptographic ﬁle
systems (e.g. [6], [14], [52]) use only unauthenticated block

4

TABLE I: Feature comparison of deniable ﬁle systems.

Single-view Resistance
Snapshot Resistance
Arbitrary No. of Levels
Authenticated Encryption
Efﬁcient Secure Deletion
Data Loss Resistance
Wear Leveling Aware

Skillen et al.
Mobiﬂage [46]

!

DEFY

!
!
!
!
!

Load-dependent

!

!

Pang et al. McDonald et al. Anderson et al. Anderson et al.
Scheme 2 [9]
StegFS [33]

Scheme 1, [9]

StegFS [28]

!
!
!

!

!

!

!

!

Probabilistic

Probabilistic

!

!

!

ciphers, which preserves message size to meet the alignment
constraints of block-based storage devices. In practice, addi-
tional storage must be used and managed for the extra bits
associated with ciphertext expansion.

ﬁle system should be easily distributable and compatible with
popular operating systems (e.g. Android and Linux). Using a
loadable kernel module to extend the existing kernel allows
systems to be modiﬁed without rebuilding from source.

Minimizing Data Loss: Data loss occurs when hidden data
(unrevealed data at a high deniability level) is overwritten
because the ﬁle system is mounted at a lower level—an
unfortunate, but unavoidable characteristic of any deniable ﬁle
system. One strategy to prevent overwriting is to maintain a
global list of memory blocks that are free for writing (not in
use by any higher or lower levels); a strategy similar to this is
employed by Pang et al. [33]. Alone, this strategy undermines
plausible deniability: a single-view adversary learns which
blocks are in-use across the system, revealing if hidden levels
exist. The remedy in Pang is to create abandoned blocks,
or blocks that are falsely marked as in-use. This creates
plausible deniability, at the expense of permanently sacriﬁcing
capacity. Anderson et al. [9] prevent data loss in their system
through block replication, similarly suffering a signiﬁcant
overhead to prevent data loss. While the capacity of NAND
drives is increasing and prices decreasing, the cost-per-byte
for ﬂash memory is still almost double that of hard disk
devices, limiting the appeal of solutions with high storage
overheads. What’s more, storage devices that employ wear
leveling preclude ﬁle systems from modifying data in place
or at completely random locations. This entirely excludes data
recovery strategies based on random placement of replicas,
or recovering overwritten blocks from n-out-of-m threshold-
based error correction codes.

Wear Leveling: NAND ﬂash has a limit to the number of
times data can be written to a block before it fails. Many
devices, then, implement wear leveling, in which all writes
are systematically written to new locations, preventing some
blocks from failing far earlier than others. This has impli-
cations for both encrypting and deniable ﬁle systems: wear
leveling mechanisms may persist old versions of encrypted
data, providing an adversary with a timeline of changes made
to disk, and thus, an ability to differentiate between claimed
and actual disk activity. Wear leveling undermines any ﬁle
system whose security is predicated on the ability to overwrite
data. Any secure ﬁle system designed for ﬂash-based storage
should be secure and compatible with drives that either do or
do not manage their own wear leveling.

Easily Deployable: To have the broadest impact, a deniable

VI. DESIGN OVERVIEW

DEFY is designed as an extension to the YAFFS ﬁle
system, with security features inspired by WhisperYAFFS. We
chose YAFFS because it is designed to operate on raw NAND
ﬂash, handles wear leveling, is widely-deployed, and is open-
source. To YAFFS we add authenticated encryption, crypto-
graphic secure deletion, and support for multiple deniability
levels that are resistant to strong adversaries. A comparison of
DEFY’s features with existing work appears in Table I. The
following provides a high-level description of DEFY’s main
design features.

Deniability Levels: DEFY supports one or more deniability
levels, each associated with a level directory, and permits the
dynamic creation of levels. Each level directory exists under
the root directory of the ﬁle system. All ﬁles for a deniability
level are located below its level directory. Each deniability
level is associated with a unique name and cryptographic key,
derived from a user-provided password. The system maintains
no record of what levels exist in the system; it can only know
which levels are currently open. When a user reveals a level,
all lower levels are also revealed. This is a convenience, helps
to minimize the chance of overwriting (since only unrevealed
levels risk overwriting), and follows the conventions of previ-
ous work.

Assigning deniability to directories at the root level is
strategic and provides a number of advantages. Level direc-
tories allow for easy inheritance of deniability levels. Objects
created within a directory will, by default, inherit the level
of that directory, i.e. be correctly encrypted at the appro-
priate level. We believe this behavior to be quite natural,
following the tradition of other security semantics (e.g. ﬁle
system permissions), and frees users of the burden of assigning
deniability levels to individual ﬁles. Separating deniability
level namespaces through level directories, also forces users
to be more thoughtful, and perhaps, careful about how they
categorize the sensitivity of their data.

Authenticated Encryption: The two key challenges associ-
ated in implementing authenticated encryption in DEFY are:
(1) designing a ﬁle system that can accommodate the data

5

Input: Data Page (cid:104)d1, . . . , dm(cid:105) with page ID id, OOB
data doob, counter x, and per-level keys K(cid:96), M(cid:96)
1: ctr1 ← PAD-128(id||x||1)
2: c1, . . . , cm, coob ← AES-CTRctr1
3: σ ← HMAC-SHA256M(cid:96) (c1, ..., cm, coob)
4: ctr2 ← PAD-128(id||x||0)
5: x1, . . . , xm, xoob ← AES-CTRctr2
6: t ← σ ⊕ x1... ⊕ xm ⊕ xoob
Output: Tag t, Page (cid:104)x1, . . . , xm(cid:105) and OOB xoob

(d1, . . . , dm, doob)

(c1, ..., cm, coob)

K(cid:96)

σ

Input: Encrypted Page (cid:104)x1, . . . , xm(cid:105) with page ID id,
OOB data xoob, counter x, tag t, per-level keys K(cid:96), M(cid:96)
1: ctr2 ← PAD-128(id||x||0)
2: σ ← t ⊕ x1 ⊕ . . . ⊕ xm ⊕ xoob
3: c1, . . . , cm, coob ← AES-CTRctr2
4: σ(cid:48) ← HMAC-SHA256M(cid:96) (c1, . . . , cm, coob)
5: if σ(cid:48) (cid:54)= σ return ⊥
6: ctr1 ← PAD-128(id||x||1)
7: d1, . . . , dm, doob ← AES-CTRctr1
Output: Page (cid:104)d1, . . . , dm(cid:105), OOB doob

(x1, . . . , xm, xoob)

(c1, . . . , cm, coob)

K(cid:96)

σ

(a) AON Encryption.

(b) AON Decryption.

Fig. 1: Authenticated encryption/decryption for a page using the all-or-nothing transform in DEFY.

expansion that results from authentication and, (2) designing an
encryption scheme that is supportive of efﬁcient and granular
secure deletion. Here, we focus our discussion on the former,
leaving a discussion of the latter for the next section.

DEFY’s encryption scheme is presented in Figure 1. The
algorithm takes as input a data page, broken into m, 128-
bit messages (d1, . . . , dm), the OOB data (doob), a unique
page identiﬁer (id), a unique global counter (x), a per-level
encryption key (K(cid:96)) and a per-level MAC key (M(cid:96)). The
algorithm implements an encrypt-then-MAC scheme: ﬁrst en-
crypting the page and OOB data using AES in counter mode
(AES-CTR), then MACing the resulting ciphertext using a
SHA-based message authentication code (HMAC-SHA256).
An additional encryption using AES-CTR using the authen-
ticator as the key is performed to complete an all-or-nothing
transform (described later). A tag (t) is created by XOR-ing
the ciphertext blocks (x1, . . . , xm, xoob) with the authenticator
(σ). This small tag is not secret; rather, it is an expansion of
the encrypted data and is subject to the all-or-nothing property.
The encrypted page (x1, . . . , xm) is written to disk as data, the
encrypted OOB data (xoob) is written to the OOB area, and
the tag (t) is stored as metadata in the parent object.

The same counter and key pair should never be used for
encryption more than once. For the block cipher in counter
mode, we extract a unique counter value, padding this to
128-bits in length using some appropriate padding scheme
(PAD-128). This value is derived from the page’s physical
disk address (id) and a global sequence counter (x); both
are associated with a DEFY object and, by policy, are non-
repeatable in a ﬁle system. The encryption key and MAC key
are also distinct between levels.

We remark that other constructions for achieving all-or-
nothing encryption, leveraging other cryptographic modes and
algorithms, may provide better performance or a more elegant
design. For example, Steps 1–3 of Figure 1a may be combined
into a single call of OCB mode [39], which requires only
one pass over the data to be made and is fully parallelizable.
Our construction acts as proof-of-concept and an exemplar for
achieving our design goals.

Encryption-Based Deletion: The same AON transform that
provides authenticated encryption, also provides a means for
efﬁcient secure deletion. The original AON transform, due to
Rivest [38], is a cryptographic function that, given only a par-

tial output, reveals nothing about its input. No single message
of a ciphertext can be decrypted in isolation without decrypting
the entire ciphertext. The original intention of the transform
was to provide additional complexity to exhaustive search
attacks, by requiring an attacker to decrypt an entire message
for each key guess. AON has been proposed to make secure
an RSA padding scheme [11], to make efﬁcient smart-card
transactions [12], [13], [24], message authentication [19], and
threshold-type cryptosystems using symmetric primitives [8].
Our design implements an encryption-based secure deletion
scheme based on Peterson et al.’s AON technique for secure
deletion of versioned data [34]. The all-or-nothing transform
allows any subset of a ciphertext block to be deleted (e.g.
through overwriting) in order to delete the entire ciphertext;
without all ciphertext blocks, the page can never be decrypted.
When combined with authenticated encryption, the AON trans-
form creates a message expansion that is bound to the same
all-or-nothing property. This small expansion becomes the
tag and can be efﬁciently overwritten to securely delete the
corresponding page. Indeed, message expansion is fundamental
to our deletion model and the AON transform is a natural
construct for providing efﬁcient secure deletion for DEFY, as
it minimizes the amount of data needed to be overwritten,
does not complicate key management, and conforms to our
hierarchical deletion model.

Metadata for DEFY: Metadata in YAFFS have been re-
purposed to support authenticated encryption and secure dele-
tion. Every DEFY metadata object supports the storage of tags
for its child objects: data pages in the case of a ﬁle object,
or ﬁle objects in the case of a directory object. When a child
object is modiﬁed, the parent object is updated with a new tag,
overwriting the previous tag, securely deleting the old object.
As a result of storing a new tag, the parent object is modiﬁed.
Thus, creating, deleting or modifying an object in DEFY will
trigger a tag cascade for all directory objects in that object’s
path, up to the ﬁle system root. See Figure 2 for a simpliﬁed
overview of DEFY’s hierarchical metadata design.

Tags for the level directory are collocated in a tag storage
area (TSA), which is managed separately from the rest of
the ﬁle system. When the level tags are updated, they are
written to a new block, and the previous version is erased and
re-written with pseudo-random data. The approach of using
a specially-managed area of ﬂash storage to achieve secure
deletion is akin to the strategies proposed by Reardon et al.

6

read and write operations, both unbuffered and buffered. We
believe these characterize the most common and I/O-bound
operations for a ﬁle system.

With each test, IOZone performs an I/O operation on a
number of uniformly-sized ﬁles, up to some maximum size.
For example, when measuring the write performance of a
64KB sized ﬁle, IOZone attempts to write sixteen 4KB ﬁles,
eight 8KB ﬁles, and so on, up to one 64KB ﬁle. For each
benchmark, we average the throughputs across four runs.
Results, with standard deviations, are presented in Figure 6.

We ﬁnd that DEFY performs comparably with Whis-
perYAFFS, while both DEFY and WhisperYAFFS underper-
form when compared with YAFFS, ext3, and ext4. This is not
unexpected, due in large part to the additional computation
requirements necessary to support their cryptographic opera-
tions. It is notable that these results suggest our AON transform
comes at an expense similar to AES in XTS mode [20],
used by WhisperYAFFS. Further, we believe the additional
computational and I/O requirements for tag cascading have
little to no impact on normal ﬁle system operations.

We also ﬁnd that the number of deniability levels has little
effect on ﬁle system performance. We conﬁgured a DEFY
partition with three deniability levels and performed the same
IOZone benchmarks mounted under all three levels (i.e. one
level, two level, and all levels revealed). Figure 7 presents the
results. These ﬁndings demonstrate that performance in DEFY
is an artifact of IO irrespective of the number of revealed (or
unrevealed) levels. DEFY’s log-structured nature writes new
data to the head of the log, regardless from which level is per-
forming the write. Writing data from many levels concurrently
may cause a single level’s blocks to be fragmented across the
device, which could lead to poor sequential read performance
for rotating media. Indeed, poor sequential read performance
is a contributing factor to why log-structured ﬁles systems
has not been more widely adopted. However, the uniform
random access performance of solid state drives render data
non-contiguity largely irrelevant, allowing system engineer’s
to once again enjoy the manifold beneﬁts of a log structure
(e.g. implicit versioning, inherent consistency, and simpliﬁed
data structures).

X. DENIABLE FILESYSTEMS IN PRACTICE

We remark that the use of deniable ﬁle systems from social,
legal, and usability perspectives has not been well-explored
in the literature. In particular, all deniable ﬁle systems to
date employ user passwords for securing ﬁles at a certain
deniability level. This allows an adversary to undermine plau-
sible deniability at the cost of a password-guessing attack. In
our adversarial setting, some password protection mechanisms
can be successfully utilized (e.g., using password-based key
derivation functions to increase the cost of brute force attacks)
while others cannot. For example, although not needed, pass-
word salts for each level’s password, would need to be stored
somewhere persistent and, thus, could undermine plausible
deniability. Similarly, key management
techniques used in
traditional disk encryption software, such as key wrapping [7],
[31], [40], could likewise undermine deniability. Currently, all
deniable ﬁle systems demand the user select good passwords,
and DEFY is no exception to this.

Relatedly, attacks against deniable ﬁle systems may be
possible when adversaries have access to data from external
sources (“hints”) or are otherwise unconstrained by the single-
view and snapshot models. For example, Skillen and Mannan
propose a “colluding carrier” attack [46], where the adversary
colludes with a wireless provider or ISP (e.g., through govern-
mental writ), collecting network trace data to aid later forensic
analysis of the device. Discrepancies between the device logs
and the carrier’s logs may enable an adversary to conclude
the presence of hidden data, and compel hidden levels to be
revealed. Skillen and Mannan make suggestions to restrict
these threats to deniable ﬁle systems for mobile devices,
including disabling wireless connectivity (or limiting network
connectivity to WiFi only) during privileged use, and using
multiple SIM cards and carriers to make log collection difﬁcult.
We, too, acknowledge DEFY’s limitations to resist this type
of attack, and suggest that users follow those same practices
in countries where carriers may assist forensic investigation.

More generally, we ﬁnd the ultimate guarantees of deniable
ﬁle systems have not been critically examined. In all existing
deﬁnitions, the onus is on the adversary to prove that the
system contains hidden data. This reﬂects the presumption of
innocence common in many legal systems, i.e. the adversary
must prove the user’s guilt and until then she is presumed
innocent. Given that adversaries have been known to torture
individuals for their passwords [47], it is unclear if a system
founded upon this tenant is viable for use in truly hostile
environments. In practice, the very existence of a deniable ﬁle
system may draw unwanted attention. To a casual observer,
DEFY looks and behaves like a full-disk encryption scheme,
so that revealing a single level may be convincing.

XI. CONCLUSION

We have presented DEFY, a deniable ﬁle system for solid-
state memory, usable as a ﬁle system for mobile devices
and laptops. Current design patterns for deniable ﬁle systems
cannot be easily adapted for many mobile devices; this is
largely due to system design assumptions about the storage
media that, while valid for many settings, are inappropriate
for solid-state drives. The physical properties of solid-state
memory require wear leveling and disallow in-place updates,
motivating our use of a log-structured ﬁle system. Thus, DEFY
is the ﬁrst log-structured deniable ﬁle system. At ﬁrst glance,
log-structured systems appear to deeply conﬂict with the goal
of empowering a user to deny actions from the recent past.
We apply techniques from a secure, versioning ﬁle system
in a completely new way, to support a log-structure with a
deniable history. As the ﬁrst deniable ﬁle system designed
for log-structured storage, we believe DEFY ﬁlls a gap in
the space of privacy enhancing technologies for devices using
solid-state drives, such as mobile devices. DEFY also supports
other features useful in a mobile setting, including authen-
ticated encryption and ﬁne-grained secure deletion of data.
Our DEFY prototype implementation is based on YAFFS and
WhisperYAFFS, and is released as an open-source project on
BitBucket1. Preliminary evaluation demonstrates performance
similar to that experienced with full-disk encryption on these
devices, i.e., WhisperYAFFS.

1https://bitbucket.org/solstice/defy/

11

ACKNOWLEDGMENTS

The authors would like to thank the NDSS program
committee for their very constructive feedback, Hayawardh
Vijayakumar for feedback on a pre-publication version of this
paper, and LT M. Chase Smith for earlier work on a related
DEFY design. Our thanks to the YAFFS and WhisperYAFFS
developers for their respective contributions to the free and
open-source software movement.

REFERENCES

[1]

[2]

[3]

“UBIFS - A UBI File System,” October 2008, http://www.linux-
mtd.infradead.org/doc/ubifs.html.
“Martus case studies: The global human rights abuse reporting system,”
2012, https://www.martus.org/resources/case studies.shtml.
[Online].
Available: https://www.martus.org/resources/case studies.shtml
“GuardianProject/ChatSecure:Android,”
https://guardianproject.info/apps/chatsecure.
“GuardianProject/Orbot,” 2014, https://guardianproject.info/apps/orbot/.
“Lookout/lookout mobile security,” 2014, https://www.lookout.com/.
“Truecrypt,” 2014, http://www.truecrypt.org/.

[4]
[5]
[6]
[7] Accredited Standards Committee, X9, Inc., “ANS X9.102- Wrapping of
Keys and Associated Data,” http://eprint.iacr.org/2004/340.pdf, Novem-
ber 2004.

2014,

[8] R. Anderson, “The dancing bear – a new way of composing ciphers,”
in Proceedings of the International Workshop on Security Protocols,
April 2004.

[9] R. Anderson, R. Needham, and A. Shamir, “The steganographic ﬁle
system,” in Information Hiding, Second International Workshop (IH
’98), Portland, Oregon, USA, April 1998, pp. 73–82.

[10] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway, “A Concrete Security
Treatment of Symmetric Encryption,” in Proceedings of the Annual
Symposium on Foundations of Computer Science, 1997, pp. 394–403.
[11] M. Bellare and C. Namprempre, “Authenticated Encryption: Relations
among notions and analysis of the generic composition paradigm,”
in Advances in Cryptology - Asiacrypt’00 Proceedings, vol. 1976.
Springer-Verlag, 2000, lecture Notes in Computer Science.

[12] M. Blaze, “High-bandwidth encryption with low-bandwidth smart-
cards,” in Fast Software Encryption, vol. 1039, 1996, pp. 33–40, lecture
Notes in Computer Science.

[13] M. Blaze, J. Feigenbaum, and M. Naor, “A formal treatment of remotely
keyed encryption,” in Advances in Cryptology – EUROCRYPT ’98, vol.
1403, 1998, pp. 251–265, Lecture Notes in Computer Science.

[14] M. Blaze, “A cryptographic ﬁle system for UNIX,” in Proceedings of
the ACM Conference on Computer and Communications Security, 1993,
pp. 9–16.

[15] D. Boneh and R. Lipton, “A revocable backup system,” in Proceedings

of the USENIX Security Symposium, July 1996, pp. 91–96.

[16] R. Canetti, C. Dwork, M. Naor, and R. Ostrovsky, “Deniable encryp-

tion,” Advances in Cryptology — CRYPTO ’97, pp. 90–104, 1997.

[17] A. Czekis, D. J. St Hilaire, K. Koscher, S. D. Gribble, T. Kohno, and
B. Schneier, “Defeating encrypted and deniable ﬁle systems: Truecrypt
v5.1a and the case of the tattling os and applications,” 3rd USENIX
Workshop on Hot Topics in Security (HotSec ’08), 2008.

[18] D. Defreez, “Android privacy through encryption,” Master’s thesis,
Southern Oregon University, May 2012, available at http://goo.gl/
94HBb.

[19] Y. Dodis and J. An, “Concealment and its applications to authenticated
encryption,” in Advances in Cryptology – EUROCRYPT ’03, vol. 2656,
2003, Lecture Notes in Computer Science.

[20] M. Dworkin, “Recommendation for block cipher modes of operation:
The XTS-AES mode for conﬁdentiality on storage devices,” National
Institute of Standards and Technology, NIST Special Publication SP-
800-38E, January 2010.

[21] S. L. Garﬁnkel and A. Shelat, “Remembrance of data passed: A study
of disk sanitization practices,” IEEE Security and Privacy, vol. 1, no. 1,
pp. 17–27, 2003.

[22] P. Gasti, G. Ateniese, and M. Blanton, “Deniable cloud storage: sharing
ﬁles via public-key deniability,” in WPES ’10: Proceedings of the 9th
annual ACM workshop on Privacy in the electronic society, Oct. 2010.
[23] P. Gutmann, “Secure deletion of data from magnetic and solid-state
memory,” in Proceedings of the USENIX Security Symposium, July
1996, pp. 77–90.

[24] M. Jakobsson, J. Stern, and M. Yung, “Scramble all. Encrypt small.” in
Fast Software Encryption, vol. 1636, 1999, lecture Notes in Computer
Science.

[25] B. Kaliski, “PKCS #5: Password-based cryptography speciﬁcation,”
IETF Network Working Group, Request for Comments RFC 2898, Sept.
2000.
J. Lee, S. Yi, J. Heo, S. Y. Shin, and Y. Cho, “An Efﬁcient Secure
Deletion Scheme for Flash File Systems,” Journal of Information
Science and Engineering, vol. 26, pp. 27–38, 2010.

[26]

[27] C. Manning, “How YAFFS works,” 23 May 2012, available at http:

//goo.gl/0Mdja.

[28] A. D. Mcdonald and M. G. Kuhn, “StegFS: A steganographic ﬁle system

[29]

for Linux,” in Information Hiding, 1999.
J. Mull, “How a Syrian refugee risked his life to bear witness to atroc-
ities,” March 2012, toronto Star Online; posted 14-March-2012. [On-
line]. Available: http://www.thestar.com/news/world/2012/03/14/how
a syrian refugee risked his life to bear witness to atrocities.html

[30] T. M¨uller and M. Spreitzenbarth, “Frost: Forensic recovery of scrambled
telephones,” in Applied Cryptography and Network Security (ACNS’13),
2013, pp. 373–388.

[31] National Institute of Standards and Technology, “AES key wrap speci-

ﬁcation,” November 2001.

[32] W. Norcott

and D. Capps,

http://www.iozone.org/.

“IOzone ﬁlesystem benchmark,”

[33] H. Pang, K. lee Tan, and X. Zhou, “StegFS: A Steganographic File
the International Conference on Data

System,” in Proceedings of
Engineering, 2003.

[34] Z. N. J. Peterson, R. Burns, J. Herring, A. Stubbleﬁeld, and A. D.
Rubin, “Secure Deletion for a Versioning File System,” in Proceedings
of the USENIX Conference on File and Storage Technologies, 2005.

[35] N. Provos and D. Mazieres, “A future-adaptable password scheme,” in

Proceedings of the USENIX Annual Technical Conference, 1999.
J. Reardon, S. Capkun, and D. Basin, “Data node encrypted
ﬁle
in
the USENIX Security Symposium, 2012, pp.
Proceedings of
333–348.
https://www.usenix.org/conference/
usenixsecurity12/technical-sessions/presentation/reardon

secure deletion for ﬂash memory,”

[Online]. Available:

system: Efﬁcient

[36]

[37] Reporters Without Borders, “Internet enemies,” 12 March 2012, avail-

able at http://goo.gl/x6zZ1.

[38] R. L. Rivest, “All-or-nothing encryption and the package transform,” in
Fast Software Encryption Conference, vol. 1267, 1997, pp. 210–218,
lecture Notes in Computer Science.

[39] P. Rogaway, M. Bellare, J. Black, and T. Krovet, “OCB: A block-
cipher mode of operation for efﬁcient authenticated encryption,” in
Proceedings of the ACM Conference on Computer and Communications
Security, November 2001, pp. 196–205.

[40] P. Rogaway and T. Shrimpton, “Deterministic authenticated-encryption
a provable-security treatment of the key-wrap problem,” in Advances
in Cryptology – EUROCRYPT 06, vol. 4004, 2007, Lecture Notes in
Computer Science.

[41] M. Rosenblum and J. K. Ousterhout, “The Design and Implementation
of a Log-Structured File System,” Operating Systems Review, vol. 25,
pp. 1–15, 1991.

[42] S. Schmitt, M. Spreitzenbarth, and C. Zimmermann, “Reverse engi-
neering of the Android ﬁle system (YAFFS2),” Friedrich-Alexander-
Universit¨at Eriangen-N¨urnberg, Tech. Rep. CS-2011-06, 2011.

[43] B. Schneier, ““Evil maid” attacks on encrypted hard drives,” 23 Oct.
2009, http://goo.gl/Z1Kny. [Online]. Available: https://www.schneier.
com/blog/archives/2009/10/evilmaidattac.html

[44] M. Seltzer, K. Bostic, M. K. McKusick, and C. Staelin, “An implemen-
tation of a log-structured ﬁle system for UNIX,” in Proceedings of the
Winter USENIX Technical Conference, January 1993, pp. 307–326.

12

“GitHub: WhisperSystems/RedPhone,” http://goo.gl/Mmz9s, Whisper-
Systems, 2012.
“GitHub: WhisperSystems/TextSecure,” http://goo.gl/3qoV8, Whisper-
Systems, 2012.
“GitHub: WhisperSystems/WhisperYAFFS: Wiki,” http://goo.gl/Qsku4,
WhisperSystems,
https://github.com/
WhisperSystems/WhisperYAFFS/wiki

[Online]. Available:

2012.

[52] C. P. Wright, M. C. Martino, and E. Zadok, “Ncryptfs: A secure and
convenient cryptographic ﬁle system,” in Proceedings of the USENIX
Technical Conference, 2003, pp. 197–210.

[45] A. Skillen, “Deniable storage encryption for mobile devices,” Master’s

thesis, Concordia University, 2013.

[46] A. Skillen and M. Mannan, “On implementing deniable storage
encryption for mobile devices,” in Proceedings of the Network and
Distributed System Security Symposium, February 2013.
[Online].
Available: http://spectrum.library.concordia.ca/975074/

[49]

[50]

[51]

[47] M. Weaver, “Developer tortured by raiders with crowbars,” Daily

Telegraph, 31 October 1997.

[48] M. Wei, L. M. Grupp, F. E. Spada, and S. Swanson, “Reliably erasing
data from ﬂash-based solid state drives,” in Proceedings of the USENIX
Conference on File and Storage Technologies, 2011.

13

